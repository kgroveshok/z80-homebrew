# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 19 1d			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			if BASE_KEV = 1  
001c			 
001c				; need to be at $66 for nmi support 
001c 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0022 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0028 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002e 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0034 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003a 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0040 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0046 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004c 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0052 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0058 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005e 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0064 00 ff			db 0,255 
0066 c3 50 76			jp nmi 
0069			endif 
0069			 
0069			include "firmware.asm" 
0069			  
0069			; main constants (used here and in firmware)  
0069			  
0069			; TODO have page 0 of storage as bios  
0069			  
0069			Device_A: equ 0h  
0069			Device_B: equ 040h          ; Sound  
0069			  
0069			if BASE_KEV  
0069			Device_C: equ 080h          ; Storage and ext cart devices  
0069			endif  
0069			  
0069			if BASE_SC114  
0069			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0069			endif  
0069			  
0069			if BASE_CPM  
0069			; TODO fixup for CPM  
0069			Device_C: equ 080h          ; Storage and ext cart devices  
0069			endif  
0069			  
0069			Device_D: equ 0c0h             ; Keyboard and LCD  
0069			  
0069			; Odd specific debug points for testing hardware dev  
0069			  
0069			DEBUG_SOUND: equ 0       
0069			DEBUG_STK_FAULT: equ 0  
0069			DEBUG_INPUT: equ 0     ; Debug input entry code  
0069			DEBUG_KEYCINWAIT: equ 0  
0069			DEBUG_KEYCIN: equ 0  
0069			DEBUG_KEY: equ 0  
0069			DEBUG_KEY_MATRIX: equ 0  
0069			DEBUG_STORECF: equ 0  
0069			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0069			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0069			DEBUG_SPI: equ 0    ; low level spi tests  
0069			  
0069			; Enable many break points  
0069			  
0069			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0069			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0069			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0069			DEBUG_FORTH_JP: equ 0    ; 4  
0069			DEBUG_FORTH_MALLOC: equ 0  
0069			DEBUG_FORTH_MALLOC_INT: equ 0  
0069			DEBUG_FORTH_DOT: equ 1  
0069			DEBUG_FORTH_DOT_WAIT: equ 0  
0069			DEBUG_FORTH_MATHS: equ 0  
0069			DEBUG_FORTH_TOK: equ 0    ; 4  
0069			DEBUG_FORTH_PARSE: equ 0    ; 3  
0069			DEBUG_FORTH: equ 0  ;2  
0069			DEBUG_FORTH_WORDS: equ 1   ; 1  
0069			DEBUG_FORTH_PUSH: equ 1   ; 1  
0069			DEBUG_FORTH_UWORD: equ 1   ; 1  
0069			  
0069			; Enable key point breakpoints  
0069			  
0069			DEBUG_FORTH_DOT_KEY: equ 0  
0069			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0069			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0069			  
0069			; Debug stack imbalances  
0069			  
0069			ON: equ 1  
0069			OFF: equ 0  
0069			  
0069			DEBUG_STACK_IMB: equ 0  
0069			STACK_IMB_STORE: equ 20  
0069			  
0069			; House keeping and protections  
0069			  
0069			DEBUG_FORTH_STACK_GUARD: equ 1  
0069			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0069			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0069			FORTH_ENABLE_FREE: equ 0  
0069			FORTH_ENABLE_MALLOCFREE: equ 1  
0069			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0069			FORTH_ENABLE_FLOATMATH: equ 0  
0069			  
0069			  
0069			CALLMONITOR: macro  
0069			;	call break_point_state  
0069			; now use the break point debug vector  
0069				call debug_vector  
0069				endm  
0069			  
0069			MALLOC_1: equ 1        ; from dk88   
0069			MALLOC_2: equ 0           ; broke  
0069			MALLOC_3: equ 0           ; really broke  
0069			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0069			  
0069			if BASE_KEV   
0069			stacksize: equ 256  
0069			  
0069			STACK_RET_SIZE: equ 64  
0069			STACK_LOOP_SIZE: equ 128  
0069			STACK_DATA_SIZE: equ 512  
0069			endif  
0069			if BASE_SC114  
0069			;tos:	equ 0f000h  
0069			stacksize: equ 256  
0069			STACK_RET_SIZE: equ 64  
0069			STACK_LOOP_SIZE: equ 128  
0069			STACK_DATA_SIZE: equ 256  
0069			endif  
0069			  
0069			if BASE_CPM  
0069			;tos:	equ 0f000h  
0069			stacksize: equ 256  
0069			STACK_RET_SIZE: equ 64  
0069			STACK_LOOP_SIZE: equ 128  
0069			STACK_DATA_SIZE: equ 256  
0069			endif  
0069			  
0069			;if STORAGE_SE == 0  
0069			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0069			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0069			;endif  
0069			  
0069			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0069			  
0069			STORE_0_AUTORUN: equ $20  
0069			  
0069			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0069			  
0069			STORE_0_AUTOFILE: equ $21  
0069			STORE_0_BANKRUN: equ $23  
0069			STORE_0_FILERUN: equ $24  
0069			  
0069			; Block 0 offsets for settings  
0069			  
0069			; if set then skip prompt for start up and accept all  
0069			  
0069			STORE_0_QUICKSTART: equ $25  
0069			  
0069			; Blocks where directory table is held  
0069			  
0069			; Reducing the number of entries increases the max file size  
0069			  
0069			;STORE_DIR_START: equ 1  
0069			;STORE_DIR_END: equ 33  
0069			  
0069			; Blocks from where file data is stored  
0069			  
0069			;STORE_DATA_START: equ STORE_DIR_END + 1  
0069			  
0069			; Block indicators (<32 are data files)  
0069			  
0069			;STORE_BLOCK_CFG: equ $8f       ; config block  
0069			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0069			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0069			;STORE_BLOCK_FREE: equ $85       ; data block free  
0069			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0069			  
0069			  
0069			  
0069			; Directory entry flags  
0069			  
0069			;STORE_DIR_FREE: equ 0  
0069			;STORE_DIR_FILE:  equ 1  
0069			  
0069			; Structure offsets to directory entries  
0069			;STORE_DE_FLAG: equ 0  
0069			;STORE_DE_MAXEXT: equ 1  
0069			;STORE_DE_FILENAME: equ 2  
0069			  
0069			; Structure offsets to block 0  
0069			  
0069			;STORE_BK0_ISFOR: equ 1  
0069			;STORE_BK0_LABEL: equ 3  
0069			  
0069			; memory allocation   
0069			  
0069			chk_stund: equ tos+2           ; underflow check word  
0069			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0069			  
0069			; keyscan table needs rows x cols buffer  
0069			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0069			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0069			  
0069			keyscan_table_row1: equ chk_stovr -key_cols-1  
0069			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0069			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0069			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0069			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0069			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0069			keyscan_scancol: equ keyscan_table-key_cols  
0069			;keyscan_table_len: equ key_rows*key_cols  
0069			;keybufptr: equ keyscan_table - 2  
0069			;keysymbol: equ keybufptr - 1  
0069			key_held: equ keyscan_scancol-1	; currently held  
0069			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0069			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0069			key_fa: equ key_repeat_ct -1 ;  
0069			key_fb: equ key_fa -1 ;  
0069			key_fc: equ key_fb -1 ;  
0069			key_fd: equ key_fc -1 ;  
0069			key_face_held: equ key_fd - 1   
0069			  
0069			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0069			  
0069			hardware_config: equ key_face_held - 10  
0069			  
0069			; hardware config switches  
0069			; TODO add bitmasks on includes for hardware  
0069			; high byte for expansion ids  
0069			;     0000 0000  no card inserted  
0069			;     0000 0001  storage card inserted  
0069			;     0000 0010  spi sd card active  
0069			  
0069			;       
0069			; low byte:  
0069			;     0000 0001   4x4 keypad  
0069			;     0000 0010   full keyboard  
0069			;     0000 0011   spi/ext keyboard  
0069			;     0000 0100   20x4 lcd  
0069			;     0000 1000   40x4 lcd  
0069			;     0000 1100   spi/ext display  
0069			;     0001 0000   ide interface available  
0069			  
0069			hardware_word: equ hardware_config - 2  
0069			  
0069			; debug marker - optional display of debug point on the debug screens  
0069			  
0069			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
0069			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
0069			  
0069			debug_mark: equ debug_vector - 4  
0069			  
0069			; input_str vars  
0069			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0069			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0069			input_size: equ input_start -1  ; number of chars  
0069			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0069			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0069			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0069			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0069			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0069			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0069			input_len: equ input_cur_onoff - 5 ; length of current input  
0069			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0069			  
0069			CUR_BLINK_RATE: equ 15  
0069			  
0069			key_actual_pressed: equ input_cursor - 1   
0069			key_symbol: equ key_actual_pressed - 1   
0069			key_shift: equ key_symbol - 1   
0069			  
0069			; Display allocation  
0069			  
0069			;display_rows: equ 4     ; move out to mini and mega files  
0069			;display_cols: equ 20  
0069			  
0069			display_fb_len: equ display_rows*display_cols  
0069			  
0069			; primary frame buffer     
0069			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0069			; working frame buffers  
0069			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0069			display_fb3: equ  display_fb1-display_fb_len - 1  
0069			display_fb2: equ  display_fb3-display_fb_len - 1  
0069			;  
0069			; pointer to active frame buffer  
0069			display_fb_active: equ display_fb2 - 2  
0069			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0069			display_write_tmp: equ display_lcde1e2 - 2  
0069			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
0069			  
0069			;  
0069			  
0069			;; can load into de directory  
0069			cursor_col: equ display_active-1  
0069			cursor_row: equ cursor_col-1  
0069			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0069			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0069			  
0069			; maths vars  
0069			  
0069			LFSRSeed: equ cursor_shape -20   
0069			randData: equ LFSRSeed - 2  
0069			xrandc: equ randData - 2  
0069			stackstore: equ xrandc - 2  
0069			seed1: equ  stackstore -2   
0069			seed2: equ seed1 - 2  
0069			  
0069			; cf storage vars  
0069			  
0069			iErrorNum:  equ seed2-1         ;Error number  
0069			iErrorReg:  equ iErrorNum -1              ;Error register  
0069			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0069			  
0069			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0069			  
0069			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
0069			  
0069			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
0069			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0069			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
0069			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
0069			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
0069			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
0069			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0069			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0069			store_tmpid: equ store_tmp3 - 1		; page temp id  
0069			store_tmpext: equ store_tmpid - 1		; file extent temp  
0069			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
0069			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
0069			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
0069			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0069			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
0069			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0069			;  
0069			; spi vars  
0069			  
0069			  
0069			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
0069			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
0069			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0069			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0069			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0069			spi_device_id: equ spi_device - 1    ; human readable bank number  
0069			  
0069			;;;;; forth cli params  
0069			  
0069			; TODO use a different frame buffer for forth???  
0069			  
0069			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0069			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0069			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0069			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0069			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0069			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0069			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0069			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0069			  
0069			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0069			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0069			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0069			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
0069			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
0069			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0069			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0069			  
0069			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0069			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0069			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0069			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0069			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0069			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0069			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0069			  
0069			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0069			  
0069			; os/forth token vars  
0069			  
0069			os_last_cmd: equ os_var_array-255  
0069			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0069			os_current_i: equ os_cli_cmd-2  
0069			os_cur_ptr: equ os_current_i-2  
0069			os_word_scratch: equ os_cur_ptr-30  
0069			os_tok_len: equ os_word_scratch - 2  
0069			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0069			os_tok_malloc: equ os_tok_ptr - 2  
0069			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0069			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0069			execscratch: equ os_input-255        ; exec cmd eval buffer  
0069			scratch: equ execscratch-255  
0069			  
0069			  
0069			; temp locations for new word processing to save on adding more   
0069			  
0069			os_new_malloc: equ scratch-2  
0069			os_new_parse_len: equ os_new_malloc - 2  
0069			os_new_word_len: equ os_new_parse_len - 2  
0069			os_new_work_ptr: equ os_new_word_len - 2  
0069			os_new_src_ptr: equ os_new_work_ptr - 2  
0069			os_new_exec: equ os_new_src_ptr - 2  
0069			os_new_exec_ptr: equ os_new_exec - 2  
0069			  
0069			; resume memory alloocations....  
0069			  
0069			;os_view_disable: equ os_new_exec_ptr - 1  
0069			os_view_af: equ os_new_exec_ptr - 2  
0069			os_view_hl: equ os_view_af -2  
0069			os_view_de: equ os_view_hl - 2  
0069			os_view_bc: equ os_view_de - 2  
0069			  
0069			; stack checksum word  
0069			if DEBUG_STACK_IMB  
0069				curframe: equ  os_view_de - 5  
0069				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0069				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0069			else  
0069				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0069			endif  
0069			  
0069			; with data stack could see memory filled with junk. need some memory management   
0069			; malloc and free entry points added  
0069			  
0069			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0069			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0069			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0069			;heap_end: equ free_list-1  ; Starting address of heap  
0069			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0069			  
0069			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0069			heap_end: equ chk_word-1  ; Starting address of heap  
0069			  
0069			  
0069			;if BASE_KEV   
0069			;heap_start: equ 0800eh  ; Starting address of heap  
0069			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0069			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0069			;endif  
0069			  
0069			;if BASE_SC114  
0069			;heap_start: equ baseram+15  ; Starting address of heap  
0069			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0069			;endif  
0069			  
0069			  
0069			;;;;  
0069			  
0069			  
0069			; change below to point to last memory alloc above  
0069			topusermem:  equ   heap_start  
0069			  
0069			;if BASE_KEV   
0069			;baseusermem: equ 08000h  
0069			;endif  
0069			  
0069			;if BASE_SC114  
0069			;;aseusermem:     equ    12  
0069			;baseusermem:     equ    prompt  
0069			;;baseusermem:     equ    endofcode  
0069			;endif  
0069			  
0069			  
0069			; **********************************************************************  
0069			; **  Constants  
0069			; **********************************************************************  
0069			  
0069			; Constants used by this code module  
0069			kDataReg:   EQU Device_D           ;PIO port A data register  
0069			kContReg:   EQU Device_D+2           ;PIO port A control register  
0069			  
0069			  
0069			portbdata:  equ Device_D+1    ; port b data  
0069			portbctl:   equ Device_D+3    ; port b control  
0069			  
0069			  
0069			;KEY_SHIFT:   equ 5  
0069			;KEY_SYMBOLSHIFT:  equ 6  
0069			  
0069			KEY_SHIFTLOCK: equ 4  
0069			  
0069			  
0069			KEY_UP: equ 5  
0069			KEY_NEXTWORD: equ 6  
0069			KEY_PREVWORD: equ 7  
0069			KEY_BS: equ 8  
0069			KEY_TAB:  equ 9  
0069			KEY_DOWN: equ 10  
0069			KEY_LEFT: equ 11  
0069			KEY_RIGHT: equ 12  
0069			KEY_CR:   equ 13  
0069			KEY_HOME: equ 14  
0069			KEY_END: equ 15  
0069			  
0069			KEY_F1: equ 16  
0069			KEY_F2: equ 17  
0069			KEY_F3: equ 18  
0069			KEY_F4: equ 19  
0069			  
0069			KEY_F5: equ 20  
0069			KEY_F6: equ 21  
0069			KEY_F7: equ 22  
0069			KEY_F8: equ 23  
0069			  
0069			KEY_F9: equ 24  
0069			KEY_F10: equ 25  
0069			KEY_F11: equ 26  
0069			KEY_F12: equ 27  
0069			  
0069			;if DEBUG_KEY  
0069			;	KEY_MATRIX_NO_PRESS: equ '.'  
0069			;	KEY_SHIFT:   equ '.'  
0069			;	KEY_SYMBOLSHIFT:  equ '.'  
0069			;else  
0069				KEY_SHIFT:   equ '~'  
0069				KEY_SYMBOLSHIFT:  equ '~'  
0069				KEY_MATRIX_NO_PRESS: equ '~'  
0069			;endi  
0069			  
0069			  
0069			  
0069			  
0069			; Macro to make adding debug marks easier  
0069			  
0069			DMARK: macro str  
0069				push af  
0069				ld a, (.dmark)  
0069				ld (debug_mark),a  
0069				ld a, (.dmark+1)  
0069				ld (debug_mark+1),a  
0069				ld a, (.dmark+2)  
0069				ld (debug_mark+2),a  
0069				jr .pastdmark  
0069			.dmark: db str  
0069			.pastdmark: pop af  
0069			  
0069			endm  
0069			  
0069			  
0069			; macro to detect for stack imbalances  
0069			  
0069			include "stackimbal.asm"  
0069			; Macro and code to detect stock imbalances 
0069			 
0069			SPPUSH: equ 0 
0069			 
0069			; Add a stack frame which can be checked before return 
0069			 
0069			STACKFRAME: macro onoff frame1 frame2 
0069			 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069						; save current SP 
0069						exx 
0069			 
0069						ld de, frame1 
0069						ld a, d 
0069						ld hl, curframe 
0069						call hexout 
0069						ld a, e 
0069						ld hl, curframe+2 
0069						call hexout 
0069			  
0069						ld hl, frame1 
0069						push hl 
0069						ld hl, frame2 
0069						push hl 
0069						exx 
0069					endif 
0069					 
0069				endif 
0069			endm 
0069			 
0069			STACKFRAMECHK: macro onoff frame1 frame2 
0069			 
0069					 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069						exx 
0069						; check stack frame SP 
0069			 
0069						ld hl, frame2 
0069						pop de   ; frame2 
0069			 
0069						call cmp16 
0069						jr nz, .spnosame 
0069						 
0069			 
0069						ld hl, frame1 
0069						pop de   ; frame1 
0069			 
0069						call cmp16 
0069						jr z, .spfrsame 
0069			 
0069						.spnosame: call showsperror 
0069			 
0069						.spfrsame: nop 
0069			 
0069						exx 
0069					endif 
0069					 
0069				endif 
0069			 
0069			 
0069			endm 
0069			 
0069			 
0069			; for a sub routine, wrap SP collection and comparisons 
0069			 
0069			; Usage: 
0069			; 
0069			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0069			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0069			 
0069			SAVESP: macro onoff storeword 
0069			 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069						; save current SP 
0069			 
0069						ld (store_sp+(storeword*4)), sp 
0069			 
0069					endif 
0069					 
0069				endif 
0069			 
0069			endm 
0069			 
0069			CHECKSP: macro onoff storeword 
0069			 
0069				if DEBUG_STACK_IMB 
0069					if onoff 
0069			 
0069						; save SP after last save 
0069				 
0069						ld (store_sp+(storeword*4)+2), sp 
0069			 
0069						push hl 
0069						ld hl, store_sp+(storeword*4) 
0069						call check_stack_sp  
0069						pop hl 
0069			 
0069			 
0069					endif 
0069					 
0069				endif 
0069			 
0069			endm 
0069			 
0069			if DEBUG_STACK_IMB 
0069			 
0069			check_stack_sp: 
0069					push de 
0069			 
0069					ld e, (hl) 
0069					inc hl 
0069					ld d, (hl) 
0069					inc hl 
0069			 
0069					push de 
0069			 
0069			 
0069					ld e, (hl) 
0069					inc hl 
0069					ld d, (hl) 
0069					inc hl 
0069			 
0069					pop hl 
0069			 
0069			 
0069					; check to see if the same 
0069			 
0069					call cmp16 
0069					jr z, .spsame 
0069			 
0069					; not same 
0069			 
0069					call showsperror 
0069			.spsame: 
0069			 
0069					pop de 
0069			 
0069					ret 
0069			 
0069			.sperr:  db "Stack imbalance",0 
0069			 
0069			 
0069			showsperror: 
0069			 
0069			 
0069				push hl 
0069				push af 
0069				push de 
0069				call clear_display 
0069				ld de, .sperr 
0069				ld a,0 
0069			;	ld de,os_word_scratch 
0069				call str_at_display 
0069				ld a, display_row_1+17 
0069				ld de, debug_mark 
0069				call str_at_display 
0069				ld a, 0 
0069				ld (curframe+4),a 
0069				ld hl, curframe 
0069				ld de, os_word_scratch 
0069				ld a, display_row_4 
0069				call str_at_display 
0069				call update_display 
0069				;call break_point_state 
0069				call cin_wait 
0069			 
0069			;	ld a, ' ' 
0069			;	ld (os_view_disable), a 
0069				call bp_on 
0069				pop de	 
0069				pop af 
0069				pop hl 
0069				CALLMONITOR 
0069				ret 
0069			 
0069			endif 
0069			 
0069			 
0069			 
0069			; eof 
# End of file stackimbal.asm
0069			  
0069			;TODO macro to calc col and row offset into screen  
0069			  
0069			  
0069			  
0069			hardware_init:  
0069			  
0069				  
0069			  
0069					;ld a, 0  
0069					;ld (hardware_diag), a  
0069			  
0069					; clear all the buffers  
0069			  
0069 21 0d fd				ld hl, display_fb1  
006c 22 c9 fb				ld (display_fb_active), hl  
006f			  
006f cd 9c 0d				call clear_display  
0072			  
0072 21 cb fb				ld hl, display_fb2  
0075 22 c9 fb				ld (display_fb_active), hl  
0078			  
0078 cd 9c 0d				call clear_display  
007b			  
007b					; init primary frame buffer area  
007b 21 ae fd				ld hl, display_fb0  
007e 22 c9 fb				ld (display_fb_active), hl  
0081			  
0081 cd 9c 0d				call clear_display  
0084			  
0084			  
0084 cd 5d 76				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0087			  
0087 cd f4 78			call key_init  
008a cd 48 02			call storage_init  
008d			  
008d				; setup malloc functions  
008d			  
008d				if MALLOC_1  
008d cd 73 14				call  heap_init  
0090				endif  
0090				if MALLOC_4  
0090					call  heap_init  
0090				endif  
0090			  
0090				; init sound hardware if present  
0090			  
0090				if SOUND_ENABLE  
0090					call sound_init  
0090				endif  
0090			  
0090				; lcd test sequence  
0090					  
0090 cd bf 0d			call update_display  
0093 cd df 0c			call delay1s  
0096 3e 2b			ld a,'+'  
0098 cd a1 0d			call fill_display  
009b cd bf 0d			call update_display  
009e cd df 0c			call delay1s  
00a1 3e 2a			ld a,'*'  
00a3 cd a1 0d			call fill_display  
00a6 cd bf 0d			call update_display  
00a9 cd df 0c			call delay1s  
00ac 3e 2d			ld a,'-'  
00ae cd a1 0d			call fill_display  
00b1 cd bf 0d			call update_display  
00b4 cd df 0c			call delay1s  
00b7			  
00b7			; boot splash screen  
00b7			if display_cols == 20	  
00b7			        ld a, display_row_1    
00b7			else  
00b7 3e 0a		        ld a, display_row_1 +10   
00b9			endif  
00b9 11 11 1c			ld de, prom_bootmsg  
00bc cd af 0d			call str_at_display  
00bf cd bf 0d			call update_display  
00c2			  
00c2			  
00c2 cd df 0c			call delay1s  
00c5 cd df 0c			call delay1s  
00c8			if display_cols == 20	  
00c8			            LD   A, display_row_3+2  
00c8			else  
00c8 3e 5c		            LD   A, display_row_3+12  
00ca			endif  
00ca 11 26 1c			ld de, prom_bootmsg1  
00cd cd af 0d			call str_at_display  
00d0 cd bf 0d			call update_display  
00d3 cd df 0c			call delay1s  
00d6 cd df 0c			call delay1s  
00d9			  
00d9			;	ld a, display_row_4+3  
00d9			;	ld de, bootmsg2  
00d9			;	call str_at_display  
00d9			;	call update_display  
00d9			;	call delay1s  
00d9			;	call delay1s  
00d9			  
00d9			; debug mark setup  
00d9			  
00d9 3e 5f		ld a, '_'  
00db 32 68 fe		ld (debug_mark),a  
00de 32 69 fe		ld (debug_mark+1),a  
00e1 32 6a fe		ld (debug_mark+2),a  
00e4 3e 00		ld a,0  
00e6 32 6b fe		ld (debug_mark+3),a  
00e9			  
00e9 c9					ret  
00ea			  
00ea			  
00ea			;bootmsg2:	db "Firmware v0.1",0  
00ea			  
00ea			; a 4x20 lcd  
00ea			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ea			  
00ea			;if display_cols == 20  
00ea			;	include "firmware_lcd_4x20.asm"  
00ea			;endif  
00ea			  
00ea			;if display_cols == 40  
00ea			;	include "firmware_lcd_4x40.asm"  
00ea			;endif  
00ea			  
00ea			;  
00ea			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ea			; TODO abstract the bit bang video out interface for dual display  
00ea			; TODO wire video out to tx pin on rc2014 bus  
00ea			  
00ea			; must supply cin, and cin_wait for low level hardware abstraction   
00ea			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ea			; test scancode  
00ea			  
00ea			;;;;;  
00ea			;;;  
00ea			; Moved out to mini and maxi versions  
00ea			;  
00ea			; include "firmware_key_4x4.asm"  
00ea			; using existing 4 wire x 4 resistor array for input  
00ea			;include "firmware_key_4x10.asm"  
00ea			; need to mod the board for 5 rows due to resistor array  
00ea			;include "firmware_key_5x10.asm"  
00ea			  
00ea			; storage hardware interface  
00ea			  
00ea			; use microchip serial eeprom for storage  
00ea			  
00ea			  
00ea			if STORAGE_SE  
00ea				include "firmware_spi.asm"  
00ea			; my spi protocol (used by storage) 
00ea			 
00ea			; SPI pins 
00ea			 
00ea			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ea			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ea			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ea			 
00ea			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ea			; chip pin 4 gnd 
00ea			 
00ea			 
00ea			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ea			SPI_CE1: equ 1      ;    port a1 pin 14  
00ea			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ea			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ea			SPI_CE4: equ 4      ; port a4     pin 10 
00ea			 
00ea			; active low AND masks 
00ea			 
00ea			;SPI_CE0_MASK: equ    255-1 
00ea			;SPI_CE1_MASK: equ   255-2 
00ea			;SPI_CE2_MASK: equ   255-4 
00ea			;SPI_CE3_MASK: equ   255-8 
00ea			;SPI_CE4_MASK: equ   255-16 
00ea			SPI_CE_HIGH:  equ 255 
00ea			 
00ea			 
00ea			 
00ea			;  Perform SCLK wait pulse 
00ea			 
00ea			spi_clk: 
00ea f5				push af 
00eb 3a 61 fa			ld a, (spi_clktime) 
00ee fe 00			cp 0 
00f0 28 03			jr z, .scskip 
00f2 cd c4 0c			call aDelayInMS 
00f5			.scskip: 
00f5 f1				pop af 
00f6 c9				ret 
00f7			 
00f7			 
00f7			 
00f7			; TODO store port id for spi device ie dev c 
00f7			; TODO store pin for SO 
00f7			; TODO store pin for SI 
00f7			; TODO store pin for SCLK 
00f7			 
00f7			; 
00f7			 
00f7			; ensure that spi bus is in a stable state with default pins  
00f7			 
00f7			se_stable_spi:   
00f7			 
00f7				 ; set DI high, CE high , SCLK low 
00f7				;ld a, SPI_DI | SPI_CE0 
00f7 3e 07			ld a, SPI_DI  
00f9 cd 03 02			call spi_ce_high 
00fc d3 80			 out (storage_adata),a 
00fe 32 5e fa			ld (spi_portbyte),a 
0101			 
0101				if DEBUG_SPI 
0101					push hl 
0101					ld l, a 
0101					DMARK "SPI" 
0101					CALLMONITOR 
0101					pop hl 
0101				endif 
0101 c9				ret 
0102			 
0102			; byte to send in a 
0102			 
0102			spi_send_byte: 
0102				; save byte to send for bit mask shift out 
0102 4f			        ld c,a 
0103 3a 5e fa			ld a,(spi_portbyte) 
0106				  
0106				; clock out	each bit of the byte msb first 
0106			 
0106 06 08			ld b, 8 
0108			.ssb1: 
0108				; clear so bit  
0108 cb bf			res SPI_DI, a 
010a cb 11			rl c 
010c				; if bit 7 is set then carry is set 
010c 30 02			jr nc, .ssb2 
010e cb ff			set SPI_DI,a 
0110			.ssb2:  ; output bit to ensure it is stable 
0110 d3 80			out (storage_adata),a 
0112 00				nop 
0113				; clock bit high 
0113 cb ef			set SPI_SCLK,a 
0115 d3 80			out (storage_adata),a 
0117 00				nop 
0118 cd ea 00			call spi_clk 
011b				; then low 
011b cb af			res SPI_SCLK,a 
011d d3 80			out (storage_adata),a 
011f 00				nop 
0120 cd ea 00			call spi_clk 
0123 10 e3			djnz .ssb1 
0125			 
0125 32 5e fa			ld (spi_portbyte),a 
0128 c9				ret 
0129			 
0129			; TODO low level get byte into A on spi 
0129			 
0129			spi_read_byte:  
0129			 
0129				; save byte to send for bit mask shift out 
0129 0e 00		    ld c,0 
012b 3a 5e fa			ld a,(spi_portbyte) 
012e				  
012e				; clock out	each bit of the byte msb first 
012e			 
012e			 
012e				; clock bit high 
012e cb ef			set SPI_SCLK,a 
0130 d3 80			out (storage_adata),a 
0132 00				nop 
0133 cd ea 00			call spi_clk 
0136			 
0136			    ; read DO  
0136			 
0136 cb f9		    set 7,c 
0138 db 80			in a,(storage_adata) 
013a cb 77		    bit SPI_DO,a 
013c 20 02		    jr nz, .b7 
013e cb b9		    res 7,c 
0140			.b7: 
0140				; then low 
0140 cb af			res SPI_SCLK,a 
0142 d3 80			out (storage_adata),a 
0144 00				nop 
0145 cd ea 00			call spi_clk 
0148			     
0148			 
0148				; clock bit high 
0148 cb ef			set SPI_SCLK,a 
014a d3 80			out (storage_adata),a 
014c 00				nop 
014d cd ea 00			call spi_clk 
0150			 
0150			    ; read DO  
0150			 
0150 cb f1		    set 6,c 
0152 db 80			in a,(storage_adata) 
0154 cb 77		    bit SPI_DO,a 
0156 20 02		    jr nz, .b6 
0158 cb b1		    res 6,c 
015a			.b6: 
015a				; then low 
015a cb af			res SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f cd ea 00			call spi_clk 
0162			 
0162				; clock bit high 
0162 cb ef			set SPI_SCLK,a 
0164 d3 80			out (storage_adata),a 
0166 00				nop 
0167 cd ea 00			call spi_clk 
016a			 
016a			 
016a			    ; read DO  
016a			 
016a cb e9		    set 5,c 
016c db 80			in a,(storage_adata) 
016e cb 77		    bit SPI_DO,a 
0170 20 02		    jr nz, .b5 
0172 cb a9		    res 5,c 
0174			.b5: 
0174				; then low 
0174 cb af			res SPI_SCLK,a 
0176 d3 80			out (storage_adata),a 
0178 00				nop 
0179 cd ea 00			call spi_clk 
017c				; clock bit high 
017c cb ef			set SPI_SCLK,a 
017e d3 80			out (storage_adata),a 
0180 00				nop 
0181 cd ea 00			call spi_clk 
0184			 
0184			    ; read DO  
0184			 
0184 cb e1		    set 4,c 
0186 db 80			in a,(storage_adata) 
0188 cb 77		    bit SPI_DO,a 
018a 20 02		    jr nz, .b4 
018c cb a1		    res 4,c 
018e			.b4: 
018e				; then low 
018e cb af			res SPI_SCLK,a 
0190 d3 80			out (storage_adata),a 
0192 00				nop 
0193 cd ea 00			call spi_clk 
0196				; clock bit high 
0196 cb ef			set SPI_SCLK,a 
0198 d3 80			out (storage_adata),a 
019a 00				nop 
019b cd ea 00			call spi_clk 
019e			 
019e			    ; read DO  
019e			 
019e cb d9		    set 3,c 
01a0 db 80			in a,(storage_adata) 
01a2 cb 77		    bit SPI_DO,a 
01a4 20 02		    jr nz, .b3 
01a6 cb 99		    res 3,c 
01a8			.b3: 
01a8				; then low 
01a8 cb af			res SPI_SCLK,a 
01aa d3 80			out (storage_adata),a 
01ac 00				nop 
01ad cd ea 00			call spi_clk 
01b0				; clock bit high 
01b0 cb ef			set SPI_SCLK,a 
01b2 d3 80			out (storage_adata),a 
01b4 00				nop 
01b5 cd ea 00			call spi_clk 
01b8			 
01b8			    ; read DO  
01b8			 
01b8 cb d1		    set 2,c 
01ba db 80			in a,(storage_adata) 
01bc cb 77		    bit SPI_DO,a 
01be 20 02		    jr nz, .b2 
01c0 cb 91		    res 2,c 
01c2			.b2: 
01c2				; then low 
01c2 cb af			res SPI_SCLK,a 
01c4 d3 80			out (storage_adata),a 
01c6 00				nop 
01c7 cd ea 00			call spi_clk 
01ca				; clock bit high 
01ca cb ef			set SPI_SCLK,a 
01cc d3 80			out (storage_adata),a 
01ce 00				nop 
01cf cd ea 00			call spi_clk 
01d2			 
01d2			    ; read DO  
01d2			 
01d2 cb c9		    set 1,c 
01d4 db 80			in a,(storage_adata) 
01d6 cb 77		    bit SPI_DO,a 
01d8 20 02		    jr nz, .b1 
01da cb 89		    res 1,c 
01dc			.b1: 
01dc				; then low 
01dc cb af			res SPI_SCLK,a 
01de d3 80			out (storage_adata),a 
01e0 00				nop 
01e1 cd ea 00			call spi_clk 
01e4				; clock bit high 
01e4 cb ef			set SPI_SCLK,a 
01e6 d3 80			out (storage_adata),a 
01e8 00				nop 
01e9 cd ea 00			call spi_clk 
01ec			 
01ec			    ; read DO  
01ec			 
01ec cb c1		    set 0,c 
01ee db 80			in a,(storage_adata) 
01f0 cb 77		    bit SPI_DO,a 
01f2 20 02		    jr nz, .b0 
01f4 cb 81		    res 0,c 
01f6			.b0: 
01f6				; then low 
01f6 cb af			res SPI_SCLK,a 
01f8 d3 80			out (storage_adata),a 
01fa 00				nop 
01fb cd ea 00			call spi_clk 
01fe			 
01fe			 
01fe 32 5e fa			ld (spi_portbyte),a 
0201			 
0201			    ; return byte 
0201 79			    ld a,c 
0202			 
0202			 
0202 c9				ret 
0203			 
0203			 
0203			 
0203			spi_ce_high: 
0203			 
0203				if DEBUG_SPI_HARD_CE0 
0203			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0203					ret 
0203			 
0203				endif 
0203			 
0203			 
0203 f5				push af 
0204			 
0204				; send direct ce to port b 
0204 3e ff			ld a, 255 
0206 d3 81			out (storage_bdata), a 
0208			 
0208 f1				pop af 
0209			 
0209				; for port a that shares with spi lines AND the mask 
0209			  
0209				if DEBUG_SPI 
0209					push hl 
0209					ld h, a 
0209				endif 
0209			;	ld c, SPI_CE_HIGH 
0209			;	and c 
0209 cb c7			set SPI_CE0, a 
020b cb cf			set SPI_CE1, a 
020d cb d7			set SPI_CE2, a 
020f cb df			set SPI_CE3, a 
0211 cb e7			set SPI_CE4, a 
0213			 
0213				if DEBUG_SPI 
0213					ld l, a 
0213					DMARK "CEh" 
0213					CALLMONITOR 
0213					pop hl 
0213				endif 
0213 c9				ret 
0214			 
0214			 
0214			spi_ce_low: 
0214			 
0214				if DEBUG_SPI_HARD_CE0 
0214			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0214					ret 
0214			 
0214				endif 
0214			 
0214 c5				push bc 
0215 f5				push af 
0216			 
0216				; send direct ce to port b 
0216 3a 60 fa			ld a, (spi_cartdev) 
0219 d3 81			out (storage_bdata), a 
021b			 
021b			 
021b			 
021b				; for port a that shares with spi lines AND the mask 
021b			 
021b 3a 5d fa			ld a, (spi_device)  
021e 4f				ld c, a 
021f			 
021f f1				pop af 
0220			 
0220				; detect CEx 
0220			 
0220				if DEBUG_SPI 
0220					push hl 
0220					ld h, a 
0220				endif 
0220			 
0220 cb 41			bit SPI_CE0, c 
0222 20 04			jr nz, .cel1 
0224 cb 87			res SPI_CE0, a 
0226 18 1e			jr .celn 
0228			.cel1: 
0228 cb 49			bit SPI_CE1, c 
022a 20 04			jr nz, .cel2 
022c cb 8f			res SPI_CE1, a 
022e 18 16			jr .celn 
0230			.cel2: 
0230 cb 51			bit SPI_CE2, c 
0232 20 04			jr nz, .cel3 
0234 cb 97			res SPI_CE2, a 
0236 18 0e			jr .celn 
0238			.cel3: 
0238 cb 59			bit SPI_CE3, c 
023a 20 04			jr nz, .cel4 
023c cb 9f			res SPI_CE3, a 
023e 18 06			jr .celn 
0240			.cel4: 
0240 cb 61			bit SPI_CE4, c 
0242 20 02			jr nz, .celn 
0244 cb a7			res SPI_CE4, a 
0246			.celn: 
0246			 
0246			 
0246			 
0246			;	add c 
0246			 
0246				if DEBUG_SPI 
0246					ld l, a 
0246					DMARK "CEl" 
0246					CALLMONITOR 
0246					pop hl 
0246				endif 
0246 c1				pop bc 
0247 c9				ret 
0248			 
0248			 
0248			 
0248			; eof 
0248			 
0248			 
0248			 
0248			 
0248			 
# End of file firmware_spi.asm
0248				include "firmware_seeprom.asm"  
0248			; 
0248			; persisent storage interface via microchip serial eeprom 
0248			 
0248			; port a pio 2 
0248			; pa 7 - si 
0248			; pa 6 - sclk  
0248			; pa 5 - so 
0248			; pa 4 - cs 
0248			; pa 3 - cs 
0248			; pa 2 - cs 
0248			; pa 1 - cs 
0248			; pa 0 - cs 
0248			; 
0248			; TODO get block 
0248			; TODO save block 
0248			; TODO load file 
0248			; TODO save file 
0248			; TODO get dir  
0248			 
0248			;  
0248			storage_adata: equ Device_C    ; device c port a - onboard storage 
0248			storage_actl: equ Device_C+2     ; device c port a 
0248			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0248			storage_bctl: equ Device_C+3     ; device c port b 
0248			 
0248			 
0248			; TODO move these to hardware driver file 
0248			 
0248			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0248			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0248			; storage bank file system format 
0248			; 
0248			; first page of bank: 
0248			; 	addr 0 - status check 
0248			;       addr 1 - write protect flag 
0248			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0248			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0248			;         TODO see if scanning whole of for available next file id is fast enough 
0248			;	addr 4 > zero term string of bank label 
0248			; 
0248			;        
0248			;  
0248			; first page of any file: 
0248			;      byte 0 - file id  
0248			;      byte 1-17 - fixed file name  
0248			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0248			; 
0248			; other pages of any file: 
0248			;      byte 0 - file id 
0248			;      byte 1> - file data 
0248			; 
0248			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0248			;  
0248			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0248			 
0248			 
0248			;storage_so_bit: 5 
0248			;storage_si_bit: 7 
0248			;storage_sclk_bit: 6 
0248			  
0248			 
0248			; init storage pio 
0248			 
0248			storage_init: 
0248			 
0248			 
0248					; set default SPI clk pulse time as disabled 
0248			 
0248 3e 00				ld a, 0 
024a 32 61 fa				ld (spi_clktime), a 
024d			 
024d					; init hardware 
024d			 
024d 3e cf		            LD   A, 11001111b 
024f d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0251 3e 00		            LD   A, 00000000b 
0253 cb f7			set SPI_DO,a 
0255			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0255 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0257			 
0257 3e cf		            LD   A, 11001111b 
0259 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
025b 3e 00		            LD   A, 00000000b 
025d d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
025f			 
025f				; set all external spi devices off  
025f 3e ff			ld a, 255 
0261 32 5d fa			ld (spi_device), a 
0264 32 60 fa			ld (spi_cartdev), a 
0267			 
0267					; ensure the spi bus is in a default stable state 
0267 cd f7 00				call se_stable_spi 
026a			 
026a			; TODO scan spi bus and gather which storage banks are present 
026a			 
026a			; populate store_bank_active  
026a			; for each ce line activate and attempt to write first byte of bank and read back 
026a			; if zero is returned then bank is empty 
026a			;   
026a			; 
026a			 
026a					; init file extent cache to save on slow reads 
026a			 
026a			;	ld hl, store_filecache 
026a			;	ld de, 0 
026a			;	ld hl,(de)	 
026a			 
026a			 
026a c9			    ret 
026b			 
026b			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
026b			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
026b			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
026b			 
026b			; INSTRUCTION SET 
026b			; READ 0000 0011 Read data from memory array beginning at selected address 
026b			; WRITE 0000 0010 Write data to memory array beginning at selected address 
026b			; WREN 0000 0110 Set the write enable latch (enable write operations) 
026b			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
026b			; RDSR 0000 0101 Read STATUS register 
026b			; WRSR 0000 0001 Write STATUS register 
026b			; PE 0100 0010 Page Erase – erase one page in memory array 
026b			; SE 1101 1000 Sector Erase – erase one sector in memory array 
026b			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
026b			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
026b			 
026b			; TODO send byte steam for page without setting the address for every single byte 
026b			; TODO read byte  
026b			 
026b			; byte in a 
026b			; address in hl  
026b			se_writebyte: 
026b			        
026b			    ;   ld c, a 
026b f5			        push af 
026c e5			        push hl 
026d			 
026d			    ; initi write mode 
026d			    ; 
026d			    ;CS low 
026d			 
026d 3a 5e fa		       ld a,(spi_portbyte) 
0270 cd 14 02			call spi_ce_low 
0273			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0273 d3 80		       out (storage_adata),a 
0275 32 5e fa		       ld (spi_portbyte), a 
0278			 
0278			    ;clock out wren instruction 
0278			 
0278 3e 06		    ld a, store_wren_ins 
027a cd 02 01		    call spi_send_byte  
027d			 
027d			    ;cs high to enable write latch 
027d			 
027d 3a 5e fa		       ld a,(spi_portbyte) 
0280 cd 03 02			call spi_ce_high 
0283			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0283 d3 80		       out (storage_adata),a 
0285 32 5e fa		       ld (spi_portbyte), a 
0288			 
0288 00				nop 
0289			    ; 
0289			    ; intial write data 
0289			    ; 
0289			    ; cs low 
0289			     
0289 3a 5e fa		       ld a,(spi_portbyte) 
028c cd 14 02			call spi_ce_low 
028f			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028f d3 80		       out (storage_adata),a 
0291 32 5e fa		       ld (spi_portbyte), a 
0294			 
0294			    ; clock out write instruction 
0294			     
0294 3e 02		    ld a, store_write_ins  
0296 cd 02 01		    call spi_send_byte  
0299			 
0299			    ; clock out address (depending on address size) 
0299			     
0299 e1			    pop hl 
029a 7c			    ld a,h    ; address out msb first 
029b cd 02 01		    call spi_send_byte  
029e 7d			    ld a,l 
029f cd 02 01		    call spi_send_byte  
02a2			 
02a2			    ; clock out byte(s) for page 
02a2			 
02a2 f1			    pop af 
02a3 cd 02 01		    call spi_send_byte  
02a6			 
02a6			    ; end write with ce high 
02a6 3a 5e fa		       ld a,(spi_portbyte) 
02a9			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02a9 cd 03 02			call spi_ce_high 
02ac d3 80		       out (storage_adata),a 
02ae 32 5e fa		       ld (spi_portbyte), a 
02b1			 
02b1				; pause for internal write cycle 
02b1 3e 0a			ld a, 10 
02b3 cd c4 0c			call aDelayInMS 
02b6 c9			    ret 
02b7			 
02b7			; buffer to write in de 
02b7			; address in hl  
02b7			se_writepage: 
02b7			        
02b7			    ;   ld c, a 
02b7 d5				push de 
02b8 e5			        push hl 
02b9			 
02b9			    ; initi write mode 
02b9			    ; 
02b9			    ;CS low 
02b9			 
02b9 3a 5e fa		       ld a,(spi_portbyte) 
02bc cd 14 02			call spi_ce_low 
02bf			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02bf d3 80		       out (storage_adata),a 
02c1 32 5e fa		       ld (spi_portbyte), a 
02c4			 
02c4			    ;clock out wren instruction 
02c4			 
02c4 3e 06		    ld a, store_wren_ins 
02c6 cd 02 01		    call spi_send_byte  
02c9			 
02c9			    ;cs high to enable write latch 
02c9			 
02c9 3a 5e fa		       ld a,(spi_portbyte) 
02cc cd 03 02			call spi_ce_high 
02cf			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cf d3 80		       out (storage_adata),a 
02d1 32 5e fa		       ld (spi_portbyte), a 
02d4			 
02d4 00				nop 
02d5			    ; 
02d5			    ; intial write data 
02d5			    ; 
02d5			    ; cs low 
02d5			     
02d5 3a 5e fa		       ld a,(spi_portbyte) 
02d8			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02d8 cd 14 02			call spi_ce_low 
02db d3 80		       out (storage_adata),a 
02dd 32 5e fa		       ld (spi_portbyte), a 
02e0			 
02e0			    ; clock out write instruction 
02e0			     
02e0 3e 02		    ld a, store_write_ins  
02e2 cd 02 01		    call spi_send_byte  
02e5			 
02e5			    ; clock out address (depending on address size) 
02e5			     
02e5 e1			    pop hl 
02e6 7c			    ld a,h    ; address out msb first 
02e7 cd 02 01		    call spi_send_byte  
02ea 7d			    ld a,l 
02eb cd 02 01		    call spi_send_byte  
02ee			 
02ee			    ; clock out byte(s) for page 
02ee			 
02ee e1				pop hl 
02ef 06 40			ld b, STORE_BLOCK_PHY 
02f1			.bytewrite: 
02f1			 
02f1 7e				ld a,(hl) 
02f2 e5			    push hl 
02f3 c5				push bc 
02f4 cd 02 01		    call spi_send_byte  
02f7 c1				pop bc 
02f8 e1				pop hl 
02f9			 
02f9			    ; end write with ce high 
02f9 3a 5e fa		       ld a,(spi_portbyte) 
02fc cd 03 02			call spi_ce_high 
02ff			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02ff d3 80		       out (storage_adata),a 
0301 32 5e fa		       ld (spi_portbyte), a 
0304			 
0304 23				inc hl 
0305 10 ea			djnz .bytewrite 
0307			 
0307				; pause for internal write cycle 
0307 3e 64			ld a, 100 
0309 cd c4 0c			call aDelayInMS 
030c c9			    ret 
030d			; returns byte in a 
030d			; address in hl  
030d			se_readbyte: 
030d d5				push de 
030e c5				push bc 
030f			 
030f			    ;   ld c, a 
030f e5			        push hl 
0310			 
0310			    ; initi write mode 
0310			    ; 
0310			    ;CS low 
0310			 
0310 3a 5e fa		       ld a,(spi_portbyte) 
0313 cd 14 02			call spi_ce_low 
0316			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0316 d3 80		       out (storage_adata),a 
0318 32 5e fa		       ld (spi_portbyte), a 
031b			 
031b			    ;clock out wren instruction 
031b			 
031b 3e 03		    ld a, store_read_ins 
031d cd 02 01		    call spi_send_byte  
0320			 
0320			 
0320			    ; clock out address (depending on address size) 
0320			     
0320 e1			    pop hl 
0321 7c			    ld a,h    ; address out msb first 
0322 cd 02 01		    call spi_send_byte  
0325 7d			    ld a,l 
0326 cd 02 01		    call spi_send_byte  
0329			 
0329			    ; clock in byte(s) for page 
0329			 
0329 cd 29 01		    call spi_read_byte  
032c f5				push af 
032d			 
032d			    ; end write with ce high 
032d 3a 5e fa		       ld a,(spi_portbyte) 
0330			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0330 cd 03 02			call spi_ce_high 
0333 d3 80		       out (storage_adata),a 
0335 32 5e fa		       ld (spi_portbyte), a 
0338			 
0338 f1				pop af 
0339			 
0339 c1				pop bc 
033a d1				pop de 
033b			 
033b c9			    ret 
033c			 
033c			if DEBUG_STORESE 
033c			 
033c			storageput:  
033c			 
033c			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
033c			 
033c 21 c0 f1			ld hl,scratch+2 
033f cd 87 13			call get_word_hl 
0342			 
0342				; stuff it here for the moment as it will be overwritten later anyway 
0342			 
0342 22 e1 f4			ld (os_cur_ptr),hl	 
0345			 
0345			 
0345			; get pointer to start of string 
0345			 
0345 21 c5 f1			ld hl, scratch+7 
0348			 
0348			; loop writing char of string to eeprom 
0348			 
0348 7e			.writestr:	ld a,(hl) 
0349 fe 00				cp 0 
034b 28 12				jr z, .wsdone		; done writing 
034d e5					push hl 
034e 2a e1 f4				ld hl,(os_cur_ptr) 
0351 cd 6b 02				call se_writebyte 
0354			 
0354 2a e1 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0357 23					inc hl 
0358 22 e1 f4				ld (os_cur_ptr),hl 
035b			 
035b					; restore string pointer and get next char 
035b			 
035b e1					pop hl 
035c 23					inc hl 
035d 18 e9				jr .writestr 
035f			 
035f			 
035f			 
035f			.wsdone: 
035f			 
035f			 
035f			; when done load first page into a buffer  
035f			 
035f 21 00 80				ld hl,08000h		; start in ram 
0362 22 e1 f4				ld (os_cur_ptr),hl 
0365 21 00 00				ld hl, 0		 ; start of page 
0368 22 e6 f1				ld (scratch+40),hl	; hang on to it 
036b			 
036b 06 80				ld b, 128		; actually get more then one page 
036d c5			.wsload:	push bc 
036e 2a e6 f1				ld hl,(scratch+40) 
0371 e5					push hl 
0372 cd 0d 03				call se_readbyte 
0375			 
0375					; a now as the byte 
0375			 
0375 2a e1 f4				ld hl,(os_cur_ptr) 
0378 77					ld (hl),a 
0379					; inc next buffer area 
0379 23					inc hl 
037a 22 e1 f4				ld (os_cur_ptr),hl 
037d			 
037d					; get eeprom position, inc and save for next round 
037d e1					pop hl		 
037e 23					inc hl 
037f 22 e6 f1				ld (scratch+40),hl 
0382 c1					pop bc 
0383 10 e8				djnz .wsload 
0385			 
0385			; set 'd' pointer to start of buffer 
0385			 
0385 21 00 80				ld hl,08000h 
0388 22 e1 f4				ld (os_cur_ptr),hl 
038b			 
038b			 
038b c9			ret 
038c			 
038c			 
038c c9			storageread: ret 
038d			 
038d			 
038d			 
038d			 
038d			 
038d			 
038d			endif 
038d			 
038d			 
038d			 
# End of file firmware_seeprom.asm
038d			else  
038d			   ; create some stubs for the labels  
038d			se_readbyte: ret  
038d			se_writebyte: ret  
038d			storage_init: ret  
038d			  
038d			endif  
038d			  
038d			; use cf card for storage - throwing timeout errors. Hardware or software?????  
038d			;include "firmware_cf.asm"  
038d			  
038d			; load up high level storage hardward abstractions  
038d			include "firmware_storage.asm"  
038d			 
038d			; persisent storage hardware abstraction layer  
038d			 
038d			 
038d			 
038d			; Block 0 on storage is a config state 
038d			 
038d			 
038d			 
038d			; TODO add read phy block and write phy block functions 
038d			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
038d			 
038d			; Abstraction layer  
038d			 
038d			; Logocial block size is same size as physical size - using tape concept 
038d			 
038d			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
038d			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
038d			 
038d			 
038d			 
038d			; Filesystem layout (Logical layout) 
038d			; 
038d			; Block 0 - Bank config  
038d			; 
038d			;      Byte - 0 file id counter 
038d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
038d			;      Byte - 3-20 zero terminated bank label 
038d			; 
038d			; Block 1 > File storage 
038d			; 
038d			;      Byte 0 file id    - block 0 file details 
038d			;      Byte 1 block id - block 0 is file  
038d			;            Byte 2-15 - File name 
038d			; 
038d			;       - to end of block data 
038d			; 
038d			 
038d			; Get ID for the file named in pointer held HL 
038d			; Returns ID in HL = 255 if no file found 
038d			 
038d			storage_getid: 
038d			 
038d 22 70 fa			ld (store_tmp1), hl 
0390			 
0390				if DEBUG_STORESE 
0390					DMARK "SGI" 
0390 f5				push af  
0391 3a a5 03			ld a, (.dmark)  
0394 32 68 fe			ld (debug_mark),a  
0397 3a a6 03			ld a, (.dmark+1)  
039a 32 69 fe			ld (debug_mark+1),a  
039d 3a a7 03			ld a, (.dmark+2)  
03a0 32 6a fe			ld (debug_mark+2),a  
03a3 18 03			jr .pastdmark  
03a5 ..			.dmark: db "SGI"  
03a8 f1			.pastdmark: pop af  
03a9			endm  
# End of macro DMARK
03a9					CALLMONITOR 
03a9 cd 6c fe			call debug_vector  
03ac				endm  
# End of macro CALLMONITOR
03ac				endif 
03ac				; get block 0 and set counter for number of files to scan 
03ac			 
03ac cd 17 05			call storage_get_block_0 
03af			 
03af 3a 77 fa			ld a, (store_page) 
03b2 47				ld b, a 
03b3			 
03b3				; get extent 0 of each file id 
03b3			 
03b3				if DEBUG_STORESE 
03b3					DMARK "SGc" 
03b3 f5				push af  
03b4 3a c8 03			ld a, (.dmark)  
03b7 32 68 fe			ld (debug_mark),a  
03ba 3a c9 03			ld a, (.dmark+1)  
03bd 32 69 fe			ld (debug_mark+1),a  
03c0 3a ca 03			ld a, (.dmark+2)  
03c3 32 6a fe			ld (debug_mark+2),a  
03c6 18 03			jr .pastdmark  
03c8 ..			.dmark: db "SGc"  
03cb f1			.pastdmark: pop af  
03cc			endm  
# End of macro DMARK
03cc					CALLMONITOR 
03cc cd 6c fe			call debug_vector  
03cf				endm  
# End of macro CALLMONITOR
03cf				endif 
03cf 60			.getloop:	ld h, b 
03d0 2e 00				ld l, 0 
03d2 c5					push bc 
03d3			 
03d3 11 77 fa				ld de, store_page 
03d6				if DEBUG_STORESE 
03d6					DMARK "SGr" 
03d6 f5				push af  
03d7 3a eb 03			ld a, (.dmark)  
03da 32 68 fe			ld (debug_mark),a  
03dd 3a ec 03			ld a, (.dmark+1)  
03e0 32 69 fe			ld (debug_mark+1),a  
03e3 3a ed 03			ld a, (.dmark+2)  
03e6 32 6a fe			ld (debug_mark+2),a  
03e9 18 03			jr .pastdmark  
03eb ..			.dmark: db "SGr"  
03ee f1			.pastdmark: pop af  
03ef			endm  
# End of macro DMARK
03ef					CALLMONITOR 
03ef cd 6c fe			call debug_vector  
03f2				endm  
# End of macro CALLMONITOR
03f2				endif 
03f2 cd bf 09				call storage_read 
03f5 cd f9 0f				call ishlzero 
03f8 28 2d				jr z, .gap 
03fa					 
03fa					; have a file name read. Is it one we want. 
03fa			 
03fa 2a 70 fa				ld hl, (store_tmp1) 
03fd 11 7a fa				ld de, store_page+3   ; file name 
0400			 
0400				if DEBUG_STORESE 
0400					DMARK "SGc" 
0400 f5				push af  
0401 3a 15 04			ld a, (.dmark)  
0404 32 68 fe			ld (debug_mark),a  
0407 3a 16 04			ld a, (.dmark+1)  
040a 32 69 fe			ld (debug_mark+1),a  
040d 3a 17 04			ld a, (.dmark+2)  
0410 32 6a fe			ld (debug_mark+2),a  
0413 18 03			jr .pastdmark  
0415 ..			.dmark: db "SGc"  
0418 f1			.pastdmark: pop af  
0419			endm  
# End of macro DMARK
0419					CALLMONITOR 
0419 cd 6c fe			call debug_vector  
041c				endm  
# End of macro CALLMONITOR
041c				endif 
041c cd 66 14				call strcmp 
041f 20 06				jr nz, .gap   ; not this one 
0421			 
0421 c1				        pop bc 
0422			 
0422 26 00				ld h, 0 
0424 68					ld l, b 
0425 18 22				jr .getdone 
0427						 
0427			 
0427			 
0427			 
0427			.gap: 
0427				if DEBUG_STORESE 
0427					DMARK "SGg" 
0427 f5				push af  
0428 3a 3c 04			ld a, (.dmark)  
042b 32 68 fe			ld (debug_mark),a  
042e 3a 3d 04			ld a, (.dmark+1)  
0431 32 69 fe			ld (debug_mark+1),a  
0434 3a 3e 04			ld a, (.dmark+2)  
0437 32 6a fe			ld (debug_mark+2),a  
043a 18 03			jr .pastdmark  
043c ..			.dmark: db "SGg"  
043f f1			.pastdmark: pop af  
0440			endm  
# End of macro DMARK
0440					CALLMONITOR 
0440 cd 6c fe			call debug_vector  
0443				endm  
# End of macro CALLMONITOR
0443				endif 
0443			 
0443 c1					pop bc 
0444 10 89				djnz .getloop 
0446 21 ff 00				ld hl, 255 
0449			.getdone: 
0449			 
0449				if DEBUG_STORESE 
0449					DMARK "SGe" 
0449 f5				push af  
044a 3a 5e 04			ld a, (.dmark)  
044d 32 68 fe			ld (debug_mark),a  
0450 3a 5f 04			ld a, (.dmark+1)  
0453 32 69 fe			ld (debug_mark+1),a  
0456 3a 60 04			ld a, (.dmark+2)  
0459 32 6a fe			ld (debug_mark+2),a  
045c 18 03			jr .pastdmark  
045e ..			.dmark: db "SGe"  
0461 f1			.pastdmark: pop af  
0462			endm  
# End of macro DMARK
0462					CALLMONITOR 
0462 cd 6c fe			call debug_vector  
0465				endm  
# End of macro CALLMONITOR
0465				endif 
0465			 
0465 c9				ret 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			 
0466			; Read Block 
0466			; ---------- 
0466			; 
0466			; With current bank 
0466			;  
0466			; Get block number to read 
0466			; Load physical blocks starting at start block into buffer 
0466			 
0466			; de points to buffer to use 
0466			; hl holds logical block number  
0466			 
0466			storage_read_block: 
0466			 
0466				; TODO bank selection 
0466			 
0466				; for each of the physical blocks read it into the buffer 
0466 06 40			ld b, STORE_BLOCK_PHY 
0468			 
0468				if DEBUG_STORESE 
0468 d5					push de 
0469				endif 
0469				 
0469			.rl1:    
0469			 
0469				; read physical block at hl into de 
0469			        ; increment hl and de to next read position on exit 
0469			 
0469 e5				push hl 
046a d5				push de	 
046b c5				push bc 
046c			;	if DEBUG_STORESE 
046c			;		push af 
046c			;		ld a, 'R' 
046c			;		ld (debug_mark),a 
046c			;		pop af 
046c			;		CALLMONITOR 
046c			;	endif 
046c cd 0d 03			call se_readbyte 
046f			;	if DEBUG_STORESE 
046f			;		ld a,(spi_portbyte) 
046f			;		ld l, a 
046f			;		push af 
046f			;		ld a, '1' 
046f			;		ld (debug_mark),a 
046f			;		pop af 
046f			;		CALLMONITOR 
046f			;	endif 
046f c1				pop bc 
0470 d1				pop de 
0471 e1				pop hl 
0472 12				ld (de),a 
0473 23				inc hl 
0474 13				inc de 
0475			 
0475			;	if DEBUG_STORESE 
0475			;		push af 
0475			;		ld a, 'r' 
0475			;		ld (debug_mark),a 
0475			;		pop af 
0475			;		CALLMONITOR 
0475			;	endif 
0475			 
0475 10 f2			djnz .rl1 
0477			 
0477				if DEBUG_STORESE 
0477					DMARK "SRB" 
0477 f5				push af  
0478 3a 8c 04			ld a, (.dmark)  
047b 32 68 fe			ld (debug_mark),a  
047e 3a 8d 04			ld a, (.dmark+1)  
0481 32 69 fe			ld (debug_mark+1),a  
0484 3a 8e 04			ld a, (.dmark+2)  
0487 32 6a fe			ld (debug_mark+2),a  
048a 18 03			jr .pastdmark  
048c ..			.dmark: db "SRB"  
048f f1			.pastdmark: pop af  
0490			endm  
# End of macro DMARK
0490 d1					pop de 
0491			; 
0491			;		push af 
0491			;		ld a, 'R' 
0491			;		ld (debug_mark),a 
0491			;		pop af 
0491					CALLMONITOR 
0491 cd 6c fe			call debug_vector  
0494				endm  
# End of macro CALLMONITOR
0494				endif 
0494 c9				ret	 
0495				 
0495			 
0495			; File Size 
0495			; --------- 
0495			; 
0495			;   hl file id 
0495			; 
0495			;  returns in hl the number of blocks 
0495			 
0495			storage_file_size: 
0495 5d				ld e, l 
0496 16 00			ld d, 0 
0498 21 40 00			ld hl, STORE_BLOCK_PHY 
049b					if DEBUG_FORTH_WORDS 
049b						DMARK "SIZ" 
049b f5				push af  
049c 3a b0 04			ld a, (.dmark)  
049f 32 68 fe			ld (debug_mark),a  
04a2 3a b1 04			ld a, (.dmark+1)  
04a5 32 69 fe			ld (debug_mark+1),a  
04a8 3a b2 04			ld a, (.dmark+2)  
04ab 32 6a fe			ld (debug_mark+2),a  
04ae 18 03			jr .pastdmark  
04b0 ..			.dmark: db "SIZ"  
04b3 f1			.pastdmark: pop af  
04b4			endm  
# End of macro DMARK
04b4						CALLMONITOR 
04b4 cd 6c fe			call debug_vector  
04b7				endm  
# End of macro CALLMONITOR
04b7					endif 
04b7 cd 99 07			call storage_findnextid 
04ba			 
04ba cd f9 0f			call ishlzero 
04bd			;	ld a, l 
04bd			;	add h 
04bd			;	cp 0 
04bd c8				ret z			; block not found so EOF 
04be			 
04be 11 77 fa			ld de, store_page 
04c1 cd 66 04			call storage_read_block 
04c4			 
04c4 3a 79 fa			ld a, (store_page+2)	 ; get extent count 
04c7 6f				ld l, a 
04c8 26 00			ld h, 0 
04ca c9			 	ret 
04cb			 
04cb			 
04cb			; Write Block 
04cb			; ----------- 
04cb			; 
04cb			; With current bank 
04cb			;  
04cb			; Get block number to write 
04cb			; Write physical blocks starting at start block from buffer 
04cb			  
04cb			storage_write_block: 
04cb				; TODO bank selection 
04cb			 
04cb				; for each of the physical blocks read it into the buffer 
04cb 06 40			ld b, STORE_BLOCK_PHY 
04cd			 
04cd				if DEBUG_STORESE 
04cd					DMARK "SWB" 
04cd f5				push af  
04ce 3a e2 04			ld a, (.dmark)  
04d1 32 68 fe			ld (debug_mark),a  
04d4 3a e3 04			ld a, (.dmark+1)  
04d7 32 69 fe			ld (debug_mark+1),a  
04da 3a e4 04			ld a, (.dmark+2)  
04dd 32 6a fe			ld (debug_mark+2),a  
04e0 18 03			jr .pastdmark  
04e2 ..			.dmark: db "SWB"  
04e5 f1			.pastdmark: pop af  
04e6			endm  
# End of macro DMARK
04e6			 
04e6					;push af 
04e6					;ld a, 'W' 
04e6					;ld (debug_mark),a 
04e6					;pop af 
04e6					CALLMONITOR 
04e6 cd 6c fe			call debug_vector  
04e9				endm  
# End of macro CALLMONITOR
04e9				endif 
04e9			 
04e9			; might not be working 
04e9			;	call se_writepage 
04e9			 
04e9			;	ret 
04e9			; 
04e9			 
04e9			 
04e9			 
04e9			.wl1:    
04e9			 
04e9				; read physical block at hl into de 
04e9			        ; increment hl and de to next read position on exit 
04e9			 
04e9 e5				push hl 
04ea d5				push de	 
04eb c5				push bc 
04ec 1a				ld a,(de) 
04ed				;if DEBUG_STORESE 
04ed			;		push af 
04ed			;		ld a, 'W' 
04ed			;		ld (debug_mark),a 
04ed			;		pop af 
04ed			;		CALLMONITOR 
04ed			;	endif 
04ed cd 6b 02			call se_writebyte 
04f0			;	call delay250ms 
04f0 00				nop 
04f1 00				nop 
04f2 00				nop 
04f3			;	if DEBUG_STORESE 
04f3			;		push af 
04f3			;		ld a, 'w' 
04f3			;		ld (debug_mark),a 
04f3			;		pop af 
04f3			;		CALLMONITOR 
04f3			;	endif 
04f3 c1				pop bc 
04f4 d1				pop de 
04f5 e1				pop hl 
04f6 23				inc hl 
04f7 13				inc de 
04f8			 
04f8			 
04f8 10 ef			djnz .wl1 
04fa			 
04fa				if DEBUG_STORESE 
04fa					DMARK "SW2" 
04fa f5				push af  
04fb 3a 0f 05			ld a, (.dmark)  
04fe 32 68 fe			ld (debug_mark),a  
0501 3a 10 05			ld a, (.dmark+1)  
0504 32 69 fe			ld (debug_mark+1),a  
0507 3a 11 05			ld a, (.dmark+2)  
050a 32 6a fe			ld (debug_mark+2),a  
050d 18 03			jr .pastdmark  
050f ..			.dmark: db "SW2"  
0512 f1			.pastdmark: pop af  
0513			endm  
# End of macro DMARK
0513			 
0513					;push af 
0513					;ld a, 'W' 
0513					;ld (debug_mark),a 
0513					;pop af 
0513					CALLMONITOR 
0513 cd 6c fe			call debug_vector  
0516				endm  
# End of macro CALLMONITOR
0516				endif 
0516 c9				ret	 
0517			 
0517			; Init bank 
0517			; --------- 
0517			; 
0517			; With current bank 
0517			; 
0517			; Setup block 0 config 
0517			;     Set 0 file id counter 
0517			;     Set formatted byte pattern 
0517			;     Zero out bank label 
0517			;      
0517			; For every logical block write 0-1 byte as null 
0517			 
0517			storage_get_block_0: 
0517			 
0517				; TODO check presence 
0517			 
0517				; get block 0 config 
0517			 
0517 21 00 00			ld hl, 0 
051a 11 77 fa			ld de, store_page 
051d cd 66 04			call storage_read_block 
0520			 
0520				if DEBUG_STORESE 
0520					DMARK "SB0" 
0520 f5				push af  
0521 3a 35 05			ld a, (.dmark)  
0524 32 68 fe			ld (debug_mark),a  
0527 3a 36 05			ld a, (.dmark+1)  
052a 32 69 fe			ld (debug_mark+1),a  
052d 3a 37 05			ld a, (.dmark+2)  
0530 32 6a fe			ld (debug_mark+2),a  
0533 18 03			jr .pastdmark  
0535 ..			.dmark: db "SB0"  
0538 f1			.pastdmark: pop af  
0539			endm  
# End of macro DMARK
0539 11 77 fa				ld de, store_page 
053c			;		push af 
053c			;		ld a, 'i' 
053c			;		ld (debug_mark),a 
053c			;		pop af 
053c					CALLMONITOR 
053c cd 6c fe			call debug_vector  
053f				endm  
# End of macro CALLMONITOR
053f				endif 
053f			 
053f				; is this area formatted? 
053f			 
053f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
053f 2a 78 fa			ld hl, (store_page+1) 
0542 3e 80			ld a,0x80 
0544 bd				cp l 
0545 20 22			jr nz, .ininotformatted 
0547				; do a double check 
0547 3e 27			ld a, 0x27 
0549 bc				cp h 
054a 20 1d			jr nz, .ininotformatted 
054c			 
054c				; formatted then 
054c			 
054c				if DEBUG_STORESE 
054c					DMARK "SB1" 
054c f5				push af  
054d 3a 61 05			ld a, (.dmark)  
0550 32 68 fe			ld (debug_mark),a  
0553 3a 62 05			ld a, (.dmark+1)  
0556 32 69 fe			ld (debug_mark+1),a  
0559 3a 63 05			ld a, (.dmark+2)  
055c 32 6a fe			ld (debug_mark+2),a  
055f 18 03			jr .pastdmark  
0561 ..			.dmark: db "SB1"  
0564 f1			.pastdmark: pop af  
0565			endm  
# End of macro DMARK
0565					;push af 
0565					;ld a, 'I' 
0565					;ld (debug_mark),a 
0565					;pop af 
0565					CALLMONITOR 
0565 cd 6c fe			call debug_vector  
0568				endm  
# End of macro CALLMONITOR
0568				endif 
0568 c9				ret 
0569			 
0569			.ininotformatted: 
0569				; bank not formatted so poke various bits to make sure 
0569			 
0569				if DEBUG_STORESE 
0569					DMARK "SB2" 
0569 f5				push af  
056a 3a 7e 05			ld a, (.dmark)  
056d 32 68 fe			ld (debug_mark),a  
0570 3a 7f 05			ld a, (.dmark+1)  
0573 32 69 fe			ld (debug_mark+1),a  
0576 3a 80 05			ld a, (.dmark+2)  
0579 32 6a fe			ld (debug_mark+2),a  
057c 18 03			jr .pastdmark  
057e ..			.dmark: db "SB2"  
0581 f1			.pastdmark: pop af  
0582			endm  
# End of macro DMARK
0582					;push af 
0582					;ld a, 'f' 
0582					;ld (debug_mark),a 
0582					;pop af 
0582					CALLMONITOR 
0582 cd 6c fe			call debug_vector  
0585				endm  
# End of macro CALLMONITOR
0585				endif 
0585			 
0585 cd a2 0c			call storage_clear_page 
0588			 
0588 21 77 fa			ld hl, store_page 
058b 3e 00			ld a, 0 
058d				 
058d 77				ld (hl),a   ; reset file counter 
058e			 
058e 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0591 22 78 fa		 	ld (store_page+1), hl	 
0594			 
0594				; set default label 
0594			 
0594 21 30 06			ld hl, .defaultbanklabl 
0597 11 7a fa		 	ld de, store_page+3 
059a 01 0f 00			ld bc, 15 
059d ed b0			ldir 
059f			 
059f				; Append the current bank id 
059f 21 83 fa			ld hl, store_page+3+9 
05a2 3a 5c fa			ld a, (spi_device_id) 
05a5 77				ld (hl), a 
05a6			 
05a6				; save default page 0 
05a6			 
05a6 21 00 00			ld hl, 0 
05a9 11 77 fa			ld de, store_page 
05ac				if DEBUG_STORESE 
05ac					DMARK "SB3" 
05ac f5				push af  
05ad 3a c1 05			ld a, (.dmark)  
05b0 32 68 fe			ld (debug_mark),a  
05b3 3a c2 05			ld a, (.dmark+1)  
05b6 32 69 fe			ld (debug_mark+1),a  
05b9 3a c3 05			ld a, (.dmark+2)  
05bc 32 6a fe			ld (debug_mark+2),a  
05bf 18 03			jr .pastdmark  
05c1 ..			.dmark: db "SB3"  
05c4 f1			.pastdmark: pop af  
05c5			endm  
# End of macro DMARK
05c5			;		push af 
05c5			;		ld a, 'F' 
05c5			;		ld (debug_mark),a 
05c5			;		pop af 
05c5					CALLMONITOR 
05c5 cd 6c fe			call debug_vector  
05c8				endm  
# End of macro CALLMONITOR
05c8				endif 
05c8 cd cb 04			call storage_write_block 
05cb				if DEBUG_STORESE 
05cb					DMARK "SB4" 
05cb f5				push af  
05cc 3a e0 05			ld a, (.dmark)  
05cf 32 68 fe			ld (debug_mark),a  
05d2 3a e1 05			ld a, (.dmark+1)  
05d5 32 69 fe			ld (debug_mark+1),a  
05d8 3a e2 05			ld a, (.dmark+2)  
05db 32 6a fe			ld (debug_mark+2),a  
05de 18 03			jr .pastdmark  
05e0 ..			.dmark: db "SB4"  
05e3 f1			.pastdmark: pop af  
05e4			endm  
# End of macro DMARK
05e4			;		push af 
05e4			;		ld a, '>' 
05e4			;		ld (debug_mark),a 
05e4			;		pop af 
05e4					CALLMONITOR 
05e4 cd 6c fe			call debug_vector  
05e7				endm  
# End of macro CALLMONITOR
05e7				endif 
05e7			 
05e7 00				nop 
05e8 00				nop 
05e9 00				nop 
05ea			 
05ea				; now set 0 in every page to mark as a free block 
05ea			 
05ea 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ec 21 40 00			ld hl, STORE_BLOCK_PHY 
05ef			 
05ef 3e 00		.setmark1:   	ld a,0 
05f1 e5					push hl 
05f2 c5					push bc 
05f3 cd 6b 02				call se_writebyte 
05f6 3e 0a			ld a, 10 
05f8 cd c4 0c			call aDelayInMS 
05fb 23				inc hl 
05fc cd 6b 02				call se_writebyte 
05ff 3e 0a			ld a, 10 
0601 cd c4 0c			call aDelayInMS 
0604 2b				dec hl 
0605 c1					pop bc 
0606 e1					pop hl 
0607 3e 40				ld a, STORE_BLOCK_PHY 
0609 cd d0 0f				call addatohl 
060c 10 e1				djnz .setmark1 
060e			 
060e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0610 3e 00		.setmark2:   	ld a,0 
0612 e5					push hl 
0613 c5					push bc 
0614 cd 6b 02				call se_writebyte 
0617 3e 0a			ld a, 10 
0619 cd c4 0c			call aDelayInMS 
061c 23				inc hl 
061d cd 6b 02				call se_writebyte 
0620 3e 0a			ld a, 10 
0622 cd c4 0c			call aDelayInMS 
0625 2b				dec hl 
0626 c1					pop bc 
0627 e1					pop hl 
0628 3e 40				ld a, STORE_BLOCK_PHY 
062a cd d0 0f				call addatohl 
062d 10 e1				djnz .setmark2 
062f			 
062f					 
062f			 
062f			 
062f c9				ret 
0630			 
0630			 
0630			 
0630			 
0630 .. 00		.defaultbanklabl:   db "BankLabel_",0 
063b			 
063b			 
063b			 
063b			; Label Bank 
063b			; ---------- 
063b			; 
063b			; With current bank 
063b			; Read block 0 
063b			; Set label 
063b			; Write block 0 
063b			 
063b			; label str pointer in hl 
063b			 
063b			storage_label:     
063b			 
063b				if DEBUG_STORESE 
063b					DMARK "LBL" 
063b f5				push af  
063c 3a 50 06			ld a, (.dmark)  
063f 32 68 fe			ld (debug_mark),a  
0642 3a 51 06			ld a, (.dmark+1)  
0645 32 69 fe			ld (debug_mark+1),a  
0648 3a 52 06			ld a, (.dmark+2)  
064b 32 6a fe			ld (debug_mark+2),a  
064e 18 03			jr .pastdmark  
0650 ..			.dmark: db "LBL"  
0653 f1			.pastdmark: pop af  
0654			endm  
# End of macro DMARK
0654					CALLMONITOR 
0654 cd 6c fe			call debug_vector  
0657				endm  
# End of macro CALLMONITOR
0657				endif 
0657			 
0657 e5				push hl 
0658			 
0658 cd 17 05			call storage_get_block_0 
065b			 
065b				; set default label 
065b			 
065b e1				pop hl 
065c			 
065c 11 7a fa		 	ld de, store_page+3 
065f 01 0f 00			ld bc, 15 
0662				if DEBUG_STORESE 
0662					DMARK "LB3" 
0662 f5				push af  
0663 3a 77 06			ld a, (.dmark)  
0666 32 68 fe			ld (debug_mark),a  
0669 3a 78 06			ld a, (.dmark+1)  
066c 32 69 fe			ld (debug_mark+1),a  
066f 3a 79 06			ld a, (.dmark+2)  
0672 32 6a fe			ld (debug_mark+2),a  
0675 18 03			jr .pastdmark  
0677 ..			.dmark: db "LB3"  
067a f1			.pastdmark: pop af  
067b			endm  
# End of macro DMARK
067b					CALLMONITOR 
067b cd 6c fe			call debug_vector  
067e				endm  
# End of macro CALLMONITOR
067e				endif 
067e ed b0			ldir 
0680				; save default page 0 
0680			 
0680 21 00 00			ld hl, 0 
0683 11 77 fa			ld de, store_page 
0686				if DEBUG_STORESE 
0686					DMARK "LBW" 
0686 f5				push af  
0687 3a 9b 06			ld a, (.dmark)  
068a 32 68 fe			ld (debug_mark),a  
068d 3a 9c 06			ld a, (.dmark+1)  
0690 32 69 fe			ld (debug_mark+1),a  
0693 3a 9d 06			ld a, (.dmark+2)  
0696 32 6a fe			ld (debug_mark+2),a  
0699 18 03			jr .pastdmark  
069b ..			.dmark: db "LBW"  
069e f1			.pastdmark: pop af  
069f			endm  
# End of macro DMARK
069f					CALLMONITOR 
069f cd 6c fe			call debug_vector  
06a2				endm  
# End of macro CALLMONITOR
06a2				endif 
06a2 cd cb 04			call storage_write_block 
06a5			 
06a5 c9				ret 
06a6			 
06a6			 
06a6			 
06a6			; Read Block 0 - Config 
06a6			; --------------------- 
06a6			; 
06a6			; With current bank 
06a6			; Call presence test 
06a6			;    If not present format/init bank  
06a6			; Read block 0  
06a6			;  
06a6			 
06a6			 
06a6			; Dir 
06a6			; --- 
06a6			; 
06a6			; With current bank 
06a6			; Load Block 0 Config 
06a6			; Get max file id number 
06a6			; For each logical block 
06a6			;    Read block read byte 2 
06a6			;      if first block of file 
06a6			;         Display file name 
06a6			;         Display type flags for file 
06a6			;        
06a6			 
06a6			; moving to words as this requires stack control 
06a6			 
06a6			 
06a6			; Delete File 
06a6			; ----------- 
06a6			; 
06a6			; With current bank 
06a6			; 
06a6			; Load Block 0 Config 
06a6			; Get max file id number 
06a6			; For each logical block 
06a6			;    Read block file id 
06a6			;      If first block of file and dont have file id 
06a6			;         if file to delete 
06a6			;         Save file id 
06a6			;         Null file id 
06a6			;         Write this block back 
06a6			;      If file id is one saved 
06a6			;         Null file id 
06a6			;         Write this block back 
06a6			 
06a6			 
06a6			.se_done: 
06a6 e1				pop hl 
06a7 c9				ret 
06a8			 
06a8			storage_erase: 
06a8			 
06a8				; hl contains the file id 
06a8			 
06a8 5d				ld e, l 
06a9 16 00			ld d, 0 
06ab 21 40 00			ld hl, STORE_BLOCK_PHY 
06ae					if DEBUG_FORTH_WORDS 
06ae						DMARK "ERA" 
06ae f5				push af  
06af 3a c3 06			ld a, (.dmark)  
06b2 32 68 fe			ld (debug_mark),a  
06b5 3a c4 06			ld a, (.dmark+1)  
06b8 32 69 fe			ld (debug_mark+1),a  
06bb 3a c5 06			ld a, (.dmark+2)  
06be 32 6a fe			ld (debug_mark+2),a  
06c1 18 03			jr .pastdmark  
06c3 ..			.dmark: db "ERA"  
06c6 f1			.pastdmark: pop af  
06c7			endm  
# End of macro DMARK
06c7						CALLMONITOR 
06c7 cd 6c fe			call debug_vector  
06ca				endm  
# End of macro CALLMONITOR
06ca					endif 
06ca cd 99 07			call storage_findnextid 
06cd cd f9 0f			call ishlzero 
06d0 c8				ret z 
06d1			 
06d1 e5				push hl 
06d2			 
06d2				; TODO check file not found 
06d2			 
06d2 11 77 fa			ld de, store_page 
06d5 cd 66 04			call storage_read_block 
06d8			 
06d8 cd f9 0f			call ishlzero 
06db ca a6 06			jp z,.se_done 
06de			 
06de					if DEBUG_FORTH_WORDS 
06de						DMARK "ER1" 
06de f5				push af  
06df 3a f3 06			ld a, (.dmark)  
06e2 32 68 fe			ld (debug_mark),a  
06e5 3a f4 06			ld a, (.dmark+1)  
06e8 32 69 fe			ld (debug_mark+1),a  
06eb 3a f5 06			ld a, (.dmark+2)  
06ee 32 6a fe			ld (debug_mark+2),a  
06f1 18 03			jr .pastdmark  
06f3 ..			.dmark: db "ER1"  
06f6 f1			.pastdmark: pop af  
06f7			endm  
# End of macro DMARK
06f7						CALLMONITOR 
06f7 cd 6c fe			call debug_vector  
06fa				endm  
# End of macro CALLMONITOR
06fa					endif 
06fa 3a 77 fa			ld a, (store_page)	; get file id 
06fd 32 6b fa			ld (store_tmpid), a 
0700			 
0700 3a 79 fa			ld a, (store_page+2)    ; get count of extends 
0703 32 6a fa			ld (store_tmpext), a 
0706			 
0706				; wipe file header 
0706			 
0706 e1				pop hl 
0707 3e 00			ld a, 0 
0709 32 77 fa			ld (store_page), a 
070c 32 78 fa			ld (store_page+1),a 
070f 11 77 fa			ld de, store_page 
0712					if DEBUG_FORTH_WORDS 
0712						DMARK "ER2" 
0712 f5				push af  
0713 3a 27 07			ld a, (.dmark)  
0716 32 68 fe			ld (debug_mark),a  
0719 3a 28 07			ld a, (.dmark+1)  
071c 32 69 fe			ld (debug_mark+1),a  
071f 3a 29 07			ld a, (.dmark+2)  
0722 32 6a fe			ld (debug_mark+2),a  
0725 18 03			jr .pastdmark  
0727 ..			.dmark: db "ER2"  
072a f1			.pastdmark: pop af  
072b			endm  
# End of macro DMARK
072b						CALLMONITOR 
072b cd 6c fe			call debug_vector  
072e				endm  
# End of macro CALLMONITOR
072e					endif 
072e cd cb 04			call storage_write_block 
0731			 
0731			 
0731				; wipe file extents 
0731			 
0731 3a 6a fa			ld a, (store_tmpext) 
0734 47				ld b, a 
0735			 
0735			.eraext:	  
0735 c5				push bc 
0736			 
0736 21 40 00			ld hl, STORE_BLOCK_PHY 
0739 3a 6b fa			ld a,(store_tmpid) 
073c 5f				ld e, a 
073d 50				ld d, b	 
073e					if DEBUG_FORTH_WORDS 
073e						DMARK "ER3" 
073e f5				push af  
073f 3a 53 07			ld a, (.dmark)  
0742 32 68 fe			ld (debug_mark),a  
0745 3a 54 07			ld a, (.dmark+1)  
0748 32 69 fe			ld (debug_mark+1),a  
074b 3a 55 07			ld a, (.dmark+2)  
074e 32 6a fe			ld (debug_mark+2),a  
0751 18 03			jr .pastdmark  
0753 ..			.dmark: db "ER3"  
0756 f1			.pastdmark: pop af  
0757			endm  
# End of macro DMARK
0757						CALLMONITOR 
0757 cd 6c fe			call debug_vector  
075a				endm  
# End of macro CALLMONITOR
075a					endif 
075a cd 99 07			call storage_findnextid 
075d cd f9 0f			call ishlzero 
0760 ca a6 06			jp z,.se_done 
0763			 
0763 e5				push hl 
0764 11 77 fa			ld de, store_page 
0767 cd 66 04			call storage_read_block 
076a			 
076a				; free block	 
076a			 
076a 3e 00			ld a, 0 
076c 32 77 fa			ld (store_page), a 
076f 32 78 fa			ld (store_page+1),a 
0772 11 77 fa			ld de, store_page 
0775 e1				pop hl 
0776					if DEBUG_FORTH_WORDS 
0776						DMARK "ER4" 
0776 f5				push af  
0777 3a 8b 07			ld a, (.dmark)  
077a 32 68 fe			ld (debug_mark),a  
077d 3a 8c 07			ld a, (.dmark+1)  
0780 32 69 fe			ld (debug_mark+1),a  
0783 3a 8d 07			ld a, (.dmark+2)  
0786 32 6a fe			ld (debug_mark+2),a  
0789 18 03			jr .pastdmark  
078b ..			.dmark: db "ER4"  
078e f1			.pastdmark: pop af  
078f			endm  
# End of macro DMARK
078f						CALLMONITOR 
078f cd 6c fe			call debug_vector  
0792				endm  
# End of macro CALLMONITOR
0792					endif 
0792 cd cb 04			call storage_write_block 
0795			 
0795 c1				pop bc 
0796 10 9d			djnz .eraext 
0798			 
0798 c9				ret 
0799			 
0799			 
0799			; Find Free Block 
0799			; --------------- 
0799			; 
0799			; With current bank 
0799			;  
0799			; From given starting logical block 
0799			;    Read block  
0799			;    If no file id 
0799			;         Return block id 
0799			 
0799			 
0799			; hl starting page number 
0799			; hl contains free page number or zero if no pages free 
0799			; e contains the file id to locate 
0799			; d contains the block number 
0799			 
0799			; TODO change to find file id and use zero for free block 
0799			 
0799			storage_findnextid: 
0799			 
0799				; now locate first 0 page to mark as a free block 
0799			 
0799 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
079b			;	ld hl, STORE_BLOCK_PHY 
079b			 
079b					if DEBUG_FORTH_WORDS 
079b					DMARK "FNI" 
079b f5				push af  
079c 3a b0 07			ld a, (.dmark)  
079f 32 68 fe			ld (debug_mark),a  
07a2 3a b1 07			ld a, (.dmark+1)  
07a5 32 69 fe			ld (debug_mark+1),a  
07a8 3a b2 07			ld a, (.dmark+2)  
07ab 32 6a fe			ld (debug_mark+2),a  
07ae 18 03			jr .pastdmark  
07b0 ..			.dmark: db "FNI"  
07b3 f1			.pastdmark: pop af  
07b4			endm  
# End of macro DMARK
07b4						CALLMONITOR 
07b4 cd 6c fe			call debug_vector  
07b7				endm  
# End of macro CALLMONITOR
07b7					endif 
07b7			.ff1:   	 
07b7 e5					push hl 
07b8 c5					push bc 
07b9 d5					push de 
07ba cd 0d 03				call se_readbyte 
07bd 5f					ld e,a 
07be 23					inc hl 
07bf cd 0d 03				call se_readbyte 
07c2 57					ld d, a 
07c3 e1					pop hl 
07c4 e5					push hl 
07c5 cd ee 0f				call cmp16 
07c8 28 49				jr z, .fffound 
07ca			 
07ca d1					pop de 
07cb c1					pop bc 
07cc e1					pop hl 
07cd			 
07cd					; is found? 
07cd					;cp e 
07cd					;ret z 
07cd			 
07cd 3e 40				ld a, STORE_BLOCK_PHY 
07cf cd d0 0f				call addatohl 
07d2 10 e3				djnz .ff1 
07d4			 
07d4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07d6			.ff2:   	 
07d6			 
07d6 e5					push hl 
07d7 c5					push bc 
07d8 d5					push de 
07d9 cd 0d 03				call se_readbyte 
07dc 5f					ld e,a 
07dd 23					inc hl 
07de cd 0d 03				call se_readbyte 
07e1 57					ld d, a 
07e2			 
07e2 e1					pop hl 
07e3 e5					push hl 
07e4 cd ee 0f				call cmp16 
07e7 28 2a				jr z, .fffound 
07e9			 
07e9 d1					pop de 
07ea c1					pop bc 
07eb e1					pop hl 
07ec					; is found? 
07ec					;cp e 
07ec					;ret z 
07ec			 
07ec 3e 40				ld a, STORE_BLOCK_PHY 
07ee cd d0 0f				call addatohl 
07f1 10 e3				djnz .ff2 
07f3			 
07f3			 
07f3					if DEBUG_FORTH_WORDS 
07f3					DMARK "FN-" 
07f3 f5				push af  
07f4 3a 08 08			ld a, (.dmark)  
07f7 32 68 fe			ld (debug_mark),a  
07fa 3a 09 08			ld a, (.dmark+1)  
07fd 32 69 fe			ld (debug_mark+1),a  
0800 3a 0a 08			ld a, (.dmark+2)  
0803 32 6a fe			ld (debug_mark+2),a  
0806 18 03			jr .pastdmark  
0808 ..			.dmark: db "FN-"  
080b f1			.pastdmark: pop af  
080c			endm  
# End of macro DMARK
080c					;	push af 
080c					;	ld a, 'n' 
080c					;	ld (debug_mark),a 
080c					;	pop af 
080c						CALLMONITOR 
080c cd 6c fe			call debug_vector  
080f				endm  
# End of macro CALLMONITOR
080f					endif 
080f				; no free marks! 
080f 21 00 00				ld hl, 0 
0812 c9				ret 
0813			.fffound: 
0813				 
0813			 
0813 d1					pop de 
0814 c1					pop bc 
0815 e1					pop hl 
0816					if DEBUG_FORTH_WORDS 
0816					DMARK "FNF" 
0816 f5				push af  
0817 3a 2b 08			ld a, (.dmark)  
081a 32 68 fe			ld (debug_mark),a  
081d 3a 2c 08			ld a, (.dmark+1)  
0820 32 69 fe			ld (debug_mark+1),a  
0823 3a 2d 08			ld a, (.dmark+2)  
0826 32 6a fe			ld (debug_mark+2),a  
0829 18 03			jr .pastdmark  
082b ..			.dmark: db "FNF"  
082e f1			.pastdmark: pop af  
082f			endm  
# End of macro DMARK
082f					;	push af 
082f					;	ld a, 'n' 
082f					;	ld (debug_mark),a 
082f					;	pop af 
082f						CALLMONITOR 
082f cd 6c fe			call debug_vector  
0832				endm  
# End of macro CALLMONITOR
0832					endif 
0832 c9				ret 
0833			 
0833			 
0833			 
0833			; Free Space 
0833			; ---------- 
0833			; 
0833			; With current bank 
0833			; 
0833			; Set block count to zero 
0833			; Starting with first logical block 
0833			;      Find free block  
0833			;      If block id given, increment block count 
0833			; 
0833			;  
0833			 
0833			 
0833			; hl contains count of free blocks 
0833			 
0833			storage_freeblocks: 
0833			 
0833				; now locate first 0 page to mark as a free block 
0833			 
0833 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0835 21 40 00			ld hl, STORE_BLOCK_PHY 
0838 11 00 00			ld de, 0 
083b			 
083b			.fb1:   	 
083b e5					push hl 
083c c5					push bc 
083d d5					push de 
083e cd 0d 03				call se_readbyte 
0841 d1					pop de 
0842 c1					pop bc 
0843 e1					pop hl 
0844			 
0844					; is free? 
0844 fe 00				cp 0 
0846 20 01				jr nz, .ff1cont 
0848 13					inc de 
0849			 
0849			.ff1cont: 
0849			 
0849			 
0849 3e 40				ld a, STORE_BLOCK_PHY 
084b cd d0 0f				call addatohl 
084e 10 eb				djnz .fb1 
0850			 
0850 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0852			.fb2:   	 
0852 e5					push hl 
0853 c5					push bc 
0854 d5					push de 
0855 cd 0d 03				call se_readbyte 
0858 d1					pop de 
0859 c1					pop bc 
085a e1					pop hl 
085b			 
085b					; is free? 
085b fe 00				cp 0 
085d 20 01				jr nz, .ff2cont 
085f 13					inc de 
0860			 
0860			.ff2cont: 
0860			 
0860 3e 40				ld a, STORE_BLOCK_PHY 
0862 cd d0 0f				call addatohl 
0865 10 eb				djnz .fb2 
0867			 
0867 eb				ex de, hl 
0868 c9				ret 
0869			 
0869			; Get File ID 
0869			; ----------- 
0869			; 
0869			; With current bank 
0869			;  
0869			; Load Block 0 Config 
0869			; Get max file id number 
0869			; For each logical block 
0869			;    Read block file id 
0869			;      If first block of file and dont have file id 
0869			;         if file get id and exit 
0869			 
0869			 
0869			 
0869			 
0869			; Create File 
0869			; ----------- 
0869			; 
0869			; With current bank  
0869			; Load Block 0 Config 
0869			; Get max file id number 
0869			; Increment file id number 
0869			; Save Config 
0869			; Find free block 
0869			; Set buffer with file name and file id 
0869			; Write buffer to free block  
0869			 
0869			 
0869			; hl point to file name 
0869			; hl returns file id 
0869			 
0869			; file format: 
0869			; byte 0 - file id 
0869			; byte 1 - extent number 
0869			; byte 2-> data 
0869			 
0869			; format for extent number 0: 
0869			; 
0869			; byte 0 - file id 
0869			; byte 1 - extent 0 
0869			; byte 2 - extent count 
0869			; byte 3 -> file name and meta data 
0869			 
0869			 
0869			storage_create: 
0869				if DEBUG_STORESE 
0869					DMARK "SCR" 
0869 f5				push af  
086a 3a 7e 08			ld a, (.dmark)  
086d 32 68 fe			ld (debug_mark),a  
0870 3a 7f 08			ld a, (.dmark+1)  
0873 32 69 fe			ld (debug_mark+1),a  
0876 3a 80 08			ld a, (.dmark+2)  
0879 32 6a fe			ld (debug_mark+2),a  
087c 18 03			jr .pastdmark  
087e ..			.dmark: db "SCR"  
0881 f1			.pastdmark: pop af  
0882			endm  
# End of macro DMARK
0882					CALLMONITOR 
0882 cd 6c fe			call debug_vector  
0885				endm  
# End of macro CALLMONITOR
0885				endif 
0885			 
0885 e5				push hl		; save file name pointer 
0886			 
0886 cd 17 05			call storage_get_block_0 
0889			 
0889 3a 77 fa			ld a,(store_page)	; get current file id 
088c 3c				inc a 
088d 32 77 fa			ld (store_page),a 
0890				 
0890 32 6b fa			ld (store_tmpid),a			; save id 
0893			 
0893 21 00 00			ld hl, 0 
0896 11 77 fa			ld de, store_page 
0899				if DEBUG_STORESE 
0899					DMARK "SCw" 
0899 f5				push af  
089a 3a ae 08			ld a, (.dmark)  
089d 32 68 fe			ld (debug_mark),a  
08a0 3a af 08			ld a, (.dmark+1)  
08a3 32 69 fe			ld (debug_mark+1),a  
08a6 3a b0 08			ld a, (.dmark+2)  
08a9 32 6a fe			ld (debug_mark+2),a  
08ac 18 03			jr .pastdmark  
08ae ..			.dmark: db "SCw"  
08b1 f1			.pastdmark: pop af  
08b2			endm  
# End of macro DMARK
08b2					CALLMONITOR 
08b2 cd 6c fe			call debug_vector  
08b5				endm  
# End of macro CALLMONITOR
08b5				endif 
08b5 cd cb 04			call storage_write_block	 ; save update 
08b8			 
08b8				if DEBUG_STORESE 
08b8 11 77 fa				ld de, store_page 
08bb					DMARK "SCC" 
08bb f5				push af  
08bc 3a d0 08			ld a, (.dmark)  
08bf 32 68 fe			ld (debug_mark),a  
08c2 3a d1 08			ld a, (.dmark+1)  
08c5 32 69 fe			ld (debug_mark+1),a  
08c8 3a d2 08			ld a, (.dmark+2)  
08cb 32 6a fe			ld (debug_mark+2),a  
08ce 18 03			jr .pastdmark  
08d0 ..			.dmark: db "SCC"  
08d3 f1			.pastdmark: pop af  
08d4			endm  
# End of macro DMARK
08d4					CALLMONITOR 
08d4 cd 6c fe			call debug_vector  
08d7				endm  
# End of macro CALLMONITOR
08d7				endif 
08d7				;  
08d7				 
08d7 21 40 00			ld hl, STORE_BLOCK_PHY 
08da 11 00 00			ld de, 0 
08dd cd 99 07			call storage_findnextid 
08e0			 
08e0 22 62 fa			ld (store_tmppageid), hl    ; save page to use  
08e3			 
08e3				; TODO detect 0 = no spare blocks 
08e3			 
08e3				; hl now contains the free page to use for the file header page 
08e3			 
08e3				if DEBUG_STORESE 
08e3				DMARK "SCF" 
08e3 f5				push af  
08e4 3a f8 08			ld a, (.dmark)  
08e7 32 68 fe			ld (debug_mark),a  
08ea 3a f9 08			ld a, (.dmark+1)  
08ed 32 69 fe			ld (debug_mark+1),a  
08f0 3a fa 08			ld a, (.dmark+2)  
08f3 32 6a fe			ld (debug_mark+2),a  
08f6 18 03			jr .pastdmark  
08f8 ..			.dmark: db "SCF"  
08fb f1			.pastdmark: pop af  
08fc			endm  
# End of macro DMARK
08fc					CALLMONITOR 
08fc cd 6c fe			call debug_vector  
08ff				endm  
# End of macro CALLMONITOR
08ff				endif 
08ff			 
08ff 22 62 fa			ld (store_tmppageid), hl 
0902				 
0902 3a 6b fa			ld a,(store_tmpid)    ; get file id 
0905			;	ld a, (store_filecache)			; save to cache 
0905			 
0905 32 77 fa			ld (store_page),a    ; set page id 
0908 3e 00			ld a, 0			 ; extent 0 is file header 
090a 32 78 fa			ld (store_page+1), a   ; set file extent 
090d			 
090d 32 79 fa			ld (store_page+2), a   ; extent count for the file 
0910			 
0910			;	inc hl 		; init block 0 of file 
0910			;	inc hl   		; skip file and extent id 
0910			 ;       ld a, 0 
0910			;	ld (hl),a 
0910			;	ld a, (store_filecache+1)  	; save to cache 
0910			 
0910			;	inc hl    ; file name 
0910				 
0910				 
0910 11 7a fa			ld de, store_page+3    ; get buffer for term string to use as file name 
0913				if DEBUG_STORESE 
0913					DMARK "SCc" 
0913 f5				push af  
0914 3a 28 09			ld a, (.dmark)  
0917 32 68 fe			ld (debug_mark),a  
091a 3a 29 09			ld a, (.dmark+1)  
091d 32 69 fe			ld (debug_mark+1),a  
0920 3a 2a 09			ld a, (.dmark+2)  
0923 32 6a fe			ld (debug_mark+2),a  
0926 18 03			jr .pastdmark  
0928 ..			.dmark: db "SCc"  
092b f1			.pastdmark: pop af  
092c			endm  
# End of macro DMARK
092c					CALLMONITOR 
092c cd 6c fe			call debug_vector  
092f				endm  
# End of macro CALLMONITOR
092f				endif 
092f e1				pop hl    ; get zero term string 
0930 e5				push hl 
0931 3e 00			ld a, 0 
0933 cd 39 14			call strlent 
0936 23				inc hl   ; cover zero term 
0937 06 00			ld b,0 
0939 4d				ld c,l 
093a e1				pop hl 
093b				;ex de, hl 
093b				if DEBUG_STORESE 
093b					DMARK "SCa" 
093b f5				push af  
093c 3a 50 09			ld a, (.dmark)  
093f 32 68 fe			ld (debug_mark),a  
0942 3a 51 09			ld a, (.dmark+1)  
0945 32 69 fe			ld (debug_mark+1),a  
0948 3a 52 09			ld a, (.dmark+2)  
094b 32 6a fe			ld (debug_mark+2),a  
094e 18 03			jr .pastdmark  
0950 ..			.dmark: db "SCa"  
0953 f1			.pastdmark: pop af  
0954			endm  
# End of macro DMARK
0954					;push af 
0954					;ld a, 'a' 
0954					;ld (debug_mark),a 
0954					;pop af 
0954					CALLMONITOR 
0954 cd 6c fe			call debug_vector  
0957				endm  
# End of macro CALLMONITOR
0957				endif 
0957 ed b0			ldir    ; copy zero term string 
0959				if DEBUG_STORESE 
0959					DMARK "SCA" 
0959 f5				push af  
095a 3a 6e 09			ld a, (.dmark)  
095d 32 68 fe			ld (debug_mark),a  
0960 3a 6f 09			ld a, (.dmark+1)  
0963 32 69 fe			ld (debug_mark+1),a  
0966 3a 70 09			ld a, (.dmark+2)  
0969 32 6a fe			ld (debug_mark+2),a  
096c 18 03			jr .pastdmark  
096e ..			.dmark: db "SCA"  
0971 f1			.pastdmark: pop af  
0972			endm  
# End of macro DMARK
0972					CALLMONITOR 
0972 cd 6c fe			call debug_vector  
0975				endm  
# End of macro CALLMONITOR
0975				endif 
0975			 
0975				; write file header page 
0975			 
0975 2a 62 fa			ld hl,(store_tmppageid) 
0978 11 77 fa			ld de, store_page 
097b				if DEBUG_STORESE 
097b					DMARK "SCb" 
097b f5				push af  
097c 3a 90 09			ld a, (.dmark)  
097f 32 68 fe			ld (debug_mark),a  
0982 3a 91 09			ld a, (.dmark+1)  
0985 32 69 fe			ld (debug_mark+1),a  
0988 3a 92 09			ld a, (.dmark+2)  
098b 32 6a fe			ld (debug_mark+2),a  
098e 18 03			jr .pastdmark  
0990 ..			.dmark: db "SCb"  
0993 f1			.pastdmark: pop af  
0994			endm  
# End of macro DMARK
0994					;push af 
0994					;ld a, 'b' 
0994					;ld (debug_mark),a 
0994					;pop af 
0994					CALLMONITOR 
0994 cd 6c fe			call debug_vector  
0997				endm  
# End of macro CALLMONITOR
0997				endif 
0997 cd cb 04			call storage_write_block 
099a			 
099a 3a 6b fa			ld a, (store_tmpid) 
099d 6f				ld l, a 
099e 26 00			ld h,0 
09a0				if DEBUG_STORESE 
09a0					DMARK "SCz" 
09a0 f5				push af  
09a1 3a b5 09			ld a, (.dmark)  
09a4 32 68 fe			ld (debug_mark),a  
09a7 3a b6 09			ld a, (.dmark+1)  
09aa 32 69 fe			ld (debug_mark+1),a  
09ad 3a b7 09			ld a, (.dmark+2)  
09b0 32 6a fe			ld (debug_mark+2),a  
09b3 18 03			jr .pastdmark  
09b5 ..			.dmark: db "SCz"  
09b8 f1			.pastdmark: pop af  
09b9			endm  
# End of macro DMARK
09b9					CALLMONITOR 
09b9 cd 6c fe			call debug_vector  
09bc				endm  
# End of macro CALLMONITOR
09bc				endif 
09bc c9				ret 
09bd				 
09bd			 
09bd			 
09bd			; 
09bd			; Read File 
09bd			; 
09bd			; h - file id to locate 
09bd			; l - extent to locate 
09bd			; de - pointer to string to read into 
09bd			; 
09bd			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09bd			 
09bd			.sr_fail: 
09bd d1				pop de 
09be c9				ret 
09bf			 
09bf			storage_read: 
09bf			 
09bf			 
09bf d5				push de 
09c0			 
09c0			; TODO BUG the above push is it popped before the RET Z? 
09c0			 
09c0			; TODO how to handle multiple part blocks 
09c0			 
09c0				; locate file extent to read 
09c0			 
09c0 5c				ld e, h 
09c1 55				ld d, l 
09c2			 
09c2			.srext: 
09c2 22 75 fa			ld (store_readptr), hl     ; save the current extent to load 
09c5 ed 53 73 fa		ld (store_readbuf), de     ; save the current buffer to load in to 
09c9			 
09c9 21 40 00			ld hl, STORE_BLOCK_PHY 
09cc				if DEBUG_STORESE 
09cc					DMARK "sre" 
09cc f5				push af  
09cd 3a e1 09			ld a, (.dmark)  
09d0 32 68 fe			ld (debug_mark),a  
09d3 3a e2 09			ld a, (.dmark+1)  
09d6 32 69 fe			ld (debug_mark+1),a  
09d9 3a e3 09			ld a, (.dmark+2)  
09dc 32 6a fe			ld (debug_mark+2),a  
09df 18 03			jr .pastdmark  
09e1 ..			.dmark: db "sre"  
09e4 f1			.pastdmark: pop af  
09e5			endm  
# End of macro DMARK
09e5					CALLMONITOR 
09e5 cd 6c fe			call debug_vector  
09e8				endm  
# End of macro CALLMONITOR
09e8				endif 
09e8 cd 99 07			call storage_findnextid 
09eb			 
09eb				if DEBUG_STORESE 
09eb					DMARK "srf" 
09eb f5				push af  
09ec 3a 00 0a			ld a, (.dmark)  
09ef 32 68 fe			ld (debug_mark),a  
09f2 3a 01 0a			ld a, (.dmark+1)  
09f5 32 69 fe			ld (debug_mark+1),a  
09f8 3a 02 0a			ld a, (.dmark+2)  
09fb 32 6a fe			ld (debug_mark+2),a  
09fe 18 03			jr .pastdmark  
0a00 ..			.dmark: db "srf"  
0a03 f1			.pastdmark: pop af  
0a04			endm  
# End of macro DMARK
0a04					CALLMONITOR 
0a04 cd 6c fe			call debug_vector  
0a07				endm  
# End of macro CALLMONITOR
0a07				endif 
0a07 cd f9 0f			call ishlzero 
0a0a			;	ld a, l 
0a0a			;	add h 
0a0a			;	cp 0 
0a0a 28 b1			jr z,.sr_fail			; block not found so EOF 
0a0c			 
0a0c				; save current address for use by higher level words etc 
0a0c			 
0a0c 22 68 fa			ld (store_openaddr),hl 
0a0f			 
0a0f			 
0a0f				; hl contains page number to load 
0a0f d1				pop de   ; get storage 
0a10 ed 53 73 fa		ld (store_readbuf), de     ; current buffer to load in to 
0a14 d5				push de 
0a15				if DEBUG_STORESE 
0a15					DMARK "srg" 
0a15 f5				push af  
0a16 3a 2a 0a			ld a, (.dmark)  
0a19 32 68 fe			ld (debug_mark),a  
0a1c 3a 2b 0a			ld a, (.dmark+1)  
0a1f 32 69 fe			ld (debug_mark+1),a  
0a22 3a 2c 0a			ld a, (.dmark+2)  
0a25 32 6a fe			ld (debug_mark+2),a  
0a28 18 03			jr .pastdmark  
0a2a ..			.dmark: db "srg"  
0a2d f1			.pastdmark: pop af  
0a2e			endm  
# End of macro DMARK
0a2e					CALLMONITOR 
0a2e cd 6c fe			call debug_vector  
0a31				endm  
# End of macro CALLMONITOR
0a31				endif 
0a31 cd 66 04			call storage_read_block 
0a34			 
0a34				; if this a continuation read??? 
0a34			 
0a34 2a 73 fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a37			 
0a37 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a39 cd d0 0f			call addatohl 
0a3c 7e				ld a,(hl) 
0a3d fe 00			cp 0 
0a3f 28 02			jr z, .markiscont 
0a41 3e ff			ld a, 255 
0a43			 
0a43			.markiscont: 
0a43 32 6a fa			ld (store_readcont), a 
0a46			 
0a46				if DEBUG_STORESE 
0a46					DMARK "srC" 
0a46 f5				push af  
0a47 3a 5b 0a			ld a, (.dmark)  
0a4a 32 68 fe			ld (debug_mark),a  
0a4d 3a 5c 0a			ld a, (.dmark+1)  
0a50 32 69 fe			ld (debug_mark+1),a  
0a53 3a 5d 0a			ld a, (.dmark+2)  
0a56 32 6a fe			ld (debug_mark+2),a  
0a59 18 03			jr .pastdmark  
0a5b ..			.dmark: db "srC"  
0a5e f1			.pastdmark: pop af  
0a5f			endm  
# End of macro DMARK
0a5f					CALLMONITOR 
0a5f cd 6c fe			call debug_vector  
0a62				endm  
# End of macro CALLMONITOR
0a62				endif 
0a62				; only short reads enabled 
0a62			 
0a62 3a 72 fa			ld a, (store_longread) 
0a65 fe 00			cp 0 
0a67 ca 34 0b			jp z, .readdone 
0a6a			 
0a6a			; TODO if block has no zeros then need to read next block  
0a6a			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a6a			; check last byte of physical block. 
0a6a			; if not zero then the next block needs to be loaded 
0a6a			 
0a6a			 
0a6a 2a 73 fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a6d			 
0a6d 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a6f cd d0 0f			call addatohl 
0a72				;dec hl 
0a72 7e				ld a,(hl) 
0a73				if DEBUG_STORESE 
0a73					DMARK "sr?" 
0a73 f5				push af  
0a74 3a 88 0a			ld a, (.dmark)  
0a77 32 68 fe			ld (debug_mark),a  
0a7a 3a 89 0a			ld a, (.dmark+1)  
0a7d 32 69 fe			ld (debug_mark+1),a  
0a80 3a 8a 0a			ld a, (.dmark+2)  
0a83 32 6a fe			ld (debug_mark+2),a  
0a86 18 03			jr .pastdmark  
0a88 ..			.dmark: db "sr?"  
0a8b f1			.pastdmark: pop af  
0a8c			endm  
# End of macro DMARK
0a8c					CALLMONITOR 
0a8c cd 6c fe			call debug_vector  
0a8f				endm  
# End of macro CALLMONITOR
0a8f				endif 
0a8f fe 00			cp 0 
0a91 ca 34 0b			jp z, .readdone 
0a94			 
0a94				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a94			 
0a94 23				inc hl 
0a95			 
0a95 22 73 fa			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a98			 
0a98 ed 5b 75 fa		ld de, (store_readptr)     ; save the current extent to load 
0a9c			 
0a9c eb				ex de, hl 
0a9d			 
0a9d				; next ext 
0a9d			 
0a9d 23				inc hl 
0a9e 22 75 fa			ld  (store_readptr), hl     ; save the current extent to load 
0aa1			 
0aa1				if DEBUG_STORESE 
0aa1					DMARK "sF2" 
0aa1 f5				push af  
0aa2 3a b6 0a			ld a, (.dmark)  
0aa5 32 68 fe			ld (debug_mark),a  
0aa8 3a b7 0a			ld a, (.dmark+1)  
0aab 32 69 fe			ld (debug_mark+1),a  
0aae 3a b8 0a			ld a, (.dmark+2)  
0ab1 32 6a fe			ld (debug_mark+2),a  
0ab4 18 03			jr .pastdmark  
0ab6 ..			.dmark: db "sF2"  
0ab9 f1			.pastdmark: pop af  
0aba			endm  
# End of macro DMARK
0aba					CALLMONITOR 
0aba cd 6c fe			call debug_vector  
0abd				endm  
# End of macro CALLMONITOR
0abd				endif 
0abd			 
0abd				; get and load block 
0abd			 
0abd cd 99 07			call storage_findnextid 
0ac0			 
0ac0				if DEBUG_STORESE 
0ac0					DMARK "sf2" 
0ac0 f5				push af  
0ac1 3a d5 0a			ld a, (.dmark)  
0ac4 32 68 fe			ld (debug_mark),a  
0ac7 3a d6 0a			ld a, (.dmark+1)  
0aca 32 69 fe			ld (debug_mark+1),a  
0acd 3a d7 0a			ld a, (.dmark+2)  
0ad0 32 6a fe			ld (debug_mark+2),a  
0ad3 18 03			jr .pastdmark  
0ad5 ..			.dmark: db "sf2"  
0ad8 f1			.pastdmark: pop af  
0ad9			endm  
# End of macro DMARK
0ad9					CALLMONITOR 
0ad9 cd 6c fe			call debug_vector  
0adc				endm  
# End of macro CALLMONITOR
0adc				endif 
0adc cd f9 0f			call ishlzero 
0adf			;	ld a, l 
0adf			;	add h 
0adf			;	cp 0 
0adf ca bd 09			jp z,.sr_fail			; block not found so EOF 
0ae2				 
0ae2				; save current address for use by higher level words etc 
0ae2			 
0ae2 22 68 fa			ld (store_openaddr),hl 
0ae5			 
0ae5 cd 66 04			call storage_read_block 
0ae8			 
0ae8				; on a continuation block, we now have the file id and ext in the middle of the block 
0ae8				; we need to pull everything back  
0ae8			 
0ae8 ed 5b 73 fa		ld de, (store_readbuf)     ; current buffer to nudge into 
0aec 2a 73 fa			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aef 23				inc hl 
0af0 23				inc hl     ; skip id and ext 
0af1 01 40 00			ld bc, STORE_BLOCK_PHY 
0af4				if DEBUG_STORESE 
0af4					DMARK "SR<" 
0af4 f5				push af  
0af5 3a 09 0b			ld a, (.dmark)  
0af8 32 68 fe			ld (debug_mark),a  
0afb 3a 0a 0b			ld a, (.dmark+1)  
0afe 32 69 fe			ld (debug_mark+1),a  
0b01 3a 0b 0b			ld a, (.dmark+2)  
0b04 32 6a fe			ld (debug_mark+2),a  
0b07 18 03			jr .pastdmark  
0b09 ..			.dmark: db "SR<"  
0b0c f1			.pastdmark: pop af  
0b0d			endm  
# End of macro DMARK
0b0d					CALLMONITOR 
0b0d cd 6c fe			call debug_vector  
0b10				endm  
# End of macro CALLMONITOR
0b10				endif 
0b10 ed b0			ldir     ; copy data 
0b12			 
0b12				; move the pointer back and pretend we have a full buffer for next recheck 
0b12			 
0b12 1b				dec de 
0b13 1b				dec de 
0b14			 
0b14			; TODO do pop below now short circuit loop????? 
0b14 c1				pop bc     ; get rid of spare de on stack 
0b15				if DEBUG_STORESE 
0b15					DMARK "SR>" 
0b15 f5				push af  
0b16 3a 2a 0b			ld a, (.dmark)  
0b19 32 68 fe			ld (debug_mark),a  
0b1c 3a 2b 0b			ld a, (.dmark+1)  
0b1f 32 69 fe			ld (debug_mark+1),a  
0b22 3a 2c 0b			ld a, (.dmark+2)  
0b25 32 6a fe			ld (debug_mark+2),a  
0b28 18 03			jr .pastdmark  
0b2a ..			.dmark: db "SR>"  
0b2d f1			.pastdmark: pop af  
0b2e			endm  
# End of macro DMARK
0b2e					CALLMONITOR 
0b2e cd 6c fe			call debug_vector  
0b31				endm  
# End of macro CALLMONITOR
0b31				endif 
0b31 c3 c2 09			jp .srext 
0b34			 
0b34			 
0b34			 
0b34			 
0b34			 
0b34			.readdone:		 
0b34 e1				pop hl 		 ; return start of data to show as not EOF 
0b35 23				inc hl   ; past file id 
0b36 23				inc hl   ; past ext 
0b37				if DEBUG_STORESE 
0b37					DMARK "SRe" 
0b37 f5				push af  
0b38 3a 4c 0b			ld a, (.dmark)  
0b3b 32 68 fe			ld (debug_mark),a  
0b3e 3a 4d 0b			ld a, (.dmark+1)  
0b41 32 69 fe			ld (debug_mark+1),a  
0b44 3a 4e 0b			ld a, (.dmark+2)  
0b47 32 6a fe			ld (debug_mark+2),a  
0b4a 18 03			jr .pastdmark  
0b4c ..			.dmark: db "SRe"  
0b4f f1			.pastdmark: pop af  
0b50			endm  
# End of macro DMARK
0b50					CALLMONITOR 
0b50 cd 6c fe			call debug_vector  
0b53				endm  
# End of macro CALLMONITOR
0b53				endif 
0b53 c9					ret 
0b54			 
0b54			 
0b54			 
0b54			; 
0b54			; Append File 
0b54			; 
0b54			; hl - file id to locate 
0b54			; de - pointer to (multi block) string to write 
0b54			 
0b54			.sa_notfound: 
0b54 d1				pop de 
0b55 c9				ret 
0b56			 
0b56			 
0b56			storage_append: 
0b56				; hl -  file id to append to 
0b56				; de - string to append 
0b56			 
0b56 d5				push de 
0b57				 
0b57				if DEBUG_STORESE 
0b57					DMARK "AP1" 
0b57 f5				push af  
0b58 3a 6c 0b			ld a, (.dmark)  
0b5b 32 68 fe			ld (debug_mark),a  
0b5e 3a 6d 0b			ld a, (.dmark+1)  
0b61 32 69 fe			ld (debug_mark+1),a  
0b64 3a 6e 0b			ld a, (.dmark+2)  
0b67 32 6a fe			ld (debug_mark+2),a  
0b6a 18 03			jr .pastdmark  
0b6c ..			.dmark: db "AP1"  
0b6f f1			.pastdmark: pop af  
0b70			endm  
# End of macro DMARK
0b70					CALLMONITOR 
0b70 cd 6c fe			call debug_vector  
0b73				endm  
# End of macro CALLMONITOR
0b73				endif 
0b73			 
0b73 7d				ld a, l 
0b74 32 6b fa			ld (store_tmpid), a 
0b77			 
0b77				; get file header  
0b77			 
0b77 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b79 3a 6b fa			ld a, (store_tmpid) 
0b7c 5f				ld e, a 
0b7d			 
0b7d 21 40 00				ld hl, STORE_BLOCK_PHY 
0b80 cd 99 07				call storage_findnextid 
0b83			 
0b83 cd f9 0f			call ishlzero 
0b86 28 cc			jr z, .sa_notfound 
0b88			 
0b88 22 62 fa			ld (store_tmppageid), hl 
0b8b			 
0b8b				; TODO handle file id not found 
0b8b			 
0b8b				if DEBUG_STORESE 
0b8b					DMARK "AP2" 
0b8b f5				push af  
0b8c 3a a0 0b			ld a, (.dmark)  
0b8f 32 68 fe			ld (debug_mark),a  
0b92 3a a1 0b			ld a, (.dmark+1)  
0b95 32 69 fe			ld (debug_mark+1),a  
0b98 3a a2 0b			ld a, (.dmark+2)  
0b9b 32 6a fe			ld (debug_mark+2),a  
0b9e 18 03			jr .pastdmark  
0ba0 ..			.dmark: db "AP2"  
0ba3 f1			.pastdmark: pop af  
0ba4			endm  
# End of macro DMARK
0ba4					CALLMONITOR 
0ba4 cd 6c fe			call debug_vector  
0ba7				endm  
# End of macro CALLMONITOR
0ba7				endif 
0ba7			 
0ba7				; update file extent count 
0ba7			 
0ba7 11 77 fa			ld de, store_page 
0baa			 
0baa cd 66 04			call storage_read_block 
0bad			 
0bad				if DEBUG_STORESE 
0bad					DMARK "AP3" 
0bad f5				push af  
0bae 3a c2 0b			ld a, (.dmark)  
0bb1 32 68 fe			ld (debug_mark),a  
0bb4 3a c3 0b			ld a, (.dmark+1)  
0bb7 32 69 fe			ld (debug_mark+1),a  
0bba 3a c4 0b			ld a, (.dmark+2)  
0bbd 32 6a fe			ld (debug_mark+2),a  
0bc0 18 03			jr .pastdmark  
0bc2 ..			.dmark: db "AP3"  
0bc5 f1			.pastdmark: pop af  
0bc6			endm  
# End of macro DMARK
0bc6					CALLMONITOR 
0bc6 cd 6c fe			call debug_vector  
0bc9				endm  
# End of macro CALLMONITOR
0bc9				endif 
0bc9			;	ld (store_tmppageid), hl 
0bc9			 
0bc9 3a 79 fa			ld a, (store_page+2) 
0bcc 3c				inc a 
0bcd 32 79 fa			ld (store_page+2), a 
0bd0 32 6a fa			ld (store_tmpext), a 
0bd3				 
0bd3				if DEBUG_STORESE 
0bd3					DMARK "AP3" 
0bd3 f5				push af  
0bd4 3a e8 0b			ld a, (.dmark)  
0bd7 32 68 fe			ld (debug_mark),a  
0bda 3a e9 0b			ld a, (.dmark+1)  
0bdd 32 69 fe			ld (debug_mark+1),a  
0be0 3a ea 0b			ld a, (.dmark+2)  
0be3 32 6a fe			ld (debug_mark+2),a  
0be6 18 03			jr .pastdmark  
0be8 ..			.dmark: db "AP3"  
0beb f1			.pastdmark: pop af  
0bec			endm  
# End of macro DMARK
0bec					CALLMONITOR 
0bec cd 6c fe			call debug_vector  
0bef				endm  
# End of macro CALLMONITOR
0bef				endif 
0bef 2a 62 fa			ld hl, (store_tmppageid) 
0bf2 11 77 fa			ld de, store_page 
0bf5 cd cb 04			call storage_write_block 
0bf8			 
0bf8				; find free block 
0bf8			 
0bf8 11 00 00			ld de, 0			 ; file extent to locate 
0bfb			 
0bfb 21 40 00				ld hl, STORE_BLOCK_PHY 
0bfe cd 99 07				call storage_findnextid 
0c01 cd f9 0f			call ishlzero 
0c04 ca 54 0b			jp z, .sa_notfound 
0c07			 
0c07					; TODO handle no space left 
0c07					 
0c07 22 62 fa				ld (store_tmppageid), hl 
0c0a			 
0c0a				if DEBUG_STORESE 
0c0a					DMARK "AP4" 
0c0a f5				push af  
0c0b 3a 1f 0c			ld a, (.dmark)  
0c0e 32 68 fe			ld (debug_mark),a  
0c11 3a 20 0c			ld a, (.dmark+1)  
0c14 32 69 fe			ld (debug_mark+1),a  
0c17 3a 21 0c			ld a, (.dmark+2)  
0c1a 32 6a fe			ld (debug_mark+2),a  
0c1d 18 03			jr .pastdmark  
0c1f ..			.dmark: db "AP4"  
0c22 f1			.pastdmark: pop af  
0c23			endm  
# End of macro DMARK
0c23					CALLMONITOR 
0c23 cd 6c fe			call debug_vector  
0c26				endm  
# End of macro CALLMONITOR
0c26				endif 
0c26					; init the buffer with zeros so we can id if the buffer is full or not 
0c26			 
0c26 e5					push hl 
0c27 c5					push bc 
0c28			 
0c28 21 77 fa				ld hl, store_page 
0c2b 06 40				ld b, STORE_BLOCK_PHY 
0c2d 3e 00				ld a, 0 
0c2f 77			.zeroblock:	ld (hl), a 
0c30 23					inc hl 
0c31 10 fc				djnz .zeroblock 
0c33			 
0c33 c1					pop bc 
0c34 e1					pop hl 
0c35			 
0c35					; construct block 
0c35			 
0c35 3a 6b fa				ld a, (store_tmpid) 
0c38 32 77 fa				ld (store_page), a   ; file id 
0c3b 3a 6a fa				ld a, (store_tmpext)   ; extent for this block 
0c3e 32 78 fa				ld (store_page+1), a 
0c41			 
0c41 e1					pop hl    ; get string to write 
0c42 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c44 11 79 fa				ld de, store_page+2 
0c47			 
0c47				if DEBUG_STORESE 
0c47					DMARK "AP5" 
0c47 f5				push af  
0c48 3a 5c 0c			ld a, (.dmark)  
0c4b 32 68 fe			ld (debug_mark),a  
0c4e 3a 5d 0c			ld a, (.dmark+1)  
0c51 32 69 fe			ld (debug_mark+1),a  
0c54 3a 5e 0c			ld a, (.dmark+2)  
0c57 32 6a fe			ld (debug_mark+2),a  
0c5a 18 03			jr .pastdmark  
0c5c ..			.dmark: db "AP5"  
0c5f f1			.pastdmark: pop af  
0c60			endm  
# End of macro DMARK
0c60					CALLMONITOR 
0c60 cd 6c fe			call debug_vector  
0c63				endm  
# End of macro CALLMONITOR
0c63				endif 
0c63			 
0c63			 
0c63			 
0c63					; fill buffer with data until end of string or full block 
0c63			 
0c63 7e			.appd:		ld a, (hl) 
0c64 12					ld (de), a 
0c65 fe 00				cp 0 
0c67 28 04				jr z, .appdone 
0c69 23					inc hl 
0c6a 13					inc de 
0c6b 10 f6				djnz .appd 
0c6d			 
0c6d e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c6e f5					push af   		; save last byte dumped 
0c6f			 
0c6f			 
0c6f 2a 62 fa			ld hl, (store_tmppageid) 
0c72 11 77 fa			ld de, store_page 
0c75				if DEBUG_STORESE 
0c75					DMARK "AP6" 
0c75 f5				push af  
0c76 3a 8a 0c			ld a, (.dmark)  
0c79 32 68 fe			ld (debug_mark),a  
0c7c 3a 8b 0c			ld a, (.dmark+1)  
0c7f 32 69 fe			ld (debug_mark+1),a  
0c82 3a 8c 0c			ld a, (.dmark+2)  
0c85 32 6a fe			ld (debug_mark+2),a  
0c88 18 03			jr .pastdmark  
0c8a ..			.dmark: db "AP6"  
0c8d f1			.pastdmark: pop af  
0c8e			endm  
# End of macro DMARK
0c8e					CALLMONITOR 
0c8e cd 6c fe			call debug_vector  
0c91				endm  
# End of macro CALLMONITOR
0c91				endif 
0c91 cd cb 04				call storage_write_block 
0c94			 
0c94			 
0c94				; was that a full block of data written? 
0c94				; any more to write out? 
0c94			 
0c94				; if yes then set vars and jump to start of function again 
0c94			 
0c94 f1					pop af 
0c95 d1					pop de 
0c96			 
0c96 fe 00				cp 0		 ; no, string was fully written 
0c98 c8					ret z 
0c99			 
0c99					; setup vars for next cycle 
0c99			 
0c99 3a 6b fa				ld a, (store_tmpid) 
0c9c 6f					ld l, a 
0c9d 26 00				ld h, 0 
0c9f			 
0c9f c3 56 0b			 	jp storage_append	 ; yes, need to write out some more 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			 
0ca2			if DEBUG_STORECF 
0ca2			storageput:	 
0ca2					ret 
0ca2			storageread: 
0ca2					ld hl, store_page 
0ca2					ld b, 200 
0ca2					ld a,0 
0ca2			.src:		ld (hl),a 
0ca2					inc hl 
0ca2					djnz .src 
0ca2					 
0ca2			 
0ca2					ld de, 0 
0ca2					ld bc, 1 
0ca2					ld hl, store_page 
0ca2					call cfRead 
0ca2			 
0ca2				call cfGetError 
0ca2				ld hl,scratch 
0ca2				call hexout 
0ca2				ld hl, scratch+2 
0ca2				ld a, 0 
0ca2				ld (hl),a 
0ca2				ld de, scratch 
0ca2				ld a,display_row_1 
0ca2				call str_at_display 
0ca2				call update_display 
0ca2			 
0ca2					ld hl, store_page 
0ca2					ld (os_cur_ptr),hl 
0ca2			 
0ca2					ret 
0ca2			endif 
0ca2			 
0ca2			 
0ca2			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ca2			 
0ca2			storage_clear_page: 
0ca2 e5				push hl 
0ca3 d5				push de 
0ca4 c5				push bc 
0ca5 21 77 fa			ld hl, store_page 
0ca8 3e 00			ld a, 0 
0caa 77				ld (hl), a 
0cab			 
0cab 11 78 fa			ld de, store_page+1 
0cae 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cb1			 
0cb1 ed b0			ldir 
0cb3				 
0cb3 c1				pop bc 
0cb4 d1				pop de 
0cb5 e1				pop hl 
0cb6 c9				ret 
0cb7			 
0cb7			; eof 
# End of file firmware_storage.asm
0cb7			  
0cb7			; support routines for above hardware abstraction layer  
0cb7			  
0cb7			include "firmware_general.asm"        ; general support functions  
0cb7			 
0cb7			; word look up 
0cb7			 
0cb7			; in 
0cb7			; a is the index 
0cb7			; hl is pointer start of array 
0cb7			; 
0cb7			; returns 
0cb7			; hl to the word 
0cb7			; 
0cb7			 
0cb7			table_lookup:  
0cb7 d5					push de 
0cb8 eb					ex de, hl 
0cb9			 
0cb9 6f					ld l, a 
0cba 26 00				ld h, 0 
0cbc 29					add hl, hl 
0cbd 19					add hl, de 
0cbe 7e					ld a, (hl) 
0cbf 23					inc hl 
0cc0 66					ld h,(hl) 
0cc1 6f					ld l, a 
0cc2			 
0cc2 d1					pop de 
0cc3 c9					ret 
0cc4			 
0cc4			; Delay loops 
0cc4			 
0cc4			 
0cc4			 
0cc4			aDelayInMS: 
0cc4 c5				push bc 
0cc5 47				ld b,a 
0cc6			msdelay: 
0cc6 c5				push bc 
0cc7				 
0cc7			 
0cc7 01 41 00			ld bc,041h 
0cca cd e2 0c			call delayloop 
0ccd c1				pop bc 
0cce 05				dec b 
0ccf 20 f5			jr nz,msdelay 
0cd1			 
0cd1			;if CPU_CLOCK_8MHZ 
0cd1			;msdelay8: 
0cd1			;	push bc 
0cd1			;	 
0cd1			; 
0cd1			;	ld bc,041h 
0cd1			;	call delayloop 
0cd1			;	pop bc 
0cd1			;	dec b 
0cd1			;	jr nz,msdelay8 
0cd1			;endif 
0cd1			 
0cd1			 
0cd1 c1				pop bc 
0cd2 c9				ret 
0cd3			 
0cd3			 
0cd3			delay250ms: 
0cd3				;push de 
0cd3 01 00 40			ld bc, 04000h 
0cd6 c3 e2 0c			jp delayloop 
0cd9			delay500ms: 
0cd9				;push de 
0cd9 01 00 80			ld bc, 08000h 
0cdc c3 e2 0c			jp delayloop 
0cdf			delay1s: 
0cdf				;push bc 
0cdf			   ; Clobbers A, d and e 
0cdf 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0ce2			delayloop: 
0ce2 c5			    push bc 
0ce3			 
0ce3			if BASE_CPM 
0ce3				ld bc, CPM_DELAY_TUNE 
0ce3			.cpmloop: 
0ce3				push bc 
0ce3			 
0ce3			endif 
0ce3			 
0ce3			 
0ce3			 
0ce3			delayloopi: 
0ce3			;	push bc 
0ce3			;.dl: 
0ce3 cb 47		    bit     0,a    	; 8 
0ce5 cb 47		    bit     0,a    	; 8 
0ce7 cb 47		    bit     0,a    	; 8 
0ce9 e6 ff		    and     255  	; 7 
0ceb 0b			    dec     bc      	; 6 
0cec 79			    ld      a,c     	; 4 
0ced b0			    or      b     	; 4 
0cee c2 e3 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cf1			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cf1				;pop de 
0cf1			;pop bc 
0cf1			 
0cf1			if BASE_CPM 
0cf1				pop bc 
0cf1				 
0cf1			    dec     bc      	; 6 
0cf1			    ld      a,c     	; 4 
0cf1			    or      b     	; 4 
0cf1			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cf1				 
0cf1			 
0cf1			endif 
0cf1			;if CPU_CLOCK_8MHZ 
0cf1			;    pop bc 
0cf1			;    push bc 
0cf1			;.dl8: 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    and     255  	; 7 
0cf1			;    dec     bc      	; 6 
0cf1			;    ld      a,c     	; 4 
0cf1			;    or      b     	; 4 
0cf1			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf1			;endif 
0cf1			 
0cf1			;if CPU_CLOCK_10MHZ 
0cf1			;    pop bc 
0cf1			;    push bc 
0cf1			;.dl8: 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    bit     0,a    	; 8 
0cf1			;    and     255  	; 7 
0cf1			;    dec     bc      	; 6 
0cf1			;    ld      a,c     	; 4 
0cf1			;    or      b     	; 4 
0cf1			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf1			;endif 
0cf1 c1			    pop bc 
0cf2			 
0cf2 c9				ret 
0cf3			 
0cf3			 
0cf3			 
0cf3			; eof 
# End of file firmware_general.asm
0cf3			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0cf3			; display routines that use the physical hardware abstraction layer 
0cf3			 
0cf3			 
0cf3			; Display an activity indicator 
0cf3			; Each call returns the new char pointed to in hl 
0cf3			 
0cf3			active: 
0cf3 3a c3 fb			ld a, (display_active) 
0cf6 fe 06			cp 6 
0cf8			 
0cf8 20 02			jr nz, .sne 
0cfa				; gone past the last one reset sequence 
0cfa 3e ff			ld a, 255 
0cfc			 
0cfc			.sne:   
0cfc				; get the next char in seq 
0cfc 3c				inc a 
0cfd 32 c3 fb			ld (display_active), a 
0d00			 
0d00				; look up the string in the table 
0d00 21 17 0d			ld hl, actseq 
0d03 cb 27			sla a 
0d05 cd d0 0f			call addatohl 
0d08 cd 34 24			call loadwordinhl 
0d0b			 
0d0b				; forth will write the to string when pushing so move from rom to ram 
0d0b			 
0d0b 11 c4 fb			ld de, display_active+1 
0d0e 01 02 00			ld bc, 2 
0d11 ed b0			ldir 
0d13			 
0d13 21 c4 fb			ld hl, display_active+1 
0d16 c9				ret 
0d17				 
0d17				 
0d17			 
0d17			 
0d17			;db "|/-\|-\" 
0d17			 
0d17			actseq: 
0d17			 
0d17 25 0d		dw spin0 
0d19 27 0d		dw spin1 
0d1b 29 0d		dw spin2 
0d1d 2b 0d		dw spin3 
0d1f 29 0d		dw spin2 
0d21 27 0d		dw spin1 
0d23 25 0d		dw spin0 
0d25			 
0d25 .. 00		spin0: db " ", 0 
0d27 .. 00		spin1: db "-", 0 
0d29 .. 00		spin2: db "+", 0 
0d2b .. 00		spin3: db "#", 0 
0d2d			 
0d2d			 
0d2d			; information window 
0d2d			 
0d2d			; pass hl with 1st string to display 
0d2d			; pass de with 2nd string to display 
0d2d			 
0d2d			info_panel: 
0d2d e5				push hl 
0d2e			 
0d2e 2a c9 fb			ld hl, (display_fb_active) 
0d31 e5				push hl    ; future de destination 
0d32 21 ae fd				ld hl, display_fb0 
0d35 22 c9 fb				ld (display_fb_active), hl 
0d38			 
0d38			;	call clear_display 
0d38			 
0d38				if BASE_CPM 
0d38				ld a, '.' 
0d38				else 
0d38 3e a5			ld a, 165 
0d3a				endif 
0d3a cd a1 0d			call fill_display 
0d3d			 
0d3d			 
0d3d 3e 55			ld a, display_row_3 + 5 
0d3f cd af 0d			call str_at_display 
0d42			 
0d42 e1				pop hl 
0d43 d1				pop de 
0d44			 
0d44 e5				push hl 
0d45			 
0d45			 
0d45 3e 2d			ld a, display_row_2 + 5 
0d47 cd af 0d			call str_at_display 
0d4a			 
0d4a			 
0d4a cd bf 0d			call update_display 
0d4d cd 7d 20			call next_page_prompt 
0d50 cd 9c 0d			call clear_display 
0d53			 
0d53				 
0d53 21 0d fd				ld hl, display_fb1 
0d56 22 c9 fb				ld (display_fb_active), hl 
0d59 cd bf 0d			call update_display 
0d5c			 
0d5c e1				pop hl 
0d5d			 
0d5d c9				ret 
0d5e			 
0d5e			 
0d5e			 
0d5e			 
0d5e			; TODO windowing? 
0d5e			 
0d5e			; TODO scroll line up 
0d5e			 
0d5e			scroll_up: 
0d5e			 
0d5e e5				push hl 
0d5f d5				push de 
0d60 c5				push bc 
0d61			 
0d61				; get frame buffer  
0d61			 
0d61 2a c9 fb			ld hl, (display_fb_active) 
0d64 e5				push hl    ; future de destination 
0d65			 
0d65 11 28 00			ld  de, display_cols 
0d68 19				add hl, de 
0d69			 
0d69 d1				pop de 
0d6a			 
0d6a				;ex de, hl 
0d6a 01 9f 00			ld bc, display_fb_len -1  
0d6d			;if DEBUG_FORTH_WORDS 
0d6d			;	DMARK "SCL" 
0d6d			;	CALLMONITOR 
0d6d			;endif	 
0d6d ed b0			ldir 
0d6f			 
0d6f				; wipe bottom row 
0d6f			 
0d6f			 
0d6f 2a c9 fb			ld hl, (display_fb_active) 
0d72 11 a0 00			ld de, display_cols*display_rows 
0d75 19				add hl, de 
0d76 06 28			ld b, display_cols 
0d78 3e 20			ld a, ' ' 
0d7a			.scwipe: 
0d7a 77				ld (hl), a 
0d7b 2b				dec hl 
0d7c 10 fc			djnz .scwipe 
0d7e			 
0d7e				;pop hl 
0d7e			 
0d7e c1				pop bc 
0d7f d1				pop de 
0d80 e1				pop hl 
0d81			 
0d81 c9				ret 
0d82			 
0d82			 
0d82			;scroll_upo: 
0d82			;	ld de, display_row_1 
0d82			 ;	ld hl, display_row_2 
0d82			;	ld bc, display_cols 
0d82			;	ldir 
0d82			;	ld de, display_row_2 
0d82			 ;	ld hl, display_row_3 
0d82			;	ld bc, display_cols 
0d82			;	ldir 
0d82			;	ld de, display_row_3 
0d82			 ;	ld hl, display_row_4 
0d82			;	ld bc, display_cols 
0d82			;	ldir 
0d82			 
0d82			; TODO clear row 4 
0d82			 
0d82			;	ret 
0d82			 
0d82				 
0d82			scroll_down: 
0d82			 
0d82 e5				push hl 
0d83 d5				push de 
0d84 c5				push bc 
0d85			 
0d85				; get frame buffer  
0d85			 
0d85 2a c9 fb			ld hl, (display_fb_active) 
0d88			 
0d88 11 9f 00			ld de, display_fb_len - 1 
0d8b 19				add hl, de 
0d8c			 
0d8c e5			push hl    ; future de destination 
0d8d			 
0d8d 11 28 00			ld  de, display_cols 
0d90 ed 52			sbc hl, de 
0d92			 
0d92			 
0d92 d1				pop de 
0d93			 
0d93			;	ex de, hl 
0d93 01 9f 00			ld bc, display_fb_len -1  
0d96			 
0d96			 
0d96				 
0d96			 
0d96 ed b0			ldir 
0d98			 
0d98				; wipe bottom row 
0d98			 
0d98			 
0d98			;	ld hl, (display_fb_active) 
0d98			;;	ld de, display_cols*display_rows 
0d98			;;	add hl, de 
0d98			;	ld b, display_cols 
0d98			;	ld a, ' ' 
0d98			;.scwiped: 
0d98			;	ld (hl), a 
0d98			;	dec hl 
0d98			;	djnz .scwiped 
0d98			 
0d98				;pop hl 
0d98			 
0d98 c1				pop bc 
0d99 d1				pop de 
0d9a e1				pop hl 
0d9b			 
0d9b c9				ret 
0d9c			;scroll_down: 
0d9c			;	ld de, display_row_4 
0d9c			;	ld hl, display_row_3 
0d9c			;	ld bc, display_cols 
0d9c			;	ldir 
0d9c			;	ld de, display_row_3 
0d9c			; 	ld hl, display_row_2 
0d9c			;	ld bc, display_cols 
0d9c			;	ldir 
0d9c			;	ld de, display_row_2 
0d9c			;	ld hl, display_row_1 
0d9c			;	ld bc, display_cols 
0d9c			;	ldir 
0d9c			;;; TODO clear row 1 
0d9c			;	ret 
0d9c			 
0d9c			 
0d9c			 
0d9c			 
0d9c			 
0d9c			; clear active frame buffer 
0d9c			 
0d9c			clear_display: 
0d9c 3e 20			ld a, ' ' 
0d9e c3 a1 0d			jp fill_display 
0da1			 
0da1			; fill active frame buffer with a char in A 
0da1			 
0da1			fill_display: 
0da1 06 a0			ld b,display_fb_len 
0da3 2a c9 fb			ld hl, (display_fb_active) 
0da6 77			.fd1:	ld (hl),a 
0da7 23				inc hl 
0da8 10 fc			djnz .fd1 
0daa 23				inc hl 
0dab 3e 00			ld a,0 
0dad 77				ld (hl),a 
0dae			 
0dae			 
0dae c9				ret 
0daf			; Write string (DE) at pos (A) to active frame buffer 
0daf			 
0daf 2a c9 fb		str_at_display:    ld hl,(display_fb_active) 
0db2 06 00					ld b,0 
0db4 4f					ld c,a 
0db5 09					add hl,bc 
0db6 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0db7 b7			            OR   A              ;Null terminator? 
0db8 c8			            RET  Z              ;Yes, so finished 
0db9 77					ld (hl),a 
0dba 23				inc hl 
0dbb 13			            INC  DE             ;Point to next character 
0dbc 18 f8		            JR   .sad1     ;Repeat 
0dbe c9					ret 
0dbf			 
0dbf			; using current frame buffer write to physical display 
0dbf			 
0dbf			update_display: 
0dbf e5				push hl 
0dc0 2a c9 fb			ld hl, (display_fb_active) 
0dc3 cd 89 76			call write_display 
0dc6 e1				pop hl 
0dc7 c9				ret 
0dc8			 
0dc8			; TODO scrolling 
0dc8			 
0dc8			 
0dc8			; move cursor right one char 
0dc8			cursor_right: 
0dc8			 
0dc8				; TODO shift right 
0dc8				; TODO if beyond max col 
0dc8				; TODO       cursor_next_line 
0dc8			 
0dc8 c9				ret 
0dc9			 
0dc9			 
0dc9			cursor_next_line: 
0dc9				; TODO first char 
0dc9				; TODO line down 
0dc9				; TODO if past last row 
0dc9				; TODO    scroll up 
0dc9			 
0dc9 c9				ret 
0dca			 
0dca			cursor_left: 
0dca				; TODO shift left 
0dca				; TODO if beyond left  
0dca				; TODO     cursor prev line 
0dca				 
0dca c9				ret 
0dcb			 
0dcb			cursor_prev_line: 
0dcb				; TODO last char 
0dcb				; TODO line up 
0dcb				; TODO if past first row 
0dcb				; TODO   scroll down 
0dcb			 
0dcb c9				ret 
0dcc			 
0dcc			 
0dcc			cout: 
0dcc				; A - char 
0dcc c9				ret 
0dcd			 
0dcd			 
0dcd			; Display a menu and allow item selection (optional toggle items) 
0dcd			; 
0dcd			; format: 
0dcd			; hl pointer to word array with zero term for items 
0dcd			; e.g.    db item1 
0dcd			;         db .... 
0dcd			;         db 0 
0dcd			; 
0dcd			; a = starting menu item  
0dcd			; 
0dcd			; de = pointer item toggle array   (todo) 
0dcd			; 
0dcd			; returns item selected in a 1-... 
0dcd			; returns 0 if back button pressed 
0dcd			; 
0dcd			; NOTE: Uses system frame buffer to display 
0dcd			; 
0dcd			; LEFT, Q = go back 
0dcd			; RIGHT, SPACE, CR = select 
0dcd			; UP, A - Up 
0dcd			; DOWN, Z - Down 
0dcd			 
0dcd			 
0dcd			 
0dcd			 
0dcd			 
0dcd			menu: 
0dcd			 
0dcd					; keep array pointer 
0dcd			 
0dcd 22 70 fa				ld (store_tmp1), hl 
0dd0 32 6e fa				ld (store_tmp2), a 
0dd3			 
0dd3					; check for key bounce 
0dd3			 
0dd3			if BASE_KEV 
0dd3			 
0dd3 cd d4 79		.mbounce:	call cin 
0dd6 fe 00				cp 0 
0dd8 20 f9				jr nz, .mbounce 
0dda			endif 
0dda					; for ease use ex 
0dda			 
0dda					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0dda 21 ae fd				ld hl, display_fb0 
0ddd 22 c9 fb				ld (display_fb_active), hl 
0de0			 
0de0 cd 9c 0d		.mloop:		call clear_display 
0de3 cd bf 0d				call update_display 
0de6			 
0de6					; draw selection id '>' at 1 
0de6			 
0de6					; init start of list display 
0de6			 
0de6 3e 05				ld a, 5 
0de8 32 6c fa				ld (store_tmp3), a   ; display row count 
0deb 3a 6e fa				ld a,( store_tmp2) 
0dee 32 6f fa				ld (store_tmp2+1), a   ; display item count 
0df1			 
0df1					 
0df1			.mitem:	 
0df1			 
0df1			 
0df1 3a 6f fa				ld a,(store_tmp2+1) 
0df4 6f					ld l, a 
0df5 26 00				ld h, 0 
0df7 29					add hl, hl 
0df8 ed 5b 70 fa			ld de, (store_tmp1) 
0dfc 19					add hl, de 
0dfd 7e					ld a, (hl) 
0dfe 23					inc hl 
0dff 66					ld h,(hl) 
0e00 6f					ld l, a 
0e01			 
0e01 cd f9 0f				call ishlzero 
0e04 28 1a				jr z, .mdone 
0e06			 
0e06 eb					ex de, hl 
0e07 3a 6c fa				ld a, (store_tmp3) 
0e0a cd af 0d				call str_at_display 
0e0d					 
0e0d			 
0e0d					; next item 
0e0d 3a 6f fa				ld a, (store_tmp2+1) 
0e10 3c					inc a 
0e11 32 6f fa				ld (store_tmp2+1), a   ; display item count 
0e14			 
0e14			 		; next row 
0e14			 
0e14 3a 6c fa				ld a, (store_tmp3) 
0e17 c6 28				add display_cols 
0e19 32 6c fa				ld (store_tmp3), a 
0e1c			 
0e1c					; at end of screen? 
0e1c			 
0e1c fe 10				cp display_rows*4 
0e1e 20 d1				jr nz, .mitem 
0e20			 
0e20			 
0e20			.mdone: 
0e20 cd f9 0f				call ishlzero 
0e23 28 08				jr z, .nodn 
0e25			 
0e25 3e 78				ld a, display_row_4 
0e27 11 a6 0e				ld de, .mdown 
0e2a cd af 0d				call str_at_display 
0e2d			 
0e2d					; draw options to fill the screens with active item on line 1 
0e2d					; if current option is 2 or more then display ^ in top 
0e2d			 
0e2d 3a 6e fa		.nodn:		ld a, (store_tmp2) 
0e30 fe 00				cp 0 
0e32 28 08				jr z, .noup 
0e34			 
0e34 3e 00				ld a, 0 
0e36 11 a4 0e				ld de, .mup 
0e39 cd af 0d				call str_at_display 
0e3c			 
0e3c 3e 02		.noup:		ld a, 2 
0e3e 11 a2 0e				ld de, .msel 
0e41 cd af 0d				call str_at_display 
0e44			 
0e44					; if current option + 1 is not null then display V in bottom 
0e44					; get key 
0e44 cd bf 0d				call update_display 
0e47			 
0e47			 
0e47					; handle key 
0e47			 
0e47 cd c3 79				call cin_wait 
0e4a			 
0e4a fe 05				cp KEY_UP 
0e4c 28 2b				jr z, .mgoup 
0e4e fe 61				cp 'a' 
0e50 28 27				jr z, .mgoup 
0e52 fe 0a				cp KEY_DOWN 
0e54 28 32				jr z, .mgod 
0e56 fe 7a				cp 'z' 
0e58 28 2e				jr z, .mgod 
0e5a fe 20				cp ' ' 
0e5c 28 34				jr z, .goend 
0e5e fe 0c				cp KEY_RIGHT 
0e60 28 30				jr z, .goend 
0e62 fe 0d				cp KEY_CR 
0e64 28 2c				jr z, .goend 
0e66 fe 71				cp 'q' 
0e68 28 0b				jr z, .goback 
0e6a			 
0e6a fe 0b				cp KEY_LEFT 
0e6c 28 07				jr z, .goback 
0e6e fe 08				cp KEY_BS 
0e70 28 03				jr z, .goback 
0e72 c3 e0 0d				jp .mloop 
0e75			 
0e75			.goback: 
0e75 3e 00			ld a, 0 
0e77 18 1d			jr .goend2 
0e79			 
0e79				; move up one 
0e79			.mgoup: 
0e79 3a 6e fa				ld a, (store_tmp2) 
0e7c fe 00				cp 0 
0e7e ca e0 0d				jp z, .mloop 
0e81 3d					dec a 
0e82 32 6e fa				ld (store_tmp2), a 
0e85 c3 e0 0d				jp .mloop 
0e88			 
0e88				; move down one 
0e88			.mgod: 
0e88 3a 6e fa				ld a, (store_tmp2) 
0e8b 3c					inc a 
0e8c 32 6e fa				ld (store_tmp2), a 
0e8f c3 e0 0d				jp .mloop 
0e92			 
0e92			 
0e92			.goend: 
0e92					; get selected item number 
0e92			 
0e92 3a 6e fa				ld a, (store_tmp2) 
0e95 3c					inc a 
0e96			 
0e96			.goend2: 
0e96 f5					push af 
0e97			 
0e97					; restore active fb 
0e97					; TODO BUG assumes fb1 
0e97			 
0e97 21 0d fd				ld hl, display_fb1 
0e9a 22 c9 fb				ld (display_fb_active), hl 
0e9d			 
0e9d					; restore main regs 
0e9d			 
0e9d			 
0e9d cd bf 0d				call update_display 
0ea0			 
0ea0 f1					pop af 
0ea1			 
0ea1 c9				ret 
0ea2			 
0ea2 .. 00		.msel:   db ">",0 
0ea4 .. 00		.mup:   db "^",0 
0ea6 .. 00		.mdown:   db "v",0 
0ea8			 
0ea8			 
0ea8			; eof 
0ea8			 
# End of file firmware_display.asm
0ea8			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ea8			; random number generators 
0ea8			 
0ea8			 
0ea8			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ea8			 
0ea8			 
0ea8			;-----> Generate a random number 
0ea8			; output a=answer 0<=a<=255 
0ea8			; all registers are preserved except: af 
0ea8			random: 
0ea8 e5			        push    hl 
0ea9 d5			        push    de 
0eaa 2a a8 fb		        ld      hl,(randData) 
0ead ed 5f		        ld      a,r 
0eaf 57			        ld      d,a 
0eb0 5e			        ld      e,(hl) 
0eb1 19			        add     hl,de 
0eb2 85			        add     a,l 
0eb3 ac			        xor     h 
0eb4 22 a8 fb		        ld      (randData),hl 
0eb7 d1			        pop     de 
0eb8 e1			        pop     hl 
0eb9 c9			        ret 
0eba			 
0eba			 
0eba			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0eba			 
0eba			 
0eba			 
0eba			;------LFSR------ 
0eba			;James Montelongo 
0eba			;optimized by Spencer Putt 
0eba			;out: 
0eba			; a = 8 bit random number 
0eba			RandLFSR: 
0eba 21 ae fb		        ld hl,LFSRSeed+4 
0ebd 5e			        ld e,(hl) 
0ebe 23			        inc hl 
0ebf 56			        ld d,(hl) 
0ec0 23			        inc hl 
0ec1 4e			        ld c,(hl) 
0ec2 23			        inc hl 
0ec3 7e			        ld a,(hl) 
0ec4 47			        ld b,a 
0ec5 cb 13		        rl e  
0ec7 cb 12			rl d 
0ec9 cb 11		        rl c  
0ecb 17				rla 
0ecc cb 13		        rl e  
0ece cb 12			rl d 
0ed0 cb 11		        rl c  
0ed2 17				rla 
0ed3 cb 13		        rl e  
0ed5 cb 12			rl d 
0ed7 cb 11		        rl c  
0ed9 17				rla 
0eda 67			        ld h,a 
0edb cb 13		        rl e  
0edd cb 12			rl d 
0edf cb 11		        rl c  
0ee1 17				rla 
0ee2 a8			        xor b 
0ee3 cb 13		        rl e  
0ee5 cb 12			rl d 
0ee7 ac			        xor h 
0ee8 a9			        xor c 
0ee9 aa			        xor d 
0eea 21 b0 fb		        ld hl,LFSRSeed+6 
0eed 11 b1 fb		        ld de,LFSRSeed+7 
0ef0 01 07 00		        ld bc,7 
0ef3 ed b8		        lddr 
0ef5 12			        ld (de),a 
0ef6 c9			        ret 
0ef7			 
0ef7			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ef7			 
0ef7			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ef7			 
0ef7			 
0ef7			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ef7			 
0ef7			prng16: 
0ef7			;Inputs: 
0ef7			;   (seed1) contains a 16-bit seed value 
0ef7			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ef7			;Outputs: 
0ef7			;   HL is the result 
0ef7			;   BC is the result of the LCG, so not that great of quality 
0ef7			;   DE is preserved 
0ef7			;Destroys: 
0ef7			;   AF 
0ef7			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ef7			;160cc 
0ef7			;26 bytes 
0ef7 2a a2 fb		    ld hl,(seed1) 
0efa 44			    ld b,h 
0efb 4d			    ld c,l 
0efc 29			    add hl,hl 
0efd 29			    add hl,hl 
0efe 2c			    inc l 
0eff 09			    add hl,bc 
0f00 22 a2 fb		    ld (seed1),hl 
0f03 2a a0 fb		    ld hl,(seed2) 
0f06 29			    add hl,hl 
0f07 9f			    sbc a,a 
0f08 e6 2d		    and %00101101 
0f0a ad			    xor l 
0f0b 6f			    ld l,a 
0f0c 22 a0 fb		    ld (seed2),hl 
0f0f 09			    add hl,bc 
0f10 c9			    ret 
0f11			 
0f11			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f11			 
0f11			rand32: 
0f11			;Inputs: 
0f11			;   (seed1_0) holds the lower 16 bits of the first seed 
0f11			;   (seed1_1) holds the upper 16 bits of the first seed 
0f11			;   (seed2_0) holds the lower 16 bits of the second seed 
0f11			;   (seed2_1) holds the upper 16 bits of the second seed 
0f11			;   **NOTE: seed2 must be non-zero 
0f11			;Outputs: 
0f11			;   HL is the result 
0f11			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f11			;Destroys: 
0f11			;   AF 
0f11			;Tested and passes all CAcert tests 
0f11			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f11			;it has a period of 18,446,744,069,414,584,320 
0f11			;roughly 18.4 quintillion. 
0f11			;LFSR taps: 0,2,6,7  = 11000101 
0f11			;291cc 
0f11			;seed1_0=$+1 
0f11			;    ld hl,12345 
0f11			;seed1_1=$+1 
0f11			;    ld de,6789 
0f11			;    ld b,h 
0f11			;    ld c,l 
0f11			;    add hl,hl \ rl e \ rl d 
0f11			;    add hl,hl \ rl e \ rl d 
0f11			;    inc l 
0f11			;    add hl,bc 
0f11			;    ld (seed1_0),hl 
0f11			;    ld hl,(seed1_1) 
0f11			;    adc hl,de 
0f11			;    ld (seed1_1),hl 
0f11			;    ex de,hl 
0f11			;seed2_0=$+1 
0f11			;    ld hl,9876 
0f11			;seed2_1=$+1 
0f11			;    ld bc,54321 
0f11			;    add hl,hl \ rl c \ rl b 
0f11			;    ld (seed2_1),bc 
0f11			;    sbc a,a 
0f11			;    and %11000101 
0f11			;    xor l 
0f11			;    ld l,a 
0f11			;    ld (seed2_0),hl 
0f11			;    ex de,hl 
0f11			;    add hl,bc 
0f11			;    ret 
0f11			; 
0f11			 
0f11			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f11			; 20 bytes, 86 cycles (excluding ret) 
0f11			 
0f11			; returns   hl = pseudorandom number 
0f11			; corrupts   a 
0f11			 
0f11			; generates 16-bit pseudorandom numbers with a period of 65535 
0f11			; using the xorshift method: 
0f11			 
0f11			; hl ^= hl << 7 
0f11			; hl ^= hl >> 9 
0f11			; hl ^= hl << 8 
0f11			 
0f11			; some alternative shift triplets which also perform well are: 
0f11			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f11			 
0f11			;  org 32768 
0f11			 
0f11			xrnd: 
0f11 2a a6 fb		  ld hl,(xrandc)       ; seed must not be 0 
0f14 3e 00		  ld a,0 
0f16 bd			  cp l 
0f17 20 02		  jr nz, .xrnd1 
0f19 2e 01		  ld l, 1 
0f1b			.xrnd1: 
0f1b			 
0f1b 7c			  ld a,h 
0f1c 1f			  rra 
0f1d 7d			  ld a,l 
0f1e 1f			  rra 
0f1f ac			  xor h 
0f20 67			  ld h,a 
0f21 7d			  ld a,l 
0f22 1f			  rra 
0f23 7c			  ld a,h 
0f24 1f			  rra 
0f25 ad			  xor l 
0f26 6f			  ld l,a 
0f27 ac			  xor h 
0f28 67			  ld h,a 
0f29			 
0f29 22 a6 fb		  ld (xrandc),hl 
0f2c			 
0f2c c9			  ret 
0f2d			;  
0f2d			 
0f2d			 
0f2d			;;;; int maths 
0f2d			 
0f2d			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f2d			; Divide 16-bit values (with 16-bit result) 
0f2d			; In: Divide BC by divider DE 
0f2d			; Out: BC = result, HL = rest 
0f2d			; 
0f2d			Div16: 
0f2d 21 00 00		    ld hl,0 
0f30 78			    ld a,b 
0f31 06 08		    ld b,8 
0f33			Div16_Loop1: 
0f33 17			    rla 
0f34 ed 6a		    adc hl,hl 
0f36 ed 52		    sbc hl,de 
0f38 30 01		    jr nc,Div16_NoAdd1 
0f3a 19			    add hl,de 
0f3b			Div16_NoAdd1: 
0f3b 10 f6		    djnz Div16_Loop1 
0f3d 17			    rla 
0f3e 2f			    cpl 
0f3f 47			    ld b,a 
0f40 79			    ld a,c 
0f41 48			    ld c,b 
0f42 06 08		    ld b,8 
0f44			Div16_Loop2: 
0f44 17			    rla 
0f45 ed 6a		    adc hl,hl 
0f47 ed 52		    sbc hl,de 
0f49 30 01		    jr nc,Div16_NoAdd2 
0f4b 19			    add hl,de 
0f4c			Div16_NoAdd2: 
0f4c 10 f6		    djnz Div16_Loop2 
0f4e 17			    rla 
0f4f 2f			    cpl 
0f50 41			    ld b,c 
0f51 4f			    ld c,a 
0f52 c9			ret 
0f53			 
0f53			 
0f53			;http://z80-heaven.wikidot.com/math 
0f53			; 
0f53			;Inputs: 
0f53			;     DE and A are factors 
0f53			;Outputs: 
0f53			;     A is not changed 
0f53			;     B is 0 
0f53			;     C is not changed 
0f53			;     DE is not changed 
0f53			;     HL is the product 
0f53			;Time: 
0f53			;     342+6x 
0f53			; 
0f53			Mult16: 
0f53			 
0f53 06 08		     ld b,8          ;7           7 
0f55 21 00 00		     ld hl,0         ;10         10 
0f58 29			       add hl,hl     ;11*8       88 
0f59 07			       rlca          ;4*8        32 
0f5a 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f5c 19			         add hl,de   ;--         -- 
0f5d 10 f9		       djnz $-5      ;13*7+8     99 
0f5f c9			ret 
0f60			 
0f60			; 
0f60			; Square root of 16-bit value 
0f60			; In:  HL = value 
0f60			; Out:  D = result (rounded down) 
0f60			; 
0f60			;Sqr16: 
0f60			;    ld de,#0040 
0f60			;    ld a,l 
0f60			;    ld l,h 
0f60			;    ld h,d 
0f60			;    or a 
0f60			;    ld b,8 
0f60			;Sqr16_Loop: 
0f60			;    sbc hl,de 
0f60			;    jr nc,Sqr16_Skip 
0f60			;    add hl,de 
0f60			;Sqr16_Skip: 
0f60			;    ccf 
0f60			;    rl d 
0f60			;    add a,a 
0f60			;    adc hl,hl 
0f60			;    add a,a 
0f60			;    adc hl,hl 
0f60			;    djnz Sqr16_Loop 
0f60			;    ret 
0f60			; 
0f60			; 
0f60			; Divide 8-bit values 
0f60			; In: Divide E by divider C 
0f60			; Out: A = result, B = rest 
0f60			; 
0f60			Div8: 
0f60 af			    xor a 
0f61 06 08		    ld b,8 
0f63			Div8_Loop: 
0f63 cb 13		    rl e 
0f65 17			    rla 
0f66 91			    sub c 
0f67 30 01		    jr nc,Div8_NoAdd 
0f69 81			    add a,c 
0f6a			Div8_NoAdd: 
0f6a 10 f7		    djnz Div8_Loop 
0f6c 47			    ld b,a 
0f6d 7b			    ld a,e 
0f6e 17			    rla 
0f6f 2f			    cpl 
0f70 c9			    ret 
0f71			 
0f71			; 
0f71			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f71			; In: Multiply A with DE 
0f71			; Out: HL = result 
0f71			; 
0f71			Mult12U: 
0f71 2e 00		    ld l,0 
0f73 87			    add a,a 
0f74 30 01		    jr nc,Mult12U_NoAdd0 
0f76 19			    add hl,de 
0f77			Mult12U_NoAdd0: 
0f77 29			    add hl,hl 
0f78 87			    add a,a 
0f79 30 01		    jr nc,Mult12U_NoAdd1 
0f7b 19			    add hl,de 
0f7c			Mult12U_NoAdd1: 
0f7c 29			    add hl,hl 
0f7d 87			    add a,a 
0f7e 30 01		    jr nc,Mult12U_NoAdd2 
0f80 19			    add hl,de 
0f81			Mult12U_NoAdd2: 
0f81 29			    add hl,hl 
0f82 87			    add a,a 
0f83 30 01		    jr nc,Mult12U_NoAdd3 
0f85 19			    add hl,de 
0f86			Mult12U_NoAdd3: 
0f86 29			    add hl,hl 
0f87 87			    add a,a 
0f88 30 01		    jr nc,Mult12U_NoAdd4 
0f8a 19			    add hl,de 
0f8b			Mult12U_NoAdd4: 
0f8b 29			    add hl,hl 
0f8c 87			    add a,a 
0f8d 30 01		    jr nc,Mult12U_NoAdd5 
0f8f 19			    add hl,de 
0f90			Mult12U_NoAdd5: 
0f90 29			    add hl,hl 
0f91 87			    add a,a 
0f92 30 01		    jr nc,Mult12U_NoAdd6 
0f94 19			    add hl,de 
0f95			Mult12U_NoAdd6: 
0f95 29			    add hl,hl 
0f96 87			    add a,a 
0f97 d0			    ret nc 
0f98 19			    add hl,de 
0f99 c9			    ret 
0f9a			 
0f9a			; 
0f9a			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f9a			; In: Multiply A with DE 
0f9a			;      Put lowest value in A for most efficient calculation 
0f9a			; Out: HL = result 
0f9a			; 
0f9a			Mult12R: 
0f9a 21 00 00		    ld hl,0 
0f9d			Mult12R_Loop: 
0f9d cb 3f		    srl a 
0f9f 30 01		    jr nc,Mult12R_NoAdd 
0fa1 19			    add hl,de 
0fa2			Mult12R_NoAdd: 
0fa2 cb 23		    sla e 
0fa4 cb 12		    rl d 
0fa6 b7			    or a 
0fa7 c2 9d 0f		    jp nz,Mult12R_Loop 
0faa c9			    ret 
0fab			 
0fab			; 
0fab			; Multiply 16-bit values (with 32-bit result) 
0fab			; In: Multiply BC with DE 
0fab			; Out: BCHL = result 
0fab			; 
0fab			Mult32: 
0fab 79			    ld a,c 
0fac 48			    ld c,b 
0fad 21 00 00		    ld hl,0 
0fb0 06 10		    ld b,16 
0fb2			Mult32_Loop: 
0fb2 29			    add hl,hl 
0fb3 17			    rla 
0fb4 cb 11		    rl c 
0fb6 30 07		    jr nc,Mult32_NoAdd 
0fb8 19			    add hl,de 
0fb9 ce 00		    adc a,0 
0fbb d2 bf 0f		    jp nc,Mult32_NoAdd 
0fbe 0c			    inc c 
0fbf			Mult32_NoAdd: 
0fbf 10 f1		    djnz Mult32_Loop 
0fc1 41			    ld b,c 
0fc2 4f			    ld c,a 
0fc3 c9			    ret 
0fc4			 
0fc4			 
0fc4			 
0fc4			; 
0fc4			; Multiply 8-bit values 
0fc4			; In:  Multiply H with E 
0fc4			; Out: HL = result 
0fc4			; 
0fc4			Mult8: 
0fc4 16 00		    ld d,0 
0fc6 6a			    ld l,d 
0fc7 06 08		    ld b,8 
0fc9			Mult8_Loop: 
0fc9 29			    add hl,hl 
0fca 30 01		    jr nc,Mult8_NoAdd 
0fcc 19			    add hl,de 
0fcd			Mult8_NoAdd: 
0fcd 10 fa		    djnz Mult8_Loop 
0fcf c9			    ret 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			 
0fd0			;;http://z80-heaven.wikidot.com/math 
0fd0			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fd0			; 
0fd0			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fd0			;     ld a,16        ;7 
0fd0			;     ld hl,0        ;10 
0fd0			;     jp $+5         ;10 
0fd0			;.DivLoop: 
0fd0			;       add hl,bc    ;-- 
0fd0			;       dec a        ;64 
0fd0			;       jr z,.DivLoopEnd        ;86 
0fd0			; 
0fd0			;       sla e        ;128 
0fd0			;       rl d         ;128 
0fd0			;       adc hl,hl    ;240 
0fd0			;       sbc hl,bc    ;240 
0fd0			;       jr nc,.DivLoop ;23|21 
0fd0			;       inc e        ;-- 
0fd0			;       jp .DivLoop+1 
0fd0			; 
0fd0			;.DivLoopEnd: 
0fd0			 
0fd0			;HL_Div_C: 
0fd0			;Inputs: 
0fd0			;     HL is the numerator 
0fd0			;     C is the denominator 
0fd0			;Outputs: 
0fd0			;     A is the remainder 
0fd0			;     B is 0 
0fd0			;     C is not changed 
0fd0			;     DE is not changed 
0fd0			;     HL is the quotient 
0fd0			; 
0fd0			;       ld b,16 
0fd0			;       xor a 
0fd0			;         add hl,hl 
0fd0			;         rla 
0fd0			;         cp c 
0fd0			;         jr c,$+4 
0fd0			;           inc l 
0fd0			;           sub c 
0fd0			;         djnz $-7 
0fd0			 
0fd0			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fd0			 
0fd0			addatohl: 
0fd0 85			    add   a, l    ; A = A+L 
0fd1 6f			    ld    l, a    ; L = A+L 
0fd2 8c			    adc   a, h    ; A = A+L+H+carry 
0fd3 95			    sub   l       ; A = H+carry 
0fd4 67			    ld    h, a    ; H = H+carry 
0fd5 c9			ret 
0fd6			 
0fd6			addatode: 
0fd6 83			    add   a, e    ; A = A+L 
0fd7 5f			    ld    e, a    ; L = A+L 
0fd8 8a			    adc   a, d    ; A = A+L+H+carry 
0fd9 93			    sub   e       ; A = H+carry 
0fda 57			    ld    d, a    ; H = H+carry 
0fdb c9			ret 
0fdc			 
0fdc			 
0fdc			addatobc: 
0fdc 81			    add   a, c    ; A = A+L 
0fdd 4f			    ld    c, a    ; L = A+L 
0fde 88			    adc   a, b    ; A = A+L+H+carry 
0fdf 91			    sub   c       ; A = H+carry 
0fe0 47			    ld    b, a    ; H = H+carry 
0fe1 c9			ret 
0fe2			 
0fe2			subafromhl: 
0fe2			   ; If A=0 do nothing 
0fe2			    ; Otherwise flip A's sign. Since 
0fe2			    ; the upper byte becomes -1, also 
0fe2			    ; substract 1 from H. 
0fe2 ed 44		    neg 
0fe4 ca ed 0f		    jp    z, Skip 
0fe7 25			    dec   h 
0fe8			     
0fe8			    ; Now add the low byte as usual 
0fe8			    ; Two's complement takes care of 
0fe8			    ; ensuring the result is correct 
0fe8 85			    add   a, l 
0fe9 6f			    ld    l, a 
0fea 8c			    adc   a, h 
0feb 95			    sub   l 
0fec 67			    ld    h, a 
0fed			Skip: 
0fed c9				ret 
0fee			 
0fee			 
0fee			; compare hl and de 
0fee			; returns:  
0fee			; if hl = de, z=1, s=0, c0=0 
0fee			; if hl > de, z=0, s=0, c=0 
0fee			; if hl < de, z=0, s=1, c=1 
0fee			cmp16:	 
0fee b7				or a 
0fef ed 52			sbc hl,de 
0ff1 e0				ret po 
0ff2 7c				ld a,h 
0ff3 1f				rra 
0ff4 ee 40			xor 01000000B 
0ff6 37				scf 
0ff7 8f				adc a,a 
0ff8 c9				ret 
0ff9			 
0ff9			 
0ff9			; test if hl contains zero   - A is destroyed 
0ff9			 
0ff9			ishlzero:    
0ff9 b7				or a     ; reset flags 
0ffa 7c				ld a, h 
0ffb b5				or l        	 
0ffc			 
0ffc c9				ret 
0ffd			 
0ffd			 
0ffd			 
0ffd			 
0ffd			if FORTH_ENABLE_FLOATMATH 
0ffd			;include "float/bbcmath.z80" 
0ffd			include "float/lpfpcalc.asm" 
0ffd			endif 
0ffd			 
0ffd			 
0ffd			; eof 
0ffd			 
# End of file firmware_maths.asm
0ffd			include "firmware_strings.asm"   ; string handling  
0ffd			 
0ffd			 
0ffd			; TODO string len 
0ffd			; input text string, end on cr with zero term 
0ffd			; a offset into frame buffer to start prompt 
0ffd			; d is max length 
0ffd			; e is display size TODO 
0ffd			; c is current cursor position 
0ffd			; hl is ptr to where string will be stored 
0ffd			 
0ffd			 
0ffd			; TODO check limit of buffer for new inserts 
0ffd			; TODO check insert does not push beyond buffer 
0ffd			; TODO scroll in a limited display area 
0ffd			; TODO scroll whole screen on page wrap 
0ffd			 
0ffd			 
0ffd			; TODO handle KEY_PREVWORD 
0ffd			; TODO handle KEY_NEXTWORD 
0ffd			; TODO handle KEY_HOME 
0ffd			; TODO handle KEY_END 
0ffd			; TODO use LCD cursor? 
0ffd			 
0ffd 32 61 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
1000 81					add c 
1001 32 5f fe				ld (input_at_cursor),a	; save draw pos of cursor 
1004 22 64 fe				ld (input_start), hl     ; save ptr to buffer 
1007 79					ld a, c 
1008 cd d0 0f				call addatohl 
100b 22 66 fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
100e 7a					ld a,d 
100f 32 63 fe			        ld (input_size), a       ; save length of input area 
1012 79					ld a, c 
1013 32 52 fe				ld (input_cursor),a      ; init cursor start position  
1016 7b					ld a,e 
1017 32 62 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
101a					 
101a					 
101a			 
101a			;		ld a,(input_ptr) 
101a			;		ld (input_under_cursor),a 	; save what is under the cursor 
101a			 
101a			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
101a					; init cursor shape if not set by the cin routines 
101a 21 be fb				ld hl, cursor_shape 
101d 3e ff				ld a, 255 
101f 77					ld (hl), a 
1020 23					inc hl 
1021 3e 00				ld a, 0 
1023 77					ld (hl), a 
1024			 
1024 3e 0f				ld a, CUR_BLINK_RATE 
1026 32 5d fe				ld (input_cur_flash), a 
1029 3e 01				ld a, 1 
102b 32 5c fe				ld (input_cur_onoff),a 
102e			 
102e			;	if DEBUG_INPUT 
102e			;		push af 
102e			;		ld a, 'I' 
102e			;		ld (debug_mark),a 
102e			;		pop af 
102e			;		CALLMONITOR 
102e			;	endif 
102e			.is1:		; main entry loop 
102e			 
102e			 
102e			 
102e					; pause 1ms 
102e			 
102e 3e 01				ld a, 1 
1030 cd c4 0c				call aDelayInMS 
1033			 
1033					; dec flash counter 
1033 3a 5d fe				ld a, (input_cur_flash) 
1036 3d					dec a 
1037 32 5d fe				ld (input_cur_flash), a 
103a fe 00				cp 0 
103c 20 0d				jr nz, .nochgstate 
103e			 
103e			 
103e					; change state 
103e 3a 5c fe				ld a,(input_cur_onoff) 
1041 ed 44				neg 
1043 32 5c fe				ld (input_cur_onoff),a 
1046			 
1046			 
1046					; reset on change of state 
1046 3e 0f				ld a, CUR_BLINK_RATE 
1048 32 5d fe				ld (input_cur_flash), a 
104b			 
104b			.nochgstate: 
104b					 
104b					 
104b			 
104b					; display cursor  
104b			 
104b			;		ld hl, (input_start) 
104b			;		ld a, (input_cursor) 
104b			;		call addatohl 
104b			 
104b					; get char under cursor and replace with cursor 
104b 2a 66 fe		ld hl, (input_ptr) 
104e			;		ld a, (hl) 
104e			;		ld (input_under_cursor),a 
104e			;		ld a, '_' 
104e			;		ld (hl), a 
104e			 
104e					; display string 
104e			 
104e ed 5b 64 fe			ld de, (input_start) 
1052 3a 61 fe				ld a, (input_at_pos) 
1055 cd af 0d				call str_at_display 
1058			;	        call update_display 
1058			 
1058					; find place to put the cursor 
1058			;		add h 
1058			;		ld l, display_row_1 
1058			;		sub l 
1058			; (input_at_pos) 
1058					;ld c, a 
1058			;		ld a, (input_cursor) 
1058			;		ld l, (input_at_pos) 
1058			;		;ld b, h 
1058			;		add l 
1058			;		ld (input_at_cursor),a 
1058					;ld l,h 
1058			 
1058			;		ld h, 0 
1058			;		ld l,(input_at_pos) 
1058			;		ld a, (input_cursor) 
1058			;		call addatohl 
1058			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
1058			;		call subafromhl 
1058			;		ld a,l 
1058			;		ld (input_at_cursor), a 
1058			 
1058				if DEBUG_INPUT 
1058					ld a, (hardware_diag) 
1058					cp 0 
1058					jr z, .skip_input_diag 
1058			 
1058					ld a,(input_at_pos) 
1058					ld hl, LFSRSeed 
1058					call hexout 
1058					ld a, (input_cursor) 
1058					ld hl, LFSRSeed+2 
1058					call hexout 
1058					ld a,(input_at_cursor) 
1058					ld hl, LFSRSeed+4 
1058					call hexout 
1058			 
1058					ld a,(input_cur_onoff) 
1058					ld hl, LFSRSeed+6 
1058					call hexout 
1058			 
1058					ld a,(input_cur_flash) 
1058					ld hl, LFSRSeed+8 
1058					call hexout 
1058			 
1058					ld a,(input_len) 
1058					ld hl, LFSRSeed+10 
1058					call hexout 
1058					ld hl, LFSRSeed+12 
1058					ld a, 0 
1058					ld (hl),a 
1058					ld a, display_row_4 
1058					ld de, LFSRSeed 
1058					call str_at_display 
1058					.skip_input_diag: 
1058				endif 
1058			 
1058					; decide on if we are showing the cursor this time round 
1058			 
1058 3a 5c fe				ld a, (input_cur_onoff) 
105b fe ff				cp 255 
105d 28 13				jr z, .skipcur 
105f			 
105f			 
105f 3a 5f fe				ld a,(input_at_cursor) 
1062 11 be fb				ld de, cursor_shape 
1065 cd af 0d				call str_at_display 
1068			 
1068					; save length of current input string 
1068 2a 64 fe				ld hl, (input_start) 
106b cd 2e 14				call strlenz 
106e 7d					ld a,l 
106f 32 57 fe				ld (input_len),a 
1072			 
1072			.skipcur: 
1072			 
1072 cd bf 0d			        call update_display 
1075					 
1075			 
1075			 
1075					; wait 
1075				 
1075					; TODO loop without wait to flash the cursor and char under cursor	 
1075 cd d4 79				call cin    ; _wait 
1078			 
1078 fe 00				cp 0 
107a ca 2e 10				jp z, .is1 
107d			 
107d					; get ptr to char to input into 
107d			 
107d 4f					ld c,a 
107e 2a 64 fe				ld hl, (input_start) 
1081 3a 52 fe				ld a, (input_cursor) 
1084 cd d0 0f				call addatohl 
1087 22 66 fe				ld (input_ptr), hl 
108a 79					ld a,c 
108b			 
108b					; replace char under cursor 
108b			 
108b			;		ld hl, (input_ptr) 
108b			;		ld a, (input_under_cursor) 	; get what is under the cursor 
108b			;		ld (hl), a 
108b			 
108b			;	if DEBUG_INPUT 
108b			;		push af 
108b			;		ld a, 'i' 
108b			;		ld (debug_mark),a 
108b			;		pop af 
108b			;		CALLMONITOR 
108b			;	endif 
108b fe 0e				cp KEY_HOME 
108d 20 0e				jr nz, .iske 
108f			 
108f 3a 61 fe				ld a, (input_at_pos) 
1092 32 5f fe				ld (input_at_cursor),a 
1095 3e 00				ld a, 0 
1097 32 52 fe				ld (input_cursor), a 
109a c3 2e 10				jp .is1 
109d					 
109d fe 0f		.iske:		cp KEY_END 
109f 20 03				jr nz, .isknw 
10a1 c3 2e 10				jp .is1 
10a4			 
10a4 fe 06		.isknw:		cp KEY_NEXTWORD 
10a6 20 1b				jr nz, .iskpw 
10a8			 
10a8 2a 66 fe		.isknwm:	ld hl, (input_ptr) 
10ab 7e					ld a,(hl)	 
10ac fe 00				cp 0 
10ae ca 2e 10				jp z, .is1    ; end of string 
10b1 fe 20				cp ' ' 
10b3 ca 2e 10				jp z, .is1    ; end of word 
10b6 23					inc hl 
10b7 22 66 fe				ld (input_ptr), hl 
10ba 3a 5f fe				ld a, (input_at_cursor) 
10bd 3c					inc a 
10be 32 5f fe				ld (input_at_cursor), a 
10c1 18 e5				jr .isknwm 
10c3			 
10c3 fe 07		.iskpw:		cp KEY_PREVWORD 
10c5 20 1b				jr nz, .iskl 
10c7			.iskpwm:	 
10c7 2a 66 fe				ld hl, (input_ptr) 
10ca 7e					ld a,(hl)	 
10cb fe 00				cp 0  
10cd ca 2e 10				jp z, .is1    ; end of string 
10d0 fe 20				cp ' ' 
10d2 ca 2e 10				jp z, .is1    ; end of word 
10d5 2b					dec hl 
10d6 22 66 fe				ld (input_ptr), hl 
10d9 3a 5f fe				ld a, (input_at_cursor) 
10dc 3d					dec a 
10dd 32 5f fe				ld (input_at_cursor), a 
10e0 18 e5				jr .iskpwm 
10e2			 
10e2			 
10e2 fe 0b		.iskl:		cp KEY_LEFT 
10e4 20 27				jr nz, .isk1 
10e6			 
10e6 3a 52 fe				ld a, (input_cursor) 
10e9			 
10e9 fe 00				cp 0 
10eb ca 2e 10				jp z, .is1 		; at start of line to ignore  
10ee			 
10ee 3d					dec  a 		; TODO check underflow 
10ef 32 52 fe				ld (input_cursor), a 
10f2			 
10f2 2a 66 fe				ld hl, (input_ptr) 
10f5 2b					dec hl 
10f6 22 66 fe				ld (input_ptr), hl 
10f9					 
10f9 3a 5f fe				ld a, (input_at_cursor) 
10fc 3d					dec a 
10fd 32 5f fe				ld (input_at_cursor), a 
1100			 
1100 3e 01				ld a, 1		; show cursor moving 
1102 32 5c fe				ld (input_cur_onoff),a 
1105 3e 0f				ld a, CUR_BLINK_RATE 
1107 32 5d fe				ld (input_cur_flash), a 
110a			 
110a c3 2e 10				jp .is1 
110d			 
110d fe 0c		.isk1:		cp KEY_RIGHT 
110f 20 2a				jr nz, .isk2 
1111			 
1111 3a 57 fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1114 5f					ld e,a 
1115 3a 52 fe				ld a, (input_cursor) 
1118 bb					cp e 
1119 ca 2e 10				jp z, .is1		; at the end of string so dont go right 
111c			 
111c 3c					inc  a 		; TODO check overflow 
111d 32 52 fe				ld (input_cursor), a 
1120			 
1120 3a 5f fe				ld a, (input_at_cursor) 
1123 3c					inc a 
1124 32 5f fe				ld (input_at_cursor), a 
1127			 
1127 2a 66 fe				ld hl, (input_ptr) 
112a 23					inc hl 
112b 22 66 fe				ld (input_ptr), hl 
112e			 
112e 3e 01				ld a, 1		; show cursor moving 
1130 32 5c fe				ld (input_cur_onoff),a 
1133 3e 0f				ld a, CUR_BLINK_RATE 
1135 32 5d fe				ld (input_cur_flash), a 
1138			 
1138 c3 2e 10				jp .is1 
113b			 
113b fe 05		.isk2:		cp KEY_UP 
113d			 
113d 20 26				jr nz, .isk3 
113f			 
113f					; swap last command with the current on 
113f			 
113f					; move cursor to start of string 
113f 2a 64 fe				ld hl, (input_start) 
1142 22 66 fe				ld (input_ptr), hl 
1145			 
1145 3a 61 fe				ld a, (input_at_pos) 
1148 32 5f fe				ld (input_at_cursor), a 
114b			 
114b 3e 00				ld a, 0 
114d 32 52 fe				ld (input_cursor), a 
1150					 
1150					; swap input and last command buffers 
1150			 
1150 21 e5 f4				ld hl, os_cli_cmd 
1153 11 e4 f5				ld de, os_last_cmd 
1156 06 ff				ld b, 255 
1158 7e			.swap1:		ld a, (hl) 
1159 4f					ld c,a 
115a 1a					ld a, (de) 
115b 77					ld (hl), a 
115c 79					ld a,c 
115d 12					ld (de),a 
115e 23					inc hl 
115f 13					inc de 
1160 10 f6				djnz .swap1 
1162			 
1162			 
1162			 
1162			 
1162			 
1162 c3 2e 10				jp .is1 
1165			 
1165 fe 08		.isk3:		cp KEY_BS 
1167 20 3c				jr nz, .isk4 
1169			 
1169 3a 52 fe				ld a, (input_cursor) 
116c			 
116c fe 00				cp 0 
116e ca 2e 10				jp z, .is1 		; at start of line to ignore  
1171			 
1171 3d					dec  a 		; TODO check underflow 
1172 32 52 fe				ld (input_cursor), a 
1175			 
1175					; hl is source 
1175					; de needs to be source - 1 
1175			 
1175			;		ld a, 0 
1175			;		dec hl 
1175			;		ld (hl), a 
1175			 
1175 2a 66 fe				ld hl, (input_ptr) 
1178 2b					dec hl 
1179 22 66 fe				ld (input_ptr), hl 
117c			 
117c					; shift all data 
117c			 
117c e5					push hl 
117d 23					inc hl 
117e d1					pop de 
117f 3a 57 fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
1182 4f					ld c,a 
1183 06 00				ld b,0 
1185 ed b0				ldir  
1187			 
1187			 
1187			 
1187			 
1187 3a 5f fe				ld a, (input_at_cursor) 
118a 3d					dec a 
118b 32 5f fe				ld (input_at_cursor), a 
118e			 
118e			 
118e 3e 01				ld a, 1		; show cursor moving 
1190 32 5c fe				ld (input_cur_onoff),a 
1193 3e 0f				ld a, CUR_BLINK_RATE 
1195 32 5d fe				ld (input_cur_flash), a 
1198			 
1198					; remove char 
1198 3a 5f fe				ld a, (input_at_cursor) 
119b 3c					inc a 
119c 11 26 12				ld de,.iblank 
119f cd af 0d				call str_at_display 
11a2			 
11a2 c3 2e 10				jp .is1 
11a5			 
11a5 fe 0d		.isk4:		cp KEY_CR 
11a7 28 6c				jr z, .endinput 
11a9			 
11a9					; else add the key press to the end 
11a9			 
11a9 4f					ld c, a			; save key pressed 
11aa			 
11aa 7e					ld a,(hl)		; get what is currently under char 
11ab			 
11ab fe 00				cp 0			; we are at the end of the string 
11ad 20 2f				jr nz, .onchar 
11af					 
11af					; add a char to the end of the string 
11af				 
11af 71					ld (hl),c 
11b0 23					inc hl 
11b1			;		ld a,' ' 
11b1			;		ld (hl),a 
11b1			;		inc hl 
11b1 3e 00				ld a,0 
11b3 77					ld (hl),a 
11b4 2b					dec hl 
11b5			 
11b5 3a 52 fe				ld a, (input_cursor) 
11b8 3c					inc a				; TODO check max string length and scroll  
11b9 32 52 fe				ld (input_cursor), a		; inc cursor pos 
11bc							 
11bc 3a 5f fe				ld a, (input_at_cursor) 
11bf 3c					inc a 
11c0 32 5f fe				ld (input_at_cursor), a 
11c3			 
11c3 2a 66 fe				ld hl, (input_ptr) 
11c6 23					inc hl 
11c7 22 66 fe				ld (input_ptr), hl 
11ca			 
11ca 2a 66 fe				ld hl, (input_ptr) 
11cd 23					inc hl 
11ce 22 66 fe				ld (input_ptr), hl 
11d1			;	if DEBUG_INPUT 
11d1			;		push af 
11d1			;		ld a, '+' 
11d1			;		ld (debug_mark),a 
11d1			;		pop af 
11d1			;		CALLMONITOR 
11d1			;	endif 
11d1 3e 01				ld a, 1		; show cursor moving 
11d3 32 5c fe				ld (input_cur_onoff),a 
11d6 3e 0f				ld a, CUR_BLINK_RATE 
11d8 32 5d fe				ld (input_cur_flash), a 
11db c3 2e 10				jp .is1 
11de					 
11de			 
11de			 
11de					; if on a char then insert 
11de			.onchar: 
11de			 
11de					; TODO over flow check: make sure insert does not blow out buffer 
11de			 
11de					; need to do some maths to use lddr 
11de			 
11de e5					push hl   ; save char pos 
11df c5					push bc 
11e0			 
11e0 2a 64 fe				ld hl, (input_start) 
11e3 3a 57 fe				ld a, (input_len) 
11e6 cd d0 0f				call addatohl  		; end of string 
11e9 23					inc hl 
11ea 23					inc hl		; past zero term 
11eb e5					push hl 
11ec 23					inc hl 
11ed e5					push hl  
11ee			 
11ee								; start and end of lddr set, now how much to move? 
11ee			 
11ee							 
11ee 3a 52 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11f1 47					ld b,a 
11f2 3a 57 fe				ld a,(input_len) 
11f5 5f					ld e,a 
11f6 90					sub b 
11f7 3c					inc a		;?? 
11f8 3c					inc a		;?? 
11f9 3c					inc a		;?? 
11fa			 
11fa 06 00				ld b,0 
11fc 4f					ld c,a 
11fd			 
11fd				if DEBUG_INPUT 
11fd					push af 
11fd					ld a, 'i' 
11fd					ld (debug_mark),a 
11fd					pop af 
11fd			;		CALLMONITOR 
11fd				endif 
11fd d1					pop de 
11fe e1					pop hl 
11ff				if DEBUG_INPUT 
11ff					push af 
11ff					ld a, 'I' 
11ff					ld (debug_mark),a 
11ff					pop af 
11ff			;		CALLMONITOR 
11ff				endif 
11ff ed b8				lddr 
1201				 
1201			 
1201			 
1201					; TODO have a key for insert/overwrite mode???? 
1201 c1					pop bc 
1202 e1					pop hl 
1203 71					ld (hl), c		; otherwise overwrite current char 
1204					 
1204			 
1204			 
1204			 
1204 3a 52 fe				ld a, (input_cursor) 
1207 3c					inc  a 		; TODO check overflow 
1208 32 52 fe				ld (input_cursor), a 
120b			 
120b 3a 5f fe				ld a, (input_at_cursor) 
120e 3c					inc a 
120f 32 5f fe				ld (input_at_cursor), a 
1212			 
1212 c3 2e 10				jp .is1 
1215			 
1215			.endinput:	; TODO look for end of string 
1215			 
1215					; add trailing space for end of token 
1215			 
1215 2a 64 fe				ld hl, (input_start) 
1218 3a 57 fe				ld a,(input_len) 
121b cd d0 0f				call addatohl 
121e 3e 20				ld a, ' ' 
1220 77					ld (hl),a 
1221					; TODO eof of parse marker 
1221			 
1221 23					inc hl 
1222 3e 00				ld a, 0 
1224 77					ld (hl),a 
1225			 
1225			 
1225 c9					ret 
1226			 
1226 .. 00		.iblank: db " ",0 
1228			 
1228			 
1228 32 61 fe		input_str_prev:	ld (input_at_pos), a 
122b 22 64 fe				ld (input_start), hl 
122e 3e 01				ld a,1			; add cursor 
1230 77					ld (hl),a 
1231 23					inc hl 
1232 3e 00				ld a,0 
1234 77					ld (hl),a 
1235 22 66 fe				ld (input_ptr), hl 
1238 7a					ld a,d 
1239 32 63 fe				ld (input_size), a 
123c 3e 00				ld a,0 
123e 32 52 fe				ld (input_cursor),a 
1241			.instr1:	 
1241			 
1241					; TODO do block cursor 
1241					; TODO switch cursor depending on the modifer key 
1241			 
1241					; update cursor shape change on key hold 
1241			 
1241 2a 66 fe				ld hl, (input_ptr) 
1244 2b					dec hl 
1245 3a be fb				ld a,(cursor_shape) 
1248 77					ld (hl), a 
1249			 
1249					; display entered text 
1249 3a 61 fe				ld a,(input_at_pos) 
124c cd 98 77		            	CALL fLCD_Pos       ;Position cursor to location in A 
124f ed 5b 64 fe	            	LD   de, (input_start) 
1253 cd ba 77		            	CALL fLCD_Str       ;Display string pointed to by DE 
1256			 
1256 cd d4 79				call cin 
1259 fe 00				cp 0 
125b 28 e4				jr z, .instr1 
125d			 
125d					; proecess keyboard controls first 
125d			 
125d 2a 66 fe				ld hl,(input_ptr) 
1260			 
1260 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1262 28 5a				jr z, .instrcr 
1264			 
1264 fe 08				cp KEY_BS 	; back space 
1266 20 0f				jr nz, .instr2 
1268					; process back space 
1268			 
1268					; TODO stop back space if at start of string 
1268 2b					dec hl 
1269 2b					dec hl ; to over write cursor 
126a 3a be fb				ld a,(cursor_shape) 
126d					;ld a,0 
126d 77					ld (hl),a 
126e 23					inc hl 
126f 3e 20				ld a," " 
1271 77					ld (hl),a 
1272 22 66 fe				ld (input_ptr),hl 
1275					 
1275			 
1275 18 ca				jr .instr1 
1277			 
1277 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1279 20 06				jr nz, .instr3 
127b 2b					dec hl 
127c 22 66 fe				ld (input_ptr),hl 
127f 18 c0				jr .instr1 
1281				 
1281 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
1283 20 06				jr nz, .instr4 
1285 23					inc hl 
1286 22 66 fe				ld (input_ptr),hl 
1289 18 b6				jr .instr1 
128b			 
128b fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
128d 20 06				jr nz, .instr5 
128f 2b					dec hl 
1290 22 66 fe				ld (input_ptr),hl 
1293 18 ac				jr .instr1 
1295			 
1295 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1297 20 06				jr nz, .instr6 
1299 2b					dec hl 
129a 22 66 fe				ld (input_ptr),hl 
129d 18 a2				jr .instr1 
129f fe 05		.instr6:        cp KEY_UP      ; recall last command 
12a1 20 0b				jr nz, .instrnew 
12a3			 
12a3 21 be f1			ld hl, scratch 
12a6 11 e4 f5			ld de, os_last_cmd 
12a9 cd c7 12			call strcpy 
12ac 18 93				jr .instr1 
12ae			 
12ae			 
12ae			.instrnew:	; no special key pressed to see if we have room to store it 
12ae			 
12ae					; TODO do string size test 
12ae			 
12ae 2b					dec hl ; to over write cursor 
12af 77					ld (hl),a 
12b0 23					inc hl 
12b1 3a be fb				ld a,(cursor_shape) 
12b4 77					ld (hl),a 
12b5 23					inc hl 
12b6 3e 00				ld a,0 
12b8 77					ld (hl),a 
12b9			 
12b9 22 66 fe				ld (input_ptr),hl 
12bc					 
12bc 18 83				jr .instr1 
12be 2b			.instrcr:	dec hl		; remove cursor 
12bf 3e 20				ld a,' '	; TODO add a trailing space for safety 
12c1 77					ld (hl),a 
12c2 23					inc hl 
12c3 3e 00				ld a,0 
12c5 77					ld (hl),a 
12c6			 
12c6			 
12c6					; if at end of line scroll up    
12c6					; TODO detecting only end of line 4 for scroll up  
12c6			 
12c6					;ld   
12c6			 
12c6 c9					ret 
12c7			 
12c7			 
12c7			; strcpy hl = dest, de source 
12c7			 
12c7 1a			strcpy:   LD   A, (DE)        ;Get character from string 
12c8 b7			            OR   A              ;Null terminator? 
12c9 c8			            RET  Z              ;Yes, so finished 
12ca 1a					ld a,(de) 
12cb 77					ld (hl),a 
12cc 13			            INC  DE             ;Point to next character 
12cd 23					inc hl 
12ce 18 f7		            JR   strcpy       ;Repeat 
12d0 c9					ret 
12d1			 
12d1			 
12d1			; TODO string_at  
12d1			; pass string which starts with lcd offset address and then null term string 
12d1			 
12d1			; TODO string to dec 
12d1			; TODO string to hex 
12d1			; TODO byte to string hex 
12d1			; TODO byte to string dec 
12d1			 
12d1			 
12d1			 
12d1			; from z80uartmonitor 
12d1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12d1			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
12d1			; pass hl for where to put the text 
12d1			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12d1 c5			hexout:	PUSH BC 
12d2 f5					PUSH AF 
12d3 47					LD B, A 
12d4					; Upper nybble 
12d4 cb 3f				SRL A 
12d6 cb 3f				SRL A 
12d8 cb 3f				SRL A 
12da cb 3f				SRL A 
12dc cd ec 12				CALL tohex 
12df 77					ld (hl),a 
12e0 23					inc hl	 
12e1					 
12e1					; Lower nybble 
12e1 78					LD A, B 
12e2 e6 0f				AND 0FH 
12e4 cd ec 12				CALL tohex 
12e7 77					ld (hl),a 
12e8 23					inc hl	 
12e9					 
12e9 f1					POP AF 
12ea c1					POP BC 
12eb c9					RET 
12ec					 
12ec			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12ec			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
12ec			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12ec			tohex: 
12ec e5					PUSH HL 
12ed d5					PUSH DE 
12ee 16 00				LD D, 0 
12f0 5f					LD E, A 
12f1 21 f9 12				LD HL, .DATA 
12f4 19					ADD HL, DE 
12f5 7e					LD A, (HL) 
12f6 d1					POP DE 
12f7 e1					POP HL 
12f8 c9					RET 
12f9			 
12f9			.DATA: 
12f9 30					DEFB	30h	; 0 
12fa 31					DEFB	31h	; 1 
12fb 32					DEFB	32h	; 2 
12fc 33					DEFB	33h	; 3 
12fd 34					DEFB	34h	; 4 
12fe 35					DEFB	35h	; 5 
12ff 36					DEFB	36h	; 6 
1300 37					DEFB	37h	; 7 
1301 38					DEFB	38h	; 8 
1302 39					DEFB	39h	; 9 
1303 41					DEFB	41h	; A 
1304 42					DEFB	42h	; B 
1305 43					DEFB	43h	; C 
1306 44					DEFB	44h	; D 
1307 45					DEFB	45h	; E 
1308 46					DEFB	46h	; F 
1309			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1309			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1309			;;    subtract $30, if result > 9 then subtract $7 more 
1309			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1309			atohex: 
1309 d6 30				SUB $30 
130b fe 0a				CP 10 
130d f8					RET M		; If result negative it was 0-9 so we're done 
130e d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1310 c9					RET		 
1311			 
1311			 
1311			 
1311			 
1311			; Get 2 ASCII characters as hex byte from pointer in hl 
1311			 
1311			BYTERD: 
1311 16 00			LD	D,00h		;Set up 
1313 cd 1b 13			CALL	HEXCON		;Get byte and convert to hex 
1316 87				ADD	A,A		;First nibble so 
1317 87				ADD	A,A		;multiply by 16 
1318 87				ADD	A,A		; 
1319 87				ADD	A,A		; 
131a 57				LD	D,A		;Save hi nibble in D 
131b			HEXCON: 
131b 7e				ld a, (hl)		;Get next chr 
131c 23				inc hl 
131d d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
131f fe 0a			CP	00Ah		;Is it 0-9 ? 
1321 38 02			JR	C,NALPHA	;If so miss next bit 
1323 d6 07			SUB	007h		;Else convert alpha 
1325			NALPHA: 
1325 b2				OR	D		;Add hi nibble back 
1326 c9				RET			; 
1327			 
1327			 
1327			; 
1327			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1327			; Since the routines get_byte and therefore get_nibble are called, only valid 
1327			; characters (0-9a-f) are accepted. 
1327			; 
1327			;get_word        push    af 
1327			;                call    get_byte        ; Get the upper byte 
1327			;                ld      h, a 
1327			;                call    get_byte        ; Get the lower byte 
1327			;                ld      l, a 
1327			;                pop     af 
1327			;                ret 
1327			; 
1327			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1327			; the routine get_nibble is used only valid characters are accepted - the  
1327			; input routine only accepts characters 0-9a-f. 
1327			; 
1327 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1328 7e					ld a,(hl) 
1329 23					inc hl 
132a cd 4f 13		                call    nibble2val      ; Get upper nibble 
132d cb 07		                rlc     a 
132f cb 07		                rlc     a 
1331 cb 07		                rlc     a 
1333 cb 07		                rlc     a 
1335 47			                ld      b, a            ; Save upper four bits 
1336 7e					ld a,(hl) 
1337 cd 4f 13		                call    nibble2val      ; Get lower nibble 
133a b0			                or      b               ; Combine both nibbles 
133b c1			                pop     bc              ; Restore B (and C) 
133c c9			                ret 
133d			; 
133d			; Get a hexadecimal digit from the serial line. This routine blocks until 
133d			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
133d			; to the serial line interface. The lower 4 bits of A contain the value of  
133d			; that particular digit. 
133d			; 
133d			;get_nibble      ld a,(hl)           ; Read a character 
133d			;                call    to_upper        ; Convert to upper case 
133d			;                call    is_hex          ; Was it a hex digit? 
133d			;                jr      nc, get_nibble  ; No, get another character 
133d			 ;               call    nibble2val      ; Convert nibble to value 
133d			 ;               call    print_nibble 
133d			 ;               ret 
133d			; 
133d			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
133d			; A valid hexadecimal digit is denoted by a set C flag. 
133d			; 
133d			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
133d			;                ret     nc              ; Yes 
133d			;                cp      '0'             ; Less than '0'? 
133d			;                jr      nc, is_hex_1    ; No, continue 
133d			;                ccf                     ; Complement carry (i.e. clear it) 
133d			;                ret 
133d			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
133d			;                ret     c               ; Yes 
133d			;                cp      'A'             ; Less than 'A'? 
133d			;                jr      nc, is_hex_2    ; No, continue 
133d			;                ccf                     ; Yes - clear carry and return 
133d			;                ret 
133d			;is_hex_2        scf                     ; Set carry 
133d			;                ret 
133d			; 
133d			; Convert a single character contained in A to upper case: 
133d			; 
133d fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
133f d8			                ret     c 
1340 fe 7b		                cp      'z' + 1         ; > 'z'? 
1342 d0			                ret     nc              ; Nothing to do, either 
1343 e6 5f		                and     $5f             ; Convert to upper case 
1345 c9			                ret 
1346			 
1346			 
1346			to_lower: 
1346			 
1346			   ; if char is in [A-Z] make it lower case 
1346			 
1346			   ; enter : a = char 
1346			   ; exit  : a = lower case char 
1346			   ; uses  : af 
1346			 
1346 fe 41		   cp 'A' 
1348 d8			   ret c 
1349			    
1349 fe 5b		   cp 'Z'+1 
134b d0			   ret nc 
134c			    
134c f6 20		   or $20 
134e c9			   ret 
134f			 
134f			; 
134f			; Expects a hexadecimal digit (upper case!) in A and returns the 
134f			; corresponding value in A. 
134f			; 
134f fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1351 38 02		                jr      c, nibble2val_1 ; Yes 
1353 d6 07		                sub     7               ; Adjust for A-F 
1355 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1357 e6 0f		                and     $f              ; Only return lower 4 bits 
1359 c9			                ret 
135a			; 
135a			; Print_nibble prints a single hex nibble which is contained in the lower  
135a			; four bits of A: 
135a			; 
135a			;print_nibble    push    af              ; We won't destroy the contents of A 
135a			;                and     $f              ; Just in case... 
135a			;                add     a, '0'             ; If we have a digit we are done here. 
135a			;                cp      '9' + 1         ; Is the result > 9? 
135a			;                jr      c, print_nibble_1 
135a			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
135a			;print_nibble_1  call    putc            ; Print the nibble and 
135a			;                pop     af              ; restore the original value of A 
135a			;                ret 
135a			;; 
135a			;; Send a CR/LF pair: 
135a			; 
135a			;crlf            push    af 
135a			;                ld      a, cr 
135a			;                call    putc 
135a			;                ld      a, lf 
135a			;                call    putc 
135a			;                pop     af 
135a			;                ret 
135a			; 
135a			; Print_word prints the four hex digits of a word to the serial line. The  
135a			; word is expected to be in HL. 
135a			; 
135a			;print_word      push    hl 
135a			;                push    af 
135a			;                ld      a, h 
135a			;                call    print_byte 
135a			;                ld      a, l 
135a			;                call    print_byte 
135a			;                pop     af 
135a			;                pop     hl 
135a			;                ret 
135a			; 
135a			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
135a			; The byte to be printed is expected to be in A. 
135a			; 
135a			;print_byte      push    af              ; Save the contents of the registers 
135a			;                push    bc 
135a			;                ld      b, a 
135a			;                rrca 
135a			;                rrca 
135a			;                rrca 
135a			;                rrca 
135a			;                call    print_nibble    ; Print high nibble 
135a			;                ld      a, b 
135a			;                call    print_nibble    ; Print low nibble 
135a			;                pop     bc              ; Restore original register contents 
135a			;                pop     af 
135a			;                ret 
135a			 
135a			 
135a			 
135a			 
135a			 
135a			fourehexhl:  
135a 7e				ld a,(hl) 
135b cd 09 13			call atohex 
135e cb 3f				SRL A 
1360 cb 3f				SRL A 
1362 cb 3f				SRL A 
1364 cb 3f				SRL A 
1366 47				ld b, a 
1367 23				inc hl 
1368 7e				ld a,(hl) 
1369 23				inc hl 
136a cd 09 13			call atohex 
136d 80				add b 
136e 57				ld d,a 
136f 7e				ld a,(hl) 
1370 cd 09 13			call atohex 
1373 cb 3f				SRL A 
1375 cb 3f				SRL A 
1377 cb 3f				SRL A 
1379 cb 3f				SRL A 
137b 47				ld b, a 
137c 23				inc hl 
137d 7e				ld a,(hl) 
137e 23				inc hl 
137f cd 09 13			call atohex 
1382 80				add b 
1383 5f				ld e, a 
1384 d5				push de 
1385 e1				pop hl 
1386 c9				ret 
1387			 
1387			; pass hl. returns z set if the byte at hl is a digit 
1387			;isdigithl:  
1387			;	push bc 
1387			;	ld a,(hl) 
1387			;	cp ':' 
1387			;	jr nc, .isdf 		; > 
1387			;	cp '0' 
1387			;	jr c, .isdf		; < 
1387			; 
1387			;	; TODO find a better way to set z 
1387			; 
1387			;	ld b,a 
1387			;	cp b 
1387			;	pop bc 
1387			;	ret 
1387			; 
1387			;.isdf:	; not digit so clear z 
1387			; 
1387			;	; TODO find a better way to unset z 
1387			; 
1387			;	ld b,a 
1387			;	inc b 
1387			;	cp b 
1387			; 
1387			;	pop bc 
1387			;	ret 
1387				 
1387				 
1387			 
1387			 
1387			; pass hl as the four byte address to load 
1387			 
1387			get_word_hl:  
1387 e5				push hl 
1388 cd 27 13			call get_byte 
138b				 
138b 47				ld b, a 
138c			 
138c e1				pop hl 
138d 23				inc hl 
138e 23				inc hl 
138f			 
138f			; TODO not able to handle a-f  
138f 7e				ld a,(hl) 
1390			;	;cp ':' 
1390			;	cp 'g' 
1390			;	jr nc, .single_byte_hl 		; > 
1390			;	cp 'G' 
1390			;	jr nc, .single_byte_hl 		; > 
1390			;	cp '0' 
1390			;	jr c, .single_byte_hl		; < 
1390			 
1390				;call isdigithl 
1390 fe 00			cp 0 
1392 28 06			jr z, .single_byte_hl 
1394			 
1394			.getwhln:   ; hex word so get next byte 
1394			 
1394 cd 27 13			call get_byte 
1397 6f				ld l, a 
1398 60				ld h,b 
1399 c9				ret 
139a 68			.single_byte_hl:   ld l,b 
139b 26 00				ld h,0 
139d c9					ret 
139e			 
139e			 
139e			 
139e			 
139e 21 f4 1d			ld hl,asc+1 
13a1			;	ld a, (hl) 
13a1			;	call nibble2val 
13a1 cd 27 13			call get_byte 
13a4			 
13a4			;	call fourehexhl 
13a4 32 f2 f1			ld (scratch+52),a 
13a7				 
13a7 21 f0 f1			ld hl,scratch+50 
13aa 22 e1 f4			ld (os_cur_ptr),hl 
13ad			 
13ad c9				ret 
13ae			 
13ae			 
13ae			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
13ae			 
13ae			; Decimal Unsigned Version 
13ae			 
13ae			;Number in a to decimal ASCII 
13ae			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
13ae			;Example: display a=56 as "056" 
13ae			;input: a = number 
13ae			;Output: a=0,value of a in the screen 
13ae			;destroys af,bc (don't know about hl and de) 
13ae			DispAToASCII: 
13ae 0e 9c			ld	c,-100 
13b0 cd ba 13			call	.Na1 
13b3 0e f6			ld	c,-10 
13b5 cd ba 13			call	.Na1 
13b8 0e ff			ld	c,-1 
13ba 06 2f		.Na1:	ld	b,'0'-1 
13bc 04			.Na2:	inc	b 
13bd 81				add	a,c 
13be 38 fc			jr	c,.Na2 
13c0 91				sub	c		;works as add 100/10/1 
13c1 f5				push af		;safer than ld c,a 
13c2 78				ld	a,b		;char is in b 
13c3			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
13c3 f1				pop af		;safer than ld a,c 
13c4 c9				ret 
13c5			 
13c5			; Decimal Signed Version 
13c5			 
13c5			; DispA 
13c5			; -------------------------------------------------------------- 
13c5			; Converts a signed integer value to a zero-terminated ASCII 
13c5			; string representative of that value (using radix 10). 
13c5			; -------------------------------------------------------------- 
13c5			; INPUTS: 
13c5			;     HL     Value to convert (two's complement integer). 
13c5			;     DE     Base address of string destination. (pointer). 
13c5			; -------------------------------------------------------------- 
13c5			; OUTPUTS: 
13c5			;     None 
13c5			; -------------------------------------------------------------- 
13c5			; REGISTERS/MEMORY DESTROYED 
13c5			; AF HL 
13c5			; -------------------------------------------------------------- 
13c5			 
13c5			;DispHLToASCII: 
13c5			;   push    de 
13c5			;   push    bc 
13c5			; 
13c5			;; Detect sign of HL. 
13c5			;    bit    7, h 
13c5			;    jr     z, ._DoConvert 
13c5			; 
13c5			;; HL is negative. Output '-' to string and negate HL. 
13c5			;    ld     a, '-' 
13c5			;    ld     (de), a 
13c5			;    inc    de 
13c5			; 
13c5			;; Negate HL (using two's complement) 
13c5			;    xor    a 
13c5			;    sub    l 
13c5			;    ld     l, a 
13c5			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
13c5			;    sbc    a, h 
13c5			;    ld     h, a 
13c5			; 
13c5			;; Convert HL to digit characters 
13c5			;._DoConvert: 
13c5			;    ld     b, 0     ; B will count character length of number 
13c5			;-   ld     a, 10 
13c5			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
13c5			;    push   af 
13c5			;    inc    b 
13c5			;    ld     a, h 
13c5			;    or     l 
13c5			;    jr     nz, - 
13c5			; 
13c5			;; Retrieve digits from stack 
13c5			;-   pop    af 
13c5			;    or     $30 
13c5			;    ld     (de), a 
13c5			;    inc    de 
13c5			;    djnz   - 
13c5			; 
13c5			;; Terminate string with NULL 
13c5			;    xor    a 
13c5			;    ld     (de), a 
13c5			; 
13c5			;    pop    bc 
13c5			;    pop    de 
13c5			;    ret 
13c5			 
13c5			;Comments 
13c5			; 
13c5			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
13c5			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
13c5			;    Note that the output string will not be fixed-width. 
13c5			; 
13c5			;Example Usage 
13c5			; 
13c5			;    ld    hl, -1004 
13c5			;    ld    de, OP1 
13c5			;    call  DispA 
13c5			;    ld    hl, OP1 
13c5			;    syscall  PutS 
13c5			 
13c5			 
13c5			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
13c5			 
13c5			 
13c5			;Converts an ASCII string to an unsigned 16-bit integer 
13c5			;Quits when it reaches a non-decimal digit 
13c5			 
13c5			string_to_uint16: 
13c5			atoui_16: 
13c5			;Input: 
13c5			;     DE points to the string 
13c5			;Outputs: 
13c5			;     HL is the result 
13c5			;     A is the 8-bit value of the number 
13c5			;     DE points to the byte after the number 
13c5			;Destroys: 
13c5			;     BC 
13c5			;       if the string is non-empty, BC is HL/10 
13c5			;Size:  24 bytes 
13c5			;Speed: 42+d(104+{0,9}) 
13c5			;       d is the number of digits in the number 
13c5			;       max is 640 cycles for a 5 digit number 
13c5			;Assuming no leading zeros: 
13c5			;1 digit:  146cc 
13c5			;2 digit:  250cc 
13c5			;3 digit:  354cc or 363cc (avg: 354.126cc) 
13c5			;4 digit:  458cc or 467cc (avg: 458.27cc) 
13c5			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
13c5			;avg: 544.81158447265625cc (544+13297/16384) 
13c5			;=============================================================== 
13c5 21 00 00		  ld hl,0 
13c8			.u16a: 
13c8 1a			  ld a,(de) 
13c9 d6 30		  sub 30h 
13cb fe 0a		  cp 10 
13cd d0			  ret nc 
13ce 13			  inc de 
13cf 44			  ld b,h 
13d0 4d			  ld c,l 
13d1 29			  add hl,hl 
13d2 29			  add hl,hl 
13d3 09			  add hl,bc 
13d4 29			  add hl,hl 
13d5 85			  add a,l 
13d6 6f			  ld l,a 
13d7 30 ef		  jr nc,.u16a 
13d9 24			  inc h 
13da c3 c8 13		  jp .u16a 
13dd			 
13dd			 
13dd			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
13dd			 
13dd			;written by Zeda 
13dd			;Converts a 16-bit unsigned integer to an ASCII string. 
13dd			 
13dd			uitoa_16: 
13dd			;Input: 
13dd			;   DE is the number to convert 
13dd			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
13dd			;Output: 
13dd			;   HL points to the null-terminated ASCII string 
13dd			;      NOTE: This isn't necessarily the same as the input HL. 
13dd d5			  push de 
13de c5			  push bc 
13df f5			  push af 
13e0 eb			  ex de,hl 
13e1			 
13e1 01 f0 d8		  ld bc,-10000 
13e4 3e 2f		  ld a,'0'-1 
13e6 3c			  inc a 
13e7 09			  add hl,bc  
13e8 38 fc		   jr c,$-2 
13ea 12			  ld (de),a 
13eb 13			  inc de 
13ec			 
13ec 01 e8 03		  ld bc,1000 
13ef 3e 3a		  ld a,'9'+1 
13f1 3d			  dec a  
13f2 09			  add hl,bc  
13f3 30 fc		   jr nc,$-2 
13f5 12			  ld (de),a 
13f6 13			  inc de 
13f7			 
13f7 01 9c ff		  ld bc,-100 
13fa 3e 2f		  ld a,'0'-1 
13fc 3c			  inc a  
13fd 09			  add hl,bc  
13fe 38 fc		   jr c,$-2 
1400 12			  ld (de),a 
1401 13			  inc de 
1402			 
1402 7d			  ld a,l 
1403 26 3a		  ld h,'9'+1 
1405 25			  dec h  
1406 c6 0a		  add a,10  
1408 30 fb		   jr nc,$-3 
140a c6 30		  add a,'0' 
140c eb			  ex de,hl 
140d 72			  ld (hl),d 
140e 23			  inc hl 
140f 77			  ld (hl),a 
1410 23			  inc hl 
1411 36 00		  ld (hl),0 
1413			 
1413			;Now strip the leading zeros 
1413 0e fa		  ld c,-6 
1415 09			  add hl,bc 
1416 3e 30		  ld a,'0' 
1418 23			  inc hl  
1419 be			  cp (hl)  
141a 28 fc		  jr z,$-2 
141c			 
141c			;Make sure that the string is non-empty! 
141c 7e			  ld a,(hl) 
141d b7			  or a 
141e 20 01		  jr nz,.atoub 
1420 2b			  dec hl 
1421			.atoub: 
1421			 
1421 f1			  pop af 
1422 c1			  pop bc 
1423 d1			  pop de 
1424 c9			  ret 
1425			 
1425			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1425			 
1425			toUpper: 
1425			;A is the char. 
1425			;If A is a lowercase letter, this sets it to the matching uppercase 
1425			;18cc or 30cc or 41cc 
1425			;avg: 26.75cc 
1425 fe 61		  cp 'a' 
1427 d8			  ret c 
1428 fe 7b		  cp 'z'+1 
142a d0			  ret nc 
142b d6 20		  sub 'a'-'A' 
142d c9			  ret 
142e			 
142e			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
142e			 
142e			; String Length 
142e			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
142e			 
142e			; Get the length of the null-terminated string starting at $8000 hl 
142e			;    LD     HL, $8000 
142e			 
142e			strlenz: 
142e			 
142e af			    XOR    A               ; Zero is the value we are looking for. 
142f 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1430 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1431			                           ; 65, 536 bytes (the entire addressable memory space). 
1431 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1433			 
1433			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1433 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1434 6f			    LD     L, A             ; number of bytes 
1435 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1437 2b			    DEC    HL              ; Compensate for null. 
1438 c9				ret 
1439			 
1439			; Get the length of the A terminated string starting at $8000 hl 
1439			;    LD     HL, $8000 
1439			 
1439			strlent: 
1439			 
1439			                  ; A is the value we are looking for. 
1439 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
143b 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
143d			                           ; 65, 536 bytes (the entire addressable memory space). 
143d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
143f			 
143f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
143f 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1441 2e 00		    LD     L, 0             ; number of bytes 
1443 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1445 2b			    DEC    HL              ; Compensate for null. 
1446 c9				ret 
1447			 
1447			 
1447			;Comparing Strings 
1447			 
1447			;IN    HL     Address of string1. 
1447			;      DE     Address of string2. 
1447			 
1447			; doc given but wrong??? 
1447			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1447			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1447			; tested 
1447			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1447			 
1447			strcmp_old: 
1447 e5			    PUSH   HL 
1448 d5			    PUSH   DE 
1449			 
1449 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
144a be			    CP     (HL)            ; (want to minimize work). 
144b 38 01		    JR     C, Str1IsBigger 
144d 7e			    LD     A, (HL) 
144e			 
144e			Str1IsBigger: 
144e 4f			    LD     C, A             ; Put length in BC 
144f 06 00		    LD     B, 0 
1451 13			    INC    DE              ; Increment pointers to meat of string. 
1452 23			    INC    HL 
1453			 
1453			CmpLoop: 
1453 1a			    LD     A, (DE)          ; Compare bytes. 
1454 ed a1		    CPI 
1456 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1458 13			    INC    DE              ; Update pointer. 
1459 ea 53 14		    JP     PE, CmpLoop 
145c			 
145c d1			    POP    DE 
145d e1			    POP    HL 
145e 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
145f be			    CP     (HL) 
1460 c9			    RET 
1461			 
1461			NoMatch: 
1461 2b			    DEC    HL 
1462 be			    CP     (HL)            ; Compare again to affect carry. 
1463 d1			    POP    DE 
1464 e1			    POP    HL 
1465 c9			    RET 
1466			 
1466			;; test strmp 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str2 
1466			;call strcmp 
1466			;jr z, .z1 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "NZ1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.z1: 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "ZZ1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str1 
1466			;call strcmp 
1466			;jr z, .z2 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "NZ2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.z2: 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "ZZ2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str2 
1466			;call strcmp 
1466			;jr c, .c1 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "Nc1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.c1: 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "cc1" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			; 
1466			;ld de, .str1 
1466			;ld hl, .str1 
1466			;call strcmp 
1466			;jr c, .c2 
1466			;;this 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "Nc2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;.c2: 
1466			; 
1466			;	if DEBUG_FORTH_WORDS 
1466			;		DMARK "cc2" 
1466			;		CALLMONITOR 
1466			;	endif 
1466			;	NEXTW 
1466			;.str1:   db "string1",0 
1466			;.str2:   db "string2",0 
1466			 
1466			; only care about direct match or not 
1466			; hl and de strings 
1466			; zero set if the same 
1466			 
1466			strcmp: 
1466 1a				ld a, (de) 
1467 be				cp (hl) 
1468 28 02			jr z, .ssame 
146a b7				or a 
146b c9				ret 
146c			 
146c			.ssame:  
146c fe 00			cp 0 
146e c8				ret z 
146f			 
146f 23				inc hl 
1470 13				inc de 
1471 18 f3			jr strcmp 
1473				 
1473				 
1473			 
1473			 
1473			 
1473			 
1473			; eof 
1473			 
1473			 
1473			 
1473			 
1473			 
1473			 
# End of file firmware_strings.asm
1473			include "firmware_memory.asm"   ; malloc and free  
1473			 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473			.mallocsize: db "Wants malloc >256",0 
1473			.mallocasize: db "MALLOC gives >256",0 
1473			.malloczero: db "MALLOC gives zero",0 
1473			 
1473			malloc_guard_zerolen: 
1473				push hl 
1473				push de 
1473				push af 
1473			 
1473				ld de, 0 
1473			        call cmp16 
1473				jr nz, .lowalloz 
1473			 
1473				push hl 
1473				push de 
1473					ld hl, display_fb0 
1473					ld (display_fb_active), hl 
1473				call clear_display 
1473				ld a, 0 
1473				ld de, .malloczero 
1473				call str_at_display 
1473				call update_display 
1473				call delay1s 
1473				call delay1s 
1473				call bp_on 
1473			;	ld a, 0 
1473			;	ld (os_view_disable), a 
1473			 
1473				pop de 
1473				pop hl 
1473			 
1473				 
1473			 
1473				CALLMONITOR 
1473			.lowalloz: 
1473			 
1473			 
1473				pop af 
1473				pop de 
1473				pop hl 
1473			ret 
1473			 
1473			malloc_guard_entry: 
1473				push hl 
1473				push de 
1473				push af 
1473			 
1473			 	or a      ;clear carry flag 
1473				push hl 
1473				ld de, 255 
1473				sbc hl, de 
1473				jr c, .lowalloc 
1473			 
1473				push de 
1473					ld hl, display_fb0 
1473					ld (display_fb_active), hl 
1473				call clear_display 
1473				ld a, 0 
1473				ld de, .mallocsize 
1473				call str_at_display 
1473				call update_display 
1473				call delay1s 
1473				call delay1s 
1473			;	ld a, 0 
1473			;	ld (os_view_disable), a 
1473				call bp_on 
1473			 
1473				pop de 
1473				pop hl 
1473			 
1473				 
1473			 
1473				CALLMONITOR 
1473				jr .lowdone 
1473			.lowalloc: 
1473			 
1473			 
1473				pop hl 
1473			.lowdone:	pop af 
1473				pop de 
1473				pop hl 
1473			ret 
1473			 
1473			malloc_guard_exit: 
1473				push hl 
1473				push de 
1473				push af 
1473			 
1473			 	or a      ;clear carry flag 
1473				push hl 
1473				ld de, 255 
1473				sbc hl, de 
1473				jr c, .lowallocx 
1473			 
1473				push de 
1473					ld hl, display_fb0 
1473					ld (display_fb_active), hl 
1473				call clear_display 
1473				ld a, 0 
1473				ld de, .mallocasize 
1473				call str_at_display 
1473				call update_display 
1473				call delay1s 
1473				call delay1s 
1473			;	ld a, 0 
1473			;	ld (os_view_disable), a 
1473				call bp_on 
1473				pop de 
1473				pop hl 
1473			 
1473				CALLMONITOR 
1473				jr .lowdonex 
1473			.lowallocx: 
1473			 
1473				pop hl 
1473			.lowdonex:	pop af 
1473				pop de 
1473				pop hl 
1473			ret 
1473			endif 
1473			 
1473			if MALLOC_2 
1473			; Z80 Malloc and Free Functions 
1473			 
1473			; Malloc Function: 
1473			; Input: 
1473			;   HL: Size of block to allocate 
1473			; Output: 
1473			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1473			 
1473			malloc: 
1473				 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473			call malloc_guard_entry 
1473			endif 
1473			 
1473			 
1473			 
1473			 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "mal" 
1473						CALLMONITOR 
1473					endif 
1473			    push af            ; Save AF register 
1473			    ld a, l            ; Load low byte of size into A 
1473			    or h               ; Check if size is zero 
1473			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1473			 
1473			    ; Allocate memory 
1473			    ld hl, (heap_start) ; Load start of heap into HL 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "ma1" 
1473						CALLMONITOR 
1473					endif 
1473			    call malloc_internal ; Call internal malloc function 
1473			    pop af             ; Restore AF register 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret                ; Return 
1473			 
1473			; Free Function: 
1473			; Input: 
1473			;   HL: Pointer to memory block to free 
1473			; Output: 
1473			;   None 
1473			 
1473			free: 
1473			    push af            ; Save AF register 
1473			    ld a, l            ; Load low byte of pointer into A 
1473			    or h               ; Check if pointer is NULL 
1473			    jp z, free_exit    ; If pointer is NULL, exit 
1473			 
1473			    ; Free memory 
1473			    ld hl, (heap_start) ; Load start of heap into HL 
1473			    call free_internal  ; Call internal free function 
1473			    pop af             ; Restore AF register 
1473			    ret                ; Return 
1473			 
1473			; Internal Malloc Function: 
1473			; Input: 
1473			;   HL: Size of block to allocate 
1473			; Output: 
1473			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1473			 
1473			malloc_internal: 
1473			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1473			    add hl, bc         ; Add management overhead to requested size 
1473			    ex de, hl          ; Save total size in DE, and keep it in HL 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "ma2" 
1473						CALLMONITOR 
1473					endif 
1473			 
1473			    ; Search for free memory block 
1473			    ld de, (heap_end)  ; Load end of heap into DE 
1473			    ld bc, 0           ; Initialize counter 
1473			 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "ma2" 
1473						CALLMONITOR 
1473					endif 
1473			malloc_search_loop: 
1473			    ; Check if current block is free 
1473			    ld a, (hl)         ; Load current block's status (free or used) 
1473			    cp 0               ; Compare with zero (free) 
1473			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1473			 
1473			    ; Check if current block is large enough 
1473			    ld a, (hl+1)       ; Load high byte of block size 
1473			    cp l               ; Compare with low byte of requested size 
1473			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1473			 
1473			    ld a, (hl+2)       ; Load low byte of block size 
1473			    cp h               ; Compare with high byte of requested size 
1473			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1473			 
1473			    ; Mark block as used 
1473			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1473			 
1473			    ; Calculate remaining space in block 
1473			    ld bc, 0           ; Clear BC 
1473			    add hl, bc         ; Increment HL to point to start of data block 
1473			    add hl, de         ; HL = HL + DE (total size) 
1473			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1473			    add hl, bc         ; Add management overhead to start of data block 
1473			 
1473			    ; Save pointer to allocated block in HL 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473						DMARK "ma5" 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret 
1473			 
1473			malloc_skip_block_check: 
1473			    ; Move to the next block 
1473			    ld bc, 3           ; Size of management overhead 
1473			    add hl, bc         ; Move to the next block 
1473			    inc de             ; Increment counter 
1473			 
1473			    ; Check if we have reached the end of heap 
1473			    ld a, e            ; Load low byte of heap end address 
1473			    cp (hl)            ; Compare with low byte of current address 
1473			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1473			    ld a, d            ; Load high byte of heap end address 
1473			    cp 0               ; Check if it's zero (end of memory) 
1473			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1473			 
1473			    ; If we reached here, allocation failed 
1473			    xor a              ; Set result to NULL 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473						DMARK "ma6" 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret 
1473			malloc_exit: 
1473			if DEBUG_FORTH_MALLOC_HIGH 
1473						DMARK "ma7" 
1473			call malloc_guard_exit 
1473			call malloc_guard_zerolen 
1473			endif 
1473			    ret 
1473			 
1473			; Internal Free Function: 
1473			; Input: 
1473			;   HL: Pointer to memory block to free 
1473			; Output: 
1473			;   None 
1473			 
1473			free_internal: 
1473			    ld de, (heap_start) ; Load start of heap into DE 
1473			    ld bc, 0            ; Initialize counter 
1473			 
1473			free_search_loop: 
1473			    ; Check if current block contains the pointer 
1473			    ld a, l             ; Load low byte of pointer 
1473			    cp (hl+1)           ; Compare with high byte of current block's address 
1473			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1473			    ld a, h             ; Load high byte of pointer 
1473			    cp (hl+2)           ; Compare with low byte of current block's address 
1473			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1473			 
1473			    ; Mark block as free 
1473			    ld (hl), 0          ; Set status byte to indicate free block 
1473			    ret                 ; Return 
1473			 
1473			free_skip_block_check: 
1473			    ; Move to the next block 
1473			    ld bc, 3            ; Size of management overhead 
1473			    add hl, bc          ; Move to the next block 
1473			    inc de              ; Increment counter 
1473			 
1473			    ; Check if we have reached the end of heap 
1473			    ld a, e             ; Load low byte of heap end address 
1473			    cp (hl)             ; Compare with low byte of current address 
1473			    jr nz, free_search_loop  ; If not equal, continue searching 
1473			    ld a, d             ; Load high byte of heap end address 
1473			    cp 0                ; Check if it's zero (end of memory) 
1473			    jr nz, free_search_loop  ; If not zero, continue searching 
1473			 
1473			    ; If we reached here, pointer is not found in heap 
1473			    ret 
1473			 
1473			free_exit: 
1473			    ret                 ; Return 
1473			 
1473			; Define heap start and end addresses 
1473			;heap_start:    .dw 0xC000   ; Start of heap 
1473			;heap_end:      .dw 0xE000   ; End of heap 
1473			 
1473			endif 
1473			 
1473			 
1473			if MALLOC_1 
1473			 
1473			 
1473			 
1473			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1473			 
1473			;moved to firmware.asm 
1473			;heap_start        .equ  0x9000      ; Starting address of heap 
1473			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1473			 
1473			;      .org 0 
1473			;      jp    main 
1473			 
1473			 
1473			;      .org  0x100 
1473			;main: 
1473			;      ld    HL, 0x8100 
1473			;      ld    SP, HL 
1473			; 
1473			;      call  heap_init 
1473			; 
1473			;      ; Make some allocations 
1473			;      ld    HL, 12 
1473			;      call  malloc            ; Allocates 0x9004 
1473			; 
1473			;      ld    HL, 12 
1473			;      call  malloc            ; Allocates 0x9014 
1473			; 
1473			;      ld    HL, 12 
1473			;      call  malloc            ; Allocates 0x9024 
1473			; 
1473			;      ; Free some allocations 
1473			;      ld    HL, 0x9014 
1473			;      call  free 
1473			; 
1473			;      ld    HL, 0x9004 
1473			;      call  free 
1473			; 
1473			;      ld    HL, 0x9024 
1473			;      call  free 
1473			; 
1473			; 
1473			;      halt 
1473			 
1473			 
1473			;------------------------------------------------------------------------------ 
1473			;     heap_init                                                               : 
1473			;                                                                             : 
1473			; Description                                                                 : 
1473			;     Initialise the heap and make it ready for malloc and free operations.   : 
1473			;                                                                             : 
1473			;     The heap is maintained as a linked list, starting with an initial       : 
1473			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1473			;     the first free block in the heap. Each block then points to the next    : 
1473			;     free block within the heap, and the free list ends at the first block   : 
1473			;     with a null pointer to the next free block.                             : 
1473			;                                                                             : 
1473			; Parameters                                                                  : 
1473			;     Inputs are compile-time only. Two defines which specify the starting    : 
1473			;     address of the heap and its size are required, along with a memory      : 
1473			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1473			;     principally stores a pointer to the first free block in the heap.       : 
1473			;                                                                             : 
1473			; Returns                                                                     : 
1473			;     Nothing                                                                 : 
1473			;------------------------------------------------------------------------------ 
1473			heap_init: 
1473 e5			      push  HL 
1474			 
1474			      ; Initialise free list struct 
1474 21 0e 80		      ld    HL, heap_start 
1477 22 0a 80		      ld    (free_list), HL 
147a 21 00 00		      ld    HL, 0 
147d 22 0c 80		      ld    (free_list+2), HL 
1480			 
1480			      ; Insert first free block at bottom of heap, consumes entire heap 
1480 21 a1 f1		      ld    HL, heap_start+heap_size-4 
1483 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1486 21 93 71		      ld    HL, heap_size-4 
1489 22 10 80		      ld    (heap_start+2), HL      ; Block size 
148c			 
148c			      ; Insert end of free list block at top of heap - two null words will 
148c			      ; terminate the free list 
148c 21 00 00		      ld    HL, 0 
148f 22 a3 f1		      ld    (heap_start+heap_size-2), HL 
1492 22 a1 f1		      ld    (heap_start+heap_size-4), HL 
1495			 
1495 e1			      pop   HL 
1496			 
1496 c9			      ret 
1497			 
1497			 
1497			;------------------------------------------------------------------------------ 
1497			;     malloc                                                                  : 
1497			;                                                                             : 
1497			; Description                                                                 : 
1497			;     Allocates the wanted space from the heap and returns the address of the : 
1497			;     first useable byte of the allocation.                                   : 
1497			;                                                                             : 
1497			;     Allocations can happen in one of two ways:                              : 
1497			;                                                                             : 
1497			;     1. A free block may be found which is the exact size wanted. In this    : 
1497			;        case the block is removed from the free list and retuedn to the      : 
1497			;        caller.                                                              : 
1497			;     2. A free block may be found which is larger than the size wanted. In   : 
1497			;        this case, the larger block is split into two. The first portion of  : 
1497			;        this block will become the requested space by the malloc call and    : 
1497			;        is returned to the caller. The second portion becomes a new free     : 
1497			;        block, and the free list is adjusted to maintain continuity via this : 
1497			;        newly created block.                                                 : 
1497			;                                                                             : 
1497			;     malloc does not set any initial value in the allocated space, the       : 
1497			;     caller is required to do this as required.                              : 
1497			;                                                                             : 
1497			;     This implementation of malloc uses the stack exclusively, and is        : 
1497			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1497			;     advisable to disable interrupts before calling malloc, and recommended  : 
1497			;     to avoid the use of malloc inside ISRs in general.                      : 
1497			;                                                                             : 
1497			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1497			;                                                                             : 
1497			; Parameters                                                                  : 
1497			;     HL  Number of bytes wanted                                              : 
1497			;                                                                             : 
1497			; Returns                                                                     : 
1497			;     HL  Address of the first useable byte of the allocation                 : 
1497			;                                                                             : 
1497			; Flags                                                                       : 
1497			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1497			;                                                                             : 
1497			; Stack frame                                                                 : 
1497			;       |             |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |     BC      |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |     DE      |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |     IX      |                                                       : 
1497			;       +-------------+                                                       : 
1497			;       |  prev_free  |                                                       : 
1497			;   +4  +-------------+                                                       : 
1497			;       |  this_free  |                                                       : 
1497			;   +2  +-------------+                                                       : 
1497			;       |  next_free  |                                                       : 
1497			;   +0  +-------------+                                                       : 
1497			;       |             |                                                       : 
1497			;                                                                             : 
1497			;------------------------------------------------------------------------------ 
1497			 
1497			 
1497			;malloc: 
1497			; 
1497			;	SAVESP ON 1 
1497			; 
1497			;	call malloc_code 
1497			; 
1497			;	CHECKSP ON 1 
1497			;	ret 
1497			 
1497			 
1497			malloc: 
1497 c5			      push  BC 
1498 d5			      push  DE 
1499 dd e5		      push  IX 
149b			if DEBUG_FORTH_MALLOC_HIGH 
149b			call malloc_guard_entry 
149b			endif 
149b			 
149b					if DEBUG_FORTH_MALLOC 
149b						DMARK "mal" 
149b						CALLMONITOR 
149b					endif 
149b 7c			      ld    A, H                    ; Exit if no space requested 
149c b5			      or    L 
149d ca 5c 15		      jp    Z, malloc_early_exit 
14a0			 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			; 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			;inc hl 
14a0			 
14a0			 
14a0			 
14a0			 
14a0					if DEBUG_FORTH_MALLOC 
14a0						DMARK "maA" 
14a0						CALLMONITOR 
14a0					endif 
14a0			      ; Set up stack frame 
14a0 eb			      ex    DE, HL 
14a1 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
14a4 39			      add   HL, SP 
14a5 f9			      ld    SP, HL 
14a6 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14aa dd 39		      add   IX, SP 
14ac			 
14ac			      ; Setup initial state 
14ac 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
14af 19			      add   HL, DE 
14b0			 
14b0 44			      ld    B, H                    ; Move want to BC 
14b1 4d			      ld    C, L 
14b2			 
14b2 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
14b5 dd 75 04		      ld    (IX+4), L 
14b8 dd 74 05		      ld    (IX+5), H 
14bb			 
14bb 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
14bc 23			      inc   HL 
14bd 56			      ld    D, (HL) 
14be dd 73 02		      ld    (IX+2), E 
14c1 dd 72 03		      ld    (IX+3), D 
14c4 eb			      ex    DE, HL                  ; this_free ptr into HL 
14c5			 
14c5					if DEBUG_FORTH_MALLOC 
14c5						DMARK "maB" 
14c5						CALLMONITOR 
14c5					endif 
14c5			      ; Loop through free block list to find some space 
14c5			malloc_find_space: 
14c5 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
14c6 23			      inc   HL 
14c7 56			      ld    D, (HL) 
14c8			 
14c8 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
14c9 b3			      or    E 
14ca ca 56 15		      jp    Z, malloc_no_space 
14cd			 
14cd dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
14d0 dd 72 01		      ld    (IX+1), D 
14d3			 
14d3			      ; Does this block have enough space to make the allocation? 
14d3 23			      inc   HL                      ; Load free block size into DE 
14d4 5e			      ld    E, (HL) 
14d5 23			      inc   HL 
14d6 56			      ld    D, (HL) 
14d7			 
14d7 eb			      ex    DE, HL                  ; Check size of block against want 
14d8 b7			      or    A                       ; Ensure carry flag clear 
14d9 ed 42		      sbc   HL, BC 
14db e5			      push  HL                      ; Store the result for later (new block size) 
14dc			 
14dc ca 2b 15		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
14df 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
14e1			 
14e1			      ; this_free block is not big enough, setup ptrs to test next free block 
14e1 e1			      pop   HL                      ; Discard previous result 
14e2			 
14e2 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
14e5 dd 66 03		      ld    H, (IX+3) 
14e8 dd 75 04		      ld    (IX+4), L 
14eb dd 74 05		      ld    (IX+5), H 
14ee			 
14ee dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
14f1 dd 66 01		      ld    H, (IX+1) 
14f4 dd 75 02		      ld    (IX+2), L 
14f7 dd 74 03		      ld    (IX+3), H 
14fa			 
14fa					if DEBUG_FORTH_MALLOC 
14fa						DMARK "MA>" 
14fa						CALLMONITOR 
14fa					endif 
14fa 18 c9		      jr    malloc_find_space 
14fc			 
14fc			      ; split a bigger block into two - requested size and remaining size 
14fc			malloc_alloc_split: 
14fc					if DEBUG_FORTH_MALLOC 
14fc						DMARK "MAs" 
14fc						CALLMONITOR 
14fc					endif 
14fc eb			      ex    DE, HL                  ; Calculate address of new free block 
14fd 2b			      dec   HL 
14fe 2b			      dec   HL 
14ff 2b			      dec   HL 
1500 09			      add   HL, BC 
1501			 
1501			      ; Create a new block and point it at next_free 
1501 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1504 dd 56 01		      ld    D, (IX+1) 
1507			 
1507 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1508 23			      inc   HL 
1509 72			      ld    (HL), D 
150a			 
150a d1			      pop   DE                      ; Store size of new block into new block 
150b 23			      inc   HL 
150c 73			      ld    (HL), E 
150d 23			      inc   HL 
150e 72			      ld    (HL), D 
150f			 
150f			      ; Update this_free ptr to point to new block 
150f 2b			      dec   HL 
1510 2b			      dec   HL 
1511 2b			      dec   HL 
1512			 
1512 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1515 dd 56 03		      ld    D, (IX+3) 
1518			 
1518 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
151b dd 74 03		      ld    (IX+3), H 
151e			 
151e			      ; Modify this_free block to be allocation 
151e eb			      ex    DE, HL 
151f af			      xor   A                       ; Null the next block ptr of allocated block 
1520 77			      ld    (HL), A 
1521 23			      inc   HL 
1522 77			      ld    (HL), A 
1523			 
1523 23			      inc   HL                      ; Store want size into allocated block 
1524 71			      ld    (HL), C 
1525 23			      inc   HL 
1526 70			      ld    (HL), B 
1527 23			      inc   HL 
1528 e5			      push  HL                      ; Address of allocation to return 
1529			 
1529 18 19		      jr    malloc_update_links 
152b			 
152b			malloc_alloc_fit: 
152b e1			      pop   HL                      ; Dont need new block size, want is exact fit 
152c			 
152c					if DEBUG_FORTH_MALLOC 
152c						DMARK "MAf" 
152c						CALLMONITOR 
152c					endif 
152c			      ; Modify this_free block to be allocation 
152c eb			      ex    DE, HL 
152d 2b			      dec   HL 
152e 2b			      dec   HL 
152f 2b			      dec   HL 
1530			 
1530 af			      xor   A                       ; Null the next block ptr of allocated block 
1531 77			      ld    (HL), A 
1532 23			      inc   HL 
1533 77			      ld    (HL), A 
1534			 
1534 23			      inc   HL                      ; Store address of allocation to return 
1535 23			      inc   HL 
1536 23			      inc   HL 
1537 e5			      push  HL 
1538			 
1538			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1538 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
153b dd 66 01		      ld    H, (IX+1) 
153e			 
153e dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1541 dd 74 03		      ld    (IX+3), H 
1544			 
1544			 
1544			malloc_update_links: 
1544			      ; Update prev_free ptr to point to this_free 
1544 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1547 dd 66 05		      ld    H, (IX+5) 
154a			 
154a dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
154d dd 56 03		      ld    D, (IX+3) 
1550			 
1550 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1551 23			      inc   HL 
1552 72			      ld    (HL), D 
1553			 
1553					if DEBUG_FORTH_MALLOC 
1553						DMARK "Mul" 
1553						CALLMONITOR 
1553					endif 
1553			      ; Clear the Z flag to indicate successful allocation 
1553 7a			      ld    A, D 
1554 b3			      or    E 
1555			 
1555 d1			      pop   DE                      ; Address of allocation 
1556					if DEBUG_FORTH_MALLOC 
1556						DMARK "MAu" 
1556						CALLMONITOR 
1556					endif 
1556			 
1556			malloc_no_space: 
1556 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1559 39			      add   HL, SP 
155a f9			      ld    SP, HL 
155b			 
155b eb			      ex    DE, HL                  ; Alloc addr into HL for return 
155c					if DEBUG_FORTH_MALLOC 
155c						DMARK "MAN" 
155c						CALLMONITOR 
155c					endif 
155c			 
155c			malloc_early_exit: 
155c					if DEBUG_FORTH_MALLOC 
155c						DMARK "MAx" 
155c						CALLMONITOR 
155c					endif 
155c dd e1		      pop   IX 
155e d1			      pop   DE 
155f c1			      pop   BC 
1560			 
1560			if DEBUG_FORTH_MALLOC_HIGH 
1560			call malloc_guard_exit 
1560			call malloc_guard_zerolen 
1560			endif 
1560 c9			      ret 
1561			 
1561			 
1561			;------------------------------------------------------------------------------ 
1561			;     free                                                                    : 
1561			;                                                                             : 
1561			; Description                                                                 : 
1561			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1561			;     returned by malloc, otherwise the behaviour is undefined.               : 
1561			;                                                                             : 
1561			;     Where possible, directly adjacent free blocks will be merged together   : 
1561			;     into larger blocks to help ensure that the heap does not become         : 
1561			;     excessively fragmented.                                                 : 
1561			;                                                                             : 
1561			;     free does not clear or set any other value into the freed space, and    : 
1561			;     therefore its contents may be visible through subsequent malloc's. The  : 
1561			;     caller should clear the freed space as required.                        : 
1561			;                                                                             : 
1561			;     This implementation of free uses the stack exclusively, and is          : 
1561			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1561			;     advisable to disable interrupts before calling free, and recommended    : 
1561			;     to avoid the use of free inside ISRs in general.                        : 
1561			;                                                                             : 
1561			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1561			;                                                                             : 
1561			; Parameters                                                                  : 
1561			;     HL  Pointer to address of first byte of allocation to be freed          : 
1561			;                                                                             : 
1561			; Returns                                                                     : 
1561			;     Nothing                                                                 : 
1561			;                                                                             : 
1561			; Stack frame                                                                 : 
1561			;       |             |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     BC      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     DE      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |     IX      |                                                       : 
1561			;       +-------------+                                                       : 
1561			;       |  prev_free  |                                                       : 
1561			;   +2  +-------------+                                                       : 
1561			;       |  next_free  |                                                       : 
1561			;   +0  +-------------+                                                       : 
1561			;       |             |                                                       : 
1561			;                                                                             : 
1561			;------------------------------------------------------------------------------ 
1561			free: 
1561 c5			      push  BC 
1562 d5			      push  DE 
1563 dd e5		      push  IX 
1565			 
1565 7c			      ld    A, H                    ; Exit if ptr is null 
1566 b5			      or    L 
1567 ca 2b 16		      jp    Z, free_early_exit 
156a			 
156a			      ; Set up stack frame 
156a eb			      ex    DE, HL 
156b 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
156e 39			      add   HL, SP 
156f f9			      ld    SP, HL 
1570 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1574 dd 39		      add   IX, SP 
1576			 
1576			      ; The address in HL points to the start of the useable allocated space, 
1576			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1576			      ; address of the block itself. 
1576 eb			      ex    DE, HL 
1577 11 fc ff		      ld    DE, -4 
157a 19			      add   HL, DE 
157b			 
157b			      ; An allocated block must have a null next block pointer in it 
157b 7e			      ld    A, (HL) 
157c 23			      inc   HL 
157d b6			      or    (HL) 
157e c2 26 16		      jp    NZ, free_done 
1581			 
1581 2b			      dec   HL 
1582			 
1582 44			      ld    B, H                    ; Copy HL to BC 
1583 4d			      ld    C, L 
1584			 
1584			      ; Loop through the free list to find the first block with an address 
1584			      ; higher than the block being freed 
1584 21 0a 80		      ld    HL, free_list 
1587			 
1587			free_find_higher_block: 
1587 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1588 23			      inc   HL 
1589 56			      ld    D, (HL) 
158a 2b			      dec   HL 
158b			 
158b dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
158e dd 72 01		      ld    (IX+1), D 
1591 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1594 dd 74 03		      ld    (IX+3), H 
1597			 
1597 78			      ld    A, B                    ; Check if DE is greater than BC 
1598 ba			      cp    D                       ; Compare MSB first 
1599 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
159b 30 04		      jr    NC, free_find_higher_block_skip 
159d 79			      ld    A, C 
159e bb			      cp    E                       ; Then compare LSB 
159f 38 08		      jr    C, free_found_higher_block 
15a1			 
15a1			free_find_higher_block_skip: 
15a1 7a			      ld    A, D                    ; Reached the end of the free list? 
15a2 b3			      or    E 
15a3 ca 26 16		      jp    Z, free_done 
15a6			 
15a6 eb			      ex    DE, HL 
15a7			 
15a7 18 de		      jr    free_find_higher_block 
15a9			 
15a9			free_found_higher_block: 
15a9			      ; Insert freed block between prev and next free blocks 
15a9 71			      ld    (HL), C                 ; Point prev free block to freed block 
15aa 23			      inc   HL 
15ab 70			      ld    (HL), B 
15ac			 
15ac 60			      ld    H, B                    ; Point freed block at next free block 
15ad 69			      ld    L, C 
15ae 73			      ld    (HL), E 
15af 23			      inc   HL 
15b0 72			      ld    (HL), D 
15b1			 
15b1			      ; Check if the freed block is adjacent to the next free block 
15b1 23			      inc   HL                      ; Load size of freed block into HL 
15b2 5e			      ld    E, (HL) 
15b3 23			      inc   HL 
15b4 56			      ld    D, (HL) 
15b5 eb			      ex    DE, HL 
15b6			 
15b6 09			      add   HL, BC                  ; Add addr of freed block and its size 
15b7			 
15b7 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
15ba dd 56 01		      ld    D, (IX+1) 
15bd			 
15bd b7			      or    A                       ; Clear the carry flag 
15be ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15c0 20 22		      jr    NZ, free_check_adjacent_to_prev 
15c2			 
15c2			      ; Freed block is adjacent to next, merge into one bigger block 
15c2 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
15c3 5e			      ld    E, (HL) 
15c4 23			      inc   HL 
15c5 56			      ld    D, (HL) 
15c6 e5			      push  HL                      ; Save ptr to next block for later 
15c7			 
15c7 60			      ld    H, B                    ; Store ptr from next block into freed block 
15c8 69			      ld    L, C 
15c9 73			      ld    (HL), E 
15ca 23			      inc   HL 
15cb 72			      ld    (HL), D 
15cc			 
15cc e1			      pop   HL                      ; Restore ptr to next block 
15cd 23			      inc   HL                      ; Load size of next block into DE 
15ce 5e			      ld    E, (HL) 
15cf 23			      inc   HL 
15d0 56			      ld    D, (HL) 
15d1 d5			      push  DE                      ; Save next block size for later 
15d2			 
15d2 60			      ld    H, B                    ; Load size of freed block into HL 
15d3 69			      ld    L, C 
15d4 23			      inc   HL 
15d5 23			      inc   HL 
15d6 5e			      ld    E, (HL) 
15d7 23			      inc   HL 
15d8 56			      ld    D, (HL) 
15d9 eb			      ex    DE, HL 
15da			 
15da d1			      pop   DE                      ; Restore size of next block 
15db 19			      add   HL, DE                  ; Add sizes of both blocks 
15dc eb			      ex    DE, HL 
15dd			 
15dd 60			      ld    H, B                    ; Store new bigger size into freed block 
15de 69			      ld    L, C 
15df 23			      inc   HL 
15e0 23			      inc   HL 
15e1 73			      ld    (HL), E 
15e2 23			      inc   HL 
15e3 72			      ld    (HL), D 
15e4			 
15e4			free_check_adjacent_to_prev: 
15e4			      ; Check if the freed block is adjacent to the prev free block 
15e4 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
15e7 dd 66 03		      ld    H, (IX+3) 
15ea			 
15ea 23			      inc   HL                      ; Size of prev free block into DE 
15eb 23			      inc   HL 
15ec 5e			      ld    E, (HL) 
15ed 23			      inc   HL 
15ee 56			      ld    D, (HL) 
15ef 2b			      dec   HL 
15f0 2b			      dec   HL 
15f1 2b			      dec   HL 
15f2			 
15f2 19			      add   HL, DE                  ; Add prev block addr and size 
15f3			 
15f3 b7			      or    A                       ; Clear the carry flag 
15f4 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15f6 20 2e		      jr    NZ, free_done 
15f8			 
15f8			      ; Freed block is adjacent to prev, merge into one bigger block 
15f8 60			      ld    H, B                    ; Load next ptr from freed block into DE 
15f9 69			      ld    L, C 
15fa 5e			      ld    E, (HL) 
15fb 23			      inc   HL 
15fc 56			      ld    D, (HL) 
15fd e5			      push  HL                      ; Save freed block ptr for later 
15fe			 
15fe dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1601 dd 66 03		      ld    H, (IX+3) 
1604 73			      ld    (HL), E 
1605 23			      inc   HL 
1606 72			      ld    (HL), D 
1607			 
1607 e1			      pop   HL                      ; Restore freed block ptr 
1608 23			      inc   HL                      ; Load size of freed block into DE 
1609 5e			      ld    E, (HL) 
160a 23			      inc   HL 
160b 56			      ld    D, (HL) 
160c d5			      push  DE                      ; Save freed block size for later 
160d			 
160d dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1610 dd 66 03		      ld    H, (IX+3) 
1613 23			      inc   HL 
1614 23			      inc   HL 
1615 5e			      ld    E, (HL) 
1616 23			      inc   HL 
1617 56			      ld    D, (HL) 
1618			 
1618 e1			      pop   HL                      ; Add sizes of both blocks 
1619 19			      add   HL, DE 
161a eb			      ex    DE, HL 
161b			 
161b dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
161e dd 66 03		      ld    H, (IX+3) 
1621 23			      inc   HL 
1622 23			      inc   HL 
1623 73			      ld    (HL), E 
1624 23			      inc   HL 
1625 72			      ld    (HL), D 
1626			 
1626			free_done: 
1626 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1629 39			      add   HL, SP 
162a f9			      ld    SP, HL 
162b			 
162b			free_early_exit: 
162b dd e1		      pop   IX 
162d d1			      pop   DE 
162e c1			      pop   BC 
162f			 
162f c9			      ret 
1630			 
1630			; moved to firmware.asm 
1630			; 
1630			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1630			;                  .dw   0 
1630			 
1630			 
1630			endif 
1630			 
1630			 
1630			if MALLOC_3 
1630			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1630			;heap_start        .equ  0x9000      ; Starting address of heap 
1630			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1630			; 
1630			 ;     .org 0 
1630			  ;    jp    main 
1630			; 
1630			; 
1630			 ;     .org  0x100 
1630			;main: 
1630			 ;     ld    HL, 0x8100 
1630			  ;    ld    SP, HL 
1630			; 
1630			;      call  heap_init 
1630			 
1630			      ; Make some allocations 
1630			;      ld    HL, 12 
1630			;      call  malloc            ; Allocates 0x9004 
1630			; 
1630			 ;     ld    HL, 12 
1630			;      call  malloc            ; Allocates 0x9014 
1630			 
1630			;      ld    HL, 12 
1630			;      call  malloc            ; Allocates 0x9024 
1630			 
1630			      ; Free some allocations 
1630			;      ld    HL, 0x9014 
1630			;      call  free 
1630			 
1630			;      ld    HL, 0x9004 
1630			;      call  free 
1630			; 
1630			;      ld    HL, 0x9024 
1630			;      call  free 
1630			 
1630			 
1630			 ;     halt 
1630			 
1630			 
1630			;------------------------------------------------------------------------------ 
1630			;     heap_init                                                               : 
1630			;                                                                             : 
1630			; Description                                                                 : 
1630			;     Initialise the heap and make it ready for malloc and free operations.   : 
1630			;                                                                             : 
1630			;     The heap is maintained as a linked list, starting with an initial       : 
1630			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1630			;     the first free block in the heap. Each block then points to the next    : 
1630			;     free block within the heap, and the free list ends at the first block   : 
1630			;     with a null pointer to the next free block.                             : 
1630			;                                                                             : 
1630			; Parameters                                                                  : 
1630			;     Inputs are compile-time only. Two defines which specify the starting    : 
1630			;     address of the heap and its size are required, along with a memory      : 
1630			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1630			;     principally stores a pointer to the first free block in the heap.       : 
1630			;                                                                             : 
1630			; Returns                                                                     : 
1630			;     Nothing                                                                 : 
1630			;------------------------------------------------------------------------------ 
1630			heap_init: 
1630			      push  HL 
1630			 
1630			      ; Initialise free list struct 
1630			      ld    HL, heap_start 
1630			      ld    (free_list), HL 
1630			      ld    HL, 0 
1630			      ld    (free_list+2), HL 
1630			 
1630			      ; Insert first free block at bottom of heap, consumes entire heap 
1630			      ld    HL, heap_start+heap_size-4 
1630			      ld    (heap_start), HL        ; Next block (end of free list) 
1630			      ld    HL, heap_size-4 
1630			      ld    (heap_start+2), HL      ; Block size 
1630			 
1630			      ; Insert end of free list block at top of heap - two null words will 
1630			      ; terminate the free list 
1630			      ld    HL, 0 
1630			      ld    (heap_start+heap_size-2), HL 
1630			      ld    (heap_start+heap_size-4), HL 
1630			 
1630			      pop   HL 
1630			 
1630			      ret 
1630			 
1630			 
1630			;------------------------------------------------------------------------------ 
1630			;     malloc                                                                  : 
1630			;                                                                             : 
1630			; Description                                                                 : 
1630			;     Allocates the wanted space from the heap and returns the address of the : 
1630			;     first useable byte of the allocation.                                   : 
1630			;                                                                             : 
1630			;     Allocations can happen in one of two ways:                              : 
1630			;                                                                             : 
1630			;     1. A free block may be found which is the exact size wanted. In this    : 
1630			;        case the block is removed from the free list and retuedn to the      : 
1630			;        caller.                                                              : 
1630			;     2. A free block may be found which is larger than the size wanted. In   : 
1630			;        this case, the larger block is split into two. The first portion of  : 
1630			;        this block will become the requested space by the malloc call and    : 
1630			;        is returned to the caller. The second portion becomes a new free     : 
1630			;        block, and the free list is adjusted to maintain continuity via this : 
1630			;        newly created block.                                                 : 
1630			;                                                                             : 
1630			;     malloc does not set any initial value in the allocated space, the       : 
1630			;     caller is required to do this as required.                              : 
1630			;                                                                             : 
1630			;     This implementation of malloc uses the stack exclusively, and is        : 
1630			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1630			;     advisable to disable interrupts before calling malloc, and recommended  : 
1630			;     to avoid the use of malloc inside ISRs in general.                      : 
1630			;                                                                             : 
1630			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1630			;                                                                             : 
1630			; Parameters                                                                  : 
1630			;     HL  Number of bytes wanted                                              : 
1630			;                                                                             : 
1630			; Returns                                                                     : 
1630			;     HL  Address of the first useable byte of the allocation                 : 
1630			;                                                                             : 
1630			; Flags                                                                       : 
1630			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1630			;                                                                             : 
1630			; Stack frame                                                                 : 
1630			;       |             |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     BC      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     DE      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     IX      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |  prev_free  |                                                       : 
1630			;   +4  +-------------+                                                       : 
1630			;       |  this_free  |                                                       : 
1630			;   +2  +-------------+                                                       : 
1630			;       |  next_free  |                                                       : 
1630			;   +0  +-------------+                                                       : 
1630			;       |             |                                                       : 
1630			;                                                                             : 
1630			;------------------------------------------------------------------------------ 
1630			malloc: 
1630			      push  BC 
1630			      push  DE 
1630			      push  IX 
1630			 
1630			      ld    A, H                    ; Exit if no space requested 
1630			      or    L 
1630			      jp    Z, malloc_early_exit 
1630			 
1630			      ; Set up stack frame 
1630			      ex    DE, HL 
1630			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			      ld    IX, 0                   ; Use IX as a frame pointer 
1630			      add   IX, SP 
1630			 
1630			      ; Setup initial state 
1630			      ld    HL, 4                   ; want must also include space used by block struct 
1630			      add   HL, DE 
1630			 
1630			      ld    B, H                    ; Move want to BC 
1630			      ld    C, L 
1630			 
1630			      ld    HL, free_list           ; Store prev_free ptr to stack 
1630			      ld    (IX+4), L 
1630			      ld    (IX+5), H 
1630			 
1630			      ld    E, (HL)                 ; Store this_free ptr to stack 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      ld    (IX+2), E 
1630			      ld    (IX+3), D 
1630			      ex    DE, HL                  ; this_free ptr into HL 
1630			 
1630			      ; Loop through free block list to find some space 
1630			malloc_find_space: 
1630			      ld    E, (HL)                 ; Load next_free ptr into DE 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			 
1630			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1630			      or    E 
1630			      jp    Z, malloc_no_space 
1630			 
1630			      ld    (IX+0), E               ; Store next_free ptr to stack 
1630			      ld    (IX+1), D 
1630			 
1630			      ; Does this block have enough space to make the allocation? 
1630			      inc   HL                      ; Load free block size into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			 
1630			      ex    DE, HL                  ; Check size of block against want 
1630			      or    A                       ; Ensure carry flag clear 
1630			      sbc   HL, BC 
1630			      push  HL                      ; Store the result for later (new block size) 
1630			 
1630			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1630			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1630			 
1630			      ; this_free block is not big enough, setup ptrs to test next free block 
1630			      pop   HL                      ; Discard previous result 
1630			 
1630			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1630			      ld    H, (IX+3) 
1630			      ld    (IX+4), L 
1630			      ld    (IX+5), H 
1630			 
1630			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1630			      ld    H, (IX+1) 
1630			      ld    (IX+2), L 
1630			      ld    (IX+3), H 
1630			 
1630			      jr    malloc_find_space 
1630			 
1630			      ; split a bigger block into two - requested size and remaining size 
1630			malloc_alloc_split: 
1630			      ex    DE, HL                  ; Calculate address of new free block 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			      add   HL, BC 
1630			 
1630			      ; Create a new block and point it at next_free 
1630			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1630			      ld    D, (IX+1) 
1630			 
1630			      ld    (HL), E                 ; Store next_free ptr into new block 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      pop   DE                      ; Store size of new block into new block 
1630			      inc   HL 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      ; Update this_free ptr to point to new block 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			 
1630			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1630			      ld    D, (IX+3) 
1630			 
1630			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1630			      ld    (IX+3), H 
1630			 
1630			      ; Modify this_free block to be allocation 
1630			      ex    DE, HL 
1630			      xor   A                       ; Null the next block ptr of allocated block 
1630			      ld    (HL), A 
1630			      inc   HL 
1630			      ld    (HL), A 
1630			 
1630			      inc   HL                      ; Store want size into allocated block 
1630			      ld    (HL), C 
1630			      inc   HL 
1630			      ld    (HL), B 
1630			      inc   HL 
1630			      push  HL                      ; Address of allocation to return 
1630			 
1630			      jr    malloc_update_links 
1630			 
1630			malloc_alloc_fit: 
1630			      pop   HL                      ; Dont need new block size, want is exact fit 
1630			 
1630			      ; Modify this_free block to be allocation 
1630			      ex    DE, HL 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			 
1630			      xor   A                       ; Null the next block ptr of allocated block 
1630			      ld    (HL), A 
1630			      inc   HL 
1630			      ld    (HL), A 
1630			 
1630			      inc   HL                      ; Store address of allocation to return 
1630			      inc   HL 
1630			      inc   HL 
1630			      push  HL 
1630			 
1630			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1630			      ld    L, (IX+0)               ; next_free to HL 
1630			      ld    H, (IX+1) 
1630			 
1630			      ld    (IX+2), L               ; HL to this_free 
1630			      ld    (IX+3), H 
1630			 
1630			 
1630			malloc_update_links: 
1630			      ; Update prev_free ptr to point to this_free 
1630			      ld    L, (IX+4)               ; prev_free ptr to HL 
1630			      ld    H, (IX+5) 
1630			 
1630			      ld    E, (IX+2)               ; this_free ptr to DE 
1630			      ld    D, (IX+3) 
1630			 
1630			      ld    (HL), E                 ; this_free ptr into prev_free 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      ; Clear the Z flag to indicate successful allocation 
1630			      ld    A, D 
1630			      or    E 
1630			 
1630			      pop   DE                      ; Address of allocation 
1630			 
1630			malloc_no_space: 
1630			      ld    HL, 6                   ; Clean up stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			 
1630			      ex    DE, HL                  ; Alloc addr into HL for return 
1630			 
1630			malloc_early_exit: 
1630			      pop   IX 
1630			      pop   DE 
1630			      pop   BC 
1630			 
1630			      ret 
1630			 
1630			 
1630			;------------------------------------------------------------------------------ 
1630			;     free                                                                    : 
1630			;                                                                             : 
1630			; Description                                                                 : 
1630			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1630			;     returned by malloc, otherwise the behaviour is undefined.               : 
1630			;                                                                             : 
1630			;     Where possible, directly adjacent free blocks will be merged together   : 
1630			;     into larger blocks to help ensure that the heap does not become         : 
1630			;     excessively fragmented.                                                 : 
1630			;                                                                             : 
1630			;     free does not clear or set any other value into the freed space, and    : 
1630			;     therefore its contents may be visible through subsequent malloc's. The  : 
1630			;     caller should clear the freed space as required.                        : 
1630			;                                                                             : 
1630			;     This implementation of free uses the stack exclusively, and is          : 
1630			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1630			;     advisable to disable interrupts before calling free, and recommended    : 
1630			;     to avoid the use of free inside ISRs in general.                        : 
1630			;                                                                             : 
1630			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1630			;                                                                             : 
1630			; Parameters                                                                  : 
1630			;     HL  Pointer to address of first byte of allocation to be freed          : 
1630			;                                                                             : 
1630			; Returns                                                                     : 
1630			;     Nothing                                                                 : 
1630			;                                                                             : 
1630			; Stack frame                                                                 : 
1630			;       |             |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     BC      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     DE      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |     IX      |                                                       : 
1630			;       +-------------+                                                       : 
1630			;       |  prev_free  |                                                       : 
1630			;   +2  +-------------+                                                       : 
1630			;       |  next_free  |                                                       : 
1630			;   +0  +-------------+                                                       : 
1630			;       |             |                                                       : 
1630			;                                                                             : 
1630			;------------------------------------------------------------------------------ 
1630			free: 
1630			      push  BC 
1630			      push  DE 
1630			      push  IX 
1630			 
1630			      ld    A, H                    ; Exit if ptr is null 
1630			      or    L 
1630			      jp    Z, free_early_exit 
1630			 
1630			      ; Set up stack frame 
1630			      ex    DE, HL 
1630			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			      ld    IX, 0                   ; Use IX as a frame pointer 
1630			      add   IX, SP 
1630			 
1630			      ; The address in HL points to the start of the useable allocated space, 
1630			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1630			      ; address of the block itself. 
1630			      ex    DE, HL 
1630			      ld    DE, -4 
1630			      add   HL, DE 
1630			 
1630			      ; An allocated block must have a null next block pointer in it 
1630			      ld    A, (HL) 
1630			      inc   HL 
1630			      or    (HL) 
1630			      jp    NZ, free_done 
1630			 
1630			      dec   HL 
1630			 
1630			      ld    B, H                    ; Copy HL to BC 
1630			      ld    C, L 
1630			 
1630			      ; Loop through the free list to find the first block with an address 
1630			      ; higher than the block being freed 
1630			      ld    HL, free_list 
1630			 
1630			free_find_higher_block: 
1630			      ld    E, (HL)                 ; Load next ptr from free block 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      dec   HL 
1630			 
1630			      ld    (IX+0), E               ; Save ptr to next free block 
1630			      ld    (IX+1), D 
1630			      ld    (IX+2), L               ; Save ptr to prev free block 
1630			      ld    (IX+3), H 
1630			 
1630			      ld    A, B                    ; Check if DE is greater than BC 
1630			      cp    D                       ; Compare MSB first 
1630			      jr    Z, $+4                  ; MSB the same, compare LSB 
1630			      jr    NC, free_find_higher_block_skip 
1630			      ld    A, C 
1630			      cp    E                       ; Then compare LSB 
1630			      jr    C, free_found_higher_block 
1630			 
1630			free_find_higher_block_skip: 
1630			      ld    A, D                    ; Reached the end of the free list? 
1630			      or    E 
1630			      jp    Z, free_done 
1630			 
1630			      ex    DE, HL 
1630			 
1630			      jr    free_find_higher_block 
1630			 
1630			free_found_higher_block: 
1630			      ; Insert freed block between prev and next free blocks 
1630			      ld    (HL), C                 ; Point prev free block to freed block 
1630			      inc   HL 
1630			      ld    (HL), B 
1630			 
1630			      ld    H, B                    ; Point freed block at next free block 
1630			      ld    L, C 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      ; Check if the freed block is adjacent to the next free block 
1630			      inc   HL                      ; Load size of freed block into HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      ex    DE, HL 
1630			 
1630			      add   HL, BC                  ; Add addr of freed block and its size 
1630			 
1630			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1630			      ld    D, (IX+1) 
1630			 
1630			      or    A                       ; Clear the carry flag 
1630			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1630			      jr    NZ, free_check_adjacent_to_prev 
1630			 
1630			      ; Freed block is adjacent to next, merge into one bigger block 
1630			      ex    DE, HL                  ; Load next ptr from next block into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  HL                      ; Save ptr to next block for later 
1630			 
1630			      ld    H, B                    ; Store ptr from next block into freed block 
1630			      ld    L, C 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      pop   HL                      ; Restore ptr to next block 
1630			      inc   HL                      ; Load size of next block into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  DE                      ; Save next block size for later 
1630			 
1630			      ld    H, B                    ; Load size of freed block into HL 
1630			      ld    L, C 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      ex    DE, HL 
1630			 
1630			      pop   DE                      ; Restore size of next block 
1630			      add   HL, DE                  ; Add sizes of both blocks 
1630			      ex    DE, HL 
1630			 
1630			      ld    H, B                    ; Store new bigger size into freed block 
1630			      ld    L, C 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			free_check_adjacent_to_prev: 
1630			      ; Check if the freed block is adjacent to the prev free block 
1630			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1630			      ld    H, (IX+3) 
1630			 
1630			      inc   HL                      ; Size of prev free block into DE 
1630			      inc   HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      dec   HL 
1630			      dec   HL 
1630			      dec   HL 
1630			 
1630			      add   HL, DE                  ; Add prev block addr and size 
1630			 
1630			      or    A                       ; Clear the carry flag 
1630			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1630			      jr    NZ, free_done 
1630			 
1630			      ; Freed block is adjacent to prev, merge into one bigger block 
1630			      ld    H, B                    ; Load next ptr from freed block into DE 
1630			      ld    L, C 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  HL                      ; Save freed block ptr for later 
1630			 
1630			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1630			      ld    H, (IX+3) 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			      pop   HL                      ; Restore freed block ptr 
1630			      inc   HL                      ; Load size of freed block into DE 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			      push  DE                      ; Save freed block size for later 
1630			 
1630			      ld    L, (IX+2)               ; Load size of prev block into DE 
1630			      ld    H, (IX+3) 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    E, (HL) 
1630			      inc   HL 
1630			      ld    D, (HL) 
1630			 
1630			      pop   HL                      ; Add sizes of both blocks 
1630			      add   HL, DE 
1630			      ex    DE, HL 
1630			 
1630			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1630			      ld    H, (IX+3) 
1630			      inc   HL 
1630			      inc   HL 
1630			      ld    (HL), E 
1630			      inc   HL 
1630			      ld    (HL), D 
1630			 
1630			free_done: 
1630			      ld    HL, 4                   ; Clean up stack frame 
1630			      add   HL, SP 
1630			      ld    SP, HL 
1630			 
1630			free_early_exit: 
1630			      pop   IX 
1630			      pop   DE 
1630			      pop   BC 
1630			 
1630			      ret 
1630			 
1630			 
1630			;      .org 0x8000 
1630			; 
1630			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1630			 ;                 .dw   0 
1630			 
1630			endif 
1630			 
1630			 
1630			if MALLOC_4 
1630			 
1630			; My memory allocation code. Very very simple.... 
1630			; allocate space under 250 chars 
1630			 
1630			heap_init: 
1630				; init start of heap as zero 
1630				;  
1630			 
1630				ld hl, heap_start 
1630				ld a, 0 
1630				ld (hl), a      ; empty block 
1630				inc hl 
1630				ld a, 0 
1630				ld (hl), a      ; length of block 
1630				; write end of list 
1630				inc hl 
1630				ld a,(hl) 
1630				inc hl 
1630				ld a,(hl) 
1630				 
1630			 
1630				; init some malloc vars 
1630			 
1630				ld hl, 0 
1630				ld (free_list), hl       ; store last malloc location 
1630			 
1630				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1630				ld a, 0 
1630				ld (hl), a 
1630			 
1630			 
1630				ld hl, heap_start 
1630				;  
1630				  
1630				ret 
1630			 
1630			 
1630			;    free block marker 
1630			;    requested size  
1630			;    pointer to next block 
1630			;    .... 
1630			;    next block marker 
1630			 
1630			 
1630			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1630			; 
1630			 
1630			 
1630			malloc:  
1630				push de 
1630				push bc 
1630				push af 
1630			 
1630				; hl space required 
1630				 
1630				ld c, l    ; hold space   (TODO only a max of 255) 
1630			 
1630			;	inc c     ; TODO BUG need to fix memory leak on push str 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			;	inc c 
1630			 
1630			 
1630			 
1630				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1630			 
1630				ld a, (free_list+3) 
1630				cp 0 
1630				jr z, .contheap 
1630			 
1630				ld hl, (free_list)     ; get last alloc 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mrs" 
1630						CALLMONITOR 
1630					endif 
1630				jr .startalloc 
1630			 
1630			.contheap: 
1630				ld hl, heap_start 
1630			 
1630			.startalloc: 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mym" 
1630						CALLMONITOR 
1630					endif 
1630			.findblock: 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mmf" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630				ld a,(hl)  
1630				; if byte is zero then clear to use 
1630			 
1630				cp 0 
1630				jr z, .foundemptyblock 
1630			 
1630				; if byte is not clear 
1630				;     then byte is offset to next block 
1630			 
1630				inc hl 
1630				ld a, (hl) ; get size 
1630			.nextblock:	inc hl 
1630					ld e, (hl) 
1630					inc hl 
1630					ld d, (hl) 
1630					ex de, hl 
1630			;	inc hl  ; move past the store space 
1630			;	inc hl  ; move past zero index  
1630			 
1630				; TODO detect no more space 
1630			 
1630				push hl 
1630				ld de, heap_end 
1630				call cmp16 
1630				pop hl 
1630				jr nc, .nospace 
1630			 
1630				jr .findblock 
1630			 
1630			.nospace: ld hl, 0 
1630				jp .exit 
1630			 
1630			 
1630			.foundemptyblock:	 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mme" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			; TODO has block enough space if reusing??? 
1630			 
1630				;  
1630			 
1630			; see if this block has been previously used 
1630				inc hl 
1630				ld a, (hl) 
1630				dec hl 
1630				cp 0 
1630				jr z, .newblock 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "meR" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			; no reusing previously allocated block 
1630			 
1630			; is it smaller than previously used? 
1630				 
1630				inc hl    ; move to size 
1630				ld a, c 
1630				sub (hl)        ; we want c < (hl) 
1630				dec hl    ; move back to marker 
1630			        jr z, .findblock 
1630			 
1630				; update with the new size which should be lower 
1630			 
1630			        ;inc  hl   ; negate next move. move back to size  
1630			 
1630			.newblock: 
1630				; need to be at marker here 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "meN" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			 
1630				ld a, c 
1630			 
1630				ld (free_list+3), a	 ; flag resume from last malloc  
1630				ld (free_list), hl    ; save out last location 
1630			 
1630			 
1630				;inc a     ; space for length byte 
1630				ld (hl), a     ; save block in use marker 
1630			 
1630				inc hl   ; move to space marker 
1630				ld (hl), a    ; save new space 
1630			 
1630				inc hl   ; move to start of allocated area 
1630				 
1630			;	push hl     ; save where we are - 1  
1630			 
1630			;	inc hl  ; move past zero index  
1630				; skip space to set down new marker 
1630			 
1630				; provide some extra space for now 
1630			 
1630				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1630				inc a 
1630				inc a 
1630			 
1630				push hl   ; save where we are in the node block 
1630			 
1630				call addatohl 
1630			 
1630				; write linked list point 
1630			 
1630				pop de     ; get our node position 
1630				ex de, hl 
1630			 
1630				ld (hl), e 
1630				inc hl 
1630				ld (hl), d 
1630			 
1630				inc hl 
1630			 
1630				; now at start of allocated data so save pointer 
1630			 
1630				push hl 
1630			 
1630				; jump to position of next node and setup empty header in DE 
1630			 
1630				ex de, hl 
1630			 
1630			;	inc hl ; move past end of block 
1630			 
1630				ld a, 0 
1630				ld (hl), a   ; empty marker 
1630				inc hl 
1630				ld (hl), a   ; size 
1630				inc hl  
1630				ld (hl), a   ; ptr 
1630				inc hl 
1630				ld (hl), a   ; ptr 
1630			 
1630			 
1630				pop hl 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "mmr" 
1630						CALLMONITOR 
1630					endif 
1630			 
1630			.exit: 
1630				pop af 
1630				pop bc 
1630				pop de  
1630				ret 
1630			 
1630			 
1630			 
1630			 
1630			free:  
1630				push hl 
1630				push af 
1630				; get address in hl 
1630			 
1630					if DEBUG_FORTH_MALLOC_INT 
1630						DMARK "fre" 
1630						CALLMONITOR 
1630					endif 
1630				; data is at hl - move to block count 
1630				dec hl 
1630				dec hl    ; get past pointer 
1630				dec hl 
1630			 
1630				ld a, (hl)    ; need this for a validation check 
1630			 
1630				dec hl    ; move to block marker 
1630			 
1630				; now check that the block count and block marker are the same  
1630			        ; this checks that we are on a malloc node and not random memory 
1630			        ; OK a faint chance this could be a problem but rare - famous last words! 
1630			 
1630				ld c, a 
1630				ld a, (hl)    
1630			 
1630				cp c 
1630				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1630			 
1630				; yes good chance we are on a malloc node 
1630			 
1630				ld a, 0      
1630				ld (hl), a   ; mark as free 
1630			 
1630				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1630			 
1630			.freeignore:  
1630			 
1630				pop af 
1630				pop hl 
1630			 
1630				ret 
1630			 
1630			 
1630			 
1630			endif 
1630			 
1630			; eof 
# End of file firmware_memory.asm
1630			  
1630			; device C  
1630			; Now handled by SPI  
1630			;if SOUND_ENABLE  
1630			;	include "firmware_sound.asm"  
1630			;endif  
1630			  
1630			include "firmware_diags.asm"  
1630			; Hardware diags menu 
1630			 
1630			 
1630			config: 
1630			 
1630 3e 00			ld a, 0 
1632 21 5b 16			ld hl, .configmn 
1635 cd cd 0d			call menu 
1638			 
1638 fe 00			cp 0 
163a c8				ret z 
163b			 
163b			;	cp 1 
163b			;	call z, .savetostore 
163b			 
163b fe 01			cp 1 
163d			if STARTUP_V1 
163d				call z, .selautoload 
163d			endif 
163d			 
163d			if STARTUP_V2 
163d cc 69 16			call z, .enautoload 
1640			endif 
1640 fe 02			cp 2 
1642 cc 80 16			call z, .disautoload 
1645			;	cp 3 
1645			;	call z, .selbank 
1645 fe 03			cp 3 
1647 cc fa 18			call z, .debug_tog 
164a fe 04			cp 4 
164c cc 48 1a			call z, .bpsgo 
164f fe 05			cp 5 
1651 cc 23 19			call z, hardware_diags 
1654			if STARTUP_V2 
1654 fe 06			cp 6 
1656 cc ac 16			call z, create_startup 
1659			endif 
1659 18 d5			jr config 
165b			 
165b			.configmn: 
165b			;	dw prom_c3 
165b 36 1c			dw prom_c2 
165d 4c 1c			dw prom_c2a 
165f			;	dw prom_c2b 
165f			;	dw prom_c4 
165f bb 1c			dw prom_m4 
1661 d6 1c			dw prom_m4b 
1663 de 1c			dw prom_c1 
1665			if STARTUP_V2 
1665 ed 1c			dw prom_c9 
1667			endif 
1667 00 00			dw 0 
1669				 
1669			 
1669			if STARTUP_V2 
1669			.enautoload: 
1669				if STORAGE_SE 
1669 3e fe			ld a, $fe      ; bit 0 clear 
166b 32 5d fa			ld (spi_device), a 
166e			 
166e cd 17 05			call storage_get_block_0 
1671			 
1671 3e 01			ld a, 1 
1673 32 98 fa			ld (store_page+STORE_0_AUTOFILE), a 
1676			 
1676 21 00 00				ld hl, 0 
1679 11 77 fa				ld de, store_page 
167c cd cb 04			call storage_write_block	 ; save update 
167f				else 
167f			 
167f				ld hl, prom_notav 
167f				ld de, prom_empty 
167f				call info_panel 
167f				endif 
167f			 
167f			 
167f c9				ret 
1680			endif 
1680			 
1680			.disautoload: 
1680				if STORAGE_SE 
1680 3e fe			ld a, $fe      ; bit 0 clear 
1682 32 5d fa			ld (spi_device), a 
1685			 
1685 cd 17 05			call storage_get_block_0 
1688			 
1688 3e 00			ld a, 0 
168a 32 98 fa			ld (store_page+STORE_0_AUTOFILE), a 
168d			 
168d 21 00 00				ld hl, 0 
1690 11 77 fa				ld de, store_page 
1693 cd cb 04			call storage_write_block	 ; save update 
1696				else 
1696			 
1696				ld hl, prom_notav 
1696				ld de, prom_empty 
1696				call info_panel 
1696				endif 
1696			 
1696			 
1696 c9				ret 
1697			 
1697			if STARTUP_V1 
1697			 
1697			; Select auto start 
1697			 
1697			.selautoload: 
1697			 
1697				 
1697				if STORAGE_SE 
1697			 
1697					call config_dir 
1697				        ld hl, scratch 
1697					ld a, 0 
1697					call menu 
1697			 
1697					cp 0 
1697					ret z 
1697			 
1697					dec a 
1697			 
1697			 
1697					; locate menu option 
1697			 
1697					ld hl, scratch 
1697					call table_lookup 
1697			 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "ALl" 
1697						CALLMONITOR 
1697					endif 
1697					; with the pointer to the menu it, the byte following the zero term is the file id 
1697			 
1697					ld a, 0 
1697					ld bc, 50   ; max of bytes to look at 
1697					cpir  
1697			 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "ALb" 
1697						CALLMONITOR 
1697					endif 
1697					;inc hl 
1697			 
1697					ld a, (hl)   ; file id 
1697					 
1697				        ; save bank and file ids 
1697			 
1697					push af 
1697			 
1697			; TODO need to save to block 0 on bank 1	 
1697			 
1697					call storage_get_block_0 
1697			 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "AL0" 
1697						CALLMONITOR 
1697					endif 
1697					pop af 
1697			 
1697					ld (store_page+STORE_0_FILERUN),a 
1697					 
1697					; save bank id 
1697			 
1697					ld a,(spi_device) 
1697					ld (store_page+STORE_0_BANKRUN),a 
1697			 
1697					; enable auto run of store file 
1697			 
1697					ld a, 1 
1697					ld (store_page+STORE_0_AUTOFILE),a 
1697			 
1697					; save buffer 
1697			 
1697					ld hl, 0 
1697					ld de, store_page 
1697					if DEBUG_FORTH_WORDS 
1697						DMARK "ALw" 
1697						CALLMONITOR 
1697					endif 
1697				call storage_write_block	 ; save update 
1697			  
1697			 
1697			 
1697			 
1697					ld hl, scratch 
1697					call config_fdir 
1697			 
1697				else 
1697			 
1697				ld hl, prom_notav 
1697				ld de, prom_empty 
1697				call info_panel 
1697			 
1697				endif 
1697				ret 
1697			endif 
1697			 
1697			 
1697			; Select storage bank 
1697			 
1697			.selbank: 
1697			 
1697			;	if STORAGE_SE 
1697			;	else 
1697			 
1697 21 02 1d			ld hl, prom_notav 
169a 11 18 1d			ld de, prom_empty 
169d cd 2d 0d			call info_panel 
16a0			;	endif 
16a0				 
16a0 c9				ret 
16a1			 
16a1			if STORAGE_SE 
16a1			 
16a1			.config_ldir:   
16a1				; Load storage bank labels into menu array 
16a1			 
16a1				 
16a1			 
16a1			 
16a1 c9				ret 
16a2			 
16a2			 
16a2			endif 
16a2			 
16a2			 
16a2			; Save user words to storage 
16a2			 
16a2			.savetostore: 
16a2			 
16a2			;	if STORAGE_SE 
16a2			; 
16a2			;		call config_dir 
16a2			;	        ld hl, scratch 
16a2			;		ld a, 0 
16a2			;		call menu 
16a2			;		 
16a2			;		ld hl, scratch 
16a2			;		call config_fdir 
16a2			; 
16a2			;	else 
16a2			 
16a2 21 02 1d			ld hl, prom_notav 
16a5 11 18 1d			ld de, prom_empty 
16a8 cd 2d 0d			call info_panel 
16ab			 
16ab			;	endif 
16ab			 
16ab c9				ret 
16ac			 
16ac			if STARTUP_V2 
16ac			 
16ac			create_startup: 
16ac			 
16ac 3e 00			ld a, 0 
16ae 21 21 18			ld hl, .crstart 
16b1 cd cd 0d			call menu 
16b4			 
16b4 fe 00			cp 0 
16b6 c8				ret z 
16b7			 
16b7 fe 01			cp 1 
16b9 cc e6 16			call z, .genlsword 
16bc fe 02			cp 2 
16be cc f0 16			call z, .genedword 
16c1			 
16c1 fe 03			cp 3 
16c3 cc fa 16			call z, .gendemword 
16c6			 
16c6 fe 04			cp 4 
16c8 cc 04 17			call z, .genutlword 
16cb fe 05			cp 5 
16cd cc 0e 17			call z, .genspiword 
16d0 fe 06			cp 6 
16d2 cc 18 17			call z, .genkeyword 
16d5 fe 07			cp 7 
16d7 cc dc 16			call z, .gensoundword 
16da 18 d0			jr create_startup 
16dc			 
16dc			.gensoundword: 
16dc 21 a6 1c			ld hl, crs_sound 
16df 11 65 17			ld de, .soundworddef 
16e2 cd 22 17			call .genfile 
16e5 c9				ret 
16e6			.genlsword: 
16e6 21 63 1c			ld hl, crs_s1 
16e9 11 8d 17			ld de, .lsworddef 
16ec cd 22 17			call .genfile 
16ef c9				ret 
16f0			 
16f0			.genedword: 
16f0 11 91 17			ld de, .edworddef 
16f3 21 6c 1c			ld hl, crs_s2 
16f6 cd 22 17			call .genfile 
16f9 c9				ret 
16fa			 
16fa			.gendemword: 
16fa 11 99 17			ld de, .demoworddef 
16fd 21 75 1c			ld hl, crs_s3 
1700 cd 22 17			call .genfile 
1703 c9				ret 
1704			 
1704			.genutlword: 
1704 21 84 1c			ld hl, crs_s4 
1707 11 79 17			ld de, .utilwordef 
170a cd 22 17			call .genfile 
170d c9				ret 
170e			.genspiword: 
170e 21 8b 1c			ld hl, crs_s5 
1711 11 df 17			ld de, .spiworddef 
1714 cd 22 17			call .genfile 
1717 c9				ret 
1718			.genkeyword: 
1718 21 97 1c			ld hl, crs_s6 
171b 11 f5 17			ld de, .keyworddef 
171e cd 22 17			call .genfile 
1721 c9				ret 
1722			 
1722			; hl - points to file name 
1722			; de - points to strings to add to file 
1722			 
1722			.genfile: 
1722 e5				push hl 
1723 d5				push de 
1724			 
1724 cd 9c 0d			call clear_display 
1727 3e 00			ld a, display_row_1 
1729 11 54 17			ld de, .genfiletxt 
172c cd af 0d			call str_at_display 
172f cd bf 0d			call update_display 
1732			 
1732 d1				pop de 
1733 e1				pop hl 
1734			 
1734			 
1734 d5				push de 
1735 cd 69 08			call storage_create 
1738				; id in hl 
1738 d1				pop de   ; table of strings to add 
1739			 
1739			.genloop: 
1739			 
1739 e5				push hl ; save id for next time around 
173a d5				push de ; save de for next time around 
173b			 
173b eb				ex de, hl 
173c cd 34 24			call loadwordinhl 
173f eb				ex de, hl 
1740			 
1740				; need hl to be the id 
1740				; need de to be the string ptr 
1740				 
1740 cd 56 0b			call storage_append 
1743			 
1743 d1				pop de 
1744 e1				pop hl 
1745			 
1745 13				inc de 
1746 13				inc de 
1747			 
1747 1a				ld a,(de) 
1748 fe 00			cp 0 
174a 20 ed			jr nz, .genloop 
174c 13				inc de 
174d 1a				ld a, (de) 
174e 1b				dec de 
174f fe 00			cp 0 
1751 20 e6			jr nz, .genloop	 
1753			 
1753 c9				ret 
1754			 
1754 .. 00		.genfiletxt:  db "Creating file...",0 
1765			 
1765			.soundworddef: 
1765 12 6a			dw sound1 
1767 36 6a			dw sound2 
1769 66 6a			dw sound3 
176b 8b 6a			dw sound4 
176d 98 6a			dw sound5 
176f a5 6a			dw sound6 
1771 b2 6a			dw sound7 
1773 bf 6a			dw sound8 
1775 d7 6a			dw sound9 
1777 00 00			dw 0 
1779			 
1779			.utilwordef: 
1779 63 63			dw strncpy 
177b 3e 63			dw type 
177d 0a 63			dw clrstack 
177f c3 62			dw longread 
1781 c4 63			dw start1 
1783 d4 63			dw start2 
1785 e5 63			dw start3b 
1787 60 64			dw start3c 
1789 c0 64			dw list 
178b 00 00			dw 0 
178d			 
178d			.lsworddef: 
178d e5 63			dw start3b 
178f 00 00			dw 0 
1791			 
1791			.edworddef: 
1791 4c 5f			dw edit1 
1793 6d 5f			dw edit2 
1795 a2 5f			dw edit3 
1797 00 00			dw 0 
1799			 
1799			.demoworddef: 
1799 08 69			dw test5 
179b 40 69			dw test6 
179d 78 69			dw test7 
179f 8c 69			dw test8 
17a1 b8 69			dw test9 
17a3 ce 69			dw test10 
17a5 ee 6a			dw game1 
17a7 ff 6a			dw game1a 
17a9 61 6b			dw game1b 
17ab 96 6b			dw game1c 
17ad cc 6b			dw game1d 
17af fd 6b			dw game1s 
17b1 11 6c			dw game1t 
17b3 26 6c			dw game1f 
17b5 5a 6c			dw game1z 
17b7 9e 6c			dw game1zz 
17b9 07 6d			dw ssv2 
17bb 3d 6d			dw ssv3 
17bd 59 6d			dw ssv4 
17bf 75 6d			dw ssv5 
17c1 8e 6d			dw ssv1 
17c3 d6 6d			dw ssv1cpm	 
17c5 2d 6e			dw game2b 
17c7 9b 6e			dw game2bf 
17c9 e5 6e			dw game2mba 
17cb 7b 6f			dw game2mbas	 
17cd a0 6f			dw game2mbht 
17cf af 6f			dw game2mbms 
17d1 bd 6f			dw game2mb 
17d3 3a 70			dw game3w 
17d5 68 70			dw game3p 
17d7 86 70			dw game3sc 
17d9 b7 70			dw game3vsi 
17db e3 70			dw game3vs 
17dd 00 00			dw 0 
17df			 
17df			 
17df			.spiworddef: 
17df			 
17df da 5f		    dw spi1 
17e1 33 60		    dw spi2 
17e3 c1 60		    dw spi3 
17e5 69 60		    dw spi4 
17e7 94 60		    dw spi5 
17e9 27 61		    dw spi6 
17eb 7c 61		    dw spi7 
17ed			 
17ed d4 61		    dw spi8 
17ef f3 61		    dw spi9 
17f1 4b 62		    dw spi10 
17f3 00 00		    dw 0 
17f5			 
17f5			.keyworddef: 
17f5			 
17f5 22 71			dw keyup 
17f7 30 71			dw keydown 
17f9 40 71			dw keyleft 
17fb 50 71			dw keyright 
17fd 61 71			dw 	keyf1 
17ff 6f 71			dw keyf2 
1801 7d 71			dw keyf3 
1803 8b 71			dw keyf4 
1805 99 71			dw keyf5 
1807 a7 71			dw keyf6 
1809 b5 71			dw keyf7 
180b c3 71			dw keyf8 
180d d1 71			dw keyf9 
180f df 71			dw keyf10 
1811 ee 71			dw keyf11 
1813 fd 71			dw keyf12 
1815 0c 72			dw keytab 
1817 1b 72			dw keycr 
1819 29 72			dw keyhome 
181b 39 72			dw keyend 
181d 48 72			dw keybs 
181f 00 00			dw 0 
1821			 
1821			.crstart: 
1821 63 1c			dw crs_s1 
1823 6c 1c			dw crs_s2 
1825 75 1c			dw crs_s3 
1827 84 1c			dw crs_s4 
1829 8b 1c			dw crs_s5 
182b 97 1c			dw crs_s6 
182d a6 1c			dw crs_sound 
182f 00 00			dw 0 
1831			 
1831			endif 
1831			 
1831			 
1831			if STORAGE_SE 
1831			 
1831			config_fdir: 
1831				; using the scratch dir go through and release the memory allocated for each string 
1831				 
1831 21 be f1			ld hl, scratch 
1834 5e			.cfdir:	ld e,(hl) 
1835 23				inc hl 
1836 56				ld d,(hl) 
1837 23				inc hl 
1838			 
1838 eb				ex de, hl 
1839 cd f9 0f			call ishlzero 
183c c8				ret z     ; return on null pointer 
183d cd 61 15			call free 
1840 eb				ex de, hl 
1841 18 f1			jr .cfdir 
1843			 
1843			 
1843 c9				ret 
1844			 
1844			 
1844			config_dir: 
1844			 
1844				; for the config menus that need to build a directory of storage call this routine 
1844				; it will construct a menu in scratch to pass to menu 
1844			 
1844				; open storage device 
1844			 
1844				; execute DIR to build a list of files and their ids into scratch in menu format 
1844				; once the menu has finished then will need to call config_fdir to release the strings 
1844				 
1844				; c = number items 
1844			 
1844				 
1844 cd 17 05			call storage_get_block_0 
1847			 
1847 21 77 fa			ld hl, store_page     ; get current id count 
184a 46				ld b, (hl) 
184b 0e 00			ld c, 0    ; count of files   
184d			 
184d			 
184d 21 be f1			ld hl, scratch 
1850 22 6e fa			ld (store_tmp2), hl    ; location to poke strings 
1853			 
1853				; check for empty drive 
1853			 
1853 3e 00			ld a, 0 
1855 b8				cp b 
1856 ca f0 18			jp z, .dirdone 
1859			 
1859				 
1859					if DEBUG_FORTH_WORDS 
1859						DMARK "Cdc" 
1859 f5				push af  
185a 3a 6e 18			ld a, (.dmark)  
185d 32 68 fe			ld (debug_mark),a  
1860 3a 6f 18			ld a, (.dmark+1)  
1863 32 69 fe			ld (debug_mark+1),a  
1866 3a 70 18			ld a, (.dmark+2)  
1869 32 6a fe			ld (debug_mark+2),a  
186c 18 03			jr .pastdmark  
186e ..			.dmark: db "Cdc"  
1871 f1			.pastdmark: pop af  
1872			endm  
# End of macro DMARK
1872						CALLMONITOR 
1872 cd 6c fe			call debug_vector  
1875				endm  
# End of macro CALLMONITOR
1875					endif 
1875			 
1875			 
1875			.diritem:	 
1875 c5				push bc 
1876				; for each of the current ids do a search for them and if found push to stack 
1876			 
1876 21 40 00				ld hl, STORE_BLOCK_PHY 
1879 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
187b 58					ld e,b 
187c			 
187c cd 99 07				call storage_findnextid 
187f			 
187f			 
187f					; if found hl will be non zero 
187f			 
187f cd f9 0f				call ishlzero 
1882 28 69				jr z, .dirnotfound 
1884			 
1884					; increase count 
1884			 
1884 c1					pop bc	 
1885 0c					inc c 
1886 c5					push bc 
1887					 
1887			 
1887					; get file header and push the file name 
1887			 
1887 11 77 fa				ld de, store_page 
188a cd 66 04				call storage_read_block 
188d			 
188d					; push file id to stack 
188d				 
188d 3a 77 fa				ld a, (store_page) 
1890 26 00				ld h, 0 
1892 6f					ld l, a 
1893			 
1893					;call forth_push_numhl 
1893					; TODO store id 
1893			 
1893 e5					push hl 
1894			 
1894					; push extent count to stack  
1894				 
1894 21 7a fa				ld hl, store_page+3 
1897			 
1897					; get file name length 
1897			 
1897 cd 2e 14				call strlenz   
189a			 
189a 23					inc hl   ; cover zero term 
189b 23					inc hl  ; stick the id at the end of the area 
189c			 
189c e5					push hl 
189d c1					pop bc    ; move length to bc 
189e			 
189e cd 97 14				call malloc 
18a1			 
18a1					; TODO save malloc area to scratch 
18a1			 
18a1 eb					ex de, hl 
18a2 2a 6e fa				ld hl, (store_tmp2) 
18a5 73					ld (hl), e 
18a6 23					inc hl 
18a7 72					ld (hl), d 
18a8 23					inc hl 
18a9 22 6e fa				ld (store_tmp2), hl 
18ac			 
18ac					 
18ac			 
18ac					;pop hl   ; get source 
18ac			;		ex de, hl    ; swap aronund	 
18ac			 
18ac 21 7a fa				ld hl, store_page+3 
18af					if DEBUG_FORTH_WORDS 
18af						DMARK "CFd" 
18af f5				push af  
18b0 3a c4 18			ld a, (.dmark)  
18b3 32 68 fe			ld (debug_mark),a  
18b6 3a c5 18			ld a, (.dmark+1)  
18b9 32 69 fe			ld (debug_mark+1),a  
18bc 3a c6 18			ld a, (.dmark+2)  
18bf 32 6a fe			ld (debug_mark+2),a  
18c2 18 03			jr .pastdmark  
18c4 ..			.dmark: db "CFd"  
18c7 f1			.pastdmark: pop af  
18c8			endm  
# End of macro DMARK
18c8						CALLMONITOR 
18c8 cd 6c fe			call debug_vector  
18cb				endm  
# End of macro CALLMONITOR
18cb					endif 
18cb ed b0				ldir 
18cd			 
18cd					; de is past string, move back one and store id 
18cd					 
18cd 1b					dec de 
18ce			 
18ce					; store file id 
18ce			 
18ce e1					pop hl 
18cf eb					ex de,hl 
18d0 73					ld (hl), e 
18d1			 
18d1					if DEBUG_FORTH_WORDS 
18d1						DMARK "Cdi" 
18d1 f5				push af  
18d2 3a e6 18			ld a, (.dmark)  
18d5 32 68 fe			ld (debug_mark),a  
18d8 3a e7 18			ld a, (.dmark+1)  
18db 32 69 fe			ld (debug_mark+1),a  
18de 3a e8 18			ld a, (.dmark+2)  
18e1 32 6a fe			ld (debug_mark+2),a  
18e4 18 03			jr .pastdmark  
18e6 ..			.dmark: db "Cdi"  
18e9 f1			.pastdmark: pop af  
18ea			endm  
# End of macro DMARK
18ea						CALLMONITOR 
18ea cd 6c fe			call debug_vector  
18ed				endm  
# End of macro CALLMONITOR
18ed					endif 
18ed					 
18ed			.dirnotfound: 
18ed c1					pop bc     
18ee 10 85				djnz .diritem 
18f0				 
18f0			.dirdone:	 
18f0			 
18f0 3e 00				ld a, 0 
18f2 2a 6e fa				ld hl, (store_tmp2) 
18f5 77					ld (hl), a 
18f6 23					inc hl 
18f7 77					ld (hl), a 
18f8 23					inc hl 
18f9					; push a count of the dir items found 
18f9			 
18f9			;		ld h, 0 
18f9			;		ld l, c 
18f9			 
18f9 c9				ret 
18fa			 
18fa			endif 
18fa			 
18fa			 
18fa			; Settings 
18fa			; Run  
18fa			 
18fa			 
18fa			 
18fa			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
18fa			;;hd_menu2:   db "        2: Editor",0   
18fa			;hd_menu2:   db "        2: Editor       6: Menu",0   
18fa			;hd_menu3:   db "        3: Storage",0 
18fa			;hd_menu4:   db "0=quit  4: Debug",0 
18fa			;hd_don:     db "ON",0 
18fa			;hd_doff:     db "OFF",0 
18fa			; 
18fa			; 
18fa			; 
18fa			;hardware_diags_old:       
18fa			; 
18fa			;.diagmenu: 
18fa			;	call clear_display 
18fa			;	ld a, display_row_1 
18fa			;	ld de, hd_menu1 
18fa			;	call str_at_display 
18fa			; 
18fa			;	ld a, display_row_2 
18fa			;	ld de, hd_menu2 
18fa			;	call str_at_display 
18fa			; 
18fa			;	ld a, display_row_3 
18fa			;	ld de, hd_menu3 
18fa			;	call str_at_display 
18fa			; 
18fa			;	ld a,  display_row_4 
18fa			;	ld de, hd_menu4 
18fa			;	call str_at_display 
18fa			; 
18fa			;	; display debug state 
18fa			; 
18fa			;	ld de, hd_don 
18fa			;	ld a, (os_view_disable) 
18fa			;	cp 0 
18fa			;	jr z, .distog 
18fa			;	ld de, hd_doff 
18fa			;.distog: ld a, display_row_4+17 
18fa			;	call str_at_display 
18fa			; 
18fa			;	call update_display 
18fa			; 
18fa			;	call cin_wait 
18fa			; 
18fa			; 
18fa			; 
18fa			;	cp '4' 
18fa			;	jr nz, .diagn1 
18fa			; 
18fa			;	; debug toggle 
18fa			; 
18fa			;	ld a, (os_view_disable) 
18fa			;	ld b, '*' 
18fa			;	cp 0 
18fa			;	jr z, .debtog 
18fa			;	ld b, 0 
18fa			;.debtog:	 
18fa			;	ld a,b 
18fa			;	ld (os_view_disable),a 
18fa			; 
18fa			;.diagn1: cp '0' 
18fa			;	 ret z 
18fa			; 
18fa			;;	cp '1' 
18fa			;;       jp z, matrix	 
18fa			;;   TODO keyboard matrix test 
18fa			; 
18fa			;	cp '2' 
18fa			;	jp z, .diagedit 
18fa			; 
18fa			;;	cp '6' 
18fa			;;	jp z, .menutest 
18fa			;;if ENABLE_BASIC 
18fa			;;	cp '6' 
18fa			;;	jp z, basic 
18fa			;;endif 
18fa			 ; 
18fa			;	jp .diagmenu 
18fa			; 
18fa			; 
18fa			;	ret 
18fa			 
18fa			 
18fa			.debug_tog: 
18fa 21 44 19			ld hl, .menudebug 
18fd				 
18fd			;	ld a, (os_view_disable) 
18fd			;	cp '*' 
18fd 3a 6c fe			ld a,(debug_vector) 
1900 fe c9			cp $C9   ; RET 
1902 20 04			jr nz,.tdon  
1904 3e 01			ld a, 1 
1906 18 02			jr .tog1 
1908 3e 00		.tdon: ld a, 0 
190a			 
190a			.tog1: 
190a cd cd 0d			call menu 
190d fe 00			cp 0 
190f c8				ret z 
1910 fe 01			cp 1    ; disable debug 
1912 28 04			jr z, .dtog0 
1914 3e 2a			ld a, '*' 
1916 18 05			jr .dtogset 
1918			.dtog0:  
1918				;ld a, 0 
1918 cd 36 1a			call bp_on 
191b 18 dd			jr .debug_tog 
191d			.dtogset:  
191d				; ld (os_view_disable), a 
191d cd 42 1a			call bp_off 
1920 c3 fa 18			jp .debug_tog 
1923			 
1923			 
1923			hardware_diags:       
1923			 
1923			.diagm: 
1923 21 36 19			ld hl, .menuitems 
1926 3e 00			ld a, 0 
1928 cd cd 0d			call menu 
192b			 
192b fe 00		         cp 0 
192d c8				 ret z 
192e			 
192e fe 02			cp 2 
1930 ca 8f 19			jp z, .diagedit 
1933			 
1933			;	cp '6' 
1933			;	jp z, .menutest 
1933			;if ENABLE_BASIC 
1933			;	cp '6' 
1933			;	jp z, basic 
1933			;endif 
1933			  
1933 c3 23 19			jp .diagm 
1936			 
1936				 
1936 4a 19		.menuitems:   	dw .m1 
1938 55 19				dw .m2 
193a 5c 19				dw .m3 
193c 64 19				dw .m5 
193e 6a 19				dw .m5a 
1940 73 19				dw .m5b 
1942 00 00				dw 0 
1944			 
1944			.menudebug: 
1944 7c 19				dw .m6 
1946 85 19				dw .m7 
1948 00 00				dw 0 
194a			 
194a .. 00		.m1:   db "Key Matrix",0 
1955 .. 00		.m2:   db "Editor",0 
195c .. 00		.m3:   db "Storage",0 
1964 .. 00		.m5:   db "Sound",0 
196a .. 00		.m5a:  db "RAM Test",0 
1973 .. 00		.m5b:  db "LCD Test",0 
197c			 
197c .. 00		.m6:   db "Debug ON",0 
1985 .. 00		.m7:   db "Debug OFF",0 
198f			 
198f			; debug editor 
198f			 
198f			.diagedit: 
198f			 
198f 21 be f1			ld hl, scratch 
1992			;	ld bc, 250 
1992			;	ldir 
1992				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1992 3e 00			ld a, 0 
1994 77				ld (hl), a 
1995 23				inc hl 
1996 77				ld (hl), a 
1997 23				inc hl 
1998 77				ld (hl), a 
1999			 
1999 cd 9c 0d		        call clear_display 
199c cd bf 0d			call update_display 
199f				;ld a, 1 
199f				;ld (hardware_diag), a 
199f			.diloop: 
199f 3e 00			ld a, display_row_1 
19a1 0e 00			ld c, 0 
19a3 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
19a5 1e 28			ld e, 40 
19a7			 
19a7 21 be f1			ld hl, scratch	 
19aa cd fd 0f			call input_str 
19ad			 
19ad 3e 28			ld a, display_row_2 
19af 11 be f1			ld de, scratch 
19b2 cd af 0d			call str_at_display 
19b5 cd bf 0d			call update_display 
19b8			 
19b8 c3 9f 19			jp .diloop 
19bb			 
19bb			 
19bb			; pass word in hl 
19bb			; a has display location 
19bb			display_word_at: 
19bb f5				push af 
19bc e5				push hl 
19bd 7c				ld a,h 
19be 21 c3 f4			ld hl, os_word_scratch 
19c1 cd d1 12			call hexout 
19c4 e1				pop hl 
19c5 7d				ld a,l 
19c6 21 c5 f4			ld hl, os_word_scratch+2 
19c9 cd d1 12			call hexout 
19cc 21 c7 f4			ld hl, os_word_scratch+4 
19cf 3e 00			ld a,0 
19d1 77				ld (hl),a 
19d2 11 c3 f4			ld de,os_word_scratch 
19d5 f1				pop af 
19d6 cd af 0d				call str_at_display 
19d9 c9				ret 
19da			 
19da			display_ptr_state: 
19da			 
19da				; to restore afterwards 
19da			 
19da d5				push de 
19db c5				push bc 
19dc e5				push hl 
19dd f5				push af 
19de			 
19de				; for use in here 
19de			 
19de			;	push bc 
19de			;	push de 
19de			;	push hl 
19de			;	push af 
19de			 
19de cd 9c 0d			call clear_display 
19e1			 
19e1 11 b9 1b			ld de, .ptrstate 
19e4 3e 00			ld a, display_row_1 
19e6 cd af 0d			call str_at_display 
19e9			 
19e9				; display debug step 
19e9			 
19e9			 
19e9 11 68 fe			ld de, debug_mark 
19ec 3e 26			ld a, display_row_1+display_cols-2 
19ee cd af 0d			call str_at_display 
19f1			 
19f1				; display a 
19f1 11 c3 1b			ld de, .ptrcliptr 
19f4 3e 28			ld a, display_row_2 
19f6 cd af 0d			call str_at_display 
19f9			 
19f9 f1				pop af 
19fa 2a 3d fa			ld hl,(cli_ptr) 
19fd 3e 30			ld a, display_row_2+8 
19ff cd bb 19			call display_word_at 
1a02			 
1a02			 
1a02				; display hl 
1a02			 
1a02			 
1a02 11 cb 1b			ld de, .ptrclioptr 
1a05 3e 32			ld a, display_row_2+10 
1a07 cd af 0d			call str_at_display 
1a0a			; 
1a0a			;	pop hl 
1a0a 3e 35			ld a, display_row_2+13 
1a0c 2a 3b fa			ld hl,(cli_origptr) 
1a0f cd bb 19			call display_word_at 
1a12			; 
1a12			;	 
1a12			;	; display de 
1a12			 
1a12			;	ld de, .regstatede 
1a12			;	ld a, display_row_3 
1a12			;	call str_at_display 
1a12			 
1a12			;	pop de 
1a12			;	ld h,d 
1a12			;	ld l, e 
1a12			;	ld a, display_row_3+3 
1a12			;	call display_word_at 
1a12			 
1a12			 
1a12				; display bc 
1a12			 
1a12			;	ld de, .regstatebc 
1a12			;	ld a, display_row_3+10 
1a12			;	call str_at_display 
1a12			 
1a12			;	pop bc 
1a12			;	ld h,b 
1a12			;	ld l, c 
1a12			;	ld a, display_row_3+13 
1a12			;	call display_word_at 
1a12			 
1a12			 
1a12				; display dsp 
1a12			 
1a12			;	ld de, .regstatedsp 
1a12			;	ld a, display_row_4 
1a12			;	call str_at_display 
1a12			 
1a12				 
1a12			;	ld hl,(cli_data_sp) 
1a12			;	ld a, display_row_4+4 
1a12			;	call display_word_at 
1a12			 
1a12				; display rsp 
1a12			 
1a12 11 fa 1b			ld de, .regstatersp 
1a15 3e 82			ld a, display_row_4+10 
1a17 cd af 0d			call str_at_display 
1a1a			 
1a1a				 
1a1a 2a ef f9			ld hl,(cli_ret_sp) 
1a1d 3e 86			ld a, display_row_4+14 
1a1f cd bb 19			call display_word_at 
1a22			 
1a22 cd bf 0d			call update_display 
1a25			 
1a25 cd df 0c			call delay1s 
1a28 cd df 0c			call delay1s 
1a2b cd df 0c			call delay1s 
1a2e			 
1a2e			 
1a2e cd 7d 20			call next_page_prompt 
1a31			 
1a31				; restore  
1a31			 
1a31 f1				pop af 
1a32 e1				pop hl 
1a33 c1				pop bc 
1a34 d1				pop de 
1a35 c9				ret 
1a36			 
1a36			; Update the break point vector so that the user can hook a new routine 
1a36			 
1a36			bp_on: 
1a36 3e c3			ld a, $c3    ; JP 
1a38 32 6c fe			ld (debug_vector), a 
1a3b 21 48 1a			ld hl, break_point_state 
1a3e 22 6d fe			ld (debug_vector+1), hl 
1a41 c9				ret 
1a42			 
1a42			bp_off: 
1a42 3e c9			ld a, $c9    ; RET 
1a44 32 6c fe			ld (debug_vector), a 
1a47 c9				ret 
1a48			 
1a48			 
1a48			break_point_state: 
1a48			;	push af 
1a48			; 
1a48			;	; see if disabled 
1a48			; 
1a48			;	ld a, (os_view_disable) 
1a48			;	cp '*' 
1a48			;	jr nz, .bpsgo 
1a48			;	pop af 
1a48			;	ret 
1a48			 
1a48			.bpsgo: 
1a48			;	pop af 
1a48 f5				push af 
1a49 22 ac f1			ld (os_view_hl), hl 
1a4c ed 53 aa f1		ld (os_view_de), de 
1a50 ed 43 a8 f1		ld (os_view_bc), bc 
1a54 e5				push hl 
1a55 6f				ld l, a 
1a56 26 00			ld h, 0 
1a58 22 ae f1			ld (os_view_af),hl 
1a5b			 
1a5b 21 ae fd				ld hl, display_fb0 
1a5e 22 c9 fb				ld (display_fb_active), hl 
1a61 e1				pop hl	 
1a62			 
1a62 3e 31			ld a, '1' 
1a64 fe 2a		.bps1:  cp '*' 
1a66 cc 42 1a			call z, bp_off 
1a69			;	jr nz, .bps1b 
1a69			;	ld (os_view_disable),a 
1a69 fe 31		.bps1b:  cp '1' 
1a6b 20 14			jr nz, .bps2 
1a6d			 
1a6d				; display reg 
1a6d			 
1a6d				 
1a6d			 
1a6d 3a ae f1			ld a, (os_view_af) 
1a70 2a ac f1			ld hl, (os_view_hl) 
1a73 ed 5b aa f1		ld de, (os_view_de) 
1a77 ed 4b a8 f1		ld bc, (os_view_bc) 
1a7b cd 15 1b			call display_reg_state 
1a7e c3 01 1b			jp .bpschk 
1a81			 
1a81 fe 32		.bps2:  cp '2' 
1a83 20 08			jr nz, .bps3 
1a85				 
1a85				; display hl 
1a85 2a ac f1			ld hl, (os_view_hl) 
1a88 cd ff 1b			call display_dump_at_hl 
1a8b			 
1a8b 18 74			jr .bpschk 
1a8d			 
1a8d fe 33		.bps3:  cp '3' 
1a8f 20 08			jr nz, .bps4 
1a91			 
1a91			        ; display de 
1a91 2a aa f1			ld hl, (os_view_de) 
1a94 cd ff 1b			call display_dump_at_hl 
1a97			 
1a97 18 68			jr .bpschk 
1a99 fe 34		.bps4:  cp '4' 
1a9b 20 08			jr nz, .bps5 
1a9d			 
1a9d			        ; display bc 
1a9d 2a a8 f1			ld hl, (os_view_bc) 
1aa0 cd ff 1b			call display_dump_at_hl 
1aa3			 
1aa3 18 5c			jr .bpschk 
1aa5 fe 35		.bps5:  cp '5' 
1aa7 20 08		        jr nz, .bps7 
1aa9			 
1aa9				; display cur ptr 
1aa9 2a 3d fa			ld hl, (cli_ptr) 
1aac cd ff 1b			call display_dump_at_hl 
1aaf			 
1aaf 18 50			jr .bpschk 
1ab1 fe 36		.bps7:  cp '6' 
1ab3 20 08			jr nz, .bps8b 
1ab5				 
1ab5				; display cur orig ptr 
1ab5 2a 3b fa			ld hl, (cli_origptr) 
1ab8 cd ff 1b			call display_dump_at_hl 
1abb 18 44			jr .bpschk 
1abd fe 37		.bps8b:  cp '7' 
1abf 20 08			jr nz, .bps9 
1ac1				 
1ac1				; display dsp 
1ac1 2a eb f9			ld hl, (cli_data_sp) 
1ac4 cd ff 1b			call display_dump_at_hl 
1ac7			 
1ac7 18 38			jr .bpschk 
1ac9 fe 39		.bps9:  cp '9' 
1acb 20 05			jr nz, .bps8c 
1acd				 
1acd				; display SP 
1acd			;	ld hl, sp 
1acd cd ff 1b			call display_dump_at_hl 
1ad0			 
1ad0 18 2f			jr .bpschk 
1ad2 fe 38		.bps8c:  cp '8' 
1ad4 20 08			jr nz, .bps8d 
1ad6				 
1ad6				; display rsp 
1ad6 2a ef f9			ld hl, (cli_ret_sp) 
1ad9 cd ff 1b			call display_dump_at_hl 
1adc			 
1adc 18 23			jr .bpschk 
1ade fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1ae0 20 05			jr nz, .bps8 
1ae2 cd 4b 1e			call monitor 
1ae5			 
1ae5 18 1a			jr .bpschk 
1ae7 fe 30		.bps8:  cp '0' 
1ae9 20 16			jr nz, .bpschk 
1aeb			 
1aeb 21 0d fd				ld hl, display_fb1 
1aee 22 c9 fb				ld (display_fb_active), hl 
1af1 cd bf 0d				call update_display 
1af4			 
1af4				;ld a, (os_view_af) 
1af4 2a ac f1			ld hl, (os_view_hl) 
1af7 ed 5b aa f1		ld de, (os_view_de) 
1afb ed 4b a8 f1		ld bc, (os_view_bc) 
1aff f1				pop af 
1b00 c9				ret 
1b01			 
1b01			.bpschk:   
1b01 cd df 0c			call delay1s 
1b04 3e 9f		ld a,display_row_4 + display_cols - 1 
1b06 11 7b 20		        ld de, endprg 
1b09 cd af 0d			call str_at_display 
1b0c cd bf 0d			call update_display 
1b0f cd c3 79			call cin_wait 
1b12			 
1b12 c3 64 1a			jp .bps1 
1b15			 
1b15			 
1b15			display_reg_state: 
1b15			 
1b15				; to restore afterwards 
1b15			 
1b15 d5				push de 
1b16 c5				push bc 
1b17 e5				push hl 
1b18 f5				push af 
1b19			 
1b19				; for use in here 
1b19			 
1b19 c5				push bc 
1b1a d5				push de 
1b1b e5				push hl 
1b1c f5				push af 
1b1d			 
1b1d cd 9c 0d			call clear_display 
1b20			 
1b20 11 d5 1b			ld de, .regstate 
1b23 3e 00			ld a, display_row_1 
1b25 cd af 0d			call str_at_display 
1b28			 
1b28				; display debug step 
1b28			 
1b28			 
1b28 11 68 fe			ld de, debug_mark 
1b2b 3e 25			ld a, display_row_1+display_cols-3 
1b2d cd af 0d			call str_at_display 
1b30			 
1b30				; display a 
1b30 11 f1 1b			ld de, .regstatea 
1b33 3e 28			ld a, display_row_2 
1b35 cd af 0d			call str_at_display 
1b38			 
1b38 e1				pop hl 
1b39			;	ld h,0 
1b39			;	ld l, a 
1b39 3e 2b			ld a, display_row_2+3 
1b3b cd bb 19			call display_word_at 
1b3e			 
1b3e			 
1b3e				; display hl 
1b3e			 
1b3e			 
1b3e 11 e5 1b			ld de, .regstatehl 
1b41 3e 32			ld a, display_row_2+10 
1b43 cd af 0d			call str_at_display 
1b46			 
1b46 e1				pop hl 
1b47 3e 35			ld a, display_row_2+13 
1b49 cd bb 19			call display_word_at 
1b4c			 
1b4c				 
1b4c				; display de 
1b4c			 
1b4c 11 e9 1b			ld de, .regstatede 
1b4f 3e 50			ld a, display_row_3 
1b51 cd af 0d			call str_at_display 
1b54			 
1b54 e1				pop hl 
1b55			;	ld h,d 
1b55			;	ld l, e 
1b55 3e 53			ld a, display_row_3+3 
1b57 cd bb 19			call display_word_at 
1b5a			 
1b5a			 
1b5a				; display bc 
1b5a			 
1b5a 11 ed 1b			ld de, .regstatebc 
1b5d 3e 5a			ld a, display_row_3+10 
1b5f cd af 0d			call str_at_display 
1b62			 
1b62 e1				pop hl 
1b63			;	ld h,b 
1b63			;	ld l, c 
1b63 3e 5d			ld a, display_row_3+13 
1b65 cd bb 19			call display_word_at 
1b68			 
1b68			 
1b68				; display dsp 
1b68			 
1b68 11 f5 1b			ld de, .regstatedsp 
1b6b 3e 78			ld a, display_row_4 
1b6d cd af 0d			call str_at_display 
1b70			 
1b70				 
1b70 2a eb f9			ld hl,(cli_data_sp) 
1b73 3e 7c			ld a, display_row_4+4 
1b75 cd bb 19			call display_word_at 
1b78			 
1b78				; display rsp 
1b78			 
1b78 11 fa 1b			ld de, .regstatersp 
1b7b 3e 82			ld a, display_row_4+10 
1b7d cd af 0d			call str_at_display 
1b80			 
1b80				 
1b80 2a ef f9			ld hl,(cli_ret_sp) 
1b83 3e 86			ld a, display_row_4+14 
1b85 cd bb 19			call display_word_at 
1b88			 
1b88 cd bf 0d			call update_display 
1b8b			 
1b8b			;	call delay1s 
1b8b			;	call delay1s 
1b8b			;	call delay1s 
1b8b			 
1b8b			 
1b8b			;	call next_page_prompt 
1b8b			 
1b8b				; restore  
1b8b			 
1b8b f1				pop af 
1b8c e1				pop hl 
1b8d c1				pop bc 
1b8e d1				pop de 
1b8f c9				ret 
1b90			 
1b90 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1ba4 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1bb9 .. 00		.ptrstate:	db "Ptr State",0 
1bc3 .. 00		.ptrcliptr:     db "cli_ptr",0 
1bcb .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1bd5 .. 00		.regstate:	db "Reg State (1/0)",0 
1be5 .. 00		.regstatehl:	db "HL:",0 
1be9 .. 00		.regstatede:	db "DE:",0 
1bed .. 00		.regstatebc:	db "BC:",0 
1bf1 .. 00		.regstatea:	db "A :",0 
1bf5 .. 00		.regstatedsp:	db "DSP:",0 
1bfa .. 00		.regstatersp:	db "RSP:",0 
1bff			 
1bff			display_dump_at_hl: 
1bff e5				push hl 
1c00 d5				push de 
1c01 c5				push bc 
1c02 f5				push af 
1c03			 
1c03 22 e1 f4			ld (os_cur_ptr),hl	 
1c06 cd 9c 0d			call clear_display 
1c09 cd 85 1f			call dumpcont 
1c0c			;	call delay1s 
1c0c			;	call next_page_prompt 
1c0c			 
1c0c			 
1c0c f1				pop af 
1c0d c1				pop bc 
1c0e d1				pop de 
1c0f e1				pop hl 
1c10 c9				ret 
1c11			 
1c11			;if ENABLE_BASIC 
1c11			;	include "nascombasic.asm" 
1c11			;	basic: 
1c11			;	include "forth/FORTH.ASM" 
1c11			;endif 
1c11			 
1c11			; eof 
1c11			 
1c11			 
# End of file firmware_diags.asm
1c11			  
1c11			include "firmware_prompts.asm"  
1c11			; Prompts  
1c11			 
1c11			; boot messages 
1c11			 
1c11 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1c26 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1c36			 
1c36			 
1c36			; config menus 
1c36			 
1c36			;prom_c3: db "Add Dictionary To File",0 
1c36			 
1c36			if STARTUP_V1 
1c36			prom_c2: db "Select Autoload File",0 
1c36			prom_c2a: db "Disable Autoload File", 0 
1c36			endif 
1c36			 
1c36			if STARTUP_V2 
1c36 .. 00		prom_c2: db "Enable Autoload Files",0 
1c4c .. 00		prom_c2a: db "Disable Autoload Files", 0 
1c63			 
1c63 .. 00		crs_s1: db "*ls-word", 0 
1c6c .. 00		crs_s2: db "*ed-word", 0 
1c75 .. 00		crs_s3: db "*Demo-Programs", 0 
1c84 .. 00		crs_s4: db "*Utils", 0 
1c8b .. 00		crs_s5: db "*SPI-Addons", 0 
1c97 .. 00		crs_s6: db "*Key-constants", 0 
1ca6 .. 00		crs_sound: db "*Sound-Util", 0 
1cb2			 
1cb2			 
1cb2			 
1cb2			endif 
1cb2			;prom_c2b: db "Select Storage Bank",0 
1cb2 .. 00		prom_c4: db "Settings",0 
1cbb .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1cd6 .. 00		prom_m4b:   db "Monitor",0 
1cde .. 00		prom_c1: db "Hardware Diags",0 
1ced			 
1ced			 
1ced			if STARTUP_V2 
1ced .. 00		prom_c9: db "Create Startup Files",0 
1d02			endif 
1d02			 
1d02 .. 00		prom_notav:    db "Feature not available",0 
1d18 .. 00		prom_empty:    db "",0 
1d19			 
1d19			; eof 
1d19			 
# End of file firmware_prompts.asm
1d19			  
1d19			  
1d19			; eof  
1d19			  
# End of file firmware.asm
1d19			 
1d19			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1d19			;if BASE_KEV  
1d19			;baseram: equ 08000h 
1d19			;endif 
1d19			 
1d19			;if BASE_SC114 
1d19			;baseram:     equ    endofcode 
1d19			;endif 
1d19			 
1d19			 
1d19			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1d19			 
1d19			; start system 
1d19			 
1d19			coldstart: 
1d19				; set sp 
1d19				; di/ei 
1d19			 
1d19 f3				di 
1d1a 31 fd ff			ld sp, tos 
1d1d cd 4a 76			call init_nmi 
1d20			;	ei 
1d20			 
1d20				; init spinner 
1d20 3e 00			ld a,0 
1d22 32 c3 fb			ld (display_active), a 
1d25			 
1d25				; disable breakpoint by default 
1d25			 
1d25				;ld a,'*' 
1d25			;	ld a,' ' 
1d25			;	ld (os_view_disable),a 
1d25			 
1d25				; set break point vector as new break point on or off 
1d25 cd 42 1a			call bp_off 
1d28			 
1d28				; init hardware 
1d28			 
1d28				; init keyboard and screen hardware 
1d28			 
1d28 cd 69 00			call hardware_init 
1d2b			 
1d2b			 
1d2b cd df 0c			call delay1s 
1d2e 3e 58			ld a, display_row_3+8 
1d30 11 03 00			ld de, buildtime 
1d33 cd af 0d			call str_at_display 
1d36 cd bf 0d			call update_display 
1d39			 
1d39 cd df 0c			call delay1s 
1d3c cd df 0c			call delay1s 
1d3f cd df 0c			call delay1s 
1d42			 
1d42				; detect if any keys are held down to enable breakpoints at start up 
1d42			 
1d42 cd d4 79			call cin  
1d45 fe 00			cp 0 
1d47 28 03			jr z, .nokeys 
1d49			 
1d49				;call hardware_diags 
1d49 cd 30 16			call config 
1d4c			 
1d4c			;	ld de, .bpen 
1d4c			;	ld a, display_row_4 
1d4c			;	call str_at_display 
1d4c			;	call update_display 
1d4c			; 
1d4c			;	ld a,0 
1d4c			;	ld (os_view_disable),a 
1d4c			; 
1d4c			;.bpwait: 
1d4c			;	call cin 
1d4c			;	cp 0 
1d4c			;	jr z, .bpwait 
1d4c			;	jr .nokeys 
1d4c			; 
1d4c			; 
1d4c			;.bpen:  db "Break points enabled!",0 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			.nokeys: 
1d4c			 
1d4c			 
1d4c				 
1d4c			 
1d4c			;jp  testkey 
1d4c			 
1d4c			;call storage_get_block_0 
1d4c			; 
1d4c			;ld hl, 0 
1d4c			;ld de, store_page 
1d4c			;call storage_read_block 
1d4c			 
1d4c				 
1d4c			;ld hl, 10 
1d4c			;ld de, store_page 
1d4c			;call storage_read_block 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			 
1d4c			;stop:	nop 
1d4c			;	jp stop 
1d4c			 
1d4c			 
1d4c			 
1d4c			main: 
1d4c cd 9c 0d			call clear_display 
1d4f cd bf 0d			call update_display 
1d52			 
1d52			 
1d52			 
1d52			;	call testlcd 
1d52			 
1d52			 
1d52			 
1d52 cd 82 24			call forth_init 
1d55			 
1d55			 
1d55			warmstart: 
1d55 cd 58 24			call forth_warmstart 
1d58			 
1d58				; run startup word load 
1d58			        ; TODO prevent this running at warmstart after crash  
1d58			 
1d58				if STARTUP_ENABLE 
1d58			 
1d58					if STARTUP_V1 
1d58			 
1d58						if STORAGE_SE 
1d58							call forth_autoload 
1d58						endif 
1d58						call forth_startup 
1d58					endif 
1d58			 
1d58					if STARTUP_V2 
1d58			 
1d58						if STORAGE_SE 
1d58 cd 78 74						call forth_autoload 
1d5b						else 
1d5b							call forth_startup 
1d5b						endif 
1d5b			 
1d5b			 
1d5b					endif 
1d5b			 
1d5b				endif 
1d5b			 
1d5b				; show free memory after boot 
1d5b 11 e6 1d			ld de, freeram 
1d5e 3e 00			ld a, display_row_1 
1d60 cd af 0d			call str_at_display 
1d63			 
1d63				; get current heap start after loading any uwords 
1d63			 
1d63 ed 5b bb f4		ld de, (os_last_new_uword) 
1d67				;ex de, hl 
1d67			 
1d67			; Or use heap_size word???? 
1d67				;ld hl, heap_end 
1d67 21 97 71			ld hl, heap_size 
1d6a				;ld de, topusermem 
1d6a				;ld de, heap_start 
1d6a ed 52			sbc hl, de 
1d6c				;push hl 
1d6c				;ld a,h	         	 
1d6c				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1d6c				;call hexout 
1d6c			   	;pop hl 
1d6c			; 
1d6c			;	ld a,l 
1d6c			;	ld hl, os_word_scratch+2 
1d6c			;	call hexout 
1d6c			;	ld hl, os_word_scratch+4 
1d6c			;	ld a, 0 
1d6c			;	ld (hl),a 
1d6c			 
1d6c 21 c3 f4			ld hl, os_word_scratch 
1d6f cd dd 13			call uitoa_16 
1d72			 
1d72			 
1d72 11 c3 f4			ld de, os_word_scratch 
1d75 3e 0d			ld a, display_row_1 + 13 
1d77 cd af 0d			call str_at_display 
1d7a cd bf 0d			call update_display 
1d7d			 
1d7d			 
1d7d				;call demo 
1d7d			 
1d7d			 
1d7d				; init scratch input area for cli commands 
1d7d			 
1d7d 21 e5 f4			ld hl, os_cli_cmd 
1d80 3e 00			ld a,0 
1d82 77				ld (hl),a 
1d83 23				inc hl 
1d84 77				ld (hl),a 
1d85			 
1d85 3e 00			ld a,0 
1d87 32 e4 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1d8a			 
1d8a 32 e1 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1d8d 32 e2 f4			ld (os_cur_ptr+1),a	 
1d90			 
1d90 32 c3 f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1d93 32 c4 f4			ld (os_word_scratch+1),a	 
1d96				 
1d96			 
1d96				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d96 21 e5 f4			ld hl, os_cli_cmd 
1d99			 
1d99 3e 00			ld a, 0		 ; init cli input 
1d9b 77				ld (hl), a 
1d9c 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d9e			cli: 
1d9e				; show cli prompt 
1d9e				;push af 
1d9e				;ld a, 0 
1d9e				;ld de, prompt 
1d9e				;call str_at_display 
1d9e			 
1d9e				;call update_display 
1d9e				;pop af 
1d9e				;inc a 
1d9e				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1d9e 0e 00			ld c, 0 
1da0 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1da2 1e 28			ld e, 40 
1da4			 
1da4 21 e5 f4			ld hl, os_cli_cmd 
1da7			 
1da7				STACKFRAME OFF $fefe $9f9f 
1da7				if DEBUG_STACK_IMB 
1da7					if OFF 
1da7						exx 
1da7						ld de, $fefe 
1da7						ld a, d 
1da7						ld hl, curframe 
1da7						call hexout 
1da7						ld a, e 
1da7						ld hl, curframe+2 
1da7						call hexout 
1da7						ld hl, $fefe 
1da7						push hl 
1da7						ld hl, $9f9f 
1da7						push hl 
1da7						exx 
1da7					endif 
1da7				endif 
1da7			endm 
# End of macro STACKFRAME
1da7			 
1da7 cd fd 0f			call input_str 
1daa			 
1daa				STACKFRAMECHK OFF $fefe $9f9f 
1daa				if DEBUG_STACK_IMB 
1daa					if OFF 
1daa						exx 
1daa						ld hl, $9f9f 
1daa						pop de   ; $9f9f 
1daa						call cmp16 
1daa						jr nz, .spnosame 
1daa						ld hl, $fefe 
1daa						pop de   ; $fefe 
1daa						call cmp16 
1daa						jr z, .spfrsame 
1daa						.spnosame: call showsperror 
1daa						.spfrsame: nop 
1daa						exx 
1daa					endif 
1daa				endif 
1daa			endm 
# End of macro STACKFRAMECHK
1daa			 
1daa				; copy input to last command 
1daa			 
1daa 21 e5 f4			ld hl, os_cli_cmd 
1dad 11 e4 f5			ld de, os_last_cmd 
1db0 01 ff 00			ld bc, 255 
1db3 ed b0			ldir 
1db5			 
1db5				; wipe current buffer 
1db5			 
1db5			;	ld a, 0 
1db5			;	ld hl, os_cli_cmd 
1db5			;	ld de, os_cli_cmd+1 
1db5			;	ld bc, 254 
1db5			;	ldir 
1db5				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1db5			;	call strcpy 
1db5			;	ld a, 0 
1db5			;	ld (hl), a 
1db5			;	inc hl 
1db5			;	ld (hl), a 
1db5			;	inc hl 
1db5			;	ld (hl), a 
1db5			 
1db5				; switch frame buffer to program  
1db5			 
1db5 21 0d fd				ld hl, display_fb1 
1db8 22 c9 fb				ld (display_fb_active), hl 
1dbb			 
1dbb			;	nop 
1dbb				STACKFRAME ON $fbfe $8f9f 
1dbb				if DEBUG_STACK_IMB 
1dbb					if ON 
1dbb						exx 
1dbb						ld de, $fbfe 
1dbb						ld a, d 
1dbb						ld hl, curframe 
1dbb						call hexout 
1dbb						ld a, e 
1dbb						ld hl, curframe+2 
1dbb						call hexout 
1dbb						ld hl, $fbfe 
1dbb						push hl 
1dbb						ld hl, $8f9f 
1dbb						push hl 
1dbb						exx 
1dbb					endif 
1dbb				endif 
1dbb			endm 
# End of macro STACKFRAME
1dbb				; first time into the parser so pass over the current scratch pad 
1dbb 21 e5 f4			ld hl,os_cli_cmd 
1dbe				; tokenise the entered statement(s) in HL 
1dbe cd 00 25			call forthparse 
1dc1			        ; exec forth statements in top of return stack 
1dc1 cd 40 25			call forthexec 
1dc4				;call forthexec_cleanup 
1dc4			;	call parsenext 
1dc4			 
1dc4				STACKFRAMECHK ON $fbfe $8f9f 
1dc4				if DEBUG_STACK_IMB 
1dc4					if ON 
1dc4						exx 
1dc4						ld hl, $8f9f 
1dc4						pop de   ; $8f9f 
1dc4						call cmp16 
1dc4						jr nz, .spnosame 
1dc4						ld hl, $fbfe 
1dc4						pop de   ; $fbfe 
1dc4						call cmp16 
1dc4						jr z, .spfrsame 
1dc4						.spnosame: call showsperror 
1dc4						.spfrsame: nop 
1dc4						exx 
1dc4					endif 
1dc4				endif 
1dc4			endm 
# End of macro STACKFRAMECHK
1dc4				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1dc4			 
1dc4 3e 78			ld a, display_row_4 
1dc6 11 f7 1d			ld de, endprog 
1dc9			 
1dc9 cd bf 0d			call update_display		 
1dcc			 
1dcc cd 7d 20			call next_page_prompt 
1dcf			 
1dcf				; switch frame buffer to cli 
1dcf			 
1dcf 21 ae fd				ld hl, display_fb0 
1dd2 22 c9 fb				ld (display_fb_active), hl 
1dd5			 
1dd5			 
1dd5 cd 9c 0d		        call clear_display 
1dd8 cd bf 0d			call update_display		 
1ddb			 
1ddb 21 e5 f4			ld hl, os_cli_cmd 
1dde			 
1dde 3e 00			ld a, 0		 ; init cli input 
1de0 77				ld (hl), a 
1de1			 
1de1				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1de1			 
1de1				; now on last line 
1de1			 
1de1				; TODO scroll screen up 
1de1			 
1de1				; TODO instead just clear screen and place at top of screen 
1de1			 
1de1			;	ld a, 0 
1de1			;	ld (f_cursor_ptr),a 
1de1			 
1de1				;call clear_display 
1de1				;call update_display 
1de1			 
1de1				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1de1 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1de3 c3 9e 1d			jp cli 
1de6			 
1de6 .. 00		freeram: db "Free bytes: ",0 
1df3 ..			asc: db "1A2F" 
1df7 .. 00		endprog: db "End prog...",0 
1e03			 
1e03			testenter2:   
1e03 21 f0 f1			ld hl,scratch+50 
1e06 22 e1 f4			ld (os_cur_ptr),hl 
1e09 c3 9e 1d			jp cli 
1e0c			 
1e0c			testenter:  
1e0c			 
1e0c 21 f3 1d			ld hl,asc 
1e0f			;	ld a,(hl) 
1e0f			;	call nibble2val 
1e0f cd 27 13			call get_byte 
1e12			 
1e12			 
1e12			;	ld a,(hl) 
1e12			;	call atohex 
1e12			 
1e12			;	call fourehexhl 
1e12 32 f0 f1			ld (scratch+50),a 
1e15			 
1e15			 
1e15			 
1e15 21 f5 1d			ld hl,asc+2 
1e18			;	ld a, (hl) 
1e18			;	call nibble2val 
1e18 cd 27 13			call get_byte 
1e1b			 
1e1b			;	call fourehexhl 
1e1b 32 f2 f1			ld (scratch+52),a 
1e1e				 
1e1e 21 f0 f1			ld hl,scratch+50 
1e21 22 e1 f4			ld (os_cur_ptr),hl 
1e24 c3 9e 1d			jp cli 
1e27			 
1e27			enter:	 
1e27 3a c2 f1			ld a,(scratch+4) 
1e2a fe 00			cp 0 
1e2c 28 0c			jr z, .entercont 
1e2e				; no, not a null term line so has an address to work out.... 
1e2e			 
1e2e 21 c0 f1			ld hl,scratch+2 
1e31 cd 87 13			call get_word_hl 
1e34			 
1e34 22 e1 f4			ld (os_cur_ptr),hl	 
1e37 c3 9e 1d			jp cli 
1e3a			 
1e3a			 
1e3a			.entercont:  
1e3a			 
1e3a 21 c0 f1			ld hl, scratch+2 
1e3d cd 27 13			call get_byte 
1e40			 
1e40 2a e1 f4		   	ld hl,(os_cur_ptr) 
1e43 77					ld (hl),a 
1e44 23					inc hl 
1e45 22 e1 f4				ld (os_cur_ptr),hl 
1e48				 
1e48			; get byte  
1e48			 
1e48			 
1e48 c3 9e 1d			jp cli 
1e4b			 
1e4b			 
1e4b			; basic monitor support 
1e4b			 
1e4b			monitor: 
1e4b				;  
1e4b cd 9c 0d			call clear_display 
1e4e 3e 00			ld a, 0 
1e50 11 9f 1e			ld de, .monprompt 
1e53 cd af 0d			call str_at_display 
1e56 cd bf 0d			call update_display 
1e59			 
1e59				; get a monitor command 
1e59			 
1e59 0e 00			ld c, 0     ; entry at top left 
1e5b 16 64			ld d, 100   ; max buffer size 
1e5d 1e 0f			ld e, 15    ; input scroll area 
1e5f 3e 00			ld a, 0     ; init string 
1e61 21 bc f3			ld hl, os_input 
1e64 77				ld (hl), a 
1e65 23				inc hl 
1e66 77				ld (hl), a 
1e67 21 bc f3			ld hl, os_input 
1e6a 3e 01			ld a, 1     ; init string 
1e6c cd fd 0f			call input_str 
1e6f			 
1e6f cd 9c 0d		        call clear_display 
1e72 cd bf 0d			call update_display		 
1e75			 
1e75 3a bc f3			ld a, (os_input) 
1e78 cd 25 14			call toUpper 
1e7b fe 48		        cp 'H' 
1e7d ca 04 1f		        jp z, .monhelp 
1e80 fe 44			cp 'D'		; dump 
1e82 ca 37 1f			jp z, .mondump	 
1e85 fe 43			cp 'C'		; dump 
1e87 ca 51 1f			jp z, .moncdump	 
1e8a fe 4d			cp 'M'		; dump 
1e8c ca a1 1e			jp z, .moneditstart 
1e8f fe 55			cp 'U'		; dump 
1e91 ca ad 1e			jp z, .monedit	 
1e94 fe 47			cp 'G'		; dump 
1e96 ca 2d 1f			jp z, .monjump 
1e99 fe 51			cp 'Q'		; dump 
1e9b c8				ret z	 
1e9c			 
1e9c			 
1e9c				; TODO "S" to access symbol by name and not need the address 
1e9c				; TODO "F" to find a string in memory 
1e9c			 
1e9c c3 4b 1e			jp monitor 
1e9f			 
1e9f .. 00		.monprompt: db ">", 0 
1ea1			 
1ea1			.moneditstart: 
1ea1				; get starting address 
1ea1			 
1ea1 21 be f3			ld hl,os_input+2 
1ea4 cd 87 13			call get_word_hl 
1ea7			 
1ea7 22 e1 f4			ld (os_cur_ptr),hl	 
1eaa			 
1eaa c3 4b 1e			jp monitor 
1ead			 
1ead			.monedit: 
1ead				; get byte to load 
1ead			 
1ead 21 be f3			ld hl,os_input+2 
1eb0 cd 27 13			call get_byte 
1eb3			 
1eb3				; get address to update 
1eb3 2a e1 f4			ld hl, (os_cur_ptr) 
1eb6			 
1eb6				; update byte 
1eb6			 
1eb6 77				ld (hl), a 
1eb7			 
1eb7				; move to next address and save it 
1eb7			 
1eb7 23				inc hl 
1eb8 22 e1 f4			ld (os_cur_ptr),hl	 
1ebb			 
1ebb c3 4b 1e			jp monitor 
1ebe			 
1ebe			 
1ebe .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1ed2 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1eee .. 00		.monhelptext3:  db "G-Call address",0 
1efd .. 00		.monhelptext4:  db "Q-Quit",0 
1f04			        
1f04			.monhelp: 
1f04 3e 00			ld a, display_row_1 
1f06 11 be 1e		        ld de, .monhelptext1 
1f09			 
1f09 cd af 0d			call str_at_display 
1f0c 3e 28			ld a, display_row_2 
1f0e 11 d2 1e		        ld de, .monhelptext2 
1f11					 
1f11 cd af 0d			call str_at_display 
1f14 3e 50			ld a, display_row_3 
1f16 11 ee 1e		        ld de, .monhelptext3 
1f19					 
1f19 cd af 0d			call str_at_display 
1f1c 3e 78			ld a, display_row_4 
1f1e 11 fd 1e		        ld de, .monhelptext4 
1f21 cd af 0d			call str_at_display 
1f24			 
1f24 cd bf 0d			call update_display		 
1f27			 
1f27 cd 7d 20			call next_page_prompt 
1f2a c3 4b 1e			jp monitor 
1f2d			 
1f2d			.monjump:    
1f2d 21 be f3			ld hl,os_input+2 
1f30 cd 87 13			call get_word_hl 
1f33			 
1f33 e9				jp (hl) 
1f34 c3 4b 1e			jp monitor 
1f37			 
1f37			.mondump:    
1f37 21 be f3			ld hl,os_input+2 
1f3a cd 87 13			call get_word_hl 
1f3d			 
1f3d 22 e1 f4			ld (os_cur_ptr),hl	 
1f40 cd 85 1f			call dumpcont 
1f43 3e 78			ld a, display_row_4 
1f45 11 f7 1d			ld de, endprog 
1f48			 
1f48 cd bf 0d			call update_display		 
1f4b			 
1f4b cd 7d 20			call next_page_prompt 
1f4e c3 4b 1e			jp monitor 
1f51			.moncdump: 
1f51 cd 85 1f			call dumpcont 
1f54 3e 78			ld a, display_row_4 
1f56 11 f7 1d			ld de, endprog 
1f59			 
1f59 cd bf 0d			call update_display		 
1f5c			 
1f5c cd 7d 20			call next_page_prompt 
1f5f c3 4b 1e			jp monitor 
1f62			 
1f62			 
1f62			; TODO symbol access  
1f62			 
1f62			.symbols:     ;; A list of symbols that can be called up  
1f62 ae fd			dw display_fb0 
1f64 .. 00			db "fb0",0  
1f68 77 fa		     	dw store_page 
1f6a .. 00			db "store_page",0 
1f75			 
1f75			 
1f75			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1f75			 
1f75 3a bf f1			ld a,(scratch+1) 
1f78 fe 00			cp 0 
1f7a 28 09			jr z, dumpcont 
1f7c			 
1f7c				; no, not a null term line so has an address to work out.... 
1f7c			 
1f7c 21 c0 f1			ld hl,scratch+2 
1f7f cd 87 13			call get_word_hl 
1f82			 
1f82 22 e1 f4			ld (os_cur_ptr),hl	 
1f85			 
1f85			 
1f85			 
1f85			dumpcont: 
1f85			 
1f85				; dump bytes at ptr 
1f85			 
1f85			 
1f85 3e 00			ld a, display_row_1 
1f87 2a c9 fb			ld hl, (display_fb_active) 
1f8a cd d0 0f			call addatohl 
1f8d cd b5 1f			call .dumpbyterow 
1f90			 
1f90 3e 28			ld a, display_row_2 
1f92 2a c9 fb			ld hl, (display_fb_active) 
1f95 cd d0 0f			call addatohl 
1f98 cd b5 1f			call .dumpbyterow 
1f9b			 
1f9b			 
1f9b 3e 50			ld a, display_row_3 
1f9d 2a c9 fb			ld hl, (display_fb_active) 
1fa0 cd d0 0f			call addatohl 
1fa3 cd b5 1f			call .dumpbyterow 
1fa6			 
1fa6 3e 78			ld a, display_row_4 
1fa8 2a c9 fb			ld hl, (display_fb_active) 
1fab cd d0 0f			call addatohl 
1fae cd b5 1f			call .dumpbyterow 
1fb1			 
1fb1 cd bf 0d			call update_display 
1fb4			;		jp cli 
1fb4 c9				ret 
1fb5			 
1fb5			.dumpbyterow: 
1fb5			 
1fb5				;push af 
1fb5			 
1fb5 e5				push hl 
1fb6			 
1fb6				; calc where to poke the ascii 
1fb6			if display_cols == 20 
1fb6				ld a, 16 
1fb6			else 
1fb6 3e 1f			ld a, 31 
1fb8			endif 
1fb8			 
1fb8 cd d0 0f			call addatohl 
1fbb 22 c3 f4			ld (os_word_scratch),hl  		; save pos for later 
1fbe			 
1fbe			 
1fbe			; display decoding address 
1fbe 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fc1			 
1fc1 7c				ld a,h 
1fc2 e1				pop hl 
1fc3 e5				push hl 
1fc4			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1fc4 cd d1 12			call hexout 
1fc7 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fca			 
1fca 7d				ld a,l 
1fcb e1				pop hl 
1fcc 23				inc hl 
1fcd 23				inc hl 
1fce e5				push hl 
1fcf			;	ld hl, os_word_scratch+2 
1fcf cd d1 12			call hexout 
1fd2 e1				pop hl 
1fd3 23				inc hl 
1fd4 23				inc hl 
1fd5				;ld hl, os_word_scratch+4 
1fd5 3e 3a			ld a, ':' 
1fd7 77				ld (hl),a 
1fd8 23				inc hl 
1fd9				;ld a, 0 
1fd9				;ld (hl),a 
1fd9				;ld de, os_word_scratch 
1fd9				;pop af 
1fd9				;push af 
1fd9			;		ld a, display_row_2 
1fd9			;		call str_at_display 
1fd9			;		call update_display 
1fd9			 
1fd9			 
1fd9			;pop af 
1fd9			;	add 5 
1fd9			 
1fd9			if display_cols == 20 
1fd9				ld b, 4 
1fd9			else 
1fd9 06 08			ld b, 8 
1fdb			endif	 
1fdb			 
1fdb			.dumpbyte: 
1fdb c5				push bc 
1fdc e5				push hl 
1fdd			 
1fdd			 
1fdd 2a e1 f4		   	ld hl,(os_cur_ptr) 
1fe0 7e					ld a,(hl) 
1fe1			 
1fe1					; poke the ascii to display 
1fe1 2a c3 f4				ld hl,(os_word_scratch) 
1fe4 77					ld (hl),a 
1fe5 23					inc hl 
1fe6 22 c3 f4				ld (os_word_scratch),hl 
1fe9			 
1fe9					 
1fe9			 
1fe9			 
1fe9 e1					pop hl 
1fea e5					push hl 
1feb			 
1feb cd d1 12				call hexout 
1fee			 
1fee					 
1fee 2a e1 f4		   	ld hl,(os_cur_ptr) 
1ff1 23				inc hl 
1ff2 22 e1 f4		   	ld (os_cur_ptr),hl 
1ff5			 
1ff5 e1					pop hl 
1ff6 23					inc hl 
1ff7 23					inc hl 
1ff8 23					inc hl 
1ff9			 
1ff9			 
1ff9			 
1ff9					;ld a,0 
1ff9					;ld (os_word_scratch+2),a 
1ff9					;pop af 
1ff9					;push af 
1ff9			 
1ff9					;ld de, os_word_scratch 
1ff9					;call str_at_display 
1ff9			;		call update_display 
1ff9			;		pop af 
1ff9 c1					pop bc 
1ffa c6 03				add 3 
1ffc 10 dd			djnz .dumpbyte 
1ffe			 
1ffe				 
1ffe			 
1ffe c9				ret 
1fff			 
1fff			jump:	 
1fff			 
1fff 21 c0 f1			ld hl,scratch+2 
2002 cd 87 13			call get_word_hl 
2005				;ld hl,(scratch+2) 
2005				;call fourehexhl 
2005			 
2005 22 e1 f4			ld (os_cur_ptr),hl	 
2008			 
2008 e9				jp (hl) 
2009			 
2009			 
2009			 
2009			; TODO implement a basic monitor mode to start with 
2009			 
2009			 
2009			 
2009			 
2009			 
2009			 
2009			 
2009			 
2009			 
2009			; testing and demo code during development 
2009			 
2009			 
2009 .. 00		str1: db "Enter some text...",0 
201c .. 00		clear: db "                    ",0 
2031			 
2031			demo: 
2031			 
2031			 
2031			 
2031			;	call update_display 
2031			 
2031				; init scratch input area for testing 
2031 21 be f1			ld hl, scratch	 
2034 3e 00			ld a,0 
2036 77				ld (hl),a 
2037			 
2037			 
2037 3e 28		            LD   A, display_row_2 
2039			;            CALL fLCD_Pos       ;Position cursor to location in A 
2039 11 09 20		            LD   DE, str1 
203c cd af 0d			call str_at_display 
203f			 
203f			;            CALL fLCD_Str       ;Display string pointed to by DE 
203f			cloop:	 
203f 3e 50		            LD   A, display_row_3 
2041			;            CALL fLCD_Pos       ;Position cursor to location in A 
2041 11 1c 20		            LD   DE, clear 
2044			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
2044 cd af 0d				call str_at_display 
2047 3e 78			ld a, display_row_4 
2049 11 79 20			ld de, prompt 
204c			 
204c cd af 0d				call str_at_display 
204f cd bf 0d			call update_display 
2052			 
2052 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
2054 16 0a			ld d, 10 
2056 21 be f1			ld hl, scratch	 
2059 cd fd 0f			call input_str 
205c			 
205c			;	call clear_display 
205c			;'	call update_display 
205c			 
205c 3e 00		            LD   A, display_row_1 
205e			;            CALL fLCD_Pos       ;Position cursor to location in A 
205e 11 1c 20		            LD   DE, clear 
2061 cd af 0d				call str_at_display 
2064			;            CALL fLCD_Str       ;Display string pointed to by DE 
2064 3e 00		            LD   A, display_row_1 
2066			;            CALL fLCD_Pos       ;Position cursor to location in A 
2066 11 be f1		            LD   DE, scratch 
2069			;            CALL fLCD_Str       ;Display string pointed to by DE 
2069 cd af 0d				call str_at_display 
206c cd bf 0d			call update_display 
206f			 
206f 3e 00				ld a,0 
2071 21 be f1			ld hl, scratch 
2074 77				ld (hl),a 
2075			 
2075 00				nop 
2076 c3 3f 20			jp cloop 
2079			 
2079			 
2079			 
2079			; OS Prompt 
2079			 
2079 .. 00		prompt: db ">",0 
207b .. 00		endprg: db "?",0 
207d			 
207d			 
207d			; handy next page prompt 
207d			next_page_prompt: 
207d e5				push hl 
207e d5				push de 
207f f5				push af 
2080 c5				push bc 
2081			 
2081 3e 9f			ld a,display_row_4 + display_cols - 1 
2083 11 7b 20		        ld de, endprg 
2086 cd af 0d			call str_at_display 
2089 cd bf 0d			call update_display 
208c cd c3 79			call cin_wait 
208f c1				pop bc 
2090 f1				pop af 
2091 d1				pop de 
2092 e1				pop hl 
2093			 
2093			 
2093 c9				ret 
2094			 
2094			 
2094			; forth parser 
2094			 
2094			; My forth kernel 
2094			include "forth_kernel.asm" 
2094			; 
2094			; kernel to the forth OS 
2094			 
2094			DS_TYPE_STR: equ 1     ; string type 
2094			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
2094			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
2094			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
2094			 
2094			FORTH_PARSEV1: equ 0 
2094			FORTH_PARSEV2: equ 0 
2094			FORTH_PARSEV3: equ 0 
2094			FORTH_PARSEV4: equ 0 
2094			FORTH_PARSEV5: equ 1 
2094			 
2094			;if FORTH_PARSEV5 
2094			;	FORTH_END_BUFFER: equ 0 
2094			;else 
2094			FORTH_END_BUFFER: equ 127 
2094			;endif 
2094			 
2094			FORTH_TRUE: equ 1 
2094			FORTH_FALSE: equ 0 
2094			 
2094			if FORTH_PARSEV4 
2094			include "forth_stackops.asm" 
2094			endif 
2094			 
2094			if FORTH_PARSEV5 
2094			include "forth_stackopsv5.asm" 
2094			 
2094			; Stack operations for v5 parser on wards 
2094			; * DATA stack 
2094			; * LOOP stack 
2094			; * RETURN stack 
2094			 
2094			 
2094			 
2094			FORTH_CHK_DSP_UNDER: macro 
2094				push hl 
2094				push de 
2094				ld hl,(cli_data_sp) 
2094				ld de, cli_data_stack 
2094				call cmp16 
2094				jp c, fault_dsp_under 
2094				pop de 
2094				pop hl 
2094				endm 
2094			 
2094			 
2094			FORTH_CHK_RSP_UNDER: macro 
2094				push hl 
2094				push de 
2094				ld hl,(cli_ret_sp) 
2094				ld de, cli_ret_stack 
2094				call cmp16 
2094				jp c, fault_rsp_under 
2094				pop de 
2094				pop hl 
2094				endm 
2094			 
2094			FORTH_CHK_LOOP_UNDER: macro 
2094				push hl 
2094				push de 
2094				ld hl,(cli_loop_sp) 
2094				ld de, cli_loop_stack 
2094				call cmp16 
2094				jp c, fault_loop_under 
2094				pop de 
2094				pop hl 
2094				endm 
2094			 
2094			FORTH_ERR_TOS_NOTSTR: macro 
2094				; TOSO might need more for checks when used 
2094				push af 
2094				ld a,(hl) 
2094				cp DS_TYPE_STR 
2094				jp nz, type_faultn   
2094				pop af 
2094				endm 
2094			 
2094			FORTH_ERR_TOS_NOTNUM: macro 
2094				push af 
2094				ld a,(hl) 
2094				cp DS_TYPE_INUM 
2094				jp nz, type_faultn   
2094				pop af 
2094				endm 
2094			 
2094			 
2094			; increase data stack pointer and save hl to it 
2094				 
2094			FORTH_DSP_NEXT: macro 
2094				call macro_forth_dsp_next 
2094				endm 
2094			 
2094			 
2094			macro_forth_dsp_next: 
2094				if DEBUG_FORTH_STACK_GUARD 
2094 cd 70 72				call check_stacks 
2097				endif 
2097 e5				push hl 
2098 d5				push de 
2099 eb				ex de,hl 
209a 2a eb f9			ld hl,(cli_data_sp) 
209d 23				inc hl 
209e 23				inc hl 
209f			 
209f			; PARSEV5 
209f 23				inc hl 
20a0 22 eb f9			ld (cli_data_sp),hl 
20a3 73				ld (hl), e 
20a4 23				inc hl 
20a5 72				ld (hl), d 
20a6 d1				pop de 
20a7 e1				pop hl 
20a8				if DEBUG_FORTH_STACK_GUARD 
20a8 cd 70 72				call check_stacks 
20ab				endif 
20ab c9				ret 
20ac			 
20ac			 
20ac			; increase ret stack pointer and save hl to it 
20ac				 
20ac			FORTH_RSP_NEXT: macro 
20ac				call macro_forth_rsp_next 
20ac				endm 
20ac			 
20ac			macro_forth_rsp_next: 
20ac				if DEBUG_FORTH_STACK_GUARD 
20ac cd 70 72				call check_stacks 
20af				endif 
20af e5				push hl 
20b0 d5				push de 
20b1 eb				ex de,hl 
20b2 2a ef f9			ld hl,(cli_ret_sp) 
20b5 23				inc hl 
20b6 23				inc hl 
20b7 22 ef f9			ld (cli_ret_sp),hl 
20ba 73				ld (hl), e 
20bb 23				inc hl 
20bc 72				ld (hl), d 
20bd d1				pop de 
20be e1				pop hl 
20bf				if DEBUG_FORTH_STACK_GUARD 
20bf cd 70 72				call check_stacks 
20c2				endif 
20c2 c9				ret 
20c3			 
20c3			; get current ret stack pointer and save to hl  
20c3				 
20c3			FORTH_RSP_TOS: macro 
20c3				call macro_forth_rsp_tos 
20c3				endm 
20c3			 
20c3			macro_forth_rsp_tos: 
20c3				;push de 
20c3 2a ef f9			ld hl,(cli_ret_sp) 
20c6 cd fe 20			call loadhlptrtohl 
20c9				;ld e, (hl) 
20c9				;inc hl 
20c9				;ld d, (hl) 
20c9				;ex de, hl 
20c9					if DEBUG_FORTH_WORDS 
20c9			;			DMARK "RST" 
20c9						CALLMONITOR 
20c9 cd 6c fe			call debug_vector  
20cc				endm  
# End of macro CALLMONITOR
20cc					endif 
20cc				;pop de 
20cc c9				ret 
20cd			 
20cd			; pop ret stack pointer 
20cd				 
20cd			FORTH_RSP_POP: macro 
20cd				call macro_forth_rsp_pop 
20cd				endm 
20cd			 
20cd			 
20cd			macro_forth_rsp_pop: 
20cd				if DEBUG_FORTH_STACK_GUARD 
20cd			;		DMARK "RPP" 
20cd cd 70 72				call check_stacks 
20d0					FORTH_CHK_RSP_UNDER 
20d0 e5				push hl 
20d1 d5				push de 
20d2 2a ef f9			ld hl,(cli_ret_sp) 
20d5 11 a9 f9			ld de, cli_ret_stack 
20d8 cd ee 0f			call cmp16 
20db da 84 73			jp c, fault_rsp_under 
20de d1				pop de 
20df e1				pop hl 
20e0				endm 
# End of macro FORTH_CHK_RSP_UNDER
20e0				endif 
20e0 e5				push hl 
20e1 2a ef f9			ld hl,(cli_ret_sp) 
20e4			 
20e4			 
20e4				if FORTH_ENABLE_FREE 
20e4			 
20e4					; get pointer 
20e4			 
20e4					push de 
20e4					push hl 
20e4			 
20e4					ld e, (hl) 
20e4					inc hl 
20e4					ld d, (hl) 
20e4			 
20e4					ex de, hl 
20e4					call free 
20e4			 
20e4					pop hl 
20e4					pop de 
20e4			 
20e4			 
20e4				endif 
20e4			 
20e4			 
20e4 2b				dec hl 
20e5 2b				dec hl 
20e6 22 ef f9			ld (cli_ret_sp), hl 
20e9				; do stack underflow checks 
20e9 e1				pop hl 
20ea				if DEBUG_FORTH_STACK_GUARD 
20ea cd 70 72				call check_stacks 
20ed					FORTH_CHK_RSP_UNDER 
20ed e5				push hl 
20ee d5				push de 
20ef 2a ef f9			ld hl,(cli_ret_sp) 
20f2 11 a9 f9			ld de, cli_ret_stack 
20f5 cd ee 0f			call cmp16 
20f8 da 84 73			jp c, fault_rsp_under 
20fb d1				pop de 
20fc e1				pop hl 
20fd				endm 
# End of macro FORTH_CHK_RSP_UNDER
20fd				endif 
20fd c9				ret 
20fe			 
20fe			 
20fe			 
20fe			; routine to load word pointed to by hl into hl 
20fe			 
20fe			loadhlptrtohl: 
20fe			 
20fe d5				push de 
20ff 5e				ld e, (hl) 
2100 23				inc hl 
2101 56				ld d, (hl) 
2102 eb				ex de, hl 
2103 d1				pop de 
2104			 
2104 c9				ret 
2105			 
2105			 
2105			 
2105			 
2105			 
2105			; push a number held in HL onto the data stack 
2105			; entry point for pushing a value when already in hl used in function above 
2105			 
2105			forth_push_numhl: 
2105			 
2105 e5				push hl    ; save value to push 
2106			 
2106			if DEBUG_FORTH_PUSH 
2106				; see if disabled 
2106			 
2106			 
2106 f5				push af 
2107 3a 6c fe			ld a,(debug_vector) 
210a fe c9			cp $c9   ; ret 
210c			;	ld a, (os_view_disable) 
210c			;	cp '*' 
210c 28 34			jr z, .pskip2 
210e e5				push hl 
210f e5			push hl 
2110 cd 9c 0d			call clear_display 
2113 e1			pop hl 
2114 7c				ld a,h 
2115 21 c3 f4			ld hl, os_word_scratch 
2118 cd d1 12			call hexout 
211b e1				pop hl 
211c 7d				ld a,l 
211d 21 c5 f4			ld hl, os_word_scratch+2 
2120 cd d1 12			call hexout 
2123			 
2123 21 c7 f4			ld hl, os_word_scratch+4 
2126 3e 00			ld a,0 
2128 77				ld (hl),a 
2129 11 c3 f4			ld de,os_word_scratch 
212c 3e 28				ld a, display_row_2 
212e cd af 0d				call str_at_display 
2131 11 ac 5d			ld de, .push_num 
2134 3e 00			ld a, display_row_1 
2136			 
2136 cd af 0d				call str_at_display 
2139			 
2139			 
2139 cd bf 0d			call update_display 
213c cd df 0c			call delay1s 
213f cd df 0c			call delay1s 
2142			.pskip2:  
2142			 
2142 f1				pop af 
2143			endif	 
2143			 
2143			 
2143				FORTH_DSP_NEXT 
2143 cd 94 20			call macro_forth_dsp_next 
2146				endm 
# End of macro FORTH_DSP_NEXT
2146			 
2146 2a eb f9			ld hl, (cli_data_sp) 
2149			 
2149				; save item type 
2149 3e 02			ld a,  DS_TYPE_INUM 
214b 77				ld (hl), a 
214c 23				inc hl 
214d			 
214d				; get word off stack 
214d d1				pop de 
214e 7b				ld a,e 
214f 77				ld (hl), a 
2150 23				inc hl 
2151 7a				ld a,d 
2152 77				ld (hl), a 
2153			 
2153			if DEBUG_FORTH_PUSH 
2153 2b				dec hl 
2154 2b				dec hl 
2155 2b				dec hl 
2156						DMARK "PH5" 
2156 f5				push af  
2157 3a 6b 21			ld a, (.dmark)  
215a 32 68 fe			ld (debug_mark),a  
215d 3a 6c 21			ld a, (.dmark+1)  
2160 32 69 fe			ld (debug_mark+1),a  
2163 3a 6d 21			ld a, (.dmark+2)  
2166 32 6a fe			ld (debug_mark+2),a  
2169 18 03			jr .pastdmark  
216b ..			.dmark: db "PH5"  
216e f1			.pastdmark: pop af  
216f			endm  
# End of macro DMARK
216f				CALLMONITOR 
216f cd 6c fe			call debug_vector  
2172				endm  
# End of macro CALLMONITOR
2172			endif	 
2172			 
2172 c9				ret 
2173			 
2173			 
2173			; Push a string to stack pointed to by hl 
2173			 
2173			forth_push_str: 
2173			 
2173			if DEBUG_FORTH_PUSH 
2173						DMARK "PSQ" 
2173 f5				push af  
2174 3a 88 21			ld a, (.dmark)  
2177 32 68 fe			ld (debug_mark),a  
217a 3a 89 21			ld a, (.dmark+1)  
217d 32 69 fe			ld (debug_mark+1),a  
2180 3a 8a 21			ld a, (.dmark+2)  
2183 32 6a fe			ld (debug_mark+2),a  
2186 18 03			jr .pastdmark  
2188 ..			.dmark: db "PSQ"  
218b f1			.pastdmark: pop af  
218c			endm  
# End of macro DMARK
218c				CALLMONITOR 
218c cd 6c fe			call debug_vector  
218f				endm  
# End of macro CALLMONITOR
218f			endif	 
218f			    
218f e5				push hl 
2190 e5				push hl 
2191			 
2191			;	ld a, 0   ; find end of string 
2191 cd 2e 14			call strlenz 
2194			if DEBUG_FORTH_PUSH 
2194						DMARK "PQ2" 
2194 f5				push af  
2195 3a a9 21			ld a, (.dmark)  
2198 32 68 fe			ld (debug_mark),a  
219b 3a aa 21			ld a, (.dmark+1)  
219e 32 69 fe			ld (debug_mark+1),a  
21a1 3a ab 21			ld a, (.dmark+2)  
21a4 32 6a fe			ld (debug_mark+2),a  
21a7 18 03			jr .pastdmark  
21a9 ..			.dmark: db "PQ2"  
21ac f1			.pastdmark: pop af  
21ad			endm  
# End of macro DMARK
21ad				CALLMONITOR 
21ad cd 6c fe			call debug_vector  
21b0				endm  
# End of macro CALLMONITOR
21b0			endif	 
21b0 eb				ex de, hl 
21b1 e1				pop hl   ; get ptr to start of string 
21b2			if DEBUG_FORTH_PUSH 
21b2						DMARK "PQ3" 
21b2 f5				push af  
21b3 3a c7 21			ld a, (.dmark)  
21b6 32 68 fe			ld (debug_mark),a  
21b9 3a c8 21			ld a, (.dmark+1)  
21bc 32 69 fe			ld (debug_mark+1),a  
21bf 3a c9 21			ld a, (.dmark+2)  
21c2 32 6a fe			ld (debug_mark+2),a  
21c5 18 03			jr .pastdmark  
21c7 ..			.dmark: db "PQ3"  
21ca f1			.pastdmark: pop af  
21cb			endm  
# End of macro DMARK
21cb				CALLMONITOR 
21cb cd 6c fe			call debug_vector  
21ce				endm  
# End of macro CALLMONITOR
21ce			endif	 
21ce 19				add hl,de 
21cf			if DEBUG_FORTH_PUSH 
21cf						DMARK "PQE" 
21cf f5				push af  
21d0 3a e4 21			ld a, (.dmark)  
21d3 32 68 fe			ld (debug_mark),a  
21d6 3a e5 21			ld a, (.dmark+1)  
21d9 32 69 fe			ld (debug_mark+1),a  
21dc 3a e6 21			ld a, (.dmark+2)  
21df 32 6a fe			ld (debug_mark+2),a  
21e2 18 03			jr .pastdmark  
21e4 ..			.dmark: db "PQE"  
21e7 f1			.pastdmark: pop af  
21e8			endm  
# End of macro DMARK
21e8				CALLMONITOR 
21e8 cd 6c fe			call debug_vector  
21eb				endm  
# End of macro CALLMONITOR
21eb			endif	 
21eb			 
21eb 2b				dec hl    ; see if there is an optional trailing double quote 
21ec 7e				ld a,(hl) 
21ed fe 22			cp '"' 
21ef 20 03			jr nz, .strnoq 
21f1 3e 00			ld a, 0      ; get rid of double quote 
21f3 77				ld (hl), a 
21f4 23			.strnoq: inc hl 
21f5			 
21f5 3e 00			ld a, 0 
21f7 77				ld (hl), a     ; add null term and get rid of trailing double quote 
21f8			 
21f8 13				inc de ; add one for the type string 
21f9 13				inc de ; add one for null term??? 
21fa			 
21fa				; tos is get string pointer again 
21fa				; de contains space to allocate 
21fa				 
21fa d5				push de 
21fb			 
21fb eb				ex de, hl 
21fc			 
21fc				;push af 
21fc			 
21fc			if DEBUG_FORTH_PUSH 
21fc						DMARK "PHm" 
21fc f5				push af  
21fd 3a 11 22			ld a, (.dmark)  
2200 32 68 fe			ld (debug_mark),a  
2203 3a 12 22			ld a, (.dmark+1)  
2206 32 69 fe			ld (debug_mark+1),a  
2209 3a 13 22			ld a, (.dmark+2)  
220c 32 6a fe			ld (debug_mark+2),a  
220f 18 03			jr .pastdmark  
2211 ..			.dmark: db "PHm"  
2214 f1			.pastdmark: pop af  
2215			endm  
# End of macro DMARK
2215				CALLMONITOR 
2215 cd 6c fe			call debug_vector  
2218				endm  
# End of macro CALLMONITOR
2218			endif	 
2218 cd 97 14			call malloc	; on ret hl now contains allocated memory 
221b				if DEBUG_FORTH_MALLOC_GUARD 
221b cc 04 5e				call z,malloc_error 
221e				endif 
221e			 
221e				 
221e c1				pop bc    ; get length 
221f d1				pop de   ;  get string start    
2220			 
2220				; hl has destination from malloc 
2220			 
2220 eb				ex de, hl    ; prep for ldir 
2221			 
2221 d5				push de   ; save malloc area for DSP later 
2222				;push hl   ; save malloc area for DSP later 
2222			 
2222			if DEBUG_FORTH_PUSH 
2222						DMARK "PHc" 
2222 f5				push af  
2223 3a 37 22			ld a, (.dmark)  
2226 32 68 fe			ld (debug_mark),a  
2229 3a 38 22			ld a, (.dmark+1)  
222c 32 69 fe			ld (debug_mark+1),a  
222f 3a 39 22			ld a, (.dmark+2)  
2232 32 6a fe			ld (debug_mark+2),a  
2235 18 03			jr .pastdmark  
2237 ..			.dmark: db "PHc"  
223a f1			.pastdmark: pop af  
223b			endm  
# End of macro DMARK
223b				CALLMONITOR 
223b cd 6c fe			call debug_vector  
223e				endm  
# End of macro CALLMONITOR
223e			endif	 
223e			 
223e			 
223e ed b0			ldir 
2240			 
2240			 
2240				; push malloc to data stack     macro?????  
2240			 
2240				FORTH_DSP_NEXT 
2240 cd 94 20			call macro_forth_dsp_next 
2243				endm 
# End of macro FORTH_DSP_NEXT
2243			 
2243				; save value and type 
2243			 
2243 2a eb f9			ld hl, (cli_data_sp) 
2246			 
2246				; save item type 
2246 3e 01			ld a,  DS_TYPE_STR 
2248 77				ld (hl), a 
2249 23				inc hl 
224a			 
224a				; get malloc word off stack 
224a d1				pop de 
224b 73				ld (hl), e 
224c 23				inc hl 
224d 72				ld (hl), d 
224e			 
224e			 
224e			 
224e			if DEBUG_FORTH_PUSH 
224e 2a eb f9			ld hl, (cli_data_sp) 
2251						DMARK "PHS" 
2251 f5				push af  
2252 3a 66 22			ld a, (.dmark)  
2255 32 68 fe			ld (debug_mark),a  
2258 3a 67 22			ld a, (.dmark+1)  
225b 32 69 fe			ld (debug_mark+1),a  
225e 3a 68 22			ld a, (.dmark+2)  
2261 32 6a fe			ld (debug_mark+2),a  
2264 18 03			jr .pastdmark  
2266 ..			.dmark: db "PHS"  
2269 f1			.pastdmark: pop af  
226a			endm  
# End of macro DMARK
226a				CALLMONITOR 
226a cd 6c fe			call debug_vector  
226d				endm  
# End of macro CALLMONITOR
226d			;	ex de,hl 
226d			endif	 
226d				; in case of spaces, skip the ptr past the copied string 
226d				;pop af 
226d				;ld (cli_origptr),hl 
226d			 
226d c9				ret 
226e			 
226e			 
226e			 
226e			; TODO ascii push input onto stack given hl to start of input 
226e			 
226e			; identify type 
226e			; if starts with a " then a string 
226e			; otherwise it is a number 
226e			;  
226e			; if a string 
226e			;     scan for ending " to get length of string to malloc for + 1 
226e			;     malloc 
226e			;     put pointer to string on stack first byte flags as string 
226e			; 
226e			; else a number 
226e			;    look for number format identifier 
226e			;    $xx hex 
226e			;    %xxxxx bin 
226e			;    xxxxx decimal 
226e			;    convert number to 16bit word.  
226e			;    malloc word + 1 with flag to identiy as num 
226e			;    put pointer to number on stack 
226e			;   
226e			;  
226e			  
226e			forth_apush: 
226e				; kernel push 
226e			 
226e			if DEBUG_FORTH_PUSH 
226e						DMARK "PSH" 
226e f5				push af  
226f 3a 83 22			ld a, (.dmark)  
2272 32 68 fe			ld (debug_mark),a  
2275 3a 84 22			ld a, (.dmark+1)  
2278 32 69 fe			ld (debug_mark+1),a  
227b 3a 85 22			ld a, (.dmark+2)  
227e 32 6a fe			ld (debug_mark+2),a  
2281 18 03			jr .pastdmark  
2283 ..			.dmark: db "PSH"  
2286 f1			.pastdmark: pop af  
2287			endm  
# End of macro DMARK
2287				CALLMONITOR 
2287 cd 6c fe			call debug_vector  
228a				endm  
# End of macro CALLMONITOR
228a			endif	 
228a				; identify input type 
228a			 
228a 7e				ld a,(hl) 
228b fe 22			cp '"' 
228d 28 0a			jr z, .fapstr 
228f fe 24			cp '$' 
2291 ca b9 22			jp z, .faphex 
2294 fe 25			cp '%' 
2296 ca a1 22			jp z, .fapbin 
2299			;	cp 'b' 
2299			;	jp z, .fabin 
2299				; else decimal 
2299			 
2299				; TODO do decimal conversion 
2299				; decimal is stored as a 16bit word 
2299			 
2299				; by default everything is a string if type is not detected 
2299			.fapstr: ; 
2299 fe 22			cp '"' 
229b 20 01			jr nz, .strnoqu 
229d 23				inc hl 
229e			.strnoqu: 
229e c3 73 21			jp forth_push_str 
22a1			 
22a1			 
22a1			 
22a1			.fapbin:    ; push a binary string.  
22a1 11 00 00			ld de, 0   ; hold a 16bit value 
22a4			 
22a4 23			.fapbinshift:	inc hl  
22a5 7e				ld a,(hl) 
22a6 fe 00			cp 0     ; done scanning  
22a8 28 0b			jr z, .fapbdone  	; got it in HL so push  
22aa			 
22aa				; left shift de 
22aa eb				ex de, hl	 
22ab 29				add hl, hl 
22ac			 
22ac				; is 1 
22ac fe 31			cp '1' 
22ae 20 02			jr nz, .binzero 
22b0 cb 4d			bit 1, l 
22b2			.binzero: 
22b2 eb				ex de, hl	 ; save current de 
22b3 18 ef			jr .fapbinshift 
22b5			 
22b5			.fapbdone: 
22b5 eb				ex de, hl 
22b6 c3 05 21			jp forth_push_numhl 
22b9			 
22b9			 
22b9			.faphex:   ; hex is always stored as a 16bit word 
22b9				; skip number prefix 
22b9 23				inc hl 
22ba				; turn ascii into number 
22ba cd 87 13			call get_word_hl	; ret 16bit word in hl 
22bd			 
22bd c3 05 21			jp forth_push_numhl 
22c0			 
22c0 00				 nop 
22c1			 
22c1			.fabin:   ; TODO bin conversion 
22c1			 
22c1			 
22c1 c9				ret 
22c2			 
22c2			 
22c2			; get either a string ptr or a 16bit word from the data stack 
22c2			 
22c2			FORTH_DSP: macro 
22c2				call macro_forth_dsp 
22c2				endm 
22c2			 
22c2			macro_forth_dsp: 
22c2				; data stack pointer points to current word on tos 
22c2			 
22c2 2a eb f9			ld hl,(cli_data_sp) 
22c5			 
22c5				if DEBUG_FORTH_PUSH 
22c5						DMARK "DSP" 
22c5 f5				push af  
22c6 3a da 22			ld a, (.dmark)  
22c9 32 68 fe			ld (debug_mark),a  
22cc 3a db 22			ld a, (.dmark+1)  
22cf 32 69 fe			ld (debug_mark+1),a  
22d2 3a dc 22			ld a, (.dmark+2)  
22d5 32 6a fe			ld (debug_mark+2),a  
22d8 18 03			jr .pastdmark  
22da ..			.dmark: db "DSP"  
22dd f1			.pastdmark: pop af  
22de			endm  
# End of macro DMARK
22de			 
22de cd 37 5e				call display_data_sp 
22e1				;call break_point_state 
22e1				;rst 030h 
22e1				CALLMONITOR 
22e1 cd 6c fe			call debug_vector  
22e4				endm  
# End of macro CALLMONITOR
22e4				endif 
22e4			 
22e4 c9				ret 
22e5			 
22e5			; return hl to start of value on stack 
22e5			 
22e5			FORTH_DSP_VALUE: macro 
22e5				call macro_forth_dsp_value 
22e5				endm 
22e5			 
22e5			macro_forth_dsp_value: 
22e5			 
22e5				FORTH_DSP 
22e5 cd c2 22			call macro_forth_dsp 
22e8				endm 
# End of macro FORTH_DSP
22e8			 
22e8 d5				push de 
22e9			 
22e9 23				inc hl ; skip type 
22ea			 
22ea 5e				ld e, (hl) 
22eb 23				inc hl 
22ec 56				ld d, (hl) 
22ed eb				ex de,hl  
22ee			 
22ee d1				pop de 
22ef			 
22ef c9				ret 
22f0			 
22f0			; return hl to start of value to second item on stack 
22f0			 
22f0			FORTH_DSP_VALUEM1: macro 
22f0				call macro_forth_dsp_value_m1 
22f0				endm 
22f0			 
22f0			macro_forth_dsp_value_m1: 
22f0			 
22f0				FORTH_DSP 
22f0 cd c2 22			call macro_forth_dsp 
22f3				endm 
# End of macro FORTH_DSP
22f3			 
22f3 2b				dec hl 
22f4 2b				dec hl 
22f5			;	dec hl 
22f5			 
22f5 d5				push de 
22f6			 
22f6 5e				ld e, (hl) 
22f7 23				inc hl 
22f8 56				ld d, (hl) 
22f9 eb				ex de,hl  
22fa			 
22fa d1				pop de 
22fb			 
22fb c9				ret 
22fc			 
22fc				 
22fc			 
22fc			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
22fc			 
22fc			FORTH_DSP_POP: macro 
22fc				call macro_forth_dsp_pop 
22fc				endm 
22fc			 
22fc			 
22fc			; get the tos data type 
22fc			 
22fc			FORTH_DSP_TYPE:   macro 
22fc			 
22fc				;FORTH_DSP_VALUE 
22fc				FORTH_DSP 
22fc				 
22fc				; hl points to value 
22fc				; check type 
22fc			 
22fc				ld a,(hl) 
22fc			 
22fc				endm 
22fc			 
22fc			; load the tos value into hl 
22fc			 
22fc			 
22fc			FORTH_DSP_VALUEHL:  macro 
22fc				call macro_dsp_valuehl 
22fc				endm 
22fc			 
22fc			 
22fc			 
22fc			macro_dsp_valuehl: 
22fc				FORTH_DSP_VALUE 
22fc cd e5 22			call macro_forth_dsp_value 
22ff				endm 
# End of macro FORTH_DSP_VALUE
22ff			 
22ff				;FORTH_ERR_TOS_NOTNUM 
22ff			 
22ff				;inc hl   ; skip type id 
22ff			 
22ff			;	push de 
22ff			; 
22ff			;	ld e, (hl) 
22ff			;	inc hl 
22ff			;	ld d, (hl) 
22ff			;	ex de,hl  
22ff			 
22ff			;	pop de 
22ff			 
22ff				if DEBUG_FORTH_PUSH 
22ff						DMARK "DVL" 
22ff f5				push af  
2300 3a 14 23			ld a, (.dmark)  
2303 32 68 fe			ld (debug_mark),a  
2306 3a 15 23			ld a, (.dmark+1)  
2309 32 69 fe			ld (debug_mark+1),a  
230c 3a 16 23			ld a, (.dmark+2)  
230f 32 6a fe			ld (debug_mark+2),a  
2312 18 03			jr .pastdmark  
2314 ..			.dmark: db "DVL"  
2317 f1			.pastdmark: pop af  
2318			endm  
# End of macro DMARK
2318				CALLMONITOR 
2318 cd 6c fe			call debug_vector  
231b				endm  
# End of macro CALLMONITOR
231b				endif 
231b c9				ret 
231c			 
231c			forth_apushstrhl:      
231c				; push of string requires use of cli_origptr 
231c				; bodge use 
231c			 
231c				; get current cli_origptr, save, update with temp pointer  
231c ed 5b 3b fa		ld de, (cli_origptr) 
2320 22 3b fa			ld (cli_origptr), hl 
2323 d5				push de 
2324 cd 6e 22			call forth_apush 
2327 d1				pop de 
2328 ed 53 3b fa		ld (cli_origptr), de 
232c c9			        ret	 
232d			 
232d			 
232d			; increase loop stack pointer and save hl to it 
232d				 
232d			FORTH_LOOP_NEXT: macro 
232d				call macro_forth_loop_next 
232d				;nop 
232d				endm 
232d			 
232d			macro_forth_loop_next: 
232d				if DEBUG_FORTH_STACK_GUARD 
232d cd 70 72				call check_stacks 
2330				endif 
2330 e5				push hl 
2331 d5				push de 
2332 eb				ex de,hl 
2333 2a ed f9			ld hl,(cli_loop_sp) 
2336 23				inc hl 
2337 23				inc hl 
2338					if DEBUG_FORTH_WORDS 
2338						DMARK "LNX" 
2338 f5				push af  
2339 3a 4d 23			ld a, (.dmark)  
233c 32 68 fe			ld (debug_mark),a  
233f 3a 4e 23			ld a, (.dmark+1)  
2342 32 69 fe			ld (debug_mark+1),a  
2345 3a 4f 23			ld a, (.dmark+2)  
2348 32 6a fe			ld (debug_mark+2),a  
234b 18 03			jr .pastdmark  
234d ..			.dmark: db "LNX"  
2350 f1			.pastdmark: pop af  
2351			endm  
# End of macro DMARK
2351						CALLMONITOR 
2351 cd 6c fe			call debug_vector  
2354				endm  
# End of macro CALLMONITOR
2354					endif 
2354 22 ed f9			ld (cli_loop_sp),hl 
2357 73				ld (hl), e 
2358 23				inc hl 
2359 72				ld (hl), d 
235a d1				pop de    ; been reversed so save a swap on restore 
235b e1				pop hl 
235c				if DEBUG_FORTH_STACK_GUARD 
235c cd 70 72				call check_stacks 
235f				endif 
235f c9				ret 
2360			 
2360			; get current ret stack pointer and save to hl  
2360				 
2360			FORTH_LOOP_TOS: macro 
2360				call macro_forth_loop_tos 
2360				endm 
2360			 
2360			macro_forth_loop_tos: 
2360 d5				push de 
2361 2a ed f9			ld hl,(cli_loop_sp) 
2364 5e				ld e, (hl) 
2365 23				inc hl 
2366 56				ld d, (hl) 
2367 eb				ex de, hl 
2368 d1				pop de 
2369 c9				ret 
236a			 
236a			; pop loop stack pointer 
236a				 
236a			FORTH_LOOP_POP: macro 
236a				call macro_forth_loop_pop 
236a				endm 
236a			 
236a			 
236a			macro_forth_loop_pop: 
236a				if DEBUG_FORTH_STACK_GUARD 
236a					DMARK "LPP" 
236a f5				push af  
236b 3a 7f 23			ld a, (.dmark)  
236e 32 68 fe			ld (debug_mark),a  
2371 3a 80 23			ld a, (.dmark+1)  
2374 32 69 fe			ld (debug_mark+1),a  
2377 3a 81 23			ld a, (.dmark+2)  
237a 32 6a fe			ld (debug_mark+2),a  
237d 18 03			jr .pastdmark  
237f ..			.dmark: db "LPP"  
2382 f1			.pastdmark: pop af  
2383			endm  
# End of macro DMARK
2383 cd 70 72				call check_stacks 
2386					FORTH_CHK_LOOP_UNDER 
2386 e5				push hl 
2387 d5				push de 
2388 2a ed f9			ld hl,(cli_loop_sp) 
238b 11 27 f9			ld de, cli_loop_stack 
238e cd ee 0f			call cmp16 
2391 da 8a 73			jp c, fault_loop_under 
2394 d1				pop de 
2395 e1				pop hl 
2396				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2396				endif 
2396 e5				push hl 
2397 2a ed f9			ld hl,(cli_loop_sp) 
239a 2b				dec hl 
239b 2b				dec hl 
239c 22 ed f9			ld (cli_loop_sp), hl 
239f				; TODO do stack underflow checks 
239f e1				pop hl 
23a0				if DEBUG_FORTH_STACK_GUARD 
23a0 cd 70 72				call check_stacks 
23a3					FORTH_CHK_LOOP_UNDER 
23a3 e5				push hl 
23a4 d5				push de 
23a5 2a ed f9			ld hl,(cli_loop_sp) 
23a8 11 27 f9			ld de, cli_loop_stack 
23ab cd ee 0f			call cmp16 
23ae da 8a 73			jp c, fault_loop_under 
23b1 d1				pop de 
23b2 e1				pop hl 
23b3				endm 
# End of macro FORTH_CHK_LOOP_UNDER
23b3				endif 
23b3 c9				ret 
23b4			 
23b4			macro_forth_dsp_pop: 
23b4			 
23b4 e5				push hl 
23b5			 
23b5				; release malloc data 
23b5			 
23b5				if DEBUG_FORTH_STACK_GUARD 
23b5 cd 70 72				call check_stacks 
23b8					FORTH_CHK_DSP_UNDER 
23b8 e5				push hl 
23b9 d5				push de 
23ba 2a eb f9			ld hl,(cli_data_sp) 
23bd 11 25 f7			ld de, cli_data_stack 
23c0 cd ee 0f			call cmp16 
23c3 da 7e 73			jp c, fault_dsp_under 
23c6 d1				pop de 
23c7 e1				pop hl 
23c8				endm 
# End of macro FORTH_CHK_DSP_UNDER
23c8				endif 
23c8				;ld hl,(cli_data_sp) 
23c8			if DEBUG_FORTH_DOT 
23c8				DMARK "DPP" 
23c8 f5				push af  
23c9 3a dd 23			ld a, (.dmark)  
23cc 32 68 fe			ld (debug_mark),a  
23cf 3a de 23			ld a, (.dmark+1)  
23d2 32 69 fe			ld (debug_mark+1),a  
23d5 3a df 23			ld a, (.dmark+2)  
23d8 32 6a fe			ld (debug_mark+2),a  
23db 18 03			jr .pastdmark  
23dd ..			.dmark: db "DPP"  
23e0 f1			.pastdmark: pop af  
23e1			endm  
# End of macro DMARK
23e1				CALLMONITOR 
23e1 cd 6c fe			call debug_vector  
23e4				endm  
# End of macro CALLMONITOR
23e4			endif	 
23e4			 
23e4			 
23e4			if FORTH_ENABLE_DSPPOPFREE 
23e4			 
23e4				FORTH_DSP 
23e4 cd c2 22			call macro_forth_dsp 
23e7				endm 
# End of macro FORTH_DSP
23e7			 
23e7 7e				ld a, (hl) 
23e8 fe 01			cp DS_TYPE_STR 
23ea 20 23			jr nz, .skippopfree 
23ec			 
23ec				FORTH_DSP_VALUEHL 
23ec cd fc 22			call macro_dsp_valuehl 
23ef				endm 
# End of macro FORTH_DSP_VALUEHL
23ef 00				nop 
23f0			if DEBUG_FORTH_DOT 
23f0				DMARK "DPf" 
23f0 f5				push af  
23f1 3a 05 24			ld a, (.dmark)  
23f4 32 68 fe			ld (debug_mark),a  
23f7 3a 06 24			ld a, (.dmark+1)  
23fa 32 69 fe			ld (debug_mark+1),a  
23fd 3a 07 24			ld a, (.dmark+2)  
2400 32 6a fe			ld (debug_mark+2),a  
2403 18 03			jr .pastdmark  
2405 ..			.dmark: db "DPf"  
2408 f1			.pastdmark: pop af  
2409			endm  
# End of macro DMARK
2409				CALLMONITOR 
2409 cd 6c fe			call debug_vector  
240c				endm  
# End of macro CALLMONITOR
240c			endif	 
240c cd 61 15			call free 
240f			.skippopfree: 
240f				 
240f			 
240f			endif 
240f			 
240f			if DEBUG_FORTH_DOT_KEY 
240f				DMARK "DP2" 
240f				CALLMONITOR 
240f			endif	 
240f			 
240f				; move pointer down 
240f			 
240f 2a eb f9			ld hl,(cli_data_sp) 
2412 2b				dec hl 
2413 2b				dec hl 
2414			; PARSEV5 
2414 2b				dec hl 
2415 22 eb f9			ld (cli_data_sp), hl 
2418			 
2418				if DEBUG_FORTH_STACK_GUARD 
2418 cd 70 72				call check_stacks 
241b					FORTH_CHK_DSP_UNDER 
241b e5				push hl 
241c d5				push de 
241d 2a eb f9			ld hl,(cli_data_sp) 
2420 11 25 f7			ld de, cli_data_stack 
2423 cd ee 0f			call cmp16 
2426 da 7e 73			jp c, fault_dsp_under 
2429 d1				pop de 
242a e1				pop hl 
242b				endm 
# End of macro FORTH_CHK_DSP_UNDER
242b				endif 
242b			 
242b e1				pop hl 
242c			 
242c c9				ret 
242d			 
242d			getwordathl: 
242d				; hl points to an address 
242d				; load hl with the word at that address 
242d			 
242d d5				push de 
242e			 
242e 5e				ld e, (hl) 
242f 23				inc hl 
2430 56				ld d, (hl) 
2431 eb				ex de, hl 
2432			 
2432 d1				pop de 
2433 c9				ret 
2434			 
2434			 
2434			 
2434			 
2434			 
2434			; eof 
2434			 
# End of file forth_stackopsv5.asm
2434			endif 
2434			 
2434			loadwordinhl:	 
2434			 
2434 d5				push de 
2435			 
2435 5e				ld e, (hl) 
2436 23				inc hl 
2437 56				ld d, (hl) 
2438 eb				ex de,hl  
2439			 
2439 d1				pop de 
243a			 
243a c9				ret 
243b			 
243b			user_word_eol:  
243b				; hl contains the pointer to where to create a linked list item from the end 
243b				; of the user dict to continue on at the system word dict 
243b				 
243b				; poke the stub of the word list linked list to repoint to rom words 
243b			 
243b				; stub format 
243b				; db   word id 
243b				; dw    link to next word 
243b			        ; db char length of token 
243b				; db string + 0 term 
243b				; db exec code....  
243b			 
243b 3e 00			ld a, WORD_SYS_ROOT     ; root word 
243d 77				ld (hl), a		; word id 
243e 23				inc hl 
243f			 
243f 11 0a 26			ld de, sysdict 
2442 73				ld (hl), e		; next word link ie system dict 
2443 23				inc hl 
2444 72				ld (hl), d		; next word link ie system dict 
2445 23				inc hl	 
2446			 
2446			;	ld (hl), sysdict		; next word link ie system dict 
2446			;	inc hl 
2446			;	inc hl 
2446			 
2446			;	inc hl 
2446			;	inc hl 
2446			 
2446 3e 02			ld a, 2			; word length is 0 
2448 77				ld (hl), a	 
2449 23				inc hl 
244a			 
244a 3e 7e			ld a, '~'			; word length is 0 
244c 77				ld (hl), a	 
244d 23				inc hl 
244e 3e 00			ld a, 0			; save empty word 
2450 77				ld (hl), a 
2451			 
2451 c9				ret 
2452			 
2452				 
2452			 
2452			forthexec_cleanup: 
2452				FORTH_RSP_POP 
2452 cd cd 20			call macro_forth_rsp_pop 
2455				endm 
# End of macro FORTH_RSP_POP
2455 c9				ret 
2456			 
2456			forth_call_hl: 
2456				; taking hl 
2456 e5				push hl 
2457 c9				ret 
2458			 
2458			; this is called to reset Forth system but keep existing uwords etc 
2458			 
2458			forth_warmstart: 
2458				; setup stack over/under flow checks 
2458				if DEBUG_FORTH_STACK_GUARD 
2458 cd 56 72				call chk_stk_init 
245b				endif 
245b			 
245b				; init stack pointers  - * these stacks go upwards *  
245b 21 a9 f9			ld hl, cli_ret_stack 
245e 22 ef f9			ld (cli_ret_sp), hl	 
2461				; set bottom of stack 
2461 3e 00			ld a,0 
2463 77				ld (hl),a 
2464 23				inc hl 
2465 77				ld (hl),a 
2466			 
2466 21 25 f7			ld hl, cli_data_stack 
2469 22 eb f9			ld (cli_data_sp), hl	 
246c				; set bottom of stack 
246c 3e 00			ld a,0 
246e 77				ld (hl),a 
246f 23				inc hl 
2470 77				ld (hl),a 
2471			 
2471 21 27 f9			ld hl, cli_loop_stack 
2474 22 ed f9			ld (cli_loop_sp), hl	 
2477				; set bottom of stack 
2477 3e 00			ld a,0 
2479 77				ld (hl),a 
247a 23				inc hl 
247b 77				ld (hl),a 
247c			 
247c				; init extent of current open file 
247c			 
247c 3e 00			ld a, 0 
247e 32 67 fa			ld (store_openext), a 
2481			 
2481 c9				ret 
2482			 
2482			 
2482			 
2482			; Cold Start - this is called to setup the whole Forth system 
2482			 
2482			forth_init: 
2482			 
2482				; setup stack over/under flow checks 
2482			 
2482			;	if DEBUG_FORTH_STACK_GUARD 
2482			;		call chk_stk_init 
2482			;	endif 
2482			 
2482				; enable auto display updates (slow.....) 
2482			 
2482 3e 01			ld a, 1 
2484 32 39 fa			ld (cli_autodisplay), a 
2487			 
2487				; if storage is in use disable long reads for now 
2487 3e 00			ld a, 0 
2489 32 72 fa			ld (store_longread), a 
248c			 
248c			 
248c				; show start up screen 
248c			 
248c cd 9c 0d			call clear_display 
248f			 
248f 3e 00			ld a,0 
2491 32 5b fa			ld (f_cursor_ptr), a 
2494			 
2494				; set start of word list in start of ram - for use when creating user words 
2494			 
2494 21 00 80			ld hl, baseram 
2497 22 bb f4			ld (os_last_new_uword), hl 
249a cd 3b 24			call user_word_eol 
249d				 
249d			;		call display_data_sp 
249d			;		call next_page_prompt 
249d			 
249d			 
249d			 
249d			 
249d c9				ret 
249e			 
249e .. 00		.bootforth: db " Forth Kernel Init ",0 
24b2			 
24b2			; TODO push to stack 
24b2			 
24b2			;  
24b2			 
24b2			if FORTH_PARSEV2 
24b2			 
24b2			 
24b2				include "forth_parserv2.asm" 
24b2			 
24b2			endif 
24b2			 
24b2			 
24b2			; parse cli version 1 
24b2			 
24b2			if FORTH_PARSEV1 
24b2			 
24b2			 
24b2			 
24b2			      include "forth_parserv1.asm" 
24b2			endif 
24b2				 
24b2			if FORTH_PARSEV3 
24b2			 
24b2			 
24b2			 
24b2			      include "forth_parserv3.asm" 
24b2				include "forth_wordsv3.asm" 
24b2			endif 
24b2			 
24b2			if FORTH_PARSEV4 
24b2			 
24b2			 
24b2			 
24b2			      include "forth_parserv4.asm" 
24b2				include "forth_wordsv4.asm" 
24b2			endif 
24b2			 
24b2			if FORTH_PARSEV5 
24b2			 
24b2			 
24b2			 
24b2			      include "forth_parserv5.asm" 
24b2			 
24b2			 
24b2			; A better parser without using malloc and string copies all over the place.  
24b2			; Exec in situ should be faster 
24b2			 
24b2			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
24b2			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
24b2			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
24b2			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
24b2			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
24b2			WORD_SYS_END: equ 0   ; Opcode for all user words 
24b2			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
24b2			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
24b2			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
24b2			 
24b2			; Core word preamble macro 
24b2			 
24b2			CWHEAD:   macro nxtword opcode lit len opflags 
24b2				db WORD_SYS_CORE+opcode             
24b2				; internal op code number 
24b2				dw nxtword            
24b2				; link to next dict word block 
24b2				db len + 1 
24b2				; literal length of dict word inc zero term 
24b2				db lit,0              
24b2				; literal dict word 
24b2			        ; TODO db opflags        
24b2				endm 
24b2			 
24b2			 
24b2			NEXTW: macro  
24b2				jp macro_next 
24b2				endm 
24b2			 
24b2			macro_next: 
24b2			if DEBUG_FORTH_PARSE_KEY 
24b2				DMARK "NXT" 
24b2				CALLMONITOR 
24b2			endif	 
24b2			;	inc hl  ; skip token null term  
24b2 ed 4b 3d fa		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
24b6 ed 5b 3b fa		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
24ba 2a bf f4			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
24bd			if DEBUG_FORTH_PARSE_KEY 
24bd				DMARK "}AA" 
24bd				CALLMONITOR 
24bd			endif	 
24bd c3 c0 25			jp execnext 
24c0				;jp exec1 
24c0			       
24c0			 
24c0			 
24c0			; Another go at the parser to compile  
24c0			 
24c0			 
24c0			; TODO rework parser to change all of the string words to byte tokens 
24c0			; TODO do a search for  
24c0			 
24c0			; TODO first run normal parser to zero term sections 
24c0			; TODO for each word do a token look up to get the op code 
24c0			; TODO need some means to flag to the exec that this is a byte code form    
24c0			 
24c0			 
24c0			forthcompile: 
24c0			 
24c0			; 
24c0			; line parse: 
24c0			;       parse raw input buffer 
24c0			;       tokenise the words 
24c0			;       malloc new copy (for looping etc) 
24c0			;       copy to malloc + current pc in line to start of string and add line term 
24c0			;       save on new rsp 
24c0			; 
24c0			 
24c0			; hl to point to the line to tokenise 
24c0			 
24c0			;	push hl 
24c0 22 bf f4			ld (os_tok_ptr), hl  ; save ptr to string 
24c3			 
24c3			;	ld a,0		; string term on input 
24c3			;	call strlent 
24c3			 
24c3			;	ld (os_tok_len), hl	 ; save string length 
24c3			 
24c3			;if DEBUG_FORTH_TOK 
24c3			;	ex de,hl		 
24c3			;endif 
24c3			 
24c3			;	pop hl 		; get back string pointer 
24c3			 
24c3			if DEBUG_FORTH_TOK 
24c3						DMARK "TOc" 
24c3				CALLMONITOR 
24c3			endif 
24c3 7e			.cptoken2:    ld a,(hl) 
24c4 23				inc hl 
24c5 fe 7f			cp FORTH_END_BUFFER 
24c7 28 29			jr z, .cptokendone2 
24c9 fe 00			cp 0 
24cb 28 25			jr z, .cptokendone2 
24cd fe 22			cp '"' 
24cf 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
24d1 fe 20			cp ' ' 
24d3 20 ee			jr nz,  .cptoken2 
24d5			 
24d5			; TODO consume comments held between ( and ) 
24d5			 
24d5				; we have a space so change to zero term for dict match later 
24d5 2b				dec hl 
24d6 3e 00			ld a,0 
24d8 77				ld (hl), a 
24d9 23				inc hl 
24da 18 e7			jr .cptoken2 
24dc				 
24dc			 
24dc			.cptokenstr2: 
24dc				; skip all white space until either eol (because forgot to term) or end double quote 
24dc			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
24dc				;inc hl ; skip current double quote 
24dc 7e				ld a,(hl) 
24dd 23				inc hl 
24de fe 22			cp '"' 
24e0 28 e1			jr z, .cptoken2 
24e2 fe 7f			cp FORTH_END_BUFFER 
24e4 28 0c			jr z, .cptokendone2 
24e6 fe 00			cp 0 
24e8 28 08			jr z, .cptokendone2 
24ea fe 20			cp ' ' 
24ec 28 02			jr z, .cptmp2 
24ee 18 ec			jr .cptokenstr2 
24f0			 
24f0			.cptmp2:	; we have a space so change to zero term for dict match later 
24f0				;dec hl 
24f0				;ld a,"-"	; TODO remove this when working 
24f0				;ld (hl), a 
24f0				;inc hl 
24f0 18 ea			jr .cptokenstr2 
24f2			 
24f2			.cptokendone2: 
24f2				;inc hl 
24f2 3e 7f			ld a, FORTH_END_BUFFER 
24f4 77				ld (hl),a 
24f5 23				inc hl 
24f6 3e 21			ld a, '!' 
24f8 77				ld (hl),a 
24f9			 
24f9 2a bf f4			ld hl,(os_tok_ptr) 
24fc			         
24fc			if DEBUG_FORTH_TOK 
24fc						DMARK "Tc1" 
24fc				CALLMONITOR 
24fc			endif 
24fc			 
24fc				; push exec string to top of return stack 
24fc				FORTH_RSP_NEXT 
24fc cd ac 20			call macro_forth_rsp_next 
24ff				endm 
# End of macro FORTH_RSP_NEXT
24ff c9				ret 
2500			 
2500			; Another go at the parser need to simplify the process 
2500			 
2500			forthparse: 
2500			 
2500			; 
2500			; line parse: 
2500			;       parse raw input buffer 
2500			;       tokenise the words 
2500			;       malloc new copy (for looping etc) 
2500			;       copy to malloc + current pc in line to start of string and add line term 
2500			;       save on new rsp 
2500			; 
2500			 
2500			; hl to point to the line to tokenise 
2500			 
2500			;	push hl 
2500 22 bf f4			ld (os_tok_ptr), hl  ; save ptr to string 
2503			 
2503			;	ld a,0		; string term on input 
2503			;	call strlent 
2503			 
2503			;	ld (os_tok_len), hl	 ; save string length 
2503			 
2503			;if DEBUG_FORTH_TOK 
2503			;	ex de,hl		 
2503			;endif 
2503			 
2503			;	pop hl 		; get back string pointer 
2503			 
2503			if DEBUG_FORTH_TOK 
2503						DMARK "TOK" 
2503				CALLMONITOR 
2503			endif 
2503 7e			.ptoken2:    ld a,(hl) 
2504 23				inc hl 
2505 fe 7f			cp FORTH_END_BUFFER 
2507 28 29			jr z, .ptokendone2 
2509 fe 00			cp 0 
250b 28 25			jr z, .ptokendone2 
250d fe 22			cp '"' 
250f 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2511 fe 20			cp ' ' 
2513 20 ee			jr nz,  .ptoken2 
2515			 
2515			; TODO consume comments held between ( and ) 
2515			 
2515				; we have a space so change to zero term for dict match later 
2515 2b				dec hl 
2516 3e 00			ld a,0 
2518 77				ld (hl), a 
2519 23				inc hl 
251a 18 e7			jr .ptoken2 
251c				 
251c			 
251c			.ptokenstr2: 
251c				; skip all white space until either eol (because forgot to term) or end double quote 
251c			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
251c				;inc hl ; skip current double quote 
251c 7e				ld a,(hl) 
251d 23				inc hl 
251e fe 22			cp '"' 
2520 28 e1			jr z, .ptoken2 
2522 fe 7f			cp FORTH_END_BUFFER 
2524 28 0c			jr z, .ptokendone2 
2526 fe 00			cp 0 
2528 28 08			jr z, .ptokendone2 
252a fe 20			cp ' ' 
252c 28 02			jr z, .ptmp2 
252e 18 ec			jr .ptokenstr2 
2530			 
2530			.ptmp2:	; we have a space so change to zero term for dict match later 
2530				;dec hl 
2530				;ld a,"-"	; TODO remove this when working 
2530				;ld (hl), a 
2530				;inc hl 
2530 18 ea			jr .ptokenstr2 
2532			 
2532			.ptokendone2: 
2532				;inc hl 
2532 3e 7f			ld a, FORTH_END_BUFFER 
2534 77				ld (hl),a 
2535 23				inc hl 
2536 3e 21			ld a, '!' 
2538 77				ld (hl),a 
2539			 
2539 2a bf f4			ld hl,(os_tok_ptr) 
253c			         
253c			if DEBUG_FORTH_TOK 
253c						DMARK "TK1" 
253c				CALLMONITOR 
253c			endif 
253c			 
253c				; push exec string to top of return stack 
253c				FORTH_RSP_NEXT 
253c cd ac 20			call macro_forth_rsp_next 
253f				endm 
# End of macro FORTH_RSP_NEXT
253f c9				ret 
2540			 
2540			; 
2540			;	; malloc size + buffer pointer + if is loop flag 
2540			;	ld hl,(os_tok_len) 		 ; get string length 
2540			; 
2540			;	ld a,l 
2540			; 
2540			;	cp 0			; we dont want to use a null string 
2540			;	ret z 
2540			; 
2540			;;	add 3    ; prefix malloc with buffer for current word ptr 
2540			; 
2540			;	add 5     ; TODO when certain not over writing memory remove 
2540			; 
2540			;		 
2540			; 
2540			;if DEBUG_FORTH_TOK 
2540			;			DMARK "TKE" 
2540			;	CALLMONITOR 
2540			;endif 
2540			; 
2540			;	ld l,a 
2540			;	ld h,0 
2540			;;	push hl   ; save required space for the copy later 
2540			;	call malloc 
2540			;if DEBUG_FORTH_TOK 
2540			;			DMARK "TKM" 
2540			;	CALLMONITOR 
2540			;endif 
2540			;	if DEBUG_FORTH_MALLOC_GUARD 
2540			;		push af 
2540			;		call ishlzero 
2540			;;		ld a, l 
2540			;;		add h 
2540			;;		cp 0 
2540			;		pop af 
2540			;		 
2540			;		call z,malloc_error 
2540			;	endif 
2540			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2540			; 
2540			; 
2540			;if DEBUG_FORTH_TOK 
2540			;			DMARK "TKR" 
2540			;	CALLMONITOR 
2540			;endif 
2540			; 
2540			;	FORTH_RSP_NEXT 
2540			; 
2540			;	;inc hl	 ; go past current buffer pointer 
2540			;	;inc hl 
2540			;	;inc hl   ; and past if loop flag 
2540			;		; TODO Need to set flag  
2540			; 
2540			;	 
2540			;	 
2540			;	ex de,hl	; malloc is dest 
2540			;	ld hl, (os_tok_len) 
2540			;;	pop bc 
2540			;	ld c, l                
2540			;	ld b,0 
2540			;	ld hl, (os_tok_ptr) 
2540			; 
2540			;if DEBUG_FORTH_TOK 
2540			;			DMARK "TKT" 
2540			;	CALLMONITOR 
2540			;endif 
2540			; 
2540			;	; do str cpy 
2540			; 
2540			;	ldir      ; copy byte in hl to de 
2540			; 
2540			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2540			; 
2540			;if DEBUG_FORTH_TOK 
2540			; 
2540			;			DMARK "TKY" 
2540			;	CALLMONITOR 
2540			;endif 
2540			;	;ld a,0 
2540			;	;ld a,FORTH_END_BUFFER 
2540			;	ex de, hl 
2540			;	;dec hl			 ; go back over the space delim at the end of word 
2540			;	;ld (hl),a 
2540			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2540			;	ld a,FORTH_END_BUFFER 
2540			;	ld (hl),a 
2540			;	inc hl 
2540			;	ld a,FORTH_END_BUFFER 
2540			;	ld (hl),a 
2540			; 
2540			;	; init the malloc area data 
2540			;	; set pc for in current area 
2540			;	;ld hl, (os_tok_malloc) 
2540			;	;inc hl 
2540			;	;inc hl 
2540			;	;inc hl 
2540			;	;ex de,hl 
2540			;	;ld hl, (os_tok_malloc) 
2540			;	;ld (hl),e 
2540			;	;inc hl 
2540			;	;ld (hl),d 
2540			; 
2540			; 
2540			;	ld hl,(os_tok_malloc) 
2540			;if DEBUG_FORTH_PARSE_KEY 
2540			;			DMARK "TKU" 
2540			;	CALLMONITOR 
2540			;endif 
2540			; 
2540			;	ret 
2540			 
2540			forthexec: 
2540			 
2540			; line exec: 
2540			; forth parser 
2540			 
2540			; 
2540			;       get current exec line on rsp 
2540			 
2540				FORTH_RSP_TOS 
2540 cd c3 20			call macro_forth_rsp_tos 
2543				endm 
# End of macro FORTH_RSP_TOS
2543			 
2543			;       restore current pc - hl points to malloc of data 
2543			 
2543				;ld e, (hl) 
2543				;inc hl 
2543				;ld d, (hl) 
2543				;ex de,hl 
2543			 
2543			 
2543			exec1: 
2543 22 bf f4			ld (os_tok_ptr), hl 
2546			 
2546				; copy our PC to working vars  
2546 22 3d fa			ld (cli_ptr), hl 
2549 22 3b fa			ld (cli_origptr), hl 
254c			 
254c 7e				ld a,(hl) 
254d fe 7f			cp FORTH_END_BUFFER 
254f c8				ret z 
2550			 
2550				; skip any nulls 
2550			 
2550 fe 00			cp 0 
2552 20 03			jr nz, .execword 
2554 23				inc hl 
2555 18 ec			jr exec1 
2557			 
2557			 
2557			.execword: 
2557			 
2557			 
2557			 
2557			if DEBUG_FORTH_PARSE_KEY 
2557						DMARK "KYQ" 
2557				CALLMONITOR 
2557			endif 
2557			;       while at start of word: 
2557			; get start of dict (in user area first) 
2557			 
2557 21 00 80		ld hl, baseram 
255a			;ld hl, sysdict 
255a 22 3f fa		ld (cli_nextword),hl 
255d			;           match word at pc 
255d			;           exec word 
255d			;           or push to dsp 
255d			;           forward to next token 
255d			;           if line term pop rsp and exit 
255d			;        
255d			 
255d			if DEBUG_FORTH_PARSE_KEY 
255d						DMARK "KYq" 
255d				CALLMONITOR 
255d			endif 
255d			 
255d			; 
255d			; word comp 
255d			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
255d			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
255d			;    move to start of word  
255d			;    compare word to cli_token 
255d			 
255d			.execpnword:	; HL at start of a word in the dictionary to check 
255d			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
255d			;	ld (cli_ptr), hl 
255d			 
255d 2a 3f fa			ld hl,(cli_nextword) 
2560			 
2560 cd 03 26			call forth_tok_next 
2563			; tok next start here 
2563			;	; TODO skip compiled symbol for now 
2563			;	inc hl 
2563			; 
2563			;	; save pointer to next word 
2563			; 
2563			;	; hl now points to the address of the next word pointer  
2563			;	ld e, (hl) 
2563			;	inc hl 
2563			;	ld d, (hl) 
2563			;	inc l 
2563			; 
2563			;	ex de,hl 
2563			;if DEBUG_FORTH_PARSE_NEXTWORD 
2563			;	push bc 
2563			;	ld bc, (cli_nextword) 
2563			;			DMARK "NXW" 
2563			;	CALLMONITOR 
2563			;	pop bc 
2563			;endif 
2563			; tok next end here 
2563 22 3f fa			ld (cli_nextword), hl     ; save for next check if no match on this word 
2566 eb				ex de, hl 
2567			 
2567			 
2567				; save the pointer of the current token - 1 to check against 
2567				 
2567 22 43 fa			ld (cli_token), hl   
256a				; TODO maybe remove below save if no debug 
256a				; save token string ptr for any debug later 
256a 23				inc hl  
256b 22 45 fa			ld (cli_origtoken), hl 
256e 2b				dec hl 
256f				; save pointer to the start of the next dictionay word 
256f 7e				ld a,(hl)   ; get string length 
2570 47				ld b,a 
2571			.execpnwordinc:  
2571 23				inc hl 
2572 10 fd			djnz .execpnwordinc 
2574 22 41 fa			ld (cli_execword), hl      ; save start of this words code 
2577			 
2577				; now check the word token against the string being parsed 
2577			 
2577 2a 43 fa			ld hl,(cli_token) 
257a 23				inc hl     ; skip string length (use zero term instead to end) 
257b 22 43 fa			ld (cli_token), hl 
257e			 
257e			if DEBUG_FORTH_PARSE_KEY 
257e						DMARK "KY2" 
257e			endif 
257e			if DEBUG_FORTH_PARSE_EXEC 
257e				; see if disabled 
257e			 
257e			;	ld a, (os_view_disable) 
257e			;	cp '*' 
257e				ld a, (debug_vector) 
257e				cp $c9   ; RET  
257e				jr z, .skip 
257e			 
257e				push hl 
257e				push hl 
257e				call clear_display 
257e				ld de, .compword 
257e				ld a, display_row_1 
257e				call str_at_display 
257e				pop de 
257e				ld a, display_row_2 
257e				call str_at_display 
257e				ld hl,(cli_ptr) 
257e				ld a,(hl) 
257e			        ld hl, os_word_scratch 
257e				ld (hl),a 
257e				ld a,0 
257e				inc hl 
257e				ld (hl),a 	 
257e				ld de, os_word_scratch 
257e				ld a, display_row_2+10 
257e				call str_at_display 
257e				call update_display 
257e				ld a, 100 
257e				call aDelayInMS 
257e				if DEBUG_FORTH_PARSE_EXEC_SLOW 
257e				call delay250ms 
257e				endif 
257e				pop hl 
257e			.skip:  
257e			endif	 
257e			.execpnchar:    ; compare char between token and string to parse 
257e			 
257e			if DEBUG_FORTH_PARSE_KEY 
257e						DMARK "Ky3" 
257e			endif 
257e			if DEBUG_FORTH_PARSE_EXEC 
257e				; see if disabled 
257e			 
257e			;	ld a, (os_view_disable) 
257e			;	cp '*' 
257e				ld a, (debug_vector) 
257e				cp $C9  ; RET 
257e				jr z, .skip2 
257e			 
257e			;	call clear_display 
257e			ld hl,(cli_token) 
257e			ld a,(hl) 
257e			ld (os_word_scratch),a 
257e				ld hl,(cli_ptr) 
257e			ld a,(hl) 
257e				ld (os_word_scratch+1),a 
257e				ld a,0 
257e				ld (os_word_scratch+2),a 
257e				ld de,os_word_scratch 
257e				ld a,display_row_4 
257e				call str_at_display 
257e				call update_display 
257e			.skip2:  
257e			endif 
257e 2a 43 fa			ld hl,(cli_token) 
2581 7e				ld a, (hl)	 ; char in word token 
2582 23				inc hl 		; move to next char 
2583 22 43 fa			ld (cli_token), hl ; and save it 
2586 47				ld b,a 
2587			 
2587 2a 3d fa			ld hl,(cli_ptr) ;	get the char from the string to parse 
258a 7e				ld a,(hl) 
258b 23				inc hl 
258c 22 3d fa			ld (cli_ptr), hl		; move to next char 
258f cd 25 14			call toUpper 		; make sure the input string matches case 
2592			 
2592			if DEBUG_FORTH_PARSE 
2592			endif 
2592			 
2592				; input stream end of token is a space so get rid of it 
2592			 
2592			;	cp ' ' 
2592			;	jr nz, .pnskipspace 
2592			; 
2592			;	ld a, 0		; make same term as word token term 
2592			; 
2592			;.pnskipspace: 
2592			 
2592			if DEBUG_FORTH_PARSE_KEY 
2592						DMARK "KY7" 
2592			endif 
2592 b8				cp b 
2593 c2 a9 25			jp nz, .execpnskipword	 ; no match so move to next word 
2596				 
2596			;    if same 
2596			;       scan for string terms 0 for token and 32 for input 
2596			 
2596				 
2596			if DEBUG_FORTH_PARSE_KEY 
2596						DMARK "KY8" 
2596			endif 
2596			 
2596 80				add b			 
2597 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2599							; TODO need to make sure last word in zero term string is accounted for 
2599 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
259b			 
259b			 
259b				; at end of both strings so both are exact match 
259b			 
259b			;       skip ptr for next word 
259b			 
259b 2a 3d fa			ld hl,(cli_ptr) 	; at input string term 
259e 23				inc hl			 ; at next char 
259f 22 3d fa			ld (cli_ptr), hl     ; save for next round of the parser 
25a2 22 3b fa			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
25a5				 
25a5				 
25a5			if DEBUG_FORTH_PARSE_KEY 
25a5						DMARK "KY3" 
25a5			endif 
25a5			 
25a5			 
25a5			 
25a5			;       exec code block 
25a5			if DEBUG_FORTH_JP 
25a5				call clear_display 
25a5				call update_display 
25a5				call delay1s 
25a5				ld hl, (cli_execword)     ; save for next check if no match on this word 
25a5				ld a,h 
25a5				ld hl, os_word_scratch 
25a5				call hexout 
25a5				ld hl, (cli_execword)     ; save for next check if no match on this word 
25a5				ld a,l 
25a5				ld hl, os_word_scratch+2 
25a5				call hexout 
25a5				ld hl, os_word_scratch+4 
25a5				ld a,0 
25a5				ld (hl),a 
25a5				ld de,os_word_scratch 
25a5				call str_at_display 
25a5					ld a, display_row_2 
25a5					call str_at_display 
25a5				ld de, (cli_origtoken) 
25a5				ld a, display_row_1+10 
25a5					call str_at_display 
25a5			 
25a5				ld a,display_row_1 
25a5				ld de, .foundword 
25a5				ld a, display_row_3 
25a5				call str_at_display 
25a5				call update_display 
25a5				call delay1s 
25a5				call delay1s 
25a5				call delay1s 
25a5			endif 
25a5			 
25a5			if DEBUG_FORTH_PARSE_KEY 
25a5						DMARK "KYj" 
25a5			endif 
25a5				; TODO save the word pointer in this exec 
25a5			 
25a5 2a 41 fa			ld hl,(cli_execword) 
25a8 e9				jp (hl) 
25a9			 
25a9			 
25a9			;    if not same 
25a9			;	scan for zero term 
25a9			;	get ptr for next word 
25a9			;	goto word comp 
25a9			 
25a9			.execpnskipword:	; get pointer to next word 
25a9 2a 3f fa			ld hl,(cli_nextword) 
25ac			 
25ac 7e				ld a,(hl) 
25ad fe 00			cp WORD_SYS_END 
25af			;	cp 0 
25af 28 09			jr z, .execendofdict			 ; at end of words 
25b1			 
25b1			if DEBUG_FORTH_PARSE_KEY 
25b1						DMARK "KY4" 
25b1			endif 
25b1			if DEBUG_FORTH_PARSE_EXEC 
25b1			 
25b1				; see if disabled 
25b1			 
25b1			;	ld a, (os_view_disable) 
25b1			;	cp '*' 
25b1				ld a,(debug_vector) 
25b1				cp $c9   ; RET 
25b1				jr z, .noskip 
25b1			 
25b1			 
25b1				ld de, .nowordfound 
25b1				ld a, display_row_3 
25b1				call str_at_display 
25b1				call update_display 
25b1				ld a, 100 
25b1				call aDelayInMS 
25b1				 
25b1				if DEBUG_FORTH_PARSE_EXEC_SLOW 
25b1					call delay250ms 
25b1				endif 
25b1			.noskip:  
25b1			 
25b1			endif	 
25b1			 
25b1 2a 3b fa			ld hl,(cli_origptr) 
25b4 22 3d fa			ld (cli_ptr),hl 
25b7			 
25b7			if DEBUG_FORTH_PARSE_KEY 
25b7						DMARK "KY5" 
25b7			endif 
25b7 c3 5d 25			jp .execpnword			; else go to next word 
25ba			 
25ba			.execendofdict:  
25ba			 
25ba			if DEBUG_FORTH_PARSE_KEY 
25ba						DMARK "KYe" 
25ba			endif 
25ba			if DEBUG_FORTH_PARSE_EXEC 
25ba				; see if disabled 
25ba			 
25ba			;	ld a, (os_view_disable) 
25ba			;	cp '*' 
25ba				ld a,(debug_vector) 
25ba				cp $c9   ; ret 
25ba				jr z, .ispskip 
25ba			 
25ba				call clear_display 
25ba				call update_display 
25ba				call delay1s 
25ba				ld de, (cli_origptr) 
25ba				ld a, display_row_1 
25ba				call str_at_display 
25ba				 
25ba				ld de, .enddict 
25ba				ld a, display_row_3 
25ba				call str_at_display 
25ba				call update_display 
25ba				ld a, 100 
25ba				call aDelayInMS 
25ba				if DEBUG_FORTH_PARSE_EXEC_SLOW 
25ba				call delay1s 
25ba				call delay1s 
25ba				call delay1s 
25ba				endif 
25ba			.ispskip:  
25ba				 
25ba			endif	 
25ba			 
25ba			 
25ba			 
25ba				; if the word is not a keyword then must be a literal so push it to stack 
25ba			 
25ba			; push token to stack to end of word 
25ba			 
25ba				STACKFRAME ON $1efe $2f9f 
25ba				if DEBUG_STACK_IMB 
25ba					if ON 
25ba						exx 
25ba						ld de, $1efe 
25ba						ld a, d 
25ba						ld hl, curframe 
25ba						call hexout 
25ba						ld a, e 
25ba						ld hl, curframe+2 
25ba						call hexout 
25ba						ld hl, $1efe 
25ba						push hl 
25ba						ld hl, $2f9f 
25ba						push hl 
25ba						exx 
25ba					endif 
25ba				endif 
25ba			endm 
# End of macro STACKFRAME
25ba			 
25ba 2a bf f4		ld hl,(os_tok_ptr) 
25bd cd 6e 22		call forth_apush 
25c0			 
25c0				STACKFRAMECHK ON $1efe $2f9f 
25c0				if DEBUG_STACK_IMB 
25c0					if ON 
25c0						exx 
25c0						ld hl, $2f9f 
25c0						pop de   ; $2f9f 
25c0						call cmp16 
25c0						jr nz, .spnosame 
25c0						ld hl, $1efe 
25c0						pop de   ; $1efe 
25c0						call cmp16 
25c0						jr z, .spfrsame 
25c0						.spnosame: call showsperror 
25c0						.spfrsame: nop 
25c0						exx 
25c0					endif 
25c0				endif 
25c0			endm 
# End of macro STACKFRAMECHK
25c0			 
25c0			execnext: 
25c0			 
25c0			if DEBUG_FORTH_PARSE_KEY 
25c0						DMARK "KY>" 
25c0			endif 
25c0			; move past token to next word 
25c0			 
25c0 2a bf f4		ld hl, (os_tok_ptr) 
25c3 3e 00		ld a, 0 
25c5 01 ff 00		ld bc, 255     ; input buffer size 
25c8 ed b1		cpir 
25ca			 
25ca			if DEBUG_FORTH_PARSE_KEY 
25ca						DMARK "KY!" 
25ca				CALLMONITOR 
25ca			endif	 
25ca			; TODO this might place hl on the null, so will need to forward on??? 
25ca			;inc hl   ; see if this gets onto the next item 
25ca			 
25ca			 
25ca			; TODO pass a pointer to the buffer to push 
25ca			; TODO call function to push 
25ca			 
25ca			; look for end of input 
25ca			 
25ca			;inc hl 
25ca			;ld a,(hl) 
25ca			;cp FORTH_END_BUFFER 
25ca			;ret z 
25ca			 
25ca			 
25ca c3 43 25		jp exec1 
25cd			 
25cd			 
25cd			 
25cd			 
25cd			 
25cd			 
25cd			 
25cd			 
25cd			 
25cd			findnexttok: 
25cd			 
25cd				; hl is pointer to move 
25cd				; de is the token to locate 
25cd			 
25cd					if DEBUG_FORTH 
25cd						DMARK "NTK" 
25cd						CALLMONITOR 
25cd					endif 
25cd d5				push de 
25ce			 
25ce			.fnt1:	 
25ce				; find first char of token to locate 
25ce			 
25ce 1a				ld a, (de) 
25cf 4f				ld c,a 
25d0 7e				ld a,(hl) 
25d1 cd 25 14			call toUpper 
25d4					if DEBUG_FORTH 
25d4						DMARK "NT1" 
25d4						CALLMONITOR 
25d4					endif 
25d4 b9				cp c 
25d5			 
25d5 28 03			jr z, .fnt2cmpmorefirst	 
25d7			 
25d7				; first char not found move to next char 
25d7			 
25d7 23				inc hl 
25d8 18 f4			jr .fnt1 
25da			 
25da			.fnt2cmpmorefirst:	 
25da				; first char of token found.  
25da			 
25da e5				push hl     ; save start of token just in case it is the right one 
25db d9				exx 
25dc e1				pop hl        ; save it to hl' 
25dd d9				exx 
25de			 
25de			 
25de			.fnt2cmpmore:	 
25de				; compare the rest 
25de				 
25de 23				inc hl 
25df 13				inc de 
25e0				 
25e0 1a				ld a, (de) 
25e1 4f				ld c,a 
25e2 7e				ld a,(hl) 
25e3 cd 25 14			call toUpper 
25e6			 
25e6					if DEBUG_FORTH 
25e6						DMARK "NT2" 
25e6						CALLMONITOR 
25e6					endif 
25e6				; c has the token to find char 
25e6				; a has the mem to scan char 
25e6			 
25e6 b9				cp c 
25e7 28 04			jr z,.fntmatch1 
25e9			 
25e9				; they are not the same 
25e9			 
25e9					if DEBUG_FORTH 
25e9						DMARK "NT3" 
25e9						CALLMONITOR 
25e9					endif 
25e9 d1				pop de	; reset de token to look for 
25ea d5				push de 
25eb 18 e1			jr .fnt1 
25ed				 
25ed			.fntmatch1: 
25ed			 
25ed				; is the same char a null which means we might have a full hit? 
25ed					if DEBUG_FORTH 
25ed						DMARK "NT4" 
25ed						CALLMONITOR 
25ed					endif 
25ed			 
25ed fe 00			cp 0 
25ef 28 0b			jr z, .fntmatchyes 
25f1			 
25f1				; are we at the end of the token to find? 
25f1			 
25f1					if DEBUG_FORTH 
25f1						DMARK "NT5" 
25f1						CALLMONITOR 
25f1					endif 
25f1 3e 00			ld a, 0 
25f3 b9				cp c 
25f4			 
25f4 c2 de 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
25f7			 
25f7					if DEBUG_FORTH 
25f7						DMARK "NT6" 
25f7						CALLMONITOR 
25f7					endif 
25f7				; token to find is exhusted but no match to stream 
25f7			 
25f7				; restore tok pointer and continue on 
25f7 d1				pop de 
25f8 d5				push de 
25f9 c3 ce 25			jp .fnt1 
25fc			 
25fc			 
25fc			.fntmatchyes: 
25fc			 
25fc				; hl now contains the end of the found token 
25fc			 
25fc				; get rid of saved token pointer to find 
25fc			 
25fc d1				pop de 
25fd			 
25fd					if DEBUG_FORTH 
25fd						DMARK "NT9" 
25fd						CALLMONITOR 
25fd					endif 
25fd			 
25fd				; hl will be on the null term so forward on 
25fd			 
25fd				; get back the saved start of the token 
25fd			 
25fd d9				exx 
25fe e5				push hl     ; save start of token just in case it is the right one 
25ff d9				exx 
2600 e1				pop hl        ; save it to hl 
2601			 
2601 c9				ret 
2602			 
2602			 
2602			; LIST needs to find a specific token   
2602			; FORGET needs to find a spefici token 
2602			 
2602			; SAVE needs to find all tokens by flag 
2602			; WORDS just needs to scan through all  by flag 
2602			; UWORDS needs to scan through all by flag 
2602			 
2602			 
2602			; given hl as pointer to start of dict look up string 
2602			; return hl as pointer to start of word block 
2602			; or 0 if not found 
2602			 
2602			forth_find_tok: 
2602 c9				ret 
2603			 
2603			; given hl as pointer to dict structure 
2603			; move to the next dict block structure 
2603			 
2603			forth_tok_next: 
2603				; hl now points to the address of the next word pointer  
2603				; TODO skip compiled symbol for now 
2603			;	push de 
2603 23				inc hl 
2604 5e				ld e, (hl) 
2605 23				inc hl 
2606 56				ld d, (hl) 
2607 23				inc hl 
2608			 
2608 eb				ex de,hl 
2609			if DEBUG_FORTH_PARSE_NEXTWORD 
2609				push bc 
2609				ld bc, (cli_nextword) 
2609						DMARK "NXW" 
2609				CALLMONITOR 
2609				pop bc 
2609			endif 
2609			;	pop de	 
2609 c9				ret 
260a			 
260a			 
260a			 
260a			; eof 
# End of file forth_parserv5.asm
260a				include "forth_wordsv4.asm" 
260a			 
260a			; the core word dictionary v4 
260a			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
260a			 
260a			; this is a linked list for each of the system words used 
260a			; user defined words will follow the same format but will be in ram 
260a			 
260a			 
260a			; 
260a			; 
260a			; define linked list: 
260a			; 
260a			; 1. compiled byte op code 
260a			; 2. len of text word 
260a			; 3. text word 
260a			; 4. ptr to next dictionary word 
260a			; 5. asm, calls etc for the word 
260a			; 
260a			;  if 1 == 0 then last word in dict  
260a			;   
260a			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
260a			;  
260a			;  
260a			; create basic standard set of words 
260a			; 
260a			;  
260a			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
260a			; 2DUP 2DROP 2SWAP  
260a			; @ C@ - get byte  
260a			; ! C! - store byte 
260a			; 0< true if less than zero 
260a			; 0= true if zero 
260a			; < >  
260a			; = true if same 
260a			; variables 
260a			 
260a			 
260a			; Hardware specific words I may need 
260a			; 
260a			; IN OUT  
260a			; calls to key util functions 
260a			; calls to hardward abstraction stuff 
260a			; easy control of frame buffers and lcd i/o 
260a			; keyboard  
260a			 
260a			 
260a			;DICT: macro 
260a			; op_code, len, word, next 
260a			;    word: 
260a			;    db op_code 
260a			;    ds word zero term 
260a			;    dw next 
260a			;    endm 
260a			 
260a			 
260a			 
260a			 
260a			; op code 1 is a flag for user define words which are to be handled differently 
260a			 
260a			 
260a			; 
260a			; 
260a			;    TODO on entry to a word this should be the expected environment 
260a			;    hl - tos value if number then held, if string this is the ptr 
260a			;    de -  
260a			 
260a			 
260a			; opcode ranges 
260a			; 0 - end of word dict 
260a			; 255 - user define words 
260a			 
260a			sysdict: 
260a			include "forth_opcodes.asm" 
260a			; op codes for forth keywords 
260a			; free to use code 0  
260a				OPCODE_HEAP: equ  1 
260a				OPCODE_EXEC: equ 2 
260a				OPCODE_DUP: equ 3 
260a				OPCODE_SWAP: equ 4 
260a				OPCODE_COLN: equ 5 
260a				OPCODE_SCOLN: equ 6 
260a				OPCODE_DROP: equ 7 
260a				OPCODE_DUP2: equ 8 
260a				OPCODE_DROP2: equ 9 
260a				OPCODE_SWAP2: equ 10 
260a				OPCODE_AT: equ 11 
260a				OPCODE_CAT: equ 12 
260a				OPCODE_BANG: equ 13 
260a				OPCODE_CBANG: equ 14 
260a				OPCODE_SCALL: equ 15 
260a				OPCODE_DEPTH: equ 16 
260a				OPCODE_OVER: equ 17 
260a				OPCODE_PAUSE: equ 18 
260a				OPCODE_PAUSES: equ 19 
260a				OPCODE_ROT: equ 20 
260a			;free to reuse	OPCODE_WORDS: equ 21 
260a			        OPCODE_NOT: equ 21 
260a				OPCODE_UWORDS: equ 22 
260a				OPCODE_BP: equ 23 
260a				OPCODE_MONITOR: equ 24  
260a				OPCODE_MALLOC: equ 25 
260a				OPCODE_FREE: equ 26 
260a				OPCODE_LIST: equ 27 
260a				OPCODE_FORGET: equ 28 
260a				OPCODE_NOP: equ 29 
260a				OPCODE_COMO: equ 30 
260a				OPCODE_COMC: equ 31 
260a			;free to reuse	OPCODE_ENDCORE: equ 32 
260a				OPCODE_AFTERSOUND: equ 33 
260a				OPCODE_GP2: equ 34 
260a				OPCODE_GP3: equ 35 
260a				OPCODE_GP4: equ 36 
260a				OPCODE_SIN: equ 37 
260a				OPCODE_SOUT: equ 38 
260a				OPCODE_SPIO: equ 39 
260a				OPCODE_SPICEH: equ 40 
260a				OPCODE_SPIOb: equ 41 
260a				OPCODE_SPII: equ 42 
260a				OPCODE_SESEL: equ 43 
260a				OPCODE_CARTDEV: equ 44 
260a			; free to reuse	OPCODE_ENDDEVICE: equ 45 
260a				OPCODE_FB: equ 46 
260a				OPCODE_EMIT: equ 47 
260a				OPCODE_DOTH: equ 48 
260a				OPCODE_DOTF: equ 49 
260a				OPCODE_DOT: equ 50 
260a				OPCODE_CLS: equ 51 
260a				OPCODE_DRAW: equ 52 
260a				OPCODE_DUMP: equ 53 
260a				OPCODE_CDUMP: equ 54 
260a				OPCODE_DAT: equ 55 
260a				OPCODE_HOME: equ 56 
260a				OPCODE_SPACE: equ 57 
260a				OPCODE_SPACES: equ 58 
260a				OPCODE_SCROLL: equ 59 
260a				OPCODE_ATQ: equ 60 
260a				OPCODE_AUTODSP: equ 61 
260a				OPCODE_MENU: equ 62 
260a			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
260a				OPCODE_THEN: equ 64 
260a				OPCODE_ELSE: equ 65 
260a				OPCODE_DO: equ 66 
260a				OPCODE_LOOP: equ 67 
260a				OPCODE_I: equ 68 
260a				OPCODE_DLOOP: equ 69  
260a				OPCODE_REPEAT: equ 70  
260a				OPCODE_UNTIL: equ 71 
260a				OPCODE_ENDFLOW: equ 72 
260a				OPCODE_WAITK: equ 73 
260a				OPCODE_ACCEPT: equ 74 
260a				OPCODE_EDIT: equ 75 
260a			;free to reuse	OPCODE_ENDKEY: equ 76 
260a				OPCODE_LZERO: equ 77 
260a				OPCODE_TZERO: equ 78 
260a				OPCODE_LESS: equ 79 
260a				OPCODE_GT: equ 80 
260a				OPCODE_EQUAL: equ 81  
260a			;free to reuse	OPCODE_ENDLOGIC: equ 82 
260a				OPCODE_NEG: equ 83 
260a				OPCODE_DIV: equ 84 
260a				OPCODE_MUL: equ 85 
260a				OPCODE_MIN: equ 86 
260a				OPCODE_MAX: equ 87 
260a				OPCODE_RND16: equ 88 
260a				OPCODE_RND8: equ 89 
260a				OPCODE_RND: equ 90 
260a			;free to reuse	OPCODE_ENDMATHS: equ 91  
260a				OPCODE_BYNAME: equ 92 
260a				OPCODE_DIR: equ 93 
260a				OPCODE_SAVE: equ 94 
260a				OPCODE_LOAD: equ 95 
260a				OPCODE_BSAVE: equ 96 
260a				OPCODE_BLOAD: equ 97 
260a				OPCODE_SEO: equ 98  
260a				OPCODE_SEI: equ 99 
260a				OPCODE_SFREE: equ 100 
260a				OPCODE_SIZE: equ 101 
260a				OPCODE_CREATE: equ 102 
260a				OPCODE_APPEND: equ 103 
260a				OPCODE_SDEL: equ 104 
260a				OPCODE_OPEN: equ 105 
260a				OPCODE_READ: equ 106 
260a				OPCODE_EOF: equ 106 
260a				OPCODE_FORMAT: equ 107 
260a				OPCODE_LABEL: equ 108 
260a				OPCODE_LABELS: equ 109 
260a			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
260a				OPCODE_UPPER: equ 111 
260a				OPCODE_LOWER: equ 112 
260a				OPCODE_SUBSTR: equ 113 
260a				OPCODE_LEFT: equ 114 
260a				OPCODE_RIGHT: equ 115 
260a				OPCODE_STR2NUM: equ 116 
260a				OPCODE_NUM2STR: equ 117 
260a				OPCODE_CONCAT: equ 118 
260a				OPCODE_FIND: equ 119 
260a				OPCODE_LEN: equ 120 
260a				OPCODE_CHAR: equ 121 
260a			; free to reuse	OPCODE_STRLEN: equ 122 
260a			; free to reuse	OPCODE_ENDSTR: equ 123 
260a				OPCODE_V0S: equ 124 
260a				OPCODE_V0Q: equ 125 
260a				OPCODE_V1S: equ 126 
260a				OPCODE_V1Q: equ 127 
260a				OPCODE_V2S: equ 128 
260a				OPCODE_V2Q: equ 129 
260a				OPCODE_V3S: equ 130 
260a				OPCODE_V3Q: equ 131 
260a			;free to reuse	OPCODE_END: equ 132 
260a				OPCODE_ZDUP: equ 133 
260a			 
260a			; eof 
# End of file forth_opcodes.asm
260a			 
260a			include "forth_words_core.asm" 
260a			 
260a			; | ## Core Words 
260a			 
260a			;if MALLOC_4 
260a			 
260a			.HEAP: 
260a				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
260a 15				db WORD_SYS_CORE+OPCODE_HEAP             
260b 49 26			dw .EXEC            
260d 05				db 4 + 1 
260e .. 00			db "HEAP",0              
2613				endm 
# End of macro CWHEAD
2613			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2613			; | | u1 - Current number of bytes in the heap 
2613			; | | u2 - Remaining bytes left on the heap 
2613			; | |  
2613			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2613			 
2613			 
2613					if DEBUG_FORTH_WORDS_KEY 
2613						DMARK "HEP" 
2613 f5				push af  
2614 3a 28 26			ld a, (.dmark)  
2617 32 68 fe			ld (debug_mark),a  
261a 3a 29 26			ld a, (.dmark+1)  
261d 32 69 fe			ld (debug_mark+1),a  
2620 3a 2a 26			ld a, (.dmark+2)  
2623 32 6a fe			ld (debug_mark+2),a  
2626 18 03			jr .pastdmark  
2628 ..			.dmark: db "HEP"  
262b f1			.pastdmark: pop af  
262c			endm  
# End of macro DMARK
262c						CALLMONITOR 
262c cd 6c fe			call debug_vector  
262f				endm  
# End of macro CALLMONITOR
262f					endif 
262f 2a 0a 80				ld hl, (free_list )      
2632 11 0e 80				ld de, heap_start 
2635			 
2635 ed 52				sbc hl, de  
2637			 
2637 cd 05 21				call forth_push_numhl 
263a			 
263a			 
263a ed 5b 0a 80			ld de, (free_list )      
263e 21 a5 f1				ld hl, heap_end 
2641			 
2641 ed 52				sbc hl, de 
2643			 
2643 cd 05 21				call forth_push_numhl 
2646					 
2646			 
2646					 
2646			 
2646			 
2646			 
2646					NEXTW 
2646 c3 b2 24			jp macro_next 
2649				endm 
# End of macro NEXTW
2649			;endif 
2649			 
2649			.EXEC: 
2649			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2649			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2649			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2649			;; > > 
2649			;; > >   
2649			;	STACKFRAME OFF $5efe $5f9f 
2649			; 
2649			;		if DEBUG_FORTH_WORDS_KEY 
2649			;			DMARK "EXE" 
2649			;			CALLMONITOR 
2649			;		endif 
2649			; 
2649			;	FORTH_DSP_VALUEHL 
2649			; 
2649			;	FORTH_DSP_POP 
2649			; 
2649			;		if DEBUG_FORTH_WORDS 
2649			;			DMARK "EX1" 
2649			;			CALLMONITOR 
2649			;		endif 
2649			;;	ld e,(hl) 
2649			;;	inc hl 
2649			;;	ld d,(hl) 
2649			;;	ex de,hl 
2649			; 
2649			;;		if DEBUG_FORTH_WORDS 
2649			;;			DMARK "EX2" 
2649			;;			CALLMONITOR 
2649			;;		endif 
2649			;	push hl 
2649			; 
2649			;	;ld a, 0 
2649			;	;ld a, FORTH_END_BUFFER 
2649			;	call strlenz 
2649			;	inc hl   ; include zero term to copy 
2649			;	inc hl   ; include term 
2649			;	inc hl   ; include term 
2649			;	ld b,0 
2649			;	ld c,l 
2649			;	pop hl 
2649			;	ld de, execscratch 
2649			;		if DEBUG_FORTH_WORDS 
2649			;			DMARK "EX3" 
2649			;			CALLMONITOR 
2649			;		endif 
2649			;	ldir 
2649			; 
2649			; 
2649			;	ld hl, execscratch 
2649			; 
2649			;		if DEBUG_FORTH_WORDS 
2649			;			DMARK "EXe" 
2649			;			CALLMONITOR 
2649			;		endif 
2649			; 
2649			;	call forthparse 
2649			;	call forthexec 
2649			;;	call forthexec_cleanup 
2649			;;	call forthparse 
2649			;;	call forthexec 
2649			; 
2649			;	STACKFRAMECHK OFF $5efe $5f9f 
2649			; 
2649			;	; an immediate word so no need to process any more words 
2649			;	ret 
2649			;	NEXTW 
2649			 
2649			; dead code - old version  
2649			;	FORTH_RSP_NEXT 
2649			 
2649			;  
2649			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2649			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2649			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2649			;	push hl 
2649			;	push de 
2649			;	push bc 
2649			; 
2649			; 
2649			;		if DEBUG_FORTH_WORDS_KEY 
2649			;			DMARK "EXR" 
2649			;			CALLMONITOR 
2649			;		endif 
2649			; 
2649			; 
2649			; 
2649			;	;v5 FORTH_DSP_VALUE 
2649			;	FORTH_DSP_VALUEHL 
2649			; 
2649			;	; TODO do string type checks 
2649			; 
2649			;;v5	inc hl   ; skip type 
2649			; 
2649			;	push hl  ; source code  
2649			;		if DEBUG_FORTH_WORDS 
2649			;			DMARK "EX1" 
2649			;			CALLMONITOR 
2649			;		endif 
2649			;	ld a, 0 
2649			;	call strlent 
2649			; 
2649			;	inc hl 
2649			;	inc hl 
2649			;	inc hl 
2649			;	inc hl 
2649			; 
2649			;	push hl    ; size 
2649			; 
2649			;		if DEBUG_FORTH_WORDS 
2649			;			DMARK "EX2" 
2649			;			CALLMONITOR 
2649			;		endif 
2649			;	call malloc 
2649			; 
2649			;	ex de, hl    ; de now contains malloc area 
2649			;	pop bc   	; get byte count 
2649			;	pop hl      ; get string to copy 
2649			; 
2649			;	push de     ; save malloc for free later 
2649			; 
2649			;		if DEBUG_FORTH_WORDS 
2649			;			DMARK "EX3" 
2649			;			CALLMONITOR 
2649			;		endif 
2649			;	ldir       ; duplicate string 
2649			; 
2649			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2649			;	 
2649			;	; TODO fix the parse would be better than this...  
2649			;	ex de, hl 
2649			;	dec hl 
2649			;	ld a, 0 
2649			;	ld (hl), a 
2649			;	dec hl 
2649			;	ld a, ' ' 
2649			;	ld (hl), a 
2649			;	dec hl 
2649			;	ld (hl), a 
2649			; 
2649			;	dec hl 
2649			;	ld (hl), a 
2649			; 
2649			; 
2649			;	FORTH_DSP_POP  
2649			; 
2649			;	pop hl     
2649			;	push hl    ; save malloc area 
2649			; 
2649			;		if DEBUG_FORTH_WORDS 
2649			;			DMARK "EX4" 
2649			;			CALLMONITOR 
2649			;		endif 
2649			; 
2649			;	call forthparse 
2649			;	call forthexec 
2649			;	 
2649			;	pop hl 
2649			;	if DEBUG_FORTH_WORDS 
2649			;		DMARK "EX5" 
2649			;		CALLMONITOR 
2649			;	endif 
2649			; 
2649			;	if FORTH_ENABLE_FREE 
2649			;	call free 
2649			;	endif 
2649			; 
2649			;	if DEBUG_FORTH_WORDS 
2649			;		DMARK "EX6" 
2649			;		CALLMONITOR 
2649			;	endif 
2649			; 
2649			;	pop bc 
2649			;	pop de 
2649			;	pop hl 
2649			;;	FORTH_RSP_POP	  
2649			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2649			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2649			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2649			; 
2649			;	if DEBUG_FORTH_WORDS 
2649			;		DMARK "EX7" 
2649			;		CALLMONITOR 
2649			;	endif 
2649			;	NEXTW 
2649			 
2649			;.STKEXEC: 
2649			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2649			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2649			; 
2649			; 
2649			;		if DEBUG_FORTH_WORDS_KEY 
2649			;			DMARK "STX" 
2649			;			CALLMONITOR 
2649			;		endif 
2649			; 
2649			;	FORTH_DSP_VALUEHL 
2649			; 
2649			;	ld (store_tmp1), hl    ; count 
2649			; 
2649			;	FORTH_DSP_POP 
2649			;.stkexec1: 
2649			;	ld hl, (store_tmp1)   ; count 
2649			;	ld a, 0 
2649			;	cp l 
2649			;	ret z 
2649			; 
2649			;	dec hl 
2649			;	ld (store_tmp1), hl    ; count 
2649			;	 
2649			;	FORTH_DSP_VALUEHL 
2649			;	push hl 
2649			;	 
2649			;		if DEBUG_FORTH_WORDS 
2649			;			DMARK "EXp" 
2649			;			CALLMONITOR 
2649			;		endif 
2649			;	FORTH_DSP_POP 
2649			; 
2649			;	call strlenz 
2649			;	inc hl   ; include zero term to copy 
2649			;	inc hl   ; include zero term to copy 
2649			;	inc hl   ; include zero term to copy 
2649			;	ld b,0 
2649			;	ld c,l 
2649			;	pop hl 
2649			;	ld de, execscratch 
2649			;		if DEBUG_FORTH_WORDS 
2649			;			DMARK "EX3" 
2649			;			CALLMONITOR 
2649			;		endif 
2649			;	ldir 
2649			; 
2649			; 
2649			;	ld hl, execscratch 
2649			; 
2649			;		if DEBUG_FORTH_WORDS 
2649			;			DMARK "EXP" 
2649			;			CALLMONITOR 
2649			;		endif 
2649			; 
2649			;	call forthparse 
2649			;	ld hl, execscratch 
2649			;		if DEBUG_FORTH_WORDS 
2649			;			DMARK "EXx" 
2649			;			CALLMONITOR 
2649			;		endif 
2649			;	call forthexec 
2649			; 
2649			;	jp .stkexec1 
2649			; 
2649			;	ret 
2649			 
2649			 
2649			.DUP: 
2649				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2649 17				db WORD_SYS_CORE+OPCODE_DUP             
264a bf 26			dw .ZDUP            
264c 04				db 3 + 1 
264d .. 00			db "DUP",0              
2651				endm 
# End of macro CWHEAD
2651			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2651			 
2651					if DEBUG_FORTH_WORDS_KEY 
2651						DMARK "DUP" 
2651 f5				push af  
2652 3a 66 26			ld a, (.dmark)  
2655 32 68 fe			ld (debug_mark),a  
2658 3a 67 26			ld a, (.dmark+1)  
265b 32 69 fe			ld (debug_mark+1),a  
265e 3a 68 26			ld a, (.dmark+2)  
2661 32 6a fe			ld (debug_mark+2),a  
2664 18 03			jr .pastdmark  
2666 ..			.dmark: db "DUP"  
2669 f1			.pastdmark: pop af  
266a			endm  
# End of macro DMARK
266a						CALLMONITOR 
266a cd 6c fe			call debug_vector  
266d				endm  
# End of macro CALLMONITOR
266d					endif 
266d			 
266d					FORTH_DSP 
266d cd c2 22			call macro_forth_dsp 
2670				endm 
# End of macro FORTH_DSP
2670			 
2670 7e					ld a, (HL) 
2671 fe 01				cp DS_TYPE_STR 
2673 20 25				jr nz, .dupinum 
2675			 
2675					; push another string 
2675			 
2675					FORTH_DSP_VALUEHL     		 
2675 cd fc 22			call macro_dsp_valuehl 
2678				endm 
# End of macro FORTH_DSP_VALUEHL
2678			 
2678				if DEBUG_FORTH_WORDS 
2678					DMARK "DUs" 
2678 f5				push af  
2679 3a 8d 26			ld a, (.dmark)  
267c 32 68 fe			ld (debug_mark),a  
267f 3a 8e 26			ld a, (.dmark+1)  
2682 32 69 fe			ld (debug_mark+1),a  
2685 3a 8f 26			ld a, (.dmark+2)  
2688 32 6a fe			ld (debug_mark+2),a  
268b 18 03			jr .pastdmark  
268d ..			.dmark: db "DUs"  
2690 f1			.pastdmark: pop af  
2691			endm  
# End of macro DMARK
2691					CALLMONITOR 
2691 cd 6c fe			call debug_vector  
2694				endm  
# End of macro CALLMONITOR
2694				endif 
2694 cd 73 21				call forth_push_str 
2697			 
2697					NEXTW 
2697 c3 b2 24			jp macro_next 
269a				endm 
# End of macro NEXTW
269a			 
269a			 
269a			.dupinum: 
269a					 
269a			 
269a			 
269a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
269a cd fc 22			call macro_dsp_valuehl 
269d				endm 
# End of macro FORTH_DSP_VALUEHL
269d			 
269d				; TODO add floating point number detection 
269d			 
269d				if DEBUG_FORTH_WORDS 
269d					DMARK "DUi" 
269d f5				push af  
269e 3a b2 26			ld a, (.dmark)  
26a1 32 68 fe			ld (debug_mark),a  
26a4 3a b3 26			ld a, (.dmark+1)  
26a7 32 69 fe			ld (debug_mark+1),a  
26aa 3a b4 26			ld a, (.dmark+2)  
26ad 32 6a fe			ld (debug_mark+2),a  
26b0 18 03			jr .pastdmark  
26b2 ..			.dmark: db "DUi"  
26b5 f1			.pastdmark: pop af  
26b6			endm  
# End of macro DMARK
26b6					CALLMONITOR 
26b6 cd 6c fe			call debug_vector  
26b9				endm  
# End of macro CALLMONITOR
26b9				endif 
26b9			 
26b9 cd 05 21				call forth_push_numhl 
26bc					NEXTW 
26bc c3 b2 24			jp macro_next 
26bf				endm 
# End of macro NEXTW
26bf			.ZDUP: 
26bf				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
26bf 99				db WORD_SYS_CORE+OPCODE_ZDUP             
26c0 f7 26			dw .SWAP            
26c2 05				db 4 + 1 
26c3 .. 00			db "?DUP",0              
26c8				endm 
# End of macro CWHEAD
26c8			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
26c8			 
26c8					if DEBUG_FORTH_WORDS_KEY 
26c8						DMARK "qDU" 
26c8 f5				push af  
26c9 3a dd 26			ld a, (.dmark)  
26cc 32 68 fe			ld (debug_mark),a  
26cf 3a de 26			ld a, (.dmark+1)  
26d2 32 69 fe			ld (debug_mark+1),a  
26d5 3a df 26			ld a, (.dmark+2)  
26d8 32 6a fe			ld (debug_mark+2),a  
26db 18 03			jr .pastdmark  
26dd ..			.dmark: db "qDU"  
26e0 f1			.pastdmark: pop af  
26e1			endm  
# End of macro DMARK
26e1						CALLMONITOR 
26e1 cd 6c fe			call debug_vector  
26e4				endm  
# End of macro CALLMONITOR
26e4					endif 
26e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26e4 cd fc 22			call macro_dsp_valuehl 
26e7				endm 
# End of macro FORTH_DSP_VALUEHL
26e7			 
26e7 e5					push hl 
26e8			 
26e8					; is it a zero? 
26e8			 
26e8 3e 00				ld a, 0 
26ea 84					add h 
26eb 85					add l 
26ec			 
26ec e1					pop hl 
26ed			 
26ed fe 00				cp 0 
26ef 28 03				jr z, .dup2orig 
26f1			 
26f1			 
26f1 cd 05 21				call forth_push_numhl 
26f4			 
26f4			 
26f4				; TODO add floating point number detection 
26f4			 
26f4			.dup2orig: 
26f4			 
26f4					NEXTW 
26f4 c3 b2 24			jp macro_next 
26f7				endm 
# End of macro NEXTW
26f7			.SWAP: 
26f7				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
26f7 18				db WORD_SYS_CORE+OPCODE_SWAP             
26f8 36 27			dw .COLN            
26fa 05				db 4 + 1 
26fb .. 00			db "SWAP",0              
2700				endm 
# End of macro CWHEAD
2700			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2700					if DEBUG_FORTH_WORDS_KEY 
2700						DMARK "SWP" 
2700 f5				push af  
2701 3a 15 27			ld a, (.dmark)  
2704 32 68 fe			ld (debug_mark),a  
2707 3a 16 27			ld a, (.dmark+1)  
270a 32 69 fe			ld (debug_mark+1),a  
270d 3a 17 27			ld a, (.dmark+2)  
2710 32 6a fe			ld (debug_mark+2),a  
2713 18 03			jr .pastdmark  
2715 ..			.dmark: db "SWP"  
2718 f1			.pastdmark: pop af  
2719			endm  
# End of macro DMARK
2719						CALLMONITOR 
2719 cd 6c fe			call debug_vector  
271c				endm  
# End of macro CALLMONITOR
271c					endif 
271c			 
271c					FORTH_DSP_VALUEHL 
271c cd fc 22			call macro_dsp_valuehl 
271f				endm 
# End of macro FORTH_DSP_VALUEHL
271f e5					push hl     ; w2 
2720			 
2720					FORTH_DSP_POP 
2720 cd b4 23			call macro_forth_dsp_pop 
2723				endm 
# End of macro FORTH_DSP_POP
2723			 
2723					FORTH_DSP_VALUEHL 
2723 cd fc 22			call macro_dsp_valuehl 
2726				endm 
# End of macro FORTH_DSP_VALUEHL
2726			 
2726					FORTH_DSP_POP 
2726 cd b4 23			call macro_forth_dsp_pop 
2729				endm 
# End of macro FORTH_DSP_POP
2729			 
2729 d1					pop de     ; w2	, hl = w1 
272a			 
272a eb					ex de, hl 
272b d5					push de 
272c			 
272c cd 05 21				call forth_push_numhl 
272f			 
272f e1					pop hl 
2730			 
2730 cd 05 21				call forth_push_numhl 
2733					 
2733			 
2733					NEXTW 
2733 c3 b2 24			jp macro_next 
2736				endm 
# End of macro NEXTW
2736			.COLN: 
2736				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2736 19				db WORD_SYS_CORE+OPCODE_COLN             
2737 c2 28			dw .SCOLN            
2739 02				db 1 + 1 
273a .. 00			db ":",0              
273c				endm 
# End of macro CWHEAD
273c			; | : ( -- )         Create new word | DONE 
273c			 
273c					if DEBUG_FORTH_WORDS_KEY 
273c						DMARK "CLN" 
273c f5				push af  
273d 3a 51 27			ld a, (.dmark)  
2740 32 68 fe			ld (debug_mark),a  
2743 3a 52 27			ld a, (.dmark+1)  
2746 32 69 fe			ld (debug_mark+1),a  
2749 3a 53 27			ld a, (.dmark+2)  
274c 32 6a fe			ld (debug_mark+2),a  
274f 18 03			jr .pastdmark  
2751 ..			.dmark: db "CLN"  
2754 f1			.pastdmark: pop af  
2755			endm  
# End of macro DMARK
2755						CALLMONITOR 
2755 cd 6c fe			call debug_vector  
2758				endm  
# End of macro CALLMONITOR
2758					endif 
2758				STACKFRAME OFF $8efe $989f 
2758				if DEBUG_STACK_IMB 
2758					if OFF 
2758						exx 
2758						ld de, $8efe 
2758						ld a, d 
2758						ld hl, curframe 
2758						call hexout 
2758						ld a, e 
2758						ld hl, curframe+2 
2758						call hexout 
2758						ld hl, $8efe 
2758						push hl 
2758						ld hl, $989f 
2758						push hl 
2758						exx 
2758					endif 
2758				endif 
2758			endm 
# End of macro STACKFRAME
2758				; get parser buffer length  of new word 
2758			 
2758				 
2758			 
2758					; move tok past this to start of name defintition 
2758					; TODO get word to define 
2758					; TODO Move past word token 
2758					; TODO get length of string up to the ';' 
2758			 
2758 2a bf f4			ld hl, (os_tok_ptr) 
275b 23				inc hl 
275c 23				inc hl 
275d			 
275d 3e 3b			ld a, ';' 
275f cd 39 14			call strlent 
2762			 
2762 7d				ld a,l 
2763 32 ba f1			ld (os_new_parse_len), a 
2766			 
2766			 
2766			if DEBUG_FORTH_UWORD 
2766 ed 5b bf f4		ld de, (os_tok_ptr) 
276a						DMARK ":01" 
276a f5				push af  
276b 3a 7f 27			ld a, (.dmark)  
276e 32 68 fe			ld (debug_mark),a  
2771 3a 80 27			ld a, (.dmark+1)  
2774 32 69 fe			ld (debug_mark+1),a  
2777 3a 81 27			ld a, (.dmark+2)  
277a 32 6a fe			ld (debug_mark+2),a  
277d 18 03			jr .pastdmark  
277f ..			.dmark: db ":01"  
2782 f1			.pastdmark: pop af  
2783			endm  
# End of macro DMARK
2783				CALLMONITOR 
2783 cd 6c fe			call debug_vector  
2786				endm  
# End of macro CALLMONITOR
2786			endif 
2786			 
2786			; 
2786			;  new word memory layout: 
2786			;  
2786			;    : adg 6666 ;  
2786			; 
2786			;    db   1     ; user defined word  
2786 23				inc hl    
2787			;    dw   sysdict 
2787 23				inc hl 
2788 23				inc hl 
2789			;    db <word len>+1 (for null) 
2789 23				inc hl 
278a			;    db .... <word> 
278a			; 
278a			 
278a 23				inc hl    ; some extras for the word preamble before the above 
278b 23				inc hl 
278c 23				inc hl 
278d 23				inc hl 
278e 23				inc hl 
278f 23				inc hl 
2790 23				inc hl  
2791 23				inc hl 
2792 23				inc hl 
2793 23				inc hl 
2794 23				inc hl 
2795 23				inc hl 
2796 23				inc hl 
2797 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2798			;       exec word buffer 
2798			;	<ptr word>   
2798 23				inc hl 
2799 23				inc hl 
279a			;       <word list><null term> 7F final term 
279a			 
279a			 
279a			if DEBUG_FORTH_UWORD 
279a						DMARK ":02" 
279a f5				push af  
279b 3a af 27			ld a, (.dmark)  
279e 32 68 fe			ld (debug_mark),a  
27a1 3a b0 27			ld a, (.dmark+1)  
27a4 32 69 fe			ld (debug_mark+1),a  
27a7 3a b1 27			ld a, (.dmark+2)  
27aa 32 6a fe			ld (debug_mark+2),a  
27ad 18 03			jr .pastdmark  
27af ..			.dmark: db ":02"  
27b2 f1			.pastdmark: pop af  
27b3			endm  
# End of macro DMARK
27b3				CALLMONITOR 
27b3 cd 6c fe			call debug_vector  
27b6				endm  
# End of macro CALLMONITOR
27b6			endif 
27b6			 
27b6				 
27b6					; malloc the size 
27b6			 
27b6 cd 97 14				call malloc 
27b9 22 bc f1				ld (os_new_malloc), hl     ; save malloc start 
27bc			 
27bc			;    db   1     ; user defined word  
27bc 3e 01				ld a, WORD_SYS_UWORD  
27be 77					ld (hl), a 
27bf				 
27bf 23				inc hl    
27c0			;    dw   sysdict 
27c0 11 0a 26			ld de, sysdict       ; continue on with the scan to the system dict 
27c3 73				ld (hl), e 
27c4 23				inc hl 
27c5 72				ld (hl), d 
27c6 23				inc hl 
27c7			 
27c7			 
27c7			;    Setup dict word 
27c7			 
27c7 23				inc hl 
27c8 22 b6 f1			ld (os_new_work_ptr), hl     ; save start of dict word  
27cb			 
27cb				; 1. get length of dict word 
27cb			 
27cb			 
27cb 2a bf f4			ld hl, (os_tok_ptr) 
27ce 23				inc hl 
27cf 23				inc hl    ; position to start of dict word 
27d0 3e 00			ld a, 0 
27d2 cd 39 14			call strlent 
27d5			 
27d5			 
27d5 23				inc hl    ; to include null??? 
27d6			 
27d6				; write length of dict word 
27d6			 
27d6 ed 5b b6 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
27da 1b				dec de 
27db eb				ex de, hl 
27dc 73				ld (hl), e 
27dd eb				ex de, hl 
27de			 
27de				 
27de			 
27de				; copy  
27de 4d				ld c, l 
27df 06 00			ld b, 0 
27e1 ed 5b b6 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
27e5 2a bf f4			ld hl, (os_tok_ptr) 
27e8 23				inc hl 
27e9 23				inc hl    ; position to start of dict word 
27ea				 
27ea			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
27ea				 
27ea				; TODO need to convert word to upper case 
27ea			 
27ea			ucasetok:	 
27ea 7e				ld a,(hl) 
27eb cd 25 14			call toUpper 
27ee 77				ld (hl),a 
27ef ed a0			ldi 
27f1 f2 ea 27		 	jp p, ucasetok 
27f4			 
27f4			 
27f4			 
27f4				; de now points to start of where the word body code should be placed 
27f4 ed 53 b6 f1		ld (os_new_work_ptr), de 
27f8				; hl now points to the words to throw at forthexec which needs to be copied 
27f8 22 b4 f1			ld (os_new_src_ptr), hl 
27fb			 
27fb				; TODO add 'call to forthexec' 
27fb			 
27fb			if DEBUG_FORTH_UWORD 
27fb c5				push bc 
27fc ed 4b bc f1		ld bc, (os_new_malloc) 
2800						DMARK ":0x" 
2800 f5				push af  
2801 3a 15 28			ld a, (.dmark)  
2804 32 68 fe			ld (debug_mark),a  
2807 3a 16 28			ld a, (.dmark+1)  
280a 32 69 fe			ld (debug_mark+1),a  
280d 3a 17 28			ld a, (.dmark+2)  
2810 32 6a fe			ld (debug_mark+2),a  
2813 18 03			jr .pastdmark  
2815 ..			.dmark: db ":0x"  
2818 f1			.pastdmark: pop af  
2819			endm  
# End of macro DMARK
2819				CALLMONITOR 
2819 cd 6c fe			call debug_vector  
281c				endm  
# End of macro CALLMONITOR
281c c1				pop bc 
281d			endif 
281d			 
281d			 
281d				; create word preamble which should be: 
281d			 
281d			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
281d			 
281d				;    ld hl, <word code> 
281d				;    jp user_exec 
281d			        ;    <word code bytes> 
281d			 
281d			 
281d			;	inc de     ; TODO ??? or are we already past the word's null 
281d eb				ex de, hl 
281e			 
281e 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2820			 
2820 23				inc hl 
2821 22 b0 f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2824 23				inc hl 
2825			 
2825 23				inc hl 
2826 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2828			 
2828 01 32 5d			ld bc, user_exec 
282b 23				inc hl 
282c 71				ld (hl), c     ; poke address of user_exec 
282d 23				inc hl 
282e 70				ld (hl), b     
282f			 ; 
282f			;	inc hl 
282f			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
282f			; 
282f			; 
282f			;	ld bc, macro_forth_rsp_next 
282f			;	inc hl 
282f			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
282f			;	inc hl 
282f			;	ld (hl), b     
282f			 ; 
282f			;	inc hl 
282f			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
282f			; 
282f			; 
282f			;	inc hl 
282f			;	ld bc, forthexec 
282f			;	ld (hl), c     ; poke address of forthexec 
282f			;	inc hl 
282f			;	ld (hl), b      
282f			; 
282f			;	inc hl 
282f			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
282f			; 
282f			;	ld bc, user_dict_next 
282f			;	inc hl 
282f			;	ld (hl), c     ; poke address of forthexec 
282f			;	inc hl 
282f			;	ld (hl), b      
282f			 
282f				; hl is now where we need to copy the word byte data to save this 
282f			 
282f 23				inc hl 
2830 22 b2 f1			ld (os_new_exec), hl 
2833				 
2833				; copy definition 
2833			 
2833 eb				ex de, hl 
2834			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2834			;	inc de    ; skip the PC for this parse 
2834 3a ba f1			ld a, (os_new_parse_len) 
2837 4f				ld c, a 
2838 06 00			ld b, 0 
283a ed b0			ldir		 ; copy defintion 
283c			 
283c			 
283c				; poke the address of where the new word bytes live for forthexec 
283c			 
283c 2a b0 f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
283f			 
283f ed 5b b2 f1		ld de, (os_new_exec)      
2843				 
2843 73				ld (hl), e 
2844 23				inc hl 
2845 72				ld (hl), d 
2846			 
2846					; TODO copy last user dict word next link to this word 
2846					; TODO update last user dict word to point to this word 
2846			; 
2846			; hl f923 de 812a ; bc 811a 
2846			 
2846			if DEBUG_FORTH_UWORD 
2846 c5				push bc 
2847 ed 4b bc f1		ld bc, (os_new_malloc) 
284b						DMARK ":0A" 
284b f5				push af  
284c 3a 60 28			ld a, (.dmark)  
284f 32 68 fe			ld (debug_mark),a  
2852 3a 61 28			ld a, (.dmark+1)  
2855 32 69 fe			ld (debug_mark+1),a  
2858 3a 62 28			ld a, (.dmark+2)  
285b 32 6a fe			ld (debug_mark+2),a  
285e 18 03			jr .pastdmark  
2860 ..			.dmark: db ":0A"  
2863 f1			.pastdmark: pop af  
2864			endm  
# End of macro DMARK
2864				CALLMONITOR 
2864 cd 6c fe			call debug_vector  
2867				endm  
# End of macro CALLMONITOR
2867 c1				pop bc 
2868			endif 
2868			if DEBUG_FORTH_UWORD 
2868 c5				push bc 
2869 ed 4b bc f1		ld bc, (os_new_malloc) 
286d 03				inc bc 
286e 03				inc bc 
286f 03				inc bc 
2870 03				inc bc 
2871 03				inc bc 
2872 03				inc bc 
2873 03				inc bc 
2874 03				inc bc 
2875			 
2875						DMARK ":0B" 
2875 f5				push af  
2876 3a 8a 28			ld a, (.dmark)  
2879 32 68 fe			ld (debug_mark),a  
287c 3a 8b 28			ld a, (.dmark+1)  
287f 32 69 fe			ld (debug_mark+1),a  
2882 3a 8c 28			ld a, (.dmark+2)  
2885 32 6a fe			ld (debug_mark+2),a  
2888 18 03			jr .pastdmark  
288a ..			.dmark: db ":0B"  
288d f1			.pastdmark: pop af  
288e			endm  
# End of macro DMARK
288e				CALLMONITOR 
288e cd 6c fe			call debug_vector  
2891				endm  
# End of macro CALLMONITOR
2891 c1				pop bc 
2892			endif 
2892			 
2892			; update word dict linked list for new word 
2892			 
2892			 
2892 2a bb f4		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2895 23			inc hl     ; move to next work linked list ptr 
2896			 
2896 ed 5b bc f1	ld de, (os_new_malloc)		 ; new next word 
289a 73			ld (hl), e 
289b 23			inc hl 
289c 72			ld (hl), d 
289d			 
289d			if DEBUG_FORTH_UWORD 
289d ed 4b bb f4		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
28a1			endif 
28a1			 
28a1 ed 53 bb f4	ld (os_last_new_uword), de      ; update last new uword ptr 
28a5			 
28a5			 
28a5			if DEBUG_FORTH_UWORD 
28a5						DMARK ":0+" 
28a5 f5				push af  
28a6 3a ba 28			ld a, (.dmark)  
28a9 32 68 fe			ld (debug_mark),a  
28ac 3a bb 28			ld a, (.dmark+1)  
28af 32 69 fe			ld (debug_mark+1),a  
28b2 3a bc 28			ld a, (.dmark+2)  
28b5 32 6a fe			ld (debug_mark+2),a  
28b8 18 03			jr .pastdmark  
28ba ..			.dmark: db ":0+"  
28bd f1			.pastdmark: pop af  
28be			endm  
# End of macro DMARK
28be				CALLMONITOR 
28be cd 6c fe			call debug_vector  
28c1				endm  
# End of macro CALLMONITOR
28c1			endif 
28c1			 
28c1				STACKFRAMECHK OFF $8efe $989f 
28c1				if DEBUG_STACK_IMB 
28c1					if OFF 
28c1						exx 
28c1						ld hl, $989f 
28c1						pop de   ; $989f 
28c1						call cmp16 
28c1						jr nz, .spnosame 
28c1						ld hl, $8efe 
28c1						pop de   ; $8efe 
28c1						call cmp16 
28c1						jr z, .spfrsame 
28c1						.spnosame: call showsperror 
28c1						.spfrsame: nop 
28c1						exx 
28c1					endif 
28c1				endif 
28c1			endm 
# End of macro STACKFRAMECHK
28c1			 
28c1 c9			ret    ; dont process any remaining parser tokens as they form new word 
28c2			 
28c2			 
28c2			 
28c2			 
28c2			;		NEXT 
28c2			.SCOLN: 
28c2			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
28c2 06				db OPCODE_SCOLN 
28c3 0e 29			dw .DROP 
28c5 02				db 2 
28c6 .. 00			db ";",0           
28c8			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
28c8					if DEBUG_FORTH_WORDS_KEY 
28c8						DMARK "SCN" 
28c8 f5				push af  
28c9 3a dd 28			ld a, (.dmark)  
28cc 32 68 fe			ld (debug_mark),a  
28cf 3a de 28			ld a, (.dmark+1)  
28d2 32 69 fe			ld (debug_mark+1),a  
28d5 3a df 28			ld a, (.dmark+2)  
28d8 32 6a fe			ld (debug_mark+2),a  
28db 18 03			jr .pastdmark  
28dd ..			.dmark: db "SCN"  
28e0 f1			.pastdmark: pop af  
28e1			endm  
# End of macro DMARK
28e1						CALLMONITOR 
28e1 cd 6c fe			call debug_vector  
28e4				endm  
# End of macro CALLMONITOR
28e4					endif 
28e4					FORTH_RSP_TOS 
28e4 cd c3 20			call macro_forth_rsp_tos 
28e7				endm 
# End of macro FORTH_RSP_TOS
28e7 e5					push hl 
28e8					FORTH_RSP_POP 
28e8 cd cd 20			call macro_forth_rsp_pop 
28eb				endm 
# End of macro FORTH_RSP_POP
28eb e1					pop hl 
28ec			;		ex de,hl 
28ec 22 bf f4				ld (os_tok_ptr),hl 
28ef			 
28ef			if DEBUG_FORTH_UWORD 
28ef						DMARK "SCL" 
28ef f5				push af  
28f0 3a 04 29			ld a, (.dmark)  
28f3 32 68 fe			ld (debug_mark),a  
28f6 3a 05 29			ld a, (.dmark+1)  
28f9 32 69 fe			ld (debug_mark+1),a  
28fc 3a 06 29			ld a, (.dmark+2)  
28ff 32 6a fe			ld (debug_mark+2),a  
2902 18 03			jr .pastdmark  
2904 ..			.dmark: db "SCL"  
2907 f1			.pastdmark: pop af  
2908			endm  
# End of macro DMARK
2908				CALLMONITOR 
2908 cd 6c fe			call debug_vector  
290b				endm  
# End of macro CALLMONITOR
290b			endif 
290b					NEXTW 
290b c3 b2 24			jp macro_next 
290e				endm 
# End of macro NEXTW
290e			 
290e			.DROP: 
290e				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
290e 1b				db WORD_SYS_CORE+OPCODE_DROP             
290f 39 29			dw .DUP2            
2911 05				db 4 + 1 
2912 .. 00			db "DROP",0              
2917				endm 
# End of macro CWHEAD
2917			; | DROP ( w -- )   drop the TOS item   | DONE 
2917					if DEBUG_FORTH_WORDS_KEY 
2917						DMARK "DRP" 
2917 f5				push af  
2918 3a 2c 29			ld a, (.dmark)  
291b 32 68 fe			ld (debug_mark),a  
291e 3a 2d 29			ld a, (.dmark+1)  
2921 32 69 fe			ld (debug_mark+1),a  
2924 3a 2e 29			ld a, (.dmark+2)  
2927 32 6a fe			ld (debug_mark+2),a  
292a 18 03			jr .pastdmark  
292c ..			.dmark: db "DRP"  
292f f1			.pastdmark: pop af  
2930			endm  
# End of macro DMARK
2930						CALLMONITOR 
2930 cd 6c fe			call debug_vector  
2933				endm  
# End of macro CALLMONITOR
2933					endif 
2933					FORTH_DSP_POP 
2933 cd b4 23			call macro_forth_dsp_pop 
2936				endm 
# End of macro FORTH_DSP_POP
2936					NEXTW 
2936 c3 b2 24			jp macro_next 
2939				endm 
# End of macro NEXTW
2939			.DUP2: 
2939				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2939 1c				db WORD_SYS_CORE+OPCODE_DUP2             
293a 7e 29			dw .DROP2            
293c 05				db 4 + 1 
293d .. 00			db "2DUP",0              
2942				endm 
# End of macro CWHEAD
2942			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2942					if DEBUG_FORTH_WORDS_KEY 
2942						DMARK "2DU" 
2942 f5				push af  
2943 3a 57 29			ld a, (.dmark)  
2946 32 68 fe			ld (debug_mark),a  
2949 3a 58 29			ld a, (.dmark+1)  
294c 32 69 fe			ld (debug_mark+1),a  
294f 3a 59 29			ld a, (.dmark+2)  
2952 32 6a fe			ld (debug_mark+2),a  
2955 18 03			jr .pastdmark  
2957 ..			.dmark: db "2DU"  
295a f1			.pastdmark: pop af  
295b			endm  
# End of macro DMARK
295b						CALLMONITOR 
295b cd 6c fe			call debug_vector  
295e				endm  
# End of macro CALLMONITOR
295e					endif 
295e					FORTH_DSP_VALUEHL 
295e cd fc 22			call macro_dsp_valuehl 
2961				endm 
# End of macro FORTH_DSP_VALUEHL
2961 e5					push hl      ; 2 
2962			 
2962					FORTH_DSP_POP 
2962 cd b4 23			call macro_forth_dsp_pop 
2965				endm 
# End of macro FORTH_DSP_POP
2965					 
2965					FORTH_DSP_VALUEHL 
2965 cd fc 22			call macro_dsp_valuehl 
2968				endm 
# End of macro FORTH_DSP_VALUEHL
2968			;		push hl      ; 1 
2968			 
2968					FORTH_DSP_POP 
2968 cd b4 23			call macro_forth_dsp_pop 
296b				endm 
# End of macro FORTH_DSP_POP
296b			 
296b			;		pop hl       ; 1 
296b d1					pop de       ; 2 
296c			 
296c cd 05 21				call forth_push_numhl 
296f eb					ex de, hl 
2970 cd 05 21				call forth_push_numhl 
2973			 
2973					 
2973 eb					ex de, hl 
2974			 
2974 cd 05 21				call forth_push_numhl 
2977 eb					ex de, hl 
2978 cd 05 21				call forth_push_numhl 
297b			 
297b			 
297b					NEXTW 
297b c3 b2 24			jp macro_next 
297e				endm 
# End of macro NEXTW
297e			.DROP2: 
297e				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
297e 1d				db WORD_SYS_CORE+OPCODE_DROP2             
297f ad 29			dw .SWAP2            
2981 06				db 5 + 1 
2982 .. 00			db "2DROP",0              
2988				endm 
# End of macro CWHEAD
2988			; | 2DROP ( w w -- )    Double drop | DONE 
2988					if DEBUG_FORTH_WORDS_KEY 
2988						DMARK "2DR" 
2988 f5				push af  
2989 3a 9d 29			ld a, (.dmark)  
298c 32 68 fe			ld (debug_mark),a  
298f 3a 9e 29			ld a, (.dmark+1)  
2992 32 69 fe			ld (debug_mark+1),a  
2995 3a 9f 29			ld a, (.dmark+2)  
2998 32 6a fe			ld (debug_mark+2),a  
299b 18 03			jr .pastdmark  
299d ..			.dmark: db "2DR"  
29a0 f1			.pastdmark: pop af  
29a1			endm  
# End of macro DMARK
29a1						CALLMONITOR 
29a1 cd 6c fe			call debug_vector  
29a4				endm  
# End of macro CALLMONITOR
29a4					endif 
29a4					FORTH_DSP_POP 
29a4 cd b4 23			call macro_forth_dsp_pop 
29a7				endm 
# End of macro FORTH_DSP_POP
29a7					FORTH_DSP_POP 
29a7 cd b4 23			call macro_forth_dsp_pop 
29aa				endm 
# End of macro FORTH_DSP_POP
29aa					NEXTW 
29aa c3 b2 24			jp macro_next 
29ad				endm 
# End of macro NEXTW
29ad			.SWAP2: 
29ad				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
29ad 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
29ae d6 29			dw .AT            
29b0 06				db 5 + 1 
29b1 .. 00			db "2SWAP",0              
29b7				endm 
# End of macro CWHEAD
29b7			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
29b7					if DEBUG_FORTH_WORDS_KEY 
29b7						DMARK "2SW" 
29b7 f5				push af  
29b8 3a cc 29			ld a, (.dmark)  
29bb 32 68 fe			ld (debug_mark),a  
29be 3a cd 29			ld a, (.dmark+1)  
29c1 32 69 fe			ld (debug_mark+1),a  
29c4 3a ce 29			ld a, (.dmark+2)  
29c7 32 6a fe			ld (debug_mark+2),a  
29ca 18 03			jr .pastdmark  
29cc ..			.dmark: db "2SW"  
29cf f1			.pastdmark: pop af  
29d0			endm  
# End of macro DMARK
29d0						CALLMONITOR 
29d0 cd 6c fe			call debug_vector  
29d3				endm  
# End of macro CALLMONITOR
29d3					endif 
29d3					NEXTW 
29d3 c3 b2 24			jp macro_next 
29d6				endm 
# End of macro NEXTW
29d6			.AT: 
29d6				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
29d6 1f				db WORD_SYS_CORE+OPCODE_AT             
29d7 08 2a			dw .CAT            
29d9 02				db 1 + 1 
29da .. 00			db "@",0              
29dc				endm 
# End of macro CWHEAD
29dc			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
29dc			 
29dc					if DEBUG_FORTH_WORDS_KEY 
29dc						DMARK "AT." 
29dc f5				push af  
29dd 3a f1 29			ld a, (.dmark)  
29e0 32 68 fe			ld (debug_mark),a  
29e3 3a f2 29			ld a, (.dmark+1)  
29e6 32 69 fe			ld (debug_mark+1),a  
29e9 3a f3 29			ld a, (.dmark+2)  
29ec 32 6a fe			ld (debug_mark+2),a  
29ef 18 03			jr .pastdmark  
29f1 ..			.dmark: db "AT."  
29f4 f1			.pastdmark: pop af  
29f5			endm  
# End of macro DMARK
29f5						CALLMONITOR 
29f5 cd 6c fe			call debug_vector  
29f8				endm  
# End of macro CALLMONITOR
29f8					endif 
29f8			.getbyteat:	 
29f8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29f8 cd fc 22			call macro_dsp_valuehl 
29fb				endm 
# End of macro FORTH_DSP_VALUEHL
29fb					 
29fb			;		push hl 
29fb				 
29fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29fb cd b4 23			call macro_forth_dsp_pop 
29fe				endm 
# End of macro FORTH_DSP_POP
29fe			 
29fe			;		pop hl 
29fe			 
29fe 7e					ld a, (hl) 
29ff			 
29ff 6f					ld l, a 
2a00 26 00				ld h, 0 
2a02 cd 05 21				call forth_push_numhl 
2a05			 
2a05					NEXTW 
2a05 c3 b2 24			jp macro_next 
2a08				endm 
# End of macro NEXTW
2a08			.CAT: 
2a08				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2a08 20				db WORD_SYS_CORE+OPCODE_CAT             
2a09 31 2a			dw .BANG            
2a0b 03				db 2 + 1 
2a0c .. 00			db "C@",0              
2a0f				endm 
# End of macro CWHEAD
2a0f			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2a0f					if DEBUG_FORTH_WORDS_KEY 
2a0f						DMARK "CAA" 
2a0f f5				push af  
2a10 3a 24 2a			ld a, (.dmark)  
2a13 32 68 fe			ld (debug_mark),a  
2a16 3a 25 2a			ld a, (.dmark+1)  
2a19 32 69 fe			ld (debug_mark+1),a  
2a1c 3a 26 2a			ld a, (.dmark+2)  
2a1f 32 6a fe			ld (debug_mark+2),a  
2a22 18 03			jr .pastdmark  
2a24 ..			.dmark: db "CAA"  
2a27 f1			.pastdmark: pop af  
2a28			endm  
# End of macro DMARK
2a28						CALLMONITOR 
2a28 cd 6c fe			call debug_vector  
2a2b				endm  
# End of macro CALLMONITOR
2a2b					endif 
2a2b c3 f8 29				jp .getbyteat 
2a2e					NEXTW 
2a2e c3 b2 24			jp macro_next 
2a31				endm 
# End of macro NEXTW
2a31			.BANG: 
2a31				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2a31 21				db WORD_SYS_CORE+OPCODE_BANG             
2a32 67 2a			dw .CBANG            
2a34 02				db 1 + 1 
2a35 .. 00			db "!",0              
2a37				endm 
# End of macro CWHEAD
2a37			; | ! ( x w -- ) Store x at address w      | DONE 
2a37					if DEBUG_FORTH_WORDS_KEY 
2a37						DMARK "BNG" 
2a37 f5				push af  
2a38 3a 4c 2a			ld a, (.dmark)  
2a3b 32 68 fe			ld (debug_mark),a  
2a3e 3a 4d 2a			ld a, (.dmark+1)  
2a41 32 69 fe			ld (debug_mark+1),a  
2a44 3a 4e 2a			ld a, (.dmark+2)  
2a47 32 6a fe			ld (debug_mark+2),a  
2a4a 18 03			jr .pastdmark  
2a4c ..			.dmark: db "BNG"  
2a4f f1			.pastdmark: pop af  
2a50			endm  
# End of macro DMARK
2a50						CALLMONITOR 
2a50 cd 6c fe			call debug_vector  
2a53				endm  
# End of macro CALLMONITOR
2a53					endif 
2a53			 
2a53			.storebyteat:		 
2a53					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a53 cd fc 22			call macro_dsp_valuehl 
2a56				endm 
# End of macro FORTH_DSP_VALUEHL
2a56					 
2a56 e5					push hl 
2a57				 
2a57					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a57 cd b4 23			call macro_forth_dsp_pop 
2a5a				endm 
# End of macro FORTH_DSP_POP
2a5a			 
2a5a					; get byte to poke 
2a5a			 
2a5a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a5a cd fc 22			call macro_dsp_valuehl 
2a5d				endm 
# End of macro FORTH_DSP_VALUEHL
2a5d e5					push hl 
2a5e			 
2a5e			 
2a5e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a5e cd b4 23			call macro_forth_dsp_pop 
2a61				endm 
# End of macro FORTH_DSP_POP
2a61			 
2a61			 
2a61 d1					pop de 
2a62 e1					pop hl 
2a63			 
2a63 73					ld (hl),e 
2a64			 
2a64			 
2a64					NEXTW 
2a64 c3 b2 24			jp macro_next 
2a67				endm 
# End of macro NEXTW
2a67			.CBANG: 
2a67				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2a67 22				db WORD_SYS_CORE+OPCODE_CBANG             
2a68 90 2a			dw .SCALL            
2a6a 03				db 2 + 1 
2a6b .. 00			db "C!",0              
2a6e				endm 
# End of macro CWHEAD
2a6e			; | C!  ( x w -- ) Store x at address w  | DONE 
2a6e					if DEBUG_FORTH_WORDS_KEY 
2a6e						DMARK "CBA" 
2a6e f5				push af  
2a6f 3a 83 2a			ld a, (.dmark)  
2a72 32 68 fe			ld (debug_mark),a  
2a75 3a 84 2a			ld a, (.dmark+1)  
2a78 32 69 fe			ld (debug_mark+1),a  
2a7b 3a 85 2a			ld a, (.dmark+2)  
2a7e 32 6a fe			ld (debug_mark+2),a  
2a81 18 03			jr .pastdmark  
2a83 ..			.dmark: db "CBA"  
2a86 f1			.pastdmark: pop af  
2a87			endm  
# End of macro DMARK
2a87						CALLMONITOR 
2a87 cd 6c fe			call debug_vector  
2a8a				endm  
# End of macro CALLMONITOR
2a8a					endif 
2a8a c3 53 2a				jp .storebyteat 
2a8d					NEXTW 
2a8d c3 b2 24			jp macro_next 
2a90				endm 
# End of macro NEXTW
2a90			.SCALL: 
2a90				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2a90 23				db WORD_SYS_CORE+OPCODE_SCALL             
2a91 c4 2a			dw .DEPTH            
2a93 05				db 4 + 1 
2a94 .. 00			db "CALL",0              
2a99				endm 
# End of macro CWHEAD
2a99			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2a99					if DEBUG_FORTH_WORDS_KEY 
2a99						DMARK "CLL" 
2a99 f5				push af  
2a9a 3a ae 2a			ld a, (.dmark)  
2a9d 32 68 fe			ld (debug_mark),a  
2aa0 3a af 2a			ld a, (.dmark+1)  
2aa3 32 69 fe			ld (debug_mark+1),a  
2aa6 3a b0 2a			ld a, (.dmark+2)  
2aa9 32 6a fe			ld (debug_mark+2),a  
2aac 18 03			jr .pastdmark  
2aae ..			.dmark: db "CLL"  
2ab1 f1			.pastdmark: pop af  
2ab2			endm  
# End of macro DMARK
2ab2						CALLMONITOR 
2ab2 cd 6c fe			call debug_vector  
2ab5				endm  
# End of macro CALLMONITOR
2ab5					endif 
2ab5			 
2ab5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ab5 cd fc 22			call macro_dsp_valuehl 
2ab8				endm 
# End of macro FORTH_DSP_VALUEHL
2ab8			 
2ab8			;		push hl 
2ab8			 
2ab8					; destroy value TOS 
2ab8			 
2ab8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ab8 cd b4 23			call macro_forth_dsp_pop 
2abb				endm 
# End of macro FORTH_DSP_POP
2abb			 
2abb						 
2abb			;		pop hl 
2abb			 
2abb					; how to do a call with hl???? save SP? 
2abb cd 56 24				call forth_call_hl 
2abe			 
2abe			 
2abe					; TODO push value back onto stack for another op etc 
2abe			 
2abe cd 05 21				call forth_push_numhl 
2ac1					NEXTW 
2ac1 c3 b2 24			jp macro_next 
2ac4				endm 
# End of macro NEXTW
2ac4			.DEPTH: 
2ac4				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2ac4 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2ac5 01 2b			dw .OVER            
2ac7 06				db 5 + 1 
2ac8 .. 00			db "DEPTH",0              
2ace				endm 
# End of macro CWHEAD
2ace			; | DEPTH ( -- u ) Push count of stack | DONE 
2ace					; take current TOS and remove from base value div by two to get count 
2ace					if DEBUG_FORTH_WORDS_KEY 
2ace						DMARK "DEP" 
2ace f5				push af  
2acf 3a e3 2a			ld a, (.dmark)  
2ad2 32 68 fe			ld (debug_mark),a  
2ad5 3a e4 2a			ld a, (.dmark+1)  
2ad8 32 69 fe			ld (debug_mark+1),a  
2adb 3a e5 2a			ld a, (.dmark+2)  
2ade 32 6a fe			ld (debug_mark+2),a  
2ae1 18 03			jr .pastdmark  
2ae3 ..			.dmark: db "DEP"  
2ae6 f1			.pastdmark: pop af  
2ae7			endm  
# End of macro DMARK
2ae7						CALLMONITOR 
2ae7 cd 6c fe			call debug_vector  
2aea				endm  
# End of macro CALLMONITOR
2aea					endif 
2aea			 
2aea			 
2aea 2a eb f9			ld hl, (cli_data_sp) 
2aed 11 25 f7			ld de, cli_data_stack 
2af0 ed 52			sbc hl,de 
2af2				 
2af2				; div by size of stack item 
2af2			 
2af2 5d				ld e,l 
2af3 0e 03			ld c, 3 
2af5 cd 60 0f			call Div8 
2af8			 
2af8 6f				ld l,a 
2af9 26 00			ld h,0 
2afb			 
2afb				;srl h 
2afb				;rr l 
2afb			 
2afb cd 05 21				call forth_push_numhl 
2afe					NEXTW 
2afe c3 b2 24			jp macro_next 
2b01				endm 
# End of macro NEXTW
2b01			.OVER: 
2b01				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2b01 42				db WORD_SYS_CORE+46             
2b02 48 2b			dw .PAUSE            
2b04 05				db 4 + 1 
2b05 .. 00			db "OVER",0              
2b0a				endm 
# End of macro CWHEAD
2b0a			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2b0a					if DEBUG_FORTH_WORDS_KEY 
2b0a						DMARK "OVR" 
2b0a f5				push af  
2b0b 3a 1f 2b			ld a, (.dmark)  
2b0e 32 68 fe			ld (debug_mark),a  
2b11 3a 20 2b			ld a, (.dmark+1)  
2b14 32 69 fe			ld (debug_mark+1),a  
2b17 3a 21 2b			ld a, (.dmark+2)  
2b1a 32 6a fe			ld (debug_mark+2),a  
2b1d 18 03			jr .pastdmark  
2b1f ..			.dmark: db "OVR"  
2b22 f1			.pastdmark: pop af  
2b23			endm  
# End of macro DMARK
2b23						CALLMONITOR 
2b23 cd 6c fe			call debug_vector  
2b26				endm  
# End of macro CALLMONITOR
2b26					endif 
2b26			 
2b26					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b26 cd fc 22			call macro_dsp_valuehl 
2b29				endm 
# End of macro FORTH_DSP_VALUEHL
2b29 e5					push hl    ; n2 
2b2a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b2a cd b4 23			call macro_forth_dsp_pop 
2b2d				endm 
# End of macro FORTH_DSP_POP
2b2d			 
2b2d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b2d cd fc 22			call macro_dsp_valuehl 
2b30				endm 
# End of macro FORTH_DSP_VALUEHL
2b30 e5					push hl    ; n1 
2b31					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b31 cd b4 23			call macro_forth_dsp_pop 
2b34				endm 
# End of macro FORTH_DSP_POP
2b34			 
2b34 d1					pop de     ; n1 
2b35 e1					pop hl     ; n2 
2b36			 
2b36 d5					push de 
2b37 e5					push hl 
2b38 d5					push de 
2b39			 
2b39					; push back  
2b39			 
2b39 e1					pop hl 
2b3a cd 05 21				call forth_push_numhl 
2b3d e1					pop hl 
2b3e cd 05 21				call forth_push_numhl 
2b41 e1					pop hl 
2b42 cd 05 21				call forth_push_numhl 
2b45					NEXTW 
2b45 c3 b2 24			jp macro_next 
2b48				endm 
# End of macro NEXTW
2b48			 
2b48			.PAUSE: 
2b48				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2b48 43				db WORD_SYS_CORE+47             
2b49 7d 2b			dw .PAUSES            
2b4b 08				db 7 + 1 
2b4c .. 00			db "PAUSEMS",0              
2b54				endm 
# End of macro CWHEAD
2b54			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2b54					if DEBUG_FORTH_WORDS_KEY 
2b54						DMARK "PMS" 
2b54 f5				push af  
2b55 3a 69 2b			ld a, (.dmark)  
2b58 32 68 fe			ld (debug_mark),a  
2b5b 3a 6a 2b			ld a, (.dmark+1)  
2b5e 32 69 fe			ld (debug_mark+1),a  
2b61 3a 6b 2b			ld a, (.dmark+2)  
2b64 32 6a fe			ld (debug_mark+2),a  
2b67 18 03			jr .pastdmark  
2b69 ..			.dmark: db "PMS"  
2b6c f1			.pastdmark: pop af  
2b6d			endm  
# End of macro DMARK
2b6d						CALLMONITOR 
2b6d cd 6c fe			call debug_vector  
2b70				endm  
# End of macro CALLMONITOR
2b70					endif 
2b70					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b70 cd fc 22			call macro_dsp_valuehl 
2b73				endm 
# End of macro FORTH_DSP_VALUEHL
2b73			;		push hl    ; n2 
2b73					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b73 cd b4 23			call macro_forth_dsp_pop 
2b76				endm 
# End of macro FORTH_DSP_POP
2b76			;		pop hl 
2b76			 
2b76 7d					ld a, l 
2b77 cd c4 0c				call aDelayInMS 
2b7a				       NEXTW 
2b7a c3 b2 24			jp macro_next 
2b7d				endm 
# End of macro NEXTW
2b7d			.PAUSES:  
2b7d				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2b7d 44				db WORD_SYS_CORE+48             
2b7e ec 2b			dw .ROT            
2b80 06				db 5 + 1 
2b81 .. 00			db "PAUSE",0              
2b87				endm 
# End of macro CWHEAD
2b87			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2b87					if DEBUG_FORTH_WORDS_KEY 
2b87						DMARK "PAU" 
2b87 f5				push af  
2b88 3a 9c 2b			ld a, (.dmark)  
2b8b 32 68 fe			ld (debug_mark),a  
2b8e 3a 9d 2b			ld a, (.dmark+1)  
2b91 32 69 fe			ld (debug_mark+1),a  
2b94 3a 9e 2b			ld a, (.dmark+2)  
2b97 32 6a fe			ld (debug_mark+2),a  
2b9a 18 03			jr .pastdmark  
2b9c ..			.dmark: db "PAU"  
2b9f f1			.pastdmark: pop af  
2ba0			endm  
# End of macro DMARK
2ba0						CALLMONITOR 
2ba0 cd 6c fe			call debug_vector  
2ba3				endm  
# End of macro CALLMONITOR
2ba3					endif 
2ba3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ba3 cd fc 22			call macro_dsp_valuehl 
2ba6				endm 
# End of macro FORTH_DSP_VALUEHL
2ba6			;		push hl    ; n2 
2ba6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ba6 cd b4 23			call macro_forth_dsp_pop 
2ba9				endm 
# End of macro FORTH_DSP_POP
2ba9			;		pop hl 
2ba9 45					ld b, l 
2baa					if DEBUG_FORTH_WORDS 
2baa						DMARK "PAU" 
2baa f5				push af  
2bab 3a bf 2b			ld a, (.dmark)  
2bae 32 68 fe			ld (debug_mark),a  
2bb1 3a c0 2b			ld a, (.dmark+1)  
2bb4 32 69 fe			ld (debug_mark+1),a  
2bb7 3a c1 2b			ld a, (.dmark+2)  
2bba 32 6a fe			ld (debug_mark+2),a  
2bbd 18 03			jr .pastdmark  
2bbf ..			.dmark: db "PAU"  
2bc2 f1			.pastdmark: pop af  
2bc3			endm  
# End of macro DMARK
2bc3						CALLMONITOR 
2bc3 cd 6c fe			call debug_vector  
2bc6				endm  
# End of macro CALLMONITOR
2bc6					endif 
2bc6 c5			.pauses1:	push bc 
2bc7 cd df 0c				call delay1s 
2bca c1					pop bc 
2bcb					if DEBUG_FORTH_WORDS 
2bcb						DMARK "PA1" 
2bcb f5				push af  
2bcc 3a e0 2b			ld a, (.dmark)  
2bcf 32 68 fe			ld (debug_mark),a  
2bd2 3a e1 2b			ld a, (.dmark+1)  
2bd5 32 69 fe			ld (debug_mark+1),a  
2bd8 3a e2 2b			ld a, (.dmark+2)  
2bdb 32 6a fe			ld (debug_mark+2),a  
2bde 18 03			jr .pastdmark  
2be0 ..			.dmark: db "PA1"  
2be3 f1			.pastdmark: pop af  
2be4			endm  
# End of macro DMARK
2be4						CALLMONITOR 
2be4 cd 6c fe			call debug_vector  
2be7				endm  
# End of macro CALLMONITOR
2be7					endif 
2be7 10 dd				djnz .pauses1 
2be9			 
2be9				       NEXTW 
2be9 c3 b2 24			jp macro_next 
2bec				endm 
# End of macro NEXTW
2bec			.ROT: 
2bec				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2bec 45				db WORD_SYS_CORE+49             
2bed 3a 2c			dw .UWORDS            
2bef 04				db 3 + 1 
2bf0 .. 00			db "ROT",0              
2bf4				endm 
# End of macro CWHEAD
2bf4			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2bf4					if DEBUG_FORTH_WORDS_KEY 
2bf4						DMARK "ROT" 
2bf4 f5				push af  
2bf5 3a 09 2c			ld a, (.dmark)  
2bf8 32 68 fe			ld (debug_mark),a  
2bfb 3a 0a 2c			ld a, (.dmark+1)  
2bfe 32 69 fe			ld (debug_mark+1),a  
2c01 3a 0b 2c			ld a, (.dmark+2)  
2c04 32 6a fe			ld (debug_mark+2),a  
2c07 18 03			jr .pastdmark  
2c09 ..			.dmark: db "ROT"  
2c0c f1			.pastdmark: pop af  
2c0d			endm  
# End of macro DMARK
2c0d						CALLMONITOR 
2c0d cd 6c fe			call debug_vector  
2c10				endm  
# End of macro CALLMONITOR
2c10					endif 
2c10			 
2c10					FORTH_DSP_VALUEHL 
2c10 cd fc 22			call macro_dsp_valuehl 
2c13				endm 
# End of macro FORTH_DSP_VALUEHL
2c13 e5					push hl    ; u3  
2c14			 
2c14					FORTH_DSP_POP 
2c14 cd b4 23			call macro_forth_dsp_pop 
2c17				endm 
# End of macro FORTH_DSP_POP
2c17			   
2c17					FORTH_DSP_VALUEHL 
2c17 cd fc 22			call macro_dsp_valuehl 
2c1a				endm 
# End of macro FORTH_DSP_VALUEHL
2c1a e5					push hl     ; u2 
2c1b			 
2c1b					FORTH_DSP_POP 
2c1b cd b4 23			call macro_forth_dsp_pop 
2c1e				endm 
# End of macro FORTH_DSP_POP
2c1e			 
2c1e					FORTH_DSP_VALUEHL 
2c1e cd fc 22			call macro_dsp_valuehl 
2c21				endm 
# End of macro FORTH_DSP_VALUEHL
2c21 e5					push hl     ; u1 
2c22			 
2c22					FORTH_DSP_POP 
2c22 cd b4 23			call macro_forth_dsp_pop 
2c25				endm 
# End of macro FORTH_DSP_POP
2c25			 
2c25 c1					pop bc      ; u1 
2c26 e1					pop hl      ; u2 
2c27 d1					pop de      ; u3 
2c28			 
2c28			 
2c28 c5					push bc 
2c29 d5					push de 
2c2a e5					push hl 
2c2b			 
2c2b			 
2c2b e1					pop hl 
2c2c cd 05 21				call forth_push_numhl 
2c2f			 
2c2f e1					pop hl 
2c30 cd 05 21				call forth_push_numhl 
2c33			 
2c33 e1					pop hl 
2c34 cd 05 21				call forth_push_numhl 
2c37					 
2c37			 
2c37			 
2c37			 
2c37			 
2c37			 
2c37				       NEXTW 
2c37 c3 b2 24			jp macro_next 
2c3a				endm 
# End of macro NEXTW
2c3a			 
2c3a			.UWORDS: 
2c3a				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2c3a 50				db WORD_SYS_CORE+60             
2c3b fc 2c			dw .BP            
2c3d 07				db 6 + 1 
2c3e .. 00			db "UWORDS",0              
2c45				endm 
# End of macro CWHEAD
2c45			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2c45			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2c45			; | | Following the count are the individual words. 
2c45			; | | 
2c45			; | | e.g. UWORDS 
2c45			; | | BOX DIRLIST 2 
2c45			; | |  
2c45			; | | Can be used to save the words to storage via: 
2c45			; | | UWORDS $01 DO $01 APPEND LOOP 
2c45				if DEBUG_FORTH_WORDS_KEY 
2c45					DMARK "UWR" 
2c45 f5				push af  
2c46 3a 5a 2c			ld a, (.dmark)  
2c49 32 68 fe			ld (debug_mark),a  
2c4c 3a 5b 2c			ld a, (.dmark+1)  
2c4f 32 69 fe			ld (debug_mark+1),a  
2c52 3a 5c 2c			ld a, (.dmark+2)  
2c55 32 6a fe			ld (debug_mark+2),a  
2c58 18 03			jr .pastdmark  
2c5a ..			.dmark: db "UWR"  
2c5d f1			.pastdmark: pop af  
2c5e			endm  
# End of macro DMARK
2c5e					CALLMONITOR 
2c5e cd 6c fe			call debug_vector  
2c61				endm  
# End of macro CALLMONITOR
2c61				endif 
2c61 21 00 80				ld hl, baseram 
2c64					;ld hl, baseusermem 
2c64 01 00 00				ld bc, 0    ; start a counter 
2c67			 
2c67				; skip dict stub 
2c67			 
2c67 cd 03 26				call forth_tok_next 
2c6a			 
2c6a			 
2c6a			; while we have words to look for 
2c6a			 
2c6a 7e			.douscan:	ld a, (hl)      
2c6b				if DEBUG_FORTH_WORDS 
2c6b					DMARK "UWs" 
2c6b f5				push af  
2c6c 3a 80 2c			ld a, (.dmark)  
2c6f 32 68 fe			ld (debug_mark),a  
2c72 3a 81 2c			ld a, (.dmark+1)  
2c75 32 69 fe			ld (debug_mark+1),a  
2c78 3a 82 2c			ld a, (.dmark+2)  
2c7b 32 6a fe			ld (debug_mark+2),a  
2c7e 18 03			jr .pastdmark  
2c80 ..			.dmark: db "UWs"  
2c83 f1			.pastdmark: pop af  
2c84			endm  
# End of macro DMARK
2c84					CALLMONITOR 
2c84 cd 6c fe			call debug_vector  
2c87				endm  
# End of macro CALLMONITOR
2c87				endif 
2c87 fe 00				cp WORD_SYS_END 
2c89 28 4d				jr z, .udone 
2c8b fe 01				cp WORD_SYS_UWORD 
2c8d 20 44				jr nz, .nuword 
2c8f			 
2c8f				if DEBUG_FORTH_WORDS 
2c8f					DMARK "UWu" 
2c8f f5				push af  
2c90 3a a4 2c			ld a, (.dmark)  
2c93 32 68 fe			ld (debug_mark),a  
2c96 3a a5 2c			ld a, (.dmark+1)  
2c99 32 69 fe			ld (debug_mark+1),a  
2c9c 3a a6 2c			ld a, (.dmark+2)  
2c9f 32 6a fe			ld (debug_mark+2),a  
2ca2 18 03			jr .pastdmark  
2ca4 ..			.dmark: db "UWu"  
2ca7 f1			.pastdmark: pop af  
2ca8			endm  
# End of macro DMARK
2ca8					CALLMONITOR 
2ca8 cd 6c fe			call debug_vector  
2cab				endm  
# End of macro CALLMONITOR
2cab				endif 
2cab					; we have a uword so push its name to the stack 
2cab			 
2cab e5				   	push hl  ; save so we can move to next dict block 
2cac			 
2cac					; skip opcode 
2cac 23					inc hl  
2cad					; skip next ptr 
2cad 23					inc hl  
2cae 23					inc hl 
2caf					; skip len 
2caf 23					inc hl 
2cb0				if DEBUG_FORTH_WORDS 
2cb0					DMARK "UWt" 
2cb0 f5				push af  
2cb1 3a c5 2c			ld a, (.dmark)  
2cb4 32 68 fe			ld (debug_mark),a  
2cb7 3a c6 2c			ld a, (.dmark+1)  
2cba 32 69 fe			ld (debug_mark+1),a  
2cbd 3a c7 2c			ld a, (.dmark+2)  
2cc0 32 6a fe			ld (debug_mark+2),a  
2cc3 18 03			jr .pastdmark  
2cc5 ..			.dmark: db "UWt"  
2cc8 f1			.pastdmark: pop af  
2cc9			endm  
# End of macro DMARK
2cc9					CALLMONITOR 
2cc9 cd 6c fe			call debug_vector  
2ccc				endm  
# End of macro CALLMONITOR
2ccc				endif 
2ccc 03					inc bc 
2ccd			 
2ccd c5					push bc 
2cce cd 73 21				call forth_push_str 
2cd1 c1					pop bc 
2cd2			 
2cd2 e1					pop hl 	 
2cd3			 
2cd3 cd 03 26		.nuword:	call forth_tok_next 
2cd6 18 92				jr .douscan  
2cd8			 
2cd8			.udone:		 ; push count of uwords found 
2cd8 c5					push bc 
2cd9 e1					pop hl 
2cda			 
2cda				if DEBUG_FORTH_WORDS 
2cda					DMARK "UWc" 
2cda f5				push af  
2cdb 3a ef 2c			ld a, (.dmark)  
2cde 32 68 fe			ld (debug_mark),a  
2ce1 3a f0 2c			ld a, (.dmark+1)  
2ce4 32 69 fe			ld (debug_mark+1),a  
2ce7 3a f1 2c			ld a, (.dmark+2)  
2cea 32 6a fe			ld (debug_mark+2),a  
2ced 18 03			jr .pastdmark  
2cef ..			.dmark: db "UWc"  
2cf2 f1			.pastdmark: pop af  
2cf3			endm  
# End of macro DMARK
2cf3					CALLMONITOR 
2cf3 cd 6c fe			call debug_vector  
2cf6				endm  
# End of macro CALLMONITOR
2cf6				endif 
2cf6 cd 05 21				call forth_push_numhl 
2cf9			 
2cf9			 
2cf9				       NEXTW 
2cf9 c3 b2 24			jp macro_next 
2cfc				endm 
# End of macro NEXTW
2cfc			 
2cfc			.BP: 
2cfc				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2cfc 54				db WORD_SYS_CORE+64             
2cfd 36 2d			dw .MONITOR            
2cff 03				db 2 + 1 
2d00 .. 00			db "BP",0              
2d03				endm 
# End of macro CWHEAD
2d03			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2d03			; | | $00 Will enable the break points within specific code paths 
2d03			; | | $01 Will disable break points 
2d03			; | |  
2d03			; | | By default break points are off. Either the above can be used to enable them 
2d03			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2d03			; | | and on release of the pressed key a message will be disaplayed to notify 
2d03			; | | that break points are enabled. Pressing any key will then continue boot process. 
2d03					; get byte count 
2d03					if DEBUG_FORTH_WORDS_KEY 
2d03						DMARK "BP." 
2d03 f5				push af  
2d04 3a 18 2d			ld a, (.dmark)  
2d07 32 68 fe			ld (debug_mark),a  
2d0a 3a 19 2d			ld a, (.dmark+1)  
2d0d 32 69 fe			ld (debug_mark+1),a  
2d10 3a 1a 2d			ld a, (.dmark+2)  
2d13 32 6a fe			ld (debug_mark+2),a  
2d16 18 03			jr .pastdmark  
2d18 ..			.dmark: db "BP."  
2d1b f1			.pastdmark: pop af  
2d1c			endm  
# End of macro DMARK
2d1c						CALLMONITOR 
2d1c cd 6c fe			call debug_vector  
2d1f				endm  
# End of macro CALLMONITOR
2d1f					endif 
2d1f			 
2d1f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d1f cd fc 22			call macro_dsp_valuehl 
2d22				endm 
# End of macro FORTH_DSP_VALUEHL
2d22			 
2d22			;		push hl 
2d22			 
2d22					; destroy value TOS 
2d22			 
2d22					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d22 cd b4 23			call macro_forth_dsp_pop 
2d25				endm 
# End of macro FORTH_DSP_POP
2d25			 
2d25			;		pop hl 
2d25			 
2d25 3e 00				ld a,0 
2d27 bd					cp l 
2d28 28 06				jr z, .bpset 
2d2a			;		ld a, '*' 
2d2a cd 42 1a				call bp_off 
2d2d					NEXTW 
2d2d c3 b2 24			jp macro_next 
2d30				endm 
# End of macro NEXTW
2d30			 
2d30			.bpset:	 
2d30					;	ld (os_view_disable), a 
2d30 cd 36 1a				call bp_on 
2d33			 
2d33			 
2d33					NEXTW 
2d33 c3 b2 24			jp macro_next 
2d36				endm 
# End of macro NEXTW
2d36			 
2d36			 
2d36			.MONITOR: 
2d36				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2d36 55				db WORD_SYS_CORE+65             
2d37 67 2d			dw .MALLOC            
2d39 08				db 7 + 1 
2d3a .. 00			db "MONITOR",0              
2d42				endm 
# End of macro CWHEAD
2d42			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2d42			; | | At start the current various registers will be displayed with contents. 
2d42			; | | Top right corner will show the most recent debug marker seen. 
2d42			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2d42			; | | and the return stack pointer (RSP). 
2d42			; | | Pressing: 
2d42			; | |    1 - Initial screen 
2d42			; | |    2 - Display a data dump of HL 
2d42			; | |    3 - Display a data dump of DE 
2d42			; | |    4 - Display a data dump of BC 
2d42			; | |    5 - Display a data dump of HL 
2d42			; | |    6 - Display a data dump of DSP 
2d42			; | |    7 - Display a data dump of RSP 
2d42			; | |    8 - Display a data dump of what is at DSP 
2d42			; | |    9 - Display a data dump of what is at RSP 
2d42			; | |    0 - Exit monitor and continue running. This will also enable break points 
2d42			; | |    * - Disable break points 
2d42			; | |    # - Enter traditional monitor mode 
2d42			; | | 
2d42			; | | Monitor Mode 
2d42			; | | ------------ 
2d42			; | | A prompt of '>' will be shown for various commands: 
2d42			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2d42			; | |    C - Continue display a data dump from the last set address 
2d42			; | |    M xxxx - Set start of memory edit at address xx 
2d42			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2d42			; | |    Q - Return to previous 
2d42					if DEBUG_FORTH_WORDS_KEY 
2d42						DMARK "MON" 
2d42 f5				push af  
2d43 3a 57 2d			ld a, (.dmark)  
2d46 32 68 fe			ld (debug_mark),a  
2d49 3a 58 2d			ld a, (.dmark+1)  
2d4c 32 69 fe			ld (debug_mark+1),a  
2d4f 3a 59 2d			ld a, (.dmark+2)  
2d52 32 6a fe			ld (debug_mark+2),a  
2d55 18 03			jr .pastdmark  
2d57 ..			.dmark: db "MON"  
2d5a f1			.pastdmark: pop af  
2d5b			endm  
# End of macro DMARK
2d5b						CALLMONITOR 
2d5b cd 6c fe			call debug_vector  
2d5e				endm  
# End of macro CALLMONITOR
2d5e					endif 
2d5e			;		ld a, 0 
2d5e			;		ld (os_view_disable), a 
2d5e cd 36 1a				call bp_on 
2d61			 
2d61					CALLMONITOR 
2d61 cd 6c fe			call debug_vector  
2d64				endm  
# End of macro CALLMONITOR
2d64			 
2d64			;	call monitor 
2d64			 
2d64					NEXTW 
2d64 c3 b2 24			jp macro_next 
2d67				endm 
# End of macro NEXTW
2d67			 
2d67			 
2d67			.MALLOC: 
2d67				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2d67 56				db WORD_SYS_CORE+66             
2d68 90 2d			dw .MALLOC2            
2d6a 06				db 5 + 1 
2d6b .. 00			db "ALLOT",0              
2d71				endm 
# End of macro CWHEAD
2d71			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d71					if DEBUG_FORTH_WORDS_KEY 
2d71						DMARK "ALL" 
2d71 f5				push af  
2d72 3a 86 2d			ld a, (.dmark)  
2d75 32 68 fe			ld (debug_mark),a  
2d78 3a 87 2d			ld a, (.dmark+1)  
2d7b 32 69 fe			ld (debug_mark+1),a  
2d7e 3a 88 2d			ld a, (.dmark+2)  
2d81 32 6a fe			ld (debug_mark+2),a  
2d84 18 03			jr .pastdmark  
2d86 ..			.dmark: db "ALL"  
2d89 f1			.pastdmark: pop af  
2d8a			endm  
# End of macro DMARK
2d8a						CALLMONITOR 
2d8a cd 6c fe			call debug_vector  
2d8d				endm  
# End of macro CALLMONITOR
2d8d					endif 
2d8d c3 b7 2d				jp .mallocc 
2d90			.MALLOC2: 
2d90				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2d90 56				db WORD_SYS_CORE+66             
2d91 ce 2d			dw .FREE            
2d93 07				db 6 + 1 
2d94 .. 00			db "MALLOC",0              
2d9b				endm 
# End of macro CWHEAD
2d9b			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d9b					; get byte count 
2d9b					if DEBUG_FORTH_WORDS_KEY 
2d9b						DMARK "MAL" 
2d9b f5				push af  
2d9c 3a b0 2d			ld a, (.dmark)  
2d9f 32 68 fe			ld (debug_mark),a  
2da2 3a b1 2d			ld a, (.dmark+1)  
2da5 32 69 fe			ld (debug_mark+1),a  
2da8 3a b2 2d			ld a, (.dmark+2)  
2dab 32 6a fe			ld (debug_mark+2),a  
2dae 18 03			jr .pastdmark  
2db0 ..			.dmark: db "MAL"  
2db3 f1			.pastdmark: pop af  
2db4			endm  
# End of macro DMARK
2db4						CALLMONITOR 
2db4 cd 6c fe			call debug_vector  
2db7				endm  
# End of macro CALLMONITOR
2db7					endif 
2db7			.mallocc: 
2db7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2db7 cd fc 22			call macro_dsp_valuehl 
2dba				endm 
# End of macro FORTH_DSP_VALUEHL
2dba			 
2dba			;		push hl 
2dba			 
2dba					; destroy value TOS 
2dba			 
2dba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2dba cd b4 23			call macro_forth_dsp_pop 
2dbd				endm 
# End of macro FORTH_DSP_POP
2dbd			 
2dbd			;		pop hl 
2dbd cd 97 14				call malloc 
2dc0				if DEBUG_FORTH_MALLOC_GUARD 
2dc0 f5					push af 
2dc1 cd f9 0f				call ishlzero 
2dc4			;		ld a, l 
2dc4			;		add h 
2dc4			;		cp 0 
2dc4 f1					pop af 
2dc5					 
2dc5 cc 04 5e				call z,malloc_error 
2dc8				endif 
2dc8			 
2dc8 cd 05 21				call forth_push_numhl 
2dcb					NEXTW 
2dcb c3 b2 24			jp macro_next 
2dce				endm 
# End of macro NEXTW
2dce			 
2dce			.FREE: 
2dce				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2dce 57				db WORD_SYS_CORE+67             
2dcf ff 2d			dw .LIST            
2dd1 05				db 4 + 1 
2dd2 .. 00			db "FREE",0              
2dd7				endm 
# End of macro CWHEAD
2dd7			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2dd7					if DEBUG_FORTH_WORDS_KEY 
2dd7						DMARK "FRE" 
2dd7 f5				push af  
2dd8 3a ec 2d			ld a, (.dmark)  
2ddb 32 68 fe			ld (debug_mark),a  
2dde 3a ed 2d			ld a, (.dmark+1)  
2de1 32 69 fe			ld (debug_mark+1),a  
2de4 3a ee 2d			ld a, (.dmark+2)  
2de7 32 6a fe			ld (debug_mark+2),a  
2dea 18 03			jr .pastdmark  
2dec ..			.dmark: db "FRE"  
2def f1			.pastdmark: pop af  
2df0			endm  
# End of macro DMARK
2df0						CALLMONITOR 
2df0 cd 6c fe			call debug_vector  
2df3				endm  
# End of macro CALLMONITOR
2df3					endif 
2df3					; get address 
2df3			 
2df3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2df3 cd fc 22			call macro_dsp_valuehl 
2df6				endm 
# End of macro FORTH_DSP_VALUEHL
2df6			 
2df6			;		push hl 
2df6			 
2df6					; destroy value TOS 
2df6			 
2df6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2df6 cd b4 23			call macro_forth_dsp_pop 
2df9				endm 
# End of macro FORTH_DSP_POP
2df9			 
2df9			;		pop hl 
2df9			if FORTH_ENABLE_MALLOCFREE 
2df9 cd 61 15				call free 
2dfc			endif 
2dfc					NEXTW 
2dfc c3 b2 24			jp macro_next 
2dff				endm 
# End of macro NEXTW
2dff			.LIST: 
2dff				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2dff 5c				db WORD_SYS_CORE+72             
2e00 ed 2f			dw .FORGET            
2e02 05				db 4 + 1 
2e03 .. 00			db "LIST",0              
2e08				endm 
# End of macro CWHEAD
2e08			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2e08			; | | The quoted word must be in upper case. 
2e08				if DEBUG_FORTH_WORDS_KEY 
2e08					DMARK "LST" 
2e08 f5				push af  
2e09 3a 1d 2e			ld a, (.dmark)  
2e0c 32 68 fe			ld (debug_mark),a  
2e0f 3a 1e 2e			ld a, (.dmark+1)  
2e12 32 69 fe			ld (debug_mark+1),a  
2e15 3a 1f 2e			ld a, (.dmark+2)  
2e18 32 6a fe			ld (debug_mark+2),a  
2e1b 18 03			jr .pastdmark  
2e1d ..			.dmark: db "LST"  
2e20 f1			.pastdmark: pop af  
2e21			endm  
# End of macro DMARK
2e21					CALLMONITOR 
2e21 cd 6c fe			call debug_vector  
2e24				endm  
# End of macro CALLMONITOR
2e24				endif 
2e24			 
2e24					FORTH_DSP_VALUEHL 
2e24 cd fc 22			call macro_dsp_valuehl 
2e27				endm 
# End of macro FORTH_DSP_VALUEHL
2e27			 
2e27 e5					push hl 
2e28					FORTH_DSP_POP 
2e28 cd b4 23			call macro_forth_dsp_pop 
2e2b				endm 
# End of macro FORTH_DSP_POP
2e2b c1					pop bc 
2e2c			 
2e2c			; Start format of scratch string 
2e2c			 
2e2c 21 be f1				ld hl, scratch 
2e2f			 
2e2f 3e 3a				ld a, ':' 
2e31 77					ld (hl),a 
2e32 23					inc hl 
2e33 3e 20				ld a, ' ' 
2e35 77					ld (hl), a 
2e36			 
2e36					; Get ptr to the word we need to look up 
2e36			 
2e36			;		FORTH_DSP_VALUEHL 
2e36					;v5 FORTH_DSP_VALUE 
2e36				; TODO type check 
2e36			;		inc hl    ; Skip type check  
2e36			;		push hl 
2e36			;		ex de, hl    ; put into DE 
2e36			 
2e36			 
2e36 21 00 80				ld hl, baseram 
2e39					;ld hl, baseusermem 
2e39			 
2e39 e5			push hl   ; sacreifical push 
2e3a			 
2e3a			.ldouscanm: 
2e3a e1				pop hl 
2e3b			.ldouscan: 
2e3b				if DEBUG_FORTH_WORDS 
2e3b					DMARK "LSs" 
2e3b f5				push af  
2e3c 3a 50 2e			ld a, (.dmark)  
2e3f 32 68 fe			ld (debug_mark),a  
2e42 3a 51 2e			ld a, (.dmark+1)  
2e45 32 69 fe			ld (debug_mark+1),a  
2e48 3a 52 2e			ld a, (.dmark+2)  
2e4b 32 6a fe			ld (debug_mark+2),a  
2e4e 18 03			jr .pastdmark  
2e50 ..			.dmark: db "LSs"  
2e53 f1			.pastdmark: pop af  
2e54			endm  
# End of macro DMARK
2e54					CALLMONITOR 
2e54 cd 6c fe			call debug_vector  
2e57				endm  
# End of macro CALLMONITOR
2e57				endif 
2e57				; skip dict stub 
2e57 cd 03 26				call forth_tok_next 
2e5a			 
2e5a			 
2e5a			; while we have words to look for 
2e5a			 
2e5a 7e				ld a, (hl)      
2e5b				if DEBUG_FORTH_WORDS 
2e5b					DMARK "LSk" 
2e5b f5				push af  
2e5c 3a 70 2e			ld a, (.dmark)  
2e5f 32 68 fe			ld (debug_mark),a  
2e62 3a 71 2e			ld a, (.dmark+1)  
2e65 32 69 fe			ld (debug_mark+1),a  
2e68 3a 72 2e			ld a, (.dmark+2)  
2e6b 32 6a fe			ld (debug_mark+2),a  
2e6e 18 03			jr .pastdmark  
2e70 ..			.dmark: db "LSk"  
2e73 f1			.pastdmark: pop af  
2e74			endm  
# End of macro DMARK
2e74					CALLMONITOR 
2e74 cd 6c fe			call debug_vector  
2e77				endm  
# End of macro CALLMONITOR
2e77				endif 
2e77					;cp WORD_SYS_END 
2e77					;jp z, .lunotfound 
2e77			 
2e77					; if we hit non uwords then gone too far 
2e77 fe 01				cp WORD_SYS_UWORD 
2e79 c2 a9 2f				jp nz, .lunotfound 
2e7c			 
2e7c				if DEBUG_FORTH_WORDS 
2e7c					DMARK "LSu" 
2e7c f5				push af  
2e7d 3a 91 2e			ld a, (.dmark)  
2e80 32 68 fe			ld (debug_mark),a  
2e83 3a 92 2e			ld a, (.dmark+1)  
2e86 32 69 fe			ld (debug_mark+1),a  
2e89 3a 93 2e			ld a, (.dmark+2)  
2e8c 32 6a fe			ld (debug_mark+2),a  
2e8f 18 03			jr .pastdmark  
2e91 ..			.dmark: db "LSu"  
2e94 f1			.pastdmark: pop af  
2e95			endm  
# End of macro DMARK
2e95					CALLMONITOR 
2e95 cd 6c fe			call debug_vector  
2e98				endm  
# End of macro CALLMONITOR
2e98				endif 
2e98			 
2e98					; found a uword but is it the one we want... 
2e98			 
2e98 c5					push bc     ; uword to find is on bc 
2e99 d1					pop de 
2e9a			 
2e9a e5					push hl  ; to save the ptr 
2e9b			 
2e9b					; skip opcode 
2e9b 23					inc hl  
2e9c					; skip next ptr 
2e9c 23					inc hl  
2e9d 23					inc hl 
2e9e					; skip len 
2e9e 23					inc hl 
2e9f			 
2e9f				if DEBUG_FORTH_WORDS 
2e9f					DMARK "LSc" 
2e9f f5				push af  
2ea0 3a b4 2e			ld a, (.dmark)  
2ea3 32 68 fe			ld (debug_mark),a  
2ea6 3a b5 2e			ld a, (.dmark+1)  
2ea9 32 69 fe			ld (debug_mark+1),a  
2eac 3a b6 2e			ld a, (.dmark+2)  
2eaf 32 6a fe			ld (debug_mark+2),a  
2eb2 18 03			jr .pastdmark  
2eb4 ..			.dmark: db "LSc"  
2eb7 f1			.pastdmark: pop af  
2eb8			endm  
# End of macro DMARK
2eb8					CALLMONITOR 
2eb8 cd 6c fe			call debug_vector  
2ebb				endm  
# End of macro CALLMONITOR
2ebb				endif 
2ebb cd 66 14				call strcmp 
2ebe c2 3a 2e				jp nz, .ldouscanm 
2ec1				 
2ec1			 
2ec1			 
2ec1					; we have a uword so push its name to the stack 
2ec1			 
2ec1			;	   	push hl  ; save so we can move to next dict block 
2ec1 e1			pop hl 
2ec2			 
2ec2				if DEBUG_FORTH_WORDS 
2ec2					DMARK "LSm" 
2ec2 f5				push af  
2ec3 3a d7 2e			ld a, (.dmark)  
2ec6 32 68 fe			ld (debug_mark),a  
2ec9 3a d8 2e			ld a, (.dmark+1)  
2ecc 32 69 fe			ld (debug_mark+1),a  
2ecf 3a d9 2e			ld a, (.dmark+2)  
2ed2 32 6a fe			ld (debug_mark+2),a  
2ed5 18 03			jr .pastdmark  
2ed7 ..			.dmark: db "LSm"  
2eda f1			.pastdmark: pop af  
2edb			endm  
# End of macro DMARK
2edb					CALLMONITOR 
2edb cd 6c fe			call debug_vector  
2ede				endm  
# End of macro CALLMONITOR
2ede				endif 
2ede			 
2ede					; skip opcode 
2ede 23					inc hl  
2edf					; skip next ptr 
2edf 23					inc hl  
2ee0 23					inc hl 
2ee1					; skip len 
2ee1 7e					ld a, (hl)   ; save length to add 
2ee2				if DEBUG_FORTH_WORDS 
2ee2					DMARK "LS2" 
2ee2 f5				push af  
2ee3 3a f7 2e			ld a, (.dmark)  
2ee6 32 68 fe			ld (debug_mark),a  
2ee9 3a f8 2e			ld a, (.dmark+1)  
2eec 32 69 fe			ld (debug_mark+1),a  
2eef 3a f9 2e			ld a, (.dmark+2)  
2ef2 32 6a fe			ld (debug_mark+2),a  
2ef5 18 03			jr .pastdmark  
2ef7 ..			.dmark: db "LS2"  
2efa f1			.pastdmark: pop af  
2efb			endm  
# End of macro DMARK
2efb					CALLMONITOR 
2efb cd 6c fe			call debug_vector  
2efe				endm  
# End of macro CALLMONITOR
2efe				endif 
2efe			 
2efe					; save this location 
2efe				 
2efe e5					push hl 
2eff			 
2eff 23					inc hl 
2f00 11 c0 f1				ld de, scratch+2 
2f03 4f					ld c, a 
2f04 06 00				ld b, 0 
2f06			 
2f06				if DEBUG_FORTH_WORDS 
2f06					DMARK "LSn" 
2f06 f5				push af  
2f07 3a 1b 2f			ld a, (.dmark)  
2f0a 32 68 fe			ld (debug_mark),a  
2f0d 3a 1c 2f			ld a, (.dmark+1)  
2f10 32 69 fe			ld (debug_mark+1),a  
2f13 3a 1d 2f			ld a, (.dmark+2)  
2f16 32 6a fe			ld (debug_mark+2),a  
2f19 18 03			jr .pastdmark  
2f1b ..			.dmark: db "LSn"  
2f1e f1			.pastdmark: pop af  
2f1f			endm  
# End of macro DMARK
2f1f					CALLMONITOR 
2f1f cd 6c fe			call debug_vector  
2f22				endm  
# End of macro CALLMONITOR
2f22				endif 
2f22			 
2f22					; copy uword name to scratch 
2f22			 
2f22 ed b0				ldir 
2f24			 
2f24 1b					dec de 
2f25 3e 20				ld a, ' '    ; change null to space 
2f27 12					ld (de), a 
2f28			 
2f28 13					inc de 
2f29			 
2f29 d5					push de 
2f2a c1					pop bc     ; move scratch pointer to end of word name and save it 
2f2b			 
2f2b e1					pop hl 
2f2c 7e					ld a, (hl) 
2f2d					;inc hl 
2f2d					; skip word string 
2f2d cd d0 0f				call addatohl 
2f30			 
2f30 23					inc hl 
2f31			 
2f31				if DEBUG_FORTH_WORDS 
2f31					DMARK "LS3" 
2f31 f5				push af  
2f32 3a 46 2f			ld a, (.dmark)  
2f35 32 68 fe			ld (debug_mark),a  
2f38 3a 47 2f			ld a, (.dmark+1)  
2f3b 32 69 fe			ld (debug_mark+1),a  
2f3e 3a 48 2f			ld a, (.dmark+2)  
2f41 32 6a fe			ld (debug_mark+2),a  
2f44 18 03			jr .pastdmark  
2f46 ..			.dmark: db "LS3"  
2f49 f1			.pastdmark: pop af  
2f4a			endm  
# End of macro DMARK
2f4a					CALLMONITOR 
2f4a cd 6c fe			call debug_vector  
2f4d				endm  
# End of macro CALLMONITOR
2f4d				endif 
2f4d					; should now be at the start of the machine code to setup the eval of the uword 
2f4d					; now locate the ptr to the string defintion 
2f4d			 
2f4d					; skip ld hl, 
2f4d					; then load the ptr 
2f4d			; TODO use get from hl ptr 
2f4d 23					inc hl 
2f4e 5e					ld e, (hl) 
2f4f 23					inc hl 
2f50 56					ld d, (hl) 
2f51 eb					ex de, hl 
2f52			 
2f52			 
2f52				if DEBUG_FORTH_WORDS 
2f52					DMARK "LSt" 
2f52 f5				push af  
2f53 3a 67 2f			ld a, (.dmark)  
2f56 32 68 fe			ld (debug_mark),a  
2f59 3a 68 2f			ld a, (.dmark+1)  
2f5c 32 69 fe			ld (debug_mark+1),a  
2f5f 3a 69 2f			ld a, (.dmark+2)  
2f62 32 6a fe			ld (debug_mark+2),a  
2f65 18 03			jr .pastdmark  
2f67 ..			.dmark: db "LSt"  
2f6a f1			.pastdmark: pop af  
2f6b			endm  
# End of macro DMARK
2f6b					CALLMONITOR 
2f6b cd 6c fe			call debug_vector  
2f6e				endm  
# End of macro CALLMONITOR
2f6e				endif 
2f6e			 
2f6e			; cant push right now due to tokenised strings  
2f6e			 
2f6e			; get the destination of where to copy this definition to. 
2f6e			 
2f6e c5					push bc 
2f6f d1					pop de 
2f70			 
2f70 7e			.listl:         ld a,(hl) 
2f71 fe 00				cp 0 
2f73 28 09				jr z, .lreplsp     ; replace zero with space 
2f75					;cp FORTH_END_BUFFER 
2f75 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2f77 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2f79				 
2f79					; just copy this char as is then 
2f79			 
2f79 12					ld (de), a 
2f7a			 
2f7a 23			.listnxt:	inc hl 
2f7b 13					inc de 
2f7c 18 f2				jr .listl 
2f7e			 
2f7e 3e 20		.lreplsp:	ld a,' ' 
2f80 12					ld (de), a 
2f81 18 f7				jr .listnxt 
2f83			 
2f83			; close up uword def 
2f83			 
2f83			.listdone: 
2f83 12					ld (de), a 
2f84 13					inc de 
2f85 3e 00				ld a, 0 
2f87 12					ld (de), a 
2f88			 
2f88			; now have def so clean up and push to stack 
2f88			 
2f88 21 be f1				ld hl, scratch 
2f8b				if DEBUG_FORTH_WORDS 
2f8b					DMARK "Ltp" 
2f8b f5				push af  
2f8c 3a a0 2f			ld a, (.dmark)  
2f8f 32 68 fe			ld (debug_mark),a  
2f92 3a a1 2f			ld a, (.dmark+1)  
2f95 32 69 fe			ld (debug_mark+1),a  
2f98 3a a2 2f			ld a, (.dmark+2)  
2f9b 32 6a fe			ld (debug_mark+2),a  
2f9e 18 03			jr .pastdmark  
2fa0 ..			.dmark: db "Ltp"  
2fa3 f1			.pastdmark: pop af  
2fa4			endm  
# End of macro DMARK
2fa4					CALLMONITOR 
2fa4 cd 6c fe			call debug_vector  
2fa7				endm  
# End of macro CALLMONITOR
2fa7				endif 
2fa7			 
2fa7 18 1f			jr .listpush 
2fa9			 
2fa9			;.lnuword:	pop hl 
2fa9			;		call forth_tok_next 
2fa9			;		jp .ldouscan  
2fa9			 
2fa9			.lunotfound:		  
2fa9			 
2fa9				if DEBUG_FORTH_WORDS 
2fa9					DMARK "LSn" 
2fa9 f5				push af  
2faa 3a be 2f			ld a, (.dmark)  
2fad 32 68 fe			ld (debug_mark),a  
2fb0 3a bf 2f			ld a, (.dmark+1)  
2fb3 32 69 fe			ld (debug_mark+1),a  
2fb6 3a c0 2f			ld a, (.dmark+2)  
2fb9 32 6a fe			ld (debug_mark+2),a  
2fbc 18 03			jr .pastdmark  
2fbe ..			.dmark: db "LSn"  
2fc1 f1			.pastdmark: pop af  
2fc2			endm  
# End of macro DMARK
2fc2					CALLMONITOR 
2fc2 cd 6c fe			call debug_vector  
2fc5				endm  
# End of macro CALLMONITOR
2fc5				endif 
2fc5			 
2fc5					 
2fc5			;		FORTH_DSP_POP 
2fc5			;		ld hl, .luno 
2fc5			 
2fc5					NEXTW			 
2fc5 c3 b2 24			jp macro_next 
2fc8				endm 
# End of macro NEXTW
2fc8			 
2fc8			.listpush: 
2fc8				if DEBUG_FORTH_WORDS 
2fc8					DMARK "LS>" 
2fc8 f5				push af  
2fc9 3a dd 2f			ld a, (.dmark)  
2fcc 32 68 fe			ld (debug_mark),a  
2fcf 3a de 2f			ld a, (.dmark+1)  
2fd2 32 69 fe			ld (debug_mark+1),a  
2fd5 3a df 2f			ld a, (.dmark+2)  
2fd8 32 6a fe			ld (debug_mark+2),a  
2fdb 18 03			jr .pastdmark  
2fdd ..			.dmark: db "LS>"  
2fe0 f1			.pastdmark: pop af  
2fe1			endm  
# End of macro DMARK
2fe1					CALLMONITOR 
2fe1 cd 6c fe			call debug_vector  
2fe4				endm  
# End of macro CALLMONITOR
2fe4				endif 
2fe4 cd 73 21				call forth_push_str 
2fe7			 
2fe7			 
2fe7			 
2fe7					NEXTW 
2fe7 c3 b2 24			jp macro_next 
2fea				endm 
# End of macro NEXTW
2fea			 
2fea			;.luno:    db "Word not found",0 
2fea			 
2fea			 
2fea			 
2fea			 
2fea			 
2fea			;		push hl   ; save pointer to start of uword def string 
2fea			; 
2fea			;; look for FORTH_EOL_LINE 
2fea			;		ld a, FORTH_END_BUFFER 
2fea			;		call strlent 
2fea			; 
2fea			;		inc hl		 ; space for coln def 
2fea			;		inc hl 
2fea			;		inc hl          ; space for terms 
2fea			;		inc hl 
2fea			; 
2fea			;		ld a, 20   ; TODO get actual length 
2fea			;		call addatohl    ; include a random amount of room for the uword name 
2fea			; 
2fea			;		 
2fea			;	if DEBUG_FORTH_WORDS 
2fea			;		DMARK "Lt1" 
2fea			;		CALLMONITOR 
2fea			;	endif 
2fea			;		 
2fea			; 
2fea			;; malloc space for the string because we cant change it 
2fea			; 
2fea			;		call malloc 
2fea			;	if DEBUG_FORTH_MALLOC_GUARD 
2fea			;		push af 
2fea			;		call ishlzero 
2fea			;		pop af 
2fea			;		 
2fea			;		call z,malloc_error 
2fea			;	endif 
2fea			; 
2fea			;	if DEBUG_FORTH_WORDS 
2fea			;		DMARK "Lt2" 
2fea			;		CALLMONITOR 
2fea			;	endif 
2fea			;		pop de 
2fea			;		push hl    ; push the malloc to release later 
2fea			;		push hl   ;  push back a copy for the later stack push 
2fea			;		 
2fea			;; copy the string swapping out the zero terms for spaces 
2fea			; 
2fea			;		; de has our source 
2fea			;		; hl has our dest 
2fea			; 
2fea			;; add the coln def 
2fea			; 
2fea			;		ld a, ':' 
2fea			;		ld (hl), a 
2fea			;		inc hl 
2fea			;		ld a, ' ' 
2fea			;		ld (hl), a 
2fea			;		inc hl 
2fea			; 
2fea			;; add the uname word 
2fea			;		push de   ; save our string for now 
2fea			;		ex de, hl 
2fea			; 
2fea			;		FORTH_DSP_VALUE 
2fea			;		;v5 FORTH_DSP_VALUE 
2fea			; 
2fea			;		inc hl   ; skip type but we know by now this is OK 
2fea			; 
2fea			;.luword:	ld a,(hl) 
2fea			;		cp 0 
2fea			;		jr z, .luword2 
2fea			;		ld (de), a 
2fea			;		inc de 
2fea			;		inc hl 
2fea			;		jr .luword 
2fea			; 
2fea			;.luword2:	ld a, ' ' 
2fea			;		ld (de), a 
2fea			;;		inc hl 
2fea			;;		inc de 
2fea			;;		ld (de), a 
2fea			;;		inc hl 
2fea			;		inc de 
2fea			; 
2fea			;		ex de, hl 
2fea			;		pop de 
2fea			;		 
2fea			;		 
2fea			; 
2fea			;; detoken that string and copy it 
2fea			; 
2fea			;	if DEBUG_FORTH_WORDS 
2fea			;		DMARK "Lt2" 
2fea			;		CALLMONITOR 
2fea			;	endif 
2fea			;.ldetok:	ld a, (de) 
2fea			;		cp FORTH_END_BUFFER 
2fea			;		jr z, .ldetokend 
2fea			;		; swap out any zero term for space 
2fea			;		cp 0 
2fea			;		jr nz, .ldetoknext 
2fea			;		ld a, ' ' 
2fea			; 
2fea			;	if DEBUG_FORTH_WORDS 
2fea			;		DMARK "LtS" 
2fea			;		CALLMONITOR 
2fea			;	endif 
2fea			;.ldetoknext:	ld (hl), a 
2fea			;		inc de 
2fea			;		inc hl 
2fea			;		jr .ldetok 
2fea			; 
2fea			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2fea			;		ld (hl), a  
2fea			; 
2fea			;; free that temp malloc 
2fea			; 
2fea			;		pop hl    
2fea			; 
2fea			;	if DEBUG_FORTH_WORDS 
2fea			;		DMARK "Lt4" 
2fea			;		CALLMONITOR 
2fea			;	endif 
2fea			;		call forth_apushstrhl 
2fea			; 
2fea			;		; get rid of temp malloc area 
2fea			; 
2fea			;		pop hl 
2fea			;		call free 
2fea			; 
2fea			;		jr .ludone 
2fea			; 
2fea			;.lnuword:	pop hl 
2fea			;		call forth_tok_next 
2fea			;		jp .ldouscan  
2fea			; 
2fea			;.ludone:		 pop hl 
2fea			; 
2fea					NEXTW 
2fea c3 b2 24			jp macro_next 
2fed				endm 
# End of macro NEXTW
2fed			 
2fed			.FORGET: 
2fed				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2fed 5d				db WORD_SYS_CORE+73             
2fee 66 30			dw .NOP            
2ff0 07				db 6 + 1 
2ff1 .. 00			db "FORGET",0              
2ff8				endm 
# End of macro CWHEAD
2ff8			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2ff8			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2ff8			; | |  
2ff8			; | | e.g. "MORE" forget 
2ff8					if DEBUG_FORTH_WORDS_KEY 
2ff8						DMARK "FRG" 
2ff8 f5				push af  
2ff9 3a 0d 30			ld a, (.dmark)  
2ffc 32 68 fe			ld (debug_mark),a  
2fff 3a 0e 30			ld a, (.dmark+1)  
3002 32 69 fe			ld (debug_mark+1),a  
3005 3a 0f 30			ld a, (.dmark+2)  
3008 32 6a fe			ld (debug_mark+2),a  
300b 18 03			jr .pastdmark  
300d ..			.dmark: db "FRG"  
3010 f1			.pastdmark: pop af  
3011			endm  
# End of macro DMARK
3011						CALLMONITOR 
3011 cd 6c fe			call debug_vector  
3014				endm  
# End of macro CALLMONITOR
3014					endif 
3014			 
3014				; find uword 
3014			        ; update start of word with "_" 
3014				; replace uword with deleted flag 
3014			 
3014			 
3014			;	if DEBUG_FORTH_WORDS 
3014			;		DMARK "FOG" 
3014			;		CALLMONITOR 
3014			;	endif 
3014			 
3014			 
3014					; Get ptr to the word we need to look up 
3014			 
3014					FORTH_DSP_VALUEHL 
3014 cd fc 22			call macro_dsp_valuehl 
3017				endm 
# End of macro FORTH_DSP_VALUEHL
3017					;v5 FORTH_DSP_VALUE 
3017				; TODO type check 
3017			;		inc hl    ; Skip type check  
3017 e5					push hl 
3018 c1					pop bc 
3019			;		ex de, hl    ; put into DE 
3019			 
3019			 
3019 21 00 80				ld hl, baseram 
301c					;ld hl, baseusermem 
301c			 
301c				; skip dict stub 
301c			;	call forth_tok_next 
301c e5			push hl   ; sacreifical push 
301d			 
301d			.fldouscanm: 
301d e1				pop hl 
301e			.fldouscan: 
301e			;	if DEBUG_FORTH_WORDS 
301e			;		DMARK "LSs" 
301e			;		CALLMONITOR 
301e			;	endif 
301e				; skip dict stub 
301e cd 03 26				call forth_tok_next 
3021			 
3021			 
3021			; while we have words to look for 
3021			 
3021 7e				ld a, (hl)      
3022			;	if DEBUG_FORTH_WORDS 
3022			;		DMARK "LSk" 
3022			;		CALLMONITOR 
3022			;	endif 
3022 fe 00				cp WORD_SYS_END 
3024 ca 60 30				jp z, .flunotfound 
3027 fe 01				cp WORD_SYS_UWORD 
3029 c2 1e 30				jp nz, .fldouscan 
302c			 
302c			;	if DEBUG_FORTH_WORDS 
302c			;		DMARK "LSu" 
302c			;		CALLMONITOR 
302c			;	endif 
302c			 
302c					; found a uword but is it the one we want... 
302c			 
302c c5					push bc     ; uword to find is on bc 
302d d1					pop de 
302e			 
302e e5					push hl  ; to save the ptr 
302f			 
302f					; skip opcode 
302f 23					inc hl  
3030					; skip next ptr 
3030 23					inc hl  
3031 23					inc hl 
3032					; skip len 
3032 23					inc hl 
3033			 
3033			;	if DEBUG_FORTH_WORDS 
3033			;		DMARK "LSc" 
3033			;		CALLMONITOR 
3033			;	endif 
3033 cd 66 14				call strcmp 
3036 c2 1d 30				jp nz, .fldouscanm 
3039			; 
3039			; 
3039			;; while we have words to look for 
3039			; 
3039			;.fdouscan:	ld a, (hl)      
3039			;	if DEBUG_FORTH_WORDS 
3039			;		DMARK "LSs" 
3039			;		CALLMONITOR 
3039			;	endif 
3039			;		cp WORD_SYS_END 
3039			;		jp z, .fudone 
3039			;		cp WORD_SYS_UWORD 
3039			;		jp nz, .fnuword 
3039			; 
3039			;	if DEBUG_FORTH_WORDS 
3039			;		DMARK "FGu" 
3039			;		CALLMONITOR 
3039			;	endif 
3039			; 
3039			;		; found a uword but is it the one we want... 
3039			; 
3039			; 
3039			;	        pop de   ; get back the dsp name 
3039			;		push de 
3039			; 
3039			;		push hl  ; to save the ptr 
3039			; 
3039			;		; skip opcode 
3039			;		inc hl  
3039			;		; skip next ptr 
3039			;		inc hl  
3039			;		inc hl 
3039			;		; skip len 
3039			;		inc hl 
3039			; 
3039			;	if DEBUG_FORTH_WORDS 
3039			;		DMARK "FGc" 
3039			;		CALLMONITOR 
3039			;	endif 
3039			;		call strcmp 
3039			;		jp nz, .fnuword 
3039			 
3039			 
3039 e1			pop hl 
303a			 
303a				 
303a				if DEBUG_FORTH_WORDS 
303a					DMARK "FGm" 
303a f5				push af  
303b 3a 4f 30			ld a, (.dmark)  
303e 32 68 fe			ld (debug_mark),a  
3041 3a 50 30			ld a, (.dmark+1)  
3044 32 69 fe			ld (debug_mark+1),a  
3047 3a 51 30			ld a, (.dmark+2)  
304a 32 6a fe			ld (debug_mark+2),a  
304d 18 03			jr .pastdmark  
304f ..			.dmark: db "FGm"  
3052 f1			.pastdmark: pop af  
3053			endm  
# End of macro DMARK
3053					CALLMONITOR 
3053 cd 6c fe			call debug_vector  
3056				endm  
# End of macro CALLMONITOR
3056				endif 
3056			 
3056			 
3056			 
3056					; we have a uword so push its name to the stack 
3056			 
3056			;	   	push hl  ; save so we can move to next dict block 
3056			;pop hl 
3056			 
3056					; update opcode to deleted 
3056 3e 03				ld a, WORD_SYS_DELETED 
3058 77					ld (hl), a 
3059			 
3059 23					inc hl  
305a					; skip next ptr 
305a 23					inc hl  
305b 23					inc hl 
305c					; skip len 
305c 23					inc hl 
305d			 
305d					; TODO change parser to skip deleted words but for now mark it out 
305d 3e 5f				ld a, "_" 
305f 77					ld  (hl),a 
3060			 
3060			;		jr .fudone 
3060			; 
3060			;.fnuword:	pop hl 
3060			;		call forth_tok_next 
3060			;		jp .fdouscan  
3060			 
3060			.flunotfound:		  
3060			 
3060			 
3060					 
3060					FORTH_DSP_POP 
3060 cd b4 23			call macro_forth_dsp_pop 
3063				endm 
# End of macro FORTH_DSP_POP
3063			;		ld hl, .luno 
3063			;.fudone:		 pop hl 
3063					NEXTW 
3063 c3 b2 24			jp macro_next 
3066				endm 
# End of macro NEXTW
3066			.NOP: 
3066				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
3066 61				db WORD_SYS_CORE+77             
3067 8d 30			dw .COMO            
3069 04				db 3 + 1 
306a .. 00			db "NOP",0              
306e				endm 
# End of macro CWHEAD
306e			; | NOP (  --  ) Do nothing | DONE 
306e					if DEBUG_FORTH_WORDS_KEY 
306e						DMARK "NOP" 
306e f5				push af  
306f 3a 83 30			ld a, (.dmark)  
3072 32 68 fe			ld (debug_mark),a  
3075 3a 84 30			ld a, (.dmark+1)  
3078 32 69 fe			ld (debug_mark+1),a  
307b 3a 85 30			ld a, (.dmark+2)  
307e 32 6a fe			ld (debug_mark+2),a  
3081 18 03			jr .pastdmark  
3083 ..			.dmark: db "NOP"  
3086 f1			.pastdmark: pop af  
3087			endm  
# End of macro DMARK
3087						CALLMONITOR 
3087 cd 6c fe			call debug_vector  
308a				endm  
# End of macro CALLMONITOR
308a					endif 
308a				       NEXTW 
308a c3 b2 24			jp macro_next 
308d				endm 
# End of macro NEXTW
308d			.COMO: 
308d				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
308d 6e				db WORD_SYS_CORE+90             
308e df 30			dw .COMC            
3090 02				db 1 + 1 
3091 .. 00			db "(",0              
3093				endm 
# End of macro CWHEAD
3093			; | ( ( -- )  Start of comment | DONE 
3093			 
3093			 
3093 2a bf f4				ld hl, ( os_tok_ptr) 
3096 11 da 30			ld de, .closepar 
3099					 
3099					if DEBUG_FORTH_WORDS 
3099						DMARK ").." 
3099 f5				push af  
309a 3a ae 30			ld a, (.dmark)  
309d 32 68 fe			ld (debug_mark),a  
30a0 3a af 30			ld a, (.dmark+1)  
30a3 32 69 fe			ld (debug_mark+1),a  
30a6 3a b0 30			ld a, (.dmark+2)  
30a9 32 6a fe			ld (debug_mark+2),a  
30ac 18 03			jr .pastdmark  
30ae ..			.dmark: db ").."  
30b1 f1			.pastdmark: pop af  
30b2			endm  
# End of macro DMARK
30b2						CALLMONITOR 
30b2 cd 6c fe			call debug_vector  
30b5				endm  
# End of macro CALLMONITOR
30b5					endif 
30b5 cd cd 25			call findnexttok  
30b8			 
30b8					if DEBUG_FORTH_WORDS 
30b8						DMARK "IF5" 
30b8 f5				push af  
30b9 3a cd 30			ld a, (.dmark)  
30bc 32 68 fe			ld (debug_mark),a  
30bf 3a ce 30			ld a, (.dmark+1)  
30c2 32 69 fe			ld (debug_mark+1),a  
30c5 3a cf 30			ld a, (.dmark+2)  
30c8 32 6a fe			ld (debug_mark+2),a  
30cb 18 03			jr .pastdmark  
30cd ..			.dmark: db "IF5"  
30d0 f1			.pastdmark: pop af  
30d1			endm  
# End of macro DMARK
30d1						CALLMONITOR 
30d1 cd 6c fe			call debug_vector  
30d4				endm  
# End of macro CALLMONITOR
30d4					endif 
30d4				; replace below with ) exec using tok_ptr 
30d4 22 bf f4			ld (os_tok_ptr), hl 
30d7 c3 43 25			jp exec1 
30da			 
30da .. 00			.closepar:   db ")",0 
30dc			 
30dc				       NEXTW 
30dc c3 b2 24			jp macro_next 
30df				endm 
# End of macro NEXTW
30df			.COMC: 
30df				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
30df 6f				db WORD_SYS_CORE+91             
30e0 e8 30			dw .SCRATCH            
30e2 02				db 1 + 1 
30e3 .. 00			db ")",0              
30e5				endm 
# End of macro CWHEAD
30e5			; | ) ( -- )  End of comment |  DONE  
30e5				       NEXTW 
30e5 c3 b2 24			jp macro_next 
30e8				endm 
# End of macro NEXTW
30e8			 
30e8			.SCRATCH: 
30e8				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
30e8 6f				db WORD_SYS_CORE+91             
30e9 23 31			dw .INC            
30eb 08				db 7 + 1 
30ec .. 00			db "SCRATCH",0              
30f4				endm 
# End of macro CWHEAD
30f4			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
30f4			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
30f4			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
30f4			; | |  
30f4			; | | e.g.    : score $00 scratch ; 
30f4			; | |  
30f4			; | | $00 score ! 
30f4			; | | $01 score +! 
30f4			; | |  
30f4			; | | e.g.   : varword $0a scratch ;  
30f4			; | | 
30f4			; | | $8000 varword ! 
30f4					if DEBUG_FORTH_WORDS_KEY 
30f4						DMARK "SCR" 
30f4 f5				push af  
30f5 3a 09 31			ld a, (.dmark)  
30f8 32 68 fe			ld (debug_mark),a  
30fb 3a 0a 31			ld a, (.dmark+1)  
30fe 32 69 fe			ld (debug_mark+1),a  
3101 3a 0b 31			ld a, (.dmark+2)  
3104 32 6a fe			ld (debug_mark+2),a  
3107 18 03			jr .pastdmark  
3109 ..			.dmark: db "SCR"  
310c f1			.pastdmark: pop af  
310d			endm  
# End of macro DMARK
310d						CALLMONITOR 
310d cd 6c fe			call debug_vector  
3110				endm  
# End of macro CALLMONITOR
3110					endif 
3110			 
3110					FORTH_DSP_VALUEHL 
3110 cd fc 22			call macro_dsp_valuehl 
3113				endm 
# End of macro FORTH_DSP_VALUEHL
3113				 
3113					FORTH_DSP_POP 
3113 cd b4 23			call macro_forth_dsp_pop 
3116				endm 
# End of macro FORTH_DSP_POP
3116			 
3116 7d					ld a, l 
3117 21 e3 f6				ld hl, os_var_array 
311a cd d0 0f				call addatohl 
311d			 
311d cd 05 21				call forth_push_numhl 
3120			 
3120				       NEXTW 
3120 c3 b2 24			jp macro_next 
3123				endm 
# End of macro NEXTW
3123			 
3123			.INC: 
3123				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3123 6f				db WORD_SYS_CORE+91             
3124 77 31			dw .DEC            
3126 03				db 2 + 1 
3127 .. 00			db "+!",0              
312a				endm 
# End of macro CWHEAD
312a			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
312a					if DEBUG_FORTH_WORDS_KEY 
312a						DMARK "+s_" 
312a f5				push af  
312b 3a 3f 31			ld a, (.dmark)  
312e 32 68 fe			ld (debug_mark),a  
3131 3a 40 31			ld a, (.dmark+1)  
3134 32 69 fe			ld (debug_mark+1),a  
3137 3a 41 31			ld a, (.dmark+2)  
313a 32 6a fe			ld (debug_mark+2),a  
313d 18 03			jr .pastdmark  
313f ..			.dmark: db "+s_"  
3142 f1			.pastdmark: pop af  
3143			endm  
# End of macro DMARK
3143						CALLMONITOR 
3143 cd 6c fe			call debug_vector  
3146				endm  
# End of macro CALLMONITOR
3146					endif 
3146			 
3146					FORTH_DSP_VALUEHL 
3146 cd fc 22			call macro_dsp_valuehl 
3149				endm 
# End of macro FORTH_DSP_VALUEHL
3149			 
3149 e5					push hl   ; save address 
314a			 
314a					FORTH_DSP_POP 
314a cd b4 23			call macro_forth_dsp_pop 
314d				endm 
# End of macro FORTH_DSP_POP
314d			 
314d					FORTH_DSP_VALUEHL 
314d cd fc 22			call macro_dsp_valuehl 
3150				endm 
# End of macro FORTH_DSP_VALUEHL
3150			 
3150					FORTH_DSP_POP 
3150 cd b4 23			call macro_forth_dsp_pop 
3153				endm 
# End of macro FORTH_DSP_POP
3153			 
3153					; hl contains value to add to byte at a 
3153				 
3153 eb					ex de, hl 
3154			 
3154 e1					pop hl 
3155			 
3155					if DEBUG_FORTH_WORDS 
3155						DMARK "INC" 
3155 f5				push af  
3156 3a 6a 31			ld a, (.dmark)  
3159 32 68 fe			ld (debug_mark),a  
315c 3a 6b 31			ld a, (.dmark+1)  
315f 32 69 fe			ld (debug_mark+1),a  
3162 3a 6c 31			ld a, (.dmark+2)  
3165 32 6a fe			ld (debug_mark+2),a  
3168 18 03			jr .pastdmark  
316a ..			.dmark: db "INC"  
316d f1			.pastdmark: pop af  
316e			endm  
# End of macro DMARK
316e						CALLMONITOR 
316e cd 6c fe			call debug_vector  
3171				endm  
# End of macro CALLMONITOR
3171					endif 
3171			 
3171 7e					ld a,(hl) 
3172 83					add e 
3173 77					ld (hl),a 
3174			 
3174			 
3174			 
3174				       NEXTW 
3174 c3 b2 24			jp macro_next 
3177				endm 
# End of macro NEXTW
3177			 
3177			.DEC: 
3177				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
3177 6f				db WORD_SYS_CORE+91             
3178 c8 31			dw .INC2            
317a 03				db 2 + 1 
317b .. 00			db "-!",0              
317e				endm 
# End of macro CWHEAD
317e			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
317e					if DEBUG_FORTH_WORDS_KEY 
317e						DMARK "-s_" 
317e f5				push af  
317f 3a 93 31			ld a, (.dmark)  
3182 32 68 fe			ld (debug_mark),a  
3185 3a 94 31			ld a, (.dmark+1)  
3188 32 69 fe			ld (debug_mark+1),a  
318b 3a 95 31			ld a, (.dmark+2)  
318e 32 6a fe			ld (debug_mark+2),a  
3191 18 03			jr .pastdmark  
3193 ..			.dmark: db "-s_"  
3196 f1			.pastdmark: pop af  
3197			endm  
# End of macro DMARK
3197						CALLMONITOR 
3197 cd 6c fe			call debug_vector  
319a				endm  
# End of macro CALLMONITOR
319a					endif 
319a			 
319a					FORTH_DSP_VALUEHL 
319a cd fc 22			call macro_dsp_valuehl 
319d				endm 
# End of macro FORTH_DSP_VALUEHL
319d			 
319d e5					push hl   ; save address 
319e			 
319e					FORTH_DSP_POP 
319e cd b4 23			call macro_forth_dsp_pop 
31a1				endm 
# End of macro FORTH_DSP_POP
31a1			 
31a1					FORTH_DSP_VALUEHL 
31a1 cd fc 22			call macro_dsp_valuehl 
31a4				endm 
# End of macro FORTH_DSP_VALUEHL
31a4			 
31a4					; hl contains value to add to byte at a 
31a4				 
31a4 eb					ex de, hl 
31a5			 
31a5 e1					pop hl 
31a6			 
31a6					if DEBUG_FORTH_WORDS 
31a6						DMARK "DEC" 
31a6 f5				push af  
31a7 3a bb 31			ld a, (.dmark)  
31aa 32 68 fe			ld (debug_mark),a  
31ad 3a bc 31			ld a, (.dmark+1)  
31b0 32 69 fe			ld (debug_mark+1),a  
31b3 3a bd 31			ld a, (.dmark+2)  
31b6 32 6a fe			ld (debug_mark+2),a  
31b9 18 03			jr .pastdmark  
31bb ..			.dmark: db "DEC"  
31be f1			.pastdmark: pop af  
31bf			endm  
# End of macro DMARK
31bf						CALLMONITOR 
31bf cd 6c fe			call debug_vector  
31c2				endm  
# End of macro CALLMONITOR
31c2					endif 
31c2			 
31c2 7e					ld a,(hl) 
31c3 93					sub e 
31c4 77					ld (hl),a 
31c5			 
31c5			 
31c5			 
31c5				       NEXTW 
31c5 c3 b2 24			jp macro_next 
31c8				endm 
# End of macro NEXTW
31c8			 
31c8			.INC2: 
31c8				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
31c8 6f				db WORD_SYS_CORE+91             
31c9 72 32			dw .DEC2            
31cb 04				db 3 + 1 
31cc .. 00			db "+2!",0              
31d0				endm 
# End of macro CWHEAD
31d0			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
31d0			 
31d0					if DEBUG_FORTH_WORDS_KEY 
31d0						DMARK "+2s" 
31d0 f5				push af  
31d1 3a e5 31			ld a, (.dmark)  
31d4 32 68 fe			ld (debug_mark),a  
31d7 3a e6 31			ld a, (.dmark+1)  
31da 32 69 fe			ld (debug_mark+1),a  
31dd 3a e7 31			ld a, (.dmark+2)  
31e0 32 6a fe			ld (debug_mark+2),a  
31e3 18 03			jr .pastdmark  
31e5 ..			.dmark: db "+2s"  
31e8 f1			.pastdmark: pop af  
31e9			endm  
# End of macro DMARK
31e9						CALLMONITOR 
31e9 cd 6c fe			call debug_vector  
31ec				endm  
# End of macro CALLMONITOR
31ec					endif 
31ec			 
31ec					; Address 
31ec			 
31ec					FORTH_DSP_VALUEHL 
31ec cd fc 22			call macro_dsp_valuehl 
31ef				endm 
# End of macro FORTH_DSP_VALUEHL
31ef			 
31ef e5					push hl    ; save address 
31f0			 
31f0					; load content into de 
31f0			 
31f0 5e					ld e,(hl) 
31f1 23					inc hl 
31f2 56					ld d, (hl) 
31f3			 
31f3					if DEBUG_FORTH_WORDS 
31f3						DMARK "+2a" 
31f3 f5				push af  
31f4 3a 08 32			ld a, (.dmark)  
31f7 32 68 fe			ld (debug_mark),a  
31fa 3a 09 32			ld a, (.dmark+1)  
31fd 32 69 fe			ld (debug_mark+1),a  
3200 3a 0a 32			ld a, (.dmark+2)  
3203 32 6a fe			ld (debug_mark+2),a  
3206 18 03			jr .pastdmark  
3208 ..			.dmark: db "+2a"  
320b f1			.pastdmark: pop af  
320c			endm  
# End of macro DMARK
320c						CALLMONITOR 
320c cd 6c fe			call debug_vector  
320f				endm  
# End of macro CALLMONITOR
320f					endif 
320f			 
320f					FORTH_DSP_POP 
320f cd b4 23			call macro_forth_dsp_pop 
3212				endm 
# End of macro FORTH_DSP_POP
3212			 
3212					; Get value to add 
3212			 
3212					FORTH_DSP_VALUE 
3212 cd e5 22			call macro_forth_dsp_value 
3215				endm 
# End of macro FORTH_DSP_VALUE
3215			 
3215					if DEBUG_FORTH_WORDS 
3215						DMARK "+2v" 
3215 f5				push af  
3216 3a 2a 32			ld a, (.dmark)  
3219 32 68 fe			ld (debug_mark),a  
321c 3a 2b 32			ld a, (.dmark+1)  
321f 32 69 fe			ld (debug_mark+1),a  
3222 3a 2c 32			ld a, (.dmark+2)  
3225 32 6a fe			ld (debug_mark+2),a  
3228 18 03			jr .pastdmark  
322a ..			.dmark: db "+2v"  
322d f1			.pastdmark: pop af  
322e			endm  
# End of macro DMARK
322e						CALLMONITOR 
322e cd 6c fe			call debug_vector  
3231				endm  
# End of macro CALLMONITOR
3231					endif 
3231			 
3231 19					add hl, de 
3232			 
3232					if DEBUG_FORTH_WORDS 
3232						DMARK "+2+" 
3232 f5				push af  
3233 3a 47 32			ld a, (.dmark)  
3236 32 68 fe			ld (debug_mark),a  
3239 3a 48 32			ld a, (.dmark+1)  
323c 32 69 fe			ld (debug_mark+1),a  
323f 3a 49 32			ld a, (.dmark+2)  
3242 32 6a fe			ld (debug_mark+2),a  
3245 18 03			jr .pastdmark  
3247 ..			.dmark: db "+2+"  
324a f1			.pastdmark: pop af  
324b			endm  
# End of macro DMARK
324b						CALLMONITOR 
324b cd 6c fe			call debug_vector  
324e				endm  
# End of macro CALLMONITOR
324e					endif 
324e			 
324e					; move result to de 
324e			 
324e eb					ex de, hl 
324f			 
324f					; Address 
324f			 
324f e1					pop hl 
3250			 
3250					; save it back 
3250			 
3250 73					ld (hl), e 
3251 23					inc hl 
3252 72					ld (hl), d 
3253			 
3253					if DEBUG_FORTH_WORDS 
3253						DMARK "+2e" 
3253 f5				push af  
3254 3a 68 32			ld a, (.dmark)  
3257 32 68 fe			ld (debug_mark),a  
325a 3a 69 32			ld a, (.dmark+1)  
325d 32 69 fe			ld (debug_mark+1),a  
3260 3a 6a 32			ld a, (.dmark+2)  
3263 32 6a fe			ld (debug_mark+2),a  
3266 18 03			jr .pastdmark  
3268 ..			.dmark: db "+2e"  
326b f1			.pastdmark: pop af  
326c			endm  
# End of macro DMARK
326c						CALLMONITOR 
326c cd 6c fe			call debug_vector  
326f				endm  
# End of macro CALLMONITOR
326f					endif 
326f			 
326f			 
326f			 
326f			 
326f			 
326f				       NEXTW 
326f c3 b2 24			jp macro_next 
3272				endm 
# End of macro NEXTW
3272			 
3272			.DEC2: 
3272				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
3272 6f				db WORD_SYS_CORE+91             
3273 1e 33			dw .GET2            
3275 04				db 3 + 1 
3276 .. 00			db "-2!",0              
327a				endm 
# End of macro CWHEAD
327a			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
327a			 
327a			 
327a					if DEBUG_FORTH_WORDS_KEY 
327a						DMARK "-2s" 
327a f5				push af  
327b 3a 8f 32			ld a, (.dmark)  
327e 32 68 fe			ld (debug_mark),a  
3281 3a 90 32			ld a, (.dmark+1)  
3284 32 69 fe			ld (debug_mark+1),a  
3287 3a 91 32			ld a, (.dmark+2)  
328a 32 6a fe			ld (debug_mark+2),a  
328d 18 03			jr .pastdmark  
328f ..			.dmark: db "-2s"  
3292 f1			.pastdmark: pop af  
3293			endm  
# End of macro DMARK
3293						CALLMONITOR 
3293 cd 6c fe			call debug_vector  
3296				endm  
# End of macro CALLMONITOR
3296					endif 
3296			 
3296					; Address 
3296			 
3296					FORTH_DSP_VALUEHL 
3296 cd fc 22			call macro_dsp_valuehl 
3299				endm 
# End of macro FORTH_DSP_VALUEHL
3299			 
3299 e5					push hl    ; save address 
329a			 
329a					; load content into de 
329a			 
329a 5e					ld e,(hl) 
329b 23					inc hl 
329c 56					ld d, (hl) 
329d			 
329d					if DEBUG_FORTH_WORDS 
329d						DMARK "-2a" 
329d f5				push af  
329e 3a b2 32			ld a, (.dmark)  
32a1 32 68 fe			ld (debug_mark),a  
32a4 3a b3 32			ld a, (.dmark+1)  
32a7 32 69 fe			ld (debug_mark+1),a  
32aa 3a b4 32			ld a, (.dmark+2)  
32ad 32 6a fe			ld (debug_mark+2),a  
32b0 18 03			jr .pastdmark  
32b2 ..			.dmark: db "-2a"  
32b5 f1			.pastdmark: pop af  
32b6			endm  
# End of macro DMARK
32b6						CALLMONITOR 
32b6 cd 6c fe			call debug_vector  
32b9				endm  
# End of macro CALLMONITOR
32b9					endif 
32b9			 
32b9					FORTH_DSP_POP 
32b9 cd b4 23			call macro_forth_dsp_pop 
32bc				endm 
# End of macro FORTH_DSP_POP
32bc			 
32bc					; Get value to remove 
32bc			 
32bc					FORTH_DSP_VALUE 
32bc cd e5 22			call macro_forth_dsp_value 
32bf				endm 
# End of macro FORTH_DSP_VALUE
32bf			 
32bf					if DEBUG_FORTH_WORDS 
32bf						DMARK "-2v" 
32bf f5				push af  
32c0 3a d4 32			ld a, (.dmark)  
32c3 32 68 fe			ld (debug_mark),a  
32c6 3a d5 32			ld a, (.dmark+1)  
32c9 32 69 fe			ld (debug_mark+1),a  
32cc 3a d6 32			ld a, (.dmark+2)  
32cf 32 6a fe			ld (debug_mark+2),a  
32d2 18 03			jr .pastdmark  
32d4 ..			.dmark: db "-2v"  
32d7 f1			.pastdmark: pop af  
32d8			endm  
# End of macro DMARK
32d8						CALLMONITOR 
32d8 cd 6c fe			call debug_vector  
32db				endm  
# End of macro CALLMONITOR
32db					endif 
32db			 
32db eb					ex de, hl 
32dc ed 52				sbc hl, de 
32de			 
32de					if DEBUG_FORTH_WORDS 
32de						DMARK "-2d" 
32de f5				push af  
32df 3a f3 32			ld a, (.dmark)  
32e2 32 68 fe			ld (debug_mark),a  
32e5 3a f4 32			ld a, (.dmark+1)  
32e8 32 69 fe			ld (debug_mark+1),a  
32eb 3a f5 32			ld a, (.dmark+2)  
32ee 32 6a fe			ld (debug_mark+2),a  
32f1 18 03			jr .pastdmark  
32f3 ..			.dmark: db "-2d"  
32f6 f1			.pastdmark: pop af  
32f7			endm  
# End of macro DMARK
32f7						CALLMONITOR 
32f7 cd 6c fe			call debug_vector  
32fa				endm  
# End of macro CALLMONITOR
32fa					endif 
32fa			 
32fa					; move result to de 
32fa			 
32fa eb					ex de, hl 
32fb			 
32fb					; Address 
32fb			 
32fb e1					pop hl 
32fc			 
32fc					; save it back 
32fc			 
32fc 73					ld (hl), e 
32fd 23					inc hl 
32fe 72					ld (hl), d 
32ff			 
32ff					if DEBUG_FORTH_WORDS 
32ff						DMARK "-2e" 
32ff f5				push af  
3300 3a 14 33			ld a, (.dmark)  
3303 32 68 fe			ld (debug_mark),a  
3306 3a 15 33			ld a, (.dmark+1)  
3309 32 69 fe			ld (debug_mark+1),a  
330c 3a 16 33			ld a, (.dmark+2)  
330f 32 6a fe			ld (debug_mark+2),a  
3312 18 03			jr .pastdmark  
3314 ..			.dmark: db "-2e"  
3317 f1			.pastdmark: pop af  
3318			endm  
# End of macro DMARK
3318						CALLMONITOR 
3318 cd 6c fe			call debug_vector  
331b				endm  
# End of macro CALLMONITOR
331b					endif 
331b			 
331b			 
331b			 
331b			 
331b			 
331b				       NEXTW 
331b c3 b2 24			jp macro_next 
331e				endm 
# End of macro NEXTW
331e			.GET2: 
331e				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
331e 6f				db WORD_SYS_CORE+91             
331f 4e 33			dw .BANG2            
3321 03				db 2 + 1 
3322 .. 00			db "2@",0              
3325				endm 
# End of macro CWHEAD
3325			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3325					if DEBUG_FORTH_WORDS_KEY 
3325						DMARK "2A_" 
3325 f5				push af  
3326 3a 3a 33			ld a, (.dmark)  
3329 32 68 fe			ld (debug_mark),a  
332c 3a 3b 33			ld a, (.dmark+1)  
332f 32 69 fe			ld (debug_mark+1),a  
3332 3a 3c 33			ld a, (.dmark+2)  
3335 32 6a fe			ld (debug_mark+2),a  
3338 18 03			jr .pastdmark  
333a ..			.dmark: db "2A_"  
333d f1			.pastdmark: pop af  
333e			endm  
# End of macro DMARK
333e						CALLMONITOR 
333e cd 6c fe			call debug_vector  
3341				endm  
# End of macro CALLMONITOR
3341					endif 
3341			 
3341					FORTH_DSP_VALUEHL 
3341 cd fc 22			call macro_dsp_valuehl 
3344				endm 
# End of macro FORTH_DSP_VALUEHL
3344			 
3344 5e					ld e, (hl) 
3345 23					inc hl 
3346 56					ld d, (hl) 
3347			 
3347 eb					ex de, hl 
3348			 
3348 cd 05 21				call forth_push_numhl 
334b			 
334b				       NEXTW 
334b c3 b2 24			jp macro_next 
334e				endm 
# End of macro NEXTW
334e			.BANG2: 
334e				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
334e 6f				db WORD_SYS_CORE+91             
334f 86 33			dw .CONFIG            
3351 03				db 2 + 1 
3352 .. 00			db "2!",0              
3355				endm 
# End of macro CWHEAD
3355			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3355					if DEBUG_FORTH_WORDS_KEY 
3355						DMARK "2S_" 
3355 f5				push af  
3356 3a 6a 33			ld a, (.dmark)  
3359 32 68 fe			ld (debug_mark),a  
335c 3a 6b 33			ld a, (.dmark+1)  
335f 32 69 fe			ld (debug_mark+1),a  
3362 3a 6c 33			ld a, (.dmark+2)  
3365 32 6a fe			ld (debug_mark+2),a  
3368 18 03			jr .pastdmark  
336a ..			.dmark: db "2S_"  
336d f1			.pastdmark: pop af  
336e			endm  
# End of macro DMARK
336e						CALLMONITOR 
336e cd 6c fe			call debug_vector  
3371				endm  
# End of macro CALLMONITOR
3371					endif 
3371			 
3371					FORTH_DSP_VALUEHL 
3371 cd fc 22			call macro_dsp_valuehl 
3374				endm 
# End of macro FORTH_DSP_VALUEHL
3374			 
3374 e5					push hl   ; save address 
3375			 
3375			 
3375					FORTH_DSP_POP 
3375 cd b4 23			call macro_forth_dsp_pop 
3378				endm 
# End of macro FORTH_DSP_POP
3378			 
3378					 
3378					FORTH_DSP_VALUEHL 
3378 cd fc 22			call macro_dsp_valuehl 
337b				endm 
# End of macro FORTH_DSP_VALUEHL
337b			 
337b					FORTH_DSP_POP 
337b cd b4 23			call macro_forth_dsp_pop 
337e				endm 
# End of macro FORTH_DSP_POP
337e			 
337e eb					ex de, hl    ; value now in de 
337f			 
337f e1					pop hl 
3380			 
3380 73					ld (hl), e 
3381			 
3381 23					inc hl 
3382			 
3382 72					ld (hl), d 
3383			 
3383			 
3383				       NEXTW 
3383 c3 b2 24			jp macro_next 
3386				endm 
# End of macro NEXTW
3386			.CONFIG: 
3386				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
3386 6f				db WORD_SYS_CORE+91             
3387 97 33			dw .ADTOS            
3389 07				db 6 + 1 
338a .. 00			db "CONFIG",0              
3391				endm 
# End of macro CWHEAD
3391			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3391			 
3391 cd 30 16				call config 
3394					NEXTW 
3394 c3 b2 24			jp macro_next 
3397				endm 
# End of macro NEXTW
3397			 
3397			.ADTOS: 
3397				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
3397 6f				db WORD_SYS_CORE+91             
3398 ad 33			dw .SBTOS            
339a 03				db 2 + 1 
339b .. 00			db "1+",0              
339e				endm 
# End of macro CWHEAD
339e			; | 1+ ( u -- u )  Increment value on TOS | DONE 
339e			 
339e					FORTH_DSP_VALUEHL 
339e cd fc 22			call macro_dsp_valuehl 
33a1				endm 
# End of macro FORTH_DSP_VALUEHL
33a1 e5					push hl 
33a2			 
33a2					FORTH_DSP_POP 
33a2 cd b4 23			call macro_forth_dsp_pop 
33a5				endm 
# End of macro FORTH_DSP_POP
33a5 e1					pop hl 
33a6			 
33a6 23					inc hl 
33a7 cd 05 21				call forth_push_numhl 
33aa					 
33aa					NEXTW 
33aa c3 b2 24			jp macro_next 
33ad				endm 
# End of macro NEXTW
33ad			.SBTOS: 
33ad				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
33ad 6f				db WORD_SYS_CORE+91             
33ae c3 33			dw .ADSTORE            
33b0 03				db 2 + 1 
33b1 .. 00			db "1-",0              
33b4				endm 
# End of macro CWHEAD
33b4			; | 1- ( u -- u )  Decrement value on TOS | DONE 
33b4			 
33b4					FORTH_DSP_VALUEHL 
33b4 cd fc 22			call macro_dsp_valuehl 
33b7				endm 
# End of macro FORTH_DSP_VALUEHL
33b7 e5					push hl 
33b8			 
33b8					FORTH_DSP_POP 
33b8 cd b4 23			call macro_forth_dsp_pop 
33bb				endm 
# End of macro FORTH_DSP_POP
33bb e1					pop hl 
33bc			 
33bc 2b					dec hl 
33bd cd 05 21				call forth_push_numhl 
33c0					 
33c0					NEXTW 
33c0 c3 b2 24			jp macro_next 
33c3				endm 
# End of macro NEXTW
33c3			.ADSTORE: 
33c3				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
33c3 6f				db WORD_SYS_CORE+91             
33c4 d9 33			dw .ADWSTORE            
33c6 04				db 3 + 1 
33c7 .. 00			db "1+!",0              
33cb				endm 
# End of macro CWHEAD
33cb			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
33cb			 
33cb					FORTH_DSP_VALUEHL 
33cb cd fc 22			call macro_dsp_valuehl 
33ce				endm 
# End of macro FORTH_DSP_VALUEHL
33ce e5					push hl 
33cf			 
33cf					FORTH_DSP_POP 
33cf cd b4 23			call macro_forth_dsp_pop 
33d2				endm 
# End of macro FORTH_DSP_POP
33d2 e1					pop hl 
33d3			 
33d3 7e					ld a, (hl) 
33d4 3c					inc a 
33d5 77					ld (hl), a 
33d6					 
33d6					NEXTW 
33d6 c3 b2 24			jp macro_next 
33d9				endm 
# End of macro NEXTW
33d9			.ADWSTORE: 
33d9				CWHEAD .ENDCORE 91 "1+2!" 4 WORD_FLAG_CODE 
33d9 6f				db WORD_SYS_CORE+91             
33da f7 33			dw .ENDCORE            
33dc 05				db 4 + 1 
33dd .. 00			db "1+2!",0              
33e2				endm 
# End of macro CWHEAD
33e2			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
33e2			 
33e2					FORTH_DSP_VALUEHL 
33e2 cd fc 22			call macro_dsp_valuehl 
33e5				endm 
# End of macro FORTH_DSP_VALUEHL
33e5 e5					push hl 
33e6			 
33e6					FORTH_DSP_POP 
33e6 cd b4 23			call macro_forth_dsp_pop 
33e9				endm 
# End of macro FORTH_DSP_POP
33e9 e1					pop hl 
33ea			 
33ea e5					push hl 
33eb			 
33eb cd 34 24				call loadwordinhl 
33ee 23					inc hl 
33ef			 
33ef d1					pop de 
33f0 eb					ex de, hl 
33f1 73					ld (hl), e 
33f2 23					inc hl 
33f3 72					ld (hl), d 
33f4					 
33f4					NEXTW 
33f4 c3 b2 24			jp macro_next 
33f7				endm 
# End of macro NEXTW
33f7			.ENDCORE: 
33f7			 
33f7			; eof 
33f7			 
33f7			 
# End of file forth_words_core.asm
33f7			include "forth_words_flow.asm" 
33f7			 
33f7			; | ## Program Flow Words 
33f7			 
33f7			.IF: 
33f7				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
33f7 1e				db WORD_SYS_CORE+10             
33f8 ec 34			dw .THEN            
33fa 03				db 2 + 1 
33fb .. 00			db "IF",0              
33fe				endm 
# End of macro CWHEAD
33fe			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
33fe			; 
33fe					if DEBUG_FORTH_WORDS_KEY 
33fe						DMARK "IF." 
33fe f5				push af  
33ff 3a 13 34			ld a, (.dmark)  
3402 32 68 fe			ld (debug_mark),a  
3405 3a 14 34			ld a, (.dmark+1)  
3408 32 69 fe			ld (debug_mark+1),a  
340b 3a 15 34			ld a, (.dmark+2)  
340e 32 6a fe			ld (debug_mark+2),a  
3411 18 03			jr .pastdmark  
3413 ..			.dmark: db "IF."  
3416 f1			.pastdmark: pop af  
3417			endm  
# End of macro DMARK
3417						CALLMONITOR 
3417 cd 6c fe			call debug_vector  
341a				endm  
# End of macro CALLMONITOR
341a					endif 
341a			; eval TOS 
341a			 
341a				FORTH_DSP_VALUEHL 
341a cd fc 22			call macro_dsp_valuehl 
341d				endm 
# End of macro FORTH_DSP_VALUEHL
341d			 
341d			;	push hl 
341d				FORTH_DSP_POP 
341d cd b4 23			call macro_forth_dsp_pop 
3420				endm 
# End of macro FORTH_DSP_POP
3420			;	pop hl 
3420			 
3420					if DEBUG_FORTH_WORDS 
3420						DMARK "IF1" 
3420 f5				push af  
3421 3a 35 34			ld a, (.dmark)  
3424 32 68 fe			ld (debug_mark),a  
3427 3a 36 34			ld a, (.dmark+1)  
342a 32 69 fe			ld (debug_mark+1),a  
342d 3a 37 34			ld a, (.dmark+2)  
3430 32 6a fe			ld (debug_mark+2),a  
3433 18 03			jr .pastdmark  
3435 ..			.dmark: db "IF1"  
3438 f1			.pastdmark: pop af  
3439			endm  
# End of macro DMARK
3439						CALLMONITOR 
3439 cd 6c fe			call debug_vector  
343c				endm  
# End of macro CALLMONITOR
343c					endif 
343c b7				or a        ; clear carry flag 
343d 11 00 00			ld de, 0 
3440 eb				ex de,hl 
3441 ed 52			sbc hl, de 
3443 c2 cd 34			jp nz, .iftrue 
3446			 
3446					if DEBUG_FORTH_WORDS 
3446						DMARK "IF2" 
3446 f5				push af  
3447 3a 5b 34			ld a, (.dmark)  
344a 32 68 fe			ld (debug_mark),a  
344d 3a 5c 34			ld a, (.dmark+1)  
3450 32 69 fe			ld (debug_mark+1),a  
3453 3a 5d 34			ld a, (.dmark+2)  
3456 32 6a fe			ld (debug_mark+2),a  
3459 18 03			jr .pastdmark  
345b ..			.dmark: db "IF2"  
345e f1			.pastdmark: pop af  
345f			endm  
# End of macro DMARK
345f						CALLMONITOR 
345f cd 6c fe			call debug_vector  
3462				endm  
# End of macro CALLMONITOR
3462					endif 
3462			 
3462			; if not true then skip to THEN 
3462			 
3462				; TODO get tok_ptr 
3462				; TODO consume toks until we get to THEN 
3462			 
3462 2a bf f4			ld hl, (os_tok_ptr) 
3465					if DEBUG_FORTH_WORDS 
3465						DMARK "IF3" 
3465 f5				push af  
3466 3a 7a 34			ld a, (.dmark)  
3469 32 68 fe			ld (debug_mark),a  
346c 3a 7b 34			ld a, (.dmark+1)  
346f 32 69 fe			ld (debug_mark+1),a  
3472 3a 7c 34			ld a, (.dmark+2)  
3475 32 6a fe			ld (debug_mark+2),a  
3478 18 03			jr .pastdmark  
347a ..			.dmark: db "IF3"  
347d f1			.pastdmark: pop af  
347e			endm  
# End of macro DMARK
347e						CALLMONITOR 
347e cd 6c fe			call debug_vector  
3481				endm  
# End of macro CALLMONITOR
3481						 
3481					endif 
3481 11 c8 34			ld de, .ifthen 
3484					if DEBUG_FORTH_WORDS 
3484						DMARK "IF4" 
3484 f5				push af  
3485 3a 99 34			ld a, (.dmark)  
3488 32 68 fe			ld (debug_mark),a  
348b 3a 9a 34			ld a, (.dmark+1)  
348e 32 69 fe			ld (debug_mark+1),a  
3491 3a 9b 34			ld a, (.dmark+2)  
3494 32 6a fe			ld (debug_mark+2),a  
3497 18 03			jr .pastdmark  
3499 ..			.dmark: db "IF4"  
349c f1			.pastdmark: pop af  
349d			endm  
# End of macro DMARK
349d						CALLMONITOR 
349d cd 6c fe			call debug_vector  
34a0				endm  
# End of macro CALLMONITOR
34a0					endif 
34a0 cd cd 25			call findnexttok  
34a3			 
34a3					if DEBUG_FORTH_WORDS 
34a3						DMARK "IF5" 
34a3 f5				push af  
34a4 3a b8 34			ld a, (.dmark)  
34a7 32 68 fe			ld (debug_mark),a  
34aa 3a b9 34			ld a, (.dmark+1)  
34ad 32 69 fe			ld (debug_mark+1),a  
34b0 3a ba 34			ld a, (.dmark+2)  
34b3 32 6a fe			ld (debug_mark+2),a  
34b6 18 03			jr .pastdmark  
34b8 ..			.dmark: db "IF5"  
34bb f1			.pastdmark: pop af  
34bc			endm  
# End of macro DMARK
34bc						CALLMONITOR 
34bc cd 6c fe			call debug_vector  
34bf				endm  
# End of macro CALLMONITOR
34bf					endif 
34bf				; TODO replace below with ; exec using tok_ptr 
34bf 22 bf f4			ld (os_tok_ptr), hl 
34c2 c3 43 25			jp exec1 
34c5				NEXTW 
34c5 c3 b2 24			jp macro_next 
34c8				endm 
# End of macro NEXTW
34c8			 
34c8 .. 00		.ifthen:  db "THEN",0 
34cd			 
34cd			.iftrue:		 
34cd				; Exec next words normally 
34cd			 
34cd				; if true then exec following IF as normal 
34cd					if DEBUG_FORTH_WORDS 
34cd						DMARK "IFT" 
34cd f5				push af  
34ce 3a e2 34			ld a, (.dmark)  
34d1 32 68 fe			ld (debug_mark),a  
34d4 3a e3 34			ld a, (.dmark+1)  
34d7 32 69 fe			ld (debug_mark+1),a  
34da 3a e4 34			ld a, (.dmark+2)  
34dd 32 6a fe			ld (debug_mark+2),a  
34e0 18 03			jr .pastdmark  
34e2 ..			.dmark: db "IFT"  
34e5 f1			.pastdmark: pop af  
34e6			endm  
# End of macro DMARK
34e6						CALLMONITOR 
34e6 cd 6c fe			call debug_vector  
34e9				endm  
# End of macro CALLMONITOR
34e9					endif 
34e9			 
34e9					NEXTW 
34e9 c3 b2 24			jp macro_next 
34ec				endm 
# End of macro NEXTW
34ec			.THEN: 
34ec				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
34ec 1f				db WORD_SYS_CORE+11             
34ed 14 35			dw .ELSE            
34ef 05				db 4 + 1 
34f0 .. 00			db "THEN",0              
34f5				endm 
# End of macro CWHEAD
34f5			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
34f5					if DEBUG_FORTH_WORDS_KEY 
34f5						DMARK "THN" 
34f5 f5				push af  
34f6 3a 0a 35			ld a, (.dmark)  
34f9 32 68 fe			ld (debug_mark),a  
34fc 3a 0b 35			ld a, (.dmark+1)  
34ff 32 69 fe			ld (debug_mark+1),a  
3502 3a 0c 35			ld a, (.dmark+2)  
3505 32 6a fe			ld (debug_mark+2),a  
3508 18 03			jr .pastdmark  
350a ..			.dmark: db "THN"  
350d f1			.pastdmark: pop af  
350e			endm  
# End of macro DMARK
350e						CALLMONITOR 
350e cd 6c fe			call debug_vector  
3511				endm  
# End of macro CALLMONITOR
3511					endif 
3511					NEXTW 
3511 c3 b2 24			jp macro_next 
3514				endm 
# End of macro NEXTW
3514			.ELSE: 
3514				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3514 20				db WORD_SYS_CORE+12             
3515 3c 35			dw .DO            
3517 03				db 2 + 1 
3518 .. 00			db "ELSE",0              
351d				endm 
# End of macro CWHEAD
351d			; | ELSE ( -- ) Not supported - does nothing | TODO 
351d			 
351d					if DEBUG_FORTH_WORDS_KEY 
351d						DMARK "ELS" 
351d f5				push af  
351e 3a 32 35			ld a, (.dmark)  
3521 32 68 fe			ld (debug_mark),a  
3524 3a 33 35			ld a, (.dmark+1)  
3527 32 69 fe			ld (debug_mark+1),a  
352a 3a 34 35			ld a, (.dmark+2)  
352d 32 6a fe			ld (debug_mark+2),a  
3530 18 03			jr .pastdmark  
3532 ..			.dmark: db "ELS"  
3535 f1			.pastdmark: pop af  
3536			endm  
# End of macro DMARK
3536						CALLMONITOR 
3536 cd 6c fe			call debug_vector  
3539				endm  
# End of macro CALLMONITOR
3539					endif 
3539			 
3539			 
3539					NEXTW 
3539 c3 b2 24			jp macro_next 
353c				endm 
# End of macro NEXTW
353c			.DO: 
353c				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
353c 21				db WORD_SYS_CORE+13             
353d 63 36			dw .LOOP            
353f 03				db 2 + 1 
3540 .. 00			db "DO",0              
3543				endm 
# End of macro CWHEAD
3543			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3543			 
3543					if DEBUG_FORTH_WORDS_KEY 
3543						DMARK "DO." 
3543 f5				push af  
3544 3a 58 35			ld a, (.dmark)  
3547 32 68 fe			ld (debug_mark),a  
354a 3a 59 35			ld a, (.dmark+1)  
354d 32 69 fe			ld (debug_mark+1),a  
3550 3a 5a 35			ld a, (.dmark+2)  
3553 32 6a fe			ld (debug_mark+2),a  
3556 18 03			jr .pastdmark  
3558 ..			.dmark: db "DO."  
355b f1			.pastdmark: pop af  
355c			endm  
# End of macro DMARK
355c						CALLMONITOR 
355c cd 6c fe			call debug_vector  
355f				endm  
# End of macro CALLMONITOR
355f					endif 
355f			;  push pc to rsp stack past the DO 
355f			 
355f 2a bf f4				ld hl, (os_tok_ptr) 
3562 23					inc hl   ; D 
3563 23					inc hl  ; O 
3564 23					inc hl   ; null 
3565					if DEBUG_FORTH_WORDS 
3565						DMARK "DO2" 
3565 f5				push af  
3566 3a 7a 35			ld a, (.dmark)  
3569 32 68 fe			ld (debug_mark),a  
356c 3a 7b 35			ld a, (.dmark+1)  
356f 32 69 fe			ld (debug_mark+1),a  
3572 3a 7c 35			ld a, (.dmark+2)  
3575 32 6a fe			ld (debug_mark+2),a  
3578 18 03			jr .pastdmark  
357a ..			.dmark: db "DO2"  
357d f1			.pastdmark: pop af  
357e			endm  
# End of macro DMARK
357e						CALLMONITOR 
357e cd 6c fe			call debug_vector  
3581				endm  
# End of macro CALLMONITOR
3581					endif 
3581					FORTH_RSP_NEXT 
3581 cd ac 20			call macro_forth_rsp_next 
3584				endm 
# End of macro FORTH_RSP_NEXT
3584					if DEBUG_FORTH_WORDS 
3584						DMARK "DO3" 
3584 f5				push af  
3585 3a 99 35			ld a, (.dmark)  
3588 32 68 fe			ld (debug_mark),a  
358b 3a 9a 35			ld a, (.dmark+1)  
358e 32 69 fe			ld (debug_mark+1),a  
3591 3a 9b 35			ld a, (.dmark+2)  
3594 32 6a fe			ld (debug_mark+2),a  
3597 18 03			jr .pastdmark  
3599 ..			.dmark: db "DO3"  
359c f1			.pastdmark: pop af  
359d			endm  
# End of macro DMARK
359d						CALLMONITOR 
359d cd 6c fe			call debug_vector  
35a0				endm  
# End of macro CALLMONITOR
35a0					endif 
35a0			 
35a0					;if DEBUG_FORTH_WORDS 
35a0				;		push hl 
35a0			;		endif  
35a0			 
35a0			; get counters from data stack 
35a0			 
35a0			 
35a0					FORTH_DSP_VALUEHL 
35a0 cd fc 22			call macro_dsp_valuehl 
35a3				endm 
# End of macro FORTH_DSP_VALUEHL
35a3 e5					push hl		 ; hl now has starting counter which needs to be tos 
35a4			 
35a4					if DEBUG_FORTH_WORDS 
35a4						DMARK "DO4" 
35a4 f5				push af  
35a5 3a b9 35			ld a, (.dmark)  
35a8 32 68 fe			ld (debug_mark),a  
35ab 3a ba 35			ld a, (.dmark+1)  
35ae 32 69 fe			ld (debug_mark+1),a  
35b1 3a bb 35			ld a, (.dmark+2)  
35b4 32 6a fe			ld (debug_mark+2),a  
35b7 18 03			jr .pastdmark  
35b9 ..			.dmark: db "DO4"  
35bc f1			.pastdmark: pop af  
35bd			endm  
# End of macro DMARK
35bd						CALLMONITOR 
35bd cd 6c fe			call debug_vector  
35c0				endm  
# End of macro CALLMONITOR
35c0					endif 
35c0					FORTH_DSP_POP 
35c0 cd b4 23			call macro_forth_dsp_pop 
35c3				endm 
# End of macro FORTH_DSP_POP
35c3			 
35c3					if DEBUG_FORTH_WORDS 
35c3						DMARK "DO5" 
35c3 f5				push af  
35c4 3a d8 35			ld a, (.dmark)  
35c7 32 68 fe			ld (debug_mark),a  
35ca 3a d9 35			ld a, (.dmark+1)  
35cd 32 69 fe			ld (debug_mark+1),a  
35d0 3a da 35			ld a, (.dmark+2)  
35d3 32 6a fe			ld (debug_mark+2),a  
35d6 18 03			jr .pastdmark  
35d8 ..			.dmark: db "DO5"  
35db f1			.pastdmark: pop af  
35dc			endm  
# End of macro DMARK
35dc						CALLMONITOR 
35dc cd 6c fe			call debug_vector  
35df				endm  
# End of macro CALLMONITOR
35df					endif 
35df			 
35df					FORTH_DSP_VALUEHL 
35df cd fc 22			call macro_dsp_valuehl 
35e2				endm 
# End of macro FORTH_DSP_VALUEHL
35e2			;		push hl		 ; hl now has starting limit counter 
35e2			 
35e2					if DEBUG_FORTH_WORDS 
35e2						DMARK "DO6" 
35e2 f5				push af  
35e3 3a f7 35			ld a, (.dmark)  
35e6 32 68 fe			ld (debug_mark),a  
35e9 3a f8 35			ld a, (.dmark+1)  
35ec 32 69 fe			ld (debug_mark+1),a  
35ef 3a f9 35			ld a, (.dmark+2)  
35f2 32 6a fe			ld (debug_mark+2),a  
35f5 18 03			jr .pastdmark  
35f7 ..			.dmark: db "DO6"  
35fa f1			.pastdmark: pop af  
35fb			endm  
# End of macro DMARK
35fb						CALLMONITOR 
35fb cd 6c fe			call debug_vector  
35fe				endm  
# End of macro CALLMONITOR
35fe					endif 
35fe					FORTH_DSP_POP 
35fe cd b4 23			call macro_forth_dsp_pop 
3601				endm 
# End of macro FORTH_DSP_POP
3601			 
3601			; put counters on the loop stack 
3601			 
3601			;		pop hl			 ; limit counter 
3601 d1					pop de			; start counter 
3602			 
3602					; push limit counter 
3602			 
3602					if DEBUG_FORTH_WORDS 
3602						DMARK "DO7" 
3602 f5				push af  
3603 3a 17 36			ld a, (.dmark)  
3606 32 68 fe			ld (debug_mark),a  
3609 3a 18 36			ld a, (.dmark+1)  
360c 32 69 fe			ld (debug_mark+1),a  
360f 3a 19 36			ld a, (.dmark+2)  
3612 32 6a fe			ld (debug_mark+2),a  
3615 18 03			jr .pastdmark  
3617 ..			.dmark: db "DO7"  
361a f1			.pastdmark: pop af  
361b			endm  
# End of macro DMARK
361b						CALLMONITOR 
361b cd 6c fe			call debug_vector  
361e				endm  
# End of macro CALLMONITOR
361e					endif 
361e					FORTH_LOOP_NEXT 
361e cd 2d 23			call macro_forth_loop_next 
3621				endm 
# End of macro FORTH_LOOP_NEXT
3621			 
3621					; push start counter 
3621			 
3621 eb					ex de, hl 
3622					if DEBUG_FORTH_WORDS 
3622						DMARK "DO7" 
3622 f5				push af  
3623 3a 37 36			ld a, (.dmark)  
3626 32 68 fe			ld (debug_mark),a  
3629 3a 38 36			ld a, (.dmark+1)  
362c 32 69 fe			ld (debug_mark+1),a  
362f 3a 39 36			ld a, (.dmark+2)  
3632 32 6a fe			ld (debug_mark+2),a  
3635 18 03			jr .pastdmark  
3637 ..			.dmark: db "DO7"  
363a f1			.pastdmark: pop af  
363b			endm  
# End of macro DMARK
363b						CALLMONITOR 
363b cd 6c fe			call debug_vector  
363e				endm  
# End of macro CALLMONITOR
363e					endif 
363e					FORTH_LOOP_NEXT 
363e cd 2d 23			call macro_forth_loop_next 
3641				endm 
# End of macro FORTH_LOOP_NEXT
3641			 
3641			 
3641					; init first round of I counter 
3641			 
3641 22 e3 f4				ld (os_current_i), hl 
3644			 
3644					if DEBUG_FORTH_WORDS 
3644						DMARK "DO8" 
3644 f5				push af  
3645 3a 59 36			ld a, (.dmark)  
3648 32 68 fe			ld (debug_mark),a  
364b 3a 5a 36			ld a, (.dmark+1)  
364e 32 69 fe			ld (debug_mark+1),a  
3651 3a 5b 36			ld a, (.dmark+2)  
3654 32 6a fe			ld (debug_mark+2),a  
3657 18 03			jr .pastdmark  
3659 ..			.dmark: db "DO8"  
365c f1			.pastdmark: pop af  
365d			endm  
# End of macro DMARK
365d						CALLMONITOR 
365d cd 6c fe			call debug_vector  
3660				endm  
# End of macro CALLMONITOR
3660					endif 
3660			 
3660					NEXTW 
3660 c3 b2 24			jp macro_next 
3663				endm 
# End of macro NEXTW
3663			.LOOP: 
3663				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3663 22				db WORD_SYS_CORE+14             
3664 7b 37			dw .I            
3666 05				db 4 + 1 
3667 .. 00			db "LOOP",0              
366c				endm 
# End of macro CWHEAD
366c			; | LOOP ( -- ) Increment and test loop counter  | DONE 
366c			 
366c				; pop tos as current loop count to hl 
366c			 
366c				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
366c			 
366c				FORTH_LOOP_TOS 
366c cd 60 23			call macro_forth_loop_tos 
366f				endm 
# End of macro FORTH_LOOP_TOS
366f e5				push hl 
3670			 
3670					if DEBUG_FORTH_WORDS_KEY 
3670						DMARK "LOP" 
3670 f5				push af  
3671 3a 85 36			ld a, (.dmark)  
3674 32 68 fe			ld (debug_mark),a  
3677 3a 86 36			ld a, (.dmark+1)  
367a 32 69 fe			ld (debug_mark+1),a  
367d 3a 87 36			ld a, (.dmark+2)  
3680 32 6a fe			ld (debug_mark+2),a  
3683 18 03			jr .pastdmark  
3685 ..			.dmark: db "LOP"  
3688 f1			.pastdmark: pop af  
3689			endm  
# End of macro DMARK
3689						CALLMONITOR 
3689 cd 6c fe			call debug_vector  
368c				endm  
# End of macro CALLMONITOR
368c					endif 
368c				; next item on the stack is the limit. get it 
368c			 
368c			 
368c				FORTH_LOOP_POP 
368c cd 6a 23			call macro_forth_loop_pop 
368f				endm 
# End of macro FORTH_LOOP_POP
368f			 
368f				FORTH_LOOP_TOS 
368f cd 60 23			call macro_forth_loop_tos 
3692				endm 
# End of macro FORTH_LOOP_TOS
3692			 
3692 d1				pop de		 ; de = i, hl = limit 
3693			 
3693					if DEBUG_FORTH_WORDS 
3693						DMARK "LP1" 
3693 f5				push af  
3694 3a a8 36			ld a, (.dmark)  
3697 32 68 fe			ld (debug_mark),a  
369a 3a a9 36			ld a, (.dmark+1)  
369d 32 69 fe			ld (debug_mark+1),a  
36a0 3a aa 36			ld a, (.dmark+2)  
36a3 32 6a fe			ld (debug_mark+2),a  
36a6 18 03			jr .pastdmark  
36a8 ..			.dmark: db "LP1"  
36ab f1			.pastdmark: pop af  
36ac			endm  
# End of macro DMARK
36ac						CALLMONITOR 
36ac cd 6c fe			call debug_vector  
36af				endm  
# End of macro CALLMONITOR
36af					endif 
36af			 
36af				; go back to previous word 
36af			 
36af d5				push de    ; save I for inc later 
36b0			 
36b0			 
36b0				; get limit 
36b0				;  is I at limit? 
36b0			 
36b0			 
36b0					if DEBUG_FORTH_WORDS 
36b0						DMARK "LP1" 
36b0 f5				push af  
36b1 3a c5 36			ld a, (.dmark)  
36b4 32 68 fe			ld (debug_mark),a  
36b7 3a c6 36			ld a, (.dmark+1)  
36ba 32 69 fe			ld (debug_mark+1),a  
36bd 3a c7 36			ld a, (.dmark+2)  
36c0 32 6a fe			ld (debug_mark+2),a  
36c3 18 03			jr .pastdmark  
36c5 ..			.dmark: db "LP1"  
36c8 f1			.pastdmark: pop af  
36c9			endm  
# End of macro DMARK
36c9						CALLMONITOR 
36c9 cd 6c fe			call debug_vector  
36cc				endm  
# End of macro CALLMONITOR
36cc					endif 
36cc			 
36cc ed 52			sbc hl, de 
36ce			 
36ce			 
36ce				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
36ce			 
36ce 20 26				jr nz, .loopnotdone 
36d0			 
36d0 e1				pop hl   ; get rid of saved I 
36d1				FORTH_LOOP_POP     ; get rid of limit 
36d1 cd 6a 23			call macro_forth_loop_pop 
36d4				endm 
# End of macro FORTH_LOOP_POP
36d4			 
36d4				FORTH_RSP_POP     ; get rid of DO ptr 
36d4 cd cd 20			call macro_forth_rsp_pop 
36d7				endm 
# End of macro FORTH_RSP_POP
36d7			 
36d7			if DEBUG_FORTH_WORDS 
36d7						DMARK "LP>" 
36d7 f5				push af  
36d8 3a ec 36			ld a, (.dmark)  
36db 32 68 fe			ld (debug_mark),a  
36de 3a ed 36			ld a, (.dmark+1)  
36e1 32 69 fe			ld (debug_mark+1),a  
36e4 3a ee 36			ld a, (.dmark+2)  
36e7 32 6a fe			ld (debug_mark+2),a  
36ea 18 03			jr .pastdmark  
36ec ..			.dmark: db "LP>"  
36ef f1			.pastdmark: pop af  
36f0			endm  
# End of macro DMARK
36f0				CALLMONITOR 
36f0 cd 6c fe			call debug_vector  
36f3				endm  
# End of macro CALLMONITOR
36f3			endif 
36f3			 
36f3					NEXTW 
36f3 c3 b2 24			jp macro_next 
36f6				endm 
# End of macro NEXTW
36f6				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
36f6			 
36f6			.loopnotdone: 
36f6			 
36f6 e1				pop hl    ; get I 
36f7 23				inc hl 
36f8			 
36f8			   	; save new I 
36f8			 
36f8			 
36f8					; set I counter 
36f8			 
36f8 22 e3 f4				ld (os_current_i), hl 
36fb			 
36fb					if DEBUG_FORTH_WORDS 
36fb						DMARK "LPN" 
36fb f5				push af  
36fc 3a 10 37			ld a, (.dmark)  
36ff 32 68 fe			ld (debug_mark),a  
3702 3a 11 37			ld a, (.dmark+1)  
3705 32 69 fe			ld (debug_mark+1),a  
3708 3a 12 37			ld a, (.dmark+2)  
370b 32 6a fe			ld (debug_mark+2),a  
370e 18 03			jr .pastdmark  
3710 ..			.dmark: db "LPN"  
3713 f1			.pastdmark: pop af  
3714			endm  
# End of macro DMARK
3714					CALLMONITOR 
3714 cd 6c fe			call debug_vector  
3717				endm  
# End of macro CALLMONITOR
3717					endif 
3717					 
3717				FORTH_LOOP_NEXT 
3717 cd 2d 23			call macro_forth_loop_next 
371a				endm 
# End of macro FORTH_LOOP_NEXT
371a			 
371a			 
371a					if DEBUG_FORTH_WORDS 
371a eb						ex de,hl 
371b					endif 
371b			 
371b			;	; get DO ptr 
371b			; 
371b					if DEBUG_FORTH_WORDS 
371b						DMARK "LP7" 
371b f5				push af  
371c 3a 30 37			ld a, (.dmark)  
371f 32 68 fe			ld (debug_mark),a  
3722 3a 31 37			ld a, (.dmark+1)  
3725 32 69 fe			ld (debug_mark+1),a  
3728 3a 32 37			ld a, (.dmark+2)  
372b 32 6a fe			ld (debug_mark+2),a  
372e 18 03			jr .pastdmark  
3730 ..			.dmark: db "LP7"  
3733 f1			.pastdmark: pop af  
3734			endm  
# End of macro DMARK
3734					CALLMONITOR 
3734 cd 6c fe			call debug_vector  
3737				endm  
# End of macro CALLMONITOR
3737					endif 
3737				FORTH_RSP_TOS 
3737 cd c3 20			call macro_forth_rsp_tos 
373a				endm 
# End of macro FORTH_RSP_TOS
373a			 
373a					if DEBUG_FORTH_WORDS 
373a						DMARK "LP8" 
373a f5				push af  
373b 3a 4f 37			ld a, (.dmark)  
373e 32 68 fe			ld (debug_mark),a  
3741 3a 50 37			ld a, (.dmark+1)  
3744 32 69 fe			ld (debug_mark+1),a  
3747 3a 51 37			ld a, (.dmark+2)  
374a 32 6a fe			ld (debug_mark+2),a  
374d 18 03			jr .pastdmark  
374f ..			.dmark: db "LP8"  
3752 f1			.pastdmark: pop af  
3753			endm  
# End of macro DMARK
3753					CALLMONITOR 
3753 cd 6c fe			call debug_vector  
3756				endm  
# End of macro CALLMONITOR
3756					endif 
3756				;push hl 
3756			 
3756				; not going to DO any more 
3756				; get rid of the RSP pointer as DO will add it back in 
3756				;FORTH_RSP_POP 
3756				;pop hl 
3756			 
3756				;ld hl,(cli_ret_sp) 
3756				;ld e, (hl) 
3756				;inc hl 
3756				;ld d, (hl) 
3756				;ex de,hl 
3756 22 bf f4			ld (os_tok_ptr), hl 
3759					if DEBUG_FORTH_WORDS 
3759						DMARK "LP<" 
3759 f5				push af  
375a 3a 6e 37			ld a, (.dmark)  
375d 32 68 fe			ld (debug_mark),a  
3760 3a 6f 37			ld a, (.dmark+1)  
3763 32 69 fe			ld (debug_mark+1),a  
3766 3a 70 37			ld a, (.dmark+2)  
3769 32 6a fe			ld (debug_mark+2),a  
376c 18 03			jr .pastdmark  
376e ..			.dmark: db "LP<"  
3771 f1			.pastdmark: pop af  
3772			endm  
# End of macro DMARK
3772					CALLMONITOR 
3772 cd 6c fe			call debug_vector  
3775				endm  
# End of macro CALLMONITOR
3775				endif 
3775 c3 43 25			jp exec1 
3778			 
3778					 
3778			 
3778			 
3778					NEXTW 
3778 c3 b2 24			jp macro_next 
377b				endm 
# End of macro NEXTW
377b			.I:  
377b			 
377b				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
377b 5e				db WORD_SYS_CORE+74             
377c a6 37			dw .DLOOP            
377e 02				db 1 + 1 
377f .. 00			db "I",0              
3781				endm 
# End of macro CWHEAD
3781			; | I ( -- ) Current loop counter | DONE 
3781					if DEBUG_FORTH_WORDS_KEY 
3781						DMARK "I.." 
3781 f5				push af  
3782 3a 96 37			ld a, (.dmark)  
3785 32 68 fe			ld (debug_mark),a  
3788 3a 97 37			ld a, (.dmark+1)  
378b 32 69 fe			ld (debug_mark+1),a  
378e 3a 98 37			ld a, (.dmark+2)  
3791 32 6a fe			ld (debug_mark+2),a  
3794 18 03			jr .pastdmark  
3796 ..			.dmark: db "I.."  
3799 f1			.pastdmark: pop af  
379a			endm  
# End of macro DMARK
379a						CALLMONITOR 
379a cd 6c fe			call debug_vector  
379d				endm  
# End of macro CALLMONITOR
379d					endif 
379d			 
379d 2a e3 f4				ld hl,(os_current_i) 
37a0 cd 05 21				call forth_push_numhl 
37a3			 
37a3					NEXTW 
37a3 c3 b2 24			jp macro_next 
37a6				endm 
# End of macro NEXTW
37a6			.DLOOP: 
37a6				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
37a6 5f				db WORD_SYS_CORE+75             
37a7 87 38			dw .REPEAT            
37a9 06				db 5 + 1 
37aa .. 00			db "-LOOP",0              
37b0				endm 
# End of macro CWHEAD
37b0			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
37b0				; pop tos as current loop count to hl 
37b0					if DEBUG_FORTH_WORDS_KEY 
37b0						DMARK "-LP" 
37b0 f5				push af  
37b1 3a c5 37			ld a, (.dmark)  
37b4 32 68 fe			ld (debug_mark),a  
37b7 3a c6 37			ld a, (.dmark+1)  
37ba 32 69 fe			ld (debug_mark+1),a  
37bd 3a c7 37			ld a, (.dmark+2)  
37c0 32 6a fe			ld (debug_mark+2),a  
37c3 18 03			jr .pastdmark  
37c5 ..			.dmark: db "-LP"  
37c8 f1			.pastdmark: pop af  
37c9			endm  
# End of macro DMARK
37c9						CALLMONITOR 
37c9 cd 6c fe			call debug_vector  
37cc				endm  
# End of macro CALLMONITOR
37cc					endif 
37cc			 
37cc				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
37cc			 
37cc				FORTH_LOOP_TOS 
37cc cd 60 23			call macro_forth_loop_tos 
37cf				endm 
# End of macro FORTH_LOOP_TOS
37cf e5				push hl 
37d0			 
37d0					if DEBUG_FORTH_WORDS 
37d0						DMARK "-LP" 
37d0 f5				push af  
37d1 3a e5 37			ld a, (.dmark)  
37d4 32 68 fe			ld (debug_mark),a  
37d7 3a e6 37			ld a, (.dmark+1)  
37da 32 69 fe			ld (debug_mark+1),a  
37dd 3a e7 37			ld a, (.dmark+2)  
37e0 32 6a fe			ld (debug_mark+2),a  
37e3 18 03			jr .pastdmark  
37e5 ..			.dmark: db "-LP"  
37e8 f1			.pastdmark: pop af  
37e9			endm  
# End of macro DMARK
37e9						CALLMONITOR 
37e9 cd 6c fe			call debug_vector  
37ec				endm  
# End of macro CALLMONITOR
37ec					endif 
37ec				; next item on the stack is the limit. get it 
37ec			 
37ec			 
37ec				FORTH_LOOP_POP 
37ec cd 6a 23			call macro_forth_loop_pop 
37ef				endm 
# End of macro FORTH_LOOP_POP
37ef			 
37ef				FORTH_LOOP_TOS 
37ef cd 60 23			call macro_forth_loop_tos 
37f2				endm 
# End of macro FORTH_LOOP_TOS
37f2			 
37f2 d1				pop de		 ; de = i, hl = limit 
37f3			 
37f3					if DEBUG_FORTH_WORDS 
37f3						DMARK "-L1" 
37f3 f5				push af  
37f4 3a 08 38			ld a, (.dmark)  
37f7 32 68 fe			ld (debug_mark),a  
37fa 3a 09 38			ld a, (.dmark+1)  
37fd 32 69 fe			ld (debug_mark+1),a  
3800 3a 0a 38			ld a, (.dmark+2)  
3803 32 6a fe			ld (debug_mark+2),a  
3806 18 03			jr .pastdmark  
3808 ..			.dmark: db "-L1"  
380b f1			.pastdmark: pop af  
380c			endm  
# End of macro DMARK
380c						CALLMONITOR 
380c cd 6c fe			call debug_vector  
380f				endm  
# End of macro CALLMONITOR
380f					endif 
380f			 
380f				; go back to previous word 
380f			 
380f d5				push de    ; save I for inc later 
3810			 
3810			 
3810				; get limit 
3810				;  is I at limit? 
3810			 
3810			 
3810					if DEBUG_FORTH_WORDS 
3810						DMARK "-L1" 
3810 f5				push af  
3811 3a 25 38			ld a, (.dmark)  
3814 32 68 fe			ld (debug_mark),a  
3817 3a 26 38			ld a, (.dmark+1)  
381a 32 69 fe			ld (debug_mark+1),a  
381d 3a 27 38			ld a, (.dmark+2)  
3820 32 6a fe			ld (debug_mark+2),a  
3823 18 03			jr .pastdmark  
3825 ..			.dmark: db "-L1"  
3828 f1			.pastdmark: pop af  
3829			endm  
# End of macro DMARK
3829						CALLMONITOR 
3829 cd 6c fe			call debug_vector  
382c				endm  
# End of macro CALLMONITOR
382c					endif 
382c			 
382c ed 52			sbc hl, de 
382e			 
382e			 
382e				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
382e			 
382e 20 26				jr nz, .mloopnotdone 
3830			 
3830 e1				pop hl   ; get rid of saved I 
3831				FORTH_LOOP_POP     ; get rid of limit 
3831 cd 6a 23			call macro_forth_loop_pop 
3834				endm 
# End of macro FORTH_LOOP_POP
3834			 
3834				FORTH_RSP_POP     ; get rid of DO ptr 
3834 cd cd 20			call macro_forth_rsp_pop 
3837				endm 
# End of macro FORTH_RSP_POP
3837			 
3837			if DEBUG_FORTH_WORDS 
3837						DMARK "-L>" 
3837 f5				push af  
3838 3a 4c 38			ld a, (.dmark)  
383b 32 68 fe			ld (debug_mark),a  
383e 3a 4d 38			ld a, (.dmark+1)  
3841 32 69 fe			ld (debug_mark+1),a  
3844 3a 4e 38			ld a, (.dmark+2)  
3847 32 6a fe			ld (debug_mark+2),a  
384a 18 03			jr .pastdmark  
384c ..			.dmark: db "-L>"  
384f f1			.pastdmark: pop af  
3850			endm  
# End of macro DMARK
3850				CALLMONITOR 
3850 cd 6c fe			call debug_vector  
3853				endm  
# End of macro CALLMONITOR
3853			endif 
3853			 
3853					NEXTW 
3853 c3 b2 24			jp macro_next 
3856				endm 
# End of macro NEXTW
3856				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3856			 
3856			.mloopnotdone: 
3856			 
3856 e1				pop hl    ; get I 
3857 2b				dec hl 
3858			 
3858			   	; save new I 
3858			 
3858			 
3858					; set I counter 
3858			 
3858 22 e3 f4				ld (os_current_i), hl 
385b			 
385b					 
385b				FORTH_LOOP_NEXT 
385b cd 2d 23			call macro_forth_loop_next 
385e				endm 
# End of macro FORTH_LOOP_NEXT
385e			 
385e			 
385e					if DEBUG_FORTH_WORDS 
385e eb						ex de,hl 
385f					endif 
385f			 
385f			;	; get DO ptr 
385f			; 
385f				FORTH_RSP_TOS 
385f cd c3 20			call macro_forth_rsp_tos 
3862				endm 
# End of macro FORTH_RSP_TOS
3862			 
3862				;push hl 
3862			 
3862				; not going to DO any more 
3862				; get rid of the RSP pointer as DO will add it back in 
3862				;FORTH_RSP_POP 
3862				;pop hl 
3862			 
3862			 
3862 22 bf f4			ld (os_tok_ptr), hl 
3865					if DEBUG_FORTH_WORDS 
3865						DMARK "-L<" 
3865 f5				push af  
3866 3a 7a 38			ld a, (.dmark)  
3869 32 68 fe			ld (debug_mark),a  
386c 3a 7b 38			ld a, (.dmark+1)  
386f 32 69 fe			ld (debug_mark+1),a  
3872 3a 7c 38			ld a, (.dmark+2)  
3875 32 6a fe			ld (debug_mark+2),a  
3878 18 03			jr .pastdmark  
387a ..			.dmark: db "-L<"  
387d f1			.pastdmark: pop af  
387e			endm  
# End of macro DMARK
387e					CALLMONITOR 
387e cd 6c fe			call debug_vector  
3881				endm  
# End of macro CALLMONITOR
3881				endif 
3881 c3 43 25			jp exec1 
3884			 
3884					 
3884			 
3884			 
3884			 
3884				NEXTW 
3884 c3 b2 24			jp macro_next 
3887				endm 
# End of macro NEXTW
3887			 
3887			 
3887			 
3887			 
3887			.REPEAT: 
3887				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3887 71				db WORD_SYS_CORE+93             
3888 da 38			dw .UNTIL            
388a 06				db 5 + 1 
388b .. 00			db "REPEAT",0              
3892				endm 
# End of macro CWHEAD
3892			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3892			;  push pc to rsp stack past the REPEAT 
3892					if DEBUG_FORTH_WORDS_KEY 
3892						DMARK "REP" 
3892 f5				push af  
3893 3a a7 38			ld a, (.dmark)  
3896 32 68 fe			ld (debug_mark),a  
3899 3a a8 38			ld a, (.dmark+1)  
389c 32 69 fe			ld (debug_mark+1),a  
389f 3a a9 38			ld a, (.dmark+2)  
38a2 32 6a fe			ld (debug_mark+2),a  
38a5 18 03			jr .pastdmark  
38a7 ..			.dmark: db "REP"  
38aa f1			.pastdmark: pop af  
38ab			endm  
# End of macro DMARK
38ab						CALLMONITOR 
38ab cd 6c fe			call debug_vector  
38ae				endm  
# End of macro CALLMONITOR
38ae					endif 
38ae			 
38ae 2a bf f4				ld hl, (os_tok_ptr) 
38b1 23					inc hl   ; R 
38b2 23					inc hl  ; E 
38b3 23					inc hl   ; P 
38b4 23					inc hl   ; E 
38b5 23					inc hl   ; A 
38b6 23					inc hl   ; T 
38b7 23					inc hl   ; zero 
38b8					FORTH_RSP_NEXT 
38b8 cd ac 20			call macro_forth_rsp_next 
38bb				endm 
# End of macro FORTH_RSP_NEXT
38bb			 
38bb			 
38bb					if DEBUG_FORTH_WORDS 
38bb						DMARK "REP" 
38bb f5				push af  
38bc 3a d0 38			ld a, (.dmark)  
38bf 32 68 fe			ld (debug_mark),a  
38c2 3a d1 38			ld a, (.dmark+1)  
38c5 32 69 fe			ld (debug_mark+1),a  
38c8 3a d2 38			ld a, (.dmark+2)  
38cb 32 6a fe			ld (debug_mark+2),a  
38ce 18 03			jr .pastdmark  
38d0 ..			.dmark: db "REP"  
38d3 f1			.pastdmark: pop af  
38d4			endm  
# End of macro DMARK
38d4						;pop bc    ; TODO BUG ?????? what is this for???? 
38d4						CALLMONITOR 
38d4 cd 6c fe			call debug_vector  
38d7				endm  
# End of macro CALLMONITOR
38d7					endif 
38d7			 
38d7					NEXTW 
38d7 c3 b2 24			jp macro_next 
38da				endm 
# End of macro NEXTW
38da			;	       NEXTW 
38da			 
38da			.UNTIL: 
38da				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
38da 72				db WORD_SYS_CORE+94             
38db 71 39			dw .ENDFLOW            
38dd 06				db 5 + 1 
38de .. 00			db "UNTIL",0              
38e4				endm 
# End of macro CWHEAD
38e4			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
38e4			 
38e4				; pop tos as check 
38e4			 
38e4				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
38e4			 
38e4				FORTH_DSP_VALUEHL 
38e4 cd fc 22			call macro_dsp_valuehl 
38e7				endm 
# End of macro FORTH_DSP_VALUEHL
38e7			 
38e7					if DEBUG_FORTH_WORDS_KEY 
38e7						DMARK "UNT" 
38e7 f5				push af  
38e8 3a fc 38			ld a, (.dmark)  
38eb 32 68 fe			ld (debug_mark),a  
38ee 3a fd 38			ld a, (.dmark+1)  
38f1 32 69 fe			ld (debug_mark+1),a  
38f4 3a fe 38			ld a, (.dmark+2)  
38f7 32 6a fe			ld (debug_mark+2),a  
38fa 18 03			jr .pastdmark  
38fc ..			.dmark: db "UNT"  
38ff f1			.pastdmark: pop af  
3900			endm  
# End of macro DMARK
3900						CALLMONITOR 
3900 cd 6c fe			call debug_vector  
3903				endm  
# End of macro CALLMONITOR
3903					endif 
3903			 
3903			;	push hl 
3903				FORTH_DSP_POP 
3903 cd b4 23			call macro_forth_dsp_pop 
3906				endm 
# End of macro FORTH_DSP_POP
3906			 
3906			;	pop hl 
3906			 
3906				; test if true 
3906			 
3906 cd f9 0f			call ishlzero 
3909			;	ld a,l 
3909			;	add h 
3909			; 
3909			;	cp 0 
3909			 
3909 20 3e			jr nz, .untilnotdone 
390b			 
390b					if DEBUG_FORTH_WORDS 
390b						DMARK "UNf" 
390b f5				push af  
390c 3a 20 39			ld a, (.dmark)  
390f 32 68 fe			ld (debug_mark),a  
3912 3a 21 39			ld a, (.dmark+1)  
3915 32 69 fe			ld (debug_mark+1),a  
3918 3a 22 39			ld a, (.dmark+2)  
391b 32 6a fe			ld (debug_mark+2),a  
391e 18 03			jr .pastdmark  
3920 ..			.dmark: db "UNf"  
3923 f1			.pastdmark: pop af  
3924			endm  
# End of macro DMARK
3924						CALLMONITOR 
3924 cd 6c fe			call debug_vector  
3927				endm  
# End of macro CALLMONITOR
3927					endif 
3927			 
3927			 
3927			 
3927				FORTH_RSP_POP     ; get rid of DO ptr 
3927 cd cd 20			call macro_forth_rsp_pop 
392a				endm 
# End of macro FORTH_RSP_POP
392a			 
392a			if DEBUG_FORTH_WORDS 
392a						DMARK "UN>" 
392a f5				push af  
392b 3a 3f 39			ld a, (.dmark)  
392e 32 68 fe			ld (debug_mark),a  
3931 3a 40 39			ld a, (.dmark+1)  
3934 32 69 fe			ld (debug_mark+1),a  
3937 3a 41 39			ld a, (.dmark+2)  
393a 32 6a fe			ld (debug_mark+2),a  
393d 18 03			jr .pastdmark  
393f ..			.dmark: db "UN>"  
3942 f1			.pastdmark: pop af  
3943			endm  
# End of macro DMARK
3943				CALLMONITOR 
3943 cd 6c fe			call debug_vector  
3946				endm  
# End of macro CALLMONITOR
3946			endif 
3946			 
3946					NEXTW 
3946 c3 b2 24			jp macro_next 
3949				endm 
# End of macro NEXTW
3949				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3949			 
3949			.untilnotdone: 
3949			 
3949			 
3949			;	; get DO ptr 
3949			; 
3949				FORTH_RSP_TOS 
3949 cd c3 20			call macro_forth_rsp_tos 
394c				endm 
# End of macro FORTH_RSP_TOS
394c			 
394c				;push hl 
394c			 
394c				; not going to DO any more 
394c				; get rid of the RSP pointer as DO will add it back in 
394c				;FORTH_RSP_POP 
394c				;pop hl 
394c			 
394c			 
394c 22 bf f4			ld (os_tok_ptr), hl 
394f					if DEBUG_FORTH_WORDS 
394f						DMARK "UN<" 
394f f5				push af  
3950 3a 64 39			ld a, (.dmark)  
3953 32 68 fe			ld (debug_mark),a  
3956 3a 65 39			ld a, (.dmark+1)  
3959 32 69 fe			ld (debug_mark+1),a  
395c 3a 66 39			ld a, (.dmark+2)  
395f 32 6a fe			ld (debug_mark+2),a  
3962 18 03			jr .pastdmark  
3964 ..			.dmark: db "UN<"  
3967 f1			.pastdmark: pop af  
3968			endm  
# End of macro DMARK
3968					CALLMONITOR 
3968 cd 6c fe			call debug_vector  
396b				endm  
# End of macro CALLMONITOR
396b				endif 
396b c3 43 25			jp exec1 
396e			 
396e					 
396e			 
396e			 
396e					NEXTW 
396e c3 b2 24			jp macro_next 
3971				endm 
# End of macro NEXTW
3971			 
3971			 
3971			.ENDFLOW: 
3971			 
3971			; eof 
3971			 
# End of file forth_words_flow.asm
3971			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3971			include "forth_words_logic.asm" 
3971			 
3971			; | ## Logic Words 
3971			 
3971			.NOT: 
3971				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3971 2d				db WORD_SYS_CORE+25             
3972 b9 39			dw .IS            
3974 04				db 3 + 1 
3975 .. 00			db "NOT",0              
3979				endm 
# End of macro CWHEAD
3979			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3979					if DEBUG_FORTH_WORDS_KEY 
3979						DMARK "NOT" 
3979 f5				push af  
397a 3a 8e 39			ld a, (.dmark)  
397d 32 68 fe			ld (debug_mark),a  
3980 3a 8f 39			ld a, (.dmark+1)  
3983 32 69 fe			ld (debug_mark+1),a  
3986 3a 90 39			ld a, (.dmark+2)  
3989 32 6a fe			ld (debug_mark+2),a  
398c 18 03			jr .pastdmark  
398e ..			.dmark: db "NOT"  
3991 f1			.pastdmark: pop af  
3992			endm  
# End of macro DMARK
3992						CALLMONITOR 
3992 cd 6c fe			call debug_vector  
3995				endm  
# End of macro CALLMONITOR
3995					endif 
3995					FORTH_DSP 
3995 cd c2 22			call macro_forth_dsp 
3998				endm 
# End of macro FORTH_DSP
3998 7e					ld a,(hl)	; get type of value on TOS 
3999 fe 02				cp DS_TYPE_INUM  
399b 28 03				jr z, .noti 
399d					NEXTW 
399d c3 b2 24			jp macro_next 
39a0				endm 
# End of macro NEXTW
39a0			.noti:          FORTH_DSP_VALUEHL 
39a0 cd fc 22			call macro_dsp_valuehl 
39a3				endm 
# End of macro FORTH_DSP_VALUEHL
39a3			;		push hl 
39a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39a3 cd b4 23			call macro_forth_dsp_pop 
39a6				endm 
# End of macro FORTH_DSP_POP
39a6			;		pop hl 
39a6 3e 00				ld a,0 
39a8 bd					cp l 
39a9 28 04				jr z, .not2t 
39ab 2e 00				ld l, 0 
39ad 18 02				jr .notip 
39af			 
39af 2e ff		.not2t:		ld l, 255 
39b1			 
39b1 26 00		.notip:		ld h, 0	 
39b3			 
39b3 cd 05 21				call forth_push_numhl 
39b6					NEXTW 
39b6 c3 b2 24			jp macro_next 
39b9				endm 
# End of macro NEXTW
39b9			 
39b9			.IS: 
39b9				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
39b9 2d				db WORD_SYS_CORE+25             
39ba df 39			dw .LZERO            
39bc 03				db 2 + 1 
39bd .. 00			db "IS",0              
39c0				endm 
# End of macro CWHEAD
39c0			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
39c0					if DEBUG_FORTH_WORDS_KEY 
39c0						DMARK "IS." 
39c0 f5				push af  
39c1 3a d5 39			ld a, (.dmark)  
39c4 32 68 fe			ld (debug_mark),a  
39c7 3a d6 39			ld a, (.dmark+1)  
39ca 32 69 fe			ld (debug_mark+1),a  
39cd 3a d7 39			ld a, (.dmark+2)  
39d0 32 6a fe			ld (debug_mark+2),a  
39d3 18 03			jr .pastdmark  
39d5 ..			.dmark: db "IS."  
39d8 f1			.pastdmark: pop af  
39d9			endm  
# End of macro DMARK
39d9						CALLMONITOR 
39d9 cd 6c fe			call debug_vector  
39dc				endm  
# End of macro CALLMONITOR
39dc					endif 
39dc					NEXTW 
39dc c3 b2 24			jp macro_next 
39df				endm 
# End of macro NEXTW
39df			.LZERO: 
39df				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
39df 2d				db WORD_SYS_CORE+25             
39e0 e9 39			dw .TZERO            
39e2 03				db 2 + 1 
39e3 .. 00			db "0<",0              
39e6				endm 
# End of macro CWHEAD
39e6			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
39e6					NEXTW 
39e6 c3 b2 24			jp macro_next 
39e9				endm 
# End of macro NEXTW
39e9			.TZERO: 
39e9				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
39e9 2e				db WORD_SYS_CORE+26             
39ea 30 3a			dw .LESS            
39ec 03				db 2 + 1 
39ed .. 00			db "0=",0              
39f0				endm 
# End of macro CWHEAD
39f0			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
39f0				; TODO add floating point number detection 
39f0					;v5 FORTH_DSP_VALUE 
39f0					if DEBUG_FORTH_WORDS_KEY 
39f0						DMARK "0=." 
39f0 f5				push af  
39f1 3a 05 3a			ld a, (.dmark)  
39f4 32 68 fe			ld (debug_mark),a  
39f7 3a 06 3a			ld a, (.dmark+1)  
39fa 32 69 fe			ld (debug_mark+1),a  
39fd 3a 07 3a			ld a, (.dmark+2)  
3a00 32 6a fe			ld (debug_mark+2),a  
3a03 18 03			jr .pastdmark  
3a05 ..			.dmark: db "0=."  
3a08 f1			.pastdmark: pop af  
3a09			endm  
# End of macro DMARK
3a09						CALLMONITOR 
3a09 cd 6c fe			call debug_vector  
3a0c				endm  
# End of macro CALLMONITOR
3a0c					endif 
3a0c					FORTH_DSP 
3a0c cd c2 22			call macro_forth_dsp 
3a0f				endm 
# End of macro FORTH_DSP
3a0f 7e					ld a,(hl)	; get type of value on TOS 
3a10 fe 02				cp DS_TYPE_INUM  
3a12 28 00				jr z, .tz_inum 
3a14			 
3a14				if FORTH_ENABLE_FLOATMATH 
3a14					jr .tz_done 
3a14			 
3a14				endif 
3a14					 
3a14			 
3a14			.tz_inum: 
3a14					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a14 cd fc 22			call macro_dsp_valuehl 
3a17				endm 
# End of macro FORTH_DSP_VALUEHL
3a17			 
3a17			;		push hl 
3a17			 
3a17					; destroy value TOS 
3a17			 
3a17					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a17 cd b4 23			call macro_forth_dsp_pop 
3a1a				endm 
# End of macro FORTH_DSP_POP
3a1a			 
3a1a			;		pop hl 
3a1a			 
3a1a 3e 00				ld a,0 
3a1c			 
3a1c bd					cp l 
3a1d 20 08				jr nz, .tz_notzero 
3a1f			 
3a1f bc					cp h 
3a20			 
3a20 20 05				jr nz, .tz_notzero 
3a22			 
3a22			 
3a22 21 01 00				ld hl, FORTH_TRUE 
3a25 18 03				jr .tz_done 
3a27			 
3a27 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3a2a			 
3a2a					; push value back onto stack for another op etc 
3a2a			 
3a2a			.tz_done: 
3a2a cd 05 21				call forth_push_numhl 
3a2d			 
3a2d					NEXTW 
3a2d c3 b2 24			jp macro_next 
3a30				endm 
# End of macro NEXTW
3a30			.LESS: 
3a30				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3a30 2f				db WORD_SYS_CORE+27             
3a31 99 3a			dw .GT            
3a33 02				db 1 + 1 
3a34 .. 00			db "<",0              
3a36				endm 
# End of macro CWHEAD
3a36			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3a36				; TODO add floating point number detection 
3a36					if DEBUG_FORTH_WORDS_KEY 
3a36						DMARK "LES" 
3a36 f5				push af  
3a37 3a 4b 3a			ld a, (.dmark)  
3a3a 32 68 fe			ld (debug_mark),a  
3a3d 3a 4c 3a			ld a, (.dmark+1)  
3a40 32 69 fe			ld (debug_mark+1),a  
3a43 3a 4d 3a			ld a, (.dmark+2)  
3a46 32 6a fe			ld (debug_mark+2),a  
3a49 18 03			jr .pastdmark  
3a4b ..			.dmark: db "LES"  
3a4e f1			.pastdmark: pop af  
3a4f			endm  
# End of macro DMARK
3a4f						CALLMONITOR 
3a4f cd 6c fe			call debug_vector  
3a52				endm  
# End of macro CALLMONITOR
3a52					endif 
3a52					FORTH_DSP 
3a52 cd c2 22			call macro_forth_dsp 
3a55				endm 
# End of macro FORTH_DSP
3a55					;v5 FORTH_DSP_VALUE 
3a55 7e					ld a,(hl)	; get type of value on TOS 
3a56 fe 02				cp DS_TYPE_INUM  
3a58 28 00				jr z, .less_inum 
3a5a			 
3a5a				if FORTH_ENABLE_FLOATMATH 
3a5a					jr .less_done 
3a5a			 
3a5a				endif 
3a5a					 
3a5a			 
3a5a			.less_inum: 
3a5a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a5a cd fc 22			call macro_dsp_valuehl 
3a5d				endm 
# End of macro FORTH_DSP_VALUEHL
3a5d			 
3a5d e5					push hl  ; u2 
3a5e			 
3a5e					; destroy value TOS 
3a5e			 
3a5e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a5e cd b4 23			call macro_forth_dsp_pop 
3a61				endm 
# End of macro FORTH_DSP_POP
3a61			 
3a61			 
3a61					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a61 cd fc 22			call macro_dsp_valuehl 
3a64				endm 
# End of macro FORTH_DSP_VALUEHL
3a64			 
3a64 e5					push hl    ; u1 
3a65			 
3a65					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a65 cd b4 23			call macro_forth_dsp_pop 
3a68				endm 
# End of macro FORTH_DSP_POP
3a68			 
3a68			 
3a68 b7			 or a      ;clear carry flag 
3a69 01 00 00		 ld bc, FORTH_FALSE 
3a6c e1			  pop hl    ; u1 
3a6d d1			  pop de    ; u2 
3a6e ed 52		  sbc hl,de 
3a70 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3a72			 
3a72 01 01 00		 ld bc, FORTH_TRUE 
3a75			.lscont:  
3a75 c5					push bc 
3a76 e1					pop hl 
3a77			 
3a77					if DEBUG_FORTH_WORDS 
3a77						DMARK "LT1" 
3a77 f5				push af  
3a78 3a 8c 3a			ld a, (.dmark)  
3a7b 32 68 fe			ld (debug_mark),a  
3a7e 3a 8d 3a			ld a, (.dmark+1)  
3a81 32 69 fe			ld (debug_mark+1),a  
3a84 3a 8e 3a			ld a, (.dmark+2)  
3a87 32 6a fe			ld (debug_mark+2),a  
3a8a 18 03			jr .pastdmark  
3a8c ..			.dmark: db "LT1"  
3a8f f1			.pastdmark: pop af  
3a90			endm  
# End of macro DMARK
3a90						CALLMONITOR 
3a90 cd 6c fe			call debug_vector  
3a93				endm  
# End of macro CALLMONITOR
3a93					endif 
3a93 cd 05 21				call forth_push_numhl 
3a96			 
3a96					NEXTW 
3a96 c3 b2 24			jp macro_next 
3a99				endm 
# End of macro NEXTW
3a99			.GT: 
3a99				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3a99 30				db WORD_SYS_CORE+28             
3a9a 02 3b			dw .EQUAL            
3a9c 02				db 1 + 1 
3a9d .. 00			db ">",0              
3a9f				endm 
# End of macro CWHEAD
3a9f			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3a9f				; TODO add floating point number detection 
3a9f					if DEBUG_FORTH_WORDS_KEY 
3a9f						DMARK "GRT" 
3a9f f5				push af  
3aa0 3a b4 3a			ld a, (.dmark)  
3aa3 32 68 fe			ld (debug_mark),a  
3aa6 3a b5 3a			ld a, (.dmark+1)  
3aa9 32 69 fe			ld (debug_mark+1),a  
3aac 3a b6 3a			ld a, (.dmark+2)  
3aaf 32 6a fe			ld (debug_mark+2),a  
3ab2 18 03			jr .pastdmark  
3ab4 ..			.dmark: db "GRT"  
3ab7 f1			.pastdmark: pop af  
3ab8			endm  
# End of macro DMARK
3ab8						CALLMONITOR 
3ab8 cd 6c fe			call debug_vector  
3abb				endm  
# End of macro CALLMONITOR
3abb					endif 
3abb					FORTH_DSP 
3abb cd c2 22			call macro_forth_dsp 
3abe				endm 
# End of macro FORTH_DSP
3abe					;FORTH_DSP_VALUE 
3abe 7e					ld a,(hl)	; get type of value on TOS 
3abf fe 02				cp DS_TYPE_INUM  
3ac1 28 00				jr z, .gt_inum 
3ac3			 
3ac3				if FORTH_ENABLE_FLOATMATH 
3ac3					jr .gt_done 
3ac3			 
3ac3				endif 
3ac3					 
3ac3			 
3ac3			.gt_inum: 
3ac3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ac3 cd fc 22			call macro_dsp_valuehl 
3ac6				endm 
# End of macro FORTH_DSP_VALUEHL
3ac6			 
3ac6 e5					push hl  ; u2 
3ac7			 
3ac7					; destroy value TOS 
3ac7			 
3ac7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ac7 cd b4 23			call macro_forth_dsp_pop 
3aca				endm 
# End of macro FORTH_DSP_POP
3aca			 
3aca			 
3aca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aca cd fc 22			call macro_dsp_valuehl 
3acd				endm 
# End of macro FORTH_DSP_VALUEHL
3acd			 
3acd e5					push hl    ; u1 
3ace			 
3ace					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ace cd b4 23			call macro_forth_dsp_pop 
3ad1				endm 
# End of macro FORTH_DSP_POP
3ad1			 
3ad1			 
3ad1 b7			 or a      ;clear carry flag 
3ad2 01 00 00		 ld bc, FORTH_FALSE 
3ad5 e1			  pop hl    ; u1 
3ad6 d1			  pop de    ; u2 
3ad7 ed 52		  sbc hl,de 
3ad9 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3adb			 
3adb 01 01 00		 ld bc, FORTH_TRUE 
3ade			.gtcont:  
3ade c5					push bc 
3adf e1					pop hl 
3ae0			 
3ae0					if DEBUG_FORTH_WORDS 
3ae0						DMARK "GT1" 
3ae0 f5				push af  
3ae1 3a f5 3a			ld a, (.dmark)  
3ae4 32 68 fe			ld (debug_mark),a  
3ae7 3a f6 3a			ld a, (.dmark+1)  
3aea 32 69 fe			ld (debug_mark+1),a  
3aed 3a f7 3a			ld a, (.dmark+2)  
3af0 32 6a fe			ld (debug_mark+2),a  
3af3 18 03			jr .pastdmark  
3af5 ..			.dmark: db "GT1"  
3af8 f1			.pastdmark: pop af  
3af9			endm  
# End of macro DMARK
3af9						CALLMONITOR 
3af9 cd 6c fe			call debug_vector  
3afc				endm  
# End of macro CALLMONITOR
3afc					endif 
3afc cd 05 21				call forth_push_numhl 
3aff			 
3aff					NEXTW 
3aff c3 b2 24			jp macro_next 
3b02				endm 
# End of macro NEXTW
3b02			.EQUAL: 
3b02				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3b02 31				db WORD_SYS_CORE+29             
3b03 6d 3b			dw .ENDLOGIC            
3b05 02				db 1 + 1 
3b06 .. 00			db "=",0              
3b08				endm 
# End of macro CWHEAD
3b08			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3b08				; TODO add floating point number detection 
3b08					if DEBUG_FORTH_WORDS_KEY 
3b08						DMARK "EQ." 
3b08 f5				push af  
3b09 3a 1d 3b			ld a, (.dmark)  
3b0c 32 68 fe			ld (debug_mark),a  
3b0f 3a 1e 3b			ld a, (.dmark+1)  
3b12 32 69 fe			ld (debug_mark+1),a  
3b15 3a 1f 3b			ld a, (.dmark+2)  
3b18 32 6a fe			ld (debug_mark+2),a  
3b1b 18 03			jr .pastdmark  
3b1d ..			.dmark: db "EQ."  
3b20 f1			.pastdmark: pop af  
3b21			endm  
# End of macro DMARK
3b21						CALLMONITOR 
3b21 cd 6c fe			call debug_vector  
3b24				endm  
# End of macro CALLMONITOR
3b24					endif 
3b24					FORTH_DSP 
3b24 cd c2 22			call macro_forth_dsp 
3b27				endm 
# End of macro FORTH_DSP
3b27					;v5 FORTH_DSP_VALUE 
3b27 7e					ld a,(hl)	; get type of value on TOS 
3b28 fe 02				cp DS_TYPE_INUM  
3b2a 28 00				jr z, .eq_inum 
3b2c			 
3b2c				if FORTH_ENABLE_FLOATMATH 
3b2c					jr .eq_done 
3b2c			 
3b2c				endif 
3b2c					 
3b2c			 
3b2c			.eq_inum: 
3b2c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b2c cd fc 22			call macro_dsp_valuehl 
3b2f				endm 
# End of macro FORTH_DSP_VALUEHL
3b2f			 
3b2f e5					push hl 
3b30			 
3b30					; destroy value TOS 
3b30			 
3b30					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b30 cd b4 23			call macro_forth_dsp_pop 
3b33				endm 
# End of macro FORTH_DSP_POP
3b33			 
3b33			 
3b33					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b33 cd fc 22			call macro_dsp_valuehl 
3b36				endm 
# End of macro FORTH_DSP_VALUEHL
3b36			 
3b36					; one value on hl get other one back 
3b36			 
3b36 e5					push hl 
3b37			 
3b37					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b37 cd b4 23			call macro_forth_dsp_pop 
3b3a				endm 
# End of macro FORTH_DSP_POP
3b3a			 
3b3a 0e 00				ld c, FORTH_FALSE 
3b3c			 
3b3c e1					pop hl 
3b3d d1					pop de 
3b3e			 
3b3e 7b					ld a, e 
3b3f bd					cp l 
3b40			 
3b40 20 06				jr nz, .eq_done 
3b42			 
3b42 7a					ld a, d 
3b43 bc					cp h 
3b44			 
3b44 20 02				jr nz, .eq_done 
3b46			 
3b46 0e 01				ld c, FORTH_TRUE 
3b48					 
3b48			 
3b48			 
3b48			.eq_done: 
3b48			 
3b48					; TODO push value back onto stack for another op etc 
3b48			 
3b48 26 00				ld h, 0 
3b4a 69					ld l, c 
3b4b					if DEBUG_FORTH_WORDS 
3b4b						DMARK "EQ1" 
3b4b f5				push af  
3b4c 3a 60 3b			ld a, (.dmark)  
3b4f 32 68 fe			ld (debug_mark),a  
3b52 3a 61 3b			ld a, (.dmark+1)  
3b55 32 69 fe			ld (debug_mark+1),a  
3b58 3a 62 3b			ld a, (.dmark+2)  
3b5b 32 6a fe			ld (debug_mark+2),a  
3b5e 18 03			jr .pastdmark  
3b60 ..			.dmark: db "EQ1"  
3b63 f1			.pastdmark: pop af  
3b64			endm  
# End of macro DMARK
3b64						CALLMONITOR 
3b64 cd 6c fe			call debug_vector  
3b67				endm  
# End of macro CALLMONITOR
3b67					endif 
3b67 cd 05 21				call forth_push_numhl 
3b6a			 
3b6a					NEXTW 
3b6a c3 b2 24			jp macro_next 
3b6d				endm 
# End of macro NEXTW
3b6d			 
3b6d			 
3b6d			.ENDLOGIC: 
3b6d			; eof 
3b6d			 
3b6d			 
# End of file forth_words_logic.asm
3b6d			include "forth_words_maths.asm" 
3b6d			 
3b6d			; | ## Maths Words 
3b6d			 
3b6d			.PLUS:	 
3b6d				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3b6d 15				db WORD_SYS_CORE+1             
3b6e cb 3b			dw .NEG            
3b70 02				db 1 + 1 
3b71 .. 00			db "+",0              
3b73				endm 
# End of macro CWHEAD
3b73			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3b73					if DEBUG_FORTH_WORDS_KEY 
3b73						DMARK "PLU" 
3b73 f5				push af  
3b74 3a 88 3b			ld a, (.dmark)  
3b77 32 68 fe			ld (debug_mark),a  
3b7a 3a 89 3b			ld a, (.dmark+1)  
3b7d 32 69 fe			ld (debug_mark+1),a  
3b80 3a 8a 3b			ld a, (.dmark+2)  
3b83 32 6a fe			ld (debug_mark+2),a  
3b86 18 03			jr .pastdmark  
3b88 ..			.dmark: db "PLU"  
3b8b f1			.pastdmark: pop af  
3b8c			endm  
# End of macro DMARK
3b8c						CALLMONITOR 
3b8c cd 6c fe			call debug_vector  
3b8f				endm  
# End of macro CALLMONITOR
3b8f					endif 
3b8f					; add top two values and push back result 
3b8f			 
3b8f					;for v5 FORTH_DSP_VALUE 
3b8f					FORTH_DSP 
3b8f cd c2 22			call macro_forth_dsp 
3b92				endm 
# End of macro FORTH_DSP
3b92 7e					ld a,(hl)	; get type of value on TOS 
3b93 fe 02				cp DS_TYPE_INUM  
3b95 28 03				jr z, .dot_inum 
3b97			 
3b97					NEXTW 
3b97 c3 b2 24			jp macro_next 
3b9a				endm 
# End of macro NEXTW
3b9a			 
3b9a			; float maths 
3b9a			 
3b9a				if FORTH_ENABLE_FLOATMATH 
3b9a						inc hl      ; now at start of numeric as string 
3b9a			 
3b9a					if DEBUG_FORTH_MATHS 
3b9a						DMARK "ADD" 
3b9a				CALLMONITOR 
3b9a					endif 
3b9a			 
3b9a					;ld ix, hl 
3b9a					call CON 
3b9a			 
3b9a			 
3b9a					push hl 
3b9a					 
3b9a					 
3b9a			 
3b9a						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3b9a			 
3b9a					; get next number 
3b9a			 
3b9a						FORTH_DSP_VALUE 
3b9a			 
3b9a						inc hl      ; now at start of numeric as string 
3b9a			 
3b9a					;ld ix, hl 
3b9a					call CON 
3b9a			 
3b9a					push hl 
3b9a			 
3b9a			 
3b9a						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b9a			 
3b9a						; TODO do add 
3b9a			 
3b9a						call IADD 
3b9a			 
3b9a						; TODO get result back as ascii 
3b9a			 
3b9a						; TODO push result  
3b9a			 
3b9a			 
3b9a			 
3b9a						jr .dot_done 
3b9a				endif 
3b9a			 
3b9a			.dot_inum: 
3b9a			 
3b9a			 
3b9a					if DEBUG_FORTH_DOT 
3b9a						DMARK "+IT" 
3b9a f5				push af  
3b9b 3a af 3b			ld a, (.dmark)  
3b9e 32 68 fe			ld (debug_mark),a  
3ba1 3a b0 3b			ld a, (.dmark+1)  
3ba4 32 69 fe			ld (debug_mark+1),a  
3ba7 3a b1 3b			ld a, (.dmark+2)  
3baa 32 6a fe			ld (debug_mark+2),a  
3bad 18 03			jr .pastdmark  
3baf ..			.dmark: db "+IT"  
3bb2 f1			.pastdmark: pop af  
3bb3			endm  
# End of macro DMARK
3bb3				CALLMONITOR 
3bb3 cd 6c fe			call debug_vector  
3bb6				endm  
# End of macro CALLMONITOR
3bb6					endif 
3bb6			 
3bb6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bb6 cd fc 22			call macro_dsp_valuehl 
3bb9				endm 
# End of macro FORTH_DSP_VALUEHL
3bb9			 
3bb9				; TODO add floating point number detection 
3bb9			 
3bb9 e5					push hl 
3bba			 
3bba					; destroy value TOS 
3bba			 
3bba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bba cd b4 23			call macro_forth_dsp_pop 
3bbd				endm 
# End of macro FORTH_DSP_POP
3bbd			 
3bbd			 
3bbd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bbd cd fc 22			call macro_dsp_valuehl 
3bc0				endm 
# End of macro FORTH_DSP_VALUEHL
3bc0			 
3bc0					; one value on hl get other one back 
3bc0			 
3bc0 d1					pop de 
3bc1			 
3bc1					; do the add 
3bc1			 
3bc1 19					add hl,de 
3bc2			 
3bc2					; save it 
3bc2			 
3bc2			;		push hl	 
3bc2			 
3bc2					; 
3bc2			 
3bc2					; destroy value TOS 
3bc2			 
3bc2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bc2 cd b4 23			call macro_forth_dsp_pop 
3bc5				endm 
# End of macro FORTH_DSP_POP
3bc5			 
3bc5					; TODO push value back onto stack for another op etc 
3bc5			 
3bc5			;		pop hl 
3bc5			 
3bc5			.dot_done: 
3bc5 cd 05 21				call forth_push_numhl 
3bc8			 
3bc8					NEXTW 
3bc8 c3 b2 24			jp macro_next 
3bcb				endm 
# End of macro NEXTW
3bcb			.NEG: 
3bcb			 
3bcb				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3bcb 17				db WORD_SYS_CORE+3             
3bcc 0e 3c			dw .DIV            
3bce 02				db 1 + 1 
3bcf .. 00			db "-",0              
3bd1				endm 
# End of macro CWHEAD
3bd1			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3bd1					if DEBUG_FORTH_WORDS_KEY 
3bd1						DMARK "SUB" 
3bd1 f5				push af  
3bd2 3a e6 3b			ld a, (.dmark)  
3bd5 32 68 fe			ld (debug_mark),a  
3bd8 3a e7 3b			ld a, (.dmark+1)  
3bdb 32 69 fe			ld (debug_mark+1),a  
3bde 3a e8 3b			ld a, (.dmark+2)  
3be1 32 6a fe			ld (debug_mark+2),a  
3be4 18 03			jr .pastdmark  
3be6 ..			.dmark: db "SUB"  
3be9 f1			.pastdmark: pop af  
3bea			endm  
# End of macro DMARK
3bea						CALLMONITOR 
3bea cd 6c fe			call debug_vector  
3bed				endm  
# End of macro CALLMONITOR
3bed					endif 
3bed			 
3bed			 
3bed				; TODO add floating point number detection 
3bed					; v5 FORTH_DSP_VALUE 
3bed					FORTH_DSP 
3bed cd c2 22			call macro_forth_dsp 
3bf0				endm 
# End of macro FORTH_DSP
3bf0 7e					ld a,(hl)	; get type of value on TOS 
3bf1 fe 02				cp DS_TYPE_INUM  
3bf3 28 03				jr z, .neg_inum 
3bf5			 
3bf5					NEXTW 
3bf5 c3 b2 24			jp macro_next 
3bf8				endm 
# End of macro NEXTW
3bf8			 
3bf8			; float maths 
3bf8			 
3bf8				if FORTH_ENABLE_FLOATMATH 
3bf8					jr .neg_done 
3bf8			 
3bf8				endif 
3bf8					 
3bf8			 
3bf8			.neg_inum: 
3bf8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bf8 cd fc 22			call macro_dsp_valuehl 
3bfb				endm 
# End of macro FORTH_DSP_VALUEHL
3bfb			 
3bfb e5					push hl 
3bfc			 
3bfc					; destroy value TOS 
3bfc			 
3bfc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bfc cd b4 23			call macro_forth_dsp_pop 
3bff				endm 
# End of macro FORTH_DSP_POP
3bff			 
3bff			 
3bff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bff cd fc 22			call macro_dsp_valuehl 
3c02				endm 
# End of macro FORTH_DSP_VALUEHL
3c02			 
3c02					; one value on hl get other one back 
3c02			 
3c02 d1					pop de 
3c03			 
3c03					; do the sub 
3c03			;		ex de, hl 
3c03			 
3c03 ed 52				sbc hl,de 
3c05			 
3c05					; save it 
3c05			 
3c05			;		push hl	 
3c05			 
3c05					; 
3c05			 
3c05					; destroy value TOS 
3c05			 
3c05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c05 cd b4 23			call macro_forth_dsp_pop 
3c08				endm 
# End of macro FORTH_DSP_POP
3c08			 
3c08					; TODO push value back onto stack for another op etc 
3c08			 
3c08			;		pop hl 
3c08			 
3c08 cd 05 21				call forth_push_numhl 
3c0b			.neg_done: 
3c0b			 
3c0b					NEXTW 
3c0b c3 b2 24			jp macro_next 
3c0e				endm 
# End of macro NEXTW
3c0e			.DIV: 
3c0e				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3c0e 18				db WORD_SYS_CORE+4             
3c0f 5b 3c			dw .MUL            
3c11 02				db 1 + 1 
3c12 .. 00			db "/",0              
3c14				endm 
# End of macro CWHEAD
3c14			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3c14					if DEBUG_FORTH_WORDS_KEY 
3c14						DMARK "DIV" 
3c14 f5				push af  
3c15 3a 29 3c			ld a, (.dmark)  
3c18 32 68 fe			ld (debug_mark),a  
3c1b 3a 2a 3c			ld a, (.dmark+1)  
3c1e 32 69 fe			ld (debug_mark+1),a  
3c21 3a 2b 3c			ld a, (.dmark+2)  
3c24 32 6a fe			ld (debug_mark+2),a  
3c27 18 03			jr .pastdmark  
3c29 ..			.dmark: db "DIV"  
3c2c f1			.pastdmark: pop af  
3c2d			endm  
# End of macro DMARK
3c2d						CALLMONITOR 
3c2d cd 6c fe			call debug_vector  
3c30				endm  
# End of macro CALLMONITOR
3c30					endif 
3c30				; TODO add floating point number detection 
3c30					; v5 FORTH_DSP_VALUE 
3c30					FORTH_DSP 
3c30 cd c2 22			call macro_forth_dsp 
3c33				endm 
# End of macro FORTH_DSP
3c33 7e					ld a,(hl)	; get type of value on TOS 
3c34 fe 02				cp DS_TYPE_INUM  
3c36 28 03				jr z, .div_inum 
3c38			 
3c38				if FORTH_ENABLE_FLOATMATH 
3c38					jr .div_done 
3c38			 
3c38				endif 
3c38					NEXTW 
3c38 c3 b2 24			jp macro_next 
3c3b				endm 
# End of macro NEXTW
3c3b			.div_inum: 
3c3b			 
3c3b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c3b cd fc 22			call macro_dsp_valuehl 
3c3e				endm 
# End of macro FORTH_DSP_VALUEHL
3c3e			 
3c3e e5					push hl    ; to go to bc 
3c3f			 
3c3f					; destroy value TOS 
3c3f			 
3c3f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c3f cd b4 23			call macro_forth_dsp_pop 
3c42				endm 
# End of macro FORTH_DSP_POP
3c42			 
3c42			 
3c42					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c42 cd fc 22			call macro_dsp_valuehl 
3c45				endm 
# End of macro FORTH_DSP_VALUEHL
3c45			 
3c45					; hl to go to de 
3c45			 
3c45 e5					push hl 
3c46			 
3c46 c1					pop bc 
3c47 d1					pop de		 
3c48			 
3c48			 
3c48					if DEBUG_FORTH_MATHS 
3c48						DMARK "DIV" 
3c48				CALLMONITOR 
3c48					endif 
3c48					; one value on hl but move to a get other one back 
3c48			 
3c48			        
3c48 cd 2d 0f			call Div16 
3c4b			 
3c4b			;	push af	 
3c4b e5				push hl 
3c4c c5				push bc 
3c4d			 
3c4d					if DEBUG_FORTH_MATHS 
3c4d						DMARK "DI1" 
3c4d				CALLMONITOR 
3c4d					endif 
3c4d			 
3c4d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c4d cd b4 23			call macro_forth_dsp_pop 
3c50				endm 
# End of macro FORTH_DSP_POP
3c50			 
3c50			 
3c50			 
3c50 e1					pop hl    ; result 
3c51			 
3c51 cd 05 21				call forth_push_numhl 
3c54			 
3c54 e1					pop hl    ; reminder 
3c55			;		ld h,0 
3c55			;		ld l,d 
3c55			 
3c55 cd 05 21				call forth_push_numhl 
3c58			.div_done: 
3c58					NEXTW 
3c58 c3 b2 24			jp macro_next 
3c5b				endm 
# End of macro NEXTW
3c5b			.MUL: 
3c5b				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3c5b 19				db WORD_SYS_CORE+5             
3c5c a0 3c			dw .MIN            
3c5e 02				db 1 + 1 
3c5f .. 00			db "*",0              
3c61				endm 
# End of macro CWHEAD
3c61			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3c61				; TODO add floating point number detection 
3c61					if DEBUG_FORTH_WORDS_KEY 
3c61						DMARK "MUL" 
3c61 f5				push af  
3c62 3a 76 3c			ld a, (.dmark)  
3c65 32 68 fe			ld (debug_mark),a  
3c68 3a 77 3c			ld a, (.dmark+1)  
3c6b 32 69 fe			ld (debug_mark+1),a  
3c6e 3a 78 3c			ld a, (.dmark+2)  
3c71 32 6a fe			ld (debug_mark+2),a  
3c74 18 03			jr .pastdmark  
3c76 ..			.dmark: db "MUL"  
3c79 f1			.pastdmark: pop af  
3c7a			endm  
# End of macro DMARK
3c7a						CALLMONITOR 
3c7a cd 6c fe			call debug_vector  
3c7d				endm  
# End of macro CALLMONITOR
3c7d					endif 
3c7d					FORTH_DSP 
3c7d cd c2 22			call macro_forth_dsp 
3c80				endm 
# End of macro FORTH_DSP
3c80					; v5 FORTH_DSP_VALUE 
3c80 7e					ld a,(hl)	; get type of value on TOS 
3c81 fe 02				cp DS_TYPE_INUM  
3c83 28 03				jr z, .mul_inum 
3c85			 
3c85				if FORTH_ENABLE_FLOATMATH 
3c85					jr .mul_done 
3c85			 
3c85				endif 
3c85			 
3c85					NEXTW 
3c85 c3 b2 24			jp macro_next 
3c88				endm 
# End of macro NEXTW
3c88			.mul_inum:	 
3c88			 
3c88					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c88 cd fc 22			call macro_dsp_valuehl 
3c8b				endm 
# End of macro FORTH_DSP_VALUEHL
3c8b			 
3c8b e5					push hl 
3c8c			 
3c8c					; destroy value TOS 
3c8c			 
3c8c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c8c cd b4 23			call macro_forth_dsp_pop 
3c8f				endm 
# End of macro FORTH_DSP_POP
3c8f			 
3c8f			 
3c8f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c8f cd fc 22			call macro_dsp_valuehl 
3c92				endm 
# End of macro FORTH_DSP_VALUEHL
3c92			 
3c92					; one value on hl but move to a get other one back 
3c92			 
3c92 7d					ld a, l 
3c93			 
3c93 d1					pop de 
3c94			 
3c94					; do the mull 
3c94			;		ex de, hl 
3c94			 
3c94 cd 53 0f				call Mult16 
3c97					; save it 
3c97			 
3c97			;		push hl	 
3c97			 
3c97					; 
3c97			 
3c97					; destroy value TOS 
3c97			 
3c97					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c97 cd b4 23			call macro_forth_dsp_pop 
3c9a				endm 
# End of macro FORTH_DSP_POP
3c9a			 
3c9a					; TODO push value back onto stack for another op etc 
3c9a			 
3c9a			;		pop hl 
3c9a			 
3c9a cd 05 21				call forth_push_numhl 
3c9d			 
3c9d			.mul_done: 
3c9d					NEXTW 
3c9d c3 b2 24			jp macro_next 
3ca0				endm 
# End of macro NEXTW
3ca0			 
3ca0			 
3ca0			 
3ca0			 
3ca0			.MIN: 
3ca0				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3ca0 49				db WORD_SYS_CORE+53             
3ca1 21 3d			dw .MAX            
3ca3 04				db 3 + 1 
3ca4 .. 00			db "MIN",0              
3ca8				endm 
# End of macro CWHEAD
3ca8			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3ca8					if DEBUG_FORTH_WORDS_KEY 
3ca8						DMARK "MIN" 
3ca8 f5				push af  
3ca9 3a bd 3c			ld a, (.dmark)  
3cac 32 68 fe			ld (debug_mark),a  
3caf 3a be 3c			ld a, (.dmark+1)  
3cb2 32 69 fe			ld (debug_mark+1),a  
3cb5 3a bf 3c			ld a, (.dmark+2)  
3cb8 32 6a fe			ld (debug_mark+2),a  
3cbb 18 03			jr .pastdmark  
3cbd ..			.dmark: db "MIN"  
3cc0 f1			.pastdmark: pop af  
3cc1			endm  
# End of macro DMARK
3cc1						CALLMONITOR 
3cc1 cd 6c fe			call debug_vector  
3cc4				endm  
# End of macro CALLMONITOR
3cc4					endif 
3cc4					; get u2 
3cc4			 
3cc4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cc4 cd fc 22			call macro_dsp_valuehl 
3cc7				endm 
# End of macro FORTH_DSP_VALUEHL
3cc7			 
3cc7 e5					push hl   ; u2 
3cc8			 
3cc8					; destroy value TOS 
3cc8			 
3cc8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cc8 cd b4 23			call macro_forth_dsp_pop 
3ccb				endm 
# End of macro FORTH_DSP_POP
3ccb			 
3ccb					; get u1 
3ccb			 
3ccb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ccb cd fc 22			call macro_dsp_valuehl 
3cce				endm 
# End of macro FORTH_DSP_VALUEHL
3cce			 
3cce e5					push hl  ; u1 
3ccf			 
3ccf					; destroy value TOS 
3ccf			 
3ccf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ccf cd b4 23			call macro_forth_dsp_pop 
3cd2				endm 
# End of macro FORTH_DSP_POP
3cd2			 
3cd2 b7			 or a      ;clear carry flag 
3cd3 e1			  pop hl    ; u1 
3cd4 d1			  pop de    ; u2 
3cd5 e5				push hl   ; saved in case hl is lowest 
3cd6 ed 52		  sbc hl,de 
3cd8 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3cda			 
3cda e1				pop hl 
3cdb					if DEBUG_FORTH_WORDS 
3cdb						DMARK "MIN" 
3cdb f5				push af  
3cdc 3a f0 3c			ld a, (.dmark)  
3cdf 32 68 fe			ld (debug_mark),a  
3ce2 3a f1 3c			ld a, (.dmark+1)  
3ce5 32 69 fe			ld (debug_mark+1),a  
3ce8 3a f2 3c			ld a, (.dmark+2)  
3ceb 32 6a fe			ld (debug_mark+2),a  
3cee 18 03			jr .pastdmark  
3cf0 ..			.dmark: db "MIN"  
3cf3 f1			.pastdmark: pop af  
3cf4			endm  
# End of macro DMARK
3cf4						CALLMONITOR 
3cf4 cd 6c fe			call debug_vector  
3cf7				endm  
# End of macro CALLMONITOR
3cf7					endif 
3cf7 cd 05 21				call forth_push_numhl 
3cfa			 
3cfa				       NEXTW 
3cfa c3 b2 24			jp macro_next 
3cfd				endm 
# End of macro NEXTW
3cfd			 
3cfd			.mincont:  
3cfd c1				pop bc   ; tidy up 
3cfe eb				ex de , hl  
3cff					if DEBUG_FORTH_WORDS 
3cff						DMARK "MI1" 
3cff f5				push af  
3d00 3a 14 3d			ld a, (.dmark)  
3d03 32 68 fe			ld (debug_mark),a  
3d06 3a 15 3d			ld a, (.dmark+1)  
3d09 32 69 fe			ld (debug_mark+1),a  
3d0c 3a 16 3d			ld a, (.dmark+2)  
3d0f 32 6a fe			ld (debug_mark+2),a  
3d12 18 03			jr .pastdmark  
3d14 ..			.dmark: db "MI1"  
3d17 f1			.pastdmark: pop af  
3d18			endm  
# End of macro DMARK
3d18						CALLMONITOR 
3d18 cd 6c fe			call debug_vector  
3d1b				endm  
# End of macro CALLMONITOR
3d1b					endif 
3d1b cd 05 21				call forth_push_numhl 
3d1e			 
3d1e				       NEXTW 
3d1e c3 b2 24			jp macro_next 
3d21				endm 
# End of macro NEXTW
3d21			.MAX: 
3d21				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3d21 4a				db WORD_SYS_CORE+54             
3d22 a2 3d			dw .RND16            
3d24 04				db 3 + 1 
3d25 .. 00			db "MAX",0              
3d29				endm 
# End of macro CWHEAD
3d29			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3d29					if DEBUG_FORTH_WORDS_KEY 
3d29						DMARK "MAX" 
3d29 f5				push af  
3d2a 3a 3e 3d			ld a, (.dmark)  
3d2d 32 68 fe			ld (debug_mark),a  
3d30 3a 3f 3d			ld a, (.dmark+1)  
3d33 32 69 fe			ld (debug_mark+1),a  
3d36 3a 40 3d			ld a, (.dmark+2)  
3d39 32 6a fe			ld (debug_mark+2),a  
3d3c 18 03			jr .pastdmark  
3d3e ..			.dmark: db "MAX"  
3d41 f1			.pastdmark: pop af  
3d42			endm  
# End of macro DMARK
3d42						CALLMONITOR 
3d42 cd 6c fe			call debug_vector  
3d45				endm  
# End of macro CALLMONITOR
3d45					endif 
3d45					; get u2 
3d45			 
3d45					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d45 cd fc 22			call macro_dsp_valuehl 
3d48				endm 
# End of macro FORTH_DSP_VALUEHL
3d48			 
3d48 e5					push hl   ; u2 
3d49			 
3d49					; destroy value TOS 
3d49			 
3d49					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d49 cd b4 23			call macro_forth_dsp_pop 
3d4c				endm 
# End of macro FORTH_DSP_POP
3d4c			 
3d4c					; get u1 
3d4c			 
3d4c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d4c cd fc 22			call macro_dsp_valuehl 
3d4f				endm 
# End of macro FORTH_DSP_VALUEHL
3d4f			 
3d4f e5					push hl  ; u1 
3d50			 
3d50					; destroy value TOS 
3d50			 
3d50					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d50 cd b4 23			call macro_forth_dsp_pop 
3d53				endm 
# End of macro FORTH_DSP_POP
3d53			 
3d53 b7			 or a      ;clear carry flag 
3d54 e1			  pop hl    ; u1 
3d55 d1			  pop de    ; u2 
3d56 e5				push hl   ; saved in case hl is lowest 
3d57 ed 52		  sbc hl,de 
3d59 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3d5b			 
3d5b e1				pop hl 
3d5c					if DEBUG_FORTH_WORDS 
3d5c						DMARK "MAX" 
3d5c f5				push af  
3d5d 3a 71 3d			ld a, (.dmark)  
3d60 32 68 fe			ld (debug_mark),a  
3d63 3a 72 3d			ld a, (.dmark+1)  
3d66 32 69 fe			ld (debug_mark+1),a  
3d69 3a 73 3d			ld a, (.dmark+2)  
3d6c 32 6a fe			ld (debug_mark+2),a  
3d6f 18 03			jr .pastdmark  
3d71 ..			.dmark: db "MAX"  
3d74 f1			.pastdmark: pop af  
3d75			endm  
# End of macro DMARK
3d75						CALLMONITOR 
3d75 cd 6c fe			call debug_vector  
3d78				endm  
# End of macro CALLMONITOR
3d78					endif 
3d78 cd 05 21				call forth_push_numhl 
3d7b			 
3d7b				       NEXTW 
3d7b c3 b2 24			jp macro_next 
3d7e				endm 
# End of macro NEXTW
3d7e			 
3d7e			.maxcont:  
3d7e c1				pop bc   ; tidy up 
3d7f eb				ex de , hl  
3d80					if DEBUG_FORTH_WORDS 
3d80						DMARK "MA1" 
3d80 f5				push af  
3d81 3a 95 3d			ld a, (.dmark)  
3d84 32 68 fe			ld (debug_mark),a  
3d87 3a 96 3d			ld a, (.dmark+1)  
3d8a 32 69 fe			ld (debug_mark+1),a  
3d8d 3a 97 3d			ld a, (.dmark+2)  
3d90 32 6a fe			ld (debug_mark+2),a  
3d93 18 03			jr .pastdmark  
3d95 ..			.dmark: db "MA1"  
3d98 f1			.pastdmark: pop af  
3d99			endm  
# End of macro DMARK
3d99						CALLMONITOR 
3d99 cd 6c fe			call debug_vector  
3d9c				endm  
# End of macro CALLMONITOR
3d9c					endif 
3d9c cd 05 21				call forth_push_numhl 
3d9f				       NEXTW 
3d9f c3 b2 24			jp macro_next 
3da2				endm 
# End of macro NEXTW
3da2			 
3da2			.RND16: 
3da2				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3da2 4e				db WORD_SYS_CORE+58             
3da3 d1 3d			dw .RND8            
3da5 06				db 5 + 1 
3da6 .. 00			db "RND16",0              
3dac				endm 
# End of macro CWHEAD
3dac			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3dac					if DEBUG_FORTH_WORDS_KEY 
3dac						DMARK "R16" 
3dac f5				push af  
3dad 3a c1 3d			ld a, (.dmark)  
3db0 32 68 fe			ld (debug_mark),a  
3db3 3a c2 3d			ld a, (.dmark+1)  
3db6 32 69 fe			ld (debug_mark+1),a  
3db9 3a c3 3d			ld a, (.dmark+2)  
3dbc 32 6a fe			ld (debug_mark+2),a  
3dbf 18 03			jr .pastdmark  
3dc1 ..			.dmark: db "R16"  
3dc4 f1			.pastdmark: pop af  
3dc5			endm  
# End of macro DMARK
3dc5						CALLMONITOR 
3dc5 cd 6c fe			call debug_vector  
3dc8				endm  
# End of macro CALLMONITOR
3dc8					endif 
3dc8 cd f7 0e				call prng16  
3dcb cd 05 21				call forth_push_numhl 
3dce				       NEXTW 
3dce c3 b2 24			jp macro_next 
3dd1				endm 
# End of macro NEXTW
3dd1			.RND8: 
3dd1				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3dd1 60				db WORD_SYS_CORE+76             
3dd2 06 3e			dw .RND            
3dd4 05				db 4 + 1 
3dd5 .. 00			db "RND8",0              
3dda				endm 
# End of macro CWHEAD
3dda			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3dda					if DEBUG_FORTH_WORDS_KEY 
3dda						DMARK "RN8" 
3dda f5				push af  
3ddb 3a ef 3d			ld a, (.dmark)  
3dde 32 68 fe			ld (debug_mark),a  
3de1 3a f0 3d			ld a, (.dmark+1)  
3de4 32 69 fe			ld (debug_mark+1),a  
3de7 3a f1 3d			ld a, (.dmark+2)  
3dea 32 6a fe			ld (debug_mark+2),a  
3ded 18 03			jr .pastdmark  
3def ..			.dmark: db "RN8"  
3df2 f1			.pastdmark: pop af  
3df3			endm  
# End of macro DMARK
3df3						CALLMONITOR 
3df3 cd 6c fe			call debug_vector  
3df6				endm  
# End of macro CALLMONITOR
3df6					endif 
3df6 2a a6 fb				ld hl,(xrandc) 
3df9 23					inc hl 
3dfa cd 11 0f				call xrnd 
3dfd 6f					ld l,a	 
3dfe 26 00				ld h,0 
3e00 cd 05 21				call forth_push_numhl 
3e03				       NEXTW 
3e03 c3 b2 24			jp macro_next 
3e06				endm 
# End of macro NEXTW
3e06			.RND: 
3e06				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3e06 60				db WORD_SYS_CORE+76             
3e07 0c 3f			dw .ENDMATHS            
3e09 04				db 3 + 1 
3e0a .. 00			db "RND",0              
3e0e				endm 
# End of macro CWHEAD
3e0e			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3e0e			 
3e0e					if DEBUG_FORTH_WORDS_KEY 
3e0e						DMARK "RND" 
3e0e f5				push af  
3e0f 3a 23 3e			ld a, (.dmark)  
3e12 32 68 fe			ld (debug_mark),a  
3e15 3a 24 3e			ld a, (.dmark+1)  
3e18 32 69 fe			ld (debug_mark+1),a  
3e1b 3a 25 3e			ld a, (.dmark+2)  
3e1e 32 6a fe			ld (debug_mark+2),a  
3e21 18 03			jr .pastdmark  
3e23 ..			.dmark: db "RND"  
3e26 f1			.pastdmark: pop af  
3e27			endm  
# End of macro DMARK
3e27						CALLMONITOR 
3e27 cd 6c fe			call debug_vector  
3e2a				endm  
# End of macro CALLMONITOR
3e2a					endif 
3e2a					 
3e2a					FORTH_DSP_VALUEHL    ; upper range 
3e2a cd fc 22			call macro_dsp_valuehl 
3e2d				endm 
# End of macro FORTH_DSP_VALUEHL
3e2d			 
3e2d 22 aa fb				ld (LFSRSeed), hl	 
3e30			 
3e30					if DEBUG_FORTH_WORDS 
3e30						DMARK "RN1" 
3e30 f5				push af  
3e31 3a 45 3e			ld a, (.dmark)  
3e34 32 68 fe			ld (debug_mark),a  
3e37 3a 46 3e			ld a, (.dmark+1)  
3e3a 32 69 fe			ld (debug_mark+1),a  
3e3d 3a 47 3e			ld a, (.dmark+2)  
3e40 32 6a fe			ld (debug_mark+2),a  
3e43 18 03			jr .pastdmark  
3e45 ..			.dmark: db "RN1"  
3e48 f1			.pastdmark: pop af  
3e49			endm  
# End of macro DMARK
3e49						CALLMONITOR 
3e49 cd 6c fe			call debug_vector  
3e4c				endm  
# End of macro CALLMONITOR
3e4c					endif 
3e4c					FORTH_DSP_POP 
3e4c cd b4 23			call macro_forth_dsp_pop 
3e4f				endm 
# End of macro FORTH_DSP_POP
3e4f			 
3e4f					FORTH_DSP_VALUEHL    ; low range 
3e4f cd fc 22			call macro_dsp_valuehl 
3e52				endm 
# End of macro FORTH_DSP_VALUEHL
3e52			 
3e52					if DEBUG_FORTH_WORDS 
3e52						DMARK "RN2" 
3e52 f5				push af  
3e53 3a 67 3e			ld a, (.dmark)  
3e56 32 68 fe			ld (debug_mark),a  
3e59 3a 68 3e			ld a, (.dmark+1)  
3e5c 32 69 fe			ld (debug_mark+1),a  
3e5f 3a 69 3e			ld a, (.dmark+2)  
3e62 32 6a fe			ld (debug_mark+2),a  
3e65 18 03			jr .pastdmark  
3e67 ..			.dmark: db "RN2"  
3e6a f1			.pastdmark: pop af  
3e6b			endm  
# End of macro DMARK
3e6b						CALLMONITOR 
3e6b cd 6c fe			call debug_vector  
3e6e				endm  
# End of macro CALLMONITOR
3e6e					endif 
3e6e 22 ac fb				ld (LFSRSeed+2), hl 
3e71			 
3e71					FORTH_DSP_POP 
3e71 cd b4 23			call macro_forth_dsp_pop 
3e74				endm 
# End of macro FORTH_DSP_POP
3e74			 
3e74 e5					push hl 
3e75			 
3e75 e1			.inrange:	pop hl 
3e76 cd f7 0e				call prng16  
3e79					if DEBUG_FORTH_WORDS 
3e79						DMARK "RN3" 
3e79 f5				push af  
3e7a 3a 8e 3e			ld a, (.dmark)  
3e7d 32 68 fe			ld (debug_mark),a  
3e80 3a 8f 3e			ld a, (.dmark+1)  
3e83 32 69 fe			ld (debug_mark+1),a  
3e86 3a 90 3e			ld a, (.dmark+2)  
3e89 32 6a fe			ld (debug_mark+2),a  
3e8c 18 03			jr .pastdmark  
3e8e ..			.dmark: db "RN3"  
3e91 f1			.pastdmark: pop af  
3e92			endm  
# End of macro DMARK
3e92						CALLMONITOR 
3e92 cd 6c fe			call debug_vector  
3e95				endm  
# End of macro CALLMONITOR
3e95					endif 
3e95					 
3e95					; if the range is 8bit knock out the high byte 
3e95			 
3e95 ed 5b aa fb			ld de, (LFSRSeed)     ; check high level 
3e99			 
3e99 3e 00				ld a, 0 
3e9b ba					cp d  
3e9c 20 1e				jr nz, .hirange 
3e9e 26 00				ld h, 0   ; knock it down to 8bit 
3ea0			 
3ea0					if DEBUG_FORTH_WORDS 
3ea0						DMARK "RNk" 
3ea0 f5				push af  
3ea1 3a b5 3e			ld a, (.dmark)  
3ea4 32 68 fe			ld (debug_mark),a  
3ea7 3a b6 3e			ld a, (.dmark+1)  
3eaa 32 69 fe			ld (debug_mark+1),a  
3ead 3a b7 3e			ld a, (.dmark+2)  
3eb0 32 6a fe			ld (debug_mark+2),a  
3eb3 18 03			jr .pastdmark  
3eb5 ..			.dmark: db "RNk"  
3eb8 f1			.pastdmark: pop af  
3eb9			endm  
# End of macro DMARK
3eb9						CALLMONITOR 
3eb9 cd 6c fe			call debug_vector  
3ebc				endm  
# End of macro CALLMONITOR
3ebc					endif 
3ebc			.hirange:   
3ebc e5					push hl  
3ebd b7					or a  
3ebe ed 52		                sbc hl, de 
3ec0			 
3ec0					;call cmp16 
3ec0			 
3ec0 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3ec2 e1					pop hl 
3ec3 e5					push hl 
3ec4			 
3ec4					if DEBUG_FORTH_WORDS 
3ec4						DMARK "RN4" 
3ec4 f5				push af  
3ec5 3a d9 3e			ld a, (.dmark)  
3ec8 32 68 fe			ld (debug_mark),a  
3ecb 3a da 3e			ld a, (.dmark+1)  
3ece 32 69 fe			ld (debug_mark+1),a  
3ed1 3a db 3e			ld a, (.dmark+2)  
3ed4 32 6a fe			ld (debug_mark+2),a  
3ed7 18 03			jr .pastdmark  
3ed9 ..			.dmark: db "RN4"  
3edc f1			.pastdmark: pop af  
3edd			endm  
# End of macro DMARK
3edd						CALLMONITOR 
3edd cd 6c fe			call debug_vector  
3ee0				endm  
# End of macro CALLMONITOR
3ee0					endif 
3ee0 ed 5b ac fb			ld de, (LFSRSeed+2)   ; check low range 
3ee4					;call cmp16 
3ee4				 
3ee4 b7					or a  
3ee5 ed 52		                sbc hl, de 
3ee7 38 8c				jr c, .inrange 
3ee9			 
3ee9 e1					pop hl 
3eea					 
3eea					if DEBUG_FORTH_WORDS 
3eea						DMARK "RNd" 
3eea f5				push af  
3eeb 3a ff 3e			ld a, (.dmark)  
3eee 32 68 fe			ld (debug_mark),a  
3ef1 3a 00 3f			ld a, (.dmark+1)  
3ef4 32 69 fe			ld (debug_mark+1),a  
3ef7 3a 01 3f			ld a, (.dmark+2)  
3efa 32 6a fe			ld (debug_mark+2),a  
3efd 18 03			jr .pastdmark  
3eff ..			.dmark: db "RNd"  
3f02 f1			.pastdmark: pop af  
3f03			endm  
# End of macro DMARK
3f03						CALLMONITOR 
3f03 cd 6c fe			call debug_vector  
3f06				endm  
# End of macro CALLMONITOR
3f06					endif 
3f06			 
3f06			 
3f06 cd 05 21				call forth_push_numhl 
3f09				       NEXTW 
3f09 c3 b2 24			jp macro_next 
3f0c				endm 
# End of macro NEXTW
3f0c			 
3f0c			.ENDMATHS: 
3f0c			 
3f0c			; eof 
3f0c			 
# End of file forth_words_maths.asm
3f0c			include "forth_words_display.asm" 
3f0c			 
3f0c			; | ## Display Words 
3f0c			 
3f0c			.ACT: 
3f0c			 
3f0c				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3f0c 62				db WORD_SYS_CORE+78             
3f0d 58 3f			dw .INFO            
3f0f 07				db 6 + 1 
3f10 .. 00			db "ACTIVE",0              
3f17				endm 
# End of macro CWHEAD
3f17			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3f17			;  
3f17			; | | e.g. $ff $00 do active . $01 pause loop 
3f17			 
3f17					if DEBUG_FORTH_WORDS_KEY 
3f17						DMARK "ACT" 
3f17 f5				push af  
3f18 3a 2c 3f			ld a, (.dmark)  
3f1b 32 68 fe			ld (debug_mark),a  
3f1e 3a 2d 3f			ld a, (.dmark+1)  
3f21 32 69 fe			ld (debug_mark+1),a  
3f24 3a 2e 3f			ld a, (.dmark+2)  
3f27 32 6a fe			ld (debug_mark+2),a  
3f2a 18 03			jr .pastdmark  
3f2c ..			.dmark: db "ACT"  
3f2f f1			.pastdmark: pop af  
3f30			endm  
# End of macro DMARK
3f30						CALLMONITOR 
3f30 cd 6c fe			call debug_vector  
3f33				endm  
# End of macro CALLMONITOR
3f33					endif 
3f33 cd f3 0c				call active 
3f36					if DEBUG_FORTH_WORDS 
3f36						DMARK "ACp" 
3f36 f5				push af  
3f37 3a 4b 3f			ld a, (.dmark)  
3f3a 32 68 fe			ld (debug_mark),a  
3f3d 3a 4c 3f			ld a, (.dmark+1)  
3f40 32 69 fe			ld (debug_mark+1),a  
3f43 3a 4d 3f			ld a, (.dmark+2)  
3f46 32 6a fe			ld (debug_mark+2),a  
3f49 18 03			jr .pastdmark  
3f4b ..			.dmark: db "ACp"  
3f4e f1			.pastdmark: pop af  
3f4f			endm  
# End of macro DMARK
3f4f						CALLMONITOR 
3f4f cd 6c fe			call debug_vector  
3f52				endm  
# End of macro CALLMONITOR
3f52					endif 
3f52 cd 73 21				call forth_push_str 
3f55			 
3f55					NEXTW 
3f55 c3 b2 24			jp macro_next 
3f58				endm 
# End of macro NEXTW
3f58			.INFO: 
3f58			 
3f58				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3f58 62				db WORD_SYS_CORE+78             
3f59 75 3f			dw .ATP            
3f5b 05				db 4 + 1 
3f5c .. 00			db "INFO",0              
3f61				endm 
# End of macro CWHEAD
3f61			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3f61					FORTH_DSP_VALUEHL 
3f61 cd fc 22			call macro_dsp_valuehl 
3f64				endm 
# End of macro FORTH_DSP_VALUEHL
3f64			 
3f64					FORTH_DSP_POP 
3f64 cd b4 23			call macro_forth_dsp_pop 
3f67				endm 
# End of macro FORTH_DSP_POP
3f67			 
3f67 e5					push hl 
3f68			 
3f68					FORTH_DSP_VALUEHL 
3f68 cd fc 22			call macro_dsp_valuehl 
3f6b				endm 
# End of macro FORTH_DSP_VALUEHL
3f6b			 
3f6b					FORTH_DSP_POP 
3f6b cd b4 23			call macro_forth_dsp_pop 
3f6e				endm 
# End of macro FORTH_DSP_POP
3f6e			 
3f6e d1					pop de 
3f6f			 
3f6f cd 2d 0d				call info_panel 
3f72			 
3f72			 
3f72					NEXTW 
3f72 c3 b2 24			jp macro_next 
3f75				endm 
# End of macro NEXTW
3f75			.ATP: 
3f75				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3f75 62				db WORD_SYS_CORE+78             
3f76 ec 3f			dw .FB            
3f78 04				db 3 + 1 
3f79 .. 00			db "AT?",0              
3f7d				endm 
# End of macro CWHEAD
3f7d			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3f7d					if DEBUG_FORTH_WORDS_KEY 
3f7d						DMARK "AT?" 
3f7d f5				push af  
3f7e 3a 92 3f			ld a, (.dmark)  
3f81 32 68 fe			ld (debug_mark),a  
3f84 3a 93 3f			ld a, (.dmark+1)  
3f87 32 69 fe			ld (debug_mark+1),a  
3f8a 3a 94 3f			ld a, (.dmark+2)  
3f8d 32 6a fe			ld (debug_mark+2),a  
3f90 18 03			jr .pastdmark  
3f92 ..			.dmark: db "AT?"  
3f95 f1			.pastdmark: pop af  
3f96			endm  
# End of macro DMARK
3f96						CALLMONITOR 
3f96 cd 6c fe			call debug_vector  
3f99				endm  
# End of macro CALLMONITOR
3f99					endif 
3f99 3a 5b fa				ld a, (f_cursor_ptr) 
3f9c			 
3f9c			if DEBUG_FORTH_WORDS 
3f9c				DMARK "AT?" 
3f9c f5				push af  
3f9d 3a b1 3f			ld a, (.dmark)  
3fa0 32 68 fe			ld (debug_mark),a  
3fa3 3a b2 3f			ld a, (.dmark+1)  
3fa6 32 69 fe			ld (debug_mark+1),a  
3fa9 3a b3 3f			ld a, (.dmark+2)  
3fac 32 6a fe			ld (debug_mark+2),a  
3faf 18 03			jr .pastdmark  
3fb1 ..			.dmark: db "AT?"  
3fb4 f1			.pastdmark: pop af  
3fb5			endm  
# End of macro DMARK
3fb5				CALLMONITOR 
3fb5 cd 6c fe			call debug_vector  
3fb8				endm  
# End of macro CALLMONITOR
3fb8			endif	 
3fb8					; count the number of rows 
3fb8			 
3fb8 06 00				ld b, 0 
3fba 4f			.atpr:		ld c, a    ; save in case we go below zero 
3fbb d6 28				sub display_cols 
3fbd f2 c3 3f				jp p, .atprunder 
3fc0 04					inc b 
3fc1 18 f7				jr .atpr 
3fc3			.atprunder:	 
3fc3			if DEBUG_FORTH_WORDS 
3fc3				DMARK "A?2" 
3fc3 f5				push af  
3fc4 3a d8 3f			ld a, (.dmark)  
3fc7 32 68 fe			ld (debug_mark),a  
3fca 3a d9 3f			ld a, (.dmark+1)  
3fcd 32 69 fe			ld (debug_mark+1),a  
3fd0 3a da 3f			ld a, (.dmark+2)  
3fd3 32 6a fe			ld (debug_mark+2),a  
3fd6 18 03			jr .pastdmark  
3fd8 ..			.dmark: db "A?2"  
3fdb f1			.pastdmark: pop af  
3fdc			endm  
# End of macro DMARK
3fdc				CALLMONITOR 
3fdc cd 6c fe			call debug_vector  
3fdf				endm  
# End of macro CALLMONITOR
3fdf			endif	 
3fdf 26 00				ld h, 0 
3fe1 69					ld l, c 
3fe2 cd 05 21				call forth_push_numhl 
3fe5 68					ld l, b  
3fe6 cd 05 21				call forth_push_numhl 
3fe9			 
3fe9			 
3fe9				NEXTW 
3fe9 c3 b2 24			jp macro_next 
3fec				endm 
# End of macro NEXTW
3fec			 
3fec			.FB: 
3fec				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3fec 1b				db WORD_SYS_CORE+7             
3fed 3a 40			dw .EMIT            
3fef 03				db 2 + 1 
3ff0 .. 00			db "FB",0              
3ff3				endm 
# End of macro CWHEAD
3ff3			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3ff3			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3ff3			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3ff3			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3ff3					if DEBUG_FORTH_WORDS_KEY 
3ff3						DMARK "FB." 
3ff3 f5				push af  
3ff4 3a 08 40			ld a, (.dmark)  
3ff7 32 68 fe			ld (debug_mark),a  
3ffa 3a 09 40			ld a, (.dmark+1)  
3ffd 32 69 fe			ld (debug_mark+1),a  
4000 3a 0a 40			ld a, (.dmark+2)  
4003 32 6a fe			ld (debug_mark+2),a  
4006 18 03			jr .pastdmark  
4008 ..			.dmark: db "FB."  
400b f1			.pastdmark: pop af  
400c			endm  
# End of macro DMARK
400c						CALLMONITOR 
400c cd 6c fe			call debug_vector  
400f				endm  
# End of macro CALLMONITOR
400f					endif 
400f			 
400f					FORTH_DSP_VALUEHL 
400f cd fc 22			call macro_dsp_valuehl 
4012				endm 
# End of macro FORTH_DSP_VALUEHL
4012			 
4012 7d					ld a, l 
4013 fe 01				cp 1 
4015 20 05				jr nz, .fbn1 
4017 21 0d fd				ld hl, display_fb1 
401a 18 15				jr .fbset 
401c fe 02		.fbn1:		cp 2 
401e 20 05				jr nz, .fbn2 
4020 21 cb fb				ld hl, display_fb2 
4023 18 0c				jr .fbset 
4025 fe 03		.fbn2:		cp 3 
4027 20 05				jr nz, .fbn3 
4029 21 6c fc				ld hl, display_fb3 
402c 18 03				jr .fbset 
402e			.fbn3:		 ; if invalid number select first 
402e 21 0d fd				ld hl, display_fb1 
4031 22 c9 fb		.fbset:		ld (display_fb_active), hl 
4034			 
4034					FORTH_DSP_POP 
4034 cd b4 23			call macro_forth_dsp_pop 
4037				endm 
# End of macro FORTH_DSP_POP
4037			 
4037					NEXTW 
4037 c3 b2 24			jp macro_next 
403a				endm 
# End of macro NEXTW
403a			 
403a			 
403a			.EMIT: 
403a				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
403a 1b				db WORD_SYS_CORE+7             
403b 8b 40			dw .DOTH            
403d 05				db 4 + 1 
403e .. 00			db "EMIT",0              
4043				endm 
# End of macro CWHEAD
4043			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
4043					; get value off TOS and display it 
4043			 
4043					if DEBUG_FORTH_WORDS_KEY 
4043						DMARK "EMT" 
4043 f5				push af  
4044 3a 58 40			ld a, (.dmark)  
4047 32 68 fe			ld (debug_mark),a  
404a 3a 59 40			ld a, (.dmark+1)  
404d 32 69 fe			ld (debug_mark+1),a  
4050 3a 5a 40			ld a, (.dmark+2)  
4053 32 6a fe			ld (debug_mark+2),a  
4056 18 03			jr .pastdmark  
4058 ..			.dmark: db "EMT"  
405b f1			.pastdmark: pop af  
405c			endm  
# End of macro DMARK
405c						CALLMONITOR 
405c cd 6c fe			call debug_vector  
405f				endm  
# End of macro CALLMONITOR
405f					endif 
405f			 
405f					FORTH_DSP_VALUEHL 
405f cd fc 22			call macro_dsp_valuehl 
4062				endm 
# End of macro FORTH_DSP_VALUEHL
4062			 
4062 7d					ld a,l 
4063			 
4063					; TODO write to display 
4063			 
4063 32 bc f3				ld (os_input), a 
4066 3e 00				ld a, 0 
4068 32 bd f3				ld (os_input+1), a 
406b					 
406b 3a 5b fa				ld a, (f_cursor_ptr) 
406e 11 bc f3				ld de, os_input 
4071 cd af 0d				call str_at_display 
4074			 
4074			 
4074 3a 39 fa				ld a,(cli_autodisplay) 
4077 fe 00				cp 0 
4079 28 03				jr z, .enoupdate 
407b cd bf 0d						call update_display 
407e					.enoupdate: 
407e			 
407e 3a 5b fa				ld a, (f_cursor_ptr) 
4081 3c					inc a 
4082 32 5b fa				ld (f_cursor_ptr), a   ; save new pos 
4085			 
4085			 
4085					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4085 cd b4 23			call macro_forth_dsp_pop 
4088				endm 
# End of macro FORTH_DSP_POP
4088			  
4088			 
4088					NEXTW 
4088 c3 b2 24			jp macro_next 
408b				endm 
# End of macro NEXTW
408b			.DOTH: 
408b				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
408b 1c				db WORD_SYS_CORE+8             
408c bb 40			dw .DOTF            
408e 03				db 2 + 1 
408f .. 00			db ".-",0              
4092				endm 
# End of macro CWHEAD
4092			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
4092					; get value off TOS and display it 
4092					if DEBUG_FORTH_WORDS_KEY 
4092						DMARK "DTD" 
4092 f5				push af  
4093 3a a7 40			ld a, (.dmark)  
4096 32 68 fe			ld (debug_mark),a  
4099 3a a8 40			ld a, (.dmark+1)  
409c 32 69 fe			ld (debug_mark+1),a  
409f 3a a9 40			ld a, (.dmark+2)  
40a2 32 6a fe			ld (debug_mark+2),a  
40a5 18 03			jr .pastdmark  
40a7 ..			.dmark: db "DTD"  
40aa f1			.pastdmark: pop af  
40ab			endm  
# End of macro DMARK
40ab						CALLMONITOR 
40ab cd 6c fe			call debug_vector  
40ae				endm  
# End of macro CALLMONITOR
40ae					endif 
40ae 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
40b0 3e 00			ld a, 0 
40b2 32 3a fa			ld (cli_mvdot), a 
40b5 c3 12 41			jp .dotgo 
40b8				NEXTW 
40b8 c3 b2 24			jp macro_next 
40bb				endm 
# End of macro NEXTW
40bb			.DOTF: 
40bb				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
40bb 1c				db WORD_SYS_CORE+8             
40bc e9 40			dw .DOT            
40be 03				db 2 + 1 
40bf .. 00			db ".>",0              
40c2				endm 
# End of macro CWHEAD
40c2			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
40c2					; get value off TOS and display it 
40c2			        ; TODO BUG adds extra spaces 
40c2			        ; TODO BUG handle numerics? 
40c2					if DEBUG_FORTH_WORDS_KEY 
40c2						DMARK "DTC" 
40c2 f5				push af  
40c3 3a d7 40			ld a, (.dmark)  
40c6 32 68 fe			ld (debug_mark),a  
40c9 3a d8 40			ld a, (.dmark+1)  
40cc 32 69 fe			ld (debug_mark+1),a  
40cf 3a d9 40			ld a, (.dmark+2)  
40d2 32 6a fe			ld (debug_mark+2),a  
40d5 18 03			jr .pastdmark  
40d7 ..			.dmark: db "DTC"  
40da f1			.pastdmark: pop af  
40db			endm  
# End of macro DMARK
40db						CALLMONITOR 
40db cd 6c fe			call debug_vector  
40de				endm  
# End of macro CALLMONITOR
40de					endif 
40de 3e 01			ld a, 1 
40e0 32 3a fa			ld (cli_mvdot), a 
40e3 c3 12 41			jp .dotgo 
40e6				NEXTW 
40e6 c3 b2 24			jp macro_next 
40e9				endm 
# End of macro NEXTW
40e9			 
40e9			.DOT: 
40e9				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
40e9 1c				db WORD_SYS_CORE+8             
40ea c5 42			dw .CLS            
40ec 02				db 1 + 1 
40ed .. 00			db ".",0              
40ef				endm 
# End of macro CWHEAD
40ef			        ; | . ( u -- ) Display TOS | DONE 
40ef					; get value off TOS and display it 
40ef			 
40ef					if DEBUG_FORTH_WORDS_KEY 
40ef						DMARK "DOT" 
40ef f5				push af  
40f0 3a 04 41			ld a, (.dmark)  
40f3 32 68 fe			ld (debug_mark),a  
40f6 3a 05 41			ld a, (.dmark+1)  
40f9 32 69 fe			ld (debug_mark+1),a  
40fc 3a 06 41			ld a, (.dmark+2)  
40ff 32 6a fe			ld (debug_mark+2),a  
4102 18 03			jr .pastdmark  
4104 ..			.dmark: db "DOT"  
4107 f1			.pastdmark: pop af  
4108			endm  
# End of macro DMARK
4108						CALLMONITOR 
4108 cd 6c fe			call debug_vector  
410b				endm  
# End of macro CALLMONITOR
410b					endif 
410b 3e 00			ld a, 0 
410d 32 3a fa			ld (cli_mvdot), a 
4110 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
4112				 
4112			 
4112			.dotgo: 
4112			 
4112			; move up type to on stack for parserv5 
4112					FORTH_DSP 
4112 cd c2 22			call macro_forth_dsp 
4115				endm 
# End of macro FORTH_DSP
4115				;FORTH_DSP_VALUE  
4115			 
4115			if DEBUG_FORTH_DOT 
4115				DMARK "DOT" 
4115 f5				push af  
4116 3a 2a 41			ld a, (.dmark)  
4119 32 68 fe			ld (debug_mark),a  
411c 3a 2b 41			ld a, (.dmark+1)  
411f 32 69 fe			ld (debug_mark+1),a  
4122 3a 2c 41			ld a, (.dmark+2)  
4125 32 6a fe			ld (debug_mark+2),a  
4128 18 03			jr .pastdmark  
412a ..			.dmark: db "DOT"  
412d f1			.pastdmark: pop af  
412e			endm  
# End of macro DMARK
412e				CALLMONITOR 
412e cd 6c fe			call debug_vector  
4131				endm  
# End of macro CALLMONITOR
4131			endif	 
4131			;		.print: 
4131			 
4131 7e				ld a,(hl)  ; work out what type of value is on the TOS 
4132 23				inc hl   ; position to the actual value 
4133 fe 01			cp DS_TYPE_STR 
4135 20 06			jr nz, .dotnum1  
4137			 
4137			; display string 
4137				FORTH_DSP_VALUE  
4137 cd e5 22			call macro_forth_dsp_value 
413a				endm 
# End of macro FORTH_DSP_VALUE
413a eb				ex de,hl 
413b 18 49			jr .dotwrite 
413d			 
413d			.dotnum1: 
413d fe 02			cp DS_TYPE_INUM 
413f 20 44			jr nz, .dotflot 
4141			 
4141			 
4141			; display number 
4141			 
4141			;	push hl 
4141			;	call clear_display 
4141			;	pop hl 
4141			 
4141 5e				ld e, (hl) 
4142 23				inc hl 
4143 56				ld d, (hl) 
4144 21 be f1			ld hl, scratch 
4147			if DEBUG_FORTH_DOT 
4147				DMARK "DT1" 
4147 f5				push af  
4148 3a 5c 41			ld a, (.dmark)  
414b 32 68 fe			ld (debug_mark),a  
414e 3a 5d 41			ld a, (.dmark+1)  
4151 32 69 fe			ld (debug_mark+1),a  
4154 3a 5e 41			ld a, (.dmark+2)  
4157 32 6a fe			ld (debug_mark+2),a  
415a 18 03			jr .pastdmark  
415c ..			.dmark: db "DT1"  
415f f1			.pastdmark: pop af  
4160			endm  
# End of macro DMARK
4160				CALLMONITOR 
4160 cd 6c fe			call debug_vector  
4163				endm  
# End of macro CALLMONITOR
4163			endif	 
4163			 
4163 cd dd 13			call uitoa_16 
4166 eb				ex de,hl 
4167			 
4167			if DEBUG_FORTH_DOT 
4167				DMARK "DT2" 
4167 f5				push af  
4168 3a 7c 41			ld a, (.dmark)  
416b 32 68 fe			ld (debug_mark),a  
416e 3a 7d 41			ld a, (.dmark+1)  
4171 32 69 fe			ld (debug_mark+1),a  
4174 3a 7e 41			ld a, (.dmark+2)  
4177 32 6a fe			ld (debug_mark+2),a  
417a 18 03			jr .pastdmark  
417c ..			.dmark: db "DT2"  
417f f1			.pastdmark: pop af  
4180			endm  
# End of macro DMARK
4180				CALLMONITOR 
4180 cd 6c fe			call debug_vector  
4183				endm  
# End of macro CALLMONITOR
4183			endif	 
4183			 
4183			;	ld de, os_word_scratch 
4183 18 01			jr .dotwrite 
4185			 
4185 00			.dotflot:   nop 
4186			; TODO print floating point number 
4186			 
4186			.dotwrite:		 
4186			 
4186					; if c is set then set all '-' to spaces 
4186					; need to also take into account .>  
4186			 
4186 3e 01				ld a, 1 
4188 b9					cp c 
4189 20 67				jr nz, .nodashswap 
418b			 
418b					; DE has the string to write, working with HL 
418b			 
418b 06 ff				ld b, 255 
418d d5					push de 
418e e1					pop hl 
418f			 
418f			if DEBUG_FORTH_DOT 
418f				DMARK "DT-" 
418f f5				push af  
4190 3a a4 41			ld a, (.dmark)  
4193 32 68 fe			ld (debug_mark),a  
4196 3a a5 41			ld a, (.dmark+1)  
4199 32 69 fe			ld (debug_mark+1),a  
419c 3a a6 41			ld a, (.dmark+2)  
419f 32 6a fe			ld (debug_mark+2),a  
41a2 18 03			jr .pastdmark  
41a4 ..			.dmark: db "DT-"  
41a7 f1			.pastdmark: pop af  
41a8			endm  
# End of macro DMARK
41a8				CALLMONITOR 
41a8 cd 6c fe			call debug_vector  
41ab				endm  
# End of macro CALLMONITOR
41ab			endif	 
41ab 7e			.dashscan:	ld a, (hl) 
41ac fe 00				cp 0 
41ae 28 42				jr z, .nodashswap 
41b0 fe 2d				cp '-' 
41b2 20 03				jr nz, .dashskip 
41b4 3e 20				ld a, ' ' 
41b6 77					ld (hl), a 
41b7 23			.dashskip:	inc hl 
41b8			if DEBUG_FORTH_DOT 
41b8				DMARK "D-2" 
41b8 f5				push af  
41b9 3a cd 41			ld a, (.dmark)  
41bc 32 68 fe			ld (debug_mark),a  
41bf 3a ce 41			ld a, (.dmark+1)  
41c2 32 69 fe			ld (debug_mark+1),a  
41c5 3a cf 41			ld a, (.dmark+2)  
41c8 32 6a fe			ld (debug_mark+2),a  
41cb 18 03			jr .pastdmark  
41cd ..			.dmark: db "D-2"  
41d0 f1			.pastdmark: pop af  
41d1			endm  
# End of macro DMARK
41d1				CALLMONITOR 
41d1 cd 6c fe			call debug_vector  
41d4				endm  
# End of macro CALLMONITOR
41d4			endif	 
41d4 10 d5				djnz .dashscan 
41d6			 
41d6			if DEBUG_FORTH_DOT 
41d6				DMARK "D-1" 
41d6 f5				push af  
41d7 3a eb 41			ld a, (.dmark)  
41da 32 68 fe			ld (debug_mark),a  
41dd 3a ec 41			ld a, (.dmark+1)  
41e0 32 69 fe			ld (debug_mark+1),a  
41e3 3a ed 41			ld a, (.dmark+2)  
41e6 32 6a fe			ld (debug_mark+2),a  
41e9 18 03			jr .pastdmark  
41eb ..			.dmark: db "D-1"  
41ee f1			.pastdmark: pop af  
41ef			endm  
# End of macro DMARK
41ef				CALLMONITOR 
41ef cd 6c fe			call debug_vector  
41f2				endm  
# End of macro CALLMONITOR
41f2			endif	 
41f2			 
41f2			.nodashswap: 
41f2			 
41f2			if DEBUG_FORTH_DOT 
41f2				DMARK "D-o" 
41f2 f5				push af  
41f3 3a 07 42			ld a, (.dmark)  
41f6 32 68 fe			ld (debug_mark),a  
41f9 3a 08 42			ld a, (.dmark+1)  
41fc 32 69 fe			ld (debug_mark+1),a  
41ff 3a 09 42			ld a, (.dmark+2)  
4202 32 6a fe			ld (debug_mark+2),a  
4205 18 03			jr .pastdmark  
4207 ..			.dmark: db "D-o"  
420a f1			.pastdmark: pop af  
420b			endm  
# End of macro DMARK
420b				CALLMONITOR 
420b cd 6c fe			call debug_vector  
420e				endm  
# End of macro CALLMONITOR
420e			endif	 
420e			 
420e d5					push de   ; save string start in case we need to advance print 
420f			 
420f 3a 5b fa				ld a, (f_cursor_ptr) 
4212 cd af 0d				call str_at_display 
4215 3a 39 fa				ld a,(cli_autodisplay) 
4218 fe 00				cp 0 
421a 28 03				jr z, .noupdate 
421c cd bf 0d						call update_display 
421f					.noupdate: 
421f			 
421f			 
421f					; see if we need to advance the print position 
421f			 
421f e1					pop hl   ; get back string 
4220			;		ex de,hl 
4220			 
4220 3a 3a fa				ld a, (cli_mvdot) 
4223			if DEBUG_FORTH_DOT 
4223			;		ld e,a 
4223				DMARK "D>1" 
4223 f5				push af  
4224 3a 38 42			ld a, (.dmark)  
4227 32 68 fe			ld (debug_mark),a  
422a 3a 39 42			ld a, (.dmark+1)  
422d 32 69 fe			ld (debug_mark+1),a  
4230 3a 3a 42			ld a, (.dmark+2)  
4233 32 6a fe			ld (debug_mark+2),a  
4236 18 03			jr .pastdmark  
4238 ..			.dmark: db "D>1"  
423b f1			.pastdmark: pop af  
423c			endm  
# End of macro DMARK
423c				CALLMONITOR 
423c cd 6c fe			call debug_vector  
423f				endm  
# End of macro CALLMONITOR
423f			endif	 
423f fe 00				cp 0 
4241 28 44				jr z, .noadv 
4243					; yes, lets advance the print position 
4243 3e 00				ld a, 0 
4245 cd 39 14				call strlent 
4248			if DEBUG_FORTH_DOT 
4248				DMARK "D-?" 
4248 f5				push af  
4249 3a 5d 42			ld a, (.dmark)  
424c 32 68 fe			ld (debug_mark),a  
424f 3a 5e 42			ld a, (.dmark+1)  
4252 32 69 fe			ld (debug_mark+1),a  
4255 3a 5f 42			ld a, (.dmark+2)  
4258 32 6a fe			ld (debug_mark+2),a  
425b 18 03			jr .pastdmark  
425d ..			.dmark: db "D-?"  
4260 f1			.pastdmark: pop af  
4261			endm  
# End of macro DMARK
4261				CALLMONITOR 
4261 cd 6c fe			call debug_vector  
4264				endm  
# End of macro CALLMONITOR
4264			endif	 
4264 3a 5b fa				ld a, (f_cursor_ptr) 
4267 85					add a,l 
4268					;call addatohl 
4268					;ld a, l 
4268 32 5b fa				ld (f_cursor_ptr), a   ; save new pos 
426b			 
426b			if DEBUG_FORTH_DOT 
426b				DMARK "D->" 
426b f5				push af  
426c 3a 80 42			ld a, (.dmark)  
426f 32 68 fe			ld (debug_mark),a  
4272 3a 81 42			ld a, (.dmark+1)  
4275 32 69 fe			ld (debug_mark+1),a  
4278 3a 82 42			ld a, (.dmark+2)  
427b 32 6a fe			ld (debug_mark+2),a  
427e 18 03			jr .pastdmark  
4280 ..			.dmark: db "D->"  
4283 f1			.pastdmark: pop af  
4284			endm  
# End of macro DMARK
4284				CALLMONITOR 
4284 cd 6c fe			call debug_vector  
4287				endm  
# End of macro CALLMONITOR
4287			endif	 
4287			 
4287			.noadv:	 
4287			 
4287					if DEBUG_FORTH_DOT_WAIT 
4287							call next_page_prompt 
4287					endif	 
4287			; TODO this pop off the stack causes a crash. i dont know why 
4287			 
4287			 
4287			if DEBUG_FORTH_DOT 
4287				DMARK "DTh" 
4287 f5				push af  
4288 3a 9c 42			ld a, (.dmark)  
428b 32 68 fe			ld (debug_mark),a  
428e 3a 9d 42			ld a, (.dmark+1)  
4291 32 69 fe			ld (debug_mark+1),a  
4294 3a 9e 42			ld a, (.dmark+2)  
4297 32 6a fe			ld (debug_mark+2),a  
429a 18 03			jr .pastdmark  
429c ..			.dmark: db "DTh"  
429f f1			.pastdmark: pop af  
42a0			endm  
# End of macro DMARK
42a0				CALLMONITOR 
42a0 cd 6c fe			call debug_vector  
42a3				endm  
# End of macro CALLMONITOR
42a3			endif	 
42a3			 
42a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42a3 cd b4 23			call macro_forth_dsp_pop 
42a6				endm 
# End of macro FORTH_DSP_POP
42a6			 
42a6			if DEBUG_FORTH_DOT 
42a6				DMARK "DTi" 
42a6 f5				push af  
42a7 3a bb 42			ld a, (.dmark)  
42aa 32 68 fe			ld (debug_mark),a  
42ad 3a bc 42			ld a, (.dmark+1)  
42b0 32 69 fe			ld (debug_mark+1),a  
42b3 3a bd 42			ld a, (.dmark+2)  
42b6 32 6a fe			ld (debug_mark+2),a  
42b9 18 03			jr .pastdmark  
42bb ..			.dmark: db "DTi"  
42be f1			.pastdmark: pop af  
42bf			endm  
# End of macro DMARK
42bf				CALLMONITOR 
42bf cd 6c fe			call debug_vector  
42c2				endm  
# End of macro CALLMONITOR
42c2			endif	 
42c2			 
42c2			 
42c2					NEXTW 
42c2 c3 b2 24			jp macro_next 
42c5				endm 
# End of macro NEXTW
42c5			 
42c5			.CLS: 
42c5				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
42c5 35				db WORD_SYS_CORE+33             
42c6 f2 42			dw .DRAW            
42c8 04				db 3 + 1 
42c9 .. 00			db "CLS",0              
42cd				endm 
# End of macro CWHEAD
42cd			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
42cd					if DEBUG_FORTH_WORDS_KEY 
42cd						DMARK "CLS" 
42cd f5				push af  
42ce 3a e2 42			ld a, (.dmark)  
42d1 32 68 fe			ld (debug_mark),a  
42d4 3a e3 42			ld a, (.dmark+1)  
42d7 32 69 fe			ld (debug_mark+1),a  
42da 3a e4 42			ld a, (.dmark+2)  
42dd 32 6a fe			ld (debug_mark+2),a  
42e0 18 03			jr .pastdmark  
42e2 ..			.dmark: db "CLS"  
42e5 f1			.pastdmark: pop af  
42e6			endm  
# End of macro DMARK
42e6						CALLMONITOR 
42e6 cd 6c fe			call debug_vector  
42e9				endm  
# End of macro CALLMONITOR
42e9					endif 
42e9 cd 9c 0d				call clear_display 
42ec c3 00 44				jp .home		; and home cursor 
42ef					NEXTW 
42ef c3 b2 24			jp macro_next 
42f2				endm 
# End of macro NEXTW
42f2			 
42f2			.DRAW: 
42f2				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
42f2 36				db WORD_SYS_CORE+34             
42f3 1d 43			dw .DUMP            
42f5 05				db 4 + 1 
42f6 .. 00			db "DRAW",0              
42fb				endm 
# End of macro CWHEAD
42fb			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
42fb					if DEBUG_FORTH_WORDS_KEY 
42fb						DMARK "DRW" 
42fb f5				push af  
42fc 3a 10 43			ld a, (.dmark)  
42ff 32 68 fe			ld (debug_mark),a  
4302 3a 11 43			ld a, (.dmark+1)  
4305 32 69 fe			ld (debug_mark+1),a  
4308 3a 12 43			ld a, (.dmark+2)  
430b 32 6a fe			ld (debug_mark+2),a  
430e 18 03			jr .pastdmark  
4310 ..			.dmark: db "DRW"  
4313 f1			.pastdmark: pop af  
4314			endm  
# End of macro DMARK
4314						CALLMONITOR 
4314 cd 6c fe			call debug_vector  
4317				endm  
# End of macro CALLMONITOR
4317					endif 
4317 cd bf 0d				call update_display 
431a					NEXTW 
431a c3 b2 24			jp macro_next 
431d				endm 
# End of macro NEXTW
431d			 
431d			.DUMP: 
431d				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
431d 37				db WORD_SYS_CORE+35             
431e 55 43			dw .CDUMP            
4320 05				db 4 + 1 
4321 .. 00			db "DUMP",0              
4326				endm 
# End of macro CWHEAD
4326			; | DUMP ( x -- ) With address x display dump   | DONE 
4326			; TODO pop address to use off of the stack 
4326					if DEBUG_FORTH_WORDS_KEY 
4326						DMARK "DUM" 
4326 f5				push af  
4327 3a 3b 43			ld a, (.dmark)  
432a 32 68 fe			ld (debug_mark),a  
432d 3a 3c 43			ld a, (.dmark+1)  
4330 32 69 fe			ld (debug_mark+1),a  
4333 3a 3d 43			ld a, (.dmark+2)  
4336 32 6a fe			ld (debug_mark+2),a  
4339 18 03			jr .pastdmark  
433b ..			.dmark: db "DUM"  
433e f1			.pastdmark: pop af  
433f			endm  
# End of macro DMARK
433f						CALLMONITOR 
433f cd 6c fe			call debug_vector  
4342				endm  
# End of macro CALLMONITOR
4342					endif 
4342 cd 9c 0d				call clear_display 
4345			 
4345					; get address 
4345			 
4345					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4345 cd fc 22			call macro_dsp_valuehl 
4348				endm 
# End of macro FORTH_DSP_VALUEHL
4348				 
4348					; save it for cdump 
4348			 
4348 22 e1 f4				ld (os_cur_ptr),hl 
434b			 
434b					; destroy value TOS 
434b			 
434b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
434b cd b4 23			call macro_forth_dsp_pop 
434e				endm 
# End of macro FORTH_DSP_POP
434e			 
434e cd 85 1f				call dumpcont	; skip old style of param parsing	 
4351 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
4352					NEXTW 
4352 c3 b2 24			jp macro_next 
4355				endm 
# End of macro NEXTW
4355			.CDUMP: 
4355				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
4355 38				db WORD_SYS_CORE+36             
4356 85 43			dw .DAT            
4358 06				db 5 + 1 
4359 .. 00			db "CDUMP",0              
435f				endm 
# End of macro CWHEAD
435f			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
435f					if DEBUG_FORTH_WORDS_KEY 
435f						DMARK "CDP" 
435f f5				push af  
4360 3a 74 43			ld a, (.dmark)  
4363 32 68 fe			ld (debug_mark),a  
4366 3a 75 43			ld a, (.dmark+1)  
4369 32 69 fe			ld (debug_mark+1),a  
436c 3a 76 43			ld a, (.dmark+2)  
436f 32 6a fe			ld (debug_mark+2),a  
4372 18 03			jr .pastdmark  
4374 ..			.dmark: db "CDP"  
4377 f1			.pastdmark: pop af  
4378			endm  
# End of macro DMARK
4378						CALLMONITOR 
4378 cd 6c fe			call debug_vector  
437b				endm  
# End of macro CALLMONITOR
437b					endif 
437b cd 9c 0d				call clear_display 
437e cd 85 1f				call dumpcont	 
4381 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4382					NEXTW 
4382 c3 b2 24			jp macro_next 
4385				endm 
# End of macro NEXTW
4385			 
4385			 
4385			 
4385			 
4385			.DAT: 
4385				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
4385 3d				db WORD_SYS_CORE+41             
4386 db 43			dw .HOME            
4388 03				db 2 + 1 
4389 .. 00			db "AT",0              
438c				endm 
# End of macro CWHEAD
438c			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
438c					if DEBUG_FORTH_WORDS_KEY 
438c						DMARK "AT." 
438c f5				push af  
438d 3a a1 43			ld a, (.dmark)  
4390 32 68 fe			ld (debug_mark),a  
4393 3a a2 43			ld a, (.dmark+1)  
4396 32 69 fe			ld (debug_mark+1),a  
4399 3a a3 43			ld a, (.dmark+2)  
439c 32 6a fe			ld (debug_mark+2),a  
439f 18 03			jr .pastdmark  
43a1 ..			.dmark: db "AT."  
43a4 f1			.pastdmark: pop af  
43a5			endm  
# End of macro DMARK
43a5						CALLMONITOR 
43a5 cd 6c fe			call debug_vector  
43a8				endm  
# End of macro CALLMONITOR
43a8					endif 
43a8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43a8 cd fc 22			call macro_dsp_valuehl 
43ab				endm 
# End of macro FORTH_DSP_VALUEHL
43ab			 
43ab			 
43ab					; TODO save cursor row 
43ab 7d					ld a,l 
43ac fe 02				cp 2 
43ae 20 04				jr nz, .crow3 
43b0 3e 28				ld a, display_row_2 
43b2 18 12				jr .ccol1 
43b4 fe 03		.crow3:		cp 3 
43b6 20 04				jr nz, .crow4 
43b8 3e 50				ld a, display_row_3 
43ba 18 0a				jr .ccol1 
43bc fe 04		.crow4:		cp 4 
43be 20 04				jr nz, .crow1 
43c0 3e 78				ld a, display_row_4 
43c2 18 02				jr .ccol1 
43c4 3e 00		.crow1:		ld a,display_row_1 
43c6 f5			.ccol1:		push af			; got row offset 
43c7 6f					ld l,a 
43c8 26 00				ld h,0 
43ca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43ca cd b4 23			call macro_forth_dsp_pop 
43cd				endm 
# End of macro FORTH_DSP_POP
43cd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43cd cd fc 22			call macro_dsp_valuehl 
43d0				endm 
# End of macro FORTH_DSP_VALUEHL
43d0					; TODO save cursor col 
43d0 f1					pop af 
43d1 85					add l		; add col offset 
43d2 32 5b fa				ld (f_cursor_ptr), a 
43d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43d5 cd b4 23			call macro_forth_dsp_pop 
43d8				endm 
# End of macro FORTH_DSP_POP
43d8			 
43d8					; calculate  
43d8			 
43d8					NEXTW 
43d8 c3 b2 24			jp macro_next 
43db				endm 
# End of macro NEXTW
43db			 
43db			 
43db			.HOME: 
43db				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
43db 41				db WORD_SYS_CORE+45             
43dc 08 44			dw .SPACE            
43de 05				db 4 + 1 
43df .. 00			db "HOME",0              
43e4				endm 
# End of macro CWHEAD
43e4			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
43e4					if DEBUG_FORTH_WORDS_KEY 
43e4						DMARK "HOM" 
43e4 f5				push af  
43e5 3a f9 43			ld a, (.dmark)  
43e8 32 68 fe			ld (debug_mark),a  
43eb 3a fa 43			ld a, (.dmark+1)  
43ee 32 69 fe			ld (debug_mark+1),a  
43f1 3a fb 43			ld a, (.dmark+2)  
43f4 32 6a fe			ld (debug_mark+2),a  
43f7 18 03			jr .pastdmark  
43f9 ..			.dmark: db "HOM"  
43fc f1			.pastdmark: pop af  
43fd			endm  
# End of macro DMARK
43fd						CALLMONITOR 
43fd cd 6c fe			call debug_vector  
4400				endm  
# End of macro CALLMONITOR
4400					endif 
4400 3e 00		.home:		ld a, 0		; and home cursor 
4402 32 5b fa				ld (f_cursor_ptr), a 
4405					NEXTW 
4405 c3 b2 24			jp macro_next 
4408				endm 
# End of macro NEXTW
4408			 
4408			 
4408			.SPACE: 
4408				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
4408 46				db WORD_SYS_CORE+50             
4409 3e 44			dw .SPACES            
440b 03				db 2 + 1 
440c .. 00			db "BL",0              
440f				endm 
# End of macro CWHEAD
440f			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
440f					if DEBUG_FORTH_WORDS_KEY 
440f						DMARK "BL." 
440f f5				push af  
4410 3a 24 44			ld a, (.dmark)  
4413 32 68 fe			ld (debug_mark),a  
4416 3a 25 44			ld a, (.dmark+1)  
4419 32 69 fe			ld (debug_mark+1),a  
441c 3a 26 44			ld a, (.dmark+2)  
441f 32 6a fe			ld (debug_mark+2),a  
4422 18 03			jr .pastdmark  
4424 ..			.dmark: db "BL."  
4427 f1			.pastdmark: pop af  
4428			endm  
# End of macro DMARK
4428						CALLMONITOR 
4428 cd 6c fe			call debug_vector  
442b				endm  
# End of macro CALLMONITOR
442b					endif 
442b 3e 20				ld a, " " 
442d 32 be f1				ld (scratch),a 
4430 3e 00				ld a, 0 
4432 32 bf f1				ld (scratch+1),a 
4435 21 be f1				ld hl, scratch 
4438 cd 73 21				call forth_push_str 
443b					 
443b				       NEXTW 
443b c3 b2 24			jp macro_next 
443e				endm 
# End of macro NEXTW
443e			 
443e			;.blstr: db " ", 0 
443e			 
443e			.SPACES: 
443e				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
443e 47				db WORD_SYS_CORE+51             
443f d9 44			dw .SCROLL            
4441 07				db 6 + 1 
4442 .. 00			db "SPACES",0              
4449				endm 
# End of macro CWHEAD
4449			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
4449					if DEBUG_FORTH_WORDS_KEY 
4449						DMARK "SPS" 
4449 f5				push af  
444a 3a 5e 44			ld a, (.dmark)  
444d 32 68 fe			ld (debug_mark),a  
4450 3a 5f 44			ld a, (.dmark+1)  
4453 32 69 fe			ld (debug_mark+1),a  
4456 3a 60 44			ld a, (.dmark+2)  
4459 32 6a fe			ld (debug_mark+2),a  
445c 18 03			jr .pastdmark  
445e ..			.dmark: db "SPS"  
4461 f1			.pastdmark: pop af  
4462			endm  
# End of macro DMARK
4462						CALLMONITOR 
4462 cd 6c fe			call debug_vector  
4465				endm  
# End of macro CALLMONITOR
4465					endif 
4465			 
4465			 
4465					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4465 cd fc 22			call macro_dsp_valuehl 
4468				endm 
# End of macro FORTH_DSP_VALUEHL
4468			 
4468 e5					push hl    ; u 
4469					if DEBUG_FORTH_WORDS 
4469						DMARK "SPA" 
4469 f5				push af  
446a 3a 7e 44			ld a, (.dmark)  
446d 32 68 fe			ld (debug_mark),a  
4470 3a 7f 44			ld a, (.dmark+1)  
4473 32 69 fe			ld (debug_mark+1),a  
4476 3a 80 44			ld a, (.dmark+2)  
4479 32 6a fe			ld (debug_mark+2),a  
447c 18 03			jr .pastdmark  
447e ..			.dmark: db "SPA"  
4481 f1			.pastdmark: pop af  
4482			endm  
# End of macro DMARK
4482						CALLMONITOR 
4482 cd 6c fe			call debug_vector  
4485				endm  
# End of macro CALLMONITOR
4485					endif 
4485			 
4485					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4485 cd b4 23			call macro_forth_dsp_pop 
4488				endm 
# End of macro FORTH_DSP_POP
4488 e1					pop hl 
4489 0e 00				ld c, 0 
448b 45					ld b, l 
448c 21 be f1				ld hl, scratch  
448f			 
448f					if DEBUG_FORTH_WORDS 
448f						DMARK "SP2" 
448f f5				push af  
4490 3a a4 44			ld a, (.dmark)  
4493 32 68 fe			ld (debug_mark),a  
4496 3a a5 44			ld a, (.dmark+1)  
4499 32 69 fe			ld (debug_mark+1),a  
449c 3a a6 44			ld a, (.dmark+2)  
449f 32 6a fe			ld (debug_mark+2),a  
44a2 18 03			jr .pastdmark  
44a4 ..			.dmark: db "SP2"  
44a7 f1			.pastdmark: pop af  
44a8			endm  
# End of macro DMARK
44a8						CALLMONITOR 
44a8 cd 6c fe			call debug_vector  
44ab				endm  
# End of macro CALLMONITOR
44ab					endif 
44ab 3e 20				ld a, ' ' 
44ad			.spaces1:	 
44ad 77					ld (hl),a 
44ae 23					inc hl 
44af					 
44af 10 fc				djnz .spaces1 
44b1 3e 00				ld a,0 
44b3 77					ld (hl),a 
44b4 21 be f1				ld hl, scratch 
44b7					if DEBUG_FORTH_WORDS 
44b7						DMARK "SP3" 
44b7 f5				push af  
44b8 3a cc 44			ld a, (.dmark)  
44bb 32 68 fe			ld (debug_mark),a  
44be 3a cd 44			ld a, (.dmark+1)  
44c1 32 69 fe			ld (debug_mark+1),a  
44c4 3a ce 44			ld a, (.dmark+2)  
44c7 32 6a fe			ld (debug_mark+2),a  
44ca 18 03			jr .pastdmark  
44cc ..			.dmark: db "SP3"  
44cf f1			.pastdmark: pop af  
44d0			endm  
# End of macro DMARK
44d0						CALLMONITOR 
44d0 cd 6c fe			call debug_vector  
44d3				endm  
# End of macro CALLMONITOR
44d3					endif 
44d3 cd 73 21				call forth_push_str 
44d6			 
44d6				       NEXTW 
44d6 c3 b2 24			jp macro_next 
44d9				endm 
# End of macro NEXTW
44d9			 
44d9			 
44d9			 
44d9			.SCROLL: 
44d9				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
44d9 53				db WORD_SYS_CORE+63             
44da 06 45			dw .SCROLLD            
44dc 07				db 6 + 1 
44dd .. 00			db "SCROLL",0              
44e4				endm 
# End of macro CWHEAD
44e4			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
44e4					if DEBUG_FORTH_WORDS_KEY 
44e4						DMARK "SCR" 
44e4 f5				push af  
44e5 3a f9 44			ld a, (.dmark)  
44e8 32 68 fe			ld (debug_mark),a  
44eb 3a fa 44			ld a, (.dmark+1)  
44ee 32 69 fe			ld (debug_mark+1),a  
44f1 3a fb 44			ld a, (.dmark+2)  
44f4 32 6a fe			ld (debug_mark+2),a  
44f7 18 03			jr .pastdmark  
44f9 ..			.dmark: db "SCR"  
44fc f1			.pastdmark: pop af  
44fd			endm  
# End of macro DMARK
44fd						CALLMONITOR 
44fd cd 6c fe			call debug_vector  
4500				endm  
# End of macro CALLMONITOR
4500					endif 
4500			 
4500 cd 5e 0d			call scroll_up 
4503			;	call update_display 
4503			 
4503					NEXTW 
4503 c3 b2 24			jp macro_next 
4506				endm 
# End of macro NEXTW
4506			 
4506			 
4506			 
4506			;		; get dir 
4506			; 
4506			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4506			; 
4506			;		push hl 
4506			; 
4506			;		; destroy value TOS 
4506			; 
4506			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4506			; 
4506			;		; get count 
4506			; 
4506			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4506			; 
4506			;		push hl 
4506			; 
4506			;		; destroy value TOS 
4506			; 
4506			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4506			; 
4506			;		; one value on hl get other one back 
4506			; 
4506			;		pop bc    ; count 
4506			; 
4506			;		pop de   ; dir 
4506			; 
4506			; 
4506			;		ld b, c 
4506			; 
4506			;.scrolldir:     push bc 
4506			;		push de 
4506			; 
4506			;		ld a, 0 
4506			;		cp e 
4506			;		jr z, .scrollup  
4506			;		call scroll_down 
4506			;		jr .scrollnext 
4506			;.scrollup:	call scroll_up 
4506			; 
4506			;		 
4506			;.scrollnext: 
4506			;		pop de 
4506			;		pop bc 
4506			;		djnz .scrolldir 
4506			; 
4506			; 
4506			; 
4506			; 
4506			; 
4506			;		NEXTW 
4506			 
4506			.SCROLLD: 
4506				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4506 53				db WORD_SYS_CORE+63             
4507 34 45			dw .ATQ            
4509 08				db 7 + 1 
450a .. 00			db "SCROLLD",0              
4512				endm 
# End of macro CWHEAD
4512			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4512					if DEBUG_FORTH_WORDS_KEY 
4512						DMARK "SCD" 
4512 f5				push af  
4513 3a 27 45			ld a, (.dmark)  
4516 32 68 fe			ld (debug_mark),a  
4519 3a 28 45			ld a, (.dmark+1)  
451c 32 69 fe			ld (debug_mark+1),a  
451f 3a 29 45			ld a, (.dmark+2)  
4522 32 6a fe			ld (debug_mark+2),a  
4525 18 03			jr .pastdmark  
4527 ..			.dmark: db "SCD"  
452a f1			.pastdmark: pop af  
452b			endm  
# End of macro DMARK
452b						CALLMONITOR 
452b cd 6c fe			call debug_vector  
452e				endm  
# End of macro CALLMONITOR
452e					endif 
452e			 
452e cd 82 0d			call scroll_down 
4531			;	call update_display 
4531			 
4531					NEXTW 
4531 c3 b2 24			jp macro_next 
4534				endm 
# End of macro NEXTW
4534			 
4534			 
4534			.ATQ: 
4534				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4534 62				db WORD_SYS_CORE+78             
4535 92 45			dw .AUTODSP            
4537 04				db 3 + 1 
4538 .. 00			db "AT@",0              
453c				endm 
# End of macro CWHEAD
453c			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
453c					if DEBUG_FORTH_WORDS_KEY 
453c						DMARK "ATA" 
453c f5				push af  
453d 3a 51 45			ld a, (.dmark)  
4540 32 68 fe			ld (debug_mark),a  
4543 3a 52 45			ld a, (.dmark+1)  
4546 32 69 fe			ld (debug_mark+1),a  
4549 3a 53 45			ld a, (.dmark+2)  
454c 32 6a fe			ld (debug_mark+2),a  
454f 18 03			jr .pastdmark  
4551 ..			.dmark: db "ATA"  
4554 f1			.pastdmark: pop af  
4555			endm  
# End of macro DMARK
4555						CALLMONITOR 
4555 cd 6c fe			call debug_vector  
4558				endm  
# End of macro CALLMONITOR
4558					endif 
4558			 
4558			 
4558					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4558 cd fc 22			call macro_dsp_valuehl 
455b				endm 
# End of macro FORTH_DSP_VALUEHL
455b			 
455b					; TODO save cursor row 
455b 7d					ld a,l 
455c fe 02				cp 2 
455e 20 04				jr nz, .crow3aq 
4560 3e 28				ld a, display_row_2 
4562 18 12				jr .ccol1aq 
4564 fe 03		.crow3aq:		cp 3 
4566 20 04				jr nz, .crow4aq 
4568 3e 50				ld a, display_row_3 
456a 18 0a				jr .ccol1aq 
456c fe 04		.crow4aq:		cp 4 
456e 20 04				jr nz, .crow1aq 
4570 3e 78				ld a, display_row_4 
4572 18 02				jr .ccol1aq 
4574 3e 00		.crow1aq:		ld a,display_row_1 
4576 f5			.ccol1aq:		push af			; got row offset 
4577 6f					ld l,a 
4578 26 00				ld h,0 
457a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
457a cd b4 23			call macro_forth_dsp_pop 
457d				endm 
# End of macro FORTH_DSP_POP
457d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
457d cd fc 22			call macro_dsp_valuehl 
4580				endm 
# End of macro FORTH_DSP_VALUEHL
4580					; TODO save cursor col 
4580 f1					pop af 
4581 85					add l		; add col offset 
4582			 
4582					; add current frame buffer address 
4582 2a c9 fb				ld hl, (display_fb_active) 
4585 cd d0 0f				call addatohl 
4588			 
4588			 
4588			 
4588			 
4588					; get char frame buffer location offset in hl 
4588			 
4588 7e					ld a,(hl) 
4589 26 00				ld h, 0 
458b 6f					ld l, a 
458c			 
458c cd 05 21				call forth_push_numhl 
458f			 
458f			 
458f					NEXTW 
458f c3 b2 24			jp macro_next 
4592				endm 
# End of macro NEXTW
4592			 
4592			.AUTODSP: 
4592				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4592 63				db WORD_SYS_CORE+79             
4593 a8 45			dw .MENU            
4595 05				db 4 + 1 
4596 .. 00			db "ADSP",0              
459b				endm 
# End of macro CWHEAD
459b			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
459b			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
459b			 
459b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
459b cd fc 22			call macro_dsp_valuehl 
459e				endm 
# End of macro FORTH_DSP_VALUEHL
459e			 
459e			;		push hl 
459e			 
459e					; destroy value TOS 
459e			 
459e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
459e cd b4 23			call macro_forth_dsp_pop 
45a1				endm 
# End of macro FORTH_DSP_POP
45a1			 
45a1			;		pop hl 
45a1			 
45a1 7d					ld a,l 
45a2 32 39 fa				ld (cli_autodisplay), a 
45a5				       NEXTW 
45a5 c3 b2 24			jp macro_next 
45a8				endm 
# End of macro NEXTW
45a8			 
45a8			.MENU: 
45a8				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
45a8 70				db WORD_SYS_CORE+92             
45a9 51 46			dw .ENDDISPLAY            
45ab 05				db 4 + 1 
45ac .. 00			db "MENU",0              
45b1				endm 
# End of macro CWHEAD
45b1			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
45b1			 
45b1			;		; get number of items on the stack 
45b1			; 
45b1				 
45b1					FORTH_DSP_VALUEHL 
45b1 cd fc 22			call macro_dsp_valuehl 
45b4				endm 
# End of macro FORTH_DSP_VALUEHL
45b4				 
45b4					if DEBUG_FORTH_WORDS_KEY 
45b4						DMARK "MNU" 
45b4 f5				push af  
45b5 3a c9 45			ld a, (.dmark)  
45b8 32 68 fe			ld (debug_mark),a  
45bb 3a ca 45			ld a, (.dmark+1)  
45be 32 69 fe			ld (debug_mark+1),a  
45c1 3a cb 45			ld a, (.dmark+2)  
45c4 32 6a fe			ld (debug_mark+2),a  
45c7 18 03			jr .pastdmark  
45c9 ..			.dmark: db "MNU"  
45cc f1			.pastdmark: pop af  
45cd			endm  
# End of macro DMARK
45cd						CALLMONITOR 
45cd cd 6c fe			call debug_vector  
45d0				endm  
# End of macro CALLMONITOR
45d0					endif 
45d0			 
45d0 45					ld b, l	 
45d1 05					dec b 
45d2			 
45d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45d2 cd b4 23			call macro_forth_dsp_pop 
45d5				endm 
# End of macro FORTH_DSP_POP
45d5			 
45d5			 
45d5					; go directly through the stack to pluck out the string pointers and build an array 
45d5			 
45d5			;		FORTH_DSP 
45d5			 
45d5					; hl contains top most stack item 
45d5				 
45d5 11 be f1				ld de, scratch 
45d8			 
45d8			.mbuild: 
45d8			 
45d8					FORTH_DSP_VALUEHL 
45d8 cd fc 22			call macro_dsp_valuehl 
45db				endm 
# End of macro FORTH_DSP_VALUEHL
45db			 
45db					if DEBUG_FORTH_WORDS 
45db						DMARK "MN3" 
45db f5				push af  
45dc 3a f0 45			ld a, (.dmark)  
45df 32 68 fe			ld (debug_mark),a  
45e2 3a f1 45			ld a, (.dmark+1)  
45e5 32 69 fe			ld (debug_mark+1),a  
45e8 3a f2 45			ld a, (.dmark+2)  
45eb 32 6a fe			ld (debug_mark+2),a  
45ee 18 03			jr .pastdmark  
45f0 ..			.dmark: db "MN3"  
45f3 f1			.pastdmark: pop af  
45f4			endm  
# End of macro DMARK
45f4						CALLMONITOR 
45f4 cd 6c fe			call debug_vector  
45f7				endm  
# End of macro CALLMONITOR
45f7					endif 
45f7 eb					ex de, hl 
45f8 73					ld (hl), e 
45f9 23					inc hl 
45fa 72					ld (hl), d 
45fb 23					inc hl 
45fc eb					ex de, hl 
45fd			 
45fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45fd cd b4 23			call macro_forth_dsp_pop 
4600				endm 
# End of macro FORTH_DSP_POP
4600			 
4600 10 d6				djnz .mbuild 
4602			 
4602					; done add term 
4602			 
4602 eb					ex de, hl 
4603 36 00				ld (hl), 0 
4605 23					inc hl 
4606 36 00				ld (hl), 0 
4608			 
4608				 
4608					 
4608 21 be f1				ld hl, scratch 
460b			 
460b					if DEBUG_FORTH_WORDS 
460b						DMARK "MNx" 
460b f5				push af  
460c 3a 20 46			ld a, (.dmark)  
460f 32 68 fe			ld (debug_mark),a  
4612 3a 21 46			ld a, (.dmark+1)  
4615 32 69 fe			ld (debug_mark+1),a  
4618 3a 22 46			ld a, (.dmark+2)  
461b 32 6a fe			ld (debug_mark+2),a  
461e 18 03			jr .pastdmark  
4620 ..			.dmark: db "MNx"  
4623 f1			.pastdmark: pop af  
4624			endm  
# End of macro DMARK
4624						CALLMONITOR 
4624 cd 6c fe			call debug_vector  
4627				endm  
# End of macro CALLMONITOR
4627					endif 
4627			 
4627			 
4627			 
4627 3e 00				ld a, 0 
4629 cd cd 0d				call menu 
462c			 
462c			 
462c 6f					ld l, a 
462d 26 00				ld h, 0 
462f			 
462f					if DEBUG_FORTH_WORDS 
462f						DMARK "MNr" 
462f f5				push af  
4630 3a 44 46			ld a, (.dmark)  
4633 32 68 fe			ld (debug_mark),a  
4636 3a 45 46			ld a, (.dmark+1)  
4639 32 69 fe			ld (debug_mark+1),a  
463c 3a 46 46			ld a, (.dmark+2)  
463f 32 6a fe			ld (debug_mark+2),a  
4642 18 03			jr .pastdmark  
4644 ..			.dmark: db "MNr"  
4647 f1			.pastdmark: pop af  
4648			endm  
# End of macro DMARK
4648						CALLMONITOR 
4648 cd 6c fe			call debug_vector  
464b				endm  
# End of macro CALLMONITOR
464b					endif 
464b			 
464b cd 05 21				call forth_push_numhl 
464e			 
464e			 
464e			 
464e			 
464e				       NEXTW 
464e c3 b2 24			jp macro_next 
4651				endm 
# End of macro NEXTW
4651			 
4651			 
4651			.ENDDISPLAY: 
4651			 
4651			; eof 
# End of file forth_words_display.asm
4651			include "forth_words_str.asm" 
4651			 
4651			; | ## String Words 
4651			 
4651			.PTR:   
4651			 
4651				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4651 48				db WORD_SYS_CORE+52             
4652 7e 46			dw .STYPE            
4654 04				db 3 + 1 
4655 .. 00			db "PTR",0              
4659				endm 
# End of macro CWHEAD
4659			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4659			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4659			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4659			 
4659					if DEBUG_FORTH_WORDS_KEY 
4659						DMARK "PTR" 
4659 f5				push af  
465a 3a 6e 46			ld a, (.dmark)  
465d 32 68 fe			ld (debug_mark),a  
4660 3a 6f 46			ld a, (.dmark+1)  
4663 32 69 fe			ld (debug_mark+1),a  
4666 3a 70 46			ld a, (.dmark+2)  
4669 32 6a fe			ld (debug_mark+2),a  
466c 18 03			jr .pastdmark  
466e ..			.dmark: db "PTR"  
4671 f1			.pastdmark: pop af  
4672			endm  
# End of macro DMARK
4672						CALLMONITOR 
4672 cd 6c fe			call debug_vector  
4675				endm  
# End of macro CALLMONITOR
4675					endif 
4675					FORTH_DSP_VALUEHL 
4675 cd fc 22			call macro_dsp_valuehl 
4678				endm 
# End of macro FORTH_DSP_VALUEHL
4678 cd 05 21				call forth_push_numhl 
467b			 
467b			 
467b					NEXTW 
467b c3 b2 24			jp macro_next 
467e				endm 
# End of macro NEXTW
467e			.STYPE: 
467e				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
467e 48				db WORD_SYS_CORE+52             
467f cd 46			dw .UPPER            
4681 06				db 5 + 1 
4682 .. 00			db "STYPE",0              
4688				endm 
# End of macro CWHEAD
4688			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4688					if DEBUG_FORTH_WORDS_KEY 
4688						DMARK "STY" 
4688 f5				push af  
4689 3a 9d 46			ld a, (.dmark)  
468c 32 68 fe			ld (debug_mark),a  
468f 3a 9e 46			ld a, (.dmark+1)  
4692 32 69 fe			ld (debug_mark+1),a  
4695 3a 9f 46			ld a, (.dmark+2)  
4698 32 6a fe			ld (debug_mark+2),a  
469b 18 03			jr .pastdmark  
469d ..			.dmark: db "STY"  
46a0 f1			.pastdmark: pop af  
46a1			endm  
# End of macro DMARK
46a1						CALLMONITOR 
46a1 cd 6c fe			call debug_vector  
46a4				endm  
# End of macro CALLMONITOR
46a4					endif 
46a4					FORTH_DSP 
46a4 cd c2 22			call macro_forth_dsp 
46a7				endm 
# End of macro FORTH_DSP
46a7					;v5 FORTH_DSP_VALUE 
46a7			 
46a7 7e					ld a, (hl) 
46a8			 
46a8 f5					push af 
46a9			 
46a9			; Dont destroy TOS		FORTH_DSP_POP 
46a9			 
46a9 f1					pop af 
46aa			 
46aa fe 01				cp DS_TYPE_STR 
46ac 28 09				jr z, .typestr 
46ae			 
46ae fe 02				cp DS_TYPE_INUM 
46b0 28 0a				jr z, .typeinum 
46b2			 
46b2 21 cb 46				ld hl, .tna 
46b5 18 0a				jr .tpush 
46b7			 
46b7 21 c7 46		.typestr:	ld hl, .tstr 
46ba 18 05				jr .tpush 
46bc 21 c9 46		.typeinum:	ld hl, .tinum 
46bf 18 00				jr .tpush 
46c1			 
46c1			.tpush: 
46c1			 
46c1 cd 73 21				call forth_push_str 
46c4			 
46c4					NEXTW 
46c4 c3 b2 24			jp macro_next 
46c7				endm 
# End of macro NEXTW
46c7 .. 00		.tstr:	db "s",0 
46c9 .. 00		.tinum:  db "i",0 
46cb .. 00		.tna:   db "?", 0 
46cd			 
46cd			 
46cd			.UPPER: 
46cd				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
46cd 48				db WORD_SYS_CORE+52             
46ce 08 47			dw .LOWER            
46d0 06				db 5 + 1 
46d1 .. 00			db "UPPER",0              
46d7				endm 
# End of macro CWHEAD
46d7			; | UPPER ( s -- s ) Upper case string s  | DONE 
46d7					if DEBUG_FORTH_WORDS_KEY 
46d7						DMARK "UPR" 
46d7 f5				push af  
46d8 3a ec 46			ld a, (.dmark)  
46db 32 68 fe			ld (debug_mark),a  
46de 3a ed 46			ld a, (.dmark+1)  
46e1 32 69 fe			ld (debug_mark+1),a  
46e4 3a ee 46			ld a, (.dmark+2)  
46e7 32 6a fe			ld (debug_mark+2),a  
46ea 18 03			jr .pastdmark  
46ec ..			.dmark: db "UPR"  
46ef f1			.pastdmark: pop af  
46f0			endm  
# End of macro DMARK
46f0						CALLMONITOR 
46f0 cd 6c fe			call debug_vector  
46f3				endm  
# End of macro CALLMONITOR
46f3					endif 
46f3			 
46f3					FORTH_DSP 
46f3 cd c2 22			call macro_forth_dsp 
46f6				endm 
# End of macro FORTH_DSP
46f6					 
46f6			; TODO check is string type 
46f6			 
46f6					FORTH_DSP_VALUEHL 
46f6 cd fc 22			call macro_dsp_valuehl 
46f9				endm 
# End of macro FORTH_DSP_VALUEHL
46f9			; get pointer to string in hl 
46f9			 
46f9 7e			.toup:		ld a, (hl) 
46fa fe 00				cp 0 
46fc 28 07				jr z, .toupdone 
46fe			 
46fe cd 3d 13				call to_upper 
4701			 
4701 77					ld (hl), a 
4702 23					inc hl 
4703 18 f4				jr .toup 
4705			 
4705					 
4705			 
4705			 
4705			; for each char convert to upper 
4705					 
4705			.toupdone: 
4705			 
4705			 
4705					NEXTW 
4705 c3 b2 24			jp macro_next 
4708				endm 
# End of macro NEXTW
4708			.LOWER: 
4708				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4708 48				db WORD_SYS_CORE+52             
4709 43 47			dw .TCASE            
470b 06				db 5 + 1 
470c .. 00			db "LOWER",0              
4712				endm 
# End of macro CWHEAD
4712			; | LOWER ( s -- s ) Lower case string s  | DONE 
4712					if DEBUG_FORTH_WORDS_KEY 
4712						DMARK "LWR" 
4712 f5				push af  
4713 3a 27 47			ld a, (.dmark)  
4716 32 68 fe			ld (debug_mark),a  
4719 3a 28 47			ld a, (.dmark+1)  
471c 32 69 fe			ld (debug_mark+1),a  
471f 3a 29 47			ld a, (.dmark+2)  
4722 32 6a fe			ld (debug_mark+2),a  
4725 18 03			jr .pastdmark  
4727 ..			.dmark: db "LWR"  
472a f1			.pastdmark: pop af  
472b			endm  
# End of macro DMARK
472b						CALLMONITOR 
472b cd 6c fe			call debug_vector  
472e				endm  
# End of macro CALLMONITOR
472e					endif 
472e			 
472e					FORTH_DSP 
472e cd c2 22			call macro_forth_dsp 
4731				endm 
# End of macro FORTH_DSP
4731					 
4731			; TODO check is string type 
4731			 
4731					FORTH_DSP_VALUEHL 
4731 cd fc 22			call macro_dsp_valuehl 
4734				endm 
# End of macro FORTH_DSP_VALUEHL
4734			; get pointer to string in hl 
4734			 
4734 7e			.tolow:		ld a, (hl) 
4735 fe 00				cp 0 
4737 28 07				jr z, .tolowdone 
4739			 
4739 cd 46 13				call to_lower 
473c			 
473c 77					ld (hl), a 
473d 23					inc hl 
473e 18 f4				jr .tolow 
4740			 
4740					 
4740			 
4740			 
4740			; for each char convert to low 
4740					 
4740			.tolowdone: 
4740					NEXTW 
4740 c3 b2 24			jp macro_next 
4743				endm 
# End of macro NEXTW
4743			.TCASE: 
4743				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4743 48				db WORD_SYS_CORE+52             
4744 79 48			dw .SUBSTR            
4746 06				db 5 + 1 
4747 .. 00			db "TCASE",0              
474d				endm 
# End of macro CWHEAD
474d			; | TCASE ( s -- s ) Title case string s  | DONE 
474d					if DEBUG_FORTH_WORDS_KEY 
474d						DMARK "TCS" 
474d f5				push af  
474e 3a 62 47			ld a, (.dmark)  
4751 32 68 fe			ld (debug_mark),a  
4754 3a 63 47			ld a, (.dmark+1)  
4757 32 69 fe			ld (debug_mark+1),a  
475a 3a 64 47			ld a, (.dmark+2)  
475d 32 6a fe			ld (debug_mark+2),a  
4760 18 03			jr .pastdmark  
4762 ..			.dmark: db "TCS"  
4765 f1			.pastdmark: pop af  
4766			endm  
# End of macro DMARK
4766						CALLMONITOR 
4766 cd 6c fe			call debug_vector  
4769				endm  
# End of macro CALLMONITOR
4769					endif 
4769			 
4769					FORTH_DSP 
4769 cd c2 22			call macro_forth_dsp 
476c				endm 
# End of macro FORTH_DSP
476c					 
476c			; TODO check is string type 
476c			 
476c					FORTH_DSP_VALUEHL 
476c cd fc 22			call macro_dsp_valuehl 
476f				endm 
# End of macro FORTH_DSP_VALUEHL
476f			; get pointer to string in hl 
476f			 
476f					if DEBUG_FORTH_WORDS 
476f						DMARK "TC1" 
476f f5				push af  
4770 3a 84 47			ld a, (.dmark)  
4773 32 68 fe			ld (debug_mark),a  
4776 3a 85 47			ld a, (.dmark+1)  
4779 32 69 fe			ld (debug_mark+1),a  
477c 3a 86 47			ld a, (.dmark+2)  
477f 32 6a fe			ld (debug_mark+2),a  
4782 18 03			jr .pastdmark  
4784 ..			.dmark: db "TC1"  
4787 f1			.pastdmark: pop af  
4788			endm  
# End of macro DMARK
4788						CALLMONITOR 
4788 cd 6c fe			call debug_vector  
478b				endm  
# End of macro CALLMONITOR
478b					endif 
478b			 
478b					; first time in turn to upper case first char 
478b			 
478b 7e					ld a, (hl) 
478c c3 16 48				jp .totsiptou 
478f			 
478f			 
478f 7e			.tot:		ld a, (hl) 
4790 fe 00				cp 0 
4792 ca 5a 48				jp z, .totdone 
4795			 
4795					if DEBUG_FORTH_WORDS 
4795						DMARK "TC2" 
4795 f5				push af  
4796 3a aa 47			ld a, (.dmark)  
4799 32 68 fe			ld (debug_mark),a  
479c 3a ab 47			ld a, (.dmark+1)  
479f 32 69 fe			ld (debug_mark+1),a  
47a2 3a ac 47			ld a, (.dmark+2)  
47a5 32 6a fe			ld (debug_mark+2),a  
47a8 18 03			jr .pastdmark  
47aa ..			.dmark: db "TC2"  
47ad f1			.pastdmark: pop af  
47ae			endm  
# End of macro DMARK
47ae						CALLMONITOR 
47ae cd 6c fe			call debug_vector  
47b1				endm  
# End of macro CALLMONITOR
47b1					endif 
47b1					; check to see if current char is a space 
47b1			 
47b1 fe 20				cp ' ' 
47b3 28 21				jr z, .totsp 
47b5 cd 46 13				call to_lower 
47b8					if DEBUG_FORTH_WORDS 
47b8						DMARK "TC3" 
47b8 f5				push af  
47b9 3a cd 47			ld a, (.dmark)  
47bc 32 68 fe			ld (debug_mark),a  
47bf 3a ce 47			ld a, (.dmark+1)  
47c2 32 69 fe			ld (debug_mark+1),a  
47c5 3a cf 47			ld a, (.dmark+2)  
47c8 32 6a fe			ld (debug_mark+2),a  
47cb 18 03			jr .pastdmark  
47cd ..			.dmark: db "TC3"  
47d0 f1			.pastdmark: pop af  
47d1			endm  
# End of macro DMARK
47d1						CALLMONITOR 
47d1 cd 6c fe			call debug_vector  
47d4				endm  
# End of macro CALLMONITOR
47d4					endif 
47d4 18 63				jr .totnxt 
47d6			 
47d6			.totsp:         ; on a space, find next char which should be upper 
47d6			 
47d6					if DEBUG_FORTH_WORDS 
47d6						DMARK "TC4" 
47d6 f5				push af  
47d7 3a eb 47			ld a, (.dmark)  
47da 32 68 fe			ld (debug_mark),a  
47dd 3a ec 47			ld a, (.dmark+1)  
47e0 32 69 fe			ld (debug_mark+1),a  
47e3 3a ed 47			ld a, (.dmark+2)  
47e6 32 6a fe			ld (debug_mark+2),a  
47e9 18 03			jr .pastdmark  
47eb ..			.dmark: db "TC4"  
47ee f1			.pastdmark: pop af  
47ef			endm  
# End of macro DMARK
47ef						CALLMONITOR 
47ef cd 6c fe			call debug_vector  
47f2				endm  
# End of macro CALLMONITOR
47f2					endif 
47f2					;; 
47f2			 
47f2 fe 20				cp ' ' 
47f4 20 20				jr nz, .totsiptou 
47f6 23					inc hl 
47f7 7e					ld a, (hl) 
47f8					if DEBUG_FORTH_WORDS 
47f8						DMARK "TC5" 
47f8 f5				push af  
47f9 3a 0d 48			ld a, (.dmark)  
47fc 32 68 fe			ld (debug_mark),a  
47ff 3a 0e 48			ld a, (.dmark+1)  
4802 32 69 fe			ld (debug_mark+1),a  
4805 3a 0f 48			ld a, (.dmark+2)  
4808 32 6a fe			ld (debug_mark+2),a  
480b 18 03			jr .pastdmark  
480d ..			.dmark: db "TC5"  
4810 f1			.pastdmark: pop af  
4811			endm  
# End of macro DMARK
4811						CALLMONITOR 
4811 cd 6c fe			call debug_vector  
4814				endm  
# End of macro CALLMONITOR
4814					endif 
4814 18 c0				jr .totsp 
4816 fe 00		.totsiptou:    cp 0 
4818 28 40				jr z, .totdone 
481a					; not space and not zero term so upper case it 
481a cd 3d 13				call to_upper 
481d			 
481d					if DEBUG_FORTH_WORDS 
481d						DMARK "TC6" 
481d f5				push af  
481e 3a 32 48			ld a, (.dmark)  
4821 32 68 fe			ld (debug_mark),a  
4824 3a 33 48			ld a, (.dmark+1)  
4827 32 69 fe			ld (debug_mark+1),a  
482a 3a 34 48			ld a, (.dmark+2)  
482d 32 6a fe			ld (debug_mark+2),a  
4830 18 03			jr .pastdmark  
4832 ..			.dmark: db "TC6"  
4835 f1			.pastdmark: pop af  
4836			endm  
# End of macro DMARK
4836						CALLMONITOR 
4836 cd 6c fe			call debug_vector  
4839				endm  
# End of macro CALLMONITOR
4839					endif 
4839			 
4839			 
4839			.totnxt: 
4839			 
4839 77					ld (hl), a 
483a 23					inc hl 
483b					if DEBUG_FORTH_WORDS 
483b						DMARK "TC7" 
483b f5				push af  
483c 3a 50 48			ld a, (.dmark)  
483f 32 68 fe			ld (debug_mark),a  
4842 3a 51 48			ld a, (.dmark+1)  
4845 32 69 fe			ld (debug_mark+1),a  
4848 3a 52 48			ld a, (.dmark+2)  
484b 32 6a fe			ld (debug_mark+2),a  
484e 18 03			jr .pastdmark  
4850 ..			.dmark: db "TC7"  
4853 f1			.pastdmark: pop af  
4854			endm  
# End of macro DMARK
4854						CALLMONITOR 
4854 cd 6c fe			call debug_vector  
4857				endm  
# End of macro CALLMONITOR
4857					endif 
4857 c3 8f 47				jp .tot 
485a			 
485a					 
485a			 
485a			 
485a			; for each char convert to low 
485a					 
485a			.totdone: 
485a					if DEBUG_FORTH_WORDS 
485a						DMARK "TCd" 
485a f5				push af  
485b 3a 6f 48			ld a, (.dmark)  
485e 32 68 fe			ld (debug_mark),a  
4861 3a 70 48			ld a, (.dmark+1)  
4864 32 69 fe			ld (debug_mark+1),a  
4867 3a 71 48			ld a, (.dmark+2)  
486a 32 6a fe			ld (debug_mark+2),a  
486d 18 03			jr .pastdmark  
486f ..			.dmark: db "TCd"  
4872 f1			.pastdmark: pop af  
4873			endm  
# End of macro DMARK
4873						CALLMONITOR 
4873 cd 6c fe			call debug_vector  
4876				endm  
# End of macro CALLMONITOR
4876					endif 
4876					NEXTW 
4876 c3 b2 24			jp macro_next 
4879				endm 
# End of macro NEXTW
4879			 
4879			.SUBSTR: 
4879				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4879 48				db WORD_SYS_CORE+52             
487a d7 48			dw .LEFT            
487c 07				db 6 + 1 
487d .. 00			db "SUBSTR",0              
4884				endm 
# End of macro CWHEAD
4884			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4884			 
4884					if DEBUG_FORTH_WORDS_KEY 
4884						DMARK "SST" 
4884 f5				push af  
4885 3a 99 48			ld a, (.dmark)  
4888 32 68 fe			ld (debug_mark),a  
488b 3a 9a 48			ld a, (.dmark+1)  
488e 32 69 fe			ld (debug_mark+1),a  
4891 3a 9b 48			ld a, (.dmark+2)  
4894 32 6a fe			ld (debug_mark+2),a  
4897 18 03			jr .pastdmark  
4899 ..			.dmark: db "SST"  
489c f1			.pastdmark: pop af  
489d			endm  
# End of macro DMARK
489d						CALLMONITOR 
489d cd 6c fe			call debug_vector  
48a0				endm  
# End of macro CALLMONITOR
48a0					endif 
48a0			; TODO check string type 
48a0					FORTH_DSP_VALUEHL 
48a0 cd fc 22			call macro_dsp_valuehl 
48a3				endm 
# End of macro FORTH_DSP_VALUEHL
48a3			 
48a3 e5					push hl      ; string length 
48a4			 
48a4					FORTH_DSP_POP 
48a4 cd b4 23			call macro_forth_dsp_pop 
48a7				endm 
# End of macro FORTH_DSP_POP
48a7			 
48a7					FORTH_DSP_VALUEHL 
48a7 cd fc 22			call macro_dsp_valuehl 
48aa				endm 
# End of macro FORTH_DSP_VALUEHL
48aa			 
48aa e5					push hl     ; start char 
48ab			 
48ab					FORTH_DSP_POP 
48ab cd b4 23			call macro_forth_dsp_pop 
48ae				endm 
# End of macro FORTH_DSP_POP
48ae			 
48ae			 
48ae					FORTH_DSP_VALUE 
48ae cd e5 22			call macro_forth_dsp_value 
48b1				endm 
# End of macro FORTH_DSP_VALUE
48b1			 
48b1 d1					pop de    ; get start post offset 
48b2			 
48b2 19					add hl, de    ; starting offset 
48b3			 
48b3 c1					pop bc 
48b4 c5					push bc      ; grab size of string 
48b5			 
48b5 e5					push hl    ; save string start  
48b6			 
48b6 26 00				ld h, 0 
48b8 69					ld l, c 
48b9 23					inc hl 
48ba 23					inc hl 
48bb			 
48bb cd 97 14				call malloc 
48be				if DEBUG_FORTH_MALLOC_GUARD 
48be cc 04 5e				call z,malloc_error 
48c1				endif 
48c1			 
48c1 eb					ex de, hl      ; save malloc area for string copy 
48c2 e1					pop hl    ; get back source 
48c3 c1					pop bc    ; get length of string back 
48c4			 
48c4 d5					push de    ; save malloc area for after we push 
48c5 ed b0				ldir     ; copy substr 
48c7			 
48c7			 
48c7 eb					ex de, hl 
48c8 3e 00				ld a, 0 
48ca 77					ld (hl), a   ; term substr 
48cb			 
48cb					 
48cb e1					pop hl    ; get malloc so we can push it 
48cc e5					push hl   ; save so we can free it afterwards 
48cd			 
48cd cd 73 21				call forth_push_str 
48d0			 
48d0 e1					pop hl 
48d1 cd 61 15				call free 
48d4			 
48d4					 
48d4					 
48d4			 
48d4			 
48d4					NEXTW 
48d4 c3 b2 24			jp macro_next 
48d7				endm 
# End of macro NEXTW
48d7			 
48d7			.LEFT: 
48d7				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
48d7 48				db WORD_SYS_CORE+52             
48d8 ff 48			dw .RIGHT            
48da 05				db 4 + 1 
48db .. 00			db "LEFT",0              
48e0				endm 
# End of macro CWHEAD
48e0			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
48e0					if DEBUG_FORTH_WORDS_KEY 
48e0						DMARK "LEF" 
48e0 f5				push af  
48e1 3a f5 48			ld a, (.dmark)  
48e4 32 68 fe			ld (debug_mark),a  
48e7 3a f6 48			ld a, (.dmark+1)  
48ea 32 69 fe			ld (debug_mark+1),a  
48ed 3a f7 48			ld a, (.dmark+2)  
48f0 32 6a fe			ld (debug_mark+2),a  
48f3 18 03			jr .pastdmark  
48f5 ..			.dmark: db "LEF"  
48f8 f1			.pastdmark: pop af  
48f9			endm  
# End of macro DMARK
48f9						CALLMONITOR 
48f9 cd 6c fe			call debug_vector  
48fc				endm  
# End of macro CALLMONITOR
48fc					endif 
48fc			 
48fc					NEXTW 
48fc c3 b2 24			jp macro_next 
48ff				endm 
# End of macro NEXTW
48ff			.RIGHT: 
48ff				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
48ff 48				db WORD_SYS_CORE+52             
4900 28 49			dw .STR2NUM            
4902 06				db 5 + 1 
4903 .. 00			db "RIGHT",0              
4909				endm 
# End of macro CWHEAD
4909			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4909					if DEBUG_FORTH_WORDS_KEY 
4909						DMARK "RIG" 
4909 f5				push af  
490a 3a 1e 49			ld a, (.dmark)  
490d 32 68 fe			ld (debug_mark),a  
4910 3a 1f 49			ld a, (.dmark+1)  
4913 32 69 fe			ld (debug_mark+1),a  
4916 3a 20 49			ld a, (.dmark+2)  
4919 32 6a fe			ld (debug_mark+2),a  
491c 18 03			jr .pastdmark  
491e ..			.dmark: db "RIG"  
4921 f1			.pastdmark: pop af  
4922			endm  
# End of macro DMARK
4922						CALLMONITOR 
4922 cd 6c fe			call debug_vector  
4925				endm  
# End of macro CALLMONITOR
4925					endif 
4925			 
4925					NEXTW 
4925 c3 b2 24			jp macro_next 
4928				endm 
# End of macro NEXTW
4928			 
4928			 
4928			.STR2NUM: 
4928				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4928 48				db WORD_SYS_CORE+52             
4929 b4 49			dw .NUM2STR            
492b 08				db 7 + 1 
492c .. 00			db "STR2NUM",0              
4934				endm 
# End of macro CWHEAD
4934			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4934			 
4934			 
4934			; TODO STR type check to do 
4934					if DEBUG_FORTH_WORDS_KEY 
4934						DMARK "S2N" 
4934 f5				push af  
4935 3a 49 49			ld a, (.dmark)  
4938 32 68 fe			ld (debug_mark),a  
493b 3a 4a 49			ld a, (.dmark+1)  
493e 32 69 fe			ld (debug_mark+1),a  
4941 3a 4b 49			ld a, (.dmark+2)  
4944 32 6a fe			ld (debug_mark+2),a  
4947 18 03			jr .pastdmark  
4949 ..			.dmark: db "S2N"  
494c f1			.pastdmark: pop af  
494d			endm  
# End of macro DMARK
494d						CALLMONITOR 
494d cd 6c fe			call debug_vector  
4950				endm  
# End of macro CALLMONITOR
4950					endif 
4950			 
4950					;FORTH_DSP 
4950					FORTH_DSP_VALUE 
4950 cd e5 22			call macro_forth_dsp_value 
4953				endm 
# End of macro FORTH_DSP_VALUE
4953					;inc hl 
4953			 
4953 eb					ex de, hl 
4954					if DEBUG_FORTH_WORDS 
4954						DMARK "S2a" 
4954 f5				push af  
4955 3a 69 49			ld a, (.dmark)  
4958 32 68 fe			ld (debug_mark),a  
495b 3a 6a 49			ld a, (.dmark+1)  
495e 32 69 fe			ld (debug_mark+1),a  
4961 3a 6b 49			ld a, (.dmark+2)  
4964 32 6a fe			ld (debug_mark+2),a  
4967 18 03			jr .pastdmark  
4969 ..			.dmark: db "S2a"  
496c f1			.pastdmark: pop af  
496d			endm  
# End of macro DMARK
496d						CALLMONITOR 
496d cd 6c fe			call debug_vector  
4970				endm  
# End of macro CALLMONITOR
4970					endif 
4970 cd c5 13				call string_to_uint16 
4973			 
4973					if DEBUG_FORTH_WORDS 
4973						DMARK "S2b" 
4973 f5				push af  
4974 3a 88 49			ld a, (.dmark)  
4977 32 68 fe			ld (debug_mark),a  
497a 3a 89 49			ld a, (.dmark+1)  
497d 32 69 fe			ld (debug_mark+1),a  
4980 3a 8a 49			ld a, (.dmark+2)  
4983 32 6a fe			ld (debug_mark+2),a  
4986 18 03			jr .pastdmark  
4988 ..			.dmark: db "S2b"  
498b f1			.pastdmark: pop af  
498c			endm  
# End of macro DMARK
498c						CALLMONITOR 
498c cd 6c fe			call debug_vector  
498f				endm  
# End of macro CALLMONITOR
498f					endif 
498f			;		push hl 
498f					FORTH_DSP_POP 
498f cd b4 23			call macro_forth_dsp_pop 
4992				endm 
# End of macro FORTH_DSP_POP
4992			;		pop hl 
4992					 
4992					if DEBUG_FORTH_WORDS 
4992						DMARK "S2b" 
4992 f5				push af  
4993 3a a7 49			ld a, (.dmark)  
4996 32 68 fe			ld (debug_mark),a  
4999 3a a8 49			ld a, (.dmark+1)  
499c 32 69 fe			ld (debug_mark+1),a  
499f 3a a9 49			ld a, (.dmark+2)  
49a2 32 6a fe			ld (debug_mark+2),a  
49a5 18 03			jr .pastdmark  
49a7 ..			.dmark: db "S2b"  
49aa f1			.pastdmark: pop af  
49ab			endm  
# End of macro DMARK
49ab						CALLMONITOR 
49ab cd 6c fe			call debug_vector  
49ae				endm  
# End of macro CALLMONITOR
49ae					endif 
49ae cd 05 21				call forth_push_numhl	 
49b1			 
49b1				 
49b1				       NEXTW 
49b1 c3 b2 24			jp macro_next 
49b4				endm 
# End of macro NEXTW
49b4			.NUM2STR: 
49b4				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
49b4 48				db WORD_SYS_CORE+52             
49b5 c3 49			dw .CONCAT            
49b7 08				db 7 + 1 
49b8 .. 00			db "NUM2STR",0              
49c0				endm 
# End of macro CWHEAD
49c0			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
49c0			 
49c0			;		; malloc a string to target 
49c0			;		ld hl, 10     ; TODO max string size should be fine 
49c0			;		call malloc 
49c0			;		push hl    ; save malloc location 
49c0			; 
49c0			; 
49c0			;; TODO check int type 
49c0			;		FORTH_DSP_VALUEHL 
49c0			;		ld a, l 
49c0			;		call DispAToASCII   
49c0			;;TODO need to chage above call to dump into string 
49c0			; 
49c0			; 
49c0			 
49c0				       NEXTW 
49c0 c3 b2 24			jp macro_next 
49c3				endm 
# End of macro NEXTW
49c3			 
49c3			.CONCAT: 
49c3				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
49c3 48				db WORD_SYS_CORE+52             
49c4 76 4a			dw .FIND            
49c6 07				db 6 + 1 
49c7 .. 00			db "CONCAT",0              
49ce				endm 
# End of macro CWHEAD
49ce			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
49ce			 
49ce			; TODO check string type 
49ce			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
49ce			 
49ce					if DEBUG_FORTH_WORDS_KEY 
49ce						DMARK "CON" 
49ce f5				push af  
49cf 3a e3 49			ld a, (.dmark)  
49d2 32 68 fe			ld (debug_mark),a  
49d5 3a e4 49			ld a, (.dmark+1)  
49d8 32 69 fe			ld (debug_mark+1),a  
49db 3a e5 49			ld a, (.dmark+2)  
49de 32 6a fe			ld (debug_mark+2),a  
49e1 18 03			jr .pastdmark  
49e3 ..			.dmark: db "CON"  
49e6 f1			.pastdmark: pop af  
49e7			endm  
# End of macro DMARK
49e7						CALLMONITOR 
49e7 cd 6c fe			call debug_vector  
49ea				endm  
# End of macro CALLMONITOR
49ea					endif 
49ea			 
49ea			 
49ea					FORTH_DSP_VALUE 
49ea cd e5 22			call macro_forth_dsp_value 
49ed				endm 
# End of macro FORTH_DSP_VALUE
49ed e5					push hl   ; s2 
49ee			 
49ee					FORTH_DSP_POP 
49ee cd b4 23			call macro_forth_dsp_pop 
49f1				endm 
# End of macro FORTH_DSP_POP
49f1			 
49f1					FORTH_DSP_VALUE 
49f1 cd e5 22			call macro_forth_dsp_value 
49f4				endm 
# End of macro FORTH_DSP_VALUE
49f4			 
49f4 e5					push hl   ; s1 
49f5			 
49f5					FORTH_DSP_POP 
49f5 cd b4 23			call macro_forth_dsp_pop 
49f8				endm 
# End of macro FORTH_DSP_POP
49f8					 
49f8			 
49f8					; copy s1 
49f8			 
49f8				 
49f8					; save ptr 
49f8 e1					pop hl  
49f9 e5					push hl 
49fa 3e 00				ld a, 0 
49fc cd 39 14				call strlent 
49ff					;inc hl    ; zer0 
49ff 06 00				ld b, 0 
4a01 4d					ld c, l 
4a02 e1					pop hl		 
4a03 11 be f1				ld de, scratch	 
4a06					if DEBUG_FORTH_WORDS 
4a06						DMARK "CO1" 
4a06 f5				push af  
4a07 3a 1b 4a			ld a, (.dmark)  
4a0a 32 68 fe			ld (debug_mark),a  
4a0d 3a 1c 4a			ld a, (.dmark+1)  
4a10 32 69 fe			ld (debug_mark+1),a  
4a13 3a 1d 4a			ld a, (.dmark+2)  
4a16 32 6a fe			ld (debug_mark+2),a  
4a19 18 03			jr .pastdmark  
4a1b ..			.dmark: db "CO1"  
4a1e f1			.pastdmark: pop af  
4a1f			endm  
# End of macro DMARK
4a1f						CALLMONITOR 
4a1f cd 6c fe			call debug_vector  
4a22				endm  
# End of macro CALLMONITOR
4a22					endif 
4a22 ed b0				ldir 
4a24			 
4a24 e1					pop hl 
4a25 e5					push hl 
4a26 d5					push de 
4a27			 
4a27			 
4a27 3e 00				ld a, 0 
4a29 cd 39 14				call strlent 
4a2c 23					inc hl    ; zer0 
4a2d 23					inc hl 
4a2e 06 00				ld b, 0 
4a30 4d					ld c, l 
4a31 d1					pop de 
4a32 e1					pop hl		 
4a33					if DEBUG_FORTH_WORDS 
4a33						DMARK "CO2" 
4a33 f5				push af  
4a34 3a 48 4a			ld a, (.dmark)  
4a37 32 68 fe			ld (debug_mark),a  
4a3a 3a 49 4a			ld a, (.dmark+1)  
4a3d 32 69 fe			ld (debug_mark+1),a  
4a40 3a 4a 4a			ld a, (.dmark+2)  
4a43 32 6a fe			ld (debug_mark+2),a  
4a46 18 03			jr .pastdmark  
4a48 ..			.dmark: db "CO2"  
4a4b f1			.pastdmark: pop af  
4a4c			endm  
# End of macro DMARK
4a4c						CALLMONITOR 
4a4c cd 6c fe			call debug_vector  
4a4f				endm  
# End of macro CALLMONITOR
4a4f					endif 
4a4f ed b0				ldir 
4a51			 
4a51			 
4a51			 
4a51 21 be f1				ld hl, scratch 
4a54					if DEBUG_FORTH_WORDS 
4a54						DMARK "CO5" 
4a54 f5				push af  
4a55 3a 69 4a			ld a, (.dmark)  
4a58 32 68 fe			ld (debug_mark),a  
4a5b 3a 6a 4a			ld a, (.dmark+1)  
4a5e 32 69 fe			ld (debug_mark+1),a  
4a61 3a 6b 4a			ld a, (.dmark+2)  
4a64 32 6a fe			ld (debug_mark+2),a  
4a67 18 03			jr .pastdmark  
4a69 ..			.dmark: db "CO5"  
4a6c f1			.pastdmark: pop af  
4a6d			endm  
# End of macro DMARK
4a6d						CALLMONITOR 
4a6d cd 6c fe			call debug_vector  
4a70				endm  
# End of macro CALLMONITOR
4a70					endif 
4a70			 
4a70 cd 73 21				call forth_push_str 
4a73			 
4a73			 
4a73			 
4a73			 
4a73				       NEXTW 
4a73 c3 b2 24			jp macro_next 
4a76				endm 
# End of macro NEXTW
4a76			 
4a76			 
4a76			.FIND: 
4a76				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4a76 4b				db WORD_SYS_CORE+55             
4a77 34 4b			dw .LEN            
4a79 05				db 4 + 1 
4a7a .. 00			db "FIND",0              
4a7f				endm 
# End of macro CWHEAD
4a7f			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4a7f			 
4a7f					if DEBUG_FORTH_WORDS_KEY 
4a7f						DMARK "FND" 
4a7f f5				push af  
4a80 3a 94 4a			ld a, (.dmark)  
4a83 32 68 fe			ld (debug_mark),a  
4a86 3a 95 4a			ld a, (.dmark+1)  
4a89 32 69 fe			ld (debug_mark+1),a  
4a8c 3a 96 4a			ld a, (.dmark+2)  
4a8f 32 6a fe			ld (debug_mark+2),a  
4a92 18 03			jr .pastdmark  
4a94 ..			.dmark: db "FND"  
4a97 f1			.pastdmark: pop af  
4a98			endm  
# End of macro DMARK
4a98						CALLMONITOR 
4a98 cd 6c fe			call debug_vector  
4a9b				endm  
# End of macro CALLMONITOR
4a9b					endif 
4a9b			 
4a9b			; TODO check string type 
4a9b					FORTH_DSP_VALUE 
4a9b cd e5 22			call macro_forth_dsp_value 
4a9e				endm 
# End of macro FORTH_DSP_VALUE
4a9e			 
4a9e e5					push hl    
4a9f 7e					ld a,(hl)    ; char to find   
4aa0			; TODO change char to substr 
4aa0			 
4aa0 f5					push af 
4aa1					 
4aa1			 
4aa1			 
4aa1					if DEBUG_FORTH_WORDS 
4aa1						DMARK "FN1" 
4aa1 f5				push af  
4aa2 3a b6 4a			ld a, (.dmark)  
4aa5 32 68 fe			ld (debug_mark),a  
4aa8 3a b7 4a			ld a, (.dmark+1)  
4aab 32 69 fe			ld (debug_mark+1),a  
4aae 3a b8 4a			ld a, (.dmark+2)  
4ab1 32 6a fe			ld (debug_mark+2),a  
4ab4 18 03			jr .pastdmark  
4ab6 ..			.dmark: db "FN1"  
4ab9 f1			.pastdmark: pop af  
4aba			endm  
# End of macro DMARK
4aba						CALLMONITOR 
4aba cd 6c fe			call debug_vector  
4abd				endm  
# End of macro CALLMONITOR
4abd					endif 
4abd			 
4abd					FORTH_DSP_POP 
4abd cd b4 23			call macro_forth_dsp_pop 
4ac0				endm 
# End of macro FORTH_DSP_POP
4ac0			 
4ac0					; string to search 
4ac0			 
4ac0					FORTH_DSP_VALUE 
4ac0 cd e5 22			call macro_forth_dsp_value 
4ac3				endm 
# End of macro FORTH_DSP_VALUE
4ac3			 
4ac3 d1					pop de  ; d is char to find  
4ac4			 
4ac4					if DEBUG_FORTH_WORDS 
4ac4						DMARK "FN2" 
4ac4 f5				push af  
4ac5 3a d9 4a			ld a, (.dmark)  
4ac8 32 68 fe			ld (debug_mark),a  
4acb 3a da 4a			ld a, (.dmark+1)  
4ace 32 69 fe			ld (debug_mark+1),a  
4ad1 3a db 4a			ld a, (.dmark+2)  
4ad4 32 6a fe			ld (debug_mark+2),a  
4ad7 18 03			jr .pastdmark  
4ad9 ..			.dmark: db "FN2"  
4adc f1			.pastdmark: pop af  
4add			endm  
# End of macro DMARK
4add						CALLMONITOR 
4add cd 6c fe			call debug_vector  
4ae0				endm  
# End of macro CALLMONITOR
4ae0					endif 
4ae0					 
4ae0 01 00 00				ld bc, 0 
4ae3 7e			.findchar:      ld a,(hl) 
4ae4 fe 00				cp 0   		 
4ae6 28 27				jr z, .finddone     
4ae8 ba					cp d 
4ae9 28 20				jr z, .foundchar 
4aeb 03					inc bc 
4aec 23					inc hl 
4aed					if DEBUG_FORTH_WORDS 
4aed						DMARK "FN3" 
4aed f5				push af  
4aee 3a 02 4b			ld a, (.dmark)  
4af1 32 68 fe			ld (debug_mark),a  
4af4 3a 03 4b			ld a, (.dmark+1)  
4af7 32 69 fe			ld (debug_mark+1),a  
4afa 3a 04 4b			ld a, (.dmark+2)  
4afd 32 6a fe			ld (debug_mark+2),a  
4b00 18 03			jr .pastdmark  
4b02 ..			.dmark: db "FN3"  
4b05 f1			.pastdmark: pop af  
4b06			endm  
# End of macro DMARK
4b06						CALLMONITOR 
4b06 cd 6c fe			call debug_vector  
4b09				endm  
# End of macro CALLMONITOR
4b09					endif 
4b09 18 d8				jr .findchar 
4b0b			 
4b0b			 
4b0b c5			.foundchar:	push bc 
4b0c e1					pop hl 
4b0d 18 03				jr .findexit 
4b0f			 
4b0f			 
4b0f							 
4b0f			 
4b0f			.finddone:     ; got to end of string with no find 
4b0f 21 00 00				ld hl, 0 
4b12			.findexit: 
4b12			 
4b12					if DEBUG_FORTH_WORDS 
4b12						DMARK "FNd" 
4b12 f5				push af  
4b13 3a 27 4b			ld a, (.dmark)  
4b16 32 68 fe			ld (debug_mark),a  
4b19 3a 28 4b			ld a, (.dmark+1)  
4b1c 32 69 fe			ld (debug_mark+1),a  
4b1f 3a 29 4b			ld a, (.dmark+2)  
4b22 32 6a fe			ld (debug_mark+2),a  
4b25 18 03			jr .pastdmark  
4b27 ..			.dmark: db "FNd"  
4b2a f1			.pastdmark: pop af  
4b2b			endm  
# End of macro DMARK
4b2b						CALLMONITOR 
4b2b cd 6c fe			call debug_vector  
4b2e				endm  
# End of macro CALLMONITOR
4b2e					endif 
4b2e cd 05 21			call forth_push_numhl 
4b31			 
4b31				       NEXTW 
4b31 c3 b2 24			jp macro_next 
4b34				endm 
# End of macro NEXTW
4b34			 
4b34			.LEN: 
4b34				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4b34 4c				db WORD_SYS_CORE+56             
4b35 9e 4b			dw .ASC            
4b37 06				db 5 + 1 
4b38 .. 00			db "COUNT",0              
4b3e				endm 
# End of macro CWHEAD
4b3e			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4b3e			 
4b3e					if DEBUG_FORTH_WORDS_KEY 
4b3e						DMARK "CNT" 
4b3e f5				push af  
4b3f 3a 53 4b			ld a, (.dmark)  
4b42 32 68 fe			ld (debug_mark),a  
4b45 3a 54 4b			ld a, (.dmark+1)  
4b48 32 69 fe			ld (debug_mark+1),a  
4b4b 3a 55 4b			ld a, (.dmark+2)  
4b4e 32 6a fe			ld (debug_mark+2),a  
4b51 18 03			jr .pastdmark  
4b53 ..			.dmark: db "CNT"  
4b56 f1			.pastdmark: pop af  
4b57			endm  
# End of macro DMARK
4b57						CALLMONITOR 
4b57 cd 6c fe			call debug_vector  
4b5a				endm  
# End of macro CALLMONITOR
4b5a					endif 
4b5a			; TODO check string type 
4b5a					FORTH_DSP_VALUE 
4b5a cd e5 22			call macro_forth_dsp_value 
4b5d				endm 
# End of macro FORTH_DSP_VALUE
4b5d			 
4b5d			 
4b5d					if DEBUG_FORTH_WORDS 
4b5d						DMARK "CN?" 
4b5d f5				push af  
4b5e 3a 72 4b			ld a, (.dmark)  
4b61 32 68 fe			ld (debug_mark),a  
4b64 3a 73 4b			ld a, (.dmark+1)  
4b67 32 69 fe			ld (debug_mark+1),a  
4b6a 3a 74 4b			ld a, (.dmark+2)  
4b6d 32 6a fe			ld (debug_mark+2),a  
4b70 18 03			jr .pastdmark  
4b72 ..			.dmark: db "CN?"  
4b75 f1			.pastdmark: pop af  
4b76			endm  
# End of macro DMARK
4b76						CALLMONITOR 
4b76 cd 6c fe			call debug_vector  
4b79				endm  
# End of macro CALLMONITOR
4b79					endif 
4b79 cd 2e 14				call strlenz 
4b7c					if DEBUG_FORTH_WORDS 
4b7c						DMARK "CNl" 
4b7c f5				push af  
4b7d 3a 91 4b			ld a, (.dmark)  
4b80 32 68 fe			ld (debug_mark),a  
4b83 3a 92 4b			ld a, (.dmark+1)  
4b86 32 69 fe			ld (debug_mark+1),a  
4b89 3a 93 4b			ld a, (.dmark+2)  
4b8c 32 6a fe			ld (debug_mark+2),a  
4b8f 18 03			jr .pastdmark  
4b91 ..			.dmark: db "CNl"  
4b94 f1			.pastdmark: pop af  
4b95			endm  
# End of macro DMARK
4b95						CALLMONITOR 
4b95 cd 6c fe			call debug_vector  
4b98				endm  
# End of macro CALLMONITOR
4b98					endif 
4b98			 
4b98 cd 05 21				call forth_push_numhl 
4b9b			 
4b9b			 
4b9b			 
4b9b				       NEXTW 
4b9b c3 b2 24			jp macro_next 
4b9e				endm 
# End of macro NEXTW
4b9e			.ASC: 
4b9e				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4b9e 4d				db WORD_SYS_CORE+57             
4b9f 0c 4c			dw .CHR            
4ba1 04				db 3 + 1 
4ba2 .. 00			db "ASC",0              
4ba6				endm 
# End of macro CWHEAD
4ba6			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4ba6					if DEBUG_FORTH_WORDS_KEY 
4ba6						DMARK "ASC" 
4ba6 f5				push af  
4ba7 3a bb 4b			ld a, (.dmark)  
4baa 32 68 fe			ld (debug_mark),a  
4bad 3a bc 4b			ld a, (.dmark+1)  
4bb0 32 69 fe			ld (debug_mark+1),a  
4bb3 3a bd 4b			ld a, (.dmark+2)  
4bb6 32 6a fe			ld (debug_mark+2),a  
4bb9 18 03			jr .pastdmark  
4bbb ..			.dmark: db "ASC"  
4bbe f1			.pastdmark: pop af  
4bbf			endm  
# End of macro DMARK
4bbf						CALLMONITOR 
4bbf cd 6c fe			call debug_vector  
4bc2				endm  
# End of macro CALLMONITOR
4bc2					endif 
4bc2					FORTH_DSP_VALUE 
4bc2 cd e5 22			call macro_forth_dsp_value 
4bc5				endm 
# End of macro FORTH_DSP_VALUE
4bc5					;v5 FORTH_DSP_VALUE 
4bc5			;		inc hl      ; now at start of numeric as string 
4bc5			 
4bc5 e5					push hl 
4bc6			 
4bc6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bc6 cd b4 23			call macro_forth_dsp_pop 
4bc9				endm 
# End of macro FORTH_DSP_POP
4bc9			 
4bc9 e1					pop hl 
4bca			 
4bca					if DEBUG_FORTH_WORDS 
4bca						DMARK "AS1" 
4bca f5				push af  
4bcb 3a df 4b			ld a, (.dmark)  
4bce 32 68 fe			ld (debug_mark),a  
4bd1 3a e0 4b			ld a, (.dmark+1)  
4bd4 32 69 fe			ld (debug_mark+1),a  
4bd7 3a e1 4b			ld a, (.dmark+2)  
4bda 32 6a fe			ld (debug_mark+2),a  
4bdd 18 03			jr .pastdmark  
4bdf ..			.dmark: db "AS1"  
4be2 f1			.pastdmark: pop af  
4be3			endm  
# End of macro DMARK
4be3						CALLMONITOR 
4be3 cd 6c fe			call debug_vector  
4be6				endm  
# End of macro CALLMONITOR
4be6					endif 
4be6					; push the content of a onto the stack as a value 
4be6			 
4be6 7e					ld a,(hl)   ; get char 
4be7 26 00				ld h,0 
4be9 6f					ld l,a 
4bea					if DEBUG_FORTH_WORDS 
4bea						DMARK "AS2" 
4bea f5				push af  
4beb 3a ff 4b			ld a, (.dmark)  
4bee 32 68 fe			ld (debug_mark),a  
4bf1 3a 00 4c			ld a, (.dmark+1)  
4bf4 32 69 fe			ld (debug_mark+1),a  
4bf7 3a 01 4c			ld a, (.dmark+2)  
4bfa 32 6a fe			ld (debug_mark+2),a  
4bfd 18 03			jr .pastdmark  
4bff ..			.dmark: db "AS2"  
4c02 f1			.pastdmark: pop af  
4c03			endm  
# End of macro DMARK
4c03						CALLMONITOR 
4c03 cd 6c fe			call debug_vector  
4c06				endm  
# End of macro CALLMONITOR
4c06					endif 
4c06 cd 05 21				call forth_push_numhl 
4c09			 
4c09				       NEXTW 
4c09 c3 b2 24			jp macro_next 
4c0c				endm 
# End of macro NEXTW
4c0c			 
4c0c			.CHR: 
4c0c				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4c0c 4d				db WORD_SYS_CORE+57             
4c0d 48 4c			dw .ENDSTR            
4c0f 04				db 3 + 1 
4c10 .. 00			db "CHR",0              
4c14				endm 
# End of macro CWHEAD
4c14			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4c14					if DEBUG_FORTH_WORDS_KEY 
4c14						DMARK "CHR" 
4c14 f5				push af  
4c15 3a 29 4c			ld a, (.dmark)  
4c18 32 68 fe			ld (debug_mark),a  
4c1b 3a 2a 4c			ld a, (.dmark+1)  
4c1e 32 69 fe			ld (debug_mark+1),a  
4c21 3a 2b 4c			ld a, (.dmark+2)  
4c24 32 6a fe			ld (debug_mark+2),a  
4c27 18 03			jr .pastdmark  
4c29 ..			.dmark: db "CHR"  
4c2c f1			.pastdmark: pop af  
4c2d			endm  
# End of macro DMARK
4c2d						CALLMONITOR 
4c2d cd 6c fe			call debug_vector  
4c30				endm  
# End of macro CALLMONITOR
4c30					endif 
4c30					FORTH_DSP_VALUEHL 
4c30 cd fc 22			call macro_dsp_valuehl 
4c33				endm 
# End of macro FORTH_DSP_VALUEHL
4c33			 
4c33					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c33 cd b4 23			call macro_forth_dsp_pop 
4c36				endm 
# End of macro FORTH_DSP_POP
4c36			 
4c36					; save asci byte as a zero term string and push string 
4c36			 
4c36 7d					ld a,l 
4c37 32 be f1				ld (scratch), a 
4c3a			 
4c3a 3e 00				ld a, 0 
4c3c 32 bf f1				ld (scratch+1), a 
4c3f			 
4c3f 21 be f1				ld hl, scratch 
4c42 cd 73 21				call forth_push_str 
4c45			 
4c45			 
4c45				       NEXTW 
4c45 c3 b2 24			jp macro_next 
4c48				endm 
# End of macro NEXTW
4c48			 
4c48			 
4c48			 
4c48			 
4c48			.ENDSTR: 
4c48			; eof 
4c48			 
# End of file forth_words_str.asm
4c48			include "forth_words_key.asm" 
4c48			 
4c48			; | ## Keyboard Words 
4c48			 
4c48			.KEY: 
4c48				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4c48 3e				db WORD_SYS_CORE+42             
4c49 78 4c			dw .WAITK            
4c4b 04				db 3 + 1 
4c4c .. 00			db "KEY",0              
4c50				endm 
# End of macro CWHEAD
4c50			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4c50			 
4c50					if DEBUG_FORTH_WORDS_KEY 
4c50						DMARK "KEY" 
4c50 f5				push af  
4c51 3a 65 4c			ld a, (.dmark)  
4c54 32 68 fe			ld (debug_mark),a  
4c57 3a 66 4c			ld a, (.dmark+1)  
4c5a 32 69 fe			ld (debug_mark+1),a  
4c5d 3a 67 4c			ld a, (.dmark+2)  
4c60 32 6a fe			ld (debug_mark+2),a  
4c63 18 03			jr .pastdmark  
4c65 ..			.dmark: db "KEY"  
4c68 f1			.pastdmark: pop af  
4c69			endm  
# End of macro DMARK
4c69						CALLMONITOR 
4c69 cd 6c fe			call debug_vector  
4c6c				endm  
# End of macro CALLMONITOR
4c6c					endif 
4c6c			; TODO currently waits 
4c6c cd d4 79				call cin 
4c6f					;call cin_wait 
4c6f 6f					ld l, a 
4c70 26 00				ld h, 0 
4c72 cd 05 21				call forth_push_numhl 
4c75					NEXTW 
4c75 c3 b2 24			jp macro_next 
4c78				endm 
# End of macro NEXTW
4c78			.WAITK: 
4c78				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4c78 3f				db WORD_SYS_CORE+43             
4c79 aa 4c			dw .ACCEPT            
4c7b 06				db 5 + 1 
4c7c .. 00			db "WAITK",0              
4c82				endm 
# End of macro CWHEAD
4c82			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4c82					if DEBUG_FORTH_WORDS_KEY 
4c82						DMARK "WAI" 
4c82 f5				push af  
4c83 3a 97 4c			ld a, (.dmark)  
4c86 32 68 fe			ld (debug_mark),a  
4c89 3a 98 4c			ld a, (.dmark+1)  
4c8c 32 69 fe			ld (debug_mark+1),a  
4c8f 3a 99 4c			ld a, (.dmark+2)  
4c92 32 6a fe			ld (debug_mark+2),a  
4c95 18 03			jr .pastdmark  
4c97 ..			.dmark: db "WAI"  
4c9a f1			.pastdmark: pop af  
4c9b			endm  
# End of macro DMARK
4c9b						CALLMONITOR 
4c9b cd 6c fe			call debug_vector  
4c9e				endm  
# End of macro CALLMONITOR
4c9e					endif 
4c9e cd c3 79				call cin_wait 
4ca1 6f					ld l, a 
4ca2 26 00				ld h, 0 
4ca4 cd 05 21				call forth_push_numhl 
4ca7					NEXTW 
4ca7 c3 b2 24			jp macro_next 
4caa				endm 
# End of macro NEXTW
4caa			.ACCEPT: 
4caa				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4caa 40				db WORD_SYS_CORE+44             
4cab 08 4d			dw .EDIT            
4cad 07				db 6 + 1 
4cae .. 00			db "ACCEPT",0              
4cb5				endm 
# End of macro CWHEAD
4cb5			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4cb5					; TODO crashes on push 
4cb5					if DEBUG_FORTH_WORDS_KEY 
4cb5						DMARK "ACC" 
4cb5 f5				push af  
4cb6 3a ca 4c			ld a, (.dmark)  
4cb9 32 68 fe			ld (debug_mark),a  
4cbc 3a cb 4c			ld a, (.dmark+1)  
4cbf 32 69 fe			ld (debug_mark+1),a  
4cc2 3a cc 4c			ld a, (.dmark+2)  
4cc5 32 6a fe			ld (debug_mark+2),a  
4cc8 18 03			jr .pastdmark  
4cca ..			.dmark: db "ACC"  
4ccd f1			.pastdmark: pop af  
4cce			endm  
# End of macro DMARK
4cce						CALLMONITOR 
4cce cd 6c fe			call debug_vector  
4cd1				endm  
# End of macro CALLMONITOR
4cd1					endif 
4cd1 21 bc f3				ld hl, os_input 
4cd4 3e 00				ld a, 0 
4cd6 77					ld (hl),a 
4cd7 3a 5b fa				ld a,(f_cursor_ptr) 
4cda 16 64				ld d, 100 
4cdc 0e 00				ld c, 0 
4cde 1e 28				ld e, 40 
4ce0 cd fd 0f				call input_str 
4ce3					; TODO perhaps do a type check and wrap in quotes if not a number 
4ce3 21 bc f3				ld hl, os_input 
4ce6					if DEBUG_FORTH_WORDS 
4ce6						DMARK "AC1" 
4ce6 f5				push af  
4ce7 3a fb 4c			ld a, (.dmark)  
4cea 32 68 fe			ld (debug_mark),a  
4ced 3a fc 4c			ld a, (.dmark+1)  
4cf0 32 69 fe			ld (debug_mark+1),a  
4cf3 3a fd 4c			ld a, (.dmark+2)  
4cf6 32 6a fe			ld (debug_mark+2),a  
4cf9 18 03			jr .pastdmark  
4cfb ..			.dmark: db "AC1"  
4cfe f1			.pastdmark: pop af  
4cff			endm  
# End of macro DMARK
4cff						CALLMONITOR 
4cff cd 6c fe			call debug_vector  
4d02				endm  
# End of macro CALLMONITOR
4d02					endif 
4d02 cd 73 21				call forth_push_str 
4d05					NEXTW 
4d05 c3 b2 24			jp macro_next 
4d08				endm 
# End of macro NEXTW
4d08			 
4d08			.EDIT: 
4d08				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4d08 40				db WORD_SYS_CORE+44             
4d09 aa 4d			dw .DEDIT            
4d0b 05				db 4 + 1 
4d0c .. 00			db "EDIT",0              
4d11				endm 
# End of macro CWHEAD
4d11			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4d11			 
4d11					; TODO does not copy from stack 
4d11					if DEBUG_FORTH_WORDS_KEY 
4d11						DMARK "EDT" 
4d11 f5				push af  
4d12 3a 26 4d			ld a, (.dmark)  
4d15 32 68 fe			ld (debug_mark),a  
4d18 3a 27 4d			ld a, (.dmark+1)  
4d1b 32 69 fe			ld (debug_mark+1),a  
4d1e 3a 28 4d			ld a, (.dmark+2)  
4d21 32 6a fe			ld (debug_mark+2),a  
4d24 18 03			jr .pastdmark  
4d26 ..			.dmark: db "EDT"  
4d29 f1			.pastdmark: pop af  
4d2a			endm  
# End of macro DMARK
4d2a						CALLMONITOR 
4d2a cd 6c fe			call debug_vector  
4d2d				endm  
# End of macro CALLMONITOR
4d2d					endif 
4d2d			 
4d2d					;FORTH_DSP 
4d2d					FORTH_DSP_VALUEHL 
4d2d cd fc 22			call macro_dsp_valuehl 
4d30				endm 
# End of macro FORTH_DSP_VALUEHL
4d30			;		inc hl    ; TODO do type check 
4d30			 
4d30			;		call get_word_hl 
4d30 e5					push hl 
4d31					if DEBUG_FORTH_WORDS 
4d31						DMARK "EDp" 
4d31 f5				push af  
4d32 3a 46 4d			ld a, (.dmark)  
4d35 32 68 fe			ld (debug_mark),a  
4d38 3a 47 4d			ld a, (.dmark+1)  
4d3b 32 69 fe			ld (debug_mark+1),a  
4d3e 3a 48 4d			ld a, (.dmark+2)  
4d41 32 6a fe			ld (debug_mark+2),a  
4d44 18 03			jr .pastdmark  
4d46 ..			.dmark: db "EDp"  
4d49 f1			.pastdmark: pop af  
4d4a			endm  
# End of macro DMARK
4d4a						CALLMONITOR 
4d4a cd 6c fe			call debug_vector  
4d4d				endm  
# End of macro CALLMONITOR
4d4d					endif 
4d4d				;	ld a, 0 
4d4d cd 2e 14				call strlenz 
4d50 23					inc hl 
4d51			 
4d51 06 00				ld b, 0 
4d53 4d					ld c, l 
4d54			 
4d54 e1					pop hl 
4d55 11 bc f3				ld de, os_input 
4d58					if DEBUG_FORTH_WORDS_KEY 
4d58						DMARK "EDc" 
4d58 f5				push af  
4d59 3a 6d 4d			ld a, (.dmark)  
4d5c 32 68 fe			ld (debug_mark),a  
4d5f 3a 6e 4d			ld a, (.dmark+1)  
4d62 32 69 fe			ld (debug_mark+1),a  
4d65 3a 6f 4d			ld a, (.dmark+2)  
4d68 32 6a fe			ld (debug_mark+2),a  
4d6b 18 03			jr .pastdmark  
4d6d ..			.dmark: db "EDc"  
4d70 f1			.pastdmark: pop af  
4d71			endm  
# End of macro DMARK
4d71						CALLMONITOR 
4d71 cd 6c fe			call debug_vector  
4d74				endm  
# End of macro CALLMONITOR
4d74					endif 
4d74 ed b0				ldir 
4d76			 
4d76			 
4d76 21 bc f3				ld hl, os_input 
4d79					;ld a, 0 
4d79					;ld (hl),a 
4d79 3a 5b fa				ld a,(f_cursor_ptr) 
4d7c 16 64				ld d, 100 
4d7e 0e 00				ld c, 0 
4d80 1e 28				ld e, 40 
4d82 cd fd 0f				call input_str 
4d85					; TODO perhaps do a type check and wrap in quotes if not a number 
4d85 21 bc f3				ld hl, os_input 
4d88					if DEBUG_FORTH_WORDS 
4d88						DMARK "ED1" 
4d88 f5				push af  
4d89 3a 9d 4d			ld a, (.dmark)  
4d8c 32 68 fe			ld (debug_mark),a  
4d8f 3a 9e 4d			ld a, (.dmark+1)  
4d92 32 69 fe			ld (debug_mark+1),a  
4d95 3a 9f 4d			ld a, (.dmark+2)  
4d98 32 6a fe			ld (debug_mark+2),a  
4d9b 18 03			jr .pastdmark  
4d9d ..			.dmark: db "ED1"  
4da0 f1			.pastdmark: pop af  
4da1			endm  
# End of macro DMARK
4da1						CALLMONITOR 
4da1 cd 6c fe			call debug_vector  
4da4				endm  
# End of macro CALLMONITOR
4da4					endif 
4da4 cd 73 21				call forth_push_str 
4da7					NEXTW 
4da7 c3 b2 24			jp macro_next 
4daa				endm 
# End of macro NEXTW
4daa			 
4daa			.DEDIT: 
4daa				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4daa 40				db WORD_SYS_CORE+44             
4dab 0c 4e			dw .ENDKEY            
4dad 06				db 5 + 1 
4dae .. 00			db "DEDIT",0              
4db4				endm 
# End of macro CWHEAD
4db4			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4db4			 
4db4					; TODO does not copy from stack 
4db4					if DEBUG_FORTH_WORDS_KEY 
4db4						DMARK "DED" 
4db4 f5				push af  
4db5 3a c9 4d			ld a, (.dmark)  
4db8 32 68 fe			ld (debug_mark),a  
4dbb 3a ca 4d			ld a, (.dmark+1)  
4dbe 32 69 fe			ld (debug_mark+1),a  
4dc1 3a cb 4d			ld a, (.dmark+2)  
4dc4 32 6a fe			ld (debug_mark+2),a  
4dc7 18 03			jr .pastdmark  
4dc9 ..			.dmark: db "DED"  
4dcc f1			.pastdmark: pop af  
4dcd			endm  
# End of macro DMARK
4dcd						CALLMONITOR 
4dcd cd 6c fe			call debug_vector  
4dd0				endm  
# End of macro CALLMONITOR
4dd0					endif 
4dd0			 
4dd0					;FORTH_DSP 
4dd0					FORTH_DSP_VALUEHL 
4dd0 cd fc 22			call macro_dsp_valuehl 
4dd3				endm 
# End of macro FORTH_DSP_VALUEHL
4dd3			;		inc hl    ; TODO do type check 
4dd3			 
4dd3			;		call get_word_hl 
4dd3 e5					push hl 
4dd4 e5					push hl 
4dd5					FORTH_DSP_POP 
4dd5 cd b4 23			call macro_forth_dsp_pop 
4dd8				endm 
# End of macro FORTH_DSP_POP
4dd8 e1					pop hl 
4dd9					if DEBUG_FORTH_WORDS 
4dd9						DMARK "EDp" 
4dd9 f5				push af  
4dda 3a ee 4d			ld a, (.dmark)  
4ddd 32 68 fe			ld (debug_mark),a  
4de0 3a ef 4d			ld a, (.dmark+1)  
4de3 32 69 fe			ld (debug_mark+1),a  
4de6 3a f0 4d			ld a, (.dmark+2)  
4de9 32 6a fe			ld (debug_mark+2),a  
4dec 18 03			jr .pastdmark  
4dee ..			.dmark: db "EDp"  
4df1 f1			.pastdmark: pop af  
4df2			endm  
# End of macro DMARK
4df2						CALLMONITOR 
4df2 cd 6c fe			call debug_vector  
4df5				endm  
# End of macro CALLMONITOR
4df5					endif 
4df5				;	ld a, 0 
4df5 cd 2e 14				call strlenz 
4df8 23					inc hl 
4df9			 
4df9 06 00				ld b, 0 
4dfb 4d					ld c, l 
4dfc			 
4dfc e1					pop hl 
4dfd			 
4dfd					;ld a, 0 
4dfd					;ld (hl),a 
4dfd 3a 5b fa				ld a,(f_cursor_ptr) 
4e00 16 64				ld d, 100 
4e02 0e 00				ld c, 0 
4e04 1e 28				ld e, 40 
4e06 cd fd 0f				call input_str 
4e09					; TODO perhaps do a type check and wrap in quotes if not a number 
4e09					NEXTW 
4e09 c3 b2 24			jp macro_next 
4e0c				endm 
# End of macro NEXTW
4e0c			 
4e0c			 
4e0c			.ENDKEY: 
4e0c			; eof 
4e0c			 
# End of file forth_words_key.asm
4e0c			include "forth_words_const.asm" 
4e0c			 
4e0c			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4e0c			 
4e0c			 
4e0c			.SPITIME: 
4e0c				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4e0c 77				db WORD_SYS_CORE+99             
4e0d 21 4e			dw .VA            
4e0f 08				db 7 + 1 
4e10 .. 00			db "SPITIME",0              
4e18				endm 
# End of macro CWHEAD
4e18			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4e18			; 
4e18			; | If using BANK devices then leave as is. 
4e18			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4e18			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4e18			 
4e18 21 61 fa				ld hl, spi_clktime  
4e1b cd 05 21				call forth_push_numhl 
4e1e			 
4e1e					NEXTW 
4e1e c3 b2 24			jp macro_next 
4e21				endm 
# End of macro NEXTW
4e21			 
4e21			 
4e21			.VA: 
4e21				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4e21 77				db WORD_SYS_CORE+99             
4e22 31 4e			dw .SYMBOL            
4e24 03				db 2 + 1 
4e25 .. 00			db "VA",0              
4e28				endm 
# End of macro CWHEAD
4e28			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4e28 21 25 fa				ld hl, cli_var_array 
4e2b cd 05 21				call forth_push_numhl 
4e2e			 
4e2e					NEXTW 
4e2e c3 b2 24			jp macro_next 
4e31				endm 
# End of macro NEXTW
4e31			 
4e31			.SYMBOL: 
4e31				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4e31 77				db WORD_SYS_CORE+99             
4e32 3b 4f			dw .ENDCONST            
4e34 07				db 6 + 1 
4e35 .. 00			db "SYMBOL",0              
4e3c				endm 
# End of macro CWHEAD
4e3c			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4e3c			; | 
4e3c			; | The value is the number reference and the final address is pushed to stack 
4e3c			 
4e3c			; | dw sym_table 
4e3c			; | dw nmi_vector 
4e3c			; | dw cli_autodisplay 
4e3c			; | dw cli_data_sp 
4e3c			; | dw cli_data_stack 
4e3c			; | dw cli_loop_sp 
4e3c			; | dw cli_loop_stack 
4e3c			; | dw cli_var_array 
4e3c			; | dw cursor_col 
4e3c			; | dw cursor_ptr 
4e3c			; | ; 10 
4e3c			; | dw cursor_row 
4e3c			; | dw debug_mark 
4e3c			; | dw display_fb0 
4e3c			; | dw display_fb1 
4e3c			; | dw display_fb2 
4e3c			; | dw display_fb3 
4e3c			; | dw display_fb_active 
4e3c			; | dw execscratch 
4e3c			; | dw f_cursor_ptr 
4e3c			; | dw hardware_word 
4e3c			; | ;20 
4e3c			; | dw input_at_cursor 
4e3c			; | dw input_at_pos 
4e3c			; | dw input_cur_flash 
4e3c			; | dw input_cur_onoff 
4e3c			; | dw input_cursor 
4e3c			; | dw input_display_size 
4e3c			; | dw input_len 
4e3c			; | dw input_ptr 
4e3c			; | dw input_size 
4e3c			; | dw input_start 
4e3c			; | ; 30 
4e3c			; | dw input_str 
4e3c			; | dw input_under_cursor 
4e3c			; | dw os_cli_cmd 
4e3c			; | dw os_cur_ptr 
4e3c			; | dw os_current_i 
4e3c			; | dw os_input 
4e3c			; | dw os_last_cmd 
4e3c			; | dw os_last_new_uword 
4e3c			; | dw debug_vector 
4e3c			; | dw os_view_hl 
4e3c			; | ;40 
4e3c			; | dw os_word_scratch 
4e3c			; | dw portbctl 
4e3c			; | dw portbdata 
4e3c			; | dw spi_cartdev 
4e3c			; | dw spi_cartdev2 
4e3c			; | dw spi_clktime 
4e3c			; | dw spi_device 
4e3c			; | dw spi_device_id 
4e3c			; | dw spi_portbyte 
4e3c			; | dw stackstore 
4e3c			; | ; 50 
4e3c			; | if STORAGE_SE 
4e3c			; | dw storage_actl 
4e3c			; | dw storage_adata 
4e3c			; | else 
4e3c			; | dw 0 
4e3c			; | dw 0 
4e3c			; | endif 
4e3c			; | dw storage_append 
4e3c			; | if STORAGE_SE 
4e3c			; | dw storage_bctl 
4e3c			; | else 
4e3c			; | dw 0 
4e3c			; | endif 
4e3c			; | dw store_bank_active 
4e3c			; | dw store_filecache 
4e3c			; | dw store_longread 
4e3c			; | dw store_openaddr 
4e3c			; | dw store_openext 
4e3c			; | dw store_openmaxext 
4e3c			; | ; 60 
4e3c			; | dw store_page 
4e3c			; | dw store_readbuf 
4e3c			; | dw store_readcont 
4e3c			; | dw store_readptr 
4e3c			; | dw store_tmpext 
4e3c			; | dw store_tmpid 
4e3c			; | dw store_tmppageid 
4e3c			; | dw malloc 
4e3c			; | dw free 
4e3c			; | dw cin 
4e3c			; | ; 70 
4e3c			; | dw cin_wait 
4e3c			; | dw forth_push_numhl 
4e3c			; | dw forth_push_str 
4e3c			 
4e3c					if DEBUG_FORTH_WORDS_KEY 
4e3c						DMARK "SYM" 
4e3c f5				push af  
4e3d 3a 51 4e			ld a, (.dmark)  
4e40 32 68 fe			ld (debug_mark),a  
4e43 3a 52 4e			ld a, (.dmark+1)  
4e46 32 69 fe			ld (debug_mark+1),a  
4e49 3a 53 4e			ld a, (.dmark+2)  
4e4c 32 6a fe			ld (debug_mark+2),a  
4e4f 18 03			jr .pastdmark  
4e51 ..			.dmark: db "SYM"  
4e54 f1			.pastdmark: pop af  
4e55			endm  
# End of macro DMARK
4e55						CALLMONITOR 
4e55 cd 6c fe			call debug_vector  
4e58				endm  
# End of macro CALLMONITOR
4e58					endif 
4e58			 
4e58					FORTH_DSP_VALUEHL 
4e58 cd fc 22			call macro_dsp_valuehl 
4e5b				endm 
# End of macro FORTH_DSP_VALUEHL
4e5b			 
4e5b 7d					ld a, l     
4e5c			 
4e5c			 
4e5c					if DEBUG_FORTH_WORDS 
4e5c						DMARK "SY1" 
4e5c f5				push af  
4e5d 3a 71 4e			ld a, (.dmark)  
4e60 32 68 fe			ld (debug_mark),a  
4e63 3a 72 4e			ld a, (.dmark+1)  
4e66 32 69 fe			ld (debug_mark+1),a  
4e69 3a 73 4e			ld a, (.dmark+2)  
4e6c 32 6a fe			ld (debug_mark+2),a  
4e6f 18 03			jr .pastdmark  
4e71 ..			.dmark: db "SY1"  
4e74 f1			.pastdmark: pop af  
4e75			endm  
# End of macro DMARK
4e75						CALLMONITOR 
4e75 cd 6c fe			call debug_vector  
4e78				endm  
# End of macro CALLMONITOR
4e78					endif 
4e78					 
4e78 f5					push af	 
4e79					FORTH_DSP_POP 
4e79 cd b4 23			call macro_forth_dsp_pop 
4e7c				endm 
# End of macro FORTH_DSP_POP
4e7c f1					pop af 
4e7d			 
4e7d cb 27				sla a  
4e7f				 
4e7f					 
4e7f					if DEBUG_FORTH_WORDS 
4e7f						DMARK "SY" 
4e7f f5				push af  
4e80 3a 94 4e			ld a, (.dmark)  
4e83 32 68 fe			ld (debug_mark),a  
4e86 3a 95 4e			ld a, (.dmark+1)  
4e89 32 69 fe			ld (debug_mark+1),a  
4e8c 3a 96 4e			ld a, (.dmark+2)  
4e8f 32 6a fe			ld (debug_mark+2),a  
4e92 18 02			jr .pastdmark  
4e94 ..			.dmark: db "SY"  
4e96 f1			.pastdmark: pop af  
4e97			endm  
# End of macro DMARK
4e97						CALLMONITOR 
4e97 cd 6c fe			call debug_vector  
4e9a				endm  
# End of macro CALLMONITOR
4e9a					endif 
4e9a			 
4e9a 21 a9 4e				ld hl, sym_table 
4e9d cd d0 0f				call addatohl 
4ea0 cd 34 24				call loadwordinhl 
4ea3 cd 05 21				call forth_push_numhl 
4ea6			 
4ea6			 
4ea6				       NEXTW 
4ea6 c3 b2 24			jp macro_next 
4ea9				endm 
# End of macro NEXTW
4ea9			 
4ea9			sym_table: 
4ea9			 
4ea9			; 0 
4ea9 a9 4e		dw sym_table 
4eab 6f fe		dw nmi_vector 
4ead 39 fa		dw cli_autodisplay 
4eaf eb f9		dw cli_data_sp 
4eb1 25 f7		dw cli_data_stack 
4eb3 ed f9		dw cli_loop_sp 
4eb5 27 f9		dw cli_loop_stack 
4eb7 25 fa		dw cli_var_array 
4eb9 c2 fb		dw cursor_col 
4ebb c0 fb		dw cursor_ptr 
4ebd			; 10 
4ebd c1 fb		dw cursor_row 
4ebf 68 fe		dw debug_mark 
4ec1 ae fd		dw display_fb0 
4ec3 0d fd		dw display_fb1 
4ec5 cb fb		dw display_fb2 
4ec7 6c fc		dw display_fb3 
4ec9 c9 fb		dw display_fb_active 
4ecb bd f2		dw execscratch 
4ecd 5b fa		dw f_cursor_ptr 
4ecf 72 fe		dw hardware_word 
4ed1			;20 
4ed1 5f fe		dw input_at_cursor 
4ed3 61 fe		dw input_at_pos 
4ed5 5d fe		dw input_cur_flash 
4ed7 5c fe		dw input_cur_onoff 
4ed9 52 fe		dw input_cursor 
4edb 62 fe		dw input_display_size 
4edd 57 fe		dw input_len 
4edf 66 fe		dw input_ptr 
4ee1 63 fe		dw input_size 
4ee3 64 fe		dw input_start 
4ee5			; 30 
4ee5 fd 0f		dw input_str 
4ee7 60 fe		dw input_under_cursor 
4ee9 e5 f4		dw os_cli_cmd 
4eeb e1 f4		dw os_cur_ptr 
4eed e3 f4		dw os_current_i 
4eef bc f3		dw os_input 
4ef1 e4 f5		dw os_last_cmd 
4ef3 bb f4		dw os_last_new_uword 
4ef5 6c fe		dw debug_vector 
4ef7 ac f1		dw os_view_hl 
4ef9			;40 
4ef9 c3 f4		dw os_word_scratch 
4efb c3 00		dw portbctl 
4efd c1 00		dw portbdata 
4eff 60 fa		dw spi_cartdev 
4f01 5f fa		dw spi_cartdev2 
4f03 61 fa		dw spi_clktime 
4f05 5d fa		dw spi_device 
4f07 5c fa		dw spi_device_id 
4f09 5e fa		dw spi_portbyte 
4f0b a4 fb		dw stackstore 
4f0d			; 50 
4f0d			if STORAGE_SE 
4f0d 82 00		dw storage_actl 
4f0f 80 00		dw storage_adata 
4f11			else 
4f11			dw 0 
4f11			dw 0 
4f11			endif 
4f11 56 0b		dw storage_append 
4f13			if STORAGE_SE 
4f13 83 00		dw storage_bctl 
4f15			else 
4f15			dw 0 
4f15			endif 
4f15 90 fb		dw store_bank_active 
4f17 64 fa		dw store_filecache 
4f19 72 fa		dw store_longread 
4f1b 68 fa		dw store_openaddr 
4f1d 67 fa		dw store_openext 
4f1f 66 fa		dw store_openmaxext 
4f21			; 60 
4f21 77 fa		dw store_page 
4f23 73 fa		dw store_readbuf 
4f25 6a fa		dw store_readcont 
4f27 75 fa		dw store_readptr 
4f29 6a fa		dw store_tmpext 
4f2b 6b fa		dw store_tmpid 
4f2d 62 fa		dw store_tmppageid 
4f2f 97 14		dw malloc 
4f31 61 15		dw free 
4f33 d4 79		dw cin 
4f35			; 70 
4f35 c3 79		dw cin_wait 
4f37 05 21		dw forth_push_numhl 
4f39 73 21		dw forth_push_str 
4f3b			 
4f3b			 
4f3b			.ENDCONST: 
4f3b			 
4f3b			; eof 
4f3b			 
4f3b			 
# End of file forth_words_const.asm
4f3b			 
4f3b			if STORAGE_SE 
4f3b			   	include "forth_words_storage.asm" 
4f3b			 
4f3b			; | ## Fixed Storage Words 
4f3b			 
4f3b			.RENAME: 
4f3b			  
4f3b				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4f3b 3a				db WORD_SYS_CORE+38             
4f3c 31 50			dw .RECORD            
4f3e 07				db 6 + 1 
4f3f .. 00			db "RENAME",0              
4f46				endm 
# End of macro CWHEAD
4f46			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4f46			; | | Compatible with PicoSPINet  
4f46					if DEBUG_FORTH_WORDS_KEY 
4f46						DMARK "REN" 
4f46 f5				push af  
4f47 3a 5b 4f			ld a, (.dmark)  
4f4a 32 68 fe			ld (debug_mark),a  
4f4d 3a 5c 4f			ld a, (.dmark+1)  
4f50 32 69 fe			ld (debug_mark+1),a  
4f53 3a 5d 4f			ld a, (.dmark+2)  
4f56 32 6a fe			ld (debug_mark+2),a  
4f59 18 03			jr .pastdmark  
4f5b ..			.dmark: db "REN"  
4f5e f1			.pastdmark: pop af  
4f5f			endm  
# End of macro DMARK
4f5f						CALLMONITOR 
4f5f cd 6c fe			call debug_vector  
4f62				endm  
# End of macro CALLMONITOR
4f62					endif 
4f62			 
4f62			 
4f62					; preserve some internal vars used by other file handing routines 
4f62			 
4f62 2a 68 fa				ld hl, (store_openaddr) 
4f65 e5					push hl 
4f66 3a 6a fa				ld a, (store_readcont) 
4f69 f5					push af 
4f6a			 
4f6a					FORTH_DSP_VALUEHL 
4f6a cd fc 22			call macro_dsp_valuehl 
4f6d				endm 
# End of macro FORTH_DSP_VALUEHL
4f6d			 
4f6d					; move ext and id around for the file header 
4f6d			 
4f6d 65					ld h, l 
4f6e 2e 00				ld l, 0 
4f70			 
4f70 e5					push hl    ; id 
4f71			 
4f71					FORTH_DSP_POP 
4f71 cd b4 23			call macro_forth_dsp_pop 
4f74				endm 
# End of macro FORTH_DSP_POP
4f74			 
4f74					; Locate the file header 
4f74			 
4f74 e1					pop hl 
4f75 e5					push hl 
4f76 11 77 fa				ld de, store_page      ; get block zero of file 
4f79					if DEBUG_FORTH_WORDS 
4f79						DMARK "REr" 
4f79 f5				push af  
4f7a 3a 8e 4f			ld a, (.dmark)  
4f7d 32 68 fe			ld (debug_mark),a  
4f80 3a 8f 4f			ld a, (.dmark+1)  
4f83 32 69 fe			ld (debug_mark+1),a  
4f86 3a 90 4f			ld a, (.dmark+2)  
4f89 32 6a fe			ld (debug_mark+2),a  
4f8c 18 03			jr .pastdmark  
4f8e ..			.dmark: db "REr"  
4f91 f1			.pastdmark: pop af  
4f92			endm  
# End of macro DMARK
4f92						CALLMONITOR 
4f92 cd 6c fe			call debug_vector  
4f95				endm  
# End of macro CALLMONITOR
4f95					endif 
4f95 cd bf 09				call storage_read 
4f98			 
4f98 cd f9 0f			call ishlzero 
4f9b 20 05			jr nz, .rnfound 
4f9d			 
4f9d				; file does not exist so indicate with 255 extents in use 
4f9d			 
4f9d 3e ff			ld a, 255 
4f9f e1				pop hl ; clear dup hl 
4fa0 18 7b			jr .skiprneof 
4fa2			 
4fa2			 
4fa2			.rnfound: 
4fa2					; file found so rename 
4fa2			 
4fa2					FORTH_DSP_VALUEHL 
4fa2 cd fc 22			call macro_dsp_valuehl 
4fa5				endm 
# End of macro FORTH_DSP_VALUEHL
4fa5			 
4fa5 e5				push hl 
4fa6 3e 00			ld a, 0 
4fa8 cd 39 14			call strlent 
4fab 23				inc hl   ; cover zero term 
4fac 06 00			ld b,0 
4fae 4d				ld c,l 
4faf e1				pop hl 
4fb0 11 7a fa				ld de, store_page + 3 
4fb3 ed b0				ldir 
4fb5			 
4fb5 11 77 fa				ld de, store_page 
4fb8					if DEBUG_FORTH_WORDS 
4fb8						DMARK "RER" 
4fb8 f5				push af  
4fb9 3a cd 4f			ld a, (.dmark)  
4fbc 32 68 fe			ld (debug_mark),a  
4fbf 3a ce 4f			ld a, (.dmark+1)  
4fc2 32 69 fe			ld (debug_mark+1),a  
4fc5 3a cf 4f			ld a, (.dmark+2)  
4fc8 32 6a fe			ld (debug_mark+2),a  
4fcb 18 03			jr .pastdmark  
4fcd ..			.dmark: db "RER"  
4fd0 f1			.pastdmark: pop af  
4fd1			endm  
# End of macro DMARK
4fd1						CALLMONITOR 
4fd1 cd 6c fe			call debug_vector  
4fd4				endm  
# End of macro CALLMONITOR
4fd4					endif 
4fd4			 
4fd4 e1					pop hl    ; get orig file id and mangle it for find id 
4fd5 55					ld d, l 
4fd6 5c					ld e, h 
4fd7			 
4fd7 21 00 00				ld hl, 0 
4fda					if DEBUG_FORTH_WORDS 
4fda						DMARK "REf" 
4fda f5				push af  
4fdb 3a ef 4f			ld a, (.dmark)  
4fde 32 68 fe			ld (debug_mark),a  
4fe1 3a f0 4f			ld a, (.dmark+1)  
4fe4 32 69 fe			ld (debug_mark+1),a  
4fe7 3a f1 4f			ld a, (.dmark+2)  
4fea 32 6a fe			ld (debug_mark+2),a  
4fed 18 03			jr .pastdmark  
4fef ..			.dmark: db "REf"  
4ff2 f1			.pastdmark: pop af  
4ff3			endm  
# End of macro DMARK
4ff3						CALLMONITOR 
4ff3 cd 6c fe			call debug_vector  
4ff6				endm  
# End of macro CALLMONITOR
4ff6					endif 
4ff6 cd 99 07				call storage_findnextid 
4ff9 11 77 fa				ld de, store_page 
4ffc					if DEBUG_FORTH_WORDS 
4ffc						DMARK "REw" 
4ffc f5				push af  
4ffd 3a 11 50			ld a, (.dmark)  
5000 32 68 fe			ld (debug_mark),a  
5003 3a 12 50			ld a, (.dmark+1)  
5006 32 69 fe			ld (debug_mark+1),a  
5009 3a 13 50			ld a, (.dmark+2)  
500c 32 6a fe			ld (debug_mark+2),a  
500f 18 03			jr .pastdmark  
5011 ..			.dmark: db "REw"  
5014 f1			.pastdmark: pop af  
5015			endm  
# End of macro DMARK
5015						CALLMONITOR 
5015 cd 6c fe			call debug_vector  
5018				endm  
# End of macro CALLMONITOR
5018					endif 
5018 cd cb 04				call storage_write_block 
501b			 
501b 3e 00				ld a, 0 
501d			.skiprneof: 
501d					; drop file name 
501d					FORTH_DSP_POP 
501d cd b4 23			call macro_forth_dsp_pop 
5020				endm 
# End of macro FORTH_DSP_POP
5020			 
5020 6f					ld l, a 
5021 26 00				ld h, 0 
5023 cd 05 21				call forth_push_numhl 
5026			 
5026			 
5026 f1					pop af 
5027 32 6a fa				ld (store_readcont),a 
502a e1					pop hl 
502b 22 68 fa				ld (store_openaddr), hl 
502e						 
502e				NEXTW 
502e c3 b2 24			jp macro_next 
5031				endm 
# End of macro NEXTW
5031			.RECORD: 
5031			  
5031				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
5031 3a				db WORD_SYS_CORE+38             
5032 d5 50			dw .BREAD            
5034 07				db 6 + 1 
5035 .. 00			db "RECORD",0              
503c				endm 
# End of macro CWHEAD
503c			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
503c			; | | Compatible with PicoSPINet  
503c			 
503c					if DEBUG_FORTH_WORDS_KEY 
503c						DMARK "REC" 
503c f5				push af  
503d 3a 51 50			ld a, (.dmark)  
5040 32 68 fe			ld (debug_mark),a  
5043 3a 52 50			ld a, (.dmark+1)  
5046 32 69 fe			ld (debug_mark+1),a  
5049 3a 53 50			ld a, (.dmark+2)  
504c 32 6a fe			ld (debug_mark+2),a  
504f 18 03			jr .pastdmark  
5051 ..			.dmark: db "REC"  
5054 f1			.pastdmark: pop af  
5055			endm  
# End of macro DMARK
5055						CALLMONITOR 
5055 cd 6c fe			call debug_vector  
5058				endm  
# End of macro CALLMONITOR
5058					endif 
5058			 
5058					FORTH_DSP_VALUEHL 
5058 cd fc 22			call macro_dsp_valuehl 
505b				endm 
# End of macro FORTH_DSP_VALUEHL
505b			 
505b e5					push hl    ; id 
505c			 
505c					FORTH_DSP_POP 
505c cd b4 23			call macro_forth_dsp_pop 
505f				endm 
# End of macro FORTH_DSP_POP
505f			 
505f					FORTH_DSP_VALUEHL 
505f cd fc 22			call macro_dsp_valuehl 
5062				endm 
# End of macro FORTH_DSP_VALUEHL
5062			 
5062					FORTH_DSP_POP 
5062 cd b4 23			call macro_forth_dsp_pop 
5065				endm 
# End of macro FORTH_DSP_POP
5065			 
5065 d1					pop de     ; get file id 
5066			 
5066					; e = file id 
5066					; l = file extent 
5066			 
5066			 
5066					; construct request to access file extent 
5066			 
5066			;		ld a, e 
5066 63					ld h, e 
5067					 
5067					 
5067					 
5067			 
5067					; e has id 
5067			 
5067 11 77 fa			ld de, store_page 
506a					if DEBUG_FORTH_WORDS 
506a						DMARK "REr" 
506a f5				push af  
506b 3a 7f 50			ld a, (.dmark)  
506e 32 68 fe			ld (debug_mark),a  
5071 3a 80 50			ld a, (.dmark+1)  
5074 32 69 fe			ld (debug_mark+1),a  
5077 3a 81 50			ld a, (.dmark+2)  
507a 32 6a fe			ld (debug_mark+2),a  
507d 18 03			jr .pastdmark  
507f ..			.dmark: db "REr"  
5082 f1			.pastdmark: pop af  
5083			endm  
# End of macro DMARK
5083						CALLMONITOR 
5083 cd 6c fe			call debug_vector  
5086				endm  
# End of macro CALLMONITOR
5086					endif 
5086 cd bf 09				call storage_read 
5089 cd f9 0f			call ishlzero 
508c 28 22			jr z, .recnotfound 
508e			 
508e			 
508e					if DEBUG_FORTH_WORDS 
508e						DMARK "REe" 
508e f5				push af  
508f 3a a3 50			ld a, (.dmark)  
5092 32 68 fe			ld (debug_mark),a  
5095 3a a4 50			ld a, (.dmark+1)  
5098 32 69 fe			ld (debug_mark+1),a  
509b 3a a5 50			ld a, (.dmark+2)  
509e 32 6a fe			ld (debug_mark+2),a  
50a1 18 03			jr .pastdmark  
50a3 ..			.dmark: db "REe"  
50a6 f1			.pastdmark: pop af  
50a7			endm  
# End of macro DMARK
50a7						CALLMONITOR 
50a7 cd 6c fe			call debug_vector  
50aa				endm  
# End of macro CALLMONITOR
50aa					endif 
50aa cd 73 21			call forth_push_str 
50ad			 
50ad					NEXTW 
50ad c3 b2 24			jp macro_next 
50b0				endm 
# End of macro NEXTW
50b0			 
50b0			.recnotfound: 
50b0					if DEBUG_FORTH_WORDS 
50b0						DMARK "REf" 
50b0 f5				push af  
50b1 3a c5 50			ld a, (.dmark)  
50b4 32 68 fe			ld (debug_mark),a  
50b7 3a c6 50			ld a, (.dmark+1)  
50ba 32 69 fe			ld (debug_mark+1),a  
50bd 3a c7 50			ld a, (.dmark+2)  
50c0 32 6a fe			ld (debug_mark+2),a  
50c3 18 03			jr .pastdmark  
50c5 ..			.dmark: db "REf"  
50c8 f1			.pastdmark: pop af  
50c9			endm  
# End of macro DMARK
50c9						CALLMONITOR 
50c9 cd 6c fe			call debug_vector  
50cc				endm  
# End of macro CALLMONITOR
50cc					endif 
50cc 21 ff 00			ld hl, 255 
50cf cd 05 21			call forth_push_numhl 
50d2				NEXTW 
50d2 c3 b2 24			jp macro_next 
50d5				endm 
# End of macro NEXTW
50d5			 
50d5			 
50d5			.BREAD: 
50d5			  
50d5				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
50d5 3a				db WORD_SYS_CORE+38             
50d6 58 51			dw .BWRITE            
50d8 06				db 5 + 1 
50d9 .. 00			db "BREAD",0              
50df				endm 
# End of macro CWHEAD
50df			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
50df			; | | Compatible with PicoSPINet  
50df				 
50df					if DEBUG_FORTH_WORDS_KEY 
50df						DMARK "BRD" 
50df f5				push af  
50e0 3a f4 50			ld a, (.dmark)  
50e3 32 68 fe			ld (debug_mark),a  
50e6 3a f5 50			ld a, (.dmark+1)  
50e9 32 69 fe			ld (debug_mark+1),a  
50ec 3a f6 50			ld a, (.dmark+2)  
50ef 32 6a fe			ld (debug_mark+2),a  
50f2 18 03			jr .pastdmark  
50f4 ..			.dmark: db "BRD"  
50f7 f1			.pastdmark: pop af  
50f8			endm  
# End of macro DMARK
50f8						CALLMONITOR 
50f8 cd 6c fe			call debug_vector  
50fb				endm  
# End of macro CALLMONITOR
50fb					endif 
50fb			 
50fb				FORTH_DSP_VALUEHL 
50fb cd fc 22			call macro_dsp_valuehl 
50fe				endm 
# End of macro FORTH_DSP_VALUEHL
50fe			 
50fe				FORTH_DSP_POP 
50fe cd b4 23			call macro_forth_dsp_pop 
5101				endm 
# End of macro FORTH_DSP_POP
5101			 
5101				; calc block address 
5101			 
5101 eb				ex de, hl 
5102 3e 40			ld a, STORE_BLOCK_PHY 
5104 cd 53 0f			call Mult16 
5107			 
5107			 
5107 11 77 fa			ld de, store_page 
510a			 
510a					if DEBUG_FORTH_WORDS 
510a						DMARK "BR1" 
510a f5				push af  
510b 3a 1f 51			ld a, (.dmark)  
510e 32 68 fe			ld (debug_mark),a  
5111 3a 20 51			ld a, (.dmark+1)  
5114 32 69 fe			ld (debug_mark+1),a  
5117 3a 21 51			ld a, (.dmark+2)  
511a 32 6a fe			ld (debug_mark+2),a  
511d 18 03			jr .pastdmark  
511f ..			.dmark: db "BR1"  
5122 f1			.pastdmark: pop af  
5123			endm  
# End of macro DMARK
5123						CALLMONITOR 
5123 cd 6c fe			call debug_vector  
5126				endm  
# End of macro CALLMONITOR
5126					endif 
5126			 
5126 cd 66 04			call storage_read_block 
5129			 
5129 cd f9 0f			call ishlzero 
512c 20 05			jr nz, .brfound 
512e			 
512e cd 05 21			call forth_push_numhl 
5131 18 22			jr .brdone 
5133			 
5133			 
5133			.brfound: 
5133 21 79 fa		        ld hl, store_page+2 
5136			 
5136					if DEBUG_FORTH_WORDS 
5136						DMARK "BR2" 
5136 f5				push af  
5137 3a 4b 51			ld a, (.dmark)  
513a 32 68 fe			ld (debug_mark),a  
513d 3a 4c 51			ld a, (.dmark+1)  
5140 32 69 fe			ld (debug_mark+1),a  
5143 3a 4d 51			ld a, (.dmark+2)  
5146 32 6a fe			ld (debug_mark+2),a  
5149 18 03			jr .pastdmark  
514b ..			.dmark: db "BR2"  
514e f1			.pastdmark: pop af  
514f			endm  
# End of macro DMARK
514f						CALLMONITOR 
514f cd 6c fe			call debug_vector  
5152				endm  
# End of macro CALLMONITOR
5152					endif 
5152			 
5152 cd 73 21			call forth_push_str 
5155			 
5155			 
5155			.brdone: 
5155			 
5155					NEXTW 
5155 c3 b2 24			jp macro_next 
5158				endm 
# End of macro NEXTW
5158			.BWRITE: 
5158				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
5158 3a				db WORD_SYS_CORE+38             
5159 ed 51			dw .BUPD            
515b 07				db 6 + 1 
515c .. 00			db "BWRITE",0              
5163				endm 
# End of macro CWHEAD
5163			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
5163			; | | Compatible with PicoSPINet  
5163			 
5163					if DEBUG_FORTH_WORDS_KEY 
5163						DMARK "BWR" 
5163 f5				push af  
5164 3a 78 51			ld a, (.dmark)  
5167 32 68 fe			ld (debug_mark),a  
516a 3a 79 51			ld a, (.dmark+1)  
516d 32 69 fe			ld (debug_mark+1),a  
5170 3a 7a 51			ld a, (.dmark+2)  
5173 32 6a fe			ld (debug_mark+2),a  
5176 18 03			jr .pastdmark  
5178 ..			.dmark: db "BWR"  
517b f1			.pastdmark: pop af  
517c			endm  
# End of macro DMARK
517c						CALLMONITOR 
517c cd 6c fe			call debug_vector  
517f				endm  
# End of macro CALLMONITOR
517f					endif 
517f			 
517f				FORTH_DSP_VALUEHL 
517f cd fc 22			call macro_dsp_valuehl 
5182				endm 
# End of macro FORTH_DSP_VALUEHL
5182			 
5182				; calc block address 
5182			 
5182 eb				ex de, hl 
5183 3e 40			ld a, STORE_BLOCK_PHY 
5185 cd 53 0f			call Mult16 
5188			 
5188 e5				push hl         ; address 
5189			 
5189				FORTH_DSP_POP 
5189 cd b4 23			call macro_forth_dsp_pop 
518c				endm 
# End of macro FORTH_DSP_POP
518c			 
518c				FORTH_DSP_VALUEHL 
518c cd fc 22			call macro_dsp_valuehl 
518f				endm 
# End of macro FORTH_DSP_VALUEHL
518f			 
518f				FORTH_DSP_POP 
518f cd b4 23			call macro_forth_dsp_pop 
5192				endm 
# End of macro FORTH_DSP_POP
5192			 
5192 cd a2 0c			call storage_clear_page 
5195			 
5195				; copy string to store page 
5195			 
5195 e5				push hl     ; save string address 
5196			 
5196 3e 00			ld a, 0 
5198 cd 39 14			call strlent 
519b			 
519b 23				inc hl 
519c			 
519c 4d				ld c, l 
519d 06 00			ld b, 0 
519f			 
519f e1				pop hl 
51a0 11 79 fa			ld de, store_page + 2 
51a3					if DEBUG_FORTH_WORDS 
51a3						DMARK "BW1" 
51a3 f5				push af  
51a4 3a b8 51			ld a, (.dmark)  
51a7 32 68 fe			ld (debug_mark),a  
51aa 3a b9 51			ld a, (.dmark+1)  
51ad 32 69 fe			ld (debug_mark+1),a  
51b0 3a ba 51			ld a, (.dmark+2)  
51b3 32 6a fe			ld (debug_mark+2),a  
51b6 18 03			jr .pastdmark  
51b8 ..			.dmark: db "BW1"  
51bb f1			.pastdmark: pop af  
51bc			endm  
# End of macro DMARK
51bc						CALLMONITOR 
51bc cd 6c fe			call debug_vector  
51bf				endm  
# End of macro CALLMONITOR
51bf					endif 
51bf ed b0			ldir 
51c1			 
51c1			 
51c1				; poke the start of the block with flags to prevent high level file ops hitting the block 
51c1			 
51c1 21 ff ff			ld hl, $ffff 
51c4			 
51c4 22 77 fa			ld (store_page), hl	 
51c7				 
51c7 e1				pop hl    ; get address 
51c8 11 77 fa			ld de, store_page 
51cb			 
51cb					if DEBUG_FORTH_WORDS 
51cb						DMARK "BW2" 
51cb f5				push af  
51cc 3a e0 51			ld a, (.dmark)  
51cf 32 68 fe			ld (debug_mark),a  
51d2 3a e1 51			ld a, (.dmark+1)  
51d5 32 69 fe			ld (debug_mark+1),a  
51d8 3a e2 51			ld a, (.dmark+2)  
51db 32 6a fe			ld (debug_mark+2),a  
51de 18 03			jr .pastdmark  
51e0 ..			.dmark: db "BW2"  
51e3 f1			.pastdmark: pop af  
51e4			endm  
# End of macro DMARK
51e4						CALLMONITOR 
51e4 cd 6c fe			call debug_vector  
51e7				endm  
# End of macro CALLMONITOR
51e7					endif 
51e7			 
51e7 cd cb 04			call storage_write_block 
51ea			 
51ea					NEXTW 
51ea c3 b2 24			jp macro_next 
51ed				endm 
# End of macro NEXTW
51ed			 
51ed			.BUPD: 
51ed				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
51ed 3a				db WORD_SYS_CORE+38             
51ee 43 52			dw .BYID            
51f0 05				db 4 + 1 
51f1 .. 00			db "BUPD",0              
51f6				endm 
# End of macro CWHEAD
51f6			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
51f6			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
51f6			; | | or completely different file system structure. 
51f6			; | | Compatible with PicoSPINet  
51f6			 
51f6					if DEBUG_FORTH_WORDS_KEY 
51f6						DMARK "BUD" 
51f6 f5				push af  
51f7 3a 0b 52			ld a, (.dmark)  
51fa 32 68 fe			ld (debug_mark),a  
51fd 3a 0c 52			ld a, (.dmark+1)  
5200 32 69 fe			ld (debug_mark+1),a  
5203 3a 0d 52			ld a, (.dmark+2)  
5206 32 6a fe			ld (debug_mark+2),a  
5209 18 03			jr .pastdmark  
520b ..			.dmark: db "BUD"  
520e f1			.pastdmark: pop af  
520f			endm  
# End of macro DMARK
520f						CALLMONITOR 
520f cd 6c fe			call debug_vector  
5212				endm  
# End of macro CALLMONITOR
5212					endif 
5212			 
5212				FORTH_DSP_VALUEHL 
5212 cd fc 22			call macro_dsp_valuehl 
5215				endm 
# End of macro FORTH_DSP_VALUEHL
5215			 
5215				; calc block address 
5215			 
5215 eb				ex de, hl 
5216 3e 40			ld a, STORE_BLOCK_PHY 
5218 cd 53 0f			call Mult16 
521b			 
521b				FORTH_DSP_POP 
521b cd b4 23			call macro_forth_dsp_pop 
521e				endm 
# End of macro FORTH_DSP_POP
521e			 
521e			 
521e 11 77 fa			ld de, store_page 
5221			 
5221					if DEBUG_FORTH_WORDS 
5221						DMARK "BUe" 
5221 f5				push af  
5222 3a 36 52			ld a, (.dmark)  
5225 32 68 fe			ld (debug_mark),a  
5228 3a 37 52			ld a, (.dmark+1)  
522b 32 69 fe			ld (debug_mark+1),a  
522e 3a 38 52			ld a, (.dmark+2)  
5231 32 6a fe			ld (debug_mark+2),a  
5234 18 03			jr .pastdmark  
5236 ..			.dmark: db "BUe"  
5239 f1			.pastdmark: pop af  
523a			endm  
# End of macro DMARK
523a						CALLMONITOR 
523a cd 6c fe			call debug_vector  
523d				endm  
# End of macro CALLMONITOR
523d					endif 
523d			 
523d cd cb 04			call storage_write_block 
5240			 
5240					NEXTW 
5240 c3 b2 24			jp macro_next 
5243				endm 
# End of macro NEXTW
5243			 
5243			.BYID: 
5243			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
5243			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
5243			; 
5243			;		 
5243			;		if DEBUG_FORTH_WORDS_KEY 
5243			;			DMARK "BYID" 
5243			;			CALLMONITOR 
5243			;		endif 
5243			; 
5243			;		; get direct address 
5243			; 
5243			;		FORTH_DSP_VALUEHL 
5243			; 
5243			;		FORTH_DSP_POP 
5243			; 
5243			;	; calc block address 
5243			; 
5243			;	ex de, hl 
5243			;	ld a, STORE_BLOCK_PHY 
5243			;	call Mult16 
5243			;	;	do BREAD with number as param 
5243			;	; push the file name	 
5243			;	ld de, store_page 
5243			;	call storage_read_block 
5243			 ;       ld hl, store_page+2 
5243			; 
5243			; 
5243			;		NEXTW 
5243			;.BYNAME: 
5243				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
5243 3a				db WORD_SYS_CORE+38             
5244 5c 52			dw .DIR            
5246 06				db 5 + 1 
5247 .. 00			db "GETID",0              
524d				endm 
# End of macro CWHEAD
524d			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
524d			; | | Compatible with PicoSPINet  
524d			 
524d					; get pointer to file name to seek 
524d			 
524d					FORTH_DSP_VALUEHL 
524d cd fc 22			call macro_dsp_valuehl 
5250				endm 
# End of macro FORTH_DSP_VALUEHL
5250			 
5250			 
5250 cd 8d 03				call storage_getid  
5253			 
5253					FORTH_DSP_POP 
5253 cd b4 23			call macro_forth_dsp_pop 
5256				endm 
# End of macro FORTH_DSP_POP
5256			 
5256 cd 05 21				call forth_push_numhl 
5259			 
5259					NEXTW 
5259 c3 b2 24			jp macro_next 
525c				endm 
# End of macro NEXTW
525c			; 
525c			.DIR: 
525c				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
525c 3a				db WORD_SYS_CORE+38             
525d 60 53			dw .SAVE            
525f 04				db 3 + 1 
5260 .. 00			db "DIR",0              
5264				endm 
# End of macro CWHEAD
5264			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
5264			; | | Compatible with PicoSPINet  
5264			 
5264					if DEBUG_FORTH_WORDS_KEY 
5264						DMARK "DIR" 
5264 f5				push af  
5265 3a 79 52			ld a, (.dmark)  
5268 32 68 fe			ld (debug_mark),a  
526b 3a 7a 52			ld a, (.dmark+1)  
526e 32 69 fe			ld (debug_mark+1),a  
5271 3a 7b 52			ld a, (.dmark+2)  
5274 32 6a fe			ld (debug_mark+2),a  
5277 18 03			jr .pastdmark  
5279 ..			.dmark: db "DIR"  
527c f1			.pastdmark: pop af  
527d			endm  
# End of macro DMARK
527d						CALLMONITOR 
527d cd 6c fe			call debug_vector  
5280				endm  
# End of macro CALLMONITOR
5280					endif 
5280 cd 17 05			call storage_get_block_0 
5283			 
5283 21 77 fa			ld hl, store_page     ; get current id count 
5286 46				ld b, (hl) 
5287 0e 00			ld c, 0    ; count of files   
5289					if DEBUG_FORTH_WORDS 
5289						DMARK "DI1" 
5289 f5				push af  
528a 3a 9e 52			ld a, (.dmark)  
528d 32 68 fe			ld (debug_mark),a  
5290 3a 9f 52			ld a, (.dmark+1)  
5293 32 69 fe			ld (debug_mark+1),a  
5296 3a a0 52			ld a, (.dmark+2)  
5299 32 6a fe			ld (debug_mark+2),a  
529c 18 03			jr .pastdmark  
529e ..			.dmark: db "DI1"  
52a1 f1			.pastdmark: pop af  
52a2			endm  
# End of macro DMARK
52a2						CALLMONITOR 
52a2 cd 6c fe			call debug_vector  
52a5				endm  
# End of macro CALLMONITOR
52a5					endif 
52a5			 
52a5				; check for empty drive 
52a5			 
52a5 3e 00			ld a, 0 
52a7 b8				cp b 
52a8 ca 16 53			jp z, .dirdone 
52ab			 
52ab				; for each of the current ids do a search for them and if found push to stack 
52ab			 
52ab c5			.diritem:	push bc 
52ac 21 40 00				ld hl, STORE_BLOCK_PHY 
52af 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
52b1 58					ld e,b 
52b2			 
52b2			;		if DEBUG_FORTH_WORDS 
52b2			;			DMARK "DI2" 
52b2			;			CALLMONITOR 
52b2			;		endif 
52b2			 
52b2 cd 99 07				call storage_findnextid 
52b5			 
52b5			;		if DEBUG_FORTH_WORDS 
52b5			;			DMARK "DI3" 
52b5			;			CALLMONITOR 
52b5			;		endif 
52b5			 
52b5					; if found hl will be non zero 
52b5			 
52b5 cd f9 0f				call ishlzero 
52b8			;		ld a, l 
52b8			;		add h 
52b8			; 
52b8			;		cp 0 
52b8 28 59				jr z, .dirnotfound 
52ba			 
52ba					; increase count 
52ba			 
52ba c1					pop bc	 
52bb 0c					inc c 
52bc c5					push bc 
52bd					 
52bd			 
52bd					; get file header and push the file name 
52bd			 
52bd 11 77 fa				ld de, store_page 
52c0 cd 66 04				call storage_read_block 
52c3			 
52c3					; push file id to stack 
52c3				 
52c3 3a 77 fa				ld a, (store_page) 
52c6 26 00				ld h, 0 
52c8 6f					ld l, a 
52c9 cd 05 21				call forth_push_numhl 
52cc			 
52cc					; push extent count to stack  
52cc				 
52cc 3a 79 fa				ld a, (store_page+2) 
52cf 26 00				ld h, 0 
52d1 6f					ld l, a 
52d2 cd 05 21				call forth_push_numhl 
52d5			 
52d5					; push file name 
52d5			 
52d5 21 7a fa				ld hl, store_page+3 
52d8					if DEBUG_FORTH_WORDS 
52d8						DMARK "DI5" 
52d8 f5				push af  
52d9 3a ed 52			ld a, (.dmark)  
52dc 32 68 fe			ld (debug_mark),a  
52df 3a ee 52			ld a, (.dmark+1)  
52e2 32 69 fe			ld (debug_mark+1),a  
52e5 3a ef 52			ld a, (.dmark+2)  
52e8 32 6a fe			ld (debug_mark+2),a  
52eb 18 03			jr .pastdmark  
52ed ..			.dmark: db "DI5"  
52f0 f1			.pastdmark: pop af  
52f1			endm  
# End of macro DMARK
52f1						CALLMONITOR 
52f1 cd 6c fe			call debug_vector  
52f4				endm  
# End of macro CALLMONITOR
52f4					endif 
52f4 cd 73 21				call forth_push_str 
52f7					if DEBUG_FORTH_WORDS 
52f7						DMARK "DI6" 
52f7 f5				push af  
52f8 3a 0c 53			ld a, (.dmark)  
52fb 32 68 fe			ld (debug_mark),a  
52fe 3a 0d 53			ld a, (.dmark+1)  
5301 32 69 fe			ld (debug_mark+1),a  
5304 3a 0e 53			ld a, (.dmark+2)  
5307 32 6a fe			ld (debug_mark+2),a  
530a 18 03			jr .pastdmark  
530c ..			.dmark: db "DI6"  
530f f1			.pastdmark: pop af  
5310			endm  
# End of macro DMARK
5310						CALLMONITOR 
5310 cd 6c fe			call debug_vector  
5313				endm  
# End of macro CALLMONITOR
5313					endif 
5313			.dirnotfound: 
5313 c1					pop bc     
5314 10 95				djnz .diritem 
5316				 
5316			.dirdone:	 
5316					if DEBUG_FORTH_WORDS 
5316						DMARK "DI7" 
5316 f5				push af  
5317 3a 2b 53			ld a, (.dmark)  
531a 32 68 fe			ld (debug_mark),a  
531d 3a 2c 53			ld a, (.dmark+1)  
5320 32 69 fe			ld (debug_mark+1),a  
5323 3a 2d 53			ld a, (.dmark+2)  
5326 32 6a fe			ld (debug_mark+2),a  
5329 18 03			jr .pastdmark  
532b ..			.dmark: db "DI7"  
532e f1			.pastdmark: pop af  
532f			endm  
# End of macro DMARK
532f						CALLMONITOR 
532f cd 6c fe			call debug_vector  
5332				endm  
# End of macro CALLMONITOR
5332					endif 
5332			 
5332					; push a count of the dir items found 
5332			 
5332 26 00				ld h, 0 
5334 69					ld l, c 
5335 cd 05 21				call forth_push_numhl 
5338			 
5338					; push the bank label 
5338			 
5338 cd 17 05				call storage_get_block_0 
533b			 
533b				 
533b 21 7a fa		 		ld hl, store_page+3 
533e			 
533e					if DEBUG_FORTH_WORDS 
533e						DMARK "DI8" 
533e f5				push af  
533f 3a 53 53			ld a, (.dmark)  
5342 32 68 fe			ld (debug_mark),a  
5345 3a 54 53			ld a, (.dmark+1)  
5348 32 69 fe			ld (debug_mark+1),a  
534b 3a 55 53			ld a, (.dmark+2)  
534e 32 6a fe			ld (debug_mark+2),a  
5351 18 03			jr .pastdmark  
5353 ..			.dmark: db "DI8"  
5356 f1			.pastdmark: pop af  
5357			endm  
# End of macro DMARK
5357						CALLMONITOR 
5357 cd 6c fe			call debug_vector  
535a				endm  
# End of macro CALLMONITOR
535a					endif 
535a cd 73 21				call forth_push_str 
535d			 
535d			 
535d				 
535d					NEXTW 
535d c3 b2 24			jp macro_next 
5360				endm 
# End of macro NEXTW
5360			.SAVE: 
5360			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
5360			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
5360			;		NEXTW 
5360			;.LOAD: 
5360			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
5360			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
5360			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
5360			;; > > The LOAD command can not be used in any user words or compound lines. 
5360			; 
5360			;		; store_openext use it. If zero it is EOF 
5360			; 
5360			;		; read block from current stream id 
5360			;		; if the block does not contain zero term keep reading blocks until zero found 
5360			;		; push the block to stack 
5360			;		; save the block id to stream 
5360			; 
5360			; 
5360			;		FORTH_DSP_VALUEHL 
5360			; 
5360			;;		push hl 
5360			; 
5360			;	if DEBUG_STORESE 
5360			;		DMARK "LOA" 
5360			;		CALLMONITOR 
5360			;	endif 
5360			;		FORTH_DSP_POP 
5360			; 
5360			;;		pop hl 
5360			; 
5360			;		ld h, l 
5360			;		ld l, 0 
5360			; 
5360			;		push hl     ; stack holds current file id and extent to work with 
5360			; 
5360			; 
5360			;		ld de, store_page      ; get block zero of file 
5360			;	if DEBUG_STORESE 
5360			;		DMARK "LO0" 
5360			;		CALLMONITOR 
5360			;	endif 
5360			;		call storage_read 
5360			; 
5360			;		ld a, (store_page+2)    ; max extents for this file 
5360			;		ld  (store_openmaxext),a   ; get our limit 
5360			; 
5360			;	if DEBUG_STORESE 
5360			;		DMARK "LOE" 
5360			;		CALLMONITOR 
5360			;	endif 
5360			; 
5360			;; TODO dont know why max extents are not present 
5360			;;		cp 0 
5360			;;		jp z, .loadeof     ; dont read past eof 
5360			; 
5360			;;		ld a, 1   ; start from the head of the file 
5360			; 
5360			;.loadline:	pop hl 
5360			;		inc hl 
5360			;		ld  a, (store_openmaxext)   ; get our limit 
5360			;	if DEBUG_STORESE 
5360			;		DMARK "LOx" 
5360			;		CALLMONITOR 
5360			;	endif 
5360			;		inc a 
5360			;		cp l 
5360			;		jp z, .loadeof 
5360			;		push hl    ; save current extent 
5360			; 
5360			;		ld de, store_page 
5360			; 
5360			;	if DEBUG_STORESE 
5360			;		DMARK "LO1" 
5360			;		CALLMONITOR 
5360			;	endif 
5360			;		call storage_read 
5360			; 
5360			;	if DEBUG_STORESE 
5360			;		DMARK "LO2" 
5360			;		CALLMONITOR 
5360			;	endif 
5360			;	call ishlzero 
5360			;	ld a, l 
5360			;	add h 
5360			;	cp 0 
5360			;	jr z, .loadeof 
5360			; 
5360			;	; not eof so hl should point to data to exec 
5360			; 
5360			;	; will need to add the FORTH_END_BUFFER flag 
5360			 ; 
5360			;	ld hl, store_page+2 
5360			;	ld bc, 255 
5360			;	ld a, 0 
5360			;	cpir 
5360			;	if DEBUG_STORESE 
5360			;		DMARK "LOt" 
5360			;		CALLMONITOR 
5360			;	endif 
5360			;	dec hl 
5360			;	ld a, ' ' 
5360			;	ld (hl), a 
5360			;	inc hl 
5360			;	ld (hl), a 
5360			;	inc hl 
5360			;	ld (hl), a 
5360			;	inc hl 
5360			;	ld a, FORTH_END_BUFFER 
5360			;	ld (hl), a 
5360			; 
5360			;	; TODO handle more than a single block read 
5360			; 
5360			; 
5360			;	ld hl, store_page+2 
5360			; 
5360			;	ld (os_tok_ptr), hl 
5360			; 
5360			;	if DEBUG_STORESE 
5360			;		DMARK "LO3" 
5360			;		CALLMONITOR 
5360			;	endif 
5360			; 
5360			;	call forthparse 
5360			;	call forthexec 
5360			;	call forthexec_cleanup 
5360			; 
5360			;	; go to next extent 
5360			; 
5360			;	; get next block  or mark as eof 
5360			;	jp .loadline 
5360			; 
5360			; 
5360			; 
5360			;	       NEXTW 
5360			;.loadeof:	ld a, 0 
5360			;		ld (store_openext), a 
5360			; 
5360			;	if DEBUG_STORESE 
5360			;		DMARK "LOF" 
5360			;		CALLMONITOR 
5360			;	endif 
5360			;		ret 
5360			;		;NEXTW 
5360			;.BSAVE:   
5360			; 
5360			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
5360			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
5360			;		NEXTW 
5360			;.BLOAD: 
5360			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
5360			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
5360			;		NEXTW 
5360			;;;; counter gap 
5360			 
5360			 
5360			.SEO: 
5360				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
5360 64				db WORD_SYS_CORE+80             
5361 7f 53			dw .SEI            
5363 04				db 3 + 1 
5364 .. 00			db "SEO",0              
5368				endm 
# End of macro CWHEAD
5368			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
5368			 
5368					; get port 
5368			 
5368					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5368 cd fc 22			call macro_dsp_valuehl 
536b				endm 
# End of macro FORTH_DSP_VALUEHL
536b			 
536b e5					push hl    ; u2 - byte 
536c			 
536c					; destroy value TOS 
536c			 
536c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
536c cd b4 23			call macro_forth_dsp_pop 
536f				endm 
# End of macro FORTH_DSP_POP
536f			 
536f					; get byte to send 
536f			 
536f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
536f cd fc 22			call macro_dsp_valuehl 
5372				endm 
# End of macro FORTH_DSP_VALUEHL
5372			 
5372 e5					push hl    ; u1 - addr 
5373			 
5373					; destroy value TOS 
5373			 
5373					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5373 cd b4 23			call macro_forth_dsp_pop 
5376				endm 
# End of macro FORTH_DSP_POP
5376			 
5376					; one value on hl get other one back 
5376			 
5376 d1					pop de   ; u1 - byte 
5377			 
5377 e1					pop hl   ; u2 - addr 
5378			 
5378					; TODO Send SPI byte 
5378			 
5378			 
5378 7b					ld a, e 
5379 cd 6b 02				call se_writebyte 
537c			 
537c					 
537c			 
537c					NEXTW 
537c c3 b2 24			jp macro_next 
537f				endm 
# End of macro NEXTW
537f			 
537f			.SEI: 
537f				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
537f 65				db WORD_SYS_CORE+81             
5380 99 53			dw .SFREE            
5382 04				db 3 + 1 
5383 .. 00			db "SEI",0              
5387				endm 
# End of macro CWHEAD
5387			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5387			 
5387					; get port 
5387			 
5387					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5387 cd fc 22			call macro_dsp_valuehl 
538a				endm 
# End of macro FORTH_DSP_VALUEHL
538a			 
538a			;		push hl 
538a			 
538a					; destroy value TOS 
538a			 
538a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
538a cd b4 23			call macro_forth_dsp_pop 
538d				endm 
# End of macro FORTH_DSP_POP
538d			 
538d					; one value on hl get other one back 
538d			 
538d			;		pop hl 
538d			 
538d			 
538d					; TODO Get SPI byte 
538d			 
538d cd 0d 03				call se_readbyte 
5390			 
5390 26 00				ld h, 0 
5392 6f					ld l, a 
5393 cd 05 21				call forth_push_numhl 
5396			 
5396					NEXTW 
5396 c3 b2 24			jp macro_next 
5399				endm 
# End of macro NEXTW
5399			 
5399			.SFREE: 
5399				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
5399 67				db WORD_SYS_CORE+83             
539a c8 53			dw .SIZE            
539c 06				db 5 + 1 
539d .. 00			db "FFREE",0              
53a3				endm 
# End of macro CWHEAD
53a3			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
53a3			; | | Compatible with PicoSPINet  
53a3					if DEBUG_FORTH_WORDS_KEY 
53a3						DMARK "FFR" 
53a3 f5				push af  
53a4 3a b8 53			ld a, (.dmark)  
53a7 32 68 fe			ld (debug_mark),a  
53aa 3a b9 53			ld a, (.dmark+1)  
53ad 32 69 fe			ld (debug_mark+1),a  
53b0 3a ba 53			ld a, (.dmark+2)  
53b3 32 6a fe			ld (debug_mark+2),a  
53b6 18 03			jr .pastdmark  
53b8 ..			.dmark: db "FFR"  
53bb f1			.pastdmark: pop af  
53bc			endm  
# End of macro DMARK
53bc						CALLMONITOR 
53bc cd 6c fe			call debug_vector  
53bf				endm  
# End of macro CALLMONITOR
53bf					endif 
53bf			 
53bf cd 33 08				call storage_freeblocks 
53c2			 
53c2 cd 05 21				call forth_push_numhl 
53c5			 
53c5				       NEXTW 
53c5 c3 b2 24			jp macro_next 
53c8				endm 
# End of macro NEXTW
53c8			.SIZE: 
53c8				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
53c8 67				db WORD_SYS_CORE+83             
53c9 fc 53			dw .CREATE            
53cb 05				db 4 + 1 
53cc .. 00			db "SIZE",0              
53d1				endm 
# End of macro CWHEAD
53d1			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
53d1			; | | Compatible with PicoSPINet  
53d1					if DEBUG_FORTH_WORDS_KEY 
53d1						DMARK "SIZ" 
53d1 f5				push af  
53d2 3a e6 53			ld a, (.dmark)  
53d5 32 68 fe			ld (debug_mark),a  
53d8 3a e7 53			ld a, (.dmark+1)  
53db 32 69 fe			ld (debug_mark+1),a  
53de 3a e8 53			ld a, (.dmark+2)  
53e1 32 6a fe			ld (debug_mark+2),a  
53e4 18 03			jr .pastdmark  
53e6 ..			.dmark: db "SIZ"  
53e9 f1			.pastdmark: pop af  
53ea			endm  
# End of macro DMARK
53ea						CALLMONITOR 
53ea cd 6c fe			call debug_vector  
53ed				endm  
# End of macro CALLMONITOR
53ed					endif 
53ed			 
53ed					FORTH_DSP_VALUEHL 
53ed cd fc 22			call macro_dsp_valuehl 
53f0				endm 
# End of macro FORTH_DSP_VALUEHL
53f0			;		push hl 
53f0					FORTH_DSP_POP 
53f0 cd b4 23			call macro_forth_dsp_pop 
53f3				endm 
# End of macro FORTH_DSP_POP
53f3			;		pop hl 
53f3 cd 95 04				call storage_file_size 
53f6			 
53f6 cd 05 21				call forth_push_numhl 
53f9			  
53f9			 
53f9				       NEXTW 
53f9 c3 b2 24			jp macro_next 
53fc				endm 
# End of macro NEXTW
53fc			 
53fc			.CREATE: 
53fc				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
53fc 68				db WORD_SYS_CORE+84             
53fd 6a 54			dw .APPEND            
53ff 07				db 6 + 1 
5400 .. 00			db "CREATE",0              
5407				endm 
# End of macro CWHEAD
5407			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
5407			; | | e.g.  
5407			; | | TestProgram CREATE 
5407			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
5407			; | |  
5407			; | | Max file IDs are 255. 
5407			; | |  
5407			; | | Compatible with PicoSPINet  
5407					 
5407					if DEBUG_FORTH_WORDS_KEY 
5407						DMARK "CRT" 
5407 f5				push af  
5408 3a 1c 54			ld a, (.dmark)  
540b 32 68 fe			ld (debug_mark),a  
540e 3a 1d 54			ld a, (.dmark+1)  
5411 32 69 fe			ld (debug_mark+1),a  
5414 3a 1e 54			ld a, (.dmark+2)  
5417 32 6a fe			ld (debug_mark+2),a  
541a 18 03			jr .pastdmark  
541c ..			.dmark: db "CRT"  
541f f1			.pastdmark: pop af  
5420			endm  
# End of macro DMARK
5420						CALLMONITOR 
5420 cd 6c fe			call debug_vector  
5423				endm  
# End of macro CALLMONITOR
5423					endif 
5423			;		call storage_get_block_0 
5423			 
5423					; TODO pop hl 
5423			 
5423					;v5 FORTH_DSP_VALUE 
5423					FORTH_DSP_VALUE 
5423 cd e5 22			call macro_forth_dsp_value 
5426				endm 
# End of macro FORTH_DSP_VALUE
5426			 
5426				if DEBUG_STORESE 
5426					DMARK "CR1" 
5426 f5				push af  
5427 3a 3b 54			ld a, (.dmark)  
542a 32 68 fe			ld (debug_mark),a  
542d 3a 3c 54			ld a, (.dmark+1)  
5430 32 69 fe			ld (debug_mark+1),a  
5433 3a 3d 54			ld a, (.dmark+2)  
5436 32 6a fe			ld (debug_mark+2),a  
5439 18 03			jr .pastdmark  
543b ..			.dmark: db "CR1"  
543e f1			.pastdmark: pop af  
543f			endm  
# End of macro DMARK
543f					CALLMONITOR 
543f cd 6c fe			call debug_vector  
5442				endm  
# End of macro CALLMONITOR
5442				endif 
5442			;		push hl 
5442			;		FORTH_DSP_POP 
5442			;		pop hl 
5442			 
5442			;		inc hl   ; move past the type marker 
5442			 
5442 cd 69 08				call storage_create 
5445			 
5445				if DEBUG_STORESE 
5445					DMARK "CT1" 
5445 f5				push af  
5446 3a 5a 54			ld a, (.dmark)  
5449 32 68 fe			ld (debug_mark),a  
544c 3a 5b 54			ld a, (.dmark+1)  
544f 32 69 fe			ld (debug_mark+1),a  
5452 3a 5c 54			ld a, (.dmark+2)  
5455 32 6a fe			ld (debug_mark+2),a  
5458 18 03			jr .pastdmark  
545a ..			.dmark: db "CT1"  
545d f1			.pastdmark: pop af  
545e			endm  
# End of macro DMARK
545e					CALLMONITOR 
545e cd 6c fe			call debug_vector  
5461				endm  
# End of macro CALLMONITOR
5461				endif 
5461			;		push hl 
5461					FORTH_DSP_POP 
5461 cd b4 23			call macro_forth_dsp_pop 
5464				endm 
# End of macro FORTH_DSP_POP
5464			;		pop hl 
5464					; push file id to stack 
5464 cd 05 21				call forth_push_numhl 
5467			 
5467			 
5467			 
5467				       NEXTW 
5467 c3 b2 24			jp macro_next 
546a				endm 
# End of macro NEXTW
546a			 
546a			.APPEND: 
546a				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
546a 69				db WORD_SYS_CORE+85             
546b fb 54			dw .SDEL            
546d 07				db 6 + 1 
546e .. 00			db "APPEND",0              
5475				endm 
# End of macro CWHEAD
5475			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5475			; | | e.g. 
5475			; | | Test CREATE      -> $01 
5475			; | | "A string to add to file" $01 APPEND 
5475			; | |  
5475			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5475			; | | Compatible with PicoSPINet  
5475					if DEBUG_FORTH_WORDS_KEY 
5475						DMARK "APP" 
5475 f5				push af  
5476 3a 8a 54			ld a, (.dmark)  
5479 32 68 fe			ld (debug_mark),a  
547c 3a 8b 54			ld a, (.dmark+1)  
547f 32 69 fe			ld (debug_mark+1),a  
5482 3a 8c 54			ld a, (.dmark+2)  
5485 32 6a fe			ld (debug_mark+2),a  
5488 18 03			jr .pastdmark  
548a ..			.dmark: db "APP"  
548d f1			.pastdmark: pop af  
548e			endm  
# End of macro DMARK
548e						CALLMONITOR 
548e cd 6c fe			call debug_vector  
5491				endm  
# End of macro CALLMONITOR
5491					endif 
5491			 
5491					FORTH_DSP_VALUEHL 
5491 cd fc 22			call macro_dsp_valuehl 
5494				endm 
# End of macro FORTH_DSP_VALUEHL
5494 e5					push hl 	; save file id 
5495			 
5495				if DEBUG_STORESE 
5495					DMARK "AP1" 
5495 f5				push af  
5496 3a aa 54			ld a, (.dmark)  
5499 32 68 fe			ld (debug_mark),a  
549c 3a ab 54			ld a, (.dmark+1)  
549f 32 69 fe			ld (debug_mark+1),a  
54a2 3a ac 54			ld a, (.dmark+2)  
54a5 32 6a fe			ld (debug_mark+2),a  
54a8 18 03			jr .pastdmark  
54aa ..			.dmark: db "AP1"  
54ad f1			.pastdmark: pop af  
54ae			endm  
# End of macro DMARK
54ae					CALLMONITOR 
54ae cd 6c fe			call debug_vector  
54b1				endm  
# End of macro CALLMONITOR
54b1				endif 
54b1					FORTH_DSP_POP 
54b1 cd b4 23			call macro_forth_dsp_pop 
54b4				endm 
# End of macro FORTH_DSP_POP
54b4			 
54b4					FORTH_DSP_VALUEHL 
54b4 cd fc 22			call macro_dsp_valuehl 
54b7				endm 
# End of macro FORTH_DSP_VALUEHL
54b7					;v5 FORTH_DSP_VALUE 
54b7 e5					push hl 	; save ptr to string to save 
54b8			 
54b8				if DEBUG_STORESE 
54b8					DMARK "AP1" 
54b8 f5				push af  
54b9 3a cd 54			ld a, (.dmark)  
54bc 32 68 fe			ld (debug_mark),a  
54bf 3a ce 54			ld a, (.dmark+1)  
54c2 32 69 fe			ld (debug_mark+1),a  
54c5 3a cf 54			ld a, (.dmark+2)  
54c8 32 6a fe			ld (debug_mark+2),a  
54cb 18 03			jr .pastdmark  
54cd ..			.dmark: db "AP1"  
54d0 f1			.pastdmark: pop af  
54d1			endm  
# End of macro DMARK
54d1					CALLMONITOR 
54d1 cd 6c fe			call debug_vector  
54d4				endm  
# End of macro CALLMONITOR
54d4				endif 
54d4					FORTH_DSP_POP 
54d4 cd b4 23			call macro_forth_dsp_pop 
54d7				endm 
# End of macro FORTH_DSP_POP
54d7			 
54d7 d1					pop de 
54d8 e1					pop hl 
54d9				if DEBUG_STORESE 
54d9					DMARK "AP2" 
54d9 f5				push af  
54da 3a ee 54			ld a, (.dmark)  
54dd 32 68 fe			ld (debug_mark),a  
54e0 3a ef 54			ld a, (.dmark+1)  
54e3 32 69 fe			ld (debug_mark+1),a  
54e6 3a f0 54			ld a, (.dmark+2)  
54e9 32 6a fe			ld (debug_mark+2),a  
54ec 18 03			jr .pastdmark  
54ee ..			.dmark: db "AP2"  
54f1 f1			.pastdmark: pop af  
54f2			endm  
# End of macro DMARK
54f2					CALLMONITOR 
54f2 cd 6c fe			call debug_vector  
54f5				endm  
# End of macro CALLMONITOR
54f5				endif 
54f5					;inc de ; skip var type indicator 
54f5			 
54f5					; TODO how to append numerics???? 
54f5			 
54f5 cd 56 0b				call storage_append		 
54f8			 
54f8				       NEXTW 
54f8 c3 b2 24			jp macro_next 
54fb				endm 
# End of macro NEXTW
54fb			.SDEL: 
54fb				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
54fb 6a				db WORD_SYS_CORE+86             
54fc 47 55			dw .OPEN            
54fe 05				db 4 + 1 
54ff .. 00			db "ERA",0              
5503				endm 
# End of macro CWHEAD
5503			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
5503			; | | Compatible with PicoSPINet  
5503					FORTH_DSP_VALUEHL 
5503 cd fc 22			call macro_dsp_valuehl 
5506				endm 
# End of macro FORTH_DSP_VALUEHL
5506			;		push hl 	; save file id 
5506			 
5506					if DEBUG_FORTH_WORDS_KEY 
5506						DMARK "ERA" 
5506 f5				push af  
5507 3a 1b 55			ld a, (.dmark)  
550a 32 68 fe			ld (debug_mark),a  
550d 3a 1c 55			ld a, (.dmark+1)  
5510 32 69 fe			ld (debug_mark+1),a  
5513 3a 1d 55			ld a, (.dmark+2)  
5516 32 6a fe			ld (debug_mark+2),a  
5519 18 03			jr .pastdmark  
551b ..			.dmark: db "ERA"  
551e f1			.pastdmark: pop af  
551f			endm  
# End of macro DMARK
551f						CALLMONITOR 
551f cd 6c fe			call debug_vector  
5522				endm  
# End of macro CALLMONITOR
5522					endif 
5522				if DEBUG_STORESE 
5522					DMARK "ER1" 
5522 f5				push af  
5523 3a 37 55			ld a, (.dmark)  
5526 32 68 fe			ld (debug_mark),a  
5529 3a 38 55			ld a, (.dmark+1)  
552c 32 69 fe			ld (debug_mark+1),a  
552f 3a 39 55			ld a, (.dmark+2)  
5532 32 6a fe			ld (debug_mark+2),a  
5535 18 03			jr .pastdmark  
5537 ..			.dmark: db "ER1"  
553a f1			.pastdmark: pop af  
553b			endm  
# End of macro DMARK
553b					CALLMONITOR 
553b cd 6c fe			call debug_vector  
553e				endm  
# End of macro CALLMONITOR
553e				endif 
553e					FORTH_DSP_POP 
553e cd b4 23			call macro_forth_dsp_pop 
5541				endm 
# End of macro FORTH_DSP_POP
5541			 
5541			;		pop hl 
5541			 
5541 cd a8 06				call storage_erase 
5544				       NEXTW 
5544 c3 b2 24			jp macro_next 
5547				endm 
# End of macro NEXTW
5547			 
5547			.OPEN: 
5547				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
5547 6b				db WORD_SYS_CORE+87             
5548 db 55			dw .READ            
554a 05				db 4 + 1 
554b .. 00			db "OPEN",0              
5550				endm 
# End of macro CWHEAD
5550			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
5550			; | | e.g. 
5550			; | | $01 OPEN $01 DO $01 READ . LOOP 
5550			; | | 
5550			; | | Will return with 255 blocks if the file does not exist 
5550			; | | Compatible with PicoSPINet  
5550			 
5550					if DEBUG_FORTH_WORDS_KEY 
5550						DMARK "OPN" 
5550 f5				push af  
5551 3a 65 55			ld a, (.dmark)  
5554 32 68 fe			ld (debug_mark),a  
5557 3a 66 55			ld a, (.dmark+1)  
555a 32 69 fe			ld (debug_mark+1),a  
555d 3a 67 55			ld a, (.dmark+2)  
5560 32 6a fe			ld (debug_mark+2),a  
5563 18 03			jr .pastdmark  
5565 ..			.dmark: db "OPN"  
5568 f1			.pastdmark: pop af  
5569			endm  
# End of macro DMARK
5569						CALLMONITOR 
5569 cd 6c fe			call debug_vector  
556c				endm  
# End of macro CALLMONITOR
556c					endif 
556c					; TODO handle multiple file opens 
556c			 
556c 3e 01			       	ld a, 1 
556e 32 67 fa				ld (store_openext), a 
5571			 
5571					; get max extents for this file 
5571				 
5571								 
5571					FORTH_DSP_VALUEHL 
5571 cd fc 22			call macro_dsp_valuehl 
5574				endm 
# End of macro FORTH_DSP_VALUEHL
5574			 
5574 65					ld h, l 
5575 2e 00				ld l, 0 
5577			 
5577					; store file id 
5577			 
5577 7c					ld a, h 
5578 32 64 fa				ld (store_filecache), a 
557b			 
557b				if DEBUG_STORESE 
557b					DMARK "OPN" 
557b f5				push af  
557c 3a 90 55			ld a, (.dmark)  
557f 32 68 fe			ld (debug_mark),a  
5582 3a 91 55			ld a, (.dmark+1)  
5585 32 69 fe			ld (debug_mark+1),a  
5588 3a 92 55			ld a, (.dmark+2)  
558b 32 6a fe			ld (debug_mark+2),a  
558e 18 03			jr .pastdmark  
5590 ..			.dmark: db "OPN"  
5593 f1			.pastdmark: pop af  
5594			endm  
# End of macro DMARK
5594					CALLMONITOR 
5594 cd 6c fe			call debug_vector  
5597				endm  
# End of macro CALLMONITOR
5597				endif 
5597			;		push hl 
5597					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5597 cd b4 23			call macro_forth_dsp_pop 
559a				endm 
# End of macro FORTH_DSP_POP
559a			;		pop hl 
559a						 
559a 11 77 fa				ld de, store_page      ; get block zero of file 
559d cd bf 09				call storage_read 
55a0 cd f9 0f			call ishlzero 
55a3 20 04			jr nz, .opfound 
55a5			 
55a5				; file does not exist so indicate with 255 extents in use 
55a5			 
55a5 3e ff			ld a, 255 
55a7 18 29			jr .skipopeneof 
55a9			 
55a9			 
55a9			.opfound: 
55a9			 
55a9			 
55a9 3a 79 fa				ld a, (store_page+2)    ; max extents for this file 
55ac 32 66 fa				ld  (store_openmaxext), a   ; get our limit and push 
55af					 
55af				if DEBUG_STORESE 
55af					DMARK "OPx" 
55af f5				push af  
55b0 3a c4 55			ld a, (.dmark)  
55b3 32 68 fe			ld (debug_mark),a  
55b6 3a c5 55			ld a, (.dmark+1)  
55b9 32 69 fe			ld (debug_mark+1),a  
55bc 3a c6 55			ld a, (.dmark+2)  
55bf 32 6a fe			ld (debug_mark+2),a  
55c2 18 03			jr .pastdmark  
55c4 ..			.dmark: db "OPx"  
55c7 f1			.pastdmark: pop af  
55c8			endm  
# End of macro DMARK
55c8					CALLMONITOR 
55c8 cd 6c fe			call debug_vector  
55cb				endm  
# End of macro CALLMONITOR
55cb				endif 
55cb fe 00				cp 0 
55cd 20 03				jr nz, .skipopeneof 
55cf					; have opened an empty file 
55cf					 
55cf 32 67 fa				ld (store_openext), a 
55d2			 
55d2			.skipopeneof: 
55d2			 
55d2 6f					ld l, a 
55d3 26 00				ld h, 0 
55d5 cd 05 21				call forth_push_numhl 
55d8			 
55d8			 
55d8				       NEXTW 
55d8 c3 b2 24			jp macro_next 
55db				endm 
# End of macro NEXTW
55db			.READ: 
55db				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
55db 6c				db WORD_SYS_CORE+88             
55dc 05 57			dw .EOF            
55de 05				db 4 + 1 
55df .. 00			db "READ",0              
55e4				endm 
# End of macro CWHEAD
55e4			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
55e4			; | | e.g. 
55e4			; | | $01 OPEN $01 DO READ . LOOP 
55e4			; | | 
55e4			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
55e4			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
55e4			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
55e4			; | | two bytes contain the file id and extent. 
55e4			; | |  
55e4			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
55e4			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
55e4			; | | Compatible with PicoSPINet  
55e4			 
55e4					if DEBUG_FORTH_WORDS_KEY 
55e4						DMARK "REA" 
55e4 f5				push af  
55e5 3a f9 55			ld a, (.dmark)  
55e8 32 68 fe			ld (debug_mark),a  
55eb 3a fa 55			ld a, (.dmark+1)  
55ee 32 69 fe			ld (debug_mark+1),a  
55f1 3a fb 55			ld a, (.dmark+2)  
55f4 32 6a fe			ld (debug_mark+2),a  
55f7 18 03			jr .pastdmark  
55f9 ..			.dmark: db "REA"  
55fc f1			.pastdmark: pop af  
55fd			endm  
# End of macro DMARK
55fd						CALLMONITOR 
55fd cd 6c fe			call debug_vector  
5600				endm  
# End of macro CALLMONITOR
5600					endif 
5600					; store_openext use it. If zero it is EOF 
5600			 
5600					; read block from current stream id 
5600					; if the block does not contain zero term keep reading blocks until zero found 
5600					; push the block to stack 
5600					; save the block id to stream 
5600			 
5600			 
5600 cd 32 57				call .testeof 
5603 3e 01				ld a, 1 
5605 bd					cp l 
5606 ca e1 56				jp z, .ateof 
5609			 
5609			 
5609			;		FORTH_DSP_VALUEHL 
5609			 
5609			;		push hl 
5609			 
5609			;	if DEBUG_STORESE 
5609			;		DMARK "REA" 
5609			;		CALLMONITOR 
5609			;	endif 
5609			;		FORTH_DSP_POP 
5609			 
5609			;		pop hl 
5609				 
5609 3a 64 fa				ld a, (store_filecache) 
560c 67					ld h,a 
560d			 
560d 3a 67 fa				ld a, (store_openext) 
5610 6f					ld l, a 
5611					 
5611 fe 00				cp 0 
5613 ca e1 56				jp z, .ateof     ; dont read past eof 
5616			 
5616 cd a2 0c				call storage_clear_page 
5619			 
5619 11 77 fa				ld de, store_page 
561c				if DEBUG_STORESE 
561c					DMARK "RE1" 
561c f5				push af  
561d 3a 31 56			ld a, (.dmark)  
5620 32 68 fe			ld (debug_mark),a  
5623 3a 32 56			ld a, (.dmark+1)  
5626 32 69 fe			ld (debug_mark+1),a  
5629 3a 33 56			ld a, (.dmark+2)  
562c 32 6a fe			ld (debug_mark+2),a  
562f 18 03			jr .pastdmark  
5631 ..			.dmark: db "RE1"  
5634 f1			.pastdmark: pop af  
5635			endm  
# End of macro DMARK
5635					CALLMONITOR 
5635 cd 6c fe			call debug_vector  
5638				endm  
# End of macro CALLMONITOR
5638				endif 
5638 cd bf 09				call storage_read 
563b			 
563b				if DEBUG_STORESE 
563b					DMARK "RE2" 
563b f5				push af  
563c 3a 50 56			ld a, (.dmark)  
563f 32 68 fe			ld (debug_mark),a  
5642 3a 51 56			ld a, (.dmark+1)  
5645 32 69 fe			ld (debug_mark+1),a  
5648 3a 52 56			ld a, (.dmark+2)  
564b 32 6a fe			ld (debug_mark+2),a  
564e 18 03			jr .pastdmark  
5650 ..			.dmark: db "RE2"  
5653 f1			.pastdmark: pop af  
5654			endm  
# End of macro DMARK
5654					CALLMONITOR 
5654 cd 6c fe			call debug_vector  
5657				endm  
# End of macro CALLMONITOR
5657				endif 
5657 cd f9 0f			call ishlzero 
565a			;	ld a, l 
565a			;	add h 
565a			;	cp 0 
565a ca e1 56			jp z, .readeof 
565d			 
565d				; not eof so hl should point to data to push to stack 
565d			 
565d				if DEBUG_STORESE 
565d					DMARK "RE3" 
565d f5				push af  
565e 3a 72 56			ld a, (.dmark)  
5661 32 68 fe			ld (debug_mark),a  
5664 3a 73 56			ld a, (.dmark+1)  
5667 32 69 fe			ld (debug_mark+1),a  
566a 3a 74 56			ld a, (.dmark+2)  
566d 32 6a fe			ld (debug_mark+2),a  
5670 18 03			jr .pastdmark  
5672 ..			.dmark: db "RE3"  
5675 f1			.pastdmark: pop af  
5676			endm  
# End of macro DMARK
5676					CALLMONITOR 
5676 cd 6c fe			call debug_vector  
5679				endm  
# End of macro CALLMONITOR
5679				endif 
5679 cd 73 21			call forth_push_str 
567c			 
567c				if DEBUG_STORESE 
567c					DMARK "RE4" 
567c f5				push af  
567d 3a 91 56			ld a, (.dmark)  
5680 32 68 fe			ld (debug_mark),a  
5683 3a 92 56			ld a, (.dmark+1)  
5686 32 69 fe			ld (debug_mark+1),a  
5689 3a 93 56			ld a, (.dmark+2)  
568c 32 6a fe			ld (debug_mark+2),a  
568f 18 03			jr .pastdmark  
5691 ..			.dmark: db "RE4"  
5694 f1			.pastdmark: pop af  
5695			endm  
# End of macro DMARK
5695					CALLMONITOR 
5695 cd 6c fe			call debug_vector  
5698				endm  
# End of macro CALLMONITOR
5698				endif 
5698				; get next block  or mark as eof 
5698			 
5698 3a 66 fa			ld a, (store_openmaxext)   ; get our limit 
569b 4f				ld c, a	 
569c 3a 67 fa			ld a, (store_openext) 
569f			 
569f				if DEBUG_STORESE 
569f					DMARK "RE5" 
569f f5				push af  
56a0 3a b4 56			ld a, (.dmark)  
56a3 32 68 fe			ld (debug_mark),a  
56a6 3a b5 56			ld a, (.dmark+1)  
56a9 32 69 fe			ld (debug_mark+1),a  
56ac 3a b6 56			ld a, (.dmark+2)  
56af 32 6a fe			ld (debug_mark+2),a  
56b2 18 03			jr .pastdmark  
56b4 ..			.dmark: db "RE5"  
56b7 f1			.pastdmark: pop af  
56b8			endm  
# End of macro DMARK
56b8					CALLMONITOR 
56b8 cd 6c fe			call debug_vector  
56bb				endm  
# End of macro CALLMONITOR
56bb				endif 
56bb b9				cp c 
56bc 28 23			jr z, .readeof     ; at last extent 
56be			 
56be 3c					inc a 
56bf 32 67 fa				ld (store_openext), a 
56c2			 
56c2				if DEBUG_STORESE 
56c2					DMARK "RE6" 
56c2 f5				push af  
56c3 3a d7 56			ld a, (.dmark)  
56c6 32 68 fe			ld (debug_mark),a  
56c9 3a d8 56			ld a, (.dmark+1)  
56cc 32 69 fe			ld (debug_mark+1),a  
56cf 3a d9 56			ld a, (.dmark+2)  
56d2 32 6a fe			ld (debug_mark+2),a  
56d5 18 03			jr .pastdmark  
56d7 ..			.dmark: db "RE6"  
56da f1			.pastdmark: pop af  
56db			endm  
# End of macro DMARK
56db					CALLMONITOR 
56db cd 6c fe			call debug_vector  
56de				endm  
# End of macro CALLMONITOR
56de				endif 
56de			 
56de			 
56de				       NEXTW 
56de c3 b2 24			jp macro_next 
56e1				endm 
# End of macro NEXTW
56e1			.ateof: 
56e1				;	ld hl, .showeof 
56e1				;	call forth_push_str 
56e1 3e 00		.readeof:	ld a, 0 
56e3 32 67 fa				ld (store_openext), a 
56e6			 
56e6					 
56e6				if DEBUG_STORESE 
56e6					DMARK "REF" 
56e6 f5				push af  
56e7 3a fb 56			ld a, (.dmark)  
56ea 32 68 fe			ld (debug_mark),a  
56ed 3a fc 56			ld a, (.dmark+1)  
56f0 32 69 fe			ld (debug_mark+1),a  
56f3 3a fd 56			ld a, (.dmark+2)  
56f6 32 6a fe			ld (debug_mark+2),a  
56f9 18 03			jr .pastdmark  
56fb ..			.dmark: db "REF"  
56fe f1			.pastdmark: pop af  
56ff			endm  
# End of macro DMARK
56ff					CALLMONITOR 
56ff cd 6c fe			call debug_vector  
5702				endm  
# End of macro CALLMONITOR
5702				endif 
5702				       NEXTW 
5702 c3 b2 24			jp macro_next 
5705				endm 
# End of macro NEXTW
5705			 
5705			;.showeof:   db "eof", 0 
5705			 
5705			 
5705			.EOF: 
5705				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5705 6d				db WORD_SYS_CORE+89             
5706 47 57			dw .FORMAT            
5708 04				db 3 + 1 
5709 .. 00			db "EOF",0              
570d				endm 
# End of macro CWHEAD
570d			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
570d			; | | e.g. 
570d			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
570d			; | | Compatible with PicoSPINet  
570d					; TODO if current block id for stream is zero then push true else false 
570d			 
570d					if DEBUG_FORTH_WORDS_KEY 
570d						DMARK "EOF" 
570d f5				push af  
570e 3a 22 57			ld a, (.dmark)  
5711 32 68 fe			ld (debug_mark),a  
5714 3a 23 57			ld a, (.dmark+1)  
5717 32 69 fe			ld (debug_mark+1),a  
571a 3a 24 57			ld a, (.dmark+2)  
571d 32 6a fe			ld (debug_mark+2),a  
5720 18 03			jr .pastdmark  
5722 ..			.dmark: db "EOF"  
5725 f1			.pastdmark: pop af  
5726			endm  
# End of macro DMARK
5726						CALLMONITOR 
5726 cd 6c fe			call debug_vector  
5729				endm  
# End of macro CALLMONITOR
5729					endif 
5729			 
5729					; TODO handlue multiple file streams 
5729			 
5729			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
5729 cd 32 57				call .testeof 
572c cd 05 21				call forth_push_numhl 
572f			 
572f			 
572f				       NEXTW 
572f c3 b2 24			jp macro_next 
5732				endm 
# End of macro NEXTW
5732			 
5732			.testeof: 
5732 2e 01				ld l, 1 
5734 3a 66 fa				ld a, (store_openmaxext) 
5737 fe 00				cp 0 
5739 28 09				jr  z, .eofdone   ; empty file 
573b 3a 67 fa				ld a, (store_openext) 
573e fe 00				cp 0 
5740 28 02				jr  z, .eofdone 
5742 2e 00				ld l, 0 
5744 26 00		.eofdone:	ld h, 0 
5746 c9					ret 
5747			 
5747			 
5747			 
5747			 
5747			.FORMAT: 
5747				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5747 6d				db WORD_SYS_CORE+89             
5748 98 57			dw .LABEL            
574a 07				db 6 + 1 
574b .. 00			db "FORMAT",0              
5752				endm 
# End of macro CWHEAD
5752			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5752			; | | Compatible with PicoSPINet  
5752					; TODO if current block id for stream is zero then push true else false 
5752				 
5752				if DEBUG_STORESE 
5752					DMARK "FOR" 
5752 f5				push af  
5753 3a 67 57			ld a, (.dmark)  
5756 32 68 fe			ld (debug_mark),a  
5759 3a 68 57			ld a, (.dmark+1)  
575c 32 69 fe			ld (debug_mark+1),a  
575f 3a 69 57			ld a, (.dmark+2)  
5762 32 6a fe			ld (debug_mark+2),a  
5765 18 03			jr .pastdmark  
5767 ..			.dmark: db "FOR"  
576a f1			.pastdmark: pop af  
576b			endm  
# End of macro DMARK
576b					CALLMONITOR 
576b cd 6c fe			call debug_vector  
576e				endm  
# End of macro CALLMONITOR
576e				endif 
576e					; Wipes the bank check flags to cause a reformat on next block 0 read 
576e			 
576e 21 01 00				ld hl, 1 
5771 3e 00				ld a, 0 
5773 cd 6b 02				call se_writebyte 
5776			 
5776				if DEBUG_STORESE 
5776					DMARK "FO0" 
5776 f5				push af  
5777 3a 8b 57			ld a, (.dmark)  
577a 32 68 fe			ld (debug_mark),a  
577d 3a 8c 57			ld a, (.dmark+1)  
5780 32 69 fe			ld (debug_mark+1),a  
5783 3a 8d 57			ld a, (.dmark+2)  
5786 32 6a fe			ld (debug_mark+2),a  
5789 18 03			jr .pastdmark  
578b ..			.dmark: db "FO0"  
578e f1			.pastdmark: pop af  
578f			endm  
# End of macro DMARK
578f					CALLMONITOR 
578f cd 6c fe			call debug_vector  
5792				endm  
# End of macro CALLMONITOR
5792				endif 
5792					; force bank init 
5792			 
5792 cd 17 05				call storage_get_block_0 
5795					 
5795				       NEXTW 
5795 c3 b2 24			jp macro_next 
5798				endm 
# End of macro NEXTW
5798			.LABEL: 
5798				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5798 6d				db WORD_SYS_CORE+89             
5799 e6 57			dw .STOREPAGE            
579b 06				db 5 + 1 
579c .. 00			db "LABEL",0              
57a2				endm 
# End of macro CWHEAD
57a2			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
57a2			; | | Compatible with PicoSPINet  
57a2					; TODO test to see if bank is selected 
57a2				 
57a2					if DEBUG_FORTH_WORDS_KEY 
57a2						DMARK "LBL" 
57a2 f5				push af  
57a3 3a b7 57			ld a, (.dmark)  
57a6 32 68 fe			ld (debug_mark),a  
57a9 3a b8 57			ld a, (.dmark+1)  
57ac 32 69 fe			ld (debug_mark+1),a  
57af 3a b9 57			ld a, (.dmark+2)  
57b2 32 6a fe			ld (debug_mark+2),a  
57b5 18 03			jr .pastdmark  
57b7 ..			.dmark: db "LBL"  
57ba f1			.pastdmark: pop af  
57bb			endm  
# End of macro DMARK
57bb						CALLMONITOR 
57bb cd 6c fe			call debug_vector  
57be				endm  
# End of macro CALLMONITOR
57be					endif 
57be			;	if DEBUG_STORESE 
57be			;		DMARK "LBL" 
57be			;		CALLMONITOR 
57be			;	endif 
57be					FORTH_DSP_VALUEHL 
57be cd fc 22			call macro_dsp_valuehl 
57c1				endm 
# End of macro FORTH_DSP_VALUEHL
57c1					;v5FORTH_DSP_VALUE 
57c1					 
57c1			;		push hl 
57c1					FORTH_DSP_POP 
57c1 cd b4 23			call macro_forth_dsp_pop 
57c4				endm 
# End of macro FORTH_DSP_POP
57c4			;		pop hl 
57c4			 
57c4			;v5		inc hl   ; move past the type marker 
57c4			 
57c4				if DEBUG_STORESE 
57c4					DMARK "LBl" 
57c4 f5				push af  
57c5 3a d9 57			ld a, (.dmark)  
57c8 32 68 fe			ld (debug_mark),a  
57cb 3a da 57			ld a, (.dmark+1)  
57ce 32 69 fe			ld (debug_mark+1),a  
57d1 3a db 57			ld a, (.dmark+2)  
57d4 32 6a fe			ld (debug_mark+2),a  
57d7 18 03			jr .pastdmark  
57d9 ..			.dmark: db "LBl"  
57dc f1			.pastdmark: pop af  
57dd			endm  
# End of macro DMARK
57dd					CALLMONITOR 
57dd cd 6c fe			call debug_vector  
57e0				endm  
# End of macro CALLMONITOR
57e0				endif 
57e0 cd 3b 06				call storage_label 
57e3			 
57e3				       NEXTW 
57e3 c3 b2 24			jp macro_next 
57e6				endm 
# End of macro NEXTW
57e6			.STOREPAGE: 
57e6				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
57e6 6d				db WORD_SYS_CORE+89             
57e7 19 58			dw .LABELS            
57e9 0a				db 9 + 1 
57ea .. 00			db "STOREPAGE",0              
57f4				endm 
# End of macro CWHEAD
57f4			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
57f4			; | | Compatible with PicoSPINet  
57f4					; TODO test to see if bank is selected 
57f4				 
57f4					if DEBUG_FORTH_WORDS_KEY 
57f4						DMARK "STP" 
57f4 f5				push af  
57f5 3a 09 58			ld a, (.dmark)  
57f8 32 68 fe			ld (debug_mark),a  
57fb 3a 0a 58			ld a, (.dmark+1)  
57fe 32 69 fe			ld (debug_mark+1),a  
5801 3a 0b 58			ld a, (.dmark+2)  
5804 32 6a fe			ld (debug_mark+2),a  
5807 18 03			jr .pastdmark  
5809 ..			.dmark: db "STP"  
580c f1			.pastdmark: pop af  
580d			endm  
# End of macro DMARK
580d						CALLMONITOR 
580d cd 6c fe			call debug_vector  
5810				endm  
# End of macro CALLMONITOR
5810					endif 
5810			;	if DEBUG_STORESE 
5810			;		DMARK "STP" 
5810			;		CALLMONITOR 
5810			;	endif 
5810			 
5810 21 77 fa			ld hl, store_page 
5813 cd 05 21			call forth_push_numhl 
5816			 
5816			 
5816				       NEXTW 
5816 c3 b2 24			jp macro_next 
5819				endm 
# End of macro NEXTW
5819			.LABELS: 
5819				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
5819 6d				db WORD_SYS_CORE+89             
581a a3 58			dw .SCONST1            
581c 07				db 6 + 1 
581d .. 00			db "LABELS",0              
5824				endm 
# End of macro CWHEAD
5824			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
5824			; | | *NOT* Compatible with PicoSPINet  
5824					;  
5824			 
5824					; save the current device selected to restore afterwards 
5824				 
5824 3a 5d fa				ld a, (spi_device) 
5827 f5					push af 
5828			 
5828			 
5828					; run through each of the banks 
5828			 
5828 21 01 00				ld hl, 1 
582b cd 05 21				call forth_push_numhl 
582e 3e ff				ld a, SPI_CE_HIGH 
5830 cb 87				res SPI_CE0, a 
5832 32 5d fa				ld (spi_device), a 
5835 cd 17 05				call storage_get_block_0 
5838 21 7a fa				ld hl, store_page+3 
583b cd 73 21				call forth_push_str 
583e			 
583e					 
583e 21 02 00				ld hl, 2 
5841 cd 05 21				call forth_push_numhl 
5844 3e ff				ld a, SPI_CE_HIGH 
5846 cb 8f				res SPI_CE1, a 
5848 32 5d fa				ld (spi_device), a 
584b cd 17 05				call storage_get_block_0 
584e 21 7a fa				ld hl, store_page+3 
5851 cd 73 21				call forth_push_str 
5854			 
5854					 
5854 21 03 00				ld hl, 3 
5857 cd 05 21				call forth_push_numhl 
585a 3e ff				ld a, SPI_CE_HIGH 
585c cb 97				res SPI_CE2, a 
585e 32 5d fa				ld (spi_device), a 
5861 cd 17 05				call storage_get_block_0 
5864 21 7a fa				ld hl, store_page+3 
5867 cd 73 21				call forth_push_str 
586a			 
586a			 
586a 21 04 00				ld hl, 4 
586d cd 05 21				call forth_push_numhl 
5870 3e ff				ld a, SPI_CE_HIGH 
5872 cb 9f				res SPI_CE3, a 
5874 32 5d fa				ld (spi_device), a 
5877 cd 17 05				call storage_get_block_0 
587a 21 7a fa				ld hl, store_page+3 
587d cd 73 21				call forth_push_str 
5880			 
5880					 
5880			 
5880 21 05 00				ld hl, 5 
5883 cd 05 21				call forth_push_numhl 
5886 3e ff				ld a, SPI_CE_HIGH 
5888 cb a7				res SPI_CE4, a 
588a 32 5d fa				ld (spi_device), a 
588d cd 17 05				call storage_get_block_0 
5890 21 7a fa				ld hl, store_page+3 
5893 cd 73 21				call forth_push_str 
5896			 
5896					 
5896					; push fixed count of storage devices (on board) for now 
5896			 
5896 21 05 00				ld hl, 5 
5899 cd 05 21				call forth_push_numhl 
589c			 
589c					; restore selected device  
589c				 
589c f1					pop af 
589d 32 5d fa				ld (spi_device), a 
58a0			 
58a0				       NEXTW 
58a0 c3 b2 24			jp macro_next 
58a3				endm 
# End of macro NEXTW
58a3			 
58a3			.SCONST1: 
58a3				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
58a3 6d				db WORD_SYS_CORE+89             
58a4 ba 58			dw .SCONST2            
58a6 07				db 6 + 1 
58a7 .. 00			db "FILEID",0              
58ae				endm 
# End of macro CWHEAD
58ae			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
58ae			; | | Compatible with PicoSPINet  
58ae 3a 64 fa				ld a, (store_filecache) 
58b1 26 00				ld h, 0 
58b3 6f					ld l, a 
58b4 cd 05 21				call forth_push_numhl 
58b7					NEXTW 
58b7 c3 b2 24			jp macro_next 
58ba				endm 
# End of macro NEXTW
58ba			.SCONST2: 
58ba				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
58ba 6d				db WORD_SYS_CORE+89             
58bb d2 58			dw .SCONST3            
58bd 08				db 7 + 1 
58be .. 00			db "FILEEXT",0              
58c6				endm 
# End of macro CWHEAD
58c6			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
58c6			; | | Compatible with PicoSPINet  
58c6 3a 67 fa				ld a, (store_openext) 
58c9 26 00				ld h, 0 
58cb 6f					ld l, a 
58cc cd 05 21				call forth_push_numhl 
58cf					NEXTW 
58cf c3 b2 24			jp macro_next 
58d2				endm 
# End of macro NEXTW
58d2			.SCONST3: 
58d2				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
58d2 6d				db WORD_SYS_CORE+89             
58d3 ea 58			dw .SCONST4            
58d5 08				db 7 + 1 
58d6 .. 00			db "FILEMAX",0              
58de				endm 
# End of macro CWHEAD
58de			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
58de			; | | Compatible with PicoSPINet  
58de 3a 66 fa				ld a, (store_openmaxext) 
58e1 26 00				ld h, 0 
58e3 6f					ld l, a 
58e4 cd 05 21				call forth_push_numhl 
58e7					NEXTW 
58e7 c3 b2 24			jp macro_next 
58ea				endm 
# End of macro NEXTW
58ea			.SCONST4: 
58ea				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
58ea 6d				db WORD_SYS_CORE+89             
58eb 00 59			dw .SCONST5            
58ed 09				db 8 + 1 
58ee .. 00			db "FILEADDR",0              
58f7				endm 
# End of macro CWHEAD
58f7			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
58f7			; | | Compatible with PicoSPINet  
58f7 2a 68 fa				ld hl, (store_openaddr) 
58fa cd 05 21				call forth_push_numhl 
58fd					NEXTW 
58fd c3 b2 24			jp macro_next 
5900				endm 
# End of macro NEXTW
5900			.SCONST5: 
5900				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
5900 6d				db WORD_SYS_CORE+89             
5901 21 59			dw .SCONST6            
5903 09				db 8 + 1 
5904 .. 00			db "FILEPAGE",0              
590d				endm 
# End of macro CWHEAD
590d			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
590d			; | | Compatible with PicoSPINet  
590d 2a 68 fa				ld hl, (store_openaddr) 
5910 e5					push hl 
5911 c1					pop bc 
5912 16 00				ld d, 0 
5914 1e 40				ld e, STORE_BLOCK_PHY 
5916 cd 2d 0f				call Div16 
5919 c5					push bc 
591a e1					pop hl 
591b cd 05 21				call forth_push_numhl 
591e					NEXTW 
591e c3 b2 24			jp macro_next 
5921				endm 
# End of macro NEXTW
5921			.SCONST6: 
5921				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5921 6d				db WORD_SYS_CORE+89             
5922 3a 59			dw .ENDSTORAGE            
5924 09				db 8 + 1 
5925 .. 00			db "READCONT",0              
592e				endm 
# End of macro CWHEAD
592e			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
592e			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
592e			; | | a further read should, if applicable, be CONCAT to the previous read. 
592e			; | | Compatible with PicoSPINet  
592e 3a 6a fa				ld a, (store_readcont) 
5931 26 00				ld h, 0 
5933 6f					ld l, a 
5934 cd 05 21				call forth_push_numhl 
5937					NEXTW 
5937 c3 b2 24			jp macro_next 
593a				endm 
# End of macro NEXTW
593a			.ENDSTORAGE: 
593a			; eof 
# End of file forth_words_storage.asm
593a			endif 
593a				include "forth_words_device.asm" 
593a			; Device related words 
593a			 
593a			; | ## Device Words 
593a			 
593a			;if SOUND_ENABLE 
593a			;.NOTE: 
593a			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
593a			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
593a			;		if DEBUG_FORTH_WORDS_KEY 
593a			;			DMARK "NTE" 
593a			;			CALLMONITOR 
593a			;		endif 
593a			; 
593a			;	 
593a			; 
593a			;		NEXTW 
593a			;.AFTERSOUND: 
593a			;endif 
593a			 
593a			 
593a			USE_GPIO: equ 0 
593a			 
593a			if USE_GPIO 
593a			.GP1: 
593a				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
593a			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
593a					NEXTW 
593a			.GP2: 
593a				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
593a			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
593a			 
593a					NEXTW 
593a			 
593a			.GP3: 
593a				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
593a			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
593a			 
593a					NEXTW 
593a			 
593a			.GP4: 
593a				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
593a			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
593a			 
593a					NEXTW 
593a			.SIN: 
593a			 
593a			 
593a			endif 
593a			 
593a			 
593a				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
593a 33				db WORD_SYS_CORE+31             
593b 6f 59			dw .SOUT            
593d 03				db 2 + 1 
593e .. 00			db "IN",0              
5941				endm 
# End of macro CWHEAD
5941			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5941					if DEBUG_FORTH_WORDS_KEY 
5941						DMARK "IN." 
5941 f5				push af  
5942 3a 56 59			ld a, (.dmark)  
5945 32 68 fe			ld (debug_mark),a  
5948 3a 57 59			ld a, (.dmark+1)  
594b 32 69 fe			ld (debug_mark+1),a  
594e 3a 58 59			ld a, (.dmark+2)  
5951 32 6a fe			ld (debug_mark+2),a  
5954 18 03			jr .pastdmark  
5956 ..			.dmark: db "IN."  
5959 f1			.pastdmark: pop af  
595a			endm  
# End of macro DMARK
595a						CALLMONITOR 
595a cd 6c fe			call debug_vector  
595d				endm  
# End of macro CALLMONITOR
595d					endif 
595d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
595d cd fc 22			call macro_dsp_valuehl 
5960				endm 
# End of macro FORTH_DSP_VALUEHL
5960			 
5960 e5					push hl 
5961			 
5961					; destroy value TOS 
5961			 
5961					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5961 cd b4 23			call macro_forth_dsp_pop 
5964				endm 
# End of macro FORTH_DSP_POP
5964			 
5964					; one value on hl get other one back 
5964			 
5964 c1					pop bc 
5965			 
5965					; do the sub 
5965			;		ex de, hl 
5965			 
5965 ed 68				in l,(c) 
5967			 
5967					; save it 
5967			 
5967 26 00				ld h,0 
5969			 
5969					; TODO push value back onto stack for another op etc 
5969			 
5969 cd 05 21				call forth_push_numhl 
596c					NEXTW 
596c c3 b2 24			jp macro_next 
596f				endm 
# End of macro NEXTW
596f			.SOUT: 
596f				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
596f 34				db WORD_SYS_CORE+32             
5970 c2 59			dw .SPIO            
5972 04				db 3 + 1 
5973 .. 00			db "OUT",0              
5977				endm 
# End of macro CWHEAD
5977			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5977					if DEBUG_FORTH_WORDS_KEY 
5977						DMARK "OUT" 
5977 f5				push af  
5978 3a 8c 59			ld a, (.dmark)  
597b 32 68 fe			ld (debug_mark),a  
597e 3a 8d 59			ld a, (.dmark+1)  
5981 32 69 fe			ld (debug_mark+1),a  
5984 3a 8e 59			ld a, (.dmark+2)  
5987 32 6a fe			ld (debug_mark+2),a  
598a 18 03			jr .pastdmark  
598c ..			.dmark: db "OUT"  
598f f1			.pastdmark: pop af  
5990			endm  
# End of macro DMARK
5990						CALLMONITOR 
5990 cd 6c fe			call debug_vector  
5993				endm  
# End of macro CALLMONITOR
5993					endif 
5993			 
5993					; get port 
5993			 
5993					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5993 cd fc 22			call macro_dsp_valuehl 
5996				endm 
# End of macro FORTH_DSP_VALUEHL
5996			 
5996 e5					push hl 
5997			 
5997					; destroy value TOS 
5997			 
5997					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5997 cd b4 23			call macro_forth_dsp_pop 
599a				endm 
# End of macro FORTH_DSP_POP
599a			 
599a					; get byte to send 
599a			 
599a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
599a cd fc 22			call macro_dsp_valuehl 
599d				endm 
# End of macro FORTH_DSP_VALUEHL
599d			 
599d			;		push hl 
599d			 
599d					; destroy value TOS 
599d			 
599d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
599d cd b4 23			call macro_forth_dsp_pop 
59a0				endm 
# End of macro FORTH_DSP_POP
59a0			 
59a0					; one value on hl get other one back 
59a0			 
59a0			;		pop hl 
59a0			 
59a0 c1					pop bc 
59a1			 
59a1					if DEBUG_FORTH_WORDS 
59a1						DMARK "OUT" 
59a1 f5				push af  
59a2 3a b6 59			ld a, (.dmark)  
59a5 32 68 fe			ld (debug_mark),a  
59a8 3a b7 59			ld a, (.dmark+1)  
59ab 32 69 fe			ld (debug_mark+1),a  
59ae 3a b8 59			ld a, (.dmark+2)  
59b1 32 6a fe			ld (debug_mark+2),a  
59b4 18 03			jr .pastdmark  
59b6 ..			.dmark: db "OUT"  
59b9 f1			.pastdmark: pop af  
59ba			endm  
# End of macro DMARK
59ba						CALLMONITOR 
59ba cd 6c fe			call debug_vector  
59bd				endm  
# End of macro CALLMONITOR
59bd					endif 
59bd			 
59bd ed 69				out (c), l 
59bf			 
59bf					NEXTW 
59bf c3 b2 24			jp macro_next 
59c2				endm 
# End of macro NEXTW
59c2			 
59c2			 
59c2			.SPIO: 
59c2			 
59c2			if STORAGE_SE 
59c2				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
59c2 51				db WORD_SYS_CORE+61             
59c3 d3 59			dw .SPICEH            
59c5 07				db 6 + 1 
59c6 .. 00			db "SPICEL",0              
59cd				endm 
# End of macro CWHEAD
59cd			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
59cd			 
59cd cd 14 02				call spi_ce_low 
59d0			    NEXTW 
59d0 c3 b2 24			jp macro_next 
59d3				endm 
# End of macro NEXTW
59d3			 
59d3			.SPICEH: 
59d3				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
59d3 51				db WORD_SYS_CORE+61             
59d4 e4 59			dw .SPIOb            
59d6 07				db 6 + 1 
59d7 .. 00			db "SPICEH",0              
59de				endm 
# End of macro CWHEAD
59de			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
59de			 
59de cd 03 02				call spi_ce_high 
59e1			    NEXTW 
59e1 c3 b2 24			jp macro_next 
59e4				endm 
# End of macro NEXTW
59e4			 
59e4			 
59e4			.SPIOb: 
59e4			 
59e4				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
59e4 51				db WORD_SYS_CORE+61             
59e5 16 5a			dw .SPII            
59e7 05				db 4 + 1 
59e8 .. 00			db "SPIO",0              
59ed				endm 
# End of macro CWHEAD
59ed			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
59ed			 
59ed					if DEBUG_FORTH_WORDS_KEY 
59ed						DMARK "SPo" 
59ed f5				push af  
59ee 3a 02 5a			ld a, (.dmark)  
59f1 32 68 fe			ld (debug_mark),a  
59f4 3a 03 5a			ld a, (.dmark+1)  
59f7 32 69 fe			ld (debug_mark+1),a  
59fa 3a 04 5a			ld a, (.dmark+2)  
59fd 32 6a fe			ld (debug_mark+2),a  
5a00 18 03			jr .pastdmark  
5a02 ..			.dmark: db "SPo"  
5a05 f1			.pastdmark: pop af  
5a06			endm  
# End of macro DMARK
5a06						CALLMONITOR 
5a06 cd 6c fe			call debug_vector  
5a09				endm  
# End of macro CALLMONITOR
5a09					endif 
5a09					; get port 
5a09			 
5a09			 
5a09					; get byte to send 
5a09			 
5a09					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a09 cd fc 22			call macro_dsp_valuehl 
5a0c				endm 
# End of macro FORTH_DSP_VALUEHL
5a0c			 
5a0c			;		push hl    ; u1  
5a0c			 
5a0c					; destroy value TOS 
5a0c			 
5a0c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a0c cd b4 23			call macro_forth_dsp_pop 
5a0f				endm 
# End of macro FORTH_DSP_POP
5a0f			 
5a0f					; one value on hl get other one back 
5a0f			 
5a0f			;		pop hl   ; u2 - addr 
5a0f			 
5a0f					; TODO Send SPI byte 
5a0f			 
5a0f			;		push hl 
5a0f			;		call spi_ce_low 
5a0f			;		pop hl 
5a0f 7d					ld a, l 
5a10 cd 02 01				call spi_send_byte 
5a13			;		call spi_ce_high 
5a13			 
5a13					NEXTW 
5a13 c3 b2 24			jp macro_next 
5a16				endm 
# End of macro NEXTW
5a16			 
5a16			.SPII: 
5a16				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5a16 52				db WORD_SYS_CORE+62             
5a17 7f 5a			dw .SESEL            
5a19 06				db 5 + 1 
5a1a .. 00			db "SPII",0              
5a1f				endm 
# End of macro CWHEAD
5a1f			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5a1f					if DEBUG_FORTH_WORDS_KEY 
5a1f						DMARK "SPi" 
5a1f f5				push af  
5a20 3a 34 5a			ld a, (.dmark)  
5a23 32 68 fe			ld (debug_mark),a  
5a26 3a 35 5a			ld a, (.dmark+1)  
5a29 32 69 fe			ld (debug_mark+1),a  
5a2c 3a 36 5a			ld a, (.dmark+2)  
5a2f 32 6a fe			ld (debug_mark+2),a  
5a32 18 03			jr .pastdmark  
5a34 ..			.dmark: db "SPi"  
5a37 f1			.pastdmark: pop af  
5a38			endm  
# End of macro DMARK
5a38						CALLMONITOR 
5a38 cd 6c fe			call debug_vector  
5a3b				endm  
# End of macro CALLMONITOR
5a3b					endif 
5a3b			 
5a3b					; TODO Get SPI byte 
5a3b			 
5a3b cd 29 01				call spi_read_byte 
5a3e			 
5a3e					if DEBUG_FORTH_WORDS 
5a3e						DMARK "Si2" 
5a3e f5				push af  
5a3f 3a 53 5a			ld a, (.dmark)  
5a42 32 68 fe			ld (debug_mark),a  
5a45 3a 54 5a			ld a, (.dmark+1)  
5a48 32 69 fe			ld (debug_mark+1),a  
5a4b 3a 55 5a			ld a, (.dmark+2)  
5a4e 32 6a fe			ld (debug_mark+2),a  
5a51 18 03			jr .pastdmark  
5a53 ..			.dmark: db "Si2"  
5a56 f1			.pastdmark: pop af  
5a57			endm  
# End of macro DMARK
5a57						CALLMONITOR 
5a57 cd 6c fe			call debug_vector  
5a5a				endm  
# End of macro CALLMONITOR
5a5a					endif 
5a5a 26 00				ld h, 0 
5a5c 6f					ld l, a 
5a5d					if DEBUG_FORTH_WORDS 
5a5d						DMARK "Si3" 
5a5d f5				push af  
5a5e 3a 72 5a			ld a, (.dmark)  
5a61 32 68 fe			ld (debug_mark),a  
5a64 3a 73 5a			ld a, (.dmark+1)  
5a67 32 69 fe			ld (debug_mark+1),a  
5a6a 3a 74 5a			ld a, (.dmark+2)  
5a6d 32 6a fe			ld (debug_mark+2),a  
5a70 18 03			jr .pastdmark  
5a72 ..			.dmark: db "Si3"  
5a75 f1			.pastdmark: pop af  
5a76			endm  
# End of macro DMARK
5a76						CALLMONITOR 
5a76 cd 6c fe			call debug_vector  
5a79				endm  
# End of macro CALLMONITOR
5a79					endif 
5a79 cd 05 21				call forth_push_numhl 
5a7c			 
5a7c					NEXTW 
5a7c c3 b2 24			jp macro_next 
5a7f				endm 
# End of macro NEXTW
5a7f			 
5a7f			 
5a7f			 
5a7f			.SESEL: 
5a7f				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5a7f 66				db WORD_SYS_CORE+82             
5a80 28 5b			dw .CARTDEV            
5a82 05				db 4 + 1 
5a83 .. 00			db "BANK",0              
5a88				endm 
# End of macro CWHEAD
5a88			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5a88					if DEBUG_FORTH_WORDS_KEY 
5a88						DMARK "BNK" 
5a88 f5				push af  
5a89 3a 9d 5a			ld a, (.dmark)  
5a8c 32 68 fe			ld (debug_mark),a  
5a8f 3a 9e 5a			ld a, (.dmark+1)  
5a92 32 69 fe			ld (debug_mark+1),a  
5a95 3a 9f 5a			ld a, (.dmark+2)  
5a98 32 6a fe			ld (debug_mark+2),a  
5a9b 18 03			jr .pastdmark  
5a9d ..			.dmark: db "BNK"  
5aa0 f1			.pastdmark: pop af  
5aa1			endm  
# End of macro DMARK
5aa1						CALLMONITOR 
5aa1 cd 6c fe			call debug_vector  
5aa4				endm  
# End of macro CALLMONITOR
5aa4					endif 
5aa4			 
5aa4 3e ff				ld a, 255 
5aa6 32 60 fa				ld (spi_cartdev), a 
5aa9			 
5aa9					; get bank 
5aa9			 
5aa9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5aa9 cd fc 22			call macro_dsp_valuehl 
5aac				endm 
# End of macro FORTH_DSP_VALUEHL
5aac			 
5aac			;		push hl 
5aac			 
5aac					; destroy value TOS 
5aac			 
5aac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5aac cd b4 23			call macro_forth_dsp_pop 
5aaf				endm 
# End of macro FORTH_DSP_POP
5aaf			 
5aaf					; one value on hl get other one back 
5aaf			 
5aaf			;		pop hl 
5aaf			 
5aaf			 
5aaf 0e ff				ld c, SPI_CE_HIGH 
5ab1 06 30				ld b, '0'    ; human readable bank number 
5ab3			 
5ab3 7d					ld a, l 
5ab4			 
5ab4					if DEBUG_FORTH_WORDS 
5ab4						DMARK "BNK" 
5ab4 f5				push af  
5ab5 3a c9 5a			ld a, (.dmark)  
5ab8 32 68 fe			ld (debug_mark),a  
5abb 3a ca 5a			ld a, (.dmark+1)  
5abe 32 69 fe			ld (debug_mark+1),a  
5ac1 3a cb 5a			ld a, (.dmark+2)  
5ac4 32 6a fe			ld (debug_mark+2),a  
5ac7 18 03			jr .pastdmark  
5ac9 ..			.dmark: db "BNK"  
5acc f1			.pastdmark: pop af  
5acd			endm  
# End of macro DMARK
5acd						CALLMONITOR 
5acd cd 6c fe			call debug_vector  
5ad0				endm  
# End of macro CALLMONITOR
5ad0					endif 
5ad0			 
5ad0					; active low 
5ad0			 
5ad0 fe 00				cp 0 
5ad2 28 28				jr z, .bset 
5ad4 fe 01				cp 1 
5ad6 20 04				jr nz, .b2 
5ad8 cb 81				res 0, c 
5ada 06 31				ld b, '1'    ; human readable bank number 
5adc fe 02		.b2:		cp 2 
5ade 20 04				jr nz, .b3 
5ae0 cb 89				res 1, c 
5ae2 06 32				ld b, '2'    ; human readable bank number 
5ae4 fe 03		.b3:		cp 3 
5ae6 20 04				jr nz, .b4 
5ae8 cb 91				res 2, c 
5aea 06 33				ld b, '3'    ; human readable bank number 
5aec fe 04		.b4:		cp 4 
5aee 20 04				jr nz, .b5 
5af0 cb 99				res 3, c 
5af2 06 34				ld b, '4'    ; human readable bank number 
5af4 fe 05		.b5:		cp 5 
5af6 20 04				jr nz, .bset 
5af8 cb a1				res 4, c 
5afa 06 35				ld b, '5'    ; human readable bank number 
5afc			 
5afc			.bset: 
5afc 79					ld a, c 
5afd 32 5d fa				ld (spi_device),a 
5b00 78					ld a, b 
5b01 32 5c fa				ld (spi_device_id),a 
5b04					if DEBUG_FORTH_WORDS 
5b04						DMARK "BN2" 
5b04 f5				push af  
5b05 3a 19 5b			ld a, (.dmark)  
5b08 32 68 fe			ld (debug_mark),a  
5b0b 3a 1a 5b			ld a, (.dmark+1)  
5b0e 32 69 fe			ld (debug_mark+1),a  
5b11 3a 1b 5b			ld a, (.dmark+2)  
5b14 32 6a fe			ld (debug_mark+2),a  
5b17 18 03			jr .pastdmark  
5b19 ..			.dmark: db "BN2"  
5b1c f1			.pastdmark: pop af  
5b1d			endm  
# End of macro DMARK
5b1d						CALLMONITOR 
5b1d cd 6c fe			call debug_vector  
5b20				endm  
# End of macro CALLMONITOR
5b20					endif 
5b20			 
5b20					; set default SPI clk pulse time as disabled for BANK use 
5b20			 
5b20 3e 00				ld a, 0 
5b22 32 61 fa				ld (spi_clktime), a 
5b25			 
5b25					NEXTW 
5b25 c3 b2 24			jp macro_next 
5b28				endm 
# End of macro NEXTW
5b28			 
5b28			.CARTDEV: 
5b28				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5b28 66				db WORD_SYS_CORE+82             
5b29 d6 5b			dw .ENDDEVICE            
5b2b 08				db 7 + 1 
5b2c .. 00			db "CARTDEV",0              
5b34				endm 
# End of macro CWHEAD
5b34			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5b34					if DEBUG_FORTH_WORDS_KEY 
5b34						DMARK "CDV" 
5b34 f5				push af  
5b35 3a 49 5b			ld a, (.dmark)  
5b38 32 68 fe			ld (debug_mark),a  
5b3b 3a 4a 5b			ld a, (.dmark+1)  
5b3e 32 69 fe			ld (debug_mark+1),a  
5b41 3a 4b 5b			ld a, (.dmark+2)  
5b44 32 6a fe			ld (debug_mark+2),a  
5b47 18 03			jr .pastdmark  
5b49 ..			.dmark: db "CDV"  
5b4c f1			.pastdmark: pop af  
5b4d			endm  
# End of macro DMARK
5b4d						CALLMONITOR 
5b4d cd 6c fe			call debug_vector  
5b50				endm  
# End of macro CALLMONITOR
5b50					endif 
5b50			 
5b50					; disable se storage bank selection 
5b50			 
5b50 3e ff				ld a, SPI_CE_HIGH		; ce high 
5b52 32 5d fa				ld (spi_device), a 
5b55			 
5b55					; get bank 
5b55			 
5b55					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b55 cd fc 22			call macro_dsp_valuehl 
5b58				endm 
# End of macro FORTH_DSP_VALUEHL
5b58			 
5b58			;		push hl 
5b58			 
5b58					; destroy value TOS 
5b58			 
5b58					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b58 cd b4 23			call macro_forth_dsp_pop 
5b5b				endm 
# End of macro FORTH_DSP_POP
5b5b			 
5b5b					; one value on hl get other one back 
5b5b			 
5b5b			;		pop hl 
5b5b			 
5b5b					; active low 
5b5b			 
5b5b 0e ff				ld c, 255 
5b5d			 
5b5d 7d					ld a, l 
5b5e					if DEBUG_FORTH_WORDS 
5b5e						DMARK "CDV" 
5b5e f5				push af  
5b5f 3a 73 5b			ld a, (.dmark)  
5b62 32 68 fe			ld (debug_mark),a  
5b65 3a 74 5b			ld a, (.dmark+1)  
5b68 32 69 fe			ld (debug_mark+1),a  
5b6b 3a 75 5b			ld a, (.dmark+2)  
5b6e 32 6a fe			ld (debug_mark+2),a  
5b71 18 03			jr .pastdmark  
5b73 ..			.dmark: db "CDV"  
5b76 f1			.pastdmark: pop af  
5b77			endm  
# End of macro DMARK
5b77						CALLMONITOR 
5b77 cd 6c fe			call debug_vector  
5b7a				endm  
# End of macro CALLMONITOR
5b7a					endif 
5b7a fe 00				cp 0 
5b7c 28 30				jr z, .cset 
5b7e fe 01				cp 1 
5b80 20 02				jr nz, .c2 
5b82 cb 81				res 0, c 
5b84 fe 02		.c2:		cp 2 
5b86 20 02				jr nz, .c3 
5b88 cb 89				res 1, c 
5b8a fe 03		.c3:		cp 3 
5b8c 20 02				jr nz, .c4 
5b8e cb 91				res 2, c 
5b90 fe 04		.c4:		cp 4 
5b92 20 02				jr nz, .c5 
5b94 cb 99				res 3, c 
5b96 fe 05		.c5:		cp 5 
5b98 20 02				jr nz, .c6 
5b9a cb a1				res 4, c 
5b9c fe 06		.c6:		cp 6 
5b9e 20 02				jr nz, .c7 
5ba0 cb a9				res 5, c 
5ba2 fe 07		.c7:		cp 7 
5ba4 20 02				jr nz, .c8 
5ba6 cb b1				res 6, c 
5ba8 fe 08		.c8:		cp 8 
5baa 20 02				jr nz, .cset 
5bac cb b9				res 7, c 
5bae 79			.cset:		ld a, c 
5baf 32 60 fa				ld (spi_cartdev),a 
5bb2			 
5bb2					if DEBUG_FORTH_WORDS 
5bb2						DMARK "CD2" 
5bb2 f5				push af  
5bb3 3a c7 5b			ld a, (.dmark)  
5bb6 32 68 fe			ld (debug_mark),a  
5bb9 3a c8 5b			ld a, (.dmark+1)  
5bbc 32 69 fe			ld (debug_mark+1),a  
5bbf 3a c9 5b			ld a, (.dmark+2)  
5bc2 32 6a fe			ld (debug_mark+2),a  
5bc5 18 03			jr .pastdmark  
5bc7 ..			.dmark: db "CD2"  
5bca f1			.pastdmark: pop af  
5bcb			endm  
# End of macro DMARK
5bcb						CALLMONITOR 
5bcb cd 6c fe			call debug_vector  
5bce				endm  
# End of macro CALLMONITOR
5bce					endif 
5bce			 
5bce					; set default SPI clk pulse time as 10ms for CARTDEV use 
5bce			 
5bce 3e 0a				ld a, $0a 
5bd0 32 61 fa				ld (spi_clktime), a 
5bd3					NEXTW 
5bd3 c3 b2 24			jp macro_next 
5bd6				endm 
# End of macro NEXTW
5bd6			endif 
5bd6			 
5bd6			.ENDDEVICE: 
5bd6			; eof 
5bd6			 
# End of file forth_words_device.asm
5bd6			 
5bd6			; var handler 
5bd6			 
5bd6			 
5bd6			.VARS: 
5bd6				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5bd6 77				db WORD_SYS_CORE+99             
5bd7 87 5c			dw .V0            
5bd9 04				db 3 + 1 
5bda .. 00			db "VAR",0              
5bde				endm 
# End of macro CWHEAD
5bde			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5bde			;| 
5bde			;| The variable name should consist of a single letter. e.g. "a" 
5bde			;! If a full string is passed then only the first char is looked at 
5bde			;| Any other char could exceed bounds checks!  
5bde			 
5bde					if DEBUG_FORTH_WORDS_KEY 
5bde						DMARK "VAR" 
5bde f5				push af  
5bdf 3a f3 5b			ld a, (.dmark)  
5be2 32 68 fe			ld (debug_mark),a  
5be5 3a f4 5b			ld a, (.dmark+1)  
5be8 32 69 fe			ld (debug_mark+1),a  
5beb 3a f5 5b			ld a, (.dmark+2)  
5bee 32 6a fe			ld (debug_mark+2),a  
5bf1 18 03			jr .pastdmark  
5bf3 ..			.dmark: db "VAR"  
5bf6 f1			.pastdmark: pop af  
5bf7			endm  
# End of macro DMARK
5bf7						CALLMONITOR 
5bf7 cd 6c fe			call debug_vector  
5bfa				endm  
# End of macro CALLMONITOR
5bfa					endif 
5bfa			 
5bfa					FORTH_DSP_VALUEHL 
5bfa cd fc 22			call macro_dsp_valuehl 
5bfd				endm 
# End of macro FORTH_DSP_VALUEHL
5bfd			 
5bfd 7e					ld a, (hl)    ; get first char on of the string 
5bfe			 
5bfe			 
5bfe					if DEBUG_FORTH_WORDS 
5bfe						DMARK "VR1" 
5bfe f5				push af  
5bff 3a 13 5c			ld a, (.dmark)  
5c02 32 68 fe			ld (debug_mark),a  
5c05 3a 14 5c			ld a, (.dmark+1)  
5c08 32 69 fe			ld (debug_mark+1),a  
5c0b 3a 15 5c			ld a, (.dmark+2)  
5c0e 32 6a fe			ld (debug_mark+2),a  
5c11 18 03			jr .pastdmark  
5c13 ..			.dmark: db "VR1"  
5c16 f1			.pastdmark: pop af  
5c17			endm  
# End of macro DMARK
5c17						CALLMONITOR 
5c17 cd 6c fe			call debug_vector  
5c1a				endm  
# End of macro CALLMONITOR
5c1a					endif 
5c1a					 
5c1a f5					push af	 
5c1b					FORTH_DSP_POP 
5c1b cd b4 23			call macro_forth_dsp_pop 
5c1e				endm 
# End of macro FORTH_DSP_POP
5c1e f1					pop af 
5c1f			 
5c1f					; convert to upper 
5c1f			 
5c1f cd 3d 13				call to_upper 
5c22					if DEBUG_FORTH_WORDS 
5c22						DMARK "Vaa" 
5c22 f5				push af  
5c23 3a 37 5c			ld a, (.dmark)  
5c26 32 68 fe			ld (debug_mark),a  
5c29 3a 38 5c			ld a, (.dmark+1)  
5c2c 32 69 fe			ld (debug_mark+1),a  
5c2f 3a 39 5c			ld a, (.dmark+2)  
5c32 32 6a fe			ld (debug_mark+2),a  
5c35 18 03			jr .pastdmark  
5c37 ..			.dmark: db "Vaa"  
5c3a f1			.pastdmark: pop af  
5c3b			endm  
# End of macro DMARK
5c3b						CALLMONITOR 
5c3b cd 6c fe			call debug_vector  
5c3e				endm  
# End of macro CALLMONITOR
5c3e					endif 
5c3e 06 41				ld b, 'A' 
5c40 90					sub b			; set offset 
5c41					if DEBUG_FORTH_WORDS 
5c41						DMARK "Vbb" 
5c41 f5				push af  
5c42 3a 56 5c			ld a, (.dmark)  
5c45 32 68 fe			ld (debug_mark),a  
5c48 3a 57 5c			ld a, (.dmark+1)  
5c4b 32 69 fe			ld (debug_mark+1),a  
5c4e 3a 58 5c			ld a, (.dmark+2)  
5c51 32 6a fe			ld (debug_mark+2),a  
5c54 18 03			jr .pastdmark  
5c56 ..			.dmark: db "Vbb"  
5c59 f1			.pastdmark: pop af  
5c5a			endm  
# End of macro DMARK
5c5a						CALLMONITOR 
5c5a cd 6c fe			call debug_vector  
5c5d				endm  
# End of macro CALLMONITOR
5c5d					endif 
5c5d cb 27				sla a  
5c5f				 
5c5f					 
5c5f					if DEBUG_FORTH_WORDS 
5c5f						DMARK "VR2" 
5c5f f5				push af  
5c60 3a 74 5c			ld a, (.dmark)  
5c63 32 68 fe			ld (debug_mark),a  
5c66 3a 75 5c			ld a, (.dmark+1)  
5c69 32 69 fe			ld (debug_mark+1),a  
5c6c 3a 76 5c			ld a, (.dmark+2)  
5c6f 32 6a fe			ld (debug_mark+2),a  
5c72 18 03			jr .pastdmark  
5c74 ..			.dmark: db "VR2"  
5c77 f1			.pastdmark: pop af  
5c78			endm  
# End of macro DMARK
5c78						CALLMONITOR 
5c78 cd 6c fe			call debug_vector  
5c7b				endm  
# End of macro CALLMONITOR
5c7b					endif 
5c7b			 
5c7b 21 f1 f9				ld hl, cli_var_array2 
5c7e cd d0 0f				call addatohl 
5c81 cd 05 21				call forth_push_numhl 
5c84			 
5c84			 
5c84				       NEXTW 
5c84 c3 b2 24			jp macro_next 
5c87				endm 
# End of macro NEXTW
5c87			.V0: 
5c87				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5c87 78				db WORD_SYS_CORE+100             
5c88 9f 5c			dw .V0Q            
5c8a 04				db 3 + 1 
5c8b .. 00			db "V0!",0              
5c8f				endm 
# End of macro CWHEAD
5c8f			;| V0! ( u1 -- )  Store value to v0  | DONE 
5c8f			 
5c8f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c8f cd fc 22			call macro_dsp_valuehl 
5c92				endm 
# End of macro FORTH_DSP_VALUEHL
5c92			 
5c92 11 25 fa				ld de, cli_var_array 
5c95			 
5c95 eb					ex de, hl 
5c96 73					ld (hl), e 
5c97 23					inc hl 
5c98 72					ld (hl), d 
5c99			 
5c99					; destroy value TOS 
5c99			 
5c99					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c99 cd b4 23			call macro_forth_dsp_pop 
5c9c				endm 
# End of macro FORTH_DSP_POP
5c9c			 
5c9c				       NEXTW 
5c9c c3 b2 24			jp macro_next 
5c9f				endm 
# End of macro NEXTW
5c9f			.V0Q: 
5c9f				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5c9f 79				db WORD_SYS_CORE+101             
5ca0 b0 5c			dw .V1S            
5ca2 04				db 3 + 1 
5ca3 .. 00			db "V0@",0              
5ca7				endm 
# End of macro CWHEAD
5ca7			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5ca7 2a 25 fa				ld hl, (cli_var_array) 
5caa cd 05 21				call forth_push_numhl 
5cad			 
5cad				       NEXTW 
5cad c3 b2 24			jp macro_next 
5cb0				endm 
# End of macro NEXTW
5cb0			.V1S: 
5cb0				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5cb0 7a				db WORD_SYS_CORE+102             
5cb1 c8 5c			dw .V1Q            
5cb3 04				db 3 + 1 
5cb4 .. 00			db "V1!",0              
5cb8				endm 
# End of macro CWHEAD
5cb8			;| V1! ( u1 -- )  Store value to v1 | DONE 
5cb8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5cb8 cd fc 22			call macro_dsp_valuehl 
5cbb				endm 
# End of macro FORTH_DSP_VALUEHL
5cbb			 
5cbb 11 27 fa				ld de, cli_var_array+2 
5cbe				 
5cbe eb					ex de, hl 
5cbf 73					ld (hl), e 
5cc0 23					inc hl 
5cc1 72					ld (hl), d 
5cc2			 
5cc2					; destroy value TOS 
5cc2			 
5cc2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cc2 cd b4 23			call macro_forth_dsp_pop 
5cc5				endm 
# End of macro FORTH_DSP_POP
5cc5				       NEXTW 
5cc5 c3 b2 24			jp macro_next 
5cc8				endm 
# End of macro NEXTW
5cc8			.V1Q: 
5cc8				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5cc8 7b				db WORD_SYS_CORE+103             
5cc9 d9 5c			dw .V2S            
5ccb 04				db 3 + 1 
5ccc .. 00			db "V1@",0              
5cd0				endm 
# End of macro CWHEAD
5cd0			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5cd0 2a 27 fa				ld hl, (cli_var_array+2) 
5cd3 cd 05 21				call forth_push_numhl 
5cd6				       NEXTW 
5cd6 c3 b2 24			jp macro_next 
5cd9				endm 
# End of macro NEXTW
5cd9			.V2S: 
5cd9				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5cd9 7c				db WORD_SYS_CORE+104             
5cda f1 5c			dw .V2Q            
5cdc 04				db 3 + 1 
5cdd .. 00			db "V2!",0              
5ce1				endm 
# End of macro CWHEAD
5ce1			;| V2! ( u1 -- )  Store value to v2 | DONE 
5ce1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ce1 cd fc 22			call macro_dsp_valuehl 
5ce4				endm 
# End of macro FORTH_DSP_VALUEHL
5ce4			 
5ce4 11 29 fa				ld de, cli_var_array+4 
5ce7				 
5ce7 eb					ex de, hl 
5ce8 73					ld (hl), e 
5ce9 23					inc hl 
5cea 72					ld (hl), d 
5ceb			 
5ceb					; destroy value TOS 
5ceb			 
5ceb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ceb cd b4 23			call macro_forth_dsp_pop 
5cee				endm 
# End of macro FORTH_DSP_POP
5cee				       NEXTW 
5cee c3 b2 24			jp macro_next 
5cf1				endm 
# End of macro NEXTW
5cf1			.V2Q: 
5cf1				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5cf1 7d				db WORD_SYS_CORE+105             
5cf2 02 5d			dw .V3S            
5cf4 04				db 3 + 1 
5cf5 .. 00			db "V2@",0              
5cf9				endm 
# End of macro CWHEAD
5cf9			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5cf9 2a 29 fa				ld hl, (cli_var_array+4) 
5cfc cd 05 21				call forth_push_numhl 
5cff				       NEXTW 
5cff c3 b2 24			jp macro_next 
5d02				endm 
# End of macro NEXTW
5d02			.V3S: 
5d02				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5d02 7c				db WORD_SYS_CORE+104             
5d03 1a 5d			dw .V3Q            
5d05 04				db 3 + 1 
5d06 .. 00			db "V3!",0              
5d0a				endm 
# End of macro CWHEAD
5d0a			;| V3! ( u1 -- )  Store value to v3 | DONE 
5d0a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5d0a cd fc 22			call macro_dsp_valuehl 
5d0d				endm 
# End of macro FORTH_DSP_VALUEHL
5d0d			 
5d0d 11 2b fa				ld de, cli_var_array+6 
5d10				 
5d10 eb					ex de, hl 
5d11 73					ld (hl), e 
5d12 23					inc hl 
5d13 72					ld (hl), d 
5d14			 
5d14					; destroy value TOS 
5d14			 
5d14					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5d14 cd b4 23			call macro_forth_dsp_pop 
5d17				endm 
# End of macro FORTH_DSP_POP
5d17				       NEXTW 
5d17 c3 b2 24			jp macro_next 
5d1a				endm 
# End of macro NEXTW
5d1a			.V3Q: 
5d1a				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5d1a 7d				db WORD_SYS_CORE+105             
5d1b 2b 5d			dw .END            
5d1d 04				db 3 + 1 
5d1e .. 00			db "V3@",0              
5d22				endm 
# End of macro CWHEAD
5d22			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5d22 2a 2b fa				ld hl, (cli_var_array+6) 
5d25 cd 05 21				call forth_push_numhl 
5d28				       NEXTW 
5d28 c3 b2 24			jp macro_next 
5d2b				endm 
# End of macro NEXTW
5d2b			 
5d2b			 
5d2b			 
5d2b			 
5d2b			 
5d2b			; end of dict marker 
5d2b			 
5d2b 00			.END:    db WORD_SYS_END 
5d2c 00 00			dw 0 
5d2e 00				db 0 
5d2f			 
5d2f			; use to jp here for user dict words to save on macro expansion  
5d2f			 
5d2f			user_dict_next: 
5d2f				NEXTW 
5d2f c3 b2 24			jp macro_next 
5d32				endm 
# End of macro NEXTW
5d32			 
5d32			 
5d32			user_exec: 
5d32				;    ld hl, <word code> 
5d32				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5d32				;    call forthexec 
5d32				;    jp user_dict_next   (NEXT) 
5d32			        ;    <word code bytes> 
5d32 eb				ex de, hl 
5d33 2a bf f4			ld hl,(os_tok_ptr) 
5d36				 
5d36				FORTH_RSP_NEXT 
5d36 cd ac 20			call macro_forth_rsp_next 
5d39				endm 
# End of macro FORTH_RSP_NEXT
5d39			 
5d39			if DEBUG_FORTH_UWORD 
5d39						DMARK "UEX" 
5d39 f5				push af  
5d3a 3a 4e 5d			ld a, (.dmark)  
5d3d 32 68 fe			ld (debug_mark),a  
5d40 3a 4f 5d			ld a, (.dmark+1)  
5d43 32 69 fe			ld (debug_mark+1),a  
5d46 3a 50 5d			ld a, (.dmark+2)  
5d49 32 6a fe			ld (debug_mark+2),a  
5d4c 18 03			jr .pastdmark  
5d4e ..			.dmark: db "UEX"  
5d51 f1			.pastdmark: pop af  
5d52			endm  
# End of macro DMARK
5d52				CALLMONITOR 
5d52 cd 6c fe			call debug_vector  
5d55				endm  
# End of macro CALLMONITOR
5d55			endif 
5d55			 
5d55			 
5d55			 
5d55 eb				ex de, hl 
5d56 22 bf f4			ld (os_tok_ptr), hl 
5d59				 
5d59				; Don't use next - Skips the first word in uword. 
5d59			 
5d59 c3 43 25			jp exec1 
5d5c			;	NEXT 
5d5c			 
5d5c			 
5d5c			; eof 
# End of file forth_wordsv4.asm
5d5c			endif 
5d5c			;;;;;;;;;;;;;; Debug code 
5d5c			 
5d5c			 
5d5c			;if DEBUG_FORTH_PARSE 
5d5c .. 00		.nowordfound: db "No match",0 
5d65 .. 00		.compword:	db "Comparing word ",0 
5d75 .. 00		.nextwordat:	db "Next word at",0 
5d82 .. 00		.charmatch:	db "Char match",0 
5d8d			;endif 
5d8d			if DEBUG_FORTH_JP 
5d8d			.foundword:	db "Word match. Exec..",0 
5d8d			endif 
5d8d			;if DEBUG_FORTH_PUSH 
5d8d .. 00		.enddict:	db "Dict end. Push.",0 
5d9d .. 00		.push_str:	db "Pushing string",0 
5dac .. 00		.push_num:	db "Pushing number",0 
5dbb .. 00		.data_sp:	db "SP:",0 
5dbf .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5dd1 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5de3 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5df5			;endif 
5df5			;if DEBUG_FORTH_MALLOC 
5df5 .. 00		.push_malloc:	db "Malloc address",0 
5e04			;endif 
5e04			 
5e04			 
5e04			 
5e04			; display malloc address and current data stack pointer  
5e04			 
5e04			malloc_error: 
5e04 d5				push de 
5e05 f5				push af 
5e06 e5				push hl 
5e07 cd 9c 0d			call clear_display 
5e0a 11 2a 5e			ld de, .mallocerr 
5e0d 3e 00			ld a,0 
5e0f			;	ld de,os_word_scratch 
5e0f cd af 0d			call str_at_display 
5e12 3e 11			ld a, display_row_1+17 
5e14 11 68 fe			ld de, debug_mark 
5e17 cd af 0d			call str_at_display 
5e1a cd bf 0d			call update_display 
5e1d				;call break_point_state 
5e1d cd c3 79			call cin_wait 
5e20			 
5e20			;	ld a, ' ' 
5e20			;	ld (os_view_disable), a 
5e20 cd 36 1a			call bp_on 
5e23 e1				pop hl 
5e24 f1				pop af 
5e25 d1				pop de	 
5e26				CALLMONITOR 
5e26 cd 6c fe			call debug_vector  
5e29				endm  
# End of macro CALLMONITOR
5e29 c9				ret 
5e2a			 
5e2a .. 00		.mallocerr: 	db "Malloc Error",0 
5e37			;if DEBUG_FORTH_PUSH 
5e37			display_data_sp: 
5e37 f5				push af 
5e38			 
5e38				; see if disabled 
5e38			 
5e38			 
5e38 3a 6c fe			ld a, (debug_vector) 
5e3b fe c9			cp $C9  ; RET 
5e3d				;ld a, (os_view_disable) 
5e3d				;cp '*' 
5e3d 28 67			jr z, .skipdsp 
5e3f			 
5e3f e5				push hl 
5e40 e5				push hl 
5e41 e5			push hl 
5e42 cd 9c 0d			call clear_display 
5e45 e1			pop hl 
5e46 7c				ld a,h 
5e47 21 c3 f4			ld hl, os_word_scratch 
5e4a cd d1 12			call hexout 
5e4d e1				pop hl 
5e4e 7d				ld a,l 
5e4f 21 c5 f4			ld hl, os_word_scratch+2 
5e52 cd d1 12			call hexout 
5e55 21 c7 f4			ld hl, os_word_scratch+4 
5e58 3e 00			ld a,0 
5e5a 77				ld (hl),a 
5e5b 11 c3 f4			ld de,os_word_scratch 
5e5e 3e 28				ld a, display_row_2 
5e60 cd af 0d				call str_at_display 
5e63 11 bf 5d			ld de, .wordinhl 
5e66 3e 00			ld a, display_row_1 
5e68			 
5e68 cd af 0d				call str_at_display 
5e6b 11 68 fe			ld de, debug_mark 
5e6e 3e 11			ld a, display_row_1+17 
5e70			 
5e70 cd af 0d				call str_at_display 
5e73			 
5e73				; display current data stack pointer 
5e73 11 bb 5d			ld de,.data_sp 
5e76 3e 30				ld a, display_row_2 + 8 
5e78 cd af 0d				call str_at_display 
5e7b			 
5e7b 2a eb f9			ld hl,(cli_data_sp) 
5e7e e5				push hl 
5e7f 7c				ld a,h 
5e80 21 c3 f4			ld hl, os_word_scratch 
5e83 cd d1 12			call hexout 
5e86 e1				pop hl 
5e87 7d				ld a,l 
5e88 21 c5 f4			ld hl, os_word_scratch+2 
5e8b cd d1 12			call hexout 
5e8e 21 c7 f4			ld hl, os_word_scratch+4 
5e91 3e 00			ld a,0 
5e93 77				ld (hl),a 
5e94 11 c3 f4			ld de,os_word_scratch 
5e97 3e 33				ld a, display_row_2 + 11 
5e99 cd af 0d				call str_at_display 
5e9c			 
5e9c			 
5e9c cd bf 0d			call update_display 
5e9f cd df 0c			call delay1s 
5ea2 cd df 0c			call delay1s 
5ea5 e1				pop hl 
5ea6			.skipdsp: 
5ea6 f1				pop af 
5ea7 c9				ret 
5ea8			 
5ea8			display_data_malloc: 
5ea8			 
5ea8 f5				push af 
5ea9 e5				push hl 
5eaa e5				push hl 
5eab e5			push hl 
5eac cd 9c 0d			call clear_display 
5eaf e1			pop hl 
5eb0 7c				ld a,h 
5eb1 21 c3 f4			ld hl, os_word_scratch 
5eb4 cd d1 12			call hexout 
5eb7 e1				pop hl 
5eb8 7d				ld a,l 
5eb9 21 c5 f4			ld hl, os_word_scratch+2 
5ebc cd d1 12			call hexout 
5ebf 21 c7 f4			ld hl, os_word_scratch+4 
5ec2 3e 00			ld a,0 
5ec4 77				ld (hl),a 
5ec5 11 c3 f4			ld de,os_word_scratch 
5ec8 3e 28				ld a, display_row_2 
5eca cd af 0d				call str_at_display 
5ecd 11 f5 5d			ld de, .push_malloc 
5ed0 3e 00			ld a, display_row_1 
5ed2			 
5ed2 cd af 0d				call str_at_display 
5ed5			 
5ed5				; display current data stack pointer 
5ed5 11 bb 5d			ld de,.data_sp 
5ed8 3e 30				ld a, display_row_2 + 8 
5eda cd af 0d				call str_at_display 
5edd			 
5edd 2a eb f9			ld hl,(cli_data_sp) 
5ee0 e5				push hl 
5ee1 7c				ld a,h 
5ee2 21 c3 f4			ld hl, os_word_scratch 
5ee5 cd d1 12			call hexout 
5ee8 e1				pop hl 
5ee9 7d				ld a,l 
5eea 21 c5 f4			ld hl, os_word_scratch+2 
5eed cd d1 12			call hexout 
5ef0 21 c7 f4			ld hl, os_word_scratch+4 
5ef3 3e 00			ld a,0 
5ef5 77				ld (hl),a 
5ef6 11 c3 f4			ld de,os_word_scratch 
5ef9 3e 33				ld a, display_row_2 + 11 
5efb cd af 0d				call str_at_display 
5efe			 
5efe cd bf 0d			call update_display 
5f01 cd df 0c			call delay1s 
5f04 cd df 0c			call delay1s 
5f07 e1				pop hl 
5f08 f1				pop af 
5f09 c9				ret 
5f0a			;endif 
5f0a			 
5f0a			include "forth_autostart.asm" 
5f0a			; list of commands to perform at system start up 
5f0a			 
5f0a			startcmds: 
5f0a			;	dw test11 
5f0a			;	dw test12 
5f0a			;	dw test13 
5f0a			;	dw test14 
5f0a			;	dw test15 
5f0a			;	dw test16 
5f0a			;	dw test17 
5f0a			;	dw ifthtest1 
5f0a			;	dw ifthtest2 
5f0a			;	dw ifthtest3 
5f0a			;	dw mmtest1 
5f0a			;	dw mmtest2 
5f0a			;	dw mmtest3 
5f0a			;	dw mmtest4 
5f0a			;	dw mmtest5 
5f0a			;	dw mmtest6 
5f0a			;	dw iftest1 
5f0a			;	dw iftest2 
5f0a			;	dw iftest3 
5f0a			;	dw looptest1 
5f0a			;	dw looptest2 
5f0a			;	dw test1 
5f0a			;	dw test2 
5f0a			;	dw test3 
5f0a			;	dw test4 
5f0a			;	dw game2r 
5f0a			;	dw game2b1 
5f0a			;	dw game2b2 
5f0a			 
5f0a				; start up words that are actually useful 
5f0a			 
5f0a			;    dw spi1 
5f0a			;    dw spi2 
5f0a			;    dw spi3 
5f0a			;    dw spi4 
5f0a			;    dw spi5 
5f0a			;    dw spi6 
5f0a			;    dw spi7 
5f0a			; 
5f0a			;    dw spi8 
5f0a			;    dw spi9 
5f0a			;    dw spi10 
5f0a			 
5f0a			; file editor 
5f0a			;	dw edit1 
5f0a			;	dw edit2 
5f0a			;	dw edit3 
5f0a			 
5f0a			;	dw longread 
5f0a 0a 63			dw clrstack 
5f0c 3e 63			dw type 
5f0e			;	dw stest 
5f0e 63 63			dw strncpy 
5f10			;	dw list 
5f10 c4 63			dw start1 
5f12 d4 63			dw start2 
5f14			;	dw start3 
5f14			;	dw start3b 
5f14			;	dw start3c 
5f14			 
5f14				; (unit) testing words 
5f14			 
5f14			;	dw mtesta 
5f14			;	dw mtestb 
5f14			;	dw mtestc 
5f14			;	dw mtestd 
5f14			;	dw mteste 
5f14			 
5f14				; demo/game words 
5f14			 
5f14			;        dw game3w 
5f14			;        dw game3p 
5f14			;        dw game3sc 
5f14			;        dw game3vsi 
5f14			;        dw game3vs 
5f14				 
5f14 2d 6e			dw game2b 
5f16 9b 6e			dw game2bf 
5f18 e5 6e			dw game2mba 
5f1a 7b 6f			dw game2mbas 
5f1c bd 6f			dw game2mb 
5f1e			 
5f1e ee 6a			dw game1 
5f20 ff 6a			dw game1a 
5f22 61 6b			dw game1b 
5f24 96 6b			dw game1c 
5f26 cc 6b			dw game1d 
5f28 fd 6b			dw game1s 
5f2a 11 6c			dw game1t 
5f2c 26 6c			dw game1f 
5f2e 5a 6c			dw game1z 
5f30 9e 6c			dw game1zz 
5f32			 
5f32 08 69			dw test5 
5f34 40 69			dw test6 
5f36 78 69			dw test7 
5f38 8c 69			dw test8 
5f3a b8 69			dw test9 
5f3c ce 69			dw test10 
5f3e				 
5f3e 75 6d		        dw ssv5 
5f40 59 6d		        dw ssv4 
5f42 3d 6d		        dw ssv3 
5f44 07 6d		        dw ssv2 
5f46 8e 6d		        dw ssv1 
5f48 d6 6d		        dw ssv1cpm 
5f4a			;	dw keyup 
5f4a			;	dw keydown 
5f4a			;	dw keyleft 
5f4a			;	dw keyright 
5f4a			;	dw 	keyf1 
5f4a			;	dw keyf2 
5f4a			;	dw keyf3 
5f4a			;	dw keyf4 
5f4a			;	dw keyf5 
5f4a			;	dw keyf6 
5f4a			;	dw keyf7 
5f4a			;	dw keyf8 
5f4a			;	dw keyf9 
5f4a			;	dw keyf10 
5f4a			;	dw keyf11 
5f4a			;	dw keyf12 
5f4a			;	dw keytab 
5f4a			;	dw keycr 
5f4a			;	dw keyhome 
5f4a			;	dw keyend 
5f4a			;	dw keybs 
5f4a 00 00			db 0, 0	 
5f4c			 
5f4c			 
5f4c			; File Editor 
5f4c			 
5f4c			; ( id - ) use 'e' to edit the displayed line 
5f4c .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5f6d .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5fa2			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5fa2 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5fda			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5fda			 
5fda			; SPI Net support words 
5fda			 
5fda			; v0! = node to send to 
5fda			; ( str count - ) 
5fda .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
6033			 
6033			; spiputchr ( char node - ) 
6033 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
6069			 
6069			; spigetchr ( - n ) 
6069 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
6094			 
6094			; getnode ( - n ) 
6094 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
60c1			 
60c1			; ( str node - )  
60c1 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
6127			; store string ( str i - ) 
6127			 
6127			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
6127 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
617c			 
617c			; get string ( addr i -  )    TO FIX 
617c			 
617c .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
61d4			 
61d4			 
61d4			; NETCHAT (TODO) 
61d4			; Program to allow two nodes to chat with eachother 
61d4			; 
61d4			; v0 - target node 
61d4			;  
61d4			; accept input at 0,0 
61d4			; if input is string send spitype to target node 
61d4			; starting at row 2,0 , while spigetchr is not zero ->  
61d4			; 
61d4			; 
61d4			; TODO add paging of get request 
61d4			 
61d4			; ( node - ) 
61d4 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
61f3 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
624b .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
62c3			 
62c3			 
62c3			; Long read of currently open file 
62c3 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
630a			 
630a			; clear stack  
630a			 
630a .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
633e			 
633e			; type ( addr count - ) 
633e .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
6363			 
6363			; some direct memory words 
6363			; strncpy ( len t f -- t ) 
6363			 
6363 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
63c4			 
63c4 .. 00		start1:     	db ": bpon $00 bp ;",0 
63d4 .. 00		start2:     	db ": bpoff $01 bp ;",0 
63e5 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
6460 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
64c0			 
64c0			 
64c0			; a handy word to list items on the stack 
64c0			 
64c0 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
652a			 
652a			 
652a			; test stack  
652a			; rnd8 stest 
652a			 
652a .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
65a1			 
65a1			; random malloc and free cycles 
65a1			 
65a1 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6656			 
6656			; fixed malloc and free cycles 
6656			 
6656 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
66f9			 
66f9			; fixed double string push and drop cycle  
66f9			 
66f9 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
67ae			 
67ae			; consistent fixed string push and drop cycle  
67ae			 
67ae .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6852			 
6852 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6908			 
6908			;test1:		db ": aa 1 2 3 ;", 0 
6908			;test2:     	db "111 aa 888 999",0 
6908			;test3:     	db ": bb 77 ;",0 
6908			;test4:     	db "$02 $01 do i . loop bb",0 
6908			 
6908 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6940 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6978 .. 00		test7:     	db ": box hline vline ;",0 
698c .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
69b8 .. 00		test9:     	db ": sw $01 adsp world ;",0 
69ce .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
69f3 .. 00		test11:     	db "hello create .",0 
6a02 .. 00		test12:     	db "hello2 create .",0 
6a12			 
6a12			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6a12			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6a12			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6a12			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6a12			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6a12			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6a12			 
6a12			;iftest1:     	db "$0001 IF cls .",0 
6a12			;iftest2:     	db "$0000 IF cls .",0 
6a12			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6a12			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6a12			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6a12			 
6a12			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6a12			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6a12			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6a12			 
6a12			 
6a12 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
6a36 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6a66 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
6a8b .. 00		sound4: db ": cha $00 ; ",0 
6a98 .. 00		sound5: db ": chb $20 ; ",0 
6aa5 .. 00		sound6: db ": chc $40 ; ",0 
6ab2 .. 00		sound7: db ": chd $60 ; ",0 
6abf .. 00		sound8: db ": cnote $80 + + note ; ", 0 
6ad7 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6aee			 
6aee			 
6aee			 
6aee			 
6aee			; a small guess the number game 
6aee			 
6aee .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6aff .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6b61			 
6b61 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6b96 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6bcc .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6bfd .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6c11 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6c26 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6c5a .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6c9e			 
6c9e			; Using 'ga' save a high score across multiple runs using external storage 
6c9e			 
6c9e .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6d07			 
6d07			 
6d07			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6d07			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6d07			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6d07			 
6d07			; simple screen saver to test code memory reuse to destruction 
6d07			 
6d07 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6d3d .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6d59 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6d75 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6d8e .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6dd6 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6e2d			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6e2d			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6e2d			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6e2d			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6e2d			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6e2d			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6e2d			 
6e2d			 
6e2d			 
6e2d			; minesweeper/battleship finding game 
6e2d			; draws a game board of random ship/mine positions 
6e2d			; user enters coords to see if it hits on 
6e2d			; game ends when all are hit 
6e2d			; when hit or miss says how many may be in the area 
6e2d			 
6e2d			; setup the game board and then hide it 
6e2d .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6e9b .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6ee5			; prompt for where to target 
6ee5 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6f7b .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6fa0			; TODO see if the entered coords hits or misses pushes char hit of miss 
6fa0 .. 00		game2mbht:      db ": mbckht nop ;",0 
6faf .. 00		game2mbms:      db ": mbcms nop ;",0 
6fbd			; TODO how many might be near by 
6fbd .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
703a			 
703a			; Game 3 
703a			 
703a			; Vert scroller ski game - avoid the trees! 
703a			 
703a			; v0 score (ie turns) 
703a			; v1 player pos 
703a			; v2 left wall 
703a			; v3 right wall 
703a			 
703a			; Draw side walls randomly 
703a			 
703a .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
7068			 
7068			; Draw player 
7068 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
7086			 
7086			; TODO Get Key 
7086			 
7086			; TODO Move left right 
7086			 
7086			; scroll and move walls a bit 
7086			 
7086 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
70b7			 
70b7			; main game loop 
70b7			 
70b7 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
70e3 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
7122			 
7122			; key board defs 
7122			 
7122 .. 00		keyup:       db ": keyup $05 ;",0 
7130 .. 00		keydown:       db ": keydown $0a ;",0 
7140 .. 00		keyleft:       db ": keyleft $0b ;",0 
7150 .. 00		keyright:       db ": keyright $0c ;",0 
7161 .. 00		keyf1:       db ": keyf1 $10 ;",0 
716f .. 00		keyf2:       db ": keyf2 $11 ;",0 
717d .. 00		keyf3:       db ": keyf3 $12 ;",0 
718b .. 00		keyf4:       db ": keyf4 $13 ;",0 
7199 .. 00		keyf5:       db ": keyf5 $14 ;",0 
71a7 .. 00		keyf6:       db ": keyf6 $15 ;",0 
71b5 .. 00		keyf7:       db ": keyf7 $16 ;",0 
71c3 .. 00		keyf8:       db ": keyf8 $17 ;",0 
71d1 .. 00		keyf9:       db ": keyf9 $18 ;",0 
71df .. 00		keyf10:       db ": keyf10 $19 ;",0 
71ee .. 00		keyf11:       db ": keyf11 $1a ;",0 
71fd .. 00		keyf12:       db ": keyf12 $1b ;",0 
720c			 
720c .. 00		keytab:       db ": keytab $09 ;",0 
721b .. 00		keycr:       db ": keycr $0d ;",0 
7229 .. 00		keyhome:       db ": keyhome $0e ;",0 
7239 .. 00		keyend:       db ": keyend $0f ;",0 
7248 .. 00		keybs:       db ": keybs $08 ;",0 
7256			 
7256			   
7256			 
7256			 
7256			 
7256			; eof 
# End of file forth_autostart.asm
7256			 
7256			 
7256			 
7256			; stack over and underflow checks 
7256			 
7256			; init the words to detect the under/overflow 
7256			 
7256			chk_stk_init: 
7256				; a vague random number to check so we dont get any "lucky" hits 
7256 3e 2d			ld a, 45 
7258 6f				ld l, a 
7259 00				nop 
725a 3e 17			ld a, 23 
725c 67				ld h, a 
725d			 
725d 22 a6 f1			ld (chk_word), hl     ; the word we need to check against 
7260			 
7260			;	ld (chk_stund), hl	; stack points.... 
7260 22 fd fe			ld (chk_stovr), hl 
7263 22 e9 f9			ld (chk_ret_und), hl 
7266 22 a7 f9			ld (chk_ret_ovr), hl 
7269 22 25 f9			ld (chk_loop_ovr), hl 
726c 22 23 f7			ld (chk_data_ovr), hl 
726f c9				ret 
7270				 
7270			check_stacks: 
7270				; check all stack words 
7270			 
7270 e5				push hl 
7271 d5				push de 
7272			 
7272			;	ld de,(chk_word) 
7272			;	ld hl, (chk_stund)	; stack points.... 
7272			;	if DEBUG_STK_FAULT 
7272			;		DMARK "FAa" 
7272			;		CALLMONITOR 
7272			;	endif 
7272			;	call cmp16 
7272			;	jp z, .chk_faulta 
7272			; 
7272			;	ld de, sfaultsu 
7272			;	jp .chk_fault 
7272			 
7272 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
7275 ed 5b a6 f1		ld de,(chk_word) 
7279				if DEBUG_STK_FAULT 
7279					DMARK "FAb" 
7279					CALLMONITOR 
7279				endif 
7279 cd ee 0f			call cmp16 
727c 28 06			jr z, .chk_fault1 
727e 11 1f 73			ld de, sfaultso 
7281 c3 d3 72			jp .chk_fault 
7284			.chk_fault1:  
7284 2a e9 f9			ld hl, (chk_ret_und) 
7287 ed 5b a6 f1		ld de,(chk_word) 
728b				if DEBUG_STK_FAULT 
728b					DMARK "FAU" 
728b					CALLMONITOR 
728b				endif 
728b cd ee 0f			call cmp16 
728e ca 97 72			jp z, .chk_fault2 
7291 11 2f 73			ld de, sfaultru 
7294 c3 d3 72			jp .chk_fault 
7297			.chk_fault2:  
7297 2a a7 f9			ld hl, (chk_ret_ovr) 
729a ed 5b a6 f1		ld de,(chk_word) 
729e				if DEBUG_STK_FAULT 
729e					DMARK "FA1" 
729e					CALLMONITOR 
729e				endif 
729e cd ee 0f			call cmp16 
72a1 ca aa 72			jp z, .chk_fault3 
72a4 11 3d 73			ld de, sfaultro 
72a7 c3 d3 72			jp .chk_fault 
72aa			.chk_fault3:  
72aa 2a 25 f9			ld hl, (chk_loop_ovr) 
72ad ed 5b a6 f1		ld de,(chk_word) 
72b1				if DEBUG_STK_FAULT 
72b1					DMARK "FA2" 
72b1					CALLMONITOR 
72b1				endif 
72b1 cd ee 0f			call cmp16 
72b4 ca bd 72			jp z, .chk_fault4 
72b7 11 57 73			ld de, sfaultlo 
72ba c3 d3 72			jp .chk_fault 
72bd			.chk_fault4:  
72bd 2a 23 f7			ld hl, (chk_data_ovr) 
72c0 ed 5b a6 f1		ld de,(chk_word) 
72c4				if DEBUG_STK_FAULT 
72c4					DMARK "FA3" 
72c4					CALLMONITOR 
72c4				endif 
72c4 cd ee 0f			call cmp16 
72c7 ca d0 72			jp z, .chk_fault5 
72ca 11 71 73			ld de, sfaultdo 
72cd c3 d3 72			jp .chk_fault 
72d0			 
72d0			 
72d0			.chk_fault5:  
72d0 d1				pop de 
72d1 e1				pop hl 
72d2			 
72d2 c9				ret 
72d3			 
72d3 cd 9c 0d		.chk_fault: 	call clear_display 
72d6 3e 28				ld a, display_row_2 
72d8 cd af 0d				call str_at_display 
72db 11 01 73				   ld de, .stackfault 
72de 3e 00				ld a, display_row_1 
72e0 cd af 0d				call str_at_display 
72e3 11 68 fe				    ld de, debug_mark 
72e6 3e 11				ld a, display_row_1+17 
72e8 cd af 0d				call str_at_display 
72eb cd bf 0d				call update_display 
72ee			 
72ee				; prompt before entering montior for investigating issue 
72ee			 
72ee 3e 78			ld a, display_row_4 
72f0 11 f7 1d			ld de, endprog 
72f3			 
72f3 cd bf 0d			call update_display		 
72f6			 
72f6 cd 7d 20			call next_page_prompt 
72f9			 
72f9 d1				pop de 
72fa e1				pop hl 
72fb cd 4b 1e				call monitor 
72fe c3 55 1d				jp warmstart 
7301					;jp 0 
7301					;halt 
7301			 
7301			 
7301			 
7301 .. 00		.stackfault: 	db "Stack fault:",0 
730e			 
730e .. 00		sfaultsu: 	db	"Stack under flow",0 
731f .. 00		sfaultso: 	db	"Stack over flow",0 
732f .. 00		sfaultru:	db "RTS underflow",0 
733d .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
7357 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
7371 .. 00		sfaultdo:	db "DTS overflow", 0 
737e			 
737e			 
737e			fault_dsp_under: 
737e 11 90 73			ld de, .dsp_under 
7381 c3 40 74			jp .show_fault 
7384			 
7384			fault_rsp_under: 
7384 11 9e 73			ld de, .rsp_under 
7387 c3 40 74			jp .show_fault 
738a			fault_loop_under: 
738a 11 ac 73			ld de, .loop_under 
738d c3 40 74			jp .show_fault 
7390			 
7390 .. 00		.dsp_under: db "DSP Underflow",0 
739e .. 00		.rsp_under: db "RSP Underflow",0 
73ac .. 00		.loop_under: db "LOOP Underflow",0 
73bb			 
73bb			 
73bb d5			type_faultn: 	push de 
73bc e5					push hl 
73bd cd 9c 0d				call clear_display 
73c0 11 e7 73				   ld de, .typefaultn 
73c3 3e 00				ld a, display_row_1 
73c5 cd af 0d				call str_at_display 
73c8 11 68 fe				    ld de, debug_mark 
73cb 3e 11				ld a, display_row_1+17 
73cd cd af 0d				call str_at_display 
73d0 cd bf 0d				call update_display 
73d3			 
73d3				; prompt before entering montior for investigating issue 
73d3			 
73d3 3e 78			ld a, display_row_4 
73d5 11 f7 1d			ld de, endprog 
73d8			 
73d8 cd bf 0d			call update_display		 
73db			 
73db cd 7d 20			call next_page_prompt 
73de			 
73de e5					push hl 
73df d5					push de 
73e0 cd 4b 1e				call monitor 
73e3 c3 55 1d				jp warmstart 
73e6 76					halt 
73e7			 
73e7			 
73e7 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
73fe			 
73fe d5			type_faults: 	push de 
73ff e5					push hl 
7400 cd 9c 0d				call clear_display 
7403 11 29 74				   ld de, .typefaults 
7406 3e 00				ld a, display_row_1 
7408 cd af 0d				call str_at_display 
740b 11 68 fe				    ld de, debug_mark 
740e 3e 11				ld a, display_row_1+17 
7410 cd af 0d				call str_at_display 
7413 cd bf 0d				call update_display 
7416			 
7416				; prompt before entering montior for investigating issue 
7416			 
7416 3e 78			ld a, display_row_4 
7418 11 f7 1d			ld de, endprog 
741b			 
741b cd bf 0d			call update_display		 
741e			 
741e cd 7d 20			call next_page_prompt 
7421			 
7421 e1					pop hl 
7422 d1					pop de 
7423 cd 4b 1e				call monitor 
7426 c3 55 1d				jp warmstart 
7429			 
7429			 
7429 .. 00		.typefaults: db "STR Type Expected TOS!",0 
7440			 
7440			.show_fault: 	 
7440 d5					push de 
7441 cd 9c 0d				call clear_display 
7444 d1					pop de 
7445 3e 00				ld a, display_row_1 
7447 cd af 0d				call str_at_display 
744a 11 68 fe				    ld de, debug_mark 
744d 3e 11				ld a, display_row_1+17 
744f cd af 0d				call str_at_display 
7452 cd bf 0d				call update_display 
7455			 
7455				; prompt before entering montior for investigating issue 
7455			 
7455 3e 78			ld a, display_row_4 
7457 11 f7 1d			ld de, endprog 
745a			 
745a cd bf 0d			call update_display		 
745d			 
745d cd 7d 20			call next_page_prompt 
7460			 
7460 e1					pop hl 
7461 d1					pop de 
7462 cd 4b 1e				call monitor 
7465			; do a dump to cli and not warmstart so we preserve all of the uwords.  
7465			; TODO Make optional fault restart to cli or warm boot? 
7465					;jp warmstart 
7465 c3 9e 1d				jp cli 
7468 76					halt 
7469			 
7469			; handle the auto run of code from files in storage 
7469			 
7469			 
7469			include "forth_startup.asm" 
7469			; Which startup method to use? 
7469			; 
7469			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
7469			; followed by loading of a list of scripts in eeprom 
7469			 
7469			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
7469			; from eeprom 
7469			 
7469			; Select with define in main stubs 
7469			 
7469			if STARTUP_V1 
7469				include "forth_startupv1.asm" 
7469			endif 
7469			if STARTUP_V2 
7469				include "forth_startupv2.asm" 
7469			; Version 2 of the startup  
7469			;  
7469			; Auto load any files in bank 1 that start with a '*' 
7469			; If no se storage then revert to using eprom 
7469			 
7469			 
7469			if STORAGE_SE = 0 
7469			 
7469			sprompt1: db "Startup load...",0 
7469			sprompt2: db "Run? 1=No *=End #=All",0 
7469			 
7469			 
7469			 
7469			 
7469			forth_startup: 
7469				ld hl, startcmds 
7469				ld a, 0 
7469				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
7469			 
7469			.start1:	push hl 
7469				call clear_display 
7469				ld de, sprompt1 
7469			        ld a, display_row_1 
7469				call str_at_display 
7469				ld de, sprompt2 
7469			        ld a, display_row_2 
7469				call str_at_display 
7469				pop hl 
7469				push hl 
7469				ld e,(hl) 
7469				inc hl 
7469				ld d,(hl) 
7469			        ld a, display_row_3 
7469				call str_at_display 
7469				call update_display 
7469			 
7469			 
7469				ld a, (os_last_cmd) 
7469				cp 0 
7469				jr z, .startprompt 
7469				call delay250ms 
7469				jr .startdo 
7469				 
7469				 
7469			 
7469			.startprompt: 
7469			 
7469				ld a,display_row_4 + display_cols - 1 
7469			        ld de, endprg 
7469				call str_at_display 
7469				call update_display 
7469				call delay1s 
7469				call cin_wait 
7469						 
7469				cp '*' 
7469				jr z, .startupend1 
7469				cp '#' 
7469				jr nz, .startno 
7469				ld a, 1 
7469				ld (os_last_cmd),a 
7469				jr .startdo 
7469			.startno:	cp '1' 
7469				jr z,.startnxt  
7469			 
7469				; exec startup line 
7469			.startdo:	 
7469				pop hl 
7469				push hl 
7469				 
7469				ld e,(hl) 
7469				inc hl 
7469				ld d,(hl) 
7469				ex de,hl 
7469			 
7469				push hl 
7469			 
7469				ld a, 0 
7469				;ld a, FORTH_END_BUFFER 
7469				call strlent 
7469				inc hl   ; include zero term to copy 
7469				ld b,0 
7469				ld c,l 
7469				pop hl 
7469				ld de, scratch 
7469				ldir 
7469			 
7469			 
7469				ld hl, scratch 
7469				call forthparse 
7469				call forthexec 
7469				call forthexec_cleanup 
7469			 
7469				ld a, display_row_4 
7469				ld de, endprog 
7469			 
7469				call update_display		 
7469			 
7469				ld a, (os_last_cmd) 
7469				cp 0 
7469				jr nz, .startnxt 
7469				call next_page_prompt 
7469			        call clear_display 
7469				call update_display		 
7469			 
7469				; move onto next startup line? 
7469			.startnxt: 
7469			 
7469				call delay250ms 
7469				pop hl 
7469			 
7469				inc hl 
7469				inc hl 
7469			 
7469				push hl 
7469				ld e, (hl) 
7469				inc hl 
7469				ld d, (hl) 
7469				pop hl 
7469				; TODO replace 0 test 
7469			 
7469				ex de, hl 
7469				call ishlzero 
7469			;	ld a,e 
7469			;	add d 
7469			;	cp 0    ; any left to do? 
7469				ex de, hl 
7469				jp nz, .start1 
7469				jr .startupend 
7469			 
7469			.startupend1: pop hl 
7469			.startupend: 
7469			 
7469				call clear_display 
7469				call update_display 
7469				ret 
7469			endif 
7469			 
7469			 
7469			if STORAGE_SE 
7469			 
7469			;sprompt3: db "Loading from start-up file:",0 
7469 .. 00		sprompt3: db "  Searching...",0 
7478			;sprompt4: db "(Any key to stop)",0 
7478			 
7478			 
7478			forth_autoload: 
7478			 
7478				; load block 0 of store 1 
7478				 
7478 3e fe			ld a, $fe      ; bit 0 clear 
747a 32 5d fa			ld (spi_device), a 
747d			 
747d cd 17 05			call storage_get_block_0 
7480			 
7480 3a 98 fa			ld a, (store_page+STORE_0_AUTOFILE) 
7483			 
7483 fe 00			cp 0 
7485 c8				ret z     ; auto start not enabled 
7486			 
7486 cd 9c 0d			call clear_display 
7489			 
7489				; set bank 
7489			 
7489 3a 9a fa				ld a, (store_page+STORE_0_BANKRUN) 
748c 32 5d fa				ld (spi_device), a 
748f			 
748f			 
748f				; generate a directory of bank 1 and search for flagged files 
748f			 
748f					if DEBUG_FORTH_WORDS_KEY 
748f						DMARK "DIR" 
748f f5				push af  
7490 3a a4 74			ld a, (.dmark)  
7493 32 68 fe			ld (debug_mark),a  
7496 3a a5 74			ld a, (.dmark+1)  
7499 32 69 fe			ld (debug_mark+1),a  
749c 3a a6 74			ld a, (.dmark+2)  
749f 32 6a fe			ld (debug_mark+2),a  
74a2 18 03			jr .pastdmark  
74a4 ..			.dmark: db "DIR"  
74a7 f1			.pastdmark: pop af  
74a8			endm  
# End of macro DMARK
74a8						CALLMONITOR 
74a8 cd 6c fe			call debug_vector  
74ab				endm  
# End of macro CALLMONITOR
74ab					endif 
74ab			 
74ab cd 17 05			call storage_get_block_0 
74ae			 
74ae 21 77 fa			ld hl, store_page     ; get current id count 
74b1 46				ld b, (hl) 
74b2 0e 00			ld c, 0    ; count of files   
74b4					if DEBUG_FORTH_WORDS 
74b4						DMARK "DI1" 
74b4 f5				push af  
74b5 3a c9 74			ld a, (.dmark)  
74b8 32 68 fe			ld (debug_mark),a  
74bb 3a ca 74			ld a, (.dmark+1)  
74be 32 69 fe			ld (debug_mark+1),a  
74c1 3a cb 74			ld a, (.dmark+2)  
74c4 32 6a fe			ld (debug_mark+2),a  
74c7 18 03			jr .pastdmark  
74c9 ..			.dmark: db "DI1"  
74cc f1			.pastdmark: pop af  
74cd			endm  
# End of macro DMARK
74cd						CALLMONITOR 
74cd cd 6c fe			call debug_vector  
74d0				endm  
# End of macro CALLMONITOR
74d0					endif 
74d0			 
74d0				; check for empty drive 
74d0			 
74d0 3e 00			ld a, 0 
74d2 b8				cp b 
74d3 ca 20 75			jp z, .dirdone 
74d6			 
74d6				; for each of the current ids do a search for them and if found push to stack 
74d6			 
74d6 c5			.diritem:	push bc 
74d7 21 40 00				ld hl, STORE_BLOCK_PHY 
74da 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
74dc 58					ld e,b 
74dd			 
74dd d5					push de 
74de e5					push hl 
74df cd 9c 0d			call clear_display 
74e2 3e 32			ld a, display_row_2 + 10 
74e4 11 69 74			ld de, sprompt3 
74e7 cd af 0d			call str_at_display 
74ea cd f3 0c			call active 
74ed eb				ex de, hl 
74ee 3e 2f			ld a, display_row_2 + 7 
74f0 cd af 0d			call str_at_display 
74f3 cd bf 0d			call update_display 
74f6 e1				pop hl 
74f7 d1				pop de 
74f8			 
74f8			;		if DEBUG_FORTH_WORDS 
74f8			;			DMARK "DI2" 
74f8			;			CALLMONITOR 
74f8			;		endif 
74f8			 
74f8 cd 99 07				call storage_findnextid 
74fb			 
74fb			;		if DEBUG_FORTH_WORDS 
74fb			;			DMARK "DI3" 
74fb			;			CALLMONITOR 
74fb			;		endif 
74fb			 
74fb					; if found hl will be non zero 
74fb			 
74fb cd f9 0f				call ishlzero 
74fe			;		ld a, l 
74fe			;		add h 
74fe			; 
74fe			;		cp 0 
74fe 28 1d				jr z, .dirnotfound 
7500			 
7500					; increase count 
7500			 
7500 c1					pop bc	 
7501 0c					inc c 
7502 c5					push bc 
7503					 
7503			 
7503					; get file header and push the file name 
7503			 
7503 11 77 fa				ld de, store_page 
7506 cd 66 04				call storage_read_block 
7509			 
7509					; push file id to stack 
7509				 
7509			 
7509					; is this a file we want to run? 
7509			 
7509 21 7a fa				ld hl, store_page+3 
750c 7e					ld a,(hl) 
750d fe 2a				cp '*' 
750f 20 0c				jr nz,  .dirnotfound 
7511					 
7511			 
7511			 
7511 3a 77 fa				ld a, (store_page) 
7514 d5					push de 
7515 e5					push hl 
7516 c5					push bc 
7517 cd 43 75				call .autorunf 
751a c1					pop bc 
751b e1					pop hl 
751c d1					pop de 
751d			 
751d			 
751d			 
751d				; save this extent 
751d			 
751d					; push file name 
751d			;display file name to run 
751d			 
751d			;		ld hl, store_page+3 
751d			;		if DEBUG_FORTH_WORDS 
751d			;			DMARK "DI5" 
751d			;			CALLMONITOR 
751d			;		endif 
751d			; 
751d			;		 
751d			; 
751d			;		call forth_push_str 
751d			;		if DEBUG_FORTH_WORDS 
751d			;			DMARK "DI6" 
751d			;			CALLMONITOR 
751d			;		endif 
751d			.dirnotfound: 
751d c1					pop bc     
751e 10 b6				djnz .diritem 
7520				 
7520			.dirdone:	 
7520					if DEBUG_FORTH_WORDS 
7520						DMARK "DI7" 
7520 f5				push af  
7521 3a 35 75			ld a, (.dmark)  
7524 32 68 fe			ld (debug_mark),a  
7527 3a 36 75			ld a, (.dmark+1)  
752a 32 69 fe			ld (debug_mark+1),a  
752d 3a 37 75			ld a, (.dmark+2)  
7530 32 6a fe			ld (debug_mark+2),a  
7533 18 03			jr .pastdmark  
7535 ..			.dmark: db "DI7"  
7538 f1			.pastdmark: pop af  
7539			endm  
# End of macro DMARK
7539						CALLMONITOR 
7539 cd 6c fe			call debug_vector  
753c				endm  
# End of macro CALLMONITOR
753c					endif 
753c			 
753c cd 9c 0d				call clear_display 
753f cd bf 0d				call update_display 
7542			 
7542 c9					ret 
7543			 
7543			 
7543			 
7543			 
7543			 
7543			.autorunf: 
7543			 
7543			 
7543				; get file id to load from and get the file name to display 
7543			 
7543			;		ld a, (store_page+STORE_0_FILERUN) 
7543			 
7543 2e 00				ld l, 0 
7545 67					ld h, a 
7546 11 77 fa				ld de, store_page 
7549			 
7549					if DEBUG_FORTH_WORDS 
7549						DMARK "ASp" 
7549 f5				push af  
754a 3a 5e 75			ld a, (.dmark)  
754d 32 68 fe			ld (debug_mark),a  
7550 3a 5f 75			ld a, (.dmark+1)  
7553 32 69 fe			ld (debug_mark+1),a  
7556 3a 60 75			ld a, (.dmark+2)  
7559 32 6a fe			ld (debug_mark+2),a  
755c 18 03			jr .pastdmark  
755e ..			.dmark: db "ASp"  
7561 f1			.pastdmark: pop af  
7562			endm  
# End of macro DMARK
7562						CALLMONITOR 
7562 cd 6c fe			call debug_vector  
7565				endm  
# End of macro CALLMONITOR
7565					endif 
7565 cd bf 09				call storage_read 
7568			 
7568					if DEBUG_FORTH_WORDS 
7568						DMARK "ASr" 
7568 f5				push af  
7569 3a 7d 75			ld a, (.dmark)  
756c 32 68 fe			ld (debug_mark),a  
756f 3a 7e 75			ld a, (.dmark+1)  
7572 32 69 fe			ld (debug_mark+1),a  
7575 3a 7f 75			ld a, (.dmark+2)  
7578 32 6a fe			ld (debug_mark+2),a  
757b 18 03			jr .pastdmark  
757d ..			.dmark: db "ASr"  
7580 f1			.pastdmark: pop af  
7581			endm  
# End of macro DMARK
7581						CALLMONITOR 
7581 cd 6c fe			call debug_vector  
7584				endm  
# End of macro CALLMONITOR
7584					endif 
7584			 
7584 cd f9 0f				call ishlzero 
7587 c8					ret z             ; file not found 
7588			 
7588					; display file name we are loading 
7588			 
7588 cd 9c 0d				call clear_display 
758b			 
758b 3e 32				ld a, display_row_2 + 10 
758d 11 7a fa				ld de, store_page+3 
7590 cd af 0d				call str_at_display 
7593				 
7593			; 
7593			 
7593			;	ld a, display_row_1+5 
7593			;	ld de, sprompt3 
7593			;	call str_at_display 
7593			;	ld a, display_row_2+7 
7593			;	call active 
7593			;	ex de, hl 
7593			;;	ld de, sprompt4 
7593			;	call str_at_display 
7593			; 
7593 cd bf 0d			call update_display 
7596			 
7596			;	call cin_wait 
7596			;	cp 'n' 
7596			;	ret z 
7596			;	cp 'N' 
7596			;	ret z 
7596			 
7596			;	call delay1s 
7596			 
7596 3a 79 fa			ld a, (store_page+2) 
7599 32 66 fa			ld (store_openmaxext), a    ; save count of ext 
759c 3e 01			ld a, 1  
759e 32 67 fa			ld (store_openext), a    ; save count of ext 
75a1			 
75a1			.autof: 
75a1				; begin to read a line from file 
75a1			 
75a1 21 e5 f4			ld hl, os_cli_cmd 
75a4 22 e3 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
75a7			  
75a7			.readext: 
75a7 3a 67 fa			ld a, (store_openext) 
75aa 6f				ld l , a 
75ab				 
75ab 3a 77 fa			ld a, (store_page) 
75ae 67				ld h, a	 
75af 11 77 fa			ld de, store_page 
75b2					if DEBUG_FORTH_WORDS 
75b2						DMARK "ASl" 
75b2 f5				push af  
75b3 3a c7 75			ld a, (.dmark)  
75b6 32 68 fe			ld (debug_mark),a  
75b9 3a c8 75			ld a, (.dmark+1)  
75bc 32 69 fe			ld (debug_mark+1),a  
75bf 3a c9 75			ld a, (.dmark+2)  
75c2 32 6a fe			ld (debug_mark+2),a  
75c5 18 03			jr .pastdmark  
75c7 ..			.dmark: db "ASl"  
75ca f1			.pastdmark: pop af  
75cb			endm  
# End of macro DMARK
75cb						CALLMONITOR 
75cb cd 6c fe			call debug_vector  
75ce				endm  
# End of macro CALLMONITOR
75ce					endif 
75ce cd bf 09				call storage_read 
75d1 cd f9 0f			call ishlzero 
75d4 c8				ret z 
75d5			 
75d5			; TODO copy to exec buffer 
75d5			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
75d5			 
75d5				; copy the record buffer to the cli buffer 
75d5			 
75d5 ed 5b e3 f6		ld de, (os_var_array) 
75d9 21 79 fa			ld hl, store_page+2 
75dc			;	ex de, hl 
75dc 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
75df ed b0			ldir 
75e1 ed 53 e3 f6		ld (os_var_array), de 
75e5				 
75e5 3a 67 fa			ld a, (store_openext) 
75e8 3c				inc a 
75e9 32 67 fa			ld (store_openext), a    ; save count of ext 
75ec			 
75ec			 
75ec			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
75ec				 
75ec 3a 6a fa			ld a, (store_readcont) 
75ef fe 00			cp 0 
75f1 20 b4			jr nz, .readext 
75f3			 
75f3			;	jr z, .autoend 
75f3			 
75f3					if DEBUG_FORTH_WORDS 
75f3						DMARK "ASc" 
75f3 f5				push af  
75f4 3a 08 76			ld a, (.dmark)  
75f7 32 68 fe			ld (debug_mark),a  
75fa 3a 09 76			ld a, (.dmark+1)  
75fd 32 69 fe			ld (debug_mark+1),a  
7600 3a 0a 76			ld a, (.dmark+2)  
7603 32 6a fe			ld (debug_mark+2),a  
7606 18 03			jr .pastdmark  
7608 ..			.dmark: db "ASc"  
760b f1			.pastdmark: pop af  
760c			endm  
# End of macro DMARK
760c						CALLMONITOR 
760c cd 6c fe			call debug_vector  
760f				endm  
# End of macro CALLMONITOR
760f					endif 
760f e5				push hl	 
7610 d5				push de 
7611 cd f3 0c			call active 
7614 eb				ex de, hl 
7615 3e 2f			ld a, display_row_2 + 7 
7617 cd af 0d			call str_at_display 
761a			 
761a cd bf 0d			call update_display 
761d d1				pop de  
761e e1				pop hl 
761f			;	call delay250ms 
761f			 
761f			 
761f			 
761f			 
761f			.autoexec: 
761f			 
761f			 
761f 21 e5 f4			ld hl, os_cli_cmd 
7622					if DEBUG_FORTH_WORDS 
7622						DMARK "ASx" 
7622 f5				push af  
7623 3a 37 76			ld a, (.dmark)  
7626 32 68 fe			ld (debug_mark),a  
7629 3a 38 76			ld a, (.dmark+1)  
762c 32 69 fe			ld (debug_mark+1),a  
762f 3a 39 76			ld a, (.dmark+2)  
7632 32 6a fe			ld (debug_mark+2),a  
7635 18 03			jr .pastdmark  
7637 ..			.dmark: db "ASx"  
763a f1			.pastdmark: pop af  
763b			endm  
# End of macro DMARK
763b						CALLMONITOR 
763b cd 6c fe			call debug_vector  
763e				endm  
# End of macro CALLMONITOR
763e					endif 
763e cd 00 25			call forthparse 
7641 cd 40 25			call forthexec 
7644 cd 52 24			call forthexec_cleanup 
7647			 
7647			 
7647			 
7647 c3 a1 75			jp .autof 
764a			;.autofdone: 
764a			; 
764a			;		if DEBUG_FORTH_WORDS 
764a			;			DMARK "ASx" 
764a			;			CALLMONITOR 
764a			;		endif 
764a			;;	call clear_display 
764a			;	ret 
764a			 
764a			 
764a			 
764a			endif 
# End of file forth_startupv2.asm
764a			endif 
764a			 
# End of file forth_startup.asm
764a			 
764a			; eof 
# End of file forth_kernel.asm
764a			;include "nascombasic.asm" 
764a			 
764a			 
764a			; find out where the code ends if loaded into RAM (for SC114) 
764a			;endofcode:  
764a			;	nop 
764a			 
764a			 
764a			; jump to nmi vector 
764a			 
764a			init_nmi: 
764a 3e c9			ld a, $c9   ; RET 
764c 32 6f fe			ld (nmi_vector), a 
764f c9				ret 
7650			nmi: 
7650 e5				push hl 
7651 d5				push de 
7652 c5				push bc 
7653 f5				push af 
7654 cd 6f fe			call nmi_vector 
7657 f5				push af 
7658 c5				push bc 
7659 d5				push de 
765a e5				push hl 
765b ed 4d			reti 
765d			 
765d			 
765d			; eof 
765d			 
# End of file main.asm
765d			include "firmware_lcd_4x40.asm" 
765d			; **********************************************************************  
765d			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
765d			; **********************************************************************  
765d			;  
765d			; **  Written as a Small Computer Monitor App  
765d			; **  www.scc.me.uk  
765d			;  
765d			; History  
765d			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
765d			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
765d			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
765d			;  
765d			; **********************************************************************  
765d			;  
765d			; This program is an example of one of the methods of interfacing an   
765d			; alphanumeric LCD module.   
765d			;  
765d			; In this example the display is connected to either a Z80 PIO or a   
765d			; simple 8-bit output port.   
765d			;  
765d			; This interfacing method uses 4-bit data mode and uses time delays  
765d			; rather than polling the display's ready status. As a result the   
765d			; interface only requires 6 simple output lines:  
765d			;   Output bit 0 = not used  
765d			;   Output bit 1 = not used  
765d			;   Output bit 2 = RS         High = data, Low = instruction  
765d			;   Output bit 3 = E          Active high  
765d			;   Output bit 4 = DB4  
765d			;   Output bit 5 = DB5  
765d			;   Output bit 6 = DB6  
765d			;   Output bit 7 = DB7  
765d			; Display's R/W is connected to 0v so it is always in write mode  
765d			;  
765d			; This set up should work with any system supporting the RC2014 bus  
765d			  
765d			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
765d			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
765d			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
765d			;  
765d			; **********************************************************************  
765d			  
765d			; Additonal for 4x40. E1 and E2 instead of just E   
765d			; TODO swipe vidout signal on port a to activate E2  
765d			  
765d			; **********************************************************************  
765d			; **  Constants  
765d			; **********************************************************************  
765d			; LCD constants required by LCD support module  
765d			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
765d			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
765d			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
765d			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
765d			; TODO Decide which E is being set  
765d			kLCDWidth:  EQU display_cols             ;Width in characters  
765d			  
765d			; **********************************************************************  
765d			; **  Code library usage  
765d			; **********************************************************************  
765d			  
765d			; send character to current cursor position  
765d			; wraps and/or scrolls screen automatically  
765d			  
765d			  
765d			  
765d			lcd_init:  
765d			  
765d			; SCMonAPI functions used  
765d			  
765d			; Alphanumeric LCD functions used  
765d			; no need to specify specific functions for this module  
765d			  
765d 3e cf		            LD   A, 11001111b  
765f d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
7661 3e 00		            LD   A, 00000000b  
7663 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
7665			  
7665			; Initialise alphanumeric LCD module  
7665 3e 00				ld a, 0  
7667 32 c8 fb				ld (display_lcde1e2), a  
766a cd eb 76		            CALL fLCD_Init      ;Initialise LCD module  
766d 3e 01				ld a, 1  
766f 32 c8 fb				ld (display_lcde1e2), a  
7672 cd eb 76		            CALL fLCD_Init      ;Initialise LCD module  
7675			  
7675 c9				ret  
7676			  
7676			;  
7676			;;  
7676			; lcd functions  
7676			;  
7676			;  
7676			  
7676			; what is at cursor position   
7676			  
7676			;get_cursor:	ld de, (cursor_row)   ;  row + col  
7676			;		call curptr  
7676			;		ret  
7676			  
7676			  
7676			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
7676			  
7676			curptr:  
7676 c5				push bc  
7677 21 ae fd			ld hl, display_fb0  
767a			cpr:	  
767a				; loop for cursor whole row  
767a 0e 28			ld c, display_cols  
767c 23			cpr1:	inc hl  
767d 0d				dec c  
767e 20 fc			jr nz, cpr1  
7680 05				dec b  
7681 20 f7			jr nz, cpr  
7683			  
7683				; add col	  
7683			  
7683 23			cpr2:	inc hl  
7684 1d				dec e  
7685 20 fc			jr nz, cpr2  
7687			  
7687 c1				pop bc  
7688 c9				ret  
7689				  
7689			  
7689			  
7689			  
7689			  
7689			; write the frame buffer given in hl to hardware   
7689 22 c6 fb		write_display: ld (display_write_tmp), hl 	   
768c 3e 00			ld a, kLCD_Line1  
768e cd 98 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7691 06 28			ld b, display_cols  
7693 ed 5b c6 fb		ld de, (display_write_tmp)  
7697 cd e3 76			call write_len_string  
769a				  
769a				  
769a 2a c6 fb			ld hl, (display_write_tmp)  
769d 11 28 00			ld de, display_cols  
76a0 19				add hl,de  
76a1 22 c6 fb			ld (display_write_tmp),hl  
76a4			  
76a4				  
76a4 3e 28			ld a, kLCD_Line2  
76a6 cd 98 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76a9 06 28			ld b, display_cols  
76ab ed 5b c6 fb		ld de, (display_write_tmp)  
76af cd e3 76			call write_len_string  
76b2				  
76b2 2a c6 fb			ld hl, (display_write_tmp)  
76b5 11 28 00			ld de, display_cols  
76b8 19				add hl,de  
76b9 22 c6 fb			ld (display_write_tmp),hl  
76bc			  
76bc				  
76bc 3e 50			ld a, kLCD_Line3  
76be cd 98 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76c1 06 28			ld b, display_cols  
76c3 ed 5b c6 fb		ld de, (display_write_tmp)  
76c7 cd e3 76			call write_len_string  
76ca				  
76ca 2a c6 fb			ld hl, (display_write_tmp)  
76cd 11 28 00			ld de, display_cols  
76d0 19				add hl,de  
76d1 22 c6 fb			ld (display_write_tmp),hl  
76d4			  
76d4				  
76d4 3e 78			ld a, kLCD_Line4  
76d6 cd 98 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76d9 06 28			ld b, display_cols  
76db ed 5b c6 fb		ld de, (display_write_tmp)  
76df cd e3 76			call write_len_string  
76e2 c9					ret  
76e3				  
76e3				; write out a fixed length string given in b from de  
76e3			  
76e3 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
76e4 cd 50 77		            CALL fLCD_Data      ;Write character to display  
76e7 13				inc de  
76e8 10 f9			djnz write_len_string  
76ea c9				ret  
76eb			  
76eb			; Some other things to do  
76eb			;            LD   A, kLCD_Clear ;Display clear  
76eb			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
76eb			;            LD   A, kLCD_Under ;Display on with underscore cursor  
76eb			;            LD   A, kLCD_On     ;Display on with no cursor  
76eb			;            ;LD   A, kLCD_Off   ;Display off  
76eb			;            CALL fLCD_Inst      ;Send instruction to display  
76eb			;  
76eb			;  
76eb			;            halt  
76eb			;  
76eb			;  
76eb			;MsgHello:   DB  "Hello World!",0  
76eb			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
76eb			  
76eb			; Custom characters 5 pixels wide by 8 pixels high  
76eb			; Up to 8 custom characters can be defined  
76eb			;BitMaps:      
76eb			;; Character 0x00 = Battery icon  
76eb			;            DB  01110b  
76eb			;            DB  11011b  
76eb			;            DB  10001b  
76eb			;            DB  10001b  
76eb			;            DB  11111b  
76eb			;            DB  11111b  
76eb			;            DB  11111b  
76eb			;            DB  11111b  
76eb			;; Character 0x01 = Bluetooth icon  
76eb			;            DB  01100b  
76eb			;            DB  01010b  
76eb			;            DB  11100b  
76eb			;            DB  01000b  
76eb			;            DB  11100b  
76eb			;            DB  01010b  
76eb			;            DB  01100b  
76eb			;            DB  00000b  
76eb			;  
76eb			  
76eb			  
76eb			; **********************************************************************  
76eb			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
76eb			; **********************************************************************  
76eb			;  
76eb			; **  Written as a Small Computer Monitor App   
76eb			; **  Version 0.1 SCC 2018-05-16  
76eb			; **  www.scc.me.uk  
76eb			;  
76eb			; **********************************************************************  
76eb			;  
76eb			; This module provides support for alphanumeric LCD modules using with  
76eb			; *  HD44780 (or compatible) controller  
76eb			; *  5 x 7 pixel fonts  
76eb			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
76eb			; *  Interface via six digital outputs to the display (see below)  
76eb			;  
76eb			; LCD module pinout:  
76eb			;   1  Vss   0v supply  
76eb			;   2  Vdd   5v supply  
76eb			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
76eb			;   4  RS    High = data, Low = instruction  
76eb			;   5  R/W   High = Read, Low = Write  
76eb			;   6  E     Enable signal (active high)  
76eb			;   7  DB0   Data bit 0  
76eb			;   8  DB1   Data bit 1  
76eb			;   9  DB2   Data bit 2  
76eb			;  10  DB3   Data bit 3  
76eb			;  11  DB4   Data bit 4  
76eb			;  12  DB5   Data bit 5  
76eb			;  13  DB6   Data bit 6  
76eb			;  14  DB7   Data bit 7  
76eb			;  15  A     Backlight anode (+)  
76eb			;  16  K     Backlight cathode (-)  
76eb			;  
76eb			; This interfacing method uses 4-bit data mode and uses time delays  
76eb			; rather than polling the display's ready status. As a result the   
76eb			; interface only requires 6 simple output lines:  
76eb			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
76eb			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
76eb			;   LCD DB4 = Microcomputer output port bit 4  
76eb			;   LCD DB5 = Microcomputer output port bit 5  
76eb			;   LCD DB6 = Microcomputer output port bit 6  
76eb			;   LCD DB7 = Microcomputer output port bit 7  
76eb			; Display's R/W is connected to 0v so it is always in write mode  
76eb			; All 6 connections must be on the same port address <kLCDPrt>  
76eb			; This method also allows a decent length of cable from micro to LCD  
76eb			;  
76eb			; **********************************************************************  
76eb			;  
76eb			; To include the code for any given function provided by this module,   
76eb			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
76eb			; the parent source file.  
76eb			; For example:  #REQUIRES   uHexPrefix  
76eb			;  
76eb			; Also #INCLUDE this file at some point after the #REQUIRES statements  
76eb			; in the parent source file.  
76eb			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
76eb			;  
76eb			; These are the function names provided by this module:  
76eb			; fLCD_Init                     ;Initialise LCD  
76eb			; fLCD_Inst                     ;Send instruction to LCD  
76eb			; fLCD_Data                     ;Send data byte to LCD  
76eb			; fLCD_Pos                      ;Position cursor  
76eb			; fLCD_Str                      ;Display string  
76eb			; fLCD_Def                      ;Define custom character  
76eb			;  
76eb			; **********************************************************************  
76eb			;  
76eb			; Requires SCMonAPI.asm to also be included in the project  
76eb			;  
76eb			  
76eb			  
76eb			; **********************************************************************  
76eb			; **  Constants  
76eb			; **********************************************************************  
76eb			  
76eb			; Constants that must be defined externally  
76eb			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
76eb			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
76eb			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
76eb			;kLCDWidth: EQU 20             ;Width in characters  
76eb			  
76eb			; general line offsets in any frame buffer  
76eb			  
76eb			  
76eb			display_row_1: equ 0  
76eb			display_row_2: equ display_row_1+display_cols  
76eb			display_row_3: equ display_row_2 + display_cols  
76eb			display_row_4: equ display_row_3 + display_cols  
76eb			;display_row_4_eol:   
76eb			  
76eb			  
76eb			; Cursor position values for the start of each line  
76eb			  
76eb			; E  
76eb			kLCD_Line1: EQU 0x00   
76eb			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
76eb			; E1  
76eb			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
76eb			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
76eb			  
76eb			; Instructions to send as A register to fLCD_Inst  
76eb			kLCD_Clear: EQU 00000001b     ;LCD clear  
76eb			kLCD_Off:   EQU 00001000b     ;LCD off  
76eb			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
76eb			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
76eb			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
76eb			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
76eb			  
76eb			; Constants used by this code module  
76eb			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
76eb			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
76eb			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
76eb			  
76eb			  
76eb			  
76eb			; **********************************************************************  
76eb			; **  LCD support functions  
76eb			; **********************************************************************  
76eb			  
76eb			; Initialise alphanumeric LCD module  
76eb			; LCD control register codes:  
76eb			;   DL   0 = 4-bit mode        1 = 8-bit mode  
76eb			;   N    0 = 1-line mode       1 = 2-line mode  
76eb			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
76eb			;   D    0 = Display off       1 = Display on  
76eb			;   C    0 = Cursor off        1 = Cursor on  
76eb			;   B    0 = Blinking off      1 = Blinking on  
76eb			;   ID   0 = Decrement mode    1 = Increment mode  
76eb			;   SH   0 = Entire shift off  1 = Entire shift on  
76eb 3e 28		fLCD_Init:  LD   A, 40  
76ed cd 12 78		            CALL LCDDelay       ;Delay 40ms after power up  
76f0			; For reliable reset set 8-bit mode - 3 times  
76f0 cd e2 77		            CALL WrFn8bit       ;Function = 8-bit mode  
76f3 cd e2 77		            CALL WrFn8bit       ;Function = 8-bit mode  
76f6 cd e2 77		            CALL WrFn8bit       ;Function = 8-bit mode  
76f9			; Set 4-bit mode  
76f9 cd de 77		            CALL WrFn4bit       ;Function = 4-bit mode  
76fc cd 10 78		            CALL LCDDelay1      ;Delay 37 us or more  
76ff			; Function set  
76ff 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
7701 cd 14 77		            CALL fLCD_Inst      ;2 line, display on  
7704			; Display On/Off control  
7704 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
7706 cd 14 77		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
7709			; Display Clear  
7709 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
770b cd 14 77		            CALL fLCD_Inst      ;Clear display  
770e			; Entry mode  
770e 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
7710 cd 14 77		            CALL fLCD_Inst      ;Increment mode, shift off  
7713			; Display module now initialised  
7713 c9			            RET  
7714			; ok to here  
7714			  
7714			; Write instruction to LCD  
7714			;   On entry: A = Instruction byte to be written  
7714			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7714 f5			fLCD_Inst:  PUSH AF  
7715 f5			            PUSH AF  
7716 cd 28 77		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
7719 f1			            POP  AF  
771a 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
771b 17			            RLA  
771c 17			            RLA  
771d 17			            RLA  
771e cd 28 77		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
7721 3e 02		            LD   A, 2  
7723 cd 12 78		            CALL LCDDelay       ;Delay 2 ms to complete   
7726 f1			            POP  AF  
7727 c9			            RET  
7728			Wr4bits:   
7728 f5					push af  
7729 3a c8 fb				ld a, (display_lcde1e2)  
772c fe 00				cp 0     ; e  
772e 20 10				jr nz, .wea2	  
7730 f1					pop af  
7731 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7733 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7735 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
7737 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
7739 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
773b cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
773d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
773f c9			            RET  
7740 f1			.wea2:		pop af  
7741 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7743 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7745 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
7747 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
7749 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
774b cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
774d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
774f c9			            RET  
7750			  
7750			  
7750			; Write data to LCD  
7750			;   On entry: A = Data byte to be written  
7750			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7750 f5			fLCD_Data:  PUSH AF  
7751 f5			            PUSH AF  
7752 cd 64 77		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7755 f1			            POP  AF  
7756 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7757 17			            RLA  
7758 17			            RLA  
7759 17			            RLA  
775a cd 64 77		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
775d 3e 96		            LD   A, 150  
775f 3d			Wait:      DEC  A              ;Wait a while to allow data   
7760 20 fd		            JR   NZ, Wait      ;  write to complete  
7762 f1			            POP  AF  
7763 c9			            RET  
7764			Wr4bitsa:     
7764 f5					push af  
7765 3a c8 fb				ld a, (display_lcde1e2)  
7768 fe 00				cp 0     ; e1  
776a 20 16				jr nz, .we2	  
776c f1					pop af  
776d e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
776f cb d7		            SET  kLCDBitRS, A  
7771 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7773 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
7775 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
7777 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7779 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
777b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
777d cb 97		            RES  kLCDBitRS, A  
777f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7781 c9			            RET  
7782 f1			.we2:		pop af  
7783 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7785 cb d7		            SET  kLCDBitRS, A  
7787 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7789 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
778b cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
778d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
778f cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
7791 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7793 cb 97		            RES  kLCDBitRS, A  
7795 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7797 c9			            RET  
7798			  
7798			  
7798			; Position cursor to specified location  
7798			;   On entry: A = Cursor position  
7798			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7798 f5			fLCD_Pos:   PUSH AF  
7799					; at this point set the E1 or E2 flag depending on position  
7799			  
7799 c5					push bc  
779a			;		push af  
779a 06 00				ld b, 0  
779c 4f					ld c, a  
779d 3e 4f				ld a, kLCD_Line3-1  
779f b7			 		or a      ;clear carry flag  
77a0 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
77a1 38 04				jr c, .pe1  
77a3			  
77a3					; E selection  
77a3 cb 80				res 0, b         ; bit 0 unset e  
77a5			;		pop af    ; before line 3 so recover orig pos  
77a5			;		ld c, a    ; save for poking back  
77a5 18 06				jr .peset	          
77a7			.pe1:          	; E2 selection  
77a7 cb c0				set 0, b         ; bit 0 set e1  
77a9 79					ld a, c  
77aa de 4f				sbc a, kLCD_Line3-1  
77ac 4f					ld c, a	         ; save caculated offset  
77ad			;		pop af     ; bin this original value now we have calculated form  
77ad			  
77ad			.peset:		; set bit  
77ad 78					ld a, b  
77ae 32 c8 fb				ld (display_lcde1e2), a 	  
77b1 79					ld a, c  
77b2 c1					pop bc  
77b3			  
77b3 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
77b5 cd 14 77		            CALL fLCD_Inst      ;Write instruction to LCD  
77b8 f1			            POP  AF  
77b9 c9			            RET  
77ba			  
77ba			  
77ba			; Output text string to LCD  
77ba			;   On entry: DE = Pointer to null terminated text string  
77ba			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
77ba 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
77bb b7			            OR   A              ;Null terminator?  
77bc c8			            RET  Z              ;Yes, so finished  
77bd cd 50 77		            CALL fLCD_Data      ;Write character to display  
77c0 13			            INC  DE             ;Point to next character  
77c1 18 f7		            JR   fLCD_Str       ;Repeat  
77c3 c9					ret  
77c4			  
77c4			; Define custom character  
77c4			;   On entry: A = Character number (0 to 7)  
77c4			;             DE = Pointer to character bitmap data  
77c4			;   On exit:  A = Next character number  
77c4			;             DE = Next location following bitmap  
77c4			;             BC HL IX IY I AF' BC' DE' HL' preserved  
77c4			; Character is   
77c4 c5			fLCD_Def:   PUSH BC  
77c5 f5			            PUSH AF  
77c6 07			            RLCA                ;Calculate location  
77c7 07			            RLCA                ;  for bitmap data  
77c8 07			            RLCA                ;  = 8 x CharacterNumber  
77c9 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
77cb cd 14 77		            CALL fLCD_Inst      ;Write instruction to LCD  
77ce 06 00		            LD   B, 0  
77d0 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
77d1 cd 50 77		            CALL fLCD_Data      ;Write byte to display  
77d4 13			            INC  DE             ;Point to next byte  
77d5 04			            INC  B              ;Count bytes  
77d6 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
77d8 28 f6		            JR   Z, Loop       ;No, so repeat  
77da f1			            POP  AF  
77db 3c			            INC  A              ;Increment character number  
77dc c1			            POP  BC  
77dd c9			            RET  
77de			  
77de			  
77de			; **********************************************************************  
77de			; **  Private functions  
77de			; **********************************************************************  
77de			  
77de			; Write function to LCD  
77de			;   On entry: A = Function byte to be written  
77de			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
77de 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
77e0 18 02		            JR   WrFunc  
77e2 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
77e4 f5			WrFunc:     PUSH AF  
77e5 f5					push af  
77e6 3a c8 fb				ld a, (display_lcde1e2)  
77e9 fe 00				cp 0     ; e1  
77eb 20 0f				jr nz, .wfea2	  
77ed f1					pop af  
77ee d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77f0 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
77f2 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
77f4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
77f6 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
77f8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77fa 18 0d			jr .wfskip  
77fc f1			.wfea2:		pop af  
77fd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77ff cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
7801 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7803 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7805 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7807 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7809 3e 05		.wfskip:            LD  A, 5  
780b cd 12 78		            CALL LCDDelay       ;Delay 5 ms to complete  
780e f1			            POP  AF  
780f c9			            RET  
7810			  
7810			  
7810			; Delay in milliseconds  
7810			;   On entry: A = Number of milliseconds delay  
7810			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7810 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
7812 d5			LCDDelay:   PUSH DE  
7813 5f			            LD   E, A           ;Delay by 'A' ms  
7814 16 00		            LD   D, 0  
7816 cd c4 0c		            CALL aDelayInMS  
7819 d1			            POP  DE  
781a c9			            RET  
781b			  
781b			  
781b			testlcd:  
781b 3e 00			ld a, kLCD_Line1  
781d cd 98 77			call fLCD_Pos  
7820 06 28			ld b, 40  
7822 11 50 78			ld de, .ttext1  
7825 cd e3 76			call write_len_string  
7828			  
7828 3e 28			ld a, kLCD_Line2  
782a cd 98 77			call fLCD_Pos  
782d 06 28			ld b, 40  
782f 11 79 78			ld de, .ttext2  
7832 cd e3 76			call write_len_string  
7835 3e 50			ld a, kLCD_Line3  
7837 cd 98 77			call fLCD_Pos  
783a 06 28			ld b, 40  
783c 11 a2 78			ld de, .ttext3  
783f cd e3 76			call write_len_string  
7842 3e 78			ld a, kLCD_Line4  
7844 cd 98 77			call fLCD_Pos  
7847 06 28			ld b, 40  
7849 11 cb 78			ld de, .ttext4  
784c cd e3 76			call write_len_string  
784f			  
784f 76				halt  
7850			  
7850			  
7850 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
7879 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
78a2 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
78cb .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
78f4			   
78f4			  
78f4			  
78f4			; eof  
78f4			  
# End of file firmware_lcd_4x40.asm
78f4			;include "firmware_lcd_4x20.asm" 
78f4			include "firmware_key_5x10.asm" 
78f4			; 5 x 10 decade counter scanner  
78f4			  
78f4			  
78f4			; TODO do cursor shape change for shift keys  
78f4			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
78f4			  
78f4			  
78f4			; bit mask for each scan column and row for teing the matrix  
78f4			  
78f4			  
78f4			key_init:  
78f4			  
78f4			; SCMonAPI functions used  
78f4			  
78f4			; Alphanumeric LCD functions used  
78f4			; no need to specify specific functions for this module  
78f4			  
78f4			  
78f4 3e cf		            LD   A, 11001111b  
78f6 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
78f8			;            LD   A, 00000000b  
78f8 3e 1f		            LD   A, 00011111b  
78fa d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
78fc			  
78fc			  
78fc				; TODO Configure cursor shapes  
78fc			  
78fc				; Load cursor shapes   
78fc 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
78fe 11 0e 79		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
7901 06 02		            LD   B, 2           ;Number of characters to define  
7903 cd c4 77		.DefLoop:   CALL fLCD_Def       ;Define custom character  
7906 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
7908			  
7908 3e 01				ld a, 1  
790a 32 be fb			ld (cursor_shape),a  
790d c9				ret  
790e			  
790e			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
790e			; Up to 8 custom characters can be defined  
790e			.cursor_shapes:      
790e			;; Character 0x00 = Normal  
790e 1f			            DB  11111b  
790f 1f			            DB  11111b  
7910 1f			            DB  11111b  
7911 1f			            DB  11111b  
7912 1f			            DB  11111b  
7913 1f			            DB  11111b  
7914 1f			            DB  11111b  
7915 1f			            DB  11111b  
7916			;; Character 0x01 = Modifier  
7916 1f			            DB  11111b  
7917 1b			            DB  11011b  
7918 1b			            DB  11011b  
7919 1b			            DB  11011b  
791a 1b			            DB  11011b  
791b 1f			            DB  11111b  
791c 1b			            DB  11011b  
791d 1f			            DB  11111b  
791e			  
791e			  
791e			  
791e			  
791e			; Display custom character 0  
791e			;            LD   A, kLCD_Line1+14  
791e			;            CALL fLCD_Pos       ;Position cursor to location in A  
791e			;            LD   A, 0  
791e			;            CALL fLCD_Data      ;Write character in A at cursor  
791e			  
791e			; Display custom character 1  
791e			;            LD   A, kLCD_Line2+14  
791e			;            CALL fLCD_Pos      ;Position cursor to location in A  
791e			;            LD   A, 1  
791e			;            CALL fLCD_Data     ;Write character in A at cursor  
791e			  
791e			; keyboard scanning   
791e			  
791e			; character in from keyboard  
791e			  
791e			; mapping for the pcb layout  
791e			  
791e			.matrix_to_char:  
791e .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
7929 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
7934 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
793f 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
794a .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7955			.matrix_to_shift:  
7955			  
7955 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
7960 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
796b 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7976 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
7981 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
798c			  
798c			.matrix_to_symbolshift:  
798c			  
798c fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7997 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
79a2 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
79ad			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
79ad 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
79b8 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
79c3			  
79c3			  
79c3			  
79c3			; mapping for a simple straight through breadboard layout  
79c3			  
79c3			;.matrix_to_char:  
79c3			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
79c3			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
79c3			;		db "asdfghjkl",KEY_CR,0  
79c3			;		db "qwertyuiop",0  
79c3			;		 db "1234567890",0  
79c3			;.matrix_to_shift:  
79c3			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
79c3			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
79c3			;		db "ASDFGHJKL",KEY_CR,0  
79c3			;		db "QWERTYUIOP",0  
79c3			;		 db "!",'"',"#$%^&*()",0  
79c3			;.matrix_to_symbolshift:  
79c3			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
79c3			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
79c3			;		db "_?*fghjk=",KEY_CR,0  
79c3			;		db "-/+*[]{}@#",0  
79c3			;		 db "1234567890",0  
79c3			  
79c3			;.matrix_to_char: db "D#0*C987B654A321"  
79c3			  
79c3			  
79c3				  
79c3			  
79c3			; add cin and cin_wait  
79c3			  
79c3 cd d4 79		cin_wait: 	call cin  
79c6						if DEBUG_KEYCINWAIT  
79c6							push af  
79c6							  
79c6							ld hl,key_repeat_ct  
79c6							ld (hl),a  
79c6							inc hl  
79c6							call hexout  
79c6							ld hl,key_repeat_ct+3  
79c6							ld a,0  
79c6							ld (hl),a  
79c6			  
79c6							    LD   A, kLCD_Line1+11  
79c6							    CALL fLCD_Pos       ;Position cursor to location in A  
79c6							    LD   DE, key_repeat_ct  
79c6							    ;LD   DE, MsgHello  
79c6							    CALL fLCD_Str       ;Display string pointed to by DE  
79c6			  
79c6			  
79c6			  
79c6							pop af  
79c6						endif  
79c6 fe 00			cp 0  
79c8 28 f9			jr z, cin_wait   ; block until key press  
79ca			  
79ca							if DEBUG_KEYCINWAIT  
79ca								push af  
79ca			  
79ca								ld a, 'A'	  
79ca								ld hl,key_repeat_ct  
79ca								ld (hl),a  
79ca								inc hl  
79ca								ld a,0  
79ca								ld (hl),a  
79ca			  
79ca								    LD   A, kLCD_Line2+11  
79ca								    CALL fLCD_Pos       ;Position cursor to location in A  
79ca								    LD   DE, key_repeat_ct  
79ca								    ;LD   DE, MsgHello  
79ca								    CALL fLCD_Str       ;Display string pointed to by DE  
79ca			  
79ca							call delay500ms  
79ca			  
79ca								pop af  
79ca							endif  
79ca f5				push af   ; save key pressed  
79cb			  
79cb			.cin_wait1:	  
79cb							if DEBUG_KEYCINWAIT  
79cb								push af  
79cb			  
79cb								ld a, 'b'	  
79cb								ld hl,key_repeat_ct  
79cb								ld (hl),a  
79cb								inc hl  
79cb								ld a,0  
79cb								ld (hl),a  
79cb			  
79cb								    LD   A, kLCD_Line2+11  
79cb								    CALL fLCD_Pos       ;Position cursor to location in A  
79cb								    LD   DE, key_repeat_ct  
79cb								    ;LD   DE, MsgHello  
79cb								    CALL fLCD_Str       ;Display string pointed to by DE  
79cb			  
79cb			  
79cb							call delay500ms  
79cb			  
79cb								pop af  
79cb							endif  
79cb			  
79cb cd d4 79		call cin  
79ce fe 00			cp 0  
79d0 20 f9			jr nz, .cin_wait1  	; wait for key release  
79d2			if DEBUG_KEYCINWAIT  
79d2				push af  
79d2			  
79d2				ld a, '3'	  
79d2				ld hl,key_repeat_ct  
79d2				ld (hl),a  
79d2				inc hl  
79d2				ld a,0  
79d2				ld (hl),a  
79d2			  
79d2			            LD   A, kLCD_Line2+11  
79d2			            CALL fLCD_Pos       ;Position cursor to location in A  
79d2			            LD   DE, key_repeat_ct  
79d2			            ;LD   DE, MsgHello  
79d2			            CALL fLCD_Str       ;Display string pointed to by DE  
79d2			  
79d2			  
79d2			call delay500ms  
79d2			  
79d2				pop af  
79d2			endif  
79d2			  
79d2 f1				pop af   ; get key  
79d3 c9				ret  
79d4			  
79d4			  
79d4 cd e8 79		cin: 	call .mtoc  
79d7			  
79d7			if DEBUG_KEYCIN  
79d7				push af  
79d7				  
79d7				ld hl,key_repeat_ct  
79d7				ld (hl),a  
79d7				inc hl  
79d7				call hexout  
79d7				ld hl,key_repeat_ct+3  
79d7				ld a,0  
79d7				ld (hl),a  
79d7			  
79d7			            LD   A, kLCD_Line3+15  
79d7			            CALL fLCD_Pos       ;Position cursor to location in A  
79d7			            LD   DE, key_repeat_ct  
79d7			            ;LD   DE, MsgHello  
79d7			            CALL fLCD_Str       ;Display string pointed to by DE  
79d7			  
79d7			  
79d7			call delay500ms  
79d7			  
79d7				pop af  
79d7			endif  
79d7			  
79d7			  
79d7				; no key held  
79d7 fe 00			cp 0  
79d9 c8				ret z  
79da			  
79da			if DEBUG_KEYCIN  
79da				push af  
79da			  
79da				ld a, '1'	  
79da				ld hl,key_repeat_ct  
79da				ld (hl),a  
79da				inc hl  
79da				ld a,0  
79da				ld (hl),a  
79da			  
79da			            LD   A, kLCD_Line4+15  
79da			            CALL fLCD_Pos       ;Position cursor to location in A  
79da			            LD   DE, key_repeat_ct  
79da			            ;LD   DE, MsgHello  
79da			            CALL fLCD_Str       ;Display string pointed to by DE  
79da			  
79da			  
79da			call delay500ms  
79da			  
79da				pop af  
79da			endif  
79da			  
79da				; stop key bounce  
79da			  
79da 32 88 fe			ld (key_held),a		 ; save it  
79dd 47				ld b, a  
79de			  
79de c5			.cina1:	push bc  
79df			if DEBUG_KEYCIN  
79df				push af  
79df			  
79df				ld hl,key_repeat_ct  
79df				inc hl  
79df				call hexout  
79df				ld hl,key_repeat_ct+3  
79df				ld a,0  
79df				ld (hl),a  
79df				ld hl,key_repeat_ct  
79df				ld a, '2'	  
79df				ld (hl),a  
79df			  
79df			            LD   A, kLCD_Line4+15  
79df			            CALL fLCD_Pos       ;Position cursor to location in A  
79df			            LD   DE, key_repeat_ct  
79df			            ;LD   DE, MsgHello  
79df			            CALL fLCD_Str       ;Display string pointed to by DE  
79df			  
79df				pop af  
79df			endif  
79df cd e8 79			call .mtoc  
79e2 c1				pop bc  
79e3 b8				cp b  
79e4 28 f8			jr z, .cina1  
79e6 78				ld a,b		  
79e7			if DEBUG_KEYCIN  
79e7				push af  
79e7			  
79e7				ld hl,key_repeat_ct  
79e7				inc hl  
79e7				call hexout  
79e7				ld hl,key_repeat_ct+3  
79e7				ld a,0  
79e7				ld (hl),a  
79e7				ld hl,key_repeat_ct  
79e7				ld a, '3'	  
79e7				ld (hl),a  
79e7			  
79e7			            LD   A, kLCD_Line4+15  
79e7			            CALL fLCD_Pos       ;Position cursor to location in A  
79e7			            LD   DE, key_repeat_ct  
79e7			            ;LD   DE, MsgHello  
79e7			            CALL fLCD_Str       ;Display string pointed to by DE  
79e7			  
79e7				pop af  
79e7			endif  
79e7 c9				ret  
79e8			  
79e8			; detect keyboard modifier key press and apply new overlay to the face key held  
79e8			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
79e8			  
79e8			;.cin_map_modifier:   
79e8			;	ld a, (hl)  
79e8			;	and 255  
79e8			;	ret NZ		; modifier key not flagged  
79e8			;  
79e8			;	; get key face  
79e8			;  
79e8			;	ld b,(key_face_held)  
79e8			;  
79e8			;	ld b, key_cols * key_rows  
79e8			;  
79e8			;	push de  
79e8			;	pop hl  
79e8			;  
79e8			;.mmod1: ld a,(hl)   ; get map test  
79e8			;	cp b  
79e8			;	jr z, .mmod2  
79e8			;  
79e8			;  
79e8			;  
79e8			;.mmod2: inc hl    ;   
79e8			;  
79e8			;	  
79e8			;  
79e8			;	  
79e8			;  
79e8			;	ld hl,key_actual_pressed  
79e8			;	ld (hl),a,  
79e8			;	ret  
79e8			  
79e8			; map matrix key held to char on face of key  
79e8			  
79e8			.mtoc:  
79e8			  
79e8			; test decade counter strobes  
79e8			  
79e8			;.decadetest1:  
79e8			  
79e8			; reset counter  
79e8			;ld a, 128  
79e8			;out (portbdata),a  
79e8			  
79e8			  
79e8			;ld b, 5  
79e8			;.dec1:  
79e8			;ld a, 0  
79e8			;out (portbdata),a  
79e8			;call delay1s  
79e8			  
79e8			;ld a, 32  
79e8			;out (portbdata),a  
79e8			;call delay1s  
79e8			;call delay1s  
79e8			;call delay1s  
79e8			;  
79e8			;ld a, 64+32  
79e8			;out (portbdata),a  
79e8			;call delay1s  
79e8			;;djnz .dec1  
79e8			;  
79e8			;jp .decadetest1  
79e8			  
79e8			  
79e8			  
79e8			  
79e8			  
79e8			  
79e8			  
79e8			  
79e8			  
79e8			  
79e8				; scan keyboard matrix and generate raw scan map  
79e8 cd 7b 7a			call matrix  
79eb			  
79eb				; reuse c bit 0 left modifer button - ie shift  
79eb			        ; reuse c bit 1 for right modifer button - ie symbol shift  
79eb				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
79eb			  
79eb 0e 00			ld c, 0  
79ed			  
79ed				; TODO set flags for modifer key presses   
79ed				; TODO do a search for modifer key...  
79ed			  
79ed				;ld hl,keyscan_table_row4  
79ed 21 e7 fe			ld hl,keyscan_table_row2  
79f0			  
79f0 7e				ld a, (hl)  
79f1 fe 23			cp '#'  
79f3 20 07			jr nz, .nextmodcheck  
79f5 cb c1			set 0, c  
79f7 21 55 79			ld hl, .matrix_to_shift  
79fa 18 21			jr .dokeymap  
79fc				; TODO for now igonre  
79fc			.nextmodcheck:  
79fc 21 dc fe			ld hl,keyscan_table_row3  
79ff			  
79ff 7e				ld a, (hl)  
7a00 fe 23			cp '#'  
7a02 20 07			jr nz, .nextmodcheck2  
7a04 cb c9			set 1, c   
7a06 21 8c 79			ld hl, .matrix_to_symbolshift  
7a09 18 12			jr .dokeymap  
7a0b			.nextmodcheck2:  
7a0b 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
7a0e			  
7a0e 7e				ld a, (hl)  
7a0f fe 23			cp '#'  
7a11 20 07			jr nz, .donemodcheck  
7a13 cb c9			set 1, c   
7a15 21 55 79			ld hl, .matrix_to_shift  
7a18 18 03			jr .dokeymap  
7a1a			  
7a1a				; no modifer found so just map to normal keys  
7a1a				; get mtoc map matrix to respective keys  
7a1a			;	ld hl, .matrix_to_char  
7a1a			;	ld hl, .matrix_to_char  
7a1a			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7a1a			;	ld a, KEY_SHIFT  
7a1a			;	call findchar  
7a1a			;  
7a1a			;	; got offset to key modifer in b  
7a1a			;  
7a1a			;	ld hl,keyscan_table_row5  
7a1a			;  
7a1a			;	ld a,b  
7a1a			;	call addatohl  
7a1a			;	ld a,(hl)  
7a1a			;  
7a1a			;	cp '#'  
7a1a			;	jr nz, .nextmodcheck  
7a1a			;	set 0, c  
7a1a			;	ld hl, .matrix_to_char  
7a1a			;	jr .dokeymap  
7a1a			;	; TODO for now igonre  
7a1a			;.nextmodcheck:  
7a1a			;	ld hl, .matrix_to_symbolshift  
7a1a			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7a1a			;	ld a, KEY_SYMBOLSHIFT  
7a1a			;	call findchar  
7a1a			;  
7a1a			;  
7a1a			;	; got offset to key modifer in b  
7a1a			;  
7a1a			;	ld hl,keyscan_table_row5  
7a1a			;  
7a1a			;	ld a,b  
7a1a			;	call addatohl  
7a1a			;	ld a,(hl)  
7a1a			;  
7a1a			;	cp '#'  
7a1a			;	jr nz, .donemodcheck  
7a1a			;	set 1, c   
7a1a			;	ld hl, .matrix_to_symbolshift  
7a1a			;	jr .dokeymap  
7a1a			  
7a1a			  
7a1a			  
7a1a			.donemodcheck:  
7a1a				; no modifer found so just map to normal keys  
7a1a				; get mtoc map matrix to respective keys  
7a1a 21 1e 79			ld hl, .matrix_to_char  
7a1d			  
7a1d			.dokeymap:  
7a1d				;ld (key_fa), c   
7a1d cd 36 7a			call .mapkeys  
7a20			  
7a20			  
7a20			if DEBUG_KEY  
7a20			  
7a20			; Display text on first line  
7a20			            LD   A, kLCD_Line1  
7a20			            CALL fLCD_Pos       ;Position cursor to location in A  
7a20			            LD   DE, keyscan_table_row1  
7a20			            ;LD   DE, MsgHello  
7a20			            CALL fLCD_Str       ;Display string pointed to by DE  
7a20			  
7a20			; Display text on second line  
7a20			            LD   A, kLCD_Line2  
7a20			            CALL fLCD_Pos       ;Position cursor to location in A  
7a20			            LD   DE, keyscan_table_row2  
7a20			            CALL fLCD_Str       ;Display string pointed to by DE  
7a20			            LD   A, kLCD_Line3  
7a20			            CALL fLCD_Pos       ;Position cursor to location in A  
7a20			            LD   DE, keyscan_table_row3  
7a20			            CALL fLCD_Str       ;Display string pointed to by DE  
7a20			            LD   A, kLCD_Line4  
7a20			            CALL fLCD_Pos       ;Position cursor to location in A  
7a20			            LD   DE, keyscan_table_row4  
7a20			            CALL fLCD_Str       ;Display string pointed to by DE  
7a20			            LD   A, kLCD_Line1+10  
7a20			            CALL fLCD_Pos       ;Position cursor to location in A  
7a20			            LD   DE, keyscan_table_row5  
7a20			            CALL fLCD_Str       ;Display string pointed to by DE  
7a20			  
7a20				;call delay250ms  
7a20			endif  
7a20			;	jp testkey  
7a20			  
7a20			; get first char reported  
7a20			  
7a20 21 c6 fe			ld hl,keyscan_table_row5  
7a23			  
7a23				;ld b, 46   ; 30 keys to remap + 8 nulls   
7a23 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7a25			.findkey:  
7a25 7e				ld a,(hl)  
7a26 fe 00			cp 0  
7a28 28 04			jr z, .nextkey  
7a2a fe 7e			cp KEY_MATRIX_NO_PRESS  
7a2c 20 06			jr nz, .foundkey  
7a2e			.nextkey:  
7a2e 23				inc hl  
7a2f 10 f4			djnz .findkey  
7a31 3e 00			ld a,0  
7a33 c9				ret  
7a34			.foundkey:  
7a34 7e				ld a,(hl)  
7a35 c9				ret  
7a36				  
7a36			  
7a36			; convert the raw key map given hl for destination key  
7a36			.mapkeys:  
7a36 11 c6 fe			ld de,keyscan_table_row5  
7a39			  
7a39 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7a3b			.remap:  
7a3b 1a				ld a,(de)  
7a3c fe 23			cp '#'  
7a3e 20 02			jr nz, .remapnext  
7a40				;CALLMONITOR  
7a40 7e				ld a,(hl)  
7a41 12				ld (de),a  
7a42			  
7a42			  
7a42			  
7a42			.remapnext:  
7a42 23				inc hl  
7a43 13				inc de  
7a44 10 f5			djnz .remap  
7a46				  
7a46 c9				ret  
7a47			  
7a47			  
7a47			  
7a47			.mtocold2:  
7a47			  
7a47			;	; flag if key D is held down and remove from reporting  
7a47			;	ld bc, .key_map_fd    
7a47			;	ld hl, keyscan_table  
7a47			;	ld de, key_fd  
7a47			;	call .key_shift_hold  
7a47			;	cp 255  
7a47			;	jr z, .cinmap  
7a47			;	; flag if key C is held down and remove from reporting  
7a47			;	ld bc, .key_map_fc    
7a47			;	ld hl, keyscan_table+key_cols  
7a47			;	ld de, key_fc  
7a47			;	call .key_shift_hold  
7a47			;	cp 255  
7a47			;	jr z, .cinmap  
7a47			;	; flag if key B is held down and remove from reporting  
7a47			;	ld bc, .key_map_fb    
7a47			;	ld hl, keyscan_table+(key_cols*2)  
7a47			;	ld de, key_fb  
7a47			;	call .key_shift_hold  
7a47			;	cp 255  
7a47			;	jr z, .cinmap  
7a47			;	; flag if key A is held down and remove from reporting  
7a47			;	ld bc, .key_map_fa    
7a47			;	ld hl, keyscan_table+(key_cols*3)  
7a47			;	ld de, key_fa  
7a47			;	call .key_shift_hold  
7a47			;	cp 255  
7a47			;	jr z, .cinmap  
7a47			  
7a47 11 1e 79			ld de, .matrix_to_char  
7a4a			  
7a4a			  
7a4a			.cinmap1:   
7a4a				if DEBUG_KEY  
7a4a			            LD   A, kLCD_Line4  
7a4a			            CALL fLCD_Pos       ;Position cursor to location in A  
7a4a					push de  
7a4a			            LD   DE, keyscan_table  
7a4a			            CALL fLCD_Str       ;Display string pointed to by DE  
7a4a					pop de  
7a4a				endif  
7a4a			  
7a4a				; scan key matrix table for any held key  
7a4a			  
7a4a				; de holds either the default matrix or one selected above  
7a4a			  
7a4a 21 93 fe			ld hl, keyscan_table  
7a4d 06 32			ld b,key_cols*key_rows  
7a4f			  
7a4f 7e			.cin11:	ld a,(hl)  
7a50 fe 23			cp '#'  
7a52 28 08			jr z, .cinhit1  
7a54 23				inc hl  
7a55 13				inc de  
7a56 05				dec b  
7a57 20 f6			jr nz, .cin11  
7a59				; no key found held  
7a59 3e 00			ld a,0  
7a5b c9				ret  
7a5c d5			.cinhit1: push de  
7a5d e1				pop hl  
7a5e 7e				ld a,(hl)  
7a5f c9				ret  
7a60			  
7a60			; flag a control key is held   
7a60			; hl is key pin, de is flag indicator  
7a60			  
7a60			.key_shift_hold1:  
7a60 c5				push bc  
7a61 3e 01			ld a, 1  
7a63 32 be fb			ld (cursor_shape),a  
7a66 06 00			ld b, 0  
7a68 7e				ld a, (hl)  
7a69 fe 2e			cp '.'  
7a6b 28 0a			jr z, .key_shift11  
7a6d 06 ff			ld b, 255  
7a6f 3e 2b			ld a, '+'    ; hide key from later scans  
7a71 77				ld (hl),a  
7a72 3e 02			ld a, 2  
7a74 32 be fb			ld (cursor_shape),a  
7a77			.key_shift11:  
7a77				; write flag indicator  
7a77 78				ld a,b  
7a78 12				ld (de),a  
7a79			  
7a79 d1				pop de    ; de now holds the key map ptr  
7a7a c9				ret  
7a7b			  
7a7b				  
7a7b			  
7a7b			; scans keyboard matrix and flags key press in memory array	  
7a7b				  
7a7b			matrix:  
7a7b				;call matrix  
7a7b				; TODO optimise the code....  
7a7b			  
7a7b			  
7a7b			;ld hl, keyscan_table_row1  
7a7b			;ld de, keyscan_table_row1+1  
7a7b			;ld bc,46  
7a7b			;ld a,KEY_MATRIX_NO_PRESS  
7a7b			;ldir  
7a7b			  
7a7b			  
7a7b			  
7a7b			; reset counter  
7a7b 3e 80		ld a, 128  
7a7d d3 c1		out (portbdata),a  
7a7f			  
7a7f 06 0a		ld b, 10  
7a81 0e 00		ld c, 0       ; current clock toggle  
7a83			  
7a83			.colscan:  
7a83			  
7a83			; set current column  
7a83			; disable clock enable and set clock low  
7a83			  
7a83			;ld a, 0  
7a83			;out (portbdata),a  
7a83			  
7a83			; For each column scan for switches  
7a83			  
7a83 c5			push bc  
7a84 21 89 fe		ld hl, keyscan_scancol  
7a87 cd 90 7b		call .rowscan  
7a8a c1			pop bc  
7a8b			  
7a8b			  
7a8b			; get back current column  
7a8b			  
7a8b			; translate the row scan  
7a8b			  
7a8b			;   
7a8b			; row 1  
7a8b			  
7a8b 78			ld a,b  
7a8c			  
7a8c 21 fc fe		LD   hl, keyscan_table_row1+10  
7a8f			  
7a8f cd e2 0f		call subafromhl  
7a92			;call addatohl  
7a92			  
7a92 11 89 fe		ld de, keyscan_scancol  
7a95			  
7a95 1a			ld a,(de)  
7a96 77			ld (hl),a  
7a97			  
7a97			  
7a97			  
7a97			  
7a97			; row 2  
7a97			  
7a97 78			ld a,b  
7a98			  
7a98 21 f1 fe		LD   hl, keyscan_table_row2+10  
7a9b			  
7a9b			;call addatohl  
7a9b cd e2 0f		call subafromhl  
7a9e			  
7a9e			  
7a9e 11 8a fe		ld de, keyscan_scancol+1  
7aa1			  
7aa1 1a			ld a,(de)  
7aa2 77			ld (hl),a  
7aa3			  
7aa3			  
7aa3			; row 3  
7aa3			  
7aa3 78			ld a,b  
7aa4			  
7aa4 21 e6 fe		LD   hl, keyscan_table_row3+10  
7aa7			  
7aa7			;call addatohl  
7aa7 cd e2 0f		call subafromhl  
7aaa			  
7aaa 11 8b fe		ld de, keyscan_scancol+2  
7aad			  
7aad 1a			ld a,(de)  
7aae 77			ld (hl),a  
7aaf			  
7aaf			  
7aaf			  
7aaf			; row 4  
7aaf			  
7aaf 78			ld a,b  
7ab0			  
7ab0 21 db fe		LD   hl, keyscan_table_row4+10  
7ab3			  
7ab3			;call addatohl  
7ab3 cd e2 0f		call subafromhl  
7ab6			  
7ab6 11 8c fe		ld de, keyscan_scancol+3  
7ab9			  
7ab9 1a			ld a,(de)  
7aba 77			ld (hl),a  
7abb			  
7abb			; row 5  
7abb			  
7abb 78			ld a,b  
7abc			  
7abc 21 d0 fe		LD   hl, keyscan_table_row5+10  
7abf			  
7abf			;call addatohl  
7abf cd e2 0f		call subafromhl  
7ac2			  
7ac2 11 8d fe		ld de, keyscan_scancol+4  
7ac5			  
7ac5 1a			ld a,(de)  
7ac6 77			ld (hl),a  
7ac7			  
7ac7			; handshake next column  
7ac7			  
7ac7			  
7ac7 3e 40		ld a, 64  
7ac9 d3 c1		out (portbdata),a  
7acb			  
7acb 3e 00		ld a, 0  
7acd d3 c1		out (portbdata),a  
7acf			  
7acf			; toggle clk and move to next column  
7acf			;ld a, 64  
7acf			;cp c  
7acf			;  
7acf			;jr z, .coltoglow  
7acf			;ld c, a  
7acf			;jr .coltog  
7acf			;.coltoglow:  
7acf			;ld c, 0  
7acf			;.coltog:  
7acf			;ld a, c  
7acf			;out (portbdata),a  
7acf			  
7acf 10 b2		djnz .colscan  
7ad1			  
7ad1 3e 0a		ld a,10  
7ad3 21 f2 fe		LD   hl, keyscan_table_row1  
7ad6 cd d0 0f		call addatohl  
7ad9 3e 00		ld a, 0  
7adb 77			ld (hl), a  
7adc			  
7adc			  
7adc 3e 0a		ld a,10  
7ade 21 e7 fe		LD   hl, keyscan_table_row2  
7ae1 cd d0 0f		call addatohl  
7ae4 3e 00		ld a, 0  
7ae6 77			ld (hl), a  
7ae7			  
7ae7 3e 0a		ld a,10  
7ae9 21 dc fe		LD   hl, keyscan_table_row3  
7aec cd d0 0f		call addatohl  
7aef 3e 00		ld a, 0  
7af1 77			ld (hl), a  
7af2			  
7af2 3e 0a		ld a,10  
7af4 21 d1 fe		LD   hl, keyscan_table_row4  
7af7 cd d0 0f		call addatohl  
7afa 3e 00		ld a, 0  
7afc 77			ld (hl), a  
7afd			  
7afd 3e 0a		ld a,10  
7aff 21 c6 fe		LD   hl, keyscan_table_row5  
7b02 cd d0 0f		call addatohl  
7b05 3e 00		ld a, 0  
7b07 77			ld (hl), a  
7b08			  
7b08			if DEBUG_KEY_MATRIX  
7b08			  
7b08			; Display text on first line  
7b08			            LD   A, kLCD_Line1  
7b08			            CALL fLCD_Pos       ;Position cursor to location in A  
7b08			            LD   DE, keyscan_table_row1  
7b08			            ;LD   DE, MsgHello  
7b08			            CALL fLCD_Str       ;Display string pointed to by DE  
7b08			  
7b08			; Display text on second line  
7b08			            LD   A, kLCD_Line2  
7b08			            CALL fLCD_Pos       ;Position cursor to location in A  
7b08			            LD   DE, keyscan_table_row2  
7b08			            CALL fLCD_Str       ;Display string pointed to by DE  
7b08			            LD   A, kLCD_Line3  
7b08			            CALL fLCD_Pos       ;Position cursor to location in A  
7b08			            LD   DE, keyscan_table_row3  
7b08			            CALL fLCD_Str       ;Display string pointed to by DE  
7b08			            LD   A, kLCD_Line4  
7b08			            CALL fLCD_Pos       ;Position cursor to location in A  
7b08			            LD   DE, keyscan_table_row4  
7b08			            CALL fLCD_Str       ;Display string pointed to by DE  
7b08			            LD   A, kLCD_Line4+10  
7b08			            CALL fLCD_Pos       ;Position cursor to location in A  
7b08			            LD   DE, keyscan_table_row5  
7b08			            CALL fLCD_Str       ;Display string pointed to by DE  
7b08			  
7b08			;call delay250ms  
7b08				jp matrix  
7b08			endif  
7b08 c9			ret  
7b09			  
7b09			; using decade counter....  
7b09			  
7b09			  
7b09			; TODO reset decade counter to start of scan  
7b09			  
7b09			; reset 15  
7b09			; clock 14  
7b09			; ce 13  
7b09			  
7b09			; 1 - q5  
7b09			; 2 - q1  
7b09			; 3 - q0  
7b09			; 4 - q2  
7b09			; 5 - q6  
7b09			; 6 - q7  
7b09			; 7 - q3  
7b09			; 8 - vss  
7b09			; 9 - q8  
7b09			; 10 - q4  
7b09			; 11 - q9  
7b09			; 12 - cout  
7b09			; 16 - vdd  
7b09			  
7b09			; clock      ce       reset     output  
7b09			; 0          x        0         n  
7b09			; x          1        0         n  
7b09			; x          x        1         q0  
7b09			; rising     0        0         n+1  
7b09			; falling    x        0         n  
7b09			; x          rising   0         n  
7b09			; 1          falling  0         x+1  
7b09			;  
7b09			; x = dont care, if n < 5 carry = 1 otherwise 0  
7b09			  
7b09			;   
7b09			; reset   
7b09			; 13=0, 14=0, 15=1 .. 15=0  
7b09			;  
7b09			; handshake line  
7b09			; 14=1.... read line 14=0  
7b09			  
7b09			  
7b09			  
7b09			  
7b09			  
7b09			; TODO hand shake clock for next column scan  
7b09			; TODO detect each row  
7b09			  
7b09			  
7b09			  
7b09			  
7b09			; reset 128  
7b09			; clock 64  
7b09			; ce 32  
7b09			  
7b09			  
7b09			.cyclestart:  
7b09			  
7b09			; reset counter  
7b09 3e 80		ld a, 128  
7b0b d3 c1		out (portbdata),a  
7b0d			  
7b0d			; loop leds  
7b0d 06 0a		ld b,10  
7b0f			  
7b0f			.cycle1:  
7b0f c5			push bc  
7b10 3e 00		ld a, 0  
7b12 d3 c1		out (portbdata),a  
7b14 cd d3 0c		call delay250ms  
7b17			  
7b17 3e 40		ld a, 64  
7b19 d3 c1		out (portbdata),a  
7b1b cd d3 0c		call delay250ms  
7b1e			  
7b1e 3e 00		ld a, 0  
7b20 d3 c1		out (portbdata),a  
7b22 cd d3 0c		call delay250ms  
7b25			  
7b25 c1			pop bc  
7b26 10 e7		djnz .cycle1  
7b28			  
7b28			  
7b28 18 df		jr .cyclestart  
7b2a			  
7b2a			  
7b2a			  
7b2a			  
7b2a			  
7b2a			  
7b2a			  
7b2a			  
7b2a			  
7b2a			; map matrix key held to char on face of key  
7b2a			  
7b2a			;.mtocold:  
7b2a			;  
7b2a			;  
7b2a			;; reset counter  
7b2a			;ld a, 128  
7b2a			;out (portbdata),a  
7b2a			;  
7b2a			;  
7b2a			;; scan keyboard row 1  
7b2a			;ld a, 0  
7b2a			;out (portbdata),a  
7b2a			;;ld a, 64  
7b2a			;;out (portbdata),a  
7b2a			;  
7b2a			;  
7b2a			;	ld a, 128  
7b2a			;	ld hl, keyscan_table  
7b2a			;	call .rowscan  
7b2a			;  
7b2a			;;ld a, 0  
7b2a			;;out (portbdata),a  
7b2a			;ld a, 64  
7b2a			;out (portbdata),a  
7b2a			;  
7b2a			;	ld a, 64  
7b2a			;	ld hl, keyscan_table+key_cols  
7b2a			;	call .rowscan  
7b2a			;  
7b2a			;ld a, 0  
7b2a			;out (portbdata),a  
7b2a			;;ld a, 64  
7b2a			;;out (portbdata),a  
7b2a			;	ld a, 32  
7b2a			;	ld hl, keyscan_table+(key_cols*2)  
7b2a			;	call .rowscan  
7b2a			;  
7b2a			;  
7b2a			;;ld a, 0  
7b2a			;;out (portbdata),a  
7b2a			;ld a, 64  
7b2a			;out (portbdata),a  
7b2a			;  
7b2a			;	ld a, 16  
7b2a			;	ld hl, keyscan_table+(key_cols*3)  
7b2a			;	call .rowscan  
7b2a			;  
7b2a			;  
7b2a			;	; flag if key D is held down and remove from reporting  
7b2a			;	ld bc, .key_map_fd    
7b2a			;	ld hl, keyscan_table  
7b2a			;	ld de, key_fd  
7b2a			;	call .key_shift_hold  
7b2a			;	cp 255  
7b2a			;	jr z, .cinmap  
7b2a			;	; flag if key C is held down and remove from reporting  
7b2a			;	ld bc, .key_map_fc    
7b2a			;	ld hl, keyscan_table+key_cols  
7b2a			;	ld de, key_fc  
7b2a			;	call .key_shift_hold  
7b2a			;	cp 255  
7b2a			;	jr z, .cinmap  
7b2a			;	; flag if key B is held down and remove from reporting  
7b2a			;	ld bc, .key_map_fb    
7b2a			;	ld hl, keyscan_table+(key_cols*2)  
7b2a			;	ld de, key_fb  
7b2a			;	call .key_shift_hold  
7b2a			;	cp 255  
7b2a			;	jr z, .cinmap  
7b2a			;	; flag if key A is held down and remove from reporting  
7b2a			;	ld bc, .key_map_fa    
7b2a			;	ld hl, keyscan_table+(key_cols*3)  
7b2a			;	ld de, key_fa  
7b2a			;	call .key_shift_hold  
7b2a			;	cp 255  
7b2a			;	jr z, .cinmap  
7b2a			;  
7b2a			;	ld de, .matrix_to_char  
7b2a			;  
7b2a			;  
7b2a			;.cinmap:   
7b2a			;	if DEBUG_KEY  
7b2a			;            LD   A, kLCD_Line4  
7b2a			;            CALL fLCD_Pos       ;Position cursor to location in A  
7b2a			;		push de  
7b2a			;            LD   DE, keyscan_table  
7b2a			;            CALL fLCD_Str       ;Display string pointed to by DE  
7b2a			;		pop de  
7b2a			;	endif  
7b2a			  
7b2a				; scan key matrix table for any held key  
7b2a			  
7b2a				; de holds either the default matrix or one selected above  
7b2a			  
7b2a			;	ld hl, keyscan_table  
7b2a			;	ld b,key_cols*key_rows  
7b2a			;  
7b2a			;.cin1:	ld a,(hl)  
7b2a			;	cp '#'  
7b2a			;	jr z, .cinhit  
7b2a			;	inc hl  
7b2a			;	inc de  
7b2a			;	dec b  
7b2a			;	jr nz, .cin1  
7b2a			;	; no key found held  
7b2a			;	ld a,0  
7b2a			;	ret  
7b2a			;.cinhit: push de  
7b2a			;	pop hl  
7b2a			;	ld a,(hl)  
7b2a			;	ret  
7b2a			  
7b2a			; flag a control key is held   
7b2a			; hl is key pin, de is flag indicator  
7b2a			  
7b2a			;.key_shift_hold:  
7b2a			;	push bc  
7b2a			;	ld a, 1  
7b2a			;	ld (cursor_shape),a  
7b2a			;	ld b, 0  
7b2a			;	ld a, (hl)  
7b2a			;	cp '.'  
7b2a			;	jr z, .key_shift1  
7b2a			;	ld b, 255  
7b2a			;	ld a, '+'    ; hide key from later scans  
7b2a			;	ld (hl),a  
7b2a			;	ld a, 2  
7b2a			;	ld (cursor_shape),a  
7b2a			;.key_shift1:  
7b2a			;	; write flag indicator  
7b2a			;	ld a,b  
7b2a			;	ld (de),a  
7b2a			;  
7b2a			;	pop de    ; de now holds the key map ptr  
7b2a			;	ret  
7b2a			  
7b2a				  
7b2a				  
7b2a			  
7b2a			  
7b2a			  
7b2a			  
7b2a			  
7b2a			  
7b2a			  
7b2a			  
7b2a			  
7b2a			  
7b2a			  
7b2a			;	push hl  
7b2a			;	push de  
7b2a			;	push bc  
7b2a			;	call keyscan  
7b2a			;	; map key matrix to ascii value of key face  
7b2a			;  
7b2a			;	ld hl, key_face_map  
7b2a			;	ld de, keyscan_table  
7b2a			;  
7b2a			;	; get how many keys to look at  
7b2a			;	ld b, keyscan_table_len  
7b2a			;	  
7b2a			;  
7b2a			;	; at this stage fall out on first key hit  
7b2a			;	; TODO handle multiple key press  
7b2a			;  
7b2a			;map1:	ld a,(hl)  
7b2a			;	cp '#'  
7b2a			;	jr z, keyhit  
7b2a			;	inc hl  
7b2a			;	inc de  
7b2a			;	dec b  
7b2a			;	jr nz, map1  
7b2a			;nohit:	ld a, 0  
7b2a			;	jr keydone  
7b2a			;keyhit: push de  
7b2a			;	pop hl  
7b2a			;	ld a,(hl)  
7b2a			;keydone:  
7b2a			;	push bc  
7b2a			;	push de  
7b2a			; 	push hl  
7b2a			;	ret   
7b2a			;  
7b2a			  
7b2a			  
7b2a			  
7b2a			  
7b2a			; scan physical key matrix  
7b2a			  
7b2a			  
7b2a			;keyscan:  
7b2a			;  
7b2a			;; for each key_row use keyscanr bit mask for out  
7b2a			;; then read in for keyscanc bitmask  
7b2a			;; save result of row scan to keyscantable  
7b2a			;  
7b2a			;; scan keyboard row 1  
7b2a			;  
7b2a			;	ld b, key_rows  
7b2a			;	ld hl, key_scanr  
7b2a			;	ld de, keyscan_table  
7b2a			;  
7b2a			;rowloop:  
7b2a			;  
7b2a			;	ld a,(hl)		; out bit mask to energise keyboard row  
7b2a			;	call rowscan  
7b2a			;	inc hl  
7b2a			;	dec b  
7b2a			;	jr nz, rowloop  
7b2a			;  
7b2a			;	ret  
7b2a			;  
7b2a			;  
7b2a			;; pass a out bitmask, b row number  
7b2a			;arowscan:   
7b2a			;	push bc  
7b2a			;  
7b2a			;	ld d, b  
7b2a			;  
7b2a			;	; calculate buffer location for this row  
7b2a			;  
7b2a			;	ld hl, keyscan_table	  
7b2a			;kbufr:  ld e, key_cols  
7b2a			;kbufc:	inc hl  
7b2a			;	dec e  
7b2a			;	jr nz, kbufc  
7b2a			;	dec d  
7b2a			;	jr nz, kbufr  
7b2a			;  
7b2a			;	; energise row and read columns  
7b2a			;  
7b2a			;	out (portbdata),a  
7b2a			;	in a,(portbdata)  
7b2a			;	ld c,a  
7b2a			;  
7b2a			;  
7b2a			;	; save buffer loc  
7b2a			;  
7b2a			;	ld (keybufptr), hl  
7b2a			;  
7b2a			;	ld hl, key_scanc  
7b2a			;	ld d, key_cols  
7b2a			;  
7b2a			;	; for each column check each bit mask  
7b2a			;  
7b2a			;colloop:  
7b2a			;	  
7b2a			;  
7b2a			;	; reset flags for the row   
7b2a			;  
7b2a			;	ld b,'.'  
7b2a			;	and (hl)  
7b2a			;	jr z, maskskip  
7b2a			;	ld b,'#'  
7b2a			;maskskip:  
7b2a			;	; save  key state  
7b2a			;	push hl  
7b2a			;	ld hl, (keybufptr)  
7b2a			;	ld (hl), b  
7b2a			;	inc hl  
7b2a			;	ld (keybufptr), hl  
7b2a			;  
7b2a			;	; move to next bit mask  
7b2a			;	pop hl  
7b2a			;	inc hl  
7b2a			;  
7b2a			;	dec d  
7b2a			;	jr nz, colloop  
7b2a			;  
7b2a			;	ret  
7b2a			;  
7b2a			;  
7b2a			;;  
7b2a			; lcd functions  
7b2a			;  
7b2a			;  
7b2a			  
7b2a			;if DEBUG_KEY_MATRIX  
7b2a			  
7b2a			; test function to display hardware view of matrix state  
7b2a			  
7b2a			matrixold:  
7b2a			  
7b2a			  
7b2a			  
7b2a			; reset counter  
7b2a 3e 80		ld a, 128  
7b2c d3 c1		out (portbdata),a  
7b2e			; scan keyboard row 1  
7b2e 3e 00		ld a, 0  
7b30 d3 c1		out (portbdata),a  
7b32			;ld a, 64  
7b32			;out (portbdata),a  
7b32 3e 80			ld a, 128  
7b34 21 f2 fe			ld hl, keyscan_table_row1  
7b37 cd 90 7b			call .rowscan  
7b3a			  
7b3a			;ld a, 0  
7b3a			;out (portbdata),a  
7b3a 3e 40		ld a, 64  
7b3c d3 c1		out (portbdata),a  
7b3e 3e 40			ld a, 64  
7b40 21 e7 fe			ld hl, keyscan_table_row2  
7b43 cd 90 7b			call .rowscan  
7b46			  
7b46 3e 00		ld a, 0  
7b48 d3 c1		out (portbdata),a  
7b4a			;ld a, 64  
7b4a			;out (portbdata),a  
7b4a 3e 20			ld a, 32  
7b4c 21 dc fe			ld hl, keyscan_table_row3  
7b4f cd 90 7b			call .rowscan  
7b52			  
7b52			;ld a, 0  
7b52			;out (portbdata),a  
7b52 3e 40		ld a, 64  
7b54 d3 c1		out (portbdata),a  
7b56 3e 10			ld a, 16  
7b58 21 d1 fe			ld hl, keyscan_table_row4  
7b5b cd 90 7b			call .rowscan  
7b5e			  
7b5e			; Display text on first line  
7b5e 3e 00		            LD   A, kLCD_Line1  
7b60 cd 98 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b63 11 f2 fe		            LD   DE, keyscan_table_row1  
7b66			            ;LD   DE, MsgHello  
7b66 cd ba 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b69			  
7b69			; Display text on second line  
7b69 3e 28		            LD   A, kLCD_Line2  
7b6b cd 98 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b6e 11 e7 fe		            LD   DE, keyscan_table_row2  
7b71 cd ba 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b74 3e 50		            LD   A, kLCD_Line3  
7b76 cd 98 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b79 11 dc fe		            LD   DE, keyscan_table_row3  
7b7c cd ba 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b7f 3e 78		            LD   A, kLCD_Line4  
7b81 cd 98 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b84 11 d1 fe		            LD   DE, keyscan_table_row4  
7b87 cd ba 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b8a			  
7b8a cd d3 0c			call delay250ms  
7b8d c3 7b 7a			jp matrix  
7b90			  
7b90			; pass de as row display flags  
7b90			.rowscan:   
7b90			;	out (portbdata),a  
7b90 db c1			in a,(portbdata)  
7b92 4f				ld c,a  
7b93				; reset flags for the row   
7b93 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7b95 e6 01			and 1  
7b97 28 02			jr z, .p1on  
7b99 06 23			ld b,'#'  
7b9b			.p1on:  
7b9b 70				ld (hl), b  
7b9c 23				inc hl  
7b9d			  
7b9d 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7b9f 79				ld a,c  
7ba0 e6 02			and 2  
7ba2			;	bit 0,a  
7ba2 28 02			jr z, .p2on  
7ba4 06 23			ld b,'#'  
7ba6			.p2on:  
7ba6 70				ld (hl), b  
7ba7 23				inc hl  
7ba8			;  
7ba8 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7baa 79				ld a,c  
7bab e6 04			and 4  
7bad			;;	bit 0,a  
7bad 28 02			jr z, .p3on  
7baf 06 23			ld b,'#'  
7bb1			.p3on:  
7bb1 70				ld (hl), b  
7bb2 23				inc hl  
7bb3			;;  
7bb3 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7bb5			;;	bit 0,a  
7bb5 79				ld a,c  
7bb6 e6 08			and 8  
7bb8 28 02			jr z, .p4on  
7bba 06 23			ld b,'#'  
7bbc			.p4on:  
7bbc 70				ld (hl), b  
7bbd 23				inc hl  
7bbe			  
7bbe 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7bc0			;;	bit 0,a  
7bc0 79				ld a,c  
7bc1 e6 10			and 16  
7bc3 28 02			jr z, .p5on  
7bc5 06 23			ld b,'#'  
7bc7			.p5on:  
7bc7 70				ld (hl), b  
7bc8 23				inc hl  
7bc9			; zero term  
7bc9 06 00			ld b,0  
7bcb 70				ld (hl), b  
7bcc			  
7bcc c9			.rscandone: ret  
7bcd			  
7bcd			;addatohl:  
7bcd			;  
7bcd			 ;add   a, l    ; A = A+L  
7bcd			  ;  ld    l, a    ; L = A+L  
7bcd			   ; adc   a, h    ; A = A+L+H+carry  
7bcd			   ; sub   l       ; A = H+carry  
7bcd			   ; ld    h, a    ; H = H+carry  
7bcd			  
7bcd			;ret  
7bcd			; eof  
# End of file firmware_key_5x10.asm
7bcd			;include "firmware_key_4x10.asm" 
7bcd			 
7bcd			heap_size:    equ heap_end - heap_start 
7bcd			;eof 
# End of file os_mega.asm
7bcd
