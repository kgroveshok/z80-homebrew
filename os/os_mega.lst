# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 c9 1c			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 1  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c			;	call break_point_state  
001c			; now use the break point debug vector  
001c				call debug_vector  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_vector:  equ hardware_word - 3   ; vector to the debug handler  
001c			  
001c			debug_mark: equ debug_vector - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_active-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
001c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
001c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
001c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
001c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			;os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_new_exec_ptr - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c			;	ld a, ' ' 
001c			;	ld (os_view_disable), a 
001c				call bp_on 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 10 fd				ld hl, display_fb1  
001f 22 cc fb				ld (display_fb_active), hl  
0022			  
0022 cd 52 0d				call clear_display  
0025			  
0025 21 ce fb				ld hl, display_fb2  
0028 22 cc fb				ld (display_fb_active), hl  
002b			  
002b cd 52 0d				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 b1 fd				ld hl, display_fb0  
0031 22 cc fb				ld (display_fb_active), hl  
0034			  
0034 cd 52 0d				call clear_display  
0037			  
0037			  
0037 cd 2a 75				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd c1 77			call key_init  
003d cd fe 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd 29 14				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043 cd e6 15				call sound_init  
0046				endif  
0046			  
0046				; lcd test sequence  
0046					  
0046 cd 75 0d			call update_display  
0049 cd 95 0c			call delay1s  
004c 3e 2b			ld a,'+'  
004e cd 57 0d			call fill_display  
0051 cd 75 0d			call update_display  
0054 cd 95 0c			call delay1s  
0057 3e 2a			ld a,'*'  
0059 cd 57 0d			call fill_display  
005c cd 75 0d			call update_display  
005f cd 95 0c			call delay1s  
0062 3e 2d			ld a,'-'  
0064 cd 57 0d			call fill_display  
0067 cd 75 0d			call update_display  
006a cd 95 0c			call delay1s  
006d			  
006d			; boot splash screen  
006d			if display_cols == 20	  
006d			        ld a, display_row_1    
006d			else  
006d 3e 0a		        ld a, display_row_1 +10   
006f			endif  
006f 11 cd 1b			ld de, prom_bootmsg  
0072 cd 65 0d			call str_at_display  
0075 cd 75 0d			call update_display  
0078			  
0078			  
0078 cd 95 0c			call delay1s  
007b cd 95 0c			call delay1s  
007e			if display_cols == 20	  
007e			            LD   A, display_row_3+2  
007e			else  
007e 3e 5c		            LD   A, display_row_3+12  
0080			endif  
0080 11 e2 1b			ld de, prom_bootmsg1  
0083 cd 65 0d			call str_at_display  
0086 cd 75 0d			call update_display  
0089 cd 95 0c			call delay1s  
008c cd 95 0c			call delay1s  
008f			  
008f			;	ld a, display_row_4+3  
008f			;	ld de, bootmsg2  
008f			;	call str_at_display  
008f			;	call update_display  
008f			;	call delay1s  
008f			;	call delay1s  
008f			  
008f			; debug mark setup  
008f			  
008f 3e 5f		ld a, '_'  
0091 32 6b fe		ld (debug_mark),a  
0094 32 6c fe		ld (debug_mark+1),a  
0097 32 6d fe		ld (debug_mark+2),a  
009a 3e 00		ld a,0  
009c 32 6e fe		ld (debug_mark+3),a  
009f			  
009f c9					ret  
00a0			  
00a0			  
00a0			;bootmsg2:	db "Firmware v0.1",0  
00a0			  
00a0			; a 4x20 lcd  
00a0			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00a0			  
00a0			;if display_cols == 20  
00a0			;	include "firmware_lcd_4x20.asm"  
00a0			;endif  
00a0			  
00a0			;if display_cols == 40  
00a0			;	include "firmware_lcd_4x40.asm"  
00a0			;endif  
00a0			  
00a0			;  
00a0			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00a0			; TODO abstract the bit bang video out interface for dual display  
00a0			; TODO wire video out to tx pin on rc2014 bus  
00a0			  
00a0			; must supply cin, and cin_wait for low level hardware abstraction   
00a0			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00a0			; test scancode  
00a0			  
00a0			;;;;;  
00a0			;;;  
00a0			; Moved out to mini and maxi versions  
00a0			;  
00a0			; include "firmware_key_4x4.asm"  
00a0			; using existing 4 wire x 4 resistor array for input  
00a0			;include "firmware_key_4x10.asm"  
00a0			; need to mod the board for 5 rows due to resistor array  
00a0			;include "firmware_key_5x10.asm"  
00a0			  
00a0			; storage hardware interface  
00a0			  
00a0			; use microchip serial eeprom for storage  
00a0			  
00a0			  
00a0			if STORAGE_SE  
00a0				include "firmware_spi.asm"  
00a0			; my spi protocol (used by storage) 
00a0			 
00a0			; SPI pins 
00a0			 
00a0			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00a0			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00a0			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00a0			 
00a0			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00a0			; chip pin 4 gnd 
00a0			 
00a0			 
00a0			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00a0			SPI_CE1: equ 1      ;    port a1 pin 14  
00a0			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00a0			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00a0			SPI_CE4: equ 4      ; port a4     pin 10 
00a0			 
00a0			; active low AND masks 
00a0			 
00a0			;SPI_CE0_MASK: equ    255-1 
00a0			;SPI_CE1_MASK: equ   255-2 
00a0			;SPI_CE2_MASK: equ   255-4 
00a0			;SPI_CE3_MASK: equ   255-8 
00a0			;SPI_CE4_MASK: equ   255-16 
00a0			SPI_CE_HIGH:  equ 255 
00a0			 
00a0			 
00a0			 
00a0			;  Perform SCLK wait pulse 
00a0			 
00a0			spi_clk: 
00a0 f5				push af 
00a1 3a 64 fa			ld a, (spi_clktime) 
00a4 fe 00			cp 0 
00a6 28 03			jr z, .scskip 
00a8 cd 7a 0c			call aDelayInMS 
00ab			.scskip: 
00ab f1				pop af 
00ac c9				ret 
00ad			 
00ad			 
00ad			 
00ad			; TODO store port id for spi device ie dev c 
00ad			; TODO store pin for SO 
00ad			; TODO store pin for SI 
00ad			; TODO store pin for SCLK 
00ad			 
00ad			; 
00ad			 
00ad			; ensure that spi bus is in a stable state with default pins  
00ad			 
00ad			se_stable_spi:   
00ad			 
00ad				 ; set DI high, CE high , SCLK low 
00ad				;ld a, SPI_DI | SPI_CE0 
00ad 3e 07			ld a, SPI_DI  
00af cd b9 01			call spi_ce_high 
00b2 d3 80			 out (storage_adata),a 
00b4 32 61 fa			ld (spi_portbyte),a 
00b7			 
00b7				if DEBUG_SPI 
00b7					push hl 
00b7					ld l, a 
00b7					DMARK "SPI" 
00b7					CALLMONITOR 
00b7					pop hl 
00b7				endif 
00b7 c9				ret 
00b8			 
00b8			; byte to send in a 
00b8			 
00b8			spi_send_byte: 
00b8				; save byte to send for bit mask shift out 
00b8 4f			        ld c,a 
00b9 3a 61 fa			ld a,(spi_portbyte) 
00bc				  
00bc				; clock out	each bit of the byte msb first 
00bc			 
00bc 06 08			ld b, 8 
00be			.ssb1: 
00be				; clear so bit  
00be cb bf			res SPI_DI, a 
00c0 cb 11			rl c 
00c2				; if bit 7 is set then carry is set 
00c2 30 02			jr nc, .ssb2 
00c4 cb ff			set SPI_DI,a 
00c6			.ssb2:  ; output bit to ensure it is stable 
00c6 d3 80			out (storage_adata),a 
00c8 00				nop 
00c9				; clock bit high 
00c9 cb ef			set SPI_SCLK,a 
00cb d3 80			out (storage_adata),a 
00cd 00				nop 
00ce cd a0 00			call spi_clk 
00d1				; then low 
00d1 cb af			res SPI_SCLK,a 
00d3 d3 80			out (storage_adata),a 
00d5 00				nop 
00d6 cd a0 00			call spi_clk 
00d9 10 e3			djnz .ssb1 
00db			 
00db 32 61 fa			ld (spi_portbyte),a 
00de c9				ret 
00df			 
00df			; TODO low level get byte into A on spi 
00df			 
00df			spi_read_byte:  
00df			 
00df				; save byte to send for bit mask shift out 
00df 0e 00		    ld c,0 
00e1 3a 61 fa			ld a,(spi_portbyte) 
00e4				  
00e4				; clock out	each bit of the byte msb first 
00e4			 
00e4			 
00e4				; clock bit high 
00e4 cb ef			set SPI_SCLK,a 
00e6 d3 80			out (storage_adata),a 
00e8 00				nop 
00e9 cd a0 00			call spi_clk 
00ec			 
00ec			    ; read DO  
00ec			 
00ec cb f9		    set 7,c 
00ee db 80			in a,(storage_adata) 
00f0 cb 77		    bit SPI_DO,a 
00f2 20 02		    jr nz, .b7 
00f4 cb b9		    res 7,c 
00f6			.b7: 
00f6				; then low 
00f6 cb af			res SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb cd a0 00			call spi_clk 
00fe			     
00fe			 
00fe				; clock bit high 
00fe cb ef			set SPI_SCLK,a 
0100 d3 80			out (storage_adata),a 
0102 00				nop 
0103 cd a0 00			call spi_clk 
0106			 
0106			    ; read DO  
0106			 
0106 cb f1		    set 6,c 
0108 db 80			in a,(storage_adata) 
010a cb 77		    bit SPI_DO,a 
010c 20 02		    jr nz, .b6 
010e cb b1		    res 6,c 
0110			.b6: 
0110				; then low 
0110 cb af			res SPI_SCLK,a 
0112 d3 80			out (storage_adata),a 
0114 00				nop 
0115 cd a0 00			call spi_clk 
0118			 
0118				; clock bit high 
0118 cb ef			set SPI_SCLK,a 
011a d3 80			out (storage_adata),a 
011c 00				nop 
011d cd a0 00			call spi_clk 
0120			 
0120			 
0120			    ; read DO  
0120			 
0120 cb e9		    set 5,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b5 
0128 cb a9		    res 5,c 
012a			.b5: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f cd a0 00			call spi_clk 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137 cd a0 00			call spi_clk 
013a			 
013a			    ; read DO  
013a			 
013a cb e1		    set 4,c 
013c db 80			in a,(storage_adata) 
013e cb 77		    bit SPI_DO,a 
0140 20 02		    jr nz, .b4 
0142 cb a1		    res 4,c 
0144			.b4: 
0144				; then low 
0144 cb af			res SPI_SCLK,a 
0146 d3 80			out (storage_adata),a 
0148 00				nop 
0149 cd a0 00			call spi_clk 
014c				; clock bit high 
014c cb ef			set SPI_SCLK,a 
014e d3 80			out (storage_adata),a 
0150 00				nop 
0151 cd a0 00			call spi_clk 
0154			 
0154			    ; read DO  
0154			 
0154 cb d9		    set 3,c 
0156 db 80			in a,(storage_adata) 
0158 cb 77		    bit SPI_DO,a 
015a 20 02		    jr nz, .b3 
015c cb 99		    res 3,c 
015e			.b3: 
015e				; then low 
015e cb af			res SPI_SCLK,a 
0160 d3 80			out (storage_adata),a 
0162 00				nop 
0163 cd a0 00			call spi_clk 
0166				; clock bit high 
0166 cb ef			set SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b cd a0 00			call spi_clk 
016e			 
016e			    ; read DO  
016e			 
016e cb d1		    set 2,c 
0170 db 80			in a,(storage_adata) 
0172 cb 77		    bit SPI_DO,a 
0174 20 02		    jr nz, .b2 
0176 cb 91		    res 2,c 
0178			.b2: 
0178				; then low 
0178 cb af			res SPI_SCLK,a 
017a d3 80			out (storage_adata),a 
017c 00				nop 
017d cd a0 00			call spi_clk 
0180				; clock bit high 
0180 cb ef			set SPI_SCLK,a 
0182 d3 80			out (storage_adata),a 
0184 00				nop 
0185 cd a0 00			call spi_clk 
0188			 
0188			    ; read DO  
0188			 
0188 cb c9		    set 1,c 
018a db 80			in a,(storage_adata) 
018c cb 77		    bit SPI_DO,a 
018e 20 02		    jr nz, .b1 
0190 cb 89		    res 1,c 
0192			.b1: 
0192				; then low 
0192 cb af			res SPI_SCLK,a 
0194 d3 80			out (storage_adata),a 
0196 00				nop 
0197 cd a0 00			call spi_clk 
019a				; clock bit high 
019a cb ef			set SPI_SCLK,a 
019c d3 80			out (storage_adata),a 
019e 00				nop 
019f cd a0 00			call spi_clk 
01a2			 
01a2			    ; read DO  
01a2			 
01a2 cb c1		    set 0,c 
01a4 db 80			in a,(storage_adata) 
01a6 cb 77		    bit SPI_DO,a 
01a8 20 02		    jr nz, .b0 
01aa cb 81		    res 0,c 
01ac			.b0: 
01ac				; then low 
01ac cb af			res SPI_SCLK,a 
01ae d3 80			out (storage_adata),a 
01b0 00				nop 
01b1 cd a0 00			call spi_clk 
01b4			 
01b4			 
01b4 32 61 fa			ld (spi_portbyte),a 
01b7			 
01b7			    ; return byte 
01b7 79			    ld a,c 
01b8			 
01b8			 
01b8 c9				ret 
01b9			 
01b9			 
01b9			 
01b9			spi_ce_high: 
01b9			 
01b9				if DEBUG_SPI_HARD_CE0 
01b9			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01b9					ret 
01b9			 
01b9				endif 
01b9			 
01b9			 
01b9 f5				push af 
01ba			 
01ba				; send direct ce to port b 
01ba 3e ff			ld a, 255 
01bc d3 81			out (storage_bdata), a 
01be			 
01be f1				pop af 
01bf			 
01bf				; for port a that shares with spi lines AND the mask 
01bf			  
01bf				if DEBUG_SPI 
01bf					push hl 
01bf					ld h, a 
01bf				endif 
01bf			;	ld c, SPI_CE_HIGH 
01bf			;	and c 
01bf cb c7			set SPI_CE0, a 
01c1 cb cf			set SPI_CE1, a 
01c3 cb d7			set SPI_CE2, a 
01c5 cb df			set SPI_CE3, a 
01c7 cb e7			set SPI_CE4, a 
01c9			 
01c9				if DEBUG_SPI 
01c9					ld l, a 
01c9					DMARK "CEh" 
01c9					CALLMONITOR 
01c9					pop hl 
01c9				endif 
01c9 c9				ret 
01ca			 
01ca			 
01ca			spi_ce_low: 
01ca			 
01ca				if DEBUG_SPI_HARD_CE0 
01ca			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ca					ret 
01ca			 
01ca				endif 
01ca			 
01ca c5				push bc 
01cb f5				push af 
01cc			 
01cc				; send direct ce to port b 
01cc 3a 63 fa			ld a, (spi_cartdev) 
01cf d3 81			out (storage_bdata), a 
01d1			 
01d1			 
01d1			 
01d1				; for port a that shares with spi lines AND the mask 
01d1			 
01d1 3a 60 fa			ld a, (spi_device)  
01d4 4f				ld c, a 
01d5			 
01d5 f1				pop af 
01d6			 
01d6				; detect CEx 
01d6			 
01d6				if DEBUG_SPI 
01d6					push hl 
01d6					ld h, a 
01d6				endif 
01d6			 
01d6 cb 41			bit SPI_CE0, c 
01d8 20 04			jr nz, .cel1 
01da cb 87			res SPI_CE0, a 
01dc 18 1e			jr .celn 
01de			.cel1: 
01de cb 49			bit SPI_CE1, c 
01e0 20 04			jr nz, .cel2 
01e2 cb 8f			res SPI_CE1, a 
01e4 18 16			jr .celn 
01e6			.cel2: 
01e6 cb 51			bit SPI_CE2, c 
01e8 20 04			jr nz, .cel3 
01ea cb 97			res SPI_CE2, a 
01ec 18 0e			jr .celn 
01ee			.cel3: 
01ee cb 59			bit SPI_CE3, c 
01f0 20 04			jr nz, .cel4 
01f2 cb 9f			res SPI_CE3, a 
01f4 18 06			jr .celn 
01f6			.cel4: 
01f6 cb 61			bit SPI_CE4, c 
01f8 20 02			jr nz, .celn 
01fa cb a7			res SPI_CE4, a 
01fc			.celn: 
01fc			 
01fc			 
01fc			 
01fc			;	add c 
01fc			 
01fc				if DEBUG_SPI 
01fc					ld l, a 
01fc					DMARK "CEl" 
01fc					CALLMONITOR 
01fc					pop hl 
01fc				endif 
01fc c1				pop bc 
01fd c9				ret 
01fe			 
01fe			 
01fe			 
01fe			; eof 
01fe			 
01fe			 
01fe			 
01fe			 
01fe			 
# End of file firmware_spi.asm
01fe				include "firmware_seeprom.asm"  
01fe			; 
01fe			; persisent storage interface via microchip serial eeprom 
01fe			 
01fe			; port a pio 2 
01fe			; pa 7 - si 
01fe			; pa 6 - sclk  
01fe			; pa 5 - so 
01fe			; pa 4 - cs 
01fe			; pa 3 - cs 
01fe			; pa 2 - cs 
01fe			; pa 1 - cs 
01fe			; pa 0 - cs 
01fe			; 
01fe			; TODO get block 
01fe			; TODO save block 
01fe			; TODO load file 
01fe			; TODO save file 
01fe			; TODO get dir  
01fe			 
01fe			;  
01fe			storage_adata: equ Device_C    ; device c port a - onboard storage 
01fe			storage_actl: equ Device_C+2     ; device c port a 
01fe			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01fe			storage_bctl: equ Device_C+3     ; device c port b 
01fe			 
01fe			 
01fe			; TODO move these to hardware driver file 
01fe			 
01fe			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01fe			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01fe			; storage bank file system format 
01fe			; 
01fe			; first page of bank: 
01fe			; 	addr 0 - status check 
01fe			;       addr 1 - write protect flag 
01fe			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01fe			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01fe			;         TODO see if scanning whole of for available next file id is fast enough 
01fe			;	addr 4 > zero term string of bank label 
01fe			; 
01fe			;        
01fe			;  
01fe			; first page of any file: 
01fe			;      byte 0 - file id  
01fe			;      byte 1-17 - fixed file name  
01fe			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01fe			; 
01fe			; other pages of any file: 
01fe			;      byte 0 - file id 
01fe			;      byte 1> - file data 
01fe			; 
01fe			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01fe			;  
01fe			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01fe			 
01fe			 
01fe			;storage_so_bit: 5 
01fe			;storage_si_bit: 7 
01fe			;storage_sclk_bit: 6 
01fe			  
01fe			 
01fe			; init storage pio 
01fe			 
01fe			storage_init: 
01fe			 
01fe			 
01fe					; set default SPI clk pulse time as disabled 
01fe			 
01fe 3e 00				ld a, 0 
0200 32 64 fa				ld (spi_clktime), a 
0203			 
0203					; init hardware 
0203			 
0203 3e cf		            LD   A, 11001111b 
0205 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0207 3e 00		            LD   A, 00000000b 
0209 cb f7			set SPI_DO,a 
020b			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
020b d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
020d			 
020d 3e cf		            LD   A, 11001111b 
020f d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0211 3e 00		            LD   A, 00000000b 
0213 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
0215			 
0215				; set all external spi devices off  
0215 3e ff			ld a, 255 
0217 32 60 fa			ld (spi_device), a 
021a 32 63 fa			ld (spi_cartdev), a 
021d			 
021d					; ensure the spi bus is in a default stable state 
021d cd ad 00				call se_stable_spi 
0220			 
0220			; TODO scan spi bus and gather which storage banks are present 
0220			 
0220			; populate store_bank_active  
0220			; for each ce line activate and attempt to write first byte of bank and read back 
0220			; if zero is returned then bank is empty 
0220			;   
0220			; 
0220			 
0220					; init file extent cache to save on slow reads 
0220			 
0220			;	ld hl, store_filecache 
0220			;	ld de, 0 
0220			;	ld hl,(de)	 
0220			 
0220			 
0220 c9			    ret 
0221			 
0221			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0221			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0221			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0221			 
0221			; INSTRUCTION SET 
0221			; READ 0000 0011 Read data from memory array beginning at selected address 
0221			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0221			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0221			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0221			; RDSR 0000 0101 Read STATUS register 
0221			; WRSR 0000 0001 Write STATUS register 
0221			; PE 0100 0010 Page Erase – erase one page in memory array 
0221			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0221			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0221			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0221			 
0221			; TODO send byte steam for page without setting the address for every single byte 
0221			; TODO read byte  
0221			 
0221			; byte in a 
0221			; address in hl  
0221			se_writebyte: 
0221			        
0221			    ;   ld c, a 
0221 f5			        push af 
0222 e5			        push hl 
0223			 
0223			    ; initi write mode 
0223			    ; 
0223			    ;CS low 
0223			 
0223 3a 61 fa		       ld a,(spi_portbyte) 
0226 cd ca 01			call spi_ce_low 
0229			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0229 d3 80		       out (storage_adata),a 
022b 32 61 fa		       ld (spi_portbyte), a 
022e			 
022e			    ;clock out wren instruction 
022e			 
022e 3e 06		    ld a, store_wren_ins 
0230 cd b8 00		    call spi_send_byte  
0233			 
0233			    ;cs high to enable write latch 
0233			 
0233 3a 61 fa		       ld a,(spi_portbyte) 
0236 cd b9 01			call spi_ce_high 
0239			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0239 d3 80		       out (storage_adata),a 
023b 32 61 fa		       ld (spi_portbyte), a 
023e			 
023e 00				nop 
023f			    ; 
023f			    ; intial write data 
023f			    ; 
023f			    ; cs low 
023f			     
023f 3a 61 fa		       ld a,(spi_portbyte) 
0242 cd ca 01			call spi_ce_low 
0245			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0245 d3 80		       out (storage_adata),a 
0247 32 61 fa		       ld (spi_portbyte), a 
024a			 
024a			    ; clock out write instruction 
024a			     
024a 3e 02		    ld a, store_write_ins  
024c cd b8 00		    call spi_send_byte  
024f			 
024f			    ; clock out address (depending on address size) 
024f			     
024f e1			    pop hl 
0250 7c			    ld a,h    ; address out msb first 
0251 cd b8 00		    call spi_send_byte  
0254 7d			    ld a,l 
0255 cd b8 00		    call spi_send_byte  
0258			 
0258			    ; clock out byte(s) for page 
0258			 
0258 f1			    pop af 
0259 cd b8 00		    call spi_send_byte  
025c			 
025c			    ; end write with ce high 
025c 3a 61 fa		       ld a,(spi_portbyte) 
025f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
025f cd b9 01			call spi_ce_high 
0262 d3 80		       out (storage_adata),a 
0264 32 61 fa		       ld (spi_portbyte), a 
0267			 
0267				; pause for internal write cycle 
0267 3e 0a			ld a, 10 
0269 cd 7a 0c			call aDelayInMS 
026c c9			    ret 
026d			 
026d			; buffer to write in de 
026d			; address in hl  
026d			se_writepage: 
026d			        
026d			    ;   ld c, a 
026d d5				push de 
026e e5			        push hl 
026f			 
026f			    ; initi write mode 
026f			    ; 
026f			    ;CS low 
026f			 
026f 3a 61 fa		       ld a,(spi_portbyte) 
0272 cd ca 01			call spi_ce_low 
0275			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0275 d3 80		       out (storage_adata),a 
0277 32 61 fa		       ld (spi_portbyte), a 
027a			 
027a			    ;clock out wren instruction 
027a			 
027a 3e 06		    ld a, store_wren_ins 
027c cd b8 00		    call spi_send_byte  
027f			 
027f			    ;cs high to enable write latch 
027f			 
027f 3a 61 fa		       ld a,(spi_portbyte) 
0282 cd b9 01			call spi_ce_high 
0285			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0285 d3 80		       out (storage_adata),a 
0287 32 61 fa		       ld (spi_portbyte), a 
028a			 
028a 00				nop 
028b			    ; 
028b			    ; intial write data 
028b			    ; 
028b			    ; cs low 
028b			     
028b 3a 61 fa		       ld a,(spi_portbyte) 
028e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028e cd ca 01			call spi_ce_low 
0291 d3 80		       out (storage_adata),a 
0293 32 61 fa		       ld (spi_portbyte), a 
0296			 
0296			    ; clock out write instruction 
0296			     
0296 3e 02		    ld a, store_write_ins  
0298 cd b8 00		    call spi_send_byte  
029b			 
029b			    ; clock out address (depending on address size) 
029b			     
029b e1			    pop hl 
029c 7c			    ld a,h    ; address out msb first 
029d cd b8 00		    call spi_send_byte  
02a0 7d			    ld a,l 
02a1 cd b8 00		    call spi_send_byte  
02a4			 
02a4			    ; clock out byte(s) for page 
02a4			 
02a4 e1				pop hl 
02a5 06 40			ld b, STORE_BLOCK_PHY 
02a7			.bytewrite: 
02a7			 
02a7 7e				ld a,(hl) 
02a8 e5			    push hl 
02a9 c5				push bc 
02aa cd b8 00		    call spi_send_byte  
02ad c1				pop bc 
02ae e1				pop hl 
02af			 
02af			    ; end write with ce high 
02af 3a 61 fa		       ld a,(spi_portbyte) 
02b2 cd b9 01			call spi_ce_high 
02b5			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b5 d3 80		       out (storage_adata),a 
02b7 32 61 fa		       ld (spi_portbyte), a 
02ba			 
02ba 23				inc hl 
02bb 10 ea			djnz .bytewrite 
02bd			 
02bd				; pause for internal write cycle 
02bd 3e 64			ld a, 100 
02bf cd 7a 0c			call aDelayInMS 
02c2 c9			    ret 
02c3			; returns byte in a 
02c3			; address in hl  
02c3			se_readbyte: 
02c3 d5				push de 
02c4 c5				push bc 
02c5			 
02c5			    ;   ld c, a 
02c5 e5			        push hl 
02c6			 
02c6			    ; initi write mode 
02c6			    ; 
02c6			    ;CS low 
02c6			 
02c6 3a 61 fa		       ld a,(spi_portbyte) 
02c9 cd ca 01			call spi_ce_low 
02cc			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cc d3 80		       out (storage_adata),a 
02ce 32 61 fa		       ld (spi_portbyte), a 
02d1			 
02d1			    ;clock out wren instruction 
02d1			 
02d1 3e 03		    ld a, store_read_ins 
02d3 cd b8 00		    call spi_send_byte  
02d6			 
02d6			 
02d6			    ; clock out address (depending on address size) 
02d6			     
02d6 e1			    pop hl 
02d7 7c			    ld a,h    ; address out msb first 
02d8 cd b8 00		    call spi_send_byte  
02db 7d			    ld a,l 
02dc cd b8 00		    call spi_send_byte  
02df			 
02df			    ; clock in byte(s) for page 
02df			 
02df cd df 00		    call spi_read_byte  
02e2 f5				push af 
02e3			 
02e3			    ; end write with ce high 
02e3 3a 61 fa		       ld a,(spi_portbyte) 
02e6			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02e6 cd b9 01			call spi_ce_high 
02e9 d3 80		       out (storage_adata),a 
02eb 32 61 fa		       ld (spi_portbyte), a 
02ee			 
02ee f1				pop af 
02ef			 
02ef c1				pop bc 
02f0 d1				pop de 
02f1			 
02f1 c9			    ret 
02f2			 
02f2			if DEBUG_STORESE 
02f2			 
02f2			storageput:  
02f2			 
02f2			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02f2			 
02f2 21 c3 f1			ld hl,scratch+2 
02f5 cd 3d 13			call get_word_hl 
02f8			 
02f8				; stuff it here for the moment as it will be overwritten later anyway 
02f8			 
02f8 22 e4 f4			ld (os_cur_ptr),hl	 
02fb			 
02fb			 
02fb			; get pointer to start of string 
02fb			 
02fb 21 c8 f1			ld hl, scratch+7 
02fe			 
02fe			; loop writing char of string to eeprom 
02fe			 
02fe 7e			.writestr:	ld a,(hl) 
02ff fe 00				cp 0 
0301 28 12				jr z, .wsdone		; done writing 
0303 e5					push hl 
0304 2a e4 f4				ld hl,(os_cur_ptr) 
0307 cd 21 02				call se_writebyte 
030a			 
030a 2a e4 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
030d 23					inc hl 
030e 22 e4 f4				ld (os_cur_ptr),hl 
0311			 
0311					; restore string pointer and get next char 
0311			 
0311 e1					pop hl 
0312 23					inc hl 
0313 18 e9				jr .writestr 
0315			 
0315			 
0315			 
0315			.wsdone: 
0315			 
0315			 
0315			; when done load first page into a buffer  
0315			 
0315 21 00 80				ld hl,08000h		; start in ram 
0318 22 e4 f4				ld (os_cur_ptr),hl 
031b 21 00 00				ld hl, 0		 ; start of page 
031e 22 e9 f1				ld (scratch+40),hl	; hang on to it 
0321			 
0321 06 80				ld b, 128		; actually get more then one page 
0323 c5			.wsload:	push bc 
0324 2a e9 f1				ld hl,(scratch+40) 
0327 e5					push hl 
0328 cd c3 02				call se_readbyte 
032b			 
032b					; a now as the byte 
032b			 
032b 2a e4 f4				ld hl,(os_cur_ptr) 
032e 77					ld (hl),a 
032f					; inc next buffer area 
032f 23					inc hl 
0330 22 e4 f4				ld (os_cur_ptr),hl 
0333			 
0333					; get eeprom position, inc and save for next round 
0333 e1					pop hl		 
0334 23					inc hl 
0335 22 e9 f1				ld (scratch+40),hl 
0338 c1					pop bc 
0339 10 e8				djnz .wsload 
033b			 
033b			; set 'd' pointer to start of buffer 
033b			 
033b 21 00 80				ld hl,08000h 
033e 22 e4 f4				ld (os_cur_ptr),hl 
0341			 
0341			 
0341 c9			ret 
0342			 
0342			 
0342 c9			storageread: ret 
0343			 
0343			 
0343			 
0343			 
0343			 
0343			 
0343			endif 
0343			 
0343			 
0343			 
# End of file firmware_seeprom.asm
0343			else  
0343			   ; create some stubs for the labels  
0343			se_readbyte: ret  
0343			se_writebyte: ret  
0343			storage_init: ret  
0343			  
0343			endif  
0343			  
0343			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0343			;include "firmware_cf.asm"  
0343			  
0343			; load up high level storage hardward abstractions  
0343			include "firmware_storage.asm"  
0343			 
0343			; persisent storage hardware abstraction layer  
0343			 
0343			 
0343			 
0343			; Block 0 on storage is a config state 
0343			 
0343			 
0343			 
0343			; TODO add read phy block and write phy block functions 
0343			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0343			 
0343			; Abstraction layer  
0343			 
0343			; Logocial block size is same size as physical size - using tape concept 
0343			 
0343			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0343			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0343			 
0343			 
0343			 
0343			; Filesystem layout (Logical layout) 
0343			; 
0343			; Block 0 - Bank config  
0343			; 
0343			;      Byte - 0 file id counter 
0343			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0343			;      Byte - 3-20 zero terminated bank label 
0343			; 
0343			; Block 1 > File storage 
0343			; 
0343			;      Byte 0 file id    - block 0 file details 
0343			;      Byte 1 block id - block 0 is file  
0343			;            Byte 2-15 - File name 
0343			; 
0343			;       - to end of block data 
0343			; 
0343			 
0343			; Get ID for the file named in pointer held HL 
0343			; Returns ID in HL = 255 if no file found 
0343			 
0343			storage_getid: 
0343			 
0343 22 73 fa			ld (store_tmp1), hl 
0346			 
0346				if DEBUG_STORESE 
0346					DMARK "SGI" 
0346 f5				push af  
0347 3a 5b 03			ld a, (.dmark)  
034a 32 6b fe			ld (debug_mark),a  
034d 3a 5c 03			ld a, (.dmark+1)  
0350 32 6c fe			ld (debug_mark+1),a  
0353 3a 5d 03			ld a, (.dmark+2)  
0356 32 6d fe			ld (debug_mark+2),a  
0359 18 03			jr .pastdmark  
035b ..			.dmark: db "SGI"  
035e f1			.pastdmark: pop af  
035f			endm  
# End of macro DMARK
035f					CALLMONITOR 
035f cd 6f fe			call debug_vector  
0362				endm  
# End of macro CALLMONITOR
0362				endif 
0362				; get block 0 and set counter for number of files to scan 
0362			 
0362 cd cd 04			call storage_get_block_0 
0365			 
0365 3a 7a fa			ld a, (store_page) 
0368 47				ld b, a 
0369			 
0369				; get extent 0 of each file id 
0369			 
0369				if DEBUG_STORESE 
0369					DMARK "SGc" 
0369 f5				push af  
036a 3a 7e 03			ld a, (.dmark)  
036d 32 6b fe			ld (debug_mark),a  
0370 3a 7f 03			ld a, (.dmark+1)  
0373 32 6c fe			ld (debug_mark+1),a  
0376 3a 80 03			ld a, (.dmark+2)  
0379 32 6d fe			ld (debug_mark+2),a  
037c 18 03			jr .pastdmark  
037e ..			.dmark: db "SGc"  
0381 f1			.pastdmark: pop af  
0382			endm  
# End of macro DMARK
0382					CALLMONITOR 
0382 cd 6f fe			call debug_vector  
0385				endm  
# End of macro CALLMONITOR
0385				endif 
0385 60			.getloop:	ld h, b 
0386 2e 00				ld l, 0 
0388 c5					push bc 
0389			 
0389 11 7a fa				ld de, store_page 
038c				if DEBUG_STORESE 
038c					DMARK "SGr" 
038c f5				push af  
038d 3a a1 03			ld a, (.dmark)  
0390 32 6b fe			ld (debug_mark),a  
0393 3a a2 03			ld a, (.dmark+1)  
0396 32 6c fe			ld (debug_mark+1),a  
0399 3a a3 03			ld a, (.dmark+2)  
039c 32 6d fe			ld (debug_mark+2),a  
039f 18 03			jr .pastdmark  
03a1 ..			.dmark: db "SGr"  
03a4 f1			.pastdmark: pop af  
03a5			endm  
# End of macro DMARK
03a5					CALLMONITOR 
03a5 cd 6f fe			call debug_vector  
03a8				endm  
# End of macro CALLMONITOR
03a8				endif 
03a8 cd 75 09				call storage_read 
03ab cd af 0f				call ishlzero 
03ae 28 2d				jr z, .gap 
03b0					 
03b0					; have a file name read. Is it one we want. 
03b0			 
03b0 2a 73 fa				ld hl, (store_tmp1) 
03b3 11 7d fa				ld de, store_page+3   ; file name 
03b6			 
03b6				if DEBUG_STORESE 
03b6					DMARK "SGc" 
03b6 f5				push af  
03b7 3a cb 03			ld a, (.dmark)  
03ba 32 6b fe			ld (debug_mark),a  
03bd 3a cc 03			ld a, (.dmark+1)  
03c0 32 6c fe			ld (debug_mark+1),a  
03c3 3a cd 03			ld a, (.dmark+2)  
03c6 32 6d fe			ld (debug_mark+2),a  
03c9 18 03			jr .pastdmark  
03cb ..			.dmark: db "SGc"  
03ce f1			.pastdmark: pop af  
03cf			endm  
# End of macro DMARK
03cf					CALLMONITOR 
03cf cd 6f fe			call debug_vector  
03d2				endm  
# End of macro CALLMONITOR
03d2				endif 
03d2 cd 1c 14				call strcmp 
03d5 20 06				jr nz, .gap   ; not this one 
03d7			 
03d7 c1				        pop bc 
03d8			 
03d8 26 00				ld h, 0 
03da 68					ld l, b 
03db 18 22				jr .getdone 
03dd						 
03dd			 
03dd			 
03dd			 
03dd			.gap: 
03dd				if DEBUG_STORESE 
03dd					DMARK "SGg" 
03dd f5				push af  
03de 3a f2 03			ld a, (.dmark)  
03e1 32 6b fe			ld (debug_mark),a  
03e4 3a f3 03			ld a, (.dmark+1)  
03e7 32 6c fe			ld (debug_mark+1),a  
03ea 3a f4 03			ld a, (.dmark+2)  
03ed 32 6d fe			ld (debug_mark+2),a  
03f0 18 03			jr .pastdmark  
03f2 ..			.dmark: db "SGg"  
03f5 f1			.pastdmark: pop af  
03f6			endm  
# End of macro DMARK
03f6					CALLMONITOR 
03f6 cd 6f fe			call debug_vector  
03f9				endm  
# End of macro CALLMONITOR
03f9				endif 
03f9			 
03f9 c1					pop bc 
03fa 10 89				djnz .getloop 
03fc 21 ff 00				ld hl, 255 
03ff			.getdone: 
03ff			 
03ff				if DEBUG_STORESE 
03ff					DMARK "SGe" 
03ff f5				push af  
0400 3a 14 04			ld a, (.dmark)  
0403 32 6b fe			ld (debug_mark),a  
0406 3a 15 04			ld a, (.dmark+1)  
0409 32 6c fe			ld (debug_mark+1),a  
040c 3a 16 04			ld a, (.dmark+2)  
040f 32 6d fe			ld (debug_mark+2),a  
0412 18 03			jr .pastdmark  
0414 ..			.dmark: db "SGe"  
0417 f1			.pastdmark: pop af  
0418			endm  
# End of macro DMARK
0418					CALLMONITOR 
0418 cd 6f fe			call debug_vector  
041b				endm  
# End of macro CALLMONITOR
041b				endif 
041b			 
041b c9				ret 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			; Read Block 
041c			; ---------- 
041c			; 
041c			; With current bank 
041c			;  
041c			; Get block number to read 
041c			; Load physical blocks starting at start block into buffer 
041c			 
041c			; de points to buffer to use 
041c			; hl holds logical block number  
041c			 
041c			storage_read_block: 
041c			 
041c				; TODO bank selection 
041c			 
041c				; for each of the physical blocks read it into the buffer 
041c 06 40			ld b, STORE_BLOCK_PHY 
041e			 
041e				if DEBUG_STORESE 
041e d5					push de 
041f				endif 
041f				 
041f			.rl1:    
041f			 
041f				; read physical block at hl into de 
041f			        ; increment hl and de to next read position on exit 
041f			 
041f e5				push hl 
0420 d5				push de	 
0421 c5				push bc 
0422			;	if DEBUG_STORESE 
0422			;		push af 
0422			;		ld a, 'R' 
0422			;		ld (debug_mark),a 
0422			;		pop af 
0422			;		CALLMONITOR 
0422			;	endif 
0422 cd c3 02			call se_readbyte 
0425			;	if DEBUG_STORESE 
0425			;		ld a,(spi_portbyte) 
0425			;		ld l, a 
0425			;		push af 
0425			;		ld a, '1' 
0425			;		ld (debug_mark),a 
0425			;		pop af 
0425			;		CALLMONITOR 
0425			;	endif 
0425 c1				pop bc 
0426 d1				pop de 
0427 e1				pop hl 
0428 12				ld (de),a 
0429 23				inc hl 
042a 13				inc de 
042b			 
042b			;	if DEBUG_STORESE 
042b			;		push af 
042b			;		ld a, 'r' 
042b			;		ld (debug_mark),a 
042b			;		pop af 
042b			;		CALLMONITOR 
042b			;	endif 
042b			 
042b 10 f2			djnz .rl1 
042d			 
042d				if DEBUG_STORESE 
042d					DMARK "SRB" 
042d f5				push af  
042e 3a 42 04			ld a, (.dmark)  
0431 32 6b fe			ld (debug_mark),a  
0434 3a 43 04			ld a, (.dmark+1)  
0437 32 6c fe			ld (debug_mark+1),a  
043a 3a 44 04			ld a, (.dmark+2)  
043d 32 6d fe			ld (debug_mark+2),a  
0440 18 03			jr .pastdmark  
0442 ..			.dmark: db "SRB"  
0445 f1			.pastdmark: pop af  
0446			endm  
# End of macro DMARK
0446 d1					pop de 
0447			; 
0447			;		push af 
0447			;		ld a, 'R' 
0447			;		ld (debug_mark),a 
0447			;		pop af 
0447					CALLMONITOR 
0447 cd 6f fe			call debug_vector  
044a				endm  
# End of macro CALLMONITOR
044a				endif 
044a c9				ret	 
044b				 
044b			 
044b			; File Size 
044b			; --------- 
044b			; 
044b			;   hl file id 
044b			; 
044b			;  returns in hl the number of blocks 
044b			 
044b			storage_file_size: 
044b 5d				ld e, l 
044c 16 00			ld d, 0 
044e 21 40 00			ld hl, STORE_BLOCK_PHY 
0451					if DEBUG_FORTH_WORDS 
0451						DMARK "SIZ" 
0451 f5				push af  
0452 3a 66 04			ld a, (.dmark)  
0455 32 6b fe			ld (debug_mark),a  
0458 3a 67 04			ld a, (.dmark+1)  
045b 32 6c fe			ld (debug_mark+1),a  
045e 3a 68 04			ld a, (.dmark+2)  
0461 32 6d fe			ld (debug_mark+2),a  
0464 18 03			jr .pastdmark  
0466 ..			.dmark: db "SIZ"  
0469 f1			.pastdmark: pop af  
046a			endm  
# End of macro DMARK
046a						CALLMONITOR 
046a cd 6f fe			call debug_vector  
046d				endm  
# End of macro CALLMONITOR
046d					endif 
046d cd 4f 07			call storage_findnextid 
0470			 
0470 cd af 0f			call ishlzero 
0473			;	ld a, l 
0473			;	add h 
0473			;	cp 0 
0473 c8				ret z			; block not found so EOF 
0474			 
0474 11 7a fa			ld de, store_page 
0477 cd 1c 04			call storage_read_block 
047a			 
047a 3a 7c fa			ld a, (store_page+2)	 ; get extent count 
047d 6f				ld l, a 
047e 26 00			ld h, 0 
0480 c9			 	ret 
0481			 
0481			 
0481			; Write Block 
0481			; ----------- 
0481			; 
0481			; With current bank 
0481			;  
0481			; Get block number to write 
0481			; Write physical blocks starting at start block from buffer 
0481			  
0481			storage_write_block: 
0481				; TODO bank selection 
0481			 
0481				; for each of the physical blocks read it into the buffer 
0481 06 40			ld b, STORE_BLOCK_PHY 
0483			 
0483				if DEBUG_STORESE 
0483					DMARK "SWB" 
0483 f5				push af  
0484 3a 98 04			ld a, (.dmark)  
0487 32 6b fe			ld (debug_mark),a  
048a 3a 99 04			ld a, (.dmark+1)  
048d 32 6c fe			ld (debug_mark+1),a  
0490 3a 9a 04			ld a, (.dmark+2)  
0493 32 6d fe			ld (debug_mark+2),a  
0496 18 03			jr .pastdmark  
0498 ..			.dmark: db "SWB"  
049b f1			.pastdmark: pop af  
049c			endm  
# End of macro DMARK
049c			 
049c					;push af 
049c					;ld a, 'W' 
049c					;ld (debug_mark),a 
049c					;pop af 
049c					CALLMONITOR 
049c cd 6f fe			call debug_vector  
049f				endm  
# End of macro CALLMONITOR
049f				endif 
049f			 
049f			; might not be working 
049f			;	call se_writepage 
049f			 
049f			;	ret 
049f			; 
049f			 
049f			 
049f			 
049f			.wl1:    
049f			 
049f				; read physical block at hl into de 
049f			        ; increment hl and de to next read position on exit 
049f			 
049f e5				push hl 
04a0 d5				push de	 
04a1 c5				push bc 
04a2 1a				ld a,(de) 
04a3				;if DEBUG_STORESE 
04a3			;		push af 
04a3			;		ld a, 'W' 
04a3			;		ld (debug_mark),a 
04a3			;		pop af 
04a3			;		CALLMONITOR 
04a3			;	endif 
04a3 cd 21 02			call se_writebyte 
04a6			;	call delay250ms 
04a6 00				nop 
04a7 00				nop 
04a8 00				nop 
04a9			;	if DEBUG_STORESE 
04a9			;		push af 
04a9			;		ld a, 'w' 
04a9			;		ld (debug_mark),a 
04a9			;		pop af 
04a9			;		CALLMONITOR 
04a9			;	endif 
04a9 c1				pop bc 
04aa d1				pop de 
04ab e1				pop hl 
04ac 23				inc hl 
04ad 13				inc de 
04ae			 
04ae			 
04ae 10 ef			djnz .wl1 
04b0			 
04b0				if DEBUG_STORESE 
04b0					DMARK "SW2" 
04b0 f5				push af  
04b1 3a c5 04			ld a, (.dmark)  
04b4 32 6b fe			ld (debug_mark),a  
04b7 3a c6 04			ld a, (.dmark+1)  
04ba 32 6c fe			ld (debug_mark+1),a  
04bd 3a c7 04			ld a, (.dmark+2)  
04c0 32 6d fe			ld (debug_mark+2),a  
04c3 18 03			jr .pastdmark  
04c5 ..			.dmark: db "SW2"  
04c8 f1			.pastdmark: pop af  
04c9			endm  
# End of macro DMARK
04c9			 
04c9					;push af 
04c9					;ld a, 'W' 
04c9					;ld (debug_mark),a 
04c9					;pop af 
04c9					CALLMONITOR 
04c9 cd 6f fe			call debug_vector  
04cc				endm  
# End of macro CALLMONITOR
04cc				endif 
04cc c9				ret	 
04cd			 
04cd			; Init bank 
04cd			; --------- 
04cd			; 
04cd			; With current bank 
04cd			; 
04cd			; Setup block 0 config 
04cd			;     Set 0 file id counter 
04cd			;     Set formatted byte pattern 
04cd			;     Zero out bank label 
04cd			;      
04cd			; For every logical block write 0-1 byte as null 
04cd			 
04cd			storage_get_block_0: 
04cd			 
04cd				; TODO check presence 
04cd			 
04cd				; get block 0 config 
04cd			 
04cd 21 00 00			ld hl, 0 
04d0 11 7a fa			ld de, store_page 
04d3 cd 1c 04			call storage_read_block 
04d6			 
04d6				if DEBUG_STORESE 
04d6					DMARK "SB0" 
04d6 f5				push af  
04d7 3a eb 04			ld a, (.dmark)  
04da 32 6b fe			ld (debug_mark),a  
04dd 3a ec 04			ld a, (.dmark+1)  
04e0 32 6c fe			ld (debug_mark+1),a  
04e3 3a ed 04			ld a, (.dmark+2)  
04e6 32 6d fe			ld (debug_mark+2),a  
04e9 18 03			jr .pastdmark  
04eb ..			.dmark: db "SB0"  
04ee f1			.pastdmark: pop af  
04ef			endm  
# End of macro DMARK
04ef 11 7a fa				ld de, store_page 
04f2			;		push af 
04f2			;		ld a, 'i' 
04f2			;		ld (debug_mark),a 
04f2			;		pop af 
04f2					CALLMONITOR 
04f2 cd 6f fe			call debug_vector  
04f5				endm  
# End of macro CALLMONITOR
04f5				endif 
04f5			 
04f5				; is this area formatted? 
04f5			 
04f5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04f5 2a 7b fa			ld hl, (store_page+1) 
04f8 3e 80			ld a,0x80 
04fa bd				cp l 
04fb 20 22			jr nz, .ininotformatted 
04fd				; do a double check 
04fd 3e 27			ld a, 0x27 
04ff bc				cp h 
0500 20 1d			jr nz, .ininotformatted 
0502			 
0502				; formatted then 
0502			 
0502				if DEBUG_STORESE 
0502					DMARK "SB1" 
0502 f5				push af  
0503 3a 17 05			ld a, (.dmark)  
0506 32 6b fe			ld (debug_mark),a  
0509 3a 18 05			ld a, (.dmark+1)  
050c 32 6c fe			ld (debug_mark+1),a  
050f 3a 19 05			ld a, (.dmark+2)  
0512 32 6d fe			ld (debug_mark+2),a  
0515 18 03			jr .pastdmark  
0517 ..			.dmark: db "SB1"  
051a f1			.pastdmark: pop af  
051b			endm  
# End of macro DMARK
051b					;push af 
051b					;ld a, 'I' 
051b					;ld (debug_mark),a 
051b					;pop af 
051b					CALLMONITOR 
051b cd 6f fe			call debug_vector  
051e				endm  
# End of macro CALLMONITOR
051e				endif 
051e c9				ret 
051f			 
051f			.ininotformatted: 
051f				; bank not formatted so poke various bits to make sure 
051f			 
051f				if DEBUG_STORESE 
051f					DMARK "SB2" 
051f f5				push af  
0520 3a 34 05			ld a, (.dmark)  
0523 32 6b fe			ld (debug_mark),a  
0526 3a 35 05			ld a, (.dmark+1)  
0529 32 6c fe			ld (debug_mark+1),a  
052c 3a 36 05			ld a, (.dmark+2)  
052f 32 6d fe			ld (debug_mark+2),a  
0532 18 03			jr .pastdmark  
0534 ..			.dmark: db "SB2"  
0537 f1			.pastdmark: pop af  
0538			endm  
# End of macro DMARK
0538					;push af 
0538					;ld a, 'f' 
0538					;ld (debug_mark),a 
0538					;pop af 
0538					CALLMONITOR 
0538 cd 6f fe			call debug_vector  
053b				endm  
# End of macro CALLMONITOR
053b				endif 
053b			 
053b cd 58 0c			call storage_clear_page 
053e			 
053e 21 7a fa			ld hl, store_page 
0541 3e 00			ld a, 0 
0543				 
0543 77				ld (hl),a   ; reset file counter 
0544			 
0544 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0547 22 7b fa		 	ld (store_page+1), hl	 
054a			 
054a				; set default label 
054a			 
054a 21 e6 05			ld hl, .defaultbanklabl 
054d 11 7d fa		 	ld de, store_page+3 
0550 01 0f 00			ld bc, 15 
0553 ed b0			ldir 
0555			 
0555				; Append the current bank id 
0555 21 86 fa			ld hl, store_page+3+9 
0558 3a 5f fa			ld a, (spi_device_id) 
055b 77				ld (hl), a 
055c			 
055c				; save default page 0 
055c			 
055c 21 00 00			ld hl, 0 
055f 11 7a fa			ld de, store_page 
0562				if DEBUG_STORESE 
0562					DMARK "SB3" 
0562 f5				push af  
0563 3a 77 05			ld a, (.dmark)  
0566 32 6b fe			ld (debug_mark),a  
0569 3a 78 05			ld a, (.dmark+1)  
056c 32 6c fe			ld (debug_mark+1),a  
056f 3a 79 05			ld a, (.dmark+2)  
0572 32 6d fe			ld (debug_mark+2),a  
0575 18 03			jr .pastdmark  
0577 ..			.dmark: db "SB3"  
057a f1			.pastdmark: pop af  
057b			endm  
# End of macro DMARK
057b			;		push af 
057b			;		ld a, 'F' 
057b			;		ld (debug_mark),a 
057b			;		pop af 
057b					CALLMONITOR 
057b cd 6f fe			call debug_vector  
057e				endm  
# End of macro CALLMONITOR
057e				endif 
057e cd 81 04			call storage_write_block 
0581				if DEBUG_STORESE 
0581					DMARK "SB4" 
0581 f5				push af  
0582 3a 96 05			ld a, (.dmark)  
0585 32 6b fe			ld (debug_mark),a  
0588 3a 97 05			ld a, (.dmark+1)  
058b 32 6c fe			ld (debug_mark+1),a  
058e 3a 98 05			ld a, (.dmark+2)  
0591 32 6d fe			ld (debug_mark+2),a  
0594 18 03			jr .pastdmark  
0596 ..			.dmark: db "SB4"  
0599 f1			.pastdmark: pop af  
059a			endm  
# End of macro DMARK
059a			;		push af 
059a			;		ld a, '>' 
059a			;		ld (debug_mark),a 
059a			;		pop af 
059a					CALLMONITOR 
059a cd 6f fe			call debug_vector  
059d				endm  
# End of macro CALLMONITOR
059d				endif 
059d			 
059d 00				nop 
059e 00				nop 
059f 00				nop 
05a0			 
05a0				; now set 0 in every page to mark as a free block 
05a0			 
05a0 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05a2 21 40 00			ld hl, STORE_BLOCK_PHY 
05a5			 
05a5 3e 00		.setmark1:   	ld a,0 
05a7 e5					push hl 
05a8 c5					push bc 
05a9 cd 21 02				call se_writebyte 
05ac 3e 0a			ld a, 10 
05ae cd 7a 0c			call aDelayInMS 
05b1 23				inc hl 
05b2 cd 21 02				call se_writebyte 
05b5 3e 0a			ld a, 10 
05b7 cd 7a 0c			call aDelayInMS 
05ba 2b				dec hl 
05bb c1					pop bc 
05bc e1					pop hl 
05bd 3e 40				ld a, STORE_BLOCK_PHY 
05bf cd 86 0f				call addatohl 
05c2 10 e1				djnz .setmark1 
05c4			 
05c4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05c6 3e 00		.setmark2:   	ld a,0 
05c8 e5					push hl 
05c9 c5					push bc 
05ca cd 21 02				call se_writebyte 
05cd 3e 0a			ld a, 10 
05cf cd 7a 0c			call aDelayInMS 
05d2 23				inc hl 
05d3 cd 21 02				call se_writebyte 
05d6 3e 0a			ld a, 10 
05d8 cd 7a 0c			call aDelayInMS 
05db 2b				dec hl 
05dc c1					pop bc 
05dd e1					pop hl 
05de 3e 40				ld a, STORE_BLOCK_PHY 
05e0 cd 86 0f				call addatohl 
05e3 10 e1				djnz .setmark2 
05e5			 
05e5					 
05e5			 
05e5			 
05e5 c9				ret 
05e6			 
05e6			 
05e6			 
05e6			 
05e6 .. 00		.defaultbanklabl:   db "BankLabel_",0 
05f1			 
05f1			 
05f1			 
05f1			; Label Bank 
05f1			; ---------- 
05f1			; 
05f1			; With current bank 
05f1			; Read block 0 
05f1			; Set label 
05f1			; Write block 0 
05f1			 
05f1			; label str pointer in hl 
05f1			 
05f1			storage_label:     
05f1			 
05f1				if DEBUG_STORESE 
05f1					DMARK "LBL" 
05f1 f5				push af  
05f2 3a 06 06			ld a, (.dmark)  
05f5 32 6b fe			ld (debug_mark),a  
05f8 3a 07 06			ld a, (.dmark+1)  
05fb 32 6c fe			ld (debug_mark+1),a  
05fe 3a 08 06			ld a, (.dmark+2)  
0601 32 6d fe			ld (debug_mark+2),a  
0604 18 03			jr .pastdmark  
0606 ..			.dmark: db "LBL"  
0609 f1			.pastdmark: pop af  
060a			endm  
# End of macro DMARK
060a					CALLMONITOR 
060a cd 6f fe			call debug_vector  
060d				endm  
# End of macro CALLMONITOR
060d				endif 
060d			 
060d e5				push hl 
060e			 
060e cd cd 04			call storage_get_block_0 
0611			 
0611				; set default label 
0611			 
0611 e1				pop hl 
0612			 
0612 11 7d fa		 	ld de, store_page+3 
0615 01 0f 00			ld bc, 15 
0618				if DEBUG_STORESE 
0618					DMARK "LB3" 
0618 f5				push af  
0619 3a 2d 06			ld a, (.dmark)  
061c 32 6b fe			ld (debug_mark),a  
061f 3a 2e 06			ld a, (.dmark+1)  
0622 32 6c fe			ld (debug_mark+1),a  
0625 3a 2f 06			ld a, (.dmark+2)  
0628 32 6d fe			ld (debug_mark+2),a  
062b 18 03			jr .pastdmark  
062d ..			.dmark: db "LB3"  
0630 f1			.pastdmark: pop af  
0631			endm  
# End of macro DMARK
0631					CALLMONITOR 
0631 cd 6f fe			call debug_vector  
0634				endm  
# End of macro CALLMONITOR
0634				endif 
0634 ed b0			ldir 
0636				; save default page 0 
0636			 
0636 21 00 00			ld hl, 0 
0639 11 7a fa			ld de, store_page 
063c				if DEBUG_STORESE 
063c					DMARK "LBW" 
063c f5				push af  
063d 3a 51 06			ld a, (.dmark)  
0640 32 6b fe			ld (debug_mark),a  
0643 3a 52 06			ld a, (.dmark+1)  
0646 32 6c fe			ld (debug_mark+1),a  
0649 3a 53 06			ld a, (.dmark+2)  
064c 32 6d fe			ld (debug_mark+2),a  
064f 18 03			jr .pastdmark  
0651 ..			.dmark: db "LBW"  
0654 f1			.pastdmark: pop af  
0655			endm  
# End of macro DMARK
0655					CALLMONITOR 
0655 cd 6f fe			call debug_vector  
0658				endm  
# End of macro CALLMONITOR
0658				endif 
0658 cd 81 04			call storage_write_block 
065b			 
065b c9				ret 
065c			 
065c			 
065c			 
065c			; Read Block 0 - Config 
065c			; --------------------- 
065c			; 
065c			; With current bank 
065c			; Call presence test 
065c			;    If not present format/init bank  
065c			; Read block 0  
065c			;  
065c			 
065c			 
065c			; Dir 
065c			; --- 
065c			; 
065c			; With current bank 
065c			; Load Block 0 Config 
065c			; Get max file id number 
065c			; For each logical block 
065c			;    Read block read byte 2 
065c			;      if first block of file 
065c			;         Display file name 
065c			;         Display type flags for file 
065c			;        
065c			 
065c			; moving to words as this requires stack control 
065c			 
065c			 
065c			; Delete File 
065c			; ----------- 
065c			; 
065c			; With current bank 
065c			; 
065c			; Load Block 0 Config 
065c			; Get max file id number 
065c			; For each logical block 
065c			;    Read block file id 
065c			;      If first block of file and dont have file id 
065c			;         if file to delete 
065c			;         Save file id 
065c			;         Null file id 
065c			;         Write this block back 
065c			;      If file id is one saved 
065c			;         Null file id 
065c			;         Write this block back 
065c			 
065c			 
065c			.se_done: 
065c e1				pop hl 
065d c9				ret 
065e			 
065e			storage_erase: 
065e			 
065e				; hl contains the file id 
065e			 
065e 5d				ld e, l 
065f 16 00			ld d, 0 
0661 21 40 00			ld hl, STORE_BLOCK_PHY 
0664					if DEBUG_FORTH_WORDS 
0664						DMARK "ERA" 
0664 f5				push af  
0665 3a 79 06			ld a, (.dmark)  
0668 32 6b fe			ld (debug_mark),a  
066b 3a 7a 06			ld a, (.dmark+1)  
066e 32 6c fe			ld (debug_mark+1),a  
0671 3a 7b 06			ld a, (.dmark+2)  
0674 32 6d fe			ld (debug_mark+2),a  
0677 18 03			jr .pastdmark  
0679 ..			.dmark: db "ERA"  
067c f1			.pastdmark: pop af  
067d			endm  
# End of macro DMARK
067d						CALLMONITOR 
067d cd 6f fe			call debug_vector  
0680				endm  
# End of macro CALLMONITOR
0680					endif 
0680 cd 4f 07			call storage_findnextid 
0683 cd af 0f			call ishlzero 
0686 c8				ret z 
0687			 
0687 e5				push hl 
0688			 
0688				; TODO check file not found 
0688			 
0688 11 7a fa			ld de, store_page 
068b cd 1c 04			call storage_read_block 
068e			 
068e cd af 0f			call ishlzero 
0691 ca 5c 06			jp z,.se_done 
0694			 
0694					if DEBUG_FORTH_WORDS 
0694						DMARK "ER1" 
0694 f5				push af  
0695 3a a9 06			ld a, (.dmark)  
0698 32 6b fe			ld (debug_mark),a  
069b 3a aa 06			ld a, (.dmark+1)  
069e 32 6c fe			ld (debug_mark+1),a  
06a1 3a ab 06			ld a, (.dmark+2)  
06a4 32 6d fe			ld (debug_mark+2),a  
06a7 18 03			jr .pastdmark  
06a9 ..			.dmark: db "ER1"  
06ac f1			.pastdmark: pop af  
06ad			endm  
# End of macro DMARK
06ad						CALLMONITOR 
06ad cd 6f fe			call debug_vector  
06b0				endm  
# End of macro CALLMONITOR
06b0					endif 
06b0 3a 7a fa			ld a, (store_page)	; get file id 
06b3 32 6e fa			ld (store_tmpid), a 
06b6			 
06b6 3a 7c fa			ld a, (store_page+2)    ; get count of extends 
06b9 32 6d fa			ld (store_tmpext), a 
06bc			 
06bc				; wipe file header 
06bc			 
06bc e1				pop hl 
06bd 3e 00			ld a, 0 
06bf 32 7a fa			ld (store_page), a 
06c2 32 7b fa			ld (store_page+1),a 
06c5 11 7a fa			ld de, store_page 
06c8					if DEBUG_FORTH_WORDS 
06c8						DMARK "ER2" 
06c8 f5				push af  
06c9 3a dd 06			ld a, (.dmark)  
06cc 32 6b fe			ld (debug_mark),a  
06cf 3a de 06			ld a, (.dmark+1)  
06d2 32 6c fe			ld (debug_mark+1),a  
06d5 3a df 06			ld a, (.dmark+2)  
06d8 32 6d fe			ld (debug_mark+2),a  
06db 18 03			jr .pastdmark  
06dd ..			.dmark: db "ER2"  
06e0 f1			.pastdmark: pop af  
06e1			endm  
# End of macro DMARK
06e1						CALLMONITOR 
06e1 cd 6f fe			call debug_vector  
06e4				endm  
# End of macro CALLMONITOR
06e4					endif 
06e4 cd 81 04			call storage_write_block 
06e7			 
06e7			 
06e7				; wipe file extents 
06e7			 
06e7 3a 6d fa			ld a, (store_tmpext) 
06ea 47				ld b, a 
06eb			 
06eb			.eraext:	  
06eb c5				push bc 
06ec			 
06ec 21 40 00			ld hl, STORE_BLOCK_PHY 
06ef 3a 6e fa			ld a,(store_tmpid) 
06f2 5f				ld e, a 
06f3 50				ld d, b	 
06f4					if DEBUG_FORTH_WORDS 
06f4						DMARK "ER3" 
06f4 f5				push af  
06f5 3a 09 07			ld a, (.dmark)  
06f8 32 6b fe			ld (debug_mark),a  
06fb 3a 0a 07			ld a, (.dmark+1)  
06fe 32 6c fe			ld (debug_mark+1),a  
0701 3a 0b 07			ld a, (.dmark+2)  
0704 32 6d fe			ld (debug_mark+2),a  
0707 18 03			jr .pastdmark  
0709 ..			.dmark: db "ER3"  
070c f1			.pastdmark: pop af  
070d			endm  
# End of macro DMARK
070d						CALLMONITOR 
070d cd 6f fe			call debug_vector  
0710				endm  
# End of macro CALLMONITOR
0710					endif 
0710 cd 4f 07			call storage_findnextid 
0713 cd af 0f			call ishlzero 
0716 ca 5c 06			jp z,.se_done 
0719			 
0719 e5				push hl 
071a 11 7a fa			ld de, store_page 
071d cd 1c 04			call storage_read_block 
0720			 
0720				; free block	 
0720			 
0720 3e 00			ld a, 0 
0722 32 7a fa			ld (store_page), a 
0725 32 7b fa			ld (store_page+1),a 
0728 11 7a fa			ld de, store_page 
072b e1				pop hl 
072c					if DEBUG_FORTH_WORDS 
072c						DMARK "ER4" 
072c f5				push af  
072d 3a 41 07			ld a, (.dmark)  
0730 32 6b fe			ld (debug_mark),a  
0733 3a 42 07			ld a, (.dmark+1)  
0736 32 6c fe			ld (debug_mark+1),a  
0739 3a 43 07			ld a, (.dmark+2)  
073c 32 6d fe			ld (debug_mark+2),a  
073f 18 03			jr .pastdmark  
0741 ..			.dmark: db "ER4"  
0744 f1			.pastdmark: pop af  
0745			endm  
# End of macro DMARK
0745						CALLMONITOR 
0745 cd 6f fe			call debug_vector  
0748				endm  
# End of macro CALLMONITOR
0748					endif 
0748 cd 81 04			call storage_write_block 
074b			 
074b c1				pop bc 
074c 10 9d			djnz .eraext 
074e			 
074e c9				ret 
074f			 
074f			 
074f			; Find Free Block 
074f			; --------------- 
074f			; 
074f			; With current bank 
074f			;  
074f			; From given starting logical block 
074f			;    Read block  
074f			;    If no file id 
074f			;         Return block id 
074f			 
074f			 
074f			; hl starting page number 
074f			; hl contains free page number or zero if no pages free 
074f			; e contains the file id to locate 
074f			; d contains the block number 
074f			 
074f			; TODO change to find file id and use zero for free block 
074f			 
074f			storage_findnextid: 
074f			 
074f				; now locate first 0 page to mark as a free block 
074f			 
074f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0751			;	ld hl, STORE_BLOCK_PHY 
0751			 
0751					if DEBUG_FORTH_WORDS 
0751					DMARK "FNI" 
0751 f5				push af  
0752 3a 66 07			ld a, (.dmark)  
0755 32 6b fe			ld (debug_mark),a  
0758 3a 67 07			ld a, (.dmark+1)  
075b 32 6c fe			ld (debug_mark+1),a  
075e 3a 68 07			ld a, (.dmark+2)  
0761 32 6d fe			ld (debug_mark+2),a  
0764 18 03			jr .pastdmark  
0766 ..			.dmark: db "FNI"  
0769 f1			.pastdmark: pop af  
076a			endm  
# End of macro DMARK
076a						CALLMONITOR 
076a cd 6f fe			call debug_vector  
076d				endm  
# End of macro CALLMONITOR
076d					endif 
076d			.ff1:   	 
076d e5					push hl 
076e c5					push bc 
076f d5					push de 
0770 cd c3 02				call se_readbyte 
0773 5f					ld e,a 
0774 23					inc hl 
0775 cd c3 02				call se_readbyte 
0778 57					ld d, a 
0779 e1					pop hl 
077a e5					push hl 
077b cd a4 0f				call cmp16 
077e 28 49				jr z, .fffound 
0780			 
0780 d1					pop de 
0781 c1					pop bc 
0782 e1					pop hl 
0783			 
0783					; is found? 
0783					;cp e 
0783					;ret z 
0783			 
0783 3e 40				ld a, STORE_BLOCK_PHY 
0785 cd 86 0f				call addatohl 
0788 10 e3				djnz .ff1 
078a			 
078a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
078c			.ff2:   	 
078c			 
078c e5					push hl 
078d c5					push bc 
078e d5					push de 
078f cd c3 02				call se_readbyte 
0792 5f					ld e,a 
0793 23					inc hl 
0794 cd c3 02				call se_readbyte 
0797 57					ld d, a 
0798			 
0798 e1					pop hl 
0799 e5					push hl 
079a cd a4 0f				call cmp16 
079d 28 2a				jr z, .fffound 
079f			 
079f d1					pop de 
07a0 c1					pop bc 
07a1 e1					pop hl 
07a2					; is found? 
07a2					;cp e 
07a2					;ret z 
07a2			 
07a2 3e 40				ld a, STORE_BLOCK_PHY 
07a4 cd 86 0f				call addatohl 
07a7 10 e3				djnz .ff2 
07a9			 
07a9			 
07a9					if DEBUG_FORTH_WORDS 
07a9					DMARK "FN-" 
07a9 f5				push af  
07aa 3a be 07			ld a, (.dmark)  
07ad 32 6b fe			ld (debug_mark),a  
07b0 3a bf 07			ld a, (.dmark+1)  
07b3 32 6c fe			ld (debug_mark+1),a  
07b6 3a c0 07			ld a, (.dmark+2)  
07b9 32 6d fe			ld (debug_mark+2),a  
07bc 18 03			jr .pastdmark  
07be ..			.dmark: db "FN-"  
07c1 f1			.pastdmark: pop af  
07c2			endm  
# End of macro DMARK
07c2					;	push af 
07c2					;	ld a, 'n' 
07c2					;	ld (debug_mark),a 
07c2					;	pop af 
07c2						CALLMONITOR 
07c2 cd 6f fe			call debug_vector  
07c5				endm  
# End of macro CALLMONITOR
07c5					endif 
07c5				; no free marks! 
07c5 21 00 00				ld hl, 0 
07c8 c9				ret 
07c9			.fffound: 
07c9				 
07c9			 
07c9 d1					pop de 
07ca c1					pop bc 
07cb e1					pop hl 
07cc					if DEBUG_FORTH_WORDS 
07cc					DMARK "FNF" 
07cc f5				push af  
07cd 3a e1 07			ld a, (.dmark)  
07d0 32 6b fe			ld (debug_mark),a  
07d3 3a e2 07			ld a, (.dmark+1)  
07d6 32 6c fe			ld (debug_mark+1),a  
07d9 3a e3 07			ld a, (.dmark+2)  
07dc 32 6d fe			ld (debug_mark+2),a  
07df 18 03			jr .pastdmark  
07e1 ..			.dmark: db "FNF"  
07e4 f1			.pastdmark: pop af  
07e5			endm  
# End of macro DMARK
07e5					;	push af 
07e5					;	ld a, 'n' 
07e5					;	ld (debug_mark),a 
07e5					;	pop af 
07e5						CALLMONITOR 
07e5 cd 6f fe			call debug_vector  
07e8				endm  
# End of macro CALLMONITOR
07e8					endif 
07e8 c9				ret 
07e9			 
07e9			 
07e9			 
07e9			; Free Space 
07e9			; ---------- 
07e9			; 
07e9			; With current bank 
07e9			; 
07e9			; Set block count to zero 
07e9			; Starting with first logical block 
07e9			;      Find free block  
07e9			;      If block id given, increment block count 
07e9			; 
07e9			;  
07e9			 
07e9			 
07e9			; hl contains count of free blocks 
07e9			 
07e9			storage_freeblocks: 
07e9			 
07e9				; now locate first 0 page to mark as a free block 
07e9			 
07e9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07eb 21 40 00			ld hl, STORE_BLOCK_PHY 
07ee 11 00 00			ld de, 0 
07f1			 
07f1			.fb1:   	 
07f1 e5					push hl 
07f2 c5					push bc 
07f3 d5					push de 
07f4 cd c3 02				call se_readbyte 
07f7 d1					pop de 
07f8 c1					pop bc 
07f9 e1					pop hl 
07fa			 
07fa					; is free? 
07fa fe 00				cp 0 
07fc 20 01				jr nz, .ff1cont 
07fe 13					inc de 
07ff			 
07ff			.ff1cont: 
07ff			 
07ff			 
07ff 3e 40				ld a, STORE_BLOCK_PHY 
0801 cd 86 0f				call addatohl 
0804 10 eb				djnz .fb1 
0806			 
0806 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0808			.fb2:   	 
0808 e5					push hl 
0809 c5					push bc 
080a d5					push de 
080b cd c3 02				call se_readbyte 
080e d1					pop de 
080f c1					pop bc 
0810 e1					pop hl 
0811			 
0811					; is free? 
0811 fe 00				cp 0 
0813 20 01				jr nz, .ff2cont 
0815 13					inc de 
0816			 
0816			.ff2cont: 
0816			 
0816 3e 40				ld a, STORE_BLOCK_PHY 
0818 cd 86 0f				call addatohl 
081b 10 eb				djnz .fb2 
081d			 
081d eb				ex de, hl 
081e c9				ret 
081f			 
081f			; Get File ID 
081f			; ----------- 
081f			; 
081f			; With current bank 
081f			;  
081f			; Load Block 0 Config 
081f			; Get max file id number 
081f			; For each logical block 
081f			;    Read block file id 
081f			;      If first block of file and dont have file id 
081f			;         if file get id and exit 
081f			 
081f			 
081f			 
081f			 
081f			; Create File 
081f			; ----------- 
081f			; 
081f			; With current bank  
081f			; Load Block 0 Config 
081f			; Get max file id number 
081f			; Increment file id number 
081f			; Save Config 
081f			; Find free block 
081f			; Set buffer with file name and file id 
081f			; Write buffer to free block  
081f			 
081f			 
081f			; hl point to file name 
081f			; hl returns file id 
081f			 
081f			; file format: 
081f			; byte 0 - file id 
081f			; byte 1 - extent number 
081f			; byte 2-> data 
081f			 
081f			; format for extent number 0: 
081f			; 
081f			; byte 0 - file id 
081f			; byte 1 - extent 0 
081f			; byte 2 - extent count 
081f			; byte 3 -> file name and meta data 
081f			 
081f			 
081f			storage_create: 
081f				if DEBUG_STORESE 
081f					DMARK "SCR" 
081f f5				push af  
0820 3a 34 08			ld a, (.dmark)  
0823 32 6b fe			ld (debug_mark),a  
0826 3a 35 08			ld a, (.dmark+1)  
0829 32 6c fe			ld (debug_mark+1),a  
082c 3a 36 08			ld a, (.dmark+2)  
082f 32 6d fe			ld (debug_mark+2),a  
0832 18 03			jr .pastdmark  
0834 ..			.dmark: db "SCR"  
0837 f1			.pastdmark: pop af  
0838			endm  
# End of macro DMARK
0838					CALLMONITOR 
0838 cd 6f fe			call debug_vector  
083b				endm  
# End of macro CALLMONITOR
083b				endif 
083b			 
083b e5				push hl		; save file name pointer 
083c			 
083c cd cd 04			call storage_get_block_0 
083f			 
083f 3a 7a fa			ld a,(store_page)	; get current file id 
0842 3c				inc a 
0843 32 7a fa			ld (store_page),a 
0846				 
0846 32 6e fa			ld (store_tmpid),a			; save id 
0849			 
0849 21 00 00			ld hl, 0 
084c 11 7a fa			ld de, store_page 
084f				if DEBUG_STORESE 
084f					DMARK "SCw" 
084f f5				push af  
0850 3a 64 08			ld a, (.dmark)  
0853 32 6b fe			ld (debug_mark),a  
0856 3a 65 08			ld a, (.dmark+1)  
0859 32 6c fe			ld (debug_mark+1),a  
085c 3a 66 08			ld a, (.dmark+2)  
085f 32 6d fe			ld (debug_mark+2),a  
0862 18 03			jr .pastdmark  
0864 ..			.dmark: db "SCw"  
0867 f1			.pastdmark: pop af  
0868			endm  
# End of macro DMARK
0868					CALLMONITOR 
0868 cd 6f fe			call debug_vector  
086b				endm  
# End of macro CALLMONITOR
086b				endif 
086b cd 81 04			call storage_write_block	 ; save update 
086e			 
086e				if DEBUG_STORESE 
086e 11 7a fa				ld de, store_page 
0871					DMARK "SCC" 
0871 f5				push af  
0872 3a 86 08			ld a, (.dmark)  
0875 32 6b fe			ld (debug_mark),a  
0878 3a 87 08			ld a, (.dmark+1)  
087b 32 6c fe			ld (debug_mark+1),a  
087e 3a 88 08			ld a, (.dmark+2)  
0881 32 6d fe			ld (debug_mark+2),a  
0884 18 03			jr .pastdmark  
0886 ..			.dmark: db "SCC"  
0889 f1			.pastdmark: pop af  
088a			endm  
# End of macro DMARK
088a					CALLMONITOR 
088a cd 6f fe			call debug_vector  
088d				endm  
# End of macro CALLMONITOR
088d				endif 
088d				;  
088d				 
088d 21 40 00			ld hl, STORE_BLOCK_PHY 
0890 11 00 00			ld de, 0 
0893 cd 4f 07			call storage_findnextid 
0896			 
0896 22 65 fa			ld (store_tmppageid), hl    ; save page to use  
0899			 
0899				; TODO detect 0 = no spare blocks 
0899			 
0899				; hl now contains the free page to use for the file header page 
0899			 
0899				if DEBUG_STORESE 
0899				DMARK "SCF" 
0899 f5				push af  
089a 3a ae 08			ld a, (.dmark)  
089d 32 6b fe			ld (debug_mark),a  
08a0 3a af 08			ld a, (.dmark+1)  
08a3 32 6c fe			ld (debug_mark+1),a  
08a6 3a b0 08			ld a, (.dmark+2)  
08a9 32 6d fe			ld (debug_mark+2),a  
08ac 18 03			jr .pastdmark  
08ae ..			.dmark: db "SCF"  
08b1 f1			.pastdmark: pop af  
08b2			endm  
# End of macro DMARK
08b2					CALLMONITOR 
08b2 cd 6f fe			call debug_vector  
08b5				endm  
# End of macro CALLMONITOR
08b5				endif 
08b5			 
08b5 22 65 fa			ld (store_tmppageid), hl 
08b8				 
08b8 3a 6e fa			ld a,(store_tmpid)    ; get file id 
08bb			;	ld a, (store_filecache)			; save to cache 
08bb			 
08bb 32 7a fa			ld (store_page),a    ; set page id 
08be 3e 00			ld a, 0			 ; extent 0 is file header 
08c0 32 7b fa			ld (store_page+1), a   ; set file extent 
08c3			 
08c3 32 7c fa			ld (store_page+2), a   ; extent count for the file 
08c6			 
08c6			;	inc hl 		; init block 0 of file 
08c6			;	inc hl   		; skip file and extent id 
08c6			 ;       ld a, 0 
08c6			;	ld (hl),a 
08c6			;	ld a, (store_filecache+1)  	; save to cache 
08c6			 
08c6			;	inc hl    ; file name 
08c6				 
08c6				 
08c6 11 7d fa			ld de, store_page+3    ; get buffer for term string to use as file name 
08c9				if DEBUG_STORESE 
08c9					DMARK "SCc" 
08c9 f5				push af  
08ca 3a de 08			ld a, (.dmark)  
08cd 32 6b fe			ld (debug_mark),a  
08d0 3a df 08			ld a, (.dmark+1)  
08d3 32 6c fe			ld (debug_mark+1),a  
08d6 3a e0 08			ld a, (.dmark+2)  
08d9 32 6d fe			ld (debug_mark+2),a  
08dc 18 03			jr .pastdmark  
08de ..			.dmark: db "SCc"  
08e1 f1			.pastdmark: pop af  
08e2			endm  
# End of macro DMARK
08e2					CALLMONITOR 
08e2 cd 6f fe			call debug_vector  
08e5				endm  
# End of macro CALLMONITOR
08e5				endif 
08e5 e1				pop hl    ; get zero term string 
08e6 e5				push hl 
08e7 3e 00			ld a, 0 
08e9 cd ef 13			call strlent 
08ec 23				inc hl   ; cover zero term 
08ed 06 00			ld b,0 
08ef 4d				ld c,l 
08f0 e1				pop hl 
08f1				;ex de, hl 
08f1				if DEBUG_STORESE 
08f1					DMARK "SCa" 
08f1 f5				push af  
08f2 3a 06 09			ld a, (.dmark)  
08f5 32 6b fe			ld (debug_mark),a  
08f8 3a 07 09			ld a, (.dmark+1)  
08fb 32 6c fe			ld (debug_mark+1),a  
08fe 3a 08 09			ld a, (.dmark+2)  
0901 32 6d fe			ld (debug_mark+2),a  
0904 18 03			jr .pastdmark  
0906 ..			.dmark: db "SCa"  
0909 f1			.pastdmark: pop af  
090a			endm  
# End of macro DMARK
090a					;push af 
090a					;ld a, 'a' 
090a					;ld (debug_mark),a 
090a					;pop af 
090a					CALLMONITOR 
090a cd 6f fe			call debug_vector  
090d				endm  
# End of macro CALLMONITOR
090d				endif 
090d ed b0			ldir    ; copy zero term string 
090f				if DEBUG_STORESE 
090f					DMARK "SCA" 
090f f5				push af  
0910 3a 24 09			ld a, (.dmark)  
0913 32 6b fe			ld (debug_mark),a  
0916 3a 25 09			ld a, (.dmark+1)  
0919 32 6c fe			ld (debug_mark+1),a  
091c 3a 26 09			ld a, (.dmark+2)  
091f 32 6d fe			ld (debug_mark+2),a  
0922 18 03			jr .pastdmark  
0924 ..			.dmark: db "SCA"  
0927 f1			.pastdmark: pop af  
0928			endm  
# End of macro DMARK
0928					CALLMONITOR 
0928 cd 6f fe			call debug_vector  
092b				endm  
# End of macro CALLMONITOR
092b				endif 
092b			 
092b				; write file header page 
092b			 
092b 2a 65 fa			ld hl,(store_tmppageid) 
092e 11 7a fa			ld de, store_page 
0931				if DEBUG_STORESE 
0931					DMARK "SCb" 
0931 f5				push af  
0932 3a 46 09			ld a, (.dmark)  
0935 32 6b fe			ld (debug_mark),a  
0938 3a 47 09			ld a, (.dmark+1)  
093b 32 6c fe			ld (debug_mark+1),a  
093e 3a 48 09			ld a, (.dmark+2)  
0941 32 6d fe			ld (debug_mark+2),a  
0944 18 03			jr .pastdmark  
0946 ..			.dmark: db "SCb"  
0949 f1			.pastdmark: pop af  
094a			endm  
# End of macro DMARK
094a					;push af 
094a					;ld a, 'b' 
094a					;ld (debug_mark),a 
094a					;pop af 
094a					CALLMONITOR 
094a cd 6f fe			call debug_vector  
094d				endm  
# End of macro CALLMONITOR
094d				endif 
094d cd 81 04			call storage_write_block 
0950			 
0950 3a 6e fa			ld a, (store_tmpid) 
0953 6f				ld l, a 
0954 26 00			ld h,0 
0956				if DEBUG_STORESE 
0956					DMARK "SCz" 
0956 f5				push af  
0957 3a 6b 09			ld a, (.dmark)  
095a 32 6b fe			ld (debug_mark),a  
095d 3a 6c 09			ld a, (.dmark+1)  
0960 32 6c fe			ld (debug_mark+1),a  
0963 3a 6d 09			ld a, (.dmark+2)  
0966 32 6d fe			ld (debug_mark+2),a  
0969 18 03			jr .pastdmark  
096b ..			.dmark: db "SCz"  
096e f1			.pastdmark: pop af  
096f			endm  
# End of macro DMARK
096f					CALLMONITOR 
096f cd 6f fe			call debug_vector  
0972				endm  
# End of macro CALLMONITOR
0972				endif 
0972 c9				ret 
0973				 
0973			 
0973			 
0973			; 
0973			; Read File 
0973			; 
0973			; h - file id to locate 
0973			; l - extent to locate 
0973			; de - pointer to string to read into 
0973			; 
0973			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0973			 
0973			.sr_fail: 
0973 d1				pop de 
0974 c9				ret 
0975			 
0975			storage_read: 
0975			 
0975			 
0975 d5				push de 
0976			 
0976			; TODO BUG the above push is it popped before the RET Z? 
0976			 
0976			; TODO how to handle multiple part blocks 
0976			 
0976				; locate file extent to read 
0976			 
0976 5c				ld e, h 
0977 55				ld d, l 
0978			 
0978			.srext: 
0978 22 78 fa			ld (store_readptr), hl     ; save the current extent to load 
097b ed 53 76 fa		ld (store_readbuf), de     ; save the current buffer to load in to 
097f			 
097f 21 40 00			ld hl, STORE_BLOCK_PHY 
0982				if DEBUG_STORESE 
0982					DMARK "sre" 
0982 f5				push af  
0983 3a 97 09			ld a, (.dmark)  
0986 32 6b fe			ld (debug_mark),a  
0989 3a 98 09			ld a, (.dmark+1)  
098c 32 6c fe			ld (debug_mark+1),a  
098f 3a 99 09			ld a, (.dmark+2)  
0992 32 6d fe			ld (debug_mark+2),a  
0995 18 03			jr .pastdmark  
0997 ..			.dmark: db "sre"  
099a f1			.pastdmark: pop af  
099b			endm  
# End of macro DMARK
099b					CALLMONITOR 
099b cd 6f fe			call debug_vector  
099e				endm  
# End of macro CALLMONITOR
099e				endif 
099e cd 4f 07			call storage_findnextid 
09a1			 
09a1				if DEBUG_STORESE 
09a1					DMARK "srf" 
09a1 f5				push af  
09a2 3a b6 09			ld a, (.dmark)  
09a5 32 6b fe			ld (debug_mark),a  
09a8 3a b7 09			ld a, (.dmark+1)  
09ab 32 6c fe			ld (debug_mark+1),a  
09ae 3a b8 09			ld a, (.dmark+2)  
09b1 32 6d fe			ld (debug_mark+2),a  
09b4 18 03			jr .pastdmark  
09b6 ..			.dmark: db "srf"  
09b9 f1			.pastdmark: pop af  
09ba			endm  
# End of macro DMARK
09ba					CALLMONITOR 
09ba cd 6f fe			call debug_vector  
09bd				endm  
# End of macro CALLMONITOR
09bd				endif 
09bd cd af 0f			call ishlzero 
09c0			;	ld a, l 
09c0			;	add h 
09c0			;	cp 0 
09c0 28 b1			jr z,.sr_fail			; block not found so EOF 
09c2			 
09c2				; save current address for use by higher level words etc 
09c2			 
09c2 22 6b fa			ld (store_openaddr),hl 
09c5			 
09c5			 
09c5				; hl contains page number to load 
09c5 d1				pop de   ; get storage 
09c6 ed 53 76 fa		ld (store_readbuf), de     ; current buffer to load in to 
09ca d5				push de 
09cb				if DEBUG_STORESE 
09cb					DMARK "srg" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 6b fe			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 6c fe			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 6d fe			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "srg"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd 6f fe			call debug_vector  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7 cd 1c 04			call storage_read_block 
09ea			 
09ea				; if this a continuation read??? 
09ea			 
09ea 2a 76 fa			ld hl, (store_readbuf)     ; current buffer to load in to 
09ed			 
09ed 3e 3f			ld a, STORE_BLOCK_PHY-1 
09ef cd 86 0f			call addatohl 
09f2 7e				ld a,(hl) 
09f3 fe 00			cp 0 
09f5 28 02			jr z, .markiscont 
09f7 3e ff			ld a, 255 
09f9			 
09f9			.markiscont: 
09f9 32 6d fa			ld (store_readcont), a 
09fc			 
09fc				if DEBUG_STORESE 
09fc					DMARK "srC" 
09fc f5				push af  
09fd 3a 11 0a			ld a, (.dmark)  
0a00 32 6b fe			ld (debug_mark),a  
0a03 3a 12 0a			ld a, (.dmark+1)  
0a06 32 6c fe			ld (debug_mark+1),a  
0a09 3a 13 0a			ld a, (.dmark+2)  
0a0c 32 6d fe			ld (debug_mark+2),a  
0a0f 18 03			jr .pastdmark  
0a11 ..			.dmark: db "srC"  
0a14 f1			.pastdmark: pop af  
0a15			endm  
# End of macro DMARK
0a15					CALLMONITOR 
0a15 cd 6f fe			call debug_vector  
0a18				endm  
# End of macro CALLMONITOR
0a18				endif 
0a18				; only short reads enabled 
0a18			 
0a18 3a 75 fa			ld a, (store_longread) 
0a1b fe 00			cp 0 
0a1d ca ea 0a			jp z, .readdone 
0a20			 
0a20			; TODO if block has no zeros then need to read next block  
0a20			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a20			; check last byte of physical block. 
0a20			; if not zero then the next block needs to be loaded 
0a20			 
0a20			 
0a20 2a 76 fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a23			 
0a23 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a25 cd 86 0f			call addatohl 
0a28				;dec hl 
0a28 7e				ld a,(hl) 
0a29				if DEBUG_STORESE 
0a29					DMARK "sr?" 
0a29 f5				push af  
0a2a 3a 3e 0a			ld a, (.dmark)  
0a2d 32 6b fe			ld (debug_mark),a  
0a30 3a 3f 0a			ld a, (.dmark+1)  
0a33 32 6c fe			ld (debug_mark+1),a  
0a36 3a 40 0a			ld a, (.dmark+2)  
0a39 32 6d fe			ld (debug_mark+2),a  
0a3c 18 03			jr .pastdmark  
0a3e ..			.dmark: db "sr?"  
0a41 f1			.pastdmark: pop af  
0a42			endm  
# End of macro DMARK
0a42					CALLMONITOR 
0a42 cd 6f fe			call debug_vector  
0a45				endm  
# End of macro CALLMONITOR
0a45				endif 
0a45 fe 00			cp 0 
0a47 ca ea 0a			jp z, .readdone 
0a4a			 
0a4a				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a4a			 
0a4a 23				inc hl 
0a4b			 
0a4b 22 76 fa			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a4e			 
0a4e ed 5b 78 fa		ld de, (store_readptr)     ; save the current extent to load 
0a52			 
0a52 eb				ex de, hl 
0a53			 
0a53				; next ext 
0a53			 
0a53 23				inc hl 
0a54 22 78 fa			ld  (store_readptr), hl     ; save the current extent to load 
0a57			 
0a57				if DEBUG_STORESE 
0a57					DMARK "sF2" 
0a57 f5				push af  
0a58 3a 6c 0a			ld a, (.dmark)  
0a5b 32 6b fe			ld (debug_mark),a  
0a5e 3a 6d 0a			ld a, (.dmark+1)  
0a61 32 6c fe			ld (debug_mark+1),a  
0a64 3a 6e 0a			ld a, (.dmark+2)  
0a67 32 6d fe			ld (debug_mark+2),a  
0a6a 18 03			jr .pastdmark  
0a6c ..			.dmark: db "sF2"  
0a6f f1			.pastdmark: pop af  
0a70			endm  
# End of macro DMARK
0a70					CALLMONITOR 
0a70 cd 6f fe			call debug_vector  
0a73				endm  
# End of macro CALLMONITOR
0a73				endif 
0a73			 
0a73				; get and load block 
0a73			 
0a73 cd 4f 07			call storage_findnextid 
0a76			 
0a76				if DEBUG_STORESE 
0a76					DMARK "sf2" 
0a76 f5				push af  
0a77 3a 8b 0a			ld a, (.dmark)  
0a7a 32 6b fe			ld (debug_mark),a  
0a7d 3a 8c 0a			ld a, (.dmark+1)  
0a80 32 6c fe			ld (debug_mark+1),a  
0a83 3a 8d 0a			ld a, (.dmark+2)  
0a86 32 6d fe			ld (debug_mark+2),a  
0a89 18 03			jr .pastdmark  
0a8b ..			.dmark: db "sf2"  
0a8e f1			.pastdmark: pop af  
0a8f			endm  
# End of macro DMARK
0a8f					CALLMONITOR 
0a8f cd 6f fe			call debug_vector  
0a92				endm  
# End of macro CALLMONITOR
0a92				endif 
0a92 cd af 0f			call ishlzero 
0a95			;	ld a, l 
0a95			;	add h 
0a95			;	cp 0 
0a95 ca 73 09			jp z,.sr_fail			; block not found so EOF 
0a98				 
0a98				; save current address for use by higher level words etc 
0a98			 
0a98 22 6b fa			ld (store_openaddr),hl 
0a9b			 
0a9b cd 1c 04			call storage_read_block 
0a9e			 
0a9e				; on a continuation block, we now have the file id and ext in the middle of the block 
0a9e				; we need to pull everything back  
0a9e			 
0a9e ed 5b 76 fa		ld de, (store_readbuf)     ; current buffer to nudge into 
0aa2 2a 76 fa			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aa5 23				inc hl 
0aa6 23				inc hl     ; skip id and ext 
0aa7 01 40 00			ld bc, STORE_BLOCK_PHY 
0aaa				if DEBUG_STORESE 
0aaa					DMARK "SR<" 
0aaa f5				push af  
0aab 3a bf 0a			ld a, (.dmark)  
0aae 32 6b fe			ld (debug_mark),a  
0ab1 3a c0 0a			ld a, (.dmark+1)  
0ab4 32 6c fe			ld (debug_mark+1),a  
0ab7 3a c1 0a			ld a, (.dmark+2)  
0aba 32 6d fe			ld (debug_mark+2),a  
0abd 18 03			jr .pastdmark  
0abf ..			.dmark: db "SR<"  
0ac2 f1			.pastdmark: pop af  
0ac3			endm  
# End of macro DMARK
0ac3					CALLMONITOR 
0ac3 cd 6f fe			call debug_vector  
0ac6				endm  
# End of macro CALLMONITOR
0ac6				endif 
0ac6 ed b0			ldir     ; copy data 
0ac8			 
0ac8				; move the pointer back and pretend we have a full buffer for next recheck 
0ac8			 
0ac8 1b				dec de 
0ac9 1b				dec de 
0aca			 
0aca			; TODO do pop below now short circuit loop????? 
0aca c1				pop bc     ; get rid of spare de on stack 
0acb				if DEBUG_STORESE 
0acb					DMARK "SR>" 
0acb f5				push af  
0acc 3a e0 0a			ld a, (.dmark)  
0acf 32 6b fe			ld (debug_mark),a  
0ad2 3a e1 0a			ld a, (.dmark+1)  
0ad5 32 6c fe			ld (debug_mark+1),a  
0ad8 3a e2 0a			ld a, (.dmark+2)  
0adb 32 6d fe			ld (debug_mark+2),a  
0ade 18 03			jr .pastdmark  
0ae0 ..			.dmark: db "SR>"  
0ae3 f1			.pastdmark: pop af  
0ae4			endm  
# End of macro DMARK
0ae4					CALLMONITOR 
0ae4 cd 6f fe			call debug_vector  
0ae7				endm  
# End of macro CALLMONITOR
0ae7				endif 
0ae7 c3 78 09			jp .srext 
0aea			 
0aea			 
0aea			 
0aea			 
0aea			 
0aea			.readdone:		 
0aea e1				pop hl 		 ; return start of data to show as not EOF 
0aeb 23				inc hl   ; past file id 
0aec 23				inc hl   ; past ext 
0aed				if DEBUG_STORESE 
0aed					DMARK "SRe" 
0aed f5				push af  
0aee 3a 02 0b			ld a, (.dmark)  
0af1 32 6b fe			ld (debug_mark),a  
0af4 3a 03 0b			ld a, (.dmark+1)  
0af7 32 6c fe			ld (debug_mark+1),a  
0afa 3a 04 0b			ld a, (.dmark+2)  
0afd 32 6d fe			ld (debug_mark+2),a  
0b00 18 03			jr .pastdmark  
0b02 ..			.dmark: db "SRe"  
0b05 f1			.pastdmark: pop af  
0b06			endm  
# End of macro DMARK
0b06					CALLMONITOR 
0b06 cd 6f fe			call debug_vector  
0b09				endm  
# End of macro CALLMONITOR
0b09				endif 
0b09 c9					ret 
0b0a			 
0b0a			 
0b0a			 
0b0a			; 
0b0a			; Append File 
0b0a			; 
0b0a			; hl - file id to locate 
0b0a			; de - pointer to (multi block) string to write 
0b0a			 
0b0a			.sa_notfound: 
0b0a d1				pop de 
0b0b c9				ret 
0b0c			 
0b0c			 
0b0c			storage_append: 
0b0c				; hl -  file id to append to 
0b0c				; de - string to append 
0b0c			 
0b0c d5				push de 
0b0d				 
0b0d				if DEBUG_STORESE 
0b0d					DMARK "AP1" 
0b0d f5				push af  
0b0e 3a 22 0b			ld a, (.dmark)  
0b11 32 6b fe			ld (debug_mark),a  
0b14 3a 23 0b			ld a, (.dmark+1)  
0b17 32 6c fe			ld (debug_mark+1),a  
0b1a 3a 24 0b			ld a, (.dmark+2)  
0b1d 32 6d fe			ld (debug_mark+2),a  
0b20 18 03			jr .pastdmark  
0b22 ..			.dmark: db "AP1"  
0b25 f1			.pastdmark: pop af  
0b26			endm  
# End of macro DMARK
0b26					CALLMONITOR 
0b26 cd 6f fe			call debug_vector  
0b29				endm  
# End of macro CALLMONITOR
0b29				endif 
0b29			 
0b29 7d				ld a, l 
0b2a 32 6e fa			ld (store_tmpid), a 
0b2d			 
0b2d				; get file header  
0b2d			 
0b2d 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b2f 3a 6e fa			ld a, (store_tmpid) 
0b32 5f				ld e, a 
0b33			 
0b33 21 40 00				ld hl, STORE_BLOCK_PHY 
0b36 cd 4f 07				call storage_findnextid 
0b39			 
0b39 cd af 0f			call ishlzero 
0b3c 28 cc			jr z, .sa_notfound 
0b3e			 
0b3e 22 65 fa			ld (store_tmppageid), hl 
0b41			 
0b41				; TODO handle file id not found 
0b41			 
0b41				if DEBUG_STORESE 
0b41					DMARK "AP2" 
0b41 f5				push af  
0b42 3a 56 0b			ld a, (.dmark)  
0b45 32 6b fe			ld (debug_mark),a  
0b48 3a 57 0b			ld a, (.dmark+1)  
0b4b 32 6c fe			ld (debug_mark+1),a  
0b4e 3a 58 0b			ld a, (.dmark+2)  
0b51 32 6d fe			ld (debug_mark+2),a  
0b54 18 03			jr .pastdmark  
0b56 ..			.dmark: db "AP2"  
0b59 f1			.pastdmark: pop af  
0b5a			endm  
# End of macro DMARK
0b5a					CALLMONITOR 
0b5a cd 6f fe			call debug_vector  
0b5d				endm  
# End of macro CALLMONITOR
0b5d				endif 
0b5d			 
0b5d				; update file extent count 
0b5d			 
0b5d 11 7a fa			ld de, store_page 
0b60			 
0b60 cd 1c 04			call storage_read_block 
0b63			 
0b63				if DEBUG_STORESE 
0b63					DMARK "AP3" 
0b63 f5				push af  
0b64 3a 78 0b			ld a, (.dmark)  
0b67 32 6b fe			ld (debug_mark),a  
0b6a 3a 79 0b			ld a, (.dmark+1)  
0b6d 32 6c fe			ld (debug_mark+1),a  
0b70 3a 7a 0b			ld a, (.dmark+2)  
0b73 32 6d fe			ld (debug_mark+2),a  
0b76 18 03			jr .pastdmark  
0b78 ..			.dmark: db "AP3"  
0b7b f1			.pastdmark: pop af  
0b7c			endm  
# End of macro DMARK
0b7c					CALLMONITOR 
0b7c cd 6f fe			call debug_vector  
0b7f				endm  
# End of macro CALLMONITOR
0b7f				endif 
0b7f			;	ld (store_tmppageid), hl 
0b7f			 
0b7f 3a 7c fa			ld a, (store_page+2) 
0b82 3c				inc a 
0b83 32 7c fa			ld (store_page+2), a 
0b86 32 6d fa			ld (store_tmpext), a 
0b89				 
0b89				if DEBUG_STORESE 
0b89					DMARK "AP3" 
0b89 f5				push af  
0b8a 3a 9e 0b			ld a, (.dmark)  
0b8d 32 6b fe			ld (debug_mark),a  
0b90 3a 9f 0b			ld a, (.dmark+1)  
0b93 32 6c fe			ld (debug_mark+1),a  
0b96 3a a0 0b			ld a, (.dmark+2)  
0b99 32 6d fe			ld (debug_mark+2),a  
0b9c 18 03			jr .pastdmark  
0b9e ..			.dmark: db "AP3"  
0ba1 f1			.pastdmark: pop af  
0ba2			endm  
# End of macro DMARK
0ba2					CALLMONITOR 
0ba2 cd 6f fe			call debug_vector  
0ba5				endm  
# End of macro CALLMONITOR
0ba5				endif 
0ba5 2a 65 fa			ld hl, (store_tmppageid) 
0ba8 11 7a fa			ld de, store_page 
0bab cd 81 04			call storage_write_block 
0bae			 
0bae				; find free block 
0bae			 
0bae 11 00 00			ld de, 0			 ; file extent to locate 
0bb1			 
0bb1 21 40 00				ld hl, STORE_BLOCK_PHY 
0bb4 cd 4f 07				call storage_findnextid 
0bb7 cd af 0f			call ishlzero 
0bba ca 0a 0b			jp z, .sa_notfound 
0bbd			 
0bbd					; TODO handle no space left 
0bbd					 
0bbd 22 65 fa				ld (store_tmppageid), hl 
0bc0			 
0bc0				if DEBUG_STORESE 
0bc0					DMARK "AP4" 
0bc0 f5				push af  
0bc1 3a d5 0b			ld a, (.dmark)  
0bc4 32 6b fe			ld (debug_mark),a  
0bc7 3a d6 0b			ld a, (.dmark+1)  
0bca 32 6c fe			ld (debug_mark+1),a  
0bcd 3a d7 0b			ld a, (.dmark+2)  
0bd0 32 6d fe			ld (debug_mark+2),a  
0bd3 18 03			jr .pastdmark  
0bd5 ..			.dmark: db "AP4"  
0bd8 f1			.pastdmark: pop af  
0bd9			endm  
# End of macro DMARK
0bd9					CALLMONITOR 
0bd9 cd 6f fe			call debug_vector  
0bdc				endm  
# End of macro CALLMONITOR
0bdc				endif 
0bdc					; init the buffer with zeros so we can id if the buffer is full or not 
0bdc			 
0bdc e5					push hl 
0bdd c5					push bc 
0bde			 
0bde 21 7a fa				ld hl, store_page 
0be1 06 40				ld b, STORE_BLOCK_PHY 
0be3 3e 00				ld a, 0 
0be5 77			.zeroblock:	ld (hl), a 
0be6 23					inc hl 
0be7 10 fc				djnz .zeroblock 
0be9			 
0be9 c1					pop bc 
0bea e1					pop hl 
0beb			 
0beb					; construct block 
0beb			 
0beb 3a 6e fa				ld a, (store_tmpid) 
0bee 32 7a fa				ld (store_page), a   ; file id 
0bf1 3a 6d fa				ld a, (store_tmpext)   ; extent for this block 
0bf4 32 7b fa				ld (store_page+1), a 
0bf7			 
0bf7 e1					pop hl    ; get string to write 
0bf8 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0bfa 11 7c fa				ld de, store_page+2 
0bfd			 
0bfd				if DEBUG_STORESE 
0bfd					DMARK "AP5" 
0bfd f5				push af  
0bfe 3a 12 0c			ld a, (.dmark)  
0c01 32 6b fe			ld (debug_mark),a  
0c04 3a 13 0c			ld a, (.dmark+1)  
0c07 32 6c fe			ld (debug_mark+1),a  
0c0a 3a 14 0c			ld a, (.dmark+2)  
0c0d 32 6d fe			ld (debug_mark+2),a  
0c10 18 03			jr .pastdmark  
0c12 ..			.dmark: db "AP5"  
0c15 f1			.pastdmark: pop af  
0c16			endm  
# End of macro DMARK
0c16					CALLMONITOR 
0c16 cd 6f fe			call debug_vector  
0c19				endm  
# End of macro CALLMONITOR
0c19				endif 
0c19			 
0c19			 
0c19			 
0c19					; fill buffer with data until end of string or full block 
0c19			 
0c19 7e			.appd:		ld a, (hl) 
0c1a 12					ld (de), a 
0c1b fe 00				cp 0 
0c1d 28 04				jr z, .appdone 
0c1f 23					inc hl 
0c20 13					inc de 
0c21 10 f6				djnz .appd 
0c23			 
0c23 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c24 f5					push af   		; save last byte dumped 
0c25			 
0c25			 
0c25 2a 65 fa			ld hl, (store_tmppageid) 
0c28 11 7a fa			ld de, store_page 
0c2b				if DEBUG_STORESE 
0c2b					DMARK "AP6" 
0c2b f5				push af  
0c2c 3a 40 0c			ld a, (.dmark)  
0c2f 32 6b fe			ld (debug_mark),a  
0c32 3a 41 0c			ld a, (.dmark+1)  
0c35 32 6c fe			ld (debug_mark+1),a  
0c38 3a 42 0c			ld a, (.dmark+2)  
0c3b 32 6d fe			ld (debug_mark+2),a  
0c3e 18 03			jr .pastdmark  
0c40 ..			.dmark: db "AP6"  
0c43 f1			.pastdmark: pop af  
0c44			endm  
# End of macro DMARK
0c44					CALLMONITOR 
0c44 cd 6f fe			call debug_vector  
0c47				endm  
# End of macro CALLMONITOR
0c47				endif 
0c47 cd 81 04				call storage_write_block 
0c4a			 
0c4a			 
0c4a				; was that a full block of data written? 
0c4a				; any more to write out? 
0c4a			 
0c4a				; if yes then set vars and jump to start of function again 
0c4a			 
0c4a f1					pop af 
0c4b d1					pop de 
0c4c			 
0c4c fe 00				cp 0		 ; no, string was fully written 
0c4e c8					ret z 
0c4f			 
0c4f					; setup vars for next cycle 
0c4f			 
0c4f 3a 6e fa				ld a, (store_tmpid) 
0c52 6f					ld l, a 
0c53 26 00				ld h, 0 
0c55			 
0c55 c3 0c 0b			 	jp storage_append	 ; yes, need to write out some more 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			if DEBUG_STORECF 
0c58			storageput:	 
0c58					ret 
0c58			storageread: 
0c58					ld hl, store_page 
0c58					ld b, 200 
0c58					ld a,0 
0c58			.src:		ld (hl),a 
0c58					inc hl 
0c58					djnz .src 
0c58					 
0c58			 
0c58					ld de, 0 
0c58					ld bc, 1 
0c58					ld hl, store_page 
0c58					call cfRead 
0c58			 
0c58				call cfGetError 
0c58				ld hl,scratch 
0c58				call hexout 
0c58				ld hl, scratch+2 
0c58				ld a, 0 
0c58				ld (hl),a 
0c58				ld de, scratch 
0c58				ld a,display_row_1 
0c58				call str_at_display 
0c58				call update_display 
0c58			 
0c58					ld hl, store_page 
0c58					ld (os_cur_ptr),hl 
0c58			 
0c58					ret 
0c58			endif 
0c58			 
0c58			 
0c58			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c58			 
0c58			storage_clear_page: 
0c58 e5				push hl 
0c59 d5				push de 
0c5a c5				push bc 
0c5b 21 7a fa			ld hl, store_page 
0c5e 3e 00			ld a, 0 
0c60 77				ld (hl), a 
0c61			 
0c61 11 7b fa			ld de, store_page+1 
0c64 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0c67			 
0c67 ed b0			ldir 
0c69				 
0c69 c1				pop bc 
0c6a d1				pop de 
0c6b e1				pop hl 
0c6c c9				ret 
0c6d			 
0c6d			; eof 
# End of file firmware_storage.asm
0c6d			  
0c6d			; support routines for above hardware abstraction layer  
0c6d			  
0c6d			include "firmware_general.asm"        ; general support functions  
0c6d			 
0c6d			; word look up 
0c6d			 
0c6d			; in 
0c6d			; a is the index 
0c6d			; hl is pointer start of array 
0c6d			; 
0c6d			; returns 
0c6d			; hl to the word 
0c6d			; 
0c6d			 
0c6d			table_lookup:  
0c6d d5					push de 
0c6e eb					ex de, hl 
0c6f			 
0c6f 6f					ld l, a 
0c70 26 00				ld h, 0 
0c72 29					add hl, hl 
0c73 19					add hl, de 
0c74 7e					ld a, (hl) 
0c75 23					inc hl 
0c76 66					ld h,(hl) 
0c77 6f					ld l, a 
0c78			 
0c78 d1					pop de 
0c79 c9					ret 
0c7a			 
0c7a			; Delay loops 
0c7a			 
0c7a			 
0c7a			 
0c7a			aDelayInMS: 
0c7a c5				push bc 
0c7b 47				ld b,a 
0c7c			msdelay: 
0c7c c5				push bc 
0c7d				 
0c7d			 
0c7d 01 41 00			ld bc,041h 
0c80 cd 98 0c			call delayloop 
0c83 c1				pop bc 
0c84 05				dec b 
0c85 20 f5			jr nz,msdelay 
0c87			 
0c87			;if CPU_CLOCK_8MHZ 
0c87			;msdelay8: 
0c87			;	push bc 
0c87			;	 
0c87			; 
0c87			;	ld bc,041h 
0c87			;	call delayloop 
0c87			;	pop bc 
0c87			;	dec b 
0c87			;	jr nz,msdelay8 
0c87			;endif 
0c87			 
0c87			 
0c87 c1				pop bc 
0c88 c9				ret 
0c89			 
0c89			 
0c89			delay250ms: 
0c89				;push de 
0c89 01 00 40			ld bc, 04000h 
0c8c c3 98 0c			jp delayloop 
0c8f			delay500ms: 
0c8f				;push de 
0c8f 01 00 80			ld bc, 08000h 
0c92 c3 98 0c			jp delayloop 
0c95			delay1s: 
0c95				;push bc 
0c95			   ; Clobbers A, d and e 
0c95 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c98			delayloop: 
0c98 c5			    push bc 
0c99			 
0c99			if BASE_CPM 
0c99				ld bc, CPM_DELAY_TUNE 
0c99			.cpmloop: 
0c99				push bc 
0c99			 
0c99			endif 
0c99			 
0c99			 
0c99			 
0c99			delayloopi: 
0c99			;	push bc 
0c99			;.dl: 
0c99 cb 47		    bit     0,a    	; 8 
0c9b cb 47		    bit     0,a    	; 8 
0c9d cb 47		    bit     0,a    	; 8 
0c9f e6 ff		    and     255  	; 7 
0ca1 0b			    dec     bc      	; 6 
0ca2 79			    ld      a,c     	; 4 
0ca3 b0			    or      b     	; 4 
0ca4 c2 99 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0ca7			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0ca7				;pop de 
0ca7			;pop bc 
0ca7			 
0ca7			if BASE_CPM 
0ca7				pop bc 
0ca7				 
0ca7			    dec     bc      	; 6 
0ca7			    ld      a,c     	; 4 
0ca7			    or      b     	; 4 
0ca7			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0ca7				 
0ca7			 
0ca7			endif 
0ca7			;if CPU_CLOCK_8MHZ 
0ca7			;    pop bc 
0ca7			;    push bc 
0ca7			;.dl8: 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    and     255  	; 7 
0ca7			;    dec     bc      	; 6 
0ca7			;    ld      a,c     	; 4 
0ca7			;    or      b     	; 4 
0ca7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca7			;endif 
0ca7			 
0ca7			;if CPU_CLOCK_10MHZ 
0ca7			;    pop bc 
0ca7			;    push bc 
0ca7			;.dl8: 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    and     255  	; 7 
0ca7			;    dec     bc      	; 6 
0ca7			;    ld      a,c     	; 4 
0ca7			;    or      b     	; 4 
0ca7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca7			;endif 
0ca7 c1			    pop bc 
0ca8			 
0ca8 c9				ret 
0ca9			 
0ca9			 
0ca9			 
0ca9			; eof 
# End of file firmware_general.asm
0ca9			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0ca9			; display routines that use the physical hardware abstraction layer 
0ca9			 
0ca9			 
0ca9			; Display an activity indicator 
0ca9			; Each call returns the new char pointed to in hl 
0ca9			 
0ca9			active: 
0ca9 3a c6 fb			ld a, (display_active) 
0cac fe 06			cp 6 
0cae			 
0cae 20 02			jr nz, .sne 
0cb0				; gone past the last one reset sequence 
0cb0 3e ff			ld a, 255 
0cb2			 
0cb2			.sne:   
0cb2				; get the next char in seq 
0cb2 3c				inc a 
0cb3 32 c6 fb			ld (display_active), a 
0cb6			 
0cb6				; look up the string in the table 
0cb6 21 cd 0c			ld hl, actseq 
0cb9 cb 27			sla a 
0cbb cd 86 0f			call addatohl 
0cbe cd f1 23			call loadwordinhl 
0cc1			 
0cc1				; forth will write the to string when pushing so move from rom to ram 
0cc1			 
0cc1 11 c7 fb			ld de, display_active+1 
0cc4 01 02 00			ld bc, 2 
0cc7 ed b0			ldir 
0cc9			 
0cc9 21 c7 fb			ld hl, display_active+1 
0ccc c9				ret 
0ccd				 
0ccd				 
0ccd			 
0ccd			 
0ccd			;db "|/-\|-\" 
0ccd			 
0ccd			actseq: 
0ccd			 
0ccd db 0c		dw spin0 
0ccf dd 0c		dw spin1 
0cd1 df 0c		dw spin2 
0cd3 e1 0c		dw spin3 
0cd5 df 0c		dw spin2 
0cd7 dd 0c		dw spin1 
0cd9 db 0c		dw spin0 
0cdb			 
0cdb .. 00		spin0: db " ", 0 
0cdd .. 00		spin1: db "-", 0 
0cdf .. 00		spin2: db "+", 0 
0ce1 .. 00		spin3: db "#", 0 
0ce3			 
0ce3			 
0ce3			; information window 
0ce3			 
0ce3			; pass hl with 1st string to display 
0ce3			; pass de with 2nd string to display 
0ce3			 
0ce3			info_panel: 
0ce3 e5				push hl 
0ce4			 
0ce4 2a cc fb			ld hl, (display_fb_active) 
0ce7 e5				push hl    ; future de destination 
0ce8 21 b1 fd				ld hl, display_fb0 
0ceb 22 cc fb				ld (display_fb_active), hl 
0cee			 
0cee			;	call clear_display 
0cee			 
0cee				if BASE_CPM 
0cee				ld a, '.' 
0cee				else 
0cee 3e a5			ld a, 165 
0cf0				endif 
0cf0 cd 57 0d			call fill_display 
0cf3			 
0cf3			 
0cf3 3e 55			ld a, display_row_3 + 5 
0cf5 cd 65 0d			call str_at_display 
0cf8			 
0cf8 e1				pop hl 
0cf9 d1				pop de 
0cfa			 
0cfa e5				push hl 
0cfb			 
0cfb			 
0cfb 3e 2d			ld a, display_row_2 + 5 
0cfd cd 65 0d			call str_at_display 
0d00			 
0d00			 
0d00 cd 75 0d			call update_display 
0d03 cd 3a 20			call next_page_prompt 
0d06 cd 52 0d			call clear_display 
0d09			 
0d09				 
0d09 21 10 fd				ld hl, display_fb1 
0d0c 22 cc fb				ld (display_fb_active), hl 
0d0f cd 75 0d			call update_display 
0d12			 
0d12 e1				pop hl 
0d13			 
0d13 c9				ret 
0d14			 
0d14			 
0d14			 
0d14			 
0d14			; TODO windowing? 
0d14			 
0d14			; TODO scroll line up 
0d14			 
0d14			scroll_up: 
0d14			 
0d14 e5				push hl 
0d15 d5				push de 
0d16 c5				push bc 
0d17			 
0d17				; get frame buffer  
0d17			 
0d17 2a cc fb			ld hl, (display_fb_active) 
0d1a e5				push hl    ; future de destination 
0d1b			 
0d1b 11 28 00			ld  de, display_cols 
0d1e 19				add hl, de 
0d1f			 
0d1f d1				pop de 
0d20			 
0d20				;ex de, hl 
0d20 01 9f 00			ld bc, display_fb_len -1  
0d23			;if DEBUG_FORTH_WORDS 
0d23			;	DMARK "SCL" 
0d23			;	CALLMONITOR 
0d23			;endif	 
0d23 ed b0			ldir 
0d25			 
0d25				; wipe bottom row 
0d25			 
0d25			 
0d25 2a cc fb			ld hl, (display_fb_active) 
0d28 11 a0 00			ld de, display_cols*display_rows 
0d2b 19				add hl, de 
0d2c 06 28			ld b, display_cols 
0d2e 3e 20			ld a, ' ' 
0d30			.scwipe: 
0d30 77				ld (hl), a 
0d31 2b				dec hl 
0d32 10 fc			djnz .scwipe 
0d34			 
0d34				;pop hl 
0d34			 
0d34 c1				pop bc 
0d35 d1				pop de 
0d36 e1				pop hl 
0d37			 
0d37 c9				ret 
0d38			 
0d38			 
0d38			;scroll_upo: 
0d38			;	ld de, display_row_1 
0d38			 ;	ld hl, display_row_2 
0d38			;	ld bc, display_cols 
0d38			;	ldir 
0d38			;	ld de, display_row_2 
0d38			 ;	ld hl, display_row_3 
0d38			;	ld bc, display_cols 
0d38			;	ldir 
0d38			;	ld de, display_row_3 
0d38			 ;	ld hl, display_row_4 
0d38			;	ld bc, display_cols 
0d38			;	ldir 
0d38			 
0d38			; TODO clear row 4 
0d38			 
0d38			;	ret 
0d38			 
0d38				 
0d38			scroll_down: 
0d38			 
0d38 e5				push hl 
0d39 d5				push de 
0d3a c5				push bc 
0d3b			 
0d3b				; get frame buffer  
0d3b			 
0d3b 2a cc fb			ld hl, (display_fb_active) 
0d3e			 
0d3e 11 9f 00			ld de, display_fb_len - 1 
0d41 19				add hl, de 
0d42			 
0d42 e5			push hl    ; future de destination 
0d43			 
0d43 11 28 00			ld  de, display_cols 
0d46 ed 52			sbc hl, de 
0d48			 
0d48			 
0d48 d1				pop de 
0d49			 
0d49			;	ex de, hl 
0d49 01 9f 00			ld bc, display_fb_len -1  
0d4c			 
0d4c			 
0d4c				 
0d4c			 
0d4c ed b0			ldir 
0d4e			 
0d4e				; wipe bottom row 
0d4e			 
0d4e			 
0d4e			;	ld hl, (display_fb_active) 
0d4e			;;	ld de, display_cols*display_rows 
0d4e			;;	add hl, de 
0d4e			;	ld b, display_cols 
0d4e			;	ld a, ' ' 
0d4e			;.scwiped: 
0d4e			;	ld (hl), a 
0d4e			;	dec hl 
0d4e			;	djnz .scwiped 
0d4e			 
0d4e				;pop hl 
0d4e			 
0d4e c1				pop bc 
0d4f d1				pop de 
0d50 e1				pop hl 
0d51			 
0d51 c9				ret 
0d52			;scroll_down: 
0d52			;	ld de, display_row_4 
0d52			;	ld hl, display_row_3 
0d52			;	ld bc, display_cols 
0d52			;	ldir 
0d52			;	ld de, display_row_3 
0d52			; 	ld hl, display_row_2 
0d52			;	ld bc, display_cols 
0d52			;	ldir 
0d52			;	ld de, display_row_2 
0d52			;	ld hl, display_row_1 
0d52			;	ld bc, display_cols 
0d52			;	ldir 
0d52			;;; TODO clear row 1 
0d52			;	ret 
0d52			 
0d52			 
0d52			 
0d52			 
0d52			 
0d52			; clear active frame buffer 
0d52			 
0d52			clear_display: 
0d52 3e 20			ld a, ' ' 
0d54 c3 57 0d			jp fill_display 
0d57			 
0d57			; fill active frame buffer with a char in A 
0d57			 
0d57			fill_display: 
0d57 06 a0			ld b,display_fb_len 
0d59 2a cc fb			ld hl, (display_fb_active) 
0d5c 77			.fd1:	ld (hl),a 
0d5d 23				inc hl 
0d5e 10 fc			djnz .fd1 
0d60 23				inc hl 
0d61 3e 00			ld a,0 
0d63 77				ld (hl),a 
0d64			 
0d64			 
0d64 c9				ret 
0d65			; Write string (DE) at pos (A) to active frame buffer 
0d65			 
0d65 2a cc fb		str_at_display:    ld hl,(display_fb_active) 
0d68 06 00					ld b,0 
0d6a 4f					ld c,a 
0d6b 09					add hl,bc 
0d6c 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0d6d b7			            OR   A              ;Null terminator? 
0d6e c8			            RET  Z              ;Yes, so finished 
0d6f 77					ld (hl),a 
0d70 23				inc hl 
0d71 13			            INC  DE             ;Point to next character 
0d72 18 f8		            JR   .sad1     ;Repeat 
0d74 c9					ret 
0d75			 
0d75			; using current frame buffer write to physical display 
0d75			 
0d75			update_display: 
0d75 e5				push hl 
0d76 2a cc fb			ld hl, (display_fb_active) 
0d79 cd 56 75			call write_display 
0d7c e1				pop hl 
0d7d c9				ret 
0d7e			 
0d7e			; TODO scrolling 
0d7e			 
0d7e			 
0d7e			; move cursor right one char 
0d7e			cursor_right: 
0d7e			 
0d7e				; TODO shift right 
0d7e				; TODO if beyond max col 
0d7e				; TODO       cursor_next_line 
0d7e			 
0d7e c9				ret 
0d7f			 
0d7f			 
0d7f			cursor_next_line: 
0d7f				; TODO first char 
0d7f				; TODO line down 
0d7f				; TODO if past last row 
0d7f				; TODO    scroll up 
0d7f			 
0d7f c9				ret 
0d80			 
0d80			cursor_left: 
0d80				; TODO shift left 
0d80				; TODO if beyond left  
0d80				; TODO     cursor prev line 
0d80				 
0d80 c9				ret 
0d81			 
0d81			cursor_prev_line: 
0d81				; TODO last char 
0d81				; TODO line up 
0d81				; TODO if past first row 
0d81				; TODO   scroll down 
0d81			 
0d81 c9				ret 
0d82			 
0d82			 
0d82			cout: 
0d82				; A - char 
0d82 c9				ret 
0d83			 
0d83			 
0d83			; Display a menu and allow item selection (optional toggle items) 
0d83			; 
0d83			; format: 
0d83			; hl pointer to word array with zero term for items 
0d83			; e.g.    db item1 
0d83			;         db .... 
0d83			;         db 0 
0d83			; 
0d83			; a = starting menu item  
0d83			; 
0d83			; de = pointer item toggle array   (todo) 
0d83			; 
0d83			; returns item selected in a 1-... 
0d83			; returns 0 if back button pressed 
0d83			; 
0d83			; NOTE: Uses system frame buffer to display 
0d83			; 
0d83			; LEFT, Q = go back 
0d83			; RIGHT, SPACE, CR = select 
0d83			; UP, A - Up 
0d83			; DOWN, Z - Down 
0d83			 
0d83			 
0d83			 
0d83			 
0d83			 
0d83			menu: 
0d83			 
0d83					; keep array pointer 
0d83			 
0d83 22 73 fa				ld (store_tmp1), hl 
0d86 32 71 fa				ld (store_tmp2), a 
0d89			 
0d89					; check for key bounce 
0d89			 
0d89			if BASE_KEV 
0d89			 
0d89 cd a1 78		.mbounce:	call cin 
0d8c fe 00				cp 0 
0d8e 20 f9				jr nz, .mbounce 
0d90			endif 
0d90					; for ease use ex 
0d90			 
0d90					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0d90 21 b1 fd				ld hl, display_fb0 
0d93 22 cc fb				ld (display_fb_active), hl 
0d96			 
0d96 cd 52 0d		.mloop:		call clear_display 
0d99 cd 75 0d				call update_display 
0d9c			 
0d9c					; draw selection id '>' at 1 
0d9c			 
0d9c					; init start of list display 
0d9c			 
0d9c 3e 05				ld a, 5 
0d9e 32 6f fa				ld (store_tmp3), a   ; display row count 
0da1 3a 71 fa				ld a,( store_tmp2) 
0da4 32 72 fa				ld (store_tmp2+1), a   ; display item count 
0da7			 
0da7					 
0da7			.mitem:	 
0da7			 
0da7			 
0da7 3a 72 fa				ld a,(store_tmp2+1) 
0daa 6f					ld l, a 
0dab 26 00				ld h, 0 
0dad 29					add hl, hl 
0dae ed 5b 73 fa			ld de, (store_tmp1) 
0db2 19					add hl, de 
0db3 7e					ld a, (hl) 
0db4 23					inc hl 
0db5 66					ld h,(hl) 
0db6 6f					ld l, a 
0db7			 
0db7 cd af 0f				call ishlzero 
0dba 28 1a				jr z, .mdone 
0dbc			 
0dbc eb					ex de, hl 
0dbd 3a 6f fa				ld a, (store_tmp3) 
0dc0 cd 65 0d				call str_at_display 
0dc3					 
0dc3			 
0dc3					; next item 
0dc3 3a 72 fa				ld a, (store_tmp2+1) 
0dc6 3c					inc a 
0dc7 32 72 fa				ld (store_tmp2+1), a   ; display item count 
0dca			 
0dca			 		; next row 
0dca			 
0dca 3a 6f fa				ld a, (store_tmp3) 
0dcd c6 28				add display_cols 
0dcf 32 6f fa				ld (store_tmp3), a 
0dd2			 
0dd2					; at end of screen? 
0dd2			 
0dd2 fe 10				cp display_rows*4 
0dd4 20 d1				jr nz, .mitem 
0dd6			 
0dd6			 
0dd6			.mdone: 
0dd6 cd af 0f				call ishlzero 
0dd9 28 08				jr z, .nodn 
0ddb			 
0ddb 3e 78				ld a, display_row_4 
0ddd 11 5c 0e				ld de, .mdown 
0de0 cd 65 0d				call str_at_display 
0de3			 
0de3					; draw options to fill the screens with active item on line 1 
0de3					; if current option is 2 or more then display ^ in top 
0de3			 
0de3 3a 71 fa		.nodn:		ld a, (store_tmp2) 
0de6 fe 00				cp 0 
0de8 28 08				jr z, .noup 
0dea			 
0dea 3e 00				ld a, 0 
0dec 11 5a 0e				ld de, .mup 
0def cd 65 0d				call str_at_display 
0df2			 
0df2 3e 02		.noup:		ld a, 2 
0df4 11 58 0e				ld de, .msel 
0df7 cd 65 0d				call str_at_display 
0dfa			 
0dfa					; if current option + 1 is not null then display V in bottom 
0dfa					; get key 
0dfa cd 75 0d				call update_display 
0dfd			 
0dfd			 
0dfd					; handle key 
0dfd			 
0dfd cd 90 78				call cin_wait 
0e00			 
0e00 fe 05				cp KEY_UP 
0e02 28 2b				jr z, .mgoup 
0e04 fe 61				cp 'a' 
0e06 28 27				jr z, .mgoup 
0e08 fe 0a				cp KEY_DOWN 
0e0a 28 32				jr z, .mgod 
0e0c fe 7a				cp 'z' 
0e0e 28 2e				jr z, .mgod 
0e10 fe 20				cp ' ' 
0e12 28 34				jr z, .goend 
0e14 fe 0c				cp KEY_RIGHT 
0e16 28 30				jr z, .goend 
0e18 fe 0d				cp KEY_CR 
0e1a 28 2c				jr z, .goend 
0e1c fe 71				cp 'q' 
0e1e 28 0b				jr z, .goback 
0e20			 
0e20 fe 0b				cp KEY_LEFT 
0e22 28 07				jr z, .goback 
0e24 fe 08				cp KEY_BS 
0e26 28 03				jr z, .goback 
0e28 c3 96 0d				jp .mloop 
0e2b			 
0e2b			.goback: 
0e2b 3e 00			ld a, 0 
0e2d 18 1d			jr .goend2 
0e2f			 
0e2f				; move up one 
0e2f			.mgoup: 
0e2f 3a 71 fa				ld a, (store_tmp2) 
0e32 fe 00				cp 0 
0e34 ca 96 0d				jp z, .mloop 
0e37 3d					dec a 
0e38 32 71 fa				ld (store_tmp2), a 
0e3b c3 96 0d				jp .mloop 
0e3e			 
0e3e				; move down one 
0e3e			.mgod: 
0e3e 3a 71 fa				ld a, (store_tmp2) 
0e41 3c					inc a 
0e42 32 71 fa				ld (store_tmp2), a 
0e45 c3 96 0d				jp .mloop 
0e48			 
0e48			 
0e48			.goend: 
0e48					; get selected item number 
0e48			 
0e48 3a 71 fa				ld a, (store_tmp2) 
0e4b 3c					inc a 
0e4c			 
0e4c			.goend2: 
0e4c f5					push af 
0e4d			 
0e4d					; restore active fb 
0e4d					; TODO BUG assumes fb1 
0e4d			 
0e4d 21 10 fd				ld hl, display_fb1 
0e50 22 cc fb				ld (display_fb_active), hl 
0e53			 
0e53					; restore main regs 
0e53			 
0e53			 
0e53 cd 75 0d				call update_display 
0e56			 
0e56 f1					pop af 
0e57			 
0e57 c9				ret 
0e58			 
0e58 .. 00		.msel:   db ">",0 
0e5a .. 00		.mup:   db "^",0 
0e5c .. 00		.mdown:   db "v",0 
0e5e			 
0e5e			 
0e5e			; eof 
0e5e			 
# End of file firmware_display.asm
0e5e			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0e5e			; random number generators 
0e5e			 
0e5e			 
0e5e			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0e5e			 
0e5e			 
0e5e			;-----> Generate a random number 
0e5e			; output a=answer 0<=a<=255 
0e5e			; all registers are preserved except: af 
0e5e			random: 
0e5e e5			        push    hl 
0e5f d5			        push    de 
0e60 2a ab fb		        ld      hl,(randData) 
0e63 ed 5f		        ld      a,r 
0e65 57			        ld      d,a 
0e66 5e			        ld      e,(hl) 
0e67 19			        add     hl,de 
0e68 85			        add     a,l 
0e69 ac			        xor     h 
0e6a 22 ab fb		        ld      (randData),hl 
0e6d d1			        pop     de 
0e6e e1			        pop     hl 
0e6f c9			        ret 
0e70			 
0e70			 
0e70			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0e70			 
0e70			 
0e70			 
0e70			;------LFSR------ 
0e70			;James Montelongo 
0e70			;optimized by Spencer Putt 
0e70			;out: 
0e70			; a = 8 bit random number 
0e70			RandLFSR: 
0e70 21 b1 fb		        ld hl,LFSRSeed+4 
0e73 5e			        ld e,(hl) 
0e74 23			        inc hl 
0e75 56			        ld d,(hl) 
0e76 23			        inc hl 
0e77 4e			        ld c,(hl) 
0e78 23			        inc hl 
0e79 7e			        ld a,(hl) 
0e7a 47			        ld b,a 
0e7b cb 13		        rl e  
0e7d cb 12			rl d 
0e7f cb 11		        rl c  
0e81 17				rla 
0e82 cb 13		        rl e  
0e84 cb 12			rl d 
0e86 cb 11		        rl c  
0e88 17				rla 
0e89 cb 13		        rl e  
0e8b cb 12			rl d 
0e8d cb 11		        rl c  
0e8f 17				rla 
0e90 67			        ld h,a 
0e91 cb 13		        rl e  
0e93 cb 12			rl d 
0e95 cb 11		        rl c  
0e97 17				rla 
0e98 a8			        xor b 
0e99 cb 13		        rl e  
0e9b cb 12			rl d 
0e9d ac			        xor h 
0e9e a9			        xor c 
0e9f aa			        xor d 
0ea0 21 b3 fb		        ld hl,LFSRSeed+6 
0ea3 11 b4 fb		        ld de,LFSRSeed+7 
0ea6 01 07 00		        ld bc,7 
0ea9 ed b8		        lddr 
0eab 12			        ld (de),a 
0eac c9			        ret 
0ead			 
0ead			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ead			 
0ead			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ead			 
0ead			 
0ead			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ead			 
0ead			prng16: 
0ead			;Inputs: 
0ead			;   (seed1) contains a 16-bit seed value 
0ead			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ead			;Outputs: 
0ead			;   HL is the result 
0ead			;   BC is the result of the LCG, so not that great of quality 
0ead			;   DE is preserved 
0ead			;Destroys: 
0ead			;   AF 
0ead			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ead			;160cc 
0ead			;26 bytes 
0ead 2a a5 fb		    ld hl,(seed1) 
0eb0 44			    ld b,h 
0eb1 4d			    ld c,l 
0eb2 29			    add hl,hl 
0eb3 29			    add hl,hl 
0eb4 2c			    inc l 
0eb5 09			    add hl,bc 
0eb6 22 a5 fb		    ld (seed1),hl 
0eb9 2a a3 fb		    ld hl,(seed2) 
0ebc 29			    add hl,hl 
0ebd 9f			    sbc a,a 
0ebe e6 2d		    and %00101101 
0ec0 ad			    xor l 
0ec1 6f			    ld l,a 
0ec2 22 a3 fb		    ld (seed2),hl 
0ec5 09			    add hl,bc 
0ec6 c9			    ret 
0ec7			 
0ec7			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0ec7			 
0ec7			rand32: 
0ec7			;Inputs: 
0ec7			;   (seed1_0) holds the lower 16 bits of the first seed 
0ec7			;   (seed1_1) holds the upper 16 bits of the first seed 
0ec7			;   (seed2_0) holds the lower 16 bits of the second seed 
0ec7			;   (seed2_1) holds the upper 16 bits of the second seed 
0ec7			;   **NOTE: seed2 must be non-zero 
0ec7			;Outputs: 
0ec7			;   HL is the result 
0ec7			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0ec7			;Destroys: 
0ec7			;   AF 
0ec7			;Tested and passes all CAcert tests 
0ec7			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0ec7			;it has a period of 18,446,744,069,414,584,320 
0ec7			;roughly 18.4 quintillion. 
0ec7			;LFSR taps: 0,2,6,7  = 11000101 
0ec7			;291cc 
0ec7			;seed1_0=$+1 
0ec7			;    ld hl,12345 
0ec7			;seed1_1=$+1 
0ec7			;    ld de,6789 
0ec7			;    ld b,h 
0ec7			;    ld c,l 
0ec7			;    add hl,hl \ rl e \ rl d 
0ec7			;    add hl,hl \ rl e \ rl d 
0ec7			;    inc l 
0ec7			;    add hl,bc 
0ec7			;    ld (seed1_0),hl 
0ec7			;    ld hl,(seed1_1) 
0ec7			;    adc hl,de 
0ec7			;    ld (seed1_1),hl 
0ec7			;    ex de,hl 
0ec7			;seed2_0=$+1 
0ec7			;    ld hl,9876 
0ec7			;seed2_1=$+1 
0ec7			;    ld bc,54321 
0ec7			;    add hl,hl \ rl c \ rl b 
0ec7			;    ld (seed2_1),bc 
0ec7			;    sbc a,a 
0ec7			;    and %11000101 
0ec7			;    xor l 
0ec7			;    ld l,a 
0ec7			;    ld (seed2_0),hl 
0ec7			;    ex de,hl 
0ec7			;    add hl,bc 
0ec7			;    ret 
0ec7			; 
0ec7			 
0ec7			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0ec7			; 20 bytes, 86 cycles (excluding ret) 
0ec7			 
0ec7			; returns   hl = pseudorandom number 
0ec7			; corrupts   a 
0ec7			 
0ec7			; generates 16-bit pseudorandom numbers with a period of 65535 
0ec7			; using the xorshift method: 
0ec7			 
0ec7			; hl ^= hl << 7 
0ec7			; hl ^= hl >> 9 
0ec7			; hl ^= hl << 8 
0ec7			 
0ec7			; some alternative shift triplets which also perform well are: 
0ec7			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0ec7			 
0ec7			;  org 32768 
0ec7			 
0ec7			xrnd: 
0ec7 2a a9 fb		  ld hl,(xrandc)       ; seed must not be 0 
0eca 3e 00		  ld a,0 
0ecc bd			  cp l 
0ecd 20 02		  jr nz, .xrnd1 
0ecf 2e 01		  ld l, 1 
0ed1			.xrnd1: 
0ed1			 
0ed1 7c			  ld a,h 
0ed2 1f			  rra 
0ed3 7d			  ld a,l 
0ed4 1f			  rra 
0ed5 ac			  xor h 
0ed6 67			  ld h,a 
0ed7 7d			  ld a,l 
0ed8 1f			  rra 
0ed9 7c			  ld a,h 
0eda 1f			  rra 
0edb ad			  xor l 
0edc 6f			  ld l,a 
0edd ac			  xor h 
0ede 67			  ld h,a 
0edf			 
0edf 22 a9 fb		  ld (xrandc),hl 
0ee2			 
0ee2 c9			  ret 
0ee3			;  
0ee3			 
0ee3			 
0ee3			;;;; int maths 
0ee3			 
0ee3			; https://map.grauw.nl/articles/mult_div_shifts.php 
0ee3			; Divide 16-bit values (with 16-bit result) 
0ee3			; In: Divide BC by divider DE 
0ee3			; Out: BC = result, HL = rest 
0ee3			; 
0ee3			Div16: 
0ee3 21 00 00		    ld hl,0 
0ee6 78			    ld a,b 
0ee7 06 08		    ld b,8 
0ee9			Div16_Loop1: 
0ee9 17			    rla 
0eea ed 6a		    adc hl,hl 
0eec ed 52		    sbc hl,de 
0eee 30 01		    jr nc,Div16_NoAdd1 
0ef0 19			    add hl,de 
0ef1			Div16_NoAdd1: 
0ef1 10 f6		    djnz Div16_Loop1 
0ef3 17			    rla 
0ef4 2f			    cpl 
0ef5 47			    ld b,a 
0ef6 79			    ld a,c 
0ef7 48			    ld c,b 
0ef8 06 08		    ld b,8 
0efa			Div16_Loop2: 
0efa 17			    rla 
0efb ed 6a		    adc hl,hl 
0efd ed 52		    sbc hl,de 
0eff 30 01		    jr nc,Div16_NoAdd2 
0f01 19			    add hl,de 
0f02			Div16_NoAdd2: 
0f02 10 f6		    djnz Div16_Loop2 
0f04 17			    rla 
0f05 2f			    cpl 
0f06 41			    ld b,c 
0f07 4f			    ld c,a 
0f08 c9			ret 
0f09			 
0f09			 
0f09			;http://z80-heaven.wikidot.com/math 
0f09			; 
0f09			;Inputs: 
0f09			;     DE and A are factors 
0f09			;Outputs: 
0f09			;     A is not changed 
0f09			;     B is 0 
0f09			;     C is not changed 
0f09			;     DE is not changed 
0f09			;     HL is the product 
0f09			;Time: 
0f09			;     342+6x 
0f09			; 
0f09			Mult16: 
0f09			 
0f09 06 08		     ld b,8          ;7           7 
0f0b 21 00 00		     ld hl,0         ;10         10 
0f0e 29			       add hl,hl     ;11*8       88 
0f0f 07			       rlca          ;4*8        32 
0f10 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f12 19			         add hl,de   ;--         -- 
0f13 10 f9		       djnz $-5      ;13*7+8     99 
0f15 c9			ret 
0f16			 
0f16			; 
0f16			; Square root of 16-bit value 
0f16			; In:  HL = value 
0f16			; Out:  D = result (rounded down) 
0f16			; 
0f16			;Sqr16: 
0f16			;    ld de,#0040 
0f16			;    ld a,l 
0f16			;    ld l,h 
0f16			;    ld h,d 
0f16			;    or a 
0f16			;    ld b,8 
0f16			;Sqr16_Loop: 
0f16			;    sbc hl,de 
0f16			;    jr nc,Sqr16_Skip 
0f16			;    add hl,de 
0f16			;Sqr16_Skip: 
0f16			;    ccf 
0f16			;    rl d 
0f16			;    add a,a 
0f16			;    adc hl,hl 
0f16			;    add a,a 
0f16			;    adc hl,hl 
0f16			;    djnz Sqr16_Loop 
0f16			;    ret 
0f16			; 
0f16			; 
0f16			; Divide 8-bit values 
0f16			; In: Divide E by divider C 
0f16			; Out: A = result, B = rest 
0f16			; 
0f16			Div8: 
0f16 af			    xor a 
0f17 06 08		    ld b,8 
0f19			Div8_Loop: 
0f19 cb 13		    rl e 
0f1b 17			    rla 
0f1c 91			    sub c 
0f1d 30 01		    jr nc,Div8_NoAdd 
0f1f 81			    add a,c 
0f20			Div8_NoAdd: 
0f20 10 f7		    djnz Div8_Loop 
0f22 47			    ld b,a 
0f23 7b			    ld a,e 
0f24 17			    rla 
0f25 2f			    cpl 
0f26 c9			    ret 
0f27			 
0f27			; 
0f27			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f27			; In: Multiply A with DE 
0f27			; Out: HL = result 
0f27			; 
0f27			Mult12U: 
0f27 2e 00		    ld l,0 
0f29 87			    add a,a 
0f2a 30 01		    jr nc,Mult12U_NoAdd0 
0f2c 19			    add hl,de 
0f2d			Mult12U_NoAdd0: 
0f2d 29			    add hl,hl 
0f2e 87			    add a,a 
0f2f 30 01		    jr nc,Mult12U_NoAdd1 
0f31 19			    add hl,de 
0f32			Mult12U_NoAdd1: 
0f32 29			    add hl,hl 
0f33 87			    add a,a 
0f34 30 01		    jr nc,Mult12U_NoAdd2 
0f36 19			    add hl,de 
0f37			Mult12U_NoAdd2: 
0f37 29			    add hl,hl 
0f38 87			    add a,a 
0f39 30 01		    jr nc,Mult12U_NoAdd3 
0f3b 19			    add hl,de 
0f3c			Mult12U_NoAdd3: 
0f3c 29			    add hl,hl 
0f3d 87			    add a,a 
0f3e 30 01		    jr nc,Mult12U_NoAdd4 
0f40 19			    add hl,de 
0f41			Mult12U_NoAdd4: 
0f41 29			    add hl,hl 
0f42 87			    add a,a 
0f43 30 01		    jr nc,Mult12U_NoAdd5 
0f45 19			    add hl,de 
0f46			Mult12U_NoAdd5: 
0f46 29			    add hl,hl 
0f47 87			    add a,a 
0f48 30 01		    jr nc,Mult12U_NoAdd6 
0f4a 19			    add hl,de 
0f4b			Mult12U_NoAdd6: 
0f4b 29			    add hl,hl 
0f4c 87			    add a,a 
0f4d d0			    ret nc 
0f4e 19			    add hl,de 
0f4f c9			    ret 
0f50			 
0f50			; 
0f50			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f50			; In: Multiply A with DE 
0f50			;      Put lowest value in A for most efficient calculation 
0f50			; Out: HL = result 
0f50			; 
0f50			Mult12R: 
0f50 21 00 00		    ld hl,0 
0f53			Mult12R_Loop: 
0f53 cb 3f		    srl a 
0f55 30 01		    jr nc,Mult12R_NoAdd 
0f57 19			    add hl,de 
0f58			Mult12R_NoAdd: 
0f58 cb 23		    sla e 
0f5a cb 12		    rl d 
0f5c b7			    or a 
0f5d c2 53 0f		    jp nz,Mult12R_Loop 
0f60 c9			    ret 
0f61			 
0f61			; 
0f61			; Multiply 16-bit values (with 32-bit result) 
0f61			; In: Multiply BC with DE 
0f61			; Out: BCHL = result 
0f61			; 
0f61			Mult32: 
0f61 79			    ld a,c 
0f62 48			    ld c,b 
0f63 21 00 00		    ld hl,0 
0f66 06 10		    ld b,16 
0f68			Mult32_Loop: 
0f68 29			    add hl,hl 
0f69 17			    rla 
0f6a cb 11		    rl c 
0f6c 30 07		    jr nc,Mult32_NoAdd 
0f6e 19			    add hl,de 
0f6f ce 00		    adc a,0 
0f71 d2 75 0f		    jp nc,Mult32_NoAdd 
0f74 0c			    inc c 
0f75			Mult32_NoAdd: 
0f75 10 f1		    djnz Mult32_Loop 
0f77 41			    ld b,c 
0f78 4f			    ld c,a 
0f79 c9			    ret 
0f7a			 
0f7a			 
0f7a			 
0f7a			; 
0f7a			; Multiply 8-bit values 
0f7a			; In:  Multiply H with E 
0f7a			; Out: HL = result 
0f7a			; 
0f7a			Mult8: 
0f7a 16 00		    ld d,0 
0f7c 6a			    ld l,d 
0f7d 06 08		    ld b,8 
0f7f			Mult8_Loop: 
0f7f 29			    add hl,hl 
0f80 30 01		    jr nc,Mult8_NoAdd 
0f82 19			    add hl,de 
0f83			Mult8_NoAdd: 
0f83 10 fa		    djnz Mult8_Loop 
0f85 c9			    ret 
0f86			 
0f86			 
0f86			 
0f86			 
0f86			 
0f86			 
0f86			 
0f86			 
0f86			;;http://z80-heaven.wikidot.com/math 
0f86			;;This divides DE by BC, storing the result in DE, remainder in HL 
0f86			; 
0f86			;DE_Div_BC:          ;1281-2x, x is at most 16 
0f86			;     ld a,16        ;7 
0f86			;     ld hl,0        ;10 
0f86			;     jp $+5         ;10 
0f86			;.DivLoop: 
0f86			;       add hl,bc    ;-- 
0f86			;       dec a        ;64 
0f86			;       jr z,.DivLoopEnd        ;86 
0f86			; 
0f86			;       sla e        ;128 
0f86			;       rl d         ;128 
0f86			;       adc hl,hl    ;240 
0f86			;       sbc hl,bc    ;240 
0f86			;       jr nc,.DivLoop ;23|21 
0f86			;       inc e        ;-- 
0f86			;       jp .DivLoop+1 
0f86			; 
0f86			;.DivLoopEnd: 
0f86			 
0f86			;HL_Div_C: 
0f86			;Inputs: 
0f86			;     HL is the numerator 
0f86			;     C is the denominator 
0f86			;Outputs: 
0f86			;     A is the remainder 
0f86			;     B is 0 
0f86			;     C is not changed 
0f86			;     DE is not changed 
0f86			;     HL is the quotient 
0f86			; 
0f86			;       ld b,16 
0f86			;       xor a 
0f86			;         add hl,hl 
0f86			;         rla 
0f86			;         cp c 
0f86			;         jr c,$+4 
0f86			;           inc l 
0f86			;           sub c 
0f86			;         djnz $-7 
0f86			 
0f86			; https://plutiedev.com/z80-add-8bit-to-16bit 
0f86			 
0f86			addatohl: 
0f86 85			    add   a, l    ; A = A+L 
0f87 6f			    ld    l, a    ; L = A+L 
0f88 8c			    adc   a, h    ; A = A+L+H+carry 
0f89 95			    sub   l       ; A = H+carry 
0f8a 67			    ld    h, a    ; H = H+carry 
0f8b c9			ret 
0f8c			 
0f8c			addatode: 
0f8c 83			    add   a, e    ; A = A+L 
0f8d 5f			    ld    e, a    ; L = A+L 
0f8e 8a			    adc   a, d    ; A = A+L+H+carry 
0f8f 93			    sub   e       ; A = H+carry 
0f90 57			    ld    d, a    ; H = H+carry 
0f91 c9			ret 
0f92			 
0f92			 
0f92			addatobc: 
0f92 81			    add   a, c    ; A = A+L 
0f93 4f			    ld    c, a    ; L = A+L 
0f94 88			    adc   a, b    ; A = A+L+H+carry 
0f95 91			    sub   c       ; A = H+carry 
0f96 47			    ld    b, a    ; H = H+carry 
0f97 c9			ret 
0f98			 
0f98			subafromhl: 
0f98			   ; If A=0 do nothing 
0f98			    ; Otherwise flip A's sign. Since 
0f98			    ; the upper byte becomes -1, also 
0f98			    ; substract 1 from H. 
0f98 ed 44		    neg 
0f9a ca a3 0f		    jp    z, Skip 
0f9d 25			    dec   h 
0f9e			     
0f9e			    ; Now add the low byte as usual 
0f9e			    ; Two's complement takes care of 
0f9e			    ; ensuring the result is correct 
0f9e 85			    add   a, l 
0f9f 6f			    ld    l, a 
0fa0 8c			    adc   a, h 
0fa1 95			    sub   l 
0fa2 67			    ld    h, a 
0fa3			Skip: 
0fa3 c9				ret 
0fa4			 
0fa4			 
0fa4			; compare hl and de 
0fa4			; returns:  
0fa4			; if hl = de, z=1, s=0, c0=0 
0fa4			; if hl > de, z=0, s=0, c=0 
0fa4			; if hl < de, z=0, s=1, c=1 
0fa4			cmp16:	 
0fa4 b7				or a 
0fa5 ed 52			sbc hl,de 
0fa7 e0				ret po 
0fa8 7c				ld a,h 
0fa9 1f				rra 
0faa ee 40			xor 01000000B 
0fac 37				scf 
0fad 8f				adc a,a 
0fae c9				ret 
0faf			 
0faf			 
0faf			; test if hl contains zero   - A is destroyed 
0faf			 
0faf			ishlzero:    
0faf b7				or a     ; reset flags 
0fb0 7c				ld a, h 
0fb1 b5				or l        	 
0fb2			 
0fb2 c9				ret 
0fb3			 
0fb3			 
0fb3			 
0fb3			 
0fb3			if FORTH_ENABLE_FLOATMATH 
0fb3			;include "float/bbcmath.z80" 
0fb3			include "float/lpfpcalc.asm" 
0fb3			endif 
0fb3			 
0fb3			 
0fb3			; eof 
0fb3			 
# End of file firmware_maths.asm
0fb3			include "firmware_strings.asm"   ; string handling  
0fb3			 
0fb3			 
0fb3			; TODO string len 
0fb3			; input text string, end on cr with zero term 
0fb3			; a offset into frame buffer to start prompt 
0fb3			; d is max length 
0fb3			; e is display size TODO 
0fb3			; c is current cursor position 
0fb3			; hl is ptr to where string will be stored 
0fb3			 
0fb3			 
0fb3			; TODO check limit of buffer for new inserts 
0fb3			; TODO check insert does not push beyond buffer 
0fb3			; TODO scroll in a limited display area 
0fb3			; TODO scroll whole screen on page wrap 
0fb3			 
0fb3			 
0fb3			; TODO handle KEY_PREVWORD 
0fb3			; TODO handle KEY_NEXTWORD 
0fb3			; TODO handle KEY_HOME 
0fb3			; TODO handle KEY_END 
0fb3			; TODO use LCD cursor? 
0fb3			 
0fb3 32 64 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0fb6 81					add c 
0fb7 32 62 fe				ld (input_at_cursor),a	; save draw pos of cursor 
0fba 22 67 fe				ld (input_start), hl     ; save ptr to buffer 
0fbd 79					ld a, c 
0fbe cd 86 0f				call addatohl 
0fc1 22 69 fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0fc4 7a					ld a,d 
0fc5 32 66 fe			        ld (input_size), a       ; save length of input area 
0fc8 79					ld a, c 
0fc9 32 55 fe				ld (input_cursor),a      ; init cursor start position  
0fcc 7b					ld a,e 
0fcd 32 65 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0fd0					 
0fd0					 
0fd0			 
0fd0			;		ld a,(input_ptr) 
0fd0			;		ld (input_under_cursor),a 	; save what is under the cursor 
0fd0			 
0fd0			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0fd0					; init cursor shape if not set by the cin routines 
0fd0 21 c1 fb				ld hl, cursor_shape 
0fd3 3e ff				ld a, 255 
0fd5 77					ld (hl), a 
0fd6 23					inc hl 
0fd7 3e 00				ld a, 0 
0fd9 77					ld (hl), a 
0fda			 
0fda 3e 0f				ld a, CUR_BLINK_RATE 
0fdc 32 60 fe				ld (input_cur_flash), a 
0fdf 3e 01				ld a, 1 
0fe1 32 5f fe				ld (input_cur_onoff),a 
0fe4			 
0fe4			;	if DEBUG_INPUT 
0fe4			;		push af 
0fe4			;		ld a, 'I' 
0fe4			;		ld (debug_mark),a 
0fe4			;		pop af 
0fe4			;		CALLMONITOR 
0fe4			;	endif 
0fe4			.is1:		; main entry loop 
0fe4			 
0fe4			 
0fe4			 
0fe4					; pause 1ms 
0fe4			 
0fe4 3e 01				ld a, 1 
0fe6 cd 7a 0c				call aDelayInMS 
0fe9			 
0fe9					; dec flash counter 
0fe9 3a 60 fe				ld a, (input_cur_flash) 
0fec 3d					dec a 
0fed 32 60 fe				ld (input_cur_flash), a 
0ff0 fe 00				cp 0 
0ff2 20 0d				jr nz, .nochgstate 
0ff4			 
0ff4			 
0ff4					; change state 
0ff4 3a 5f fe				ld a,(input_cur_onoff) 
0ff7 ed 44				neg 
0ff9 32 5f fe				ld (input_cur_onoff),a 
0ffc			 
0ffc			 
0ffc					; reset on change of state 
0ffc 3e 0f				ld a, CUR_BLINK_RATE 
0ffe 32 60 fe				ld (input_cur_flash), a 
1001			 
1001			.nochgstate: 
1001					 
1001					 
1001			 
1001					; display cursor  
1001			 
1001			;		ld hl, (input_start) 
1001			;		ld a, (input_cursor) 
1001			;		call addatohl 
1001			 
1001					; get char under cursor and replace with cursor 
1001 2a 69 fe		ld hl, (input_ptr) 
1004			;		ld a, (hl) 
1004			;		ld (input_under_cursor),a 
1004			;		ld a, '_' 
1004			;		ld (hl), a 
1004			 
1004					; display string 
1004			 
1004 ed 5b 67 fe			ld de, (input_start) 
1008 3a 64 fe				ld a, (input_at_pos) 
100b cd 65 0d				call str_at_display 
100e			;	        call update_display 
100e			 
100e					; find place to put the cursor 
100e			;		add h 
100e			;		ld l, display_row_1 
100e			;		sub l 
100e			; (input_at_pos) 
100e					;ld c, a 
100e			;		ld a, (input_cursor) 
100e			;		ld l, (input_at_pos) 
100e			;		;ld b, h 
100e			;		add l 
100e			;		ld (input_at_cursor),a 
100e					;ld l,h 
100e			 
100e			;		ld h, 0 
100e			;		ld l,(input_at_pos) 
100e			;		ld a, (input_cursor) 
100e			;		call addatohl 
100e			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
100e			;		call subafromhl 
100e			;		ld a,l 
100e			;		ld (input_at_cursor), a 
100e			 
100e				if DEBUG_INPUT 
100e					ld a, (hardware_diag) 
100e					cp 0 
100e					jr z, .skip_input_diag 
100e			 
100e					ld a,(input_at_pos) 
100e					ld hl, LFSRSeed 
100e					call hexout 
100e					ld a, (input_cursor) 
100e					ld hl, LFSRSeed+2 
100e					call hexout 
100e					ld a,(input_at_cursor) 
100e					ld hl, LFSRSeed+4 
100e					call hexout 
100e			 
100e					ld a,(input_cur_onoff) 
100e					ld hl, LFSRSeed+6 
100e					call hexout 
100e			 
100e					ld a,(input_cur_flash) 
100e					ld hl, LFSRSeed+8 
100e					call hexout 
100e			 
100e					ld a,(input_len) 
100e					ld hl, LFSRSeed+10 
100e					call hexout 
100e					ld hl, LFSRSeed+12 
100e					ld a, 0 
100e					ld (hl),a 
100e					ld a, display_row_4 
100e					ld de, LFSRSeed 
100e					call str_at_display 
100e					.skip_input_diag: 
100e				endif 
100e			 
100e					; decide on if we are showing the cursor this time round 
100e			 
100e 3a 5f fe				ld a, (input_cur_onoff) 
1011 fe ff				cp 255 
1013 28 13				jr z, .skipcur 
1015			 
1015			 
1015 3a 62 fe				ld a,(input_at_cursor) 
1018 11 c1 fb				ld de, cursor_shape 
101b cd 65 0d				call str_at_display 
101e			 
101e					; save length of current input string 
101e 2a 67 fe				ld hl, (input_start) 
1021 cd e4 13				call strlenz 
1024 7d					ld a,l 
1025 32 5a fe				ld (input_len),a 
1028			 
1028			.skipcur: 
1028			 
1028 cd 75 0d			        call update_display 
102b					 
102b			 
102b			 
102b					; wait 
102b				 
102b					; TODO loop without wait to flash the cursor and char under cursor	 
102b cd a1 78				call cin    ; _wait 
102e			 
102e fe 00				cp 0 
1030 ca e4 0f				jp z, .is1 
1033			 
1033					; get ptr to char to input into 
1033			 
1033 4f					ld c,a 
1034 2a 67 fe				ld hl, (input_start) 
1037 3a 55 fe				ld a, (input_cursor) 
103a cd 86 0f				call addatohl 
103d 22 69 fe				ld (input_ptr), hl 
1040 79					ld a,c 
1041			 
1041					; replace char under cursor 
1041			 
1041			;		ld hl, (input_ptr) 
1041			;		ld a, (input_under_cursor) 	; get what is under the cursor 
1041			;		ld (hl), a 
1041			 
1041			;	if DEBUG_INPUT 
1041			;		push af 
1041			;		ld a, 'i' 
1041			;		ld (debug_mark),a 
1041			;		pop af 
1041			;		CALLMONITOR 
1041			;	endif 
1041 fe 0e				cp KEY_HOME 
1043 20 0e				jr nz, .iske 
1045			 
1045 3a 64 fe				ld a, (input_at_pos) 
1048 32 62 fe				ld (input_at_cursor),a 
104b 3e 00				ld a, 0 
104d 32 55 fe				ld (input_cursor), a 
1050 c3 e4 0f				jp .is1 
1053					 
1053 fe 0f		.iske:		cp KEY_END 
1055 20 03				jr nz, .isknw 
1057 c3 e4 0f				jp .is1 
105a			 
105a fe 06		.isknw:		cp KEY_NEXTWORD 
105c 20 1b				jr nz, .iskpw 
105e			 
105e 2a 69 fe		.isknwm:	ld hl, (input_ptr) 
1061 7e					ld a,(hl)	 
1062 fe 00				cp 0 
1064 ca e4 0f				jp z, .is1    ; end of string 
1067 fe 20				cp ' ' 
1069 ca e4 0f				jp z, .is1    ; end of word 
106c 23					inc hl 
106d 22 69 fe				ld (input_ptr), hl 
1070 3a 62 fe				ld a, (input_at_cursor) 
1073 3c					inc a 
1074 32 62 fe				ld (input_at_cursor), a 
1077 18 e5				jr .isknwm 
1079			 
1079 fe 07		.iskpw:		cp KEY_PREVWORD 
107b 20 1b				jr nz, .iskl 
107d			.iskpwm:	 
107d 2a 69 fe				ld hl, (input_ptr) 
1080 7e					ld a,(hl)	 
1081 fe 00				cp 0  
1083 ca e4 0f				jp z, .is1    ; end of string 
1086 fe 20				cp ' ' 
1088 ca e4 0f				jp z, .is1    ; end of word 
108b 2b					dec hl 
108c 22 69 fe				ld (input_ptr), hl 
108f 3a 62 fe				ld a, (input_at_cursor) 
1092 3d					dec a 
1093 32 62 fe				ld (input_at_cursor), a 
1096 18 e5				jr .iskpwm 
1098			 
1098			 
1098 fe 0b		.iskl:		cp KEY_LEFT 
109a 20 27				jr nz, .isk1 
109c			 
109c 3a 55 fe				ld a, (input_cursor) 
109f			 
109f fe 00				cp 0 
10a1 ca e4 0f				jp z, .is1 		; at start of line to ignore  
10a4			 
10a4 3d					dec  a 		; TODO check underflow 
10a5 32 55 fe				ld (input_cursor), a 
10a8			 
10a8 2a 69 fe				ld hl, (input_ptr) 
10ab 2b					dec hl 
10ac 22 69 fe				ld (input_ptr), hl 
10af					 
10af 3a 62 fe				ld a, (input_at_cursor) 
10b2 3d					dec a 
10b3 32 62 fe				ld (input_at_cursor), a 
10b6			 
10b6 3e 01				ld a, 1		; show cursor moving 
10b8 32 5f fe				ld (input_cur_onoff),a 
10bb 3e 0f				ld a, CUR_BLINK_RATE 
10bd 32 60 fe				ld (input_cur_flash), a 
10c0			 
10c0 c3 e4 0f				jp .is1 
10c3			 
10c3 fe 0c		.isk1:		cp KEY_RIGHT 
10c5 20 2a				jr nz, .isk2 
10c7			 
10c7 3a 5a fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
10ca 5f					ld e,a 
10cb 3a 55 fe				ld a, (input_cursor) 
10ce bb					cp e 
10cf ca e4 0f				jp z, .is1		; at the end of string so dont go right 
10d2			 
10d2 3c					inc  a 		; TODO check overflow 
10d3 32 55 fe				ld (input_cursor), a 
10d6			 
10d6 3a 62 fe				ld a, (input_at_cursor) 
10d9 3c					inc a 
10da 32 62 fe				ld (input_at_cursor), a 
10dd			 
10dd 2a 69 fe				ld hl, (input_ptr) 
10e0 23					inc hl 
10e1 22 69 fe				ld (input_ptr), hl 
10e4			 
10e4 3e 01				ld a, 1		; show cursor moving 
10e6 32 5f fe				ld (input_cur_onoff),a 
10e9 3e 0f				ld a, CUR_BLINK_RATE 
10eb 32 60 fe				ld (input_cur_flash), a 
10ee			 
10ee c3 e4 0f				jp .is1 
10f1			 
10f1 fe 05		.isk2:		cp KEY_UP 
10f3			 
10f3 20 26				jr nz, .isk3 
10f5			 
10f5					; swap last command with the current on 
10f5			 
10f5					; move cursor to start of string 
10f5 2a 67 fe				ld hl, (input_start) 
10f8 22 69 fe				ld (input_ptr), hl 
10fb			 
10fb 3a 64 fe				ld a, (input_at_pos) 
10fe 32 62 fe				ld (input_at_cursor), a 
1101			 
1101 3e 00				ld a, 0 
1103 32 55 fe				ld (input_cursor), a 
1106					 
1106					; swap input and last command buffers 
1106			 
1106 21 e8 f4				ld hl, os_cli_cmd 
1109 11 e7 f5				ld de, os_last_cmd 
110c 06 ff				ld b, 255 
110e 7e			.swap1:		ld a, (hl) 
110f 4f					ld c,a 
1110 1a					ld a, (de) 
1111 77					ld (hl), a 
1112 79					ld a,c 
1113 12					ld (de),a 
1114 23					inc hl 
1115 13					inc de 
1116 10 f6				djnz .swap1 
1118			 
1118			 
1118			 
1118			 
1118			 
1118 c3 e4 0f				jp .is1 
111b			 
111b fe 08		.isk3:		cp KEY_BS 
111d 20 3c				jr nz, .isk4 
111f			 
111f 3a 55 fe				ld a, (input_cursor) 
1122			 
1122 fe 00				cp 0 
1124 ca e4 0f				jp z, .is1 		; at start of line to ignore  
1127			 
1127 3d					dec  a 		; TODO check underflow 
1128 32 55 fe				ld (input_cursor), a 
112b			 
112b					; hl is source 
112b					; de needs to be source - 1 
112b			 
112b			;		ld a, 0 
112b			;		dec hl 
112b			;		ld (hl), a 
112b			 
112b 2a 69 fe				ld hl, (input_ptr) 
112e 2b					dec hl 
112f 22 69 fe				ld (input_ptr), hl 
1132			 
1132					; shift all data 
1132			 
1132 e5					push hl 
1133 23					inc hl 
1134 d1					pop de 
1135 3a 5a fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
1138 4f					ld c,a 
1139 06 00				ld b,0 
113b ed b0				ldir  
113d			 
113d			 
113d			 
113d			 
113d 3a 62 fe				ld a, (input_at_cursor) 
1140 3d					dec a 
1141 32 62 fe				ld (input_at_cursor), a 
1144			 
1144			 
1144 3e 01				ld a, 1		; show cursor moving 
1146 32 5f fe				ld (input_cur_onoff),a 
1149 3e 0f				ld a, CUR_BLINK_RATE 
114b 32 60 fe				ld (input_cur_flash), a 
114e			 
114e					; remove char 
114e 3a 62 fe				ld a, (input_at_cursor) 
1151 3c					inc a 
1152 11 dc 11				ld de,.iblank 
1155 cd 65 0d				call str_at_display 
1158			 
1158 c3 e4 0f				jp .is1 
115b			 
115b fe 0d		.isk4:		cp KEY_CR 
115d 28 6c				jr z, .endinput 
115f			 
115f					; else add the key press to the end 
115f			 
115f 4f					ld c, a			; save key pressed 
1160			 
1160 7e					ld a,(hl)		; get what is currently under char 
1161			 
1161 fe 00				cp 0			; we are at the end of the string 
1163 20 2f				jr nz, .onchar 
1165					 
1165					; add a char to the end of the string 
1165				 
1165 71					ld (hl),c 
1166 23					inc hl 
1167			;		ld a,' ' 
1167			;		ld (hl),a 
1167			;		inc hl 
1167 3e 00				ld a,0 
1169 77					ld (hl),a 
116a 2b					dec hl 
116b			 
116b 3a 55 fe				ld a, (input_cursor) 
116e 3c					inc a				; TODO check max string length and scroll  
116f 32 55 fe				ld (input_cursor), a		; inc cursor pos 
1172							 
1172 3a 62 fe				ld a, (input_at_cursor) 
1175 3c					inc a 
1176 32 62 fe				ld (input_at_cursor), a 
1179			 
1179 2a 69 fe				ld hl, (input_ptr) 
117c 23					inc hl 
117d 22 69 fe				ld (input_ptr), hl 
1180			 
1180 2a 69 fe				ld hl, (input_ptr) 
1183 23					inc hl 
1184 22 69 fe				ld (input_ptr), hl 
1187			;	if DEBUG_INPUT 
1187			;		push af 
1187			;		ld a, '+' 
1187			;		ld (debug_mark),a 
1187			;		pop af 
1187			;		CALLMONITOR 
1187			;	endif 
1187 3e 01				ld a, 1		; show cursor moving 
1189 32 5f fe				ld (input_cur_onoff),a 
118c 3e 0f				ld a, CUR_BLINK_RATE 
118e 32 60 fe				ld (input_cur_flash), a 
1191 c3 e4 0f				jp .is1 
1194					 
1194			 
1194			 
1194					; if on a char then insert 
1194			.onchar: 
1194			 
1194					; TODO over flow check: make sure insert does not blow out buffer 
1194			 
1194					; need to do some maths to use lddr 
1194			 
1194 e5					push hl   ; save char pos 
1195 c5					push bc 
1196			 
1196 2a 67 fe				ld hl, (input_start) 
1199 3a 5a fe				ld a, (input_len) 
119c cd 86 0f				call addatohl  		; end of string 
119f 23					inc hl 
11a0 23					inc hl		; past zero term 
11a1 e5					push hl 
11a2 23					inc hl 
11a3 e5					push hl  
11a4			 
11a4								; start and end of lddr set, now how much to move? 
11a4			 
11a4							 
11a4 3a 55 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11a7 47					ld b,a 
11a8 3a 5a fe				ld a,(input_len) 
11ab 5f					ld e,a 
11ac 90					sub b 
11ad 3c					inc a		;?? 
11ae 3c					inc a		;?? 
11af 3c					inc a		;?? 
11b0			 
11b0 06 00				ld b,0 
11b2 4f					ld c,a 
11b3			 
11b3				if DEBUG_INPUT 
11b3					push af 
11b3					ld a, 'i' 
11b3					ld (debug_mark),a 
11b3					pop af 
11b3			;		CALLMONITOR 
11b3				endif 
11b3 d1					pop de 
11b4 e1					pop hl 
11b5				if DEBUG_INPUT 
11b5					push af 
11b5					ld a, 'I' 
11b5					ld (debug_mark),a 
11b5					pop af 
11b5			;		CALLMONITOR 
11b5				endif 
11b5 ed b8				lddr 
11b7				 
11b7			 
11b7			 
11b7					; TODO have a key for insert/overwrite mode???? 
11b7 c1					pop bc 
11b8 e1					pop hl 
11b9 71					ld (hl), c		; otherwise overwrite current char 
11ba					 
11ba			 
11ba			 
11ba			 
11ba 3a 55 fe				ld a, (input_cursor) 
11bd 3c					inc  a 		; TODO check overflow 
11be 32 55 fe				ld (input_cursor), a 
11c1			 
11c1 3a 62 fe				ld a, (input_at_cursor) 
11c4 3c					inc a 
11c5 32 62 fe				ld (input_at_cursor), a 
11c8			 
11c8 c3 e4 0f				jp .is1 
11cb			 
11cb			.endinput:	; TODO look for end of string 
11cb			 
11cb					; add trailing space for end of token 
11cb			 
11cb 2a 67 fe				ld hl, (input_start) 
11ce 3a 5a fe				ld a,(input_len) 
11d1 cd 86 0f				call addatohl 
11d4 3e 20				ld a, ' ' 
11d6 77					ld (hl),a 
11d7					; TODO eof of parse marker 
11d7			 
11d7 23					inc hl 
11d8 3e 00				ld a, 0 
11da 77					ld (hl),a 
11db			 
11db			 
11db c9					ret 
11dc			 
11dc .. 00		.iblank: db " ",0 
11de			 
11de			 
11de 32 64 fe		input_str_prev:	ld (input_at_pos), a 
11e1 22 67 fe				ld (input_start), hl 
11e4 3e 01				ld a,1			; add cursor 
11e6 77					ld (hl),a 
11e7 23					inc hl 
11e8 3e 00				ld a,0 
11ea 77					ld (hl),a 
11eb 22 69 fe				ld (input_ptr), hl 
11ee 7a					ld a,d 
11ef 32 66 fe				ld (input_size), a 
11f2 3e 00				ld a,0 
11f4 32 55 fe				ld (input_cursor),a 
11f7			.instr1:	 
11f7			 
11f7					; TODO do block cursor 
11f7					; TODO switch cursor depending on the modifer key 
11f7			 
11f7					; update cursor shape change on key hold 
11f7			 
11f7 2a 69 fe				ld hl, (input_ptr) 
11fa 2b					dec hl 
11fb 3a c1 fb				ld a,(cursor_shape) 
11fe 77					ld (hl), a 
11ff			 
11ff					; display entered text 
11ff 3a 64 fe				ld a,(input_at_pos) 
1202 cd 65 76		            	CALL fLCD_Pos       ;Position cursor to location in A 
1205 ed 5b 67 fe	            	LD   de, (input_start) 
1209 cd 87 76		            	CALL fLCD_Str       ;Display string pointed to by DE 
120c			 
120c cd a1 78				call cin 
120f fe 00				cp 0 
1211 28 e4				jr z, .instr1 
1213			 
1213					; proecess keyboard controls first 
1213			 
1213 2a 69 fe				ld hl,(input_ptr) 
1216			 
1216 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1218 28 5a				jr z, .instrcr 
121a			 
121a fe 08				cp KEY_BS 	; back space 
121c 20 0f				jr nz, .instr2 
121e					; process back space 
121e			 
121e					; TODO stop back space if at start of string 
121e 2b					dec hl 
121f 2b					dec hl ; to over write cursor 
1220 3a c1 fb				ld a,(cursor_shape) 
1223					;ld a,0 
1223 77					ld (hl),a 
1224 23					inc hl 
1225 3e 20				ld a," " 
1227 77					ld (hl),a 
1228 22 69 fe				ld (input_ptr),hl 
122b					 
122b			 
122b 18 ca				jr .instr1 
122d			 
122d fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
122f 20 06				jr nz, .instr3 
1231 2b					dec hl 
1232 22 69 fe				ld (input_ptr),hl 
1235 18 c0				jr .instr1 
1237				 
1237 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
1239 20 06				jr nz, .instr4 
123b 23					inc hl 
123c 22 69 fe				ld (input_ptr),hl 
123f 18 b6				jr .instr1 
1241			 
1241 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1243 20 06				jr nz, .instr5 
1245 2b					dec hl 
1246 22 69 fe				ld (input_ptr),hl 
1249 18 ac				jr .instr1 
124b			 
124b fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
124d 20 06				jr nz, .instr6 
124f 2b					dec hl 
1250 22 69 fe				ld (input_ptr),hl 
1253 18 a2				jr .instr1 
1255 fe 05		.instr6:        cp KEY_UP      ; recall last command 
1257 20 0b				jr nz, .instrnew 
1259			 
1259 21 c1 f1			ld hl, scratch 
125c 11 e7 f5			ld de, os_last_cmd 
125f cd 7d 12			call strcpy 
1262 18 93				jr .instr1 
1264			 
1264			 
1264			.instrnew:	; no special key pressed to see if we have room to store it 
1264			 
1264					; TODO do string size test 
1264			 
1264 2b					dec hl ; to over write cursor 
1265 77					ld (hl),a 
1266 23					inc hl 
1267 3a c1 fb				ld a,(cursor_shape) 
126a 77					ld (hl),a 
126b 23					inc hl 
126c 3e 00				ld a,0 
126e 77					ld (hl),a 
126f			 
126f 22 69 fe				ld (input_ptr),hl 
1272					 
1272 18 83				jr .instr1 
1274 2b			.instrcr:	dec hl		; remove cursor 
1275 3e 20				ld a,' '	; TODO add a trailing space for safety 
1277 77					ld (hl),a 
1278 23					inc hl 
1279 3e 00				ld a,0 
127b 77					ld (hl),a 
127c			 
127c			 
127c					; if at end of line scroll up    
127c					; TODO detecting only end of line 4 for scroll up  
127c			 
127c					;ld   
127c			 
127c c9					ret 
127d			 
127d			 
127d			; strcpy hl = dest, de source 
127d			 
127d 1a			strcpy:   LD   A, (DE)        ;Get character from string 
127e b7			            OR   A              ;Null terminator? 
127f c8			            RET  Z              ;Yes, so finished 
1280 1a					ld a,(de) 
1281 77					ld (hl),a 
1282 13			            INC  DE             ;Point to next character 
1283 23					inc hl 
1284 18 f7		            JR   strcpy       ;Repeat 
1286 c9					ret 
1287			 
1287			 
1287			; TODO string_at  
1287			; pass string which starts with lcd offset address and then null term string 
1287			 
1287			; TODO string to dec 
1287			; TODO string to hex 
1287			; TODO byte to string hex 
1287			; TODO byte to string dec 
1287			 
1287			 
1287			 
1287			; from z80uartmonitor 
1287			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1287			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
1287			; pass hl for where to put the text 
1287			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1287 c5			hexout:	PUSH BC 
1288 f5					PUSH AF 
1289 47					LD B, A 
128a					; Upper nybble 
128a cb 3f				SRL A 
128c cb 3f				SRL A 
128e cb 3f				SRL A 
1290 cb 3f				SRL A 
1292 cd a2 12				CALL tohex 
1295 77					ld (hl),a 
1296 23					inc hl	 
1297					 
1297					; Lower nybble 
1297 78					LD A, B 
1298 e6 0f				AND 0FH 
129a cd a2 12				CALL tohex 
129d 77					ld (hl),a 
129e 23					inc hl	 
129f					 
129f f1					POP AF 
12a0 c1					POP BC 
12a1 c9					RET 
12a2					 
12a2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12a2			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
12a2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
12a2			tohex: 
12a2 e5					PUSH HL 
12a3 d5					PUSH DE 
12a4 16 00				LD D, 0 
12a6 5f					LD E, A 
12a7 21 af 12				LD HL, .DATA 
12aa 19					ADD HL, DE 
12ab 7e					LD A, (HL) 
12ac d1					POP DE 
12ad e1					POP HL 
12ae c9					RET 
12af			 
12af			.DATA: 
12af 30					DEFB	30h	; 0 
12b0 31					DEFB	31h	; 1 
12b1 32					DEFB	32h	; 2 
12b2 33					DEFB	33h	; 3 
12b3 34					DEFB	34h	; 4 
12b4 35					DEFB	35h	; 5 
12b5 36					DEFB	36h	; 6 
12b6 37					DEFB	37h	; 7 
12b7 38					DEFB	38h	; 8 
12b8 39					DEFB	39h	; 9 
12b9 41					DEFB	41h	; A 
12ba 42					DEFB	42h	; B 
12bb 43					DEFB	43h	; C 
12bc 44					DEFB	44h	; D 
12bd 45					DEFB	45h	; E 
12be 46					DEFB	46h	; F 
12bf			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
12bf			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
12bf			;;    subtract $30, if result > 9 then subtract $7 more 
12bf			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
12bf			atohex: 
12bf d6 30				SUB $30 
12c1 fe 0a				CP 10 
12c3 f8					RET M		; If result negative it was 0-9 so we're done 
12c4 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
12c6 c9					RET		 
12c7			 
12c7			 
12c7			 
12c7			 
12c7			; Get 2 ASCII characters as hex byte from pointer in hl 
12c7			 
12c7			BYTERD: 
12c7 16 00			LD	D,00h		;Set up 
12c9 cd d1 12			CALL	HEXCON		;Get byte and convert to hex 
12cc 87				ADD	A,A		;First nibble so 
12cd 87				ADD	A,A		;multiply by 16 
12ce 87				ADD	A,A		; 
12cf 87				ADD	A,A		; 
12d0 57				LD	D,A		;Save hi nibble in D 
12d1			HEXCON: 
12d1 7e				ld a, (hl)		;Get next chr 
12d2 23				inc hl 
12d3 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
12d5 fe 0a			CP	00Ah		;Is it 0-9 ? 
12d7 38 02			JR	C,NALPHA	;If so miss next bit 
12d9 d6 07			SUB	007h		;Else convert alpha 
12db			NALPHA: 
12db b2				OR	D		;Add hi nibble back 
12dc c9				RET			; 
12dd			 
12dd			 
12dd			; 
12dd			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
12dd			; Since the routines get_byte and therefore get_nibble are called, only valid 
12dd			; characters (0-9a-f) are accepted. 
12dd			; 
12dd			;get_word        push    af 
12dd			;                call    get_byte        ; Get the upper byte 
12dd			;                ld      h, a 
12dd			;                call    get_byte        ; Get the lower byte 
12dd			;                ld      l, a 
12dd			;                pop     af 
12dd			;                ret 
12dd			; 
12dd			; Get a byte in hexadecimal notation. The result is returned in A. Since 
12dd			; the routine get_nibble is used only valid characters are accepted - the  
12dd			; input routine only accepts characters 0-9a-f. 
12dd			; 
12dd c5			get_byte:        push    bc              ; Save contents of B (and C) 
12de 7e					ld a,(hl) 
12df 23					inc hl 
12e0 cd 05 13		                call    nibble2val      ; Get upper nibble 
12e3 cb 07		                rlc     a 
12e5 cb 07		                rlc     a 
12e7 cb 07		                rlc     a 
12e9 cb 07		                rlc     a 
12eb 47			                ld      b, a            ; Save upper four bits 
12ec 7e					ld a,(hl) 
12ed cd 05 13		                call    nibble2val      ; Get lower nibble 
12f0 b0			                or      b               ; Combine both nibbles 
12f1 c1			                pop     bc              ; Restore B (and C) 
12f2 c9			                ret 
12f3			; 
12f3			; Get a hexadecimal digit from the serial line. This routine blocks until 
12f3			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
12f3			; to the serial line interface. The lower 4 bits of A contain the value of  
12f3			; that particular digit. 
12f3			; 
12f3			;get_nibble      ld a,(hl)           ; Read a character 
12f3			;                call    to_upper        ; Convert to upper case 
12f3			;                call    is_hex          ; Was it a hex digit? 
12f3			;                jr      nc, get_nibble  ; No, get another character 
12f3			 ;               call    nibble2val      ; Convert nibble to value 
12f3			 ;               call    print_nibble 
12f3			 ;               ret 
12f3			; 
12f3			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
12f3			; A valid hexadecimal digit is denoted by a set C flag. 
12f3			; 
12f3			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
12f3			;                ret     nc              ; Yes 
12f3			;                cp      '0'             ; Less than '0'? 
12f3			;                jr      nc, is_hex_1    ; No, continue 
12f3			;                ccf                     ; Complement carry (i.e. clear it) 
12f3			;                ret 
12f3			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
12f3			;                ret     c               ; Yes 
12f3			;                cp      'A'             ; Less than 'A'? 
12f3			;                jr      nc, is_hex_2    ; No, continue 
12f3			;                ccf                     ; Yes - clear carry and return 
12f3			;                ret 
12f3			;is_hex_2        scf                     ; Set carry 
12f3			;                ret 
12f3			; 
12f3			; Convert a single character contained in A to upper case: 
12f3			; 
12f3 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
12f5 d8			                ret     c 
12f6 fe 7b		                cp      'z' + 1         ; > 'z'? 
12f8 d0			                ret     nc              ; Nothing to do, either 
12f9 e6 5f		                and     $5f             ; Convert to upper case 
12fb c9			                ret 
12fc			 
12fc			 
12fc			to_lower: 
12fc			 
12fc			   ; if char is in [A-Z] make it lower case 
12fc			 
12fc			   ; enter : a = char 
12fc			   ; exit  : a = lower case char 
12fc			   ; uses  : af 
12fc			 
12fc fe 41		   cp 'A' 
12fe d8			   ret c 
12ff			    
12ff fe 5b		   cp 'Z'+1 
1301 d0			   ret nc 
1302			    
1302 f6 20		   or $20 
1304 c9			   ret 
1305			 
1305			; 
1305			; Expects a hexadecimal digit (upper case!) in A and returns the 
1305			; corresponding value in A. 
1305			; 
1305 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1307 38 02		                jr      c, nibble2val_1 ; Yes 
1309 d6 07		                sub     7               ; Adjust for A-F 
130b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
130d e6 0f		                and     $f              ; Only return lower 4 bits 
130f c9			                ret 
1310			; 
1310			; Print_nibble prints a single hex nibble which is contained in the lower  
1310			; four bits of A: 
1310			; 
1310			;print_nibble    push    af              ; We won't destroy the contents of A 
1310			;                and     $f              ; Just in case... 
1310			;                add     a, '0'             ; If we have a digit we are done here. 
1310			;                cp      '9' + 1         ; Is the result > 9? 
1310			;                jr      c, print_nibble_1 
1310			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1310			;print_nibble_1  call    putc            ; Print the nibble and 
1310			;                pop     af              ; restore the original value of A 
1310			;                ret 
1310			;; 
1310			;; Send a CR/LF pair: 
1310			; 
1310			;crlf            push    af 
1310			;                ld      a, cr 
1310			;                call    putc 
1310			;                ld      a, lf 
1310			;                call    putc 
1310			;                pop     af 
1310			;                ret 
1310			; 
1310			; Print_word prints the four hex digits of a word to the serial line. The  
1310			; word is expected to be in HL. 
1310			; 
1310			;print_word      push    hl 
1310			;                push    af 
1310			;                ld      a, h 
1310			;                call    print_byte 
1310			;                ld      a, l 
1310			;                call    print_byte 
1310			;                pop     af 
1310			;                pop     hl 
1310			;                ret 
1310			; 
1310			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1310			; The byte to be printed is expected to be in A. 
1310			; 
1310			;print_byte      push    af              ; Save the contents of the registers 
1310			;                push    bc 
1310			;                ld      b, a 
1310			;                rrca 
1310			;                rrca 
1310			;                rrca 
1310			;                rrca 
1310			;                call    print_nibble    ; Print high nibble 
1310			;                ld      a, b 
1310			;                call    print_nibble    ; Print low nibble 
1310			;                pop     bc              ; Restore original register contents 
1310			;                pop     af 
1310			;                ret 
1310			 
1310			 
1310			 
1310			 
1310			 
1310			fourehexhl:  
1310 7e				ld a,(hl) 
1311 cd bf 12			call atohex 
1314 cb 3f				SRL A 
1316 cb 3f				SRL A 
1318 cb 3f				SRL A 
131a cb 3f				SRL A 
131c 47				ld b, a 
131d 23				inc hl 
131e 7e				ld a,(hl) 
131f 23				inc hl 
1320 cd bf 12			call atohex 
1323 80				add b 
1324 57				ld d,a 
1325 7e				ld a,(hl) 
1326 cd bf 12			call atohex 
1329 cb 3f				SRL A 
132b cb 3f				SRL A 
132d cb 3f				SRL A 
132f cb 3f				SRL A 
1331 47				ld b, a 
1332 23				inc hl 
1333 7e				ld a,(hl) 
1334 23				inc hl 
1335 cd bf 12			call atohex 
1338 80				add b 
1339 5f				ld e, a 
133a d5				push de 
133b e1				pop hl 
133c c9				ret 
133d			 
133d			; pass hl. returns z set if the byte at hl is a digit 
133d			;isdigithl:  
133d			;	push bc 
133d			;	ld a,(hl) 
133d			;	cp ':' 
133d			;	jr nc, .isdf 		; > 
133d			;	cp '0' 
133d			;	jr c, .isdf		; < 
133d			; 
133d			;	; TODO find a better way to set z 
133d			; 
133d			;	ld b,a 
133d			;	cp b 
133d			;	pop bc 
133d			;	ret 
133d			; 
133d			;.isdf:	; not digit so clear z 
133d			; 
133d			;	; TODO find a better way to unset z 
133d			; 
133d			;	ld b,a 
133d			;	inc b 
133d			;	cp b 
133d			; 
133d			;	pop bc 
133d			;	ret 
133d				 
133d				 
133d			 
133d			 
133d			; pass hl as the four byte address to load 
133d			 
133d			get_word_hl:  
133d e5				push hl 
133e cd dd 12			call get_byte 
1341				 
1341 47				ld b, a 
1342			 
1342 e1				pop hl 
1343 23				inc hl 
1344 23				inc hl 
1345			 
1345			; TODO not able to handle a-f  
1345 7e				ld a,(hl) 
1346			;	;cp ':' 
1346			;	cp 'g' 
1346			;	jr nc, .single_byte_hl 		; > 
1346			;	cp 'G' 
1346			;	jr nc, .single_byte_hl 		; > 
1346			;	cp '0' 
1346			;	jr c, .single_byte_hl		; < 
1346			 
1346				;call isdigithl 
1346 fe 00			cp 0 
1348 28 06			jr z, .single_byte_hl 
134a			 
134a			.getwhln:   ; hex word so get next byte 
134a			 
134a cd dd 12			call get_byte 
134d 6f				ld l, a 
134e 60				ld h,b 
134f c9				ret 
1350 68			.single_byte_hl:   ld l,b 
1351 26 00				ld h,0 
1353 c9					ret 
1354			 
1354			 
1354			 
1354			 
1354 21 b1 1d			ld hl,asc+1 
1357			;	ld a, (hl) 
1357			;	call nibble2val 
1357 cd dd 12			call get_byte 
135a			 
135a			;	call fourehexhl 
135a 32 f5 f1			ld (scratch+52),a 
135d				 
135d 21 f3 f1			ld hl,scratch+50 
1360 22 e4 f4			ld (os_cur_ptr),hl 
1363			 
1363 c9				ret 
1364			 
1364			 
1364			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
1364			 
1364			; Decimal Unsigned Version 
1364			 
1364			;Number in a to decimal ASCII 
1364			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
1364			;Example: display a=56 as "056" 
1364			;input: a = number 
1364			;Output: a=0,value of a in the screen 
1364			;destroys af,bc (don't know about hl and de) 
1364			DispAToASCII: 
1364 0e 9c			ld	c,-100 
1366 cd 70 13			call	.Na1 
1369 0e f6			ld	c,-10 
136b cd 70 13			call	.Na1 
136e 0e ff			ld	c,-1 
1370 06 2f		.Na1:	ld	b,'0'-1 
1372 04			.Na2:	inc	b 
1373 81				add	a,c 
1374 38 fc			jr	c,.Na2 
1376 91				sub	c		;works as add 100/10/1 
1377 f5				push af		;safer than ld c,a 
1378 78				ld	a,b		;char is in b 
1379			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1379 f1				pop af		;safer than ld a,c 
137a c9				ret 
137b			 
137b			; Decimal Signed Version 
137b			 
137b			; DispA 
137b			; -------------------------------------------------------------- 
137b			; Converts a signed integer value to a zero-terminated ASCII 
137b			; string representative of that value (using radix 10). 
137b			; -------------------------------------------------------------- 
137b			; INPUTS: 
137b			;     HL     Value to convert (two's complement integer). 
137b			;     DE     Base address of string destination. (pointer). 
137b			; -------------------------------------------------------------- 
137b			; OUTPUTS: 
137b			;     None 
137b			; -------------------------------------------------------------- 
137b			; REGISTERS/MEMORY DESTROYED 
137b			; AF HL 
137b			; -------------------------------------------------------------- 
137b			 
137b			;DispHLToASCII: 
137b			;   push    de 
137b			;   push    bc 
137b			; 
137b			;; Detect sign of HL. 
137b			;    bit    7, h 
137b			;    jr     z, ._DoConvert 
137b			; 
137b			;; HL is negative. Output '-' to string and negate HL. 
137b			;    ld     a, '-' 
137b			;    ld     (de), a 
137b			;    inc    de 
137b			; 
137b			;; Negate HL (using two's complement) 
137b			;    xor    a 
137b			;    sub    l 
137b			;    ld     l, a 
137b			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
137b			;    sbc    a, h 
137b			;    ld     h, a 
137b			; 
137b			;; Convert HL to digit characters 
137b			;._DoConvert: 
137b			;    ld     b, 0     ; B will count character length of number 
137b			;-   ld     a, 10 
137b			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
137b			;    push   af 
137b			;    inc    b 
137b			;    ld     a, h 
137b			;    or     l 
137b			;    jr     nz, - 
137b			; 
137b			;; Retrieve digits from stack 
137b			;-   pop    af 
137b			;    or     $30 
137b			;    ld     (de), a 
137b			;    inc    de 
137b			;    djnz   - 
137b			; 
137b			;; Terminate string with NULL 
137b			;    xor    a 
137b			;    ld     (de), a 
137b			; 
137b			;    pop    bc 
137b			;    pop    de 
137b			;    ret 
137b			 
137b			;Comments 
137b			; 
137b			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
137b			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
137b			;    Note that the output string will not be fixed-width. 
137b			; 
137b			;Example Usage 
137b			; 
137b			;    ld    hl, -1004 
137b			;    ld    de, OP1 
137b			;    call  DispA 
137b			;    ld    hl, OP1 
137b			;    syscall  PutS 
137b			 
137b			 
137b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
137b			 
137b			 
137b			;Converts an ASCII string to an unsigned 16-bit integer 
137b			;Quits when it reaches a non-decimal digit 
137b			 
137b			string_to_uint16: 
137b			atoui_16: 
137b			;Input: 
137b			;     DE points to the string 
137b			;Outputs: 
137b			;     HL is the result 
137b			;     A is the 8-bit value of the number 
137b			;     DE points to the byte after the number 
137b			;Destroys: 
137b			;     BC 
137b			;       if the string is non-empty, BC is HL/10 
137b			;Size:  24 bytes 
137b			;Speed: 42+d(104+{0,9}) 
137b			;       d is the number of digits in the number 
137b			;       max is 640 cycles for a 5 digit number 
137b			;Assuming no leading zeros: 
137b			;1 digit:  146cc 
137b			;2 digit:  250cc 
137b			;3 digit:  354cc or 363cc (avg: 354.126cc) 
137b			;4 digit:  458cc or 467cc (avg: 458.27cc) 
137b			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
137b			;avg: 544.81158447265625cc (544+13297/16384) 
137b			;=============================================================== 
137b 21 00 00		  ld hl,0 
137e			.u16a: 
137e 1a			  ld a,(de) 
137f d6 30		  sub 30h 
1381 fe 0a		  cp 10 
1383 d0			  ret nc 
1384 13			  inc de 
1385 44			  ld b,h 
1386 4d			  ld c,l 
1387 29			  add hl,hl 
1388 29			  add hl,hl 
1389 09			  add hl,bc 
138a 29			  add hl,hl 
138b 85			  add a,l 
138c 6f			  ld l,a 
138d 30 ef		  jr nc,.u16a 
138f 24			  inc h 
1390 c3 7e 13		  jp .u16a 
1393			 
1393			 
1393			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1393			 
1393			;written by Zeda 
1393			;Converts a 16-bit unsigned integer to an ASCII string. 
1393			 
1393			uitoa_16: 
1393			;Input: 
1393			;   DE is the number to convert 
1393			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1393			;Output: 
1393			;   HL points to the null-terminated ASCII string 
1393			;      NOTE: This isn't necessarily the same as the input HL. 
1393 d5			  push de 
1394 c5			  push bc 
1395 f5			  push af 
1396 eb			  ex de,hl 
1397			 
1397 01 f0 d8		  ld bc,-10000 
139a 3e 2f		  ld a,'0'-1 
139c 3c			  inc a 
139d 09			  add hl,bc  
139e 38 fc		   jr c,$-2 
13a0 12			  ld (de),a 
13a1 13			  inc de 
13a2			 
13a2 01 e8 03		  ld bc,1000 
13a5 3e 3a		  ld a,'9'+1 
13a7 3d			  dec a  
13a8 09			  add hl,bc  
13a9 30 fc		   jr nc,$-2 
13ab 12			  ld (de),a 
13ac 13			  inc de 
13ad			 
13ad 01 9c ff		  ld bc,-100 
13b0 3e 2f		  ld a,'0'-1 
13b2 3c			  inc a  
13b3 09			  add hl,bc  
13b4 38 fc		   jr c,$-2 
13b6 12			  ld (de),a 
13b7 13			  inc de 
13b8			 
13b8 7d			  ld a,l 
13b9 26 3a		  ld h,'9'+1 
13bb 25			  dec h  
13bc c6 0a		  add a,10  
13be 30 fb		   jr nc,$-3 
13c0 c6 30		  add a,'0' 
13c2 eb			  ex de,hl 
13c3 72			  ld (hl),d 
13c4 23			  inc hl 
13c5 77			  ld (hl),a 
13c6 23			  inc hl 
13c7 36 00		  ld (hl),0 
13c9			 
13c9			;Now strip the leading zeros 
13c9 0e fa		  ld c,-6 
13cb 09			  add hl,bc 
13cc 3e 30		  ld a,'0' 
13ce 23			  inc hl  
13cf be			  cp (hl)  
13d0 28 fc		  jr z,$-2 
13d2			 
13d2			;Make sure that the string is non-empty! 
13d2 7e			  ld a,(hl) 
13d3 b7			  or a 
13d4 20 01		  jr nz,.atoub 
13d6 2b			  dec hl 
13d7			.atoub: 
13d7			 
13d7 f1			  pop af 
13d8 c1			  pop bc 
13d9 d1			  pop de 
13da c9			  ret 
13db			 
13db			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
13db			 
13db			toUpper: 
13db			;A is the char. 
13db			;If A is a lowercase letter, this sets it to the matching uppercase 
13db			;18cc or 30cc or 41cc 
13db			;avg: 26.75cc 
13db fe 61		  cp 'a' 
13dd d8			  ret c 
13de fe 7b		  cp 'z'+1 
13e0 d0			  ret nc 
13e1 d6 20		  sub 'a'-'A' 
13e3 c9			  ret 
13e4			 
13e4			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
13e4			 
13e4			; String Length 
13e4			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
13e4			 
13e4			; Get the length of the null-terminated string starting at $8000 hl 
13e4			;    LD     HL, $8000 
13e4			 
13e4			strlenz: 
13e4			 
13e4 af			    XOR    A               ; Zero is the value we are looking for. 
13e5 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
13e6 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
13e7			                           ; 65, 536 bytes (the entire addressable memory space). 
13e7 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13e9			 
13e9			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13e9 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
13ea 6f			    LD     L, A             ; number of bytes 
13eb ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13ed 2b			    DEC    HL              ; Compensate for null. 
13ee c9				ret 
13ef			 
13ef			; Get the length of the A terminated string starting at $8000 hl 
13ef			;    LD     HL, $8000 
13ef			 
13ef			strlent: 
13ef			 
13ef			                  ; A is the value we are looking for. 
13ef 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
13f1 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
13f3			                           ; 65, 536 bytes (the entire addressable memory space). 
13f3 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13f5			 
13f5			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13f5 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
13f7 2e 00		    LD     L, 0             ; number of bytes 
13f9 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13fb 2b			    DEC    HL              ; Compensate for null. 
13fc c9				ret 
13fd			 
13fd			 
13fd			;Comparing Strings 
13fd			 
13fd			;IN    HL     Address of string1. 
13fd			;      DE     Address of string2. 
13fd			 
13fd			; doc given but wrong??? 
13fd			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
13fd			;      carry  Set if string1 > string2, reset if string1 <= string2. 
13fd			; tested 
13fd			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
13fd			 
13fd			strcmp_old: 
13fd e5			    PUSH   HL 
13fe d5			    PUSH   DE 
13ff			 
13ff 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1400 be			    CP     (HL)            ; (want to minimize work). 
1401 38 01		    JR     C, Str1IsBigger 
1403 7e			    LD     A, (HL) 
1404			 
1404			Str1IsBigger: 
1404 4f			    LD     C, A             ; Put length in BC 
1405 06 00		    LD     B, 0 
1407 13			    INC    DE              ; Increment pointers to meat of string. 
1408 23			    INC    HL 
1409			 
1409			CmpLoop: 
1409 1a			    LD     A, (DE)          ; Compare bytes. 
140a ed a1		    CPI 
140c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
140e 13			    INC    DE              ; Update pointer. 
140f ea 09 14		    JP     PE, CmpLoop 
1412			 
1412 d1			    POP    DE 
1413 e1			    POP    HL 
1414 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1415 be			    CP     (HL) 
1416 c9			    RET 
1417			 
1417			NoMatch: 
1417 2b			    DEC    HL 
1418 be			    CP     (HL)            ; Compare again to affect carry. 
1419 d1			    POP    DE 
141a e1			    POP    HL 
141b c9			    RET 
141c			 
141c			;; test strmp 
141c			; 
141c			;ld de, .str1 
141c			;ld hl, .str2 
141c			;call strcmp 
141c			;jr z, .z1 
141c			;;this 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "NZ1" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			;.z1: 
141c			; 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "ZZ1" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			; 
141c			;ld de, .str1 
141c			;ld hl, .str1 
141c			;call strcmp 
141c			;jr z, .z2 
141c			;;this 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "NZ2" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			;.z2: 
141c			; 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "ZZ2" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			; 
141c			;ld de, .str1 
141c			;ld hl, .str2 
141c			;call strcmp 
141c			;jr c, .c1 
141c			; 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "Nc1" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			;.c1: 
141c			;;this 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "cc1" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			; 
141c			;ld de, .str1 
141c			;ld hl, .str1 
141c			;call strcmp 
141c			;jr c, .c2 
141c			;;this 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "Nc2" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			;.c2: 
141c			; 
141c			;	if DEBUG_FORTH_WORDS 
141c			;		DMARK "cc2" 
141c			;		CALLMONITOR 
141c			;	endif 
141c			;	NEXTW 
141c			;.str1:   db "string1",0 
141c			;.str2:   db "string2",0 
141c			 
141c			; only care about direct match or not 
141c			; hl and de strings 
141c			; zero set if the same 
141c			 
141c			strcmp: 
141c 1a				ld a, (de) 
141d be				cp (hl) 
141e 28 02			jr z, .ssame 
1420 b7				or a 
1421 c9				ret 
1422			 
1422			.ssame:  
1422 fe 00			cp 0 
1424 c8				ret z 
1425			 
1425 23				inc hl 
1426 13				inc de 
1427 18 f3			jr strcmp 
1429				 
1429				 
1429			 
1429			 
1429			 
1429			 
1429			; eof 
1429			 
1429			 
1429			 
1429			 
1429			 
1429			 
# End of file firmware_strings.asm
1429			include "firmware_memory.asm"   ; malloc and free  
1429			 
1429			if DEBUG_FORTH_MALLOC_HIGH 
1429			.mallocsize: db "Wants malloc >256",0 
1429			.mallocasize: db "MALLOC gives >256",0 
1429			.malloczero: db "MALLOC gives zero",0 
1429			 
1429			malloc_guard_zerolen: 
1429				push hl 
1429				push de 
1429				push af 
1429			 
1429				ld de, 0 
1429			        call cmp16 
1429				jr nz, .lowalloz 
1429			 
1429				push hl 
1429				push de 
1429					ld hl, display_fb0 
1429					ld (display_fb_active), hl 
1429				call clear_display 
1429				ld a, 0 
1429				ld de, .malloczero 
1429				call str_at_display 
1429				call update_display 
1429				call delay1s 
1429				call delay1s 
1429				call bp_on 
1429			;	ld a, 0 
1429			;	ld (os_view_disable), a 
1429			 
1429				pop de 
1429				pop hl 
1429			 
1429				 
1429			 
1429				CALLMONITOR 
1429			.lowalloz: 
1429			 
1429			 
1429				pop af 
1429				pop de 
1429				pop hl 
1429			ret 
1429			 
1429			malloc_guard_entry: 
1429				push hl 
1429				push de 
1429				push af 
1429			 
1429			 	or a      ;clear carry flag 
1429				push hl 
1429				ld de, 255 
1429				sbc hl, de 
1429				jr c, .lowalloc 
1429			 
1429				push de 
1429					ld hl, display_fb0 
1429					ld (display_fb_active), hl 
1429				call clear_display 
1429				ld a, 0 
1429				ld de, .mallocsize 
1429				call str_at_display 
1429				call update_display 
1429				call delay1s 
1429				call delay1s 
1429			;	ld a, 0 
1429			;	ld (os_view_disable), a 
1429				call bp_on 
1429			 
1429				pop de 
1429				pop hl 
1429			 
1429				 
1429			 
1429				CALLMONITOR 
1429				jr .lowdone 
1429			.lowalloc: 
1429			 
1429			 
1429				pop hl 
1429			.lowdone:	pop af 
1429				pop de 
1429				pop hl 
1429			ret 
1429			 
1429			malloc_guard_exit: 
1429				push hl 
1429				push de 
1429				push af 
1429			 
1429			 	or a      ;clear carry flag 
1429				push hl 
1429				ld de, 255 
1429				sbc hl, de 
1429				jr c, .lowallocx 
1429			 
1429				push de 
1429					ld hl, display_fb0 
1429					ld (display_fb_active), hl 
1429				call clear_display 
1429				ld a, 0 
1429				ld de, .mallocasize 
1429				call str_at_display 
1429				call update_display 
1429				call delay1s 
1429				call delay1s 
1429			;	ld a, 0 
1429			;	ld (os_view_disable), a 
1429				call bp_on 
1429				pop de 
1429				pop hl 
1429			 
1429				CALLMONITOR 
1429				jr .lowdonex 
1429			.lowallocx: 
1429			 
1429				pop hl 
1429			.lowdonex:	pop af 
1429				pop de 
1429				pop hl 
1429			ret 
1429			endif 
1429			 
1429			if MALLOC_2 
1429			; Z80 Malloc and Free Functions 
1429			 
1429			; Malloc Function: 
1429			; Input: 
1429			;   HL: Size of block to allocate 
1429			; Output: 
1429			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1429			 
1429			malloc: 
1429				 
1429			if DEBUG_FORTH_MALLOC_HIGH 
1429			call malloc_guard_entry 
1429			endif 
1429			 
1429			 
1429			 
1429			 
1429					if DEBUG_FORTH_MALLOC 
1429						DMARK "mal" 
1429						CALLMONITOR 
1429					endif 
1429			    push af            ; Save AF register 
1429			    ld a, l            ; Load low byte of size into A 
1429			    or h               ; Check if size is zero 
1429			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1429			 
1429			    ; Allocate memory 
1429			    ld hl, (heap_start) ; Load start of heap into HL 
1429					if DEBUG_FORTH_MALLOC 
1429						DMARK "ma1" 
1429						CALLMONITOR 
1429					endif 
1429			    call malloc_internal ; Call internal malloc function 
1429			    pop af             ; Restore AF register 
1429			if DEBUG_FORTH_MALLOC_HIGH 
1429			call malloc_guard_exit 
1429			call malloc_guard_zerolen 
1429			endif 
1429			    ret                ; Return 
1429			 
1429			; Free Function: 
1429			; Input: 
1429			;   HL: Pointer to memory block to free 
1429			; Output: 
1429			;   None 
1429			 
1429			free: 
1429			    push af            ; Save AF register 
1429			    ld a, l            ; Load low byte of pointer into A 
1429			    or h               ; Check if pointer is NULL 
1429			    jp z, free_exit    ; If pointer is NULL, exit 
1429			 
1429			    ; Free memory 
1429			    ld hl, (heap_start) ; Load start of heap into HL 
1429			    call free_internal  ; Call internal free function 
1429			    pop af             ; Restore AF register 
1429			    ret                ; Return 
1429			 
1429			; Internal Malloc Function: 
1429			; Input: 
1429			;   HL: Size of block to allocate 
1429			; Output: 
1429			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1429			 
1429			malloc_internal: 
1429			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1429			    add hl, bc         ; Add management overhead to requested size 
1429			    ex de, hl          ; Save total size in DE, and keep it in HL 
1429					if DEBUG_FORTH_MALLOC 
1429						DMARK "ma2" 
1429						CALLMONITOR 
1429					endif 
1429			 
1429			    ; Search for free memory block 
1429			    ld de, (heap_end)  ; Load end of heap into DE 
1429			    ld bc, 0           ; Initialize counter 
1429			 
1429					if DEBUG_FORTH_MALLOC 
1429						DMARK "ma2" 
1429						CALLMONITOR 
1429					endif 
1429			malloc_search_loop: 
1429			    ; Check if current block is free 
1429			    ld a, (hl)         ; Load current block's status (free or used) 
1429			    cp 0               ; Compare with zero (free) 
1429			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1429			 
1429			    ; Check if current block is large enough 
1429			    ld a, (hl+1)       ; Load high byte of block size 
1429			    cp l               ; Compare with low byte of requested size 
1429			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1429			 
1429			    ld a, (hl+2)       ; Load low byte of block size 
1429			    cp h               ; Compare with high byte of requested size 
1429			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1429			 
1429			    ; Mark block as used 
1429			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1429			 
1429			    ; Calculate remaining space in block 
1429			    ld bc, 0           ; Clear BC 
1429			    add hl, bc         ; Increment HL to point to start of data block 
1429			    add hl, de         ; HL = HL + DE (total size) 
1429			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1429			    add hl, bc         ; Add management overhead to start of data block 
1429			 
1429			    ; Save pointer to allocated block in HL 
1429			if DEBUG_FORTH_MALLOC_HIGH 
1429						DMARK "ma5" 
1429			call malloc_guard_exit 
1429			call malloc_guard_zerolen 
1429			endif 
1429			    ret 
1429			 
1429			malloc_skip_block_check: 
1429			    ; Move to the next block 
1429			    ld bc, 3           ; Size of management overhead 
1429			    add hl, bc         ; Move to the next block 
1429			    inc de             ; Increment counter 
1429			 
1429			    ; Check if we have reached the end of heap 
1429			    ld a, e            ; Load low byte of heap end address 
1429			    cp (hl)            ; Compare with low byte of current address 
1429			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1429			    ld a, d            ; Load high byte of heap end address 
1429			    cp 0               ; Check if it's zero (end of memory) 
1429			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1429			 
1429			    ; If we reached here, allocation failed 
1429			    xor a              ; Set result to NULL 
1429			if DEBUG_FORTH_MALLOC_HIGH 
1429						DMARK "ma6" 
1429			call malloc_guard_exit 
1429			call malloc_guard_zerolen 
1429			endif 
1429			    ret 
1429			malloc_exit: 
1429			if DEBUG_FORTH_MALLOC_HIGH 
1429						DMARK "ma7" 
1429			call malloc_guard_exit 
1429			call malloc_guard_zerolen 
1429			endif 
1429			    ret 
1429			 
1429			; Internal Free Function: 
1429			; Input: 
1429			;   HL: Pointer to memory block to free 
1429			; Output: 
1429			;   None 
1429			 
1429			free_internal: 
1429			    ld de, (heap_start) ; Load start of heap into DE 
1429			    ld bc, 0            ; Initialize counter 
1429			 
1429			free_search_loop: 
1429			    ; Check if current block contains the pointer 
1429			    ld a, l             ; Load low byte of pointer 
1429			    cp (hl+1)           ; Compare with high byte of current block's address 
1429			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1429			    ld a, h             ; Load high byte of pointer 
1429			    cp (hl+2)           ; Compare with low byte of current block's address 
1429			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1429			 
1429			    ; Mark block as free 
1429			    ld (hl), 0          ; Set status byte to indicate free block 
1429			    ret                 ; Return 
1429			 
1429			free_skip_block_check: 
1429			    ; Move to the next block 
1429			    ld bc, 3            ; Size of management overhead 
1429			    add hl, bc          ; Move to the next block 
1429			    inc de              ; Increment counter 
1429			 
1429			    ; Check if we have reached the end of heap 
1429			    ld a, e             ; Load low byte of heap end address 
1429			    cp (hl)             ; Compare with low byte of current address 
1429			    jr nz, free_search_loop  ; If not equal, continue searching 
1429			    ld a, d             ; Load high byte of heap end address 
1429			    cp 0                ; Check if it's zero (end of memory) 
1429			    jr nz, free_search_loop  ; If not zero, continue searching 
1429			 
1429			    ; If we reached here, pointer is not found in heap 
1429			    ret 
1429			 
1429			free_exit: 
1429			    ret                 ; Return 
1429			 
1429			; Define heap start and end addresses 
1429			;heap_start:    .dw 0xC000   ; Start of heap 
1429			;heap_end:      .dw 0xE000   ; End of heap 
1429			 
1429			endif 
1429			 
1429			 
1429			if MALLOC_1 
1429			 
1429			 
1429			 
1429			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1429			 
1429			;moved to firmware.asm 
1429			;heap_start        .equ  0x9000      ; Starting address of heap 
1429			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1429			 
1429			;      .org 0 
1429			;      jp    main 
1429			 
1429			 
1429			;      .org  0x100 
1429			;main: 
1429			;      ld    HL, 0x8100 
1429			;      ld    SP, HL 
1429			; 
1429			;      call  heap_init 
1429			; 
1429			;      ; Make some allocations 
1429			;      ld    HL, 12 
1429			;      call  malloc            ; Allocates 0x9004 
1429			; 
1429			;      ld    HL, 12 
1429			;      call  malloc            ; Allocates 0x9014 
1429			; 
1429			;      ld    HL, 12 
1429			;      call  malloc            ; Allocates 0x9024 
1429			; 
1429			;      ; Free some allocations 
1429			;      ld    HL, 0x9014 
1429			;      call  free 
1429			; 
1429			;      ld    HL, 0x9004 
1429			;      call  free 
1429			; 
1429			;      ld    HL, 0x9024 
1429			;      call  free 
1429			; 
1429			; 
1429			;      halt 
1429			 
1429			 
1429			;------------------------------------------------------------------------------ 
1429			;     heap_init                                                               : 
1429			;                                                                             : 
1429			; Description                                                                 : 
1429			;     Initialise the heap and make it ready for malloc and free operations.   : 
1429			;                                                                             : 
1429			;     The heap is maintained as a linked list, starting with an initial       : 
1429			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1429			;     the first free block in the heap. Each block then points to the next    : 
1429			;     free block within the heap, and the free list ends at the first block   : 
1429			;     with a null pointer to the next free block.                             : 
1429			;                                                                             : 
1429			; Parameters                                                                  : 
1429			;     Inputs are compile-time only. Two defines which specify the starting    : 
1429			;     address of the heap and its size are required, along with a memory      : 
1429			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1429			;     principally stores a pointer to the first free block in the heap.       : 
1429			;                                                                             : 
1429			; Returns                                                                     : 
1429			;     Nothing                                                                 : 
1429			;------------------------------------------------------------------------------ 
1429			heap_init: 
1429 e5			      push  HL 
142a			 
142a			      ; Initialise free list struct 
142a 21 0e 80		      ld    HL, heap_start 
142d 22 0a 80		      ld    (free_list), HL 
1430 21 00 00		      ld    HL, 0 
1433 22 0c 80		      ld    (free_list+2), HL 
1436			 
1436			      ; Insert first free block at bottom of heap, consumes entire heap 
1436 21 a4 f1		      ld    HL, heap_start+heap_size-4 
1439 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
143c 21 96 71		      ld    HL, heap_size-4 
143f 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1442			 
1442			      ; Insert end of free list block at top of heap - two null words will 
1442			      ; terminate the free list 
1442 21 00 00		      ld    HL, 0 
1445 22 a6 f1		      ld    (heap_start+heap_size-2), HL 
1448 22 a4 f1		      ld    (heap_start+heap_size-4), HL 
144b			 
144b e1			      pop   HL 
144c			 
144c c9			      ret 
144d			 
144d			 
144d			;------------------------------------------------------------------------------ 
144d			;     malloc                                                                  : 
144d			;                                                                             : 
144d			; Description                                                                 : 
144d			;     Allocates the wanted space from the heap and returns the address of the : 
144d			;     first useable byte of the allocation.                                   : 
144d			;                                                                             : 
144d			;     Allocations can happen in one of two ways:                              : 
144d			;                                                                             : 
144d			;     1. A free block may be found which is the exact size wanted. In this    : 
144d			;        case the block is removed from the free list and retuedn to the      : 
144d			;        caller.                                                              : 
144d			;     2. A free block may be found which is larger than the size wanted. In   : 
144d			;        this case, the larger block is split into two. The first portion of  : 
144d			;        this block will become the requested space by the malloc call and    : 
144d			;        is returned to the caller. The second portion becomes a new free     : 
144d			;        block, and the free list is adjusted to maintain continuity via this : 
144d			;        newly created block.                                                 : 
144d			;                                                                             : 
144d			;     malloc does not set any initial value in the allocated space, the       : 
144d			;     caller is required to do this as required.                              : 
144d			;                                                                             : 
144d			;     This implementation of malloc uses the stack exclusively, and is        : 
144d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
144d			;     advisable to disable interrupts before calling malloc, and recommended  : 
144d			;     to avoid the use of malloc inside ISRs in general.                      : 
144d			;                                                                             : 
144d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
144d			;                                                                             : 
144d			; Parameters                                                                  : 
144d			;     HL  Number of bytes wanted                                              : 
144d			;                                                                             : 
144d			; Returns                                                                     : 
144d			;     HL  Address of the first useable byte of the allocation                 : 
144d			;                                                                             : 
144d			; Flags                                                                       : 
144d			;     Z   Set if the allocation did not succeed, clear otherwise              : 
144d			;                                                                             : 
144d			; Stack frame                                                                 : 
144d			;       |             |                                                       : 
144d			;       +-------------+                                                       : 
144d			;       |     BC      |                                                       : 
144d			;       +-------------+                                                       : 
144d			;       |     DE      |                                                       : 
144d			;       +-------------+                                                       : 
144d			;       |     IX      |                                                       : 
144d			;       +-------------+                                                       : 
144d			;       |  prev_free  |                                                       : 
144d			;   +4  +-------------+                                                       : 
144d			;       |  this_free  |                                                       : 
144d			;   +2  +-------------+                                                       : 
144d			;       |  next_free  |                                                       : 
144d			;   +0  +-------------+                                                       : 
144d			;       |             |                                                       : 
144d			;                                                                             : 
144d			;------------------------------------------------------------------------------ 
144d			 
144d			 
144d			;malloc: 
144d			; 
144d			;	SAVESP ON 1 
144d			; 
144d			;	call malloc_code 
144d			; 
144d			;	CHECKSP ON 1 
144d			;	ret 
144d			 
144d			 
144d			malloc: 
144d c5			      push  BC 
144e d5			      push  DE 
144f dd e5		      push  IX 
1451			if DEBUG_FORTH_MALLOC_HIGH 
1451			call malloc_guard_entry 
1451			endif 
1451			 
1451					if DEBUG_FORTH_MALLOC 
1451						DMARK "mal" 
1451						CALLMONITOR 
1451					endif 
1451 7c			      ld    A, H                    ; Exit if no space requested 
1452 b5			      or    L 
1453 ca 12 15		      jp    Z, malloc_early_exit 
1456			 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			; 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			;inc hl 
1456			 
1456			 
1456			 
1456			 
1456					if DEBUG_FORTH_MALLOC 
1456						DMARK "maA" 
1456						CALLMONITOR 
1456					endif 
1456			      ; Set up stack frame 
1456 eb			      ex    DE, HL 
1457 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
145a 39			      add   HL, SP 
145b f9			      ld    SP, HL 
145c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1460 dd 39		      add   IX, SP 
1462			 
1462			      ; Setup initial state 
1462 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1465 19			      add   HL, DE 
1466			 
1466 44			      ld    B, H                    ; Move want to BC 
1467 4d			      ld    C, L 
1468			 
1468 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
146b dd 75 04		      ld    (IX+4), L 
146e dd 74 05		      ld    (IX+5), H 
1471			 
1471 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1472 23			      inc   HL 
1473 56			      ld    D, (HL) 
1474 dd 73 02		      ld    (IX+2), E 
1477 dd 72 03		      ld    (IX+3), D 
147a eb			      ex    DE, HL                  ; this_free ptr into HL 
147b			 
147b					if DEBUG_FORTH_MALLOC 
147b						DMARK "maB" 
147b						CALLMONITOR 
147b					endif 
147b			      ; Loop through free block list to find some space 
147b			malloc_find_space: 
147b 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
147c 23			      inc   HL 
147d 56			      ld    D, (HL) 
147e			 
147e 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
147f b3			      or    E 
1480 ca 0c 15		      jp    Z, malloc_no_space 
1483			 
1483 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1486 dd 72 01		      ld    (IX+1), D 
1489			 
1489			      ; Does this block have enough space to make the allocation? 
1489 23			      inc   HL                      ; Load free block size into DE 
148a 5e			      ld    E, (HL) 
148b 23			      inc   HL 
148c 56			      ld    D, (HL) 
148d			 
148d eb			      ex    DE, HL                  ; Check size of block against want 
148e b7			      or    A                       ; Ensure carry flag clear 
148f ed 42		      sbc   HL, BC 
1491 e5			      push  HL                      ; Store the result for later (new block size) 
1492			 
1492 ca e1 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1495 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1497			 
1497			      ; this_free block is not big enough, setup ptrs to test next free block 
1497 e1			      pop   HL                      ; Discard previous result 
1498			 
1498 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
149b dd 66 03		      ld    H, (IX+3) 
149e dd 75 04		      ld    (IX+4), L 
14a1 dd 74 05		      ld    (IX+5), H 
14a4			 
14a4 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
14a7 dd 66 01		      ld    H, (IX+1) 
14aa dd 75 02		      ld    (IX+2), L 
14ad dd 74 03		      ld    (IX+3), H 
14b0			 
14b0					if DEBUG_FORTH_MALLOC 
14b0						DMARK "MA>" 
14b0						CALLMONITOR 
14b0					endif 
14b0 18 c9		      jr    malloc_find_space 
14b2			 
14b2			      ; split a bigger block into two - requested size and remaining size 
14b2			malloc_alloc_split: 
14b2					if DEBUG_FORTH_MALLOC 
14b2						DMARK "MAs" 
14b2						CALLMONITOR 
14b2					endif 
14b2 eb			      ex    DE, HL                  ; Calculate address of new free block 
14b3 2b			      dec   HL 
14b4 2b			      dec   HL 
14b5 2b			      dec   HL 
14b6 09			      add   HL, BC 
14b7			 
14b7			      ; Create a new block and point it at next_free 
14b7 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
14ba dd 56 01		      ld    D, (IX+1) 
14bd			 
14bd 73			      ld    (HL), E                 ; Store next_free ptr into new block 
14be 23			      inc   HL 
14bf 72			      ld    (HL), D 
14c0			 
14c0 d1			      pop   DE                      ; Store size of new block into new block 
14c1 23			      inc   HL 
14c2 73			      ld    (HL), E 
14c3 23			      inc   HL 
14c4 72			      ld    (HL), D 
14c5			 
14c5			      ; Update this_free ptr to point to new block 
14c5 2b			      dec   HL 
14c6 2b			      dec   HL 
14c7 2b			      dec   HL 
14c8			 
14c8 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
14cb dd 56 03		      ld    D, (IX+3) 
14ce			 
14ce dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
14d1 dd 74 03		      ld    (IX+3), H 
14d4			 
14d4			      ; Modify this_free block to be allocation 
14d4 eb			      ex    DE, HL 
14d5 af			      xor   A                       ; Null the next block ptr of allocated block 
14d6 77			      ld    (HL), A 
14d7 23			      inc   HL 
14d8 77			      ld    (HL), A 
14d9			 
14d9 23			      inc   HL                      ; Store want size into allocated block 
14da 71			      ld    (HL), C 
14db 23			      inc   HL 
14dc 70			      ld    (HL), B 
14dd 23			      inc   HL 
14de e5			      push  HL                      ; Address of allocation to return 
14df			 
14df 18 19		      jr    malloc_update_links 
14e1			 
14e1			malloc_alloc_fit: 
14e1 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
14e2			 
14e2					if DEBUG_FORTH_MALLOC 
14e2						DMARK "MAf" 
14e2						CALLMONITOR 
14e2					endif 
14e2			      ; Modify this_free block to be allocation 
14e2 eb			      ex    DE, HL 
14e3 2b			      dec   HL 
14e4 2b			      dec   HL 
14e5 2b			      dec   HL 
14e6			 
14e6 af			      xor   A                       ; Null the next block ptr of allocated block 
14e7 77			      ld    (HL), A 
14e8 23			      inc   HL 
14e9 77			      ld    (HL), A 
14ea			 
14ea 23			      inc   HL                      ; Store address of allocation to return 
14eb 23			      inc   HL 
14ec 23			      inc   HL 
14ed e5			      push  HL 
14ee			 
14ee			      ; Copy next_free ptr to this_free, remove allocated block from free list 
14ee dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
14f1 dd 66 01		      ld    H, (IX+1) 
14f4			 
14f4 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
14f7 dd 74 03		      ld    (IX+3), H 
14fa			 
14fa			 
14fa			malloc_update_links: 
14fa			      ; Update prev_free ptr to point to this_free 
14fa dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
14fd dd 66 05		      ld    H, (IX+5) 
1500			 
1500 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1503 dd 56 03		      ld    D, (IX+3) 
1506			 
1506 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1507 23			      inc   HL 
1508 72			      ld    (HL), D 
1509			 
1509					if DEBUG_FORTH_MALLOC 
1509						DMARK "Mul" 
1509						CALLMONITOR 
1509					endif 
1509			      ; Clear the Z flag to indicate successful allocation 
1509 7a			      ld    A, D 
150a b3			      or    E 
150b			 
150b d1			      pop   DE                      ; Address of allocation 
150c					if DEBUG_FORTH_MALLOC 
150c						DMARK "MAu" 
150c						CALLMONITOR 
150c					endif 
150c			 
150c			malloc_no_space: 
150c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
150f 39			      add   HL, SP 
1510 f9			      ld    SP, HL 
1511			 
1511 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1512					if DEBUG_FORTH_MALLOC 
1512						DMARK "MAN" 
1512						CALLMONITOR 
1512					endif 
1512			 
1512			malloc_early_exit: 
1512					if DEBUG_FORTH_MALLOC 
1512						DMARK "MAx" 
1512						CALLMONITOR 
1512					endif 
1512 dd e1		      pop   IX 
1514 d1			      pop   DE 
1515 c1			      pop   BC 
1516			 
1516			if DEBUG_FORTH_MALLOC_HIGH 
1516			call malloc_guard_exit 
1516			call malloc_guard_zerolen 
1516			endif 
1516 c9			      ret 
1517			 
1517			 
1517			;------------------------------------------------------------------------------ 
1517			;     free                                                                    : 
1517			;                                                                             : 
1517			; Description                                                                 : 
1517			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1517			;     returned by malloc, otherwise the behaviour is undefined.               : 
1517			;                                                                             : 
1517			;     Where possible, directly adjacent free blocks will be merged together   : 
1517			;     into larger blocks to help ensure that the heap does not become         : 
1517			;     excessively fragmented.                                                 : 
1517			;                                                                             : 
1517			;     free does not clear or set any other value into the freed space, and    : 
1517			;     therefore its contents may be visible through subsequent malloc's. The  : 
1517			;     caller should clear the freed space as required.                        : 
1517			;                                                                             : 
1517			;     This implementation of free uses the stack exclusively, and is          : 
1517			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1517			;     advisable to disable interrupts before calling free, and recommended    : 
1517			;     to avoid the use of free inside ISRs in general.                        : 
1517			;                                                                             : 
1517			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1517			;                                                                             : 
1517			; Parameters                                                                  : 
1517			;     HL  Pointer to address of first byte of allocation to be freed          : 
1517			;                                                                             : 
1517			; Returns                                                                     : 
1517			;     Nothing                                                                 : 
1517			;                                                                             : 
1517			; Stack frame                                                                 : 
1517			;       |             |                                                       : 
1517			;       +-------------+                                                       : 
1517			;       |     BC      |                                                       : 
1517			;       +-------------+                                                       : 
1517			;       |     DE      |                                                       : 
1517			;       +-------------+                                                       : 
1517			;       |     IX      |                                                       : 
1517			;       +-------------+                                                       : 
1517			;       |  prev_free  |                                                       : 
1517			;   +2  +-------------+                                                       : 
1517			;       |  next_free  |                                                       : 
1517			;   +0  +-------------+                                                       : 
1517			;       |             |                                                       : 
1517			;                                                                             : 
1517			;------------------------------------------------------------------------------ 
1517			free: 
1517 c5			      push  BC 
1518 d5			      push  DE 
1519 dd e5		      push  IX 
151b			 
151b 7c			      ld    A, H                    ; Exit if ptr is null 
151c b5			      or    L 
151d ca e1 15		      jp    Z, free_early_exit 
1520			 
1520			      ; Set up stack frame 
1520 eb			      ex    DE, HL 
1521 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1524 39			      add   HL, SP 
1525 f9			      ld    SP, HL 
1526 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
152a dd 39		      add   IX, SP 
152c			 
152c			      ; The address in HL points to the start of the useable allocated space, 
152c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
152c			      ; address of the block itself. 
152c eb			      ex    DE, HL 
152d 11 fc ff		      ld    DE, -4 
1530 19			      add   HL, DE 
1531			 
1531			      ; An allocated block must have a null next block pointer in it 
1531 7e			      ld    A, (HL) 
1532 23			      inc   HL 
1533 b6			      or    (HL) 
1534 c2 dc 15		      jp    NZ, free_done 
1537			 
1537 2b			      dec   HL 
1538			 
1538 44			      ld    B, H                    ; Copy HL to BC 
1539 4d			      ld    C, L 
153a			 
153a			      ; Loop through the free list to find the first block with an address 
153a			      ; higher than the block being freed 
153a 21 0a 80		      ld    HL, free_list 
153d			 
153d			free_find_higher_block: 
153d 5e			      ld    E, (HL)                 ; Load next ptr from free block 
153e 23			      inc   HL 
153f 56			      ld    D, (HL) 
1540 2b			      dec   HL 
1541			 
1541 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1544 dd 72 01		      ld    (IX+1), D 
1547 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
154a dd 74 03		      ld    (IX+3), H 
154d			 
154d 78			      ld    A, B                    ; Check if DE is greater than BC 
154e ba			      cp    D                       ; Compare MSB first 
154f 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1551 30 04		      jr    NC, free_find_higher_block_skip 
1553 79			      ld    A, C 
1554 bb			      cp    E                       ; Then compare LSB 
1555 38 08		      jr    C, free_found_higher_block 
1557			 
1557			free_find_higher_block_skip: 
1557 7a			      ld    A, D                    ; Reached the end of the free list? 
1558 b3			      or    E 
1559 ca dc 15		      jp    Z, free_done 
155c			 
155c eb			      ex    DE, HL 
155d			 
155d 18 de		      jr    free_find_higher_block 
155f			 
155f			free_found_higher_block: 
155f			      ; Insert freed block between prev and next free blocks 
155f 71			      ld    (HL), C                 ; Point prev free block to freed block 
1560 23			      inc   HL 
1561 70			      ld    (HL), B 
1562			 
1562 60			      ld    H, B                    ; Point freed block at next free block 
1563 69			      ld    L, C 
1564 73			      ld    (HL), E 
1565 23			      inc   HL 
1566 72			      ld    (HL), D 
1567			 
1567			      ; Check if the freed block is adjacent to the next free block 
1567 23			      inc   HL                      ; Load size of freed block into HL 
1568 5e			      ld    E, (HL) 
1569 23			      inc   HL 
156a 56			      ld    D, (HL) 
156b eb			      ex    DE, HL 
156c			 
156c 09			      add   HL, BC                  ; Add addr of freed block and its size 
156d			 
156d dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1570 dd 56 01		      ld    D, (IX+1) 
1573			 
1573 b7			      or    A                       ; Clear the carry flag 
1574 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1576 20 22		      jr    NZ, free_check_adjacent_to_prev 
1578			 
1578			      ; Freed block is adjacent to next, merge into one bigger block 
1578 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1579 5e			      ld    E, (HL) 
157a 23			      inc   HL 
157b 56			      ld    D, (HL) 
157c e5			      push  HL                      ; Save ptr to next block for later 
157d			 
157d 60			      ld    H, B                    ; Store ptr from next block into freed block 
157e 69			      ld    L, C 
157f 73			      ld    (HL), E 
1580 23			      inc   HL 
1581 72			      ld    (HL), D 
1582			 
1582 e1			      pop   HL                      ; Restore ptr to next block 
1583 23			      inc   HL                      ; Load size of next block into DE 
1584 5e			      ld    E, (HL) 
1585 23			      inc   HL 
1586 56			      ld    D, (HL) 
1587 d5			      push  DE                      ; Save next block size for later 
1588			 
1588 60			      ld    H, B                    ; Load size of freed block into HL 
1589 69			      ld    L, C 
158a 23			      inc   HL 
158b 23			      inc   HL 
158c 5e			      ld    E, (HL) 
158d 23			      inc   HL 
158e 56			      ld    D, (HL) 
158f eb			      ex    DE, HL 
1590			 
1590 d1			      pop   DE                      ; Restore size of next block 
1591 19			      add   HL, DE                  ; Add sizes of both blocks 
1592 eb			      ex    DE, HL 
1593			 
1593 60			      ld    H, B                    ; Store new bigger size into freed block 
1594 69			      ld    L, C 
1595 23			      inc   HL 
1596 23			      inc   HL 
1597 73			      ld    (HL), E 
1598 23			      inc   HL 
1599 72			      ld    (HL), D 
159a			 
159a			free_check_adjacent_to_prev: 
159a			      ; Check if the freed block is adjacent to the prev free block 
159a dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
159d dd 66 03		      ld    H, (IX+3) 
15a0			 
15a0 23			      inc   HL                      ; Size of prev free block into DE 
15a1 23			      inc   HL 
15a2 5e			      ld    E, (HL) 
15a3 23			      inc   HL 
15a4 56			      ld    D, (HL) 
15a5 2b			      dec   HL 
15a6 2b			      dec   HL 
15a7 2b			      dec   HL 
15a8			 
15a8 19			      add   HL, DE                  ; Add prev block addr and size 
15a9			 
15a9 b7			      or    A                       ; Clear the carry flag 
15aa ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15ac 20 2e		      jr    NZ, free_done 
15ae			 
15ae			      ; Freed block is adjacent to prev, merge into one bigger block 
15ae 60			      ld    H, B                    ; Load next ptr from freed block into DE 
15af 69			      ld    L, C 
15b0 5e			      ld    E, (HL) 
15b1 23			      inc   HL 
15b2 56			      ld    D, (HL) 
15b3 e5			      push  HL                      ; Save freed block ptr for later 
15b4			 
15b4 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
15b7 dd 66 03		      ld    H, (IX+3) 
15ba 73			      ld    (HL), E 
15bb 23			      inc   HL 
15bc 72			      ld    (HL), D 
15bd			 
15bd e1			      pop   HL                      ; Restore freed block ptr 
15be 23			      inc   HL                      ; Load size of freed block into DE 
15bf 5e			      ld    E, (HL) 
15c0 23			      inc   HL 
15c1 56			      ld    D, (HL) 
15c2 d5			      push  DE                      ; Save freed block size for later 
15c3			 
15c3 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
15c6 dd 66 03		      ld    H, (IX+3) 
15c9 23			      inc   HL 
15ca 23			      inc   HL 
15cb 5e			      ld    E, (HL) 
15cc 23			      inc   HL 
15cd 56			      ld    D, (HL) 
15ce			 
15ce e1			      pop   HL                      ; Add sizes of both blocks 
15cf 19			      add   HL, DE 
15d0 eb			      ex    DE, HL 
15d1			 
15d1 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
15d4 dd 66 03		      ld    H, (IX+3) 
15d7 23			      inc   HL 
15d8 23			      inc   HL 
15d9 73			      ld    (HL), E 
15da 23			      inc   HL 
15db 72			      ld    (HL), D 
15dc			 
15dc			free_done: 
15dc 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
15df 39			      add   HL, SP 
15e0 f9			      ld    SP, HL 
15e1			 
15e1			free_early_exit: 
15e1 dd e1		      pop   IX 
15e3 d1			      pop   DE 
15e4 c1			      pop   BC 
15e5			 
15e5 c9			      ret 
15e6			 
15e6			; moved to firmware.asm 
15e6			; 
15e6			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15e6			;                  .dw   0 
15e6			 
15e6			 
15e6			endif 
15e6			 
15e6			 
15e6			if MALLOC_3 
15e6			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
15e6			;heap_start        .equ  0x9000      ; Starting address of heap 
15e6			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
15e6			; 
15e6			 ;     .org 0 
15e6			  ;    jp    main 
15e6			; 
15e6			; 
15e6			 ;     .org  0x100 
15e6			;main: 
15e6			 ;     ld    HL, 0x8100 
15e6			  ;    ld    SP, HL 
15e6			; 
15e6			;      call  heap_init 
15e6			 
15e6			      ; Make some allocations 
15e6			;      ld    HL, 12 
15e6			;      call  malloc            ; Allocates 0x9004 
15e6			; 
15e6			 ;     ld    HL, 12 
15e6			;      call  malloc            ; Allocates 0x9014 
15e6			 
15e6			;      ld    HL, 12 
15e6			;      call  malloc            ; Allocates 0x9024 
15e6			 
15e6			      ; Free some allocations 
15e6			;      ld    HL, 0x9014 
15e6			;      call  free 
15e6			 
15e6			;      ld    HL, 0x9004 
15e6			;      call  free 
15e6			; 
15e6			;      ld    HL, 0x9024 
15e6			;      call  free 
15e6			 
15e6			 
15e6			 ;     halt 
15e6			 
15e6			 
15e6			;------------------------------------------------------------------------------ 
15e6			;     heap_init                                                               : 
15e6			;                                                                             : 
15e6			; Description                                                                 : 
15e6			;     Initialise the heap and make it ready for malloc and free operations.   : 
15e6			;                                                                             : 
15e6			;     The heap is maintained as a linked list, starting with an initial       : 
15e6			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
15e6			;     the first free block in the heap. Each block then points to the next    : 
15e6			;     free block within the heap, and the free list ends at the first block   : 
15e6			;     with a null pointer to the next free block.                             : 
15e6			;                                                                             : 
15e6			; Parameters                                                                  : 
15e6			;     Inputs are compile-time only. Two defines which specify the starting    : 
15e6			;     address of the heap and its size are required, along with a memory      : 
15e6			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
15e6			;     principally stores a pointer to the first free block in the heap.       : 
15e6			;                                                                             : 
15e6			; Returns                                                                     : 
15e6			;     Nothing                                                                 : 
15e6			;------------------------------------------------------------------------------ 
15e6			heap_init: 
15e6			      push  HL 
15e6			 
15e6			      ; Initialise free list struct 
15e6			      ld    HL, heap_start 
15e6			      ld    (free_list), HL 
15e6			      ld    HL, 0 
15e6			      ld    (free_list+2), HL 
15e6			 
15e6			      ; Insert first free block at bottom of heap, consumes entire heap 
15e6			      ld    HL, heap_start+heap_size-4 
15e6			      ld    (heap_start), HL        ; Next block (end of free list) 
15e6			      ld    HL, heap_size-4 
15e6			      ld    (heap_start+2), HL      ; Block size 
15e6			 
15e6			      ; Insert end of free list block at top of heap - two null words will 
15e6			      ; terminate the free list 
15e6			      ld    HL, 0 
15e6			      ld    (heap_start+heap_size-2), HL 
15e6			      ld    (heap_start+heap_size-4), HL 
15e6			 
15e6			      pop   HL 
15e6			 
15e6			      ret 
15e6			 
15e6			 
15e6			;------------------------------------------------------------------------------ 
15e6			;     malloc                                                                  : 
15e6			;                                                                             : 
15e6			; Description                                                                 : 
15e6			;     Allocates the wanted space from the heap and returns the address of the : 
15e6			;     first useable byte of the allocation.                                   : 
15e6			;                                                                             : 
15e6			;     Allocations can happen in one of two ways:                              : 
15e6			;                                                                             : 
15e6			;     1. A free block may be found which is the exact size wanted. In this    : 
15e6			;        case the block is removed from the free list and retuedn to the      : 
15e6			;        caller.                                                              : 
15e6			;     2. A free block may be found which is larger than the size wanted. In   : 
15e6			;        this case, the larger block is split into two. The first portion of  : 
15e6			;        this block will become the requested space by the malloc call and    : 
15e6			;        is returned to the caller. The second portion becomes a new free     : 
15e6			;        block, and the free list is adjusted to maintain continuity via this : 
15e6			;        newly created block.                                                 : 
15e6			;                                                                             : 
15e6			;     malloc does not set any initial value in the allocated space, the       : 
15e6			;     caller is required to do this as required.                              : 
15e6			;                                                                             : 
15e6			;     This implementation of malloc uses the stack exclusively, and is        : 
15e6			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15e6			;     advisable to disable interrupts before calling malloc, and recommended  : 
15e6			;     to avoid the use of malloc inside ISRs in general.                      : 
15e6			;                                                                             : 
15e6			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15e6			;                                                                             : 
15e6			; Parameters                                                                  : 
15e6			;     HL  Number of bytes wanted                                              : 
15e6			;                                                                             : 
15e6			; Returns                                                                     : 
15e6			;     HL  Address of the first useable byte of the allocation                 : 
15e6			;                                                                             : 
15e6			; Flags                                                                       : 
15e6			;     Z   Set if the allocation did not succeed, clear otherwise              : 
15e6			;                                                                             : 
15e6			; Stack frame                                                                 : 
15e6			;       |             |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |     BC      |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |     DE      |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |     IX      |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |  prev_free  |                                                       : 
15e6			;   +4  +-------------+                                                       : 
15e6			;       |  this_free  |                                                       : 
15e6			;   +2  +-------------+                                                       : 
15e6			;       |  next_free  |                                                       : 
15e6			;   +0  +-------------+                                                       : 
15e6			;       |             |                                                       : 
15e6			;                                                                             : 
15e6			;------------------------------------------------------------------------------ 
15e6			malloc: 
15e6			      push  BC 
15e6			      push  DE 
15e6			      push  IX 
15e6			 
15e6			      ld    A, H                    ; Exit if no space requested 
15e6			      or    L 
15e6			      jp    Z, malloc_early_exit 
15e6			 
15e6			      ; Set up stack frame 
15e6			      ex    DE, HL 
15e6			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
15e6			      add   HL, SP 
15e6			      ld    SP, HL 
15e6			      ld    IX, 0                   ; Use IX as a frame pointer 
15e6			      add   IX, SP 
15e6			 
15e6			      ; Setup initial state 
15e6			      ld    HL, 4                   ; want must also include space used by block struct 
15e6			      add   HL, DE 
15e6			 
15e6			      ld    B, H                    ; Move want to BC 
15e6			      ld    C, L 
15e6			 
15e6			      ld    HL, free_list           ; Store prev_free ptr to stack 
15e6			      ld    (IX+4), L 
15e6			      ld    (IX+5), H 
15e6			 
15e6			      ld    E, (HL)                 ; Store this_free ptr to stack 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      ld    (IX+2), E 
15e6			      ld    (IX+3), D 
15e6			      ex    DE, HL                  ; this_free ptr into HL 
15e6			 
15e6			      ; Loop through free block list to find some space 
15e6			malloc_find_space: 
15e6			      ld    E, (HL)                 ; Load next_free ptr into DE 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			 
15e6			      ld    A, D                    ; Check for null next_free ptr - end of free list 
15e6			      or    E 
15e6			      jp    Z, malloc_no_space 
15e6			 
15e6			      ld    (IX+0), E               ; Store next_free ptr to stack 
15e6			      ld    (IX+1), D 
15e6			 
15e6			      ; Does this block have enough space to make the allocation? 
15e6			      inc   HL                      ; Load free block size into DE 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			 
15e6			      ex    DE, HL                  ; Check size of block against want 
15e6			      or    A                       ; Ensure carry flag clear 
15e6			      sbc   HL, BC 
15e6			      push  HL                      ; Store the result for later (new block size) 
15e6			 
15e6			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
15e6			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
15e6			 
15e6			      ; this_free block is not big enough, setup ptrs to test next free block 
15e6			      pop   HL                      ; Discard previous result 
15e6			 
15e6			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
15e6			      ld    H, (IX+3) 
15e6			      ld    (IX+4), L 
15e6			      ld    (IX+5), H 
15e6			 
15e6			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
15e6			      ld    H, (IX+1) 
15e6			      ld    (IX+2), L 
15e6			      ld    (IX+3), H 
15e6			 
15e6			      jr    malloc_find_space 
15e6			 
15e6			      ; split a bigger block into two - requested size and remaining size 
15e6			malloc_alloc_split: 
15e6			      ex    DE, HL                  ; Calculate address of new free block 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			      add   HL, BC 
15e6			 
15e6			      ; Create a new block and point it at next_free 
15e6			      ld    E, (IX+0)               ; Load next_free ptr into DE 
15e6			      ld    D, (IX+1) 
15e6			 
15e6			      ld    (HL), E                 ; Store next_free ptr into new block 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			      pop   DE                      ; Store size of new block into new block 
15e6			      inc   HL 
15e6			      ld    (HL), E 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			      ; Update this_free ptr to point to new block 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			 
15e6			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
15e6			      ld    D, (IX+3) 
15e6			 
15e6			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
15e6			      ld    (IX+3), H 
15e6			 
15e6			      ; Modify this_free block to be allocation 
15e6			      ex    DE, HL 
15e6			      xor   A                       ; Null the next block ptr of allocated block 
15e6			      ld    (HL), A 
15e6			      inc   HL 
15e6			      ld    (HL), A 
15e6			 
15e6			      inc   HL                      ; Store want size into allocated block 
15e6			      ld    (HL), C 
15e6			      inc   HL 
15e6			      ld    (HL), B 
15e6			      inc   HL 
15e6			      push  HL                      ; Address of allocation to return 
15e6			 
15e6			      jr    malloc_update_links 
15e6			 
15e6			malloc_alloc_fit: 
15e6			      pop   HL                      ; Dont need new block size, want is exact fit 
15e6			 
15e6			      ; Modify this_free block to be allocation 
15e6			      ex    DE, HL 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			 
15e6			      xor   A                       ; Null the next block ptr of allocated block 
15e6			      ld    (HL), A 
15e6			      inc   HL 
15e6			      ld    (HL), A 
15e6			 
15e6			      inc   HL                      ; Store address of allocation to return 
15e6			      inc   HL 
15e6			      inc   HL 
15e6			      push  HL 
15e6			 
15e6			      ; Copy next_free ptr to this_free, remove allocated block from free list 
15e6			      ld    L, (IX+0)               ; next_free to HL 
15e6			      ld    H, (IX+1) 
15e6			 
15e6			      ld    (IX+2), L               ; HL to this_free 
15e6			      ld    (IX+3), H 
15e6			 
15e6			 
15e6			malloc_update_links: 
15e6			      ; Update prev_free ptr to point to this_free 
15e6			      ld    L, (IX+4)               ; prev_free ptr to HL 
15e6			      ld    H, (IX+5) 
15e6			 
15e6			      ld    E, (IX+2)               ; this_free ptr to DE 
15e6			      ld    D, (IX+3) 
15e6			 
15e6			      ld    (HL), E                 ; this_free ptr into prev_free 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			      ; Clear the Z flag to indicate successful allocation 
15e6			      ld    A, D 
15e6			      or    E 
15e6			 
15e6			      pop   DE                      ; Address of allocation 
15e6			 
15e6			malloc_no_space: 
15e6			      ld    HL, 6                   ; Clean up stack frame 
15e6			      add   HL, SP 
15e6			      ld    SP, HL 
15e6			 
15e6			      ex    DE, HL                  ; Alloc addr into HL for return 
15e6			 
15e6			malloc_early_exit: 
15e6			      pop   IX 
15e6			      pop   DE 
15e6			      pop   BC 
15e6			 
15e6			      ret 
15e6			 
15e6			 
15e6			;------------------------------------------------------------------------------ 
15e6			;     free                                                                    : 
15e6			;                                                                             : 
15e6			; Description                                                                 : 
15e6			;     Return the space pointed to by HL to the heap. HL must be an address as : 
15e6			;     returned by malloc, otherwise the behaviour is undefined.               : 
15e6			;                                                                             : 
15e6			;     Where possible, directly adjacent free blocks will be merged together   : 
15e6			;     into larger blocks to help ensure that the heap does not become         : 
15e6			;     excessively fragmented.                                                 : 
15e6			;                                                                             : 
15e6			;     free does not clear or set any other value into the freed space, and    : 
15e6			;     therefore its contents may be visible through subsequent malloc's. The  : 
15e6			;     caller should clear the freed space as required.                        : 
15e6			;                                                                             : 
15e6			;     This implementation of free uses the stack exclusively, and is          : 
15e6			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15e6			;     advisable to disable interrupts before calling free, and recommended    : 
15e6			;     to avoid the use of free inside ISRs in general.                        : 
15e6			;                                                                             : 
15e6			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15e6			;                                                                             : 
15e6			; Parameters                                                                  : 
15e6			;     HL  Pointer to address of first byte of allocation to be freed          : 
15e6			;                                                                             : 
15e6			; Returns                                                                     : 
15e6			;     Nothing                                                                 : 
15e6			;                                                                             : 
15e6			; Stack frame                                                                 : 
15e6			;       |             |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |     BC      |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |     DE      |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |     IX      |                                                       : 
15e6			;       +-------------+                                                       : 
15e6			;       |  prev_free  |                                                       : 
15e6			;   +2  +-------------+                                                       : 
15e6			;       |  next_free  |                                                       : 
15e6			;   +0  +-------------+                                                       : 
15e6			;       |             |                                                       : 
15e6			;                                                                             : 
15e6			;------------------------------------------------------------------------------ 
15e6			free: 
15e6			      push  BC 
15e6			      push  DE 
15e6			      push  IX 
15e6			 
15e6			      ld    A, H                    ; Exit if ptr is null 
15e6			      or    L 
15e6			      jp    Z, free_early_exit 
15e6			 
15e6			      ; Set up stack frame 
15e6			      ex    DE, HL 
15e6			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
15e6			      add   HL, SP 
15e6			      ld    SP, HL 
15e6			      ld    IX, 0                   ; Use IX as a frame pointer 
15e6			      add   IX, SP 
15e6			 
15e6			      ; The address in HL points to the start of the useable allocated space, 
15e6			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
15e6			      ; address of the block itself. 
15e6			      ex    DE, HL 
15e6			      ld    DE, -4 
15e6			      add   HL, DE 
15e6			 
15e6			      ; An allocated block must have a null next block pointer in it 
15e6			      ld    A, (HL) 
15e6			      inc   HL 
15e6			      or    (HL) 
15e6			      jp    NZ, free_done 
15e6			 
15e6			      dec   HL 
15e6			 
15e6			      ld    B, H                    ; Copy HL to BC 
15e6			      ld    C, L 
15e6			 
15e6			      ; Loop through the free list to find the first block with an address 
15e6			      ; higher than the block being freed 
15e6			      ld    HL, free_list 
15e6			 
15e6			free_find_higher_block: 
15e6			      ld    E, (HL)                 ; Load next ptr from free block 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      dec   HL 
15e6			 
15e6			      ld    (IX+0), E               ; Save ptr to next free block 
15e6			      ld    (IX+1), D 
15e6			      ld    (IX+2), L               ; Save ptr to prev free block 
15e6			      ld    (IX+3), H 
15e6			 
15e6			      ld    A, B                    ; Check if DE is greater than BC 
15e6			      cp    D                       ; Compare MSB first 
15e6			      jr    Z, $+4                  ; MSB the same, compare LSB 
15e6			      jr    NC, free_find_higher_block_skip 
15e6			      ld    A, C 
15e6			      cp    E                       ; Then compare LSB 
15e6			      jr    C, free_found_higher_block 
15e6			 
15e6			free_find_higher_block_skip: 
15e6			      ld    A, D                    ; Reached the end of the free list? 
15e6			      or    E 
15e6			      jp    Z, free_done 
15e6			 
15e6			      ex    DE, HL 
15e6			 
15e6			      jr    free_find_higher_block 
15e6			 
15e6			free_found_higher_block: 
15e6			      ; Insert freed block between prev and next free blocks 
15e6			      ld    (HL), C                 ; Point prev free block to freed block 
15e6			      inc   HL 
15e6			      ld    (HL), B 
15e6			 
15e6			      ld    H, B                    ; Point freed block at next free block 
15e6			      ld    L, C 
15e6			      ld    (HL), E 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			      ; Check if the freed block is adjacent to the next free block 
15e6			      inc   HL                      ; Load size of freed block into HL 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      ex    DE, HL 
15e6			 
15e6			      add   HL, BC                  ; Add addr of freed block and its size 
15e6			 
15e6			      ld    E, (IX+0)               ; Load addr of next free block into DE 
15e6			      ld    D, (IX+1) 
15e6			 
15e6			      or    A                       ; Clear the carry flag 
15e6			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15e6			      jr    NZ, free_check_adjacent_to_prev 
15e6			 
15e6			      ; Freed block is adjacent to next, merge into one bigger block 
15e6			      ex    DE, HL                  ; Load next ptr from next block into DE 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      push  HL                      ; Save ptr to next block for later 
15e6			 
15e6			      ld    H, B                    ; Store ptr from next block into freed block 
15e6			      ld    L, C 
15e6			      ld    (HL), E 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			      pop   HL                      ; Restore ptr to next block 
15e6			      inc   HL                      ; Load size of next block into DE 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      push  DE                      ; Save next block size for later 
15e6			 
15e6			      ld    H, B                    ; Load size of freed block into HL 
15e6			      ld    L, C 
15e6			      inc   HL 
15e6			      inc   HL 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      ex    DE, HL 
15e6			 
15e6			      pop   DE                      ; Restore size of next block 
15e6			      add   HL, DE                  ; Add sizes of both blocks 
15e6			      ex    DE, HL 
15e6			 
15e6			      ld    H, B                    ; Store new bigger size into freed block 
15e6			      ld    L, C 
15e6			      inc   HL 
15e6			      inc   HL 
15e6			      ld    (HL), E 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			free_check_adjacent_to_prev: 
15e6			      ; Check if the freed block is adjacent to the prev free block 
15e6			      ld    L, (IX+2)               ; Prev free block ptr into HL 
15e6			      ld    H, (IX+3) 
15e6			 
15e6			      inc   HL                      ; Size of prev free block into DE 
15e6			      inc   HL 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			      dec   HL 
15e6			 
15e6			      add   HL, DE                  ; Add prev block addr and size 
15e6			 
15e6			      or    A                       ; Clear the carry flag 
15e6			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15e6			      jr    NZ, free_done 
15e6			 
15e6			      ; Freed block is adjacent to prev, merge into one bigger block 
15e6			      ld    H, B                    ; Load next ptr from freed block into DE 
15e6			      ld    L, C 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      push  HL                      ; Save freed block ptr for later 
15e6			 
15e6			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
15e6			      ld    H, (IX+3) 
15e6			      ld    (HL), E 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			      pop   HL                      ; Restore freed block ptr 
15e6			      inc   HL                      ; Load size of freed block into DE 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			      push  DE                      ; Save freed block size for later 
15e6			 
15e6			      ld    L, (IX+2)               ; Load size of prev block into DE 
15e6			      ld    H, (IX+3) 
15e6			      inc   HL 
15e6			      inc   HL 
15e6			      ld    E, (HL) 
15e6			      inc   HL 
15e6			      ld    D, (HL) 
15e6			 
15e6			      pop   HL                      ; Add sizes of both blocks 
15e6			      add   HL, DE 
15e6			      ex    DE, HL 
15e6			 
15e6			      ld    L, (IX+2)               ; Store new bigger size into prev block 
15e6			      ld    H, (IX+3) 
15e6			      inc   HL 
15e6			      inc   HL 
15e6			      ld    (HL), E 
15e6			      inc   HL 
15e6			      ld    (HL), D 
15e6			 
15e6			free_done: 
15e6			      ld    HL, 4                   ; Clean up stack frame 
15e6			      add   HL, SP 
15e6			      ld    SP, HL 
15e6			 
15e6			free_early_exit: 
15e6			      pop   IX 
15e6			      pop   DE 
15e6			      pop   BC 
15e6			 
15e6			      ret 
15e6			 
15e6			 
15e6			;      .org 0x8000 
15e6			; 
15e6			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15e6			 ;                 .dw   0 
15e6			 
15e6			endif 
15e6			 
15e6			 
15e6			if MALLOC_4 
15e6			 
15e6			; My memory allocation code. Very very simple.... 
15e6			; allocate space under 250 chars 
15e6			 
15e6			heap_init: 
15e6				; init start of heap as zero 
15e6				;  
15e6			 
15e6				ld hl, heap_start 
15e6				ld a, 0 
15e6				ld (hl), a      ; empty block 
15e6				inc hl 
15e6				ld a, 0 
15e6				ld (hl), a      ; length of block 
15e6				; write end of list 
15e6				inc hl 
15e6				ld a,(hl) 
15e6				inc hl 
15e6				ld a,(hl) 
15e6				 
15e6			 
15e6				; init some malloc vars 
15e6			 
15e6				ld hl, 0 
15e6				ld (free_list), hl       ; store last malloc location 
15e6			 
15e6				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
15e6				ld a, 0 
15e6				ld (hl), a 
15e6			 
15e6			 
15e6				ld hl, heap_start 
15e6				;  
15e6				  
15e6				ret 
15e6			 
15e6			 
15e6			;    free block marker 
15e6			;    requested size  
15e6			;    pointer to next block 
15e6			;    .... 
15e6			;    next block marker 
15e6			 
15e6			 
15e6			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
15e6			; 
15e6			 
15e6			 
15e6			malloc:  
15e6				push de 
15e6				push bc 
15e6				push af 
15e6			 
15e6				; hl space required 
15e6				 
15e6				ld c, l    ; hold space   (TODO only a max of 255) 
15e6			 
15e6			;	inc c     ; TODO BUG need to fix memory leak on push str 
15e6			;	inc c 
15e6			;	inc c 
15e6			;	inc c 
15e6			;	inc c 
15e6			;	inc c 
15e6			;	inc c 
15e6			 
15e6			 
15e6			 
15e6				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
15e6			 
15e6				ld a, (free_list+3) 
15e6				cp 0 
15e6				jr z, .contheap 
15e6			 
15e6				ld hl, (free_list)     ; get last alloc 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "mrs" 
15e6						CALLMONITOR 
15e6					endif 
15e6				jr .startalloc 
15e6			 
15e6			.contheap: 
15e6				ld hl, heap_start 
15e6			 
15e6			.startalloc: 
15e6			 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "mym" 
15e6						CALLMONITOR 
15e6					endif 
15e6			.findblock: 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "mmf" 
15e6						CALLMONITOR 
15e6					endif 
15e6			 
15e6				ld a,(hl)  
15e6				; if byte is zero then clear to use 
15e6			 
15e6				cp 0 
15e6				jr z, .foundemptyblock 
15e6			 
15e6				; if byte is not clear 
15e6				;     then byte is offset to next block 
15e6			 
15e6				inc hl 
15e6				ld a, (hl) ; get size 
15e6			.nextblock:	inc hl 
15e6					ld e, (hl) 
15e6					inc hl 
15e6					ld d, (hl) 
15e6					ex de, hl 
15e6			;	inc hl  ; move past the store space 
15e6			;	inc hl  ; move past zero index  
15e6			 
15e6				; TODO detect no more space 
15e6			 
15e6				push hl 
15e6				ld de, heap_end 
15e6				call cmp16 
15e6				pop hl 
15e6				jr nc, .nospace 
15e6			 
15e6				jr .findblock 
15e6			 
15e6			.nospace: ld hl, 0 
15e6				jp .exit 
15e6			 
15e6			 
15e6			.foundemptyblock:	 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "mme" 
15e6						CALLMONITOR 
15e6					endif 
15e6			 
15e6			; TODO has block enough space if reusing??? 
15e6			 
15e6				;  
15e6			 
15e6			; see if this block has been previously used 
15e6				inc hl 
15e6				ld a, (hl) 
15e6				dec hl 
15e6				cp 0 
15e6				jr z, .newblock 
15e6			 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "meR" 
15e6						CALLMONITOR 
15e6					endif 
15e6			 
15e6			; no reusing previously allocated block 
15e6			 
15e6			; is it smaller than previously used? 
15e6				 
15e6				inc hl    ; move to size 
15e6				ld a, c 
15e6				sub (hl)        ; we want c < (hl) 
15e6				dec hl    ; move back to marker 
15e6			        jr z, .findblock 
15e6			 
15e6				; update with the new size which should be lower 
15e6			 
15e6			        ;inc  hl   ; negate next move. move back to size  
15e6			 
15e6			.newblock: 
15e6				; need to be at marker here 
15e6			 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "meN" 
15e6						CALLMONITOR 
15e6					endif 
15e6			 
15e6			 
15e6				ld a, c 
15e6			 
15e6				ld (free_list+3), a	 ; flag resume from last malloc  
15e6				ld (free_list), hl    ; save out last location 
15e6			 
15e6			 
15e6				;inc a     ; space for length byte 
15e6				ld (hl), a     ; save block in use marker 
15e6			 
15e6				inc hl   ; move to space marker 
15e6				ld (hl), a    ; save new space 
15e6			 
15e6				inc hl   ; move to start of allocated area 
15e6				 
15e6			;	push hl     ; save where we are - 1  
15e6			 
15e6			;	inc hl  ; move past zero index  
15e6				; skip space to set down new marker 
15e6			 
15e6				; provide some extra space for now 
15e6			 
15e6				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
15e6				inc a 
15e6				inc a 
15e6			 
15e6				push hl   ; save where we are in the node block 
15e6			 
15e6				call addatohl 
15e6			 
15e6				; write linked list point 
15e6			 
15e6				pop de     ; get our node position 
15e6				ex de, hl 
15e6			 
15e6				ld (hl), e 
15e6				inc hl 
15e6				ld (hl), d 
15e6			 
15e6				inc hl 
15e6			 
15e6				; now at start of allocated data so save pointer 
15e6			 
15e6				push hl 
15e6			 
15e6				; jump to position of next node and setup empty header in DE 
15e6			 
15e6				ex de, hl 
15e6			 
15e6			;	inc hl ; move past end of block 
15e6			 
15e6				ld a, 0 
15e6				ld (hl), a   ; empty marker 
15e6				inc hl 
15e6				ld (hl), a   ; size 
15e6				inc hl  
15e6				ld (hl), a   ; ptr 
15e6				inc hl 
15e6				ld (hl), a   ; ptr 
15e6			 
15e6			 
15e6				pop hl 
15e6			 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "mmr" 
15e6						CALLMONITOR 
15e6					endif 
15e6			 
15e6			.exit: 
15e6				pop af 
15e6				pop bc 
15e6				pop de  
15e6				ret 
15e6			 
15e6			 
15e6			 
15e6			 
15e6			free:  
15e6				push hl 
15e6				push af 
15e6				; get address in hl 
15e6			 
15e6					if DEBUG_FORTH_MALLOC_INT 
15e6						DMARK "fre" 
15e6						CALLMONITOR 
15e6					endif 
15e6				; data is at hl - move to block count 
15e6				dec hl 
15e6				dec hl    ; get past pointer 
15e6				dec hl 
15e6			 
15e6				ld a, (hl)    ; need this for a validation check 
15e6			 
15e6				dec hl    ; move to block marker 
15e6			 
15e6				; now check that the block count and block marker are the same  
15e6			        ; this checks that we are on a malloc node and not random memory 
15e6			        ; OK a faint chance this could be a problem but rare - famous last words! 
15e6			 
15e6				ld c, a 
15e6				ld a, (hl)    
15e6			 
15e6				cp c 
15e6				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
15e6			 
15e6				; yes good chance we are on a malloc node 
15e6			 
15e6				ld a, 0      
15e6				ld (hl), a   ; mark as free 
15e6			 
15e6				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
15e6			 
15e6			.freeignore:  
15e6			 
15e6				pop af 
15e6				pop hl 
15e6			 
15e6				ret 
15e6			 
15e6			 
15e6			 
15e6			endif 
15e6			 
15e6			; eof 
# End of file firmware_memory.asm
15e6			  
15e6			; device C  
15e6			if SOUND_ENABLE  
15e6				include "firmware_sound.asm"  
15e6			; Sound abstraction layer 
15e6			 
15e6			; support different sound chips through common interface 
15e6			 
15e6			SOUND_DEVICE_AY: equ 0 
15e6			 
15e6			SOUND_DEVICE: equ Device_A 
15e6			 
15e6			 
15e6			 
15e6			if SOUND_DEVICE_AY 
15e6				include "firmware_sound_ay38910.asm" 
15e6			else 
15e6				include "firmware_sound_sn76489an.asm" 
15e6			 
15e6			; Device support for SN76489AN sound chip 
15e6			 
15e6			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
15e6			; http://danceswithferrets.org/geekblog/?p=93 
15e6			; https://www.smspower.org/Development/SN76489 
15e6			 
15e6			; D0 [ 3] 
15e6			; D1 [ 2] 
15e6			; D2 [ 1] 
15e6			; D3 [15] 
15e6			; D4 [13] 
15e6			; D5 [12] 
15e6			; D6 [11] 
15e6			; D7 [10] 
15e6			; /WE [ 5] 
15e6			; CLK [14] 
15e6			; /OE [ 6] 
15e6			; AUDIO [ 7] 
15e6			; GND 8 
15e6			; +5 16 
15e6			; 
15e6			 
15e6			; Write sequence: 
15e6			; CE low 
15e6			; Data bus 
15e6			; WE low then high 
15e6			; 32 clock cycles / 8ns write time at 4mhz 
15e6			; 
15e6			; https://github.com/jblang/SN76489 
15e6			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
15e6			; Tried: 
15e6			; 
15e6			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
15e6			; 
15e6			; Connected WE to OR too 
15e6			;  
15e6			; That enabled the clock when required 
15e6			; However still random bus corruption. Need further investigation 
15e6			 
15e6			 
15e6			SOUND_LATCH: equ 10000000B 
15e6			SOUND_DATA: equ 0B 
15e6			SOUND_CH0:  equ 0B    ; Tone 
15e6			SOUND_CH1: equ 0100000B        ; Tone 
15e6			SOUND_CH2: equ 1000000B   ; Tone 
15e6			SOUND_CH3: equ 1100000B    ; Noise 
15e6			SOUND_VOL: equ 10000B 
15e6			SOUND_TONE: equ 0B 
15e6			 
15e6			 
15e6			sound_init: 
15e6 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
15e8 cd fd 15			call note_send_byte 
15eb 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
15ed cd fd 15			call note_send_byte 
15f0 cd 89 0c			call delay250ms 
15f3 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
15f5 cd fd 15			call note_send_byte 
15f8 cd 89 0c			call delay250ms 
15fb c9				ret 
15fc			 
15fc			; Play a note 
15fc			; h = note 
15fc			; l = duration 
15fc			; a = channel 
15fc			 
15fc			 
15fc			;  frequ = clock / ( 2 x reg valu x 32 )  
15fc			 
15fc			note:  
15fc				 
15fc			 
15fc c9				ret 
15fd			 
15fd			note_send_byte: 
15fd				; byte in a 
15fd			 
15fd				; we high 
15fd d3 40			out (Device_B), a 
15ff			;	ld a, 1 
15ff			;	call aDelayInMS 
15ff 00				nop  
1600 00				nop  
1601 00				nop  
1602 00				nop  
1603				; we low 
1603 d3 40			out (Device_B), a 
1605			;	ld a, 1 
1605			;	call aDelayInMS 
1605 00				nop  
1606 00				nop  
1607 00				nop  
1608 00				nop  
1609				; we high 
1609 d3 40			out (Device_B), a 
160b			;	ld a, 1 
160b			;	call aDelayInMS 
160b 00				nop  
160c 00				nop  
160d 00				nop  
160e 00				nop  
160f			 
160f			 
160f c9				ret 
1610			 
1610			;void SilenceAllChannels() 
1610			;{ 
1610			;  SendByte(0x9f); 
1610			;  SendByte(0xbf); 
1610			;  SendByte(0xdf); 
1610			;  SendByte(0xff); 
1610			;} 
1610			 
1610			 
1610			; eof 
1610			 
# End of file firmware_sound_sn76489an.asm
1610			endif 
1610			 
1610			 
1610			; Abstraction entry points 
1610			 
1610			; init  
1610			 
1610			; sound_init in specific hardware files 
1610			 
1610			; Play a note 
1610			; h = note 
1610			; l = duration 
1610			; a = channel 
1610			 
1610			;note:     
1610			;	ret 
1610			 
1610			 
1610			 
1610			 
1610			; eof 
1610			 
# End of file firmware_sound.asm
1610			endif  
1610			  
1610			include "firmware_diags.asm"  
1610			; Hardware diags menu 
1610			 
1610			 
1610			config: 
1610			 
1610 3e 00			ld a, 0 
1612 21 3b 16			ld hl, .configmn 
1615 cd 83 0d			call menu 
1618			 
1618 fe 00			cp 0 
161a c8				ret z 
161b			 
161b			;	cp 1 
161b			;	call z, .savetostore 
161b			 
161b fe 01			cp 1 
161d			if STARTUP_V1 
161d				call z, .selautoload 
161d			endif 
161d			 
161d			if STARTUP_V2 
161d cc 49 16			call z, .enautoload 
1620			endif 
1620 fe 02			cp 2 
1622 cc 60 16			call z, .disautoload 
1625			;	cp 3 
1625			;	call z, .selbank 
1625 fe 03			cp 3 
1627 cc b5 18			call z, .debug_tog 
162a fe 04			cp 4 
162c cc 03 1a			call z, .bpsgo 
162f fe 05			cp 5 
1631 cc de 18			call z, hardware_diags 
1634			if STARTUP_V2 
1634 fe 06			cp 6 
1636 cc 8c 16			call z, create_startup 
1639			endif 
1639 18 d5			jr config 
163b			 
163b			.configmn: 
163b			;	dw prom_c3 
163b f2 1b			dw prom_c2 
163d 08 1c			dw prom_c2a 
163f			;	dw prom_c2b 
163f			;	dw prom_c4 
163f 6b 1c			dw prom_m4 
1641 86 1c			dw prom_m4b 
1643 8e 1c			dw prom_c1 
1645			if STARTUP_V2 
1645 9d 1c			dw prom_c9 
1647			endif 
1647 00 00			dw 0 
1649				 
1649			 
1649			if STARTUP_V2 
1649			.enautoload: 
1649				if STORAGE_SE 
1649 3e fe			ld a, $fe      ; bit 0 clear 
164b 32 60 fa			ld (spi_device), a 
164e			 
164e cd cd 04			call storage_get_block_0 
1651			 
1651 3e 01			ld a, 1 
1653 32 9b fa			ld (store_page+STORE_0_AUTOFILE), a 
1656			 
1656 21 00 00				ld hl, 0 
1659 11 7a fa				ld de, store_page 
165c cd 81 04			call storage_write_block	 ; save update 
165f				else 
165f			 
165f				ld hl, prom_notav 
165f				ld de, prom_empty 
165f				call info_panel 
165f				endif 
165f			 
165f			 
165f c9				ret 
1660			endif 
1660			 
1660			.disautoload: 
1660				if STORAGE_SE 
1660 3e fe			ld a, $fe      ; bit 0 clear 
1662 32 60 fa			ld (spi_device), a 
1665			 
1665 cd cd 04			call storage_get_block_0 
1668			 
1668 3e 00			ld a, 0 
166a 32 9b fa			ld (store_page+STORE_0_AUTOFILE), a 
166d			 
166d 21 00 00				ld hl, 0 
1670 11 7a fa				ld de, store_page 
1673 cd 81 04			call storage_write_block	 ; save update 
1676				else 
1676			 
1676				ld hl, prom_notav 
1676				ld de, prom_empty 
1676				call info_panel 
1676				endif 
1676			 
1676			 
1676 c9				ret 
1677			 
1677			if STARTUP_V1 
1677			 
1677			; Select auto start 
1677			 
1677			.selautoload: 
1677			 
1677				 
1677				if STORAGE_SE 
1677			 
1677					call config_dir 
1677				        ld hl, scratch 
1677					ld a, 0 
1677					call menu 
1677			 
1677					cp 0 
1677					ret z 
1677			 
1677					dec a 
1677			 
1677			 
1677					; locate menu option 
1677			 
1677					ld hl, scratch 
1677					call table_lookup 
1677			 
1677					if DEBUG_FORTH_WORDS 
1677						DMARK "ALl" 
1677						CALLMONITOR 
1677					endif 
1677					; with the pointer to the menu it, the byte following the zero term is the file id 
1677			 
1677					ld a, 0 
1677					ld bc, 50   ; max of bytes to look at 
1677					cpir  
1677			 
1677					if DEBUG_FORTH_WORDS 
1677						DMARK "ALb" 
1677						CALLMONITOR 
1677					endif 
1677					;inc hl 
1677			 
1677					ld a, (hl)   ; file id 
1677					 
1677				        ; save bank and file ids 
1677			 
1677					push af 
1677			 
1677			; TODO need to save to block 0 on bank 1	 
1677			 
1677					call storage_get_block_0 
1677			 
1677					if DEBUG_FORTH_WORDS 
1677						DMARK "AL0" 
1677						CALLMONITOR 
1677					endif 
1677					pop af 
1677			 
1677					ld (store_page+STORE_0_FILERUN),a 
1677					 
1677					; save bank id 
1677			 
1677					ld a,(spi_device) 
1677					ld (store_page+STORE_0_BANKRUN),a 
1677			 
1677					; enable auto run of store file 
1677			 
1677					ld a, 1 
1677					ld (store_page+STORE_0_AUTOFILE),a 
1677			 
1677					; save buffer 
1677			 
1677					ld hl, 0 
1677					ld de, store_page 
1677					if DEBUG_FORTH_WORDS 
1677						DMARK "ALw" 
1677						CALLMONITOR 
1677					endif 
1677				call storage_write_block	 ; save update 
1677			  
1677			 
1677			 
1677			 
1677					ld hl, scratch 
1677					call config_fdir 
1677			 
1677				else 
1677			 
1677				ld hl, prom_notav 
1677				ld de, prom_empty 
1677				call info_panel 
1677			 
1677				endif 
1677				ret 
1677			endif 
1677			 
1677			 
1677			; Select storage bank 
1677			 
1677			.selbank: 
1677			 
1677			;	if STORAGE_SE 
1677			;	else 
1677			 
1677 21 b2 1c			ld hl, prom_notav 
167a 11 c8 1c			ld de, prom_empty 
167d cd e3 0c			call info_panel 
1680			;	endif 
1680				 
1680 c9				ret 
1681			 
1681			if STORAGE_SE 
1681			 
1681			.config_ldir:   
1681				; Load storage bank labels into menu array 
1681			 
1681				 
1681			 
1681			 
1681 c9				ret 
1682			 
1682			 
1682			endif 
1682			 
1682			 
1682			; Save user words to storage 
1682			 
1682			.savetostore: 
1682			 
1682			;	if STORAGE_SE 
1682			; 
1682			;		call config_dir 
1682			;	        ld hl, scratch 
1682			;		ld a, 0 
1682			;		call menu 
1682			;		 
1682			;		ld hl, scratch 
1682			;		call config_fdir 
1682			; 
1682			;	else 
1682			 
1682 21 b2 1c			ld hl, prom_notav 
1685 11 c8 1c			ld de, prom_empty 
1688 cd e3 0c			call info_panel 
168b			 
168b			;	endif 
168b			 
168b c9				ret 
168c			 
168c			if STARTUP_V2 
168c			 
168c			create_startup: 
168c			 
168c 3e 00			ld a, 0 
168e 21 de 17			ld hl, .crstart 
1691 cd 83 0d			call menu 
1694			 
1694 fe 00			cp 0 
1696 c8				ret z 
1697			 
1697 fe 01			cp 1 
1699 cc b7 16			call z, .genlsword 
169c fe 02			cp 2 
169e cc c1 16			call z, .genedword 
16a1			 
16a1 fe 03			cp 3 
16a3 cc cb 16			call z, .gendemword 
16a6			 
16a6 fe 04			cp 4 
16a8 cc d5 16			call z, .genutlword 
16ab fe 05			cp 5 
16ad cc df 16			call z, .genspiword 
16b0 fe 06			cp 6 
16b2 cc e9 16			call z, .genkeyword 
16b5 18 d5			jr create_startup 
16b7			 
16b7			.genlsword: 
16b7 21 1f 1c			ld hl, crs_s1 
16ba 11 4a 17			ld de, .lsworddef 
16bd cd f3 16			call .genfile 
16c0 c9				ret 
16c1			 
16c1			.genedword: 
16c1 11 4e 17			ld de, .edworddef 
16c4 21 28 1c			ld hl, crs_s2 
16c7 cd f3 16			call .genfile 
16ca c9				ret 
16cb			 
16cb			.gendemword: 
16cb 11 56 17			ld de, .demoworddef 
16ce 21 31 1c			ld hl, crs_s3 
16d1 cd f3 16			call .genfile 
16d4 c9				ret 
16d5			 
16d5			.genutlword: 
16d5 21 40 1c			ld hl, crs_s4 
16d8 11 36 17			ld de, .utilwordef 
16db cd f3 16			call .genfile 
16de c9				ret 
16df			.genspiword: 
16df 21 47 1c			ld hl, crs_s5 
16e2 11 9c 17			ld de, .spiworddef 
16e5 cd f3 16			call .genfile 
16e8 c9				ret 
16e9			.genkeyword: 
16e9 21 53 1c			ld hl, crs_s6 
16ec 11 b2 17			ld de, .keyworddef 
16ef cd f3 16			call .genfile 
16f2 c9				ret 
16f3			 
16f3			; hl - points to file name 
16f3			; de - points to strings to add to file 
16f3			 
16f3			.genfile: 
16f3 e5				push hl 
16f4 d5				push de 
16f5			 
16f5 cd 52 0d			call clear_display 
16f8 3e 00			ld a, display_row_1 
16fa 11 25 17			ld de, .genfiletxt 
16fd cd 65 0d			call str_at_display 
1700 cd 75 0d			call update_display 
1703			 
1703 d1				pop de 
1704 e1				pop hl 
1705			 
1705			 
1705 d5				push de 
1706 cd 1f 08			call storage_create 
1709				; id in hl 
1709 d1				pop de   ; table of strings to add 
170a			 
170a			.genloop: 
170a			 
170a e5				push hl ; save id for next time around 
170b d5				push de ; save de for next time around 
170c			 
170c eb				ex de, hl 
170d cd f1 23			call loadwordinhl 
1710 eb				ex de, hl 
1711			 
1711				; need hl to be the id 
1711				; need de to be the string ptr 
1711				 
1711 cd 0c 0b			call storage_append 
1714			 
1714 d1				pop de 
1715 e1				pop hl 
1716			 
1716 13				inc de 
1717 13				inc de 
1718			 
1718 1a				ld a,(de) 
1719 fe 00			cp 0 
171b 20 ed			jr nz, .genloop 
171d 13				inc de 
171e 1a				ld a, (de) 
171f 1b				dec de 
1720 fe 00			cp 0 
1722 20 e6			jr nz, .genloop	 
1724			 
1724 c9				ret 
1725			 
1725 .. 00		.genfiletxt:  db "Creating file...",0 
1736			 
1736			.utilwordef: 
1736 1f 63			dw strncpy 
1738 fb 62			dw type 
173a c8 62			dw clrstack 
173c 81 62			dw longread 
173e 80 63			dw start1 
1740 90 63			dw start2 
1742 a1 63			dw start3b 
1744 1c 64			dw start3c 
1746 7c 64			dw list 
1748 00 00			dw 0 
174a			 
174a			.lsworddef: 
174a a1 63			dw start3b 
174c 00 00			dw 0 
174e			 
174e			.edworddef: 
174e 0f 5f			dw edit1 
1750 30 5f			dw edit2 
1752 65 5f			dw edit3 
1754 00 00			dw 0 
1756			 
1756			.demoworddef: 
1756 c4 68			dw test5 
1758 fc 68			dw test6 
175a 34 69			dw test7 
175c 48 69			dw test8 
175e 74 69			dw test9 
1760 8a 69			dw test10 
1762 ce 69			dw game1 
1764 df 69			dw game1a 
1766 41 6a			dw game1b 
1768 76 6a			dw game1c 
176a ac 6a			dw game1d 
176c dd 6a			dw game1s 
176e f1 6a			dw game1t 
1770 06 6b			dw game1f 
1772 3a 6b			dw game1z 
1774 7e 6b			dw game1zz 
1776 e7 6b			dw ssv2 
1778 1d 6c			dw ssv3 
177a 39 6c			dw ssv4 
177c 55 6c			dw ssv5 
177e 6e 6c			dw ssv1 
1780 b6 6c			dw ssv1cpm	 
1782 0d 6d			dw game2b 
1784 7b 6d			dw game2bf 
1786 c5 6d			dw game2mba 
1788 5b 6e			dw game2mbas	 
178a 80 6e			dw game2mbht 
178c 8f 6e			dw game2mbms 
178e 9d 6e			dw game2mb 
1790 1a 6f			dw game3w 
1792 48 6f			dw game3p 
1794 66 6f			dw game3sc 
1796 97 6f			dw game3vsi 
1798 c3 6f			dw game3vs 
179a 00 00			dw 0 
179c			 
179c			 
179c			.spiworddef: 
179c			 
179c 9d 5f		    dw spi1 
179e f6 5f		    dw spi2 
17a0 84 60		    dw spi3 
17a2 2c 60		    dw spi4 
17a4 57 60		    dw spi5 
17a6 ea 60		    dw spi6 
17a8 3f 61		    dw spi7 
17aa			 
17aa 97 61		    dw spi8 
17ac b6 61		    dw spi9 
17ae 0e 62		    dw spi10 
17b0 00 00		    dw 0 
17b2			 
17b2			.keyworddef: 
17b2			 
17b2 02 70			dw keyup 
17b4 10 70			dw keydown 
17b6 20 70			dw keyleft 
17b8 30 70			dw keyright 
17ba 41 70			dw 	keyf1 
17bc 4f 70			dw keyf2 
17be 5d 70			dw keyf3 
17c0 6b 70			dw keyf4 
17c2 79 70			dw keyf5 
17c4 87 70			dw keyf6 
17c6 95 70			dw keyf7 
17c8 a3 70			dw keyf8 
17ca b1 70			dw keyf9 
17cc bf 70			dw keyf10 
17ce ce 70			dw keyf11 
17d0 dd 70			dw keyf12 
17d2 ec 70			dw keytab 
17d4 fb 70			dw keycr 
17d6 09 71			dw keyhome 
17d8 19 71			dw keyend 
17da 28 71			dw keybs 
17dc 00 00			dw 0 
17de			 
17de			.crstart: 
17de 1f 1c			dw crs_s1 
17e0 28 1c			dw crs_s2 
17e2 31 1c			dw crs_s3 
17e4 40 1c			dw crs_s4 
17e6 47 1c			dw crs_s5 
17e8 53 1c			dw crs_s6 
17ea 00 00			dw 0 
17ec			 
17ec			endif 
17ec			 
17ec			 
17ec			if STORAGE_SE 
17ec			 
17ec			config_fdir: 
17ec				; using the scratch dir go through and release the memory allocated for each string 
17ec				 
17ec 21 c1 f1			ld hl, scratch 
17ef 5e			.cfdir:	ld e,(hl) 
17f0 23				inc hl 
17f1 56				ld d,(hl) 
17f2 23				inc hl 
17f3			 
17f3 eb				ex de, hl 
17f4 cd af 0f			call ishlzero 
17f7 c8				ret z     ; return on null pointer 
17f8 cd 17 15			call free 
17fb eb				ex de, hl 
17fc 18 f1			jr .cfdir 
17fe			 
17fe			 
17fe c9				ret 
17ff			 
17ff			 
17ff			config_dir: 
17ff			 
17ff				; for the config menus that need to build a directory of storage call this routine 
17ff				; it will construct a menu in scratch to pass to menu 
17ff			 
17ff				; open storage device 
17ff			 
17ff				; execute DIR to build a list of files and their ids into scratch in menu format 
17ff				; once the menu has finished then will need to call config_fdir to release the strings 
17ff				 
17ff				; c = number items 
17ff			 
17ff				 
17ff cd cd 04			call storage_get_block_0 
1802			 
1802 21 7a fa			ld hl, store_page     ; get current id count 
1805 46				ld b, (hl) 
1806 0e 00			ld c, 0    ; count of files   
1808			 
1808			 
1808 21 c1 f1			ld hl, scratch 
180b 22 71 fa			ld (store_tmp2), hl    ; location to poke strings 
180e			 
180e				; check for empty drive 
180e			 
180e 3e 00			ld a, 0 
1810 b8				cp b 
1811 ca ab 18			jp z, .dirdone 
1814			 
1814				 
1814					if DEBUG_FORTH_WORDS 
1814						DMARK "Cdc" 
1814 f5				push af  
1815 3a 29 18			ld a, (.dmark)  
1818 32 6b fe			ld (debug_mark),a  
181b 3a 2a 18			ld a, (.dmark+1)  
181e 32 6c fe			ld (debug_mark+1),a  
1821 3a 2b 18			ld a, (.dmark+2)  
1824 32 6d fe			ld (debug_mark+2),a  
1827 18 03			jr .pastdmark  
1829 ..			.dmark: db "Cdc"  
182c f1			.pastdmark: pop af  
182d			endm  
# End of macro DMARK
182d						CALLMONITOR 
182d cd 6f fe			call debug_vector  
1830				endm  
# End of macro CALLMONITOR
1830					endif 
1830			 
1830			 
1830			.diritem:	 
1830 c5				push bc 
1831				; for each of the current ids do a search for them and if found push to stack 
1831			 
1831 21 40 00				ld hl, STORE_BLOCK_PHY 
1834 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
1836 58					ld e,b 
1837			 
1837 cd 4f 07				call storage_findnextid 
183a			 
183a			 
183a					; if found hl will be non zero 
183a			 
183a cd af 0f				call ishlzero 
183d 28 69				jr z, .dirnotfound 
183f			 
183f					; increase count 
183f			 
183f c1					pop bc	 
1840 0c					inc c 
1841 c5					push bc 
1842					 
1842			 
1842					; get file header and push the file name 
1842			 
1842 11 7a fa				ld de, store_page 
1845 cd 1c 04				call storage_read_block 
1848			 
1848					; push file id to stack 
1848				 
1848 3a 7a fa				ld a, (store_page) 
184b 26 00				ld h, 0 
184d 6f					ld l, a 
184e			 
184e					;call forth_push_numhl 
184e					; TODO store id 
184e			 
184e e5					push hl 
184f			 
184f					; push extent count to stack  
184f				 
184f 21 7d fa				ld hl, store_page+3 
1852			 
1852					; get file name length 
1852			 
1852 cd e4 13				call strlenz   
1855			 
1855 23					inc hl   ; cover zero term 
1856 23					inc hl  ; stick the id at the end of the area 
1857			 
1857 e5					push hl 
1858 c1					pop bc    ; move length to bc 
1859			 
1859 cd 4d 14				call malloc 
185c			 
185c					; TODO save malloc area to scratch 
185c			 
185c eb					ex de, hl 
185d 2a 71 fa				ld hl, (store_tmp2) 
1860 73					ld (hl), e 
1861 23					inc hl 
1862 72					ld (hl), d 
1863 23					inc hl 
1864 22 71 fa				ld (store_tmp2), hl 
1867			 
1867					 
1867			 
1867					;pop hl   ; get source 
1867			;		ex de, hl    ; swap aronund	 
1867			 
1867 21 7d fa				ld hl, store_page+3 
186a					if DEBUG_FORTH_WORDS 
186a						DMARK "CFd" 
186a f5				push af  
186b 3a 7f 18			ld a, (.dmark)  
186e 32 6b fe			ld (debug_mark),a  
1871 3a 80 18			ld a, (.dmark+1)  
1874 32 6c fe			ld (debug_mark+1),a  
1877 3a 81 18			ld a, (.dmark+2)  
187a 32 6d fe			ld (debug_mark+2),a  
187d 18 03			jr .pastdmark  
187f ..			.dmark: db "CFd"  
1882 f1			.pastdmark: pop af  
1883			endm  
# End of macro DMARK
1883						CALLMONITOR 
1883 cd 6f fe			call debug_vector  
1886				endm  
# End of macro CALLMONITOR
1886					endif 
1886 ed b0				ldir 
1888			 
1888					; de is past string, move back one and store id 
1888					 
1888 1b					dec de 
1889			 
1889					; store file id 
1889			 
1889 e1					pop hl 
188a eb					ex de,hl 
188b 73					ld (hl), e 
188c			 
188c					if DEBUG_FORTH_WORDS 
188c						DMARK "Cdi" 
188c f5				push af  
188d 3a a1 18			ld a, (.dmark)  
1890 32 6b fe			ld (debug_mark),a  
1893 3a a2 18			ld a, (.dmark+1)  
1896 32 6c fe			ld (debug_mark+1),a  
1899 3a a3 18			ld a, (.dmark+2)  
189c 32 6d fe			ld (debug_mark+2),a  
189f 18 03			jr .pastdmark  
18a1 ..			.dmark: db "Cdi"  
18a4 f1			.pastdmark: pop af  
18a5			endm  
# End of macro DMARK
18a5						CALLMONITOR 
18a5 cd 6f fe			call debug_vector  
18a8				endm  
# End of macro CALLMONITOR
18a8					endif 
18a8					 
18a8			.dirnotfound: 
18a8 c1					pop bc     
18a9 10 85				djnz .diritem 
18ab				 
18ab			.dirdone:	 
18ab			 
18ab 3e 00				ld a, 0 
18ad 2a 71 fa				ld hl, (store_tmp2) 
18b0 77					ld (hl), a 
18b1 23					inc hl 
18b2 77					ld (hl), a 
18b3 23					inc hl 
18b4					; push a count of the dir items found 
18b4			 
18b4			;		ld h, 0 
18b4			;		ld l, c 
18b4			 
18b4 c9				ret 
18b5			 
18b5			endif 
18b5			 
18b5			 
18b5			; Settings 
18b5			; Run  
18b5			 
18b5			 
18b5			 
18b5			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
18b5			;;hd_menu2:   db "        2: Editor",0   
18b5			;hd_menu2:   db "        2: Editor       6: Menu",0   
18b5			;hd_menu3:   db "        3: Storage",0 
18b5			;hd_menu4:   db "0=quit  4: Debug",0 
18b5			;hd_don:     db "ON",0 
18b5			;hd_doff:     db "OFF",0 
18b5			; 
18b5			; 
18b5			; 
18b5			;hardware_diags_old:       
18b5			; 
18b5			;.diagmenu: 
18b5			;	call clear_display 
18b5			;	ld a, display_row_1 
18b5			;	ld de, hd_menu1 
18b5			;	call str_at_display 
18b5			; 
18b5			;	ld a, display_row_2 
18b5			;	ld de, hd_menu2 
18b5			;	call str_at_display 
18b5			; 
18b5			;	ld a, display_row_3 
18b5			;	ld de, hd_menu3 
18b5			;	call str_at_display 
18b5			; 
18b5			;	ld a,  display_row_4 
18b5			;	ld de, hd_menu4 
18b5			;	call str_at_display 
18b5			; 
18b5			;	; display debug state 
18b5			; 
18b5			;	ld de, hd_don 
18b5			;	ld a, (os_view_disable) 
18b5			;	cp 0 
18b5			;	jr z, .distog 
18b5			;	ld de, hd_doff 
18b5			;.distog: ld a, display_row_4+17 
18b5			;	call str_at_display 
18b5			; 
18b5			;	call update_display 
18b5			; 
18b5			;	call cin_wait 
18b5			; 
18b5			; 
18b5			; 
18b5			;	cp '4' 
18b5			;	jr nz, .diagn1 
18b5			; 
18b5			;	; debug toggle 
18b5			; 
18b5			;	ld a, (os_view_disable) 
18b5			;	ld b, '*' 
18b5			;	cp 0 
18b5			;	jr z, .debtog 
18b5			;	ld b, 0 
18b5			;.debtog:	 
18b5			;	ld a,b 
18b5			;	ld (os_view_disable),a 
18b5			; 
18b5			;.diagn1: cp '0' 
18b5			;	 ret z 
18b5			; 
18b5			;;	cp '1' 
18b5			;;       jp z, matrix	 
18b5			;;   TODO keyboard matrix test 
18b5			; 
18b5			;	cp '2' 
18b5			;	jp z, .diagedit 
18b5			; 
18b5			;;	cp '6' 
18b5			;;	jp z, .menutest 
18b5			;;if ENABLE_BASIC 
18b5			;;	cp '6' 
18b5			;;	jp z, basic 
18b5			;;endif 
18b5			 ; 
18b5			;	jp .diagmenu 
18b5			; 
18b5			; 
18b5			;	ret 
18b5			 
18b5			 
18b5			.debug_tog: 
18b5 21 ff 18			ld hl, .menudebug 
18b8				 
18b8			;	ld a, (os_view_disable) 
18b8			;	cp '*' 
18b8 3a 6f fe			ld a,(debug_vector) 
18bb fe c9			cp $C9   ; RET 
18bd 20 04			jr nz,.tdon  
18bf 3e 01			ld a, 1 
18c1 18 02			jr .tog1 
18c3 3e 00		.tdon: ld a, 0 
18c5			 
18c5			.tog1: 
18c5 cd 83 0d			call menu 
18c8 fe 00			cp 0 
18ca c8				ret z 
18cb fe 01			cp 1    ; disable debug 
18cd 28 04			jr z, .dtog0 
18cf 3e 2a			ld a, '*' 
18d1 18 05			jr .dtogset 
18d3			.dtog0:  
18d3				;ld a, 0 
18d3 cd f1 19			call bp_on 
18d6 18 dd			jr .debug_tog 
18d8			.dtogset:  
18d8				; ld (os_view_disable), a 
18d8 cd fd 19			call bp_off 
18db c3 b5 18			jp .debug_tog 
18de			 
18de			 
18de			hardware_diags:       
18de			 
18de			.diagm: 
18de 21 f1 18			ld hl, .menuitems 
18e1 3e 00			ld a, 0 
18e3 cd 83 0d			call menu 
18e6			 
18e6 fe 00		         cp 0 
18e8 c8				 ret z 
18e9			 
18e9 fe 02			cp 2 
18eb ca 4a 19			jp z, .diagedit 
18ee			 
18ee			;	cp '6' 
18ee			;	jp z, .menutest 
18ee			;if ENABLE_BASIC 
18ee			;	cp '6' 
18ee			;	jp z, basic 
18ee			;endif 
18ee			  
18ee c3 de 18			jp .diagm 
18f1			 
18f1				 
18f1 05 19		.menuitems:   	dw .m1 
18f3 10 19				dw .m2 
18f5 17 19				dw .m3 
18f7 1f 19				dw .m5 
18f9 25 19				dw .m5a 
18fb 2e 19				dw .m5b 
18fd 00 00				dw 0 
18ff			 
18ff			.menudebug: 
18ff 37 19				dw .m6 
1901 40 19				dw .m7 
1903 00 00				dw 0 
1905			 
1905 .. 00		.m1:   db "Key Matrix",0 
1910 .. 00		.m2:   db "Editor",0 
1917 .. 00		.m3:   db "Storage",0 
191f .. 00		.m5:   db "Sound",0 
1925 .. 00		.m5a:  db "RAM Test",0 
192e .. 00		.m5b:  db "LCD Test",0 
1937			 
1937 .. 00		.m6:   db "Debug ON",0 
1940 .. 00		.m7:   db "Debug OFF",0 
194a			 
194a			; debug editor 
194a			 
194a			.diagedit: 
194a			 
194a 21 c1 f1			ld hl, scratch 
194d			;	ld bc, 250 
194d			;	ldir 
194d				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
194d 3e 00			ld a, 0 
194f 77				ld (hl), a 
1950 23				inc hl 
1951 77				ld (hl), a 
1952 23				inc hl 
1953 77				ld (hl), a 
1954			 
1954 cd 52 0d		        call clear_display 
1957 cd 75 0d			call update_display 
195a				;ld a, 1 
195a				;ld (hardware_diag), a 
195a			.diloop: 
195a 3e 00			ld a, display_row_1 
195c 0e 00			ld c, 0 
195e 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1960 1e 28			ld e, 40 
1962			 
1962 21 c1 f1			ld hl, scratch	 
1965 cd b3 0f			call input_str 
1968			 
1968 3e 28			ld a, display_row_2 
196a 11 c1 f1			ld de, scratch 
196d cd 65 0d			call str_at_display 
1970 cd 75 0d			call update_display 
1973			 
1973 c3 5a 19			jp .diloop 
1976			 
1976			 
1976			; pass word in hl 
1976			; a has display location 
1976			display_word_at: 
1976 f5				push af 
1977 e5				push hl 
1978 7c				ld a,h 
1979 21 c6 f4			ld hl, os_word_scratch 
197c cd 87 12			call hexout 
197f e1				pop hl 
1980 7d				ld a,l 
1981 21 c8 f4			ld hl, os_word_scratch+2 
1984 cd 87 12			call hexout 
1987 21 ca f4			ld hl, os_word_scratch+4 
198a 3e 00			ld a,0 
198c 77				ld (hl),a 
198d 11 c6 f4			ld de,os_word_scratch 
1990 f1				pop af 
1991 cd 65 0d				call str_at_display 
1994 c9				ret 
1995			 
1995			display_ptr_state: 
1995			 
1995				; to restore afterwards 
1995			 
1995 d5				push de 
1996 c5				push bc 
1997 e5				push hl 
1998 f5				push af 
1999			 
1999				; for use in here 
1999			 
1999			;	push bc 
1999			;	push de 
1999			;	push hl 
1999			;	push af 
1999			 
1999 cd 52 0d			call clear_display 
199c			 
199c 11 75 1b			ld de, .ptrstate 
199f 3e 00			ld a, display_row_1 
19a1 cd 65 0d			call str_at_display 
19a4			 
19a4				; display debug step 
19a4			 
19a4			 
19a4 11 6b fe			ld de, debug_mark 
19a7 3e 26			ld a, display_row_1+display_cols-2 
19a9 cd 65 0d			call str_at_display 
19ac			 
19ac				; display a 
19ac 11 7f 1b			ld de, .ptrcliptr 
19af 3e 28			ld a, display_row_2 
19b1 cd 65 0d			call str_at_display 
19b4			 
19b4 f1				pop af 
19b5 2a 40 fa			ld hl,(cli_ptr) 
19b8 3e 30			ld a, display_row_2+8 
19ba cd 76 19			call display_word_at 
19bd			 
19bd			 
19bd				; display hl 
19bd			 
19bd			 
19bd 11 87 1b			ld de, .ptrclioptr 
19c0 3e 32			ld a, display_row_2+10 
19c2 cd 65 0d			call str_at_display 
19c5			; 
19c5			;	pop hl 
19c5 3e 35			ld a, display_row_2+13 
19c7 2a 3e fa			ld hl,(cli_origptr) 
19ca cd 76 19			call display_word_at 
19cd			; 
19cd			;	 
19cd			;	; display de 
19cd			 
19cd			;	ld de, .regstatede 
19cd			;	ld a, display_row_3 
19cd			;	call str_at_display 
19cd			 
19cd			;	pop de 
19cd			;	ld h,d 
19cd			;	ld l, e 
19cd			;	ld a, display_row_3+3 
19cd			;	call display_word_at 
19cd			 
19cd			 
19cd				; display bc 
19cd			 
19cd			;	ld de, .regstatebc 
19cd			;	ld a, display_row_3+10 
19cd			;	call str_at_display 
19cd			 
19cd			;	pop bc 
19cd			;	ld h,b 
19cd			;	ld l, c 
19cd			;	ld a, display_row_3+13 
19cd			;	call display_word_at 
19cd			 
19cd			 
19cd				; display dsp 
19cd			 
19cd			;	ld de, .regstatedsp 
19cd			;	ld a, display_row_4 
19cd			;	call str_at_display 
19cd			 
19cd				 
19cd			;	ld hl,(cli_data_sp) 
19cd			;	ld a, display_row_4+4 
19cd			;	call display_word_at 
19cd			 
19cd				; display rsp 
19cd			 
19cd 11 b6 1b			ld de, .regstatersp 
19d0 3e 82			ld a, display_row_4+10 
19d2 cd 65 0d			call str_at_display 
19d5			 
19d5				 
19d5 2a f2 f9			ld hl,(cli_ret_sp) 
19d8 3e 86			ld a, display_row_4+14 
19da cd 76 19			call display_word_at 
19dd			 
19dd cd 75 0d			call update_display 
19e0			 
19e0 cd 95 0c			call delay1s 
19e3 cd 95 0c			call delay1s 
19e6 cd 95 0c			call delay1s 
19e9			 
19e9			 
19e9 cd 3a 20			call next_page_prompt 
19ec			 
19ec				; restore  
19ec			 
19ec f1				pop af 
19ed e1				pop hl 
19ee c1				pop bc 
19ef d1				pop de 
19f0 c9				ret 
19f1			 
19f1			; Update the break point vector so that the user can hook a new routine 
19f1			 
19f1			bp_on: 
19f1 3e c3			ld a, $c3    ; JP 
19f3 32 6f fe			ld (debug_vector), a 
19f6 21 03 1a			ld hl, break_point_state 
19f9 22 70 fe			ld (debug_vector+1), hl 
19fc c9				ret 
19fd			 
19fd			bp_off: 
19fd 3e c9			ld a, $c9    ; RET 
19ff 32 6f fe			ld (debug_vector), a 
1a02 c9				ret 
1a03			 
1a03			 
1a03			break_point_state: 
1a03			;	push af 
1a03			; 
1a03			;	; see if disabled 
1a03			; 
1a03			;	ld a, (os_view_disable) 
1a03			;	cp '*' 
1a03			;	jr nz, .bpsgo 
1a03			;	pop af 
1a03			;	ret 
1a03			 
1a03			.bpsgo: 
1a03 f1				pop af 
1a04 f5				push af 
1a05 22 af f1			ld (os_view_hl), hl 
1a08 ed 53 ad f1		ld (os_view_de), de 
1a0c ed 43 ab f1		ld (os_view_bc), bc 
1a10 e5				push hl 
1a11 6f				ld l, a 
1a12 26 00			ld h, 0 
1a14 22 b1 f1			ld (os_view_af),hl 
1a17			 
1a17 21 b1 fd				ld hl, display_fb0 
1a1a 22 cc fb				ld (display_fb_active), hl 
1a1d e1				pop hl	 
1a1e			 
1a1e 3e 31			ld a, '1' 
1a20 fe 2a		.bps1:  cp '*' 
1a22 cc fd 19			call z, bp_off 
1a25			;	jr nz, .bps1b 
1a25			;	ld (os_view_disable),a 
1a25 fe 31		.bps1b:  cp '1' 
1a27 20 14			jr nz, .bps2 
1a29			 
1a29				; display reg 
1a29			 
1a29				 
1a29			 
1a29 3a b1 f1			ld a, (os_view_af) 
1a2c 2a af f1			ld hl, (os_view_hl) 
1a2f ed 5b ad f1		ld de, (os_view_de) 
1a33 ed 4b ab f1		ld bc, (os_view_bc) 
1a37 cd d1 1a			call display_reg_state 
1a3a c3 bd 1a			jp .bpschk 
1a3d			 
1a3d fe 32		.bps2:  cp '2' 
1a3f 20 08			jr nz, .bps3 
1a41				 
1a41				; display hl 
1a41 2a af f1			ld hl, (os_view_hl) 
1a44 cd bb 1b			call display_dump_at_hl 
1a47			 
1a47 18 74			jr .bpschk 
1a49			 
1a49 fe 33		.bps3:  cp '3' 
1a4b 20 08			jr nz, .bps4 
1a4d			 
1a4d			        ; display de 
1a4d 2a ad f1			ld hl, (os_view_de) 
1a50 cd bb 1b			call display_dump_at_hl 
1a53			 
1a53 18 68			jr .bpschk 
1a55 fe 34		.bps4:  cp '4' 
1a57 20 08			jr nz, .bps5 
1a59			 
1a59			        ; display bc 
1a59 2a ab f1			ld hl, (os_view_bc) 
1a5c cd bb 1b			call display_dump_at_hl 
1a5f			 
1a5f 18 5c			jr .bpschk 
1a61 fe 35		.bps5:  cp '5' 
1a63 20 08		        jr nz, .bps7 
1a65			 
1a65				; display cur ptr 
1a65 2a 40 fa			ld hl, (cli_ptr) 
1a68 cd bb 1b			call display_dump_at_hl 
1a6b			 
1a6b 18 50			jr .bpschk 
1a6d fe 36		.bps7:  cp '6' 
1a6f 20 08			jr nz, .bps8b 
1a71				 
1a71				; display cur orig ptr 
1a71 2a 3e fa			ld hl, (cli_origptr) 
1a74 cd bb 1b			call display_dump_at_hl 
1a77 18 44			jr .bpschk 
1a79 fe 37		.bps8b:  cp '7' 
1a7b 20 08			jr nz, .bps9 
1a7d				 
1a7d				; display dsp 
1a7d 2a ee f9			ld hl, (cli_data_sp) 
1a80 cd bb 1b			call display_dump_at_hl 
1a83			 
1a83 18 38			jr .bpschk 
1a85 fe 39		.bps9:  cp '9' 
1a87 20 05			jr nz, .bps8c 
1a89				 
1a89				; display SP 
1a89			;	ld hl, sp 
1a89 cd bb 1b			call display_dump_at_hl 
1a8c			 
1a8c 18 2f			jr .bpschk 
1a8e fe 38		.bps8c:  cp '8' 
1a90 20 08			jr nz, .bps8d 
1a92				 
1a92				; display rsp 
1a92 2a f2 f9			ld hl, (cli_ret_sp) 
1a95 cd bb 1b			call display_dump_at_hl 
1a98			 
1a98 18 23			jr .bpschk 
1a9a fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1a9c 20 05			jr nz, .bps8 
1a9e cd 08 1e			call monitor 
1aa1			 
1aa1 18 1a			jr .bpschk 
1aa3 fe 30		.bps8:  cp '0' 
1aa5 20 16			jr nz, .bpschk 
1aa7			 
1aa7 21 10 fd				ld hl, display_fb1 
1aaa 22 cc fb				ld (display_fb_active), hl 
1aad cd 75 0d				call update_display 
1ab0			 
1ab0				;ld a, (os_view_af) 
1ab0 2a af f1			ld hl, (os_view_hl) 
1ab3 ed 5b ad f1		ld de, (os_view_de) 
1ab7 ed 4b ab f1		ld bc, (os_view_bc) 
1abb f1				pop af 
1abc c9				ret 
1abd			 
1abd			.bpschk:   
1abd cd 95 0c			call delay1s 
1ac0 3e 9f		ld a,display_row_4 + display_cols - 1 
1ac2 11 38 20		        ld de, endprg 
1ac5 cd 65 0d			call str_at_display 
1ac8 cd 75 0d			call update_display 
1acb cd 90 78			call cin_wait 
1ace			 
1ace c3 20 1a			jp .bps1 
1ad1			 
1ad1			 
1ad1			display_reg_state: 
1ad1			 
1ad1				; to restore afterwards 
1ad1			 
1ad1 d5				push de 
1ad2 c5				push bc 
1ad3 e5				push hl 
1ad4 f5				push af 
1ad5			 
1ad5				; for use in here 
1ad5			 
1ad5 c5				push bc 
1ad6 d5				push de 
1ad7 e5				push hl 
1ad8 f5				push af 
1ad9			 
1ad9 cd 52 0d			call clear_display 
1adc			 
1adc 11 91 1b			ld de, .regstate 
1adf 3e 00			ld a, display_row_1 
1ae1 cd 65 0d			call str_at_display 
1ae4			 
1ae4				; display debug step 
1ae4			 
1ae4			 
1ae4 11 6b fe			ld de, debug_mark 
1ae7 3e 25			ld a, display_row_1+display_cols-3 
1ae9 cd 65 0d			call str_at_display 
1aec			 
1aec				; display a 
1aec 11 ad 1b			ld de, .regstatea 
1aef 3e 28			ld a, display_row_2 
1af1 cd 65 0d			call str_at_display 
1af4			 
1af4 e1				pop hl 
1af5			;	ld h,0 
1af5			;	ld l, a 
1af5 3e 2b			ld a, display_row_2+3 
1af7 cd 76 19			call display_word_at 
1afa			 
1afa			 
1afa				; display hl 
1afa			 
1afa			 
1afa 11 a1 1b			ld de, .regstatehl 
1afd 3e 32			ld a, display_row_2+10 
1aff cd 65 0d			call str_at_display 
1b02			 
1b02 e1				pop hl 
1b03 3e 35			ld a, display_row_2+13 
1b05 cd 76 19			call display_word_at 
1b08			 
1b08				 
1b08				; display de 
1b08			 
1b08 11 a5 1b			ld de, .regstatede 
1b0b 3e 50			ld a, display_row_3 
1b0d cd 65 0d			call str_at_display 
1b10			 
1b10 e1				pop hl 
1b11			;	ld h,d 
1b11			;	ld l, e 
1b11 3e 53			ld a, display_row_3+3 
1b13 cd 76 19			call display_word_at 
1b16			 
1b16			 
1b16				; display bc 
1b16			 
1b16 11 a9 1b			ld de, .regstatebc 
1b19 3e 5a			ld a, display_row_3+10 
1b1b cd 65 0d			call str_at_display 
1b1e			 
1b1e e1				pop hl 
1b1f			;	ld h,b 
1b1f			;	ld l, c 
1b1f 3e 5d			ld a, display_row_3+13 
1b21 cd 76 19			call display_word_at 
1b24			 
1b24			 
1b24				; display dsp 
1b24			 
1b24 11 b1 1b			ld de, .regstatedsp 
1b27 3e 78			ld a, display_row_4 
1b29 cd 65 0d			call str_at_display 
1b2c			 
1b2c				 
1b2c 2a ee f9			ld hl,(cli_data_sp) 
1b2f 3e 7c			ld a, display_row_4+4 
1b31 cd 76 19			call display_word_at 
1b34			 
1b34				; display rsp 
1b34			 
1b34 11 b6 1b			ld de, .regstatersp 
1b37 3e 82			ld a, display_row_4+10 
1b39 cd 65 0d			call str_at_display 
1b3c			 
1b3c				 
1b3c 2a f2 f9			ld hl,(cli_ret_sp) 
1b3f 3e 86			ld a, display_row_4+14 
1b41 cd 76 19			call display_word_at 
1b44			 
1b44 cd 75 0d			call update_display 
1b47			 
1b47			;	call delay1s 
1b47			;	call delay1s 
1b47			;	call delay1s 
1b47			 
1b47			 
1b47			;	call next_page_prompt 
1b47			 
1b47				; restore  
1b47			 
1b47 f1				pop af 
1b48 e1				pop hl 
1b49 c1				pop bc 
1b4a d1				pop de 
1b4b c9				ret 
1b4c			 
1b4c .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1b60 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1b75 .. 00		.ptrstate:	db "Ptr State",0 
1b7f .. 00		.ptrcliptr:     db "cli_ptr",0 
1b87 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1b91 .. 00		.regstate:	db "Reg State (1/0)",0 
1ba1 .. 00		.regstatehl:	db "HL:",0 
1ba5 .. 00		.regstatede:	db "DE:",0 
1ba9 .. 00		.regstatebc:	db "BC:",0 
1bad .. 00		.regstatea:	db "A :",0 
1bb1 .. 00		.regstatedsp:	db "DSP:",0 
1bb6 .. 00		.regstatersp:	db "RSP:",0 
1bbb			 
1bbb			display_dump_at_hl: 
1bbb e5				push hl 
1bbc d5				push de 
1bbd c5				push bc 
1bbe f5				push af 
1bbf			 
1bbf 22 e4 f4			ld (os_cur_ptr),hl	 
1bc2 cd 52 0d			call clear_display 
1bc5 cd 42 1f			call dumpcont 
1bc8			;	call delay1s 
1bc8			;	call next_page_prompt 
1bc8			 
1bc8			 
1bc8 f1				pop af 
1bc9 c1				pop bc 
1bca d1				pop de 
1bcb e1				pop hl 
1bcc c9				ret 
1bcd			 
1bcd			;if ENABLE_BASIC 
1bcd			;	include "nascombasic.asm" 
1bcd			;	basic: 
1bcd			;	include "forth/FORTH.ASM" 
1bcd			;endif 
1bcd			 
1bcd			; eof 
1bcd			 
1bcd			 
# End of file firmware_diags.asm
1bcd			  
1bcd			include "firmware_prompts.asm"  
1bcd			; Prompts  
1bcd			 
1bcd			; boot messages 
1bcd			 
1bcd .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1be2 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1bf2			 
1bf2			 
1bf2			; config menus 
1bf2			 
1bf2			;prom_c3: db "Add Dictionary To File",0 
1bf2			 
1bf2			if STARTUP_V1 
1bf2			prom_c2: db "Select Autoload File",0 
1bf2			prom_c2a: db "Disable Autoload File", 0 
1bf2			endif 
1bf2			 
1bf2			if STARTUP_V2 
1bf2 .. 00		prom_c2: db "Enable Autoload Files",0 
1c08 .. 00		prom_c2a: db "Disable Autoload Files", 0 
1c1f			 
1c1f .. 00		crs_s1: db "*ls-word", 0 
1c28 .. 00		crs_s2: db "*ed-word", 0 
1c31 .. 00		crs_s3: db "*Demo-Programs", 0 
1c40 .. 00		crs_s4: db "*Utils", 0 
1c47 .. 00		crs_s5: db "*SPI-Addons", 0 
1c53 .. 00		crs_s6: db "*Key-constants", 0 
1c62			 
1c62			 
1c62			 
1c62			endif 
1c62			;prom_c2b: db "Select Storage Bank",0 
1c62 .. 00		prom_c4: db "Settings",0 
1c6b .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1c86 .. 00		prom_m4b:   db "Monitor",0 
1c8e .. 00		prom_c1: db "Hardware Diags",0 
1c9d			 
1c9d			 
1c9d			if STARTUP_V2 
1c9d .. 00		prom_c9: db "Create Startup Files",0 
1cb2			endif 
1cb2			 
1cb2 .. 00		prom_notav:    db "Feature not available",0 
1cc8 .. 00		prom_empty:    db "",0 
1cc9			 
1cc9			; eof 
1cc9			 
# End of file firmware_prompts.asm
1cc9			  
1cc9			  
1cc9			; eof  
1cc9			  
# End of file firmware.asm
1cc9			 
1cc9			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1cc9			;if BASE_KEV  
1cc9			;baseram: equ 08000h 
1cc9			;endif 
1cc9			 
1cc9			;if BASE_SC114 
1cc9			;baseram:     equ    endofcode 
1cc9			;endif 
1cc9			 
1cc9			 
1cc9			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1cc9			 
1cc9			; start system 
1cc9			 
1cc9			coldstart: 
1cc9				; set sp 
1cc9				; di/ei 
1cc9			 
1cc9 f3				di 
1cca 31 fd ff			ld sp, tos 
1ccd			;	ei 
1ccd			 
1ccd				; init spinner 
1ccd 3e 00			ld a,0 
1ccf 32 c6 fb			ld (display_active), a 
1cd2			 
1cd2				; disable breakpoint by default 
1cd2			 
1cd2				;ld a,'*' 
1cd2			;	ld a,' ' 
1cd2			;	ld (os_view_disable),a 
1cd2			 
1cd2				; set break point vector as new break point on or off 
1cd2 cd fd 19			call bp_off 
1cd5			 
1cd5				; init hardware 
1cd5			 
1cd5				; init keyboard and screen hardware 
1cd5			 
1cd5 cd 1c 00			call hardware_init 
1cd8			 
1cd8			 
1cd8 cd 95 0c			call delay1s 
1cdb 3e 58			ld a, display_row_3+8 
1cdd 11 03 00			ld de, buildtime 
1ce0 cd 65 0d			call str_at_display 
1ce3 cd 75 0d			call update_display 
1ce6			 
1ce6 cd 95 0c			call delay1s 
1ce9 cd 95 0c			call delay1s 
1cec cd 95 0c			call delay1s 
1cef			 
1cef				; detect if any keys are held down to enable breakpoints at start up 
1cef			 
1cef cd a1 78			call cin  
1cf2 fe 00			cp 0 
1cf4 28 03			jr z, .nokeys 
1cf6			 
1cf6				;call hardware_diags 
1cf6 cd 10 16			call config 
1cf9			 
1cf9			;	ld de, .bpen 
1cf9			;	ld a, display_row_4 
1cf9			;	call str_at_display 
1cf9			;	call update_display 
1cf9			; 
1cf9			;	ld a,0 
1cf9			;	ld (os_view_disable),a 
1cf9			; 
1cf9			;.bpwait: 
1cf9			;	call cin 
1cf9			;	cp 0 
1cf9			;	jr z, .bpwait 
1cf9			;	jr .nokeys 
1cf9			; 
1cf9			; 
1cf9			;.bpen:  db "Break points enabled!",0 
1cf9			 
1cf9			 
1cf9			 
1cf9			 
1cf9			 
1cf9			 
1cf9			.nokeys: 
1cf9			 
1cf9			 
1cf9				 
1cf9			 
1cf9			;jp  testkey 
1cf9			 
1cf9			;call storage_get_block_0 
1cf9			; 
1cf9			;ld hl, 0 
1cf9			;ld de, store_page 
1cf9			;call storage_read_block 
1cf9			 
1cf9				 
1cf9			;ld hl, 10 
1cf9			;ld de, store_page 
1cf9			;call storage_read_block 
1cf9			 
1cf9			 
1cf9			 
1cf9			 
1cf9			 
1cf9			;stop:	nop 
1cf9			;	jp stop 
1cf9			 
1cf9			 
1cf9			 
1cf9			main: 
1cf9 cd 52 0d			call clear_display 
1cfc cd 75 0d			call update_display 
1cff			 
1cff			 
1cff			 
1cff			;	call testlcd 
1cff			 
1cff			 
1cff			 
1cff cd 3f 24			call forth_init 
1d02			 
1d02			 
1d02			warmstart: 
1d02 cd 15 24			call forth_warmstart 
1d05			 
1d05				; run startup word load 
1d05			        ; TODO prevent this running at warmstart after crash  
1d05			 
1d05				if STARTUP_ENABLE 
1d05			 
1d05					if STARTUP_V1 
1d05			 
1d05						if STORAGE_SE 
1d05							call forth_autoload 
1d05						endif 
1d05						call forth_startup 
1d05					endif 
1d05			 
1d05					if STARTUP_V2 
1d05			 
1d05						if STORAGE_SE 
1d05 cd 58 73						call forth_autoload 
1d08						else 
1d08							call forth_startup 
1d08						endif 
1d08			 
1d08			 
1d08					endif 
1d08			 
1d08				endif 
1d08			 
1d08				; show free memory after boot 
1d08 11 a2 1d			ld de, freeram 
1d0b 3e 00			ld a, display_row_1 
1d0d cd 65 0d			call str_at_display 
1d10			 
1d10			; Or use heap_size word???? 
1d10 21 a8 f1			ld hl, heap_end 
1d13 11 0e 80			ld de, heap_start 
1d16 ed 52			sbc hl, de 
1d18 e5				push hl 
1d19 7c				ld a,h	         	 
1d1a 21 c6 f4			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1d1d cd 87 12			call hexout 
1d20 e1			   	pop hl 
1d21			 
1d21 7d				ld a,l 
1d22 21 c8 f4			ld hl, os_word_scratch+2 
1d25 cd 87 12			call hexout 
1d28 21 ca f4			ld hl, os_word_scratch+4 
1d2b 3e 00			ld a, 0 
1d2d 77				ld (hl),a 
1d2e 11 c6 f4			ld de, os_word_scratch 
1d31 3e 0d			ld a, display_row_1 + 13 
1d33 cd 65 0d			call str_at_display 
1d36 cd 75 0d			call update_display 
1d39			 
1d39			 
1d39				;call demo 
1d39			 
1d39			 
1d39				; init scratch input area for cli commands 
1d39			 
1d39 21 e8 f4			ld hl, os_cli_cmd 
1d3c 3e 00			ld a,0 
1d3e 77				ld (hl),a 
1d3f 23				inc hl 
1d40 77				ld (hl),a 
1d41			 
1d41 3e 00			ld a,0 
1d43 32 e7 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1d46			 
1d46 32 e4 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1d49 32 e5 f4			ld (os_cur_ptr+1),a	 
1d4c			 
1d4c 32 c6 f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1d4f 32 c7 f4			ld (os_word_scratch+1),a	 
1d52				 
1d52			 
1d52				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d52 21 e8 f4			ld hl, os_cli_cmd 
1d55			 
1d55 3e 00			ld a, 0		 ; init cli input 
1d57 77				ld (hl), a 
1d58 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d5a			cli: 
1d5a				; show cli prompt 
1d5a				;push af 
1d5a				;ld a, 0 
1d5a				;ld de, prompt 
1d5a				;call str_at_display 
1d5a			 
1d5a				;call update_display 
1d5a				;pop af 
1d5a				;inc a 
1d5a				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1d5a 0e 00			ld c, 0 
1d5c 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1d5e 1e 28			ld e, 40 
1d60			 
1d60 21 e8 f4			ld hl, os_cli_cmd 
1d63			 
1d63				STACKFRAME OFF $fefe $9f9f 
1d63				if DEBUG_STACK_IMB 
1d63					if OFF 
1d63						exx 
1d63						ld de, $fefe 
1d63						ld a, d 
1d63						ld hl, curframe 
1d63						call hexout 
1d63						ld a, e 
1d63						ld hl, curframe+2 
1d63						call hexout 
1d63						ld hl, $fefe 
1d63						push hl 
1d63						ld hl, $9f9f 
1d63						push hl 
1d63						exx 
1d63					endif 
1d63				endif 
1d63			endm 
# End of macro STACKFRAME
1d63			 
1d63 cd b3 0f			call input_str 
1d66			 
1d66				STACKFRAMECHK OFF $fefe $9f9f 
1d66				if DEBUG_STACK_IMB 
1d66					if OFF 
1d66						exx 
1d66						ld hl, $9f9f 
1d66						pop de   ; $9f9f 
1d66						call cmp16 
1d66						jr nz, .spnosame 
1d66						ld hl, $fefe 
1d66						pop de   ; $fefe 
1d66						call cmp16 
1d66						jr z, .spfrsame 
1d66						.spnosame: call showsperror 
1d66						.spfrsame: nop 
1d66						exx 
1d66					endif 
1d66				endif 
1d66			endm 
# End of macro STACKFRAMECHK
1d66			 
1d66				; copy input to last command 
1d66			 
1d66 21 e8 f4			ld hl, os_cli_cmd 
1d69 11 e7 f5			ld de, os_last_cmd 
1d6c 01 ff 00			ld bc, 255 
1d6f ed b0			ldir 
1d71			 
1d71				; wipe current buffer 
1d71			 
1d71			;	ld a, 0 
1d71			;	ld hl, os_cli_cmd 
1d71			;	ld de, os_cli_cmd+1 
1d71			;	ld bc, 254 
1d71			;	ldir 
1d71				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1d71			;	call strcpy 
1d71			;	ld a, 0 
1d71			;	ld (hl), a 
1d71			;	inc hl 
1d71			;	ld (hl), a 
1d71			;	inc hl 
1d71			;	ld (hl), a 
1d71			 
1d71				; switch frame buffer to program  
1d71			 
1d71 21 10 fd				ld hl, display_fb1 
1d74 22 cc fb				ld (display_fb_active), hl 
1d77			 
1d77			;	nop 
1d77				STACKFRAME ON $fbfe $8f9f 
1d77				if DEBUG_STACK_IMB 
1d77					if ON 
1d77						exx 
1d77						ld de, $fbfe 
1d77						ld a, d 
1d77						ld hl, curframe 
1d77						call hexout 
1d77						ld a, e 
1d77						ld hl, curframe+2 
1d77						call hexout 
1d77						ld hl, $fbfe 
1d77						push hl 
1d77						ld hl, $8f9f 
1d77						push hl 
1d77						exx 
1d77					endif 
1d77				endif 
1d77			endm 
# End of macro STACKFRAME
1d77				; first time into the parser so pass over the current scratch pad 
1d77 21 e8 f4			ld hl,os_cli_cmd 
1d7a				; tokenise the entered statement(s) in HL 
1d7a cd bd 24			call forthparse 
1d7d			        ; exec forth statements in top of return stack 
1d7d cd fd 24			call forthexec 
1d80				;call forthexec_cleanup 
1d80			;	call parsenext 
1d80			 
1d80				STACKFRAMECHK ON $fbfe $8f9f 
1d80				if DEBUG_STACK_IMB 
1d80					if ON 
1d80						exx 
1d80						ld hl, $8f9f 
1d80						pop de   ; $8f9f 
1d80						call cmp16 
1d80						jr nz, .spnosame 
1d80						ld hl, $fbfe 
1d80						pop de   ; $fbfe 
1d80						call cmp16 
1d80						jr z, .spfrsame 
1d80						.spnosame: call showsperror 
1d80						.spfrsame: nop 
1d80						exx 
1d80					endif 
1d80				endif 
1d80			endm 
# End of macro STACKFRAMECHK
1d80				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1d80			 
1d80 3e 78			ld a, display_row_4 
1d82 11 b4 1d			ld de, endprog 
1d85			 
1d85 cd 75 0d			call update_display		 
1d88			 
1d88 cd 3a 20			call next_page_prompt 
1d8b			 
1d8b				; switch frame buffer to cli 
1d8b			 
1d8b 21 b1 fd				ld hl, display_fb0 
1d8e 22 cc fb				ld (display_fb_active), hl 
1d91			 
1d91			 
1d91 cd 52 0d		        call clear_display 
1d94 cd 75 0d			call update_display		 
1d97			 
1d97 21 e8 f4			ld hl, os_cli_cmd 
1d9a			 
1d9a 3e 00			ld a, 0		 ; init cli input 
1d9c 77				ld (hl), a 
1d9d			 
1d9d				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1d9d			 
1d9d				; now on last line 
1d9d			 
1d9d				; TODO scroll screen up 
1d9d			 
1d9d				; TODO instead just clear screen and place at top of screen 
1d9d			 
1d9d			;	ld a, 0 
1d9d			;	ld (f_cursor_ptr),a 
1d9d			 
1d9d				;call clear_display 
1d9d				;call update_display 
1d9d			 
1d9d				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d9d 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d9f c3 5a 1d			jp cli 
1da2			 
1da2 .. 00		freeram: db "Free bytes: $",0 
1db0 ..			asc: db "1A2F" 
1db4 .. 00		endprog: db "End prog...",0 
1dc0			 
1dc0			testenter2:   
1dc0 21 f3 f1			ld hl,scratch+50 
1dc3 22 e4 f4			ld (os_cur_ptr),hl 
1dc6 c3 5a 1d			jp cli 
1dc9			 
1dc9			testenter:  
1dc9			 
1dc9 21 b0 1d			ld hl,asc 
1dcc			;	ld a,(hl) 
1dcc			;	call nibble2val 
1dcc cd dd 12			call get_byte 
1dcf			 
1dcf			 
1dcf			;	ld a,(hl) 
1dcf			;	call atohex 
1dcf			 
1dcf			;	call fourehexhl 
1dcf 32 f3 f1			ld (scratch+50),a 
1dd2			 
1dd2			 
1dd2			 
1dd2 21 b2 1d			ld hl,asc+2 
1dd5			;	ld a, (hl) 
1dd5			;	call nibble2val 
1dd5 cd dd 12			call get_byte 
1dd8			 
1dd8			;	call fourehexhl 
1dd8 32 f5 f1			ld (scratch+52),a 
1ddb				 
1ddb 21 f3 f1			ld hl,scratch+50 
1dde 22 e4 f4			ld (os_cur_ptr),hl 
1de1 c3 5a 1d			jp cli 
1de4			 
1de4			enter:	 
1de4 3a c5 f1			ld a,(scratch+4) 
1de7 fe 00			cp 0 
1de9 28 0c			jr z, .entercont 
1deb				; no, not a null term line so has an address to work out.... 
1deb			 
1deb 21 c3 f1			ld hl,scratch+2 
1dee cd 3d 13			call get_word_hl 
1df1			 
1df1 22 e4 f4			ld (os_cur_ptr),hl	 
1df4 c3 5a 1d			jp cli 
1df7			 
1df7			 
1df7			.entercont:  
1df7			 
1df7 21 c3 f1			ld hl, scratch+2 
1dfa cd dd 12			call get_byte 
1dfd			 
1dfd 2a e4 f4		   	ld hl,(os_cur_ptr) 
1e00 77					ld (hl),a 
1e01 23					inc hl 
1e02 22 e4 f4				ld (os_cur_ptr),hl 
1e05				 
1e05			; get byte  
1e05			 
1e05			 
1e05 c3 5a 1d			jp cli 
1e08			 
1e08			 
1e08			; basic monitor support 
1e08			 
1e08			monitor: 
1e08				;  
1e08 cd 52 0d			call clear_display 
1e0b 3e 00			ld a, 0 
1e0d 11 5c 1e			ld de, .monprompt 
1e10 cd 65 0d			call str_at_display 
1e13 cd 75 0d			call update_display 
1e16			 
1e16				; get a monitor command 
1e16			 
1e16 0e 00			ld c, 0     ; entry at top left 
1e18 16 64			ld d, 100   ; max buffer size 
1e1a 1e 0f			ld e, 15    ; input scroll area 
1e1c 3e 00			ld a, 0     ; init string 
1e1e 21 bf f3			ld hl, os_input 
1e21 77				ld (hl), a 
1e22 23				inc hl 
1e23 77				ld (hl), a 
1e24 21 bf f3			ld hl, os_input 
1e27 3e 01			ld a, 1     ; init string 
1e29 cd b3 0f			call input_str 
1e2c			 
1e2c cd 52 0d		        call clear_display 
1e2f cd 75 0d			call update_display		 
1e32			 
1e32 3a bf f3			ld a, (os_input) 
1e35 cd db 13			call toUpper 
1e38 fe 48		        cp 'H' 
1e3a ca c1 1e		        jp z, .monhelp 
1e3d fe 44			cp 'D'		; dump 
1e3f ca f4 1e			jp z, .mondump	 
1e42 fe 43			cp 'C'		; dump 
1e44 ca 0e 1f			jp z, .moncdump	 
1e47 fe 4d			cp 'M'		; dump 
1e49 ca 5e 1e			jp z, .moneditstart 
1e4c fe 55			cp 'U'		; dump 
1e4e ca 6a 1e			jp z, .monedit	 
1e51 fe 47			cp 'G'		; dump 
1e53 ca ea 1e			jp z, .monjump 
1e56 fe 51			cp 'Q'		; dump 
1e58 c8				ret z	 
1e59			 
1e59			 
1e59				; TODO "S" to access symbol by name and not need the address 
1e59				; TODO "F" to find a string in memory 
1e59			 
1e59 c3 08 1e			jp monitor 
1e5c			 
1e5c .. 00		.monprompt: db ">", 0 
1e5e			 
1e5e			.moneditstart: 
1e5e				; get starting address 
1e5e			 
1e5e 21 c1 f3			ld hl,os_input+2 
1e61 cd 3d 13			call get_word_hl 
1e64			 
1e64 22 e4 f4			ld (os_cur_ptr),hl	 
1e67			 
1e67 c3 08 1e			jp monitor 
1e6a			 
1e6a			.monedit: 
1e6a				; get byte to load 
1e6a			 
1e6a 21 c1 f3			ld hl,os_input+2 
1e6d cd dd 12			call get_byte 
1e70			 
1e70				; get address to update 
1e70 2a e4 f4			ld hl, (os_cur_ptr) 
1e73			 
1e73				; update byte 
1e73			 
1e73 77				ld (hl), a 
1e74			 
1e74				; move to next address and save it 
1e74			 
1e74 23				inc hl 
1e75 22 e4 f4			ld (os_cur_ptr),hl	 
1e78			 
1e78 c3 08 1e			jp monitor 
1e7b			 
1e7b			 
1e7b .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1e8f .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1eab .. 00		.monhelptext3:  db "G-Call address",0 
1eba .. 00		.monhelptext4:  db "Q-Quit",0 
1ec1			        
1ec1			.monhelp: 
1ec1 3e 00			ld a, display_row_1 
1ec3 11 7b 1e		        ld de, .monhelptext1 
1ec6			 
1ec6 cd 65 0d			call str_at_display 
1ec9 3e 28			ld a, display_row_2 
1ecb 11 8f 1e		        ld de, .monhelptext2 
1ece					 
1ece cd 65 0d			call str_at_display 
1ed1 3e 50			ld a, display_row_3 
1ed3 11 ab 1e		        ld de, .monhelptext3 
1ed6					 
1ed6 cd 65 0d			call str_at_display 
1ed9 3e 78			ld a, display_row_4 
1edb 11 ba 1e		        ld de, .monhelptext4 
1ede cd 65 0d			call str_at_display 
1ee1			 
1ee1 cd 75 0d			call update_display		 
1ee4			 
1ee4 cd 3a 20			call next_page_prompt 
1ee7 c3 08 1e			jp monitor 
1eea			 
1eea			.monjump:    
1eea 21 c1 f3			ld hl,os_input+2 
1eed cd 3d 13			call get_word_hl 
1ef0			 
1ef0 e9				jp (hl) 
1ef1 c3 08 1e			jp monitor 
1ef4			 
1ef4			.mondump:    
1ef4 21 c1 f3			ld hl,os_input+2 
1ef7 cd 3d 13			call get_word_hl 
1efa			 
1efa 22 e4 f4			ld (os_cur_ptr),hl	 
1efd cd 42 1f			call dumpcont 
1f00 3e 78			ld a, display_row_4 
1f02 11 b4 1d			ld de, endprog 
1f05			 
1f05 cd 75 0d			call update_display		 
1f08			 
1f08 cd 3a 20			call next_page_prompt 
1f0b c3 08 1e			jp monitor 
1f0e			.moncdump: 
1f0e cd 42 1f			call dumpcont 
1f11 3e 78			ld a, display_row_4 
1f13 11 b4 1d			ld de, endprog 
1f16			 
1f16 cd 75 0d			call update_display		 
1f19			 
1f19 cd 3a 20			call next_page_prompt 
1f1c c3 08 1e			jp monitor 
1f1f			 
1f1f			 
1f1f			; TODO symbol access  
1f1f			 
1f1f			.symbols:     ;; A list of symbols that can be called up  
1f1f b1 fd			dw display_fb0 
1f21 .. 00			db "fb0",0  
1f25 7a fa		     	dw store_page 
1f27 .. 00			db "store_page",0 
1f32			 
1f32			 
1f32			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1f32			 
1f32 3a c2 f1			ld a,(scratch+1) 
1f35 fe 00			cp 0 
1f37 28 09			jr z, dumpcont 
1f39			 
1f39				; no, not a null term line so has an address to work out.... 
1f39			 
1f39 21 c3 f1			ld hl,scratch+2 
1f3c cd 3d 13			call get_word_hl 
1f3f			 
1f3f 22 e4 f4			ld (os_cur_ptr),hl	 
1f42			 
1f42			 
1f42			 
1f42			dumpcont: 
1f42			 
1f42				; dump bytes at ptr 
1f42			 
1f42			 
1f42 3e 00			ld a, display_row_1 
1f44 2a cc fb			ld hl, (display_fb_active) 
1f47 cd 86 0f			call addatohl 
1f4a cd 72 1f			call .dumpbyterow 
1f4d			 
1f4d 3e 28			ld a, display_row_2 
1f4f 2a cc fb			ld hl, (display_fb_active) 
1f52 cd 86 0f			call addatohl 
1f55 cd 72 1f			call .dumpbyterow 
1f58			 
1f58			 
1f58 3e 50			ld a, display_row_3 
1f5a 2a cc fb			ld hl, (display_fb_active) 
1f5d cd 86 0f			call addatohl 
1f60 cd 72 1f			call .dumpbyterow 
1f63			 
1f63 3e 78			ld a, display_row_4 
1f65 2a cc fb			ld hl, (display_fb_active) 
1f68 cd 86 0f			call addatohl 
1f6b cd 72 1f			call .dumpbyterow 
1f6e			 
1f6e cd 75 0d			call update_display 
1f71			;		jp cli 
1f71 c9				ret 
1f72			 
1f72			.dumpbyterow: 
1f72			 
1f72				;push af 
1f72			 
1f72 e5				push hl 
1f73			 
1f73				; calc where to poke the ascii 
1f73			if display_cols == 20 
1f73				ld a, 16 
1f73			else 
1f73 3e 1f			ld a, 31 
1f75			endif 
1f75			 
1f75 cd 86 0f			call addatohl 
1f78 22 c6 f4			ld (os_word_scratch),hl  		; save pos for later 
1f7b			 
1f7b			 
1f7b			; display decoding address 
1f7b 2a e4 f4		   	ld hl,(os_cur_ptr) 
1f7e			 
1f7e 7c				ld a,h 
1f7f e1				pop hl 
1f80 e5				push hl 
1f81			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1f81 cd 87 12			call hexout 
1f84 2a e4 f4		   	ld hl,(os_cur_ptr) 
1f87			 
1f87 7d				ld a,l 
1f88 e1				pop hl 
1f89 23				inc hl 
1f8a 23				inc hl 
1f8b e5				push hl 
1f8c			;	ld hl, os_word_scratch+2 
1f8c cd 87 12			call hexout 
1f8f e1				pop hl 
1f90 23				inc hl 
1f91 23				inc hl 
1f92				;ld hl, os_word_scratch+4 
1f92 3e 3a			ld a, ':' 
1f94 77				ld (hl),a 
1f95 23				inc hl 
1f96				;ld a, 0 
1f96				;ld (hl),a 
1f96				;ld de, os_word_scratch 
1f96				;pop af 
1f96				;push af 
1f96			;		ld a, display_row_2 
1f96			;		call str_at_display 
1f96			;		call update_display 
1f96			 
1f96			 
1f96			;pop af 
1f96			;	add 5 
1f96			 
1f96			if display_cols == 20 
1f96				ld b, 4 
1f96			else 
1f96 06 08			ld b, 8 
1f98			endif	 
1f98			 
1f98			.dumpbyte: 
1f98 c5				push bc 
1f99 e5				push hl 
1f9a			 
1f9a			 
1f9a 2a e4 f4		   	ld hl,(os_cur_ptr) 
1f9d 7e					ld a,(hl) 
1f9e			 
1f9e					; poke the ascii to display 
1f9e 2a c6 f4				ld hl,(os_word_scratch) 
1fa1 77					ld (hl),a 
1fa2 23					inc hl 
1fa3 22 c6 f4				ld (os_word_scratch),hl 
1fa6			 
1fa6					 
1fa6			 
1fa6			 
1fa6 e1					pop hl 
1fa7 e5					push hl 
1fa8			 
1fa8 cd 87 12				call hexout 
1fab			 
1fab					 
1fab 2a e4 f4		   	ld hl,(os_cur_ptr) 
1fae 23				inc hl 
1faf 22 e4 f4		   	ld (os_cur_ptr),hl 
1fb2			 
1fb2 e1					pop hl 
1fb3 23					inc hl 
1fb4 23					inc hl 
1fb5 23					inc hl 
1fb6			 
1fb6			 
1fb6			 
1fb6					;ld a,0 
1fb6					;ld (os_word_scratch+2),a 
1fb6					;pop af 
1fb6					;push af 
1fb6			 
1fb6					;ld de, os_word_scratch 
1fb6					;call str_at_display 
1fb6			;		call update_display 
1fb6			;		pop af 
1fb6 c1					pop bc 
1fb7 c6 03				add 3 
1fb9 10 dd			djnz .dumpbyte 
1fbb			 
1fbb				 
1fbb			 
1fbb c9				ret 
1fbc			 
1fbc			jump:	 
1fbc			 
1fbc 21 c3 f1			ld hl,scratch+2 
1fbf cd 3d 13			call get_word_hl 
1fc2				;ld hl,(scratch+2) 
1fc2				;call fourehexhl 
1fc2			 
1fc2 22 e4 f4			ld (os_cur_ptr),hl	 
1fc5			 
1fc5 e9				jp (hl) 
1fc6			 
1fc6			 
1fc6			 
1fc6			; TODO implement a basic monitor mode to start with 
1fc6			 
1fc6			 
1fc6			 
1fc6			 
1fc6			 
1fc6			 
1fc6			 
1fc6			 
1fc6			 
1fc6			; testing and demo code during development 
1fc6			 
1fc6			 
1fc6 .. 00		str1: db "Enter some text...",0 
1fd9 .. 00		clear: db "                    ",0 
1fee			 
1fee			demo: 
1fee			 
1fee			 
1fee			 
1fee			;	call update_display 
1fee			 
1fee				; init scratch input area for testing 
1fee 21 c1 f1			ld hl, scratch	 
1ff1 3e 00			ld a,0 
1ff3 77				ld (hl),a 
1ff4			 
1ff4			 
1ff4 3e 28		            LD   A, display_row_2 
1ff6			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ff6 11 c6 1f		            LD   DE, str1 
1ff9 cd 65 0d			call str_at_display 
1ffc			 
1ffc			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ffc			cloop:	 
1ffc 3e 50		            LD   A, display_row_3 
1ffe			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ffe 11 d9 1f		            LD   DE, clear 
2001			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
2001 cd 65 0d				call str_at_display 
2004 3e 78			ld a, display_row_4 
2006 11 36 20			ld de, prompt 
2009			 
2009 cd 65 0d				call str_at_display 
200c cd 75 0d			call update_display 
200f			 
200f 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
2011 16 0a			ld d, 10 
2013 21 c1 f1			ld hl, scratch	 
2016 cd b3 0f			call input_str 
2019			 
2019			;	call clear_display 
2019			;'	call update_display 
2019			 
2019 3e 00		            LD   A, display_row_1 
201b			;            CALL fLCD_Pos       ;Position cursor to location in A 
201b 11 d9 1f		            LD   DE, clear 
201e cd 65 0d				call str_at_display 
2021			;            CALL fLCD_Str       ;Display string pointed to by DE 
2021 3e 00		            LD   A, display_row_1 
2023			;            CALL fLCD_Pos       ;Position cursor to location in A 
2023 11 c1 f1		            LD   DE, scratch 
2026			;            CALL fLCD_Str       ;Display string pointed to by DE 
2026 cd 65 0d				call str_at_display 
2029 cd 75 0d			call update_display 
202c			 
202c 3e 00				ld a,0 
202e 21 c1 f1			ld hl, scratch 
2031 77				ld (hl),a 
2032			 
2032 00				nop 
2033 c3 fc 1f			jp cloop 
2036			 
2036			 
2036			 
2036			; OS Prompt 
2036			 
2036 .. 00		prompt: db ">",0 
2038 .. 00		endprg: db "?",0 
203a			 
203a			 
203a			; handy next page prompt 
203a			next_page_prompt: 
203a e5				push hl 
203b d5				push de 
203c f5				push af 
203d c5				push bc 
203e			 
203e 3e 9f			ld a,display_row_4 + display_cols - 1 
2040 11 38 20		        ld de, endprg 
2043 cd 65 0d			call str_at_display 
2046 cd 75 0d			call update_display 
2049 cd 90 78			call cin_wait 
204c c1				pop bc 
204d f1				pop af 
204e d1				pop de 
204f e1				pop hl 
2050			 
2050			 
2050 c9				ret 
2051			 
2051			 
2051			; forth parser 
2051			 
2051			; My forth kernel 
2051			include "forth_kernel.asm" 
2051			; 
2051			; kernel to the forth OS 
2051			 
2051			DS_TYPE_STR: equ 1     ; string type 
2051			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
2051			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
2051			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
2051			 
2051			FORTH_PARSEV1: equ 0 
2051			FORTH_PARSEV2: equ 0 
2051			FORTH_PARSEV3: equ 0 
2051			FORTH_PARSEV4: equ 0 
2051			FORTH_PARSEV5: equ 1 
2051			 
2051			;if FORTH_PARSEV5 
2051			;	FORTH_END_BUFFER: equ 0 
2051			;else 
2051			FORTH_END_BUFFER: equ 127 
2051			;endif 
2051			 
2051			FORTH_TRUE: equ 1 
2051			FORTH_FALSE: equ 0 
2051			 
2051			if FORTH_PARSEV4 
2051			include "forth_stackops.asm" 
2051			endif 
2051			 
2051			if FORTH_PARSEV5 
2051			include "forth_stackopsv5.asm" 
2051			 
2051			; Stack operations for v5 parser on wards 
2051			; * DATA stack 
2051			; * LOOP stack 
2051			; * RETURN stack 
2051			 
2051			 
2051			 
2051			FORTH_CHK_DSP_UNDER: macro 
2051				push hl 
2051				push de 
2051				ld hl,(cli_data_sp) 
2051				ld de, cli_data_stack 
2051				call cmp16 
2051				jp c, fault_dsp_under 
2051				pop de 
2051				pop hl 
2051				endm 
2051			 
2051			 
2051			FORTH_CHK_RSP_UNDER: macro 
2051				push hl 
2051				push de 
2051				ld hl,(cli_ret_sp) 
2051				ld de, cli_ret_stack 
2051				call cmp16 
2051				jp c, fault_rsp_under 
2051				pop de 
2051				pop hl 
2051				endm 
2051			 
2051			FORTH_CHK_LOOP_UNDER: macro 
2051				push hl 
2051				push de 
2051				ld hl,(cli_loop_sp) 
2051				ld de, cli_loop_stack 
2051				call cmp16 
2051				jp c, fault_loop_under 
2051				pop de 
2051				pop hl 
2051				endm 
2051			 
2051			FORTH_ERR_TOS_NOTSTR: macro 
2051				; TOSO might need more for checks when used 
2051				push af 
2051				ld a,(hl) 
2051				cp DS_TYPE_STR 
2051				jp nz, type_faultn   
2051				pop af 
2051				endm 
2051			 
2051			FORTH_ERR_TOS_NOTNUM: macro 
2051				push af 
2051				ld a,(hl) 
2051				cp DS_TYPE_INUM 
2051				jp nz, type_faultn   
2051				pop af 
2051				endm 
2051			 
2051			 
2051			; increase data stack pointer and save hl to it 
2051				 
2051			FORTH_DSP_NEXT: macro 
2051				call macro_forth_dsp_next 
2051				endm 
2051			 
2051			 
2051			macro_forth_dsp_next: 
2051				if DEBUG_FORTH_STACK_GUARD 
2051 cd 50 71				call check_stacks 
2054				endif 
2054 e5				push hl 
2055 d5				push de 
2056 eb				ex de,hl 
2057 2a ee f9			ld hl,(cli_data_sp) 
205a 23				inc hl 
205b 23				inc hl 
205c			 
205c			; PARSEV5 
205c 23				inc hl 
205d 22 ee f9			ld (cli_data_sp),hl 
2060 73				ld (hl), e 
2061 23				inc hl 
2062 72				ld (hl), d 
2063 d1				pop de 
2064 e1				pop hl 
2065				if DEBUG_FORTH_STACK_GUARD 
2065 cd 50 71				call check_stacks 
2068				endif 
2068 c9				ret 
2069			 
2069			 
2069			; increase ret stack pointer and save hl to it 
2069				 
2069			FORTH_RSP_NEXT: macro 
2069				call macro_forth_rsp_next 
2069				endm 
2069			 
2069			macro_forth_rsp_next: 
2069				if DEBUG_FORTH_STACK_GUARD 
2069 cd 50 71				call check_stacks 
206c				endif 
206c e5				push hl 
206d d5				push de 
206e eb				ex de,hl 
206f 2a f2 f9			ld hl,(cli_ret_sp) 
2072 23				inc hl 
2073 23				inc hl 
2074 22 f2 f9			ld (cli_ret_sp),hl 
2077 73				ld (hl), e 
2078 23				inc hl 
2079 72				ld (hl), d 
207a d1				pop de 
207b e1				pop hl 
207c				if DEBUG_FORTH_STACK_GUARD 
207c cd 50 71				call check_stacks 
207f				endif 
207f c9				ret 
2080			 
2080			; get current ret stack pointer and save to hl  
2080				 
2080			FORTH_RSP_TOS: macro 
2080				call macro_forth_rsp_tos 
2080				endm 
2080			 
2080			macro_forth_rsp_tos: 
2080				;push de 
2080 2a f2 f9			ld hl,(cli_ret_sp) 
2083 cd bb 20			call loadhlptrtohl 
2086				;ld e, (hl) 
2086				;inc hl 
2086				;ld d, (hl) 
2086				;ex de, hl 
2086					if DEBUG_FORTH_WORDS 
2086			;			DMARK "RST" 
2086						CALLMONITOR 
2086 cd 6f fe			call debug_vector  
2089				endm  
# End of macro CALLMONITOR
2089					endif 
2089				;pop de 
2089 c9				ret 
208a			 
208a			; pop ret stack pointer 
208a				 
208a			FORTH_RSP_POP: macro 
208a				call macro_forth_rsp_pop 
208a				endm 
208a			 
208a			 
208a			macro_forth_rsp_pop: 
208a				if DEBUG_FORTH_STACK_GUARD 
208a			;		DMARK "RPP" 
208a cd 50 71				call check_stacks 
208d					FORTH_CHK_RSP_UNDER 
208d e5				push hl 
208e d5				push de 
208f 2a f2 f9			ld hl,(cli_ret_sp) 
2092 11 ac f9			ld de, cli_ret_stack 
2095 cd a4 0f			call cmp16 
2098 da 64 72			jp c, fault_rsp_under 
209b d1				pop de 
209c e1				pop hl 
209d				endm 
# End of macro FORTH_CHK_RSP_UNDER
209d				endif 
209d e5				push hl 
209e 2a f2 f9			ld hl,(cli_ret_sp) 
20a1			 
20a1			 
20a1				if FORTH_ENABLE_FREE 
20a1			 
20a1					; get pointer 
20a1			 
20a1					push de 
20a1					push hl 
20a1			 
20a1					ld e, (hl) 
20a1					inc hl 
20a1					ld d, (hl) 
20a1			 
20a1					ex de, hl 
20a1					call free 
20a1			 
20a1					pop hl 
20a1					pop de 
20a1			 
20a1			 
20a1				endif 
20a1			 
20a1			 
20a1 2b				dec hl 
20a2 2b				dec hl 
20a3 22 f2 f9			ld (cli_ret_sp), hl 
20a6				; do stack underflow checks 
20a6 e1				pop hl 
20a7				if DEBUG_FORTH_STACK_GUARD 
20a7 cd 50 71				call check_stacks 
20aa					FORTH_CHK_RSP_UNDER 
20aa e5				push hl 
20ab d5				push de 
20ac 2a f2 f9			ld hl,(cli_ret_sp) 
20af 11 ac f9			ld de, cli_ret_stack 
20b2 cd a4 0f			call cmp16 
20b5 da 64 72			jp c, fault_rsp_under 
20b8 d1				pop de 
20b9 e1				pop hl 
20ba				endm 
# End of macro FORTH_CHK_RSP_UNDER
20ba				endif 
20ba c9				ret 
20bb			 
20bb			 
20bb			 
20bb			; routine to load word pointed to by hl into hl 
20bb			 
20bb			loadhlptrtohl: 
20bb			 
20bb d5				push de 
20bc 5e				ld e, (hl) 
20bd 23				inc hl 
20be 56				ld d, (hl) 
20bf eb				ex de, hl 
20c0 d1				pop de 
20c1			 
20c1 c9				ret 
20c2			 
20c2			 
20c2			 
20c2			 
20c2			 
20c2			; push a number held in HL onto the data stack 
20c2			; entry point for pushing a value when already in hl used in function above 
20c2			 
20c2			forth_push_numhl: 
20c2			 
20c2 e5				push hl    ; save value to push 
20c3			 
20c3			if DEBUG_FORTH_PUSH 
20c3				; see if disabled 
20c3			 
20c3			 
20c3 f5				push af 
20c4 3a 6f fe			ld a,(debug_vector) 
20c7 fe c9			cp $c9   ; ret 
20c9			;	ld a, (os_view_disable) 
20c9			;	cp '*' 
20c9 28 34			jr z, .pskip2 
20cb e5				push hl 
20cc e5			push hl 
20cd cd 52 0d			call clear_display 
20d0 e1			pop hl 
20d1 7c				ld a,h 
20d2 21 c6 f4			ld hl, os_word_scratch 
20d5 cd 87 12			call hexout 
20d8 e1				pop hl 
20d9 7d				ld a,l 
20da 21 c8 f4			ld hl, os_word_scratch+2 
20dd cd 87 12			call hexout 
20e0			 
20e0 21 ca f4			ld hl, os_word_scratch+4 
20e3 3e 00			ld a,0 
20e5 77				ld (hl),a 
20e6 11 c6 f4			ld de,os_word_scratch 
20e9 3e 28				ld a, display_row_2 
20eb cd 65 0d				call str_at_display 
20ee 11 37 5d			ld de, .push_num 
20f1 3e 00			ld a, display_row_1 
20f3			 
20f3 cd 65 0d				call str_at_display 
20f6			 
20f6			 
20f6 cd 75 0d			call update_display 
20f9 cd 95 0c			call delay1s 
20fc cd 95 0c			call delay1s 
20ff			.pskip2:  
20ff			 
20ff f1				pop af 
2100			endif	 
2100			 
2100			 
2100				FORTH_DSP_NEXT 
2100 cd 51 20			call macro_forth_dsp_next 
2103				endm 
# End of macro FORTH_DSP_NEXT
2103			 
2103 2a ee f9			ld hl, (cli_data_sp) 
2106			 
2106				; save item type 
2106 3e 02			ld a,  DS_TYPE_INUM 
2108 77				ld (hl), a 
2109 23				inc hl 
210a			 
210a				; get word off stack 
210a d1				pop de 
210b 7b				ld a,e 
210c 77				ld (hl), a 
210d 23				inc hl 
210e 7a				ld a,d 
210f 77				ld (hl), a 
2110			 
2110			if DEBUG_FORTH_PUSH 
2110 2b				dec hl 
2111 2b				dec hl 
2112 2b				dec hl 
2113						DMARK "PH5" 
2113 f5				push af  
2114 3a 28 21			ld a, (.dmark)  
2117 32 6b fe			ld (debug_mark),a  
211a 3a 29 21			ld a, (.dmark+1)  
211d 32 6c fe			ld (debug_mark+1),a  
2120 3a 2a 21			ld a, (.dmark+2)  
2123 32 6d fe			ld (debug_mark+2),a  
2126 18 03			jr .pastdmark  
2128 ..			.dmark: db "PH5"  
212b f1			.pastdmark: pop af  
212c			endm  
# End of macro DMARK
212c				CALLMONITOR 
212c cd 6f fe			call debug_vector  
212f				endm  
# End of macro CALLMONITOR
212f			endif	 
212f			 
212f c9				ret 
2130			 
2130			 
2130			; Push a string to stack pointed to by hl 
2130			 
2130			forth_push_str: 
2130			 
2130			if DEBUG_FORTH_PUSH 
2130						DMARK "PSQ" 
2130 f5				push af  
2131 3a 45 21			ld a, (.dmark)  
2134 32 6b fe			ld (debug_mark),a  
2137 3a 46 21			ld a, (.dmark+1)  
213a 32 6c fe			ld (debug_mark+1),a  
213d 3a 47 21			ld a, (.dmark+2)  
2140 32 6d fe			ld (debug_mark+2),a  
2143 18 03			jr .pastdmark  
2145 ..			.dmark: db "PSQ"  
2148 f1			.pastdmark: pop af  
2149			endm  
# End of macro DMARK
2149				CALLMONITOR 
2149 cd 6f fe			call debug_vector  
214c				endm  
# End of macro CALLMONITOR
214c			endif	 
214c			    
214c e5				push hl 
214d e5				push hl 
214e			 
214e			;	ld a, 0   ; find end of string 
214e cd e4 13			call strlenz 
2151			if DEBUG_FORTH_PUSH 
2151						DMARK "PQ2" 
2151 f5				push af  
2152 3a 66 21			ld a, (.dmark)  
2155 32 6b fe			ld (debug_mark),a  
2158 3a 67 21			ld a, (.dmark+1)  
215b 32 6c fe			ld (debug_mark+1),a  
215e 3a 68 21			ld a, (.dmark+2)  
2161 32 6d fe			ld (debug_mark+2),a  
2164 18 03			jr .pastdmark  
2166 ..			.dmark: db "PQ2"  
2169 f1			.pastdmark: pop af  
216a			endm  
# End of macro DMARK
216a				CALLMONITOR 
216a cd 6f fe			call debug_vector  
216d				endm  
# End of macro CALLMONITOR
216d			endif	 
216d eb				ex de, hl 
216e e1				pop hl   ; get ptr to start of string 
216f			if DEBUG_FORTH_PUSH 
216f						DMARK "PQ3" 
216f f5				push af  
2170 3a 84 21			ld a, (.dmark)  
2173 32 6b fe			ld (debug_mark),a  
2176 3a 85 21			ld a, (.dmark+1)  
2179 32 6c fe			ld (debug_mark+1),a  
217c 3a 86 21			ld a, (.dmark+2)  
217f 32 6d fe			ld (debug_mark+2),a  
2182 18 03			jr .pastdmark  
2184 ..			.dmark: db "PQ3"  
2187 f1			.pastdmark: pop af  
2188			endm  
# End of macro DMARK
2188				CALLMONITOR 
2188 cd 6f fe			call debug_vector  
218b				endm  
# End of macro CALLMONITOR
218b			endif	 
218b 19				add hl,de 
218c			if DEBUG_FORTH_PUSH 
218c						DMARK "PQE" 
218c f5				push af  
218d 3a a1 21			ld a, (.dmark)  
2190 32 6b fe			ld (debug_mark),a  
2193 3a a2 21			ld a, (.dmark+1)  
2196 32 6c fe			ld (debug_mark+1),a  
2199 3a a3 21			ld a, (.dmark+2)  
219c 32 6d fe			ld (debug_mark+2),a  
219f 18 03			jr .pastdmark  
21a1 ..			.dmark: db "PQE"  
21a4 f1			.pastdmark: pop af  
21a5			endm  
# End of macro DMARK
21a5				CALLMONITOR 
21a5 cd 6f fe			call debug_vector  
21a8				endm  
# End of macro CALLMONITOR
21a8			endif	 
21a8			 
21a8 2b				dec hl    ; see if there is an optional trailing double quote 
21a9 7e				ld a,(hl) 
21aa fe 22			cp '"' 
21ac 20 03			jr nz, .strnoq 
21ae 3e 00			ld a, 0      ; get rid of double quote 
21b0 77				ld (hl), a 
21b1 23			.strnoq: inc hl 
21b2			 
21b2 3e 00			ld a, 0 
21b4 77				ld (hl), a     ; add null term and get rid of trailing double quote 
21b5			 
21b5 13				inc de ; add one for the type string 
21b6 13				inc de ; add one for null term??? 
21b7			 
21b7				; tos is get string pointer again 
21b7				; de contains space to allocate 
21b7				 
21b7 d5				push de 
21b8			 
21b8 eb				ex de, hl 
21b9			 
21b9				;push af 
21b9			 
21b9			if DEBUG_FORTH_PUSH 
21b9						DMARK "PHm" 
21b9 f5				push af  
21ba 3a ce 21			ld a, (.dmark)  
21bd 32 6b fe			ld (debug_mark),a  
21c0 3a cf 21			ld a, (.dmark+1)  
21c3 32 6c fe			ld (debug_mark+1),a  
21c6 3a d0 21			ld a, (.dmark+2)  
21c9 32 6d fe			ld (debug_mark+2),a  
21cc 18 03			jr .pastdmark  
21ce ..			.dmark: db "PHm"  
21d1 f1			.pastdmark: pop af  
21d2			endm  
# End of macro DMARK
21d2				CALLMONITOR 
21d2 cd 6f fe			call debug_vector  
21d5				endm  
# End of macro CALLMONITOR
21d5			endif	 
21d5 cd 4d 14			call malloc	; on ret hl now contains allocated memory 
21d8				if DEBUG_FORTH_MALLOC_GUARD 
21d8 cc 8f 5d				call z,malloc_error 
21db				endif 
21db			 
21db				 
21db c1				pop bc    ; get length 
21dc d1				pop de   ;  get string start    
21dd			 
21dd				; hl has destination from malloc 
21dd			 
21dd eb				ex de, hl    ; prep for ldir 
21de			 
21de d5				push de   ; save malloc area for DSP later 
21df				;push hl   ; save malloc area for DSP later 
21df			 
21df			if DEBUG_FORTH_PUSH 
21df						DMARK "PHc" 
21df f5				push af  
21e0 3a f4 21			ld a, (.dmark)  
21e3 32 6b fe			ld (debug_mark),a  
21e6 3a f5 21			ld a, (.dmark+1)  
21e9 32 6c fe			ld (debug_mark+1),a  
21ec 3a f6 21			ld a, (.dmark+2)  
21ef 32 6d fe			ld (debug_mark+2),a  
21f2 18 03			jr .pastdmark  
21f4 ..			.dmark: db "PHc"  
21f7 f1			.pastdmark: pop af  
21f8			endm  
# End of macro DMARK
21f8				CALLMONITOR 
21f8 cd 6f fe			call debug_vector  
21fb				endm  
# End of macro CALLMONITOR
21fb			endif	 
21fb			 
21fb			 
21fb ed b0			ldir 
21fd			 
21fd			 
21fd				; push malloc to data stack     macro?????  
21fd			 
21fd				FORTH_DSP_NEXT 
21fd cd 51 20			call macro_forth_dsp_next 
2200				endm 
# End of macro FORTH_DSP_NEXT
2200			 
2200				; save value and type 
2200			 
2200 2a ee f9			ld hl, (cli_data_sp) 
2203			 
2203				; save item type 
2203 3e 01			ld a,  DS_TYPE_STR 
2205 77				ld (hl), a 
2206 23				inc hl 
2207			 
2207				; get malloc word off stack 
2207 d1				pop de 
2208 73				ld (hl), e 
2209 23				inc hl 
220a 72				ld (hl), d 
220b			 
220b			 
220b			 
220b			if DEBUG_FORTH_PUSH 
220b 2a ee f9			ld hl, (cli_data_sp) 
220e						DMARK "PHS" 
220e f5				push af  
220f 3a 23 22			ld a, (.dmark)  
2212 32 6b fe			ld (debug_mark),a  
2215 3a 24 22			ld a, (.dmark+1)  
2218 32 6c fe			ld (debug_mark+1),a  
221b 3a 25 22			ld a, (.dmark+2)  
221e 32 6d fe			ld (debug_mark+2),a  
2221 18 03			jr .pastdmark  
2223 ..			.dmark: db "PHS"  
2226 f1			.pastdmark: pop af  
2227			endm  
# End of macro DMARK
2227				CALLMONITOR 
2227 cd 6f fe			call debug_vector  
222a				endm  
# End of macro CALLMONITOR
222a			;	ex de,hl 
222a			endif	 
222a				; in case of spaces, skip the ptr past the copied string 
222a				;pop af 
222a				;ld (cli_origptr),hl 
222a			 
222a c9				ret 
222b			 
222b			 
222b			 
222b			; TODO ascii push input onto stack given hl to start of input 
222b			 
222b			; identify type 
222b			; if starts with a " then a string 
222b			; otherwise it is a number 
222b			;  
222b			; if a string 
222b			;     scan for ending " to get length of string to malloc for + 1 
222b			;     malloc 
222b			;     put pointer to string on stack first byte flags as string 
222b			; 
222b			; else a number 
222b			;    look for number format identifier 
222b			;    $xx hex 
222b			;    %xxxxx bin 
222b			;    xxxxx decimal 
222b			;    convert number to 16bit word.  
222b			;    malloc word + 1 with flag to identiy as num 
222b			;    put pointer to number on stack 
222b			;   
222b			;  
222b			  
222b			forth_apush: 
222b				; kernel push 
222b			 
222b			if DEBUG_FORTH_PUSH 
222b						DMARK "PSH" 
222b f5				push af  
222c 3a 40 22			ld a, (.dmark)  
222f 32 6b fe			ld (debug_mark),a  
2232 3a 41 22			ld a, (.dmark+1)  
2235 32 6c fe			ld (debug_mark+1),a  
2238 3a 42 22			ld a, (.dmark+2)  
223b 32 6d fe			ld (debug_mark+2),a  
223e 18 03			jr .pastdmark  
2240 ..			.dmark: db "PSH"  
2243 f1			.pastdmark: pop af  
2244			endm  
# End of macro DMARK
2244				CALLMONITOR 
2244 cd 6f fe			call debug_vector  
2247				endm  
# End of macro CALLMONITOR
2247			endif	 
2247				; identify input type 
2247			 
2247 7e				ld a,(hl) 
2248 fe 22			cp '"' 
224a 28 0a			jr z, .fapstr 
224c fe 24			cp '$' 
224e ca 76 22			jp z, .faphex 
2251 fe 25			cp '%' 
2253 ca 5e 22			jp z, .fapbin 
2256			;	cp 'b' 
2256			;	jp z, .fabin 
2256				; else decimal 
2256			 
2256				; TODO do decimal conversion 
2256				; decimal is stored as a 16bit word 
2256			 
2256				; by default everything is a string if type is not detected 
2256			.fapstr: ; 
2256 fe 22			cp '"' 
2258 20 01			jr nz, .strnoqu 
225a 23				inc hl 
225b			.strnoqu: 
225b c3 30 21			jp forth_push_str 
225e			 
225e			 
225e			 
225e			.fapbin:    ; push a binary string.  
225e 11 00 00			ld de, 0   ; hold a 16bit value 
2261			 
2261 23			.fapbinshift:	inc hl  
2262 7e				ld a,(hl) 
2263 fe 00			cp 0     ; done scanning  
2265 28 0b			jr z, .fapbdone  	; got it in HL so push  
2267			 
2267				; left shift de 
2267 eb				ex de, hl	 
2268 29				add hl, hl 
2269			 
2269				; is 1 
2269 fe 31			cp '1' 
226b 20 02			jr nz, .binzero 
226d cb 4d			bit 1, l 
226f			.binzero: 
226f eb				ex de, hl	 ; save current de 
2270 18 ef			jr .fapbinshift 
2272			 
2272			.fapbdone: 
2272 eb				ex de, hl 
2273 c3 c2 20			jp forth_push_numhl 
2276			 
2276			 
2276			.faphex:   ; hex is always stored as a 16bit word 
2276				; skip number prefix 
2276 23				inc hl 
2277				; turn ascii into number 
2277 cd 3d 13			call get_word_hl	; ret 16bit word in hl 
227a			 
227a c3 c2 20			jp forth_push_numhl 
227d			 
227d 00				 nop 
227e			 
227e			.fabin:   ; TODO bin conversion 
227e			 
227e			 
227e c9				ret 
227f			 
227f			 
227f			; get either a string ptr or a 16bit word from the data stack 
227f			 
227f			FORTH_DSP: macro 
227f				call macro_forth_dsp 
227f				endm 
227f			 
227f			macro_forth_dsp: 
227f				; data stack pointer points to current word on tos 
227f			 
227f 2a ee f9			ld hl,(cli_data_sp) 
2282			 
2282				if DEBUG_FORTH_PUSH 
2282						DMARK "DSP" 
2282 f5				push af  
2283 3a 97 22			ld a, (.dmark)  
2286 32 6b fe			ld (debug_mark),a  
2289 3a 98 22			ld a, (.dmark+1)  
228c 32 6c fe			ld (debug_mark+1),a  
228f 3a 99 22			ld a, (.dmark+2)  
2292 32 6d fe			ld (debug_mark+2),a  
2295 18 03			jr .pastdmark  
2297 ..			.dmark: db "DSP"  
229a f1			.pastdmark: pop af  
229b			endm  
# End of macro DMARK
229b			 
229b cd c2 5d				call display_data_sp 
229e				;call break_point_state 
229e				;rst 030h 
229e				CALLMONITOR 
229e cd 6f fe			call debug_vector  
22a1				endm  
# End of macro CALLMONITOR
22a1				endif 
22a1			 
22a1 c9				ret 
22a2			 
22a2			; return hl to start of value on stack 
22a2			 
22a2			FORTH_DSP_VALUE: macro 
22a2				call macro_forth_dsp_value 
22a2				endm 
22a2			 
22a2			macro_forth_dsp_value: 
22a2			 
22a2				FORTH_DSP 
22a2 cd 7f 22			call macro_forth_dsp 
22a5				endm 
# End of macro FORTH_DSP
22a5			 
22a5 d5				push de 
22a6			 
22a6 23				inc hl ; skip type 
22a7			 
22a7 5e				ld e, (hl) 
22a8 23				inc hl 
22a9 56				ld d, (hl) 
22aa eb				ex de,hl  
22ab			 
22ab d1				pop de 
22ac			 
22ac c9				ret 
22ad			 
22ad			; return hl to start of value to second item on stack 
22ad			 
22ad			FORTH_DSP_VALUEM1: macro 
22ad				call macro_forth_dsp_value_m1 
22ad				endm 
22ad			 
22ad			macro_forth_dsp_value_m1: 
22ad			 
22ad				FORTH_DSP 
22ad cd 7f 22			call macro_forth_dsp 
22b0				endm 
# End of macro FORTH_DSP
22b0			 
22b0 2b				dec hl 
22b1 2b				dec hl 
22b2			;	dec hl 
22b2			 
22b2 d5				push de 
22b3			 
22b3 5e				ld e, (hl) 
22b4 23				inc hl 
22b5 56				ld d, (hl) 
22b6 eb				ex de,hl  
22b7			 
22b7 d1				pop de 
22b8			 
22b8 c9				ret 
22b9			 
22b9				 
22b9			 
22b9			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
22b9			 
22b9			FORTH_DSP_POP: macro 
22b9				call macro_forth_dsp_pop 
22b9				endm 
22b9			 
22b9			 
22b9			; get the tos data type 
22b9			 
22b9			FORTH_DSP_TYPE:   macro 
22b9			 
22b9				;FORTH_DSP_VALUE 
22b9				FORTH_DSP 
22b9				 
22b9				; hl points to value 
22b9				; check type 
22b9			 
22b9				ld a,(hl) 
22b9			 
22b9				endm 
22b9			 
22b9			; load the tos value into hl 
22b9			 
22b9			 
22b9			FORTH_DSP_VALUEHL:  macro 
22b9				call macro_dsp_valuehl 
22b9				endm 
22b9			 
22b9			 
22b9			 
22b9			macro_dsp_valuehl: 
22b9				FORTH_DSP_VALUE 
22b9 cd a2 22			call macro_forth_dsp_value 
22bc				endm 
# End of macro FORTH_DSP_VALUE
22bc			 
22bc				;FORTH_ERR_TOS_NOTNUM 
22bc			 
22bc				;inc hl   ; skip type id 
22bc			 
22bc			;	push de 
22bc			; 
22bc			;	ld e, (hl) 
22bc			;	inc hl 
22bc			;	ld d, (hl) 
22bc			;	ex de,hl  
22bc			 
22bc			;	pop de 
22bc			 
22bc				if DEBUG_FORTH_PUSH 
22bc						DMARK "DVL" 
22bc f5				push af  
22bd 3a d1 22			ld a, (.dmark)  
22c0 32 6b fe			ld (debug_mark),a  
22c3 3a d2 22			ld a, (.dmark+1)  
22c6 32 6c fe			ld (debug_mark+1),a  
22c9 3a d3 22			ld a, (.dmark+2)  
22cc 32 6d fe			ld (debug_mark+2),a  
22cf 18 03			jr .pastdmark  
22d1 ..			.dmark: db "DVL"  
22d4 f1			.pastdmark: pop af  
22d5			endm  
# End of macro DMARK
22d5				CALLMONITOR 
22d5 cd 6f fe			call debug_vector  
22d8				endm  
# End of macro CALLMONITOR
22d8				endif 
22d8 c9				ret 
22d9			 
22d9			forth_apushstrhl:      
22d9				; push of string requires use of cli_origptr 
22d9				; bodge use 
22d9			 
22d9				; get current cli_origptr, save, update with temp pointer  
22d9 ed 5b 3e fa		ld de, (cli_origptr) 
22dd 22 3e fa			ld (cli_origptr), hl 
22e0 d5				push de 
22e1 cd 2b 22			call forth_apush 
22e4 d1				pop de 
22e5 ed 53 3e fa		ld (cli_origptr), de 
22e9 c9			        ret	 
22ea			 
22ea			 
22ea			; increase loop stack pointer and save hl to it 
22ea				 
22ea			FORTH_LOOP_NEXT: macro 
22ea				call macro_forth_loop_next 
22ea				;nop 
22ea				endm 
22ea			 
22ea			macro_forth_loop_next: 
22ea				if DEBUG_FORTH_STACK_GUARD 
22ea cd 50 71				call check_stacks 
22ed				endif 
22ed e5				push hl 
22ee d5				push de 
22ef eb				ex de,hl 
22f0 2a f0 f9			ld hl,(cli_loop_sp) 
22f3 23				inc hl 
22f4 23				inc hl 
22f5					if DEBUG_FORTH_WORDS 
22f5						DMARK "LNX" 
22f5 f5				push af  
22f6 3a 0a 23			ld a, (.dmark)  
22f9 32 6b fe			ld (debug_mark),a  
22fc 3a 0b 23			ld a, (.dmark+1)  
22ff 32 6c fe			ld (debug_mark+1),a  
2302 3a 0c 23			ld a, (.dmark+2)  
2305 32 6d fe			ld (debug_mark+2),a  
2308 18 03			jr .pastdmark  
230a ..			.dmark: db "LNX"  
230d f1			.pastdmark: pop af  
230e			endm  
# End of macro DMARK
230e						CALLMONITOR 
230e cd 6f fe			call debug_vector  
2311				endm  
# End of macro CALLMONITOR
2311					endif 
2311 22 f0 f9			ld (cli_loop_sp),hl 
2314 73				ld (hl), e 
2315 23				inc hl 
2316 72				ld (hl), d 
2317 d1				pop de    ; been reversed so save a swap on restore 
2318 e1				pop hl 
2319				if DEBUG_FORTH_STACK_GUARD 
2319 cd 50 71				call check_stacks 
231c				endif 
231c c9				ret 
231d			 
231d			; get current ret stack pointer and save to hl  
231d				 
231d			FORTH_LOOP_TOS: macro 
231d				call macro_forth_loop_tos 
231d				endm 
231d			 
231d			macro_forth_loop_tos: 
231d d5				push de 
231e 2a f0 f9			ld hl,(cli_loop_sp) 
2321 5e				ld e, (hl) 
2322 23				inc hl 
2323 56				ld d, (hl) 
2324 eb				ex de, hl 
2325 d1				pop de 
2326 c9				ret 
2327			 
2327			; pop loop stack pointer 
2327				 
2327			FORTH_LOOP_POP: macro 
2327				call macro_forth_loop_pop 
2327				endm 
2327			 
2327			 
2327			macro_forth_loop_pop: 
2327				if DEBUG_FORTH_STACK_GUARD 
2327					DMARK "LPP" 
2327 f5				push af  
2328 3a 3c 23			ld a, (.dmark)  
232b 32 6b fe			ld (debug_mark),a  
232e 3a 3d 23			ld a, (.dmark+1)  
2331 32 6c fe			ld (debug_mark+1),a  
2334 3a 3e 23			ld a, (.dmark+2)  
2337 32 6d fe			ld (debug_mark+2),a  
233a 18 03			jr .pastdmark  
233c ..			.dmark: db "LPP"  
233f f1			.pastdmark: pop af  
2340			endm  
# End of macro DMARK
2340 cd 50 71				call check_stacks 
2343					FORTH_CHK_LOOP_UNDER 
2343 e5				push hl 
2344 d5				push de 
2345 2a f0 f9			ld hl,(cli_loop_sp) 
2348 11 2a f9			ld de, cli_loop_stack 
234b cd a4 0f			call cmp16 
234e da 6a 72			jp c, fault_loop_under 
2351 d1				pop de 
2352 e1				pop hl 
2353				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2353				endif 
2353 e5				push hl 
2354 2a f0 f9			ld hl,(cli_loop_sp) 
2357 2b				dec hl 
2358 2b				dec hl 
2359 22 f0 f9			ld (cli_loop_sp), hl 
235c				; TODO do stack underflow checks 
235c e1				pop hl 
235d				if DEBUG_FORTH_STACK_GUARD 
235d cd 50 71				call check_stacks 
2360					FORTH_CHK_LOOP_UNDER 
2360 e5				push hl 
2361 d5				push de 
2362 2a f0 f9			ld hl,(cli_loop_sp) 
2365 11 2a f9			ld de, cli_loop_stack 
2368 cd a4 0f			call cmp16 
236b da 6a 72			jp c, fault_loop_under 
236e d1				pop de 
236f e1				pop hl 
2370				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2370				endif 
2370 c9				ret 
2371			 
2371			macro_forth_dsp_pop: 
2371			 
2371 e5				push hl 
2372			 
2372				; release malloc data 
2372			 
2372				if DEBUG_FORTH_STACK_GUARD 
2372 cd 50 71				call check_stacks 
2375					FORTH_CHK_DSP_UNDER 
2375 e5				push hl 
2376 d5				push de 
2377 2a ee f9			ld hl,(cli_data_sp) 
237a 11 28 f7			ld de, cli_data_stack 
237d cd a4 0f			call cmp16 
2380 da 5e 72			jp c, fault_dsp_under 
2383 d1				pop de 
2384 e1				pop hl 
2385				endm 
# End of macro FORTH_CHK_DSP_UNDER
2385				endif 
2385				;ld hl,(cli_data_sp) 
2385			if DEBUG_FORTH_DOT 
2385				DMARK "DPP" 
2385 f5				push af  
2386 3a 9a 23			ld a, (.dmark)  
2389 32 6b fe			ld (debug_mark),a  
238c 3a 9b 23			ld a, (.dmark+1)  
238f 32 6c fe			ld (debug_mark+1),a  
2392 3a 9c 23			ld a, (.dmark+2)  
2395 32 6d fe			ld (debug_mark+2),a  
2398 18 03			jr .pastdmark  
239a ..			.dmark: db "DPP"  
239d f1			.pastdmark: pop af  
239e			endm  
# End of macro DMARK
239e				CALLMONITOR 
239e cd 6f fe			call debug_vector  
23a1				endm  
# End of macro CALLMONITOR
23a1			endif	 
23a1			 
23a1			 
23a1			if FORTH_ENABLE_DSPPOPFREE 
23a1			 
23a1				FORTH_DSP 
23a1 cd 7f 22			call macro_forth_dsp 
23a4				endm 
# End of macro FORTH_DSP
23a4			 
23a4 7e				ld a, (hl) 
23a5 fe 01			cp DS_TYPE_STR 
23a7 20 23			jr nz, .skippopfree 
23a9			 
23a9				FORTH_DSP_VALUEHL 
23a9 cd b9 22			call macro_dsp_valuehl 
23ac				endm 
# End of macro FORTH_DSP_VALUEHL
23ac 00				nop 
23ad			if DEBUG_FORTH_DOT 
23ad				DMARK "DPf" 
23ad f5				push af  
23ae 3a c2 23			ld a, (.dmark)  
23b1 32 6b fe			ld (debug_mark),a  
23b4 3a c3 23			ld a, (.dmark+1)  
23b7 32 6c fe			ld (debug_mark+1),a  
23ba 3a c4 23			ld a, (.dmark+2)  
23bd 32 6d fe			ld (debug_mark+2),a  
23c0 18 03			jr .pastdmark  
23c2 ..			.dmark: db "DPf"  
23c5 f1			.pastdmark: pop af  
23c6			endm  
# End of macro DMARK
23c6				CALLMONITOR 
23c6 cd 6f fe			call debug_vector  
23c9				endm  
# End of macro CALLMONITOR
23c9			endif	 
23c9 cd 17 15			call free 
23cc			.skippopfree: 
23cc				 
23cc			 
23cc			endif 
23cc			 
23cc			if DEBUG_FORTH_DOT_KEY 
23cc				DMARK "DP2" 
23cc				CALLMONITOR 
23cc			endif	 
23cc			 
23cc				; move pointer down 
23cc			 
23cc 2a ee f9			ld hl,(cli_data_sp) 
23cf 2b				dec hl 
23d0 2b				dec hl 
23d1			; PARSEV5 
23d1 2b				dec hl 
23d2 22 ee f9			ld (cli_data_sp), hl 
23d5			 
23d5				if DEBUG_FORTH_STACK_GUARD 
23d5 cd 50 71				call check_stacks 
23d8					FORTH_CHK_DSP_UNDER 
23d8 e5				push hl 
23d9 d5				push de 
23da 2a ee f9			ld hl,(cli_data_sp) 
23dd 11 28 f7			ld de, cli_data_stack 
23e0 cd a4 0f			call cmp16 
23e3 da 5e 72			jp c, fault_dsp_under 
23e6 d1				pop de 
23e7 e1				pop hl 
23e8				endm 
# End of macro FORTH_CHK_DSP_UNDER
23e8				endif 
23e8			 
23e8 e1				pop hl 
23e9			 
23e9 c9				ret 
23ea			 
23ea			getwordathl: 
23ea				; hl points to an address 
23ea				; load hl with the word at that address 
23ea			 
23ea d5				push de 
23eb			 
23eb 5e				ld e, (hl) 
23ec 23				inc hl 
23ed 56				ld d, (hl) 
23ee eb				ex de, hl 
23ef			 
23ef d1				pop de 
23f0 c9				ret 
23f1			 
23f1			 
23f1			 
23f1			 
23f1			 
23f1			; eof 
23f1			 
# End of file forth_stackopsv5.asm
23f1			endif 
23f1			 
23f1			loadwordinhl:	 
23f1			 
23f1 d5				push de 
23f2			 
23f2 5e				ld e, (hl) 
23f3 23				inc hl 
23f4 56				ld d, (hl) 
23f5 eb				ex de,hl  
23f6			 
23f6 d1				pop de 
23f7			 
23f7 c9				ret 
23f8			 
23f8			user_word_eol:  
23f8				; hl contains the pointer to where to create a linked list item from the end 
23f8				; of the user dict to continue on at the system word dict 
23f8				 
23f8				; poke the stub of the word list linked list to repoint to rom words 
23f8			 
23f8				; stub format 
23f8				; db   word id 
23f8				; dw    link to next word 
23f8			        ; db char length of token 
23f8				; db string + 0 term 
23f8				; db exec code....  
23f8			 
23f8 3e 00			ld a, WORD_SYS_ROOT     ; root word 
23fa 77				ld (hl), a		; word id 
23fb 23				inc hl 
23fc			 
23fc 11 c7 25			ld de, sysdict 
23ff 73				ld (hl), e		; next word link ie system dict 
2400 23				inc hl 
2401 72				ld (hl), d		; next word link ie system dict 
2402 23				inc hl	 
2403			 
2403			;	ld (hl), sysdict		; next word link ie system dict 
2403			;	inc hl 
2403			;	inc hl 
2403			 
2403			;	inc hl 
2403			;	inc hl 
2403			 
2403 3e 02			ld a, 2			; word length is 0 
2405 77				ld (hl), a	 
2406 23				inc hl 
2407			 
2407 3e 7e			ld a, '~'			; word length is 0 
2409 77				ld (hl), a	 
240a 23				inc hl 
240b 3e 00			ld a, 0			; save empty word 
240d 77				ld (hl), a 
240e			 
240e c9				ret 
240f			 
240f				 
240f			 
240f			forthexec_cleanup: 
240f				FORTH_RSP_POP 
240f cd 8a 20			call macro_forth_rsp_pop 
2412				endm 
# End of macro FORTH_RSP_POP
2412 c9				ret 
2413			 
2413			forth_call_hl: 
2413				; taking hl 
2413 e5				push hl 
2414 c9				ret 
2415			 
2415			; this is called to reset Forth system but keep existing uwords etc 
2415			 
2415			forth_warmstart: 
2415				; setup stack over/under flow checks 
2415				if DEBUG_FORTH_STACK_GUARD 
2415 cd 36 71				call chk_stk_init 
2418				endif 
2418			 
2418				; init stack pointers  - * these stacks go upwards *  
2418 21 ac f9			ld hl, cli_ret_stack 
241b 22 f2 f9			ld (cli_ret_sp), hl	 
241e				; set bottom of stack 
241e 3e 00			ld a,0 
2420 77				ld (hl),a 
2421 23				inc hl 
2422 77				ld (hl),a 
2423			 
2423 21 28 f7			ld hl, cli_data_stack 
2426 22 ee f9			ld (cli_data_sp), hl	 
2429				; set bottom of stack 
2429 3e 00			ld a,0 
242b 77				ld (hl),a 
242c 23				inc hl 
242d 77				ld (hl),a 
242e			 
242e 21 2a f9			ld hl, cli_loop_stack 
2431 22 f0 f9			ld (cli_loop_sp), hl	 
2434				; set bottom of stack 
2434 3e 00			ld a,0 
2436 77				ld (hl),a 
2437 23				inc hl 
2438 77				ld (hl),a 
2439			 
2439				; init extent of current open file 
2439			 
2439 3e 00			ld a, 0 
243b 32 6a fa			ld (store_openext), a 
243e			 
243e c9				ret 
243f			 
243f			 
243f			 
243f			; Cold Start - this is called to setup the whole Forth system 
243f			 
243f			forth_init: 
243f			 
243f				; setup stack over/under flow checks 
243f			 
243f			;	if DEBUG_FORTH_STACK_GUARD 
243f			;		call chk_stk_init 
243f			;	endif 
243f			 
243f				; enable auto display updates (slow.....) 
243f			 
243f 3e 01			ld a, 1 
2441 32 3c fa			ld (cli_autodisplay), a 
2444			 
2444				; if storage is in use disable long reads for now 
2444 3e 00			ld a, 0 
2446 32 75 fa			ld (store_longread), a 
2449			 
2449			 
2449				; show start up screen 
2449			 
2449 cd 52 0d			call clear_display 
244c			 
244c 3e 00			ld a,0 
244e 32 5e fa			ld (f_cursor_ptr), a 
2451			 
2451				; set start of word list in start of ram - for use when creating user words 
2451			 
2451 21 00 80			ld hl, baseram 
2454 22 be f4			ld (os_last_new_uword), hl 
2457 cd f8 23			call user_word_eol 
245a				 
245a			;		call display_data_sp 
245a			;		call next_page_prompt 
245a			 
245a			 
245a			 
245a			 
245a c9				ret 
245b			 
245b .. 00		.bootforth: db " Forth Kernel Init ",0 
246f			 
246f			; TODO push to stack 
246f			 
246f			;  
246f			 
246f			if FORTH_PARSEV2 
246f			 
246f			 
246f				include "forth_parserv2.asm" 
246f			 
246f			endif 
246f			 
246f			 
246f			; parse cli version 1 
246f			 
246f			if FORTH_PARSEV1 
246f			 
246f			 
246f			 
246f			      include "forth_parserv1.asm" 
246f			endif 
246f				 
246f			if FORTH_PARSEV3 
246f			 
246f			 
246f			 
246f			      include "forth_parserv3.asm" 
246f				include "forth_wordsv3.asm" 
246f			endif 
246f			 
246f			if FORTH_PARSEV4 
246f			 
246f			 
246f			 
246f			      include "forth_parserv4.asm" 
246f				include "forth_wordsv4.asm" 
246f			endif 
246f			 
246f			if FORTH_PARSEV5 
246f			 
246f			 
246f			 
246f			      include "forth_parserv5.asm" 
246f			 
246f			 
246f			; A better parser without using malloc and string copies all over the place.  
246f			; Exec in situ should be faster 
246f			 
246f			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
246f			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
246f			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
246f			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
246f			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
246f			WORD_SYS_END: equ 0   ; Opcode for all user words 
246f			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
246f			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
246f			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
246f			 
246f			; Core word preamble macro 
246f			 
246f			CWHEAD:   macro nxtword opcode lit len opflags 
246f				db WORD_SYS_CORE+opcode             
246f				; internal op code number 
246f				dw nxtword            
246f				; link to next dict word block 
246f				db len + 1 
246f				; literal length of dict word inc zero term 
246f				db lit,0              
246f				; literal dict word 
246f			        ; TODO db opflags        
246f				endm 
246f			 
246f			 
246f			NEXTW: macro  
246f				jp macro_next 
246f				endm 
246f			 
246f			macro_next: 
246f			if DEBUG_FORTH_PARSE_KEY 
246f				DMARK "NXT" 
246f				CALLMONITOR 
246f			endif	 
246f			;	inc hl  ; skip token null term  
246f ed 4b 40 fa		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2473 ed 5b 3e fa		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2477 2a c2 f4			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
247a			if DEBUG_FORTH_PARSE_KEY 
247a				DMARK "}AA" 
247a				CALLMONITOR 
247a			endif	 
247a c3 7d 25			jp execnext 
247d				;jp exec1 
247d			       
247d			 
247d			 
247d			; Another go at the parser to compile  
247d			 
247d			 
247d			; TODO rework parser to change all of the string words to byte tokens 
247d			; TODO do a search for  
247d			 
247d			; TODO first run normal parser to zero term sections 
247d			; TODO for each word do a token look up to get the op code 
247d			; TODO need some means to flag to the exec that this is a byte code form    
247d			 
247d			 
247d			forthcompile: 
247d			 
247d			; 
247d			; line parse: 
247d			;       parse raw input buffer 
247d			;       tokenise the words 
247d			;       malloc new copy (for looping etc) 
247d			;       copy to malloc + current pc in line to start of string and add line term 
247d			;       save on new rsp 
247d			; 
247d			 
247d			; hl to point to the line to tokenise 
247d			 
247d			;	push hl 
247d 22 c2 f4			ld (os_tok_ptr), hl  ; save ptr to string 
2480			 
2480			;	ld a,0		; string term on input 
2480			;	call strlent 
2480			 
2480			;	ld (os_tok_len), hl	 ; save string length 
2480			 
2480			;if DEBUG_FORTH_TOK 
2480			;	ex de,hl		 
2480			;endif 
2480			 
2480			;	pop hl 		; get back string pointer 
2480			 
2480			if DEBUG_FORTH_TOK 
2480						DMARK "TOc" 
2480				CALLMONITOR 
2480			endif 
2480 7e			.cptoken2:    ld a,(hl) 
2481 23				inc hl 
2482 fe 7f			cp FORTH_END_BUFFER 
2484 28 29			jr z, .cptokendone2 
2486 fe 00			cp 0 
2488 28 25			jr z, .cptokendone2 
248a fe 22			cp '"' 
248c 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
248e fe 20			cp ' ' 
2490 20 ee			jr nz,  .cptoken2 
2492			 
2492			; TODO consume comments held between ( and ) 
2492			 
2492				; we have a space so change to zero term for dict match later 
2492 2b				dec hl 
2493 3e 00			ld a,0 
2495 77				ld (hl), a 
2496 23				inc hl 
2497 18 e7			jr .cptoken2 
2499				 
2499			 
2499			.cptokenstr2: 
2499				; skip all white space until either eol (because forgot to term) or end double quote 
2499			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2499				;inc hl ; skip current double quote 
2499 7e				ld a,(hl) 
249a 23				inc hl 
249b fe 22			cp '"' 
249d 28 e1			jr z, .cptoken2 
249f fe 7f			cp FORTH_END_BUFFER 
24a1 28 0c			jr z, .cptokendone2 
24a3 fe 00			cp 0 
24a5 28 08			jr z, .cptokendone2 
24a7 fe 20			cp ' ' 
24a9 28 02			jr z, .cptmp2 
24ab 18 ec			jr .cptokenstr2 
24ad			 
24ad			.cptmp2:	; we have a space so change to zero term for dict match later 
24ad				;dec hl 
24ad				;ld a,"-"	; TODO remove this when working 
24ad				;ld (hl), a 
24ad				;inc hl 
24ad 18 ea			jr .cptokenstr2 
24af			 
24af			.cptokendone2: 
24af				;inc hl 
24af 3e 7f			ld a, FORTH_END_BUFFER 
24b1 77				ld (hl),a 
24b2 23				inc hl 
24b3 3e 21			ld a, '!' 
24b5 77				ld (hl),a 
24b6			 
24b6 2a c2 f4			ld hl,(os_tok_ptr) 
24b9			         
24b9			if DEBUG_FORTH_TOK 
24b9						DMARK "Tc1" 
24b9				CALLMONITOR 
24b9			endif 
24b9			 
24b9				; push exec string to top of return stack 
24b9				FORTH_RSP_NEXT 
24b9 cd 69 20			call macro_forth_rsp_next 
24bc				endm 
# End of macro FORTH_RSP_NEXT
24bc c9				ret 
24bd			 
24bd			; Another go at the parser need to simplify the process 
24bd			 
24bd			forthparse: 
24bd			 
24bd			; 
24bd			; line parse: 
24bd			;       parse raw input buffer 
24bd			;       tokenise the words 
24bd			;       malloc new copy (for looping etc) 
24bd			;       copy to malloc + current pc in line to start of string and add line term 
24bd			;       save on new rsp 
24bd			; 
24bd			 
24bd			; hl to point to the line to tokenise 
24bd			 
24bd			;	push hl 
24bd 22 c2 f4			ld (os_tok_ptr), hl  ; save ptr to string 
24c0			 
24c0			;	ld a,0		; string term on input 
24c0			;	call strlent 
24c0			 
24c0			;	ld (os_tok_len), hl	 ; save string length 
24c0			 
24c0			;if DEBUG_FORTH_TOK 
24c0			;	ex de,hl		 
24c0			;endif 
24c0			 
24c0			;	pop hl 		; get back string pointer 
24c0			 
24c0			if DEBUG_FORTH_TOK 
24c0						DMARK "TOK" 
24c0				CALLMONITOR 
24c0			endif 
24c0 7e			.ptoken2:    ld a,(hl) 
24c1 23				inc hl 
24c2 fe 7f			cp FORTH_END_BUFFER 
24c4 28 29			jr z, .ptokendone2 
24c6 fe 00			cp 0 
24c8 28 25			jr z, .ptokendone2 
24ca fe 22			cp '"' 
24cc 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
24ce fe 20			cp ' ' 
24d0 20 ee			jr nz,  .ptoken2 
24d2			 
24d2			; TODO consume comments held between ( and ) 
24d2			 
24d2				; we have a space so change to zero term for dict match later 
24d2 2b				dec hl 
24d3 3e 00			ld a,0 
24d5 77				ld (hl), a 
24d6 23				inc hl 
24d7 18 e7			jr .ptoken2 
24d9				 
24d9			 
24d9			.ptokenstr2: 
24d9				; skip all white space until either eol (because forgot to term) or end double quote 
24d9			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
24d9				;inc hl ; skip current double quote 
24d9 7e				ld a,(hl) 
24da 23				inc hl 
24db fe 22			cp '"' 
24dd 28 e1			jr z, .ptoken2 
24df fe 7f			cp FORTH_END_BUFFER 
24e1 28 0c			jr z, .ptokendone2 
24e3 fe 00			cp 0 
24e5 28 08			jr z, .ptokendone2 
24e7 fe 20			cp ' ' 
24e9 28 02			jr z, .ptmp2 
24eb 18 ec			jr .ptokenstr2 
24ed			 
24ed			.ptmp2:	; we have a space so change to zero term for dict match later 
24ed				;dec hl 
24ed				;ld a,"-"	; TODO remove this when working 
24ed				;ld (hl), a 
24ed				;inc hl 
24ed 18 ea			jr .ptokenstr2 
24ef			 
24ef			.ptokendone2: 
24ef				;inc hl 
24ef 3e 7f			ld a, FORTH_END_BUFFER 
24f1 77				ld (hl),a 
24f2 23				inc hl 
24f3 3e 21			ld a, '!' 
24f5 77				ld (hl),a 
24f6			 
24f6 2a c2 f4			ld hl,(os_tok_ptr) 
24f9			         
24f9			if DEBUG_FORTH_TOK 
24f9						DMARK "TK1" 
24f9				CALLMONITOR 
24f9			endif 
24f9			 
24f9				; push exec string to top of return stack 
24f9				FORTH_RSP_NEXT 
24f9 cd 69 20			call macro_forth_rsp_next 
24fc				endm 
# End of macro FORTH_RSP_NEXT
24fc c9				ret 
24fd			 
24fd			; 
24fd			;	; malloc size + buffer pointer + if is loop flag 
24fd			;	ld hl,(os_tok_len) 		 ; get string length 
24fd			; 
24fd			;	ld a,l 
24fd			; 
24fd			;	cp 0			; we dont want to use a null string 
24fd			;	ret z 
24fd			; 
24fd			;;	add 3    ; prefix malloc with buffer for current word ptr 
24fd			; 
24fd			;	add 5     ; TODO when certain not over writing memory remove 
24fd			; 
24fd			;		 
24fd			; 
24fd			;if DEBUG_FORTH_TOK 
24fd			;			DMARK "TKE" 
24fd			;	CALLMONITOR 
24fd			;endif 
24fd			; 
24fd			;	ld l,a 
24fd			;	ld h,0 
24fd			;;	push hl   ; save required space for the copy later 
24fd			;	call malloc 
24fd			;if DEBUG_FORTH_TOK 
24fd			;			DMARK "TKM" 
24fd			;	CALLMONITOR 
24fd			;endif 
24fd			;	if DEBUG_FORTH_MALLOC_GUARD 
24fd			;		push af 
24fd			;		call ishlzero 
24fd			;;		ld a, l 
24fd			;;		add h 
24fd			;;		cp 0 
24fd			;		pop af 
24fd			;		 
24fd			;		call z,malloc_error 
24fd			;	endif 
24fd			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
24fd			; 
24fd			; 
24fd			;if DEBUG_FORTH_TOK 
24fd			;			DMARK "TKR" 
24fd			;	CALLMONITOR 
24fd			;endif 
24fd			; 
24fd			;	FORTH_RSP_NEXT 
24fd			; 
24fd			;	;inc hl	 ; go past current buffer pointer 
24fd			;	;inc hl 
24fd			;	;inc hl   ; and past if loop flag 
24fd			;		; TODO Need to set flag  
24fd			; 
24fd			;	 
24fd			;	 
24fd			;	ex de,hl	; malloc is dest 
24fd			;	ld hl, (os_tok_len) 
24fd			;;	pop bc 
24fd			;	ld c, l                
24fd			;	ld b,0 
24fd			;	ld hl, (os_tok_ptr) 
24fd			; 
24fd			;if DEBUG_FORTH_TOK 
24fd			;			DMARK "TKT" 
24fd			;	CALLMONITOR 
24fd			;endif 
24fd			; 
24fd			;	; do str cpy 
24fd			; 
24fd			;	ldir      ; copy byte in hl to de 
24fd			; 
24fd			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
24fd			; 
24fd			;if DEBUG_FORTH_TOK 
24fd			; 
24fd			;			DMARK "TKY" 
24fd			;	CALLMONITOR 
24fd			;endif 
24fd			;	;ld a,0 
24fd			;	;ld a,FORTH_END_BUFFER 
24fd			;	ex de, hl 
24fd			;	;dec hl			 ; go back over the space delim at the end of word 
24fd			;	;ld (hl),a 
24fd			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
24fd			;	ld a,FORTH_END_BUFFER 
24fd			;	ld (hl),a 
24fd			;	inc hl 
24fd			;	ld a,FORTH_END_BUFFER 
24fd			;	ld (hl),a 
24fd			; 
24fd			;	; init the malloc area data 
24fd			;	; set pc for in current area 
24fd			;	;ld hl, (os_tok_malloc) 
24fd			;	;inc hl 
24fd			;	;inc hl 
24fd			;	;inc hl 
24fd			;	;ex de,hl 
24fd			;	;ld hl, (os_tok_malloc) 
24fd			;	;ld (hl),e 
24fd			;	;inc hl 
24fd			;	;ld (hl),d 
24fd			; 
24fd			; 
24fd			;	ld hl,(os_tok_malloc) 
24fd			;if DEBUG_FORTH_PARSE_KEY 
24fd			;			DMARK "TKU" 
24fd			;	CALLMONITOR 
24fd			;endif 
24fd			; 
24fd			;	ret 
24fd			 
24fd			forthexec: 
24fd			 
24fd			; line exec: 
24fd			; forth parser 
24fd			 
24fd			; 
24fd			;       get current exec line on rsp 
24fd			 
24fd				FORTH_RSP_TOS 
24fd cd 80 20			call macro_forth_rsp_tos 
2500				endm 
# End of macro FORTH_RSP_TOS
2500			 
2500			;       restore current pc - hl points to malloc of data 
2500			 
2500				;ld e, (hl) 
2500				;inc hl 
2500				;ld d, (hl) 
2500				;ex de,hl 
2500			 
2500			 
2500			exec1: 
2500 22 c2 f4			ld (os_tok_ptr), hl 
2503			 
2503				; copy our PC to working vars  
2503 22 40 fa			ld (cli_ptr), hl 
2506 22 3e fa			ld (cli_origptr), hl 
2509			 
2509 7e				ld a,(hl) 
250a fe 7f			cp FORTH_END_BUFFER 
250c c8				ret z 
250d			 
250d				; skip any nulls 
250d			 
250d fe 00			cp 0 
250f 20 03			jr nz, .execword 
2511 23				inc hl 
2512 18 ec			jr exec1 
2514			 
2514			 
2514			.execword: 
2514			 
2514			 
2514			 
2514			if DEBUG_FORTH_PARSE_KEY 
2514						DMARK "KYQ" 
2514				CALLMONITOR 
2514			endif 
2514			;       while at start of word: 
2514			; get start of dict (in user area first) 
2514			 
2514 21 00 80		ld hl, baseram 
2517			;ld hl, sysdict 
2517 22 42 fa		ld (cli_nextword),hl 
251a			;           match word at pc 
251a			;           exec word 
251a			;           or push to dsp 
251a			;           forward to next token 
251a			;           if line term pop rsp and exit 
251a			;        
251a			 
251a			if DEBUG_FORTH_PARSE_KEY 
251a						DMARK "KYq" 
251a				CALLMONITOR 
251a			endif 
251a			 
251a			; 
251a			; word comp 
251a			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
251a			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
251a			;    move to start of word  
251a			;    compare word to cli_token 
251a			 
251a			.execpnword:	; HL at start of a word in the dictionary to check 
251a			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
251a			;	ld (cli_ptr), hl 
251a			 
251a 2a 42 fa			ld hl,(cli_nextword) 
251d			 
251d cd c0 25			call forth_tok_next 
2520			; tok next start here 
2520			;	; TODO skip compiled symbol for now 
2520			;	inc hl 
2520			; 
2520			;	; save pointer to next word 
2520			; 
2520			;	; hl now points to the address of the next word pointer  
2520			;	ld e, (hl) 
2520			;	inc hl 
2520			;	ld d, (hl) 
2520			;	inc l 
2520			; 
2520			;	ex de,hl 
2520			;if DEBUG_FORTH_PARSE_NEXTWORD 
2520			;	push bc 
2520			;	ld bc, (cli_nextword) 
2520			;			DMARK "NXW" 
2520			;	CALLMONITOR 
2520			;	pop bc 
2520			;endif 
2520			; tok next end here 
2520 22 42 fa			ld (cli_nextword), hl     ; save for next check if no match on this word 
2523 eb				ex de, hl 
2524			 
2524			 
2524				; save the pointer of the current token - 1 to check against 
2524				 
2524 22 46 fa			ld (cli_token), hl   
2527				; TODO maybe remove below save if no debug 
2527				; save token string ptr for any debug later 
2527 23				inc hl  
2528 22 48 fa			ld (cli_origtoken), hl 
252b 2b				dec hl 
252c				; save pointer to the start of the next dictionay word 
252c 7e				ld a,(hl)   ; get string length 
252d 47				ld b,a 
252e			.execpnwordinc:  
252e 23				inc hl 
252f 10 fd			djnz .execpnwordinc 
2531 22 44 fa			ld (cli_execword), hl      ; save start of this words code 
2534			 
2534				; now check the word token against the string being parsed 
2534			 
2534 2a 46 fa			ld hl,(cli_token) 
2537 23				inc hl     ; skip string length (use zero term instead to end) 
2538 22 46 fa			ld (cli_token), hl 
253b			 
253b			if DEBUG_FORTH_PARSE_KEY 
253b						DMARK "KY2" 
253b			endif 
253b			if DEBUG_FORTH_PARSE_EXEC 
253b				; see if disabled 
253b			 
253b			;	ld a, (os_view_disable) 
253b			;	cp '*' 
253b				ld a, (debug_vector) 
253b				cp $c9   ; RET  
253b				jr z, .skip 
253b			 
253b				push hl 
253b				push hl 
253b				call clear_display 
253b				ld de, .compword 
253b				ld a, display_row_1 
253b				call str_at_display 
253b				pop de 
253b				ld a, display_row_2 
253b				call str_at_display 
253b				ld hl,(cli_ptr) 
253b				ld a,(hl) 
253b			        ld hl, os_word_scratch 
253b				ld (hl),a 
253b				ld a,0 
253b				inc hl 
253b				ld (hl),a 	 
253b				ld de, os_word_scratch 
253b				ld a, display_row_2+10 
253b				call str_at_display 
253b				call update_display 
253b				ld a, 100 
253b				call aDelayInMS 
253b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
253b				call delay250ms 
253b				endif 
253b				pop hl 
253b			.skip:  
253b			endif	 
253b			.execpnchar:    ; compare char between token and string to parse 
253b			 
253b			if DEBUG_FORTH_PARSE_KEY 
253b						DMARK "Ky3" 
253b			endif 
253b			if DEBUG_FORTH_PARSE_EXEC 
253b				; see if disabled 
253b			 
253b			;	ld a, (os_view_disable) 
253b			;	cp '*' 
253b				ld a, (debug_vector) 
253b				cp $C9  ; RET 
253b				jr z, .skip2 
253b			 
253b			;	call clear_display 
253b			ld hl,(cli_token) 
253b			ld a,(hl) 
253b			ld (os_word_scratch),a 
253b				ld hl,(cli_ptr) 
253b			ld a,(hl) 
253b				ld (os_word_scratch+1),a 
253b				ld a,0 
253b				ld (os_word_scratch+2),a 
253b				ld de,os_word_scratch 
253b				ld a,display_row_4 
253b				call str_at_display 
253b				call update_display 
253b			.skip2:  
253b			endif 
253b 2a 46 fa			ld hl,(cli_token) 
253e 7e				ld a, (hl)	 ; char in word token 
253f 23				inc hl 		; move to next char 
2540 22 46 fa			ld (cli_token), hl ; and save it 
2543 47				ld b,a 
2544			 
2544 2a 40 fa			ld hl,(cli_ptr) ;	get the char from the string to parse 
2547 7e				ld a,(hl) 
2548 23				inc hl 
2549 22 40 fa			ld (cli_ptr), hl		; move to next char 
254c cd db 13			call toUpper 		; make sure the input string matches case 
254f			 
254f			if DEBUG_FORTH_PARSE 
254f			endif 
254f			 
254f				; input stream end of token is a space so get rid of it 
254f			 
254f			;	cp ' ' 
254f			;	jr nz, .pnskipspace 
254f			; 
254f			;	ld a, 0		; make same term as word token term 
254f			; 
254f			;.pnskipspace: 
254f			 
254f			if DEBUG_FORTH_PARSE_KEY 
254f						DMARK "KY7" 
254f			endif 
254f b8				cp b 
2550 c2 66 25			jp nz, .execpnskipword	 ; no match so move to next word 
2553				 
2553			;    if same 
2553			;       scan for string terms 0 for token and 32 for input 
2553			 
2553				 
2553			if DEBUG_FORTH_PARSE_KEY 
2553						DMARK "KY8" 
2553			endif 
2553			 
2553 80				add b			 
2554 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2556							; TODO need to make sure last word in zero term string is accounted for 
2556 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2558			 
2558			 
2558				; at end of both strings so both are exact match 
2558			 
2558			;       skip ptr for next word 
2558			 
2558 2a 40 fa			ld hl,(cli_ptr) 	; at input string term 
255b 23				inc hl			 ; at next char 
255c 22 40 fa			ld (cli_ptr), hl     ; save for next round of the parser 
255f 22 3e fa			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2562				 
2562				 
2562			if DEBUG_FORTH_PARSE_KEY 
2562						DMARK "KY3" 
2562			endif 
2562			 
2562			 
2562			 
2562			;       exec code block 
2562			if DEBUG_FORTH_JP 
2562				call clear_display 
2562				call update_display 
2562				call delay1s 
2562				ld hl, (cli_execword)     ; save for next check if no match on this word 
2562				ld a,h 
2562				ld hl, os_word_scratch 
2562				call hexout 
2562				ld hl, (cli_execword)     ; save for next check if no match on this word 
2562				ld a,l 
2562				ld hl, os_word_scratch+2 
2562				call hexout 
2562				ld hl, os_word_scratch+4 
2562				ld a,0 
2562				ld (hl),a 
2562				ld de,os_word_scratch 
2562				call str_at_display 
2562					ld a, display_row_2 
2562					call str_at_display 
2562				ld de, (cli_origtoken) 
2562				ld a, display_row_1+10 
2562					call str_at_display 
2562			 
2562				ld a,display_row_1 
2562				ld de, .foundword 
2562				ld a, display_row_3 
2562				call str_at_display 
2562				call update_display 
2562				call delay1s 
2562				call delay1s 
2562				call delay1s 
2562			endif 
2562			 
2562			if DEBUG_FORTH_PARSE_KEY 
2562						DMARK "KYj" 
2562			endif 
2562				; TODO save the word pointer in this exec 
2562			 
2562 2a 44 fa			ld hl,(cli_execword) 
2565 e9				jp (hl) 
2566			 
2566			 
2566			;    if not same 
2566			;	scan for zero term 
2566			;	get ptr for next word 
2566			;	goto word comp 
2566			 
2566			.execpnskipword:	; get pointer to next word 
2566 2a 42 fa			ld hl,(cli_nextword) 
2569			 
2569 7e				ld a,(hl) 
256a fe 00			cp WORD_SYS_END 
256c			;	cp 0 
256c 28 09			jr z, .execendofdict			 ; at end of words 
256e			 
256e			if DEBUG_FORTH_PARSE_KEY 
256e						DMARK "KY4" 
256e			endif 
256e			if DEBUG_FORTH_PARSE_EXEC 
256e			 
256e				; see if disabled 
256e			 
256e			;	ld a, (os_view_disable) 
256e			;	cp '*' 
256e				ld a,(debug_vector) 
256e				cp $c9   ; RET 
256e				jr z, .noskip 
256e			 
256e			 
256e				ld de, .nowordfound 
256e				ld a, display_row_3 
256e				call str_at_display 
256e				call update_display 
256e				ld a, 100 
256e				call aDelayInMS 
256e				 
256e				if DEBUG_FORTH_PARSE_EXEC_SLOW 
256e					call delay250ms 
256e				endif 
256e			.noskip:  
256e			 
256e			endif	 
256e			 
256e 2a 3e fa			ld hl,(cli_origptr) 
2571 22 40 fa			ld (cli_ptr),hl 
2574			 
2574			if DEBUG_FORTH_PARSE_KEY 
2574						DMARK "KY5" 
2574			endif 
2574 c3 1a 25			jp .execpnword			; else go to next word 
2577			 
2577			.execendofdict:  
2577			 
2577			if DEBUG_FORTH_PARSE_KEY 
2577						DMARK "KYe" 
2577			endif 
2577			if DEBUG_FORTH_PARSE_EXEC 
2577				; see if disabled 
2577			 
2577			;	ld a, (os_view_disable) 
2577			;	cp '*' 
2577				ld a,(debug_vector) 
2577				cp $c9   ; ret 
2577				jr z, .ispskip 
2577			 
2577				call clear_display 
2577				call update_display 
2577				call delay1s 
2577				ld de, (cli_origptr) 
2577				ld a, display_row_1 
2577				call str_at_display 
2577				 
2577				ld de, .enddict 
2577				ld a, display_row_3 
2577				call str_at_display 
2577				call update_display 
2577				ld a, 100 
2577				call aDelayInMS 
2577				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2577				call delay1s 
2577				call delay1s 
2577				call delay1s 
2577				endif 
2577			.ispskip:  
2577				 
2577			endif	 
2577			 
2577			 
2577			 
2577				; if the word is not a keyword then must be a literal so push it to stack 
2577			 
2577			; push token to stack to end of word 
2577			 
2577				STACKFRAME ON $1efe $2f9f 
2577				if DEBUG_STACK_IMB 
2577					if ON 
2577						exx 
2577						ld de, $1efe 
2577						ld a, d 
2577						ld hl, curframe 
2577						call hexout 
2577						ld a, e 
2577						ld hl, curframe+2 
2577						call hexout 
2577						ld hl, $1efe 
2577						push hl 
2577						ld hl, $2f9f 
2577						push hl 
2577						exx 
2577					endif 
2577				endif 
2577			endm 
# End of macro STACKFRAME
2577			 
2577 2a c2 f4		ld hl,(os_tok_ptr) 
257a cd 2b 22		call forth_apush 
257d			 
257d				STACKFRAMECHK ON $1efe $2f9f 
257d				if DEBUG_STACK_IMB 
257d					if ON 
257d						exx 
257d						ld hl, $2f9f 
257d						pop de   ; $2f9f 
257d						call cmp16 
257d						jr nz, .spnosame 
257d						ld hl, $1efe 
257d						pop de   ; $1efe 
257d						call cmp16 
257d						jr z, .spfrsame 
257d						.spnosame: call showsperror 
257d						.spfrsame: nop 
257d						exx 
257d					endif 
257d				endif 
257d			endm 
# End of macro STACKFRAMECHK
257d			 
257d			execnext: 
257d			 
257d			if DEBUG_FORTH_PARSE_KEY 
257d						DMARK "KY>" 
257d			endif 
257d			; move past token to next word 
257d			 
257d 2a c2 f4		ld hl, (os_tok_ptr) 
2580 3e 00		ld a, 0 
2582 01 ff 00		ld bc, 255     ; input buffer size 
2585 ed b1		cpir 
2587			 
2587			if DEBUG_FORTH_PARSE_KEY 
2587						DMARK "KY!" 
2587				CALLMONITOR 
2587			endif	 
2587			; TODO this might place hl on the null, so will need to forward on??? 
2587			;inc hl   ; see if this gets onto the next item 
2587			 
2587			 
2587			; TODO pass a pointer to the buffer to push 
2587			; TODO call function to push 
2587			 
2587			; look for end of input 
2587			 
2587			;inc hl 
2587			;ld a,(hl) 
2587			;cp FORTH_END_BUFFER 
2587			;ret z 
2587			 
2587			 
2587 c3 00 25		jp exec1 
258a			 
258a			 
258a			 
258a			 
258a			 
258a			 
258a			 
258a			 
258a			 
258a			findnexttok: 
258a			 
258a				; hl is pointer to move 
258a				; de is the token to locate 
258a			 
258a					if DEBUG_FORTH 
258a						DMARK "NTK" 
258a						CALLMONITOR 
258a					endif 
258a d5				push de 
258b			 
258b			.fnt1:	 
258b				; find first char of token to locate 
258b			 
258b 1a				ld a, (de) 
258c 4f				ld c,a 
258d 7e				ld a,(hl) 
258e cd db 13			call toUpper 
2591					if DEBUG_FORTH 
2591						DMARK "NT1" 
2591						CALLMONITOR 
2591					endif 
2591 b9				cp c 
2592			 
2592 28 03			jr z, .fnt2cmpmorefirst	 
2594			 
2594				; first char not found move to next char 
2594			 
2594 23				inc hl 
2595 18 f4			jr .fnt1 
2597			 
2597			.fnt2cmpmorefirst:	 
2597				; first char of token found.  
2597			 
2597 e5				push hl     ; save start of token just in case it is the right one 
2598 d9				exx 
2599 e1				pop hl        ; save it to hl' 
259a d9				exx 
259b			 
259b			 
259b			.fnt2cmpmore:	 
259b				; compare the rest 
259b				 
259b 23				inc hl 
259c 13				inc de 
259d				 
259d 1a				ld a, (de) 
259e 4f				ld c,a 
259f 7e				ld a,(hl) 
25a0 cd db 13			call toUpper 
25a3			 
25a3					if DEBUG_FORTH 
25a3						DMARK "NT2" 
25a3						CALLMONITOR 
25a3					endif 
25a3				; c has the token to find char 
25a3				; a has the mem to scan char 
25a3			 
25a3 b9				cp c 
25a4 28 04			jr z,.fntmatch1 
25a6			 
25a6				; they are not the same 
25a6			 
25a6					if DEBUG_FORTH 
25a6						DMARK "NT3" 
25a6						CALLMONITOR 
25a6					endif 
25a6 d1				pop de	; reset de token to look for 
25a7 d5				push de 
25a8 18 e1			jr .fnt1 
25aa				 
25aa			.fntmatch1: 
25aa			 
25aa				; is the same char a null which means we might have a full hit? 
25aa					if DEBUG_FORTH 
25aa						DMARK "NT4" 
25aa						CALLMONITOR 
25aa					endif 
25aa			 
25aa fe 00			cp 0 
25ac 28 0b			jr z, .fntmatchyes 
25ae			 
25ae				; are we at the end of the token to find? 
25ae			 
25ae					if DEBUG_FORTH 
25ae						DMARK "NT5" 
25ae						CALLMONITOR 
25ae					endif 
25ae 3e 00			ld a, 0 
25b0 b9				cp c 
25b1			 
25b1 c2 9b 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
25b4			 
25b4					if DEBUG_FORTH 
25b4						DMARK "NT6" 
25b4						CALLMONITOR 
25b4					endif 
25b4				; token to find is exhusted but no match to stream 
25b4			 
25b4				; restore tok pointer and continue on 
25b4 d1				pop de 
25b5 d5				push de 
25b6 c3 8b 25			jp .fnt1 
25b9			 
25b9			 
25b9			.fntmatchyes: 
25b9			 
25b9				; hl now contains the end of the found token 
25b9			 
25b9				; get rid of saved token pointer to find 
25b9			 
25b9 d1				pop de 
25ba			 
25ba					if DEBUG_FORTH 
25ba						DMARK "NT9" 
25ba						CALLMONITOR 
25ba					endif 
25ba			 
25ba				; hl will be on the null term so forward on 
25ba			 
25ba				; get back the saved start of the token 
25ba			 
25ba d9				exx 
25bb e5				push hl     ; save start of token just in case it is the right one 
25bc d9				exx 
25bd e1				pop hl        ; save it to hl 
25be			 
25be c9				ret 
25bf			 
25bf			 
25bf			; LIST needs to find a specific token   
25bf			; FORGET needs to find a spefici token 
25bf			 
25bf			; SAVE needs to find all tokens by flag 
25bf			; WORDS just needs to scan through all  by flag 
25bf			; UWORDS needs to scan through all by flag 
25bf			 
25bf			 
25bf			; given hl as pointer to start of dict look up string 
25bf			; return hl as pointer to start of word block 
25bf			; or 0 if not found 
25bf			 
25bf			forth_find_tok: 
25bf c9				ret 
25c0			 
25c0			; given hl as pointer to dict structure 
25c0			; move to the next dict block structure 
25c0			 
25c0			forth_tok_next: 
25c0				; hl now points to the address of the next word pointer  
25c0				; TODO skip compiled symbol for now 
25c0			;	push de 
25c0 23				inc hl 
25c1 5e				ld e, (hl) 
25c2 23				inc hl 
25c3 56				ld d, (hl) 
25c4 23				inc hl 
25c5			 
25c5 eb				ex de,hl 
25c6			if DEBUG_FORTH_PARSE_NEXTWORD 
25c6				push bc 
25c6				ld bc, (cli_nextword) 
25c6						DMARK "NXW" 
25c6				CALLMONITOR 
25c6				pop bc 
25c6			endif 
25c6			;	pop de	 
25c6 c9				ret 
25c7			 
25c7			 
25c7			 
25c7			; eof 
# End of file forth_parserv5.asm
25c7				include "forth_wordsv4.asm" 
25c7			 
25c7			; the core word dictionary v4 
25c7			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
25c7			 
25c7			; this is a linked list for each of the system words used 
25c7			; user defined words will follow the same format but will be in ram 
25c7			 
25c7			 
25c7			; 
25c7			; 
25c7			; define linked list: 
25c7			; 
25c7			; 1. compiled byte op code 
25c7			; 2. len of text word 
25c7			; 3. text word 
25c7			; 4. ptr to next dictionary word 
25c7			; 5. asm, calls etc for the word 
25c7			; 
25c7			;  if 1 == 0 then last word in dict  
25c7			;   
25c7			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
25c7			;  
25c7			;  
25c7			; create basic standard set of words 
25c7			; 
25c7			;  
25c7			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
25c7			; 2DUP 2DROP 2SWAP  
25c7			; @ C@ - get byte  
25c7			; ! C! - store byte 
25c7			; 0< true if less than zero 
25c7			; 0= true if zero 
25c7			; < >  
25c7			; = true if same 
25c7			; variables 
25c7			 
25c7			 
25c7			; Hardware specific words I may need 
25c7			; 
25c7			; IN OUT  
25c7			; calls to key util functions 
25c7			; calls to hardward abstraction stuff 
25c7			; easy control of frame buffers and lcd i/o 
25c7			; keyboard  
25c7			 
25c7			 
25c7			;DICT: macro 
25c7			; op_code, len, word, next 
25c7			;    word: 
25c7			;    db op_code 
25c7			;    ds word zero term 
25c7			;    dw next 
25c7			;    endm 
25c7			 
25c7			 
25c7			 
25c7			 
25c7			; op code 1 is a flag for user define words which are to be handled differently 
25c7			 
25c7			 
25c7			; 
25c7			; 
25c7			;    TODO on entry to a word this should be the expected environment 
25c7			;    hl - tos value if number then held, if string this is the ptr 
25c7			;    de -  
25c7			 
25c7			 
25c7			; opcode ranges 
25c7			; 0 - end of word dict 
25c7			; 255 - user define words 
25c7			 
25c7			sysdict: 
25c7			include "forth_opcodes.asm" 
25c7			; op codes for forth keywords 
25c7			; free to use code 0  
25c7				OPCODE_HEAP: equ  1 
25c7				OPCODE_EXEC: equ 2 
25c7				OPCODE_DUP: equ 3 
25c7				OPCODE_SWAP: equ 4 
25c7				OPCODE_COLN: equ 5 
25c7				OPCODE_SCOLN: equ 6 
25c7				OPCODE_DROP: equ 7 
25c7				OPCODE_DUP2: equ 8 
25c7				OPCODE_DROP2: equ 9 
25c7				OPCODE_SWAP2: equ 10 
25c7				OPCODE_AT: equ 11 
25c7				OPCODE_CAT: equ 12 
25c7				OPCODE_BANG: equ 13 
25c7				OPCODE_CBANG: equ 14 
25c7				OPCODE_SCALL: equ 15 
25c7				OPCODE_DEPTH: equ 16 
25c7				OPCODE_OVER: equ 17 
25c7				OPCODE_PAUSE: equ 18 
25c7				OPCODE_PAUSES: equ 19 
25c7				OPCODE_ROT: equ 20 
25c7			;free to reuse	OPCODE_WORDS: equ 21 
25c7			        OPCODE_NOT: equ 21 
25c7				OPCODE_UWORDS: equ 22 
25c7				OPCODE_BP: equ 23 
25c7				OPCODE_MONITOR: equ 24  
25c7				OPCODE_MALLOC: equ 25 
25c7				OPCODE_FREE: equ 26 
25c7				OPCODE_LIST: equ 27 
25c7				OPCODE_FORGET: equ 28 
25c7				OPCODE_NOP: equ 29 
25c7				OPCODE_COMO: equ 30 
25c7				OPCODE_COMC: equ 31 
25c7			;free to reuse	OPCODE_ENDCORE: equ 32 
25c7				OPCODE_AFTERSOUND: equ 33 
25c7				OPCODE_GP2: equ 34 
25c7				OPCODE_GP3: equ 35 
25c7				OPCODE_GP4: equ 36 
25c7				OPCODE_SIN: equ 37 
25c7				OPCODE_SOUT: equ 38 
25c7				OPCODE_SPIO: equ 39 
25c7				OPCODE_SPICEH: equ 40 
25c7				OPCODE_SPIOb: equ 41 
25c7				OPCODE_SPII: equ 42 
25c7				OPCODE_SESEL: equ 43 
25c7				OPCODE_CARTDEV: equ 44 
25c7			; free to reuse	OPCODE_ENDDEVICE: equ 45 
25c7				OPCODE_FB: equ 46 
25c7				OPCODE_EMIT: equ 47 
25c7				OPCODE_DOTH: equ 48 
25c7				OPCODE_DOTF: equ 49 
25c7				OPCODE_DOT: equ 50 
25c7				OPCODE_CLS: equ 51 
25c7				OPCODE_DRAW: equ 52 
25c7				OPCODE_DUMP: equ 53 
25c7				OPCODE_CDUMP: equ 54 
25c7				OPCODE_DAT: equ 55 
25c7				OPCODE_HOME: equ 56 
25c7				OPCODE_SPACE: equ 57 
25c7				OPCODE_SPACES: equ 58 
25c7				OPCODE_SCROLL: equ 59 
25c7				OPCODE_ATQ: equ 60 
25c7				OPCODE_AUTODSP: equ 61 
25c7				OPCODE_MENU: equ 62 
25c7			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
25c7				OPCODE_THEN: equ 64 
25c7				OPCODE_ELSE: equ 65 
25c7				OPCODE_DO: equ 66 
25c7				OPCODE_LOOP: equ 67 
25c7				OPCODE_I: equ 68 
25c7				OPCODE_DLOOP: equ 69  
25c7				OPCODE_REPEAT: equ 70  
25c7				OPCODE_UNTIL: equ 71 
25c7				OPCODE_ENDFLOW: equ 72 
25c7				OPCODE_WAITK: equ 73 
25c7				OPCODE_ACCEPT: equ 74 
25c7				OPCODE_EDIT: equ 75 
25c7			;free to reuse	OPCODE_ENDKEY: equ 76 
25c7				OPCODE_LZERO: equ 77 
25c7				OPCODE_TZERO: equ 78 
25c7				OPCODE_LESS: equ 79 
25c7				OPCODE_GT: equ 80 
25c7				OPCODE_EQUAL: equ 81  
25c7			;free to reuse	OPCODE_ENDLOGIC: equ 82 
25c7				OPCODE_NEG: equ 83 
25c7				OPCODE_DIV: equ 84 
25c7				OPCODE_MUL: equ 85 
25c7				OPCODE_MIN: equ 86 
25c7				OPCODE_MAX: equ 87 
25c7				OPCODE_RND16: equ 88 
25c7				OPCODE_RND8: equ 89 
25c7				OPCODE_RND: equ 90 
25c7			;free to reuse	OPCODE_ENDMATHS: equ 91  
25c7				OPCODE_BYNAME: equ 92 
25c7				OPCODE_DIR: equ 93 
25c7				OPCODE_SAVE: equ 94 
25c7				OPCODE_LOAD: equ 95 
25c7				OPCODE_BSAVE: equ 96 
25c7				OPCODE_BLOAD: equ 97 
25c7				OPCODE_SEO: equ 98  
25c7				OPCODE_SEI: equ 99 
25c7				OPCODE_SFREE: equ 100 
25c7				OPCODE_SIZE: equ 101 
25c7				OPCODE_CREATE: equ 102 
25c7				OPCODE_APPEND: equ 103 
25c7				OPCODE_SDEL: equ 104 
25c7				OPCODE_OPEN: equ 105 
25c7				OPCODE_READ: equ 106 
25c7				OPCODE_EOF: equ 106 
25c7				OPCODE_FORMAT: equ 107 
25c7				OPCODE_LABEL: equ 108 
25c7				OPCODE_LABELS: equ 109 
25c7			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
25c7				OPCODE_UPPER: equ 111 
25c7				OPCODE_LOWER: equ 112 
25c7				OPCODE_SUBSTR: equ 113 
25c7				OPCODE_LEFT: equ 114 
25c7				OPCODE_RIGHT: equ 115 
25c7				OPCODE_STR2NUM: equ 116 
25c7				OPCODE_NUM2STR: equ 117 
25c7				OPCODE_CONCAT: equ 118 
25c7				OPCODE_FIND: equ 119 
25c7				OPCODE_LEN: equ 120 
25c7				OPCODE_CHAR: equ 121 
25c7			; free to reuse	OPCODE_STRLEN: equ 122 
25c7			; free to reuse	OPCODE_ENDSTR: equ 123 
25c7				OPCODE_V0S: equ 124 
25c7				OPCODE_V0Q: equ 125 
25c7				OPCODE_V1S: equ 126 
25c7				OPCODE_V1Q: equ 127 
25c7				OPCODE_V2S: equ 128 
25c7				OPCODE_V2Q: equ 129 
25c7				OPCODE_V3S: equ 130 
25c7				OPCODE_V3Q: equ 131 
25c7			;free to reuse	OPCODE_END: equ 132 
25c7				OPCODE_ZDUP: equ 133 
25c7			 
25c7			; eof 
# End of file forth_opcodes.asm
25c7			 
25c7			include "forth_words_core.asm" 
25c7			 
25c7			; | ## Core Words 
25c7			 
25c7			;if MALLOC_4 
25c7			 
25c7			.HEAP: 
25c7				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
25c7 15				db WORD_SYS_CORE+OPCODE_HEAP             
25c8 06 26			dw .EXEC            
25ca 05				db 4 + 1 
25cb .. 00			db "HEAP",0              
25d0				endm 
# End of macro CWHEAD
25d0			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
25d0			; | | u1 - Current number of bytes in the heap 
25d0			; | | u2 - Remaining bytes left on the heap 
25d0			; | |  
25d0			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
25d0			 
25d0			 
25d0					if DEBUG_FORTH_WORDS_KEY 
25d0						DMARK "HEP" 
25d0 f5				push af  
25d1 3a e5 25			ld a, (.dmark)  
25d4 32 6b fe			ld (debug_mark),a  
25d7 3a e6 25			ld a, (.dmark+1)  
25da 32 6c fe			ld (debug_mark+1),a  
25dd 3a e7 25			ld a, (.dmark+2)  
25e0 32 6d fe			ld (debug_mark+2),a  
25e3 18 03			jr .pastdmark  
25e5 ..			.dmark: db "HEP"  
25e8 f1			.pastdmark: pop af  
25e9			endm  
# End of macro DMARK
25e9						CALLMONITOR 
25e9 cd 6f fe			call debug_vector  
25ec				endm  
# End of macro CALLMONITOR
25ec					endif 
25ec 2a 0a 80				ld hl, (free_list )      
25ef 11 0e 80				ld de, heap_start 
25f2			 
25f2 ed 52				sbc hl, de  
25f4			 
25f4 cd c2 20				call forth_push_numhl 
25f7			 
25f7			 
25f7 ed 5b 0a 80			ld de, (free_list )      
25fb 21 a8 f1				ld hl, heap_end 
25fe			 
25fe ed 52				sbc hl, de 
2600			 
2600 cd c2 20				call forth_push_numhl 
2603					 
2603			 
2603					 
2603			 
2603			 
2603			 
2603					NEXTW 
2603 c3 6f 24			jp macro_next 
2606				endm 
# End of macro NEXTW
2606			;endif 
2606			 
2606			.EXEC: 
2606			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2606			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2606			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2606			;; > > 
2606			;; > >   
2606			;	STACKFRAME OFF $5efe $5f9f 
2606			; 
2606			;		if DEBUG_FORTH_WORDS_KEY 
2606			;			DMARK "EXE" 
2606			;			CALLMONITOR 
2606			;		endif 
2606			; 
2606			;	FORTH_DSP_VALUEHL 
2606			; 
2606			;	FORTH_DSP_POP 
2606			; 
2606			;		if DEBUG_FORTH_WORDS 
2606			;			DMARK "EX1" 
2606			;			CALLMONITOR 
2606			;		endif 
2606			;;	ld e,(hl) 
2606			;;	inc hl 
2606			;;	ld d,(hl) 
2606			;;	ex de,hl 
2606			; 
2606			;;		if DEBUG_FORTH_WORDS 
2606			;;			DMARK "EX2" 
2606			;;			CALLMONITOR 
2606			;;		endif 
2606			;	push hl 
2606			; 
2606			;	;ld a, 0 
2606			;	;ld a, FORTH_END_BUFFER 
2606			;	call strlenz 
2606			;	inc hl   ; include zero term to copy 
2606			;	inc hl   ; include term 
2606			;	inc hl   ; include term 
2606			;	ld b,0 
2606			;	ld c,l 
2606			;	pop hl 
2606			;	ld de, execscratch 
2606			;		if DEBUG_FORTH_WORDS 
2606			;			DMARK "EX3" 
2606			;			CALLMONITOR 
2606			;		endif 
2606			;	ldir 
2606			; 
2606			; 
2606			;	ld hl, execscratch 
2606			; 
2606			;		if DEBUG_FORTH_WORDS 
2606			;			DMARK "EXe" 
2606			;			CALLMONITOR 
2606			;		endif 
2606			; 
2606			;	call forthparse 
2606			;	call forthexec 
2606			;;	call forthexec_cleanup 
2606			;;	call forthparse 
2606			;;	call forthexec 
2606			; 
2606			;	STACKFRAMECHK OFF $5efe $5f9f 
2606			; 
2606			;	; an immediate word so no need to process any more words 
2606			;	ret 
2606			;	NEXTW 
2606			 
2606			; dead code - old version  
2606			;	FORTH_RSP_NEXT 
2606			 
2606			;  
2606			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2606			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2606			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2606			;	push hl 
2606			;	push de 
2606			;	push bc 
2606			; 
2606			; 
2606			;		if DEBUG_FORTH_WORDS_KEY 
2606			;			DMARK "EXR" 
2606			;			CALLMONITOR 
2606			;		endif 
2606			; 
2606			; 
2606			; 
2606			;	;v5 FORTH_DSP_VALUE 
2606			;	FORTH_DSP_VALUEHL 
2606			; 
2606			;	; TODO do string type checks 
2606			; 
2606			;;v5	inc hl   ; skip type 
2606			; 
2606			;	push hl  ; source code  
2606			;		if DEBUG_FORTH_WORDS 
2606			;			DMARK "EX1" 
2606			;			CALLMONITOR 
2606			;		endif 
2606			;	ld a, 0 
2606			;	call strlent 
2606			; 
2606			;	inc hl 
2606			;	inc hl 
2606			;	inc hl 
2606			;	inc hl 
2606			; 
2606			;	push hl    ; size 
2606			; 
2606			;		if DEBUG_FORTH_WORDS 
2606			;			DMARK "EX2" 
2606			;			CALLMONITOR 
2606			;		endif 
2606			;	call malloc 
2606			; 
2606			;	ex de, hl    ; de now contains malloc area 
2606			;	pop bc   	; get byte count 
2606			;	pop hl      ; get string to copy 
2606			; 
2606			;	push de     ; save malloc for free later 
2606			; 
2606			;		if DEBUG_FORTH_WORDS 
2606			;			DMARK "EX3" 
2606			;			CALLMONITOR 
2606			;		endif 
2606			;	ldir       ; duplicate string 
2606			; 
2606			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2606			;	 
2606			;	; TODO fix the parse would be better than this...  
2606			;	ex de, hl 
2606			;	dec hl 
2606			;	ld a, 0 
2606			;	ld (hl), a 
2606			;	dec hl 
2606			;	ld a, ' ' 
2606			;	ld (hl), a 
2606			;	dec hl 
2606			;	ld (hl), a 
2606			; 
2606			;	dec hl 
2606			;	ld (hl), a 
2606			; 
2606			; 
2606			;	FORTH_DSP_POP  
2606			; 
2606			;	pop hl     
2606			;	push hl    ; save malloc area 
2606			; 
2606			;		if DEBUG_FORTH_WORDS 
2606			;			DMARK "EX4" 
2606			;			CALLMONITOR 
2606			;		endif 
2606			; 
2606			;	call forthparse 
2606			;	call forthexec 
2606			;	 
2606			;	pop hl 
2606			;	if DEBUG_FORTH_WORDS 
2606			;		DMARK "EX5" 
2606			;		CALLMONITOR 
2606			;	endif 
2606			; 
2606			;	if FORTH_ENABLE_FREE 
2606			;	call free 
2606			;	endif 
2606			; 
2606			;	if DEBUG_FORTH_WORDS 
2606			;		DMARK "EX6" 
2606			;		CALLMONITOR 
2606			;	endif 
2606			; 
2606			;	pop bc 
2606			;	pop de 
2606			;	pop hl 
2606			;;	FORTH_RSP_POP	  
2606			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2606			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2606			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2606			; 
2606			;	if DEBUG_FORTH_WORDS 
2606			;		DMARK "EX7" 
2606			;		CALLMONITOR 
2606			;	endif 
2606			;	NEXTW 
2606			 
2606			;.STKEXEC: 
2606			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2606			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2606			; 
2606			; 
2606			;		if DEBUG_FORTH_WORDS_KEY 
2606			;			DMARK "STX" 
2606			;			CALLMONITOR 
2606			;		endif 
2606			; 
2606			;	FORTH_DSP_VALUEHL 
2606			; 
2606			;	ld (store_tmp1), hl    ; count 
2606			; 
2606			;	FORTH_DSP_POP 
2606			;.stkexec1: 
2606			;	ld hl, (store_tmp1)   ; count 
2606			;	ld a, 0 
2606			;	cp l 
2606			;	ret z 
2606			; 
2606			;	dec hl 
2606			;	ld (store_tmp1), hl    ; count 
2606			;	 
2606			;	FORTH_DSP_VALUEHL 
2606			;	push hl 
2606			;	 
2606			;		if DEBUG_FORTH_WORDS 
2606			;			DMARK "EXp" 
2606			;			CALLMONITOR 
2606			;		endif 
2606			;	FORTH_DSP_POP 
2606			; 
2606			;	call strlenz 
2606			;	inc hl   ; include zero term to copy 
2606			;	inc hl   ; include zero term to copy 
2606			;	inc hl   ; include zero term to copy 
2606			;	ld b,0 
2606			;	ld c,l 
2606			;	pop hl 
2606			;	ld de, execscratch 
2606			;		if DEBUG_FORTH_WORDS 
2606			;			DMARK "EX3" 
2606			;			CALLMONITOR 
2606			;		endif 
2606			;	ldir 
2606			; 
2606			; 
2606			;	ld hl, execscratch 
2606			; 
2606			;		if DEBUG_FORTH_WORDS 
2606			;			DMARK "EXP" 
2606			;			CALLMONITOR 
2606			;		endif 
2606			; 
2606			;	call forthparse 
2606			;	ld hl, execscratch 
2606			;		if DEBUG_FORTH_WORDS 
2606			;			DMARK "EXx" 
2606			;			CALLMONITOR 
2606			;		endif 
2606			;	call forthexec 
2606			; 
2606			;	jp .stkexec1 
2606			; 
2606			;	ret 
2606			 
2606			 
2606			.DUP: 
2606				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2606 17				db WORD_SYS_CORE+OPCODE_DUP             
2607 7c 26			dw .ZDUP            
2609 04				db 3 + 1 
260a .. 00			db "DUP",0              
260e				endm 
# End of macro CWHEAD
260e			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
260e			 
260e					if DEBUG_FORTH_WORDS_KEY 
260e						DMARK "DUP" 
260e f5				push af  
260f 3a 23 26			ld a, (.dmark)  
2612 32 6b fe			ld (debug_mark),a  
2615 3a 24 26			ld a, (.dmark+1)  
2618 32 6c fe			ld (debug_mark+1),a  
261b 3a 25 26			ld a, (.dmark+2)  
261e 32 6d fe			ld (debug_mark+2),a  
2621 18 03			jr .pastdmark  
2623 ..			.dmark: db "DUP"  
2626 f1			.pastdmark: pop af  
2627			endm  
# End of macro DMARK
2627						CALLMONITOR 
2627 cd 6f fe			call debug_vector  
262a				endm  
# End of macro CALLMONITOR
262a					endif 
262a			 
262a					FORTH_DSP 
262a cd 7f 22			call macro_forth_dsp 
262d				endm 
# End of macro FORTH_DSP
262d			 
262d 7e					ld a, (HL) 
262e fe 01				cp DS_TYPE_STR 
2630 20 25				jr nz, .dupinum 
2632			 
2632					; push another string 
2632			 
2632					FORTH_DSP_VALUEHL     		 
2632 cd b9 22			call macro_dsp_valuehl 
2635				endm 
# End of macro FORTH_DSP_VALUEHL
2635			 
2635				if DEBUG_FORTH_WORDS 
2635					DMARK "DUs" 
2635 f5				push af  
2636 3a 4a 26			ld a, (.dmark)  
2639 32 6b fe			ld (debug_mark),a  
263c 3a 4b 26			ld a, (.dmark+1)  
263f 32 6c fe			ld (debug_mark+1),a  
2642 3a 4c 26			ld a, (.dmark+2)  
2645 32 6d fe			ld (debug_mark+2),a  
2648 18 03			jr .pastdmark  
264a ..			.dmark: db "DUs"  
264d f1			.pastdmark: pop af  
264e			endm  
# End of macro DMARK
264e					CALLMONITOR 
264e cd 6f fe			call debug_vector  
2651				endm  
# End of macro CALLMONITOR
2651				endif 
2651 cd 30 21				call forth_push_str 
2654			 
2654					NEXTW 
2654 c3 6f 24			jp macro_next 
2657				endm 
# End of macro NEXTW
2657			 
2657			 
2657			.dupinum: 
2657					 
2657			 
2657			 
2657					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2657 cd b9 22			call macro_dsp_valuehl 
265a				endm 
# End of macro FORTH_DSP_VALUEHL
265a			 
265a				; TODO add floating point number detection 
265a			 
265a				if DEBUG_FORTH_WORDS 
265a					DMARK "DUi" 
265a f5				push af  
265b 3a 6f 26			ld a, (.dmark)  
265e 32 6b fe			ld (debug_mark),a  
2661 3a 70 26			ld a, (.dmark+1)  
2664 32 6c fe			ld (debug_mark+1),a  
2667 3a 71 26			ld a, (.dmark+2)  
266a 32 6d fe			ld (debug_mark+2),a  
266d 18 03			jr .pastdmark  
266f ..			.dmark: db "DUi"  
2672 f1			.pastdmark: pop af  
2673			endm  
# End of macro DMARK
2673					CALLMONITOR 
2673 cd 6f fe			call debug_vector  
2676				endm  
# End of macro CALLMONITOR
2676				endif 
2676			 
2676 cd c2 20				call forth_push_numhl 
2679					NEXTW 
2679 c3 6f 24			jp macro_next 
267c				endm 
# End of macro NEXTW
267c			.ZDUP: 
267c				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
267c 99				db WORD_SYS_CORE+OPCODE_ZDUP             
267d b4 26			dw .SWAP            
267f 05				db 4 + 1 
2680 .. 00			db "?DUP",0              
2685				endm 
# End of macro CWHEAD
2685			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2685			 
2685					if DEBUG_FORTH_WORDS_KEY 
2685						DMARK "qDU" 
2685 f5				push af  
2686 3a 9a 26			ld a, (.dmark)  
2689 32 6b fe			ld (debug_mark),a  
268c 3a 9b 26			ld a, (.dmark+1)  
268f 32 6c fe			ld (debug_mark+1),a  
2692 3a 9c 26			ld a, (.dmark+2)  
2695 32 6d fe			ld (debug_mark+2),a  
2698 18 03			jr .pastdmark  
269a ..			.dmark: db "qDU"  
269d f1			.pastdmark: pop af  
269e			endm  
# End of macro DMARK
269e						CALLMONITOR 
269e cd 6f fe			call debug_vector  
26a1				endm  
# End of macro CALLMONITOR
26a1					endif 
26a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26a1 cd b9 22			call macro_dsp_valuehl 
26a4				endm 
# End of macro FORTH_DSP_VALUEHL
26a4			 
26a4 e5					push hl 
26a5			 
26a5					; is it a zero? 
26a5			 
26a5 3e 00				ld a, 0 
26a7 84					add h 
26a8 85					add l 
26a9			 
26a9 e1					pop hl 
26aa			 
26aa fe 00				cp 0 
26ac 28 03				jr z, .dup2orig 
26ae			 
26ae			 
26ae cd c2 20				call forth_push_numhl 
26b1			 
26b1			 
26b1				; TODO add floating point number detection 
26b1			 
26b1			.dup2orig: 
26b1			 
26b1					NEXTW 
26b1 c3 6f 24			jp macro_next 
26b4				endm 
# End of macro NEXTW
26b4			.SWAP: 
26b4				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
26b4 18				db WORD_SYS_CORE+OPCODE_SWAP             
26b5 f3 26			dw .COLN            
26b7 05				db 4 + 1 
26b8 .. 00			db "SWAP",0              
26bd				endm 
# End of macro CWHEAD
26bd			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
26bd					if DEBUG_FORTH_WORDS_KEY 
26bd						DMARK "SWP" 
26bd f5				push af  
26be 3a d2 26			ld a, (.dmark)  
26c1 32 6b fe			ld (debug_mark),a  
26c4 3a d3 26			ld a, (.dmark+1)  
26c7 32 6c fe			ld (debug_mark+1),a  
26ca 3a d4 26			ld a, (.dmark+2)  
26cd 32 6d fe			ld (debug_mark+2),a  
26d0 18 03			jr .pastdmark  
26d2 ..			.dmark: db "SWP"  
26d5 f1			.pastdmark: pop af  
26d6			endm  
# End of macro DMARK
26d6						CALLMONITOR 
26d6 cd 6f fe			call debug_vector  
26d9				endm  
# End of macro CALLMONITOR
26d9					endif 
26d9			 
26d9					FORTH_DSP_VALUEHL 
26d9 cd b9 22			call macro_dsp_valuehl 
26dc				endm 
# End of macro FORTH_DSP_VALUEHL
26dc e5					push hl     ; w2 
26dd			 
26dd					FORTH_DSP_POP 
26dd cd 71 23			call macro_forth_dsp_pop 
26e0				endm 
# End of macro FORTH_DSP_POP
26e0			 
26e0					FORTH_DSP_VALUEHL 
26e0 cd b9 22			call macro_dsp_valuehl 
26e3				endm 
# End of macro FORTH_DSP_VALUEHL
26e3			 
26e3					FORTH_DSP_POP 
26e3 cd 71 23			call macro_forth_dsp_pop 
26e6				endm 
# End of macro FORTH_DSP_POP
26e6			 
26e6 d1					pop de     ; w2	, hl = w1 
26e7			 
26e7 eb					ex de, hl 
26e8 d5					push de 
26e9			 
26e9 cd c2 20				call forth_push_numhl 
26ec			 
26ec e1					pop hl 
26ed			 
26ed cd c2 20				call forth_push_numhl 
26f0					 
26f0			 
26f0					NEXTW 
26f0 c3 6f 24			jp macro_next 
26f3				endm 
# End of macro NEXTW
26f3			.COLN: 
26f3				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
26f3 19				db WORD_SYS_CORE+OPCODE_COLN             
26f4 7f 28			dw .SCOLN            
26f6 02				db 1 + 1 
26f7 .. 00			db ":",0              
26f9				endm 
# End of macro CWHEAD
26f9			; | : ( -- )         Create new word | DONE 
26f9			 
26f9					if DEBUG_FORTH_WORDS_KEY 
26f9						DMARK "CLN" 
26f9 f5				push af  
26fa 3a 0e 27			ld a, (.dmark)  
26fd 32 6b fe			ld (debug_mark),a  
2700 3a 0f 27			ld a, (.dmark+1)  
2703 32 6c fe			ld (debug_mark+1),a  
2706 3a 10 27			ld a, (.dmark+2)  
2709 32 6d fe			ld (debug_mark+2),a  
270c 18 03			jr .pastdmark  
270e ..			.dmark: db "CLN"  
2711 f1			.pastdmark: pop af  
2712			endm  
# End of macro DMARK
2712						CALLMONITOR 
2712 cd 6f fe			call debug_vector  
2715				endm  
# End of macro CALLMONITOR
2715					endif 
2715				STACKFRAME OFF $8efe $989f 
2715				if DEBUG_STACK_IMB 
2715					if OFF 
2715						exx 
2715						ld de, $8efe 
2715						ld a, d 
2715						ld hl, curframe 
2715						call hexout 
2715						ld a, e 
2715						ld hl, curframe+2 
2715						call hexout 
2715						ld hl, $8efe 
2715						push hl 
2715						ld hl, $989f 
2715						push hl 
2715						exx 
2715					endif 
2715				endif 
2715			endm 
# End of macro STACKFRAME
2715				; get parser buffer length  of new word 
2715			 
2715				 
2715			 
2715					; move tok past this to start of name defintition 
2715					; TODO get word to define 
2715					; TODO Move past word token 
2715					; TODO get length of string up to the ';' 
2715			 
2715 2a c2 f4			ld hl, (os_tok_ptr) 
2718 23				inc hl 
2719 23				inc hl 
271a			 
271a 3e 3b			ld a, ';' 
271c cd ef 13			call strlent 
271f			 
271f 7d				ld a,l 
2720 32 bd f1			ld (os_new_parse_len), a 
2723			 
2723			 
2723			if DEBUG_FORTH_UWORD 
2723 ed 5b c2 f4		ld de, (os_tok_ptr) 
2727						DMARK ":01" 
2727 f5				push af  
2728 3a 3c 27			ld a, (.dmark)  
272b 32 6b fe			ld (debug_mark),a  
272e 3a 3d 27			ld a, (.dmark+1)  
2731 32 6c fe			ld (debug_mark+1),a  
2734 3a 3e 27			ld a, (.dmark+2)  
2737 32 6d fe			ld (debug_mark+2),a  
273a 18 03			jr .pastdmark  
273c ..			.dmark: db ":01"  
273f f1			.pastdmark: pop af  
2740			endm  
# End of macro DMARK
2740				CALLMONITOR 
2740 cd 6f fe			call debug_vector  
2743				endm  
# End of macro CALLMONITOR
2743			endif 
2743			 
2743			; 
2743			;  new word memory layout: 
2743			;  
2743			;    : adg 6666 ;  
2743			; 
2743			;    db   1     ; user defined word  
2743 23				inc hl    
2744			;    dw   sysdict 
2744 23				inc hl 
2745 23				inc hl 
2746			;    db <word len>+1 (for null) 
2746 23				inc hl 
2747			;    db .... <word> 
2747			; 
2747			 
2747 23				inc hl    ; some extras for the word preamble before the above 
2748 23				inc hl 
2749 23				inc hl 
274a 23				inc hl 
274b 23				inc hl 
274c 23				inc hl 
274d 23				inc hl  
274e 23				inc hl 
274f 23				inc hl 
2750 23				inc hl 
2751 23				inc hl 
2752 23				inc hl 
2753 23				inc hl 
2754 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2755			;       exec word buffer 
2755			;	<ptr word>   
2755 23				inc hl 
2756 23				inc hl 
2757			;       <word list><null term> 7F final term 
2757			 
2757			 
2757			if DEBUG_FORTH_UWORD 
2757						DMARK ":02" 
2757 f5				push af  
2758 3a 6c 27			ld a, (.dmark)  
275b 32 6b fe			ld (debug_mark),a  
275e 3a 6d 27			ld a, (.dmark+1)  
2761 32 6c fe			ld (debug_mark+1),a  
2764 3a 6e 27			ld a, (.dmark+2)  
2767 32 6d fe			ld (debug_mark+2),a  
276a 18 03			jr .pastdmark  
276c ..			.dmark: db ":02"  
276f f1			.pastdmark: pop af  
2770			endm  
# End of macro DMARK
2770				CALLMONITOR 
2770 cd 6f fe			call debug_vector  
2773				endm  
# End of macro CALLMONITOR
2773			endif 
2773			 
2773				 
2773					; malloc the size 
2773			 
2773 cd 4d 14				call malloc 
2776 22 bf f1				ld (os_new_malloc), hl     ; save malloc start 
2779			 
2779			;    db   1     ; user defined word  
2779 3e 01				ld a, WORD_SYS_UWORD  
277b 77					ld (hl), a 
277c				 
277c 23				inc hl    
277d			;    dw   sysdict 
277d 11 c7 25			ld de, sysdict       ; continue on with the scan to the system dict 
2780 73				ld (hl), e 
2781 23				inc hl 
2782 72				ld (hl), d 
2783 23				inc hl 
2784			 
2784			 
2784			;    Setup dict word 
2784			 
2784 23				inc hl 
2785 22 b9 f1			ld (os_new_work_ptr), hl     ; save start of dict word  
2788			 
2788				; 1. get length of dict word 
2788			 
2788			 
2788 2a c2 f4			ld hl, (os_tok_ptr) 
278b 23				inc hl 
278c 23				inc hl    ; position to start of dict word 
278d 3e 00			ld a, 0 
278f cd ef 13			call strlent 
2792			 
2792			 
2792 23				inc hl    ; to include null??? 
2793			 
2793				; write length of dict word 
2793			 
2793 ed 5b b9 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2797 1b				dec de 
2798 eb				ex de, hl 
2799 73				ld (hl), e 
279a eb				ex de, hl 
279b			 
279b				 
279b			 
279b				; copy  
279b 4d				ld c, l 
279c 06 00			ld b, 0 
279e ed 5b b9 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
27a2 2a c2 f4			ld hl, (os_tok_ptr) 
27a5 23				inc hl 
27a6 23				inc hl    ; position to start of dict word 
27a7				 
27a7			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
27a7				 
27a7				; TODO need to convert word to upper case 
27a7			 
27a7			ucasetok:	 
27a7 7e				ld a,(hl) 
27a8 cd db 13			call toUpper 
27ab 77				ld (hl),a 
27ac ed a0			ldi 
27ae f2 a7 27		 	jp p, ucasetok 
27b1			 
27b1			 
27b1			 
27b1				; de now points to start of where the word body code should be placed 
27b1 ed 53 b9 f1		ld (os_new_work_ptr), de 
27b5				; hl now points to the words to throw at forthexec which needs to be copied 
27b5 22 b7 f1			ld (os_new_src_ptr), hl 
27b8			 
27b8				; TODO add 'call to forthexec' 
27b8			 
27b8			if DEBUG_FORTH_UWORD 
27b8 c5				push bc 
27b9 ed 4b bf f1		ld bc, (os_new_malloc) 
27bd						DMARK ":0x" 
27bd f5				push af  
27be 3a d2 27			ld a, (.dmark)  
27c1 32 6b fe			ld (debug_mark),a  
27c4 3a d3 27			ld a, (.dmark+1)  
27c7 32 6c fe			ld (debug_mark+1),a  
27ca 3a d4 27			ld a, (.dmark+2)  
27cd 32 6d fe			ld (debug_mark+2),a  
27d0 18 03			jr .pastdmark  
27d2 ..			.dmark: db ":0x"  
27d5 f1			.pastdmark: pop af  
27d6			endm  
# End of macro DMARK
27d6				CALLMONITOR 
27d6 cd 6f fe			call debug_vector  
27d9				endm  
# End of macro CALLMONITOR
27d9 c1				pop bc 
27da			endif 
27da			 
27da			 
27da				; create word preamble which should be: 
27da			 
27da			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
27da			 
27da				;    ld hl, <word code> 
27da				;    jp user_exec 
27da			        ;    <word code bytes> 
27da			 
27da			 
27da			;	inc de     ; TODO ??? or are we already past the word's null 
27da eb				ex de, hl 
27db			 
27db 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
27dd			 
27dd 23				inc hl 
27de 22 b3 f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
27e1 23				inc hl 
27e2			 
27e2 23				inc hl 
27e3 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
27e5			 
27e5 01 bd 5c			ld bc, user_exec 
27e8 23				inc hl 
27e9 71				ld (hl), c     ; poke address of user_exec 
27ea 23				inc hl 
27eb 70				ld (hl), b     
27ec			 ; 
27ec			;	inc hl 
27ec			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
27ec			; 
27ec			; 
27ec			;	ld bc, macro_forth_rsp_next 
27ec			;	inc hl 
27ec			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
27ec			;	inc hl 
27ec			;	ld (hl), b     
27ec			 ; 
27ec			;	inc hl 
27ec			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
27ec			; 
27ec			; 
27ec			;	inc hl 
27ec			;	ld bc, forthexec 
27ec			;	ld (hl), c     ; poke address of forthexec 
27ec			;	inc hl 
27ec			;	ld (hl), b      
27ec			; 
27ec			;	inc hl 
27ec			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
27ec			; 
27ec			;	ld bc, user_dict_next 
27ec			;	inc hl 
27ec			;	ld (hl), c     ; poke address of forthexec 
27ec			;	inc hl 
27ec			;	ld (hl), b      
27ec			 
27ec				; hl is now where we need to copy the word byte data to save this 
27ec			 
27ec 23				inc hl 
27ed 22 b5 f1			ld (os_new_exec), hl 
27f0				 
27f0				; copy definition 
27f0			 
27f0 eb				ex de, hl 
27f1			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
27f1			;	inc de    ; skip the PC for this parse 
27f1 3a bd f1			ld a, (os_new_parse_len) 
27f4 4f				ld c, a 
27f5 06 00			ld b, 0 
27f7 ed b0			ldir		 ; copy defintion 
27f9			 
27f9			 
27f9				; poke the address of where the new word bytes live for forthexec 
27f9			 
27f9 2a b3 f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
27fc			 
27fc ed 5b b5 f1		ld de, (os_new_exec)      
2800				 
2800 73				ld (hl), e 
2801 23				inc hl 
2802 72				ld (hl), d 
2803			 
2803					; TODO copy last user dict word next link to this word 
2803					; TODO update last user dict word to point to this word 
2803			; 
2803			; hl f923 de 812a ; bc 811a 
2803			 
2803			if DEBUG_FORTH_UWORD 
2803 c5				push bc 
2804 ed 4b bf f1		ld bc, (os_new_malloc) 
2808						DMARK ":0A" 
2808 f5				push af  
2809 3a 1d 28			ld a, (.dmark)  
280c 32 6b fe			ld (debug_mark),a  
280f 3a 1e 28			ld a, (.dmark+1)  
2812 32 6c fe			ld (debug_mark+1),a  
2815 3a 1f 28			ld a, (.dmark+2)  
2818 32 6d fe			ld (debug_mark+2),a  
281b 18 03			jr .pastdmark  
281d ..			.dmark: db ":0A"  
2820 f1			.pastdmark: pop af  
2821			endm  
# End of macro DMARK
2821				CALLMONITOR 
2821 cd 6f fe			call debug_vector  
2824				endm  
# End of macro CALLMONITOR
2824 c1				pop bc 
2825			endif 
2825			if DEBUG_FORTH_UWORD 
2825 c5				push bc 
2826 ed 4b bf f1		ld bc, (os_new_malloc) 
282a 03				inc bc 
282b 03				inc bc 
282c 03				inc bc 
282d 03				inc bc 
282e 03				inc bc 
282f 03				inc bc 
2830 03				inc bc 
2831 03				inc bc 
2832			 
2832						DMARK ":0B" 
2832 f5				push af  
2833 3a 47 28			ld a, (.dmark)  
2836 32 6b fe			ld (debug_mark),a  
2839 3a 48 28			ld a, (.dmark+1)  
283c 32 6c fe			ld (debug_mark+1),a  
283f 3a 49 28			ld a, (.dmark+2)  
2842 32 6d fe			ld (debug_mark+2),a  
2845 18 03			jr .pastdmark  
2847 ..			.dmark: db ":0B"  
284a f1			.pastdmark: pop af  
284b			endm  
# End of macro DMARK
284b				CALLMONITOR 
284b cd 6f fe			call debug_vector  
284e				endm  
# End of macro CALLMONITOR
284e c1				pop bc 
284f			endif 
284f			 
284f			; update word dict linked list for new word 
284f			 
284f			 
284f 2a be f4		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2852 23			inc hl     ; move to next work linked list ptr 
2853			 
2853 ed 5b bf f1	ld de, (os_new_malloc)		 ; new next word 
2857 73			ld (hl), e 
2858 23			inc hl 
2859 72			ld (hl), d 
285a			 
285a			if DEBUG_FORTH_UWORD 
285a ed 4b be f4		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
285e			endif 
285e			 
285e ed 53 be f4	ld (os_last_new_uword), de      ; update last new uword ptr 
2862			 
2862			 
2862			if DEBUG_FORTH_UWORD 
2862						DMARK ":0+" 
2862 f5				push af  
2863 3a 77 28			ld a, (.dmark)  
2866 32 6b fe			ld (debug_mark),a  
2869 3a 78 28			ld a, (.dmark+1)  
286c 32 6c fe			ld (debug_mark+1),a  
286f 3a 79 28			ld a, (.dmark+2)  
2872 32 6d fe			ld (debug_mark+2),a  
2875 18 03			jr .pastdmark  
2877 ..			.dmark: db ":0+"  
287a f1			.pastdmark: pop af  
287b			endm  
# End of macro DMARK
287b				CALLMONITOR 
287b cd 6f fe			call debug_vector  
287e				endm  
# End of macro CALLMONITOR
287e			endif 
287e			 
287e				STACKFRAMECHK OFF $8efe $989f 
287e				if DEBUG_STACK_IMB 
287e					if OFF 
287e						exx 
287e						ld hl, $989f 
287e						pop de   ; $989f 
287e						call cmp16 
287e						jr nz, .spnosame 
287e						ld hl, $8efe 
287e						pop de   ; $8efe 
287e						call cmp16 
287e						jr z, .spfrsame 
287e						.spnosame: call showsperror 
287e						.spfrsame: nop 
287e						exx 
287e					endif 
287e				endif 
287e			endm 
# End of macro STACKFRAMECHK
287e			 
287e c9			ret    ; dont process any remaining parser tokens as they form new word 
287f			 
287f			 
287f			 
287f			 
287f			;		NEXT 
287f			.SCOLN: 
287f			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
287f 06				db OPCODE_SCOLN 
2880 cb 28			dw .DROP 
2882 02				db 2 
2883 .. 00			db ";",0           
2885			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2885					if DEBUG_FORTH_WORDS_KEY 
2885						DMARK "SCN" 
2885 f5				push af  
2886 3a 9a 28			ld a, (.dmark)  
2889 32 6b fe			ld (debug_mark),a  
288c 3a 9b 28			ld a, (.dmark+1)  
288f 32 6c fe			ld (debug_mark+1),a  
2892 3a 9c 28			ld a, (.dmark+2)  
2895 32 6d fe			ld (debug_mark+2),a  
2898 18 03			jr .pastdmark  
289a ..			.dmark: db "SCN"  
289d f1			.pastdmark: pop af  
289e			endm  
# End of macro DMARK
289e						CALLMONITOR 
289e cd 6f fe			call debug_vector  
28a1				endm  
# End of macro CALLMONITOR
28a1					endif 
28a1					FORTH_RSP_TOS 
28a1 cd 80 20			call macro_forth_rsp_tos 
28a4				endm 
# End of macro FORTH_RSP_TOS
28a4 e5					push hl 
28a5					FORTH_RSP_POP 
28a5 cd 8a 20			call macro_forth_rsp_pop 
28a8				endm 
# End of macro FORTH_RSP_POP
28a8 e1					pop hl 
28a9			;		ex de,hl 
28a9 22 c2 f4				ld (os_tok_ptr),hl 
28ac			 
28ac			if DEBUG_FORTH_UWORD 
28ac						DMARK "SCL" 
28ac f5				push af  
28ad 3a c1 28			ld a, (.dmark)  
28b0 32 6b fe			ld (debug_mark),a  
28b3 3a c2 28			ld a, (.dmark+1)  
28b6 32 6c fe			ld (debug_mark+1),a  
28b9 3a c3 28			ld a, (.dmark+2)  
28bc 32 6d fe			ld (debug_mark+2),a  
28bf 18 03			jr .pastdmark  
28c1 ..			.dmark: db "SCL"  
28c4 f1			.pastdmark: pop af  
28c5			endm  
# End of macro DMARK
28c5				CALLMONITOR 
28c5 cd 6f fe			call debug_vector  
28c8				endm  
# End of macro CALLMONITOR
28c8			endif 
28c8					NEXTW 
28c8 c3 6f 24			jp macro_next 
28cb				endm 
# End of macro NEXTW
28cb			 
28cb			.DROP: 
28cb				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
28cb 1b				db WORD_SYS_CORE+OPCODE_DROP             
28cc f6 28			dw .DUP2            
28ce 05				db 4 + 1 
28cf .. 00			db "DROP",0              
28d4				endm 
# End of macro CWHEAD
28d4			; | DROP ( w -- )   drop the TOS item   | DONE 
28d4					if DEBUG_FORTH_WORDS_KEY 
28d4						DMARK "DRP" 
28d4 f5				push af  
28d5 3a e9 28			ld a, (.dmark)  
28d8 32 6b fe			ld (debug_mark),a  
28db 3a ea 28			ld a, (.dmark+1)  
28de 32 6c fe			ld (debug_mark+1),a  
28e1 3a eb 28			ld a, (.dmark+2)  
28e4 32 6d fe			ld (debug_mark+2),a  
28e7 18 03			jr .pastdmark  
28e9 ..			.dmark: db "DRP"  
28ec f1			.pastdmark: pop af  
28ed			endm  
# End of macro DMARK
28ed						CALLMONITOR 
28ed cd 6f fe			call debug_vector  
28f0				endm  
# End of macro CALLMONITOR
28f0					endif 
28f0					FORTH_DSP_POP 
28f0 cd 71 23			call macro_forth_dsp_pop 
28f3				endm 
# End of macro FORTH_DSP_POP
28f3					NEXTW 
28f3 c3 6f 24			jp macro_next 
28f6				endm 
# End of macro NEXTW
28f6			.DUP2: 
28f6				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
28f6 1c				db WORD_SYS_CORE+OPCODE_DUP2             
28f7 3b 29			dw .DROP2            
28f9 05				db 4 + 1 
28fa .. 00			db "2DUP",0              
28ff				endm 
# End of macro CWHEAD
28ff			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
28ff					if DEBUG_FORTH_WORDS_KEY 
28ff						DMARK "2DU" 
28ff f5				push af  
2900 3a 14 29			ld a, (.dmark)  
2903 32 6b fe			ld (debug_mark),a  
2906 3a 15 29			ld a, (.dmark+1)  
2909 32 6c fe			ld (debug_mark+1),a  
290c 3a 16 29			ld a, (.dmark+2)  
290f 32 6d fe			ld (debug_mark+2),a  
2912 18 03			jr .pastdmark  
2914 ..			.dmark: db "2DU"  
2917 f1			.pastdmark: pop af  
2918			endm  
# End of macro DMARK
2918						CALLMONITOR 
2918 cd 6f fe			call debug_vector  
291b				endm  
# End of macro CALLMONITOR
291b					endif 
291b					FORTH_DSP_VALUEHL 
291b cd b9 22			call macro_dsp_valuehl 
291e				endm 
# End of macro FORTH_DSP_VALUEHL
291e e5					push hl      ; 2 
291f			 
291f					FORTH_DSP_POP 
291f cd 71 23			call macro_forth_dsp_pop 
2922				endm 
# End of macro FORTH_DSP_POP
2922					 
2922					FORTH_DSP_VALUEHL 
2922 cd b9 22			call macro_dsp_valuehl 
2925				endm 
# End of macro FORTH_DSP_VALUEHL
2925			;		push hl      ; 1 
2925			 
2925					FORTH_DSP_POP 
2925 cd 71 23			call macro_forth_dsp_pop 
2928				endm 
# End of macro FORTH_DSP_POP
2928			 
2928			;		pop hl       ; 1 
2928 d1					pop de       ; 2 
2929			 
2929 cd c2 20				call forth_push_numhl 
292c eb					ex de, hl 
292d cd c2 20				call forth_push_numhl 
2930			 
2930					 
2930 eb					ex de, hl 
2931			 
2931 cd c2 20				call forth_push_numhl 
2934 eb					ex de, hl 
2935 cd c2 20				call forth_push_numhl 
2938			 
2938			 
2938					NEXTW 
2938 c3 6f 24			jp macro_next 
293b				endm 
# End of macro NEXTW
293b			.DROP2: 
293b				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
293b 1d				db WORD_SYS_CORE+OPCODE_DROP2             
293c 6a 29			dw .SWAP2            
293e 06				db 5 + 1 
293f .. 00			db "2DROP",0              
2945				endm 
# End of macro CWHEAD
2945			; | 2DROP ( w w -- )    Double drop | DONE 
2945					if DEBUG_FORTH_WORDS_KEY 
2945						DMARK "2DR" 
2945 f5				push af  
2946 3a 5a 29			ld a, (.dmark)  
2949 32 6b fe			ld (debug_mark),a  
294c 3a 5b 29			ld a, (.dmark+1)  
294f 32 6c fe			ld (debug_mark+1),a  
2952 3a 5c 29			ld a, (.dmark+2)  
2955 32 6d fe			ld (debug_mark+2),a  
2958 18 03			jr .pastdmark  
295a ..			.dmark: db "2DR"  
295d f1			.pastdmark: pop af  
295e			endm  
# End of macro DMARK
295e						CALLMONITOR 
295e cd 6f fe			call debug_vector  
2961				endm  
# End of macro CALLMONITOR
2961					endif 
2961					FORTH_DSP_POP 
2961 cd 71 23			call macro_forth_dsp_pop 
2964				endm 
# End of macro FORTH_DSP_POP
2964					FORTH_DSP_POP 
2964 cd 71 23			call macro_forth_dsp_pop 
2967				endm 
# End of macro FORTH_DSP_POP
2967					NEXTW 
2967 c3 6f 24			jp macro_next 
296a				endm 
# End of macro NEXTW
296a			.SWAP2: 
296a				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
296a 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
296b 93 29			dw .AT            
296d 06				db 5 + 1 
296e .. 00			db "2SWAP",0              
2974				endm 
# End of macro CWHEAD
2974			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2974					if DEBUG_FORTH_WORDS_KEY 
2974						DMARK "2SW" 
2974 f5				push af  
2975 3a 89 29			ld a, (.dmark)  
2978 32 6b fe			ld (debug_mark),a  
297b 3a 8a 29			ld a, (.dmark+1)  
297e 32 6c fe			ld (debug_mark+1),a  
2981 3a 8b 29			ld a, (.dmark+2)  
2984 32 6d fe			ld (debug_mark+2),a  
2987 18 03			jr .pastdmark  
2989 ..			.dmark: db "2SW"  
298c f1			.pastdmark: pop af  
298d			endm  
# End of macro DMARK
298d						CALLMONITOR 
298d cd 6f fe			call debug_vector  
2990				endm  
# End of macro CALLMONITOR
2990					endif 
2990					NEXTW 
2990 c3 6f 24			jp macro_next 
2993				endm 
# End of macro NEXTW
2993			.AT: 
2993				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2993 1f				db WORD_SYS_CORE+OPCODE_AT             
2994 c5 29			dw .CAT            
2996 02				db 1 + 1 
2997 .. 00			db "@",0              
2999				endm 
# End of macro CWHEAD
2999			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2999			 
2999					if DEBUG_FORTH_WORDS_KEY 
2999						DMARK "AT." 
2999 f5				push af  
299a 3a ae 29			ld a, (.dmark)  
299d 32 6b fe			ld (debug_mark),a  
29a0 3a af 29			ld a, (.dmark+1)  
29a3 32 6c fe			ld (debug_mark+1),a  
29a6 3a b0 29			ld a, (.dmark+2)  
29a9 32 6d fe			ld (debug_mark+2),a  
29ac 18 03			jr .pastdmark  
29ae ..			.dmark: db "AT."  
29b1 f1			.pastdmark: pop af  
29b2			endm  
# End of macro DMARK
29b2						CALLMONITOR 
29b2 cd 6f fe			call debug_vector  
29b5				endm  
# End of macro CALLMONITOR
29b5					endif 
29b5			.getbyteat:	 
29b5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29b5 cd b9 22			call macro_dsp_valuehl 
29b8				endm 
# End of macro FORTH_DSP_VALUEHL
29b8					 
29b8			;		push hl 
29b8				 
29b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29b8 cd 71 23			call macro_forth_dsp_pop 
29bb				endm 
# End of macro FORTH_DSP_POP
29bb			 
29bb			;		pop hl 
29bb			 
29bb 7e					ld a, (hl) 
29bc			 
29bc 6f					ld l, a 
29bd 26 00				ld h, 0 
29bf cd c2 20				call forth_push_numhl 
29c2			 
29c2					NEXTW 
29c2 c3 6f 24			jp macro_next 
29c5				endm 
# End of macro NEXTW
29c5			.CAT: 
29c5				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
29c5 20				db WORD_SYS_CORE+OPCODE_CAT             
29c6 ee 29			dw .BANG            
29c8 03				db 2 + 1 
29c9 .. 00			db "C@",0              
29cc				endm 
# End of macro CWHEAD
29cc			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
29cc					if DEBUG_FORTH_WORDS_KEY 
29cc						DMARK "CAA" 
29cc f5				push af  
29cd 3a e1 29			ld a, (.dmark)  
29d0 32 6b fe			ld (debug_mark),a  
29d3 3a e2 29			ld a, (.dmark+1)  
29d6 32 6c fe			ld (debug_mark+1),a  
29d9 3a e3 29			ld a, (.dmark+2)  
29dc 32 6d fe			ld (debug_mark+2),a  
29df 18 03			jr .pastdmark  
29e1 ..			.dmark: db "CAA"  
29e4 f1			.pastdmark: pop af  
29e5			endm  
# End of macro DMARK
29e5						CALLMONITOR 
29e5 cd 6f fe			call debug_vector  
29e8				endm  
# End of macro CALLMONITOR
29e8					endif 
29e8 c3 b5 29				jp .getbyteat 
29eb					NEXTW 
29eb c3 6f 24			jp macro_next 
29ee				endm 
# End of macro NEXTW
29ee			.BANG: 
29ee				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
29ee 21				db WORD_SYS_CORE+OPCODE_BANG             
29ef 24 2a			dw .CBANG            
29f1 02				db 1 + 1 
29f2 .. 00			db "!",0              
29f4				endm 
# End of macro CWHEAD
29f4			; | ! ( x w -- ) Store x at address w      | DONE 
29f4					if DEBUG_FORTH_WORDS_KEY 
29f4						DMARK "BNG" 
29f4 f5				push af  
29f5 3a 09 2a			ld a, (.dmark)  
29f8 32 6b fe			ld (debug_mark),a  
29fb 3a 0a 2a			ld a, (.dmark+1)  
29fe 32 6c fe			ld (debug_mark+1),a  
2a01 3a 0b 2a			ld a, (.dmark+2)  
2a04 32 6d fe			ld (debug_mark+2),a  
2a07 18 03			jr .pastdmark  
2a09 ..			.dmark: db "BNG"  
2a0c f1			.pastdmark: pop af  
2a0d			endm  
# End of macro DMARK
2a0d						CALLMONITOR 
2a0d cd 6f fe			call debug_vector  
2a10				endm  
# End of macro CALLMONITOR
2a10					endif 
2a10			 
2a10			.storebyteat:		 
2a10					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a10 cd b9 22			call macro_dsp_valuehl 
2a13				endm 
# End of macro FORTH_DSP_VALUEHL
2a13					 
2a13 e5					push hl 
2a14				 
2a14					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a14 cd 71 23			call macro_forth_dsp_pop 
2a17				endm 
# End of macro FORTH_DSP_POP
2a17			 
2a17					; get byte to poke 
2a17			 
2a17					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a17 cd b9 22			call macro_dsp_valuehl 
2a1a				endm 
# End of macro FORTH_DSP_VALUEHL
2a1a e5					push hl 
2a1b			 
2a1b			 
2a1b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a1b cd 71 23			call macro_forth_dsp_pop 
2a1e				endm 
# End of macro FORTH_DSP_POP
2a1e			 
2a1e			 
2a1e d1					pop de 
2a1f e1					pop hl 
2a20			 
2a20 73					ld (hl),e 
2a21			 
2a21			 
2a21					NEXTW 
2a21 c3 6f 24			jp macro_next 
2a24				endm 
# End of macro NEXTW
2a24			.CBANG: 
2a24				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2a24 22				db WORD_SYS_CORE+OPCODE_CBANG             
2a25 4d 2a			dw .SCALL            
2a27 03				db 2 + 1 
2a28 .. 00			db "C!",0              
2a2b				endm 
# End of macro CWHEAD
2a2b			; | C!  ( x w -- ) Store x at address w  | DONE 
2a2b					if DEBUG_FORTH_WORDS_KEY 
2a2b						DMARK "CBA" 
2a2b f5				push af  
2a2c 3a 40 2a			ld a, (.dmark)  
2a2f 32 6b fe			ld (debug_mark),a  
2a32 3a 41 2a			ld a, (.dmark+1)  
2a35 32 6c fe			ld (debug_mark+1),a  
2a38 3a 42 2a			ld a, (.dmark+2)  
2a3b 32 6d fe			ld (debug_mark+2),a  
2a3e 18 03			jr .pastdmark  
2a40 ..			.dmark: db "CBA"  
2a43 f1			.pastdmark: pop af  
2a44			endm  
# End of macro DMARK
2a44						CALLMONITOR 
2a44 cd 6f fe			call debug_vector  
2a47				endm  
# End of macro CALLMONITOR
2a47					endif 
2a47 c3 10 2a				jp .storebyteat 
2a4a					NEXTW 
2a4a c3 6f 24			jp macro_next 
2a4d				endm 
# End of macro NEXTW
2a4d			.SCALL: 
2a4d				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2a4d 23				db WORD_SYS_CORE+OPCODE_SCALL             
2a4e 81 2a			dw .DEPTH            
2a50 05				db 4 + 1 
2a51 .. 00			db "CALL",0              
2a56				endm 
# End of macro CWHEAD
2a56			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2a56					if DEBUG_FORTH_WORDS_KEY 
2a56						DMARK "CLL" 
2a56 f5				push af  
2a57 3a 6b 2a			ld a, (.dmark)  
2a5a 32 6b fe			ld (debug_mark),a  
2a5d 3a 6c 2a			ld a, (.dmark+1)  
2a60 32 6c fe			ld (debug_mark+1),a  
2a63 3a 6d 2a			ld a, (.dmark+2)  
2a66 32 6d fe			ld (debug_mark+2),a  
2a69 18 03			jr .pastdmark  
2a6b ..			.dmark: db "CLL"  
2a6e f1			.pastdmark: pop af  
2a6f			endm  
# End of macro DMARK
2a6f						CALLMONITOR 
2a6f cd 6f fe			call debug_vector  
2a72				endm  
# End of macro CALLMONITOR
2a72					endif 
2a72			 
2a72					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a72 cd b9 22			call macro_dsp_valuehl 
2a75				endm 
# End of macro FORTH_DSP_VALUEHL
2a75			 
2a75			;		push hl 
2a75			 
2a75					; destroy value TOS 
2a75			 
2a75					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a75 cd 71 23			call macro_forth_dsp_pop 
2a78				endm 
# End of macro FORTH_DSP_POP
2a78			 
2a78						 
2a78			;		pop hl 
2a78			 
2a78					; how to do a call with hl???? save SP? 
2a78 cd 13 24				call forth_call_hl 
2a7b			 
2a7b			 
2a7b					; TODO push value back onto stack for another op etc 
2a7b			 
2a7b cd c2 20				call forth_push_numhl 
2a7e					NEXTW 
2a7e c3 6f 24			jp macro_next 
2a81				endm 
# End of macro NEXTW
2a81			.DEPTH: 
2a81				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2a81 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2a82 be 2a			dw .OVER            
2a84 06				db 5 + 1 
2a85 .. 00			db "DEPTH",0              
2a8b				endm 
# End of macro CWHEAD
2a8b			; | DEPTH ( -- u ) Push count of stack | DONE 
2a8b					; take current TOS and remove from base value div by two to get count 
2a8b					if DEBUG_FORTH_WORDS_KEY 
2a8b						DMARK "DEP" 
2a8b f5				push af  
2a8c 3a a0 2a			ld a, (.dmark)  
2a8f 32 6b fe			ld (debug_mark),a  
2a92 3a a1 2a			ld a, (.dmark+1)  
2a95 32 6c fe			ld (debug_mark+1),a  
2a98 3a a2 2a			ld a, (.dmark+2)  
2a9b 32 6d fe			ld (debug_mark+2),a  
2a9e 18 03			jr .pastdmark  
2aa0 ..			.dmark: db "DEP"  
2aa3 f1			.pastdmark: pop af  
2aa4			endm  
# End of macro DMARK
2aa4						CALLMONITOR 
2aa4 cd 6f fe			call debug_vector  
2aa7				endm  
# End of macro CALLMONITOR
2aa7					endif 
2aa7			 
2aa7			 
2aa7 2a ee f9			ld hl, (cli_data_sp) 
2aaa 11 28 f7			ld de, cli_data_stack 
2aad ed 52			sbc hl,de 
2aaf				 
2aaf				; div by size of stack item 
2aaf			 
2aaf 5d				ld e,l 
2ab0 0e 03			ld c, 3 
2ab2 cd 16 0f			call Div8 
2ab5			 
2ab5 6f				ld l,a 
2ab6 26 00			ld h,0 
2ab8			 
2ab8				;srl h 
2ab8				;rr l 
2ab8			 
2ab8 cd c2 20				call forth_push_numhl 
2abb					NEXTW 
2abb c3 6f 24			jp macro_next 
2abe				endm 
# End of macro NEXTW
2abe			.OVER: 
2abe				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2abe 42				db WORD_SYS_CORE+46             
2abf 05 2b			dw .PAUSE            
2ac1 05				db 4 + 1 
2ac2 .. 00			db "OVER",0              
2ac7				endm 
# End of macro CWHEAD
2ac7			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2ac7					if DEBUG_FORTH_WORDS_KEY 
2ac7						DMARK "OVR" 
2ac7 f5				push af  
2ac8 3a dc 2a			ld a, (.dmark)  
2acb 32 6b fe			ld (debug_mark),a  
2ace 3a dd 2a			ld a, (.dmark+1)  
2ad1 32 6c fe			ld (debug_mark+1),a  
2ad4 3a de 2a			ld a, (.dmark+2)  
2ad7 32 6d fe			ld (debug_mark+2),a  
2ada 18 03			jr .pastdmark  
2adc ..			.dmark: db "OVR"  
2adf f1			.pastdmark: pop af  
2ae0			endm  
# End of macro DMARK
2ae0						CALLMONITOR 
2ae0 cd 6f fe			call debug_vector  
2ae3				endm  
# End of macro CALLMONITOR
2ae3					endif 
2ae3			 
2ae3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ae3 cd b9 22			call macro_dsp_valuehl 
2ae6				endm 
# End of macro FORTH_DSP_VALUEHL
2ae6 e5					push hl    ; n2 
2ae7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ae7 cd 71 23			call macro_forth_dsp_pop 
2aea				endm 
# End of macro FORTH_DSP_POP
2aea			 
2aea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2aea cd b9 22			call macro_dsp_valuehl 
2aed				endm 
# End of macro FORTH_DSP_VALUEHL
2aed e5					push hl    ; n1 
2aee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2aee cd 71 23			call macro_forth_dsp_pop 
2af1				endm 
# End of macro FORTH_DSP_POP
2af1			 
2af1 d1					pop de     ; n1 
2af2 e1					pop hl     ; n2 
2af3			 
2af3 d5					push de 
2af4 e5					push hl 
2af5 d5					push de 
2af6			 
2af6					; push back  
2af6			 
2af6 e1					pop hl 
2af7 cd c2 20				call forth_push_numhl 
2afa e1					pop hl 
2afb cd c2 20				call forth_push_numhl 
2afe e1					pop hl 
2aff cd c2 20				call forth_push_numhl 
2b02					NEXTW 
2b02 c3 6f 24			jp macro_next 
2b05				endm 
# End of macro NEXTW
2b05			 
2b05			.PAUSE: 
2b05				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2b05 43				db WORD_SYS_CORE+47             
2b06 3a 2b			dw .PAUSES            
2b08 08				db 7 + 1 
2b09 .. 00			db "PAUSEMS",0              
2b11				endm 
# End of macro CWHEAD
2b11			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2b11					if DEBUG_FORTH_WORDS_KEY 
2b11						DMARK "PMS" 
2b11 f5				push af  
2b12 3a 26 2b			ld a, (.dmark)  
2b15 32 6b fe			ld (debug_mark),a  
2b18 3a 27 2b			ld a, (.dmark+1)  
2b1b 32 6c fe			ld (debug_mark+1),a  
2b1e 3a 28 2b			ld a, (.dmark+2)  
2b21 32 6d fe			ld (debug_mark+2),a  
2b24 18 03			jr .pastdmark  
2b26 ..			.dmark: db "PMS"  
2b29 f1			.pastdmark: pop af  
2b2a			endm  
# End of macro DMARK
2b2a						CALLMONITOR 
2b2a cd 6f fe			call debug_vector  
2b2d				endm  
# End of macro CALLMONITOR
2b2d					endif 
2b2d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b2d cd b9 22			call macro_dsp_valuehl 
2b30				endm 
# End of macro FORTH_DSP_VALUEHL
2b30			;		push hl    ; n2 
2b30					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b30 cd 71 23			call macro_forth_dsp_pop 
2b33				endm 
# End of macro FORTH_DSP_POP
2b33			;		pop hl 
2b33			 
2b33 7d					ld a, l 
2b34 cd 7a 0c				call aDelayInMS 
2b37				       NEXTW 
2b37 c3 6f 24			jp macro_next 
2b3a				endm 
# End of macro NEXTW
2b3a			.PAUSES:  
2b3a				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2b3a 44				db WORD_SYS_CORE+48             
2b3b a9 2b			dw .ROT            
2b3d 06				db 5 + 1 
2b3e .. 00			db "PAUSE",0              
2b44				endm 
# End of macro CWHEAD
2b44			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2b44					if DEBUG_FORTH_WORDS_KEY 
2b44						DMARK "PAU" 
2b44 f5				push af  
2b45 3a 59 2b			ld a, (.dmark)  
2b48 32 6b fe			ld (debug_mark),a  
2b4b 3a 5a 2b			ld a, (.dmark+1)  
2b4e 32 6c fe			ld (debug_mark+1),a  
2b51 3a 5b 2b			ld a, (.dmark+2)  
2b54 32 6d fe			ld (debug_mark+2),a  
2b57 18 03			jr .pastdmark  
2b59 ..			.dmark: db "PAU"  
2b5c f1			.pastdmark: pop af  
2b5d			endm  
# End of macro DMARK
2b5d						CALLMONITOR 
2b5d cd 6f fe			call debug_vector  
2b60				endm  
# End of macro CALLMONITOR
2b60					endif 
2b60					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b60 cd b9 22			call macro_dsp_valuehl 
2b63				endm 
# End of macro FORTH_DSP_VALUEHL
2b63			;		push hl    ; n2 
2b63					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b63 cd 71 23			call macro_forth_dsp_pop 
2b66				endm 
# End of macro FORTH_DSP_POP
2b66			;		pop hl 
2b66 45					ld b, l 
2b67					if DEBUG_FORTH_WORDS 
2b67						DMARK "PAU" 
2b67 f5				push af  
2b68 3a 7c 2b			ld a, (.dmark)  
2b6b 32 6b fe			ld (debug_mark),a  
2b6e 3a 7d 2b			ld a, (.dmark+1)  
2b71 32 6c fe			ld (debug_mark+1),a  
2b74 3a 7e 2b			ld a, (.dmark+2)  
2b77 32 6d fe			ld (debug_mark+2),a  
2b7a 18 03			jr .pastdmark  
2b7c ..			.dmark: db "PAU"  
2b7f f1			.pastdmark: pop af  
2b80			endm  
# End of macro DMARK
2b80						CALLMONITOR 
2b80 cd 6f fe			call debug_vector  
2b83				endm  
# End of macro CALLMONITOR
2b83					endif 
2b83 c5			.pauses1:	push bc 
2b84 cd 95 0c				call delay1s 
2b87 c1					pop bc 
2b88					if DEBUG_FORTH_WORDS 
2b88						DMARK "PA1" 
2b88 f5				push af  
2b89 3a 9d 2b			ld a, (.dmark)  
2b8c 32 6b fe			ld (debug_mark),a  
2b8f 3a 9e 2b			ld a, (.dmark+1)  
2b92 32 6c fe			ld (debug_mark+1),a  
2b95 3a 9f 2b			ld a, (.dmark+2)  
2b98 32 6d fe			ld (debug_mark+2),a  
2b9b 18 03			jr .pastdmark  
2b9d ..			.dmark: db "PA1"  
2ba0 f1			.pastdmark: pop af  
2ba1			endm  
# End of macro DMARK
2ba1						CALLMONITOR 
2ba1 cd 6f fe			call debug_vector  
2ba4				endm  
# End of macro CALLMONITOR
2ba4					endif 
2ba4 10 dd				djnz .pauses1 
2ba6			 
2ba6				       NEXTW 
2ba6 c3 6f 24			jp macro_next 
2ba9				endm 
# End of macro NEXTW
2ba9			.ROT: 
2ba9				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2ba9 45				db WORD_SYS_CORE+49             
2baa f7 2b			dw .UWORDS            
2bac 04				db 3 + 1 
2bad .. 00			db "ROT",0              
2bb1				endm 
# End of macro CWHEAD
2bb1			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2bb1					if DEBUG_FORTH_WORDS_KEY 
2bb1						DMARK "ROT" 
2bb1 f5				push af  
2bb2 3a c6 2b			ld a, (.dmark)  
2bb5 32 6b fe			ld (debug_mark),a  
2bb8 3a c7 2b			ld a, (.dmark+1)  
2bbb 32 6c fe			ld (debug_mark+1),a  
2bbe 3a c8 2b			ld a, (.dmark+2)  
2bc1 32 6d fe			ld (debug_mark+2),a  
2bc4 18 03			jr .pastdmark  
2bc6 ..			.dmark: db "ROT"  
2bc9 f1			.pastdmark: pop af  
2bca			endm  
# End of macro DMARK
2bca						CALLMONITOR 
2bca cd 6f fe			call debug_vector  
2bcd				endm  
# End of macro CALLMONITOR
2bcd					endif 
2bcd			 
2bcd					FORTH_DSP_VALUEHL 
2bcd cd b9 22			call macro_dsp_valuehl 
2bd0				endm 
# End of macro FORTH_DSP_VALUEHL
2bd0 e5					push hl    ; u3  
2bd1			 
2bd1					FORTH_DSP_POP 
2bd1 cd 71 23			call macro_forth_dsp_pop 
2bd4				endm 
# End of macro FORTH_DSP_POP
2bd4			   
2bd4					FORTH_DSP_VALUEHL 
2bd4 cd b9 22			call macro_dsp_valuehl 
2bd7				endm 
# End of macro FORTH_DSP_VALUEHL
2bd7 e5					push hl     ; u2 
2bd8			 
2bd8					FORTH_DSP_POP 
2bd8 cd 71 23			call macro_forth_dsp_pop 
2bdb				endm 
# End of macro FORTH_DSP_POP
2bdb			 
2bdb					FORTH_DSP_VALUEHL 
2bdb cd b9 22			call macro_dsp_valuehl 
2bde				endm 
# End of macro FORTH_DSP_VALUEHL
2bde e5					push hl     ; u1 
2bdf			 
2bdf					FORTH_DSP_POP 
2bdf cd 71 23			call macro_forth_dsp_pop 
2be2				endm 
# End of macro FORTH_DSP_POP
2be2			 
2be2 c1					pop bc      ; u1 
2be3 e1					pop hl      ; u2 
2be4 d1					pop de      ; u3 
2be5			 
2be5			 
2be5 c5					push bc 
2be6 d5					push de 
2be7 e5					push hl 
2be8			 
2be8			 
2be8 e1					pop hl 
2be9 cd c2 20				call forth_push_numhl 
2bec			 
2bec e1					pop hl 
2bed cd c2 20				call forth_push_numhl 
2bf0			 
2bf0 e1					pop hl 
2bf1 cd c2 20				call forth_push_numhl 
2bf4					 
2bf4			 
2bf4			 
2bf4			 
2bf4			 
2bf4			 
2bf4				       NEXTW 
2bf4 c3 6f 24			jp macro_next 
2bf7				endm 
# End of macro NEXTW
2bf7			 
2bf7			.UWORDS: 
2bf7				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2bf7 50				db WORD_SYS_CORE+60             
2bf8 b9 2c			dw .BP            
2bfa 07				db 6 + 1 
2bfb .. 00			db "UWORDS",0              
2c02				endm 
# End of macro CWHEAD
2c02			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2c02			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2c02			; | | Following the count are the individual words. 
2c02			; | | 
2c02			; | | e.g. UWORDS 
2c02			; | | BOX DIRLIST 2 
2c02			; | |  
2c02			; | | Can be used to save the words to storage via: 
2c02			; | | UWORDS $01 DO $01 APPEND LOOP 
2c02				if DEBUG_FORTH_WORDS_KEY 
2c02					DMARK "UWR" 
2c02 f5				push af  
2c03 3a 17 2c			ld a, (.dmark)  
2c06 32 6b fe			ld (debug_mark),a  
2c09 3a 18 2c			ld a, (.dmark+1)  
2c0c 32 6c fe			ld (debug_mark+1),a  
2c0f 3a 19 2c			ld a, (.dmark+2)  
2c12 32 6d fe			ld (debug_mark+2),a  
2c15 18 03			jr .pastdmark  
2c17 ..			.dmark: db "UWR"  
2c1a f1			.pastdmark: pop af  
2c1b			endm  
# End of macro DMARK
2c1b					CALLMONITOR 
2c1b cd 6f fe			call debug_vector  
2c1e				endm  
# End of macro CALLMONITOR
2c1e				endif 
2c1e 21 00 80				ld hl, baseram 
2c21					;ld hl, baseusermem 
2c21 01 00 00				ld bc, 0    ; start a counter 
2c24			 
2c24				; skip dict stub 
2c24			 
2c24 cd c0 25				call forth_tok_next 
2c27			 
2c27			 
2c27			; while we have words to look for 
2c27			 
2c27 7e			.douscan:	ld a, (hl)      
2c28				if DEBUG_FORTH_WORDS 
2c28					DMARK "UWs" 
2c28 f5				push af  
2c29 3a 3d 2c			ld a, (.dmark)  
2c2c 32 6b fe			ld (debug_mark),a  
2c2f 3a 3e 2c			ld a, (.dmark+1)  
2c32 32 6c fe			ld (debug_mark+1),a  
2c35 3a 3f 2c			ld a, (.dmark+2)  
2c38 32 6d fe			ld (debug_mark+2),a  
2c3b 18 03			jr .pastdmark  
2c3d ..			.dmark: db "UWs"  
2c40 f1			.pastdmark: pop af  
2c41			endm  
# End of macro DMARK
2c41					CALLMONITOR 
2c41 cd 6f fe			call debug_vector  
2c44				endm  
# End of macro CALLMONITOR
2c44				endif 
2c44 fe 00				cp WORD_SYS_END 
2c46 28 4d				jr z, .udone 
2c48 fe 01				cp WORD_SYS_UWORD 
2c4a 20 44				jr nz, .nuword 
2c4c			 
2c4c				if DEBUG_FORTH_WORDS 
2c4c					DMARK "UWu" 
2c4c f5				push af  
2c4d 3a 61 2c			ld a, (.dmark)  
2c50 32 6b fe			ld (debug_mark),a  
2c53 3a 62 2c			ld a, (.dmark+1)  
2c56 32 6c fe			ld (debug_mark+1),a  
2c59 3a 63 2c			ld a, (.dmark+2)  
2c5c 32 6d fe			ld (debug_mark+2),a  
2c5f 18 03			jr .pastdmark  
2c61 ..			.dmark: db "UWu"  
2c64 f1			.pastdmark: pop af  
2c65			endm  
# End of macro DMARK
2c65					CALLMONITOR 
2c65 cd 6f fe			call debug_vector  
2c68				endm  
# End of macro CALLMONITOR
2c68				endif 
2c68					; we have a uword so push its name to the stack 
2c68			 
2c68 e5				   	push hl  ; save so we can move to next dict block 
2c69			 
2c69					; skip opcode 
2c69 23					inc hl  
2c6a					; skip next ptr 
2c6a 23					inc hl  
2c6b 23					inc hl 
2c6c					; skip len 
2c6c 23					inc hl 
2c6d				if DEBUG_FORTH_WORDS 
2c6d					DMARK "UWt" 
2c6d f5				push af  
2c6e 3a 82 2c			ld a, (.dmark)  
2c71 32 6b fe			ld (debug_mark),a  
2c74 3a 83 2c			ld a, (.dmark+1)  
2c77 32 6c fe			ld (debug_mark+1),a  
2c7a 3a 84 2c			ld a, (.dmark+2)  
2c7d 32 6d fe			ld (debug_mark+2),a  
2c80 18 03			jr .pastdmark  
2c82 ..			.dmark: db "UWt"  
2c85 f1			.pastdmark: pop af  
2c86			endm  
# End of macro DMARK
2c86					CALLMONITOR 
2c86 cd 6f fe			call debug_vector  
2c89				endm  
# End of macro CALLMONITOR
2c89				endif 
2c89 03					inc bc 
2c8a			 
2c8a c5					push bc 
2c8b cd 30 21				call forth_push_str 
2c8e c1					pop bc 
2c8f			 
2c8f e1					pop hl 	 
2c90			 
2c90 cd c0 25		.nuword:	call forth_tok_next 
2c93 18 92				jr .douscan  
2c95			 
2c95			.udone:		 ; push count of uwords found 
2c95 c5					push bc 
2c96 e1					pop hl 
2c97			 
2c97				if DEBUG_FORTH_WORDS 
2c97					DMARK "UWc" 
2c97 f5				push af  
2c98 3a ac 2c			ld a, (.dmark)  
2c9b 32 6b fe			ld (debug_mark),a  
2c9e 3a ad 2c			ld a, (.dmark+1)  
2ca1 32 6c fe			ld (debug_mark+1),a  
2ca4 3a ae 2c			ld a, (.dmark+2)  
2ca7 32 6d fe			ld (debug_mark+2),a  
2caa 18 03			jr .pastdmark  
2cac ..			.dmark: db "UWc"  
2caf f1			.pastdmark: pop af  
2cb0			endm  
# End of macro DMARK
2cb0					CALLMONITOR 
2cb0 cd 6f fe			call debug_vector  
2cb3				endm  
# End of macro CALLMONITOR
2cb3				endif 
2cb3 cd c2 20				call forth_push_numhl 
2cb6			 
2cb6			 
2cb6				       NEXTW 
2cb6 c3 6f 24			jp macro_next 
2cb9				endm 
# End of macro NEXTW
2cb9			 
2cb9			.BP: 
2cb9				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2cb9 54				db WORD_SYS_CORE+64             
2cba f3 2c			dw .MONITOR            
2cbc 03				db 2 + 1 
2cbd .. 00			db "BP",0              
2cc0				endm 
# End of macro CWHEAD
2cc0			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2cc0			; | | $00 Will enable the break points within specific code paths 
2cc0			; | | $01 Will disable break points 
2cc0			; | |  
2cc0			; | | By default break points are off. Either the above can be used to enable them 
2cc0			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2cc0			; | | and on release of the pressed key a message will be disaplayed to notify 
2cc0			; | | that break points are enabled. Pressing any key will then continue boot process. 
2cc0					; get byte count 
2cc0					if DEBUG_FORTH_WORDS_KEY 
2cc0						DMARK "BP." 
2cc0 f5				push af  
2cc1 3a d5 2c			ld a, (.dmark)  
2cc4 32 6b fe			ld (debug_mark),a  
2cc7 3a d6 2c			ld a, (.dmark+1)  
2cca 32 6c fe			ld (debug_mark+1),a  
2ccd 3a d7 2c			ld a, (.dmark+2)  
2cd0 32 6d fe			ld (debug_mark+2),a  
2cd3 18 03			jr .pastdmark  
2cd5 ..			.dmark: db "BP."  
2cd8 f1			.pastdmark: pop af  
2cd9			endm  
# End of macro DMARK
2cd9						CALLMONITOR 
2cd9 cd 6f fe			call debug_vector  
2cdc				endm  
# End of macro CALLMONITOR
2cdc					endif 
2cdc			 
2cdc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2cdc cd b9 22			call macro_dsp_valuehl 
2cdf				endm 
# End of macro FORTH_DSP_VALUEHL
2cdf			 
2cdf			;		push hl 
2cdf			 
2cdf					; destroy value TOS 
2cdf			 
2cdf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2cdf cd 71 23			call macro_forth_dsp_pop 
2ce2				endm 
# End of macro FORTH_DSP_POP
2ce2			 
2ce2			;		pop hl 
2ce2			 
2ce2 3e 00				ld a,0 
2ce4 bd					cp l 
2ce5 28 06				jr z, .bpset 
2ce7			;		ld a, '*' 
2ce7 cd fd 19				call bp_off 
2cea					NEXTW 
2cea c3 6f 24			jp macro_next 
2ced				endm 
# End of macro NEXTW
2ced			 
2ced			.bpset:	 
2ced					;	ld (os_view_disable), a 
2ced cd f1 19				call bp_on 
2cf0			 
2cf0			 
2cf0					NEXTW 
2cf0 c3 6f 24			jp macro_next 
2cf3				endm 
# End of macro NEXTW
2cf3			 
2cf3			 
2cf3			.MONITOR: 
2cf3				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2cf3 55				db WORD_SYS_CORE+65             
2cf4 24 2d			dw .MALLOC            
2cf6 08				db 7 + 1 
2cf7 .. 00			db "MONITOR",0              
2cff				endm 
# End of macro CWHEAD
2cff			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2cff			; | | At start the current various registers will be displayed with contents. 
2cff			; | | Top right corner will show the most recent debug marker seen. 
2cff			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2cff			; | | and the return stack pointer (RSP). 
2cff			; | | Pressing: 
2cff			; | |    1 - Initial screen 
2cff			; | |    2 - Display a data dump of HL 
2cff			; | |    3 - Display a data dump of DE 
2cff			; | |    4 - Display a data dump of BC 
2cff			; | |    5 - Display a data dump of HL 
2cff			; | |    6 - Display a data dump of DSP 
2cff			; | |    7 - Display a data dump of RSP 
2cff			; | |    8 - Display a data dump of what is at DSP 
2cff			; | |    9 - Display a data dump of what is at RSP 
2cff			; | |    0 - Exit monitor and continue running. This will also enable break points 
2cff			; | |    * - Disable break points 
2cff			; | |    # - Enter traditional monitor mode 
2cff			; | | 
2cff			; | | Monitor Mode 
2cff			; | | ------------ 
2cff			; | | A prompt of '>' will be shown for various commands: 
2cff			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2cff			; | |    C - Continue display a data dump from the last set address 
2cff			; | |    M xxxx - Set start of memory edit at address xx 
2cff			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2cff			; | |    Q - Return to previous 
2cff					if DEBUG_FORTH_WORDS_KEY 
2cff						DMARK "MON" 
2cff f5				push af  
2d00 3a 14 2d			ld a, (.dmark)  
2d03 32 6b fe			ld (debug_mark),a  
2d06 3a 15 2d			ld a, (.dmark+1)  
2d09 32 6c fe			ld (debug_mark+1),a  
2d0c 3a 16 2d			ld a, (.dmark+2)  
2d0f 32 6d fe			ld (debug_mark+2),a  
2d12 18 03			jr .pastdmark  
2d14 ..			.dmark: db "MON"  
2d17 f1			.pastdmark: pop af  
2d18			endm  
# End of macro DMARK
2d18						CALLMONITOR 
2d18 cd 6f fe			call debug_vector  
2d1b				endm  
# End of macro CALLMONITOR
2d1b					endif 
2d1b			;		ld a, 0 
2d1b			;		ld (os_view_disable), a 
2d1b cd f1 19				call bp_on 
2d1e			 
2d1e					CALLMONITOR 
2d1e cd 6f fe			call debug_vector  
2d21				endm  
# End of macro CALLMONITOR
2d21			 
2d21			;	call monitor 
2d21			 
2d21					NEXTW 
2d21 c3 6f 24			jp macro_next 
2d24				endm 
# End of macro NEXTW
2d24			 
2d24			 
2d24			.MALLOC: 
2d24				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2d24 56				db WORD_SYS_CORE+66             
2d25 4d 2d			dw .MALLOC2            
2d27 06				db 5 + 1 
2d28 .. 00			db "ALLOT",0              
2d2e				endm 
# End of macro CWHEAD
2d2e			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d2e					if DEBUG_FORTH_WORDS_KEY 
2d2e						DMARK "ALL" 
2d2e f5				push af  
2d2f 3a 43 2d			ld a, (.dmark)  
2d32 32 6b fe			ld (debug_mark),a  
2d35 3a 44 2d			ld a, (.dmark+1)  
2d38 32 6c fe			ld (debug_mark+1),a  
2d3b 3a 45 2d			ld a, (.dmark+2)  
2d3e 32 6d fe			ld (debug_mark+2),a  
2d41 18 03			jr .pastdmark  
2d43 ..			.dmark: db "ALL"  
2d46 f1			.pastdmark: pop af  
2d47			endm  
# End of macro DMARK
2d47						CALLMONITOR 
2d47 cd 6f fe			call debug_vector  
2d4a				endm  
# End of macro CALLMONITOR
2d4a					endif 
2d4a c3 74 2d				jp .mallocc 
2d4d			.MALLOC2: 
2d4d				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2d4d 56				db WORD_SYS_CORE+66             
2d4e 8b 2d			dw .FREE            
2d50 07				db 6 + 1 
2d51 .. 00			db "MALLOC",0              
2d58				endm 
# End of macro CWHEAD
2d58			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d58					; get byte count 
2d58					if DEBUG_FORTH_WORDS_KEY 
2d58						DMARK "MAL" 
2d58 f5				push af  
2d59 3a 6d 2d			ld a, (.dmark)  
2d5c 32 6b fe			ld (debug_mark),a  
2d5f 3a 6e 2d			ld a, (.dmark+1)  
2d62 32 6c fe			ld (debug_mark+1),a  
2d65 3a 6f 2d			ld a, (.dmark+2)  
2d68 32 6d fe			ld (debug_mark+2),a  
2d6b 18 03			jr .pastdmark  
2d6d ..			.dmark: db "MAL"  
2d70 f1			.pastdmark: pop af  
2d71			endm  
# End of macro DMARK
2d71						CALLMONITOR 
2d71 cd 6f fe			call debug_vector  
2d74				endm  
# End of macro CALLMONITOR
2d74					endif 
2d74			.mallocc: 
2d74					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d74 cd b9 22			call macro_dsp_valuehl 
2d77				endm 
# End of macro FORTH_DSP_VALUEHL
2d77			 
2d77			;		push hl 
2d77			 
2d77					; destroy value TOS 
2d77			 
2d77					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d77 cd 71 23			call macro_forth_dsp_pop 
2d7a				endm 
# End of macro FORTH_DSP_POP
2d7a			 
2d7a			;		pop hl 
2d7a cd 4d 14				call malloc 
2d7d				if DEBUG_FORTH_MALLOC_GUARD 
2d7d f5					push af 
2d7e cd af 0f				call ishlzero 
2d81			;		ld a, l 
2d81			;		add h 
2d81			;		cp 0 
2d81 f1					pop af 
2d82					 
2d82 cc 8f 5d				call z,malloc_error 
2d85				endif 
2d85			 
2d85 cd c2 20				call forth_push_numhl 
2d88					NEXTW 
2d88 c3 6f 24			jp macro_next 
2d8b				endm 
# End of macro NEXTW
2d8b			 
2d8b			.FREE: 
2d8b				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2d8b 57				db WORD_SYS_CORE+67             
2d8c bc 2d			dw .LIST            
2d8e 05				db 4 + 1 
2d8f .. 00			db "FREE",0              
2d94				endm 
# End of macro CWHEAD
2d94			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2d94					if DEBUG_FORTH_WORDS_KEY 
2d94						DMARK "FRE" 
2d94 f5				push af  
2d95 3a a9 2d			ld a, (.dmark)  
2d98 32 6b fe			ld (debug_mark),a  
2d9b 3a aa 2d			ld a, (.dmark+1)  
2d9e 32 6c fe			ld (debug_mark+1),a  
2da1 3a ab 2d			ld a, (.dmark+2)  
2da4 32 6d fe			ld (debug_mark+2),a  
2da7 18 03			jr .pastdmark  
2da9 ..			.dmark: db "FRE"  
2dac f1			.pastdmark: pop af  
2dad			endm  
# End of macro DMARK
2dad						CALLMONITOR 
2dad cd 6f fe			call debug_vector  
2db0				endm  
# End of macro CALLMONITOR
2db0					endif 
2db0					; get address 
2db0			 
2db0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2db0 cd b9 22			call macro_dsp_valuehl 
2db3				endm 
# End of macro FORTH_DSP_VALUEHL
2db3			 
2db3			;		push hl 
2db3			 
2db3					; destroy value TOS 
2db3			 
2db3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2db3 cd 71 23			call macro_forth_dsp_pop 
2db6				endm 
# End of macro FORTH_DSP_POP
2db6			 
2db6			;		pop hl 
2db6			if FORTH_ENABLE_MALLOCFREE 
2db6 cd 17 15				call free 
2db9			endif 
2db9					NEXTW 
2db9 c3 6f 24			jp macro_next 
2dbc				endm 
# End of macro NEXTW
2dbc			.LIST: 
2dbc				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2dbc 5c				db WORD_SYS_CORE+72             
2dbd aa 2f			dw .FORGET            
2dbf 05				db 4 + 1 
2dc0 .. 00			db "LIST",0              
2dc5				endm 
# End of macro CWHEAD
2dc5			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2dc5			; | | The quoted word must be in upper case. 
2dc5				if DEBUG_FORTH_WORDS_KEY 
2dc5					DMARK "LST" 
2dc5 f5				push af  
2dc6 3a da 2d			ld a, (.dmark)  
2dc9 32 6b fe			ld (debug_mark),a  
2dcc 3a db 2d			ld a, (.dmark+1)  
2dcf 32 6c fe			ld (debug_mark+1),a  
2dd2 3a dc 2d			ld a, (.dmark+2)  
2dd5 32 6d fe			ld (debug_mark+2),a  
2dd8 18 03			jr .pastdmark  
2dda ..			.dmark: db "LST"  
2ddd f1			.pastdmark: pop af  
2dde			endm  
# End of macro DMARK
2dde					CALLMONITOR 
2dde cd 6f fe			call debug_vector  
2de1				endm  
# End of macro CALLMONITOR
2de1				endif 
2de1			 
2de1					FORTH_DSP_VALUEHL 
2de1 cd b9 22			call macro_dsp_valuehl 
2de4				endm 
# End of macro FORTH_DSP_VALUEHL
2de4			 
2de4 e5					push hl 
2de5					FORTH_DSP_POP 
2de5 cd 71 23			call macro_forth_dsp_pop 
2de8				endm 
# End of macro FORTH_DSP_POP
2de8 c1					pop bc 
2de9			 
2de9			; Start format of scratch string 
2de9			 
2de9 21 c1 f1				ld hl, scratch 
2dec			 
2dec 3e 3a				ld a, ':' 
2dee 77					ld (hl),a 
2def 23					inc hl 
2df0 3e 20				ld a, ' ' 
2df2 77					ld (hl), a 
2df3			 
2df3					; Get ptr to the word we need to look up 
2df3			 
2df3			;		FORTH_DSP_VALUEHL 
2df3					;v5 FORTH_DSP_VALUE 
2df3				; TODO type check 
2df3			;		inc hl    ; Skip type check  
2df3			;		push hl 
2df3			;		ex de, hl    ; put into DE 
2df3			 
2df3			 
2df3 21 00 80				ld hl, baseram 
2df6					;ld hl, baseusermem 
2df6			 
2df6 e5			push hl   ; sacreifical push 
2df7			 
2df7			.ldouscanm: 
2df7 e1				pop hl 
2df8			.ldouscan: 
2df8				if DEBUG_FORTH_WORDS 
2df8					DMARK "LSs" 
2df8 f5				push af  
2df9 3a 0d 2e			ld a, (.dmark)  
2dfc 32 6b fe			ld (debug_mark),a  
2dff 3a 0e 2e			ld a, (.dmark+1)  
2e02 32 6c fe			ld (debug_mark+1),a  
2e05 3a 0f 2e			ld a, (.dmark+2)  
2e08 32 6d fe			ld (debug_mark+2),a  
2e0b 18 03			jr .pastdmark  
2e0d ..			.dmark: db "LSs"  
2e10 f1			.pastdmark: pop af  
2e11			endm  
# End of macro DMARK
2e11					CALLMONITOR 
2e11 cd 6f fe			call debug_vector  
2e14				endm  
# End of macro CALLMONITOR
2e14				endif 
2e14				; skip dict stub 
2e14 cd c0 25				call forth_tok_next 
2e17			 
2e17			 
2e17			; while we have words to look for 
2e17			 
2e17 7e				ld a, (hl)      
2e18				if DEBUG_FORTH_WORDS 
2e18					DMARK "LSk" 
2e18 f5				push af  
2e19 3a 2d 2e			ld a, (.dmark)  
2e1c 32 6b fe			ld (debug_mark),a  
2e1f 3a 2e 2e			ld a, (.dmark+1)  
2e22 32 6c fe			ld (debug_mark+1),a  
2e25 3a 2f 2e			ld a, (.dmark+2)  
2e28 32 6d fe			ld (debug_mark+2),a  
2e2b 18 03			jr .pastdmark  
2e2d ..			.dmark: db "LSk"  
2e30 f1			.pastdmark: pop af  
2e31			endm  
# End of macro DMARK
2e31					CALLMONITOR 
2e31 cd 6f fe			call debug_vector  
2e34				endm  
# End of macro CALLMONITOR
2e34				endif 
2e34					;cp WORD_SYS_END 
2e34					;jp z, .lunotfound 
2e34			 
2e34					; if we hit non uwords then gone too far 
2e34 fe 01				cp WORD_SYS_UWORD 
2e36 c2 66 2f				jp nz, .lunotfound 
2e39			 
2e39				if DEBUG_FORTH_WORDS 
2e39					DMARK "LSu" 
2e39 f5				push af  
2e3a 3a 4e 2e			ld a, (.dmark)  
2e3d 32 6b fe			ld (debug_mark),a  
2e40 3a 4f 2e			ld a, (.dmark+1)  
2e43 32 6c fe			ld (debug_mark+1),a  
2e46 3a 50 2e			ld a, (.dmark+2)  
2e49 32 6d fe			ld (debug_mark+2),a  
2e4c 18 03			jr .pastdmark  
2e4e ..			.dmark: db "LSu"  
2e51 f1			.pastdmark: pop af  
2e52			endm  
# End of macro DMARK
2e52					CALLMONITOR 
2e52 cd 6f fe			call debug_vector  
2e55				endm  
# End of macro CALLMONITOR
2e55				endif 
2e55			 
2e55					; found a uword but is it the one we want... 
2e55			 
2e55 c5					push bc     ; uword to find is on bc 
2e56 d1					pop de 
2e57			 
2e57 e5					push hl  ; to save the ptr 
2e58			 
2e58					; skip opcode 
2e58 23					inc hl  
2e59					; skip next ptr 
2e59 23					inc hl  
2e5a 23					inc hl 
2e5b					; skip len 
2e5b 23					inc hl 
2e5c			 
2e5c				if DEBUG_FORTH_WORDS 
2e5c					DMARK "LSc" 
2e5c f5				push af  
2e5d 3a 71 2e			ld a, (.dmark)  
2e60 32 6b fe			ld (debug_mark),a  
2e63 3a 72 2e			ld a, (.dmark+1)  
2e66 32 6c fe			ld (debug_mark+1),a  
2e69 3a 73 2e			ld a, (.dmark+2)  
2e6c 32 6d fe			ld (debug_mark+2),a  
2e6f 18 03			jr .pastdmark  
2e71 ..			.dmark: db "LSc"  
2e74 f1			.pastdmark: pop af  
2e75			endm  
# End of macro DMARK
2e75					CALLMONITOR 
2e75 cd 6f fe			call debug_vector  
2e78				endm  
# End of macro CALLMONITOR
2e78				endif 
2e78 cd 1c 14				call strcmp 
2e7b c2 f7 2d				jp nz, .ldouscanm 
2e7e				 
2e7e			 
2e7e			 
2e7e					; we have a uword so push its name to the stack 
2e7e			 
2e7e			;	   	push hl  ; save so we can move to next dict block 
2e7e e1			pop hl 
2e7f			 
2e7f				if DEBUG_FORTH_WORDS 
2e7f					DMARK "LSm" 
2e7f f5				push af  
2e80 3a 94 2e			ld a, (.dmark)  
2e83 32 6b fe			ld (debug_mark),a  
2e86 3a 95 2e			ld a, (.dmark+1)  
2e89 32 6c fe			ld (debug_mark+1),a  
2e8c 3a 96 2e			ld a, (.dmark+2)  
2e8f 32 6d fe			ld (debug_mark+2),a  
2e92 18 03			jr .pastdmark  
2e94 ..			.dmark: db "LSm"  
2e97 f1			.pastdmark: pop af  
2e98			endm  
# End of macro DMARK
2e98					CALLMONITOR 
2e98 cd 6f fe			call debug_vector  
2e9b				endm  
# End of macro CALLMONITOR
2e9b				endif 
2e9b			 
2e9b					; skip opcode 
2e9b 23					inc hl  
2e9c					; skip next ptr 
2e9c 23					inc hl  
2e9d 23					inc hl 
2e9e					; skip len 
2e9e 7e					ld a, (hl)   ; save length to add 
2e9f				if DEBUG_FORTH_WORDS 
2e9f					DMARK "LS2" 
2e9f f5				push af  
2ea0 3a b4 2e			ld a, (.dmark)  
2ea3 32 6b fe			ld (debug_mark),a  
2ea6 3a b5 2e			ld a, (.dmark+1)  
2ea9 32 6c fe			ld (debug_mark+1),a  
2eac 3a b6 2e			ld a, (.dmark+2)  
2eaf 32 6d fe			ld (debug_mark+2),a  
2eb2 18 03			jr .pastdmark  
2eb4 ..			.dmark: db "LS2"  
2eb7 f1			.pastdmark: pop af  
2eb8			endm  
# End of macro DMARK
2eb8					CALLMONITOR 
2eb8 cd 6f fe			call debug_vector  
2ebb				endm  
# End of macro CALLMONITOR
2ebb				endif 
2ebb			 
2ebb					; save this location 
2ebb				 
2ebb e5					push hl 
2ebc			 
2ebc 23					inc hl 
2ebd 11 c3 f1				ld de, scratch+2 
2ec0 4f					ld c, a 
2ec1 06 00				ld b, 0 
2ec3			 
2ec3				if DEBUG_FORTH_WORDS 
2ec3					DMARK "LSn" 
2ec3 f5				push af  
2ec4 3a d8 2e			ld a, (.dmark)  
2ec7 32 6b fe			ld (debug_mark),a  
2eca 3a d9 2e			ld a, (.dmark+1)  
2ecd 32 6c fe			ld (debug_mark+1),a  
2ed0 3a da 2e			ld a, (.dmark+2)  
2ed3 32 6d fe			ld (debug_mark+2),a  
2ed6 18 03			jr .pastdmark  
2ed8 ..			.dmark: db "LSn"  
2edb f1			.pastdmark: pop af  
2edc			endm  
# End of macro DMARK
2edc					CALLMONITOR 
2edc cd 6f fe			call debug_vector  
2edf				endm  
# End of macro CALLMONITOR
2edf				endif 
2edf			 
2edf					; copy uword name to scratch 
2edf			 
2edf ed b0				ldir 
2ee1			 
2ee1 1b					dec de 
2ee2 3e 20				ld a, ' '    ; change null to space 
2ee4 12					ld (de), a 
2ee5			 
2ee5 13					inc de 
2ee6			 
2ee6 d5					push de 
2ee7 c1					pop bc     ; move scratch pointer to end of word name and save it 
2ee8			 
2ee8 e1					pop hl 
2ee9 7e					ld a, (hl) 
2eea					;inc hl 
2eea					; skip word string 
2eea cd 86 0f				call addatohl 
2eed			 
2eed 23					inc hl 
2eee			 
2eee				if DEBUG_FORTH_WORDS 
2eee					DMARK "LS3" 
2eee f5				push af  
2eef 3a 03 2f			ld a, (.dmark)  
2ef2 32 6b fe			ld (debug_mark),a  
2ef5 3a 04 2f			ld a, (.dmark+1)  
2ef8 32 6c fe			ld (debug_mark+1),a  
2efb 3a 05 2f			ld a, (.dmark+2)  
2efe 32 6d fe			ld (debug_mark+2),a  
2f01 18 03			jr .pastdmark  
2f03 ..			.dmark: db "LS3"  
2f06 f1			.pastdmark: pop af  
2f07			endm  
# End of macro DMARK
2f07					CALLMONITOR 
2f07 cd 6f fe			call debug_vector  
2f0a				endm  
# End of macro CALLMONITOR
2f0a				endif 
2f0a					; should now be at the start of the machine code to setup the eval of the uword 
2f0a					; now locate the ptr to the string defintion 
2f0a			 
2f0a					; skip ld hl, 
2f0a					; then load the ptr 
2f0a			; TODO use get from hl ptr 
2f0a 23					inc hl 
2f0b 5e					ld e, (hl) 
2f0c 23					inc hl 
2f0d 56					ld d, (hl) 
2f0e eb					ex de, hl 
2f0f			 
2f0f			 
2f0f				if DEBUG_FORTH_WORDS 
2f0f					DMARK "LSt" 
2f0f f5				push af  
2f10 3a 24 2f			ld a, (.dmark)  
2f13 32 6b fe			ld (debug_mark),a  
2f16 3a 25 2f			ld a, (.dmark+1)  
2f19 32 6c fe			ld (debug_mark+1),a  
2f1c 3a 26 2f			ld a, (.dmark+2)  
2f1f 32 6d fe			ld (debug_mark+2),a  
2f22 18 03			jr .pastdmark  
2f24 ..			.dmark: db "LSt"  
2f27 f1			.pastdmark: pop af  
2f28			endm  
# End of macro DMARK
2f28					CALLMONITOR 
2f28 cd 6f fe			call debug_vector  
2f2b				endm  
# End of macro CALLMONITOR
2f2b				endif 
2f2b			 
2f2b			; cant push right now due to tokenised strings  
2f2b			 
2f2b			; get the destination of where to copy this definition to. 
2f2b			 
2f2b c5					push bc 
2f2c d1					pop de 
2f2d			 
2f2d 7e			.listl:         ld a,(hl) 
2f2e fe 00				cp 0 
2f30 28 09				jr z, .lreplsp     ; replace zero with space 
2f32					;cp FORTH_END_BUFFER 
2f32 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2f34 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2f36				 
2f36					; just copy this char as is then 
2f36			 
2f36 12					ld (de), a 
2f37			 
2f37 23			.listnxt:	inc hl 
2f38 13					inc de 
2f39 18 f2				jr .listl 
2f3b			 
2f3b 3e 20		.lreplsp:	ld a,' ' 
2f3d 12					ld (de), a 
2f3e 18 f7				jr .listnxt 
2f40			 
2f40			; close up uword def 
2f40			 
2f40			.listdone: 
2f40 12					ld (de), a 
2f41 13					inc de 
2f42 3e 00				ld a, 0 
2f44 12					ld (de), a 
2f45			 
2f45			; now have def so clean up and push to stack 
2f45			 
2f45 21 c1 f1				ld hl, scratch 
2f48				if DEBUG_FORTH_WORDS 
2f48					DMARK "Ltp" 
2f48 f5				push af  
2f49 3a 5d 2f			ld a, (.dmark)  
2f4c 32 6b fe			ld (debug_mark),a  
2f4f 3a 5e 2f			ld a, (.dmark+1)  
2f52 32 6c fe			ld (debug_mark+1),a  
2f55 3a 5f 2f			ld a, (.dmark+2)  
2f58 32 6d fe			ld (debug_mark+2),a  
2f5b 18 03			jr .pastdmark  
2f5d ..			.dmark: db "Ltp"  
2f60 f1			.pastdmark: pop af  
2f61			endm  
# End of macro DMARK
2f61					CALLMONITOR 
2f61 cd 6f fe			call debug_vector  
2f64				endm  
# End of macro CALLMONITOR
2f64				endif 
2f64			 
2f64 18 1f			jr .listpush 
2f66			 
2f66			;.lnuword:	pop hl 
2f66			;		call forth_tok_next 
2f66			;		jp .ldouscan  
2f66			 
2f66			.lunotfound:		  
2f66			 
2f66				if DEBUG_FORTH_WORDS 
2f66					DMARK "LSn" 
2f66 f5				push af  
2f67 3a 7b 2f			ld a, (.dmark)  
2f6a 32 6b fe			ld (debug_mark),a  
2f6d 3a 7c 2f			ld a, (.dmark+1)  
2f70 32 6c fe			ld (debug_mark+1),a  
2f73 3a 7d 2f			ld a, (.dmark+2)  
2f76 32 6d fe			ld (debug_mark+2),a  
2f79 18 03			jr .pastdmark  
2f7b ..			.dmark: db "LSn"  
2f7e f1			.pastdmark: pop af  
2f7f			endm  
# End of macro DMARK
2f7f					CALLMONITOR 
2f7f cd 6f fe			call debug_vector  
2f82				endm  
# End of macro CALLMONITOR
2f82				endif 
2f82			 
2f82					 
2f82			;		FORTH_DSP_POP 
2f82			;		ld hl, .luno 
2f82			 
2f82					NEXTW			 
2f82 c3 6f 24			jp macro_next 
2f85				endm 
# End of macro NEXTW
2f85			 
2f85			.listpush: 
2f85				if DEBUG_FORTH_WORDS 
2f85					DMARK "LS>" 
2f85 f5				push af  
2f86 3a 9a 2f			ld a, (.dmark)  
2f89 32 6b fe			ld (debug_mark),a  
2f8c 3a 9b 2f			ld a, (.dmark+1)  
2f8f 32 6c fe			ld (debug_mark+1),a  
2f92 3a 9c 2f			ld a, (.dmark+2)  
2f95 32 6d fe			ld (debug_mark+2),a  
2f98 18 03			jr .pastdmark  
2f9a ..			.dmark: db "LS>"  
2f9d f1			.pastdmark: pop af  
2f9e			endm  
# End of macro DMARK
2f9e					CALLMONITOR 
2f9e cd 6f fe			call debug_vector  
2fa1				endm  
# End of macro CALLMONITOR
2fa1				endif 
2fa1 cd 30 21				call forth_push_str 
2fa4			 
2fa4			 
2fa4			 
2fa4					NEXTW 
2fa4 c3 6f 24			jp macro_next 
2fa7				endm 
# End of macro NEXTW
2fa7			 
2fa7			;.luno:    db "Word not found",0 
2fa7			 
2fa7			 
2fa7			 
2fa7			 
2fa7			 
2fa7			;		push hl   ; save pointer to start of uword def string 
2fa7			; 
2fa7			;; look for FORTH_EOL_LINE 
2fa7			;		ld a, FORTH_END_BUFFER 
2fa7			;		call strlent 
2fa7			; 
2fa7			;		inc hl		 ; space for coln def 
2fa7			;		inc hl 
2fa7			;		inc hl          ; space for terms 
2fa7			;		inc hl 
2fa7			; 
2fa7			;		ld a, 20   ; TODO get actual length 
2fa7			;		call addatohl    ; include a random amount of room for the uword name 
2fa7			; 
2fa7			;		 
2fa7			;	if DEBUG_FORTH_WORDS 
2fa7			;		DMARK "Lt1" 
2fa7			;		CALLMONITOR 
2fa7			;	endif 
2fa7			;		 
2fa7			; 
2fa7			;; malloc space for the string because we cant change it 
2fa7			; 
2fa7			;		call malloc 
2fa7			;	if DEBUG_FORTH_MALLOC_GUARD 
2fa7			;		push af 
2fa7			;		call ishlzero 
2fa7			;		pop af 
2fa7			;		 
2fa7			;		call z,malloc_error 
2fa7			;	endif 
2fa7			; 
2fa7			;	if DEBUG_FORTH_WORDS 
2fa7			;		DMARK "Lt2" 
2fa7			;		CALLMONITOR 
2fa7			;	endif 
2fa7			;		pop de 
2fa7			;		push hl    ; push the malloc to release later 
2fa7			;		push hl   ;  push back a copy for the later stack push 
2fa7			;		 
2fa7			;; copy the string swapping out the zero terms for spaces 
2fa7			; 
2fa7			;		; de has our source 
2fa7			;		; hl has our dest 
2fa7			; 
2fa7			;; add the coln def 
2fa7			; 
2fa7			;		ld a, ':' 
2fa7			;		ld (hl), a 
2fa7			;		inc hl 
2fa7			;		ld a, ' ' 
2fa7			;		ld (hl), a 
2fa7			;		inc hl 
2fa7			; 
2fa7			;; add the uname word 
2fa7			;		push de   ; save our string for now 
2fa7			;		ex de, hl 
2fa7			; 
2fa7			;		FORTH_DSP_VALUE 
2fa7			;		;v5 FORTH_DSP_VALUE 
2fa7			; 
2fa7			;		inc hl   ; skip type but we know by now this is OK 
2fa7			; 
2fa7			;.luword:	ld a,(hl) 
2fa7			;		cp 0 
2fa7			;		jr z, .luword2 
2fa7			;		ld (de), a 
2fa7			;		inc de 
2fa7			;		inc hl 
2fa7			;		jr .luword 
2fa7			; 
2fa7			;.luword2:	ld a, ' ' 
2fa7			;		ld (de), a 
2fa7			;;		inc hl 
2fa7			;;		inc de 
2fa7			;;		ld (de), a 
2fa7			;;		inc hl 
2fa7			;		inc de 
2fa7			; 
2fa7			;		ex de, hl 
2fa7			;		pop de 
2fa7			;		 
2fa7			;		 
2fa7			; 
2fa7			;; detoken that string and copy it 
2fa7			; 
2fa7			;	if DEBUG_FORTH_WORDS 
2fa7			;		DMARK "Lt2" 
2fa7			;		CALLMONITOR 
2fa7			;	endif 
2fa7			;.ldetok:	ld a, (de) 
2fa7			;		cp FORTH_END_BUFFER 
2fa7			;		jr z, .ldetokend 
2fa7			;		; swap out any zero term for space 
2fa7			;		cp 0 
2fa7			;		jr nz, .ldetoknext 
2fa7			;		ld a, ' ' 
2fa7			; 
2fa7			;	if DEBUG_FORTH_WORDS 
2fa7			;		DMARK "LtS" 
2fa7			;		CALLMONITOR 
2fa7			;	endif 
2fa7			;.ldetoknext:	ld (hl), a 
2fa7			;		inc de 
2fa7			;		inc hl 
2fa7			;		jr .ldetok 
2fa7			; 
2fa7			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2fa7			;		ld (hl), a  
2fa7			; 
2fa7			;; free that temp malloc 
2fa7			; 
2fa7			;		pop hl    
2fa7			; 
2fa7			;	if DEBUG_FORTH_WORDS 
2fa7			;		DMARK "Lt4" 
2fa7			;		CALLMONITOR 
2fa7			;	endif 
2fa7			;		call forth_apushstrhl 
2fa7			; 
2fa7			;		; get rid of temp malloc area 
2fa7			; 
2fa7			;		pop hl 
2fa7			;		call free 
2fa7			; 
2fa7			;		jr .ludone 
2fa7			; 
2fa7			;.lnuword:	pop hl 
2fa7			;		call forth_tok_next 
2fa7			;		jp .ldouscan  
2fa7			; 
2fa7			;.ludone:		 pop hl 
2fa7			; 
2fa7					NEXTW 
2fa7 c3 6f 24			jp macro_next 
2faa				endm 
# End of macro NEXTW
2faa			 
2faa			.FORGET: 
2faa				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2faa 5d				db WORD_SYS_CORE+73             
2fab 23 30			dw .NOP            
2fad 07				db 6 + 1 
2fae .. 00			db "FORGET",0              
2fb5				endm 
# End of macro CWHEAD
2fb5			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2fb5			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2fb5			; | |  
2fb5			; | | e.g. "MORE" forget 
2fb5					if DEBUG_FORTH_WORDS_KEY 
2fb5						DMARK "FRG" 
2fb5 f5				push af  
2fb6 3a ca 2f			ld a, (.dmark)  
2fb9 32 6b fe			ld (debug_mark),a  
2fbc 3a cb 2f			ld a, (.dmark+1)  
2fbf 32 6c fe			ld (debug_mark+1),a  
2fc2 3a cc 2f			ld a, (.dmark+2)  
2fc5 32 6d fe			ld (debug_mark+2),a  
2fc8 18 03			jr .pastdmark  
2fca ..			.dmark: db "FRG"  
2fcd f1			.pastdmark: pop af  
2fce			endm  
# End of macro DMARK
2fce						CALLMONITOR 
2fce cd 6f fe			call debug_vector  
2fd1				endm  
# End of macro CALLMONITOR
2fd1					endif 
2fd1			 
2fd1				; find uword 
2fd1			        ; update start of word with "_" 
2fd1				; replace uword with deleted flag 
2fd1			 
2fd1			 
2fd1			;	if DEBUG_FORTH_WORDS 
2fd1			;		DMARK "FOG" 
2fd1			;		CALLMONITOR 
2fd1			;	endif 
2fd1			 
2fd1			 
2fd1					; Get ptr to the word we need to look up 
2fd1			 
2fd1					FORTH_DSP_VALUEHL 
2fd1 cd b9 22			call macro_dsp_valuehl 
2fd4				endm 
# End of macro FORTH_DSP_VALUEHL
2fd4					;v5 FORTH_DSP_VALUE 
2fd4				; TODO type check 
2fd4			;		inc hl    ; Skip type check  
2fd4 e5					push hl 
2fd5 c1					pop bc 
2fd6			;		ex de, hl    ; put into DE 
2fd6			 
2fd6			 
2fd6 21 00 80				ld hl, baseram 
2fd9					;ld hl, baseusermem 
2fd9			 
2fd9				; skip dict stub 
2fd9			;	call forth_tok_next 
2fd9 e5			push hl   ; sacreifical push 
2fda			 
2fda			.fldouscanm: 
2fda e1				pop hl 
2fdb			.fldouscan: 
2fdb			;	if DEBUG_FORTH_WORDS 
2fdb			;		DMARK "LSs" 
2fdb			;		CALLMONITOR 
2fdb			;	endif 
2fdb				; skip dict stub 
2fdb cd c0 25				call forth_tok_next 
2fde			 
2fde			 
2fde			; while we have words to look for 
2fde			 
2fde 7e				ld a, (hl)      
2fdf			;	if DEBUG_FORTH_WORDS 
2fdf			;		DMARK "LSk" 
2fdf			;		CALLMONITOR 
2fdf			;	endif 
2fdf fe 00				cp WORD_SYS_END 
2fe1 ca 1d 30				jp z, .flunotfound 
2fe4 fe 01				cp WORD_SYS_UWORD 
2fe6 c2 db 2f				jp nz, .fldouscan 
2fe9			 
2fe9			;	if DEBUG_FORTH_WORDS 
2fe9			;		DMARK "LSu" 
2fe9			;		CALLMONITOR 
2fe9			;	endif 
2fe9			 
2fe9					; found a uword but is it the one we want... 
2fe9			 
2fe9 c5					push bc     ; uword to find is on bc 
2fea d1					pop de 
2feb			 
2feb e5					push hl  ; to save the ptr 
2fec			 
2fec					; skip opcode 
2fec 23					inc hl  
2fed					; skip next ptr 
2fed 23					inc hl  
2fee 23					inc hl 
2fef					; skip len 
2fef 23					inc hl 
2ff0			 
2ff0			;	if DEBUG_FORTH_WORDS 
2ff0			;		DMARK "LSc" 
2ff0			;		CALLMONITOR 
2ff0			;	endif 
2ff0 cd 1c 14				call strcmp 
2ff3 c2 da 2f				jp nz, .fldouscanm 
2ff6			; 
2ff6			; 
2ff6			;; while we have words to look for 
2ff6			; 
2ff6			;.fdouscan:	ld a, (hl)      
2ff6			;	if DEBUG_FORTH_WORDS 
2ff6			;		DMARK "LSs" 
2ff6			;		CALLMONITOR 
2ff6			;	endif 
2ff6			;		cp WORD_SYS_END 
2ff6			;		jp z, .fudone 
2ff6			;		cp WORD_SYS_UWORD 
2ff6			;		jp nz, .fnuword 
2ff6			; 
2ff6			;	if DEBUG_FORTH_WORDS 
2ff6			;		DMARK "FGu" 
2ff6			;		CALLMONITOR 
2ff6			;	endif 
2ff6			; 
2ff6			;		; found a uword but is it the one we want... 
2ff6			; 
2ff6			; 
2ff6			;	        pop de   ; get back the dsp name 
2ff6			;		push de 
2ff6			; 
2ff6			;		push hl  ; to save the ptr 
2ff6			; 
2ff6			;		; skip opcode 
2ff6			;		inc hl  
2ff6			;		; skip next ptr 
2ff6			;		inc hl  
2ff6			;		inc hl 
2ff6			;		; skip len 
2ff6			;		inc hl 
2ff6			; 
2ff6			;	if DEBUG_FORTH_WORDS 
2ff6			;		DMARK "FGc" 
2ff6			;		CALLMONITOR 
2ff6			;	endif 
2ff6			;		call strcmp 
2ff6			;		jp nz, .fnuword 
2ff6			 
2ff6			 
2ff6 e1			pop hl 
2ff7			 
2ff7				 
2ff7				if DEBUG_FORTH_WORDS 
2ff7					DMARK "FGm" 
2ff7 f5				push af  
2ff8 3a 0c 30			ld a, (.dmark)  
2ffb 32 6b fe			ld (debug_mark),a  
2ffe 3a 0d 30			ld a, (.dmark+1)  
3001 32 6c fe			ld (debug_mark+1),a  
3004 3a 0e 30			ld a, (.dmark+2)  
3007 32 6d fe			ld (debug_mark+2),a  
300a 18 03			jr .pastdmark  
300c ..			.dmark: db "FGm"  
300f f1			.pastdmark: pop af  
3010			endm  
# End of macro DMARK
3010					CALLMONITOR 
3010 cd 6f fe			call debug_vector  
3013				endm  
# End of macro CALLMONITOR
3013				endif 
3013			 
3013			 
3013			 
3013					; we have a uword so push its name to the stack 
3013			 
3013			;	   	push hl  ; save so we can move to next dict block 
3013			;pop hl 
3013			 
3013					; update opcode to deleted 
3013 3e 03				ld a, WORD_SYS_DELETED 
3015 77					ld (hl), a 
3016			 
3016 23					inc hl  
3017					; skip next ptr 
3017 23					inc hl  
3018 23					inc hl 
3019					; skip len 
3019 23					inc hl 
301a			 
301a					; TODO change parser to skip deleted words but for now mark it out 
301a 3e 5f				ld a, "_" 
301c 77					ld  (hl),a 
301d			 
301d			;		jr .fudone 
301d			; 
301d			;.fnuword:	pop hl 
301d			;		call forth_tok_next 
301d			;		jp .fdouscan  
301d			 
301d			.flunotfound:		  
301d			 
301d			 
301d					 
301d					FORTH_DSP_POP 
301d cd 71 23			call macro_forth_dsp_pop 
3020				endm 
# End of macro FORTH_DSP_POP
3020			;		ld hl, .luno 
3020			;.fudone:		 pop hl 
3020					NEXTW 
3020 c3 6f 24			jp macro_next 
3023				endm 
# End of macro NEXTW
3023			.NOP: 
3023				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
3023 61				db WORD_SYS_CORE+77             
3024 4a 30			dw .COMO            
3026 04				db 3 + 1 
3027 .. 00			db "NOP",0              
302b				endm 
# End of macro CWHEAD
302b			; | NOP (  --  ) Do nothing | DONE 
302b					if DEBUG_FORTH_WORDS_KEY 
302b						DMARK "NOP" 
302b f5				push af  
302c 3a 40 30			ld a, (.dmark)  
302f 32 6b fe			ld (debug_mark),a  
3032 3a 41 30			ld a, (.dmark+1)  
3035 32 6c fe			ld (debug_mark+1),a  
3038 3a 42 30			ld a, (.dmark+2)  
303b 32 6d fe			ld (debug_mark+2),a  
303e 18 03			jr .pastdmark  
3040 ..			.dmark: db "NOP"  
3043 f1			.pastdmark: pop af  
3044			endm  
# End of macro DMARK
3044						CALLMONITOR 
3044 cd 6f fe			call debug_vector  
3047				endm  
# End of macro CALLMONITOR
3047					endif 
3047				       NEXTW 
3047 c3 6f 24			jp macro_next 
304a				endm 
# End of macro NEXTW
304a			.COMO: 
304a				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
304a 6e				db WORD_SYS_CORE+90             
304b 9c 30			dw .COMC            
304d 02				db 1 + 1 
304e .. 00			db "(",0              
3050				endm 
# End of macro CWHEAD
3050			; | ( ( -- )  Start of comment | DONE 
3050			 
3050			 
3050 2a c2 f4				ld hl, ( os_tok_ptr) 
3053 11 97 30			ld de, .closepar 
3056					 
3056					if DEBUG_FORTH_WORDS 
3056						DMARK ").." 
3056 f5				push af  
3057 3a 6b 30			ld a, (.dmark)  
305a 32 6b fe			ld (debug_mark),a  
305d 3a 6c 30			ld a, (.dmark+1)  
3060 32 6c fe			ld (debug_mark+1),a  
3063 3a 6d 30			ld a, (.dmark+2)  
3066 32 6d fe			ld (debug_mark+2),a  
3069 18 03			jr .pastdmark  
306b ..			.dmark: db ").."  
306e f1			.pastdmark: pop af  
306f			endm  
# End of macro DMARK
306f						CALLMONITOR 
306f cd 6f fe			call debug_vector  
3072				endm  
# End of macro CALLMONITOR
3072					endif 
3072 cd 8a 25			call findnexttok  
3075			 
3075					if DEBUG_FORTH_WORDS 
3075						DMARK "IF5" 
3075 f5				push af  
3076 3a 8a 30			ld a, (.dmark)  
3079 32 6b fe			ld (debug_mark),a  
307c 3a 8b 30			ld a, (.dmark+1)  
307f 32 6c fe			ld (debug_mark+1),a  
3082 3a 8c 30			ld a, (.dmark+2)  
3085 32 6d fe			ld (debug_mark+2),a  
3088 18 03			jr .pastdmark  
308a ..			.dmark: db "IF5"  
308d f1			.pastdmark: pop af  
308e			endm  
# End of macro DMARK
308e						CALLMONITOR 
308e cd 6f fe			call debug_vector  
3091				endm  
# End of macro CALLMONITOR
3091					endif 
3091				; replace below with ) exec using tok_ptr 
3091 22 c2 f4			ld (os_tok_ptr), hl 
3094 c3 00 25			jp exec1 
3097			 
3097 .. 00			.closepar:   db ")",0 
3099			 
3099				       NEXTW 
3099 c3 6f 24			jp macro_next 
309c				endm 
# End of macro NEXTW
309c			.COMC: 
309c				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
309c 6f				db WORD_SYS_CORE+91             
309d a5 30			dw .SCRATCH            
309f 02				db 1 + 1 
30a0 .. 00			db ")",0              
30a2				endm 
# End of macro CWHEAD
30a2			; | ) ( -- )  End of comment |  DONE  
30a2				       NEXTW 
30a2 c3 6f 24			jp macro_next 
30a5				endm 
# End of macro NEXTW
30a5			 
30a5			.SCRATCH: 
30a5				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
30a5 6f				db WORD_SYS_CORE+91             
30a6 e0 30			dw .INC            
30a8 08				db 7 + 1 
30a9 .. 00			db "SCRATCH",0              
30b1				endm 
# End of macro CWHEAD
30b1			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
30b1			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
30b1			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
30b1			; | |  
30b1			; | | e.g.    : score $00 scratch ; 
30b1			; | |  
30b1			; | | $00 score ! 
30b1			; | | $01 score +! 
30b1			; | |  
30b1			; | | e.g.   : varword $0a scratch ;  
30b1			; | | 
30b1			; | | $8000 varword ! 
30b1					if DEBUG_FORTH_WORDS_KEY 
30b1						DMARK "SCR" 
30b1 f5				push af  
30b2 3a c6 30			ld a, (.dmark)  
30b5 32 6b fe			ld (debug_mark),a  
30b8 3a c7 30			ld a, (.dmark+1)  
30bb 32 6c fe			ld (debug_mark+1),a  
30be 3a c8 30			ld a, (.dmark+2)  
30c1 32 6d fe			ld (debug_mark+2),a  
30c4 18 03			jr .pastdmark  
30c6 ..			.dmark: db "SCR"  
30c9 f1			.pastdmark: pop af  
30ca			endm  
# End of macro DMARK
30ca						CALLMONITOR 
30ca cd 6f fe			call debug_vector  
30cd				endm  
# End of macro CALLMONITOR
30cd					endif 
30cd			 
30cd					FORTH_DSP_VALUEHL 
30cd cd b9 22			call macro_dsp_valuehl 
30d0				endm 
# End of macro FORTH_DSP_VALUEHL
30d0				 
30d0					FORTH_DSP_POP 
30d0 cd 71 23			call macro_forth_dsp_pop 
30d3				endm 
# End of macro FORTH_DSP_POP
30d3			 
30d3 7d					ld a, l 
30d4 21 e6 f6				ld hl, os_var_array 
30d7 cd 86 0f				call addatohl 
30da			 
30da cd c2 20				call forth_push_numhl 
30dd			 
30dd				       NEXTW 
30dd c3 6f 24			jp macro_next 
30e0				endm 
# End of macro NEXTW
30e0			 
30e0			.INC: 
30e0				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
30e0 6f				db WORD_SYS_CORE+91             
30e1 34 31			dw .DEC            
30e3 03				db 2 + 1 
30e4 .. 00			db "+!",0              
30e7				endm 
# End of macro CWHEAD
30e7			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
30e7					if DEBUG_FORTH_WORDS_KEY 
30e7						DMARK "+s_" 
30e7 f5				push af  
30e8 3a fc 30			ld a, (.dmark)  
30eb 32 6b fe			ld (debug_mark),a  
30ee 3a fd 30			ld a, (.dmark+1)  
30f1 32 6c fe			ld (debug_mark+1),a  
30f4 3a fe 30			ld a, (.dmark+2)  
30f7 32 6d fe			ld (debug_mark+2),a  
30fa 18 03			jr .pastdmark  
30fc ..			.dmark: db "+s_"  
30ff f1			.pastdmark: pop af  
3100			endm  
# End of macro DMARK
3100						CALLMONITOR 
3100 cd 6f fe			call debug_vector  
3103				endm  
# End of macro CALLMONITOR
3103					endif 
3103			 
3103					FORTH_DSP_VALUEHL 
3103 cd b9 22			call macro_dsp_valuehl 
3106				endm 
# End of macro FORTH_DSP_VALUEHL
3106			 
3106 e5					push hl   ; save address 
3107			 
3107					FORTH_DSP_POP 
3107 cd 71 23			call macro_forth_dsp_pop 
310a				endm 
# End of macro FORTH_DSP_POP
310a			 
310a					FORTH_DSP_VALUEHL 
310a cd b9 22			call macro_dsp_valuehl 
310d				endm 
# End of macro FORTH_DSP_VALUEHL
310d			 
310d					FORTH_DSP_POP 
310d cd 71 23			call macro_forth_dsp_pop 
3110				endm 
# End of macro FORTH_DSP_POP
3110			 
3110					; hl contains value to add to byte at a 
3110				 
3110 eb					ex de, hl 
3111			 
3111 e1					pop hl 
3112			 
3112					if DEBUG_FORTH_WORDS 
3112						DMARK "INC" 
3112 f5				push af  
3113 3a 27 31			ld a, (.dmark)  
3116 32 6b fe			ld (debug_mark),a  
3119 3a 28 31			ld a, (.dmark+1)  
311c 32 6c fe			ld (debug_mark+1),a  
311f 3a 29 31			ld a, (.dmark+2)  
3122 32 6d fe			ld (debug_mark+2),a  
3125 18 03			jr .pastdmark  
3127 ..			.dmark: db "INC"  
312a f1			.pastdmark: pop af  
312b			endm  
# End of macro DMARK
312b						CALLMONITOR 
312b cd 6f fe			call debug_vector  
312e				endm  
# End of macro CALLMONITOR
312e					endif 
312e			 
312e 7e					ld a,(hl) 
312f 83					add e 
3130 77					ld (hl),a 
3131			 
3131			 
3131			 
3131				       NEXTW 
3131 c3 6f 24			jp macro_next 
3134				endm 
# End of macro NEXTW
3134			 
3134			.DEC: 
3134				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
3134 6f				db WORD_SYS_CORE+91             
3135 85 31			dw .INC2            
3137 03				db 2 + 1 
3138 .. 00			db "-!",0              
313b				endm 
# End of macro CWHEAD
313b			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
313b					if DEBUG_FORTH_WORDS_KEY 
313b						DMARK "-s_" 
313b f5				push af  
313c 3a 50 31			ld a, (.dmark)  
313f 32 6b fe			ld (debug_mark),a  
3142 3a 51 31			ld a, (.dmark+1)  
3145 32 6c fe			ld (debug_mark+1),a  
3148 3a 52 31			ld a, (.dmark+2)  
314b 32 6d fe			ld (debug_mark+2),a  
314e 18 03			jr .pastdmark  
3150 ..			.dmark: db "-s_"  
3153 f1			.pastdmark: pop af  
3154			endm  
# End of macro DMARK
3154						CALLMONITOR 
3154 cd 6f fe			call debug_vector  
3157				endm  
# End of macro CALLMONITOR
3157					endif 
3157			 
3157					FORTH_DSP_VALUEHL 
3157 cd b9 22			call macro_dsp_valuehl 
315a				endm 
# End of macro FORTH_DSP_VALUEHL
315a			 
315a e5					push hl   ; save address 
315b			 
315b					FORTH_DSP_POP 
315b cd 71 23			call macro_forth_dsp_pop 
315e				endm 
# End of macro FORTH_DSP_POP
315e			 
315e					FORTH_DSP_VALUEHL 
315e cd b9 22			call macro_dsp_valuehl 
3161				endm 
# End of macro FORTH_DSP_VALUEHL
3161			 
3161					; hl contains value to add to byte at a 
3161				 
3161 eb					ex de, hl 
3162			 
3162 e1					pop hl 
3163			 
3163					if DEBUG_FORTH_WORDS 
3163						DMARK "DEC" 
3163 f5				push af  
3164 3a 78 31			ld a, (.dmark)  
3167 32 6b fe			ld (debug_mark),a  
316a 3a 79 31			ld a, (.dmark+1)  
316d 32 6c fe			ld (debug_mark+1),a  
3170 3a 7a 31			ld a, (.dmark+2)  
3173 32 6d fe			ld (debug_mark+2),a  
3176 18 03			jr .pastdmark  
3178 ..			.dmark: db "DEC"  
317b f1			.pastdmark: pop af  
317c			endm  
# End of macro DMARK
317c						CALLMONITOR 
317c cd 6f fe			call debug_vector  
317f				endm  
# End of macro CALLMONITOR
317f					endif 
317f			 
317f 7e					ld a,(hl) 
3180 93					sub e 
3181 77					ld (hl),a 
3182			 
3182			 
3182			 
3182				       NEXTW 
3182 c3 6f 24			jp macro_next 
3185				endm 
# End of macro NEXTW
3185			 
3185			.INC2: 
3185				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
3185 6f				db WORD_SYS_CORE+91             
3186 2f 32			dw .DEC2            
3188 04				db 3 + 1 
3189 .. 00			db "+2!",0              
318d				endm 
# End of macro CWHEAD
318d			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
318d			 
318d					if DEBUG_FORTH_WORDS_KEY 
318d						DMARK "+2s" 
318d f5				push af  
318e 3a a2 31			ld a, (.dmark)  
3191 32 6b fe			ld (debug_mark),a  
3194 3a a3 31			ld a, (.dmark+1)  
3197 32 6c fe			ld (debug_mark+1),a  
319a 3a a4 31			ld a, (.dmark+2)  
319d 32 6d fe			ld (debug_mark+2),a  
31a0 18 03			jr .pastdmark  
31a2 ..			.dmark: db "+2s"  
31a5 f1			.pastdmark: pop af  
31a6			endm  
# End of macro DMARK
31a6						CALLMONITOR 
31a6 cd 6f fe			call debug_vector  
31a9				endm  
# End of macro CALLMONITOR
31a9					endif 
31a9			 
31a9					; Address 
31a9			 
31a9					FORTH_DSP_VALUEHL 
31a9 cd b9 22			call macro_dsp_valuehl 
31ac				endm 
# End of macro FORTH_DSP_VALUEHL
31ac			 
31ac e5					push hl    ; save address 
31ad			 
31ad					; load content into de 
31ad			 
31ad 5e					ld e,(hl) 
31ae 23					inc hl 
31af 56					ld d, (hl) 
31b0			 
31b0					if DEBUG_FORTH_WORDS 
31b0						DMARK "+2a" 
31b0 f5				push af  
31b1 3a c5 31			ld a, (.dmark)  
31b4 32 6b fe			ld (debug_mark),a  
31b7 3a c6 31			ld a, (.dmark+1)  
31ba 32 6c fe			ld (debug_mark+1),a  
31bd 3a c7 31			ld a, (.dmark+2)  
31c0 32 6d fe			ld (debug_mark+2),a  
31c3 18 03			jr .pastdmark  
31c5 ..			.dmark: db "+2a"  
31c8 f1			.pastdmark: pop af  
31c9			endm  
# End of macro DMARK
31c9						CALLMONITOR 
31c9 cd 6f fe			call debug_vector  
31cc				endm  
# End of macro CALLMONITOR
31cc					endif 
31cc			 
31cc					FORTH_DSP_POP 
31cc cd 71 23			call macro_forth_dsp_pop 
31cf				endm 
# End of macro FORTH_DSP_POP
31cf			 
31cf					; Get value to add 
31cf			 
31cf					FORTH_DSP_VALUE 
31cf cd a2 22			call macro_forth_dsp_value 
31d2				endm 
# End of macro FORTH_DSP_VALUE
31d2			 
31d2					if DEBUG_FORTH_WORDS 
31d2						DMARK "+2v" 
31d2 f5				push af  
31d3 3a e7 31			ld a, (.dmark)  
31d6 32 6b fe			ld (debug_mark),a  
31d9 3a e8 31			ld a, (.dmark+1)  
31dc 32 6c fe			ld (debug_mark+1),a  
31df 3a e9 31			ld a, (.dmark+2)  
31e2 32 6d fe			ld (debug_mark+2),a  
31e5 18 03			jr .pastdmark  
31e7 ..			.dmark: db "+2v"  
31ea f1			.pastdmark: pop af  
31eb			endm  
# End of macro DMARK
31eb						CALLMONITOR 
31eb cd 6f fe			call debug_vector  
31ee				endm  
# End of macro CALLMONITOR
31ee					endif 
31ee			 
31ee 19					add hl, de 
31ef			 
31ef					if DEBUG_FORTH_WORDS 
31ef						DMARK "+2+" 
31ef f5				push af  
31f0 3a 04 32			ld a, (.dmark)  
31f3 32 6b fe			ld (debug_mark),a  
31f6 3a 05 32			ld a, (.dmark+1)  
31f9 32 6c fe			ld (debug_mark+1),a  
31fc 3a 06 32			ld a, (.dmark+2)  
31ff 32 6d fe			ld (debug_mark+2),a  
3202 18 03			jr .pastdmark  
3204 ..			.dmark: db "+2+"  
3207 f1			.pastdmark: pop af  
3208			endm  
# End of macro DMARK
3208						CALLMONITOR 
3208 cd 6f fe			call debug_vector  
320b				endm  
# End of macro CALLMONITOR
320b					endif 
320b			 
320b					; move result to de 
320b			 
320b eb					ex de, hl 
320c			 
320c					; Address 
320c			 
320c e1					pop hl 
320d			 
320d					; save it back 
320d			 
320d 73					ld (hl), e 
320e 23					inc hl 
320f 72					ld (hl), d 
3210			 
3210					if DEBUG_FORTH_WORDS 
3210						DMARK "+2e" 
3210 f5				push af  
3211 3a 25 32			ld a, (.dmark)  
3214 32 6b fe			ld (debug_mark),a  
3217 3a 26 32			ld a, (.dmark+1)  
321a 32 6c fe			ld (debug_mark+1),a  
321d 3a 27 32			ld a, (.dmark+2)  
3220 32 6d fe			ld (debug_mark+2),a  
3223 18 03			jr .pastdmark  
3225 ..			.dmark: db "+2e"  
3228 f1			.pastdmark: pop af  
3229			endm  
# End of macro DMARK
3229						CALLMONITOR 
3229 cd 6f fe			call debug_vector  
322c				endm  
# End of macro CALLMONITOR
322c					endif 
322c			 
322c			 
322c			 
322c			 
322c			 
322c				       NEXTW 
322c c3 6f 24			jp macro_next 
322f				endm 
# End of macro NEXTW
322f			 
322f			.DEC2: 
322f				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
322f 6f				db WORD_SYS_CORE+91             
3230 db 32			dw .GET2            
3232 04				db 3 + 1 
3233 .. 00			db "-2!",0              
3237				endm 
# End of macro CWHEAD
3237			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
3237			 
3237			 
3237					if DEBUG_FORTH_WORDS_KEY 
3237						DMARK "-2s" 
3237 f5				push af  
3238 3a 4c 32			ld a, (.dmark)  
323b 32 6b fe			ld (debug_mark),a  
323e 3a 4d 32			ld a, (.dmark+1)  
3241 32 6c fe			ld (debug_mark+1),a  
3244 3a 4e 32			ld a, (.dmark+2)  
3247 32 6d fe			ld (debug_mark+2),a  
324a 18 03			jr .pastdmark  
324c ..			.dmark: db "-2s"  
324f f1			.pastdmark: pop af  
3250			endm  
# End of macro DMARK
3250						CALLMONITOR 
3250 cd 6f fe			call debug_vector  
3253				endm  
# End of macro CALLMONITOR
3253					endif 
3253			 
3253					; Address 
3253			 
3253					FORTH_DSP_VALUEHL 
3253 cd b9 22			call macro_dsp_valuehl 
3256				endm 
# End of macro FORTH_DSP_VALUEHL
3256			 
3256 e5					push hl    ; save address 
3257			 
3257					; load content into de 
3257			 
3257 5e					ld e,(hl) 
3258 23					inc hl 
3259 56					ld d, (hl) 
325a			 
325a					if DEBUG_FORTH_WORDS 
325a						DMARK "-2a" 
325a f5				push af  
325b 3a 6f 32			ld a, (.dmark)  
325e 32 6b fe			ld (debug_mark),a  
3261 3a 70 32			ld a, (.dmark+1)  
3264 32 6c fe			ld (debug_mark+1),a  
3267 3a 71 32			ld a, (.dmark+2)  
326a 32 6d fe			ld (debug_mark+2),a  
326d 18 03			jr .pastdmark  
326f ..			.dmark: db "-2a"  
3272 f1			.pastdmark: pop af  
3273			endm  
# End of macro DMARK
3273						CALLMONITOR 
3273 cd 6f fe			call debug_vector  
3276				endm  
# End of macro CALLMONITOR
3276					endif 
3276			 
3276					FORTH_DSP_POP 
3276 cd 71 23			call macro_forth_dsp_pop 
3279				endm 
# End of macro FORTH_DSP_POP
3279			 
3279					; Get value to remove 
3279			 
3279					FORTH_DSP_VALUE 
3279 cd a2 22			call macro_forth_dsp_value 
327c				endm 
# End of macro FORTH_DSP_VALUE
327c			 
327c					if DEBUG_FORTH_WORDS 
327c						DMARK "-2v" 
327c f5				push af  
327d 3a 91 32			ld a, (.dmark)  
3280 32 6b fe			ld (debug_mark),a  
3283 3a 92 32			ld a, (.dmark+1)  
3286 32 6c fe			ld (debug_mark+1),a  
3289 3a 93 32			ld a, (.dmark+2)  
328c 32 6d fe			ld (debug_mark+2),a  
328f 18 03			jr .pastdmark  
3291 ..			.dmark: db "-2v"  
3294 f1			.pastdmark: pop af  
3295			endm  
# End of macro DMARK
3295						CALLMONITOR 
3295 cd 6f fe			call debug_vector  
3298				endm  
# End of macro CALLMONITOR
3298					endif 
3298			 
3298 eb					ex de, hl 
3299 ed 52				sbc hl, de 
329b			 
329b					if DEBUG_FORTH_WORDS 
329b						DMARK "-2d" 
329b f5				push af  
329c 3a b0 32			ld a, (.dmark)  
329f 32 6b fe			ld (debug_mark),a  
32a2 3a b1 32			ld a, (.dmark+1)  
32a5 32 6c fe			ld (debug_mark+1),a  
32a8 3a b2 32			ld a, (.dmark+2)  
32ab 32 6d fe			ld (debug_mark+2),a  
32ae 18 03			jr .pastdmark  
32b0 ..			.dmark: db "-2d"  
32b3 f1			.pastdmark: pop af  
32b4			endm  
# End of macro DMARK
32b4						CALLMONITOR 
32b4 cd 6f fe			call debug_vector  
32b7				endm  
# End of macro CALLMONITOR
32b7					endif 
32b7			 
32b7					; move result to de 
32b7			 
32b7 eb					ex de, hl 
32b8			 
32b8					; Address 
32b8			 
32b8 e1					pop hl 
32b9			 
32b9					; save it back 
32b9			 
32b9 73					ld (hl), e 
32ba 23					inc hl 
32bb 72					ld (hl), d 
32bc			 
32bc					if DEBUG_FORTH_WORDS 
32bc						DMARK "-2e" 
32bc f5				push af  
32bd 3a d1 32			ld a, (.dmark)  
32c0 32 6b fe			ld (debug_mark),a  
32c3 3a d2 32			ld a, (.dmark+1)  
32c6 32 6c fe			ld (debug_mark+1),a  
32c9 3a d3 32			ld a, (.dmark+2)  
32cc 32 6d fe			ld (debug_mark+2),a  
32cf 18 03			jr .pastdmark  
32d1 ..			.dmark: db "-2e"  
32d4 f1			.pastdmark: pop af  
32d5			endm  
# End of macro DMARK
32d5						CALLMONITOR 
32d5 cd 6f fe			call debug_vector  
32d8				endm  
# End of macro CALLMONITOR
32d8					endif 
32d8			 
32d8			 
32d8			 
32d8			 
32d8			 
32d8				       NEXTW 
32d8 c3 6f 24			jp macro_next 
32db				endm 
# End of macro NEXTW
32db			.GET2: 
32db				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
32db 6f				db WORD_SYS_CORE+91             
32dc 0b 33			dw .BANG2            
32de 03				db 2 + 1 
32df .. 00			db "2@",0              
32e2				endm 
# End of macro CWHEAD
32e2			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
32e2					if DEBUG_FORTH_WORDS_KEY 
32e2						DMARK "2A_" 
32e2 f5				push af  
32e3 3a f7 32			ld a, (.dmark)  
32e6 32 6b fe			ld (debug_mark),a  
32e9 3a f8 32			ld a, (.dmark+1)  
32ec 32 6c fe			ld (debug_mark+1),a  
32ef 3a f9 32			ld a, (.dmark+2)  
32f2 32 6d fe			ld (debug_mark+2),a  
32f5 18 03			jr .pastdmark  
32f7 ..			.dmark: db "2A_"  
32fa f1			.pastdmark: pop af  
32fb			endm  
# End of macro DMARK
32fb						CALLMONITOR 
32fb cd 6f fe			call debug_vector  
32fe				endm  
# End of macro CALLMONITOR
32fe					endif 
32fe			 
32fe					FORTH_DSP_VALUEHL 
32fe cd b9 22			call macro_dsp_valuehl 
3301				endm 
# End of macro FORTH_DSP_VALUEHL
3301			 
3301 5e					ld e, (hl) 
3302 23					inc hl 
3303 56					ld d, (hl) 
3304			 
3304 eb					ex de, hl 
3305			 
3305 cd c2 20				call forth_push_numhl 
3308			 
3308				       NEXTW 
3308 c3 6f 24			jp macro_next 
330b				endm 
# End of macro NEXTW
330b			.BANG2: 
330b				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
330b 6f				db WORD_SYS_CORE+91             
330c 43 33			dw .CONFIG            
330e 03				db 2 + 1 
330f .. 00			db "2!",0              
3312				endm 
# End of macro CWHEAD
3312			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3312					if DEBUG_FORTH_WORDS_KEY 
3312						DMARK "2S_" 
3312 f5				push af  
3313 3a 27 33			ld a, (.dmark)  
3316 32 6b fe			ld (debug_mark),a  
3319 3a 28 33			ld a, (.dmark+1)  
331c 32 6c fe			ld (debug_mark+1),a  
331f 3a 29 33			ld a, (.dmark+2)  
3322 32 6d fe			ld (debug_mark+2),a  
3325 18 03			jr .pastdmark  
3327 ..			.dmark: db "2S_"  
332a f1			.pastdmark: pop af  
332b			endm  
# End of macro DMARK
332b						CALLMONITOR 
332b cd 6f fe			call debug_vector  
332e				endm  
# End of macro CALLMONITOR
332e					endif 
332e			 
332e					FORTH_DSP_VALUEHL 
332e cd b9 22			call macro_dsp_valuehl 
3331				endm 
# End of macro FORTH_DSP_VALUEHL
3331			 
3331 e5					push hl   ; save address 
3332			 
3332			 
3332					FORTH_DSP_POP 
3332 cd 71 23			call macro_forth_dsp_pop 
3335				endm 
# End of macro FORTH_DSP_POP
3335			 
3335					 
3335					FORTH_DSP_VALUEHL 
3335 cd b9 22			call macro_dsp_valuehl 
3338				endm 
# End of macro FORTH_DSP_VALUEHL
3338			 
3338					FORTH_DSP_POP 
3338 cd 71 23			call macro_forth_dsp_pop 
333b				endm 
# End of macro FORTH_DSP_POP
333b			 
333b eb					ex de, hl    ; value now in de 
333c			 
333c e1					pop hl 
333d			 
333d 73					ld (hl), e 
333e			 
333e 23					inc hl 
333f			 
333f 72					ld (hl), d 
3340			 
3340			 
3340				       NEXTW 
3340 c3 6f 24			jp macro_next 
3343				endm 
# End of macro NEXTW
3343			.CONFIG: 
3343				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
3343 6f				db WORD_SYS_CORE+91             
3344 54 33			dw .ENDCORE            
3346 07				db 6 + 1 
3347 .. 00			db "CONFIG",0              
334e				endm 
# End of macro CWHEAD
334e			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
334e			 
334e cd 10 16				call config 
3351					NEXTW 
3351 c3 6f 24			jp macro_next 
3354				endm 
# End of macro NEXTW
3354			.ENDCORE: 
3354			 
3354			; eof 
3354			 
3354			 
# End of file forth_words_core.asm
3354			include "forth_words_flow.asm" 
3354			 
3354			; | ## Program Flow Words 
3354			 
3354			.IF: 
3354				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3354 1e				db WORD_SYS_CORE+10             
3355 49 34			dw .THEN            
3357 03				db 2 + 1 
3358 .. 00			db "IF",0              
335b				endm 
# End of macro CWHEAD
335b			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
335b			; 
335b					if DEBUG_FORTH_WORDS_KEY 
335b						DMARK "IF." 
335b f5				push af  
335c 3a 70 33			ld a, (.dmark)  
335f 32 6b fe			ld (debug_mark),a  
3362 3a 71 33			ld a, (.dmark+1)  
3365 32 6c fe			ld (debug_mark+1),a  
3368 3a 72 33			ld a, (.dmark+2)  
336b 32 6d fe			ld (debug_mark+2),a  
336e 18 03			jr .pastdmark  
3370 ..			.dmark: db "IF."  
3373 f1			.pastdmark: pop af  
3374			endm  
# End of macro DMARK
3374						CALLMONITOR 
3374 cd 6f fe			call debug_vector  
3377				endm  
# End of macro CALLMONITOR
3377					endif 
3377			; eval TOS 
3377			 
3377				FORTH_DSP_VALUEHL 
3377 cd b9 22			call macro_dsp_valuehl 
337a				endm 
# End of macro FORTH_DSP_VALUEHL
337a			 
337a			;	push hl 
337a				FORTH_DSP_POP 
337a cd 71 23			call macro_forth_dsp_pop 
337d				endm 
# End of macro FORTH_DSP_POP
337d			;	pop hl 
337d			 
337d					if DEBUG_FORTH_WORDS 
337d						DMARK "IF1" 
337d f5				push af  
337e 3a 92 33			ld a, (.dmark)  
3381 32 6b fe			ld (debug_mark),a  
3384 3a 93 33			ld a, (.dmark+1)  
3387 32 6c fe			ld (debug_mark+1),a  
338a 3a 94 33			ld a, (.dmark+2)  
338d 32 6d fe			ld (debug_mark+2),a  
3390 18 03			jr .pastdmark  
3392 ..			.dmark: db "IF1"  
3395 f1			.pastdmark: pop af  
3396			endm  
# End of macro DMARK
3396						CALLMONITOR 
3396 cd 6f fe			call debug_vector  
3399				endm  
# End of macro CALLMONITOR
3399					endif 
3399 b7				or a        ; clear carry flag 
339a 11 00 00			ld de, 0 
339d eb				ex de,hl 
339e ed 52			sbc hl, de 
33a0 c2 2a 34			jp nz, .iftrue 
33a3			 
33a3					if DEBUG_FORTH_WORDS 
33a3						DMARK "IF2" 
33a3 f5				push af  
33a4 3a b8 33			ld a, (.dmark)  
33a7 32 6b fe			ld (debug_mark),a  
33aa 3a b9 33			ld a, (.dmark+1)  
33ad 32 6c fe			ld (debug_mark+1),a  
33b0 3a ba 33			ld a, (.dmark+2)  
33b3 32 6d fe			ld (debug_mark+2),a  
33b6 18 03			jr .pastdmark  
33b8 ..			.dmark: db "IF2"  
33bb f1			.pastdmark: pop af  
33bc			endm  
# End of macro DMARK
33bc						CALLMONITOR 
33bc cd 6f fe			call debug_vector  
33bf				endm  
# End of macro CALLMONITOR
33bf					endif 
33bf			 
33bf			; if not true then skip to THEN 
33bf			 
33bf				; TODO get tok_ptr 
33bf				; TODO consume toks until we get to THEN 
33bf			 
33bf 2a c2 f4			ld hl, (os_tok_ptr) 
33c2					if DEBUG_FORTH_WORDS 
33c2						DMARK "IF3" 
33c2 f5				push af  
33c3 3a d7 33			ld a, (.dmark)  
33c6 32 6b fe			ld (debug_mark),a  
33c9 3a d8 33			ld a, (.dmark+1)  
33cc 32 6c fe			ld (debug_mark+1),a  
33cf 3a d9 33			ld a, (.dmark+2)  
33d2 32 6d fe			ld (debug_mark+2),a  
33d5 18 03			jr .pastdmark  
33d7 ..			.dmark: db "IF3"  
33da f1			.pastdmark: pop af  
33db			endm  
# End of macro DMARK
33db						CALLMONITOR 
33db cd 6f fe			call debug_vector  
33de				endm  
# End of macro CALLMONITOR
33de						 
33de					endif 
33de 11 25 34			ld de, .ifthen 
33e1					if DEBUG_FORTH_WORDS 
33e1						DMARK "IF4" 
33e1 f5				push af  
33e2 3a f6 33			ld a, (.dmark)  
33e5 32 6b fe			ld (debug_mark),a  
33e8 3a f7 33			ld a, (.dmark+1)  
33eb 32 6c fe			ld (debug_mark+1),a  
33ee 3a f8 33			ld a, (.dmark+2)  
33f1 32 6d fe			ld (debug_mark+2),a  
33f4 18 03			jr .pastdmark  
33f6 ..			.dmark: db "IF4"  
33f9 f1			.pastdmark: pop af  
33fa			endm  
# End of macro DMARK
33fa						CALLMONITOR 
33fa cd 6f fe			call debug_vector  
33fd				endm  
# End of macro CALLMONITOR
33fd					endif 
33fd cd 8a 25			call findnexttok  
3400			 
3400					if DEBUG_FORTH_WORDS 
3400						DMARK "IF5" 
3400 f5				push af  
3401 3a 15 34			ld a, (.dmark)  
3404 32 6b fe			ld (debug_mark),a  
3407 3a 16 34			ld a, (.dmark+1)  
340a 32 6c fe			ld (debug_mark+1),a  
340d 3a 17 34			ld a, (.dmark+2)  
3410 32 6d fe			ld (debug_mark+2),a  
3413 18 03			jr .pastdmark  
3415 ..			.dmark: db "IF5"  
3418 f1			.pastdmark: pop af  
3419			endm  
# End of macro DMARK
3419						CALLMONITOR 
3419 cd 6f fe			call debug_vector  
341c				endm  
# End of macro CALLMONITOR
341c					endif 
341c				; TODO replace below with ; exec using tok_ptr 
341c 22 c2 f4			ld (os_tok_ptr), hl 
341f c3 00 25			jp exec1 
3422				NEXTW 
3422 c3 6f 24			jp macro_next 
3425				endm 
# End of macro NEXTW
3425			 
3425 .. 00		.ifthen:  db "THEN",0 
342a			 
342a			.iftrue:		 
342a				; Exec next words normally 
342a			 
342a				; if true then exec following IF as normal 
342a					if DEBUG_FORTH_WORDS 
342a						DMARK "IFT" 
342a f5				push af  
342b 3a 3f 34			ld a, (.dmark)  
342e 32 6b fe			ld (debug_mark),a  
3431 3a 40 34			ld a, (.dmark+1)  
3434 32 6c fe			ld (debug_mark+1),a  
3437 3a 41 34			ld a, (.dmark+2)  
343a 32 6d fe			ld (debug_mark+2),a  
343d 18 03			jr .pastdmark  
343f ..			.dmark: db "IFT"  
3442 f1			.pastdmark: pop af  
3443			endm  
# End of macro DMARK
3443						CALLMONITOR 
3443 cd 6f fe			call debug_vector  
3446				endm  
# End of macro CALLMONITOR
3446					endif 
3446			 
3446					NEXTW 
3446 c3 6f 24			jp macro_next 
3449				endm 
# End of macro NEXTW
3449			.THEN: 
3449				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3449 1f				db WORD_SYS_CORE+11             
344a 71 34			dw .ELSE            
344c 05				db 4 + 1 
344d .. 00			db "THEN",0              
3452				endm 
# End of macro CWHEAD
3452			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3452					if DEBUG_FORTH_WORDS_KEY 
3452						DMARK "THN" 
3452 f5				push af  
3453 3a 67 34			ld a, (.dmark)  
3456 32 6b fe			ld (debug_mark),a  
3459 3a 68 34			ld a, (.dmark+1)  
345c 32 6c fe			ld (debug_mark+1),a  
345f 3a 69 34			ld a, (.dmark+2)  
3462 32 6d fe			ld (debug_mark+2),a  
3465 18 03			jr .pastdmark  
3467 ..			.dmark: db "THN"  
346a f1			.pastdmark: pop af  
346b			endm  
# End of macro DMARK
346b						CALLMONITOR 
346b cd 6f fe			call debug_vector  
346e				endm  
# End of macro CALLMONITOR
346e					endif 
346e					NEXTW 
346e c3 6f 24			jp macro_next 
3471				endm 
# End of macro NEXTW
3471			.ELSE: 
3471				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3471 20				db WORD_SYS_CORE+12             
3472 99 34			dw .DO            
3474 03				db 2 + 1 
3475 .. 00			db "ELSE",0              
347a				endm 
# End of macro CWHEAD
347a			; | ELSE ( -- ) Not supported - does nothing | TODO 
347a			 
347a					if DEBUG_FORTH_WORDS_KEY 
347a						DMARK "ELS" 
347a f5				push af  
347b 3a 8f 34			ld a, (.dmark)  
347e 32 6b fe			ld (debug_mark),a  
3481 3a 90 34			ld a, (.dmark+1)  
3484 32 6c fe			ld (debug_mark+1),a  
3487 3a 91 34			ld a, (.dmark+2)  
348a 32 6d fe			ld (debug_mark+2),a  
348d 18 03			jr .pastdmark  
348f ..			.dmark: db "ELS"  
3492 f1			.pastdmark: pop af  
3493			endm  
# End of macro DMARK
3493						CALLMONITOR 
3493 cd 6f fe			call debug_vector  
3496				endm  
# End of macro CALLMONITOR
3496					endif 
3496			 
3496			 
3496					NEXTW 
3496 c3 6f 24			jp macro_next 
3499				endm 
# End of macro NEXTW
3499			.DO: 
3499				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3499 21				db WORD_SYS_CORE+13             
349a c0 35			dw .LOOP            
349c 03				db 2 + 1 
349d .. 00			db "DO",0              
34a0				endm 
# End of macro CWHEAD
34a0			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
34a0			 
34a0					if DEBUG_FORTH_WORDS_KEY 
34a0						DMARK "DO." 
34a0 f5				push af  
34a1 3a b5 34			ld a, (.dmark)  
34a4 32 6b fe			ld (debug_mark),a  
34a7 3a b6 34			ld a, (.dmark+1)  
34aa 32 6c fe			ld (debug_mark+1),a  
34ad 3a b7 34			ld a, (.dmark+2)  
34b0 32 6d fe			ld (debug_mark+2),a  
34b3 18 03			jr .pastdmark  
34b5 ..			.dmark: db "DO."  
34b8 f1			.pastdmark: pop af  
34b9			endm  
# End of macro DMARK
34b9						CALLMONITOR 
34b9 cd 6f fe			call debug_vector  
34bc				endm  
# End of macro CALLMONITOR
34bc					endif 
34bc			;  push pc to rsp stack past the DO 
34bc			 
34bc 2a c2 f4				ld hl, (os_tok_ptr) 
34bf 23					inc hl   ; D 
34c0 23					inc hl  ; O 
34c1 23					inc hl   ; null 
34c2					if DEBUG_FORTH_WORDS 
34c2						DMARK "DO2" 
34c2 f5				push af  
34c3 3a d7 34			ld a, (.dmark)  
34c6 32 6b fe			ld (debug_mark),a  
34c9 3a d8 34			ld a, (.dmark+1)  
34cc 32 6c fe			ld (debug_mark+1),a  
34cf 3a d9 34			ld a, (.dmark+2)  
34d2 32 6d fe			ld (debug_mark+2),a  
34d5 18 03			jr .pastdmark  
34d7 ..			.dmark: db "DO2"  
34da f1			.pastdmark: pop af  
34db			endm  
# End of macro DMARK
34db						CALLMONITOR 
34db cd 6f fe			call debug_vector  
34de				endm  
# End of macro CALLMONITOR
34de					endif 
34de					FORTH_RSP_NEXT 
34de cd 69 20			call macro_forth_rsp_next 
34e1				endm 
# End of macro FORTH_RSP_NEXT
34e1					if DEBUG_FORTH_WORDS 
34e1						DMARK "DO3" 
34e1 f5				push af  
34e2 3a f6 34			ld a, (.dmark)  
34e5 32 6b fe			ld (debug_mark),a  
34e8 3a f7 34			ld a, (.dmark+1)  
34eb 32 6c fe			ld (debug_mark+1),a  
34ee 3a f8 34			ld a, (.dmark+2)  
34f1 32 6d fe			ld (debug_mark+2),a  
34f4 18 03			jr .pastdmark  
34f6 ..			.dmark: db "DO3"  
34f9 f1			.pastdmark: pop af  
34fa			endm  
# End of macro DMARK
34fa						CALLMONITOR 
34fa cd 6f fe			call debug_vector  
34fd				endm  
# End of macro CALLMONITOR
34fd					endif 
34fd			 
34fd					;if DEBUG_FORTH_WORDS 
34fd				;		push hl 
34fd			;		endif  
34fd			 
34fd			; get counters from data stack 
34fd			 
34fd			 
34fd					FORTH_DSP_VALUEHL 
34fd cd b9 22			call macro_dsp_valuehl 
3500				endm 
# End of macro FORTH_DSP_VALUEHL
3500 e5					push hl		 ; hl now has starting counter which needs to be tos 
3501			 
3501					if DEBUG_FORTH_WORDS 
3501						DMARK "DO4" 
3501 f5				push af  
3502 3a 16 35			ld a, (.dmark)  
3505 32 6b fe			ld (debug_mark),a  
3508 3a 17 35			ld a, (.dmark+1)  
350b 32 6c fe			ld (debug_mark+1),a  
350e 3a 18 35			ld a, (.dmark+2)  
3511 32 6d fe			ld (debug_mark+2),a  
3514 18 03			jr .pastdmark  
3516 ..			.dmark: db "DO4"  
3519 f1			.pastdmark: pop af  
351a			endm  
# End of macro DMARK
351a						CALLMONITOR 
351a cd 6f fe			call debug_vector  
351d				endm  
# End of macro CALLMONITOR
351d					endif 
351d					FORTH_DSP_POP 
351d cd 71 23			call macro_forth_dsp_pop 
3520				endm 
# End of macro FORTH_DSP_POP
3520			 
3520					if DEBUG_FORTH_WORDS 
3520						DMARK "DO5" 
3520 f5				push af  
3521 3a 35 35			ld a, (.dmark)  
3524 32 6b fe			ld (debug_mark),a  
3527 3a 36 35			ld a, (.dmark+1)  
352a 32 6c fe			ld (debug_mark+1),a  
352d 3a 37 35			ld a, (.dmark+2)  
3530 32 6d fe			ld (debug_mark+2),a  
3533 18 03			jr .pastdmark  
3535 ..			.dmark: db "DO5"  
3538 f1			.pastdmark: pop af  
3539			endm  
# End of macro DMARK
3539						CALLMONITOR 
3539 cd 6f fe			call debug_vector  
353c				endm  
# End of macro CALLMONITOR
353c					endif 
353c			 
353c					FORTH_DSP_VALUEHL 
353c cd b9 22			call macro_dsp_valuehl 
353f				endm 
# End of macro FORTH_DSP_VALUEHL
353f			;		push hl		 ; hl now has starting limit counter 
353f			 
353f					if DEBUG_FORTH_WORDS 
353f						DMARK "DO6" 
353f f5				push af  
3540 3a 54 35			ld a, (.dmark)  
3543 32 6b fe			ld (debug_mark),a  
3546 3a 55 35			ld a, (.dmark+1)  
3549 32 6c fe			ld (debug_mark+1),a  
354c 3a 56 35			ld a, (.dmark+2)  
354f 32 6d fe			ld (debug_mark+2),a  
3552 18 03			jr .pastdmark  
3554 ..			.dmark: db "DO6"  
3557 f1			.pastdmark: pop af  
3558			endm  
# End of macro DMARK
3558						CALLMONITOR 
3558 cd 6f fe			call debug_vector  
355b				endm  
# End of macro CALLMONITOR
355b					endif 
355b					FORTH_DSP_POP 
355b cd 71 23			call macro_forth_dsp_pop 
355e				endm 
# End of macro FORTH_DSP_POP
355e			 
355e			; put counters on the loop stack 
355e			 
355e			;		pop hl			 ; limit counter 
355e d1					pop de			; start counter 
355f			 
355f					; push limit counter 
355f			 
355f					if DEBUG_FORTH_WORDS 
355f						DMARK "DO7" 
355f f5				push af  
3560 3a 74 35			ld a, (.dmark)  
3563 32 6b fe			ld (debug_mark),a  
3566 3a 75 35			ld a, (.dmark+1)  
3569 32 6c fe			ld (debug_mark+1),a  
356c 3a 76 35			ld a, (.dmark+2)  
356f 32 6d fe			ld (debug_mark+2),a  
3572 18 03			jr .pastdmark  
3574 ..			.dmark: db "DO7"  
3577 f1			.pastdmark: pop af  
3578			endm  
# End of macro DMARK
3578						CALLMONITOR 
3578 cd 6f fe			call debug_vector  
357b				endm  
# End of macro CALLMONITOR
357b					endif 
357b					FORTH_LOOP_NEXT 
357b cd ea 22			call macro_forth_loop_next 
357e				endm 
# End of macro FORTH_LOOP_NEXT
357e			 
357e					; push start counter 
357e			 
357e eb					ex de, hl 
357f					if DEBUG_FORTH_WORDS 
357f						DMARK "DO7" 
357f f5				push af  
3580 3a 94 35			ld a, (.dmark)  
3583 32 6b fe			ld (debug_mark),a  
3586 3a 95 35			ld a, (.dmark+1)  
3589 32 6c fe			ld (debug_mark+1),a  
358c 3a 96 35			ld a, (.dmark+2)  
358f 32 6d fe			ld (debug_mark+2),a  
3592 18 03			jr .pastdmark  
3594 ..			.dmark: db "DO7"  
3597 f1			.pastdmark: pop af  
3598			endm  
# End of macro DMARK
3598						CALLMONITOR 
3598 cd 6f fe			call debug_vector  
359b				endm  
# End of macro CALLMONITOR
359b					endif 
359b					FORTH_LOOP_NEXT 
359b cd ea 22			call macro_forth_loop_next 
359e				endm 
# End of macro FORTH_LOOP_NEXT
359e			 
359e			 
359e					; init first round of I counter 
359e			 
359e 22 e6 f4				ld (os_current_i), hl 
35a1			 
35a1					if DEBUG_FORTH_WORDS 
35a1						DMARK "DO8" 
35a1 f5				push af  
35a2 3a b6 35			ld a, (.dmark)  
35a5 32 6b fe			ld (debug_mark),a  
35a8 3a b7 35			ld a, (.dmark+1)  
35ab 32 6c fe			ld (debug_mark+1),a  
35ae 3a b8 35			ld a, (.dmark+2)  
35b1 32 6d fe			ld (debug_mark+2),a  
35b4 18 03			jr .pastdmark  
35b6 ..			.dmark: db "DO8"  
35b9 f1			.pastdmark: pop af  
35ba			endm  
# End of macro DMARK
35ba						CALLMONITOR 
35ba cd 6f fe			call debug_vector  
35bd				endm  
# End of macro CALLMONITOR
35bd					endif 
35bd			 
35bd					NEXTW 
35bd c3 6f 24			jp macro_next 
35c0				endm 
# End of macro NEXTW
35c0			.LOOP: 
35c0				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
35c0 22				db WORD_SYS_CORE+14             
35c1 d8 36			dw .I            
35c3 05				db 4 + 1 
35c4 .. 00			db "LOOP",0              
35c9				endm 
# End of macro CWHEAD
35c9			; | LOOP ( -- ) Increment and test loop counter  | DONE 
35c9			 
35c9				; pop tos as current loop count to hl 
35c9			 
35c9				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
35c9			 
35c9				FORTH_LOOP_TOS 
35c9 cd 1d 23			call macro_forth_loop_tos 
35cc				endm 
# End of macro FORTH_LOOP_TOS
35cc e5				push hl 
35cd			 
35cd					if DEBUG_FORTH_WORDS_KEY 
35cd						DMARK "LOP" 
35cd f5				push af  
35ce 3a e2 35			ld a, (.dmark)  
35d1 32 6b fe			ld (debug_mark),a  
35d4 3a e3 35			ld a, (.dmark+1)  
35d7 32 6c fe			ld (debug_mark+1),a  
35da 3a e4 35			ld a, (.dmark+2)  
35dd 32 6d fe			ld (debug_mark+2),a  
35e0 18 03			jr .pastdmark  
35e2 ..			.dmark: db "LOP"  
35e5 f1			.pastdmark: pop af  
35e6			endm  
# End of macro DMARK
35e6						CALLMONITOR 
35e6 cd 6f fe			call debug_vector  
35e9				endm  
# End of macro CALLMONITOR
35e9					endif 
35e9				; next item on the stack is the limit. get it 
35e9			 
35e9			 
35e9				FORTH_LOOP_POP 
35e9 cd 27 23			call macro_forth_loop_pop 
35ec				endm 
# End of macro FORTH_LOOP_POP
35ec			 
35ec				FORTH_LOOP_TOS 
35ec cd 1d 23			call macro_forth_loop_tos 
35ef				endm 
# End of macro FORTH_LOOP_TOS
35ef			 
35ef d1				pop de		 ; de = i, hl = limit 
35f0			 
35f0					if DEBUG_FORTH_WORDS 
35f0						DMARK "LP1" 
35f0 f5				push af  
35f1 3a 05 36			ld a, (.dmark)  
35f4 32 6b fe			ld (debug_mark),a  
35f7 3a 06 36			ld a, (.dmark+1)  
35fa 32 6c fe			ld (debug_mark+1),a  
35fd 3a 07 36			ld a, (.dmark+2)  
3600 32 6d fe			ld (debug_mark+2),a  
3603 18 03			jr .pastdmark  
3605 ..			.dmark: db "LP1"  
3608 f1			.pastdmark: pop af  
3609			endm  
# End of macro DMARK
3609						CALLMONITOR 
3609 cd 6f fe			call debug_vector  
360c				endm  
# End of macro CALLMONITOR
360c					endif 
360c			 
360c				; go back to previous word 
360c			 
360c d5				push de    ; save I for inc later 
360d			 
360d			 
360d				; get limit 
360d				;  is I at limit? 
360d			 
360d			 
360d					if DEBUG_FORTH_WORDS 
360d						DMARK "LP1" 
360d f5				push af  
360e 3a 22 36			ld a, (.dmark)  
3611 32 6b fe			ld (debug_mark),a  
3614 3a 23 36			ld a, (.dmark+1)  
3617 32 6c fe			ld (debug_mark+1),a  
361a 3a 24 36			ld a, (.dmark+2)  
361d 32 6d fe			ld (debug_mark+2),a  
3620 18 03			jr .pastdmark  
3622 ..			.dmark: db "LP1"  
3625 f1			.pastdmark: pop af  
3626			endm  
# End of macro DMARK
3626						CALLMONITOR 
3626 cd 6f fe			call debug_vector  
3629				endm  
# End of macro CALLMONITOR
3629					endif 
3629			 
3629 ed 52			sbc hl, de 
362b			 
362b			 
362b				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
362b			 
362b 20 26				jr nz, .loopnotdone 
362d			 
362d e1				pop hl   ; get rid of saved I 
362e				FORTH_LOOP_POP     ; get rid of limit 
362e cd 27 23			call macro_forth_loop_pop 
3631				endm 
# End of macro FORTH_LOOP_POP
3631			 
3631				FORTH_RSP_POP     ; get rid of DO ptr 
3631 cd 8a 20			call macro_forth_rsp_pop 
3634				endm 
# End of macro FORTH_RSP_POP
3634			 
3634			if DEBUG_FORTH_WORDS 
3634						DMARK "LP>" 
3634 f5				push af  
3635 3a 49 36			ld a, (.dmark)  
3638 32 6b fe			ld (debug_mark),a  
363b 3a 4a 36			ld a, (.dmark+1)  
363e 32 6c fe			ld (debug_mark+1),a  
3641 3a 4b 36			ld a, (.dmark+2)  
3644 32 6d fe			ld (debug_mark+2),a  
3647 18 03			jr .pastdmark  
3649 ..			.dmark: db "LP>"  
364c f1			.pastdmark: pop af  
364d			endm  
# End of macro DMARK
364d				CALLMONITOR 
364d cd 6f fe			call debug_vector  
3650				endm  
# End of macro CALLMONITOR
3650			endif 
3650			 
3650					NEXTW 
3650 c3 6f 24			jp macro_next 
3653				endm 
# End of macro NEXTW
3653				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3653			 
3653			.loopnotdone: 
3653			 
3653 e1				pop hl    ; get I 
3654 23				inc hl 
3655			 
3655			   	; save new I 
3655			 
3655			 
3655					; set I counter 
3655			 
3655 22 e6 f4				ld (os_current_i), hl 
3658			 
3658					if DEBUG_FORTH_WORDS 
3658						DMARK "LPN" 
3658 f5				push af  
3659 3a 6d 36			ld a, (.dmark)  
365c 32 6b fe			ld (debug_mark),a  
365f 3a 6e 36			ld a, (.dmark+1)  
3662 32 6c fe			ld (debug_mark+1),a  
3665 3a 6f 36			ld a, (.dmark+2)  
3668 32 6d fe			ld (debug_mark+2),a  
366b 18 03			jr .pastdmark  
366d ..			.dmark: db "LPN"  
3670 f1			.pastdmark: pop af  
3671			endm  
# End of macro DMARK
3671					CALLMONITOR 
3671 cd 6f fe			call debug_vector  
3674				endm  
# End of macro CALLMONITOR
3674					endif 
3674					 
3674				FORTH_LOOP_NEXT 
3674 cd ea 22			call macro_forth_loop_next 
3677				endm 
# End of macro FORTH_LOOP_NEXT
3677			 
3677			 
3677					if DEBUG_FORTH_WORDS 
3677 eb						ex de,hl 
3678					endif 
3678			 
3678			;	; get DO ptr 
3678			; 
3678					if DEBUG_FORTH_WORDS 
3678						DMARK "LP7" 
3678 f5				push af  
3679 3a 8d 36			ld a, (.dmark)  
367c 32 6b fe			ld (debug_mark),a  
367f 3a 8e 36			ld a, (.dmark+1)  
3682 32 6c fe			ld (debug_mark+1),a  
3685 3a 8f 36			ld a, (.dmark+2)  
3688 32 6d fe			ld (debug_mark+2),a  
368b 18 03			jr .pastdmark  
368d ..			.dmark: db "LP7"  
3690 f1			.pastdmark: pop af  
3691			endm  
# End of macro DMARK
3691					CALLMONITOR 
3691 cd 6f fe			call debug_vector  
3694				endm  
# End of macro CALLMONITOR
3694					endif 
3694				FORTH_RSP_TOS 
3694 cd 80 20			call macro_forth_rsp_tos 
3697				endm 
# End of macro FORTH_RSP_TOS
3697			 
3697					if DEBUG_FORTH_WORDS 
3697						DMARK "LP8" 
3697 f5				push af  
3698 3a ac 36			ld a, (.dmark)  
369b 32 6b fe			ld (debug_mark),a  
369e 3a ad 36			ld a, (.dmark+1)  
36a1 32 6c fe			ld (debug_mark+1),a  
36a4 3a ae 36			ld a, (.dmark+2)  
36a7 32 6d fe			ld (debug_mark+2),a  
36aa 18 03			jr .pastdmark  
36ac ..			.dmark: db "LP8"  
36af f1			.pastdmark: pop af  
36b0			endm  
# End of macro DMARK
36b0					CALLMONITOR 
36b0 cd 6f fe			call debug_vector  
36b3				endm  
# End of macro CALLMONITOR
36b3					endif 
36b3				;push hl 
36b3			 
36b3				; not going to DO any more 
36b3				; get rid of the RSP pointer as DO will add it back in 
36b3				;FORTH_RSP_POP 
36b3				;pop hl 
36b3			 
36b3				;ld hl,(cli_ret_sp) 
36b3				;ld e, (hl) 
36b3				;inc hl 
36b3				;ld d, (hl) 
36b3				;ex de,hl 
36b3 22 c2 f4			ld (os_tok_ptr), hl 
36b6					if DEBUG_FORTH_WORDS 
36b6						DMARK "LP<" 
36b6 f5				push af  
36b7 3a cb 36			ld a, (.dmark)  
36ba 32 6b fe			ld (debug_mark),a  
36bd 3a cc 36			ld a, (.dmark+1)  
36c0 32 6c fe			ld (debug_mark+1),a  
36c3 3a cd 36			ld a, (.dmark+2)  
36c6 32 6d fe			ld (debug_mark+2),a  
36c9 18 03			jr .pastdmark  
36cb ..			.dmark: db "LP<"  
36ce f1			.pastdmark: pop af  
36cf			endm  
# End of macro DMARK
36cf					CALLMONITOR 
36cf cd 6f fe			call debug_vector  
36d2				endm  
# End of macro CALLMONITOR
36d2				endif 
36d2 c3 00 25			jp exec1 
36d5			 
36d5					 
36d5			 
36d5			 
36d5					NEXTW 
36d5 c3 6f 24			jp macro_next 
36d8				endm 
# End of macro NEXTW
36d8			.I:  
36d8			 
36d8				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
36d8 5e				db WORD_SYS_CORE+74             
36d9 03 37			dw .DLOOP            
36db 02				db 1 + 1 
36dc .. 00			db "I",0              
36de				endm 
# End of macro CWHEAD
36de			; | I ( -- ) Current loop counter | DONE 
36de					if DEBUG_FORTH_WORDS_KEY 
36de						DMARK "I.." 
36de f5				push af  
36df 3a f3 36			ld a, (.dmark)  
36e2 32 6b fe			ld (debug_mark),a  
36e5 3a f4 36			ld a, (.dmark+1)  
36e8 32 6c fe			ld (debug_mark+1),a  
36eb 3a f5 36			ld a, (.dmark+2)  
36ee 32 6d fe			ld (debug_mark+2),a  
36f1 18 03			jr .pastdmark  
36f3 ..			.dmark: db "I.."  
36f6 f1			.pastdmark: pop af  
36f7			endm  
# End of macro DMARK
36f7						CALLMONITOR 
36f7 cd 6f fe			call debug_vector  
36fa				endm  
# End of macro CALLMONITOR
36fa					endif 
36fa			 
36fa 2a e6 f4				ld hl,(os_current_i) 
36fd cd c2 20				call forth_push_numhl 
3700			 
3700					NEXTW 
3700 c3 6f 24			jp macro_next 
3703				endm 
# End of macro NEXTW
3703			.DLOOP: 
3703				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3703 5f				db WORD_SYS_CORE+75             
3704 e4 37			dw .REPEAT            
3706 06				db 5 + 1 
3707 .. 00			db "-LOOP",0              
370d				endm 
# End of macro CWHEAD
370d			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
370d				; pop tos as current loop count to hl 
370d					if DEBUG_FORTH_WORDS_KEY 
370d						DMARK "-LP" 
370d f5				push af  
370e 3a 22 37			ld a, (.dmark)  
3711 32 6b fe			ld (debug_mark),a  
3714 3a 23 37			ld a, (.dmark+1)  
3717 32 6c fe			ld (debug_mark+1),a  
371a 3a 24 37			ld a, (.dmark+2)  
371d 32 6d fe			ld (debug_mark+2),a  
3720 18 03			jr .pastdmark  
3722 ..			.dmark: db "-LP"  
3725 f1			.pastdmark: pop af  
3726			endm  
# End of macro DMARK
3726						CALLMONITOR 
3726 cd 6f fe			call debug_vector  
3729				endm  
# End of macro CALLMONITOR
3729					endif 
3729			 
3729				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3729			 
3729				FORTH_LOOP_TOS 
3729 cd 1d 23			call macro_forth_loop_tos 
372c				endm 
# End of macro FORTH_LOOP_TOS
372c e5				push hl 
372d			 
372d					if DEBUG_FORTH_WORDS 
372d						DMARK "-LP" 
372d f5				push af  
372e 3a 42 37			ld a, (.dmark)  
3731 32 6b fe			ld (debug_mark),a  
3734 3a 43 37			ld a, (.dmark+1)  
3737 32 6c fe			ld (debug_mark+1),a  
373a 3a 44 37			ld a, (.dmark+2)  
373d 32 6d fe			ld (debug_mark+2),a  
3740 18 03			jr .pastdmark  
3742 ..			.dmark: db "-LP"  
3745 f1			.pastdmark: pop af  
3746			endm  
# End of macro DMARK
3746						CALLMONITOR 
3746 cd 6f fe			call debug_vector  
3749				endm  
# End of macro CALLMONITOR
3749					endif 
3749				; next item on the stack is the limit. get it 
3749			 
3749			 
3749				FORTH_LOOP_POP 
3749 cd 27 23			call macro_forth_loop_pop 
374c				endm 
# End of macro FORTH_LOOP_POP
374c			 
374c				FORTH_LOOP_TOS 
374c cd 1d 23			call macro_forth_loop_tos 
374f				endm 
# End of macro FORTH_LOOP_TOS
374f			 
374f d1				pop de		 ; de = i, hl = limit 
3750			 
3750					if DEBUG_FORTH_WORDS 
3750						DMARK "-L1" 
3750 f5				push af  
3751 3a 65 37			ld a, (.dmark)  
3754 32 6b fe			ld (debug_mark),a  
3757 3a 66 37			ld a, (.dmark+1)  
375a 32 6c fe			ld (debug_mark+1),a  
375d 3a 67 37			ld a, (.dmark+2)  
3760 32 6d fe			ld (debug_mark+2),a  
3763 18 03			jr .pastdmark  
3765 ..			.dmark: db "-L1"  
3768 f1			.pastdmark: pop af  
3769			endm  
# End of macro DMARK
3769						CALLMONITOR 
3769 cd 6f fe			call debug_vector  
376c				endm  
# End of macro CALLMONITOR
376c					endif 
376c			 
376c				; go back to previous word 
376c			 
376c d5				push de    ; save I for inc later 
376d			 
376d			 
376d				; get limit 
376d				;  is I at limit? 
376d			 
376d			 
376d					if DEBUG_FORTH_WORDS 
376d						DMARK "-L1" 
376d f5				push af  
376e 3a 82 37			ld a, (.dmark)  
3771 32 6b fe			ld (debug_mark),a  
3774 3a 83 37			ld a, (.dmark+1)  
3777 32 6c fe			ld (debug_mark+1),a  
377a 3a 84 37			ld a, (.dmark+2)  
377d 32 6d fe			ld (debug_mark+2),a  
3780 18 03			jr .pastdmark  
3782 ..			.dmark: db "-L1"  
3785 f1			.pastdmark: pop af  
3786			endm  
# End of macro DMARK
3786						CALLMONITOR 
3786 cd 6f fe			call debug_vector  
3789				endm  
# End of macro CALLMONITOR
3789					endif 
3789			 
3789 ed 52			sbc hl, de 
378b			 
378b			 
378b				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
378b			 
378b 20 26				jr nz, .mloopnotdone 
378d			 
378d e1				pop hl   ; get rid of saved I 
378e				FORTH_LOOP_POP     ; get rid of limit 
378e cd 27 23			call macro_forth_loop_pop 
3791				endm 
# End of macro FORTH_LOOP_POP
3791			 
3791				FORTH_RSP_POP     ; get rid of DO ptr 
3791 cd 8a 20			call macro_forth_rsp_pop 
3794				endm 
# End of macro FORTH_RSP_POP
3794			 
3794			if DEBUG_FORTH_WORDS 
3794						DMARK "-L>" 
3794 f5				push af  
3795 3a a9 37			ld a, (.dmark)  
3798 32 6b fe			ld (debug_mark),a  
379b 3a aa 37			ld a, (.dmark+1)  
379e 32 6c fe			ld (debug_mark+1),a  
37a1 3a ab 37			ld a, (.dmark+2)  
37a4 32 6d fe			ld (debug_mark+2),a  
37a7 18 03			jr .pastdmark  
37a9 ..			.dmark: db "-L>"  
37ac f1			.pastdmark: pop af  
37ad			endm  
# End of macro DMARK
37ad				CALLMONITOR 
37ad cd 6f fe			call debug_vector  
37b0				endm  
# End of macro CALLMONITOR
37b0			endif 
37b0			 
37b0					NEXTW 
37b0 c3 6f 24			jp macro_next 
37b3				endm 
# End of macro NEXTW
37b3				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
37b3			 
37b3			.mloopnotdone: 
37b3			 
37b3 e1				pop hl    ; get I 
37b4 2b				dec hl 
37b5			 
37b5			   	; save new I 
37b5			 
37b5			 
37b5					; set I counter 
37b5			 
37b5 22 e6 f4				ld (os_current_i), hl 
37b8			 
37b8					 
37b8				FORTH_LOOP_NEXT 
37b8 cd ea 22			call macro_forth_loop_next 
37bb				endm 
# End of macro FORTH_LOOP_NEXT
37bb			 
37bb			 
37bb					if DEBUG_FORTH_WORDS 
37bb eb						ex de,hl 
37bc					endif 
37bc			 
37bc			;	; get DO ptr 
37bc			; 
37bc				FORTH_RSP_TOS 
37bc cd 80 20			call macro_forth_rsp_tos 
37bf				endm 
# End of macro FORTH_RSP_TOS
37bf			 
37bf				;push hl 
37bf			 
37bf				; not going to DO any more 
37bf				; get rid of the RSP pointer as DO will add it back in 
37bf				;FORTH_RSP_POP 
37bf				;pop hl 
37bf			 
37bf			 
37bf 22 c2 f4			ld (os_tok_ptr), hl 
37c2					if DEBUG_FORTH_WORDS 
37c2						DMARK "-L<" 
37c2 f5				push af  
37c3 3a d7 37			ld a, (.dmark)  
37c6 32 6b fe			ld (debug_mark),a  
37c9 3a d8 37			ld a, (.dmark+1)  
37cc 32 6c fe			ld (debug_mark+1),a  
37cf 3a d9 37			ld a, (.dmark+2)  
37d2 32 6d fe			ld (debug_mark+2),a  
37d5 18 03			jr .pastdmark  
37d7 ..			.dmark: db "-L<"  
37da f1			.pastdmark: pop af  
37db			endm  
# End of macro DMARK
37db					CALLMONITOR 
37db cd 6f fe			call debug_vector  
37de				endm  
# End of macro CALLMONITOR
37de				endif 
37de c3 00 25			jp exec1 
37e1			 
37e1					 
37e1			 
37e1			 
37e1			 
37e1				NEXTW 
37e1 c3 6f 24			jp macro_next 
37e4				endm 
# End of macro NEXTW
37e4			 
37e4			 
37e4			 
37e4			 
37e4			.REPEAT: 
37e4				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
37e4 71				db WORD_SYS_CORE+93             
37e5 37 38			dw .UNTIL            
37e7 06				db 5 + 1 
37e8 .. 00			db "REPEAT",0              
37ef				endm 
# End of macro CWHEAD
37ef			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
37ef			;  push pc to rsp stack past the REPEAT 
37ef					if DEBUG_FORTH_WORDS_KEY 
37ef						DMARK "REP" 
37ef f5				push af  
37f0 3a 04 38			ld a, (.dmark)  
37f3 32 6b fe			ld (debug_mark),a  
37f6 3a 05 38			ld a, (.dmark+1)  
37f9 32 6c fe			ld (debug_mark+1),a  
37fc 3a 06 38			ld a, (.dmark+2)  
37ff 32 6d fe			ld (debug_mark+2),a  
3802 18 03			jr .pastdmark  
3804 ..			.dmark: db "REP"  
3807 f1			.pastdmark: pop af  
3808			endm  
# End of macro DMARK
3808						CALLMONITOR 
3808 cd 6f fe			call debug_vector  
380b				endm  
# End of macro CALLMONITOR
380b					endif 
380b			 
380b 2a c2 f4				ld hl, (os_tok_ptr) 
380e 23					inc hl   ; R 
380f 23					inc hl  ; E 
3810 23					inc hl   ; P 
3811 23					inc hl   ; E 
3812 23					inc hl   ; A 
3813 23					inc hl   ; T 
3814 23					inc hl   ; zero 
3815					FORTH_RSP_NEXT 
3815 cd 69 20			call macro_forth_rsp_next 
3818				endm 
# End of macro FORTH_RSP_NEXT
3818			 
3818			 
3818					if DEBUG_FORTH_WORDS 
3818						DMARK "REP" 
3818 f5				push af  
3819 3a 2d 38			ld a, (.dmark)  
381c 32 6b fe			ld (debug_mark),a  
381f 3a 2e 38			ld a, (.dmark+1)  
3822 32 6c fe			ld (debug_mark+1),a  
3825 3a 2f 38			ld a, (.dmark+2)  
3828 32 6d fe			ld (debug_mark+2),a  
382b 18 03			jr .pastdmark  
382d ..			.dmark: db "REP"  
3830 f1			.pastdmark: pop af  
3831			endm  
# End of macro DMARK
3831						;pop bc    ; TODO BUG ?????? what is this for???? 
3831						CALLMONITOR 
3831 cd 6f fe			call debug_vector  
3834				endm  
# End of macro CALLMONITOR
3834					endif 
3834			 
3834					NEXTW 
3834 c3 6f 24			jp macro_next 
3837				endm 
# End of macro NEXTW
3837			;	       NEXTW 
3837			 
3837			.UNTIL: 
3837				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3837 72				db WORD_SYS_CORE+94             
3838 ce 38			dw .ENDFLOW            
383a 06				db 5 + 1 
383b .. 00			db "UNTIL",0              
3841				endm 
# End of macro CWHEAD
3841			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3841			 
3841				; pop tos as check 
3841			 
3841				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3841			 
3841				FORTH_DSP_VALUEHL 
3841 cd b9 22			call macro_dsp_valuehl 
3844				endm 
# End of macro FORTH_DSP_VALUEHL
3844			 
3844					if DEBUG_FORTH_WORDS_KEY 
3844						DMARK "UNT" 
3844 f5				push af  
3845 3a 59 38			ld a, (.dmark)  
3848 32 6b fe			ld (debug_mark),a  
384b 3a 5a 38			ld a, (.dmark+1)  
384e 32 6c fe			ld (debug_mark+1),a  
3851 3a 5b 38			ld a, (.dmark+2)  
3854 32 6d fe			ld (debug_mark+2),a  
3857 18 03			jr .pastdmark  
3859 ..			.dmark: db "UNT"  
385c f1			.pastdmark: pop af  
385d			endm  
# End of macro DMARK
385d						CALLMONITOR 
385d cd 6f fe			call debug_vector  
3860				endm  
# End of macro CALLMONITOR
3860					endif 
3860			 
3860			;	push hl 
3860				FORTH_DSP_POP 
3860 cd 71 23			call macro_forth_dsp_pop 
3863				endm 
# End of macro FORTH_DSP_POP
3863			 
3863			;	pop hl 
3863			 
3863				; test if true 
3863			 
3863 cd af 0f			call ishlzero 
3866			;	ld a,l 
3866			;	add h 
3866			; 
3866			;	cp 0 
3866			 
3866 20 3e			jr nz, .untilnotdone 
3868			 
3868					if DEBUG_FORTH_WORDS 
3868						DMARK "UNf" 
3868 f5				push af  
3869 3a 7d 38			ld a, (.dmark)  
386c 32 6b fe			ld (debug_mark),a  
386f 3a 7e 38			ld a, (.dmark+1)  
3872 32 6c fe			ld (debug_mark+1),a  
3875 3a 7f 38			ld a, (.dmark+2)  
3878 32 6d fe			ld (debug_mark+2),a  
387b 18 03			jr .pastdmark  
387d ..			.dmark: db "UNf"  
3880 f1			.pastdmark: pop af  
3881			endm  
# End of macro DMARK
3881						CALLMONITOR 
3881 cd 6f fe			call debug_vector  
3884				endm  
# End of macro CALLMONITOR
3884					endif 
3884			 
3884			 
3884			 
3884				FORTH_RSP_POP     ; get rid of DO ptr 
3884 cd 8a 20			call macro_forth_rsp_pop 
3887				endm 
# End of macro FORTH_RSP_POP
3887			 
3887			if DEBUG_FORTH_WORDS 
3887						DMARK "UN>" 
3887 f5				push af  
3888 3a 9c 38			ld a, (.dmark)  
388b 32 6b fe			ld (debug_mark),a  
388e 3a 9d 38			ld a, (.dmark+1)  
3891 32 6c fe			ld (debug_mark+1),a  
3894 3a 9e 38			ld a, (.dmark+2)  
3897 32 6d fe			ld (debug_mark+2),a  
389a 18 03			jr .pastdmark  
389c ..			.dmark: db "UN>"  
389f f1			.pastdmark: pop af  
38a0			endm  
# End of macro DMARK
38a0				CALLMONITOR 
38a0 cd 6f fe			call debug_vector  
38a3				endm  
# End of macro CALLMONITOR
38a3			endif 
38a3			 
38a3					NEXTW 
38a3 c3 6f 24			jp macro_next 
38a6				endm 
# End of macro NEXTW
38a6				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
38a6			 
38a6			.untilnotdone: 
38a6			 
38a6			 
38a6			;	; get DO ptr 
38a6			; 
38a6				FORTH_RSP_TOS 
38a6 cd 80 20			call macro_forth_rsp_tos 
38a9				endm 
# End of macro FORTH_RSP_TOS
38a9			 
38a9				;push hl 
38a9			 
38a9				; not going to DO any more 
38a9				; get rid of the RSP pointer as DO will add it back in 
38a9				;FORTH_RSP_POP 
38a9				;pop hl 
38a9			 
38a9			 
38a9 22 c2 f4			ld (os_tok_ptr), hl 
38ac					if DEBUG_FORTH_WORDS 
38ac						DMARK "UN<" 
38ac f5				push af  
38ad 3a c1 38			ld a, (.dmark)  
38b0 32 6b fe			ld (debug_mark),a  
38b3 3a c2 38			ld a, (.dmark+1)  
38b6 32 6c fe			ld (debug_mark+1),a  
38b9 3a c3 38			ld a, (.dmark+2)  
38bc 32 6d fe			ld (debug_mark+2),a  
38bf 18 03			jr .pastdmark  
38c1 ..			.dmark: db "UN<"  
38c4 f1			.pastdmark: pop af  
38c5			endm  
# End of macro DMARK
38c5					CALLMONITOR 
38c5 cd 6f fe			call debug_vector  
38c8				endm  
# End of macro CALLMONITOR
38c8				endif 
38c8 c3 00 25			jp exec1 
38cb			 
38cb					 
38cb			 
38cb			 
38cb					NEXTW 
38cb c3 6f 24			jp macro_next 
38ce				endm 
# End of macro NEXTW
38ce			 
38ce			 
38ce			.ENDFLOW: 
38ce			 
38ce			; eof 
38ce			 
# End of file forth_words_flow.asm
38ce			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
38ce			include "forth_words_logic.asm" 
38ce			 
38ce			; | ## Logic Words 
38ce			 
38ce			.NOT: 
38ce				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
38ce 2d				db WORD_SYS_CORE+25             
38cf 16 39			dw .IS            
38d1 04				db 3 + 1 
38d2 .. 00			db "NOT",0              
38d6				endm 
# End of macro CWHEAD
38d6			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
38d6					if DEBUG_FORTH_WORDS_KEY 
38d6						DMARK "NOT" 
38d6 f5				push af  
38d7 3a eb 38			ld a, (.dmark)  
38da 32 6b fe			ld (debug_mark),a  
38dd 3a ec 38			ld a, (.dmark+1)  
38e0 32 6c fe			ld (debug_mark+1),a  
38e3 3a ed 38			ld a, (.dmark+2)  
38e6 32 6d fe			ld (debug_mark+2),a  
38e9 18 03			jr .pastdmark  
38eb ..			.dmark: db "NOT"  
38ee f1			.pastdmark: pop af  
38ef			endm  
# End of macro DMARK
38ef						CALLMONITOR 
38ef cd 6f fe			call debug_vector  
38f2				endm  
# End of macro CALLMONITOR
38f2					endif 
38f2					FORTH_DSP 
38f2 cd 7f 22			call macro_forth_dsp 
38f5				endm 
# End of macro FORTH_DSP
38f5 7e					ld a,(hl)	; get type of value on TOS 
38f6 fe 02				cp DS_TYPE_INUM  
38f8 28 03				jr z, .noti 
38fa					NEXTW 
38fa c3 6f 24			jp macro_next 
38fd				endm 
# End of macro NEXTW
38fd			.noti:          FORTH_DSP_VALUEHL 
38fd cd b9 22			call macro_dsp_valuehl 
3900				endm 
# End of macro FORTH_DSP_VALUEHL
3900			;		push hl 
3900					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3900 cd 71 23			call macro_forth_dsp_pop 
3903				endm 
# End of macro FORTH_DSP_POP
3903			;		pop hl 
3903 3e 00				ld a,0 
3905 bd					cp l 
3906 28 04				jr z, .not2t 
3908 2e 00				ld l, 0 
390a 18 02				jr .notip 
390c			 
390c 2e ff		.not2t:		ld l, 255 
390e			 
390e 26 00		.notip:		ld h, 0	 
3910			 
3910 cd c2 20				call forth_push_numhl 
3913					NEXTW 
3913 c3 6f 24			jp macro_next 
3916				endm 
# End of macro NEXTW
3916			 
3916			.IS: 
3916				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3916 2d				db WORD_SYS_CORE+25             
3917 3c 39			dw .LZERO            
3919 03				db 2 + 1 
391a .. 00			db "IS",0              
391d				endm 
# End of macro CWHEAD
391d			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
391d					if DEBUG_FORTH_WORDS_KEY 
391d						DMARK "IS." 
391d f5				push af  
391e 3a 32 39			ld a, (.dmark)  
3921 32 6b fe			ld (debug_mark),a  
3924 3a 33 39			ld a, (.dmark+1)  
3927 32 6c fe			ld (debug_mark+1),a  
392a 3a 34 39			ld a, (.dmark+2)  
392d 32 6d fe			ld (debug_mark+2),a  
3930 18 03			jr .pastdmark  
3932 ..			.dmark: db "IS."  
3935 f1			.pastdmark: pop af  
3936			endm  
# End of macro DMARK
3936						CALLMONITOR 
3936 cd 6f fe			call debug_vector  
3939				endm  
# End of macro CALLMONITOR
3939					endif 
3939					NEXTW 
3939 c3 6f 24			jp macro_next 
393c				endm 
# End of macro NEXTW
393c			.LZERO: 
393c				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
393c 2d				db WORD_SYS_CORE+25             
393d 46 39			dw .TZERO            
393f 03				db 2 + 1 
3940 .. 00			db "0<",0              
3943				endm 
# End of macro CWHEAD
3943			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3943					NEXTW 
3943 c3 6f 24			jp macro_next 
3946				endm 
# End of macro NEXTW
3946			.TZERO: 
3946				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3946 2e				db WORD_SYS_CORE+26             
3947 8d 39			dw .LESS            
3949 03				db 2 + 1 
394a .. 00			db "0=",0              
394d				endm 
# End of macro CWHEAD
394d			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
394d				; TODO add floating point number detection 
394d					;v5 FORTH_DSP_VALUE 
394d					if DEBUG_FORTH_WORDS_KEY 
394d						DMARK "0=." 
394d f5				push af  
394e 3a 62 39			ld a, (.dmark)  
3951 32 6b fe			ld (debug_mark),a  
3954 3a 63 39			ld a, (.dmark+1)  
3957 32 6c fe			ld (debug_mark+1),a  
395a 3a 64 39			ld a, (.dmark+2)  
395d 32 6d fe			ld (debug_mark+2),a  
3960 18 03			jr .pastdmark  
3962 ..			.dmark: db "0=."  
3965 f1			.pastdmark: pop af  
3966			endm  
# End of macro DMARK
3966						CALLMONITOR 
3966 cd 6f fe			call debug_vector  
3969				endm  
# End of macro CALLMONITOR
3969					endif 
3969					FORTH_DSP 
3969 cd 7f 22			call macro_forth_dsp 
396c				endm 
# End of macro FORTH_DSP
396c 7e					ld a,(hl)	; get type of value on TOS 
396d fe 02				cp DS_TYPE_INUM  
396f 28 00				jr z, .tz_inum 
3971			 
3971				if FORTH_ENABLE_FLOATMATH 
3971					jr .tz_done 
3971			 
3971				endif 
3971					 
3971			 
3971			.tz_inum: 
3971					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3971 cd b9 22			call macro_dsp_valuehl 
3974				endm 
# End of macro FORTH_DSP_VALUEHL
3974			 
3974			;		push hl 
3974			 
3974					; destroy value TOS 
3974			 
3974					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3974 cd 71 23			call macro_forth_dsp_pop 
3977				endm 
# End of macro FORTH_DSP_POP
3977			 
3977			;		pop hl 
3977			 
3977 3e 00				ld a,0 
3979			 
3979 bd					cp l 
397a 20 08				jr nz, .tz_notzero 
397c			 
397c bc					cp h 
397d			 
397d 20 05				jr nz, .tz_notzero 
397f			 
397f			 
397f 21 01 00				ld hl, FORTH_TRUE 
3982 18 03				jr .tz_done 
3984			 
3984 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3987			 
3987					; push value back onto stack for another op etc 
3987			 
3987			.tz_done: 
3987 cd c2 20				call forth_push_numhl 
398a			 
398a					NEXTW 
398a c3 6f 24			jp macro_next 
398d				endm 
# End of macro NEXTW
398d			.LESS: 
398d				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
398d 2f				db WORD_SYS_CORE+27             
398e f6 39			dw .GT            
3990 02				db 1 + 1 
3991 .. 00			db "<",0              
3993				endm 
# End of macro CWHEAD
3993			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3993				; TODO add floating point number detection 
3993					if DEBUG_FORTH_WORDS_KEY 
3993						DMARK "LES" 
3993 f5				push af  
3994 3a a8 39			ld a, (.dmark)  
3997 32 6b fe			ld (debug_mark),a  
399a 3a a9 39			ld a, (.dmark+1)  
399d 32 6c fe			ld (debug_mark+1),a  
39a0 3a aa 39			ld a, (.dmark+2)  
39a3 32 6d fe			ld (debug_mark+2),a  
39a6 18 03			jr .pastdmark  
39a8 ..			.dmark: db "LES"  
39ab f1			.pastdmark: pop af  
39ac			endm  
# End of macro DMARK
39ac						CALLMONITOR 
39ac cd 6f fe			call debug_vector  
39af				endm  
# End of macro CALLMONITOR
39af					endif 
39af					FORTH_DSP 
39af cd 7f 22			call macro_forth_dsp 
39b2				endm 
# End of macro FORTH_DSP
39b2					;v5 FORTH_DSP_VALUE 
39b2 7e					ld a,(hl)	; get type of value on TOS 
39b3 fe 02				cp DS_TYPE_INUM  
39b5 28 00				jr z, .less_inum 
39b7			 
39b7				if FORTH_ENABLE_FLOATMATH 
39b7					jr .less_done 
39b7			 
39b7				endif 
39b7					 
39b7			 
39b7			.less_inum: 
39b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b7 cd b9 22			call macro_dsp_valuehl 
39ba				endm 
# End of macro FORTH_DSP_VALUEHL
39ba			 
39ba e5					push hl  ; u2 
39bb			 
39bb					; destroy value TOS 
39bb			 
39bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39bb cd 71 23			call macro_forth_dsp_pop 
39be				endm 
# End of macro FORTH_DSP_POP
39be			 
39be			 
39be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39be cd b9 22			call macro_dsp_valuehl 
39c1				endm 
# End of macro FORTH_DSP_VALUEHL
39c1			 
39c1 e5					push hl    ; u1 
39c2			 
39c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c2 cd 71 23			call macro_forth_dsp_pop 
39c5				endm 
# End of macro FORTH_DSP_POP
39c5			 
39c5			 
39c5 b7			 or a      ;clear carry flag 
39c6 01 00 00		 ld bc, FORTH_FALSE 
39c9 e1			  pop hl    ; u1 
39ca d1			  pop de    ; u2 
39cb ed 52		  sbc hl,de 
39cd 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
39cf			 
39cf 01 01 00		 ld bc, FORTH_TRUE 
39d2			.lscont:  
39d2 c5					push bc 
39d3 e1					pop hl 
39d4			 
39d4					if DEBUG_FORTH_WORDS 
39d4						DMARK "LT1" 
39d4 f5				push af  
39d5 3a e9 39			ld a, (.dmark)  
39d8 32 6b fe			ld (debug_mark),a  
39db 3a ea 39			ld a, (.dmark+1)  
39de 32 6c fe			ld (debug_mark+1),a  
39e1 3a eb 39			ld a, (.dmark+2)  
39e4 32 6d fe			ld (debug_mark+2),a  
39e7 18 03			jr .pastdmark  
39e9 ..			.dmark: db "LT1"  
39ec f1			.pastdmark: pop af  
39ed			endm  
# End of macro DMARK
39ed						CALLMONITOR 
39ed cd 6f fe			call debug_vector  
39f0				endm  
# End of macro CALLMONITOR
39f0					endif 
39f0 cd c2 20				call forth_push_numhl 
39f3			 
39f3					NEXTW 
39f3 c3 6f 24			jp macro_next 
39f6				endm 
# End of macro NEXTW
39f6			.GT: 
39f6				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
39f6 30				db WORD_SYS_CORE+28             
39f7 5f 3a			dw .EQUAL            
39f9 02				db 1 + 1 
39fa .. 00			db ">",0              
39fc				endm 
# End of macro CWHEAD
39fc			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
39fc				; TODO add floating point number detection 
39fc					if DEBUG_FORTH_WORDS_KEY 
39fc						DMARK "GRT" 
39fc f5				push af  
39fd 3a 11 3a			ld a, (.dmark)  
3a00 32 6b fe			ld (debug_mark),a  
3a03 3a 12 3a			ld a, (.dmark+1)  
3a06 32 6c fe			ld (debug_mark+1),a  
3a09 3a 13 3a			ld a, (.dmark+2)  
3a0c 32 6d fe			ld (debug_mark+2),a  
3a0f 18 03			jr .pastdmark  
3a11 ..			.dmark: db "GRT"  
3a14 f1			.pastdmark: pop af  
3a15			endm  
# End of macro DMARK
3a15						CALLMONITOR 
3a15 cd 6f fe			call debug_vector  
3a18				endm  
# End of macro CALLMONITOR
3a18					endif 
3a18					FORTH_DSP 
3a18 cd 7f 22			call macro_forth_dsp 
3a1b				endm 
# End of macro FORTH_DSP
3a1b					;FORTH_DSP_VALUE 
3a1b 7e					ld a,(hl)	; get type of value on TOS 
3a1c fe 02				cp DS_TYPE_INUM  
3a1e 28 00				jr z, .gt_inum 
3a20			 
3a20				if FORTH_ENABLE_FLOATMATH 
3a20					jr .gt_done 
3a20			 
3a20				endif 
3a20					 
3a20			 
3a20			.gt_inum: 
3a20					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a20 cd b9 22			call macro_dsp_valuehl 
3a23				endm 
# End of macro FORTH_DSP_VALUEHL
3a23			 
3a23 e5					push hl  ; u2 
3a24			 
3a24					; destroy value TOS 
3a24			 
3a24					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a24 cd 71 23			call macro_forth_dsp_pop 
3a27				endm 
# End of macro FORTH_DSP_POP
3a27			 
3a27			 
3a27					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a27 cd b9 22			call macro_dsp_valuehl 
3a2a				endm 
# End of macro FORTH_DSP_VALUEHL
3a2a			 
3a2a e5					push hl    ; u1 
3a2b			 
3a2b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a2b cd 71 23			call macro_forth_dsp_pop 
3a2e				endm 
# End of macro FORTH_DSP_POP
3a2e			 
3a2e			 
3a2e b7			 or a      ;clear carry flag 
3a2f 01 00 00		 ld bc, FORTH_FALSE 
3a32 e1			  pop hl    ; u1 
3a33 d1			  pop de    ; u2 
3a34 ed 52		  sbc hl,de 
3a36 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3a38			 
3a38 01 01 00		 ld bc, FORTH_TRUE 
3a3b			.gtcont:  
3a3b c5					push bc 
3a3c e1					pop hl 
3a3d			 
3a3d					if DEBUG_FORTH_WORDS 
3a3d						DMARK "GT1" 
3a3d f5				push af  
3a3e 3a 52 3a			ld a, (.dmark)  
3a41 32 6b fe			ld (debug_mark),a  
3a44 3a 53 3a			ld a, (.dmark+1)  
3a47 32 6c fe			ld (debug_mark+1),a  
3a4a 3a 54 3a			ld a, (.dmark+2)  
3a4d 32 6d fe			ld (debug_mark+2),a  
3a50 18 03			jr .pastdmark  
3a52 ..			.dmark: db "GT1"  
3a55 f1			.pastdmark: pop af  
3a56			endm  
# End of macro DMARK
3a56						CALLMONITOR 
3a56 cd 6f fe			call debug_vector  
3a59				endm  
# End of macro CALLMONITOR
3a59					endif 
3a59 cd c2 20				call forth_push_numhl 
3a5c			 
3a5c					NEXTW 
3a5c c3 6f 24			jp macro_next 
3a5f				endm 
# End of macro NEXTW
3a5f			.EQUAL: 
3a5f				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3a5f 31				db WORD_SYS_CORE+29             
3a60 ca 3a			dw .ENDLOGIC            
3a62 02				db 1 + 1 
3a63 .. 00			db "=",0              
3a65				endm 
# End of macro CWHEAD
3a65			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3a65				; TODO add floating point number detection 
3a65					if DEBUG_FORTH_WORDS_KEY 
3a65						DMARK "EQ." 
3a65 f5				push af  
3a66 3a 7a 3a			ld a, (.dmark)  
3a69 32 6b fe			ld (debug_mark),a  
3a6c 3a 7b 3a			ld a, (.dmark+1)  
3a6f 32 6c fe			ld (debug_mark+1),a  
3a72 3a 7c 3a			ld a, (.dmark+2)  
3a75 32 6d fe			ld (debug_mark+2),a  
3a78 18 03			jr .pastdmark  
3a7a ..			.dmark: db "EQ."  
3a7d f1			.pastdmark: pop af  
3a7e			endm  
# End of macro DMARK
3a7e						CALLMONITOR 
3a7e cd 6f fe			call debug_vector  
3a81				endm  
# End of macro CALLMONITOR
3a81					endif 
3a81					FORTH_DSP 
3a81 cd 7f 22			call macro_forth_dsp 
3a84				endm 
# End of macro FORTH_DSP
3a84					;v5 FORTH_DSP_VALUE 
3a84 7e					ld a,(hl)	; get type of value on TOS 
3a85 fe 02				cp DS_TYPE_INUM  
3a87 28 00				jr z, .eq_inum 
3a89			 
3a89				if FORTH_ENABLE_FLOATMATH 
3a89					jr .eq_done 
3a89			 
3a89				endif 
3a89					 
3a89			 
3a89			.eq_inum: 
3a89					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a89 cd b9 22			call macro_dsp_valuehl 
3a8c				endm 
# End of macro FORTH_DSP_VALUEHL
3a8c			 
3a8c e5					push hl 
3a8d			 
3a8d					; destroy value TOS 
3a8d			 
3a8d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a8d cd 71 23			call macro_forth_dsp_pop 
3a90				endm 
# End of macro FORTH_DSP_POP
3a90			 
3a90			 
3a90					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a90 cd b9 22			call macro_dsp_valuehl 
3a93				endm 
# End of macro FORTH_DSP_VALUEHL
3a93			 
3a93					; one value on hl get other one back 
3a93			 
3a93 e5					push hl 
3a94			 
3a94					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a94 cd 71 23			call macro_forth_dsp_pop 
3a97				endm 
# End of macro FORTH_DSP_POP
3a97			 
3a97 0e 00				ld c, FORTH_FALSE 
3a99			 
3a99 e1					pop hl 
3a9a d1					pop de 
3a9b			 
3a9b 7b					ld a, e 
3a9c bd					cp l 
3a9d			 
3a9d 20 06				jr nz, .eq_done 
3a9f			 
3a9f 7a					ld a, d 
3aa0 bc					cp h 
3aa1			 
3aa1 20 02				jr nz, .eq_done 
3aa3			 
3aa3 0e 01				ld c, FORTH_TRUE 
3aa5					 
3aa5			 
3aa5			 
3aa5			.eq_done: 
3aa5			 
3aa5					; TODO push value back onto stack for another op etc 
3aa5			 
3aa5 26 00				ld h, 0 
3aa7 69					ld l, c 
3aa8					if DEBUG_FORTH_WORDS 
3aa8						DMARK "EQ1" 
3aa8 f5				push af  
3aa9 3a bd 3a			ld a, (.dmark)  
3aac 32 6b fe			ld (debug_mark),a  
3aaf 3a be 3a			ld a, (.dmark+1)  
3ab2 32 6c fe			ld (debug_mark+1),a  
3ab5 3a bf 3a			ld a, (.dmark+2)  
3ab8 32 6d fe			ld (debug_mark+2),a  
3abb 18 03			jr .pastdmark  
3abd ..			.dmark: db "EQ1"  
3ac0 f1			.pastdmark: pop af  
3ac1			endm  
# End of macro DMARK
3ac1						CALLMONITOR 
3ac1 cd 6f fe			call debug_vector  
3ac4				endm  
# End of macro CALLMONITOR
3ac4					endif 
3ac4 cd c2 20				call forth_push_numhl 
3ac7			 
3ac7					NEXTW 
3ac7 c3 6f 24			jp macro_next 
3aca				endm 
# End of macro NEXTW
3aca			 
3aca			 
3aca			.ENDLOGIC: 
3aca			; eof 
3aca			 
3aca			 
# End of file forth_words_logic.asm
3aca			include "forth_words_maths.asm" 
3aca			 
3aca			; | ## Maths Words 
3aca			 
3aca			.PLUS:	 
3aca				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3aca 15				db WORD_SYS_CORE+1             
3acb 28 3b			dw .NEG            
3acd 02				db 1 + 1 
3ace .. 00			db "+",0              
3ad0				endm 
# End of macro CWHEAD
3ad0			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3ad0					if DEBUG_FORTH_WORDS_KEY 
3ad0						DMARK "PLU" 
3ad0 f5				push af  
3ad1 3a e5 3a			ld a, (.dmark)  
3ad4 32 6b fe			ld (debug_mark),a  
3ad7 3a e6 3a			ld a, (.dmark+1)  
3ada 32 6c fe			ld (debug_mark+1),a  
3add 3a e7 3a			ld a, (.dmark+2)  
3ae0 32 6d fe			ld (debug_mark+2),a  
3ae3 18 03			jr .pastdmark  
3ae5 ..			.dmark: db "PLU"  
3ae8 f1			.pastdmark: pop af  
3ae9			endm  
# End of macro DMARK
3ae9						CALLMONITOR 
3ae9 cd 6f fe			call debug_vector  
3aec				endm  
# End of macro CALLMONITOR
3aec					endif 
3aec					; add top two values and push back result 
3aec			 
3aec					;for v5 FORTH_DSP_VALUE 
3aec					FORTH_DSP 
3aec cd 7f 22			call macro_forth_dsp 
3aef				endm 
# End of macro FORTH_DSP
3aef 7e					ld a,(hl)	; get type of value on TOS 
3af0 fe 02				cp DS_TYPE_INUM  
3af2 28 03				jr z, .dot_inum 
3af4			 
3af4					NEXTW 
3af4 c3 6f 24			jp macro_next 
3af7				endm 
# End of macro NEXTW
3af7			 
3af7			; float maths 
3af7			 
3af7				if FORTH_ENABLE_FLOATMATH 
3af7						inc hl      ; now at start of numeric as string 
3af7			 
3af7					if DEBUG_FORTH_MATHS 
3af7						DMARK "ADD" 
3af7				CALLMONITOR 
3af7					endif 
3af7			 
3af7					;ld ix, hl 
3af7					call CON 
3af7			 
3af7			 
3af7					push hl 
3af7					 
3af7					 
3af7			 
3af7						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3af7			 
3af7					; get next number 
3af7			 
3af7						FORTH_DSP_VALUE 
3af7			 
3af7						inc hl      ; now at start of numeric as string 
3af7			 
3af7					;ld ix, hl 
3af7					call CON 
3af7			 
3af7					push hl 
3af7			 
3af7			 
3af7						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3af7			 
3af7						; TODO do add 
3af7			 
3af7						call IADD 
3af7			 
3af7						; TODO get result back as ascii 
3af7			 
3af7						; TODO push result  
3af7			 
3af7			 
3af7			 
3af7						jr .dot_done 
3af7				endif 
3af7			 
3af7			.dot_inum: 
3af7			 
3af7			 
3af7					if DEBUG_FORTH_DOT 
3af7						DMARK "+IT" 
3af7 f5				push af  
3af8 3a 0c 3b			ld a, (.dmark)  
3afb 32 6b fe			ld (debug_mark),a  
3afe 3a 0d 3b			ld a, (.dmark+1)  
3b01 32 6c fe			ld (debug_mark+1),a  
3b04 3a 0e 3b			ld a, (.dmark+2)  
3b07 32 6d fe			ld (debug_mark+2),a  
3b0a 18 03			jr .pastdmark  
3b0c ..			.dmark: db "+IT"  
3b0f f1			.pastdmark: pop af  
3b10			endm  
# End of macro DMARK
3b10				CALLMONITOR 
3b10 cd 6f fe			call debug_vector  
3b13				endm  
# End of macro CALLMONITOR
3b13					endif 
3b13			 
3b13					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b13 cd b9 22			call macro_dsp_valuehl 
3b16				endm 
# End of macro FORTH_DSP_VALUEHL
3b16			 
3b16				; TODO add floating point number detection 
3b16			 
3b16 e5					push hl 
3b17			 
3b17					; destroy value TOS 
3b17			 
3b17					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b17 cd 71 23			call macro_forth_dsp_pop 
3b1a				endm 
# End of macro FORTH_DSP_POP
3b1a			 
3b1a			 
3b1a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b1a cd b9 22			call macro_dsp_valuehl 
3b1d				endm 
# End of macro FORTH_DSP_VALUEHL
3b1d			 
3b1d					; one value on hl get other one back 
3b1d			 
3b1d d1					pop de 
3b1e			 
3b1e					; do the add 
3b1e			 
3b1e 19					add hl,de 
3b1f			 
3b1f					; save it 
3b1f			 
3b1f			;		push hl	 
3b1f			 
3b1f					; 
3b1f			 
3b1f					; destroy value TOS 
3b1f			 
3b1f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b1f cd 71 23			call macro_forth_dsp_pop 
3b22				endm 
# End of macro FORTH_DSP_POP
3b22			 
3b22					; TODO push value back onto stack for another op etc 
3b22			 
3b22			;		pop hl 
3b22			 
3b22			.dot_done: 
3b22 cd c2 20				call forth_push_numhl 
3b25			 
3b25					NEXTW 
3b25 c3 6f 24			jp macro_next 
3b28				endm 
# End of macro NEXTW
3b28			.NEG: 
3b28			 
3b28				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3b28 17				db WORD_SYS_CORE+3             
3b29 6b 3b			dw .DIV            
3b2b 02				db 1 + 1 
3b2c .. 00			db "-",0              
3b2e				endm 
# End of macro CWHEAD
3b2e			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3b2e					if DEBUG_FORTH_WORDS_KEY 
3b2e						DMARK "SUB" 
3b2e f5				push af  
3b2f 3a 43 3b			ld a, (.dmark)  
3b32 32 6b fe			ld (debug_mark),a  
3b35 3a 44 3b			ld a, (.dmark+1)  
3b38 32 6c fe			ld (debug_mark+1),a  
3b3b 3a 45 3b			ld a, (.dmark+2)  
3b3e 32 6d fe			ld (debug_mark+2),a  
3b41 18 03			jr .pastdmark  
3b43 ..			.dmark: db "SUB"  
3b46 f1			.pastdmark: pop af  
3b47			endm  
# End of macro DMARK
3b47						CALLMONITOR 
3b47 cd 6f fe			call debug_vector  
3b4a				endm  
# End of macro CALLMONITOR
3b4a					endif 
3b4a			 
3b4a			 
3b4a				; TODO add floating point number detection 
3b4a					; v5 FORTH_DSP_VALUE 
3b4a					FORTH_DSP 
3b4a cd 7f 22			call macro_forth_dsp 
3b4d				endm 
# End of macro FORTH_DSP
3b4d 7e					ld a,(hl)	; get type of value on TOS 
3b4e fe 02				cp DS_TYPE_INUM  
3b50 28 03				jr z, .neg_inum 
3b52			 
3b52					NEXTW 
3b52 c3 6f 24			jp macro_next 
3b55				endm 
# End of macro NEXTW
3b55			 
3b55			; float maths 
3b55			 
3b55				if FORTH_ENABLE_FLOATMATH 
3b55					jr .neg_done 
3b55			 
3b55				endif 
3b55					 
3b55			 
3b55			.neg_inum: 
3b55					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b55 cd b9 22			call macro_dsp_valuehl 
3b58				endm 
# End of macro FORTH_DSP_VALUEHL
3b58			 
3b58 e5					push hl 
3b59			 
3b59					; destroy value TOS 
3b59			 
3b59					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b59 cd 71 23			call macro_forth_dsp_pop 
3b5c				endm 
# End of macro FORTH_DSP_POP
3b5c			 
3b5c			 
3b5c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b5c cd b9 22			call macro_dsp_valuehl 
3b5f				endm 
# End of macro FORTH_DSP_VALUEHL
3b5f			 
3b5f					; one value on hl get other one back 
3b5f			 
3b5f d1					pop de 
3b60			 
3b60					; do the sub 
3b60			;		ex de, hl 
3b60			 
3b60 ed 52				sbc hl,de 
3b62			 
3b62					; save it 
3b62			 
3b62			;		push hl	 
3b62			 
3b62					; 
3b62			 
3b62					; destroy value TOS 
3b62			 
3b62					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b62 cd 71 23			call macro_forth_dsp_pop 
3b65				endm 
# End of macro FORTH_DSP_POP
3b65			 
3b65					; TODO push value back onto stack for another op etc 
3b65			 
3b65			;		pop hl 
3b65			 
3b65 cd c2 20				call forth_push_numhl 
3b68			.neg_done: 
3b68			 
3b68					NEXTW 
3b68 c3 6f 24			jp macro_next 
3b6b				endm 
# End of macro NEXTW
3b6b			.DIV: 
3b6b				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3b6b 18				db WORD_SYS_CORE+4             
3b6c b8 3b			dw .MUL            
3b6e 02				db 1 + 1 
3b6f .. 00			db "/",0              
3b71				endm 
# End of macro CWHEAD
3b71			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3b71					if DEBUG_FORTH_WORDS_KEY 
3b71						DMARK "DIV" 
3b71 f5				push af  
3b72 3a 86 3b			ld a, (.dmark)  
3b75 32 6b fe			ld (debug_mark),a  
3b78 3a 87 3b			ld a, (.dmark+1)  
3b7b 32 6c fe			ld (debug_mark+1),a  
3b7e 3a 88 3b			ld a, (.dmark+2)  
3b81 32 6d fe			ld (debug_mark+2),a  
3b84 18 03			jr .pastdmark  
3b86 ..			.dmark: db "DIV"  
3b89 f1			.pastdmark: pop af  
3b8a			endm  
# End of macro DMARK
3b8a						CALLMONITOR 
3b8a cd 6f fe			call debug_vector  
3b8d				endm  
# End of macro CALLMONITOR
3b8d					endif 
3b8d				; TODO add floating point number detection 
3b8d					; v5 FORTH_DSP_VALUE 
3b8d					FORTH_DSP 
3b8d cd 7f 22			call macro_forth_dsp 
3b90				endm 
# End of macro FORTH_DSP
3b90 7e					ld a,(hl)	; get type of value on TOS 
3b91 fe 02				cp DS_TYPE_INUM  
3b93 28 03				jr z, .div_inum 
3b95			 
3b95				if FORTH_ENABLE_FLOATMATH 
3b95					jr .div_done 
3b95			 
3b95				endif 
3b95					NEXTW 
3b95 c3 6f 24			jp macro_next 
3b98				endm 
# End of macro NEXTW
3b98			.div_inum: 
3b98			 
3b98					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b98 cd b9 22			call macro_dsp_valuehl 
3b9b				endm 
# End of macro FORTH_DSP_VALUEHL
3b9b			 
3b9b e5					push hl    ; to go to bc 
3b9c			 
3b9c					; destroy value TOS 
3b9c			 
3b9c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b9c cd 71 23			call macro_forth_dsp_pop 
3b9f				endm 
# End of macro FORTH_DSP_POP
3b9f			 
3b9f			 
3b9f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b9f cd b9 22			call macro_dsp_valuehl 
3ba2				endm 
# End of macro FORTH_DSP_VALUEHL
3ba2			 
3ba2					; hl to go to de 
3ba2			 
3ba2 e5					push hl 
3ba3			 
3ba3 c1					pop bc 
3ba4 d1					pop de		 
3ba5			 
3ba5			 
3ba5					if DEBUG_FORTH_MATHS 
3ba5						DMARK "DIV" 
3ba5				CALLMONITOR 
3ba5					endif 
3ba5					; one value on hl but move to a get other one back 
3ba5			 
3ba5			        
3ba5 cd e3 0e			call Div16 
3ba8			 
3ba8			;	push af	 
3ba8 e5				push hl 
3ba9 c5				push bc 
3baa			 
3baa					if DEBUG_FORTH_MATHS 
3baa						DMARK "DI1" 
3baa				CALLMONITOR 
3baa					endif 
3baa			 
3baa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3baa cd 71 23			call macro_forth_dsp_pop 
3bad				endm 
# End of macro FORTH_DSP_POP
3bad			 
3bad			 
3bad			 
3bad e1					pop hl    ; result 
3bae			 
3bae cd c2 20				call forth_push_numhl 
3bb1			 
3bb1 e1					pop hl    ; reminder 
3bb2			;		ld h,0 
3bb2			;		ld l,d 
3bb2			 
3bb2 cd c2 20				call forth_push_numhl 
3bb5			.div_done: 
3bb5					NEXTW 
3bb5 c3 6f 24			jp macro_next 
3bb8				endm 
# End of macro NEXTW
3bb8			.MUL: 
3bb8				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3bb8 19				db WORD_SYS_CORE+5             
3bb9 fd 3b			dw .MIN            
3bbb 02				db 1 + 1 
3bbc .. 00			db "*",0              
3bbe				endm 
# End of macro CWHEAD
3bbe			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3bbe				; TODO add floating point number detection 
3bbe					if DEBUG_FORTH_WORDS_KEY 
3bbe						DMARK "MUL" 
3bbe f5				push af  
3bbf 3a d3 3b			ld a, (.dmark)  
3bc2 32 6b fe			ld (debug_mark),a  
3bc5 3a d4 3b			ld a, (.dmark+1)  
3bc8 32 6c fe			ld (debug_mark+1),a  
3bcb 3a d5 3b			ld a, (.dmark+2)  
3bce 32 6d fe			ld (debug_mark+2),a  
3bd1 18 03			jr .pastdmark  
3bd3 ..			.dmark: db "MUL"  
3bd6 f1			.pastdmark: pop af  
3bd7			endm  
# End of macro DMARK
3bd7						CALLMONITOR 
3bd7 cd 6f fe			call debug_vector  
3bda				endm  
# End of macro CALLMONITOR
3bda					endif 
3bda					FORTH_DSP 
3bda cd 7f 22			call macro_forth_dsp 
3bdd				endm 
# End of macro FORTH_DSP
3bdd					; v5 FORTH_DSP_VALUE 
3bdd 7e					ld a,(hl)	; get type of value on TOS 
3bde fe 02				cp DS_TYPE_INUM  
3be0 28 03				jr z, .mul_inum 
3be2			 
3be2				if FORTH_ENABLE_FLOATMATH 
3be2					jr .mul_done 
3be2			 
3be2				endif 
3be2			 
3be2					NEXTW 
3be2 c3 6f 24			jp macro_next 
3be5				endm 
# End of macro NEXTW
3be5			.mul_inum:	 
3be5			 
3be5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3be5 cd b9 22			call macro_dsp_valuehl 
3be8				endm 
# End of macro FORTH_DSP_VALUEHL
3be8			 
3be8 e5					push hl 
3be9			 
3be9					; destroy value TOS 
3be9			 
3be9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3be9 cd 71 23			call macro_forth_dsp_pop 
3bec				endm 
# End of macro FORTH_DSP_POP
3bec			 
3bec			 
3bec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bec cd b9 22			call macro_dsp_valuehl 
3bef				endm 
# End of macro FORTH_DSP_VALUEHL
3bef			 
3bef					; one value on hl but move to a get other one back 
3bef			 
3bef 7d					ld a, l 
3bf0			 
3bf0 d1					pop de 
3bf1			 
3bf1					; do the mull 
3bf1			;		ex de, hl 
3bf1			 
3bf1 cd 09 0f				call Mult16 
3bf4					; save it 
3bf4			 
3bf4			;		push hl	 
3bf4			 
3bf4					; 
3bf4			 
3bf4					; destroy value TOS 
3bf4			 
3bf4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bf4 cd 71 23			call macro_forth_dsp_pop 
3bf7				endm 
# End of macro FORTH_DSP_POP
3bf7			 
3bf7					; TODO push value back onto stack for another op etc 
3bf7			 
3bf7			;		pop hl 
3bf7			 
3bf7 cd c2 20				call forth_push_numhl 
3bfa			 
3bfa			.mul_done: 
3bfa					NEXTW 
3bfa c3 6f 24			jp macro_next 
3bfd				endm 
# End of macro NEXTW
3bfd			 
3bfd			 
3bfd			 
3bfd			 
3bfd			.MIN: 
3bfd				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3bfd 49				db WORD_SYS_CORE+53             
3bfe 7e 3c			dw .MAX            
3c00 04				db 3 + 1 
3c01 .. 00			db "MIN",0              
3c05				endm 
# End of macro CWHEAD
3c05			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3c05					if DEBUG_FORTH_WORDS_KEY 
3c05						DMARK "MIN" 
3c05 f5				push af  
3c06 3a 1a 3c			ld a, (.dmark)  
3c09 32 6b fe			ld (debug_mark),a  
3c0c 3a 1b 3c			ld a, (.dmark+1)  
3c0f 32 6c fe			ld (debug_mark+1),a  
3c12 3a 1c 3c			ld a, (.dmark+2)  
3c15 32 6d fe			ld (debug_mark+2),a  
3c18 18 03			jr .pastdmark  
3c1a ..			.dmark: db "MIN"  
3c1d f1			.pastdmark: pop af  
3c1e			endm  
# End of macro DMARK
3c1e						CALLMONITOR 
3c1e cd 6f fe			call debug_vector  
3c21				endm  
# End of macro CALLMONITOR
3c21					endif 
3c21					; get u2 
3c21			 
3c21					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c21 cd b9 22			call macro_dsp_valuehl 
3c24				endm 
# End of macro FORTH_DSP_VALUEHL
3c24			 
3c24 e5					push hl   ; u2 
3c25			 
3c25					; destroy value TOS 
3c25			 
3c25					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c25 cd 71 23			call macro_forth_dsp_pop 
3c28				endm 
# End of macro FORTH_DSP_POP
3c28			 
3c28					; get u1 
3c28			 
3c28					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c28 cd b9 22			call macro_dsp_valuehl 
3c2b				endm 
# End of macro FORTH_DSP_VALUEHL
3c2b			 
3c2b e5					push hl  ; u1 
3c2c			 
3c2c					; destroy value TOS 
3c2c			 
3c2c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c2c cd 71 23			call macro_forth_dsp_pop 
3c2f				endm 
# End of macro FORTH_DSP_POP
3c2f			 
3c2f b7			 or a      ;clear carry flag 
3c30 e1			  pop hl    ; u1 
3c31 d1			  pop de    ; u2 
3c32 e5				push hl   ; saved in case hl is lowest 
3c33 ed 52		  sbc hl,de 
3c35 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3c37			 
3c37 e1				pop hl 
3c38					if DEBUG_FORTH_WORDS 
3c38						DMARK "MIN" 
3c38 f5				push af  
3c39 3a 4d 3c			ld a, (.dmark)  
3c3c 32 6b fe			ld (debug_mark),a  
3c3f 3a 4e 3c			ld a, (.dmark+1)  
3c42 32 6c fe			ld (debug_mark+1),a  
3c45 3a 4f 3c			ld a, (.dmark+2)  
3c48 32 6d fe			ld (debug_mark+2),a  
3c4b 18 03			jr .pastdmark  
3c4d ..			.dmark: db "MIN"  
3c50 f1			.pastdmark: pop af  
3c51			endm  
# End of macro DMARK
3c51						CALLMONITOR 
3c51 cd 6f fe			call debug_vector  
3c54				endm  
# End of macro CALLMONITOR
3c54					endif 
3c54 cd c2 20				call forth_push_numhl 
3c57			 
3c57				       NEXTW 
3c57 c3 6f 24			jp macro_next 
3c5a				endm 
# End of macro NEXTW
3c5a			 
3c5a			.mincont:  
3c5a c1				pop bc   ; tidy up 
3c5b eb				ex de , hl  
3c5c					if DEBUG_FORTH_WORDS 
3c5c						DMARK "MI1" 
3c5c f5				push af  
3c5d 3a 71 3c			ld a, (.dmark)  
3c60 32 6b fe			ld (debug_mark),a  
3c63 3a 72 3c			ld a, (.dmark+1)  
3c66 32 6c fe			ld (debug_mark+1),a  
3c69 3a 73 3c			ld a, (.dmark+2)  
3c6c 32 6d fe			ld (debug_mark+2),a  
3c6f 18 03			jr .pastdmark  
3c71 ..			.dmark: db "MI1"  
3c74 f1			.pastdmark: pop af  
3c75			endm  
# End of macro DMARK
3c75						CALLMONITOR 
3c75 cd 6f fe			call debug_vector  
3c78				endm  
# End of macro CALLMONITOR
3c78					endif 
3c78 cd c2 20				call forth_push_numhl 
3c7b			 
3c7b				       NEXTW 
3c7b c3 6f 24			jp macro_next 
3c7e				endm 
# End of macro NEXTW
3c7e			.MAX: 
3c7e				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3c7e 4a				db WORD_SYS_CORE+54             
3c7f ff 3c			dw .RND16            
3c81 04				db 3 + 1 
3c82 .. 00			db "MAX",0              
3c86				endm 
# End of macro CWHEAD
3c86			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3c86					if DEBUG_FORTH_WORDS_KEY 
3c86						DMARK "MAX" 
3c86 f5				push af  
3c87 3a 9b 3c			ld a, (.dmark)  
3c8a 32 6b fe			ld (debug_mark),a  
3c8d 3a 9c 3c			ld a, (.dmark+1)  
3c90 32 6c fe			ld (debug_mark+1),a  
3c93 3a 9d 3c			ld a, (.dmark+2)  
3c96 32 6d fe			ld (debug_mark+2),a  
3c99 18 03			jr .pastdmark  
3c9b ..			.dmark: db "MAX"  
3c9e f1			.pastdmark: pop af  
3c9f			endm  
# End of macro DMARK
3c9f						CALLMONITOR 
3c9f cd 6f fe			call debug_vector  
3ca2				endm  
# End of macro CALLMONITOR
3ca2					endif 
3ca2					; get u2 
3ca2			 
3ca2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ca2 cd b9 22			call macro_dsp_valuehl 
3ca5				endm 
# End of macro FORTH_DSP_VALUEHL
3ca5			 
3ca5 e5					push hl   ; u2 
3ca6			 
3ca6					; destroy value TOS 
3ca6			 
3ca6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ca6 cd 71 23			call macro_forth_dsp_pop 
3ca9				endm 
# End of macro FORTH_DSP_POP
3ca9			 
3ca9					; get u1 
3ca9			 
3ca9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ca9 cd b9 22			call macro_dsp_valuehl 
3cac				endm 
# End of macro FORTH_DSP_VALUEHL
3cac			 
3cac e5					push hl  ; u1 
3cad			 
3cad					; destroy value TOS 
3cad			 
3cad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cad cd 71 23			call macro_forth_dsp_pop 
3cb0				endm 
# End of macro FORTH_DSP_POP
3cb0			 
3cb0 b7			 or a      ;clear carry flag 
3cb1 e1			  pop hl    ; u1 
3cb2 d1			  pop de    ; u2 
3cb3 e5				push hl   ; saved in case hl is lowest 
3cb4 ed 52		  sbc hl,de 
3cb6 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3cb8			 
3cb8 e1				pop hl 
3cb9					if DEBUG_FORTH_WORDS 
3cb9						DMARK "MAX" 
3cb9 f5				push af  
3cba 3a ce 3c			ld a, (.dmark)  
3cbd 32 6b fe			ld (debug_mark),a  
3cc0 3a cf 3c			ld a, (.dmark+1)  
3cc3 32 6c fe			ld (debug_mark+1),a  
3cc6 3a d0 3c			ld a, (.dmark+2)  
3cc9 32 6d fe			ld (debug_mark+2),a  
3ccc 18 03			jr .pastdmark  
3cce ..			.dmark: db "MAX"  
3cd1 f1			.pastdmark: pop af  
3cd2			endm  
# End of macro DMARK
3cd2						CALLMONITOR 
3cd2 cd 6f fe			call debug_vector  
3cd5				endm  
# End of macro CALLMONITOR
3cd5					endif 
3cd5 cd c2 20				call forth_push_numhl 
3cd8			 
3cd8				       NEXTW 
3cd8 c3 6f 24			jp macro_next 
3cdb				endm 
# End of macro NEXTW
3cdb			 
3cdb			.maxcont:  
3cdb c1				pop bc   ; tidy up 
3cdc eb				ex de , hl  
3cdd					if DEBUG_FORTH_WORDS 
3cdd						DMARK "MA1" 
3cdd f5				push af  
3cde 3a f2 3c			ld a, (.dmark)  
3ce1 32 6b fe			ld (debug_mark),a  
3ce4 3a f3 3c			ld a, (.dmark+1)  
3ce7 32 6c fe			ld (debug_mark+1),a  
3cea 3a f4 3c			ld a, (.dmark+2)  
3ced 32 6d fe			ld (debug_mark+2),a  
3cf0 18 03			jr .pastdmark  
3cf2 ..			.dmark: db "MA1"  
3cf5 f1			.pastdmark: pop af  
3cf6			endm  
# End of macro DMARK
3cf6						CALLMONITOR 
3cf6 cd 6f fe			call debug_vector  
3cf9				endm  
# End of macro CALLMONITOR
3cf9					endif 
3cf9 cd c2 20				call forth_push_numhl 
3cfc				       NEXTW 
3cfc c3 6f 24			jp macro_next 
3cff				endm 
# End of macro NEXTW
3cff			 
3cff			.RND16: 
3cff				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3cff 4e				db WORD_SYS_CORE+58             
3d00 2e 3d			dw .RND8            
3d02 06				db 5 + 1 
3d03 .. 00			db "RND16",0              
3d09				endm 
# End of macro CWHEAD
3d09			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3d09					if DEBUG_FORTH_WORDS_KEY 
3d09						DMARK "R16" 
3d09 f5				push af  
3d0a 3a 1e 3d			ld a, (.dmark)  
3d0d 32 6b fe			ld (debug_mark),a  
3d10 3a 1f 3d			ld a, (.dmark+1)  
3d13 32 6c fe			ld (debug_mark+1),a  
3d16 3a 20 3d			ld a, (.dmark+2)  
3d19 32 6d fe			ld (debug_mark+2),a  
3d1c 18 03			jr .pastdmark  
3d1e ..			.dmark: db "R16"  
3d21 f1			.pastdmark: pop af  
3d22			endm  
# End of macro DMARK
3d22						CALLMONITOR 
3d22 cd 6f fe			call debug_vector  
3d25				endm  
# End of macro CALLMONITOR
3d25					endif 
3d25 cd ad 0e				call prng16  
3d28 cd c2 20				call forth_push_numhl 
3d2b				       NEXTW 
3d2b c3 6f 24			jp macro_next 
3d2e				endm 
# End of macro NEXTW
3d2e			.RND8: 
3d2e				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3d2e 60				db WORD_SYS_CORE+76             
3d2f 63 3d			dw .RND            
3d31 05				db 4 + 1 
3d32 .. 00			db "RND8",0              
3d37				endm 
# End of macro CWHEAD
3d37			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3d37					if DEBUG_FORTH_WORDS_KEY 
3d37						DMARK "RN8" 
3d37 f5				push af  
3d38 3a 4c 3d			ld a, (.dmark)  
3d3b 32 6b fe			ld (debug_mark),a  
3d3e 3a 4d 3d			ld a, (.dmark+1)  
3d41 32 6c fe			ld (debug_mark+1),a  
3d44 3a 4e 3d			ld a, (.dmark+2)  
3d47 32 6d fe			ld (debug_mark+2),a  
3d4a 18 03			jr .pastdmark  
3d4c ..			.dmark: db "RN8"  
3d4f f1			.pastdmark: pop af  
3d50			endm  
# End of macro DMARK
3d50						CALLMONITOR 
3d50 cd 6f fe			call debug_vector  
3d53				endm  
# End of macro CALLMONITOR
3d53					endif 
3d53 2a a9 fb				ld hl,(xrandc) 
3d56 23					inc hl 
3d57 cd c7 0e				call xrnd 
3d5a 6f					ld l,a	 
3d5b 26 00				ld h,0 
3d5d cd c2 20				call forth_push_numhl 
3d60				       NEXTW 
3d60 c3 6f 24			jp macro_next 
3d63				endm 
# End of macro NEXTW
3d63			.RND: 
3d63				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3d63 60				db WORD_SYS_CORE+76             
3d64 69 3e			dw .ENDMATHS            
3d66 04				db 3 + 1 
3d67 .. 00			db "RND",0              
3d6b				endm 
# End of macro CWHEAD
3d6b			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3d6b			 
3d6b					if DEBUG_FORTH_WORDS_KEY 
3d6b						DMARK "RND" 
3d6b f5				push af  
3d6c 3a 80 3d			ld a, (.dmark)  
3d6f 32 6b fe			ld (debug_mark),a  
3d72 3a 81 3d			ld a, (.dmark+1)  
3d75 32 6c fe			ld (debug_mark+1),a  
3d78 3a 82 3d			ld a, (.dmark+2)  
3d7b 32 6d fe			ld (debug_mark+2),a  
3d7e 18 03			jr .pastdmark  
3d80 ..			.dmark: db "RND"  
3d83 f1			.pastdmark: pop af  
3d84			endm  
# End of macro DMARK
3d84						CALLMONITOR 
3d84 cd 6f fe			call debug_vector  
3d87				endm  
# End of macro CALLMONITOR
3d87					endif 
3d87					 
3d87					FORTH_DSP_VALUEHL    ; upper range 
3d87 cd b9 22			call macro_dsp_valuehl 
3d8a				endm 
# End of macro FORTH_DSP_VALUEHL
3d8a			 
3d8a 22 ad fb				ld (LFSRSeed), hl	 
3d8d			 
3d8d					if DEBUG_FORTH_WORDS 
3d8d						DMARK "RN1" 
3d8d f5				push af  
3d8e 3a a2 3d			ld a, (.dmark)  
3d91 32 6b fe			ld (debug_mark),a  
3d94 3a a3 3d			ld a, (.dmark+1)  
3d97 32 6c fe			ld (debug_mark+1),a  
3d9a 3a a4 3d			ld a, (.dmark+2)  
3d9d 32 6d fe			ld (debug_mark+2),a  
3da0 18 03			jr .pastdmark  
3da2 ..			.dmark: db "RN1"  
3da5 f1			.pastdmark: pop af  
3da6			endm  
# End of macro DMARK
3da6						CALLMONITOR 
3da6 cd 6f fe			call debug_vector  
3da9				endm  
# End of macro CALLMONITOR
3da9					endif 
3da9					FORTH_DSP_POP 
3da9 cd 71 23			call macro_forth_dsp_pop 
3dac				endm 
# End of macro FORTH_DSP_POP
3dac			 
3dac					FORTH_DSP_VALUEHL    ; low range 
3dac cd b9 22			call macro_dsp_valuehl 
3daf				endm 
# End of macro FORTH_DSP_VALUEHL
3daf			 
3daf					if DEBUG_FORTH_WORDS 
3daf						DMARK "RN2" 
3daf f5				push af  
3db0 3a c4 3d			ld a, (.dmark)  
3db3 32 6b fe			ld (debug_mark),a  
3db6 3a c5 3d			ld a, (.dmark+1)  
3db9 32 6c fe			ld (debug_mark+1),a  
3dbc 3a c6 3d			ld a, (.dmark+2)  
3dbf 32 6d fe			ld (debug_mark+2),a  
3dc2 18 03			jr .pastdmark  
3dc4 ..			.dmark: db "RN2"  
3dc7 f1			.pastdmark: pop af  
3dc8			endm  
# End of macro DMARK
3dc8						CALLMONITOR 
3dc8 cd 6f fe			call debug_vector  
3dcb				endm  
# End of macro CALLMONITOR
3dcb					endif 
3dcb 22 af fb				ld (LFSRSeed+2), hl 
3dce			 
3dce					FORTH_DSP_POP 
3dce cd 71 23			call macro_forth_dsp_pop 
3dd1				endm 
# End of macro FORTH_DSP_POP
3dd1			 
3dd1 e5					push hl 
3dd2			 
3dd2 e1			.inrange:	pop hl 
3dd3 cd ad 0e				call prng16  
3dd6					if DEBUG_FORTH_WORDS 
3dd6						DMARK "RN3" 
3dd6 f5				push af  
3dd7 3a eb 3d			ld a, (.dmark)  
3dda 32 6b fe			ld (debug_mark),a  
3ddd 3a ec 3d			ld a, (.dmark+1)  
3de0 32 6c fe			ld (debug_mark+1),a  
3de3 3a ed 3d			ld a, (.dmark+2)  
3de6 32 6d fe			ld (debug_mark+2),a  
3de9 18 03			jr .pastdmark  
3deb ..			.dmark: db "RN3"  
3dee f1			.pastdmark: pop af  
3def			endm  
# End of macro DMARK
3def						CALLMONITOR 
3def cd 6f fe			call debug_vector  
3df2				endm  
# End of macro CALLMONITOR
3df2					endif 
3df2					 
3df2					; if the range is 8bit knock out the high byte 
3df2			 
3df2 ed 5b ad fb			ld de, (LFSRSeed)     ; check high level 
3df6			 
3df6 3e 00				ld a, 0 
3df8 ba					cp d  
3df9 20 1e				jr nz, .hirange 
3dfb 26 00				ld h, 0   ; knock it down to 8bit 
3dfd			 
3dfd					if DEBUG_FORTH_WORDS 
3dfd						DMARK "RNk" 
3dfd f5				push af  
3dfe 3a 12 3e			ld a, (.dmark)  
3e01 32 6b fe			ld (debug_mark),a  
3e04 3a 13 3e			ld a, (.dmark+1)  
3e07 32 6c fe			ld (debug_mark+1),a  
3e0a 3a 14 3e			ld a, (.dmark+2)  
3e0d 32 6d fe			ld (debug_mark+2),a  
3e10 18 03			jr .pastdmark  
3e12 ..			.dmark: db "RNk"  
3e15 f1			.pastdmark: pop af  
3e16			endm  
# End of macro DMARK
3e16						CALLMONITOR 
3e16 cd 6f fe			call debug_vector  
3e19				endm  
# End of macro CALLMONITOR
3e19					endif 
3e19			.hirange:   
3e19 e5					push hl  
3e1a b7					or a  
3e1b ed 52		                sbc hl, de 
3e1d			 
3e1d					;call cmp16 
3e1d			 
3e1d 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3e1f e1					pop hl 
3e20 e5					push hl 
3e21			 
3e21					if DEBUG_FORTH_WORDS 
3e21						DMARK "RN4" 
3e21 f5				push af  
3e22 3a 36 3e			ld a, (.dmark)  
3e25 32 6b fe			ld (debug_mark),a  
3e28 3a 37 3e			ld a, (.dmark+1)  
3e2b 32 6c fe			ld (debug_mark+1),a  
3e2e 3a 38 3e			ld a, (.dmark+2)  
3e31 32 6d fe			ld (debug_mark+2),a  
3e34 18 03			jr .pastdmark  
3e36 ..			.dmark: db "RN4"  
3e39 f1			.pastdmark: pop af  
3e3a			endm  
# End of macro DMARK
3e3a						CALLMONITOR 
3e3a cd 6f fe			call debug_vector  
3e3d				endm  
# End of macro CALLMONITOR
3e3d					endif 
3e3d ed 5b af fb			ld de, (LFSRSeed+2)   ; check low range 
3e41					;call cmp16 
3e41				 
3e41 b7					or a  
3e42 ed 52		                sbc hl, de 
3e44 38 8c				jr c, .inrange 
3e46			 
3e46 e1					pop hl 
3e47					 
3e47					if DEBUG_FORTH_WORDS 
3e47						DMARK "RNd" 
3e47 f5				push af  
3e48 3a 5c 3e			ld a, (.dmark)  
3e4b 32 6b fe			ld (debug_mark),a  
3e4e 3a 5d 3e			ld a, (.dmark+1)  
3e51 32 6c fe			ld (debug_mark+1),a  
3e54 3a 5e 3e			ld a, (.dmark+2)  
3e57 32 6d fe			ld (debug_mark+2),a  
3e5a 18 03			jr .pastdmark  
3e5c ..			.dmark: db "RNd"  
3e5f f1			.pastdmark: pop af  
3e60			endm  
# End of macro DMARK
3e60						CALLMONITOR 
3e60 cd 6f fe			call debug_vector  
3e63				endm  
# End of macro CALLMONITOR
3e63					endif 
3e63			 
3e63			 
3e63 cd c2 20				call forth_push_numhl 
3e66				       NEXTW 
3e66 c3 6f 24			jp macro_next 
3e69				endm 
# End of macro NEXTW
3e69			 
3e69			.ENDMATHS: 
3e69			 
3e69			; eof 
3e69			 
# End of file forth_words_maths.asm
3e69			include "forth_words_display.asm" 
3e69			 
3e69			; | ## Display Words 
3e69			 
3e69			.ACT: 
3e69			 
3e69				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3e69 62				db WORD_SYS_CORE+78             
3e6a b5 3e			dw .INFO            
3e6c 07				db 6 + 1 
3e6d .. 00			db "ACTIVE",0              
3e74				endm 
# End of macro CWHEAD
3e74			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3e74			;  
3e74			; | | e.g. $ff $00 do active . $01 pause loop 
3e74			 
3e74					if DEBUG_FORTH_WORDS_KEY 
3e74						DMARK "ACT" 
3e74 f5				push af  
3e75 3a 89 3e			ld a, (.dmark)  
3e78 32 6b fe			ld (debug_mark),a  
3e7b 3a 8a 3e			ld a, (.dmark+1)  
3e7e 32 6c fe			ld (debug_mark+1),a  
3e81 3a 8b 3e			ld a, (.dmark+2)  
3e84 32 6d fe			ld (debug_mark+2),a  
3e87 18 03			jr .pastdmark  
3e89 ..			.dmark: db "ACT"  
3e8c f1			.pastdmark: pop af  
3e8d			endm  
# End of macro DMARK
3e8d						CALLMONITOR 
3e8d cd 6f fe			call debug_vector  
3e90				endm  
# End of macro CALLMONITOR
3e90					endif 
3e90 cd a9 0c				call active 
3e93					if DEBUG_FORTH_WORDS 
3e93						DMARK "ACp" 
3e93 f5				push af  
3e94 3a a8 3e			ld a, (.dmark)  
3e97 32 6b fe			ld (debug_mark),a  
3e9a 3a a9 3e			ld a, (.dmark+1)  
3e9d 32 6c fe			ld (debug_mark+1),a  
3ea0 3a aa 3e			ld a, (.dmark+2)  
3ea3 32 6d fe			ld (debug_mark+2),a  
3ea6 18 03			jr .pastdmark  
3ea8 ..			.dmark: db "ACp"  
3eab f1			.pastdmark: pop af  
3eac			endm  
# End of macro DMARK
3eac						CALLMONITOR 
3eac cd 6f fe			call debug_vector  
3eaf				endm  
# End of macro CALLMONITOR
3eaf					endif 
3eaf cd 30 21				call forth_push_str 
3eb2			 
3eb2					NEXTW 
3eb2 c3 6f 24			jp macro_next 
3eb5				endm 
# End of macro NEXTW
3eb5			.INFO: 
3eb5			 
3eb5				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3eb5 62				db WORD_SYS_CORE+78             
3eb6 d2 3e			dw .ATP            
3eb8 05				db 4 + 1 
3eb9 .. 00			db "INFO",0              
3ebe				endm 
# End of macro CWHEAD
3ebe			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3ebe					FORTH_DSP_VALUEHL 
3ebe cd b9 22			call macro_dsp_valuehl 
3ec1				endm 
# End of macro FORTH_DSP_VALUEHL
3ec1			 
3ec1					FORTH_DSP_POP 
3ec1 cd 71 23			call macro_forth_dsp_pop 
3ec4				endm 
# End of macro FORTH_DSP_POP
3ec4			 
3ec4 e5					push hl 
3ec5			 
3ec5					FORTH_DSP_VALUEHL 
3ec5 cd b9 22			call macro_dsp_valuehl 
3ec8				endm 
# End of macro FORTH_DSP_VALUEHL
3ec8			 
3ec8					FORTH_DSP_POP 
3ec8 cd 71 23			call macro_forth_dsp_pop 
3ecb				endm 
# End of macro FORTH_DSP_POP
3ecb			 
3ecb d1					pop de 
3ecc			 
3ecc cd e3 0c				call info_panel 
3ecf			 
3ecf			 
3ecf					NEXTW 
3ecf c3 6f 24			jp macro_next 
3ed2				endm 
# End of macro NEXTW
3ed2			.ATP: 
3ed2				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3ed2 62				db WORD_SYS_CORE+78             
3ed3 49 3f			dw .FB            
3ed5 04				db 3 + 1 
3ed6 .. 00			db "AT?",0              
3eda				endm 
# End of macro CWHEAD
3eda			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3eda					if DEBUG_FORTH_WORDS_KEY 
3eda						DMARK "AT?" 
3eda f5				push af  
3edb 3a ef 3e			ld a, (.dmark)  
3ede 32 6b fe			ld (debug_mark),a  
3ee1 3a f0 3e			ld a, (.dmark+1)  
3ee4 32 6c fe			ld (debug_mark+1),a  
3ee7 3a f1 3e			ld a, (.dmark+2)  
3eea 32 6d fe			ld (debug_mark+2),a  
3eed 18 03			jr .pastdmark  
3eef ..			.dmark: db "AT?"  
3ef2 f1			.pastdmark: pop af  
3ef3			endm  
# End of macro DMARK
3ef3						CALLMONITOR 
3ef3 cd 6f fe			call debug_vector  
3ef6				endm  
# End of macro CALLMONITOR
3ef6					endif 
3ef6 3a 5e fa				ld a, (f_cursor_ptr) 
3ef9			 
3ef9			if DEBUG_FORTH_WORDS 
3ef9				DMARK "AT?" 
3ef9 f5				push af  
3efa 3a 0e 3f			ld a, (.dmark)  
3efd 32 6b fe			ld (debug_mark),a  
3f00 3a 0f 3f			ld a, (.dmark+1)  
3f03 32 6c fe			ld (debug_mark+1),a  
3f06 3a 10 3f			ld a, (.dmark+2)  
3f09 32 6d fe			ld (debug_mark+2),a  
3f0c 18 03			jr .pastdmark  
3f0e ..			.dmark: db "AT?"  
3f11 f1			.pastdmark: pop af  
3f12			endm  
# End of macro DMARK
3f12				CALLMONITOR 
3f12 cd 6f fe			call debug_vector  
3f15				endm  
# End of macro CALLMONITOR
3f15			endif	 
3f15					; count the number of rows 
3f15			 
3f15 06 00				ld b, 0 
3f17 4f			.atpr:		ld c, a    ; save in case we go below zero 
3f18 d6 28				sub display_cols 
3f1a f2 20 3f				jp p, .atprunder 
3f1d 04					inc b 
3f1e 18 f7				jr .atpr 
3f20			.atprunder:	 
3f20			if DEBUG_FORTH_WORDS 
3f20				DMARK "A?2" 
3f20 f5				push af  
3f21 3a 35 3f			ld a, (.dmark)  
3f24 32 6b fe			ld (debug_mark),a  
3f27 3a 36 3f			ld a, (.dmark+1)  
3f2a 32 6c fe			ld (debug_mark+1),a  
3f2d 3a 37 3f			ld a, (.dmark+2)  
3f30 32 6d fe			ld (debug_mark+2),a  
3f33 18 03			jr .pastdmark  
3f35 ..			.dmark: db "A?2"  
3f38 f1			.pastdmark: pop af  
3f39			endm  
# End of macro DMARK
3f39				CALLMONITOR 
3f39 cd 6f fe			call debug_vector  
3f3c				endm  
# End of macro CALLMONITOR
3f3c			endif	 
3f3c 26 00				ld h, 0 
3f3e 69					ld l, c 
3f3f cd c2 20				call forth_push_numhl 
3f42 68					ld l, b  
3f43 cd c2 20				call forth_push_numhl 
3f46			 
3f46			 
3f46				NEXTW 
3f46 c3 6f 24			jp macro_next 
3f49				endm 
# End of macro NEXTW
3f49			 
3f49			.FB: 
3f49				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3f49 1b				db WORD_SYS_CORE+7             
3f4a 97 3f			dw .EMIT            
3f4c 03				db 2 + 1 
3f4d .. 00			db "FB",0              
3f50				endm 
# End of macro CWHEAD
3f50			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3f50			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3f50			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3f50			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3f50					if DEBUG_FORTH_WORDS_KEY 
3f50						DMARK "FB." 
3f50 f5				push af  
3f51 3a 65 3f			ld a, (.dmark)  
3f54 32 6b fe			ld (debug_mark),a  
3f57 3a 66 3f			ld a, (.dmark+1)  
3f5a 32 6c fe			ld (debug_mark+1),a  
3f5d 3a 67 3f			ld a, (.dmark+2)  
3f60 32 6d fe			ld (debug_mark+2),a  
3f63 18 03			jr .pastdmark  
3f65 ..			.dmark: db "FB."  
3f68 f1			.pastdmark: pop af  
3f69			endm  
# End of macro DMARK
3f69						CALLMONITOR 
3f69 cd 6f fe			call debug_vector  
3f6c				endm  
# End of macro CALLMONITOR
3f6c					endif 
3f6c			 
3f6c					FORTH_DSP_VALUEHL 
3f6c cd b9 22			call macro_dsp_valuehl 
3f6f				endm 
# End of macro FORTH_DSP_VALUEHL
3f6f			 
3f6f 7d					ld a, l 
3f70 fe 01				cp 1 
3f72 20 05				jr nz, .fbn1 
3f74 21 10 fd				ld hl, display_fb1 
3f77 18 15				jr .fbset 
3f79 fe 02		.fbn1:		cp 2 
3f7b 20 05				jr nz, .fbn2 
3f7d 21 ce fb				ld hl, display_fb2 
3f80 18 0c				jr .fbset 
3f82 fe 03		.fbn2:		cp 3 
3f84 20 05				jr nz, .fbn3 
3f86 21 6f fc				ld hl, display_fb3 
3f89 18 03				jr .fbset 
3f8b			.fbn3:		 ; if invalid number select first 
3f8b 21 10 fd				ld hl, display_fb1 
3f8e 22 cc fb		.fbset:		ld (display_fb_active), hl 
3f91			 
3f91					FORTH_DSP_POP 
3f91 cd 71 23			call macro_forth_dsp_pop 
3f94				endm 
# End of macro FORTH_DSP_POP
3f94			 
3f94					NEXTW 
3f94 c3 6f 24			jp macro_next 
3f97				endm 
# End of macro NEXTW
3f97			 
3f97			 
3f97			.EMIT: 
3f97				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3f97 1b				db WORD_SYS_CORE+7             
3f98 e8 3f			dw .DOTH            
3f9a 05				db 4 + 1 
3f9b .. 00			db "EMIT",0              
3fa0				endm 
# End of macro CWHEAD
3fa0			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3fa0					; get value off TOS and display it 
3fa0			 
3fa0					if DEBUG_FORTH_WORDS_KEY 
3fa0						DMARK "EMT" 
3fa0 f5				push af  
3fa1 3a b5 3f			ld a, (.dmark)  
3fa4 32 6b fe			ld (debug_mark),a  
3fa7 3a b6 3f			ld a, (.dmark+1)  
3faa 32 6c fe			ld (debug_mark+1),a  
3fad 3a b7 3f			ld a, (.dmark+2)  
3fb0 32 6d fe			ld (debug_mark+2),a  
3fb3 18 03			jr .pastdmark  
3fb5 ..			.dmark: db "EMT"  
3fb8 f1			.pastdmark: pop af  
3fb9			endm  
# End of macro DMARK
3fb9						CALLMONITOR 
3fb9 cd 6f fe			call debug_vector  
3fbc				endm  
# End of macro CALLMONITOR
3fbc					endif 
3fbc			 
3fbc					FORTH_DSP_VALUEHL 
3fbc cd b9 22			call macro_dsp_valuehl 
3fbf				endm 
# End of macro FORTH_DSP_VALUEHL
3fbf			 
3fbf 7d					ld a,l 
3fc0			 
3fc0					; TODO write to display 
3fc0			 
3fc0 32 bf f3				ld (os_input), a 
3fc3 3e 00				ld a, 0 
3fc5 32 c0 f3				ld (os_input+1), a 
3fc8					 
3fc8 3a 5e fa				ld a, (f_cursor_ptr) 
3fcb 11 bf f3				ld de, os_input 
3fce cd 65 0d				call str_at_display 
3fd1			 
3fd1			 
3fd1 3a 3c fa				ld a,(cli_autodisplay) 
3fd4 fe 00				cp 0 
3fd6 28 03				jr z, .enoupdate 
3fd8 cd 75 0d						call update_display 
3fdb					.enoupdate: 
3fdb			 
3fdb 3a 5e fa				ld a, (f_cursor_ptr) 
3fde 3c					inc a 
3fdf 32 5e fa				ld (f_cursor_ptr), a   ; save new pos 
3fe2			 
3fe2			 
3fe2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fe2 cd 71 23			call macro_forth_dsp_pop 
3fe5				endm 
# End of macro FORTH_DSP_POP
3fe5			  
3fe5			 
3fe5					NEXTW 
3fe5 c3 6f 24			jp macro_next 
3fe8				endm 
# End of macro NEXTW
3fe8			.DOTH: 
3fe8				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3fe8 1c				db WORD_SYS_CORE+8             
3fe9 18 40			dw .DOTF            
3feb 03				db 2 + 1 
3fec .. 00			db ".-",0              
3fef				endm 
# End of macro CWHEAD
3fef			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3fef					; get value off TOS and display it 
3fef					if DEBUG_FORTH_WORDS_KEY 
3fef						DMARK "DTD" 
3fef f5				push af  
3ff0 3a 04 40			ld a, (.dmark)  
3ff3 32 6b fe			ld (debug_mark),a  
3ff6 3a 05 40			ld a, (.dmark+1)  
3ff9 32 6c fe			ld (debug_mark+1),a  
3ffc 3a 06 40			ld a, (.dmark+2)  
3fff 32 6d fe			ld (debug_mark+2),a  
4002 18 03			jr .pastdmark  
4004 ..			.dmark: db "DTD"  
4007 f1			.pastdmark: pop af  
4008			endm  
# End of macro DMARK
4008						CALLMONITOR 
4008 cd 6f fe			call debug_vector  
400b				endm  
# End of macro CALLMONITOR
400b					endif 
400b 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
400d 3e 00			ld a, 0 
400f 32 3d fa			ld (cli_mvdot), a 
4012 c3 6f 40			jp .dotgo 
4015				NEXTW 
4015 c3 6f 24			jp macro_next 
4018				endm 
# End of macro NEXTW
4018			.DOTF: 
4018				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
4018 1c				db WORD_SYS_CORE+8             
4019 46 40			dw .DOT            
401b 03				db 2 + 1 
401c .. 00			db ".>",0              
401f				endm 
# End of macro CWHEAD
401f			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
401f					; get value off TOS and display it 
401f			        ; TODO BUG adds extra spaces 
401f			        ; TODO BUG handle numerics? 
401f					if DEBUG_FORTH_WORDS_KEY 
401f						DMARK "DTC" 
401f f5				push af  
4020 3a 34 40			ld a, (.dmark)  
4023 32 6b fe			ld (debug_mark),a  
4026 3a 35 40			ld a, (.dmark+1)  
4029 32 6c fe			ld (debug_mark+1),a  
402c 3a 36 40			ld a, (.dmark+2)  
402f 32 6d fe			ld (debug_mark+2),a  
4032 18 03			jr .pastdmark  
4034 ..			.dmark: db "DTC"  
4037 f1			.pastdmark: pop af  
4038			endm  
# End of macro DMARK
4038						CALLMONITOR 
4038 cd 6f fe			call debug_vector  
403b				endm  
# End of macro CALLMONITOR
403b					endif 
403b 3e 01			ld a, 1 
403d 32 3d fa			ld (cli_mvdot), a 
4040 c3 6f 40			jp .dotgo 
4043				NEXTW 
4043 c3 6f 24			jp macro_next 
4046				endm 
# End of macro NEXTW
4046			 
4046			.DOT: 
4046				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
4046 1c				db WORD_SYS_CORE+8             
4047 22 42			dw .CLS            
4049 02				db 1 + 1 
404a .. 00			db ".",0              
404c				endm 
# End of macro CWHEAD
404c			        ; | . ( u -- ) Display TOS | DONE 
404c					; get value off TOS and display it 
404c			 
404c					if DEBUG_FORTH_WORDS_KEY 
404c						DMARK "DOT" 
404c f5				push af  
404d 3a 61 40			ld a, (.dmark)  
4050 32 6b fe			ld (debug_mark),a  
4053 3a 62 40			ld a, (.dmark+1)  
4056 32 6c fe			ld (debug_mark+1),a  
4059 3a 63 40			ld a, (.dmark+2)  
405c 32 6d fe			ld (debug_mark+2),a  
405f 18 03			jr .pastdmark  
4061 ..			.dmark: db "DOT"  
4064 f1			.pastdmark: pop af  
4065			endm  
# End of macro DMARK
4065						CALLMONITOR 
4065 cd 6f fe			call debug_vector  
4068				endm  
# End of macro CALLMONITOR
4068					endif 
4068 3e 00			ld a, 0 
406a 32 3d fa			ld (cli_mvdot), a 
406d 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
406f				 
406f			 
406f			.dotgo: 
406f			 
406f			; move up type to on stack for parserv5 
406f					FORTH_DSP 
406f cd 7f 22			call macro_forth_dsp 
4072				endm 
# End of macro FORTH_DSP
4072				;FORTH_DSP_VALUE  
4072			 
4072			if DEBUG_FORTH_DOT 
4072				DMARK "DOT" 
4072 f5				push af  
4073 3a 87 40			ld a, (.dmark)  
4076 32 6b fe			ld (debug_mark),a  
4079 3a 88 40			ld a, (.dmark+1)  
407c 32 6c fe			ld (debug_mark+1),a  
407f 3a 89 40			ld a, (.dmark+2)  
4082 32 6d fe			ld (debug_mark+2),a  
4085 18 03			jr .pastdmark  
4087 ..			.dmark: db "DOT"  
408a f1			.pastdmark: pop af  
408b			endm  
# End of macro DMARK
408b				CALLMONITOR 
408b cd 6f fe			call debug_vector  
408e				endm  
# End of macro CALLMONITOR
408e			endif	 
408e			;		.print: 
408e			 
408e 7e				ld a,(hl)  ; work out what type of value is on the TOS 
408f 23				inc hl   ; position to the actual value 
4090 fe 01			cp DS_TYPE_STR 
4092 20 06			jr nz, .dotnum1  
4094			 
4094			; display string 
4094				FORTH_DSP_VALUE  
4094 cd a2 22			call macro_forth_dsp_value 
4097				endm 
# End of macro FORTH_DSP_VALUE
4097 eb				ex de,hl 
4098 18 49			jr .dotwrite 
409a			 
409a			.dotnum1: 
409a fe 02			cp DS_TYPE_INUM 
409c 20 44			jr nz, .dotflot 
409e			 
409e			 
409e			; display number 
409e			 
409e			;	push hl 
409e			;	call clear_display 
409e			;	pop hl 
409e			 
409e 5e				ld e, (hl) 
409f 23				inc hl 
40a0 56				ld d, (hl) 
40a1 21 c1 f1			ld hl, scratch 
40a4			if DEBUG_FORTH_DOT 
40a4				DMARK "DT1" 
40a4 f5				push af  
40a5 3a b9 40			ld a, (.dmark)  
40a8 32 6b fe			ld (debug_mark),a  
40ab 3a ba 40			ld a, (.dmark+1)  
40ae 32 6c fe			ld (debug_mark+1),a  
40b1 3a bb 40			ld a, (.dmark+2)  
40b4 32 6d fe			ld (debug_mark+2),a  
40b7 18 03			jr .pastdmark  
40b9 ..			.dmark: db "DT1"  
40bc f1			.pastdmark: pop af  
40bd			endm  
# End of macro DMARK
40bd				CALLMONITOR 
40bd cd 6f fe			call debug_vector  
40c0				endm  
# End of macro CALLMONITOR
40c0			endif	 
40c0			 
40c0 cd 93 13			call uitoa_16 
40c3 eb				ex de,hl 
40c4			 
40c4			if DEBUG_FORTH_DOT 
40c4				DMARK "DT2" 
40c4 f5				push af  
40c5 3a d9 40			ld a, (.dmark)  
40c8 32 6b fe			ld (debug_mark),a  
40cb 3a da 40			ld a, (.dmark+1)  
40ce 32 6c fe			ld (debug_mark+1),a  
40d1 3a db 40			ld a, (.dmark+2)  
40d4 32 6d fe			ld (debug_mark+2),a  
40d7 18 03			jr .pastdmark  
40d9 ..			.dmark: db "DT2"  
40dc f1			.pastdmark: pop af  
40dd			endm  
# End of macro DMARK
40dd				CALLMONITOR 
40dd cd 6f fe			call debug_vector  
40e0				endm  
# End of macro CALLMONITOR
40e0			endif	 
40e0			 
40e0			;	ld de, os_word_scratch 
40e0 18 01			jr .dotwrite 
40e2			 
40e2 00			.dotflot:   nop 
40e3			; TODO print floating point number 
40e3			 
40e3			.dotwrite:		 
40e3			 
40e3					; if c is set then set all '-' to spaces 
40e3					; need to also take into account .>  
40e3			 
40e3 3e 01				ld a, 1 
40e5 b9					cp c 
40e6 20 67				jr nz, .nodashswap 
40e8			 
40e8					; DE has the string to write, working with HL 
40e8			 
40e8 06 ff				ld b, 255 
40ea d5					push de 
40eb e1					pop hl 
40ec			 
40ec			if DEBUG_FORTH_DOT 
40ec				DMARK "DT-" 
40ec f5				push af  
40ed 3a 01 41			ld a, (.dmark)  
40f0 32 6b fe			ld (debug_mark),a  
40f3 3a 02 41			ld a, (.dmark+1)  
40f6 32 6c fe			ld (debug_mark+1),a  
40f9 3a 03 41			ld a, (.dmark+2)  
40fc 32 6d fe			ld (debug_mark+2),a  
40ff 18 03			jr .pastdmark  
4101 ..			.dmark: db "DT-"  
4104 f1			.pastdmark: pop af  
4105			endm  
# End of macro DMARK
4105				CALLMONITOR 
4105 cd 6f fe			call debug_vector  
4108				endm  
# End of macro CALLMONITOR
4108			endif	 
4108 7e			.dashscan:	ld a, (hl) 
4109 fe 00				cp 0 
410b 28 42				jr z, .nodashswap 
410d fe 2d				cp '-' 
410f 20 03				jr nz, .dashskip 
4111 3e 20				ld a, ' ' 
4113 77					ld (hl), a 
4114 23			.dashskip:	inc hl 
4115			if DEBUG_FORTH_DOT 
4115				DMARK "D-2" 
4115 f5				push af  
4116 3a 2a 41			ld a, (.dmark)  
4119 32 6b fe			ld (debug_mark),a  
411c 3a 2b 41			ld a, (.dmark+1)  
411f 32 6c fe			ld (debug_mark+1),a  
4122 3a 2c 41			ld a, (.dmark+2)  
4125 32 6d fe			ld (debug_mark+2),a  
4128 18 03			jr .pastdmark  
412a ..			.dmark: db "D-2"  
412d f1			.pastdmark: pop af  
412e			endm  
# End of macro DMARK
412e				CALLMONITOR 
412e cd 6f fe			call debug_vector  
4131				endm  
# End of macro CALLMONITOR
4131			endif	 
4131 10 d5				djnz .dashscan 
4133			 
4133			if DEBUG_FORTH_DOT 
4133				DMARK "D-1" 
4133 f5				push af  
4134 3a 48 41			ld a, (.dmark)  
4137 32 6b fe			ld (debug_mark),a  
413a 3a 49 41			ld a, (.dmark+1)  
413d 32 6c fe			ld (debug_mark+1),a  
4140 3a 4a 41			ld a, (.dmark+2)  
4143 32 6d fe			ld (debug_mark+2),a  
4146 18 03			jr .pastdmark  
4148 ..			.dmark: db "D-1"  
414b f1			.pastdmark: pop af  
414c			endm  
# End of macro DMARK
414c				CALLMONITOR 
414c cd 6f fe			call debug_vector  
414f				endm  
# End of macro CALLMONITOR
414f			endif	 
414f			 
414f			.nodashswap: 
414f			 
414f			if DEBUG_FORTH_DOT 
414f				DMARK "D-o" 
414f f5				push af  
4150 3a 64 41			ld a, (.dmark)  
4153 32 6b fe			ld (debug_mark),a  
4156 3a 65 41			ld a, (.dmark+1)  
4159 32 6c fe			ld (debug_mark+1),a  
415c 3a 66 41			ld a, (.dmark+2)  
415f 32 6d fe			ld (debug_mark+2),a  
4162 18 03			jr .pastdmark  
4164 ..			.dmark: db "D-o"  
4167 f1			.pastdmark: pop af  
4168			endm  
# End of macro DMARK
4168				CALLMONITOR 
4168 cd 6f fe			call debug_vector  
416b				endm  
# End of macro CALLMONITOR
416b			endif	 
416b			 
416b d5					push de   ; save string start in case we need to advance print 
416c			 
416c 3a 5e fa				ld a, (f_cursor_ptr) 
416f cd 65 0d				call str_at_display 
4172 3a 3c fa				ld a,(cli_autodisplay) 
4175 fe 00				cp 0 
4177 28 03				jr z, .noupdate 
4179 cd 75 0d						call update_display 
417c					.noupdate: 
417c			 
417c			 
417c					; see if we need to advance the print position 
417c			 
417c e1					pop hl   ; get back string 
417d			;		ex de,hl 
417d			 
417d 3a 3d fa				ld a, (cli_mvdot) 
4180			if DEBUG_FORTH_DOT 
4180			;		ld e,a 
4180				DMARK "D>1" 
4180 f5				push af  
4181 3a 95 41			ld a, (.dmark)  
4184 32 6b fe			ld (debug_mark),a  
4187 3a 96 41			ld a, (.dmark+1)  
418a 32 6c fe			ld (debug_mark+1),a  
418d 3a 97 41			ld a, (.dmark+2)  
4190 32 6d fe			ld (debug_mark+2),a  
4193 18 03			jr .pastdmark  
4195 ..			.dmark: db "D>1"  
4198 f1			.pastdmark: pop af  
4199			endm  
# End of macro DMARK
4199				CALLMONITOR 
4199 cd 6f fe			call debug_vector  
419c				endm  
# End of macro CALLMONITOR
419c			endif	 
419c fe 00				cp 0 
419e 28 44				jr z, .noadv 
41a0					; yes, lets advance the print position 
41a0 3e 00				ld a, 0 
41a2 cd ef 13				call strlent 
41a5			if DEBUG_FORTH_DOT 
41a5				DMARK "D-?" 
41a5 f5				push af  
41a6 3a ba 41			ld a, (.dmark)  
41a9 32 6b fe			ld (debug_mark),a  
41ac 3a bb 41			ld a, (.dmark+1)  
41af 32 6c fe			ld (debug_mark+1),a  
41b2 3a bc 41			ld a, (.dmark+2)  
41b5 32 6d fe			ld (debug_mark+2),a  
41b8 18 03			jr .pastdmark  
41ba ..			.dmark: db "D-?"  
41bd f1			.pastdmark: pop af  
41be			endm  
# End of macro DMARK
41be				CALLMONITOR 
41be cd 6f fe			call debug_vector  
41c1				endm  
# End of macro CALLMONITOR
41c1			endif	 
41c1 3a 5e fa				ld a, (f_cursor_ptr) 
41c4 85					add a,l 
41c5					;call addatohl 
41c5					;ld a, l 
41c5 32 5e fa				ld (f_cursor_ptr), a   ; save new pos 
41c8			 
41c8			if DEBUG_FORTH_DOT 
41c8				DMARK "D->" 
41c8 f5				push af  
41c9 3a dd 41			ld a, (.dmark)  
41cc 32 6b fe			ld (debug_mark),a  
41cf 3a de 41			ld a, (.dmark+1)  
41d2 32 6c fe			ld (debug_mark+1),a  
41d5 3a df 41			ld a, (.dmark+2)  
41d8 32 6d fe			ld (debug_mark+2),a  
41db 18 03			jr .pastdmark  
41dd ..			.dmark: db "D->"  
41e0 f1			.pastdmark: pop af  
41e1			endm  
# End of macro DMARK
41e1				CALLMONITOR 
41e1 cd 6f fe			call debug_vector  
41e4				endm  
# End of macro CALLMONITOR
41e4			endif	 
41e4			 
41e4			.noadv:	 
41e4			 
41e4					if DEBUG_FORTH_DOT_WAIT 
41e4							call next_page_prompt 
41e4					endif	 
41e4			; TODO this pop off the stack causes a crash. i dont know why 
41e4			 
41e4			 
41e4			if DEBUG_FORTH_DOT 
41e4				DMARK "DTh" 
41e4 f5				push af  
41e5 3a f9 41			ld a, (.dmark)  
41e8 32 6b fe			ld (debug_mark),a  
41eb 3a fa 41			ld a, (.dmark+1)  
41ee 32 6c fe			ld (debug_mark+1),a  
41f1 3a fb 41			ld a, (.dmark+2)  
41f4 32 6d fe			ld (debug_mark+2),a  
41f7 18 03			jr .pastdmark  
41f9 ..			.dmark: db "DTh"  
41fc f1			.pastdmark: pop af  
41fd			endm  
# End of macro DMARK
41fd				CALLMONITOR 
41fd cd 6f fe			call debug_vector  
4200				endm  
# End of macro CALLMONITOR
4200			endif	 
4200			 
4200					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4200 cd 71 23			call macro_forth_dsp_pop 
4203				endm 
# End of macro FORTH_DSP_POP
4203			 
4203			if DEBUG_FORTH_DOT 
4203				DMARK "DTi" 
4203 f5				push af  
4204 3a 18 42			ld a, (.dmark)  
4207 32 6b fe			ld (debug_mark),a  
420a 3a 19 42			ld a, (.dmark+1)  
420d 32 6c fe			ld (debug_mark+1),a  
4210 3a 1a 42			ld a, (.dmark+2)  
4213 32 6d fe			ld (debug_mark+2),a  
4216 18 03			jr .pastdmark  
4218 ..			.dmark: db "DTi"  
421b f1			.pastdmark: pop af  
421c			endm  
# End of macro DMARK
421c				CALLMONITOR 
421c cd 6f fe			call debug_vector  
421f				endm  
# End of macro CALLMONITOR
421f			endif	 
421f			 
421f			 
421f					NEXTW 
421f c3 6f 24			jp macro_next 
4222				endm 
# End of macro NEXTW
4222			 
4222			.CLS: 
4222				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4222 35				db WORD_SYS_CORE+33             
4223 4f 42			dw .DRAW            
4225 04				db 3 + 1 
4226 .. 00			db "CLS",0              
422a				endm 
# End of macro CWHEAD
422a			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
422a					if DEBUG_FORTH_WORDS_KEY 
422a						DMARK "CLS" 
422a f5				push af  
422b 3a 3f 42			ld a, (.dmark)  
422e 32 6b fe			ld (debug_mark),a  
4231 3a 40 42			ld a, (.dmark+1)  
4234 32 6c fe			ld (debug_mark+1),a  
4237 3a 41 42			ld a, (.dmark+2)  
423a 32 6d fe			ld (debug_mark+2),a  
423d 18 03			jr .pastdmark  
423f ..			.dmark: db "CLS"  
4242 f1			.pastdmark: pop af  
4243			endm  
# End of macro DMARK
4243						CALLMONITOR 
4243 cd 6f fe			call debug_vector  
4246				endm  
# End of macro CALLMONITOR
4246					endif 
4246 cd 52 0d				call clear_display 
4249 c3 5d 43				jp .home		; and home cursor 
424c					NEXTW 
424c c3 6f 24			jp macro_next 
424f				endm 
# End of macro NEXTW
424f			 
424f			.DRAW: 
424f				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
424f 36				db WORD_SYS_CORE+34             
4250 7a 42			dw .DUMP            
4252 05				db 4 + 1 
4253 .. 00			db "DRAW",0              
4258				endm 
# End of macro CWHEAD
4258			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
4258					if DEBUG_FORTH_WORDS_KEY 
4258						DMARK "DRW" 
4258 f5				push af  
4259 3a 6d 42			ld a, (.dmark)  
425c 32 6b fe			ld (debug_mark),a  
425f 3a 6e 42			ld a, (.dmark+1)  
4262 32 6c fe			ld (debug_mark+1),a  
4265 3a 6f 42			ld a, (.dmark+2)  
4268 32 6d fe			ld (debug_mark+2),a  
426b 18 03			jr .pastdmark  
426d ..			.dmark: db "DRW"  
4270 f1			.pastdmark: pop af  
4271			endm  
# End of macro DMARK
4271						CALLMONITOR 
4271 cd 6f fe			call debug_vector  
4274				endm  
# End of macro CALLMONITOR
4274					endif 
4274 cd 75 0d				call update_display 
4277					NEXTW 
4277 c3 6f 24			jp macro_next 
427a				endm 
# End of macro NEXTW
427a			 
427a			.DUMP: 
427a				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
427a 37				db WORD_SYS_CORE+35             
427b b2 42			dw .CDUMP            
427d 05				db 4 + 1 
427e .. 00			db "DUMP",0              
4283				endm 
# End of macro CWHEAD
4283			; | DUMP ( x -- ) With address x display dump   | DONE 
4283			; TODO pop address to use off of the stack 
4283					if DEBUG_FORTH_WORDS_KEY 
4283						DMARK "DUM" 
4283 f5				push af  
4284 3a 98 42			ld a, (.dmark)  
4287 32 6b fe			ld (debug_mark),a  
428a 3a 99 42			ld a, (.dmark+1)  
428d 32 6c fe			ld (debug_mark+1),a  
4290 3a 9a 42			ld a, (.dmark+2)  
4293 32 6d fe			ld (debug_mark+2),a  
4296 18 03			jr .pastdmark  
4298 ..			.dmark: db "DUM"  
429b f1			.pastdmark: pop af  
429c			endm  
# End of macro DMARK
429c						CALLMONITOR 
429c cd 6f fe			call debug_vector  
429f				endm  
# End of macro CALLMONITOR
429f					endif 
429f cd 52 0d				call clear_display 
42a2			 
42a2					; get address 
42a2			 
42a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42a2 cd b9 22			call macro_dsp_valuehl 
42a5				endm 
# End of macro FORTH_DSP_VALUEHL
42a5				 
42a5					; save it for cdump 
42a5			 
42a5 22 e4 f4				ld (os_cur_ptr),hl 
42a8			 
42a8					; destroy value TOS 
42a8			 
42a8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42a8 cd 71 23			call macro_forth_dsp_pop 
42ab				endm 
# End of macro FORTH_DSP_POP
42ab			 
42ab cd 42 1f				call dumpcont	; skip old style of param parsing	 
42ae c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
42af					NEXTW 
42af c3 6f 24			jp macro_next 
42b2				endm 
# End of macro NEXTW
42b2			.CDUMP: 
42b2				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
42b2 38				db WORD_SYS_CORE+36             
42b3 e2 42			dw .DAT            
42b5 06				db 5 + 1 
42b6 .. 00			db "CDUMP",0              
42bc				endm 
# End of macro CWHEAD
42bc			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
42bc					if DEBUG_FORTH_WORDS_KEY 
42bc						DMARK "CDP" 
42bc f5				push af  
42bd 3a d1 42			ld a, (.dmark)  
42c0 32 6b fe			ld (debug_mark),a  
42c3 3a d2 42			ld a, (.dmark+1)  
42c6 32 6c fe			ld (debug_mark+1),a  
42c9 3a d3 42			ld a, (.dmark+2)  
42cc 32 6d fe			ld (debug_mark+2),a  
42cf 18 03			jr .pastdmark  
42d1 ..			.dmark: db "CDP"  
42d4 f1			.pastdmark: pop af  
42d5			endm  
# End of macro DMARK
42d5						CALLMONITOR 
42d5 cd 6f fe			call debug_vector  
42d8				endm  
# End of macro CALLMONITOR
42d8					endif 
42d8 cd 52 0d				call clear_display 
42db cd 42 1f				call dumpcont	 
42de c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
42df					NEXTW 
42df c3 6f 24			jp macro_next 
42e2				endm 
# End of macro NEXTW
42e2			 
42e2			 
42e2			 
42e2			 
42e2			.DAT: 
42e2				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
42e2 3d				db WORD_SYS_CORE+41             
42e3 38 43			dw .HOME            
42e5 03				db 2 + 1 
42e6 .. 00			db "AT",0              
42e9				endm 
# End of macro CWHEAD
42e9			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
42e9					if DEBUG_FORTH_WORDS_KEY 
42e9						DMARK "AT." 
42e9 f5				push af  
42ea 3a fe 42			ld a, (.dmark)  
42ed 32 6b fe			ld (debug_mark),a  
42f0 3a ff 42			ld a, (.dmark+1)  
42f3 32 6c fe			ld (debug_mark+1),a  
42f6 3a 00 43			ld a, (.dmark+2)  
42f9 32 6d fe			ld (debug_mark+2),a  
42fc 18 03			jr .pastdmark  
42fe ..			.dmark: db "AT."  
4301 f1			.pastdmark: pop af  
4302			endm  
# End of macro DMARK
4302						CALLMONITOR 
4302 cd 6f fe			call debug_vector  
4305				endm  
# End of macro CALLMONITOR
4305					endif 
4305					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4305 cd b9 22			call macro_dsp_valuehl 
4308				endm 
# End of macro FORTH_DSP_VALUEHL
4308			 
4308			 
4308					; TODO save cursor row 
4308 7d					ld a,l 
4309 fe 02				cp 2 
430b 20 04				jr nz, .crow3 
430d 3e 28				ld a, display_row_2 
430f 18 12				jr .ccol1 
4311 fe 03		.crow3:		cp 3 
4313 20 04				jr nz, .crow4 
4315 3e 50				ld a, display_row_3 
4317 18 0a				jr .ccol1 
4319 fe 04		.crow4:		cp 4 
431b 20 04				jr nz, .crow1 
431d 3e 78				ld a, display_row_4 
431f 18 02				jr .ccol1 
4321 3e 00		.crow1:		ld a,display_row_1 
4323 f5			.ccol1:		push af			; got row offset 
4324 6f					ld l,a 
4325 26 00				ld h,0 
4327					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4327 cd 71 23			call macro_forth_dsp_pop 
432a				endm 
# End of macro FORTH_DSP_POP
432a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
432a cd b9 22			call macro_dsp_valuehl 
432d				endm 
# End of macro FORTH_DSP_VALUEHL
432d					; TODO save cursor col 
432d f1					pop af 
432e 85					add l		; add col offset 
432f 32 5e fa				ld (f_cursor_ptr), a 
4332					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4332 cd 71 23			call macro_forth_dsp_pop 
4335				endm 
# End of macro FORTH_DSP_POP
4335			 
4335					; calculate  
4335			 
4335					NEXTW 
4335 c3 6f 24			jp macro_next 
4338				endm 
# End of macro NEXTW
4338			 
4338			 
4338			.HOME: 
4338				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
4338 41				db WORD_SYS_CORE+45             
4339 65 43			dw .SPACE            
433b 05				db 4 + 1 
433c .. 00			db "HOME",0              
4341				endm 
# End of macro CWHEAD
4341			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4341					if DEBUG_FORTH_WORDS_KEY 
4341						DMARK "HOM" 
4341 f5				push af  
4342 3a 56 43			ld a, (.dmark)  
4345 32 6b fe			ld (debug_mark),a  
4348 3a 57 43			ld a, (.dmark+1)  
434b 32 6c fe			ld (debug_mark+1),a  
434e 3a 58 43			ld a, (.dmark+2)  
4351 32 6d fe			ld (debug_mark+2),a  
4354 18 03			jr .pastdmark  
4356 ..			.dmark: db "HOM"  
4359 f1			.pastdmark: pop af  
435a			endm  
# End of macro DMARK
435a						CALLMONITOR 
435a cd 6f fe			call debug_vector  
435d				endm  
# End of macro CALLMONITOR
435d					endif 
435d 3e 00		.home:		ld a, 0		; and home cursor 
435f 32 5e fa				ld (f_cursor_ptr), a 
4362					NEXTW 
4362 c3 6f 24			jp macro_next 
4365				endm 
# End of macro NEXTW
4365			 
4365			 
4365			.SPACE: 
4365				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
4365 46				db WORD_SYS_CORE+50             
4366 9b 43			dw .SPACES            
4368 03				db 2 + 1 
4369 .. 00			db "BL",0              
436c				endm 
# End of macro CWHEAD
436c			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
436c					if DEBUG_FORTH_WORDS_KEY 
436c						DMARK "BL." 
436c f5				push af  
436d 3a 81 43			ld a, (.dmark)  
4370 32 6b fe			ld (debug_mark),a  
4373 3a 82 43			ld a, (.dmark+1)  
4376 32 6c fe			ld (debug_mark+1),a  
4379 3a 83 43			ld a, (.dmark+2)  
437c 32 6d fe			ld (debug_mark+2),a  
437f 18 03			jr .pastdmark  
4381 ..			.dmark: db "BL."  
4384 f1			.pastdmark: pop af  
4385			endm  
# End of macro DMARK
4385						CALLMONITOR 
4385 cd 6f fe			call debug_vector  
4388				endm  
# End of macro CALLMONITOR
4388					endif 
4388 3e 20				ld a, " " 
438a 32 c1 f1				ld (scratch),a 
438d 3e 00				ld a, 0 
438f 32 c2 f1				ld (scratch+1),a 
4392 21 c1 f1				ld hl, scratch 
4395 cd 30 21				call forth_push_str 
4398					 
4398				       NEXTW 
4398 c3 6f 24			jp macro_next 
439b				endm 
# End of macro NEXTW
439b			 
439b			;.blstr: db " ", 0 
439b			 
439b			.SPACES: 
439b				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
439b 47				db WORD_SYS_CORE+51             
439c 36 44			dw .SCROLL            
439e 07				db 6 + 1 
439f .. 00			db "SPACES",0              
43a6				endm 
# End of macro CWHEAD
43a6			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
43a6					if DEBUG_FORTH_WORDS_KEY 
43a6						DMARK "SPS" 
43a6 f5				push af  
43a7 3a bb 43			ld a, (.dmark)  
43aa 32 6b fe			ld (debug_mark),a  
43ad 3a bc 43			ld a, (.dmark+1)  
43b0 32 6c fe			ld (debug_mark+1),a  
43b3 3a bd 43			ld a, (.dmark+2)  
43b6 32 6d fe			ld (debug_mark+2),a  
43b9 18 03			jr .pastdmark  
43bb ..			.dmark: db "SPS"  
43be f1			.pastdmark: pop af  
43bf			endm  
# End of macro DMARK
43bf						CALLMONITOR 
43bf cd 6f fe			call debug_vector  
43c2				endm  
# End of macro CALLMONITOR
43c2					endif 
43c2			 
43c2			 
43c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43c2 cd b9 22			call macro_dsp_valuehl 
43c5				endm 
# End of macro FORTH_DSP_VALUEHL
43c5			 
43c5 e5					push hl    ; u 
43c6					if DEBUG_FORTH_WORDS 
43c6						DMARK "SPA" 
43c6 f5				push af  
43c7 3a db 43			ld a, (.dmark)  
43ca 32 6b fe			ld (debug_mark),a  
43cd 3a dc 43			ld a, (.dmark+1)  
43d0 32 6c fe			ld (debug_mark+1),a  
43d3 3a dd 43			ld a, (.dmark+2)  
43d6 32 6d fe			ld (debug_mark+2),a  
43d9 18 03			jr .pastdmark  
43db ..			.dmark: db "SPA"  
43de f1			.pastdmark: pop af  
43df			endm  
# End of macro DMARK
43df						CALLMONITOR 
43df cd 6f fe			call debug_vector  
43e2				endm  
# End of macro CALLMONITOR
43e2					endif 
43e2			 
43e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43e2 cd 71 23			call macro_forth_dsp_pop 
43e5				endm 
# End of macro FORTH_DSP_POP
43e5 e1					pop hl 
43e6 0e 00				ld c, 0 
43e8 45					ld b, l 
43e9 21 c1 f1				ld hl, scratch  
43ec			 
43ec					if DEBUG_FORTH_WORDS 
43ec						DMARK "SP2" 
43ec f5				push af  
43ed 3a 01 44			ld a, (.dmark)  
43f0 32 6b fe			ld (debug_mark),a  
43f3 3a 02 44			ld a, (.dmark+1)  
43f6 32 6c fe			ld (debug_mark+1),a  
43f9 3a 03 44			ld a, (.dmark+2)  
43fc 32 6d fe			ld (debug_mark+2),a  
43ff 18 03			jr .pastdmark  
4401 ..			.dmark: db "SP2"  
4404 f1			.pastdmark: pop af  
4405			endm  
# End of macro DMARK
4405						CALLMONITOR 
4405 cd 6f fe			call debug_vector  
4408				endm  
# End of macro CALLMONITOR
4408					endif 
4408 3e 20				ld a, ' ' 
440a			.spaces1:	 
440a 77					ld (hl),a 
440b 23					inc hl 
440c					 
440c 10 fc				djnz .spaces1 
440e 3e 00				ld a,0 
4410 77					ld (hl),a 
4411 21 c1 f1				ld hl, scratch 
4414					if DEBUG_FORTH_WORDS 
4414						DMARK "SP3" 
4414 f5				push af  
4415 3a 29 44			ld a, (.dmark)  
4418 32 6b fe			ld (debug_mark),a  
441b 3a 2a 44			ld a, (.dmark+1)  
441e 32 6c fe			ld (debug_mark+1),a  
4421 3a 2b 44			ld a, (.dmark+2)  
4424 32 6d fe			ld (debug_mark+2),a  
4427 18 03			jr .pastdmark  
4429 ..			.dmark: db "SP3"  
442c f1			.pastdmark: pop af  
442d			endm  
# End of macro DMARK
442d						CALLMONITOR 
442d cd 6f fe			call debug_vector  
4430				endm  
# End of macro CALLMONITOR
4430					endif 
4430 cd 30 21				call forth_push_str 
4433			 
4433				       NEXTW 
4433 c3 6f 24			jp macro_next 
4436				endm 
# End of macro NEXTW
4436			 
4436			 
4436			 
4436			.SCROLL: 
4436				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4436 53				db WORD_SYS_CORE+63             
4437 63 44			dw .SCROLLD            
4439 07				db 6 + 1 
443a .. 00			db "SCROLL",0              
4441				endm 
# End of macro CWHEAD
4441			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4441					if DEBUG_FORTH_WORDS_KEY 
4441						DMARK "SCR" 
4441 f5				push af  
4442 3a 56 44			ld a, (.dmark)  
4445 32 6b fe			ld (debug_mark),a  
4448 3a 57 44			ld a, (.dmark+1)  
444b 32 6c fe			ld (debug_mark+1),a  
444e 3a 58 44			ld a, (.dmark+2)  
4451 32 6d fe			ld (debug_mark+2),a  
4454 18 03			jr .pastdmark  
4456 ..			.dmark: db "SCR"  
4459 f1			.pastdmark: pop af  
445a			endm  
# End of macro DMARK
445a						CALLMONITOR 
445a cd 6f fe			call debug_vector  
445d				endm  
# End of macro CALLMONITOR
445d					endif 
445d			 
445d cd 14 0d			call scroll_up 
4460			;	call update_display 
4460			 
4460					NEXTW 
4460 c3 6f 24			jp macro_next 
4463				endm 
# End of macro NEXTW
4463			 
4463			 
4463			 
4463			;		; get dir 
4463			; 
4463			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4463			; 
4463			;		push hl 
4463			; 
4463			;		; destroy value TOS 
4463			; 
4463			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4463			; 
4463			;		; get count 
4463			; 
4463			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4463			; 
4463			;		push hl 
4463			; 
4463			;		; destroy value TOS 
4463			; 
4463			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4463			; 
4463			;		; one value on hl get other one back 
4463			; 
4463			;		pop bc    ; count 
4463			; 
4463			;		pop de   ; dir 
4463			; 
4463			; 
4463			;		ld b, c 
4463			; 
4463			;.scrolldir:     push bc 
4463			;		push de 
4463			; 
4463			;		ld a, 0 
4463			;		cp e 
4463			;		jr z, .scrollup  
4463			;		call scroll_down 
4463			;		jr .scrollnext 
4463			;.scrollup:	call scroll_up 
4463			; 
4463			;		 
4463			;.scrollnext: 
4463			;		pop de 
4463			;		pop bc 
4463			;		djnz .scrolldir 
4463			; 
4463			; 
4463			; 
4463			; 
4463			; 
4463			;		NEXTW 
4463			 
4463			.SCROLLD: 
4463				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4463 53				db WORD_SYS_CORE+63             
4464 91 44			dw .ATQ            
4466 08				db 7 + 1 
4467 .. 00			db "SCROLLD",0              
446f				endm 
# End of macro CWHEAD
446f			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
446f					if DEBUG_FORTH_WORDS_KEY 
446f						DMARK "SCD" 
446f f5				push af  
4470 3a 84 44			ld a, (.dmark)  
4473 32 6b fe			ld (debug_mark),a  
4476 3a 85 44			ld a, (.dmark+1)  
4479 32 6c fe			ld (debug_mark+1),a  
447c 3a 86 44			ld a, (.dmark+2)  
447f 32 6d fe			ld (debug_mark+2),a  
4482 18 03			jr .pastdmark  
4484 ..			.dmark: db "SCD"  
4487 f1			.pastdmark: pop af  
4488			endm  
# End of macro DMARK
4488						CALLMONITOR 
4488 cd 6f fe			call debug_vector  
448b				endm  
# End of macro CALLMONITOR
448b					endif 
448b			 
448b cd 38 0d			call scroll_down 
448e			;	call update_display 
448e			 
448e					NEXTW 
448e c3 6f 24			jp macro_next 
4491				endm 
# End of macro NEXTW
4491			 
4491			 
4491			.ATQ: 
4491				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4491 62				db WORD_SYS_CORE+78             
4492 ef 44			dw .AUTODSP            
4494 04				db 3 + 1 
4495 .. 00			db "AT@",0              
4499				endm 
# End of macro CWHEAD
4499			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
4499					if DEBUG_FORTH_WORDS_KEY 
4499						DMARK "ATA" 
4499 f5				push af  
449a 3a ae 44			ld a, (.dmark)  
449d 32 6b fe			ld (debug_mark),a  
44a0 3a af 44			ld a, (.dmark+1)  
44a3 32 6c fe			ld (debug_mark+1),a  
44a6 3a b0 44			ld a, (.dmark+2)  
44a9 32 6d fe			ld (debug_mark+2),a  
44ac 18 03			jr .pastdmark  
44ae ..			.dmark: db "ATA"  
44b1 f1			.pastdmark: pop af  
44b2			endm  
# End of macro DMARK
44b2						CALLMONITOR 
44b2 cd 6f fe			call debug_vector  
44b5				endm  
# End of macro CALLMONITOR
44b5					endif 
44b5			 
44b5			 
44b5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44b5 cd b9 22			call macro_dsp_valuehl 
44b8				endm 
# End of macro FORTH_DSP_VALUEHL
44b8			 
44b8					; TODO save cursor row 
44b8 7d					ld a,l 
44b9 fe 02				cp 2 
44bb 20 04				jr nz, .crow3aq 
44bd 3e 28				ld a, display_row_2 
44bf 18 12				jr .ccol1aq 
44c1 fe 03		.crow3aq:		cp 3 
44c3 20 04				jr nz, .crow4aq 
44c5 3e 50				ld a, display_row_3 
44c7 18 0a				jr .ccol1aq 
44c9 fe 04		.crow4aq:		cp 4 
44cb 20 04				jr nz, .crow1aq 
44cd 3e 78				ld a, display_row_4 
44cf 18 02				jr .ccol1aq 
44d1 3e 00		.crow1aq:		ld a,display_row_1 
44d3 f5			.ccol1aq:		push af			; got row offset 
44d4 6f					ld l,a 
44d5 26 00				ld h,0 
44d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44d7 cd 71 23			call macro_forth_dsp_pop 
44da				endm 
# End of macro FORTH_DSP_POP
44da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44da cd b9 22			call macro_dsp_valuehl 
44dd				endm 
# End of macro FORTH_DSP_VALUEHL
44dd					; TODO save cursor col 
44dd f1					pop af 
44de 85					add l		; add col offset 
44df			 
44df					; add current frame buffer address 
44df 2a cc fb				ld hl, (display_fb_active) 
44e2 cd 86 0f				call addatohl 
44e5			 
44e5			 
44e5			 
44e5			 
44e5					; get char frame buffer location offset in hl 
44e5			 
44e5 7e					ld a,(hl) 
44e6 26 00				ld h, 0 
44e8 6f					ld l, a 
44e9			 
44e9 cd c2 20				call forth_push_numhl 
44ec			 
44ec			 
44ec					NEXTW 
44ec c3 6f 24			jp macro_next 
44ef				endm 
# End of macro NEXTW
44ef			 
44ef			.AUTODSP: 
44ef				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
44ef 63				db WORD_SYS_CORE+79             
44f0 05 45			dw .MENU            
44f2 05				db 4 + 1 
44f3 .. 00			db "ADSP",0              
44f8				endm 
# End of macro CWHEAD
44f8			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
44f8			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
44f8			 
44f8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44f8 cd b9 22			call macro_dsp_valuehl 
44fb				endm 
# End of macro FORTH_DSP_VALUEHL
44fb			 
44fb			;		push hl 
44fb			 
44fb					; destroy value TOS 
44fb			 
44fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44fb cd 71 23			call macro_forth_dsp_pop 
44fe				endm 
# End of macro FORTH_DSP_POP
44fe			 
44fe			;		pop hl 
44fe			 
44fe 7d					ld a,l 
44ff 32 3c fa				ld (cli_autodisplay), a 
4502				       NEXTW 
4502 c3 6f 24			jp macro_next 
4505				endm 
# End of macro NEXTW
4505			 
4505			.MENU: 
4505				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4505 70				db WORD_SYS_CORE+92             
4506 ae 45			dw .ENDDISPLAY            
4508 05				db 4 + 1 
4509 .. 00			db "MENU",0              
450e				endm 
# End of macro CWHEAD
450e			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
450e			 
450e			;		; get number of items on the stack 
450e			; 
450e				 
450e					FORTH_DSP_VALUEHL 
450e cd b9 22			call macro_dsp_valuehl 
4511				endm 
# End of macro FORTH_DSP_VALUEHL
4511				 
4511					if DEBUG_FORTH_WORDS_KEY 
4511						DMARK "MNU" 
4511 f5				push af  
4512 3a 26 45			ld a, (.dmark)  
4515 32 6b fe			ld (debug_mark),a  
4518 3a 27 45			ld a, (.dmark+1)  
451b 32 6c fe			ld (debug_mark+1),a  
451e 3a 28 45			ld a, (.dmark+2)  
4521 32 6d fe			ld (debug_mark+2),a  
4524 18 03			jr .pastdmark  
4526 ..			.dmark: db "MNU"  
4529 f1			.pastdmark: pop af  
452a			endm  
# End of macro DMARK
452a						CALLMONITOR 
452a cd 6f fe			call debug_vector  
452d				endm  
# End of macro CALLMONITOR
452d					endif 
452d			 
452d 45					ld b, l	 
452e 05					dec b 
452f			 
452f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
452f cd 71 23			call macro_forth_dsp_pop 
4532				endm 
# End of macro FORTH_DSP_POP
4532			 
4532			 
4532					; go directly through the stack to pluck out the string pointers and build an array 
4532			 
4532			;		FORTH_DSP 
4532			 
4532					; hl contains top most stack item 
4532				 
4532 11 c1 f1				ld de, scratch 
4535			 
4535			.mbuild: 
4535			 
4535					FORTH_DSP_VALUEHL 
4535 cd b9 22			call macro_dsp_valuehl 
4538				endm 
# End of macro FORTH_DSP_VALUEHL
4538			 
4538					if DEBUG_FORTH_WORDS 
4538						DMARK "MN3" 
4538 f5				push af  
4539 3a 4d 45			ld a, (.dmark)  
453c 32 6b fe			ld (debug_mark),a  
453f 3a 4e 45			ld a, (.dmark+1)  
4542 32 6c fe			ld (debug_mark+1),a  
4545 3a 4f 45			ld a, (.dmark+2)  
4548 32 6d fe			ld (debug_mark+2),a  
454b 18 03			jr .pastdmark  
454d ..			.dmark: db "MN3"  
4550 f1			.pastdmark: pop af  
4551			endm  
# End of macro DMARK
4551						CALLMONITOR 
4551 cd 6f fe			call debug_vector  
4554				endm  
# End of macro CALLMONITOR
4554					endif 
4554 eb					ex de, hl 
4555 73					ld (hl), e 
4556 23					inc hl 
4557 72					ld (hl), d 
4558 23					inc hl 
4559 eb					ex de, hl 
455a			 
455a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
455a cd 71 23			call macro_forth_dsp_pop 
455d				endm 
# End of macro FORTH_DSP_POP
455d			 
455d 10 d6				djnz .mbuild 
455f			 
455f					; done add term 
455f			 
455f eb					ex de, hl 
4560 36 00				ld (hl), 0 
4562 23					inc hl 
4563 36 00				ld (hl), 0 
4565			 
4565				 
4565					 
4565 21 c1 f1				ld hl, scratch 
4568			 
4568					if DEBUG_FORTH_WORDS 
4568						DMARK "MNx" 
4568 f5				push af  
4569 3a 7d 45			ld a, (.dmark)  
456c 32 6b fe			ld (debug_mark),a  
456f 3a 7e 45			ld a, (.dmark+1)  
4572 32 6c fe			ld (debug_mark+1),a  
4575 3a 7f 45			ld a, (.dmark+2)  
4578 32 6d fe			ld (debug_mark+2),a  
457b 18 03			jr .pastdmark  
457d ..			.dmark: db "MNx"  
4580 f1			.pastdmark: pop af  
4581			endm  
# End of macro DMARK
4581						CALLMONITOR 
4581 cd 6f fe			call debug_vector  
4584				endm  
# End of macro CALLMONITOR
4584					endif 
4584			 
4584			 
4584			 
4584 3e 00				ld a, 0 
4586 cd 83 0d				call menu 
4589			 
4589			 
4589 6f					ld l, a 
458a 26 00				ld h, 0 
458c			 
458c					if DEBUG_FORTH_WORDS 
458c						DMARK "MNr" 
458c f5				push af  
458d 3a a1 45			ld a, (.dmark)  
4590 32 6b fe			ld (debug_mark),a  
4593 3a a2 45			ld a, (.dmark+1)  
4596 32 6c fe			ld (debug_mark+1),a  
4599 3a a3 45			ld a, (.dmark+2)  
459c 32 6d fe			ld (debug_mark+2),a  
459f 18 03			jr .pastdmark  
45a1 ..			.dmark: db "MNr"  
45a4 f1			.pastdmark: pop af  
45a5			endm  
# End of macro DMARK
45a5						CALLMONITOR 
45a5 cd 6f fe			call debug_vector  
45a8				endm  
# End of macro CALLMONITOR
45a8					endif 
45a8			 
45a8 cd c2 20				call forth_push_numhl 
45ab			 
45ab			 
45ab			 
45ab			 
45ab				       NEXTW 
45ab c3 6f 24			jp macro_next 
45ae				endm 
# End of macro NEXTW
45ae			 
45ae			 
45ae			.ENDDISPLAY: 
45ae			 
45ae			; eof 
# End of file forth_words_display.asm
45ae			include "forth_words_str.asm" 
45ae			 
45ae			; | ## String Words 
45ae			 
45ae			.PTR:   
45ae			 
45ae				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
45ae 48				db WORD_SYS_CORE+52             
45af db 45			dw .STYPE            
45b1 04				db 3 + 1 
45b2 .. 00			db "PTR",0              
45b6				endm 
# End of macro CWHEAD
45b6			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
45b6			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
45b6			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
45b6			 
45b6					if DEBUG_FORTH_WORDS_KEY 
45b6						DMARK "PTR" 
45b6 f5				push af  
45b7 3a cb 45			ld a, (.dmark)  
45ba 32 6b fe			ld (debug_mark),a  
45bd 3a cc 45			ld a, (.dmark+1)  
45c0 32 6c fe			ld (debug_mark+1),a  
45c3 3a cd 45			ld a, (.dmark+2)  
45c6 32 6d fe			ld (debug_mark+2),a  
45c9 18 03			jr .pastdmark  
45cb ..			.dmark: db "PTR"  
45ce f1			.pastdmark: pop af  
45cf			endm  
# End of macro DMARK
45cf						CALLMONITOR 
45cf cd 6f fe			call debug_vector  
45d2				endm  
# End of macro CALLMONITOR
45d2					endif 
45d2					FORTH_DSP_VALUEHL 
45d2 cd b9 22			call macro_dsp_valuehl 
45d5				endm 
# End of macro FORTH_DSP_VALUEHL
45d5 cd c2 20				call forth_push_numhl 
45d8			 
45d8			 
45d8					NEXTW 
45d8 c3 6f 24			jp macro_next 
45db				endm 
# End of macro NEXTW
45db			.STYPE: 
45db				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
45db 48				db WORD_SYS_CORE+52             
45dc 2a 46			dw .UPPER            
45de 06				db 5 + 1 
45df .. 00			db "STYPE",0              
45e5				endm 
# End of macro CWHEAD
45e5			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
45e5					if DEBUG_FORTH_WORDS_KEY 
45e5						DMARK "STY" 
45e5 f5				push af  
45e6 3a fa 45			ld a, (.dmark)  
45e9 32 6b fe			ld (debug_mark),a  
45ec 3a fb 45			ld a, (.dmark+1)  
45ef 32 6c fe			ld (debug_mark+1),a  
45f2 3a fc 45			ld a, (.dmark+2)  
45f5 32 6d fe			ld (debug_mark+2),a  
45f8 18 03			jr .pastdmark  
45fa ..			.dmark: db "STY"  
45fd f1			.pastdmark: pop af  
45fe			endm  
# End of macro DMARK
45fe						CALLMONITOR 
45fe cd 6f fe			call debug_vector  
4601				endm  
# End of macro CALLMONITOR
4601					endif 
4601					FORTH_DSP 
4601 cd 7f 22			call macro_forth_dsp 
4604				endm 
# End of macro FORTH_DSP
4604					;v5 FORTH_DSP_VALUE 
4604			 
4604 7e					ld a, (hl) 
4605			 
4605 f5					push af 
4606			 
4606			; Dont destroy TOS		FORTH_DSP_POP 
4606			 
4606 f1					pop af 
4607			 
4607 fe 01				cp DS_TYPE_STR 
4609 28 09				jr z, .typestr 
460b			 
460b fe 02				cp DS_TYPE_INUM 
460d 28 0a				jr z, .typeinum 
460f			 
460f 21 28 46				ld hl, .tna 
4612 18 0a				jr .tpush 
4614			 
4614 21 24 46		.typestr:	ld hl, .tstr 
4617 18 05				jr .tpush 
4619 21 26 46		.typeinum:	ld hl, .tinum 
461c 18 00				jr .tpush 
461e			 
461e			.tpush: 
461e			 
461e cd 30 21				call forth_push_str 
4621			 
4621					NEXTW 
4621 c3 6f 24			jp macro_next 
4624				endm 
# End of macro NEXTW
4624 .. 00		.tstr:	db "s",0 
4626 .. 00		.tinum:  db "i",0 
4628 .. 00		.tna:   db "?", 0 
462a			 
462a			 
462a			.UPPER: 
462a				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
462a 48				db WORD_SYS_CORE+52             
462b 65 46			dw .LOWER            
462d 06				db 5 + 1 
462e .. 00			db "UPPER",0              
4634				endm 
# End of macro CWHEAD
4634			; | UPPER ( s -- s ) Upper case string s  | DONE 
4634					if DEBUG_FORTH_WORDS_KEY 
4634						DMARK "UPR" 
4634 f5				push af  
4635 3a 49 46			ld a, (.dmark)  
4638 32 6b fe			ld (debug_mark),a  
463b 3a 4a 46			ld a, (.dmark+1)  
463e 32 6c fe			ld (debug_mark+1),a  
4641 3a 4b 46			ld a, (.dmark+2)  
4644 32 6d fe			ld (debug_mark+2),a  
4647 18 03			jr .pastdmark  
4649 ..			.dmark: db "UPR"  
464c f1			.pastdmark: pop af  
464d			endm  
# End of macro DMARK
464d						CALLMONITOR 
464d cd 6f fe			call debug_vector  
4650				endm  
# End of macro CALLMONITOR
4650					endif 
4650			 
4650					FORTH_DSP 
4650 cd 7f 22			call macro_forth_dsp 
4653				endm 
# End of macro FORTH_DSP
4653					 
4653			; TODO check is string type 
4653			 
4653					FORTH_DSP_VALUEHL 
4653 cd b9 22			call macro_dsp_valuehl 
4656				endm 
# End of macro FORTH_DSP_VALUEHL
4656			; get pointer to string in hl 
4656			 
4656 7e			.toup:		ld a, (hl) 
4657 fe 00				cp 0 
4659 28 07				jr z, .toupdone 
465b			 
465b cd f3 12				call to_upper 
465e			 
465e 77					ld (hl), a 
465f 23					inc hl 
4660 18 f4				jr .toup 
4662			 
4662					 
4662			 
4662			 
4662			; for each char convert to upper 
4662					 
4662			.toupdone: 
4662			 
4662			 
4662					NEXTW 
4662 c3 6f 24			jp macro_next 
4665				endm 
# End of macro NEXTW
4665			.LOWER: 
4665				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4665 48				db WORD_SYS_CORE+52             
4666 a0 46			dw .TCASE            
4668 06				db 5 + 1 
4669 .. 00			db "LOWER",0              
466f				endm 
# End of macro CWHEAD
466f			; | LOWER ( s -- s ) Lower case string s  | DONE 
466f					if DEBUG_FORTH_WORDS_KEY 
466f						DMARK "LWR" 
466f f5				push af  
4670 3a 84 46			ld a, (.dmark)  
4673 32 6b fe			ld (debug_mark),a  
4676 3a 85 46			ld a, (.dmark+1)  
4679 32 6c fe			ld (debug_mark+1),a  
467c 3a 86 46			ld a, (.dmark+2)  
467f 32 6d fe			ld (debug_mark+2),a  
4682 18 03			jr .pastdmark  
4684 ..			.dmark: db "LWR"  
4687 f1			.pastdmark: pop af  
4688			endm  
# End of macro DMARK
4688						CALLMONITOR 
4688 cd 6f fe			call debug_vector  
468b				endm  
# End of macro CALLMONITOR
468b					endif 
468b			 
468b					FORTH_DSP 
468b cd 7f 22			call macro_forth_dsp 
468e				endm 
# End of macro FORTH_DSP
468e					 
468e			; TODO check is string type 
468e			 
468e					FORTH_DSP_VALUEHL 
468e cd b9 22			call macro_dsp_valuehl 
4691				endm 
# End of macro FORTH_DSP_VALUEHL
4691			; get pointer to string in hl 
4691			 
4691 7e			.tolow:		ld a, (hl) 
4692 fe 00				cp 0 
4694 28 07				jr z, .tolowdone 
4696			 
4696 cd fc 12				call to_lower 
4699			 
4699 77					ld (hl), a 
469a 23					inc hl 
469b 18 f4				jr .tolow 
469d			 
469d					 
469d			 
469d			 
469d			; for each char convert to low 
469d					 
469d			.tolowdone: 
469d					NEXTW 
469d c3 6f 24			jp macro_next 
46a0				endm 
# End of macro NEXTW
46a0			.TCASE: 
46a0				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
46a0 48				db WORD_SYS_CORE+52             
46a1 d6 47			dw .SUBSTR            
46a3 06				db 5 + 1 
46a4 .. 00			db "TCASE",0              
46aa				endm 
# End of macro CWHEAD
46aa			; | TCASE ( s -- s ) Title case string s  | DONE 
46aa					if DEBUG_FORTH_WORDS_KEY 
46aa						DMARK "TCS" 
46aa f5				push af  
46ab 3a bf 46			ld a, (.dmark)  
46ae 32 6b fe			ld (debug_mark),a  
46b1 3a c0 46			ld a, (.dmark+1)  
46b4 32 6c fe			ld (debug_mark+1),a  
46b7 3a c1 46			ld a, (.dmark+2)  
46ba 32 6d fe			ld (debug_mark+2),a  
46bd 18 03			jr .pastdmark  
46bf ..			.dmark: db "TCS"  
46c2 f1			.pastdmark: pop af  
46c3			endm  
# End of macro DMARK
46c3						CALLMONITOR 
46c3 cd 6f fe			call debug_vector  
46c6				endm  
# End of macro CALLMONITOR
46c6					endif 
46c6			 
46c6					FORTH_DSP 
46c6 cd 7f 22			call macro_forth_dsp 
46c9				endm 
# End of macro FORTH_DSP
46c9					 
46c9			; TODO check is string type 
46c9			 
46c9					FORTH_DSP_VALUEHL 
46c9 cd b9 22			call macro_dsp_valuehl 
46cc				endm 
# End of macro FORTH_DSP_VALUEHL
46cc			; get pointer to string in hl 
46cc			 
46cc					if DEBUG_FORTH_WORDS 
46cc						DMARK "TC1" 
46cc f5				push af  
46cd 3a e1 46			ld a, (.dmark)  
46d0 32 6b fe			ld (debug_mark),a  
46d3 3a e2 46			ld a, (.dmark+1)  
46d6 32 6c fe			ld (debug_mark+1),a  
46d9 3a e3 46			ld a, (.dmark+2)  
46dc 32 6d fe			ld (debug_mark+2),a  
46df 18 03			jr .pastdmark  
46e1 ..			.dmark: db "TC1"  
46e4 f1			.pastdmark: pop af  
46e5			endm  
# End of macro DMARK
46e5						CALLMONITOR 
46e5 cd 6f fe			call debug_vector  
46e8				endm  
# End of macro CALLMONITOR
46e8					endif 
46e8			 
46e8					; first time in turn to upper case first char 
46e8			 
46e8 7e					ld a, (hl) 
46e9 c3 73 47				jp .totsiptou 
46ec			 
46ec			 
46ec 7e			.tot:		ld a, (hl) 
46ed fe 00				cp 0 
46ef ca b7 47				jp z, .totdone 
46f2			 
46f2					if DEBUG_FORTH_WORDS 
46f2						DMARK "TC2" 
46f2 f5				push af  
46f3 3a 07 47			ld a, (.dmark)  
46f6 32 6b fe			ld (debug_mark),a  
46f9 3a 08 47			ld a, (.dmark+1)  
46fc 32 6c fe			ld (debug_mark+1),a  
46ff 3a 09 47			ld a, (.dmark+2)  
4702 32 6d fe			ld (debug_mark+2),a  
4705 18 03			jr .pastdmark  
4707 ..			.dmark: db "TC2"  
470a f1			.pastdmark: pop af  
470b			endm  
# End of macro DMARK
470b						CALLMONITOR 
470b cd 6f fe			call debug_vector  
470e				endm  
# End of macro CALLMONITOR
470e					endif 
470e					; check to see if current char is a space 
470e			 
470e fe 20				cp ' ' 
4710 28 21				jr z, .totsp 
4712 cd fc 12				call to_lower 
4715					if DEBUG_FORTH_WORDS 
4715						DMARK "TC3" 
4715 f5				push af  
4716 3a 2a 47			ld a, (.dmark)  
4719 32 6b fe			ld (debug_mark),a  
471c 3a 2b 47			ld a, (.dmark+1)  
471f 32 6c fe			ld (debug_mark+1),a  
4722 3a 2c 47			ld a, (.dmark+2)  
4725 32 6d fe			ld (debug_mark+2),a  
4728 18 03			jr .pastdmark  
472a ..			.dmark: db "TC3"  
472d f1			.pastdmark: pop af  
472e			endm  
# End of macro DMARK
472e						CALLMONITOR 
472e cd 6f fe			call debug_vector  
4731				endm  
# End of macro CALLMONITOR
4731					endif 
4731 18 63				jr .totnxt 
4733			 
4733			.totsp:         ; on a space, find next char which should be upper 
4733			 
4733					if DEBUG_FORTH_WORDS 
4733						DMARK "TC4" 
4733 f5				push af  
4734 3a 48 47			ld a, (.dmark)  
4737 32 6b fe			ld (debug_mark),a  
473a 3a 49 47			ld a, (.dmark+1)  
473d 32 6c fe			ld (debug_mark+1),a  
4740 3a 4a 47			ld a, (.dmark+2)  
4743 32 6d fe			ld (debug_mark+2),a  
4746 18 03			jr .pastdmark  
4748 ..			.dmark: db "TC4"  
474b f1			.pastdmark: pop af  
474c			endm  
# End of macro DMARK
474c						CALLMONITOR 
474c cd 6f fe			call debug_vector  
474f				endm  
# End of macro CALLMONITOR
474f					endif 
474f					;; 
474f			 
474f fe 20				cp ' ' 
4751 20 20				jr nz, .totsiptou 
4753 23					inc hl 
4754 7e					ld a, (hl) 
4755					if DEBUG_FORTH_WORDS 
4755						DMARK "TC5" 
4755 f5				push af  
4756 3a 6a 47			ld a, (.dmark)  
4759 32 6b fe			ld (debug_mark),a  
475c 3a 6b 47			ld a, (.dmark+1)  
475f 32 6c fe			ld (debug_mark+1),a  
4762 3a 6c 47			ld a, (.dmark+2)  
4765 32 6d fe			ld (debug_mark+2),a  
4768 18 03			jr .pastdmark  
476a ..			.dmark: db "TC5"  
476d f1			.pastdmark: pop af  
476e			endm  
# End of macro DMARK
476e						CALLMONITOR 
476e cd 6f fe			call debug_vector  
4771				endm  
# End of macro CALLMONITOR
4771					endif 
4771 18 c0				jr .totsp 
4773 fe 00		.totsiptou:    cp 0 
4775 28 40				jr z, .totdone 
4777					; not space and not zero term so upper case it 
4777 cd f3 12				call to_upper 
477a			 
477a					if DEBUG_FORTH_WORDS 
477a						DMARK "TC6" 
477a f5				push af  
477b 3a 8f 47			ld a, (.dmark)  
477e 32 6b fe			ld (debug_mark),a  
4781 3a 90 47			ld a, (.dmark+1)  
4784 32 6c fe			ld (debug_mark+1),a  
4787 3a 91 47			ld a, (.dmark+2)  
478a 32 6d fe			ld (debug_mark+2),a  
478d 18 03			jr .pastdmark  
478f ..			.dmark: db "TC6"  
4792 f1			.pastdmark: pop af  
4793			endm  
# End of macro DMARK
4793						CALLMONITOR 
4793 cd 6f fe			call debug_vector  
4796				endm  
# End of macro CALLMONITOR
4796					endif 
4796			 
4796			 
4796			.totnxt: 
4796			 
4796 77					ld (hl), a 
4797 23					inc hl 
4798					if DEBUG_FORTH_WORDS 
4798						DMARK "TC7" 
4798 f5				push af  
4799 3a ad 47			ld a, (.dmark)  
479c 32 6b fe			ld (debug_mark),a  
479f 3a ae 47			ld a, (.dmark+1)  
47a2 32 6c fe			ld (debug_mark+1),a  
47a5 3a af 47			ld a, (.dmark+2)  
47a8 32 6d fe			ld (debug_mark+2),a  
47ab 18 03			jr .pastdmark  
47ad ..			.dmark: db "TC7"  
47b0 f1			.pastdmark: pop af  
47b1			endm  
# End of macro DMARK
47b1						CALLMONITOR 
47b1 cd 6f fe			call debug_vector  
47b4				endm  
# End of macro CALLMONITOR
47b4					endif 
47b4 c3 ec 46				jp .tot 
47b7			 
47b7					 
47b7			 
47b7			 
47b7			; for each char convert to low 
47b7					 
47b7			.totdone: 
47b7					if DEBUG_FORTH_WORDS 
47b7						DMARK "TCd" 
47b7 f5				push af  
47b8 3a cc 47			ld a, (.dmark)  
47bb 32 6b fe			ld (debug_mark),a  
47be 3a cd 47			ld a, (.dmark+1)  
47c1 32 6c fe			ld (debug_mark+1),a  
47c4 3a ce 47			ld a, (.dmark+2)  
47c7 32 6d fe			ld (debug_mark+2),a  
47ca 18 03			jr .pastdmark  
47cc ..			.dmark: db "TCd"  
47cf f1			.pastdmark: pop af  
47d0			endm  
# End of macro DMARK
47d0						CALLMONITOR 
47d0 cd 6f fe			call debug_vector  
47d3				endm  
# End of macro CALLMONITOR
47d3					endif 
47d3					NEXTW 
47d3 c3 6f 24			jp macro_next 
47d6				endm 
# End of macro NEXTW
47d6			 
47d6			.SUBSTR: 
47d6				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
47d6 48				db WORD_SYS_CORE+52             
47d7 34 48			dw .LEFT            
47d9 07				db 6 + 1 
47da .. 00			db "SUBSTR",0              
47e1				endm 
# End of macro CWHEAD
47e1			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
47e1			 
47e1					if DEBUG_FORTH_WORDS_KEY 
47e1						DMARK "SST" 
47e1 f5				push af  
47e2 3a f6 47			ld a, (.dmark)  
47e5 32 6b fe			ld (debug_mark),a  
47e8 3a f7 47			ld a, (.dmark+1)  
47eb 32 6c fe			ld (debug_mark+1),a  
47ee 3a f8 47			ld a, (.dmark+2)  
47f1 32 6d fe			ld (debug_mark+2),a  
47f4 18 03			jr .pastdmark  
47f6 ..			.dmark: db "SST"  
47f9 f1			.pastdmark: pop af  
47fa			endm  
# End of macro DMARK
47fa						CALLMONITOR 
47fa cd 6f fe			call debug_vector  
47fd				endm  
# End of macro CALLMONITOR
47fd					endif 
47fd			; TODO check string type 
47fd					FORTH_DSP_VALUEHL 
47fd cd b9 22			call macro_dsp_valuehl 
4800				endm 
# End of macro FORTH_DSP_VALUEHL
4800			 
4800 e5					push hl      ; string length 
4801			 
4801					FORTH_DSP_POP 
4801 cd 71 23			call macro_forth_dsp_pop 
4804				endm 
# End of macro FORTH_DSP_POP
4804			 
4804					FORTH_DSP_VALUEHL 
4804 cd b9 22			call macro_dsp_valuehl 
4807				endm 
# End of macro FORTH_DSP_VALUEHL
4807			 
4807 e5					push hl     ; start char 
4808			 
4808					FORTH_DSP_POP 
4808 cd 71 23			call macro_forth_dsp_pop 
480b				endm 
# End of macro FORTH_DSP_POP
480b			 
480b			 
480b					FORTH_DSP_VALUE 
480b cd a2 22			call macro_forth_dsp_value 
480e				endm 
# End of macro FORTH_DSP_VALUE
480e			 
480e d1					pop de    ; get start post offset 
480f			 
480f 19					add hl, de    ; starting offset 
4810			 
4810 c1					pop bc 
4811 c5					push bc      ; grab size of string 
4812			 
4812 e5					push hl    ; save string start  
4813			 
4813 26 00				ld h, 0 
4815 69					ld l, c 
4816 23					inc hl 
4817 23					inc hl 
4818			 
4818 cd 4d 14				call malloc 
481b				if DEBUG_FORTH_MALLOC_GUARD 
481b cc 8f 5d				call z,malloc_error 
481e				endif 
481e			 
481e eb					ex de, hl      ; save malloc area for string copy 
481f e1					pop hl    ; get back source 
4820 c1					pop bc    ; get length of string back 
4821			 
4821 d5					push de    ; save malloc area for after we push 
4822 ed b0				ldir     ; copy substr 
4824			 
4824			 
4824 eb					ex de, hl 
4825 3e 00				ld a, 0 
4827 77					ld (hl), a   ; term substr 
4828			 
4828					 
4828 e1					pop hl    ; get malloc so we can push it 
4829 e5					push hl   ; save so we can free it afterwards 
482a			 
482a cd 30 21				call forth_push_str 
482d			 
482d e1					pop hl 
482e cd 17 15				call free 
4831			 
4831					 
4831					 
4831			 
4831			 
4831					NEXTW 
4831 c3 6f 24			jp macro_next 
4834				endm 
# End of macro NEXTW
4834			 
4834			.LEFT: 
4834				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4834 48				db WORD_SYS_CORE+52             
4835 5c 48			dw .RIGHT            
4837 05				db 4 + 1 
4838 .. 00			db "LEFT",0              
483d				endm 
# End of macro CWHEAD
483d			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
483d					if DEBUG_FORTH_WORDS_KEY 
483d						DMARK "LEF" 
483d f5				push af  
483e 3a 52 48			ld a, (.dmark)  
4841 32 6b fe			ld (debug_mark),a  
4844 3a 53 48			ld a, (.dmark+1)  
4847 32 6c fe			ld (debug_mark+1),a  
484a 3a 54 48			ld a, (.dmark+2)  
484d 32 6d fe			ld (debug_mark+2),a  
4850 18 03			jr .pastdmark  
4852 ..			.dmark: db "LEF"  
4855 f1			.pastdmark: pop af  
4856			endm  
# End of macro DMARK
4856						CALLMONITOR 
4856 cd 6f fe			call debug_vector  
4859				endm  
# End of macro CALLMONITOR
4859					endif 
4859			 
4859					NEXTW 
4859 c3 6f 24			jp macro_next 
485c				endm 
# End of macro NEXTW
485c			.RIGHT: 
485c				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
485c 48				db WORD_SYS_CORE+52             
485d 85 48			dw .STR2NUM            
485f 06				db 5 + 1 
4860 .. 00			db "RIGHT",0              
4866				endm 
# End of macro CWHEAD
4866			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4866					if DEBUG_FORTH_WORDS_KEY 
4866						DMARK "RIG" 
4866 f5				push af  
4867 3a 7b 48			ld a, (.dmark)  
486a 32 6b fe			ld (debug_mark),a  
486d 3a 7c 48			ld a, (.dmark+1)  
4870 32 6c fe			ld (debug_mark+1),a  
4873 3a 7d 48			ld a, (.dmark+2)  
4876 32 6d fe			ld (debug_mark+2),a  
4879 18 03			jr .pastdmark  
487b ..			.dmark: db "RIG"  
487e f1			.pastdmark: pop af  
487f			endm  
# End of macro DMARK
487f						CALLMONITOR 
487f cd 6f fe			call debug_vector  
4882				endm  
# End of macro CALLMONITOR
4882					endif 
4882			 
4882					NEXTW 
4882 c3 6f 24			jp macro_next 
4885				endm 
# End of macro NEXTW
4885			 
4885			 
4885			.STR2NUM: 
4885				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4885 48				db WORD_SYS_CORE+52             
4886 11 49			dw .NUM2STR            
4888 08				db 7 + 1 
4889 .. 00			db "STR2NUM",0              
4891				endm 
# End of macro CWHEAD
4891			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4891			 
4891			 
4891			; TODO STR type check to do 
4891					if DEBUG_FORTH_WORDS_KEY 
4891						DMARK "S2N" 
4891 f5				push af  
4892 3a a6 48			ld a, (.dmark)  
4895 32 6b fe			ld (debug_mark),a  
4898 3a a7 48			ld a, (.dmark+1)  
489b 32 6c fe			ld (debug_mark+1),a  
489e 3a a8 48			ld a, (.dmark+2)  
48a1 32 6d fe			ld (debug_mark+2),a  
48a4 18 03			jr .pastdmark  
48a6 ..			.dmark: db "S2N"  
48a9 f1			.pastdmark: pop af  
48aa			endm  
# End of macro DMARK
48aa						CALLMONITOR 
48aa cd 6f fe			call debug_vector  
48ad				endm  
# End of macro CALLMONITOR
48ad					endif 
48ad			 
48ad					;FORTH_DSP 
48ad					FORTH_DSP_VALUE 
48ad cd a2 22			call macro_forth_dsp_value 
48b0				endm 
# End of macro FORTH_DSP_VALUE
48b0					;inc hl 
48b0			 
48b0 eb					ex de, hl 
48b1					if DEBUG_FORTH_WORDS 
48b1						DMARK "S2a" 
48b1 f5				push af  
48b2 3a c6 48			ld a, (.dmark)  
48b5 32 6b fe			ld (debug_mark),a  
48b8 3a c7 48			ld a, (.dmark+1)  
48bb 32 6c fe			ld (debug_mark+1),a  
48be 3a c8 48			ld a, (.dmark+2)  
48c1 32 6d fe			ld (debug_mark+2),a  
48c4 18 03			jr .pastdmark  
48c6 ..			.dmark: db "S2a"  
48c9 f1			.pastdmark: pop af  
48ca			endm  
# End of macro DMARK
48ca						CALLMONITOR 
48ca cd 6f fe			call debug_vector  
48cd				endm  
# End of macro CALLMONITOR
48cd					endif 
48cd cd 7b 13				call string_to_uint16 
48d0			 
48d0					if DEBUG_FORTH_WORDS 
48d0						DMARK "S2b" 
48d0 f5				push af  
48d1 3a e5 48			ld a, (.dmark)  
48d4 32 6b fe			ld (debug_mark),a  
48d7 3a e6 48			ld a, (.dmark+1)  
48da 32 6c fe			ld (debug_mark+1),a  
48dd 3a e7 48			ld a, (.dmark+2)  
48e0 32 6d fe			ld (debug_mark+2),a  
48e3 18 03			jr .pastdmark  
48e5 ..			.dmark: db "S2b"  
48e8 f1			.pastdmark: pop af  
48e9			endm  
# End of macro DMARK
48e9						CALLMONITOR 
48e9 cd 6f fe			call debug_vector  
48ec				endm  
# End of macro CALLMONITOR
48ec					endif 
48ec			;		push hl 
48ec					FORTH_DSP_POP 
48ec cd 71 23			call macro_forth_dsp_pop 
48ef				endm 
# End of macro FORTH_DSP_POP
48ef			;		pop hl 
48ef					 
48ef					if DEBUG_FORTH_WORDS 
48ef						DMARK "S2b" 
48ef f5				push af  
48f0 3a 04 49			ld a, (.dmark)  
48f3 32 6b fe			ld (debug_mark),a  
48f6 3a 05 49			ld a, (.dmark+1)  
48f9 32 6c fe			ld (debug_mark+1),a  
48fc 3a 06 49			ld a, (.dmark+2)  
48ff 32 6d fe			ld (debug_mark+2),a  
4902 18 03			jr .pastdmark  
4904 ..			.dmark: db "S2b"  
4907 f1			.pastdmark: pop af  
4908			endm  
# End of macro DMARK
4908						CALLMONITOR 
4908 cd 6f fe			call debug_vector  
490b				endm  
# End of macro CALLMONITOR
490b					endif 
490b cd c2 20				call forth_push_numhl	 
490e			 
490e				 
490e				       NEXTW 
490e c3 6f 24			jp macro_next 
4911				endm 
# End of macro NEXTW
4911			.NUM2STR: 
4911				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4911 48				db WORD_SYS_CORE+52             
4912 20 49			dw .CONCAT            
4914 08				db 7 + 1 
4915 .. 00			db "NUM2STR",0              
491d				endm 
# End of macro CWHEAD
491d			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
491d			 
491d			;		; malloc a string to target 
491d			;		ld hl, 10     ; TODO max string size should be fine 
491d			;		call malloc 
491d			;		push hl    ; save malloc location 
491d			; 
491d			; 
491d			;; TODO check int type 
491d			;		FORTH_DSP_VALUEHL 
491d			;		ld a, l 
491d			;		call DispAToASCII   
491d			;;TODO need to chage above call to dump into string 
491d			; 
491d			; 
491d			 
491d				       NEXTW 
491d c3 6f 24			jp macro_next 
4920				endm 
# End of macro NEXTW
4920			 
4920			.CONCAT: 
4920				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4920 48				db WORD_SYS_CORE+52             
4921 d3 49			dw .FIND            
4923 07				db 6 + 1 
4924 .. 00			db "CONCAT",0              
492b				endm 
# End of macro CWHEAD
492b			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
492b			 
492b			; TODO check string type 
492b			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
492b			 
492b					if DEBUG_FORTH_WORDS_KEY 
492b						DMARK "CON" 
492b f5				push af  
492c 3a 40 49			ld a, (.dmark)  
492f 32 6b fe			ld (debug_mark),a  
4932 3a 41 49			ld a, (.dmark+1)  
4935 32 6c fe			ld (debug_mark+1),a  
4938 3a 42 49			ld a, (.dmark+2)  
493b 32 6d fe			ld (debug_mark+2),a  
493e 18 03			jr .pastdmark  
4940 ..			.dmark: db "CON"  
4943 f1			.pastdmark: pop af  
4944			endm  
# End of macro DMARK
4944						CALLMONITOR 
4944 cd 6f fe			call debug_vector  
4947				endm  
# End of macro CALLMONITOR
4947					endif 
4947			 
4947			 
4947					FORTH_DSP_VALUE 
4947 cd a2 22			call macro_forth_dsp_value 
494a				endm 
# End of macro FORTH_DSP_VALUE
494a e5					push hl   ; s2 
494b			 
494b					FORTH_DSP_POP 
494b cd 71 23			call macro_forth_dsp_pop 
494e				endm 
# End of macro FORTH_DSP_POP
494e			 
494e					FORTH_DSP_VALUE 
494e cd a2 22			call macro_forth_dsp_value 
4951				endm 
# End of macro FORTH_DSP_VALUE
4951			 
4951 e5					push hl   ; s1 
4952			 
4952					FORTH_DSP_POP 
4952 cd 71 23			call macro_forth_dsp_pop 
4955				endm 
# End of macro FORTH_DSP_POP
4955					 
4955			 
4955					; copy s1 
4955			 
4955				 
4955					; save ptr 
4955 e1					pop hl  
4956 e5					push hl 
4957 3e 00				ld a, 0 
4959 cd ef 13				call strlent 
495c					;inc hl    ; zer0 
495c 06 00				ld b, 0 
495e 4d					ld c, l 
495f e1					pop hl		 
4960 11 c1 f1				ld de, scratch	 
4963					if DEBUG_FORTH_WORDS 
4963						DMARK "CO1" 
4963 f5				push af  
4964 3a 78 49			ld a, (.dmark)  
4967 32 6b fe			ld (debug_mark),a  
496a 3a 79 49			ld a, (.dmark+1)  
496d 32 6c fe			ld (debug_mark+1),a  
4970 3a 7a 49			ld a, (.dmark+2)  
4973 32 6d fe			ld (debug_mark+2),a  
4976 18 03			jr .pastdmark  
4978 ..			.dmark: db "CO1"  
497b f1			.pastdmark: pop af  
497c			endm  
# End of macro DMARK
497c						CALLMONITOR 
497c cd 6f fe			call debug_vector  
497f				endm  
# End of macro CALLMONITOR
497f					endif 
497f ed b0				ldir 
4981			 
4981 e1					pop hl 
4982 e5					push hl 
4983 d5					push de 
4984			 
4984			 
4984 3e 00				ld a, 0 
4986 cd ef 13				call strlent 
4989 23					inc hl    ; zer0 
498a 23					inc hl 
498b 06 00				ld b, 0 
498d 4d					ld c, l 
498e d1					pop de 
498f e1					pop hl		 
4990					if DEBUG_FORTH_WORDS 
4990						DMARK "CO2" 
4990 f5				push af  
4991 3a a5 49			ld a, (.dmark)  
4994 32 6b fe			ld (debug_mark),a  
4997 3a a6 49			ld a, (.dmark+1)  
499a 32 6c fe			ld (debug_mark+1),a  
499d 3a a7 49			ld a, (.dmark+2)  
49a0 32 6d fe			ld (debug_mark+2),a  
49a3 18 03			jr .pastdmark  
49a5 ..			.dmark: db "CO2"  
49a8 f1			.pastdmark: pop af  
49a9			endm  
# End of macro DMARK
49a9						CALLMONITOR 
49a9 cd 6f fe			call debug_vector  
49ac				endm  
# End of macro CALLMONITOR
49ac					endif 
49ac ed b0				ldir 
49ae			 
49ae			 
49ae			 
49ae 21 c1 f1				ld hl, scratch 
49b1					if DEBUG_FORTH_WORDS 
49b1						DMARK "CO5" 
49b1 f5				push af  
49b2 3a c6 49			ld a, (.dmark)  
49b5 32 6b fe			ld (debug_mark),a  
49b8 3a c7 49			ld a, (.dmark+1)  
49bb 32 6c fe			ld (debug_mark+1),a  
49be 3a c8 49			ld a, (.dmark+2)  
49c1 32 6d fe			ld (debug_mark+2),a  
49c4 18 03			jr .pastdmark  
49c6 ..			.dmark: db "CO5"  
49c9 f1			.pastdmark: pop af  
49ca			endm  
# End of macro DMARK
49ca						CALLMONITOR 
49ca cd 6f fe			call debug_vector  
49cd				endm  
# End of macro CALLMONITOR
49cd					endif 
49cd			 
49cd cd 30 21				call forth_push_str 
49d0			 
49d0			 
49d0			 
49d0			 
49d0				       NEXTW 
49d0 c3 6f 24			jp macro_next 
49d3				endm 
# End of macro NEXTW
49d3			 
49d3			 
49d3			.FIND: 
49d3				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
49d3 4b				db WORD_SYS_CORE+55             
49d4 91 4a			dw .LEN            
49d6 05				db 4 + 1 
49d7 .. 00			db "FIND",0              
49dc				endm 
# End of macro CWHEAD
49dc			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
49dc			 
49dc					if DEBUG_FORTH_WORDS_KEY 
49dc						DMARK "FND" 
49dc f5				push af  
49dd 3a f1 49			ld a, (.dmark)  
49e0 32 6b fe			ld (debug_mark),a  
49e3 3a f2 49			ld a, (.dmark+1)  
49e6 32 6c fe			ld (debug_mark+1),a  
49e9 3a f3 49			ld a, (.dmark+2)  
49ec 32 6d fe			ld (debug_mark+2),a  
49ef 18 03			jr .pastdmark  
49f1 ..			.dmark: db "FND"  
49f4 f1			.pastdmark: pop af  
49f5			endm  
# End of macro DMARK
49f5						CALLMONITOR 
49f5 cd 6f fe			call debug_vector  
49f8				endm  
# End of macro CALLMONITOR
49f8					endif 
49f8			 
49f8			; TODO check string type 
49f8					FORTH_DSP_VALUE 
49f8 cd a2 22			call macro_forth_dsp_value 
49fb				endm 
# End of macro FORTH_DSP_VALUE
49fb			 
49fb e5					push hl    
49fc 7e					ld a,(hl)    ; char to find   
49fd			; TODO change char to substr 
49fd			 
49fd f5					push af 
49fe					 
49fe			 
49fe			 
49fe					if DEBUG_FORTH_WORDS 
49fe						DMARK "FN1" 
49fe f5				push af  
49ff 3a 13 4a			ld a, (.dmark)  
4a02 32 6b fe			ld (debug_mark),a  
4a05 3a 14 4a			ld a, (.dmark+1)  
4a08 32 6c fe			ld (debug_mark+1),a  
4a0b 3a 15 4a			ld a, (.dmark+2)  
4a0e 32 6d fe			ld (debug_mark+2),a  
4a11 18 03			jr .pastdmark  
4a13 ..			.dmark: db "FN1"  
4a16 f1			.pastdmark: pop af  
4a17			endm  
# End of macro DMARK
4a17						CALLMONITOR 
4a17 cd 6f fe			call debug_vector  
4a1a				endm  
# End of macro CALLMONITOR
4a1a					endif 
4a1a			 
4a1a					FORTH_DSP_POP 
4a1a cd 71 23			call macro_forth_dsp_pop 
4a1d				endm 
# End of macro FORTH_DSP_POP
4a1d			 
4a1d					; string to search 
4a1d			 
4a1d					FORTH_DSP_VALUE 
4a1d cd a2 22			call macro_forth_dsp_value 
4a20				endm 
# End of macro FORTH_DSP_VALUE
4a20			 
4a20 d1					pop de  ; d is char to find  
4a21			 
4a21					if DEBUG_FORTH_WORDS 
4a21						DMARK "FN2" 
4a21 f5				push af  
4a22 3a 36 4a			ld a, (.dmark)  
4a25 32 6b fe			ld (debug_mark),a  
4a28 3a 37 4a			ld a, (.dmark+1)  
4a2b 32 6c fe			ld (debug_mark+1),a  
4a2e 3a 38 4a			ld a, (.dmark+2)  
4a31 32 6d fe			ld (debug_mark+2),a  
4a34 18 03			jr .pastdmark  
4a36 ..			.dmark: db "FN2"  
4a39 f1			.pastdmark: pop af  
4a3a			endm  
# End of macro DMARK
4a3a						CALLMONITOR 
4a3a cd 6f fe			call debug_vector  
4a3d				endm  
# End of macro CALLMONITOR
4a3d					endif 
4a3d					 
4a3d 01 00 00				ld bc, 0 
4a40 7e			.findchar:      ld a,(hl) 
4a41 fe 00				cp 0   		 
4a43 28 27				jr z, .finddone     
4a45 ba					cp d 
4a46 28 20				jr z, .foundchar 
4a48 03					inc bc 
4a49 23					inc hl 
4a4a					if DEBUG_FORTH_WORDS 
4a4a						DMARK "FN3" 
4a4a f5				push af  
4a4b 3a 5f 4a			ld a, (.dmark)  
4a4e 32 6b fe			ld (debug_mark),a  
4a51 3a 60 4a			ld a, (.dmark+1)  
4a54 32 6c fe			ld (debug_mark+1),a  
4a57 3a 61 4a			ld a, (.dmark+2)  
4a5a 32 6d fe			ld (debug_mark+2),a  
4a5d 18 03			jr .pastdmark  
4a5f ..			.dmark: db "FN3"  
4a62 f1			.pastdmark: pop af  
4a63			endm  
# End of macro DMARK
4a63						CALLMONITOR 
4a63 cd 6f fe			call debug_vector  
4a66				endm  
# End of macro CALLMONITOR
4a66					endif 
4a66 18 d8				jr .findchar 
4a68			 
4a68			 
4a68 c5			.foundchar:	push bc 
4a69 e1					pop hl 
4a6a 18 03				jr .findexit 
4a6c			 
4a6c			 
4a6c							 
4a6c			 
4a6c			.finddone:     ; got to end of string with no find 
4a6c 21 00 00				ld hl, 0 
4a6f			.findexit: 
4a6f			 
4a6f					if DEBUG_FORTH_WORDS 
4a6f						DMARK "FNd" 
4a6f f5				push af  
4a70 3a 84 4a			ld a, (.dmark)  
4a73 32 6b fe			ld (debug_mark),a  
4a76 3a 85 4a			ld a, (.dmark+1)  
4a79 32 6c fe			ld (debug_mark+1),a  
4a7c 3a 86 4a			ld a, (.dmark+2)  
4a7f 32 6d fe			ld (debug_mark+2),a  
4a82 18 03			jr .pastdmark  
4a84 ..			.dmark: db "FNd"  
4a87 f1			.pastdmark: pop af  
4a88			endm  
# End of macro DMARK
4a88						CALLMONITOR 
4a88 cd 6f fe			call debug_vector  
4a8b				endm  
# End of macro CALLMONITOR
4a8b					endif 
4a8b cd c2 20			call forth_push_numhl 
4a8e			 
4a8e				       NEXTW 
4a8e c3 6f 24			jp macro_next 
4a91				endm 
# End of macro NEXTW
4a91			 
4a91			.LEN: 
4a91				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4a91 4c				db WORD_SYS_CORE+56             
4a92 fb 4a			dw .ASC            
4a94 06				db 5 + 1 
4a95 .. 00			db "COUNT",0              
4a9b				endm 
# End of macro CWHEAD
4a9b			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4a9b			 
4a9b					if DEBUG_FORTH_WORDS_KEY 
4a9b						DMARK "CNT" 
4a9b f5				push af  
4a9c 3a b0 4a			ld a, (.dmark)  
4a9f 32 6b fe			ld (debug_mark),a  
4aa2 3a b1 4a			ld a, (.dmark+1)  
4aa5 32 6c fe			ld (debug_mark+1),a  
4aa8 3a b2 4a			ld a, (.dmark+2)  
4aab 32 6d fe			ld (debug_mark+2),a  
4aae 18 03			jr .pastdmark  
4ab0 ..			.dmark: db "CNT"  
4ab3 f1			.pastdmark: pop af  
4ab4			endm  
# End of macro DMARK
4ab4						CALLMONITOR 
4ab4 cd 6f fe			call debug_vector  
4ab7				endm  
# End of macro CALLMONITOR
4ab7					endif 
4ab7			; TODO check string type 
4ab7					FORTH_DSP_VALUE 
4ab7 cd a2 22			call macro_forth_dsp_value 
4aba				endm 
# End of macro FORTH_DSP_VALUE
4aba			 
4aba			 
4aba					if DEBUG_FORTH_WORDS 
4aba						DMARK "CN?" 
4aba f5				push af  
4abb 3a cf 4a			ld a, (.dmark)  
4abe 32 6b fe			ld (debug_mark),a  
4ac1 3a d0 4a			ld a, (.dmark+1)  
4ac4 32 6c fe			ld (debug_mark+1),a  
4ac7 3a d1 4a			ld a, (.dmark+2)  
4aca 32 6d fe			ld (debug_mark+2),a  
4acd 18 03			jr .pastdmark  
4acf ..			.dmark: db "CN?"  
4ad2 f1			.pastdmark: pop af  
4ad3			endm  
# End of macro DMARK
4ad3						CALLMONITOR 
4ad3 cd 6f fe			call debug_vector  
4ad6				endm  
# End of macro CALLMONITOR
4ad6					endif 
4ad6 cd e4 13				call strlenz 
4ad9					if DEBUG_FORTH_WORDS 
4ad9						DMARK "CNl" 
4ad9 f5				push af  
4ada 3a ee 4a			ld a, (.dmark)  
4add 32 6b fe			ld (debug_mark),a  
4ae0 3a ef 4a			ld a, (.dmark+1)  
4ae3 32 6c fe			ld (debug_mark+1),a  
4ae6 3a f0 4a			ld a, (.dmark+2)  
4ae9 32 6d fe			ld (debug_mark+2),a  
4aec 18 03			jr .pastdmark  
4aee ..			.dmark: db "CNl"  
4af1 f1			.pastdmark: pop af  
4af2			endm  
# End of macro DMARK
4af2						CALLMONITOR 
4af2 cd 6f fe			call debug_vector  
4af5				endm  
# End of macro CALLMONITOR
4af5					endif 
4af5			 
4af5 cd c2 20				call forth_push_numhl 
4af8			 
4af8			 
4af8			 
4af8				       NEXTW 
4af8 c3 6f 24			jp macro_next 
4afb				endm 
# End of macro NEXTW
4afb			.ASC: 
4afb				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4afb 4d				db WORD_SYS_CORE+57             
4afc 69 4b			dw .CHR            
4afe 04				db 3 + 1 
4aff .. 00			db "ASC",0              
4b03				endm 
# End of macro CWHEAD
4b03			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4b03					if DEBUG_FORTH_WORDS_KEY 
4b03						DMARK "ASC" 
4b03 f5				push af  
4b04 3a 18 4b			ld a, (.dmark)  
4b07 32 6b fe			ld (debug_mark),a  
4b0a 3a 19 4b			ld a, (.dmark+1)  
4b0d 32 6c fe			ld (debug_mark+1),a  
4b10 3a 1a 4b			ld a, (.dmark+2)  
4b13 32 6d fe			ld (debug_mark+2),a  
4b16 18 03			jr .pastdmark  
4b18 ..			.dmark: db "ASC"  
4b1b f1			.pastdmark: pop af  
4b1c			endm  
# End of macro DMARK
4b1c						CALLMONITOR 
4b1c cd 6f fe			call debug_vector  
4b1f				endm  
# End of macro CALLMONITOR
4b1f					endif 
4b1f					FORTH_DSP_VALUE 
4b1f cd a2 22			call macro_forth_dsp_value 
4b22				endm 
# End of macro FORTH_DSP_VALUE
4b22					;v5 FORTH_DSP_VALUE 
4b22			;		inc hl      ; now at start of numeric as string 
4b22			 
4b22 e5					push hl 
4b23			 
4b23					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b23 cd 71 23			call macro_forth_dsp_pop 
4b26				endm 
# End of macro FORTH_DSP_POP
4b26			 
4b26 e1					pop hl 
4b27			 
4b27					if DEBUG_FORTH_WORDS 
4b27						DMARK "AS1" 
4b27 f5				push af  
4b28 3a 3c 4b			ld a, (.dmark)  
4b2b 32 6b fe			ld (debug_mark),a  
4b2e 3a 3d 4b			ld a, (.dmark+1)  
4b31 32 6c fe			ld (debug_mark+1),a  
4b34 3a 3e 4b			ld a, (.dmark+2)  
4b37 32 6d fe			ld (debug_mark+2),a  
4b3a 18 03			jr .pastdmark  
4b3c ..			.dmark: db "AS1"  
4b3f f1			.pastdmark: pop af  
4b40			endm  
# End of macro DMARK
4b40						CALLMONITOR 
4b40 cd 6f fe			call debug_vector  
4b43				endm  
# End of macro CALLMONITOR
4b43					endif 
4b43					; push the content of a onto the stack as a value 
4b43			 
4b43 7e					ld a,(hl)   ; get char 
4b44 26 00				ld h,0 
4b46 6f					ld l,a 
4b47					if DEBUG_FORTH_WORDS 
4b47						DMARK "AS2" 
4b47 f5				push af  
4b48 3a 5c 4b			ld a, (.dmark)  
4b4b 32 6b fe			ld (debug_mark),a  
4b4e 3a 5d 4b			ld a, (.dmark+1)  
4b51 32 6c fe			ld (debug_mark+1),a  
4b54 3a 5e 4b			ld a, (.dmark+2)  
4b57 32 6d fe			ld (debug_mark+2),a  
4b5a 18 03			jr .pastdmark  
4b5c ..			.dmark: db "AS2"  
4b5f f1			.pastdmark: pop af  
4b60			endm  
# End of macro DMARK
4b60						CALLMONITOR 
4b60 cd 6f fe			call debug_vector  
4b63				endm  
# End of macro CALLMONITOR
4b63					endif 
4b63 cd c2 20				call forth_push_numhl 
4b66			 
4b66				       NEXTW 
4b66 c3 6f 24			jp macro_next 
4b69				endm 
# End of macro NEXTW
4b69			 
4b69			.CHR: 
4b69				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4b69 4d				db WORD_SYS_CORE+57             
4b6a a5 4b			dw .ENDSTR            
4b6c 04				db 3 + 1 
4b6d .. 00			db "CHR",0              
4b71				endm 
# End of macro CWHEAD
4b71			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4b71					if DEBUG_FORTH_WORDS_KEY 
4b71						DMARK "CHR" 
4b71 f5				push af  
4b72 3a 86 4b			ld a, (.dmark)  
4b75 32 6b fe			ld (debug_mark),a  
4b78 3a 87 4b			ld a, (.dmark+1)  
4b7b 32 6c fe			ld (debug_mark+1),a  
4b7e 3a 88 4b			ld a, (.dmark+2)  
4b81 32 6d fe			ld (debug_mark+2),a  
4b84 18 03			jr .pastdmark  
4b86 ..			.dmark: db "CHR"  
4b89 f1			.pastdmark: pop af  
4b8a			endm  
# End of macro DMARK
4b8a						CALLMONITOR 
4b8a cd 6f fe			call debug_vector  
4b8d				endm  
# End of macro CALLMONITOR
4b8d					endif 
4b8d					FORTH_DSP_VALUEHL 
4b8d cd b9 22			call macro_dsp_valuehl 
4b90				endm 
# End of macro FORTH_DSP_VALUEHL
4b90			 
4b90					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b90 cd 71 23			call macro_forth_dsp_pop 
4b93				endm 
# End of macro FORTH_DSP_POP
4b93			 
4b93					; save asci byte as a zero term string and push string 
4b93			 
4b93 7d					ld a,l 
4b94 32 c1 f1				ld (scratch), a 
4b97			 
4b97 3e 00				ld a, 0 
4b99 32 c2 f1				ld (scratch+1), a 
4b9c			 
4b9c 21 c1 f1				ld hl, scratch 
4b9f cd 30 21				call forth_push_str 
4ba2			 
4ba2			 
4ba2				       NEXTW 
4ba2 c3 6f 24			jp macro_next 
4ba5				endm 
# End of macro NEXTW
4ba5			 
4ba5			 
4ba5			 
4ba5			 
4ba5			.ENDSTR: 
4ba5			; eof 
4ba5			 
# End of file forth_words_str.asm
4ba5			include "forth_words_key.asm" 
4ba5			 
4ba5			; | ## Keyboard Words 
4ba5			 
4ba5			.KEY: 
4ba5				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4ba5 3e				db WORD_SYS_CORE+42             
4ba6 d5 4b			dw .WAITK            
4ba8 04				db 3 + 1 
4ba9 .. 00			db "KEY",0              
4bad				endm 
# End of macro CWHEAD
4bad			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4bad			 
4bad					if DEBUG_FORTH_WORDS_KEY 
4bad						DMARK "KEY" 
4bad f5				push af  
4bae 3a c2 4b			ld a, (.dmark)  
4bb1 32 6b fe			ld (debug_mark),a  
4bb4 3a c3 4b			ld a, (.dmark+1)  
4bb7 32 6c fe			ld (debug_mark+1),a  
4bba 3a c4 4b			ld a, (.dmark+2)  
4bbd 32 6d fe			ld (debug_mark+2),a  
4bc0 18 03			jr .pastdmark  
4bc2 ..			.dmark: db "KEY"  
4bc5 f1			.pastdmark: pop af  
4bc6			endm  
# End of macro DMARK
4bc6						CALLMONITOR 
4bc6 cd 6f fe			call debug_vector  
4bc9				endm  
# End of macro CALLMONITOR
4bc9					endif 
4bc9			; TODO currently waits 
4bc9 cd a1 78				call cin 
4bcc					;call cin_wait 
4bcc 6f					ld l, a 
4bcd 26 00				ld h, 0 
4bcf cd c2 20				call forth_push_numhl 
4bd2					NEXTW 
4bd2 c3 6f 24			jp macro_next 
4bd5				endm 
# End of macro NEXTW
4bd5			.WAITK: 
4bd5				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4bd5 3f				db WORD_SYS_CORE+43             
4bd6 07 4c			dw .ACCEPT            
4bd8 06				db 5 + 1 
4bd9 .. 00			db "WAITK",0              
4bdf				endm 
# End of macro CWHEAD
4bdf			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4bdf					if DEBUG_FORTH_WORDS_KEY 
4bdf						DMARK "WAI" 
4bdf f5				push af  
4be0 3a f4 4b			ld a, (.dmark)  
4be3 32 6b fe			ld (debug_mark),a  
4be6 3a f5 4b			ld a, (.dmark+1)  
4be9 32 6c fe			ld (debug_mark+1),a  
4bec 3a f6 4b			ld a, (.dmark+2)  
4bef 32 6d fe			ld (debug_mark+2),a  
4bf2 18 03			jr .pastdmark  
4bf4 ..			.dmark: db "WAI"  
4bf7 f1			.pastdmark: pop af  
4bf8			endm  
# End of macro DMARK
4bf8						CALLMONITOR 
4bf8 cd 6f fe			call debug_vector  
4bfb				endm  
# End of macro CALLMONITOR
4bfb					endif 
4bfb cd 90 78				call cin_wait 
4bfe 6f					ld l, a 
4bff 26 00				ld h, 0 
4c01 cd c2 20				call forth_push_numhl 
4c04					NEXTW 
4c04 c3 6f 24			jp macro_next 
4c07				endm 
# End of macro NEXTW
4c07			.ACCEPT: 
4c07				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4c07 40				db WORD_SYS_CORE+44             
4c08 65 4c			dw .EDIT            
4c0a 07				db 6 + 1 
4c0b .. 00			db "ACCEPT",0              
4c12				endm 
# End of macro CWHEAD
4c12			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4c12					; TODO crashes on push 
4c12					if DEBUG_FORTH_WORDS_KEY 
4c12						DMARK "ACC" 
4c12 f5				push af  
4c13 3a 27 4c			ld a, (.dmark)  
4c16 32 6b fe			ld (debug_mark),a  
4c19 3a 28 4c			ld a, (.dmark+1)  
4c1c 32 6c fe			ld (debug_mark+1),a  
4c1f 3a 29 4c			ld a, (.dmark+2)  
4c22 32 6d fe			ld (debug_mark+2),a  
4c25 18 03			jr .pastdmark  
4c27 ..			.dmark: db "ACC"  
4c2a f1			.pastdmark: pop af  
4c2b			endm  
# End of macro DMARK
4c2b						CALLMONITOR 
4c2b cd 6f fe			call debug_vector  
4c2e				endm  
# End of macro CALLMONITOR
4c2e					endif 
4c2e 21 bf f3				ld hl, os_input 
4c31 3e 00				ld a, 0 
4c33 77					ld (hl),a 
4c34 3a 5e fa				ld a,(f_cursor_ptr) 
4c37 16 64				ld d, 100 
4c39 0e 00				ld c, 0 
4c3b 1e 28				ld e, 40 
4c3d cd b3 0f				call input_str 
4c40					; TODO perhaps do a type check and wrap in quotes if not a number 
4c40 21 bf f3				ld hl, os_input 
4c43					if DEBUG_FORTH_WORDS 
4c43						DMARK "AC1" 
4c43 f5				push af  
4c44 3a 58 4c			ld a, (.dmark)  
4c47 32 6b fe			ld (debug_mark),a  
4c4a 3a 59 4c			ld a, (.dmark+1)  
4c4d 32 6c fe			ld (debug_mark+1),a  
4c50 3a 5a 4c			ld a, (.dmark+2)  
4c53 32 6d fe			ld (debug_mark+2),a  
4c56 18 03			jr .pastdmark  
4c58 ..			.dmark: db "AC1"  
4c5b f1			.pastdmark: pop af  
4c5c			endm  
# End of macro DMARK
4c5c						CALLMONITOR 
4c5c cd 6f fe			call debug_vector  
4c5f				endm  
# End of macro CALLMONITOR
4c5f					endif 
4c5f cd 30 21				call forth_push_str 
4c62					NEXTW 
4c62 c3 6f 24			jp macro_next 
4c65				endm 
# End of macro NEXTW
4c65			 
4c65			.EDIT: 
4c65				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4c65 40				db WORD_SYS_CORE+44             
4c66 07 4d			dw .DEDIT            
4c68 05				db 4 + 1 
4c69 .. 00			db "EDIT",0              
4c6e				endm 
# End of macro CWHEAD
4c6e			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4c6e			 
4c6e					; TODO does not copy from stack 
4c6e					if DEBUG_FORTH_WORDS_KEY 
4c6e						DMARK "EDT" 
4c6e f5				push af  
4c6f 3a 83 4c			ld a, (.dmark)  
4c72 32 6b fe			ld (debug_mark),a  
4c75 3a 84 4c			ld a, (.dmark+1)  
4c78 32 6c fe			ld (debug_mark+1),a  
4c7b 3a 85 4c			ld a, (.dmark+2)  
4c7e 32 6d fe			ld (debug_mark+2),a  
4c81 18 03			jr .pastdmark  
4c83 ..			.dmark: db "EDT"  
4c86 f1			.pastdmark: pop af  
4c87			endm  
# End of macro DMARK
4c87						CALLMONITOR 
4c87 cd 6f fe			call debug_vector  
4c8a				endm  
# End of macro CALLMONITOR
4c8a					endif 
4c8a			 
4c8a					;FORTH_DSP 
4c8a					FORTH_DSP_VALUEHL 
4c8a cd b9 22			call macro_dsp_valuehl 
4c8d				endm 
# End of macro FORTH_DSP_VALUEHL
4c8d			;		inc hl    ; TODO do type check 
4c8d			 
4c8d			;		call get_word_hl 
4c8d e5					push hl 
4c8e					if DEBUG_FORTH_WORDS 
4c8e						DMARK "EDp" 
4c8e f5				push af  
4c8f 3a a3 4c			ld a, (.dmark)  
4c92 32 6b fe			ld (debug_mark),a  
4c95 3a a4 4c			ld a, (.dmark+1)  
4c98 32 6c fe			ld (debug_mark+1),a  
4c9b 3a a5 4c			ld a, (.dmark+2)  
4c9e 32 6d fe			ld (debug_mark+2),a  
4ca1 18 03			jr .pastdmark  
4ca3 ..			.dmark: db "EDp"  
4ca6 f1			.pastdmark: pop af  
4ca7			endm  
# End of macro DMARK
4ca7						CALLMONITOR 
4ca7 cd 6f fe			call debug_vector  
4caa				endm  
# End of macro CALLMONITOR
4caa					endif 
4caa				;	ld a, 0 
4caa cd e4 13				call strlenz 
4cad 23					inc hl 
4cae			 
4cae 06 00				ld b, 0 
4cb0 4d					ld c, l 
4cb1			 
4cb1 e1					pop hl 
4cb2 11 bf f3				ld de, os_input 
4cb5					if DEBUG_FORTH_WORDS_KEY 
4cb5						DMARK "EDc" 
4cb5 f5				push af  
4cb6 3a ca 4c			ld a, (.dmark)  
4cb9 32 6b fe			ld (debug_mark),a  
4cbc 3a cb 4c			ld a, (.dmark+1)  
4cbf 32 6c fe			ld (debug_mark+1),a  
4cc2 3a cc 4c			ld a, (.dmark+2)  
4cc5 32 6d fe			ld (debug_mark+2),a  
4cc8 18 03			jr .pastdmark  
4cca ..			.dmark: db "EDc"  
4ccd f1			.pastdmark: pop af  
4cce			endm  
# End of macro DMARK
4cce						CALLMONITOR 
4cce cd 6f fe			call debug_vector  
4cd1				endm  
# End of macro CALLMONITOR
4cd1					endif 
4cd1 ed b0				ldir 
4cd3			 
4cd3			 
4cd3 21 bf f3				ld hl, os_input 
4cd6					;ld a, 0 
4cd6					;ld (hl),a 
4cd6 3a 5e fa				ld a,(f_cursor_ptr) 
4cd9 16 64				ld d, 100 
4cdb 0e 00				ld c, 0 
4cdd 1e 28				ld e, 40 
4cdf cd b3 0f				call input_str 
4ce2					; TODO perhaps do a type check and wrap in quotes if not a number 
4ce2 21 bf f3				ld hl, os_input 
4ce5					if DEBUG_FORTH_WORDS 
4ce5						DMARK "ED1" 
4ce5 f5				push af  
4ce6 3a fa 4c			ld a, (.dmark)  
4ce9 32 6b fe			ld (debug_mark),a  
4cec 3a fb 4c			ld a, (.dmark+1)  
4cef 32 6c fe			ld (debug_mark+1),a  
4cf2 3a fc 4c			ld a, (.dmark+2)  
4cf5 32 6d fe			ld (debug_mark+2),a  
4cf8 18 03			jr .pastdmark  
4cfa ..			.dmark: db "ED1"  
4cfd f1			.pastdmark: pop af  
4cfe			endm  
# End of macro DMARK
4cfe						CALLMONITOR 
4cfe cd 6f fe			call debug_vector  
4d01				endm  
# End of macro CALLMONITOR
4d01					endif 
4d01 cd 30 21				call forth_push_str 
4d04					NEXTW 
4d04 c3 6f 24			jp macro_next 
4d07				endm 
# End of macro NEXTW
4d07			 
4d07			.DEDIT: 
4d07				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4d07 40				db WORD_SYS_CORE+44             
4d08 69 4d			dw .ENDKEY            
4d0a 06				db 5 + 1 
4d0b .. 00			db "DEDIT",0              
4d11				endm 
# End of macro CWHEAD
4d11			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4d11			 
4d11					; TODO does not copy from stack 
4d11					if DEBUG_FORTH_WORDS_KEY 
4d11						DMARK "DED" 
4d11 f5				push af  
4d12 3a 26 4d			ld a, (.dmark)  
4d15 32 6b fe			ld (debug_mark),a  
4d18 3a 27 4d			ld a, (.dmark+1)  
4d1b 32 6c fe			ld (debug_mark+1),a  
4d1e 3a 28 4d			ld a, (.dmark+2)  
4d21 32 6d fe			ld (debug_mark+2),a  
4d24 18 03			jr .pastdmark  
4d26 ..			.dmark: db "DED"  
4d29 f1			.pastdmark: pop af  
4d2a			endm  
# End of macro DMARK
4d2a						CALLMONITOR 
4d2a cd 6f fe			call debug_vector  
4d2d				endm  
# End of macro CALLMONITOR
4d2d					endif 
4d2d			 
4d2d					;FORTH_DSP 
4d2d					FORTH_DSP_VALUEHL 
4d2d cd b9 22			call macro_dsp_valuehl 
4d30				endm 
# End of macro FORTH_DSP_VALUEHL
4d30			;		inc hl    ; TODO do type check 
4d30			 
4d30			;		call get_word_hl 
4d30 e5					push hl 
4d31 e5					push hl 
4d32					FORTH_DSP_POP 
4d32 cd 71 23			call macro_forth_dsp_pop 
4d35				endm 
# End of macro FORTH_DSP_POP
4d35 e1					pop hl 
4d36					if DEBUG_FORTH_WORDS 
4d36						DMARK "EDp" 
4d36 f5				push af  
4d37 3a 4b 4d			ld a, (.dmark)  
4d3a 32 6b fe			ld (debug_mark),a  
4d3d 3a 4c 4d			ld a, (.dmark+1)  
4d40 32 6c fe			ld (debug_mark+1),a  
4d43 3a 4d 4d			ld a, (.dmark+2)  
4d46 32 6d fe			ld (debug_mark+2),a  
4d49 18 03			jr .pastdmark  
4d4b ..			.dmark: db "EDp"  
4d4e f1			.pastdmark: pop af  
4d4f			endm  
# End of macro DMARK
4d4f						CALLMONITOR 
4d4f cd 6f fe			call debug_vector  
4d52				endm  
# End of macro CALLMONITOR
4d52					endif 
4d52				;	ld a, 0 
4d52 cd e4 13				call strlenz 
4d55 23					inc hl 
4d56			 
4d56 06 00				ld b, 0 
4d58 4d					ld c, l 
4d59			 
4d59 e1					pop hl 
4d5a			 
4d5a					;ld a, 0 
4d5a					;ld (hl),a 
4d5a 3a 5e fa				ld a,(f_cursor_ptr) 
4d5d 16 64				ld d, 100 
4d5f 0e 00				ld c, 0 
4d61 1e 28				ld e, 40 
4d63 cd b3 0f				call input_str 
4d66					; TODO perhaps do a type check and wrap in quotes if not a number 
4d66					NEXTW 
4d66 c3 6f 24			jp macro_next 
4d69				endm 
# End of macro NEXTW
4d69			 
4d69			 
4d69			.ENDKEY: 
4d69			; eof 
4d69			 
# End of file forth_words_key.asm
4d69			include "forth_words_const.asm" 
4d69			 
4d69			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4d69			 
4d69			 
4d69			.SPITIME: 
4d69				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4d69 77				db WORD_SYS_CORE+99             
4d6a 7e 4d			dw .VA            
4d6c 08				db 7 + 1 
4d6d .. 00			db "SPITIME",0              
4d75				endm 
# End of macro CWHEAD
4d75			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4d75			; 
4d75			; | If using BANK devices then leave as is. 
4d75			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4d75			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4d75			 
4d75 21 64 fa				ld hl, spi_clktime  
4d78 cd c2 20				call forth_push_numhl 
4d7b			 
4d7b					NEXTW 
4d7b c3 6f 24			jp macro_next 
4d7e				endm 
# End of macro NEXTW
4d7e			 
4d7e			 
4d7e			.VA: 
4d7e				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4d7e 77				db WORD_SYS_CORE+99             
4d7f 8e 4d			dw .SYMBOL            
4d81 03				db 2 + 1 
4d82 .. 00			db "VA",0              
4d85				endm 
# End of macro CWHEAD
4d85			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4d85 21 28 fa				ld hl, cli_var_array 
4d88 cd c2 20				call forth_push_numhl 
4d8b			 
4d8b					NEXTW 
4d8b c3 6f 24			jp macro_next 
4d8e				endm 
# End of macro NEXTW
4d8e			 
4d8e			.SYMBOL: 
4d8e				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4d8e 77				db WORD_SYS_CORE+99             
4d8f c6 4e			dw .ENDCONST            
4d91 07				db 6 + 1 
4d92 .. 00			db "SYMBOL",0              
4d99				endm 
# End of macro CWHEAD
4d99			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4d99			; | 
4d99			; | The value is the number reference and the final address is pushed to stack 
4d99			 
4d99					if DEBUG_FORTH_WORDS_KEY 
4d99						DMARK "SYM" 
4d99 f5				push af  
4d9a 3a ae 4d			ld a, (.dmark)  
4d9d 32 6b fe			ld (debug_mark),a  
4da0 3a af 4d			ld a, (.dmark+1)  
4da3 32 6c fe			ld (debug_mark+1),a  
4da6 3a b0 4d			ld a, (.dmark+2)  
4da9 32 6d fe			ld (debug_mark+2),a  
4dac 18 03			jr .pastdmark  
4dae ..			.dmark: db "SYM"  
4db1 f1			.pastdmark: pop af  
4db2			endm  
# End of macro DMARK
4db2						CALLMONITOR 
4db2 cd 6f fe			call debug_vector  
4db5				endm  
# End of macro CALLMONITOR
4db5					endif 
4db5			 
4db5					FORTH_DSP_VALUEHL 
4db5 cd b9 22			call macro_dsp_valuehl 
4db8				endm 
# End of macro FORTH_DSP_VALUEHL
4db8			 
4db8 7d					ld a, l     
4db9			 
4db9			 
4db9					if DEBUG_FORTH_WORDS 
4db9						DMARK "SY1" 
4db9 f5				push af  
4dba 3a ce 4d			ld a, (.dmark)  
4dbd 32 6b fe			ld (debug_mark),a  
4dc0 3a cf 4d			ld a, (.dmark+1)  
4dc3 32 6c fe			ld (debug_mark+1),a  
4dc6 3a d0 4d			ld a, (.dmark+2)  
4dc9 32 6d fe			ld (debug_mark+2),a  
4dcc 18 03			jr .pastdmark  
4dce ..			.dmark: db "SY1"  
4dd1 f1			.pastdmark: pop af  
4dd2			endm  
# End of macro DMARK
4dd2						CALLMONITOR 
4dd2 cd 6f fe			call debug_vector  
4dd5				endm  
# End of macro CALLMONITOR
4dd5					endif 
4dd5					 
4dd5 f5					push af	 
4dd6					FORTH_DSP_POP 
4dd6 cd 71 23			call macro_forth_dsp_pop 
4dd9				endm 
# End of macro FORTH_DSP_POP
4dd9 f1					pop af 
4dda			 
4dda cb 27				sla a  
4ddc				 
4ddc					 
4ddc					if DEBUG_FORTH_WORDS 
4ddc						DMARK "SY" 
4ddc f5				push af  
4ddd 3a f1 4d			ld a, (.dmark)  
4de0 32 6b fe			ld (debug_mark),a  
4de3 3a f2 4d			ld a, (.dmark+1)  
4de6 32 6c fe			ld (debug_mark+1),a  
4de9 3a f3 4d			ld a, (.dmark+2)  
4dec 32 6d fe			ld (debug_mark+2),a  
4def 18 02			jr .pastdmark  
4df1 ..			.dmark: db "SY"  
4df3 f1			.pastdmark: pop af  
4df4			endm  
# End of macro DMARK
4df4						CALLMONITOR 
4df4 cd 6f fe			call debug_vector  
4df7				endm  
# End of macro CALLMONITOR
4df7					endif 
4df7			 
4df7 21 06 4e				ld hl, sym_table 
4dfa cd 86 0f				call addatohl 
4dfd cd f1 23				call loadwordinhl 
4e00 cd c2 20				call forth_push_numhl 
4e03			 
4e03			 
4e03				       NEXTW 
4e03 c3 6f 24			jp macro_next 
4e06				endm 
# End of macro NEXTW
4e06			 
4e06			sym_table: 
4e06			 
4e06			; 0 
4e06 3c fa		dw cli_autodisplay 
4e08 4a fa		dw cli_buffer 
4e0a ee f9		dw cli_data_sp 
4e0c 28 f7		dw cli_data_stack 
4e0e 44 fa		dw cli_execword 
4e10 f0 f9		dw cli_loop_sp 
4e12 2a f9		dw cli_loop_stack 
4e14 3d fa		dw cli_mvdot 
4e16 42 fa		dw cli_nextword 
4e18 3e fa		dw cli_origptr 
4e1a 48 fa		dw cli_origtoken 
4e1c			; 11 
4e1c 40 fa		dw cli_ptr 
4e1e f2 f9		dw cli_ret_sp 
4e20 ac f9		dw cli_ret_stack 
4e22 46 fa		dw cli_token 
4e24 28 fa		dw cli_var_array 
4e26 c5 fb		dw cursor_col 
4e28 c3 fb		dw cursor_ptr 
4e2a c4 fb		dw cursor_row 
4e2c c1 fb		dw cursor_shape 
4e2e 6b fe		dw debug_mark 
4e30			; 21 
4e30 b1 fd		dw display_fb0 
4e32 10 fd		dw display_fb1 
4e34 ce fb		dw display_fb2 
4e36 6f fc		dw display_fb3 
4e38 cc fb		dw display_fb_active 
4e3a c0 f2		dw execscratch 
4e3c 5e fa		dw f_cursor_ptr 
4e3e 72 fe		dw hardware_word 
4e40 62 fe		dw input_at_cursor 
4e42 64 fe		dw input_at_pos 
4e44			; 31 
4e44 60 fe		dw input_cur_flash 
4e46 5f fe		dw input_cur_onoff 
4e48 55 fe		dw input_cursor 
4e4a 65 fe		dw input_display_size 
4e4c 5a fe		dw input_len 
4e4e 69 fe		dw input_ptr 
4e50 66 fe		dw input_size 
4e52 67 fe		dw input_start 
4e54 b3 0f		dw input_str 
4e56 63 fe		dw input_under_cursor 
4e58			; 41 
4e58 54 fe		dw key_actual_pressed 
4e5a 82 fe		dw key_fa 
4e5c 7e fe		dw key_face_held 
4e5e 81 fe		dw key_fb 
4e60 80 fe		dw key_fc 
4e62 7f fe		dw key_fd 
4e64 88 fe		dw key_held 
4e66 87 fe		dw key_held_prev 
4e68 c1 77		dw key_init 
4e6a 83 fe		dw key_repeat_ct 
4e6c			; 51 
4e6c 05 00		dw key_rows 
4e6e 52 fe		dw key_shift 
4e70 53 fe		dw key_symbol 
4e72 89 fe		dw keyscan_scancol 
4e74 93 fe		dw keyscan_table 
4e76 f2 fe		dw keyscan_table_row1 
4e78 e7 fe		dw keyscan_table_row2 
4e7a dc fe		dw keyscan_table_row3 
4e7c d1 fe		dw keyscan_table_row4 
4e7e c6 fe		dw keyscan_table_row5 
4e80			; 61 
4e80 e8 f4		dw os_cli_cmd 
4e82 e4 f4		dw os_cur_ptr 
4e84 e6 f4		dw os_current_i 
4e86 bf f3		dw os_input 
4e88 e7 f5		dw os_last_cmd 
4e8a be f4		dw os_last_new_uword 
4e8c			;dw os_view_disable 
4e8c 6f fe		dw debug_vector 
4e8e af f1		dw os_view_hl 
4e90 c6 f4		dw os_word_scratch 
4e92 c3 00		dw portbctl 
4e94			; 71 
4e94 c1 00		dw portbdata 
4e96 63 fa		dw spi_cartdev 
4e98 62 fa		dw spi_cartdev2 
4e9a 64 fa		dw spi_clktime 
4e9c 60 fa		dw spi_device 
4e9e 5f fa		dw spi_device_id 
4ea0 61 fa		dw spi_portbyte 
4ea2 a7 fb		dw stackstore 
4ea4			if STORAGE_SE 
4ea4 82 00		dw storage_actl 
4ea6 80 00		dw storage_adata 
4ea8			else 
4ea8			dw 0 
4ea8			dw 0 
4ea8			endif 
4ea8			; 81 
4ea8 0c 0b		dw storage_append 
4eaa			if STORAGE_SE 
4eaa 83 00		dw storage_bctl 
4eac			else 
4eac			dw 0 
4eac			endif 
4eac 93 fb		dw store_bank_active 
4eae 67 fa		dw store_filecache 
4eb0 75 fa		dw store_longread 
4eb2 6b fa		dw store_openaddr 
4eb4 6a fa		dw store_openext 
4eb6 69 fa		dw store_openmaxext 
4eb8 7a fa		dw store_page 
4eba 76 fa		dw store_readbuf 
4ebc			; 91 
4ebc 6d fa		dw store_readcont 
4ebe 78 fa		dw store_readptr 
4ec0 6d fa		dw store_tmpext 
4ec2 6e fa		dw store_tmpid 
4ec4 65 fa		dw store_tmppageid 
4ec6			 
4ec6			.ENDCONST: 
4ec6			 
4ec6			; eof 
4ec6			 
4ec6			 
# End of file forth_words_const.asm
4ec6			 
4ec6			if STORAGE_SE 
4ec6			   	include "forth_words_storage.asm" 
4ec6			 
4ec6			; | ## Fixed Storage Words 
4ec6			 
4ec6			.RENAME: 
4ec6			  
4ec6				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4ec6 3a				db WORD_SYS_CORE+38             
4ec7 bc 4f			dw .RECORD            
4ec9 07				db 6 + 1 
4eca .. 00			db "RENAME",0              
4ed1				endm 
# End of macro CWHEAD
4ed1			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4ed1			; | | Compatible with PicoSPINet  
4ed1					if DEBUG_FORTH_WORDS_KEY 
4ed1						DMARK "REN" 
4ed1 f5				push af  
4ed2 3a e6 4e			ld a, (.dmark)  
4ed5 32 6b fe			ld (debug_mark),a  
4ed8 3a e7 4e			ld a, (.dmark+1)  
4edb 32 6c fe			ld (debug_mark+1),a  
4ede 3a e8 4e			ld a, (.dmark+2)  
4ee1 32 6d fe			ld (debug_mark+2),a  
4ee4 18 03			jr .pastdmark  
4ee6 ..			.dmark: db "REN"  
4ee9 f1			.pastdmark: pop af  
4eea			endm  
# End of macro DMARK
4eea						CALLMONITOR 
4eea cd 6f fe			call debug_vector  
4eed				endm  
# End of macro CALLMONITOR
4eed					endif 
4eed			 
4eed			 
4eed					; preserve some internal vars used by other file handing routines 
4eed			 
4eed 2a 6b fa				ld hl, (store_openaddr) 
4ef0 e5					push hl 
4ef1 3a 6d fa				ld a, (store_readcont) 
4ef4 f5					push af 
4ef5			 
4ef5					FORTH_DSP_VALUEHL 
4ef5 cd b9 22			call macro_dsp_valuehl 
4ef8				endm 
# End of macro FORTH_DSP_VALUEHL
4ef8			 
4ef8					; move ext and id around for the file header 
4ef8			 
4ef8 65					ld h, l 
4ef9 2e 00				ld l, 0 
4efb			 
4efb e5					push hl    ; id 
4efc			 
4efc					FORTH_DSP_POP 
4efc cd 71 23			call macro_forth_dsp_pop 
4eff				endm 
# End of macro FORTH_DSP_POP
4eff			 
4eff					; Locate the file header 
4eff			 
4eff e1					pop hl 
4f00 e5					push hl 
4f01 11 7a fa				ld de, store_page      ; get block zero of file 
4f04					if DEBUG_FORTH_WORDS 
4f04						DMARK "REr" 
4f04 f5				push af  
4f05 3a 19 4f			ld a, (.dmark)  
4f08 32 6b fe			ld (debug_mark),a  
4f0b 3a 1a 4f			ld a, (.dmark+1)  
4f0e 32 6c fe			ld (debug_mark+1),a  
4f11 3a 1b 4f			ld a, (.dmark+2)  
4f14 32 6d fe			ld (debug_mark+2),a  
4f17 18 03			jr .pastdmark  
4f19 ..			.dmark: db "REr"  
4f1c f1			.pastdmark: pop af  
4f1d			endm  
# End of macro DMARK
4f1d						CALLMONITOR 
4f1d cd 6f fe			call debug_vector  
4f20				endm  
# End of macro CALLMONITOR
4f20					endif 
4f20 cd 75 09				call storage_read 
4f23			 
4f23 cd af 0f			call ishlzero 
4f26 20 05			jr nz, .rnfound 
4f28			 
4f28				; file does not exist so indicate with 255 extents in use 
4f28			 
4f28 3e ff			ld a, 255 
4f2a e1				pop hl ; clear dup hl 
4f2b 18 7b			jr .skiprneof 
4f2d			 
4f2d			 
4f2d			.rnfound: 
4f2d					; file found so rename 
4f2d			 
4f2d					FORTH_DSP_VALUEHL 
4f2d cd b9 22			call macro_dsp_valuehl 
4f30				endm 
# End of macro FORTH_DSP_VALUEHL
4f30			 
4f30 e5				push hl 
4f31 3e 00			ld a, 0 
4f33 cd ef 13			call strlent 
4f36 23				inc hl   ; cover zero term 
4f37 06 00			ld b,0 
4f39 4d				ld c,l 
4f3a e1				pop hl 
4f3b 11 7d fa				ld de, store_page + 3 
4f3e ed b0				ldir 
4f40			 
4f40 11 7a fa				ld de, store_page 
4f43					if DEBUG_FORTH_WORDS 
4f43						DMARK "RER" 
4f43 f5				push af  
4f44 3a 58 4f			ld a, (.dmark)  
4f47 32 6b fe			ld (debug_mark),a  
4f4a 3a 59 4f			ld a, (.dmark+1)  
4f4d 32 6c fe			ld (debug_mark+1),a  
4f50 3a 5a 4f			ld a, (.dmark+2)  
4f53 32 6d fe			ld (debug_mark+2),a  
4f56 18 03			jr .pastdmark  
4f58 ..			.dmark: db "RER"  
4f5b f1			.pastdmark: pop af  
4f5c			endm  
# End of macro DMARK
4f5c						CALLMONITOR 
4f5c cd 6f fe			call debug_vector  
4f5f				endm  
# End of macro CALLMONITOR
4f5f					endif 
4f5f			 
4f5f e1					pop hl    ; get orig file id and mangle it for find id 
4f60 55					ld d, l 
4f61 5c					ld e, h 
4f62			 
4f62 21 00 00				ld hl, 0 
4f65					if DEBUG_FORTH_WORDS 
4f65						DMARK "REf" 
4f65 f5				push af  
4f66 3a 7a 4f			ld a, (.dmark)  
4f69 32 6b fe			ld (debug_mark),a  
4f6c 3a 7b 4f			ld a, (.dmark+1)  
4f6f 32 6c fe			ld (debug_mark+1),a  
4f72 3a 7c 4f			ld a, (.dmark+2)  
4f75 32 6d fe			ld (debug_mark+2),a  
4f78 18 03			jr .pastdmark  
4f7a ..			.dmark: db "REf"  
4f7d f1			.pastdmark: pop af  
4f7e			endm  
# End of macro DMARK
4f7e						CALLMONITOR 
4f7e cd 6f fe			call debug_vector  
4f81				endm  
# End of macro CALLMONITOR
4f81					endif 
4f81 cd 4f 07				call storage_findnextid 
4f84 11 7a fa				ld de, store_page 
4f87					if DEBUG_FORTH_WORDS 
4f87						DMARK "REw" 
4f87 f5				push af  
4f88 3a 9c 4f			ld a, (.dmark)  
4f8b 32 6b fe			ld (debug_mark),a  
4f8e 3a 9d 4f			ld a, (.dmark+1)  
4f91 32 6c fe			ld (debug_mark+1),a  
4f94 3a 9e 4f			ld a, (.dmark+2)  
4f97 32 6d fe			ld (debug_mark+2),a  
4f9a 18 03			jr .pastdmark  
4f9c ..			.dmark: db "REw"  
4f9f f1			.pastdmark: pop af  
4fa0			endm  
# End of macro DMARK
4fa0						CALLMONITOR 
4fa0 cd 6f fe			call debug_vector  
4fa3				endm  
# End of macro CALLMONITOR
4fa3					endif 
4fa3 cd 81 04				call storage_write_block 
4fa6			 
4fa6 3e 00				ld a, 0 
4fa8			.skiprneof: 
4fa8					; drop file name 
4fa8					FORTH_DSP_POP 
4fa8 cd 71 23			call macro_forth_dsp_pop 
4fab				endm 
# End of macro FORTH_DSP_POP
4fab			 
4fab 6f					ld l, a 
4fac 26 00				ld h, 0 
4fae cd c2 20				call forth_push_numhl 
4fb1			 
4fb1			 
4fb1 f1					pop af 
4fb2 32 6d fa				ld (store_readcont),a 
4fb5 e1					pop hl 
4fb6 22 6b fa				ld (store_openaddr), hl 
4fb9						 
4fb9				NEXTW 
4fb9 c3 6f 24			jp macro_next 
4fbc				endm 
# End of macro NEXTW
4fbc			.RECORD: 
4fbc			  
4fbc				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4fbc 3a				db WORD_SYS_CORE+38             
4fbd 60 50			dw .BREAD            
4fbf 07				db 6 + 1 
4fc0 .. 00			db "RECORD",0              
4fc7				endm 
# End of macro CWHEAD
4fc7			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4fc7			; | | Compatible with PicoSPINet  
4fc7			 
4fc7					if DEBUG_FORTH_WORDS_KEY 
4fc7						DMARK "REC" 
4fc7 f5				push af  
4fc8 3a dc 4f			ld a, (.dmark)  
4fcb 32 6b fe			ld (debug_mark),a  
4fce 3a dd 4f			ld a, (.dmark+1)  
4fd1 32 6c fe			ld (debug_mark+1),a  
4fd4 3a de 4f			ld a, (.dmark+2)  
4fd7 32 6d fe			ld (debug_mark+2),a  
4fda 18 03			jr .pastdmark  
4fdc ..			.dmark: db "REC"  
4fdf f1			.pastdmark: pop af  
4fe0			endm  
# End of macro DMARK
4fe0						CALLMONITOR 
4fe0 cd 6f fe			call debug_vector  
4fe3				endm  
# End of macro CALLMONITOR
4fe3					endif 
4fe3			 
4fe3					FORTH_DSP_VALUEHL 
4fe3 cd b9 22			call macro_dsp_valuehl 
4fe6				endm 
# End of macro FORTH_DSP_VALUEHL
4fe6			 
4fe6 e5					push hl    ; id 
4fe7			 
4fe7					FORTH_DSP_POP 
4fe7 cd 71 23			call macro_forth_dsp_pop 
4fea				endm 
# End of macro FORTH_DSP_POP
4fea			 
4fea					FORTH_DSP_VALUEHL 
4fea cd b9 22			call macro_dsp_valuehl 
4fed				endm 
# End of macro FORTH_DSP_VALUEHL
4fed			 
4fed					FORTH_DSP_POP 
4fed cd 71 23			call macro_forth_dsp_pop 
4ff0				endm 
# End of macro FORTH_DSP_POP
4ff0			 
4ff0 d1					pop de     ; get file id 
4ff1			 
4ff1					; e = file id 
4ff1					; l = file extent 
4ff1			 
4ff1			 
4ff1					; construct request to access file extent 
4ff1			 
4ff1			;		ld a, e 
4ff1 63					ld h, e 
4ff2					 
4ff2					 
4ff2					 
4ff2			 
4ff2					; e has id 
4ff2			 
4ff2 11 7a fa			ld de, store_page 
4ff5					if DEBUG_FORTH_WORDS 
4ff5						DMARK "REr" 
4ff5 f5				push af  
4ff6 3a 0a 50			ld a, (.dmark)  
4ff9 32 6b fe			ld (debug_mark),a  
4ffc 3a 0b 50			ld a, (.dmark+1)  
4fff 32 6c fe			ld (debug_mark+1),a  
5002 3a 0c 50			ld a, (.dmark+2)  
5005 32 6d fe			ld (debug_mark+2),a  
5008 18 03			jr .pastdmark  
500a ..			.dmark: db "REr"  
500d f1			.pastdmark: pop af  
500e			endm  
# End of macro DMARK
500e						CALLMONITOR 
500e cd 6f fe			call debug_vector  
5011				endm  
# End of macro CALLMONITOR
5011					endif 
5011 cd 75 09				call storage_read 
5014 cd af 0f			call ishlzero 
5017 28 22			jr z, .recnotfound 
5019			 
5019			 
5019					if DEBUG_FORTH_WORDS 
5019						DMARK "REe" 
5019 f5				push af  
501a 3a 2e 50			ld a, (.dmark)  
501d 32 6b fe			ld (debug_mark),a  
5020 3a 2f 50			ld a, (.dmark+1)  
5023 32 6c fe			ld (debug_mark+1),a  
5026 3a 30 50			ld a, (.dmark+2)  
5029 32 6d fe			ld (debug_mark+2),a  
502c 18 03			jr .pastdmark  
502e ..			.dmark: db "REe"  
5031 f1			.pastdmark: pop af  
5032			endm  
# End of macro DMARK
5032						CALLMONITOR 
5032 cd 6f fe			call debug_vector  
5035				endm  
# End of macro CALLMONITOR
5035					endif 
5035 cd 30 21			call forth_push_str 
5038			 
5038					NEXTW 
5038 c3 6f 24			jp macro_next 
503b				endm 
# End of macro NEXTW
503b			 
503b			.recnotfound: 
503b					if DEBUG_FORTH_WORDS 
503b						DMARK "REf" 
503b f5				push af  
503c 3a 50 50			ld a, (.dmark)  
503f 32 6b fe			ld (debug_mark),a  
5042 3a 51 50			ld a, (.dmark+1)  
5045 32 6c fe			ld (debug_mark+1),a  
5048 3a 52 50			ld a, (.dmark+2)  
504b 32 6d fe			ld (debug_mark+2),a  
504e 18 03			jr .pastdmark  
5050 ..			.dmark: db "REf"  
5053 f1			.pastdmark: pop af  
5054			endm  
# End of macro DMARK
5054						CALLMONITOR 
5054 cd 6f fe			call debug_vector  
5057				endm  
# End of macro CALLMONITOR
5057					endif 
5057 21 ff 00			ld hl, 255 
505a cd c2 20			call forth_push_numhl 
505d				NEXTW 
505d c3 6f 24			jp macro_next 
5060				endm 
# End of macro NEXTW
5060			 
5060			 
5060			.BREAD: 
5060			  
5060				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
5060 3a				db WORD_SYS_CORE+38             
5061 e3 50			dw .BWRITE            
5063 06				db 5 + 1 
5064 .. 00			db "BREAD",0              
506a				endm 
# End of macro CWHEAD
506a			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
506a			; | | Compatible with PicoSPINet  
506a				 
506a					if DEBUG_FORTH_WORDS_KEY 
506a						DMARK "BRD" 
506a f5				push af  
506b 3a 7f 50			ld a, (.dmark)  
506e 32 6b fe			ld (debug_mark),a  
5071 3a 80 50			ld a, (.dmark+1)  
5074 32 6c fe			ld (debug_mark+1),a  
5077 3a 81 50			ld a, (.dmark+2)  
507a 32 6d fe			ld (debug_mark+2),a  
507d 18 03			jr .pastdmark  
507f ..			.dmark: db "BRD"  
5082 f1			.pastdmark: pop af  
5083			endm  
# End of macro DMARK
5083						CALLMONITOR 
5083 cd 6f fe			call debug_vector  
5086				endm  
# End of macro CALLMONITOR
5086					endif 
5086			 
5086				FORTH_DSP_VALUEHL 
5086 cd b9 22			call macro_dsp_valuehl 
5089				endm 
# End of macro FORTH_DSP_VALUEHL
5089			 
5089				FORTH_DSP_POP 
5089 cd 71 23			call macro_forth_dsp_pop 
508c				endm 
# End of macro FORTH_DSP_POP
508c			 
508c				; calc block address 
508c			 
508c eb				ex de, hl 
508d 3e 40			ld a, STORE_BLOCK_PHY 
508f cd 09 0f			call Mult16 
5092			 
5092			 
5092 11 7a fa			ld de, store_page 
5095			 
5095					if DEBUG_FORTH_WORDS 
5095						DMARK "BR1" 
5095 f5				push af  
5096 3a aa 50			ld a, (.dmark)  
5099 32 6b fe			ld (debug_mark),a  
509c 3a ab 50			ld a, (.dmark+1)  
509f 32 6c fe			ld (debug_mark+1),a  
50a2 3a ac 50			ld a, (.dmark+2)  
50a5 32 6d fe			ld (debug_mark+2),a  
50a8 18 03			jr .pastdmark  
50aa ..			.dmark: db "BR1"  
50ad f1			.pastdmark: pop af  
50ae			endm  
# End of macro DMARK
50ae						CALLMONITOR 
50ae cd 6f fe			call debug_vector  
50b1				endm  
# End of macro CALLMONITOR
50b1					endif 
50b1			 
50b1 cd 1c 04			call storage_read_block 
50b4			 
50b4 cd af 0f			call ishlzero 
50b7 20 05			jr nz, .brfound 
50b9			 
50b9 cd c2 20			call forth_push_numhl 
50bc 18 22			jr .brdone 
50be			 
50be			 
50be			.brfound: 
50be 21 7c fa		        ld hl, store_page+2 
50c1			 
50c1					if DEBUG_FORTH_WORDS 
50c1						DMARK "BR2" 
50c1 f5				push af  
50c2 3a d6 50			ld a, (.dmark)  
50c5 32 6b fe			ld (debug_mark),a  
50c8 3a d7 50			ld a, (.dmark+1)  
50cb 32 6c fe			ld (debug_mark+1),a  
50ce 3a d8 50			ld a, (.dmark+2)  
50d1 32 6d fe			ld (debug_mark+2),a  
50d4 18 03			jr .pastdmark  
50d6 ..			.dmark: db "BR2"  
50d9 f1			.pastdmark: pop af  
50da			endm  
# End of macro DMARK
50da						CALLMONITOR 
50da cd 6f fe			call debug_vector  
50dd				endm  
# End of macro CALLMONITOR
50dd					endif 
50dd			 
50dd cd 30 21			call forth_push_str 
50e0			 
50e0			 
50e0			.brdone: 
50e0			 
50e0					NEXTW 
50e0 c3 6f 24			jp macro_next 
50e3				endm 
# End of macro NEXTW
50e3			.BWRITE: 
50e3				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
50e3 3a				db WORD_SYS_CORE+38             
50e4 78 51			dw .BUPD            
50e6 07				db 6 + 1 
50e7 .. 00			db "BWRITE",0              
50ee				endm 
# End of macro CWHEAD
50ee			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
50ee			; | | Compatible with PicoSPINet  
50ee			 
50ee					if DEBUG_FORTH_WORDS_KEY 
50ee						DMARK "BWR" 
50ee f5				push af  
50ef 3a 03 51			ld a, (.dmark)  
50f2 32 6b fe			ld (debug_mark),a  
50f5 3a 04 51			ld a, (.dmark+1)  
50f8 32 6c fe			ld (debug_mark+1),a  
50fb 3a 05 51			ld a, (.dmark+2)  
50fe 32 6d fe			ld (debug_mark+2),a  
5101 18 03			jr .pastdmark  
5103 ..			.dmark: db "BWR"  
5106 f1			.pastdmark: pop af  
5107			endm  
# End of macro DMARK
5107						CALLMONITOR 
5107 cd 6f fe			call debug_vector  
510a				endm  
# End of macro CALLMONITOR
510a					endif 
510a			 
510a				FORTH_DSP_VALUEHL 
510a cd b9 22			call macro_dsp_valuehl 
510d				endm 
# End of macro FORTH_DSP_VALUEHL
510d			 
510d				; calc block address 
510d			 
510d eb				ex de, hl 
510e 3e 40			ld a, STORE_BLOCK_PHY 
5110 cd 09 0f			call Mult16 
5113			 
5113 e5				push hl         ; address 
5114			 
5114				FORTH_DSP_POP 
5114 cd 71 23			call macro_forth_dsp_pop 
5117				endm 
# End of macro FORTH_DSP_POP
5117			 
5117				FORTH_DSP_VALUEHL 
5117 cd b9 22			call macro_dsp_valuehl 
511a				endm 
# End of macro FORTH_DSP_VALUEHL
511a			 
511a				FORTH_DSP_POP 
511a cd 71 23			call macro_forth_dsp_pop 
511d				endm 
# End of macro FORTH_DSP_POP
511d			 
511d cd 58 0c			call storage_clear_page 
5120			 
5120				; copy string to store page 
5120			 
5120 e5				push hl     ; save string address 
5121			 
5121 3e 00			ld a, 0 
5123 cd ef 13			call strlent 
5126			 
5126 23				inc hl 
5127			 
5127 4d				ld c, l 
5128 06 00			ld b, 0 
512a			 
512a e1				pop hl 
512b 11 7c fa			ld de, store_page + 2 
512e					if DEBUG_FORTH_WORDS 
512e						DMARK "BW1" 
512e f5				push af  
512f 3a 43 51			ld a, (.dmark)  
5132 32 6b fe			ld (debug_mark),a  
5135 3a 44 51			ld a, (.dmark+1)  
5138 32 6c fe			ld (debug_mark+1),a  
513b 3a 45 51			ld a, (.dmark+2)  
513e 32 6d fe			ld (debug_mark+2),a  
5141 18 03			jr .pastdmark  
5143 ..			.dmark: db "BW1"  
5146 f1			.pastdmark: pop af  
5147			endm  
# End of macro DMARK
5147						CALLMONITOR 
5147 cd 6f fe			call debug_vector  
514a				endm  
# End of macro CALLMONITOR
514a					endif 
514a ed b0			ldir 
514c			 
514c			 
514c				; poke the start of the block with flags to prevent high level file ops hitting the block 
514c			 
514c 21 ff ff			ld hl, $ffff 
514f			 
514f 22 7a fa			ld (store_page), hl	 
5152				 
5152 e1				pop hl    ; get address 
5153 11 7a fa			ld de, store_page 
5156			 
5156					if DEBUG_FORTH_WORDS 
5156						DMARK "BW2" 
5156 f5				push af  
5157 3a 6b 51			ld a, (.dmark)  
515a 32 6b fe			ld (debug_mark),a  
515d 3a 6c 51			ld a, (.dmark+1)  
5160 32 6c fe			ld (debug_mark+1),a  
5163 3a 6d 51			ld a, (.dmark+2)  
5166 32 6d fe			ld (debug_mark+2),a  
5169 18 03			jr .pastdmark  
516b ..			.dmark: db "BW2"  
516e f1			.pastdmark: pop af  
516f			endm  
# End of macro DMARK
516f						CALLMONITOR 
516f cd 6f fe			call debug_vector  
5172				endm  
# End of macro CALLMONITOR
5172					endif 
5172			 
5172 cd 81 04			call storage_write_block 
5175			 
5175					NEXTW 
5175 c3 6f 24			jp macro_next 
5178				endm 
# End of macro NEXTW
5178			 
5178			.BUPD: 
5178				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
5178 3a				db WORD_SYS_CORE+38             
5179 ce 51			dw .BYID            
517b 05				db 4 + 1 
517c .. 00			db "BUPD",0              
5181				endm 
# End of macro CWHEAD
5181			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
5181			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
5181			; | | or completely different file system structure. 
5181			; | | Compatible with PicoSPINet  
5181			 
5181					if DEBUG_FORTH_WORDS_KEY 
5181						DMARK "BUD" 
5181 f5				push af  
5182 3a 96 51			ld a, (.dmark)  
5185 32 6b fe			ld (debug_mark),a  
5188 3a 97 51			ld a, (.dmark+1)  
518b 32 6c fe			ld (debug_mark+1),a  
518e 3a 98 51			ld a, (.dmark+2)  
5191 32 6d fe			ld (debug_mark+2),a  
5194 18 03			jr .pastdmark  
5196 ..			.dmark: db "BUD"  
5199 f1			.pastdmark: pop af  
519a			endm  
# End of macro DMARK
519a						CALLMONITOR 
519a cd 6f fe			call debug_vector  
519d				endm  
# End of macro CALLMONITOR
519d					endif 
519d			 
519d				FORTH_DSP_VALUEHL 
519d cd b9 22			call macro_dsp_valuehl 
51a0				endm 
# End of macro FORTH_DSP_VALUEHL
51a0			 
51a0				; calc block address 
51a0			 
51a0 eb				ex de, hl 
51a1 3e 40			ld a, STORE_BLOCK_PHY 
51a3 cd 09 0f			call Mult16 
51a6			 
51a6				FORTH_DSP_POP 
51a6 cd 71 23			call macro_forth_dsp_pop 
51a9				endm 
# End of macro FORTH_DSP_POP
51a9			 
51a9			 
51a9 11 7a fa			ld de, store_page 
51ac			 
51ac					if DEBUG_FORTH_WORDS 
51ac						DMARK "BUe" 
51ac f5				push af  
51ad 3a c1 51			ld a, (.dmark)  
51b0 32 6b fe			ld (debug_mark),a  
51b3 3a c2 51			ld a, (.dmark+1)  
51b6 32 6c fe			ld (debug_mark+1),a  
51b9 3a c3 51			ld a, (.dmark+2)  
51bc 32 6d fe			ld (debug_mark+2),a  
51bf 18 03			jr .pastdmark  
51c1 ..			.dmark: db "BUe"  
51c4 f1			.pastdmark: pop af  
51c5			endm  
# End of macro DMARK
51c5						CALLMONITOR 
51c5 cd 6f fe			call debug_vector  
51c8				endm  
# End of macro CALLMONITOR
51c8					endif 
51c8			 
51c8 cd 81 04			call storage_write_block 
51cb			 
51cb					NEXTW 
51cb c3 6f 24			jp macro_next 
51ce				endm 
# End of macro NEXTW
51ce			 
51ce			.BYID: 
51ce			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
51ce			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
51ce			; 
51ce			;		 
51ce			;		if DEBUG_FORTH_WORDS_KEY 
51ce			;			DMARK "BYID" 
51ce			;			CALLMONITOR 
51ce			;		endif 
51ce			; 
51ce			;		; get direct address 
51ce			; 
51ce			;		FORTH_DSP_VALUEHL 
51ce			; 
51ce			;		FORTH_DSP_POP 
51ce			; 
51ce			;	; calc block address 
51ce			; 
51ce			;	ex de, hl 
51ce			;	ld a, STORE_BLOCK_PHY 
51ce			;	call Mult16 
51ce			;	;	do BREAD with number as param 
51ce			;	; push the file name	 
51ce			;	ld de, store_page 
51ce			;	call storage_read_block 
51ce			 ;       ld hl, store_page+2 
51ce			; 
51ce			; 
51ce			;		NEXTW 
51ce			;.BYNAME: 
51ce				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
51ce 3a				db WORD_SYS_CORE+38             
51cf e7 51			dw .DIR            
51d1 06				db 5 + 1 
51d2 .. 00			db "GETID",0              
51d8				endm 
# End of macro CWHEAD
51d8			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
51d8			; | | Compatible with PicoSPINet  
51d8			 
51d8					; get pointer to file name to seek 
51d8			 
51d8					FORTH_DSP_VALUEHL 
51d8 cd b9 22			call macro_dsp_valuehl 
51db				endm 
# End of macro FORTH_DSP_VALUEHL
51db			 
51db			 
51db cd 43 03				call storage_getid  
51de			 
51de					FORTH_DSP_POP 
51de cd 71 23			call macro_forth_dsp_pop 
51e1				endm 
# End of macro FORTH_DSP_POP
51e1			 
51e1 cd c2 20				call forth_push_numhl 
51e4			 
51e4					NEXTW 
51e4 c3 6f 24			jp macro_next 
51e7				endm 
# End of macro NEXTW
51e7			; 
51e7			.DIR: 
51e7				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
51e7 3a				db WORD_SYS_CORE+38             
51e8 eb 52			dw .SAVE            
51ea 04				db 3 + 1 
51eb .. 00			db "DIR",0              
51ef				endm 
# End of macro CWHEAD
51ef			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
51ef			; | | Compatible with PicoSPINet  
51ef			 
51ef					if DEBUG_FORTH_WORDS_KEY 
51ef						DMARK "DIR" 
51ef f5				push af  
51f0 3a 04 52			ld a, (.dmark)  
51f3 32 6b fe			ld (debug_mark),a  
51f6 3a 05 52			ld a, (.dmark+1)  
51f9 32 6c fe			ld (debug_mark+1),a  
51fc 3a 06 52			ld a, (.dmark+2)  
51ff 32 6d fe			ld (debug_mark+2),a  
5202 18 03			jr .pastdmark  
5204 ..			.dmark: db "DIR"  
5207 f1			.pastdmark: pop af  
5208			endm  
# End of macro DMARK
5208						CALLMONITOR 
5208 cd 6f fe			call debug_vector  
520b				endm  
# End of macro CALLMONITOR
520b					endif 
520b cd cd 04			call storage_get_block_0 
520e			 
520e 21 7a fa			ld hl, store_page     ; get current id count 
5211 46				ld b, (hl) 
5212 0e 00			ld c, 0    ; count of files   
5214					if DEBUG_FORTH_WORDS 
5214						DMARK "DI1" 
5214 f5				push af  
5215 3a 29 52			ld a, (.dmark)  
5218 32 6b fe			ld (debug_mark),a  
521b 3a 2a 52			ld a, (.dmark+1)  
521e 32 6c fe			ld (debug_mark+1),a  
5221 3a 2b 52			ld a, (.dmark+2)  
5224 32 6d fe			ld (debug_mark+2),a  
5227 18 03			jr .pastdmark  
5229 ..			.dmark: db "DI1"  
522c f1			.pastdmark: pop af  
522d			endm  
# End of macro DMARK
522d						CALLMONITOR 
522d cd 6f fe			call debug_vector  
5230				endm  
# End of macro CALLMONITOR
5230					endif 
5230			 
5230				; check for empty drive 
5230			 
5230 3e 00			ld a, 0 
5232 b8				cp b 
5233 ca a1 52			jp z, .dirdone 
5236			 
5236				; for each of the current ids do a search for them and if found push to stack 
5236			 
5236 c5			.diritem:	push bc 
5237 21 40 00				ld hl, STORE_BLOCK_PHY 
523a 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
523c 58					ld e,b 
523d			 
523d			;		if DEBUG_FORTH_WORDS 
523d			;			DMARK "DI2" 
523d			;			CALLMONITOR 
523d			;		endif 
523d			 
523d cd 4f 07				call storage_findnextid 
5240			 
5240			;		if DEBUG_FORTH_WORDS 
5240			;			DMARK "DI3" 
5240			;			CALLMONITOR 
5240			;		endif 
5240			 
5240					; if found hl will be non zero 
5240			 
5240 cd af 0f				call ishlzero 
5243			;		ld a, l 
5243			;		add h 
5243			; 
5243			;		cp 0 
5243 28 59				jr z, .dirnotfound 
5245			 
5245					; increase count 
5245			 
5245 c1					pop bc	 
5246 0c					inc c 
5247 c5					push bc 
5248					 
5248			 
5248					; get file header and push the file name 
5248			 
5248 11 7a fa				ld de, store_page 
524b cd 1c 04				call storage_read_block 
524e			 
524e					; push file id to stack 
524e				 
524e 3a 7a fa				ld a, (store_page) 
5251 26 00				ld h, 0 
5253 6f					ld l, a 
5254 cd c2 20				call forth_push_numhl 
5257			 
5257					; push extent count to stack  
5257				 
5257 3a 7c fa				ld a, (store_page+2) 
525a 26 00				ld h, 0 
525c 6f					ld l, a 
525d cd c2 20				call forth_push_numhl 
5260			 
5260					; push file name 
5260			 
5260 21 7d fa				ld hl, store_page+3 
5263					if DEBUG_FORTH_WORDS 
5263						DMARK "DI5" 
5263 f5				push af  
5264 3a 78 52			ld a, (.dmark)  
5267 32 6b fe			ld (debug_mark),a  
526a 3a 79 52			ld a, (.dmark+1)  
526d 32 6c fe			ld (debug_mark+1),a  
5270 3a 7a 52			ld a, (.dmark+2)  
5273 32 6d fe			ld (debug_mark+2),a  
5276 18 03			jr .pastdmark  
5278 ..			.dmark: db "DI5"  
527b f1			.pastdmark: pop af  
527c			endm  
# End of macro DMARK
527c						CALLMONITOR 
527c cd 6f fe			call debug_vector  
527f				endm  
# End of macro CALLMONITOR
527f					endif 
527f cd 30 21				call forth_push_str 
5282					if DEBUG_FORTH_WORDS 
5282						DMARK "DI6" 
5282 f5				push af  
5283 3a 97 52			ld a, (.dmark)  
5286 32 6b fe			ld (debug_mark),a  
5289 3a 98 52			ld a, (.dmark+1)  
528c 32 6c fe			ld (debug_mark+1),a  
528f 3a 99 52			ld a, (.dmark+2)  
5292 32 6d fe			ld (debug_mark+2),a  
5295 18 03			jr .pastdmark  
5297 ..			.dmark: db "DI6"  
529a f1			.pastdmark: pop af  
529b			endm  
# End of macro DMARK
529b						CALLMONITOR 
529b cd 6f fe			call debug_vector  
529e				endm  
# End of macro CALLMONITOR
529e					endif 
529e			.dirnotfound: 
529e c1					pop bc     
529f 10 95				djnz .diritem 
52a1				 
52a1			.dirdone:	 
52a1					if DEBUG_FORTH_WORDS 
52a1						DMARK "DI7" 
52a1 f5				push af  
52a2 3a b6 52			ld a, (.dmark)  
52a5 32 6b fe			ld (debug_mark),a  
52a8 3a b7 52			ld a, (.dmark+1)  
52ab 32 6c fe			ld (debug_mark+1),a  
52ae 3a b8 52			ld a, (.dmark+2)  
52b1 32 6d fe			ld (debug_mark+2),a  
52b4 18 03			jr .pastdmark  
52b6 ..			.dmark: db "DI7"  
52b9 f1			.pastdmark: pop af  
52ba			endm  
# End of macro DMARK
52ba						CALLMONITOR 
52ba cd 6f fe			call debug_vector  
52bd				endm  
# End of macro CALLMONITOR
52bd					endif 
52bd			 
52bd					; push a count of the dir items found 
52bd			 
52bd 26 00				ld h, 0 
52bf 69					ld l, c 
52c0 cd c2 20				call forth_push_numhl 
52c3			 
52c3					; push the bank label 
52c3			 
52c3 cd cd 04				call storage_get_block_0 
52c6			 
52c6				 
52c6 21 7d fa		 		ld hl, store_page+3 
52c9			 
52c9					if DEBUG_FORTH_WORDS 
52c9						DMARK "DI8" 
52c9 f5				push af  
52ca 3a de 52			ld a, (.dmark)  
52cd 32 6b fe			ld (debug_mark),a  
52d0 3a df 52			ld a, (.dmark+1)  
52d3 32 6c fe			ld (debug_mark+1),a  
52d6 3a e0 52			ld a, (.dmark+2)  
52d9 32 6d fe			ld (debug_mark+2),a  
52dc 18 03			jr .pastdmark  
52de ..			.dmark: db "DI8"  
52e1 f1			.pastdmark: pop af  
52e2			endm  
# End of macro DMARK
52e2						CALLMONITOR 
52e2 cd 6f fe			call debug_vector  
52e5				endm  
# End of macro CALLMONITOR
52e5					endif 
52e5 cd 30 21				call forth_push_str 
52e8			 
52e8			 
52e8				 
52e8					NEXTW 
52e8 c3 6f 24			jp macro_next 
52eb				endm 
# End of macro NEXTW
52eb			.SAVE: 
52eb			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
52eb			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
52eb			;		NEXTW 
52eb			;.LOAD: 
52eb			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
52eb			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
52eb			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
52eb			;; > > The LOAD command can not be used in any user words or compound lines. 
52eb			; 
52eb			;		; store_openext use it. If zero it is EOF 
52eb			; 
52eb			;		; read block from current stream id 
52eb			;		; if the block does not contain zero term keep reading blocks until zero found 
52eb			;		; push the block to stack 
52eb			;		; save the block id to stream 
52eb			; 
52eb			; 
52eb			;		FORTH_DSP_VALUEHL 
52eb			; 
52eb			;;		push hl 
52eb			; 
52eb			;	if DEBUG_STORESE 
52eb			;		DMARK "LOA" 
52eb			;		CALLMONITOR 
52eb			;	endif 
52eb			;		FORTH_DSP_POP 
52eb			; 
52eb			;;		pop hl 
52eb			; 
52eb			;		ld h, l 
52eb			;		ld l, 0 
52eb			; 
52eb			;		push hl     ; stack holds current file id and extent to work with 
52eb			; 
52eb			; 
52eb			;		ld de, store_page      ; get block zero of file 
52eb			;	if DEBUG_STORESE 
52eb			;		DMARK "LO0" 
52eb			;		CALLMONITOR 
52eb			;	endif 
52eb			;		call storage_read 
52eb			; 
52eb			;		ld a, (store_page+2)    ; max extents for this file 
52eb			;		ld  (store_openmaxext),a   ; get our limit 
52eb			; 
52eb			;	if DEBUG_STORESE 
52eb			;		DMARK "LOE" 
52eb			;		CALLMONITOR 
52eb			;	endif 
52eb			; 
52eb			;; TODO dont know why max extents are not present 
52eb			;;		cp 0 
52eb			;;		jp z, .loadeof     ; dont read past eof 
52eb			; 
52eb			;;		ld a, 1   ; start from the head of the file 
52eb			; 
52eb			;.loadline:	pop hl 
52eb			;		inc hl 
52eb			;		ld  a, (store_openmaxext)   ; get our limit 
52eb			;	if DEBUG_STORESE 
52eb			;		DMARK "LOx" 
52eb			;		CALLMONITOR 
52eb			;	endif 
52eb			;		inc a 
52eb			;		cp l 
52eb			;		jp z, .loadeof 
52eb			;		push hl    ; save current extent 
52eb			; 
52eb			;		ld de, store_page 
52eb			; 
52eb			;	if DEBUG_STORESE 
52eb			;		DMARK "LO1" 
52eb			;		CALLMONITOR 
52eb			;	endif 
52eb			;		call storage_read 
52eb			; 
52eb			;	if DEBUG_STORESE 
52eb			;		DMARK "LO2" 
52eb			;		CALLMONITOR 
52eb			;	endif 
52eb			;	call ishlzero 
52eb			;	ld a, l 
52eb			;	add h 
52eb			;	cp 0 
52eb			;	jr z, .loadeof 
52eb			; 
52eb			;	; not eof so hl should point to data to exec 
52eb			; 
52eb			;	; will need to add the FORTH_END_BUFFER flag 
52eb			 ; 
52eb			;	ld hl, store_page+2 
52eb			;	ld bc, 255 
52eb			;	ld a, 0 
52eb			;	cpir 
52eb			;	if DEBUG_STORESE 
52eb			;		DMARK "LOt" 
52eb			;		CALLMONITOR 
52eb			;	endif 
52eb			;	dec hl 
52eb			;	ld a, ' ' 
52eb			;	ld (hl), a 
52eb			;	inc hl 
52eb			;	ld (hl), a 
52eb			;	inc hl 
52eb			;	ld (hl), a 
52eb			;	inc hl 
52eb			;	ld a, FORTH_END_BUFFER 
52eb			;	ld (hl), a 
52eb			; 
52eb			;	; TODO handle more than a single block read 
52eb			; 
52eb			; 
52eb			;	ld hl, store_page+2 
52eb			; 
52eb			;	ld (os_tok_ptr), hl 
52eb			; 
52eb			;	if DEBUG_STORESE 
52eb			;		DMARK "LO3" 
52eb			;		CALLMONITOR 
52eb			;	endif 
52eb			; 
52eb			;	call forthparse 
52eb			;	call forthexec 
52eb			;	call forthexec_cleanup 
52eb			; 
52eb			;	; go to next extent 
52eb			; 
52eb			;	; get next block  or mark as eof 
52eb			;	jp .loadline 
52eb			; 
52eb			; 
52eb			; 
52eb			;	       NEXTW 
52eb			;.loadeof:	ld a, 0 
52eb			;		ld (store_openext), a 
52eb			; 
52eb			;	if DEBUG_STORESE 
52eb			;		DMARK "LOF" 
52eb			;		CALLMONITOR 
52eb			;	endif 
52eb			;		ret 
52eb			;		;NEXTW 
52eb			;.BSAVE:   
52eb			; 
52eb			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
52eb			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
52eb			;		NEXTW 
52eb			;.BLOAD: 
52eb			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
52eb			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
52eb			;		NEXTW 
52eb			;;;; counter gap 
52eb			 
52eb			 
52eb			.SEO: 
52eb				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
52eb 64				db WORD_SYS_CORE+80             
52ec 0a 53			dw .SEI            
52ee 04				db 3 + 1 
52ef .. 00			db "SEO",0              
52f3				endm 
# End of macro CWHEAD
52f3			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
52f3			 
52f3					; get port 
52f3			 
52f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52f3 cd b9 22			call macro_dsp_valuehl 
52f6				endm 
# End of macro FORTH_DSP_VALUEHL
52f6			 
52f6 e5					push hl    ; u2 - byte 
52f7			 
52f7					; destroy value TOS 
52f7			 
52f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52f7 cd 71 23			call macro_forth_dsp_pop 
52fa				endm 
# End of macro FORTH_DSP_POP
52fa			 
52fa					; get byte to send 
52fa			 
52fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52fa cd b9 22			call macro_dsp_valuehl 
52fd				endm 
# End of macro FORTH_DSP_VALUEHL
52fd			 
52fd e5					push hl    ; u1 - addr 
52fe			 
52fe					; destroy value TOS 
52fe			 
52fe					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52fe cd 71 23			call macro_forth_dsp_pop 
5301				endm 
# End of macro FORTH_DSP_POP
5301			 
5301					; one value on hl get other one back 
5301			 
5301 d1					pop de   ; u1 - byte 
5302			 
5302 e1					pop hl   ; u2 - addr 
5303			 
5303					; TODO Send SPI byte 
5303			 
5303			 
5303 7b					ld a, e 
5304 cd 21 02				call se_writebyte 
5307			 
5307					 
5307			 
5307					NEXTW 
5307 c3 6f 24			jp macro_next 
530a				endm 
# End of macro NEXTW
530a			 
530a			.SEI: 
530a				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
530a 65				db WORD_SYS_CORE+81             
530b 24 53			dw .SFREE            
530d 04				db 3 + 1 
530e .. 00			db "SEI",0              
5312				endm 
# End of macro CWHEAD
5312			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5312			 
5312					; get port 
5312			 
5312					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5312 cd b9 22			call macro_dsp_valuehl 
5315				endm 
# End of macro FORTH_DSP_VALUEHL
5315			 
5315			;		push hl 
5315			 
5315					; destroy value TOS 
5315			 
5315					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5315 cd 71 23			call macro_forth_dsp_pop 
5318				endm 
# End of macro FORTH_DSP_POP
5318			 
5318					; one value on hl get other one back 
5318			 
5318			;		pop hl 
5318			 
5318			 
5318					; TODO Get SPI byte 
5318			 
5318 cd c3 02				call se_readbyte 
531b			 
531b 26 00				ld h, 0 
531d 6f					ld l, a 
531e cd c2 20				call forth_push_numhl 
5321			 
5321					NEXTW 
5321 c3 6f 24			jp macro_next 
5324				endm 
# End of macro NEXTW
5324			 
5324			.SFREE: 
5324				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
5324 67				db WORD_SYS_CORE+83             
5325 53 53			dw .SIZE            
5327 06				db 5 + 1 
5328 .. 00			db "FFREE",0              
532e				endm 
# End of macro CWHEAD
532e			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
532e			; | | Compatible with PicoSPINet  
532e					if DEBUG_FORTH_WORDS_KEY 
532e						DMARK "FFR" 
532e f5				push af  
532f 3a 43 53			ld a, (.dmark)  
5332 32 6b fe			ld (debug_mark),a  
5335 3a 44 53			ld a, (.dmark+1)  
5338 32 6c fe			ld (debug_mark+1),a  
533b 3a 45 53			ld a, (.dmark+2)  
533e 32 6d fe			ld (debug_mark+2),a  
5341 18 03			jr .pastdmark  
5343 ..			.dmark: db "FFR"  
5346 f1			.pastdmark: pop af  
5347			endm  
# End of macro DMARK
5347						CALLMONITOR 
5347 cd 6f fe			call debug_vector  
534a				endm  
# End of macro CALLMONITOR
534a					endif 
534a			 
534a cd e9 07				call storage_freeblocks 
534d			 
534d cd c2 20				call forth_push_numhl 
5350			 
5350				       NEXTW 
5350 c3 6f 24			jp macro_next 
5353				endm 
# End of macro NEXTW
5353			.SIZE: 
5353				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
5353 67				db WORD_SYS_CORE+83             
5354 87 53			dw .CREATE            
5356 05				db 4 + 1 
5357 .. 00			db "SIZE",0              
535c				endm 
# End of macro CWHEAD
535c			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
535c			; | | Compatible with PicoSPINet  
535c					if DEBUG_FORTH_WORDS_KEY 
535c						DMARK "SIZ" 
535c f5				push af  
535d 3a 71 53			ld a, (.dmark)  
5360 32 6b fe			ld (debug_mark),a  
5363 3a 72 53			ld a, (.dmark+1)  
5366 32 6c fe			ld (debug_mark+1),a  
5369 3a 73 53			ld a, (.dmark+2)  
536c 32 6d fe			ld (debug_mark+2),a  
536f 18 03			jr .pastdmark  
5371 ..			.dmark: db "SIZ"  
5374 f1			.pastdmark: pop af  
5375			endm  
# End of macro DMARK
5375						CALLMONITOR 
5375 cd 6f fe			call debug_vector  
5378				endm  
# End of macro CALLMONITOR
5378					endif 
5378			 
5378					FORTH_DSP_VALUEHL 
5378 cd b9 22			call macro_dsp_valuehl 
537b				endm 
# End of macro FORTH_DSP_VALUEHL
537b			;		push hl 
537b					FORTH_DSP_POP 
537b cd 71 23			call macro_forth_dsp_pop 
537e				endm 
# End of macro FORTH_DSP_POP
537e			;		pop hl 
537e cd 4b 04				call storage_file_size 
5381			 
5381 cd c2 20				call forth_push_numhl 
5384			  
5384			 
5384				       NEXTW 
5384 c3 6f 24			jp macro_next 
5387				endm 
# End of macro NEXTW
5387			 
5387			.CREATE: 
5387				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
5387 68				db WORD_SYS_CORE+84             
5388 f5 53			dw .APPEND            
538a 07				db 6 + 1 
538b .. 00			db "CREATE",0              
5392				endm 
# End of macro CWHEAD
5392			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
5392			; | | e.g.  
5392			; | | TestProgram CREATE 
5392			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
5392			; | |  
5392			; | | Max file IDs are 255. 
5392			; | |  
5392			; | | Compatible with PicoSPINet  
5392					 
5392					if DEBUG_FORTH_WORDS_KEY 
5392						DMARK "CRT" 
5392 f5				push af  
5393 3a a7 53			ld a, (.dmark)  
5396 32 6b fe			ld (debug_mark),a  
5399 3a a8 53			ld a, (.dmark+1)  
539c 32 6c fe			ld (debug_mark+1),a  
539f 3a a9 53			ld a, (.dmark+2)  
53a2 32 6d fe			ld (debug_mark+2),a  
53a5 18 03			jr .pastdmark  
53a7 ..			.dmark: db "CRT"  
53aa f1			.pastdmark: pop af  
53ab			endm  
# End of macro DMARK
53ab						CALLMONITOR 
53ab cd 6f fe			call debug_vector  
53ae				endm  
# End of macro CALLMONITOR
53ae					endif 
53ae			;		call storage_get_block_0 
53ae			 
53ae					; TODO pop hl 
53ae			 
53ae					;v5 FORTH_DSP_VALUE 
53ae					FORTH_DSP_VALUE 
53ae cd a2 22			call macro_forth_dsp_value 
53b1				endm 
# End of macro FORTH_DSP_VALUE
53b1			 
53b1				if DEBUG_STORESE 
53b1					DMARK "CR1" 
53b1 f5				push af  
53b2 3a c6 53			ld a, (.dmark)  
53b5 32 6b fe			ld (debug_mark),a  
53b8 3a c7 53			ld a, (.dmark+1)  
53bb 32 6c fe			ld (debug_mark+1),a  
53be 3a c8 53			ld a, (.dmark+2)  
53c1 32 6d fe			ld (debug_mark+2),a  
53c4 18 03			jr .pastdmark  
53c6 ..			.dmark: db "CR1"  
53c9 f1			.pastdmark: pop af  
53ca			endm  
# End of macro DMARK
53ca					CALLMONITOR 
53ca cd 6f fe			call debug_vector  
53cd				endm  
# End of macro CALLMONITOR
53cd				endif 
53cd			;		push hl 
53cd			;		FORTH_DSP_POP 
53cd			;		pop hl 
53cd			 
53cd			;		inc hl   ; move past the type marker 
53cd			 
53cd cd 1f 08				call storage_create 
53d0			 
53d0				if DEBUG_STORESE 
53d0					DMARK "CT1" 
53d0 f5				push af  
53d1 3a e5 53			ld a, (.dmark)  
53d4 32 6b fe			ld (debug_mark),a  
53d7 3a e6 53			ld a, (.dmark+1)  
53da 32 6c fe			ld (debug_mark+1),a  
53dd 3a e7 53			ld a, (.dmark+2)  
53e0 32 6d fe			ld (debug_mark+2),a  
53e3 18 03			jr .pastdmark  
53e5 ..			.dmark: db "CT1"  
53e8 f1			.pastdmark: pop af  
53e9			endm  
# End of macro DMARK
53e9					CALLMONITOR 
53e9 cd 6f fe			call debug_vector  
53ec				endm  
# End of macro CALLMONITOR
53ec				endif 
53ec			;		push hl 
53ec					FORTH_DSP_POP 
53ec cd 71 23			call macro_forth_dsp_pop 
53ef				endm 
# End of macro FORTH_DSP_POP
53ef			;		pop hl 
53ef					; push file id to stack 
53ef cd c2 20				call forth_push_numhl 
53f2			 
53f2			 
53f2			 
53f2				       NEXTW 
53f2 c3 6f 24			jp macro_next 
53f5				endm 
# End of macro NEXTW
53f5			 
53f5			.APPEND: 
53f5				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
53f5 69				db WORD_SYS_CORE+85             
53f6 86 54			dw .SDEL            
53f8 07				db 6 + 1 
53f9 .. 00			db "APPEND",0              
5400				endm 
# End of macro CWHEAD
5400			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5400			; | | e.g. 
5400			; | | Test CREATE      -> $01 
5400			; | | "A string to add to file" $01 APPEND 
5400			; | |  
5400			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5400			; | | Compatible with PicoSPINet  
5400					if DEBUG_FORTH_WORDS_KEY 
5400						DMARK "APP" 
5400 f5				push af  
5401 3a 15 54			ld a, (.dmark)  
5404 32 6b fe			ld (debug_mark),a  
5407 3a 16 54			ld a, (.dmark+1)  
540a 32 6c fe			ld (debug_mark+1),a  
540d 3a 17 54			ld a, (.dmark+2)  
5410 32 6d fe			ld (debug_mark+2),a  
5413 18 03			jr .pastdmark  
5415 ..			.dmark: db "APP"  
5418 f1			.pastdmark: pop af  
5419			endm  
# End of macro DMARK
5419						CALLMONITOR 
5419 cd 6f fe			call debug_vector  
541c				endm  
# End of macro CALLMONITOR
541c					endif 
541c			 
541c					FORTH_DSP_VALUEHL 
541c cd b9 22			call macro_dsp_valuehl 
541f				endm 
# End of macro FORTH_DSP_VALUEHL
541f e5					push hl 	; save file id 
5420			 
5420				if DEBUG_STORESE 
5420					DMARK "AP1" 
5420 f5				push af  
5421 3a 35 54			ld a, (.dmark)  
5424 32 6b fe			ld (debug_mark),a  
5427 3a 36 54			ld a, (.dmark+1)  
542a 32 6c fe			ld (debug_mark+1),a  
542d 3a 37 54			ld a, (.dmark+2)  
5430 32 6d fe			ld (debug_mark+2),a  
5433 18 03			jr .pastdmark  
5435 ..			.dmark: db "AP1"  
5438 f1			.pastdmark: pop af  
5439			endm  
# End of macro DMARK
5439					CALLMONITOR 
5439 cd 6f fe			call debug_vector  
543c				endm  
# End of macro CALLMONITOR
543c				endif 
543c					FORTH_DSP_POP 
543c cd 71 23			call macro_forth_dsp_pop 
543f				endm 
# End of macro FORTH_DSP_POP
543f			 
543f					FORTH_DSP_VALUEHL 
543f cd b9 22			call macro_dsp_valuehl 
5442				endm 
# End of macro FORTH_DSP_VALUEHL
5442					;v5 FORTH_DSP_VALUE 
5442 e5					push hl 	; save ptr to string to save 
5443			 
5443				if DEBUG_STORESE 
5443					DMARK "AP1" 
5443 f5				push af  
5444 3a 58 54			ld a, (.dmark)  
5447 32 6b fe			ld (debug_mark),a  
544a 3a 59 54			ld a, (.dmark+1)  
544d 32 6c fe			ld (debug_mark+1),a  
5450 3a 5a 54			ld a, (.dmark+2)  
5453 32 6d fe			ld (debug_mark+2),a  
5456 18 03			jr .pastdmark  
5458 ..			.dmark: db "AP1"  
545b f1			.pastdmark: pop af  
545c			endm  
# End of macro DMARK
545c					CALLMONITOR 
545c cd 6f fe			call debug_vector  
545f				endm  
# End of macro CALLMONITOR
545f				endif 
545f					FORTH_DSP_POP 
545f cd 71 23			call macro_forth_dsp_pop 
5462				endm 
# End of macro FORTH_DSP_POP
5462			 
5462 d1					pop de 
5463 e1					pop hl 
5464				if DEBUG_STORESE 
5464					DMARK "AP2" 
5464 f5				push af  
5465 3a 79 54			ld a, (.dmark)  
5468 32 6b fe			ld (debug_mark),a  
546b 3a 7a 54			ld a, (.dmark+1)  
546e 32 6c fe			ld (debug_mark+1),a  
5471 3a 7b 54			ld a, (.dmark+2)  
5474 32 6d fe			ld (debug_mark+2),a  
5477 18 03			jr .pastdmark  
5479 ..			.dmark: db "AP2"  
547c f1			.pastdmark: pop af  
547d			endm  
# End of macro DMARK
547d					CALLMONITOR 
547d cd 6f fe			call debug_vector  
5480				endm  
# End of macro CALLMONITOR
5480				endif 
5480					;inc de ; skip var type indicator 
5480			 
5480					; TODO how to append numerics???? 
5480			 
5480 cd 0c 0b				call storage_append		 
5483			 
5483				       NEXTW 
5483 c3 6f 24			jp macro_next 
5486				endm 
# End of macro NEXTW
5486			.SDEL: 
5486				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
5486 6a				db WORD_SYS_CORE+86             
5487 d2 54			dw .OPEN            
5489 05				db 4 + 1 
548a .. 00			db "ERA",0              
548e				endm 
# End of macro CWHEAD
548e			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
548e			; | | Compatible with PicoSPINet  
548e					FORTH_DSP_VALUEHL 
548e cd b9 22			call macro_dsp_valuehl 
5491				endm 
# End of macro FORTH_DSP_VALUEHL
5491			;		push hl 	; save file id 
5491			 
5491					if DEBUG_FORTH_WORDS_KEY 
5491						DMARK "ERA" 
5491 f5				push af  
5492 3a a6 54			ld a, (.dmark)  
5495 32 6b fe			ld (debug_mark),a  
5498 3a a7 54			ld a, (.dmark+1)  
549b 32 6c fe			ld (debug_mark+1),a  
549e 3a a8 54			ld a, (.dmark+2)  
54a1 32 6d fe			ld (debug_mark+2),a  
54a4 18 03			jr .pastdmark  
54a6 ..			.dmark: db "ERA"  
54a9 f1			.pastdmark: pop af  
54aa			endm  
# End of macro DMARK
54aa						CALLMONITOR 
54aa cd 6f fe			call debug_vector  
54ad				endm  
# End of macro CALLMONITOR
54ad					endif 
54ad				if DEBUG_STORESE 
54ad					DMARK "ER1" 
54ad f5				push af  
54ae 3a c2 54			ld a, (.dmark)  
54b1 32 6b fe			ld (debug_mark),a  
54b4 3a c3 54			ld a, (.dmark+1)  
54b7 32 6c fe			ld (debug_mark+1),a  
54ba 3a c4 54			ld a, (.dmark+2)  
54bd 32 6d fe			ld (debug_mark+2),a  
54c0 18 03			jr .pastdmark  
54c2 ..			.dmark: db "ER1"  
54c5 f1			.pastdmark: pop af  
54c6			endm  
# End of macro DMARK
54c6					CALLMONITOR 
54c6 cd 6f fe			call debug_vector  
54c9				endm  
# End of macro CALLMONITOR
54c9				endif 
54c9					FORTH_DSP_POP 
54c9 cd 71 23			call macro_forth_dsp_pop 
54cc				endm 
# End of macro FORTH_DSP_POP
54cc			 
54cc			;		pop hl 
54cc			 
54cc cd 5e 06				call storage_erase 
54cf				       NEXTW 
54cf c3 6f 24			jp macro_next 
54d2				endm 
# End of macro NEXTW
54d2			 
54d2			.OPEN: 
54d2				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
54d2 6b				db WORD_SYS_CORE+87             
54d3 66 55			dw .READ            
54d5 05				db 4 + 1 
54d6 .. 00			db "OPEN",0              
54db				endm 
# End of macro CWHEAD
54db			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
54db			; | | e.g. 
54db			; | | $01 OPEN $01 DO $01 READ . LOOP 
54db			; | | 
54db			; | | Will return with 255 blocks if the file does not exist 
54db			; | | Compatible with PicoSPINet  
54db			 
54db					if DEBUG_FORTH_WORDS_KEY 
54db						DMARK "OPN" 
54db f5				push af  
54dc 3a f0 54			ld a, (.dmark)  
54df 32 6b fe			ld (debug_mark),a  
54e2 3a f1 54			ld a, (.dmark+1)  
54e5 32 6c fe			ld (debug_mark+1),a  
54e8 3a f2 54			ld a, (.dmark+2)  
54eb 32 6d fe			ld (debug_mark+2),a  
54ee 18 03			jr .pastdmark  
54f0 ..			.dmark: db "OPN"  
54f3 f1			.pastdmark: pop af  
54f4			endm  
# End of macro DMARK
54f4						CALLMONITOR 
54f4 cd 6f fe			call debug_vector  
54f7				endm  
# End of macro CALLMONITOR
54f7					endif 
54f7					; TODO handle multiple file opens 
54f7			 
54f7 3e 01			       	ld a, 1 
54f9 32 6a fa				ld (store_openext), a 
54fc			 
54fc					; get max extents for this file 
54fc				 
54fc								 
54fc					FORTH_DSP_VALUEHL 
54fc cd b9 22			call macro_dsp_valuehl 
54ff				endm 
# End of macro FORTH_DSP_VALUEHL
54ff			 
54ff 65					ld h, l 
5500 2e 00				ld l, 0 
5502			 
5502					; store file id 
5502			 
5502 7c					ld a, h 
5503 32 67 fa				ld (store_filecache), a 
5506			 
5506				if DEBUG_STORESE 
5506					DMARK "OPN" 
5506 f5				push af  
5507 3a 1b 55			ld a, (.dmark)  
550a 32 6b fe			ld (debug_mark),a  
550d 3a 1c 55			ld a, (.dmark+1)  
5510 32 6c fe			ld (debug_mark+1),a  
5513 3a 1d 55			ld a, (.dmark+2)  
5516 32 6d fe			ld (debug_mark+2),a  
5519 18 03			jr .pastdmark  
551b ..			.dmark: db "OPN"  
551e f1			.pastdmark: pop af  
551f			endm  
# End of macro DMARK
551f					CALLMONITOR 
551f cd 6f fe			call debug_vector  
5522				endm  
# End of macro CALLMONITOR
5522				endif 
5522			;		push hl 
5522					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5522 cd 71 23			call macro_forth_dsp_pop 
5525				endm 
# End of macro FORTH_DSP_POP
5525			;		pop hl 
5525						 
5525 11 7a fa				ld de, store_page      ; get block zero of file 
5528 cd 75 09				call storage_read 
552b cd af 0f			call ishlzero 
552e 20 04			jr nz, .opfound 
5530			 
5530				; file does not exist so indicate with 255 extents in use 
5530			 
5530 3e ff			ld a, 255 
5532 18 29			jr .skipopeneof 
5534			 
5534			 
5534			.opfound: 
5534			 
5534			 
5534 3a 7c fa				ld a, (store_page+2)    ; max extents for this file 
5537 32 69 fa				ld  (store_openmaxext), a   ; get our limit and push 
553a					 
553a				if DEBUG_STORESE 
553a					DMARK "OPx" 
553a f5				push af  
553b 3a 4f 55			ld a, (.dmark)  
553e 32 6b fe			ld (debug_mark),a  
5541 3a 50 55			ld a, (.dmark+1)  
5544 32 6c fe			ld (debug_mark+1),a  
5547 3a 51 55			ld a, (.dmark+2)  
554a 32 6d fe			ld (debug_mark+2),a  
554d 18 03			jr .pastdmark  
554f ..			.dmark: db "OPx"  
5552 f1			.pastdmark: pop af  
5553			endm  
# End of macro DMARK
5553					CALLMONITOR 
5553 cd 6f fe			call debug_vector  
5556				endm  
# End of macro CALLMONITOR
5556				endif 
5556 fe 00				cp 0 
5558 20 03				jr nz, .skipopeneof 
555a					; have opened an empty file 
555a					 
555a 32 6a fa				ld (store_openext), a 
555d			 
555d			.skipopeneof: 
555d			 
555d 6f					ld l, a 
555e 26 00				ld h, 0 
5560 cd c2 20				call forth_push_numhl 
5563			 
5563			 
5563				       NEXTW 
5563 c3 6f 24			jp macro_next 
5566				endm 
# End of macro NEXTW
5566			.READ: 
5566				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
5566 6c				db WORD_SYS_CORE+88             
5567 90 56			dw .EOF            
5569 05				db 4 + 1 
556a .. 00			db "READ",0              
556f				endm 
# End of macro CWHEAD
556f			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
556f			; | | e.g. 
556f			; | | $01 OPEN $01 DO READ . LOOP 
556f			; | | 
556f			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
556f			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
556f			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
556f			; | | two bytes contain the file id and extent. 
556f			; | |  
556f			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
556f			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
556f			; | | Compatible with PicoSPINet  
556f			 
556f					if DEBUG_FORTH_WORDS_KEY 
556f						DMARK "REA" 
556f f5				push af  
5570 3a 84 55			ld a, (.dmark)  
5573 32 6b fe			ld (debug_mark),a  
5576 3a 85 55			ld a, (.dmark+1)  
5579 32 6c fe			ld (debug_mark+1),a  
557c 3a 86 55			ld a, (.dmark+2)  
557f 32 6d fe			ld (debug_mark+2),a  
5582 18 03			jr .pastdmark  
5584 ..			.dmark: db "REA"  
5587 f1			.pastdmark: pop af  
5588			endm  
# End of macro DMARK
5588						CALLMONITOR 
5588 cd 6f fe			call debug_vector  
558b				endm  
# End of macro CALLMONITOR
558b					endif 
558b					; store_openext use it. If zero it is EOF 
558b			 
558b					; read block from current stream id 
558b					; if the block does not contain zero term keep reading blocks until zero found 
558b					; push the block to stack 
558b					; save the block id to stream 
558b			 
558b			 
558b cd bd 56				call .testeof 
558e 3e 01				ld a, 1 
5590 bd					cp l 
5591 ca 6c 56				jp z, .ateof 
5594			 
5594			 
5594			;		FORTH_DSP_VALUEHL 
5594			 
5594			;		push hl 
5594			 
5594			;	if DEBUG_STORESE 
5594			;		DMARK "REA" 
5594			;		CALLMONITOR 
5594			;	endif 
5594			;		FORTH_DSP_POP 
5594			 
5594			;		pop hl 
5594				 
5594 3a 67 fa				ld a, (store_filecache) 
5597 67					ld h,a 
5598			 
5598 3a 6a fa				ld a, (store_openext) 
559b 6f					ld l, a 
559c					 
559c fe 00				cp 0 
559e ca 6c 56				jp z, .ateof     ; dont read past eof 
55a1			 
55a1 cd 58 0c				call storage_clear_page 
55a4			 
55a4 11 7a fa				ld de, store_page 
55a7				if DEBUG_STORESE 
55a7					DMARK "RE1" 
55a7 f5				push af  
55a8 3a bc 55			ld a, (.dmark)  
55ab 32 6b fe			ld (debug_mark),a  
55ae 3a bd 55			ld a, (.dmark+1)  
55b1 32 6c fe			ld (debug_mark+1),a  
55b4 3a be 55			ld a, (.dmark+2)  
55b7 32 6d fe			ld (debug_mark+2),a  
55ba 18 03			jr .pastdmark  
55bc ..			.dmark: db "RE1"  
55bf f1			.pastdmark: pop af  
55c0			endm  
# End of macro DMARK
55c0					CALLMONITOR 
55c0 cd 6f fe			call debug_vector  
55c3				endm  
# End of macro CALLMONITOR
55c3				endif 
55c3 cd 75 09				call storage_read 
55c6			 
55c6				if DEBUG_STORESE 
55c6					DMARK "RE2" 
55c6 f5				push af  
55c7 3a db 55			ld a, (.dmark)  
55ca 32 6b fe			ld (debug_mark),a  
55cd 3a dc 55			ld a, (.dmark+1)  
55d0 32 6c fe			ld (debug_mark+1),a  
55d3 3a dd 55			ld a, (.dmark+2)  
55d6 32 6d fe			ld (debug_mark+2),a  
55d9 18 03			jr .pastdmark  
55db ..			.dmark: db "RE2"  
55de f1			.pastdmark: pop af  
55df			endm  
# End of macro DMARK
55df					CALLMONITOR 
55df cd 6f fe			call debug_vector  
55e2				endm  
# End of macro CALLMONITOR
55e2				endif 
55e2 cd af 0f			call ishlzero 
55e5			;	ld a, l 
55e5			;	add h 
55e5			;	cp 0 
55e5 ca 6c 56			jp z, .readeof 
55e8			 
55e8				; not eof so hl should point to data to push to stack 
55e8			 
55e8				if DEBUG_STORESE 
55e8					DMARK "RE3" 
55e8 f5				push af  
55e9 3a fd 55			ld a, (.dmark)  
55ec 32 6b fe			ld (debug_mark),a  
55ef 3a fe 55			ld a, (.dmark+1)  
55f2 32 6c fe			ld (debug_mark+1),a  
55f5 3a ff 55			ld a, (.dmark+2)  
55f8 32 6d fe			ld (debug_mark+2),a  
55fb 18 03			jr .pastdmark  
55fd ..			.dmark: db "RE3"  
5600 f1			.pastdmark: pop af  
5601			endm  
# End of macro DMARK
5601					CALLMONITOR 
5601 cd 6f fe			call debug_vector  
5604				endm  
# End of macro CALLMONITOR
5604				endif 
5604 cd 30 21			call forth_push_str 
5607			 
5607				if DEBUG_STORESE 
5607					DMARK "RE4" 
5607 f5				push af  
5608 3a 1c 56			ld a, (.dmark)  
560b 32 6b fe			ld (debug_mark),a  
560e 3a 1d 56			ld a, (.dmark+1)  
5611 32 6c fe			ld (debug_mark+1),a  
5614 3a 1e 56			ld a, (.dmark+2)  
5617 32 6d fe			ld (debug_mark+2),a  
561a 18 03			jr .pastdmark  
561c ..			.dmark: db "RE4"  
561f f1			.pastdmark: pop af  
5620			endm  
# End of macro DMARK
5620					CALLMONITOR 
5620 cd 6f fe			call debug_vector  
5623				endm  
# End of macro CALLMONITOR
5623				endif 
5623				; get next block  or mark as eof 
5623			 
5623 3a 69 fa			ld a, (store_openmaxext)   ; get our limit 
5626 4f				ld c, a	 
5627 3a 6a fa			ld a, (store_openext) 
562a			 
562a				if DEBUG_STORESE 
562a					DMARK "RE5" 
562a f5				push af  
562b 3a 3f 56			ld a, (.dmark)  
562e 32 6b fe			ld (debug_mark),a  
5631 3a 40 56			ld a, (.dmark+1)  
5634 32 6c fe			ld (debug_mark+1),a  
5637 3a 41 56			ld a, (.dmark+2)  
563a 32 6d fe			ld (debug_mark+2),a  
563d 18 03			jr .pastdmark  
563f ..			.dmark: db "RE5"  
5642 f1			.pastdmark: pop af  
5643			endm  
# End of macro DMARK
5643					CALLMONITOR 
5643 cd 6f fe			call debug_vector  
5646				endm  
# End of macro CALLMONITOR
5646				endif 
5646 b9				cp c 
5647 28 23			jr z, .readeof     ; at last extent 
5649			 
5649 3c					inc a 
564a 32 6a fa				ld (store_openext), a 
564d			 
564d				if DEBUG_STORESE 
564d					DMARK "RE6" 
564d f5				push af  
564e 3a 62 56			ld a, (.dmark)  
5651 32 6b fe			ld (debug_mark),a  
5654 3a 63 56			ld a, (.dmark+1)  
5657 32 6c fe			ld (debug_mark+1),a  
565a 3a 64 56			ld a, (.dmark+2)  
565d 32 6d fe			ld (debug_mark+2),a  
5660 18 03			jr .pastdmark  
5662 ..			.dmark: db "RE6"  
5665 f1			.pastdmark: pop af  
5666			endm  
# End of macro DMARK
5666					CALLMONITOR 
5666 cd 6f fe			call debug_vector  
5669				endm  
# End of macro CALLMONITOR
5669				endif 
5669			 
5669			 
5669				       NEXTW 
5669 c3 6f 24			jp macro_next 
566c				endm 
# End of macro NEXTW
566c			.ateof: 
566c				;	ld hl, .showeof 
566c				;	call forth_push_str 
566c 3e 00		.readeof:	ld a, 0 
566e 32 6a fa				ld (store_openext), a 
5671			 
5671					 
5671				if DEBUG_STORESE 
5671					DMARK "REF" 
5671 f5				push af  
5672 3a 86 56			ld a, (.dmark)  
5675 32 6b fe			ld (debug_mark),a  
5678 3a 87 56			ld a, (.dmark+1)  
567b 32 6c fe			ld (debug_mark+1),a  
567e 3a 88 56			ld a, (.dmark+2)  
5681 32 6d fe			ld (debug_mark+2),a  
5684 18 03			jr .pastdmark  
5686 ..			.dmark: db "REF"  
5689 f1			.pastdmark: pop af  
568a			endm  
# End of macro DMARK
568a					CALLMONITOR 
568a cd 6f fe			call debug_vector  
568d				endm  
# End of macro CALLMONITOR
568d				endif 
568d				       NEXTW 
568d c3 6f 24			jp macro_next 
5690				endm 
# End of macro NEXTW
5690			 
5690			;.showeof:   db "eof", 0 
5690			 
5690			 
5690			.EOF: 
5690				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5690 6d				db WORD_SYS_CORE+89             
5691 d2 56			dw .FORMAT            
5693 04				db 3 + 1 
5694 .. 00			db "EOF",0              
5698				endm 
# End of macro CWHEAD
5698			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
5698			; | | e.g. 
5698			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
5698			; | | Compatible with PicoSPINet  
5698					; TODO if current block id for stream is zero then push true else false 
5698			 
5698					if DEBUG_FORTH_WORDS_KEY 
5698						DMARK "EOF" 
5698 f5				push af  
5699 3a ad 56			ld a, (.dmark)  
569c 32 6b fe			ld (debug_mark),a  
569f 3a ae 56			ld a, (.dmark+1)  
56a2 32 6c fe			ld (debug_mark+1),a  
56a5 3a af 56			ld a, (.dmark+2)  
56a8 32 6d fe			ld (debug_mark+2),a  
56ab 18 03			jr .pastdmark  
56ad ..			.dmark: db "EOF"  
56b0 f1			.pastdmark: pop af  
56b1			endm  
# End of macro DMARK
56b1						CALLMONITOR 
56b1 cd 6f fe			call debug_vector  
56b4				endm  
# End of macro CALLMONITOR
56b4					endif 
56b4			 
56b4					; TODO handlue multiple file streams 
56b4			 
56b4			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
56b4 cd bd 56				call .testeof 
56b7 cd c2 20				call forth_push_numhl 
56ba			 
56ba			 
56ba				       NEXTW 
56ba c3 6f 24			jp macro_next 
56bd				endm 
# End of macro NEXTW
56bd			 
56bd			.testeof: 
56bd 2e 01				ld l, 1 
56bf 3a 69 fa				ld a, (store_openmaxext) 
56c2 fe 00				cp 0 
56c4 28 09				jr  z, .eofdone   ; empty file 
56c6 3a 6a fa				ld a, (store_openext) 
56c9 fe 00				cp 0 
56cb 28 02				jr  z, .eofdone 
56cd 2e 00				ld l, 0 
56cf 26 00		.eofdone:	ld h, 0 
56d1 c9					ret 
56d2			 
56d2			 
56d2			 
56d2			 
56d2			.FORMAT: 
56d2				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
56d2 6d				db WORD_SYS_CORE+89             
56d3 23 57			dw .LABEL            
56d5 07				db 6 + 1 
56d6 .. 00			db "FORMAT",0              
56dd				endm 
# End of macro CWHEAD
56dd			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
56dd			; | | Compatible with PicoSPINet  
56dd					; TODO if current block id for stream is zero then push true else false 
56dd				 
56dd				if DEBUG_STORESE 
56dd					DMARK "FOR" 
56dd f5				push af  
56de 3a f2 56			ld a, (.dmark)  
56e1 32 6b fe			ld (debug_mark),a  
56e4 3a f3 56			ld a, (.dmark+1)  
56e7 32 6c fe			ld (debug_mark+1),a  
56ea 3a f4 56			ld a, (.dmark+2)  
56ed 32 6d fe			ld (debug_mark+2),a  
56f0 18 03			jr .pastdmark  
56f2 ..			.dmark: db "FOR"  
56f5 f1			.pastdmark: pop af  
56f6			endm  
# End of macro DMARK
56f6					CALLMONITOR 
56f6 cd 6f fe			call debug_vector  
56f9				endm  
# End of macro CALLMONITOR
56f9				endif 
56f9					; Wipes the bank check flags to cause a reformat on next block 0 read 
56f9			 
56f9 21 01 00				ld hl, 1 
56fc 3e 00				ld a, 0 
56fe cd 21 02				call se_writebyte 
5701			 
5701				if DEBUG_STORESE 
5701					DMARK "FO0" 
5701 f5				push af  
5702 3a 16 57			ld a, (.dmark)  
5705 32 6b fe			ld (debug_mark),a  
5708 3a 17 57			ld a, (.dmark+1)  
570b 32 6c fe			ld (debug_mark+1),a  
570e 3a 18 57			ld a, (.dmark+2)  
5711 32 6d fe			ld (debug_mark+2),a  
5714 18 03			jr .pastdmark  
5716 ..			.dmark: db "FO0"  
5719 f1			.pastdmark: pop af  
571a			endm  
# End of macro DMARK
571a					CALLMONITOR 
571a cd 6f fe			call debug_vector  
571d				endm  
# End of macro CALLMONITOR
571d				endif 
571d					; force bank init 
571d			 
571d cd cd 04				call storage_get_block_0 
5720					 
5720				       NEXTW 
5720 c3 6f 24			jp macro_next 
5723				endm 
# End of macro NEXTW
5723			.LABEL: 
5723				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5723 6d				db WORD_SYS_CORE+89             
5724 71 57			dw .STOREPAGE            
5726 06				db 5 + 1 
5727 .. 00			db "LABEL",0              
572d				endm 
# End of macro CWHEAD
572d			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
572d			; | | Compatible with PicoSPINet  
572d					; TODO test to see if bank is selected 
572d				 
572d					if DEBUG_FORTH_WORDS_KEY 
572d						DMARK "LBL" 
572d f5				push af  
572e 3a 42 57			ld a, (.dmark)  
5731 32 6b fe			ld (debug_mark),a  
5734 3a 43 57			ld a, (.dmark+1)  
5737 32 6c fe			ld (debug_mark+1),a  
573a 3a 44 57			ld a, (.dmark+2)  
573d 32 6d fe			ld (debug_mark+2),a  
5740 18 03			jr .pastdmark  
5742 ..			.dmark: db "LBL"  
5745 f1			.pastdmark: pop af  
5746			endm  
# End of macro DMARK
5746						CALLMONITOR 
5746 cd 6f fe			call debug_vector  
5749				endm  
# End of macro CALLMONITOR
5749					endif 
5749			;	if DEBUG_STORESE 
5749			;		DMARK "LBL" 
5749			;		CALLMONITOR 
5749			;	endif 
5749					FORTH_DSP_VALUEHL 
5749 cd b9 22			call macro_dsp_valuehl 
574c				endm 
# End of macro FORTH_DSP_VALUEHL
574c					;v5FORTH_DSP_VALUE 
574c					 
574c			;		push hl 
574c					FORTH_DSP_POP 
574c cd 71 23			call macro_forth_dsp_pop 
574f				endm 
# End of macro FORTH_DSP_POP
574f			;		pop hl 
574f			 
574f			;v5		inc hl   ; move past the type marker 
574f			 
574f				if DEBUG_STORESE 
574f					DMARK "LBl" 
574f f5				push af  
5750 3a 64 57			ld a, (.dmark)  
5753 32 6b fe			ld (debug_mark),a  
5756 3a 65 57			ld a, (.dmark+1)  
5759 32 6c fe			ld (debug_mark+1),a  
575c 3a 66 57			ld a, (.dmark+2)  
575f 32 6d fe			ld (debug_mark+2),a  
5762 18 03			jr .pastdmark  
5764 ..			.dmark: db "LBl"  
5767 f1			.pastdmark: pop af  
5768			endm  
# End of macro DMARK
5768					CALLMONITOR 
5768 cd 6f fe			call debug_vector  
576b				endm  
# End of macro CALLMONITOR
576b				endif 
576b cd f1 05				call storage_label 
576e			 
576e				       NEXTW 
576e c3 6f 24			jp macro_next 
5771				endm 
# End of macro NEXTW
5771			.STOREPAGE: 
5771				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5771 6d				db WORD_SYS_CORE+89             
5772 a4 57			dw .LABELS            
5774 0a				db 9 + 1 
5775 .. 00			db "STOREPAGE",0              
577f				endm 
# End of macro CWHEAD
577f			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
577f			; | | Compatible with PicoSPINet  
577f					; TODO test to see if bank is selected 
577f				 
577f					if DEBUG_FORTH_WORDS_KEY 
577f						DMARK "STP" 
577f f5				push af  
5780 3a 94 57			ld a, (.dmark)  
5783 32 6b fe			ld (debug_mark),a  
5786 3a 95 57			ld a, (.dmark+1)  
5789 32 6c fe			ld (debug_mark+1),a  
578c 3a 96 57			ld a, (.dmark+2)  
578f 32 6d fe			ld (debug_mark+2),a  
5792 18 03			jr .pastdmark  
5794 ..			.dmark: db "STP"  
5797 f1			.pastdmark: pop af  
5798			endm  
# End of macro DMARK
5798						CALLMONITOR 
5798 cd 6f fe			call debug_vector  
579b				endm  
# End of macro CALLMONITOR
579b					endif 
579b			;	if DEBUG_STORESE 
579b			;		DMARK "STP" 
579b			;		CALLMONITOR 
579b			;	endif 
579b			 
579b 21 7a fa			ld hl, store_page 
579e cd c2 20			call forth_push_numhl 
57a1			 
57a1			 
57a1				       NEXTW 
57a1 c3 6f 24			jp macro_next 
57a4				endm 
# End of macro NEXTW
57a4			.LABELS: 
57a4				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
57a4 6d				db WORD_SYS_CORE+89             
57a5 2e 58			dw .SCONST1            
57a7 07				db 6 + 1 
57a8 .. 00			db "LABELS",0              
57af				endm 
# End of macro CWHEAD
57af			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
57af			; | | *NOT* Compatible with PicoSPINet  
57af					;  
57af			 
57af					; save the current device selected to restore afterwards 
57af				 
57af 3a 60 fa				ld a, (spi_device) 
57b2 f5					push af 
57b3			 
57b3			 
57b3					; run through each of the banks 
57b3			 
57b3 21 01 00				ld hl, 1 
57b6 cd c2 20				call forth_push_numhl 
57b9 3e ff				ld a, SPI_CE_HIGH 
57bb cb 87				res SPI_CE0, a 
57bd 32 60 fa				ld (spi_device), a 
57c0 cd cd 04				call storage_get_block_0 
57c3 21 7d fa				ld hl, store_page+3 
57c6 cd 30 21				call forth_push_str 
57c9			 
57c9					 
57c9 21 02 00				ld hl, 2 
57cc cd c2 20				call forth_push_numhl 
57cf 3e ff				ld a, SPI_CE_HIGH 
57d1 cb 8f				res SPI_CE1, a 
57d3 32 60 fa				ld (spi_device), a 
57d6 cd cd 04				call storage_get_block_0 
57d9 21 7d fa				ld hl, store_page+3 
57dc cd 30 21				call forth_push_str 
57df			 
57df					 
57df 21 03 00				ld hl, 3 
57e2 cd c2 20				call forth_push_numhl 
57e5 3e ff				ld a, SPI_CE_HIGH 
57e7 cb 97				res SPI_CE2, a 
57e9 32 60 fa				ld (spi_device), a 
57ec cd cd 04				call storage_get_block_0 
57ef 21 7d fa				ld hl, store_page+3 
57f2 cd 30 21				call forth_push_str 
57f5			 
57f5			 
57f5 21 04 00				ld hl, 4 
57f8 cd c2 20				call forth_push_numhl 
57fb 3e ff				ld a, SPI_CE_HIGH 
57fd cb 9f				res SPI_CE3, a 
57ff 32 60 fa				ld (spi_device), a 
5802 cd cd 04				call storage_get_block_0 
5805 21 7d fa				ld hl, store_page+3 
5808 cd 30 21				call forth_push_str 
580b			 
580b					 
580b			 
580b 21 05 00				ld hl, 5 
580e cd c2 20				call forth_push_numhl 
5811 3e ff				ld a, SPI_CE_HIGH 
5813 cb a7				res SPI_CE4, a 
5815 32 60 fa				ld (spi_device), a 
5818 cd cd 04				call storage_get_block_0 
581b 21 7d fa				ld hl, store_page+3 
581e cd 30 21				call forth_push_str 
5821			 
5821					 
5821					; push fixed count of storage devices (on board) for now 
5821			 
5821 21 05 00				ld hl, 5 
5824 cd c2 20				call forth_push_numhl 
5827			 
5827					; restore selected device  
5827				 
5827 f1					pop af 
5828 32 60 fa				ld (spi_device), a 
582b			 
582b				       NEXTW 
582b c3 6f 24			jp macro_next 
582e				endm 
# End of macro NEXTW
582e			 
582e			.SCONST1: 
582e				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
582e 6d				db WORD_SYS_CORE+89             
582f 45 58			dw .SCONST2            
5831 07				db 6 + 1 
5832 .. 00			db "FILEID",0              
5839				endm 
# End of macro CWHEAD
5839			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5839			; | | Compatible with PicoSPINet  
5839 3a 67 fa				ld a, (store_filecache) 
583c 26 00				ld h, 0 
583e 6f					ld l, a 
583f cd c2 20				call forth_push_numhl 
5842					NEXTW 
5842 c3 6f 24			jp macro_next 
5845				endm 
# End of macro NEXTW
5845			.SCONST2: 
5845				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5845 6d				db WORD_SYS_CORE+89             
5846 5d 58			dw .SCONST3            
5848 08				db 7 + 1 
5849 .. 00			db "FILEEXT",0              
5851				endm 
# End of macro CWHEAD
5851			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5851			; | | Compatible with PicoSPINet  
5851 3a 6a fa				ld a, (store_openext) 
5854 26 00				ld h, 0 
5856 6f					ld l, a 
5857 cd c2 20				call forth_push_numhl 
585a					NEXTW 
585a c3 6f 24			jp macro_next 
585d				endm 
# End of macro NEXTW
585d			.SCONST3: 
585d				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
585d 6d				db WORD_SYS_CORE+89             
585e 75 58			dw .SCONST4            
5860 08				db 7 + 1 
5861 .. 00			db "FILEMAX",0              
5869				endm 
# End of macro CWHEAD
5869			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
5869			; | | Compatible with PicoSPINet  
5869 3a 69 fa				ld a, (store_openmaxext) 
586c 26 00				ld h, 0 
586e 6f					ld l, a 
586f cd c2 20				call forth_push_numhl 
5872					NEXTW 
5872 c3 6f 24			jp macro_next 
5875				endm 
# End of macro NEXTW
5875			.SCONST4: 
5875				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
5875 6d				db WORD_SYS_CORE+89             
5876 8b 58			dw .SCONST5            
5878 09				db 8 + 1 
5879 .. 00			db "FILEADDR",0              
5882				endm 
# End of macro CWHEAD
5882			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
5882			; | | Compatible with PicoSPINet  
5882 2a 6b fa				ld hl, (store_openaddr) 
5885 cd c2 20				call forth_push_numhl 
5888					NEXTW 
5888 c3 6f 24			jp macro_next 
588b				endm 
# End of macro NEXTW
588b			.SCONST5: 
588b				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
588b 6d				db WORD_SYS_CORE+89             
588c ac 58			dw .SCONST6            
588e 09				db 8 + 1 
588f .. 00			db "FILEPAGE",0              
5898				endm 
# End of macro CWHEAD
5898			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
5898			; | | Compatible with PicoSPINet  
5898 2a 6b fa				ld hl, (store_openaddr) 
589b e5					push hl 
589c c1					pop bc 
589d 16 00				ld d, 0 
589f 1e 40				ld e, STORE_BLOCK_PHY 
58a1 cd e3 0e				call Div16 
58a4 c5					push bc 
58a5 e1					pop hl 
58a6 cd c2 20				call forth_push_numhl 
58a9					NEXTW 
58a9 c3 6f 24			jp macro_next 
58ac				endm 
# End of macro NEXTW
58ac			.SCONST6: 
58ac				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
58ac 6d				db WORD_SYS_CORE+89             
58ad c5 58			dw .ENDSTORAGE            
58af 09				db 8 + 1 
58b0 .. 00			db "READCONT",0              
58b9				endm 
# End of macro CWHEAD
58b9			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
58b9			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
58b9			; | | a further read should, if applicable, be CONCAT to the previous read. 
58b9			; | | Compatible with PicoSPINet  
58b9 3a 6d fa				ld a, (store_readcont) 
58bc 26 00				ld h, 0 
58be 6f					ld l, a 
58bf cd c2 20				call forth_push_numhl 
58c2					NEXTW 
58c2 c3 6f 24			jp macro_next 
58c5				endm 
# End of macro NEXTW
58c5			.ENDSTORAGE: 
58c5			; eof 
# End of file forth_words_storage.asm
58c5			endif 
58c5				include "forth_words_device.asm" 
58c5			; Device related words 
58c5			 
58c5			; | ## Device Words 
58c5			 
58c5			;if SOUND_ENABLE 
58c5			;.NOTE: 
58c5			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
58c5			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
58c5			;		if DEBUG_FORTH_WORDS_KEY 
58c5			;			DMARK "NTE" 
58c5			;			CALLMONITOR 
58c5			;		endif 
58c5			; 
58c5			;	 
58c5			; 
58c5			;		NEXTW 
58c5			;.AFTERSOUND: 
58c5			;endif 
58c5			 
58c5			 
58c5			USE_GPIO: equ 0 
58c5			 
58c5			if USE_GPIO 
58c5			.GP1: 
58c5				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
58c5			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
58c5					NEXTW 
58c5			.GP2: 
58c5				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
58c5			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
58c5			 
58c5					NEXTW 
58c5			 
58c5			.GP3: 
58c5				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
58c5			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
58c5			 
58c5					NEXTW 
58c5			 
58c5			.GP4: 
58c5				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
58c5			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
58c5			 
58c5					NEXTW 
58c5			.SIN: 
58c5			 
58c5			 
58c5			endif 
58c5			 
58c5			 
58c5				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
58c5 33				db WORD_SYS_CORE+31             
58c6 fa 58			dw .SOUT            
58c8 03				db 2 + 1 
58c9 .. 00			db "IN",0              
58cc				endm 
# End of macro CWHEAD
58cc			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
58cc					if DEBUG_FORTH_WORDS_KEY 
58cc						DMARK "IN." 
58cc f5				push af  
58cd 3a e1 58			ld a, (.dmark)  
58d0 32 6b fe			ld (debug_mark),a  
58d3 3a e2 58			ld a, (.dmark+1)  
58d6 32 6c fe			ld (debug_mark+1),a  
58d9 3a e3 58			ld a, (.dmark+2)  
58dc 32 6d fe			ld (debug_mark+2),a  
58df 18 03			jr .pastdmark  
58e1 ..			.dmark: db "IN."  
58e4 f1			.pastdmark: pop af  
58e5			endm  
# End of macro DMARK
58e5						CALLMONITOR 
58e5 cd 6f fe			call debug_vector  
58e8				endm  
# End of macro CALLMONITOR
58e8					endif 
58e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
58e8 cd b9 22			call macro_dsp_valuehl 
58eb				endm 
# End of macro FORTH_DSP_VALUEHL
58eb			 
58eb e5					push hl 
58ec			 
58ec					; destroy value TOS 
58ec			 
58ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
58ec cd 71 23			call macro_forth_dsp_pop 
58ef				endm 
# End of macro FORTH_DSP_POP
58ef			 
58ef					; one value on hl get other one back 
58ef			 
58ef c1					pop bc 
58f0			 
58f0					; do the sub 
58f0			;		ex de, hl 
58f0			 
58f0 ed 68				in l,(c) 
58f2			 
58f2					; save it 
58f2			 
58f2 26 00				ld h,0 
58f4			 
58f4					; TODO push value back onto stack for another op etc 
58f4			 
58f4 cd c2 20				call forth_push_numhl 
58f7					NEXTW 
58f7 c3 6f 24			jp macro_next 
58fa				endm 
# End of macro NEXTW
58fa			.SOUT: 
58fa				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
58fa 34				db WORD_SYS_CORE+32             
58fb 4d 59			dw .SPIO            
58fd 04				db 3 + 1 
58fe .. 00			db "OUT",0              
5902				endm 
# End of macro CWHEAD
5902			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5902					if DEBUG_FORTH_WORDS_KEY 
5902						DMARK "OUT" 
5902 f5				push af  
5903 3a 17 59			ld a, (.dmark)  
5906 32 6b fe			ld (debug_mark),a  
5909 3a 18 59			ld a, (.dmark+1)  
590c 32 6c fe			ld (debug_mark+1),a  
590f 3a 19 59			ld a, (.dmark+2)  
5912 32 6d fe			ld (debug_mark+2),a  
5915 18 03			jr .pastdmark  
5917 ..			.dmark: db "OUT"  
591a f1			.pastdmark: pop af  
591b			endm  
# End of macro DMARK
591b						CALLMONITOR 
591b cd 6f fe			call debug_vector  
591e				endm  
# End of macro CALLMONITOR
591e					endif 
591e			 
591e					; get port 
591e			 
591e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
591e cd b9 22			call macro_dsp_valuehl 
5921				endm 
# End of macro FORTH_DSP_VALUEHL
5921			 
5921 e5					push hl 
5922			 
5922					; destroy value TOS 
5922			 
5922					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5922 cd 71 23			call macro_forth_dsp_pop 
5925				endm 
# End of macro FORTH_DSP_POP
5925			 
5925					; get byte to send 
5925			 
5925					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5925 cd b9 22			call macro_dsp_valuehl 
5928				endm 
# End of macro FORTH_DSP_VALUEHL
5928			 
5928			;		push hl 
5928			 
5928					; destroy value TOS 
5928			 
5928					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5928 cd 71 23			call macro_forth_dsp_pop 
592b				endm 
# End of macro FORTH_DSP_POP
592b			 
592b					; one value on hl get other one back 
592b			 
592b			;		pop hl 
592b			 
592b c1					pop bc 
592c			 
592c					if DEBUG_FORTH_WORDS 
592c						DMARK "OUT" 
592c f5				push af  
592d 3a 41 59			ld a, (.dmark)  
5930 32 6b fe			ld (debug_mark),a  
5933 3a 42 59			ld a, (.dmark+1)  
5936 32 6c fe			ld (debug_mark+1),a  
5939 3a 43 59			ld a, (.dmark+2)  
593c 32 6d fe			ld (debug_mark+2),a  
593f 18 03			jr .pastdmark  
5941 ..			.dmark: db "OUT"  
5944 f1			.pastdmark: pop af  
5945			endm  
# End of macro DMARK
5945						CALLMONITOR 
5945 cd 6f fe			call debug_vector  
5948				endm  
# End of macro CALLMONITOR
5948					endif 
5948			 
5948 ed 69				out (c), l 
594a			 
594a					NEXTW 
594a c3 6f 24			jp macro_next 
594d				endm 
# End of macro NEXTW
594d			 
594d			 
594d			.SPIO: 
594d			 
594d			if STORAGE_SE 
594d				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
594d 51				db WORD_SYS_CORE+61             
594e 5e 59			dw .SPICEH            
5950 07				db 6 + 1 
5951 .. 00			db "SPICEL",0              
5958				endm 
# End of macro CWHEAD
5958			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5958			 
5958 cd ca 01				call spi_ce_low 
595b			    NEXTW 
595b c3 6f 24			jp macro_next 
595e				endm 
# End of macro NEXTW
595e			 
595e			.SPICEH: 
595e				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
595e 51				db WORD_SYS_CORE+61             
595f 6f 59			dw .SPIOb            
5961 07				db 6 + 1 
5962 .. 00			db "SPICEH",0              
5969				endm 
# End of macro CWHEAD
5969			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5969			 
5969 cd b9 01				call spi_ce_high 
596c			    NEXTW 
596c c3 6f 24			jp macro_next 
596f				endm 
# End of macro NEXTW
596f			 
596f			 
596f			.SPIOb: 
596f			 
596f				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
596f 51				db WORD_SYS_CORE+61             
5970 a1 59			dw .SPII            
5972 05				db 4 + 1 
5973 .. 00			db "SPIO",0              
5978				endm 
# End of macro CWHEAD
5978			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5978			 
5978					if DEBUG_FORTH_WORDS_KEY 
5978						DMARK "SPo" 
5978 f5				push af  
5979 3a 8d 59			ld a, (.dmark)  
597c 32 6b fe			ld (debug_mark),a  
597f 3a 8e 59			ld a, (.dmark+1)  
5982 32 6c fe			ld (debug_mark+1),a  
5985 3a 8f 59			ld a, (.dmark+2)  
5988 32 6d fe			ld (debug_mark+2),a  
598b 18 03			jr .pastdmark  
598d ..			.dmark: db "SPo"  
5990 f1			.pastdmark: pop af  
5991			endm  
# End of macro DMARK
5991						CALLMONITOR 
5991 cd 6f fe			call debug_vector  
5994				endm  
# End of macro CALLMONITOR
5994					endif 
5994					; get port 
5994			 
5994			 
5994					; get byte to send 
5994			 
5994					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5994 cd b9 22			call macro_dsp_valuehl 
5997				endm 
# End of macro FORTH_DSP_VALUEHL
5997			 
5997			;		push hl    ; u1  
5997			 
5997					; destroy value TOS 
5997			 
5997					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5997 cd 71 23			call macro_forth_dsp_pop 
599a				endm 
# End of macro FORTH_DSP_POP
599a			 
599a					; one value on hl get other one back 
599a			 
599a			;		pop hl   ; u2 - addr 
599a			 
599a					; TODO Send SPI byte 
599a			 
599a			;		push hl 
599a			;		call spi_ce_low 
599a			;		pop hl 
599a 7d					ld a, l 
599b cd b8 00				call spi_send_byte 
599e			;		call spi_ce_high 
599e			 
599e					NEXTW 
599e c3 6f 24			jp macro_next 
59a1				endm 
# End of macro NEXTW
59a1			 
59a1			.SPII: 
59a1				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
59a1 52				db WORD_SYS_CORE+62             
59a2 0a 5a			dw .SESEL            
59a4 06				db 5 + 1 
59a5 .. 00			db "SPII",0              
59aa				endm 
# End of macro CWHEAD
59aa			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
59aa					if DEBUG_FORTH_WORDS_KEY 
59aa						DMARK "SPi" 
59aa f5				push af  
59ab 3a bf 59			ld a, (.dmark)  
59ae 32 6b fe			ld (debug_mark),a  
59b1 3a c0 59			ld a, (.dmark+1)  
59b4 32 6c fe			ld (debug_mark+1),a  
59b7 3a c1 59			ld a, (.dmark+2)  
59ba 32 6d fe			ld (debug_mark+2),a  
59bd 18 03			jr .pastdmark  
59bf ..			.dmark: db "SPi"  
59c2 f1			.pastdmark: pop af  
59c3			endm  
# End of macro DMARK
59c3						CALLMONITOR 
59c3 cd 6f fe			call debug_vector  
59c6				endm  
# End of macro CALLMONITOR
59c6					endif 
59c6			 
59c6					; TODO Get SPI byte 
59c6			 
59c6 cd df 00				call spi_read_byte 
59c9			 
59c9					if DEBUG_FORTH_WORDS 
59c9						DMARK "Si2" 
59c9 f5				push af  
59ca 3a de 59			ld a, (.dmark)  
59cd 32 6b fe			ld (debug_mark),a  
59d0 3a df 59			ld a, (.dmark+1)  
59d3 32 6c fe			ld (debug_mark+1),a  
59d6 3a e0 59			ld a, (.dmark+2)  
59d9 32 6d fe			ld (debug_mark+2),a  
59dc 18 03			jr .pastdmark  
59de ..			.dmark: db "Si2"  
59e1 f1			.pastdmark: pop af  
59e2			endm  
# End of macro DMARK
59e2						CALLMONITOR 
59e2 cd 6f fe			call debug_vector  
59e5				endm  
# End of macro CALLMONITOR
59e5					endif 
59e5 26 00				ld h, 0 
59e7 6f					ld l, a 
59e8					if DEBUG_FORTH_WORDS 
59e8						DMARK "Si3" 
59e8 f5				push af  
59e9 3a fd 59			ld a, (.dmark)  
59ec 32 6b fe			ld (debug_mark),a  
59ef 3a fe 59			ld a, (.dmark+1)  
59f2 32 6c fe			ld (debug_mark+1),a  
59f5 3a ff 59			ld a, (.dmark+2)  
59f8 32 6d fe			ld (debug_mark+2),a  
59fb 18 03			jr .pastdmark  
59fd ..			.dmark: db "Si3"  
5a00 f1			.pastdmark: pop af  
5a01			endm  
# End of macro DMARK
5a01						CALLMONITOR 
5a01 cd 6f fe			call debug_vector  
5a04				endm  
# End of macro CALLMONITOR
5a04					endif 
5a04 cd c2 20				call forth_push_numhl 
5a07			 
5a07					NEXTW 
5a07 c3 6f 24			jp macro_next 
5a0a				endm 
# End of macro NEXTW
5a0a			 
5a0a			 
5a0a			 
5a0a			.SESEL: 
5a0a				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5a0a 66				db WORD_SYS_CORE+82             
5a0b b3 5a			dw .CARTDEV            
5a0d 05				db 4 + 1 
5a0e .. 00			db "BANK",0              
5a13				endm 
# End of macro CWHEAD
5a13			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5a13					if DEBUG_FORTH_WORDS_KEY 
5a13						DMARK "BNK" 
5a13 f5				push af  
5a14 3a 28 5a			ld a, (.dmark)  
5a17 32 6b fe			ld (debug_mark),a  
5a1a 3a 29 5a			ld a, (.dmark+1)  
5a1d 32 6c fe			ld (debug_mark+1),a  
5a20 3a 2a 5a			ld a, (.dmark+2)  
5a23 32 6d fe			ld (debug_mark+2),a  
5a26 18 03			jr .pastdmark  
5a28 ..			.dmark: db "BNK"  
5a2b f1			.pastdmark: pop af  
5a2c			endm  
# End of macro DMARK
5a2c						CALLMONITOR 
5a2c cd 6f fe			call debug_vector  
5a2f				endm  
# End of macro CALLMONITOR
5a2f					endif 
5a2f			 
5a2f 3e ff				ld a, 255 
5a31 32 63 fa				ld (spi_cartdev), a 
5a34			 
5a34					; get bank 
5a34			 
5a34					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a34 cd b9 22			call macro_dsp_valuehl 
5a37				endm 
# End of macro FORTH_DSP_VALUEHL
5a37			 
5a37			;		push hl 
5a37			 
5a37					; destroy value TOS 
5a37			 
5a37					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a37 cd 71 23			call macro_forth_dsp_pop 
5a3a				endm 
# End of macro FORTH_DSP_POP
5a3a			 
5a3a					; one value on hl get other one back 
5a3a			 
5a3a			;		pop hl 
5a3a			 
5a3a			 
5a3a 0e ff				ld c, SPI_CE_HIGH 
5a3c 06 30				ld b, '0'    ; human readable bank number 
5a3e			 
5a3e 7d					ld a, l 
5a3f			 
5a3f					if DEBUG_FORTH_WORDS 
5a3f						DMARK "BNK" 
5a3f f5				push af  
5a40 3a 54 5a			ld a, (.dmark)  
5a43 32 6b fe			ld (debug_mark),a  
5a46 3a 55 5a			ld a, (.dmark+1)  
5a49 32 6c fe			ld (debug_mark+1),a  
5a4c 3a 56 5a			ld a, (.dmark+2)  
5a4f 32 6d fe			ld (debug_mark+2),a  
5a52 18 03			jr .pastdmark  
5a54 ..			.dmark: db "BNK"  
5a57 f1			.pastdmark: pop af  
5a58			endm  
# End of macro DMARK
5a58						CALLMONITOR 
5a58 cd 6f fe			call debug_vector  
5a5b				endm  
# End of macro CALLMONITOR
5a5b					endif 
5a5b			 
5a5b					; active low 
5a5b			 
5a5b fe 00				cp 0 
5a5d 28 28				jr z, .bset 
5a5f fe 01				cp 1 
5a61 20 04				jr nz, .b2 
5a63 cb 81				res 0, c 
5a65 06 31				ld b, '1'    ; human readable bank number 
5a67 fe 02		.b2:		cp 2 
5a69 20 04				jr nz, .b3 
5a6b cb 89				res 1, c 
5a6d 06 32				ld b, '2'    ; human readable bank number 
5a6f fe 03		.b3:		cp 3 
5a71 20 04				jr nz, .b4 
5a73 cb 91				res 2, c 
5a75 06 33				ld b, '3'    ; human readable bank number 
5a77 fe 04		.b4:		cp 4 
5a79 20 04				jr nz, .b5 
5a7b cb 99				res 3, c 
5a7d 06 34				ld b, '4'    ; human readable bank number 
5a7f fe 05		.b5:		cp 5 
5a81 20 04				jr nz, .bset 
5a83 cb a1				res 4, c 
5a85 06 35				ld b, '5'    ; human readable bank number 
5a87			 
5a87			.bset: 
5a87 79					ld a, c 
5a88 32 60 fa				ld (spi_device),a 
5a8b 78					ld a, b 
5a8c 32 5f fa				ld (spi_device_id),a 
5a8f					if DEBUG_FORTH_WORDS 
5a8f						DMARK "BN2" 
5a8f f5				push af  
5a90 3a a4 5a			ld a, (.dmark)  
5a93 32 6b fe			ld (debug_mark),a  
5a96 3a a5 5a			ld a, (.dmark+1)  
5a99 32 6c fe			ld (debug_mark+1),a  
5a9c 3a a6 5a			ld a, (.dmark+2)  
5a9f 32 6d fe			ld (debug_mark+2),a  
5aa2 18 03			jr .pastdmark  
5aa4 ..			.dmark: db "BN2"  
5aa7 f1			.pastdmark: pop af  
5aa8			endm  
# End of macro DMARK
5aa8						CALLMONITOR 
5aa8 cd 6f fe			call debug_vector  
5aab				endm  
# End of macro CALLMONITOR
5aab					endif 
5aab			 
5aab					; set default SPI clk pulse time as disabled for BANK use 
5aab			 
5aab 3e 00				ld a, 0 
5aad 32 64 fa				ld (spi_clktime), a 
5ab0			 
5ab0					NEXTW 
5ab0 c3 6f 24			jp macro_next 
5ab3				endm 
# End of macro NEXTW
5ab3			 
5ab3			.CARTDEV: 
5ab3				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5ab3 66				db WORD_SYS_CORE+82             
5ab4 61 5b			dw .ENDDEVICE            
5ab6 08				db 7 + 1 
5ab7 .. 00			db "CARTDEV",0              
5abf				endm 
# End of macro CWHEAD
5abf			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5abf					if DEBUG_FORTH_WORDS_KEY 
5abf						DMARK "CDV" 
5abf f5				push af  
5ac0 3a d4 5a			ld a, (.dmark)  
5ac3 32 6b fe			ld (debug_mark),a  
5ac6 3a d5 5a			ld a, (.dmark+1)  
5ac9 32 6c fe			ld (debug_mark+1),a  
5acc 3a d6 5a			ld a, (.dmark+2)  
5acf 32 6d fe			ld (debug_mark+2),a  
5ad2 18 03			jr .pastdmark  
5ad4 ..			.dmark: db "CDV"  
5ad7 f1			.pastdmark: pop af  
5ad8			endm  
# End of macro DMARK
5ad8						CALLMONITOR 
5ad8 cd 6f fe			call debug_vector  
5adb				endm  
# End of macro CALLMONITOR
5adb					endif 
5adb			 
5adb					; disable se storage bank selection 
5adb			 
5adb 3e ff				ld a, SPI_CE_HIGH		; ce high 
5add 32 60 fa				ld (spi_device), a 
5ae0			 
5ae0					; get bank 
5ae0			 
5ae0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ae0 cd b9 22			call macro_dsp_valuehl 
5ae3				endm 
# End of macro FORTH_DSP_VALUEHL
5ae3			 
5ae3			;		push hl 
5ae3			 
5ae3					; destroy value TOS 
5ae3			 
5ae3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ae3 cd 71 23			call macro_forth_dsp_pop 
5ae6				endm 
# End of macro FORTH_DSP_POP
5ae6			 
5ae6					; one value on hl get other one back 
5ae6			 
5ae6			;		pop hl 
5ae6			 
5ae6					; active low 
5ae6			 
5ae6 0e ff				ld c, 255 
5ae8			 
5ae8 7d					ld a, l 
5ae9					if DEBUG_FORTH_WORDS 
5ae9						DMARK "CDV" 
5ae9 f5				push af  
5aea 3a fe 5a			ld a, (.dmark)  
5aed 32 6b fe			ld (debug_mark),a  
5af0 3a ff 5a			ld a, (.dmark+1)  
5af3 32 6c fe			ld (debug_mark+1),a  
5af6 3a 00 5b			ld a, (.dmark+2)  
5af9 32 6d fe			ld (debug_mark+2),a  
5afc 18 03			jr .pastdmark  
5afe ..			.dmark: db "CDV"  
5b01 f1			.pastdmark: pop af  
5b02			endm  
# End of macro DMARK
5b02						CALLMONITOR 
5b02 cd 6f fe			call debug_vector  
5b05				endm  
# End of macro CALLMONITOR
5b05					endif 
5b05 fe 00				cp 0 
5b07 28 30				jr z, .cset 
5b09 fe 01				cp 1 
5b0b 20 02				jr nz, .c2 
5b0d cb 81				res 0, c 
5b0f fe 02		.c2:		cp 2 
5b11 20 02				jr nz, .c3 
5b13 cb 89				res 1, c 
5b15 fe 03		.c3:		cp 3 
5b17 20 02				jr nz, .c4 
5b19 cb 91				res 2, c 
5b1b fe 04		.c4:		cp 4 
5b1d 20 02				jr nz, .c5 
5b1f cb 99				res 3, c 
5b21 fe 05		.c5:		cp 5 
5b23 20 02				jr nz, .c6 
5b25 cb a1				res 4, c 
5b27 fe 06		.c6:		cp 6 
5b29 20 02				jr nz, .c7 
5b2b cb a9				res 5, c 
5b2d fe 07		.c7:		cp 7 
5b2f 20 02				jr nz, .c8 
5b31 cb b1				res 6, c 
5b33 fe 08		.c8:		cp 8 
5b35 20 02				jr nz, .cset 
5b37 cb b9				res 7, c 
5b39 79			.cset:		ld a, c 
5b3a 32 63 fa				ld (spi_cartdev),a 
5b3d			 
5b3d					if DEBUG_FORTH_WORDS 
5b3d						DMARK "CD2" 
5b3d f5				push af  
5b3e 3a 52 5b			ld a, (.dmark)  
5b41 32 6b fe			ld (debug_mark),a  
5b44 3a 53 5b			ld a, (.dmark+1)  
5b47 32 6c fe			ld (debug_mark+1),a  
5b4a 3a 54 5b			ld a, (.dmark+2)  
5b4d 32 6d fe			ld (debug_mark+2),a  
5b50 18 03			jr .pastdmark  
5b52 ..			.dmark: db "CD2"  
5b55 f1			.pastdmark: pop af  
5b56			endm  
# End of macro DMARK
5b56						CALLMONITOR 
5b56 cd 6f fe			call debug_vector  
5b59				endm  
# End of macro CALLMONITOR
5b59					endif 
5b59			 
5b59					; set default SPI clk pulse time as 10ms for CARTDEV use 
5b59			 
5b59 3e 0a				ld a, $0a 
5b5b 32 64 fa				ld (spi_clktime), a 
5b5e					NEXTW 
5b5e c3 6f 24			jp macro_next 
5b61				endm 
# End of macro NEXTW
5b61			endif 
5b61			 
5b61			.ENDDEVICE: 
5b61			; eof 
5b61			 
# End of file forth_words_device.asm
5b61			 
5b61			; var handler 
5b61			 
5b61			 
5b61			.VARS: 
5b61				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5b61 77				db WORD_SYS_CORE+99             
5b62 12 5c			dw .V0            
5b64 04				db 3 + 1 
5b65 .. 00			db "VAR",0              
5b69				endm 
# End of macro CWHEAD
5b69			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5b69			;| 
5b69			;| The variable name should consist of a single letter. e.g. "a" 
5b69			;! If a full string is passed then only the first char is looked at 
5b69			;| Any other char could exceed bounds checks!  
5b69			 
5b69					if DEBUG_FORTH_WORDS_KEY 
5b69						DMARK "VAR" 
5b69 f5				push af  
5b6a 3a 7e 5b			ld a, (.dmark)  
5b6d 32 6b fe			ld (debug_mark),a  
5b70 3a 7f 5b			ld a, (.dmark+1)  
5b73 32 6c fe			ld (debug_mark+1),a  
5b76 3a 80 5b			ld a, (.dmark+2)  
5b79 32 6d fe			ld (debug_mark+2),a  
5b7c 18 03			jr .pastdmark  
5b7e ..			.dmark: db "VAR"  
5b81 f1			.pastdmark: pop af  
5b82			endm  
# End of macro DMARK
5b82						CALLMONITOR 
5b82 cd 6f fe			call debug_vector  
5b85				endm  
# End of macro CALLMONITOR
5b85					endif 
5b85			 
5b85					FORTH_DSP_VALUEHL 
5b85 cd b9 22			call macro_dsp_valuehl 
5b88				endm 
# End of macro FORTH_DSP_VALUEHL
5b88			 
5b88 7e					ld a, (hl)    ; get first char on of the string 
5b89			 
5b89			 
5b89					if DEBUG_FORTH_WORDS 
5b89						DMARK "VR1" 
5b89 f5				push af  
5b8a 3a 9e 5b			ld a, (.dmark)  
5b8d 32 6b fe			ld (debug_mark),a  
5b90 3a 9f 5b			ld a, (.dmark+1)  
5b93 32 6c fe			ld (debug_mark+1),a  
5b96 3a a0 5b			ld a, (.dmark+2)  
5b99 32 6d fe			ld (debug_mark+2),a  
5b9c 18 03			jr .pastdmark  
5b9e ..			.dmark: db "VR1"  
5ba1 f1			.pastdmark: pop af  
5ba2			endm  
# End of macro DMARK
5ba2						CALLMONITOR 
5ba2 cd 6f fe			call debug_vector  
5ba5				endm  
# End of macro CALLMONITOR
5ba5					endif 
5ba5					 
5ba5 f5					push af	 
5ba6					FORTH_DSP_POP 
5ba6 cd 71 23			call macro_forth_dsp_pop 
5ba9				endm 
# End of macro FORTH_DSP_POP
5ba9 f1					pop af 
5baa			 
5baa					; convert to upper 
5baa			 
5baa cd f3 12				call to_upper 
5bad					if DEBUG_FORTH_WORDS 
5bad						DMARK "Vaa" 
5bad f5				push af  
5bae 3a c2 5b			ld a, (.dmark)  
5bb1 32 6b fe			ld (debug_mark),a  
5bb4 3a c3 5b			ld a, (.dmark+1)  
5bb7 32 6c fe			ld (debug_mark+1),a  
5bba 3a c4 5b			ld a, (.dmark+2)  
5bbd 32 6d fe			ld (debug_mark+2),a  
5bc0 18 03			jr .pastdmark  
5bc2 ..			.dmark: db "Vaa"  
5bc5 f1			.pastdmark: pop af  
5bc6			endm  
# End of macro DMARK
5bc6						CALLMONITOR 
5bc6 cd 6f fe			call debug_vector  
5bc9				endm  
# End of macro CALLMONITOR
5bc9					endif 
5bc9 06 41				ld b, 'A' 
5bcb 90					sub b			; set offset 
5bcc					if DEBUG_FORTH_WORDS 
5bcc						DMARK "Vbb" 
5bcc f5				push af  
5bcd 3a e1 5b			ld a, (.dmark)  
5bd0 32 6b fe			ld (debug_mark),a  
5bd3 3a e2 5b			ld a, (.dmark+1)  
5bd6 32 6c fe			ld (debug_mark+1),a  
5bd9 3a e3 5b			ld a, (.dmark+2)  
5bdc 32 6d fe			ld (debug_mark+2),a  
5bdf 18 03			jr .pastdmark  
5be1 ..			.dmark: db "Vbb"  
5be4 f1			.pastdmark: pop af  
5be5			endm  
# End of macro DMARK
5be5						CALLMONITOR 
5be5 cd 6f fe			call debug_vector  
5be8				endm  
# End of macro CALLMONITOR
5be8					endif 
5be8 cb 27				sla a  
5bea				 
5bea					 
5bea					if DEBUG_FORTH_WORDS 
5bea						DMARK "VR2" 
5bea f5				push af  
5beb 3a ff 5b			ld a, (.dmark)  
5bee 32 6b fe			ld (debug_mark),a  
5bf1 3a 00 5c			ld a, (.dmark+1)  
5bf4 32 6c fe			ld (debug_mark+1),a  
5bf7 3a 01 5c			ld a, (.dmark+2)  
5bfa 32 6d fe			ld (debug_mark+2),a  
5bfd 18 03			jr .pastdmark  
5bff ..			.dmark: db "VR2"  
5c02 f1			.pastdmark: pop af  
5c03			endm  
# End of macro DMARK
5c03						CALLMONITOR 
5c03 cd 6f fe			call debug_vector  
5c06				endm  
# End of macro CALLMONITOR
5c06					endif 
5c06			 
5c06 21 f4 f9				ld hl, cli_var_array2 
5c09 cd 86 0f				call addatohl 
5c0c cd c2 20				call forth_push_numhl 
5c0f			 
5c0f			 
5c0f				       NEXTW 
5c0f c3 6f 24			jp macro_next 
5c12				endm 
# End of macro NEXTW
5c12			.V0: 
5c12				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5c12 78				db WORD_SYS_CORE+100             
5c13 2a 5c			dw .V0Q            
5c15 04				db 3 + 1 
5c16 .. 00			db "V0!",0              
5c1a				endm 
# End of macro CWHEAD
5c1a			;| V0! ( u1 -- )  Store value to v0  | DONE 
5c1a			 
5c1a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c1a cd b9 22			call macro_dsp_valuehl 
5c1d				endm 
# End of macro FORTH_DSP_VALUEHL
5c1d			 
5c1d 11 28 fa				ld de, cli_var_array 
5c20			 
5c20 eb					ex de, hl 
5c21 73					ld (hl), e 
5c22 23					inc hl 
5c23 72					ld (hl), d 
5c24			 
5c24					; destroy value TOS 
5c24			 
5c24					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c24 cd 71 23			call macro_forth_dsp_pop 
5c27				endm 
# End of macro FORTH_DSP_POP
5c27			 
5c27				       NEXTW 
5c27 c3 6f 24			jp macro_next 
5c2a				endm 
# End of macro NEXTW
5c2a			.V0Q: 
5c2a				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5c2a 79				db WORD_SYS_CORE+101             
5c2b 3b 5c			dw .V1S            
5c2d 04				db 3 + 1 
5c2e .. 00			db "V0@",0              
5c32				endm 
# End of macro CWHEAD
5c32			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5c32 2a 28 fa				ld hl, (cli_var_array) 
5c35 cd c2 20				call forth_push_numhl 
5c38			 
5c38				       NEXTW 
5c38 c3 6f 24			jp macro_next 
5c3b				endm 
# End of macro NEXTW
5c3b			.V1S: 
5c3b				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5c3b 7a				db WORD_SYS_CORE+102             
5c3c 53 5c			dw .V1Q            
5c3e 04				db 3 + 1 
5c3f .. 00			db "V1!",0              
5c43				endm 
# End of macro CWHEAD
5c43			;| V1! ( u1 -- )  Store value to v1 | DONE 
5c43					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c43 cd b9 22			call macro_dsp_valuehl 
5c46				endm 
# End of macro FORTH_DSP_VALUEHL
5c46			 
5c46 11 2a fa				ld de, cli_var_array+2 
5c49				 
5c49 eb					ex de, hl 
5c4a 73					ld (hl), e 
5c4b 23					inc hl 
5c4c 72					ld (hl), d 
5c4d			 
5c4d					; destroy value TOS 
5c4d			 
5c4d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c4d cd 71 23			call macro_forth_dsp_pop 
5c50				endm 
# End of macro FORTH_DSP_POP
5c50				       NEXTW 
5c50 c3 6f 24			jp macro_next 
5c53				endm 
# End of macro NEXTW
5c53			.V1Q: 
5c53				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5c53 7b				db WORD_SYS_CORE+103             
5c54 64 5c			dw .V2S            
5c56 04				db 3 + 1 
5c57 .. 00			db "V1@",0              
5c5b				endm 
# End of macro CWHEAD
5c5b			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5c5b 2a 2a fa				ld hl, (cli_var_array+2) 
5c5e cd c2 20				call forth_push_numhl 
5c61				       NEXTW 
5c61 c3 6f 24			jp macro_next 
5c64				endm 
# End of macro NEXTW
5c64			.V2S: 
5c64				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5c64 7c				db WORD_SYS_CORE+104             
5c65 7c 5c			dw .V2Q            
5c67 04				db 3 + 1 
5c68 .. 00			db "V2!",0              
5c6c				endm 
# End of macro CWHEAD
5c6c			;| V2! ( u1 -- )  Store value to v2 | DONE 
5c6c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c6c cd b9 22			call macro_dsp_valuehl 
5c6f				endm 
# End of macro FORTH_DSP_VALUEHL
5c6f			 
5c6f 11 2c fa				ld de, cli_var_array+4 
5c72				 
5c72 eb					ex de, hl 
5c73 73					ld (hl), e 
5c74 23					inc hl 
5c75 72					ld (hl), d 
5c76			 
5c76					; destroy value TOS 
5c76			 
5c76					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c76 cd 71 23			call macro_forth_dsp_pop 
5c79				endm 
# End of macro FORTH_DSP_POP
5c79				       NEXTW 
5c79 c3 6f 24			jp macro_next 
5c7c				endm 
# End of macro NEXTW
5c7c			.V2Q: 
5c7c				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5c7c 7d				db WORD_SYS_CORE+105             
5c7d 8d 5c			dw .V3S            
5c7f 04				db 3 + 1 
5c80 .. 00			db "V2@",0              
5c84				endm 
# End of macro CWHEAD
5c84			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5c84 2a 2c fa				ld hl, (cli_var_array+4) 
5c87 cd c2 20				call forth_push_numhl 
5c8a				       NEXTW 
5c8a c3 6f 24			jp macro_next 
5c8d				endm 
# End of macro NEXTW
5c8d			.V3S: 
5c8d				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5c8d 7c				db WORD_SYS_CORE+104             
5c8e a5 5c			dw .V3Q            
5c90 04				db 3 + 1 
5c91 .. 00			db "V3!",0              
5c95				endm 
# End of macro CWHEAD
5c95			;| V3! ( u1 -- )  Store value to v3 | DONE 
5c95					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c95 cd b9 22			call macro_dsp_valuehl 
5c98				endm 
# End of macro FORTH_DSP_VALUEHL
5c98			 
5c98 11 2e fa				ld de, cli_var_array+6 
5c9b				 
5c9b eb					ex de, hl 
5c9c 73					ld (hl), e 
5c9d 23					inc hl 
5c9e 72					ld (hl), d 
5c9f			 
5c9f					; destroy value TOS 
5c9f			 
5c9f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c9f cd 71 23			call macro_forth_dsp_pop 
5ca2				endm 
# End of macro FORTH_DSP_POP
5ca2				       NEXTW 
5ca2 c3 6f 24			jp macro_next 
5ca5				endm 
# End of macro NEXTW
5ca5			.V3Q: 
5ca5				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5ca5 7d				db WORD_SYS_CORE+105             
5ca6 b6 5c			dw .END            
5ca8 04				db 3 + 1 
5ca9 .. 00			db "V3@",0              
5cad				endm 
# End of macro CWHEAD
5cad			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5cad 2a 2e fa				ld hl, (cli_var_array+6) 
5cb0 cd c2 20				call forth_push_numhl 
5cb3				       NEXTW 
5cb3 c3 6f 24			jp macro_next 
5cb6				endm 
# End of macro NEXTW
5cb6			 
5cb6			 
5cb6			 
5cb6			 
5cb6			 
5cb6			; end of dict marker 
5cb6			 
5cb6 00			.END:    db WORD_SYS_END 
5cb7 00 00			dw 0 
5cb9 00				db 0 
5cba			 
5cba			; use to jp here for user dict words to save on macro expansion  
5cba			 
5cba			user_dict_next: 
5cba				NEXTW 
5cba c3 6f 24			jp macro_next 
5cbd				endm 
# End of macro NEXTW
5cbd			 
5cbd			 
5cbd			user_exec: 
5cbd				;    ld hl, <word code> 
5cbd				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5cbd				;    call forthexec 
5cbd				;    jp user_dict_next   (NEXT) 
5cbd			        ;    <word code bytes> 
5cbd eb				ex de, hl 
5cbe 2a c2 f4			ld hl,(os_tok_ptr) 
5cc1				 
5cc1				FORTH_RSP_NEXT 
5cc1 cd 69 20			call macro_forth_rsp_next 
5cc4				endm 
# End of macro FORTH_RSP_NEXT
5cc4			 
5cc4			if DEBUG_FORTH_UWORD 
5cc4						DMARK "UEX" 
5cc4 f5				push af  
5cc5 3a d9 5c			ld a, (.dmark)  
5cc8 32 6b fe			ld (debug_mark),a  
5ccb 3a da 5c			ld a, (.dmark+1)  
5cce 32 6c fe			ld (debug_mark+1),a  
5cd1 3a db 5c			ld a, (.dmark+2)  
5cd4 32 6d fe			ld (debug_mark+2),a  
5cd7 18 03			jr .pastdmark  
5cd9 ..			.dmark: db "UEX"  
5cdc f1			.pastdmark: pop af  
5cdd			endm  
# End of macro DMARK
5cdd				CALLMONITOR 
5cdd cd 6f fe			call debug_vector  
5ce0				endm  
# End of macro CALLMONITOR
5ce0			endif 
5ce0			 
5ce0			 
5ce0			 
5ce0 eb				ex de, hl 
5ce1 22 c2 f4			ld (os_tok_ptr), hl 
5ce4				 
5ce4				; Don't use next - Skips the first word in uword. 
5ce4			 
5ce4 c3 00 25			jp exec1 
5ce7			;	NEXT 
5ce7			 
5ce7			 
5ce7			; eof 
# End of file forth_wordsv4.asm
5ce7			endif 
5ce7			;;;;;;;;;;;;;; Debug code 
5ce7			 
5ce7			 
5ce7			;if DEBUG_FORTH_PARSE 
5ce7 .. 00		.nowordfound: db "No match",0 
5cf0 .. 00		.compword:	db "Comparing word ",0 
5d00 .. 00		.nextwordat:	db "Next word at",0 
5d0d .. 00		.charmatch:	db "Char match",0 
5d18			;endif 
5d18			if DEBUG_FORTH_JP 
5d18			.foundword:	db "Word match. Exec..",0 
5d18			endif 
5d18			;if DEBUG_FORTH_PUSH 
5d18 .. 00		.enddict:	db "Dict end. Push.",0 
5d28 .. 00		.push_str:	db "Pushing string",0 
5d37 .. 00		.push_num:	db "Pushing number",0 
5d46 .. 00		.data_sp:	db "SP:",0 
5d4a .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5d5c .. 00		.wordinde:	db "Word in DE (3/0):",0 
5d6e .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5d80			;endif 
5d80			;if DEBUG_FORTH_MALLOC 
5d80 .. 00		.push_malloc:	db "Malloc address",0 
5d8f			;endif 
5d8f			 
5d8f			 
5d8f			 
5d8f			; display malloc address and current data stack pointer  
5d8f			 
5d8f			malloc_error: 
5d8f d5				push de 
5d90 f5				push af 
5d91 e5				push hl 
5d92 cd 52 0d			call clear_display 
5d95 11 b5 5d			ld de, .mallocerr 
5d98 3e 00			ld a,0 
5d9a			;	ld de,os_word_scratch 
5d9a cd 65 0d			call str_at_display 
5d9d 3e 11			ld a, display_row_1+17 
5d9f 11 6b fe			ld de, debug_mark 
5da2 cd 65 0d			call str_at_display 
5da5 cd 75 0d			call update_display 
5da8				;call break_point_state 
5da8 cd 90 78			call cin_wait 
5dab			 
5dab			;	ld a, ' ' 
5dab			;	ld (os_view_disable), a 
5dab cd f1 19			call bp_on 
5dae e1				pop hl 
5daf f1				pop af 
5db0 d1				pop de	 
5db1				CALLMONITOR 
5db1 cd 6f fe			call debug_vector  
5db4				endm  
# End of macro CALLMONITOR
5db4 c9				ret 
5db5			 
5db5 .. 00		.mallocerr: 	db "Malloc Error",0 
5dc2			;if DEBUG_FORTH_PUSH 
5dc2			display_data_sp: 
5dc2 f5				push af 
5dc3			 
5dc3				; see if disabled 
5dc3			 
5dc3			 
5dc3 3a 6f fe			ld a, (debug_vector) 
5dc6 fe c9			cp $C9  ; RET 
5dc8				;ld a, (os_view_disable) 
5dc8				;cp '*' 
5dc8 28 67			jr z, .skipdsp 
5dca			 
5dca e5				push hl 
5dcb e5				push hl 
5dcc e5			push hl 
5dcd cd 52 0d			call clear_display 
5dd0 e1			pop hl 
5dd1 7c				ld a,h 
5dd2 21 c6 f4			ld hl, os_word_scratch 
5dd5 cd 87 12			call hexout 
5dd8 e1				pop hl 
5dd9 7d				ld a,l 
5dda 21 c8 f4			ld hl, os_word_scratch+2 
5ddd cd 87 12			call hexout 
5de0 21 ca f4			ld hl, os_word_scratch+4 
5de3 3e 00			ld a,0 
5de5 77				ld (hl),a 
5de6 11 c6 f4			ld de,os_word_scratch 
5de9 3e 28				ld a, display_row_2 
5deb cd 65 0d				call str_at_display 
5dee 11 4a 5d			ld de, .wordinhl 
5df1 3e 00			ld a, display_row_1 
5df3			 
5df3 cd 65 0d				call str_at_display 
5df6 11 6b fe			ld de, debug_mark 
5df9 3e 11			ld a, display_row_1+17 
5dfb			 
5dfb cd 65 0d				call str_at_display 
5dfe			 
5dfe				; display current data stack pointer 
5dfe 11 46 5d			ld de,.data_sp 
5e01 3e 30				ld a, display_row_2 + 8 
5e03 cd 65 0d				call str_at_display 
5e06			 
5e06 2a ee f9			ld hl,(cli_data_sp) 
5e09 e5				push hl 
5e0a 7c				ld a,h 
5e0b 21 c6 f4			ld hl, os_word_scratch 
5e0e cd 87 12			call hexout 
5e11 e1				pop hl 
5e12 7d				ld a,l 
5e13 21 c8 f4			ld hl, os_word_scratch+2 
5e16 cd 87 12			call hexout 
5e19 21 ca f4			ld hl, os_word_scratch+4 
5e1c 3e 00			ld a,0 
5e1e 77				ld (hl),a 
5e1f 11 c6 f4			ld de,os_word_scratch 
5e22 3e 33				ld a, display_row_2 + 11 
5e24 cd 65 0d				call str_at_display 
5e27			 
5e27			 
5e27 cd 75 0d			call update_display 
5e2a cd 95 0c			call delay1s 
5e2d cd 95 0c			call delay1s 
5e30 e1				pop hl 
5e31			.skipdsp: 
5e31 f1				pop af 
5e32 c9				ret 
5e33			 
5e33			display_data_malloc: 
5e33			 
5e33 f5				push af 
5e34 e5				push hl 
5e35 e5				push hl 
5e36 e5			push hl 
5e37 cd 52 0d			call clear_display 
5e3a e1			pop hl 
5e3b 7c				ld a,h 
5e3c 21 c6 f4			ld hl, os_word_scratch 
5e3f cd 87 12			call hexout 
5e42 e1				pop hl 
5e43 7d				ld a,l 
5e44 21 c8 f4			ld hl, os_word_scratch+2 
5e47 cd 87 12			call hexout 
5e4a 21 ca f4			ld hl, os_word_scratch+4 
5e4d 3e 00			ld a,0 
5e4f 77				ld (hl),a 
5e50 11 c6 f4			ld de,os_word_scratch 
5e53 3e 28				ld a, display_row_2 
5e55 cd 65 0d				call str_at_display 
5e58 11 80 5d			ld de, .push_malloc 
5e5b 3e 00			ld a, display_row_1 
5e5d			 
5e5d cd 65 0d				call str_at_display 
5e60			 
5e60				; display current data stack pointer 
5e60 11 46 5d			ld de,.data_sp 
5e63 3e 30				ld a, display_row_2 + 8 
5e65 cd 65 0d				call str_at_display 
5e68			 
5e68 2a ee f9			ld hl,(cli_data_sp) 
5e6b e5				push hl 
5e6c 7c				ld a,h 
5e6d 21 c6 f4			ld hl, os_word_scratch 
5e70 cd 87 12			call hexout 
5e73 e1				pop hl 
5e74 7d				ld a,l 
5e75 21 c8 f4			ld hl, os_word_scratch+2 
5e78 cd 87 12			call hexout 
5e7b 21 ca f4			ld hl, os_word_scratch+4 
5e7e 3e 00			ld a,0 
5e80 77				ld (hl),a 
5e81 11 c6 f4			ld de,os_word_scratch 
5e84 3e 33				ld a, display_row_2 + 11 
5e86 cd 65 0d				call str_at_display 
5e89			 
5e89 cd 75 0d			call update_display 
5e8c cd 95 0c			call delay1s 
5e8f cd 95 0c			call delay1s 
5e92 e1				pop hl 
5e93 f1				pop af 
5e94 c9				ret 
5e95			;endif 
5e95			 
5e95			include "forth_autostart.asm" 
5e95			; list of commands to perform at system start up 
5e95			 
5e95			startcmds: 
5e95			;	dw test11 
5e95			;	dw test12 
5e95			;	dw test13 
5e95			;	dw test14 
5e95			;	dw test15 
5e95			;	dw test16 
5e95			;	dw test17 
5e95			;	dw ifthtest1 
5e95			;	dw ifthtest2 
5e95			;	dw ifthtest3 
5e95			;	dw mmtest1 
5e95			;	dw mmtest2 
5e95			;	dw mmtest3 
5e95			;	dw mmtest4 
5e95			;	dw mmtest5 
5e95			;	dw mmtest6 
5e95			;	dw iftest1 
5e95			;	dw iftest2 
5e95			;	dw iftest3 
5e95			;	dw looptest1 
5e95			;	dw looptest2 
5e95			;	dw test1 
5e95			;	dw test2 
5e95			;	dw test3 
5e95			;	dw test4 
5e95			;	dw game2r 
5e95			;	dw game2b1 
5e95			;	dw game2b2 
5e95			 
5e95				; start up words that are actually useful 
5e95			 
5e95 9d 5f		    dw spi1 
5e97 f6 5f		    dw spi2 
5e99 84 60		    dw spi3 
5e9b 2c 60		    dw spi4 
5e9d 57 60		    dw spi5 
5e9f ea 60		    dw spi6 
5ea1 3f 61		    dw spi7 
5ea3			 
5ea3 97 61		    dw spi8 
5ea5 b6 61		    dw spi9 
5ea7 0e 62		    dw spi10 
5ea9			 
5ea9			; file editor 
5ea9 0f 5f			dw edit1 
5eab 30 5f			dw edit2 
5ead 65 5f			dw edit3 
5eaf			 
5eaf 81 62			dw longread 
5eb1 c8 62			dw clrstack 
5eb3 fb 62			dw type 
5eb5 e6 64			dw stest 
5eb7 1f 63			dw strncpy 
5eb9 7c 64			dw list 
5ebb 80 63			dw start1 
5ebd 90 63			dw start2 
5ebf			;	dw start3 
5ebf a1 63			dw start3b 
5ec1 1c 64			dw start3c 
5ec3			 
5ec3				; (unit) testing words 
5ec3			 
5ec3 5d 65			dw mtesta 
5ec5 12 66			dw mtestb 
5ec7 b5 66			dw mtestc 
5ec9 6a 67			dw mtestd 
5ecb 0e 68			dw mteste 
5ecd			 
5ecd				; demo/game words 
5ecd			 
5ecd 1a 6f		        dw game3w 
5ecf 48 6f		        dw game3p 
5ed1 66 6f		        dw game3sc 
5ed3 97 6f		        dw game3vsi 
5ed5 c3 6f		        dw game3vs 
5ed7				 
5ed7 0d 6d			dw game2b 
5ed9 7b 6d			dw game2bf 
5edb c5 6d			dw game2mba 
5edd 5b 6e			dw game2mbas 
5edf 9d 6e			dw game2mb 
5ee1			 
5ee1 ce 69			dw game1 
5ee3 df 69			dw game1a 
5ee5 41 6a			dw game1b 
5ee7 76 6a			dw game1c 
5ee9 ac 6a			dw game1d 
5eeb dd 6a			dw game1s 
5eed f1 6a			dw game1t 
5eef 06 6b			dw game1f 
5ef1 3a 6b			dw game1z 
5ef3 7e 6b			dw game1zz 
5ef5			 
5ef5 c4 68			dw test5 
5ef7 fc 68			dw test6 
5ef9 34 69			dw test7 
5efb 48 69			dw test8 
5efd 74 69			dw test9 
5eff 8a 69			dw test10 
5f01				 
5f01 55 6c		        dw ssv5 
5f03 39 6c		        dw ssv4 
5f05 1d 6c		        dw ssv3 
5f07 e7 6b		        dw ssv2 
5f09 6e 6c		        dw ssv1 
5f0b b6 6c		        dw ssv1cpm 
5f0d			;	dw keyup 
5f0d			;	dw keydown 
5f0d			;	dw keyleft 
5f0d			;	dw keyright 
5f0d			;	dw 	keyf1 
5f0d			;	dw keyf2 
5f0d			;	dw keyf3 
5f0d			;	dw keyf4 
5f0d			;	dw keyf5 
5f0d			;	dw keyf6 
5f0d			;	dw keyf7 
5f0d			;	dw keyf8 
5f0d			;	dw keyf9 
5f0d			;	dw keyf10 
5f0d			;	dw keyf11 
5f0d			;	dw keyf12 
5f0d			;	dw keytab 
5f0d			;	dw keycr 
5f0d			;	dw keyhome 
5f0d			;	dw keyend 
5f0d			;	dw keybs 
5f0d 00 00			db 0, 0	 
5f0f			 
5f0f			 
5f0f			; File Editor 
5f0f			 
5f0f			; ( id - ) use 'e' to edit the displayed line 
5f0f .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5f30 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5f65			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5f65 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5f9d			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5f9d			 
5f9d			; SPI Net support words 
5f9d			 
5f9d			; v0! = node to send to 
5f9d			; ( str count - ) 
5f9d .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
5ff6			 
5ff6			; spiputchr ( char node - ) 
5ff6 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
602c			 
602c			; spigetchr ( - n ) 
602c .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
6057			 
6057			; getnode ( - n ) 
6057 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
6084			 
6084			; ( str node - )  
6084 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
60ea			; store string ( str i - ) 
60ea			 
60ea			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
60ea .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
613f			 
613f			; get string ( addr i -  )    TO FIX 
613f			 
613f .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
6197			 
6197			 
6197			; NETCHAT (TODO) 
6197			; Program to allow two nodes to chat with eachother 
6197			; 
6197			; v0 - target node 
6197			;  
6197			; accept input at 0,0 
6197			; if input is string send spitype to target node 
6197			; starting at row 2,0 , while spigetchr is not zero ->  
6197			; 
6197			; 
6197			; TODO add paging of get request 
6197			 
6197			; ( node - ) 
6197 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
61b6 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
620e .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
6281			 
6281			 
6281			; Long read of currently open file 
6281 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
62c8			 
62c8			; clear stack  
62c8			 
62c8 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
62fb			 
62fb			; type ( addr count - ) 
62fb .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
631f			 
631f			; some direct memory words 
631f			; strncpy ( len t f -- t ) 
631f			 
631f .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
6380			 
6380 .. 00		start1:     	db ": bpon $00 bp ;",0 
6390 .. 00		start2:     	db ": bpoff $01 bp ;",0 
63a1 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
641c .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
647c			 
647c			 
647c			; a handy word to list items on the stack 
647c			 
647c .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
64e6			 
64e6			 
64e6			; test stack  
64e6			; rnd8 stest 
64e6			 
64e6 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
655d			 
655d			; random malloc and free cycles 
655d			 
655d .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6612			 
6612			; fixed malloc and free cycles 
6612			 
6612 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
66b5			 
66b5			; fixed double string push and drop cycle  
66b5			 
66b5 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
676a			 
676a			; consistent fixed string push and drop cycle  
676a			 
676a .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
680e			 
680e .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
68c4			 
68c4			;test1:		db ": aa 1 2 3 ;", 0 
68c4			;test2:     	db "111 aa 888 999",0 
68c4			;test3:     	db ": bb 77 ;",0 
68c4			;test4:     	db "$02 $01 do i . loop bb",0 
68c4			 
68c4 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
68fc .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6934 .. 00		test7:     	db ": box hline vline ;",0 
6948 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
6974 .. 00		test9:     	db ": sw $01 adsp world ;",0 
698a .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
69af .. 00		test11:     	db "hello create .",0 
69be .. 00		test12:     	db "hello2 create .",0 
69ce			 
69ce			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
69ce			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
69ce			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
69ce			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
69ce			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
69ce			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
69ce			 
69ce			;iftest1:     	db "$0001 IF cls .",0 
69ce			;iftest2:     	db "$0000 IF cls .",0 
69ce			;iftest3:     	db "$0002 $0003 - IF cls .",0 
69ce			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
69ce			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
69ce			 
69ce			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
69ce			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
69ce			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
69ce			 
69ce			 
69ce			 
69ce			; a small guess the number game 
69ce			 
69ce .. 00		game1:          db ": gsn rnd8 v1! ;",0 
69df .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6a41			 
6a41 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6a76 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6aac .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6add .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6af1 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6b06 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6b3a .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6b7e			 
6b7e			; Using 'ga' save a high score across multiple runs using external storage 
6b7e			 
6b7e .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6be7			 
6be7			 
6be7			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6be7			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6be7			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6be7			 
6be7			; simple screen saver to test code memory reuse to destruction 
6be7			 
6be7 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6c1d .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6c39 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6c55 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6c6e .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6cb6 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6d0d			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6d0d			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6d0d			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6d0d			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6d0d			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6d0d			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6d0d			 
6d0d			 
6d0d			 
6d0d			; minesweeper/battleship finding game 
6d0d			; draws a game board of random ship/mine positions 
6d0d			; user enters coords to see if it hits on 
6d0d			; game ends when all are hit 
6d0d			; when hit or miss says how many may be in the area 
6d0d			 
6d0d			; setup the game board and then hide it 
6d0d .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6d7b .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6dc5			; prompt for where to target 
6dc5 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6e5b .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6e80			; TODO see if the entered coords hits or misses pushes char hit of miss 
6e80 .. 00		game2mbht:      db ": mbckht nop ;",0 
6e8f .. 00		game2mbms:      db ": mbcms nop ;",0 
6e9d			; TODO how many might be near by 
6e9d .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6f1a			 
6f1a			; Game 3 
6f1a			 
6f1a			; Vert scroller ski game - avoid the trees! 
6f1a			 
6f1a			; v0 score (ie turns) 
6f1a			; v1 player pos 
6f1a			; v2 left wall 
6f1a			; v3 right wall 
6f1a			 
6f1a			; Draw side walls randomly 
6f1a			 
6f1a .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6f48			 
6f48			; Draw player 
6f48 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6f66			 
6f66			; TODO Get Key 
6f66			 
6f66			; TODO Move left right 
6f66			 
6f66			; scroll and move walls a bit 
6f66			 
6f66 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6f97			 
6f97			; main game loop 
6f97			 
6f97 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6fc3 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
7002			 
7002			; key board defs 
7002			 
7002 .. 00		keyup:       db ": keyup $05 ;",0 
7010 .. 00		keydown:       db ": keydown $0a ;",0 
7020 .. 00		keyleft:       db ": keyleft $0b ;",0 
7030 .. 00		keyright:       db ": keyright $0c ;",0 
7041 .. 00		keyf1:       db ": keyf1 $10 ;",0 
704f .. 00		keyf2:       db ": keyf2 $11 ;",0 
705d .. 00		keyf3:       db ": keyf3 $12 ;",0 
706b .. 00		keyf4:       db ": keyf4 $13 ;",0 
7079 .. 00		keyf5:       db ": keyf5 $14 ;",0 
7087 .. 00		keyf6:       db ": keyf6 $15 ;",0 
7095 .. 00		keyf7:       db ": keyf7 $16 ;",0 
70a3 .. 00		keyf8:       db ": keyf8 $17 ;",0 
70b1 .. 00		keyf9:       db ": keyf9 $18 ;",0 
70bf .. 00		keyf10:       db ": keyf10 $19 ;",0 
70ce .. 00		keyf11:       db ": keyf11 $1a ;",0 
70dd .. 00		keyf12:       db ": keyf12 $1b ;",0 
70ec			 
70ec .. 00		keytab:       db ": keytab $09 ;",0 
70fb .. 00		keycr:       db ": keycr $0d ;",0 
7109 .. 00		keyhome:       db ": keyhome $0e ;",0 
7119 .. 00		keyend:       db ": keyend $0f ;",0 
7128 .. 00		keybs:       db ": keybs $08 ;",0 
7136			 
7136			   
7136			 
7136			 
7136			 
7136			; eof 
# End of file forth_autostart.asm
7136			 
7136			 
7136			 
7136			; stack over and underflow checks 
7136			 
7136			; init the words to detect the under/overflow 
7136			 
7136			chk_stk_init: 
7136				; a vague random number to check so we dont get any "lucky" hits 
7136 3e 2d			ld a, 45 
7138 6f				ld l, a 
7139 00				nop 
713a 3e 17			ld a, 23 
713c 67				ld h, a 
713d			 
713d 22 a9 f1			ld (chk_word), hl     ; the word we need to check against 
7140			 
7140			;	ld (chk_stund), hl	; stack points.... 
7140 22 fd fe			ld (chk_stovr), hl 
7143 22 ec f9			ld (chk_ret_und), hl 
7146 22 aa f9			ld (chk_ret_ovr), hl 
7149 22 28 f9			ld (chk_loop_ovr), hl 
714c 22 26 f7			ld (chk_data_ovr), hl 
714f c9				ret 
7150				 
7150			check_stacks: 
7150				; check all stack words 
7150			 
7150 e5				push hl 
7151 d5				push de 
7152			 
7152			;	ld de,(chk_word) 
7152			;	ld hl, (chk_stund)	; stack points.... 
7152			;	if DEBUG_STK_FAULT 
7152			;		DMARK "FAa" 
7152			;		CALLMONITOR 
7152			;	endif 
7152			;	call cmp16 
7152			;	jp z, .chk_faulta 
7152			; 
7152			;	ld de, sfaultsu 
7152			;	jp .chk_fault 
7152			 
7152 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
7155 ed 5b a9 f1		ld de,(chk_word) 
7159				if DEBUG_STK_FAULT 
7159					DMARK "FAb" 
7159					CALLMONITOR 
7159				endif 
7159 cd a4 0f			call cmp16 
715c 28 06			jr z, .chk_fault1 
715e 11 ff 71			ld de, sfaultso 
7161 c3 b3 71			jp .chk_fault 
7164			.chk_fault1:  
7164 2a ec f9			ld hl, (chk_ret_und) 
7167 ed 5b a9 f1		ld de,(chk_word) 
716b				if DEBUG_STK_FAULT 
716b					DMARK "FAU" 
716b					CALLMONITOR 
716b				endif 
716b cd a4 0f			call cmp16 
716e ca 77 71			jp z, .chk_fault2 
7171 11 0f 72			ld de, sfaultru 
7174 c3 b3 71			jp .chk_fault 
7177			.chk_fault2:  
7177 2a aa f9			ld hl, (chk_ret_ovr) 
717a ed 5b a9 f1		ld de,(chk_word) 
717e				if DEBUG_STK_FAULT 
717e					DMARK "FA1" 
717e					CALLMONITOR 
717e				endif 
717e cd a4 0f			call cmp16 
7181 ca 8a 71			jp z, .chk_fault3 
7184 11 1d 72			ld de, sfaultro 
7187 c3 b3 71			jp .chk_fault 
718a			.chk_fault3:  
718a 2a 28 f9			ld hl, (chk_loop_ovr) 
718d ed 5b a9 f1		ld de,(chk_word) 
7191				if DEBUG_STK_FAULT 
7191					DMARK "FA2" 
7191					CALLMONITOR 
7191				endif 
7191 cd a4 0f			call cmp16 
7194 ca 9d 71			jp z, .chk_fault4 
7197 11 37 72			ld de, sfaultlo 
719a c3 b3 71			jp .chk_fault 
719d			.chk_fault4:  
719d 2a 26 f7			ld hl, (chk_data_ovr) 
71a0 ed 5b a9 f1		ld de,(chk_word) 
71a4				if DEBUG_STK_FAULT 
71a4					DMARK "FA3" 
71a4					CALLMONITOR 
71a4				endif 
71a4 cd a4 0f			call cmp16 
71a7 ca b0 71			jp z, .chk_fault5 
71aa 11 51 72			ld de, sfaultdo 
71ad c3 b3 71			jp .chk_fault 
71b0			 
71b0			 
71b0			.chk_fault5:  
71b0 d1				pop de 
71b1 e1				pop hl 
71b2			 
71b2 c9				ret 
71b3			 
71b3 cd 52 0d		.chk_fault: 	call clear_display 
71b6 3e 28				ld a, display_row_2 
71b8 cd 65 0d				call str_at_display 
71bb 11 e1 71				   ld de, .stackfault 
71be 3e 00				ld a, display_row_1 
71c0 cd 65 0d				call str_at_display 
71c3 11 6b fe				    ld de, debug_mark 
71c6 3e 11				ld a, display_row_1+17 
71c8 cd 65 0d				call str_at_display 
71cb cd 75 0d				call update_display 
71ce			 
71ce				; prompt before entering montior for investigating issue 
71ce			 
71ce 3e 78			ld a, display_row_4 
71d0 11 b4 1d			ld de, endprog 
71d3			 
71d3 cd 75 0d			call update_display		 
71d6			 
71d6 cd 3a 20			call next_page_prompt 
71d9			 
71d9 d1				pop de 
71da e1				pop hl 
71db cd 08 1e				call monitor 
71de c3 02 1d				jp warmstart 
71e1					;jp 0 
71e1					;halt 
71e1			 
71e1			 
71e1			 
71e1 .. 00		.stackfault: 	db "Stack fault:",0 
71ee			 
71ee .. 00		sfaultsu: 	db	"Stack under flow",0 
71ff .. 00		sfaultso: 	db	"Stack over flow",0 
720f .. 00		sfaultru:	db "RTS underflow",0 
721d .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
7237 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
7251 .. 00		sfaultdo:	db "DTS overflow", 0 
725e			 
725e			 
725e			fault_dsp_under: 
725e 11 70 72			ld de, .dsp_under 
7261 c3 20 73			jp .show_fault 
7264			 
7264			fault_rsp_under: 
7264 11 7e 72			ld de, .rsp_under 
7267 c3 20 73			jp .show_fault 
726a			fault_loop_under: 
726a 11 8c 72			ld de, .loop_under 
726d c3 20 73			jp .show_fault 
7270			 
7270 .. 00		.dsp_under: db "DSP Underflow",0 
727e .. 00		.rsp_under: db "RSP Underflow",0 
728c .. 00		.loop_under: db "LOOP Underflow",0 
729b			 
729b			 
729b d5			type_faultn: 	push de 
729c e5					push hl 
729d cd 52 0d				call clear_display 
72a0 11 c7 72				   ld de, .typefaultn 
72a3 3e 00				ld a, display_row_1 
72a5 cd 65 0d				call str_at_display 
72a8 11 6b fe				    ld de, debug_mark 
72ab 3e 11				ld a, display_row_1+17 
72ad cd 65 0d				call str_at_display 
72b0 cd 75 0d				call update_display 
72b3			 
72b3				; prompt before entering montior for investigating issue 
72b3			 
72b3 3e 78			ld a, display_row_4 
72b5 11 b4 1d			ld de, endprog 
72b8			 
72b8 cd 75 0d			call update_display		 
72bb			 
72bb cd 3a 20			call next_page_prompt 
72be			 
72be e5					push hl 
72bf d5					push de 
72c0 cd 08 1e				call monitor 
72c3 c3 02 1d				jp warmstart 
72c6 76					halt 
72c7			 
72c7			 
72c7 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
72de			 
72de d5			type_faults: 	push de 
72df e5					push hl 
72e0 cd 52 0d				call clear_display 
72e3 11 09 73				   ld de, .typefaults 
72e6 3e 00				ld a, display_row_1 
72e8 cd 65 0d				call str_at_display 
72eb 11 6b fe				    ld de, debug_mark 
72ee 3e 11				ld a, display_row_1+17 
72f0 cd 65 0d				call str_at_display 
72f3 cd 75 0d				call update_display 
72f6			 
72f6				; prompt before entering montior for investigating issue 
72f6			 
72f6 3e 78			ld a, display_row_4 
72f8 11 b4 1d			ld de, endprog 
72fb			 
72fb cd 75 0d			call update_display		 
72fe			 
72fe cd 3a 20			call next_page_prompt 
7301			 
7301 e1					pop hl 
7302 d1					pop de 
7303 cd 08 1e				call monitor 
7306 c3 02 1d				jp warmstart 
7309			 
7309			 
7309 .. 00		.typefaults: db "STR Type Expected TOS!",0 
7320			 
7320			.show_fault: 	 
7320 d5					push de 
7321 cd 52 0d				call clear_display 
7324 d1					pop de 
7325 3e 00				ld a, display_row_1 
7327 cd 65 0d				call str_at_display 
732a 11 6b fe				    ld de, debug_mark 
732d 3e 11				ld a, display_row_1+17 
732f cd 65 0d				call str_at_display 
7332 cd 75 0d				call update_display 
7335			 
7335				; prompt before entering montior for investigating issue 
7335			 
7335 3e 78			ld a, display_row_4 
7337 11 b4 1d			ld de, endprog 
733a			 
733a cd 75 0d			call update_display		 
733d			 
733d cd 3a 20			call next_page_prompt 
7340			 
7340 e1					pop hl 
7341 d1					pop de 
7342 cd 08 1e				call monitor 
7345			; do a dump to cli and not warmstart so we preserve all of the uwords.  
7345			; TODO Make optional fault restart to cli or warm boot? 
7345					;jp warmstart 
7345 c3 5a 1d				jp cli 
7348 76					halt 
7349			 
7349			; handle the auto run of code from files in storage 
7349			 
7349			 
7349			include "forth_startup.asm" 
7349			; Which startup method to use? 
7349			; 
7349			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
7349			; followed by loading of a list of scripts in eeprom 
7349			 
7349			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
7349			; from eeprom 
7349			 
7349			; Select with define in main stubs 
7349			 
7349			if STARTUP_V1 
7349				include "forth_startupv1.asm" 
7349			endif 
7349			if STARTUP_V2 
7349				include "forth_startupv2.asm" 
7349			; Version 2 of the startup  
7349			;  
7349			; Auto load any files in bank 1 that start with a '*' 
7349			; If no se storage then revert to using eprom 
7349			 
7349			 
7349			if STORAGE_SE = 0 
7349			 
7349			sprompt1: db "Startup load...",0 
7349			sprompt2: db "Run? 1=No *=End #=All",0 
7349			 
7349			 
7349			 
7349			 
7349			forth_startup: 
7349				ld hl, startcmds 
7349				ld a, 0 
7349				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
7349			 
7349			.start1:	push hl 
7349				call clear_display 
7349				ld de, sprompt1 
7349			        ld a, display_row_1 
7349				call str_at_display 
7349				ld de, sprompt2 
7349			        ld a, display_row_2 
7349				call str_at_display 
7349				pop hl 
7349				push hl 
7349				ld e,(hl) 
7349				inc hl 
7349				ld d,(hl) 
7349			        ld a, display_row_3 
7349				call str_at_display 
7349				call update_display 
7349			 
7349			 
7349				ld a, (os_last_cmd) 
7349				cp 0 
7349				jr z, .startprompt 
7349				call delay250ms 
7349				jr .startdo 
7349				 
7349				 
7349			 
7349			.startprompt: 
7349			 
7349				ld a,display_row_4 + display_cols - 1 
7349			        ld de, endprg 
7349				call str_at_display 
7349				call update_display 
7349				call delay1s 
7349				call cin_wait 
7349						 
7349				cp '*' 
7349				jr z, .startupend1 
7349				cp '#' 
7349				jr nz, .startno 
7349				ld a, 1 
7349				ld (os_last_cmd),a 
7349				jr .startdo 
7349			.startno:	cp '1' 
7349				jr z,.startnxt  
7349			 
7349				; exec startup line 
7349			.startdo:	 
7349				pop hl 
7349				push hl 
7349				 
7349				ld e,(hl) 
7349				inc hl 
7349				ld d,(hl) 
7349				ex de,hl 
7349			 
7349				push hl 
7349			 
7349				ld a, 0 
7349				;ld a, FORTH_END_BUFFER 
7349				call strlent 
7349				inc hl   ; include zero term to copy 
7349				ld b,0 
7349				ld c,l 
7349				pop hl 
7349				ld de, scratch 
7349				ldir 
7349			 
7349			 
7349				ld hl, scratch 
7349				call forthparse 
7349				call forthexec 
7349				call forthexec_cleanup 
7349			 
7349				ld a, display_row_4 
7349				ld de, endprog 
7349			 
7349				call update_display		 
7349			 
7349				ld a, (os_last_cmd) 
7349				cp 0 
7349				jr nz, .startnxt 
7349				call next_page_prompt 
7349			        call clear_display 
7349				call update_display		 
7349			 
7349				; move onto next startup line? 
7349			.startnxt: 
7349			 
7349				call delay250ms 
7349				pop hl 
7349			 
7349				inc hl 
7349				inc hl 
7349			 
7349				push hl 
7349				ld e, (hl) 
7349				inc hl 
7349				ld d, (hl) 
7349				pop hl 
7349				; TODO replace 0 test 
7349			 
7349				ex de, hl 
7349				call ishlzero 
7349			;	ld a,e 
7349			;	add d 
7349			;	cp 0    ; any left to do? 
7349				ex de, hl 
7349				jp nz, .start1 
7349				jr .startupend 
7349			 
7349			.startupend1: pop hl 
7349			.startupend: 
7349			 
7349				call clear_display 
7349				call update_display 
7349				ret 
7349			endif 
7349			 
7349			 
7349			if STORAGE_SE 
7349			 
7349			;sprompt3: db "Loading from start-up file:",0 
7349 .. 00		sprompt3: db "  Searching...",0 
7358			;sprompt4: db "(Any key to stop)",0 
7358			 
7358			 
7358			forth_autoload: 
7358			 
7358				; load block 0 of store 1 
7358				 
7358 3e fe			ld a, $fe      ; bit 0 clear 
735a 32 60 fa			ld (spi_device), a 
735d			 
735d cd cd 04			call storage_get_block_0 
7360			 
7360 3a 9b fa			ld a, (store_page+STORE_0_AUTOFILE) 
7363			 
7363 fe 00			cp 0 
7365 c8				ret z     ; auto start not enabled 
7366			 
7366 cd 52 0d			call clear_display 
7369			 
7369				; set bank 
7369			 
7369 3a 9d fa				ld a, (store_page+STORE_0_BANKRUN) 
736c 32 60 fa				ld (spi_device), a 
736f			 
736f			 
736f				; generate a directory of bank 1 and search for flagged files 
736f			 
736f					if DEBUG_FORTH_WORDS_KEY 
736f						DMARK "DIR" 
736f f5				push af  
7370 3a 84 73			ld a, (.dmark)  
7373 32 6b fe			ld (debug_mark),a  
7376 3a 85 73			ld a, (.dmark+1)  
7379 32 6c fe			ld (debug_mark+1),a  
737c 3a 86 73			ld a, (.dmark+2)  
737f 32 6d fe			ld (debug_mark+2),a  
7382 18 03			jr .pastdmark  
7384 ..			.dmark: db "DIR"  
7387 f1			.pastdmark: pop af  
7388			endm  
# End of macro DMARK
7388						CALLMONITOR 
7388 cd 6f fe			call debug_vector  
738b				endm  
# End of macro CALLMONITOR
738b					endif 
738b			 
738b cd cd 04			call storage_get_block_0 
738e			 
738e 21 7a fa			ld hl, store_page     ; get current id count 
7391 46				ld b, (hl) 
7392 0e 00			ld c, 0    ; count of files   
7394					if DEBUG_FORTH_WORDS 
7394						DMARK "DI1" 
7394 f5				push af  
7395 3a a9 73			ld a, (.dmark)  
7398 32 6b fe			ld (debug_mark),a  
739b 3a aa 73			ld a, (.dmark+1)  
739e 32 6c fe			ld (debug_mark+1),a  
73a1 3a ab 73			ld a, (.dmark+2)  
73a4 32 6d fe			ld (debug_mark+2),a  
73a7 18 03			jr .pastdmark  
73a9 ..			.dmark: db "DI1"  
73ac f1			.pastdmark: pop af  
73ad			endm  
# End of macro DMARK
73ad						CALLMONITOR 
73ad cd 6f fe			call debug_vector  
73b0				endm  
# End of macro CALLMONITOR
73b0					endif 
73b0			 
73b0				; check for empty drive 
73b0			 
73b0 3e 00			ld a, 0 
73b2 b8				cp b 
73b3 ca 00 74			jp z, .dirdone 
73b6			 
73b6				; for each of the current ids do a search for them and if found push to stack 
73b6			 
73b6 c5			.diritem:	push bc 
73b7 21 40 00				ld hl, STORE_BLOCK_PHY 
73ba 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
73bc 58					ld e,b 
73bd			 
73bd d5					push de 
73be e5					push hl 
73bf cd 52 0d			call clear_display 
73c2 3e 32			ld a, display_row_2 + 10 
73c4 11 49 73			ld de, sprompt3 
73c7 cd 65 0d			call str_at_display 
73ca cd a9 0c			call active 
73cd eb				ex de, hl 
73ce 3e 2f			ld a, display_row_2 + 7 
73d0 cd 65 0d			call str_at_display 
73d3 cd 75 0d			call update_display 
73d6 e1				pop hl 
73d7 d1				pop de 
73d8			 
73d8			;		if DEBUG_FORTH_WORDS 
73d8			;			DMARK "DI2" 
73d8			;			CALLMONITOR 
73d8			;		endif 
73d8			 
73d8 cd 4f 07				call storage_findnextid 
73db			 
73db			;		if DEBUG_FORTH_WORDS 
73db			;			DMARK "DI3" 
73db			;			CALLMONITOR 
73db			;		endif 
73db			 
73db					; if found hl will be non zero 
73db			 
73db cd af 0f				call ishlzero 
73de			;		ld a, l 
73de			;		add h 
73de			; 
73de			;		cp 0 
73de 28 1d				jr z, .dirnotfound 
73e0			 
73e0					; increase count 
73e0			 
73e0 c1					pop bc	 
73e1 0c					inc c 
73e2 c5					push bc 
73e3					 
73e3			 
73e3					; get file header and push the file name 
73e3			 
73e3 11 7a fa				ld de, store_page 
73e6 cd 1c 04				call storage_read_block 
73e9			 
73e9					; push file id to stack 
73e9				 
73e9			 
73e9					; is this a file we want to run? 
73e9			 
73e9 21 7d fa				ld hl, store_page+3 
73ec 7e					ld a,(hl) 
73ed fe 2a				cp '*' 
73ef 20 0c				jr nz,  .dirnotfound 
73f1					 
73f1			 
73f1			 
73f1 3a 7a fa				ld a, (store_page) 
73f4 d5					push de 
73f5 e5					push hl 
73f6 c5					push bc 
73f7 cd 23 74				call .autorunf 
73fa c1					pop bc 
73fb e1					pop hl 
73fc d1					pop de 
73fd			 
73fd			 
73fd			 
73fd				; save this extent 
73fd			 
73fd					; push file name 
73fd			;display file name to run 
73fd			 
73fd			;		ld hl, store_page+3 
73fd			;		if DEBUG_FORTH_WORDS 
73fd			;			DMARK "DI5" 
73fd			;			CALLMONITOR 
73fd			;		endif 
73fd			; 
73fd			;		 
73fd			; 
73fd			;		call forth_push_str 
73fd			;		if DEBUG_FORTH_WORDS 
73fd			;			DMARK "DI6" 
73fd			;			CALLMONITOR 
73fd			;		endif 
73fd			.dirnotfound: 
73fd c1					pop bc     
73fe 10 b6				djnz .diritem 
7400				 
7400			.dirdone:	 
7400					if DEBUG_FORTH_WORDS 
7400						DMARK "DI7" 
7400 f5				push af  
7401 3a 15 74			ld a, (.dmark)  
7404 32 6b fe			ld (debug_mark),a  
7407 3a 16 74			ld a, (.dmark+1)  
740a 32 6c fe			ld (debug_mark+1),a  
740d 3a 17 74			ld a, (.dmark+2)  
7410 32 6d fe			ld (debug_mark+2),a  
7413 18 03			jr .pastdmark  
7415 ..			.dmark: db "DI7"  
7418 f1			.pastdmark: pop af  
7419			endm  
# End of macro DMARK
7419						CALLMONITOR 
7419 cd 6f fe			call debug_vector  
741c				endm  
# End of macro CALLMONITOR
741c					endif 
741c			 
741c cd 52 0d				call clear_display 
741f cd 75 0d				call update_display 
7422			 
7422 c9					ret 
7423			 
7423			 
7423			 
7423			 
7423			 
7423			.autorunf: 
7423			 
7423			 
7423				; get file id to load from and get the file name to display 
7423			 
7423			;		ld a, (store_page+STORE_0_FILERUN) 
7423			 
7423 2e 00				ld l, 0 
7425 67					ld h, a 
7426 11 7a fa				ld de, store_page 
7429			 
7429					if DEBUG_FORTH_WORDS 
7429						DMARK "ASp" 
7429 f5				push af  
742a 3a 3e 74			ld a, (.dmark)  
742d 32 6b fe			ld (debug_mark),a  
7430 3a 3f 74			ld a, (.dmark+1)  
7433 32 6c fe			ld (debug_mark+1),a  
7436 3a 40 74			ld a, (.dmark+2)  
7439 32 6d fe			ld (debug_mark+2),a  
743c 18 03			jr .pastdmark  
743e ..			.dmark: db "ASp"  
7441 f1			.pastdmark: pop af  
7442			endm  
# End of macro DMARK
7442						CALLMONITOR 
7442 cd 6f fe			call debug_vector  
7445				endm  
# End of macro CALLMONITOR
7445					endif 
7445 cd 75 09				call storage_read 
7448			 
7448					if DEBUG_FORTH_WORDS 
7448						DMARK "ASr" 
7448 f5				push af  
7449 3a 5d 74			ld a, (.dmark)  
744c 32 6b fe			ld (debug_mark),a  
744f 3a 5e 74			ld a, (.dmark+1)  
7452 32 6c fe			ld (debug_mark+1),a  
7455 3a 5f 74			ld a, (.dmark+2)  
7458 32 6d fe			ld (debug_mark+2),a  
745b 18 03			jr .pastdmark  
745d ..			.dmark: db "ASr"  
7460 f1			.pastdmark: pop af  
7461			endm  
# End of macro DMARK
7461						CALLMONITOR 
7461 cd 6f fe			call debug_vector  
7464				endm  
# End of macro CALLMONITOR
7464					endif 
7464			 
7464 cd af 0f				call ishlzero 
7467 c8					ret z             ; file not found 
7468			 
7468					; display file name we are loading 
7468			 
7468 cd 52 0d				call clear_display 
746b			 
746b 3e 32				ld a, display_row_2 + 10 
746d 11 7d fa				ld de, store_page+3 
7470 cd 65 0d				call str_at_display 
7473				 
7473			; 
7473			 
7473			;	ld a, display_row_1+5 
7473			;	ld de, sprompt3 
7473			;	call str_at_display 
7473			;	ld a, display_row_2+7 
7473			;	call active 
7473			;	ex de, hl 
7473			;;	ld de, sprompt4 
7473			;	call str_at_display 
7473			; 
7473 cd 75 0d			call update_display 
7476			 
7476			;	call cin_wait 
7476			;	cp 'n' 
7476			;	ret z 
7476			;	cp 'N' 
7476			;	ret z 
7476			 
7476			;	call delay1s 
7476			 
7476 3a 7c fa			ld a, (store_page+2) 
7479 32 69 fa			ld (store_openmaxext), a    ; save count of ext 
747c 3e 01			ld a, 1  
747e 32 6a fa			ld (store_openext), a    ; save count of ext 
7481			 
7481			.autof: 
7481				; begin to read a line from file 
7481			 
7481 21 e8 f4			ld hl, os_cli_cmd 
7484 22 e6 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
7487			  
7487			.readext: 
7487 3a 6a fa			ld a, (store_openext) 
748a 6f				ld l , a 
748b				 
748b 3a 7a fa			ld a, (store_page) 
748e 67				ld h, a	 
748f 11 7a fa			ld de, store_page 
7492					if DEBUG_FORTH_WORDS 
7492						DMARK "ASl" 
7492 f5				push af  
7493 3a a7 74			ld a, (.dmark)  
7496 32 6b fe			ld (debug_mark),a  
7499 3a a8 74			ld a, (.dmark+1)  
749c 32 6c fe			ld (debug_mark+1),a  
749f 3a a9 74			ld a, (.dmark+2)  
74a2 32 6d fe			ld (debug_mark+2),a  
74a5 18 03			jr .pastdmark  
74a7 ..			.dmark: db "ASl"  
74aa f1			.pastdmark: pop af  
74ab			endm  
# End of macro DMARK
74ab						CALLMONITOR 
74ab cd 6f fe			call debug_vector  
74ae				endm  
# End of macro CALLMONITOR
74ae					endif 
74ae cd 75 09				call storage_read 
74b1 cd af 0f			call ishlzero 
74b4 c8				ret z 
74b5			 
74b5			; TODO copy to exec buffer 
74b5			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
74b5			 
74b5				; copy the record buffer to the cli buffer 
74b5			 
74b5 ed 5b e6 f6		ld de, (os_var_array) 
74b9 21 7c fa			ld hl, store_page+2 
74bc			;	ex de, hl 
74bc 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
74bf ed b0			ldir 
74c1 ed 53 e6 f6		ld (os_var_array), de 
74c5				 
74c5 3a 6a fa			ld a, (store_openext) 
74c8 3c				inc a 
74c9 32 6a fa			ld (store_openext), a    ; save count of ext 
74cc			 
74cc			 
74cc			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
74cc				 
74cc 3a 6d fa			ld a, (store_readcont) 
74cf fe 00			cp 0 
74d1 20 b4			jr nz, .readext 
74d3			 
74d3			;	jr z, .autoend 
74d3			 
74d3					if DEBUG_FORTH_WORDS 
74d3						DMARK "ASc" 
74d3 f5				push af  
74d4 3a e8 74			ld a, (.dmark)  
74d7 32 6b fe			ld (debug_mark),a  
74da 3a e9 74			ld a, (.dmark+1)  
74dd 32 6c fe			ld (debug_mark+1),a  
74e0 3a ea 74			ld a, (.dmark+2)  
74e3 32 6d fe			ld (debug_mark+2),a  
74e6 18 03			jr .pastdmark  
74e8 ..			.dmark: db "ASc"  
74eb f1			.pastdmark: pop af  
74ec			endm  
# End of macro DMARK
74ec						CALLMONITOR 
74ec cd 6f fe			call debug_vector  
74ef				endm  
# End of macro CALLMONITOR
74ef					endif 
74ef e5				push hl	 
74f0 d5				push de 
74f1 cd a9 0c			call active 
74f4 eb				ex de, hl 
74f5 3e 2f			ld a, display_row_2 + 7 
74f7 cd 65 0d			call str_at_display 
74fa			 
74fa cd 75 0d			call update_display 
74fd d1				pop de  
74fe e1				pop hl 
74ff			;	call delay250ms 
74ff			 
74ff			 
74ff			 
74ff			 
74ff			.autoexec: 
74ff			 
74ff			 
74ff 21 e8 f4			ld hl, os_cli_cmd 
7502					if DEBUG_FORTH_WORDS 
7502						DMARK "ASx" 
7502 f5				push af  
7503 3a 17 75			ld a, (.dmark)  
7506 32 6b fe			ld (debug_mark),a  
7509 3a 18 75			ld a, (.dmark+1)  
750c 32 6c fe			ld (debug_mark+1),a  
750f 3a 19 75			ld a, (.dmark+2)  
7512 32 6d fe			ld (debug_mark+2),a  
7515 18 03			jr .pastdmark  
7517 ..			.dmark: db "ASx"  
751a f1			.pastdmark: pop af  
751b			endm  
# End of macro DMARK
751b						CALLMONITOR 
751b cd 6f fe			call debug_vector  
751e				endm  
# End of macro CALLMONITOR
751e					endif 
751e cd bd 24			call forthparse 
7521 cd fd 24			call forthexec 
7524 cd 0f 24			call forthexec_cleanup 
7527			 
7527			 
7527			 
7527 c3 81 74			jp .autof 
752a			;.autofdone: 
752a			; 
752a			;		if DEBUG_FORTH_WORDS 
752a			;			DMARK "ASx" 
752a			;			CALLMONITOR 
752a			;		endif 
752a			;;	call clear_display 
752a			;	ret 
752a			 
752a			 
752a			 
752a			endif 
# End of file forth_startupv2.asm
752a			endif 
752a			 
# End of file forth_startup.asm
752a			 
752a			; eof 
# End of file forth_kernel.asm
752a			;include "nascombasic.asm" 
752a			 
752a			 
752a			; find out where the code ends if loaded into RAM (for SC114) 
752a			;endofcode:  
752a			;	nop 
752a			 
752a			 
752a			; eof 
752a			 
# End of file main.asm
752a			include "firmware_lcd_4x40.asm" 
752a			; **********************************************************************  
752a			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
752a			; **********************************************************************  
752a			;  
752a			; **  Written as a Small Computer Monitor App  
752a			; **  www.scc.me.uk  
752a			;  
752a			; History  
752a			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
752a			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
752a			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
752a			;  
752a			; **********************************************************************  
752a			;  
752a			; This program is an example of one of the methods of interfacing an   
752a			; alphanumeric LCD module.   
752a			;  
752a			; In this example the display is connected to either a Z80 PIO or a   
752a			; simple 8-bit output port.   
752a			;  
752a			; This interfacing method uses 4-bit data mode and uses time delays  
752a			; rather than polling the display's ready status. As a result the   
752a			; interface only requires 6 simple output lines:  
752a			;   Output bit 0 = not used  
752a			;   Output bit 1 = not used  
752a			;   Output bit 2 = RS         High = data, Low = instruction  
752a			;   Output bit 3 = E          Active high  
752a			;   Output bit 4 = DB4  
752a			;   Output bit 5 = DB5  
752a			;   Output bit 6 = DB6  
752a			;   Output bit 7 = DB7  
752a			; Display's R/W is connected to 0v so it is always in write mode  
752a			;  
752a			; This set up should work with any system supporting the RC2014 bus  
752a			  
752a			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
752a			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
752a			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
752a			;  
752a			; **********************************************************************  
752a			  
752a			; Additonal for 4x40. E1 and E2 instead of just E   
752a			; TODO swipe vidout signal on port a to activate E2  
752a			  
752a			; **********************************************************************  
752a			; **  Constants  
752a			; **********************************************************************  
752a			; LCD constants required by LCD support module  
752a			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
752a			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
752a			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
752a			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
752a			; TODO Decide which E is being set  
752a			kLCDWidth:  EQU display_cols             ;Width in characters  
752a			  
752a			; **********************************************************************  
752a			; **  Code library usage  
752a			; **********************************************************************  
752a			  
752a			; send character to current cursor position  
752a			; wraps and/or scrolls screen automatically  
752a			  
752a			  
752a			  
752a			lcd_init:  
752a			  
752a			; SCMonAPI functions used  
752a			  
752a			; Alphanumeric LCD functions used  
752a			; no need to specify specific functions for this module  
752a			  
752a 3e cf		            LD   A, 11001111b  
752c d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
752e 3e 00		            LD   A, 00000000b  
7530 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
7532			  
7532			; Initialise alphanumeric LCD module  
7532 3e 00				ld a, 0  
7534 32 cb fb				ld (display_lcde1e2), a  
7537 cd b8 75		            CALL fLCD_Init      ;Initialise LCD module  
753a 3e 01				ld a, 1  
753c 32 cb fb				ld (display_lcde1e2), a  
753f cd b8 75		            CALL fLCD_Init      ;Initialise LCD module  
7542			  
7542 c9				ret  
7543			  
7543			;  
7543			;;  
7543			; lcd functions  
7543			;  
7543			;  
7543			  
7543			; what is at cursor position   
7543			  
7543			;get_cursor:	ld de, (cursor_row)   ;  row + col  
7543			;		call curptr  
7543			;		ret  
7543			  
7543			  
7543			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
7543			  
7543			curptr:  
7543 c5				push bc  
7544 21 b1 fd			ld hl, display_fb0  
7547			cpr:	  
7547				; loop for cursor whole row  
7547 0e 28			ld c, display_cols  
7549 23			cpr1:	inc hl  
754a 0d				dec c  
754b 20 fc			jr nz, cpr1  
754d 05				dec b  
754e 20 f7			jr nz, cpr  
7550			  
7550				; add col	  
7550			  
7550 23			cpr2:	inc hl  
7551 1d				dec e  
7552 20 fc			jr nz, cpr2  
7554			  
7554 c1				pop bc  
7555 c9				ret  
7556				  
7556			  
7556			  
7556			  
7556			  
7556			; write the frame buffer given in hl to hardware   
7556 22 c9 fb		write_display: ld (display_write_tmp), hl 	   
7559 3e 00			ld a, kLCD_Line1  
755b cd 65 76		            CALL fLCD_Pos       ;Position cursor to location in A  
755e 06 28			ld b, display_cols  
7560 ed 5b c9 fb		ld de, (display_write_tmp)  
7564 cd b0 75			call write_len_string  
7567				  
7567				  
7567 2a c9 fb			ld hl, (display_write_tmp)  
756a 11 28 00			ld de, display_cols  
756d 19				add hl,de  
756e 22 c9 fb			ld (display_write_tmp),hl  
7571			  
7571				  
7571 3e 28			ld a, kLCD_Line2  
7573 cd 65 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7576 06 28			ld b, display_cols  
7578 ed 5b c9 fb		ld de, (display_write_tmp)  
757c cd b0 75			call write_len_string  
757f				  
757f 2a c9 fb			ld hl, (display_write_tmp)  
7582 11 28 00			ld de, display_cols  
7585 19				add hl,de  
7586 22 c9 fb			ld (display_write_tmp),hl  
7589			  
7589				  
7589 3e 50			ld a, kLCD_Line3  
758b cd 65 76		            CALL fLCD_Pos       ;Position cursor to location in A  
758e 06 28			ld b, display_cols  
7590 ed 5b c9 fb		ld de, (display_write_tmp)  
7594 cd b0 75			call write_len_string  
7597				  
7597 2a c9 fb			ld hl, (display_write_tmp)  
759a 11 28 00			ld de, display_cols  
759d 19				add hl,de  
759e 22 c9 fb			ld (display_write_tmp),hl  
75a1			  
75a1				  
75a1 3e 78			ld a, kLCD_Line4  
75a3 cd 65 76		            CALL fLCD_Pos       ;Position cursor to location in A  
75a6 06 28			ld b, display_cols  
75a8 ed 5b c9 fb		ld de, (display_write_tmp)  
75ac cd b0 75			call write_len_string  
75af c9					ret  
75b0				  
75b0				; write out a fixed length string given in b from de  
75b0			  
75b0 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
75b1 cd 1d 76		            CALL fLCD_Data      ;Write character to display  
75b4 13				inc de  
75b5 10 f9			djnz write_len_string  
75b7 c9				ret  
75b8			  
75b8			; Some other things to do  
75b8			;            LD   A, kLCD_Clear ;Display clear  
75b8			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
75b8			;            LD   A, kLCD_Under ;Display on with underscore cursor  
75b8			;            LD   A, kLCD_On     ;Display on with no cursor  
75b8			;            ;LD   A, kLCD_Off   ;Display off  
75b8			;            CALL fLCD_Inst      ;Send instruction to display  
75b8			;  
75b8			;  
75b8			;            halt  
75b8			;  
75b8			;  
75b8			;MsgHello:   DB  "Hello World!",0  
75b8			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
75b8			  
75b8			; Custom characters 5 pixels wide by 8 pixels high  
75b8			; Up to 8 custom characters can be defined  
75b8			;BitMaps:      
75b8			;; Character 0x00 = Battery icon  
75b8			;            DB  01110b  
75b8			;            DB  11011b  
75b8			;            DB  10001b  
75b8			;            DB  10001b  
75b8			;            DB  11111b  
75b8			;            DB  11111b  
75b8			;            DB  11111b  
75b8			;            DB  11111b  
75b8			;; Character 0x01 = Bluetooth icon  
75b8			;            DB  01100b  
75b8			;            DB  01010b  
75b8			;            DB  11100b  
75b8			;            DB  01000b  
75b8			;            DB  11100b  
75b8			;            DB  01010b  
75b8			;            DB  01100b  
75b8			;            DB  00000b  
75b8			;  
75b8			  
75b8			  
75b8			; **********************************************************************  
75b8			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
75b8			; **********************************************************************  
75b8			;  
75b8			; **  Written as a Small Computer Monitor App   
75b8			; **  Version 0.1 SCC 2018-05-16  
75b8			; **  www.scc.me.uk  
75b8			;  
75b8			; **********************************************************************  
75b8			;  
75b8			; This module provides support for alphanumeric LCD modules using with  
75b8			; *  HD44780 (or compatible) controller  
75b8			; *  5 x 7 pixel fonts  
75b8			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
75b8			; *  Interface via six digital outputs to the display (see below)  
75b8			;  
75b8			; LCD module pinout:  
75b8			;   1  Vss   0v supply  
75b8			;   2  Vdd   5v supply  
75b8			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
75b8			;   4  RS    High = data, Low = instruction  
75b8			;   5  R/W   High = Read, Low = Write  
75b8			;   6  E     Enable signal (active high)  
75b8			;   7  DB0   Data bit 0  
75b8			;   8  DB1   Data bit 1  
75b8			;   9  DB2   Data bit 2  
75b8			;  10  DB3   Data bit 3  
75b8			;  11  DB4   Data bit 4  
75b8			;  12  DB5   Data bit 5  
75b8			;  13  DB6   Data bit 6  
75b8			;  14  DB7   Data bit 7  
75b8			;  15  A     Backlight anode (+)  
75b8			;  16  K     Backlight cathode (-)  
75b8			;  
75b8			; This interfacing method uses 4-bit data mode and uses time delays  
75b8			; rather than polling the display's ready status. As a result the   
75b8			; interface only requires 6 simple output lines:  
75b8			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
75b8			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
75b8			;   LCD DB4 = Microcomputer output port bit 4  
75b8			;   LCD DB5 = Microcomputer output port bit 5  
75b8			;   LCD DB6 = Microcomputer output port bit 6  
75b8			;   LCD DB7 = Microcomputer output port bit 7  
75b8			; Display's R/W is connected to 0v so it is always in write mode  
75b8			; All 6 connections must be on the same port address <kLCDPrt>  
75b8			; This method also allows a decent length of cable from micro to LCD  
75b8			;  
75b8			; **********************************************************************  
75b8			;  
75b8			; To include the code for any given function provided by this module,   
75b8			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
75b8			; the parent source file.  
75b8			; For example:  #REQUIRES   uHexPrefix  
75b8			;  
75b8			; Also #INCLUDE this file at some point after the #REQUIRES statements  
75b8			; in the parent source file.  
75b8			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
75b8			;  
75b8			; These are the function names provided by this module:  
75b8			; fLCD_Init                     ;Initialise LCD  
75b8			; fLCD_Inst                     ;Send instruction to LCD  
75b8			; fLCD_Data                     ;Send data byte to LCD  
75b8			; fLCD_Pos                      ;Position cursor  
75b8			; fLCD_Str                      ;Display string  
75b8			; fLCD_Def                      ;Define custom character  
75b8			;  
75b8			; **********************************************************************  
75b8			;  
75b8			; Requires SCMonAPI.asm to also be included in the project  
75b8			;  
75b8			  
75b8			  
75b8			; **********************************************************************  
75b8			; **  Constants  
75b8			; **********************************************************************  
75b8			  
75b8			; Constants that must be defined externally  
75b8			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
75b8			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
75b8			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
75b8			;kLCDWidth: EQU 20             ;Width in characters  
75b8			  
75b8			; general line offsets in any frame buffer  
75b8			  
75b8			  
75b8			display_row_1: equ 0  
75b8			display_row_2: equ display_row_1+display_cols  
75b8			display_row_3: equ display_row_2 + display_cols  
75b8			display_row_4: equ display_row_3 + display_cols  
75b8			;display_row_4_eol:   
75b8			  
75b8			  
75b8			; Cursor position values for the start of each line  
75b8			  
75b8			; E  
75b8			kLCD_Line1: EQU 0x00   
75b8			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
75b8			; E1  
75b8			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
75b8			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
75b8			  
75b8			; Instructions to send as A register to fLCD_Inst  
75b8			kLCD_Clear: EQU 00000001b     ;LCD clear  
75b8			kLCD_Off:   EQU 00001000b     ;LCD off  
75b8			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
75b8			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
75b8			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
75b8			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
75b8			  
75b8			; Constants used by this code module  
75b8			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
75b8			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
75b8			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
75b8			  
75b8			  
75b8			  
75b8			; **********************************************************************  
75b8			; **  LCD support functions  
75b8			; **********************************************************************  
75b8			  
75b8			; Initialise alphanumeric LCD module  
75b8			; LCD control register codes:  
75b8			;   DL   0 = 4-bit mode        1 = 8-bit mode  
75b8			;   N    0 = 1-line mode       1 = 2-line mode  
75b8			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
75b8			;   D    0 = Display off       1 = Display on  
75b8			;   C    0 = Cursor off        1 = Cursor on  
75b8			;   B    0 = Blinking off      1 = Blinking on  
75b8			;   ID   0 = Decrement mode    1 = Increment mode  
75b8			;   SH   0 = Entire shift off  1 = Entire shift on  
75b8 3e 28		fLCD_Init:  LD   A, 40  
75ba cd df 76		            CALL LCDDelay       ;Delay 40ms after power up  
75bd			; For reliable reset set 8-bit mode - 3 times  
75bd cd af 76		            CALL WrFn8bit       ;Function = 8-bit mode  
75c0 cd af 76		            CALL WrFn8bit       ;Function = 8-bit mode  
75c3 cd af 76		            CALL WrFn8bit       ;Function = 8-bit mode  
75c6			; Set 4-bit mode  
75c6 cd ab 76		            CALL WrFn4bit       ;Function = 4-bit mode  
75c9 cd dd 76		            CALL LCDDelay1      ;Delay 37 us or more  
75cc			; Function set  
75cc 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
75ce cd e1 75		            CALL fLCD_Inst      ;2 line, display on  
75d1			; Display On/Off control  
75d1 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
75d3 cd e1 75		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
75d6			; Display Clear  
75d6 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
75d8 cd e1 75		            CALL fLCD_Inst      ;Clear display  
75db			; Entry mode  
75db 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
75dd cd e1 75		            CALL fLCD_Inst      ;Increment mode, shift off  
75e0			; Display module now initialised  
75e0 c9			            RET  
75e1			; ok to here  
75e1			  
75e1			; Write instruction to LCD  
75e1			;   On entry: A = Instruction byte to be written  
75e1			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
75e1 f5			fLCD_Inst:  PUSH AF  
75e2 f5			            PUSH AF  
75e3 cd f5 75		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
75e6 f1			            POP  AF  
75e7 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
75e8 17			            RLA  
75e9 17			            RLA  
75ea 17			            RLA  
75eb cd f5 75		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
75ee 3e 02		            LD   A, 2  
75f0 cd df 76		            CALL LCDDelay       ;Delay 2 ms to complete   
75f3 f1			            POP  AF  
75f4 c9			            RET  
75f5			Wr4bits:   
75f5 f5					push af  
75f6 3a cb fb				ld a, (display_lcde1e2)  
75f9 fe 00				cp 0     ; e  
75fb 20 10				jr nz, .wea2	  
75fd f1					pop af  
75fe e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7600 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7602 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
7604 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
7606 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7608 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
760a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
760c c9			            RET  
760d f1			.wea2:		pop af  
760e e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7610 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7612 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
7614 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
7616 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7618 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
761a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
761c c9			            RET  
761d			  
761d			  
761d			; Write data to LCD  
761d			;   On entry: A = Data byte to be written  
761d			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
761d f5			fLCD_Data:  PUSH AF  
761e f5			            PUSH AF  
761f cd 31 76		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7622 f1			            POP  AF  
7623 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7624 17			            RLA  
7625 17			            RLA  
7626 17			            RLA  
7627 cd 31 76		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
762a 3e 96		            LD   A, 150  
762c 3d			Wait:      DEC  A              ;Wait a while to allow data   
762d 20 fd		            JR   NZ, Wait      ;  write to complete  
762f f1			            POP  AF  
7630 c9			            RET  
7631			Wr4bitsa:     
7631 f5					push af  
7632 3a cb fb				ld a, (display_lcde1e2)  
7635 fe 00				cp 0     ; e1  
7637 20 16				jr nz, .we2	  
7639 f1					pop af  
763a e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
763c cb d7		            SET  kLCDBitRS, A  
763e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7640 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
7642 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
7644 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7646 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
7648 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
764a cb 97		            RES  kLCDBitRS, A  
764c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
764e c9			            RET  
764f f1			.we2:		pop af  
7650 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7652 cb d7		            SET  kLCDBitRS, A  
7654 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7656 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
7658 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
765a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
765c cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
765e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7660 cb 97		            RES  kLCDBitRS, A  
7662 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7664 c9			            RET  
7665			  
7665			  
7665			; Position cursor to specified location  
7665			;   On entry: A = Cursor position  
7665			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7665 f5			fLCD_Pos:   PUSH AF  
7666					; at this point set the E1 or E2 flag depending on position  
7666			  
7666 c5					push bc  
7667			;		push af  
7667 06 00				ld b, 0  
7669 4f					ld c, a  
766a 3e 4f				ld a, kLCD_Line3-1  
766c b7			 		or a      ;clear carry flag  
766d 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
766e 38 04				jr c, .pe1  
7670			  
7670					; E selection  
7670 cb 80				res 0, b         ; bit 0 unset e  
7672			;		pop af    ; before line 3 so recover orig pos  
7672			;		ld c, a    ; save for poking back  
7672 18 06				jr .peset	          
7674			.pe1:          	; E2 selection  
7674 cb c0				set 0, b         ; bit 0 set e1  
7676 79					ld a, c  
7677 de 4f				sbc a, kLCD_Line3-1  
7679 4f					ld c, a	         ; save caculated offset  
767a			;		pop af     ; bin this original value now we have calculated form  
767a			  
767a			.peset:		; set bit  
767a 78					ld a, b  
767b 32 cb fb				ld (display_lcde1e2), a 	  
767e 79					ld a, c  
767f c1					pop bc  
7680			  
7680 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
7682 cd e1 75		            CALL fLCD_Inst      ;Write instruction to LCD  
7685 f1			            POP  AF  
7686 c9			            RET  
7687			  
7687			  
7687			; Output text string to LCD  
7687			;   On entry: DE = Pointer to null terminated text string  
7687			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
7687 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
7688 b7			            OR   A              ;Null terminator?  
7689 c8			            RET  Z              ;Yes, so finished  
768a cd 1d 76		            CALL fLCD_Data      ;Write character to display  
768d 13			            INC  DE             ;Point to next character  
768e 18 f7		            JR   fLCD_Str       ;Repeat  
7690 c9					ret  
7691			  
7691			; Define custom character  
7691			;   On entry: A = Character number (0 to 7)  
7691			;             DE = Pointer to character bitmap data  
7691			;   On exit:  A = Next character number  
7691			;             DE = Next location following bitmap  
7691			;             BC HL IX IY I AF' BC' DE' HL' preserved  
7691			; Character is   
7691 c5			fLCD_Def:   PUSH BC  
7692 f5			            PUSH AF  
7693 07			            RLCA                ;Calculate location  
7694 07			            RLCA                ;  for bitmap data  
7695 07			            RLCA                ;  = 8 x CharacterNumber  
7696 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
7698 cd e1 75		            CALL fLCD_Inst      ;Write instruction to LCD  
769b 06 00		            LD   B, 0  
769d 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
769e cd 1d 76		            CALL fLCD_Data      ;Write byte to display  
76a1 13			            INC  DE             ;Point to next byte  
76a2 04			            INC  B              ;Count bytes  
76a3 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
76a5 28 f6		            JR   Z, Loop       ;No, so repeat  
76a7 f1			            POP  AF  
76a8 3c			            INC  A              ;Increment character number  
76a9 c1			            POP  BC  
76aa c9			            RET  
76ab			  
76ab			  
76ab			; **********************************************************************  
76ab			; **  Private functions  
76ab			; **********************************************************************  
76ab			  
76ab			; Write function to LCD  
76ab			;   On entry: A = Function byte to be written  
76ab			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
76ab 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
76ad 18 02		            JR   WrFunc  
76af 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
76b1 f5			WrFunc:     PUSH AF  
76b2 f5					push af  
76b3 3a cb fb				ld a, (display_lcde1e2)  
76b6 fe 00				cp 0     ; e1  
76b8 20 0f				jr nz, .wfea2	  
76ba f1					pop af  
76bb d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
76bd cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
76bf cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
76c1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
76c3 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
76c5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
76c7 18 0d			jr .wfskip  
76c9 f1			.wfea2:		pop af  
76ca d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
76cc cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
76ce cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
76d0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
76d2 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
76d4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
76d6 3e 05		.wfskip:            LD  A, 5  
76d8 cd df 76		            CALL LCDDelay       ;Delay 5 ms to complete  
76db f1			            POP  AF  
76dc c9			            RET  
76dd			  
76dd			  
76dd			; Delay in milliseconds  
76dd			;   On entry: A = Number of milliseconds delay  
76dd			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
76dd 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
76df d5			LCDDelay:   PUSH DE  
76e0 5f			            LD   E, A           ;Delay by 'A' ms  
76e1 16 00		            LD   D, 0  
76e3 cd 7a 0c		            CALL aDelayInMS  
76e6 d1			            POP  DE  
76e7 c9			            RET  
76e8			  
76e8			  
76e8			testlcd:  
76e8 3e 00			ld a, kLCD_Line1  
76ea cd 65 76			call fLCD_Pos  
76ed 06 28			ld b, 40  
76ef 11 1d 77			ld de, .ttext1  
76f2 cd b0 75			call write_len_string  
76f5			  
76f5 3e 28			ld a, kLCD_Line2  
76f7 cd 65 76			call fLCD_Pos  
76fa 06 28			ld b, 40  
76fc 11 46 77			ld de, .ttext2  
76ff cd b0 75			call write_len_string  
7702 3e 50			ld a, kLCD_Line3  
7704 cd 65 76			call fLCD_Pos  
7707 06 28			ld b, 40  
7709 11 6f 77			ld de, .ttext3  
770c cd b0 75			call write_len_string  
770f 3e 78			ld a, kLCD_Line4  
7711 cd 65 76			call fLCD_Pos  
7714 06 28			ld b, 40  
7716 11 98 77			ld de, .ttext4  
7719 cd b0 75			call write_len_string  
771c			  
771c 76				halt  
771d			  
771d			  
771d .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
7746 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
776f .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
7798 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
77c1			   
77c1			  
77c1			  
77c1			; eof  
77c1			  
# End of file firmware_lcd_4x40.asm
77c1			;include "firmware_lcd_4x20.asm" 
77c1			include "firmware_key_5x10.asm" 
77c1			; 5 x 10 decade counter scanner  
77c1			  
77c1			  
77c1			; TODO do cursor shape change for shift keys  
77c1			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
77c1			  
77c1			  
77c1			; bit mask for each scan column and row for teing the matrix  
77c1			  
77c1			  
77c1			key_init:  
77c1			  
77c1			; SCMonAPI functions used  
77c1			  
77c1			; Alphanumeric LCD functions used  
77c1			; no need to specify specific functions for this module  
77c1			  
77c1			  
77c1 3e cf		            LD   A, 11001111b  
77c3 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
77c5			;            LD   A, 00000000b  
77c5 3e 1f		            LD   A, 00011111b  
77c7 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
77c9			  
77c9			  
77c9				; TODO Configure cursor shapes  
77c9			  
77c9				; Load cursor shapes   
77c9 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
77cb 11 db 77		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
77ce 06 02		            LD   B, 2           ;Number of characters to define  
77d0 cd 91 76		.DefLoop:   CALL fLCD_Def       ;Define custom character  
77d3 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
77d5			  
77d5 3e 01				ld a, 1  
77d7 32 c1 fb			ld (cursor_shape),a  
77da c9				ret  
77db			  
77db			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
77db			; Up to 8 custom characters can be defined  
77db			.cursor_shapes:      
77db			;; Character 0x00 = Normal  
77db 1f			            DB  11111b  
77dc 1f			            DB  11111b  
77dd 1f			            DB  11111b  
77de 1f			            DB  11111b  
77df 1f			            DB  11111b  
77e0 1f			            DB  11111b  
77e1 1f			            DB  11111b  
77e2 1f			            DB  11111b  
77e3			;; Character 0x01 = Modifier  
77e3 1f			            DB  11111b  
77e4 1b			            DB  11011b  
77e5 1b			            DB  11011b  
77e6 1b			            DB  11011b  
77e7 1b			            DB  11011b  
77e8 1f			            DB  11111b  
77e9 1b			            DB  11011b  
77ea 1f			            DB  11111b  
77eb			  
77eb			  
77eb			  
77eb			  
77eb			; Display custom character 0  
77eb			;            LD   A, kLCD_Line1+14  
77eb			;            CALL fLCD_Pos       ;Position cursor to location in A  
77eb			;            LD   A, 0  
77eb			;            CALL fLCD_Data      ;Write character in A at cursor  
77eb			  
77eb			; Display custom character 1  
77eb			;            LD   A, kLCD_Line2+14  
77eb			;            CALL fLCD_Pos      ;Position cursor to location in A  
77eb			;            LD   A, 1  
77eb			;            CALL fLCD_Data     ;Write character in A at cursor  
77eb			  
77eb			; keyboard scanning   
77eb			  
77eb			; character in from keyboard  
77eb			  
77eb			; mapping for the pcb layout  
77eb			  
77eb			.matrix_to_char:  
77eb .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
77f6 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
7801 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
780c 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7817 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7822			.matrix_to_shift:  
7822			  
7822 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
782d .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
7838 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7843 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
784e .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
7859			  
7859			.matrix_to_symbolshift:  
7859			  
7859 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7864 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
786f 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
787a			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
787a 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
7885 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
7890			  
7890			  
7890			  
7890			; mapping for a simple straight through breadboard layout  
7890			  
7890			;.matrix_to_char:  
7890			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7890			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
7890			;		db "asdfghjkl",KEY_CR,0  
7890			;		db "qwertyuiop",0  
7890			;		 db "1234567890",0  
7890			;.matrix_to_shift:  
7890			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
7890			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
7890			;		db "ASDFGHJKL",KEY_CR,0  
7890			;		db "QWERTYUIOP",0  
7890			;		 db "!",'"',"#$%^&*()",0  
7890			;.matrix_to_symbolshift:  
7890			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7890			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
7890			;		db "_?*fghjk=",KEY_CR,0  
7890			;		db "-/+*[]{}@#",0  
7890			;		 db "1234567890",0  
7890			  
7890			;.matrix_to_char: db "D#0*C987B654A321"  
7890			  
7890			  
7890				  
7890			  
7890			; add cin and cin_wait  
7890			  
7890 cd a1 78		cin_wait: 	call cin  
7893						if DEBUG_KEYCINWAIT  
7893							push af  
7893							  
7893							ld hl,key_repeat_ct  
7893							ld (hl),a  
7893							inc hl  
7893							call hexout  
7893							ld hl,key_repeat_ct+3  
7893							ld a,0  
7893							ld (hl),a  
7893			  
7893							    LD   A, kLCD_Line1+11  
7893							    CALL fLCD_Pos       ;Position cursor to location in A  
7893							    LD   DE, key_repeat_ct  
7893							    ;LD   DE, MsgHello  
7893							    CALL fLCD_Str       ;Display string pointed to by DE  
7893			  
7893			  
7893			  
7893							pop af  
7893						endif  
7893 fe 00			cp 0  
7895 28 f9			jr z, cin_wait   ; block until key press  
7897			  
7897							if DEBUG_KEYCINWAIT  
7897								push af  
7897			  
7897								ld a, 'A'	  
7897								ld hl,key_repeat_ct  
7897								ld (hl),a  
7897								inc hl  
7897								ld a,0  
7897								ld (hl),a  
7897			  
7897								    LD   A, kLCD_Line2+11  
7897								    CALL fLCD_Pos       ;Position cursor to location in A  
7897								    LD   DE, key_repeat_ct  
7897								    ;LD   DE, MsgHello  
7897								    CALL fLCD_Str       ;Display string pointed to by DE  
7897			  
7897							call delay500ms  
7897			  
7897								pop af  
7897							endif  
7897 f5				push af   ; save key pressed  
7898			  
7898			.cin_wait1:	  
7898							if DEBUG_KEYCINWAIT  
7898								push af  
7898			  
7898								ld a, 'b'	  
7898								ld hl,key_repeat_ct  
7898								ld (hl),a  
7898								inc hl  
7898								ld a,0  
7898								ld (hl),a  
7898			  
7898								    LD   A, kLCD_Line2+11  
7898								    CALL fLCD_Pos       ;Position cursor to location in A  
7898								    LD   DE, key_repeat_ct  
7898								    ;LD   DE, MsgHello  
7898								    CALL fLCD_Str       ;Display string pointed to by DE  
7898			  
7898			  
7898							call delay500ms  
7898			  
7898								pop af  
7898							endif  
7898			  
7898 cd a1 78		call cin  
789b fe 00			cp 0  
789d 20 f9			jr nz, .cin_wait1  	; wait for key release  
789f			if DEBUG_KEYCINWAIT  
789f				push af  
789f			  
789f				ld a, '3'	  
789f				ld hl,key_repeat_ct  
789f				ld (hl),a  
789f				inc hl  
789f				ld a,0  
789f				ld (hl),a  
789f			  
789f			            LD   A, kLCD_Line2+11  
789f			            CALL fLCD_Pos       ;Position cursor to location in A  
789f			            LD   DE, key_repeat_ct  
789f			            ;LD   DE, MsgHello  
789f			            CALL fLCD_Str       ;Display string pointed to by DE  
789f			  
789f			  
789f			call delay500ms  
789f			  
789f				pop af  
789f			endif  
789f			  
789f f1				pop af   ; get key  
78a0 c9				ret  
78a1			  
78a1			  
78a1 cd b5 78		cin: 	call .mtoc  
78a4			  
78a4			if DEBUG_KEYCIN  
78a4				push af  
78a4				  
78a4				ld hl,key_repeat_ct  
78a4				ld (hl),a  
78a4				inc hl  
78a4				call hexout  
78a4				ld hl,key_repeat_ct+3  
78a4				ld a,0  
78a4				ld (hl),a  
78a4			  
78a4			            LD   A, kLCD_Line3+15  
78a4			            CALL fLCD_Pos       ;Position cursor to location in A  
78a4			            LD   DE, key_repeat_ct  
78a4			            ;LD   DE, MsgHello  
78a4			            CALL fLCD_Str       ;Display string pointed to by DE  
78a4			  
78a4			  
78a4			call delay500ms  
78a4			  
78a4				pop af  
78a4			endif  
78a4			  
78a4			  
78a4				; no key held  
78a4 fe 00			cp 0  
78a6 c8				ret z  
78a7			  
78a7			if DEBUG_KEYCIN  
78a7				push af  
78a7			  
78a7				ld a, '1'	  
78a7				ld hl,key_repeat_ct  
78a7				ld (hl),a  
78a7				inc hl  
78a7				ld a,0  
78a7				ld (hl),a  
78a7			  
78a7			            LD   A, kLCD_Line4+15  
78a7			            CALL fLCD_Pos       ;Position cursor to location in A  
78a7			            LD   DE, key_repeat_ct  
78a7			            ;LD   DE, MsgHello  
78a7			            CALL fLCD_Str       ;Display string pointed to by DE  
78a7			  
78a7			  
78a7			call delay500ms  
78a7			  
78a7				pop af  
78a7			endif  
78a7			  
78a7				; stop key bounce  
78a7			  
78a7 32 88 fe			ld (key_held),a		 ; save it  
78aa 47				ld b, a  
78ab			  
78ab c5			.cina1:	push bc  
78ac			if DEBUG_KEYCIN  
78ac				push af  
78ac			  
78ac				ld hl,key_repeat_ct  
78ac				inc hl  
78ac				call hexout  
78ac				ld hl,key_repeat_ct+3  
78ac				ld a,0  
78ac				ld (hl),a  
78ac				ld hl,key_repeat_ct  
78ac				ld a, '2'	  
78ac				ld (hl),a  
78ac			  
78ac			            LD   A, kLCD_Line4+15  
78ac			            CALL fLCD_Pos       ;Position cursor to location in A  
78ac			            LD   DE, key_repeat_ct  
78ac			            ;LD   DE, MsgHello  
78ac			            CALL fLCD_Str       ;Display string pointed to by DE  
78ac			  
78ac				pop af  
78ac			endif  
78ac cd b5 78			call .mtoc  
78af c1				pop bc  
78b0 b8				cp b  
78b1 28 f8			jr z, .cina1  
78b3 78				ld a,b		  
78b4			if DEBUG_KEYCIN  
78b4				push af  
78b4			  
78b4				ld hl,key_repeat_ct  
78b4				inc hl  
78b4				call hexout  
78b4				ld hl,key_repeat_ct+3  
78b4				ld a,0  
78b4				ld (hl),a  
78b4				ld hl,key_repeat_ct  
78b4				ld a, '3'	  
78b4				ld (hl),a  
78b4			  
78b4			            LD   A, kLCD_Line4+15  
78b4			            CALL fLCD_Pos       ;Position cursor to location in A  
78b4			            LD   DE, key_repeat_ct  
78b4			            ;LD   DE, MsgHello  
78b4			            CALL fLCD_Str       ;Display string pointed to by DE  
78b4			  
78b4				pop af  
78b4			endif  
78b4 c9				ret  
78b5			  
78b5			; detect keyboard modifier key press and apply new overlay to the face key held  
78b5			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
78b5			  
78b5			;.cin_map_modifier:   
78b5			;	ld a, (hl)  
78b5			;	and 255  
78b5			;	ret NZ		; modifier key not flagged  
78b5			;  
78b5			;	; get key face  
78b5			;  
78b5			;	ld b,(key_face_held)  
78b5			;  
78b5			;	ld b, key_cols * key_rows  
78b5			;  
78b5			;	push de  
78b5			;	pop hl  
78b5			;  
78b5			;.mmod1: ld a,(hl)   ; get map test  
78b5			;	cp b  
78b5			;	jr z, .mmod2  
78b5			;  
78b5			;  
78b5			;  
78b5			;.mmod2: inc hl    ;   
78b5			;  
78b5			;	  
78b5			;  
78b5			;	  
78b5			;  
78b5			;	ld hl,key_actual_pressed  
78b5			;	ld (hl),a,  
78b5			;	ret  
78b5			  
78b5			; map matrix key held to char on face of key  
78b5			  
78b5			.mtoc:  
78b5			  
78b5			; test decade counter strobes  
78b5			  
78b5			;.decadetest1:  
78b5			  
78b5			; reset counter  
78b5			;ld a, 128  
78b5			;out (portbdata),a  
78b5			  
78b5			  
78b5			;ld b, 5  
78b5			;.dec1:  
78b5			;ld a, 0  
78b5			;out (portbdata),a  
78b5			;call delay1s  
78b5			  
78b5			;ld a, 32  
78b5			;out (portbdata),a  
78b5			;call delay1s  
78b5			;call delay1s  
78b5			;call delay1s  
78b5			;  
78b5			;ld a, 64+32  
78b5			;out (portbdata),a  
78b5			;call delay1s  
78b5			;;djnz .dec1  
78b5			;  
78b5			;jp .decadetest1  
78b5			  
78b5			  
78b5			  
78b5			  
78b5			  
78b5			  
78b5			  
78b5			  
78b5			  
78b5			  
78b5				; scan keyboard matrix and generate raw scan map  
78b5 cd 48 79			call matrix  
78b8			  
78b8				; reuse c bit 0 left modifer button - ie shift  
78b8			        ; reuse c bit 1 for right modifer button - ie symbol shift  
78b8				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
78b8			  
78b8 0e 00			ld c, 0  
78ba			  
78ba				; TODO set flags for modifer key presses   
78ba				; TODO do a search for modifer key...  
78ba			  
78ba				;ld hl,keyscan_table_row4  
78ba 21 e7 fe			ld hl,keyscan_table_row2  
78bd			  
78bd 7e				ld a, (hl)  
78be fe 23			cp '#'  
78c0 20 07			jr nz, .nextmodcheck  
78c2 cb c1			set 0, c  
78c4 21 22 78			ld hl, .matrix_to_shift  
78c7 18 21			jr .dokeymap  
78c9				; TODO for now igonre  
78c9			.nextmodcheck:  
78c9 21 dc fe			ld hl,keyscan_table_row3  
78cc			  
78cc 7e				ld a, (hl)  
78cd fe 23			cp '#'  
78cf 20 07			jr nz, .nextmodcheck2  
78d1 cb c9			set 1, c   
78d3 21 59 78			ld hl, .matrix_to_symbolshift  
78d6 18 12			jr .dokeymap  
78d8			.nextmodcheck2:  
78d8 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
78db			  
78db 7e				ld a, (hl)  
78dc fe 23			cp '#'  
78de 20 07			jr nz, .donemodcheck  
78e0 cb c9			set 1, c   
78e2 21 22 78			ld hl, .matrix_to_shift  
78e5 18 03			jr .dokeymap  
78e7			  
78e7				; no modifer found so just map to normal keys  
78e7				; get mtoc map matrix to respective keys  
78e7			;	ld hl, .matrix_to_char  
78e7			;	ld hl, .matrix_to_char  
78e7			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
78e7			;	ld a, KEY_SHIFT  
78e7			;	call findchar  
78e7			;  
78e7			;	; got offset to key modifer in b  
78e7			;  
78e7			;	ld hl,keyscan_table_row5  
78e7			;  
78e7			;	ld a,b  
78e7			;	call addatohl  
78e7			;	ld a,(hl)  
78e7			;  
78e7			;	cp '#'  
78e7			;	jr nz, .nextmodcheck  
78e7			;	set 0, c  
78e7			;	ld hl, .matrix_to_char  
78e7			;	jr .dokeymap  
78e7			;	; TODO for now igonre  
78e7			;.nextmodcheck:  
78e7			;	ld hl, .matrix_to_symbolshift  
78e7			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
78e7			;	ld a, KEY_SYMBOLSHIFT  
78e7			;	call findchar  
78e7			;  
78e7			;  
78e7			;	; got offset to key modifer in b  
78e7			;  
78e7			;	ld hl,keyscan_table_row5  
78e7			;  
78e7			;	ld a,b  
78e7			;	call addatohl  
78e7			;	ld a,(hl)  
78e7			;  
78e7			;	cp '#'  
78e7			;	jr nz, .donemodcheck  
78e7			;	set 1, c   
78e7			;	ld hl, .matrix_to_symbolshift  
78e7			;	jr .dokeymap  
78e7			  
78e7			  
78e7			  
78e7			.donemodcheck:  
78e7				; no modifer found so just map to normal keys  
78e7				; get mtoc map matrix to respective keys  
78e7 21 eb 77			ld hl, .matrix_to_char  
78ea			  
78ea			.dokeymap:  
78ea				;ld (key_fa), c   
78ea cd 03 79			call .mapkeys  
78ed			  
78ed			  
78ed			if DEBUG_KEY  
78ed			  
78ed			; Display text on first line  
78ed			            LD   A, kLCD_Line1  
78ed			            CALL fLCD_Pos       ;Position cursor to location in A  
78ed			            LD   DE, keyscan_table_row1  
78ed			            ;LD   DE, MsgHello  
78ed			            CALL fLCD_Str       ;Display string pointed to by DE  
78ed			  
78ed			; Display text on second line  
78ed			            LD   A, kLCD_Line2  
78ed			            CALL fLCD_Pos       ;Position cursor to location in A  
78ed			            LD   DE, keyscan_table_row2  
78ed			            CALL fLCD_Str       ;Display string pointed to by DE  
78ed			            LD   A, kLCD_Line3  
78ed			            CALL fLCD_Pos       ;Position cursor to location in A  
78ed			            LD   DE, keyscan_table_row3  
78ed			            CALL fLCD_Str       ;Display string pointed to by DE  
78ed			            LD   A, kLCD_Line4  
78ed			            CALL fLCD_Pos       ;Position cursor to location in A  
78ed			            LD   DE, keyscan_table_row4  
78ed			            CALL fLCD_Str       ;Display string pointed to by DE  
78ed			            LD   A, kLCD_Line1+10  
78ed			            CALL fLCD_Pos       ;Position cursor to location in A  
78ed			            LD   DE, keyscan_table_row5  
78ed			            CALL fLCD_Str       ;Display string pointed to by DE  
78ed			  
78ed				;call delay250ms  
78ed			endif  
78ed			;	jp testkey  
78ed			  
78ed			; get first char reported  
78ed			  
78ed 21 c6 fe			ld hl,keyscan_table_row5  
78f0			  
78f0				;ld b, 46   ; 30 keys to remap + 8 nulls   
78f0 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
78f2			.findkey:  
78f2 7e				ld a,(hl)  
78f3 fe 00			cp 0  
78f5 28 04			jr z, .nextkey  
78f7 fe 7e			cp KEY_MATRIX_NO_PRESS  
78f9 20 06			jr nz, .foundkey  
78fb			.nextkey:  
78fb 23				inc hl  
78fc 10 f4			djnz .findkey  
78fe 3e 00			ld a,0  
7900 c9				ret  
7901			.foundkey:  
7901 7e				ld a,(hl)  
7902 c9				ret  
7903				  
7903			  
7903			; convert the raw key map given hl for destination key  
7903			.mapkeys:  
7903 11 c6 fe			ld de,keyscan_table_row5  
7906			  
7906 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7908			.remap:  
7908 1a				ld a,(de)  
7909 fe 23			cp '#'  
790b 20 02			jr nz, .remapnext  
790d				;CALLMONITOR  
790d 7e				ld a,(hl)  
790e 12				ld (de),a  
790f			  
790f			  
790f			  
790f			.remapnext:  
790f 23				inc hl  
7910 13				inc de  
7911 10 f5			djnz .remap  
7913				  
7913 c9				ret  
7914			  
7914			  
7914			  
7914			.mtocold2:  
7914			  
7914			;	; flag if key D is held down and remove from reporting  
7914			;	ld bc, .key_map_fd    
7914			;	ld hl, keyscan_table  
7914			;	ld de, key_fd  
7914			;	call .key_shift_hold  
7914			;	cp 255  
7914			;	jr z, .cinmap  
7914			;	; flag if key C is held down and remove from reporting  
7914			;	ld bc, .key_map_fc    
7914			;	ld hl, keyscan_table+key_cols  
7914			;	ld de, key_fc  
7914			;	call .key_shift_hold  
7914			;	cp 255  
7914			;	jr z, .cinmap  
7914			;	; flag if key B is held down and remove from reporting  
7914			;	ld bc, .key_map_fb    
7914			;	ld hl, keyscan_table+(key_cols*2)  
7914			;	ld de, key_fb  
7914			;	call .key_shift_hold  
7914			;	cp 255  
7914			;	jr z, .cinmap  
7914			;	; flag if key A is held down and remove from reporting  
7914			;	ld bc, .key_map_fa    
7914			;	ld hl, keyscan_table+(key_cols*3)  
7914			;	ld de, key_fa  
7914			;	call .key_shift_hold  
7914			;	cp 255  
7914			;	jr z, .cinmap  
7914			  
7914 11 eb 77			ld de, .matrix_to_char  
7917			  
7917			  
7917			.cinmap1:   
7917				if DEBUG_KEY  
7917			            LD   A, kLCD_Line4  
7917			            CALL fLCD_Pos       ;Position cursor to location in A  
7917					push de  
7917			            LD   DE, keyscan_table  
7917			            CALL fLCD_Str       ;Display string pointed to by DE  
7917					pop de  
7917				endif  
7917			  
7917				; scan key matrix table for any held key  
7917			  
7917				; de holds either the default matrix or one selected above  
7917			  
7917 21 93 fe			ld hl, keyscan_table  
791a 06 32			ld b,key_cols*key_rows  
791c			  
791c 7e			.cin11:	ld a,(hl)  
791d fe 23			cp '#'  
791f 28 08			jr z, .cinhit1  
7921 23				inc hl  
7922 13				inc de  
7923 05				dec b  
7924 20 f6			jr nz, .cin11  
7926				; no key found held  
7926 3e 00			ld a,0  
7928 c9				ret  
7929 d5			.cinhit1: push de  
792a e1				pop hl  
792b 7e				ld a,(hl)  
792c c9				ret  
792d			  
792d			; flag a control key is held   
792d			; hl is key pin, de is flag indicator  
792d			  
792d			.key_shift_hold1:  
792d c5				push bc  
792e 3e 01			ld a, 1  
7930 32 c1 fb			ld (cursor_shape),a  
7933 06 00			ld b, 0  
7935 7e				ld a, (hl)  
7936 fe 2e			cp '.'  
7938 28 0a			jr z, .key_shift11  
793a 06 ff			ld b, 255  
793c 3e 2b			ld a, '+'    ; hide key from later scans  
793e 77				ld (hl),a  
793f 3e 02			ld a, 2  
7941 32 c1 fb			ld (cursor_shape),a  
7944			.key_shift11:  
7944				; write flag indicator  
7944 78				ld a,b  
7945 12				ld (de),a  
7946			  
7946 d1				pop de    ; de now holds the key map ptr  
7947 c9				ret  
7948			  
7948				  
7948			  
7948			; scans keyboard matrix and flags key press in memory array	  
7948				  
7948			matrix:  
7948				;call matrix  
7948				; TODO optimise the code....  
7948			  
7948			  
7948			;ld hl, keyscan_table_row1  
7948			;ld de, keyscan_table_row1+1  
7948			;ld bc,46  
7948			;ld a,KEY_MATRIX_NO_PRESS  
7948			;ldir  
7948			  
7948			  
7948			  
7948			; reset counter  
7948 3e 80		ld a, 128  
794a d3 c1		out (portbdata),a  
794c			  
794c 06 0a		ld b, 10  
794e 0e 00		ld c, 0       ; current clock toggle  
7950			  
7950			.colscan:  
7950			  
7950			; set current column  
7950			; disable clock enable and set clock low  
7950			  
7950			;ld a, 0  
7950			;out (portbdata),a  
7950			  
7950			; For each column scan for switches  
7950			  
7950 c5			push bc  
7951 21 89 fe		ld hl, keyscan_scancol  
7954 cd 5d 7a		call .rowscan  
7957 c1			pop bc  
7958			  
7958			  
7958			; get back current column  
7958			  
7958			; translate the row scan  
7958			  
7958			;   
7958			; row 1  
7958			  
7958 78			ld a,b  
7959			  
7959 21 fc fe		LD   hl, keyscan_table_row1+10  
795c			  
795c cd 98 0f		call subafromhl  
795f			;call addatohl  
795f			  
795f 11 89 fe		ld de, keyscan_scancol  
7962			  
7962 1a			ld a,(de)  
7963 77			ld (hl),a  
7964			  
7964			  
7964			  
7964			  
7964			; row 2  
7964			  
7964 78			ld a,b  
7965			  
7965 21 f1 fe		LD   hl, keyscan_table_row2+10  
7968			  
7968			;call addatohl  
7968 cd 98 0f		call subafromhl  
796b			  
796b			  
796b 11 8a fe		ld de, keyscan_scancol+1  
796e			  
796e 1a			ld a,(de)  
796f 77			ld (hl),a  
7970			  
7970			  
7970			; row 3  
7970			  
7970 78			ld a,b  
7971			  
7971 21 e6 fe		LD   hl, keyscan_table_row3+10  
7974			  
7974			;call addatohl  
7974 cd 98 0f		call subafromhl  
7977			  
7977 11 8b fe		ld de, keyscan_scancol+2  
797a			  
797a 1a			ld a,(de)  
797b 77			ld (hl),a  
797c			  
797c			  
797c			  
797c			; row 4  
797c			  
797c 78			ld a,b  
797d			  
797d 21 db fe		LD   hl, keyscan_table_row4+10  
7980			  
7980			;call addatohl  
7980 cd 98 0f		call subafromhl  
7983			  
7983 11 8c fe		ld de, keyscan_scancol+3  
7986			  
7986 1a			ld a,(de)  
7987 77			ld (hl),a  
7988			  
7988			; row 5  
7988			  
7988 78			ld a,b  
7989			  
7989 21 d0 fe		LD   hl, keyscan_table_row5+10  
798c			  
798c			;call addatohl  
798c cd 98 0f		call subafromhl  
798f			  
798f 11 8d fe		ld de, keyscan_scancol+4  
7992			  
7992 1a			ld a,(de)  
7993 77			ld (hl),a  
7994			  
7994			; handshake next column  
7994			  
7994			  
7994 3e 40		ld a, 64  
7996 d3 c1		out (portbdata),a  
7998			  
7998 3e 00		ld a, 0  
799a d3 c1		out (portbdata),a  
799c			  
799c			; toggle clk and move to next column  
799c			;ld a, 64  
799c			;cp c  
799c			;  
799c			;jr z, .coltoglow  
799c			;ld c, a  
799c			;jr .coltog  
799c			;.coltoglow:  
799c			;ld c, 0  
799c			;.coltog:  
799c			;ld a, c  
799c			;out (portbdata),a  
799c			  
799c 10 b2		djnz .colscan  
799e			  
799e 3e 0a		ld a,10  
79a0 21 f2 fe		LD   hl, keyscan_table_row1  
79a3 cd 86 0f		call addatohl  
79a6 3e 00		ld a, 0  
79a8 77			ld (hl), a  
79a9			  
79a9			  
79a9 3e 0a		ld a,10  
79ab 21 e7 fe		LD   hl, keyscan_table_row2  
79ae cd 86 0f		call addatohl  
79b1 3e 00		ld a, 0  
79b3 77			ld (hl), a  
79b4			  
79b4 3e 0a		ld a,10  
79b6 21 dc fe		LD   hl, keyscan_table_row3  
79b9 cd 86 0f		call addatohl  
79bc 3e 00		ld a, 0  
79be 77			ld (hl), a  
79bf			  
79bf 3e 0a		ld a,10  
79c1 21 d1 fe		LD   hl, keyscan_table_row4  
79c4 cd 86 0f		call addatohl  
79c7 3e 00		ld a, 0  
79c9 77			ld (hl), a  
79ca			  
79ca 3e 0a		ld a,10  
79cc 21 c6 fe		LD   hl, keyscan_table_row5  
79cf cd 86 0f		call addatohl  
79d2 3e 00		ld a, 0  
79d4 77			ld (hl), a  
79d5			  
79d5			if DEBUG_KEY_MATRIX  
79d5			  
79d5			; Display text on first line  
79d5			            LD   A, kLCD_Line1  
79d5			            CALL fLCD_Pos       ;Position cursor to location in A  
79d5			            LD   DE, keyscan_table_row1  
79d5			            ;LD   DE, MsgHello  
79d5			            CALL fLCD_Str       ;Display string pointed to by DE  
79d5			  
79d5			; Display text on second line  
79d5			            LD   A, kLCD_Line2  
79d5			            CALL fLCD_Pos       ;Position cursor to location in A  
79d5			            LD   DE, keyscan_table_row2  
79d5			            CALL fLCD_Str       ;Display string pointed to by DE  
79d5			            LD   A, kLCD_Line3  
79d5			            CALL fLCD_Pos       ;Position cursor to location in A  
79d5			            LD   DE, keyscan_table_row3  
79d5			            CALL fLCD_Str       ;Display string pointed to by DE  
79d5			            LD   A, kLCD_Line4  
79d5			            CALL fLCD_Pos       ;Position cursor to location in A  
79d5			            LD   DE, keyscan_table_row4  
79d5			            CALL fLCD_Str       ;Display string pointed to by DE  
79d5			            LD   A, kLCD_Line4+10  
79d5			            CALL fLCD_Pos       ;Position cursor to location in A  
79d5			            LD   DE, keyscan_table_row5  
79d5			            CALL fLCD_Str       ;Display string pointed to by DE  
79d5			  
79d5			;call delay250ms  
79d5				jp matrix  
79d5			endif  
79d5 c9			ret  
79d6			  
79d6			; using decade counter....  
79d6			  
79d6			  
79d6			; TODO reset decade counter to start of scan  
79d6			  
79d6			; reset 15  
79d6			; clock 14  
79d6			; ce 13  
79d6			  
79d6			; 1 - q5  
79d6			; 2 - q1  
79d6			; 3 - q0  
79d6			; 4 - q2  
79d6			; 5 - q6  
79d6			; 6 - q7  
79d6			; 7 - q3  
79d6			; 8 - vss  
79d6			; 9 - q8  
79d6			; 10 - q4  
79d6			; 11 - q9  
79d6			; 12 - cout  
79d6			; 16 - vdd  
79d6			  
79d6			; clock      ce       reset     output  
79d6			; 0          x        0         n  
79d6			; x          1        0         n  
79d6			; x          x        1         q0  
79d6			; rising     0        0         n+1  
79d6			; falling    x        0         n  
79d6			; x          rising   0         n  
79d6			; 1          falling  0         x+1  
79d6			;  
79d6			; x = dont care, if n < 5 carry = 1 otherwise 0  
79d6			  
79d6			;   
79d6			; reset   
79d6			; 13=0, 14=0, 15=1 .. 15=0  
79d6			;  
79d6			; handshake line  
79d6			; 14=1.... read line 14=0  
79d6			  
79d6			  
79d6			  
79d6			  
79d6			  
79d6			; TODO hand shake clock for next column scan  
79d6			; TODO detect each row  
79d6			  
79d6			  
79d6			  
79d6			  
79d6			; reset 128  
79d6			; clock 64  
79d6			; ce 32  
79d6			  
79d6			  
79d6			.cyclestart:  
79d6			  
79d6			; reset counter  
79d6 3e 80		ld a, 128  
79d8 d3 c1		out (portbdata),a  
79da			  
79da			; loop leds  
79da 06 0a		ld b,10  
79dc			  
79dc			.cycle1:  
79dc c5			push bc  
79dd 3e 00		ld a, 0  
79df d3 c1		out (portbdata),a  
79e1 cd 89 0c		call delay250ms  
79e4			  
79e4 3e 40		ld a, 64  
79e6 d3 c1		out (portbdata),a  
79e8 cd 89 0c		call delay250ms  
79eb			  
79eb 3e 00		ld a, 0  
79ed d3 c1		out (portbdata),a  
79ef cd 89 0c		call delay250ms  
79f2			  
79f2 c1			pop bc  
79f3 10 e7		djnz .cycle1  
79f5			  
79f5			  
79f5 18 df		jr .cyclestart  
79f7			  
79f7			  
79f7			  
79f7			  
79f7			  
79f7			  
79f7			  
79f7			  
79f7			  
79f7			; map matrix key held to char on face of key  
79f7			  
79f7			;.mtocold:  
79f7			;  
79f7			;  
79f7			;; reset counter  
79f7			;ld a, 128  
79f7			;out (portbdata),a  
79f7			;  
79f7			;  
79f7			;; scan keyboard row 1  
79f7			;ld a, 0  
79f7			;out (portbdata),a  
79f7			;;ld a, 64  
79f7			;;out (portbdata),a  
79f7			;  
79f7			;  
79f7			;	ld a, 128  
79f7			;	ld hl, keyscan_table  
79f7			;	call .rowscan  
79f7			;  
79f7			;;ld a, 0  
79f7			;;out (portbdata),a  
79f7			;ld a, 64  
79f7			;out (portbdata),a  
79f7			;  
79f7			;	ld a, 64  
79f7			;	ld hl, keyscan_table+key_cols  
79f7			;	call .rowscan  
79f7			;  
79f7			;ld a, 0  
79f7			;out (portbdata),a  
79f7			;;ld a, 64  
79f7			;;out (portbdata),a  
79f7			;	ld a, 32  
79f7			;	ld hl, keyscan_table+(key_cols*2)  
79f7			;	call .rowscan  
79f7			;  
79f7			;  
79f7			;;ld a, 0  
79f7			;;out (portbdata),a  
79f7			;ld a, 64  
79f7			;out (portbdata),a  
79f7			;  
79f7			;	ld a, 16  
79f7			;	ld hl, keyscan_table+(key_cols*3)  
79f7			;	call .rowscan  
79f7			;  
79f7			;  
79f7			;	; flag if key D is held down and remove from reporting  
79f7			;	ld bc, .key_map_fd    
79f7			;	ld hl, keyscan_table  
79f7			;	ld de, key_fd  
79f7			;	call .key_shift_hold  
79f7			;	cp 255  
79f7			;	jr z, .cinmap  
79f7			;	; flag if key C is held down and remove from reporting  
79f7			;	ld bc, .key_map_fc    
79f7			;	ld hl, keyscan_table+key_cols  
79f7			;	ld de, key_fc  
79f7			;	call .key_shift_hold  
79f7			;	cp 255  
79f7			;	jr z, .cinmap  
79f7			;	; flag if key B is held down and remove from reporting  
79f7			;	ld bc, .key_map_fb    
79f7			;	ld hl, keyscan_table+(key_cols*2)  
79f7			;	ld de, key_fb  
79f7			;	call .key_shift_hold  
79f7			;	cp 255  
79f7			;	jr z, .cinmap  
79f7			;	; flag if key A is held down and remove from reporting  
79f7			;	ld bc, .key_map_fa    
79f7			;	ld hl, keyscan_table+(key_cols*3)  
79f7			;	ld de, key_fa  
79f7			;	call .key_shift_hold  
79f7			;	cp 255  
79f7			;	jr z, .cinmap  
79f7			;  
79f7			;	ld de, .matrix_to_char  
79f7			;  
79f7			;  
79f7			;.cinmap:   
79f7			;	if DEBUG_KEY  
79f7			;            LD   A, kLCD_Line4  
79f7			;            CALL fLCD_Pos       ;Position cursor to location in A  
79f7			;		push de  
79f7			;            LD   DE, keyscan_table  
79f7			;            CALL fLCD_Str       ;Display string pointed to by DE  
79f7			;		pop de  
79f7			;	endif  
79f7			  
79f7				; scan key matrix table for any held key  
79f7			  
79f7				; de holds either the default matrix or one selected above  
79f7			  
79f7			;	ld hl, keyscan_table  
79f7			;	ld b,key_cols*key_rows  
79f7			;  
79f7			;.cin1:	ld a,(hl)  
79f7			;	cp '#'  
79f7			;	jr z, .cinhit  
79f7			;	inc hl  
79f7			;	inc de  
79f7			;	dec b  
79f7			;	jr nz, .cin1  
79f7			;	; no key found held  
79f7			;	ld a,0  
79f7			;	ret  
79f7			;.cinhit: push de  
79f7			;	pop hl  
79f7			;	ld a,(hl)  
79f7			;	ret  
79f7			  
79f7			; flag a control key is held   
79f7			; hl is key pin, de is flag indicator  
79f7			  
79f7			;.key_shift_hold:  
79f7			;	push bc  
79f7			;	ld a, 1  
79f7			;	ld (cursor_shape),a  
79f7			;	ld b, 0  
79f7			;	ld a, (hl)  
79f7			;	cp '.'  
79f7			;	jr z, .key_shift1  
79f7			;	ld b, 255  
79f7			;	ld a, '+'    ; hide key from later scans  
79f7			;	ld (hl),a  
79f7			;	ld a, 2  
79f7			;	ld (cursor_shape),a  
79f7			;.key_shift1:  
79f7			;	; write flag indicator  
79f7			;	ld a,b  
79f7			;	ld (de),a  
79f7			;  
79f7			;	pop de    ; de now holds the key map ptr  
79f7			;	ret  
79f7			  
79f7				  
79f7				  
79f7			  
79f7			  
79f7			  
79f7			  
79f7			  
79f7			  
79f7			  
79f7			  
79f7			  
79f7			  
79f7			  
79f7			;	push hl  
79f7			;	push de  
79f7			;	push bc  
79f7			;	call keyscan  
79f7			;	; map key matrix to ascii value of key face  
79f7			;  
79f7			;	ld hl, key_face_map  
79f7			;	ld de, keyscan_table  
79f7			;  
79f7			;	; get how many keys to look at  
79f7			;	ld b, keyscan_table_len  
79f7			;	  
79f7			;  
79f7			;	; at this stage fall out on first key hit  
79f7			;	; TODO handle multiple key press  
79f7			;  
79f7			;map1:	ld a,(hl)  
79f7			;	cp '#'  
79f7			;	jr z, keyhit  
79f7			;	inc hl  
79f7			;	inc de  
79f7			;	dec b  
79f7			;	jr nz, map1  
79f7			;nohit:	ld a, 0  
79f7			;	jr keydone  
79f7			;keyhit: push de  
79f7			;	pop hl  
79f7			;	ld a,(hl)  
79f7			;keydone:  
79f7			;	push bc  
79f7			;	push de  
79f7			; 	push hl  
79f7			;	ret   
79f7			;  
79f7			  
79f7			  
79f7			  
79f7			  
79f7			; scan physical key matrix  
79f7			  
79f7			  
79f7			;keyscan:  
79f7			;  
79f7			;; for each key_row use keyscanr bit mask for out  
79f7			;; then read in for keyscanc bitmask  
79f7			;; save result of row scan to keyscantable  
79f7			;  
79f7			;; scan keyboard row 1  
79f7			;  
79f7			;	ld b, key_rows  
79f7			;	ld hl, key_scanr  
79f7			;	ld de, keyscan_table  
79f7			;  
79f7			;rowloop:  
79f7			;  
79f7			;	ld a,(hl)		; out bit mask to energise keyboard row  
79f7			;	call rowscan  
79f7			;	inc hl  
79f7			;	dec b  
79f7			;	jr nz, rowloop  
79f7			;  
79f7			;	ret  
79f7			;  
79f7			;  
79f7			;; pass a out bitmask, b row number  
79f7			;arowscan:   
79f7			;	push bc  
79f7			;  
79f7			;	ld d, b  
79f7			;  
79f7			;	; calculate buffer location for this row  
79f7			;  
79f7			;	ld hl, keyscan_table	  
79f7			;kbufr:  ld e, key_cols  
79f7			;kbufc:	inc hl  
79f7			;	dec e  
79f7			;	jr nz, kbufc  
79f7			;	dec d  
79f7			;	jr nz, kbufr  
79f7			;  
79f7			;	; energise row and read columns  
79f7			;  
79f7			;	out (portbdata),a  
79f7			;	in a,(portbdata)  
79f7			;	ld c,a  
79f7			;  
79f7			;  
79f7			;	; save buffer loc  
79f7			;  
79f7			;	ld (keybufptr), hl  
79f7			;  
79f7			;	ld hl, key_scanc  
79f7			;	ld d, key_cols  
79f7			;  
79f7			;	; for each column check each bit mask  
79f7			;  
79f7			;colloop:  
79f7			;	  
79f7			;  
79f7			;	; reset flags for the row   
79f7			;  
79f7			;	ld b,'.'  
79f7			;	and (hl)  
79f7			;	jr z, maskskip  
79f7			;	ld b,'#'  
79f7			;maskskip:  
79f7			;	; save  key state  
79f7			;	push hl  
79f7			;	ld hl, (keybufptr)  
79f7			;	ld (hl), b  
79f7			;	inc hl  
79f7			;	ld (keybufptr), hl  
79f7			;  
79f7			;	; move to next bit mask  
79f7			;	pop hl  
79f7			;	inc hl  
79f7			;  
79f7			;	dec d  
79f7			;	jr nz, colloop  
79f7			;  
79f7			;	ret  
79f7			;  
79f7			;  
79f7			;;  
79f7			; lcd functions  
79f7			;  
79f7			;  
79f7			  
79f7			;if DEBUG_KEY_MATRIX  
79f7			  
79f7			; test function to display hardware view of matrix state  
79f7			  
79f7			matrixold:  
79f7			  
79f7			  
79f7			  
79f7			; reset counter  
79f7 3e 80		ld a, 128  
79f9 d3 c1		out (portbdata),a  
79fb			; scan keyboard row 1  
79fb 3e 00		ld a, 0  
79fd d3 c1		out (portbdata),a  
79ff			;ld a, 64  
79ff			;out (portbdata),a  
79ff 3e 80			ld a, 128  
7a01 21 f2 fe			ld hl, keyscan_table_row1  
7a04 cd 5d 7a			call .rowscan  
7a07			  
7a07			;ld a, 0  
7a07			;out (portbdata),a  
7a07 3e 40		ld a, 64  
7a09 d3 c1		out (portbdata),a  
7a0b 3e 40			ld a, 64  
7a0d 21 e7 fe			ld hl, keyscan_table_row2  
7a10 cd 5d 7a			call .rowscan  
7a13			  
7a13 3e 00		ld a, 0  
7a15 d3 c1		out (portbdata),a  
7a17			;ld a, 64  
7a17			;out (portbdata),a  
7a17 3e 20			ld a, 32  
7a19 21 dc fe			ld hl, keyscan_table_row3  
7a1c cd 5d 7a			call .rowscan  
7a1f			  
7a1f			;ld a, 0  
7a1f			;out (portbdata),a  
7a1f 3e 40		ld a, 64  
7a21 d3 c1		out (portbdata),a  
7a23 3e 10			ld a, 16  
7a25 21 d1 fe			ld hl, keyscan_table_row4  
7a28 cd 5d 7a			call .rowscan  
7a2b			  
7a2b			; Display text on first line  
7a2b 3e 00		            LD   A, kLCD_Line1  
7a2d cd 65 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7a30 11 f2 fe		            LD   DE, keyscan_table_row1  
7a33			            ;LD   DE, MsgHello  
7a33 cd 87 76		            CALL fLCD_Str       ;Display string pointed to by DE  
7a36			  
7a36			; Display text on second line  
7a36 3e 28		            LD   A, kLCD_Line2  
7a38 cd 65 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7a3b 11 e7 fe		            LD   DE, keyscan_table_row2  
7a3e cd 87 76		            CALL fLCD_Str       ;Display string pointed to by DE  
7a41 3e 50		            LD   A, kLCD_Line3  
7a43 cd 65 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7a46 11 dc fe		            LD   DE, keyscan_table_row3  
7a49 cd 87 76		            CALL fLCD_Str       ;Display string pointed to by DE  
7a4c 3e 78		            LD   A, kLCD_Line4  
7a4e cd 65 76		            CALL fLCD_Pos       ;Position cursor to location in A  
7a51 11 d1 fe		            LD   DE, keyscan_table_row4  
7a54 cd 87 76		            CALL fLCD_Str       ;Display string pointed to by DE  
7a57			  
7a57 cd 89 0c			call delay250ms  
7a5a c3 48 79			jp matrix  
7a5d			  
7a5d			; pass de as row display flags  
7a5d			.rowscan:   
7a5d			;	out (portbdata),a  
7a5d db c1			in a,(portbdata)  
7a5f 4f				ld c,a  
7a60				; reset flags for the row   
7a60 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7a62 e6 01			and 1  
7a64 28 02			jr z, .p1on  
7a66 06 23			ld b,'#'  
7a68			.p1on:  
7a68 70				ld (hl), b  
7a69 23				inc hl  
7a6a			  
7a6a 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7a6c 79				ld a,c  
7a6d e6 02			and 2  
7a6f			;	bit 0,a  
7a6f 28 02			jr z, .p2on  
7a71 06 23			ld b,'#'  
7a73			.p2on:  
7a73 70				ld (hl), b  
7a74 23				inc hl  
7a75			;  
7a75 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7a77 79				ld a,c  
7a78 e6 04			and 4  
7a7a			;;	bit 0,a  
7a7a 28 02			jr z, .p3on  
7a7c 06 23			ld b,'#'  
7a7e			.p3on:  
7a7e 70				ld (hl), b  
7a7f 23				inc hl  
7a80			;;  
7a80 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7a82			;;	bit 0,a  
7a82 79				ld a,c  
7a83 e6 08			and 8  
7a85 28 02			jr z, .p4on  
7a87 06 23			ld b,'#'  
7a89			.p4on:  
7a89 70				ld (hl), b  
7a8a 23				inc hl  
7a8b			  
7a8b 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7a8d			;;	bit 0,a  
7a8d 79				ld a,c  
7a8e e6 10			and 16  
7a90 28 02			jr z, .p5on  
7a92 06 23			ld b,'#'  
7a94			.p5on:  
7a94 70				ld (hl), b  
7a95 23				inc hl  
7a96			; zero term  
7a96 06 00			ld b,0  
7a98 70				ld (hl), b  
7a99			  
7a99 c9			.rscandone: ret  
7a9a			  
7a9a			;addatohl:  
7a9a			;  
7a9a			 ;add   a, l    ; A = A+L  
7a9a			  ;  ld    l, a    ; L = A+L  
7a9a			   ; adc   a, h    ; A = A+L+H+carry  
7a9a			   ; sub   l       ; A = H+carry  
7a9a			   ; ld    h, a    ; H = H+carry  
7a9a			  
7a9a			;ret  
7a9a			; eof  
# End of file firmware_key_5x10.asm
7a9a			;include "firmware_key_4x10.asm" 
7a9a			 
7a9a			heap_size:    equ heap_end - heap_start 
7a9a			;eof 
# End of file os_mega.asm
7a9a
