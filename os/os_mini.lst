# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 69 1b			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 1  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_write_tmp-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
001c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
001c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
001c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
001c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 f9 fd				ld hl, display_fb1  
001f 22 55 fd				ld (display_fb_active), hl  
0022			  
0022 cd 15 0d				call clear_display  
0025			  
0025 21 57 fd				ld hl, display_fb2  
0028 22 55 fd				ld (display_fb_active), hl  
002b			  
002b cd 15 0d				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 4a fe				ld hl, display_fb0  
0031 22 55 fd				ld (display_fb_active), hl  
0034			  
0034 cd 15 0d				call clear_display  
0037			  
0037			  
0037 cd ee 6f				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd 37 71			call key_init  
003d cd fb 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd ec 13				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043					call sound_init  
0043				endif  
0043			  
0043				; lcd test sequence  
0043					  
0043 cd 38 0d			call update_display  
0046 cd 92 0c			call delay1s  
0049 3e 2b			ld a,'+'  
004b cd 1a 0d			call fill_display  
004e cd 38 0d			call update_display  
0051 cd 92 0c			call delay1s  
0054 3e 2a			ld a,'*'  
0056 cd 1a 0d			call fill_display  
0059 cd 38 0d			call update_display  
005c cd 92 0c			call delay1s  
005f 3e 2d			ld a,'-'  
0061 cd 1a 0d			call fill_display  
0064 cd 38 0d			call update_display  
0067 cd 92 0c			call delay1s  
006a			  
006a			; boot splash screen  
006a			if display_cols == 20	  
006a 3e 00		        ld a, display_row_1    
006c			else  
006c			        ld a, display_row_1 +10   
006c			endif  
006c 11 9c 1a			ld de, prom_bootmsg  
006f cd 28 0d			call str_at_display  
0072 cd 38 0d			call update_display  
0075			  
0075			  
0075 cd 92 0c			call delay1s  
0078 cd 92 0c			call delay1s  
007b			if display_cols == 20	  
007b 3e 2a		            LD   A, display_row_3+2  
007d			else  
007d			            LD   A, display_row_3+12  
007d			endif  
007d 11 b1 1a			ld de, prom_bootmsg1  
0080 cd 28 0d			call str_at_display  
0083 cd 38 0d			call update_display  
0086 cd 92 0c			call delay1s  
0089 cd 92 0c			call delay1s  
008c			  
008c			;	ld a, display_row_4+3  
008c			;	ld de, bootmsg2  
008c			;	call str_at_display  
008c			;	call update_display  
008c			;	call delay1s  
008c			;	call delay1s  
008c			  
008c			; debug mark setup  
008c			  
008c 3e 5f		ld a, '_'  
008e 32 b4 fe		ld (debug_mark),a  
0091 32 b5 fe		ld (debug_mark+1),a  
0094 32 b6 fe		ld (debug_mark+2),a  
0097 3e 00		ld a,0  
0099 32 b7 fe		ld (debug_mark+3),a  
009c			  
009c c9					ret  
009d			  
009d			  
009d			;bootmsg2:	db "Firmware v0.1",0  
009d			  
009d			; a 4x20 lcd  
009d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
009d			  
009d			;if display_cols == 20  
009d			;	include "firmware_lcd_4x20.asm"  
009d			;endif  
009d			  
009d			;if display_cols == 40  
009d			;	include "firmware_lcd_4x40.asm"  
009d			;endif  
009d			  
009d			;  
009d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
009d			; TODO abstract the bit bang video out interface for dual display  
009d			; TODO wire video out to tx pin on rc2014 bus  
009d			  
009d			; must supply cin, and cin_wait for low level hardware abstraction   
009d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
009d			; test scancode  
009d			  
009d			;;;;;  
009d			;;;  
009d			; Moved out to mini and maxi versions  
009d			;  
009d			; include "firmware_key_4x4.asm"  
009d			; using existing 4 wire x 4 resistor array for input  
009d			;include "firmware_key_4x10.asm"  
009d			; need to mod the board for 5 rows due to resistor array  
009d			;include "firmware_key_5x10.asm"  
009d			  
009d			; storage hardware interface  
009d			  
009d			; use microchip serial eeprom for storage  
009d			  
009d			  
009d			if STORAGE_SE  
009d				include "firmware_spi.asm"  
009d			; my spi protocol (used by storage) 
009d			 
009d			; SPI pins 
009d			 
009d			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
009d			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
009d			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
009d			 
009d			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
009d			; chip pin 4 gnd 
009d			 
009d			 
009d			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
009d			SPI_CE1: equ 1      ;    port a1 pin 14  
009d			SPI_CE2: equ 2      ;    port a2 pin pin 13 
009d			SPI_CE3: equ 3      ; port    a3 pin pin 12 
009d			SPI_CE4: equ 4      ; port a4     pin 10 
009d			 
009d			; active low AND masks 
009d			 
009d			;SPI_CE0_MASK: equ    255-1 
009d			;SPI_CE1_MASK: equ   255-2 
009d			;SPI_CE2_MASK: equ   255-4 
009d			;SPI_CE3_MASK: equ   255-8 
009d			;SPI_CE4_MASK: equ   255-16 
009d			SPI_CE_HIGH:  equ 255 
009d			 
009d			 
009d			 
009d			;  Perform SCLK wait pulse 
009d			 
009d			spi_clk: 
009d f5				push af 
009e 3a f1 fb			ld a, (spi_clktime) 
00a1 fe 00			cp 0 
00a3 28 03			jr z, .scskip 
00a5 cd 77 0c			call aDelayInMS 
00a8			.scskip: 
00a8 f1				pop af 
00a9 c9				ret 
00aa			 
00aa			 
00aa			 
00aa			; TODO store port id for spi device ie dev c 
00aa			; TODO store pin for SO 
00aa			; TODO store pin for SI 
00aa			; TODO store pin for SCLK 
00aa			 
00aa			; 
00aa			 
00aa			; ensure that spi bus is in a stable state with default pins  
00aa			 
00aa			se_stable_spi:   
00aa			 
00aa				 ; set DI high, CE high , SCLK low 
00aa				;ld a, SPI_DI | SPI_CE0 
00aa 3e 07			ld a, SPI_DI  
00ac cd b6 01			call spi_ce_high 
00af d3 80			 out (storage_adata),a 
00b1 32 ee fb			ld (spi_portbyte),a 
00b4			 
00b4				if DEBUG_SPI 
00b4					push hl 
00b4					ld l, a 
00b4					DMARK "SPI" 
00b4					CALLMONITOR 
00b4					pop hl 
00b4				endif 
00b4 c9				ret 
00b5			 
00b5			; byte to send in a 
00b5			 
00b5			spi_send_byte: 
00b5				; save byte to send for bit mask shift out 
00b5 4f			        ld c,a 
00b6 3a ee fb			ld a,(spi_portbyte) 
00b9				  
00b9				; clock out	each bit of the byte msb first 
00b9			 
00b9 06 08			ld b, 8 
00bb			.ssb1: 
00bb				; clear so bit  
00bb cb bf			res SPI_DI, a 
00bd cb 11			rl c 
00bf				; if bit 7 is set then carry is set 
00bf 30 02			jr nc, .ssb2 
00c1 cb ff			set SPI_DI,a 
00c3			.ssb2:  ; output bit to ensure it is stable 
00c3 d3 80			out (storage_adata),a 
00c5 00				nop 
00c6				; clock bit high 
00c6 cb ef			set SPI_SCLK,a 
00c8 d3 80			out (storage_adata),a 
00ca 00				nop 
00cb cd 9d 00			call spi_clk 
00ce				; then low 
00ce cb af			res SPI_SCLK,a 
00d0 d3 80			out (storage_adata),a 
00d2 00				nop 
00d3 cd 9d 00			call spi_clk 
00d6 10 e3			djnz .ssb1 
00d8			 
00d8 32 ee fb			ld (spi_portbyte),a 
00db c9				ret 
00dc			 
00dc			; TODO low level get byte into A on spi 
00dc			 
00dc			spi_read_byte:  
00dc			 
00dc				; save byte to send for bit mask shift out 
00dc 0e 00		    ld c,0 
00de 3a ee fb			ld a,(spi_portbyte) 
00e1				  
00e1				; clock out	each bit of the byte msb first 
00e1			 
00e1			 
00e1				; clock bit high 
00e1 cb ef			set SPI_SCLK,a 
00e3 d3 80			out (storage_adata),a 
00e5 00				nop 
00e6 cd 9d 00			call spi_clk 
00e9			 
00e9			    ; read DO  
00e9			 
00e9 cb f9		    set 7,c 
00eb db 80			in a,(storage_adata) 
00ed cb 77		    bit SPI_DO,a 
00ef 20 02		    jr nz, .b7 
00f1 cb b9		    res 7,c 
00f3			.b7: 
00f3				; then low 
00f3 cb af			res SPI_SCLK,a 
00f5 d3 80			out (storage_adata),a 
00f7 00				nop 
00f8 cd 9d 00			call spi_clk 
00fb			     
00fb			 
00fb				; clock bit high 
00fb cb ef			set SPI_SCLK,a 
00fd d3 80			out (storage_adata),a 
00ff 00				nop 
0100 cd 9d 00			call spi_clk 
0103			 
0103			    ; read DO  
0103			 
0103 cb f1		    set 6,c 
0105 db 80			in a,(storage_adata) 
0107 cb 77		    bit SPI_DO,a 
0109 20 02		    jr nz, .b6 
010b cb b1		    res 6,c 
010d			.b6: 
010d				; then low 
010d cb af			res SPI_SCLK,a 
010f d3 80			out (storage_adata),a 
0111 00				nop 
0112 cd 9d 00			call spi_clk 
0115			 
0115				; clock bit high 
0115 cb ef			set SPI_SCLK,a 
0117 d3 80			out (storage_adata),a 
0119 00				nop 
011a cd 9d 00			call spi_clk 
011d			 
011d			 
011d			    ; read DO  
011d			 
011d cb e9		    set 5,c 
011f db 80			in a,(storage_adata) 
0121 cb 77		    bit SPI_DO,a 
0123 20 02		    jr nz, .b5 
0125 cb a9		    res 5,c 
0127			.b5: 
0127				; then low 
0127 cb af			res SPI_SCLK,a 
0129 d3 80			out (storage_adata),a 
012b 00				nop 
012c cd 9d 00			call spi_clk 
012f				; clock bit high 
012f cb ef			set SPI_SCLK,a 
0131 d3 80			out (storage_adata),a 
0133 00				nop 
0134 cd 9d 00			call spi_clk 
0137			 
0137			    ; read DO  
0137			 
0137 cb e1		    set 4,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b4 
013f cb a1		    res 4,c 
0141			.b4: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146 cd 9d 00			call spi_clk 
0149				; clock bit high 
0149 cb ef			set SPI_SCLK,a 
014b d3 80			out (storage_adata),a 
014d 00				nop 
014e cd 9d 00			call spi_clk 
0151			 
0151			    ; read DO  
0151			 
0151 cb d9		    set 3,c 
0153 db 80			in a,(storage_adata) 
0155 cb 77		    bit SPI_DO,a 
0157 20 02		    jr nz, .b3 
0159 cb 99		    res 3,c 
015b			.b3: 
015b				; then low 
015b cb af			res SPI_SCLK,a 
015d d3 80			out (storage_adata),a 
015f 00				nop 
0160 cd 9d 00			call spi_clk 
0163				; clock bit high 
0163 cb ef			set SPI_SCLK,a 
0165 d3 80			out (storage_adata),a 
0167 00				nop 
0168 cd 9d 00			call spi_clk 
016b			 
016b			    ; read DO  
016b			 
016b cb d1		    set 2,c 
016d db 80			in a,(storage_adata) 
016f cb 77		    bit SPI_DO,a 
0171 20 02		    jr nz, .b2 
0173 cb 91		    res 2,c 
0175			.b2: 
0175				; then low 
0175 cb af			res SPI_SCLK,a 
0177 d3 80			out (storage_adata),a 
0179 00				nop 
017a cd 9d 00			call spi_clk 
017d				; clock bit high 
017d cb ef			set SPI_SCLK,a 
017f d3 80			out (storage_adata),a 
0181 00				nop 
0182 cd 9d 00			call spi_clk 
0185			 
0185			    ; read DO  
0185			 
0185 cb c9		    set 1,c 
0187 db 80			in a,(storage_adata) 
0189 cb 77		    bit SPI_DO,a 
018b 20 02		    jr nz, .b1 
018d cb 89		    res 1,c 
018f			.b1: 
018f				; then low 
018f cb af			res SPI_SCLK,a 
0191 d3 80			out (storage_adata),a 
0193 00				nop 
0194 cd 9d 00			call spi_clk 
0197				; clock bit high 
0197 cb ef			set SPI_SCLK,a 
0199 d3 80			out (storage_adata),a 
019b 00				nop 
019c cd 9d 00			call spi_clk 
019f			 
019f			    ; read DO  
019f			 
019f cb c1		    set 0,c 
01a1 db 80			in a,(storage_adata) 
01a3 cb 77		    bit SPI_DO,a 
01a5 20 02		    jr nz, .b0 
01a7 cb 81		    res 0,c 
01a9			.b0: 
01a9				; then low 
01a9 cb af			res SPI_SCLK,a 
01ab d3 80			out (storage_adata),a 
01ad 00				nop 
01ae cd 9d 00			call spi_clk 
01b1			 
01b1			 
01b1 32 ee fb			ld (spi_portbyte),a 
01b4			 
01b4			    ; return byte 
01b4 79			    ld a,c 
01b5			 
01b5			 
01b5 c9				ret 
01b6			 
01b6			 
01b6			 
01b6			spi_ce_high: 
01b6			 
01b6				if DEBUG_SPI_HARD_CE0 
01b6			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01b6					ret 
01b6			 
01b6				endif 
01b6			 
01b6			 
01b6 f5				push af 
01b7			 
01b7				; send direct ce to port b 
01b7 3e ff			ld a, 255 
01b9 d3 81			out (storage_bdata), a 
01bb			 
01bb f1				pop af 
01bc			 
01bc				; for port a that shares with spi lines AND the mask 
01bc			  
01bc				if DEBUG_SPI 
01bc					push hl 
01bc					ld h, a 
01bc				endif 
01bc			;	ld c, SPI_CE_HIGH 
01bc			;	and c 
01bc cb c7			set SPI_CE0, a 
01be cb cf			set SPI_CE1, a 
01c0 cb d7			set SPI_CE2, a 
01c2 cb df			set SPI_CE3, a 
01c4 cb e7			set SPI_CE4, a 
01c6			 
01c6				if DEBUG_SPI 
01c6					ld l, a 
01c6					DMARK "CEh" 
01c6					CALLMONITOR 
01c6					pop hl 
01c6				endif 
01c6 c9				ret 
01c7			 
01c7			 
01c7			spi_ce_low: 
01c7			 
01c7				if DEBUG_SPI_HARD_CE0 
01c7			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01c7					ret 
01c7			 
01c7				endif 
01c7			 
01c7 c5				push bc 
01c8 f5				push af 
01c9			 
01c9				; send direct ce to port b 
01c9 3a f0 fb			ld a, (spi_cartdev) 
01cc d3 81			out (storage_bdata), a 
01ce			 
01ce			 
01ce			 
01ce				; for port a that shares with spi lines AND the mask 
01ce			 
01ce 3a ed fb			ld a, (spi_device)  
01d1 4f				ld c, a 
01d2			 
01d2 f1				pop af 
01d3			 
01d3				; detect CEx 
01d3			 
01d3				if DEBUG_SPI 
01d3					push hl 
01d3					ld h, a 
01d3				endif 
01d3			 
01d3 cb 41			bit SPI_CE0, c 
01d5 20 04			jr nz, .cel1 
01d7 cb 87			res SPI_CE0, a 
01d9 18 1e			jr .celn 
01db			.cel1: 
01db cb 49			bit SPI_CE1, c 
01dd 20 04			jr nz, .cel2 
01df cb 8f			res SPI_CE1, a 
01e1 18 16			jr .celn 
01e3			.cel2: 
01e3 cb 51			bit SPI_CE2, c 
01e5 20 04			jr nz, .cel3 
01e7 cb 97			res SPI_CE2, a 
01e9 18 0e			jr .celn 
01eb			.cel3: 
01eb cb 59			bit SPI_CE3, c 
01ed 20 04			jr nz, .cel4 
01ef cb 9f			res SPI_CE3, a 
01f1 18 06			jr .celn 
01f3			.cel4: 
01f3 cb 61			bit SPI_CE4, c 
01f5 20 02			jr nz, .celn 
01f7 cb a7			res SPI_CE4, a 
01f9			.celn: 
01f9			 
01f9			 
01f9			 
01f9			;	add c 
01f9			 
01f9				if DEBUG_SPI 
01f9					ld l, a 
01f9					DMARK "CEl" 
01f9					CALLMONITOR 
01f9					pop hl 
01f9				endif 
01f9 c1				pop bc 
01fa c9				ret 
01fb			 
01fb			 
01fb			 
01fb			; eof 
01fb			 
01fb			 
01fb			 
01fb			 
01fb			 
# End of file firmware_spi.asm
01fb				include "firmware_seeprom.asm"  
01fb			; 
01fb			; persisent storage interface via microchip serial eeprom 
01fb			 
01fb			; port a pio 2 
01fb			; pa 7 - si 
01fb			; pa 6 - sclk  
01fb			; pa 5 - so 
01fb			; pa 4 - cs 
01fb			; pa 3 - cs 
01fb			; pa 2 - cs 
01fb			; pa 1 - cs 
01fb			; pa 0 - cs 
01fb			; 
01fb			; TODO get block 
01fb			; TODO save block 
01fb			; TODO load file 
01fb			; TODO save file 
01fb			; TODO get dir  
01fb			 
01fb			;  
01fb			storage_adata: equ Device_C    ; device c port a - onboard storage 
01fb			storage_actl: equ Device_C+2     ; device c port a 
01fb			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01fb			storage_bctl: equ Device_C+3     ; device c port b 
01fb			 
01fb			 
01fb			; TODO move these to hardware driver file 
01fb			 
01fb			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01fb			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01fb			; storage bank file system format 
01fb			; 
01fb			; first page of bank: 
01fb			; 	addr 0 - status check 
01fb			;       addr 1 - write protect flag 
01fb			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01fb			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01fb			;         TODO see if scanning whole of for available next file id is fast enough 
01fb			;	addr 4 > zero term string of bank label 
01fb			; 
01fb			;        
01fb			;  
01fb			; first page of any file: 
01fb			;      byte 0 - file id  
01fb			;      byte 1-17 - fixed file name  
01fb			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01fb			; 
01fb			; other pages of any file: 
01fb			;      byte 0 - file id 
01fb			;      byte 1> - file data 
01fb			; 
01fb			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01fb			;  
01fb			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01fb			 
01fb			 
01fb			;storage_so_bit: 5 
01fb			;storage_si_bit: 7 
01fb			;storage_sclk_bit: 6 
01fb			  
01fb			 
01fb			; init storage pio 
01fb			 
01fb			storage_init: 
01fb			 
01fb			 
01fb					; set default SPI clk pulse time as disabled 
01fb			 
01fb 3e 00				ld a, 0 
01fd 32 f1 fb				ld (spi_clktime), a 
0200			 
0200					; init hardware 
0200			 
0200 3e cf		            LD   A, 11001111b 
0202 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0204 3e 00		            LD   A, 00000000b 
0206 cb f7			set SPI_DO,a 
0208			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0208 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
020a			 
020a 3e cf		            LD   A, 11001111b 
020c d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
020e 3e 00		            LD   A, 00000000b 
0210 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
0212			 
0212				; set all external spi devices off  
0212 3e ff			ld a, 255 
0214 32 ed fb			ld (spi_device), a 
0217 32 f0 fb			ld (spi_cartdev), a 
021a			 
021a					; ensure the spi bus is in a default stable state 
021a cd aa 00				call se_stable_spi 
021d			 
021d			; TODO scan spi bus and gather which storage banks are present 
021d			 
021d			; populate store_bank_active  
021d			; for each ce line activate and attempt to write first byte of bank and read back 
021d			; if zero is returned then bank is empty 
021d			;   
021d			; 
021d			 
021d					; init file extent cache to save on slow reads 
021d			 
021d			;	ld hl, store_filecache 
021d			;	ld de, 0 
021d			;	ld hl,(de)	 
021d			 
021d			 
021d c9			    ret 
021e			 
021e			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
021e			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
021e			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
021e			 
021e			; INSTRUCTION SET 
021e			; READ 0000 0011 Read data from memory array beginning at selected address 
021e			; WRITE 0000 0010 Write data to memory array beginning at selected address 
021e			; WREN 0000 0110 Set the write enable latch (enable write operations) 
021e			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
021e			; RDSR 0000 0101 Read STATUS register 
021e			; WRSR 0000 0001 Write STATUS register 
021e			; PE 0100 0010 Page Erase – erase one page in memory array 
021e			; SE 1101 1000 Sector Erase – erase one sector in memory array 
021e			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
021e			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
021e			 
021e			; TODO send byte steam for page without setting the address for every single byte 
021e			; TODO read byte  
021e			 
021e			; byte in a 
021e			; address in hl  
021e			se_writebyte: 
021e			        
021e			    ;   ld c, a 
021e f5			        push af 
021f e5			        push hl 
0220			 
0220			    ; initi write mode 
0220			    ; 
0220			    ;CS low 
0220			 
0220 3a ee fb		       ld a,(spi_portbyte) 
0223 cd c7 01			call spi_ce_low 
0226			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0226 d3 80		       out (storage_adata),a 
0228 32 ee fb		       ld (spi_portbyte), a 
022b			 
022b			    ;clock out wren instruction 
022b			 
022b 3e 06		    ld a, store_wren_ins 
022d cd b5 00		    call spi_send_byte  
0230			 
0230			    ;cs high to enable write latch 
0230			 
0230 3a ee fb		       ld a,(spi_portbyte) 
0233 cd b6 01			call spi_ce_high 
0236			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0236 d3 80		       out (storage_adata),a 
0238 32 ee fb		       ld (spi_portbyte), a 
023b			 
023b 00				nop 
023c			    ; 
023c			    ; intial write data 
023c			    ; 
023c			    ; cs low 
023c			     
023c 3a ee fb		       ld a,(spi_portbyte) 
023f cd c7 01			call spi_ce_low 
0242			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0242 d3 80		       out (storage_adata),a 
0244 32 ee fb		       ld (spi_portbyte), a 
0247			 
0247			    ; clock out write instruction 
0247			     
0247 3e 02		    ld a, store_write_ins  
0249 cd b5 00		    call spi_send_byte  
024c			 
024c			    ; clock out address (depending on address size) 
024c			     
024c e1			    pop hl 
024d 7c			    ld a,h    ; address out msb first 
024e cd b5 00		    call spi_send_byte  
0251 7d			    ld a,l 
0252 cd b5 00		    call spi_send_byte  
0255			 
0255			    ; clock out byte(s) for page 
0255			 
0255 f1			    pop af 
0256 cd b5 00		    call spi_send_byte  
0259			 
0259			    ; end write with ce high 
0259 3a ee fb		       ld a,(spi_portbyte) 
025c			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
025c cd b6 01			call spi_ce_high 
025f d3 80		       out (storage_adata),a 
0261 32 ee fb		       ld (spi_portbyte), a 
0264			 
0264				; pause for internal write cycle 
0264 3e 0a			ld a, 10 
0266 cd 77 0c			call aDelayInMS 
0269 c9			    ret 
026a			 
026a			; buffer to write in de 
026a			; address in hl  
026a			se_writepage: 
026a			        
026a			    ;   ld c, a 
026a d5				push de 
026b e5			        push hl 
026c			 
026c			    ; initi write mode 
026c			    ; 
026c			    ;CS low 
026c			 
026c 3a ee fb		       ld a,(spi_portbyte) 
026f cd c7 01			call spi_ce_low 
0272			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0272 d3 80		       out (storage_adata),a 
0274 32 ee fb		       ld (spi_portbyte), a 
0277			 
0277			    ;clock out wren instruction 
0277			 
0277 3e 06		    ld a, store_wren_ins 
0279 cd b5 00		    call spi_send_byte  
027c			 
027c			    ;cs high to enable write latch 
027c			 
027c 3a ee fb		       ld a,(spi_portbyte) 
027f cd b6 01			call spi_ce_high 
0282			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0282 d3 80		       out (storage_adata),a 
0284 32 ee fb		       ld (spi_portbyte), a 
0287			 
0287 00				nop 
0288			    ; 
0288			    ; intial write data 
0288			    ; 
0288			    ; cs low 
0288			     
0288 3a ee fb		       ld a,(spi_portbyte) 
028b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028b cd c7 01			call spi_ce_low 
028e d3 80		       out (storage_adata),a 
0290 32 ee fb		       ld (spi_portbyte), a 
0293			 
0293			    ; clock out write instruction 
0293			     
0293 3e 02		    ld a, store_write_ins  
0295 cd b5 00		    call spi_send_byte  
0298			 
0298			    ; clock out address (depending on address size) 
0298			     
0298 e1			    pop hl 
0299 7c			    ld a,h    ; address out msb first 
029a cd b5 00		    call spi_send_byte  
029d 7d			    ld a,l 
029e cd b5 00		    call spi_send_byte  
02a1			 
02a1			    ; clock out byte(s) for page 
02a1			 
02a1 e1				pop hl 
02a2 06 40			ld b, STORE_BLOCK_PHY 
02a4			.bytewrite: 
02a4			 
02a4 7e				ld a,(hl) 
02a5 e5			    push hl 
02a6 c5				push bc 
02a7 cd b5 00		    call spi_send_byte  
02aa c1				pop bc 
02ab e1				pop hl 
02ac			 
02ac			    ; end write with ce high 
02ac 3a ee fb		       ld a,(spi_portbyte) 
02af cd b6 01			call spi_ce_high 
02b2			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b2 d3 80		       out (storage_adata),a 
02b4 32 ee fb		       ld (spi_portbyte), a 
02b7			 
02b7 23				inc hl 
02b8 10 ea			djnz .bytewrite 
02ba			 
02ba				; pause for internal write cycle 
02ba 3e 64			ld a, 100 
02bc cd 77 0c			call aDelayInMS 
02bf c9			    ret 
02c0			; returns byte in a 
02c0			; address in hl  
02c0			se_readbyte: 
02c0 d5				push de 
02c1 c5				push bc 
02c2			 
02c2			    ;   ld c, a 
02c2 e5			        push hl 
02c3			 
02c3			    ; initi write mode 
02c3			    ; 
02c3			    ;CS low 
02c3			 
02c3 3a ee fb		       ld a,(spi_portbyte) 
02c6 cd c7 01			call spi_ce_low 
02c9			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02c9 d3 80		       out (storage_adata),a 
02cb 32 ee fb		       ld (spi_portbyte), a 
02ce			 
02ce			    ;clock out wren instruction 
02ce			 
02ce 3e 03		    ld a, store_read_ins 
02d0 cd b5 00		    call spi_send_byte  
02d3			 
02d3			 
02d3			    ; clock out address (depending on address size) 
02d3			     
02d3 e1			    pop hl 
02d4 7c			    ld a,h    ; address out msb first 
02d5 cd b5 00		    call spi_send_byte  
02d8 7d			    ld a,l 
02d9 cd b5 00		    call spi_send_byte  
02dc			 
02dc			    ; clock in byte(s) for page 
02dc			 
02dc cd dc 00		    call spi_read_byte  
02df f5				push af 
02e0			 
02e0			    ; end write with ce high 
02e0 3a ee fb		       ld a,(spi_portbyte) 
02e3			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02e3 cd b6 01			call spi_ce_high 
02e6 d3 80		       out (storage_adata),a 
02e8 32 ee fb		       ld (spi_portbyte), a 
02eb			 
02eb f1				pop af 
02ec			 
02ec c1				pop bc 
02ed d1				pop de 
02ee			 
02ee c9			    ret 
02ef			 
02ef			if DEBUG_STORESE 
02ef			 
02ef			storageput:  
02ef			 
02ef			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02ef			 
02ef 21 50 f3			ld hl,scratch+2 
02f2 cd 00 13			call get_word_hl 
02f5			 
02f5				; stuff it here for the moment as it will be overwritten later anyway 
02f5			 
02f5 22 71 f6			ld (os_cur_ptr),hl	 
02f8			 
02f8			 
02f8			; get pointer to start of string 
02f8			 
02f8 21 55 f3			ld hl, scratch+7 
02fb			 
02fb			; loop writing char of string to eeprom 
02fb			 
02fb 7e			.writestr:	ld a,(hl) 
02fc fe 00				cp 0 
02fe 28 12				jr z, .wsdone		; done writing 
0300 e5					push hl 
0301 2a 71 f6				ld hl,(os_cur_ptr) 
0304 cd 1e 02				call se_writebyte 
0307			 
0307 2a 71 f6				ld hl,(os_cur_ptr)	 ; save next eeprom address 
030a 23					inc hl 
030b 22 71 f6				ld (os_cur_ptr),hl 
030e			 
030e					; restore string pointer and get next char 
030e			 
030e e1					pop hl 
030f 23					inc hl 
0310 18 e9				jr .writestr 
0312			 
0312			 
0312			 
0312			.wsdone: 
0312			 
0312			 
0312			; when done load first page into a buffer  
0312			 
0312 21 00 80				ld hl,08000h		; start in ram 
0315 22 71 f6				ld (os_cur_ptr),hl 
0318 21 00 00				ld hl, 0		 ; start of page 
031b 22 76 f3				ld (scratch+40),hl	; hang on to it 
031e			 
031e 06 80				ld b, 128		; actually get more then one page 
0320 c5			.wsload:	push bc 
0321 2a 76 f3				ld hl,(scratch+40) 
0324 e5					push hl 
0325 cd c0 02				call se_readbyte 
0328			 
0328					; a now as the byte 
0328			 
0328 2a 71 f6				ld hl,(os_cur_ptr) 
032b 77					ld (hl),a 
032c					; inc next buffer area 
032c 23					inc hl 
032d 22 71 f6				ld (os_cur_ptr),hl 
0330			 
0330					; get eeprom position, inc and save for next round 
0330 e1					pop hl		 
0331 23					inc hl 
0332 22 76 f3				ld (scratch+40),hl 
0335 c1					pop bc 
0336 10 e8				djnz .wsload 
0338			 
0338			; set 'd' pointer to start of buffer 
0338			 
0338 21 00 80				ld hl,08000h 
033b 22 71 f6				ld (os_cur_ptr),hl 
033e			 
033e			 
033e c9			ret 
033f			 
033f			 
033f c9			storageread: ret 
0340			 
0340			 
0340			 
0340			 
0340			 
0340			 
0340			endif 
0340			 
0340			 
0340			 
# End of file firmware_seeprom.asm
0340			else  
0340			   ; create some stubs for the labels  
0340			se_readbyte: ret  
0340			se_writebyte: ret  
0340			storage_init: ret  
0340			  
0340			endif  
0340			  
0340			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0340			;include "firmware_cf.asm"  
0340			  
0340			; load up high level storage hardward abstractions  
0340			include "firmware_storage.asm"  
0340			 
0340			; persisent storage hardware abstraction layer  
0340			 
0340			 
0340			 
0340			; Block 0 on storage is a config state 
0340			 
0340			 
0340			 
0340			; TODO add read phy block and write phy block functions 
0340			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0340			 
0340			; Abstraction layer  
0340			 
0340			; Logocial block size is same size as physical size - using tape concept 
0340			 
0340			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0340			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0340			 
0340			 
0340			 
0340			; Filesystem layout (Logical layout) 
0340			; 
0340			; Block 0 - Bank config  
0340			; 
0340			;      Byte - 0 file id counter 
0340			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0340			;      Byte - 3-20 zero terminated bank label 
0340			; 
0340			; Block 1 > File storage 
0340			; 
0340			;      Byte 0 file id    - block 0 file details 
0340			;      Byte 1 block id - block 0 is file  
0340			;            Byte 2-15 - File name 
0340			; 
0340			;       - to end of block data 
0340			; 
0340			 
0340			; Get ID for the file named in pointer held HL 
0340			; Returns ID in HL = 255 if no file found 
0340			 
0340			storage_getid: 
0340			 
0340 22 00 fc			ld (store_tmp1), hl 
0343			 
0343				if DEBUG_STORESE 
0343					DMARK "SGI" 
0343 f5				push af  
0344 3a 58 03			ld a, (.dmark)  
0347 32 b4 fe			ld (debug_mark),a  
034a 3a 59 03			ld a, (.dmark+1)  
034d 32 b5 fe			ld (debug_mark+1),a  
0350 3a 5a 03			ld a, (.dmark+2)  
0353 32 b6 fe			ld (debug_mark+2),a  
0356 18 03			jr .pastdmark  
0358 ..			.dmark: db "SGI"  
035b f1			.pastdmark: pop af  
035c			endm  
# End of macro DMARK
035c					CALLMONITOR 
035c cd c6 18			call break_point_state  
035f				endm  
# End of macro CALLMONITOR
035f				endif 
035f				; get block 0 and set counter for number of files to scan 
035f			 
035f cd ca 04			call storage_get_block_0 
0362			 
0362 3a 07 fc			ld a, (store_page) 
0365 47				ld b, a 
0366			 
0366				; get extent 0 of each file id 
0366			 
0366				if DEBUG_STORESE 
0366					DMARK "SGc" 
0366 f5				push af  
0367 3a 7b 03			ld a, (.dmark)  
036a 32 b4 fe			ld (debug_mark),a  
036d 3a 7c 03			ld a, (.dmark+1)  
0370 32 b5 fe			ld (debug_mark+1),a  
0373 3a 7d 03			ld a, (.dmark+2)  
0376 32 b6 fe			ld (debug_mark+2),a  
0379 18 03			jr .pastdmark  
037b ..			.dmark: db "SGc"  
037e f1			.pastdmark: pop af  
037f			endm  
# End of macro DMARK
037f					CALLMONITOR 
037f cd c6 18			call break_point_state  
0382				endm  
# End of macro CALLMONITOR
0382				endif 
0382 60			.getloop:	ld h, b 
0383 2e 00				ld l, 0 
0385 c5					push bc 
0386			 
0386 11 07 fc				ld de, store_page 
0389				if DEBUG_STORESE 
0389					DMARK "SGr" 
0389 f5				push af  
038a 3a 9e 03			ld a, (.dmark)  
038d 32 b4 fe			ld (debug_mark),a  
0390 3a 9f 03			ld a, (.dmark+1)  
0393 32 b5 fe			ld (debug_mark+1),a  
0396 3a a0 03			ld a, (.dmark+2)  
0399 32 b6 fe			ld (debug_mark+2),a  
039c 18 03			jr .pastdmark  
039e ..			.dmark: db "SGr"  
03a1 f1			.pastdmark: pop af  
03a2			endm  
# End of macro DMARK
03a2					CALLMONITOR 
03a2 cd c6 18			call break_point_state  
03a5				endm  
# End of macro CALLMONITOR
03a5				endif 
03a5 cd 72 09				call storage_read 
03a8 cd 72 0f				call ishlzero 
03ab 28 2d				jr z, .gap 
03ad					 
03ad					; have a file name read. Is it one we want. 
03ad			 
03ad 2a 00 fc				ld hl, (store_tmp1) 
03b0 11 0a fc				ld de, store_page+3   ; file name 
03b3			 
03b3				if DEBUG_STORESE 
03b3					DMARK "SGc" 
03b3 f5				push af  
03b4 3a c8 03			ld a, (.dmark)  
03b7 32 b4 fe			ld (debug_mark),a  
03ba 3a c9 03			ld a, (.dmark+1)  
03bd 32 b5 fe			ld (debug_mark+1),a  
03c0 3a ca 03			ld a, (.dmark+2)  
03c3 32 b6 fe			ld (debug_mark+2),a  
03c6 18 03			jr .pastdmark  
03c8 ..			.dmark: db "SGc"  
03cb f1			.pastdmark: pop af  
03cc			endm  
# End of macro DMARK
03cc					CALLMONITOR 
03cc cd c6 18			call break_point_state  
03cf				endm  
# End of macro CALLMONITOR
03cf				endif 
03cf cd df 13				call strcmp 
03d2 20 06				jr nz, .gap   ; not this one 
03d4			 
03d4 c1				        pop bc 
03d5			 
03d5 26 00				ld h, 0 
03d7 68					ld l, b 
03d8 18 22				jr .getdone 
03da						 
03da			 
03da			 
03da			 
03da			.gap: 
03da				if DEBUG_STORESE 
03da					DMARK "SGg" 
03da f5				push af  
03db 3a ef 03			ld a, (.dmark)  
03de 32 b4 fe			ld (debug_mark),a  
03e1 3a f0 03			ld a, (.dmark+1)  
03e4 32 b5 fe			ld (debug_mark+1),a  
03e7 3a f1 03			ld a, (.dmark+2)  
03ea 32 b6 fe			ld (debug_mark+2),a  
03ed 18 03			jr .pastdmark  
03ef ..			.dmark: db "SGg"  
03f2 f1			.pastdmark: pop af  
03f3			endm  
# End of macro DMARK
03f3					CALLMONITOR 
03f3 cd c6 18			call break_point_state  
03f6				endm  
# End of macro CALLMONITOR
03f6				endif 
03f6			 
03f6 c1					pop bc 
03f7 10 89				djnz .getloop 
03f9 21 ff 00				ld hl, 255 
03fc			.getdone: 
03fc			 
03fc				if DEBUG_STORESE 
03fc					DMARK "SGe" 
03fc f5				push af  
03fd 3a 11 04			ld a, (.dmark)  
0400 32 b4 fe			ld (debug_mark),a  
0403 3a 12 04			ld a, (.dmark+1)  
0406 32 b5 fe			ld (debug_mark+1),a  
0409 3a 13 04			ld a, (.dmark+2)  
040c 32 b6 fe			ld (debug_mark+2),a  
040f 18 03			jr .pastdmark  
0411 ..			.dmark: db "SGe"  
0414 f1			.pastdmark: pop af  
0415			endm  
# End of macro DMARK
0415					CALLMONITOR 
0415 cd c6 18			call break_point_state  
0418				endm  
# End of macro CALLMONITOR
0418				endif 
0418			 
0418 c9				ret 
0419			 
0419			 
0419			 
0419			 
0419			 
0419			 
0419			 
0419			 
0419			; Read Block 
0419			; ---------- 
0419			; 
0419			; With current bank 
0419			;  
0419			; Get block number to read 
0419			; Load physical blocks starting at start block into buffer 
0419			 
0419			; de points to buffer to use 
0419			; hl holds logical block number  
0419			 
0419			storage_read_block: 
0419			 
0419				; TODO bank selection 
0419			 
0419				; for each of the physical blocks read it into the buffer 
0419 06 40			ld b, STORE_BLOCK_PHY 
041b			 
041b				if DEBUG_STORESE 
041b d5					push de 
041c				endif 
041c				 
041c			.rl1:    
041c			 
041c				; read physical block at hl into de 
041c			        ; increment hl and de to next read position on exit 
041c			 
041c e5				push hl 
041d d5				push de	 
041e c5				push bc 
041f			;	if DEBUG_STORESE 
041f			;		push af 
041f			;		ld a, 'R' 
041f			;		ld (debug_mark),a 
041f			;		pop af 
041f			;		CALLMONITOR 
041f			;	endif 
041f cd c0 02			call se_readbyte 
0422			;	if DEBUG_STORESE 
0422			;		ld a,(spi_portbyte) 
0422			;		ld l, a 
0422			;		push af 
0422			;		ld a, '1' 
0422			;		ld (debug_mark),a 
0422			;		pop af 
0422			;		CALLMONITOR 
0422			;	endif 
0422 c1				pop bc 
0423 d1				pop de 
0424 e1				pop hl 
0425 12				ld (de),a 
0426 23				inc hl 
0427 13				inc de 
0428			 
0428			;	if DEBUG_STORESE 
0428			;		push af 
0428			;		ld a, 'r' 
0428			;		ld (debug_mark),a 
0428			;		pop af 
0428			;		CALLMONITOR 
0428			;	endif 
0428			 
0428 10 f2			djnz .rl1 
042a			 
042a				if DEBUG_STORESE 
042a					DMARK "SRB" 
042a f5				push af  
042b 3a 3f 04			ld a, (.dmark)  
042e 32 b4 fe			ld (debug_mark),a  
0431 3a 40 04			ld a, (.dmark+1)  
0434 32 b5 fe			ld (debug_mark+1),a  
0437 3a 41 04			ld a, (.dmark+2)  
043a 32 b6 fe			ld (debug_mark+2),a  
043d 18 03			jr .pastdmark  
043f ..			.dmark: db "SRB"  
0442 f1			.pastdmark: pop af  
0443			endm  
# End of macro DMARK
0443 d1					pop de 
0444			; 
0444			;		push af 
0444			;		ld a, 'R' 
0444			;		ld (debug_mark),a 
0444			;		pop af 
0444					CALLMONITOR 
0444 cd c6 18			call break_point_state  
0447				endm  
# End of macro CALLMONITOR
0447				endif 
0447 c9				ret	 
0448				 
0448			 
0448			; File Size 
0448			; --------- 
0448			; 
0448			;   hl file id 
0448			; 
0448			;  returns in hl the number of blocks 
0448			 
0448			storage_file_size: 
0448 5d				ld e, l 
0449 16 00			ld d, 0 
044b 21 40 00			ld hl, STORE_BLOCK_PHY 
044e					if DEBUG_FORTH_WORDS 
044e						DMARK "SIZ" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 b4 fe			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 b5 fe			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 b6 fe			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "SIZ"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467						CALLMONITOR 
0467 cd c6 18			call break_point_state  
046a				endm  
# End of macro CALLMONITOR
046a					endif 
046a cd 4c 07			call storage_findnextid 
046d			 
046d cd 72 0f			call ishlzero 
0470			;	ld a, l 
0470			;	add h 
0470			;	cp 0 
0470 c8				ret z			; block not found so EOF 
0471			 
0471 11 07 fc			ld de, store_page 
0474 cd 19 04			call storage_read_block 
0477			 
0477 3a 09 fc			ld a, (store_page+2)	 ; get extent count 
047a 6f				ld l, a 
047b 26 00			ld h, 0 
047d c9			 	ret 
047e			 
047e			 
047e			; Write Block 
047e			; ----------- 
047e			; 
047e			; With current bank 
047e			;  
047e			; Get block number to write 
047e			; Write physical blocks starting at start block from buffer 
047e			  
047e			storage_write_block: 
047e				; TODO bank selection 
047e			 
047e				; for each of the physical blocks read it into the buffer 
047e 06 40			ld b, STORE_BLOCK_PHY 
0480			 
0480				if DEBUG_STORESE 
0480					DMARK "SWB" 
0480 f5				push af  
0481 3a 95 04			ld a, (.dmark)  
0484 32 b4 fe			ld (debug_mark),a  
0487 3a 96 04			ld a, (.dmark+1)  
048a 32 b5 fe			ld (debug_mark+1),a  
048d 3a 97 04			ld a, (.dmark+2)  
0490 32 b6 fe			ld (debug_mark+2),a  
0493 18 03			jr .pastdmark  
0495 ..			.dmark: db "SWB"  
0498 f1			.pastdmark: pop af  
0499			endm  
# End of macro DMARK
0499			 
0499					;push af 
0499					;ld a, 'W' 
0499					;ld (debug_mark),a 
0499					;pop af 
0499					CALLMONITOR 
0499 cd c6 18			call break_point_state  
049c				endm  
# End of macro CALLMONITOR
049c				endif 
049c			 
049c			; might not be working 
049c			;	call se_writepage 
049c			 
049c			;	ret 
049c			; 
049c			 
049c			 
049c			 
049c			.wl1:    
049c			 
049c				; read physical block at hl into de 
049c			        ; increment hl and de to next read position on exit 
049c			 
049c e5				push hl 
049d d5				push de	 
049e c5				push bc 
049f 1a				ld a,(de) 
04a0				;if DEBUG_STORESE 
04a0			;		push af 
04a0			;		ld a, 'W' 
04a0			;		ld (debug_mark),a 
04a0			;		pop af 
04a0			;		CALLMONITOR 
04a0			;	endif 
04a0 cd 1e 02			call se_writebyte 
04a3			;	call delay250ms 
04a3 00				nop 
04a4 00				nop 
04a5 00				nop 
04a6			;	if DEBUG_STORESE 
04a6			;		push af 
04a6			;		ld a, 'w' 
04a6			;		ld (debug_mark),a 
04a6			;		pop af 
04a6			;		CALLMONITOR 
04a6			;	endif 
04a6 c1				pop bc 
04a7 d1				pop de 
04a8 e1				pop hl 
04a9 23				inc hl 
04aa 13				inc de 
04ab			 
04ab			 
04ab 10 ef			djnz .wl1 
04ad			 
04ad				if DEBUG_STORESE 
04ad					DMARK "SW2" 
04ad f5				push af  
04ae 3a c2 04			ld a, (.dmark)  
04b1 32 b4 fe			ld (debug_mark),a  
04b4 3a c3 04			ld a, (.dmark+1)  
04b7 32 b5 fe			ld (debug_mark+1),a  
04ba 3a c4 04			ld a, (.dmark+2)  
04bd 32 b6 fe			ld (debug_mark+2),a  
04c0 18 03			jr .pastdmark  
04c2 ..			.dmark: db "SW2"  
04c5 f1			.pastdmark: pop af  
04c6			endm  
# End of macro DMARK
04c6			 
04c6					;push af 
04c6					;ld a, 'W' 
04c6					;ld (debug_mark),a 
04c6					;pop af 
04c6					CALLMONITOR 
04c6 cd c6 18			call break_point_state  
04c9				endm  
# End of macro CALLMONITOR
04c9				endif 
04c9 c9				ret	 
04ca			 
04ca			; Init bank 
04ca			; --------- 
04ca			; 
04ca			; With current bank 
04ca			; 
04ca			; Setup block 0 config 
04ca			;     Set 0 file id counter 
04ca			;     Set formatted byte pattern 
04ca			;     Zero out bank label 
04ca			;      
04ca			; For every logical block write 0-1 byte as null 
04ca			 
04ca			storage_get_block_0: 
04ca			 
04ca				; TODO check presence 
04ca			 
04ca				; get block 0 config 
04ca			 
04ca 21 00 00			ld hl, 0 
04cd 11 07 fc			ld de, store_page 
04d0 cd 19 04			call storage_read_block 
04d3			 
04d3				if DEBUG_STORESE 
04d3					DMARK "SB0" 
04d3 f5				push af  
04d4 3a e8 04			ld a, (.dmark)  
04d7 32 b4 fe			ld (debug_mark),a  
04da 3a e9 04			ld a, (.dmark+1)  
04dd 32 b5 fe			ld (debug_mark+1),a  
04e0 3a ea 04			ld a, (.dmark+2)  
04e3 32 b6 fe			ld (debug_mark+2),a  
04e6 18 03			jr .pastdmark  
04e8 ..			.dmark: db "SB0"  
04eb f1			.pastdmark: pop af  
04ec			endm  
# End of macro DMARK
04ec 11 07 fc				ld de, store_page 
04ef			;		push af 
04ef			;		ld a, 'i' 
04ef			;		ld (debug_mark),a 
04ef			;		pop af 
04ef					CALLMONITOR 
04ef cd c6 18			call break_point_state  
04f2				endm  
# End of macro CALLMONITOR
04f2				endif 
04f2			 
04f2				; is this area formatted? 
04f2			 
04f2			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04f2 2a 08 fc			ld hl, (store_page+1) 
04f5 3e 80			ld a,0x80 
04f7 bd				cp l 
04f8 20 22			jr nz, .ininotformatted 
04fa				; do a double check 
04fa 3e 27			ld a, 0x27 
04fc bc				cp h 
04fd 20 1d			jr nz, .ininotformatted 
04ff			 
04ff				; formatted then 
04ff			 
04ff				if DEBUG_STORESE 
04ff					DMARK "SB1" 
04ff f5				push af  
0500 3a 14 05			ld a, (.dmark)  
0503 32 b4 fe			ld (debug_mark),a  
0506 3a 15 05			ld a, (.dmark+1)  
0509 32 b5 fe			ld (debug_mark+1),a  
050c 3a 16 05			ld a, (.dmark+2)  
050f 32 b6 fe			ld (debug_mark+2),a  
0512 18 03			jr .pastdmark  
0514 ..			.dmark: db "SB1"  
0517 f1			.pastdmark: pop af  
0518			endm  
# End of macro DMARK
0518					;push af 
0518					;ld a, 'I' 
0518					;ld (debug_mark),a 
0518					;pop af 
0518					CALLMONITOR 
0518 cd c6 18			call break_point_state  
051b				endm  
# End of macro CALLMONITOR
051b				endif 
051b c9				ret 
051c			 
051c			.ininotformatted: 
051c				; bank not formatted so poke various bits to make sure 
051c			 
051c				if DEBUG_STORESE 
051c					DMARK "SB2" 
051c f5				push af  
051d 3a 31 05			ld a, (.dmark)  
0520 32 b4 fe			ld (debug_mark),a  
0523 3a 32 05			ld a, (.dmark+1)  
0526 32 b5 fe			ld (debug_mark+1),a  
0529 3a 33 05			ld a, (.dmark+2)  
052c 32 b6 fe			ld (debug_mark+2),a  
052f 18 03			jr .pastdmark  
0531 ..			.dmark: db "SB2"  
0534 f1			.pastdmark: pop af  
0535			endm  
# End of macro DMARK
0535					;push af 
0535					;ld a, 'f' 
0535					;ld (debug_mark),a 
0535					;pop af 
0535					CALLMONITOR 
0535 cd c6 18			call break_point_state  
0538				endm  
# End of macro CALLMONITOR
0538				endif 
0538			 
0538 cd 55 0c			call storage_clear_page 
053b			 
053b 21 07 fc			ld hl, store_page 
053e 3e 00			ld a, 0 
0540				 
0540 77				ld (hl),a   ; reset file counter 
0541			 
0541 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0544 22 08 fc		 	ld (store_page+1), hl	 
0547			 
0547				; set default label 
0547			 
0547 21 e3 05			ld hl, .defaultbanklabl 
054a 11 0a fc		 	ld de, store_page+3 
054d 01 0f 00			ld bc, 15 
0550 ed b0			ldir 
0552			 
0552				; Append the current bank id 
0552 21 13 fc			ld hl, store_page+3+9 
0555 3a ec fb			ld a, (spi_device_id) 
0558 77				ld (hl), a 
0559			 
0559				; save default page 0 
0559			 
0559 21 00 00			ld hl, 0 
055c 11 07 fc			ld de, store_page 
055f				if DEBUG_STORESE 
055f					DMARK "SB3" 
055f f5				push af  
0560 3a 74 05			ld a, (.dmark)  
0563 32 b4 fe			ld (debug_mark),a  
0566 3a 75 05			ld a, (.dmark+1)  
0569 32 b5 fe			ld (debug_mark+1),a  
056c 3a 76 05			ld a, (.dmark+2)  
056f 32 b6 fe			ld (debug_mark+2),a  
0572 18 03			jr .pastdmark  
0574 ..			.dmark: db "SB3"  
0577 f1			.pastdmark: pop af  
0578			endm  
# End of macro DMARK
0578			;		push af 
0578			;		ld a, 'F' 
0578			;		ld (debug_mark),a 
0578			;		pop af 
0578					CALLMONITOR 
0578 cd c6 18			call break_point_state  
057b				endm  
# End of macro CALLMONITOR
057b				endif 
057b cd 7e 04			call storage_write_block 
057e				if DEBUG_STORESE 
057e					DMARK "SB4" 
057e f5				push af  
057f 3a 93 05			ld a, (.dmark)  
0582 32 b4 fe			ld (debug_mark),a  
0585 3a 94 05			ld a, (.dmark+1)  
0588 32 b5 fe			ld (debug_mark+1),a  
058b 3a 95 05			ld a, (.dmark+2)  
058e 32 b6 fe			ld (debug_mark+2),a  
0591 18 03			jr .pastdmark  
0593 ..			.dmark: db "SB4"  
0596 f1			.pastdmark: pop af  
0597			endm  
# End of macro DMARK
0597			;		push af 
0597			;		ld a, '>' 
0597			;		ld (debug_mark),a 
0597			;		pop af 
0597					CALLMONITOR 
0597 cd c6 18			call break_point_state  
059a				endm  
# End of macro CALLMONITOR
059a				endif 
059a			 
059a 00				nop 
059b 00				nop 
059c 00				nop 
059d			 
059d				; now set 0 in every page to mark as a free block 
059d			 
059d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
059f 21 40 00			ld hl, STORE_BLOCK_PHY 
05a2			 
05a2 3e 00		.setmark1:   	ld a,0 
05a4 e5					push hl 
05a5 c5					push bc 
05a6 cd 1e 02				call se_writebyte 
05a9 3e 0a			ld a, 10 
05ab cd 77 0c			call aDelayInMS 
05ae 23				inc hl 
05af cd 1e 02				call se_writebyte 
05b2 3e 0a			ld a, 10 
05b4 cd 77 0c			call aDelayInMS 
05b7 2b				dec hl 
05b8 c1					pop bc 
05b9 e1					pop hl 
05ba 3e 40				ld a, STORE_BLOCK_PHY 
05bc cd 49 0f				call addatohl 
05bf 10 e1				djnz .setmark1 
05c1			 
05c1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05c3 3e 00		.setmark2:   	ld a,0 
05c5 e5					push hl 
05c6 c5					push bc 
05c7 cd 1e 02				call se_writebyte 
05ca 3e 0a			ld a, 10 
05cc cd 77 0c			call aDelayInMS 
05cf 23				inc hl 
05d0 cd 1e 02				call se_writebyte 
05d3 3e 0a			ld a, 10 
05d5 cd 77 0c			call aDelayInMS 
05d8 2b				dec hl 
05d9 c1					pop bc 
05da e1					pop hl 
05db 3e 40				ld a, STORE_BLOCK_PHY 
05dd cd 49 0f				call addatohl 
05e0 10 e1				djnz .setmark2 
05e2			 
05e2					 
05e2			 
05e2			 
05e2 c9				ret 
05e3			 
05e3			 
05e3			 
05e3			 
05e3 .. 00		.defaultbanklabl:   db "BankLabel_",0 
05ee			 
05ee			 
05ee			 
05ee			; Label Bank 
05ee			; ---------- 
05ee			; 
05ee			; With current bank 
05ee			; Read block 0 
05ee			; Set label 
05ee			; Write block 0 
05ee			 
05ee			; label str pointer in hl 
05ee			 
05ee			storage_label:     
05ee			 
05ee				if DEBUG_STORESE 
05ee					DMARK "LBL" 
05ee f5				push af  
05ef 3a 03 06			ld a, (.dmark)  
05f2 32 b4 fe			ld (debug_mark),a  
05f5 3a 04 06			ld a, (.dmark+1)  
05f8 32 b5 fe			ld (debug_mark+1),a  
05fb 3a 05 06			ld a, (.dmark+2)  
05fe 32 b6 fe			ld (debug_mark+2),a  
0601 18 03			jr .pastdmark  
0603 ..			.dmark: db "LBL"  
0606 f1			.pastdmark: pop af  
0607			endm  
# End of macro DMARK
0607					CALLMONITOR 
0607 cd c6 18			call break_point_state  
060a				endm  
# End of macro CALLMONITOR
060a				endif 
060a			 
060a e5				push hl 
060b			 
060b cd ca 04			call storage_get_block_0 
060e			 
060e				; set default label 
060e			 
060e e1				pop hl 
060f			 
060f 11 0a fc		 	ld de, store_page+3 
0612 01 0f 00			ld bc, 15 
0615				if DEBUG_STORESE 
0615					DMARK "LB3" 
0615 f5				push af  
0616 3a 2a 06			ld a, (.dmark)  
0619 32 b4 fe			ld (debug_mark),a  
061c 3a 2b 06			ld a, (.dmark+1)  
061f 32 b5 fe			ld (debug_mark+1),a  
0622 3a 2c 06			ld a, (.dmark+2)  
0625 32 b6 fe			ld (debug_mark+2),a  
0628 18 03			jr .pastdmark  
062a ..			.dmark: db "LB3"  
062d f1			.pastdmark: pop af  
062e			endm  
# End of macro DMARK
062e					CALLMONITOR 
062e cd c6 18			call break_point_state  
0631				endm  
# End of macro CALLMONITOR
0631				endif 
0631 ed b0			ldir 
0633				; save default page 0 
0633			 
0633 21 00 00			ld hl, 0 
0636 11 07 fc			ld de, store_page 
0639				if DEBUG_STORESE 
0639					DMARK "LBW" 
0639 f5				push af  
063a 3a 4e 06			ld a, (.dmark)  
063d 32 b4 fe			ld (debug_mark),a  
0640 3a 4f 06			ld a, (.dmark+1)  
0643 32 b5 fe			ld (debug_mark+1),a  
0646 3a 50 06			ld a, (.dmark+2)  
0649 32 b6 fe			ld (debug_mark+2),a  
064c 18 03			jr .pastdmark  
064e ..			.dmark: db "LBW"  
0651 f1			.pastdmark: pop af  
0652			endm  
# End of macro DMARK
0652					CALLMONITOR 
0652 cd c6 18			call break_point_state  
0655				endm  
# End of macro CALLMONITOR
0655				endif 
0655 cd 7e 04			call storage_write_block 
0658			 
0658 c9				ret 
0659			 
0659			 
0659			 
0659			; Read Block 0 - Config 
0659			; --------------------- 
0659			; 
0659			; With current bank 
0659			; Call presence test 
0659			;    If not present format/init bank  
0659			; Read block 0  
0659			;  
0659			 
0659			 
0659			; Dir 
0659			; --- 
0659			; 
0659			; With current bank 
0659			; Load Block 0 Config 
0659			; Get max file id number 
0659			; For each logical block 
0659			;    Read block read byte 2 
0659			;      if first block of file 
0659			;         Display file name 
0659			;         Display type flags for file 
0659			;        
0659			 
0659			; moving to words as this requires stack control 
0659			 
0659			 
0659			; Delete File 
0659			; ----------- 
0659			; 
0659			; With current bank 
0659			; 
0659			; Load Block 0 Config 
0659			; Get max file id number 
0659			; For each logical block 
0659			;    Read block file id 
0659			;      If first block of file and dont have file id 
0659			;         if file to delete 
0659			;         Save file id 
0659			;         Null file id 
0659			;         Write this block back 
0659			;      If file id is one saved 
0659			;         Null file id 
0659			;         Write this block back 
0659			 
0659			 
0659			.se_done: 
0659 e1				pop hl 
065a c9				ret 
065b			 
065b			storage_erase: 
065b			 
065b				; hl contains the file id 
065b			 
065b 5d				ld e, l 
065c 16 00			ld d, 0 
065e 21 40 00			ld hl, STORE_BLOCK_PHY 
0661					if DEBUG_FORTH_WORDS 
0661						DMARK "ERA" 
0661 f5				push af  
0662 3a 76 06			ld a, (.dmark)  
0665 32 b4 fe			ld (debug_mark),a  
0668 3a 77 06			ld a, (.dmark+1)  
066b 32 b5 fe			ld (debug_mark+1),a  
066e 3a 78 06			ld a, (.dmark+2)  
0671 32 b6 fe			ld (debug_mark+2),a  
0674 18 03			jr .pastdmark  
0676 ..			.dmark: db "ERA"  
0679 f1			.pastdmark: pop af  
067a			endm  
# End of macro DMARK
067a						CALLMONITOR 
067a cd c6 18			call break_point_state  
067d				endm  
# End of macro CALLMONITOR
067d					endif 
067d cd 4c 07			call storage_findnextid 
0680 cd 72 0f			call ishlzero 
0683 c8				ret z 
0684			 
0684 e5				push hl 
0685			 
0685				; TODO check file not found 
0685			 
0685 11 07 fc			ld de, store_page 
0688 cd 19 04			call storage_read_block 
068b			 
068b cd 72 0f			call ishlzero 
068e ca 59 06			jp z,.se_done 
0691			 
0691					if DEBUG_FORTH_WORDS 
0691						DMARK "ER1" 
0691 f5				push af  
0692 3a a6 06			ld a, (.dmark)  
0695 32 b4 fe			ld (debug_mark),a  
0698 3a a7 06			ld a, (.dmark+1)  
069b 32 b5 fe			ld (debug_mark+1),a  
069e 3a a8 06			ld a, (.dmark+2)  
06a1 32 b6 fe			ld (debug_mark+2),a  
06a4 18 03			jr .pastdmark  
06a6 ..			.dmark: db "ER1"  
06a9 f1			.pastdmark: pop af  
06aa			endm  
# End of macro DMARK
06aa						CALLMONITOR 
06aa cd c6 18			call break_point_state  
06ad				endm  
# End of macro CALLMONITOR
06ad					endif 
06ad 3a 07 fc			ld a, (store_page)	; get file id 
06b0 32 fb fb			ld (store_tmpid), a 
06b3			 
06b3 3a 09 fc			ld a, (store_page+2)    ; get count of extends 
06b6 32 fa fb			ld (store_tmpext), a 
06b9			 
06b9				; wipe file header 
06b9			 
06b9 e1				pop hl 
06ba 3e 00			ld a, 0 
06bc 32 07 fc			ld (store_page), a 
06bf 32 08 fc			ld (store_page+1),a 
06c2 11 07 fc			ld de, store_page 
06c5					if DEBUG_FORTH_WORDS 
06c5						DMARK "ER2" 
06c5 f5				push af  
06c6 3a da 06			ld a, (.dmark)  
06c9 32 b4 fe			ld (debug_mark),a  
06cc 3a db 06			ld a, (.dmark+1)  
06cf 32 b5 fe			ld (debug_mark+1),a  
06d2 3a dc 06			ld a, (.dmark+2)  
06d5 32 b6 fe			ld (debug_mark+2),a  
06d8 18 03			jr .pastdmark  
06da ..			.dmark: db "ER2"  
06dd f1			.pastdmark: pop af  
06de			endm  
# End of macro DMARK
06de						CALLMONITOR 
06de cd c6 18			call break_point_state  
06e1				endm  
# End of macro CALLMONITOR
06e1					endif 
06e1 cd 7e 04			call storage_write_block 
06e4			 
06e4			 
06e4				; wipe file extents 
06e4			 
06e4 3a fa fb			ld a, (store_tmpext) 
06e7 47				ld b, a 
06e8			 
06e8			.eraext:	  
06e8 c5				push bc 
06e9			 
06e9 21 40 00			ld hl, STORE_BLOCK_PHY 
06ec 3a fb fb			ld a,(store_tmpid) 
06ef 5f				ld e, a 
06f0 50				ld d, b	 
06f1					if DEBUG_FORTH_WORDS 
06f1						DMARK "ER3" 
06f1 f5				push af  
06f2 3a 06 07			ld a, (.dmark)  
06f5 32 b4 fe			ld (debug_mark),a  
06f8 3a 07 07			ld a, (.dmark+1)  
06fb 32 b5 fe			ld (debug_mark+1),a  
06fe 3a 08 07			ld a, (.dmark+2)  
0701 32 b6 fe			ld (debug_mark+2),a  
0704 18 03			jr .pastdmark  
0706 ..			.dmark: db "ER3"  
0709 f1			.pastdmark: pop af  
070a			endm  
# End of macro DMARK
070a						CALLMONITOR 
070a cd c6 18			call break_point_state  
070d				endm  
# End of macro CALLMONITOR
070d					endif 
070d cd 4c 07			call storage_findnextid 
0710 cd 72 0f			call ishlzero 
0713 ca 59 06			jp z,.se_done 
0716			 
0716 e5				push hl 
0717 11 07 fc			ld de, store_page 
071a cd 19 04			call storage_read_block 
071d			 
071d				; free block	 
071d			 
071d 3e 00			ld a, 0 
071f 32 07 fc			ld (store_page), a 
0722 32 08 fc			ld (store_page+1),a 
0725 11 07 fc			ld de, store_page 
0728 e1				pop hl 
0729					if DEBUG_FORTH_WORDS 
0729						DMARK "ER4" 
0729 f5				push af  
072a 3a 3e 07			ld a, (.dmark)  
072d 32 b4 fe			ld (debug_mark),a  
0730 3a 3f 07			ld a, (.dmark+1)  
0733 32 b5 fe			ld (debug_mark+1),a  
0736 3a 40 07			ld a, (.dmark+2)  
0739 32 b6 fe			ld (debug_mark+2),a  
073c 18 03			jr .pastdmark  
073e ..			.dmark: db "ER4"  
0741 f1			.pastdmark: pop af  
0742			endm  
# End of macro DMARK
0742						CALLMONITOR 
0742 cd c6 18			call break_point_state  
0745				endm  
# End of macro CALLMONITOR
0745					endif 
0745 cd 7e 04			call storage_write_block 
0748			 
0748 c1				pop bc 
0749 10 9d			djnz .eraext 
074b			 
074b c9				ret 
074c			 
074c			 
074c			; Find Free Block 
074c			; --------------- 
074c			; 
074c			; With current bank 
074c			;  
074c			; From given starting logical block 
074c			;    Read block  
074c			;    If no file id 
074c			;         Return block id 
074c			 
074c			 
074c			; hl starting page number 
074c			; hl contains free page number or zero if no pages free 
074c			; e contains the file id to locate 
074c			; d contains the block number 
074c			 
074c			; TODO change to find file id and use zero for free block 
074c			 
074c			storage_findnextid: 
074c			 
074c				; now locate first 0 page to mark as a free block 
074c			 
074c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
074e			;	ld hl, STORE_BLOCK_PHY 
074e			 
074e					if DEBUG_FORTH_WORDS 
074e					DMARK "FNI" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 b4 fe			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 b5 fe			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 b6 fe			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "FNI"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767						CALLMONITOR 
0767 cd c6 18			call break_point_state  
076a				endm  
# End of macro CALLMONITOR
076a					endif 
076a			.ff1:   	 
076a e5					push hl 
076b c5					push bc 
076c d5					push de 
076d cd c0 02				call se_readbyte 
0770 5f					ld e,a 
0771 23					inc hl 
0772 cd c0 02				call se_readbyte 
0775 57					ld d, a 
0776 e1					pop hl 
0777 e5					push hl 
0778 cd 67 0f				call cmp16 
077b 28 49				jr z, .fffound 
077d			 
077d d1					pop de 
077e c1					pop bc 
077f e1					pop hl 
0780			 
0780					; is found? 
0780					;cp e 
0780					;ret z 
0780			 
0780 3e 40				ld a, STORE_BLOCK_PHY 
0782 cd 49 0f				call addatohl 
0785 10 e3				djnz .ff1 
0787			 
0787 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0789			.ff2:   	 
0789			 
0789 e5					push hl 
078a c5					push bc 
078b d5					push de 
078c cd c0 02				call se_readbyte 
078f 5f					ld e,a 
0790 23					inc hl 
0791 cd c0 02				call se_readbyte 
0794 57					ld d, a 
0795			 
0795 e1					pop hl 
0796 e5					push hl 
0797 cd 67 0f				call cmp16 
079a 28 2a				jr z, .fffound 
079c			 
079c d1					pop de 
079d c1					pop bc 
079e e1					pop hl 
079f					; is found? 
079f					;cp e 
079f					;ret z 
079f			 
079f 3e 40				ld a, STORE_BLOCK_PHY 
07a1 cd 49 0f				call addatohl 
07a4 10 e3				djnz .ff2 
07a6			 
07a6			 
07a6					if DEBUG_FORTH_WORDS 
07a6					DMARK "FN-" 
07a6 f5				push af  
07a7 3a bb 07			ld a, (.dmark)  
07aa 32 b4 fe			ld (debug_mark),a  
07ad 3a bc 07			ld a, (.dmark+1)  
07b0 32 b5 fe			ld (debug_mark+1),a  
07b3 3a bd 07			ld a, (.dmark+2)  
07b6 32 b6 fe			ld (debug_mark+2),a  
07b9 18 03			jr .pastdmark  
07bb ..			.dmark: db "FN-"  
07be f1			.pastdmark: pop af  
07bf			endm  
# End of macro DMARK
07bf					;	push af 
07bf					;	ld a, 'n' 
07bf					;	ld (debug_mark),a 
07bf					;	pop af 
07bf						CALLMONITOR 
07bf cd c6 18			call break_point_state  
07c2				endm  
# End of macro CALLMONITOR
07c2					endif 
07c2				; no free marks! 
07c2 21 00 00				ld hl, 0 
07c5 c9				ret 
07c6			.fffound: 
07c6				 
07c6			 
07c6 d1					pop de 
07c7 c1					pop bc 
07c8 e1					pop hl 
07c9					if DEBUG_FORTH_WORDS 
07c9					DMARK "FNF" 
07c9 f5				push af  
07ca 3a de 07			ld a, (.dmark)  
07cd 32 b4 fe			ld (debug_mark),a  
07d0 3a df 07			ld a, (.dmark+1)  
07d3 32 b5 fe			ld (debug_mark+1),a  
07d6 3a e0 07			ld a, (.dmark+2)  
07d9 32 b6 fe			ld (debug_mark+2),a  
07dc 18 03			jr .pastdmark  
07de ..			.dmark: db "FNF"  
07e1 f1			.pastdmark: pop af  
07e2			endm  
# End of macro DMARK
07e2					;	push af 
07e2					;	ld a, 'n' 
07e2					;	ld (debug_mark),a 
07e2					;	pop af 
07e2						CALLMONITOR 
07e2 cd c6 18			call break_point_state  
07e5				endm  
# End of macro CALLMONITOR
07e5					endif 
07e5 c9				ret 
07e6			 
07e6			 
07e6			 
07e6			; Free Space 
07e6			; ---------- 
07e6			; 
07e6			; With current bank 
07e6			; 
07e6			; Set block count to zero 
07e6			; Starting with first logical block 
07e6			;      Find free block  
07e6			;      If block id given, increment block count 
07e6			; 
07e6			;  
07e6			 
07e6			 
07e6			; hl contains count of free blocks 
07e6			 
07e6			storage_freeblocks: 
07e6			 
07e6				; now locate first 0 page to mark as a free block 
07e6			 
07e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07e8 21 40 00			ld hl, STORE_BLOCK_PHY 
07eb 11 00 00			ld de, 0 
07ee			 
07ee			.fb1:   	 
07ee e5					push hl 
07ef c5					push bc 
07f0 d5					push de 
07f1 cd c0 02				call se_readbyte 
07f4 d1					pop de 
07f5 c1					pop bc 
07f6 e1					pop hl 
07f7			 
07f7					; is free? 
07f7 fe 00				cp 0 
07f9 20 01				jr nz, .ff1cont 
07fb 13					inc de 
07fc			 
07fc			.ff1cont: 
07fc			 
07fc			 
07fc 3e 40				ld a, STORE_BLOCK_PHY 
07fe cd 49 0f				call addatohl 
0801 10 eb				djnz .fb1 
0803			 
0803 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0805			.fb2:   	 
0805 e5					push hl 
0806 c5					push bc 
0807 d5					push de 
0808 cd c0 02				call se_readbyte 
080b d1					pop de 
080c c1					pop bc 
080d e1					pop hl 
080e			 
080e					; is free? 
080e fe 00				cp 0 
0810 20 01				jr nz, .ff2cont 
0812 13					inc de 
0813			 
0813			.ff2cont: 
0813			 
0813 3e 40				ld a, STORE_BLOCK_PHY 
0815 cd 49 0f				call addatohl 
0818 10 eb				djnz .fb2 
081a			 
081a eb				ex de, hl 
081b c9				ret 
081c			 
081c			; Get File ID 
081c			; ----------- 
081c			; 
081c			; With current bank 
081c			;  
081c			; Load Block 0 Config 
081c			; Get max file id number 
081c			; For each logical block 
081c			;    Read block file id 
081c			;      If first block of file and dont have file id 
081c			;         if file get id and exit 
081c			 
081c			 
081c			 
081c			 
081c			; Create File 
081c			; ----------- 
081c			; 
081c			; With current bank  
081c			; Load Block 0 Config 
081c			; Get max file id number 
081c			; Increment file id number 
081c			; Save Config 
081c			; Find free block 
081c			; Set buffer with file name and file id 
081c			; Write buffer to free block  
081c			 
081c			 
081c			; hl point to file name 
081c			; hl returns file id 
081c			 
081c			; file format: 
081c			; byte 0 - file id 
081c			; byte 1 - extent number 
081c			; byte 2-> data 
081c			 
081c			; format for extent number 0: 
081c			; 
081c			; byte 0 - file id 
081c			; byte 1 - extent 0 
081c			; byte 2 - extent count 
081c			; byte 3 -> file name and meta data 
081c			 
081c			 
081c			storage_create: 
081c				if DEBUG_STORESE 
081c					DMARK "SCR" 
081c f5				push af  
081d 3a 31 08			ld a, (.dmark)  
0820 32 b4 fe			ld (debug_mark),a  
0823 3a 32 08			ld a, (.dmark+1)  
0826 32 b5 fe			ld (debug_mark+1),a  
0829 3a 33 08			ld a, (.dmark+2)  
082c 32 b6 fe			ld (debug_mark+2),a  
082f 18 03			jr .pastdmark  
0831 ..			.dmark: db "SCR"  
0834 f1			.pastdmark: pop af  
0835			endm  
# End of macro DMARK
0835					CALLMONITOR 
0835 cd c6 18			call break_point_state  
0838				endm  
# End of macro CALLMONITOR
0838				endif 
0838			 
0838 e5				push hl		; save file name pointer 
0839			 
0839 cd ca 04			call storage_get_block_0 
083c			 
083c 3a 07 fc			ld a,(store_page)	; get current file id 
083f 3c				inc a 
0840 32 07 fc			ld (store_page),a 
0843				 
0843 32 fb fb			ld (store_tmpid),a			; save id 
0846			 
0846 21 00 00			ld hl, 0 
0849 11 07 fc			ld de, store_page 
084c				if DEBUG_STORESE 
084c					DMARK "SCw" 
084c f5				push af  
084d 3a 61 08			ld a, (.dmark)  
0850 32 b4 fe			ld (debug_mark),a  
0853 3a 62 08			ld a, (.dmark+1)  
0856 32 b5 fe			ld (debug_mark+1),a  
0859 3a 63 08			ld a, (.dmark+2)  
085c 32 b6 fe			ld (debug_mark+2),a  
085f 18 03			jr .pastdmark  
0861 ..			.dmark: db "SCw"  
0864 f1			.pastdmark: pop af  
0865			endm  
# End of macro DMARK
0865					CALLMONITOR 
0865 cd c6 18			call break_point_state  
0868				endm  
# End of macro CALLMONITOR
0868				endif 
0868 cd 7e 04			call storage_write_block	 ; save update 
086b			 
086b				if DEBUG_STORESE 
086b 11 07 fc				ld de, store_page 
086e					DMARK "SCC" 
086e f5				push af  
086f 3a 83 08			ld a, (.dmark)  
0872 32 b4 fe			ld (debug_mark),a  
0875 3a 84 08			ld a, (.dmark+1)  
0878 32 b5 fe			ld (debug_mark+1),a  
087b 3a 85 08			ld a, (.dmark+2)  
087e 32 b6 fe			ld (debug_mark+2),a  
0881 18 03			jr .pastdmark  
0883 ..			.dmark: db "SCC"  
0886 f1			.pastdmark: pop af  
0887			endm  
# End of macro DMARK
0887					CALLMONITOR 
0887 cd c6 18			call break_point_state  
088a				endm  
# End of macro CALLMONITOR
088a				endif 
088a				;  
088a				 
088a 21 40 00			ld hl, STORE_BLOCK_PHY 
088d 11 00 00			ld de, 0 
0890 cd 4c 07			call storage_findnextid 
0893			 
0893 22 f2 fb			ld (store_tmppageid), hl    ; save page to use  
0896			 
0896				; TODO detect 0 = no spare blocks 
0896			 
0896				; hl now contains the free page to use for the file header page 
0896			 
0896				if DEBUG_STORESE 
0896				DMARK "SCF" 
0896 f5				push af  
0897 3a ab 08			ld a, (.dmark)  
089a 32 b4 fe			ld (debug_mark),a  
089d 3a ac 08			ld a, (.dmark+1)  
08a0 32 b5 fe			ld (debug_mark+1),a  
08a3 3a ad 08			ld a, (.dmark+2)  
08a6 32 b6 fe			ld (debug_mark+2),a  
08a9 18 03			jr .pastdmark  
08ab ..			.dmark: db "SCF"  
08ae f1			.pastdmark: pop af  
08af			endm  
# End of macro DMARK
08af					CALLMONITOR 
08af cd c6 18			call break_point_state  
08b2				endm  
# End of macro CALLMONITOR
08b2				endif 
08b2			 
08b2 22 f2 fb			ld (store_tmppageid), hl 
08b5				 
08b5 3a fb fb			ld a,(store_tmpid)    ; get file id 
08b8			;	ld a, (store_filecache)			; save to cache 
08b8			 
08b8 32 07 fc			ld (store_page),a    ; set page id 
08bb 3e 00			ld a, 0			 ; extent 0 is file header 
08bd 32 08 fc			ld (store_page+1), a   ; set file extent 
08c0			 
08c0 32 09 fc			ld (store_page+2), a   ; extent count for the file 
08c3			 
08c3			;	inc hl 		; init block 0 of file 
08c3			;	inc hl   		; skip file and extent id 
08c3			 ;       ld a, 0 
08c3			;	ld (hl),a 
08c3			;	ld a, (store_filecache+1)  	; save to cache 
08c3			 
08c3			;	inc hl    ; file name 
08c3				 
08c3				 
08c3 11 0a fc			ld de, store_page+3    ; get buffer for term string to use as file name 
08c6				if DEBUG_STORESE 
08c6					DMARK "SCc" 
08c6 f5				push af  
08c7 3a db 08			ld a, (.dmark)  
08ca 32 b4 fe			ld (debug_mark),a  
08cd 3a dc 08			ld a, (.dmark+1)  
08d0 32 b5 fe			ld (debug_mark+1),a  
08d3 3a dd 08			ld a, (.dmark+2)  
08d6 32 b6 fe			ld (debug_mark+2),a  
08d9 18 03			jr .pastdmark  
08db ..			.dmark: db "SCc"  
08de f1			.pastdmark: pop af  
08df			endm  
# End of macro DMARK
08df					CALLMONITOR 
08df cd c6 18			call break_point_state  
08e2				endm  
# End of macro CALLMONITOR
08e2				endif 
08e2 e1				pop hl    ; get zero term string 
08e3 e5				push hl 
08e4 3e 00			ld a, 0 
08e6 cd b2 13			call strlent 
08e9 23				inc hl   ; cover zero term 
08ea 06 00			ld b,0 
08ec 4d				ld c,l 
08ed e1				pop hl 
08ee				;ex de, hl 
08ee				if DEBUG_STORESE 
08ee					DMARK "SCa" 
08ee f5				push af  
08ef 3a 03 09			ld a, (.dmark)  
08f2 32 b4 fe			ld (debug_mark),a  
08f5 3a 04 09			ld a, (.dmark+1)  
08f8 32 b5 fe			ld (debug_mark+1),a  
08fb 3a 05 09			ld a, (.dmark+2)  
08fe 32 b6 fe			ld (debug_mark+2),a  
0901 18 03			jr .pastdmark  
0903 ..			.dmark: db "SCa"  
0906 f1			.pastdmark: pop af  
0907			endm  
# End of macro DMARK
0907					;push af 
0907					;ld a, 'a' 
0907					;ld (debug_mark),a 
0907					;pop af 
0907					CALLMONITOR 
0907 cd c6 18			call break_point_state  
090a				endm  
# End of macro CALLMONITOR
090a				endif 
090a ed b0			ldir    ; copy zero term string 
090c				if DEBUG_STORESE 
090c					DMARK "SCA" 
090c f5				push af  
090d 3a 21 09			ld a, (.dmark)  
0910 32 b4 fe			ld (debug_mark),a  
0913 3a 22 09			ld a, (.dmark+1)  
0916 32 b5 fe			ld (debug_mark+1),a  
0919 3a 23 09			ld a, (.dmark+2)  
091c 32 b6 fe			ld (debug_mark+2),a  
091f 18 03			jr .pastdmark  
0921 ..			.dmark: db "SCA"  
0924 f1			.pastdmark: pop af  
0925			endm  
# End of macro DMARK
0925					CALLMONITOR 
0925 cd c6 18			call break_point_state  
0928				endm  
# End of macro CALLMONITOR
0928				endif 
0928			 
0928				; write file header page 
0928			 
0928 2a f2 fb			ld hl,(store_tmppageid) 
092b 11 07 fc			ld de, store_page 
092e				if DEBUG_STORESE 
092e					DMARK "SCb" 
092e f5				push af  
092f 3a 43 09			ld a, (.dmark)  
0932 32 b4 fe			ld (debug_mark),a  
0935 3a 44 09			ld a, (.dmark+1)  
0938 32 b5 fe			ld (debug_mark+1),a  
093b 3a 45 09			ld a, (.dmark+2)  
093e 32 b6 fe			ld (debug_mark+2),a  
0941 18 03			jr .pastdmark  
0943 ..			.dmark: db "SCb"  
0946 f1			.pastdmark: pop af  
0947			endm  
# End of macro DMARK
0947					;push af 
0947					;ld a, 'b' 
0947					;ld (debug_mark),a 
0947					;pop af 
0947					CALLMONITOR 
0947 cd c6 18			call break_point_state  
094a				endm  
# End of macro CALLMONITOR
094a				endif 
094a cd 7e 04			call storage_write_block 
094d			 
094d 3a fb fb			ld a, (store_tmpid) 
0950 6f				ld l, a 
0951 26 00			ld h,0 
0953				if DEBUG_STORESE 
0953					DMARK "SCz" 
0953 f5				push af  
0954 3a 68 09			ld a, (.dmark)  
0957 32 b4 fe			ld (debug_mark),a  
095a 3a 69 09			ld a, (.dmark+1)  
095d 32 b5 fe			ld (debug_mark+1),a  
0960 3a 6a 09			ld a, (.dmark+2)  
0963 32 b6 fe			ld (debug_mark+2),a  
0966 18 03			jr .pastdmark  
0968 ..			.dmark: db "SCz"  
096b f1			.pastdmark: pop af  
096c			endm  
# End of macro DMARK
096c					CALLMONITOR 
096c cd c6 18			call break_point_state  
096f				endm  
# End of macro CALLMONITOR
096f				endif 
096f c9				ret 
0970				 
0970			 
0970			 
0970			; 
0970			; Read File 
0970			; 
0970			; h - file id to locate 
0970			; l - extent to locate 
0970			; de - pointer to string to read into 
0970			; 
0970			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0970			 
0970			.sr_fail: 
0970 d1				pop de 
0971 c9				ret 
0972			 
0972			storage_read: 
0972			 
0972			 
0972 d5				push de 
0973			 
0973			; TODO BUG the above push is it popped before the RET Z? 
0973			 
0973			; TODO how to handle multiple part blocks 
0973			 
0973				; locate file extent to read 
0973			 
0973 5c				ld e, h 
0974 55				ld d, l 
0975			 
0975			.srext: 
0975 22 05 fc			ld (store_readptr), hl     ; save the current extent to load 
0978 ed 53 03 fc		ld (store_readbuf), de     ; save the current buffer to load in to 
097c			 
097c 21 40 00			ld hl, STORE_BLOCK_PHY 
097f				if DEBUG_STORESE 
097f					DMARK "sre" 
097f f5				push af  
0980 3a 94 09			ld a, (.dmark)  
0983 32 b4 fe			ld (debug_mark),a  
0986 3a 95 09			ld a, (.dmark+1)  
0989 32 b5 fe			ld (debug_mark+1),a  
098c 3a 96 09			ld a, (.dmark+2)  
098f 32 b6 fe			ld (debug_mark+2),a  
0992 18 03			jr .pastdmark  
0994 ..			.dmark: db "sre"  
0997 f1			.pastdmark: pop af  
0998			endm  
# End of macro DMARK
0998					CALLMONITOR 
0998 cd c6 18			call break_point_state  
099b				endm  
# End of macro CALLMONITOR
099b				endif 
099b cd 4c 07			call storage_findnextid 
099e			 
099e				if DEBUG_STORESE 
099e					DMARK "srf" 
099e f5				push af  
099f 3a b3 09			ld a, (.dmark)  
09a2 32 b4 fe			ld (debug_mark),a  
09a5 3a b4 09			ld a, (.dmark+1)  
09a8 32 b5 fe			ld (debug_mark+1),a  
09ab 3a b5 09			ld a, (.dmark+2)  
09ae 32 b6 fe			ld (debug_mark+2),a  
09b1 18 03			jr .pastdmark  
09b3 ..			.dmark: db "srf"  
09b6 f1			.pastdmark: pop af  
09b7			endm  
# End of macro DMARK
09b7					CALLMONITOR 
09b7 cd c6 18			call break_point_state  
09ba				endm  
# End of macro CALLMONITOR
09ba				endif 
09ba cd 72 0f			call ishlzero 
09bd			;	ld a, l 
09bd			;	add h 
09bd			;	cp 0 
09bd 28 b1			jr z,.sr_fail			; block not found so EOF 
09bf			 
09bf				; save current address for use by higher level words etc 
09bf			 
09bf 22 f8 fb			ld (store_openaddr),hl 
09c2			 
09c2			 
09c2				; hl contains page number to load 
09c2 d1				pop de   ; get storage 
09c3 ed 53 03 fc		ld (store_readbuf), de     ; current buffer to load in to 
09c7 d5				push de 
09c8				if DEBUG_STORESE 
09c8					DMARK "srg" 
09c8 f5				push af  
09c9 3a dd 09			ld a, (.dmark)  
09cc 32 b4 fe			ld (debug_mark),a  
09cf 3a de 09			ld a, (.dmark+1)  
09d2 32 b5 fe			ld (debug_mark+1),a  
09d5 3a df 09			ld a, (.dmark+2)  
09d8 32 b6 fe			ld (debug_mark+2),a  
09db 18 03			jr .pastdmark  
09dd ..			.dmark: db "srg"  
09e0 f1			.pastdmark: pop af  
09e1			endm  
# End of macro DMARK
09e1					CALLMONITOR 
09e1 cd c6 18			call break_point_state  
09e4				endm  
# End of macro CALLMONITOR
09e4				endif 
09e4 cd 19 04			call storage_read_block 
09e7			 
09e7				; if this a continuation read??? 
09e7			 
09e7 2a 03 fc			ld hl, (store_readbuf)     ; current buffer to load in to 
09ea			 
09ea 3e 3f			ld a, STORE_BLOCK_PHY-1 
09ec cd 49 0f			call addatohl 
09ef 7e				ld a,(hl) 
09f0 fe 00			cp 0 
09f2 28 02			jr z, .markiscont 
09f4 3e ff			ld a, 255 
09f6			 
09f6			.markiscont: 
09f6 32 fa fb			ld (store_readcont), a 
09f9			 
09f9				if DEBUG_STORESE 
09f9					DMARK "srC" 
09f9 f5				push af  
09fa 3a 0e 0a			ld a, (.dmark)  
09fd 32 b4 fe			ld (debug_mark),a  
0a00 3a 0f 0a			ld a, (.dmark+1)  
0a03 32 b5 fe			ld (debug_mark+1),a  
0a06 3a 10 0a			ld a, (.dmark+2)  
0a09 32 b6 fe			ld (debug_mark+2),a  
0a0c 18 03			jr .pastdmark  
0a0e ..			.dmark: db "srC"  
0a11 f1			.pastdmark: pop af  
0a12			endm  
# End of macro DMARK
0a12					CALLMONITOR 
0a12 cd c6 18			call break_point_state  
0a15				endm  
# End of macro CALLMONITOR
0a15				endif 
0a15				; only short reads enabled 
0a15			 
0a15 3a 02 fc			ld a, (store_longread) 
0a18 fe 00			cp 0 
0a1a ca e7 0a			jp z, .readdone 
0a1d			 
0a1d			; TODO if block has no zeros then need to read next block  
0a1d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a1d			; check last byte of physical block. 
0a1d			; if not zero then the next block needs to be loaded 
0a1d			 
0a1d			 
0a1d 2a 03 fc			ld hl, (store_readbuf)     ; current buffer to load in to 
0a20			 
0a20 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a22 cd 49 0f			call addatohl 
0a25				;dec hl 
0a25 7e				ld a,(hl) 
0a26				if DEBUG_STORESE 
0a26					DMARK "sr?" 
0a26 f5				push af  
0a27 3a 3b 0a			ld a, (.dmark)  
0a2a 32 b4 fe			ld (debug_mark),a  
0a2d 3a 3c 0a			ld a, (.dmark+1)  
0a30 32 b5 fe			ld (debug_mark+1),a  
0a33 3a 3d 0a			ld a, (.dmark+2)  
0a36 32 b6 fe			ld (debug_mark+2),a  
0a39 18 03			jr .pastdmark  
0a3b ..			.dmark: db "sr?"  
0a3e f1			.pastdmark: pop af  
0a3f			endm  
# End of macro DMARK
0a3f					CALLMONITOR 
0a3f cd c6 18			call break_point_state  
0a42				endm  
# End of macro CALLMONITOR
0a42				endif 
0a42 fe 00			cp 0 
0a44 ca e7 0a			jp z, .readdone 
0a47			 
0a47				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a47			 
0a47 23				inc hl 
0a48			 
0a48 22 03 fc			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a4b			 
0a4b ed 5b 05 fc		ld de, (store_readptr)     ; save the current extent to load 
0a4f			 
0a4f eb				ex de, hl 
0a50			 
0a50				; next ext 
0a50			 
0a50 23				inc hl 
0a51 22 05 fc			ld  (store_readptr), hl     ; save the current extent to load 
0a54			 
0a54				if DEBUG_STORESE 
0a54					DMARK "sF2" 
0a54 f5				push af  
0a55 3a 69 0a			ld a, (.dmark)  
0a58 32 b4 fe			ld (debug_mark),a  
0a5b 3a 6a 0a			ld a, (.dmark+1)  
0a5e 32 b5 fe			ld (debug_mark+1),a  
0a61 3a 6b 0a			ld a, (.dmark+2)  
0a64 32 b6 fe			ld (debug_mark+2),a  
0a67 18 03			jr .pastdmark  
0a69 ..			.dmark: db "sF2"  
0a6c f1			.pastdmark: pop af  
0a6d			endm  
# End of macro DMARK
0a6d					CALLMONITOR 
0a6d cd c6 18			call break_point_state  
0a70				endm  
# End of macro CALLMONITOR
0a70				endif 
0a70			 
0a70				; get and load block 
0a70			 
0a70 cd 4c 07			call storage_findnextid 
0a73			 
0a73				if DEBUG_STORESE 
0a73					DMARK "sf2" 
0a73 f5				push af  
0a74 3a 88 0a			ld a, (.dmark)  
0a77 32 b4 fe			ld (debug_mark),a  
0a7a 3a 89 0a			ld a, (.dmark+1)  
0a7d 32 b5 fe			ld (debug_mark+1),a  
0a80 3a 8a 0a			ld a, (.dmark+2)  
0a83 32 b6 fe			ld (debug_mark+2),a  
0a86 18 03			jr .pastdmark  
0a88 ..			.dmark: db "sf2"  
0a8b f1			.pastdmark: pop af  
0a8c			endm  
# End of macro DMARK
0a8c					CALLMONITOR 
0a8c cd c6 18			call break_point_state  
0a8f				endm  
# End of macro CALLMONITOR
0a8f				endif 
0a8f cd 72 0f			call ishlzero 
0a92			;	ld a, l 
0a92			;	add h 
0a92			;	cp 0 
0a92 ca 70 09			jp z,.sr_fail			; block not found so EOF 
0a95				 
0a95				; save current address for use by higher level words etc 
0a95			 
0a95 22 f8 fb			ld (store_openaddr),hl 
0a98			 
0a98 cd 19 04			call storage_read_block 
0a9b			 
0a9b				; on a continuation block, we now have the file id and ext in the middle of the block 
0a9b				; we need to pull everything back  
0a9b			 
0a9b ed 5b 03 fc		ld de, (store_readbuf)     ; current buffer to nudge into 
0a9f 2a 03 fc			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aa2 23				inc hl 
0aa3 23				inc hl     ; skip id and ext 
0aa4 01 40 00			ld bc, STORE_BLOCK_PHY 
0aa7				if DEBUG_STORESE 
0aa7					DMARK "SR<" 
0aa7 f5				push af  
0aa8 3a bc 0a			ld a, (.dmark)  
0aab 32 b4 fe			ld (debug_mark),a  
0aae 3a bd 0a			ld a, (.dmark+1)  
0ab1 32 b5 fe			ld (debug_mark+1),a  
0ab4 3a be 0a			ld a, (.dmark+2)  
0ab7 32 b6 fe			ld (debug_mark+2),a  
0aba 18 03			jr .pastdmark  
0abc ..			.dmark: db "SR<"  
0abf f1			.pastdmark: pop af  
0ac0			endm  
# End of macro DMARK
0ac0					CALLMONITOR 
0ac0 cd c6 18			call break_point_state  
0ac3				endm  
# End of macro CALLMONITOR
0ac3				endif 
0ac3 ed b0			ldir     ; copy data 
0ac5			 
0ac5				; move the pointer back and pretend we have a full buffer for next recheck 
0ac5			 
0ac5 1b				dec de 
0ac6 1b				dec de 
0ac7			 
0ac7			; TODO do pop below now short circuit loop????? 
0ac7 c1				pop bc     ; get rid of spare de on stack 
0ac8				if DEBUG_STORESE 
0ac8					DMARK "SR>" 
0ac8 f5				push af  
0ac9 3a dd 0a			ld a, (.dmark)  
0acc 32 b4 fe			ld (debug_mark),a  
0acf 3a de 0a			ld a, (.dmark+1)  
0ad2 32 b5 fe			ld (debug_mark+1),a  
0ad5 3a df 0a			ld a, (.dmark+2)  
0ad8 32 b6 fe			ld (debug_mark+2),a  
0adb 18 03			jr .pastdmark  
0add ..			.dmark: db "SR>"  
0ae0 f1			.pastdmark: pop af  
0ae1			endm  
# End of macro DMARK
0ae1					CALLMONITOR 
0ae1 cd c6 18			call break_point_state  
0ae4				endm  
# End of macro CALLMONITOR
0ae4				endif 
0ae4 c3 75 09			jp .srext 
0ae7			 
0ae7			 
0ae7			 
0ae7			 
0ae7			 
0ae7			.readdone:		 
0ae7 e1				pop hl 		 ; return start of data to show as not EOF 
0ae8 23				inc hl   ; past file id 
0ae9 23				inc hl   ; past ext 
0aea				if DEBUG_STORESE 
0aea					DMARK "SRe" 
0aea f5				push af  
0aeb 3a ff 0a			ld a, (.dmark)  
0aee 32 b4 fe			ld (debug_mark),a  
0af1 3a 00 0b			ld a, (.dmark+1)  
0af4 32 b5 fe			ld (debug_mark+1),a  
0af7 3a 01 0b			ld a, (.dmark+2)  
0afa 32 b6 fe			ld (debug_mark+2),a  
0afd 18 03			jr .pastdmark  
0aff ..			.dmark: db "SRe"  
0b02 f1			.pastdmark: pop af  
0b03			endm  
# End of macro DMARK
0b03					CALLMONITOR 
0b03 cd c6 18			call break_point_state  
0b06				endm  
# End of macro CALLMONITOR
0b06				endif 
0b06 c9					ret 
0b07			 
0b07			 
0b07			 
0b07			; 
0b07			; Append File 
0b07			; 
0b07			; hl - file id to locate 
0b07			; de - pointer to (multi block) string to write 
0b07			 
0b07			.sa_notfound: 
0b07 d1				pop de 
0b08 c9				ret 
0b09			 
0b09			 
0b09			storage_append: 
0b09				; hl -  file id to append to 
0b09				; de - string to append 
0b09			 
0b09 d5				push de 
0b0a				 
0b0a				if DEBUG_STORESE 
0b0a					DMARK "AP1" 
0b0a f5				push af  
0b0b 3a 1f 0b			ld a, (.dmark)  
0b0e 32 b4 fe			ld (debug_mark),a  
0b11 3a 20 0b			ld a, (.dmark+1)  
0b14 32 b5 fe			ld (debug_mark+1),a  
0b17 3a 21 0b			ld a, (.dmark+2)  
0b1a 32 b6 fe			ld (debug_mark+2),a  
0b1d 18 03			jr .pastdmark  
0b1f ..			.dmark: db "AP1"  
0b22 f1			.pastdmark: pop af  
0b23			endm  
# End of macro DMARK
0b23					CALLMONITOR 
0b23 cd c6 18			call break_point_state  
0b26				endm  
# End of macro CALLMONITOR
0b26				endif 
0b26			 
0b26 7d				ld a, l 
0b27 32 fb fb			ld (store_tmpid), a 
0b2a			 
0b2a				; get file header  
0b2a			 
0b2a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b2c 3a fb fb			ld a, (store_tmpid) 
0b2f 5f				ld e, a 
0b30			 
0b30 21 40 00				ld hl, STORE_BLOCK_PHY 
0b33 cd 4c 07				call storage_findnextid 
0b36			 
0b36 cd 72 0f			call ishlzero 
0b39 28 cc			jr z, .sa_notfound 
0b3b			 
0b3b 22 f2 fb			ld (store_tmppageid), hl 
0b3e			 
0b3e				; TODO handle file id not found 
0b3e			 
0b3e				if DEBUG_STORESE 
0b3e					DMARK "AP2" 
0b3e f5				push af  
0b3f 3a 53 0b			ld a, (.dmark)  
0b42 32 b4 fe			ld (debug_mark),a  
0b45 3a 54 0b			ld a, (.dmark+1)  
0b48 32 b5 fe			ld (debug_mark+1),a  
0b4b 3a 55 0b			ld a, (.dmark+2)  
0b4e 32 b6 fe			ld (debug_mark+2),a  
0b51 18 03			jr .pastdmark  
0b53 ..			.dmark: db "AP2"  
0b56 f1			.pastdmark: pop af  
0b57			endm  
# End of macro DMARK
0b57					CALLMONITOR 
0b57 cd c6 18			call break_point_state  
0b5a				endm  
# End of macro CALLMONITOR
0b5a				endif 
0b5a			 
0b5a				; update file extent count 
0b5a			 
0b5a 11 07 fc			ld de, store_page 
0b5d			 
0b5d cd 19 04			call storage_read_block 
0b60			 
0b60				if DEBUG_STORESE 
0b60					DMARK "AP3" 
0b60 f5				push af  
0b61 3a 75 0b			ld a, (.dmark)  
0b64 32 b4 fe			ld (debug_mark),a  
0b67 3a 76 0b			ld a, (.dmark+1)  
0b6a 32 b5 fe			ld (debug_mark+1),a  
0b6d 3a 77 0b			ld a, (.dmark+2)  
0b70 32 b6 fe			ld (debug_mark+2),a  
0b73 18 03			jr .pastdmark  
0b75 ..			.dmark: db "AP3"  
0b78 f1			.pastdmark: pop af  
0b79			endm  
# End of macro DMARK
0b79					CALLMONITOR 
0b79 cd c6 18			call break_point_state  
0b7c				endm  
# End of macro CALLMONITOR
0b7c				endif 
0b7c			;	ld (store_tmppageid), hl 
0b7c			 
0b7c 3a 09 fc			ld a, (store_page+2) 
0b7f 3c				inc a 
0b80 32 09 fc			ld (store_page+2), a 
0b83 32 fa fb			ld (store_tmpext), a 
0b86				 
0b86				if DEBUG_STORESE 
0b86					DMARK "AP3" 
0b86 f5				push af  
0b87 3a 9b 0b			ld a, (.dmark)  
0b8a 32 b4 fe			ld (debug_mark),a  
0b8d 3a 9c 0b			ld a, (.dmark+1)  
0b90 32 b5 fe			ld (debug_mark+1),a  
0b93 3a 9d 0b			ld a, (.dmark+2)  
0b96 32 b6 fe			ld (debug_mark+2),a  
0b99 18 03			jr .pastdmark  
0b9b ..			.dmark: db "AP3"  
0b9e f1			.pastdmark: pop af  
0b9f			endm  
# End of macro DMARK
0b9f					CALLMONITOR 
0b9f cd c6 18			call break_point_state  
0ba2				endm  
# End of macro CALLMONITOR
0ba2				endif 
0ba2 2a f2 fb			ld hl, (store_tmppageid) 
0ba5 11 07 fc			ld de, store_page 
0ba8 cd 7e 04			call storage_write_block 
0bab			 
0bab				; find free block 
0bab			 
0bab 11 00 00			ld de, 0			 ; file extent to locate 
0bae			 
0bae 21 40 00				ld hl, STORE_BLOCK_PHY 
0bb1 cd 4c 07				call storage_findnextid 
0bb4 cd 72 0f			call ishlzero 
0bb7 ca 07 0b			jp z, .sa_notfound 
0bba			 
0bba					; TODO handle no space left 
0bba					 
0bba 22 f2 fb				ld (store_tmppageid), hl 
0bbd			 
0bbd				if DEBUG_STORESE 
0bbd					DMARK "AP4" 
0bbd f5				push af  
0bbe 3a d2 0b			ld a, (.dmark)  
0bc1 32 b4 fe			ld (debug_mark),a  
0bc4 3a d3 0b			ld a, (.dmark+1)  
0bc7 32 b5 fe			ld (debug_mark+1),a  
0bca 3a d4 0b			ld a, (.dmark+2)  
0bcd 32 b6 fe			ld (debug_mark+2),a  
0bd0 18 03			jr .pastdmark  
0bd2 ..			.dmark: db "AP4"  
0bd5 f1			.pastdmark: pop af  
0bd6			endm  
# End of macro DMARK
0bd6					CALLMONITOR 
0bd6 cd c6 18			call break_point_state  
0bd9				endm  
# End of macro CALLMONITOR
0bd9				endif 
0bd9					; init the buffer with zeros so we can id if the buffer is full or not 
0bd9			 
0bd9 e5					push hl 
0bda c5					push bc 
0bdb			 
0bdb 21 07 fc				ld hl, store_page 
0bde 06 40				ld b, STORE_BLOCK_PHY 
0be0 3e 00				ld a, 0 
0be2 77			.zeroblock:	ld (hl), a 
0be3 23					inc hl 
0be4 10 fc				djnz .zeroblock 
0be6			 
0be6 c1					pop bc 
0be7 e1					pop hl 
0be8			 
0be8					; construct block 
0be8			 
0be8 3a fb fb				ld a, (store_tmpid) 
0beb 32 07 fc				ld (store_page), a   ; file id 
0bee 3a fa fb				ld a, (store_tmpext)   ; extent for this block 
0bf1 32 08 fc				ld (store_page+1), a 
0bf4			 
0bf4 e1					pop hl    ; get string to write 
0bf5 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0bf7 11 09 fc				ld de, store_page+2 
0bfa			 
0bfa				if DEBUG_STORESE 
0bfa					DMARK "AP5" 
0bfa f5				push af  
0bfb 3a 0f 0c			ld a, (.dmark)  
0bfe 32 b4 fe			ld (debug_mark),a  
0c01 3a 10 0c			ld a, (.dmark+1)  
0c04 32 b5 fe			ld (debug_mark+1),a  
0c07 3a 11 0c			ld a, (.dmark+2)  
0c0a 32 b6 fe			ld (debug_mark+2),a  
0c0d 18 03			jr .pastdmark  
0c0f ..			.dmark: db "AP5"  
0c12 f1			.pastdmark: pop af  
0c13			endm  
# End of macro DMARK
0c13					CALLMONITOR 
0c13 cd c6 18			call break_point_state  
0c16				endm  
# End of macro CALLMONITOR
0c16				endif 
0c16			 
0c16			 
0c16			 
0c16					; fill buffer with data until end of string or full block 
0c16			 
0c16 7e			.appd:		ld a, (hl) 
0c17 12					ld (de), a 
0c18 fe 00				cp 0 
0c1a 28 04				jr z, .appdone 
0c1c 23					inc hl 
0c1d 13					inc de 
0c1e 10 f6				djnz .appd 
0c20			 
0c20 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c21 f5					push af   		; save last byte dumped 
0c22			 
0c22			 
0c22 2a f2 fb			ld hl, (store_tmppageid) 
0c25 11 07 fc			ld de, store_page 
0c28				if DEBUG_STORESE 
0c28					DMARK "AP6" 
0c28 f5				push af  
0c29 3a 3d 0c			ld a, (.dmark)  
0c2c 32 b4 fe			ld (debug_mark),a  
0c2f 3a 3e 0c			ld a, (.dmark+1)  
0c32 32 b5 fe			ld (debug_mark+1),a  
0c35 3a 3f 0c			ld a, (.dmark+2)  
0c38 32 b6 fe			ld (debug_mark+2),a  
0c3b 18 03			jr .pastdmark  
0c3d ..			.dmark: db "AP6"  
0c40 f1			.pastdmark: pop af  
0c41			endm  
# End of macro DMARK
0c41					CALLMONITOR 
0c41 cd c6 18			call break_point_state  
0c44				endm  
# End of macro CALLMONITOR
0c44				endif 
0c44 cd 7e 04				call storage_write_block 
0c47			 
0c47			 
0c47				; was that a full block of data written? 
0c47				; any more to write out? 
0c47			 
0c47				; if yes then set vars and jump to start of function again 
0c47			 
0c47 f1					pop af 
0c48 d1					pop de 
0c49			 
0c49 fe 00				cp 0		 ; no, string was fully written 
0c4b c8					ret z 
0c4c			 
0c4c					; setup vars for next cycle 
0c4c			 
0c4c 3a fb fb				ld a, (store_tmpid) 
0c4f 6f					ld l, a 
0c50 26 00				ld h, 0 
0c52			 
0c52 c3 09 0b			 	jp storage_append	 ; yes, need to write out some more 
0c55			 
0c55			 
0c55			 
0c55			 
0c55			 
0c55			 
0c55			 
0c55			if DEBUG_STORECF 
0c55			storageput:	 
0c55					ret 
0c55			storageread: 
0c55					ld hl, store_page 
0c55					ld b, 200 
0c55					ld a,0 
0c55			.src:		ld (hl),a 
0c55					inc hl 
0c55					djnz .src 
0c55					 
0c55			 
0c55					ld de, 0 
0c55					ld bc, 1 
0c55					ld hl, store_page 
0c55					call cfRead 
0c55			 
0c55				call cfGetError 
0c55				ld hl,scratch 
0c55				call hexout 
0c55				ld hl, scratch+2 
0c55				ld a, 0 
0c55				ld (hl),a 
0c55				ld de, scratch 
0c55				ld a,display_row_1 
0c55				call str_at_display 
0c55				call update_display 
0c55			 
0c55					ld hl, store_page 
0c55					ld (os_cur_ptr),hl 
0c55			 
0c55					ret 
0c55			endif 
0c55			 
0c55			 
0c55			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c55			 
0c55			storage_clear_page: 
0c55 e5				push hl 
0c56 d5				push de 
0c57 c5				push bc 
0c58 21 07 fc			ld hl, store_page 
0c5b 3e 00			ld a, 0 
0c5d 77				ld (hl), a 
0c5e			 
0c5e 11 08 fc			ld de, store_page+1 
0c61 01 18 01			ld bc, STORE_BLOCK_LOG 
0c64			 
0c64 ed b0			ldir 
0c66				 
0c66 c1				pop bc 
0c67 d1				pop de 
0c68 e1				pop hl 
0c69 c9				ret 
0c6a			 
0c6a			; eof 
# End of file firmware_storage.asm
0c6a			  
0c6a			; support routines for above hardware abstraction layer  
0c6a			  
0c6a			include "firmware_general.asm"        ; general support functions  
0c6a			 
0c6a			; word look up 
0c6a			 
0c6a			; in 
0c6a			; a is the index 
0c6a			; hl is pointer start of array 
0c6a			; 
0c6a			; returns 
0c6a			; hl to the word 
0c6a			; 
0c6a			 
0c6a			table_lookup:  
0c6a d5					push de 
0c6b eb					ex de, hl 
0c6c			 
0c6c 6f					ld l, a 
0c6d 26 00				ld h, 0 
0c6f 29					add hl, hl 
0c70 19					add hl, de 
0c71 7e					ld a, (hl) 
0c72 23					inc hl 
0c73 66					ld h,(hl) 
0c74 6f					ld l, a 
0c75			 
0c75 d1					pop de 
0c76 c9					ret 
0c77			 
0c77			; Delay loops 
0c77			 
0c77			 
0c77			 
0c77			aDelayInMS: 
0c77 c5				push bc 
0c78 47				ld b,a 
0c79			msdelay: 
0c79 c5				push bc 
0c7a				 
0c7a			 
0c7a 01 41 00			ld bc,041h 
0c7d cd 95 0c			call delayloop 
0c80 c1				pop bc 
0c81 05				dec b 
0c82 20 f5			jr nz,msdelay 
0c84			 
0c84			;if CPU_CLOCK_8MHZ 
0c84			;msdelay8: 
0c84			;	push bc 
0c84			;	 
0c84			; 
0c84			;	ld bc,041h 
0c84			;	call delayloop 
0c84			;	pop bc 
0c84			;	dec b 
0c84			;	jr nz,msdelay8 
0c84			;endif 
0c84			 
0c84			 
0c84 c1				pop bc 
0c85 c9				ret 
0c86			 
0c86			 
0c86			delay250ms: 
0c86				;push de 
0c86 01 00 40			ld bc, 04000h 
0c89 c3 95 0c			jp delayloop 
0c8c			delay500ms: 
0c8c				;push de 
0c8c 01 00 80			ld bc, 08000h 
0c8f c3 95 0c			jp delayloop 
0c92			delay1s: 
0c92				;push bc 
0c92			   ; Clobbers A, d and e 
0c92 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c95			delayloop: 
0c95 c5			    push bc 
0c96			 
0c96			if BASE_CPM 
0c96				ld bc, CPM_DELAY_TUNE 
0c96			.cpmloop: 
0c96				push bc 
0c96			 
0c96			endif 
0c96			 
0c96			 
0c96			 
0c96			delayloopi: 
0c96			;	push bc 
0c96			;.dl: 
0c96 cb 47		    bit     0,a    	; 8 
0c98 cb 47		    bit     0,a    	; 8 
0c9a cb 47		    bit     0,a    	; 8 
0c9c e6 ff		    and     255  	; 7 
0c9e 0b			    dec     bc      	; 6 
0c9f 79			    ld      a,c     	; 4 
0ca0 b0			    or      b     	; 4 
0ca1 c2 96 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0ca4			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0ca4				;pop de 
0ca4			;pop bc 
0ca4			 
0ca4			if BASE_CPM 
0ca4				pop bc 
0ca4				 
0ca4			    dec     bc      	; 6 
0ca4			    ld      a,c     	; 4 
0ca4			    or      b     	; 4 
0ca4			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0ca4				 
0ca4			 
0ca4			endif 
0ca4			;if CPU_CLOCK_8MHZ 
0ca4			;    pop bc 
0ca4			;    push bc 
0ca4			;.dl8: 
0ca4			;    bit     0,a    	; 8 
0ca4			;    bit     0,a    	; 8 
0ca4			;    bit     0,a    	; 8 
0ca4			;    and     255  	; 7 
0ca4			;    dec     bc      	; 6 
0ca4			;    ld      a,c     	; 4 
0ca4			;    or      b     	; 4 
0ca4			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca4			;endif 
0ca4			 
0ca4			;if CPU_CLOCK_10MHZ 
0ca4			;    pop bc 
0ca4			;    push bc 
0ca4			;.dl8: 
0ca4			;    bit     0,a    	; 8 
0ca4			;    bit     0,a    	; 8 
0ca4			;    bit     0,a    	; 8 
0ca4			;    and     255  	; 7 
0ca4			;    dec     bc      	; 6 
0ca4			;    ld      a,c     	; 4 
0ca4			;    or      b     	; 4 
0ca4			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca4			;endif 
0ca4 c1			    pop bc 
0ca5			 
0ca5 c9				ret 
0ca6			 
0ca6			 
0ca6			 
0ca6			; eof 
# End of file firmware_general.asm
0ca6			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0ca6			; display routines that use the physical hardware abstraction layer 
0ca6			 
0ca6			 
0ca6			; information window 
0ca6			 
0ca6			; pass hl with 1st string to display 
0ca6			; pass de with 2nd string to display 
0ca6			 
0ca6			info_panel: 
0ca6 e5				push hl 
0ca7			 
0ca7 2a 55 fd			ld hl, (display_fb_active) 
0caa e5				push hl    ; future de destination 
0cab 21 4a fe				ld hl, display_fb0 
0cae 22 55 fd				ld (display_fb_active), hl 
0cb1			 
0cb1			;	call clear_display 
0cb1			 
0cb1				if BASE_CPM 
0cb1				ld a, '.' 
0cb1				else 
0cb1 3e a5			ld a, 165 
0cb3				endif 
0cb3 cd 1a 0d			call fill_display 
0cb6			 
0cb6			 
0cb6 3e 2d			ld a, display_row_3 + 5 
0cb8 cd 28 0d			call str_at_display 
0cbb			 
0cbb e1				pop hl 
0cbc d1				pop de 
0cbd			 
0cbd e5				push hl 
0cbe			 
0cbe			 
0cbe 3e 19			ld a, display_row_2 + 5 
0cc0 cd 28 0d			call str_at_display 
0cc3			 
0cc3			 
0cc3 cd 38 0d			call update_display 
0cc6 cd b2 1e			call next_page_prompt 
0cc9 cd 15 0d			call clear_display 
0ccc			 
0ccc				 
0ccc 21 f9 fd				ld hl, display_fb1 
0ccf 22 55 fd				ld (display_fb_active), hl 
0cd2 cd 38 0d			call update_display 
0cd5			 
0cd5 e1				pop hl 
0cd6			 
0cd6 c9				ret 
0cd7			 
0cd7			 
0cd7			 
0cd7			 
0cd7			; TODO windowing? 
0cd7			 
0cd7			; TODO scroll line up 
0cd7			 
0cd7			scroll_up: 
0cd7			 
0cd7 e5				push hl 
0cd8 d5				push de 
0cd9 c5				push bc 
0cda			 
0cda				; get frame buffer  
0cda			 
0cda 2a 55 fd			ld hl, (display_fb_active) 
0cdd e5				push hl    ; future de destination 
0cde			 
0cde 11 14 00			ld  de, display_cols 
0ce1 19				add hl, de 
0ce2			 
0ce2 d1				pop de 
0ce3			 
0ce3				;ex de, hl 
0ce3 01 4f 00			ld bc, display_fb_len -1  
0ce6			;if DEBUG_FORTH_WORDS 
0ce6			;	DMARK "SCL" 
0ce6			;	CALLMONITOR 
0ce6			;endif	 
0ce6 ed b0			ldir 
0ce8			 
0ce8				; wipe bottom row 
0ce8			 
0ce8			 
0ce8 2a 55 fd			ld hl, (display_fb_active) 
0ceb 11 50 00			ld de, display_cols*display_rows 
0cee 19				add hl, de 
0cef 06 14			ld b, display_cols 
0cf1 3e 20			ld a, ' ' 
0cf3			.scwipe: 
0cf3 77				ld (hl), a 
0cf4 2b				dec hl 
0cf5 10 fc			djnz .scwipe 
0cf7			 
0cf7				;pop hl 
0cf7			 
0cf7 c1				pop bc 
0cf8 d1				pop de 
0cf9 e1				pop hl 
0cfa			 
0cfa c9				ret 
0cfb			 
0cfb			 
0cfb			;scroll_upo: 
0cfb			;	ld de, display_row_1 
0cfb			 ;	ld hl, display_row_2 
0cfb			;	ld bc, display_cols 
0cfb			;	ldir 
0cfb			;	ld de, display_row_2 
0cfb			 ;	ld hl, display_row_3 
0cfb			;	ld bc, display_cols 
0cfb			;	ldir 
0cfb			;	ld de, display_row_3 
0cfb			 ;	ld hl, display_row_4 
0cfb			;	ld bc, display_cols 
0cfb			;	ldir 
0cfb			 
0cfb			; TODO clear row 4 
0cfb			 
0cfb			;	ret 
0cfb			 
0cfb				 
0cfb			scroll_down: 
0cfb			 
0cfb e5				push hl 
0cfc d5				push de 
0cfd c5				push bc 
0cfe			 
0cfe				; get frame buffer  
0cfe			 
0cfe 2a 55 fd			ld hl, (display_fb_active) 
0d01			 
0d01 11 4f 00			ld de, display_fb_len - 1 
0d04 19				add hl, de 
0d05			 
0d05 e5			push hl    ; future de destination 
0d06			 
0d06 11 14 00			ld  de, display_cols 
0d09 ed 52			sbc hl, de 
0d0b			 
0d0b			 
0d0b d1				pop de 
0d0c			 
0d0c			;	ex de, hl 
0d0c 01 4f 00			ld bc, display_fb_len -1  
0d0f			 
0d0f			 
0d0f				 
0d0f			 
0d0f ed b0			ldir 
0d11			 
0d11				; wipe bottom row 
0d11			 
0d11			 
0d11			;	ld hl, (display_fb_active) 
0d11			;;	ld de, display_cols*display_rows 
0d11			;;	add hl, de 
0d11			;	ld b, display_cols 
0d11			;	ld a, ' ' 
0d11			;.scwiped: 
0d11			;	ld (hl), a 
0d11			;	dec hl 
0d11			;	djnz .scwiped 
0d11			 
0d11				;pop hl 
0d11			 
0d11 c1				pop bc 
0d12 d1				pop de 
0d13 e1				pop hl 
0d14			 
0d14 c9				ret 
0d15			;scroll_down: 
0d15			;	ld de, display_row_4 
0d15			;	ld hl, display_row_3 
0d15			;	ld bc, display_cols 
0d15			;	ldir 
0d15			;	ld de, display_row_3 
0d15			; 	ld hl, display_row_2 
0d15			;	ld bc, display_cols 
0d15			;	ldir 
0d15			;	ld de, display_row_2 
0d15			;	ld hl, display_row_1 
0d15			;	ld bc, display_cols 
0d15			;	ldir 
0d15			;;; TODO clear row 1 
0d15			;	ret 
0d15			 
0d15			 
0d15			 
0d15			 
0d15			 
0d15			; clear active frame buffer 
0d15			 
0d15			clear_display: 
0d15 3e 20			ld a, ' ' 
0d17 c3 1a 0d			jp fill_display 
0d1a			 
0d1a			; fill active frame buffer with a char in A 
0d1a			 
0d1a			fill_display: 
0d1a 06 50			ld b,display_fb_len 
0d1c 2a 55 fd			ld hl, (display_fb_active) 
0d1f 77			.fd1:	ld (hl),a 
0d20 23				inc hl 
0d21 10 fc			djnz .fd1 
0d23 23				inc hl 
0d24 3e 00			ld a,0 
0d26 77				ld (hl),a 
0d27			 
0d27			 
0d27 c9				ret 
0d28			; Write string (DE) at pos (A) to active frame buffer 
0d28			 
0d28 2a 55 fd		str_at_display:    ld hl,(display_fb_active) 
0d2b 06 00					ld b,0 
0d2d 4f					ld c,a 
0d2e 09					add hl,bc 
0d2f 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0d30 b7			            OR   A              ;Null terminator? 
0d31 c8			            RET  Z              ;Yes, so finished 
0d32 77					ld (hl),a 
0d33 23				inc hl 
0d34 13			            INC  DE             ;Point to next character 
0d35 18 f8		            JR   .sad1     ;Repeat 
0d37 c9					ret 
0d38			 
0d38			; using current frame buffer write to physical display 
0d38			 
0d38			update_display: 
0d38 e5				push hl 
0d39 2a 55 fd			ld hl, (display_fb_active) 
0d3c cd 0d 70			call write_display 
0d3f e1				pop hl 
0d40 c9				ret 
0d41			 
0d41			; TODO scrolling 
0d41			 
0d41			 
0d41			; move cursor right one char 
0d41			cursor_right: 
0d41			 
0d41				; TODO shift right 
0d41				; TODO if beyond max col 
0d41				; TODO       cursor_next_line 
0d41			 
0d41 c9				ret 
0d42			 
0d42			 
0d42			cursor_next_line: 
0d42				; TODO first char 
0d42				; TODO line down 
0d42				; TODO if past last row 
0d42				; TODO    scroll up 
0d42			 
0d42 c9				ret 
0d43			 
0d43			cursor_left: 
0d43				; TODO shift left 
0d43				; TODO if beyond left  
0d43				; TODO     cursor prev line 
0d43				 
0d43 c9				ret 
0d44			 
0d44			cursor_prev_line: 
0d44				; TODO last char 
0d44				; TODO line up 
0d44				; TODO if past first row 
0d44				; TODO   scroll down 
0d44			 
0d44 c9				ret 
0d45			 
0d45			 
0d45			cout: 
0d45				; A - char 
0d45 c9				ret 
0d46			 
0d46			 
0d46			; Display a menu and allow item selection (optional toggle items) 
0d46			; 
0d46			; format: 
0d46			; hl pointer to word array with zero term for items 
0d46			; e.g.    db item1 
0d46			;         db .... 
0d46			;         db 0 
0d46			; 
0d46			; a = starting menu item  
0d46			; 
0d46			; de = pointer item toggle array   (todo) 
0d46			; 
0d46			; returns item selected in a 1-... 
0d46			; returns 0 if back button pressed 
0d46			; 
0d46			; NOTE: Uses system frame buffer to display 
0d46			; 
0d46			; LEFT, Q = go back 
0d46			; RIGHT, SPACE, CR = select 
0d46			; UP, A - Up 
0d46			; DOWN, Z - Down 
0d46			 
0d46			 
0d46			 
0d46			 
0d46			 
0d46			menu: 
0d46			 
0d46					; keep array pointer 
0d46			 
0d46 22 00 fc				ld (store_tmp1), hl 
0d49 32 fe fb				ld (store_tmp2), a 
0d4c			 
0d4c					; check for key bounce 
0d4c			 
0d4c			if BASE_KEV 
0d4c			 
0d4c cd c2 71		.mbounce:	call cin 
0d4f fe 00				cp 0 
0d51 20 f9				jr nz, .mbounce 
0d53			endif 
0d53					; for ease use ex 
0d53			 
0d53					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0d53 21 4a fe				ld hl, display_fb0 
0d56 22 55 fd				ld (display_fb_active), hl 
0d59			 
0d59 cd 15 0d		.mloop:		call clear_display 
0d5c cd 38 0d				call update_display 
0d5f			 
0d5f					; draw selection id '>' at 1 
0d5f			 
0d5f					; init start of list display 
0d5f			 
0d5f 3e 05				ld a, 5 
0d61 32 fc fb				ld (store_tmp3), a   ; display row count 
0d64 3a fe fb				ld a,( store_tmp2) 
0d67 32 ff fb				ld (store_tmp2+1), a   ; display item count 
0d6a			 
0d6a					 
0d6a			.mitem:	 
0d6a			 
0d6a			 
0d6a 3a ff fb				ld a,(store_tmp2+1) 
0d6d 6f					ld l, a 
0d6e 26 00				ld h, 0 
0d70 29					add hl, hl 
0d71 ed 5b 00 fc			ld de, (store_tmp1) 
0d75 19					add hl, de 
0d76 7e					ld a, (hl) 
0d77 23					inc hl 
0d78 66					ld h,(hl) 
0d79 6f					ld l, a 
0d7a			 
0d7a cd 72 0f				call ishlzero 
0d7d 28 1a				jr z, .mdone 
0d7f			 
0d7f eb					ex de, hl 
0d80 3a fc fb				ld a, (store_tmp3) 
0d83 cd 28 0d				call str_at_display 
0d86					 
0d86			 
0d86					; next item 
0d86 3a ff fb				ld a, (store_tmp2+1) 
0d89 3c					inc a 
0d8a 32 ff fb				ld (store_tmp2+1), a   ; display item count 
0d8d			 
0d8d			 		; next row 
0d8d			 
0d8d 3a fc fb				ld a, (store_tmp3) 
0d90 c6 14				add display_cols 
0d92 32 fc fb				ld (store_tmp3), a 
0d95			 
0d95					; at end of screen? 
0d95			 
0d95 fe 10				cp display_rows*4 
0d97 20 d1				jr nz, .mitem 
0d99			 
0d99			 
0d99			.mdone: 
0d99 cd 72 0f				call ishlzero 
0d9c 28 08				jr z, .nodn 
0d9e			 
0d9e 3e 3c				ld a, display_row_4 
0da0 11 1f 0e				ld de, .mdown 
0da3 cd 28 0d				call str_at_display 
0da6			 
0da6					; draw options to fill the screens with active item on line 1 
0da6					; if current option is 2 or more then display ^ in top 
0da6			 
0da6 3a fe fb		.nodn:		ld a, (store_tmp2) 
0da9 fe 00				cp 0 
0dab 28 08				jr z, .noup 
0dad			 
0dad 3e 00				ld a, 0 
0daf 11 1d 0e				ld de, .mup 
0db2 cd 28 0d				call str_at_display 
0db5			 
0db5 3e 02		.noup:		ld a, 2 
0db7 11 1b 0e				ld de, .msel 
0dba cd 28 0d				call str_at_display 
0dbd			 
0dbd					; if current option + 1 is not null then display V in bottom 
0dbd					; get key 
0dbd cd 38 0d				call update_display 
0dc0			 
0dc0			 
0dc0					; handle key 
0dc0			 
0dc0 cd b1 71				call cin_wait 
0dc3			 
0dc3 fe 05				cp KEY_UP 
0dc5 28 2b				jr z, .mgoup 
0dc7 fe 61				cp 'a' 
0dc9 28 27				jr z, .mgoup 
0dcb fe 0a				cp KEY_DOWN 
0dcd 28 32				jr z, .mgod 
0dcf fe 7a				cp 'z' 
0dd1 28 2e				jr z, .mgod 
0dd3 fe 20				cp ' ' 
0dd5 28 34				jr z, .goend 
0dd7 fe 0c				cp KEY_RIGHT 
0dd9 28 30				jr z, .goend 
0ddb fe 0d				cp KEY_CR 
0ddd 28 2c				jr z, .goend 
0ddf fe 71				cp 'q' 
0de1 28 0b				jr z, .goback 
0de3			 
0de3 fe 0b				cp KEY_LEFT 
0de5 28 07				jr z, .goback 
0de7 fe 08				cp KEY_BS 
0de9 28 03				jr z, .goback 
0deb c3 59 0d				jp .mloop 
0dee			 
0dee			.goback: 
0dee 3e 00			ld a, 0 
0df0 18 1d			jr .goend2 
0df2			 
0df2				; move up one 
0df2			.mgoup: 
0df2 3a fe fb				ld a, (store_tmp2) 
0df5 fe 00				cp 0 
0df7 ca 59 0d				jp z, .mloop 
0dfa 3d					dec a 
0dfb 32 fe fb				ld (store_tmp2), a 
0dfe c3 59 0d				jp .mloop 
0e01			 
0e01				; move down one 
0e01			.mgod: 
0e01 3a fe fb				ld a, (store_tmp2) 
0e04 3c					inc a 
0e05 32 fe fb				ld (store_tmp2), a 
0e08 c3 59 0d				jp .mloop 
0e0b			 
0e0b			 
0e0b			.goend: 
0e0b					; get selected item number 
0e0b			 
0e0b 3a fe fb				ld a, (store_tmp2) 
0e0e 3c					inc a 
0e0f			 
0e0f			.goend2: 
0e0f f5					push af 
0e10			 
0e10					; restore active fb 
0e10					; TODO BUG assumes fb1 
0e10			 
0e10 21 f9 fd				ld hl, display_fb1 
0e13 22 55 fd				ld (display_fb_active), hl 
0e16			 
0e16					; restore main regs 
0e16			 
0e16			 
0e16 cd 38 0d				call update_display 
0e19			 
0e19 f1					pop af 
0e1a			 
0e1a c9				ret 
0e1b			 
0e1b .. 00		.msel:   db ">",0 
0e1d .. 00		.mup:   db "^",0 
0e1f .. 00		.mdown:   db "v",0 
0e21			 
0e21			 
0e21			; eof 
0e21			 
# End of file firmware_display.asm
0e21			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0e21			; random number generators 
0e21			 
0e21			 
0e21			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0e21			 
0e21			 
0e21			;-----> Generate a random number 
0e21			; output a=answer 0<=a<=255 
0e21			; all registers are preserved except: af 
0e21			random: 
0e21 e5			        push    hl 
0e22 d5			        push    de 
0e23 2a 37 fd		        ld      hl,(randData) 
0e26 ed 5f		        ld      a,r 
0e28 57			        ld      d,a 
0e29 5e			        ld      e,(hl) 
0e2a 19			        add     hl,de 
0e2b 85			        add     a,l 
0e2c ac			        xor     h 
0e2d 22 37 fd		        ld      (randData),hl 
0e30 d1			        pop     de 
0e31 e1			        pop     hl 
0e32 c9			        ret 
0e33			 
0e33			 
0e33			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0e33			 
0e33			 
0e33			 
0e33			;------LFSR------ 
0e33			;James Montelongo 
0e33			;optimized by Spencer Putt 
0e33			;out: 
0e33			; a = 8 bit random number 
0e33			RandLFSR: 
0e33 21 3d fd		        ld hl,LFSRSeed+4 
0e36 5e			        ld e,(hl) 
0e37 23			        inc hl 
0e38 56			        ld d,(hl) 
0e39 23			        inc hl 
0e3a 4e			        ld c,(hl) 
0e3b 23			        inc hl 
0e3c 7e			        ld a,(hl) 
0e3d 47			        ld b,a 
0e3e cb 13		        rl e  
0e40 cb 12			rl d 
0e42 cb 11		        rl c  
0e44 17				rla 
0e45 cb 13		        rl e  
0e47 cb 12			rl d 
0e49 cb 11		        rl c  
0e4b 17				rla 
0e4c cb 13		        rl e  
0e4e cb 12			rl d 
0e50 cb 11		        rl c  
0e52 17				rla 
0e53 67			        ld h,a 
0e54 cb 13		        rl e  
0e56 cb 12			rl d 
0e58 cb 11		        rl c  
0e5a 17				rla 
0e5b a8			        xor b 
0e5c cb 13		        rl e  
0e5e cb 12			rl d 
0e60 ac			        xor h 
0e61 a9			        xor c 
0e62 aa			        xor d 
0e63 21 3f fd		        ld hl,LFSRSeed+6 
0e66 11 40 fd		        ld de,LFSRSeed+7 
0e69 01 07 00		        ld bc,7 
0e6c ed b8		        lddr 
0e6e 12			        ld (de),a 
0e6f c9			        ret 
0e70			 
0e70			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0e70			 
0e70			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0e70			 
0e70			 
0e70			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0e70			 
0e70			prng16: 
0e70			;Inputs: 
0e70			;   (seed1) contains a 16-bit seed value 
0e70			;   (seed2) contains a NON-ZERO 16-bit seed value 
0e70			;Outputs: 
0e70			;   HL is the result 
0e70			;   BC is the result of the LCG, so not that great of quality 
0e70			;   DE is preserved 
0e70			;Destroys: 
0e70			;   AF 
0e70			;cycle: 4,294,901,760 (almost 4.3 billion) 
0e70			;160cc 
0e70			;26 bytes 
0e70 2a 31 fd		    ld hl,(seed1) 
0e73 44			    ld b,h 
0e74 4d			    ld c,l 
0e75 29			    add hl,hl 
0e76 29			    add hl,hl 
0e77 2c			    inc l 
0e78 09			    add hl,bc 
0e79 22 31 fd		    ld (seed1),hl 
0e7c 2a 2f fd		    ld hl,(seed2) 
0e7f 29			    add hl,hl 
0e80 9f			    sbc a,a 
0e81 e6 2d		    and %00101101 
0e83 ad			    xor l 
0e84 6f			    ld l,a 
0e85 22 2f fd		    ld (seed2),hl 
0e88 09			    add hl,bc 
0e89 c9			    ret 
0e8a			 
0e8a			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0e8a			 
0e8a			rand32: 
0e8a			;Inputs: 
0e8a			;   (seed1_0) holds the lower 16 bits of the first seed 
0e8a			;   (seed1_1) holds the upper 16 bits of the first seed 
0e8a			;   (seed2_0) holds the lower 16 bits of the second seed 
0e8a			;   (seed2_1) holds the upper 16 bits of the second seed 
0e8a			;   **NOTE: seed2 must be non-zero 
0e8a			;Outputs: 
0e8a			;   HL is the result 
0e8a			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0e8a			;Destroys: 
0e8a			;   AF 
0e8a			;Tested and passes all CAcert tests 
0e8a			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0e8a			;it has a period of 18,446,744,069,414,584,320 
0e8a			;roughly 18.4 quintillion. 
0e8a			;LFSR taps: 0,2,6,7  = 11000101 
0e8a			;291cc 
0e8a			;seed1_0=$+1 
0e8a			;    ld hl,12345 
0e8a			;seed1_1=$+1 
0e8a			;    ld de,6789 
0e8a			;    ld b,h 
0e8a			;    ld c,l 
0e8a			;    add hl,hl \ rl e \ rl d 
0e8a			;    add hl,hl \ rl e \ rl d 
0e8a			;    inc l 
0e8a			;    add hl,bc 
0e8a			;    ld (seed1_0),hl 
0e8a			;    ld hl,(seed1_1) 
0e8a			;    adc hl,de 
0e8a			;    ld (seed1_1),hl 
0e8a			;    ex de,hl 
0e8a			;seed2_0=$+1 
0e8a			;    ld hl,9876 
0e8a			;seed2_1=$+1 
0e8a			;    ld bc,54321 
0e8a			;    add hl,hl \ rl c \ rl b 
0e8a			;    ld (seed2_1),bc 
0e8a			;    sbc a,a 
0e8a			;    and %11000101 
0e8a			;    xor l 
0e8a			;    ld l,a 
0e8a			;    ld (seed2_0),hl 
0e8a			;    ex de,hl 
0e8a			;    add hl,bc 
0e8a			;    ret 
0e8a			; 
0e8a			 
0e8a			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0e8a			; 20 bytes, 86 cycles (excluding ret) 
0e8a			 
0e8a			; returns   hl = pseudorandom number 
0e8a			; corrupts   a 
0e8a			 
0e8a			; generates 16-bit pseudorandom numbers with a period of 65535 
0e8a			; using the xorshift method: 
0e8a			 
0e8a			; hl ^= hl << 7 
0e8a			; hl ^= hl >> 9 
0e8a			; hl ^= hl << 8 
0e8a			 
0e8a			; some alternative shift triplets which also perform well are: 
0e8a			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0e8a			 
0e8a			;  org 32768 
0e8a			 
0e8a			xrnd: 
0e8a 2a 35 fd		  ld hl,(xrandc)       ; seed must not be 0 
0e8d 3e 00		  ld a,0 
0e8f bd			  cp l 
0e90 20 02		  jr nz, .xrnd1 
0e92 2e 01		  ld l, 1 
0e94			.xrnd1: 
0e94			 
0e94 7c			  ld a,h 
0e95 1f			  rra 
0e96 7d			  ld a,l 
0e97 1f			  rra 
0e98 ac			  xor h 
0e99 67			  ld h,a 
0e9a 7d			  ld a,l 
0e9b 1f			  rra 
0e9c 7c			  ld a,h 
0e9d 1f			  rra 
0e9e ad			  xor l 
0e9f 6f			  ld l,a 
0ea0 ac			  xor h 
0ea1 67			  ld h,a 
0ea2			 
0ea2 22 35 fd		  ld (xrandc),hl 
0ea5			 
0ea5 c9			  ret 
0ea6			;  
0ea6			 
0ea6			 
0ea6			;;;; int maths 
0ea6			 
0ea6			; https://map.grauw.nl/articles/mult_div_shifts.php 
0ea6			; Divide 16-bit values (with 16-bit result) 
0ea6			; In: Divide BC by divider DE 
0ea6			; Out: BC = result, HL = rest 
0ea6			; 
0ea6			Div16: 
0ea6 21 00 00		    ld hl,0 
0ea9 78			    ld a,b 
0eaa 06 08		    ld b,8 
0eac			Div16_Loop1: 
0eac 17			    rla 
0ead ed 6a		    adc hl,hl 
0eaf ed 52		    sbc hl,de 
0eb1 30 01		    jr nc,Div16_NoAdd1 
0eb3 19			    add hl,de 
0eb4			Div16_NoAdd1: 
0eb4 10 f6		    djnz Div16_Loop1 
0eb6 17			    rla 
0eb7 2f			    cpl 
0eb8 47			    ld b,a 
0eb9 79			    ld a,c 
0eba 48			    ld c,b 
0ebb 06 08		    ld b,8 
0ebd			Div16_Loop2: 
0ebd 17			    rla 
0ebe ed 6a		    adc hl,hl 
0ec0 ed 52		    sbc hl,de 
0ec2 30 01		    jr nc,Div16_NoAdd2 
0ec4 19			    add hl,de 
0ec5			Div16_NoAdd2: 
0ec5 10 f6		    djnz Div16_Loop2 
0ec7 17			    rla 
0ec8 2f			    cpl 
0ec9 41			    ld b,c 
0eca 4f			    ld c,a 
0ecb c9			ret 
0ecc			 
0ecc			 
0ecc			;http://z80-heaven.wikidot.com/math 
0ecc			; 
0ecc			;Inputs: 
0ecc			;     DE and A are factors 
0ecc			;Outputs: 
0ecc			;     A is not changed 
0ecc			;     B is 0 
0ecc			;     C is not changed 
0ecc			;     DE is not changed 
0ecc			;     HL is the product 
0ecc			;Time: 
0ecc			;     342+6x 
0ecc			; 
0ecc			Mult16: 
0ecc			 
0ecc 06 08		     ld b,8          ;7           7 
0ece 21 00 00		     ld hl,0         ;10         10 
0ed1 29			       add hl,hl     ;11*8       88 
0ed2 07			       rlca          ;4*8        32 
0ed3 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0ed5 19			         add hl,de   ;--         -- 
0ed6 10 f9		       djnz $-5      ;13*7+8     99 
0ed8 c9			ret 
0ed9			 
0ed9			; 
0ed9			; Square root of 16-bit value 
0ed9			; In:  HL = value 
0ed9			; Out:  D = result (rounded down) 
0ed9			; 
0ed9			;Sqr16: 
0ed9			;    ld de,#0040 
0ed9			;    ld a,l 
0ed9			;    ld l,h 
0ed9			;    ld h,d 
0ed9			;    or a 
0ed9			;    ld b,8 
0ed9			;Sqr16_Loop: 
0ed9			;    sbc hl,de 
0ed9			;    jr nc,Sqr16_Skip 
0ed9			;    add hl,de 
0ed9			;Sqr16_Skip: 
0ed9			;    ccf 
0ed9			;    rl d 
0ed9			;    add a,a 
0ed9			;    adc hl,hl 
0ed9			;    add a,a 
0ed9			;    adc hl,hl 
0ed9			;    djnz Sqr16_Loop 
0ed9			;    ret 
0ed9			; 
0ed9			; 
0ed9			; Divide 8-bit values 
0ed9			; In: Divide E by divider C 
0ed9			; Out: A = result, B = rest 
0ed9			; 
0ed9			Div8: 
0ed9 af			    xor a 
0eda 06 08		    ld b,8 
0edc			Div8_Loop: 
0edc cb 13		    rl e 
0ede 17			    rla 
0edf 91			    sub c 
0ee0 30 01		    jr nc,Div8_NoAdd 
0ee2 81			    add a,c 
0ee3			Div8_NoAdd: 
0ee3 10 f7		    djnz Div8_Loop 
0ee5 47			    ld b,a 
0ee6 7b			    ld a,e 
0ee7 17			    rla 
0ee8 2f			    cpl 
0ee9 c9			    ret 
0eea			 
0eea			; 
0eea			; Multiply 8-bit value with a 16-bit value (unrolled) 
0eea			; In: Multiply A with DE 
0eea			; Out: HL = result 
0eea			; 
0eea			Mult12U: 
0eea 2e 00		    ld l,0 
0eec 87			    add a,a 
0eed 30 01		    jr nc,Mult12U_NoAdd0 
0eef 19			    add hl,de 
0ef0			Mult12U_NoAdd0: 
0ef0 29			    add hl,hl 
0ef1 87			    add a,a 
0ef2 30 01		    jr nc,Mult12U_NoAdd1 
0ef4 19			    add hl,de 
0ef5			Mult12U_NoAdd1: 
0ef5 29			    add hl,hl 
0ef6 87			    add a,a 
0ef7 30 01		    jr nc,Mult12U_NoAdd2 
0ef9 19			    add hl,de 
0efa			Mult12U_NoAdd2: 
0efa 29			    add hl,hl 
0efb 87			    add a,a 
0efc 30 01		    jr nc,Mult12U_NoAdd3 
0efe 19			    add hl,de 
0eff			Mult12U_NoAdd3: 
0eff 29			    add hl,hl 
0f00 87			    add a,a 
0f01 30 01		    jr nc,Mult12U_NoAdd4 
0f03 19			    add hl,de 
0f04			Mult12U_NoAdd4: 
0f04 29			    add hl,hl 
0f05 87			    add a,a 
0f06 30 01		    jr nc,Mult12U_NoAdd5 
0f08 19			    add hl,de 
0f09			Mult12U_NoAdd5: 
0f09 29			    add hl,hl 
0f0a 87			    add a,a 
0f0b 30 01		    jr nc,Mult12U_NoAdd6 
0f0d 19			    add hl,de 
0f0e			Mult12U_NoAdd6: 
0f0e 29			    add hl,hl 
0f0f 87			    add a,a 
0f10 d0			    ret nc 
0f11 19			    add hl,de 
0f12 c9			    ret 
0f13			 
0f13			; 
0f13			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f13			; In: Multiply A with DE 
0f13			;      Put lowest value in A for most efficient calculation 
0f13			; Out: HL = result 
0f13			; 
0f13			Mult12R: 
0f13 21 00 00		    ld hl,0 
0f16			Mult12R_Loop: 
0f16 cb 3f		    srl a 
0f18 30 01		    jr nc,Mult12R_NoAdd 
0f1a 19			    add hl,de 
0f1b			Mult12R_NoAdd: 
0f1b cb 23		    sla e 
0f1d cb 12		    rl d 
0f1f b7			    or a 
0f20 c2 16 0f		    jp nz,Mult12R_Loop 
0f23 c9			    ret 
0f24			 
0f24			; 
0f24			; Multiply 16-bit values (with 32-bit result) 
0f24			; In: Multiply BC with DE 
0f24			; Out: BCHL = result 
0f24			; 
0f24			Mult32: 
0f24 79			    ld a,c 
0f25 48			    ld c,b 
0f26 21 00 00		    ld hl,0 
0f29 06 10		    ld b,16 
0f2b			Mult32_Loop: 
0f2b 29			    add hl,hl 
0f2c 17			    rla 
0f2d cb 11		    rl c 
0f2f 30 07		    jr nc,Mult32_NoAdd 
0f31 19			    add hl,de 
0f32 ce 00		    adc a,0 
0f34 d2 38 0f		    jp nc,Mult32_NoAdd 
0f37 0c			    inc c 
0f38			Mult32_NoAdd: 
0f38 10 f1		    djnz Mult32_Loop 
0f3a 41			    ld b,c 
0f3b 4f			    ld c,a 
0f3c c9			    ret 
0f3d			 
0f3d			 
0f3d			 
0f3d			; 
0f3d			; Multiply 8-bit values 
0f3d			; In:  Multiply H with E 
0f3d			; Out: HL = result 
0f3d			; 
0f3d			Mult8: 
0f3d 16 00		    ld d,0 
0f3f 6a			    ld l,d 
0f40 06 08		    ld b,8 
0f42			Mult8_Loop: 
0f42 29			    add hl,hl 
0f43 30 01		    jr nc,Mult8_NoAdd 
0f45 19			    add hl,de 
0f46			Mult8_NoAdd: 
0f46 10 fa		    djnz Mult8_Loop 
0f48 c9			    ret 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			 
0f49			;;http://z80-heaven.wikidot.com/math 
0f49			;;This divides DE by BC, storing the result in DE, remainder in HL 
0f49			; 
0f49			;DE_Div_BC:          ;1281-2x, x is at most 16 
0f49			;     ld a,16        ;7 
0f49			;     ld hl,0        ;10 
0f49			;     jp $+5         ;10 
0f49			;.DivLoop: 
0f49			;       add hl,bc    ;-- 
0f49			;       dec a        ;64 
0f49			;       jr z,.DivLoopEnd        ;86 
0f49			; 
0f49			;       sla e        ;128 
0f49			;       rl d         ;128 
0f49			;       adc hl,hl    ;240 
0f49			;       sbc hl,bc    ;240 
0f49			;       jr nc,.DivLoop ;23|21 
0f49			;       inc e        ;-- 
0f49			;       jp .DivLoop+1 
0f49			; 
0f49			;.DivLoopEnd: 
0f49			 
0f49			;HL_Div_C: 
0f49			;Inputs: 
0f49			;     HL is the numerator 
0f49			;     C is the denominator 
0f49			;Outputs: 
0f49			;     A is the remainder 
0f49			;     B is 0 
0f49			;     C is not changed 
0f49			;     DE is not changed 
0f49			;     HL is the quotient 
0f49			; 
0f49			;       ld b,16 
0f49			;       xor a 
0f49			;         add hl,hl 
0f49			;         rla 
0f49			;         cp c 
0f49			;         jr c,$+4 
0f49			;           inc l 
0f49			;           sub c 
0f49			;         djnz $-7 
0f49			 
0f49			; https://plutiedev.com/z80-add-8bit-to-16bit 
0f49			 
0f49			addatohl: 
0f49 85			    add   a, l    ; A = A+L 
0f4a 6f			    ld    l, a    ; L = A+L 
0f4b 8c			    adc   a, h    ; A = A+L+H+carry 
0f4c 95			    sub   l       ; A = H+carry 
0f4d 67			    ld    h, a    ; H = H+carry 
0f4e c9			ret 
0f4f			 
0f4f			addatode: 
0f4f 83			    add   a, e    ; A = A+L 
0f50 5f			    ld    e, a    ; L = A+L 
0f51 8a			    adc   a, d    ; A = A+L+H+carry 
0f52 93			    sub   e       ; A = H+carry 
0f53 57			    ld    d, a    ; H = H+carry 
0f54 c9			ret 
0f55			 
0f55			 
0f55			addatobc: 
0f55 81			    add   a, c    ; A = A+L 
0f56 4f			    ld    c, a    ; L = A+L 
0f57 88			    adc   a, b    ; A = A+L+H+carry 
0f58 91			    sub   c       ; A = H+carry 
0f59 47			    ld    b, a    ; H = H+carry 
0f5a c9			ret 
0f5b			 
0f5b			subafromhl: 
0f5b			   ; If A=0 do nothing 
0f5b			    ; Otherwise flip A's sign. Since 
0f5b			    ; the upper byte becomes -1, also 
0f5b			    ; substract 1 from H. 
0f5b ed 44		    neg 
0f5d ca 66 0f		    jp    z, Skip 
0f60 25			    dec   h 
0f61			     
0f61			    ; Now add the low byte as usual 
0f61			    ; Two's complement takes care of 
0f61			    ; ensuring the result is correct 
0f61 85			    add   a, l 
0f62 6f			    ld    l, a 
0f63 8c			    adc   a, h 
0f64 95			    sub   l 
0f65 67			    ld    h, a 
0f66			Skip: 
0f66 c9				ret 
0f67			 
0f67			 
0f67			; compare hl and de 
0f67			; returns:  
0f67			; if hl = de, z=1, s=0, c0=0 
0f67			; if hl > de, z=0, s=0, c=0 
0f67			; if hl < de, z=0, s=1, c=1 
0f67			cmp16:	 
0f67 b7				or a 
0f68 ed 52			sbc hl,de 
0f6a e0				ret po 
0f6b 7c				ld a,h 
0f6c 1f				rra 
0f6d ee 40			xor 01000000B 
0f6f 37				scf 
0f70 8f				adc a,a 
0f71 c9				ret 
0f72			 
0f72			 
0f72			; test if hl contains zero   - A is destroyed 
0f72			 
0f72			ishlzero:    
0f72 b7				or a     ; reset flags 
0f73 7c				ld a, h 
0f74 b5				or l        	 
0f75			 
0f75 c9				ret 
0f76			 
0f76			 
0f76			 
0f76			 
0f76			if FORTH_ENABLE_FLOATMATH 
0f76			;include "float/bbcmath.z80" 
0f76			include "float/lpfpcalc.asm" 
0f76			endif 
0f76			 
0f76			 
0f76			; eof 
0f76			 
# End of file firmware_maths.asm
0f76			include "firmware_strings.asm"   ; string handling  
0f76			 
0f76			 
0f76			; TODO string len 
0f76			; input text string, end on cr with zero term 
0f76			; a offset into frame buffer to start prompt 
0f76			; d is max length 
0f76			; e is display size TODO 
0f76			; c is current cursor position 
0f76			; hl is ptr to where string will be stored 
0f76			 
0f76			 
0f76			; TODO check limit of buffer for new inserts 
0f76			; TODO check insert does not push beyond buffer 
0f76			; TODO scroll in a limited display area 
0f76			; TODO scroll whole screen on page wrap 
0f76			 
0f76			 
0f76			; TODO handle KEY_PREVWORD 
0f76			; TODO handle KEY_NEXTWORD 
0f76			; TODO handle KEY_HOME 
0f76			; TODO handle KEY_END 
0f76			; TODO use LCD cursor? 
0f76			 
0f76 32 ad fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0f79 81					add c 
0f7a 32 ab fe				ld (input_at_cursor),a	; save draw pos of cursor 
0f7d 22 b0 fe				ld (input_start), hl     ; save ptr to buffer 
0f80 79					ld a, c 
0f81 cd 49 0f				call addatohl 
0f84 22 b2 fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0f87 7a					ld a,d 
0f88 32 af fe			        ld (input_size), a       ; save length of input area 
0f8b 79					ld a, c 
0f8c 32 9e fe				ld (input_cursor),a      ; init cursor start position  
0f8f 7b					ld a,e 
0f90 32 ae fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0f93					 
0f93					 
0f93			 
0f93			;		ld a,(input_ptr) 
0f93			;		ld (input_under_cursor),a 	; save what is under the cursor 
0f93			 
0f93			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0f93					; init cursor shape if not set by the cin routines 
0f93 21 4d fd				ld hl, cursor_shape 
0f96 3e ff				ld a, 255 
0f98 77					ld (hl), a 
0f99 23					inc hl 
0f9a 3e 00				ld a, 0 
0f9c 77					ld (hl), a 
0f9d			 
0f9d 3e 0f				ld a, CUR_BLINK_RATE 
0f9f 32 a9 fe				ld (input_cur_flash), a 
0fa2 3e 01				ld a, 1 
0fa4 32 a8 fe				ld (input_cur_onoff),a 
0fa7			 
0fa7			;	if DEBUG_INPUT 
0fa7			;		push af 
0fa7			;		ld a, 'I' 
0fa7			;		ld (debug_mark),a 
0fa7			;		pop af 
0fa7			;		CALLMONITOR 
0fa7			;	endif 
0fa7			.is1:		; main entry loop 
0fa7			 
0fa7			 
0fa7			 
0fa7					; pause 1ms 
0fa7			 
0fa7 3e 01				ld a, 1 
0fa9 cd 77 0c				call aDelayInMS 
0fac			 
0fac					; dec flash counter 
0fac 3a a9 fe				ld a, (input_cur_flash) 
0faf 3d					dec a 
0fb0 32 a9 fe				ld (input_cur_flash), a 
0fb3 fe 00				cp 0 
0fb5 20 0d				jr nz, .nochgstate 
0fb7			 
0fb7			 
0fb7					; change state 
0fb7 3a a8 fe				ld a,(input_cur_onoff) 
0fba ed 44				neg 
0fbc 32 a8 fe				ld (input_cur_onoff),a 
0fbf			 
0fbf			 
0fbf					; reset on change of state 
0fbf 3e 0f				ld a, CUR_BLINK_RATE 
0fc1 32 a9 fe				ld (input_cur_flash), a 
0fc4			 
0fc4			.nochgstate: 
0fc4					 
0fc4					 
0fc4			 
0fc4					; display cursor  
0fc4			 
0fc4			;		ld hl, (input_start) 
0fc4			;		ld a, (input_cursor) 
0fc4			;		call addatohl 
0fc4			 
0fc4					; get char under cursor and replace with cursor 
0fc4 2a b2 fe		ld hl, (input_ptr) 
0fc7			;		ld a, (hl) 
0fc7			;		ld (input_under_cursor),a 
0fc7			;		ld a, '_' 
0fc7			;		ld (hl), a 
0fc7			 
0fc7					; display string 
0fc7			 
0fc7 ed 5b b0 fe			ld de, (input_start) 
0fcb 3a ad fe				ld a, (input_at_pos) 
0fce cd 28 0d				call str_at_display 
0fd1			;	        call update_display 
0fd1			 
0fd1					; find place to put the cursor 
0fd1			;		add h 
0fd1			;		ld l, display_row_1 
0fd1			;		sub l 
0fd1			; (input_at_pos) 
0fd1					;ld c, a 
0fd1			;		ld a, (input_cursor) 
0fd1			;		ld l, (input_at_pos) 
0fd1			;		;ld b, h 
0fd1			;		add l 
0fd1			;		ld (input_at_cursor),a 
0fd1					;ld l,h 
0fd1			 
0fd1			;		ld h, 0 
0fd1			;		ld l,(input_at_pos) 
0fd1			;		ld a, (input_cursor) 
0fd1			;		call addatohl 
0fd1			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0fd1			;		call subafromhl 
0fd1			;		ld a,l 
0fd1			;		ld (input_at_cursor), a 
0fd1			 
0fd1				if DEBUG_INPUT 
0fd1					ld a, (hardware_diag) 
0fd1					cp 0 
0fd1					jr z, .skip_input_diag 
0fd1			 
0fd1					ld a,(input_at_pos) 
0fd1					ld hl, LFSRSeed 
0fd1					call hexout 
0fd1					ld a, (input_cursor) 
0fd1					ld hl, LFSRSeed+2 
0fd1					call hexout 
0fd1					ld a,(input_at_cursor) 
0fd1					ld hl, LFSRSeed+4 
0fd1					call hexout 
0fd1			 
0fd1					ld a,(input_cur_onoff) 
0fd1					ld hl, LFSRSeed+6 
0fd1					call hexout 
0fd1			 
0fd1					ld a,(input_cur_flash) 
0fd1					ld hl, LFSRSeed+8 
0fd1					call hexout 
0fd1			 
0fd1					ld a,(input_len) 
0fd1					ld hl, LFSRSeed+10 
0fd1					call hexout 
0fd1					ld hl, LFSRSeed+12 
0fd1					ld a, 0 
0fd1					ld (hl),a 
0fd1					ld a, display_row_4 
0fd1					ld de, LFSRSeed 
0fd1					call str_at_display 
0fd1					.skip_input_diag: 
0fd1				endif 
0fd1			 
0fd1					; decide on if we are showing the cursor this time round 
0fd1			 
0fd1 3a a8 fe				ld a, (input_cur_onoff) 
0fd4 fe ff				cp 255 
0fd6 28 13				jr z, .skipcur 
0fd8			 
0fd8			 
0fd8 3a ab fe				ld a,(input_at_cursor) 
0fdb 11 4d fd				ld de, cursor_shape 
0fde cd 28 0d				call str_at_display 
0fe1			 
0fe1					; save length of current input string 
0fe1 2a b0 fe				ld hl, (input_start) 
0fe4 cd a7 13				call strlenz 
0fe7 7d					ld a,l 
0fe8 32 a3 fe				ld (input_len),a 
0feb			 
0feb			.skipcur: 
0feb			 
0feb cd 38 0d			        call update_display 
0fee					 
0fee			 
0fee			 
0fee					; wait 
0fee				 
0fee					; TODO loop without wait to flash the cursor and char under cursor	 
0fee cd c2 71				call cin    ; _wait 
0ff1			 
0ff1 fe 00				cp 0 
0ff3 ca a7 0f				jp z, .is1 
0ff6			 
0ff6					; get ptr to char to input into 
0ff6			 
0ff6 4f					ld c,a 
0ff7 2a b0 fe				ld hl, (input_start) 
0ffa 3a 9e fe				ld a, (input_cursor) 
0ffd cd 49 0f				call addatohl 
1000 22 b2 fe				ld (input_ptr), hl 
1003 79					ld a,c 
1004			 
1004					; replace char under cursor 
1004			 
1004			;		ld hl, (input_ptr) 
1004			;		ld a, (input_under_cursor) 	; get what is under the cursor 
1004			;		ld (hl), a 
1004			 
1004			;	if DEBUG_INPUT 
1004			;		push af 
1004			;		ld a, 'i' 
1004			;		ld (debug_mark),a 
1004			;		pop af 
1004			;		CALLMONITOR 
1004			;	endif 
1004 fe 0e				cp KEY_HOME 
1006 20 0e				jr nz, .iske 
1008			 
1008 3a ad fe				ld a, (input_at_pos) 
100b 32 ab fe				ld (input_at_cursor),a 
100e 3e 00				ld a, 0 
1010 32 9e fe				ld (input_cursor), a 
1013 c3 a7 0f				jp .is1 
1016					 
1016 fe 0f		.iske:		cp KEY_END 
1018 20 03				jr nz, .isknw 
101a c3 a7 0f				jp .is1 
101d			 
101d fe 06		.isknw:		cp KEY_NEXTWORD 
101f 20 1b				jr nz, .iskpw 
1021			 
1021 2a b2 fe		.isknwm:	ld hl, (input_ptr) 
1024 7e					ld a,(hl)	 
1025 fe 00				cp 0 
1027 ca a7 0f				jp z, .is1    ; end of string 
102a fe 20				cp ' ' 
102c ca a7 0f				jp z, .is1    ; end of word 
102f 23					inc hl 
1030 22 b2 fe				ld (input_ptr), hl 
1033 3a ab fe				ld a, (input_at_cursor) 
1036 3c					inc a 
1037 32 ab fe				ld (input_at_cursor), a 
103a 18 e5				jr .isknwm 
103c			 
103c fe 07		.iskpw:		cp KEY_PREVWORD 
103e 20 1b				jr nz, .iskl 
1040			.iskpwm:	 
1040 2a b2 fe				ld hl, (input_ptr) 
1043 7e					ld a,(hl)	 
1044 fe 00				cp 0  
1046 ca a7 0f				jp z, .is1    ; end of string 
1049 fe 20				cp ' ' 
104b ca a7 0f				jp z, .is1    ; end of word 
104e 2b					dec hl 
104f 22 b2 fe				ld (input_ptr), hl 
1052 3a ab fe				ld a, (input_at_cursor) 
1055 3d					dec a 
1056 32 ab fe				ld (input_at_cursor), a 
1059 18 e5				jr .iskpwm 
105b			 
105b			 
105b fe 0b		.iskl:		cp KEY_LEFT 
105d 20 27				jr nz, .isk1 
105f			 
105f 3a 9e fe				ld a, (input_cursor) 
1062			 
1062 fe 00				cp 0 
1064 ca a7 0f				jp z, .is1 		; at start of line to ignore  
1067			 
1067 3d					dec  a 		; TODO check underflow 
1068 32 9e fe				ld (input_cursor), a 
106b			 
106b 2a b2 fe				ld hl, (input_ptr) 
106e 2b					dec hl 
106f 22 b2 fe				ld (input_ptr), hl 
1072					 
1072 3a ab fe				ld a, (input_at_cursor) 
1075 3d					dec a 
1076 32 ab fe				ld (input_at_cursor), a 
1079			 
1079 3e 01				ld a, 1		; show cursor moving 
107b 32 a8 fe				ld (input_cur_onoff),a 
107e 3e 0f				ld a, CUR_BLINK_RATE 
1080 32 a9 fe				ld (input_cur_flash), a 
1083			 
1083 c3 a7 0f				jp .is1 
1086			 
1086 fe 0c		.isk1:		cp KEY_RIGHT 
1088 20 2a				jr nz, .isk2 
108a			 
108a 3a a3 fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
108d 5f					ld e,a 
108e 3a 9e fe				ld a, (input_cursor) 
1091 bb					cp e 
1092 ca a7 0f				jp z, .is1		; at the end of string so dont go right 
1095			 
1095 3c					inc  a 		; TODO check overflow 
1096 32 9e fe				ld (input_cursor), a 
1099			 
1099 3a ab fe				ld a, (input_at_cursor) 
109c 3c					inc a 
109d 32 ab fe				ld (input_at_cursor), a 
10a0			 
10a0 2a b2 fe				ld hl, (input_ptr) 
10a3 23					inc hl 
10a4 22 b2 fe				ld (input_ptr), hl 
10a7			 
10a7 3e 01				ld a, 1		; show cursor moving 
10a9 32 a8 fe				ld (input_cur_onoff),a 
10ac 3e 0f				ld a, CUR_BLINK_RATE 
10ae 32 a9 fe				ld (input_cur_flash), a 
10b1			 
10b1 c3 a7 0f				jp .is1 
10b4			 
10b4 fe 05		.isk2:		cp KEY_UP 
10b6			 
10b6 20 26				jr nz, .isk3 
10b8			 
10b8					; swap last command with the current on 
10b8			 
10b8					; move cursor to start of string 
10b8 2a b0 fe				ld hl, (input_start) 
10bb 22 b2 fe				ld (input_ptr), hl 
10be			 
10be 3a ad fe				ld a, (input_at_pos) 
10c1 32 ab fe				ld (input_at_cursor), a 
10c4			 
10c4 3e 00				ld a, 0 
10c6 32 9e fe				ld (input_cursor), a 
10c9					 
10c9					; swap input and last command buffers 
10c9			 
10c9 21 75 f6				ld hl, os_cli_cmd 
10cc 11 74 f7				ld de, os_last_cmd 
10cf 06 ff				ld b, 255 
10d1 7e			.swap1:		ld a, (hl) 
10d2 4f					ld c,a 
10d3 1a					ld a, (de) 
10d4 77					ld (hl), a 
10d5 79					ld a,c 
10d6 12					ld (de),a 
10d7 23					inc hl 
10d8 13					inc de 
10d9 10 f6				djnz .swap1 
10db			 
10db			 
10db			 
10db			 
10db			 
10db c3 a7 0f				jp .is1 
10de			 
10de fe 08		.isk3:		cp KEY_BS 
10e0 20 3c				jr nz, .isk4 
10e2			 
10e2 3a 9e fe				ld a, (input_cursor) 
10e5			 
10e5 fe 00				cp 0 
10e7 ca a7 0f				jp z, .is1 		; at start of line to ignore  
10ea			 
10ea 3d					dec  a 		; TODO check underflow 
10eb 32 9e fe				ld (input_cursor), a 
10ee			 
10ee					; hl is source 
10ee					; de needs to be source - 1 
10ee			 
10ee			;		ld a, 0 
10ee			;		dec hl 
10ee			;		ld (hl), a 
10ee			 
10ee 2a b2 fe				ld hl, (input_ptr) 
10f1 2b					dec hl 
10f2 22 b2 fe				ld (input_ptr), hl 
10f5			 
10f5					; shift all data 
10f5			 
10f5 e5					push hl 
10f6 23					inc hl 
10f7 d1					pop de 
10f8 3a a3 fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
10fb 4f					ld c,a 
10fc 06 00				ld b,0 
10fe ed b0				ldir  
1100			 
1100			 
1100			 
1100			 
1100 3a ab fe				ld a, (input_at_cursor) 
1103 3d					dec a 
1104 32 ab fe				ld (input_at_cursor), a 
1107			 
1107			 
1107 3e 01				ld a, 1		; show cursor moving 
1109 32 a8 fe				ld (input_cur_onoff),a 
110c 3e 0f				ld a, CUR_BLINK_RATE 
110e 32 a9 fe				ld (input_cur_flash), a 
1111			 
1111					; remove char 
1111 3a ab fe				ld a, (input_at_cursor) 
1114 3c					inc a 
1115 11 9f 11				ld de,.iblank 
1118 cd 28 0d				call str_at_display 
111b			 
111b c3 a7 0f				jp .is1 
111e			 
111e fe 0d		.isk4:		cp KEY_CR 
1120 28 6c				jr z, .endinput 
1122			 
1122					; else add the key press to the end 
1122			 
1122 4f					ld c, a			; save key pressed 
1123			 
1123 7e					ld a,(hl)		; get what is currently under char 
1124			 
1124 fe 00				cp 0			; we are at the end of the string 
1126 20 2f				jr nz, .onchar 
1128					 
1128					; add a char to the end of the string 
1128				 
1128 71					ld (hl),c 
1129 23					inc hl 
112a			;		ld a,' ' 
112a			;		ld (hl),a 
112a			;		inc hl 
112a 3e 00				ld a,0 
112c 77					ld (hl),a 
112d 2b					dec hl 
112e			 
112e 3a 9e fe				ld a, (input_cursor) 
1131 3c					inc a				; TODO check max string length and scroll  
1132 32 9e fe				ld (input_cursor), a		; inc cursor pos 
1135							 
1135 3a ab fe				ld a, (input_at_cursor) 
1138 3c					inc a 
1139 32 ab fe				ld (input_at_cursor), a 
113c			 
113c 2a b2 fe				ld hl, (input_ptr) 
113f 23					inc hl 
1140 22 b2 fe				ld (input_ptr), hl 
1143			 
1143 2a b2 fe				ld hl, (input_ptr) 
1146 23					inc hl 
1147 22 b2 fe				ld (input_ptr), hl 
114a			;	if DEBUG_INPUT 
114a			;		push af 
114a			;		ld a, '+' 
114a			;		ld (debug_mark),a 
114a			;		pop af 
114a			;		CALLMONITOR 
114a			;	endif 
114a 3e 01				ld a, 1		; show cursor moving 
114c 32 a8 fe				ld (input_cur_onoff),a 
114f 3e 0f				ld a, CUR_BLINK_RATE 
1151 32 a9 fe				ld (input_cur_flash), a 
1154 c3 a7 0f				jp .is1 
1157					 
1157			 
1157			 
1157					; if on a char then insert 
1157			.onchar: 
1157			 
1157					; TODO over flow check: make sure insert does not blow out buffer 
1157			 
1157					; need to do some maths to use lddr 
1157			 
1157 e5					push hl   ; save char pos 
1158 c5					push bc 
1159			 
1159 2a b0 fe				ld hl, (input_start) 
115c 3a a3 fe				ld a, (input_len) 
115f cd 49 0f				call addatohl  		; end of string 
1162 23					inc hl 
1163 23					inc hl		; past zero term 
1164 e5					push hl 
1165 23					inc hl 
1166 e5					push hl  
1167			 
1167								; start and end of lddr set, now how much to move? 
1167			 
1167							 
1167 3a 9e fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
116a 47					ld b,a 
116b 3a a3 fe				ld a,(input_len) 
116e 5f					ld e,a 
116f 90					sub b 
1170 3c					inc a		;?? 
1171 3c					inc a		;?? 
1172 3c					inc a		;?? 
1173			 
1173 06 00				ld b,0 
1175 4f					ld c,a 
1176			 
1176				if DEBUG_INPUT 
1176					push af 
1176					ld a, 'i' 
1176					ld (debug_mark),a 
1176					pop af 
1176			;		CALLMONITOR 
1176				endif 
1176 d1					pop de 
1177 e1					pop hl 
1178				if DEBUG_INPUT 
1178					push af 
1178					ld a, 'I' 
1178					ld (debug_mark),a 
1178					pop af 
1178			;		CALLMONITOR 
1178				endif 
1178 ed b8				lddr 
117a				 
117a			 
117a			 
117a					; TODO have a key for insert/overwrite mode???? 
117a c1					pop bc 
117b e1					pop hl 
117c 71					ld (hl), c		; otherwise overwrite current char 
117d					 
117d			 
117d			 
117d			 
117d 3a 9e fe				ld a, (input_cursor) 
1180 3c					inc  a 		; TODO check overflow 
1181 32 9e fe				ld (input_cursor), a 
1184			 
1184 3a ab fe				ld a, (input_at_cursor) 
1187 3c					inc a 
1188 32 ab fe				ld (input_at_cursor), a 
118b			 
118b c3 a7 0f				jp .is1 
118e			 
118e			.endinput:	; TODO look for end of string 
118e			 
118e					; add trailing space for end of token 
118e			 
118e 2a b0 fe				ld hl, (input_start) 
1191 3a a3 fe				ld a,(input_len) 
1194 cd 49 0f				call addatohl 
1197 3e 20				ld a, ' ' 
1199 77					ld (hl),a 
119a					; TODO eof of parse marker 
119a			 
119a 23					inc hl 
119b 3e 00				ld a, 0 
119d 77					ld (hl),a 
119e			 
119e			 
119e c9					ret 
119f			 
119f .. 00		.iblank: db " ",0 
11a1			 
11a1			 
11a1 32 ad fe		input_str_prev:	ld (input_at_pos), a 
11a4 22 b0 fe				ld (input_start), hl 
11a7 3e 01				ld a,1			; add cursor 
11a9 77					ld (hl),a 
11aa 23					inc hl 
11ab 3e 00				ld a,0 
11ad 77					ld (hl),a 
11ae 22 b2 fe				ld (input_ptr), hl 
11b1 7a					ld a,d 
11b2 32 af fe				ld (input_size), a 
11b5 3e 00				ld a,0 
11b7 32 9e fe				ld (input_cursor),a 
11ba			.instr1:	 
11ba			 
11ba					; TODO do block cursor 
11ba					; TODO switch cursor depending on the modifer key 
11ba			 
11ba					; update cursor shape change on key hold 
11ba			 
11ba 2a b2 fe				ld hl, (input_ptr) 
11bd 2b					dec hl 
11be 3a 4d fd				ld a,(cursor_shape) 
11c1 77					ld (hl), a 
11c2			 
11c2					; display entered text 
11c2 3a ad fe				ld a,(input_at_pos) 
11c5 cd e0 70		            	CALL fLCD_Pos       ;Position cursor to location in A 
11c8 ed 5b b0 fe	            	LD   de, (input_start) 
11cc cd e8 70		            	CALL fLCD_Str       ;Display string pointed to by DE 
11cf			 
11cf cd c2 71				call cin 
11d2 fe 00				cp 0 
11d4 28 e4				jr z, .instr1 
11d6			 
11d6					; proecess keyboard controls first 
11d6			 
11d6 2a b2 fe				ld hl,(input_ptr) 
11d9			 
11d9 fe 0d				cp KEY_CR	 ; pressing enter ends input 
11db 28 5a				jr z, .instrcr 
11dd			 
11dd fe 08				cp KEY_BS 	; back space 
11df 20 0f				jr nz, .instr2 
11e1					; process back space 
11e1			 
11e1					; TODO stop back space if at start of string 
11e1 2b					dec hl 
11e2 2b					dec hl ; to over write cursor 
11e3 3a 4d fd				ld a,(cursor_shape) 
11e6					;ld a,0 
11e6 77					ld (hl),a 
11e7 23					inc hl 
11e8 3e 20				ld a," " 
11ea 77					ld (hl),a 
11eb 22 b2 fe				ld (input_ptr),hl 
11ee					 
11ee			 
11ee 18 ca				jr .instr1 
11f0			 
11f0 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
11f2 20 06				jr nz, .instr3 
11f4 2b					dec hl 
11f5 22 b2 fe				ld (input_ptr),hl 
11f8 18 c0				jr .instr1 
11fa				 
11fa fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
11fc 20 06				jr nz, .instr4 
11fe 23					inc hl 
11ff 22 b2 fe				ld (input_ptr),hl 
1202 18 b6				jr .instr1 
1204			 
1204 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1206 20 06				jr nz, .instr5 
1208 2b					dec hl 
1209 22 b2 fe				ld (input_ptr),hl 
120c 18 ac				jr .instr1 
120e			 
120e fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1210 20 06				jr nz, .instr6 
1212 2b					dec hl 
1213 22 b2 fe				ld (input_ptr),hl 
1216 18 a2				jr .instr1 
1218 fe 05		.instr6:        cp KEY_UP      ; recall last command 
121a 20 0b				jr nz, .instrnew 
121c			 
121c 21 4e f3			ld hl, scratch 
121f 11 74 f7			ld de, os_last_cmd 
1222 cd 40 12			call strcpy 
1225 18 93				jr .instr1 
1227			 
1227			 
1227			.instrnew:	; no special key pressed to see if we have room to store it 
1227			 
1227					; TODO do string size test 
1227			 
1227 2b					dec hl ; to over write cursor 
1228 77					ld (hl),a 
1229 23					inc hl 
122a 3a 4d fd				ld a,(cursor_shape) 
122d 77					ld (hl),a 
122e 23					inc hl 
122f 3e 00				ld a,0 
1231 77					ld (hl),a 
1232			 
1232 22 b2 fe				ld (input_ptr),hl 
1235					 
1235 18 83				jr .instr1 
1237 2b			.instrcr:	dec hl		; remove cursor 
1238 3e 20				ld a,' '	; TODO add a trailing space for safety 
123a 77					ld (hl),a 
123b 23					inc hl 
123c 3e 00				ld a,0 
123e 77					ld (hl),a 
123f			 
123f			 
123f					; if at end of line scroll up    
123f					; TODO detecting only end of line 4 for scroll up  
123f			 
123f					;ld   
123f			 
123f c9					ret 
1240			 
1240			 
1240			; strcpy hl = dest, de source 
1240			 
1240 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1241 b7			            OR   A              ;Null terminator? 
1242 c8			            RET  Z              ;Yes, so finished 
1243 1a					ld a,(de) 
1244 77					ld (hl),a 
1245 13			            INC  DE             ;Point to next character 
1246 23					inc hl 
1247 18 f7		            JR   strcpy       ;Repeat 
1249 c9					ret 
124a			 
124a			 
124a			; TODO string_at  
124a			; pass string which starts with lcd offset address and then null term string 
124a			 
124a			; TODO string to dec 
124a			; TODO string to hex 
124a			; TODO byte to string hex 
124a			; TODO byte to string dec 
124a			 
124a			 
124a			 
124a			; from z80uartmonitor 
124a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124a			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
124a			; pass hl for where to put the text 
124a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124a c5			hexout:	PUSH BC 
124b f5					PUSH AF 
124c 47					LD B, A 
124d					; Upper nybble 
124d cb 3f				SRL A 
124f cb 3f				SRL A 
1251 cb 3f				SRL A 
1253 cb 3f				SRL A 
1255 cd 65 12				CALL tohex 
1258 77					ld (hl),a 
1259 23					inc hl	 
125a					 
125a					; Lower nybble 
125a 78					LD A, B 
125b e6 0f				AND 0FH 
125d cd 65 12				CALL tohex 
1260 77					ld (hl),a 
1261 23					inc hl	 
1262					 
1262 f1					POP AF 
1263 c1					POP BC 
1264 c9					RET 
1265					 
1265			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1265			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1265			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1265			tohex: 
1265 e5					PUSH HL 
1266 d5					PUSH DE 
1267 16 00				LD D, 0 
1269 5f					LD E, A 
126a 21 72 12				LD HL, .DATA 
126d 19					ADD HL, DE 
126e 7e					LD A, (HL) 
126f d1					POP DE 
1270 e1					POP HL 
1271 c9					RET 
1272			 
1272			.DATA: 
1272 30					DEFB	30h	; 0 
1273 31					DEFB	31h	; 1 
1274 32					DEFB	32h	; 2 
1275 33					DEFB	33h	; 3 
1276 34					DEFB	34h	; 4 
1277 35					DEFB	35h	; 5 
1278 36					DEFB	36h	; 6 
1279 37					DEFB	37h	; 7 
127a 38					DEFB	38h	; 8 
127b 39					DEFB	39h	; 9 
127c 41					DEFB	41h	; A 
127d 42					DEFB	42h	; B 
127e 43					DEFB	43h	; C 
127f 44					DEFB	44h	; D 
1280 45					DEFB	45h	; E 
1281 46					DEFB	46h	; F 
1282			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1282			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1282			;;    subtract $30, if result > 9 then subtract $7 more 
1282			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1282			atohex: 
1282 d6 30				SUB $30 
1284 fe 0a				CP 10 
1286 f8					RET M		; If result negative it was 0-9 so we're done 
1287 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1289 c9					RET		 
128a			 
128a			 
128a			 
128a			 
128a			; Get 2 ASCII characters as hex byte from pointer in hl 
128a			 
128a			BYTERD: 
128a 16 00			LD	D,00h		;Set up 
128c cd 94 12			CALL	HEXCON		;Get byte and convert to hex 
128f 87				ADD	A,A		;First nibble so 
1290 87				ADD	A,A		;multiply by 16 
1291 87				ADD	A,A		; 
1292 87				ADD	A,A		; 
1293 57				LD	D,A		;Save hi nibble in D 
1294			HEXCON: 
1294 7e				ld a, (hl)		;Get next chr 
1295 23				inc hl 
1296 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1298 fe 0a			CP	00Ah		;Is it 0-9 ? 
129a 38 02			JR	C,NALPHA	;If so miss next bit 
129c d6 07			SUB	007h		;Else convert alpha 
129e			NALPHA: 
129e b2				OR	D		;Add hi nibble back 
129f c9				RET			; 
12a0			 
12a0			 
12a0			; 
12a0			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
12a0			; Since the routines get_byte and therefore get_nibble are called, only valid 
12a0			; characters (0-9a-f) are accepted. 
12a0			; 
12a0			;get_word        push    af 
12a0			;                call    get_byte        ; Get the upper byte 
12a0			;                ld      h, a 
12a0			;                call    get_byte        ; Get the lower byte 
12a0			;                ld      l, a 
12a0			;                pop     af 
12a0			;                ret 
12a0			; 
12a0			; Get a byte in hexadecimal notation. The result is returned in A. Since 
12a0			; the routine get_nibble is used only valid characters are accepted - the  
12a0			; input routine only accepts characters 0-9a-f. 
12a0			; 
12a0 c5			get_byte:        push    bc              ; Save contents of B (and C) 
12a1 7e					ld a,(hl) 
12a2 23					inc hl 
12a3 cd c8 12		                call    nibble2val      ; Get upper nibble 
12a6 cb 07		                rlc     a 
12a8 cb 07		                rlc     a 
12aa cb 07		                rlc     a 
12ac cb 07		                rlc     a 
12ae 47			                ld      b, a            ; Save upper four bits 
12af 7e					ld a,(hl) 
12b0 cd c8 12		                call    nibble2val      ; Get lower nibble 
12b3 b0			                or      b               ; Combine both nibbles 
12b4 c1			                pop     bc              ; Restore B (and C) 
12b5 c9			                ret 
12b6			; 
12b6			; Get a hexadecimal digit from the serial line. This routine blocks until 
12b6			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
12b6			; to the serial line interface. The lower 4 bits of A contain the value of  
12b6			; that particular digit. 
12b6			; 
12b6			;get_nibble      ld a,(hl)           ; Read a character 
12b6			;                call    to_upper        ; Convert to upper case 
12b6			;                call    is_hex          ; Was it a hex digit? 
12b6			;                jr      nc, get_nibble  ; No, get another character 
12b6			 ;               call    nibble2val      ; Convert nibble to value 
12b6			 ;               call    print_nibble 
12b6			 ;               ret 
12b6			; 
12b6			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
12b6			; A valid hexadecimal digit is denoted by a set C flag. 
12b6			; 
12b6			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
12b6			;                ret     nc              ; Yes 
12b6			;                cp      '0'             ; Less than '0'? 
12b6			;                jr      nc, is_hex_1    ; No, continue 
12b6			;                ccf                     ; Complement carry (i.e. clear it) 
12b6			;                ret 
12b6			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
12b6			;                ret     c               ; Yes 
12b6			;                cp      'A'             ; Less than 'A'? 
12b6			;                jr      nc, is_hex_2    ; No, continue 
12b6			;                ccf                     ; Yes - clear carry and return 
12b6			;                ret 
12b6			;is_hex_2        scf                     ; Set carry 
12b6			;                ret 
12b6			; 
12b6			; Convert a single character contained in A to upper case: 
12b6			; 
12b6 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
12b8 d8			                ret     c 
12b9 fe 7b		                cp      'z' + 1         ; > 'z'? 
12bb d0			                ret     nc              ; Nothing to do, either 
12bc e6 5f		                and     $5f             ; Convert to upper case 
12be c9			                ret 
12bf			 
12bf			 
12bf			to_lower: 
12bf			 
12bf			   ; if char is in [A-Z] make it lower case 
12bf			 
12bf			   ; enter : a = char 
12bf			   ; exit  : a = lower case char 
12bf			   ; uses  : af 
12bf			 
12bf fe 41		   cp 'A' 
12c1 d8			   ret c 
12c2			    
12c2 fe 5b		   cp 'Z'+1 
12c4 d0			   ret nc 
12c5			    
12c5 f6 20		   or $20 
12c7 c9			   ret 
12c8			 
12c8			; 
12c8			; Expects a hexadecimal digit (upper case!) in A and returns the 
12c8			; corresponding value in A. 
12c8			; 
12c8 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
12ca 38 02		                jr      c, nibble2val_1 ; Yes 
12cc d6 07		                sub     7               ; Adjust for A-F 
12ce d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
12d0 e6 0f		                and     $f              ; Only return lower 4 bits 
12d2 c9			                ret 
12d3			; 
12d3			; Print_nibble prints a single hex nibble which is contained in the lower  
12d3			; four bits of A: 
12d3			; 
12d3			;print_nibble    push    af              ; We won't destroy the contents of A 
12d3			;                and     $f              ; Just in case... 
12d3			;                add     a, '0'             ; If we have a digit we are done here. 
12d3			;                cp      '9' + 1         ; Is the result > 9? 
12d3			;                jr      c, print_nibble_1 
12d3			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
12d3			;print_nibble_1  call    putc            ; Print the nibble and 
12d3			;                pop     af              ; restore the original value of A 
12d3			;                ret 
12d3			;; 
12d3			;; Send a CR/LF pair: 
12d3			; 
12d3			;crlf            push    af 
12d3			;                ld      a, cr 
12d3			;                call    putc 
12d3			;                ld      a, lf 
12d3			;                call    putc 
12d3			;                pop     af 
12d3			;                ret 
12d3			; 
12d3			; Print_word prints the four hex digits of a word to the serial line. The  
12d3			; word is expected to be in HL. 
12d3			; 
12d3			;print_word      push    hl 
12d3			;                push    af 
12d3			;                ld      a, h 
12d3			;                call    print_byte 
12d3			;                ld      a, l 
12d3			;                call    print_byte 
12d3			;                pop     af 
12d3			;                pop     hl 
12d3			;                ret 
12d3			; 
12d3			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
12d3			; The byte to be printed is expected to be in A. 
12d3			; 
12d3			;print_byte      push    af              ; Save the contents of the registers 
12d3			;                push    bc 
12d3			;                ld      b, a 
12d3			;                rrca 
12d3			;                rrca 
12d3			;                rrca 
12d3			;                rrca 
12d3			;                call    print_nibble    ; Print high nibble 
12d3			;                ld      a, b 
12d3			;                call    print_nibble    ; Print low nibble 
12d3			;                pop     bc              ; Restore original register contents 
12d3			;                pop     af 
12d3			;                ret 
12d3			 
12d3			 
12d3			 
12d3			 
12d3			 
12d3			fourehexhl:  
12d3 7e				ld a,(hl) 
12d4 cd 82 12			call atohex 
12d7 cb 3f				SRL A 
12d9 cb 3f				SRL A 
12db cb 3f				SRL A 
12dd cb 3f				SRL A 
12df 47				ld b, a 
12e0 23				inc hl 
12e1 7e				ld a,(hl) 
12e2 23				inc hl 
12e3 cd 82 12			call atohex 
12e6 80				add b 
12e7 57				ld d,a 
12e8 7e				ld a,(hl) 
12e9 cd 82 12			call atohex 
12ec cb 3f				SRL A 
12ee cb 3f				SRL A 
12f0 cb 3f				SRL A 
12f2 cb 3f				SRL A 
12f4 47				ld b, a 
12f5 23				inc hl 
12f6 7e				ld a,(hl) 
12f7 23				inc hl 
12f8 cd 82 12			call atohex 
12fb 80				add b 
12fc 5f				ld e, a 
12fd d5				push de 
12fe e1				pop hl 
12ff c9				ret 
1300			 
1300			; pass hl. returns z set if the byte at hl is a digit 
1300			;isdigithl:  
1300			;	push bc 
1300			;	ld a,(hl) 
1300			;	cp ':' 
1300			;	jr nc, .isdf 		; > 
1300			;	cp '0' 
1300			;	jr c, .isdf		; < 
1300			; 
1300			;	; TODO find a better way to set z 
1300			; 
1300			;	ld b,a 
1300			;	cp b 
1300			;	pop bc 
1300			;	ret 
1300			; 
1300			;.isdf:	; not digit so clear z 
1300			; 
1300			;	; TODO find a better way to unset z 
1300			; 
1300			;	ld b,a 
1300			;	inc b 
1300			;	cp b 
1300			; 
1300			;	pop bc 
1300			;	ret 
1300				 
1300				 
1300			 
1300			 
1300			; pass hl as the four byte address to load 
1300			 
1300			get_word_hl:  
1300 e5				push hl 
1301 cd a0 12			call get_byte 
1304				 
1304 47				ld b, a 
1305			 
1305 e1				pop hl 
1306 23				inc hl 
1307 23				inc hl 
1308			 
1308			; TODO not able to handle a-f  
1308 7e				ld a,(hl) 
1309			;	;cp ':' 
1309			;	cp 'g' 
1309			;	jr nc, .single_byte_hl 		; > 
1309			;	cp 'G' 
1309			;	jr nc, .single_byte_hl 		; > 
1309			;	cp '0' 
1309			;	jr c, .single_byte_hl		; < 
1309			 
1309				;call isdigithl 
1309 fe 00			cp 0 
130b 28 06			jr z, .single_byte_hl 
130d			 
130d			.getwhln:   ; hex word so get next byte 
130d			 
130d cd a0 12			call get_byte 
1310 6f				ld l, a 
1311 60				ld h,b 
1312 c9				ret 
1313 68			.single_byte_hl:   ld l,b 
1314 26 00				ld h,0 
1316 c9					ret 
1317			 
1317			 
1317			 
1317			 
1317 21 51 1c			ld hl,asc+1 
131a			;	ld a, (hl) 
131a			;	call nibble2val 
131a cd a0 12			call get_byte 
131d			 
131d			;	call fourehexhl 
131d 32 82 f3			ld (scratch+52),a 
1320				 
1320 21 80 f3			ld hl,scratch+50 
1323 22 71 f6			ld (os_cur_ptr),hl 
1326			 
1326 c9				ret 
1327			 
1327			 
1327			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
1327			 
1327			; Decimal Unsigned Version 
1327			 
1327			;Number in a to decimal ASCII 
1327			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
1327			;Example: display a=56 as "056" 
1327			;input: a = number 
1327			;Output: a=0,value of a in the screen 
1327			;destroys af,bc (don't know about hl and de) 
1327			DispAToASCII: 
1327 0e 9c			ld	c,-100 
1329 cd 33 13			call	.Na1 
132c 0e f6			ld	c,-10 
132e cd 33 13			call	.Na1 
1331 0e ff			ld	c,-1 
1333 06 2f		.Na1:	ld	b,'0'-1 
1335 04			.Na2:	inc	b 
1336 81				add	a,c 
1337 38 fc			jr	c,.Na2 
1339 91				sub	c		;works as add 100/10/1 
133a f5				push af		;safer than ld c,a 
133b 78				ld	a,b		;char is in b 
133c			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
133c f1				pop af		;safer than ld a,c 
133d c9				ret 
133e			 
133e			; Decimal Signed Version 
133e			 
133e			; DispA 
133e			; -------------------------------------------------------------- 
133e			; Converts a signed integer value to a zero-terminated ASCII 
133e			; string representative of that value (using radix 10). 
133e			; -------------------------------------------------------------- 
133e			; INPUTS: 
133e			;     HL     Value to convert (two's complement integer). 
133e			;     DE     Base address of string destination. (pointer). 
133e			; -------------------------------------------------------------- 
133e			; OUTPUTS: 
133e			;     None 
133e			; -------------------------------------------------------------- 
133e			; REGISTERS/MEMORY DESTROYED 
133e			; AF HL 
133e			; -------------------------------------------------------------- 
133e			 
133e			;DispHLToASCII: 
133e			;   push    de 
133e			;   push    bc 
133e			; 
133e			;; Detect sign of HL. 
133e			;    bit    7, h 
133e			;    jr     z, ._DoConvert 
133e			; 
133e			;; HL is negative. Output '-' to string and negate HL. 
133e			;    ld     a, '-' 
133e			;    ld     (de), a 
133e			;    inc    de 
133e			; 
133e			;; Negate HL (using two's complement) 
133e			;    xor    a 
133e			;    sub    l 
133e			;    ld     l, a 
133e			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
133e			;    sbc    a, h 
133e			;    ld     h, a 
133e			; 
133e			;; Convert HL to digit characters 
133e			;._DoConvert: 
133e			;    ld     b, 0     ; B will count character length of number 
133e			;-   ld     a, 10 
133e			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
133e			;    push   af 
133e			;    inc    b 
133e			;    ld     a, h 
133e			;    or     l 
133e			;    jr     nz, - 
133e			; 
133e			;; Retrieve digits from stack 
133e			;-   pop    af 
133e			;    or     $30 
133e			;    ld     (de), a 
133e			;    inc    de 
133e			;    djnz   - 
133e			; 
133e			;; Terminate string with NULL 
133e			;    xor    a 
133e			;    ld     (de), a 
133e			; 
133e			;    pop    bc 
133e			;    pop    de 
133e			;    ret 
133e			 
133e			;Comments 
133e			; 
133e			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
133e			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
133e			;    Note that the output string will not be fixed-width. 
133e			; 
133e			;Example Usage 
133e			; 
133e			;    ld    hl, -1004 
133e			;    ld    de, OP1 
133e			;    call  DispA 
133e			;    ld    hl, OP1 
133e			;    syscall  PutS 
133e			 
133e			 
133e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
133e			 
133e			 
133e			;Converts an ASCII string to an unsigned 16-bit integer 
133e			;Quits when it reaches a non-decimal digit 
133e			 
133e			string_to_uint16: 
133e			atoui_16: 
133e			;Input: 
133e			;     DE points to the string 
133e			;Outputs: 
133e			;     HL is the result 
133e			;     A is the 8-bit value of the number 
133e			;     DE points to the byte after the number 
133e			;Destroys: 
133e			;     BC 
133e			;       if the string is non-empty, BC is HL/10 
133e			;Size:  24 bytes 
133e			;Speed: 42+d(104+{0,9}) 
133e			;       d is the number of digits in the number 
133e			;       max is 640 cycles for a 5 digit number 
133e			;Assuming no leading zeros: 
133e			;1 digit:  146cc 
133e			;2 digit:  250cc 
133e			;3 digit:  354cc or 363cc (avg: 354.126cc) 
133e			;4 digit:  458cc or 467cc (avg: 458.27cc) 
133e			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
133e			;avg: 544.81158447265625cc (544+13297/16384) 
133e			;=============================================================== 
133e 21 00 00		  ld hl,0 
1341			.u16a: 
1341 1a			  ld a,(de) 
1342 d6 30		  sub 30h 
1344 fe 0a		  cp 10 
1346 d0			  ret nc 
1347 13			  inc de 
1348 44			  ld b,h 
1349 4d			  ld c,l 
134a 29			  add hl,hl 
134b 29			  add hl,hl 
134c 09			  add hl,bc 
134d 29			  add hl,hl 
134e 85			  add a,l 
134f 6f			  ld l,a 
1350 30 ef		  jr nc,.u16a 
1352 24			  inc h 
1353 c3 41 13		  jp .u16a 
1356			 
1356			 
1356			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1356			 
1356			;written by Zeda 
1356			;Converts a 16-bit unsigned integer to an ASCII string. 
1356			 
1356			uitoa_16: 
1356			;Input: 
1356			;   DE is the number to convert 
1356			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1356			;Output: 
1356			;   HL points to the null-terminated ASCII string 
1356			;      NOTE: This isn't necessarily the same as the input HL. 
1356 d5			  push de 
1357 c5			  push bc 
1358 f5			  push af 
1359 eb			  ex de,hl 
135a			 
135a 01 f0 d8		  ld bc,-10000 
135d 3e 2f		  ld a,'0'-1 
135f 3c			  inc a 
1360 09			  add hl,bc  
1361 38 fc		   jr c,$-2 
1363 12			  ld (de),a 
1364 13			  inc de 
1365			 
1365 01 e8 03		  ld bc,1000 
1368 3e 3a		  ld a,'9'+1 
136a 3d			  dec a  
136b 09			  add hl,bc  
136c 30 fc		   jr nc,$-2 
136e 12			  ld (de),a 
136f 13			  inc de 
1370			 
1370 01 9c ff		  ld bc,-100 
1373 3e 2f		  ld a,'0'-1 
1375 3c			  inc a  
1376 09			  add hl,bc  
1377 38 fc		   jr c,$-2 
1379 12			  ld (de),a 
137a 13			  inc de 
137b			 
137b 7d			  ld a,l 
137c 26 3a		  ld h,'9'+1 
137e 25			  dec h  
137f c6 0a		  add a,10  
1381 30 fb		   jr nc,$-3 
1383 c6 30		  add a,'0' 
1385 eb			  ex de,hl 
1386 72			  ld (hl),d 
1387 23			  inc hl 
1388 77			  ld (hl),a 
1389 23			  inc hl 
138a 36 00		  ld (hl),0 
138c			 
138c			;Now strip the leading zeros 
138c 0e fa		  ld c,-6 
138e 09			  add hl,bc 
138f 3e 30		  ld a,'0' 
1391 23			  inc hl  
1392 be			  cp (hl)  
1393 28 fc		  jr z,$-2 
1395			 
1395			;Make sure that the string is non-empty! 
1395 7e			  ld a,(hl) 
1396 b7			  or a 
1397 20 01		  jr nz,.atoub 
1399 2b			  dec hl 
139a			.atoub: 
139a			 
139a f1			  pop af 
139b c1			  pop bc 
139c d1			  pop de 
139d c9			  ret 
139e			 
139e			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
139e			 
139e			toUpper: 
139e			;A is the char. 
139e			;If A is a lowercase letter, this sets it to the matching uppercase 
139e			;18cc or 30cc or 41cc 
139e			;avg: 26.75cc 
139e fe 61		  cp 'a' 
13a0 d8			  ret c 
13a1 fe 7b		  cp 'z'+1 
13a3 d0			  ret nc 
13a4 d6 20		  sub 'a'-'A' 
13a6 c9			  ret 
13a7			 
13a7			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
13a7			 
13a7			; String Length 
13a7			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
13a7			 
13a7			; Get the length of the null-terminated string starting at $8000 hl 
13a7			;    LD     HL, $8000 
13a7			 
13a7			strlenz: 
13a7			 
13a7 af			    XOR    A               ; Zero is the value we are looking for. 
13a8 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
13a9 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
13aa			                           ; 65, 536 bytes (the entire addressable memory space). 
13aa ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13ac			 
13ac			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13ac 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
13ad 6f			    LD     L, A             ; number of bytes 
13ae ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13b0 2b			    DEC    HL              ; Compensate for null. 
13b1 c9				ret 
13b2			 
13b2			; Get the length of the A terminated string starting at $8000 hl 
13b2			;    LD     HL, $8000 
13b2			 
13b2			strlent: 
13b2			 
13b2			                  ; A is the value we are looking for. 
13b2 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
13b4 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
13b6			                           ; 65, 536 bytes (the entire addressable memory space). 
13b6 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13b8			 
13b8			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13b8 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
13ba 2e 00		    LD     L, 0             ; number of bytes 
13bc ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13be 2b			    DEC    HL              ; Compensate for null. 
13bf c9				ret 
13c0			 
13c0			 
13c0			;Comparing Strings 
13c0			 
13c0			;IN    HL     Address of string1. 
13c0			;      DE     Address of string2. 
13c0			 
13c0			; doc given but wrong??? 
13c0			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
13c0			;      carry  Set if string1 > string2, reset if string1 <= string2. 
13c0			; tested 
13c0			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
13c0			 
13c0			strcmp_old: 
13c0 e5			    PUSH   HL 
13c1 d5			    PUSH   DE 
13c2			 
13c2 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
13c3 be			    CP     (HL)            ; (want to minimize work). 
13c4 38 01		    JR     C, Str1IsBigger 
13c6 7e			    LD     A, (HL) 
13c7			 
13c7			Str1IsBigger: 
13c7 4f			    LD     C, A             ; Put length in BC 
13c8 06 00		    LD     B, 0 
13ca 13			    INC    DE              ; Increment pointers to meat of string. 
13cb 23			    INC    HL 
13cc			 
13cc			CmpLoop: 
13cc 1a			    LD     A, (DE)          ; Compare bytes. 
13cd ed a1		    CPI 
13cf 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
13d1 13			    INC    DE              ; Update pointer. 
13d2 ea cc 13		    JP     PE, CmpLoop 
13d5			 
13d5 d1			    POP    DE 
13d6 e1			    POP    HL 
13d7 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
13d8 be			    CP     (HL) 
13d9 c9			    RET 
13da			 
13da			NoMatch: 
13da 2b			    DEC    HL 
13db be			    CP     (HL)            ; Compare again to affect carry. 
13dc d1			    POP    DE 
13dd e1			    POP    HL 
13de c9			    RET 
13df			 
13df			;; test strmp 
13df			; 
13df			;ld de, .str1 
13df			;ld hl, .str2 
13df			;call strcmp 
13df			;jr z, .z1 
13df			;;this 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "NZ1" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;.z1: 
13df			; 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "ZZ1" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			; 
13df			;ld de, .str1 
13df			;ld hl, .str1 
13df			;call strcmp 
13df			;jr z, .z2 
13df			;;this 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "NZ2" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;.z2: 
13df			; 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "ZZ2" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			; 
13df			;ld de, .str1 
13df			;ld hl, .str2 
13df			;call strcmp 
13df			;jr c, .c1 
13df			; 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "Nc1" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;.c1: 
13df			;;this 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "cc1" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			; 
13df			;ld de, .str1 
13df			;ld hl, .str1 
13df			;call strcmp 
13df			;jr c, .c2 
13df			;;this 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "Nc2" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;.c2: 
13df			; 
13df			;	if DEBUG_FORTH_WORDS 
13df			;		DMARK "cc2" 
13df			;		CALLMONITOR 
13df			;	endif 
13df			;	NEXTW 
13df			;.str1:   db "string1",0 
13df			;.str2:   db "string2",0 
13df			 
13df			; only care about direct match or not 
13df			; hl and de strings 
13df			; zero set if the same 
13df			 
13df			strcmp: 
13df 1a				ld a, (de) 
13e0 be				cp (hl) 
13e1 28 02			jr z, .ssame 
13e3 b7				or a 
13e4 c9				ret 
13e5			 
13e5			.ssame:  
13e5 fe 00			cp 0 
13e7 c8				ret z 
13e8			 
13e8 23				inc hl 
13e9 13				inc de 
13ea 18 f3			jr strcmp 
13ec				 
13ec				 
13ec			 
13ec			 
13ec			 
13ec			 
13ec			; eof 
13ec			 
13ec			 
13ec			 
13ec			 
13ec			 
13ec			 
# End of file firmware_strings.asm
13ec			include "firmware_memory.asm"   ; malloc and free  
13ec			 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec			.mallocsize: db "Wants malloc >256",0 
13ec			.mallocasize: db "MALLOC gives >256",0 
13ec			.malloczero: db "MALLOC gives zero",0 
13ec			 
13ec			malloc_guard_zerolen: 
13ec				push hl 
13ec				push de 
13ec				push af 
13ec			 
13ec				ld de, 0 
13ec			        call cmp16 
13ec				jr nz, .lowalloz 
13ec			 
13ec				push hl 
13ec				push de 
13ec					ld hl, display_fb0 
13ec					ld (display_fb_active), hl 
13ec				call clear_display 
13ec				ld a, 0 
13ec				ld de, .malloczero 
13ec				call str_at_display 
13ec				call update_display 
13ec				call delay1s 
13ec				call delay1s 
13ec				ld a, 0 
13ec				ld (os_view_disable), a 
13ec			 
13ec				pop de 
13ec				pop hl 
13ec			 
13ec				 
13ec			 
13ec				CALLMONITOR 
13ec			.lowalloz: 
13ec			 
13ec			 
13ec				pop af 
13ec				pop de 
13ec				pop hl 
13ec			ret 
13ec			 
13ec			malloc_guard_entry: 
13ec				push hl 
13ec				push de 
13ec				push af 
13ec			 
13ec			 	or a      ;clear carry flag 
13ec				push hl 
13ec				ld de, 255 
13ec				sbc hl, de 
13ec				jr c, .lowalloc 
13ec			 
13ec				push de 
13ec					ld hl, display_fb0 
13ec					ld (display_fb_active), hl 
13ec				call clear_display 
13ec				ld a, 0 
13ec				ld de, .mallocsize 
13ec				call str_at_display 
13ec				call update_display 
13ec				call delay1s 
13ec				call delay1s 
13ec				ld a, 0 
13ec				ld (os_view_disable), a 
13ec			 
13ec				pop de 
13ec				pop hl 
13ec			 
13ec				 
13ec			 
13ec				CALLMONITOR 
13ec				jr .lowdone 
13ec			.lowalloc: 
13ec			 
13ec			 
13ec				pop hl 
13ec			.lowdone:	pop af 
13ec				pop de 
13ec				pop hl 
13ec			ret 
13ec			 
13ec			malloc_guard_exit: 
13ec				push hl 
13ec				push de 
13ec				push af 
13ec			 
13ec			 	or a      ;clear carry flag 
13ec				push hl 
13ec				ld de, 255 
13ec				sbc hl, de 
13ec				jr c, .lowallocx 
13ec			 
13ec				push de 
13ec					ld hl, display_fb0 
13ec					ld (display_fb_active), hl 
13ec				call clear_display 
13ec				ld a, 0 
13ec				ld de, .mallocasize 
13ec				call str_at_display 
13ec				call update_display 
13ec				call delay1s 
13ec				call delay1s 
13ec				ld a, 0 
13ec				ld (os_view_disable), a 
13ec				pop de 
13ec				pop hl 
13ec			 
13ec				CALLMONITOR 
13ec				jr .lowdonex 
13ec			.lowallocx: 
13ec			 
13ec				pop hl 
13ec			.lowdonex:	pop af 
13ec				pop de 
13ec				pop hl 
13ec			ret 
13ec			endif 
13ec			 
13ec			if MALLOC_2 
13ec			; Z80 Malloc and Free Functions 
13ec			 
13ec			; Malloc Function: 
13ec			; Input: 
13ec			;   HL: Size of block to allocate 
13ec			; Output: 
13ec			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ec			 
13ec			malloc: 
13ec				 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec			call malloc_guard_entry 
13ec			endif 
13ec			 
13ec			 
13ec			 
13ec			 
13ec					if DEBUG_FORTH_MALLOC 
13ec						DMARK "mal" 
13ec						CALLMONITOR 
13ec					endif 
13ec			    push af            ; Save AF register 
13ec			    ld a, l            ; Load low byte of size into A 
13ec			    or h               ; Check if size is zero 
13ec			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
13ec			 
13ec			    ; Allocate memory 
13ec			    ld hl, (heap_start) ; Load start of heap into HL 
13ec					if DEBUG_FORTH_MALLOC 
13ec						DMARK "ma1" 
13ec						CALLMONITOR 
13ec					endif 
13ec			    call malloc_internal ; Call internal malloc function 
13ec			    pop af             ; Restore AF register 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec			call malloc_guard_exit 
13ec			call malloc_guard_zerolen 
13ec			endif 
13ec			    ret                ; Return 
13ec			 
13ec			; Free Function: 
13ec			; Input: 
13ec			;   HL: Pointer to memory block to free 
13ec			; Output: 
13ec			;   None 
13ec			 
13ec			free: 
13ec			    push af            ; Save AF register 
13ec			    ld a, l            ; Load low byte of pointer into A 
13ec			    or h               ; Check if pointer is NULL 
13ec			    jp z, free_exit    ; If pointer is NULL, exit 
13ec			 
13ec			    ; Free memory 
13ec			    ld hl, (heap_start) ; Load start of heap into HL 
13ec			    call free_internal  ; Call internal free function 
13ec			    pop af             ; Restore AF register 
13ec			    ret                ; Return 
13ec			 
13ec			; Internal Malloc Function: 
13ec			; Input: 
13ec			;   HL: Size of block to allocate 
13ec			; Output: 
13ec			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ec			 
13ec			malloc_internal: 
13ec			    ld bc, 2           ; Number of bytes to allocate for management overhead 
13ec			    add hl, bc         ; Add management overhead to requested size 
13ec			    ex de, hl          ; Save total size in DE, and keep it in HL 
13ec					if DEBUG_FORTH_MALLOC 
13ec						DMARK "ma2" 
13ec						CALLMONITOR 
13ec					endif 
13ec			 
13ec			    ; Search for free memory block 
13ec			    ld de, (heap_end)  ; Load end of heap into DE 
13ec			    ld bc, 0           ; Initialize counter 
13ec			 
13ec					if DEBUG_FORTH_MALLOC 
13ec						DMARK "ma2" 
13ec						CALLMONITOR 
13ec					endif 
13ec			malloc_search_loop: 
13ec			    ; Check if current block is free 
13ec			    ld a, (hl)         ; Load current block's status (free or used) 
13ec			    cp 0               ; Compare with zero (free) 
13ec			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
13ec			 
13ec			    ; Check if current block is large enough 
13ec			    ld a, (hl+1)       ; Load high byte of block size 
13ec			    cp l               ; Compare with low byte of requested size 
13ec			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
13ec			 
13ec			    ld a, (hl+2)       ; Load low byte of block size 
13ec			    cp h               ; Compare with high byte of requested size 
13ec			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
13ec			 
13ec			    ; Mark block as used 
13ec			    ld (hl), 0xFF      ; Set status byte to indicate used block 
13ec			 
13ec			    ; Calculate remaining space in block 
13ec			    ld bc, 0           ; Clear BC 
13ec			    add hl, bc         ; Increment HL to point to start of data block 
13ec			    add hl, de         ; HL = HL + DE (total size) 
13ec			    ld bc, 1           ; Number of bytes to allocate for management overhead 
13ec			    add hl, bc         ; Add management overhead to start of data block 
13ec			 
13ec			    ; Save pointer to allocated block in HL 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec						DMARK "ma5" 
13ec			call malloc_guard_exit 
13ec			call malloc_guard_zerolen 
13ec			endif 
13ec			    ret 
13ec			 
13ec			malloc_skip_block_check: 
13ec			    ; Move to the next block 
13ec			    ld bc, 3           ; Size of management overhead 
13ec			    add hl, bc         ; Move to the next block 
13ec			    inc de             ; Increment counter 
13ec			 
13ec			    ; Check if we have reached the end of heap 
13ec			    ld a, e            ; Load low byte of heap end address 
13ec			    cp (hl)            ; Compare with low byte of current address 
13ec			    jr nz, malloc_search_loop  ; If not equal, continue searching 
13ec			    ld a, d            ; Load high byte of heap end address 
13ec			    cp 0               ; Check if it's zero (end of memory) 
13ec			    jr nz, malloc_search_loop  ; If not zero, continue searching 
13ec			 
13ec			    ; If we reached here, allocation failed 
13ec			    xor a              ; Set result to NULL 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec						DMARK "ma6" 
13ec			call malloc_guard_exit 
13ec			call malloc_guard_zerolen 
13ec			endif 
13ec			    ret 
13ec			malloc_exit: 
13ec			if DEBUG_FORTH_MALLOC_HIGH 
13ec						DMARK "ma7" 
13ec			call malloc_guard_exit 
13ec			call malloc_guard_zerolen 
13ec			endif 
13ec			    ret 
13ec			 
13ec			; Internal Free Function: 
13ec			; Input: 
13ec			;   HL: Pointer to memory block to free 
13ec			; Output: 
13ec			;   None 
13ec			 
13ec			free_internal: 
13ec			    ld de, (heap_start) ; Load start of heap into DE 
13ec			    ld bc, 0            ; Initialize counter 
13ec			 
13ec			free_search_loop: 
13ec			    ; Check if current block contains the pointer 
13ec			    ld a, l             ; Load low byte of pointer 
13ec			    cp (hl+1)           ; Compare with high byte of current block's address 
13ec			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ec			    ld a, h             ; Load high byte of pointer 
13ec			    cp (hl+2)           ; Compare with low byte of current block's address 
13ec			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ec			 
13ec			    ; Mark block as free 
13ec			    ld (hl), 0          ; Set status byte to indicate free block 
13ec			    ret                 ; Return 
13ec			 
13ec			free_skip_block_check: 
13ec			    ; Move to the next block 
13ec			    ld bc, 3            ; Size of management overhead 
13ec			    add hl, bc          ; Move to the next block 
13ec			    inc de              ; Increment counter 
13ec			 
13ec			    ; Check if we have reached the end of heap 
13ec			    ld a, e             ; Load low byte of heap end address 
13ec			    cp (hl)             ; Compare with low byte of current address 
13ec			    jr nz, free_search_loop  ; If not equal, continue searching 
13ec			    ld a, d             ; Load high byte of heap end address 
13ec			    cp 0                ; Check if it's zero (end of memory) 
13ec			    jr nz, free_search_loop  ; If not zero, continue searching 
13ec			 
13ec			    ; If we reached here, pointer is not found in heap 
13ec			    ret 
13ec			 
13ec			free_exit: 
13ec			    ret                 ; Return 
13ec			 
13ec			; Define heap start and end addresses 
13ec			;heap_start:    .dw 0xC000   ; Start of heap 
13ec			;heap_end:      .dw 0xE000   ; End of heap 
13ec			 
13ec			endif 
13ec			 
13ec			 
13ec			if MALLOC_1 
13ec			 
13ec			 
13ec			 
13ec			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
13ec			 
13ec			;moved to firmware.asm 
13ec			;heap_start        .equ  0x9000      ; Starting address of heap 
13ec			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
13ec			 
13ec			;      .org 0 
13ec			;      jp    main 
13ec			 
13ec			 
13ec			;      .org  0x100 
13ec			;main: 
13ec			;      ld    HL, 0x8100 
13ec			;      ld    SP, HL 
13ec			; 
13ec			;      call  heap_init 
13ec			; 
13ec			;      ; Make some allocations 
13ec			;      ld    HL, 12 
13ec			;      call  malloc            ; Allocates 0x9004 
13ec			; 
13ec			;      ld    HL, 12 
13ec			;      call  malloc            ; Allocates 0x9014 
13ec			; 
13ec			;      ld    HL, 12 
13ec			;      call  malloc            ; Allocates 0x9024 
13ec			; 
13ec			;      ; Free some allocations 
13ec			;      ld    HL, 0x9014 
13ec			;      call  free 
13ec			; 
13ec			;      ld    HL, 0x9004 
13ec			;      call  free 
13ec			; 
13ec			;      ld    HL, 0x9024 
13ec			;      call  free 
13ec			; 
13ec			; 
13ec			;      halt 
13ec			 
13ec			 
13ec			;------------------------------------------------------------------------------ 
13ec			;     heap_init                                                               : 
13ec			;                                                                             : 
13ec			; Description                                                                 : 
13ec			;     Initialise the heap and make it ready for malloc and free operations.   : 
13ec			;                                                                             : 
13ec			;     The heap is maintained as a linked list, starting with an initial       : 
13ec			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
13ec			;     the first free block in the heap. Each block then points to the next    : 
13ec			;     free block within the heap, and the free list ends at the first block   : 
13ec			;     with a null pointer to the next free block.                             : 
13ec			;                                                                             : 
13ec			; Parameters                                                                  : 
13ec			;     Inputs are compile-time only. Two defines which specify the starting    : 
13ec			;     address of the heap and its size are required, along with a memory      : 
13ec			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
13ec			;     principally stores a pointer to the first free block in the heap.       : 
13ec			;                                                                             : 
13ec			; Returns                                                                     : 
13ec			;     Nothing                                                                 : 
13ec			;------------------------------------------------------------------------------ 
13ec			heap_init: 
13ec e5			      push  HL 
13ed			 
13ed			      ; Initialise free list struct 
13ed 21 0e 80		      ld    HL, heap_start 
13f0 22 0a 80		      ld    (free_list), HL 
13f3 21 00 00		      ld    HL, 0 
13f6 22 0c 80		      ld    (free_list+2), HL 
13f9			 
13f9			      ; Insert first free block at bottom of heap, consumes entire heap 
13f9 21 0a 80		      ld    HL, heap_start+heap_size-4 
13fc 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
13ff 21 fc ff		      ld    HL, heap_size-4 
1402 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1405			 
1405			      ; Insert end of free list block at top of heap - two null words will 
1405			      ; terminate the free list 
1405 21 00 00		      ld    HL, 0 
1408 22 0c 80		      ld    (heap_start+heap_size-2), HL 
140b 22 0a 80		      ld    (heap_start+heap_size-4), HL 
140e			 
140e e1			      pop   HL 
140f			 
140f c9			      ret 
1410			 
1410			 
1410			;------------------------------------------------------------------------------ 
1410			;     malloc                                                                  : 
1410			;                                                                             : 
1410			; Description                                                                 : 
1410			;     Allocates the wanted space from the heap and returns the address of the : 
1410			;     first useable byte of the allocation.                                   : 
1410			;                                                                             : 
1410			;     Allocations can happen in one of two ways:                              : 
1410			;                                                                             : 
1410			;     1. A free block may be found which is the exact size wanted. In this    : 
1410			;        case the block is removed from the free list and retuedn to the      : 
1410			;        caller.                                                              : 
1410			;     2. A free block may be found which is larger than the size wanted. In   : 
1410			;        this case, the larger block is split into two. The first portion of  : 
1410			;        this block will become the requested space by the malloc call and    : 
1410			;        is returned to the caller. The second portion becomes a new free     : 
1410			;        block, and the free list is adjusted to maintain continuity via this : 
1410			;        newly created block.                                                 : 
1410			;                                                                             : 
1410			;     malloc does not set any initial value in the allocated space, the       : 
1410			;     caller is required to do this as required.                              : 
1410			;                                                                             : 
1410			;     This implementation of malloc uses the stack exclusively, and is        : 
1410			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1410			;     advisable to disable interrupts before calling malloc, and recommended  : 
1410			;     to avoid the use of malloc inside ISRs in general.                      : 
1410			;                                                                             : 
1410			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1410			;                                                                             : 
1410			; Parameters                                                                  : 
1410			;     HL  Number of bytes wanted                                              : 
1410			;                                                                             : 
1410			; Returns                                                                     : 
1410			;     HL  Address of the first useable byte of the allocation                 : 
1410			;                                                                             : 
1410			; Flags                                                                       : 
1410			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1410			;                                                                             : 
1410			; Stack frame                                                                 : 
1410			;       |             |                                                       : 
1410			;       +-------------+                                                       : 
1410			;       |     BC      |                                                       : 
1410			;       +-------------+                                                       : 
1410			;       |     DE      |                                                       : 
1410			;       +-------------+                                                       : 
1410			;       |     IX      |                                                       : 
1410			;       +-------------+                                                       : 
1410			;       |  prev_free  |                                                       : 
1410			;   +4  +-------------+                                                       : 
1410			;       |  this_free  |                                                       : 
1410			;   +2  +-------------+                                                       : 
1410			;       |  next_free  |                                                       : 
1410			;   +0  +-------------+                                                       : 
1410			;       |             |                                                       : 
1410			;                                                                             : 
1410			;------------------------------------------------------------------------------ 
1410			 
1410			 
1410			;malloc: 
1410			; 
1410			;	SAVESP ON 1 
1410			; 
1410			;	call malloc_code 
1410			; 
1410			;	CHECKSP ON 1 
1410			;	ret 
1410			 
1410			 
1410			malloc: 
1410 c5			      push  BC 
1411 d5			      push  DE 
1412 dd e5		      push  IX 
1414			if DEBUG_FORTH_MALLOC_HIGH 
1414			call malloc_guard_entry 
1414			endif 
1414			 
1414					if DEBUG_FORTH_MALLOC 
1414						DMARK "mal" 
1414						CALLMONITOR 
1414					endif 
1414 7c			      ld    A, H                    ; Exit if no space requested 
1415 b5			      or    L 
1416 ca d5 14		      jp    Z, malloc_early_exit 
1419			 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			; 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			;inc hl 
1419			 
1419			 
1419			 
1419			 
1419					if DEBUG_FORTH_MALLOC 
1419						DMARK "maA" 
1419						CALLMONITOR 
1419					endif 
1419			      ; Set up stack frame 
1419 eb			      ex    DE, HL 
141a 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
141d 39			      add   HL, SP 
141e f9			      ld    SP, HL 
141f dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1423 dd 39		      add   IX, SP 
1425			 
1425			      ; Setup initial state 
1425 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1428 19			      add   HL, DE 
1429			 
1429 44			      ld    B, H                    ; Move want to BC 
142a 4d			      ld    C, L 
142b			 
142b 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
142e dd 75 04		      ld    (IX+4), L 
1431 dd 74 05		      ld    (IX+5), H 
1434			 
1434 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1435 23			      inc   HL 
1436 56			      ld    D, (HL) 
1437 dd 73 02		      ld    (IX+2), E 
143a dd 72 03		      ld    (IX+3), D 
143d eb			      ex    DE, HL                  ; this_free ptr into HL 
143e			 
143e					if DEBUG_FORTH_MALLOC 
143e						DMARK "maB" 
143e						CALLMONITOR 
143e					endif 
143e			      ; Loop through free block list to find some space 
143e			malloc_find_space: 
143e 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
143f 23			      inc   HL 
1440 56			      ld    D, (HL) 
1441			 
1441 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1442 b3			      or    E 
1443 ca cf 14		      jp    Z, malloc_no_space 
1446			 
1446 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1449 dd 72 01		      ld    (IX+1), D 
144c			 
144c			      ; Does this block have enough space to make the allocation? 
144c 23			      inc   HL                      ; Load free block size into DE 
144d 5e			      ld    E, (HL) 
144e 23			      inc   HL 
144f 56			      ld    D, (HL) 
1450			 
1450 eb			      ex    DE, HL                  ; Check size of block against want 
1451 b7			      or    A                       ; Ensure carry flag clear 
1452 ed 42		      sbc   HL, BC 
1454 e5			      push  HL                      ; Store the result for later (new block size) 
1455			 
1455 ca a4 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1458 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
145a			 
145a			      ; this_free block is not big enough, setup ptrs to test next free block 
145a e1			      pop   HL                      ; Discard previous result 
145b			 
145b dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
145e dd 66 03		      ld    H, (IX+3) 
1461 dd 75 04		      ld    (IX+4), L 
1464 dd 74 05		      ld    (IX+5), H 
1467			 
1467 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
146a dd 66 01		      ld    H, (IX+1) 
146d dd 75 02		      ld    (IX+2), L 
1470 dd 74 03		      ld    (IX+3), H 
1473			 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "MA>" 
1473						CALLMONITOR 
1473					endif 
1473 18 c9		      jr    malloc_find_space 
1475			 
1475			      ; split a bigger block into two - requested size and remaining size 
1475			malloc_alloc_split: 
1475					if DEBUG_FORTH_MALLOC 
1475						DMARK "MAs" 
1475						CALLMONITOR 
1475					endif 
1475 eb			      ex    DE, HL                  ; Calculate address of new free block 
1476 2b			      dec   HL 
1477 2b			      dec   HL 
1478 2b			      dec   HL 
1479 09			      add   HL, BC 
147a			 
147a			      ; Create a new block and point it at next_free 
147a dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
147d dd 56 01		      ld    D, (IX+1) 
1480			 
1480 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1481 23			      inc   HL 
1482 72			      ld    (HL), D 
1483			 
1483 d1			      pop   DE                      ; Store size of new block into new block 
1484 23			      inc   HL 
1485 73			      ld    (HL), E 
1486 23			      inc   HL 
1487 72			      ld    (HL), D 
1488			 
1488			      ; Update this_free ptr to point to new block 
1488 2b			      dec   HL 
1489 2b			      dec   HL 
148a 2b			      dec   HL 
148b			 
148b dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
148e dd 56 03		      ld    D, (IX+3) 
1491			 
1491 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1494 dd 74 03		      ld    (IX+3), H 
1497			 
1497			      ; Modify this_free block to be allocation 
1497 eb			      ex    DE, HL 
1498 af			      xor   A                       ; Null the next block ptr of allocated block 
1499 77			      ld    (HL), A 
149a 23			      inc   HL 
149b 77			      ld    (HL), A 
149c			 
149c 23			      inc   HL                      ; Store want size into allocated block 
149d 71			      ld    (HL), C 
149e 23			      inc   HL 
149f 70			      ld    (HL), B 
14a0 23			      inc   HL 
14a1 e5			      push  HL                      ; Address of allocation to return 
14a2			 
14a2 18 19		      jr    malloc_update_links 
14a4			 
14a4			malloc_alloc_fit: 
14a4 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
14a5			 
14a5					if DEBUG_FORTH_MALLOC 
14a5						DMARK "MAf" 
14a5						CALLMONITOR 
14a5					endif 
14a5			      ; Modify this_free block to be allocation 
14a5 eb			      ex    DE, HL 
14a6 2b			      dec   HL 
14a7 2b			      dec   HL 
14a8 2b			      dec   HL 
14a9			 
14a9 af			      xor   A                       ; Null the next block ptr of allocated block 
14aa 77			      ld    (HL), A 
14ab 23			      inc   HL 
14ac 77			      ld    (HL), A 
14ad			 
14ad 23			      inc   HL                      ; Store address of allocation to return 
14ae 23			      inc   HL 
14af 23			      inc   HL 
14b0 e5			      push  HL 
14b1			 
14b1			      ; Copy next_free ptr to this_free, remove allocated block from free list 
14b1 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
14b4 dd 66 01		      ld    H, (IX+1) 
14b7			 
14b7 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
14ba dd 74 03		      ld    (IX+3), H 
14bd			 
14bd			 
14bd			malloc_update_links: 
14bd			      ; Update prev_free ptr to point to this_free 
14bd dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
14c0 dd 66 05		      ld    H, (IX+5) 
14c3			 
14c3 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
14c6 dd 56 03		      ld    D, (IX+3) 
14c9			 
14c9 73			      ld    (HL), E                 ; this_free ptr into prev_free 
14ca 23			      inc   HL 
14cb 72			      ld    (HL), D 
14cc			 
14cc					if DEBUG_FORTH_MALLOC 
14cc						DMARK "Mul" 
14cc						CALLMONITOR 
14cc					endif 
14cc			      ; Clear the Z flag to indicate successful allocation 
14cc 7a			      ld    A, D 
14cd b3			      or    E 
14ce			 
14ce d1			      pop   DE                      ; Address of allocation 
14cf					if DEBUG_FORTH_MALLOC 
14cf						DMARK "MAu" 
14cf						CALLMONITOR 
14cf					endif 
14cf			 
14cf			malloc_no_space: 
14cf 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
14d2 39			      add   HL, SP 
14d3 f9			      ld    SP, HL 
14d4			 
14d4 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
14d5					if DEBUG_FORTH_MALLOC 
14d5						DMARK "MAN" 
14d5						CALLMONITOR 
14d5					endif 
14d5			 
14d5			malloc_early_exit: 
14d5					if DEBUG_FORTH_MALLOC 
14d5						DMARK "MAx" 
14d5						CALLMONITOR 
14d5					endif 
14d5 dd e1		      pop   IX 
14d7 d1			      pop   DE 
14d8 c1			      pop   BC 
14d9			 
14d9			if DEBUG_FORTH_MALLOC_HIGH 
14d9			call malloc_guard_exit 
14d9			call malloc_guard_zerolen 
14d9			endif 
14d9 c9			      ret 
14da			 
14da			 
14da			;------------------------------------------------------------------------------ 
14da			;     free                                                                    : 
14da			;                                                                             : 
14da			; Description                                                                 : 
14da			;     Return the space pointed to by HL to the heap. HL must be an address as : 
14da			;     returned by malloc, otherwise the behaviour is undefined.               : 
14da			;                                                                             : 
14da			;     Where possible, directly adjacent free blocks will be merged together   : 
14da			;     into larger blocks to help ensure that the heap does not become         : 
14da			;     excessively fragmented.                                                 : 
14da			;                                                                             : 
14da			;     free does not clear or set any other value into the freed space, and    : 
14da			;     therefore its contents may be visible through subsequent malloc's. The  : 
14da			;     caller should clear the freed space as required.                        : 
14da			;                                                                             : 
14da			;     This implementation of free uses the stack exclusively, and is          : 
14da			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
14da			;     advisable to disable interrupts before calling free, and recommended    : 
14da			;     to avoid the use of free inside ISRs in general.                        : 
14da			;                                                                             : 
14da			;     NOTE: heap_init must be called before malloc and free can be used.      : 
14da			;                                                                             : 
14da			; Parameters                                                                  : 
14da			;     HL  Pointer to address of first byte of allocation to be freed          : 
14da			;                                                                             : 
14da			; Returns                                                                     : 
14da			;     Nothing                                                                 : 
14da			;                                                                             : 
14da			; Stack frame                                                                 : 
14da			;       |             |                                                       : 
14da			;       +-------------+                                                       : 
14da			;       |     BC      |                                                       : 
14da			;       +-------------+                                                       : 
14da			;       |     DE      |                                                       : 
14da			;       +-------------+                                                       : 
14da			;       |     IX      |                                                       : 
14da			;       +-------------+                                                       : 
14da			;       |  prev_free  |                                                       : 
14da			;   +2  +-------------+                                                       : 
14da			;       |  next_free  |                                                       : 
14da			;   +0  +-------------+                                                       : 
14da			;       |             |                                                       : 
14da			;                                                                             : 
14da			;------------------------------------------------------------------------------ 
14da			free: 
14da c5			      push  BC 
14db d5			      push  DE 
14dc dd e5		      push  IX 
14de			 
14de 7c			      ld    A, H                    ; Exit if ptr is null 
14df b5			      or    L 
14e0 ca a4 15		      jp    Z, free_early_exit 
14e3			 
14e3			      ; Set up stack frame 
14e3 eb			      ex    DE, HL 
14e4 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
14e7 39			      add   HL, SP 
14e8 f9			      ld    SP, HL 
14e9 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14ed dd 39		      add   IX, SP 
14ef			 
14ef			      ; The address in HL points to the start of the useable allocated space, 
14ef			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
14ef			      ; address of the block itself. 
14ef eb			      ex    DE, HL 
14f0 11 fc ff		      ld    DE, -4 
14f3 19			      add   HL, DE 
14f4			 
14f4			      ; An allocated block must have a null next block pointer in it 
14f4 7e			      ld    A, (HL) 
14f5 23			      inc   HL 
14f6 b6			      or    (HL) 
14f7 c2 9f 15		      jp    NZ, free_done 
14fa			 
14fa 2b			      dec   HL 
14fb			 
14fb 44			      ld    B, H                    ; Copy HL to BC 
14fc 4d			      ld    C, L 
14fd			 
14fd			      ; Loop through the free list to find the first block with an address 
14fd			      ; higher than the block being freed 
14fd 21 0a 80		      ld    HL, free_list 
1500			 
1500			free_find_higher_block: 
1500 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1501 23			      inc   HL 
1502 56			      ld    D, (HL) 
1503 2b			      dec   HL 
1504			 
1504 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1507 dd 72 01		      ld    (IX+1), D 
150a dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
150d dd 74 03		      ld    (IX+3), H 
1510			 
1510 78			      ld    A, B                    ; Check if DE is greater than BC 
1511 ba			      cp    D                       ; Compare MSB first 
1512 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1514 30 04		      jr    NC, free_find_higher_block_skip 
1516 79			      ld    A, C 
1517 bb			      cp    E                       ; Then compare LSB 
1518 38 08		      jr    C, free_found_higher_block 
151a			 
151a			free_find_higher_block_skip: 
151a 7a			      ld    A, D                    ; Reached the end of the free list? 
151b b3			      or    E 
151c ca 9f 15		      jp    Z, free_done 
151f			 
151f eb			      ex    DE, HL 
1520			 
1520 18 de		      jr    free_find_higher_block 
1522			 
1522			free_found_higher_block: 
1522			      ; Insert freed block between prev and next free blocks 
1522 71			      ld    (HL), C                 ; Point prev free block to freed block 
1523 23			      inc   HL 
1524 70			      ld    (HL), B 
1525			 
1525 60			      ld    H, B                    ; Point freed block at next free block 
1526 69			      ld    L, C 
1527 73			      ld    (HL), E 
1528 23			      inc   HL 
1529 72			      ld    (HL), D 
152a			 
152a			      ; Check if the freed block is adjacent to the next free block 
152a 23			      inc   HL                      ; Load size of freed block into HL 
152b 5e			      ld    E, (HL) 
152c 23			      inc   HL 
152d 56			      ld    D, (HL) 
152e eb			      ex    DE, HL 
152f			 
152f 09			      add   HL, BC                  ; Add addr of freed block and its size 
1530			 
1530 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1533 dd 56 01		      ld    D, (IX+1) 
1536			 
1536 b7			      or    A                       ; Clear the carry flag 
1537 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1539 20 22		      jr    NZ, free_check_adjacent_to_prev 
153b			 
153b			      ; Freed block is adjacent to next, merge into one bigger block 
153b eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
153c 5e			      ld    E, (HL) 
153d 23			      inc   HL 
153e 56			      ld    D, (HL) 
153f e5			      push  HL                      ; Save ptr to next block for later 
1540			 
1540 60			      ld    H, B                    ; Store ptr from next block into freed block 
1541 69			      ld    L, C 
1542 73			      ld    (HL), E 
1543 23			      inc   HL 
1544 72			      ld    (HL), D 
1545			 
1545 e1			      pop   HL                      ; Restore ptr to next block 
1546 23			      inc   HL                      ; Load size of next block into DE 
1547 5e			      ld    E, (HL) 
1548 23			      inc   HL 
1549 56			      ld    D, (HL) 
154a d5			      push  DE                      ; Save next block size for later 
154b			 
154b 60			      ld    H, B                    ; Load size of freed block into HL 
154c 69			      ld    L, C 
154d 23			      inc   HL 
154e 23			      inc   HL 
154f 5e			      ld    E, (HL) 
1550 23			      inc   HL 
1551 56			      ld    D, (HL) 
1552 eb			      ex    DE, HL 
1553			 
1553 d1			      pop   DE                      ; Restore size of next block 
1554 19			      add   HL, DE                  ; Add sizes of both blocks 
1555 eb			      ex    DE, HL 
1556			 
1556 60			      ld    H, B                    ; Store new bigger size into freed block 
1557 69			      ld    L, C 
1558 23			      inc   HL 
1559 23			      inc   HL 
155a 73			      ld    (HL), E 
155b 23			      inc   HL 
155c 72			      ld    (HL), D 
155d			 
155d			free_check_adjacent_to_prev: 
155d			      ; Check if the freed block is adjacent to the prev free block 
155d dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1560 dd 66 03		      ld    H, (IX+3) 
1563			 
1563 23			      inc   HL                      ; Size of prev free block into DE 
1564 23			      inc   HL 
1565 5e			      ld    E, (HL) 
1566 23			      inc   HL 
1567 56			      ld    D, (HL) 
1568 2b			      dec   HL 
1569 2b			      dec   HL 
156a 2b			      dec   HL 
156b			 
156b 19			      add   HL, DE                  ; Add prev block addr and size 
156c			 
156c b7			      or    A                       ; Clear the carry flag 
156d ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
156f 20 2e		      jr    NZ, free_done 
1571			 
1571			      ; Freed block is adjacent to prev, merge into one bigger block 
1571 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1572 69			      ld    L, C 
1573 5e			      ld    E, (HL) 
1574 23			      inc   HL 
1575 56			      ld    D, (HL) 
1576 e5			      push  HL                      ; Save freed block ptr for later 
1577			 
1577 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
157a dd 66 03		      ld    H, (IX+3) 
157d 73			      ld    (HL), E 
157e 23			      inc   HL 
157f 72			      ld    (HL), D 
1580			 
1580 e1			      pop   HL                      ; Restore freed block ptr 
1581 23			      inc   HL                      ; Load size of freed block into DE 
1582 5e			      ld    E, (HL) 
1583 23			      inc   HL 
1584 56			      ld    D, (HL) 
1585 d5			      push  DE                      ; Save freed block size for later 
1586			 
1586 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1589 dd 66 03		      ld    H, (IX+3) 
158c 23			      inc   HL 
158d 23			      inc   HL 
158e 5e			      ld    E, (HL) 
158f 23			      inc   HL 
1590 56			      ld    D, (HL) 
1591			 
1591 e1			      pop   HL                      ; Add sizes of both blocks 
1592 19			      add   HL, DE 
1593 eb			      ex    DE, HL 
1594			 
1594 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1597 dd 66 03		      ld    H, (IX+3) 
159a 23			      inc   HL 
159b 23			      inc   HL 
159c 73			      ld    (HL), E 
159d 23			      inc   HL 
159e 72			      ld    (HL), D 
159f			 
159f			free_done: 
159f 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
15a2 39			      add   HL, SP 
15a3 f9			      ld    SP, HL 
15a4			 
15a4			free_early_exit: 
15a4 dd e1		      pop   IX 
15a6 d1			      pop   DE 
15a7 c1			      pop   BC 
15a8			 
15a8 c9			      ret 
15a9			 
15a9			; moved to firmware.asm 
15a9			; 
15a9			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15a9			;                  .dw   0 
15a9			 
15a9			 
15a9			endif 
15a9			 
15a9			 
15a9			if MALLOC_3 
15a9			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
15a9			;heap_start        .equ  0x9000      ; Starting address of heap 
15a9			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
15a9			; 
15a9			 ;     .org 0 
15a9			  ;    jp    main 
15a9			; 
15a9			; 
15a9			 ;     .org  0x100 
15a9			;main: 
15a9			 ;     ld    HL, 0x8100 
15a9			  ;    ld    SP, HL 
15a9			; 
15a9			;      call  heap_init 
15a9			 
15a9			      ; Make some allocations 
15a9			;      ld    HL, 12 
15a9			;      call  malloc            ; Allocates 0x9004 
15a9			; 
15a9			 ;     ld    HL, 12 
15a9			;      call  malloc            ; Allocates 0x9014 
15a9			 
15a9			;      ld    HL, 12 
15a9			;      call  malloc            ; Allocates 0x9024 
15a9			 
15a9			      ; Free some allocations 
15a9			;      ld    HL, 0x9014 
15a9			;      call  free 
15a9			 
15a9			;      ld    HL, 0x9004 
15a9			;      call  free 
15a9			; 
15a9			;      ld    HL, 0x9024 
15a9			;      call  free 
15a9			 
15a9			 
15a9			 ;     halt 
15a9			 
15a9			 
15a9			;------------------------------------------------------------------------------ 
15a9			;     heap_init                                                               : 
15a9			;                                                                             : 
15a9			; Description                                                                 : 
15a9			;     Initialise the heap and make it ready for malloc and free operations.   : 
15a9			;                                                                             : 
15a9			;     The heap is maintained as a linked list, starting with an initial       : 
15a9			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
15a9			;     the first free block in the heap. Each block then points to the next    : 
15a9			;     free block within the heap, and the free list ends at the first block   : 
15a9			;     with a null pointer to the next free block.                             : 
15a9			;                                                                             : 
15a9			; Parameters                                                                  : 
15a9			;     Inputs are compile-time only. Two defines which specify the starting    : 
15a9			;     address of the heap and its size are required, along with a memory      : 
15a9			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
15a9			;     principally stores a pointer to the first free block in the heap.       : 
15a9			;                                                                             : 
15a9			; Returns                                                                     : 
15a9			;     Nothing                                                                 : 
15a9			;------------------------------------------------------------------------------ 
15a9			heap_init: 
15a9			      push  HL 
15a9			 
15a9			      ; Initialise free list struct 
15a9			      ld    HL, heap_start 
15a9			      ld    (free_list), HL 
15a9			      ld    HL, 0 
15a9			      ld    (free_list+2), HL 
15a9			 
15a9			      ; Insert first free block at bottom of heap, consumes entire heap 
15a9			      ld    HL, heap_start+heap_size-4 
15a9			      ld    (heap_start), HL        ; Next block (end of free list) 
15a9			      ld    HL, heap_size-4 
15a9			      ld    (heap_start+2), HL      ; Block size 
15a9			 
15a9			      ; Insert end of free list block at top of heap - two null words will 
15a9			      ; terminate the free list 
15a9			      ld    HL, 0 
15a9			      ld    (heap_start+heap_size-2), HL 
15a9			      ld    (heap_start+heap_size-4), HL 
15a9			 
15a9			      pop   HL 
15a9			 
15a9			      ret 
15a9			 
15a9			 
15a9			;------------------------------------------------------------------------------ 
15a9			;     malloc                                                                  : 
15a9			;                                                                             : 
15a9			; Description                                                                 : 
15a9			;     Allocates the wanted space from the heap and returns the address of the : 
15a9			;     first useable byte of the allocation.                                   : 
15a9			;                                                                             : 
15a9			;     Allocations can happen in one of two ways:                              : 
15a9			;                                                                             : 
15a9			;     1. A free block may be found which is the exact size wanted. In this    : 
15a9			;        case the block is removed from the free list and retuedn to the      : 
15a9			;        caller.                                                              : 
15a9			;     2. A free block may be found which is larger than the size wanted. In   : 
15a9			;        this case, the larger block is split into two. The first portion of  : 
15a9			;        this block will become the requested space by the malloc call and    : 
15a9			;        is returned to the caller. The second portion becomes a new free     : 
15a9			;        block, and the free list is adjusted to maintain continuity via this : 
15a9			;        newly created block.                                                 : 
15a9			;                                                                             : 
15a9			;     malloc does not set any initial value in the allocated space, the       : 
15a9			;     caller is required to do this as required.                              : 
15a9			;                                                                             : 
15a9			;     This implementation of malloc uses the stack exclusively, and is        : 
15a9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15a9			;     advisable to disable interrupts before calling malloc, and recommended  : 
15a9			;     to avoid the use of malloc inside ISRs in general.                      : 
15a9			;                                                                             : 
15a9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15a9			;                                                                             : 
15a9			; Parameters                                                                  : 
15a9			;     HL  Number of bytes wanted                                              : 
15a9			;                                                                             : 
15a9			; Returns                                                                     : 
15a9			;     HL  Address of the first useable byte of the allocation                 : 
15a9			;                                                                             : 
15a9			; Flags                                                                       : 
15a9			;     Z   Set if the allocation did not succeed, clear otherwise              : 
15a9			;                                                                             : 
15a9			; Stack frame                                                                 : 
15a9			;       |             |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     BC      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     DE      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     IX      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |  prev_free  |                                                       : 
15a9			;   +4  +-------------+                                                       : 
15a9			;       |  this_free  |                                                       : 
15a9			;   +2  +-------------+                                                       : 
15a9			;       |  next_free  |                                                       : 
15a9			;   +0  +-------------+                                                       : 
15a9			;       |             |                                                       : 
15a9			;                                                                             : 
15a9			;------------------------------------------------------------------------------ 
15a9			malloc: 
15a9			      push  BC 
15a9			      push  DE 
15a9			      push  IX 
15a9			 
15a9			      ld    A, H                    ; Exit if no space requested 
15a9			      or    L 
15a9			      jp    Z, malloc_early_exit 
15a9			 
15a9			      ; Set up stack frame 
15a9			      ex    DE, HL 
15a9			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
15a9			      add   HL, SP 
15a9			      ld    SP, HL 
15a9			      ld    IX, 0                   ; Use IX as a frame pointer 
15a9			      add   IX, SP 
15a9			 
15a9			      ; Setup initial state 
15a9			      ld    HL, 4                   ; want must also include space used by block struct 
15a9			      add   HL, DE 
15a9			 
15a9			      ld    B, H                    ; Move want to BC 
15a9			      ld    C, L 
15a9			 
15a9			      ld    HL, free_list           ; Store prev_free ptr to stack 
15a9			      ld    (IX+4), L 
15a9			      ld    (IX+5), H 
15a9			 
15a9			      ld    E, (HL)                 ; Store this_free ptr to stack 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      ld    (IX+2), E 
15a9			      ld    (IX+3), D 
15a9			      ex    DE, HL                  ; this_free ptr into HL 
15a9			 
15a9			      ; Loop through free block list to find some space 
15a9			malloc_find_space: 
15a9			      ld    E, (HL)                 ; Load next_free ptr into DE 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			 
15a9			      ld    A, D                    ; Check for null next_free ptr - end of free list 
15a9			      or    E 
15a9			      jp    Z, malloc_no_space 
15a9			 
15a9			      ld    (IX+0), E               ; Store next_free ptr to stack 
15a9			      ld    (IX+1), D 
15a9			 
15a9			      ; Does this block have enough space to make the allocation? 
15a9			      inc   HL                      ; Load free block size into DE 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			 
15a9			      ex    DE, HL                  ; Check size of block against want 
15a9			      or    A                       ; Ensure carry flag clear 
15a9			      sbc   HL, BC 
15a9			      push  HL                      ; Store the result for later (new block size) 
15a9			 
15a9			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
15a9			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
15a9			 
15a9			      ; this_free block is not big enough, setup ptrs to test next free block 
15a9			      pop   HL                      ; Discard previous result 
15a9			 
15a9			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
15a9			      ld    H, (IX+3) 
15a9			      ld    (IX+4), L 
15a9			      ld    (IX+5), H 
15a9			 
15a9			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
15a9			      ld    H, (IX+1) 
15a9			      ld    (IX+2), L 
15a9			      ld    (IX+3), H 
15a9			 
15a9			      jr    malloc_find_space 
15a9			 
15a9			      ; split a bigger block into two - requested size and remaining size 
15a9			malloc_alloc_split: 
15a9			      ex    DE, HL                  ; Calculate address of new free block 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      add   HL, BC 
15a9			 
15a9			      ; Create a new block and point it at next_free 
15a9			      ld    E, (IX+0)               ; Load next_free ptr into DE 
15a9			      ld    D, (IX+1) 
15a9			 
15a9			      ld    (HL), E                 ; Store next_free ptr into new block 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      pop   DE                      ; Store size of new block into new block 
15a9			      inc   HL 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      ; Update this_free ptr to point to new block 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			 
15a9			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
15a9			      ld    D, (IX+3) 
15a9			 
15a9			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
15a9			      ld    (IX+3), H 
15a9			 
15a9			      ; Modify this_free block to be allocation 
15a9			      ex    DE, HL 
15a9			      xor   A                       ; Null the next block ptr of allocated block 
15a9			      ld    (HL), A 
15a9			      inc   HL 
15a9			      ld    (HL), A 
15a9			 
15a9			      inc   HL                      ; Store want size into allocated block 
15a9			      ld    (HL), C 
15a9			      inc   HL 
15a9			      ld    (HL), B 
15a9			      inc   HL 
15a9			      push  HL                      ; Address of allocation to return 
15a9			 
15a9			      jr    malloc_update_links 
15a9			 
15a9			malloc_alloc_fit: 
15a9			      pop   HL                      ; Dont need new block size, want is exact fit 
15a9			 
15a9			      ; Modify this_free block to be allocation 
15a9			      ex    DE, HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			 
15a9			      xor   A                       ; Null the next block ptr of allocated block 
15a9			      ld    (HL), A 
15a9			      inc   HL 
15a9			      ld    (HL), A 
15a9			 
15a9			      inc   HL                      ; Store address of allocation to return 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      push  HL 
15a9			 
15a9			      ; Copy next_free ptr to this_free, remove allocated block from free list 
15a9			      ld    L, (IX+0)               ; next_free to HL 
15a9			      ld    H, (IX+1) 
15a9			 
15a9			      ld    (IX+2), L               ; HL to this_free 
15a9			      ld    (IX+3), H 
15a9			 
15a9			 
15a9			malloc_update_links: 
15a9			      ; Update prev_free ptr to point to this_free 
15a9			      ld    L, (IX+4)               ; prev_free ptr to HL 
15a9			      ld    H, (IX+5) 
15a9			 
15a9			      ld    E, (IX+2)               ; this_free ptr to DE 
15a9			      ld    D, (IX+3) 
15a9			 
15a9			      ld    (HL), E                 ; this_free ptr into prev_free 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      ; Clear the Z flag to indicate successful allocation 
15a9			      ld    A, D 
15a9			      or    E 
15a9			 
15a9			      pop   DE                      ; Address of allocation 
15a9			 
15a9			malloc_no_space: 
15a9			      ld    HL, 6                   ; Clean up stack frame 
15a9			      add   HL, SP 
15a9			      ld    SP, HL 
15a9			 
15a9			      ex    DE, HL                  ; Alloc addr into HL for return 
15a9			 
15a9			malloc_early_exit: 
15a9			      pop   IX 
15a9			      pop   DE 
15a9			      pop   BC 
15a9			 
15a9			      ret 
15a9			 
15a9			 
15a9			;------------------------------------------------------------------------------ 
15a9			;     free                                                                    : 
15a9			;                                                                             : 
15a9			; Description                                                                 : 
15a9			;     Return the space pointed to by HL to the heap. HL must be an address as : 
15a9			;     returned by malloc, otherwise the behaviour is undefined.               : 
15a9			;                                                                             : 
15a9			;     Where possible, directly adjacent free blocks will be merged together   : 
15a9			;     into larger blocks to help ensure that the heap does not become         : 
15a9			;     excessively fragmented.                                                 : 
15a9			;                                                                             : 
15a9			;     free does not clear or set any other value into the freed space, and    : 
15a9			;     therefore its contents may be visible through subsequent malloc's. The  : 
15a9			;     caller should clear the freed space as required.                        : 
15a9			;                                                                             : 
15a9			;     This implementation of free uses the stack exclusively, and is          : 
15a9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15a9			;     advisable to disable interrupts before calling free, and recommended    : 
15a9			;     to avoid the use of free inside ISRs in general.                        : 
15a9			;                                                                             : 
15a9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15a9			;                                                                             : 
15a9			; Parameters                                                                  : 
15a9			;     HL  Pointer to address of first byte of allocation to be freed          : 
15a9			;                                                                             : 
15a9			; Returns                                                                     : 
15a9			;     Nothing                                                                 : 
15a9			;                                                                             : 
15a9			; Stack frame                                                                 : 
15a9			;       |             |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     BC      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     DE      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |     IX      |                                                       : 
15a9			;       +-------------+                                                       : 
15a9			;       |  prev_free  |                                                       : 
15a9			;   +2  +-------------+                                                       : 
15a9			;       |  next_free  |                                                       : 
15a9			;   +0  +-------------+                                                       : 
15a9			;       |             |                                                       : 
15a9			;                                                                             : 
15a9			;------------------------------------------------------------------------------ 
15a9			free: 
15a9			      push  BC 
15a9			      push  DE 
15a9			      push  IX 
15a9			 
15a9			      ld    A, H                    ; Exit if ptr is null 
15a9			      or    L 
15a9			      jp    Z, free_early_exit 
15a9			 
15a9			      ; Set up stack frame 
15a9			      ex    DE, HL 
15a9			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
15a9			      add   HL, SP 
15a9			      ld    SP, HL 
15a9			      ld    IX, 0                   ; Use IX as a frame pointer 
15a9			      add   IX, SP 
15a9			 
15a9			      ; The address in HL points to the start of the useable allocated space, 
15a9			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
15a9			      ; address of the block itself. 
15a9			      ex    DE, HL 
15a9			      ld    DE, -4 
15a9			      add   HL, DE 
15a9			 
15a9			      ; An allocated block must have a null next block pointer in it 
15a9			      ld    A, (HL) 
15a9			      inc   HL 
15a9			      or    (HL) 
15a9			      jp    NZ, free_done 
15a9			 
15a9			      dec   HL 
15a9			 
15a9			      ld    B, H                    ; Copy HL to BC 
15a9			      ld    C, L 
15a9			 
15a9			      ; Loop through the free list to find the first block with an address 
15a9			      ; higher than the block being freed 
15a9			      ld    HL, free_list 
15a9			 
15a9			free_find_higher_block: 
15a9			      ld    E, (HL)                 ; Load next ptr from free block 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      dec   HL 
15a9			 
15a9			      ld    (IX+0), E               ; Save ptr to next free block 
15a9			      ld    (IX+1), D 
15a9			      ld    (IX+2), L               ; Save ptr to prev free block 
15a9			      ld    (IX+3), H 
15a9			 
15a9			      ld    A, B                    ; Check if DE is greater than BC 
15a9			      cp    D                       ; Compare MSB first 
15a9			      jr    Z, $+4                  ; MSB the same, compare LSB 
15a9			      jr    NC, free_find_higher_block_skip 
15a9			      ld    A, C 
15a9			      cp    E                       ; Then compare LSB 
15a9			      jr    C, free_found_higher_block 
15a9			 
15a9			free_find_higher_block_skip: 
15a9			      ld    A, D                    ; Reached the end of the free list? 
15a9			      or    E 
15a9			      jp    Z, free_done 
15a9			 
15a9			      ex    DE, HL 
15a9			 
15a9			      jr    free_find_higher_block 
15a9			 
15a9			free_found_higher_block: 
15a9			      ; Insert freed block between prev and next free blocks 
15a9			      ld    (HL), C                 ; Point prev free block to freed block 
15a9			      inc   HL 
15a9			      ld    (HL), B 
15a9			 
15a9			      ld    H, B                    ; Point freed block at next free block 
15a9			      ld    L, C 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      ; Check if the freed block is adjacent to the next free block 
15a9			      inc   HL                      ; Load size of freed block into HL 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      ex    DE, HL 
15a9			 
15a9			      add   HL, BC                  ; Add addr of freed block and its size 
15a9			 
15a9			      ld    E, (IX+0)               ; Load addr of next free block into DE 
15a9			      ld    D, (IX+1) 
15a9			 
15a9			      or    A                       ; Clear the carry flag 
15a9			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15a9			      jr    NZ, free_check_adjacent_to_prev 
15a9			 
15a9			      ; Freed block is adjacent to next, merge into one bigger block 
15a9			      ex    DE, HL                  ; Load next ptr from next block into DE 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      push  HL                      ; Save ptr to next block for later 
15a9			 
15a9			      ld    H, B                    ; Store ptr from next block into freed block 
15a9			      ld    L, C 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      pop   HL                      ; Restore ptr to next block 
15a9			      inc   HL                      ; Load size of next block into DE 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      push  DE                      ; Save next block size for later 
15a9			 
15a9			      ld    H, B                    ; Load size of freed block into HL 
15a9			      ld    L, C 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      ex    DE, HL 
15a9			 
15a9			      pop   DE                      ; Restore size of next block 
15a9			      add   HL, DE                  ; Add sizes of both blocks 
15a9			      ex    DE, HL 
15a9			 
15a9			      ld    H, B                    ; Store new bigger size into freed block 
15a9			      ld    L, C 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			free_check_adjacent_to_prev: 
15a9			      ; Check if the freed block is adjacent to the prev free block 
15a9			      ld    L, (IX+2)               ; Prev free block ptr into HL 
15a9			      ld    H, (IX+3) 
15a9			 
15a9			      inc   HL                      ; Size of prev free block into DE 
15a9			      inc   HL 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			      dec   HL 
15a9			 
15a9			      add   HL, DE                  ; Add prev block addr and size 
15a9			 
15a9			      or    A                       ; Clear the carry flag 
15a9			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15a9			      jr    NZ, free_done 
15a9			 
15a9			      ; Freed block is adjacent to prev, merge into one bigger block 
15a9			      ld    H, B                    ; Load next ptr from freed block into DE 
15a9			      ld    L, C 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      push  HL                      ; Save freed block ptr for later 
15a9			 
15a9			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
15a9			      ld    H, (IX+3) 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			      pop   HL                      ; Restore freed block ptr 
15a9			      inc   HL                      ; Load size of freed block into DE 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			      push  DE                      ; Save freed block size for later 
15a9			 
15a9			      ld    L, (IX+2)               ; Load size of prev block into DE 
15a9			      ld    H, (IX+3) 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      ld    E, (HL) 
15a9			      inc   HL 
15a9			      ld    D, (HL) 
15a9			 
15a9			      pop   HL                      ; Add sizes of both blocks 
15a9			      add   HL, DE 
15a9			      ex    DE, HL 
15a9			 
15a9			      ld    L, (IX+2)               ; Store new bigger size into prev block 
15a9			      ld    H, (IX+3) 
15a9			      inc   HL 
15a9			      inc   HL 
15a9			      ld    (HL), E 
15a9			      inc   HL 
15a9			      ld    (HL), D 
15a9			 
15a9			free_done: 
15a9			      ld    HL, 4                   ; Clean up stack frame 
15a9			      add   HL, SP 
15a9			      ld    SP, HL 
15a9			 
15a9			free_early_exit: 
15a9			      pop   IX 
15a9			      pop   DE 
15a9			      pop   BC 
15a9			 
15a9			      ret 
15a9			 
15a9			 
15a9			;      .org 0x8000 
15a9			; 
15a9			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15a9			 ;                 .dw   0 
15a9			 
15a9			endif 
15a9			 
15a9			 
15a9			if MALLOC_4 
15a9			 
15a9			; My memory allocation code. Very very simple.... 
15a9			; allocate space under 250 chars 
15a9			 
15a9			heap_init: 
15a9				; init start of heap as zero 
15a9				;  
15a9			 
15a9				ld hl, heap_start 
15a9				ld a, 0 
15a9				ld (hl), a      ; empty block 
15a9				inc hl 
15a9				ld a, 0 
15a9				ld (hl), a      ; length of block 
15a9				; write end of list 
15a9				inc hl 
15a9				ld a,(hl) 
15a9				inc hl 
15a9				ld a,(hl) 
15a9				 
15a9			 
15a9				; init some malloc vars 
15a9			 
15a9				ld hl, 0 
15a9				ld (free_list), hl       ; store last malloc location 
15a9			 
15a9				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
15a9				ld a, 0 
15a9				ld (hl), a 
15a9			 
15a9			 
15a9				ld hl, heap_start 
15a9				;  
15a9				  
15a9				ret 
15a9			 
15a9			 
15a9			;    free block marker 
15a9			;    requested size  
15a9			;    pointer to next block 
15a9			;    .... 
15a9			;    next block marker 
15a9			 
15a9			 
15a9			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
15a9			; 
15a9			 
15a9			 
15a9			malloc:  
15a9				push de 
15a9				push bc 
15a9				push af 
15a9			 
15a9				; hl space required 
15a9				 
15a9				ld c, l    ; hold space   (TODO only a max of 255) 
15a9			 
15a9			;	inc c     ; TODO BUG need to fix memory leak on push str 
15a9			;	inc c 
15a9			;	inc c 
15a9			;	inc c 
15a9			;	inc c 
15a9			;	inc c 
15a9			;	inc c 
15a9			 
15a9			 
15a9			 
15a9				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
15a9			 
15a9				ld a, (free_list+3) 
15a9				cp 0 
15a9				jr z, .contheap 
15a9			 
15a9				ld hl, (free_list)     ; get last alloc 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mrs" 
15a9						CALLMONITOR 
15a9					endif 
15a9				jr .startalloc 
15a9			 
15a9			.contheap: 
15a9				ld hl, heap_start 
15a9			 
15a9			.startalloc: 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mym" 
15a9						CALLMONITOR 
15a9					endif 
15a9			.findblock: 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mmf" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9				ld a,(hl)  
15a9				; if byte is zero then clear to use 
15a9			 
15a9				cp 0 
15a9				jr z, .foundemptyblock 
15a9			 
15a9				; if byte is not clear 
15a9				;     then byte is offset to next block 
15a9			 
15a9				inc hl 
15a9				ld a, (hl) ; get size 
15a9			.nextblock:	inc hl 
15a9					ld e, (hl) 
15a9					inc hl 
15a9					ld d, (hl) 
15a9					ex de, hl 
15a9			;	inc hl  ; move past the store space 
15a9			;	inc hl  ; move past zero index  
15a9			 
15a9				; TODO detect no more space 
15a9			 
15a9				push hl 
15a9				ld de, heap_end 
15a9				call cmp16 
15a9				pop hl 
15a9				jr nc, .nospace 
15a9			 
15a9				jr .findblock 
15a9			 
15a9			.nospace: ld hl, 0 
15a9				jp .exit 
15a9			 
15a9			 
15a9			.foundemptyblock:	 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mme" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9			; TODO has block enough space if reusing??? 
15a9			 
15a9				;  
15a9			 
15a9			; see if this block has been previously used 
15a9				inc hl 
15a9				ld a, (hl) 
15a9				dec hl 
15a9				cp 0 
15a9				jr z, .newblock 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "meR" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9			; no reusing previously allocated block 
15a9			 
15a9			; is it smaller than previously used? 
15a9				 
15a9				inc hl    ; move to size 
15a9				ld a, c 
15a9				sub (hl)        ; we want c < (hl) 
15a9				dec hl    ; move back to marker 
15a9			        jr z, .findblock 
15a9			 
15a9				; update with the new size which should be lower 
15a9			 
15a9			        ;inc  hl   ; negate next move. move back to size  
15a9			 
15a9			.newblock: 
15a9				; need to be at marker here 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "meN" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9			 
15a9				ld a, c 
15a9			 
15a9				ld (free_list+3), a	 ; flag resume from last malloc  
15a9				ld (free_list), hl    ; save out last location 
15a9			 
15a9			 
15a9				;inc a     ; space for length byte 
15a9				ld (hl), a     ; save block in use marker 
15a9			 
15a9				inc hl   ; move to space marker 
15a9				ld (hl), a    ; save new space 
15a9			 
15a9				inc hl   ; move to start of allocated area 
15a9				 
15a9			;	push hl     ; save where we are - 1  
15a9			 
15a9			;	inc hl  ; move past zero index  
15a9				; skip space to set down new marker 
15a9			 
15a9				; provide some extra space for now 
15a9			 
15a9				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
15a9				inc a 
15a9				inc a 
15a9			 
15a9				push hl   ; save where we are in the node block 
15a9			 
15a9				call addatohl 
15a9			 
15a9				; write linked list point 
15a9			 
15a9				pop de     ; get our node position 
15a9				ex de, hl 
15a9			 
15a9				ld (hl), e 
15a9				inc hl 
15a9				ld (hl), d 
15a9			 
15a9				inc hl 
15a9			 
15a9				; now at start of allocated data so save pointer 
15a9			 
15a9				push hl 
15a9			 
15a9				; jump to position of next node and setup empty header in DE 
15a9			 
15a9				ex de, hl 
15a9			 
15a9			;	inc hl ; move past end of block 
15a9			 
15a9				ld a, 0 
15a9				ld (hl), a   ; empty marker 
15a9				inc hl 
15a9				ld (hl), a   ; size 
15a9				inc hl  
15a9				ld (hl), a   ; ptr 
15a9				inc hl 
15a9				ld (hl), a   ; ptr 
15a9			 
15a9			 
15a9				pop hl 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "mmr" 
15a9						CALLMONITOR 
15a9					endif 
15a9			 
15a9			.exit: 
15a9				pop af 
15a9				pop bc 
15a9				pop de  
15a9				ret 
15a9			 
15a9			 
15a9			 
15a9			 
15a9			free:  
15a9				push hl 
15a9				push af 
15a9				; get address in hl 
15a9			 
15a9					if DEBUG_FORTH_MALLOC_INT 
15a9						DMARK "fre" 
15a9						CALLMONITOR 
15a9					endif 
15a9				; data is at hl - move to block count 
15a9				dec hl 
15a9				dec hl    ; get past pointer 
15a9				dec hl 
15a9			 
15a9				ld a, (hl)    ; need this for a validation check 
15a9			 
15a9				dec hl    ; move to block marker 
15a9			 
15a9				; now check that the block count and block marker are the same  
15a9			        ; this checks that we are on a malloc node and not random memory 
15a9			        ; OK a faint chance this could be a problem but rare - famous last words! 
15a9			 
15a9				ld c, a 
15a9				ld a, (hl)    
15a9			 
15a9				cp c 
15a9				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
15a9			 
15a9				; yes good chance we are on a malloc node 
15a9			 
15a9				ld a, 0      
15a9				ld (hl), a   ; mark as free 
15a9			 
15a9				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
15a9			 
15a9			.freeignore:  
15a9			 
15a9				pop af 
15a9				pop hl 
15a9			 
15a9				ret 
15a9			 
15a9			 
15a9			 
15a9			endif 
15a9			 
15a9			; eof 
# End of file firmware_memory.asm
15a9			  
15a9			; device C  
15a9			if SOUND_ENABLE  
15a9				include "firmware_sound.asm"  
15a9			endif  
15a9			  
15a9			include "firmware_diags.asm"  
15a9			; Hardware diags menu 
15a9			 
15a9			 
15a9			config: 
15a9			 
15a9 3e 00			ld a, 0 
15ab 21 d9 15			ld hl, .configmn 
15ae cd 46 0d			call menu 
15b1			 
15b1 fe 00			cp 0 
15b3 c8				ret z 
15b4			 
15b4 fe 01			cp 1 
15b6 cc b2 16			call z, .savetostore 
15b9			 
15b9 fe 02			cp 2 
15bb cc 00 16			call z, .selautoload 
15be fe 03			cp 3 
15c0 cc e9 15			call z, .disautoload 
15c3 fe 04			cp 4 
15c5 cc b0 16			call z, .selbank 
15c8 fe 05			cp 5 
15ca cc 8d 17			call z, .debug_tog 
15cd fe 06			cp 6 
15cf cc d0 18			call z, .bpsgo 
15d2 fe 07			cp 7 
15d4 cc b3 17			call z, hardware_diags 
15d7			 
15d7 18 d0			jr config 
15d9			 
15d9			.configmn: 
15d9 c1 1a			dw prom_c3 
15db d8 1a			dw prom_c2 
15dd ed 1a			dw prom_c2a 
15df 03 1b			dw prom_c2b 
15e1			;	dw prom_c4 
15e1 20 1b			dw prom_m4 
15e3 3b 1b			dw prom_m4b 
15e5 43 1b			dw prom_c1 
15e7 00 00			dw 0 
15e9				 
15e9			 
15e9			 
15e9			 
15e9			.disautoload: 
15e9				if STORAGE_SE 
15e9 3e fe			ld a, $fe      ; bit 0 clear 
15eb 32 ed fb			ld (spi_device), a 
15ee			 
15ee cd ca 04			call storage_get_block_0 
15f1			 
15f1 3e 00			ld a, 0 
15f3 32 28 fc			ld (store_page+STORE_0_AUTOFILE), a 
15f6			 
15f6 21 00 00				ld hl, 0 
15f9 11 07 fc				ld de, store_page 
15fc cd 7e 04			call storage_write_block	 ; save update 
15ff				else 
15ff			 
15ff				ld hl, prom_notav 
15ff				ld de, prom_empty 
15ff				call info_panel 
15ff				endif 
15ff			 
15ff			 
15ff c9				ret 
1600			 
1600			 
1600			 
1600			; Select auto start 
1600			 
1600			.selautoload: 
1600			 
1600				 
1600				if STORAGE_SE 
1600			 
1600 cd d7 16				call config_dir 
1603 21 4e f3			        ld hl, scratch 
1606 3e 00				ld a, 0 
1608 cd 46 0d				call menu 
160b			 
160b fe 00				cp 0 
160d c8					ret z 
160e			 
160e 3d					dec a 
160f			 
160f			 
160f					; locate menu option 
160f			 
160f 21 4e f3				ld hl, scratch 
1612 cd 6a 0c				call table_lookup 
1615			 
1615					if DEBUG_FORTH_WORDS 
1615						DMARK "ALl" 
1615 f5				push af  
1616 3a 2a 16			ld a, (.dmark)  
1619 32 b4 fe			ld (debug_mark),a  
161c 3a 2b 16			ld a, (.dmark+1)  
161f 32 b5 fe			ld (debug_mark+1),a  
1622 3a 2c 16			ld a, (.dmark+2)  
1625 32 b6 fe			ld (debug_mark+2),a  
1628 18 03			jr .pastdmark  
162a ..			.dmark: db "ALl"  
162d f1			.pastdmark: pop af  
162e			endm  
# End of macro DMARK
162e						CALLMONITOR 
162e cd c6 18			call break_point_state  
1631				endm  
# End of macro CALLMONITOR
1631					endif 
1631					; with the pointer to the menu it, the byte following the zero term is the file id 
1631			 
1631 3e 00				ld a, 0 
1633 01 32 00				ld bc, 50   ; max of bytes to look at 
1636 ed b1				cpir  
1638			 
1638					if DEBUG_FORTH_WORDS 
1638						DMARK "ALb" 
1638 f5				push af  
1639 3a 4d 16			ld a, (.dmark)  
163c 32 b4 fe			ld (debug_mark),a  
163f 3a 4e 16			ld a, (.dmark+1)  
1642 32 b5 fe			ld (debug_mark+1),a  
1645 3a 4f 16			ld a, (.dmark+2)  
1648 32 b6 fe			ld (debug_mark+2),a  
164b 18 03			jr .pastdmark  
164d ..			.dmark: db "ALb"  
1650 f1			.pastdmark: pop af  
1651			endm  
# End of macro DMARK
1651						CALLMONITOR 
1651 cd c6 18			call break_point_state  
1654				endm  
# End of macro CALLMONITOR
1654					endif 
1654					;inc hl 
1654			 
1654 7e					ld a, (hl)   ; file id 
1655					 
1655				        ; save bank and file ids 
1655			 
1655 f5					push af 
1656			 
1656			; TODO need to save to block 0 on bank 1	 
1656			 
1656 cd ca 04				call storage_get_block_0 
1659			 
1659					if DEBUG_FORTH_WORDS 
1659						DMARK "AL0" 
1659 f5				push af  
165a 3a 6e 16			ld a, (.dmark)  
165d 32 b4 fe			ld (debug_mark),a  
1660 3a 6f 16			ld a, (.dmark+1)  
1663 32 b5 fe			ld (debug_mark+1),a  
1666 3a 70 16			ld a, (.dmark+2)  
1669 32 b6 fe			ld (debug_mark+2),a  
166c 18 03			jr .pastdmark  
166e ..			.dmark: db "AL0"  
1671 f1			.pastdmark: pop af  
1672			endm  
# End of macro DMARK
1672						CALLMONITOR 
1672 cd c6 18			call break_point_state  
1675				endm  
# End of macro CALLMONITOR
1675					endif 
1675 f1					pop af 
1676			 
1676 32 2b fc				ld (store_page+STORE_0_FILERUN),a 
1679					 
1679					; save bank id 
1679			 
1679 3a ed fb				ld a,(spi_device) 
167c 32 2a fc				ld (store_page+STORE_0_BANKRUN),a 
167f			 
167f					; enable auto run of store file 
167f			 
167f 3e 01				ld a, 1 
1681 32 28 fc				ld (store_page+STORE_0_AUTOFILE),a 
1684			 
1684					; save buffer 
1684			 
1684 21 00 00				ld hl, 0 
1687 11 07 fc				ld de, store_page 
168a					if DEBUG_FORTH_WORDS 
168a						DMARK "ALw" 
168a f5				push af  
168b 3a 9f 16			ld a, (.dmark)  
168e 32 b4 fe			ld (debug_mark),a  
1691 3a a0 16			ld a, (.dmark+1)  
1694 32 b5 fe			ld (debug_mark+1),a  
1697 3a a1 16			ld a, (.dmark+2)  
169a 32 b6 fe			ld (debug_mark+2),a  
169d 18 03			jr .pastdmark  
169f ..			.dmark: db "ALw"  
16a2 f1			.pastdmark: pop af  
16a3			endm  
# End of macro DMARK
16a3						CALLMONITOR 
16a3 cd c6 18			call break_point_state  
16a6				endm  
# End of macro CALLMONITOR
16a6					endif 
16a6 cd 7e 04			call storage_write_block	 ; save update 
16a9			  
16a9			 
16a9			 
16a9			 
16a9 21 4e f3				ld hl, scratch 
16ac cd c4 16				call config_fdir 
16af			 
16af				else 
16af			 
16af				ld hl, prom_notav 
16af				ld de, prom_empty 
16af				call info_panel 
16af			 
16af				endif 
16af c9				ret 
16b0			 
16b0			 
16b0			 
16b0			; Select storage bank 
16b0			 
16b0			.selbank: 
16b0			 
16b0				if STORAGE_SE 
16b0				else 
16b0			 
16b0				ld hl, prom_notav 
16b0				ld de, prom_empty 
16b0				call info_panel 
16b0				endif 
16b0				 
16b0 c9				ret 
16b1			 
16b1			if STORAGE_SE 
16b1			 
16b1			.config_ldir:   
16b1				; Load storage bank labels into menu array 
16b1			 
16b1				 
16b1			 
16b1			 
16b1 c9				ret 
16b2			 
16b2			 
16b2			endif 
16b2			 
16b2			 
16b2			; Save user words to storage 
16b2			 
16b2			.savetostore: 
16b2			 
16b2				if STORAGE_SE 
16b2			 
16b2 cd d7 16				call config_dir 
16b5 21 4e f3			        ld hl, scratch 
16b8 3e 00				ld a, 0 
16ba cd 46 0d				call menu 
16bd					 
16bd 21 4e f3				ld hl, scratch 
16c0 cd c4 16				call config_fdir 
16c3			 
16c3				else 
16c3			 
16c3				ld hl, prom_notav 
16c3				ld de, prom_empty 
16c3				call info_panel 
16c3			 
16c3				endif 
16c3			 
16c3 c9				ret 
16c4			 
16c4			 
16c4			 
16c4			if STORAGE_SE 
16c4			 
16c4			config_fdir: 
16c4				; using the scratch dir go through and release the memory allocated for each string 
16c4				 
16c4 21 4e f3			ld hl, scratch 
16c7 5e			.cfdir:	ld e,(hl) 
16c8 23				inc hl 
16c9 56				ld d,(hl) 
16ca 23				inc hl 
16cb			 
16cb eb				ex de, hl 
16cc cd 72 0f			call ishlzero 
16cf c8				ret z     ; return on null pointer 
16d0 cd da 14			call free 
16d3 eb				ex de, hl 
16d4 18 f1			jr .cfdir 
16d6			 
16d6			 
16d6 c9				ret 
16d7			 
16d7			 
16d7			config_dir: 
16d7			 
16d7				; for the config menus that need to build a directory of storage call this routine 
16d7				; it will construct a menu in scratch to pass to menu 
16d7			 
16d7				; open storage device 
16d7			 
16d7				; execute DIR to build a list of files and their ids into scratch in menu format 
16d7				; once the menu has finished then will need to call config_fdir to release the strings 
16d7				 
16d7				; c = number items 
16d7			 
16d7				 
16d7 cd ca 04			call storage_get_block_0 
16da			 
16da 21 07 fc			ld hl, store_page     ; get current id count 
16dd 46				ld b, (hl) 
16de 0e 00			ld c, 0    ; count of files   
16e0			 
16e0			 
16e0 21 4e f3			ld hl, scratch 
16e3 22 fe fb			ld (store_tmp2), hl    ; location to poke strings 
16e6			 
16e6				; check for empty drive 
16e6			 
16e6 3e 00			ld a, 0 
16e8 b8				cp b 
16e9 ca 83 17			jp z, .dirdone 
16ec			 
16ec				 
16ec					if DEBUG_FORTH_WORDS 
16ec						DMARK "Cdc" 
16ec f5				push af  
16ed 3a 01 17			ld a, (.dmark)  
16f0 32 b4 fe			ld (debug_mark),a  
16f3 3a 02 17			ld a, (.dmark+1)  
16f6 32 b5 fe			ld (debug_mark+1),a  
16f9 3a 03 17			ld a, (.dmark+2)  
16fc 32 b6 fe			ld (debug_mark+2),a  
16ff 18 03			jr .pastdmark  
1701 ..			.dmark: db "Cdc"  
1704 f1			.pastdmark: pop af  
1705			endm  
# End of macro DMARK
1705						CALLMONITOR 
1705 cd c6 18			call break_point_state  
1708				endm  
# End of macro CALLMONITOR
1708					endif 
1708			 
1708			 
1708			.diritem:	 
1708 c5				push bc 
1709				; for each of the current ids do a search for them and if found push to stack 
1709			 
1709 21 40 00				ld hl, STORE_BLOCK_PHY 
170c 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
170e 58					ld e,b 
170f			 
170f cd 4c 07				call storage_findnextid 
1712			 
1712			 
1712					; if found hl will be non zero 
1712			 
1712 cd 72 0f				call ishlzero 
1715 28 69				jr z, .dirnotfound 
1717			 
1717					; increase count 
1717			 
1717 c1					pop bc	 
1718 0c					inc c 
1719 c5					push bc 
171a					 
171a			 
171a					; get file header and push the file name 
171a			 
171a 11 07 fc				ld de, store_page 
171d cd 19 04				call storage_read_block 
1720			 
1720					; push file id to stack 
1720				 
1720 3a 07 fc				ld a, (store_page) 
1723 26 00				ld h, 0 
1725 6f					ld l, a 
1726			 
1726					;call forth_push_numhl 
1726					; TODO store id 
1726			 
1726 e5					push hl 
1727			 
1727					; push extent count to stack  
1727				 
1727 21 0a fc				ld hl, store_page+3 
172a			 
172a					; get file name length 
172a			 
172a cd a7 13				call strlenz   
172d			 
172d 23					inc hl   ; cover zero term 
172e 23					inc hl  ; stick the id at the end of the area 
172f			 
172f e5					push hl 
1730 c1					pop bc    ; move length to bc 
1731			 
1731 cd 10 14				call malloc 
1734			 
1734					; TODO save malloc area to scratch 
1734			 
1734 eb					ex de, hl 
1735 2a fe fb				ld hl, (store_tmp2) 
1738 73					ld (hl), e 
1739 23					inc hl 
173a 72					ld (hl), d 
173b 23					inc hl 
173c 22 fe fb				ld (store_tmp2), hl 
173f			 
173f					 
173f			 
173f					;pop hl   ; get source 
173f			;		ex de, hl    ; swap aronund	 
173f			 
173f 21 0a fc				ld hl, store_page+3 
1742					if DEBUG_FORTH_WORDS 
1742						DMARK "CFd" 
1742 f5				push af  
1743 3a 57 17			ld a, (.dmark)  
1746 32 b4 fe			ld (debug_mark),a  
1749 3a 58 17			ld a, (.dmark+1)  
174c 32 b5 fe			ld (debug_mark+1),a  
174f 3a 59 17			ld a, (.dmark+2)  
1752 32 b6 fe			ld (debug_mark+2),a  
1755 18 03			jr .pastdmark  
1757 ..			.dmark: db "CFd"  
175a f1			.pastdmark: pop af  
175b			endm  
# End of macro DMARK
175b						CALLMONITOR 
175b cd c6 18			call break_point_state  
175e				endm  
# End of macro CALLMONITOR
175e					endif 
175e ed b0				ldir 
1760			 
1760					; de is past string, move back one and store id 
1760					 
1760 1b					dec de 
1761			 
1761					; store file id 
1761			 
1761 e1					pop hl 
1762 eb					ex de,hl 
1763 73					ld (hl), e 
1764			 
1764					if DEBUG_FORTH_WORDS 
1764						DMARK "Cdi" 
1764 f5				push af  
1765 3a 79 17			ld a, (.dmark)  
1768 32 b4 fe			ld (debug_mark),a  
176b 3a 7a 17			ld a, (.dmark+1)  
176e 32 b5 fe			ld (debug_mark+1),a  
1771 3a 7b 17			ld a, (.dmark+2)  
1774 32 b6 fe			ld (debug_mark+2),a  
1777 18 03			jr .pastdmark  
1779 ..			.dmark: db "Cdi"  
177c f1			.pastdmark: pop af  
177d			endm  
# End of macro DMARK
177d						CALLMONITOR 
177d cd c6 18			call break_point_state  
1780				endm  
# End of macro CALLMONITOR
1780					endif 
1780					 
1780			.dirnotfound: 
1780 c1					pop bc     
1781 10 85				djnz .diritem 
1783				 
1783			.dirdone:	 
1783			 
1783 3e 00				ld a, 0 
1785 2a fe fb				ld hl, (store_tmp2) 
1788 77					ld (hl), a 
1789 23					inc hl 
178a 77					ld (hl), a 
178b 23					inc hl 
178c					; push a count of the dir items found 
178c			 
178c			;		ld h, 0 
178c			;		ld l, c 
178c			 
178c c9				ret 
178d			 
178d			endif 
178d			 
178d			 
178d			; Settings 
178d			; Run  
178d			 
178d			 
178d			 
178d			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
178d			;;hd_menu2:   db "        2: Editor",0   
178d			;hd_menu2:   db "        2: Editor       6: Menu",0   
178d			;hd_menu3:   db "        3: Storage",0 
178d			;hd_menu4:   db "0=quit  4: Debug",0 
178d			;hd_don:     db "ON",0 
178d			;hd_doff:     db "OFF",0 
178d			; 
178d			; 
178d			; 
178d			;hardware_diags_old:       
178d			; 
178d			;.diagmenu: 
178d			;	call clear_display 
178d			;	ld a, display_row_1 
178d			;	ld de, hd_menu1 
178d			;	call str_at_display 
178d			; 
178d			;	ld a, display_row_2 
178d			;	ld de, hd_menu2 
178d			;	call str_at_display 
178d			; 
178d			;	ld a, display_row_3 
178d			;	ld de, hd_menu3 
178d			;	call str_at_display 
178d			; 
178d			;	ld a,  display_row_4 
178d			;	ld de, hd_menu4 
178d			;	call str_at_display 
178d			; 
178d			;	; display debug state 
178d			; 
178d			;	ld de, hd_don 
178d			;	ld a, (os_view_disable) 
178d			;	cp 0 
178d			;	jr z, .distog 
178d			;	ld de, hd_doff 
178d			;.distog: ld a, display_row_4+17 
178d			;	call str_at_display 
178d			; 
178d			;	call update_display 
178d			; 
178d			;	call cin_wait 
178d			; 
178d			; 
178d			; 
178d			;	cp '4' 
178d			;	jr nz, .diagn1 
178d			; 
178d			;	; debug toggle 
178d			; 
178d			;	ld a, (os_view_disable) 
178d			;	ld b, '*' 
178d			;	cp 0 
178d			;	jr z, .debtog 
178d			;	ld b, 0 
178d			;.debtog:	 
178d			;	ld a,b 
178d			;	ld (os_view_disable),a 
178d			; 
178d			;.diagn1: cp '0' 
178d			;	 ret z 
178d			; 
178d			;;	cp '1' 
178d			;;       jp z, matrix	 
178d			;;   TODO keyboard matrix test 
178d			; 
178d			;	cp '2' 
178d			;	jp z, .diagedit 
178d			; 
178d			;;	cp '6' 
178d			;;	jp z, .menutest 
178d			;;if ENABLE_BASIC 
178d			;;	cp '6' 
178d			;;	jp z, basic 
178d			;;endif 
178d			 ; 
178d			;	jp .diagmenu 
178d			; 
178d			; 
178d			;	ret 
178d			 
178d			 
178d			.debug_tog: 
178d 21 d4 17			ld hl, .menudebug 
1790				 
1790 3a 3f f3			ld a, (os_view_disable) 
1793 fe 2a			cp '*' 
1795 20 04			jr nz,.tdon  
1797 3e 01			ld a, 1 
1799 18 02			jr .tog1 
179b 3e 00		.tdon: ld a, 0 
179d			 
179d			.tog1: 
179d cd 46 0d			call menu 
17a0 fe 00			cp 0 
17a2 c8				ret z 
17a3 fe 01			cp 1    ; disable debug 
17a5 28 04			jr z, .dtog0 
17a7 3e 2a			ld a, '*' 
17a9 18 02			jr .dtogset 
17ab 3e 00		.dtog0: ld a, 0 
17ad 32 3f f3		.dtogset:  ld (os_view_disable), a 
17b0 c3 8d 17			jp .debug_tog 
17b3			 
17b3			 
17b3			hardware_diags:       
17b3			 
17b3			.diagm: 
17b3 21 c6 17			ld hl, .menuitems 
17b6 3e 00			ld a, 0 
17b8 cd 46 0d			call menu 
17bb			 
17bb fe 00		         cp 0 
17bd c8				 ret z 
17be			 
17be fe 02			cp 2 
17c0 ca 1f 18			jp z, .diagedit 
17c3			 
17c3			;	cp '6' 
17c3			;	jp z, .menutest 
17c3			;if ENABLE_BASIC 
17c3			;	cp '6' 
17c3			;	jp z, basic 
17c3			;endif 
17c3			  
17c3 c3 b3 17			jp .diagm 
17c6			 
17c6				 
17c6 da 17		.menuitems:   	dw .m1 
17c8 e5 17				dw .m2 
17ca ec 17				dw .m3 
17cc f4 17				dw .m5 
17ce fa 17				dw .m5a 
17d0 03 18				dw .m5b 
17d2 00 00				dw 0 
17d4			 
17d4			.menudebug: 
17d4 0c 18				dw .m6 
17d6 15 18				dw .m7 
17d8 00 00				dw 0 
17da			 
17da .. 00		.m1:   db "Key Matrix",0 
17e5 .. 00		.m2:   db "Editor",0 
17ec .. 00		.m3:   db "Storage",0 
17f4 .. 00		.m5:   db "Sound",0 
17fa .. 00		.m5a:  db "RAM Test",0 
1803 .. 00		.m5b:  db "LCD Test",0 
180c			 
180c .. 00		.m6:   db "Debug ON",0 
1815 .. 00		.m7:   db "Debug OFF",0 
181f			 
181f			; debug editor 
181f			 
181f			.diagedit: 
181f			 
181f 21 4e f3			ld hl, scratch 
1822			;	ld bc, 250 
1822			;	ldir 
1822				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1822 3e 00			ld a, 0 
1824 77				ld (hl), a 
1825 23				inc hl 
1826 77				ld (hl), a 
1827 23				inc hl 
1828 77				ld (hl), a 
1829			 
1829 cd 15 0d		        call clear_display 
182c cd 38 0d			call update_display 
182f				;ld a, 1 
182f				;ld (hardware_diag), a 
182f			.diloop: 
182f 3e 00			ld a, display_row_1 
1831 0e 00			ld c, 0 
1833 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1835 1e 28			ld e, 40 
1837			 
1837 21 4e f3			ld hl, scratch	 
183a cd 76 0f			call input_str 
183d			 
183d 3e 14			ld a, display_row_2 
183f 11 4e f3			ld de, scratch 
1842 cd 28 0d			call str_at_display 
1845 cd 38 0d			call update_display 
1848			 
1848 c3 2f 18			jp .diloop 
184b			 
184b			 
184b			; pass word in hl 
184b			; a has display location 
184b			display_word_at: 
184b f5				push af 
184c e5				push hl 
184d 7c				ld a,h 
184e 21 53 f6			ld hl, os_word_scratch 
1851 cd 4a 12			call hexout 
1854 e1				pop hl 
1855 7d				ld a,l 
1856 21 55 f6			ld hl, os_word_scratch+2 
1859 cd 4a 12			call hexout 
185c 21 57 f6			ld hl, os_word_scratch+4 
185f 3e 00			ld a,0 
1861 77				ld (hl),a 
1862 11 53 f6			ld de,os_word_scratch 
1865 f1				pop af 
1866 cd 28 0d				call str_at_display 
1869 c9				ret 
186a			 
186a			display_ptr_state: 
186a			 
186a				; to restore afterwards 
186a			 
186a d5				push de 
186b c5				push bc 
186c e5				push hl 
186d f5				push af 
186e			 
186e				; for use in here 
186e			 
186e			;	push bc 
186e			;	push de 
186e			;	push hl 
186e			;	push af 
186e			 
186e cd 15 0d			call clear_display 
1871			 
1871 11 44 1a			ld de, .ptrstate 
1874 3e 00			ld a, display_row_1 
1876 cd 28 0d			call str_at_display 
1879			 
1879				; display debug step 
1879			 
1879			 
1879 11 b4 fe			ld de, debug_mark 
187c 3e 12			ld a, display_row_1+display_cols-2 
187e cd 28 0d			call str_at_display 
1881			 
1881				; display a 
1881 11 4e 1a			ld de, .ptrcliptr 
1884 3e 14			ld a, display_row_2 
1886 cd 28 0d			call str_at_display 
1889			 
1889 f1				pop af 
188a 2a cd fb			ld hl,(cli_ptr) 
188d 3e 1c			ld a, display_row_2+8 
188f cd 4b 18			call display_word_at 
1892			 
1892			 
1892				; display hl 
1892			 
1892			 
1892 11 56 1a			ld de, .ptrclioptr 
1895 3e 1e			ld a, display_row_2+10 
1897 cd 28 0d			call str_at_display 
189a			; 
189a			;	pop hl 
189a 3e 21			ld a, display_row_2+13 
189c 2a cb fb			ld hl,(cli_origptr) 
189f cd 4b 18			call display_word_at 
18a2			; 
18a2			;	 
18a2			;	; display de 
18a2			 
18a2			;	ld de, .regstatede 
18a2			;	ld a, display_row_3 
18a2			;	call str_at_display 
18a2			 
18a2			;	pop de 
18a2			;	ld h,d 
18a2			;	ld l, e 
18a2			;	ld a, display_row_3+3 
18a2			;	call display_word_at 
18a2			 
18a2			 
18a2				; display bc 
18a2			 
18a2			;	ld de, .regstatebc 
18a2			;	ld a, display_row_3+10 
18a2			;	call str_at_display 
18a2			 
18a2			;	pop bc 
18a2			;	ld h,b 
18a2			;	ld l, c 
18a2			;	ld a, display_row_3+13 
18a2			;	call display_word_at 
18a2			 
18a2			 
18a2				; display dsp 
18a2			 
18a2			;	ld de, .regstatedsp 
18a2			;	ld a, display_row_4 
18a2			;	call str_at_display 
18a2			 
18a2				 
18a2			;	ld hl,(cli_data_sp) 
18a2			;	ld a, display_row_4+4 
18a2			;	call display_word_at 
18a2			 
18a2				; display rsp 
18a2			 
18a2 11 85 1a			ld de, .regstatersp 
18a5 3e 46			ld a, display_row_4+10 
18a7 cd 28 0d			call str_at_display 
18aa			 
18aa				 
18aa 2a 7f fb			ld hl,(cli_ret_sp) 
18ad 3e 4a			ld a, display_row_4+14 
18af cd 4b 18			call display_word_at 
18b2			 
18b2 cd 38 0d			call update_display 
18b5			 
18b5 cd 92 0c			call delay1s 
18b8 cd 92 0c			call delay1s 
18bb cd 92 0c			call delay1s 
18be			 
18be			 
18be cd b2 1e			call next_page_prompt 
18c1			 
18c1				; restore  
18c1			 
18c1 f1				pop af 
18c2 e1				pop hl 
18c3 c1				pop bc 
18c4 d1				pop de 
18c5 c9				ret 
18c6			 
18c6			break_point_state: 
18c6 f5				push af 
18c7			 
18c7				; see if disabled 
18c7			 
18c7 3a 3f f3			ld a, (os_view_disable) 
18ca fe 2a			cp '*' 
18cc 20 02			jr nz, .bpsgo 
18ce f1				pop af 
18cf c9				ret 
18d0			 
18d0			.bpsgo: 
18d0 f1				pop af 
18d1 f5				push af 
18d2 22 3b f3			ld (os_view_hl), hl 
18d5 ed 53 39 f3		ld (os_view_de), de 
18d9 ed 43 37 f3		ld (os_view_bc), bc 
18dd e5				push hl 
18de 6f				ld l, a 
18df 26 00			ld h, 0 
18e1 22 3d f3			ld (os_view_af),hl 
18e4			 
18e4 21 4a fe				ld hl, display_fb0 
18e7 22 55 fd				ld (display_fb_active), hl 
18ea e1				pop hl	 
18eb			 
18eb 3e 31			ld a, '1' 
18ed fe 2a		.bps1:  cp '*' 
18ef 20 03			jr nz, .bps1b 
18f1 32 3f f3			ld (os_view_disable),a 
18f4 fe 31		.bps1b:  cp '1' 
18f6 20 14			jr nz, .bps2 
18f8			 
18f8				; display reg 
18f8			 
18f8				 
18f8			 
18f8 3a 3d f3			ld a, (os_view_af) 
18fb 2a 3b f3			ld hl, (os_view_hl) 
18fe ed 5b 39 f3		ld de, (os_view_de) 
1902 ed 4b 37 f3		ld bc, (os_view_bc) 
1906 cd a0 19			call display_reg_state 
1909 c3 8c 19			jp .bpschk 
190c			 
190c fe 32		.bps2:  cp '2' 
190e 20 08			jr nz, .bps3 
1910				 
1910				; display hl 
1910 2a 3b f3			ld hl, (os_view_hl) 
1913 cd 8a 1a			call display_dump_at_hl 
1916			 
1916 18 74			jr .bpschk 
1918			 
1918 fe 33		.bps3:  cp '3' 
191a 20 08			jr nz, .bps4 
191c			 
191c			        ; display de 
191c 2a 39 f3			ld hl, (os_view_de) 
191f cd 8a 1a			call display_dump_at_hl 
1922			 
1922 18 68			jr .bpschk 
1924 fe 34		.bps4:  cp '4' 
1926 20 08			jr nz, .bps5 
1928			 
1928			        ; display bc 
1928 2a 37 f3			ld hl, (os_view_bc) 
192b cd 8a 1a			call display_dump_at_hl 
192e			 
192e 18 5c			jr .bpschk 
1930 fe 35		.bps5:  cp '5' 
1932 20 08		        jr nz, .bps7 
1934			 
1934				; display cur ptr 
1934 2a cd fb			ld hl, (cli_ptr) 
1937 cd 8a 1a			call display_dump_at_hl 
193a			 
193a 18 50			jr .bpschk 
193c fe 36		.bps7:  cp '6' 
193e 20 08			jr nz, .bps8b 
1940				 
1940				; display cur orig ptr 
1940 2a cb fb			ld hl, (cli_origptr) 
1943 cd 8a 1a			call display_dump_at_hl 
1946 18 44			jr .bpschk 
1948 fe 37		.bps8b:  cp '7' 
194a 20 08			jr nz, .bps9 
194c				 
194c				; display dsp 
194c 2a 7b fb			ld hl, (cli_data_sp) 
194f cd 8a 1a			call display_dump_at_hl 
1952			 
1952 18 38			jr .bpschk 
1954 fe 39		.bps9:  cp '9' 
1956 20 05			jr nz, .bps8c 
1958				 
1958				; display SP 
1958			;	ld hl, sp 
1958 cd 8a 1a			call display_dump_at_hl 
195b			 
195b 18 2f			jr .bpschk 
195d fe 38		.bps8c:  cp '8' 
195f 20 08			jr nz, .bps8d 
1961				 
1961				; display rsp 
1961 2a 7f fb			ld hl, (cli_ret_sp) 
1964 cd 8a 1a			call display_dump_at_hl 
1967			 
1967 18 23			jr .bpschk 
1969 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
196b 20 05			jr nz, .bps8 
196d cd a8 1c			call monitor 
1970			 
1970 18 1a			jr .bpschk 
1972 fe 30		.bps8:  cp '0' 
1974 20 16			jr nz, .bpschk 
1976			 
1976 21 f9 fd				ld hl, display_fb1 
1979 22 55 fd				ld (display_fb_active), hl 
197c cd 38 0d				call update_display 
197f			 
197f				;ld a, (os_view_af) 
197f 2a 3b f3			ld hl, (os_view_hl) 
1982 ed 5b 39 f3		ld de, (os_view_de) 
1986 ed 4b 37 f3		ld bc, (os_view_bc) 
198a f1				pop af 
198b c9				ret 
198c			 
198c			.bpschk:   
198c cd 92 0c			call delay1s 
198f 3e 4f		ld a,display_row_4 + display_cols - 1 
1991 11 b0 1e		        ld de, endprg 
1994 cd 28 0d			call str_at_display 
1997 cd 38 0d			call update_display 
199a cd b1 71			call cin_wait 
199d			 
199d c3 ed 18			jp .bps1 
19a0			 
19a0			 
19a0			display_reg_state: 
19a0			 
19a0				; to restore afterwards 
19a0			 
19a0 d5				push de 
19a1 c5				push bc 
19a2 e5				push hl 
19a3 f5				push af 
19a4			 
19a4				; for use in here 
19a4			 
19a4 c5				push bc 
19a5 d5				push de 
19a6 e5				push hl 
19a7 f5				push af 
19a8			 
19a8 cd 15 0d			call clear_display 
19ab			 
19ab 11 60 1a			ld de, .regstate 
19ae 3e 00			ld a, display_row_1 
19b0 cd 28 0d			call str_at_display 
19b3			 
19b3				; display debug step 
19b3			 
19b3			 
19b3 11 b4 fe			ld de, debug_mark 
19b6 3e 11			ld a, display_row_1+display_cols-3 
19b8 cd 28 0d			call str_at_display 
19bb			 
19bb				; display a 
19bb 11 7c 1a			ld de, .regstatea 
19be 3e 14			ld a, display_row_2 
19c0 cd 28 0d			call str_at_display 
19c3			 
19c3 e1				pop hl 
19c4			;	ld h,0 
19c4			;	ld l, a 
19c4 3e 17			ld a, display_row_2+3 
19c6 cd 4b 18			call display_word_at 
19c9			 
19c9			 
19c9				; display hl 
19c9			 
19c9			 
19c9 11 70 1a			ld de, .regstatehl 
19cc 3e 1e			ld a, display_row_2+10 
19ce cd 28 0d			call str_at_display 
19d1			 
19d1 e1				pop hl 
19d2 3e 21			ld a, display_row_2+13 
19d4 cd 4b 18			call display_word_at 
19d7			 
19d7				 
19d7				; display de 
19d7			 
19d7 11 74 1a			ld de, .regstatede 
19da 3e 28			ld a, display_row_3 
19dc cd 28 0d			call str_at_display 
19df			 
19df e1				pop hl 
19e0			;	ld h,d 
19e0			;	ld l, e 
19e0 3e 2b			ld a, display_row_3+3 
19e2 cd 4b 18			call display_word_at 
19e5			 
19e5			 
19e5				; display bc 
19e5			 
19e5 11 78 1a			ld de, .regstatebc 
19e8 3e 32			ld a, display_row_3+10 
19ea cd 28 0d			call str_at_display 
19ed			 
19ed e1				pop hl 
19ee			;	ld h,b 
19ee			;	ld l, c 
19ee 3e 35			ld a, display_row_3+13 
19f0 cd 4b 18			call display_word_at 
19f3			 
19f3			 
19f3				; display dsp 
19f3			 
19f3 11 80 1a			ld de, .regstatedsp 
19f6 3e 3c			ld a, display_row_4 
19f8 cd 28 0d			call str_at_display 
19fb			 
19fb				 
19fb 2a 7b fb			ld hl,(cli_data_sp) 
19fe 3e 40			ld a, display_row_4+4 
1a00 cd 4b 18			call display_word_at 
1a03			 
1a03				; display rsp 
1a03			 
1a03 11 85 1a			ld de, .regstatersp 
1a06 3e 46			ld a, display_row_4+10 
1a08 cd 28 0d			call str_at_display 
1a0b			 
1a0b				 
1a0b 2a 7f fb			ld hl,(cli_ret_sp) 
1a0e 3e 4a			ld a, display_row_4+14 
1a10 cd 4b 18			call display_word_at 
1a13			 
1a13 cd 38 0d			call update_display 
1a16			 
1a16			;	call delay1s 
1a16			;	call delay1s 
1a16			;	call delay1s 
1a16			 
1a16			 
1a16			;	call next_page_prompt 
1a16			 
1a16				; restore  
1a16			 
1a16 f1				pop af 
1a17 e1				pop hl 
1a18 c1				pop bc 
1a19 d1				pop de 
1a1a c9				ret 
1a1b			 
1a1b .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1a2f .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1a44 .. 00		.ptrstate:	db "Ptr State",0 
1a4e .. 00		.ptrcliptr:     db "cli_ptr",0 
1a56 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1a60 .. 00		.regstate:	db "Reg State (1/0)",0 
1a70 .. 00		.regstatehl:	db "HL:",0 
1a74 .. 00		.regstatede:	db "DE:",0 
1a78 .. 00		.regstatebc:	db "BC:",0 
1a7c .. 00		.regstatea:	db "A :",0 
1a80 .. 00		.regstatedsp:	db "DSP:",0 
1a85 .. 00		.regstatersp:	db "RSP:",0 
1a8a			 
1a8a			display_dump_at_hl: 
1a8a e5				push hl 
1a8b d5				push de 
1a8c c5				push bc 
1a8d f5				push af 
1a8e			 
1a8e 22 71 f6			ld (os_cur_ptr),hl	 
1a91 cd 15 0d			call clear_display 
1a94 cd ba 1d			call dumpcont 
1a97			;	call delay1s 
1a97			;	call next_page_prompt 
1a97			 
1a97			 
1a97 f1				pop af 
1a98 c1				pop bc 
1a99 d1				pop de 
1a9a e1				pop hl 
1a9b c9				ret 
1a9c			 
1a9c			;if ENABLE_BASIC 
1a9c			;	include "nascombasic.asm" 
1a9c			;	basic: 
1a9c			;	include "forth/FORTH.ASM" 
1a9c			;endif 
1a9c			 
1a9c			; eof 
1a9c			 
1a9c			 
# End of file firmware_diags.asm
1a9c			  
1a9c			include "firmware_prompts.asm"  
1a9c			; Prompts  
1a9c			 
1a9c			; boot messages 
1a9c			 
1a9c .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1ab1 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1ac1			 
1ac1			 
1ac1			; config menus 
1ac1			 
1ac1 .. 00		prom_c3: db "Add Dictionary To File",0 
1ad8 .. 00		prom_c2: db "Select Autoload File",0 
1aed .. 00		prom_c2a: db "Disable Autoload File", 0 
1b03 .. 00		prom_c2b: db "Select Storage Bank",0 
1b17 .. 00		prom_c4: db "Settings",0 
1b20 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1b3b .. 00		prom_m4b:   db "Monitor",0 
1b43 .. 00		prom_c1: db "Hardware Diags",0 
1b52			 
1b52			 
1b52 .. 00		prom_notav:    db "Feature not available",0 
1b68 .. 00		prom_empty:    db "",0 
1b69			 
1b69			; eof 
1b69			 
# End of file firmware_prompts.asm
1b69			  
1b69			  
1b69			; eof  
1b69			  
# End of file firmware.asm
1b69			 
1b69			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1b69			;if BASE_KEV  
1b69			;baseram: equ 08000h 
1b69			;endif 
1b69			 
1b69			;if BASE_SC114 
1b69			;baseram:     equ    endofcode 
1b69			;endif 
1b69			 
1b69			 
1b69			; start system 
1b69			 
1b69			coldstart: 
1b69				; set sp 
1b69				; di/ei 
1b69			 
1b69 f3				di 
1b6a 31 fd ff			ld sp, tos 
1b6d			;	ei 
1b6d			 
1b6d			 
1b6d				; disable breakpoint by default 
1b6d			 
1b6d 3e 2a			ld a,'*' 
1b6f 32 3f f3			ld (os_view_disable),a 
1b72			 
1b72				; init hardware 
1b72			 
1b72				; init keyboard and screen hardware 
1b72			 
1b72 cd 1c 00			call hardware_init 
1b75			 
1b75			 
1b75 cd 92 0c			call delay1s 
1b78 3e 30			ld a, display_row_3+8 
1b7a 11 03 00			ld de, buildtime 
1b7d cd 28 0d			call str_at_display 
1b80 cd 38 0d			call update_display 
1b83			 
1b83 cd 92 0c			call delay1s 
1b86 cd 92 0c			call delay1s 
1b89 cd 92 0c			call delay1s 
1b8c			 
1b8c				; detect if any keys are held down to enable breakpoints at start up 
1b8c			 
1b8c cd c2 71			call cin  
1b8f fe 00			cp 0 
1b91 28 03			jr z, .nokeys 
1b93			 
1b93				;call hardware_diags 
1b93 cd a9 15			call config 
1b96			 
1b96			;	ld de, .bpen 
1b96			;	ld a, display_row_4 
1b96			;	call str_at_display 
1b96			;	call update_display 
1b96			; 
1b96			;	ld a,0 
1b96			;	ld (os_view_disable),a 
1b96			; 
1b96			;.bpwait: 
1b96			;	call cin 
1b96			;	cp 0 
1b96			;	jr z, .bpwait 
1b96			;	jr .nokeys 
1b96			; 
1b96			; 
1b96			;.bpen:  db "Break points enabled!",0 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			.nokeys: 
1b96			 
1b96			 
1b96				 
1b96			 
1b96			;jp  testkey 
1b96			 
1b96			;call storage_get_block_0 
1b96			; 
1b96			;ld hl, 0 
1b96			;ld de, store_page 
1b96			;call storage_read_block 
1b96			 
1b96				 
1b96			;ld hl, 10 
1b96			;ld de, store_page 
1b96			;call storage_read_block 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			 
1b96			;stop:	nop 
1b96			;	jp stop 
1b96			 
1b96			 
1b96			 
1b96			main: 
1b96 cd 15 0d			call clear_display 
1b99 cd 38 0d			call update_display 
1b9c			 
1b9c			 
1b9c			 
1b9c			;	call testlcd 
1b9c			 
1b9c			 
1b9c			 
1b9c cd b0 22			call forth_init 
1b9f			 
1b9f			 
1b9f			warmstart: 
1b9f cd 86 22			call forth_warmstart 
1ba2			 
1ba2				; run startup word load 
1ba2			        ; TODO prevent this running at warmstart after crash  
1ba2			 
1ba2				if STARTUP_ENABLE 
1ba2					if STORAGE_SE 
1ba2 cd f3 6e					call forth_autoload 
1ba5					endif 
1ba5 cd 02 6c				call forth_startup 
1ba8			 
1ba8			 
1ba8				endif 
1ba8			 
1ba8				; show free memory after boot 
1ba8 11 42 1c			ld de, freeram 
1bab 3e 00			ld a, display_row_1 
1bad cd 28 0d			call str_at_display 
1bb0			 
1bb0			; Or use heap_size word???? 
1bb0 21 34 f3			ld hl, heap_end 
1bb3 11 0e 80			ld de, heap_start 
1bb6 ed 52			sbc hl, de 
1bb8 e5				push hl 
1bb9 7c				ld a,h	         	 
1bba 21 53 f6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1bbd cd 4a 12			call hexout 
1bc0 e1			   	pop hl 
1bc1			 
1bc1 7d				ld a,l 
1bc2 21 55 f6			ld hl, os_word_scratch+2 
1bc5 cd 4a 12			call hexout 
1bc8 21 57 f6			ld hl, os_word_scratch+4 
1bcb 3e 00			ld a, 0 
1bcd 77				ld (hl),a 
1bce 11 53 f6			ld de, os_word_scratch 
1bd1 3e 0d			ld a, display_row_1 + 13 
1bd3 cd 28 0d			call str_at_display 
1bd6 cd 38 0d			call update_display 
1bd9			 
1bd9			 
1bd9				;call demo 
1bd9			 
1bd9			 
1bd9				; init scratch input area for cli commands 
1bd9			 
1bd9 21 75 f6			ld hl, os_cli_cmd 
1bdc 3e 00			ld a,0 
1bde 77				ld (hl),a 
1bdf 23				inc hl 
1be0 77				ld (hl),a 
1be1			 
1be1 3e 00			ld a,0 
1be3 32 74 f7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1be6			 
1be6 32 71 f6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1be9 32 72 f6			ld (os_cur_ptr+1),a	 
1bec			 
1bec 32 53 f6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1bef 32 54 f6			ld (os_word_scratch+1),a	 
1bf2				 
1bf2			 
1bf2				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bf2 21 75 f6			ld hl, os_cli_cmd 
1bf5			 
1bf5 3e 00			ld a, 0		 ; init cli input 
1bf7 77				ld (hl), a 
1bf8 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bfa			cli: 
1bfa				; show cli prompt 
1bfa				;push af 
1bfa				;ld a, 0 
1bfa				;ld de, prompt 
1bfa				;call str_at_display 
1bfa			 
1bfa				;call update_display 
1bfa				;pop af 
1bfa				;inc a 
1bfa				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1bfa 0e 00			ld c, 0 
1bfc 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1bfe 1e 28			ld e, 40 
1c00			 
1c00 21 75 f6			ld hl, os_cli_cmd 
1c03			 
1c03				STACKFRAME OFF $fefe $9f9f 
1c03				if DEBUG_STACK_IMB 
1c03					if OFF 
1c03						exx 
1c03						ld de, $fefe 
1c03						ld a, d 
1c03						ld hl, curframe 
1c03						call hexout 
1c03						ld a, e 
1c03						ld hl, curframe+2 
1c03						call hexout 
1c03						ld hl, $fefe 
1c03						push hl 
1c03						ld hl, $9f9f 
1c03						push hl 
1c03						exx 
1c03					endif 
1c03				endif 
1c03			endm 
# End of macro STACKFRAME
1c03			 
1c03 cd 76 0f			call input_str 
1c06			 
1c06				STACKFRAMECHK OFF $fefe $9f9f 
1c06				if DEBUG_STACK_IMB 
1c06					if OFF 
1c06						exx 
1c06						ld hl, $9f9f 
1c06						pop de   ; $9f9f 
1c06						call cmp16 
1c06						jr nz, .spnosame 
1c06						ld hl, $fefe 
1c06						pop de   ; $fefe 
1c06						call cmp16 
1c06						jr z, .spfrsame 
1c06						.spnosame: call showsperror 
1c06						.spfrsame: nop 
1c06						exx 
1c06					endif 
1c06				endif 
1c06			endm 
# End of macro STACKFRAMECHK
1c06			 
1c06				; copy input to last command 
1c06			 
1c06 21 75 f6			ld hl, os_cli_cmd 
1c09 11 74 f7			ld de, os_last_cmd 
1c0c 01 ff 00			ld bc, 255 
1c0f ed b0			ldir 
1c11			 
1c11				; wipe current buffer 
1c11			 
1c11			;	ld a, 0 
1c11			;	ld hl, os_cli_cmd 
1c11			;	ld de, os_cli_cmd+1 
1c11			;	ld bc, 254 
1c11			;	ldir 
1c11				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1c11			;	call strcpy 
1c11			;	ld a, 0 
1c11			;	ld (hl), a 
1c11			;	inc hl 
1c11			;	ld (hl), a 
1c11			;	inc hl 
1c11			;	ld (hl), a 
1c11			 
1c11				; switch frame buffer to program  
1c11			 
1c11 21 f9 fd				ld hl, display_fb1 
1c14 22 55 fd				ld (display_fb_active), hl 
1c17			 
1c17			;	nop 
1c17				STACKFRAME ON $fbfe $8f9f 
1c17				if DEBUG_STACK_IMB 
1c17					if ON 
1c17						exx 
1c17						ld de, $fbfe 
1c17						ld a, d 
1c17						ld hl, curframe 
1c17						call hexout 
1c17						ld a, e 
1c17						ld hl, curframe+2 
1c17						call hexout 
1c17						ld hl, $fbfe 
1c17						push hl 
1c17						ld hl, $8f9f 
1c17						push hl 
1c17						exx 
1c17					endif 
1c17				endif 
1c17			endm 
# End of macro STACKFRAME
1c17				; first time into the parser so pass over the current scratch pad 
1c17 21 75 f6			ld hl,os_cli_cmd 
1c1a				; tokenise the entered statement(s) in HL 
1c1a cd 2e 23			call forthparse 
1c1d			        ; exec forth statements in top of return stack 
1c1d cd 6e 23			call forthexec 
1c20				;call forthexec_cleanup 
1c20			;	call parsenext 
1c20			 
1c20				STACKFRAMECHK ON $fbfe $8f9f 
1c20				if DEBUG_STACK_IMB 
1c20					if ON 
1c20						exx 
1c20						ld hl, $8f9f 
1c20						pop de   ; $8f9f 
1c20						call cmp16 
1c20						jr nz, .spnosame 
1c20						ld hl, $fbfe 
1c20						pop de   ; $fbfe 
1c20						call cmp16 
1c20						jr z, .spfrsame 
1c20						.spnosame: call showsperror 
1c20						.spfrsame: nop 
1c20						exx 
1c20					endif 
1c20				endif 
1c20			endm 
# End of macro STACKFRAMECHK
1c20				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1c20			 
1c20 3e 3c			ld a, display_row_4 
1c22 11 54 1c			ld de, endprog 
1c25			 
1c25 cd 38 0d			call update_display		 
1c28			 
1c28 cd b2 1e			call next_page_prompt 
1c2b			 
1c2b				; switch frame buffer to cli 
1c2b			 
1c2b 21 4a fe				ld hl, display_fb0 
1c2e 22 55 fd				ld (display_fb_active), hl 
1c31			 
1c31			 
1c31 cd 15 0d		        call clear_display 
1c34 cd 38 0d			call update_display		 
1c37			 
1c37 21 75 f6			ld hl, os_cli_cmd 
1c3a			 
1c3a 3e 00			ld a, 0		 ; init cli input 
1c3c 77				ld (hl), a 
1c3d			 
1c3d				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1c3d			 
1c3d				; now on last line 
1c3d			 
1c3d				; TODO scroll screen up 
1c3d			 
1c3d				; TODO instead just clear screen and place at top of screen 
1c3d			 
1c3d			;	ld a, 0 
1c3d			;	ld (f_cursor_ptr),a 
1c3d			 
1c3d				;call clear_display 
1c3d				;call update_display 
1c3d			 
1c3d				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c3d 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c3f c3 fa 1b			jp cli 
1c42			 
1c42 .. 00		freeram: db "Free bytes: $",0 
1c50 ..			asc: db "1A2F" 
1c54 .. 00		endprog: db "End prog...",0 
1c60			 
1c60			testenter2:   
1c60 21 80 f3			ld hl,scratch+50 
1c63 22 71 f6			ld (os_cur_ptr),hl 
1c66 c3 fa 1b			jp cli 
1c69			 
1c69			testenter:  
1c69			 
1c69 21 50 1c			ld hl,asc 
1c6c			;	ld a,(hl) 
1c6c			;	call nibble2val 
1c6c cd a0 12			call get_byte 
1c6f			 
1c6f			 
1c6f			;	ld a,(hl) 
1c6f			;	call atohex 
1c6f			 
1c6f			;	call fourehexhl 
1c6f 32 80 f3			ld (scratch+50),a 
1c72			 
1c72			 
1c72			 
1c72 21 52 1c			ld hl,asc+2 
1c75			;	ld a, (hl) 
1c75			;	call nibble2val 
1c75 cd a0 12			call get_byte 
1c78			 
1c78			;	call fourehexhl 
1c78 32 82 f3			ld (scratch+52),a 
1c7b				 
1c7b 21 80 f3			ld hl,scratch+50 
1c7e 22 71 f6			ld (os_cur_ptr),hl 
1c81 c3 fa 1b			jp cli 
1c84			 
1c84			enter:	 
1c84 3a 52 f3			ld a,(scratch+4) 
1c87 fe 00			cp 0 
1c89 28 0c			jr z, .entercont 
1c8b				; no, not a null term line so has an address to work out.... 
1c8b			 
1c8b 21 50 f3			ld hl,scratch+2 
1c8e cd 00 13			call get_word_hl 
1c91			 
1c91 22 71 f6			ld (os_cur_ptr),hl	 
1c94 c3 fa 1b			jp cli 
1c97			 
1c97			 
1c97			.entercont:  
1c97			 
1c97 21 50 f3			ld hl, scratch+2 
1c9a cd a0 12			call get_byte 
1c9d			 
1c9d 2a 71 f6		   	ld hl,(os_cur_ptr) 
1ca0 77					ld (hl),a 
1ca1 23					inc hl 
1ca2 22 71 f6				ld (os_cur_ptr),hl 
1ca5				 
1ca5			; get byte  
1ca5			 
1ca5			 
1ca5 c3 fa 1b			jp cli 
1ca8			 
1ca8			 
1ca8			; basic monitor support 
1ca8			 
1ca8			monitor: 
1ca8				;  
1ca8 cd 15 0d			call clear_display 
1cab 3e 00			ld a, 0 
1cad 11 f5 1c			ld de, .monprompt 
1cb0 cd 28 0d			call str_at_display 
1cb3 cd 38 0d			call update_display 
1cb6			 
1cb6				; get a monitor command 
1cb6			 
1cb6 0e 00			ld c, 0     ; entry at top left 
1cb8 16 64			ld d, 100   ; max buffer size 
1cba 1e 0f			ld e, 15    ; input scroll area 
1cbc 3e 00			ld a, 0     ; init string 
1cbe 21 4c f5			ld hl, os_input 
1cc1 77				ld (hl), a 
1cc2 23				inc hl 
1cc3 77				ld (hl), a 
1cc4 21 4c f5			ld hl, os_input 
1cc7 3e 01			ld a, 1     ; init string 
1cc9 cd 76 0f			call input_str 
1ccc			 
1ccc cd 15 0d		        call clear_display 
1ccf cd 38 0d			call update_display		 
1cd2			 
1cd2 3a 4c f5			ld a, (os_input) 
1cd5 cd 9e 13			call toUpper 
1cd8 fe 48		        cp 'H' 
1cda 28 6f		        jr z, .monhelp 
1cdc fe 44			cp 'D'		; dump 
1cde ca 6c 1d			jp z, .mondump	 
1ce1 fe 43			cp 'C'		; dump 
1ce3 ca 86 1d			jp z, .moncdump	 
1ce6 fe 4d			cp 'M'		; dump 
1ce8 ca f7 1c			jp z, .moneditstart 
1ceb fe 55			cp 'U'		; dump 
1ced 28 14			jr z, .monedit	 
1cef fe 51			cp 'Q'		; dump 
1cf1 c8				ret z	 
1cf2			 
1cf2			 
1cf2				; TODO "S" to access symbol by name and not need the address 
1cf2				; TODO "F" to find a string in memory 
1cf2			 
1cf2 c3 a8 1c			jp monitor 
1cf5			 
1cf5 .. 00		.monprompt: db ">", 0 
1cf7			 
1cf7			.moneditstart: 
1cf7				; get starting address 
1cf7			 
1cf7 21 4e f5			ld hl,os_input+2 
1cfa cd 00 13			call get_word_hl 
1cfd			 
1cfd 22 71 f6			ld (os_cur_ptr),hl	 
1d00			 
1d00 c3 a8 1c			jp monitor 
1d03			 
1d03			.monedit: 
1d03				; get byte to load 
1d03			 
1d03 21 4e f5			ld hl,os_input+2 
1d06 cd a0 12			call get_byte 
1d09			 
1d09				; get address to update 
1d09 2a 71 f6			ld hl, (os_cur_ptr) 
1d0c			 
1d0c				; update byte 
1d0c			 
1d0c 77				ld (hl), a 
1d0d			 
1d0d				; move to next address and save it 
1d0d			 
1d0d 23				inc hl 
1d0e 22 71 f6			ld (os_cur_ptr),hl	 
1d11			 
1d11 c3 a8 1c			jp monitor 
1d14			 
1d14			 
1d14 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1d28 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1d44 .. 00		.monhelptext3:  db "Q-Quit",0 
1d4b			        
1d4b			.monhelp: 
1d4b 3e 00			ld a, display_row_1 
1d4d 11 14 1d		        ld de, .monhelptext1 
1d50			 
1d50 cd 28 0d			call str_at_display 
1d53 3e 14			ld a, display_row_2 
1d55 11 28 1d		        ld de, .monhelptext2 
1d58					 
1d58 cd 28 0d			call str_at_display 
1d5b 3e 28			ld a, display_row_3 
1d5d 11 44 1d		        ld de, .monhelptext3 
1d60					 
1d60 cd 28 0d			call str_at_display 
1d63 cd 38 0d			call update_display		 
1d66			 
1d66 cd b2 1e			call next_page_prompt 
1d69 c3 a8 1c			jp monitor 
1d6c			 
1d6c			.mondump:    
1d6c 21 4e f5			ld hl,os_input+2 
1d6f cd 00 13			call get_word_hl 
1d72			 
1d72 22 71 f6			ld (os_cur_ptr),hl	 
1d75 cd ba 1d			call dumpcont 
1d78 3e 3c			ld a, display_row_4 
1d7a 11 54 1c			ld de, endprog 
1d7d			 
1d7d cd 38 0d			call update_display		 
1d80			 
1d80 cd b2 1e			call next_page_prompt 
1d83 c3 a8 1c			jp monitor 
1d86			.moncdump: 
1d86 cd ba 1d			call dumpcont 
1d89 3e 3c			ld a, display_row_4 
1d8b 11 54 1c			ld de, endprog 
1d8e			 
1d8e cd 38 0d			call update_display		 
1d91			 
1d91 cd b2 1e			call next_page_prompt 
1d94 c3 a8 1c			jp monitor 
1d97			 
1d97			 
1d97			; TODO symbol access  
1d97			 
1d97			.symbols:     ;; A list of symbols that can be called up  
1d97 4a fe			dw display_fb0 
1d99 .. 00			db "fb0",0  
1d9d 07 fc		     	dw store_page 
1d9f .. 00			db "store_page",0 
1daa			 
1daa			 
1daa			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1daa			 
1daa 3a 4f f3			ld a,(scratch+1) 
1dad fe 00			cp 0 
1daf 28 09			jr z, dumpcont 
1db1			 
1db1				; no, not a null term line so has an address to work out.... 
1db1			 
1db1 21 50 f3			ld hl,scratch+2 
1db4 cd 00 13			call get_word_hl 
1db7			 
1db7 22 71 f6			ld (os_cur_ptr),hl	 
1dba			 
1dba			 
1dba			 
1dba			dumpcont: 
1dba			 
1dba				; dump bytes at ptr 
1dba			 
1dba			 
1dba 3e 00			ld a, display_row_1 
1dbc 2a 55 fd			ld hl, (display_fb_active) 
1dbf cd 49 0f			call addatohl 
1dc2 cd ea 1d			call .dumpbyterow 
1dc5			 
1dc5 3e 14			ld a, display_row_2 
1dc7 2a 55 fd			ld hl, (display_fb_active) 
1dca cd 49 0f			call addatohl 
1dcd cd ea 1d			call .dumpbyterow 
1dd0			 
1dd0			 
1dd0 3e 28			ld a, display_row_3 
1dd2 2a 55 fd			ld hl, (display_fb_active) 
1dd5 cd 49 0f			call addatohl 
1dd8 cd ea 1d			call .dumpbyterow 
1ddb			 
1ddb 3e 3c			ld a, display_row_4 
1ddd 2a 55 fd			ld hl, (display_fb_active) 
1de0 cd 49 0f			call addatohl 
1de3 cd ea 1d			call .dumpbyterow 
1de6			 
1de6 cd 38 0d			call update_display 
1de9			;		jp cli 
1de9 c9				ret 
1dea			 
1dea			.dumpbyterow: 
1dea			 
1dea				;push af 
1dea			 
1dea e5				push hl 
1deb			 
1deb				; calc where to poke the ascii 
1deb			if display_cols == 20 
1deb 3e 10			ld a, 16 
1ded			else 
1ded				ld a, 31 
1ded			endif 
1ded			 
1ded cd 49 0f			call addatohl 
1df0 22 53 f6			ld (os_word_scratch),hl  		; save pos for later 
1df3			 
1df3			 
1df3			; display decoding address 
1df3 2a 71 f6		   	ld hl,(os_cur_ptr) 
1df6			 
1df6 7c				ld a,h 
1df7 e1				pop hl 
1df8 e5				push hl 
1df9			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1df9 cd 4a 12			call hexout 
1dfc 2a 71 f6		   	ld hl,(os_cur_ptr) 
1dff			 
1dff 7d				ld a,l 
1e00 e1				pop hl 
1e01 23				inc hl 
1e02 23				inc hl 
1e03 e5				push hl 
1e04			;	ld hl, os_word_scratch+2 
1e04 cd 4a 12			call hexout 
1e07 e1				pop hl 
1e08 23				inc hl 
1e09 23				inc hl 
1e0a				;ld hl, os_word_scratch+4 
1e0a 3e 3a			ld a, ':' 
1e0c 77				ld (hl),a 
1e0d 23				inc hl 
1e0e				;ld a, 0 
1e0e				;ld (hl),a 
1e0e				;ld de, os_word_scratch 
1e0e				;pop af 
1e0e				;push af 
1e0e			;		ld a, display_row_2 
1e0e			;		call str_at_display 
1e0e			;		call update_display 
1e0e			 
1e0e			 
1e0e			;pop af 
1e0e			;	add 5 
1e0e			 
1e0e			if display_cols == 20 
1e0e 06 04			ld b, 4 
1e10			else 
1e10				ld b, 8 
1e10			endif	 
1e10			 
1e10			.dumpbyte: 
1e10 c5				push bc 
1e11 e5				push hl 
1e12			 
1e12			 
1e12 2a 71 f6		   	ld hl,(os_cur_ptr) 
1e15 7e					ld a,(hl) 
1e16			 
1e16					; poke the ascii to display 
1e16 2a 53 f6				ld hl,(os_word_scratch) 
1e19 77					ld (hl),a 
1e1a 23					inc hl 
1e1b 22 53 f6				ld (os_word_scratch),hl 
1e1e			 
1e1e					 
1e1e			 
1e1e			 
1e1e e1					pop hl 
1e1f e5					push hl 
1e20			 
1e20 cd 4a 12				call hexout 
1e23			 
1e23					 
1e23 2a 71 f6		   	ld hl,(os_cur_ptr) 
1e26 23				inc hl 
1e27 22 71 f6		   	ld (os_cur_ptr),hl 
1e2a			 
1e2a e1					pop hl 
1e2b 23					inc hl 
1e2c 23					inc hl 
1e2d 23					inc hl 
1e2e			 
1e2e			 
1e2e			 
1e2e					;ld a,0 
1e2e					;ld (os_word_scratch+2),a 
1e2e					;pop af 
1e2e					;push af 
1e2e			 
1e2e					;ld de, os_word_scratch 
1e2e					;call str_at_display 
1e2e			;		call update_display 
1e2e			;		pop af 
1e2e c1					pop bc 
1e2f c6 03				add 3 
1e31 10 dd			djnz .dumpbyte 
1e33			 
1e33				 
1e33			 
1e33 c9				ret 
1e34			 
1e34			jump:	 
1e34			 
1e34 21 50 f3			ld hl,scratch+2 
1e37 cd 00 13			call get_word_hl 
1e3a				;ld hl,(scratch+2) 
1e3a				;call fourehexhl 
1e3a			 
1e3a 22 71 f6			ld (os_cur_ptr),hl	 
1e3d			 
1e3d e9				jp (hl) 
1e3e			 
1e3e			 
1e3e			 
1e3e			; TODO implement a basic monitor mode to start with 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			 
1e3e			; testing and demo code during development 
1e3e			 
1e3e			 
1e3e .. 00		str1: db "Enter some text...",0 
1e51 .. 00		clear: db "                    ",0 
1e66			 
1e66			demo: 
1e66			 
1e66			 
1e66			 
1e66			;	call update_display 
1e66			 
1e66				; init scratch input area for testing 
1e66 21 4e f3			ld hl, scratch	 
1e69 3e 00			ld a,0 
1e6b 77				ld (hl),a 
1e6c			 
1e6c			 
1e6c 3e 14		            LD   A, display_row_2 
1e6e			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e6e 11 3e 1e		            LD   DE, str1 
1e71 cd 28 0d			call str_at_display 
1e74			 
1e74			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e74			cloop:	 
1e74 3e 28		            LD   A, display_row_3 
1e76			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e76 11 51 1e		            LD   DE, clear 
1e79			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1e79 cd 28 0d				call str_at_display 
1e7c 3e 3c			ld a, display_row_4 
1e7e 11 ae 1e			ld de, prompt 
1e81			 
1e81 cd 28 0d				call str_at_display 
1e84 cd 38 0d			call update_display 
1e87			 
1e87 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1e89 16 0a			ld d, 10 
1e8b 21 4e f3			ld hl, scratch	 
1e8e cd 76 0f			call input_str 
1e91			 
1e91			;	call clear_display 
1e91			;'	call update_display 
1e91			 
1e91 3e 00		            LD   A, display_row_1 
1e93			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e93 11 51 1e		            LD   DE, clear 
1e96 cd 28 0d				call str_at_display 
1e99			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e99 3e 00		            LD   A, display_row_1 
1e9b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e9b 11 4e f3		            LD   DE, scratch 
1e9e			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e9e cd 28 0d				call str_at_display 
1ea1 cd 38 0d			call update_display 
1ea4			 
1ea4 3e 00				ld a,0 
1ea6 21 4e f3			ld hl, scratch 
1ea9 77				ld (hl),a 
1eaa			 
1eaa 00				nop 
1eab c3 74 1e			jp cloop 
1eae			 
1eae			 
1eae			 
1eae			; OS Prompt 
1eae			 
1eae .. 00		prompt: db ">",0 
1eb0 .. 00		endprg: db "?",0 
1eb2			 
1eb2			 
1eb2			; handy next page prompt 
1eb2			next_page_prompt: 
1eb2 e5				push hl 
1eb3 d5				push de 
1eb4 f5				push af 
1eb5 c5				push bc 
1eb6			 
1eb6 3e 4f			ld a,display_row_4 + display_cols - 1 
1eb8 11 b0 1e		        ld de, endprg 
1ebb cd 28 0d			call str_at_display 
1ebe cd 38 0d			call update_display 
1ec1 cd b1 71			call cin_wait 
1ec4 c1				pop bc 
1ec5 f1				pop af 
1ec6 d1				pop de 
1ec7 e1				pop hl 
1ec8			 
1ec8			 
1ec8 c9				ret 
1ec9			 
1ec9			 
1ec9			; forth parser 
1ec9			 
1ec9			; My forth kernel 
1ec9			include "forth_kernel.asm" 
1ec9			; 
1ec9			; kernel to the forth OS 
1ec9			 
1ec9			DS_TYPE_STR: equ 1     ; string type 
1ec9			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1ec9			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1ec9			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1ec9			 
1ec9			FORTH_PARSEV1: equ 0 
1ec9			FORTH_PARSEV2: equ 0 
1ec9			FORTH_PARSEV3: equ 0 
1ec9			FORTH_PARSEV4: equ 0 
1ec9			FORTH_PARSEV5: equ 1 
1ec9			 
1ec9			;if FORTH_PARSEV5 
1ec9			;	FORTH_END_BUFFER: equ 0 
1ec9			;else 
1ec9			FORTH_END_BUFFER: equ 127 
1ec9			;endif 
1ec9			 
1ec9			FORTH_TRUE: equ 1 
1ec9			FORTH_FALSE: equ 0 
1ec9			 
1ec9			if FORTH_PARSEV4 
1ec9			include "forth_stackops.asm" 
1ec9			endif 
1ec9			 
1ec9			if FORTH_PARSEV5 
1ec9			include "forth_stackopsv5.asm" 
1ec9			 
1ec9			; Stack operations for v5 parser on wards 
1ec9			; * DATA stack 
1ec9			; * LOOP stack 
1ec9			; * RETURN stack 
1ec9			 
1ec9			 
1ec9			 
1ec9			FORTH_CHK_DSP_UNDER: macro 
1ec9				push hl 
1ec9				push de 
1ec9				ld hl,(cli_data_sp) 
1ec9				ld de, cli_data_stack 
1ec9				call cmp16 
1ec9				jp c, fault_dsp_under 
1ec9				pop de 
1ec9				pop hl 
1ec9				endm 
1ec9			 
1ec9			 
1ec9			FORTH_CHK_RSP_UNDER: macro 
1ec9				push hl 
1ec9				push de 
1ec9				ld hl,(cli_ret_sp) 
1ec9				ld de, cli_ret_stack 
1ec9				call cmp16 
1ec9				jp c, fault_rsp_under 
1ec9				pop de 
1ec9				pop hl 
1ec9				endm 
1ec9			 
1ec9			FORTH_CHK_LOOP_UNDER: macro 
1ec9				push hl 
1ec9				push de 
1ec9				ld hl,(cli_loop_sp) 
1ec9				ld de, cli_loop_stack 
1ec9				call cmp16 
1ec9				jp c, fault_loop_under 
1ec9				pop de 
1ec9				pop hl 
1ec9				endm 
1ec9			 
1ec9			FORTH_ERR_TOS_NOTSTR: macro 
1ec9				; TOSO might need more for checks when used 
1ec9				push af 
1ec9				ld a,(hl) 
1ec9				cp DS_TYPE_STR 
1ec9				jp nz, type_faultn   
1ec9				pop af 
1ec9				endm 
1ec9			 
1ec9			FORTH_ERR_TOS_NOTNUM: macro 
1ec9				push af 
1ec9				ld a,(hl) 
1ec9				cp DS_TYPE_INUM 
1ec9				jp nz, type_faultn   
1ec9				pop af 
1ec9				endm 
1ec9			 
1ec9			 
1ec9			; increase data stack pointer and save hl to it 
1ec9				 
1ec9			FORTH_DSP_NEXT: macro 
1ec9				call macro_forth_dsp_next 
1ec9				endm 
1ec9			 
1ec9			 
1ec9			macro_forth_dsp_next: 
1ec9				if DEBUG_FORTH_STACK_GUARD 
1ec9 cd cc 6c				call check_stacks 
1ecc				endif 
1ecc e5				push hl 
1ecd d5				push de 
1ece eb				ex de,hl 
1ecf 2a 7b fb			ld hl,(cli_data_sp) 
1ed2 23				inc hl 
1ed3 23				inc hl 
1ed4			 
1ed4			; PARSEV5 
1ed4 23				inc hl 
1ed5 22 7b fb			ld (cli_data_sp),hl 
1ed8 73				ld (hl), e 
1ed9 23				inc hl 
1eda 72				ld (hl), d 
1edb d1				pop de 
1edc e1				pop hl 
1edd				if DEBUG_FORTH_STACK_GUARD 
1edd cd cc 6c				call check_stacks 
1ee0				endif 
1ee0 c9				ret 
1ee1			 
1ee1			 
1ee1			; increase ret stack pointer and save hl to it 
1ee1				 
1ee1			FORTH_RSP_NEXT: macro 
1ee1				call macro_forth_rsp_next 
1ee1				endm 
1ee1			 
1ee1			macro_forth_rsp_next: 
1ee1				if DEBUG_FORTH_STACK_GUARD 
1ee1 cd cc 6c				call check_stacks 
1ee4				endif 
1ee4 e5				push hl 
1ee5 d5				push de 
1ee6 eb				ex de,hl 
1ee7 2a 7f fb			ld hl,(cli_ret_sp) 
1eea 23				inc hl 
1eeb 23				inc hl 
1eec 22 7f fb			ld (cli_ret_sp),hl 
1eef 73				ld (hl), e 
1ef0 23				inc hl 
1ef1 72				ld (hl), d 
1ef2 d1				pop de 
1ef3 e1				pop hl 
1ef4				if DEBUG_FORTH_STACK_GUARD 
1ef4 cd cc 6c				call check_stacks 
1ef7				endif 
1ef7 c9				ret 
1ef8			 
1ef8			; get current ret stack pointer and save to hl  
1ef8				 
1ef8			FORTH_RSP_TOS: macro 
1ef8				call macro_forth_rsp_tos 
1ef8				endm 
1ef8			 
1ef8			macro_forth_rsp_tos: 
1ef8				;push de 
1ef8 2a 7f fb			ld hl,(cli_ret_sp) 
1efb cd 33 1f			call loadhlptrtohl 
1efe				;ld e, (hl) 
1efe				;inc hl 
1efe				;ld d, (hl) 
1efe				;ex de, hl 
1efe					if DEBUG_FORTH_WORDS 
1efe			;			DMARK "RST" 
1efe						CALLMONITOR 
1efe cd c6 18			call break_point_state  
1f01				endm  
# End of macro CALLMONITOR
1f01					endif 
1f01				;pop de 
1f01 c9				ret 
1f02			 
1f02			; pop ret stack pointer 
1f02				 
1f02			FORTH_RSP_POP: macro 
1f02				call macro_forth_rsp_pop 
1f02				endm 
1f02			 
1f02			 
1f02			macro_forth_rsp_pop: 
1f02				if DEBUG_FORTH_STACK_GUARD 
1f02			;		DMARK "RPP" 
1f02 cd cc 6c				call check_stacks 
1f05					FORTH_CHK_RSP_UNDER 
1f05 e5				push hl 
1f06 d5				push de 
1f07 2a 7f fb			ld hl,(cli_ret_sp) 
1f0a 11 39 fb			ld de, cli_ret_stack 
1f0d cd 67 0f			call cmp16 
1f10 da e0 6d			jp c, fault_rsp_under 
1f13 d1				pop de 
1f14 e1				pop hl 
1f15				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f15				endif 
1f15 e5				push hl 
1f16 2a 7f fb			ld hl,(cli_ret_sp) 
1f19			 
1f19			 
1f19				if FORTH_ENABLE_FREE 
1f19			 
1f19					; get pointer 
1f19			 
1f19					push de 
1f19					push hl 
1f19			 
1f19					ld e, (hl) 
1f19					inc hl 
1f19					ld d, (hl) 
1f19			 
1f19					ex de, hl 
1f19					call free 
1f19			 
1f19					pop hl 
1f19					pop de 
1f19			 
1f19			 
1f19				endif 
1f19			 
1f19			 
1f19 2b				dec hl 
1f1a 2b				dec hl 
1f1b 22 7f fb			ld (cli_ret_sp), hl 
1f1e				; do stack underflow checks 
1f1e e1				pop hl 
1f1f				if DEBUG_FORTH_STACK_GUARD 
1f1f cd cc 6c				call check_stacks 
1f22					FORTH_CHK_RSP_UNDER 
1f22 e5				push hl 
1f23 d5				push de 
1f24 2a 7f fb			ld hl,(cli_ret_sp) 
1f27 11 39 fb			ld de, cli_ret_stack 
1f2a cd 67 0f			call cmp16 
1f2d da e0 6d			jp c, fault_rsp_under 
1f30 d1				pop de 
1f31 e1				pop hl 
1f32				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f32				endif 
1f32 c9				ret 
1f33			 
1f33			 
1f33			 
1f33			; routine to load word pointed to by hl into hl 
1f33			 
1f33			loadhlptrtohl: 
1f33			 
1f33 d5				push de 
1f34 5e				ld e, (hl) 
1f35 23				inc hl 
1f36 56				ld d, (hl) 
1f37 eb				ex de, hl 
1f38 d1				pop de 
1f39			 
1f39 c9				ret 
1f3a			 
1f3a			 
1f3a			 
1f3a			 
1f3a			 
1f3a			; push a number held in HL onto the data stack 
1f3a			; entry point for pushing a value when already in hl used in function above 
1f3a			 
1f3a			forth_push_numhl: 
1f3a			 
1f3a e5				push hl    ; save value to push 
1f3b			 
1f3b			if DEBUG_FORTH_PUSH 
1f3b				; see if disabled 
1f3b			 
1f3b			 
1f3b f5				push af 
1f3c 3a 3f f3			ld a, (os_view_disable) 
1f3f fe 2a			cp '*' 
1f41 28 34			jr z, .pskip2 
1f43 e5				push hl 
1f44 e5			push hl 
1f45 cd 15 0d			call clear_display 
1f48 e1			pop hl 
1f49 7c				ld a,h 
1f4a 21 53 f6			ld hl, os_word_scratch 
1f4d cd 4a 12			call hexout 
1f50 e1				pop hl 
1f51 7d				ld a,l 
1f52 21 55 f6			ld hl, os_word_scratch+2 
1f55 cd 4a 12			call hexout 
1f58			 
1f58 21 57 f6			ld hl, os_word_scratch+4 
1f5b 3e 00			ld a,0 
1f5d 77				ld (hl),a 
1f5e 11 53 f6			ld de,os_word_scratch 
1f61 3e 14				ld a, display_row_2 
1f63 cd 28 0d				call str_at_display 
1f66 11 68 58			ld de, .push_num 
1f69 3e 00			ld a, display_row_1 
1f6b			 
1f6b cd 28 0d				call str_at_display 
1f6e			 
1f6e			 
1f6e cd 38 0d			call update_display 
1f71 cd 92 0c			call delay1s 
1f74 cd 92 0c			call delay1s 
1f77			.pskip2:  
1f77			 
1f77 f1				pop af 
1f78			endif	 
1f78			 
1f78			 
1f78				FORTH_DSP_NEXT 
1f78 cd c9 1e			call macro_forth_dsp_next 
1f7b				endm 
# End of macro FORTH_DSP_NEXT
1f7b			 
1f7b 2a 7b fb			ld hl, (cli_data_sp) 
1f7e			 
1f7e				; save item type 
1f7e 3e 02			ld a,  DS_TYPE_INUM 
1f80 77				ld (hl), a 
1f81 23				inc hl 
1f82			 
1f82				; get word off stack 
1f82 d1				pop de 
1f83 7b				ld a,e 
1f84 77				ld (hl), a 
1f85 23				inc hl 
1f86 7a				ld a,d 
1f87 77				ld (hl), a 
1f88			 
1f88			if DEBUG_FORTH_PUSH 
1f88 2b				dec hl 
1f89 2b				dec hl 
1f8a 2b				dec hl 
1f8b						DMARK "PH5" 
1f8b f5				push af  
1f8c 3a a0 1f			ld a, (.dmark)  
1f8f 32 b4 fe			ld (debug_mark),a  
1f92 3a a1 1f			ld a, (.dmark+1)  
1f95 32 b5 fe			ld (debug_mark+1),a  
1f98 3a a2 1f			ld a, (.dmark+2)  
1f9b 32 b6 fe			ld (debug_mark+2),a  
1f9e 18 03			jr .pastdmark  
1fa0 ..			.dmark: db "PH5"  
1fa3 f1			.pastdmark: pop af  
1fa4			endm  
# End of macro DMARK
1fa4				CALLMONITOR 
1fa4 cd c6 18			call break_point_state  
1fa7				endm  
# End of macro CALLMONITOR
1fa7			endif	 
1fa7			 
1fa7 c9				ret 
1fa8			 
1fa8			 
1fa8			; Push a string to stack pointed to by hl 
1fa8			 
1fa8			forth_push_str: 
1fa8			 
1fa8			if DEBUG_FORTH_PUSH 
1fa8						DMARK "PSQ" 
1fa8 f5				push af  
1fa9 3a bd 1f			ld a, (.dmark)  
1fac 32 b4 fe			ld (debug_mark),a  
1faf 3a be 1f			ld a, (.dmark+1)  
1fb2 32 b5 fe			ld (debug_mark+1),a  
1fb5 3a bf 1f			ld a, (.dmark+2)  
1fb8 32 b6 fe			ld (debug_mark+2),a  
1fbb 18 03			jr .pastdmark  
1fbd ..			.dmark: db "PSQ"  
1fc0 f1			.pastdmark: pop af  
1fc1			endm  
# End of macro DMARK
1fc1				CALLMONITOR 
1fc1 cd c6 18			call break_point_state  
1fc4				endm  
# End of macro CALLMONITOR
1fc4			endif	 
1fc4			    
1fc4 e5				push hl 
1fc5 e5				push hl 
1fc6			 
1fc6			;	ld a, 0   ; find end of string 
1fc6 cd a7 13			call strlenz 
1fc9			if DEBUG_FORTH_PUSH 
1fc9						DMARK "PQ2" 
1fc9 f5				push af  
1fca 3a de 1f			ld a, (.dmark)  
1fcd 32 b4 fe			ld (debug_mark),a  
1fd0 3a df 1f			ld a, (.dmark+1)  
1fd3 32 b5 fe			ld (debug_mark+1),a  
1fd6 3a e0 1f			ld a, (.dmark+2)  
1fd9 32 b6 fe			ld (debug_mark+2),a  
1fdc 18 03			jr .pastdmark  
1fde ..			.dmark: db "PQ2"  
1fe1 f1			.pastdmark: pop af  
1fe2			endm  
# End of macro DMARK
1fe2				CALLMONITOR 
1fe2 cd c6 18			call break_point_state  
1fe5				endm  
# End of macro CALLMONITOR
1fe5			endif	 
1fe5 eb				ex de, hl 
1fe6 e1				pop hl   ; get ptr to start of string 
1fe7			if DEBUG_FORTH_PUSH 
1fe7						DMARK "PQ3" 
1fe7 f5				push af  
1fe8 3a fc 1f			ld a, (.dmark)  
1feb 32 b4 fe			ld (debug_mark),a  
1fee 3a fd 1f			ld a, (.dmark+1)  
1ff1 32 b5 fe			ld (debug_mark+1),a  
1ff4 3a fe 1f			ld a, (.dmark+2)  
1ff7 32 b6 fe			ld (debug_mark+2),a  
1ffa 18 03			jr .pastdmark  
1ffc ..			.dmark: db "PQ3"  
1fff f1			.pastdmark: pop af  
2000			endm  
# End of macro DMARK
2000				CALLMONITOR 
2000 cd c6 18			call break_point_state  
2003				endm  
# End of macro CALLMONITOR
2003			endif	 
2003 19				add hl,de 
2004			if DEBUG_FORTH_PUSH 
2004						DMARK "PQE" 
2004 f5				push af  
2005 3a 19 20			ld a, (.dmark)  
2008 32 b4 fe			ld (debug_mark),a  
200b 3a 1a 20			ld a, (.dmark+1)  
200e 32 b5 fe			ld (debug_mark+1),a  
2011 3a 1b 20			ld a, (.dmark+2)  
2014 32 b6 fe			ld (debug_mark+2),a  
2017 18 03			jr .pastdmark  
2019 ..			.dmark: db "PQE"  
201c f1			.pastdmark: pop af  
201d			endm  
# End of macro DMARK
201d				CALLMONITOR 
201d cd c6 18			call break_point_state  
2020				endm  
# End of macro CALLMONITOR
2020			endif	 
2020			 
2020 2b				dec hl    ; see if there is an optional trailing double quote 
2021 7e				ld a,(hl) 
2022 fe 22			cp '"' 
2024 20 03			jr nz, .strnoq 
2026 3e 00			ld a, 0      ; get rid of double quote 
2028 77				ld (hl), a 
2029 23			.strnoq: inc hl 
202a			 
202a 3e 00			ld a, 0 
202c 77				ld (hl), a     ; add null term and get rid of trailing double quote 
202d			 
202d 13				inc de ; add one for the type string 
202e 13				inc de ; add one for null term??? 
202f			 
202f				; tos is get string pointer again 
202f				; de contains space to allocate 
202f				 
202f d5				push de 
2030			 
2030 eb				ex de, hl 
2031			 
2031				;push af 
2031			 
2031			if DEBUG_FORTH_PUSH 
2031						DMARK "PHm" 
2031 f5				push af  
2032 3a 46 20			ld a, (.dmark)  
2035 32 b4 fe			ld (debug_mark),a  
2038 3a 47 20			ld a, (.dmark+1)  
203b 32 b5 fe			ld (debug_mark+1),a  
203e 3a 48 20			ld a, (.dmark+2)  
2041 32 b6 fe			ld (debug_mark+2),a  
2044 18 03			jr .pastdmark  
2046 ..			.dmark: db "PHm"  
2049 f1			.pastdmark: pop af  
204a			endm  
# End of macro DMARK
204a				CALLMONITOR 
204a cd c6 18			call break_point_state  
204d				endm  
# End of macro CALLMONITOR
204d			endif	 
204d cd 10 14			call malloc	; on ret hl now contains allocated memory 
2050				if DEBUG_FORTH_MALLOC_GUARD 
2050 cc c0 58				call z,malloc_error 
2053				endif 
2053			 
2053				 
2053 c1				pop bc    ; get length 
2054 d1				pop de   ;  get string start    
2055			 
2055				; hl has destination from malloc 
2055			 
2055 eb				ex de, hl    ; prep for ldir 
2056			 
2056 d5				push de   ; save malloc area for DSP later 
2057				;push hl   ; save malloc area for DSP later 
2057			 
2057			if DEBUG_FORTH_PUSH 
2057						DMARK "PHc" 
2057 f5				push af  
2058 3a 6c 20			ld a, (.dmark)  
205b 32 b4 fe			ld (debug_mark),a  
205e 3a 6d 20			ld a, (.dmark+1)  
2061 32 b5 fe			ld (debug_mark+1),a  
2064 3a 6e 20			ld a, (.dmark+2)  
2067 32 b6 fe			ld (debug_mark+2),a  
206a 18 03			jr .pastdmark  
206c ..			.dmark: db "PHc"  
206f f1			.pastdmark: pop af  
2070			endm  
# End of macro DMARK
2070				CALLMONITOR 
2070 cd c6 18			call break_point_state  
2073				endm  
# End of macro CALLMONITOR
2073			endif	 
2073			 
2073			 
2073 ed b0			ldir 
2075			 
2075			 
2075				; push malloc to data stack     macro?????  
2075			 
2075				FORTH_DSP_NEXT 
2075 cd c9 1e			call macro_forth_dsp_next 
2078				endm 
# End of macro FORTH_DSP_NEXT
2078			 
2078				; save value and type 
2078			 
2078 2a 7b fb			ld hl, (cli_data_sp) 
207b			 
207b				; save item type 
207b 3e 01			ld a,  DS_TYPE_STR 
207d 77				ld (hl), a 
207e 23				inc hl 
207f			 
207f				; get malloc word off stack 
207f d1				pop de 
2080 73				ld (hl), e 
2081 23				inc hl 
2082 72				ld (hl), d 
2083			 
2083			 
2083			 
2083			if DEBUG_FORTH_PUSH 
2083 2a 7b fb			ld hl, (cli_data_sp) 
2086						DMARK "PHS" 
2086 f5				push af  
2087 3a 9b 20			ld a, (.dmark)  
208a 32 b4 fe			ld (debug_mark),a  
208d 3a 9c 20			ld a, (.dmark+1)  
2090 32 b5 fe			ld (debug_mark+1),a  
2093 3a 9d 20			ld a, (.dmark+2)  
2096 32 b6 fe			ld (debug_mark+2),a  
2099 18 03			jr .pastdmark  
209b ..			.dmark: db "PHS"  
209e f1			.pastdmark: pop af  
209f			endm  
# End of macro DMARK
209f				CALLMONITOR 
209f cd c6 18			call break_point_state  
20a2				endm  
# End of macro CALLMONITOR
20a2			;	ex de,hl 
20a2			endif	 
20a2				; in case of spaces, skip the ptr past the copied string 
20a2				;pop af 
20a2				;ld (cli_origptr),hl 
20a2			 
20a2 c9				ret 
20a3			 
20a3			 
20a3			 
20a3			; TODO ascii push input onto stack given hl to start of input 
20a3			 
20a3			; identify type 
20a3			; if starts with a " then a string 
20a3			; otherwise it is a number 
20a3			;  
20a3			; if a string 
20a3			;     scan for ending " to get length of string to malloc for + 1 
20a3			;     malloc 
20a3			;     put pointer to string on stack first byte flags as string 
20a3			; 
20a3			; else a number 
20a3			;    look for number format identifier 
20a3			;    $xx hex 
20a3			;    %xxxxx bin 
20a3			;    xxxxx decimal 
20a3			;    convert number to 16bit word.  
20a3			;    malloc word + 1 with flag to identiy as num 
20a3			;    put pointer to number on stack 
20a3			;   
20a3			;  
20a3			  
20a3			forth_apush: 
20a3				; kernel push 
20a3			 
20a3			if DEBUG_FORTH_PUSH 
20a3						DMARK "PSH" 
20a3 f5				push af  
20a4 3a b8 20			ld a, (.dmark)  
20a7 32 b4 fe			ld (debug_mark),a  
20aa 3a b9 20			ld a, (.dmark+1)  
20ad 32 b5 fe			ld (debug_mark+1),a  
20b0 3a ba 20			ld a, (.dmark+2)  
20b3 32 b6 fe			ld (debug_mark+2),a  
20b6 18 03			jr .pastdmark  
20b8 ..			.dmark: db "PSH"  
20bb f1			.pastdmark: pop af  
20bc			endm  
# End of macro DMARK
20bc				CALLMONITOR 
20bc cd c6 18			call break_point_state  
20bf				endm  
# End of macro CALLMONITOR
20bf			endif	 
20bf				; identify input type 
20bf			 
20bf 7e				ld a,(hl) 
20c0 fe 22			cp '"' 
20c2 28 0a			jr z, .fapstr 
20c4 fe 24			cp '$' 
20c6 ca ee 20			jp z, .faphex 
20c9 fe 25			cp '%' 
20cb ca d6 20			jp z, .fapbin 
20ce			;	cp 'b' 
20ce			;	jp z, .fabin 
20ce				; else decimal 
20ce			 
20ce				; TODO do decimal conversion 
20ce				; decimal is stored as a 16bit word 
20ce			 
20ce				; by default everything is a string if type is not detected 
20ce			.fapstr: ; 
20ce fe 22			cp '"' 
20d0 20 01			jr nz, .strnoqu 
20d2 23				inc hl 
20d3			.strnoqu: 
20d3 c3 a8 1f			jp forth_push_str 
20d6			 
20d6			 
20d6			 
20d6			.fapbin:    ; push a binary string.  
20d6 11 00 00			ld de, 0   ; hold a 16bit value 
20d9			 
20d9 23			.fapbinshift:	inc hl  
20da 7e				ld a,(hl) 
20db fe 00			cp 0     ; done scanning  
20dd 28 0b			jr z, .fapbdone  	; got it in HL so push  
20df			 
20df				; left shift de 
20df eb				ex de, hl	 
20e0 29				add hl, hl 
20e1			 
20e1				; is 1 
20e1 fe 31			cp '1' 
20e3 20 02			jr nz, .binzero 
20e5 cb 4d			bit 1, l 
20e7			.binzero: 
20e7 eb				ex de, hl	 ; save current de 
20e8 18 ef			jr .fapbinshift 
20ea			 
20ea			.fapbdone: 
20ea eb				ex de, hl 
20eb c3 3a 1f			jp forth_push_numhl 
20ee			 
20ee			 
20ee			.faphex:   ; hex is always stored as a 16bit word 
20ee				; skip number prefix 
20ee 23				inc hl 
20ef				; turn ascii into number 
20ef cd 00 13			call get_word_hl	; ret 16bit word in hl 
20f2			 
20f2 c3 3a 1f			jp forth_push_numhl 
20f5			 
20f5 00				 nop 
20f6			 
20f6			.fabin:   ; TODO bin conversion 
20f6			 
20f6			 
20f6 c9				ret 
20f7			 
20f7			 
20f7			; get either a string ptr or a 16bit word from the data stack 
20f7			 
20f7			FORTH_DSP: macro 
20f7				call macro_forth_dsp 
20f7				endm 
20f7			 
20f7			macro_forth_dsp: 
20f7				; data stack pointer points to current word on tos 
20f7			 
20f7 2a 7b fb			ld hl,(cli_data_sp) 
20fa			 
20fa				if DEBUG_FORTH_PUSH 
20fa						DMARK "DSP" 
20fa f5				push af  
20fb 3a 0f 21			ld a, (.dmark)  
20fe 32 b4 fe			ld (debug_mark),a  
2101 3a 10 21			ld a, (.dmark+1)  
2104 32 b5 fe			ld (debug_mark+1),a  
2107 3a 11 21			ld a, (.dmark+2)  
210a 32 b6 fe			ld (debug_mark+2),a  
210d 18 03			jr .pastdmark  
210f ..			.dmark: db "DSP"  
2112 f1			.pastdmark: pop af  
2113			endm  
# End of macro DMARK
2113			 
2113 cd f5 58				call display_data_sp 
2116				;call break_point_state 
2116				;rst 030h 
2116				CALLMONITOR 
2116 cd c6 18			call break_point_state  
2119				endm  
# End of macro CALLMONITOR
2119				endif 
2119			 
2119 c9				ret 
211a			 
211a			; return hl to start of value on stack 
211a			 
211a			FORTH_DSP_VALUE: macro 
211a				call macro_forth_dsp_value 
211a				endm 
211a			 
211a			macro_forth_dsp_value: 
211a			 
211a				FORTH_DSP 
211a cd f7 20			call macro_forth_dsp 
211d				endm 
# End of macro FORTH_DSP
211d			 
211d d5				push de 
211e			 
211e 23				inc hl ; skip type 
211f			 
211f 5e				ld e, (hl) 
2120 23				inc hl 
2121 56				ld d, (hl) 
2122 eb				ex de,hl  
2123			 
2123 d1				pop de 
2124			 
2124 c9				ret 
2125			 
2125			; return hl to start of value to second item on stack 
2125			 
2125			FORTH_DSP_VALUEM1: macro 
2125				call macro_forth_dsp_value_m1 
2125				endm 
2125			 
2125			macro_forth_dsp_value_m1: 
2125			 
2125				FORTH_DSP 
2125 cd f7 20			call macro_forth_dsp 
2128				endm 
# End of macro FORTH_DSP
2128			 
2128 2b				dec hl 
2129 2b				dec hl 
212a			;	dec hl 
212a			 
212a d5				push de 
212b			 
212b 5e				ld e, (hl) 
212c 23				inc hl 
212d 56				ld d, (hl) 
212e eb				ex de,hl  
212f			 
212f d1				pop de 
2130			 
2130 c9				ret 
2131			 
2131				 
2131			 
2131			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
2131			 
2131			FORTH_DSP_POP: macro 
2131				call macro_forth_dsp_pop 
2131				endm 
2131			 
2131			 
2131			; get the tos data type 
2131			 
2131			FORTH_DSP_TYPE:   macro 
2131			 
2131				;FORTH_DSP_VALUE 
2131				FORTH_DSP 
2131				 
2131				; hl points to value 
2131				; check type 
2131			 
2131				ld a,(hl) 
2131			 
2131				endm 
2131			 
2131			; load the tos value into hl 
2131			 
2131			 
2131			FORTH_DSP_VALUEHL:  macro 
2131				call macro_dsp_valuehl 
2131				endm 
2131			 
2131			 
2131			 
2131			macro_dsp_valuehl: 
2131				FORTH_DSP_VALUE 
2131 cd 1a 21			call macro_forth_dsp_value 
2134				endm 
# End of macro FORTH_DSP_VALUE
2134			 
2134				;FORTH_ERR_TOS_NOTNUM 
2134			 
2134				;inc hl   ; skip type id 
2134			 
2134			;	push de 
2134			; 
2134			;	ld e, (hl) 
2134			;	inc hl 
2134			;	ld d, (hl) 
2134			;	ex de,hl  
2134			 
2134			;	pop de 
2134			 
2134				if DEBUG_FORTH_PUSH 
2134						DMARK "DVL" 
2134 f5				push af  
2135 3a 49 21			ld a, (.dmark)  
2138 32 b4 fe			ld (debug_mark),a  
213b 3a 4a 21			ld a, (.dmark+1)  
213e 32 b5 fe			ld (debug_mark+1),a  
2141 3a 4b 21			ld a, (.dmark+2)  
2144 32 b6 fe			ld (debug_mark+2),a  
2147 18 03			jr .pastdmark  
2149 ..			.dmark: db "DVL"  
214c f1			.pastdmark: pop af  
214d			endm  
# End of macro DMARK
214d				CALLMONITOR 
214d cd c6 18			call break_point_state  
2150				endm  
# End of macro CALLMONITOR
2150				endif 
2150 c9				ret 
2151			 
2151			forth_apushstrhl:      
2151				; push of string requires use of cli_origptr 
2151				; bodge use 
2151			 
2151				; get current cli_origptr, save, update with temp pointer  
2151 ed 5b cb fb		ld de, (cli_origptr) 
2155 22 cb fb			ld (cli_origptr), hl 
2158 d5				push de 
2159 cd a3 20			call forth_apush 
215c d1				pop de 
215d ed 53 cb fb		ld (cli_origptr), de 
2161 c9			        ret	 
2162			 
2162			 
2162			; increase loop stack pointer and save hl to it 
2162				 
2162			FORTH_LOOP_NEXT: macro 
2162				call macro_forth_loop_next 
2162				;nop 
2162				endm 
2162			 
2162			macro_forth_loop_next: 
2162				if DEBUG_FORTH_STACK_GUARD 
2162 cd cc 6c				call check_stacks 
2165				endif 
2165 e5				push hl 
2166 d5				push de 
2167 eb				ex de,hl 
2168 2a 7d fb			ld hl,(cli_loop_sp) 
216b 23				inc hl 
216c 23				inc hl 
216d					if DEBUG_FORTH_WORDS 
216d						DMARK "LNX" 
216d f5				push af  
216e 3a 82 21			ld a, (.dmark)  
2171 32 b4 fe			ld (debug_mark),a  
2174 3a 83 21			ld a, (.dmark+1)  
2177 32 b5 fe			ld (debug_mark+1),a  
217a 3a 84 21			ld a, (.dmark+2)  
217d 32 b6 fe			ld (debug_mark+2),a  
2180 18 03			jr .pastdmark  
2182 ..			.dmark: db "LNX"  
2185 f1			.pastdmark: pop af  
2186			endm  
# End of macro DMARK
2186						CALLMONITOR 
2186 cd c6 18			call break_point_state  
2189				endm  
# End of macro CALLMONITOR
2189					endif 
2189 22 7d fb			ld (cli_loop_sp),hl 
218c 73				ld (hl), e 
218d 23				inc hl 
218e 72				ld (hl), d 
218f d1				pop de    ; been reversed so save a swap on restore 
2190 e1				pop hl 
2191				if DEBUG_FORTH_STACK_GUARD 
2191 cd cc 6c				call check_stacks 
2194				endif 
2194 c9				ret 
2195			 
2195			; get current ret stack pointer and save to hl  
2195				 
2195			FORTH_LOOP_TOS: macro 
2195				call macro_forth_loop_tos 
2195				endm 
2195			 
2195			macro_forth_loop_tos: 
2195 d5				push de 
2196 2a 7d fb			ld hl,(cli_loop_sp) 
2199 5e				ld e, (hl) 
219a 23				inc hl 
219b 56				ld d, (hl) 
219c eb				ex de, hl 
219d d1				pop de 
219e c9				ret 
219f			 
219f			; pop loop stack pointer 
219f				 
219f			FORTH_LOOP_POP: macro 
219f				call macro_forth_loop_pop 
219f				endm 
219f			 
219f			 
219f			macro_forth_loop_pop: 
219f				if DEBUG_FORTH_STACK_GUARD 
219f					DMARK "LPP" 
219f f5				push af  
21a0 3a b4 21			ld a, (.dmark)  
21a3 32 b4 fe			ld (debug_mark),a  
21a6 3a b5 21			ld a, (.dmark+1)  
21a9 32 b5 fe			ld (debug_mark+1),a  
21ac 3a b6 21			ld a, (.dmark+2)  
21af 32 b6 fe			ld (debug_mark+2),a  
21b2 18 03			jr .pastdmark  
21b4 ..			.dmark: db "LPP"  
21b7 f1			.pastdmark: pop af  
21b8			endm  
# End of macro DMARK
21b8 cd cc 6c				call check_stacks 
21bb					FORTH_CHK_LOOP_UNDER 
21bb e5				push hl 
21bc d5				push de 
21bd 2a 7d fb			ld hl,(cli_loop_sp) 
21c0 11 b7 fa			ld de, cli_loop_stack 
21c3 cd 67 0f			call cmp16 
21c6 da e6 6d			jp c, fault_loop_under 
21c9 d1				pop de 
21ca e1				pop hl 
21cb				endm 
# End of macro FORTH_CHK_LOOP_UNDER
21cb				endif 
21cb e5				push hl 
21cc 2a 7d fb			ld hl,(cli_loop_sp) 
21cf 2b				dec hl 
21d0 2b				dec hl 
21d1 22 7d fb			ld (cli_loop_sp), hl 
21d4				; TODO do stack underflow checks 
21d4 e1				pop hl 
21d5				if DEBUG_FORTH_STACK_GUARD 
21d5 cd cc 6c				call check_stacks 
21d8					FORTH_CHK_LOOP_UNDER 
21d8 e5				push hl 
21d9 d5				push de 
21da 2a 7d fb			ld hl,(cli_loop_sp) 
21dd 11 b7 fa			ld de, cli_loop_stack 
21e0 cd 67 0f			call cmp16 
21e3 da e6 6d			jp c, fault_loop_under 
21e6 d1				pop de 
21e7 e1				pop hl 
21e8				endm 
# End of macro FORTH_CHK_LOOP_UNDER
21e8				endif 
21e8 c9				ret 
21e9			 
21e9			macro_forth_dsp_pop: 
21e9			 
21e9 e5				push hl 
21ea			 
21ea				; release malloc data 
21ea			 
21ea				if DEBUG_FORTH_STACK_GUARD 
21ea cd cc 6c				call check_stacks 
21ed					FORTH_CHK_DSP_UNDER 
21ed e5				push hl 
21ee d5				push de 
21ef 2a 7b fb			ld hl,(cli_data_sp) 
21f2 11 b5 f8			ld de, cli_data_stack 
21f5 cd 67 0f			call cmp16 
21f8 da da 6d			jp c, fault_dsp_under 
21fb d1				pop de 
21fc e1				pop hl 
21fd				endm 
# End of macro FORTH_CHK_DSP_UNDER
21fd				endif 
21fd				;ld hl,(cli_data_sp) 
21fd			if DEBUG_FORTH_DOT 
21fd				DMARK "DPP" 
21fd f5				push af  
21fe 3a 12 22			ld a, (.dmark)  
2201 32 b4 fe			ld (debug_mark),a  
2204 3a 13 22			ld a, (.dmark+1)  
2207 32 b5 fe			ld (debug_mark+1),a  
220a 3a 14 22			ld a, (.dmark+2)  
220d 32 b6 fe			ld (debug_mark+2),a  
2210 18 03			jr .pastdmark  
2212 ..			.dmark: db "DPP"  
2215 f1			.pastdmark: pop af  
2216			endm  
# End of macro DMARK
2216				CALLMONITOR 
2216 cd c6 18			call break_point_state  
2219				endm  
# End of macro CALLMONITOR
2219			endif	 
2219			 
2219			 
2219			if FORTH_ENABLE_DSPPOPFREE 
2219			 
2219				FORTH_DSP 
2219 cd f7 20			call macro_forth_dsp 
221c				endm 
# End of macro FORTH_DSP
221c			 
221c 7e				ld a, (hl) 
221d fe 01			cp DS_TYPE_STR 
221f 20 23			jr nz, .skippopfree 
2221			 
2221				FORTH_DSP_VALUEHL 
2221 cd 31 21			call macro_dsp_valuehl 
2224				endm 
# End of macro FORTH_DSP_VALUEHL
2224 00				nop 
2225			if DEBUG_FORTH_DOT 
2225				DMARK "DPf" 
2225 f5				push af  
2226 3a 3a 22			ld a, (.dmark)  
2229 32 b4 fe			ld (debug_mark),a  
222c 3a 3b 22			ld a, (.dmark+1)  
222f 32 b5 fe			ld (debug_mark+1),a  
2232 3a 3c 22			ld a, (.dmark+2)  
2235 32 b6 fe			ld (debug_mark+2),a  
2238 18 03			jr .pastdmark  
223a ..			.dmark: db "DPf"  
223d f1			.pastdmark: pop af  
223e			endm  
# End of macro DMARK
223e				CALLMONITOR 
223e cd c6 18			call break_point_state  
2241				endm  
# End of macro CALLMONITOR
2241			endif	 
2241 cd da 14			call free 
2244			.skippopfree: 
2244				 
2244			 
2244			endif 
2244			 
2244			if DEBUG_FORTH_DOT_KEY 
2244				DMARK "DP2" 
2244				CALLMONITOR 
2244			endif	 
2244			 
2244				; move pointer down 
2244			 
2244 2a 7b fb			ld hl,(cli_data_sp) 
2247 2b				dec hl 
2248 2b				dec hl 
2249			; PARSEV5 
2249 2b				dec hl 
224a 22 7b fb			ld (cli_data_sp), hl 
224d			 
224d				if DEBUG_FORTH_STACK_GUARD 
224d cd cc 6c				call check_stacks 
2250					FORTH_CHK_DSP_UNDER 
2250 e5				push hl 
2251 d5				push de 
2252 2a 7b fb			ld hl,(cli_data_sp) 
2255 11 b5 f8			ld de, cli_data_stack 
2258 cd 67 0f			call cmp16 
225b da da 6d			jp c, fault_dsp_under 
225e d1				pop de 
225f e1				pop hl 
2260				endm 
# End of macro FORTH_CHK_DSP_UNDER
2260				endif 
2260			 
2260 e1				pop hl 
2261			 
2261 c9				ret 
2262			 
2262			getwordathl: 
2262				; hl points to an address 
2262				; load hl with the word at that address 
2262			 
2262 d5				push de 
2263			 
2263 5e				ld e, (hl) 
2264 23				inc hl 
2265 56				ld d, (hl) 
2266 eb				ex de, hl 
2267			 
2267 d1				pop de 
2268 c9				ret 
2269			 
2269			 
2269			 
2269			 
2269			 
2269			; eof 
2269			 
# End of file forth_stackopsv5.asm
2269			endif 
2269			 
2269			user_word_eol:  
2269				; hl contains the pointer to where to create a linked list item from the end 
2269				; of the user dict to continue on at the system word dict 
2269				 
2269				; poke the stub of the word list linked list to repoint to rom words 
2269			 
2269				; stub format 
2269				; db   word id 
2269				; dw    link to next word 
2269			        ; db char length of token 
2269				; db string + 0 term 
2269				; db exec code....  
2269			 
2269 3e 00			ld a, WORD_SYS_ROOT     ; root word 
226b 77				ld (hl), a		; word id 
226c 23				inc hl 
226d			 
226d 11 38 24			ld de, sysdict 
2270 73				ld (hl), e		; next word link ie system dict 
2271 23				inc hl 
2272 72				ld (hl), d		; next word link ie system dict 
2273 23				inc hl	 
2274			 
2274			;	ld (hl), sysdict		; next word link ie system dict 
2274			;	inc hl 
2274			;	inc hl 
2274			 
2274			;	inc hl 
2274			;	inc hl 
2274			 
2274 3e 02			ld a, 2			; word length is 0 
2276 77				ld (hl), a	 
2277 23				inc hl 
2278			 
2278 3e 7e			ld a, '~'			; word length is 0 
227a 77				ld (hl), a	 
227b 23				inc hl 
227c 3e 00			ld a, 0			; save empty word 
227e 77				ld (hl), a 
227f			 
227f c9				ret 
2280			 
2280				 
2280			 
2280			forthexec_cleanup: 
2280				FORTH_RSP_POP 
2280 cd 02 1f			call macro_forth_rsp_pop 
2283				endm 
# End of macro FORTH_RSP_POP
2283 c9				ret 
2284			 
2284			forth_call_hl: 
2284				; taking hl 
2284 e5				push hl 
2285 c9				ret 
2286			 
2286			; this is called to reset Forth system but keep existing uwords etc 
2286			 
2286			forth_warmstart: 
2286				; setup stack over/under flow checks 
2286				if DEBUG_FORTH_STACK_GUARD 
2286 cd b2 6c				call chk_stk_init 
2289				endif 
2289			 
2289				; init stack pointers  - * these stacks go upwards *  
2289 21 39 fb			ld hl, cli_ret_stack 
228c 22 7f fb			ld (cli_ret_sp), hl	 
228f				; set bottom of stack 
228f 3e 00			ld a,0 
2291 77				ld (hl),a 
2292 23				inc hl 
2293 77				ld (hl),a 
2294			 
2294 21 b5 f8			ld hl, cli_data_stack 
2297 22 7b fb			ld (cli_data_sp), hl	 
229a				; set bottom of stack 
229a 3e 00			ld a,0 
229c 77				ld (hl),a 
229d 23				inc hl 
229e 77				ld (hl),a 
229f			 
229f 21 b7 fa			ld hl, cli_loop_stack 
22a2 22 7d fb			ld (cli_loop_sp), hl	 
22a5				; set bottom of stack 
22a5 3e 00			ld a,0 
22a7 77				ld (hl),a 
22a8 23				inc hl 
22a9 77				ld (hl),a 
22aa			 
22aa				; init extent of current open file 
22aa			 
22aa 3e 00			ld a, 0 
22ac 32 f7 fb			ld (store_openext), a 
22af			 
22af c9				ret 
22b0			 
22b0			 
22b0			; Cold Start - this is called to setup the whole Forth system 
22b0			 
22b0			forth_init: 
22b0			 
22b0				; setup stack over/under flow checks 
22b0			 
22b0			;	if DEBUG_FORTH_STACK_GUARD 
22b0			;		call chk_stk_init 
22b0			;	endif 
22b0			 
22b0				; enable auto display updates (slow.....) 
22b0			 
22b0 3e 01			ld a, 1 
22b2 32 c9 fb			ld (cli_autodisplay), a 
22b5			 
22b5				; if storage is in use disable long reads for now 
22b5 3e 00			ld a, 0 
22b7 32 02 fc			ld (store_longread), a 
22ba			 
22ba			 
22ba				; show start up screen 
22ba			 
22ba cd 15 0d			call clear_display 
22bd			 
22bd 3e 00			ld a,0 
22bf 32 eb fb			ld (f_cursor_ptr), a 
22c2			 
22c2				; set start of word list in start of ram - for use when creating user words 
22c2			 
22c2 21 00 80			ld hl, baseram 
22c5 22 4b f6			ld (os_last_new_uword), hl 
22c8 cd 69 22			call user_word_eol 
22cb				 
22cb			;		call display_data_sp 
22cb			;		call next_page_prompt 
22cb			 
22cb			 
22cb			 
22cb			 
22cb c9				ret 
22cc			 
22cc .. 00		.bootforth: db " Forth Kernel Init ",0 
22e0			 
22e0			; TODO push to stack 
22e0			 
22e0			;  
22e0			 
22e0			if FORTH_PARSEV2 
22e0			 
22e0			 
22e0				include "forth_parserv2.asm" 
22e0			 
22e0			endif 
22e0			 
22e0			 
22e0			; parse cli version 1 
22e0			 
22e0			if FORTH_PARSEV1 
22e0			 
22e0			 
22e0			 
22e0			      include "forth_parserv1.asm" 
22e0			endif 
22e0				 
22e0			if FORTH_PARSEV3 
22e0			 
22e0			 
22e0			 
22e0			      include "forth_parserv3.asm" 
22e0				include "forth_wordsv3.asm" 
22e0			endif 
22e0			 
22e0			if FORTH_PARSEV4 
22e0			 
22e0			 
22e0			 
22e0			      include "forth_parserv4.asm" 
22e0				include "forth_wordsv4.asm" 
22e0			endif 
22e0			 
22e0			if FORTH_PARSEV5 
22e0			 
22e0			 
22e0			 
22e0			      include "forth_parserv5.asm" 
22e0			 
22e0			 
22e0			; A better parser without using malloc and string copies all over the place.  
22e0			; Exec in situ should be faster 
22e0			 
22e0			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
22e0			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
22e0			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
22e0			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
22e0			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
22e0			WORD_SYS_END: equ 0   ; Opcode for all user words 
22e0			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
22e0			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
22e0			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
22e0			 
22e0			; Core word preamble macro 
22e0			 
22e0			CWHEAD:   macro nxtword opcode lit len opflags 
22e0				db WORD_SYS_CORE+opcode             
22e0				; internal op code number 
22e0				dw nxtword            
22e0				; link to next dict word block 
22e0				db len + 1 
22e0				; literal length of dict word inc zero term 
22e0				db lit,0              
22e0				; literal dict word 
22e0			        ; TODO db opflags        
22e0				endm 
22e0			 
22e0			 
22e0			NEXTW: macro  
22e0				jp macro_next 
22e0				endm 
22e0			 
22e0			macro_next: 
22e0			if DEBUG_FORTH_PARSE_KEY 
22e0				DMARK "NXT" 
22e0				CALLMONITOR 
22e0			endif	 
22e0			;	inc hl  ; skip token null term  
22e0 ed 4b cd fb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
22e4 ed 5b cb fb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
22e8 2a 4f f6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
22eb			if DEBUG_FORTH_PARSE_KEY 
22eb				DMARK "}AA" 
22eb				CALLMONITOR 
22eb			endif	 
22eb c3 ee 23			jp execnext 
22ee				;jp exec1 
22ee			       
22ee			 
22ee			 
22ee			; Another go at the parser to compile  
22ee			 
22ee			 
22ee			; TODO rework parser to change all of the string words to byte tokens 
22ee			; TODO do a search for  
22ee			 
22ee			; TODO first run normal parser to zero term sections 
22ee			; TODO for each word do a token look up to get the op code 
22ee			; TODO need some means to flag to the exec that this is a byte code form    
22ee			 
22ee			 
22ee			forthcompile: 
22ee			 
22ee			; 
22ee			; line parse: 
22ee			;       parse raw input buffer 
22ee			;       tokenise the words 
22ee			;       malloc new copy (for looping etc) 
22ee			;       copy to malloc + current pc in line to start of string and add line term 
22ee			;       save on new rsp 
22ee			; 
22ee			 
22ee			; hl to point to the line to tokenise 
22ee			 
22ee			;	push hl 
22ee 22 4f f6			ld (os_tok_ptr), hl  ; save ptr to string 
22f1			 
22f1			;	ld a,0		; string term on input 
22f1			;	call strlent 
22f1			 
22f1			;	ld (os_tok_len), hl	 ; save string length 
22f1			 
22f1			;if DEBUG_FORTH_TOK 
22f1			;	ex de,hl		 
22f1			;endif 
22f1			 
22f1			;	pop hl 		; get back string pointer 
22f1			 
22f1			if DEBUG_FORTH_TOK 
22f1						DMARK "TOc" 
22f1				CALLMONITOR 
22f1			endif 
22f1 7e			.cptoken2:    ld a,(hl) 
22f2 23				inc hl 
22f3 fe 7f			cp FORTH_END_BUFFER 
22f5 28 29			jr z, .cptokendone2 
22f7 fe 00			cp 0 
22f9 28 25			jr z, .cptokendone2 
22fb fe 22			cp '"' 
22fd 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
22ff fe 20			cp ' ' 
2301 20 ee			jr nz,  .cptoken2 
2303			 
2303			; TODO consume comments held between ( and ) 
2303			 
2303				; we have a space so change to zero term for dict match later 
2303 2b				dec hl 
2304 3e 00			ld a,0 
2306 77				ld (hl), a 
2307 23				inc hl 
2308 18 e7			jr .cptoken2 
230a				 
230a			 
230a			.cptokenstr2: 
230a				; skip all white space until either eol (because forgot to term) or end double quote 
230a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
230a				;inc hl ; skip current double quote 
230a 7e				ld a,(hl) 
230b 23				inc hl 
230c fe 22			cp '"' 
230e 28 e1			jr z, .cptoken2 
2310 fe 7f			cp FORTH_END_BUFFER 
2312 28 0c			jr z, .cptokendone2 
2314 fe 00			cp 0 
2316 28 08			jr z, .cptokendone2 
2318 fe 20			cp ' ' 
231a 28 02			jr z, .cptmp2 
231c 18 ec			jr .cptokenstr2 
231e			 
231e			.cptmp2:	; we have a space so change to zero term for dict match later 
231e				;dec hl 
231e				;ld a,"-"	; TODO remove this when working 
231e				;ld (hl), a 
231e				;inc hl 
231e 18 ea			jr .cptokenstr2 
2320			 
2320			.cptokendone2: 
2320				;inc hl 
2320 3e 7f			ld a, FORTH_END_BUFFER 
2322 77				ld (hl),a 
2323 23				inc hl 
2324 3e 21			ld a, '!' 
2326 77				ld (hl),a 
2327			 
2327 2a 4f f6			ld hl,(os_tok_ptr) 
232a			         
232a			if DEBUG_FORTH_TOK 
232a						DMARK "Tc1" 
232a				CALLMONITOR 
232a			endif 
232a			 
232a				; push exec string to top of return stack 
232a				FORTH_RSP_NEXT 
232a cd e1 1e			call macro_forth_rsp_next 
232d				endm 
# End of macro FORTH_RSP_NEXT
232d c9				ret 
232e			 
232e			; Another go at the parser need to simplify the process 
232e			 
232e			forthparse: 
232e			 
232e			; 
232e			; line parse: 
232e			;       parse raw input buffer 
232e			;       tokenise the words 
232e			;       malloc new copy (for looping etc) 
232e			;       copy to malloc + current pc in line to start of string and add line term 
232e			;       save on new rsp 
232e			; 
232e			 
232e			; hl to point to the line to tokenise 
232e			 
232e			;	push hl 
232e 22 4f f6			ld (os_tok_ptr), hl  ; save ptr to string 
2331			 
2331			;	ld a,0		; string term on input 
2331			;	call strlent 
2331			 
2331			;	ld (os_tok_len), hl	 ; save string length 
2331			 
2331			;if DEBUG_FORTH_TOK 
2331			;	ex de,hl		 
2331			;endif 
2331			 
2331			;	pop hl 		; get back string pointer 
2331			 
2331			if DEBUG_FORTH_TOK 
2331						DMARK "TOK" 
2331				CALLMONITOR 
2331			endif 
2331 7e			.ptoken2:    ld a,(hl) 
2332 23				inc hl 
2333 fe 7f			cp FORTH_END_BUFFER 
2335 28 29			jr z, .ptokendone2 
2337 fe 00			cp 0 
2339 28 25			jr z, .ptokendone2 
233b fe 22			cp '"' 
233d 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
233f fe 20			cp ' ' 
2341 20 ee			jr nz,  .ptoken2 
2343			 
2343			; TODO consume comments held between ( and ) 
2343			 
2343				; we have a space so change to zero term for dict match later 
2343 2b				dec hl 
2344 3e 00			ld a,0 
2346 77				ld (hl), a 
2347 23				inc hl 
2348 18 e7			jr .ptoken2 
234a				 
234a			 
234a			.ptokenstr2: 
234a				; skip all white space until either eol (because forgot to term) or end double quote 
234a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
234a				;inc hl ; skip current double quote 
234a 7e				ld a,(hl) 
234b 23				inc hl 
234c fe 22			cp '"' 
234e 28 e1			jr z, .ptoken2 
2350 fe 7f			cp FORTH_END_BUFFER 
2352 28 0c			jr z, .ptokendone2 
2354 fe 00			cp 0 
2356 28 08			jr z, .ptokendone2 
2358 fe 20			cp ' ' 
235a 28 02			jr z, .ptmp2 
235c 18 ec			jr .ptokenstr2 
235e			 
235e			.ptmp2:	; we have a space so change to zero term for dict match later 
235e				;dec hl 
235e				;ld a,"-"	; TODO remove this when working 
235e				;ld (hl), a 
235e				;inc hl 
235e 18 ea			jr .ptokenstr2 
2360			 
2360			.ptokendone2: 
2360				;inc hl 
2360 3e 7f			ld a, FORTH_END_BUFFER 
2362 77				ld (hl),a 
2363 23				inc hl 
2364 3e 21			ld a, '!' 
2366 77				ld (hl),a 
2367			 
2367 2a 4f f6			ld hl,(os_tok_ptr) 
236a			         
236a			if DEBUG_FORTH_TOK 
236a						DMARK "TK1" 
236a				CALLMONITOR 
236a			endif 
236a			 
236a				; push exec string to top of return stack 
236a				FORTH_RSP_NEXT 
236a cd e1 1e			call macro_forth_rsp_next 
236d				endm 
# End of macro FORTH_RSP_NEXT
236d c9				ret 
236e			 
236e			; 
236e			;	; malloc size + buffer pointer + if is loop flag 
236e			;	ld hl,(os_tok_len) 		 ; get string length 
236e			; 
236e			;	ld a,l 
236e			; 
236e			;	cp 0			; we dont want to use a null string 
236e			;	ret z 
236e			; 
236e			;;	add 3    ; prefix malloc with buffer for current word ptr 
236e			; 
236e			;	add 5     ; TODO when certain not over writing memory remove 
236e			; 
236e			;		 
236e			; 
236e			;if DEBUG_FORTH_TOK 
236e			;			DMARK "TKE" 
236e			;	CALLMONITOR 
236e			;endif 
236e			; 
236e			;	ld l,a 
236e			;	ld h,0 
236e			;;	push hl   ; save required space for the copy later 
236e			;	call malloc 
236e			;if DEBUG_FORTH_TOK 
236e			;			DMARK "TKM" 
236e			;	CALLMONITOR 
236e			;endif 
236e			;	if DEBUG_FORTH_MALLOC_GUARD 
236e			;		push af 
236e			;		call ishlzero 
236e			;;		ld a, l 
236e			;;		add h 
236e			;;		cp 0 
236e			;		pop af 
236e			;		 
236e			;		call z,malloc_error 
236e			;	endif 
236e			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
236e			; 
236e			; 
236e			;if DEBUG_FORTH_TOK 
236e			;			DMARK "TKR" 
236e			;	CALLMONITOR 
236e			;endif 
236e			; 
236e			;	FORTH_RSP_NEXT 
236e			; 
236e			;	;inc hl	 ; go past current buffer pointer 
236e			;	;inc hl 
236e			;	;inc hl   ; and past if loop flag 
236e			;		; TODO Need to set flag  
236e			; 
236e			;	 
236e			;	 
236e			;	ex de,hl	; malloc is dest 
236e			;	ld hl, (os_tok_len) 
236e			;;	pop bc 
236e			;	ld c, l                
236e			;	ld b,0 
236e			;	ld hl, (os_tok_ptr) 
236e			; 
236e			;if DEBUG_FORTH_TOK 
236e			;			DMARK "TKT" 
236e			;	CALLMONITOR 
236e			;endif 
236e			; 
236e			;	; do str cpy 
236e			; 
236e			;	ldir      ; copy byte in hl to de 
236e			; 
236e			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
236e			; 
236e			;if DEBUG_FORTH_TOK 
236e			; 
236e			;			DMARK "TKY" 
236e			;	CALLMONITOR 
236e			;endif 
236e			;	;ld a,0 
236e			;	;ld a,FORTH_END_BUFFER 
236e			;	ex de, hl 
236e			;	;dec hl			 ; go back over the space delim at the end of word 
236e			;	;ld (hl),a 
236e			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
236e			;	ld a,FORTH_END_BUFFER 
236e			;	ld (hl),a 
236e			;	inc hl 
236e			;	ld a,FORTH_END_BUFFER 
236e			;	ld (hl),a 
236e			; 
236e			;	; init the malloc area data 
236e			;	; set pc for in current area 
236e			;	;ld hl, (os_tok_malloc) 
236e			;	;inc hl 
236e			;	;inc hl 
236e			;	;inc hl 
236e			;	;ex de,hl 
236e			;	;ld hl, (os_tok_malloc) 
236e			;	;ld (hl),e 
236e			;	;inc hl 
236e			;	;ld (hl),d 
236e			; 
236e			; 
236e			;	ld hl,(os_tok_malloc) 
236e			;if DEBUG_FORTH_PARSE_KEY 
236e			;			DMARK "TKU" 
236e			;	CALLMONITOR 
236e			;endif 
236e			; 
236e			;	ret 
236e			 
236e			forthexec: 
236e			 
236e			; line exec: 
236e			; forth parser 
236e			 
236e			; 
236e			;       get current exec line on rsp 
236e			 
236e				FORTH_RSP_TOS 
236e cd f8 1e			call macro_forth_rsp_tos 
2371				endm 
# End of macro FORTH_RSP_TOS
2371			 
2371			;       restore current pc - hl points to malloc of data 
2371			 
2371				;ld e, (hl) 
2371				;inc hl 
2371				;ld d, (hl) 
2371				;ex de,hl 
2371			 
2371			 
2371			exec1: 
2371 22 4f f6			ld (os_tok_ptr), hl 
2374			 
2374				; copy our PC to working vars  
2374 22 cd fb			ld (cli_ptr), hl 
2377 22 cb fb			ld (cli_origptr), hl 
237a			 
237a 7e				ld a,(hl) 
237b fe 7f			cp FORTH_END_BUFFER 
237d c8				ret z 
237e			 
237e				; skip any nulls 
237e			 
237e fe 00			cp 0 
2380 20 03			jr nz, .execword 
2382 23				inc hl 
2383 18 ec			jr exec1 
2385			 
2385			 
2385			.execword: 
2385			 
2385			 
2385			 
2385			if DEBUG_FORTH_PARSE_KEY 
2385						DMARK "KYQ" 
2385				CALLMONITOR 
2385			endif 
2385			;       while at start of word: 
2385			; get start of dict (in user area first) 
2385			 
2385 21 00 80		ld hl, baseram 
2388			;ld hl, sysdict 
2388 22 cf fb		ld (cli_nextword),hl 
238b			;           match word at pc 
238b			;           exec word 
238b			;           or push to dsp 
238b			;           forward to next token 
238b			;           if line term pop rsp and exit 
238b			;        
238b			 
238b			if DEBUG_FORTH_PARSE_KEY 
238b						DMARK "KYq" 
238b				CALLMONITOR 
238b			endif 
238b			 
238b			; 
238b			; word comp 
238b			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
238b			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
238b			;    move to start of word  
238b			;    compare word to cli_token 
238b			 
238b			.execpnword:	; HL at start of a word in the dictionary to check 
238b			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
238b			;	ld (cli_ptr), hl 
238b			 
238b 2a cf fb			ld hl,(cli_nextword) 
238e			 
238e cd 31 24			call forth_tok_next 
2391			; tok next start here 
2391			;	; TODO skip compiled symbol for now 
2391			;	inc hl 
2391			; 
2391			;	; save pointer to next word 
2391			; 
2391			;	; hl now points to the address of the next word pointer  
2391			;	ld e, (hl) 
2391			;	inc hl 
2391			;	ld d, (hl) 
2391			;	inc l 
2391			; 
2391			;	ex de,hl 
2391			;if DEBUG_FORTH_PARSE_NEXTWORD 
2391			;	push bc 
2391			;	ld bc, (cli_nextword) 
2391			;			DMARK "NXW" 
2391			;	CALLMONITOR 
2391			;	pop bc 
2391			;endif 
2391			; tok next end here 
2391 22 cf fb			ld (cli_nextword), hl     ; save for next check if no match on this word 
2394 eb				ex de, hl 
2395			 
2395			 
2395				; save the pointer of the current token - 1 to check against 
2395				 
2395 22 d3 fb			ld (cli_token), hl   
2398				; TODO maybe remove below save if no debug 
2398				; save token string ptr for any debug later 
2398 23				inc hl  
2399 22 d5 fb			ld (cli_origtoken), hl 
239c 2b				dec hl 
239d				; save pointer to the start of the next dictionay word 
239d 7e				ld a,(hl)   ; get string length 
239e 47				ld b,a 
239f			.execpnwordinc:  
239f 23				inc hl 
23a0 10 fd			djnz .execpnwordinc 
23a2 22 d1 fb			ld (cli_execword), hl      ; save start of this words code 
23a5			 
23a5				; now check the word token against the string being parsed 
23a5			 
23a5 2a d3 fb			ld hl,(cli_token) 
23a8 23				inc hl     ; skip string length (use zero term instead to end) 
23a9 22 d3 fb			ld (cli_token), hl 
23ac			 
23ac			if DEBUG_FORTH_PARSE_KEY 
23ac						DMARK "KY2" 
23ac			endif 
23ac			if DEBUG_FORTH_PARSE_EXEC 
23ac				; see if disabled 
23ac			 
23ac				ld a, (os_view_disable) 
23ac				cp '*' 
23ac				jr z, .skip 
23ac			 
23ac				push hl 
23ac				push hl 
23ac				call clear_display 
23ac				ld de, .compword 
23ac				ld a, display_row_1 
23ac				call str_at_display 
23ac				pop de 
23ac				ld a, display_row_2 
23ac				call str_at_display 
23ac				ld hl,(cli_ptr) 
23ac				ld a,(hl) 
23ac			        ld hl, os_word_scratch 
23ac				ld (hl),a 
23ac				ld a,0 
23ac				inc hl 
23ac				ld (hl),a 	 
23ac				ld de, os_word_scratch 
23ac				ld a, display_row_2+10 
23ac				call str_at_display 
23ac				call update_display 
23ac				ld a, 100 
23ac				call aDelayInMS 
23ac				if DEBUG_FORTH_PARSE_EXEC_SLOW 
23ac				call delay250ms 
23ac				endif 
23ac				pop hl 
23ac			.skip:  
23ac			endif	 
23ac			.execpnchar:    ; compare char between token and string to parse 
23ac			 
23ac			if DEBUG_FORTH_PARSE_KEY 
23ac						DMARK "Ky3" 
23ac			endif 
23ac			if DEBUG_FORTH_PARSE_EXEC 
23ac				; see if disabled 
23ac			 
23ac				ld a, (os_view_disable) 
23ac				cp '*' 
23ac				jr z, .skip2 
23ac			 
23ac			;	call clear_display 
23ac			ld hl,(cli_token) 
23ac			ld a,(hl) 
23ac			ld (os_word_scratch),a 
23ac				ld hl,(cli_ptr) 
23ac			ld a,(hl) 
23ac				ld (os_word_scratch+1),a 
23ac				ld a,0 
23ac				ld (os_word_scratch+2),a 
23ac				ld de,os_word_scratch 
23ac				ld a,display_row_4 
23ac				call str_at_display 
23ac				call update_display 
23ac			.skip2:  
23ac			endif 
23ac 2a d3 fb			ld hl,(cli_token) 
23af 7e				ld a, (hl)	 ; char in word token 
23b0 23				inc hl 		; move to next char 
23b1 22 d3 fb			ld (cli_token), hl ; and save it 
23b4 47				ld b,a 
23b5			 
23b5 2a cd fb			ld hl,(cli_ptr) ;	get the char from the string to parse 
23b8 7e				ld a,(hl) 
23b9 23				inc hl 
23ba 22 cd fb			ld (cli_ptr), hl		; move to next char 
23bd cd 9e 13			call toUpper 		; make sure the input string matches case 
23c0			 
23c0			if DEBUG_FORTH_PARSE 
23c0			endif 
23c0			 
23c0				; input stream end of token is a space so get rid of it 
23c0			 
23c0			;	cp ' ' 
23c0			;	jr nz, .pnskipspace 
23c0			; 
23c0			;	ld a, 0		; make same term as word token term 
23c0			; 
23c0			;.pnskipspace: 
23c0			 
23c0			if DEBUG_FORTH_PARSE_KEY 
23c0						DMARK "KY7" 
23c0			endif 
23c0 b8				cp b 
23c1 c2 d7 23			jp nz, .execpnskipword	 ; no match so move to next word 
23c4				 
23c4			;    if same 
23c4			;       scan for string terms 0 for token and 32 for input 
23c4			 
23c4				 
23c4			if DEBUG_FORTH_PARSE_KEY 
23c4						DMARK "KY8" 
23c4			endif 
23c4			 
23c4 80				add b			 
23c5 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
23c7							; TODO need to make sure last word in zero term string is accounted for 
23c7 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
23c9			 
23c9			 
23c9				; at end of both strings so both are exact match 
23c9			 
23c9			;       skip ptr for next word 
23c9			 
23c9 2a cd fb			ld hl,(cli_ptr) 	; at input string term 
23cc 23				inc hl			 ; at next char 
23cd 22 cd fb			ld (cli_ptr), hl     ; save for next round of the parser 
23d0 22 cb fb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
23d3				 
23d3				 
23d3			if DEBUG_FORTH_PARSE_KEY 
23d3						DMARK "KY3" 
23d3			endif 
23d3			 
23d3			 
23d3			 
23d3			;       exec code block 
23d3			if DEBUG_FORTH_JP 
23d3				call clear_display 
23d3				call update_display 
23d3				call delay1s 
23d3				ld hl, (cli_execword)     ; save for next check if no match on this word 
23d3				ld a,h 
23d3				ld hl, os_word_scratch 
23d3				call hexout 
23d3				ld hl, (cli_execword)     ; save for next check if no match on this word 
23d3				ld a,l 
23d3				ld hl, os_word_scratch+2 
23d3				call hexout 
23d3				ld hl, os_word_scratch+4 
23d3				ld a,0 
23d3				ld (hl),a 
23d3				ld de,os_word_scratch 
23d3				call str_at_display 
23d3					ld a, display_row_2 
23d3					call str_at_display 
23d3				ld de, (cli_origtoken) 
23d3				ld a, display_row_1+10 
23d3					call str_at_display 
23d3			 
23d3				ld a,display_row_1 
23d3				ld de, .foundword 
23d3				ld a, display_row_3 
23d3				call str_at_display 
23d3				call update_display 
23d3				call delay1s 
23d3				call delay1s 
23d3				call delay1s 
23d3			endif 
23d3			 
23d3			if DEBUG_FORTH_PARSE_KEY 
23d3						DMARK "KYj" 
23d3			endif 
23d3				; TODO save the word pointer in this exec 
23d3			 
23d3 2a d1 fb			ld hl,(cli_execword) 
23d6 e9				jp (hl) 
23d7			 
23d7			 
23d7			;    if not same 
23d7			;	scan for zero term 
23d7			;	get ptr for next word 
23d7			;	goto word comp 
23d7			 
23d7			.execpnskipword:	; get pointer to next word 
23d7 2a cf fb			ld hl,(cli_nextword) 
23da			 
23da 7e				ld a,(hl) 
23db fe 00			cp WORD_SYS_END 
23dd			;	cp 0 
23dd 28 09			jr z, .execendofdict			 ; at end of words 
23df			 
23df			if DEBUG_FORTH_PARSE_KEY 
23df						DMARK "KY4" 
23df			endif 
23df			if DEBUG_FORTH_PARSE_EXEC 
23df			 
23df				; see if disabled 
23df			 
23df				ld a, (os_view_disable) 
23df				cp '*' 
23df				jr z, .noskip 
23df			 
23df			 
23df				ld de, .nowordfound 
23df				ld a, display_row_3 
23df				call str_at_display 
23df				call update_display 
23df				ld a, 100 
23df				call aDelayInMS 
23df				 
23df				if DEBUG_FORTH_PARSE_EXEC_SLOW 
23df					call delay250ms 
23df				endif 
23df			.noskip:  
23df			 
23df			endif	 
23df			 
23df 2a cb fb			ld hl,(cli_origptr) 
23e2 22 cd fb			ld (cli_ptr),hl 
23e5			 
23e5			if DEBUG_FORTH_PARSE_KEY 
23e5						DMARK "KY5" 
23e5			endif 
23e5 c3 8b 23			jp .execpnword			; else go to next word 
23e8			 
23e8			.execendofdict:  
23e8			 
23e8			if DEBUG_FORTH_PARSE_KEY 
23e8						DMARK "KYe" 
23e8			endif 
23e8			if DEBUG_FORTH_PARSE_EXEC 
23e8				; see if disabled 
23e8			 
23e8				ld a, (os_view_disable) 
23e8				cp '*' 
23e8				jr z, .ispskip 
23e8			 
23e8				call clear_display 
23e8				call update_display 
23e8				call delay1s 
23e8				ld de, (cli_origptr) 
23e8				ld a, display_row_1 
23e8				call str_at_display 
23e8				 
23e8				ld de, .enddict 
23e8				ld a, display_row_3 
23e8				call str_at_display 
23e8				call update_display 
23e8				ld a, 100 
23e8				call aDelayInMS 
23e8				if DEBUG_FORTH_PARSE_EXEC_SLOW 
23e8				call delay1s 
23e8				call delay1s 
23e8				call delay1s 
23e8				endif 
23e8			.ispskip:  
23e8				 
23e8			endif	 
23e8			 
23e8			 
23e8			 
23e8				; if the word is not a keyword then must be a literal so push it to stack 
23e8			 
23e8			; push token to stack to end of word 
23e8			 
23e8				STACKFRAME ON $1efe $2f9f 
23e8				if DEBUG_STACK_IMB 
23e8					if ON 
23e8						exx 
23e8						ld de, $1efe 
23e8						ld a, d 
23e8						ld hl, curframe 
23e8						call hexout 
23e8						ld a, e 
23e8						ld hl, curframe+2 
23e8						call hexout 
23e8						ld hl, $1efe 
23e8						push hl 
23e8						ld hl, $2f9f 
23e8						push hl 
23e8						exx 
23e8					endif 
23e8				endif 
23e8			endm 
# End of macro STACKFRAME
23e8			 
23e8 2a 4f f6		ld hl,(os_tok_ptr) 
23eb cd a3 20		call forth_apush 
23ee			 
23ee				STACKFRAMECHK ON $1efe $2f9f 
23ee				if DEBUG_STACK_IMB 
23ee					if ON 
23ee						exx 
23ee						ld hl, $2f9f 
23ee						pop de   ; $2f9f 
23ee						call cmp16 
23ee						jr nz, .spnosame 
23ee						ld hl, $1efe 
23ee						pop de   ; $1efe 
23ee						call cmp16 
23ee						jr z, .spfrsame 
23ee						.spnosame: call showsperror 
23ee						.spfrsame: nop 
23ee						exx 
23ee					endif 
23ee				endif 
23ee			endm 
# End of macro STACKFRAMECHK
23ee			 
23ee			execnext: 
23ee			 
23ee			if DEBUG_FORTH_PARSE_KEY 
23ee						DMARK "KY>" 
23ee			endif 
23ee			; move past token to next word 
23ee			 
23ee 2a 4f f6		ld hl, (os_tok_ptr) 
23f1 3e 00		ld a, 0 
23f3 01 ff 00		ld bc, 255     ; input buffer size 
23f6 ed b1		cpir 
23f8			 
23f8			if DEBUG_FORTH_PARSE_KEY 
23f8						DMARK "KY!" 
23f8				CALLMONITOR 
23f8			endif	 
23f8			; TODO this might place hl on the null, so will need to forward on??? 
23f8			;inc hl   ; see if this gets onto the next item 
23f8			 
23f8			 
23f8			; TODO pass a pointer to the buffer to push 
23f8			; TODO call function to push 
23f8			 
23f8			; look for end of input 
23f8			 
23f8			;inc hl 
23f8			;ld a,(hl) 
23f8			;cp FORTH_END_BUFFER 
23f8			;ret z 
23f8			 
23f8			 
23f8 c3 71 23		jp exec1 
23fb			 
23fb			 
23fb			 
23fb			 
23fb			 
23fb			 
23fb			 
23fb			 
23fb			 
23fb			findnexttok: 
23fb			 
23fb				; hl is pointer to move 
23fb				; de is the token to locate 
23fb			 
23fb					if DEBUG_FORTH 
23fb						DMARK "NTK" 
23fb						CALLMONITOR 
23fb					endif 
23fb d5				push de 
23fc			 
23fc			.fnt1:	 
23fc				; find first char of token to locate 
23fc			 
23fc 1a				ld a, (de) 
23fd 4f				ld c,a 
23fe 7e				ld a,(hl) 
23ff cd 9e 13			call toUpper 
2402					if DEBUG_FORTH 
2402						DMARK "NT1" 
2402						CALLMONITOR 
2402					endif 
2402 b9				cp c 
2403			 
2403 28 03			jr z, .fnt2cmpmorefirst	 
2405			 
2405				; first char not found move to next char 
2405			 
2405 23				inc hl 
2406 18 f4			jr .fnt1 
2408			 
2408			.fnt2cmpmorefirst:	 
2408				; first char of token found.  
2408			 
2408 e5				push hl     ; save start of token just in case it is the right one 
2409 d9				exx 
240a e1				pop hl        ; save it to hl' 
240b d9				exx 
240c			 
240c			 
240c			.fnt2cmpmore:	 
240c				; compare the rest 
240c				 
240c 23				inc hl 
240d 13				inc de 
240e				 
240e 1a				ld a, (de) 
240f 4f				ld c,a 
2410 7e				ld a,(hl) 
2411 cd 9e 13			call toUpper 
2414			 
2414					if DEBUG_FORTH 
2414						DMARK "NT2" 
2414						CALLMONITOR 
2414					endif 
2414				; c has the token to find char 
2414				; a has the mem to scan char 
2414			 
2414 b9				cp c 
2415 28 04			jr z,.fntmatch1 
2417			 
2417				; they are not the same 
2417			 
2417					if DEBUG_FORTH 
2417						DMARK "NT3" 
2417						CALLMONITOR 
2417					endif 
2417 d1				pop de	; reset de token to look for 
2418 d5				push de 
2419 18 e1			jr .fnt1 
241b				 
241b			.fntmatch1: 
241b			 
241b				; is the same char a null which means we might have a full hit? 
241b					if DEBUG_FORTH 
241b						DMARK "NT4" 
241b						CALLMONITOR 
241b					endif 
241b			 
241b fe 00			cp 0 
241d 28 0b			jr z, .fntmatchyes 
241f			 
241f				; are we at the end of the token to find? 
241f			 
241f					if DEBUG_FORTH 
241f						DMARK "NT5" 
241f						CALLMONITOR 
241f					endif 
241f 3e 00			ld a, 0 
2421 b9				cp c 
2422			 
2422 c2 0c 24			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2425			 
2425					if DEBUG_FORTH 
2425						DMARK "NT6" 
2425						CALLMONITOR 
2425					endif 
2425				; token to find is exhusted but no match to stream 
2425			 
2425				; restore tok pointer and continue on 
2425 d1				pop de 
2426 d5				push de 
2427 c3 fc 23			jp .fnt1 
242a			 
242a			 
242a			.fntmatchyes: 
242a			 
242a				; hl now contains the end of the found token 
242a			 
242a				; get rid of saved token pointer to find 
242a			 
242a d1				pop de 
242b			 
242b					if DEBUG_FORTH 
242b						DMARK "NT9" 
242b						CALLMONITOR 
242b					endif 
242b			 
242b				; hl will be on the null term so forward on 
242b			 
242b				; get back the saved start of the token 
242b			 
242b d9				exx 
242c e5				push hl     ; save start of token just in case it is the right one 
242d d9				exx 
242e e1				pop hl        ; save it to hl 
242f			 
242f c9				ret 
2430			 
2430			 
2430			; LIST needs to find a specific token   
2430			; FORGET needs to find a spefici token 
2430			 
2430			; SAVE needs to find all tokens by flag 
2430			; WORDS just needs to scan through all  by flag 
2430			; UWORDS needs to scan through all by flag 
2430			 
2430			 
2430			; given hl as pointer to start of dict look up string 
2430			; return hl as pointer to start of word block 
2430			; or 0 if not found 
2430			 
2430			forth_find_tok: 
2430 c9				ret 
2431			 
2431			; given hl as pointer to dict structure 
2431			; move to the next dict block structure 
2431			 
2431			forth_tok_next: 
2431				; hl now points to the address of the next word pointer  
2431				; TODO skip compiled symbol for now 
2431			;	push de 
2431 23				inc hl 
2432 5e				ld e, (hl) 
2433 23				inc hl 
2434 56				ld d, (hl) 
2435 23				inc hl 
2436			 
2436 eb				ex de,hl 
2437			if DEBUG_FORTH_PARSE_NEXTWORD 
2437				push bc 
2437				ld bc, (cli_nextword) 
2437						DMARK "NXW" 
2437				CALLMONITOR 
2437				pop bc 
2437			endif 
2437			;	pop de	 
2437 c9				ret 
2438			 
2438			 
2438			 
2438			; eof 
# End of file forth_parserv5.asm
2438				include "forth_wordsv4.asm" 
2438			 
2438			; the core word dictionary v4 
2438			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2438			 
2438			; this is a linked list for each of the system words used 
2438			; user defined words will follow the same format but will be in ram 
2438			 
2438			 
2438			; 
2438			; 
2438			; define linked list: 
2438			; 
2438			; 1. compiled byte op code 
2438			; 2. len of text word 
2438			; 3. text word 
2438			; 4. ptr to next dictionary word 
2438			; 5. asm, calls etc for the word 
2438			; 
2438			;  if 1 == 0 then last word in dict  
2438			;   
2438			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2438			;  
2438			;  
2438			; create basic standard set of words 
2438			; 
2438			;  
2438			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2438			; 2DUP 2DROP 2SWAP  
2438			; @ C@ - get byte  
2438			; ! C! - store byte 
2438			; 0< true if less than zero 
2438			; 0= true if zero 
2438			; < >  
2438			; = true if same 
2438			; variables 
2438			 
2438			 
2438			; Hardware specific words I may need 
2438			; 
2438			; IN OUT  
2438			; calls to key util functions 
2438			; calls to hardward abstraction stuff 
2438			; easy control of frame buffers and lcd i/o 
2438			; keyboard  
2438			 
2438			 
2438			;DICT: macro 
2438			; op_code, len, word, next 
2438			;    word: 
2438			;    db op_code 
2438			;    ds word zero term 
2438			;    dw next 
2438			;    endm 
2438			 
2438			 
2438			 
2438			 
2438			; op code 1 is a flag for user define words which are to be handled differently 
2438			 
2438			 
2438			; 
2438			; 
2438			;    TODO on entry to a word this should be the expected environment 
2438			;    hl - tos value if number then held, if string this is the ptr 
2438			;    de -  
2438			 
2438			 
2438			; opcode ranges 
2438			; 0 - end of word dict 
2438			; 255 - user define words 
2438			 
2438			sysdict: 
2438			include "forth_opcodes.asm" 
2438			; op codes for forth keywords 
2438			; free to use code 0  
2438				OPCODE_HEAP: equ  1 
2438				OPCODE_EXEC: equ 2 
2438				OPCODE_DUP: equ 3 
2438				OPCODE_SWAP: equ 4 
2438				OPCODE_COLN: equ 5 
2438				OPCODE_SCOLN: equ 6 
2438				OPCODE_DROP: equ 7 
2438				OPCODE_DUP2: equ 8 
2438				OPCODE_DROP2: equ 9 
2438				OPCODE_SWAP2: equ 10 
2438				OPCODE_AT: equ 11 
2438				OPCODE_CAT: equ 12 
2438				OPCODE_BANG: equ 13 
2438				OPCODE_CBANG: equ 14 
2438				OPCODE_SCALL: equ 15 
2438				OPCODE_DEPTH: equ 16 
2438				OPCODE_OVER: equ 17 
2438				OPCODE_PAUSE: equ 18 
2438				OPCODE_PAUSES: equ 19 
2438				OPCODE_ROT: equ 20 
2438			;free to reuse	OPCODE_WORDS: equ 21 
2438			        OPCODE_NOT: equ 21 
2438				OPCODE_UWORDS: equ 22 
2438				OPCODE_BP: equ 23 
2438				OPCODE_MONITOR: equ 24  
2438				OPCODE_MALLOC: equ 25 
2438				OPCODE_FREE: equ 26 
2438				OPCODE_LIST: equ 27 
2438				OPCODE_FORGET: equ 28 
2438				OPCODE_NOP: equ 29 
2438				OPCODE_COMO: equ 30 
2438				OPCODE_COMC: equ 31 
2438			;free to reuse	OPCODE_ENDCORE: equ 32 
2438				OPCODE_AFTERSOUND: equ 33 
2438				OPCODE_GP2: equ 34 
2438				OPCODE_GP3: equ 35 
2438				OPCODE_GP4: equ 36 
2438				OPCODE_SIN: equ 37 
2438				OPCODE_SOUT: equ 38 
2438				OPCODE_SPIO: equ 39 
2438				OPCODE_SPICEH: equ 40 
2438				OPCODE_SPIOb: equ 41 
2438				OPCODE_SPII: equ 42 
2438				OPCODE_SESEL: equ 43 
2438				OPCODE_CARTDEV: equ 44 
2438			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2438				OPCODE_FB: equ 46 
2438				OPCODE_EMIT: equ 47 
2438				OPCODE_DOTH: equ 48 
2438				OPCODE_DOTF: equ 49 
2438				OPCODE_DOT: equ 50 
2438				OPCODE_CLS: equ 51 
2438				OPCODE_DRAW: equ 52 
2438				OPCODE_DUMP: equ 53 
2438				OPCODE_CDUMP: equ 54 
2438				OPCODE_DAT: equ 55 
2438				OPCODE_HOME: equ 56 
2438				OPCODE_SPACE: equ 57 
2438				OPCODE_SPACES: equ 58 
2438				OPCODE_SCROLL: equ 59 
2438				OPCODE_ATQ: equ 60 
2438				OPCODE_AUTODSP: equ 61 
2438				OPCODE_MENU: equ 62 
2438			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2438				OPCODE_THEN: equ 64 
2438				OPCODE_ELSE: equ 65 
2438				OPCODE_DO: equ 66 
2438				OPCODE_LOOP: equ 67 
2438				OPCODE_I: equ 68 
2438				OPCODE_DLOOP: equ 69  
2438				OPCODE_REPEAT: equ 70  
2438				OPCODE_UNTIL: equ 71 
2438				OPCODE_ENDFLOW: equ 72 
2438				OPCODE_WAITK: equ 73 
2438				OPCODE_ACCEPT: equ 74 
2438				OPCODE_EDIT: equ 75 
2438			;free to reuse	OPCODE_ENDKEY: equ 76 
2438				OPCODE_LZERO: equ 77 
2438				OPCODE_TZERO: equ 78 
2438				OPCODE_LESS: equ 79 
2438				OPCODE_GT: equ 80 
2438				OPCODE_EQUAL: equ 81  
2438			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2438				OPCODE_NEG: equ 83 
2438				OPCODE_DIV: equ 84 
2438				OPCODE_MUL: equ 85 
2438				OPCODE_MIN: equ 86 
2438				OPCODE_MAX: equ 87 
2438				OPCODE_RND16: equ 88 
2438				OPCODE_RND8: equ 89 
2438				OPCODE_RND: equ 90 
2438			;free to reuse	OPCODE_ENDMATHS: equ 91  
2438				OPCODE_BYNAME: equ 92 
2438				OPCODE_DIR: equ 93 
2438				OPCODE_SAVE: equ 94 
2438				OPCODE_LOAD: equ 95 
2438				OPCODE_BSAVE: equ 96 
2438				OPCODE_BLOAD: equ 97 
2438				OPCODE_SEO: equ 98  
2438				OPCODE_SEI: equ 99 
2438				OPCODE_SFREE: equ 100 
2438				OPCODE_SIZE: equ 101 
2438				OPCODE_CREATE: equ 102 
2438				OPCODE_APPEND: equ 103 
2438				OPCODE_SDEL: equ 104 
2438				OPCODE_OPEN: equ 105 
2438				OPCODE_READ: equ 106 
2438				OPCODE_EOF: equ 106 
2438				OPCODE_FORMAT: equ 107 
2438				OPCODE_LABEL: equ 108 
2438				OPCODE_LABELS: equ 109 
2438			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2438				OPCODE_UPPER: equ 111 
2438				OPCODE_LOWER: equ 112 
2438				OPCODE_SUBSTR: equ 113 
2438				OPCODE_LEFT: equ 114 
2438				OPCODE_RIGHT: equ 115 
2438				OPCODE_STR2NUM: equ 116 
2438				OPCODE_NUM2STR: equ 117 
2438				OPCODE_CONCAT: equ 118 
2438				OPCODE_FIND: equ 119 
2438				OPCODE_LEN: equ 120 
2438				OPCODE_CHAR: equ 121 
2438			; free to reuse	OPCODE_STRLEN: equ 122 
2438			; free to reuse	OPCODE_ENDSTR: equ 123 
2438				OPCODE_V0S: equ 124 
2438				OPCODE_V0Q: equ 125 
2438				OPCODE_V1S: equ 126 
2438				OPCODE_V1Q: equ 127 
2438				OPCODE_V2S: equ 128 
2438				OPCODE_V2Q: equ 129 
2438				OPCODE_V3S: equ 130 
2438				OPCODE_V3Q: equ 131 
2438			;free to reuse	OPCODE_END: equ 132 
2438				OPCODE_ZDUP: equ 133 
2438			 
2438			; eof 
# End of file forth_opcodes.asm
2438			 
2438			include "forth_words_core.asm" 
2438			 
2438			; | ## Core Words 
2438			 
2438			;if MALLOC_4 
2438			 
2438			.HEAP: 
2438				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2438 15				db WORD_SYS_CORE+OPCODE_HEAP             
2439 77 24			dw .EXEC            
243b 05				db 4 + 1 
243c .. 00			db "HEAP",0              
2441				endm 
# End of macro CWHEAD
2441			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2441			; | | u1 - Current number of bytes in the heap 
2441			; | | u2 - Remaining bytes left on the heap 
2441			; | |  
2441			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2441			 
2441			 
2441					if DEBUG_FORTH_WORDS_KEY 
2441						DMARK "HEP" 
2441 f5				push af  
2442 3a 56 24			ld a, (.dmark)  
2445 32 b4 fe			ld (debug_mark),a  
2448 3a 57 24			ld a, (.dmark+1)  
244b 32 b5 fe			ld (debug_mark+1),a  
244e 3a 58 24			ld a, (.dmark+2)  
2451 32 b6 fe			ld (debug_mark+2),a  
2454 18 03			jr .pastdmark  
2456 ..			.dmark: db "HEP"  
2459 f1			.pastdmark: pop af  
245a			endm  
# End of macro DMARK
245a						CALLMONITOR 
245a cd c6 18			call break_point_state  
245d				endm  
# End of macro CALLMONITOR
245d					endif 
245d 2a 0a 80				ld hl, (free_list )      
2460 11 0e 80				ld de, heap_start 
2463			 
2463 ed 52				sbc hl, de  
2465			 
2465 cd 3a 1f				call forth_push_numhl 
2468			 
2468			 
2468 ed 5b 0a 80			ld de, (free_list )      
246c 21 34 f3				ld hl, heap_end 
246f			 
246f ed 52				sbc hl, de 
2471			 
2471 cd 3a 1f				call forth_push_numhl 
2474					 
2474			 
2474					 
2474			 
2474			 
2474			 
2474					NEXTW 
2474 c3 e0 22			jp macro_next 
2477				endm 
# End of macro NEXTW
2477			;endif 
2477			 
2477			.EXEC: 
2477			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2477			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2477			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2477			;; > > 
2477			;; > >   
2477			;	STACKFRAME OFF $5efe $5f9f 
2477			; 
2477			;		if DEBUG_FORTH_WORDS_KEY 
2477			;			DMARK "EXE" 
2477			;			CALLMONITOR 
2477			;		endif 
2477			; 
2477			;	FORTH_DSP_VALUEHL 
2477			; 
2477			;	FORTH_DSP_POP 
2477			; 
2477			;		if DEBUG_FORTH_WORDS 
2477			;			DMARK "EX1" 
2477			;			CALLMONITOR 
2477			;		endif 
2477			;;	ld e,(hl) 
2477			;;	inc hl 
2477			;;	ld d,(hl) 
2477			;;	ex de,hl 
2477			; 
2477			;;		if DEBUG_FORTH_WORDS 
2477			;;			DMARK "EX2" 
2477			;;			CALLMONITOR 
2477			;;		endif 
2477			;	push hl 
2477			; 
2477			;	;ld a, 0 
2477			;	;ld a, FORTH_END_BUFFER 
2477			;	call strlenz 
2477			;	inc hl   ; include zero term to copy 
2477			;	inc hl   ; include term 
2477			;	inc hl   ; include term 
2477			;	ld b,0 
2477			;	ld c,l 
2477			;	pop hl 
2477			;	ld de, execscratch 
2477			;		if DEBUG_FORTH_WORDS 
2477			;			DMARK "EX3" 
2477			;			CALLMONITOR 
2477			;		endif 
2477			;	ldir 
2477			; 
2477			; 
2477			;	ld hl, execscratch 
2477			; 
2477			;		if DEBUG_FORTH_WORDS 
2477			;			DMARK "EXe" 
2477			;			CALLMONITOR 
2477			;		endif 
2477			; 
2477			;	call forthparse 
2477			;	call forthexec 
2477			;;	call forthexec_cleanup 
2477			;;	call forthparse 
2477			;;	call forthexec 
2477			; 
2477			;	STACKFRAMECHK OFF $5efe $5f9f 
2477			; 
2477			;	; an immediate word so no need to process any more words 
2477			;	ret 
2477			;	NEXTW 
2477			 
2477			; dead code - old version  
2477			;	FORTH_RSP_NEXT 
2477			 
2477			;  
2477			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2477			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2477			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2477			;	push hl 
2477			;	push de 
2477			;	push bc 
2477			; 
2477			; 
2477			;		if DEBUG_FORTH_WORDS_KEY 
2477			;			DMARK "EXR" 
2477			;			CALLMONITOR 
2477			;		endif 
2477			; 
2477			; 
2477			; 
2477			;	;v5 FORTH_DSP_VALUE 
2477			;	FORTH_DSP_VALUEHL 
2477			; 
2477			;	; TODO do string type checks 
2477			; 
2477			;;v5	inc hl   ; skip type 
2477			; 
2477			;	push hl  ; source code  
2477			;		if DEBUG_FORTH_WORDS 
2477			;			DMARK "EX1" 
2477			;			CALLMONITOR 
2477			;		endif 
2477			;	ld a, 0 
2477			;	call strlent 
2477			; 
2477			;	inc hl 
2477			;	inc hl 
2477			;	inc hl 
2477			;	inc hl 
2477			; 
2477			;	push hl    ; size 
2477			; 
2477			;		if DEBUG_FORTH_WORDS 
2477			;			DMARK "EX2" 
2477			;			CALLMONITOR 
2477			;		endif 
2477			;	call malloc 
2477			; 
2477			;	ex de, hl    ; de now contains malloc area 
2477			;	pop bc   	; get byte count 
2477			;	pop hl      ; get string to copy 
2477			; 
2477			;	push de     ; save malloc for free later 
2477			; 
2477			;		if DEBUG_FORTH_WORDS 
2477			;			DMARK "EX3" 
2477			;			CALLMONITOR 
2477			;		endif 
2477			;	ldir       ; duplicate string 
2477			; 
2477			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2477			;	 
2477			;	; TODO fix the parse would be better than this...  
2477			;	ex de, hl 
2477			;	dec hl 
2477			;	ld a, 0 
2477			;	ld (hl), a 
2477			;	dec hl 
2477			;	ld a, ' ' 
2477			;	ld (hl), a 
2477			;	dec hl 
2477			;	ld (hl), a 
2477			; 
2477			;	dec hl 
2477			;	ld (hl), a 
2477			; 
2477			; 
2477			;	FORTH_DSP_POP  
2477			; 
2477			;	pop hl     
2477			;	push hl    ; save malloc area 
2477			; 
2477			;		if DEBUG_FORTH_WORDS 
2477			;			DMARK "EX4" 
2477			;			CALLMONITOR 
2477			;		endif 
2477			; 
2477			;	call forthparse 
2477			;	call forthexec 
2477			;	 
2477			;	pop hl 
2477			;	if DEBUG_FORTH_WORDS 
2477			;		DMARK "EX5" 
2477			;		CALLMONITOR 
2477			;	endif 
2477			; 
2477			;	if FORTH_ENABLE_FREE 
2477			;	call free 
2477			;	endif 
2477			; 
2477			;	if DEBUG_FORTH_WORDS 
2477			;		DMARK "EX6" 
2477			;		CALLMONITOR 
2477			;	endif 
2477			; 
2477			;	pop bc 
2477			;	pop de 
2477			;	pop hl 
2477			;;	FORTH_RSP_POP	  
2477			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2477			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2477			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2477			; 
2477			;	if DEBUG_FORTH_WORDS 
2477			;		DMARK "EX7" 
2477			;		CALLMONITOR 
2477			;	endif 
2477			;	NEXTW 
2477			 
2477			;.STKEXEC: 
2477			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2477			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2477			; 
2477			; 
2477			;		if DEBUG_FORTH_WORDS_KEY 
2477			;			DMARK "STX" 
2477			;			CALLMONITOR 
2477			;		endif 
2477			; 
2477			;	FORTH_DSP_VALUEHL 
2477			; 
2477			;	ld (store_tmp1), hl    ; count 
2477			; 
2477			;	FORTH_DSP_POP 
2477			;.stkexec1: 
2477			;	ld hl, (store_tmp1)   ; count 
2477			;	ld a, 0 
2477			;	cp l 
2477			;	ret z 
2477			; 
2477			;	dec hl 
2477			;	ld (store_tmp1), hl    ; count 
2477			;	 
2477			;	FORTH_DSP_VALUEHL 
2477			;	push hl 
2477			;	 
2477			;		if DEBUG_FORTH_WORDS 
2477			;			DMARK "EXp" 
2477			;			CALLMONITOR 
2477			;		endif 
2477			;	FORTH_DSP_POP 
2477			; 
2477			;	call strlenz 
2477			;	inc hl   ; include zero term to copy 
2477			;	inc hl   ; include zero term to copy 
2477			;	inc hl   ; include zero term to copy 
2477			;	ld b,0 
2477			;	ld c,l 
2477			;	pop hl 
2477			;	ld de, execscratch 
2477			;		if DEBUG_FORTH_WORDS 
2477			;			DMARK "EX3" 
2477			;			CALLMONITOR 
2477			;		endif 
2477			;	ldir 
2477			; 
2477			; 
2477			;	ld hl, execscratch 
2477			; 
2477			;		if DEBUG_FORTH_WORDS 
2477			;			DMARK "EXP" 
2477			;			CALLMONITOR 
2477			;		endif 
2477			; 
2477			;	call forthparse 
2477			;	ld hl, execscratch 
2477			;		if DEBUG_FORTH_WORDS 
2477			;			DMARK "EXx" 
2477			;			CALLMONITOR 
2477			;		endif 
2477			;	call forthexec 
2477			; 
2477			;	jp .stkexec1 
2477			; 
2477			;	ret 
2477			 
2477			 
2477			.DUP: 
2477				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2477 17				db WORD_SYS_CORE+OPCODE_DUP             
2478 ed 24			dw .ZDUP            
247a 04				db 3 + 1 
247b .. 00			db "DUP",0              
247f				endm 
# End of macro CWHEAD
247f			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
247f			 
247f					if DEBUG_FORTH_WORDS_KEY 
247f						DMARK "DUP" 
247f f5				push af  
2480 3a 94 24			ld a, (.dmark)  
2483 32 b4 fe			ld (debug_mark),a  
2486 3a 95 24			ld a, (.dmark+1)  
2489 32 b5 fe			ld (debug_mark+1),a  
248c 3a 96 24			ld a, (.dmark+2)  
248f 32 b6 fe			ld (debug_mark+2),a  
2492 18 03			jr .pastdmark  
2494 ..			.dmark: db "DUP"  
2497 f1			.pastdmark: pop af  
2498			endm  
# End of macro DMARK
2498						CALLMONITOR 
2498 cd c6 18			call break_point_state  
249b				endm  
# End of macro CALLMONITOR
249b					endif 
249b			 
249b					FORTH_DSP 
249b cd f7 20			call macro_forth_dsp 
249e				endm 
# End of macro FORTH_DSP
249e			 
249e 7e					ld a, (HL) 
249f fe 01				cp DS_TYPE_STR 
24a1 20 25				jr nz, .dupinum 
24a3			 
24a3					; push another string 
24a3			 
24a3					FORTH_DSP_VALUEHL     		 
24a3 cd 31 21			call macro_dsp_valuehl 
24a6				endm 
# End of macro FORTH_DSP_VALUEHL
24a6			 
24a6				if DEBUG_FORTH_WORDS 
24a6					DMARK "DUs" 
24a6 f5				push af  
24a7 3a bb 24			ld a, (.dmark)  
24aa 32 b4 fe			ld (debug_mark),a  
24ad 3a bc 24			ld a, (.dmark+1)  
24b0 32 b5 fe			ld (debug_mark+1),a  
24b3 3a bd 24			ld a, (.dmark+2)  
24b6 32 b6 fe			ld (debug_mark+2),a  
24b9 18 03			jr .pastdmark  
24bb ..			.dmark: db "DUs"  
24be f1			.pastdmark: pop af  
24bf			endm  
# End of macro DMARK
24bf					CALLMONITOR 
24bf cd c6 18			call break_point_state  
24c2				endm  
# End of macro CALLMONITOR
24c2				endif 
24c2 cd a8 1f				call forth_push_str 
24c5			 
24c5					NEXTW 
24c5 c3 e0 22			jp macro_next 
24c8				endm 
# End of macro NEXTW
24c8			 
24c8			 
24c8			.dupinum: 
24c8					 
24c8			 
24c8			 
24c8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24c8 cd 31 21			call macro_dsp_valuehl 
24cb				endm 
# End of macro FORTH_DSP_VALUEHL
24cb			 
24cb				; TODO add floating point number detection 
24cb			 
24cb				if DEBUG_FORTH_WORDS 
24cb					DMARK "DUi" 
24cb f5				push af  
24cc 3a e0 24			ld a, (.dmark)  
24cf 32 b4 fe			ld (debug_mark),a  
24d2 3a e1 24			ld a, (.dmark+1)  
24d5 32 b5 fe			ld (debug_mark+1),a  
24d8 3a e2 24			ld a, (.dmark+2)  
24db 32 b6 fe			ld (debug_mark+2),a  
24de 18 03			jr .pastdmark  
24e0 ..			.dmark: db "DUi"  
24e3 f1			.pastdmark: pop af  
24e4			endm  
# End of macro DMARK
24e4					CALLMONITOR 
24e4 cd c6 18			call break_point_state  
24e7				endm  
# End of macro CALLMONITOR
24e7				endif 
24e7			 
24e7 cd 3a 1f				call forth_push_numhl 
24ea					NEXTW 
24ea c3 e0 22			jp macro_next 
24ed				endm 
# End of macro NEXTW
24ed			.ZDUP: 
24ed				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
24ed 99				db WORD_SYS_CORE+OPCODE_ZDUP             
24ee 25 25			dw .SWAP            
24f0 05				db 4 + 1 
24f1 .. 00			db "?DUP",0              
24f6				endm 
# End of macro CWHEAD
24f6			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
24f6			 
24f6					if DEBUG_FORTH_WORDS_KEY 
24f6						DMARK "qDU" 
24f6 f5				push af  
24f7 3a 0b 25			ld a, (.dmark)  
24fa 32 b4 fe			ld (debug_mark),a  
24fd 3a 0c 25			ld a, (.dmark+1)  
2500 32 b5 fe			ld (debug_mark+1),a  
2503 3a 0d 25			ld a, (.dmark+2)  
2506 32 b6 fe			ld (debug_mark+2),a  
2509 18 03			jr .pastdmark  
250b ..			.dmark: db "qDU"  
250e f1			.pastdmark: pop af  
250f			endm  
# End of macro DMARK
250f						CALLMONITOR 
250f cd c6 18			call break_point_state  
2512				endm  
# End of macro CALLMONITOR
2512					endif 
2512					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2512 cd 31 21			call macro_dsp_valuehl 
2515				endm 
# End of macro FORTH_DSP_VALUEHL
2515			 
2515 e5					push hl 
2516			 
2516					; is it a zero? 
2516			 
2516 3e 00				ld a, 0 
2518 84					add h 
2519 85					add l 
251a			 
251a e1					pop hl 
251b			 
251b fe 00				cp 0 
251d 28 03				jr z, .dup2orig 
251f			 
251f			 
251f cd 3a 1f				call forth_push_numhl 
2522			 
2522			 
2522				; TODO add floating point number detection 
2522			 
2522			.dup2orig: 
2522			 
2522					NEXTW 
2522 c3 e0 22			jp macro_next 
2525				endm 
# End of macro NEXTW
2525			.SWAP: 
2525				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2525 18				db WORD_SYS_CORE+OPCODE_SWAP             
2526 64 25			dw .COLN            
2528 05				db 4 + 1 
2529 .. 00			db "SWAP",0              
252e				endm 
# End of macro CWHEAD
252e			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
252e					if DEBUG_FORTH_WORDS_KEY 
252e						DMARK "SWP" 
252e f5				push af  
252f 3a 43 25			ld a, (.dmark)  
2532 32 b4 fe			ld (debug_mark),a  
2535 3a 44 25			ld a, (.dmark+1)  
2538 32 b5 fe			ld (debug_mark+1),a  
253b 3a 45 25			ld a, (.dmark+2)  
253e 32 b6 fe			ld (debug_mark+2),a  
2541 18 03			jr .pastdmark  
2543 ..			.dmark: db "SWP"  
2546 f1			.pastdmark: pop af  
2547			endm  
# End of macro DMARK
2547						CALLMONITOR 
2547 cd c6 18			call break_point_state  
254a				endm  
# End of macro CALLMONITOR
254a					endif 
254a			 
254a					FORTH_DSP_VALUEHL 
254a cd 31 21			call macro_dsp_valuehl 
254d				endm 
# End of macro FORTH_DSP_VALUEHL
254d e5					push hl     ; w2 
254e			 
254e					FORTH_DSP_POP 
254e cd e9 21			call macro_forth_dsp_pop 
2551				endm 
# End of macro FORTH_DSP_POP
2551			 
2551					FORTH_DSP_VALUEHL 
2551 cd 31 21			call macro_dsp_valuehl 
2554				endm 
# End of macro FORTH_DSP_VALUEHL
2554			 
2554					FORTH_DSP_POP 
2554 cd e9 21			call macro_forth_dsp_pop 
2557				endm 
# End of macro FORTH_DSP_POP
2557			 
2557 d1					pop de     ; w2	, hl = w1 
2558			 
2558 eb					ex de, hl 
2559 d5					push de 
255a			 
255a cd 3a 1f				call forth_push_numhl 
255d			 
255d e1					pop hl 
255e			 
255e cd 3a 1f				call forth_push_numhl 
2561					 
2561			 
2561					NEXTW 
2561 c3 e0 22			jp macro_next 
2564				endm 
# End of macro NEXTW
2564			.COLN: 
2564				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2564 19				db WORD_SYS_CORE+OPCODE_COLN             
2565 f0 26			dw .SCOLN            
2567 02				db 1 + 1 
2568 .. 00			db ":",0              
256a				endm 
# End of macro CWHEAD
256a			; | : ( -- )         Create new word | DONE 
256a			 
256a					if DEBUG_FORTH_WORDS_KEY 
256a						DMARK "CLN" 
256a f5				push af  
256b 3a 7f 25			ld a, (.dmark)  
256e 32 b4 fe			ld (debug_mark),a  
2571 3a 80 25			ld a, (.dmark+1)  
2574 32 b5 fe			ld (debug_mark+1),a  
2577 3a 81 25			ld a, (.dmark+2)  
257a 32 b6 fe			ld (debug_mark+2),a  
257d 18 03			jr .pastdmark  
257f ..			.dmark: db "CLN"  
2582 f1			.pastdmark: pop af  
2583			endm  
# End of macro DMARK
2583						CALLMONITOR 
2583 cd c6 18			call break_point_state  
2586				endm  
# End of macro CALLMONITOR
2586					endif 
2586				STACKFRAME OFF $8efe $989f 
2586				if DEBUG_STACK_IMB 
2586					if OFF 
2586						exx 
2586						ld de, $8efe 
2586						ld a, d 
2586						ld hl, curframe 
2586						call hexout 
2586						ld a, e 
2586						ld hl, curframe+2 
2586						call hexout 
2586						ld hl, $8efe 
2586						push hl 
2586						ld hl, $989f 
2586						push hl 
2586						exx 
2586					endif 
2586				endif 
2586			endm 
# End of macro STACKFRAME
2586				; get parser buffer length  of new word 
2586			 
2586				 
2586			 
2586					; move tok past this to start of name defintition 
2586					; TODO get word to define 
2586					; TODO Move past word token 
2586					; TODO get length of string up to the ';' 
2586			 
2586 2a 4f f6			ld hl, (os_tok_ptr) 
2589 23				inc hl 
258a 23				inc hl 
258b			 
258b 3e 3b			ld a, ';' 
258d cd b2 13			call strlent 
2590			 
2590 7d				ld a,l 
2591 32 4a f3			ld (os_new_parse_len), a 
2594			 
2594			 
2594			if DEBUG_FORTH_UWORD 
2594 ed 5b 4f f6		ld de, (os_tok_ptr) 
2598						DMARK ":01" 
2598 f5				push af  
2599 3a ad 25			ld a, (.dmark)  
259c 32 b4 fe			ld (debug_mark),a  
259f 3a ae 25			ld a, (.dmark+1)  
25a2 32 b5 fe			ld (debug_mark+1),a  
25a5 3a af 25			ld a, (.dmark+2)  
25a8 32 b6 fe			ld (debug_mark+2),a  
25ab 18 03			jr .pastdmark  
25ad ..			.dmark: db ":01"  
25b0 f1			.pastdmark: pop af  
25b1			endm  
# End of macro DMARK
25b1				CALLMONITOR 
25b1 cd c6 18			call break_point_state  
25b4				endm  
# End of macro CALLMONITOR
25b4			endif 
25b4			 
25b4			; 
25b4			;  new word memory layout: 
25b4			;  
25b4			;    : adg 6666 ;  
25b4			; 
25b4			;    db   1     ; user defined word  
25b4 23				inc hl    
25b5			;    dw   sysdict 
25b5 23				inc hl 
25b6 23				inc hl 
25b7			;    db <word len>+1 (for null) 
25b7 23				inc hl 
25b8			;    db .... <word> 
25b8			; 
25b8			 
25b8 23				inc hl    ; some extras for the word preamble before the above 
25b9 23				inc hl 
25ba 23				inc hl 
25bb 23				inc hl 
25bc 23				inc hl 
25bd 23				inc hl 
25be 23				inc hl  
25bf 23				inc hl 
25c0 23				inc hl 
25c1 23				inc hl 
25c2 23				inc hl 
25c3 23				inc hl 
25c4 23				inc hl 
25c5 23				inc hl     ; TODO how many do we really need?     maybe only 6 
25c6			;       exec word buffer 
25c6			;	<ptr word>   
25c6 23				inc hl 
25c7 23				inc hl 
25c8			;       <word list><null term> 7F final term 
25c8			 
25c8			 
25c8			if DEBUG_FORTH_UWORD 
25c8						DMARK ":02" 
25c8 f5				push af  
25c9 3a dd 25			ld a, (.dmark)  
25cc 32 b4 fe			ld (debug_mark),a  
25cf 3a de 25			ld a, (.dmark+1)  
25d2 32 b5 fe			ld (debug_mark+1),a  
25d5 3a df 25			ld a, (.dmark+2)  
25d8 32 b6 fe			ld (debug_mark+2),a  
25db 18 03			jr .pastdmark  
25dd ..			.dmark: db ":02"  
25e0 f1			.pastdmark: pop af  
25e1			endm  
# End of macro DMARK
25e1				CALLMONITOR 
25e1 cd c6 18			call break_point_state  
25e4				endm  
# End of macro CALLMONITOR
25e4			endif 
25e4			 
25e4				 
25e4					; malloc the size 
25e4			 
25e4 cd 10 14				call malloc 
25e7 22 4c f3				ld (os_new_malloc), hl     ; save malloc start 
25ea			 
25ea			;    db   1     ; user defined word  
25ea 3e 01				ld a, WORD_SYS_UWORD  
25ec 77					ld (hl), a 
25ed				 
25ed 23				inc hl    
25ee			;    dw   sysdict 
25ee 11 38 24			ld de, sysdict       ; continue on with the scan to the system dict 
25f1 73				ld (hl), e 
25f2 23				inc hl 
25f3 72				ld (hl), d 
25f4 23				inc hl 
25f5			 
25f5			 
25f5			;    Setup dict word 
25f5			 
25f5 23				inc hl 
25f6 22 46 f3			ld (os_new_work_ptr), hl     ; save start of dict word  
25f9			 
25f9				; 1. get length of dict word 
25f9			 
25f9			 
25f9 2a 4f f6			ld hl, (os_tok_ptr) 
25fc 23				inc hl 
25fd 23				inc hl    ; position to start of dict word 
25fe 3e 00			ld a, 0 
2600 cd b2 13			call strlent 
2603			 
2603			 
2603 23				inc hl    ; to include null??? 
2604			 
2604				; write length of dict word 
2604			 
2604 ed 5b 46 f3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2608 1b				dec de 
2609 eb				ex de, hl 
260a 73				ld (hl), e 
260b eb				ex de, hl 
260c			 
260c				 
260c			 
260c				; copy  
260c 4d				ld c, l 
260d 06 00			ld b, 0 
260f ed 5b 46 f3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2613 2a 4f f6			ld hl, (os_tok_ptr) 
2616 23				inc hl 
2617 23				inc hl    ; position to start of dict word 
2618				 
2618			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2618				 
2618				; TODO need to convert word to upper case 
2618			 
2618			ucasetok:	 
2618 7e				ld a,(hl) 
2619 cd 9e 13			call toUpper 
261c 77				ld (hl),a 
261d ed a0			ldi 
261f f2 18 26		 	jp p, ucasetok 
2622			 
2622			 
2622			 
2622				; de now points to start of where the word body code should be placed 
2622 ed 53 46 f3		ld (os_new_work_ptr), de 
2626				; hl now points to the words to throw at forthexec which needs to be copied 
2626 22 44 f3			ld (os_new_src_ptr), hl 
2629			 
2629				; TODO add 'call to forthexec' 
2629			 
2629			if DEBUG_FORTH_UWORD 
2629 c5				push bc 
262a ed 4b 4c f3		ld bc, (os_new_malloc) 
262e						DMARK ":0x" 
262e f5				push af  
262f 3a 43 26			ld a, (.dmark)  
2632 32 b4 fe			ld (debug_mark),a  
2635 3a 44 26			ld a, (.dmark+1)  
2638 32 b5 fe			ld (debug_mark+1),a  
263b 3a 45 26			ld a, (.dmark+2)  
263e 32 b6 fe			ld (debug_mark+2),a  
2641 18 03			jr .pastdmark  
2643 ..			.dmark: db ":0x"  
2646 f1			.pastdmark: pop af  
2647			endm  
# End of macro DMARK
2647				CALLMONITOR 
2647 cd c6 18			call break_point_state  
264a				endm  
# End of macro CALLMONITOR
264a c1				pop bc 
264b			endif 
264b			 
264b			 
264b				; create word preamble which should be: 
264b			 
264b			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
264b			 
264b				;    ld hl, <word code> 
264b				;    jp user_exec 
264b			        ;    <word code bytes> 
264b			 
264b			 
264b			;	inc de     ; TODO ??? or are we already past the word's null 
264b eb				ex de, hl 
264c			 
264c 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
264e			 
264e 23				inc hl 
264f 22 40 f3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2652 23				inc hl 
2653			 
2653 23				inc hl 
2654 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2656			 
2656 01 ee 57			ld bc, user_exec 
2659 23				inc hl 
265a 71				ld (hl), c     ; poke address of user_exec 
265b 23				inc hl 
265c 70				ld (hl), b     
265d			 ; 
265d			;	inc hl 
265d			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
265d			; 
265d			; 
265d			;	ld bc, macro_forth_rsp_next 
265d			;	inc hl 
265d			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
265d			;	inc hl 
265d			;	ld (hl), b     
265d			 ; 
265d			;	inc hl 
265d			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
265d			; 
265d			; 
265d			;	inc hl 
265d			;	ld bc, forthexec 
265d			;	ld (hl), c     ; poke address of forthexec 
265d			;	inc hl 
265d			;	ld (hl), b      
265d			; 
265d			;	inc hl 
265d			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
265d			; 
265d			;	ld bc, user_dict_next 
265d			;	inc hl 
265d			;	ld (hl), c     ; poke address of forthexec 
265d			;	inc hl 
265d			;	ld (hl), b      
265d			 
265d				; hl is now where we need to copy the word byte data to save this 
265d			 
265d 23				inc hl 
265e 22 42 f3			ld (os_new_exec), hl 
2661				 
2661				; copy definition 
2661			 
2661 eb				ex de, hl 
2662			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2662			;	inc de    ; skip the PC for this parse 
2662 3a 4a f3			ld a, (os_new_parse_len) 
2665 4f				ld c, a 
2666 06 00			ld b, 0 
2668 ed b0			ldir		 ; copy defintion 
266a			 
266a			 
266a				; poke the address of where the new word bytes live for forthexec 
266a			 
266a 2a 40 f3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
266d			 
266d ed 5b 42 f3		ld de, (os_new_exec)      
2671				 
2671 73				ld (hl), e 
2672 23				inc hl 
2673 72				ld (hl), d 
2674			 
2674					; TODO copy last user dict word next link to this word 
2674					; TODO update last user dict word to point to this word 
2674			; 
2674			; hl f923 de 812a ; bc 811a 
2674			 
2674			if DEBUG_FORTH_UWORD 
2674 c5				push bc 
2675 ed 4b 4c f3		ld bc, (os_new_malloc) 
2679						DMARK ":0A" 
2679 f5				push af  
267a 3a 8e 26			ld a, (.dmark)  
267d 32 b4 fe			ld (debug_mark),a  
2680 3a 8f 26			ld a, (.dmark+1)  
2683 32 b5 fe			ld (debug_mark+1),a  
2686 3a 90 26			ld a, (.dmark+2)  
2689 32 b6 fe			ld (debug_mark+2),a  
268c 18 03			jr .pastdmark  
268e ..			.dmark: db ":0A"  
2691 f1			.pastdmark: pop af  
2692			endm  
# End of macro DMARK
2692				CALLMONITOR 
2692 cd c6 18			call break_point_state  
2695				endm  
# End of macro CALLMONITOR
2695 c1				pop bc 
2696			endif 
2696			if DEBUG_FORTH_UWORD 
2696 c5				push bc 
2697 ed 4b 4c f3		ld bc, (os_new_malloc) 
269b 03				inc bc 
269c 03				inc bc 
269d 03				inc bc 
269e 03				inc bc 
269f 03				inc bc 
26a0 03				inc bc 
26a1 03				inc bc 
26a2 03				inc bc 
26a3			 
26a3						DMARK ":0B" 
26a3 f5				push af  
26a4 3a b8 26			ld a, (.dmark)  
26a7 32 b4 fe			ld (debug_mark),a  
26aa 3a b9 26			ld a, (.dmark+1)  
26ad 32 b5 fe			ld (debug_mark+1),a  
26b0 3a ba 26			ld a, (.dmark+2)  
26b3 32 b6 fe			ld (debug_mark+2),a  
26b6 18 03			jr .pastdmark  
26b8 ..			.dmark: db ":0B"  
26bb f1			.pastdmark: pop af  
26bc			endm  
# End of macro DMARK
26bc				CALLMONITOR 
26bc cd c6 18			call break_point_state  
26bf				endm  
# End of macro CALLMONITOR
26bf c1				pop bc 
26c0			endif 
26c0			 
26c0			; update word dict linked list for new word 
26c0			 
26c0			 
26c0 2a 4b f6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
26c3 23			inc hl     ; move to next work linked list ptr 
26c4			 
26c4 ed 5b 4c f3	ld de, (os_new_malloc)		 ; new next word 
26c8 73			ld (hl), e 
26c9 23			inc hl 
26ca 72			ld (hl), d 
26cb			 
26cb			if DEBUG_FORTH_UWORD 
26cb ed 4b 4b f6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
26cf			endif 
26cf			 
26cf ed 53 4b f6	ld (os_last_new_uword), de      ; update last new uword ptr 
26d3			 
26d3			 
26d3			if DEBUG_FORTH_UWORD 
26d3						DMARK ":0+" 
26d3 f5				push af  
26d4 3a e8 26			ld a, (.dmark)  
26d7 32 b4 fe			ld (debug_mark),a  
26da 3a e9 26			ld a, (.dmark+1)  
26dd 32 b5 fe			ld (debug_mark+1),a  
26e0 3a ea 26			ld a, (.dmark+2)  
26e3 32 b6 fe			ld (debug_mark+2),a  
26e6 18 03			jr .pastdmark  
26e8 ..			.dmark: db ":0+"  
26eb f1			.pastdmark: pop af  
26ec			endm  
# End of macro DMARK
26ec				CALLMONITOR 
26ec cd c6 18			call break_point_state  
26ef				endm  
# End of macro CALLMONITOR
26ef			endif 
26ef			 
26ef				STACKFRAMECHK OFF $8efe $989f 
26ef				if DEBUG_STACK_IMB 
26ef					if OFF 
26ef						exx 
26ef						ld hl, $989f 
26ef						pop de   ; $989f 
26ef						call cmp16 
26ef						jr nz, .spnosame 
26ef						ld hl, $8efe 
26ef						pop de   ; $8efe 
26ef						call cmp16 
26ef						jr z, .spfrsame 
26ef						.spnosame: call showsperror 
26ef						.spfrsame: nop 
26ef						exx 
26ef					endif 
26ef				endif 
26ef			endm 
# End of macro STACKFRAMECHK
26ef			 
26ef c9			ret    ; dont process any remaining parser tokens as they form new word 
26f0			 
26f0			 
26f0			 
26f0			 
26f0			;		NEXT 
26f0			.SCOLN: 
26f0			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
26f0 06				db OPCODE_SCOLN 
26f1 3c 27			dw .DROP 
26f3 02				db 2 
26f4 .. 00			db ";",0           
26f6			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
26f6					if DEBUG_FORTH_WORDS_KEY 
26f6						DMARK "SCN" 
26f6 f5				push af  
26f7 3a 0b 27			ld a, (.dmark)  
26fa 32 b4 fe			ld (debug_mark),a  
26fd 3a 0c 27			ld a, (.dmark+1)  
2700 32 b5 fe			ld (debug_mark+1),a  
2703 3a 0d 27			ld a, (.dmark+2)  
2706 32 b6 fe			ld (debug_mark+2),a  
2709 18 03			jr .pastdmark  
270b ..			.dmark: db "SCN"  
270e f1			.pastdmark: pop af  
270f			endm  
# End of macro DMARK
270f						CALLMONITOR 
270f cd c6 18			call break_point_state  
2712				endm  
# End of macro CALLMONITOR
2712					endif 
2712					FORTH_RSP_TOS 
2712 cd f8 1e			call macro_forth_rsp_tos 
2715				endm 
# End of macro FORTH_RSP_TOS
2715 e5					push hl 
2716					FORTH_RSP_POP 
2716 cd 02 1f			call macro_forth_rsp_pop 
2719				endm 
# End of macro FORTH_RSP_POP
2719 e1					pop hl 
271a			;		ex de,hl 
271a 22 4f f6				ld (os_tok_ptr),hl 
271d			 
271d			if DEBUG_FORTH_UWORD 
271d						DMARK "SCL" 
271d f5				push af  
271e 3a 32 27			ld a, (.dmark)  
2721 32 b4 fe			ld (debug_mark),a  
2724 3a 33 27			ld a, (.dmark+1)  
2727 32 b5 fe			ld (debug_mark+1),a  
272a 3a 34 27			ld a, (.dmark+2)  
272d 32 b6 fe			ld (debug_mark+2),a  
2730 18 03			jr .pastdmark  
2732 ..			.dmark: db "SCL"  
2735 f1			.pastdmark: pop af  
2736			endm  
# End of macro DMARK
2736				CALLMONITOR 
2736 cd c6 18			call break_point_state  
2739				endm  
# End of macro CALLMONITOR
2739			endif 
2739					NEXTW 
2739 c3 e0 22			jp macro_next 
273c				endm 
# End of macro NEXTW
273c			 
273c			.DROP: 
273c				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
273c 1b				db WORD_SYS_CORE+OPCODE_DROP             
273d 67 27			dw .DUP2            
273f 05				db 4 + 1 
2740 .. 00			db "DROP",0              
2745				endm 
# End of macro CWHEAD
2745			; | DROP ( w -- )   drop the TOS item   | DONE 
2745					if DEBUG_FORTH_WORDS_KEY 
2745						DMARK "DRP" 
2745 f5				push af  
2746 3a 5a 27			ld a, (.dmark)  
2749 32 b4 fe			ld (debug_mark),a  
274c 3a 5b 27			ld a, (.dmark+1)  
274f 32 b5 fe			ld (debug_mark+1),a  
2752 3a 5c 27			ld a, (.dmark+2)  
2755 32 b6 fe			ld (debug_mark+2),a  
2758 18 03			jr .pastdmark  
275a ..			.dmark: db "DRP"  
275d f1			.pastdmark: pop af  
275e			endm  
# End of macro DMARK
275e						CALLMONITOR 
275e cd c6 18			call break_point_state  
2761				endm  
# End of macro CALLMONITOR
2761					endif 
2761					FORTH_DSP_POP 
2761 cd e9 21			call macro_forth_dsp_pop 
2764				endm 
# End of macro FORTH_DSP_POP
2764					NEXTW 
2764 c3 e0 22			jp macro_next 
2767				endm 
# End of macro NEXTW
2767			.DUP2: 
2767				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2767 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2768 ac 27			dw .DROP2            
276a 05				db 4 + 1 
276b .. 00			db "2DUP",0              
2770				endm 
# End of macro CWHEAD
2770			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2770					if DEBUG_FORTH_WORDS_KEY 
2770						DMARK "2DU" 
2770 f5				push af  
2771 3a 85 27			ld a, (.dmark)  
2774 32 b4 fe			ld (debug_mark),a  
2777 3a 86 27			ld a, (.dmark+1)  
277a 32 b5 fe			ld (debug_mark+1),a  
277d 3a 87 27			ld a, (.dmark+2)  
2780 32 b6 fe			ld (debug_mark+2),a  
2783 18 03			jr .pastdmark  
2785 ..			.dmark: db "2DU"  
2788 f1			.pastdmark: pop af  
2789			endm  
# End of macro DMARK
2789						CALLMONITOR 
2789 cd c6 18			call break_point_state  
278c				endm  
# End of macro CALLMONITOR
278c					endif 
278c					FORTH_DSP_VALUEHL 
278c cd 31 21			call macro_dsp_valuehl 
278f				endm 
# End of macro FORTH_DSP_VALUEHL
278f e5					push hl      ; 2 
2790			 
2790					FORTH_DSP_POP 
2790 cd e9 21			call macro_forth_dsp_pop 
2793				endm 
# End of macro FORTH_DSP_POP
2793					 
2793					FORTH_DSP_VALUEHL 
2793 cd 31 21			call macro_dsp_valuehl 
2796				endm 
# End of macro FORTH_DSP_VALUEHL
2796			;		push hl      ; 1 
2796			 
2796					FORTH_DSP_POP 
2796 cd e9 21			call macro_forth_dsp_pop 
2799				endm 
# End of macro FORTH_DSP_POP
2799			 
2799			;		pop hl       ; 1 
2799 d1					pop de       ; 2 
279a			 
279a cd 3a 1f				call forth_push_numhl 
279d eb					ex de, hl 
279e cd 3a 1f				call forth_push_numhl 
27a1			 
27a1					 
27a1 eb					ex de, hl 
27a2			 
27a2 cd 3a 1f				call forth_push_numhl 
27a5 eb					ex de, hl 
27a6 cd 3a 1f				call forth_push_numhl 
27a9			 
27a9			 
27a9					NEXTW 
27a9 c3 e0 22			jp macro_next 
27ac				endm 
# End of macro NEXTW
27ac			.DROP2: 
27ac				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
27ac 1d				db WORD_SYS_CORE+OPCODE_DROP2             
27ad db 27			dw .SWAP2            
27af 06				db 5 + 1 
27b0 .. 00			db "2DROP",0              
27b6				endm 
# End of macro CWHEAD
27b6			; | 2DROP ( w w -- )    Double drop | DONE 
27b6					if DEBUG_FORTH_WORDS_KEY 
27b6						DMARK "2DR" 
27b6 f5				push af  
27b7 3a cb 27			ld a, (.dmark)  
27ba 32 b4 fe			ld (debug_mark),a  
27bd 3a cc 27			ld a, (.dmark+1)  
27c0 32 b5 fe			ld (debug_mark+1),a  
27c3 3a cd 27			ld a, (.dmark+2)  
27c6 32 b6 fe			ld (debug_mark+2),a  
27c9 18 03			jr .pastdmark  
27cb ..			.dmark: db "2DR"  
27ce f1			.pastdmark: pop af  
27cf			endm  
# End of macro DMARK
27cf						CALLMONITOR 
27cf cd c6 18			call break_point_state  
27d2				endm  
# End of macro CALLMONITOR
27d2					endif 
27d2					FORTH_DSP_POP 
27d2 cd e9 21			call macro_forth_dsp_pop 
27d5				endm 
# End of macro FORTH_DSP_POP
27d5					FORTH_DSP_POP 
27d5 cd e9 21			call macro_forth_dsp_pop 
27d8				endm 
# End of macro FORTH_DSP_POP
27d8					NEXTW 
27d8 c3 e0 22			jp macro_next 
27db				endm 
# End of macro NEXTW
27db			.SWAP2: 
27db				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
27db 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
27dc 04 28			dw .AT            
27de 06				db 5 + 1 
27df .. 00			db "2SWAP",0              
27e5				endm 
# End of macro CWHEAD
27e5			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
27e5					if DEBUG_FORTH_WORDS_KEY 
27e5						DMARK "2SW" 
27e5 f5				push af  
27e6 3a fa 27			ld a, (.dmark)  
27e9 32 b4 fe			ld (debug_mark),a  
27ec 3a fb 27			ld a, (.dmark+1)  
27ef 32 b5 fe			ld (debug_mark+1),a  
27f2 3a fc 27			ld a, (.dmark+2)  
27f5 32 b6 fe			ld (debug_mark+2),a  
27f8 18 03			jr .pastdmark  
27fa ..			.dmark: db "2SW"  
27fd f1			.pastdmark: pop af  
27fe			endm  
# End of macro DMARK
27fe						CALLMONITOR 
27fe cd c6 18			call break_point_state  
2801				endm  
# End of macro CALLMONITOR
2801					endif 
2801					NEXTW 
2801 c3 e0 22			jp macro_next 
2804				endm 
# End of macro NEXTW
2804			.AT: 
2804				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2804 1f				db WORD_SYS_CORE+OPCODE_AT             
2805 36 28			dw .CAT            
2807 02				db 1 + 1 
2808 .. 00			db "@",0              
280a				endm 
# End of macro CWHEAD
280a			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
280a			 
280a					if DEBUG_FORTH_WORDS_KEY 
280a						DMARK "AT." 
280a f5				push af  
280b 3a 1f 28			ld a, (.dmark)  
280e 32 b4 fe			ld (debug_mark),a  
2811 3a 20 28			ld a, (.dmark+1)  
2814 32 b5 fe			ld (debug_mark+1),a  
2817 3a 21 28			ld a, (.dmark+2)  
281a 32 b6 fe			ld (debug_mark+2),a  
281d 18 03			jr .pastdmark  
281f ..			.dmark: db "AT."  
2822 f1			.pastdmark: pop af  
2823			endm  
# End of macro DMARK
2823						CALLMONITOR 
2823 cd c6 18			call break_point_state  
2826				endm  
# End of macro CALLMONITOR
2826					endif 
2826			.getbyteat:	 
2826					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2826 cd 31 21			call macro_dsp_valuehl 
2829				endm 
# End of macro FORTH_DSP_VALUEHL
2829					 
2829			;		push hl 
2829				 
2829					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2829 cd e9 21			call macro_forth_dsp_pop 
282c				endm 
# End of macro FORTH_DSP_POP
282c			 
282c			;		pop hl 
282c			 
282c 7e					ld a, (hl) 
282d			 
282d 6f					ld l, a 
282e 26 00				ld h, 0 
2830 cd 3a 1f				call forth_push_numhl 
2833			 
2833					NEXTW 
2833 c3 e0 22			jp macro_next 
2836				endm 
# End of macro NEXTW
2836			.CAT: 
2836				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2836 20				db WORD_SYS_CORE+OPCODE_CAT             
2837 5f 28			dw .BANG            
2839 03				db 2 + 1 
283a .. 00			db "C@",0              
283d				endm 
# End of macro CWHEAD
283d			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
283d					if DEBUG_FORTH_WORDS_KEY 
283d						DMARK "CAA" 
283d f5				push af  
283e 3a 52 28			ld a, (.dmark)  
2841 32 b4 fe			ld (debug_mark),a  
2844 3a 53 28			ld a, (.dmark+1)  
2847 32 b5 fe			ld (debug_mark+1),a  
284a 3a 54 28			ld a, (.dmark+2)  
284d 32 b6 fe			ld (debug_mark+2),a  
2850 18 03			jr .pastdmark  
2852 ..			.dmark: db "CAA"  
2855 f1			.pastdmark: pop af  
2856			endm  
# End of macro DMARK
2856						CALLMONITOR 
2856 cd c6 18			call break_point_state  
2859				endm  
# End of macro CALLMONITOR
2859					endif 
2859 c3 26 28				jp .getbyteat 
285c					NEXTW 
285c c3 e0 22			jp macro_next 
285f				endm 
# End of macro NEXTW
285f			.BANG: 
285f				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
285f 21				db WORD_SYS_CORE+OPCODE_BANG             
2860 95 28			dw .CBANG            
2862 02				db 1 + 1 
2863 .. 00			db "!",0              
2865				endm 
# End of macro CWHEAD
2865			; | ! ( x w -- ) Store x at address w      | DONE 
2865					if DEBUG_FORTH_WORDS_KEY 
2865						DMARK "BNG" 
2865 f5				push af  
2866 3a 7a 28			ld a, (.dmark)  
2869 32 b4 fe			ld (debug_mark),a  
286c 3a 7b 28			ld a, (.dmark+1)  
286f 32 b5 fe			ld (debug_mark+1),a  
2872 3a 7c 28			ld a, (.dmark+2)  
2875 32 b6 fe			ld (debug_mark+2),a  
2878 18 03			jr .pastdmark  
287a ..			.dmark: db "BNG"  
287d f1			.pastdmark: pop af  
287e			endm  
# End of macro DMARK
287e						CALLMONITOR 
287e cd c6 18			call break_point_state  
2881				endm  
# End of macro CALLMONITOR
2881					endif 
2881			 
2881			.storebyteat:		 
2881					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2881 cd 31 21			call macro_dsp_valuehl 
2884				endm 
# End of macro FORTH_DSP_VALUEHL
2884					 
2884 e5					push hl 
2885				 
2885					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2885 cd e9 21			call macro_forth_dsp_pop 
2888				endm 
# End of macro FORTH_DSP_POP
2888			 
2888					; get byte to poke 
2888			 
2888					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2888 cd 31 21			call macro_dsp_valuehl 
288b				endm 
# End of macro FORTH_DSP_VALUEHL
288b e5					push hl 
288c			 
288c			 
288c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
288c cd e9 21			call macro_forth_dsp_pop 
288f				endm 
# End of macro FORTH_DSP_POP
288f			 
288f			 
288f d1					pop de 
2890 e1					pop hl 
2891			 
2891 73					ld (hl),e 
2892			 
2892			 
2892					NEXTW 
2892 c3 e0 22			jp macro_next 
2895				endm 
# End of macro NEXTW
2895			.CBANG: 
2895				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2895 22				db WORD_SYS_CORE+OPCODE_CBANG             
2896 be 28			dw .SCALL            
2898 03				db 2 + 1 
2899 .. 00			db "C!",0              
289c				endm 
# End of macro CWHEAD
289c			; | C!  ( x w -- ) Store x at address w  | DONE 
289c					if DEBUG_FORTH_WORDS_KEY 
289c						DMARK "CBA" 
289c f5				push af  
289d 3a b1 28			ld a, (.dmark)  
28a0 32 b4 fe			ld (debug_mark),a  
28a3 3a b2 28			ld a, (.dmark+1)  
28a6 32 b5 fe			ld (debug_mark+1),a  
28a9 3a b3 28			ld a, (.dmark+2)  
28ac 32 b6 fe			ld (debug_mark+2),a  
28af 18 03			jr .pastdmark  
28b1 ..			.dmark: db "CBA"  
28b4 f1			.pastdmark: pop af  
28b5			endm  
# End of macro DMARK
28b5						CALLMONITOR 
28b5 cd c6 18			call break_point_state  
28b8				endm  
# End of macro CALLMONITOR
28b8					endif 
28b8 c3 81 28				jp .storebyteat 
28bb					NEXTW 
28bb c3 e0 22			jp macro_next 
28be				endm 
# End of macro NEXTW
28be			.SCALL: 
28be				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
28be 23				db WORD_SYS_CORE+OPCODE_SCALL             
28bf f2 28			dw .DEPTH            
28c1 05				db 4 + 1 
28c2 .. 00			db "CALL",0              
28c7				endm 
# End of macro CWHEAD
28c7			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
28c7					if DEBUG_FORTH_WORDS_KEY 
28c7						DMARK "CLL" 
28c7 f5				push af  
28c8 3a dc 28			ld a, (.dmark)  
28cb 32 b4 fe			ld (debug_mark),a  
28ce 3a dd 28			ld a, (.dmark+1)  
28d1 32 b5 fe			ld (debug_mark+1),a  
28d4 3a de 28			ld a, (.dmark+2)  
28d7 32 b6 fe			ld (debug_mark+2),a  
28da 18 03			jr .pastdmark  
28dc ..			.dmark: db "CLL"  
28df f1			.pastdmark: pop af  
28e0			endm  
# End of macro DMARK
28e0						CALLMONITOR 
28e0 cd c6 18			call break_point_state  
28e3				endm  
# End of macro CALLMONITOR
28e3					endif 
28e3			 
28e3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28e3 cd 31 21			call macro_dsp_valuehl 
28e6				endm 
# End of macro FORTH_DSP_VALUEHL
28e6			 
28e6			;		push hl 
28e6			 
28e6					; destroy value TOS 
28e6			 
28e6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28e6 cd e9 21			call macro_forth_dsp_pop 
28e9				endm 
# End of macro FORTH_DSP_POP
28e9			 
28e9						 
28e9			;		pop hl 
28e9			 
28e9					; how to do a call with hl???? save SP? 
28e9 cd 84 22				call forth_call_hl 
28ec			 
28ec			 
28ec					; TODO push value back onto stack for another op etc 
28ec			 
28ec cd 3a 1f				call forth_push_numhl 
28ef					NEXTW 
28ef c3 e0 22			jp macro_next 
28f2				endm 
# End of macro NEXTW
28f2			.DEPTH: 
28f2				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
28f2 24				db WORD_SYS_CORE+OPCODE_DEPTH             
28f3 2f 29			dw .OVER            
28f5 06				db 5 + 1 
28f6 .. 00			db "DEPTH",0              
28fc				endm 
# End of macro CWHEAD
28fc			; | DEPTH ( -- u ) Push count of stack | DONE 
28fc					; take current TOS and remove from base value div by two to get count 
28fc					if DEBUG_FORTH_WORDS_KEY 
28fc						DMARK "DEP" 
28fc f5				push af  
28fd 3a 11 29			ld a, (.dmark)  
2900 32 b4 fe			ld (debug_mark),a  
2903 3a 12 29			ld a, (.dmark+1)  
2906 32 b5 fe			ld (debug_mark+1),a  
2909 3a 13 29			ld a, (.dmark+2)  
290c 32 b6 fe			ld (debug_mark+2),a  
290f 18 03			jr .pastdmark  
2911 ..			.dmark: db "DEP"  
2914 f1			.pastdmark: pop af  
2915			endm  
# End of macro DMARK
2915						CALLMONITOR 
2915 cd c6 18			call break_point_state  
2918				endm  
# End of macro CALLMONITOR
2918					endif 
2918			 
2918			 
2918 2a 7b fb			ld hl, (cli_data_sp) 
291b 11 b5 f8			ld de, cli_data_stack 
291e ed 52			sbc hl,de 
2920				 
2920				; div by size of stack item 
2920			 
2920 5d				ld e,l 
2921 0e 03			ld c, 3 
2923 cd d9 0e			call Div8 
2926			 
2926 6f				ld l,a 
2927 26 00			ld h,0 
2929			 
2929				;srl h 
2929				;rr l 
2929			 
2929 cd 3a 1f				call forth_push_numhl 
292c					NEXTW 
292c c3 e0 22			jp macro_next 
292f				endm 
# End of macro NEXTW
292f			.OVER: 
292f				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
292f 42				db WORD_SYS_CORE+46             
2930 76 29			dw .PAUSE            
2932 05				db 4 + 1 
2933 .. 00			db "OVER",0              
2938				endm 
# End of macro CWHEAD
2938			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2938					if DEBUG_FORTH_WORDS_KEY 
2938						DMARK "OVR" 
2938 f5				push af  
2939 3a 4d 29			ld a, (.dmark)  
293c 32 b4 fe			ld (debug_mark),a  
293f 3a 4e 29			ld a, (.dmark+1)  
2942 32 b5 fe			ld (debug_mark+1),a  
2945 3a 4f 29			ld a, (.dmark+2)  
2948 32 b6 fe			ld (debug_mark+2),a  
294b 18 03			jr .pastdmark  
294d ..			.dmark: db "OVR"  
2950 f1			.pastdmark: pop af  
2951			endm  
# End of macro DMARK
2951						CALLMONITOR 
2951 cd c6 18			call break_point_state  
2954				endm  
# End of macro CALLMONITOR
2954					endif 
2954			 
2954					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2954 cd 31 21			call macro_dsp_valuehl 
2957				endm 
# End of macro FORTH_DSP_VALUEHL
2957 e5					push hl    ; n2 
2958					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2958 cd e9 21			call macro_forth_dsp_pop 
295b				endm 
# End of macro FORTH_DSP_POP
295b			 
295b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
295b cd 31 21			call macro_dsp_valuehl 
295e				endm 
# End of macro FORTH_DSP_VALUEHL
295e e5					push hl    ; n1 
295f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
295f cd e9 21			call macro_forth_dsp_pop 
2962				endm 
# End of macro FORTH_DSP_POP
2962			 
2962 d1					pop de     ; n1 
2963 e1					pop hl     ; n2 
2964			 
2964 d5					push de 
2965 e5					push hl 
2966 d5					push de 
2967			 
2967					; push back  
2967			 
2967 e1					pop hl 
2968 cd 3a 1f				call forth_push_numhl 
296b e1					pop hl 
296c cd 3a 1f				call forth_push_numhl 
296f e1					pop hl 
2970 cd 3a 1f				call forth_push_numhl 
2973					NEXTW 
2973 c3 e0 22			jp macro_next 
2976				endm 
# End of macro NEXTW
2976			 
2976			.PAUSE: 
2976				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2976 43				db WORD_SYS_CORE+47             
2977 ab 29			dw .PAUSES            
2979 08				db 7 + 1 
297a .. 00			db "PAUSEMS",0              
2982				endm 
# End of macro CWHEAD
2982			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2982					if DEBUG_FORTH_WORDS_KEY 
2982						DMARK "PMS" 
2982 f5				push af  
2983 3a 97 29			ld a, (.dmark)  
2986 32 b4 fe			ld (debug_mark),a  
2989 3a 98 29			ld a, (.dmark+1)  
298c 32 b5 fe			ld (debug_mark+1),a  
298f 3a 99 29			ld a, (.dmark+2)  
2992 32 b6 fe			ld (debug_mark+2),a  
2995 18 03			jr .pastdmark  
2997 ..			.dmark: db "PMS"  
299a f1			.pastdmark: pop af  
299b			endm  
# End of macro DMARK
299b						CALLMONITOR 
299b cd c6 18			call break_point_state  
299e				endm  
# End of macro CALLMONITOR
299e					endif 
299e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
299e cd 31 21			call macro_dsp_valuehl 
29a1				endm 
# End of macro FORTH_DSP_VALUEHL
29a1			;		push hl    ; n2 
29a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29a1 cd e9 21			call macro_forth_dsp_pop 
29a4				endm 
# End of macro FORTH_DSP_POP
29a4			;		pop hl 
29a4			 
29a4 7d					ld a, l 
29a5 cd 77 0c				call aDelayInMS 
29a8				       NEXTW 
29a8 c3 e0 22			jp macro_next 
29ab				endm 
# End of macro NEXTW
29ab			.PAUSES:  
29ab				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
29ab 44				db WORD_SYS_CORE+48             
29ac 1a 2a			dw .ROT            
29ae 06				db 5 + 1 
29af .. 00			db "PAUSE",0              
29b5				endm 
# End of macro CWHEAD
29b5			; | PAUSE ( n -- )  Pause for n seconds | DONE 
29b5					if DEBUG_FORTH_WORDS_KEY 
29b5						DMARK "PAU" 
29b5 f5				push af  
29b6 3a ca 29			ld a, (.dmark)  
29b9 32 b4 fe			ld (debug_mark),a  
29bc 3a cb 29			ld a, (.dmark+1)  
29bf 32 b5 fe			ld (debug_mark+1),a  
29c2 3a cc 29			ld a, (.dmark+2)  
29c5 32 b6 fe			ld (debug_mark+2),a  
29c8 18 03			jr .pastdmark  
29ca ..			.dmark: db "PAU"  
29cd f1			.pastdmark: pop af  
29ce			endm  
# End of macro DMARK
29ce						CALLMONITOR 
29ce cd c6 18			call break_point_state  
29d1				endm  
# End of macro CALLMONITOR
29d1					endif 
29d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29d1 cd 31 21			call macro_dsp_valuehl 
29d4				endm 
# End of macro FORTH_DSP_VALUEHL
29d4			;		push hl    ; n2 
29d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29d4 cd e9 21			call macro_forth_dsp_pop 
29d7				endm 
# End of macro FORTH_DSP_POP
29d7			;		pop hl 
29d7 45					ld b, l 
29d8					if DEBUG_FORTH_WORDS 
29d8						DMARK "PAU" 
29d8 f5				push af  
29d9 3a ed 29			ld a, (.dmark)  
29dc 32 b4 fe			ld (debug_mark),a  
29df 3a ee 29			ld a, (.dmark+1)  
29e2 32 b5 fe			ld (debug_mark+1),a  
29e5 3a ef 29			ld a, (.dmark+2)  
29e8 32 b6 fe			ld (debug_mark+2),a  
29eb 18 03			jr .pastdmark  
29ed ..			.dmark: db "PAU"  
29f0 f1			.pastdmark: pop af  
29f1			endm  
# End of macro DMARK
29f1						CALLMONITOR 
29f1 cd c6 18			call break_point_state  
29f4				endm  
# End of macro CALLMONITOR
29f4					endif 
29f4 c5			.pauses1:	push bc 
29f5 cd 92 0c				call delay1s 
29f8 c1					pop bc 
29f9					if DEBUG_FORTH_WORDS 
29f9						DMARK "PA1" 
29f9 f5				push af  
29fa 3a 0e 2a			ld a, (.dmark)  
29fd 32 b4 fe			ld (debug_mark),a  
2a00 3a 0f 2a			ld a, (.dmark+1)  
2a03 32 b5 fe			ld (debug_mark+1),a  
2a06 3a 10 2a			ld a, (.dmark+2)  
2a09 32 b6 fe			ld (debug_mark+2),a  
2a0c 18 03			jr .pastdmark  
2a0e ..			.dmark: db "PA1"  
2a11 f1			.pastdmark: pop af  
2a12			endm  
# End of macro DMARK
2a12						CALLMONITOR 
2a12 cd c6 18			call break_point_state  
2a15				endm  
# End of macro CALLMONITOR
2a15					endif 
2a15 10 dd				djnz .pauses1 
2a17			 
2a17				       NEXTW 
2a17 c3 e0 22			jp macro_next 
2a1a				endm 
# End of macro NEXTW
2a1a			.ROT: 
2a1a				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2a1a 45				db WORD_SYS_CORE+49             
2a1b 68 2a			dw .UWORDS            
2a1d 04				db 3 + 1 
2a1e .. 00			db "ROT",0              
2a22				endm 
# End of macro CWHEAD
2a22			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2a22					if DEBUG_FORTH_WORDS_KEY 
2a22						DMARK "ROT" 
2a22 f5				push af  
2a23 3a 37 2a			ld a, (.dmark)  
2a26 32 b4 fe			ld (debug_mark),a  
2a29 3a 38 2a			ld a, (.dmark+1)  
2a2c 32 b5 fe			ld (debug_mark+1),a  
2a2f 3a 39 2a			ld a, (.dmark+2)  
2a32 32 b6 fe			ld (debug_mark+2),a  
2a35 18 03			jr .pastdmark  
2a37 ..			.dmark: db "ROT"  
2a3a f1			.pastdmark: pop af  
2a3b			endm  
# End of macro DMARK
2a3b						CALLMONITOR 
2a3b cd c6 18			call break_point_state  
2a3e				endm  
# End of macro CALLMONITOR
2a3e					endif 
2a3e			 
2a3e					FORTH_DSP_VALUEHL 
2a3e cd 31 21			call macro_dsp_valuehl 
2a41				endm 
# End of macro FORTH_DSP_VALUEHL
2a41 e5					push hl    ; u3  
2a42			 
2a42					FORTH_DSP_POP 
2a42 cd e9 21			call macro_forth_dsp_pop 
2a45				endm 
# End of macro FORTH_DSP_POP
2a45			   
2a45					FORTH_DSP_VALUEHL 
2a45 cd 31 21			call macro_dsp_valuehl 
2a48				endm 
# End of macro FORTH_DSP_VALUEHL
2a48 e5					push hl     ; u2 
2a49			 
2a49					FORTH_DSP_POP 
2a49 cd e9 21			call macro_forth_dsp_pop 
2a4c				endm 
# End of macro FORTH_DSP_POP
2a4c			 
2a4c					FORTH_DSP_VALUEHL 
2a4c cd 31 21			call macro_dsp_valuehl 
2a4f				endm 
# End of macro FORTH_DSP_VALUEHL
2a4f e5					push hl     ; u1 
2a50			 
2a50					FORTH_DSP_POP 
2a50 cd e9 21			call macro_forth_dsp_pop 
2a53				endm 
# End of macro FORTH_DSP_POP
2a53			 
2a53 c1					pop bc      ; u1 
2a54 e1					pop hl      ; u2 
2a55 d1					pop de      ; u3 
2a56			 
2a56			 
2a56 c5					push bc 
2a57 d5					push de 
2a58 e5					push hl 
2a59			 
2a59			 
2a59 e1					pop hl 
2a5a cd 3a 1f				call forth_push_numhl 
2a5d			 
2a5d e1					pop hl 
2a5e cd 3a 1f				call forth_push_numhl 
2a61			 
2a61 e1					pop hl 
2a62 cd 3a 1f				call forth_push_numhl 
2a65					 
2a65			 
2a65			 
2a65			 
2a65			 
2a65			 
2a65				       NEXTW 
2a65 c3 e0 22			jp macro_next 
2a68				endm 
# End of macro NEXTW
2a68			 
2a68			.UWORDS: 
2a68				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2a68 50				db WORD_SYS_CORE+60             
2a69 2a 2b			dw .BP            
2a6b 07				db 6 + 1 
2a6c .. 00			db "UWORDS",0              
2a73				endm 
# End of macro CWHEAD
2a73			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2a73			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2a73			; | | Following the count are the individual words. 
2a73			; | | 
2a73			; | | e.g. UWORDS 
2a73			; | | BOX DIRLIST 2 
2a73			; | |  
2a73			; | | Can be used to save the words to storage via: 
2a73			; | | UWORDS $01 DO $01 APPEND LOOP 
2a73				if DEBUG_FORTH_WORDS_KEY 
2a73					DMARK "UWR" 
2a73 f5				push af  
2a74 3a 88 2a			ld a, (.dmark)  
2a77 32 b4 fe			ld (debug_mark),a  
2a7a 3a 89 2a			ld a, (.dmark+1)  
2a7d 32 b5 fe			ld (debug_mark+1),a  
2a80 3a 8a 2a			ld a, (.dmark+2)  
2a83 32 b6 fe			ld (debug_mark+2),a  
2a86 18 03			jr .pastdmark  
2a88 ..			.dmark: db "UWR"  
2a8b f1			.pastdmark: pop af  
2a8c			endm  
# End of macro DMARK
2a8c					CALLMONITOR 
2a8c cd c6 18			call break_point_state  
2a8f				endm  
# End of macro CALLMONITOR
2a8f				endif 
2a8f 21 00 80				ld hl, baseram 
2a92					;ld hl, baseusermem 
2a92 01 00 00				ld bc, 0    ; start a counter 
2a95			 
2a95				; skip dict stub 
2a95			 
2a95 cd 31 24				call forth_tok_next 
2a98			 
2a98			 
2a98			; while we have words to look for 
2a98			 
2a98 7e			.douscan:	ld a, (hl)      
2a99				if DEBUG_FORTH_WORDS 
2a99					DMARK "UWs" 
2a99 f5				push af  
2a9a 3a ae 2a			ld a, (.dmark)  
2a9d 32 b4 fe			ld (debug_mark),a  
2aa0 3a af 2a			ld a, (.dmark+1)  
2aa3 32 b5 fe			ld (debug_mark+1),a  
2aa6 3a b0 2a			ld a, (.dmark+2)  
2aa9 32 b6 fe			ld (debug_mark+2),a  
2aac 18 03			jr .pastdmark  
2aae ..			.dmark: db "UWs"  
2ab1 f1			.pastdmark: pop af  
2ab2			endm  
# End of macro DMARK
2ab2					CALLMONITOR 
2ab2 cd c6 18			call break_point_state  
2ab5				endm  
# End of macro CALLMONITOR
2ab5				endif 
2ab5 fe 00				cp WORD_SYS_END 
2ab7 28 4d				jr z, .udone 
2ab9 fe 01				cp WORD_SYS_UWORD 
2abb 20 44				jr nz, .nuword 
2abd			 
2abd				if DEBUG_FORTH_WORDS 
2abd					DMARK "UWu" 
2abd f5				push af  
2abe 3a d2 2a			ld a, (.dmark)  
2ac1 32 b4 fe			ld (debug_mark),a  
2ac4 3a d3 2a			ld a, (.dmark+1)  
2ac7 32 b5 fe			ld (debug_mark+1),a  
2aca 3a d4 2a			ld a, (.dmark+2)  
2acd 32 b6 fe			ld (debug_mark+2),a  
2ad0 18 03			jr .pastdmark  
2ad2 ..			.dmark: db "UWu"  
2ad5 f1			.pastdmark: pop af  
2ad6			endm  
# End of macro DMARK
2ad6					CALLMONITOR 
2ad6 cd c6 18			call break_point_state  
2ad9				endm  
# End of macro CALLMONITOR
2ad9				endif 
2ad9					; we have a uword so push its name to the stack 
2ad9			 
2ad9 e5				   	push hl  ; save so we can move to next dict block 
2ada			 
2ada					; skip opcode 
2ada 23					inc hl  
2adb					; skip next ptr 
2adb 23					inc hl  
2adc 23					inc hl 
2add					; skip len 
2add 23					inc hl 
2ade				if DEBUG_FORTH_WORDS 
2ade					DMARK "UWt" 
2ade f5				push af  
2adf 3a f3 2a			ld a, (.dmark)  
2ae2 32 b4 fe			ld (debug_mark),a  
2ae5 3a f4 2a			ld a, (.dmark+1)  
2ae8 32 b5 fe			ld (debug_mark+1),a  
2aeb 3a f5 2a			ld a, (.dmark+2)  
2aee 32 b6 fe			ld (debug_mark+2),a  
2af1 18 03			jr .pastdmark  
2af3 ..			.dmark: db "UWt"  
2af6 f1			.pastdmark: pop af  
2af7			endm  
# End of macro DMARK
2af7					CALLMONITOR 
2af7 cd c6 18			call break_point_state  
2afa				endm  
# End of macro CALLMONITOR
2afa				endif 
2afa 03					inc bc 
2afb			 
2afb c5					push bc 
2afc cd a8 1f				call forth_push_str 
2aff c1					pop bc 
2b00			 
2b00 e1					pop hl 	 
2b01			 
2b01 cd 31 24		.nuword:	call forth_tok_next 
2b04 18 92				jr .douscan  
2b06			 
2b06			.udone:		 ; push count of uwords found 
2b06 c5					push bc 
2b07 e1					pop hl 
2b08			 
2b08				if DEBUG_FORTH_WORDS 
2b08					DMARK "UWc" 
2b08 f5				push af  
2b09 3a 1d 2b			ld a, (.dmark)  
2b0c 32 b4 fe			ld (debug_mark),a  
2b0f 3a 1e 2b			ld a, (.dmark+1)  
2b12 32 b5 fe			ld (debug_mark+1),a  
2b15 3a 1f 2b			ld a, (.dmark+2)  
2b18 32 b6 fe			ld (debug_mark+2),a  
2b1b 18 03			jr .pastdmark  
2b1d ..			.dmark: db "UWc"  
2b20 f1			.pastdmark: pop af  
2b21			endm  
# End of macro DMARK
2b21					CALLMONITOR 
2b21 cd c6 18			call break_point_state  
2b24				endm  
# End of macro CALLMONITOR
2b24				endif 
2b24 cd 3a 1f				call forth_push_numhl 
2b27			 
2b27			 
2b27				       NEXTW 
2b27 c3 e0 22			jp macro_next 
2b2a				endm 
# End of macro NEXTW
2b2a			 
2b2a			.BP: 
2b2a				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2b2a 54				db WORD_SYS_CORE+64             
2b2b 60 2b			dw .MONITOR            
2b2d 03				db 2 + 1 
2b2e .. 00			db "BP",0              
2b31				endm 
# End of macro CWHEAD
2b31			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2b31			; | | $00 Will enable the break points within specific code paths 
2b31			; | | $01 Will disable break points 
2b31			; | |  
2b31			; | | By default break points are off. Either the above can be used to enable them 
2b31			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2b31			; | | and on release of the pressed key a message will be disaplayed to notify 
2b31			; | | that break points are enabled. Pressing any key will then continue boot process. 
2b31					; get byte count 
2b31					if DEBUG_FORTH_WORDS_KEY 
2b31						DMARK "BP." 
2b31 f5				push af  
2b32 3a 46 2b			ld a, (.dmark)  
2b35 32 b4 fe			ld (debug_mark),a  
2b38 3a 47 2b			ld a, (.dmark+1)  
2b3b 32 b5 fe			ld (debug_mark+1),a  
2b3e 3a 48 2b			ld a, (.dmark+2)  
2b41 32 b6 fe			ld (debug_mark+2),a  
2b44 18 03			jr .pastdmark  
2b46 ..			.dmark: db "BP."  
2b49 f1			.pastdmark: pop af  
2b4a			endm  
# End of macro DMARK
2b4a						CALLMONITOR 
2b4a cd c6 18			call break_point_state  
2b4d				endm  
# End of macro CALLMONITOR
2b4d					endif 
2b4d			 
2b4d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b4d cd 31 21			call macro_dsp_valuehl 
2b50				endm 
# End of macro FORTH_DSP_VALUEHL
2b50			 
2b50			;		push hl 
2b50			 
2b50					; destroy value TOS 
2b50			 
2b50					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b50 cd e9 21			call macro_forth_dsp_pop 
2b53				endm 
# End of macro FORTH_DSP_POP
2b53			 
2b53			;		pop hl 
2b53			 
2b53 3e 00				ld a,0 
2b55 bd					cp l 
2b56 28 02				jr z, .bpset 
2b58 3e 2a				ld a, '*' 
2b5a			 
2b5a 32 3f f3		.bpset:		ld (os_view_disable), a 
2b5d			 
2b5d			 
2b5d					NEXTW 
2b5d c3 e0 22			jp macro_next 
2b60				endm 
# End of macro NEXTW
2b60			 
2b60			 
2b60			.MONITOR: 
2b60				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2b60 55				db WORD_SYS_CORE+65             
2b61 93 2b			dw .MALLOC            
2b63 08				db 7 + 1 
2b64 .. 00			db "MONITOR",0              
2b6c				endm 
# End of macro CWHEAD
2b6c			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2b6c			; | | At start the current various registers will be displayed with contents. 
2b6c			; | | Top right corner will show the most recent debug marker seen. 
2b6c			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2b6c			; | | and the return stack pointer (RSP). 
2b6c			; | | Pressing: 
2b6c			; | |    1 - Initial screen 
2b6c			; | |    2 - Display a data dump of HL 
2b6c			; | |    3 - Display a data dump of DE 
2b6c			; | |    4 - Display a data dump of BC 
2b6c			; | |    5 - Display a data dump of HL 
2b6c			; | |    6 - Display a data dump of DSP 
2b6c			; | |    7 - Display a data dump of RSP 
2b6c			; | |    8 - Display a data dump of what is at DSP 
2b6c			; | |    9 - Display a data dump of what is at RSP 
2b6c			; | |    0 - Exit monitor and continue running. This will also enable break points 
2b6c			; | |    * - Disable break points 
2b6c			; | |    # - Enter traditional monitor mode 
2b6c			; | | 
2b6c			; | | Monitor Mode 
2b6c			; | | ------------ 
2b6c			; | | A prompt of '>' will be shown for various commands: 
2b6c			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2b6c			; | |    C - Continue display a data dump from the last set address 
2b6c			; | |    M xxxx - Set start of memory edit at address xx 
2b6c			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2b6c			; | |    Q - Return to previous 
2b6c					if DEBUG_FORTH_WORDS_KEY 
2b6c						DMARK "MON" 
2b6c f5				push af  
2b6d 3a 81 2b			ld a, (.dmark)  
2b70 32 b4 fe			ld (debug_mark),a  
2b73 3a 82 2b			ld a, (.dmark+1)  
2b76 32 b5 fe			ld (debug_mark+1),a  
2b79 3a 83 2b			ld a, (.dmark+2)  
2b7c 32 b6 fe			ld (debug_mark+2),a  
2b7f 18 03			jr .pastdmark  
2b81 ..			.dmark: db "MON"  
2b84 f1			.pastdmark: pop af  
2b85			endm  
# End of macro DMARK
2b85						CALLMONITOR 
2b85 cd c6 18			call break_point_state  
2b88				endm  
# End of macro CALLMONITOR
2b88					endif 
2b88 3e 00				ld a, 0 
2b8a 32 3f f3				ld (os_view_disable), a 
2b8d			 
2b8d					CALLMONITOR 
2b8d cd c6 18			call break_point_state  
2b90				endm  
# End of macro CALLMONITOR
2b90			 
2b90			;	call monitor 
2b90			 
2b90					NEXTW 
2b90 c3 e0 22			jp macro_next 
2b93				endm 
# End of macro NEXTW
2b93			 
2b93			 
2b93			.MALLOC: 
2b93				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2b93 56				db WORD_SYS_CORE+66             
2b94 bc 2b			dw .MALLOC2            
2b96 06				db 5 + 1 
2b97 .. 00			db "ALLOT",0              
2b9d				endm 
# End of macro CWHEAD
2b9d			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2b9d					if DEBUG_FORTH_WORDS_KEY 
2b9d						DMARK "ALL" 
2b9d f5				push af  
2b9e 3a b2 2b			ld a, (.dmark)  
2ba1 32 b4 fe			ld (debug_mark),a  
2ba4 3a b3 2b			ld a, (.dmark+1)  
2ba7 32 b5 fe			ld (debug_mark+1),a  
2baa 3a b4 2b			ld a, (.dmark+2)  
2bad 32 b6 fe			ld (debug_mark+2),a  
2bb0 18 03			jr .pastdmark  
2bb2 ..			.dmark: db "ALL"  
2bb5 f1			.pastdmark: pop af  
2bb6			endm  
# End of macro DMARK
2bb6						CALLMONITOR 
2bb6 cd c6 18			call break_point_state  
2bb9				endm  
# End of macro CALLMONITOR
2bb9					endif 
2bb9 c3 e3 2b				jp .mallocc 
2bbc			.MALLOC2: 
2bbc				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2bbc 56				db WORD_SYS_CORE+66             
2bbd fa 2b			dw .FREE            
2bbf 07				db 6 + 1 
2bc0 .. 00			db "MALLOC",0              
2bc7				endm 
# End of macro CWHEAD
2bc7			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2bc7					; get byte count 
2bc7					if DEBUG_FORTH_WORDS_KEY 
2bc7						DMARK "MAL" 
2bc7 f5				push af  
2bc8 3a dc 2b			ld a, (.dmark)  
2bcb 32 b4 fe			ld (debug_mark),a  
2bce 3a dd 2b			ld a, (.dmark+1)  
2bd1 32 b5 fe			ld (debug_mark+1),a  
2bd4 3a de 2b			ld a, (.dmark+2)  
2bd7 32 b6 fe			ld (debug_mark+2),a  
2bda 18 03			jr .pastdmark  
2bdc ..			.dmark: db "MAL"  
2bdf f1			.pastdmark: pop af  
2be0			endm  
# End of macro DMARK
2be0						CALLMONITOR 
2be0 cd c6 18			call break_point_state  
2be3				endm  
# End of macro CALLMONITOR
2be3					endif 
2be3			.mallocc: 
2be3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2be3 cd 31 21			call macro_dsp_valuehl 
2be6				endm 
# End of macro FORTH_DSP_VALUEHL
2be6			 
2be6			;		push hl 
2be6			 
2be6					; destroy value TOS 
2be6			 
2be6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2be6 cd e9 21			call macro_forth_dsp_pop 
2be9				endm 
# End of macro FORTH_DSP_POP
2be9			 
2be9			;		pop hl 
2be9 cd 10 14				call malloc 
2bec				if DEBUG_FORTH_MALLOC_GUARD 
2bec f5					push af 
2bed cd 72 0f				call ishlzero 
2bf0			;		ld a, l 
2bf0			;		add h 
2bf0			;		cp 0 
2bf0 f1					pop af 
2bf1					 
2bf1 cc c0 58				call z,malloc_error 
2bf4				endif 
2bf4			 
2bf4 cd 3a 1f				call forth_push_numhl 
2bf7					NEXTW 
2bf7 c3 e0 22			jp macro_next 
2bfa				endm 
# End of macro NEXTW
2bfa			 
2bfa			.FREE: 
2bfa				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2bfa 57				db WORD_SYS_CORE+67             
2bfb 2b 2c			dw .LIST            
2bfd 05				db 4 + 1 
2bfe .. 00			db "FREE",0              
2c03				endm 
# End of macro CWHEAD
2c03			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2c03					if DEBUG_FORTH_WORDS_KEY 
2c03						DMARK "FRE" 
2c03 f5				push af  
2c04 3a 18 2c			ld a, (.dmark)  
2c07 32 b4 fe			ld (debug_mark),a  
2c0a 3a 19 2c			ld a, (.dmark+1)  
2c0d 32 b5 fe			ld (debug_mark+1),a  
2c10 3a 1a 2c			ld a, (.dmark+2)  
2c13 32 b6 fe			ld (debug_mark+2),a  
2c16 18 03			jr .pastdmark  
2c18 ..			.dmark: db "FRE"  
2c1b f1			.pastdmark: pop af  
2c1c			endm  
# End of macro DMARK
2c1c						CALLMONITOR 
2c1c cd c6 18			call break_point_state  
2c1f				endm  
# End of macro CALLMONITOR
2c1f					endif 
2c1f					; get address 
2c1f			 
2c1f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c1f cd 31 21			call macro_dsp_valuehl 
2c22				endm 
# End of macro FORTH_DSP_VALUEHL
2c22			 
2c22			;		push hl 
2c22			 
2c22					; destroy value TOS 
2c22			 
2c22					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c22 cd e9 21			call macro_forth_dsp_pop 
2c25				endm 
# End of macro FORTH_DSP_POP
2c25			 
2c25			;		pop hl 
2c25			if FORTH_ENABLE_MALLOCFREE 
2c25 cd da 14				call free 
2c28			endif 
2c28					NEXTW 
2c28 c3 e0 22			jp macro_next 
2c2b				endm 
# End of macro NEXTW
2c2b			.LIST: 
2c2b				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2c2b 5c				db WORD_SYS_CORE+72             
2c2c 19 2e			dw .FORGET            
2c2e 05				db 4 + 1 
2c2f .. 00			db "LIST",0              
2c34				endm 
# End of macro CWHEAD
2c34			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2c34			; | | The quoted word must be in upper case. 
2c34				if DEBUG_FORTH_WORDS_KEY 
2c34					DMARK "LST" 
2c34 f5				push af  
2c35 3a 49 2c			ld a, (.dmark)  
2c38 32 b4 fe			ld (debug_mark),a  
2c3b 3a 4a 2c			ld a, (.dmark+1)  
2c3e 32 b5 fe			ld (debug_mark+1),a  
2c41 3a 4b 2c			ld a, (.dmark+2)  
2c44 32 b6 fe			ld (debug_mark+2),a  
2c47 18 03			jr .pastdmark  
2c49 ..			.dmark: db "LST"  
2c4c f1			.pastdmark: pop af  
2c4d			endm  
# End of macro DMARK
2c4d					CALLMONITOR 
2c4d cd c6 18			call break_point_state  
2c50				endm  
# End of macro CALLMONITOR
2c50				endif 
2c50			 
2c50					FORTH_DSP_VALUEHL 
2c50 cd 31 21			call macro_dsp_valuehl 
2c53				endm 
# End of macro FORTH_DSP_VALUEHL
2c53			 
2c53 e5					push hl 
2c54					FORTH_DSP_POP 
2c54 cd e9 21			call macro_forth_dsp_pop 
2c57				endm 
# End of macro FORTH_DSP_POP
2c57 c1					pop bc 
2c58			 
2c58			; Start format of scratch string 
2c58			 
2c58 21 4e f3				ld hl, scratch 
2c5b			 
2c5b 3e 3a				ld a, ':' 
2c5d 77					ld (hl),a 
2c5e 23					inc hl 
2c5f 3e 20				ld a, ' ' 
2c61 77					ld (hl), a 
2c62			 
2c62					; Get ptr to the word we need to look up 
2c62			 
2c62			;		FORTH_DSP_VALUEHL 
2c62					;v5 FORTH_DSP_VALUE 
2c62				; TODO type check 
2c62			;		inc hl    ; Skip type check  
2c62			;		push hl 
2c62			;		ex de, hl    ; put into DE 
2c62			 
2c62			 
2c62 21 00 80				ld hl, baseram 
2c65					;ld hl, baseusermem 
2c65			 
2c65 e5			push hl   ; sacreifical push 
2c66			 
2c66			.ldouscanm: 
2c66 e1				pop hl 
2c67			.ldouscan: 
2c67				if DEBUG_FORTH_WORDS 
2c67					DMARK "LSs" 
2c67 f5				push af  
2c68 3a 7c 2c			ld a, (.dmark)  
2c6b 32 b4 fe			ld (debug_mark),a  
2c6e 3a 7d 2c			ld a, (.dmark+1)  
2c71 32 b5 fe			ld (debug_mark+1),a  
2c74 3a 7e 2c			ld a, (.dmark+2)  
2c77 32 b6 fe			ld (debug_mark+2),a  
2c7a 18 03			jr .pastdmark  
2c7c ..			.dmark: db "LSs"  
2c7f f1			.pastdmark: pop af  
2c80			endm  
# End of macro DMARK
2c80					CALLMONITOR 
2c80 cd c6 18			call break_point_state  
2c83				endm  
# End of macro CALLMONITOR
2c83				endif 
2c83				; skip dict stub 
2c83 cd 31 24				call forth_tok_next 
2c86			 
2c86			 
2c86			; while we have words to look for 
2c86			 
2c86 7e				ld a, (hl)      
2c87				if DEBUG_FORTH_WORDS 
2c87					DMARK "LSk" 
2c87 f5				push af  
2c88 3a 9c 2c			ld a, (.dmark)  
2c8b 32 b4 fe			ld (debug_mark),a  
2c8e 3a 9d 2c			ld a, (.dmark+1)  
2c91 32 b5 fe			ld (debug_mark+1),a  
2c94 3a 9e 2c			ld a, (.dmark+2)  
2c97 32 b6 fe			ld (debug_mark+2),a  
2c9a 18 03			jr .pastdmark  
2c9c ..			.dmark: db "LSk"  
2c9f f1			.pastdmark: pop af  
2ca0			endm  
# End of macro DMARK
2ca0					CALLMONITOR 
2ca0 cd c6 18			call break_point_state  
2ca3				endm  
# End of macro CALLMONITOR
2ca3				endif 
2ca3					;cp WORD_SYS_END 
2ca3					;jp z, .lunotfound 
2ca3			 
2ca3					; if we hit non uwords then gone too far 
2ca3 fe 01				cp WORD_SYS_UWORD 
2ca5 c2 d5 2d				jp nz, .lunotfound 
2ca8			 
2ca8				if DEBUG_FORTH_WORDS 
2ca8					DMARK "LSu" 
2ca8 f5				push af  
2ca9 3a bd 2c			ld a, (.dmark)  
2cac 32 b4 fe			ld (debug_mark),a  
2caf 3a be 2c			ld a, (.dmark+1)  
2cb2 32 b5 fe			ld (debug_mark+1),a  
2cb5 3a bf 2c			ld a, (.dmark+2)  
2cb8 32 b6 fe			ld (debug_mark+2),a  
2cbb 18 03			jr .pastdmark  
2cbd ..			.dmark: db "LSu"  
2cc0 f1			.pastdmark: pop af  
2cc1			endm  
# End of macro DMARK
2cc1					CALLMONITOR 
2cc1 cd c6 18			call break_point_state  
2cc4				endm  
# End of macro CALLMONITOR
2cc4				endif 
2cc4			 
2cc4					; found a uword but is it the one we want... 
2cc4			 
2cc4 c5					push bc     ; uword to find is on bc 
2cc5 d1					pop de 
2cc6			 
2cc6 e5					push hl  ; to save the ptr 
2cc7			 
2cc7					; skip opcode 
2cc7 23					inc hl  
2cc8					; skip next ptr 
2cc8 23					inc hl  
2cc9 23					inc hl 
2cca					; skip len 
2cca 23					inc hl 
2ccb			 
2ccb				if DEBUG_FORTH_WORDS 
2ccb					DMARK "LSc" 
2ccb f5				push af  
2ccc 3a e0 2c			ld a, (.dmark)  
2ccf 32 b4 fe			ld (debug_mark),a  
2cd2 3a e1 2c			ld a, (.dmark+1)  
2cd5 32 b5 fe			ld (debug_mark+1),a  
2cd8 3a e2 2c			ld a, (.dmark+2)  
2cdb 32 b6 fe			ld (debug_mark+2),a  
2cde 18 03			jr .pastdmark  
2ce0 ..			.dmark: db "LSc"  
2ce3 f1			.pastdmark: pop af  
2ce4			endm  
# End of macro DMARK
2ce4					CALLMONITOR 
2ce4 cd c6 18			call break_point_state  
2ce7				endm  
# End of macro CALLMONITOR
2ce7				endif 
2ce7 cd df 13				call strcmp 
2cea c2 66 2c				jp nz, .ldouscanm 
2ced				 
2ced			 
2ced			 
2ced					; we have a uword so push its name to the stack 
2ced			 
2ced			;	   	push hl  ; save so we can move to next dict block 
2ced e1			pop hl 
2cee			 
2cee				if DEBUG_FORTH_WORDS 
2cee					DMARK "LSm" 
2cee f5				push af  
2cef 3a 03 2d			ld a, (.dmark)  
2cf2 32 b4 fe			ld (debug_mark),a  
2cf5 3a 04 2d			ld a, (.dmark+1)  
2cf8 32 b5 fe			ld (debug_mark+1),a  
2cfb 3a 05 2d			ld a, (.dmark+2)  
2cfe 32 b6 fe			ld (debug_mark+2),a  
2d01 18 03			jr .pastdmark  
2d03 ..			.dmark: db "LSm"  
2d06 f1			.pastdmark: pop af  
2d07			endm  
# End of macro DMARK
2d07					CALLMONITOR 
2d07 cd c6 18			call break_point_state  
2d0a				endm  
# End of macro CALLMONITOR
2d0a				endif 
2d0a			 
2d0a					; skip opcode 
2d0a 23					inc hl  
2d0b					; skip next ptr 
2d0b 23					inc hl  
2d0c 23					inc hl 
2d0d					; skip len 
2d0d 7e					ld a, (hl)   ; save length to add 
2d0e				if DEBUG_FORTH_WORDS 
2d0e					DMARK "LS2" 
2d0e f5				push af  
2d0f 3a 23 2d			ld a, (.dmark)  
2d12 32 b4 fe			ld (debug_mark),a  
2d15 3a 24 2d			ld a, (.dmark+1)  
2d18 32 b5 fe			ld (debug_mark+1),a  
2d1b 3a 25 2d			ld a, (.dmark+2)  
2d1e 32 b6 fe			ld (debug_mark+2),a  
2d21 18 03			jr .pastdmark  
2d23 ..			.dmark: db "LS2"  
2d26 f1			.pastdmark: pop af  
2d27			endm  
# End of macro DMARK
2d27					CALLMONITOR 
2d27 cd c6 18			call break_point_state  
2d2a				endm  
# End of macro CALLMONITOR
2d2a				endif 
2d2a			 
2d2a					; save this location 
2d2a				 
2d2a e5					push hl 
2d2b			 
2d2b 23					inc hl 
2d2c 11 50 f3				ld de, scratch+2 
2d2f 4f					ld c, a 
2d30 06 00				ld b, 0 
2d32			 
2d32				if DEBUG_FORTH_WORDS 
2d32					DMARK "LSn" 
2d32 f5				push af  
2d33 3a 47 2d			ld a, (.dmark)  
2d36 32 b4 fe			ld (debug_mark),a  
2d39 3a 48 2d			ld a, (.dmark+1)  
2d3c 32 b5 fe			ld (debug_mark+1),a  
2d3f 3a 49 2d			ld a, (.dmark+2)  
2d42 32 b6 fe			ld (debug_mark+2),a  
2d45 18 03			jr .pastdmark  
2d47 ..			.dmark: db "LSn"  
2d4a f1			.pastdmark: pop af  
2d4b			endm  
# End of macro DMARK
2d4b					CALLMONITOR 
2d4b cd c6 18			call break_point_state  
2d4e				endm  
# End of macro CALLMONITOR
2d4e				endif 
2d4e			 
2d4e					; copy uword name to scratch 
2d4e			 
2d4e ed b0				ldir 
2d50			 
2d50 1b					dec de 
2d51 3e 20				ld a, ' '    ; change null to space 
2d53 12					ld (de), a 
2d54			 
2d54 13					inc de 
2d55			 
2d55 d5					push de 
2d56 c1					pop bc     ; move scratch pointer to end of word name and save it 
2d57			 
2d57 e1					pop hl 
2d58 7e					ld a, (hl) 
2d59					;inc hl 
2d59					; skip word string 
2d59 cd 49 0f				call addatohl 
2d5c			 
2d5c 23					inc hl 
2d5d			 
2d5d				if DEBUG_FORTH_WORDS 
2d5d					DMARK "LS3" 
2d5d f5				push af  
2d5e 3a 72 2d			ld a, (.dmark)  
2d61 32 b4 fe			ld (debug_mark),a  
2d64 3a 73 2d			ld a, (.dmark+1)  
2d67 32 b5 fe			ld (debug_mark+1),a  
2d6a 3a 74 2d			ld a, (.dmark+2)  
2d6d 32 b6 fe			ld (debug_mark+2),a  
2d70 18 03			jr .pastdmark  
2d72 ..			.dmark: db "LS3"  
2d75 f1			.pastdmark: pop af  
2d76			endm  
# End of macro DMARK
2d76					CALLMONITOR 
2d76 cd c6 18			call break_point_state  
2d79				endm  
# End of macro CALLMONITOR
2d79				endif 
2d79					; should now be at the start of the machine code to setup the eval of the uword 
2d79					; now locate the ptr to the string defintion 
2d79			 
2d79					; skip ld hl, 
2d79					; then load the ptr 
2d79			; TODO use get from hl ptr 
2d79 23					inc hl 
2d7a 5e					ld e, (hl) 
2d7b 23					inc hl 
2d7c 56					ld d, (hl) 
2d7d eb					ex de, hl 
2d7e			 
2d7e			 
2d7e				if DEBUG_FORTH_WORDS 
2d7e					DMARK "LSt" 
2d7e f5				push af  
2d7f 3a 93 2d			ld a, (.dmark)  
2d82 32 b4 fe			ld (debug_mark),a  
2d85 3a 94 2d			ld a, (.dmark+1)  
2d88 32 b5 fe			ld (debug_mark+1),a  
2d8b 3a 95 2d			ld a, (.dmark+2)  
2d8e 32 b6 fe			ld (debug_mark+2),a  
2d91 18 03			jr .pastdmark  
2d93 ..			.dmark: db "LSt"  
2d96 f1			.pastdmark: pop af  
2d97			endm  
# End of macro DMARK
2d97					CALLMONITOR 
2d97 cd c6 18			call break_point_state  
2d9a				endm  
# End of macro CALLMONITOR
2d9a				endif 
2d9a			 
2d9a			; cant push right now due to tokenised strings  
2d9a			 
2d9a			; get the destination of where to copy this definition to. 
2d9a			 
2d9a c5					push bc 
2d9b d1					pop de 
2d9c			 
2d9c 7e			.listl:         ld a,(hl) 
2d9d fe 00				cp 0 
2d9f 28 09				jr z, .lreplsp     ; replace zero with space 
2da1					;cp FORTH_END_BUFFER 
2da1 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2da3 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2da5				 
2da5					; just copy this char as is then 
2da5			 
2da5 12					ld (de), a 
2da6			 
2da6 23			.listnxt:	inc hl 
2da7 13					inc de 
2da8 18 f2				jr .listl 
2daa			 
2daa 3e 20		.lreplsp:	ld a,' ' 
2dac 12					ld (de), a 
2dad 18 f7				jr .listnxt 
2daf			 
2daf			; close up uword def 
2daf			 
2daf			.listdone: 
2daf 12					ld (de), a 
2db0 13					inc de 
2db1 3e 00				ld a, 0 
2db3 12					ld (de), a 
2db4			 
2db4			; now have def so clean up and push to stack 
2db4			 
2db4 21 4e f3				ld hl, scratch 
2db7				if DEBUG_FORTH_WORDS 
2db7					DMARK "Ltp" 
2db7 f5				push af  
2db8 3a cc 2d			ld a, (.dmark)  
2dbb 32 b4 fe			ld (debug_mark),a  
2dbe 3a cd 2d			ld a, (.dmark+1)  
2dc1 32 b5 fe			ld (debug_mark+1),a  
2dc4 3a ce 2d			ld a, (.dmark+2)  
2dc7 32 b6 fe			ld (debug_mark+2),a  
2dca 18 03			jr .pastdmark  
2dcc ..			.dmark: db "Ltp"  
2dcf f1			.pastdmark: pop af  
2dd0			endm  
# End of macro DMARK
2dd0					CALLMONITOR 
2dd0 cd c6 18			call break_point_state  
2dd3				endm  
# End of macro CALLMONITOR
2dd3				endif 
2dd3			 
2dd3 18 1f			jr .listpush 
2dd5			 
2dd5			;.lnuword:	pop hl 
2dd5			;		call forth_tok_next 
2dd5			;		jp .ldouscan  
2dd5			 
2dd5			.lunotfound:		  
2dd5			 
2dd5				if DEBUG_FORTH_WORDS 
2dd5					DMARK "LSn" 
2dd5 f5				push af  
2dd6 3a ea 2d			ld a, (.dmark)  
2dd9 32 b4 fe			ld (debug_mark),a  
2ddc 3a eb 2d			ld a, (.dmark+1)  
2ddf 32 b5 fe			ld (debug_mark+1),a  
2de2 3a ec 2d			ld a, (.dmark+2)  
2de5 32 b6 fe			ld (debug_mark+2),a  
2de8 18 03			jr .pastdmark  
2dea ..			.dmark: db "LSn"  
2ded f1			.pastdmark: pop af  
2dee			endm  
# End of macro DMARK
2dee					CALLMONITOR 
2dee cd c6 18			call break_point_state  
2df1				endm  
# End of macro CALLMONITOR
2df1				endif 
2df1			 
2df1					 
2df1			;		FORTH_DSP_POP 
2df1			;		ld hl, .luno 
2df1			 
2df1					NEXTW			 
2df1 c3 e0 22			jp macro_next 
2df4				endm 
# End of macro NEXTW
2df4			 
2df4			.listpush: 
2df4				if DEBUG_FORTH_WORDS 
2df4					DMARK "LS>" 
2df4 f5				push af  
2df5 3a 09 2e			ld a, (.dmark)  
2df8 32 b4 fe			ld (debug_mark),a  
2dfb 3a 0a 2e			ld a, (.dmark+1)  
2dfe 32 b5 fe			ld (debug_mark+1),a  
2e01 3a 0b 2e			ld a, (.dmark+2)  
2e04 32 b6 fe			ld (debug_mark+2),a  
2e07 18 03			jr .pastdmark  
2e09 ..			.dmark: db "LS>"  
2e0c f1			.pastdmark: pop af  
2e0d			endm  
# End of macro DMARK
2e0d					CALLMONITOR 
2e0d cd c6 18			call break_point_state  
2e10				endm  
# End of macro CALLMONITOR
2e10				endif 
2e10 cd a8 1f				call forth_push_str 
2e13			 
2e13			 
2e13			 
2e13					NEXTW 
2e13 c3 e0 22			jp macro_next 
2e16				endm 
# End of macro NEXTW
2e16			 
2e16			;.luno:    db "Word not found",0 
2e16			 
2e16			 
2e16			 
2e16			 
2e16			 
2e16			;		push hl   ; save pointer to start of uword def string 
2e16			; 
2e16			;; look for FORTH_EOL_LINE 
2e16			;		ld a, FORTH_END_BUFFER 
2e16			;		call strlent 
2e16			; 
2e16			;		inc hl		 ; space for coln def 
2e16			;		inc hl 
2e16			;		inc hl          ; space for terms 
2e16			;		inc hl 
2e16			; 
2e16			;		ld a, 20   ; TODO get actual length 
2e16			;		call addatohl    ; include a random amount of room for the uword name 
2e16			; 
2e16			;		 
2e16			;	if DEBUG_FORTH_WORDS 
2e16			;		DMARK "Lt1" 
2e16			;		CALLMONITOR 
2e16			;	endif 
2e16			;		 
2e16			; 
2e16			;; malloc space for the string because we cant change it 
2e16			; 
2e16			;		call malloc 
2e16			;	if DEBUG_FORTH_MALLOC_GUARD 
2e16			;		push af 
2e16			;		call ishlzero 
2e16			;		pop af 
2e16			;		 
2e16			;		call z,malloc_error 
2e16			;	endif 
2e16			; 
2e16			;	if DEBUG_FORTH_WORDS 
2e16			;		DMARK "Lt2" 
2e16			;		CALLMONITOR 
2e16			;	endif 
2e16			;		pop de 
2e16			;		push hl    ; push the malloc to release later 
2e16			;		push hl   ;  push back a copy for the later stack push 
2e16			;		 
2e16			;; copy the string swapping out the zero terms for spaces 
2e16			; 
2e16			;		; de has our source 
2e16			;		; hl has our dest 
2e16			; 
2e16			;; add the coln def 
2e16			; 
2e16			;		ld a, ':' 
2e16			;		ld (hl), a 
2e16			;		inc hl 
2e16			;		ld a, ' ' 
2e16			;		ld (hl), a 
2e16			;		inc hl 
2e16			; 
2e16			;; add the uname word 
2e16			;		push de   ; save our string for now 
2e16			;		ex de, hl 
2e16			; 
2e16			;		FORTH_DSP_VALUE 
2e16			;		;v5 FORTH_DSP_VALUE 
2e16			; 
2e16			;		inc hl   ; skip type but we know by now this is OK 
2e16			; 
2e16			;.luword:	ld a,(hl) 
2e16			;		cp 0 
2e16			;		jr z, .luword2 
2e16			;		ld (de), a 
2e16			;		inc de 
2e16			;		inc hl 
2e16			;		jr .luword 
2e16			; 
2e16			;.luword2:	ld a, ' ' 
2e16			;		ld (de), a 
2e16			;;		inc hl 
2e16			;;		inc de 
2e16			;;		ld (de), a 
2e16			;;		inc hl 
2e16			;		inc de 
2e16			; 
2e16			;		ex de, hl 
2e16			;		pop de 
2e16			;		 
2e16			;		 
2e16			; 
2e16			;; detoken that string and copy it 
2e16			; 
2e16			;	if DEBUG_FORTH_WORDS 
2e16			;		DMARK "Lt2" 
2e16			;		CALLMONITOR 
2e16			;	endif 
2e16			;.ldetok:	ld a, (de) 
2e16			;		cp FORTH_END_BUFFER 
2e16			;		jr z, .ldetokend 
2e16			;		; swap out any zero term for space 
2e16			;		cp 0 
2e16			;		jr nz, .ldetoknext 
2e16			;		ld a, ' ' 
2e16			; 
2e16			;	if DEBUG_FORTH_WORDS 
2e16			;		DMARK "LtS" 
2e16			;		CALLMONITOR 
2e16			;	endif 
2e16			;.ldetoknext:	ld (hl), a 
2e16			;		inc de 
2e16			;		inc hl 
2e16			;		jr .ldetok 
2e16			; 
2e16			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2e16			;		ld (hl), a  
2e16			; 
2e16			;; free that temp malloc 
2e16			; 
2e16			;		pop hl    
2e16			; 
2e16			;	if DEBUG_FORTH_WORDS 
2e16			;		DMARK "Lt4" 
2e16			;		CALLMONITOR 
2e16			;	endif 
2e16			;		call forth_apushstrhl 
2e16			; 
2e16			;		; get rid of temp malloc area 
2e16			; 
2e16			;		pop hl 
2e16			;		call free 
2e16			; 
2e16			;		jr .ludone 
2e16			; 
2e16			;.lnuword:	pop hl 
2e16			;		call forth_tok_next 
2e16			;		jp .ldouscan  
2e16			; 
2e16			;.ludone:		 pop hl 
2e16			; 
2e16					NEXTW 
2e16 c3 e0 22			jp macro_next 
2e19				endm 
# End of macro NEXTW
2e19			 
2e19			.FORGET: 
2e19				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2e19 5d				db WORD_SYS_CORE+73             
2e1a 92 2e			dw .NOP            
2e1c 07				db 6 + 1 
2e1d .. 00			db "FORGET",0              
2e24				endm 
# End of macro CWHEAD
2e24			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2e24			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2e24			; | |  
2e24			; | | e.g. "MORE" forget 
2e24					if DEBUG_FORTH_WORDS_KEY 
2e24						DMARK "FRG" 
2e24 f5				push af  
2e25 3a 39 2e			ld a, (.dmark)  
2e28 32 b4 fe			ld (debug_mark),a  
2e2b 3a 3a 2e			ld a, (.dmark+1)  
2e2e 32 b5 fe			ld (debug_mark+1),a  
2e31 3a 3b 2e			ld a, (.dmark+2)  
2e34 32 b6 fe			ld (debug_mark+2),a  
2e37 18 03			jr .pastdmark  
2e39 ..			.dmark: db "FRG"  
2e3c f1			.pastdmark: pop af  
2e3d			endm  
# End of macro DMARK
2e3d						CALLMONITOR 
2e3d cd c6 18			call break_point_state  
2e40				endm  
# End of macro CALLMONITOR
2e40					endif 
2e40			 
2e40				; find uword 
2e40			        ; update start of word with "_" 
2e40				; replace uword with deleted flag 
2e40			 
2e40			 
2e40			;	if DEBUG_FORTH_WORDS 
2e40			;		DMARK "FOG" 
2e40			;		CALLMONITOR 
2e40			;	endif 
2e40			 
2e40			 
2e40					; Get ptr to the word we need to look up 
2e40			 
2e40					FORTH_DSP_VALUEHL 
2e40 cd 31 21			call macro_dsp_valuehl 
2e43				endm 
# End of macro FORTH_DSP_VALUEHL
2e43					;v5 FORTH_DSP_VALUE 
2e43				; TODO type check 
2e43			;		inc hl    ; Skip type check  
2e43 e5					push hl 
2e44 c1					pop bc 
2e45			;		ex de, hl    ; put into DE 
2e45			 
2e45			 
2e45 21 00 80				ld hl, baseram 
2e48					;ld hl, baseusermem 
2e48			 
2e48				; skip dict stub 
2e48			;	call forth_tok_next 
2e48 e5			push hl   ; sacreifical push 
2e49			 
2e49			.fldouscanm: 
2e49 e1				pop hl 
2e4a			.fldouscan: 
2e4a			;	if DEBUG_FORTH_WORDS 
2e4a			;		DMARK "LSs" 
2e4a			;		CALLMONITOR 
2e4a			;	endif 
2e4a				; skip dict stub 
2e4a cd 31 24				call forth_tok_next 
2e4d			 
2e4d			 
2e4d			; while we have words to look for 
2e4d			 
2e4d 7e				ld a, (hl)      
2e4e			;	if DEBUG_FORTH_WORDS 
2e4e			;		DMARK "LSk" 
2e4e			;		CALLMONITOR 
2e4e			;	endif 
2e4e fe 00				cp WORD_SYS_END 
2e50 ca 8c 2e				jp z, .flunotfound 
2e53 fe 01				cp WORD_SYS_UWORD 
2e55 c2 4a 2e				jp nz, .fldouscan 
2e58			 
2e58			;	if DEBUG_FORTH_WORDS 
2e58			;		DMARK "LSu" 
2e58			;		CALLMONITOR 
2e58			;	endif 
2e58			 
2e58					; found a uword but is it the one we want... 
2e58			 
2e58 c5					push bc     ; uword to find is on bc 
2e59 d1					pop de 
2e5a			 
2e5a e5					push hl  ; to save the ptr 
2e5b			 
2e5b					; skip opcode 
2e5b 23					inc hl  
2e5c					; skip next ptr 
2e5c 23					inc hl  
2e5d 23					inc hl 
2e5e					; skip len 
2e5e 23					inc hl 
2e5f			 
2e5f			;	if DEBUG_FORTH_WORDS 
2e5f			;		DMARK "LSc" 
2e5f			;		CALLMONITOR 
2e5f			;	endif 
2e5f cd df 13				call strcmp 
2e62 c2 49 2e				jp nz, .fldouscanm 
2e65			; 
2e65			; 
2e65			;; while we have words to look for 
2e65			; 
2e65			;.fdouscan:	ld a, (hl)      
2e65			;	if DEBUG_FORTH_WORDS 
2e65			;		DMARK "LSs" 
2e65			;		CALLMONITOR 
2e65			;	endif 
2e65			;		cp WORD_SYS_END 
2e65			;		jp z, .fudone 
2e65			;		cp WORD_SYS_UWORD 
2e65			;		jp nz, .fnuword 
2e65			; 
2e65			;	if DEBUG_FORTH_WORDS 
2e65			;		DMARK "FGu" 
2e65			;		CALLMONITOR 
2e65			;	endif 
2e65			; 
2e65			;		; found a uword but is it the one we want... 
2e65			; 
2e65			; 
2e65			;	        pop de   ; get back the dsp name 
2e65			;		push de 
2e65			; 
2e65			;		push hl  ; to save the ptr 
2e65			; 
2e65			;		; skip opcode 
2e65			;		inc hl  
2e65			;		; skip next ptr 
2e65			;		inc hl  
2e65			;		inc hl 
2e65			;		; skip len 
2e65			;		inc hl 
2e65			; 
2e65			;	if DEBUG_FORTH_WORDS 
2e65			;		DMARK "FGc" 
2e65			;		CALLMONITOR 
2e65			;	endif 
2e65			;		call strcmp 
2e65			;		jp nz, .fnuword 
2e65			 
2e65			 
2e65 e1			pop hl 
2e66			 
2e66				 
2e66				if DEBUG_FORTH_WORDS 
2e66					DMARK "FGm" 
2e66 f5				push af  
2e67 3a 7b 2e			ld a, (.dmark)  
2e6a 32 b4 fe			ld (debug_mark),a  
2e6d 3a 7c 2e			ld a, (.dmark+1)  
2e70 32 b5 fe			ld (debug_mark+1),a  
2e73 3a 7d 2e			ld a, (.dmark+2)  
2e76 32 b6 fe			ld (debug_mark+2),a  
2e79 18 03			jr .pastdmark  
2e7b ..			.dmark: db "FGm"  
2e7e f1			.pastdmark: pop af  
2e7f			endm  
# End of macro DMARK
2e7f					CALLMONITOR 
2e7f cd c6 18			call break_point_state  
2e82				endm  
# End of macro CALLMONITOR
2e82				endif 
2e82			 
2e82			 
2e82			 
2e82					; we have a uword so push its name to the stack 
2e82			 
2e82			;	   	push hl  ; save so we can move to next dict block 
2e82			;pop hl 
2e82			 
2e82					; update opcode to deleted 
2e82 3e 03				ld a, WORD_SYS_DELETED 
2e84 77					ld (hl), a 
2e85			 
2e85 23					inc hl  
2e86					; skip next ptr 
2e86 23					inc hl  
2e87 23					inc hl 
2e88					; skip len 
2e88 23					inc hl 
2e89			 
2e89					; TODO change parser to skip deleted words but for now mark it out 
2e89 3e 5f				ld a, "_" 
2e8b 77					ld  (hl),a 
2e8c			 
2e8c			;		jr .fudone 
2e8c			; 
2e8c			;.fnuword:	pop hl 
2e8c			;		call forth_tok_next 
2e8c			;		jp .fdouscan  
2e8c			 
2e8c			.flunotfound:		  
2e8c			 
2e8c			 
2e8c					 
2e8c					FORTH_DSP_POP 
2e8c cd e9 21			call macro_forth_dsp_pop 
2e8f				endm 
# End of macro FORTH_DSP_POP
2e8f			;		ld hl, .luno 
2e8f			;.fudone:		 pop hl 
2e8f					NEXTW 
2e8f c3 e0 22			jp macro_next 
2e92				endm 
# End of macro NEXTW
2e92			.NOP: 
2e92				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2e92 61				db WORD_SYS_CORE+77             
2e93 b9 2e			dw .COMO            
2e95 04				db 3 + 1 
2e96 .. 00			db "NOP",0              
2e9a				endm 
# End of macro CWHEAD
2e9a			; | NOP (  --  ) Do nothing | DONE 
2e9a					if DEBUG_FORTH_WORDS_KEY 
2e9a						DMARK "NOP" 
2e9a f5				push af  
2e9b 3a af 2e			ld a, (.dmark)  
2e9e 32 b4 fe			ld (debug_mark),a  
2ea1 3a b0 2e			ld a, (.dmark+1)  
2ea4 32 b5 fe			ld (debug_mark+1),a  
2ea7 3a b1 2e			ld a, (.dmark+2)  
2eaa 32 b6 fe			ld (debug_mark+2),a  
2ead 18 03			jr .pastdmark  
2eaf ..			.dmark: db "NOP"  
2eb2 f1			.pastdmark: pop af  
2eb3			endm  
# End of macro DMARK
2eb3						CALLMONITOR 
2eb3 cd c6 18			call break_point_state  
2eb6				endm  
# End of macro CALLMONITOR
2eb6					endif 
2eb6				       NEXTW 
2eb6 c3 e0 22			jp macro_next 
2eb9				endm 
# End of macro NEXTW
2eb9			.COMO: 
2eb9				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2eb9 6e				db WORD_SYS_CORE+90             
2eba 0b 2f			dw .COMC            
2ebc 02				db 1 + 1 
2ebd .. 00			db "(",0              
2ebf				endm 
# End of macro CWHEAD
2ebf			; | ( ( -- )  Start of comment | DONE 
2ebf			 
2ebf			 
2ebf 2a 4f f6				ld hl, ( os_tok_ptr) 
2ec2 11 06 2f			ld de, .closepar 
2ec5					 
2ec5					if DEBUG_FORTH_WORDS 
2ec5						DMARK ").." 
2ec5 f5				push af  
2ec6 3a da 2e			ld a, (.dmark)  
2ec9 32 b4 fe			ld (debug_mark),a  
2ecc 3a db 2e			ld a, (.dmark+1)  
2ecf 32 b5 fe			ld (debug_mark+1),a  
2ed2 3a dc 2e			ld a, (.dmark+2)  
2ed5 32 b6 fe			ld (debug_mark+2),a  
2ed8 18 03			jr .pastdmark  
2eda ..			.dmark: db ").."  
2edd f1			.pastdmark: pop af  
2ede			endm  
# End of macro DMARK
2ede						CALLMONITOR 
2ede cd c6 18			call break_point_state  
2ee1				endm  
# End of macro CALLMONITOR
2ee1					endif 
2ee1 cd fb 23			call findnexttok  
2ee4			 
2ee4					if DEBUG_FORTH_WORDS 
2ee4						DMARK "IF5" 
2ee4 f5				push af  
2ee5 3a f9 2e			ld a, (.dmark)  
2ee8 32 b4 fe			ld (debug_mark),a  
2eeb 3a fa 2e			ld a, (.dmark+1)  
2eee 32 b5 fe			ld (debug_mark+1),a  
2ef1 3a fb 2e			ld a, (.dmark+2)  
2ef4 32 b6 fe			ld (debug_mark+2),a  
2ef7 18 03			jr .pastdmark  
2ef9 ..			.dmark: db "IF5"  
2efc f1			.pastdmark: pop af  
2efd			endm  
# End of macro DMARK
2efd						CALLMONITOR 
2efd cd c6 18			call break_point_state  
2f00				endm  
# End of macro CALLMONITOR
2f00					endif 
2f00				; replace below with ) exec using tok_ptr 
2f00 22 4f f6			ld (os_tok_ptr), hl 
2f03 c3 71 23			jp exec1 
2f06			 
2f06 .. 00			.closepar:   db ")",0 
2f08			 
2f08				       NEXTW 
2f08 c3 e0 22			jp macro_next 
2f0b				endm 
# End of macro NEXTW
2f0b			.COMC: 
2f0b				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2f0b 6f				db WORD_SYS_CORE+91             
2f0c 14 2f			dw .SCRATCH            
2f0e 02				db 1 + 1 
2f0f .. 00			db ")",0              
2f11				endm 
# End of macro CWHEAD
2f11			; | ) ( -- )  End of comment |  DONE  
2f11				       NEXTW 
2f11 c3 e0 22			jp macro_next 
2f14				endm 
# End of macro NEXTW
2f14			 
2f14			.SCRATCH: 
2f14				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2f14 6f				db WORD_SYS_CORE+91             
2f15 4f 2f			dw .INC            
2f17 08				db 7 + 1 
2f18 .. 00			db "SCRATCH",0              
2f20				endm 
# End of macro CWHEAD
2f20			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2f20			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2f20			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2f20			; | |  
2f20			; | | e.g.    : score $00 scratch ; 
2f20			; | |  
2f20			; | | $00 score ! 
2f20			; | | $01 score +! 
2f20			; | |  
2f20			; | | e.g.   : varword $0a scratch ;  
2f20			; | | 
2f20			; | | $8000 varword ! 
2f20					if DEBUG_FORTH_WORDS_KEY 
2f20						DMARK "SCR" 
2f20 f5				push af  
2f21 3a 35 2f			ld a, (.dmark)  
2f24 32 b4 fe			ld (debug_mark),a  
2f27 3a 36 2f			ld a, (.dmark+1)  
2f2a 32 b5 fe			ld (debug_mark+1),a  
2f2d 3a 37 2f			ld a, (.dmark+2)  
2f30 32 b6 fe			ld (debug_mark+2),a  
2f33 18 03			jr .pastdmark  
2f35 ..			.dmark: db "SCR"  
2f38 f1			.pastdmark: pop af  
2f39			endm  
# End of macro DMARK
2f39						CALLMONITOR 
2f39 cd c6 18			call break_point_state  
2f3c				endm  
# End of macro CALLMONITOR
2f3c					endif 
2f3c			 
2f3c					FORTH_DSP_VALUEHL 
2f3c cd 31 21			call macro_dsp_valuehl 
2f3f				endm 
# End of macro FORTH_DSP_VALUEHL
2f3f				 
2f3f					FORTH_DSP_POP 
2f3f cd e9 21			call macro_forth_dsp_pop 
2f42				endm 
# End of macro FORTH_DSP_POP
2f42			 
2f42 7d					ld a, l 
2f43 21 73 f8				ld hl, os_var_array 
2f46 cd 49 0f				call addatohl 
2f49			 
2f49 cd 3a 1f				call forth_push_numhl 
2f4c			 
2f4c				       NEXTW 
2f4c c3 e0 22			jp macro_next 
2f4f				endm 
# End of macro NEXTW
2f4f			 
2f4f			.INC: 
2f4f				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2f4f 6f				db WORD_SYS_CORE+91             
2f50 a3 2f			dw .DEC            
2f52 03				db 2 + 1 
2f53 .. 00			db "+!",0              
2f56				endm 
# End of macro CWHEAD
2f56			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2f56					if DEBUG_FORTH_WORDS_KEY 
2f56						DMARK "+s_" 
2f56 f5				push af  
2f57 3a 6b 2f			ld a, (.dmark)  
2f5a 32 b4 fe			ld (debug_mark),a  
2f5d 3a 6c 2f			ld a, (.dmark+1)  
2f60 32 b5 fe			ld (debug_mark+1),a  
2f63 3a 6d 2f			ld a, (.dmark+2)  
2f66 32 b6 fe			ld (debug_mark+2),a  
2f69 18 03			jr .pastdmark  
2f6b ..			.dmark: db "+s_"  
2f6e f1			.pastdmark: pop af  
2f6f			endm  
# End of macro DMARK
2f6f						CALLMONITOR 
2f6f cd c6 18			call break_point_state  
2f72				endm  
# End of macro CALLMONITOR
2f72					endif 
2f72			 
2f72					FORTH_DSP_VALUEHL 
2f72 cd 31 21			call macro_dsp_valuehl 
2f75				endm 
# End of macro FORTH_DSP_VALUEHL
2f75			 
2f75 e5					push hl   ; save address 
2f76			 
2f76					FORTH_DSP_POP 
2f76 cd e9 21			call macro_forth_dsp_pop 
2f79				endm 
# End of macro FORTH_DSP_POP
2f79			 
2f79					FORTH_DSP_VALUEHL 
2f79 cd 31 21			call macro_dsp_valuehl 
2f7c				endm 
# End of macro FORTH_DSP_VALUEHL
2f7c			 
2f7c					FORTH_DSP_POP 
2f7c cd e9 21			call macro_forth_dsp_pop 
2f7f				endm 
# End of macro FORTH_DSP_POP
2f7f			 
2f7f					; hl contains value to add to byte at a 
2f7f				 
2f7f eb					ex de, hl 
2f80			 
2f80 e1					pop hl 
2f81			 
2f81					if DEBUG_FORTH_WORDS 
2f81						DMARK "INC" 
2f81 f5				push af  
2f82 3a 96 2f			ld a, (.dmark)  
2f85 32 b4 fe			ld (debug_mark),a  
2f88 3a 97 2f			ld a, (.dmark+1)  
2f8b 32 b5 fe			ld (debug_mark+1),a  
2f8e 3a 98 2f			ld a, (.dmark+2)  
2f91 32 b6 fe			ld (debug_mark+2),a  
2f94 18 03			jr .pastdmark  
2f96 ..			.dmark: db "INC"  
2f99 f1			.pastdmark: pop af  
2f9a			endm  
# End of macro DMARK
2f9a						CALLMONITOR 
2f9a cd c6 18			call break_point_state  
2f9d				endm  
# End of macro CALLMONITOR
2f9d					endif 
2f9d			 
2f9d 7e					ld a,(hl) 
2f9e 83					add e 
2f9f 77					ld (hl),a 
2fa0			 
2fa0			 
2fa0			 
2fa0				       NEXTW 
2fa0 c3 e0 22			jp macro_next 
2fa3				endm 
# End of macro NEXTW
2fa3			 
2fa3			.DEC: 
2fa3				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2fa3 6f				db WORD_SYS_CORE+91             
2fa4 f4 2f			dw .INC2            
2fa6 03				db 2 + 1 
2fa7 .. 00			db "-!",0              
2faa				endm 
# End of macro CWHEAD
2faa			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2faa					if DEBUG_FORTH_WORDS_KEY 
2faa						DMARK "-s_" 
2faa f5				push af  
2fab 3a bf 2f			ld a, (.dmark)  
2fae 32 b4 fe			ld (debug_mark),a  
2fb1 3a c0 2f			ld a, (.dmark+1)  
2fb4 32 b5 fe			ld (debug_mark+1),a  
2fb7 3a c1 2f			ld a, (.dmark+2)  
2fba 32 b6 fe			ld (debug_mark+2),a  
2fbd 18 03			jr .pastdmark  
2fbf ..			.dmark: db "-s_"  
2fc2 f1			.pastdmark: pop af  
2fc3			endm  
# End of macro DMARK
2fc3						CALLMONITOR 
2fc3 cd c6 18			call break_point_state  
2fc6				endm  
# End of macro CALLMONITOR
2fc6					endif 
2fc6			 
2fc6					FORTH_DSP_VALUEHL 
2fc6 cd 31 21			call macro_dsp_valuehl 
2fc9				endm 
# End of macro FORTH_DSP_VALUEHL
2fc9			 
2fc9 e5					push hl   ; save address 
2fca			 
2fca					FORTH_DSP_POP 
2fca cd e9 21			call macro_forth_dsp_pop 
2fcd				endm 
# End of macro FORTH_DSP_POP
2fcd			 
2fcd					FORTH_DSP_VALUEHL 
2fcd cd 31 21			call macro_dsp_valuehl 
2fd0				endm 
# End of macro FORTH_DSP_VALUEHL
2fd0			 
2fd0					; hl contains value to add to byte at a 
2fd0				 
2fd0 eb					ex de, hl 
2fd1			 
2fd1 e1					pop hl 
2fd2			 
2fd2					if DEBUG_FORTH_WORDS 
2fd2						DMARK "DEC" 
2fd2 f5				push af  
2fd3 3a e7 2f			ld a, (.dmark)  
2fd6 32 b4 fe			ld (debug_mark),a  
2fd9 3a e8 2f			ld a, (.dmark+1)  
2fdc 32 b5 fe			ld (debug_mark+1),a  
2fdf 3a e9 2f			ld a, (.dmark+2)  
2fe2 32 b6 fe			ld (debug_mark+2),a  
2fe5 18 03			jr .pastdmark  
2fe7 ..			.dmark: db "DEC"  
2fea f1			.pastdmark: pop af  
2feb			endm  
# End of macro DMARK
2feb						CALLMONITOR 
2feb cd c6 18			call break_point_state  
2fee				endm  
# End of macro CALLMONITOR
2fee					endif 
2fee			 
2fee 7e					ld a,(hl) 
2fef 93					sub e 
2ff0 77					ld (hl),a 
2ff1			 
2ff1			 
2ff1			 
2ff1				       NEXTW 
2ff1 c3 e0 22			jp macro_next 
2ff4				endm 
# End of macro NEXTW
2ff4			 
2ff4			.INC2: 
2ff4				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2ff4 6f				db WORD_SYS_CORE+91             
2ff5 9e 30			dw .DEC2            
2ff7 04				db 3 + 1 
2ff8 .. 00			db "+2!",0              
2ffc				endm 
# End of macro CWHEAD
2ffc			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2ffc			 
2ffc					if DEBUG_FORTH_WORDS_KEY 
2ffc						DMARK "+2s" 
2ffc f5				push af  
2ffd 3a 11 30			ld a, (.dmark)  
3000 32 b4 fe			ld (debug_mark),a  
3003 3a 12 30			ld a, (.dmark+1)  
3006 32 b5 fe			ld (debug_mark+1),a  
3009 3a 13 30			ld a, (.dmark+2)  
300c 32 b6 fe			ld (debug_mark+2),a  
300f 18 03			jr .pastdmark  
3011 ..			.dmark: db "+2s"  
3014 f1			.pastdmark: pop af  
3015			endm  
# End of macro DMARK
3015						CALLMONITOR 
3015 cd c6 18			call break_point_state  
3018				endm  
# End of macro CALLMONITOR
3018					endif 
3018			 
3018					; Address 
3018			 
3018					FORTH_DSP_VALUEHL 
3018 cd 31 21			call macro_dsp_valuehl 
301b				endm 
# End of macro FORTH_DSP_VALUEHL
301b			 
301b e5					push hl    ; save address 
301c			 
301c					; load content into de 
301c			 
301c 5e					ld e,(hl) 
301d 23					inc hl 
301e 56					ld d, (hl) 
301f			 
301f					if DEBUG_FORTH_WORDS 
301f						DMARK "+2a" 
301f f5				push af  
3020 3a 34 30			ld a, (.dmark)  
3023 32 b4 fe			ld (debug_mark),a  
3026 3a 35 30			ld a, (.dmark+1)  
3029 32 b5 fe			ld (debug_mark+1),a  
302c 3a 36 30			ld a, (.dmark+2)  
302f 32 b6 fe			ld (debug_mark+2),a  
3032 18 03			jr .pastdmark  
3034 ..			.dmark: db "+2a"  
3037 f1			.pastdmark: pop af  
3038			endm  
# End of macro DMARK
3038						CALLMONITOR 
3038 cd c6 18			call break_point_state  
303b				endm  
# End of macro CALLMONITOR
303b					endif 
303b			 
303b					FORTH_DSP_POP 
303b cd e9 21			call macro_forth_dsp_pop 
303e				endm 
# End of macro FORTH_DSP_POP
303e			 
303e					; Get value to add 
303e			 
303e					FORTH_DSP_VALUE 
303e cd 1a 21			call macro_forth_dsp_value 
3041				endm 
# End of macro FORTH_DSP_VALUE
3041			 
3041					if DEBUG_FORTH_WORDS 
3041						DMARK "+2v" 
3041 f5				push af  
3042 3a 56 30			ld a, (.dmark)  
3045 32 b4 fe			ld (debug_mark),a  
3048 3a 57 30			ld a, (.dmark+1)  
304b 32 b5 fe			ld (debug_mark+1),a  
304e 3a 58 30			ld a, (.dmark+2)  
3051 32 b6 fe			ld (debug_mark+2),a  
3054 18 03			jr .pastdmark  
3056 ..			.dmark: db "+2v"  
3059 f1			.pastdmark: pop af  
305a			endm  
# End of macro DMARK
305a						CALLMONITOR 
305a cd c6 18			call break_point_state  
305d				endm  
# End of macro CALLMONITOR
305d					endif 
305d			 
305d 19					add hl, de 
305e			 
305e					if DEBUG_FORTH_WORDS 
305e						DMARK "+2+" 
305e f5				push af  
305f 3a 73 30			ld a, (.dmark)  
3062 32 b4 fe			ld (debug_mark),a  
3065 3a 74 30			ld a, (.dmark+1)  
3068 32 b5 fe			ld (debug_mark+1),a  
306b 3a 75 30			ld a, (.dmark+2)  
306e 32 b6 fe			ld (debug_mark+2),a  
3071 18 03			jr .pastdmark  
3073 ..			.dmark: db "+2+"  
3076 f1			.pastdmark: pop af  
3077			endm  
# End of macro DMARK
3077						CALLMONITOR 
3077 cd c6 18			call break_point_state  
307a				endm  
# End of macro CALLMONITOR
307a					endif 
307a			 
307a					; move result to de 
307a			 
307a eb					ex de, hl 
307b			 
307b					; Address 
307b			 
307b e1					pop hl 
307c			 
307c					; save it back 
307c			 
307c 73					ld (hl), e 
307d 23					inc hl 
307e 72					ld (hl), d 
307f			 
307f					if DEBUG_FORTH_WORDS 
307f						DMARK "+2e" 
307f f5				push af  
3080 3a 94 30			ld a, (.dmark)  
3083 32 b4 fe			ld (debug_mark),a  
3086 3a 95 30			ld a, (.dmark+1)  
3089 32 b5 fe			ld (debug_mark+1),a  
308c 3a 96 30			ld a, (.dmark+2)  
308f 32 b6 fe			ld (debug_mark+2),a  
3092 18 03			jr .pastdmark  
3094 ..			.dmark: db "+2e"  
3097 f1			.pastdmark: pop af  
3098			endm  
# End of macro DMARK
3098						CALLMONITOR 
3098 cd c6 18			call break_point_state  
309b				endm  
# End of macro CALLMONITOR
309b					endif 
309b			 
309b			 
309b			 
309b			 
309b			 
309b				       NEXTW 
309b c3 e0 22			jp macro_next 
309e				endm 
# End of macro NEXTW
309e			 
309e			.DEC2: 
309e				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
309e 6f				db WORD_SYS_CORE+91             
309f 4a 31			dw .GET2            
30a1 04				db 3 + 1 
30a2 .. 00			db "-2!",0              
30a6				endm 
# End of macro CWHEAD
30a6			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
30a6			 
30a6			 
30a6					if DEBUG_FORTH_WORDS_KEY 
30a6						DMARK "-2s" 
30a6 f5				push af  
30a7 3a bb 30			ld a, (.dmark)  
30aa 32 b4 fe			ld (debug_mark),a  
30ad 3a bc 30			ld a, (.dmark+1)  
30b0 32 b5 fe			ld (debug_mark+1),a  
30b3 3a bd 30			ld a, (.dmark+2)  
30b6 32 b6 fe			ld (debug_mark+2),a  
30b9 18 03			jr .pastdmark  
30bb ..			.dmark: db "-2s"  
30be f1			.pastdmark: pop af  
30bf			endm  
# End of macro DMARK
30bf						CALLMONITOR 
30bf cd c6 18			call break_point_state  
30c2				endm  
# End of macro CALLMONITOR
30c2					endif 
30c2			 
30c2					; Address 
30c2			 
30c2					FORTH_DSP_VALUEHL 
30c2 cd 31 21			call macro_dsp_valuehl 
30c5				endm 
# End of macro FORTH_DSP_VALUEHL
30c5			 
30c5 e5					push hl    ; save address 
30c6			 
30c6					; load content into de 
30c6			 
30c6 5e					ld e,(hl) 
30c7 23					inc hl 
30c8 56					ld d, (hl) 
30c9			 
30c9					if DEBUG_FORTH_WORDS 
30c9						DMARK "-2a" 
30c9 f5				push af  
30ca 3a de 30			ld a, (.dmark)  
30cd 32 b4 fe			ld (debug_mark),a  
30d0 3a df 30			ld a, (.dmark+1)  
30d3 32 b5 fe			ld (debug_mark+1),a  
30d6 3a e0 30			ld a, (.dmark+2)  
30d9 32 b6 fe			ld (debug_mark+2),a  
30dc 18 03			jr .pastdmark  
30de ..			.dmark: db "-2a"  
30e1 f1			.pastdmark: pop af  
30e2			endm  
# End of macro DMARK
30e2						CALLMONITOR 
30e2 cd c6 18			call break_point_state  
30e5				endm  
# End of macro CALLMONITOR
30e5					endif 
30e5			 
30e5					FORTH_DSP_POP 
30e5 cd e9 21			call macro_forth_dsp_pop 
30e8				endm 
# End of macro FORTH_DSP_POP
30e8			 
30e8					; Get value to remove 
30e8			 
30e8					FORTH_DSP_VALUE 
30e8 cd 1a 21			call macro_forth_dsp_value 
30eb				endm 
# End of macro FORTH_DSP_VALUE
30eb			 
30eb					if DEBUG_FORTH_WORDS 
30eb						DMARK "-2v" 
30eb f5				push af  
30ec 3a 00 31			ld a, (.dmark)  
30ef 32 b4 fe			ld (debug_mark),a  
30f2 3a 01 31			ld a, (.dmark+1)  
30f5 32 b5 fe			ld (debug_mark+1),a  
30f8 3a 02 31			ld a, (.dmark+2)  
30fb 32 b6 fe			ld (debug_mark+2),a  
30fe 18 03			jr .pastdmark  
3100 ..			.dmark: db "-2v"  
3103 f1			.pastdmark: pop af  
3104			endm  
# End of macro DMARK
3104						CALLMONITOR 
3104 cd c6 18			call break_point_state  
3107				endm  
# End of macro CALLMONITOR
3107					endif 
3107			 
3107 eb					ex de, hl 
3108 ed 52				sbc hl, de 
310a			 
310a					if DEBUG_FORTH_WORDS 
310a						DMARK "-2d" 
310a f5				push af  
310b 3a 1f 31			ld a, (.dmark)  
310e 32 b4 fe			ld (debug_mark),a  
3111 3a 20 31			ld a, (.dmark+1)  
3114 32 b5 fe			ld (debug_mark+1),a  
3117 3a 21 31			ld a, (.dmark+2)  
311a 32 b6 fe			ld (debug_mark+2),a  
311d 18 03			jr .pastdmark  
311f ..			.dmark: db "-2d"  
3122 f1			.pastdmark: pop af  
3123			endm  
# End of macro DMARK
3123						CALLMONITOR 
3123 cd c6 18			call break_point_state  
3126				endm  
# End of macro CALLMONITOR
3126					endif 
3126			 
3126					; move result to de 
3126			 
3126 eb					ex de, hl 
3127			 
3127					; Address 
3127			 
3127 e1					pop hl 
3128			 
3128					; save it back 
3128			 
3128 73					ld (hl), e 
3129 23					inc hl 
312a 72					ld (hl), d 
312b			 
312b					if DEBUG_FORTH_WORDS 
312b						DMARK "-2e" 
312b f5				push af  
312c 3a 40 31			ld a, (.dmark)  
312f 32 b4 fe			ld (debug_mark),a  
3132 3a 41 31			ld a, (.dmark+1)  
3135 32 b5 fe			ld (debug_mark+1),a  
3138 3a 42 31			ld a, (.dmark+2)  
313b 32 b6 fe			ld (debug_mark+2),a  
313e 18 03			jr .pastdmark  
3140 ..			.dmark: db "-2e"  
3143 f1			.pastdmark: pop af  
3144			endm  
# End of macro DMARK
3144						CALLMONITOR 
3144 cd c6 18			call break_point_state  
3147				endm  
# End of macro CALLMONITOR
3147					endif 
3147			 
3147			 
3147			 
3147			 
3147			 
3147				       NEXTW 
3147 c3 e0 22			jp macro_next 
314a				endm 
# End of macro NEXTW
314a			.GET2: 
314a				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
314a 6f				db WORD_SYS_CORE+91             
314b 7a 31			dw .BANG2            
314d 03				db 2 + 1 
314e .. 00			db "2@",0              
3151				endm 
# End of macro CWHEAD
3151			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3151					if DEBUG_FORTH_WORDS_KEY 
3151						DMARK "2A_" 
3151 f5				push af  
3152 3a 66 31			ld a, (.dmark)  
3155 32 b4 fe			ld (debug_mark),a  
3158 3a 67 31			ld a, (.dmark+1)  
315b 32 b5 fe			ld (debug_mark+1),a  
315e 3a 68 31			ld a, (.dmark+2)  
3161 32 b6 fe			ld (debug_mark+2),a  
3164 18 03			jr .pastdmark  
3166 ..			.dmark: db "2A_"  
3169 f1			.pastdmark: pop af  
316a			endm  
# End of macro DMARK
316a						CALLMONITOR 
316a cd c6 18			call break_point_state  
316d				endm  
# End of macro CALLMONITOR
316d					endif 
316d			 
316d					FORTH_DSP_VALUEHL 
316d cd 31 21			call macro_dsp_valuehl 
3170				endm 
# End of macro FORTH_DSP_VALUEHL
3170			 
3170 5e					ld e, (hl) 
3171 23					inc hl 
3172 56					ld d, (hl) 
3173			 
3173 eb					ex de, hl 
3174			 
3174 cd 3a 1f				call forth_push_numhl 
3177			 
3177				       NEXTW 
3177 c3 e0 22			jp macro_next 
317a				endm 
# End of macro NEXTW
317a			.BANG2: 
317a				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
317a 6f				db WORD_SYS_CORE+91             
317b b2 31			dw .CONFIG            
317d 03				db 2 + 1 
317e .. 00			db "2!",0              
3181				endm 
# End of macro CWHEAD
3181			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3181					if DEBUG_FORTH_WORDS_KEY 
3181						DMARK "2S_" 
3181 f5				push af  
3182 3a 96 31			ld a, (.dmark)  
3185 32 b4 fe			ld (debug_mark),a  
3188 3a 97 31			ld a, (.dmark+1)  
318b 32 b5 fe			ld (debug_mark+1),a  
318e 3a 98 31			ld a, (.dmark+2)  
3191 32 b6 fe			ld (debug_mark+2),a  
3194 18 03			jr .pastdmark  
3196 ..			.dmark: db "2S_"  
3199 f1			.pastdmark: pop af  
319a			endm  
# End of macro DMARK
319a						CALLMONITOR 
319a cd c6 18			call break_point_state  
319d				endm  
# End of macro CALLMONITOR
319d					endif 
319d			 
319d					FORTH_DSP_VALUEHL 
319d cd 31 21			call macro_dsp_valuehl 
31a0				endm 
# End of macro FORTH_DSP_VALUEHL
31a0			 
31a0 e5					push hl   ; save address 
31a1			 
31a1			 
31a1					FORTH_DSP_POP 
31a1 cd e9 21			call macro_forth_dsp_pop 
31a4				endm 
# End of macro FORTH_DSP_POP
31a4			 
31a4					 
31a4					FORTH_DSP_VALUEHL 
31a4 cd 31 21			call macro_dsp_valuehl 
31a7				endm 
# End of macro FORTH_DSP_VALUEHL
31a7			 
31a7					FORTH_DSP_POP 
31a7 cd e9 21			call macro_forth_dsp_pop 
31aa				endm 
# End of macro FORTH_DSP_POP
31aa			 
31aa eb					ex de, hl    ; value now in de 
31ab			 
31ab e1					pop hl 
31ac			 
31ac 73					ld (hl), e 
31ad			 
31ad 23					inc hl 
31ae			 
31ae 72					ld (hl), d 
31af			 
31af			 
31af				       NEXTW 
31af c3 e0 22			jp macro_next 
31b2				endm 
# End of macro NEXTW
31b2			.CONFIG: 
31b2				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
31b2 6f				db WORD_SYS_CORE+91             
31b3 c3 31			dw .ENDCORE            
31b5 07				db 6 + 1 
31b6 .. 00			db "CONFIG",0              
31bd				endm 
# End of macro CWHEAD
31bd			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
31bd			 
31bd cd a9 15				call config 
31c0					NEXTW 
31c0 c3 e0 22			jp macro_next 
31c3				endm 
# End of macro NEXTW
31c3			.ENDCORE: 
31c3			 
31c3			; eof 
31c3			 
31c3			 
# End of file forth_words_core.asm
31c3			include "forth_words_flow.asm" 
31c3			 
31c3			; | ## Program Flow Words 
31c3			 
31c3			.IF: 
31c3				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
31c3 1e				db WORD_SYS_CORE+10             
31c4 b8 32			dw .THEN            
31c6 03				db 2 + 1 
31c7 .. 00			db "IF",0              
31ca				endm 
# End of macro CWHEAD
31ca			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
31ca			; 
31ca					if DEBUG_FORTH_WORDS_KEY 
31ca						DMARK "IF." 
31ca f5				push af  
31cb 3a df 31			ld a, (.dmark)  
31ce 32 b4 fe			ld (debug_mark),a  
31d1 3a e0 31			ld a, (.dmark+1)  
31d4 32 b5 fe			ld (debug_mark+1),a  
31d7 3a e1 31			ld a, (.dmark+2)  
31da 32 b6 fe			ld (debug_mark+2),a  
31dd 18 03			jr .pastdmark  
31df ..			.dmark: db "IF."  
31e2 f1			.pastdmark: pop af  
31e3			endm  
# End of macro DMARK
31e3						CALLMONITOR 
31e3 cd c6 18			call break_point_state  
31e6				endm  
# End of macro CALLMONITOR
31e6					endif 
31e6			; eval TOS 
31e6			 
31e6				FORTH_DSP_VALUEHL 
31e6 cd 31 21			call macro_dsp_valuehl 
31e9				endm 
# End of macro FORTH_DSP_VALUEHL
31e9			 
31e9			;	push hl 
31e9				FORTH_DSP_POP 
31e9 cd e9 21			call macro_forth_dsp_pop 
31ec				endm 
# End of macro FORTH_DSP_POP
31ec			;	pop hl 
31ec			 
31ec					if DEBUG_FORTH_WORDS 
31ec						DMARK "IF1" 
31ec f5				push af  
31ed 3a 01 32			ld a, (.dmark)  
31f0 32 b4 fe			ld (debug_mark),a  
31f3 3a 02 32			ld a, (.dmark+1)  
31f6 32 b5 fe			ld (debug_mark+1),a  
31f9 3a 03 32			ld a, (.dmark+2)  
31fc 32 b6 fe			ld (debug_mark+2),a  
31ff 18 03			jr .pastdmark  
3201 ..			.dmark: db "IF1"  
3204 f1			.pastdmark: pop af  
3205			endm  
# End of macro DMARK
3205						CALLMONITOR 
3205 cd c6 18			call break_point_state  
3208				endm  
# End of macro CALLMONITOR
3208					endif 
3208 b7				or a        ; clear carry flag 
3209 11 00 00			ld de, 0 
320c eb				ex de,hl 
320d ed 52			sbc hl, de 
320f c2 99 32			jp nz, .iftrue 
3212			 
3212					if DEBUG_FORTH_WORDS 
3212						DMARK "IF2" 
3212 f5				push af  
3213 3a 27 32			ld a, (.dmark)  
3216 32 b4 fe			ld (debug_mark),a  
3219 3a 28 32			ld a, (.dmark+1)  
321c 32 b5 fe			ld (debug_mark+1),a  
321f 3a 29 32			ld a, (.dmark+2)  
3222 32 b6 fe			ld (debug_mark+2),a  
3225 18 03			jr .pastdmark  
3227 ..			.dmark: db "IF2"  
322a f1			.pastdmark: pop af  
322b			endm  
# End of macro DMARK
322b						CALLMONITOR 
322b cd c6 18			call break_point_state  
322e				endm  
# End of macro CALLMONITOR
322e					endif 
322e			 
322e			; if not true then skip to THEN 
322e			 
322e				; TODO get tok_ptr 
322e				; TODO consume toks until we get to THEN 
322e			 
322e 2a 4f f6			ld hl, (os_tok_ptr) 
3231					if DEBUG_FORTH_WORDS 
3231						DMARK "IF3" 
3231 f5				push af  
3232 3a 46 32			ld a, (.dmark)  
3235 32 b4 fe			ld (debug_mark),a  
3238 3a 47 32			ld a, (.dmark+1)  
323b 32 b5 fe			ld (debug_mark+1),a  
323e 3a 48 32			ld a, (.dmark+2)  
3241 32 b6 fe			ld (debug_mark+2),a  
3244 18 03			jr .pastdmark  
3246 ..			.dmark: db "IF3"  
3249 f1			.pastdmark: pop af  
324a			endm  
# End of macro DMARK
324a						CALLMONITOR 
324a cd c6 18			call break_point_state  
324d				endm  
# End of macro CALLMONITOR
324d						 
324d					endif 
324d 11 94 32			ld de, .ifthen 
3250					if DEBUG_FORTH_WORDS 
3250						DMARK "IF4" 
3250 f5				push af  
3251 3a 65 32			ld a, (.dmark)  
3254 32 b4 fe			ld (debug_mark),a  
3257 3a 66 32			ld a, (.dmark+1)  
325a 32 b5 fe			ld (debug_mark+1),a  
325d 3a 67 32			ld a, (.dmark+2)  
3260 32 b6 fe			ld (debug_mark+2),a  
3263 18 03			jr .pastdmark  
3265 ..			.dmark: db "IF4"  
3268 f1			.pastdmark: pop af  
3269			endm  
# End of macro DMARK
3269						CALLMONITOR 
3269 cd c6 18			call break_point_state  
326c				endm  
# End of macro CALLMONITOR
326c					endif 
326c cd fb 23			call findnexttok  
326f			 
326f					if DEBUG_FORTH_WORDS 
326f						DMARK "IF5" 
326f f5				push af  
3270 3a 84 32			ld a, (.dmark)  
3273 32 b4 fe			ld (debug_mark),a  
3276 3a 85 32			ld a, (.dmark+1)  
3279 32 b5 fe			ld (debug_mark+1),a  
327c 3a 86 32			ld a, (.dmark+2)  
327f 32 b6 fe			ld (debug_mark+2),a  
3282 18 03			jr .pastdmark  
3284 ..			.dmark: db "IF5"  
3287 f1			.pastdmark: pop af  
3288			endm  
# End of macro DMARK
3288						CALLMONITOR 
3288 cd c6 18			call break_point_state  
328b				endm  
# End of macro CALLMONITOR
328b					endif 
328b				; TODO replace below with ; exec using tok_ptr 
328b 22 4f f6			ld (os_tok_ptr), hl 
328e c3 71 23			jp exec1 
3291				NEXTW 
3291 c3 e0 22			jp macro_next 
3294				endm 
# End of macro NEXTW
3294			 
3294 .. 00		.ifthen:  db "THEN",0 
3299			 
3299			.iftrue:		 
3299				; Exec next words normally 
3299			 
3299				; if true then exec following IF as normal 
3299					if DEBUG_FORTH_WORDS 
3299						DMARK "IFT" 
3299 f5				push af  
329a 3a ae 32			ld a, (.dmark)  
329d 32 b4 fe			ld (debug_mark),a  
32a0 3a af 32			ld a, (.dmark+1)  
32a3 32 b5 fe			ld (debug_mark+1),a  
32a6 3a b0 32			ld a, (.dmark+2)  
32a9 32 b6 fe			ld (debug_mark+2),a  
32ac 18 03			jr .pastdmark  
32ae ..			.dmark: db "IFT"  
32b1 f1			.pastdmark: pop af  
32b2			endm  
# End of macro DMARK
32b2						CALLMONITOR 
32b2 cd c6 18			call break_point_state  
32b5				endm  
# End of macro CALLMONITOR
32b5					endif 
32b5			 
32b5					NEXTW 
32b5 c3 e0 22			jp macro_next 
32b8				endm 
# End of macro NEXTW
32b8			.THEN: 
32b8				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
32b8 1f				db WORD_SYS_CORE+11             
32b9 e0 32			dw .ELSE            
32bb 05				db 4 + 1 
32bc .. 00			db "THEN",0              
32c1				endm 
# End of macro CWHEAD
32c1			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
32c1					if DEBUG_FORTH_WORDS_KEY 
32c1						DMARK "THN" 
32c1 f5				push af  
32c2 3a d6 32			ld a, (.dmark)  
32c5 32 b4 fe			ld (debug_mark),a  
32c8 3a d7 32			ld a, (.dmark+1)  
32cb 32 b5 fe			ld (debug_mark+1),a  
32ce 3a d8 32			ld a, (.dmark+2)  
32d1 32 b6 fe			ld (debug_mark+2),a  
32d4 18 03			jr .pastdmark  
32d6 ..			.dmark: db "THN"  
32d9 f1			.pastdmark: pop af  
32da			endm  
# End of macro DMARK
32da						CALLMONITOR 
32da cd c6 18			call break_point_state  
32dd				endm  
# End of macro CALLMONITOR
32dd					endif 
32dd					NEXTW 
32dd c3 e0 22			jp macro_next 
32e0				endm 
# End of macro NEXTW
32e0			.ELSE: 
32e0				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
32e0 20				db WORD_SYS_CORE+12             
32e1 08 33			dw .DO            
32e3 03				db 2 + 1 
32e4 .. 00			db "ELSE",0              
32e9				endm 
# End of macro CWHEAD
32e9			; | ELSE ( -- ) Not supported - does nothing | TODO 
32e9			 
32e9					if DEBUG_FORTH_WORDS_KEY 
32e9						DMARK "ELS" 
32e9 f5				push af  
32ea 3a fe 32			ld a, (.dmark)  
32ed 32 b4 fe			ld (debug_mark),a  
32f0 3a ff 32			ld a, (.dmark+1)  
32f3 32 b5 fe			ld (debug_mark+1),a  
32f6 3a 00 33			ld a, (.dmark+2)  
32f9 32 b6 fe			ld (debug_mark+2),a  
32fc 18 03			jr .pastdmark  
32fe ..			.dmark: db "ELS"  
3301 f1			.pastdmark: pop af  
3302			endm  
# End of macro DMARK
3302						CALLMONITOR 
3302 cd c6 18			call break_point_state  
3305				endm  
# End of macro CALLMONITOR
3305					endif 
3305			 
3305			 
3305					NEXTW 
3305 c3 e0 22			jp macro_next 
3308				endm 
# End of macro NEXTW
3308			.DO: 
3308				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3308 21				db WORD_SYS_CORE+13             
3309 2f 34			dw .LOOP            
330b 03				db 2 + 1 
330c .. 00			db "DO",0              
330f				endm 
# End of macro CWHEAD
330f			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
330f			 
330f					if DEBUG_FORTH_WORDS_KEY 
330f						DMARK "DO." 
330f f5				push af  
3310 3a 24 33			ld a, (.dmark)  
3313 32 b4 fe			ld (debug_mark),a  
3316 3a 25 33			ld a, (.dmark+1)  
3319 32 b5 fe			ld (debug_mark+1),a  
331c 3a 26 33			ld a, (.dmark+2)  
331f 32 b6 fe			ld (debug_mark+2),a  
3322 18 03			jr .pastdmark  
3324 ..			.dmark: db "DO."  
3327 f1			.pastdmark: pop af  
3328			endm  
# End of macro DMARK
3328						CALLMONITOR 
3328 cd c6 18			call break_point_state  
332b				endm  
# End of macro CALLMONITOR
332b					endif 
332b			;  push pc to rsp stack past the DO 
332b			 
332b 2a 4f f6				ld hl, (os_tok_ptr) 
332e 23					inc hl   ; D 
332f 23					inc hl  ; O 
3330 23					inc hl   ; null 
3331					if DEBUG_FORTH_WORDS 
3331						DMARK "DO2" 
3331 f5				push af  
3332 3a 46 33			ld a, (.dmark)  
3335 32 b4 fe			ld (debug_mark),a  
3338 3a 47 33			ld a, (.dmark+1)  
333b 32 b5 fe			ld (debug_mark+1),a  
333e 3a 48 33			ld a, (.dmark+2)  
3341 32 b6 fe			ld (debug_mark+2),a  
3344 18 03			jr .pastdmark  
3346 ..			.dmark: db "DO2"  
3349 f1			.pastdmark: pop af  
334a			endm  
# End of macro DMARK
334a						CALLMONITOR 
334a cd c6 18			call break_point_state  
334d				endm  
# End of macro CALLMONITOR
334d					endif 
334d					FORTH_RSP_NEXT 
334d cd e1 1e			call macro_forth_rsp_next 
3350				endm 
# End of macro FORTH_RSP_NEXT
3350					if DEBUG_FORTH_WORDS 
3350						DMARK "DO3" 
3350 f5				push af  
3351 3a 65 33			ld a, (.dmark)  
3354 32 b4 fe			ld (debug_mark),a  
3357 3a 66 33			ld a, (.dmark+1)  
335a 32 b5 fe			ld (debug_mark+1),a  
335d 3a 67 33			ld a, (.dmark+2)  
3360 32 b6 fe			ld (debug_mark+2),a  
3363 18 03			jr .pastdmark  
3365 ..			.dmark: db "DO3"  
3368 f1			.pastdmark: pop af  
3369			endm  
# End of macro DMARK
3369						CALLMONITOR 
3369 cd c6 18			call break_point_state  
336c				endm  
# End of macro CALLMONITOR
336c					endif 
336c			 
336c					;if DEBUG_FORTH_WORDS 
336c				;		push hl 
336c			;		endif  
336c			 
336c			; get counters from data stack 
336c			 
336c			 
336c					FORTH_DSP_VALUEHL 
336c cd 31 21			call macro_dsp_valuehl 
336f				endm 
# End of macro FORTH_DSP_VALUEHL
336f e5					push hl		 ; hl now has starting counter which needs to be tos 
3370			 
3370					if DEBUG_FORTH_WORDS 
3370						DMARK "DO4" 
3370 f5				push af  
3371 3a 85 33			ld a, (.dmark)  
3374 32 b4 fe			ld (debug_mark),a  
3377 3a 86 33			ld a, (.dmark+1)  
337a 32 b5 fe			ld (debug_mark+1),a  
337d 3a 87 33			ld a, (.dmark+2)  
3380 32 b6 fe			ld (debug_mark+2),a  
3383 18 03			jr .pastdmark  
3385 ..			.dmark: db "DO4"  
3388 f1			.pastdmark: pop af  
3389			endm  
# End of macro DMARK
3389						CALLMONITOR 
3389 cd c6 18			call break_point_state  
338c				endm  
# End of macro CALLMONITOR
338c					endif 
338c					FORTH_DSP_POP 
338c cd e9 21			call macro_forth_dsp_pop 
338f				endm 
# End of macro FORTH_DSP_POP
338f			 
338f					if DEBUG_FORTH_WORDS 
338f						DMARK "DO5" 
338f f5				push af  
3390 3a a4 33			ld a, (.dmark)  
3393 32 b4 fe			ld (debug_mark),a  
3396 3a a5 33			ld a, (.dmark+1)  
3399 32 b5 fe			ld (debug_mark+1),a  
339c 3a a6 33			ld a, (.dmark+2)  
339f 32 b6 fe			ld (debug_mark+2),a  
33a2 18 03			jr .pastdmark  
33a4 ..			.dmark: db "DO5"  
33a7 f1			.pastdmark: pop af  
33a8			endm  
# End of macro DMARK
33a8						CALLMONITOR 
33a8 cd c6 18			call break_point_state  
33ab				endm  
# End of macro CALLMONITOR
33ab					endif 
33ab			 
33ab					FORTH_DSP_VALUEHL 
33ab cd 31 21			call macro_dsp_valuehl 
33ae				endm 
# End of macro FORTH_DSP_VALUEHL
33ae			;		push hl		 ; hl now has starting limit counter 
33ae			 
33ae					if DEBUG_FORTH_WORDS 
33ae						DMARK "DO6" 
33ae f5				push af  
33af 3a c3 33			ld a, (.dmark)  
33b2 32 b4 fe			ld (debug_mark),a  
33b5 3a c4 33			ld a, (.dmark+1)  
33b8 32 b5 fe			ld (debug_mark+1),a  
33bb 3a c5 33			ld a, (.dmark+2)  
33be 32 b6 fe			ld (debug_mark+2),a  
33c1 18 03			jr .pastdmark  
33c3 ..			.dmark: db "DO6"  
33c6 f1			.pastdmark: pop af  
33c7			endm  
# End of macro DMARK
33c7						CALLMONITOR 
33c7 cd c6 18			call break_point_state  
33ca				endm  
# End of macro CALLMONITOR
33ca					endif 
33ca					FORTH_DSP_POP 
33ca cd e9 21			call macro_forth_dsp_pop 
33cd				endm 
# End of macro FORTH_DSP_POP
33cd			 
33cd			; put counters on the loop stack 
33cd			 
33cd			;		pop hl			 ; limit counter 
33cd d1					pop de			; start counter 
33ce			 
33ce					; push limit counter 
33ce			 
33ce					if DEBUG_FORTH_WORDS 
33ce						DMARK "DO7" 
33ce f5				push af  
33cf 3a e3 33			ld a, (.dmark)  
33d2 32 b4 fe			ld (debug_mark),a  
33d5 3a e4 33			ld a, (.dmark+1)  
33d8 32 b5 fe			ld (debug_mark+1),a  
33db 3a e5 33			ld a, (.dmark+2)  
33de 32 b6 fe			ld (debug_mark+2),a  
33e1 18 03			jr .pastdmark  
33e3 ..			.dmark: db "DO7"  
33e6 f1			.pastdmark: pop af  
33e7			endm  
# End of macro DMARK
33e7						CALLMONITOR 
33e7 cd c6 18			call break_point_state  
33ea				endm  
# End of macro CALLMONITOR
33ea					endif 
33ea					FORTH_LOOP_NEXT 
33ea cd 62 21			call macro_forth_loop_next 
33ed				endm 
# End of macro FORTH_LOOP_NEXT
33ed			 
33ed					; push start counter 
33ed			 
33ed eb					ex de, hl 
33ee					if DEBUG_FORTH_WORDS 
33ee						DMARK "DO7" 
33ee f5				push af  
33ef 3a 03 34			ld a, (.dmark)  
33f2 32 b4 fe			ld (debug_mark),a  
33f5 3a 04 34			ld a, (.dmark+1)  
33f8 32 b5 fe			ld (debug_mark+1),a  
33fb 3a 05 34			ld a, (.dmark+2)  
33fe 32 b6 fe			ld (debug_mark+2),a  
3401 18 03			jr .pastdmark  
3403 ..			.dmark: db "DO7"  
3406 f1			.pastdmark: pop af  
3407			endm  
# End of macro DMARK
3407						CALLMONITOR 
3407 cd c6 18			call break_point_state  
340a				endm  
# End of macro CALLMONITOR
340a					endif 
340a					FORTH_LOOP_NEXT 
340a cd 62 21			call macro_forth_loop_next 
340d				endm 
# End of macro FORTH_LOOP_NEXT
340d			 
340d			 
340d					; init first round of I counter 
340d			 
340d 22 73 f6				ld (os_current_i), hl 
3410			 
3410					if DEBUG_FORTH_WORDS 
3410						DMARK "DO8" 
3410 f5				push af  
3411 3a 25 34			ld a, (.dmark)  
3414 32 b4 fe			ld (debug_mark),a  
3417 3a 26 34			ld a, (.dmark+1)  
341a 32 b5 fe			ld (debug_mark+1),a  
341d 3a 27 34			ld a, (.dmark+2)  
3420 32 b6 fe			ld (debug_mark+2),a  
3423 18 03			jr .pastdmark  
3425 ..			.dmark: db "DO8"  
3428 f1			.pastdmark: pop af  
3429			endm  
# End of macro DMARK
3429						CALLMONITOR 
3429 cd c6 18			call break_point_state  
342c				endm  
# End of macro CALLMONITOR
342c					endif 
342c			 
342c					NEXTW 
342c c3 e0 22			jp macro_next 
342f				endm 
# End of macro NEXTW
342f			.LOOP: 
342f				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
342f 22				db WORD_SYS_CORE+14             
3430 47 35			dw .I            
3432 05				db 4 + 1 
3433 .. 00			db "LOOP",0              
3438				endm 
# End of macro CWHEAD
3438			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3438			 
3438				; pop tos as current loop count to hl 
3438			 
3438				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3438			 
3438				FORTH_LOOP_TOS 
3438 cd 95 21			call macro_forth_loop_tos 
343b				endm 
# End of macro FORTH_LOOP_TOS
343b e5				push hl 
343c			 
343c					if DEBUG_FORTH_WORDS_KEY 
343c						DMARK "LOP" 
343c f5				push af  
343d 3a 51 34			ld a, (.dmark)  
3440 32 b4 fe			ld (debug_mark),a  
3443 3a 52 34			ld a, (.dmark+1)  
3446 32 b5 fe			ld (debug_mark+1),a  
3449 3a 53 34			ld a, (.dmark+2)  
344c 32 b6 fe			ld (debug_mark+2),a  
344f 18 03			jr .pastdmark  
3451 ..			.dmark: db "LOP"  
3454 f1			.pastdmark: pop af  
3455			endm  
# End of macro DMARK
3455						CALLMONITOR 
3455 cd c6 18			call break_point_state  
3458				endm  
# End of macro CALLMONITOR
3458					endif 
3458				; next item on the stack is the limit. get it 
3458			 
3458			 
3458				FORTH_LOOP_POP 
3458 cd 9f 21			call macro_forth_loop_pop 
345b				endm 
# End of macro FORTH_LOOP_POP
345b			 
345b				FORTH_LOOP_TOS 
345b cd 95 21			call macro_forth_loop_tos 
345e				endm 
# End of macro FORTH_LOOP_TOS
345e			 
345e d1				pop de		 ; de = i, hl = limit 
345f			 
345f					if DEBUG_FORTH_WORDS 
345f						DMARK "LP1" 
345f f5				push af  
3460 3a 74 34			ld a, (.dmark)  
3463 32 b4 fe			ld (debug_mark),a  
3466 3a 75 34			ld a, (.dmark+1)  
3469 32 b5 fe			ld (debug_mark+1),a  
346c 3a 76 34			ld a, (.dmark+2)  
346f 32 b6 fe			ld (debug_mark+2),a  
3472 18 03			jr .pastdmark  
3474 ..			.dmark: db "LP1"  
3477 f1			.pastdmark: pop af  
3478			endm  
# End of macro DMARK
3478						CALLMONITOR 
3478 cd c6 18			call break_point_state  
347b				endm  
# End of macro CALLMONITOR
347b					endif 
347b			 
347b				; go back to previous word 
347b			 
347b d5				push de    ; save I for inc later 
347c			 
347c			 
347c				; get limit 
347c				;  is I at limit? 
347c			 
347c			 
347c					if DEBUG_FORTH_WORDS 
347c						DMARK "LP1" 
347c f5				push af  
347d 3a 91 34			ld a, (.dmark)  
3480 32 b4 fe			ld (debug_mark),a  
3483 3a 92 34			ld a, (.dmark+1)  
3486 32 b5 fe			ld (debug_mark+1),a  
3489 3a 93 34			ld a, (.dmark+2)  
348c 32 b6 fe			ld (debug_mark+2),a  
348f 18 03			jr .pastdmark  
3491 ..			.dmark: db "LP1"  
3494 f1			.pastdmark: pop af  
3495			endm  
# End of macro DMARK
3495						CALLMONITOR 
3495 cd c6 18			call break_point_state  
3498				endm  
# End of macro CALLMONITOR
3498					endif 
3498			 
3498 ed 52			sbc hl, de 
349a			 
349a			 
349a				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
349a			 
349a 20 26				jr nz, .loopnotdone 
349c			 
349c e1				pop hl   ; get rid of saved I 
349d				FORTH_LOOP_POP     ; get rid of limit 
349d cd 9f 21			call macro_forth_loop_pop 
34a0				endm 
# End of macro FORTH_LOOP_POP
34a0			 
34a0				FORTH_RSP_POP     ; get rid of DO ptr 
34a0 cd 02 1f			call macro_forth_rsp_pop 
34a3				endm 
# End of macro FORTH_RSP_POP
34a3			 
34a3			if DEBUG_FORTH_WORDS 
34a3						DMARK "LP>" 
34a3 f5				push af  
34a4 3a b8 34			ld a, (.dmark)  
34a7 32 b4 fe			ld (debug_mark),a  
34aa 3a b9 34			ld a, (.dmark+1)  
34ad 32 b5 fe			ld (debug_mark+1),a  
34b0 3a ba 34			ld a, (.dmark+2)  
34b3 32 b6 fe			ld (debug_mark+2),a  
34b6 18 03			jr .pastdmark  
34b8 ..			.dmark: db "LP>"  
34bb f1			.pastdmark: pop af  
34bc			endm  
# End of macro DMARK
34bc				CALLMONITOR 
34bc cd c6 18			call break_point_state  
34bf				endm  
# End of macro CALLMONITOR
34bf			endif 
34bf			 
34bf					NEXTW 
34bf c3 e0 22			jp macro_next 
34c2				endm 
# End of macro NEXTW
34c2				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34c2			 
34c2			.loopnotdone: 
34c2			 
34c2 e1				pop hl    ; get I 
34c3 23				inc hl 
34c4			 
34c4			   	; save new I 
34c4			 
34c4			 
34c4					; set I counter 
34c4			 
34c4 22 73 f6				ld (os_current_i), hl 
34c7			 
34c7					if DEBUG_FORTH_WORDS 
34c7						DMARK "LPN" 
34c7 f5				push af  
34c8 3a dc 34			ld a, (.dmark)  
34cb 32 b4 fe			ld (debug_mark),a  
34ce 3a dd 34			ld a, (.dmark+1)  
34d1 32 b5 fe			ld (debug_mark+1),a  
34d4 3a de 34			ld a, (.dmark+2)  
34d7 32 b6 fe			ld (debug_mark+2),a  
34da 18 03			jr .pastdmark  
34dc ..			.dmark: db "LPN"  
34df f1			.pastdmark: pop af  
34e0			endm  
# End of macro DMARK
34e0					CALLMONITOR 
34e0 cd c6 18			call break_point_state  
34e3				endm  
# End of macro CALLMONITOR
34e3					endif 
34e3					 
34e3				FORTH_LOOP_NEXT 
34e3 cd 62 21			call macro_forth_loop_next 
34e6				endm 
# End of macro FORTH_LOOP_NEXT
34e6			 
34e6			 
34e6					if DEBUG_FORTH_WORDS 
34e6 eb						ex de,hl 
34e7					endif 
34e7			 
34e7			;	; get DO ptr 
34e7			; 
34e7					if DEBUG_FORTH_WORDS 
34e7						DMARK "LP7" 
34e7 f5				push af  
34e8 3a fc 34			ld a, (.dmark)  
34eb 32 b4 fe			ld (debug_mark),a  
34ee 3a fd 34			ld a, (.dmark+1)  
34f1 32 b5 fe			ld (debug_mark+1),a  
34f4 3a fe 34			ld a, (.dmark+2)  
34f7 32 b6 fe			ld (debug_mark+2),a  
34fa 18 03			jr .pastdmark  
34fc ..			.dmark: db "LP7"  
34ff f1			.pastdmark: pop af  
3500			endm  
# End of macro DMARK
3500					CALLMONITOR 
3500 cd c6 18			call break_point_state  
3503				endm  
# End of macro CALLMONITOR
3503					endif 
3503				FORTH_RSP_TOS 
3503 cd f8 1e			call macro_forth_rsp_tos 
3506				endm 
# End of macro FORTH_RSP_TOS
3506			 
3506					if DEBUG_FORTH_WORDS 
3506						DMARK "LP8" 
3506 f5				push af  
3507 3a 1b 35			ld a, (.dmark)  
350a 32 b4 fe			ld (debug_mark),a  
350d 3a 1c 35			ld a, (.dmark+1)  
3510 32 b5 fe			ld (debug_mark+1),a  
3513 3a 1d 35			ld a, (.dmark+2)  
3516 32 b6 fe			ld (debug_mark+2),a  
3519 18 03			jr .pastdmark  
351b ..			.dmark: db "LP8"  
351e f1			.pastdmark: pop af  
351f			endm  
# End of macro DMARK
351f					CALLMONITOR 
351f cd c6 18			call break_point_state  
3522				endm  
# End of macro CALLMONITOR
3522					endif 
3522				;push hl 
3522			 
3522				; not going to DO any more 
3522				; get rid of the RSP pointer as DO will add it back in 
3522				;FORTH_RSP_POP 
3522				;pop hl 
3522			 
3522				;ld hl,(cli_ret_sp) 
3522				;ld e, (hl) 
3522				;inc hl 
3522				;ld d, (hl) 
3522				;ex de,hl 
3522 22 4f f6			ld (os_tok_ptr), hl 
3525					if DEBUG_FORTH_WORDS 
3525						DMARK "LP<" 
3525 f5				push af  
3526 3a 3a 35			ld a, (.dmark)  
3529 32 b4 fe			ld (debug_mark),a  
352c 3a 3b 35			ld a, (.dmark+1)  
352f 32 b5 fe			ld (debug_mark+1),a  
3532 3a 3c 35			ld a, (.dmark+2)  
3535 32 b6 fe			ld (debug_mark+2),a  
3538 18 03			jr .pastdmark  
353a ..			.dmark: db "LP<"  
353d f1			.pastdmark: pop af  
353e			endm  
# End of macro DMARK
353e					CALLMONITOR 
353e cd c6 18			call break_point_state  
3541				endm  
# End of macro CALLMONITOR
3541				endif 
3541 c3 71 23			jp exec1 
3544			 
3544					 
3544			 
3544			 
3544					NEXTW 
3544 c3 e0 22			jp macro_next 
3547				endm 
# End of macro NEXTW
3547			.I:  
3547			 
3547				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3547 5e				db WORD_SYS_CORE+74             
3548 72 35			dw .DLOOP            
354a 02				db 1 + 1 
354b .. 00			db "I",0              
354d				endm 
# End of macro CWHEAD
354d			; | I ( -- ) Current loop counter | DONE 
354d					if DEBUG_FORTH_WORDS_KEY 
354d						DMARK "I.." 
354d f5				push af  
354e 3a 62 35			ld a, (.dmark)  
3551 32 b4 fe			ld (debug_mark),a  
3554 3a 63 35			ld a, (.dmark+1)  
3557 32 b5 fe			ld (debug_mark+1),a  
355a 3a 64 35			ld a, (.dmark+2)  
355d 32 b6 fe			ld (debug_mark+2),a  
3560 18 03			jr .pastdmark  
3562 ..			.dmark: db "I.."  
3565 f1			.pastdmark: pop af  
3566			endm  
# End of macro DMARK
3566						CALLMONITOR 
3566 cd c6 18			call break_point_state  
3569				endm  
# End of macro CALLMONITOR
3569					endif 
3569			 
3569 2a 73 f6				ld hl,(os_current_i) 
356c cd 3a 1f				call forth_push_numhl 
356f			 
356f					NEXTW 
356f c3 e0 22			jp macro_next 
3572				endm 
# End of macro NEXTW
3572			.DLOOP: 
3572				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3572 5f				db WORD_SYS_CORE+75             
3573 53 36			dw .REPEAT            
3575 06				db 5 + 1 
3576 .. 00			db "-LOOP",0              
357c				endm 
# End of macro CWHEAD
357c			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
357c				; pop tos as current loop count to hl 
357c					if DEBUG_FORTH_WORDS_KEY 
357c						DMARK "-LP" 
357c f5				push af  
357d 3a 91 35			ld a, (.dmark)  
3580 32 b4 fe			ld (debug_mark),a  
3583 3a 92 35			ld a, (.dmark+1)  
3586 32 b5 fe			ld (debug_mark+1),a  
3589 3a 93 35			ld a, (.dmark+2)  
358c 32 b6 fe			ld (debug_mark+2),a  
358f 18 03			jr .pastdmark  
3591 ..			.dmark: db "-LP"  
3594 f1			.pastdmark: pop af  
3595			endm  
# End of macro DMARK
3595						CALLMONITOR 
3595 cd c6 18			call break_point_state  
3598				endm  
# End of macro CALLMONITOR
3598					endif 
3598			 
3598				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3598			 
3598				FORTH_LOOP_TOS 
3598 cd 95 21			call macro_forth_loop_tos 
359b				endm 
# End of macro FORTH_LOOP_TOS
359b e5				push hl 
359c			 
359c					if DEBUG_FORTH_WORDS 
359c						DMARK "-LP" 
359c f5				push af  
359d 3a b1 35			ld a, (.dmark)  
35a0 32 b4 fe			ld (debug_mark),a  
35a3 3a b2 35			ld a, (.dmark+1)  
35a6 32 b5 fe			ld (debug_mark+1),a  
35a9 3a b3 35			ld a, (.dmark+2)  
35ac 32 b6 fe			ld (debug_mark+2),a  
35af 18 03			jr .pastdmark  
35b1 ..			.dmark: db "-LP"  
35b4 f1			.pastdmark: pop af  
35b5			endm  
# End of macro DMARK
35b5						CALLMONITOR 
35b5 cd c6 18			call break_point_state  
35b8				endm  
# End of macro CALLMONITOR
35b8					endif 
35b8				; next item on the stack is the limit. get it 
35b8			 
35b8			 
35b8				FORTH_LOOP_POP 
35b8 cd 9f 21			call macro_forth_loop_pop 
35bb				endm 
# End of macro FORTH_LOOP_POP
35bb			 
35bb				FORTH_LOOP_TOS 
35bb cd 95 21			call macro_forth_loop_tos 
35be				endm 
# End of macro FORTH_LOOP_TOS
35be			 
35be d1				pop de		 ; de = i, hl = limit 
35bf			 
35bf					if DEBUG_FORTH_WORDS 
35bf						DMARK "-L1" 
35bf f5				push af  
35c0 3a d4 35			ld a, (.dmark)  
35c3 32 b4 fe			ld (debug_mark),a  
35c6 3a d5 35			ld a, (.dmark+1)  
35c9 32 b5 fe			ld (debug_mark+1),a  
35cc 3a d6 35			ld a, (.dmark+2)  
35cf 32 b6 fe			ld (debug_mark+2),a  
35d2 18 03			jr .pastdmark  
35d4 ..			.dmark: db "-L1"  
35d7 f1			.pastdmark: pop af  
35d8			endm  
# End of macro DMARK
35d8						CALLMONITOR 
35d8 cd c6 18			call break_point_state  
35db				endm  
# End of macro CALLMONITOR
35db					endif 
35db			 
35db				; go back to previous word 
35db			 
35db d5				push de    ; save I for inc later 
35dc			 
35dc			 
35dc				; get limit 
35dc				;  is I at limit? 
35dc			 
35dc			 
35dc					if DEBUG_FORTH_WORDS 
35dc						DMARK "-L1" 
35dc f5				push af  
35dd 3a f1 35			ld a, (.dmark)  
35e0 32 b4 fe			ld (debug_mark),a  
35e3 3a f2 35			ld a, (.dmark+1)  
35e6 32 b5 fe			ld (debug_mark+1),a  
35e9 3a f3 35			ld a, (.dmark+2)  
35ec 32 b6 fe			ld (debug_mark+2),a  
35ef 18 03			jr .pastdmark  
35f1 ..			.dmark: db "-L1"  
35f4 f1			.pastdmark: pop af  
35f5			endm  
# End of macro DMARK
35f5						CALLMONITOR 
35f5 cd c6 18			call break_point_state  
35f8				endm  
# End of macro CALLMONITOR
35f8					endif 
35f8			 
35f8 ed 52			sbc hl, de 
35fa			 
35fa			 
35fa				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
35fa			 
35fa 20 26				jr nz, .mloopnotdone 
35fc			 
35fc e1				pop hl   ; get rid of saved I 
35fd				FORTH_LOOP_POP     ; get rid of limit 
35fd cd 9f 21			call macro_forth_loop_pop 
3600				endm 
# End of macro FORTH_LOOP_POP
3600			 
3600				FORTH_RSP_POP     ; get rid of DO ptr 
3600 cd 02 1f			call macro_forth_rsp_pop 
3603				endm 
# End of macro FORTH_RSP_POP
3603			 
3603			if DEBUG_FORTH_WORDS 
3603						DMARK "-L>" 
3603 f5				push af  
3604 3a 18 36			ld a, (.dmark)  
3607 32 b4 fe			ld (debug_mark),a  
360a 3a 19 36			ld a, (.dmark+1)  
360d 32 b5 fe			ld (debug_mark+1),a  
3610 3a 1a 36			ld a, (.dmark+2)  
3613 32 b6 fe			ld (debug_mark+2),a  
3616 18 03			jr .pastdmark  
3618 ..			.dmark: db "-L>"  
361b f1			.pastdmark: pop af  
361c			endm  
# End of macro DMARK
361c				CALLMONITOR 
361c cd c6 18			call break_point_state  
361f				endm  
# End of macro CALLMONITOR
361f			endif 
361f			 
361f					NEXTW 
361f c3 e0 22			jp macro_next 
3622				endm 
# End of macro NEXTW
3622				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3622			 
3622			.mloopnotdone: 
3622			 
3622 e1				pop hl    ; get I 
3623 2b				dec hl 
3624			 
3624			   	; save new I 
3624			 
3624			 
3624					; set I counter 
3624			 
3624 22 73 f6				ld (os_current_i), hl 
3627			 
3627					 
3627				FORTH_LOOP_NEXT 
3627 cd 62 21			call macro_forth_loop_next 
362a				endm 
# End of macro FORTH_LOOP_NEXT
362a			 
362a			 
362a					if DEBUG_FORTH_WORDS 
362a eb						ex de,hl 
362b					endif 
362b			 
362b			;	; get DO ptr 
362b			; 
362b				FORTH_RSP_TOS 
362b cd f8 1e			call macro_forth_rsp_tos 
362e				endm 
# End of macro FORTH_RSP_TOS
362e			 
362e				;push hl 
362e			 
362e				; not going to DO any more 
362e				; get rid of the RSP pointer as DO will add it back in 
362e				;FORTH_RSP_POP 
362e				;pop hl 
362e			 
362e			 
362e 22 4f f6			ld (os_tok_ptr), hl 
3631					if DEBUG_FORTH_WORDS 
3631						DMARK "-L<" 
3631 f5				push af  
3632 3a 46 36			ld a, (.dmark)  
3635 32 b4 fe			ld (debug_mark),a  
3638 3a 47 36			ld a, (.dmark+1)  
363b 32 b5 fe			ld (debug_mark+1),a  
363e 3a 48 36			ld a, (.dmark+2)  
3641 32 b6 fe			ld (debug_mark+2),a  
3644 18 03			jr .pastdmark  
3646 ..			.dmark: db "-L<"  
3649 f1			.pastdmark: pop af  
364a			endm  
# End of macro DMARK
364a					CALLMONITOR 
364a cd c6 18			call break_point_state  
364d				endm  
# End of macro CALLMONITOR
364d				endif 
364d c3 71 23			jp exec1 
3650			 
3650					 
3650			 
3650			 
3650			 
3650				NEXTW 
3650 c3 e0 22			jp macro_next 
3653				endm 
# End of macro NEXTW
3653			 
3653			 
3653			 
3653			 
3653			.REPEAT: 
3653				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3653 71				db WORD_SYS_CORE+93             
3654 a6 36			dw .UNTIL            
3656 06				db 5 + 1 
3657 .. 00			db "REPEAT",0              
365e				endm 
# End of macro CWHEAD
365e			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
365e			;  push pc to rsp stack past the REPEAT 
365e					if DEBUG_FORTH_WORDS_KEY 
365e						DMARK "REP" 
365e f5				push af  
365f 3a 73 36			ld a, (.dmark)  
3662 32 b4 fe			ld (debug_mark),a  
3665 3a 74 36			ld a, (.dmark+1)  
3668 32 b5 fe			ld (debug_mark+1),a  
366b 3a 75 36			ld a, (.dmark+2)  
366e 32 b6 fe			ld (debug_mark+2),a  
3671 18 03			jr .pastdmark  
3673 ..			.dmark: db "REP"  
3676 f1			.pastdmark: pop af  
3677			endm  
# End of macro DMARK
3677						CALLMONITOR 
3677 cd c6 18			call break_point_state  
367a				endm  
# End of macro CALLMONITOR
367a					endif 
367a			 
367a 2a 4f f6				ld hl, (os_tok_ptr) 
367d 23					inc hl   ; R 
367e 23					inc hl  ; E 
367f 23					inc hl   ; P 
3680 23					inc hl   ; E 
3681 23					inc hl   ; A 
3682 23					inc hl   ; T 
3683 23					inc hl   ; zero 
3684					FORTH_RSP_NEXT 
3684 cd e1 1e			call macro_forth_rsp_next 
3687				endm 
# End of macro FORTH_RSP_NEXT
3687			 
3687			 
3687					if DEBUG_FORTH_WORDS 
3687						DMARK "REP" 
3687 f5				push af  
3688 3a 9c 36			ld a, (.dmark)  
368b 32 b4 fe			ld (debug_mark),a  
368e 3a 9d 36			ld a, (.dmark+1)  
3691 32 b5 fe			ld (debug_mark+1),a  
3694 3a 9e 36			ld a, (.dmark+2)  
3697 32 b6 fe			ld (debug_mark+2),a  
369a 18 03			jr .pastdmark  
369c ..			.dmark: db "REP"  
369f f1			.pastdmark: pop af  
36a0			endm  
# End of macro DMARK
36a0						;pop bc    ; TODO BUG ?????? what is this for???? 
36a0						CALLMONITOR 
36a0 cd c6 18			call break_point_state  
36a3				endm  
# End of macro CALLMONITOR
36a3					endif 
36a3			 
36a3					NEXTW 
36a3 c3 e0 22			jp macro_next 
36a6				endm 
# End of macro NEXTW
36a6			;	       NEXTW 
36a6			 
36a6			.UNTIL: 
36a6				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
36a6 72				db WORD_SYS_CORE+94             
36a7 3d 37			dw .ENDFLOW            
36a9 06				db 5 + 1 
36aa .. 00			db "UNTIL",0              
36b0				endm 
# End of macro CWHEAD
36b0			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
36b0			 
36b0				; pop tos as check 
36b0			 
36b0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
36b0			 
36b0				FORTH_DSP_VALUEHL 
36b0 cd 31 21			call macro_dsp_valuehl 
36b3				endm 
# End of macro FORTH_DSP_VALUEHL
36b3			 
36b3					if DEBUG_FORTH_WORDS_KEY 
36b3						DMARK "UNT" 
36b3 f5				push af  
36b4 3a c8 36			ld a, (.dmark)  
36b7 32 b4 fe			ld (debug_mark),a  
36ba 3a c9 36			ld a, (.dmark+1)  
36bd 32 b5 fe			ld (debug_mark+1),a  
36c0 3a ca 36			ld a, (.dmark+2)  
36c3 32 b6 fe			ld (debug_mark+2),a  
36c6 18 03			jr .pastdmark  
36c8 ..			.dmark: db "UNT"  
36cb f1			.pastdmark: pop af  
36cc			endm  
# End of macro DMARK
36cc						CALLMONITOR 
36cc cd c6 18			call break_point_state  
36cf				endm  
# End of macro CALLMONITOR
36cf					endif 
36cf			 
36cf			;	push hl 
36cf				FORTH_DSP_POP 
36cf cd e9 21			call macro_forth_dsp_pop 
36d2				endm 
# End of macro FORTH_DSP_POP
36d2			 
36d2			;	pop hl 
36d2			 
36d2				; test if true 
36d2			 
36d2 cd 72 0f			call ishlzero 
36d5			;	ld a,l 
36d5			;	add h 
36d5			; 
36d5			;	cp 0 
36d5			 
36d5 20 3e			jr nz, .untilnotdone 
36d7			 
36d7					if DEBUG_FORTH_WORDS 
36d7						DMARK "UNf" 
36d7 f5				push af  
36d8 3a ec 36			ld a, (.dmark)  
36db 32 b4 fe			ld (debug_mark),a  
36de 3a ed 36			ld a, (.dmark+1)  
36e1 32 b5 fe			ld (debug_mark+1),a  
36e4 3a ee 36			ld a, (.dmark+2)  
36e7 32 b6 fe			ld (debug_mark+2),a  
36ea 18 03			jr .pastdmark  
36ec ..			.dmark: db "UNf"  
36ef f1			.pastdmark: pop af  
36f0			endm  
# End of macro DMARK
36f0						CALLMONITOR 
36f0 cd c6 18			call break_point_state  
36f3				endm  
# End of macro CALLMONITOR
36f3					endif 
36f3			 
36f3			 
36f3			 
36f3				FORTH_RSP_POP     ; get rid of DO ptr 
36f3 cd 02 1f			call macro_forth_rsp_pop 
36f6				endm 
# End of macro FORTH_RSP_POP
36f6			 
36f6			if DEBUG_FORTH_WORDS 
36f6						DMARK "UN>" 
36f6 f5				push af  
36f7 3a 0b 37			ld a, (.dmark)  
36fa 32 b4 fe			ld (debug_mark),a  
36fd 3a 0c 37			ld a, (.dmark+1)  
3700 32 b5 fe			ld (debug_mark+1),a  
3703 3a 0d 37			ld a, (.dmark+2)  
3706 32 b6 fe			ld (debug_mark+2),a  
3709 18 03			jr .pastdmark  
370b ..			.dmark: db "UN>"  
370e f1			.pastdmark: pop af  
370f			endm  
# End of macro DMARK
370f				CALLMONITOR 
370f cd c6 18			call break_point_state  
3712				endm  
# End of macro CALLMONITOR
3712			endif 
3712			 
3712					NEXTW 
3712 c3 e0 22			jp macro_next 
3715				endm 
# End of macro NEXTW
3715				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3715			 
3715			.untilnotdone: 
3715			 
3715			 
3715			;	; get DO ptr 
3715			; 
3715				FORTH_RSP_TOS 
3715 cd f8 1e			call macro_forth_rsp_tos 
3718				endm 
# End of macro FORTH_RSP_TOS
3718			 
3718				;push hl 
3718			 
3718				; not going to DO any more 
3718				; get rid of the RSP pointer as DO will add it back in 
3718				;FORTH_RSP_POP 
3718				;pop hl 
3718			 
3718			 
3718 22 4f f6			ld (os_tok_ptr), hl 
371b					if DEBUG_FORTH_WORDS 
371b						DMARK "UN<" 
371b f5				push af  
371c 3a 30 37			ld a, (.dmark)  
371f 32 b4 fe			ld (debug_mark),a  
3722 3a 31 37			ld a, (.dmark+1)  
3725 32 b5 fe			ld (debug_mark+1),a  
3728 3a 32 37			ld a, (.dmark+2)  
372b 32 b6 fe			ld (debug_mark+2),a  
372e 18 03			jr .pastdmark  
3730 ..			.dmark: db "UN<"  
3733 f1			.pastdmark: pop af  
3734			endm  
# End of macro DMARK
3734					CALLMONITOR 
3734 cd c6 18			call break_point_state  
3737				endm  
# End of macro CALLMONITOR
3737				endif 
3737 c3 71 23			jp exec1 
373a			 
373a					 
373a			 
373a			 
373a					NEXTW 
373a c3 e0 22			jp macro_next 
373d				endm 
# End of macro NEXTW
373d			 
373d			 
373d			.ENDFLOW: 
373d			 
373d			; eof 
373d			 
# End of file forth_words_flow.asm
373d			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
373d			include "forth_words_logic.asm" 
373d			 
373d			; | ## Logic Words 
373d			 
373d			.NOT: 
373d				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
373d 2d				db WORD_SYS_CORE+25             
373e 85 37			dw .IS            
3740 04				db 3 + 1 
3741 .. 00			db "NOT",0              
3745				endm 
# End of macro CWHEAD
3745			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3745					if DEBUG_FORTH_WORDS_KEY 
3745						DMARK "NOT" 
3745 f5				push af  
3746 3a 5a 37			ld a, (.dmark)  
3749 32 b4 fe			ld (debug_mark),a  
374c 3a 5b 37			ld a, (.dmark+1)  
374f 32 b5 fe			ld (debug_mark+1),a  
3752 3a 5c 37			ld a, (.dmark+2)  
3755 32 b6 fe			ld (debug_mark+2),a  
3758 18 03			jr .pastdmark  
375a ..			.dmark: db "NOT"  
375d f1			.pastdmark: pop af  
375e			endm  
# End of macro DMARK
375e						CALLMONITOR 
375e cd c6 18			call break_point_state  
3761				endm  
# End of macro CALLMONITOR
3761					endif 
3761					FORTH_DSP 
3761 cd f7 20			call macro_forth_dsp 
3764				endm 
# End of macro FORTH_DSP
3764 7e					ld a,(hl)	; get type of value on TOS 
3765 fe 02				cp DS_TYPE_INUM  
3767 28 03				jr z, .noti 
3769					NEXTW 
3769 c3 e0 22			jp macro_next 
376c				endm 
# End of macro NEXTW
376c			.noti:          FORTH_DSP_VALUEHL 
376c cd 31 21			call macro_dsp_valuehl 
376f				endm 
# End of macro FORTH_DSP_VALUEHL
376f			;		push hl 
376f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
376f cd e9 21			call macro_forth_dsp_pop 
3772				endm 
# End of macro FORTH_DSP_POP
3772			;		pop hl 
3772 3e 00				ld a,0 
3774 bd					cp l 
3775 28 04				jr z, .not2t 
3777 2e 00				ld l, 0 
3779 18 02				jr .notip 
377b			 
377b 2e ff		.not2t:		ld l, 255 
377d			 
377d 26 00		.notip:		ld h, 0	 
377f			 
377f cd 3a 1f				call forth_push_numhl 
3782					NEXTW 
3782 c3 e0 22			jp macro_next 
3785				endm 
# End of macro NEXTW
3785			 
3785			.IS: 
3785				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3785 2d				db WORD_SYS_CORE+25             
3786 ab 37			dw .LZERO            
3788 03				db 2 + 1 
3789 .. 00			db "IS",0              
378c				endm 
# End of macro CWHEAD
378c			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
378c					if DEBUG_FORTH_WORDS_KEY 
378c						DMARK "IS." 
378c f5				push af  
378d 3a a1 37			ld a, (.dmark)  
3790 32 b4 fe			ld (debug_mark),a  
3793 3a a2 37			ld a, (.dmark+1)  
3796 32 b5 fe			ld (debug_mark+1),a  
3799 3a a3 37			ld a, (.dmark+2)  
379c 32 b6 fe			ld (debug_mark+2),a  
379f 18 03			jr .pastdmark  
37a1 ..			.dmark: db "IS."  
37a4 f1			.pastdmark: pop af  
37a5			endm  
# End of macro DMARK
37a5						CALLMONITOR 
37a5 cd c6 18			call break_point_state  
37a8				endm  
# End of macro CALLMONITOR
37a8					endif 
37a8					NEXTW 
37a8 c3 e0 22			jp macro_next 
37ab				endm 
# End of macro NEXTW
37ab			.LZERO: 
37ab				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
37ab 2d				db WORD_SYS_CORE+25             
37ac b5 37			dw .TZERO            
37ae 03				db 2 + 1 
37af .. 00			db "0<",0              
37b2				endm 
# End of macro CWHEAD
37b2			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
37b2					NEXTW 
37b2 c3 e0 22			jp macro_next 
37b5				endm 
# End of macro NEXTW
37b5			.TZERO: 
37b5				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
37b5 2e				db WORD_SYS_CORE+26             
37b6 fc 37			dw .LESS            
37b8 03				db 2 + 1 
37b9 .. 00			db "0=",0              
37bc				endm 
# End of macro CWHEAD
37bc			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
37bc				; TODO add floating point number detection 
37bc					;v5 FORTH_DSP_VALUE 
37bc					if DEBUG_FORTH_WORDS_KEY 
37bc						DMARK "0=." 
37bc f5				push af  
37bd 3a d1 37			ld a, (.dmark)  
37c0 32 b4 fe			ld (debug_mark),a  
37c3 3a d2 37			ld a, (.dmark+1)  
37c6 32 b5 fe			ld (debug_mark+1),a  
37c9 3a d3 37			ld a, (.dmark+2)  
37cc 32 b6 fe			ld (debug_mark+2),a  
37cf 18 03			jr .pastdmark  
37d1 ..			.dmark: db "0=."  
37d4 f1			.pastdmark: pop af  
37d5			endm  
# End of macro DMARK
37d5						CALLMONITOR 
37d5 cd c6 18			call break_point_state  
37d8				endm  
# End of macro CALLMONITOR
37d8					endif 
37d8					FORTH_DSP 
37d8 cd f7 20			call macro_forth_dsp 
37db				endm 
# End of macro FORTH_DSP
37db 7e					ld a,(hl)	; get type of value on TOS 
37dc fe 02				cp DS_TYPE_INUM  
37de 28 00				jr z, .tz_inum 
37e0			 
37e0				if FORTH_ENABLE_FLOATMATH 
37e0					jr .tz_done 
37e0			 
37e0				endif 
37e0					 
37e0			 
37e0			.tz_inum: 
37e0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37e0 cd 31 21			call macro_dsp_valuehl 
37e3				endm 
# End of macro FORTH_DSP_VALUEHL
37e3			 
37e3			;		push hl 
37e3			 
37e3					; destroy value TOS 
37e3			 
37e3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37e3 cd e9 21			call macro_forth_dsp_pop 
37e6				endm 
# End of macro FORTH_DSP_POP
37e6			 
37e6			;		pop hl 
37e6			 
37e6 3e 00				ld a,0 
37e8			 
37e8 bd					cp l 
37e9 20 08				jr nz, .tz_notzero 
37eb			 
37eb bc					cp h 
37ec			 
37ec 20 05				jr nz, .tz_notzero 
37ee			 
37ee			 
37ee 21 01 00				ld hl, FORTH_TRUE 
37f1 18 03				jr .tz_done 
37f3			 
37f3 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
37f6			 
37f6					; push value back onto stack for another op etc 
37f6			 
37f6			.tz_done: 
37f6 cd 3a 1f				call forth_push_numhl 
37f9			 
37f9					NEXTW 
37f9 c3 e0 22			jp macro_next 
37fc				endm 
# End of macro NEXTW
37fc			.LESS: 
37fc				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
37fc 2f				db WORD_SYS_CORE+27             
37fd 65 38			dw .GT            
37ff 02				db 1 + 1 
3800 .. 00			db "<",0              
3802				endm 
# End of macro CWHEAD
3802			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3802				; TODO add floating point number detection 
3802					if DEBUG_FORTH_WORDS_KEY 
3802						DMARK "LES" 
3802 f5				push af  
3803 3a 17 38			ld a, (.dmark)  
3806 32 b4 fe			ld (debug_mark),a  
3809 3a 18 38			ld a, (.dmark+1)  
380c 32 b5 fe			ld (debug_mark+1),a  
380f 3a 19 38			ld a, (.dmark+2)  
3812 32 b6 fe			ld (debug_mark+2),a  
3815 18 03			jr .pastdmark  
3817 ..			.dmark: db "LES"  
381a f1			.pastdmark: pop af  
381b			endm  
# End of macro DMARK
381b						CALLMONITOR 
381b cd c6 18			call break_point_state  
381e				endm  
# End of macro CALLMONITOR
381e					endif 
381e					FORTH_DSP 
381e cd f7 20			call macro_forth_dsp 
3821				endm 
# End of macro FORTH_DSP
3821					;v5 FORTH_DSP_VALUE 
3821 7e					ld a,(hl)	; get type of value on TOS 
3822 fe 02				cp DS_TYPE_INUM  
3824 28 00				jr z, .less_inum 
3826			 
3826				if FORTH_ENABLE_FLOATMATH 
3826					jr .less_done 
3826			 
3826				endif 
3826					 
3826			 
3826			.less_inum: 
3826					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3826 cd 31 21			call macro_dsp_valuehl 
3829				endm 
# End of macro FORTH_DSP_VALUEHL
3829			 
3829 e5					push hl  ; u2 
382a			 
382a					; destroy value TOS 
382a			 
382a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
382a cd e9 21			call macro_forth_dsp_pop 
382d				endm 
# End of macro FORTH_DSP_POP
382d			 
382d			 
382d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
382d cd 31 21			call macro_dsp_valuehl 
3830				endm 
# End of macro FORTH_DSP_VALUEHL
3830			 
3830 e5					push hl    ; u1 
3831			 
3831					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3831 cd e9 21			call macro_forth_dsp_pop 
3834				endm 
# End of macro FORTH_DSP_POP
3834			 
3834			 
3834 b7			 or a      ;clear carry flag 
3835 01 00 00		 ld bc, FORTH_FALSE 
3838 e1			  pop hl    ; u1 
3839 d1			  pop de    ; u2 
383a ed 52		  sbc hl,de 
383c 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
383e			 
383e 01 01 00		 ld bc, FORTH_TRUE 
3841			.lscont:  
3841 c5					push bc 
3842 e1					pop hl 
3843			 
3843					if DEBUG_FORTH_WORDS 
3843						DMARK "LT1" 
3843 f5				push af  
3844 3a 58 38			ld a, (.dmark)  
3847 32 b4 fe			ld (debug_mark),a  
384a 3a 59 38			ld a, (.dmark+1)  
384d 32 b5 fe			ld (debug_mark+1),a  
3850 3a 5a 38			ld a, (.dmark+2)  
3853 32 b6 fe			ld (debug_mark+2),a  
3856 18 03			jr .pastdmark  
3858 ..			.dmark: db "LT1"  
385b f1			.pastdmark: pop af  
385c			endm  
# End of macro DMARK
385c						CALLMONITOR 
385c cd c6 18			call break_point_state  
385f				endm  
# End of macro CALLMONITOR
385f					endif 
385f cd 3a 1f				call forth_push_numhl 
3862			 
3862					NEXTW 
3862 c3 e0 22			jp macro_next 
3865				endm 
# End of macro NEXTW
3865			.GT: 
3865				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3865 30				db WORD_SYS_CORE+28             
3866 ce 38			dw .EQUAL            
3868 02				db 1 + 1 
3869 .. 00			db ">",0              
386b				endm 
# End of macro CWHEAD
386b			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
386b				; TODO add floating point number detection 
386b					if DEBUG_FORTH_WORDS_KEY 
386b						DMARK "GRT" 
386b f5				push af  
386c 3a 80 38			ld a, (.dmark)  
386f 32 b4 fe			ld (debug_mark),a  
3872 3a 81 38			ld a, (.dmark+1)  
3875 32 b5 fe			ld (debug_mark+1),a  
3878 3a 82 38			ld a, (.dmark+2)  
387b 32 b6 fe			ld (debug_mark+2),a  
387e 18 03			jr .pastdmark  
3880 ..			.dmark: db "GRT"  
3883 f1			.pastdmark: pop af  
3884			endm  
# End of macro DMARK
3884						CALLMONITOR 
3884 cd c6 18			call break_point_state  
3887				endm  
# End of macro CALLMONITOR
3887					endif 
3887					FORTH_DSP 
3887 cd f7 20			call macro_forth_dsp 
388a				endm 
# End of macro FORTH_DSP
388a					;FORTH_DSP_VALUE 
388a 7e					ld a,(hl)	; get type of value on TOS 
388b fe 02				cp DS_TYPE_INUM  
388d 28 00				jr z, .gt_inum 
388f			 
388f				if FORTH_ENABLE_FLOATMATH 
388f					jr .gt_done 
388f			 
388f				endif 
388f					 
388f			 
388f			.gt_inum: 
388f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
388f cd 31 21			call macro_dsp_valuehl 
3892				endm 
# End of macro FORTH_DSP_VALUEHL
3892			 
3892 e5					push hl  ; u2 
3893			 
3893					; destroy value TOS 
3893			 
3893					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3893 cd e9 21			call macro_forth_dsp_pop 
3896				endm 
# End of macro FORTH_DSP_POP
3896			 
3896			 
3896					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3896 cd 31 21			call macro_dsp_valuehl 
3899				endm 
# End of macro FORTH_DSP_VALUEHL
3899			 
3899 e5					push hl    ; u1 
389a			 
389a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
389a cd e9 21			call macro_forth_dsp_pop 
389d				endm 
# End of macro FORTH_DSP_POP
389d			 
389d			 
389d b7			 or a      ;clear carry flag 
389e 01 00 00		 ld bc, FORTH_FALSE 
38a1 e1			  pop hl    ; u1 
38a2 d1			  pop de    ; u2 
38a3 ed 52		  sbc hl,de 
38a5 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
38a7			 
38a7 01 01 00		 ld bc, FORTH_TRUE 
38aa			.gtcont:  
38aa c5					push bc 
38ab e1					pop hl 
38ac			 
38ac					if DEBUG_FORTH_WORDS 
38ac						DMARK "GT1" 
38ac f5				push af  
38ad 3a c1 38			ld a, (.dmark)  
38b0 32 b4 fe			ld (debug_mark),a  
38b3 3a c2 38			ld a, (.dmark+1)  
38b6 32 b5 fe			ld (debug_mark+1),a  
38b9 3a c3 38			ld a, (.dmark+2)  
38bc 32 b6 fe			ld (debug_mark+2),a  
38bf 18 03			jr .pastdmark  
38c1 ..			.dmark: db "GT1"  
38c4 f1			.pastdmark: pop af  
38c5			endm  
# End of macro DMARK
38c5						CALLMONITOR 
38c5 cd c6 18			call break_point_state  
38c8				endm  
# End of macro CALLMONITOR
38c8					endif 
38c8 cd 3a 1f				call forth_push_numhl 
38cb			 
38cb					NEXTW 
38cb c3 e0 22			jp macro_next 
38ce				endm 
# End of macro NEXTW
38ce			.EQUAL: 
38ce				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
38ce 31				db WORD_SYS_CORE+29             
38cf 39 39			dw .ENDLOGIC            
38d1 02				db 1 + 1 
38d2 .. 00			db "=",0              
38d4				endm 
# End of macro CWHEAD
38d4			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
38d4				; TODO add floating point number detection 
38d4					if DEBUG_FORTH_WORDS_KEY 
38d4						DMARK "EQ." 
38d4 f5				push af  
38d5 3a e9 38			ld a, (.dmark)  
38d8 32 b4 fe			ld (debug_mark),a  
38db 3a ea 38			ld a, (.dmark+1)  
38de 32 b5 fe			ld (debug_mark+1),a  
38e1 3a eb 38			ld a, (.dmark+2)  
38e4 32 b6 fe			ld (debug_mark+2),a  
38e7 18 03			jr .pastdmark  
38e9 ..			.dmark: db "EQ."  
38ec f1			.pastdmark: pop af  
38ed			endm  
# End of macro DMARK
38ed						CALLMONITOR 
38ed cd c6 18			call break_point_state  
38f0				endm  
# End of macro CALLMONITOR
38f0					endif 
38f0					FORTH_DSP 
38f0 cd f7 20			call macro_forth_dsp 
38f3				endm 
# End of macro FORTH_DSP
38f3					;v5 FORTH_DSP_VALUE 
38f3 7e					ld a,(hl)	; get type of value on TOS 
38f4 fe 02				cp DS_TYPE_INUM  
38f6 28 00				jr z, .eq_inum 
38f8			 
38f8				if FORTH_ENABLE_FLOATMATH 
38f8					jr .eq_done 
38f8			 
38f8				endif 
38f8					 
38f8			 
38f8			.eq_inum: 
38f8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38f8 cd 31 21			call macro_dsp_valuehl 
38fb				endm 
# End of macro FORTH_DSP_VALUEHL
38fb			 
38fb e5					push hl 
38fc			 
38fc					; destroy value TOS 
38fc			 
38fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38fc cd e9 21			call macro_forth_dsp_pop 
38ff				endm 
# End of macro FORTH_DSP_POP
38ff			 
38ff			 
38ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38ff cd 31 21			call macro_dsp_valuehl 
3902				endm 
# End of macro FORTH_DSP_VALUEHL
3902			 
3902					; one value on hl get other one back 
3902			 
3902 e5					push hl 
3903			 
3903					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3903 cd e9 21			call macro_forth_dsp_pop 
3906				endm 
# End of macro FORTH_DSP_POP
3906			 
3906 0e 00				ld c, FORTH_FALSE 
3908			 
3908 e1					pop hl 
3909 d1					pop de 
390a			 
390a 7b					ld a, e 
390b bd					cp l 
390c			 
390c 20 06				jr nz, .eq_done 
390e			 
390e 7a					ld a, d 
390f bc					cp h 
3910			 
3910 20 02				jr nz, .eq_done 
3912			 
3912 0e 01				ld c, FORTH_TRUE 
3914					 
3914			 
3914			 
3914			.eq_done: 
3914			 
3914					; TODO push value back onto stack for another op etc 
3914			 
3914 26 00				ld h, 0 
3916 69					ld l, c 
3917					if DEBUG_FORTH_WORDS 
3917						DMARK "EQ1" 
3917 f5				push af  
3918 3a 2c 39			ld a, (.dmark)  
391b 32 b4 fe			ld (debug_mark),a  
391e 3a 2d 39			ld a, (.dmark+1)  
3921 32 b5 fe			ld (debug_mark+1),a  
3924 3a 2e 39			ld a, (.dmark+2)  
3927 32 b6 fe			ld (debug_mark+2),a  
392a 18 03			jr .pastdmark  
392c ..			.dmark: db "EQ1"  
392f f1			.pastdmark: pop af  
3930			endm  
# End of macro DMARK
3930						CALLMONITOR 
3930 cd c6 18			call break_point_state  
3933				endm  
# End of macro CALLMONITOR
3933					endif 
3933 cd 3a 1f				call forth_push_numhl 
3936			 
3936					NEXTW 
3936 c3 e0 22			jp macro_next 
3939				endm 
# End of macro NEXTW
3939			 
3939			 
3939			.ENDLOGIC: 
3939			; eof 
3939			 
3939			 
# End of file forth_words_logic.asm
3939			include "forth_words_maths.asm" 
3939			 
3939			; | ## Maths Words 
3939			 
3939			.PLUS:	 
3939				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3939 15				db WORD_SYS_CORE+1             
393a 97 39			dw .NEG            
393c 02				db 1 + 1 
393d .. 00			db "+",0              
393f				endm 
# End of macro CWHEAD
393f			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
393f					if DEBUG_FORTH_WORDS_KEY 
393f						DMARK "PLU" 
393f f5				push af  
3940 3a 54 39			ld a, (.dmark)  
3943 32 b4 fe			ld (debug_mark),a  
3946 3a 55 39			ld a, (.dmark+1)  
3949 32 b5 fe			ld (debug_mark+1),a  
394c 3a 56 39			ld a, (.dmark+2)  
394f 32 b6 fe			ld (debug_mark+2),a  
3952 18 03			jr .pastdmark  
3954 ..			.dmark: db "PLU"  
3957 f1			.pastdmark: pop af  
3958			endm  
# End of macro DMARK
3958						CALLMONITOR 
3958 cd c6 18			call break_point_state  
395b				endm  
# End of macro CALLMONITOR
395b					endif 
395b					; add top two values and push back result 
395b			 
395b					;for v5 FORTH_DSP_VALUE 
395b					FORTH_DSP 
395b cd f7 20			call macro_forth_dsp 
395e				endm 
# End of macro FORTH_DSP
395e 7e					ld a,(hl)	; get type of value on TOS 
395f fe 02				cp DS_TYPE_INUM  
3961 28 03				jr z, .dot_inum 
3963			 
3963					NEXTW 
3963 c3 e0 22			jp macro_next 
3966				endm 
# End of macro NEXTW
3966			 
3966			; float maths 
3966			 
3966				if FORTH_ENABLE_FLOATMATH 
3966						inc hl      ; now at start of numeric as string 
3966			 
3966					if DEBUG_FORTH_MATHS 
3966						DMARK "ADD" 
3966				CALLMONITOR 
3966					endif 
3966			 
3966					;ld ix, hl 
3966					call CON 
3966			 
3966			 
3966					push hl 
3966					 
3966					 
3966			 
3966						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3966			 
3966					; get next number 
3966			 
3966						FORTH_DSP_VALUE 
3966			 
3966						inc hl      ; now at start of numeric as string 
3966			 
3966					;ld ix, hl 
3966					call CON 
3966			 
3966					push hl 
3966			 
3966			 
3966						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3966			 
3966						; TODO do add 
3966			 
3966						call IADD 
3966			 
3966						; TODO get result back as ascii 
3966			 
3966						; TODO push result  
3966			 
3966			 
3966			 
3966						jr .dot_done 
3966				endif 
3966			 
3966			.dot_inum: 
3966			 
3966			 
3966					if DEBUG_FORTH_DOT 
3966						DMARK "+IT" 
3966 f5				push af  
3967 3a 7b 39			ld a, (.dmark)  
396a 32 b4 fe			ld (debug_mark),a  
396d 3a 7c 39			ld a, (.dmark+1)  
3970 32 b5 fe			ld (debug_mark+1),a  
3973 3a 7d 39			ld a, (.dmark+2)  
3976 32 b6 fe			ld (debug_mark+2),a  
3979 18 03			jr .pastdmark  
397b ..			.dmark: db "+IT"  
397e f1			.pastdmark: pop af  
397f			endm  
# End of macro DMARK
397f				CALLMONITOR 
397f cd c6 18			call break_point_state  
3982				endm  
# End of macro CALLMONITOR
3982					endif 
3982			 
3982					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3982 cd 31 21			call macro_dsp_valuehl 
3985				endm 
# End of macro FORTH_DSP_VALUEHL
3985			 
3985				; TODO add floating point number detection 
3985			 
3985 e5					push hl 
3986			 
3986					; destroy value TOS 
3986			 
3986					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3986 cd e9 21			call macro_forth_dsp_pop 
3989				endm 
# End of macro FORTH_DSP_POP
3989			 
3989			 
3989					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3989 cd 31 21			call macro_dsp_valuehl 
398c				endm 
# End of macro FORTH_DSP_VALUEHL
398c			 
398c					; one value on hl get other one back 
398c			 
398c d1					pop de 
398d			 
398d					; do the add 
398d			 
398d 19					add hl,de 
398e			 
398e					; save it 
398e			 
398e			;		push hl	 
398e			 
398e					; 
398e			 
398e					; destroy value TOS 
398e			 
398e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
398e cd e9 21			call macro_forth_dsp_pop 
3991				endm 
# End of macro FORTH_DSP_POP
3991			 
3991					; TODO push value back onto stack for another op etc 
3991			 
3991			;		pop hl 
3991			 
3991			.dot_done: 
3991 cd 3a 1f				call forth_push_numhl 
3994			 
3994					NEXTW 
3994 c3 e0 22			jp macro_next 
3997				endm 
# End of macro NEXTW
3997			.NEG: 
3997			 
3997				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3997 17				db WORD_SYS_CORE+3             
3998 da 39			dw .DIV            
399a 02				db 1 + 1 
399b .. 00			db "-",0              
399d				endm 
# End of macro CWHEAD
399d			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
399d					if DEBUG_FORTH_WORDS_KEY 
399d						DMARK "SUB" 
399d f5				push af  
399e 3a b2 39			ld a, (.dmark)  
39a1 32 b4 fe			ld (debug_mark),a  
39a4 3a b3 39			ld a, (.dmark+1)  
39a7 32 b5 fe			ld (debug_mark+1),a  
39aa 3a b4 39			ld a, (.dmark+2)  
39ad 32 b6 fe			ld (debug_mark+2),a  
39b0 18 03			jr .pastdmark  
39b2 ..			.dmark: db "SUB"  
39b5 f1			.pastdmark: pop af  
39b6			endm  
# End of macro DMARK
39b6						CALLMONITOR 
39b6 cd c6 18			call break_point_state  
39b9				endm  
# End of macro CALLMONITOR
39b9					endif 
39b9			 
39b9			 
39b9				; TODO add floating point number detection 
39b9					; v5 FORTH_DSP_VALUE 
39b9					FORTH_DSP 
39b9 cd f7 20			call macro_forth_dsp 
39bc				endm 
# End of macro FORTH_DSP
39bc 7e					ld a,(hl)	; get type of value on TOS 
39bd fe 02				cp DS_TYPE_INUM  
39bf 28 03				jr z, .neg_inum 
39c1			 
39c1					NEXTW 
39c1 c3 e0 22			jp macro_next 
39c4				endm 
# End of macro NEXTW
39c4			 
39c4			; float maths 
39c4			 
39c4				if FORTH_ENABLE_FLOATMATH 
39c4					jr .neg_done 
39c4			 
39c4				endif 
39c4					 
39c4			 
39c4			.neg_inum: 
39c4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39c4 cd 31 21			call macro_dsp_valuehl 
39c7				endm 
# End of macro FORTH_DSP_VALUEHL
39c7			 
39c7 e5					push hl 
39c8			 
39c8					; destroy value TOS 
39c8			 
39c8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c8 cd e9 21			call macro_forth_dsp_pop 
39cb				endm 
# End of macro FORTH_DSP_POP
39cb			 
39cb			 
39cb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39cb cd 31 21			call macro_dsp_valuehl 
39ce				endm 
# End of macro FORTH_DSP_VALUEHL
39ce			 
39ce					; one value on hl get other one back 
39ce			 
39ce d1					pop de 
39cf			 
39cf					; do the sub 
39cf			;		ex de, hl 
39cf			 
39cf ed 52				sbc hl,de 
39d1			 
39d1					; save it 
39d1			 
39d1			;		push hl	 
39d1			 
39d1					; 
39d1			 
39d1					; destroy value TOS 
39d1			 
39d1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39d1 cd e9 21			call macro_forth_dsp_pop 
39d4				endm 
# End of macro FORTH_DSP_POP
39d4			 
39d4					; TODO push value back onto stack for another op etc 
39d4			 
39d4			;		pop hl 
39d4			 
39d4 cd 3a 1f				call forth_push_numhl 
39d7			.neg_done: 
39d7			 
39d7					NEXTW 
39d7 c3 e0 22			jp macro_next 
39da				endm 
# End of macro NEXTW
39da			.DIV: 
39da				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
39da 18				db WORD_SYS_CORE+4             
39db 27 3a			dw .MUL            
39dd 02				db 1 + 1 
39de .. 00			db "/",0              
39e0				endm 
# End of macro CWHEAD
39e0			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
39e0					if DEBUG_FORTH_WORDS_KEY 
39e0						DMARK "DIV" 
39e0 f5				push af  
39e1 3a f5 39			ld a, (.dmark)  
39e4 32 b4 fe			ld (debug_mark),a  
39e7 3a f6 39			ld a, (.dmark+1)  
39ea 32 b5 fe			ld (debug_mark+1),a  
39ed 3a f7 39			ld a, (.dmark+2)  
39f0 32 b6 fe			ld (debug_mark+2),a  
39f3 18 03			jr .pastdmark  
39f5 ..			.dmark: db "DIV"  
39f8 f1			.pastdmark: pop af  
39f9			endm  
# End of macro DMARK
39f9						CALLMONITOR 
39f9 cd c6 18			call break_point_state  
39fc				endm  
# End of macro CALLMONITOR
39fc					endif 
39fc				; TODO add floating point number detection 
39fc					; v5 FORTH_DSP_VALUE 
39fc					FORTH_DSP 
39fc cd f7 20			call macro_forth_dsp 
39ff				endm 
# End of macro FORTH_DSP
39ff 7e					ld a,(hl)	; get type of value on TOS 
3a00 fe 02				cp DS_TYPE_INUM  
3a02 28 03				jr z, .div_inum 
3a04			 
3a04				if FORTH_ENABLE_FLOATMATH 
3a04					jr .div_done 
3a04			 
3a04				endif 
3a04					NEXTW 
3a04 c3 e0 22			jp macro_next 
3a07				endm 
# End of macro NEXTW
3a07			.div_inum: 
3a07			 
3a07					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a07 cd 31 21			call macro_dsp_valuehl 
3a0a				endm 
# End of macro FORTH_DSP_VALUEHL
3a0a			 
3a0a e5					push hl    ; to go to bc 
3a0b			 
3a0b					; destroy value TOS 
3a0b			 
3a0b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a0b cd e9 21			call macro_forth_dsp_pop 
3a0e				endm 
# End of macro FORTH_DSP_POP
3a0e			 
3a0e			 
3a0e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a0e cd 31 21			call macro_dsp_valuehl 
3a11				endm 
# End of macro FORTH_DSP_VALUEHL
3a11			 
3a11					; hl to go to de 
3a11			 
3a11 e5					push hl 
3a12			 
3a12 c1					pop bc 
3a13 d1					pop de		 
3a14			 
3a14			 
3a14					if DEBUG_FORTH_MATHS 
3a14						DMARK "DIV" 
3a14				CALLMONITOR 
3a14					endif 
3a14					; one value on hl but move to a get other one back 
3a14			 
3a14			        
3a14 cd a6 0e			call Div16 
3a17			 
3a17			;	push af	 
3a17 e5				push hl 
3a18 c5				push bc 
3a19			 
3a19					if DEBUG_FORTH_MATHS 
3a19						DMARK "DI1" 
3a19				CALLMONITOR 
3a19					endif 
3a19			 
3a19					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a19 cd e9 21			call macro_forth_dsp_pop 
3a1c				endm 
# End of macro FORTH_DSP_POP
3a1c			 
3a1c			 
3a1c			 
3a1c e1					pop hl    ; result 
3a1d			 
3a1d cd 3a 1f				call forth_push_numhl 
3a20			 
3a20 e1					pop hl    ; reminder 
3a21			;		ld h,0 
3a21			;		ld l,d 
3a21			 
3a21 cd 3a 1f				call forth_push_numhl 
3a24			.div_done: 
3a24					NEXTW 
3a24 c3 e0 22			jp macro_next 
3a27				endm 
# End of macro NEXTW
3a27			.MUL: 
3a27				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3a27 19				db WORD_SYS_CORE+5             
3a28 6c 3a			dw .MIN            
3a2a 02				db 1 + 1 
3a2b .. 00			db "*",0              
3a2d				endm 
# End of macro CWHEAD
3a2d			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3a2d				; TODO add floating point number detection 
3a2d					if DEBUG_FORTH_WORDS_KEY 
3a2d						DMARK "MUL" 
3a2d f5				push af  
3a2e 3a 42 3a			ld a, (.dmark)  
3a31 32 b4 fe			ld (debug_mark),a  
3a34 3a 43 3a			ld a, (.dmark+1)  
3a37 32 b5 fe			ld (debug_mark+1),a  
3a3a 3a 44 3a			ld a, (.dmark+2)  
3a3d 32 b6 fe			ld (debug_mark+2),a  
3a40 18 03			jr .pastdmark  
3a42 ..			.dmark: db "MUL"  
3a45 f1			.pastdmark: pop af  
3a46			endm  
# End of macro DMARK
3a46						CALLMONITOR 
3a46 cd c6 18			call break_point_state  
3a49				endm  
# End of macro CALLMONITOR
3a49					endif 
3a49					FORTH_DSP 
3a49 cd f7 20			call macro_forth_dsp 
3a4c				endm 
# End of macro FORTH_DSP
3a4c					; v5 FORTH_DSP_VALUE 
3a4c 7e					ld a,(hl)	; get type of value on TOS 
3a4d fe 02				cp DS_TYPE_INUM  
3a4f 28 03				jr z, .mul_inum 
3a51			 
3a51				if FORTH_ENABLE_FLOATMATH 
3a51					jr .mul_done 
3a51			 
3a51				endif 
3a51			 
3a51					NEXTW 
3a51 c3 e0 22			jp macro_next 
3a54				endm 
# End of macro NEXTW
3a54			.mul_inum:	 
3a54			 
3a54					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a54 cd 31 21			call macro_dsp_valuehl 
3a57				endm 
# End of macro FORTH_DSP_VALUEHL
3a57			 
3a57 e5					push hl 
3a58			 
3a58					; destroy value TOS 
3a58			 
3a58					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a58 cd e9 21			call macro_forth_dsp_pop 
3a5b				endm 
# End of macro FORTH_DSP_POP
3a5b			 
3a5b			 
3a5b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a5b cd 31 21			call macro_dsp_valuehl 
3a5e				endm 
# End of macro FORTH_DSP_VALUEHL
3a5e			 
3a5e					; one value on hl but move to a get other one back 
3a5e			 
3a5e 7d					ld a, l 
3a5f			 
3a5f d1					pop de 
3a60			 
3a60					; do the mull 
3a60			;		ex de, hl 
3a60			 
3a60 cd cc 0e				call Mult16 
3a63					; save it 
3a63			 
3a63			;		push hl	 
3a63			 
3a63					; 
3a63			 
3a63					; destroy value TOS 
3a63			 
3a63					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a63 cd e9 21			call macro_forth_dsp_pop 
3a66				endm 
# End of macro FORTH_DSP_POP
3a66			 
3a66					; TODO push value back onto stack for another op etc 
3a66			 
3a66			;		pop hl 
3a66			 
3a66 cd 3a 1f				call forth_push_numhl 
3a69			 
3a69			.mul_done: 
3a69					NEXTW 
3a69 c3 e0 22			jp macro_next 
3a6c				endm 
# End of macro NEXTW
3a6c			 
3a6c			 
3a6c			 
3a6c			 
3a6c			.MIN: 
3a6c				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3a6c 49				db WORD_SYS_CORE+53             
3a6d ed 3a			dw .MAX            
3a6f 04				db 3 + 1 
3a70 .. 00			db "MIN",0              
3a74				endm 
# End of macro CWHEAD
3a74			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3a74					if DEBUG_FORTH_WORDS_KEY 
3a74						DMARK "MIN" 
3a74 f5				push af  
3a75 3a 89 3a			ld a, (.dmark)  
3a78 32 b4 fe			ld (debug_mark),a  
3a7b 3a 8a 3a			ld a, (.dmark+1)  
3a7e 32 b5 fe			ld (debug_mark+1),a  
3a81 3a 8b 3a			ld a, (.dmark+2)  
3a84 32 b6 fe			ld (debug_mark+2),a  
3a87 18 03			jr .pastdmark  
3a89 ..			.dmark: db "MIN"  
3a8c f1			.pastdmark: pop af  
3a8d			endm  
# End of macro DMARK
3a8d						CALLMONITOR 
3a8d cd c6 18			call break_point_state  
3a90				endm  
# End of macro CALLMONITOR
3a90					endif 
3a90					; get u2 
3a90			 
3a90					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a90 cd 31 21			call macro_dsp_valuehl 
3a93				endm 
# End of macro FORTH_DSP_VALUEHL
3a93			 
3a93 e5					push hl   ; u2 
3a94			 
3a94					; destroy value TOS 
3a94			 
3a94					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a94 cd e9 21			call macro_forth_dsp_pop 
3a97				endm 
# End of macro FORTH_DSP_POP
3a97			 
3a97					; get u1 
3a97			 
3a97					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a97 cd 31 21			call macro_dsp_valuehl 
3a9a				endm 
# End of macro FORTH_DSP_VALUEHL
3a9a			 
3a9a e5					push hl  ; u1 
3a9b			 
3a9b					; destroy value TOS 
3a9b			 
3a9b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a9b cd e9 21			call macro_forth_dsp_pop 
3a9e				endm 
# End of macro FORTH_DSP_POP
3a9e			 
3a9e b7			 or a      ;clear carry flag 
3a9f e1			  pop hl    ; u1 
3aa0 d1			  pop de    ; u2 
3aa1 e5				push hl   ; saved in case hl is lowest 
3aa2 ed 52		  sbc hl,de 
3aa4 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3aa6			 
3aa6 e1				pop hl 
3aa7					if DEBUG_FORTH_WORDS 
3aa7						DMARK "MIN" 
3aa7 f5				push af  
3aa8 3a bc 3a			ld a, (.dmark)  
3aab 32 b4 fe			ld (debug_mark),a  
3aae 3a bd 3a			ld a, (.dmark+1)  
3ab1 32 b5 fe			ld (debug_mark+1),a  
3ab4 3a be 3a			ld a, (.dmark+2)  
3ab7 32 b6 fe			ld (debug_mark+2),a  
3aba 18 03			jr .pastdmark  
3abc ..			.dmark: db "MIN"  
3abf f1			.pastdmark: pop af  
3ac0			endm  
# End of macro DMARK
3ac0						CALLMONITOR 
3ac0 cd c6 18			call break_point_state  
3ac3				endm  
# End of macro CALLMONITOR
3ac3					endif 
3ac3 cd 3a 1f				call forth_push_numhl 
3ac6			 
3ac6				       NEXTW 
3ac6 c3 e0 22			jp macro_next 
3ac9				endm 
# End of macro NEXTW
3ac9			 
3ac9			.mincont:  
3ac9 c1				pop bc   ; tidy up 
3aca eb				ex de , hl  
3acb					if DEBUG_FORTH_WORDS 
3acb						DMARK "MI1" 
3acb f5				push af  
3acc 3a e0 3a			ld a, (.dmark)  
3acf 32 b4 fe			ld (debug_mark),a  
3ad2 3a e1 3a			ld a, (.dmark+1)  
3ad5 32 b5 fe			ld (debug_mark+1),a  
3ad8 3a e2 3a			ld a, (.dmark+2)  
3adb 32 b6 fe			ld (debug_mark+2),a  
3ade 18 03			jr .pastdmark  
3ae0 ..			.dmark: db "MI1"  
3ae3 f1			.pastdmark: pop af  
3ae4			endm  
# End of macro DMARK
3ae4						CALLMONITOR 
3ae4 cd c6 18			call break_point_state  
3ae7				endm  
# End of macro CALLMONITOR
3ae7					endif 
3ae7 cd 3a 1f				call forth_push_numhl 
3aea			 
3aea				       NEXTW 
3aea c3 e0 22			jp macro_next 
3aed				endm 
# End of macro NEXTW
3aed			.MAX: 
3aed				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3aed 4a				db WORD_SYS_CORE+54             
3aee 6e 3b			dw .RND16            
3af0 04				db 3 + 1 
3af1 .. 00			db "MAX",0              
3af5				endm 
# End of macro CWHEAD
3af5			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3af5					if DEBUG_FORTH_WORDS_KEY 
3af5						DMARK "MAX" 
3af5 f5				push af  
3af6 3a 0a 3b			ld a, (.dmark)  
3af9 32 b4 fe			ld (debug_mark),a  
3afc 3a 0b 3b			ld a, (.dmark+1)  
3aff 32 b5 fe			ld (debug_mark+1),a  
3b02 3a 0c 3b			ld a, (.dmark+2)  
3b05 32 b6 fe			ld (debug_mark+2),a  
3b08 18 03			jr .pastdmark  
3b0a ..			.dmark: db "MAX"  
3b0d f1			.pastdmark: pop af  
3b0e			endm  
# End of macro DMARK
3b0e						CALLMONITOR 
3b0e cd c6 18			call break_point_state  
3b11				endm  
# End of macro CALLMONITOR
3b11					endif 
3b11					; get u2 
3b11			 
3b11					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b11 cd 31 21			call macro_dsp_valuehl 
3b14				endm 
# End of macro FORTH_DSP_VALUEHL
3b14			 
3b14 e5					push hl   ; u2 
3b15			 
3b15					; destroy value TOS 
3b15			 
3b15					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b15 cd e9 21			call macro_forth_dsp_pop 
3b18				endm 
# End of macro FORTH_DSP_POP
3b18			 
3b18					; get u1 
3b18			 
3b18					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b18 cd 31 21			call macro_dsp_valuehl 
3b1b				endm 
# End of macro FORTH_DSP_VALUEHL
3b1b			 
3b1b e5					push hl  ; u1 
3b1c			 
3b1c					; destroy value TOS 
3b1c			 
3b1c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b1c cd e9 21			call macro_forth_dsp_pop 
3b1f				endm 
# End of macro FORTH_DSP_POP
3b1f			 
3b1f b7			 or a      ;clear carry flag 
3b20 e1			  pop hl    ; u1 
3b21 d1			  pop de    ; u2 
3b22 e5				push hl   ; saved in case hl is lowest 
3b23 ed 52		  sbc hl,de 
3b25 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3b27			 
3b27 e1				pop hl 
3b28					if DEBUG_FORTH_WORDS 
3b28						DMARK "MAX" 
3b28 f5				push af  
3b29 3a 3d 3b			ld a, (.dmark)  
3b2c 32 b4 fe			ld (debug_mark),a  
3b2f 3a 3e 3b			ld a, (.dmark+1)  
3b32 32 b5 fe			ld (debug_mark+1),a  
3b35 3a 3f 3b			ld a, (.dmark+2)  
3b38 32 b6 fe			ld (debug_mark+2),a  
3b3b 18 03			jr .pastdmark  
3b3d ..			.dmark: db "MAX"  
3b40 f1			.pastdmark: pop af  
3b41			endm  
# End of macro DMARK
3b41						CALLMONITOR 
3b41 cd c6 18			call break_point_state  
3b44				endm  
# End of macro CALLMONITOR
3b44					endif 
3b44 cd 3a 1f				call forth_push_numhl 
3b47			 
3b47				       NEXTW 
3b47 c3 e0 22			jp macro_next 
3b4a				endm 
# End of macro NEXTW
3b4a			 
3b4a			.maxcont:  
3b4a c1				pop bc   ; tidy up 
3b4b eb				ex de , hl  
3b4c					if DEBUG_FORTH_WORDS 
3b4c						DMARK "MA1" 
3b4c f5				push af  
3b4d 3a 61 3b			ld a, (.dmark)  
3b50 32 b4 fe			ld (debug_mark),a  
3b53 3a 62 3b			ld a, (.dmark+1)  
3b56 32 b5 fe			ld (debug_mark+1),a  
3b59 3a 63 3b			ld a, (.dmark+2)  
3b5c 32 b6 fe			ld (debug_mark+2),a  
3b5f 18 03			jr .pastdmark  
3b61 ..			.dmark: db "MA1"  
3b64 f1			.pastdmark: pop af  
3b65			endm  
# End of macro DMARK
3b65						CALLMONITOR 
3b65 cd c6 18			call break_point_state  
3b68				endm  
# End of macro CALLMONITOR
3b68					endif 
3b68 cd 3a 1f				call forth_push_numhl 
3b6b				       NEXTW 
3b6b c3 e0 22			jp macro_next 
3b6e				endm 
# End of macro NEXTW
3b6e			 
3b6e			.RND16: 
3b6e				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3b6e 4e				db WORD_SYS_CORE+58             
3b6f 9d 3b			dw .RND8            
3b71 06				db 5 + 1 
3b72 .. 00			db "RND16",0              
3b78				endm 
# End of macro CWHEAD
3b78			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3b78					if DEBUG_FORTH_WORDS_KEY 
3b78						DMARK "R16" 
3b78 f5				push af  
3b79 3a 8d 3b			ld a, (.dmark)  
3b7c 32 b4 fe			ld (debug_mark),a  
3b7f 3a 8e 3b			ld a, (.dmark+1)  
3b82 32 b5 fe			ld (debug_mark+1),a  
3b85 3a 8f 3b			ld a, (.dmark+2)  
3b88 32 b6 fe			ld (debug_mark+2),a  
3b8b 18 03			jr .pastdmark  
3b8d ..			.dmark: db "R16"  
3b90 f1			.pastdmark: pop af  
3b91			endm  
# End of macro DMARK
3b91						CALLMONITOR 
3b91 cd c6 18			call break_point_state  
3b94				endm  
# End of macro CALLMONITOR
3b94					endif 
3b94 cd 70 0e				call prng16  
3b97 cd 3a 1f				call forth_push_numhl 
3b9a				       NEXTW 
3b9a c3 e0 22			jp macro_next 
3b9d				endm 
# End of macro NEXTW
3b9d			.RND8: 
3b9d				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3b9d 60				db WORD_SYS_CORE+76             
3b9e d2 3b			dw .RND            
3ba0 05				db 4 + 1 
3ba1 .. 00			db "RND8",0              
3ba6				endm 
# End of macro CWHEAD
3ba6			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3ba6					if DEBUG_FORTH_WORDS_KEY 
3ba6						DMARK "RN8" 
3ba6 f5				push af  
3ba7 3a bb 3b			ld a, (.dmark)  
3baa 32 b4 fe			ld (debug_mark),a  
3bad 3a bc 3b			ld a, (.dmark+1)  
3bb0 32 b5 fe			ld (debug_mark+1),a  
3bb3 3a bd 3b			ld a, (.dmark+2)  
3bb6 32 b6 fe			ld (debug_mark+2),a  
3bb9 18 03			jr .pastdmark  
3bbb ..			.dmark: db "RN8"  
3bbe f1			.pastdmark: pop af  
3bbf			endm  
# End of macro DMARK
3bbf						CALLMONITOR 
3bbf cd c6 18			call break_point_state  
3bc2				endm  
# End of macro CALLMONITOR
3bc2					endif 
3bc2 2a 35 fd				ld hl,(xrandc) 
3bc5 23					inc hl 
3bc6 cd 8a 0e				call xrnd 
3bc9 6f					ld l,a	 
3bca 26 00				ld h,0 
3bcc cd 3a 1f				call forth_push_numhl 
3bcf				       NEXTW 
3bcf c3 e0 22			jp macro_next 
3bd2				endm 
# End of macro NEXTW
3bd2			.RND: 
3bd2				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3bd2 60				db WORD_SYS_CORE+76             
3bd3 d8 3c			dw .ENDMATHS            
3bd5 04				db 3 + 1 
3bd6 .. 00			db "RND",0              
3bda				endm 
# End of macro CWHEAD
3bda			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3bda			 
3bda					if DEBUG_FORTH_WORDS_KEY 
3bda						DMARK "RND" 
3bda f5				push af  
3bdb 3a ef 3b			ld a, (.dmark)  
3bde 32 b4 fe			ld (debug_mark),a  
3be1 3a f0 3b			ld a, (.dmark+1)  
3be4 32 b5 fe			ld (debug_mark+1),a  
3be7 3a f1 3b			ld a, (.dmark+2)  
3bea 32 b6 fe			ld (debug_mark+2),a  
3bed 18 03			jr .pastdmark  
3bef ..			.dmark: db "RND"  
3bf2 f1			.pastdmark: pop af  
3bf3			endm  
# End of macro DMARK
3bf3						CALLMONITOR 
3bf3 cd c6 18			call break_point_state  
3bf6				endm  
# End of macro CALLMONITOR
3bf6					endif 
3bf6					 
3bf6					FORTH_DSP_VALUEHL    ; upper range 
3bf6 cd 31 21			call macro_dsp_valuehl 
3bf9				endm 
# End of macro FORTH_DSP_VALUEHL
3bf9			 
3bf9 22 39 fd				ld (LFSRSeed), hl	 
3bfc			 
3bfc					if DEBUG_FORTH_WORDS 
3bfc						DMARK "RN1" 
3bfc f5				push af  
3bfd 3a 11 3c			ld a, (.dmark)  
3c00 32 b4 fe			ld (debug_mark),a  
3c03 3a 12 3c			ld a, (.dmark+1)  
3c06 32 b5 fe			ld (debug_mark+1),a  
3c09 3a 13 3c			ld a, (.dmark+2)  
3c0c 32 b6 fe			ld (debug_mark+2),a  
3c0f 18 03			jr .pastdmark  
3c11 ..			.dmark: db "RN1"  
3c14 f1			.pastdmark: pop af  
3c15			endm  
# End of macro DMARK
3c15						CALLMONITOR 
3c15 cd c6 18			call break_point_state  
3c18				endm  
# End of macro CALLMONITOR
3c18					endif 
3c18					FORTH_DSP_POP 
3c18 cd e9 21			call macro_forth_dsp_pop 
3c1b				endm 
# End of macro FORTH_DSP_POP
3c1b			 
3c1b					FORTH_DSP_VALUEHL    ; low range 
3c1b cd 31 21			call macro_dsp_valuehl 
3c1e				endm 
# End of macro FORTH_DSP_VALUEHL
3c1e			 
3c1e					if DEBUG_FORTH_WORDS 
3c1e						DMARK "RN2" 
3c1e f5				push af  
3c1f 3a 33 3c			ld a, (.dmark)  
3c22 32 b4 fe			ld (debug_mark),a  
3c25 3a 34 3c			ld a, (.dmark+1)  
3c28 32 b5 fe			ld (debug_mark+1),a  
3c2b 3a 35 3c			ld a, (.dmark+2)  
3c2e 32 b6 fe			ld (debug_mark+2),a  
3c31 18 03			jr .pastdmark  
3c33 ..			.dmark: db "RN2"  
3c36 f1			.pastdmark: pop af  
3c37			endm  
# End of macro DMARK
3c37						CALLMONITOR 
3c37 cd c6 18			call break_point_state  
3c3a				endm  
# End of macro CALLMONITOR
3c3a					endif 
3c3a 22 3b fd				ld (LFSRSeed+2), hl 
3c3d			 
3c3d					FORTH_DSP_POP 
3c3d cd e9 21			call macro_forth_dsp_pop 
3c40				endm 
# End of macro FORTH_DSP_POP
3c40			 
3c40 e5					push hl 
3c41			 
3c41 e1			.inrange:	pop hl 
3c42 cd 70 0e				call prng16  
3c45					if DEBUG_FORTH_WORDS 
3c45						DMARK "RN3" 
3c45 f5				push af  
3c46 3a 5a 3c			ld a, (.dmark)  
3c49 32 b4 fe			ld (debug_mark),a  
3c4c 3a 5b 3c			ld a, (.dmark+1)  
3c4f 32 b5 fe			ld (debug_mark+1),a  
3c52 3a 5c 3c			ld a, (.dmark+2)  
3c55 32 b6 fe			ld (debug_mark+2),a  
3c58 18 03			jr .pastdmark  
3c5a ..			.dmark: db "RN3"  
3c5d f1			.pastdmark: pop af  
3c5e			endm  
# End of macro DMARK
3c5e						CALLMONITOR 
3c5e cd c6 18			call break_point_state  
3c61				endm  
# End of macro CALLMONITOR
3c61					endif 
3c61					 
3c61					; if the range is 8bit knock out the high byte 
3c61			 
3c61 ed 5b 39 fd			ld de, (LFSRSeed)     ; check high level 
3c65			 
3c65 3e 00				ld a, 0 
3c67 ba					cp d  
3c68 20 1e				jr nz, .hirange 
3c6a 26 00				ld h, 0   ; knock it down to 8bit 
3c6c			 
3c6c					if DEBUG_FORTH_WORDS 
3c6c						DMARK "RNk" 
3c6c f5				push af  
3c6d 3a 81 3c			ld a, (.dmark)  
3c70 32 b4 fe			ld (debug_mark),a  
3c73 3a 82 3c			ld a, (.dmark+1)  
3c76 32 b5 fe			ld (debug_mark+1),a  
3c79 3a 83 3c			ld a, (.dmark+2)  
3c7c 32 b6 fe			ld (debug_mark+2),a  
3c7f 18 03			jr .pastdmark  
3c81 ..			.dmark: db "RNk"  
3c84 f1			.pastdmark: pop af  
3c85			endm  
# End of macro DMARK
3c85						CALLMONITOR 
3c85 cd c6 18			call break_point_state  
3c88				endm  
# End of macro CALLMONITOR
3c88					endif 
3c88			.hirange:   
3c88 e5					push hl  
3c89 b7					or a  
3c8a ed 52		                sbc hl, de 
3c8c			 
3c8c					;call cmp16 
3c8c			 
3c8c 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3c8e e1					pop hl 
3c8f e5					push hl 
3c90			 
3c90					if DEBUG_FORTH_WORDS 
3c90						DMARK "RN4" 
3c90 f5				push af  
3c91 3a a5 3c			ld a, (.dmark)  
3c94 32 b4 fe			ld (debug_mark),a  
3c97 3a a6 3c			ld a, (.dmark+1)  
3c9a 32 b5 fe			ld (debug_mark+1),a  
3c9d 3a a7 3c			ld a, (.dmark+2)  
3ca0 32 b6 fe			ld (debug_mark+2),a  
3ca3 18 03			jr .pastdmark  
3ca5 ..			.dmark: db "RN4"  
3ca8 f1			.pastdmark: pop af  
3ca9			endm  
# End of macro DMARK
3ca9						CALLMONITOR 
3ca9 cd c6 18			call break_point_state  
3cac				endm  
# End of macro CALLMONITOR
3cac					endif 
3cac ed 5b 3b fd			ld de, (LFSRSeed+2)   ; check low range 
3cb0					;call cmp16 
3cb0				 
3cb0 b7					or a  
3cb1 ed 52		                sbc hl, de 
3cb3 38 8c				jr c, .inrange 
3cb5			 
3cb5 e1					pop hl 
3cb6					 
3cb6					if DEBUG_FORTH_WORDS 
3cb6						DMARK "RNd" 
3cb6 f5				push af  
3cb7 3a cb 3c			ld a, (.dmark)  
3cba 32 b4 fe			ld (debug_mark),a  
3cbd 3a cc 3c			ld a, (.dmark+1)  
3cc0 32 b5 fe			ld (debug_mark+1),a  
3cc3 3a cd 3c			ld a, (.dmark+2)  
3cc6 32 b6 fe			ld (debug_mark+2),a  
3cc9 18 03			jr .pastdmark  
3ccb ..			.dmark: db "RNd"  
3cce f1			.pastdmark: pop af  
3ccf			endm  
# End of macro DMARK
3ccf						CALLMONITOR 
3ccf cd c6 18			call break_point_state  
3cd2				endm  
# End of macro CALLMONITOR
3cd2					endif 
3cd2			 
3cd2			 
3cd2 cd 3a 1f				call forth_push_numhl 
3cd5				       NEXTW 
3cd5 c3 e0 22			jp macro_next 
3cd8				endm 
# End of macro NEXTW
3cd8			 
3cd8			.ENDMATHS: 
3cd8			 
3cd8			; eof 
3cd8			 
# End of file forth_words_maths.asm
3cd8			include "forth_words_display.asm" 
3cd8			 
3cd8			; | ## Display Words 
3cd8			 
3cd8			.INFO: 
3cd8			 
3cd8				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3cd8 62				db WORD_SYS_CORE+78             
3cd9 f5 3c			dw .ATP            
3cdb 05				db 4 + 1 
3cdc .. 00			db "INFO",0              
3ce1				endm 
# End of macro CWHEAD
3ce1			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3ce1					FORTH_DSP_VALUEHL 
3ce1 cd 31 21			call macro_dsp_valuehl 
3ce4				endm 
# End of macro FORTH_DSP_VALUEHL
3ce4			 
3ce4					FORTH_DSP_POP 
3ce4 cd e9 21			call macro_forth_dsp_pop 
3ce7				endm 
# End of macro FORTH_DSP_POP
3ce7			 
3ce7 e5					push hl 
3ce8			 
3ce8					FORTH_DSP_VALUEHL 
3ce8 cd 31 21			call macro_dsp_valuehl 
3ceb				endm 
# End of macro FORTH_DSP_VALUEHL
3ceb			 
3ceb					FORTH_DSP_POP 
3ceb cd e9 21			call macro_forth_dsp_pop 
3cee				endm 
# End of macro FORTH_DSP_POP
3cee			 
3cee d1					pop de 
3cef			 
3cef cd a6 0c				call info_panel 
3cf2			 
3cf2			 
3cf2					NEXTW 
3cf2 c3 e0 22			jp macro_next 
3cf5				endm 
# End of macro NEXTW
3cf5			.ATP: 
3cf5				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3cf5 62				db WORD_SYS_CORE+78             
3cf6 6c 3d			dw .FB            
3cf8 04				db 3 + 1 
3cf9 .. 00			db "AT?",0              
3cfd				endm 
# End of macro CWHEAD
3cfd			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3cfd					if DEBUG_FORTH_WORDS_KEY 
3cfd						DMARK "AT?" 
3cfd f5				push af  
3cfe 3a 12 3d			ld a, (.dmark)  
3d01 32 b4 fe			ld (debug_mark),a  
3d04 3a 13 3d			ld a, (.dmark+1)  
3d07 32 b5 fe			ld (debug_mark+1),a  
3d0a 3a 14 3d			ld a, (.dmark+2)  
3d0d 32 b6 fe			ld (debug_mark+2),a  
3d10 18 03			jr .pastdmark  
3d12 ..			.dmark: db "AT?"  
3d15 f1			.pastdmark: pop af  
3d16			endm  
# End of macro DMARK
3d16						CALLMONITOR 
3d16 cd c6 18			call break_point_state  
3d19				endm  
# End of macro CALLMONITOR
3d19					endif 
3d19 3a eb fb				ld a, (f_cursor_ptr) 
3d1c			 
3d1c			if DEBUG_FORTH_WORDS 
3d1c				DMARK "AT?" 
3d1c f5				push af  
3d1d 3a 31 3d			ld a, (.dmark)  
3d20 32 b4 fe			ld (debug_mark),a  
3d23 3a 32 3d			ld a, (.dmark+1)  
3d26 32 b5 fe			ld (debug_mark+1),a  
3d29 3a 33 3d			ld a, (.dmark+2)  
3d2c 32 b6 fe			ld (debug_mark+2),a  
3d2f 18 03			jr .pastdmark  
3d31 ..			.dmark: db "AT?"  
3d34 f1			.pastdmark: pop af  
3d35			endm  
# End of macro DMARK
3d35				CALLMONITOR 
3d35 cd c6 18			call break_point_state  
3d38				endm  
# End of macro CALLMONITOR
3d38			endif	 
3d38					; count the number of rows 
3d38			 
3d38 06 00				ld b, 0 
3d3a 4f			.atpr:		ld c, a    ; save in case we go below zero 
3d3b d6 14				sub display_cols 
3d3d f2 43 3d				jp p, .atprunder 
3d40 04					inc b 
3d41 18 f7				jr .atpr 
3d43			.atprunder:	 
3d43			if DEBUG_FORTH_WORDS 
3d43				DMARK "A?2" 
3d43 f5				push af  
3d44 3a 58 3d			ld a, (.dmark)  
3d47 32 b4 fe			ld (debug_mark),a  
3d4a 3a 59 3d			ld a, (.dmark+1)  
3d4d 32 b5 fe			ld (debug_mark+1),a  
3d50 3a 5a 3d			ld a, (.dmark+2)  
3d53 32 b6 fe			ld (debug_mark+2),a  
3d56 18 03			jr .pastdmark  
3d58 ..			.dmark: db "A?2"  
3d5b f1			.pastdmark: pop af  
3d5c			endm  
# End of macro DMARK
3d5c				CALLMONITOR 
3d5c cd c6 18			call break_point_state  
3d5f				endm  
# End of macro CALLMONITOR
3d5f			endif	 
3d5f 26 00				ld h, 0 
3d61 69					ld l, c 
3d62 cd 3a 1f				call forth_push_numhl 
3d65 68					ld l, b  
3d66 cd 3a 1f				call forth_push_numhl 
3d69			 
3d69			 
3d69				NEXTW 
3d69 c3 e0 22			jp macro_next 
3d6c				endm 
# End of macro NEXTW
3d6c			 
3d6c			.FB: 
3d6c				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3d6c 1b				db WORD_SYS_CORE+7             
3d6d ba 3d			dw .EMIT            
3d6f 03				db 2 + 1 
3d70 .. 00			db "FB",0              
3d73				endm 
# End of macro CWHEAD
3d73			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3d73			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3d73			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3d73			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3d73					if DEBUG_FORTH_WORDS_KEY 
3d73						DMARK "FB." 
3d73 f5				push af  
3d74 3a 88 3d			ld a, (.dmark)  
3d77 32 b4 fe			ld (debug_mark),a  
3d7a 3a 89 3d			ld a, (.dmark+1)  
3d7d 32 b5 fe			ld (debug_mark+1),a  
3d80 3a 8a 3d			ld a, (.dmark+2)  
3d83 32 b6 fe			ld (debug_mark+2),a  
3d86 18 03			jr .pastdmark  
3d88 ..			.dmark: db "FB."  
3d8b f1			.pastdmark: pop af  
3d8c			endm  
# End of macro DMARK
3d8c						CALLMONITOR 
3d8c cd c6 18			call break_point_state  
3d8f				endm  
# End of macro CALLMONITOR
3d8f					endif 
3d8f			 
3d8f					FORTH_DSP_VALUEHL 
3d8f cd 31 21			call macro_dsp_valuehl 
3d92				endm 
# End of macro FORTH_DSP_VALUEHL
3d92			 
3d92 7d					ld a, l 
3d93 fe 01				cp 1 
3d95 20 05				jr nz, .fbn1 
3d97 21 f9 fd				ld hl, display_fb1 
3d9a 18 15				jr .fbset 
3d9c fe 02		.fbn1:		cp 2 
3d9e 20 05				jr nz, .fbn2 
3da0 21 57 fd				ld hl, display_fb2 
3da3 18 0c				jr .fbset 
3da5 fe 03		.fbn2:		cp 3 
3da7 20 05				jr nz, .fbn3 
3da9 21 a8 fd				ld hl, display_fb3 
3dac 18 03				jr .fbset 
3dae			.fbn3:		 ; if invalid number select first 
3dae 21 f9 fd				ld hl, display_fb1 
3db1 22 55 fd		.fbset:		ld (display_fb_active), hl 
3db4			 
3db4					FORTH_DSP_POP 
3db4 cd e9 21			call macro_forth_dsp_pop 
3db7				endm 
# End of macro FORTH_DSP_POP
3db7			 
3db7					NEXTW 
3db7 c3 e0 22			jp macro_next 
3dba				endm 
# End of macro NEXTW
3dba			 
3dba			 
3dba			.EMIT: 
3dba				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3dba 1b				db WORD_SYS_CORE+7             
3dbb 0b 3e			dw .DOTH            
3dbd 05				db 4 + 1 
3dbe .. 00			db "EMIT",0              
3dc3				endm 
# End of macro CWHEAD
3dc3			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3dc3					; get value off TOS and display it 
3dc3			 
3dc3					if DEBUG_FORTH_WORDS_KEY 
3dc3						DMARK "EMT" 
3dc3 f5				push af  
3dc4 3a d8 3d			ld a, (.dmark)  
3dc7 32 b4 fe			ld (debug_mark),a  
3dca 3a d9 3d			ld a, (.dmark+1)  
3dcd 32 b5 fe			ld (debug_mark+1),a  
3dd0 3a da 3d			ld a, (.dmark+2)  
3dd3 32 b6 fe			ld (debug_mark+2),a  
3dd6 18 03			jr .pastdmark  
3dd8 ..			.dmark: db "EMT"  
3ddb f1			.pastdmark: pop af  
3ddc			endm  
# End of macro DMARK
3ddc						CALLMONITOR 
3ddc cd c6 18			call break_point_state  
3ddf				endm  
# End of macro CALLMONITOR
3ddf					endif 
3ddf			 
3ddf					FORTH_DSP_VALUEHL 
3ddf cd 31 21			call macro_dsp_valuehl 
3de2				endm 
# End of macro FORTH_DSP_VALUEHL
3de2			 
3de2 7d					ld a,l 
3de3			 
3de3					; TODO write to display 
3de3			 
3de3 32 4c f5				ld (os_input), a 
3de6 3e 00				ld a, 0 
3de8 32 4d f5				ld (os_input+1), a 
3deb					 
3deb 3a eb fb				ld a, (f_cursor_ptr) 
3dee 11 4c f5				ld de, os_input 
3df1 cd 28 0d				call str_at_display 
3df4			 
3df4			 
3df4 3a c9 fb				ld a,(cli_autodisplay) 
3df7 fe 00				cp 0 
3df9 28 03				jr z, .enoupdate 
3dfb cd 38 0d						call update_display 
3dfe					.enoupdate: 
3dfe			 
3dfe 3a eb fb				ld a, (f_cursor_ptr) 
3e01 3c					inc a 
3e02 32 eb fb				ld (f_cursor_ptr), a   ; save new pos 
3e05			 
3e05			 
3e05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e05 cd e9 21			call macro_forth_dsp_pop 
3e08				endm 
# End of macro FORTH_DSP_POP
3e08			  
3e08			 
3e08					NEXTW 
3e08 c3 e0 22			jp macro_next 
3e0b				endm 
# End of macro NEXTW
3e0b			.DOTH: 
3e0b				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3e0b 1c				db WORD_SYS_CORE+8             
3e0c 3b 3e			dw .DOTF            
3e0e 03				db 2 + 1 
3e0f .. 00			db ".-",0              
3e12				endm 
# End of macro CWHEAD
3e12			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3e12					; get value off TOS and display it 
3e12					if DEBUG_FORTH_WORDS_KEY 
3e12						DMARK "DTD" 
3e12 f5				push af  
3e13 3a 27 3e			ld a, (.dmark)  
3e16 32 b4 fe			ld (debug_mark),a  
3e19 3a 28 3e			ld a, (.dmark+1)  
3e1c 32 b5 fe			ld (debug_mark+1),a  
3e1f 3a 29 3e			ld a, (.dmark+2)  
3e22 32 b6 fe			ld (debug_mark+2),a  
3e25 18 03			jr .pastdmark  
3e27 ..			.dmark: db "DTD"  
3e2a f1			.pastdmark: pop af  
3e2b			endm  
# End of macro DMARK
3e2b						CALLMONITOR 
3e2b cd c6 18			call break_point_state  
3e2e				endm  
# End of macro CALLMONITOR
3e2e					endif 
3e2e 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3e30 3e 00			ld a, 0 
3e32 32 ca fb			ld (cli_mvdot), a 
3e35 c3 92 3e			jp .dotgo 
3e38				NEXTW 
3e38 c3 e0 22			jp macro_next 
3e3b				endm 
# End of macro NEXTW
3e3b			.DOTF: 
3e3b				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3e3b 1c				db WORD_SYS_CORE+8             
3e3c 69 3e			dw .DOT            
3e3e 03				db 2 + 1 
3e3f .. 00			db ".>",0              
3e42				endm 
# End of macro CWHEAD
3e42			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3e42					; get value off TOS and display it 
3e42			        ; TODO BUG adds extra spaces 
3e42			        ; TODO BUG handle numerics? 
3e42					if DEBUG_FORTH_WORDS_KEY 
3e42						DMARK "DTC" 
3e42 f5				push af  
3e43 3a 57 3e			ld a, (.dmark)  
3e46 32 b4 fe			ld (debug_mark),a  
3e49 3a 58 3e			ld a, (.dmark+1)  
3e4c 32 b5 fe			ld (debug_mark+1),a  
3e4f 3a 59 3e			ld a, (.dmark+2)  
3e52 32 b6 fe			ld (debug_mark+2),a  
3e55 18 03			jr .pastdmark  
3e57 ..			.dmark: db "DTC"  
3e5a f1			.pastdmark: pop af  
3e5b			endm  
# End of macro DMARK
3e5b						CALLMONITOR 
3e5b cd c6 18			call break_point_state  
3e5e				endm  
# End of macro CALLMONITOR
3e5e					endif 
3e5e 3e 01			ld a, 1 
3e60 32 ca fb			ld (cli_mvdot), a 
3e63 c3 92 3e			jp .dotgo 
3e66				NEXTW 
3e66 c3 e0 22			jp macro_next 
3e69				endm 
# End of macro NEXTW
3e69			 
3e69			.DOT: 
3e69				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3e69 1c				db WORD_SYS_CORE+8             
3e6a 45 40			dw .CLS            
3e6c 02				db 1 + 1 
3e6d .. 00			db ".",0              
3e6f				endm 
# End of macro CWHEAD
3e6f			        ; | . ( u -- ) Display TOS | DONE 
3e6f					; get value off TOS and display it 
3e6f			 
3e6f					if DEBUG_FORTH_WORDS_KEY 
3e6f						DMARK "DOT" 
3e6f f5				push af  
3e70 3a 84 3e			ld a, (.dmark)  
3e73 32 b4 fe			ld (debug_mark),a  
3e76 3a 85 3e			ld a, (.dmark+1)  
3e79 32 b5 fe			ld (debug_mark+1),a  
3e7c 3a 86 3e			ld a, (.dmark+2)  
3e7f 32 b6 fe			ld (debug_mark+2),a  
3e82 18 03			jr .pastdmark  
3e84 ..			.dmark: db "DOT"  
3e87 f1			.pastdmark: pop af  
3e88			endm  
# End of macro DMARK
3e88						CALLMONITOR 
3e88 cd c6 18			call break_point_state  
3e8b				endm  
# End of macro CALLMONITOR
3e8b					endif 
3e8b 3e 00			ld a, 0 
3e8d 32 ca fb			ld (cli_mvdot), a 
3e90 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3e92				 
3e92			 
3e92			.dotgo: 
3e92			 
3e92			; move up type to on stack for parserv5 
3e92					FORTH_DSP 
3e92 cd f7 20			call macro_forth_dsp 
3e95				endm 
# End of macro FORTH_DSP
3e95				;FORTH_DSP_VALUE  
3e95			 
3e95			if DEBUG_FORTH_DOT 
3e95				DMARK "DOT" 
3e95 f5				push af  
3e96 3a aa 3e			ld a, (.dmark)  
3e99 32 b4 fe			ld (debug_mark),a  
3e9c 3a ab 3e			ld a, (.dmark+1)  
3e9f 32 b5 fe			ld (debug_mark+1),a  
3ea2 3a ac 3e			ld a, (.dmark+2)  
3ea5 32 b6 fe			ld (debug_mark+2),a  
3ea8 18 03			jr .pastdmark  
3eaa ..			.dmark: db "DOT"  
3ead f1			.pastdmark: pop af  
3eae			endm  
# End of macro DMARK
3eae				CALLMONITOR 
3eae cd c6 18			call break_point_state  
3eb1				endm  
# End of macro CALLMONITOR
3eb1			endif	 
3eb1			;		.print: 
3eb1			 
3eb1 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3eb2 23				inc hl   ; position to the actual value 
3eb3 fe 01			cp DS_TYPE_STR 
3eb5 20 06			jr nz, .dotnum1  
3eb7			 
3eb7			; display string 
3eb7				FORTH_DSP_VALUE  
3eb7 cd 1a 21			call macro_forth_dsp_value 
3eba				endm 
# End of macro FORTH_DSP_VALUE
3eba eb				ex de,hl 
3ebb 18 49			jr .dotwrite 
3ebd			 
3ebd			.dotnum1: 
3ebd fe 02			cp DS_TYPE_INUM 
3ebf 20 44			jr nz, .dotflot 
3ec1			 
3ec1			 
3ec1			; display number 
3ec1			 
3ec1			;	push hl 
3ec1			;	call clear_display 
3ec1			;	pop hl 
3ec1			 
3ec1 5e				ld e, (hl) 
3ec2 23				inc hl 
3ec3 56				ld d, (hl) 
3ec4 21 4e f3			ld hl, scratch 
3ec7			if DEBUG_FORTH_DOT 
3ec7				DMARK "DT1" 
3ec7 f5				push af  
3ec8 3a dc 3e			ld a, (.dmark)  
3ecb 32 b4 fe			ld (debug_mark),a  
3ece 3a dd 3e			ld a, (.dmark+1)  
3ed1 32 b5 fe			ld (debug_mark+1),a  
3ed4 3a de 3e			ld a, (.dmark+2)  
3ed7 32 b6 fe			ld (debug_mark+2),a  
3eda 18 03			jr .pastdmark  
3edc ..			.dmark: db "DT1"  
3edf f1			.pastdmark: pop af  
3ee0			endm  
# End of macro DMARK
3ee0				CALLMONITOR 
3ee0 cd c6 18			call break_point_state  
3ee3				endm  
# End of macro CALLMONITOR
3ee3			endif	 
3ee3			 
3ee3 cd 56 13			call uitoa_16 
3ee6 eb				ex de,hl 
3ee7			 
3ee7			if DEBUG_FORTH_DOT 
3ee7				DMARK "DT2" 
3ee7 f5				push af  
3ee8 3a fc 3e			ld a, (.dmark)  
3eeb 32 b4 fe			ld (debug_mark),a  
3eee 3a fd 3e			ld a, (.dmark+1)  
3ef1 32 b5 fe			ld (debug_mark+1),a  
3ef4 3a fe 3e			ld a, (.dmark+2)  
3ef7 32 b6 fe			ld (debug_mark+2),a  
3efa 18 03			jr .pastdmark  
3efc ..			.dmark: db "DT2"  
3eff f1			.pastdmark: pop af  
3f00			endm  
# End of macro DMARK
3f00				CALLMONITOR 
3f00 cd c6 18			call break_point_state  
3f03				endm  
# End of macro CALLMONITOR
3f03			endif	 
3f03			 
3f03			;	ld de, os_word_scratch 
3f03 18 01			jr .dotwrite 
3f05			 
3f05 00			.dotflot:   nop 
3f06			; TODO print floating point number 
3f06			 
3f06			.dotwrite:		 
3f06			 
3f06					; if c is set then set all '-' to spaces 
3f06					; need to also take into account .>  
3f06			 
3f06 3e 01				ld a, 1 
3f08 b9					cp c 
3f09 20 67				jr nz, .nodashswap 
3f0b			 
3f0b					; DE has the string to write, working with HL 
3f0b			 
3f0b 06 ff				ld b, 255 
3f0d d5					push de 
3f0e e1					pop hl 
3f0f			 
3f0f			if DEBUG_FORTH_DOT 
3f0f				DMARK "DT-" 
3f0f f5				push af  
3f10 3a 24 3f			ld a, (.dmark)  
3f13 32 b4 fe			ld (debug_mark),a  
3f16 3a 25 3f			ld a, (.dmark+1)  
3f19 32 b5 fe			ld (debug_mark+1),a  
3f1c 3a 26 3f			ld a, (.dmark+2)  
3f1f 32 b6 fe			ld (debug_mark+2),a  
3f22 18 03			jr .pastdmark  
3f24 ..			.dmark: db "DT-"  
3f27 f1			.pastdmark: pop af  
3f28			endm  
# End of macro DMARK
3f28				CALLMONITOR 
3f28 cd c6 18			call break_point_state  
3f2b				endm  
# End of macro CALLMONITOR
3f2b			endif	 
3f2b 7e			.dashscan:	ld a, (hl) 
3f2c fe 00				cp 0 
3f2e 28 42				jr z, .nodashswap 
3f30 fe 2d				cp '-' 
3f32 20 03				jr nz, .dashskip 
3f34 3e 20				ld a, ' ' 
3f36 77					ld (hl), a 
3f37 23			.dashskip:	inc hl 
3f38			if DEBUG_FORTH_DOT 
3f38				DMARK "D-2" 
3f38 f5				push af  
3f39 3a 4d 3f			ld a, (.dmark)  
3f3c 32 b4 fe			ld (debug_mark),a  
3f3f 3a 4e 3f			ld a, (.dmark+1)  
3f42 32 b5 fe			ld (debug_mark+1),a  
3f45 3a 4f 3f			ld a, (.dmark+2)  
3f48 32 b6 fe			ld (debug_mark+2),a  
3f4b 18 03			jr .pastdmark  
3f4d ..			.dmark: db "D-2"  
3f50 f1			.pastdmark: pop af  
3f51			endm  
# End of macro DMARK
3f51				CALLMONITOR 
3f51 cd c6 18			call break_point_state  
3f54				endm  
# End of macro CALLMONITOR
3f54			endif	 
3f54 10 d5				djnz .dashscan 
3f56			 
3f56			if DEBUG_FORTH_DOT 
3f56				DMARK "D-1" 
3f56 f5				push af  
3f57 3a 6b 3f			ld a, (.dmark)  
3f5a 32 b4 fe			ld (debug_mark),a  
3f5d 3a 6c 3f			ld a, (.dmark+1)  
3f60 32 b5 fe			ld (debug_mark+1),a  
3f63 3a 6d 3f			ld a, (.dmark+2)  
3f66 32 b6 fe			ld (debug_mark+2),a  
3f69 18 03			jr .pastdmark  
3f6b ..			.dmark: db "D-1"  
3f6e f1			.pastdmark: pop af  
3f6f			endm  
# End of macro DMARK
3f6f				CALLMONITOR 
3f6f cd c6 18			call break_point_state  
3f72				endm  
# End of macro CALLMONITOR
3f72			endif	 
3f72			 
3f72			.nodashswap: 
3f72			 
3f72			if DEBUG_FORTH_DOT 
3f72				DMARK "D-o" 
3f72 f5				push af  
3f73 3a 87 3f			ld a, (.dmark)  
3f76 32 b4 fe			ld (debug_mark),a  
3f79 3a 88 3f			ld a, (.dmark+1)  
3f7c 32 b5 fe			ld (debug_mark+1),a  
3f7f 3a 89 3f			ld a, (.dmark+2)  
3f82 32 b6 fe			ld (debug_mark+2),a  
3f85 18 03			jr .pastdmark  
3f87 ..			.dmark: db "D-o"  
3f8a f1			.pastdmark: pop af  
3f8b			endm  
# End of macro DMARK
3f8b				CALLMONITOR 
3f8b cd c6 18			call break_point_state  
3f8e				endm  
# End of macro CALLMONITOR
3f8e			endif	 
3f8e			 
3f8e d5					push de   ; save string start in case we need to advance print 
3f8f			 
3f8f 3a eb fb				ld a, (f_cursor_ptr) 
3f92 cd 28 0d				call str_at_display 
3f95 3a c9 fb				ld a,(cli_autodisplay) 
3f98 fe 00				cp 0 
3f9a 28 03				jr z, .noupdate 
3f9c cd 38 0d						call update_display 
3f9f					.noupdate: 
3f9f			 
3f9f			 
3f9f					; see if we need to advance the print position 
3f9f			 
3f9f e1					pop hl   ; get back string 
3fa0			;		ex de,hl 
3fa0			 
3fa0 3a ca fb				ld a, (cli_mvdot) 
3fa3			if DEBUG_FORTH_DOT 
3fa3			;		ld e,a 
3fa3				DMARK "D>1" 
3fa3 f5				push af  
3fa4 3a b8 3f			ld a, (.dmark)  
3fa7 32 b4 fe			ld (debug_mark),a  
3faa 3a b9 3f			ld a, (.dmark+1)  
3fad 32 b5 fe			ld (debug_mark+1),a  
3fb0 3a ba 3f			ld a, (.dmark+2)  
3fb3 32 b6 fe			ld (debug_mark+2),a  
3fb6 18 03			jr .pastdmark  
3fb8 ..			.dmark: db "D>1"  
3fbb f1			.pastdmark: pop af  
3fbc			endm  
# End of macro DMARK
3fbc				CALLMONITOR 
3fbc cd c6 18			call break_point_state  
3fbf				endm  
# End of macro CALLMONITOR
3fbf			endif	 
3fbf fe 00				cp 0 
3fc1 28 44				jr z, .noadv 
3fc3					; yes, lets advance the print position 
3fc3 3e 00				ld a, 0 
3fc5 cd b2 13				call strlent 
3fc8			if DEBUG_FORTH_DOT 
3fc8				DMARK "D-?" 
3fc8 f5				push af  
3fc9 3a dd 3f			ld a, (.dmark)  
3fcc 32 b4 fe			ld (debug_mark),a  
3fcf 3a de 3f			ld a, (.dmark+1)  
3fd2 32 b5 fe			ld (debug_mark+1),a  
3fd5 3a df 3f			ld a, (.dmark+2)  
3fd8 32 b6 fe			ld (debug_mark+2),a  
3fdb 18 03			jr .pastdmark  
3fdd ..			.dmark: db "D-?"  
3fe0 f1			.pastdmark: pop af  
3fe1			endm  
# End of macro DMARK
3fe1				CALLMONITOR 
3fe1 cd c6 18			call break_point_state  
3fe4				endm  
# End of macro CALLMONITOR
3fe4			endif	 
3fe4 3a eb fb				ld a, (f_cursor_ptr) 
3fe7 85					add a,l 
3fe8					;call addatohl 
3fe8					;ld a, l 
3fe8 32 eb fb				ld (f_cursor_ptr), a   ; save new pos 
3feb			 
3feb			if DEBUG_FORTH_DOT 
3feb				DMARK "D->" 
3feb f5				push af  
3fec 3a 00 40			ld a, (.dmark)  
3fef 32 b4 fe			ld (debug_mark),a  
3ff2 3a 01 40			ld a, (.dmark+1)  
3ff5 32 b5 fe			ld (debug_mark+1),a  
3ff8 3a 02 40			ld a, (.dmark+2)  
3ffb 32 b6 fe			ld (debug_mark+2),a  
3ffe 18 03			jr .pastdmark  
4000 ..			.dmark: db "D->"  
4003 f1			.pastdmark: pop af  
4004			endm  
# End of macro DMARK
4004				CALLMONITOR 
4004 cd c6 18			call break_point_state  
4007				endm  
# End of macro CALLMONITOR
4007			endif	 
4007			 
4007			.noadv:	 
4007			 
4007					if DEBUG_FORTH_DOT_WAIT 
4007							call next_page_prompt 
4007					endif	 
4007			; TODO this pop off the stack causes a crash. i dont know why 
4007			 
4007			 
4007			if DEBUG_FORTH_DOT 
4007				DMARK "DTh" 
4007 f5				push af  
4008 3a 1c 40			ld a, (.dmark)  
400b 32 b4 fe			ld (debug_mark),a  
400e 3a 1d 40			ld a, (.dmark+1)  
4011 32 b5 fe			ld (debug_mark+1),a  
4014 3a 1e 40			ld a, (.dmark+2)  
4017 32 b6 fe			ld (debug_mark+2),a  
401a 18 03			jr .pastdmark  
401c ..			.dmark: db "DTh"  
401f f1			.pastdmark: pop af  
4020			endm  
# End of macro DMARK
4020				CALLMONITOR 
4020 cd c6 18			call break_point_state  
4023				endm  
# End of macro CALLMONITOR
4023			endif	 
4023			 
4023					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4023 cd e9 21			call macro_forth_dsp_pop 
4026				endm 
# End of macro FORTH_DSP_POP
4026			 
4026			if DEBUG_FORTH_DOT 
4026				DMARK "DTi" 
4026 f5				push af  
4027 3a 3b 40			ld a, (.dmark)  
402a 32 b4 fe			ld (debug_mark),a  
402d 3a 3c 40			ld a, (.dmark+1)  
4030 32 b5 fe			ld (debug_mark+1),a  
4033 3a 3d 40			ld a, (.dmark+2)  
4036 32 b6 fe			ld (debug_mark+2),a  
4039 18 03			jr .pastdmark  
403b ..			.dmark: db "DTi"  
403e f1			.pastdmark: pop af  
403f			endm  
# End of macro DMARK
403f				CALLMONITOR 
403f cd c6 18			call break_point_state  
4042				endm  
# End of macro CALLMONITOR
4042			endif	 
4042			 
4042			 
4042					NEXTW 
4042 c3 e0 22			jp macro_next 
4045				endm 
# End of macro NEXTW
4045			 
4045			.CLS: 
4045				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4045 35				db WORD_SYS_CORE+33             
4046 72 40			dw .DRAW            
4048 04				db 3 + 1 
4049 .. 00			db "CLS",0              
404d				endm 
# End of macro CWHEAD
404d			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
404d					if DEBUG_FORTH_WORDS_KEY 
404d						DMARK "CLS" 
404d f5				push af  
404e 3a 62 40			ld a, (.dmark)  
4051 32 b4 fe			ld (debug_mark),a  
4054 3a 63 40			ld a, (.dmark+1)  
4057 32 b5 fe			ld (debug_mark+1),a  
405a 3a 64 40			ld a, (.dmark+2)  
405d 32 b6 fe			ld (debug_mark+2),a  
4060 18 03			jr .pastdmark  
4062 ..			.dmark: db "CLS"  
4065 f1			.pastdmark: pop af  
4066			endm  
# End of macro DMARK
4066						CALLMONITOR 
4066 cd c6 18			call break_point_state  
4069				endm  
# End of macro CALLMONITOR
4069					endif 
4069 cd 15 0d				call clear_display 
406c c3 80 41				jp .home		; and home cursor 
406f					NEXTW 
406f c3 e0 22			jp macro_next 
4072				endm 
# End of macro NEXTW
4072			 
4072			.DRAW: 
4072				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
4072 36				db WORD_SYS_CORE+34             
4073 9d 40			dw .DUMP            
4075 05				db 4 + 1 
4076 .. 00			db "DRAW",0              
407b				endm 
# End of macro CWHEAD
407b			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
407b					if DEBUG_FORTH_WORDS_KEY 
407b						DMARK "DRW" 
407b f5				push af  
407c 3a 90 40			ld a, (.dmark)  
407f 32 b4 fe			ld (debug_mark),a  
4082 3a 91 40			ld a, (.dmark+1)  
4085 32 b5 fe			ld (debug_mark+1),a  
4088 3a 92 40			ld a, (.dmark+2)  
408b 32 b6 fe			ld (debug_mark+2),a  
408e 18 03			jr .pastdmark  
4090 ..			.dmark: db "DRW"  
4093 f1			.pastdmark: pop af  
4094			endm  
# End of macro DMARK
4094						CALLMONITOR 
4094 cd c6 18			call break_point_state  
4097				endm  
# End of macro CALLMONITOR
4097					endif 
4097 cd 38 0d				call update_display 
409a					NEXTW 
409a c3 e0 22			jp macro_next 
409d				endm 
# End of macro NEXTW
409d			 
409d			.DUMP: 
409d				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
409d 37				db WORD_SYS_CORE+35             
409e d5 40			dw .CDUMP            
40a0 05				db 4 + 1 
40a1 .. 00			db "DUMP",0              
40a6				endm 
# End of macro CWHEAD
40a6			; | DUMP ( x -- ) With address x display dump   | DONE 
40a6			; TODO pop address to use off of the stack 
40a6					if DEBUG_FORTH_WORDS_KEY 
40a6						DMARK "DUM" 
40a6 f5				push af  
40a7 3a bb 40			ld a, (.dmark)  
40aa 32 b4 fe			ld (debug_mark),a  
40ad 3a bc 40			ld a, (.dmark+1)  
40b0 32 b5 fe			ld (debug_mark+1),a  
40b3 3a bd 40			ld a, (.dmark+2)  
40b6 32 b6 fe			ld (debug_mark+2),a  
40b9 18 03			jr .pastdmark  
40bb ..			.dmark: db "DUM"  
40be f1			.pastdmark: pop af  
40bf			endm  
# End of macro DMARK
40bf						CALLMONITOR 
40bf cd c6 18			call break_point_state  
40c2				endm  
# End of macro CALLMONITOR
40c2					endif 
40c2 cd 15 0d				call clear_display 
40c5			 
40c5					; get address 
40c5			 
40c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40c5 cd 31 21			call macro_dsp_valuehl 
40c8				endm 
# End of macro FORTH_DSP_VALUEHL
40c8				 
40c8					; save it for cdump 
40c8			 
40c8 22 71 f6				ld (os_cur_ptr),hl 
40cb			 
40cb					; destroy value TOS 
40cb			 
40cb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40cb cd e9 21			call macro_forth_dsp_pop 
40ce				endm 
# End of macro FORTH_DSP_POP
40ce			 
40ce cd ba 1d				call dumpcont	; skip old style of param parsing	 
40d1 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
40d2					NEXTW 
40d2 c3 e0 22			jp macro_next 
40d5				endm 
# End of macro NEXTW
40d5			.CDUMP: 
40d5				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
40d5 38				db WORD_SYS_CORE+36             
40d6 05 41			dw .DAT            
40d8 06				db 5 + 1 
40d9 .. 00			db "CDUMP",0              
40df				endm 
# End of macro CWHEAD
40df			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
40df					if DEBUG_FORTH_WORDS_KEY 
40df						DMARK "CDP" 
40df f5				push af  
40e0 3a f4 40			ld a, (.dmark)  
40e3 32 b4 fe			ld (debug_mark),a  
40e6 3a f5 40			ld a, (.dmark+1)  
40e9 32 b5 fe			ld (debug_mark+1),a  
40ec 3a f6 40			ld a, (.dmark+2)  
40ef 32 b6 fe			ld (debug_mark+2),a  
40f2 18 03			jr .pastdmark  
40f4 ..			.dmark: db "CDP"  
40f7 f1			.pastdmark: pop af  
40f8			endm  
# End of macro DMARK
40f8						CALLMONITOR 
40f8 cd c6 18			call break_point_state  
40fb				endm  
# End of macro CALLMONITOR
40fb					endif 
40fb cd 15 0d				call clear_display 
40fe cd ba 1d				call dumpcont	 
4101 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4102					NEXTW 
4102 c3 e0 22			jp macro_next 
4105				endm 
# End of macro NEXTW
4105			 
4105			 
4105			 
4105			 
4105			.DAT: 
4105				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
4105 3d				db WORD_SYS_CORE+41             
4106 5b 41			dw .HOME            
4108 03				db 2 + 1 
4109 .. 00			db "AT",0              
410c				endm 
# End of macro CWHEAD
410c			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
410c					if DEBUG_FORTH_WORDS_KEY 
410c						DMARK "AT." 
410c f5				push af  
410d 3a 21 41			ld a, (.dmark)  
4110 32 b4 fe			ld (debug_mark),a  
4113 3a 22 41			ld a, (.dmark+1)  
4116 32 b5 fe			ld (debug_mark+1),a  
4119 3a 23 41			ld a, (.dmark+2)  
411c 32 b6 fe			ld (debug_mark+2),a  
411f 18 03			jr .pastdmark  
4121 ..			.dmark: db "AT."  
4124 f1			.pastdmark: pop af  
4125			endm  
# End of macro DMARK
4125						CALLMONITOR 
4125 cd c6 18			call break_point_state  
4128				endm  
# End of macro CALLMONITOR
4128					endif 
4128					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4128 cd 31 21			call macro_dsp_valuehl 
412b				endm 
# End of macro FORTH_DSP_VALUEHL
412b			 
412b			 
412b					; TODO save cursor row 
412b 7d					ld a,l 
412c fe 02				cp 2 
412e 20 04				jr nz, .crow3 
4130 3e 14				ld a, display_row_2 
4132 18 12				jr .ccol1 
4134 fe 03		.crow3:		cp 3 
4136 20 04				jr nz, .crow4 
4138 3e 28				ld a, display_row_3 
413a 18 0a				jr .ccol1 
413c fe 04		.crow4:		cp 4 
413e 20 04				jr nz, .crow1 
4140 3e 3c				ld a, display_row_4 
4142 18 02				jr .ccol1 
4144 3e 00		.crow1:		ld a,display_row_1 
4146 f5			.ccol1:		push af			; got row offset 
4147 6f					ld l,a 
4148 26 00				ld h,0 
414a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
414a cd e9 21			call macro_forth_dsp_pop 
414d				endm 
# End of macro FORTH_DSP_POP
414d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
414d cd 31 21			call macro_dsp_valuehl 
4150				endm 
# End of macro FORTH_DSP_VALUEHL
4150					; TODO save cursor col 
4150 f1					pop af 
4151 85					add l		; add col offset 
4152 32 eb fb				ld (f_cursor_ptr), a 
4155					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4155 cd e9 21			call macro_forth_dsp_pop 
4158				endm 
# End of macro FORTH_DSP_POP
4158			 
4158					; calculate  
4158			 
4158					NEXTW 
4158 c3 e0 22			jp macro_next 
415b				endm 
# End of macro NEXTW
415b			 
415b			 
415b			.HOME: 
415b				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
415b 41				db WORD_SYS_CORE+45             
415c 88 41			dw .SPACE            
415e 05				db 4 + 1 
415f .. 00			db "HOME",0              
4164				endm 
# End of macro CWHEAD
4164			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4164					if DEBUG_FORTH_WORDS_KEY 
4164						DMARK "HOM" 
4164 f5				push af  
4165 3a 79 41			ld a, (.dmark)  
4168 32 b4 fe			ld (debug_mark),a  
416b 3a 7a 41			ld a, (.dmark+1)  
416e 32 b5 fe			ld (debug_mark+1),a  
4171 3a 7b 41			ld a, (.dmark+2)  
4174 32 b6 fe			ld (debug_mark+2),a  
4177 18 03			jr .pastdmark  
4179 ..			.dmark: db "HOM"  
417c f1			.pastdmark: pop af  
417d			endm  
# End of macro DMARK
417d						CALLMONITOR 
417d cd c6 18			call break_point_state  
4180				endm  
# End of macro CALLMONITOR
4180					endif 
4180 3e 00		.home:		ld a, 0		; and home cursor 
4182 32 eb fb				ld (f_cursor_ptr), a 
4185					NEXTW 
4185 c3 e0 22			jp macro_next 
4188				endm 
# End of macro NEXTW
4188			 
4188			 
4188			.SPACE: 
4188				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
4188 46				db WORD_SYS_CORE+50             
4189 b6 41			dw .SPACES            
418b 03				db 2 + 1 
418c .. 00			db "BL",0              
418f				endm 
# End of macro CWHEAD
418f			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
418f					if DEBUG_FORTH_WORDS_KEY 
418f						DMARK "BL." 
418f f5				push af  
4190 3a a4 41			ld a, (.dmark)  
4193 32 b4 fe			ld (debug_mark),a  
4196 3a a5 41			ld a, (.dmark+1)  
4199 32 b5 fe			ld (debug_mark+1),a  
419c 3a a6 41			ld a, (.dmark+2)  
419f 32 b6 fe			ld (debug_mark+2),a  
41a2 18 03			jr .pastdmark  
41a4 ..			.dmark: db "BL."  
41a7 f1			.pastdmark: pop af  
41a8			endm  
# End of macro DMARK
41a8						CALLMONITOR 
41a8 cd c6 18			call break_point_state  
41ab				endm  
# End of macro CALLMONITOR
41ab					endif 
41ab 21 b4 41				ld hl, .blstr 
41ae cd a8 1f				call forth_push_str 
41b1					 
41b1				       NEXTW 
41b1 c3 e0 22			jp macro_next 
41b4				endm 
# End of macro NEXTW
41b4			 
41b4 .. 00		.blstr: db " ", 0 
41b6			 
41b6			.SPACES: 
41b6				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
41b6 47				db WORD_SYS_CORE+51             
41b7 51 42			dw .SCROLL            
41b9 07				db 6 + 1 
41ba .. 00			db "SPACES",0              
41c1				endm 
# End of macro CWHEAD
41c1			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
41c1					if DEBUG_FORTH_WORDS_KEY 
41c1						DMARK "SPS" 
41c1 f5				push af  
41c2 3a d6 41			ld a, (.dmark)  
41c5 32 b4 fe			ld (debug_mark),a  
41c8 3a d7 41			ld a, (.dmark+1)  
41cb 32 b5 fe			ld (debug_mark+1),a  
41ce 3a d8 41			ld a, (.dmark+2)  
41d1 32 b6 fe			ld (debug_mark+2),a  
41d4 18 03			jr .pastdmark  
41d6 ..			.dmark: db "SPS"  
41d9 f1			.pastdmark: pop af  
41da			endm  
# End of macro DMARK
41da						CALLMONITOR 
41da cd c6 18			call break_point_state  
41dd				endm  
# End of macro CALLMONITOR
41dd					endif 
41dd			 
41dd			 
41dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
41dd cd 31 21			call macro_dsp_valuehl 
41e0				endm 
# End of macro FORTH_DSP_VALUEHL
41e0			 
41e0			;		push hl    ; u 
41e0					if DEBUG_FORTH_WORDS 
41e0						DMARK "SPA" 
41e0 f5				push af  
41e1 3a f5 41			ld a, (.dmark)  
41e4 32 b4 fe			ld (debug_mark),a  
41e7 3a f6 41			ld a, (.dmark+1)  
41ea 32 b5 fe			ld (debug_mark+1),a  
41ed 3a f7 41			ld a, (.dmark+2)  
41f0 32 b6 fe			ld (debug_mark+2),a  
41f3 18 03			jr .pastdmark  
41f5 ..			.dmark: db "SPA"  
41f8 f1			.pastdmark: pop af  
41f9			endm  
# End of macro DMARK
41f9						CALLMONITOR 
41f9 cd c6 18			call break_point_state  
41fc				endm  
# End of macro CALLMONITOR
41fc					endif 
41fc			 
41fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
41fc cd e9 21			call macro_forth_dsp_pop 
41ff				endm 
# End of macro FORTH_DSP_POP
41ff			;		pop hl 
41ff 4d					ld c, l 
4200 06 00				ld b, 0 
4202 21 4e f3				ld hl, scratch  
4205			 
4205					if DEBUG_FORTH_WORDS 
4205						DMARK "SP2" 
4205 f5				push af  
4206 3a 1a 42			ld a, (.dmark)  
4209 32 b4 fe			ld (debug_mark),a  
420c 3a 1b 42			ld a, (.dmark+1)  
420f 32 b5 fe			ld (debug_mark+1),a  
4212 3a 1c 42			ld a, (.dmark+2)  
4215 32 b6 fe			ld (debug_mark+2),a  
4218 18 03			jr .pastdmark  
421a ..			.dmark: db "SP2"  
421d f1			.pastdmark: pop af  
421e			endm  
# End of macro DMARK
421e						CALLMONITOR 
421e cd c6 18			call break_point_state  
4221				endm  
# End of macro CALLMONITOR
4221					endif 
4221 3e 20				ld a, ' ' 
4223 c5			.spaces1:	push bc 
4224 77					ld (hl),a 
4225 23					inc hl 
4226 c1					pop bc 
4227 10 fa				djnz .spaces1 
4229 3e 00				ld a,0 
422b 77					ld (hl),a 
422c 21 4e f3				ld hl, scratch 
422f					if DEBUG_FORTH_WORDS 
422f						DMARK "SP3" 
422f f5				push af  
4230 3a 44 42			ld a, (.dmark)  
4233 32 b4 fe			ld (debug_mark),a  
4236 3a 45 42			ld a, (.dmark+1)  
4239 32 b5 fe			ld (debug_mark+1),a  
423c 3a 46 42			ld a, (.dmark+2)  
423f 32 b6 fe			ld (debug_mark+2),a  
4242 18 03			jr .pastdmark  
4244 ..			.dmark: db "SP3"  
4247 f1			.pastdmark: pop af  
4248			endm  
# End of macro DMARK
4248						CALLMONITOR 
4248 cd c6 18			call break_point_state  
424b				endm  
# End of macro CALLMONITOR
424b					endif 
424b cd a3 20				call forth_apush 
424e			 
424e				       NEXTW 
424e c3 e0 22			jp macro_next 
4251				endm 
# End of macro NEXTW
4251			 
4251			 
4251			 
4251			.SCROLL: 
4251				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4251 53				db WORD_SYS_CORE+63             
4252 7e 42			dw .SCROLLD            
4254 07				db 6 + 1 
4255 .. 00			db "SCROLL",0              
425c				endm 
# End of macro CWHEAD
425c			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
425c					if DEBUG_FORTH_WORDS_KEY 
425c						DMARK "SCR" 
425c f5				push af  
425d 3a 71 42			ld a, (.dmark)  
4260 32 b4 fe			ld (debug_mark),a  
4263 3a 72 42			ld a, (.dmark+1)  
4266 32 b5 fe			ld (debug_mark+1),a  
4269 3a 73 42			ld a, (.dmark+2)  
426c 32 b6 fe			ld (debug_mark+2),a  
426f 18 03			jr .pastdmark  
4271 ..			.dmark: db "SCR"  
4274 f1			.pastdmark: pop af  
4275			endm  
# End of macro DMARK
4275						CALLMONITOR 
4275 cd c6 18			call break_point_state  
4278				endm  
# End of macro CALLMONITOR
4278					endif 
4278			 
4278 cd d7 0c			call scroll_up 
427b			;	call update_display 
427b			 
427b					NEXTW 
427b c3 e0 22			jp macro_next 
427e				endm 
# End of macro NEXTW
427e			 
427e			 
427e			 
427e			;		; get dir 
427e			; 
427e			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
427e			; 
427e			;		push hl 
427e			; 
427e			;		; destroy value TOS 
427e			; 
427e			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
427e			; 
427e			;		; get count 
427e			; 
427e			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
427e			; 
427e			;		push hl 
427e			; 
427e			;		; destroy value TOS 
427e			; 
427e			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
427e			; 
427e			;		; one value on hl get other one back 
427e			; 
427e			;		pop bc    ; count 
427e			; 
427e			;		pop de   ; dir 
427e			; 
427e			; 
427e			;		ld b, c 
427e			; 
427e			;.scrolldir:     push bc 
427e			;		push de 
427e			; 
427e			;		ld a, 0 
427e			;		cp e 
427e			;		jr z, .scrollup  
427e			;		call scroll_down 
427e			;		jr .scrollnext 
427e			;.scrollup:	call scroll_up 
427e			; 
427e			;		 
427e			;.scrollnext: 
427e			;		pop de 
427e			;		pop bc 
427e			;		djnz .scrolldir 
427e			; 
427e			; 
427e			; 
427e			; 
427e			; 
427e			;		NEXTW 
427e			 
427e			.SCROLLD: 
427e				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
427e 53				db WORD_SYS_CORE+63             
427f ac 42			dw .ATQ            
4281 08				db 7 + 1 
4282 .. 00			db "SCROLLD",0              
428a				endm 
# End of macro CWHEAD
428a			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
428a					if DEBUG_FORTH_WORDS_KEY 
428a						DMARK "SCD" 
428a f5				push af  
428b 3a 9f 42			ld a, (.dmark)  
428e 32 b4 fe			ld (debug_mark),a  
4291 3a a0 42			ld a, (.dmark+1)  
4294 32 b5 fe			ld (debug_mark+1),a  
4297 3a a1 42			ld a, (.dmark+2)  
429a 32 b6 fe			ld (debug_mark+2),a  
429d 18 03			jr .pastdmark  
429f ..			.dmark: db "SCD"  
42a2 f1			.pastdmark: pop af  
42a3			endm  
# End of macro DMARK
42a3						CALLMONITOR 
42a3 cd c6 18			call break_point_state  
42a6				endm  
# End of macro CALLMONITOR
42a6					endif 
42a6			 
42a6 cd fb 0c			call scroll_down 
42a9			;	call update_display 
42a9			 
42a9					NEXTW 
42a9 c3 e0 22			jp macro_next 
42ac				endm 
# End of macro NEXTW
42ac			 
42ac			 
42ac			.ATQ: 
42ac				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
42ac 62				db WORD_SYS_CORE+78             
42ad 0a 43			dw .AUTODSP            
42af 04				db 3 + 1 
42b0 .. 00			db "AT@",0              
42b4				endm 
# End of macro CWHEAD
42b4			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
42b4					if DEBUG_FORTH_WORDS_KEY 
42b4						DMARK "ATA" 
42b4 f5				push af  
42b5 3a c9 42			ld a, (.dmark)  
42b8 32 b4 fe			ld (debug_mark),a  
42bb 3a ca 42			ld a, (.dmark+1)  
42be 32 b5 fe			ld (debug_mark+1),a  
42c1 3a cb 42			ld a, (.dmark+2)  
42c4 32 b6 fe			ld (debug_mark+2),a  
42c7 18 03			jr .pastdmark  
42c9 ..			.dmark: db "ATA"  
42cc f1			.pastdmark: pop af  
42cd			endm  
# End of macro DMARK
42cd						CALLMONITOR 
42cd cd c6 18			call break_point_state  
42d0				endm  
# End of macro CALLMONITOR
42d0					endif 
42d0			 
42d0			 
42d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42d0 cd 31 21			call macro_dsp_valuehl 
42d3				endm 
# End of macro FORTH_DSP_VALUEHL
42d3			 
42d3					; TODO save cursor row 
42d3 7d					ld a,l 
42d4 fe 02				cp 2 
42d6 20 04				jr nz, .crow3aq 
42d8 3e 14				ld a, display_row_2 
42da 18 12				jr .ccol1aq 
42dc fe 03		.crow3aq:		cp 3 
42de 20 04				jr nz, .crow4aq 
42e0 3e 28				ld a, display_row_3 
42e2 18 0a				jr .ccol1aq 
42e4 fe 04		.crow4aq:		cp 4 
42e6 20 04				jr nz, .crow1aq 
42e8 3e 3c				ld a, display_row_4 
42ea 18 02				jr .ccol1aq 
42ec 3e 00		.crow1aq:		ld a,display_row_1 
42ee f5			.ccol1aq:		push af			; got row offset 
42ef 6f					ld l,a 
42f0 26 00				ld h,0 
42f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42f2 cd e9 21			call macro_forth_dsp_pop 
42f5				endm 
# End of macro FORTH_DSP_POP
42f5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42f5 cd 31 21			call macro_dsp_valuehl 
42f8				endm 
# End of macro FORTH_DSP_VALUEHL
42f8					; TODO save cursor col 
42f8 f1					pop af 
42f9 85					add l		; add col offset 
42fa			 
42fa					; add current frame buffer address 
42fa 2a 55 fd				ld hl, (display_fb_active) 
42fd cd 49 0f				call addatohl 
4300			 
4300			 
4300			 
4300			 
4300					; get char frame buffer location offset in hl 
4300			 
4300 7e					ld a,(hl) 
4301 26 00				ld h, 0 
4303 6f					ld l, a 
4304			 
4304 cd 3a 1f				call forth_push_numhl 
4307			 
4307			 
4307					NEXTW 
4307 c3 e0 22			jp macro_next 
430a				endm 
# End of macro NEXTW
430a			 
430a			.AUTODSP: 
430a				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
430a 63				db WORD_SYS_CORE+79             
430b 20 43			dw .MENU            
430d 05				db 4 + 1 
430e .. 00			db "ADSP",0              
4313				endm 
# End of macro CWHEAD
4313			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4313			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4313			 
4313					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4313 cd 31 21			call macro_dsp_valuehl 
4316				endm 
# End of macro FORTH_DSP_VALUEHL
4316			 
4316			;		push hl 
4316			 
4316					; destroy value TOS 
4316			 
4316					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4316 cd e9 21			call macro_forth_dsp_pop 
4319				endm 
# End of macro FORTH_DSP_POP
4319			 
4319			;		pop hl 
4319			 
4319 7d					ld a,l 
431a 32 c9 fb				ld (cli_autodisplay), a 
431d				       NEXTW 
431d c3 e0 22			jp macro_next 
4320				endm 
# End of macro NEXTW
4320			 
4320			.MENU: 
4320				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4320 70				db WORD_SYS_CORE+92             
4321 c9 43			dw .ENDDISPLAY            
4323 05				db 4 + 1 
4324 .. 00			db "MENU",0              
4329				endm 
# End of macro CWHEAD
4329			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
4329			 
4329			;		; get number of items on the stack 
4329			; 
4329				 
4329					FORTH_DSP_VALUEHL 
4329 cd 31 21			call macro_dsp_valuehl 
432c				endm 
# End of macro FORTH_DSP_VALUEHL
432c				 
432c					if DEBUG_FORTH_WORDS_KEY 
432c						DMARK "MNU" 
432c f5				push af  
432d 3a 41 43			ld a, (.dmark)  
4330 32 b4 fe			ld (debug_mark),a  
4333 3a 42 43			ld a, (.dmark+1)  
4336 32 b5 fe			ld (debug_mark+1),a  
4339 3a 43 43			ld a, (.dmark+2)  
433c 32 b6 fe			ld (debug_mark+2),a  
433f 18 03			jr .pastdmark  
4341 ..			.dmark: db "MNU"  
4344 f1			.pastdmark: pop af  
4345			endm  
# End of macro DMARK
4345						CALLMONITOR 
4345 cd c6 18			call break_point_state  
4348				endm  
# End of macro CALLMONITOR
4348					endif 
4348			 
4348 45					ld b, l	 
4349 05					dec b 
434a			 
434a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
434a cd e9 21			call macro_forth_dsp_pop 
434d				endm 
# End of macro FORTH_DSP_POP
434d			 
434d			 
434d					; go directly through the stack to pluck out the string pointers and build an array 
434d			 
434d			;		FORTH_DSP 
434d			 
434d					; hl contains top most stack item 
434d				 
434d 11 4e f3				ld de, scratch 
4350			 
4350			.mbuild: 
4350			 
4350					FORTH_DSP_VALUEHL 
4350 cd 31 21			call macro_dsp_valuehl 
4353				endm 
# End of macro FORTH_DSP_VALUEHL
4353			 
4353					if DEBUG_FORTH_WORDS 
4353						DMARK "MN3" 
4353 f5				push af  
4354 3a 68 43			ld a, (.dmark)  
4357 32 b4 fe			ld (debug_mark),a  
435a 3a 69 43			ld a, (.dmark+1)  
435d 32 b5 fe			ld (debug_mark+1),a  
4360 3a 6a 43			ld a, (.dmark+2)  
4363 32 b6 fe			ld (debug_mark+2),a  
4366 18 03			jr .pastdmark  
4368 ..			.dmark: db "MN3"  
436b f1			.pastdmark: pop af  
436c			endm  
# End of macro DMARK
436c						CALLMONITOR 
436c cd c6 18			call break_point_state  
436f				endm  
# End of macro CALLMONITOR
436f					endif 
436f eb					ex de, hl 
4370 73					ld (hl), e 
4371 23					inc hl 
4372 72					ld (hl), d 
4373 23					inc hl 
4374 eb					ex de, hl 
4375			 
4375					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4375 cd e9 21			call macro_forth_dsp_pop 
4378				endm 
# End of macro FORTH_DSP_POP
4378			 
4378 10 d6				djnz .mbuild 
437a			 
437a					; done add term 
437a			 
437a eb					ex de, hl 
437b 36 00				ld (hl), 0 
437d 23					inc hl 
437e 36 00				ld (hl), 0 
4380			 
4380				 
4380					 
4380 21 4e f3				ld hl, scratch 
4383			 
4383					if DEBUG_FORTH_WORDS 
4383						DMARK "MNx" 
4383 f5				push af  
4384 3a 98 43			ld a, (.dmark)  
4387 32 b4 fe			ld (debug_mark),a  
438a 3a 99 43			ld a, (.dmark+1)  
438d 32 b5 fe			ld (debug_mark+1),a  
4390 3a 9a 43			ld a, (.dmark+2)  
4393 32 b6 fe			ld (debug_mark+2),a  
4396 18 03			jr .pastdmark  
4398 ..			.dmark: db "MNx"  
439b f1			.pastdmark: pop af  
439c			endm  
# End of macro DMARK
439c						CALLMONITOR 
439c cd c6 18			call break_point_state  
439f				endm  
# End of macro CALLMONITOR
439f					endif 
439f			 
439f			 
439f			 
439f 3e 00				ld a, 0 
43a1 cd 46 0d				call menu 
43a4			 
43a4			 
43a4 6f					ld l, a 
43a5 26 00				ld h, 0 
43a7			 
43a7					if DEBUG_FORTH_WORDS 
43a7						DMARK "MNr" 
43a7 f5				push af  
43a8 3a bc 43			ld a, (.dmark)  
43ab 32 b4 fe			ld (debug_mark),a  
43ae 3a bd 43			ld a, (.dmark+1)  
43b1 32 b5 fe			ld (debug_mark+1),a  
43b4 3a be 43			ld a, (.dmark+2)  
43b7 32 b6 fe			ld (debug_mark+2),a  
43ba 18 03			jr .pastdmark  
43bc ..			.dmark: db "MNr"  
43bf f1			.pastdmark: pop af  
43c0			endm  
# End of macro DMARK
43c0						CALLMONITOR 
43c0 cd c6 18			call break_point_state  
43c3				endm  
# End of macro CALLMONITOR
43c3					endif 
43c3			 
43c3 cd 3a 1f				call forth_push_numhl 
43c6			 
43c6			 
43c6			 
43c6			 
43c6				       NEXTW 
43c6 c3 e0 22			jp macro_next 
43c9				endm 
# End of macro NEXTW
43c9			 
43c9			 
43c9			.ENDDISPLAY: 
43c9			 
43c9			; eof 
# End of file forth_words_display.asm
43c9			include "forth_words_str.asm" 
43c9			 
43c9			; | ## String Words 
43c9			 
43c9			.PTR:   
43c9			 
43c9				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
43c9 48				db WORD_SYS_CORE+52             
43ca f6 43			dw .STYPE            
43cc 04				db 3 + 1 
43cd .. 00			db "PTR",0              
43d1				endm 
# End of macro CWHEAD
43d1			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
43d1			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
43d1			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
43d1			 
43d1					if DEBUG_FORTH_WORDS_KEY 
43d1						DMARK "PTR" 
43d1 f5				push af  
43d2 3a e6 43			ld a, (.dmark)  
43d5 32 b4 fe			ld (debug_mark),a  
43d8 3a e7 43			ld a, (.dmark+1)  
43db 32 b5 fe			ld (debug_mark+1),a  
43de 3a e8 43			ld a, (.dmark+2)  
43e1 32 b6 fe			ld (debug_mark+2),a  
43e4 18 03			jr .pastdmark  
43e6 ..			.dmark: db "PTR"  
43e9 f1			.pastdmark: pop af  
43ea			endm  
# End of macro DMARK
43ea						CALLMONITOR 
43ea cd c6 18			call break_point_state  
43ed				endm  
# End of macro CALLMONITOR
43ed					endif 
43ed					FORTH_DSP_VALUEHL 
43ed cd 31 21			call macro_dsp_valuehl 
43f0				endm 
# End of macro FORTH_DSP_VALUEHL
43f0 cd 3a 1f				call forth_push_numhl 
43f3			 
43f3			 
43f3					NEXTW 
43f3 c3 e0 22			jp macro_next 
43f6				endm 
# End of macro NEXTW
43f6			.STYPE: 
43f6				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
43f6 48				db WORD_SYS_CORE+52             
43f7 45 44			dw .UPPER            
43f9 06				db 5 + 1 
43fa .. 00			db "STYPE",0              
4400				endm 
# End of macro CWHEAD
4400			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4400					if DEBUG_FORTH_WORDS_KEY 
4400						DMARK "STY" 
4400 f5				push af  
4401 3a 15 44			ld a, (.dmark)  
4404 32 b4 fe			ld (debug_mark),a  
4407 3a 16 44			ld a, (.dmark+1)  
440a 32 b5 fe			ld (debug_mark+1),a  
440d 3a 17 44			ld a, (.dmark+2)  
4410 32 b6 fe			ld (debug_mark+2),a  
4413 18 03			jr .pastdmark  
4415 ..			.dmark: db "STY"  
4418 f1			.pastdmark: pop af  
4419			endm  
# End of macro DMARK
4419						CALLMONITOR 
4419 cd c6 18			call break_point_state  
441c				endm  
# End of macro CALLMONITOR
441c					endif 
441c					FORTH_DSP 
441c cd f7 20			call macro_forth_dsp 
441f				endm 
# End of macro FORTH_DSP
441f					;v5 FORTH_DSP_VALUE 
441f			 
441f 7e					ld a, (hl) 
4420			 
4420 f5					push af 
4421			 
4421			; Dont destroy TOS		FORTH_DSP_POP 
4421			 
4421 f1					pop af 
4422			 
4422 fe 01				cp DS_TYPE_STR 
4424 28 09				jr z, .typestr 
4426			 
4426 fe 02				cp DS_TYPE_INUM 
4428 28 0a				jr z, .typeinum 
442a			 
442a 21 43 44				ld hl, .tna 
442d 18 0a				jr .tpush 
442f			 
442f 21 3f 44		.typestr:	ld hl, .tstr 
4432 18 05				jr .tpush 
4434 21 41 44		.typeinum:	ld hl, .tinum 
4437 18 00				jr .tpush 
4439			 
4439			.tpush: 
4439			 
4439 cd a8 1f				call forth_push_str 
443c			 
443c					NEXTW 
443c c3 e0 22			jp macro_next 
443f				endm 
# End of macro NEXTW
443f .. 00		.tstr:	db "s",0 
4441 .. 00		.tinum:  db "i",0 
4443 .. 00		.tna:   db "?", 0 
4445			 
4445			 
4445			.UPPER: 
4445				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4445 48				db WORD_SYS_CORE+52             
4446 80 44			dw .LOWER            
4448 06				db 5 + 1 
4449 .. 00			db "UPPER",0              
444f				endm 
# End of macro CWHEAD
444f			; | UPPER ( s -- s ) Upper case string s  | DONE 
444f					if DEBUG_FORTH_WORDS_KEY 
444f						DMARK "UPR" 
444f f5				push af  
4450 3a 64 44			ld a, (.dmark)  
4453 32 b4 fe			ld (debug_mark),a  
4456 3a 65 44			ld a, (.dmark+1)  
4459 32 b5 fe			ld (debug_mark+1),a  
445c 3a 66 44			ld a, (.dmark+2)  
445f 32 b6 fe			ld (debug_mark+2),a  
4462 18 03			jr .pastdmark  
4464 ..			.dmark: db "UPR"  
4467 f1			.pastdmark: pop af  
4468			endm  
# End of macro DMARK
4468						CALLMONITOR 
4468 cd c6 18			call break_point_state  
446b				endm  
# End of macro CALLMONITOR
446b					endif 
446b			 
446b					FORTH_DSP 
446b cd f7 20			call macro_forth_dsp 
446e				endm 
# End of macro FORTH_DSP
446e					 
446e			; TODO check is string type 
446e			 
446e					FORTH_DSP_VALUEHL 
446e cd 31 21			call macro_dsp_valuehl 
4471				endm 
# End of macro FORTH_DSP_VALUEHL
4471			; get pointer to string in hl 
4471			 
4471 7e			.toup:		ld a, (hl) 
4472 fe 00				cp 0 
4474 28 07				jr z, .toupdone 
4476			 
4476 cd b6 12				call to_upper 
4479			 
4479 77					ld (hl), a 
447a 23					inc hl 
447b 18 f4				jr .toup 
447d			 
447d					 
447d			 
447d			 
447d			; for each char convert to upper 
447d					 
447d			.toupdone: 
447d			 
447d			 
447d					NEXTW 
447d c3 e0 22			jp macro_next 
4480				endm 
# End of macro NEXTW
4480			.LOWER: 
4480				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4480 48				db WORD_SYS_CORE+52             
4481 bb 44			dw .TCASE            
4483 06				db 5 + 1 
4484 .. 00			db "LOWER",0              
448a				endm 
# End of macro CWHEAD
448a			; | LOWER ( s -- s ) Lower case string s  | DONE 
448a					if DEBUG_FORTH_WORDS_KEY 
448a						DMARK "LWR" 
448a f5				push af  
448b 3a 9f 44			ld a, (.dmark)  
448e 32 b4 fe			ld (debug_mark),a  
4491 3a a0 44			ld a, (.dmark+1)  
4494 32 b5 fe			ld (debug_mark+1),a  
4497 3a a1 44			ld a, (.dmark+2)  
449a 32 b6 fe			ld (debug_mark+2),a  
449d 18 03			jr .pastdmark  
449f ..			.dmark: db "LWR"  
44a2 f1			.pastdmark: pop af  
44a3			endm  
# End of macro DMARK
44a3						CALLMONITOR 
44a3 cd c6 18			call break_point_state  
44a6				endm  
# End of macro CALLMONITOR
44a6					endif 
44a6			 
44a6					FORTH_DSP 
44a6 cd f7 20			call macro_forth_dsp 
44a9				endm 
# End of macro FORTH_DSP
44a9					 
44a9			; TODO check is string type 
44a9			 
44a9					FORTH_DSP_VALUEHL 
44a9 cd 31 21			call macro_dsp_valuehl 
44ac				endm 
# End of macro FORTH_DSP_VALUEHL
44ac			; get pointer to string in hl 
44ac			 
44ac 7e			.tolow:		ld a, (hl) 
44ad fe 00				cp 0 
44af 28 07				jr z, .tolowdone 
44b1			 
44b1 cd bf 12				call to_lower 
44b4			 
44b4 77					ld (hl), a 
44b5 23					inc hl 
44b6 18 f4				jr .tolow 
44b8			 
44b8					 
44b8			 
44b8			 
44b8			; for each char convert to low 
44b8					 
44b8			.tolowdone: 
44b8					NEXTW 
44b8 c3 e0 22			jp macro_next 
44bb				endm 
# End of macro NEXTW
44bb			.TCASE: 
44bb				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
44bb 48				db WORD_SYS_CORE+52             
44bc f1 45			dw .SUBSTR            
44be 06				db 5 + 1 
44bf .. 00			db "TCASE",0              
44c5				endm 
# End of macro CWHEAD
44c5			; | TCASE ( s -- s ) Title case string s  | DONE 
44c5					if DEBUG_FORTH_WORDS_KEY 
44c5						DMARK "TCS" 
44c5 f5				push af  
44c6 3a da 44			ld a, (.dmark)  
44c9 32 b4 fe			ld (debug_mark),a  
44cc 3a db 44			ld a, (.dmark+1)  
44cf 32 b5 fe			ld (debug_mark+1),a  
44d2 3a dc 44			ld a, (.dmark+2)  
44d5 32 b6 fe			ld (debug_mark+2),a  
44d8 18 03			jr .pastdmark  
44da ..			.dmark: db "TCS"  
44dd f1			.pastdmark: pop af  
44de			endm  
# End of macro DMARK
44de						CALLMONITOR 
44de cd c6 18			call break_point_state  
44e1				endm  
# End of macro CALLMONITOR
44e1					endif 
44e1			 
44e1					FORTH_DSP 
44e1 cd f7 20			call macro_forth_dsp 
44e4				endm 
# End of macro FORTH_DSP
44e4					 
44e4			; TODO check is string type 
44e4			 
44e4					FORTH_DSP_VALUEHL 
44e4 cd 31 21			call macro_dsp_valuehl 
44e7				endm 
# End of macro FORTH_DSP_VALUEHL
44e7			; get pointer to string in hl 
44e7			 
44e7					if DEBUG_FORTH_WORDS 
44e7						DMARK "TC1" 
44e7 f5				push af  
44e8 3a fc 44			ld a, (.dmark)  
44eb 32 b4 fe			ld (debug_mark),a  
44ee 3a fd 44			ld a, (.dmark+1)  
44f1 32 b5 fe			ld (debug_mark+1),a  
44f4 3a fe 44			ld a, (.dmark+2)  
44f7 32 b6 fe			ld (debug_mark+2),a  
44fa 18 03			jr .pastdmark  
44fc ..			.dmark: db "TC1"  
44ff f1			.pastdmark: pop af  
4500			endm  
# End of macro DMARK
4500						CALLMONITOR 
4500 cd c6 18			call break_point_state  
4503				endm  
# End of macro CALLMONITOR
4503					endif 
4503			 
4503					; first time in turn to upper case first char 
4503			 
4503 7e					ld a, (hl) 
4504 c3 8e 45				jp .totsiptou 
4507			 
4507			 
4507 7e			.tot:		ld a, (hl) 
4508 fe 00				cp 0 
450a ca d2 45				jp z, .totdone 
450d			 
450d					if DEBUG_FORTH_WORDS 
450d						DMARK "TC2" 
450d f5				push af  
450e 3a 22 45			ld a, (.dmark)  
4511 32 b4 fe			ld (debug_mark),a  
4514 3a 23 45			ld a, (.dmark+1)  
4517 32 b5 fe			ld (debug_mark+1),a  
451a 3a 24 45			ld a, (.dmark+2)  
451d 32 b6 fe			ld (debug_mark+2),a  
4520 18 03			jr .pastdmark  
4522 ..			.dmark: db "TC2"  
4525 f1			.pastdmark: pop af  
4526			endm  
# End of macro DMARK
4526						CALLMONITOR 
4526 cd c6 18			call break_point_state  
4529				endm  
# End of macro CALLMONITOR
4529					endif 
4529					; check to see if current char is a space 
4529			 
4529 fe 20				cp ' ' 
452b 28 21				jr z, .totsp 
452d cd bf 12				call to_lower 
4530					if DEBUG_FORTH_WORDS 
4530						DMARK "TC3" 
4530 f5				push af  
4531 3a 45 45			ld a, (.dmark)  
4534 32 b4 fe			ld (debug_mark),a  
4537 3a 46 45			ld a, (.dmark+1)  
453a 32 b5 fe			ld (debug_mark+1),a  
453d 3a 47 45			ld a, (.dmark+2)  
4540 32 b6 fe			ld (debug_mark+2),a  
4543 18 03			jr .pastdmark  
4545 ..			.dmark: db "TC3"  
4548 f1			.pastdmark: pop af  
4549			endm  
# End of macro DMARK
4549						CALLMONITOR 
4549 cd c6 18			call break_point_state  
454c				endm  
# End of macro CALLMONITOR
454c					endif 
454c 18 63				jr .totnxt 
454e			 
454e			.totsp:         ; on a space, find next char which should be upper 
454e			 
454e					if DEBUG_FORTH_WORDS 
454e						DMARK "TC4" 
454e f5				push af  
454f 3a 63 45			ld a, (.dmark)  
4552 32 b4 fe			ld (debug_mark),a  
4555 3a 64 45			ld a, (.dmark+1)  
4558 32 b5 fe			ld (debug_mark+1),a  
455b 3a 65 45			ld a, (.dmark+2)  
455e 32 b6 fe			ld (debug_mark+2),a  
4561 18 03			jr .pastdmark  
4563 ..			.dmark: db "TC4"  
4566 f1			.pastdmark: pop af  
4567			endm  
# End of macro DMARK
4567						CALLMONITOR 
4567 cd c6 18			call break_point_state  
456a				endm  
# End of macro CALLMONITOR
456a					endif 
456a					;; 
456a			 
456a fe 20				cp ' ' 
456c 20 20				jr nz, .totsiptou 
456e 23					inc hl 
456f 7e					ld a, (hl) 
4570					if DEBUG_FORTH_WORDS 
4570						DMARK "TC5" 
4570 f5				push af  
4571 3a 85 45			ld a, (.dmark)  
4574 32 b4 fe			ld (debug_mark),a  
4577 3a 86 45			ld a, (.dmark+1)  
457a 32 b5 fe			ld (debug_mark+1),a  
457d 3a 87 45			ld a, (.dmark+2)  
4580 32 b6 fe			ld (debug_mark+2),a  
4583 18 03			jr .pastdmark  
4585 ..			.dmark: db "TC5"  
4588 f1			.pastdmark: pop af  
4589			endm  
# End of macro DMARK
4589						CALLMONITOR 
4589 cd c6 18			call break_point_state  
458c				endm  
# End of macro CALLMONITOR
458c					endif 
458c 18 c0				jr .totsp 
458e fe 00		.totsiptou:    cp 0 
4590 28 40				jr z, .totdone 
4592					; not space and not zero term so upper case it 
4592 cd b6 12				call to_upper 
4595			 
4595					if DEBUG_FORTH_WORDS 
4595						DMARK "TC6" 
4595 f5				push af  
4596 3a aa 45			ld a, (.dmark)  
4599 32 b4 fe			ld (debug_mark),a  
459c 3a ab 45			ld a, (.dmark+1)  
459f 32 b5 fe			ld (debug_mark+1),a  
45a2 3a ac 45			ld a, (.dmark+2)  
45a5 32 b6 fe			ld (debug_mark+2),a  
45a8 18 03			jr .pastdmark  
45aa ..			.dmark: db "TC6"  
45ad f1			.pastdmark: pop af  
45ae			endm  
# End of macro DMARK
45ae						CALLMONITOR 
45ae cd c6 18			call break_point_state  
45b1				endm  
# End of macro CALLMONITOR
45b1					endif 
45b1			 
45b1			 
45b1			.totnxt: 
45b1			 
45b1 77					ld (hl), a 
45b2 23					inc hl 
45b3					if DEBUG_FORTH_WORDS 
45b3						DMARK "TC7" 
45b3 f5				push af  
45b4 3a c8 45			ld a, (.dmark)  
45b7 32 b4 fe			ld (debug_mark),a  
45ba 3a c9 45			ld a, (.dmark+1)  
45bd 32 b5 fe			ld (debug_mark+1),a  
45c0 3a ca 45			ld a, (.dmark+2)  
45c3 32 b6 fe			ld (debug_mark+2),a  
45c6 18 03			jr .pastdmark  
45c8 ..			.dmark: db "TC7"  
45cb f1			.pastdmark: pop af  
45cc			endm  
# End of macro DMARK
45cc						CALLMONITOR 
45cc cd c6 18			call break_point_state  
45cf				endm  
# End of macro CALLMONITOR
45cf					endif 
45cf c3 07 45				jp .tot 
45d2			 
45d2					 
45d2			 
45d2			 
45d2			; for each char convert to low 
45d2					 
45d2			.totdone: 
45d2					if DEBUG_FORTH_WORDS 
45d2						DMARK "TCd" 
45d2 f5				push af  
45d3 3a e7 45			ld a, (.dmark)  
45d6 32 b4 fe			ld (debug_mark),a  
45d9 3a e8 45			ld a, (.dmark+1)  
45dc 32 b5 fe			ld (debug_mark+1),a  
45df 3a e9 45			ld a, (.dmark+2)  
45e2 32 b6 fe			ld (debug_mark+2),a  
45e5 18 03			jr .pastdmark  
45e7 ..			.dmark: db "TCd"  
45ea f1			.pastdmark: pop af  
45eb			endm  
# End of macro DMARK
45eb						CALLMONITOR 
45eb cd c6 18			call break_point_state  
45ee				endm  
# End of macro CALLMONITOR
45ee					endif 
45ee					NEXTW 
45ee c3 e0 22			jp macro_next 
45f1				endm 
# End of macro NEXTW
45f1			 
45f1			.SUBSTR: 
45f1				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
45f1 48				db WORD_SYS_CORE+52             
45f2 4f 46			dw .LEFT            
45f4 07				db 6 + 1 
45f5 .. 00			db "SUBSTR",0              
45fc				endm 
# End of macro CWHEAD
45fc			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
45fc			 
45fc					if DEBUG_FORTH_WORDS_KEY 
45fc						DMARK "SST" 
45fc f5				push af  
45fd 3a 11 46			ld a, (.dmark)  
4600 32 b4 fe			ld (debug_mark),a  
4603 3a 12 46			ld a, (.dmark+1)  
4606 32 b5 fe			ld (debug_mark+1),a  
4609 3a 13 46			ld a, (.dmark+2)  
460c 32 b6 fe			ld (debug_mark+2),a  
460f 18 03			jr .pastdmark  
4611 ..			.dmark: db "SST"  
4614 f1			.pastdmark: pop af  
4615			endm  
# End of macro DMARK
4615						CALLMONITOR 
4615 cd c6 18			call break_point_state  
4618				endm  
# End of macro CALLMONITOR
4618					endif 
4618			; TODO check string type 
4618					FORTH_DSP_VALUEHL 
4618 cd 31 21			call macro_dsp_valuehl 
461b				endm 
# End of macro FORTH_DSP_VALUEHL
461b			 
461b e5					push hl      ; string length 
461c			 
461c					FORTH_DSP_POP 
461c cd e9 21			call macro_forth_dsp_pop 
461f				endm 
# End of macro FORTH_DSP_POP
461f			 
461f					FORTH_DSP_VALUEHL 
461f cd 31 21			call macro_dsp_valuehl 
4622				endm 
# End of macro FORTH_DSP_VALUEHL
4622			 
4622 e5					push hl     ; start char 
4623			 
4623					FORTH_DSP_POP 
4623 cd e9 21			call macro_forth_dsp_pop 
4626				endm 
# End of macro FORTH_DSP_POP
4626			 
4626			 
4626					FORTH_DSP_VALUE 
4626 cd 1a 21			call macro_forth_dsp_value 
4629				endm 
# End of macro FORTH_DSP_VALUE
4629			 
4629 d1					pop de    ; get start post offset 
462a			 
462a 19					add hl, de    ; starting offset 
462b			 
462b c1					pop bc 
462c c5					push bc      ; grab size of string 
462d			 
462d e5					push hl    ; save string start  
462e			 
462e 26 00				ld h, 0 
4630 69					ld l, c 
4631 23					inc hl 
4632 23					inc hl 
4633			 
4633 cd 10 14				call malloc 
4636				if DEBUG_FORTH_MALLOC_GUARD 
4636 cc c0 58				call z,malloc_error 
4639				endif 
4639			 
4639 eb					ex de, hl      ; save malloc area for string copy 
463a e1					pop hl    ; get back source 
463b c1					pop bc    ; get length of string back 
463c			 
463c d5					push de    ; save malloc area for after we push 
463d ed b0				ldir     ; copy substr 
463f			 
463f			 
463f eb					ex de, hl 
4640 3e 00				ld a, 0 
4642 77					ld (hl), a   ; term substr 
4643			 
4643					 
4643 e1					pop hl    ; get malloc so we can push it 
4644 e5					push hl   ; save so we can free it afterwards 
4645			 
4645 cd a8 1f				call forth_push_str 
4648			 
4648 e1					pop hl 
4649 cd da 14				call free 
464c			 
464c					 
464c					 
464c			 
464c			 
464c					NEXTW 
464c c3 e0 22			jp macro_next 
464f				endm 
# End of macro NEXTW
464f			 
464f			.LEFT: 
464f				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
464f 48				db WORD_SYS_CORE+52             
4650 77 46			dw .RIGHT            
4652 05				db 4 + 1 
4653 .. 00			db "LEFT",0              
4658				endm 
# End of macro CWHEAD
4658			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4658					if DEBUG_FORTH_WORDS_KEY 
4658						DMARK "LEF" 
4658 f5				push af  
4659 3a 6d 46			ld a, (.dmark)  
465c 32 b4 fe			ld (debug_mark),a  
465f 3a 6e 46			ld a, (.dmark+1)  
4662 32 b5 fe			ld (debug_mark+1),a  
4665 3a 6f 46			ld a, (.dmark+2)  
4668 32 b6 fe			ld (debug_mark+2),a  
466b 18 03			jr .pastdmark  
466d ..			.dmark: db "LEF"  
4670 f1			.pastdmark: pop af  
4671			endm  
# End of macro DMARK
4671						CALLMONITOR 
4671 cd c6 18			call break_point_state  
4674				endm  
# End of macro CALLMONITOR
4674					endif 
4674			 
4674					NEXTW 
4674 c3 e0 22			jp macro_next 
4677				endm 
# End of macro NEXTW
4677			.RIGHT: 
4677				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4677 48				db WORD_SYS_CORE+52             
4678 a0 46			dw .STR2NUM            
467a 06				db 5 + 1 
467b .. 00			db "RIGHT",0              
4681				endm 
# End of macro CWHEAD
4681			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4681					if DEBUG_FORTH_WORDS_KEY 
4681						DMARK "RIG" 
4681 f5				push af  
4682 3a 96 46			ld a, (.dmark)  
4685 32 b4 fe			ld (debug_mark),a  
4688 3a 97 46			ld a, (.dmark+1)  
468b 32 b5 fe			ld (debug_mark+1),a  
468e 3a 98 46			ld a, (.dmark+2)  
4691 32 b6 fe			ld (debug_mark+2),a  
4694 18 03			jr .pastdmark  
4696 ..			.dmark: db "RIG"  
4699 f1			.pastdmark: pop af  
469a			endm  
# End of macro DMARK
469a						CALLMONITOR 
469a cd c6 18			call break_point_state  
469d				endm  
# End of macro CALLMONITOR
469d					endif 
469d			 
469d					NEXTW 
469d c3 e0 22			jp macro_next 
46a0				endm 
# End of macro NEXTW
46a0			 
46a0			 
46a0			.STR2NUM: 
46a0				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
46a0 48				db WORD_SYS_CORE+52             
46a1 2c 47			dw .NUM2STR            
46a3 08				db 7 + 1 
46a4 .. 00			db "STR2NUM",0              
46ac				endm 
# End of macro CWHEAD
46ac			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
46ac			 
46ac			 
46ac			; TODO STR type check to do 
46ac					if DEBUG_FORTH_WORDS_KEY 
46ac						DMARK "S2N" 
46ac f5				push af  
46ad 3a c1 46			ld a, (.dmark)  
46b0 32 b4 fe			ld (debug_mark),a  
46b3 3a c2 46			ld a, (.dmark+1)  
46b6 32 b5 fe			ld (debug_mark+1),a  
46b9 3a c3 46			ld a, (.dmark+2)  
46bc 32 b6 fe			ld (debug_mark+2),a  
46bf 18 03			jr .pastdmark  
46c1 ..			.dmark: db "S2N"  
46c4 f1			.pastdmark: pop af  
46c5			endm  
# End of macro DMARK
46c5						CALLMONITOR 
46c5 cd c6 18			call break_point_state  
46c8				endm  
# End of macro CALLMONITOR
46c8					endif 
46c8			 
46c8					;FORTH_DSP 
46c8					FORTH_DSP_VALUE 
46c8 cd 1a 21			call macro_forth_dsp_value 
46cb				endm 
# End of macro FORTH_DSP_VALUE
46cb					;inc hl 
46cb			 
46cb eb					ex de, hl 
46cc					if DEBUG_FORTH_WORDS 
46cc						DMARK "S2a" 
46cc f5				push af  
46cd 3a e1 46			ld a, (.dmark)  
46d0 32 b4 fe			ld (debug_mark),a  
46d3 3a e2 46			ld a, (.dmark+1)  
46d6 32 b5 fe			ld (debug_mark+1),a  
46d9 3a e3 46			ld a, (.dmark+2)  
46dc 32 b6 fe			ld (debug_mark+2),a  
46df 18 03			jr .pastdmark  
46e1 ..			.dmark: db "S2a"  
46e4 f1			.pastdmark: pop af  
46e5			endm  
# End of macro DMARK
46e5						CALLMONITOR 
46e5 cd c6 18			call break_point_state  
46e8				endm  
# End of macro CALLMONITOR
46e8					endif 
46e8 cd 3e 13				call string_to_uint16 
46eb			 
46eb					if DEBUG_FORTH_WORDS 
46eb						DMARK "S2b" 
46eb f5				push af  
46ec 3a 00 47			ld a, (.dmark)  
46ef 32 b4 fe			ld (debug_mark),a  
46f2 3a 01 47			ld a, (.dmark+1)  
46f5 32 b5 fe			ld (debug_mark+1),a  
46f8 3a 02 47			ld a, (.dmark+2)  
46fb 32 b6 fe			ld (debug_mark+2),a  
46fe 18 03			jr .pastdmark  
4700 ..			.dmark: db "S2b"  
4703 f1			.pastdmark: pop af  
4704			endm  
# End of macro DMARK
4704						CALLMONITOR 
4704 cd c6 18			call break_point_state  
4707				endm  
# End of macro CALLMONITOR
4707					endif 
4707			;		push hl 
4707					FORTH_DSP_POP 
4707 cd e9 21			call macro_forth_dsp_pop 
470a				endm 
# End of macro FORTH_DSP_POP
470a			;		pop hl 
470a					 
470a					if DEBUG_FORTH_WORDS 
470a						DMARK "S2b" 
470a f5				push af  
470b 3a 1f 47			ld a, (.dmark)  
470e 32 b4 fe			ld (debug_mark),a  
4711 3a 20 47			ld a, (.dmark+1)  
4714 32 b5 fe			ld (debug_mark+1),a  
4717 3a 21 47			ld a, (.dmark+2)  
471a 32 b6 fe			ld (debug_mark+2),a  
471d 18 03			jr .pastdmark  
471f ..			.dmark: db "S2b"  
4722 f1			.pastdmark: pop af  
4723			endm  
# End of macro DMARK
4723						CALLMONITOR 
4723 cd c6 18			call break_point_state  
4726				endm  
# End of macro CALLMONITOR
4726					endif 
4726 cd 3a 1f				call forth_push_numhl	 
4729			 
4729				 
4729				       NEXTW 
4729 c3 e0 22			jp macro_next 
472c				endm 
# End of macro NEXTW
472c			.NUM2STR: 
472c				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
472c 48				db WORD_SYS_CORE+52             
472d 3b 47			dw .CONCAT            
472f 08				db 7 + 1 
4730 .. 00			db "NUM2STR",0              
4738				endm 
# End of macro CWHEAD
4738			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4738			 
4738			;		; malloc a string to target 
4738			;		ld hl, 10     ; TODO max string size should be fine 
4738			;		call malloc 
4738			;		push hl    ; save malloc location 
4738			; 
4738			; 
4738			;; TODO check int type 
4738			;		FORTH_DSP_VALUEHL 
4738			;		ld a, l 
4738			;		call DispAToASCII   
4738			;;TODO need to chage above call to dump into string 
4738			; 
4738			; 
4738			 
4738				       NEXTW 
4738 c3 e0 22			jp macro_next 
473b				endm 
# End of macro NEXTW
473b			 
473b			.CONCAT: 
473b				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
473b 48				db WORD_SYS_CORE+52             
473c ee 47			dw .FIND            
473e 07				db 6 + 1 
473f .. 00			db "CONCAT",0              
4746				endm 
# End of macro CWHEAD
4746			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4746			 
4746			; TODO check string type 
4746			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4746			 
4746					if DEBUG_FORTH_WORDS_KEY 
4746						DMARK "CON" 
4746 f5				push af  
4747 3a 5b 47			ld a, (.dmark)  
474a 32 b4 fe			ld (debug_mark),a  
474d 3a 5c 47			ld a, (.dmark+1)  
4750 32 b5 fe			ld (debug_mark+1),a  
4753 3a 5d 47			ld a, (.dmark+2)  
4756 32 b6 fe			ld (debug_mark+2),a  
4759 18 03			jr .pastdmark  
475b ..			.dmark: db "CON"  
475e f1			.pastdmark: pop af  
475f			endm  
# End of macro DMARK
475f						CALLMONITOR 
475f cd c6 18			call break_point_state  
4762				endm  
# End of macro CALLMONITOR
4762					endif 
4762			 
4762			 
4762					FORTH_DSP_VALUE 
4762 cd 1a 21			call macro_forth_dsp_value 
4765				endm 
# End of macro FORTH_DSP_VALUE
4765 e5					push hl   ; s2 
4766			 
4766					FORTH_DSP_POP 
4766 cd e9 21			call macro_forth_dsp_pop 
4769				endm 
# End of macro FORTH_DSP_POP
4769			 
4769					FORTH_DSP_VALUE 
4769 cd 1a 21			call macro_forth_dsp_value 
476c				endm 
# End of macro FORTH_DSP_VALUE
476c			 
476c e5					push hl   ; s1 
476d			 
476d					FORTH_DSP_POP 
476d cd e9 21			call macro_forth_dsp_pop 
4770				endm 
# End of macro FORTH_DSP_POP
4770					 
4770			 
4770					; copy s1 
4770			 
4770				 
4770					; save ptr 
4770 e1					pop hl  
4771 e5					push hl 
4772 3e 00				ld a, 0 
4774 cd b2 13				call strlent 
4777					;inc hl    ; zer0 
4777 06 00				ld b, 0 
4779 4d					ld c, l 
477a e1					pop hl		 
477b 11 4e f3				ld de, scratch	 
477e					if DEBUG_FORTH_WORDS 
477e						DMARK "CO1" 
477e f5				push af  
477f 3a 93 47			ld a, (.dmark)  
4782 32 b4 fe			ld (debug_mark),a  
4785 3a 94 47			ld a, (.dmark+1)  
4788 32 b5 fe			ld (debug_mark+1),a  
478b 3a 95 47			ld a, (.dmark+2)  
478e 32 b6 fe			ld (debug_mark+2),a  
4791 18 03			jr .pastdmark  
4793 ..			.dmark: db "CO1"  
4796 f1			.pastdmark: pop af  
4797			endm  
# End of macro DMARK
4797						CALLMONITOR 
4797 cd c6 18			call break_point_state  
479a				endm  
# End of macro CALLMONITOR
479a					endif 
479a ed b0				ldir 
479c			 
479c e1					pop hl 
479d e5					push hl 
479e d5					push de 
479f			 
479f			 
479f 3e 00				ld a, 0 
47a1 cd b2 13				call strlent 
47a4 23					inc hl    ; zer0 
47a5 23					inc hl 
47a6 06 00				ld b, 0 
47a8 4d					ld c, l 
47a9 d1					pop de 
47aa e1					pop hl		 
47ab					if DEBUG_FORTH_WORDS 
47ab						DMARK "CO2" 
47ab f5				push af  
47ac 3a c0 47			ld a, (.dmark)  
47af 32 b4 fe			ld (debug_mark),a  
47b2 3a c1 47			ld a, (.dmark+1)  
47b5 32 b5 fe			ld (debug_mark+1),a  
47b8 3a c2 47			ld a, (.dmark+2)  
47bb 32 b6 fe			ld (debug_mark+2),a  
47be 18 03			jr .pastdmark  
47c0 ..			.dmark: db "CO2"  
47c3 f1			.pastdmark: pop af  
47c4			endm  
# End of macro DMARK
47c4						CALLMONITOR 
47c4 cd c6 18			call break_point_state  
47c7				endm  
# End of macro CALLMONITOR
47c7					endif 
47c7 ed b0				ldir 
47c9			 
47c9			 
47c9			 
47c9 21 4e f3				ld hl, scratch 
47cc					if DEBUG_FORTH_WORDS 
47cc						DMARK "CO5" 
47cc f5				push af  
47cd 3a e1 47			ld a, (.dmark)  
47d0 32 b4 fe			ld (debug_mark),a  
47d3 3a e2 47			ld a, (.dmark+1)  
47d6 32 b5 fe			ld (debug_mark+1),a  
47d9 3a e3 47			ld a, (.dmark+2)  
47dc 32 b6 fe			ld (debug_mark+2),a  
47df 18 03			jr .pastdmark  
47e1 ..			.dmark: db "CO5"  
47e4 f1			.pastdmark: pop af  
47e5			endm  
# End of macro DMARK
47e5						CALLMONITOR 
47e5 cd c6 18			call break_point_state  
47e8				endm  
# End of macro CALLMONITOR
47e8					endif 
47e8			 
47e8 cd a8 1f				call forth_push_str 
47eb			 
47eb			 
47eb			 
47eb			 
47eb				       NEXTW 
47eb c3 e0 22			jp macro_next 
47ee				endm 
# End of macro NEXTW
47ee			 
47ee			 
47ee			.FIND: 
47ee				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
47ee 4b				db WORD_SYS_CORE+55             
47ef ac 48			dw .LEN            
47f1 05				db 4 + 1 
47f2 .. 00			db "FIND",0              
47f7				endm 
# End of macro CWHEAD
47f7			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
47f7			 
47f7					if DEBUG_FORTH_WORDS_KEY 
47f7						DMARK "FND" 
47f7 f5				push af  
47f8 3a 0c 48			ld a, (.dmark)  
47fb 32 b4 fe			ld (debug_mark),a  
47fe 3a 0d 48			ld a, (.dmark+1)  
4801 32 b5 fe			ld (debug_mark+1),a  
4804 3a 0e 48			ld a, (.dmark+2)  
4807 32 b6 fe			ld (debug_mark+2),a  
480a 18 03			jr .pastdmark  
480c ..			.dmark: db "FND"  
480f f1			.pastdmark: pop af  
4810			endm  
# End of macro DMARK
4810						CALLMONITOR 
4810 cd c6 18			call break_point_state  
4813				endm  
# End of macro CALLMONITOR
4813					endif 
4813			 
4813			; TODO check string type 
4813					FORTH_DSP_VALUE 
4813 cd 1a 21			call macro_forth_dsp_value 
4816				endm 
# End of macro FORTH_DSP_VALUE
4816			 
4816 e5					push hl    
4817 7e					ld a,(hl)    ; char to find   
4818			; TODO change char to substr 
4818			 
4818 f5					push af 
4819					 
4819			 
4819			 
4819					if DEBUG_FORTH_WORDS 
4819						DMARK "FN1" 
4819 f5				push af  
481a 3a 2e 48			ld a, (.dmark)  
481d 32 b4 fe			ld (debug_mark),a  
4820 3a 2f 48			ld a, (.dmark+1)  
4823 32 b5 fe			ld (debug_mark+1),a  
4826 3a 30 48			ld a, (.dmark+2)  
4829 32 b6 fe			ld (debug_mark+2),a  
482c 18 03			jr .pastdmark  
482e ..			.dmark: db "FN1"  
4831 f1			.pastdmark: pop af  
4832			endm  
# End of macro DMARK
4832						CALLMONITOR 
4832 cd c6 18			call break_point_state  
4835				endm  
# End of macro CALLMONITOR
4835					endif 
4835			 
4835					FORTH_DSP_POP 
4835 cd e9 21			call macro_forth_dsp_pop 
4838				endm 
# End of macro FORTH_DSP_POP
4838			 
4838					; string to search 
4838			 
4838					FORTH_DSP_VALUE 
4838 cd 1a 21			call macro_forth_dsp_value 
483b				endm 
# End of macro FORTH_DSP_VALUE
483b			 
483b d1					pop de  ; d is char to find  
483c			 
483c					if DEBUG_FORTH_WORDS 
483c						DMARK "FN2" 
483c f5				push af  
483d 3a 51 48			ld a, (.dmark)  
4840 32 b4 fe			ld (debug_mark),a  
4843 3a 52 48			ld a, (.dmark+1)  
4846 32 b5 fe			ld (debug_mark+1),a  
4849 3a 53 48			ld a, (.dmark+2)  
484c 32 b6 fe			ld (debug_mark+2),a  
484f 18 03			jr .pastdmark  
4851 ..			.dmark: db "FN2"  
4854 f1			.pastdmark: pop af  
4855			endm  
# End of macro DMARK
4855						CALLMONITOR 
4855 cd c6 18			call break_point_state  
4858				endm  
# End of macro CALLMONITOR
4858					endif 
4858					 
4858 01 00 00				ld bc, 0 
485b 7e			.findchar:      ld a,(hl) 
485c fe 00				cp 0   		 
485e 28 27				jr z, .finddone     
4860 ba					cp d 
4861 28 20				jr z, .foundchar 
4863 03					inc bc 
4864 23					inc hl 
4865					if DEBUG_FORTH_WORDS 
4865						DMARK "FN3" 
4865 f5				push af  
4866 3a 7a 48			ld a, (.dmark)  
4869 32 b4 fe			ld (debug_mark),a  
486c 3a 7b 48			ld a, (.dmark+1)  
486f 32 b5 fe			ld (debug_mark+1),a  
4872 3a 7c 48			ld a, (.dmark+2)  
4875 32 b6 fe			ld (debug_mark+2),a  
4878 18 03			jr .pastdmark  
487a ..			.dmark: db "FN3"  
487d f1			.pastdmark: pop af  
487e			endm  
# End of macro DMARK
487e						CALLMONITOR 
487e cd c6 18			call break_point_state  
4881				endm  
# End of macro CALLMONITOR
4881					endif 
4881 18 d8				jr .findchar 
4883			 
4883			 
4883 c5			.foundchar:	push bc 
4884 e1					pop hl 
4885 18 03				jr .findexit 
4887			 
4887			 
4887							 
4887			 
4887			.finddone:     ; got to end of string with no find 
4887 21 00 00				ld hl, 0 
488a			.findexit: 
488a			 
488a					if DEBUG_FORTH_WORDS 
488a						DMARK "FNd" 
488a f5				push af  
488b 3a 9f 48			ld a, (.dmark)  
488e 32 b4 fe			ld (debug_mark),a  
4891 3a a0 48			ld a, (.dmark+1)  
4894 32 b5 fe			ld (debug_mark+1),a  
4897 3a a1 48			ld a, (.dmark+2)  
489a 32 b6 fe			ld (debug_mark+2),a  
489d 18 03			jr .pastdmark  
489f ..			.dmark: db "FNd"  
48a2 f1			.pastdmark: pop af  
48a3			endm  
# End of macro DMARK
48a3						CALLMONITOR 
48a3 cd c6 18			call break_point_state  
48a6				endm  
# End of macro CALLMONITOR
48a6					endif 
48a6 cd 3a 1f			call forth_push_numhl 
48a9			 
48a9				       NEXTW 
48a9 c3 e0 22			jp macro_next 
48ac				endm 
# End of macro NEXTW
48ac			 
48ac			.LEN: 
48ac				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
48ac 4c				db WORD_SYS_CORE+56             
48ad 16 49			dw .ASC            
48af 06				db 5 + 1 
48b0 .. 00			db "COUNT",0              
48b6				endm 
# End of macro CWHEAD
48b6			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
48b6			 
48b6					if DEBUG_FORTH_WORDS_KEY 
48b6						DMARK "CNT" 
48b6 f5				push af  
48b7 3a cb 48			ld a, (.dmark)  
48ba 32 b4 fe			ld (debug_mark),a  
48bd 3a cc 48			ld a, (.dmark+1)  
48c0 32 b5 fe			ld (debug_mark+1),a  
48c3 3a cd 48			ld a, (.dmark+2)  
48c6 32 b6 fe			ld (debug_mark+2),a  
48c9 18 03			jr .pastdmark  
48cb ..			.dmark: db "CNT"  
48ce f1			.pastdmark: pop af  
48cf			endm  
# End of macro DMARK
48cf						CALLMONITOR 
48cf cd c6 18			call break_point_state  
48d2				endm  
# End of macro CALLMONITOR
48d2					endif 
48d2			; TODO check string type 
48d2					FORTH_DSP_VALUE 
48d2 cd 1a 21			call macro_forth_dsp_value 
48d5				endm 
# End of macro FORTH_DSP_VALUE
48d5			 
48d5			 
48d5					if DEBUG_FORTH_WORDS 
48d5						DMARK "CN?" 
48d5 f5				push af  
48d6 3a ea 48			ld a, (.dmark)  
48d9 32 b4 fe			ld (debug_mark),a  
48dc 3a eb 48			ld a, (.dmark+1)  
48df 32 b5 fe			ld (debug_mark+1),a  
48e2 3a ec 48			ld a, (.dmark+2)  
48e5 32 b6 fe			ld (debug_mark+2),a  
48e8 18 03			jr .pastdmark  
48ea ..			.dmark: db "CN?"  
48ed f1			.pastdmark: pop af  
48ee			endm  
# End of macro DMARK
48ee						CALLMONITOR 
48ee cd c6 18			call break_point_state  
48f1				endm  
# End of macro CALLMONITOR
48f1					endif 
48f1 cd a7 13				call strlenz 
48f4					if DEBUG_FORTH_WORDS 
48f4						DMARK "CNl" 
48f4 f5				push af  
48f5 3a 09 49			ld a, (.dmark)  
48f8 32 b4 fe			ld (debug_mark),a  
48fb 3a 0a 49			ld a, (.dmark+1)  
48fe 32 b5 fe			ld (debug_mark+1),a  
4901 3a 0b 49			ld a, (.dmark+2)  
4904 32 b6 fe			ld (debug_mark+2),a  
4907 18 03			jr .pastdmark  
4909 ..			.dmark: db "CNl"  
490c f1			.pastdmark: pop af  
490d			endm  
# End of macro DMARK
490d						CALLMONITOR 
490d cd c6 18			call break_point_state  
4910				endm  
# End of macro CALLMONITOR
4910					endif 
4910			 
4910 cd 3a 1f				call forth_push_numhl 
4913			 
4913			 
4913			 
4913				       NEXTW 
4913 c3 e0 22			jp macro_next 
4916				endm 
# End of macro NEXTW
4916			.ASC: 
4916				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4916 4d				db WORD_SYS_CORE+57             
4917 4b 49			dw .CHR            
4919 04				db 3 + 1 
491a .. 00			db "ASC",0              
491e				endm 
# End of macro CWHEAD
491e			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
491e					if DEBUG_FORTH_WORDS_KEY 
491e						DMARK "ASC" 
491e f5				push af  
491f 3a 33 49			ld a, (.dmark)  
4922 32 b4 fe			ld (debug_mark),a  
4925 3a 34 49			ld a, (.dmark+1)  
4928 32 b5 fe			ld (debug_mark+1),a  
492b 3a 35 49			ld a, (.dmark+2)  
492e 32 b6 fe			ld (debug_mark+2),a  
4931 18 03			jr .pastdmark  
4933 ..			.dmark: db "ASC"  
4936 f1			.pastdmark: pop af  
4937			endm  
# End of macro DMARK
4937						CALLMONITOR 
4937 cd c6 18			call break_point_state  
493a				endm  
# End of macro CALLMONITOR
493a					endif 
493a					FORTH_DSP 
493a cd f7 20			call macro_forth_dsp 
493d				endm 
# End of macro FORTH_DSP
493d					;v5 FORTH_DSP_VALUE 
493d 23					inc hl      ; now at start of numeric as string 
493e			 
493e			;		push hl 
493e			 
493e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
493e cd e9 21			call macro_forth_dsp_pop 
4941				endm 
# End of macro FORTH_DSP_POP
4941			 
4941			;		pop hl 
4941			 
4941					; push the content of a onto the stack as a value 
4941			 
4941 7e					ld a,(hl)   ; get char 
4942 26 00				ld h,0 
4944 6f					ld l,a 
4945 cd 3a 1f				call forth_push_numhl 
4948			 
4948				       NEXTW 
4948 c3 e0 22			jp macro_next 
494b				endm 
# End of macro NEXTW
494b			 
494b			.CHR: 
494b				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
494b 4d				db WORD_SYS_CORE+57             
494c 87 49			dw .ENDSTR            
494e 04				db 3 + 1 
494f .. 00			db "CHR",0              
4953				endm 
# End of macro CWHEAD
4953			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4953					if DEBUG_FORTH_WORDS_KEY 
4953						DMARK "CHR" 
4953 f5				push af  
4954 3a 68 49			ld a, (.dmark)  
4957 32 b4 fe			ld (debug_mark),a  
495a 3a 69 49			ld a, (.dmark+1)  
495d 32 b5 fe			ld (debug_mark+1),a  
4960 3a 6a 49			ld a, (.dmark+2)  
4963 32 b6 fe			ld (debug_mark+2),a  
4966 18 03			jr .pastdmark  
4968 ..			.dmark: db "CHR"  
496b f1			.pastdmark: pop af  
496c			endm  
# End of macro DMARK
496c						CALLMONITOR 
496c cd c6 18			call break_point_state  
496f				endm  
# End of macro CALLMONITOR
496f					endif 
496f					FORTH_DSP_VALUEHL 
496f cd 31 21			call macro_dsp_valuehl 
4972				endm 
# End of macro FORTH_DSP_VALUEHL
4972			 
4972					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4972 cd e9 21			call macro_forth_dsp_pop 
4975				endm 
# End of macro FORTH_DSP_POP
4975			 
4975					; save asci byte as a zero term string and push string 
4975			 
4975 7d					ld a,l 
4976 32 4e f3				ld (scratch), a 
4979			 
4979 3e 00				ld a, 0 
497b 32 4f f3				ld (scratch+1), a 
497e			 
497e 21 4e f3				ld hl, scratch 
4981 cd a8 1f				call forth_push_str 
4984			 
4984			 
4984				       NEXTW 
4984 c3 e0 22			jp macro_next 
4987				endm 
# End of macro NEXTW
4987			 
4987			 
4987			 
4987			 
4987			.ENDSTR: 
4987			; eof 
4987			 
# End of file forth_words_str.asm
4987			include "forth_words_key.asm" 
4987			 
4987			; | ## Keyboard Words 
4987			 
4987			.KEY: 
4987				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4987 3e				db WORD_SYS_CORE+42             
4988 b7 49			dw .WAITK            
498a 04				db 3 + 1 
498b .. 00			db "KEY",0              
498f				endm 
# End of macro CWHEAD
498f			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
498f			 
498f					if DEBUG_FORTH_WORDS_KEY 
498f						DMARK "KEY" 
498f f5				push af  
4990 3a a4 49			ld a, (.dmark)  
4993 32 b4 fe			ld (debug_mark),a  
4996 3a a5 49			ld a, (.dmark+1)  
4999 32 b5 fe			ld (debug_mark+1),a  
499c 3a a6 49			ld a, (.dmark+2)  
499f 32 b6 fe			ld (debug_mark+2),a  
49a2 18 03			jr .pastdmark  
49a4 ..			.dmark: db "KEY"  
49a7 f1			.pastdmark: pop af  
49a8			endm  
# End of macro DMARK
49a8						CALLMONITOR 
49a8 cd c6 18			call break_point_state  
49ab				endm  
# End of macro CALLMONITOR
49ab					endif 
49ab			; TODO currently waits 
49ab cd c2 71				call cin 
49ae					;call cin_wait 
49ae 6f					ld l, a 
49af 26 00				ld h, 0 
49b1 cd 3a 1f				call forth_push_numhl 
49b4					NEXTW 
49b4 c3 e0 22			jp macro_next 
49b7				endm 
# End of macro NEXTW
49b7			.WAITK: 
49b7				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
49b7 3f				db WORD_SYS_CORE+43             
49b8 e9 49			dw .ACCEPT            
49ba 06				db 5 + 1 
49bb .. 00			db "WAITK",0              
49c1				endm 
# End of macro CWHEAD
49c1			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
49c1					if DEBUG_FORTH_WORDS_KEY 
49c1						DMARK "WAI" 
49c1 f5				push af  
49c2 3a d6 49			ld a, (.dmark)  
49c5 32 b4 fe			ld (debug_mark),a  
49c8 3a d7 49			ld a, (.dmark+1)  
49cb 32 b5 fe			ld (debug_mark+1),a  
49ce 3a d8 49			ld a, (.dmark+2)  
49d1 32 b6 fe			ld (debug_mark+2),a  
49d4 18 03			jr .pastdmark  
49d6 ..			.dmark: db "WAI"  
49d9 f1			.pastdmark: pop af  
49da			endm  
# End of macro DMARK
49da						CALLMONITOR 
49da cd c6 18			call break_point_state  
49dd				endm  
# End of macro CALLMONITOR
49dd					endif 
49dd cd b1 71				call cin_wait 
49e0 6f					ld l, a 
49e1 26 00				ld h, 0 
49e3 cd 3a 1f				call forth_push_numhl 
49e6					NEXTW 
49e6 c3 e0 22			jp macro_next 
49e9				endm 
# End of macro NEXTW
49e9			.ACCEPT: 
49e9				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
49e9 40				db WORD_SYS_CORE+44             
49ea 47 4a			dw .EDIT            
49ec 07				db 6 + 1 
49ed .. 00			db "ACCEPT",0              
49f4				endm 
# End of macro CWHEAD
49f4			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
49f4					; TODO crashes on push 
49f4					if DEBUG_FORTH_WORDS_KEY 
49f4						DMARK "ACC" 
49f4 f5				push af  
49f5 3a 09 4a			ld a, (.dmark)  
49f8 32 b4 fe			ld (debug_mark),a  
49fb 3a 0a 4a			ld a, (.dmark+1)  
49fe 32 b5 fe			ld (debug_mark+1),a  
4a01 3a 0b 4a			ld a, (.dmark+2)  
4a04 32 b6 fe			ld (debug_mark+2),a  
4a07 18 03			jr .pastdmark  
4a09 ..			.dmark: db "ACC"  
4a0c f1			.pastdmark: pop af  
4a0d			endm  
# End of macro DMARK
4a0d						CALLMONITOR 
4a0d cd c6 18			call break_point_state  
4a10				endm  
# End of macro CALLMONITOR
4a10					endif 
4a10 21 4c f5				ld hl, os_input 
4a13 3e 00				ld a, 0 
4a15 77					ld (hl),a 
4a16 3a eb fb				ld a,(f_cursor_ptr) 
4a19 16 64				ld d, 100 
4a1b 0e 00				ld c, 0 
4a1d 1e 28				ld e, 40 
4a1f cd 76 0f				call input_str 
4a22					; TODO perhaps do a type check and wrap in quotes if not a number 
4a22 21 4c f5				ld hl, os_input 
4a25					if DEBUG_FORTH_WORDS 
4a25						DMARK "AC1" 
4a25 f5				push af  
4a26 3a 3a 4a			ld a, (.dmark)  
4a29 32 b4 fe			ld (debug_mark),a  
4a2c 3a 3b 4a			ld a, (.dmark+1)  
4a2f 32 b5 fe			ld (debug_mark+1),a  
4a32 3a 3c 4a			ld a, (.dmark+2)  
4a35 32 b6 fe			ld (debug_mark+2),a  
4a38 18 03			jr .pastdmark  
4a3a ..			.dmark: db "AC1"  
4a3d f1			.pastdmark: pop af  
4a3e			endm  
# End of macro DMARK
4a3e						CALLMONITOR 
4a3e cd c6 18			call break_point_state  
4a41				endm  
# End of macro CALLMONITOR
4a41					endif 
4a41 cd a8 1f				call forth_push_str 
4a44					NEXTW 
4a44 c3 e0 22			jp macro_next 
4a47				endm 
# End of macro NEXTW
4a47			 
4a47			.EDIT: 
4a47				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4a47 40				db WORD_SYS_CORE+44             
4a48 e9 4a			dw .ENDKEY            
4a4a 05				db 4 + 1 
4a4b .. 00			db "EDIT",0              
4a50				endm 
# End of macro CWHEAD
4a50			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4a50			 
4a50					; TODO does not copy from stack 
4a50					if DEBUG_FORTH_WORDS_KEY 
4a50						DMARK "EDT" 
4a50 f5				push af  
4a51 3a 65 4a			ld a, (.dmark)  
4a54 32 b4 fe			ld (debug_mark),a  
4a57 3a 66 4a			ld a, (.dmark+1)  
4a5a 32 b5 fe			ld (debug_mark+1),a  
4a5d 3a 67 4a			ld a, (.dmark+2)  
4a60 32 b6 fe			ld (debug_mark+2),a  
4a63 18 03			jr .pastdmark  
4a65 ..			.dmark: db "EDT"  
4a68 f1			.pastdmark: pop af  
4a69			endm  
# End of macro DMARK
4a69						CALLMONITOR 
4a69 cd c6 18			call break_point_state  
4a6c				endm  
# End of macro CALLMONITOR
4a6c					endif 
4a6c			 
4a6c					;FORTH_DSP 
4a6c					FORTH_DSP_VALUEHL 
4a6c cd 31 21			call macro_dsp_valuehl 
4a6f				endm 
# End of macro FORTH_DSP_VALUEHL
4a6f			;		inc hl    ; TODO do type check 
4a6f			 
4a6f			;		call get_word_hl 
4a6f e5					push hl 
4a70					if DEBUG_FORTH_WORDS 
4a70						DMARK "EDp" 
4a70 f5				push af  
4a71 3a 85 4a			ld a, (.dmark)  
4a74 32 b4 fe			ld (debug_mark),a  
4a77 3a 86 4a			ld a, (.dmark+1)  
4a7a 32 b5 fe			ld (debug_mark+1),a  
4a7d 3a 87 4a			ld a, (.dmark+2)  
4a80 32 b6 fe			ld (debug_mark+2),a  
4a83 18 03			jr .pastdmark  
4a85 ..			.dmark: db "EDp"  
4a88 f1			.pastdmark: pop af  
4a89			endm  
# End of macro DMARK
4a89						CALLMONITOR 
4a89 cd c6 18			call break_point_state  
4a8c				endm  
# End of macro CALLMONITOR
4a8c					endif 
4a8c				;	ld a, 0 
4a8c cd a7 13				call strlenz 
4a8f 23					inc hl 
4a90			 
4a90 06 00				ld b, 0 
4a92 4d					ld c, l 
4a93			 
4a93 e1					pop hl 
4a94 11 4c f5				ld de, os_input 
4a97					if DEBUG_FORTH_WORDS_KEY 
4a97						DMARK "EDc" 
4a97 f5				push af  
4a98 3a ac 4a			ld a, (.dmark)  
4a9b 32 b4 fe			ld (debug_mark),a  
4a9e 3a ad 4a			ld a, (.dmark+1)  
4aa1 32 b5 fe			ld (debug_mark+1),a  
4aa4 3a ae 4a			ld a, (.dmark+2)  
4aa7 32 b6 fe			ld (debug_mark+2),a  
4aaa 18 03			jr .pastdmark  
4aac ..			.dmark: db "EDc"  
4aaf f1			.pastdmark: pop af  
4ab0			endm  
# End of macro DMARK
4ab0						CALLMONITOR 
4ab0 cd c6 18			call break_point_state  
4ab3				endm  
# End of macro CALLMONITOR
4ab3					endif 
4ab3 ed b0				ldir 
4ab5			 
4ab5			 
4ab5 21 4c f5				ld hl, os_input 
4ab8					;ld a, 0 
4ab8					;ld (hl),a 
4ab8 3a eb fb				ld a,(f_cursor_ptr) 
4abb 16 64				ld d, 100 
4abd 0e 00				ld c, 0 
4abf 1e 28				ld e, 40 
4ac1 cd 76 0f				call input_str 
4ac4					; TODO perhaps do a type check and wrap in quotes if not a number 
4ac4 21 4c f5				ld hl, os_input 
4ac7					if DEBUG_FORTH_WORDS 
4ac7						DMARK "ED1" 
4ac7 f5				push af  
4ac8 3a dc 4a			ld a, (.dmark)  
4acb 32 b4 fe			ld (debug_mark),a  
4ace 3a dd 4a			ld a, (.dmark+1)  
4ad1 32 b5 fe			ld (debug_mark+1),a  
4ad4 3a de 4a			ld a, (.dmark+2)  
4ad7 32 b6 fe			ld (debug_mark+2),a  
4ada 18 03			jr .pastdmark  
4adc ..			.dmark: db "ED1"  
4adf f1			.pastdmark: pop af  
4ae0			endm  
# End of macro DMARK
4ae0						CALLMONITOR 
4ae0 cd c6 18			call break_point_state  
4ae3				endm  
# End of macro CALLMONITOR
4ae3					endif 
4ae3 cd a8 1f				call forth_push_str 
4ae6					NEXTW 
4ae6 c3 e0 22			jp macro_next 
4ae9				endm 
# End of macro NEXTW
4ae9			 
4ae9			 
4ae9			 
4ae9			.ENDKEY: 
4ae9			; eof 
4ae9			 
# End of file forth_words_key.asm
4ae9			include "forth_words_const.asm" 
4ae9			 
4ae9			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4ae9			 
4ae9			 
4ae9			.SPITIME: 
4ae9				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4ae9 77				db WORD_SYS_CORE+99             
4aea fe 4a			dw .VA            
4aec 08				db 7 + 1 
4aed .. 00			db "SPITIME",0              
4af5				endm 
# End of macro CWHEAD
4af5			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4af5			; 
4af5			; | If using BANK devices then leave as is. 
4af5			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4af5			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4af5			 
4af5 21 f1 fb				ld hl, spi_clktime  
4af8 cd 3a 1f				call forth_push_numhl 
4afb			 
4afb					NEXTW 
4afb c3 e0 22			jp macro_next 
4afe				endm 
# End of macro NEXTW
4afe			 
4afe			 
4afe			.VA: 
4afe				CWHEAD .ENDCONST 99 "VA" 2 WORD_FLAG_CODE 
4afe 77				db WORD_SYS_CORE+99             
4aff 0e 4b			dw .ENDCONST            
4b01 03				db 2 + 1 
4b02 .. 00			db "VA",0              
4b05				endm 
# End of macro CWHEAD
4b05			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4b05 21 b5 fb				ld hl, cli_var_array 
4b08 cd 3a 1f				call forth_push_numhl 
4b0b			 
4b0b					NEXTW 
4b0b c3 e0 22			jp macro_next 
4b0e				endm 
# End of macro NEXTW
4b0e			 
4b0e			 
4b0e			;endif 
4b0e			 
4b0e			;LFSRSeed:	equ $fbb3 
4b0e			;chk_data_ovr:	equ $f761 
4b0e			;chk_loop_ovr:	equ $f963 
4b0e			;chk_ret_ovr:	equ $f9e5 
4b0e			;chk_ret_und:	equ $fa27 
4b0e			;chk_stovr:	equ $fefd 
4b0e			;chk_stund:	equ $ffff 
4b0e			;cli_autodisplay:	equ $fa43 
4b0e			;cli_buffer:	equ $fa51 
4b0e			;cli_data_sp:	equ $fa29 
4b0e			;cli_data_stack:	equ $f763 
4b0e			;cli_execword:	equ $fa4b 
4b0e			;cli_loop_sp:	equ $fa2b 
4b0e			;cli_loop_stack:	equ $f965 
4b0e			;cli_mvdot:	equ $fa44 
4b0e			;cli_nextword:	equ $fa49 
4b0e			;cli_origptr:	equ $fa45 
4b0e			;cli_origtoken:	equ $fa4f 
4b0e			;cli_ptr:	equ $fa47 
4b0e			;cli_ret_sp:	equ $fa2d 
4b0e			;cli_ret_stack:	equ $f9e7 
4b0e			;cli_token:	equ $fa4d 
4b0e			;cli_var_array:	equ $fa2f 
4b0e			;cursor_col:	equ $fbcb 
4b0e			;cursor_ptr:	equ $fbc9 
4b0e			;cursor_row:	equ $fbca 
4b0e			;cursor_shape:	equ $fbc7 
4b0e			;debug_mark:	equ $fe6e 
4b0e			;display_fb0:	equ $fdb4 
4b0e			;display_fb1:	equ $fd13 
4b0e			;display_fb2:	equ $fbd1 
4b0e			;display_fb3:	equ $fc72 
4b0e			;display_fb_active:	equ $fbcf 
4b0e			;display_lcde1e2:	equ $fbce 
4b0e			;execscratch:	equ $f2fb 
4b0e			;f_cursor_ptr:	equ $fa65 
4b0e			;hardware_word:	equ $fe72 
4b0e			;heap_start:	equ $800e 
4b0e			;iErrorNum:	equ $fba8 
4b0e			;iErrorReg:	equ $fba7 
4b0e			;iErrorVer:	equ $fba6 
4b0e			;input_at_cursor:	equ $fe65 
4b0e			;input_at_pos:	equ $fe67 
4b0e			;input_cur_flash:	equ $fe63 
4b0e			;input_cur_onoff:	equ $fe62 
4b0e			;input_cursor:	equ $fe58 
4b0e			;input_display_size:	equ $fe68 
4b0e			;input_len:	equ $fe5d 
4b0e			;input_ptr:	equ $fe6c 
4b0e			;input_size:	equ $fe69 
4b0e			;input_start:	equ $fe6a 
4b0e			;input_str:	equ $0f79 
4b0e			;input_under_cursor:	equ $fe66 
4b0e			;key_actual_pressed:	equ $fe57 
4b0e			;key_fa:	equ $fe82 
4b0e			;key_face_held:	equ $fe7e 
4b0e			;key_fb:	equ $fe81 
4b0e			;key_fc:	equ $fe80 
4b0e			;key_fd:	equ $fe7f 
4b0e			;key_held:	equ $fe88 
4b0e			;key_held_prev:	equ $fe87 
4b0e			;key_init:	equ $7060 
4b0e			;key_repeat_ct:	equ $fe83 
4b0e			;key_rows:	equ $0005 
4b0e			;key_shift:	equ $fe55 
4b0e			;key_symbol:	equ $fe56 
4b0e			;keyscan_scancol:	equ $fe89 
4b0e			;keyscan_table:	equ $fe93 
4b0e			;keyscan_table_row1:	equ $fef2 
4b0e			;keyscan_table_row2:	equ $fee7 
4b0e			;keyscan_table_row3:	equ $fedc 
4b0e			;keyscan_table_row4:	equ $fed1 
4b0e			;keyscan_table_row5:	equ $fec6 
4b0e			;os_cli_cmd:	equ $f523 
4b0e			;os_cur_ptr:	equ $f51f 
4b0e			;os_current_i:	equ $f521 
4b0e			;os_input:	equ $f3fa 
4b0e			;os_last_cmd:	equ $f622 
4b0e			;os_last_new_uword:	equ $f4f9 
4b0e			;os_new_exec:	equ $f1f0 
4b0e			;os_new_exec_ptr:	equ $f1ee 
4b0e			;os_new_malloc:	equ $f1fa 
4b0e			;os_new_parse_len:	equ $f1f8 
4b0e			;os_new_src_ptr:	equ $f1f2 
4b0e			;os_new_word_len:	equ $f1f6 
4b0e			;os_new_work_ptr:	equ $f1f4 
4b0e			;os_tok_len:	equ $f4ff 
4b0e			;os_tok_malloc:	equ $f4fb 
4b0e			;os_tok_ptr:	equ $f4fd 
4b0e			;os_var_array:	equ $f721 
4b0e			;os_view_af:	equ $f1eb 
4b0e			;os_view_bc:	equ $f1e5 
4b0e			;os_view_de:	equ $f1e7 
4b0e			;os_view_disable:	equ $f1ed 
4b0e			;os_view_hl:	equ $f1e9 
4b0e			;os_word_scratch:	equ $f501 
4b0e			;portbctl:	equ $00c3 
4b0e			;portbdata:	equ $00c1 
4b0e			;prng16:	equ $0e73 
4b0e			;prom_bootmsg:	equ $1ac9 
4b0e			;prom_bootmsg1:	equ $1ade 
4b0e			;randData:	equ $fbb1 
4b0e			;scratch:	equ $f1fc 
4b0e			;seed1:	equ $fbab 
4b0e			;seed2:	equ $fba9 
4b0e			;spi_cartdev:	equ $fa6a 
4b0e			;spi_cartdev2:	equ $fa69 
4b0e			;spi_clktime:	equ $fa6b 
4b0e			;spi_device:	equ $fa67 
4b0e			;spi_device_id:	equ $fa66 
4b0e			;spi_portbyte:	equ $fa68 
4b0e			;stackstore:	equ $fbad 
4b0e			;;start1:	equ $5bfc 
4b0e			;;start2:	equ $5c0e 
4b0e			;;start3b:	equ $5c21 
4b0e			;;start3c:	equ $5c9d 
4b0e			;;startcmds:	equ $57a3 
4b0e			;;stest:	equ $5d67 
4b0e			;;storage_actl:	equ $0082 
4b0e			;;storage_adata:	equ $0080 
4b0e			;;storage_append:	equ $0b0c 
4b0e			;;storage_bctl:	equ $0083 
4b0e			;store_bank_active:	equ $fb99 
4b0e			;store_filecache:	equ $fa6e 
4b0e			;store_longread:	equ $fa7c 
4b0e			;store_openaddr:	equ $fa72 
4b0e			;store_openext:	equ $fa71 
4b0e			;store_openmaxext:	equ $fa70 
4b0e			;store_page:	equ $fa81 
4b0e			;store_readbuf:	equ $fa7d 
4b0e			;store_readcont:	equ $fa74 
4b0e			;store_readptr:	equ $fa7f 
4b0e			;store_tmp1:	equ $fa7a 
4b0e			;store_tmp2:	equ $fa78 
4b0e			;store_tmp3:	equ $fa76 
4b0e			;store_tmpext:	equ $fa74 
4b0e			;store_tmpid:	equ $fa75 
4b0e			;store_tmppageid:	equ $fa6c 
4b0e			;tos:	equ $fffd 
4b0e			;type:	equ $5b77 
4b0e			;xrandc:	equ $fbaf 
4b0e			 
4b0e			 
4b0e			.ENDCONST: 
4b0e			 
4b0e			; eof 
4b0e			 
4b0e			 
# End of file forth_words_const.asm
4b0e			 
4b0e			if STORAGE_SE 
4b0e			   	include "forth_words_storage.asm" 
4b0e			 
4b0e			; | ## Fixed Storage Words 
4b0e			 
4b0e			.RECORD: 
4b0e			  
4b0e				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4b0e 3a				db WORD_SYS_CORE+38             
4b0f b2 4b			dw .BREAD            
4b11 07				db 6 + 1 
4b12 .. 00			db "RECORD",0              
4b19				endm 
# End of macro CWHEAD
4b19			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4b19			 
4b19					if DEBUG_FORTH_WORDS_KEY 
4b19						DMARK "REC" 
4b19 f5				push af  
4b1a 3a 2e 4b			ld a, (.dmark)  
4b1d 32 b4 fe			ld (debug_mark),a  
4b20 3a 2f 4b			ld a, (.dmark+1)  
4b23 32 b5 fe			ld (debug_mark+1),a  
4b26 3a 30 4b			ld a, (.dmark+2)  
4b29 32 b6 fe			ld (debug_mark+2),a  
4b2c 18 03			jr .pastdmark  
4b2e ..			.dmark: db "REC"  
4b31 f1			.pastdmark: pop af  
4b32			endm  
# End of macro DMARK
4b32						CALLMONITOR 
4b32 cd c6 18			call break_point_state  
4b35				endm  
# End of macro CALLMONITOR
4b35					endif 
4b35			 
4b35					FORTH_DSP_VALUEHL 
4b35 cd 31 21			call macro_dsp_valuehl 
4b38				endm 
# End of macro FORTH_DSP_VALUEHL
4b38			 
4b38 e5					push hl    ; id 
4b39			 
4b39					FORTH_DSP_POP 
4b39 cd e9 21			call macro_forth_dsp_pop 
4b3c				endm 
# End of macro FORTH_DSP_POP
4b3c			 
4b3c					FORTH_DSP_VALUEHL 
4b3c cd 31 21			call macro_dsp_valuehl 
4b3f				endm 
# End of macro FORTH_DSP_VALUEHL
4b3f			 
4b3f					FORTH_DSP_POP 
4b3f cd e9 21			call macro_forth_dsp_pop 
4b42				endm 
# End of macro FORTH_DSP_POP
4b42			 
4b42 d1					pop de     ; get file id 
4b43			 
4b43					; e = file id 
4b43					; l = file extent 
4b43			 
4b43			 
4b43					; construct request to access file extent 
4b43			 
4b43			;		ld a, e 
4b43 63					ld h, e 
4b44					 
4b44					 
4b44					 
4b44			 
4b44					; e has id 
4b44			 
4b44 11 07 fc			ld de, store_page 
4b47					if DEBUG_FORTH_WORDS 
4b47						DMARK "REr" 
4b47 f5				push af  
4b48 3a 5c 4b			ld a, (.dmark)  
4b4b 32 b4 fe			ld (debug_mark),a  
4b4e 3a 5d 4b			ld a, (.dmark+1)  
4b51 32 b5 fe			ld (debug_mark+1),a  
4b54 3a 5e 4b			ld a, (.dmark+2)  
4b57 32 b6 fe			ld (debug_mark+2),a  
4b5a 18 03			jr .pastdmark  
4b5c ..			.dmark: db "REr"  
4b5f f1			.pastdmark: pop af  
4b60			endm  
# End of macro DMARK
4b60						CALLMONITOR 
4b60 cd c6 18			call break_point_state  
4b63				endm  
# End of macro CALLMONITOR
4b63					endif 
4b63 cd 72 09				call storage_read 
4b66 cd 72 0f			call ishlzero 
4b69 28 22			jr z, .recnotfound 
4b6b			 
4b6b			 
4b6b					if DEBUG_FORTH_WORDS 
4b6b						DMARK "REe" 
4b6b f5				push af  
4b6c 3a 80 4b			ld a, (.dmark)  
4b6f 32 b4 fe			ld (debug_mark),a  
4b72 3a 81 4b			ld a, (.dmark+1)  
4b75 32 b5 fe			ld (debug_mark+1),a  
4b78 3a 82 4b			ld a, (.dmark+2)  
4b7b 32 b6 fe			ld (debug_mark+2),a  
4b7e 18 03			jr .pastdmark  
4b80 ..			.dmark: db "REe"  
4b83 f1			.pastdmark: pop af  
4b84			endm  
# End of macro DMARK
4b84						CALLMONITOR 
4b84 cd c6 18			call break_point_state  
4b87				endm  
# End of macro CALLMONITOR
4b87					endif 
4b87 cd a8 1f			call forth_push_str 
4b8a			 
4b8a					NEXTW 
4b8a c3 e0 22			jp macro_next 
4b8d				endm 
# End of macro NEXTW
4b8d			 
4b8d			.recnotfound: 
4b8d					if DEBUG_FORTH_WORDS 
4b8d						DMARK "REf" 
4b8d f5				push af  
4b8e 3a a2 4b			ld a, (.dmark)  
4b91 32 b4 fe			ld (debug_mark),a  
4b94 3a a3 4b			ld a, (.dmark+1)  
4b97 32 b5 fe			ld (debug_mark+1),a  
4b9a 3a a4 4b			ld a, (.dmark+2)  
4b9d 32 b6 fe			ld (debug_mark+2),a  
4ba0 18 03			jr .pastdmark  
4ba2 ..			.dmark: db "REf"  
4ba5 f1			.pastdmark: pop af  
4ba6			endm  
# End of macro DMARK
4ba6						CALLMONITOR 
4ba6 cd c6 18			call break_point_state  
4ba9				endm  
# End of macro CALLMONITOR
4ba9					endif 
4ba9 21 ff 00			ld hl, 255 
4bac cd 3a 1f			call forth_push_numhl 
4baf				NEXTW 
4baf c3 e0 22			jp macro_next 
4bb2				endm 
# End of macro NEXTW
4bb2			 
4bb2			 
4bb2			.BREAD: 
4bb2			  
4bb2				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4bb2 3a				db WORD_SYS_CORE+38             
4bb3 35 4c			dw .BWRITE            
4bb5 06				db 5 + 1 
4bb6 .. 00			db "BREAD",0              
4bbc				endm 
# End of macro CWHEAD
4bbc			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
4bbc				 
4bbc					if DEBUG_FORTH_WORDS_KEY 
4bbc						DMARK "BRD" 
4bbc f5				push af  
4bbd 3a d1 4b			ld a, (.dmark)  
4bc0 32 b4 fe			ld (debug_mark),a  
4bc3 3a d2 4b			ld a, (.dmark+1)  
4bc6 32 b5 fe			ld (debug_mark+1),a  
4bc9 3a d3 4b			ld a, (.dmark+2)  
4bcc 32 b6 fe			ld (debug_mark+2),a  
4bcf 18 03			jr .pastdmark  
4bd1 ..			.dmark: db "BRD"  
4bd4 f1			.pastdmark: pop af  
4bd5			endm  
# End of macro DMARK
4bd5						CALLMONITOR 
4bd5 cd c6 18			call break_point_state  
4bd8				endm  
# End of macro CALLMONITOR
4bd8					endif 
4bd8			 
4bd8				FORTH_DSP_VALUEHL 
4bd8 cd 31 21			call macro_dsp_valuehl 
4bdb				endm 
# End of macro FORTH_DSP_VALUEHL
4bdb			 
4bdb				FORTH_DSP_POP 
4bdb cd e9 21			call macro_forth_dsp_pop 
4bde				endm 
# End of macro FORTH_DSP_POP
4bde			 
4bde				; calc block address 
4bde			 
4bde eb				ex de, hl 
4bdf 3e 40			ld a, STORE_BLOCK_PHY 
4be1 cd cc 0e			call Mult16 
4be4			 
4be4			 
4be4 11 07 fc			ld de, store_page 
4be7			 
4be7					if DEBUG_FORTH_WORDS 
4be7						DMARK "BR1" 
4be7 f5				push af  
4be8 3a fc 4b			ld a, (.dmark)  
4beb 32 b4 fe			ld (debug_mark),a  
4bee 3a fd 4b			ld a, (.dmark+1)  
4bf1 32 b5 fe			ld (debug_mark+1),a  
4bf4 3a fe 4b			ld a, (.dmark+2)  
4bf7 32 b6 fe			ld (debug_mark+2),a  
4bfa 18 03			jr .pastdmark  
4bfc ..			.dmark: db "BR1"  
4bff f1			.pastdmark: pop af  
4c00			endm  
# End of macro DMARK
4c00						CALLMONITOR 
4c00 cd c6 18			call break_point_state  
4c03				endm  
# End of macro CALLMONITOR
4c03					endif 
4c03			 
4c03 cd 19 04			call storage_read_block 
4c06			 
4c06 cd 72 0f			call ishlzero 
4c09 20 05			jr nz, .brfound 
4c0b			 
4c0b cd 3a 1f			call forth_push_numhl 
4c0e 18 22			jr .brdone 
4c10			 
4c10			 
4c10			.brfound: 
4c10 21 09 fc		        ld hl, store_page+2 
4c13			 
4c13					if DEBUG_FORTH_WORDS 
4c13						DMARK "BR2" 
4c13 f5				push af  
4c14 3a 28 4c			ld a, (.dmark)  
4c17 32 b4 fe			ld (debug_mark),a  
4c1a 3a 29 4c			ld a, (.dmark+1)  
4c1d 32 b5 fe			ld (debug_mark+1),a  
4c20 3a 2a 4c			ld a, (.dmark+2)  
4c23 32 b6 fe			ld (debug_mark+2),a  
4c26 18 03			jr .pastdmark  
4c28 ..			.dmark: db "BR2"  
4c2b f1			.pastdmark: pop af  
4c2c			endm  
# End of macro DMARK
4c2c						CALLMONITOR 
4c2c cd c6 18			call break_point_state  
4c2f				endm  
# End of macro CALLMONITOR
4c2f					endif 
4c2f			 
4c2f cd a8 1f			call forth_push_str 
4c32			 
4c32			 
4c32			.brdone: 
4c32			 
4c32					NEXTW 
4c32 c3 e0 22			jp macro_next 
4c35				endm 
# End of macro NEXTW
4c35			.BWRITE: 
4c35				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4c35 3a				db WORD_SYS_CORE+38             
4c36 ca 4c			dw .BUPD            
4c38 07				db 6 + 1 
4c39 .. 00			db "BWRITE",0              
4c40				endm 
# End of macro CWHEAD
4c40			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to address u | DONE 
4c40			 
4c40					if DEBUG_FORTH_WORDS_KEY 
4c40						DMARK "BWR" 
4c40 f5				push af  
4c41 3a 55 4c			ld a, (.dmark)  
4c44 32 b4 fe			ld (debug_mark),a  
4c47 3a 56 4c			ld a, (.dmark+1)  
4c4a 32 b5 fe			ld (debug_mark+1),a  
4c4d 3a 57 4c			ld a, (.dmark+2)  
4c50 32 b6 fe			ld (debug_mark+2),a  
4c53 18 03			jr .pastdmark  
4c55 ..			.dmark: db "BWR"  
4c58 f1			.pastdmark: pop af  
4c59			endm  
# End of macro DMARK
4c59						CALLMONITOR 
4c59 cd c6 18			call break_point_state  
4c5c				endm  
# End of macro CALLMONITOR
4c5c					endif 
4c5c			 
4c5c				FORTH_DSP_VALUEHL 
4c5c cd 31 21			call macro_dsp_valuehl 
4c5f				endm 
# End of macro FORTH_DSP_VALUEHL
4c5f			 
4c5f				; calc block address 
4c5f			 
4c5f eb				ex de, hl 
4c60 3e 40			ld a, STORE_BLOCK_PHY 
4c62 cd cc 0e			call Mult16 
4c65			 
4c65 e5				push hl         ; address 
4c66			 
4c66				FORTH_DSP_POP 
4c66 cd e9 21			call macro_forth_dsp_pop 
4c69				endm 
# End of macro FORTH_DSP_POP
4c69			 
4c69				FORTH_DSP_VALUEHL 
4c69 cd 31 21			call macro_dsp_valuehl 
4c6c				endm 
# End of macro FORTH_DSP_VALUEHL
4c6c			 
4c6c				FORTH_DSP_POP 
4c6c cd e9 21			call macro_forth_dsp_pop 
4c6f				endm 
# End of macro FORTH_DSP_POP
4c6f			 
4c6f cd 55 0c			call storage_clear_page 
4c72			 
4c72				; copy string to store page 
4c72			 
4c72 e5				push hl     ; save string address 
4c73			 
4c73 3e 00			ld a, 0 
4c75 cd b2 13			call strlent 
4c78			 
4c78 23				inc hl 
4c79			 
4c79 4d				ld c, l 
4c7a 06 00			ld b, 0 
4c7c			 
4c7c e1				pop hl 
4c7d 11 09 fc			ld de, store_page + 2 
4c80					if DEBUG_FORTH_WORDS 
4c80						DMARK "BW1" 
4c80 f5				push af  
4c81 3a 95 4c			ld a, (.dmark)  
4c84 32 b4 fe			ld (debug_mark),a  
4c87 3a 96 4c			ld a, (.dmark+1)  
4c8a 32 b5 fe			ld (debug_mark+1),a  
4c8d 3a 97 4c			ld a, (.dmark+2)  
4c90 32 b6 fe			ld (debug_mark+2),a  
4c93 18 03			jr .pastdmark  
4c95 ..			.dmark: db "BW1"  
4c98 f1			.pastdmark: pop af  
4c99			endm  
# End of macro DMARK
4c99						CALLMONITOR 
4c99 cd c6 18			call break_point_state  
4c9c				endm  
# End of macro CALLMONITOR
4c9c					endif 
4c9c ed b0			ldir 
4c9e			 
4c9e			 
4c9e				; poke the start of the block with flags to prevent high level file ops hitting the block 
4c9e			 
4c9e 21 ff ff			ld hl, $ffff 
4ca1			 
4ca1 22 07 fc			ld (store_page), hl	 
4ca4				 
4ca4 e1				pop hl    ; get address 
4ca5 11 07 fc			ld de, store_page 
4ca8			 
4ca8					if DEBUG_FORTH_WORDS 
4ca8						DMARK "BW2" 
4ca8 f5				push af  
4ca9 3a bd 4c			ld a, (.dmark)  
4cac 32 b4 fe			ld (debug_mark),a  
4caf 3a be 4c			ld a, (.dmark+1)  
4cb2 32 b5 fe			ld (debug_mark+1),a  
4cb5 3a bf 4c			ld a, (.dmark+2)  
4cb8 32 b6 fe			ld (debug_mark+2),a  
4cbb 18 03			jr .pastdmark  
4cbd ..			.dmark: db "BW2"  
4cc0 f1			.pastdmark: pop af  
4cc1			endm  
# End of macro DMARK
4cc1						CALLMONITOR 
4cc1 cd c6 18			call break_point_state  
4cc4				endm  
# End of macro CALLMONITOR
4cc4					endif 
4cc4			 
4cc4 cd 7e 04			call storage_write_block 
4cc7			 
4cc7					NEXTW 
4cc7 c3 e0 22			jp macro_next 
4cca				endm 
# End of macro NEXTW
4cca			 
4cca			.BUPD: 
4cca				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4cca 3a				db WORD_SYS_CORE+38             
4ccb 20 4d			dw .BYID            
4ccd 05				db 4 + 1 
4cce .. 00			db "BUPD",0              
4cd3				endm 
# End of macro CWHEAD
4cd3			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to address u | DONE 
4cd3			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4cd3			; | | or completely different file system structure. 
4cd3			 
4cd3					if DEBUG_FORTH_WORDS_KEY 
4cd3						DMARK "BUD" 
4cd3 f5				push af  
4cd4 3a e8 4c			ld a, (.dmark)  
4cd7 32 b4 fe			ld (debug_mark),a  
4cda 3a e9 4c			ld a, (.dmark+1)  
4cdd 32 b5 fe			ld (debug_mark+1),a  
4ce0 3a ea 4c			ld a, (.dmark+2)  
4ce3 32 b6 fe			ld (debug_mark+2),a  
4ce6 18 03			jr .pastdmark  
4ce8 ..			.dmark: db "BUD"  
4ceb f1			.pastdmark: pop af  
4cec			endm  
# End of macro DMARK
4cec						CALLMONITOR 
4cec cd c6 18			call break_point_state  
4cef				endm  
# End of macro CALLMONITOR
4cef					endif 
4cef			 
4cef				FORTH_DSP_VALUEHL 
4cef cd 31 21			call macro_dsp_valuehl 
4cf2				endm 
# End of macro FORTH_DSP_VALUEHL
4cf2			 
4cf2				; calc block address 
4cf2			 
4cf2 eb				ex de, hl 
4cf3 3e 40			ld a, STORE_BLOCK_PHY 
4cf5 cd cc 0e			call Mult16 
4cf8			 
4cf8				FORTH_DSP_POP 
4cf8 cd e9 21			call macro_forth_dsp_pop 
4cfb				endm 
# End of macro FORTH_DSP_POP
4cfb			 
4cfb			 
4cfb 11 07 fc			ld de, store_page 
4cfe			 
4cfe					if DEBUG_FORTH_WORDS 
4cfe						DMARK "BUe" 
4cfe f5				push af  
4cff 3a 13 4d			ld a, (.dmark)  
4d02 32 b4 fe			ld (debug_mark),a  
4d05 3a 14 4d			ld a, (.dmark+1)  
4d08 32 b5 fe			ld (debug_mark+1),a  
4d0b 3a 15 4d			ld a, (.dmark+2)  
4d0e 32 b6 fe			ld (debug_mark+2),a  
4d11 18 03			jr .pastdmark  
4d13 ..			.dmark: db "BUe"  
4d16 f1			.pastdmark: pop af  
4d17			endm  
# End of macro DMARK
4d17						CALLMONITOR 
4d17 cd c6 18			call break_point_state  
4d1a				endm  
# End of macro CALLMONITOR
4d1a					endif 
4d1a			 
4d1a cd 7e 04			call storage_write_block 
4d1d			 
4d1d					NEXTW 
4d1d c3 e0 22			jp macro_next 
4d20				endm 
# End of macro NEXTW
4d20			 
4d20			.BYID: 
4d20			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4d20			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4d20			; 
4d20			;		 
4d20			;		if DEBUG_FORTH_WORDS_KEY 
4d20			;			DMARK "BYID" 
4d20			;			CALLMONITOR 
4d20			;		endif 
4d20			; 
4d20			;		; get direct address 
4d20			; 
4d20			;		FORTH_DSP_VALUEHL 
4d20			; 
4d20			;		FORTH_DSP_POP 
4d20			; 
4d20			;	; calc block address 
4d20			; 
4d20			;	ex de, hl 
4d20			;	ld a, STORE_BLOCK_PHY 
4d20			;	call Mult16 
4d20			;	;	do BREAD with number as param 
4d20			;	; push the file name	 
4d20			;	ld de, store_page 
4d20			;	call storage_read_block 
4d20			 ;       ld hl, store_page+2 
4d20			; 
4d20			; 
4d20			;		NEXTW 
4d20			;.BYNAME: 
4d20				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
4d20 3a				db WORD_SYS_CORE+38             
4d21 39 4d			dw .DIR            
4d23 06				db 5 + 1 
4d24 .. 00			db "GETID",0              
4d2a				endm 
# End of macro CWHEAD
4d2a			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
4d2a			 
4d2a					; get pointer to file name to seek 
4d2a			 
4d2a					FORTH_DSP_VALUEHL 
4d2a cd 31 21			call macro_dsp_valuehl 
4d2d				endm 
# End of macro FORTH_DSP_VALUEHL
4d2d			 
4d2d			 
4d2d cd 40 03				call storage_getid  
4d30			 
4d30					FORTH_DSP_POP 
4d30 cd e9 21			call macro_forth_dsp_pop 
4d33				endm 
# End of macro FORTH_DSP_POP
4d33			 
4d33 cd 3a 1f				call forth_push_numhl 
4d36			 
4d36					NEXTW 
4d36 c3 e0 22			jp macro_next 
4d39				endm 
# End of macro NEXTW
4d39			; 
4d39			.DIR: 
4d39				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4d39 3a				db WORD_SYS_CORE+38             
4d3a 3d 4e			dw .SAVE            
4d3c 04				db 3 + 1 
4d3d .. 00			db "DIR",0              
4d41				endm 
# End of macro CWHEAD
4d41			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4d41			 
4d41					if DEBUG_FORTH_WORDS_KEY 
4d41						DMARK "DIR" 
4d41 f5				push af  
4d42 3a 56 4d			ld a, (.dmark)  
4d45 32 b4 fe			ld (debug_mark),a  
4d48 3a 57 4d			ld a, (.dmark+1)  
4d4b 32 b5 fe			ld (debug_mark+1),a  
4d4e 3a 58 4d			ld a, (.dmark+2)  
4d51 32 b6 fe			ld (debug_mark+2),a  
4d54 18 03			jr .pastdmark  
4d56 ..			.dmark: db "DIR"  
4d59 f1			.pastdmark: pop af  
4d5a			endm  
# End of macro DMARK
4d5a						CALLMONITOR 
4d5a cd c6 18			call break_point_state  
4d5d				endm  
# End of macro CALLMONITOR
4d5d					endif 
4d5d cd ca 04			call storage_get_block_0 
4d60			 
4d60 21 07 fc			ld hl, store_page     ; get current id count 
4d63 46				ld b, (hl) 
4d64 0e 00			ld c, 0    ; count of files   
4d66					if DEBUG_FORTH_WORDS 
4d66						DMARK "DI1" 
4d66 f5				push af  
4d67 3a 7b 4d			ld a, (.dmark)  
4d6a 32 b4 fe			ld (debug_mark),a  
4d6d 3a 7c 4d			ld a, (.dmark+1)  
4d70 32 b5 fe			ld (debug_mark+1),a  
4d73 3a 7d 4d			ld a, (.dmark+2)  
4d76 32 b6 fe			ld (debug_mark+2),a  
4d79 18 03			jr .pastdmark  
4d7b ..			.dmark: db "DI1"  
4d7e f1			.pastdmark: pop af  
4d7f			endm  
# End of macro DMARK
4d7f						CALLMONITOR 
4d7f cd c6 18			call break_point_state  
4d82				endm  
# End of macro CALLMONITOR
4d82					endif 
4d82			 
4d82				; check for empty drive 
4d82			 
4d82 3e 00			ld a, 0 
4d84 b8				cp b 
4d85 ca f3 4d			jp z, .dirdone 
4d88			 
4d88				; for each of the current ids do a search for them and if found push to stack 
4d88			 
4d88 c5			.diritem:	push bc 
4d89 21 40 00				ld hl, STORE_BLOCK_PHY 
4d8c 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4d8e 58					ld e,b 
4d8f			 
4d8f			;		if DEBUG_FORTH_WORDS 
4d8f			;			DMARK "DI2" 
4d8f			;			CALLMONITOR 
4d8f			;		endif 
4d8f			 
4d8f cd 4c 07				call storage_findnextid 
4d92			 
4d92			;		if DEBUG_FORTH_WORDS 
4d92			;			DMARK "DI3" 
4d92			;			CALLMONITOR 
4d92			;		endif 
4d92			 
4d92					; if found hl will be non zero 
4d92			 
4d92 cd 72 0f				call ishlzero 
4d95			;		ld a, l 
4d95			;		add h 
4d95			; 
4d95			;		cp 0 
4d95 28 59				jr z, .dirnotfound 
4d97			 
4d97					; increase count 
4d97			 
4d97 c1					pop bc	 
4d98 0c					inc c 
4d99 c5					push bc 
4d9a					 
4d9a			 
4d9a					; get file header and push the file name 
4d9a			 
4d9a 11 07 fc				ld de, store_page 
4d9d cd 19 04				call storage_read_block 
4da0			 
4da0					; push file id to stack 
4da0				 
4da0 3a 07 fc				ld a, (store_page) 
4da3 26 00				ld h, 0 
4da5 6f					ld l, a 
4da6 cd 3a 1f				call forth_push_numhl 
4da9			 
4da9					; push extent count to stack  
4da9				 
4da9 3a 09 fc				ld a, (store_page+2) 
4dac 26 00				ld h, 0 
4dae 6f					ld l, a 
4daf cd 3a 1f				call forth_push_numhl 
4db2			 
4db2					; push file name 
4db2			 
4db2 21 0a fc				ld hl, store_page+3 
4db5					if DEBUG_FORTH_WORDS 
4db5						DMARK "DI5" 
4db5 f5				push af  
4db6 3a ca 4d			ld a, (.dmark)  
4db9 32 b4 fe			ld (debug_mark),a  
4dbc 3a cb 4d			ld a, (.dmark+1)  
4dbf 32 b5 fe			ld (debug_mark+1),a  
4dc2 3a cc 4d			ld a, (.dmark+2)  
4dc5 32 b6 fe			ld (debug_mark+2),a  
4dc8 18 03			jr .pastdmark  
4dca ..			.dmark: db "DI5"  
4dcd f1			.pastdmark: pop af  
4dce			endm  
# End of macro DMARK
4dce						CALLMONITOR 
4dce cd c6 18			call break_point_state  
4dd1				endm  
# End of macro CALLMONITOR
4dd1					endif 
4dd1 cd a8 1f				call forth_push_str 
4dd4					if DEBUG_FORTH_WORDS 
4dd4						DMARK "DI6" 
4dd4 f5				push af  
4dd5 3a e9 4d			ld a, (.dmark)  
4dd8 32 b4 fe			ld (debug_mark),a  
4ddb 3a ea 4d			ld a, (.dmark+1)  
4dde 32 b5 fe			ld (debug_mark+1),a  
4de1 3a eb 4d			ld a, (.dmark+2)  
4de4 32 b6 fe			ld (debug_mark+2),a  
4de7 18 03			jr .pastdmark  
4de9 ..			.dmark: db "DI6"  
4dec f1			.pastdmark: pop af  
4ded			endm  
# End of macro DMARK
4ded						CALLMONITOR 
4ded cd c6 18			call break_point_state  
4df0				endm  
# End of macro CALLMONITOR
4df0					endif 
4df0			.dirnotfound: 
4df0 c1					pop bc     
4df1 10 95				djnz .diritem 
4df3				 
4df3			.dirdone:	 
4df3					if DEBUG_FORTH_WORDS 
4df3						DMARK "DI7" 
4df3 f5				push af  
4df4 3a 08 4e			ld a, (.dmark)  
4df7 32 b4 fe			ld (debug_mark),a  
4dfa 3a 09 4e			ld a, (.dmark+1)  
4dfd 32 b5 fe			ld (debug_mark+1),a  
4e00 3a 0a 4e			ld a, (.dmark+2)  
4e03 32 b6 fe			ld (debug_mark+2),a  
4e06 18 03			jr .pastdmark  
4e08 ..			.dmark: db "DI7"  
4e0b f1			.pastdmark: pop af  
4e0c			endm  
# End of macro DMARK
4e0c						CALLMONITOR 
4e0c cd c6 18			call break_point_state  
4e0f				endm  
# End of macro CALLMONITOR
4e0f					endif 
4e0f			 
4e0f					; push a count of the dir items found 
4e0f			 
4e0f 26 00				ld h, 0 
4e11 69					ld l, c 
4e12 cd 3a 1f				call forth_push_numhl 
4e15			 
4e15					; push the bank label 
4e15			 
4e15 cd ca 04				call storage_get_block_0 
4e18			 
4e18				 
4e18 21 0a fc		 		ld hl, store_page+3 
4e1b			 
4e1b					if DEBUG_FORTH_WORDS 
4e1b						DMARK "DI8" 
4e1b f5				push af  
4e1c 3a 30 4e			ld a, (.dmark)  
4e1f 32 b4 fe			ld (debug_mark),a  
4e22 3a 31 4e			ld a, (.dmark+1)  
4e25 32 b5 fe			ld (debug_mark+1),a  
4e28 3a 32 4e			ld a, (.dmark+2)  
4e2b 32 b6 fe			ld (debug_mark+2),a  
4e2e 18 03			jr .pastdmark  
4e30 ..			.dmark: db "DI8"  
4e33 f1			.pastdmark: pop af  
4e34			endm  
# End of macro DMARK
4e34						CALLMONITOR 
4e34 cd c6 18			call break_point_state  
4e37				endm  
# End of macro CALLMONITOR
4e37					endif 
4e37 cd a8 1f				call forth_push_str 
4e3a			 
4e3a			 
4e3a				 
4e3a					NEXTW 
4e3a c3 e0 22			jp macro_next 
4e3d				endm 
# End of macro NEXTW
4e3d			.SAVE: 
4e3d			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4e3d			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4e3d			;		NEXTW 
4e3d			;.LOAD: 
4e3d			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4e3d			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4e3d			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4e3d			;; > > The LOAD command can not be used in any user words or compound lines. 
4e3d			; 
4e3d			;		; store_openext use it. If zero it is EOF 
4e3d			; 
4e3d			;		; read block from current stream id 
4e3d			;		; if the block does not contain zero term keep reading blocks until zero found 
4e3d			;		; push the block to stack 
4e3d			;		; save the block id to stream 
4e3d			; 
4e3d			; 
4e3d			;		FORTH_DSP_VALUEHL 
4e3d			; 
4e3d			;;		push hl 
4e3d			; 
4e3d			;	if DEBUG_STORESE 
4e3d			;		DMARK "LOA" 
4e3d			;		CALLMONITOR 
4e3d			;	endif 
4e3d			;		FORTH_DSP_POP 
4e3d			; 
4e3d			;;		pop hl 
4e3d			; 
4e3d			;		ld h, l 
4e3d			;		ld l, 0 
4e3d			; 
4e3d			;		push hl     ; stack holds current file id and extent to work with 
4e3d			; 
4e3d			; 
4e3d			;		ld de, store_page      ; get block zero of file 
4e3d			;	if DEBUG_STORESE 
4e3d			;		DMARK "LO0" 
4e3d			;		CALLMONITOR 
4e3d			;	endif 
4e3d			;		call storage_read 
4e3d			; 
4e3d			;		ld a, (store_page+2)    ; max extents for this file 
4e3d			;		ld  (store_openmaxext),a   ; get our limit 
4e3d			; 
4e3d			;	if DEBUG_STORESE 
4e3d			;		DMARK "LOE" 
4e3d			;		CALLMONITOR 
4e3d			;	endif 
4e3d			; 
4e3d			;; TODO dont know why max extents are not present 
4e3d			;;		cp 0 
4e3d			;;		jp z, .loadeof     ; dont read past eof 
4e3d			; 
4e3d			;;		ld a, 1   ; start from the head of the file 
4e3d			; 
4e3d			;.loadline:	pop hl 
4e3d			;		inc hl 
4e3d			;		ld  a, (store_openmaxext)   ; get our limit 
4e3d			;	if DEBUG_STORESE 
4e3d			;		DMARK "LOx" 
4e3d			;		CALLMONITOR 
4e3d			;	endif 
4e3d			;		inc a 
4e3d			;		cp l 
4e3d			;		jp z, .loadeof 
4e3d			;		push hl    ; save current extent 
4e3d			; 
4e3d			;		ld de, store_page 
4e3d			; 
4e3d			;	if DEBUG_STORESE 
4e3d			;		DMARK "LO1" 
4e3d			;		CALLMONITOR 
4e3d			;	endif 
4e3d			;		call storage_read 
4e3d			; 
4e3d			;	if DEBUG_STORESE 
4e3d			;		DMARK "LO2" 
4e3d			;		CALLMONITOR 
4e3d			;	endif 
4e3d			;	call ishlzero 
4e3d			;	ld a, l 
4e3d			;	add h 
4e3d			;	cp 0 
4e3d			;	jr z, .loadeof 
4e3d			; 
4e3d			;	; not eof so hl should point to data to exec 
4e3d			; 
4e3d			;	; will need to add the FORTH_END_BUFFER flag 
4e3d			 ; 
4e3d			;	ld hl, store_page+2 
4e3d			;	ld bc, 255 
4e3d			;	ld a, 0 
4e3d			;	cpir 
4e3d			;	if DEBUG_STORESE 
4e3d			;		DMARK "LOt" 
4e3d			;		CALLMONITOR 
4e3d			;	endif 
4e3d			;	dec hl 
4e3d			;	ld a, ' ' 
4e3d			;	ld (hl), a 
4e3d			;	inc hl 
4e3d			;	ld (hl), a 
4e3d			;	inc hl 
4e3d			;	ld (hl), a 
4e3d			;	inc hl 
4e3d			;	ld a, FORTH_END_BUFFER 
4e3d			;	ld (hl), a 
4e3d			; 
4e3d			;	; TODO handle more than a single block read 
4e3d			; 
4e3d			; 
4e3d			;	ld hl, store_page+2 
4e3d			; 
4e3d			;	ld (os_tok_ptr), hl 
4e3d			; 
4e3d			;	if DEBUG_STORESE 
4e3d			;		DMARK "LO3" 
4e3d			;		CALLMONITOR 
4e3d			;	endif 
4e3d			; 
4e3d			;	call forthparse 
4e3d			;	call forthexec 
4e3d			;	call forthexec_cleanup 
4e3d			; 
4e3d			;	; go to next extent 
4e3d			; 
4e3d			;	; get next block  or mark as eof 
4e3d			;	jp .loadline 
4e3d			; 
4e3d			; 
4e3d			; 
4e3d			;	       NEXTW 
4e3d			;.loadeof:	ld a, 0 
4e3d			;		ld (store_openext), a 
4e3d			; 
4e3d			;	if DEBUG_STORESE 
4e3d			;		DMARK "LOF" 
4e3d			;		CALLMONITOR 
4e3d			;	endif 
4e3d			;		ret 
4e3d			;		;NEXTW 
4e3d			;.BSAVE:   
4e3d			; 
4e3d			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4e3d			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4e3d			;		NEXTW 
4e3d			;.BLOAD: 
4e3d			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4e3d			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4e3d			;		NEXTW 
4e3d			;;;; counter gap 
4e3d			 
4e3d			 
4e3d			.SEO: 
4e3d				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4e3d 64				db WORD_SYS_CORE+80             
4e3e 5c 4e			dw .SEI            
4e40 04				db 3 + 1 
4e41 .. 00			db "SEO",0              
4e45				endm 
# End of macro CWHEAD
4e45			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4e45			 
4e45					; get port 
4e45			 
4e45					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e45 cd 31 21			call macro_dsp_valuehl 
4e48				endm 
# End of macro FORTH_DSP_VALUEHL
4e48			 
4e48 e5					push hl    ; u2 - byte 
4e49			 
4e49					; destroy value TOS 
4e49			 
4e49					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e49 cd e9 21			call macro_forth_dsp_pop 
4e4c				endm 
# End of macro FORTH_DSP_POP
4e4c			 
4e4c					; get byte to send 
4e4c			 
4e4c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e4c cd 31 21			call macro_dsp_valuehl 
4e4f				endm 
# End of macro FORTH_DSP_VALUEHL
4e4f			 
4e4f e5					push hl    ; u1 - addr 
4e50			 
4e50					; destroy value TOS 
4e50			 
4e50					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e50 cd e9 21			call macro_forth_dsp_pop 
4e53				endm 
# End of macro FORTH_DSP_POP
4e53			 
4e53					; one value on hl get other one back 
4e53			 
4e53 d1					pop de   ; u1 - byte 
4e54			 
4e54 e1					pop hl   ; u2 - addr 
4e55			 
4e55					; TODO Send SPI byte 
4e55			 
4e55			 
4e55 7b					ld a, e 
4e56 cd 1e 02				call se_writebyte 
4e59			 
4e59					 
4e59			 
4e59					NEXTW 
4e59 c3 e0 22			jp macro_next 
4e5c				endm 
# End of macro NEXTW
4e5c			 
4e5c			.SEI: 
4e5c				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4e5c 65				db WORD_SYS_CORE+81             
4e5d 76 4e			dw .SFREE            
4e5f 04				db 3 + 1 
4e60 .. 00			db "SEI",0              
4e64				endm 
# End of macro CWHEAD
4e64			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4e64			 
4e64					; get port 
4e64			 
4e64					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e64 cd 31 21			call macro_dsp_valuehl 
4e67				endm 
# End of macro FORTH_DSP_VALUEHL
4e67			 
4e67			;		push hl 
4e67			 
4e67					; destroy value TOS 
4e67			 
4e67					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e67 cd e9 21			call macro_forth_dsp_pop 
4e6a				endm 
# End of macro FORTH_DSP_POP
4e6a			 
4e6a					; one value on hl get other one back 
4e6a			 
4e6a			;		pop hl 
4e6a			 
4e6a			 
4e6a					; TODO Get SPI byte 
4e6a			 
4e6a cd c0 02				call se_readbyte 
4e6d			 
4e6d 26 00				ld h, 0 
4e6f 6f					ld l, a 
4e70 cd 3a 1f				call forth_push_numhl 
4e73			 
4e73					NEXTW 
4e73 c3 e0 22			jp macro_next 
4e76				endm 
# End of macro NEXTW
4e76			 
4e76			.SFREE: 
4e76				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4e76 67				db WORD_SYS_CORE+83             
4e77 a5 4e			dw .SIZE            
4e79 06				db 5 + 1 
4e7a .. 00			db "FFREE",0              
4e80				endm 
# End of macro CWHEAD
4e80			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4e80					if DEBUG_FORTH_WORDS_KEY 
4e80						DMARK "FFR" 
4e80 f5				push af  
4e81 3a 95 4e			ld a, (.dmark)  
4e84 32 b4 fe			ld (debug_mark),a  
4e87 3a 96 4e			ld a, (.dmark+1)  
4e8a 32 b5 fe			ld (debug_mark+1),a  
4e8d 3a 97 4e			ld a, (.dmark+2)  
4e90 32 b6 fe			ld (debug_mark+2),a  
4e93 18 03			jr .pastdmark  
4e95 ..			.dmark: db "FFR"  
4e98 f1			.pastdmark: pop af  
4e99			endm  
# End of macro DMARK
4e99						CALLMONITOR 
4e99 cd c6 18			call break_point_state  
4e9c				endm  
# End of macro CALLMONITOR
4e9c					endif 
4e9c			 
4e9c cd e6 07				call storage_freeblocks 
4e9f			 
4e9f cd 3a 1f				call forth_push_numhl 
4ea2			 
4ea2				       NEXTW 
4ea2 c3 e0 22			jp macro_next 
4ea5				endm 
# End of macro NEXTW
4ea5			.SIZE: 
4ea5				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4ea5 67				db WORD_SYS_CORE+83             
4ea6 d9 4e			dw .CREATE            
4ea8 05				db 4 + 1 
4ea9 .. 00			db "SIZE",0              
4eae				endm 
# End of macro CWHEAD
4eae			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4eae					if DEBUG_FORTH_WORDS_KEY 
4eae						DMARK "SIZ" 
4eae f5				push af  
4eaf 3a c3 4e			ld a, (.dmark)  
4eb2 32 b4 fe			ld (debug_mark),a  
4eb5 3a c4 4e			ld a, (.dmark+1)  
4eb8 32 b5 fe			ld (debug_mark+1),a  
4ebb 3a c5 4e			ld a, (.dmark+2)  
4ebe 32 b6 fe			ld (debug_mark+2),a  
4ec1 18 03			jr .pastdmark  
4ec3 ..			.dmark: db "SIZ"  
4ec6 f1			.pastdmark: pop af  
4ec7			endm  
# End of macro DMARK
4ec7						CALLMONITOR 
4ec7 cd c6 18			call break_point_state  
4eca				endm  
# End of macro CALLMONITOR
4eca					endif 
4eca			 
4eca					FORTH_DSP_VALUEHL 
4eca cd 31 21			call macro_dsp_valuehl 
4ecd				endm 
# End of macro FORTH_DSP_VALUEHL
4ecd			;		push hl 
4ecd					FORTH_DSP_POP 
4ecd cd e9 21			call macro_forth_dsp_pop 
4ed0				endm 
# End of macro FORTH_DSP_POP
4ed0			;		pop hl 
4ed0 cd 48 04				call storage_file_size 
4ed3			 
4ed3 cd 3a 1f				call forth_push_numhl 
4ed6			  
4ed6			 
4ed6				       NEXTW 
4ed6 c3 e0 22			jp macro_next 
4ed9				endm 
# End of macro NEXTW
4ed9			 
4ed9			.CREATE: 
4ed9				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4ed9 68				db WORD_SYS_CORE+84             
4eda 47 4f			dw .APPEND            
4edc 07				db 6 + 1 
4edd .. 00			db "CREATE",0              
4ee4				endm 
# End of macro CWHEAD
4ee4			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4ee4			; | | e.g.  
4ee4			; | | TestProgram CREATE 
4ee4			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4ee4			; | |  
4ee4			; | | Max file IDs are 255. 
4ee4			; | |  
4ee4					 
4ee4					if DEBUG_FORTH_WORDS_KEY 
4ee4						DMARK "CRT" 
4ee4 f5				push af  
4ee5 3a f9 4e			ld a, (.dmark)  
4ee8 32 b4 fe			ld (debug_mark),a  
4eeb 3a fa 4e			ld a, (.dmark+1)  
4eee 32 b5 fe			ld (debug_mark+1),a  
4ef1 3a fb 4e			ld a, (.dmark+2)  
4ef4 32 b6 fe			ld (debug_mark+2),a  
4ef7 18 03			jr .pastdmark  
4ef9 ..			.dmark: db "CRT"  
4efc f1			.pastdmark: pop af  
4efd			endm  
# End of macro DMARK
4efd						CALLMONITOR 
4efd cd c6 18			call break_point_state  
4f00				endm  
# End of macro CALLMONITOR
4f00					endif 
4f00			;		call storage_get_block_0 
4f00			 
4f00					; TODO pop hl 
4f00			 
4f00					;v5 FORTH_DSP_VALUE 
4f00					FORTH_DSP_VALUE 
4f00 cd 1a 21			call macro_forth_dsp_value 
4f03				endm 
# End of macro FORTH_DSP_VALUE
4f03			 
4f03				if DEBUG_STORESE 
4f03					DMARK "CR1" 
4f03 f5				push af  
4f04 3a 18 4f			ld a, (.dmark)  
4f07 32 b4 fe			ld (debug_mark),a  
4f0a 3a 19 4f			ld a, (.dmark+1)  
4f0d 32 b5 fe			ld (debug_mark+1),a  
4f10 3a 1a 4f			ld a, (.dmark+2)  
4f13 32 b6 fe			ld (debug_mark+2),a  
4f16 18 03			jr .pastdmark  
4f18 ..			.dmark: db "CR1"  
4f1b f1			.pastdmark: pop af  
4f1c			endm  
# End of macro DMARK
4f1c					CALLMONITOR 
4f1c cd c6 18			call break_point_state  
4f1f				endm  
# End of macro CALLMONITOR
4f1f				endif 
4f1f			;		push hl 
4f1f			;		FORTH_DSP_POP 
4f1f			;		pop hl 
4f1f			 
4f1f			;		inc hl   ; move past the type marker 
4f1f			 
4f1f cd 1c 08				call storage_create 
4f22			 
4f22				if DEBUG_STORESE 
4f22					DMARK "CT1" 
4f22 f5				push af  
4f23 3a 37 4f			ld a, (.dmark)  
4f26 32 b4 fe			ld (debug_mark),a  
4f29 3a 38 4f			ld a, (.dmark+1)  
4f2c 32 b5 fe			ld (debug_mark+1),a  
4f2f 3a 39 4f			ld a, (.dmark+2)  
4f32 32 b6 fe			ld (debug_mark+2),a  
4f35 18 03			jr .pastdmark  
4f37 ..			.dmark: db "CT1"  
4f3a f1			.pastdmark: pop af  
4f3b			endm  
# End of macro DMARK
4f3b					CALLMONITOR 
4f3b cd c6 18			call break_point_state  
4f3e				endm  
# End of macro CALLMONITOR
4f3e				endif 
4f3e			;		push hl 
4f3e					FORTH_DSP_POP 
4f3e cd e9 21			call macro_forth_dsp_pop 
4f41				endm 
# End of macro FORTH_DSP_POP
4f41			;		pop hl 
4f41					; push file id to stack 
4f41 cd 3a 1f				call forth_push_numhl 
4f44			 
4f44			 
4f44			 
4f44				       NEXTW 
4f44 c3 e0 22			jp macro_next 
4f47				endm 
# End of macro NEXTW
4f47			 
4f47			.APPEND: 
4f47				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4f47 69				db WORD_SYS_CORE+85             
4f48 d8 4f			dw .SDEL            
4f4a 07				db 6 + 1 
4f4b .. 00			db "APPEND",0              
4f52				endm 
# End of macro CWHEAD
4f52			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4f52			; | | e.g. 
4f52			; | | Test CREATE      -> $01 
4f52			; | | "A string to add to file" $01 APPEND 
4f52			; | |  
4f52			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4f52					if DEBUG_FORTH_WORDS_KEY 
4f52						DMARK "APP" 
4f52 f5				push af  
4f53 3a 67 4f			ld a, (.dmark)  
4f56 32 b4 fe			ld (debug_mark),a  
4f59 3a 68 4f			ld a, (.dmark+1)  
4f5c 32 b5 fe			ld (debug_mark+1),a  
4f5f 3a 69 4f			ld a, (.dmark+2)  
4f62 32 b6 fe			ld (debug_mark+2),a  
4f65 18 03			jr .pastdmark  
4f67 ..			.dmark: db "APP"  
4f6a f1			.pastdmark: pop af  
4f6b			endm  
# End of macro DMARK
4f6b						CALLMONITOR 
4f6b cd c6 18			call break_point_state  
4f6e				endm  
# End of macro CALLMONITOR
4f6e					endif 
4f6e			 
4f6e					FORTH_DSP_VALUEHL 
4f6e cd 31 21			call macro_dsp_valuehl 
4f71				endm 
# End of macro FORTH_DSP_VALUEHL
4f71 e5					push hl 	; save file id 
4f72			 
4f72				if DEBUG_STORESE 
4f72					DMARK "AP1" 
4f72 f5				push af  
4f73 3a 87 4f			ld a, (.dmark)  
4f76 32 b4 fe			ld (debug_mark),a  
4f79 3a 88 4f			ld a, (.dmark+1)  
4f7c 32 b5 fe			ld (debug_mark+1),a  
4f7f 3a 89 4f			ld a, (.dmark+2)  
4f82 32 b6 fe			ld (debug_mark+2),a  
4f85 18 03			jr .pastdmark  
4f87 ..			.dmark: db "AP1"  
4f8a f1			.pastdmark: pop af  
4f8b			endm  
# End of macro DMARK
4f8b					CALLMONITOR 
4f8b cd c6 18			call break_point_state  
4f8e				endm  
# End of macro CALLMONITOR
4f8e				endif 
4f8e					FORTH_DSP_POP 
4f8e cd e9 21			call macro_forth_dsp_pop 
4f91				endm 
# End of macro FORTH_DSP_POP
4f91			 
4f91					FORTH_DSP_VALUEHL 
4f91 cd 31 21			call macro_dsp_valuehl 
4f94				endm 
# End of macro FORTH_DSP_VALUEHL
4f94					;v5 FORTH_DSP_VALUE 
4f94 e5					push hl 	; save ptr to string to save 
4f95			 
4f95				if DEBUG_STORESE 
4f95					DMARK "AP1" 
4f95 f5				push af  
4f96 3a aa 4f			ld a, (.dmark)  
4f99 32 b4 fe			ld (debug_mark),a  
4f9c 3a ab 4f			ld a, (.dmark+1)  
4f9f 32 b5 fe			ld (debug_mark+1),a  
4fa2 3a ac 4f			ld a, (.dmark+2)  
4fa5 32 b6 fe			ld (debug_mark+2),a  
4fa8 18 03			jr .pastdmark  
4faa ..			.dmark: db "AP1"  
4fad f1			.pastdmark: pop af  
4fae			endm  
# End of macro DMARK
4fae					CALLMONITOR 
4fae cd c6 18			call break_point_state  
4fb1				endm  
# End of macro CALLMONITOR
4fb1				endif 
4fb1					FORTH_DSP_POP 
4fb1 cd e9 21			call macro_forth_dsp_pop 
4fb4				endm 
# End of macro FORTH_DSP_POP
4fb4			 
4fb4 d1					pop de 
4fb5 e1					pop hl 
4fb6				if DEBUG_STORESE 
4fb6					DMARK "AP2" 
4fb6 f5				push af  
4fb7 3a cb 4f			ld a, (.dmark)  
4fba 32 b4 fe			ld (debug_mark),a  
4fbd 3a cc 4f			ld a, (.dmark+1)  
4fc0 32 b5 fe			ld (debug_mark+1),a  
4fc3 3a cd 4f			ld a, (.dmark+2)  
4fc6 32 b6 fe			ld (debug_mark+2),a  
4fc9 18 03			jr .pastdmark  
4fcb ..			.dmark: db "AP2"  
4fce f1			.pastdmark: pop af  
4fcf			endm  
# End of macro DMARK
4fcf					CALLMONITOR 
4fcf cd c6 18			call break_point_state  
4fd2				endm  
# End of macro CALLMONITOR
4fd2				endif 
4fd2					;inc de ; skip var type indicator 
4fd2			 
4fd2					; TODO how to append numerics???? 
4fd2			 
4fd2 cd 09 0b				call storage_append		 
4fd5			 
4fd5				       NEXTW 
4fd5 c3 e0 22			jp macro_next 
4fd8				endm 
# End of macro NEXTW
4fd8			.SDEL: 
4fd8				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4fd8 6a				db WORD_SYS_CORE+86             
4fd9 24 50			dw .OPEN            
4fdb 05				db 4 + 1 
4fdc .. 00			db "ERA",0              
4fe0				endm 
# End of macro CWHEAD
4fe0			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4fe0					FORTH_DSP_VALUEHL 
4fe0 cd 31 21			call macro_dsp_valuehl 
4fe3				endm 
# End of macro FORTH_DSP_VALUEHL
4fe3			;		push hl 	; save file id 
4fe3			 
4fe3					if DEBUG_FORTH_WORDS_KEY 
4fe3						DMARK "ERA" 
4fe3 f5				push af  
4fe4 3a f8 4f			ld a, (.dmark)  
4fe7 32 b4 fe			ld (debug_mark),a  
4fea 3a f9 4f			ld a, (.dmark+1)  
4fed 32 b5 fe			ld (debug_mark+1),a  
4ff0 3a fa 4f			ld a, (.dmark+2)  
4ff3 32 b6 fe			ld (debug_mark+2),a  
4ff6 18 03			jr .pastdmark  
4ff8 ..			.dmark: db "ERA"  
4ffb f1			.pastdmark: pop af  
4ffc			endm  
# End of macro DMARK
4ffc						CALLMONITOR 
4ffc cd c6 18			call break_point_state  
4fff				endm  
# End of macro CALLMONITOR
4fff					endif 
4fff				if DEBUG_STORESE 
4fff					DMARK "ER1" 
4fff f5				push af  
5000 3a 14 50			ld a, (.dmark)  
5003 32 b4 fe			ld (debug_mark),a  
5006 3a 15 50			ld a, (.dmark+1)  
5009 32 b5 fe			ld (debug_mark+1),a  
500c 3a 16 50			ld a, (.dmark+2)  
500f 32 b6 fe			ld (debug_mark+2),a  
5012 18 03			jr .pastdmark  
5014 ..			.dmark: db "ER1"  
5017 f1			.pastdmark: pop af  
5018			endm  
# End of macro DMARK
5018					CALLMONITOR 
5018 cd c6 18			call break_point_state  
501b				endm  
# End of macro CALLMONITOR
501b				endif 
501b					FORTH_DSP_POP 
501b cd e9 21			call macro_forth_dsp_pop 
501e				endm 
# End of macro FORTH_DSP_POP
501e			 
501e			;		pop hl 
501e			 
501e cd 5b 06				call storage_erase 
5021				       NEXTW 
5021 c3 e0 22			jp macro_next 
5024				endm 
# End of macro NEXTW
5024			 
5024			.OPEN: 
5024				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
5024 6b				db WORD_SYS_CORE+87             
5025 b8 50			dw .READ            
5027 05				db 4 + 1 
5028 .. 00			db "OPEN",0              
502d				endm 
# End of macro CWHEAD
502d			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
502d			; | | e.g. 
502d			; | | $01 OPEN $01 DO $01 READ . LOOP 
502d			; | | 
502d			; | | Will return with 255 blocks if the file does not exist 
502d			 
502d					if DEBUG_FORTH_WORDS_KEY 
502d						DMARK "OPN" 
502d f5				push af  
502e 3a 42 50			ld a, (.dmark)  
5031 32 b4 fe			ld (debug_mark),a  
5034 3a 43 50			ld a, (.dmark+1)  
5037 32 b5 fe			ld (debug_mark+1),a  
503a 3a 44 50			ld a, (.dmark+2)  
503d 32 b6 fe			ld (debug_mark+2),a  
5040 18 03			jr .pastdmark  
5042 ..			.dmark: db "OPN"  
5045 f1			.pastdmark: pop af  
5046			endm  
# End of macro DMARK
5046						CALLMONITOR 
5046 cd c6 18			call break_point_state  
5049				endm  
# End of macro CALLMONITOR
5049					endif 
5049					; TODO handle multiple file opens 
5049			 
5049 3e 01			       	ld a, 1 
504b 32 f7 fb				ld (store_openext), a 
504e			 
504e					; get max extents for this file 
504e				 
504e								 
504e					FORTH_DSP_VALUEHL 
504e cd 31 21			call macro_dsp_valuehl 
5051				endm 
# End of macro FORTH_DSP_VALUEHL
5051			 
5051 65					ld h, l 
5052 2e 00				ld l, 0 
5054			 
5054					; store file id 
5054			 
5054 7c					ld a, h 
5055 32 f4 fb				ld (store_filecache), a 
5058			 
5058				if DEBUG_STORESE 
5058					DMARK "OPN" 
5058 f5				push af  
5059 3a 6d 50			ld a, (.dmark)  
505c 32 b4 fe			ld (debug_mark),a  
505f 3a 6e 50			ld a, (.dmark+1)  
5062 32 b5 fe			ld (debug_mark+1),a  
5065 3a 6f 50			ld a, (.dmark+2)  
5068 32 b6 fe			ld (debug_mark+2),a  
506b 18 03			jr .pastdmark  
506d ..			.dmark: db "OPN"  
5070 f1			.pastdmark: pop af  
5071			endm  
# End of macro DMARK
5071					CALLMONITOR 
5071 cd c6 18			call break_point_state  
5074				endm  
# End of macro CALLMONITOR
5074				endif 
5074			;		push hl 
5074					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5074 cd e9 21			call macro_forth_dsp_pop 
5077				endm 
# End of macro FORTH_DSP_POP
5077			;		pop hl 
5077						 
5077 11 07 fc				ld de, store_page      ; get block zero of file 
507a cd 72 09				call storage_read 
507d cd 72 0f			call ishlzero 
5080 20 04			jr nz, .opfound 
5082			 
5082				; file does not exist so indicate with 255 extents in use 
5082			 
5082 3e ff			ld a, 255 
5084 18 29			jr .skipopeneof 
5086			 
5086			 
5086			.opfound: 
5086			 
5086			 
5086 3a 09 fc				ld a, (store_page+2)    ; max extents for this file 
5089 32 f6 fb				ld  (store_openmaxext), a   ; get our limit and push 
508c					 
508c				if DEBUG_STORESE 
508c					DMARK "OPx" 
508c f5				push af  
508d 3a a1 50			ld a, (.dmark)  
5090 32 b4 fe			ld (debug_mark),a  
5093 3a a2 50			ld a, (.dmark+1)  
5096 32 b5 fe			ld (debug_mark+1),a  
5099 3a a3 50			ld a, (.dmark+2)  
509c 32 b6 fe			ld (debug_mark+2),a  
509f 18 03			jr .pastdmark  
50a1 ..			.dmark: db "OPx"  
50a4 f1			.pastdmark: pop af  
50a5			endm  
# End of macro DMARK
50a5					CALLMONITOR 
50a5 cd c6 18			call break_point_state  
50a8				endm  
# End of macro CALLMONITOR
50a8				endif 
50a8 fe 00				cp 0 
50aa 20 03				jr nz, .skipopeneof 
50ac					; have opened an empty file 
50ac					 
50ac 32 f7 fb				ld (store_openext), a 
50af			 
50af			.skipopeneof: 
50af			 
50af 6f					ld l, a 
50b0 26 00				ld h, 0 
50b2 cd 3a 1f				call forth_push_numhl 
50b5			 
50b5			 
50b5				       NEXTW 
50b5 c3 e0 22			jp macro_next 
50b8				endm 
# End of macro NEXTW
50b8			.READ: 
50b8				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
50b8 6c				db WORD_SYS_CORE+88             
50b9 e2 51			dw .EOF            
50bb 05				db 4 + 1 
50bc .. 00			db "READ",0              
50c1				endm 
# End of macro CWHEAD
50c1			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
50c1			; | | e.g. 
50c1			; | | $01 OPEN $01 DO READ . LOOP 
50c1			; | | 
50c1			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
50c1			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
50c1			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
50c1			; | | two bytes contain the file id and extent. 
50c1			; | |  
50c1			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
50c1			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
50c1			 
50c1					if DEBUG_FORTH_WORDS_KEY 
50c1						DMARK "REA" 
50c1 f5				push af  
50c2 3a d6 50			ld a, (.dmark)  
50c5 32 b4 fe			ld (debug_mark),a  
50c8 3a d7 50			ld a, (.dmark+1)  
50cb 32 b5 fe			ld (debug_mark+1),a  
50ce 3a d8 50			ld a, (.dmark+2)  
50d1 32 b6 fe			ld (debug_mark+2),a  
50d4 18 03			jr .pastdmark  
50d6 ..			.dmark: db "REA"  
50d9 f1			.pastdmark: pop af  
50da			endm  
# End of macro DMARK
50da						CALLMONITOR 
50da cd c6 18			call break_point_state  
50dd				endm  
# End of macro CALLMONITOR
50dd					endif 
50dd					; store_openext use it. If zero it is EOF 
50dd			 
50dd					; read block from current stream id 
50dd					; if the block does not contain zero term keep reading blocks until zero found 
50dd					; push the block to stack 
50dd					; save the block id to stream 
50dd			 
50dd			 
50dd cd 0f 52				call .testeof 
50e0 3e 01				ld a, 1 
50e2 bd					cp l 
50e3 ca be 51				jp z, .ateof 
50e6			 
50e6			 
50e6			;		FORTH_DSP_VALUEHL 
50e6			 
50e6			;		push hl 
50e6			 
50e6			;	if DEBUG_STORESE 
50e6			;		DMARK "REA" 
50e6			;		CALLMONITOR 
50e6			;	endif 
50e6			;		FORTH_DSP_POP 
50e6			 
50e6			;		pop hl 
50e6				 
50e6 3a f4 fb				ld a, (store_filecache) 
50e9 67					ld h,a 
50ea			 
50ea 3a f7 fb				ld a, (store_openext) 
50ed 6f					ld l, a 
50ee					 
50ee fe 00				cp 0 
50f0 ca be 51				jp z, .ateof     ; dont read past eof 
50f3			 
50f3 cd 55 0c				call storage_clear_page 
50f6			 
50f6 11 07 fc				ld de, store_page 
50f9				if DEBUG_STORESE 
50f9					DMARK "RE1" 
50f9 f5				push af  
50fa 3a 0e 51			ld a, (.dmark)  
50fd 32 b4 fe			ld (debug_mark),a  
5100 3a 0f 51			ld a, (.dmark+1)  
5103 32 b5 fe			ld (debug_mark+1),a  
5106 3a 10 51			ld a, (.dmark+2)  
5109 32 b6 fe			ld (debug_mark+2),a  
510c 18 03			jr .pastdmark  
510e ..			.dmark: db "RE1"  
5111 f1			.pastdmark: pop af  
5112			endm  
# End of macro DMARK
5112					CALLMONITOR 
5112 cd c6 18			call break_point_state  
5115				endm  
# End of macro CALLMONITOR
5115				endif 
5115 cd 72 09				call storage_read 
5118			 
5118				if DEBUG_STORESE 
5118					DMARK "RE2" 
5118 f5				push af  
5119 3a 2d 51			ld a, (.dmark)  
511c 32 b4 fe			ld (debug_mark),a  
511f 3a 2e 51			ld a, (.dmark+1)  
5122 32 b5 fe			ld (debug_mark+1),a  
5125 3a 2f 51			ld a, (.dmark+2)  
5128 32 b6 fe			ld (debug_mark+2),a  
512b 18 03			jr .pastdmark  
512d ..			.dmark: db "RE2"  
5130 f1			.pastdmark: pop af  
5131			endm  
# End of macro DMARK
5131					CALLMONITOR 
5131 cd c6 18			call break_point_state  
5134				endm  
# End of macro CALLMONITOR
5134				endif 
5134 cd 72 0f			call ishlzero 
5137			;	ld a, l 
5137			;	add h 
5137			;	cp 0 
5137 ca be 51			jp z, .readeof 
513a			 
513a				; not eof so hl should point to data to push to stack 
513a			 
513a				if DEBUG_STORESE 
513a					DMARK "RE3" 
513a f5				push af  
513b 3a 4f 51			ld a, (.dmark)  
513e 32 b4 fe			ld (debug_mark),a  
5141 3a 50 51			ld a, (.dmark+1)  
5144 32 b5 fe			ld (debug_mark+1),a  
5147 3a 51 51			ld a, (.dmark+2)  
514a 32 b6 fe			ld (debug_mark+2),a  
514d 18 03			jr .pastdmark  
514f ..			.dmark: db "RE3"  
5152 f1			.pastdmark: pop af  
5153			endm  
# End of macro DMARK
5153					CALLMONITOR 
5153 cd c6 18			call break_point_state  
5156				endm  
# End of macro CALLMONITOR
5156				endif 
5156 cd a8 1f			call forth_push_str 
5159			 
5159				if DEBUG_STORESE 
5159					DMARK "RE4" 
5159 f5				push af  
515a 3a 6e 51			ld a, (.dmark)  
515d 32 b4 fe			ld (debug_mark),a  
5160 3a 6f 51			ld a, (.dmark+1)  
5163 32 b5 fe			ld (debug_mark+1),a  
5166 3a 70 51			ld a, (.dmark+2)  
5169 32 b6 fe			ld (debug_mark+2),a  
516c 18 03			jr .pastdmark  
516e ..			.dmark: db "RE4"  
5171 f1			.pastdmark: pop af  
5172			endm  
# End of macro DMARK
5172					CALLMONITOR 
5172 cd c6 18			call break_point_state  
5175				endm  
# End of macro CALLMONITOR
5175				endif 
5175				; get next block  or mark as eof 
5175			 
5175 3a f6 fb			ld a, (store_openmaxext)   ; get our limit 
5178 4f				ld c, a	 
5179 3a f7 fb			ld a, (store_openext) 
517c			 
517c				if DEBUG_STORESE 
517c					DMARK "RE5" 
517c f5				push af  
517d 3a 91 51			ld a, (.dmark)  
5180 32 b4 fe			ld (debug_mark),a  
5183 3a 92 51			ld a, (.dmark+1)  
5186 32 b5 fe			ld (debug_mark+1),a  
5189 3a 93 51			ld a, (.dmark+2)  
518c 32 b6 fe			ld (debug_mark+2),a  
518f 18 03			jr .pastdmark  
5191 ..			.dmark: db "RE5"  
5194 f1			.pastdmark: pop af  
5195			endm  
# End of macro DMARK
5195					CALLMONITOR 
5195 cd c6 18			call break_point_state  
5198				endm  
# End of macro CALLMONITOR
5198				endif 
5198 b9				cp c 
5199 28 23			jr z, .readeof     ; at last extent 
519b			 
519b 3c					inc a 
519c 32 f7 fb				ld (store_openext), a 
519f			 
519f				if DEBUG_STORESE 
519f					DMARK "RE6" 
519f f5				push af  
51a0 3a b4 51			ld a, (.dmark)  
51a3 32 b4 fe			ld (debug_mark),a  
51a6 3a b5 51			ld a, (.dmark+1)  
51a9 32 b5 fe			ld (debug_mark+1),a  
51ac 3a b6 51			ld a, (.dmark+2)  
51af 32 b6 fe			ld (debug_mark+2),a  
51b2 18 03			jr .pastdmark  
51b4 ..			.dmark: db "RE6"  
51b7 f1			.pastdmark: pop af  
51b8			endm  
# End of macro DMARK
51b8					CALLMONITOR 
51b8 cd c6 18			call break_point_state  
51bb				endm  
# End of macro CALLMONITOR
51bb				endif 
51bb			 
51bb			 
51bb				       NEXTW 
51bb c3 e0 22			jp macro_next 
51be				endm 
# End of macro NEXTW
51be			.ateof: 
51be				;	ld hl, .showeof 
51be				;	call forth_push_str 
51be 3e 00		.readeof:	ld a, 0 
51c0 32 f7 fb				ld (store_openext), a 
51c3			 
51c3					 
51c3				if DEBUG_STORESE 
51c3					DMARK "REF" 
51c3 f5				push af  
51c4 3a d8 51			ld a, (.dmark)  
51c7 32 b4 fe			ld (debug_mark),a  
51ca 3a d9 51			ld a, (.dmark+1)  
51cd 32 b5 fe			ld (debug_mark+1),a  
51d0 3a da 51			ld a, (.dmark+2)  
51d3 32 b6 fe			ld (debug_mark+2),a  
51d6 18 03			jr .pastdmark  
51d8 ..			.dmark: db "REF"  
51db f1			.pastdmark: pop af  
51dc			endm  
# End of macro DMARK
51dc					CALLMONITOR 
51dc cd c6 18			call break_point_state  
51df				endm  
# End of macro CALLMONITOR
51df				endif 
51df				       NEXTW 
51df c3 e0 22			jp macro_next 
51e2				endm 
# End of macro NEXTW
51e2			 
51e2			;.showeof:   db "eof", 0 
51e2			 
51e2			 
51e2			.EOF: 
51e2				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
51e2 6d				db WORD_SYS_CORE+89             
51e3 24 52			dw .FORMAT            
51e5 04				db 3 + 1 
51e6 .. 00			db "EOF",0              
51ea				endm 
# End of macro CWHEAD
51ea			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
51ea			; | | e.g. 
51ea			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
51ea					; TODO if current block id for stream is zero then push true else false 
51ea			 
51ea					if DEBUG_FORTH_WORDS_KEY 
51ea						DMARK "EOF" 
51ea f5				push af  
51eb 3a ff 51			ld a, (.dmark)  
51ee 32 b4 fe			ld (debug_mark),a  
51f1 3a 00 52			ld a, (.dmark+1)  
51f4 32 b5 fe			ld (debug_mark+1),a  
51f7 3a 01 52			ld a, (.dmark+2)  
51fa 32 b6 fe			ld (debug_mark+2),a  
51fd 18 03			jr .pastdmark  
51ff ..			.dmark: db "EOF"  
5202 f1			.pastdmark: pop af  
5203			endm  
# End of macro DMARK
5203						CALLMONITOR 
5203 cd c6 18			call break_point_state  
5206				endm  
# End of macro CALLMONITOR
5206					endif 
5206			 
5206					; TODO handlue multiple file streams 
5206			 
5206			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
5206 cd 0f 52				call .testeof 
5209 cd 3a 1f				call forth_push_numhl 
520c			 
520c			 
520c				       NEXTW 
520c c3 e0 22			jp macro_next 
520f				endm 
# End of macro NEXTW
520f			 
520f			.testeof: 
520f 2e 01				ld l, 1 
5211 3a f6 fb				ld a, (store_openmaxext) 
5214 fe 00				cp 0 
5216 28 09				jr  z, .eofdone   ; empty file 
5218 3a f7 fb				ld a, (store_openext) 
521b fe 00				cp 0 
521d 28 02				jr  z, .eofdone 
521f 2e 00				ld l, 0 
5221 26 00		.eofdone:	ld h, 0 
5223 c9					ret 
5224			 
5224			 
5224			 
5224			 
5224			.FORMAT: 
5224				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5224 6d				db WORD_SYS_CORE+89             
5225 75 52			dw .LABEL            
5227 07				db 6 + 1 
5228 .. 00			db "FORMAT",0              
522f				endm 
# End of macro CWHEAD
522f			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
522f					; TODO if current block id for stream is zero then push true else false 
522f				 
522f				if DEBUG_STORESE 
522f					DMARK "FOR" 
522f f5				push af  
5230 3a 44 52			ld a, (.dmark)  
5233 32 b4 fe			ld (debug_mark),a  
5236 3a 45 52			ld a, (.dmark+1)  
5239 32 b5 fe			ld (debug_mark+1),a  
523c 3a 46 52			ld a, (.dmark+2)  
523f 32 b6 fe			ld (debug_mark+2),a  
5242 18 03			jr .pastdmark  
5244 ..			.dmark: db "FOR"  
5247 f1			.pastdmark: pop af  
5248			endm  
# End of macro DMARK
5248					CALLMONITOR 
5248 cd c6 18			call break_point_state  
524b				endm  
# End of macro CALLMONITOR
524b				endif 
524b					; Wipes the bank check flags to cause a reformat on next block 0 read 
524b			 
524b 21 01 00				ld hl, 1 
524e 3e 00				ld a, 0 
5250 cd 1e 02				call se_writebyte 
5253			 
5253				if DEBUG_STORESE 
5253					DMARK "FO0" 
5253 f5				push af  
5254 3a 68 52			ld a, (.dmark)  
5257 32 b4 fe			ld (debug_mark),a  
525a 3a 69 52			ld a, (.dmark+1)  
525d 32 b5 fe			ld (debug_mark+1),a  
5260 3a 6a 52			ld a, (.dmark+2)  
5263 32 b6 fe			ld (debug_mark+2),a  
5266 18 03			jr .pastdmark  
5268 ..			.dmark: db "FO0"  
526b f1			.pastdmark: pop af  
526c			endm  
# End of macro DMARK
526c					CALLMONITOR 
526c cd c6 18			call break_point_state  
526f				endm  
# End of macro CALLMONITOR
526f				endif 
526f					; force bank init 
526f			 
526f cd ca 04				call storage_get_block_0 
5272					 
5272				       NEXTW 
5272 c3 e0 22			jp macro_next 
5275				endm 
# End of macro NEXTW
5275			.LABEL: 
5275				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5275 6d				db WORD_SYS_CORE+89             
5276 c3 52			dw .STOREPAGE            
5278 06				db 5 + 1 
5279 .. 00			db "LABEL",0              
527f				endm 
# End of macro CWHEAD
527f			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
527f					; TODO test to see if bank is selected 
527f				 
527f					if DEBUG_FORTH_WORDS_KEY 
527f						DMARK "LBL" 
527f f5				push af  
5280 3a 94 52			ld a, (.dmark)  
5283 32 b4 fe			ld (debug_mark),a  
5286 3a 95 52			ld a, (.dmark+1)  
5289 32 b5 fe			ld (debug_mark+1),a  
528c 3a 96 52			ld a, (.dmark+2)  
528f 32 b6 fe			ld (debug_mark+2),a  
5292 18 03			jr .pastdmark  
5294 ..			.dmark: db "LBL"  
5297 f1			.pastdmark: pop af  
5298			endm  
# End of macro DMARK
5298						CALLMONITOR 
5298 cd c6 18			call break_point_state  
529b				endm  
# End of macro CALLMONITOR
529b					endif 
529b			;	if DEBUG_STORESE 
529b			;		DMARK "LBL" 
529b			;		CALLMONITOR 
529b			;	endif 
529b					FORTH_DSP_VALUEHL 
529b cd 31 21			call macro_dsp_valuehl 
529e				endm 
# End of macro FORTH_DSP_VALUEHL
529e					;v5FORTH_DSP_VALUE 
529e					 
529e			;		push hl 
529e					FORTH_DSP_POP 
529e cd e9 21			call macro_forth_dsp_pop 
52a1				endm 
# End of macro FORTH_DSP_POP
52a1			;		pop hl 
52a1			 
52a1			;v5		inc hl   ; move past the type marker 
52a1			 
52a1				if DEBUG_STORESE 
52a1					DMARK "LBl" 
52a1 f5				push af  
52a2 3a b6 52			ld a, (.dmark)  
52a5 32 b4 fe			ld (debug_mark),a  
52a8 3a b7 52			ld a, (.dmark+1)  
52ab 32 b5 fe			ld (debug_mark+1),a  
52ae 3a b8 52			ld a, (.dmark+2)  
52b1 32 b6 fe			ld (debug_mark+2),a  
52b4 18 03			jr .pastdmark  
52b6 ..			.dmark: db "LBl"  
52b9 f1			.pastdmark: pop af  
52ba			endm  
# End of macro DMARK
52ba					CALLMONITOR 
52ba cd c6 18			call break_point_state  
52bd				endm  
# End of macro CALLMONITOR
52bd				endif 
52bd cd ee 05				call storage_label 
52c0			 
52c0				       NEXTW 
52c0 c3 e0 22			jp macro_next 
52c3				endm 
# End of macro NEXTW
52c3			.STOREPAGE: 
52c3				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
52c3 6d				db WORD_SYS_CORE+89             
52c4 f6 52			dw .LABELS            
52c6 0a				db 9 + 1 
52c7 .. 00			db "STOREPAGE",0              
52d1				endm 
# End of macro CWHEAD
52d1			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
52d1					; TODO test to see if bank is selected 
52d1				 
52d1					if DEBUG_FORTH_WORDS_KEY 
52d1						DMARK "STP" 
52d1 f5				push af  
52d2 3a e6 52			ld a, (.dmark)  
52d5 32 b4 fe			ld (debug_mark),a  
52d8 3a e7 52			ld a, (.dmark+1)  
52db 32 b5 fe			ld (debug_mark+1),a  
52de 3a e8 52			ld a, (.dmark+2)  
52e1 32 b6 fe			ld (debug_mark+2),a  
52e4 18 03			jr .pastdmark  
52e6 ..			.dmark: db "STP"  
52e9 f1			.pastdmark: pop af  
52ea			endm  
# End of macro DMARK
52ea						CALLMONITOR 
52ea cd c6 18			call break_point_state  
52ed				endm  
# End of macro CALLMONITOR
52ed					endif 
52ed			;	if DEBUG_STORESE 
52ed			;		DMARK "STP" 
52ed			;		CALLMONITOR 
52ed			;	endif 
52ed			 
52ed 21 07 fc			ld hl, store_page 
52f0 cd 3a 1f			call forth_push_numhl 
52f3			 
52f3			 
52f3				       NEXTW 
52f3 c3 e0 22			jp macro_next 
52f6				endm 
# End of macro NEXTW
52f6			.LABELS: 
52f6				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
52f6 6d				db WORD_SYS_CORE+89             
52f7 80 53			dw .SCONST1            
52f9 07				db 6 + 1 
52fa .. 00			db "LABELS",0              
5301				endm 
# End of macro CWHEAD
5301			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
5301					;  
5301			 
5301					; save the current device selected to restore afterwards 
5301				 
5301 3a ed fb				ld a, (spi_device) 
5304 f5					push af 
5305			 
5305			 
5305					; run through each of the banks 
5305			 
5305 21 01 00				ld hl, 1 
5308 cd 3a 1f				call forth_push_numhl 
530b 3e ff				ld a, SPI_CE_HIGH 
530d cb 87				res SPI_CE0, a 
530f 32 ed fb				ld (spi_device), a 
5312 cd ca 04				call storage_get_block_0 
5315 21 0a fc				ld hl, store_page+3 
5318 cd a8 1f				call forth_push_str 
531b			 
531b					 
531b 21 02 00				ld hl, 2 
531e cd 3a 1f				call forth_push_numhl 
5321 3e ff				ld a, SPI_CE_HIGH 
5323 cb 8f				res SPI_CE1, a 
5325 32 ed fb				ld (spi_device), a 
5328 cd ca 04				call storage_get_block_0 
532b 21 0a fc				ld hl, store_page+3 
532e cd a8 1f				call forth_push_str 
5331			 
5331					 
5331 21 03 00				ld hl, 3 
5334 cd 3a 1f				call forth_push_numhl 
5337 3e ff				ld a, SPI_CE_HIGH 
5339 cb 97				res SPI_CE2, a 
533b 32 ed fb				ld (spi_device), a 
533e cd ca 04				call storage_get_block_0 
5341 21 0a fc				ld hl, store_page+3 
5344 cd a8 1f				call forth_push_str 
5347			 
5347			 
5347 21 04 00				ld hl, 4 
534a cd 3a 1f				call forth_push_numhl 
534d 3e ff				ld a, SPI_CE_HIGH 
534f cb 9f				res SPI_CE3, a 
5351 32 ed fb				ld (spi_device), a 
5354 cd ca 04				call storage_get_block_0 
5357 21 0a fc				ld hl, store_page+3 
535a cd a8 1f				call forth_push_str 
535d			 
535d					 
535d			 
535d 21 05 00				ld hl, 5 
5360 cd 3a 1f				call forth_push_numhl 
5363 3e ff				ld a, SPI_CE_HIGH 
5365 cb a7				res SPI_CE4, a 
5367 32 ed fb				ld (spi_device), a 
536a cd ca 04				call storage_get_block_0 
536d 21 0a fc				ld hl, store_page+3 
5370 cd a8 1f				call forth_push_str 
5373			 
5373					 
5373					; push fixed count of storage devices (on board) for now 
5373			 
5373 21 05 00				ld hl, 5 
5376 cd 3a 1f				call forth_push_numhl 
5379			 
5379					; restore selected device  
5379				 
5379 f1					pop af 
537a 32 ed fb				ld (spi_device), a 
537d			 
537d				       NEXTW 
537d c3 e0 22			jp macro_next 
5380				endm 
# End of macro NEXTW
5380			 
5380			.SCONST1: 
5380				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5380 6d				db WORD_SYS_CORE+89             
5381 97 53			dw .SCONST2            
5383 07				db 6 + 1 
5384 .. 00			db "FILEID",0              
538b				endm 
# End of macro CWHEAD
538b			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
538b 3a f4 fb				ld a, (store_filecache) 
538e 26 00				ld h, 0 
5390 6f					ld l, a 
5391 cd 3a 1f				call forth_push_numhl 
5394					NEXTW 
5394 c3 e0 22			jp macro_next 
5397				endm 
# End of macro NEXTW
5397			.SCONST2: 
5397				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5397 6d				db WORD_SYS_CORE+89             
5398 af 53			dw .SCONST3            
539a 08				db 7 + 1 
539b .. 00			db "FILEEXT",0              
53a3				endm 
# End of macro CWHEAD
53a3			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
53a3 3a f7 fb				ld a, (store_openext) 
53a6 26 00				ld h, 0 
53a8 6f					ld l, a 
53a9 cd 3a 1f				call forth_push_numhl 
53ac					NEXTW 
53ac c3 e0 22			jp macro_next 
53af				endm 
# End of macro NEXTW
53af			.SCONST3: 
53af				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
53af 6d				db WORD_SYS_CORE+89             
53b0 c7 53			dw .SCONST4            
53b2 08				db 7 + 1 
53b3 .. 00			db "FILEMAX",0              
53bb				endm 
# End of macro CWHEAD
53bb			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
53bb 3a f6 fb				ld a, (store_openmaxext) 
53be 26 00				ld h, 0 
53c0 6f					ld l, a 
53c1 cd 3a 1f				call forth_push_numhl 
53c4					NEXTW 
53c4 c3 e0 22			jp macro_next 
53c7				endm 
# End of macro NEXTW
53c7			.SCONST4: 
53c7				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
53c7 6d				db WORD_SYS_CORE+89             
53c8 dd 53			dw .SCONST5            
53ca 09				db 8 + 1 
53cb .. 00			db "FILEADDR",0              
53d4				endm 
# End of macro CWHEAD
53d4			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
53d4 2a f8 fb				ld hl, (store_openaddr) 
53d7 cd 3a 1f				call forth_push_numhl 
53da					NEXTW 
53da c3 e0 22			jp macro_next 
53dd				endm 
# End of macro NEXTW
53dd			.SCONST5: 
53dd				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
53dd 6d				db WORD_SYS_CORE+89             
53de f6 53			dw .ENDSTORAGE            
53e0 09				db 8 + 1 
53e1 .. 00			db "READCONT",0              
53ea				endm 
# End of macro CWHEAD
53ea			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
53ea			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
53ea			; | | a further read should, if applicable, be CONCAT to the previous read. 
53ea 3a fa fb				ld a, (store_readcont) 
53ed 26 00				ld h, 0 
53ef 6f					ld l, a 
53f0 cd 3a 1f				call forth_push_numhl 
53f3					NEXTW 
53f3 c3 e0 22			jp macro_next 
53f6				endm 
# End of macro NEXTW
53f6			.ENDSTORAGE: 
53f6			; eof 
# End of file forth_words_storage.asm
53f6			endif 
53f6				include "forth_words_device.asm" 
53f6			; Device related words 
53f6			 
53f6			; | ## Device Words 
53f6			 
53f6			if SOUND_ENABLE 
53f6			.NOTE: 
53f6				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
53f6			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
53f6					if DEBUG_FORTH_WORDS_KEY 
53f6						DMARK "NTE" 
53f6						CALLMONITOR 
53f6					endif 
53f6			 
53f6				 
53f6			 
53f6					NEXTW 
53f6			.AFTERSOUND: 
53f6			endif 
53f6			 
53f6			 
53f6			USE_GPIO: equ 0 
53f6			 
53f6			if USE_GPIO 
53f6			.GP1: 
53f6				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
53f6			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
53f6					NEXTW 
53f6			.GP2: 
53f6				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
53f6			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
53f6			 
53f6					NEXTW 
53f6			 
53f6			.GP3: 
53f6				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
53f6			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
53f6			 
53f6					NEXTW 
53f6			 
53f6			.GP4: 
53f6				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
53f6			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
53f6			 
53f6					NEXTW 
53f6			.SIN: 
53f6			 
53f6			 
53f6			endif 
53f6			 
53f6			 
53f6				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
53f6 33				db WORD_SYS_CORE+31             
53f7 2b 54			dw .SOUT            
53f9 03				db 2 + 1 
53fa .. 00			db "IN",0              
53fd				endm 
# End of macro CWHEAD
53fd			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
53fd					if DEBUG_FORTH_WORDS_KEY 
53fd						DMARK "IN." 
53fd f5				push af  
53fe 3a 12 54			ld a, (.dmark)  
5401 32 b4 fe			ld (debug_mark),a  
5404 3a 13 54			ld a, (.dmark+1)  
5407 32 b5 fe			ld (debug_mark+1),a  
540a 3a 14 54			ld a, (.dmark+2)  
540d 32 b6 fe			ld (debug_mark+2),a  
5410 18 03			jr .pastdmark  
5412 ..			.dmark: db "IN."  
5415 f1			.pastdmark: pop af  
5416			endm  
# End of macro DMARK
5416						CALLMONITOR 
5416 cd c6 18			call break_point_state  
5419				endm  
# End of macro CALLMONITOR
5419					endif 
5419					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5419 cd 31 21			call macro_dsp_valuehl 
541c				endm 
# End of macro FORTH_DSP_VALUEHL
541c			 
541c e5					push hl 
541d			 
541d					; destroy value TOS 
541d			 
541d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
541d cd e9 21			call macro_forth_dsp_pop 
5420				endm 
# End of macro FORTH_DSP_POP
5420			 
5420					; one value on hl get other one back 
5420			 
5420 c1					pop bc 
5421			 
5421					; do the sub 
5421			;		ex de, hl 
5421			 
5421 ed 68				in l,(c) 
5423			 
5423					; save it 
5423			 
5423 26 00				ld h,0 
5425			 
5425					; TODO push value back onto stack for another op etc 
5425			 
5425 cd 3a 1f				call forth_push_numhl 
5428					NEXTW 
5428 c3 e0 22			jp macro_next 
542b				endm 
# End of macro NEXTW
542b			.SOUT: 
542b				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
542b 34				db WORD_SYS_CORE+32             
542c 7e 54			dw .SPIO            
542e 04				db 3 + 1 
542f .. 00			db "OUT",0              
5433				endm 
# End of macro CWHEAD
5433			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5433					if DEBUG_FORTH_WORDS_KEY 
5433						DMARK "OUT" 
5433 f5				push af  
5434 3a 48 54			ld a, (.dmark)  
5437 32 b4 fe			ld (debug_mark),a  
543a 3a 49 54			ld a, (.dmark+1)  
543d 32 b5 fe			ld (debug_mark+1),a  
5440 3a 4a 54			ld a, (.dmark+2)  
5443 32 b6 fe			ld (debug_mark+2),a  
5446 18 03			jr .pastdmark  
5448 ..			.dmark: db "OUT"  
544b f1			.pastdmark: pop af  
544c			endm  
# End of macro DMARK
544c						CALLMONITOR 
544c cd c6 18			call break_point_state  
544f				endm  
# End of macro CALLMONITOR
544f					endif 
544f			 
544f					; get port 
544f			 
544f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
544f cd 31 21			call macro_dsp_valuehl 
5452				endm 
# End of macro FORTH_DSP_VALUEHL
5452			 
5452 e5					push hl 
5453			 
5453					; destroy value TOS 
5453			 
5453					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5453 cd e9 21			call macro_forth_dsp_pop 
5456				endm 
# End of macro FORTH_DSP_POP
5456			 
5456					; get byte to send 
5456			 
5456					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5456 cd 31 21			call macro_dsp_valuehl 
5459				endm 
# End of macro FORTH_DSP_VALUEHL
5459			 
5459			;		push hl 
5459			 
5459					; destroy value TOS 
5459			 
5459					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5459 cd e9 21			call macro_forth_dsp_pop 
545c				endm 
# End of macro FORTH_DSP_POP
545c			 
545c					; one value on hl get other one back 
545c			 
545c			;		pop hl 
545c			 
545c c1					pop bc 
545d			 
545d					if DEBUG_FORTH_WORDS 
545d						DMARK "OUT" 
545d f5				push af  
545e 3a 72 54			ld a, (.dmark)  
5461 32 b4 fe			ld (debug_mark),a  
5464 3a 73 54			ld a, (.dmark+1)  
5467 32 b5 fe			ld (debug_mark+1),a  
546a 3a 74 54			ld a, (.dmark+2)  
546d 32 b6 fe			ld (debug_mark+2),a  
5470 18 03			jr .pastdmark  
5472 ..			.dmark: db "OUT"  
5475 f1			.pastdmark: pop af  
5476			endm  
# End of macro DMARK
5476						CALLMONITOR 
5476 cd c6 18			call break_point_state  
5479				endm  
# End of macro CALLMONITOR
5479					endif 
5479			 
5479 ed 69				out (c), l 
547b			 
547b					NEXTW 
547b c3 e0 22			jp macro_next 
547e				endm 
# End of macro NEXTW
547e			 
547e			 
547e			.SPIO: 
547e			 
547e			if STORAGE_SE 
547e				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
547e 51				db WORD_SYS_CORE+61             
547f 8f 54			dw .SPICEH            
5481 07				db 6 + 1 
5482 .. 00			db "SPICEL",0              
5489				endm 
# End of macro CWHEAD
5489			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5489			 
5489 cd c7 01				call spi_ce_low 
548c			    NEXTW 
548c c3 e0 22			jp macro_next 
548f				endm 
# End of macro NEXTW
548f			 
548f			.SPICEH: 
548f				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
548f 51				db WORD_SYS_CORE+61             
5490 a0 54			dw .SPIOb            
5492 07				db 6 + 1 
5493 .. 00			db "SPICEH",0              
549a				endm 
# End of macro CWHEAD
549a			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
549a			 
549a cd b6 01				call spi_ce_high 
549d			    NEXTW 
549d c3 e0 22			jp macro_next 
54a0				endm 
# End of macro NEXTW
54a0			 
54a0			 
54a0			.SPIOb: 
54a0			 
54a0				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
54a0 51				db WORD_SYS_CORE+61             
54a1 d2 54			dw .SPII            
54a3 05				db 4 + 1 
54a4 .. 00			db "SPIO",0              
54a9				endm 
# End of macro CWHEAD
54a9			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
54a9			 
54a9					if DEBUG_FORTH_WORDS_KEY 
54a9						DMARK "SPo" 
54a9 f5				push af  
54aa 3a be 54			ld a, (.dmark)  
54ad 32 b4 fe			ld (debug_mark),a  
54b0 3a bf 54			ld a, (.dmark+1)  
54b3 32 b5 fe			ld (debug_mark+1),a  
54b6 3a c0 54			ld a, (.dmark+2)  
54b9 32 b6 fe			ld (debug_mark+2),a  
54bc 18 03			jr .pastdmark  
54be ..			.dmark: db "SPo"  
54c1 f1			.pastdmark: pop af  
54c2			endm  
# End of macro DMARK
54c2						CALLMONITOR 
54c2 cd c6 18			call break_point_state  
54c5				endm  
# End of macro CALLMONITOR
54c5					endif 
54c5					; get port 
54c5			 
54c5			 
54c5					; get byte to send 
54c5			 
54c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
54c5 cd 31 21			call macro_dsp_valuehl 
54c8				endm 
# End of macro FORTH_DSP_VALUEHL
54c8			 
54c8			;		push hl    ; u1  
54c8			 
54c8					; destroy value TOS 
54c8			 
54c8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
54c8 cd e9 21			call macro_forth_dsp_pop 
54cb				endm 
# End of macro FORTH_DSP_POP
54cb			 
54cb					; one value on hl get other one back 
54cb			 
54cb			;		pop hl   ; u2 - addr 
54cb			 
54cb					; TODO Send SPI byte 
54cb			 
54cb			;		push hl 
54cb			;		call spi_ce_low 
54cb			;		pop hl 
54cb 7d					ld a, l 
54cc cd b5 00				call spi_send_byte 
54cf			;		call spi_ce_high 
54cf			 
54cf					NEXTW 
54cf c3 e0 22			jp macro_next 
54d2				endm 
# End of macro NEXTW
54d2			 
54d2			.SPII: 
54d2				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
54d2 52				db WORD_SYS_CORE+62             
54d3 3b 55			dw .SESEL            
54d5 06				db 5 + 1 
54d6 .. 00			db "SPII",0              
54db				endm 
# End of macro CWHEAD
54db			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
54db					if DEBUG_FORTH_WORDS_KEY 
54db						DMARK "SPi" 
54db f5				push af  
54dc 3a f0 54			ld a, (.dmark)  
54df 32 b4 fe			ld (debug_mark),a  
54e2 3a f1 54			ld a, (.dmark+1)  
54e5 32 b5 fe			ld (debug_mark+1),a  
54e8 3a f2 54			ld a, (.dmark+2)  
54eb 32 b6 fe			ld (debug_mark+2),a  
54ee 18 03			jr .pastdmark  
54f0 ..			.dmark: db "SPi"  
54f3 f1			.pastdmark: pop af  
54f4			endm  
# End of macro DMARK
54f4						CALLMONITOR 
54f4 cd c6 18			call break_point_state  
54f7				endm  
# End of macro CALLMONITOR
54f7					endif 
54f7			 
54f7					; TODO Get SPI byte 
54f7			 
54f7 cd dc 00				call spi_read_byte 
54fa			 
54fa					if DEBUG_FORTH_WORDS 
54fa						DMARK "Si2" 
54fa f5				push af  
54fb 3a 0f 55			ld a, (.dmark)  
54fe 32 b4 fe			ld (debug_mark),a  
5501 3a 10 55			ld a, (.dmark+1)  
5504 32 b5 fe			ld (debug_mark+1),a  
5507 3a 11 55			ld a, (.dmark+2)  
550a 32 b6 fe			ld (debug_mark+2),a  
550d 18 03			jr .pastdmark  
550f ..			.dmark: db "Si2"  
5512 f1			.pastdmark: pop af  
5513			endm  
# End of macro DMARK
5513						CALLMONITOR 
5513 cd c6 18			call break_point_state  
5516				endm  
# End of macro CALLMONITOR
5516					endif 
5516 26 00				ld h, 0 
5518 6f					ld l, a 
5519					if DEBUG_FORTH_WORDS 
5519						DMARK "Si3" 
5519 f5				push af  
551a 3a 2e 55			ld a, (.dmark)  
551d 32 b4 fe			ld (debug_mark),a  
5520 3a 2f 55			ld a, (.dmark+1)  
5523 32 b5 fe			ld (debug_mark+1),a  
5526 3a 30 55			ld a, (.dmark+2)  
5529 32 b6 fe			ld (debug_mark+2),a  
552c 18 03			jr .pastdmark  
552e ..			.dmark: db "Si3"  
5531 f1			.pastdmark: pop af  
5532			endm  
# End of macro DMARK
5532						CALLMONITOR 
5532 cd c6 18			call break_point_state  
5535				endm  
# End of macro CALLMONITOR
5535					endif 
5535 cd 3a 1f				call forth_push_numhl 
5538			 
5538					NEXTW 
5538 c3 e0 22			jp macro_next 
553b				endm 
# End of macro NEXTW
553b			 
553b			 
553b			 
553b			.SESEL: 
553b				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
553b 66				db WORD_SYS_CORE+82             
553c e4 55			dw .CARTDEV            
553e 05				db 4 + 1 
553f .. 00			db "BANK",0              
5544				endm 
# End of macro CWHEAD
5544			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5544					if DEBUG_FORTH_WORDS_KEY 
5544						DMARK "BNK" 
5544 f5				push af  
5545 3a 59 55			ld a, (.dmark)  
5548 32 b4 fe			ld (debug_mark),a  
554b 3a 5a 55			ld a, (.dmark+1)  
554e 32 b5 fe			ld (debug_mark+1),a  
5551 3a 5b 55			ld a, (.dmark+2)  
5554 32 b6 fe			ld (debug_mark+2),a  
5557 18 03			jr .pastdmark  
5559 ..			.dmark: db "BNK"  
555c f1			.pastdmark: pop af  
555d			endm  
# End of macro DMARK
555d						CALLMONITOR 
555d cd c6 18			call break_point_state  
5560				endm  
# End of macro CALLMONITOR
5560					endif 
5560			 
5560 3e ff				ld a, 255 
5562 32 f0 fb				ld (spi_cartdev), a 
5565			 
5565					; get bank 
5565			 
5565					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5565 cd 31 21			call macro_dsp_valuehl 
5568				endm 
# End of macro FORTH_DSP_VALUEHL
5568			 
5568			;		push hl 
5568			 
5568					; destroy value TOS 
5568			 
5568					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5568 cd e9 21			call macro_forth_dsp_pop 
556b				endm 
# End of macro FORTH_DSP_POP
556b			 
556b					; one value on hl get other one back 
556b			 
556b			;		pop hl 
556b			 
556b			 
556b 0e ff				ld c, SPI_CE_HIGH 
556d 06 30				ld b, '0'    ; human readable bank number 
556f			 
556f 7d					ld a, l 
5570			 
5570					if DEBUG_FORTH_WORDS 
5570						DMARK "BNK" 
5570 f5				push af  
5571 3a 85 55			ld a, (.dmark)  
5574 32 b4 fe			ld (debug_mark),a  
5577 3a 86 55			ld a, (.dmark+1)  
557a 32 b5 fe			ld (debug_mark+1),a  
557d 3a 87 55			ld a, (.dmark+2)  
5580 32 b6 fe			ld (debug_mark+2),a  
5583 18 03			jr .pastdmark  
5585 ..			.dmark: db "BNK"  
5588 f1			.pastdmark: pop af  
5589			endm  
# End of macro DMARK
5589						CALLMONITOR 
5589 cd c6 18			call break_point_state  
558c				endm  
# End of macro CALLMONITOR
558c					endif 
558c			 
558c					; active low 
558c			 
558c fe 00				cp 0 
558e 28 28				jr z, .bset 
5590 fe 01				cp 1 
5592 20 04				jr nz, .b2 
5594 cb 81				res 0, c 
5596 06 31				ld b, '1'    ; human readable bank number 
5598 fe 02		.b2:		cp 2 
559a 20 04				jr nz, .b3 
559c cb 89				res 1, c 
559e 06 32				ld b, '2'    ; human readable bank number 
55a0 fe 03		.b3:		cp 3 
55a2 20 04				jr nz, .b4 
55a4 cb 91				res 2, c 
55a6 06 33				ld b, '3'    ; human readable bank number 
55a8 fe 04		.b4:		cp 4 
55aa 20 04				jr nz, .b5 
55ac cb 99				res 3, c 
55ae 06 34				ld b, '4'    ; human readable bank number 
55b0 fe 05		.b5:		cp 5 
55b2 20 04				jr nz, .bset 
55b4 cb a1				res 4, c 
55b6 06 35				ld b, '5'    ; human readable bank number 
55b8			 
55b8			.bset: 
55b8 79					ld a, c 
55b9 32 ed fb				ld (spi_device),a 
55bc 78					ld a, b 
55bd 32 ec fb				ld (spi_device_id),a 
55c0					if DEBUG_FORTH_WORDS 
55c0						DMARK "BN2" 
55c0 f5				push af  
55c1 3a d5 55			ld a, (.dmark)  
55c4 32 b4 fe			ld (debug_mark),a  
55c7 3a d6 55			ld a, (.dmark+1)  
55ca 32 b5 fe			ld (debug_mark+1),a  
55cd 3a d7 55			ld a, (.dmark+2)  
55d0 32 b6 fe			ld (debug_mark+2),a  
55d3 18 03			jr .pastdmark  
55d5 ..			.dmark: db "BN2"  
55d8 f1			.pastdmark: pop af  
55d9			endm  
# End of macro DMARK
55d9						CALLMONITOR 
55d9 cd c6 18			call break_point_state  
55dc				endm  
# End of macro CALLMONITOR
55dc					endif 
55dc			 
55dc					; set default SPI clk pulse time as disabled for BANK use 
55dc			 
55dc 3e 00				ld a, 0 
55de 32 f1 fb				ld (spi_clktime), a 
55e1			 
55e1					NEXTW 
55e1 c3 e0 22			jp macro_next 
55e4				endm 
# End of macro NEXTW
55e4			 
55e4			.CARTDEV: 
55e4				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
55e4 66				db WORD_SYS_CORE+82             
55e5 92 56			dw .ENDDEVICE            
55e7 08				db 7 + 1 
55e8 .. 00			db "CARTDEV",0              
55f0				endm 
# End of macro CWHEAD
55f0			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
55f0					if DEBUG_FORTH_WORDS_KEY 
55f0						DMARK "CDV" 
55f0 f5				push af  
55f1 3a 05 56			ld a, (.dmark)  
55f4 32 b4 fe			ld (debug_mark),a  
55f7 3a 06 56			ld a, (.dmark+1)  
55fa 32 b5 fe			ld (debug_mark+1),a  
55fd 3a 07 56			ld a, (.dmark+2)  
5600 32 b6 fe			ld (debug_mark+2),a  
5603 18 03			jr .pastdmark  
5605 ..			.dmark: db "CDV"  
5608 f1			.pastdmark: pop af  
5609			endm  
# End of macro DMARK
5609						CALLMONITOR 
5609 cd c6 18			call break_point_state  
560c				endm  
# End of macro CALLMONITOR
560c					endif 
560c			 
560c					; disable se storage bank selection 
560c			 
560c 3e ff				ld a, SPI_CE_HIGH		; ce high 
560e 32 ed fb				ld (spi_device), a 
5611			 
5611					; get bank 
5611			 
5611					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5611 cd 31 21			call macro_dsp_valuehl 
5614				endm 
# End of macro FORTH_DSP_VALUEHL
5614			 
5614			;		push hl 
5614			 
5614					; destroy value TOS 
5614			 
5614					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5614 cd e9 21			call macro_forth_dsp_pop 
5617				endm 
# End of macro FORTH_DSP_POP
5617			 
5617					; one value on hl get other one back 
5617			 
5617			;		pop hl 
5617			 
5617					; active low 
5617			 
5617 0e ff				ld c, 255 
5619			 
5619 7d					ld a, l 
561a					if DEBUG_FORTH_WORDS 
561a						DMARK "CDV" 
561a f5				push af  
561b 3a 2f 56			ld a, (.dmark)  
561e 32 b4 fe			ld (debug_mark),a  
5621 3a 30 56			ld a, (.dmark+1)  
5624 32 b5 fe			ld (debug_mark+1),a  
5627 3a 31 56			ld a, (.dmark+2)  
562a 32 b6 fe			ld (debug_mark+2),a  
562d 18 03			jr .pastdmark  
562f ..			.dmark: db "CDV"  
5632 f1			.pastdmark: pop af  
5633			endm  
# End of macro DMARK
5633						CALLMONITOR 
5633 cd c6 18			call break_point_state  
5636				endm  
# End of macro CALLMONITOR
5636					endif 
5636 fe 00				cp 0 
5638 28 30				jr z, .cset 
563a fe 01				cp 1 
563c 20 02				jr nz, .c2 
563e cb 81				res 0, c 
5640 fe 02		.c2:		cp 2 
5642 20 02				jr nz, .c3 
5644 cb 89				res 1, c 
5646 fe 03		.c3:		cp 3 
5648 20 02				jr nz, .c4 
564a cb 91				res 2, c 
564c fe 04		.c4:		cp 4 
564e 20 02				jr nz, .c5 
5650 cb 99				res 3, c 
5652 fe 05		.c5:		cp 5 
5654 20 02				jr nz, .c6 
5656 cb a1				res 4, c 
5658 fe 06		.c6:		cp 6 
565a 20 02				jr nz, .c7 
565c cb a9				res 5, c 
565e fe 07		.c7:		cp 7 
5660 20 02				jr nz, .c8 
5662 cb b1				res 6, c 
5664 fe 08		.c8:		cp 8 
5666 20 02				jr nz, .cset 
5668 cb b9				res 7, c 
566a 79			.cset:		ld a, c 
566b 32 f0 fb				ld (spi_cartdev),a 
566e			 
566e					if DEBUG_FORTH_WORDS 
566e						DMARK "CD2" 
566e f5				push af  
566f 3a 83 56			ld a, (.dmark)  
5672 32 b4 fe			ld (debug_mark),a  
5675 3a 84 56			ld a, (.dmark+1)  
5678 32 b5 fe			ld (debug_mark+1),a  
567b 3a 85 56			ld a, (.dmark+2)  
567e 32 b6 fe			ld (debug_mark+2),a  
5681 18 03			jr .pastdmark  
5683 ..			.dmark: db "CD2"  
5686 f1			.pastdmark: pop af  
5687			endm  
# End of macro DMARK
5687						CALLMONITOR 
5687 cd c6 18			call break_point_state  
568a				endm  
# End of macro CALLMONITOR
568a					endif 
568a			 
568a					; set default SPI clk pulse time as 10ms for CARTDEV use 
568a			 
568a 3e 0a				ld a, $0a 
568c 32 f1 fb				ld (spi_clktime), a 
568f					NEXTW 
568f c3 e0 22			jp macro_next 
5692				endm 
# End of macro NEXTW
5692			endif 
5692			 
5692			.ENDDEVICE: 
5692			; eof 
5692			 
# End of file forth_words_device.asm
5692			 
5692			; var handler 
5692			 
5692			 
5692			.VARS: 
5692				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5692 77				db WORD_SYS_CORE+99             
5693 43 57			dw .V0            
5695 04				db 3 + 1 
5696 .. 00			db "VAR",0              
569a				endm 
# End of macro CWHEAD
569a			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
569a			;| 
569a			;| The variable name should consist of a single letter. e.g. "a" 
569a			;! If a full string is passed then only the first char is looked at 
569a			;| Any other char could exceed bounds checks!  
569a			 
569a					if DEBUG_FORTH_WORDS_KEY 
569a						DMARK "VAR" 
569a f5				push af  
569b 3a af 56			ld a, (.dmark)  
569e 32 b4 fe			ld (debug_mark),a  
56a1 3a b0 56			ld a, (.dmark+1)  
56a4 32 b5 fe			ld (debug_mark+1),a  
56a7 3a b1 56			ld a, (.dmark+2)  
56aa 32 b6 fe			ld (debug_mark+2),a  
56ad 18 03			jr .pastdmark  
56af ..			.dmark: db "VAR"  
56b2 f1			.pastdmark: pop af  
56b3			endm  
# End of macro DMARK
56b3						CALLMONITOR 
56b3 cd c6 18			call break_point_state  
56b6				endm  
# End of macro CALLMONITOR
56b6					endif 
56b6			 
56b6					FORTH_DSP_VALUEHL 
56b6 cd 31 21			call macro_dsp_valuehl 
56b9				endm 
# End of macro FORTH_DSP_VALUEHL
56b9			 
56b9 7e					ld a, (hl)    ; get first char on of the string 
56ba			 
56ba			 
56ba					if DEBUG_FORTH_WORDS 
56ba						DMARK "VR1" 
56ba f5				push af  
56bb 3a cf 56			ld a, (.dmark)  
56be 32 b4 fe			ld (debug_mark),a  
56c1 3a d0 56			ld a, (.dmark+1)  
56c4 32 b5 fe			ld (debug_mark+1),a  
56c7 3a d1 56			ld a, (.dmark+2)  
56ca 32 b6 fe			ld (debug_mark+2),a  
56cd 18 03			jr .pastdmark  
56cf ..			.dmark: db "VR1"  
56d2 f1			.pastdmark: pop af  
56d3			endm  
# End of macro DMARK
56d3						CALLMONITOR 
56d3 cd c6 18			call break_point_state  
56d6				endm  
# End of macro CALLMONITOR
56d6					endif 
56d6					 
56d6 f5					push af	 
56d7					FORTH_DSP_POP 
56d7 cd e9 21			call macro_forth_dsp_pop 
56da				endm 
# End of macro FORTH_DSP_POP
56da f1					pop af 
56db			 
56db					; convert to upper 
56db			 
56db cd b6 12				call to_upper 
56de					if DEBUG_FORTH_WORDS 
56de						DMARK "Vaa" 
56de f5				push af  
56df 3a f3 56			ld a, (.dmark)  
56e2 32 b4 fe			ld (debug_mark),a  
56e5 3a f4 56			ld a, (.dmark+1)  
56e8 32 b5 fe			ld (debug_mark+1),a  
56eb 3a f5 56			ld a, (.dmark+2)  
56ee 32 b6 fe			ld (debug_mark+2),a  
56f1 18 03			jr .pastdmark  
56f3 ..			.dmark: db "Vaa"  
56f6 f1			.pastdmark: pop af  
56f7			endm  
# End of macro DMARK
56f7						CALLMONITOR 
56f7 cd c6 18			call break_point_state  
56fa				endm  
# End of macro CALLMONITOR
56fa					endif 
56fa 06 41				ld b, 'A' 
56fc 90					sub b			; set offset 
56fd					if DEBUG_FORTH_WORDS 
56fd						DMARK "Vbb" 
56fd f5				push af  
56fe 3a 12 57			ld a, (.dmark)  
5701 32 b4 fe			ld (debug_mark),a  
5704 3a 13 57			ld a, (.dmark+1)  
5707 32 b5 fe			ld (debug_mark+1),a  
570a 3a 14 57			ld a, (.dmark+2)  
570d 32 b6 fe			ld (debug_mark+2),a  
5710 18 03			jr .pastdmark  
5712 ..			.dmark: db "Vbb"  
5715 f1			.pastdmark: pop af  
5716			endm  
# End of macro DMARK
5716						CALLMONITOR 
5716 cd c6 18			call break_point_state  
5719				endm  
# End of macro CALLMONITOR
5719					endif 
5719 cb 27				sla a  
571b				 
571b					 
571b					if DEBUG_FORTH_WORDS 
571b						DMARK "VR2" 
571b f5				push af  
571c 3a 30 57			ld a, (.dmark)  
571f 32 b4 fe			ld (debug_mark),a  
5722 3a 31 57			ld a, (.dmark+1)  
5725 32 b5 fe			ld (debug_mark+1),a  
5728 3a 32 57			ld a, (.dmark+2)  
572b 32 b6 fe			ld (debug_mark+2),a  
572e 18 03			jr .pastdmark  
5730 ..			.dmark: db "VR2"  
5733 f1			.pastdmark: pop af  
5734			endm  
# End of macro DMARK
5734						CALLMONITOR 
5734 cd c6 18			call break_point_state  
5737				endm  
# End of macro CALLMONITOR
5737					endif 
5737			 
5737 21 81 fb				ld hl, cli_var_array2 
573a cd 49 0f				call addatohl 
573d cd 3a 1f				call forth_push_numhl 
5740			 
5740			 
5740				       NEXTW 
5740 c3 e0 22			jp macro_next 
5743				endm 
# End of macro NEXTW
5743			.V0: 
5743				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5743 78				db WORD_SYS_CORE+100             
5744 5b 57			dw .V0Q            
5746 04				db 3 + 1 
5747 .. 00			db "V0!",0              
574b				endm 
# End of macro CWHEAD
574b			;| V0! ( u1 -- )  Store value to v0  | DONE 
574b			 
574b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
574b cd 31 21			call macro_dsp_valuehl 
574e				endm 
# End of macro FORTH_DSP_VALUEHL
574e			 
574e 11 b5 fb				ld de, cli_var_array 
5751			 
5751 eb					ex de, hl 
5752 73					ld (hl), e 
5753 23					inc hl 
5754 72					ld (hl), d 
5755			 
5755					; destroy value TOS 
5755			 
5755					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5755 cd e9 21			call macro_forth_dsp_pop 
5758				endm 
# End of macro FORTH_DSP_POP
5758			 
5758				       NEXTW 
5758 c3 e0 22			jp macro_next 
575b				endm 
# End of macro NEXTW
575b			.V0Q: 
575b				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
575b 79				db WORD_SYS_CORE+101             
575c 6c 57			dw .V1S            
575e 04				db 3 + 1 
575f .. 00			db "V0@",0              
5763				endm 
# End of macro CWHEAD
5763			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5763 2a b5 fb				ld hl, (cli_var_array) 
5766 cd 3a 1f				call forth_push_numhl 
5769			 
5769				       NEXTW 
5769 c3 e0 22			jp macro_next 
576c				endm 
# End of macro NEXTW
576c			.V1S: 
576c				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
576c 7a				db WORD_SYS_CORE+102             
576d 84 57			dw .V1Q            
576f 04				db 3 + 1 
5770 .. 00			db "V1!",0              
5774				endm 
# End of macro CWHEAD
5774			;| V1! ( u1 -- )  Store value to v1 | DONE 
5774					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5774 cd 31 21			call macro_dsp_valuehl 
5777				endm 
# End of macro FORTH_DSP_VALUEHL
5777			 
5777 11 b7 fb				ld de, cli_var_array+2 
577a				 
577a eb					ex de, hl 
577b 73					ld (hl), e 
577c 23					inc hl 
577d 72					ld (hl), d 
577e			 
577e					; destroy value TOS 
577e			 
577e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
577e cd e9 21			call macro_forth_dsp_pop 
5781				endm 
# End of macro FORTH_DSP_POP
5781				       NEXTW 
5781 c3 e0 22			jp macro_next 
5784				endm 
# End of macro NEXTW
5784			.V1Q: 
5784				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5784 7b				db WORD_SYS_CORE+103             
5785 95 57			dw .V2S            
5787 04				db 3 + 1 
5788 .. 00			db "V1@",0              
578c				endm 
# End of macro CWHEAD
578c			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
578c 2a b7 fb				ld hl, (cli_var_array+2) 
578f cd 3a 1f				call forth_push_numhl 
5792				       NEXTW 
5792 c3 e0 22			jp macro_next 
5795				endm 
# End of macro NEXTW
5795			.V2S: 
5795				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5795 7c				db WORD_SYS_CORE+104             
5796 ad 57			dw .V2Q            
5798 04				db 3 + 1 
5799 .. 00			db "V2!",0              
579d				endm 
# End of macro CWHEAD
579d			;| V2! ( u1 -- )  Store value to v2 | DONE 
579d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
579d cd 31 21			call macro_dsp_valuehl 
57a0				endm 
# End of macro FORTH_DSP_VALUEHL
57a0			 
57a0 11 b9 fb				ld de, cli_var_array+4 
57a3				 
57a3 eb					ex de, hl 
57a4 73					ld (hl), e 
57a5 23					inc hl 
57a6 72					ld (hl), d 
57a7			 
57a7					; destroy value TOS 
57a7			 
57a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
57a7 cd e9 21			call macro_forth_dsp_pop 
57aa				endm 
# End of macro FORTH_DSP_POP
57aa				       NEXTW 
57aa c3 e0 22			jp macro_next 
57ad				endm 
# End of macro NEXTW
57ad			.V2Q: 
57ad				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
57ad 7d				db WORD_SYS_CORE+105             
57ae be 57			dw .V3S            
57b0 04				db 3 + 1 
57b1 .. 00			db "V2@",0              
57b5				endm 
# End of macro CWHEAD
57b5			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
57b5 2a b9 fb				ld hl, (cli_var_array+4) 
57b8 cd 3a 1f				call forth_push_numhl 
57bb				       NEXTW 
57bb c3 e0 22			jp macro_next 
57be				endm 
# End of macro NEXTW
57be			.V3S: 
57be				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
57be 7c				db WORD_SYS_CORE+104             
57bf d6 57			dw .V3Q            
57c1 04				db 3 + 1 
57c2 .. 00			db "V3!",0              
57c6				endm 
# End of macro CWHEAD
57c6			;| V3! ( u1 -- )  Store value to v3 | DONE 
57c6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
57c6 cd 31 21			call macro_dsp_valuehl 
57c9				endm 
# End of macro FORTH_DSP_VALUEHL
57c9			 
57c9 11 bb fb				ld de, cli_var_array+6 
57cc				 
57cc eb					ex de, hl 
57cd 73					ld (hl), e 
57ce 23					inc hl 
57cf 72					ld (hl), d 
57d0			 
57d0					; destroy value TOS 
57d0			 
57d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
57d0 cd e9 21			call macro_forth_dsp_pop 
57d3				endm 
# End of macro FORTH_DSP_POP
57d3				       NEXTW 
57d3 c3 e0 22			jp macro_next 
57d6				endm 
# End of macro NEXTW
57d6			.V3Q: 
57d6				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
57d6 7d				db WORD_SYS_CORE+105             
57d7 e7 57			dw .END            
57d9 04				db 3 + 1 
57da .. 00			db "V3@",0              
57de				endm 
# End of macro CWHEAD
57de			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
57de 2a bb fb				ld hl, (cli_var_array+6) 
57e1 cd 3a 1f				call forth_push_numhl 
57e4				       NEXTW 
57e4 c3 e0 22			jp macro_next 
57e7				endm 
# End of macro NEXTW
57e7			 
57e7			 
57e7			 
57e7			 
57e7			 
57e7			; end of dict marker 
57e7			 
57e7 00			.END:    db WORD_SYS_END 
57e8 00 00			dw 0 
57ea 00				db 0 
57eb			 
57eb			; use to jp here for user dict words to save on macro expansion  
57eb			 
57eb			user_dict_next: 
57eb				NEXTW 
57eb c3 e0 22			jp macro_next 
57ee				endm 
# End of macro NEXTW
57ee			 
57ee			 
57ee			user_exec: 
57ee				;    ld hl, <word code> 
57ee				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
57ee				;    call forthexec 
57ee				;    jp user_dict_next   (NEXT) 
57ee			        ;    <word code bytes> 
57ee eb				ex de, hl 
57ef 2a 4f f6			ld hl,(os_tok_ptr) 
57f2				 
57f2				FORTH_RSP_NEXT 
57f2 cd e1 1e			call macro_forth_rsp_next 
57f5				endm 
# End of macro FORTH_RSP_NEXT
57f5			 
57f5			if DEBUG_FORTH_UWORD 
57f5						DMARK "UEX" 
57f5 f5				push af  
57f6 3a 0a 58			ld a, (.dmark)  
57f9 32 b4 fe			ld (debug_mark),a  
57fc 3a 0b 58			ld a, (.dmark+1)  
57ff 32 b5 fe			ld (debug_mark+1),a  
5802 3a 0c 58			ld a, (.dmark+2)  
5805 32 b6 fe			ld (debug_mark+2),a  
5808 18 03			jr .pastdmark  
580a ..			.dmark: db "UEX"  
580d f1			.pastdmark: pop af  
580e			endm  
# End of macro DMARK
580e				CALLMONITOR 
580e cd c6 18			call break_point_state  
5811				endm  
# End of macro CALLMONITOR
5811			endif 
5811			 
5811			 
5811			 
5811 eb				ex de, hl 
5812 22 4f f6			ld (os_tok_ptr), hl 
5815				 
5815				; Don't use next - Skips the first word in uword. 
5815			 
5815 c3 71 23			jp exec1 
5818			;	NEXT 
5818			 
5818			 
5818			; eof 
# End of file forth_wordsv4.asm
5818			endif 
5818			;;;;;;;;;;;;;; Debug code 
5818			 
5818			 
5818			;if DEBUG_FORTH_PARSE 
5818 .. 00		.nowordfound: db "No match",0 
5821 .. 00		.compword:	db "Comparing word ",0 
5831 .. 00		.nextwordat:	db "Next word at",0 
583e .. 00		.charmatch:	db "Char match",0 
5849			;endif 
5849			if DEBUG_FORTH_JP 
5849			.foundword:	db "Word match. Exec..",0 
5849			endif 
5849			;if DEBUG_FORTH_PUSH 
5849 .. 00		.enddict:	db "Dict end. Push.",0 
5859 .. 00		.push_str:	db "Pushing string",0 
5868 .. 00		.push_num:	db "Pushing number",0 
5877 .. 00		.data_sp:	db "SP:",0 
587b .. 00		.wordinhl:	db "Word in HL (2/0):",0 
588d .. 00		.wordinde:	db "Word in DE (3/0):",0 
589f .. 00		.wordinbc:	db "Word in BC (4/0):",0 
58b1			;endif 
58b1			;if DEBUG_FORTH_MALLOC 
58b1 .. 00		.push_malloc:	db "Malloc address",0 
58c0			;endif 
58c0			 
58c0			 
58c0			 
58c0			; display malloc address and current data stack pointer  
58c0			 
58c0			malloc_error: 
58c0 d5				push de 
58c1 f5				push af 
58c2 e5				push hl 
58c3 cd 15 0d			call clear_display 
58c6 11 e8 58			ld de, .mallocerr 
58c9 3e 00			ld a,0 
58cb			;	ld de,os_word_scratch 
58cb cd 28 0d			call str_at_display 
58ce 3e 11			ld a, display_row_1+17 
58d0 11 b4 fe			ld de, debug_mark 
58d3 cd 28 0d			call str_at_display 
58d6 cd 38 0d			call update_display 
58d9				;call break_point_state 
58d9 cd b1 71			call cin_wait 
58dc			 
58dc 3e 20			ld a, ' ' 
58de 32 3f f3			ld (os_view_disable), a 
58e1 e1				pop hl 
58e2 f1				pop af 
58e3 d1				pop de	 
58e4				CALLMONITOR 
58e4 cd c6 18			call break_point_state  
58e7				endm  
# End of macro CALLMONITOR
58e7 c9				ret 
58e8			 
58e8 .. 00		.mallocerr: 	db "Malloc Error",0 
58f5			;if DEBUG_FORTH_PUSH 
58f5			display_data_sp: 
58f5 f5				push af 
58f6			 
58f6				; see if disabled 
58f6			 
58f6 3a 3f f3			ld a, (os_view_disable) 
58f9 fe 2a			cp '*' 
58fb 28 67			jr z, .skipdsp 
58fd			 
58fd e5				push hl 
58fe e5				push hl 
58ff e5			push hl 
5900 cd 15 0d			call clear_display 
5903 e1			pop hl 
5904 7c				ld a,h 
5905 21 53 f6			ld hl, os_word_scratch 
5908 cd 4a 12			call hexout 
590b e1				pop hl 
590c 7d				ld a,l 
590d 21 55 f6			ld hl, os_word_scratch+2 
5910 cd 4a 12			call hexout 
5913 21 57 f6			ld hl, os_word_scratch+4 
5916 3e 00			ld a,0 
5918 77				ld (hl),a 
5919 11 53 f6			ld de,os_word_scratch 
591c 3e 14				ld a, display_row_2 
591e cd 28 0d				call str_at_display 
5921 11 7b 58			ld de, .wordinhl 
5924 3e 00			ld a, display_row_1 
5926			 
5926 cd 28 0d				call str_at_display 
5929 11 b4 fe			ld de, debug_mark 
592c 3e 11			ld a, display_row_1+17 
592e			 
592e cd 28 0d				call str_at_display 
5931			 
5931				; display current data stack pointer 
5931 11 77 58			ld de,.data_sp 
5934 3e 1c				ld a, display_row_2 + 8 
5936 cd 28 0d				call str_at_display 
5939			 
5939 2a 7b fb			ld hl,(cli_data_sp) 
593c e5				push hl 
593d 7c				ld a,h 
593e 21 53 f6			ld hl, os_word_scratch 
5941 cd 4a 12			call hexout 
5944 e1				pop hl 
5945 7d				ld a,l 
5946 21 55 f6			ld hl, os_word_scratch+2 
5949 cd 4a 12			call hexout 
594c 21 57 f6			ld hl, os_word_scratch+4 
594f 3e 00			ld a,0 
5951 77				ld (hl),a 
5952 11 53 f6			ld de,os_word_scratch 
5955 3e 1f				ld a, display_row_2 + 11 
5957 cd 28 0d				call str_at_display 
595a			 
595a			 
595a cd 38 0d			call update_display 
595d cd 92 0c			call delay1s 
5960 cd 92 0c			call delay1s 
5963 e1				pop hl 
5964			.skipdsp: 
5964 f1				pop af 
5965 c9				ret 
5966			 
5966			display_data_malloc: 
5966			 
5966 f5				push af 
5967 e5				push hl 
5968 e5				push hl 
5969 e5			push hl 
596a cd 15 0d			call clear_display 
596d e1			pop hl 
596e 7c				ld a,h 
596f 21 53 f6			ld hl, os_word_scratch 
5972 cd 4a 12			call hexout 
5975 e1				pop hl 
5976 7d				ld a,l 
5977 21 55 f6			ld hl, os_word_scratch+2 
597a cd 4a 12			call hexout 
597d 21 57 f6			ld hl, os_word_scratch+4 
5980 3e 00			ld a,0 
5982 77				ld (hl),a 
5983 11 53 f6			ld de,os_word_scratch 
5986 3e 14				ld a, display_row_2 
5988 cd 28 0d				call str_at_display 
598b 11 b1 58			ld de, .push_malloc 
598e 3e 00			ld a, display_row_1 
5990			 
5990 cd 28 0d				call str_at_display 
5993			 
5993				; display current data stack pointer 
5993 11 77 58			ld de,.data_sp 
5996 3e 1c				ld a, display_row_2 + 8 
5998 cd 28 0d				call str_at_display 
599b			 
599b 2a 7b fb			ld hl,(cli_data_sp) 
599e e5				push hl 
599f 7c				ld a,h 
59a0 21 53 f6			ld hl, os_word_scratch 
59a3 cd 4a 12			call hexout 
59a6 e1				pop hl 
59a7 7d				ld a,l 
59a8 21 55 f6			ld hl, os_word_scratch+2 
59ab cd 4a 12			call hexout 
59ae 21 57 f6			ld hl, os_word_scratch+4 
59b1 3e 00			ld a,0 
59b3 77				ld (hl),a 
59b4 11 53 f6			ld de,os_word_scratch 
59b7 3e 1f				ld a, display_row_2 + 11 
59b9 cd 28 0d				call str_at_display 
59bc			 
59bc cd 38 0d			call update_display 
59bf cd 92 0c			call delay1s 
59c2 cd 92 0c			call delay1s 
59c5 e1				pop hl 
59c6 f1				pop af 
59c7 c9				ret 
59c8			;endif 
59c8			 
59c8			include "forth_autostart.asm" 
59c8			; list of commands to perform at system start up 
59c8			 
59c8			startcmds: 
59c8			;	dw test11 
59c8			;	dw test12 
59c8			;	dw test13 
59c8			;	dw test14 
59c8			;	dw test15 
59c8			;	dw test16 
59c8			;	dw test17 
59c8			;	dw ifthtest1 
59c8			;	dw ifthtest2 
59c8			;	dw ifthtest3 
59c8			;	dw mmtest1 
59c8			;	dw mmtest2 
59c8			;	dw mmtest3 
59c8			;	dw mmtest4 
59c8			;	dw mmtest5 
59c8			;	dw mmtest6 
59c8			;	dw iftest1 
59c8			;	dw iftest2 
59c8			;	dw iftest3 
59c8			;	dw looptest1 
59c8			;	dw looptest2 
59c8			;	dw test1 
59c8			;	dw test2 
59c8			;	dw test3 
59c8			;	dw test4 
59c8			;	dw game2r 
59c8			;	dw game2b1 
59c8			;	dw game2b2 
59c8			 
59c8				; start up words that are actually useful 
59c8			 
59c8 3c 5a		    dw spi1 
59ca 97 5a		    dw spi2 
59cc 25 5b		    dw spi3 
59ce cd 5a		    dw spi4 
59d0 f8 5a		    dw spi5 
59d2 8b 5b		    dw spi6 
59d4 e0 5b		    dw spi7 
59d6			 
59d6 38 5c		    dw spi8 
59d8 57 5c		    dw spi9 
59da af 5c		    dw spi10 
59dc			 
59dc 22 5d			dw longread 
59de 69 5d			dw clrstack 
59e0 9c 5d			dw type 
59e2 8c 5f			dw stest 
59e4 c0 5d			dw strncpy 
59e6 22 5f			dw list 
59e8 21 5e			dw start1 
59ea 33 5e			dw start2 
59ec			;	dw start3 
59ec 46 5e			dw start3b 
59ee c2 5e			dw start3c 
59f0			 
59f0				; (unit) testing words 
59f0			 
59f0 03 60			dw mtesta 
59f2 b8 60			dw mtestb 
59f4 5b 61			dw mtestc 
59f6 10 62			dw mtestd 
59f8 b4 62			dw mteste 
59fa			 
59fa				; demo/game words 
59fa			 
59fa c0 69		        dw game3w 
59fc ee 69		        dw game3p 
59fe 0c 6a		        dw game3sc 
5a00 3d 6a		        dw game3vsi 
5a02 69 6a		        dw game3vs 
5a04				 
5a04 b3 67			dw game2b 
5a06 21 68			dw game2bf 
5a08 6b 68			dw game2mba 
5a0a 01 69			dw game2mbas 
5a0c 43 69			dw game2mb 
5a0e			 
5a0e 74 64			dw game1 
5a10 85 64			dw game1a 
5a12 e7 64			dw game1b 
5a14 1c 65			dw game1c 
5a16 52 65			dw game1d 
5a18 83 65			dw game1s 
5a1a 97 65			dw game1t 
5a1c ac 65			dw game1f 
5a1e e0 65			dw game1z 
5a20 24 66			dw game1zz 
5a22			 
5a22 6a 63			dw test5 
5a24 a2 63			dw test6 
5a26 da 63			dw test7 
5a28 ee 63			dw test8 
5a2a 1a 64			dw test9 
5a2c 30 64			dw test10 
5a2e				 
5a2e fb 66		        dw ssv5 
5a30 df 66		        dw ssv4 
5a32 c3 66		        dw ssv3 
5a34 8d 66		        dw ssv2 
5a36 14 67		        dw ssv1 
5a38 5c 67		        dw ssv1cpm 
5a3a			;	dw keyup 
5a3a			;	dw keydown 
5a3a			;	dw keyleft 
5a3a			;	dw keyright 
5a3a			;	dw 	keyf1 
5a3a			;	dw keyf2 
5a3a			;	dw keyf3 
5a3a			;	dw keyf4 
5a3a			;	dw keyf5 
5a3a			;	dw keyf6 
5a3a			;	dw keyf7 
5a3a			;	dw keyf8 
5a3a			;	dw keyf9 
5a3a			;	dw keyf10 
5a3a			;	dw keyf11 
5a3a			;	dw keyf12 
5a3a			;	dw keytab 
5a3a			;	dw keycr 
5a3a			;	dw keyhome 
5a3a			;	dw keyend 
5a3a			;	dw keybs 
5a3a 00 00			db 0, 0	 
5a3c			 
5a3c			; SPI Net support words 
5a3c			 
5a3c			; v0! = node to send to 
5a3c			; ( str count - ) 
5a3c .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5a97			 
5a97			; spiputchr ( char node - ) 
5a97 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
5acd			 
5acd			; spigetchr ( - n ) 
5acd .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
5af8			 
5af8			; getnode ( - n ) 
5af8 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
5b25			 
5b25			; ( str node - )  
5b25 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5b8b			; store string ( str i - ) 
5b8b			 
5b8b			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5b8b .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
5be0			 
5be0			; get string ( addr i -  )    TO FIX 
5be0			 
5be0 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5c38			 
5c38			 
5c38			; NETCHAT (TODO) 
5c38			; Program to allow two nodes to chat with eachother 
5c38			; 
5c38			; v0 - target node 
5c38			;  
5c38			; accept input at 0,0 
5c38			; if input is string send spitype to target node 
5c38			; starting at row 2,0 , while spigetchr is not zero ->  
5c38			; 
5c38			; 
5c38			; TODO add paging of get request 
5c38			 
5c38			; ( node - ) 
5c38 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
5c57 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5caf .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
5d22			 
5d22			 
5d22			; Long read of currently open file 
5d22 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5d69			 
5d69			; clear stack  
5d69			 
5d69 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5d9c			 
5d9c			; type ( addr count - ) 
5d9c .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5dc0			 
5dc0			; some direct memory words 
5dc0			; strncpy ( len t f -- t ) 
5dc0			 
5dc0 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5e21			 
5e21 .. 00		start1:     	db ": bpon $0000 bp ;",0 
5e33 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5e46 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
5ec2 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5f22			 
5f22			 
5f22			; a handy word to list items on the stack 
5f22			 
5f22 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5f8c			 
5f8c			 
5f8c			; test stack  
5f8c			; rnd8 stest 
5f8c			 
5f8c .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
6003			 
6003			; random malloc and free cycles 
6003			 
6003 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
60b8			 
60b8			; fixed malloc and free cycles 
60b8			 
60b8 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
615b			 
615b			; fixed double string push and drop cycle  
615b			 
615b .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
6210			 
6210			; consistent fixed string push and drop cycle  
6210			 
6210 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
62b4			 
62b4 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
636a			 
636a			;test1:		db ": aa 1 2 3 ;", 0 
636a			;test2:     	db "111 aa 888 999",0 
636a			;test3:     	db ": bb 77 ;",0 
636a			;test4:     	db "$02 $01 do i . loop bb",0 
636a			 
636a .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
63a2 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
63da .. 00		test7:     	db ": box hline vline ;",0 
63ee .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
641a .. 00		test9:     	db ": sw $01 adsp world ;",0 
6430 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
6455 .. 00		test11:     	db "hello create .",0 
6464 .. 00		test12:     	db "hello2 create .",0 
6474			 
6474			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6474			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6474			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6474			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6474			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6474			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6474			 
6474			;iftest1:     	db "$0001 IF cls .",0 
6474			;iftest2:     	db "$0000 IF cls .",0 
6474			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6474			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6474			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6474			 
6474			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6474			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6474			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6474			 
6474			 
6474			 
6474			; a small guess the number game 
6474			 
6474 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6485 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
64e7			 
64e7 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
651c .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6552 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6583 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6597 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
65ac .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
65e0 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6624			 
6624			; Using 'ga' save a high score across multiple runs using external storage 
6624			 
6624 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
668d			 
668d			 
668d			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
668d			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
668d			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
668d			 
668d			; simple screen saver to test code memory reuse to destruction 
668d			 
668d .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
66c3 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
66df .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
66fb .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6714 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
675c .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
67b3			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
67b3			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
67b3			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
67b3			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
67b3			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
67b3			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
67b3			 
67b3			 
67b3			 
67b3			; minesweeper/battleship finding game 
67b3			; draws a game board of random ship/mine positions 
67b3			; user enters coords to see if it hits on 
67b3			; game ends when all are hit 
67b3			; when hit or miss says how many may be in the area 
67b3			 
67b3			; setup the game board and then hide it 
67b3 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6821 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
686b			; prompt for where to target 
686b .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6901 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6926			; TODO see if the entered coords hits or misses pushes char hit of miss 
6926 .. 00		game2mbht:      db ": mbckht nop ;",0 
6935 .. 00		game2mbms:      db ": mbcms nop ;",0 
6943			; TODO how many might be near by 
6943 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
69c0			 
69c0			; Game 3 
69c0			 
69c0			; Vert scroller ski game - avoid the trees! 
69c0			 
69c0			; v0 score (ie turns) 
69c0			; v1 player pos 
69c0			; v2 left wall 
69c0			; v3 right wall 
69c0			 
69c0			; Draw side walls randomly 
69c0			 
69c0 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
69ee			 
69ee			; Draw player 
69ee .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6a0c			 
6a0c			; TODO Get Key 
6a0c			 
6a0c			; TODO Move left right 
6a0c			 
6a0c			; scroll and move walls a bit 
6a0c			 
6a0c .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6a3d			 
6a3d			; main game loop 
6a3d			 
6a3d .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6a69 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6aa8			 
6aa8			; key board defs 
6aa8			 
6aa8 .. 00		keyup:       db ": keyup $05 ;",0 
6ab6 .. 00		keydown:       db ": keydown $0a ;",0 
6ac6 .. 00		keyleft:       db ": keyleft $0b ;",0 
6ad6 .. 00		keyright:       db ": keyright $0c ;",0 
6ae7 .. 00		keyf1:       db ": keyf1 $10 ;",0 
6af5 .. 00		keyf2:       db ": keyf2 $11 ;",0 
6b03 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6b11 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6b1f .. 00		keyf5:       db ": keyf5 $14 ;",0 
6b2d .. 00		keyf6:       db ": keyf6 $15 ;",0 
6b3b .. 00		keyf7:       db ": keyf7 $16 ;",0 
6b49 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6b57 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6b65 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6b74 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6b83 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6b92			 
6b92 .. 00		keytab:       db ": keytab $09 ;",0 
6ba1 .. 00		keycr:       db ": keycr $0d ;",0 
6baf .. 00		keyhome:       db ": keyhome $0e ;",0 
6bbf .. 00		keyend:       db ": keyend $0f ;",0 
6bce .. 00		keybs:       db ": keybs $08 ;",0 
6bdc			 
6bdc			   
6bdc			 
6bdc			 
6bdc			 
6bdc			; eof 
# End of file forth_autostart.asm
6bdc			 
6bdc .. 00		sprompt1: db "Startup load...",0 
6bec .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6c02			 
6c02			 
6c02			 
6c02			 
6c02			forth_startup: 
6c02 21 c8 59			ld hl, startcmds 
6c05 3e 00			ld a, 0 
6c07 32 74 f7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6c0a			 
6c0a e5			.start1:	push hl 
6c0b cd 15 0d			call clear_display 
6c0e 11 dc 6b			ld de, sprompt1 
6c11 3e 00		        ld a, display_row_1 
6c13 cd 28 0d			call str_at_display 
6c16 11 ec 6b			ld de, sprompt2 
6c19 3e 14		        ld a, display_row_2 
6c1b cd 28 0d			call str_at_display 
6c1e e1				pop hl 
6c1f e5				push hl 
6c20 5e				ld e,(hl) 
6c21 23				inc hl 
6c22 56				ld d,(hl) 
6c23 3e 28		        ld a, display_row_3 
6c25 cd 28 0d			call str_at_display 
6c28 cd 38 0d			call update_display 
6c2b			 
6c2b			 
6c2b 3a 74 f7			ld a, (os_last_cmd) 
6c2e fe 00			cp 0 
6c30 28 05			jr z, .startprompt 
6c32 cd 86 0c			call delay250ms 
6c35 18 24			jr .startdo 
6c37				 
6c37				 
6c37			 
6c37			.startprompt: 
6c37			 
6c37 3e 4f			ld a,display_row_4 + display_cols - 1 
6c39 11 b0 1e		        ld de, endprg 
6c3c cd 28 0d			call str_at_display 
6c3f cd 38 0d			call update_display 
6c42 cd 92 0c			call delay1s 
6c45 cd b1 71			call cin_wait 
6c48						 
6c48 fe 2a			cp '*' 
6c4a 28 5e			jr z, .startupend1 
6c4c fe 23			cp '#' 
6c4e 20 07			jr nz, .startno 
6c50 3e 01			ld a, 1 
6c52 32 74 f7			ld (os_last_cmd),a 
6c55 18 04			jr .startdo 
6c57 fe 31		.startno:	cp '1' 
6c59 28 3a			jr z,.startnxt  
6c5b			 
6c5b				; exec startup line 
6c5b			.startdo:	 
6c5b e1				pop hl 
6c5c e5				push hl 
6c5d				 
6c5d 5e				ld e,(hl) 
6c5e 23				inc hl 
6c5f 56				ld d,(hl) 
6c60 eb				ex de,hl 
6c61			 
6c61 e5				push hl 
6c62			 
6c62 3e 00			ld a, 0 
6c64				;ld a, FORTH_END_BUFFER 
6c64 cd b2 13			call strlent 
6c67 23				inc hl   ; include zero term to copy 
6c68 06 00			ld b,0 
6c6a 4d				ld c,l 
6c6b e1				pop hl 
6c6c 11 4e f3			ld de, scratch 
6c6f ed b0			ldir 
6c71			 
6c71			 
6c71 21 4e f3			ld hl, scratch 
6c74 cd 2e 23			call forthparse 
6c77 cd 6e 23			call forthexec 
6c7a cd 80 22			call forthexec_cleanup 
6c7d			 
6c7d 3e 3c			ld a, display_row_4 
6c7f 11 54 1c			ld de, endprog 
6c82			 
6c82 cd 38 0d			call update_display		 
6c85			 
6c85 3a 74 f7			ld a, (os_last_cmd) 
6c88 fe 00			cp 0 
6c8a 20 09			jr nz, .startnxt 
6c8c cd b2 1e			call next_page_prompt 
6c8f cd 15 0d		        call clear_display 
6c92 cd 38 0d			call update_display		 
6c95			 
6c95				; move onto next startup line? 
6c95			.startnxt: 
6c95			 
6c95 cd 86 0c			call delay250ms 
6c98 e1				pop hl 
6c99			 
6c99 23				inc hl 
6c9a 23				inc hl 
6c9b			 
6c9b e5				push hl 
6c9c 5e				ld e, (hl) 
6c9d 23				inc hl 
6c9e 56				ld d, (hl) 
6c9f e1				pop hl 
6ca0				; TODO replace 0 test 
6ca0			 
6ca0 eb				ex de, hl 
6ca1 cd 72 0f			call ishlzero 
6ca4			;	ld a,e 
6ca4			;	add d 
6ca4			;	cp 0    ; any left to do? 
6ca4 eb				ex de, hl 
6ca5 c2 0a 6c			jp nz, .start1 
6ca8 18 01			jr .startupend 
6caa			 
6caa e1			.startupend1: pop hl 
6cab			.startupend: 
6cab			 
6cab cd 15 0d			call clear_display 
6cae cd 38 0d			call update_display 
6cb1 c9				ret 
6cb2			 
6cb2			 
6cb2			; stack over and underflow checks 
6cb2			 
6cb2			; init the words to detect the under/overflow 
6cb2			 
6cb2			chk_stk_init: 
6cb2				; a vague random number to check so we dont get any "lucky" hits 
6cb2 3e 2d			ld a, 45 
6cb4 6f				ld l, a 
6cb5 00				nop 
6cb6 3e 17			ld a, 23 
6cb8 67				ld h, a 
6cb9			 
6cb9 22 35 f3			ld (chk_word), hl     ; the word we need to check against 
6cbc			 
6cbc			;	ld (chk_stund), hl	; stack points.... 
6cbc 22 fd fe			ld (chk_stovr), hl 
6cbf 22 79 fb			ld (chk_ret_und), hl 
6cc2 22 37 fb			ld (chk_ret_ovr), hl 
6cc5 22 b5 fa			ld (chk_loop_ovr), hl 
6cc8 22 b3 f8			ld (chk_data_ovr), hl 
6ccb c9				ret 
6ccc				 
6ccc			check_stacks: 
6ccc				; check all stack words 
6ccc			 
6ccc e5				push hl 
6ccd d5				push de 
6cce			 
6cce			;	ld de,(chk_word) 
6cce			;	ld hl, (chk_stund)	; stack points.... 
6cce			;	if DEBUG_STK_FAULT 
6cce			;		DMARK "FAa" 
6cce			;		CALLMONITOR 
6cce			;	endif 
6cce			;	call cmp16 
6cce			;	jp z, .chk_faulta 
6cce			; 
6cce			;	ld de, sfaultsu 
6cce			;	jp .chk_fault 
6cce			 
6cce 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
6cd1 ed 5b 35 f3		ld de,(chk_word) 
6cd5				if DEBUG_STK_FAULT 
6cd5					DMARK "FAb" 
6cd5					CALLMONITOR 
6cd5				endif 
6cd5 cd 67 0f			call cmp16 
6cd8 28 06			jr z, .chk_fault1 
6cda 11 7b 6d			ld de, sfaultso 
6cdd c3 2f 6d			jp .chk_fault 
6ce0			.chk_fault1:  
6ce0 2a 79 fb			ld hl, (chk_ret_und) 
6ce3 ed 5b 35 f3		ld de,(chk_word) 
6ce7				if DEBUG_STK_FAULT 
6ce7					DMARK "FAU" 
6ce7					CALLMONITOR 
6ce7				endif 
6ce7 cd 67 0f			call cmp16 
6cea ca f3 6c			jp z, .chk_fault2 
6ced 11 8b 6d			ld de, sfaultru 
6cf0 c3 2f 6d			jp .chk_fault 
6cf3			.chk_fault2:  
6cf3 2a 37 fb			ld hl, (chk_ret_ovr) 
6cf6 ed 5b 35 f3		ld de,(chk_word) 
6cfa				if DEBUG_STK_FAULT 
6cfa					DMARK "FA1" 
6cfa					CALLMONITOR 
6cfa				endif 
6cfa cd 67 0f			call cmp16 
6cfd ca 06 6d			jp z, .chk_fault3 
6d00 11 99 6d			ld de, sfaultro 
6d03 c3 2f 6d			jp .chk_fault 
6d06			.chk_fault3:  
6d06 2a b5 fa			ld hl, (chk_loop_ovr) 
6d09 ed 5b 35 f3		ld de,(chk_word) 
6d0d				if DEBUG_STK_FAULT 
6d0d					DMARK "FA2" 
6d0d					CALLMONITOR 
6d0d				endif 
6d0d cd 67 0f			call cmp16 
6d10 ca 19 6d			jp z, .chk_fault4 
6d13 11 b3 6d			ld de, sfaultlo 
6d16 c3 2f 6d			jp .chk_fault 
6d19			.chk_fault4:  
6d19 2a b3 f8			ld hl, (chk_data_ovr) 
6d1c ed 5b 35 f3		ld de,(chk_word) 
6d20				if DEBUG_STK_FAULT 
6d20					DMARK "FA3" 
6d20					CALLMONITOR 
6d20				endif 
6d20 cd 67 0f			call cmp16 
6d23 ca 2c 6d			jp z, .chk_fault5 
6d26 11 cd 6d			ld de, sfaultdo 
6d29 c3 2f 6d			jp .chk_fault 
6d2c			 
6d2c			 
6d2c			.chk_fault5:  
6d2c d1				pop de 
6d2d e1				pop hl 
6d2e			 
6d2e c9				ret 
6d2f			 
6d2f cd 15 0d		.chk_fault: 	call clear_display 
6d32 3e 14				ld a, display_row_2 
6d34 cd 28 0d				call str_at_display 
6d37 11 5d 6d				   ld de, .stackfault 
6d3a 3e 00				ld a, display_row_1 
6d3c cd 28 0d				call str_at_display 
6d3f 11 b4 fe				    ld de, debug_mark 
6d42 3e 11				ld a, display_row_1+17 
6d44 cd 28 0d				call str_at_display 
6d47 cd 38 0d				call update_display 
6d4a			 
6d4a				; prompt before entering montior for investigating issue 
6d4a			 
6d4a 3e 3c			ld a, display_row_4 
6d4c 11 54 1c			ld de, endprog 
6d4f			 
6d4f cd 38 0d			call update_display		 
6d52			 
6d52 cd b2 1e			call next_page_prompt 
6d55			 
6d55 d1				pop de 
6d56 e1				pop hl 
6d57 cd a8 1c				call monitor 
6d5a c3 9f 1b				jp warmstart 
6d5d					;jp 0 
6d5d					;halt 
6d5d			 
6d5d			 
6d5d			 
6d5d .. 00		.stackfault: 	db "Stack fault:",0 
6d6a			 
6d6a .. 00		sfaultsu: 	db	"Stack under flow",0 
6d7b .. 00		sfaultso: 	db	"Stack over flow",0 
6d8b .. 00		sfaultru:	db "RTS underflow",0 
6d99 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6db3 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6dcd .. 00		sfaultdo:	db "DTS overflow", 0 
6dda			 
6dda			 
6dda			fault_dsp_under: 
6dda 11 ec 6d			ld de, .dsp_under 
6ddd c3 9c 6e			jp .show_fault 
6de0			 
6de0			fault_rsp_under: 
6de0 11 fa 6d			ld de, .rsp_under 
6de3 c3 9c 6e			jp .show_fault 
6de6			fault_loop_under: 
6de6 11 08 6e			ld de, .loop_under 
6de9 c3 9c 6e			jp .show_fault 
6dec			 
6dec .. 00		.dsp_under: db "DSP Underflow",0 
6dfa .. 00		.rsp_under: db "RSP Underflow",0 
6e08 .. 00		.loop_under: db "LOOP Underflow",0 
6e17			 
6e17			 
6e17 d5			type_faultn: 	push de 
6e18 e5					push hl 
6e19 cd 15 0d				call clear_display 
6e1c 11 43 6e				   ld de, .typefaultn 
6e1f 3e 00				ld a, display_row_1 
6e21 cd 28 0d				call str_at_display 
6e24 11 b4 fe				    ld de, debug_mark 
6e27 3e 11				ld a, display_row_1+17 
6e29 cd 28 0d				call str_at_display 
6e2c cd 38 0d				call update_display 
6e2f			 
6e2f				; prompt before entering montior for investigating issue 
6e2f			 
6e2f 3e 3c			ld a, display_row_4 
6e31 11 54 1c			ld de, endprog 
6e34			 
6e34 cd 38 0d			call update_display		 
6e37			 
6e37 cd b2 1e			call next_page_prompt 
6e3a			 
6e3a e5					push hl 
6e3b d5					push de 
6e3c cd a8 1c				call monitor 
6e3f c3 9f 1b				jp warmstart 
6e42 76					halt 
6e43			 
6e43			 
6e43 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6e5a			 
6e5a d5			type_faults: 	push de 
6e5b e5					push hl 
6e5c cd 15 0d				call clear_display 
6e5f 11 85 6e				   ld de, .typefaults 
6e62 3e 00				ld a, display_row_1 
6e64 cd 28 0d				call str_at_display 
6e67 11 b4 fe				    ld de, debug_mark 
6e6a 3e 11				ld a, display_row_1+17 
6e6c cd 28 0d				call str_at_display 
6e6f cd 38 0d				call update_display 
6e72			 
6e72				; prompt before entering montior for investigating issue 
6e72			 
6e72 3e 3c			ld a, display_row_4 
6e74 11 54 1c			ld de, endprog 
6e77			 
6e77 cd 38 0d			call update_display		 
6e7a			 
6e7a cd b2 1e			call next_page_prompt 
6e7d			 
6e7d e1					pop hl 
6e7e d1					pop de 
6e7f cd a8 1c				call monitor 
6e82 c3 9f 1b				jp warmstart 
6e85			 
6e85			 
6e85 .. 00		.typefaults: db "STR Type Expected TOS!",0 
6e9c			 
6e9c			.show_fault: 	 
6e9c d5					push de 
6e9d cd 15 0d				call clear_display 
6ea0 d1					pop de 
6ea1 3e 00				ld a, display_row_1 
6ea3 cd 28 0d				call str_at_display 
6ea6 11 b4 fe				    ld de, debug_mark 
6ea9 3e 11				ld a, display_row_1+17 
6eab cd 28 0d				call str_at_display 
6eae cd 38 0d				call update_display 
6eb1			 
6eb1				; prompt before entering montior for investigating issue 
6eb1			 
6eb1 3e 3c			ld a, display_row_4 
6eb3 11 54 1c			ld de, endprog 
6eb6			 
6eb6 cd 38 0d			call update_display		 
6eb9			 
6eb9 cd b2 1e			call next_page_prompt 
6ebc			 
6ebc e1					pop hl 
6ebd d1					pop de 
6ebe cd a8 1c				call monitor 
6ec1			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6ec1			; TODO Make optional fault restart to cli or warm boot? 
6ec1					;jp warmstart 
6ec1 c3 fa 1b				jp cli 
6ec4 76					halt 
6ec5			 
6ec5			; handle the auto run of code from files in storage 
6ec5			 
6ec5			 
6ec5			if STORAGE_SE 
6ec5			 
6ec5 .. 00		sprompt3: db "Loading from start-up file?:",0 
6ee2 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
6ef3			 
6ef3			 
6ef3			forth_autoload: 
6ef3			 
6ef3				; load block 0 of store 1 
6ef3				 
6ef3 3e fe			ld a, $fe      ; bit 0 clear 
6ef5 32 ed fb			ld (spi_device), a 
6ef8			 
6ef8 cd ca 04			call storage_get_block_0 
6efb			 
6efb 3a 28 fc			ld a, (store_page+STORE_0_AUTOFILE) 
6efe			 
6efe fe 00			cp 0 
6f00 c8				ret z     ; auto start not enabled 
6f01			 
6f01 cd 15 0d			call clear_display 
6f04			 
6f04				; set bank 
6f04			 
6f04 3a 2a fc				ld a, (store_page+STORE_0_BANKRUN) 
6f07 32 ed fb				ld (spi_device), a 
6f0a			 
6f0a				; get file id to load from and get the file name to display 
6f0a			 
6f0a 3a 2b fc				ld a, (store_page+STORE_0_FILERUN) 
6f0d			 
6f0d 2e 00				ld l, 0 
6f0f 67					ld h, a 
6f10 11 07 fc				ld de, store_page 
6f13			 
6f13					if DEBUG_FORTH_WORDS 
6f13						DMARK "ASp" 
6f13 f5				push af  
6f14 3a 28 6f			ld a, (.dmark)  
6f17 32 b4 fe			ld (debug_mark),a  
6f1a 3a 29 6f			ld a, (.dmark+1)  
6f1d 32 b5 fe			ld (debug_mark+1),a  
6f20 3a 2a 6f			ld a, (.dmark+2)  
6f23 32 b6 fe			ld (debug_mark+2),a  
6f26 18 03			jr .pastdmark  
6f28 ..			.dmark: db "ASp"  
6f2b f1			.pastdmark: pop af  
6f2c			endm  
# End of macro DMARK
6f2c						CALLMONITOR 
6f2c cd c6 18			call break_point_state  
6f2f				endm  
# End of macro CALLMONITOR
6f2f					endif 
6f2f cd 72 09				call storage_read 
6f32			 
6f32					if DEBUG_FORTH_WORDS 
6f32						DMARK "ASr" 
6f32 f5				push af  
6f33 3a 47 6f			ld a, (.dmark)  
6f36 32 b4 fe			ld (debug_mark),a  
6f39 3a 48 6f			ld a, (.dmark+1)  
6f3c 32 b5 fe			ld (debug_mark+1),a  
6f3f 3a 49 6f			ld a, (.dmark+2)  
6f42 32 b6 fe			ld (debug_mark+2),a  
6f45 18 03			jr .pastdmark  
6f47 ..			.dmark: db "ASr"  
6f4a f1			.pastdmark: pop af  
6f4b			endm  
# End of macro DMARK
6f4b						CALLMONITOR 
6f4b cd c6 18			call break_point_state  
6f4e				endm  
# End of macro CALLMONITOR
6f4e					endif 
6f4e			 
6f4e cd 72 0f				call ishlzero 
6f51 c8					ret z             ; file not found 
6f52			 
6f52 3e 1e				ld a, display_row_2 + 10 
6f54 11 0a fc				ld de, store_page+3 
6f57 cd 28 0d				call str_at_display 
6f5a				 
6f5a			; 
6f5a			 
6f5a 3e 05			ld a, display_row_1+5 
6f5c 11 c5 6e			ld de, sprompt3 
6f5f cd 28 0d			call str_at_display 
6f62 3e 37			ld a, display_row_3+15 
6f64 11 e2 6e			ld de, sprompt4 
6f67 cd 28 0d			call str_at_display 
6f6a			 
6f6a cd 38 0d			call update_display 
6f6d			 
6f6d cd b1 71			call cin_wait 
6f70 fe 6e			cp 'n' 
6f72 c8				ret z 
6f73 fe 4e			cp 'N' 
6f75 c8				ret z 
6f76			 
6f76 cd 92 0c			call delay1s 
6f79			 
6f79 3a 09 fc			ld a, (store_page+2) 
6f7c 32 f6 fb			ld (store_openmaxext), a    ; save count of ext 
6f7f 3e 01			ld a, 1  
6f81 32 f7 fb			ld (store_openext), a    ; save count of ext 
6f84			 
6f84			.autof:  
6f84 6f				ld l , a 
6f85				 
6f85 3a 07 fc			ld a, (store_page) 
6f88 67				ld h, a	 
6f89 11 07 fc			ld de, store_page 
6f8c					if DEBUG_FORTH_WORDS 
6f8c						DMARK "ASl" 
6f8c f5				push af  
6f8d 3a a1 6f			ld a, (.dmark)  
6f90 32 b4 fe			ld (debug_mark),a  
6f93 3a a2 6f			ld a, (.dmark+1)  
6f96 32 b5 fe			ld (debug_mark+1),a  
6f99 3a a3 6f			ld a, (.dmark+2)  
6f9c 32 b6 fe			ld (debug_mark+2),a  
6f9f 18 03			jr .pastdmark  
6fa1 ..			.dmark: db "ASl"  
6fa4 f1			.pastdmark: pop af  
6fa5			endm  
# End of macro DMARK
6fa5						CALLMONITOR 
6fa5 cd c6 18			call break_point_state  
6fa8				endm  
# End of macro CALLMONITOR
6fa8					endif 
6fa8 cd 72 09				call storage_read 
6fab cd 72 0f			call ishlzero 
6fae c8				ret z 
6faf			;	jr z, .autoend 
6faf			 
6faf					if DEBUG_FORTH_WORDS 
6faf						DMARK "ASc" 
6faf f5				push af  
6fb0 3a c4 6f			ld a, (.dmark)  
6fb3 32 b4 fe			ld (debug_mark),a  
6fb6 3a c5 6f			ld a, (.dmark+1)  
6fb9 32 b5 fe			ld (debug_mark+1),a  
6fbc 3a c6 6f			ld a, (.dmark+2)  
6fbf 32 b6 fe			ld (debug_mark+2),a  
6fc2 18 03			jr .pastdmark  
6fc4 ..			.dmark: db "ASc"  
6fc7 f1			.pastdmark: pop af  
6fc8			endm  
# End of macro DMARK
6fc8						CALLMONITOR 
6fc8 cd c6 18			call break_point_state  
6fcb				endm  
# End of macro CALLMONITOR
6fcb					endif 
6fcb 11 09 fc			ld de, store_page+2 
6fce 3e 3c			ld a, display_row_4 
6fd0 cd 28 0d			call str_at_display 
6fd3			 
6fd3 cd 38 0d			call update_display 
6fd6 cd 86 0c			call delay250ms 
6fd9			 
6fd9			 
6fd9			 
6fd9 21 09 fc			ld hl, store_page+2 
6fdc cd 2e 23			call forthparse 
6fdf cd 6e 23			call forthexec 
6fe2 cd 80 22			call forthexec_cleanup 
6fe5			 
6fe5				 
6fe5 3a f7 fb			ld a, (store_openext) 
6fe8 3c				inc a 
6fe9 32 f7 fb			ld (store_openext), a    ; save count of ext 
6fec			 
6fec 18 96			jr .autof 
6fee			;.autofdone: 
6fee			; 
6fee			;		if DEBUG_FORTH_WORDS 
6fee			;			DMARK "ASx" 
6fee			;			CALLMONITOR 
6fee			;		endif 
6fee			;;	call clear_display 
6fee			;	ret 
6fee			 
6fee			 
6fee			 
6fee			endif 
6fee			 
6fee			 
6fee			; eof 
# End of file forth_kernel.asm
6fee			;include "nascombasic.asm" 
6fee			 
6fee			 
6fee			; find out where the code ends if loaded into RAM (for SC114) 
6fee			;endofcode:  
6fee			;	nop 
6fee			 
6fee			 
6fee			; eof 
6fee			 
# End of file main.asm
6fee			include "firmware_lcd_4x20.asm" 
6fee			; **********************************************************************  
6fee			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6fee			; **********************************************************************  
6fee			;  
6fee			; **  Written as a Small Computer Monitor App  
6fee			; **  www.scc.me.uk  
6fee			;  
6fee			; History  
6fee			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6fee			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6fee			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6fee			;  
6fee			; **********************************************************************  
6fee			;  
6fee			; This program is an example of one of the methods of interfacing an   
6fee			; alphanumeric LCD module.   
6fee			;  
6fee			; In this example the display is connected to either a Z80 PIO or a   
6fee			; simple 8-bit output port.   
6fee			;  
6fee			; This interfacing method uses 4-bit data mode and uses time delays  
6fee			; rather than polling the display's ready status. As a result the   
6fee			; interface only requires 6 simple output lines:  
6fee			;   Output bit 0 = not used  
6fee			;   Output bit 1 = not used  
6fee			;   Output bit 2 = RS         High = data, Low = instruction  
6fee			;   Output bit 3 = E          Active high  
6fee			;   Output bit 4 = DB4  
6fee			;   Output bit 5 = DB5  
6fee			;   Output bit 6 = DB6  
6fee			;   Output bit 7 = DB7  
6fee			; Display's R/W is connected to 0v so it is always in write mode  
6fee			;  
6fee			; This set up should work with any system supporting the RC2014 bus  
6fee			  
6fee			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6fee			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6fee			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6fee			;  
6fee			; **********************************************************************  
6fee			  
6fee			; **********************************************************************  
6fee			; **  Constants  
6fee			; **********************************************************************  
6fee			; LCD constants required by LCD support module  
6fee			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6fee			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6fee			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
6fee			kLCDWidth:  EQU display_cols             ;Width in characters  
6fee			  
6fee			; **********************************************************************  
6fee			; **  Code library usage  
6fee			; **********************************************************************  
6fee			  
6fee			; send character to current cursor position  
6fee			; wraps and/or scrolls screen automatically  
6fee			  
6fee			  
6fee			lcd_init:  
6fee			  
6fee			; SCMonAPI functions used  
6fee			  
6fee			; Alphanumeric LCD functions used  
6fee			; no need to specify specific functions for this module  
6fee			  
6fee 3e cf		            LD   A, 11001111b  
6ff0 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6ff2 3e 00		            LD   A, 00000000b  
6ff4 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6ff6			  
6ff6			; Initialise alphanumeric LCD module  
6ff6 cd 6f 70		            CALL fLCD_Init      ;Initialise LCD module  
6ff9			  
6ff9 c9				ret  
6ffa			  
6ffa			;  
6ffa			;;  
6ffa			; lcd functions  
6ffa			;  
6ffa			;  
6ffa			  
6ffa			; what is at cursor position   
6ffa			  
6ffa			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6ffa			;		call curptr  
6ffa			;		ret  
6ffa			  
6ffa			  
6ffa			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6ffa			  
6ffa			curptr:  
6ffa c5				push bc  
6ffb 21 4a fe			ld hl, display_fb0  
6ffe			cpr:	  
6ffe				; loop for cursor whole row  
6ffe 0e 14			ld c, display_cols  
7000 23			cpr1:	inc hl  
7001 0d				dec c  
7002 20 fc			jr nz, cpr1  
7004 05				dec b  
7005 20 f7			jr nz, cpr  
7007			  
7007				; add col	  
7007			  
7007 23			cpr2:	inc hl  
7008 1d				dec e  
7009 20 fc			jr nz, cpr2  
700b			  
700b c1				pop bc  
700c c9				ret  
700d				  
700d			  
700d			  
700d			  
700d			  
700d			; write the frame buffer given in hl to hardware   
700d 22 52 fd		write_display: ld (display_write_tmp), hl 	   
7010 3e 00			ld a, kLCD_Line1  
7012 cd e0 70		            CALL fLCD_Pos       ;Position cursor to location in A  
7015 06 14			ld b, display_cols  
7017 ed 5b 52 fd		ld de, (display_write_tmp)  
701b cd 67 70			call write_len_string  
701e				  
701e				  
701e 2a 52 fd			ld hl, (display_write_tmp)  
7021 11 14 00			ld de, display_cols  
7024 19				add hl,de  
7025 22 52 fd			ld (display_write_tmp),hl  
7028			  
7028				  
7028 3e 40			ld a, kLCD_Line2  
702a cd e0 70		            CALL fLCD_Pos       ;Position cursor to location in A  
702d 06 14			ld b, display_cols  
702f ed 5b 52 fd		ld de, (display_write_tmp)  
7033 cd 67 70			call write_len_string  
7036				  
7036 2a 52 fd			ld hl, (display_write_tmp)  
7039 11 14 00			ld de, display_cols  
703c 19				add hl,de  
703d 22 52 fd			ld (display_write_tmp),hl  
7040			  
7040				  
7040 3e 14			ld a, kLCD_Line3  
7042 cd e0 70		            CALL fLCD_Pos       ;Position cursor to location in A  
7045 06 14			ld b, display_cols  
7047 ed 5b 52 fd		ld de, (display_write_tmp)  
704b cd 67 70			call write_len_string  
704e				  
704e 2a 52 fd			ld hl, (display_write_tmp)  
7051 11 14 00			ld de, display_cols  
7054 19				add hl,de  
7055 22 52 fd			ld (display_write_tmp),hl  
7058			  
7058				  
7058 3e 54			ld a, kLCD_Line4  
705a cd e0 70		            CALL fLCD_Pos       ;Position cursor to location in A  
705d 06 14			ld b, display_cols  
705f ed 5b 52 fd		ld de, (display_write_tmp)  
7063 cd 67 70			call write_len_string  
7066 c9					ret  
7067				  
7067				; write out a fixed length string given in b from de  
7067			  
7067 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
7068 cd b9 70		            CALL fLCD_Data      ;Write character to display  
706b 13				inc de  
706c 10 f9			djnz write_len_string  
706e c9				ret  
706f			  
706f			; Some other things to do  
706f			;            LD   A, kLCD_Clear ;Display clear  
706f			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
706f			;            LD   A, kLCD_Under ;Display on with underscore cursor  
706f			;            LD   A, kLCD_On     ;Display on with no cursor  
706f			;            ;LD   A, kLCD_Off   ;Display off  
706f			;            CALL fLCD_Inst      ;Send instruction to display  
706f			;  
706f			;  
706f			;            halt  
706f			;  
706f			;  
706f			;MsgHello:   DB  "Hello World!",0  
706f			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
706f			  
706f			; Custom characters 5 pixels wide by 8 pixels high  
706f			; Up to 8 custom characters can be defined  
706f			;BitMaps:      
706f			;; Character 0x00 = Battery icon  
706f			;            DB  01110b  
706f			;            DB  11011b  
706f			;            DB  10001b  
706f			;            DB  10001b  
706f			;            DB  11111b  
706f			;            DB  11111b  
706f			;            DB  11111b  
706f			;            DB  11111b  
706f			;; Character 0x01 = Bluetooth icon  
706f			;            DB  01100b  
706f			;            DB  01010b  
706f			;            DB  11100b  
706f			;            DB  01000b  
706f			;            DB  11100b  
706f			;            DB  01010b  
706f			;            DB  01100b  
706f			;            DB  00000b  
706f			;  
706f			  
706f			  
706f			; **********************************************************************  
706f			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
706f			; **********************************************************************  
706f			;  
706f			; **  Written as a Small Computer Monitor App   
706f			; **  Version 0.1 SCC 2018-05-16  
706f			; **  www.scc.me.uk  
706f			;  
706f			; **********************************************************************  
706f			;  
706f			; This module provides support for alphanumeric LCD modules using with  
706f			; *  HD44780 (or compatible) controller  
706f			; *  5 x 7 pixel fonts  
706f			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
706f			; *  Interface via six digital outputs to the display (see below)  
706f			;  
706f			; LCD module pinout:  
706f			;   1  Vss   0v supply  
706f			;   2  Vdd   5v supply  
706f			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
706f			;   4  RS    High = data, Low = instruction  
706f			;   5  R/W   High = Read, Low = Write  
706f			;   6  E     Enable signal (active high)  
706f			;   7  DB0   Data bit 0  
706f			;   8  DB1   Data bit 1  
706f			;   9  DB2   Data bit 2  
706f			;  10  DB3   Data bit 3  
706f			;  11  DB4   Data bit 4  
706f			;  12  DB5   Data bit 5  
706f			;  13  DB6   Data bit 6  
706f			;  14  DB7   Data bit 7  
706f			;  15  A     Backlight anode (+)  
706f			;  16  K     Backlight cathode (-)  
706f			;  
706f			; This interfacing method uses 4-bit data mode and uses time delays  
706f			; rather than polling the display's ready status. As a result the   
706f			; interface only requires 6 simple output lines:  
706f			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
706f			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
706f			;   LCD DB4 = Microcomputer output port bit 4  
706f			;   LCD DB5 = Microcomputer output port bit 5  
706f			;   LCD DB6 = Microcomputer output port bit 6  
706f			;   LCD DB7 = Microcomputer output port bit 7  
706f			; Display's R/W is connected to 0v so it is always in write mode  
706f			; All 6 connections must be on the same port address <kLCDPrt>  
706f			; This method also allows a decent length of cable from micro to LCD  
706f			;  
706f			; **********************************************************************  
706f			;  
706f			; To include the code for any given function provided by this module,   
706f			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
706f			; the parent source file.  
706f			; For example:  #REQUIRES   uHexPrefix  
706f			;  
706f			; Also #INCLUDE this file at some point after the #REQUIRES statements  
706f			; in the parent source file.  
706f			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
706f			;  
706f			; These are the function names provided by this module:  
706f			; fLCD_Init                     ;Initialise LCD  
706f			; fLCD_Inst                     ;Send instruction to LCD  
706f			; fLCD_Data                     ;Send data byte to LCD  
706f			; fLCD_Pos                      ;Position cursor  
706f			; fLCD_Str                      ;Display string  
706f			; fLCD_Def                      ;Define custom character  
706f			;  
706f			; **********************************************************************  
706f			;  
706f			; Requires SCMonAPI.asm to also be included in the project  
706f			;  
706f			  
706f			  
706f			; **********************************************************************  
706f			; **  Constants  
706f			; **********************************************************************  
706f			  
706f			; Constants that must be defined externally  
706f			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
706f			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
706f			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
706f			;kLCDWidth: EQU 20             ;Width in characters  
706f			  
706f			; general line offsets in any frame buffer  
706f			  
706f			  
706f			display_row_1: equ 0  
706f			display_row_2: equ display_row_1+display_cols  
706f			display_row_3: equ display_row_2 + display_cols  
706f			display_row_4: equ display_row_3 + display_cols  
706f			;display_row_4_eol:   
706f			  
706f			  
706f			; Cursor position values for the start of each line  
706f			kLCD_Line1: EQU 0x00   
706f			kLCD_Line2: EQU 0x40    
706f			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
706f			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
706f			  
706f			; Instructions to send as A register to fLCD_Inst  
706f			kLCD_Clear: EQU 00000001b     ;LCD clear  
706f			kLCD_Off:   EQU 00001000b     ;LCD off  
706f			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
706f			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
706f			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
706f			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
706f			  
706f			; Constants used by this code module  
706f			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
706f			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
706f			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
706f			  
706f			  
706f			  
706f			; **********************************************************************  
706f			; **  LCD support functions  
706f			; **********************************************************************  
706f			  
706f			; Initialise alphanumeric LCD module  
706f			; LCD control register codes:  
706f			;   DL   0 = 4-bit mode        1 = 8-bit mode  
706f			;   N    0 = 1-line mode       1 = 2-line mode  
706f			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
706f			;   D    0 = Display off       1 = Display on  
706f			;   C    0 = Cursor off        1 = Cursor on  
706f			;   B    0 = Blinking off      1 = Blinking on  
706f			;   ID   0 = Decrement mode    1 = Increment mode  
706f			;   SH   0 = Entire shift off  1 = Entire shift on  
706f 3e 28		fLCD_Init:  LD   A, 40  
7071 cd 26 71		            CALL LCDDelay       ;Delay 40ms after power up  
7074			; For reliable reset set 8-bit mode - 3 times  
7074 cd 10 71		            CALL WrFn8bit       ;Function = 8-bit mode  
7077 cd 10 71		            CALL WrFn8bit       ;Function = 8-bit mode  
707a cd 10 71		            CALL WrFn8bit       ;Function = 8-bit mode  
707d			; Set 4-bit mode  
707d cd 0c 71		            CALL WrFn4bit       ;Function = 4-bit mode  
7080 cd 24 71		            CALL LCDDelay1      ;Delay 37 us or more  
7083			; Function set  
7083 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
7085 cd 98 70		            CALL fLCD_Inst      ;2 line, display on  
7088			; Display On/Off control  
7088 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
708a cd 98 70		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
708d			; Display Clear  
708d 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
708f cd 98 70		            CALL fLCD_Inst      ;Clear display  
7092			; Entry mode  
7092 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
7094 cd 98 70		            CALL fLCD_Inst      ;Increment mode, shift off  
7097			; Display module now initialised  
7097 c9			            RET  
7098			; ok to here  
7098			  
7098			; Write instruction to LCD  
7098			;   On entry: A = Instruction byte to be written  
7098			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7098 f5			fLCD_Inst:  PUSH AF  
7099 f5			            PUSH AF  
709a cd ac 70		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
709d f1			            POP  AF  
709e 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
709f 17			            RLA  
70a0 17			            RLA  
70a1 17			            RLA  
70a2 cd ac 70		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
70a5 3e 02		            LD   A, 2  
70a7 cd 26 71		            CALL LCDDelay       ;Delay 2 ms to complete   
70aa f1			            POP  AF  
70ab c9			            RET  
70ac e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
70ae d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70b0 cb df		            SET  kLCDBitE, A  
70b2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
70b4 cb 9f		            RES  kLCDBitE, A  
70b6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70b8 c9			            RET  
70b9			  
70b9			  
70b9			; Write data to LCD  
70b9			;   On entry: A = Data byte to be written  
70b9			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
70b9 f5			fLCD_Data:  PUSH AF  
70ba f5			            PUSH AF  
70bb cd cd 70		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
70be f1			            POP  AF  
70bf 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
70c0 17			            RLA  
70c1 17			            RLA  
70c2 17			            RLA  
70c3 cd cd 70		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
70c6 3e 96		            LD   A, 150  
70c8 3d			Wait:      DEC  A              ;Wait a while to allow data   
70c9 20 fd		            JR   NZ, Wait      ;  write to complete  
70cb f1			            POP  AF  
70cc c9			            RET  
70cd e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
70cf cb d7		            SET  kLCDBitRS, A  
70d1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
70d3 cb df		            SET  kLCDBitE, A  
70d5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
70d7 cb 9f		            RES  kLCDBitE, A  
70d9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
70db cb 97		            RES  kLCDBitRS, A  
70dd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70df c9			            RET  
70e0			  
70e0			  
70e0			; Position cursor to specified location  
70e0			;   On entry: A = Cursor position  
70e0			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
70e0 f5			fLCD_Pos:   PUSH AF  
70e1 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
70e3 cd 98 70		            CALL fLCD_Inst      ;Write instruction to LCD  
70e6 f1			            POP  AF  
70e7 c9			            RET  
70e8			  
70e8			  
70e8			; Output text string to LCD  
70e8			;   On entry: DE = Pointer to null terminated text string  
70e8			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
70e8 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
70e9 b7			            OR   A              ;Null terminator?  
70ea c8			            RET  Z              ;Yes, so finished  
70eb cd b9 70		            CALL fLCD_Data      ;Write character to display  
70ee 13			            INC  DE             ;Point to next character  
70ef 18 f7		            JR   fLCD_Str       ;Repeat  
70f1 c9					ret  
70f2			  
70f2			; Define custom character  
70f2			;   On entry: A = Character number (0 to 7)  
70f2			;             DE = Pointer to character bitmap data  
70f2			;   On exit:  A = Next character number  
70f2			;             DE = Next location following bitmap  
70f2			;             BC HL IX IY I AF' BC' DE' HL' preserved  
70f2			; Character is   
70f2 c5			fLCD_Def:   PUSH BC  
70f3 f5			            PUSH AF  
70f4 07			            RLCA                ;Calculate location  
70f5 07			            RLCA                ;  for bitmap data  
70f6 07			            RLCA                ;  = 8 x CharacterNumber  
70f7 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
70f9 cd 98 70		            CALL fLCD_Inst      ;Write instruction to LCD  
70fc 06 00		            LD   B, 0  
70fe 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
70ff cd b9 70		            CALL fLCD_Data      ;Write byte to display  
7102 13			            INC  DE             ;Point to next byte  
7103 04			            INC  B              ;Count bytes  
7104 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
7106 28 f6		            JR   Z, Loop       ;No, so repeat  
7108 f1			            POP  AF  
7109 3c			            INC  A              ;Increment character number  
710a c1			            POP  BC  
710b c9			            RET  
710c			  
710c			  
710c			; **********************************************************************  
710c			; **  Private functions  
710c			; **********************************************************************  
710c			  
710c			; Write function to LCD  
710c			;   On entry: A = Function byte to be written  
710c			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
710c 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
710e 18 02		            JR   WrFunc  
7110 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
7112 f5			WrFunc:     PUSH AF  
7113 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7115 cb df		            SET  kLCDBitE, A  
7117 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7119 cb 9f		            RES  kLCDBitE, A  
711b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
711d 3e 05		            LD   A, 5  
711f cd 26 71		            CALL LCDDelay       ;Delay 5 ms to complete  
7122 f1			            POP  AF  
7123 c9			            RET  
7124			  
7124			  
7124			; Delay in milliseconds  
7124			;   On entry: A = Number of milliseconds delay  
7124			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7124 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
7126 d5			LCDDelay:   PUSH DE  
7127 5f			            LD   E, A           ;Delay by 'A' ms  
7128 16 00		            LD   D, 0  
712a cd 77 0c		            CALL aDelayInMS  
712d d1			            POP  DE  
712e c9			            RET  
712f			  
712f			  
712f			  
712f			  
712f			; eof  
712f			  
# End of file firmware_lcd_4x20.asm
712f			include "firmware_key_4x4.asm" 
712f			  
712f			  
712f			; bit mask for each scan column and row for teing the matrix  
712f			  
712f			; out   
712f 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
7133			; in  
7133 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
7137			  
7137			; row/col to character map  
7137			  
7137			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
7137			;    
7137			  
7137			; physical key matrix map to face of key  
7137			  
7137			  
7137			;      	1	2	3	A  
7137			;   	abc”	def&	ghi$	s1  
7137			;			  
7137			;	4	5	6	B  
7137			; 	jkl,	mno.	pqr:	s2  
7137			;			  
7137			; 	7	8	9	C  
7137			;	stu;	vwx@	yz?!	s3  
7137			;			  
7137			; 	*	0	#	D  
7137			; 	shift lck '	Space < >	Enter ( )	s4  
7137			;       tab bs 		  
7137			  
7137			  
7137			  
7137			  
7137			key_init:  
7137			  
7137			; SCMonAPI functions used  
7137			  
7137			; Alphanumeric LCD functions used  
7137			; no need to specify specific functions for this module  
7137			  
7137			  
7137 3e cf		            LD   A, 11001111b  
7139 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
713b			;            LD   A, 00000000b  
713b 3e 0f		            LD   A, 00001111b  
713d d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
713f			  
713f			  
713f				; TODO Configure cursor shapes  
713f			  
713f				; Load cursor shapes   
713f 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
7141 11 51 71		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
7144 06 02		            LD   B, 2           ;Number of characters to define  
7146 cd f2 70		.DefLoop:   CALL fLCD_Def       ;Define custom character  
7149 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
714b			  
714b 3e 01				ld a, 1  
714d 32 4d fd			ld (cursor_shape),a  
7150 c9				ret  
7151			  
7151			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
7151			; Up to 8 custom characters can be defined  
7151			.cursor_shapes:      
7151			;; Character 0x00 = Normal  
7151 1f			            DB  11111b  
7152 1f			            DB  11111b  
7153 1f			            DB  11111b  
7154 1f			            DB  11111b  
7155 1f			            DB  11111b  
7156 1f			            DB  11111b  
7157 1f			            DB  11111b  
7158 1f			            DB  11111b  
7159			;; Character 0x01 = Modifier  
7159 1f			            DB  11111b  
715a 1b			            DB  11011b  
715b 1b			            DB  11011b  
715c 1b			            DB  11011b  
715d 1b			            DB  11011b  
715e 1f			            DB  11111b  
715f 1b			            DB  11011b  
7160 1f			            DB  11111b  
7161			  
7161			  
7161			  
7161			  
7161			; Display custom character 0  
7161			;            LD   A, kLCD_Line1+14  
7161			;            CALL fLCD_Pos       ;Position cursor to location in A  
7161			;            LD   A, 0  
7161			;            CALL fLCD_Data      ;Write character in A at cursor  
7161			  
7161			; Display custom character 1  
7161			;            LD   A, kLCD_Line2+14  
7161			;            CALL fLCD_Pos      ;Position cursor to location in A  
7161			;            LD   A, 1  
7161			;            CALL fLCD_Data     ;Write character in A at cursor  
7161			  
7161			; keyboard scanning   
7161			  
7161			  
7161			; key_rows: equ 4  
7161			; key_cols: equ 4  
7161			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
7161			  
7161			; key_scanr: equ key_row_bitmask  
7161			; key_scanc: equ key_col_bitmask  
7161			  
7161			; key_char_map: equ key_map  
7161			  
7161			  
7161			  
7161			; character in from keyboard  
7161			  
7161 ..			.matrix_to_char: db "D#0*C987B654A321"  
7171			  
7171			  
7171			; map the physical key to a char dependant on state  
7171			  
7171			.key_map_fa:   
7171			  
7171 ..					db 'D'  
7172 0d					db KEY_CR    ; cr  
7173 ..					db ' '  
7174 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
7175 ..					db 'C'  
7176 ..					db 'y'  
7177 ..					db 'v'  
7178 ..					db 's'  
7179 ..					db 'B'  
717a ..					db 'p'  
717b ..					db 'm'  
717c ..					db 'j'  
717d ..					db 'A'  
717e ..					db 'g'  
717f ..					db 'd'  
7180 ..					db 'a'  
7181			  
7181			.key_map_fb:  
7181			  
7181 ..					db 'A'  
7182 ..					db '+'   
7183 ..					db '<'  
7184 ..					db  "'"    
7185			  
7185 ..					db 'A'  
7186 ..					db 'z'  
7187 ..					db 'w'  
7188 ..					db 't'  
7189 ..					db 'A'  
718a ..					db 'q'  
718b ..					db 'n'  
718c ..					db 'k'  
718d ..					db 'A'  
718e ..					db 'h'  
718f ..					db 'e'  
7190 ..			 		db 'b'  
7191			  
7191			.key_map_fc:   
7191			  
7191			  
7191 ..					db 'A'  
7192 ..					db '-'   
7193 ..					db '>'  
7194 ..					db  '='   	  
7195 ..					db 'A'  
7196 ..					db '?'  
7197 ..					db 'x'  
7198 ..					db 'u'  
7199 ..					db 'A'  
719a ..					db 'r'  
719b ..					db 'o'  
719c ..					db 'l'  
719d ..					db 'A'  
719e ..					db 'i'  
719f ..					db 'f'  
71a0 ..					db 'c'  
71a1			  
71a1				  
71a1			.key_map_fd:  
71a1			  
71a1 ..					db 'A'  
71a2 ..					db '/'   
71a3 ..					db '%'   
71a4 08					db KEY_BS  ; back space  
71a5 ..					db 'A'  
71a6 ..					db '!'  
71a7 ..					db '@'  
71a8 ..					db ';'  
71a9 ..					db 'A'  
71aa ..					db ':'  
71ab ..					db '.'  
71ac ..					db ','  
71ad ..					db 'A'  
71ae ..					db '$'  
71af ..					db '&'  
71b0 ..				 	db '"'  
71b1			  
71b1					  
71b1				  
71b1			  
71b1			; add cin and cin_wait  
71b1			  
71b1 cd c2 71		cin_wait: 	call cin  
71b4 fe 00			cp 0  
71b6 28 f9			jr z, cin_wait   ; block until key press  
71b8			  
71b8 f5				push af   ; save key pressed  
71b9			  
71b9 cd c2 71		.cin_wait1:	call cin  
71bc fe 00			cp 0  
71be 20 f9			jr nz, .cin_wait1  	; wait for key release  
71c0			  
71c0 f1				pop af   ; get key  
71c1 c9				ret  
71c2			  
71c2			  
71c2 cd d3 71		cin: 	call .mtoc  
71c5			  
71c5				; no key held  
71c5 fe 00			cp 0  
71c7 c8				ret z  
71c8			  
71c8				; stop key bounce  
71c8			  
71c8			;	ld (key_held),a		 ; save it  
71c8 47				ld b, a  
71c9			  
71c9 c5			.cina1:	push bc  
71ca cd d3 71			call .mtoc  
71cd c1				pop bc  
71ce b8				cp b  
71cf 28 f8			jr z, .cina1  
71d1 78				ld a,b		  
71d2 c9				ret  
71d3			  
71d3			; detect keyboard modifier key press and apply new overlay to the face key held  
71d3			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
71d3			  
71d3			;.cin_map_modifier:   
71d3			;	ld a, (hl)  
71d3			;	and 255  
71d3			;	ret NZ		; modifier key not flagged  
71d3			;  
71d3			;	; get key face  
71d3			;  
71d3			;	ld b,(key_face_held)  
71d3			;  
71d3			;	ld b, key_cols * key_rows  
71d3			;  
71d3			;	push de  
71d3			;	pop hl  
71d3			;  
71d3			;.mmod1: ld a,(hl)   ; get map test  
71d3			;	cp b  
71d3			;	jr z, .mmod2  
71d3			;  
71d3			;  
71d3			;  
71d3			;.mmod2: inc hl    ;   
71d3			;  
71d3			;	  
71d3			;  
71d3			;	  
71d3			;  
71d3			;	ld hl,key_actual_pressed  
71d3			;	ld (hl),a,  
71d3			;	ret  
71d3			  
71d3				  
71d3			  
71d3			; map matrix key held to char on face of key  
71d3			  
71d3			.mtoc:  
71d3			  
71d3			  
71d3				; TODO optimise the code....  
71d3			  
71d3			; scan keyboard row 1  
71d3 3e 80			ld a, 128  
71d5 21 d3 fe			ld hl, keyscan_table  
71d8 cd ba 72			call .rowscan  
71db			  
71db				   
71db			  
71db 3e 40			ld a, 64  
71dd 21 d7 fe			ld hl, keyscan_table+key_cols  
71e0 cd ba 72			call .rowscan  
71e3			  
71e3			  
71e3			  
71e3			  
71e3 3e 20			ld a, 32  
71e5 21 db fe			ld hl, keyscan_table+(key_cols*2)  
71e8 cd ba 72			call .rowscan  
71eb			  
71eb			  
71eb			  
71eb 3e 10			ld a, 16  
71ed 21 df fe			ld hl, keyscan_table+(key_cols*3)  
71f0 cd ba 72			call .rowscan  
71f3			  
71f3			  
71f3				; flag if key D is held down and remove from reporting  
71f3 01 a1 71			ld bc, .key_map_fd    
71f6 21 d3 fe			ld hl, keyscan_table  
71f9 11 c5 fe			ld de, key_fd  
71fc cd 4c 72			call .key_shift_hold  
71ff fe ff			cp 255  
7201 28 33			jr z, .cinmap  
7203				; flag if key C is held down and remove from reporting  
7203 01 91 71			ld bc, .key_map_fc    
7206 21 d7 fe			ld hl, keyscan_table+key_cols  
7209 11 c6 fe			ld de, key_fc  
720c cd 4c 72			call .key_shift_hold  
720f fe ff			cp 255  
7211 28 23			jr z, .cinmap  
7213				; flag if key B is held down and remove from reporting  
7213 01 81 71			ld bc, .key_map_fb    
7216 21 db fe			ld hl, keyscan_table+(key_cols*2)  
7219 11 c7 fe			ld de, key_fb  
721c cd 4c 72			call .key_shift_hold  
721f fe ff			cp 255  
7221 28 13			jr z, .cinmap  
7223				; flag if key A is held down and remove from reporting  
7223 01 71 71			ld bc, .key_map_fa    
7226 21 df fe			ld hl, keyscan_table+(key_cols*3)  
7229 11 c8 fe			ld de, key_fa  
722c cd 4c 72			call .key_shift_hold  
722f fe ff			cp 255  
7231 28 03			jr z, .cinmap  
7233			  
7233 11 61 71			ld de, .matrix_to_char  
7236			  
7236			  
7236			.cinmap:   
7236				if DEBUG_KEY  
7236			            LD   A, kLCD_Line4  
7236			            CALL fLCD_Pos       ;Position cursor to location in A  
7236					push de  
7236			            LD   DE, keyscan_table  
7236			            CALL fLCD_Str       ;Display string pointed to by DE  
7236					pop de  
7236				endif  
7236			  
7236				; scan key matrix table for any held key  
7236			  
7236				; de holds either the default matrix or one selected above  
7236			  
7236 21 d3 fe			ld hl, keyscan_table  
7239 06 10			ld b,key_cols*key_rows  
723b			  
723b 7e			.cin1:	ld a,(hl)  
723c fe 23			cp '#'  
723e 28 08			jr z, .cinhit  
7240 23				inc hl  
7241 13				inc de  
7242 05				dec b  
7243 20 f6			jr nz, .cin1  
7245				; no key found held  
7245 3e 00			ld a,0  
7247 c9				ret  
7248 d5			.cinhit: push de  
7249 e1				pop hl  
724a 7e				ld a,(hl)  
724b c9				ret  
724c			  
724c			; flag a control key is held   
724c			; hl is key pin, de is flag indicator  
724c			  
724c			.key_shift_hold:  
724c c5				push bc  
724d 3e 01			ld a, 1  
724f 32 4d fd			ld (cursor_shape),a  
7252 06 00			ld b, 0  
7254 7e				ld a, (hl)  
7255 fe 2e			cp '.'  
7257 28 0a			jr z, .key_shift1  
7259 06 ff			ld b, 255  
725b 3e 2b			ld a, '+'    ; hide key from later scans  
725d 77				ld (hl),a  
725e 3e 02			ld a, 2  
7260 32 4d fd			ld (cursor_shape),a  
7263			.key_shift1:  
7263				; write flag indicator  
7263 78				ld a,b  
7264 12				ld (de),a  
7265			  
7265 d1				pop de    ; de now holds the key map ptr  
7266 c9				ret  
7267			  
7267				  
7267				  
7267			  
7267			  
7267			  
7267			  
7267			  
7267			  
7267			  
7267			  
7267			  
7267			  
7267 c9				ret  
7268			  
7268			;	push hl  
7268			;	push de  
7268			;	push bc  
7268			;	call keyscan  
7268			;	; map key matrix to ascii value of key face  
7268			;  
7268			;	ld hl, key_face_map  
7268			;	ld de, keyscan_table  
7268			;  
7268			;	; get how many keys to look at  
7268			;	ld b, keyscan_table_len  
7268			;	  
7268			;  
7268			;	; at this stage fall out on first key hit  
7268			;	; TODO handle multiple key press  
7268			;  
7268			;map1:	ld a,(hl)  
7268			;	cp '#'  
7268			;	jr z, keyhit  
7268			;	inc hl  
7268			;	inc de  
7268			;	dec b  
7268			;	jr nz, map1  
7268			;nohit:	ld a, 0  
7268			;	jr keydone  
7268			;keyhit: push de  
7268			;	pop hl  
7268			;	ld a,(hl)  
7268			;keydone:  
7268			;	push bc  
7268			;	push de  
7268			; 	push hl  
7268			;	ret   
7268			;  
7268			  
7268			  
7268			  
7268			  
7268			; scan physical key matrix  
7268			  
7268			  
7268			;keyscan:  
7268			;  
7268			;; for each key_row use keyscanr bit mask for out  
7268			;; then read in for keyscanc bitmask  
7268			;; save result of row scan to keyscantable  
7268			;  
7268			;; scan keyboard row 1  
7268			;  
7268			;	ld b, key_rows  
7268			;	ld hl, key_scanr  
7268			;	ld de, keyscan_table  
7268			;  
7268			;rowloop:  
7268			;  
7268			;	ld a,(hl)		; out bit mask to energise keyboard row  
7268			;	call rowscan  
7268			;	inc hl  
7268			;	dec b  
7268			;	jr nz, rowloop  
7268			;  
7268			;	ret  
7268			;  
7268			;  
7268			;; pass a out bitmask, b row number  
7268			;arowscan:   
7268			;	push bc  
7268			;  
7268			;	ld d, b  
7268			;  
7268			;	; calculate buffer location for this row  
7268			;  
7268			;	ld hl, keyscan_table	  
7268			;kbufr:  ld e, key_cols  
7268			;kbufc:	inc hl  
7268			;	dec e  
7268			;	jr nz, kbufc  
7268			;	dec d  
7268			;	jr nz, kbufr  
7268			;  
7268			;	; energise row and read columns  
7268			;  
7268			;	out (portbdata),a  
7268			;	in a,(portbdata)  
7268			;	ld c,a  
7268			;  
7268			;  
7268			;	; save buffer loc  
7268			;  
7268			;	ld (keybufptr), hl  
7268			;  
7268			;	ld hl, key_scanc  
7268			;	ld d, key_cols  
7268			;  
7268			;	; for each column check each bit mask  
7268			;  
7268			;colloop:  
7268			;	  
7268			;  
7268			;	; reset flags for the row   
7268			;  
7268			;	ld b,'.'  
7268			;	and (hl)  
7268			;	jr z, maskskip  
7268			;	ld b,'#'  
7268			;maskskip:  
7268			;	; save  key state  
7268			;	push hl  
7268			;	ld hl, (keybufptr)  
7268			;	ld (hl), b  
7268			;	inc hl  
7268			;	ld (keybufptr), hl  
7268			;  
7268			;	; move to next bit mask  
7268			;	pop hl  
7268			;	inc hl  
7268			;  
7268			;	dec d  
7268			;	jr nz, colloop  
7268			;  
7268			;	ret  
7268			;  
7268			;  
7268			;;  
7268			; lcd functions  
7268			;  
7268			;  
7268			  
7268			;if DEBUG_KEY_MATRIX  
7268			  
7268			; test function to display hardware view of matrix state  
7268			  
7268			matrix:  
7268			  
7268			  
7268			  
7268			; scan keyboard row 1  
7268 3e 80			ld a, 128  
726a 21 f8 fe			ld hl, keyscan_table_row1  
726d cd ba 72			call .rowscan  
7270			  
7270 3e 40			ld a, 64  
7272 21 f3 fe			ld hl, keyscan_table_row2  
7275 cd ba 72			call .rowscan  
7278			  
7278 3e 20			ld a, 32  
727a 21 ee fe			ld hl, keyscan_table_row3  
727d cd ba 72			call .rowscan  
7280			  
7280 3e 10			ld a, 16  
7282 21 e9 fe			ld hl, keyscan_table_row4  
7285 cd ba 72			call .rowscan  
7288			  
7288			; Display text on first line  
7288 3e 00		            LD   A, kLCD_Line1  
728a cd e0 70		            CALL fLCD_Pos       ;Position cursor to location in A  
728d 11 f8 fe		            LD   DE, keyscan_table_row1  
7290			            ;LD   DE, MsgHello  
7290 cd e8 70		            CALL fLCD_Str       ;Display string pointed to by DE  
7293			  
7293			; Display text on second line  
7293 3e 40		            LD   A, kLCD_Line2  
7295 cd e0 70		            CALL fLCD_Pos       ;Position cursor to location in A  
7298 11 f3 fe		            LD   DE, keyscan_table_row2  
729b cd e8 70		            CALL fLCD_Str       ;Display string pointed to by DE  
729e 3e 14		            LD   A, kLCD_Line3  
72a0 cd e0 70		            CALL fLCD_Pos       ;Position cursor to location in A  
72a3 11 ee fe		            LD   DE, keyscan_table_row3  
72a6 cd e8 70		            CALL fLCD_Str       ;Display string pointed to by DE  
72a9 3e 54		            LD   A, kLCD_Line4  
72ab cd e0 70		            CALL fLCD_Pos       ;Position cursor to location in A  
72ae 11 e9 fe		            LD   DE, keyscan_table_row4  
72b1 cd e8 70		            CALL fLCD_Str       ;Display string pointed to by DE  
72b4			  
72b4 cd 86 0c			call delay250ms  
72b7 c3 68 72			jp matrix  
72ba			  
72ba			; pass de as row display flags  
72ba			.rowscan:   
72ba d3 c1			out (portbdata),a  
72bc db c1			in a,(portbdata)  
72be 4f				ld c,a  
72bf				; reset flags for the row   
72bf 06 2e			ld b,'.'  
72c1 e6 01			and 1  
72c3 28 02			jr z, .p1on  
72c5 06 23			ld b,'#'  
72c7			.p1on:  
72c7 70				ld (hl), b  
72c8 23				inc hl  
72c9			  
72c9 06 2e			ld b,'.'  
72cb 79				ld a,c  
72cc e6 02			and 2  
72ce			;	bit 0,a  
72ce 28 02			jr z, .p2on  
72d0 06 23			ld b,'#'  
72d2			.p2on:  
72d2 70				ld (hl), b  
72d3 23				inc hl  
72d4			;  
72d4 06 2e			ld b,'.'  
72d6 79				ld a,c  
72d7 e6 04			and 4  
72d9			;;	bit 0,a  
72d9 28 02			jr z, .p3on  
72db 06 23			ld b,'#'  
72dd			.p3on:  
72dd 70				ld (hl), b  
72de 23				inc hl  
72df			;;  
72df 06 2e			ld b,'.'  
72e1			;;	bit 0,a  
72e1 79				ld a,c  
72e2 e6 08			and 8  
72e4 28 02			jr z, .p4on  
72e6 06 23			ld b,'#'  
72e8			.p4on:  
72e8 70				ld (hl), b  
72e9 23				inc hl  
72ea			  
72ea			; zero term  
72ea 06 00			ld b,0  
72ec 70				ld (hl), b  
72ed			  
72ed c9			.rscandone: ret  
72ee			  
72ee			  
72ee			  
72ee			;endif  
72ee			  
72ee			  
72ee			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
72ee
