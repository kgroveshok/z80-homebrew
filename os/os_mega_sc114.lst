# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 4f 97			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
801c			 
801c			 
801c			 
801c			;        nop  
801c			;        nop 
801c			;;	org 05h		; null out bdos call 
801c			; 
801c			;        nop  
801c			;        nop  
801c			;        nop 
801c			;;	org 08h 
801c			;;; 
801c			;;	jp cin		; rst 8 - char in 
801c			;;; 
801c			; 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;	org 010h 
801c			;; 
801c			;	jp cout		; rest 010h  - char out 
801c			;; 
801c			;	org 01bh   
801c			; 
801c			;	;jp  		; rst 01bh   - write string to display 
801c			;	jp str_at_display 
801c			; 
801c			; 
801c			;	org 020h 
801c			; 
801c			;	; jp		 ; rst 020h - read char at screen location 
801c			; 
801c			;	org 028h 
801c			 
801c				; jp		 ; rst 028h  - storage i/o 
801c			 
801c			; 	org 030h 
801c			;	jp break_point_state 
801c			  
801c			; $30  
801c			; org 038h 
801c			; $38 
801c			 
801c			; TODO any more important entry points to add to jump table for easier coding use? 
801c			 
801c			if BASE_KEV = 1  
801c			 
801c				; need to be at $66 for nmi support 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255,0,255,0,255 
801c				db 0,255 
801c				jp nmi 
801c			endif 
801c			 
801c			include "firmware.asm" 
801c			  
801c			; main constants (used here and in firmware)  
801c			  
801c			; TODO have page 0 of storage as bios  
801c			  
801c			Device_A: equ 0h  
801c			Device_B: equ 040h          ; Sound  
801c			  
801c			if BASE_KEV  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_SC114  
801c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			; TODO fixup for CPM  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			Device_D: equ 0c0h             ; Keyboard and LCD  
801c			  
801c			; Odd specific debug points for testing hardware dev  
801c			  
801c			DEBUG_SOUND: equ 0       
801c			DEBUG_STK_FAULT: equ 0  
801c			DEBUG_INPUT: equ 0     ; Debug input entry code  
801c			DEBUG_KEYCINWAIT: equ 0  
801c			DEBUG_KEYCIN: equ 0  
801c			DEBUG_KEY: equ 0  
801c			DEBUG_KEY_MATRIX: equ 0  
801c			DEBUG_STORECF: equ 0  
801c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801c			DEBUG_SPI: equ 0    ; low level spi tests  
801c			  
801c			; Enable many break points  
801c			  
801c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801c			DEBUG_FORTH_JP: equ 0    ; 4  
801c			DEBUG_FORTH_MALLOC: equ 0  
801c			DEBUG_FORTH_MALLOC_INT: equ 0  
801c			DEBUG_FORTH_DOT: equ 1  
801c			DEBUG_FORTH_DOT_WAIT: equ 0  
801c			DEBUG_FORTH_MATHS: equ 0  
801c			DEBUG_FORTH_TOK: equ 0    ; 4  
801c			DEBUG_FORTH_PARSE: equ 0    ; 3  
801c			DEBUG_FORTH: equ 0  ;2  
801c			DEBUG_FORTH_WORDS: equ 1   ; 1  
801c			DEBUG_FORTH_PUSH: equ 1   ; 1  
801c			DEBUG_FORTH_UWORD: equ 1   ; 1  
801c			  
801c			; Enable key point breakpoints  
801c			  
801c			DEBUG_FORTH_DOT_KEY: equ 0  
801c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801c			  
801c			; Debug stack imbalances  
801c			  
801c			ON: equ 1  
801c			OFF: equ 0  
801c			  
801c			DEBUG_STACK_IMB: equ 0  
801c			STACK_IMB_STORE: equ 20  
801c			  
801c			; House keeping and protections  
801c			  
801c			DEBUG_FORTH_STACK_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801c			FORTH_ENABLE_FREE: equ 0  
801c			FORTH_ENABLE_MALLOCFREE: equ 1  
801c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801c			FORTH_ENABLE_FLOATMATH: equ 0  
801c			  
801c			  
801c			CALLMONITOR: macro  
801c			;	call break_point_state  
801c			; now use the break point debug vector  
801c				call debug_vector  
801c				endm  
801c			  
801c			MALLOC_1: equ 1        ; from dk88   
801c			MALLOC_2: equ 0           ; broke  
801c			MALLOC_3: equ 0           ; really broke  
801c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801c			  
801c			if BASE_KEV   
801c			stacksize: equ 256  
801c			  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 512  
801c			endif  
801c			if BASE_SC114  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			;if STORAGE_SE == 0  
801c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801c			;endif  
801c			  
801c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801c			  
801c			STORE_0_AUTORUN: equ $20  
801c			  
801c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801c			  
801c			STORE_0_AUTOFILE: equ $21  
801c			STORE_0_BANKRUN: equ $23  
801c			STORE_0_FILERUN: equ $24  
801c			  
801c			; Block 0 offsets for settings  
801c			  
801c			; if set then skip prompt for start up and accept all  
801c			  
801c			STORE_0_QUICKSTART: equ $25  
801c			  
801c			; Blocks where directory table is held  
801c			  
801c			; Reducing the number of entries increases the max file size  
801c			  
801c			;STORE_DIR_START: equ 1  
801c			;STORE_DIR_END: equ 33  
801c			  
801c			; Blocks from where file data is stored  
801c			  
801c			;STORE_DATA_START: equ STORE_DIR_END + 1  
801c			  
801c			; Block indicators (<32 are data files)  
801c			  
801c			;STORE_BLOCK_CFG: equ $8f       ; config block  
801c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801c			;STORE_BLOCK_FREE: equ $85       ; data block free  
801c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801c			  
801c			  
801c			  
801c			; Directory entry flags  
801c			  
801c			;STORE_DIR_FREE: equ 0  
801c			;STORE_DIR_FILE:  equ 1  
801c			  
801c			; Structure offsets to directory entries  
801c			;STORE_DE_FLAG: equ 0  
801c			;STORE_DE_MAXEXT: equ 1  
801c			;STORE_DE_FILENAME: equ 2  
801c			  
801c			; Structure offsets to block 0  
801c			  
801c			;STORE_BK0_ISFOR: equ 1  
801c			;STORE_BK0_LABEL: equ 3  
801c			  
801c			; memory allocation   
801c			  
801c			chk_stund: equ tos+2           ; underflow check word  
801c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801c			  
801c			; keyscan table needs rows x cols buffer  
801c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801c			  
801c			keyscan_table_row1: equ chk_stovr -key_cols-1  
801c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801c			keyscan_scancol: equ keyscan_table-key_cols  
801c			;keyscan_table_len: equ key_rows*key_cols  
801c			;keybufptr: equ keyscan_table - 2  
801c			;keysymbol: equ keybufptr - 1  
801c			key_held: equ keyscan_scancol-1	; currently held  
801c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801c			key_fa: equ key_repeat_ct -1 ;  
801c			key_fb: equ key_fa -1 ;  
801c			key_fc: equ key_fb -1 ;  
801c			key_fd: equ key_fc -1 ;  
801c			key_face_held: equ key_fd - 1   
801c			  
801c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801c			  
801c			hardware_config: equ key_face_held - 10  
801c			  
801c			; hardware config switches  
801c			; TODO add bitmasks on includes for hardware  
801c			; high byte for expansion ids  
801c			;     0000 0000  no card inserted  
801c			;     0000 0001  storage card inserted  
801c			;     0000 0010  spi sd card active  
801c			  
801c			;       
801c			; low byte:  
801c			;     0000 0001   4x4 keypad  
801c			;     0000 0010   full keyboard  
801c			;     0000 0011   spi/ext keyboard  
801c			;     0000 0100   20x4 lcd  
801c			;     0000 1000   40x4 lcd  
801c			;     0000 1100   spi/ext display  
801c			;     0001 0000   ide interface available  
801c			  
801c			hardware_word: equ hardware_config - 2  
801c			  
801c			; debug marker - optional display of debug point on the debug screens  
801c			  
801c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
801c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
801c			  
801c			debug_mark: equ debug_vector - 4  
801c			  
801c			; input_str vars  
801c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801c			input_size: equ input_start -1  ; number of chars  
801c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801c			input_len: equ input_cur_onoff - 5 ; length of current input  
801c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801c			  
801c			CUR_BLINK_RATE: equ 15  
801c			  
801c			key_actual_pressed: equ input_cursor - 1   
801c			key_symbol: equ key_actual_pressed - 1   
801c			key_shift: equ key_symbol - 1   
801c			  
801c			; Display allocation  
801c			  
801c			;display_rows: equ 4     ; move out to mini and mega files  
801c			;display_cols: equ 20  
801c			  
801c			display_fb_len: equ display_rows*display_cols  
801c			  
801c			; primary frame buffer     
801c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801c			; working frame buffers  
801c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801c			display_fb3: equ  display_fb1-display_fb_len - 1  
801c			display_fb2: equ  display_fb3-display_fb_len - 1  
801c			;  
801c			; pointer to active frame buffer  
801c			display_fb_active: equ display_fb2 - 2  
801c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801c			display_write_tmp: equ display_lcde1e2 - 2  
801c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
801c			  
801c			;  
801c			  
801c			;; can load into de directory  
801c			cursor_col: equ display_active-1  
801c			cursor_row: equ cursor_col-1  
801c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801c			  
801c			; maths vars  
801c			  
801c			LFSRSeed: equ cursor_shape -20   
801c			randData: equ LFSRSeed - 2  
801c			xrandc: equ randData - 2  
801c			stackstore: equ xrandc - 2  
801c			seed1: equ  stackstore -2   
801c			seed2: equ seed1 - 2  
801c			  
801c			; cf storage vars  
801c			  
801c			iErrorNum:  equ seed2-1         ;Error number  
801c			iErrorReg:  equ iErrorNum -1              ;Error register  
801c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801c			  
801c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801c			  
801c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801c			  
801c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801c			store_tmpid: equ store_tmp3 - 1		; page temp id  
801c			store_tmpext: equ store_tmpid - 1		; file extent temp  
801c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
801c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
801c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801c			;  
801c			; spi vars  
801c			  
801c			  
801c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
801c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
801c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801c			spi_device_id: equ spi_device - 1    ; human readable bank number  
801c			  
801c			;;;;; forth cli params  
801c			  
801c			; TODO use a different frame buffer for forth???  
801c			  
801c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801c			  
801c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
801c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
801c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801c			  
801c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801c			  
801c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801c			  
801c			; os/forth token vars  
801c			  
801c			os_last_cmd: equ os_var_array-255  
801c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801c			os_current_i: equ os_cli_cmd-2  
801c			os_cur_ptr: equ os_current_i-2  
801c			os_word_scratch: equ os_cur_ptr-30  
801c			os_tok_len: equ os_word_scratch - 2  
801c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801c			os_tok_malloc: equ os_tok_ptr - 2  
801c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801c			execscratch: equ os_input-255        ; exec cmd eval buffer  
801c			scratch: equ execscratch-255  
801c			  
801c			  
801c			; temp locations for new word processing to save on adding more   
801c			  
801c			os_new_malloc: equ scratch-2  
801c			os_new_parse_len: equ os_new_malloc - 2  
801c			os_new_word_len: equ os_new_parse_len - 2  
801c			os_new_work_ptr: equ os_new_word_len - 2  
801c			os_new_src_ptr: equ os_new_work_ptr - 2  
801c			os_new_exec: equ os_new_src_ptr - 2  
801c			os_new_exec_ptr: equ os_new_exec - 2  
801c			  
801c			; resume memory alloocations....  
801c			  
801c			;os_view_disable: equ os_new_exec_ptr - 1  
801c			os_view_af: equ os_new_exec_ptr - 2  
801c			os_view_hl: equ os_view_af -2  
801c			os_view_de: equ os_view_hl - 2  
801c			os_view_bc: equ os_view_de - 2  
801c			  
801c			; stack checksum word  
801c			if DEBUG_STACK_IMB  
801c				curframe: equ  os_view_de - 5  
801c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			else  
801c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			endif  
801c			  
801c			; with data stack could see memory filled with junk. need some memory management   
801c			; malloc and free entry points added  
801c			  
801c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			;heap_end: equ free_list-1  ; Starting address of heap  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			heap_end: equ chk_word-1  ; Starting address of heap  
801c			  
801c			  
801c			;if BASE_KEV   
801c			;heap_start: equ 0800eh  ; Starting address of heap  
801c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;heap_start: equ baseram+15  ; Starting address of heap  
801c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;endif  
801c			  
801c			  
801c			;;;;  
801c			  
801c			  
801c			; change below to point to last memory alloc above  
801c			topusermem:  equ   heap_start  
801c			  
801c			;if BASE_KEV   
801c			;baseusermem: equ 08000h  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;;aseusermem:     equ    12  
801c			;baseusermem:     equ    prompt  
801c			;;baseusermem:     equ    endofcode  
801c			;endif  
801c			  
801c			  
801c			; **********************************************************************  
801c			; **  Constants  
801c			; **********************************************************************  
801c			  
801c			; Constants used by this code module  
801c			kDataReg:   EQU Device_D           ;PIO port A data register  
801c			kContReg:   EQU Device_D+2           ;PIO port A control register  
801c			  
801c			  
801c			portbdata:  equ Device_D+1    ; port b data  
801c			portbctl:   equ Device_D+3    ; port b control  
801c			  
801c			  
801c			;KEY_SHIFT:   equ 5  
801c			;KEY_SYMBOLSHIFT:  equ 6  
801c			  
801c			KEY_SHIFTLOCK: equ 4  
801c			  
801c			  
801c			KEY_UP: equ 5  
801c			KEY_NEXTWORD: equ 6  
801c			KEY_PREVWORD: equ 7  
801c			KEY_BS: equ 8  
801c			KEY_TAB:  equ 9  
801c			KEY_DOWN: equ 10  
801c			KEY_LEFT: equ 11  
801c			KEY_RIGHT: equ 12  
801c			KEY_CR:   equ 13  
801c			KEY_HOME: equ 14  
801c			KEY_END: equ 15  
801c			  
801c			KEY_F1: equ 16  
801c			KEY_F2: equ 17  
801c			KEY_F3: equ 18  
801c			KEY_F4: equ 19  
801c			  
801c			KEY_F5: equ 20  
801c			KEY_F6: equ 21  
801c			KEY_F7: equ 22  
801c			KEY_F8: equ 23  
801c			  
801c			KEY_F9: equ 24  
801c			KEY_F10: equ 25  
801c			KEY_F11: equ 26  
801c			KEY_F12: equ 27  
801c			  
801c			;if DEBUG_KEY  
801c			;	KEY_MATRIX_NO_PRESS: equ '.'  
801c			;	KEY_SHIFT:   equ '.'  
801c			;	KEY_SYMBOLSHIFT:  equ '.'  
801c			;else  
801c				KEY_SHIFT:   equ '~'  
801c				KEY_SYMBOLSHIFT:  equ '~'  
801c				KEY_MATRIX_NO_PRESS: equ '~'  
801c			;endi  
801c			  
801c			  
801c			  
801c			  
801c			; Macro to make adding debug marks easier  
801c			  
801c			DMARK: macro str  
801c				push af  
801c				ld a, (.dmark)  
801c				ld (debug_mark),a  
801c				ld a, (.dmark+1)  
801c				ld (debug_mark+1),a  
801c				ld a, (.dmark+2)  
801c				ld (debug_mark+2),a  
801c				jr .pastdmark  
801c			.dmark: db str  
801c			.pastdmark: pop af  
801c			  
801c			endm  
801c			  
801c			  
801c			; macro to detect for stack imbalances  
801c			  
801c			include "stackimbal.asm"  
801c			; Macro and code to detect stock imbalances 
801c			 
801c			SPPUSH: equ 0 
801c			 
801c			; Add a stack frame which can be checked before return 
801c			 
801c			STACKFRAME: macro onoff frame1 frame2 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c						exx 
801c			 
801c						ld de, frame1 
801c						ld a, d 
801c						ld hl, curframe 
801c						call hexout 
801c						ld a, e 
801c						ld hl, curframe+2 
801c						call hexout 
801c			  
801c						ld hl, frame1 
801c						push hl 
801c						ld hl, frame2 
801c						push hl 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			endm 
801c			 
801c			STACKFRAMECHK: macro onoff frame1 frame2 
801c			 
801c					 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						exx 
801c						; check stack frame SP 
801c			 
801c						ld hl, frame2 
801c						pop de   ; frame2 
801c			 
801c						call cmp16 
801c						jr nz, .spnosame 
801c						 
801c			 
801c						ld hl, frame1 
801c						pop de   ; frame1 
801c			 
801c						call cmp16 
801c						jr z, .spfrsame 
801c			 
801c						.spnosame: call showsperror 
801c			 
801c						.spfrsame: nop 
801c			 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			 
801c			 
801c			endm 
801c			 
801c			 
801c			; for a sub routine, wrap SP collection and comparisons 
801c			 
801c			; Usage: 
801c			; 
801c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801c			 
801c			SAVESP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c			 
801c						ld (store_sp+(storeword*4)), sp 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			CHECKSP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c			 
801c						; save SP after last save 
801c				 
801c						ld (store_sp+(storeword*4)+2), sp 
801c			 
801c						push hl 
801c						ld hl, store_sp+(storeword*4) 
801c						call check_stack_sp  
801c						pop hl 
801c			 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			if DEBUG_STACK_IMB 
801c			 
801c			check_stack_sp: 
801c					push de 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					push de 
801c			 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					pop hl 
801c			 
801c			 
801c					; check to see if the same 
801c			 
801c					call cmp16 
801c					jr z, .spsame 
801c			 
801c					; not same 
801c			 
801c					call showsperror 
801c			.spsame: 
801c			 
801c					pop de 
801c			 
801c					ret 
801c			 
801c			.sperr:  db "Stack imbalance",0 
801c			 
801c			 
801c			showsperror: 
801c			 
801c			 
801c				push hl 
801c				push af 
801c				push de 
801c				call clear_display 
801c				ld de, .sperr 
801c				ld a,0 
801c			;	ld de,os_word_scratch 
801c				call str_at_display 
801c				ld a, display_row_1+17 
801c				ld de, debug_mark 
801c				call str_at_display 
801c				ld a, 0 
801c				ld (curframe+4),a 
801c				ld hl, curframe 
801c				ld de, os_word_scratch 
801c				ld a, display_row_4 
801c				call str_at_display 
801c				call update_display 
801c				;call break_point_state 
801c				call cin_wait 
801c			 
801c			;	ld a, ' ' 
801c			;	ld (os_view_disable), a 
801c				call bp_on 
801c				pop de	 
801c				pop af 
801c				pop hl 
801c				CALLMONITOR 
801c				ret 
801c			 
801c			endif 
801c			 
801c			 
801c			 
801c			; eof 
# End of file stackimbal.asm
801c			  
801c			;TODO macro to calc col and row offset into screen  
801c			  
801c			  
801c			  
801c			hardware_init:  
801c			  
801c				  
801c			  
801c					;ld a, 0  
801c					;ld (hardware_diag), a  
801c			  
801c					; clear all the buffers  
801c			  
801c 21 10 ed				ld hl, display_fb1  
801f 22 cc eb				ld (display_fb_active), hl  
8022			  
8022 cd af 8a				call clear_display  
8025			  
8025 21 ce eb				ld hl, display_fb2  
8028 22 cc eb				ld (display_fb_active), hl  
802b			  
802b cd af 8a				call clear_display  
802e			  
802e					; init primary frame buffer area  
802e 21 b1 ed				ld hl, display_fb0  
8031 22 cc eb				ld (display_fb_active), hl  
8034			  
8034 cd af 8a				call clear_display  
8037			  
8037			  
8037 cd 74 e3				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803a			  
803a cd 16 e4			call key_init  
803d cd 9f 80			call storage_init  
8040			  
8040				; setup malloc functions  
8040			  
8040				if MALLOC_1  
8040 cd 7f 91				call  heap_init  
8043				endif  
8043				if MALLOC_4  
8043					call  heap_init  
8043				endif  
8043			  
8043				; init sound hardware if present  
8043			  
8043				if SOUND_ENABLE  
8043					call sound_init  
8043				endif  
8043			  
8043				; lcd test sequence  
8043					  
8043 cd d2 8a			call update_display  
8046 cd f2 89			call delay1s  
8049 3e 2b			ld a,'+'  
804b cd b4 8a			call fill_display  
804e cd d2 8a			call update_display  
8051 cd f2 89			call delay1s  
8054 3e 2a			ld a,'*'  
8056 cd b4 8a			call fill_display  
8059 cd d2 8a			call update_display  
805c cd f2 89			call delay1s  
805f 3e 2d			ld a,'-'  
8061 cd b4 8a			call fill_display  
8064 cd d2 8a			call update_display  
8067 cd f2 89			call delay1s  
806a			  
806a			; boot splash screen  
806a			if display_cols == 20	  
806a			        ld a, display_row_1    
806a			else  
806a 3e 0a		        ld a, display_row_1 +10   
806c			endif  
806c 11 ad 96			ld de, prom_bootmsg  
806f cd c2 8a			call str_at_display  
8072 cd d2 8a			call update_display  
8075			  
8075			  
8075 cd f2 89			call delay1s  
8078 cd f2 89			call delay1s  
807b			if display_cols == 20	  
807b			            LD   A, display_row_3+2  
807b			else  
807b 3e 5c		            LD   A, display_row_3+12  
807d			endif  
807d 11 c2 96			ld de, prom_bootmsg1  
8080 cd c2 8a			call str_at_display  
8083 cd d2 8a			call update_display  
8086 cd f2 89			call delay1s  
8089 cd f2 89			call delay1s  
808c			  
808c			;	ld a, display_row_4+3  
808c			;	ld de, bootmsg2  
808c			;	call str_at_display  
808c			;	call update_display  
808c			;	call delay1s  
808c			;	call delay1s  
808c			  
808c			; debug mark setup  
808c			  
808c 3e 5f		ld a, '_'  
808e 32 6b ee		ld (debug_mark),a  
8091 32 6c ee		ld (debug_mark+1),a  
8094 32 6d ee		ld (debug_mark+2),a  
8097 3e 00		ld a,0  
8099 32 6e ee		ld (debug_mark+3),a  
809c			  
809c c9					ret  
809d			  
809d			  
809d			;bootmsg2:	db "Firmware v0.1",0  
809d			  
809d			; a 4x20 lcd  
809d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809d			  
809d			;if display_cols == 20  
809d			;	include "firmware_lcd_4x20.asm"  
809d			;endif  
809d			  
809d			;if display_cols == 40  
809d			;	include "firmware_lcd_4x40.asm"  
809d			;endif  
809d			  
809d			;  
809d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809d			; TODO abstract the bit bang video out interface for dual display  
809d			; TODO wire video out to tx pin on rc2014 bus  
809d			  
809d			; must supply cin, and cin_wait for low level hardware abstraction   
809d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809d			; test scancode  
809d			  
809d			;;;;;  
809d			;;;  
809d			; Moved out to mini and maxi versions  
809d			;  
809d			; include "firmware_key_4x4.asm"  
809d			; using existing 4 wire x 4 resistor array for input  
809d			;include "firmware_key_4x10.asm"  
809d			; need to mod the board for 5 rows due to resistor array  
809d			;include "firmware_key_5x10.asm"  
809d			  
809d			; storage hardware interface  
809d			  
809d			; use microchip serial eeprom for storage  
809d			  
809d			  
809d			if STORAGE_SE  
809d				include "firmware_spi.asm"  
809d				include "firmware_seeprom.asm"  
809d			else  
809d			   ; create some stubs for the labels  
809d c9			se_readbyte: ret  
809e c9			se_writebyte: ret  
809f c9			storage_init: ret  
80a0			  
80a0			endif  
80a0			  
80a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80a0			;include "firmware_cf.asm"  
80a0			  
80a0			; load up high level storage hardward abstractions  
80a0			include "firmware_storage.asm"  
80a0			 
80a0			; persisent storage hardware abstraction layer  
80a0			 
80a0			 
80a0			 
80a0			; Block 0 on storage is a config state 
80a0			 
80a0			 
80a0			 
80a0			; TODO add read phy block and write phy block functions 
80a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80a0			 
80a0			; Abstraction layer  
80a0			 
80a0			; Logocial block size is same size as physical size - using tape concept 
80a0			 
80a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80a0			 
80a0			 
80a0			 
80a0			; Filesystem layout (Logical layout) 
80a0			; 
80a0			; Block 0 - Bank config  
80a0			; 
80a0			;      Byte - 0 file id counter 
80a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80a0			;      Byte - 3-20 zero terminated bank label 
80a0			; 
80a0			; Block 1 > File storage 
80a0			; 
80a0			;      Byte 0 file id    - block 0 file details 
80a0			;      Byte 1 block id - block 0 is file  
80a0			;            Byte 2-15 - File name 
80a0			; 
80a0			;       - to end of block data 
80a0			; 
80a0			 
80a0			; Get ID for the file named in pointer held HL 
80a0			; Returns ID in HL = 255 if no file found 
80a0			 
80a0			storage_getid: 
80a0			 
80a0 22 73 ea			ld (store_tmp1), hl 
80a3			 
80a3				if DEBUG_STORESE 
80a3					DMARK "SGI" 
80a3 f5				push af  
80a4 3a b8 80			ld a, (.dmark)  
80a7 32 6b ee			ld (debug_mark),a  
80aa 3a b9 80			ld a, (.dmark+1)  
80ad 32 6c ee			ld (debug_mark+1),a  
80b0 3a ba 80			ld a, (.dmark+2)  
80b3 32 6d ee			ld (debug_mark+2),a  
80b6 18 03			jr .pastdmark  
80b8 ..			.dmark: db "SGI"  
80bb f1			.pastdmark: pop af  
80bc			endm  
# End of macro DMARK
80bc					CALLMONITOR 
80bc cd 6f ee			call debug_vector  
80bf				endm  
# End of macro CALLMONITOR
80bf				endif 
80bf				; get block 0 and set counter for number of files to scan 
80bf			 
80bf cd 2a 82			call storage_get_block_0 
80c2			 
80c2 3a 7a ea			ld a, (store_page) 
80c5 47				ld b, a 
80c6			 
80c6				; get extent 0 of each file id 
80c6			 
80c6				if DEBUG_STORESE 
80c6					DMARK "SGc" 
80c6 f5				push af  
80c7 3a db 80			ld a, (.dmark)  
80ca 32 6b ee			ld (debug_mark),a  
80cd 3a dc 80			ld a, (.dmark+1)  
80d0 32 6c ee			ld (debug_mark+1),a  
80d3 3a dd 80			ld a, (.dmark+2)  
80d6 32 6d ee			ld (debug_mark+2),a  
80d9 18 03			jr .pastdmark  
80db ..			.dmark: db "SGc"  
80de f1			.pastdmark: pop af  
80df			endm  
# End of macro DMARK
80df					CALLMONITOR 
80df cd 6f ee			call debug_vector  
80e2				endm  
# End of macro CALLMONITOR
80e2				endif 
80e2 60			.getloop:	ld h, b 
80e3 2e 00				ld l, 0 
80e5 c5					push bc 
80e6			 
80e6 11 7a ea				ld de, store_page 
80e9				if DEBUG_STORESE 
80e9					DMARK "SGr" 
80e9 f5				push af  
80ea 3a fe 80			ld a, (.dmark)  
80ed 32 6b ee			ld (debug_mark),a  
80f0 3a ff 80			ld a, (.dmark+1)  
80f3 32 6c ee			ld (debug_mark+1),a  
80f6 3a 00 81			ld a, (.dmark+2)  
80f9 32 6d ee			ld (debug_mark+2),a  
80fc 18 03			jr .pastdmark  
80fe ..			.dmark: db "SGr"  
8101 f1			.pastdmark: pop af  
8102			endm  
# End of macro DMARK
8102					CALLMONITOR 
8102 cd 6f ee			call debug_vector  
8105				endm  
# End of macro CALLMONITOR
8105				endif 
8105 cd d2 86				call storage_read 
8108 cd 05 8d				call ishlzero 
810b 28 2d				jr z, .gap 
810d					 
810d					; have a file name read. Is it one we want. 
810d			 
810d 2a 73 ea				ld hl, (store_tmp1) 
8110 11 7d ea				ld de, store_page+3   ; file name 
8113			 
8113				if DEBUG_STORESE 
8113					DMARK "SGc" 
8113 f5				push af  
8114 3a 28 81			ld a, (.dmark)  
8117 32 6b ee			ld (debug_mark),a  
811a 3a 29 81			ld a, (.dmark+1)  
811d 32 6c ee			ld (debug_mark+1),a  
8120 3a 2a 81			ld a, (.dmark+2)  
8123 32 6d ee			ld (debug_mark+2),a  
8126 18 03			jr .pastdmark  
8128 ..			.dmark: db "SGc"  
812b f1			.pastdmark: pop af  
812c			endm  
# End of macro DMARK
812c					CALLMONITOR 
812c cd 6f ee			call debug_vector  
812f				endm  
# End of macro CALLMONITOR
812f				endif 
812f cd 72 91				call strcmp 
8132 20 06				jr nz, .gap   ; not this one 
8134			 
8134 c1				        pop bc 
8135			 
8135 26 00				ld h, 0 
8137 68					ld l, b 
8138 18 22				jr .getdone 
813a						 
813a			 
813a			 
813a			 
813a			.gap: 
813a				if DEBUG_STORESE 
813a					DMARK "SGg" 
813a f5				push af  
813b 3a 4f 81			ld a, (.dmark)  
813e 32 6b ee			ld (debug_mark),a  
8141 3a 50 81			ld a, (.dmark+1)  
8144 32 6c ee			ld (debug_mark+1),a  
8147 3a 51 81			ld a, (.dmark+2)  
814a 32 6d ee			ld (debug_mark+2),a  
814d 18 03			jr .pastdmark  
814f ..			.dmark: db "SGg"  
8152 f1			.pastdmark: pop af  
8153			endm  
# End of macro DMARK
8153					CALLMONITOR 
8153 cd 6f ee			call debug_vector  
8156				endm  
# End of macro CALLMONITOR
8156				endif 
8156			 
8156 c1					pop bc 
8157 10 89				djnz .getloop 
8159 21 ff 00				ld hl, 255 
815c			.getdone: 
815c			 
815c				if DEBUG_STORESE 
815c					DMARK "SGe" 
815c f5				push af  
815d 3a 71 81			ld a, (.dmark)  
8160 32 6b ee			ld (debug_mark),a  
8163 3a 72 81			ld a, (.dmark+1)  
8166 32 6c ee			ld (debug_mark+1),a  
8169 3a 73 81			ld a, (.dmark+2)  
816c 32 6d ee			ld (debug_mark+2),a  
816f 18 03			jr .pastdmark  
8171 ..			.dmark: db "SGe"  
8174 f1			.pastdmark: pop af  
8175			endm  
# End of macro DMARK
8175					CALLMONITOR 
8175 cd 6f ee			call debug_vector  
8178				endm  
# End of macro CALLMONITOR
8178				endif 
8178			 
8178 c9				ret 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			; Read Block 
8179			; ---------- 
8179			; 
8179			; With current bank 
8179			;  
8179			; Get block number to read 
8179			; Load physical blocks starting at start block into buffer 
8179			 
8179			; de points to buffer to use 
8179			; hl holds logical block number  
8179			 
8179			storage_read_block: 
8179			 
8179				; TODO bank selection 
8179			 
8179				; for each of the physical blocks read it into the buffer 
8179 06 40			ld b, STORE_BLOCK_PHY 
817b			 
817b				if DEBUG_STORESE 
817b d5					push de 
817c				endif 
817c				 
817c			.rl1:    
817c			 
817c				; read physical block at hl into de 
817c			        ; increment hl and de to next read position on exit 
817c			 
817c e5				push hl 
817d d5				push de	 
817e c5				push bc 
817f			;	if DEBUG_STORESE 
817f			;		push af 
817f			;		ld a, 'R' 
817f			;		ld (debug_mark),a 
817f			;		pop af 
817f			;		CALLMONITOR 
817f			;	endif 
817f cd 9d 80			call se_readbyte 
8182			;	if DEBUG_STORESE 
8182			;		ld a,(spi_portbyte) 
8182			;		ld l, a 
8182			;		push af 
8182			;		ld a, '1' 
8182			;		ld (debug_mark),a 
8182			;		pop af 
8182			;		CALLMONITOR 
8182			;	endif 
8182 c1				pop bc 
8183 d1				pop de 
8184 e1				pop hl 
8185 12				ld (de),a 
8186 23				inc hl 
8187 13				inc de 
8188			 
8188			;	if DEBUG_STORESE 
8188			;		push af 
8188			;		ld a, 'r' 
8188			;		ld (debug_mark),a 
8188			;		pop af 
8188			;		CALLMONITOR 
8188			;	endif 
8188			 
8188 10 f2			djnz .rl1 
818a			 
818a				if DEBUG_STORESE 
818a					DMARK "SRB" 
818a f5				push af  
818b 3a 9f 81			ld a, (.dmark)  
818e 32 6b ee			ld (debug_mark),a  
8191 3a a0 81			ld a, (.dmark+1)  
8194 32 6c ee			ld (debug_mark+1),a  
8197 3a a1 81			ld a, (.dmark+2)  
819a 32 6d ee			ld (debug_mark+2),a  
819d 18 03			jr .pastdmark  
819f ..			.dmark: db "SRB"  
81a2 f1			.pastdmark: pop af  
81a3			endm  
# End of macro DMARK
81a3 d1					pop de 
81a4			; 
81a4			;		push af 
81a4			;		ld a, 'R' 
81a4			;		ld (debug_mark),a 
81a4			;		pop af 
81a4					CALLMONITOR 
81a4 cd 6f ee			call debug_vector  
81a7				endm  
# End of macro CALLMONITOR
81a7				endif 
81a7 c9				ret	 
81a8				 
81a8			 
81a8			; File Size 
81a8			; --------- 
81a8			; 
81a8			;   hl file id 
81a8			; 
81a8			;  returns in hl the number of blocks 
81a8			 
81a8			storage_file_size: 
81a8 5d				ld e, l 
81a9 16 00			ld d, 0 
81ab 21 40 00			ld hl, STORE_BLOCK_PHY 
81ae					if DEBUG_FORTH_WORDS 
81ae						DMARK "SIZ" 
81ae f5				push af  
81af 3a c3 81			ld a, (.dmark)  
81b2 32 6b ee			ld (debug_mark),a  
81b5 3a c4 81			ld a, (.dmark+1)  
81b8 32 6c ee			ld (debug_mark+1),a  
81bb 3a c5 81			ld a, (.dmark+2)  
81be 32 6d ee			ld (debug_mark+2),a  
81c1 18 03			jr .pastdmark  
81c3 ..			.dmark: db "SIZ"  
81c6 f1			.pastdmark: pop af  
81c7			endm  
# End of macro DMARK
81c7						CALLMONITOR 
81c7 cd 6f ee			call debug_vector  
81ca				endm  
# End of macro CALLMONITOR
81ca					endif 
81ca cd ac 84			call storage_findnextid 
81cd			 
81cd cd 05 8d			call ishlzero 
81d0			;	ld a, l 
81d0			;	add h 
81d0			;	cp 0 
81d0 c8				ret z			; block not found so EOF 
81d1			 
81d1 11 7a ea			ld de, store_page 
81d4 cd 79 81			call storage_read_block 
81d7			 
81d7 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
81da 6f				ld l, a 
81db 26 00			ld h, 0 
81dd c9			 	ret 
81de			 
81de			 
81de			; Write Block 
81de			; ----------- 
81de			; 
81de			; With current bank 
81de			;  
81de			; Get block number to write 
81de			; Write physical blocks starting at start block from buffer 
81de			  
81de			storage_write_block: 
81de				; TODO bank selection 
81de			 
81de				; for each of the physical blocks read it into the buffer 
81de 06 40			ld b, STORE_BLOCK_PHY 
81e0			 
81e0				if DEBUG_STORESE 
81e0					DMARK "SWB" 
81e0 f5				push af  
81e1 3a f5 81			ld a, (.dmark)  
81e4 32 6b ee			ld (debug_mark),a  
81e7 3a f6 81			ld a, (.dmark+1)  
81ea 32 6c ee			ld (debug_mark+1),a  
81ed 3a f7 81			ld a, (.dmark+2)  
81f0 32 6d ee			ld (debug_mark+2),a  
81f3 18 03			jr .pastdmark  
81f5 ..			.dmark: db "SWB"  
81f8 f1			.pastdmark: pop af  
81f9			endm  
# End of macro DMARK
81f9			 
81f9					;push af 
81f9					;ld a, 'W' 
81f9					;ld (debug_mark),a 
81f9					;pop af 
81f9					CALLMONITOR 
81f9 cd 6f ee			call debug_vector  
81fc				endm  
# End of macro CALLMONITOR
81fc				endif 
81fc			 
81fc			; might not be working 
81fc			;	call se_writepage 
81fc			 
81fc			;	ret 
81fc			; 
81fc			 
81fc			 
81fc			 
81fc			.wl1:    
81fc			 
81fc				; read physical block at hl into de 
81fc			        ; increment hl and de to next read position on exit 
81fc			 
81fc e5				push hl 
81fd d5				push de	 
81fe c5				push bc 
81ff 1a				ld a,(de) 
8200				;if DEBUG_STORESE 
8200			;		push af 
8200			;		ld a, 'W' 
8200			;		ld (debug_mark),a 
8200			;		pop af 
8200			;		CALLMONITOR 
8200			;	endif 
8200 cd 9e 80			call se_writebyte 
8203			;	call delay250ms 
8203 00				nop 
8204 00				nop 
8205 00				nop 
8206			;	if DEBUG_STORESE 
8206			;		push af 
8206			;		ld a, 'w' 
8206			;		ld (debug_mark),a 
8206			;		pop af 
8206			;		CALLMONITOR 
8206			;	endif 
8206 c1				pop bc 
8207 d1				pop de 
8208 e1				pop hl 
8209 23				inc hl 
820a 13				inc de 
820b			 
820b			 
820b 10 ef			djnz .wl1 
820d			 
820d				if DEBUG_STORESE 
820d					DMARK "SW2" 
820d f5				push af  
820e 3a 22 82			ld a, (.dmark)  
8211 32 6b ee			ld (debug_mark),a  
8214 3a 23 82			ld a, (.dmark+1)  
8217 32 6c ee			ld (debug_mark+1),a  
821a 3a 24 82			ld a, (.dmark+2)  
821d 32 6d ee			ld (debug_mark+2),a  
8220 18 03			jr .pastdmark  
8222 ..			.dmark: db "SW2"  
8225 f1			.pastdmark: pop af  
8226			endm  
# End of macro DMARK
8226			 
8226					;push af 
8226					;ld a, 'W' 
8226					;ld (debug_mark),a 
8226					;pop af 
8226					CALLMONITOR 
8226 cd 6f ee			call debug_vector  
8229				endm  
# End of macro CALLMONITOR
8229				endif 
8229 c9				ret	 
822a			 
822a			; Init bank 
822a			; --------- 
822a			; 
822a			; With current bank 
822a			; 
822a			; Setup block 0 config 
822a			;     Set 0 file id counter 
822a			;     Set formatted byte pattern 
822a			;     Zero out bank label 
822a			;      
822a			; For every logical block write 0-1 byte as null 
822a			 
822a			storage_get_block_0: 
822a			 
822a				; TODO check presence 
822a			 
822a				; get block 0 config 
822a			 
822a 21 00 00			ld hl, 0 
822d 11 7a ea			ld de, store_page 
8230 cd 79 81			call storage_read_block 
8233			 
8233				if DEBUG_STORESE 
8233					DMARK "SB0" 
8233 f5				push af  
8234 3a 48 82			ld a, (.dmark)  
8237 32 6b ee			ld (debug_mark),a  
823a 3a 49 82			ld a, (.dmark+1)  
823d 32 6c ee			ld (debug_mark+1),a  
8240 3a 4a 82			ld a, (.dmark+2)  
8243 32 6d ee			ld (debug_mark+2),a  
8246 18 03			jr .pastdmark  
8248 ..			.dmark: db "SB0"  
824b f1			.pastdmark: pop af  
824c			endm  
# End of macro DMARK
824c 11 7a ea				ld de, store_page 
824f			;		push af 
824f			;		ld a, 'i' 
824f			;		ld (debug_mark),a 
824f			;		pop af 
824f					CALLMONITOR 
824f cd 6f ee			call debug_vector  
8252				endm  
# End of macro CALLMONITOR
8252				endif 
8252			 
8252				; is this area formatted? 
8252			 
8252			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8252 2a 7b ea			ld hl, (store_page+1) 
8255 3e 80			ld a,0x80 
8257 bd				cp l 
8258 20 22			jr nz, .ininotformatted 
825a				; do a double check 
825a 3e 27			ld a, 0x27 
825c bc				cp h 
825d 20 1d			jr nz, .ininotformatted 
825f			 
825f				; formatted then 
825f			 
825f				if DEBUG_STORESE 
825f					DMARK "SB1" 
825f f5				push af  
8260 3a 74 82			ld a, (.dmark)  
8263 32 6b ee			ld (debug_mark),a  
8266 3a 75 82			ld a, (.dmark+1)  
8269 32 6c ee			ld (debug_mark+1),a  
826c 3a 76 82			ld a, (.dmark+2)  
826f 32 6d ee			ld (debug_mark+2),a  
8272 18 03			jr .pastdmark  
8274 ..			.dmark: db "SB1"  
8277 f1			.pastdmark: pop af  
8278			endm  
# End of macro DMARK
8278					;push af 
8278					;ld a, 'I' 
8278					;ld (debug_mark),a 
8278					;pop af 
8278					CALLMONITOR 
8278 cd 6f ee			call debug_vector  
827b				endm  
# End of macro CALLMONITOR
827b				endif 
827b c9				ret 
827c			 
827c			.ininotformatted: 
827c				; bank not formatted so poke various bits to make sure 
827c			 
827c				if DEBUG_STORESE 
827c					DMARK "SB2" 
827c f5				push af  
827d 3a 91 82			ld a, (.dmark)  
8280 32 6b ee			ld (debug_mark),a  
8283 3a 92 82			ld a, (.dmark+1)  
8286 32 6c ee			ld (debug_mark+1),a  
8289 3a 93 82			ld a, (.dmark+2)  
828c 32 6d ee			ld (debug_mark+2),a  
828f 18 03			jr .pastdmark  
8291 ..			.dmark: db "SB2"  
8294 f1			.pastdmark: pop af  
8295			endm  
# End of macro DMARK
8295					;push af 
8295					;ld a, 'f' 
8295					;ld (debug_mark),a 
8295					;pop af 
8295					CALLMONITOR 
8295 cd 6f ee			call debug_vector  
8298				endm  
# End of macro CALLMONITOR
8298				endif 
8298			 
8298 cd b5 89			call storage_clear_page 
829b			 
829b 21 7a ea			ld hl, store_page 
829e 3e 00			ld a, 0 
82a0				 
82a0 77				ld (hl),a   ; reset file counter 
82a1			 
82a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a4 22 7b ea		 	ld (store_page+1), hl	 
82a7			 
82a7				; set default label 
82a7			 
82a7 21 43 83			ld hl, .defaultbanklabl 
82aa 11 7d ea		 	ld de, store_page+3 
82ad 01 0f 00			ld bc, 15 
82b0 ed b0			ldir 
82b2			 
82b2				; Append the current bank id 
82b2 21 86 ea			ld hl, store_page+3+9 
82b5 3a 5f ea			ld a, (spi_device_id) 
82b8 77				ld (hl), a 
82b9			 
82b9				; save default page 0 
82b9			 
82b9 21 00 00			ld hl, 0 
82bc 11 7a ea			ld de, store_page 
82bf				if DEBUG_STORESE 
82bf					DMARK "SB3" 
82bf f5				push af  
82c0 3a d4 82			ld a, (.dmark)  
82c3 32 6b ee			ld (debug_mark),a  
82c6 3a d5 82			ld a, (.dmark+1)  
82c9 32 6c ee			ld (debug_mark+1),a  
82cc 3a d6 82			ld a, (.dmark+2)  
82cf 32 6d ee			ld (debug_mark+2),a  
82d2 18 03			jr .pastdmark  
82d4 ..			.dmark: db "SB3"  
82d7 f1			.pastdmark: pop af  
82d8			endm  
# End of macro DMARK
82d8			;		push af 
82d8			;		ld a, 'F' 
82d8			;		ld (debug_mark),a 
82d8			;		pop af 
82d8					CALLMONITOR 
82d8 cd 6f ee			call debug_vector  
82db				endm  
# End of macro CALLMONITOR
82db				endif 
82db cd de 81			call storage_write_block 
82de				if DEBUG_STORESE 
82de					DMARK "SB4" 
82de f5				push af  
82df 3a f3 82			ld a, (.dmark)  
82e2 32 6b ee			ld (debug_mark),a  
82e5 3a f4 82			ld a, (.dmark+1)  
82e8 32 6c ee			ld (debug_mark+1),a  
82eb 3a f5 82			ld a, (.dmark+2)  
82ee 32 6d ee			ld (debug_mark+2),a  
82f1 18 03			jr .pastdmark  
82f3 ..			.dmark: db "SB4"  
82f6 f1			.pastdmark: pop af  
82f7			endm  
# End of macro DMARK
82f7			;		push af 
82f7			;		ld a, '>' 
82f7			;		ld (debug_mark),a 
82f7			;		pop af 
82f7					CALLMONITOR 
82f7 cd 6f ee			call debug_vector  
82fa				endm  
# End of macro CALLMONITOR
82fa				endif 
82fa			 
82fa 00				nop 
82fb 00				nop 
82fc 00				nop 
82fd			 
82fd				; now set 0 in every page to mark as a free block 
82fd			 
82fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82ff 21 40 00			ld hl, STORE_BLOCK_PHY 
8302			 
8302 3e 00		.setmark1:   	ld a,0 
8304 e5					push hl 
8305 c5					push bc 
8306 cd 9e 80				call se_writebyte 
8309 3e 0a			ld a, 10 
830b cd d7 89			call aDelayInMS 
830e 23				inc hl 
830f cd 9e 80				call se_writebyte 
8312 3e 0a			ld a, 10 
8314 cd d7 89			call aDelayInMS 
8317 2b				dec hl 
8318 c1					pop bc 
8319 e1					pop hl 
831a 3e 40				ld a, STORE_BLOCK_PHY 
831c cd dc 8c				call addatohl 
831f 10 e1				djnz .setmark1 
8321			 
8321 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8323 3e 00		.setmark2:   	ld a,0 
8325 e5					push hl 
8326 c5					push bc 
8327 cd 9e 80				call se_writebyte 
832a 3e 0a			ld a, 10 
832c cd d7 89			call aDelayInMS 
832f 23				inc hl 
8330 cd 9e 80				call se_writebyte 
8333 3e 0a			ld a, 10 
8335 cd d7 89			call aDelayInMS 
8338 2b				dec hl 
8339 c1					pop bc 
833a e1					pop hl 
833b 3e 40				ld a, STORE_BLOCK_PHY 
833d cd dc 8c				call addatohl 
8340 10 e1				djnz .setmark2 
8342			 
8342					 
8342			 
8342			 
8342 c9				ret 
8343			 
8343			 
8343			 
8343			 
8343 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834e			 
834e			 
834e			 
834e			; Label Bank 
834e			; ---------- 
834e			; 
834e			; With current bank 
834e			; Read block 0 
834e			; Set label 
834e			; Write block 0 
834e			 
834e			; label str pointer in hl 
834e			 
834e			storage_label:     
834e			 
834e				if DEBUG_STORESE 
834e					DMARK "LBL" 
834e f5				push af  
834f 3a 63 83			ld a, (.dmark)  
8352 32 6b ee			ld (debug_mark),a  
8355 3a 64 83			ld a, (.dmark+1)  
8358 32 6c ee			ld (debug_mark+1),a  
835b 3a 65 83			ld a, (.dmark+2)  
835e 32 6d ee			ld (debug_mark+2),a  
8361 18 03			jr .pastdmark  
8363 ..			.dmark: db "LBL"  
8366 f1			.pastdmark: pop af  
8367			endm  
# End of macro DMARK
8367					CALLMONITOR 
8367 cd 6f ee			call debug_vector  
836a				endm  
# End of macro CALLMONITOR
836a				endif 
836a			 
836a e5				push hl 
836b			 
836b cd 2a 82			call storage_get_block_0 
836e			 
836e				; set default label 
836e			 
836e e1				pop hl 
836f			 
836f 11 7d ea		 	ld de, store_page+3 
8372 01 0f 00			ld bc, 15 
8375				if DEBUG_STORESE 
8375					DMARK "LB3" 
8375 f5				push af  
8376 3a 8a 83			ld a, (.dmark)  
8379 32 6b ee			ld (debug_mark),a  
837c 3a 8b 83			ld a, (.dmark+1)  
837f 32 6c ee			ld (debug_mark+1),a  
8382 3a 8c 83			ld a, (.dmark+2)  
8385 32 6d ee			ld (debug_mark+2),a  
8388 18 03			jr .pastdmark  
838a ..			.dmark: db "LB3"  
838d f1			.pastdmark: pop af  
838e			endm  
# End of macro DMARK
838e					CALLMONITOR 
838e cd 6f ee			call debug_vector  
8391				endm  
# End of macro CALLMONITOR
8391				endif 
8391 ed b0			ldir 
8393				; save default page 0 
8393			 
8393 21 00 00			ld hl, 0 
8396 11 7a ea			ld de, store_page 
8399				if DEBUG_STORESE 
8399					DMARK "LBW" 
8399 f5				push af  
839a 3a ae 83			ld a, (.dmark)  
839d 32 6b ee			ld (debug_mark),a  
83a0 3a af 83			ld a, (.dmark+1)  
83a3 32 6c ee			ld (debug_mark+1),a  
83a6 3a b0 83			ld a, (.dmark+2)  
83a9 32 6d ee			ld (debug_mark+2),a  
83ac 18 03			jr .pastdmark  
83ae ..			.dmark: db "LBW"  
83b1 f1			.pastdmark: pop af  
83b2			endm  
# End of macro DMARK
83b2					CALLMONITOR 
83b2 cd 6f ee			call debug_vector  
83b5				endm  
# End of macro CALLMONITOR
83b5				endif 
83b5 cd de 81			call storage_write_block 
83b8			 
83b8 c9				ret 
83b9			 
83b9			 
83b9			 
83b9			; Read Block 0 - Config 
83b9			; --------------------- 
83b9			; 
83b9			; With current bank 
83b9			; Call presence test 
83b9			;    If not present format/init bank  
83b9			; Read block 0  
83b9			;  
83b9			 
83b9			 
83b9			; Dir 
83b9			; --- 
83b9			; 
83b9			; With current bank 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block read byte 2 
83b9			;      if first block of file 
83b9			;         Display file name 
83b9			;         Display type flags for file 
83b9			;        
83b9			 
83b9			; moving to words as this requires stack control 
83b9			 
83b9			 
83b9			; Delete File 
83b9			; ----------- 
83b9			; 
83b9			; With current bank 
83b9			; 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block file id 
83b9			;      If first block of file and dont have file id 
83b9			;         if file to delete 
83b9			;         Save file id 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			;      If file id is one saved 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			 
83b9			 
83b9			.se_done: 
83b9 e1				pop hl 
83ba c9				ret 
83bb			 
83bb			storage_erase: 
83bb			 
83bb				; hl contains the file id 
83bb			 
83bb 5d				ld e, l 
83bc 16 00			ld d, 0 
83be 21 40 00			ld hl, STORE_BLOCK_PHY 
83c1					if DEBUG_FORTH_WORDS 
83c1						DMARK "ERA" 
83c1 f5				push af  
83c2 3a d6 83			ld a, (.dmark)  
83c5 32 6b ee			ld (debug_mark),a  
83c8 3a d7 83			ld a, (.dmark+1)  
83cb 32 6c ee			ld (debug_mark+1),a  
83ce 3a d8 83			ld a, (.dmark+2)  
83d1 32 6d ee			ld (debug_mark+2),a  
83d4 18 03			jr .pastdmark  
83d6 ..			.dmark: db "ERA"  
83d9 f1			.pastdmark: pop af  
83da			endm  
# End of macro DMARK
83da						CALLMONITOR 
83da cd 6f ee			call debug_vector  
83dd				endm  
# End of macro CALLMONITOR
83dd					endif 
83dd cd ac 84			call storage_findnextid 
83e0 cd 05 8d			call ishlzero 
83e3 c8				ret z 
83e4			 
83e4 e5				push hl 
83e5			 
83e5				; TODO check file not found 
83e5			 
83e5 11 7a ea			ld de, store_page 
83e8 cd 79 81			call storage_read_block 
83eb			 
83eb cd 05 8d			call ishlzero 
83ee ca b9 83			jp z,.se_done 
83f1			 
83f1					if DEBUG_FORTH_WORDS 
83f1						DMARK "ER1" 
83f1 f5				push af  
83f2 3a 06 84			ld a, (.dmark)  
83f5 32 6b ee			ld (debug_mark),a  
83f8 3a 07 84			ld a, (.dmark+1)  
83fb 32 6c ee			ld (debug_mark+1),a  
83fe 3a 08 84			ld a, (.dmark+2)  
8401 32 6d ee			ld (debug_mark+2),a  
8404 18 03			jr .pastdmark  
8406 ..			.dmark: db "ER1"  
8409 f1			.pastdmark: pop af  
840a			endm  
# End of macro DMARK
840a						CALLMONITOR 
840a cd 6f ee			call debug_vector  
840d				endm  
# End of macro CALLMONITOR
840d					endif 
840d 3a 7a ea			ld a, (store_page)	; get file id 
8410 32 6e ea			ld (store_tmpid), a 
8413			 
8413 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
8416 32 6d ea			ld (store_tmpext), a 
8419			 
8419				; wipe file header 
8419			 
8419 e1				pop hl 
841a 3e 00			ld a, 0 
841c 32 7a ea			ld (store_page), a 
841f 32 7b ea			ld (store_page+1),a 
8422 11 7a ea			ld de, store_page 
8425					if DEBUG_FORTH_WORDS 
8425						DMARK "ER2" 
8425 f5				push af  
8426 3a 3a 84			ld a, (.dmark)  
8429 32 6b ee			ld (debug_mark),a  
842c 3a 3b 84			ld a, (.dmark+1)  
842f 32 6c ee			ld (debug_mark+1),a  
8432 3a 3c 84			ld a, (.dmark+2)  
8435 32 6d ee			ld (debug_mark+2),a  
8438 18 03			jr .pastdmark  
843a ..			.dmark: db "ER2"  
843d f1			.pastdmark: pop af  
843e			endm  
# End of macro DMARK
843e						CALLMONITOR 
843e cd 6f ee			call debug_vector  
8441				endm  
# End of macro CALLMONITOR
8441					endif 
8441 cd de 81			call storage_write_block 
8444			 
8444			 
8444				; wipe file extents 
8444			 
8444 3a 6d ea			ld a, (store_tmpext) 
8447 47				ld b, a 
8448			 
8448			.eraext:	  
8448 c5				push bc 
8449			 
8449 21 40 00			ld hl, STORE_BLOCK_PHY 
844c 3a 6e ea			ld a,(store_tmpid) 
844f 5f				ld e, a 
8450 50				ld d, b	 
8451					if DEBUG_FORTH_WORDS 
8451						DMARK "ER3" 
8451 f5				push af  
8452 3a 66 84			ld a, (.dmark)  
8455 32 6b ee			ld (debug_mark),a  
8458 3a 67 84			ld a, (.dmark+1)  
845b 32 6c ee			ld (debug_mark+1),a  
845e 3a 68 84			ld a, (.dmark+2)  
8461 32 6d ee			ld (debug_mark+2),a  
8464 18 03			jr .pastdmark  
8466 ..			.dmark: db "ER3"  
8469 f1			.pastdmark: pop af  
846a			endm  
# End of macro DMARK
846a						CALLMONITOR 
846a cd 6f ee			call debug_vector  
846d				endm  
# End of macro CALLMONITOR
846d					endif 
846d cd ac 84			call storage_findnextid 
8470 cd 05 8d			call ishlzero 
8473 ca b9 83			jp z,.se_done 
8476			 
8476 e5				push hl 
8477 11 7a ea			ld de, store_page 
847a cd 79 81			call storage_read_block 
847d			 
847d				; free block	 
847d			 
847d 3e 00			ld a, 0 
847f 32 7a ea			ld (store_page), a 
8482 32 7b ea			ld (store_page+1),a 
8485 11 7a ea			ld de, store_page 
8488 e1				pop hl 
8489					if DEBUG_FORTH_WORDS 
8489						DMARK "ER4" 
8489 f5				push af  
848a 3a 9e 84			ld a, (.dmark)  
848d 32 6b ee			ld (debug_mark),a  
8490 3a 9f 84			ld a, (.dmark+1)  
8493 32 6c ee			ld (debug_mark+1),a  
8496 3a a0 84			ld a, (.dmark+2)  
8499 32 6d ee			ld (debug_mark+2),a  
849c 18 03			jr .pastdmark  
849e ..			.dmark: db "ER4"  
84a1 f1			.pastdmark: pop af  
84a2			endm  
# End of macro DMARK
84a2						CALLMONITOR 
84a2 cd 6f ee			call debug_vector  
84a5				endm  
# End of macro CALLMONITOR
84a5					endif 
84a5 cd de 81			call storage_write_block 
84a8			 
84a8 c1				pop bc 
84a9 10 9d			djnz .eraext 
84ab			 
84ab c9				ret 
84ac			 
84ac			 
84ac			; Find Free Block 
84ac			; --------------- 
84ac			; 
84ac			; With current bank 
84ac			;  
84ac			; From given starting logical block 
84ac			;    Read block  
84ac			;    If no file id 
84ac			;         Return block id 
84ac			 
84ac			 
84ac			; hl starting page number 
84ac			; hl contains free page number or zero if no pages free 
84ac			; e contains the file id to locate 
84ac			; d contains the block number 
84ac			 
84ac			; TODO change to find file id and use zero for free block 
84ac			 
84ac			storage_findnextid: 
84ac			 
84ac				; now locate first 0 page to mark as a free block 
84ac			 
84ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ae			;	ld hl, STORE_BLOCK_PHY 
84ae			 
84ae					if DEBUG_FORTH_WORDS 
84ae					DMARK "FNI" 
84ae f5				push af  
84af 3a c3 84			ld a, (.dmark)  
84b2 32 6b ee			ld (debug_mark),a  
84b5 3a c4 84			ld a, (.dmark+1)  
84b8 32 6c ee			ld (debug_mark+1),a  
84bb 3a c5 84			ld a, (.dmark+2)  
84be 32 6d ee			ld (debug_mark+2),a  
84c1 18 03			jr .pastdmark  
84c3 ..			.dmark: db "FNI"  
84c6 f1			.pastdmark: pop af  
84c7			endm  
# End of macro DMARK
84c7						CALLMONITOR 
84c7 cd 6f ee			call debug_vector  
84ca				endm  
# End of macro CALLMONITOR
84ca					endif 
84ca			.ff1:   	 
84ca e5					push hl 
84cb c5					push bc 
84cc d5					push de 
84cd cd 9d 80				call se_readbyte 
84d0 5f					ld e,a 
84d1 23					inc hl 
84d2 cd 9d 80				call se_readbyte 
84d5 57					ld d, a 
84d6 e1					pop hl 
84d7 e5					push hl 
84d8 cd fa 8c				call cmp16 
84db 28 49				jr z, .fffound 
84dd			 
84dd d1					pop de 
84de c1					pop bc 
84df e1					pop hl 
84e0			 
84e0					; is found? 
84e0					;cp e 
84e0					;ret z 
84e0			 
84e0 3e 40				ld a, STORE_BLOCK_PHY 
84e2 cd dc 8c				call addatohl 
84e5 10 e3				djnz .ff1 
84e7			 
84e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e9			.ff2:   	 
84e9			 
84e9 e5					push hl 
84ea c5					push bc 
84eb d5					push de 
84ec cd 9d 80				call se_readbyte 
84ef 5f					ld e,a 
84f0 23					inc hl 
84f1 cd 9d 80				call se_readbyte 
84f4 57					ld d, a 
84f5			 
84f5 e1					pop hl 
84f6 e5					push hl 
84f7 cd fa 8c				call cmp16 
84fa 28 2a				jr z, .fffound 
84fc			 
84fc d1					pop de 
84fd c1					pop bc 
84fe e1					pop hl 
84ff					; is found? 
84ff					;cp e 
84ff					;ret z 
84ff			 
84ff 3e 40				ld a, STORE_BLOCK_PHY 
8501 cd dc 8c				call addatohl 
8504 10 e3				djnz .ff2 
8506			 
8506			 
8506					if DEBUG_FORTH_WORDS 
8506					DMARK "FN-" 
8506 f5				push af  
8507 3a 1b 85			ld a, (.dmark)  
850a 32 6b ee			ld (debug_mark),a  
850d 3a 1c 85			ld a, (.dmark+1)  
8510 32 6c ee			ld (debug_mark+1),a  
8513 3a 1d 85			ld a, (.dmark+2)  
8516 32 6d ee			ld (debug_mark+2),a  
8519 18 03			jr .pastdmark  
851b ..			.dmark: db "FN-"  
851e f1			.pastdmark: pop af  
851f			endm  
# End of macro DMARK
851f					;	push af 
851f					;	ld a, 'n' 
851f					;	ld (debug_mark),a 
851f					;	pop af 
851f						CALLMONITOR 
851f cd 6f ee			call debug_vector  
8522				endm  
# End of macro CALLMONITOR
8522					endif 
8522				; no free marks! 
8522 21 00 00				ld hl, 0 
8525 c9				ret 
8526			.fffound: 
8526				 
8526			 
8526 d1					pop de 
8527 c1					pop bc 
8528 e1					pop hl 
8529					if DEBUG_FORTH_WORDS 
8529					DMARK "FNF" 
8529 f5				push af  
852a 3a 3e 85			ld a, (.dmark)  
852d 32 6b ee			ld (debug_mark),a  
8530 3a 3f 85			ld a, (.dmark+1)  
8533 32 6c ee			ld (debug_mark+1),a  
8536 3a 40 85			ld a, (.dmark+2)  
8539 32 6d ee			ld (debug_mark+2),a  
853c 18 03			jr .pastdmark  
853e ..			.dmark: db "FNF"  
8541 f1			.pastdmark: pop af  
8542			endm  
# End of macro DMARK
8542					;	push af 
8542					;	ld a, 'n' 
8542					;	ld (debug_mark),a 
8542					;	pop af 
8542						CALLMONITOR 
8542 cd 6f ee			call debug_vector  
8545				endm  
# End of macro CALLMONITOR
8545					endif 
8545 c9				ret 
8546			 
8546			 
8546			 
8546			; Free Space 
8546			; ---------- 
8546			; 
8546			; With current bank 
8546			; 
8546			; Set block count to zero 
8546			; Starting with first logical block 
8546			;      Find free block  
8546			;      If block id given, increment block count 
8546			; 
8546			;  
8546			 
8546			 
8546			; hl contains count of free blocks 
8546			 
8546			storage_freeblocks: 
8546			 
8546				; now locate first 0 page to mark as a free block 
8546			 
8546 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8548 21 40 00			ld hl, STORE_BLOCK_PHY 
854b 11 00 00			ld de, 0 
854e			 
854e			.fb1:   	 
854e e5					push hl 
854f c5					push bc 
8550 d5					push de 
8551 cd 9d 80				call se_readbyte 
8554 d1					pop de 
8555 c1					pop bc 
8556 e1					pop hl 
8557			 
8557					; is free? 
8557 fe 00				cp 0 
8559 20 01				jr nz, .ff1cont 
855b 13					inc de 
855c			 
855c			.ff1cont: 
855c			 
855c			 
855c 3e 40				ld a, STORE_BLOCK_PHY 
855e cd dc 8c				call addatohl 
8561 10 eb				djnz .fb1 
8563			 
8563 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8565			.fb2:   	 
8565 e5					push hl 
8566 c5					push bc 
8567 d5					push de 
8568 cd 9d 80				call se_readbyte 
856b d1					pop de 
856c c1					pop bc 
856d e1					pop hl 
856e			 
856e					; is free? 
856e fe 00				cp 0 
8570 20 01				jr nz, .ff2cont 
8572 13					inc de 
8573			 
8573			.ff2cont: 
8573			 
8573 3e 40				ld a, STORE_BLOCK_PHY 
8575 cd dc 8c				call addatohl 
8578 10 eb				djnz .fb2 
857a			 
857a eb				ex de, hl 
857b c9				ret 
857c			 
857c			; Get File ID 
857c			; ----------- 
857c			; 
857c			; With current bank 
857c			;  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; For each logical block 
857c			;    Read block file id 
857c			;      If first block of file and dont have file id 
857c			;         if file get id and exit 
857c			 
857c			 
857c			 
857c			 
857c			; Create File 
857c			; ----------- 
857c			; 
857c			; With current bank  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; Increment file id number 
857c			; Save Config 
857c			; Find free block 
857c			; Set buffer with file name and file id 
857c			; Write buffer to free block  
857c			 
857c			 
857c			; hl point to file name 
857c			; hl returns file id 
857c			 
857c			; file format: 
857c			; byte 0 - file id 
857c			; byte 1 - extent number 
857c			; byte 2-> data 
857c			 
857c			; format for extent number 0: 
857c			; 
857c			; byte 0 - file id 
857c			; byte 1 - extent 0 
857c			; byte 2 - extent count 
857c			; byte 3 -> file name and meta data 
857c			 
857c			 
857c			storage_create: 
857c				if DEBUG_STORESE 
857c					DMARK "SCR" 
857c f5				push af  
857d 3a 91 85			ld a, (.dmark)  
8580 32 6b ee			ld (debug_mark),a  
8583 3a 92 85			ld a, (.dmark+1)  
8586 32 6c ee			ld (debug_mark+1),a  
8589 3a 93 85			ld a, (.dmark+2)  
858c 32 6d ee			ld (debug_mark+2),a  
858f 18 03			jr .pastdmark  
8591 ..			.dmark: db "SCR"  
8594 f1			.pastdmark: pop af  
8595			endm  
# End of macro DMARK
8595					CALLMONITOR 
8595 cd 6f ee			call debug_vector  
8598				endm  
# End of macro CALLMONITOR
8598				endif 
8598			 
8598 e5				push hl		; save file name pointer 
8599			 
8599 cd 2a 82			call storage_get_block_0 
859c			 
859c 3a 7a ea			ld a,(store_page)	; get current file id 
859f 3c				inc a 
85a0 32 7a ea			ld (store_page),a 
85a3				 
85a3 32 6e ea			ld (store_tmpid),a			; save id 
85a6			 
85a6 21 00 00			ld hl, 0 
85a9 11 7a ea			ld de, store_page 
85ac				if DEBUG_STORESE 
85ac					DMARK "SCw" 
85ac f5				push af  
85ad 3a c1 85			ld a, (.dmark)  
85b0 32 6b ee			ld (debug_mark),a  
85b3 3a c2 85			ld a, (.dmark+1)  
85b6 32 6c ee			ld (debug_mark+1),a  
85b9 3a c3 85			ld a, (.dmark+2)  
85bc 32 6d ee			ld (debug_mark+2),a  
85bf 18 03			jr .pastdmark  
85c1 ..			.dmark: db "SCw"  
85c4 f1			.pastdmark: pop af  
85c5			endm  
# End of macro DMARK
85c5					CALLMONITOR 
85c5 cd 6f ee			call debug_vector  
85c8				endm  
# End of macro CALLMONITOR
85c8				endif 
85c8 cd de 81			call storage_write_block	 ; save update 
85cb			 
85cb				if DEBUG_STORESE 
85cb 11 7a ea				ld de, store_page 
85ce					DMARK "SCC" 
85ce f5				push af  
85cf 3a e3 85			ld a, (.dmark)  
85d2 32 6b ee			ld (debug_mark),a  
85d5 3a e4 85			ld a, (.dmark+1)  
85d8 32 6c ee			ld (debug_mark+1),a  
85db 3a e5 85			ld a, (.dmark+2)  
85de 32 6d ee			ld (debug_mark+2),a  
85e1 18 03			jr .pastdmark  
85e3 ..			.dmark: db "SCC"  
85e6 f1			.pastdmark: pop af  
85e7			endm  
# End of macro DMARK
85e7					CALLMONITOR 
85e7 cd 6f ee			call debug_vector  
85ea				endm  
# End of macro CALLMONITOR
85ea				endif 
85ea				;  
85ea				 
85ea 21 40 00			ld hl, STORE_BLOCK_PHY 
85ed 11 00 00			ld de, 0 
85f0 cd ac 84			call storage_findnextid 
85f3			 
85f3 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
85f6			 
85f6				; TODO detect 0 = no spare blocks 
85f6			 
85f6				; hl now contains the free page to use for the file header page 
85f6			 
85f6				if DEBUG_STORESE 
85f6				DMARK "SCF" 
85f6 f5				push af  
85f7 3a 0b 86			ld a, (.dmark)  
85fa 32 6b ee			ld (debug_mark),a  
85fd 3a 0c 86			ld a, (.dmark+1)  
8600 32 6c ee			ld (debug_mark+1),a  
8603 3a 0d 86			ld a, (.dmark+2)  
8606 32 6d ee			ld (debug_mark+2),a  
8609 18 03			jr .pastdmark  
860b ..			.dmark: db "SCF"  
860e f1			.pastdmark: pop af  
860f			endm  
# End of macro DMARK
860f					CALLMONITOR 
860f cd 6f ee			call debug_vector  
8612				endm  
# End of macro CALLMONITOR
8612				endif 
8612			 
8612 22 65 ea			ld (store_tmppageid), hl 
8615				 
8615 3a 6e ea			ld a,(store_tmpid)    ; get file id 
8618			;	ld a, (store_filecache)			; save to cache 
8618			 
8618 32 7a ea			ld (store_page),a    ; set page id 
861b 3e 00			ld a, 0			 ; extent 0 is file header 
861d 32 7b ea			ld (store_page+1), a   ; set file extent 
8620			 
8620 32 7c ea			ld (store_page+2), a   ; extent count for the file 
8623			 
8623			;	inc hl 		; init block 0 of file 
8623			;	inc hl   		; skip file and extent id 
8623			 ;       ld a, 0 
8623			;	ld (hl),a 
8623			;	ld a, (store_filecache+1)  	; save to cache 
8623			 
8623			;	inc hl    ; file name 
8623				 
8623				 
8623 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8626				if DEBUG_STORESE 
8626					DMARK "SCc" 
8626 f5				push af  
8627 3a 3b 86			ld a, (.dmark)  
862a 32 6b ee			ld (debug_mark),a  
862d 3a 3c 86			ld a, (.dmark+1)  
8630 32 6c ee			ld (debug_mark+1),a  
8633 3a 3d 86			ld a, (.dmark+2)  
8636 32 6d ee			ld (debug_mark+2),a  
8639 18 03			jr .pastdmark  
863b ..			.dmark: db "SCc"  
863e f1			.pastdmark: pop af  
863f			endm  
# End of macro DMARK
863f					CALLMONITOR 
863f cd 6f ee			call debug_vector  
8642				endm  
# End of macro CALLMONITOR
8642				endif 
8642 e1				pop hl    ; get zero term string 
8643 e5				push hl 
8644 3e 00			ld a, 0 
8646 cd 45 91			call strlent 
8649 23				inc hl   ; cover zero term 
864a 06 00			ld b,0 
864c 4d				ld c,l 
864d e1				pop hl 
864e				;ex de, hl 
864e				if DEBUG_STORESE 
864e					DMARK "SCa" 
864e f5				push af  
864f 3a 63 86			ld a, (.dmark)  
8652 32 6b ee			ld (debug_mark),a  
8655 3a 64 86			ld a, (.dmark+1)  
8658 32 6c ee			ld (debug_mark+1),a  
865b 3a 65 86			ld a, (.dmark+2)  
865e 32 6d ee			ld (debug_mark+2),a  
8661 18 03			jr .pastdmark  
8663 ..			.dmark: db "SCa"  
8666 f1			.pastdmark: pop af  
8667			endm  
# End of macro DMARK
8667					;push af 
8667					;ld a, 'a' 
8667					;ld (debug_mark),a 
8667					;pop af 
8667					CALLMONITOR 
8667 cd 6f ee			call debug_vector  
866a				endm  
# End of macro CALLMONITOR
866a				endif 
866a ed b0			ldir    ; copy zero term string 
866c				if DEBUG_STORESE 
866c					DMARK "SCA" 
866c f5				push af  
866d 3a 81 86			ld a, (.dmark)  
8670 32 6b ee			ld (debug_mark),a  
8673 3a 82 86			ld a, (.dmark+1)  
8676 32 6c ee			ld (debug_mark+1),a  
8679 3a 83 86			ld a, (.dmark+2)  
867c 32 6d ee			ld (debug_mark+2),a  
867f 18 03			jr .pastdmark  
8681 ..			.dmark: db "SCA"  
8684 f1			.pastdmark: pop af  
8685			endm  
# End of macro DMARK
8685					CALLMONITOR 
8685 cd 6f ee			call debug_vector  
8688				endm  
# End of macro CALLMONITOR
8688				endif 
8688			 
8688				; write file header page 
8688			 
8688 2a 65 ea			ld hl,(store_tmppageid) 
868b 11 7a ea			ld de, store_page 
868e				if DEBUG_STORESE 
868e					DMARK "SCb" 
868e f5				push af  
868f 3a a3 86			ld a, (.dmark)  
8692 32 6b ee			ld (debug_mark),a  
8695 3a a4 86			ld a, (.dmark+1)  
8698 32 6c ee			ld (debug_mark+1),a  
869b 3a a5 86			ld a, (.dmark+2)  
869e 32 6d ee			ld (debug_mark+2),a  
86a1 18 03			jr .pastdmark  
86a3 ..			.dmark: db "SCb"  
86a6 f1			.pastdmark: pop af  
86a7			endm  
# End of macro DMARK
86a7					;push af 
86a7					;ld a, 'b' 
86a7					;ld (debug_mark),a 
86a7					;pop af 
86a7					CALLMONITOR 
86a7 cd 6f ee			call debug_vector  
86aa				endm  
# End of macro CALLMONITOR
86aa				endif 
86aa cd de 81			call storage_write_block 
86ad			 
86ad 3a 6e ea			ld a, (store_tmpid) 
86b0 6f				ld l, a 
86b1 26 00			ld h,0 
86b3				if DEBUG_STORESE 
86b3					DMARK "SCz" 
86b3 f5				push af  
86b4 3a c8 86			ld a, (.dmark)  
86b7 32 6b ee			ld (debug_mark),a  
86ba 3a c9 86			ld a, (.dmark+1)  
86bd 32 6c ee			ld (debug_mark+1),a  
86c0 3a ca 86			ld a, (.dmark+2)  
86c3 32 6d ee			ld (debug_mark+2),a  
86c6 18 03			jr .pastdmark  
86c8 ..			.dmark: db "SCz"  
86cb f1			.pastdmark: pop af  
86cc			endm  
# End of macro DMARK
86cc					CALLMONITOR 
86cc cd 6f ee			call debug_vector  
86cf				endm  
# End of macro CALLMONITOR
86cf				endif 
86cf c9				ret 
86d0				 
86d0			 
86d0			 
86d0			; 
86d0			; Read File 
86d0			; 
86d0			; h - file id to locate 
86d0			; l - extent to locate 
86d0			; de - pointer to string to read into 
86d0			; 
86d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86d0			 
86d0			.sr_fail: 
86d0 d1				pop de 
86d1 c9				ret 
86d2			 
86d2			storage_read: 
86d2			 
86d2			 
86d2 d5				push de 
86d3			 
86d3			; TODO BUG the above push is it popped before the RET Z? 
86d3			 
86d3			; TODO how to handle multiple part blocks 
86d3			 
86d3				; locate file extent to read 
86d3			 
86d3 5c				ld e, h 
86d4 55				ld d, l 
86d5			 
86d5			.srext: 
86d5 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
86d8 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86dc			 
86dc 21 40 00			ld hl, STORE_BLOCK_PHY 
86df				if DEBUG_STORESE 
86df					DMARK "sre" 
86df f5				push af  
86e0 3a f4 86			ld a, (.dmark)  
86e3 32 6b ee			ld (debug_mark),a  
86e6 3a f5 86			ld a, (.dmark+1)  
86e9 32 6c ee			ld (debug_mark+1),a  
86ec 3a f6 86			ld a, (.dmark+2)  
86ef 32 6d ee			ld (debug_mark+2),a  
86f2 18 03			jr .pastdmark  
86f4 ..			.dmark: db "sre"  
86f7 f1			.pastdmark: pop af  
86f8			endm  
# End of macro DMARK
86f8					CALLMONITOR 
86f8 cd 6f ee			call debug_vector  
86fb				endm  
# End of macro CALLMONITOR
86fb				endif 
86fb cd ac 84			call storage_findnextid 
86fe			 
86fe				if DEBUG_STORESE 
86fe					DMARK "srf" 
86fe f5				push af  
86ff 3a 13 87			ld a, (.dmark)  
8702 32 6b ee			ld (debug_mark),a  
8705 3a 14 87			ld a, (.dmark+1)  
8708 32 6c ee			ld (debug_mark+1),a  
870b 3a 15 87			ld a, (.dmark+2)  
870e 32 6d ee			ld (debug_mark+2),a  
8711 18 03			jr .pastdmark  
8713 ..			.dmark: db "srf"  
8716 f1			.pastdmark: pop af  
8717			endm  
# End of macro DMARK
8717					CALLMONITOR 
8717 cd 6f ee			call debug_vector  
871a				endm  
# End of macro CALLMONITOR
871a				endif 
871a cd 05 8d			call ishlzero 
871d			;	ld a, l 
871d			;	add h 
871d			;	cp 0 
871d 28 b1			jr z,.sr_fail			; block not found so EOF 
871f			 
871f				; save current address for use by higher level words etc 
871f			 
871f 22 6b ea			ld (store_openaddr),hl 
8722			 
8722			 
8722				; hl contains page number to load 
8722 d1				pop de   ; get storage 
8723 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
8727 d5				push de 
8728				if DEBUG_STORESE 
8728					DMARK "srg" 
8728 f5				push af  
8729 3a 3d 87			ld a, (.dmark)  
872c 32 6b ee			ld (debug_mark),a  
872f 3a 3e 87			ld a, (.dmark+1)  
8732 32 6c ee			ld (debug_mark+1),a  
8735 3a 3f 87			ld a, (.dmark+2)  
8738 32 6d ee			ld (debug_mark+2),a  
873b 18 03			jr .pastdmark  
873d ..			.dmark: db "srg"  
8740 f1			.pastdmark: pop af  
8741			endm  
# End of macro DMARK
8741					CALLMONITOR 
8741 cd 6f ee			call debug_vector  
8744				endm  
# End of macro CALLMONITOR
8744				endif 
8744 cd 79 81			call storage_read_block 
8747			 
8747				; if this a continuation read??? 
8747			 
8747 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
874a			 
874a 3e 3f			ld a, STORE_BLOCK_PHY-1 
874c cd dc 8c			call addatohl 
874f 7e				ld a,(hl) 
8750 fe 00			cp 0 
8752 28 02			jr z, .markiscont 
8754 3e ff			ld a, 255 
8756			 
8756			.markiscont: 
8756 32 6d ea			ld (store_readcont), a 
8759			 
8759				if DEBUG_STORESE 
8759					DMARK "srC" 
8759 f5				push af  
875a 3a 6e 87			ld a, (.dmark)  
875d 32 6b ee			ld (debug_mark),a  
8760 3a 6f 87			ld a, (.dmark+1)  
8763 32 6c ee			ld (debug_mark+1),a  
8766 3a 70 87			ld a, (.dmark+2)  
8769 32 6d ee			ld (debug_mark+2),a  
876c 18 03			jr .pastdmark  
876e ..			.dmark: db "srC"  
8771 f1			.pastdmark: pop af  
8772			endm  
# End of macro DMARK
8772					CALLMONITOR 
8772 cd 6f ee			call debug_vector  
8775				endm  
# End of macro CALLMONITOR
8775				endif 
8775				; only short reads enabled 
8775			 
8775 3a 75 ea			ld a, (store_longread) 
8778 fe 00			cp 0 
877a ca 47 88			jp z, .readdone 
877d			 
877d			; TODO if block has no zeros then need to read next block  
877d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877d			; check last byte of physical block. 
877d			; if not zero then the next block needs to be loaded 
877d			 
877d			 
877d 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8780			 
8780 3e 3f			ld a, STORE_BLOCK_PHY-1 
8782 cd dc 8c			call addatohl 
8785				;dec hl 
8785 7e				ld a,(hl) 
8786				if DEBUG_STORESE 
8786					DMARK "sr?" 
8786 f5				push af  
8787 3a 9b 87			ld a, (.dmark)  
878a 32 6b ee			ld (debug_mark),a  
878d 3a 9c 87			ld a, (.dmark+1)  
8790 32 6c ee			ld (debug_mark+1),a  
8793 3a 9d 87			ld a, (.dmark+2)  
8796 32 6d ee			ld (debug_mark+2),a  
8799 18 03			jr .pastdmark  
879b ..			.dmark: db "sr?"  
879e f1			.pastdmark: pop af  
879f			endm  
# End of macro DMARK
879f					CALLMONITOR 
879f cd 6f ee			call debug_vector  
87a2				endm  
# End of macro CALLMONITOR
87a2				endif 
87a2 fe 00			cp 0 
87a4 ca 47 88			jp z, .readdone 
87a7			 
87a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a7			 
87a7 23				inc hl 
87a8			 
87a8 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87ab			 
87ab ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
87af			 
87af eb				ex de, hl 
87b0			 
87b0				; next ext 
87b0			 
87b0 23				inc hl 
87b1 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
87b4			 
87b4				if DEBUG_STORESE 
87b4					DMARK "sF2" 
87b4 f5				push af  
87b5 3a c9 87			ld a, (.dmark)  
87b8 32 6b ee			ld (debug_mark),a  
87bb 3a ca 87			ld a, (.dmark+1)  
87be 32 6c ee			ld (debug_mark+1),a  
87c1 3a cb 87			ld a, (.dmark+2)  
87c4 32 6d ee			ld (debug_mark+2),a  
87c7 18 03			jr .pastdmark  
87c9 ..			.dmark: db "sF2"  
87cc f1			.pastdmark: pop af  
87cd			endm  
# End of macro DMARK
87cd					CALLMONITOR 
87cd cd 6f ee			call debug_vector  
87d0				endm  
# End of macro CALLMONITOR
87d0				endif 
87d0			 
87d0				; get and load block 
87d0			 
87d0 cd ac 84			call storage_findnextid 
87d3			 
87d3				if DEBUG_STORESE 
87d3					DMARK "sf2" 
87d3 f5				push af  
87d4 3a e8 87			ld a, (.dmark)  
87d7 32 6b ee			ld (debug_mark),a  
87da 3a e9 87			ld a, (.dmark+1)  
87dd 32 6c ee			ld (debug_mark+1),a  
87e0 3a ea 87			ld a, (.dmark+2)  
87e3 32 6d ee			ld (debug_mark+2),a  
87e6 18 03			jr .pastdmark  
87e8 ..			.dmark: db "sf2"  
87eb f1			.pastdmark: pop af  
87ec			endm  
# End of macro DMARK
87ec					CALLMONITOR 
87ec cd 6f ee			call debug_vector  
87ef				endm  
# End of macro CALLMONITOR
87ef				endif 
87ef cd 05 8d			call ishlzero 
87f2			;	ld a, l 
87f2			;	add h 
87f2			;	cp 0 
87f2 ca d0 86			jp z,.sr_fail			; block not found so EOF 
87f5				 
87f5				; save current address for use by higher level words etc 
87f5			 
87f5 22 6b ea			ld (store_openaddr),hl 
87f8			 
87f8 cd 79 81			call storage_read_block 
87fb			 
87fb				; on a continuation block, we now have the file id and ext in the middle of the block 
87fb				; we need to pull everything back  
87fb			 
87fb ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87ff 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
8802 23				inc hl 
8803 23				inc hl     ; skip id and ext 
8804 01 40 00			ld bc, STORE_BLOCK_PHY 
8807				if DEBUG_STORESE 
8807					DMARK "SR<" 
8807 f5				push af  
8808 3a 1c 88			ld a, (.dmark)  
880b 32 6b ee			ld (debug_mark),a  
880e 3a 1d 88			ld a, (.dmark+1)  
8811 32 6c ee			ld (debug_mark+1),a  
8814 3a 1e 88			ld a, (.dmark+2)  
8817 32 6d ee			ld (debug_mark+2),a  
881a 18 03			jr .pastdmark  
881c ..			.dmark: db "SR<"  
881f f1			.pastdmark: pop af  
8820			endm  
# End of macro DMARK
8820					CALLMONITOR 
8820 cd 6f ee			call debug_vector  
8823				endm  
# End of macro CALLMONITOR
8823				endif 
8823 ed b0			ldir     ; copy data 
8825			 
8825				; move the pointer back and pretend we have a full buffer for next recheck 
8825			 
8825 1b				dec de 
8826 1b				dec de 
8827			 
8827			; TODO do pop below now short circuit loop????? 
8827 c1				pop bc     ; get rid of spare de on stack 
8828				if DEBUG_STORESE 
8828					DMARK "SR>" 
8828 f5				push af  
8829 3a 3d 88			ld a, (.dmark)  
882c 32 6b ee			ld (debug_mark),a  
882f 3a 3e 88			ld a, (.dmark+1)  
8832 32 6c ee			ld (debug_mark+1),a  
8835 3a 3f 88			ld a, (.dmark+2)  
8838 32 6d ee			ld (debug_mark+2),a  
883b 18 03			jr .pastdmark  
883d ..			.dmark: db "SR>"  
8840 f1			.pastdmark: pop af  
8841			endm  
# End of macro DMARK
8841					CALLMONITOR 
8841 cd 6f ee			call debug_vector  
8844				endm  
# End of macro CALLMONITOR
8844				endif 
8844 c3 d5 86			jp .srext 
8847			 
8847			 
8847			 
8847			 
8847			 
8847			.readdone:		 
8847 e1				pop hl 		 ; return start of data to show as not EOF 
8848 23				inc hl   ; past file id 
8849 23				inc hl   ; past ext 
884a				if DEBUG_STORESE 
884a					DMARK "SRe" 
884a f5				push af  
884b 3a 5f 88			ld a, (.dmark)  
884e 32 6b ee			ld (debug_mark),a  
8851 3a 60 88			ld a, (.dmark+1)  
8854 32 6c ee			ld (debug_mark+1),a  
8857 3a 61 88			ld a, (.dmark+2)  
885a 32 6d ee			ld (debug_mark+2),a  
885d 18 03			jr .pastdmark  
885f ..			.dmark: db "SRe"  
8862 f1			.pastdmark: pop af  
8863			endm  
# End of macro DMARK
8863					CALLMONITOR 
8863 cd 6f ee			call debug_vector  
8866				endm  
# End of macro CALLMONITOR
8866				endif 
8866 c9					ret 
8867			 
8867			 
8867			 
8867			; 
8867			; Append File 
8867			; 
8867			; hl - file id to locate 
8867			; de - pointer to (multi block) string to write 
8867			 
8867			.sa_notfound: 
8867 d1				pop de 
8868 c9				ret 
8869			 
8869			 
8869			storage_append: 
8869				; hl -  file id to append to 
8869				; de - string to append 
8869			 
8869 d5				push de 
886a				 
886a				if DEBUG_STORESE 
886a					DMARK "AP1" 
886a f5				push af  
886b 3a 7f 88			ld a, (.dmark)  
886e 32 6b ee			ld (debug_mark),a  
8871 3a 80 88			ld a, (.dmark+1)  
8874 32 6c ee			ld (debug_mark+1),a  
8877 3a 81 88			ld a, (.dmark+2)  
887a 32 6d ee			ld (debug_mark+2),a  
887d 18 03			jr .pastdmark  
887f ..			.dmark: db "AP1"  
8882 f1			.pastdmark: pop af  
8883			endm  
# End of macro DMARK
8883					CALLMONITOR 
8883 cd 6f ee			call debug_vector  
8886				endm  
# End of macro CALLMONITOR
8886				endif 
8886			 
8886 7d				ld a, l 
8887 32 6e ea			ld (store_tmpid), a 
888a			 
888a				; get file header  
888a			 
888a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
888c 3a 6e ea			ld a, (store_tmpid) 
888f 5f				ld e, a 
8890			 
8890 21 40 00				ld hl, STORE_BLOCK_PHY 
8893 cd ac 84				call storage_findnextid 
8896			 
8896 cd 05 8d			call ishlzero 
8899 28 cc			jr z, .sa_notfound 
889b			 
889b 22 65 ea			ld (store_tmppageid), hl 
889e			 
889e				; TODO handle file id not found 
889e			 
889e				if DEBUG_STORESE 
889e					DMARK "AP2" 
889e f5				push af  
889f 3a b3 88			ld a, (.dmark)  
88a2 32 6b ee			ld (debug_mark),a  
88a5 3a b4 88			ld a, (.dmark+1)  
88a8 32 6c ee			ld (debug_mark+1),a  
88ab 3a b5 88			ld a, (.dmark+2)  
88ae 32 6d ee			ld (debug_mark+2),a  
88b1 18 03			jr .pastdmark  
88b3 ..			.dmark: db "AP2"  
88b6 f1			.pastdmark: pop af  
88b7			endm  
# End of macro DMARK
88b7					CALLMONITOR 
88b7 cd 6f ee			call debug_vector  
88ba				endm  
# End of macro CALLMONITOR
88ba				endif 
88ba			 
88ba				; update file extent count 
88ba			 
88ba 11 7a ea			ld de, store_page 
88bd			 
88bd cd 79 81			call storage_read_block 
88c0			 
88c0				if DEBUG_STORESE 
88c0					DMARK "AP3" 
88c0 f5				push af  
88c1 3a d5 88			ld a, (.dmark)  
88c4 32 6b ee			ld (debug_mark),a  
88c7 3a d6 88			ld a, (.dmark+1)  
88ca 32 6c ee			ld (debug_mark+1),a  
88cd 3a d7 88			ld a, (.dmark+2)  
88d0 32 6d ee			ld (debug_mark+2),a  
88d3 18 03			jr .pastdmark  
88d5 ..			.dmark: db "AP3"  
88d8 f1			.pastdmark: pop af  
88d9			endm  
# End of macro DMARK
88d9					CALLMONITOR 
88d9 cd 6f ee			call debug_vector  
88dc				endm  
# End of macro CALLMONITOR
88dc				endif 
88dc			;	ld (store_tmppageid), hl 
88dc			 
88dc 3a 7c ea			ld a, (store_page+2) 
88df 3c				inc a 
88e0 32 7c ea			ld (store_page+2), a 
88e3 32 6d ea			ld (store_tmpext), a 
88e6				 
88e6				if DEBUG_STORESE 
88e6					DMARK "AP3" 
88e6 f5				push af  
88e7 3a fb 88			ld a, (.dmark)  
88ea 32 6b ee			ld (debug_mark),a  
88ed 3a fc 88			ld a, (.dmark+1)  
88f0 32 6c ee			ld (debug_mark+1),a  
88f3 3a fd 88			ld a, (.dmark+2)  
88f6 32 6d ee			ld (debug_mark+2),a  
88f9 18 03			jr .pastdmark  
88fb ..			.dmark: db "AP3"  
88fe f1			.pastdmark: pop af  
88ff			endm  
# End of macro DMARK
88ff					CALLMONITOR 
88ff cd 6f ee			call debug_vector  
8902				endm  
# End of macro CALLMONITOR
8902				endif 
8902 2a 65 ea			ld hl, (store_tmppageid) 
8905 11 7a ea			ld de, store_page 
8908 cd de 81			call storage_write_block 
890b			 
890b				; find free block 
890b			 
890b 11 00 00			ld de, 0			 ; file extent to locate 
890e			 
890e 21 40 00				ld hl, STORE_BLOCK_PHY 
8911 cd ac 84				call storage_findnextid 
8914 cd 05 8d			call ishlzero 
8917 ca 67 88			jp z, .sa_notfound 
891a			 
891a					; TODO handle no space left 
891a					 
891a 22 65 ea				ld (store_tmppageid), hl 
891d			 
891d				if DEBUG_STORESE 
891d					DMARK "AP4" 
891d f5				push af  
891e 3a 32 89			ld a, (.dmark)  
8921 32 6b ee			ld (debug_mark),a  
8924 3a 33 89			ld a, (.dmark+1)  
8927 32 6c ee			ld (debug_mark+1),a  
892a 3a 34 89			ld a, (.dmark+2)  
892d 32 6d ee			ld (debug_mark+2),a  
8930 18 03			jr .pastdmark  
8932 ..			.dmark: db "AP4"  
8935 f1			.pastdmark: pop af  
8936			endm  
# End of macro DMARK
8936					CALLMONITOR 
8936 cd 6f ee			call debug_vector  
8939				endm  
# End of macro CALLMONITOR
8939				endif 
8939					; init the buffer with zeros so we can id if the buffer is full or not 
8939			 
8939 e5					push hl 
893a c5					push bc 
893b			 
893b 21 7a ea				ld hl, store_page 
893e 06 40				ld b, STORE_BLOCK_PHY 
8940 3e 00				ld a, 0 
8942 77			.zeroblock:	ld (hl), a 
8943 23					inc hl 
8944 10 fc				djnz .zeroblock 
8946			 
8946 c1					pop bc 
8947 e1					pop hl 
8948			 
8948					; construct block 
8948			 
8948 3a 6e ea				ld a, (store_tmpid) 
894b 32 7a ea				ld (store_page), a   ; file id 
894e 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
8951 32 7b ea				ld (store_page+1), a 
8954			 
8954 e1					pop hl    ; get string to write 
8955 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8957 11 7c ea				ld de, store_page+2 
895a			 
895a				if DEBUG_STORESE 
895a					DMARK "AP5" 
895a f5				push af  
895b 3a 6f 89			ld a, (.dmark)  
895e 32 6b ee			ld (debug_mark),a  
8961 3a 70 89			ld a, (.dmark+1)  
8964 32 6c ee			ld (debug_mark+1),a  
8967 3a 71 89			ld a, (.dmark+2)  
896a 32 6d ee			ld (debug_mark+2),a  
896d 18 03			jr .pastdmark  
896f ..			.dmark: db "AP5"  
8972 f1			.pastdmark: pop af  
8973			endm  
# End of macro DMARK
8973					CALLMONITOR 
8973 cd 6f ee			call debug_vector  
8976				endm  
# End of macro CALLMONITOR
8976				endif 
8976			 
8976			 
8976			 
8976					; fill buffer with data until end of string or full block 
8976			 
8976 7e			.appd:		ld a, (hl) 
8977 12					ld (de), a 
8978 fe 00				cp 0 
897a 28 04				jr z, .appdone 
897c 23					inc hl 
897d 13					inc de 
897e 10 f6				djnz .appd 
8980			 
8980 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8981 f5					push af   		; save last byte dumped 
8982			 
8982			 
8982 2a 65 ea			ld hl, (store_tmppageid) 
8985 11 7a ea			ld de, store_page 
8988				if DEBUG_STORESE 
8988					DMARK "AP6" 
8988 f5				push af  
8989 3a 9d 89			ld a, (.dmark)  
898c 32 6b ee			ld (debug_mark),a  
898f 3a 9e 89			ld a, (.dmark+1)  
8992 32 6c ee			ld (debug_mark+1),a  
8995 3a 9f 89			ld a, (.dmark+2)  
8998 32 6d ee			ld (debug_mark+2),a  
899b 18 03			jr .pastdmark  
899d ..			.dmark: db "AP6"  
89a0 f1			.pastdmark: pop af  
89a1			endm  
# End of macro DMARK
89a1					CALLMONITOR 
89a1 cd 6f ee			call debug_vector  
89a4				endm  
# End of macro CALLMONITOR
89a4				endif 
89a4 cd de 81				call storage_write_block 
89a7			 
89a7			 
89a7				; was that a full block of data written? 
89a7				; any more to write out? 
89a7			 
89a7				; if yes then set vars and jump to start of function again 
89a7			 
89a7 f1					pop af 
89a8 d1					pop de 
89a9			 
89a9 fe 00				cp 0		 ; no, string was fully written 
89ab c8					ret z 
89ac			 
89ac					; setup vars for next cycle 
89ac			 
89ac 3a 6e ea				ld a, (store_tmpid) 
89af 6f					ld l, a 
89b0 26 00				ld h, 0 
89b2			 
89b2 c3 69 88			 	jp storage_append	 ; yes, need to write out some more 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			 
89b5			if DEBUG_STORECF 
89b5			storageput:	 
89b5					ret 
89b5			storageread: 
89b5					ld hl, store_page 
89b5					ld b, 200 
89b5					ld a,0 
89b5			.src:		ld (hl),a 
89b5					inc hl 
89b5					djnz .src 
89b5					 
89b5			 
89b5					ld de, 0 
89b5					ld bc, 1 
89b5					ld hl, store_page 
89b5					call cfRead 
89b5			 
89b5				call cfGetError 
89b5				ld hl,scratch 
89b5				call hexout 
89b5				ld hl, scratch+2 
89b5				ld a, 0 
89b5				ld (hl),a 
89b5				ld de, scratch 
89b5				ld a,display_row_1 
89b5				call str_at_display 
89b5				call update_display 
89b5			 
89b5					ld hl, store_page 
89b5					ld (os_cur_ptr),hl 
89b5			 
89b5					ret 
89b5			endif 
89b5			 
89b5			 
89b5			; Clear out the main buffer store (used to remove junk before writing a new block) 
89b5			 
89b5			storage_clear_page: 
89b5 e5				push hl 
89b6 d5				push de 
89b7 c5				push bc 
89b8 21 7a ea			ld hl, store_page 
89bb 3e 00			ld a, 0 
89bd 77				ld (hl), a 
89be			 
89be 11 7b ea			ld de, store_page+1 
89c1 01 19 01			ld bc, STORE_BLOCK_LOG+1 
89c4			 
89c4 ed b0			ldir 
89c6				 
89c6 c1				pop bc 
89c7 d1				pop de 
89c8 e1				pop hl 
89c9 c9				ret 
89ca			 
89ca			; eof 
# End of file firmware_storage.asm
89ca			  
89ca			; support routines for above hardware abstraction layer  
89ca			  
89ca			include "firmware_general.asm"        ; general support functions  
89ca			 
89ca			; word look up 
89ca			 
89ca			; in 
89ca			; a is the index 
89ca			; hl is pointer start of array 
89ca			; 
89ca			; returns 
89ca			; hl to the word 
89ca			; 
89ca			 
89ca			table_lookup:  
89ca d5					push de 
89cb eb					ex de, hl 
89cc			 
89cc 6f					ld l, a 
89cd 26 00				ld h, 0 
89cf 29					add hl, hl 
89d0 19					add hl, de 
89d1 7e					ld a, (hl) 
89d2 23					inc hl 
89d3 66					ld h,(hl) 
89d4 6f					ld l, a 
89d5			 
89d5 d1					pop de 
89d6 c9					ret 
89d7			 
89d7			; Delay loops 
89d7			 
89d7			 
89d7			 
89d7			aDelayInMS: 
89d7 c5				push bc 
89d8 47				ld b,a 
89d9			msdelay: 
89d9 c5				push bc 
89da				 
89da			 
89da 01 41 00			ld bc,041h 
89dd cd f5 89			call delayloop 
89e0 c1				pop bc 
89e1 05				dec b 
89e2 20 f5			jr nz,msdelay 
89e4			 
89e4			;if CPU_CLOCK_8MHZ 
89e4			;msdelay8: 
89e4			;	push bc 
89e4			;	 
89e4			; 
89e4			;	ld bc,041h 
89e4			;	call delayloop 
89e4			;	pop bc 
89e4			;	dec b 
89e4			;	jr nz,msdelay8 
89e4			;endif 
89e4			 
89e4			 
89e4 c1				pop bc 
89e5 c9				ret 
89e6			 
89e6			 
89e6			delay250ms: 
89e6				;push de 
89e6 01 00 40			ld bc, 04000h 
89e9 c3 f5 89			jp delayloop 
89ec			delay500ms: 
89ec				;push de 
89ec 01 00 80			ld bc, 08000h 
89ef c3 f5 89			jp delayloop 
89f2			delay1s: 
89f2				;push bc 
89f2			   ; Clobbers A, d and e 
89f2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89f5			delayloop: 
89f5 c5			    push bc 
89f6			 
89f6			if BASE_CPM 
89f6				ld bc, CPM_DELAY_TUNE 
89f6			.cpmloop: 
89f6				push bc 
89f6			 
89f6			endif 
89f6			 
89f6			 
89f6			 
89f6			delayloopi: 
89f6			;	push bc 
89f6			;.dl: 
89f6 cb 47		    bit     0,a    	; 8 
89f8 cb 47		    bit     0,a    	; 8 
89fa cb 47		    bit     0,a    	; 8 
89fc e6 ff		    and     255  	; 7 
89fe 0b			    dec     bc      	; 6 
89ff 79			    ld      a,c     	; 4 
8a00 b0			    or      b     	; 4 
8a01 c2 f6 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8a04			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8a04				;pop de 
8a04			;pop bc 
8a04			 
8a04			if BASE_CPM 
8a04				pop bc 
8a04				 
8a04			    dec     bc      	; 6 
8a04			    ld      a,c     	; 4 
8a04			    or      b     	; 4 
8a04			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8a04				 
8a04			 
8a04			endif 
8a04			;if CPU_CLOCK_8MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04			 
8a04			;if CPU_CLOCK_10MHZ 
8a04			;    pop bc 
8a04			;    push bc 
8a04			;.dl8: 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    bit     0,a    	; 8 
8a04			;    and     255  	; 7 
8a04			;    dec     bc      	; 6 
8a04			;    ld      a,c     	; 4 
8a04			;    or      b     	; 4 
8a04			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8a04			;endif 
8a04 c1			    pop bc 
8a05			 
8a05 c9				ret 
8a06			 
8a06			 
8a06			 
8a06			; eof 
# End of file firmware_general.asm
8a06			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a06			; display routines that use the physical hardware abstraction layer 
8a06			 
8a06			 
8a06			; Display an activity indicator 
8a06			; Each call returns the new char pointed to in hl 
8a06			 
8a06			active: 
8a06 3a c6 eb			ld a, (display_active) 
8a09 fe 06			cp 6 
8a0b			 
8a0b 20 02			jr nz, .sne 
8a0d				; gone past the last one reset sequence 
8a0d 3e ff			ld a, 255 
8a0f			 
8a0f			.sne:   
8a0f				; get the next char in seq 
8a0f 3c				inc a 
8a10 32 c6 eb			ld (display_active), a 
8a13			 
8a13				; look up the string in the table 
8a13 21 2a 8a			ld hl, actseq 
8a16 cb 27			sla a 
8a18 cd dc 8c			call addatohl 
8a1b cd 69 9e			call loadwordinhl 
8a1e			 
8a1e				; forth will write the to string when pushing so move from rom to ram 
8a1e			 
8a1e 11 c7 eb			ld de, display_active+1 
8a21 01 02 00			ld bc, 2 
8a24 ed b0			ldir 
8a26			 
8a26 21 c7 eb			ld hl, display_active+1 
8a29 c9				ret 
8a2a				 
8a2a				 
8a2a			 
8a2a			 
8a2a			;db "|/-\|-\" 
8a2a			 
8a2a			actseq: 
8a2a			 
8a2a 38 8a		dw spin0 
8a2c 3a 8a		dw spin1 
8a2e 3c 8a		dw spin2 
8a30 3e 8a		dw spin3 
8a32 3c 8a		dw spin2 
8a34 3a 8a		dw spin1 
8a36 38 8a		dw spin0 
8a38			 
8a38 .. 00		spin0: db " ", 0 
8a3a .. 00		spin1: db "-", 0 
8a3c .. 00		spin2: db "+", 0 
8a3e .. 00		spin3: db "#", 0 
8a40			 
8a40			 
8a40			; information window 
8a40			 
8a40			; pass hl with 1st string to display 
8a40			; pass de with 2nd string to display 
8a40			 
8a40			info_panel: 
8a40 e5				push hl 
8a41			 
8a41 2a cc eb			ld hl, (display_fb_active) 
8a44 e5				push hl    ; future de destination 
8a45 21 b1 ed				ld hl, display_fb0 
8a48 22 cc eb				ld (display_fb_active), hl 
8a4b			 
8a4b			;	call clear_display 
8a4b			 
8a4b				if BASE_CPM 
8a4b				ld a, '.' 
8a4b				else 
8a4b 3e a5			ld a, 165 
8a4d				endif 
8a4d cd b4 8a			call fill_display 
8a50			 
8a50			 
8a50 3e 55			ld a, display_row_3 + 5 
8a52 cd c2 8a			call str_at_display 
8a55			 
8a55 e1				pop hl 
8a56 d1				pop de 
8a57			 
8a57 e5				push hl 
8a58			 
8a58			 
8a58 3e 2d			ld a, display_row_2 + 5 
8a5a cd c2 8a			call str_at_display 
8a5d			 
8a5d			 
8a5d cd d2 8a			call update_display 
8a60 cd b2 9a			call next_page_prompt 
8a63 cd af 8a			call clear_display 
8a66			 
8a66				 
8a66 21 10 ed				ld hl, display_fb1 
8a69 22 cc eb				ld (display_fb_active), hl 
8a6c cd d2 8a			call update_display 
8a6f			 
8a6f e1				pop hl 
8a70			 
8a70 c9				ret 
8a71			 
8a71			 
8a71			 
8a71			 
8a71			; TODO windowing? 
8a71			 
8a71			; TODO scroll line up 
8a71			 
8a71			scroll_up: 
8a71			 
8a71 e5				push hl 
8a72 d5				push de 
8a73 c5				push bc 
8a74			 
8a74				; get frame buffer  
8a74			 
8a74 2a cc eb			ld hl, (display_fb_active) 
8a77 e5				push hl    ; future de destination 
8a78			 
8a78 11 28 00			ld  de, display_cols 
8a7b 19				add hl, de 
8a7c			 
8a7c d1				pop de 
8a7d			 
8a7d				;ex de, hl 
8a7d 01 9f 00			ld bc, display_fb_len -1  
8a80			;if DEBUG_FORTH_WORDS 
8a80			;	DMARK "SCL" 
8a80			;	CALLMONITOR 
8a80			;endif	 
8a80 ed b0			ldir 
8a82			 
8a82				; wipe bottom row 
8a82			 
8a82			 
8a82 2a cc eb			ld hl, (display_fb_active) 
8a85 11 a0 00			ld de, display_cols*display_rows 
8a88 19				add hl, de 
8a89 06 28			ld b, display_cols 
8a8b 3e 20			ld a, ' ' 
8a8d			.scwipe: 
8a8d 77				ld (hl), a 
8a8e 2b				dec hl 
8a8f 10 fc			djnz .scwipe 
8a91			 
8a91				;pop hl 
8a91			 
8a91 c1				pop bc 
8a92 d1				pop de 
8a93 e1				pop hl 
8a94			 
8a94 c9				ret 
8a95			 
8a95			 
8a95			;scroll_upo: 
8a95			;	ld de, display_row_1 
8a95			 ;	ld hl, display_row_2 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			;	ld de, display_row_2 
8a95			 ;	ld hl, display_row_3 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			;	ld de, display_row_3 
8a95			 ;	ld hl, display_row_4 
8a95			;	ld bc, display_cols 
8a95			;	ldir 
8a95			 
8a95			; TODO clear row 4 
8a95			 
8a95			;	ret 
8a95			 
8a95				 
8a95			scroll_down: 
8a95			 
8a95 e5				push hl 
8a96 d5				push de 
8a97 c5				push bc 
8a98			 
8a98				; get frame buffer  
8a98			 
8a98 2a cc eb			ld hl, (display_fb_active) 
8a9b			 
8a9b 11 9f 00			ld de, display_fb_len - 1 
8a9e 19				add hl, de 
8a9f			 
8a9f e5			push hl    ; future de destination 
8aa0			 
8aa0 11 28 00			ld  de, display_cols 
8aa3 ed 52			sbc hl, de 
8aa5			 
8aa5			 
8aa5 d1				pop de 
8aa6			 
8aa6			;	ex de, hl 
8aa6 01 9f 00			ld bc, display_fb_len -1  
8aa9			 
8aa9			 
8aa9				 
8aa9			 
8aa9 ed b0			ldir 
8aab			 
8aab				; wipe bottom row 
8aab			 
8aab			 
8aab			;	ld hl, (display_fb_active) 
8aab			;;	ld de, display_cols*display_rows 
8aab			;;	add hl, de 
8aab			;	ld b, display_cols 
8aab			;	ld a, ' ' 
8aab			;.scwiped: 
8aab			;	ld (hl), a 
8aab			;	dec hl 
8aab			;	djnz .scwiped 
8aab			 
8aab				;pop hl 
8aab			 
8aab c1				pop bc 
8aac d1				pop de 
8aad e1				pop hl 
8aae			 
8aae c9				ret 
8aaf			;scroll_down: 
8aaf			;	ld de, display_row_4 
8aaf			;	ld hl, display_row_3 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;	ld de, display_row_3 
8aaf			; 	ld hl, display_row_2 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;	ld de, display_row_2 
8aaf			;	ld hl, display_row_1 
8aaf			;	ld bc, display_cols 
8aaf			;	ldir 
8aaf			;;; TODO clear row 1 
8aaf			;	ret 
8aaf			 
8aaf			 
8aaf			 
8aaf			 
8aaf			 
8aaf			; clear active frame buffer 
8aaf			 
8aaf			clear_display: 
8aaf 3e 20			ld a, ' ' 
8ab1 c3 b4 8a			jp fill_display 
8ab4			 
8ab4			; fill active frame buffer with a char in A 
8ab4			 
8ab4			fill_display: 
8ab4 06 a0			ld b,display_fb_len 
8ab6 2a cc eb			ld hl, (display_fb_active) 
8ab9 77			.fd1:	ld (hl),a 
8aba 23				inc hl 
8abb 10 fc			djnz .fd1 
8abd 23				inc hl 
8abe 3e 00			ld a,0 
8ac0 77				ld (hl),a 
8ac1			 
8ac1			 
8ac1 c9				ret 
8ac2			; Write string (DE) at pos (A) to active frame buffer 
8ac2			 
8ac2 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
8ac5 06 00					ld b,0 
8ac7 4f					ld c,a 
8ac8 09					add hl,bc 
8ac9 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8aca b7			            OR   A              ;Null terminator? 
8acb c8			            RET  Z              ;Yes, so finished 
8acc 77					ld (hl),a 
8acd 23				inc hl 
8ace 13			            INC  DE             ;Point to next character 
8acf 18 f8		            JR   .sad1     ;Repeat 
8ad1 c9					ret 
8ad2			 
8ad2			; using current frame buffer write to physical display 
8ad2			 
8ad2			update_display: 
8ad2 e5				push hl 
8ad3 2a cc eb			ld hl, (display_fb_active) 
8ad6 cd 8b e3			call write_display 
8ad9 e1				pop hl 
8ada c9				ret 
8adb			 
8adb			; TODO scrolling 
8adb			 
8adb			 
8adb			; move cursor right one char 
8adb			cursor_right: 
8adb			 
8adb				; TODO shift right 
8adb				; TODO if beyond max col 
8adb				; TODO       cursor_next_line 
8adb			 
8adb c9				ret 
8adc			 
8adc			 
8adc			cursor_next_line: 
8adc				; TODO first char 
8adc				; TODO line down 
8adc				; TODO if past last row 
8adc				; TODO    scroll up 
8adc			 
8adc c9				ret 
8add			 
8add			cursor_left: 
8add				; TODO shift left 
8add				; TODO if beyond left  
8add				; TODO     cursor prev line 
8add				 
8add c9				ret 
8ade			 
8ade			cursor_prev_line: 
8ade				; TODO last char 
8ade				; TODO line up 
8ade				; TODO if past first row 
8ade				; TODO   scroll down 
8ade			 
8ade c9				ret 
8adf			 
8adf			 
8adf			cout: 
8adf				; A - char 
8adf c9				ret 
8ae0			 
8ae0			 
8ae0			; Display a menu and allow item selection (optional toggle items) 
8ae0			; 
8ae0			; format: 
8ae0			; hl pointer to word array with zero term for items 
8ae0			; e.g.    db item1 
8ae0			;         db .... 
8ae0			;         db 0 
8ae0			; 
8ae0			; a = starting menu item  
8ae0			; 
8ae0			; de = pointer item toggle array   (todo) 
8ae0			; 
8ae0			; returns item selected in a 1-... 
8ae0			; returns 0 if back button pressed 
8ae0			; 
8ae0			; NOTE: Uses system frame buffer to display 
8ae0			; 
8ae0			; LEFT, Q = go back 
8ae0			; RIGHT, SPACE, CR = select 
8ae0			; UP, A - Up 
8ae0			; DOWN, Z - Down 
8ae0			 
8ae0			 
8ae0			 
8ae0			 
8ae0			 
8ae0			menu: 
8ae0			 
8ae0					; keep array pointer 
8ae0			 
8ae0 22 73 ea				ld (store_tmp1), hl 
8ae3 32 71 ea				ld (store_tmp2), a 
8ae6			 
8ae6					; check for key bounce 
8ae6			 
8ae6			if BASE_KEV 
8ae6			 
8ae6			.mbounce:	call cin 
8ae6					cp 0 
8ae6					jr nz, .mbounce 
8ae6			endif 
8ae6					; for ease use ex 
8ae6			 
8ae6					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8ae6 21 b1 ed				ld hl, display_fb0 
8ae9 22 cc eb				ld (display_fb_active), hl 
8aec			 
8aec cd af 8a		.mloop:		call clear_display 
8aef cd d2 8a				call update_display 
8af2			 
8af2					; draw selection id '>' at 1 
8af2			 
8af2					; init start of list display 
8af2			 
8af2 3e 05				ld a, 5 
8af4 32 6f ea				ld (store_tmp3), a   ; display row count 
8af7 3a 71 ea				ld a,( store_tmp2) 
8afa 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8afd			 
8afd					 
8afd			.mitem:	 
8afd			 
8afd			 
8afd 3a 72 ea				ld a,(store_tmp2+1) 
8b00 6f					ld l, a 
8b01 26 00				ld h, 0 
8b03 29					add hl, hl 
8b04 ed 5b 73 ea			ld de, (store_tmp1) 
8b08 19					add hl, de 
8b09 7e					ld a, (hl) 
8b0a 23					inc hl 
8b0b 66					ld h,(hl) 
8b0c 6f					ld l, a 
8b0d			 
8b0d cd 05 8d				call ishlzero 
8b10 28 1a				jr z, .mdone 
8b12			 
8b12 eb					ex de, hl 
8b13 3a 6f ea				ld a, (store_tmp3) 
8b16 cd c2 8a				call str_at_display 
8b19					 
8b19			 
8b19					; next item 
8b19 3a 72 ea				ld a, (store_tmp2+1) 
8b1c 3c					inc a 
8b1d 32 72 ea				ld (store_tmp2+1), a   ; display item count 
8b20			 
8b20			 		; next row 
8b20			 
8b20 3a 6f ea				ld a, (store_tmp3) 
8b23 c6 28				add display_cols 
8b25 32 6f ea				ld (store_tmp3), a 
8b28			 
8b28					; at end of screen? 
8b28			 
8b28 fe 10				cp display_rows*4 
8b2a 20 d1				jr nz, .mitem 
8b2c			 
8b2c			 
8b2c			.mdone: 
8b2c cd 05 8d				call ishlzero 
8b2f 28 08				jr z, .nodn 
8b31			 
8b31 3e 78				ld a, display_row_4 
8b33 11 b2 8b				ld de, .mdown 
8b36 cd c2 8a				call str_at_display 
8b39			 
8b39					; draw options to fill the screens with active item on line 1 
8b39					; if current option is 2 or more then display ^ in top 
8b39			 
8b39 3a 71 ea		.nodn:		ld a, (store_tmp2) 
8b3c fe 00				cp 0 
8b3e 28 08				jr z, .noup 
8b40			 
8b40 3e 00				ld a, 0 
8b42 11 b0 8b				ld de, .mup 
8b45 cd c2 8a				call str_at_display 
8b48			 
8b48 3e 02		.noup:		ld a, 2 
8b4a 11 ae 8b				ld de, .msel 
8b4d cd c2 8a				call str_at_display 
8b50			 
8b50					; if current option + 1 is not null then display V in bottom 
8b50					; get key 
8b50 cd d2 8a				call update_display 
8b53			 
8b53			 
8b53					; handle key 
8b53			 
8b53 cd 17 e4				call cin_wait 
8b56			 
8b56 fe 05				cp KEY_UP 
8b58 28 2b				jr z, .mgoup 
8b5a fe 61				cp 'a' 
8b5c 28 27				jr z, .mgoup 
8b5e fe 0a				cp KEY_DOWN 
8b60 28 32				jr z, .mgod 
8b62 fe 7a				cp 'z' 
8b64 28 2e				jr z, .mgod 
8b66 fe 20				cp ' ' 
8b68 28 34				jr z, .goend 
8b6a fe 0c				cp KEY_RIGHT 
8b6c 28 30				jr z, .goend 
8b6e fe 0d				cp KEY_CR 
8b70 28 2c				jr z, .goend 
8b72 fe 71				cp 'q' 
8b74 28 0b				jr z, .goback 
8b76			 
8b76 fe 0b				cp KEY_LEFT 
8b78 28 07				jr z, .goback 
8b7a fe 08				cp KEY_BS 
8b7c 28 03				jr z, .goback 
8b7e c3 ec 8a				jp .mloop 
8b81			 
8b81			.goback: 
8b81 3e 00			ld a, 0 
8b83 18 1d			jr .goend2 
8b85			 
8b85				; move up one 
8b85			.mgoup: 
8b85 3a 71 ea				ld a, (store_tmp2) 
8b88 fe 00				cp 0 
8b8a ca ec 8a				jp z, .mloop 
8b8d 3d					dec a 
8b8e 32 71 ea				ld (store_tmp2), a 
8b91 c3 ec 8a				jp .mloop 
8b94			 
8b94				; move down one 
8b94			.mgod: 
8b94 3a 71 ea				ld a, (store_tmp2) 
8b97 3c					inc a 
8b98 32 71 ea				ld (store_tmp2), a 
8b9b c3 ec 8a				jp .mloop 
8b9e			 
8b9e			 
8b9e			.goend: 
8b9e					; get selected item number 
8b9e			 
8b9e 3a 71 ea				ld a, (store_tmp2) 
8ba1 3c					inc a 
8ba2			 
8ba2			.goend2: 
8ba2 f5					push af 
8ba3			 
8ba3					; restore active fb 
8ba3					; TODO BUG assumes fb1 
8ba3			 
8ba3 21 10 ed				ld hl, display_fb1 
8ba6 22 cc eb				ld (display_fb_active), hl 
8ba9			 
8ba9					; restore main regs 
8ba9			 
8ba9			 
8ba9 cd d2 8a				call update_display 
8bac			 
8bac f1					pop af 
8bad			 
8bad c9				ret 
8bae			 
8bae .. 00		.msel:   db ">",0 
8bb0 .. 00		.mup:   db "^",0 
8bb2 .. 00		.mdown:   db "v",0 
8bb4			 
8bb4			 
8bb4			; eof 
8bb4			 
# End of file firmware_display.asm
8bb4			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8bb4			; random number generators 
8bb4			 
8bb4			 
8bb4			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8bb4			 
8bb4			 
8bb4			;-----> Generate a random number 
8bb4			; output a=answer 0<=a<=255 
8bb4			; all registers are preserved except: af 
8bb4			random: 
8bb4 e5			        push    hl 
8bb5 d5			        push    de 
8bb6 2a ab eb		        ld      hl,(randData) 
8bb9 ed 5f		        ld      a,r 
8bbb 57			        ld      d,a 
8bbc 5e			        ld      e,(hl) 
8bbd 19			        add     hl,de 
8bbe 85			        add     a,l 
8bbf ac			        xor     h 
8bc0 22 ab eb		        ld      (randData),hl 
8bc3 d1			        pop     de 
8bc4 e1			        pop     hl 
8bc5 c9			        ret 
8bc6			 
8bc6			 
8bc6			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8bc6			 
8bc6			 
8bc6			 
8bc6			;------LFSR------ 
8bc6			;James Montelongo 
8bc6			;optimized by Spencer Putt 
8bc6			;out: 
8bc6			; a = 8 bit random number 
8bc6			RandLFSR: 
8bc6 21 b1 eb		        ld hl,LFSRSeed+4 
8bc9 5e			        ld e,(hl) 
8bca 23			        inc hl 
8bcb 56			        ld d,(hl) 
8bcc 23			        inc hl 
8bcd 4e			        ld c,(hl) 
8bce 23			        inc hl 
8bcf 7e			        ld a,(hl) 
8bd0 47			        ld b,a 
8bd1 cb 13		        rl e  
8bd3 cb 12			rl d 
8bd5 cb 11		        rl c  
8bd7 17				rla 
8bd8 cb 13		        rl e  
8bda cb 12			rl d 
8bdc cb 11		        rl c  
8bde 17				rla 
8bdf cb 13		        rl e  
8be1 cb 12			rl d 
8be3 cb 11		        rl c  
8be5 17				rla 
8be6 67			        ld h,a 
8be7 cb 13		        rl e  
8be9 cb 12			rl d 
8beb cb 11		        rl c  
8bed 17				rla 
8bee a8			        xor b 
8bef cb 13		        rl e  
8bf1 cb 12			rl d 
8bf3 ac			        xor h 
8bf4 a9			        xor c 
8bf5 aa			        xor d 
8bf6 21 b3 eb		        ld hl,LFSRSeed+6 
8bf9 11 b4 eb		        ld de,LFSRSeed+7 
8bfc 01 07 00		        ld bc,7 
8bff ed b8		        lddr 
8c01 12			        ld (de),a 
8c02 c9			        ret 
8c03			 
8c03			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8c03			 
8c03			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8c03			 
8c03			 
8c03			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8c03			 
8c03			prng16: 
8c03			;Inputs: 
8c03			;   (seed1) contains a 16-bit seed value 
8c03			;   (seed2) contains a NON-ZERO 16-bit seed value 
8c03			;Outputs: 
8c03			;   HL is the result 
8c03			;   BC is the result of the LCG, so not that great of quality 
8c03			;   DE is preserved 
8c03			;Destroys: 
8c03			;   AF 
8c03			;cycle: 4,294,901,760 (almost 4.3 billion) 
8c03			;160cc 
8c03			;26 bytes 
8c03 2a a5 eb		    ld hl,(seed1) 
8c06 44			    ld b,h 
8c07 4d			    ld c,l 
8c08 29			    add hl,hl 
8c09 29			    add hl,hl 
8c0a 2c			    inc l 
8c0b 09			    add hl,bc 
8c0c 22 a5 eb		    ld (seed1),hl 
8c0f 2a a3 eb		    ld hl,(seed2) 
8c12 29			    add hl,hl 
8c13 9f			    sbc a,a 
8c14 e6 2d		    and %00101101 
8c16 ad			    xor l 
8c17 6f			    ld l,a 
8c18 22 a3 eb		    ld (seed2),hl 
8c1b 09			    add hl,bc 
8c1c c9			    ret 
8c1d			 
8c1d			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8c1d			 
8c1d			rand32: 
8c1d			;Inputs: 
8c1d			;   (seed1_0) holds the lower 16 bits of the first seed 
8c1d			;   (seed1_1) holds the upper 16 bits of the first seed 
8c1d			;   (seed2_0) holds the lower 16 bits of the second seed 
8c1d			;   (seed2_1) holds the upper 16 bits of the second seed 
8c1d			;   **NOTE: seed2 must be non-zero 
8c1d			;Outputs: 
8c1d			;   HL is the result 
8c1d			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8c1d			;Destroys: 
8c1d			;   AF 
8c1d			;Tested and passes all CAcert tests 
8c1d			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8c1d			;it has a period of 18,446,744,069,414,584,320 
8c1d			;roughly 18.4 quintillion. 
8c1d			;LFSR taps: 0,2,6,7  = 11000101 
8c1d			;291cc 
8c1d			;seed1_0=$+1 
8c1d			;    ld hl,12345 
8c1d			;seed1_1=$+1 
8c1d			;    ld de,6789 
8c1d			;    ld b,h 
8c1d			;    ld c,l 
8c1d			;    add hl,hl \ rl e \ rl d 
8c1d			;    add hl,hl \ rl e \ rl d 
8c1d			;    inc l 
8c1d			;    add hl,bc 
8c1d			;    ld (seed1_0),hl 
8c1d			;    ld hl,(seed1_1) 
8c1d			;    adc hl,de 
8c1d			;    ld (seed1_1),hl 
8c1d			;    ex de,hl 
8c1d			;seed2_0=$+1 
8c1d			;    ld hl,9876 
8c1d			;seed2_1=$+1 
8c1d			;    ld bc,54321 
8c1d			;    add hl,hl \ rl c \ rl b 
8c1d			;    ld (seed2_1),bc 
8c1d			;    sbc a,a 
8c1d			;    and %11000101 
8c1d			;    xor l 
8c1d			;    ld l,a 
8c1d			;    ld (seed2_0),hl 
8c1d			;    ex de,hl 
8c1d			;    add hl,bc 
8c1d			;    ret 
8c1d			; 
8c1d			 
8c1d			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8c1d			; 20 bytes, 86 cycles (excluding ret) 
8c1d			 
8c1d			; returns   hl = pseudorandom number 
8c1d			; corrupts   a 
8c1d			 
8c1d			; generates 16-bit pseudorandom numbers with a period of 65535 
8c1d			; using the xorshift method: 
8c1d			 
8c1d			; hl ^= hl << 7 
8c1d			; hl ^= hl >> 9 
8c1d			; hl ^= hl << 8 
8c1d			 
8c1d			; some alternative shift triplets which also perform well are: 
8c1d			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8c1d			 
8c1d			;  org 32768 
8c1d			 
8c1d			xrnd: 
8c1d 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
8c20 3e 00		  ld a,0 
8c22 bd			  cp l 
8c23 20 02		  jr nz, .xrnd1 
8c25 2e 01		  ld l, 1 
8c27			.xrnd1: 
8c27			 
8c27 7c			  ld a,h 
8c28 1f			  rra 
8c29 7d			  ld a,l 
8c2a 1f			  rra 
8c2b ac			  xor h 
8c2c 67			  ld h,a 
8c2d 7d			  ld a,l 
8c2e 1f			  rra 
8c2f 7c			  ld a,h 
8c30 1f			  rra 
8c31 ad			  xor l 
8c32 6f			  ld l,a 
8c33 ac			  xor h 
8c34 67			  ld h,a 
8c35			 
8c35 22 a9 eb		  ld (xrandc),hl 
8c38			 
8c38 c9			  ret 
8c39			;  
8c39			 
8c39			 
8c39			;;;; int maths 
8c39			 
8c39			; https://map.grauw.nl/articles/mult_div_shifts.php 
8c39			; Divide 16-bit values (with 16-bit result) 
8c39			; In: Divide BC by divider DE 
8c39			; Out: BC = result, HL = rest 
8c39			; 
8c39			Div16: 
8c39 21 00 00		    ld hl,0 
8c3c 78			    ld a,b 
8c3d 06 08		    ld b,8 
8c3f			Div16_Loop1: 
8c3f 17			    rla 
8c40 ed 6a		    adc hl,hl 
8c42 ed 52		    sbc hl,de 
8c44 30 01		    jr nc,Div16_NoAdd1 
8c46 19			    add hl,de 
8c47			Div16_NoAdd1: 
8c47 10 f6		    djnz Div16_Loop1 
8c49 17			    rla 
8c4a 2f			    cpl 
8c4b 47			    ld b,a 
8c4c 79			    ld a,c 
8c4d 48			    ld c,b 
8c4e 06 08		    ld b,8 
8c50			Div16_Loop2: 
8c50 17			    rla 
8c51 ed 6a		    adc hl,hl 
8c53 ed 52		    sbc hl,de 
8c55 30 01		    jr nc,Div16_NoAdd2 
8c57 19			    add hl,de 
8c58			Div16_NoAdd2: 
8c58 10 f6		    djnz Div16_Loop2 
8c5a 17			    rla 
8c5b 2f			    cpl 
8c5c 41			    ld b,c 
8c5d 4f			    ld c,a 
8c5e c9			ret 
8c5f			 
8c5f			 
8c5f			;http://z80-heaven.wikidot.com/math 
8c5f			; 
8c5f			;Inputs: 
8c5f			;     DE and A are factors 
8c5f			;Outputs: 
8c5f			;     A is not changed 
8c5f			;     B is 0 
8c5f			;     C is not changed 
8c5f			;     DE is not changed 
8c5f			;     HL is the product 
8c5f			;Time: 
8c5f			;     342+6x 
8c5f			; 
8c5f			Mult16: 
8c5f			 
8c5f 06 08		     ld b,8          ;7           7 
8c61 21 00 00		     ld hl,0         ;10         10 
8c64 29			       add hl,hl     ;11*8       88 
8c65 07			       rlca          ;4*8        32 
8c66 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c68 19			         add hl,de   ;--         -- 
8c69 10 f9		       djnz $-5      ;13*7+8     99 
8c6b c9			ret 
8c6c			 
8c6c			; 
8c6c			; Square root of 16-bit value 
8c6c			; In:  HL = value 
8c6c			; Out:  D = result (rounded down) 
8c6c			; 
8c6c			;Sqr16: 
8c6c			;    ld de,#0040 
8c6c			;    ld a,l 
8c6c			;    ld l,h 
8c6c			;    ld h,d 
8c6c			;    or a 
8c6c			;    ld b,8 
8c6c			;Sqr16_Loop: 
8c6c			;    sbc hl,de 
8c6c			;    jr nc,Sqr16_Skip 
8c6c			;    add hl,de 
8c6c			;Sqr16_Skip: 
8c6c			;    ccf 
8c6c			;    rl d 
8c6c			;    add a,a 
8c6c			;    adc hl,hl 
8c6c			;    add a,a 
8c6c			;    adc hl,hl 
8c6c			;    djnz Sqr16_Loop 
8c6c			;    ret 
8c6c			; 
8c6c			; 
8c6c			; Divide 8-bit values 
8c6c			; In: Divide E by divider C 
8c6c			; Out: A = result, B = rest 
8c6c			; 
8c6c			Div8: 
8c6c af			    xor a 
8c6d 06 08		    ld b,8 
8c6f			Div8_Loop: 
8c6f cb 13		    rl e 
8c71 17			    rla 
8c72 91			    sub c 
8c73 30 01		    jr nc,Div8_NoAdd 
8c75 81			    add a,c 
8c76			Div8_NoAdd: 
8c76 10 f7		    djnz Div8_Loop 
8c78 47			    ld b,a 
8c79 7b			    ld a,e 
8c7a 17			    rla 
8c7b 2f			    cpl 
8c7c c9			    ret 
8c7d			 
8c7d			; 
8c7d			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c7d			; In: Multiply A with DE 
8c7d			; Out: HL = result 
8c7d			; 
8c7d			Mult12U: 
8c7d 2e 00		    ld l,0 
8c7f 87			    add a,a 
8c80 30 01		    jr nc,Mult12U_NoAdd0 
8c82 19			    add hl,de 
8c83			Mult12U_NoAdd0: 
8c83 29			    add hl,hl 
8c84 87			    add a,a 
8c85 30 01		    jr nc,Mult12U_NoAdd1 
8c87 19			    add hl,de 
8c88			Mult12U_NoAdd1: 
8c88 29			    add hl,hl 
8c89 87			    add a,a 
8c8a 30 01		    jr nc,Mult12U_NoAdd2 
8c8c 19			    add hl,de 
8c8d			Mult12U_NoAdd2: 
8c8d 29			    add hl,hl 
8c8e 87			    add a,a 
8c8f 30 01		    jr nc,Mult12U_NoAdd3 
8c91 19			    add hl,de 
8c92			Mult12U_NoAdd3: 
8c92 29			    add hl,hl 
8c93 87			    add a,a 
8c94 30 01		    jr nc,Mult12U_NoAdd4 
8c96 19			    add hl,de 
8c97			Mult12U_NoAdd4: 
8c97 29			    add hl,hl 
8c98 87			    add a,a 
8c99 30 01		    jr nc,Mult12U_NoAdd5 
8c9b 19			    add hl,de 
8c9c			Mult12U_NoAdd5: 
8c9c 29			    add hl,hl 
8c9d 87			    add a,a 
8c9e 30 01		    jr nc,Mult12U_NoAdd6 
8ca0 19			    add hl,de 
8ca1			Mult12U_NoAdd6: 
8ca1 29			    add hl,hl 
8ca2 87			    add a,a 
8ca3 d0			    ret nc 
8ca4 19			    add hl,de 
8ca5 c9			    ret 
8ca6			 
8ca6			; 
8ca6			; Multiply 8-bit value with a 16-bit value (right rotating) 
8ca6			; In: Multiply A with DE 
8ca6			;      Put lowest value in A for most efficient calculation 
8ca6			; Out: HL = result 
8ca6			; 
8ca6			Mult12R: 
8ca6 21 00 00		    ld hl,0 
8ca9			Mult12R_Loop: 
8ca9 cb 3f		    srl a 
8cab 30 01		    jr nc,Mult12R_NoAdd 
8cad 19			    add hl,de 
8cae			Mult12R_NoAdd: 
8cae cb 23		    sla e 
8cb0 cb 12		    rl d 
8cb2 b7			    or a 
8cb3 c2 a9 8c		    jp nz,Mult12R_Loop 
8cb6 c9			    ret 
8cb7			 
8cb7			; 
8cb7			; Multiply 16-bit values (with 32-bit result) 
8cb7			; In: Multiply BC with DE 
8cb7			; Out: BCHL = result 
8cb7			; 
8cb7			Mult32: 
8cb7 79			    ld a,c 
8cb8 48			    ld c,b 
8cb9 21 00 00		    ld hl,0 
8cbc 06 10		    ld b,16 
8cbe			Mult32_Loop: 
8cbe 29			    add hl,hl 
8cbf 17			    rla 
8cc0 cb 11		    rl c 
8cc2 30 07		    jr nc,Mult32_NoAdd 
8cc4 19			    add hl,de 
8cc5 ce 00		    adc a,0 
8cc7 d2 cb 8c		    jp nc,Mult32_NoAdd 
8cca 0c			    inc c 
8ccb			Mult32_NoAdd: 
8ccb 10 f1		    djnz Mult32_Loop 
8ccd 41			    ld b,c 
8cce 4f			    ld c,a 
8ccf c9			    ret 
8cd0			 
8cd0			 
8cd0			 
8cd0			; 
8cd0			; Multiply 8-bit values 
8cd0			; In:  Multiply H with E 
8cd0			; Out: HL = result 
8cd0			; 
8cd0			Mult8: 
8cd0 16 00		    ld d,0 
8cd2 6a			    ld l,d 
8cd3 06 08		    ld b,8 
8cd5			Mult8_Loop: 
8cd5 29			    add hl,hl 
8cd6 30 01		    jr nc,Mult8_NoAdd 
8cd8 19			    add hl,de 
8cd9			Mult8_NoAdd: 
8cd9 10 fa		    djnz Mult8_Loop 
8cdb c9			    ret 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			 
8cdc			;;http://z80-heaven.wikidot.com/math 
8cdc			;;This divides DE by BC, storing the result in DE, remainder in HL 
8cdc			; 
8cdc			;DE_Div_BC:          ;1281-2x, x is at most 16 
8cdc			;     ld a,16        ;7 
8cdc			;     ld hl,0        ;10 
8cdc			;     jp $+5         ;10 
8cdc			;.DivLoop: 
8cdc			;       add hl,bc    ;-- 
8cdc			;       dec a        ;64 
8cdc			;       jr z,.DivLoopEnd        ;86 
8cdc			; 
8cdc			;       sla e        ;128 
8cdc			;       rl d         ;128 
8cdc			;       adc hl,hl    ;240 
8cdc			;       sbc hl,bc    ;240 
8cdc			;       jr nc,.DivLoop ;23|21 
8cdc			;       inc e        ;-- 
8cdc			;       jp .DivLoop+1 
8cdc			; 
8cdc			;.DivLoopEnd: 
8cdc			 
8cdc			;HL_Div_C: 
8cdc			;Inputs: 
8cdc			;     HL is the numerator 
8cdc			;     C is the denominator 
8cdc			;Outputs: 
8cdc			;     A is the remainder 
8cdc			;     B is 0 
8cdc			;     C is not changed 
8cdc			;     DE is not changed 
8cdc			;     HL is the quotient 
8cdc			; 
8cdc			;       ld b,16 
8cdc			;       xor a 
8cdc			;         add hl,hl 
8cdc			;         rla 
8cdc			;         cp c 
8cdc			;         jr c,$+4 
8cdc			;           inc l 
8cdc			;           sub c 
8cdc			;         djnz $-7 
8cdc			 
8cdc			; https://plutiedev.com/z80-add-8bit-to-16bit 
8cdc			 
8cdc			addatohl: 
8cdc 85			    add   a, l    ; A = A+L 
8cdd 6f			    ld    l, a    ; L = A+L 
8cde 8c			    adc   a, h    ; A = A+L+H+carry 
8cdf 95			    sub   l       ; A = H+carry 
8ce0 67			    ld    h, a    ; H = H+carry 
8ce1 c9			ret 
8ce2			 
8ce2			addatode: 
8ce2 83			    add   a, e    ; A = A+L 
8ce3 5f			    ld    e, a    ; L = A+L 
8ce4 8a			    adc   a, d    ; A = A+L+H+carry 
8ce5 93			    sub   e       ; A = H+carry 
8ce6 57			    ld    d, a    ; H = H+carry 
8ce7 c9			ret 
8ce8			 
8ce8			 
8ce8			addatobc: 
8ce8 81			    add   a, c    ; A = A+L 
8ce9 4f			    ld    c, a    ; L = A+L 
8cea 88			    adc   a, b    ; A = A+L+H+carry 
8ceb 91			    sub   c       ; A = H+carry 
8cec 47			    ld    b, a    ; H = H+carry 
8ced c9			ret 
8cee			 
8cee			subafromhl: 
8cee			   ; If A=0 do nothing 
8cee			    ; Otherwise flip A's sign. Since 
8cee			    ; the upper byte becomes -1, also 
8cee			    ; substract 1 from H. 
8cee ed 44		    neg 
8cf0 ca f9 8c		    jp    z, Skip 
8cf3 25			    dec   h 
8cf4			     
8cf4			    ; Now add the low byte as usual 
8cf4			    ; Two's complement takes care of 
8cf4			    ; ensuring the result is correct 
8cf4 85			    add   a, l 
8cf5 6f			    ld    l, a 
8cf6 8c			    adc   a, h 
8cf7 95			    sub   l 
8cf8 67			    ld    h, a 
8cf9			Skip: 
8cf9 c9				ret 
8cfa			 
8cfa			 
8cfa			; compare hl and de 
8cfa			; returns:  
8cfa			; if hl = de, z=1, s=0, c0=0 
8cfa			; if hl > de, z=0, s=0, c=0 
8cfa			; if hl < de, z=0, s=1, c=1 
8cfa			cmp16:	 
8cfa b7				or a 
8cfb ed 52			sbc hl,de 
8cfd e0				ret po 
8cfe 7c				ld a,h 
8cff 1f				rra 
8d00 ee 40			xor 01000000B 
8d02 37				scf 
8d03 8f				adc a,a 
8d04 c9				ret 
8d05			 
8d05			 
8d05			; test if hl contains zero   - A is destroyed 
8d05			 
8d05			ishlzero:    
8d05 b7				or a     ; reset flags 
8d06 7c				ld a, h 
8d07 b5				or l        	 
8d08			 
8d08 c9				ret 
8d09			 
8d09			 
8d09			 
8d09			 
8d09			if FORTH_ENABLE_FLOATMATH 
8d09			;include "float/bbcmath.z80" 
8d09			include "float/lpfpcalc.asm" 
8d09			endif 
8d09			 
8d09			 
8d09			; eof 
8d09			 
# End of file firmware_maths.asm
8d09			include "firmware_strings.asm"   ; string handling  
8d09			 
8d09			 
8d09			; TODO string len 
8d09			; input text string, end on cr with zero term 
8d09			; a offset into frame buffer to start prompt 
8d09			; d is max length 
8d09			; e is display size TODO 
8d09			; c is current cursor position 
8d09			; hl is ptr to where string will be stored 
8d09			 
8d09			 
8d09			; TODO check limit of buffer for new inserts 
8d09			; TODO check insert does not push beyond buffer 
8d09			; TODO scroll in a limited display area 
8d09			; TODO scroll whole screen on page wrap 
8d09			 
8d09			 
8d09			; TODO handle KEY_PREVWORD 
8d09			; TODO handle KEY_NEXTWORD 
8d09			; TODO handle KEY_HOME 
8d09			; TODO handle KEY_END 
8d09			; TODO use LCD cursor? 
8d09			 
8d09 32 64 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8d0c 81					add c 
8d0d 32 62 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8d10 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
8d13 79					ld a, c 
8d14 cd dc 8c				call addatohl 
8d17 22 69 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8d1a 7a					ld a,d 
8d1b 32 66 ee			        ld (input_size), a       ; save length of input area 
8d1e 79					ld a, c 
8d1f 32 55 ee				ld (input_cursor),a      ; init cursor start position  
8d22 7b					ld a,e 
8d23 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8d26					 
8d26					 
8d26			 
8d26			;		ld a,(input_ptr) 
8d26			;		ld (input_under_cursor),a 	; save what is under the cursor 
8d26			 
8d26			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8d26					; init cursor shape if not set by the cin routines 
8d26 21 c1 eb				ld hl, cursor_shape 
8d29 3e ff				ld a, 255 
8d2b 77					ld (hl), a 
8d2c 23					inc hl 
8d2d 3e 00				ld a, 0 
8d2f 77					ld (hl), a 
8d30			 
8d30 3e 0f				ld a, CUR_BLINK_RATE 
8d32 32 60 ee				ld (input_cur_flash), a 
8d35 3e 01				ld a, 1 
8d37 32 5f ee				ld (input_cur_onoff),a 
8d3a			 
8d3a			;	if DEBUG_INPUT 
8d3a			;		push af 
8d3a			;		ld a, 'I' 
8d3a			;		ld (debug_mark),a 
8d3a			;		pop af 
8d3a			;		CALLMONITOR 
8d3a			;	endif 
8d3a			.is1:		; main entry loop 
8d3a			 
8d3a			 
8d3a			 
8d3a					; pause 1ms 
8d3a			 
8d3a 3e 01				ld a, 1 
8d3c cd d7 89				call aDelayInMS 
8d3f			 
8d3f					; dec flash counter 
8d3f 3a 60 ee				ld a, (input_cur_flash) 
8d42 3d					dec a 
8d43 32 60 ee				ld (input_cur_flash), a 
8d46 fe 00				cp 0 
8d48 20 0d				jr nz, .nochgstate 
8d4a			 
8d4a			 
8d4a					; change state 
8d4a 3a 5f ee				ld a,(input_cur_onoff) 
8d4d ed 44				neg 
8d4f 32 5f ee				ld (input_cur_onoff),a 
8d52			 
8d52			 
8d52					; reset on change of state 
8d52 3e 0f				ld a, CUR_BLINK_RATE 
8d54 32 60 ee				ld (input_cur_flash), a 
8d57			 
8d57			.nochgstate: 
8d57					 
8d57					 
8d57			 
8d57					; display cursor  
8d57			 
8d57			;		ld hl, (input_start) 
8d57			;		ld a, (input_cursor) 
8d57			;		call addatohl 
8d57			 
8d57					; get char under cursor and replace with cursor 
8d57 2a 69 ee		ld hl, (input_ptr) 
8d5a			;		ld a, (hl) 
8d5a			;		ld (input_under_cursor),a 
8d5a			;		ld a, '_' 
8d5a			;		ld (hl), a 
8d5a			 
8d5a					; display string 
8d5a			 
8d5a ed 5b 67 ee			ld de, (input_start) 
8d5e 3a 64 ee				ld a, (input_at_pos) 
8d61 cd c2 8a				call str_at_display 
8d64			;	        call update_display 
8d64			 
8d64					; find place to put the cursor 
8d64			;		add h 
8d64			;		ld l, display_row_1 
8d64			;		sub l 
8d64			; (input_at_pos) 
8d64					;ld c, a 
8d64			;		ld a, (input_cursor) 
8d64			;		ld l, (input_at_pos) 
8d64			;		;ld b, h 
8d64			;		add l 
8d64			;		ld (input_at_cursor),a 
8d64					;ld l,h 
8d64			 
8d64			;		ld h, 0 
8d64			;		ld l,(input_at_pos) 
8d64			;		ld a, (input_cursor) 
8d64			;		call addatohl 
8d64			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8d64			;		call subafromhl 
8d64			;		ld a,l 
8d64			;		ld (input_at_cursor), a 
8d64			 
8d64				if DEBUG_INPUT 
8d64					ld a, (hardware_diag) 
8d64					cp 0 
8d64					jr z, .skip_input_diag 
8d64			 
8d64					ld a,(input_at_pos) 
8d64					ld hl, LFSRSeed 
8d64					call hexout 
8d64					ld a, (input_cursor) 
8d64					ld hl, LFSRSeed+2 
8d64					call hexout 
8d64					ld a,(input_at_cursor) 
8d64					ld hl, LFSRSeed+4 
8d64					call hexout 
8d64			 
8d64					ld a,(input_cur_onoff) 
8d64					ld hl, LFSRSeed+6 
8d64					call hexout 
8d64			 
8d64					ld a,(input_cur_flash) 
8d64					ld hl, LFSRSeed+8 
8d64					call hexout 
8d64			 
8d64					ld a,(input_len) 
8d64					ld hl, LFSRSeed+10 
8d64					call hexout 
8d64					ld hl, LFSRSeed+12 
8d64					ld a, 0 
8d64					ld (hl),a 
8d64					ld a, display_row_4 
8d64					ld de, LFSRSeed 
8d64					call str_at_display 
8d64					.skip_input_diag: 
8d64				endif 
8d64			 
8d64					; decide on if we are showing the cursor this time round 
8d64			 
8d64 3a 5f ee				ld a, (input_cur_onoff) 
8d67 fe ff				cp 255 
8d69 28 13				jr z, .skipcur 
8d6b			 
8d6b			 
8d6b 3a 62 ee				ld a,(input_at_cursor) 
8d6e 11 c1 eb				ld de, cursor_shape 
8d71 cd c2 8a				call str_at_display 
8d74			 
8d74					; save length of current input string 
8d74 2a 67 ee				ld hl, (input_start) 
8d77 cd 3a 91				call strlenz 
8d7a 7d					ld a,l 
8d7b 32 5a ee				ld (input_len),a 
8d7e			 
8d7e			.skipcur: 
8d7e			 
8d7e cd d2 8a			        call update_display 
8d81					 
8d81			 
8d81			 
8d81					; wait 
8d81				 
8d81					; TODO loop without wait to flash the cursor and char under cursor	 
8d81 cd 1d e4				call cin    ; _wait 
8d84			 
8d84 fe 00				cp 0 
8d86 ca 3a 8d				jp z, .is1 
8d89			 
8d89					; get ptr to char to input into 
8d89			 
8d89 4f					ld c,a 
8d8a 2a 67 ee				ld hl, (input_start) 
8d8d 3a 55 ee				ld a, (input_cursor) 
8d90 cd dc 8c				call addatohl 
8d93 22 69 ee				ld (input_ptr), hl 
8d96 79					ld a,c 
8d97			 
8d97					; replace char under cursor 
8d97			 
8d97			;		ld hl, (input_ptr) 
8d97			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8d97			;		ld (hl), a 
8d97			 
8d97			;	if DEBUG_INPUT 
8d97			;		push af 
8d97			;		ld a, 'i' 
8d97			;		ld (debug_mark),a 
8d97			;		pop af 
8d97			;		CALLMONITOR 
8d97			;	endif 
8d97 fe 0e				cp KEY_HOME 
8d99 20 0e				jr nz, .iske 
8d9b			 
8d9b 3a 64 ee				ld a, (input_at_pos) 
8d9e 32 62 ee				ld (input_at_cursor),a 
8da1 3e 00				ld a, 0 
8da3 32 55 ee				ld (input_cursor), a 
8da6 c3 3a 8d				jp .is1 
8da9					 
8da9 fe 0f		.iske:		cp KEY_END 
8dab 20 03				jr nz, .isknw 
8dad c3 3a 8d				jp .is1 
8db0			 
8db0 fe 06		.isknw:		cp KEY_NEXTWORD 
8db2 20 1b				jr nz, .iskpw 
8db4			 
8db4 2a 69 ee		.isknwm:	ld hl, (input_ptr) 
8db7 7e					ld a,(hl)	 
8db8 fe 00				cp 0 
8dba ca 3a 8d				jp z, .is1    ; end of string 
8dbd fe 20				cp ' ' 
8dbf ca 3a 8d				jp z, .is1    ; end of word 
8dc2 23					inc hl 
8dc3 22 69 ee				ld (input_ptr), hl 
8dc6 3a 62 ee				ld a, (input_at_cursor) 
8dc9 3c					inc a 
8dca 32 62 ee				ld (input_at_cursor), a 
8dcd 18 e5				jr .isknwm 
8dcf			 
8dcf fe 07		.iskpw:		cp KEY_PREVWORD 
8dd1 20 1b				jr nz, .iskl 
8dd3			.iskpwm:	 
8dd3 2a 69 ee				ld hl, (input_ptr) 
8dd6 7e					ld a,(hl)	 
8dd7 fe 00				cp 0  
8dd9 ca 3a 8d				jp z, .is1    ; end of string 
8ddc fe 20				cp ' ' 
8dde ca 3a 8d				jp z, .is1    ; end of word 
8de1 2b					dec hl 
8de2 22 69 ee				ld (input_ptr), hl 
8de5 3a 62 ee				ld a, (input_at_cursor) 
8de8 3d					dec a 
8de9 32 62 ee				ld (input_at_cursor), a 
8dec 18 e5				jr .iskpwm 
8dee			 
8dee			 
8dee fe 0b		.iskl:		cp KEY_LEFT 
8df0 20 27				jr nz, .isk1 
8df2			 
8df2 3a 55 ee				ld a, (input_cursor) 
8df5			 
8df5 fe 00				cp 0 
8df7 ca 3a 8d				jp z, .is1 		; at start of line to ignore  
8dfa			 
8dfa 3d					dec  a 		; TODO check underflow 
8dfb 32 55 ee				ld (input_cursor), a 
8dfe			 
8dfe 2a 69 ee				ld hl, (input_ptr) 
8e01 2b					dec hl 
8e02 22 69 ee				ld (input_ptr), hl 
8e05					 
8e05 3a 62 ee				ld a, (input_at_cursor) 
8e08 3d					dec a 
8e09 32 62 ee				ld (input_at_cursor), a 
8e0c			 
8e0c 3e 01				ld a, 1		; show cursor moving 
8e0e 32 5f ee				ld (input_cur_onoff),a 
8e11 3e 0f				ld a, CUR_BLINK_RATE 
8e13 32 60 ee				ld (input_cur_flash), a 
8e16			 
8e16 c3 3a 8d				jp .is1 
8e19			 
8e19 fe 0c		.isk1:		cp KEY_RIGHT 
8e1b 20 2a				jr nz, .isk2 
8e1d			 
8e1d 3a 5a ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8e20 5f					ld e,a 
8e21 3a 55 ee				ld a, (input_cursor) 
8e24 bb					cp e 
8e25 ca 3a 8d				jp z, .is1		; at the end of string so dont go right 
8e28			 
8e28 3c					inc  a 		; TODO check overflow 
8e29 32 55 ee				ld (input_cursor), a 
8e2c			 
8e2c 3a 62 ee				ld a, (input_at_cursor) 
8e2f 3c					inc a 
8e30 32 62 ee				ld (input_at_cursor), a 
8e33			 
8e33 2a 69 ee				ld hl, (input_ptr) 
8e36 23					inc hl 
8e37 22 69 ee				ld (input_ptr), hl 
8e3a			 
8e3a 3e 01				ld a, 1		; show cursor moving 
8e3c 32 5f ee				ld (input_cur_onoff),a 
8e3f 3e 0f				ld a, CUR_BLINK_RATE 
8e41 32 60 ee				ld (input_cur_flash), a 
8e44			 
8e44 c3 3a 8d				jp .is1 
8e47			 
8e47 fe 05		.isk2:		cp KEY_UP 
8e49			 
8e49 20 26				jr nz, .isk3 
8e4b			 
8e4b					; swap last command with the current on 
8e4b			 
8e4b					; move cursor to start of string 
8e4b 2a 67 ee				ld hl, (input_start) 
8e4e 22 69 ee				ld (input_ptr), hl 
8e51			 
8e51 3a 64 ee				ld a, (input_at_pos) 
8e54 32 62 ee				ld (input_at_cursor), a 
8e57			 
8e57 3e 00				ld a, 0 
8e59 32 55 ee				ld (input_cursor), a 
8e5c					 
8e5c					; swap input and last command buffers 
8e5c			 
8e5c 21 e8 e5				ld hl, os_cli_cmd 
8e5f 11 e7 e6				ld de, os_last_cmd 
8e62 06 ff				ld b, 255 
8e64 7e			.swap1:		ld a, (hl) 
8e65 4f					ld c,a 
8e66 1a					ld a, (de) 
8e67 77					ld (hl), a 
8e68 79					ld a,c 
8e69 12					ld (de),a 
8e6a 23					inc hl 
8e6b 13					inc de 
8e6c 10 f6				djnz .swap1 
8e6e			 
8e6e			 
8e6e			 
8e6e			 
8e6e			 
8e6e c3 3a 8d				jp .is1 
8e71			 
8e71 fe 08		.isk3:		cp KEY_BS 
8e73 20 3c				jr nz, .isk4 
8e75			 
8e75 3a 55 ee				ld a, (input_cursor) 
8e78			 
8e78 fe 00				cp 0 
8e7a ca 3a 8d				jp z, .is1 		; at start of line to ignore  
8e7d			 
8e7d 3d					dec  a 		; TODO check underflow 
8e7e 32 55 ee				ld (input_cursor), a 
8e81			 
8e81					; hl is source 
8e81					; de needs to be source - 1 
8e81			 
8e81			;		ld a, 0 
8e81			;		dec hl 
8e81			;		ld (hl), a 
8e81			 
8e81 2a 69 ee				ld hl, (input_ptr) 
8e84 2b					dec hl 
8e85 22 69 ee				ld (input_ptr), hl 
8e88			 
8e88					; shift all data 
8e88			 
8e88 e5					push hl 
8e89 23					inc hl 
8e8a d1					pop de 
8e8b 3a 5a ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8e8e 4f					ld c,a 
8e8f 06 00				ld b,0 
8e91 ed b0				ldir  
8e93			 
8e93			 
8e93			 
8e93			 
8e93 3a 62 ee				ld a, (input_at_cursor) 
8e96 3d					dec a 
8e97 32 62 ee				ld (input_at_cursor), a 
8e9a			 
8e9a			 
8e9a 3e 01				ld a, 1		; show cursor moving 
8e9c 32 5f ee				ld (input_cur_onoff),a 
8e9f 3e 0f				ld a, CUR_BLINK_RATE 
8ea1 32 60 ee				ld (input_cur_flash), a 
8ea4			 
8ea4					; remove char 
8ea4 3a 62 ee				ld a, (input_at_cursor) 
8ea7 3c					inc a 
8ea8 11 32 8f				ld de,.iblank 
8eab cd c2 8a				call str_at_display 
8eae			 
8eae c3 3a 8d				jp .is1 
8eb1			 
8eb1 fe 0d		.isk4:		cp KEY_CR 
8eb3 28 6c				jr z, .endinput 
8eb5			 
8eb5					; else add the key press to the end 
8eb5			 
8eb5 4f					ld c, a			; save key pressed 
8eb6			 
8eb6 7e					ld a,(hl)		; get what is currently under char 
8eb7			 
8eb7 fe 00				cp 0			; we are at the end of the string 
8eb9 20 2f				jr nz, .onchar 
8ebb					 
8ebb					; add a char to the end of the string 
8ebb				 
8ebb 71					ld (hl),c 
8ebc 23					inc hl 
8ebd			;		ld a,' ' 
8ebd			;		ld (hl),a 
8ebd			;		inc hl 
8ebd 3e 00				ld a,0 
8ebf 77					ld (hl),a 
8ec0 2b					dec hl 
8ec1			 
8ec1 3a 55 ee				ld a, (input_cursor) 
8ec4 3c					inc a				; TODO check max string length and scroll  
8ec5 32 55 ee				ld (input_cursor), a		; inc cursor pos 
8ec8							 
8ec8 3a 62 ee				ld a, (input_at_cursor) 
8ecb 3c					inc a 
8ecc 32 62 ee				ld (input_at_cursor), a 
8ecf			 
8ecf 2a 69 ee				ld hl, (input_ptr) 
8ed2 23					inc hl 
8ed3 22 69 ee				ld (input_ptr), hl 
8ed6			 
8ed6 2a 69 ee				ld hl, (input_ptr) 
8ed9 23					inc hl 
8eda 22 69 ee				ld (input_ptr), hl 
8edd			;	if DEBUG_INPUT 
8edd			;		push af 
8edd			;		ld a, '+' 
8edd			;		ld (debug_mark),a 
8edd			;		pop af 
8edd			;		CALLMONITOR 
8edd			;	endif 
8edd 3e 01				ld a, 1		; show cursor moving 
8edf 32 5f ee				ld (input_cur_onoff),a 
8ee2 3e 0f				ld a, CUR_BLINK_RATE 
8ee4 32 60 ee				ld (input_cur_flash), a 
8ee7 c3 3a 8d				jp .is1 
8eea					 
8eea			 
8eea			 
8eea					; if on a char then insert 
8eea			.onchar: 
8eea			 
8eea					; TODO over flow check: make sure insert does not blow out buffer 
8eea			 
8eea					; need to do some maths to use lddr 
8eea			 
8eea e5					push hl   ; save char pos 
8eeb c5					push bc 
8eec			 
8eec 2a 67 ee				ld hl, (input_start) 
8eef 3a 5a ee				ld a, (input_len) 
8ef2 cd dc 8c				call addatohl  		; end of string 
8ef5 23					inc hl 
8ef6 23					inc hl		; past zero term 
8ef7 e5					push hl 
8ef8 23					inc hl 
8ef9 e5					push hl  
8efa			 
8efa								; start and end of lddr set, now how much to move? 
8efa			 
8efa							 
8efa 3a 55 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8efd 47					ld b,a 
8efe 3a 5a ee				ld a,(input_len) 
8f01 5f					ld e,a 
8f02 90					sub b 
8f03 3c					inc a		;?? 
8f04 3c					inc a		;?? 
8f05 3c					inc a		;?? 
8f06			 
8f06 06 00				ld b,0 
8f08 4f					ld c,a 
8f09			 
8f09				if DEBUG_INPUT 
8f09					push af 
8f09					ld a, 'i' 
8f09					ld (debug_mark),a 
8f09					pop af 
8f09			;		CALLMONITOR 
8f09				endif 
8f09 d1					pop de 
8f0a e1					pop hl 
8f0b				if DEBUG_INPUT 
8f0b					push af 
8f0b					ld a, 'I' 
8f0b					ld (debug_mark),a 
8f0b					pop af 
8f0b			;		CALLMONITOR 
8f0b				endif 
8f0b ed b8				lddr 
8f0d				 
8f0d			 
8f0d			 
8f0d					; TODO have a key for insert/overwrite mode???? 
8f0d c1					pop bc 
8f0e e1					pop hl 
8f0f 71					ld (hl), c		; otherwise overwrite current char 
8f10					 
8f10			 
8f10			 
8f10			 
8f10 3a 55 ee				ld a, (input_cursor) 
8f13 3c					inc  a 		; TODO check overflow 
8f14 32 55 ee				ld (input_cursor), a 
8f17			 
8f17 3a 62 ee				ld a, (input_at_cursor) 
8f1a 3c					inc a 
8f1b 32 62 ee				ld (input_at_cursor), a 
8f1e			 
8f1e c3 3a 8d				jp .is1 
8f21			 
8f21			.endinput:	; TODO look for end of string 
8f21			 
8f21					; add trailing space for end of token 
8f21			 
8f21 2a 67 ee				ld hl, (input_start) 
8f24 3a 5a ee				ld a,(input_len) 
8f27 cd dc 8c				call addatohl 
8f2a 3e 20				ld a, ' ' 
8f2c 77					ld (hl),a 
8f2d					; TODO eof of parse marker 
8f2d			 
8f2d 23					inc hl 
8f2e 3e 00				ld a, 0 
8f30 77					ld (hl),a 
8f31			 
8f31			 
8f31 c9					ret 
8f32			 
8f32 .. 00		.iblank: db " ",0 
8f34			 
8f34			 
8f34 32 64 ee		input_str_prev:	ld (input_at_pos), a 
8f37 22 67 ee				ld (input_start), hl 
8f3a 3e 01				ld a,1			; add cursor 
8f3c 77					ld (hl),a 
8f3d 23					inc hl 
8f3e 3e 00				ld a,0 
8f40 77					ld (hl),a 
8f41 22 69 ee				ld (input_ptr), hl 
8f44 7a					ld a,d 
8f45 32 66 ee				ld (input_size), a 
8f48 3e 00				ld a,0 
8f4a 32 55 ee				ld (input_cursor),a 
8f4d			.instr1:	 
8f4d			 
8f4d					; TODO do block cursor 
8f4d					; TODO switch cursor depending on the modifer key 
8f4d			 
8f4d					; update cursor shape change on key hold 
8f4d			 
8f4d 2a 69 ee				ld hl, (input_ptr) 
8f50 2b					dec hl 
8f51 3a c1 eb				ld a,(cursor_shape) 
8f54 77					ld (hl), a 
8f55			 
8f55					; display entered text 
8f55 3a 64 ee				ld a,(input_at_pos) 
8f58 cd 7b e3		            	CALL fLCD_Pos       ;Position cursor to location in A 
8f5b ed 5b 67 ee	            	LD   de, (input_start) 
8f5f cd 75 e3		            	CALL fLCD_Str       ;Display string pointed to by DE 
8f62			 
8f62 cd 1d e4				call cin 
8f65 fe 00				cp 0 
8f67 28 e4				jr z, .instr1 
8f69			 
8f69					; proecess keyboard controls first 
8f69			 
8f69 2a 69 ee				ld hl,(input_ptr) 
8f6c			 
8f6c fe 0d				cp KEY_CR	 ; pressing enter ends input 
8f6e 28 5a				jr z, .instrcr 
8f70			 
8f70 fe 08				cp KEY_BS 	; back space 
8f72 20 0f				jr nz, .instr2 
8f74					; process back space 
8f74			 
8f74					; TODO stop back space if at start of string 
8f74 2b					dec hl 
8f75 2b					dec hl ; to over write cursor 
8f76 3a c1 eb				ld a,(cursor_shape) 
8f79					;ld a,0 
8f79 77					ld (hl),a 
8f7a 23					inc hl 
8f7b 3e 20				ld a," " 
8f7d 77					ld (hl),a 
8f7e 22 69 ee				ld (input_ptr),hl 
8f81					 
8f81			 
8f81 18 ca				jr .instr1 
8f83			 
8f83 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8f85 20 06				jr nz, .instr3 
8f87 2b					dec hl 
8f88 22 69 ee				ld (input_ptr),hl 
8f8b 18 c0				jr .instr1 
8f8d				 
8f8d fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8f8f 20 06				jr nz, .instr4 
8f91 23					inc hl 
8f92 22 69 ee				ld (input_ptr),hl 
8f95 18 b6				jr .instr1 
8f97			 
8f97 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8f99 20 06				jr nz, .instr5 
8f9b 2b					dec hl 
8f9c 22 69 ee				ld (input_ptr),hl 
8f9f 18 ac				jr .instr1 
8fa1			 
8fa1 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8fa3 20 06				jr nz, .instr6 
8fa5 2b					dec hl 
8fa6 22 69 ee				ld (input_ptr),hl 
8fa9 18 a2				jr .instr1 
8fab fe 05		.instr6:        cp KEY_UP      ; recall last command 
8fad 20 0b				jr nz, .instrnew 
8faf			 
8faf 21 c1 e2			ld hl, scratch 
8fb2 11 e7 e6			ld de, os_last_cmd 
8fb5 cd d3 8f			call strcpy 
8fb8 18 93				jr .instr1 
8fba			 
8fba			 
8fba			.instrnew:	; no special key pressed to see if we have room to store it 
8fba			 
8fba					; TODO do string size test 
8fba			 
8fba 2b					dec hl ; to over write cursor 
8fbb 77					ld (hl),a 
8fbc 23					inc hl 
8fbd 3a c1 eb				ld a,(cursor_shape) 
8fc0 77					ld (hl),a 
8fc1 23					inc hl 
8fc2 3e 00				ld a,0 
8fc4 77					ld (hl),a 
8fc5			 
8fc5 22 69 ee				ld (input_ptr),hl 
8fc8					 
8fc8 18 83				jr .instr1 
8fca 2b			.instrcr:	dec hl		; remove cursor 
8fcb 3e 20				ld a,' '	; TODO add a trailing space for safety 
8fcd 77					ld (hl),a 
8fce 23					inc hl 
8fcf 3e 00				ld a,0 
8fd1 77					ld (hl),a 
8fd2			 
8fd2			 
8fd2					; if at end of line scroll up    
8fd2					; TODO detecting only end of line 4 for scroll up  
8fd2			 
8fd2					;ld   
8fd2			 
8fd2 c9					ret 
8fd3			 
8fd3			 
8fd3			; strcpy hl = dest, de source 
8fd3			 
8fd3 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8fd4 b7			            OR   A              ;Null terminator? 
8fd5 c8			            RET  Z              ;Yes, so finished 
8fd6 1a					ld a,(de) 
8fd7 77					ld (hl),a 
8fd8 13			            INC  DE             ;Point to next character 
8fd9 23					inc hl 
8fda 18 f7		            JR   strcpy       ;Repeat 
8fdc c9					ret 
8fdd			 
8fdd			 
8fdd			; TODO string_at  
8fdd			; pass string which starts with lcd offset address and then null term string 
8fdd			 
8fdd			; TODO string to dec 
8fdd			; TODO string to hex 
8fdd			; TODO byte to string hex 
8fdd			; TODO byte to string dec 
8fdd			 
8fdd			 
8fdd			 
8fdd			; from z80uartmonitor 
8fdd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fdd			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8fdd			; pass hl for where to put the text 
8fdd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fdd c5			hexout:	PUSH BC 
8fde f5					PUSH AF 
8fdf 47					LD B, A 
8fe0					; Upper nybble 
8fe0 cb 3f				SRL A 
8fe2 cb 3f				SRL A 
8fe4 cb 3f				SRL A 
8fe6 cb 3f				SRL A 
8fe8 cd f8 8f				CALL tohex 
8feb 77					ld (hl),a 
8fec 23					inc hl	 
8fed					 
8fed					; Lower nybble 
8fed 78					LD A, B 
8fee e6 0f				AND 0FH 
8ff0 cd f8 8f				CALL tohex 
8ff3 77					ld (hl),a 
8ff4 23					inc hl	 
8ff5					 
8ff5 f1					POP AF 
8ff6 c1					POP BC 
8ff7 c9					RET 
8ff8					 
8ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ff8			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8ff8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8ff8			tohex: 
8ff8 e5					PUSH HL 
8ff9 d5					PUSH DE 
8ffa 16 00				LD D, 0 
8ffc 5f					LD E, A 
8ffd 21 05 90				LD HL, .DATA 
9000 19					ADD HL, DE 
9001 7e					LD A, (HL) 
9002 d1					POP DE 
9003 e1					POP HL 
9004 c9					RET 
9005			 
9005			.DATA: 
9005 30					DEFB	30h	; 0 
9006 31					DEFB	31h	; 1 
9007 32					DEFB	32h	; 2 
9008 33					DEFB	33h	; 3 
9009 34					DEFB	34h	; 4 
900a 35					DEFB	35h	; 5 
900b 36					DEFB	36h	; 6 
900c 37					DEFB	37h	; 7 
900d 38					DEFB	38h	; 8 
900e 39					DEFB	39h	; 9 
900f 41					DEFB	41h	; A 
9010 42					DEFB	42h	; B 
9011 43					DEFB	43h	; C 
9012 44					DEFB	44h	; D 
9013 45					DEFB	45h	; E 
9014 46					DEFB	46h	; F 
9015			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9015			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
9015			;;    subtract $30, if result > 9 then subtract $7 more 
9015			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
9015			atohex: 
9015 d6 30				SUB $30 
9017 fe 0a				CP 10 
9019 f8					RET M		; If result negative it was 0-9 so we're done 
901a d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
901c c9					RET		 
901d			 
901d			 
901d			 
901d			 
901d			; Get 2 ASCII characters as hex byte from pointer in hl 
901d			 
901d			BYTERD: 
901d 16 00			LD	D,00h		;Set up 
901f cd 27 90			CALL	HEXCON		;Get byte and convert to hex 
9022 87				ADD	A,A		;First nibble so 
9023 87				ADD	A,A		;multiply by 16 
9024 87				ADD	A,A		; 
9025 87				ADD	A,A		; 
9026 57				LD	D,A		;Save hi nibble in D 
9027			HEXCON: 
9027 7e				ld a, (hl)		;Get next chr 
9028 23				inc hl 
9029 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
902b fe 0a			CP	00Ah		;Is it 0-9 ? 
902d 38 02			JR	C,NALPHA	;If so miss next bit 
902f d6 07			SUB	007h		;Else convert alpha 
9031			NALPHA: 
9031 b2				OR	D		;Add hi nibble back 
9032 c9				RET			; 
9033			 
9033			 
9033			; 
9033			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
9033			; Since the routines get_byte and therefore get_nibble are called, only valid 
9033			; characters (0-9a-f) are accepted. 
9033			; 
9033			;get_word        push    af 
9033			;                call    get_byte        ; Get the upper byte 
9033			;                ld      h, a 
9033			;                call    get_byte        ; Get the lower byte 
9033			;                ld      l, a 
9033			;                pop     af 
9033			;                ret 
9033			; 
9033			; Get a byte in hexadecimal notation. The result is returned in A. Since 
9033			; the routine get_nibble is used only valid characters are accepted - the  
9033			; input routine only accepts characters 0-9a-f. 
9033			; 
9033 c5			get_byte:        push    bc              ; Save contents of B (and C) 
9034 7e					ld a,(hl) 
9035 23					inc hl 
9036 cd 5b 90		                call    nibble2val      ; Get upper nibble 
9039 cb 07		                rlc     a 
903b cb 07		                rlc     a 
903d cb 07		                rlc     a 
903f cb 07		                rlc     a 
9041 47			                ld      b, a            ; Save upper four bits 
9042 7e					ld a,(hl) 
9043 cd 5b 90		                call    nibble2val      ; Get lower nibble 
9046 b0			                or      b               ; Combine both nibbles 
9047 c1			                pop     bc              ; Restore B (and C) 
9048 c9			                ret 
9049			; 
9049			; Get a hexadecimal digit from the serial line. This routine blocks until 
9049			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
9049			; to the serial line interface. The lower 4 bits of A contain the value of  
9049			; that particular digit. 
9049			; 
9049			;get_nibble      ld a,(hl)           ; Read a character 
9049			;                call    to_upper        ; Convert to upper case 
9049			;                call    is_hex          ; Was it a hex digit? 
9049			;                jr      nc, get_nibble  ; No, get another character 
9049			 ;               call    nibble2val      ; Convert nibble to value 
9049			 ;               call    print_nibble 
9049			 ;               ret 
9049			; 
9049			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
9049			; A valid hexadecimal digit is denoted by a set C flag. 
9049			; 
9049			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
9049			;                ret     nc              ; Yes 
9049			;                cp      '0'             ; Less than '0'? 
9049			;                jr      nc, is_hex_1    ; No, continue 
9049			;                ccf                     ; Complement carry (i.e. clear it) 
9049			;                ret 
9049			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
9049			;                ret     c               ; Yes 
9049			;                cp      'A'             ; Less than 'A'? 
9049			;                jr      nc, is_hex_2    ; No, continue 
9049			;                ccf                     ; Yes - clear carry and return 
9049			;                ret 
9049			;is_hex_2        scf                     ; Set carry 
9049			;                ret 
9049			; 
9049			; Convert a single character contained in A to upper case: 
9049			; 
9049 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
904b d8			                ret     c 
904c fe 7b		                cp      'z' + 1         ; > 'z'? 
904e d0			                ret     nc              ; Nothing to do, either 
904f e6 5f		                and     $5f             ; Convert to upper case 
9051 c9			                ret 
9052			 
9052			 
9052			to_lower: 
9052			 
9052			   ; if char is in [A-Z] make it lower case 
9052			 
9052			   ; enter : a = char 
9052			   ; exit  : a = lower case char 
9052			   ; uses  : af 
9052			 
9052 fe 41		   cp 'A' 
9054 d8			   ret c 
9055			    
9055 fe 5b		   cp 'Z'+1 
9057 d0			   ret nc 
9058			    
9058 f6 20		   or $20 
905a c9			   ret 
905b			 
905b			; 
905b			; Expects a hexadecimal digit (upper case!) in A and returns the 
905b			; corresponding value in A. 
905b			; 
905b fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
905d 38 02		                jr      c, nibble2val_1 ; Yes 
905f d6 07		                sub     7               ; Adjust for A-F 
9061 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
9063 e6 0f		                and     $f              ; Only return lower 4 bits 
9065 c9			                ret 
9066			; 
9066			; Print_nibble prints a single hex nibble which is contained in the lower  
9066			; four bits of A: 
9066			; 
9066			;print_nibble    push    af              ; We won't destroy the contents of A 
9066			;                and     $f              ; Just in case... 
9066			;                add     a, '0'             ; If we have a digit we are done here. 
9066			;                cp      '9' + 1         ; Is the result > 9? 
9066			;                jr      c, print_nibble_1 
9066			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
9066			;print_nibble_1  call    putc            ; Print the nibble and 
9066			;                pop     af              ; restore the original value of A 
9066			;                ret 
9066			;; 
9066			;; Send a CR/LF pair: 
9066			; 
9066			;crlf            push    af 
9066			;                ld      a, cr 
9066			;                call    putc 
9066			;                ld      a, lf 
9066			;                call    putc 
9066			;                pop     af 
9066			;                ret 
9066			; 
9066			; Print_word prints the four hex digits of a word to the serial line. The  
9066			; word is expected to be in HL. 
9066			; 
9066			;print_word      push    hl 
9066			;                push    af 
9066			;                ld      a, h 
9066			;                call    print_byte 
9066			;                ld      a, l 
9066			;                call    print_byte 
9066			;                pop     af 
9066			;                pop     hl 
9066			;                ret 
9066			; 
9066			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
9066			; The byte to be printed is expected to be in A. 
9066			; 
9066			;print_byte      push    af              ; Save the contents of the registers 
9066			;                push    bc 
9066			;                ld      b, a 
9066			;                rrca 
9066			;                rrca 
9066			;                rrca 
9066			;                rrca 
9066			;                call    print_nibble    ; Print high nibble 
9066			;                ld      a, b 
9066			;                call    print_nibble    ; Print low nibble 
9066			;                pop     bc              ; Restore original register contents 
9066			;                pop     af 
9066			;                ret 
9066			 
9066			 
9066			 
9066			 
9066			 
9066			fourehexhl:  
9066 7e				ld a,(hl) 
9067 cd 15 90			call atohex 
906a cb 3f				SRL A 
906c cb 3f				SRL A 
906e cb 3f				SRL A 
9070 cb 3f				SRL A 
9072 47				ld b, a 
9073 23				inc hl 
9074 7e				ld a,(hl) 
9075 23				inc hl 
9076 cd 15 90			call atohex 
9079 80				add b 
907a 57				ld d,a 
907b 7e				ld a,(hl) 
907c cd 15 90			call atohex 
907f cb 3f				SRL A 
9081 cb 3f				SRL A 
9083 cb 3f				SRL A 
9085 cb 3f				SRL A 
9087 47				ld b, a 
9088 23				inc hl 
9089 7e				ld a,(hl) 
908a 23				inc hl 
908b cd 15 90			call atohex 
908e 80				add b 
908f 5f				ld e, a 
9090 d5				push de 
9091 e1				pop hl 
9092 c9				ret 
9093			 
9093			; pass hl. returns z set if the byte at hl is a digit 
9093			;isdigithl:  
9093			;	push bc 
9093			;	ld a,(hl) 
9093			;	cp ':' 
9093			;	jr nc, .isdf 		; > 
9093			;	cp '0' 
9093			;	jr c, .isdf		; < 
9093			; 
9093			;	; TODO find a better way to set z 
9093			; 
9093			;	ld b,a 
9093			;	cp b 
9093			;	pop bc 
9093			;	ret 
9093			; 
9093			;.isdf:	; not digit so clear z 
9093			; 
9093			;	; TODO find a better way to unset z 
9093			; 
9093			;	ld b,a 
9093			;	inc b 
9093			;	cp b 
9093			; 
9093			;	pop bc 
9093			;	ret 
9093				 
9093				 
9093			 
9093			 
9093			; pass hl as the four byte address to load 
9093			 
9093			get_word_hl:  
9093 e5				push hl 
9094 cd 33 90			call get_byte 
9097				 
9097 47				ld b, a 
9098			 
9098 e1				pop hl 
9099 23				inc hl 
909a 23				inc hl 
909b			 
909b			; TODO not able to handle a-f  
909b 7e				ld a,(hl) 
909c			;	;cp ':' 
909c			;	cp 'g' 
909c			;	jr nc, .single_byte_hl 		; > 
909c			;	cp 'G' 
909c			;	jr nc, .single_byte_hl 		; > 
909c			;	cp '0' 
909c			;	jr c, .single_byte_hl		; < 
909c			 
909c				;call isdigithl 
909c fe 00			cp 0 
909e 28 06			jr z, .single_byte_hl 
90a0			 
90a0			.getwhln:   ; hex word so get next byte 
90a0			 
90a0 cd 33 90			call get_byte 
90a3 6f				ld l, a 
90a4 60				ld h,b 
90a5 c9				ret 
90a6 68			.single_byte_hl:   ld l,b 
90a7 26 00				ld h,0 
90a9 c9					ret 
90aa			 
90aa			 
90aa			 
90aa			 
90aa 21 29 98			ld hl,asc+1 
90ad			;	ld a, (hl) 
90ad			;	call nibble2val 
90ad cd 33 90			call get_byte 
90b0			 
90b0			;	call fourehexhl 
90b0 32 f5 e2			ld (scratch+52),a 
90b3				 
90b3 21 f3 e2			ld hl,scratch+50 
90b6 22 e4 e5			ld (os_cur_ptr),hl 
90b9			 
90b9 c9				ret 
90ba			 
90ba			 
90ba			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
90ba			 
90ba			; Decimal Unsigned Version 
90ba			 
90ba			;Number in a to decimal ASCII 
90ba			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
90ba			;Example: display a=56 as "056" 
90ba			;input: a = number 
90ba			;Output: a=0,value of a in the screen 
90ba			;destroys af,bc (don't know about hl and de) 
90ba			DispAToASCII: 
90ba 0e 9c			ld	c,-100 
90bc cd c6 90			call	.Na1 
90bf 0e f6			ld	c,-10 
90c1 cd c6 90			call	.Na1 
90c4 0e ff			ld	c,-1 
90c6 06 2f		.Na1:	ld	b,'0'-1 
90c8 04			.Na2:	inc	b 
90c9 81				add	a,c 
90ca 38 fc			jr	c,.Na2 
90cc 91				sub	c		;works as add 100/10/1 
90cd f5				push af		;safer than ld c,a 
90ce 78				ld	a,b		;char is in b 
90cf			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
90cf f1				pop af		;safer than ld a,c 
90d0 c9				ret 
90d1			 
90d1			; Decimal Signed Version 
90d1			 
90d1			; DispA 
90d1			; -------------------------------------------------------------- 
90d1			; Converts a signed integer value to a zero-terminated ASCII 
90d1			; string representative of that value (using radix 10). 
90d1			; -------------------------------------------------------------- 
90d1			; INPUTS: 
90d1			;     HL     Value to convert (two's complement integer). 
90d1			;     DE     Base address of string destination. (pointer). 
90d1			; -------------------------------------------------------------- 
90d1			; OUTPUTS: 
90d1			;     None 
90d1			; -------------------------------------------------------------- 
90d1			; REGISTERS/MEMORY DESTROYED 
90d1			; AF HL 
90d1			; -------------------------------------------------------------- 
90d1			 
90d1			;DispHLToASCII: 
90d1			;   push    de 
90d1			;   push    bc 
90d1			; 
90d1			;; Detect sign of HL. 
90d1			;    bit    7, h 
90d1			;    jr     z, ._DoConvert 
90d1			; 
90d1			;; HL is negative. Output '-' to string and negate HL. 
90d1			;    ld     a, '-' 
90d1			;    ld     (de), a 
90d1			;    inc    de 
90d1			; 
90d1			;; Negate HL (using two's complement) 
90d1			;    xor    a 
90d1			;    sub    l 
90d1			;    ld     l, a 
90d1			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
90d1			;    sbc    a, h 
90d1			;    ld     h, a 
90d1			; 
90d1			;; Convert HL to digit characters 
90d1			;._DoConvert: 
90d1			;    ld     b, 0     ; B will count character length of number 
90d1			;-   ld     a, 10 
90d1			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
90d1			;    push   af 
90d1			;    inc    b 
90d1			;    ld     a, h 
90d1			;    or     l 
90d1			;    jr     nz, - 
90d1			; 
90d1			;; Retrieve digits from stack 
90d1			;-   pop    af 
90d1			;    or     $30 
90d1			;    ld     (de), a 
90d1			;    inc    de 
90d1			;    djnz   - 
90d1			; 
90d1			;; Terminate string with NULL 
90d1			;    xor    a 
90d1			;    ld     (de), a 
90d1			; 
90d1			;    pop    bc 
90d1			;    pop    de 
90d1			;    ret 
90d1			 
90d1			;Comments 
90d1			; 
90d1			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
90d1			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
90d1			;    Note that the output string will not be fixed-width. 
90d1			; 
90d1			;Example Usage 
90d1			; 
90d1			;    ld    hl, -1004 
90d1			;    ld    de, OP1 
90d1			;    call  DispA 
90d1			;    ld    hl, OP1 
90d1			;    syscall  PutS 
90d1			 
90d1			 
90d1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90d1			 
90d1			 
90d1			;Converts an ASCII string to an unsigned 16-bit integer 
90d1			;Quits when it reaches a non-decimal digit 
90d1			 
90d1			string_to_uint16: 
90d1			atoui_16: 
90d1			;Input: 
90d1			;     DE points to the string 
90d1			;Outputs: 
90d1			;     HL is the result 
90d1			;     A is the 8-bit value of the number 
90d1			;     DE points to the byte after the number 
90d1			;Destroys: 
90d1			;     BC 
90d1			;       if the string is non-empty, BC is HL/10 
90d1			;Size:  24 bytes 
90d1			;Speed: 42+d(104+{0,9}) 
90d1			;       d is the number of digits in the number 
90d1			;       max is 640 cycles for a 5 digit number 
90d1			;Assuming no leading zeros: 
90d1			;1 digit:  146cc 
90d1			;2 digit:  250cc 
90d1			;3 digit:  354cc or 363cc (avg: 354.126cc) 
90d1			;4 digit:  458cc or 467cc (avg: 458.27cc) 
90d1			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
90d1			;avg: 544.81158447265625cc (544+13297/16384) 
90d1			;=============================================================== 
90d1 21 00 00		  ld hl,0 
90d4			.u16a: 
90d4 1a			  ld a,(de) 
90d5 d6 30		  sub 30h 
90d7 fe 0a		  cp 10 
90d9 d0			  ret nc 
90da 13			  inc de 
90db 44			  ld b,h 
90dc 4d			  ld c,l 
90dd 29			  add hl,hl 
90de 29			  add hl,hl 
90df 09			  add hl,bc 
90e0 29			  add hl,hl 
90e1 85			  add a,l 
90e2 6f			  ld l,a 
90e3 30 ef		  jr nc,.u16a 
90e5 24			  inc h 
90e6 c3 d4 90		  jp .u16a 
90e9			 
90e9			 
90e9			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90e9			 
90e9			;written by Zeda 
90e9			;Converts a 16-bit unsigned integer to an ASCII string. 
90e9			 
90e9			uitoa_16: 
90e9			;Input: 
90e9			;   DE is the number to convert 
90e9			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
90e9			;Output: 
90e9			;   HL points to the null-terminated ASCII string 
90e9			;      NOTE: This isn't necessarily the same as the input HL. 
90e9 d5			  push de 
90ea c5			  push bc 
90eb f5			  push af 
90ec eb			  ex de,hl 
90ed			 
90ed 01 f0 d8		  ld bc,-10000 
90f0 3e 2f		  ld a,'0'-1 
90f2 3c			  inc a 
90f3 09			  add hl,bc  
90f4 38 fc		   jr c,$-2 
90f6 12			  ld (de),a 
90f7 13			  inc de 
90f8			 
90f8 01 e8 03		  ld bc,1000 
90fb 3e 3a		  ld a,'9'+1 
90fd 3d			  dec a  
90fe 09			  add hl,bc  
90ff 30 fc		   jr nc,$-2 
9101 12			  ld (de),a 
9102 13			  inc de 
9103			 
9103 01 9c ff		  ld bc,-100 
9106 3e 2f		  ld a,'0'-1 
9108 3c			  inc a  
9109 09			  add hl,bc  
910a 38 fc		   jr c,$-2 
910c 12			  ld (de),a 
910d 13			  inc de 
910e			 
910e 7d			  ld a,l 
910f 26 3a		  ld h,'9'+1 
9111 25			  dec h  
9112 c6 0a		  add a,10  
9114 30 fb		   jr nc,$-3 
9116 c6 30		  add a,'0' 
9118 eb			  ex de,hl 
9119 72			  ld (hl),d 
911a 23			  inc hl 
911b 77			  ld (hl),a 
911c 23			  inc hl 
911d 36 00		  ld (hl),0 
911f			 
911f			;Now strip the leading zeros 
911f 0e fa		  ld c,-6 
9121 09			  add hl,bc 
9122 3e 30		  ld a,'0' 
9124 23			  inc hl  
9125 be			  cp (hl)  
9126 28 fc		  jr z,$-2 
9128			 
9128			;Make sure that the string is non-empty! 
9128 7e			  ld a,(hl) 
9129 b7			  or a 
912a 20 01		  jr nz,.atoub 
912c 2b			  dec hl 
912d			.atoub: 
912d			 
912d f1			  pop af 
912e c1			  pop bc 
912f d1			  pop de 
9130 c9			  ret 
9131			 
9131			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
9131			 
9131			toUpper: 
9131			;A is the char. 
9131			;If A is a lowercase letter, this sets it to the matching uppercase 
9131			;18cc or 30cc or 41cc 
9131			;avg: 26.75cc 
9131 fe 61		  cp 'a' 
9133 d8			  ret c 
9134 fe 7b		  cp 'z'+1 
9136 d0			  ret nc 
9137 d6 20		  sub 'a'-'A' 
9139 c9			  ret 
913a			 
913a			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
913a			 
913a			; String Length 
913a			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
913a			 
913a			; Get the length of the null-terminated string starting at $8000 hl 
913a			;    LD     HL, $8000 
913a			 
913a			strlenz: 
913a			 
913a af			    XOR    A               ; Zero is the value we are looking for. 
913b 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
913c 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
913d			                           ; 65, 536 bytes (the entire addressable memory space). 
913d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
913f			 
913f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
913f 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9140 6f			    LD     L, A             ; number of bytes 
9141 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9143 2b			    DEC    HL              ; Compensate for null. 
9144 c9				ret 
9145			 
9145			; Get the length of the A terminated string starting at $8000 hl 
9145			;    LD     HL, $8000 
9145			 
9145			strlent: 
9145			 
9145			                  ; A is the value we are looking for. 
9145 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
9147 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
9149			                           ; 65, 536 bytes (the entire addressable memory space). 
9149 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
914b			 
914b			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
914b 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
914d 2e 00		    LD     L, 0             ; number of bytes 
914f ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9151 2b			    DEC    HL              ; Compensate for null. 
9152 c9				ret 
9153			 
9153			 
9153			;Comparing Strings 
9153			 
9153			;IN    HL     Address of string1. 
9153			;      DE     Address of string2. 
9153			 
9153			; doc given but wrong??? 
9153			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9153			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9153			; tested 
9153			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9153			 
9153			strcmp_old: 
9153 e5			    PUSH   HL 
9154 d5			    PUSH   DE 
9155			 
9155 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
9156 be			    CP     (HL)            ; (want to minimize work). 
9157 38 01		    JR     C, Str1IsBigger 
9159 7e			    LD     A, (HL) 
915a			 
915a			Str1IsBigger: 
915a 4f			    LD     C, A             ; Put length in BC 
915b 06 00		    LD     B, 0 
915d 13			    INC    DE              ; Increment pointers to meat of string. 
915e 23			    INC    HL 
915f			 
915f			CmpLoop: 
915f 1a			    LD     A, (DE)          ; Compare bytes. 
9160 ed a1		    CPI 
9162 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
9164 13			    INC    DE              ; Update pointer. 
9165 ea 5f 91		    JP     PE, CmpLoop 
9168			 
9168 d1			    POP    DE 
9169 e1			    POP    HL 
916a 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
916b be			    CP     (HL) 
916c c9			    RET 
916d			 
916d			NoMatch: 
916d 2b			    DEC    HL 
916e be			    CP     (HL)            ; Compare again to affect carry. 
916f d1			    POP    DE 
9170 e1			    POP    HL 
9171 c9			    RET 
9172			 
9172			;; test strmp 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str2 
9172			;call strcmp 
9172			;jr z, .z1 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "NZ1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.z1: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "ZZ1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str1 
9172			;call strcmp 
9172			;jr z, .z2 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "NZ2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.z2: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "ZZ2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str2 
9172			;call strcmp 
9172			;jr c, .c1 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "Nc1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.c1: 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "cc1" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			; 
9172			;ld de, .str1 
9172			;ld hl, .str1 
9172			;call strcmp 
9172			;jr c, .c2 
9172			;;this 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "Nc2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;.c2: 
9172			; 
9172			;	if DEBUG_FORTH_WORDS 
9172			;		DMARK "cc2" 
9172			;		CALLMONITOR 
9172			;	endif 
9172			;	NEXTW 
9172			;.str1:   db "string1",0 
9172			;.str2:   db "string2",0 
9172			 
9172			; only care about direct match or not 
9172			; hl and de strings 
9172			; zero set if the same 
9172			 
9172			strcmp: 
9172 1a				ld a, (de) 
9173 be				cp (hl) 
9174 28 02			jr z, .ssame 
9176 b7				or a 
9177 c9				ret 
9178			 
9178			.ssame:  
9178 fe 00			cp 0 
917a c8				ret z 
917b			 
917b 23				inc hl 
917c 13				inc de 
917d 18 f3			jr strcmp 
917f				 
917f				 
917f			 
917f			 
917f			 
917f			 
917f			; eof 
917f			 
917f			 
917f			 
917f			 
917f			 
917f			 
# End of file firmware_strings.asm
917f			include "firmware_memory.asm"   ; malloc and free  
917f			 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			.mallocsize: db "Wants malloc >256",0 
917f			.mallocasize: db "MALLOC gives >256",0 
917f			.malloczero: db "MALLOC gives zero",0 
917f			 
917f			malloc_guard_zerolen: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f				ld de, 0 
917f			        call cmp16 
917f				jr nz, .lowalloz 
917f			 
917f				push hl 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .malloczero 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f				call bp_on 
917f			;	ld a, 0 
917f			;	ld (os_view_disable), a 
917f			 
917f				pop de 
917f				pop hl 
917f			 
917f				 
917f			 
917f				CALLMONITOR 
917f			.lowalloz: 
917f			 
917f			 
917f				pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			 
917f			malloc_guard_entry: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f			 	or a      ;clear carry flag 
917f				push hl 
917f				ld de, 255 
917f				sbc hl, de 
917f				jr c, .lowalloc 
917f			 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .mallocsize 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f			;	ld a, 0 
917f			;	ld (os_view_disable), a 
917f				call bp_on 
917f			 
917f				pop de 
917f				pop hl 
917f			 
917f				 
917f			 
917f				CALLMONITOR 
917f				jr .lowdone 
917f			.lowalloc: 
917f			 
917f			 
917f				pop hl 
917f			.lowdone:	pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			 
917f			malloc_guard_exit: 
917f				push hl 
917f				push de 
917f				push af 
917f			 
917f			 	or a      ;clear carry flag 
917f				push hl 
917f				ld de, 255 
917f				sbc hl, de 
917f				jr c, .lowallocx 
917f			 
917f				push de 
917f					ld hl, display_fb0 
917f					ld (display_fb_active), hl 
917f				call clear_display 
917f				ld a, 0 
917f				ld de, .mallocasize 
917f				call str_at_display 
917f				call update_display 
917f				call delay1s 
917f				call delay1s 
917f			;	ld a, 0 
917f			;	ld (os_view_disable), a 
917f				call bp_on 
917f				pop de 
917f				pop hl 
917f			 
917f				CALLMONITOR 
917f				jr .lowdonex 
917f			.lowallocx: 
917f			 
917f				pop hl 
917f			.lowdonex:	pop af 
917f				pop de 
917f				pop hl 
917f			ret 
917f			endif 
917f			 
917f			if MALLOC_2 
917f			; Z80 Malloc and Free Functions 
917f			 
917f			; Malloc Function: 
917f			; Input: 
917f			;   HL: Size of block to allocate 
917f			; Output: 
917f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
917f			 
917f			malloc: 
917f				 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			call malloc_guard_entry 
917f			endif 
917f			 
917f			 
917f			 
917f			 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "mal" 
917f						CALLMONITOR 
917f					endif 
917f			    push af            ; Save AF register 
917f			    ld a, l            ; Load low byte of size into A 
917f			    or h               ; Check if size is zero 
917f			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
917f			 
917f			    ; Allocate memory 
917f			    ld hl, (heap_start) ; Load start of heap into HL 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma1" 
917f						CALLMONITOR 
917f					endif 
917f			    call malloc_internal ; Call internal malloc function 
917f			    pop af             ; Restore AF register 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret                ; Return 
917f			 
917f			; Free Function: 
917f			; Input: 
917f			;   HL: Pointer to memory block to free 
917f			; Output: 
917f			;   None 
917f			 
917f			free: 
917f			    push af            ; Save AF register 
917f			    ld a, l            ; Load low byte of pointer into A 
917f			    or h               ; Check if pointer is NULL 
917f			    jp z, free_exit    ; If pointer is NULL, exit 
917f			 
917f			    ; Free memory 
917f			    ld hl, (heap_start) ; Load start of heap into HL 
917f			    call free_internal  ; Call internal free function 
917f			    pop af             ; Restore AF register 
917f			    ret                ; Return 
917f			 
917f			; Internal Malloc Function: 
917f			; Input: 
917f			;   HL: Size of block to allocate 
917f			; Output: 
917f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
917f			 
917f			malloc_internal: 
917f			    ld bc, 2           ; Number of bytes to allocate for management overhead 
917f			    add hl, bc         ; Add management overhead to requested size 
917f			    ex de, hl          ; Save total size in DE, and keep it in HL 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma2" 
917f						CALLMONITOR 
917f					endif 
917f			 
917f			    ; Search for free memory block 
917f			    ld de, (heap_end)  ; Load end of heap into DE 
917f			    ld bc, 0           ; Initialize counter 
917f			 
917f					if DEBUG_FORTH_MALLOC 
917f						DMARK "ma2" 
917f						CALLMONITOR 
917f					endif 
917f			malloc_search_loop: 
917f			    ; Check if current block is free 
917f			    ld a, (hl)         ; Load current block's status (free or used) 
917f			    cp 0               ; Compare with zero (free) 
917f			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
917f			 
917f			    ; Check if current block is large enough 
917f			    ld a, (hl+1)       ; Load high byte of block size 
917f			    cp l               ; Compare with low byte of requested size 
917f			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
917f			 
917f			    ld a, (hl+2)       ; Load low byte of block size 
917f			    cp h               ; Compare with high byte of requested size 
917f			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
917f			 
917f			    ; Mark block as used 
917f			    ld (hl), 0xFF      ; Set status byte to indicate used block 
917f			 
917f			    ; Calculate remaining space in block 
917f			    ld bc, 0           ; Clear BC 
917f			    add hl, bc         ; Increment HL to point to start of data block 
917f			    add hl, de         ; HL = HL + DE (total size) 
917f			    ld bc, 1           ; Number of bytes to allocate for management overhead 
917f			    add hl, bc         ; Add management overhead to start of data block 
917f			 
917f			    ; Save pointer to allocated block in HL 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma5" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			 
917f			malloc_skip_block_check: 
917f			    ; Move to the next block 
917f			    ld bc, 3           ; Size of management overhead 
917f			    add hl, bc         ; Move to the next block 
917f			    inc de             ; Increment counter 
917f			 
917f			    ; Check if we have reached the end of heap 
917f			    ld a, e            ; Load low byte of heap end address 
917f			    cp (hl)            ; Compare with low byte of current address 
917f			    jr nz, malloc_search_loop  ; If not equal, continue searching 
917f			    ld a, d            ; Load high byte of heap end address 
917f			    cp 0               ; Check if it's zero (end of memory) 
917f			    jr nz, malloc_search_loop  ; If not zero, continue searching 
917f			 
917f			    ; If we reached here, allocation failed 
917f			    xor a              ; Set result to NULL 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma6" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			malloc_exit: 
917f			if DEBUG_FORTH_MALLOC_HIGH 
917f						DMARK "ma7" 
917f			call malloc_guard_exit 
917f			call malloc_guard_zerolen 
917f			endif 
917f			    ret 
917f			 
917f			; Internal Free Function: 
917f			; Input: 
917f			;   HL: Pointer to memory block to free 
917f			; Output: 
917f			;   None 
917f			 
917f			free_internal: 
917f			    ld de, (heap_start) ; Load start of heap into DE 
917f			    ld bc, 0            ; Initialize counter 
917f			 
917f			free_search_loop: 
917f			    ; Check if current block contains the pointer 
917f			    ld a, l             ; Load low byte of pointer 
917f			    cp (hl+1)           ; Compare with high byte of current block's address 
917f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
917f			    ld a, h             ; Load high byte of pointer 
917f			    cp (hl+2)           ; Compare with low byte of current block's address 
917f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
917f			 
917f			    ; Mark block as free 
917f			    ld (hl), 0          ; Set status byte to indicate free block 
917f			    ret                 ; Return 
917f			 
917f			free_skip_block_check: 
917f			    ; Move to the next block 
917f			    ld bc, 3            ; Size of management overhead 
917f			    add hl, bc          ; Move to the next block 
917f			    inc de              ; Increment counter 
917f			 
917f			    ; Check if we have reached the end of heap 
917f			    ld a, e             ; Load low byte of heap end address 
917f			    cp (hl)             ; Compare with low byte of current address 
917f			    jr nz, free_search_loop  ; If not equal, continue searching 
917f			    ld a, d             ; Load high byte of heap end address 
917f			    cp 0                ; Check if it's zero (end of memory) 
917f			    jr nz, free_search_loop  ; If not zero, continue searching 
917f			 
917f			    ; If we reached here, pointer is not found in heap 
917f			    ret 
917f			 
917f			free_exit: 
917f			    ret                 ; Return 
917f			 
917f			; Define heap start and end addresses 
917f			;heap_start:    .dw 0xC000   ; Start of heap 
917f			;heap_end:      .dw 0xE000   ; End of heap 
917f			 
917f			endif 
917f			 
917f			 
917f			if MALLOC_1 
917f			 
917f			 
917f			 
917f			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
917f			 
917f			;moved to firmware.asm 
917f			;heap_start        .equ  0x9000      ; Starting address of heap 
917f			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
917f			 
917f			;      .org 0 
917f			;      jp    main 
917f			 
917f			 
917f			;      .org  0x100 
917f			;main: 
917f			;      ld    HL, 0x8100 
917f			;      ld    SP, HL 
917f			; 
917f			;      call  heap_init 
917f			; 
917f			;      ; Make some allocations 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9004 
917f			; 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9014 
917f			; 
917f			;      ld    HL, 12 
917f			;      call  malloc            ; Allocates 0x9024 
917f			; 
917f			;      ; Free some allocations 
917f			;      ld    HL, 0x9014 
917f			;      call  free 
917f			; 
917f			;      ld    HL, 0x9004 
917f			;      call  free 
917f			; 
917f			;      ld    HL, 0x9024 
917f			;      call  free 
917f			; 
917f			; 
917f			;      halt 
917f			 
917f			 
917f			;------------------------------------------------------------------------------ 
917f			;     heap_init                                                               : 
917f			;                                                                             : 
917f			; Description                                                                 : 
917f			;     Initialise the heap and make it ready for malloc and free operations.   : 
917f			;                                                                             : 
917f			;     The heap is maintained as a linked list, starting with an initial       : 
917f			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
917f			;     the first free block in the heap. Each block then points to the next    : 
917f			;     free block within the heap, and the free list ends at the first block   : 
917f			;     with a null pointer to the next free block.                             : 
917f			;                                                                             : 
917f			; Parameters                                                                  : 
917f			;     Inputs are compile-time only. Two defines which specify the starting    : 
917f			;     address of the heap and its size are required, along with a memory      : 
917f			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
917f			;     principally stores a pointer to the first free block in the heap.       : 
917f			;                                                                             : 
917f			; Returns                                                                     : 
917f			;     Nothing                                                                 : 
917f			;------------------------------------------------------------------------------ 
917f			heap_init: 
917f e5			      push  HL 
9180			 
9180			      ; Initialise free list struct 
9180 21 3b e4		      ld    HL, heap_start 
9183 22 36 e4		      ld    (free_list), HL 
9186 21 00 00		      ld    HL, 0 
9189 22 38 e4		      ld    (free_list+2), HL 
918c			 
918c			      ; Insert first free block at bottom of heap, consumes entire heap 
918c 21 a4 e2		      ld    HL, heap_start+heap_size-4 
918f 22 3b e4		      ld    (heap_start), HL        ; Next block (end of free list) 
9192 21 69 fe		      ld    HL, heap_size-4 
9195 22 3d e4		      ld    (heap_start+2), HL      ; Block size 
9198			 
9198			      ; Insert end of free list block at top of heap - two null words will 
9198			      ; terminate the free list 
9198 21 00 00		      ld    HL, 0 
919b 22 a6 e2		      ld    (heap_start+heap_size-2), HL 
919e 22 a4 e2		      ld    (heap_start+heap_size-4), HL 
91a1			 
91a1 e1			      pop   HL 
91a2			 
91a2 c9			      ret 
91a3			 
91a3			 
91a3			;------------------------------------------------------------------------------ 
91a3			;     malloc                                                                  : 
91a3			;                                                                             : 
91a3			; Description                                                                 : 
91a3			;     Allocates the wanted space from the heap and returns the address of the : 
91a3			;     first useable byte of the allocation.                                   : 
91a3			;                                                                             : 
91a3			;     Allocations can happen in one of two ways:                              : 
91a3			;                                                                             : 
91a3			;     1. A free block may be found which is the exact size wanted. In this    : 
91a3			;        case the block is removed from the free list and retuedn to the      : 
91a3			;        caller.                                                              : 
91a3			;     2. A free block may be found which is larger than the size wanted. In   : 
91a3			;        this case, the larger block is split into two. The first portion of  : 
91a3			;        this block will become the requested space by the malloc call and    : 
91a3			;        is returned to the caller. The second portion becomes a new free     : 
91a3			;        block, and the free list is adjusted to maintain continuity via this : 
91a3			;        newly created block.                                                 : 
91a3			;                                                                             : 
91a3			;     malloc does not set any initial value in the allocated space, the       : 
91a3			;     caller is required to do this as required.                              : 
91a3			;                                                                             : 
91a3			;     This implementation of malloc uses the stack exclusively, and is        : 
91a3			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
91a3			;     advisable to disable interrupts before calling malloc, and recommended  : 
91a3			;     to avoid the use of malloc inside ISRs in general.                      : 
91a3			;                                                                             : 
91a3			;     NOTE: heap_init must be called before malloc and free can be used.      : 
91a3			;                                                                             : 
91a3			; Parameters                                                                  : 
91a3			;     HL  Number of bytes wanted                                              : 
91a3			;                                                                             : 
91a3			; Returns                                                                     : 
91a3			;     HL  Address of the first useable byte of the allocation                 : 
91a3			;                                                                             : 
91a3			; Flags                                                                       : 
91a3			;     Z   Set if the allocation did not succeed, clear otherwise              : 
91a3			;                                                                             : 
91a3			; Stack frame                                                                 : 
91a3			;       |             |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     BC      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     DE      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |     IX      |                                                       : 
91a3			;       +-------------+                                                       : 
91a3			;       |  prev_free  |                                                       : 
91a3			;   +4  +-------------+                                                       : 
91a3			;       |  this_free  |                                                       : 
91a3			;   +2  +-------------+                                                       : 
91a3			;       |  next_free  |                                                       : 
91a3			;   +0  +-------------+                                                       : 
91a3			;       |             |                                                       : 
91a3			;                                                                             : 
91a3			;------------------------------------------------------------------------------ 
91a3			 
91a3			 
91a3			;malloc: 
91a3			; 
91a3			;	SAVESP ON 1 
91a3			; 
91a3			;	call malloc_code 
91a3			; 
91a3			;	CHECKSP ON 1 
91a3			;	ret 
91a3			 
91a3			 
91a3			malloc: 
91a3 c5			      push  BC 
91a4 d5			      push  DE 
91a5 dd e5		      push  IX 
91a7			if DEBUG_FORTH_MALLOC_HIGH 
91a7			call malloc_guard_entry 
91a7			endif 
91a7			 
91a7					if DEBUG_FORTH_MALLOC 
91a7						DMARK "mal" 
91a7						CALLMONITOR 
91a7					endif 
91a7 7c			      ld    A, H                    ; Exit if no space requested 
91a8 b5			      or    L 
91a9 ca 68 92		      jp    Z, malloc_early_exit 
91ac			 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			; 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			;inc hl 
91ac			 
91ac			 
91ac			 
91ac			 
91ac					if DEBUG_FORTH_MALLOC 
91ac						DMARK "maA" 
91ac						CALLMONITOR 
91ac					endif 
91ac			      ; Set up stack frame 
91ac eb			      ex    DE, HL 
91ad 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
91b0 39			      add   HL, SP 
91b1 f9			      ld    SP, HL 
91b2 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
91b6 dd 39		      add   IX, SP 
91b8			 
91b8			      ; Setup initial state 
91b8 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
91bb 19			      add   HL, DE 
91bc			 
91bc 44			      ld    B, H                    ; Move want to BC 
91bd 4d			      ld    C, L 
91be			 
91be 21 36 e4		      ld    HL, free_list           ; Store prev_free ptr to stack 
91c1 dd 75 04		      ld    (IX+4), L 
91c4 dd 74 05		      ld    (IX+5), H 
91c7			 
91c7 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
91c8 23			      inc   HL 
91c9 56			      ld    D, (HL) 
91ca dd 73 02		      ld    (IX+2), E 
91cd dd 72 03		      ld    (IX+3), D 
91d0 eb			      ex    DE, HL                  ; this_free ptr into HL 
91d1			 
91d1					if DEBUG_FORTH_MALLOC 
91d1						DMARK "maB" 
91d1						CALLMONITOR 
91d1					endif 
91d1			      ; Loop through free block list to find some space 
91d1			malloc_find_space: 
91d1 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
91d2 23			      inc   HL 
91d3 56			      ld    D, (HL) 
91d4			 
91d4 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
91d5 b3			      or    E 
91d6 ca 62 92		      jp    Z, malloc_no_space 
91d9			 
91d9 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
91dc dd 72 01		      ld    (IX+1), D 
91df			 
91df			      ; Does this block have enough space to make the allocation? 
91df 23			      inc   HL                      ; Load free block size into DE 
91e0 5e			      ld    E, (HL) 
91e1 23			      inc   HL 
91e2 56			      ld    D, (HL) 
91e3			 
91e3 eb			      ex    DE, HL                  ; Check size of block against want 
91e4 b7			      or    A                       ; Ensure carry flag clear 
91e5 ed 42		      sbc   HL, BC 
91e7 e5			      push  HL                      ; Store the result for later (new block size) 
91e8			 
91e8 ca 37 92		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
91eb 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
91ed			 
91ed			      ; this_free block is not big enough, setup ptrs to test next free block 
91ed e1			      pop   HL                      ; Discard previous result 
91ee			 
91ee dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
91f1 dd 66 03		      ld    H, (IX+3) 
91f4 dd 75 04		      ld    (IX+4), L 
91f7 dd 74 05		      ld    (IX+5), H 
91fa			 
91fa dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
91fd dd 66 01		      ld    H, (IX+1) 
9200 dd 75 02		      ld    (IX+2), L 
9203 dd 74 03		      ld    (IX+3), H 
9206			 
9206					if DEBUG_FORTH_MALLOC 
9206						DMARK "MA>" 
9206						CALLMONITOR 
9206					endif 
9206 18 c9		      jr    malloc_find_space 
9208			 
9208			      ; split a bigger block into two - requested size and remaining size 
9208			malloc_alloc_split: 
9208					if DEBUG_FORTH_MALLOC 
9208						DMARK "MAs" 
9208						CALLMONITOR 
9208					endif 
9208 eb			      ex    DE, HL                  ; Calculate address of new free block 
9209 2b			      dec   HL 
920a 2b			      dec   HL 
920b 2b			      dec   HL 
920c 09			      add   HL, BC 
920d			 
920d			      ; Create a new block and point it at next_free 
920d dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
9210 dd 56 01		      ld    D, (IX+1) 
9213			 
9213 73			      ld    (HL), E                 ; Store next_free ptr into new block 
9214 23			      inc   HL 
9215 72			      ld    (HL), D 
9216			 
9216 d1			      pop   DE                      ; Store size of new block into new block 
9217 23			      inc   HL 
9218 73			      ld    (HL), E 
9219 23			      inc   HL 
921a 72			      ld    (HL), D 
921b			 
921b			      ; Update this_free ptr to point to new block 
921b 2b			      dec   HL 
921c 2b			      dec   HL 
921d 2b			      dec   HL 
921e			 
921e dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9221 dd 56 03		      ld    D, (IX+3) 
9224			 
9224 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9227 dd 74 03		      ld    (IX+3), H 
922a			 
922a			      ; Modify this_free block to be allocation 
922a eb			      ex    DE, HL 
922b af			      xor   A                       ; Null the next block ptr of allocated block 
922c 77			      ld    (HL), A 
922d 23			      inc   HL 
922e 77			      ld    (HL), A 
922f			 
922f 23			      inc   HL                      ; Store want size into allocated block 
9230 71			      ld    (HL), C 
9231 23			      inc   HL 
9232 70			      ld    (HL), B 
9233 23			      inc   HL 
9234 e5			      push  HL                      ; Address of allocation to return 
9235			 
9235 18 19		      jr    malloc_update_links 
9237			 
9237			malloc_alloc_fit: 
9237 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9238			 
9238					if DEBUG_FORTH_MALLOC 
9238						DMARK "MAf" 
9238						CALLMONITOR 
9238					endif 
9238			      ; Modify this_free block to be allocation 
9238 eb			      ex    DE, HL 
9239 2b			      dec   HL 
923a 2b			      dec   HL 
923b 2b			      dec   HL 
923c			 
923c af			      xor   A                       ; Null the next block ptr of allocated block 
923d 77			      ld    (HL), A 
923e 23			      inc   HL 
923f 77			      ld    (HL), A 
9240			 
9240 23			      inc   HL                      ; Store address of allocation to return 
9241 23			      inc   HL 
9242 23			      inc   HL 
9243 e5			      push  HL 
9244			 
9244			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9244 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9247 dd 66 01		      ld    H, (IX+1) 
924a			 
924a dd 75 02		      ld    (IX+2), L               ; HL to this_free 
924d dd 74 03		      ld    (IX+3), H 
9250			 
9250			 
9250			malloc_update_links: 
9250			      ; Update prev_free ptr to point to this_free 
9250 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9253 dd 66 05		      ld    H, (IX+5) 
9256			 
9256 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9259 dd 56 03		      ld    D, (IX+3) 
925c			 
925c 73			      ld    (HL), E                 ; this_free ptr into prev_free 
925d 23			      inc   HL 
925e 72			      ld    (HL), D 
925f			 
925f					if DEBUG_FORTH_MALLOC 
925f						DMARK "Mul" 
925f						CALLMONITOR 
925f					endif 
925f			      ; Clear the Z flag to indicate successful allocation 
925f 7a			      ld    A, D 
9260 b3			      or    E 
9261			 
9261 d1			      pop   DE                      ; Address of allocation 
9262					if DEBUG_FORTH_MALLOC 
9262						DMARK "MAu" 
9262						CALLMONITOR 
9262					endif 
9262			 
9262			malloc_no_space: 
9262 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9265 39			      add   HL, SP 
9266 f9			      ld    SP, HL 
9267			 
9267 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9268					if DEBUG_FORTH_MALLOC 
9268						DMARK "MAN" 
9268						CALLMONITOR 
9268					endif 
9268			 
9268			malloc_early_exit: 
9268					if DEBUG_FORTH_MALLOC 
9268						DMARK "MAx" 
9268						CALLMONITOR 
9268					endif 
9268 dd e1		      pop   IX 
926a d1			      pop   DE 
926b c1			      pop   BC 
926c			 
926c			if DEBUG_FORTH_MALLOC_HIGH 
926c			call malloc_guard_exit 
926c			call malloc_guard_zerolen 
926c			endif 
926c c9			      ret 
926d			 
926d			 
926d			;------------------------------------------------------------------------------ 
926d			;     free                                                                    : 
926d			;                                                                             : 
926d			; Description                                                                 : 
926d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
926d			;     returned by malloc, otherwise the behaviour is undefined.               : 
926d			;                                                                             : 
926d			;     Where possible, directly adjacent free blocks will be merged together   : 
926d			;     into larger blocks to help ensure that the heap does not become         : 
926d			;     excessively fragmented.                                                 : 
926d			;                                                                             : 
926d			;     free does not clear or set any other value into the freed space, and    : 
926d			;     therefore its contents may be visible through subsequent malloc's. The  : 
926d			;     caller should clear the freed space as required.                        : 
926d			;                                                                             : 
926d			;     This implementation of free uses the stack exclusively, and is          : 
926d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
926d			;     advisable to disable interrupts before calling free, and recommended    : 
926d			;     to avoid the use of free inside ISRs in general.                        : 
926d			;                                                                             : 
926d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
926d			;                                                                             : 
926d			; Parameters                                                                  : 
926d			;     HL  Pointer to address of first byte of allocation to be freed          : 
926d			;                                                                             : 
926d			; Returns                                                                     : 
926d			;     Nothing                                                                 : 
926d			;                                                                             : 
926d			; Stack frame                                                                 : 
926d			;       |             |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     BC      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     DE      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |     IX      |                                                       : 
926d			;       +-------------+                                                       : 
926d			;       |  prev_free  |                                                       : 
926d			;   +2  +-------------+                                                       : 
926d			;       |  next_free  |                                                       : 
926d			;   +0  +-------------+                                                       : 
926d			;       |             |                                                       : 
926d			;                                                                             : 
926d			;------------------------------------------------------------------------------ 
926d			free: 
926d c5			      push  BC 
926e d5			      push  DE 
926f dd e5		      push  IX 
9271			 
9271 7c			      ld    A, H                    ; Exit if ptr is null 
9272 b5			      or    L 
9273 ca 37 93		      jp    Z, free_early_exit 
9276			 
9276			      ; Set up stack frame 
9276 eb			      ex    DE, HL 
9277 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
927a 39			      add   HL, SP 
927b f9			      ld    SP, HL 
927c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9280 dd 39		      add   IX, SP 
9282			 
9282			      ; The address in HL points to the start of the useable allocated space, 
9282			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9282			      ; address of the block itself. 
9282 eb			      ex    DE, HL 
9283 11 fc ff		      ld    DE, -4 
9286 19			      add   HL, DE 
9287			 
9287			      ; An allocated block must have a null next block pointer in it 
9287 7e			      ld    A, (HL) 
9288 23			      inc   HL 
9289 b6			      or    (HL) 
928a c2 32 93		      jp    NZ, free_done 
928d			 
928d 2b			      dec   HL 
928e			 
928e 44			      ld    B, H                    ; Copy HL to BC 
928f 4d			      ld    C, L 
9290			 
9290			      ; Loop through the free list to find the first block with an address 
9290			      ; higher than the block being freed 
9290 21 36 e4		      ld    HL, free_list 
9293			 
9293			free_find_higher_block: 
9293 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9294 23			      inc   HL 
9295 56			      ld    D, (HL) 
9296 2b			      dec   HL 
9297			 
9297 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
929a dd 72 01		      ld    (IX+1), D 
929d dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
92a0 dd 74 03		      ld    (IX+3), H 
92a3			 
92a3 78			      ld    A, B                    ; Check if DE is greater than BC 
92a4 ba			      cp    D                       ; Compare MSB first 
92a5 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
92a7 30 04		      jr    NC, free_find_higher_block_skip 
92a9 79			      ld    A, C 
92aa bb			      cp    E                       ; Then compare LSB 
92ab 38 08		      jr    C, free_found_higher_block 
92ad			 
92ad			free_find_higher_block_skip: 
92ad 7a			      ld    A, D                    ; Reached the end of the free list? 
92ae b3			      or    E 
92af ca 32 93		      jp    Z, free_done 
92b2			 
92b2 eb			      ex    DE, HL 
92b3			 
92b3 18 de		      jr    free_find_higher_block 
92b5			 
92b5			free_found_higher_block: 
92b5			      ; Insert freed block between prev and next free blocks 
92b5 71			      ld    (HL), C                 ; Point prev free block to freed block 
92b6 23			      inc   HL 
92b7 70			      ld    (HL), B 
92b8			 
92b8 60			      ld    H, B                    ; Point freed block at next free block 
92b9 69			      ld    L, C 
92ba 73			      ld    (HL), E 
92bb 23			      inc   HL 
92bc 72			      ld    (HL), D 
92bd			 
92bd			      ; Check if the freed block is adjacent to the next free block 
92bd 23			      inc   HL                      ; Load size of freed block into HL 
92be 5e			      ld    E, (HL) 
92bf 23			      inc   HL 
92c0 56			      ld    D, (HL) 
92c1 eb			      ex    DE, HL 
92c2			 
92c2 09			      add   HL, BC                  ; Add addr of freed block and its size 
92c3			 
92c3 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
92c6 dd 56 01		      ld    D, (IX+1) 
92c9			 
92c9 b7			      or    A                       ; Clear the carry flag 
92ca ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
92cc 20 22		      jr    NZ, free_check_adjacent_to_prev 
92ce			 
92ce			      ; Freed block is adjacent to next, merge into one bigger block 
92ce eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
92cf 5e			      ld    E, (HL) 
92d0 23			      inc   HL 
92d1 56			      ld    D, (HL) 
92d2 e5			      push  HL                      ; Save ptr to next block for later 
92d3			 
92d3 60			      ld    H, B                    ; Store ptr from next block into freed block 
92d4 69			      ld    L, C 
92d5 73			      ld    (HL), E 
92d6 23			      inc   HL 
92d7 72			      ld    (HL), D 
92d8			 
92d8 e1			      pop   HL                      ; Restore ptr to next block 
92d9 23			      inc   HL                      ; Load size of next block into DE 
92da 5e			      ld    E, (HL) 
92db 23			      inc   HL 
92dc 56			      ld    D, (HL) 
92dd d5			      push  DE                      ; Save next block size for later 
92de			 
92de 60			      ld    H, B                    ; Load size of freed block into HL 
92df 69			      ld    L, C 
92e0 23			      inc   HL 
92e1 23			      inc   HL 
92e2 5e			      ld    E, (HL) 
92e3 23			      inc   HL 
92e4 56			      ld    D, (HL) 
92e5 eb			      ex    DE, HL 
92e6			 
92e6 d1			      pop   DE                      ; Restore size of next block 
92e7 19			      add   HL, DE                  ; Add sizes of both blocks 
92e8 eb			      ex    DE, HL 
92e9			 
92e9 60			      ld    H, B                    ; Store new bigger size into freed block 
92ea 69			      ld    L, C 
92eb 23			      inc   HL 
92ec 23			      inc   HL 
92ed 73			      ld    (HL), E 
92ee 23			      inc   HL 
92ef 72			      ld    (HL), D 
92f0			 
92f0			free_check_adjacent_to_prev: 
92f0			      ; Check if the freed block is adjacent to the prev free block 
92f0 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
92f3 dd 66 03		      ld    H, (IX+3) 
92f6			 
92f6 23			      inc   HL                      ; Size of prev free block into DE 
92f7 23			      inc   HL 
92f8 5e			      ld    E, (HL) 
92f9 23			      inc   HL 
92fa 56			      ld    D, (HL) 
92fb 2b			      dec   HL 
92fc 2b			      dec   HL 
92fd 2b			      dec   HL 
92fe			 
92fe 19			      add   HL, DE                  ; Add prev block addr and size 
92ff			 
92ff b7			      or    A                       ; Clear the carry flag 
9300 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9302 20 2e		      jr    NZ, free_done 
9304			 
9304			      ; Freed block is adjacent to prev, merge into one bigger block 
9304 60			      ld    H, B                    ; Load next ptr from freed block into DE 
9305 69			      ld    L, C 
9306 5e			      ld    E, (HL) 
9307 23			      inc   HL 
9308 56			      ld    D, (HL) 
9309 e5			      push  HL                      ; Save freed block ptr for later 
930a			 
930a dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
930d dd 66 03		      ld    H, (IX+3) 
9310 73			      ld    (HL), E 
9311 23			      inc   HL 
9312 72			      ld    (HL), D 
9313			 
9313 e1			      pop   HL                      ; Restore freed block ptr 
9314 23			      inc   HL                      ; Load size of freed block into DE 
9315 5e			      ld    E, (HL) 
9316 23			      inc   HL 
9317 56			      ld    D, (HL) 
9318 d5			      push  DE                      ; Save freed block size for later 
9319			 
9319 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
931c dd 66 03		      ld    H, (IX+3) 
931f 23			      inc   HL 
9320 23			      inc   HL 
9321 5e			      ld    E, (HL) 
9322 23			      inc   HL 
9323 56			      ld    D, (HL) 
9324			 
9324 e1			      pop   HL                      ; Add sizes of both blocks 
9325 19			      add   HL, DE 
9326 eb			      ex    DE, HL 
9327			 
9327 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
932a dd 66 03		      ld    H, (IX+3) 
932d 23			      inc   HL 
932e 23			      inc   HL 
932f 73			      ld    (HL), E 
9330 23			      inc   HL 
9331 72			      ld    (HL), D 
9332			 
9332			free_done: 
9332 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9335 39			      add   HL, SP 
9336 f9			      ld    SP, HL 
9337			 
9337			free_early_exit: 
9337 dd e1		      pop   IX 
9339 d1			      pop   DE 
933a c1			      pop   BC 
933b			 
933b c9			      ret 
933c			 
933c			; moved to firmware.asm 
933c			; 
933c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
933c			;                  .dw   0 
933c			 
933c			 
933c			endif 
933c			 
933c			 
933c			if MALLOC_3 
933c			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
933c			;heap_start        .equ  0x9000      ; Starting address of heap 
933c			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
933c			; 
933c			 ;     .org 0 
933c			  ;    jp    main 
933c			; 
933c			; 
933c			 ;     .org  0x100 
933c			;main: 
933c			 ;     ld    HL, 0x8100 
933c			  ;    ld    SP, HL 
933c			; 
933c			;      call  heap_init 
933c			 
933c			      ; Make some allocations 
933c			;      ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9004 
933c			; 
933c			 ;     ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9014 
933c			 
933c			;      ld    HL, 12 
933c			;      call  malloc            ; Allocates 0x9024 
933c			 
933c			      ; Free some allocations 
933c			;      ld    HL, 0x9014 
933c			;      call  free 
933c			 
933c			;      ld    HL, 0x9004 
933c			;      call  free 
933c			; 
933c			;      ld    HL, 0x9024 
933c			;      call  free 
933c			 
933c			 
933c			 ;     halt 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     heap_init                                                               : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Initialise the heap and make it ready for malloc and free operations.   : 
933c			;                                                                             : 
933c			;     The heap is maintained as a linked list, starting with an initial       : 
933c			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
933c			;     the first free block in the heap. Each block then points to the next    : 
933c			;     free block within the heap, and the free list ends at the first block   : 
933c			;     with a null pointer to the next free block.                             : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     Inputs are compile-time only. Two defines which specify the starting    : 
933c			;     address of the heap and its size are required, along with a memory      : 
933c			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
933c			;     principally stores a pointer to the first free block in the heap.       : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     Nothing                                                                 : 
933c			;------------------------------------------------------------------------------ 
933c			heap_init: 
933c			      push  HL 
933c			 
933c			      ; Initialise free list struct 
933c			      ld    HL, heap_start 
933c			      ld    (free_list), HL 
933c			      ld    HL, 0 
933c			      ld    (free_list+2), HL 
933c			 
933c			      ; Insert first free block at bottom of heap, consumes entire heap 
933c			      ld    HL, heap_start+heap_size-4 
933c			      ld    (heap_start), HL        ; Next block (end of free list) 
933c			      ld    HL, heap_size-4 
933c			      ld    (heap_start+2), HL      ; Block size 
933c			 
933c			      ; Insert end of free list block at top of heap - two null words will 
933c			      ; terminate the free list 
933c			      ld    HL, 0 
933c			      ld    (heap_start+heap_size-2), HL 
933c			      ld    (heap_start+heap_size-4), HL 
933c			 
933c			      pop   HL 
933c			 
933c			      ret 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     malloc                                                                  : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Allocates the wanted space from the heap and returns the address of the : 
933c			;     first useable byte of the allocation.                                   : 
933c			;                                                                             : 
933c			;     Allocations can happen in one of two ways:                              : 
933c			;                                                                             : 
933c			;     1. A free block may be found which is the exact size wanted. In this    : 
933c			;        case the block is removed from the free list and retuedn to the      : 
933c			;        caller.                                                              : 
933c			;     2. A free block may be found which is larger than the size wanted. In   : 
933c			;        this case, the larger block is split into two. The first portion of  : 
933c			;        this block will become the requested space by the malloc call and    : 
933c			;        is returned to the caller. The second portion becomes a new free     : 
933c			;        block, and the free list is adjusted to maintain continuity via this : 
933c			;        newly created block.                                                 : 
933c			;                                                                             : 
933c			;     malloc does not set any initial value in the allocated space, the       : 
933c			;     caller is required to do this as required.                              : 
933c			;                                                                             : 
933c			;     This implementation of malloc uses the stack exclusively, and is        : 
933c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
933c			;     advisable to disable interrupts before calling malloc, and recommended  : 
933c			;     to avoid the use of malloc inside ISRs in general.                      : 
933c			;                                                                             : 
933c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     HL  Number of bytes wanted                                              : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     HL  Address of the first useable byte of the allocation                 : 
933c			;                                                                             : 
933c			; Flags                                                                       : 
933c			;     Z   Set if the allocation did not succeed, clear otherwise              : 
933c			;                                                                             : 
933c			; Stack frame                                                                 : 
933c			;       |             |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     BC      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     DE      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     IX      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |  prev_free  |                                                       : 
933c			;   +4  +-------------+                                                       : 
933c			;       |  this_free  |                                                       : 
933c			;   +2  +-------------+                                                       : 
933c			;       |  next_free  |                                                       : 
933c			;   +0  +-------------+                                                       : 
933c			;       |             |                                                       : 
933c			;                                                                             : 
933c			;------------------------------------------------------------------------------ 
933c			malloc: 
933c			      push  BC 
933c			      push  DE 
933c			      push  IX 
933c			 
933c			      ld    A, H                    ; Exit if no space requested 
933c			      or    L 
933c			      jp    Z, malloc_early_exit 
933c			 
933c			      ; Set up stack frame 
933c			      ex    DE, HL 
933c			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			      ld    IX, 0                   ; Use IX as a frame pointer 
933c			      add   IX, SP 
933c			 
933c			      ; Setup initial state 
933c			      ld    HL, 4                   ; want must also include space used by block struct 
933c			      add   HL, DE 
933c			 
933c			      ld    B, H                    ; Move want to BC 
933c			      ld    C, L 
933c			 
933c			      ld    HL, free_list           ; Store prev_free ptr to stack 
933c			      ld    (IX+4), L 
933c			      ld    (IX+5), H 
933c			 
933c			      ld    E, (HL)                 ; Store this_free ptr to stack 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ld    (IX+2), E 
933c			      ld    (IX+3), D 
933c			      ex    DE, HL                  ; this_free ptr into HL 
933c			 
933c			      ; Loop through free block list to find some space 
933c			malloc_find_space: 
933c			      ld    E, (HL)                 ; Load next_free ptr into DE 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      ld    A, D                    ; Check for null next_free ptr - end of free list 
933c			      or    E 
933c			      jp    Z, malloc_no_space 
933c			 
933c			      ld    (IX+0), E               ; Store next_free ptr to stack 
933c			      ld    (IX+1), D 
933c			 
933c			      ; Does this block have enough space to make the allocation? 
933c			      inc   HL                      ; Load free block size into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      ex    DE, HL                  ; Check size of block against want 
933c			      or    A                       ; Ensure carry flag clear 
933c			      sbc   HL, BC 
933c			      push  HL                      ; Store the result for later (new block size) 
933c			 
933c			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
933c			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
933c			 
933c			      ; this_free block is not big enough, setup ptrs to test next free block 
933c			      pop   HL                      ; Discard previous result 
933c			 
933c			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
933c			      ld    H, (IX+3) 
933c			      ld    (IX+4), L 
933c			      ld    (IX+5), H 
933c			 
933c			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
933c			      ld    H, (IX+1) 
933c			      ld    (IX+2), L 
933c			      ld    (IX+3), H 
933c			 
933c			      jr    malloc_find_space 
933c			 
933c			      ; split a bigger block into two - requested size and remaining size 
933c			malloc_alloc_split: 
933c			      ex    DE, HL                  ; Calculate address of new free block 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			      add   HL, BC 
933c			 
933c			      ; Create a new block and point it at next_free 
933c			      ld    E, (IX+0)               ; Load next_free ptr into DE 
933c			      ld    D, (IX+1) 
933c			 
933c			      ld    (HL), E                 ; Store next_free ptr into new block 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   DE                      ; Store size of new block into new block 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Update this_free ptr to point to new block 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
933c			      ld    D, (IX+3) 
933c			 
933c			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
933c			      ld    (IX+3), H 
933c			 
933c			      ; Modify this_free block to be allocation 
933c			      ex    DE, HL 
933c			      xor   A                       ; Null the next block ptr of allocated block 
933c			      ld    (HL), A 
933c			      inc   HL 
933c			      ld    (HL), A 
933c			 
933c			      inc   HL                      ; Store want size into allocated block 
933c			      ld    (HL), C 
933c			      inc   HL 
933c			      ld    (HL), B 
933c			      inc   HL 
933c			      push  HL                      ; Address of allocation to return 
933c			 
933c			      jr    malloc_update_links 
933c			 
933c			malloc_alloc_fit: 
933c			      pop   HL                      ; Dont need new block size, want is exact fit 
933c			 
933c			      ; Modify this_free block to be allocation 
933c			      ex    DE, HL 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      xor   A                       ; Null the next block ptr of allocated block 
933c			      ld    (HL), A 
933c			      inc   HL 
933c			      ld    (HL), A 
933c			 
933c			      inc   HL                      ; Store address of allocation to return 
933c			      inc   HL 
933c			      inc   HL 
933c			      push  HL 
933c			 
933c			      ; Copy next_free ptr to this_free, remove allocated block from free list 
933c			      ld    L, (IX+0)               ; next_free to HL 
933c			      ld    H, (IX+1) 
933c			 
933c			      ld    (IX+2), L               ; HL to this_free 
933c			      ld    (IX+3), H 
933c			 
933c			 
933c			malloc_update_links: 
933c			      ; Update prev_free ptr to point to this_free 
933c			      ld    L, (IX+4)               ; prev_free ptr to HL 
933c			      ld    H, (IX+5) 
933c			 
933c			      ld    E, (IX+2)               ; this_free ptr to DE 
933c			      ld    D, (IX+3) 
933c			 
933c			      ld    (HL), E                 ; this_free ptr into prev_free 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Clear the Z flag to indicate successful allocation 
933c			      ld    A, D 
933c			      or    E 
933c			 
933c			      pop   DE                      ; Address of allocation 
933c			 
933c			malloc_no_space: 
933c			      ld    HL, 6                   ; Clean up stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			 
933c			      ex    DE, HL                  ; Alloc addr into HL for return 
933c			 
933c			malloc_early_exit: 
933c			      pop   IX 
933c			      pop   DE 
933c			      pop   BC 
933c			 
933c			      ret 
933c			 
933c			 
933c			;------------------------------------------------------------------------------ 
933c			;     free                                                                    : 
933c			;                                                                             : 
933c			; Description                                                                 : 
933c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
933c			;     returned by malloc, otherwise the behaviour is undefined.               : 
933c			;                                                                             : 
933c			;     Where possible, directly adjacent free blocks will be merged together   : 
933c			;     into larger blocks to help ensure that the heap does not become         : 
933c			;     excessively fragmented.                                                 : 
933c			;                                                                             : 
933c			;     free does not clear or set any other value into the freed space, and    : 
933c			;     therefore its contents may be visible through subsequent malloc's. The  : 
933c			;     caller should clear the freed space as required.                        : 
933c			;                                                                             : 
933c			;     This implementation of free uses the stack exclusively, and is          : 
933c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
933c			;     advisable to disable interrupts before calling free, and recommended    : 
933c			;     to avoid the use of free inside ISRs in general.                        : 
933c			;                                                                             : 
933c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
933c			;                                                                             : 
933c			; Parameters                                                                  : 
933c			;     HL  Pointer to address of first byte of allocation to be freed          : 
933c			;                                                                             : 
933c			; Returns                                                                     : 
933c			;     Nothing                                                                 : 
933c			;                                                                             : 
933c			; Stack frame                                                                 : 
933c			;       |             |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     BC      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     DE      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |     IX      |                                                       : 
933c			;       +-------------+                                                       : 
933c			;       |  prev_free  |                                                       : 
933c			;   +2  +-------------+                                                       : 
933c			;       |  next_free  |                                                       : 
933c			;   +0  +-------------+                                                       : 
933c			;       |             |                                                       : 
933c			;                                                                             : 
933c			;------------------------------------------------------------------------------ 
933c			free: 
933c			      push  BC 
933c			      push  DE 
933c			      push  IX 
933c			 
933c			      ld    A, H                    ; Exit if ptr is null 
933c			      or    L 
933c			      jp    Z, free_early_exit 
933c			 
933c			      ; Set up stack frame 
933c			      ex    DE, HL 
933c			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			      ld    IX, 0                   ; Use IX as a frame pointer 
933c			      add   IX, SP 
933c			 
933c			      ; The address in HL points to the start of the useable allocated space, 
933c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
933c			      ; address of the block itself. 
933c			      ex    DE, HL 
933c			      ld    DE, -4 
933c			      add   HL, DE 
933c			 
933c			      ; An allocated block must have a null next block pointer in it 
933c			      ld    A, (HL) 
933c			      inc   HL 
933c			      or    (HL) 
933c			      jp    NZ, free_done 
933c			 
933c			      dec   HL 
933c			 
933c			      ld    B, H                    ; Copy HL to BC 
933c			      ld    C, L 
933c			 
933c			      ; Loop through the free list to find the first block with an address 
933c			      ; higher than the block being freed 
933c			      ld    HL, free_list 
933c			 
933c			free_find_higher_block: 
933c			      ld    E, (HL)                 ; Load next ptr from free block 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      dec   HL 
933c			 
933c			      ld    (IX+0), E               ; Save ptr to next free block 
933c			      ld    (IX+1), D 
933c			      ld    (IX+2), L               ; Save ptr to prev free block 
933c			      ld    (IX+3), H 
933c			 
933c			      ld    A, B                    ; Check if DE is greater than BC 
933c			      cp    D                       ; Compare MSB first 
933c			      jr    Z, $+4                  ; MSB the same, compare LSB 
933c			      jr    NC, free_find_higher_block_skip 
933c			      ld    A, C 
933c			      cp    E                       ; Then compare LSB 
933c			      jr    C, free_found_higher_block 
933c			 
933c			free_find_higher_block_skip: 
933c			      ld    A, D                    ; Reached the end of the free list? 
933c			      or    E 
933c			      jp    Z, free_done 
933c			 
933c			      ex    DE, HL 
933c			 
933c			      jr    free_find_higher_block 
933c			 
933c			free_found_higher_block: 
933c			      ; Insert freed block between prev and next free blocks 
933c			      ld    (HL), C                 ; Point prev free block to freed block 
933c			      inc   HL 
933c			      ld    (HL), B 
933c			 
933c			      ld    H, B                    ; Point freed block at next free block 
933c			      ld    L, C 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      ; Check if the freed block is adjacent to the next free block 
933c			      inc   HL                      ; Load size of freed block into HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ex    DE, HL 
933c			 
933c			      add   HL, BC                  ; Add addr of freed block and its size 
933c			 
933c			      ld    E, (IX+0)               ; Load addr of next free block into DE 
933c			      ld    D, (IX+1) 
933c			 
933c			      or    A                       ; Clear the carry flag 
933c			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
933c			      jr    NZ, free_check_adjacent_to_prev 
933c			 
933c			      ; Freed block is adjacent to next, merge into one bigger block 
933c			      ex    DE, HL                  ; Load next ptr from next block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  HL                      ; Save ptr to next block for later 
933c			 
933c			      ld    H, B                    ; Store ptr from next block into freed block 
933c			      ld    L, C 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   HL                      ; Restore ptr to next block 
933c			      inc   HL                      ; Load size of next block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  DE                      ; Save next block size for later 
933c			 
933c			      ld    H, B                    ; Load size of freed block into HL 
933c			      ld    L, C 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      ex    DE, HL 
933c			 
933c			      pop   DE                      ; Restore size of next block 
933c			      add   HL, DE                  ; Add sizes of both blocks 
933c			      ex    DE, HL 
933c			 
933c			      ld    H, B                    ; Store new bigger size into freed block 
933c			      ld    L, C 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			free_check_adjacent_to_prev: 
933c			      ; Check if the freed block is adjacent to the prev free block 
933c			      ld    L, (IX+2)               ; Prev free block ptr into HL 
933c			      ld    H, (IX+3) 
933c			 
933c			      inc   HL                      ; Size of prev free block into DE 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      dec   HL 
933c			      dec   HL 
933c			      dec   HL 
933c			 
933c			      add   HL, DE                  ; Add prev block addr and size 
933c			 
933c			      or    A                       ; Clear the carry flag 
933c			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
933c			      jr    NZ, free_done 
933c			 
933c			      ; Freed block is adjacent to prev, merge into one bigger block 
933c			      ld    H, B                    ; Load next ptr from freed block into DE 
933c			      ld    L, C 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  HL                      ; Save freed block ptr for later 
933c			 
933c			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
933c			      ld    H, (IX+3) 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			      pop   HL                      ; Restore freed block ptr 
933c			      inc   HL                      ; Load size of freed block into DE 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			      push  DE                      ; Save freed block size for later 
933c			 
933c			      ld    L, (IX+2)               ; Load size of prev block into DE 
933c			      ld    H, (IX+3) 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    E, (HL) 
933c			      inc   HL 
933c			      ld    D, (HL) 
933c			 
933c			      pop   HL                      ; Add sizes of both blocks 
933c			      add   HL, DE 
933c			      ex    DE, HL 
933c			 
933c			      ld    L, (IX+2)               ; Store new bigger size into prev block 
933c			      ld    H, (IX+3) 
933c			      inc   HL 
933c			      inc   HL 
933c			      ld    (HL), E 
933c			      inc   HL 
933c			      ld    (HL), D 
933c			 
933c			free_done: 
933c			      ld    HL, 4                   ; Clean up stack frame 
933c			      add   HL, SP 
933c			      ld    SP, HL 
933c			 
933c			free_early_exit: 
933c			      pop   IX 
933c			      pop   DE 
933c			      pop   BC 
933c			 
933c			      ret 
933c			 
933c			 
933c			;      .org 0x8000 
933c			; 
933c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
933c			 ;                 .dw   0 
933c			 
933c			endif 
933c			 
933c			 
933c			if MALLOC_4 
933c			 
933c			; My memory allocation code. Very very simple.... 
933c			; allocate space under 250 chars 
933c			 
933c			heap_init: 
933c				; init start of heap as zero 
933c				;  
933c			 
933c				ld hl, heap_start 
933c				ld a, 0 
933c				ld (hl), a      ; empty block 
933c				inc hl 
933c				ld a, 0 
933c				ld (hl), a      ; length of block 
933c				; write end of list 
933c				inc hl 
933c				ld a,(hl) 
933c				inc hl 
933c				ld a,(hl) 
933c				 
933c			 
933c				; init some malloc vars 
933c			 
933c				ld hl, 0 
933c				ld (free_list), hl       ; store last malloc location 
933c			 
933c				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
933c				ld a, 0 
933c				ld (hl), a 
933c			 
933c			 
933c				ld hl, heap_start 
933c				;  
933c				  
933c				ret 
933c			 
933c			 
933c			;    free block marker 
933c			;    requested size  
933c			;    pointer to next block 
933c			;    .... 
933c			;    next block marker 
933c			 
933c			 
933c			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
933c			; 
933c			 
933c			 
933c			malloc:  
933c				push de 
933c				push bc 
933c				push af 
933c			 
933c				; hl space required 
933c				 
933c				ld c, l    ; hold space   (TODO only a max of 255) 
933c			 
933c			;	inc c     ; TODO BUG need to fix memory leak on push str 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			;	inc c 
933c			 
933c			 
933c			 
933c				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
933c			 
933c				ld a, (free_list+3) 
933c				cp 0 
933c				jr z, .contheap 
933c			 
933c				ld hl, (free_list)     ; get last alloc 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mrs" 
933c						CALLMONITOR 
933c					endif 
933c				jr .startalloc 
933c			 
933c			.contheap: 
933c				ld hl, heap_start 
933c			 
933c			.startalloc: 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mym" 
933c						CALLMONITOR 
933c					endif 
933c			.findblock: 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mmf" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c				ld a,(hl)  
933c				; if byte is zero then clear to use 
933c			 
933c				cp 0 
933c				jr z, .foundemptyblock 
933c			 
933c				; if byte is not clear 
933c				;     then byte is offset to next block 
933c			 
933c				inc hl 
933c				ld a, (hl) ; get size 
933c			.nextblock:	inc hl 
933c					ld e, (hl) 
933c					inc hl 
933c					ld d, (hl) 
933c					ex de, hl 
933c			;	inc hl  ; move past the store space 
933c			;	inc hl  ; move past zero index  
933c			 
933c				; TODO detect no more space 
933c			 
933c				push hl 
933c				ld de, heap_end 
933c				call cmp16 
933c				pop hl 
933c				jr nc, .nospace 
933c			 
933c				jr .findblock 
933c			 
933c			.nospace: ld hl, 0 
933c				jp .exit 
933c			 
933c			 
933c			.foundemptyblock:	 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mme" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			; TODO has block enough space if reusing??? 
933c			 
933c				;  
933c			 
933c			; see if this block has been previously used 
933c				inc hl 
933c				ld a, (hl) 
933c				dec hl 
933c				cp 0 
933c				jr z, .newblock 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "meR" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			; no reusing previously allocated block 
933c			 
933c			; is it smaller than previously used? 
933c				 
933c				inc hl    ; move to size 
933c				ld a, c 
933c				sub (hl)        ; we want c < (hl) 
933c				dec hl    ; move back to marker 
933c			        jr z, .findblock 
933c			 
933c				; update with the new size which should be lower 
933c			 
933c			        ;inc  hl   ; negate next move. move back to size  
933c			 
933c			.newblock: 
933c				; need to be at marker here 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "meN" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			 
933c				ld a, c 
933c			 
933c				ld (free_list+3), a	 ; flag resume from last malloc  
933c				ld (free_list), hl    ; save out last location 
933c			 
933c			 
933c				;inc a     ; space for length byte 
933c				ld (hl), a     ; save block in use marker 
933c			 
933c				inc hl   ; move to space marker 
933c				ld (hl), a    ; save new space 
933c			 
933c				inc hl   ; move to start of allocated area 
933c				 
933c			;	push hl     ; save where we are - 1  
933c			 
933c			;	inc hl  ; move past zero index  
933c				; skip space to set down new marker 
933c			 
933c				; provide some extra space for now 
933c			 
933c				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
933c				inc a 
933c				inc a 
933c			 
933c				push hl   ; save where we are in the node block 
933c			 
933c				call addatohl 
933c			 
933c				; write linked list point 
933c			 
933c				pop de     ; get our node position 
933c				ex de, hl 
933c			 
933c				ld (hl), e 
933c				inc hl 
933c				ld (hl), d 
933c			 
933c				inc hl 
933c			 
933c				; now at start of allocated data so save pointer 
933c			 
933c				push hl 
933c			 
933c				; jump to position of next node and setup empty header in DE 
933c			 
933c				ex de, hl 
933c			 
933c			;	inc hl ; move past end of block 
933c			 
933c				ld a, 0 
933c				ld (hl), a   ; empty marker 
933c				inc hl 
933c				ld (hl), a   ; size 
933c				inc hl  
933c				ld (hl), a   ; ptr 
933c				inc hl 
933c				ld (hl), a   ; ptr 
933c			 
933c			 
933c				pop hl 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "mmr" 
933c						CALLMONITOR 
933c					endif 
933c			 
933c			.exit: 
933c				pop af 
933c				pop bc 
933c				pop de  
933c				ret 
933c			 
933c			 
933c			 
933c			 
933c			free:  
933c				push hl 
933c				push af 
933c				; get address in hl 
933c			 
933c					if DEBUG_FORTH_MALLOC_INT 
933c						DMARK "fre" 
933c						CALLMONITOR 
933c					endif 
933c				; data is at hl - move to block count 
933c				dec hl 
933c				dec hl    ; get past pointer 
933c				dec hl 
933c			 
933c				ld a, (hl)    ; need this for a validation check 
933c			 
933c				dec hl    ; move to block marker 
933c			 
933c				; now check that the block count and block marker are the same  
933c			        ; this checks that we are on a malloc node and not random memory 
933c			        ; OK a faint chance this could be a problem but rare - famous last words! 
933c			 
933c				ld c, a 
933c				ld a, (hl)    
933c			 
933c				cp c 
933c				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
933c			 
933c				; yes good chance we are on a malloc node 
933c			 
933c				ld a, 0      
933c				ld (hl), a   ; mark as free 
933c			 
933c				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
933c			 
933c			.freeignore:  
933c			 
933c				pop af 
933c				pop hl 
933c			 
933c				ret 
933c			 
933c			 
933c			 
933c			endif 
933c			 
933c			; eof 
# End of file firmware_memory.asm
933c			  
933c			; device C  
933c			; Now handled by SPI  
933c			;if SOUND_ENABLE  
933c			;	include "firmware_sound.asm"  
933c			;endif  
933c			  
933c			include "firmware_diags.asm"  
933c			; Hardware diags menu 
933c			 
933c			 
933c			config: 
933c			 
933c 3e 00			ld a, 0 
933e 21 62 93			ld hl, .configmn 
9341 cd e0 8a			call menu 
9344			 
9344 fe 00			cp 0 
9346 c8				ret z 
9347			 
9347			;	cp 1 
9347			;	call z, .savetostore 
9347			 
9347 fe 01			cp 1 
9349			if STARTUP_V1 
9349 cc 78 93			call z, .selautoload 
934c			endif 
934c			 
934c			if STARTUP_V2 
934c				call z, .enautoload 
934c			endif 
934c fe 02			cp 2 
934e cc 6e 93			call z, .disautoload 
9351			;	cp 3 
9351			;	call z, .selbank 
9351 fe 03			cp 3 
9353 cc 96 93			call z, .debug_tog 
9356 fe 04			cp 4 
9358 cc e4 94			call z, .bpsgo 
935b fe 05			cp 5 
935d cc bf 93			call z, hardware_diags 
9360			if STARTUP_V2 
9360				cp 6 
9360				call z, create_startup 
9360			endif 
9360 18 da			jr config 
9362			 
9362			.configmn: 
9362			;	dw prom_c3 
9362 d2 96			dw prom_c2 
9364 e7 96			dw prom_c2a 
9366			;	dw prom_c2b 
9366			;	dw prom_c4 
9366 06 97			dw prom_m4 
9368 21 97			dw prom_m4b 
936a 29 97			dw prom_c1 
936c			if STARTUP_V2 
936c				dw prom_c9 
936c			endif 
936c 00 00			dw 0 
936e				 
936e			 
936e			if STARTUP_V2 
936e			.enautoload: 
936e				if STORAGE_SE 
936e				ld a, $fe      ; bit 0 clear 
936e				ld (spi_device), a 
936e			 
936e				call storage_get_block_0 
936e			 
936e				ld a, 1 
936e				ld (store_page+STORE_0_AUTOFILE), a 
936e			 
936e					ld hl, 0 
936e					ld de, store_page 
936e				call storage_write_block	 ; save update 
936e				else 
936e			 
936e				ld hl, prom_notav 
936e				ld de, prom_empty 
936e				call info_panel 
936e				endif 
936e			 
936e			 
936e				ret 
936e			endif 
936e			 
936e			.disautoload: 
936e				if STORAGE_SE 
936e				ld a, $fe      ; bit 0 clear 
936e				ld (spi_device), a 
936e			 
936e				call storage_get_block_0 
936e			 
936e				ld a, 0 
936e				ld (store_page+STORE_0_AUTOFILE), a 
936e			 
936e					ld hl, 0 
936e					ld de, store_page 
936e				call storage_write_block	 ; save update 
936e				else 
936e			 
936e 21 38 97			ld hl, prom_notav 
9371 11 4e 97			ld de, prom_empty 
9374 cd 40 8a			call info_panel 
9377				endif 
9377			 
9377			 
9377 c9				ret 
9378			 
9378			if STARTUP_V1 
9378			 
9378			; Select auto start 
9378			 
9378			.selautoload: 
9378			 
9378				 
9378				if STORAGE_SE 
9378			 
9378					call config_dir 
9378				        ld hl, scratch 
9378					ld a, 0 
9378					call menu 
9378			 
9378					cp 0 
9378					ret z 
9378			 
9378					dec a 
9378			 
9378			 
9378					; locate menu option 
9378			 
9378					ld hl, scratch 
9378					call table_lookup 
9378			 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "ALl" 
9378						CALLMONITOR 
9378					endif 
9378					; with the pointer to the menu it, the byte following the zero term is the file id 
9378			 
9378					ld a, 0 
9378					ld bc, 50   ; max of bytes to look at 
9378					cpir  
9378			 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "ALb" 
9378						CALLMONITOR 
9378					endif 
9378					;inc hl 
9378			 
9378					ld a, (hl)   ; file id 
9378					 
9378				        ; save bank and file ids 
9378			 
9378					push af 
9378			 
9378			; TODO need to save to block 0 on bank 1	 
9378			 
9378					call storage_get_block_0 
9378			 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "AL0" 
9378						CALLMONITOR 
9378					endif 
9378					pop af 
9378			 
9378					ld (store_page+STORE_0_FILERUN),a 
9378					 
9378					; save bank id 
9378			 
9378					ld a,(spi_device) 
9378					ld (store_page+STORE_0_BANKRUN),a 
9378			 
9378					; enable auto run of store file 
9378			 
9378					ld a, 1 
9378					ld (store_page+STORE_0_AUTOFILE),a 
9378			 
9378					; save buffer 
9378			 
9378					ld hl, 0 
9378					ld de, store_page 
9378					if DEBUG_FORTH_WORDS 
9378						DMARK "ALw" 
9378						CALLMONITOR 
9378					endif 
9378				call storage_write_block	 ; save update 
9378			  
9378			 
9378			 
9378			 
9378					ld hl, scratch 
9378					call config_fdir 
9378			 
9378				else 
9378			 
9378 21 38 97			ld hl, prom_notav 
937b 11 4e 97			ld de, prom_empty 
937e cd 40 8a			call info_panel 
9381			 
9381				endif 
9381 c9				ret 
9382			endif 
9382			 
9382			 
9382			; Select storage bank 
9382			 
9382			.selbank: 
9382			 
9382			;	if STORAGE_SE 
9382			;	else 
9382			 
9382 21 38 97			ld hl, prom_notav 
9385 11 4e 97			ld de, prom_empty 
9388 cd 40 8a			call info_panel 
938b			;	endif 
938b				 
938b c9				ret 
938c			 
938c			if STORAGE_SE 
938c			 
938c			.config_ldir:   
938c				; Load storage bank labels into menu array 
938c			 
938c				 
938c			 
938c			 
938c				ret 
938c			 
938c			 
938c			endif 
938c			 
938c			 
938c			; Save user words to storage 
938c			 
938c			.savetostore: 
938c			 
938c			;	if STORAGE_SE 
938c			; 
938c			;		call config_dir 
938c			;	        ld hl, scratch 
938c			;		ld a, 0 
938c			;		call menu 
938c			;		 
938c			;		ld hl, scratch 
938c			;		call config_fdir 
938c			; 
938c			;	else 
938c			 
938c 21 38 97			ld hl, prom_notav 
938f 11 4e 97			ld de, prom_empty 
9392 cd 40 8a			call info_panel 
9395			 
9395			;	endif 
9395			 
9395 c9				ret 
9396			 
9396			if STARTUP_V2 
9396			 
9396			create_startup: 
9396			 
9396				ld a, 0 
9396				ld hl, .crstart 
9396				call menu 
9396			 
9396				cp 0 
9396				ret z 
9396			 
9396				cp 1 
9396				call z, .genlsword 
9396				cp 2 
9396				call z, .genedword 
9396			 
9396				cp 3 
9396				call z, .gendemword 
9396			 
9396				cp 4 
9396				call z, .genutlword 
9396				cp 5 
9396				call z, .genspiword 
9396				cp 6 
9396				call z, .genkeyword 
9396				cp 7 
9396				call z, .gensoundword 
9396				jr create_startup 
9396			 
9396			.gensoundword: 
9396				ld hl, crs_sound 
9396				ld de, .soundworddef 
9396				call .genfile 
9396				ret 
9396			.genlsword: 
9396				ld hl, crs_s1 
9396				ld de, .lsworddef 
9396				call .genfile 
9396				ret 
9396			 
9396			.genedword: 
9396				ld de, .edworddef 
9396				ld hl, crs_s2 
9396				call .genfile 
9396				ret 
9396			 
9396			.gendemword: 
9396				ld de, .demoworddef 
9396				ld hl, crs_s3 
9396				call .genfile 
9396				ret 
9396			 
9396			.genutlword: 
9396				ld hl, crs_s4 
9396				ld de, .utilwordef 
9396				call .genfile 
9396				ret 
9396			.genspiword: 
9396				ld hl, crs_s5 
9396				ld de, .spiworddef 
9396				call .genfile 
9396				ret 
9396			.genkeyword: 
9396				ld hl, crs_s6 
9396				ld de, .keyworddef 
9396				call .genfile 
9396				ret 
9396			 
9396			; hl - points to file name 
9396			; de - points to strings to add to file 
9396			 
9396			.genfile: 
9396				push hl 
9396				push de 
9396			 
9396				call clear_display 
9396				ld a, display_row_1 
9396				ld de, .genfiletxt 
9396				call str_at_display 
9396				call update_display 
9396			 
9396				pop de 
9396				pop hl 
9396			 
9396			 
9396				push de 
9396				call storage_create 
9396				; id in hl 
9396				pop de   ; table of strings to add 
9396			 
9396			.genloop: 
9396			 
9396				push hl ; save id for next time around 
9396				push de ; save de for next time around 
9396			 
9396				ex de, hl 
9396				call loadwordinhl 
9396				ex de, hl 
9396			 
9396				; need hl to be the id 
9396				; need de to be the string ptr 
9396				 
9396				call storage_append 
9396			 
9396				pop de 
9396				pop hl 
9396			 
9396				inc de 
9396				inc de 
9396			 
9396				ld a,(de) 
9396				cp 0 
9396				jr nz, .genloop 
9396				inc de 
9396				ld a, (de) 
9396				dec de 
9396				cp 0 
9396				jr nz, .genloop	 
9396			 
9396				ret 
9396			 
9396			.genfiletxt:  db "Creating file...",0 
9396			 
9396			.soundworddef: 
9396				dw sound1 
9396				dw sound2 
9396				dw sound3 
9396				dw sound4 
9396				dw sound5 
9396				dw sound6 
9396				dw sound7 
9396				dw sound8 
9396				dw sound9 
9396				dw 0 
9396			 
9396			.utilwordef: 
9396				dw strncpy 
9396				dw type 
9396				dw clrstack 
9396				dw longread 
9396				dw start1 
9396				dw start2 
9396				dw start3b 
9396				dw start3c 
9396				dw list 
9396				dw 0 
9396			 
9396			.lsworddef: 
9396				dw start3b 
9396				dw 0 
9396			 
9396			.edworddef: 
9396				dw edit1 
9396				dw edit2 
9396				dw edit3 
9396				dw 0 
9396			 
9396			.demoworddef: 
9396				dw test5 
9396				dw test6 
9396				dw test7 
9396				dw test8 
9396				dw test9 
9396				dw test10 
9396				dw game1 
9396				dw game1a 
9396				dw game1b 
9396				dw game1c 
9396				dw game1d 
9396				dw game1s 
9396				dw game1t 
9396				dw game1f 
9396				dw game1z 
9396				dw game1zz 
9396				dw ssv2 
9396				dw ssv3 
9396				dw ssv4 
9396				dw ssv5 
9396				dw ssv1 
9396				dw ssv1cpm	 
9396				dw game2b 
9396				dw game2bf 
9396				dw game2mba 
9396				dw game2mbas	 
9396				dw game2mbht 
9396				dw game2mbms 
9396				dw game2mb 
9396				dw game3w 
9396				dw game3p 
9396				dw game3sc 
9396				dw game3vsi 
9396				dw game3vs 
9396				dw 0 
9396			 
9396			 
9396			.spiworddef: 
9396			 
9396			    dw spi1 
9396			    dw spi2 
9396			    dw spi3 
9396			    dw spi4 
9396			    dw spi5 
9396			    dw spi6 
9396			    dw spi7 
9396			 
9396			    dw spi8 
9396			    dw spi9 
9396			    dw spi10 
9396			    dw 0 
9396			 
9396			.keyworddef: 
9396			 
9396				dw keyup 
9396				dw keydown 
9396				dw keyleft 
9396				dw keyright 
9396				dw 	keyf1 
9396				dw keyf2 
9396				dw keyf3 
9396				dw keyf4 
9396				dw keyf5 
9396				dw keyf6 
9396				dw keyf7 
9396				dw keyf8 
9396				dw keyf9 
9396				dw keyf10 
9396				dw keyf11 
9396				dw keyf12 
9396				dw keytab 
9396				dw keycr 
9396				dw keyhome 
9396				dw keyend 
9396				dw keybs 
9396				dw 0 
9396			 
9396			.crstart: 
9396				dw crs_s1 
9396				dw crs_s2 
9396				dw crs_s3 
9396				dw crs_s4 
9396				dw crs_s5 
9396				dw crs_s6 
9396				dw crs_sound 
9396				dw 0 
9396			 
9396			endif 
9396			 
9396			 
9396			if STORAGE_SE 
9396			 
9396			config_fdir: 
9396				; using the scratch dir go through and release the memory allocated for each string 
9396				 
9396				ld hl, scratch 
9396			.cfdir:	ld e,(hl) 
9396				inc hl 
9396				ld d,(hl) 
9396				inc hl 
9396			 
9396				ex de, hl 
9396				call ishlzero 
9396				ret z     ; return on null pointer 
9396				call free 
9396				ex de, hl 
9396				jr .cfdir 
9396			 
9396			 
9396				ret 
9396			 
9396			 
9396			config_dir: 
9396			 
9396				; for the config menus that need to build a directory of storage call this routine 
9396				; it will construct a menu in scratch to pass to menu 
9396			 
9396				; open storage device 
9396			 
9396				; execute DIR to build a list of files and their ids into scratch in menu format 
9396				; once the menu has finished then will need to call config_fdir to release the strings 
9396				 
9396				; c = number items 
9396			 
9396				 
9396				call storage_get_block_0 
9396			 
9396				ld hl, store_page     ; get current id count 
9396				ld b, (hl) 
9396				ld c, 0    ; count of files   
9396			 
9396			 
9396				ld hl, scratch 
9396				ld (store_tmp2), hl    ; location to poke strings 
9396			 
9396				; check for empty drive 
9396			 
9396				ld a, 0 
9396				cp b 
9396				jp z, .dirdone 
9396			 
9396				 
9396					if DEBUG_FORTH_WORDS 
9396						DMARK "Cdc" 
9396						CALLMONITOR 
9396					endif 
9396			 
9396			 
9396			.diritem:	 
9396				push bc 
9396				; for each of the current ids do a search for them and if found push to stack 
9396			 
9396					ld hl, STORE_BLOCK_PHY 
9396					ld d, 0		 ; look for extent 0 of block id as this contains file name 
9396					ld e,b 
9396			 
9396					call storage_findnextid 
9396			 
9396			 
9396					; if found hl will be non zero 
9396			 
9396					call ishlzero 
9396					jr z, .dirnotfound 
9396			 
9396					; increase count 
9396			 
9396					pop bc	 
9396					inc c 
9396					push bc 
9396					 
9396			 
9396					; get file header and push the file name 
9396			 
9396					ld de, store_page 
9396					call storage_read_block 
9396			 
9396					; push file id to stack 
9396				 
9396					ld a, (store_page) 
9396					ld h, 0 
9396					ld l, a 
9396			 
9396					;call forth_push_numhl 
9396					; TODO store id 
9396			 
9396					push hl 
9396			 
9396					; push extent count to stack  
9396				 
9396					ld hl, store_page+3 
9396			 
9396					; get file name length 
9396			 
9396					call strlenz   
9396			 
9396					inc hl   ; cover zero term 
9396					inc hl  ; stick the id at the end of the area 
9396			 
9396					push hl 
9396					pop bc    ; move length to bc 
9396			 
9396					call malloc 
9396			 
9396					; TODO save malloc area to scratch 
9396			 
9396					ex de, hl 
9396					ld hl, (store_tmp2) 
9396					ld (hl), e 
9396					inc hl 
9396					ld (hl), d 
9396					inc hl 
9396					ld (store_tmp2), hl 
9396			 
9396					 
9396			 
9396					;pop hl   ; get source 
9396			;		ex de, hl    ; swap aronund	 
9396			 
9396					ld hl, store_page+3 
9396					if DEBUG_FORTH_WORDS 
9396						DMARK "CFd" 
9396						CALLMONITOR 
9396					endif 
9396					ldir 
9396			 
9396					; de is past string, move back one and store id 
9396					 
9396					dec de 
9396			 
9396					; store file id 
9396			 
9396					pop hl 
9396					ex de,hl 
9396					ld (hl), e 
9396			 
9396					if DEBUG_FORTH_WORDS 
9396						DMARK "Cdi" 
9396						CALLMONITOR 
9396					endif 
9396					 
9396			.dirnotfound: 
9396					pop bc     
9396					djnz .diritem 
9396				 
9396			.dirdone:	 
9396			 
9396					ld a, 0 
9396					ld hl, (store_tmp2) 
9396					ld (hl), a 
9396					inc hl 
9396					ld (hl), a 
9396					inc hl 
9396					; push a count of the dir items found 
9396			 
9396			;		ld h, 0 
9396			;		ld l, c 
9396			 
9396				ret 
9396			 
9396			endif 
9396			 
9396			 
9396			; Settings 
9396			; Run  
9396			 
9396			 
9396			 
9396			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
9396			;;hd_menu2:   db "        2: Editor",0   
9396			;hd_menu2:   db "        2: Editor       6: Menu",0   
9396			;hd_menu3:   db "        3: Storage",0 
9396			;hd_menu4:   db "0=quit  4: Debug",0 
9396			;hd_don:     db "ON",0 
9396			;hd_doff:     db "OFF",0 
9396			; 
9396			; 
9396			; 
9396			;hardware_diags_old:       
9396			; 
9396			;.diagmenu: 
9396			;	call clear_display 
9396			;	ld a, display_row_1 
9396			;	ld de, hd_menu1 
9396			;	call str_at_display 
9396			; 
9396			;	ld a, display_row_2 
9396			;	ld de, hd_menu2 
9396			;	call str_at_display 
9396			; 
9396			;	ld a, display_row_3 
9396			;	ld de, hd_menu3 
9396			;	call str_at_display 
9396			; 
9396			;	ld a,  display_row_4 
9396			;	ld de, hd_menu4 
9396			;	call str_at_display 
9396			; 
9396			;	; display debug state 
9396			; 
9396			;	ld de, hd_don 
9396			;	ld a, (os_view_disable) 
9396			;	cp 0 
9396			;	jr z, .distog 
9396			;	ld de, hd_doff 
9396			;.distog: ld a, display_row_4+17 
9396			;	call str_at_display 
9396			; 
9396			;	call update_display 
9396			; 
9396			;	call cin_wait 
9396			; 
9396			; 
9396			; 
9396			;	cp '4' 
9396			;	jr nz, .diagn1 
9396			; 
9396			;	; debug toggle 
9396			; 
9396			;	ld a, (os_view_disable) 
9396			;	ld b, '*' 
9396			;	cp 0 
9396			;	jr z, .debtog 
9396			;	ld b, 0 
9396			;.debtog:	 
9396			;	ld a,b 
9396			;	ld (os_view_disable),a 
9396			; 
9396			;.diagn1: cp '0' 
9396			;	 ret z 
9396			; 
9396			;;	cp '1' 
9396			;;       jp z, matrix	 
9396			;;   TODO keyboard matrix test 
9396			; 
9396			;	cp '2' 
9396			;	jp z, .diagedit 
9396			; 
9396			;;	cp '6' 
9396			;;	jp z, .menutest 
9396			;;if ENABLE_BASIC 
9396			;;	cp '6' 
9396			;;	jp z, basic 
9396			;;endif 
9396			 ; 
9396			;	jp .diagmenu 
9396			; 
9396			; 
9396			;	ret 
9396			 
9396			 
9396			.debug_tog: 
9396 21 e0 93			ld hl, .menudebug 
9399				 
9399			;	ld a, (os_view_disable) 
9399			;	cp '*' 
9399 3a 6f ee			ld a,(debug_vector) 
939c fe c9			cp $C9   ; RET 
939e 20 04			jr nz,.tdon  
93a0 3e 01			ld a, 1 
93a2 18 02			jr .tog1 
93a4 3e 00		.tdon: ld a, 0 
93a6			 
93a6			.tog1: 
93a6 cd e0 8a			call menu 
93a9 fe 00			cp 0 
93ab c8				ret z 
93ac fe 01			cp 1    ; disable debug 
93ae 28 04			jr z, .dtog0 
93b0 3e 2a			ld a, '*' 
93b2 18 05			jr .dtogset 
93b4			.dtog0:  
93b4				;ld a, 0 
93b4 cd d2 94			call bp_on 
93b7 18 dd			jr .debug_tog 
93b9			.dtogset:  
93b9				; ld (os_view_disable), a 
93b9 cd de 94			call bp_off 
93bc c3 96 93			jp .debug_tog 
93bf			 
93bf			 
93bf			hardware_diags:       
93bf			 
93bf			.diagm: 
93bf 21 d2 93			ld hl, .menuitems 
93c2 3e 00			ld a, 0 
93c4 cd e0 8a			call menu 
93c7			 
93c7 fe 00		         cp 0 
93c9 c8				 ret z 
93ca			 
93ca fe 02			cp 2 
93cc ca 2b 94			jp z, .diagedit 
93cf			 
93cf			;	cp '6' 
93cf			;	jp z, .menutest 
93cf			;if ENABLE_BASIC 
93cf			;	cp '6' 
93cf			;	jp z, basic 
93cf			;endif 
93cf			  
93cf c3 bf 93			jp .diagm 
93d2			 
93d2				 
93d2 e6 93		.menuitems:   	dw .m1 
93d4 f1 93				dw .m2 
93d6 f8 93				dw .m3 
93d8 00 94				dw .m5 
93da 06 94				dw .m5a 
93dc 0f 94				dw .m5b 
93de 00 00				dw 0 
93e0			 
93e0			.menudebug: 
93e0 18 94				dw .m6 
93e2 21 94				dw .m7 
93e4 00 00				dw 0 
93e6			 
93e6 .. 00		.m1:   db "Key Matrix",0 
93f1 .. 00		.m2:   db "Editor",0 
93f8 .. 00		.m3:   db "Storage",0 
9400 .. 00		.m5:   db "Sound",0 
9406 .. 00		.m5a:  db "RAM Test",0 
940f .. 00		.m5b:  db "LCD Test",0 
9418			 
9418 .. 00		.m6:   db "Debug ON",0 
9421 .. 00		.m7:   db "Debug OFF",0 
942b			 
942b			; debug editor 
942b			 
942b			.diagedit: 
942b			 
942b 21 c1 e2			ld hl, scratch 
942e			;	ld bc, 250 
942e			;	ldir 
942e				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
942e 3e 00			ld a, 0 
9430 77				ld (hl), a 
9431 23				inc hl 
9432 77				ld (hl), a 
9433 23				inc hl 
9434 77				ld (hl), a 
9435			 
9435 cd af 8a		        call clear_display 
9438 cd d2 8a			call update_display 
943b				;ld a, 1 
943b				;ld (hardware_diag), a 
943b			.diloop: 
943b 3e 00			ld a, display_row_1 
943d 0e 00			ld c, 0 
943f 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9441 1e 28			ld e, 40 
9443			 
9443 21 c1 e2			ld hl, scratch	 
9446 cd 09 8d			call input_str 
9449			 
9449 3e 28			ld a, display_row_2 
944b 11 c1 e2			ld de, scratch 
944e cd c2 8a			call str_at_display 
9451 cd d2 8a			call update_display 
9454			 
9454 c3 3b 94			jp .diloop 
9457			 
9457			 
9457			; pass word in hl 
9457			; a has display location 
9457			display_word_at: 
9457 f5				push af 
9458 e5				push hl 
9459 7c				ld a,h 
945a 21 c6 e5			ld hl, os_word_scratch 
945d cd dd 8f			call hexout 
9460 e1				pop hl 
9461 7d				ld a,l 
9462 21 c8 e5			ld hl, os_word_scratch+2 
9465 cd dd 8f			call hexout 
9468 21 ca e5			ld hl, os_word_scratch+4 
946b 3e 00			ld a,0 
946d 77				ld (hl),a 
946e 11 c6 e5			ld de,os_word_scratch 
9471 f1				pop af 
9472 cd c2 8a				call str_at_display 
9475 c9				ret 
9476			 
9476			display_ptr_state: 
9476			 
9476				; to restore afterwards 
9476			 
9476 d5				push de 
9477 c5				push bc 
9478 e5				push hl 
9479 f5				push af 
947a			 
947a				; for use in here 
947a			 
947a			;	push bc 
947a			;	push de 
947a			;	push hl 
947a			;	push af 
947a			 
947a cd af 8a			call clear_display 
947d			 
947d 11 55 96			ld de, .ptrstate 
9480 3e 00			ld a, display_row_1 
9482 cd c2 8a			call str_at_display 
9485			 
9485				; display debug step 
9485			 
9485			 
9485 11 6b ee			ld de, debug_mark 
9488 3e 26			ld a, display_row_1+display_cols-2 
948a cd c2 8a			call str_at_display 
948d			 
948d				; display a 
948d 11 5f 96			ld de, .ptrcliptr 
9490 3e 28			ld a, display_row_2 
9492 cd c2 8a			call str_at_display 
9495			 
9495 f1				pop af 
9496 2a 40 ea			ld hl,(cli_ptr) 
9499 3e 30			ld a, display_row_2+8 
949b cd 57 94			call display_word_at 
949e			 
949e			 
949e				; display hl 
949e			 
949e			 
949e 11 67 96			ld de, .ptrclioptr 
94a1 3e 32			ld a, display_row_2+10 
94a3 cd c2 8a			call str_at_display 
94a6			; 
94a6			;	pop hl 
94a6 3e 35			ld a, display_row_2+13 
94a8 2a 3e ea			ld hl,(cli_origptr) 
94ab cd 57 94			call display_word_at 
94ae			; 
94ae			;	 
94ae			;	; display de 
94ae			 
94ae			;	ld de, .regstatede 
94ae			;	ld a, display_row_3 
94ae			;	call str_at_display 
94ae			 
94ae			;	pop de 
94ae			;	ld h,d 
94ae			;	ld l, e 
94ae			;	ld a, display_row_3+3 
94ae			;	call display_word_at 
94ae			 
94ae			 
94ae				; display bc 
94ae			 
94ae			;	ld de, .regstatebc 
94ae			;	ld a, display_row_3+10 
94ae			;	call str_at_display 
94ae			 
94ae			;	pop bc 
94ae			;	ld h,b 
94ae			;	ld l, c 
94ae			;	ld a, display_row_3+13 
94ae			;	call display_word_at 
94ae			 
94ae			 
94ae				; display dsp 
94ae			 
94ae			;	ld de, .regstatedsp 
94ae			;	ld a, display_row_4 
94ae			;	call str_at_display 
94ae			 
94ae				 
94ae			;	ld hl,(cli_data_sp) 
94ae			;	ld a, display_row_4+4 
94ae			;	call display_word_at 
94ae			 
94ae				; display rsp 
94ae			 
94ae 11 96 96			ld de, .regstatersp 
94b1 3e 82			ld a, display_row_4+10 
94b3 cd c2 8a			call str_at_display 
94b6			 
94b6				 
94b6 2a f2 e9			ld hl,(cli_ret_sp) 
94b9 3e 86			ld a, display_row_4+14 
94bb cd 57 94			call display_word_at 
94be			 
94be cd d2 8a			call update_display 
94c1			 
94c1 cd f2 89			call delay1s 
94c4 cd f2 89			call delay1s 
94c7 cd f2 89			call delay1s 
94ca			 
94ca			 
94ca cd b2 9a			call next_page_prompt 
94cd			 
94cd				; restore  
94cd			 
94cd f1				pop af 
94ce e1				pop hl 
94cf c1				pop bc 
94d0 d1				pop de 
94d1 c9				ret 
94d2			 
94d2			; Update the break point vector so that the user can hook a new routine 
94d2			 
94d2			bp_on: 
94d2 3e c3			ld a, $c3    ; JP 
94d4 32 6f ee			ld (debug_vector), a 
94d7 21 e4 94			ld hl, break_point_state 
94da 22 70 ee			ld (debug_vector+1), hl 
94dd c9				ret 
94de			 
94de			bp_off: 
94de 3e c9			ld a, $c9    ; RET 
94e0 32 6f ee			ld (debug_vector), a 
94e3 c9				ret 
94e4			 
94e4			 
94e4			break_point_state: 
94e4			;	push af 
94e4			; 
94e4			;	; see if disabled 
94e4			; 
94e4			;	ld a, (os_view_disable) 
94e4			;	cp '*' 
94e4			;	jr nz, .bpsgo 
94e4			;	pop af 
94e4			;	ret 
94e4			 
94e4			.bpsgo: 
94e4			;	pop af 
94e4 f5				push af 
94e5 22 af e2			ld (os_view_hl), hl 
94e8 ed 53 ad e2		ld (os_view_de), de 
94ec ed 43 ab e2		ld (os_view_bc), bc 
94f0 e5				push hl 
94f1 6f				ld l, a 
94f2 26 00			ld h, 0 
94f4 22 b1 e2			ld (os_view_af),hl 
94f7			 
94f7 21 b1 ed				ld hl, display_fb0 
94fa 22 cc eb				ld (display_fb_active), hl 
94fd e1				pop hl	 
94fe			 
94fe 3e 31			ld a, '1' 
9500 fe 2a		.bps1:  cp '*' 
9502 cc de 94			call z, bp_off 
9505			;	jr nz, .bps1b 
9505			;	ld (os_view_disable),a 
9505 fe 31		.bps1b:  cp '1' 
9507 20 14			jr nz, .bps2 
9509			 
9509				; display reg 
9509			 
9509				 
9509			 
9509 3a b1 e2			ld a, (os_view_af) 
950c 2a af e2			ld hl, (os_view_hl) 
950f ed 5b ad e2		ld de, (os_view_de) 
9513 ed 4b ab e2		ld bc, (os_view_bc) 
9517 cd b1 95			call display_reg_state 
951a c3 9d 95			jp .bpschk 
951d			 
951d fe 32		.bps2:  cp '2' 
951f 20 08			jr nz, .bps3 
9521				 
9521				; display hl 
9521 2a af e2			ld hl, (os_view_hl) 
9524 cd 9b 96			call display_dump_at_hl 
9527			 
9527 18 74			jr .bpschk 
9529			 
9529 fe 33		.bps3:  cp '3' 
952b 20 08			jr nz, .bps4 
952d			 
952d			        ; display de 
952d 2a ad e2			ld hl, (os_view_de) 
9530 cd 9b 96			call display_dump_at_hl 
9533			 
9533 18 68			jr .bpschk 
9535 fe 34		.bps4:  cp '4' 
9537 20 08			jr nz, .bps5 
9539			 
9539			        ; display bc 
9539 2a ab e2			ld hl, (os_view_bc) 
953c cd 9b 96			call display_dump_at_hl 
953f			 
953f 18 5c			jr .bpschk 
9541 fe 35		.bps5:  cp '5' 
9543 20 08		        jr nz, .bps7 
9545			 
9545				; display cur ptr 
9545 2a 40 ea			ld hl, (cli_ptr) 
9548 cd 9b 96			call display_dump_at_hl 
954b			 
954b 18 50			jr .bpschk 
954d fe 36		.bps7:  cp '6' 
954f 20 08			jr nz, .bps8b 
9551				 
9551				; display cur orig ptr 
9551 2a 3e ea			ld hl, (cli_origptr) 
9554 cd 9b 96			call display_dump_at_hl 
9557 18 44			jr .bpschk 
9559 fe 37		.bps8b:  cp '7' 
955b 20 08			jr nz, .bps9 
955d				 
955d				; display dsp 
955d 2a ee e9			ld hl, (cli_data_sp) 
9560 cd 9b 96			call display_dump_at_hl 
9563			 
9563 18 38			jr .bpschk 
9565 fe 39		.bps9:  cp '9' 
9567 20 05			jr nz, .bps8c 
9569				 
9569				; display SP 
9569			;	ld hl, sp 
9569 cd 9b 96			call display_dump_at_hl 
956c			 
956c 18 2f			jr .bpschk 
956e fe 38		.bps8c:  cp '8' 
9570 20 08			jr nz, .bps8d 
9572				 
9572				; display rsp 
9572 2a f2 e9			ld hl, (cli_ret_sp) 
9575 cd 9b 96			call display_dump_at_hl 
9578			 
9578 18 23			jr .bpschk 
957a fe 23		.bps8d:  cp '#'     ; access monitor sub system 
957c 20 05			jr nz, .bps8 
957e cd 80 98			call monitor 
9581			 
9581 18 1a			jr .bpschk 
9583 fe 30		.bps8:  cp '0' 
9585 20 16			jr nz, .bpschk 
9587			 
9587 21 10 ed				ld hl, display_fb1 
958a 22 cc eb				ld (display_fb_active), hl 
958d cd d2 8a				call update_display 
9590			 
9590				;ld a, (os_view_af) 
9590 2a af e2			ld hl, (os_view_hl) 
9593 ed 5b ad e2		ld de, (os_view_de) 
9597 ed 4b ab e2		ld bc, (os_view_bc) 
959b f1				pop af 
959c c9				ret 
959d			 
959d			.bpschk:   
959d cd f2 89			call delay1s 
95a0 3e 9f		ld a,display_row_4 + display_cols - 1 
95a2 11 b0 9a		        ld de, endprg 
95a5 cd c2 8a			call str_at_display 
95a8 cd d2 8a			call update_display 
95ab cd 17 e4			call cin_wait 
95ae			 
95ae c3 00 95			jp .bps1 
95b1			 
95b1			 
95b1			display_reg_state: 
95b1			 
95b1				; to restore afterwards 
95b1			 
95b1 d5				push de 
95b2 c5				push bc 
95b3 e5				push hl 
95b4 f5				push af 
95b5			 
95b5				; for use in here 
95b5			 
95b5 c5				push bc 
95b6 d5				push de 
95b7 e5				push hl 
95b8 f5				push af 
95b9			 
95b9 cd af 8a			call clear_display 
95bc			 
95bc 11 71 96			ld de, .regstate 
95bf 3e 00			ld a, display_row_1 
95c1 cd c2 8a			call str_at_display 
95c4			 
95c4				; display debug step 
95c4			 
95c4			 
95c4 11 6b ee			ld de, debug_mark 
95c7 3e 25			ld a, display_row_1+display_cols-3 
95c9 cd c2 8a			call str_at_display 
95cc			 
95cc				; display a 
95cc 11 8d 96			ld de, .regstatea 
95cf 3e 28			ld a, display_row_2 
95d1 cd c2 8a			call str_at_display 
95d4			 
95d4 e1				pop hl 
95d5			;	ld h,0 
95d5			;	ld l, a 
95d5 3e 2b			ld a, display_row_2+3 
95d7 cd 57 94			call display_word_at 
95da			 
95da			 
95da				; display hl 
95da			 
95da			 
95da 11 81 96			ld de, .regstatehl 
95dd 3e 32			ld a, display_row_2+10 
95df cd c2 8a			call str_at_display 
95e2			 
95e2 e1				pop hl 
95e3 3e 35			ld a, display_row_2+13 
95e5 cd 57 94			call display_word_at 
95e8			 
95e8				 
95e8				; display de 
95e8			 
95e8 11 85 96			ld de, .regstatede 
95eb 3e 50			ld a, display_row_3 
95ed cd c2 8a			call str_at_display 
95f0			 
95f0 e1				pop hl 
95f1			;	ld h,d 
95f1			;	ld l, e 
95f1 3e 53			ld a, display_row_3+3 
95f3 cd 57 94			call display_word_at 
95f6			 
95f6			 
95f6				; display bc 
95f6			 
95f6 11 89 96			ld de, .regstatebc 
95f9 3e 5a			ld a, display_row_3+10 
95fb cd c2 8a			call str_at_display 
95fe			 
95fe e1				pop hl 
95ff			;	ld h,b 
95ff			;	ld l, c 
95ff 3e 5d			ld a, display_row_3+13 
9601 cd 57 94			call display_word_at 
9604			 
9604			 
9604				; display dsp 
9604			 
9604 11 91 96			ld de, .regstatedsp 
9607 3e 78			ld a, display_row_4 
9609 cd c2 8a			call str_at_display 
960c			 
960c				 
960c 2a ee e9			ld hl,(cli_data_sp) 
960f 3e 7c			ld a, display_row_4+4 
9611 cd 57 94			call display_word_at 
9614			 
9614				; display rsp 
9614			 
9614 11 96 96			ld de, .regstatersp 
9617 3e 82			ld a, display_row_4+10 
9619 cd c2 8a			call str_at_display 
961c			 
961c				 
961c 2a f2 e9			ld hl,(cli_ret_sp) 
961f 3e 86			ld a, display_row_4+14 
9621 cd 57 94			call display_word_at 
9624			 
9624 cd d2 8a			call update_display 
9627			 
9627			;	call delay1s 
9627			;	call delay1s 
9627			;	call delay1s 
9627			 
9627			 
9627			;	call next_page_prompt 
9627			 
9627				; restore  
9627			 
9627 f1				pop af 
9628 e1				pop hl 
9629 c1				pop bc 
962a d1				pop de 
962b c9				ret 
962c			 
962c .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
9640 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9655 .. 00		.ptrstate:	db "Ptr State",0 
965f .. 00		.ptrcliptr:     db "cli_ptr",0 
9667 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9671 .. 00		.regstate:	db "Reg State (1/0)",0 
9681 .. 00		.regstatehl:	db "HL:",0 
9685 .. 00		.regstatede:	db "DE:",0 
9689 .. 00		.regstatebc:	db "BC:",0 
968d .. 00		.regstatea:	db "A :",0 
9691 .. 00		.regstatedsp:	db "DSP:",0 
9696 .. 00		.regstatersp:	db "RSP:",0 
969b			 
969b			display_dump_at_hl: 
969b e5				push hl 
969c d5				push de 
969d c5				push bc 
969e f5				push af 
969f			 
969f 22 e4 e5			ld (os_cur_ptr),hl	 
96a2 cd af 8a			call clear_display 
96a5 cd ba 99			call dumpcont 
96a8			;	call delay1s 
96a8			;	call next_page_prompt 
96a8			 
96a8			 
96a8 f1				pop af 
96a9 c1				pop bc 
96aa d1				pop de 
96ab e1				pop hl 
96ac c9				ret 
96ad			 
96ad			;if ENABLE_BASIC 
96ad			;	include "nascombasic.asm" 
96ad			;	basic: 
96ad			;	include "forth/FORTH.ASM" 
96ad			;endif 
96ad			 
96ad			; eof 
96ad			 
96ad			 
# End of file firmware_diags.asm
96ad			  
96ad			include "firmware_prompts.asm"  
96ad			; Prompts  
96ad			 
96ad			; boot messages 
96ad			 
96ad .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
96c2 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
96d2			 
96d2			 
96d2			; config menus 
96d2			 
96d2			;prom_c3: db "Add Dictionary To File",0 
96d2			 
96d2			if STARTUP_V1 
96d2 .. 00		prom_c2: db "Select Autoload File",0 
96e7 .. 00		prom_c2a: db "Disable Autoload File", 0 
96fd			endif 
96fd			 
96fd			if STARTUP_V2 
96fd			prom_c2: db "Enable Autoload Files",0 
96fd			prom_c2a: db "Disable Autoload Files", 0 
96fd			 
96fd			crs_s1: db "*ls-word", 0 
96fd			crs_s2: db "*ed-word", 0 
96fd			crs_s3: db "*Demo-Programs", 0 
96fd			crs_s4: db "*Utils", 0 
96fd			crs_s5: db "*SPI-Addons", 0 
96fd			crs_s6: db "*Key-constants", 0 
96fd			crs_sound: db "*Sound-Util", 0 
96fd			 
96fd			 
96fd			 
96fd			endif 
96fd			;prom_c2b: db "Select Storage Bank",0 
96fd .. 00		prom_c4: db "Settings",0 
9706 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9721 .. 00		prom_m4b:   db "Monitor",0 
9729 .. 00		prom_c1: db "Hardware Diags",0 
9738			 
9738			 
9738			if STARTUP_V2 
9738			prom_c9: db "Create Startup Files",0 
9738			endif 
9738			 
9738 .. 00		prom_notav:    db "Feature not available",0 
974e .. 00		prom_empty:    db "",0 
974f			 
974f			; eof 
974f			 
# End of file firmware_prompts.asm
974f			  
974f			  
974f			; eof  
974f			  
# End of file firmware.asm
974f			 
974f			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
974f			;if BASE_KEV  
974f			;baseram: equ 08000h 
974f			;endif 
974f			 
974f			;if BASE_SC114 
974f			;baseram:     equ    endofcode 
974f			;endif 
974f			 
974f			 
974f			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
974f			 
974f			; start system 
974f			 
974f			coldstart: 
974f				; set sp 
974f				; di/ei 
974f			 
974f f3				di 
9750 31 00 f0			ld sp, tos 
9753 cd 61 e3			call init_nmi 
9756			;	ei 
9756			 
9756				; init spinner 
9756 3e 00			ld a,0 
9758 32 c6 eb			ld (display_active), a 
975b			 
975b				; disable breakpoint by default 
975b			 
975b				;ld a,'*' 
975b			;	ld a,' ' 
975b			;	ld (os_view_disable),a 
975b			 
975b				; set break point vector as new break point on or off 
975b cd de 94			call bp_off 
975e			 
975e				; init hardware 
975e			 
975e				; init keyboard and screen hardware 
975e			 
975e cd 1c 80			call hardware_init 
9761			 
9761			 
9761 cd f2 89			call delay1s 
9764 3e 58			ld a, display_row_3+8 
9766 11 03 80			ld de, buildtime 
9769 cd c2 8a			call str_at_display 
976c cd d2 8a			call update_display 
976f			 
976f cd f2 89			call delay1s 
9772 cd f2 89			call delay1s 
9775 cd f2 89			call delay1s 
9778			 
9778				; detect if any keys are held down to enable breakpoints at start up 
9778			 
9778 cd 1d e4			call cin  
977b fe 00			cp 0 
977d 28 03			jr z, .nokeys 
977f			 
977f				;call hardware_diags 
977f cd 3c 93			call config 
9782			 
9782			;	ld de, .bpen 
9782			;	ld a, display_row_4 
9782			;	call str_at_display 
9782			;	call update_display 
9782			; 
9782			;	ld a,0 
9782			;	ld (os_view_disable),a 
9782			; 
9782			;.bpwait: 
9782			;	call cin 
9782			;	cp 0 
9782			;	jr z, .bpwait 
9782			;	jr .nokeys 
9782			; 
9782			; 
9782			;.bpen:  db "Break points enabled!",0 
9782			 
9782			 
9782			 
9782			 
9782			 
9782			 
9782			.nokeys: 
9782			 
9782			 
9782				 
9782			 
9782			;jp  testkey 
9782			 
9782			;call storage_get_block_0 
9782			; 
9782			;ld hl, 0 
9782			;ld de, store_page 
9782			;call storage_read_block 
9782			 
9782				 
9782			;ld hl, 10 
9782			;ld de, store_page 
9782			;call storage_read_block 
9782			 
9782			 
9782			 
9782			 
9782			 
9782			;stop:	nop 
9782			;	jp stop 
9782			 
9782			 
9782			 
9782			main: 
9782 cd af 8a			call clear_display 
9785 cd d2 8a			call update_display 
9788			 
9788			 
9788			 
9788			;	call testlcd 
9788			 
9788			 
9788			 
9788 cd b7 9e			call forth_init 
978b			 
978b			 
978b			warmstart: 
978b cd 8d 9e			call forth_warmstart 
978e			 
978e				; run startup word load 
978e			        ; TODO prevent this running at warmstart after crash  
978e			 
978e				if STARTUP_ENABLE 
978e			 
978e					if STARTUP_V1 
978e			 
978e						if STORAGE_SE 
978e							call forth_autoload 
978e						endif 
978e cd b1 e2					call forth_startup 
9791					endif 
9791			 
9791					if STARTUP_V2 
9791			 
9791						if STORAGE_SE 
9791							call forth_autoload 
9791						else 
9791							call forth_startup 
9791						endif 
9791			 
9791			 
9791					endif 
9791			 
9791				endif 
9791			 
9791				; show free memory after boot 
9791 11 1b 98			ld de, freeram 
9794 3e 00			ld a, display_row_1 
9796 cd c2 8a			call str_at_display 
9799			 
9799			; Or use heap_size word???? 
9799 21 a8 e2			ld hl, heap_end 
979c 11 3b e4			ld de, heap_start 
979f ed 52			sbc hl, de 
97a1				;push hl 
97a1				;ld a,h	         	 
97a1				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
97a1				;call hexout 
97a1			   	;pop hl 
97a1			; 
97a1			;	ld a,l 
97a1			;	ld hl, os_word_scratch+2 
97a1			;	call hexout 
97a1			;	ld hl, os_word_scratch+4 
97a1			;	ld a, 0 
97a1			;	ld (hl),a 
97a1			 
97a1 21 c6 e5			ld hl, os_word_scratch 
97a4 cd e9 90			call uitoa_16 
97a7			 
97a7			 
97a7 11 c6 e5			ld de, os_word_scratch 
97aa 3e 0d			ld a, display_row_1 + 13 
97ac cd c2 8a			call str_at_display 
97af cd d2 8a			call update_display 
97b2			 
97b2			 
97b2				;call demo 
97b2			 
97b2			 
97b2				; init scratch input area for cli commands 
97b2			 
97b2 21 e8 e5			ld hl, os_cli_cmd 
97b5 3e 00			ld a,0 
97b7 77				ld (hl),a 
97b8 23				inc hl 
97b9 77				ld (hl),a 
97ba			 
97ba 3e 00			ld a,0 
97bc 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
97bf			 
97bf 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
97c2 32 e5 e5			ld (os_cur_ptr+1),a	 
97c5			 
97c5 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
97c8 32 c7 e5			ld (os_word_scratch+1),a	 
97cb				 
97cb			 
97cb				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97cb 21 e8 e5			ld hl, os_cli_cmd 
97ce			 
97ce 3e 00			ld a, 0		 ; init cli input 
97d0 77				ld (hl), a 
97d1 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97d3			cli: 
97d3				; show cli prompt 
97d3				;push af 
97d3				;ld a, 0 
97d3				;ld de, prompt 
97d3				;call str_at_display 
97d3			 
97d3				;call update_display 
97d3				;pop af 
97d3				;inc a 
97d3				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
97d3 0e 00			ld c, 0 
97d5 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
97d7 1e 28			ld e, 40 
97d9			 
97d9 21 e8 e5			ld hl, os_cli_cmd 
97dc			 
97dc				STACKFRAME OFF $fefe $9f9f 
97dc				if DEBUG_STACK_IMB 
97dc					if OFF 
97dc						exx 
97dc						ld de, $fefe 
97dc						ld a, d 
97dc						ld hl, curframe 
97dc						call hexout 
97dc						ld a, e 
97dc						ld hl, curframe+2 
97dc						call hexout 
97dc						ld hl, $fefe 
97dc						push hl 
97dc						ld hl, $9f9f 
97dc						push hl 
97dc						exx 
97dc					endif 
97dc				endif 
97dc			endm 
# End of macro STACKFRAME
97dc			 
97dc cd 09 8d			call input_str 
97df			 
97df				STACKFRAMECHK OFF $fefe $9f9f 
97df				if DEBUG_STACK_IMB 
97df					if OFF 
97df						exx 
97df						ld hl, $9f9f 
97df						pop de   ; $9f9f 
97df						call cmp16 
97df						jr nz, .spnosame 
97df						ld hl, $fefe 
97df						pop de   ; $fefe 
97df						call cmp16 
97df						jr z, .spfrsame 
97df						.spnosame: call showsperror 
97df						.spfrsame: nop 
97df						exx 
97df					endif 
97df				endif 
97df			endm 
# End of macro STACKFRAMECHK
97df			 
97df				; copy input to last command 
97df			 
97df 21 e8 e5			ld hl, os_cli_cmd 
97e2 11 e7 e6			ld de, os_last_cmd 
97e5 01 ff 00			ld bc, 255 
97e8 ed b0			ldir 
97ea			 
97ea				; wipe current buffer 
97ea			 
97ea			;	ld a, 0 
97ea			;	ld hl, os_cli_cmd 
97ea			;	ld de, os_cli_cmd+1 
97ea			;	ld bc, 254 
97ea			;	ldir 
97ea				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
97ea			;	call strcpy 
97ea			;	ld a, 0 
97ea			;	ld (hl), a 
97ea			;	inc hl 
97ea			;	ld (hl), a 
97ea			;	inc hl 
97ea			;	ld (hl), a 
97ea			 
97ea				; switch frame buffer to program  
97ea			 
97ea 21 10 ed				ld hl, display_fb1 
97ed 22 cc eb				ld (display_fb_active), hl 
97f0			 
97f0			;	nop 
97f0				STACKFRAME ON $fbfe $8f9f 
97f0				if DEBUG_STACK_IMB 
97f0					if ON 
97f0						exx 
97f0						ld de, $fbfe 
97f0						ld a, d 
97f0						ld hl, curframe 
97f0						call hexout 
97f0						ld a, e 
97f0						ld hl, curframe+2 
97f0						call hexout 
97f0						ld hl, $fbfe 
97f0						push hl 
97f0						ld hl, $8f9f 
97f0						push hl 
97f0						exx 
97f0					endif 
97f0				endif 
97f0			endm 
# End of macro STACKFRAME
97f0				; first time into the parser so pass over the current scratch pad 
97f0 21 e8 e5			ld hl,os_cli_cmd 
97f3				; tokenise the entered statement(s) in HL 
97f3 cd 35 9f			call forthparse 
97f6			        ; exec forth statements in top of return stack 
97f6 cd 75 9f			call forthexec 
97f9				;call forthexec_cleanup 
97f9			;	call parsenext 
97f9			 
97f9				STACKFRAMECHK ON $fbfe $8f9f 
97f9				if DEBUG_STACK_IMB 
97f9					if ON 
97f9						exx 
97f9						ld hl, $8f9f 
97f9						pop de   ; $8f9f 
97f9						call cmp16 
97f9						jr nz, .spnosame 
97f9						ld hl, $fbfe 
97f9						pop de   ; $fbfe 
97f9						call cmp16 
97f9						jr z, .spfrsame 
97f9						.spnosame: call showsperror 
97f9						.spfrsame: nop 
97f9						exx 
97f9					endif 
97f9				endif 
97f9			endm 
# End of macro STACKFRAMECHK
97f9				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
97f9			 
97f9 3e 78			ld a, display_row_4 
97fb 11 2c 98			ld de, endprog 
97fe			 
97fe cd d2 8a			call update_display		 
9801			 
9801 cd b2 9a			call next_page_prompt 
9804			 
9804				; switch frame buffer to cli 
9804			 
9804 21 b1 ed				ld hl, display_fb0 
9807 22 cc eb				ld (display_fb_active), hl 
980a			 
980a			 
980a cd af 8a		        call clear_display 
980d cd d2 8a			call update_display		 
9810			 
9810 21 e8 e5			ld hl, os_cli_cmd 
9813			 
9813 3e 00			ld a, 0		 ; init cli input 
9815 77				ld (hl), a 
9816			 
9816				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9816			 
9816				; now on last line 
9816			 
9816				; TODO scroll screen up 
9816			 
9816				; TODO instead just clear screen and place at top of screen 
9816			 
9816			;	ld a, 0 
9816			;	ld (f_cursor_ptr),a 
9816			 
9816				;call clear_display 
9816				;call update_display 
9816			 
9816				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9816 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9818 c3 d3 97			jp cli 
981b			 
981b .. 00		freeram: db "Free bytes: ",0 
9828 ..			asc: db "1A2F" 
982c .. 00		endprog: db "End prog...",0 
9838			 
9838			testenter2:   
9838 21 f3 e2			ld hl,scratch+50 
983b 22 e4 e5			ld (os_cur_ptr),hl 
983e c3 d3 97			jp cli 
9841			 
9841			testenter:  
9841			 
9841 21 28 98			ld hl,asc 
9844			;	ld a,(hl) 
9844			;	call nibble2val 
9844 cd 33 90			call get_byte 
9847			 
9847			 
9847			;	ld a,(hl) 
9847			;	call atohex 
9847			 
9847			;	call fourehexhl 
9847 32 f3 e2			ld (scratch+50),a 
984a			 
984a			 
984a			 
984a 21 2a 98			ld hl,asc+2 
984d			;	ld a, (hl) 
984d			;	call nibble2val 
984d cd 33 90			call get_byte 
9850			 
9850			;	call fourehexhl 
9850 32 f5 e2			ld (scratch+52),a 
9853				 
9853 21 f3 e2			ld hl,scratch+50 
9856 22 e4 e5			ld (os_cur_ptr),hl 
9859 c3 d3 97			jp cli 
985c			 
985c			enter:	 
985c 3a c5 e2			ld a,(scratch+4) 
985f fe 00			cp 0 
9861 28 0c			jr z, .entercont 
9863				; no, not a null term line so has an address to work out.... 
9863			 
9863 21 c3 e2			ld hl,scratch+2 
9866 cd 93 90			call get_word_hl 
9869			 
9869 22 e4 e5			ld (os_cur_ptr),hl	 
986c c3 d3 97			jp cli 
986f			 
986f			 
986f			.entercont:  
986f			 
986f 21 c3 e2			ld hl, scratch+2 
9872 cd 33 90			call get_byte 
9875			 
9875 2a e4 e5		   	ld hl,(os_cur_ptr) 
9878 77					ld (hl),a 
9879 23					inc hl 
987a 22 e4 e5				ld (os_cur_ptr),hl 
987d				 
987d			; get byte  
987d			 
987d			 
987d c3 d3 97			jp cli 
9880			 
9880			 
9880			; basic monitor support 
9880			 
9880			monitor: 
9880				;  
9880 cd af 8a			call clear_display 
9883 3e 00			ld a, 0 
9885 11 d4 98			ld de, .monprompt 
9888 cd c2 8a			call str_at_display 
988b cd d2 8a			call update_display 
988e			 
988e				; get a monitor command 
988e			 
988e 0e 00			ld c, 0     ; entry at top left 
9890 16 64			ld d, 100   ; max buffer size 
9892 1e 0f			ld e, 15    ; input scroll area 
9894 3e 00			ld a, 0     ; init string 
9896 21 bf e4			ld hl, os_input 
9899 77				ld (hl), a 
989a 23				inc hl 
989b 77				ld (hl), a 
989c 21 bf e4			ld hl, os_input 
989f 3e 01			ld a, 1     ; init string 
98a1 cd 09 8d			call input_str 
98a4			 
98a4 cd af 8a		        call clear_display 
98a7 cd d2 8a			call update_display		 
98aa			 
98aa 3a bf e4			ld a, (os_input) 
98ad cd 31 91			call toUpper 
98b0 fe 48		        cp 'H' 
98b2 ca 39 99		        jp z, .monhelp 
98b5 fe 44			cp 'D'		; dump 
98b7 ca 6c 99			jp z, .mondump	 
98ba fe 43			cp 'C'		; dump 
98bc ca 86 99			jp z, .moncdump	 
98bf fe 4d			cp 'M'		; dump 
98c1 ca d6 98			jp z, .moneditstart 
98c4 fe 55			cp 'U'		; dump 
98c6 ca e2 98			jp z, .monedit	 
98c9 fe 47			cp 'G'		; dump 
98cb ca 62 99			jp z, .monjump 
98ce fe 51			cp 'Q'		; dump 
98d0 c8				ret z	 
98d1			 
98d1			 
98d1				; TODO "S" to access symbol by name and not need the address 
98d1				; TODO "F" to find a string in memory 
98d1			 
98d1 c3 80 98			jp monitor 
98d4			 
98d4 .. 00		.monprompt: db ">", 0 
98d6			 
98d6			.moneditstart: 
98d6				; get starting address 
98d6			 
98d6 21 c1 e4			ld hl,os_input+2 
98d9 cd 93 90			call get_word_hl 
98dc			 
98dc 22 e4 e5			ld (os_cur_ptr),hl	 
98df			 
98df c3 80 98			jp monitor 
98e2			 
98e2			.monedit: 
98e2				; get byte to load 
98e2			 
98e2 21 c1 e4			ld hl,os_input+2 
98e5 cd 33 90			call get_byte 
98e8			 
98e8				; get address to update 
98e8 2a e4 e5			ld hl, (os_cur_ptr) 
98eb			 
98eb				; update byte 
98eb			 
98eb 77				ld (hl), a 
98ec			 
98ec				; move to next address and save it 
98ec			 
98ec 23				inc hl 
98ed 22 e4 e5			ld (os_cur_ptr),hl	 
98f0			 
98f0 c3 80 98			jp monitor 
98f3			 
98f3			 
98f3 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9907 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9923 .. 00		.monhelptext3:  db "G-Call address",0 
9932 .. 00		.monhelptext4:  db "Q-Quit",0 
9939			        
9939			.monhelp: 
9939 3e 00			ld a, display_row_1 
993b 11 f3 98		        ld de, .monhelptext1 
993e			 
993e cd c2 8a			call str_at_display 
9941 3e 28			ld a, display_row_2 
9943 11 07 99		        ld de, .monhelptext2 
9946					 
9946 cd c2 8a			call str_at_display 
9949 3e 50			ld a, display_row_3 
994b 11 23 99		        ld de, .monhelptext3 
994e					 
994e cd c2 8a			call str_at_display 
9951 3e 78			ld a, display_row_4 
9953 11 32 99		        ld de, .monhelptext4 
9956 cd c2 8a			call str_at_display 
9959			 
9959 cd d2 8a			call update_display		 
995c			 
995c cd b2 9a			call next_page_prompt 
995f c3 80 98			jp monitor 
9962			 
9962			.monjump:    
9962 21 c1 e4			ld hl,os_input+2 
9965 cd 93 90			call get_word_hl 
9968			 
9968 e9				jp (hl) 
9969 c3 80 98			jp monitor 
996c			 
996c			.mondump:    
996c 21 c1 e4			ld hl,os_input+2 
996f cd 93 90			call get_word_hl 
9972			 
9972 22 e4 e5			ld (os_cur_ptr),hl	 
9975 cd ba 99			call dumpcont 
9978 3e 78			ld a, display_row_4 
997a 11 2c 98			ld de, endprog 
997d			 
997d cd d2 8a			call update_display		 
9980			 
9980 cd b2 9a			call next_page_prompt 
9983 c3 80 98			jp monitor 
9986			.moncdump: 
9986 cd ba 99			call dumpcont 
9989 3e 78			ld a, display_row_4 
998b 11 2c 98			ld de, endprog 
998e			 
998e cd d2 8a			call update_display		 
9991			 
9991 cd b2 9a			call next_page_prompt 
9994 c3 80 98			jp monitor 
9997			 
9997			 
9997			; TODO symbol access  
9997			 
9997			.symbols:     ;; A list of symbols that can be called up  
9997 b1 ed			dw display_fb0 
9999 .. 00			db "fb0",0  
999d 7a ea		     	dw store_page 
999f .. 00			db "store_page",0 
99aa			 
99aa			 
99aa			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
99aa			 
99aa 3a c2 e2			ld a,(scratch+1) 
99ad fe 00			cp 0 
99af 28 09			jr z, dumpcont 
99b1			 
99b1				; no, not a null term line so has an address to work out.... 
99b1			 
99b1 21 c3 e2			ld hl,scratch+2 
99b4 cd 93 90			call get_word_hl 
99b7			 
99b7 22 e4 e5			ld (os_cur_ptr),hl	 
99ba			 
99ba			 
99ba			 
99ba			dumpcont: 
99ba			 
99ba				; dump bytes at ptr 
99ba			 
99ba			 
99ba 3e 00			ld a, display_row_1 
99bc 2a cc eb			ld hl, (display_fb_active) 
99bf cd dc 8c			call addatohl 
99c2 cd ea 99			call .dumpbyterow 
99c5			 
99c5 3e 28			ld a, display_row_2 
99c7 2a cc eb			ld hl, (display_fb_active) 
99ca cd dc 8c			call addatohl 
99cd cd ea 99			call .dumpbyterow 
99d0			 
99d0			 
99d0 3e 50			ld a, display_row_3 
99d2 2a cc eb			ld hl, (display_fb_active) 
99d5 cd dc 8c			call addatohl 
99d8 cd ea 99			call .dumpbyterow 
99db			 
99db 3e 78			ld a, display_row_4 
99dd 2a cc eb			ld hl, (display_fb_active) 
99e0 cd dc 8c			call addatohl 
99e3 cd ea 99			call .dumpbyterow 
99e6			 
99e6 cd d2 8a			call update_display 
99e9			;		jp cli 
99e9 c9				ret 
99ea			 
99ea			.dumpbyterow: 
99ea			 
99ea				;push af 
99ea			 
99ea e5				push hl 
99eb			 
99eb				; calc where to poke the ascii 
99eb			if display_cols == 20 
99eb				ld a, 16 
99eb			else 
99eb 3e 1f			ld a, 31 
99ed			endif 
99ed			 
99ed cd dc 8c			call addatohl 
99f0 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
99f3			 
99f3			 
99f3			; display decoding address 
99f3 2a e4 e5		   	ld hl,(os_cur_ptr) 
99f6			 
99f6 7c				ld a,h 
99f7 e1				pop hl 
99f8 e5				push hl 
99f9			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
99f9 cd dd 8f			call hexout 
99fc 2a e4 e5		   	ld hl,(os_cur_ptr) 
99ff			 
99ff 7d				ld a,l 
9a00 e1				pop hl 
9a01 23				inc hl 
9a02 23				inc hl 
9a03 e5				push hl 
9a04			;	ld hl, os_word_scratch+2 
9a04 cd dd 8f			call hexout 
9a07 e1				pop hl 
9a08 23				inc hl 
9a09 23				inc hl 
9a0a				;ld hl, os_word_scratch+4 
9a0a 3e 3a			ld a, ':' 
9a0c 77				ld (hl),a 
9a0d 23				inc hl 
9a0e				;ld a, 0 
9a0e				;ld (hl),a 
9a0e				;ld de, os_word_scratch 
9a0e				;pop af 
9a0e				;push af 
9a0e			;		ld a, display_row_2 
9a0e			;		call str_at_display 
9a0e			;		call update_display 
9a0e			 
9a0e			 
9a0e			;pop af 
9a0e			;	add 5 
9a0e			 
9a0e			if display_cols == 20 
9a0e				ld b, 4 
9a0e			else 
9a0e 06 08			ld b, 8 
9a10			endif	 
9a10			 
9a10			.dumpbyte: 
9a10 c5				push bc 
9a11 e5				push hl 
9a12			 
9a12			 
9a12 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a15 7e					ld a,(hl) 
9a16			 
9a16					; poke the ascii to display 
9a16 2a c6 e5				ld hl,(os_word_scratch) 
9a19 77					ld (hl),a 
9a1a 23					inc hl 
9a1b 22 c6 e5				ld (os_word_scratch),hl 
9a1e			 
9a1e					 
9a1e			 
9a1e			 
9a1e e1					pop hl 
9a1f e5					push hl 
9a20			 
9a20 cd dd 8f				call hexout 
9a23			 
9a23					 
9a23 2a e4 e5		   	ld hl,(os_cur_ptr) 
9a26 23				inc hl 
9a27 22 e4 e5		   	ld (os_cur_ptr),hl 
9a2a			 
9a2a e1					pop hl 
9a2b 23					inc hl 
9a2c 23					inc hl 
9a2d 23					inc hl 
9a2e			 
9a2e			 
9a2e			 
9a2e					;ld a,0 
9a2e					;ld (os_word_scratch+2),a 
9a2e					;pop af 
9a2e					;push af 
9a2e			 
9a2e					;ld de, os_word_scratch 
9a2e					;call str_at_display 
9a2e			;		call update_display 
9a2e			;		pop af 
9a2e c1					pop bc 
9a2f c6 03				add 3 
9a31 10 dd			djnz .dumpbyte 
9a33			 
9a33				 
9a33			 
9a33 c9				ret 
9a34			 
9a34			jump:	 
9a34			 
9a34 21 c3 e2			ld hl,scratch+2 
9a37 cd 93 90			call get_word_hl 
9a3a				;ld hl,(scratch+2) 
9a3a				;call fourehexhl 
9a3a			 
9a3a 22 e4 e5			ld (os_cur_ptr),hl	 
9a3d			 
9a3d e9				jp (hl) 
9a3e			 
9a3e			 
9a3e			 
9a3e			; TODO implement a basic monitor mode to start with 
9a3e			 
9a3e			 
9a3e			 
9a3e			 
9a3e			 
9a3e			 
9a3e			 
9a3e			 
9a3e			 
9a3e			; testing and demo code during development 
9a3e			 
9a3e			 
9a3e .. 00		str1: db "Enter some text...",0 
9a51 .. 00		clear: db "                    ",0 
9a66			 
9a66			demo: 
9a66			 
9a66			 
9a66			 
9a66			;	call update_display 
9a66			 
9a66				; init scratch input area for testing 
9a66 21 c1 e2			ld hl, scratch	 
9a69 3e 00			ld a,0 
9a6b 77				ld (hl),a 
9a6c			 
9a6c			 
9a6c 3e 28		            LD   A, display_row_2 
9a6e			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a6e 11 3e 9a		            LD   DE, str1 
9a71 cd c2 8a			call str_at_display 
9a74			 
9a74			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a74			cloop:	 
9a74 3e 50		            LD   A, display_row_3 
9a76			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a76 11 51 9a		            LD   DE, clear 
9a79			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9a79 cd c2 8a				call str_at_display 
9a7c 3e 78			ld a, display_row_4 
9a7e 11 ae 9a			ld de, prompt 
9a81			 
9a81 cd c2 8a				call str_at_display 
9a84 cd d2 8a			call update_display 
9a87			 
9a87 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9a89 16 0a			ld d, 10 
9a8b 21 c1 e2			ld hl, scratch	 
9a8e cd 09 8d			call input_str 
9a91			 
9a91			;	call clear_display 
9a91			;'	call update_display 
9a91			 
9a91 3e 00		            LD   A, display_row_1 
9a93			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a93 11 51 9a		            LD   DE, clear 
9a96 cd c2 8a				call str_at_display 
9a99			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a99 3e 00		            LD   A, display_row_1 
9a9b			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a9b 11 c1 e2		            LD   DE, scratch 
9a9e			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a9e cd c2 8a				call str_at_display 
9aa1 cd d2 8a			call update_display 
9aa4			 
9aa4 3e 00				ld a,0 
9aa6 21 c1 e2			ld hl, scratch 
9aa9 77				ld (hl),a 
9aaa			 
9aaa 00				nop 
9aab c3 74 9a			jp cloop 
9aae			 
9aae			 
9aae			 
9aae			; OS Prompt 
9aae			 
9aae .. 00		prompt: db ">",0 
9ab0 .. 00		endprg: db "?",0 
9ab2			 
9ab2			 
9ab2			; handy next page prompt 
9ab2			next_page_prompt: 
9ab2 e5				push hl 
9ab3 d5				push de 
9ab4 f5				push af 
9ab5 c5				push bc 
9ab6			 
9ab6 3e 9f			ld a,display_row_4 + display_cols - 1 
9ab8 11 b0 9a		        ld de, endprg 
9abb cd c2 8a			call str_at_display 
9abe cd d2 8a			call update_display 
9ac1 cd 17 e4			call cin_wait 
9ac4 c1				pop bc 
9ac5 f1				pop af 
9ac6 d1				pop de 
9ac7 e1				pop hl 
9ac8			 
9ac8			 
9ac8 c9				ret 
9ac9			 
9ac9			 
9ac9			; forth parser 
9ac9			 
9ac9			; My forth kernel 
9ac9			include "forth_kernel.asm" 
9ac9			; 
9ac9			; kernel to the forth OS 
9ac9			 
9ac9			DS_TYPE_STR: equ 1     ; string type 
9ac9			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9ac9			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9ac9			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9ac9			 
9ac9			FORTH_PARSEV1: equ 0 
9ac9			FORTH_PARSEV2: equ 0 
9ac9			FORTH_PARSEV3: equ 0 
9ac9			FORTH_PARSEV4: equ 0 
9ac9			FORTH_PARSEV5: equ 1 
9ac9			 
9ac9			;if FORTH_PARSEV5 
9ac9			;	FORTH_END_BUFFER: equ 0 
9ac9			;else 
9ac9			FORTH_END_BUFFER: equ 127 
9ac9			;endif 
9ac9			 
9ac9			FORTH_TRUE: equ 1 
9ac9			FORTH_FALSE: equ 0 
9ac9			 
9ac9			if FORTH_PARSEV4 
9ac9			include "forth_stackops.asm" 
9ac9			endif 
9ac9			 
9ac9			if FORTH_PARSEV5 
9ac9			include "forth_stackopsv5.asm" 
9ac9			 
9ac9			; Stack operations for v5 parser on wards 
9ac9			; * DATA stack 
9ac9			; * LOOP stack 
9ac9			; * RETURN stack 
9ac9			 
9ac9			 
9ac9			 
9ac9			FORTH_CHK_DSP_UNDER: macro 
9ac9				push hl 
9ac9				push de 
9ac9				ld hl,(cli_data_sp) 
9ac9				ld de, cli_data_stack 
9ac9				call cmp16 
9ac9				jp c, fault_dsp_under 
9ac9				pop de 
9ac9				pop hl 
9ac9				endm 
9ac9			 
9ac9			 
9ac9			FORTH_CHK_RSP_UNDER: macro 
9ac9				push hl 
9ac9				push de 
9ac9				ld hl,(cli_ret_sp) 
9ac9				ld de, cli_ret_stack 
9ac9				call cmp16 
9ac9				jp c, fault_rsp_under 
9ac9				pop de 
9ac9				pop hl 
9ac9				endm 
9ac9			 
9ac9			FORTH_CHK_LOOP_UNDER: macro 
9ac9				push hl 
9ac9				push de 
9ac9				ld hl,(cli_loop_sp) 
9ac9				ld de, cli_loop_stack 
9ac9				call cmp16 
9ac9				jp c, fault_loop_under 
9ac9				pop de 
9ac9				pop hl 
9ac9				endm 
9ac9			 
9ac9			FORTH_ERR_TOS_NOTSTR: macro 
9ac9				; TOSO might need more for checks when used 
9ac9				push af 
9ac9				ld a,(hl) 
9ac9				cp DS_TYPE_STR 
9ac9				jp nz, type_faultn   
9ac9				pop af 
9ac9				endm 
9ac9			 
9ac9			FORTH_ERR_TOS_NOTNUM: macro 
9ac9				push af 
9ac9				ld a,(hl) 
9ac9				cp DS_TYPE_INUM 
9ac9				jp nz, type_faultn   
9ac9				pop af 
9ac9				endm 
9ac9			 
9ac9			 
9ac9			; increase data stack pointer and save hl to it 
9ac9				 
9ac9			FORTH_DSP_NEXT: macro 
9ac9				call macro_forth_dsp_next 
9ac9				endm 
9ac9			 
9ac9			 
9ac9			macro_forth_dsp_next: 
9ac9				if DEBUG_FORTH_STACK_GUARD 
9ac9 cd 92 e0				call check_stacks 
9acc				endif 
9acc e5				push hl 
9acd d5				push de 
9ace eb				ex de,hl 
9acf 2a ee e9			ld hl,(cli_data_sp) 
9ad2 23				inc hl 
9ad3 23				inc hl 
9ad4			 
9ad4			; PARSEV5 
9ad4 23				inc hl 
9ad5 22 ee e9			ld (cli_data_sp),hl 
9ad8 73				ld (hl), e 
9ad9 23				inc hl 
9ada 72				ld (hl), d 
9adb d1				pop de 
9adc e1				pop hl 
9add				if DEBUG_FORTH_STACK_GUARD 
9add cd 92 e0				call check_stacks 
9ae0				endif 
9ae0 c9				ret 
9ae1			 
9ae1			 
9ae1			; increase ret stack pointer and save hl to it 
9ae1				 
9ae1			FORTH_RSP_NEXT: macro 
9ae1				call macro_forth_rsp_next 
9ae1				endm 
9ae1			 
9ae1			macro_forth_rsp_next: 
9ae1				if DEBUG_FORTH_STACK_GUARD 
9ae1 cd 92 e0				call check_stacks 
9ae4				endif 
9ae4 e5				push hl 
9ae5 d5				push de 
9ae6 eb				ex de,hl 
9ae7 2a f2 e9			ld hl,(cli_ret_sp) 
9aea 23				inc hl 
9aeb 23				inc hl 
9aec 22 f2 e9			ld (cli_ret_sp),hl 
9aef 73				ld (hl), e 
9af0 23				inc hl 
9af1 72				ld (hl), d 
9af2 d1				pop de 
9af3 e1				pop hl 
9af4				if DEBUG_FORTH_STACK_GUARD 
9af4 cd 92 e0				call check_stacks 
9af7				endif 
9af7 c9				ret 
9af8			 
9af8			; get current ret stack pointer and save to hl  
9af8				 
9af8			FORTH_RSP_TOS: macro 
9af8				call macro_forth_rsp_tos 
9af8				endm 
9af8			 
9af8			macro_forth_rsp_tos: 
9af8				;push de 
9af8 2a f2 e9			ld hl,(cli_ret_sp) 
9afb cd 33 9b			call loadhlptrtohl 
9afe				;ld e, (hl) 
9afe				;inc hl 
9afe				;ld d, (hl) 
9afe				;ex de, hl 
9afe					if DEBUG_FORTH_WORDS 
9afe			;			DMARK "RST" 
9afe						CALLMONITOR 
9afe cd 6f ee			call debug_vector  
9b01				endm  
# End of macro CALLMONITOR
9b01					endif 
9b01				;pop de 
9b01 c9				ret 
9b02			 
9b02			; pop ret stack pointer 
9b02				 
9b02			FORTH_RSP_POP: macro 
9b02				call macro_forth_rsp_pop 
9b02				endm 
9b02			 
9b02			 
9b02			macro_forth_rsp_pop: 
9b02				if DEBUG_FORTH_STACK_GUARD 
9b02			;		DMARK "RPP" 
9b02 cd 92 e0				call check_stacks 
9b05					FORTH_CHK_RSP_UNDER 
9b05 e5				push hl 
9b06 d5				push de 
9b07 2a f2 e9			ld hl,(cli_ret_sp) 
9b0a 11 ac e9			ld de, cli_ret_stack 
9b0d cd fa 8c			call cmp16 
9b10 da a6 e1			jp c, fault_rsp_under 
9b13 d1				pop de 
9b14 e1				pop hl 
9b15				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b15				endif 
9b15 e5				push hl 
9b16 2a f2 e9			ld hl,(cli_ret_sp) 
9b19			 
9b19			 
9b19				if FORTH_ENABLE_FREE 
9b19			 
9b19					; get pointer 
9b19			 
9b19					push de 
9b19					push hl 
9b19			 
9b19					ld e, (hl) 
9b19					inc hl 
9b19					ld d, (hl) 
9b19			 
9b19					ex de, hl 
9b19					call free 
9b19			 
9b19					pop hl 
9b19					pop de 
9b19			 
9b19			 
9b19				endif 
9b19			 
9b19			 
9b19 2b				dec hl 
9b1a 2b				dec hl 
9b1b 22 f2 e9			ld (cli_ret_sp), hl 
9b1e				; do stack underflow checks 
9b1e e1				pop hl 
9b1f				if DEBUG_FORTH_STACK_GUARD 
9b1f cd 92 e0				call check_stacks 
9b22					FORTH_CHK_RSP_UNDER 
9b22 e5				push hl 
9b23 d5				push de 
9b24 2a f2 e9			ld hl,(cli_ret_sp) 
9b27 11 ac e9			ld de, cli_ret_stack 
9b2a cd fa 8c			call cmp16 
9b2d da a6 e1			jp c, fault_rsp_under 
9b30 d1				pop de 
9b31 e1				pop hl 
9b32				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b32				endif 
9b32 c9				ret 
9b33			 
9b33			 
9b33			 
9b33			; routine to load word pointed to by hl into hl 
9b33			 
9b33			loadhlptrtohl: 
9b33			 
9b33 d5				push de 
9b34 5e				ld e, (hl) 
9b35 23				inc hl 
9b36 56				ld d, (hl) 
9b37 eb				ex de, hl 
9b38 d1				pop de 
9b39			 
9b39 c9				ret 
9b3a			 
9b3a			 
9b3a			 
9b3a			 
9b3a			 
9b3a			; push a number held in HL onto the data stack 
9b3a			; entry point for pushing a value when already in hl used in function above 
9b3a			 
9b3a			forth_push_numhl: 
9b3a			 
9b3a e5				push hl    ; save value to push 
9b3b			 
9b3b			if DEBUG_FORTH_PUSH 
9b3b				; see if disabled 
9b3b			 
9b3b			 
9b3b f5				push af 
9b3c 3a 6f ee			ld a,(debug_vector) 
9b3f fe c9			cp $c9   ; ret 
9b41			;	ld a, (os_view_disable) 
9b41			;	cp '*' 
9b41 28 34			jr z, .pskip2 
9b43 e5				push hl 
9b44 e5			push hl 
9b45 cd af 8a			call clear_display 
9b48 e1			pop hl 
9b49 7c				ld a,h 
9b4a 21 c6 e5			ld hl, os_word_scratch 
9b4d cd dd 8f			call hexout 
9b50 e1				pop hl 
9b51 7d				ld a,l 
9b52 21 c8 e5			ld hl, os_word_scratch+2 
9b55 cd dd 8f			call hexout 
9b58			 
9b58 21 ca e5			ld hl, os_word_scratch+4 
9b5b 3e 00			ld a,0 
9b5d 77				ld (hl),a 
9b5e 11 c6 e5			ld de,os_word_scratch 
9b61 3e 28				ld a, display_row_2 
9b63 cd c2 8a				call str_at_display 
9b66 11 ce cb			ld de, .push_num 
9b69 3e 00			ld a, display_row_1 
9b6b			 
9b6b cd c2 8a				call str_at_display 
9b6e			 
9b6e			 
9b6e cd d2 8a			call update_display 
9b71 cd f2 89			call delay1s 
9b74 cd f2 89			call delay1s 
9b77			.pskip2:  
9b77			 
9b77 f1				pop af 
9b78			endif	 
9b78			 
9b78			 
9b78				FORTH_DSP_NEXT 
9b78 cd c9 9a			call macro_forth_dsp_next 
9b7b				endm 
# End of macro FORTH_DSP_NEXT
9b7b			 
9b7b 2a ee e9			ld hl, (cli_data_sp) 
9b7e			 
9b7e				; save item type 
9b7e 3e 02			ld a,  DS_TYPE_INUM 
9b80 77				ld (hl), a 
9b81 23				inc hl 
9b82			 
9b82				; get word off stack 
9b82 d1				pop de 
9b83 7b				ld a,e 
9b84 77				ld (hl), a 
9b85 23				inc hl 
9b86 7a				ld a,d 
9b87 77				ld (hl), a 
9b88			 
9b88			if DEBUG_FORTH_PUSH 
9b88 2b				dec hl 
9b89 2b				dec hl 
9b8a 2b				dec hl 
9b8b						DMARK "PH5" 
9b8b f5				push af  
9b8c 3a a0 9b			ld a, (.dmark)  
9b8f 32 6b ee			ld (debug_mark),a  
9b92 3a a1 9b			ld a, (.dmark+1)  
9b95 32 6c ee			ld (debug_mark+1),a  
9b98 3a a2 9b			ld a, (.dmark+2)  
9b9b 32 6d ee			ld (debug_mark+2),a  
9b9e 18 03			jr .pastdmark  
9ba0 ..			.dmark: db "PH5"  
9ba3 f1			.pastdmark: pop af  
9ba4			endm  
# End of macro DMARK
9ba4				CALLMONITOR 
9ba4 cd 6f ee			call debug_vector  
9ba7				endm  
# End of macro CALLMONITOR
9ba7			endif	 
9ba7			 
9ba7 c9				ret 
9ba8			 
9ba8			 
9ba8			; Push a string to stack pointed to by hl 
9ba8			 
9ba8			forth_push_str: 
9ba8			 
9ba8			if DEBUG_FORTH_PUSH 
9ba8						DMARK "PSQ" 
9ba8 f5				push af  
9ba9 3a bd 9b			ld a, (.dmark)  
9bac 32 6b ee			ld (debug_mark),a  
9baf 3a be 9b			ld a, (.dmark+1)  
9bb2 32 6c ee			ld (debug_mark+1),a  
9bb5 3a bf 9b			ld a, (.dmark+2)  
9bb8 32 6d ee			ld (debug_mark+2),a  
9bbb 18 03			jr .pastdmark  
9bbd ..			.dmark: db "PSQ"  
9bc0 f1			.pastdmark: pop af  
9bc1			endm  
# End of macro DMARK
9bc1				CALLMONITOR 
9bc1 cd 6f ee			call debug_vector  
9bc4				endm  
# End of macro CALLMONITOR
9bc4			endif	 
9bc4			    
9bc4 e5				push hl 
9bc5 e5				push hl 
9bc6			 
9bc6			;	ld a, 0   ; find end of string 
9bc6 cd 3a 91			call strlenz 
9bc9			if DEBUG_FORTH_PUSH 
9bc9						DMARK "PQ2" 
9bc9 f5				push af  
9bca 3a de 9b			ld a, (.dmark)  
9bcd 32 6b ee			ld (debug_mark),a  
9bd0 3a df 9b			ld a, (.dmark+1)  
9bd3 32 6c ee			ld (debug_mark+1),a  
9bd6 3a e0 9b			ld a, (.dmark+2)  
9bd9 32 6d ee			ld (debug_mark+2),a  
9bdc 18 03			jr .pastdmark  
9bde ..			.dmark: db "PQ2"  
9be1 f1			.pastdmark: pop af  
9be2			endm  
# End of macro DMARK
9be2				CALLMONITOR 
9be2 cd 6f ee			call debug_vector  
9be5				endm  
# End of macro CALLMONITOR
9be5			endif	 
9be5 eb				ex de, hl 
9be6 e1				pop hl   ; get ptr to start of string 
9be7			if DEBUG_FORTH_PUSH 
9be7						DMARK "PQ3" 
9be7 f5				push af  
9be8 3a fc 9b			ld a, (.dmark)  
9beb 32 6b ee			ld (debug_mark),a  
9bee 3a fd 9b			ld a, (.dmark+1)  
9bf1 32 6c ee			ld (debug_mark+1),a  
9bf4 3a fe 9b			ld a, (.dmark+2)  
9bf7 32 6d ee			ld (debug_mark+2),a  
9bfa 18 03			jr .pastdmark  
9bfc ..			.dmark: db "PQ3"  
9bff f1			.pastdmark: pop af  
9c00			endm  
# End of macro DMARK
9c00				CALLMONITOR 
9c00 cd 6f ee			call debug_vector  
9c03				endm  
# End of macro CALLMONITOR
9c03			endif	 
9c03 19				add hl,de 
9c04			if DEBUG_FORTH_PUSH 
9c04						DMARK "PQE" 
9c04 f5				push af  
9c05 3a 19 9c			ld a, (.dmark)  
9c08 32 6b ee			ld (debug_mark),a  
9c0b 3a 1a 9c			ld a, (.dmark+1)  
9c0e 32 6c ee			ld (debug_mark+1),a  
9c11 3a 1b 9c			ld a, (.dmark+2)  
9c14 32 6d ee			ld (debug_mark+2),a  
9c17 18 03			jr .pastdmark  
9c19 ..			.dmark: db "PQE"  
9c1c f1			.pastdmark: pop af  
9c1d			endm  
# End of macro DMARK
9c1d				CALLMONITOR 
9c1d cd 6f ee			call debug_vector  
9c20				endm  
# End of macro CALLMONITOR
9c20			endif	 
9c20			 
9c20 2b				dec hl    ; see if there is an optional trailing double quote 
9c21 7e				ld a,(hl) 
9c22 fe 22			cp '"' 
9c24 20 03			jr nz, .strnoq 
9c26 3e 00			ld a, 0      ; get rid of double quote 
9c28 77				ld (hl), a 
9c29 23			.strnoq: inc hl 
9c2a			 
9c2a 3e 00			ld a, 0 
9c2c 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9c2d			 
9c2d 13				inc de ; add one for the type string 
9c2e 13				inc de ; add one for null term??? 
9c2f			 
9c2f				; tos is get string pointer again 
9c2f				; de contains space to allocate 
9c2f				 
9c2f d5				push de 
9c30			 
9c30 eb				ex de, hl 
9c31			 
9c31				;push af 
9c31			 
9c31			if DEBUG_FORTH_PUSH 
9c31						DMARK "PHm" 
9c31 f5				push af  
9c32 3a 46 9c			ld a, (.dmark)  
9c35 32 6b ee			ld (debug_mark),a  
9c38 3a 47 9c			ld a, (.dmark+1)  
9c3b 32 6c ee			ld (debug_mark+1),a  
9c3e 3a 48 9c			ld a, (.dmark+2)  
9c41 32 6d ee			ld (debug_mark+2),a  
9c44 18 03			jr .pastdmark  
9c46 ..			.dmark: db "PHm"  
9c49 f1			.pastdmark: pop af  
9c4a			endm  
# End of macro DMARK
9c4a				CALLMONITOR 
9c4a cd 6f ee			call debug_vector  
9c4d				endm  
# End of macro CALLMONITOR
9c4d			endif	 
9c4d cd a3 91			call malloc	; on ret hl now contains allocated memory 
9c50				if DEBUG_FORTH_MALLOC_GUARD 
9c50 cc 26 cc				call z,malloc_error 
9c53				endif 
9c53			 
9c53				 
9c53 c1				pop bc    ; get length 
9c54 d1				pop de   ;  get string start    
9c55			 
9c55				; hl has destination from malloc 
9c55			 
9c55 eb				ex de, hl    ; prep for ldir 
9c56			 
9c56 d5				push de   ; save malloc area for DSP later 
9c57				;push hl   ; save malloc area for DSP later 
9c57			 
9c57			if DEBUG_FORTH_PUSH 
9c57						DMARK "PHc" 
9c57 f5				push af  
9c58 3a 6c 9c			ld a, (.dmark)  
9c5b 32 6b ee			ld (debug_mark),a  
9c5e 3a 6d 9c			ld a, (.dmark+1)  
9c61 32 6c ee			ld (debug_mark+1),a  
9c64 3a 6e 9c			ld a, (.dmark+2)  
9c67 32 6d ee			ld (debug_mark+2),a  
9c6a 18 03			jr .pastdmark  
9c6c ..			.dmark: db "PHc"  
9c6f f1			.pastdmark: pop af  
9c70			endm  
# End of macro DMARK
9c70				CALLMONITOR 
9c70 cd 6f ee			call debug_vector  
9c73				endm  
# End of macro CALLMONITOR
9c73			endif	 
9c73			 
9c73			 
9c73 ed b0			ldir 
9c75			 
9c75			 
9c75				; push malloc to data stack     macro?????  
9c75			 
9c75				FORTH_DSP_NEXT 
9c75 cd c9 9a			call macro_forth_dsp_next 
9c78				endm 
# End of macro FORTH_DSP_NEXT
9c78			 
9c78				; save value and type 
9c78			 
9c78 2a ee e9			ld hl, (cli_data_sp) 
9c7b			 
9c7b				; save item type 
9c7b 3e 01			ld a,  DS_TYPE_STR 
9c7d 77				ld (hl), a 
9c7e 23				inc hl 
9c7f			 
9c7f				; get malloc word off stack 
9c7f d1				pop de 
9c80 73				ld (hl), e 
9c81 23				inc hl 
9c82 72				ld (hl), d 
9c83			 
9c83			 
9c83			 
9c83			if DEBUG_FORTH_PUSH 
9c83 2a ee e9			ld hl, (cli_data_sp) 
9c86						DMARK "PHS" 
9c86 f5				push af  
9c87 3a 9b 9c			ld a, (.dmark)  
9c8a 32 6b ee			ld (debug_mark),a  
9c8d 3a 9c 9c			ld a, (.dmark+1)  
9c90 32 6c ee			ld (debug_mark+1),a  
9c93 3a 9d 9c			ld a, (.dmark+2)  
9c96 32 6d ee			ld (debug_mark+2),a  
9c99 18 03			jr .pastdmark  
9c9b ..			.dmark: db "PHS"  
9c9e f1			.pastdmark: pop af  
9c9f			endm  
# End of macro DMARK
9c9f				CALLMONITOR 
9c9f cd 6f ee			call debug_vector  
9ca2				endm  
# End of macro CALLMONITOR
9ca2			;	ex de,hl 
9ca2			endif	 
9ca2				; in case of spaces, skip the ptr past the copied string 
9ca2				;pop af 
9ca2				;ld (cli_origptr),hl 
9ca2			 
9ca2 c9				ret 
9ca3			 
9ca3			 
9ca3			 
9ca3			; TODO ascii push input onto stack given hl to start of input 
9ca3			 
9ca3			; identify type 
9ca3			; if starts with a " then a string 
9ca3			; otherwise it is a number 
9ca3			;  
9ca3			; if a string 
9ca3			;     scan for ending " to get length of string to malloc for + 1 
9ca3			;     malloc 
9ca3			;     put pointer to string on stack first byte flags as string 
9ca3			; 
9ca3			; else a number 
9ca3			;    look for number format identifier 
9ca3			;    $xx hex 
9ca3			;    %xxxxx bin 
9ca3			;    xxxxx decimal 
9ca3			;    convert number to 16bit word.  
9ca3			;    malloc word + 1 with flag to identiy as num 
9ca3			;    put pointer to number on stack 
9ca3			;   
9ca3			;  
9ca3			  
9ca3			forth_apush: 
9ca3				; kernel push 
9ca3			 
9ca3			if DEBUG_FORTH_PUSH 
9ca3						DMARK "PSH" 
9ca3 f5				push af  
9ca4 3a b8 9c			ld a, (.dmark)  
9ca7 32 6b ee			ld (debug_mark),a  
9caa 3a b9 9c			ld a, (.dmark+1)  
9cad 32 6c ee			ld (debug_mark+1),a  
9cb0 3a ba 9c			ld a, (.dmark+2)  
9cb3 32 6d ee			ld (debug_mark+2),a  
9cb6 18 03			jr .pastdmark  
9cb8 ..			.dmark: db "PSH"  
9cbb f1			.pastdmark: pop af  
9cbc			endm  
# End of macro DMARK
9cbc				CALLMONITOR 
9cbc cd 6f ee			call debug_vector  
9cbf				endm  
# End of macro CALLMONITOR
9cbf			endif	 
9cbf				; identify input type 
9cbf			 
9cbf 7e				ld a,(hl) 
9cc0 fe 22			cp '"' 
9cc2 28 0a			jr z, .fapstr 
9cc4 fe 24			cp '$' 
9cc6 ca ee 9c			jp z, .faphex 
9cc9 fe 25			cp '%' 
9ccb ca d6 9c			jp z, .fapbin 
9cce			;	cp 'b' 
9cce			;	jp z, .fabin 
9cce				; else decimal 
9cce			 
9cce				; TODO do decimal conversion 
9cce				; decimal is stored as a 16bit word 
9cce			 
9cce				; by default everything is a string if type is not detected 
9cce			.fapstr: ; 
9cce fe 22			cp '"' 
9cd0 20 01			jr nz, .strnoqu 
9cd2 23				inc hl 
9cd3			.strnoqu: 
9cd3 c3 a8 9b			jp forth_push_str 
9cd6			 
9cd6			 
9cd6			 
9cd6			.fapbin:    ; push a binary string.  
9cd6 11 00 00			ld de, 0   ; hold a 16bit value 
9cd9			 
9cd9 23			.fapbinshift:	inc hl  
9cda 7e				ld a,(hl) 
9cdb fe 00			cp 0     ; done scanning  
9cdd 28 0b			jr z, .fapbdone  	; got it in HL so push  
9cdf			 
9cdf				; left shift de 
9cdf eb				ex de, hl	 
9ce0 29				add hl, hl 
9ce1			 
9ce1				; is 1 
9ce1 fe 31			cp '1' 
9ce3 20 02			jr nz, .binzero 
9ce5 cb 4d			bit 1, l 
9ce7			.binzero: 
9ce7 eb				ex de, hl	 ; save current de 
9ce8 18 ef			jr .fapbinshift 
9cea			 
9cea			.fapbdone: 
9cea eb				ex de, hl 
9ceb c3 3a 9b			jp forth_push_numhl 
9cee			 
9cee			 
9cee			.faphex:   ; hex is always stored as a 16bit word 
9cee				; skip number prefix 
9cee 23				inc hl 
9cef				; turn ascii into number 
9cef cd 93 90			call get_word_hl	; ret 16bit word in hl 
9cf2			 
9cf2 c3 3a 9b			jp forth_push_numhl 
9cf5			 
9cf5 00				 nop 
9cf6			 
9cf6			.fabin:   ; TODO bin conversion 
9cf6			 
9cf6			 
9cf6 c9				ret 
9cf7			 
9cf7			 
9cf7			; get either a string ptr or a 16bit word from the data stack 
9cf7			 
9cf7			FORTH_DSP: macro 
9cf7				call macro_forth_dsp 
9cf7				endm 
9cf7			 
9cf7			macro_forth_dsp: 
9cf7				; data stack pointer points to current word on tos 
9cf7			 
9cf7 2a ee e9			ld hl,(cli_data_sp) 
9cfa			 
9cfa				if DEBUG_FORTH_PUSH 
9cfa						DMARK "DSP" 
9cfa f5				push af  
9cfb 3a 0f 9d			ld a, (.dmark)  
9cfe 32 6b ee			ld (debug_mark),a  
9d01 3a 10 9d			ld a, (.dmark+1)  
9d04 32 6c ee			ld (debug_mark+1),a  
9d07 3a 11 9d			ld a, (.dmark+2)  
9d0a 32 6d ee			ld (debug_mark+2),a  
9d0d 18 03			jr .pastdmark  
9d0f ..			.dmark: db "DSP"  
9d12 f1			.pastdmark: pop af  
9d13			endm  
# End of macro DMARK
9d13			 
9d13 cd 59 cc				call display_data_sp 
9d16				;call break_point_state 
9d16				;rst 030h 
9d16				CALLMONITOR 
9d16 cd 6f ee			call debug_vector  
9d19				endm  
# End of macro CALLMONITOR
9d19				endif 
9d19			 
9d19 c9				ret 
9d1a			 
9d1a			; return hl to start of value on stack 
9d1a			 
9d1a			FORTH_DSP_VALUE: macro 
9d1a				call macro_forth_dsp_value 
9d1a				endm 
9d1a			 
9d1a			macro_forth_dsp_value: 
9d1a			 
9d1a				FORTH_DSP 
9d1a cd f7 9c			call macro_forth_dsp 
9d1d				endm 
# End of macro FORTH_DSP
9d1d			 
9d1d d5				push de 
9d1e			 
9d1e 23				inc hl ; skip type 
9d1f			 
9d1f 5e				ld e, (hl) 
9d20 23				inc hl 
9d21 56				ld d, (hl) 
9d22 eb				ex de,hl  
9d23			 
9d23 d1				pop de 
9d24			 
9d24 c9				ret 
9d25			 
9d25			; return hl to start of value to second item on stack 
9d25			 
9d25			FORTH_DSP_VALUEM1: macro 
9d25				call macro_forth_dsp_value_m1 
9d25				endm 
9d25			 
9d25			macro_forth_dsp_value_m1: 
9d25			 
9d25				FORTH_DSP 
9d25 cd f7 9c			call macro_forth_dsp 
9d28				endm 
# End of macro FORTH_DSP
9d28			 
9d28 2b				dec hl 
9d29 2b				dec hl 
9d2a			;	dec hl 
9d2a			 
9d2a d5				push de 
9d2b			 
9d2b 5e				ld e, (hl) 
9d2c 23				inc hl 
9d2d 56				ld d, (hl) 
9d2e eb				ex de,hl  
9d2f			 
9d2f d1				pop de 
9d30			 
9d30 c9				ret 
9d31			 
9d31				 
9d31			 
9d31			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9d31			 
9d31			FORTH_DSP_POP: macro 
9d31				call macro_forth_dsp_pop 
9d31				endm 
9d31			 
9d31			 
9d31			; get the tos data type 
9d31			 
9d31			FORTH_DSP_TYPE:   macro 
9d31			 
9d31				;FORTH_DSP_VALUE 
9d31				FORTH_DSP 
9d31				 
9d31				; hl points to value 
9d31				; check type 
9d31			 
9d31				ld a,(hl) 
9d31			 
9d31				endm 
9d31			 
9d31			; load the tos value into hl 
9d31			 
9d31			 
9d31			FORTH_DSP_VALUEHL:  macro 
9d31				call macro_dsp_valuehl 
9d31				endm 
9d31			 
9d31			 
9d31			 
9d31			macro_dsp_valuehl: 
9d31				FORTH_DSP_VALUE 
9d31 cd 1a 9d			call macro_forth_dsp_value 
9d34				endm 
# End of macro FORTH_DSP_VALUE
9d34			 
9d34				;FORTH_ERR_TOS_NOTNUM 
9d34			 
9d34				;inc hl   ; skip type id 
9d34			 
9d34			;	push de 
9d34			; 
9d34			;	ld e, (hl) 
9d34			;	inc hl 
9d34			;	ld d, (hl) 
9d34			;	ex de,hl  
9d34			 
9d34			;	pop de 
9d34			 
9d34				if DEBUG_FORTH_PUSH 
9d34						DMARK "DVL" 
9d34 f5				push af  
9d35 3a 49 9d			ld a, (.dmark)  
9d38 32 6b ee			ld (debug_mark),a  
9d3b 3a 4a 9d			ld a, (.dmark+1)  
9d3e 32 6c ee			ld (debug_mark+1),a  
9d41 3a 4b 9d			ld a, (.dmark+2)  
9d44 32 6d ee			ld (debug_mark+2),a  
9d47 18 03			jr .pastdmark  
9d49 ..			.dmark: db "DVL"  
9d4c f1			.pastdmark: pop af  
9d4d			endm  
# End of macro DMARK
9d4d				CALLMONITOR 
9d4d cd 6f ee			call debug_vector  
9d50				endm  
# End of macro CALLMONITOR
9d50				endif 
9d50 c9				ret 
9d51			 
9d51			forth_apushstrhl:      
9d51				; push of string requires use of cli_origptr 
9d51				; bodge use 
9d51			 
9d51				; get current cli_origptr, save, update with temp pointer  
9d51 ed 5b 3e ea		ld de, (cli_origptr) 
9d55 22 3e ea			ld (cli_origptr), hl 
9d58 d5				push de 
9d59 cd a3 9c			call forth_apush 
9d5c d1				pop de 
9d5d ed 53 3e ea		ld (cli_origptr), de 
9d61 c9			        ret	 
9d62			 
9d62			 
9d62			; increase loop stack pointer and save hl to it 
9d62				 
9d62			FORTH_LOOP_NEXT: macro 
9d62				call macro_forth_loop_next 
9d62				;nop 
9d62				endm 
9d62			 
9d62			macro_forth_loop_next: 
9d62				if DEBUG_FORTH_STACK_GUARD 
9d62 cd 92 e0				call check_stacks 
9d65				endif 
9d65 e5				push hl 
9d66 d5				push de 
9d67 eb				ex de,hl 
9d68 2a f0 e9			ld hl,(cli_loop_sp) 
9d6b 23				inc hl 
9d6c 23				inc hl 
9d6d					if DEBUG_FORTH_WORDS 
9d6d						DMARK "LNX" 
9d6d f5				push af  
9d6e 3a 82 9d			ld a, (.dmark)  
9d71 32 6b ee			ld (debug_mark),a  
9d74 3a 83 9d			ld a, (.dmark+1)  
9d77 32 6c ee			ld (debug_mark+1),a  
9d7a 3a 84 9d			ld a, (.dmark+2)  
9d7d 32 6d ee			ld (debug_mark+2),a  
9d80 18 03			jr .pastdmark  
9d82 ..			.dmark: db "LNX"  
9d85 f1			.pastdmark: pop af  
9d86			endm  
# End of macro DMARK
9d86						CALLMONITOR 
9d86 cd 6f ee			call debug_vector  
9d89				endm  
# End of macro CALLMONITOR
9d89					endif 
9d89 22 f0 e9			ld (cli_loop_sp),hl 
9d8c 73				ld (hl), e 
9d8d 23				inc hl 
9d8e 72				ld (hl), d 
9d8f d1				pop de    ; been reversed so save a swap on restore 
9d90 e1				pop hl 
9d91				if DEBUG_FORTH_STACK_GUARD 
9d91 cd 92 e0				call check_stacks 
9d94				endif 
9d94 c9				ret 
9d95			 
9d95			; get current ret stack pointer and save to hl  
9d95				 
9d95			FORTH_LOOP_TOS: macro 
9d95				call macro_forth_loop_tos 
9d95				endm 
9d95			 
9d95			macro_forth_loop_tos: 
9d95 d5				push de 
9d96 2a f0 e9			ld hl,(cli_loop_sp) 
9d99 5e				ld e, (hl) 
9d9a 23				inc hl 
9d9b 56				ld d, (hl) 
9d9c eb				ex de, hl 
9d9d d1				pop de 
9d9e c9				ret 
9d9f			 
9d9f			; pop loop stack pointer 
9d9f				 
9d9f			FORTH_LOOP_POP: macro 
9d9f				call macro_forth_loop_pop 
9d9f				endm 
9d9f			 
9d9f			 
9d9f			macro_forth_loop_pop: 
9d9f				if DEBUG_FORTH_STACK_GUARD 
9d9f					DMARK "LPP" 
9d9f f5				push af  
9da0 3a b4 9d			ld a, (.dmark)  
9da3 32 6b ee			ld (debug_mark),a  
9da6 3a b5 9d			ld a, (.dmark+1)  
9da9 32 6c ee			ld (debug_mark+1),a  
9dac 3a b6 9d			ld a, (.dmark+2)  
9daf 32 6d ee			ld (debug_mark+2),a  
9db2 18 03			jr .pastdmark  
9db4 ..			.dmark: db "LPP"  
9db7 f1			.pastdmark: pop af  
9db8			endm  
# End of macro DMARK
9db8 cd 92 e0				call check_stacks 
9dbb					FORTH_CHK_LOOP_UNDER 
9dbb e5				push hl 
9dbc d5				push de 
9dbd 2a f0 e9			ld hl,(cli_loop_sp) 
9dc0 11 2a e9			ld de, cli_loop_stack 
9dc3 cd fa 8c			call cmp16 
9dc6 da ac e1			jp c, fault_loop_under 
9dc9 d1				pop de 
9dca e1				pop hl 
9dcb				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9dcb				endif 
9dcb e5				push hl 
9dcc 2a f0 e9			ld hl,(cli_loop_sp) 
9dcf 2b				dec hl 
9dd0 2b				dec hl 
9dd1 22 f0 e9			ld (cli_loop_sp), hl 
9dd4				; TODO do stack underflow checks 
9dd4 e1				pop hl 
9dd5				if DEBUG_FORTH_STACK_GUARD 
9dd5 cd 92 e0				call check_stacks 
9dd8					FORTH_CHK_LOOP_UNDER 
9dd8 e5				push hl 
9dd9 d5				push de 
9dda 2a f0 e9			ld hl,(cli_loop_sp) 
9ddd 11 2a e9			ld de, cli_loop_stack 
9de0 cd fa 8c			call cmp16 
9de3 da ac e1			jp c, fault_loop_under 
9de6 d1				pop de 
9de7 e1				pop hl 
9de8				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9de8				endif 
9de8 c9				ret 
9de9			 
9de9			macro_forth_dsp_pop: 
9de9			 
9de9 e5				push hl 
9dea			 
9dea				; release malloc data 
9dea			 
9dea				if DEBUG_FORTH_STACK_GUARD 
9dea cd 92 e0				call check_stacks 
9ded					FORTH_CHK_DSP_UNDER 
9ded e5				push hl 
9dee d5				push de 
9def 2a ee e9			ld hl,(cli_data_sp) 
9df2 11 28 e8			ld de, cli_data_stack 
9df5 cd fa 8c			call cmp16 
9df8 da a0 e1			jp c, fault_dsp_under 
9dfb d1				pop de 
9dfc e1				pop hl 
9dfd				endm 
# End of macro FORTH_CHK_DSP_UNDER
9dfd				endif 
9dfd				;ld hl,(cli_data_sp) 
9dfd			if DEBUG_FORTH_DOT 
9dfd				DMARK "DPP" 
9dfd f5				push af  
9dfe 3a 12 9e			ld a, (.dmark)  
9e01 32 6b ee			ld (debug_mark),a  
9e04 3a 13 9e			ld a, (.dmark+1)  
9e07 32 6c ee			ld (debug_mark+1),a  
9e0a 3a 14 9e			ld a, (.dmark+2)  
9e0d 32 6d ee			ld (debug_mark+2),a  
9e10 18 03			jr .pastdmark  
9e12 ..			.dmark: db "DPP"  
9e15 f1			.pastdmark: pop af  
9e16			endm  
# End of macro DMARK
9e16				CALLMONITOR 
9e16 cd 6f ee			call debug_vector  
9e19				endm  
# End of macro CALLMONITOR
9e19			endif	 
9e19			 
9e19			 
9e19			if FORTH_ENABLE_DSPPOPFREE 
9e19			 
9e19				FORTH_DSP 
9e19 cd f7 9c			call macro_forth_dsp 
9e1c				endm 
# End of macro FORTH_DSP
9e1c			 
9e1c 7e				ld a, (hl) 
9e1d fe 01			cp DS_TYPE_STR 
9e1f 20 23			jr nz, .skippopfree 
9e21			 
9e21				FORTH_DSP_VALUEHL 
9e21 cd 31 9d			call macro_dsp_valuehl 
9e24				endm 
# End of macro FORTH_DSP_VALUEHL
9e24 00				nop 
9e25			if DEBUG_FORTH_DOT 
9e25				DMARK "DPf" 
9e25 f5				push af  
9e26 3a 3a 9e			ld a, (.dmark)  
9e29 32 6b ee			ld (debug_mark),a  
9e2c 3a 3b 9e			ld a, (.dmark+1)  
9e2f 32 6c ee			ld (debug_mark+1),a  
9e32 3a 3c 9e			ld a, (.dmark+2)  
9e35 32 6d ee			ld (debug_mark+2),a  
9e38 18 03			jr .pastdmark  
9e3a ..			.dmark: db "DPf"  
9e3d f1			.pastdmark: pop af  
9e3e			endm  
# End of macro DMARK
9e3e				CALLMONITOR 
9e3e cd 6f ee			call debug_vector  
9e41				endm  
# End of macro CALLMONITOR
9e41			endif	 
9e41 cd 6d 92			call free 
9e44			.skippopfree: 
9e44				 
9e44			 
9e44			endif 
9e44			 
9e44			if DEBUG_FORTH_DOT_KEY 
9e44				DMARK "DP2" 
9e44				CALLMONITOR 
9e44			endif	 
9e44			 
9e44				; move pointer down 
9e44			 
9e44 2a ee e9			ld hl,(cli_data_sp) 
9e47 2b				dec hl 
9e48 2b				dec hl 
9e49			; PARSEV5 
9e49 2b				dec hl 
9e4a 22 ee e9			ld (cli_data_sp), hl 
9e4d			 
9e4d				if DEBUG_FORTH_STACK_GUARD 
9e4d cd 92 e0				call check_stacks 
9e50					FORTH_CHK_DSP_UNDER 
9e50 e5				push hl 
9e51 d5				push de 
9e52 2a ee e9			ld hl,(cli_data_sp) 
9e55 11 28 e8			ld de, cli_data_stack 
9e58 cd fa 8c			call cmp16 
9e5b da a0 e1			jp c, fault_dsp_under 
9e5e d1				pop de 
9e5f e1				pop hl 
9e60				endm 
# End of macro FORTH_CHK_DSP_UNDER
9e60				endif 
9e60			 
9e60 e1				pop hl 
9e61			 
9e61 c9				ret 
9e62			 
9e62			getwordathl: 
9e62				; hl points to an address 
9e62				; load hl with the word at that address 
9e62			 
9e62 d5				push de 
9e63			 
9e63 5e				ld e, (hl) 
9e64 23				inc hl 
9e65 56				ld d, (hl) 
9e66 eb				ex de, hl 
9e67			 
9e67 d1				pop de 
9e68 c9				ret 
9e69			 
9e69			 
9e69			 
9e69			 
9e69			 
9e69			; eof 
9e69			 
# End of file forth_stackopsv5.asm
9e69			endif 
9e69			 
9e69			loadwordinhl:	 
9e69			 
9e69 d5				push de 
9e6a			 
9e6a 5e				ld e, (hl) 
9e6b 23				inc hl 
9e6c 56				ld d, (hl) 
9e6d eb				ex de,hl  
9e6e			 
9e6e d1				pop de 
9e6f			 
9e6f c9				ret 
9e70			 
9e70			user_word_eol:  
9e70				; hl contains the pointer to where to create a linked list item from the end 
9e70				; of the user dict to continue on at the system word dict 
9e70				 
9e70				; poke the stub of the word list linked list to repoint to rom words 
9e70			 
9e70				; stub format 
9e70				; db   word id 
9e70				; dw    link to next word 
9e70			        ; db char length of token 
9e70				; db string + 0 term 
9e70				; db exec code....  
9e70			 
9e70 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9e72 77				ld (hl), a		; word id 
9e73 23				inc hl 
9e74			 
9e74 11 3f a0			ld de, sysdict 
9e77 73				ld (hl), e		; next word link ie system dict 
9e78 23				inc hl 
9e79 72				ld (hl), d		; next word link ie system dict 
9e7a 23				inc hl	 
9e7b			 
9e7b			;	ld (hl), sysdict		; next word link ie system dict 
9e7b			;	inc hl 
9e7b			;	inc hl 
9e7b			 
9e7b			;	inc hl 
9e7b			;	inc hl 
9e7b			 
9e7b 3e 02			ld a, 2			; word length is 0 
9e7d 77				ld (hl), a	 
9e7e 23				inc hl 
9e7f			 
9e7f 3e 7e			ld a, '~'			; word length is 0 
9e81 77				ld (hl), a	 
9e82 23				inc hl 
9e83 3e 00			ld a, 0			; save empty word 
9e85 77				ld (hl), a 
9e86			 
9e86 c9				ret 
9e87			 
9e87				 
9e87			 
9e87			forthexec_cleanup: 
9e87				FORTH_RSP_POP 
9e87 cd 02 9b			call macro_forth_rsp_pop 
9e8a				endm 
# End of macro FORTH_RSP_POP
9e8a c9				ret 
9e8b			 
9e8b			forth_call_hl: 
9e8b				; taking hl 
9e8b e5				push hl 
9e8c c9				ret 
9e8d			 
9e8d			; this is called to reset Forth system but keep existing uwords etc 
9e8d			 
9e8d			forth_warmstart: 
9e8d				; setup stack over/under flow checks 
9e8d				if DEBUG_FORTH_STACK_GUARD 
9e8d cd 78 e0				call chk_stk_init 
9e90				endif 
9e90			 
9e90				; init stack pointers  - * these stacks go upwards *  
9e90 21 ac e9			ld hl, cli_ret_stack 
9e93 22 f2 e9			ld (cli_ret_sp), hl	 
9e96				; set bottom of stack 
9e96 3e 00			ld a,0 
9e98 77				ld (hl),a 
9e99 23				inc hl 
9e9a 77				ld (hl),a 
9e9b			 
9e9b 21 28 e8			ld hl, cli_data_stack 
9e9e 22 ee e9			ld (cli_data_sp), hl	 
9ea1				; set bottom of stack 
9ea1 3e 00			ld a,0 
9ea3 77				ld (hl),a 
9ea4 23				inc hl 
9ea5 77				ld (hl),a 
9ea6			 
9ea6 21 2a e9			ld hl, cli_loop_stack 
9ea9 22 f0 e9			ld (cli_loop_sp), hl	 
9eac				; set bottom of stack 
9eac 3e 00			ld a,0 
9eae 77				ld (hl),a 
9eaf 23				inc hl 
9eb0 77				ld (hl),a 
9eb1			 
9eb1				; init extent of current open file 
9eb1			 
9eb1 3e 00			ld a, 0 
9eb3 32 6a ea			ld (store_openext), a 
9eb6			 
9eb6 c9				ret 
9eb7			 
9eb7			 
9eb7			 
9eb7			; Cold Start - this is called to setup the whole Forth system 
9eb7			 
9eb7			forth_init: 
9eb7			 
9eb7				; setup stack over/under flow checks 
9eb7			 
9eb7			;	if DEBUG_FORTH_STACK_GUARD 
9eb7			;		call chk_stk_init 
9eb7			;	endif 
9eb7			 
9eb7				; enable auto display updates (slow.....) 
9eb7			 
9eb7 3e 01			ld a, 1 
9eb9 32 3c ea			ld (cli_autodisplay), a 
9ebc			 
9ebc				; if storage is in use disable long reads for now 
9ebc 3e 00			ld a, 0 
9ebe 32 75 ea			ld (store_longread), a 
9ec1			 
9ec1			 
9ec1				; show start up screen 
9ec1			 
9ec1 cd af 8a			call clear_display 
9ec4			 
9ec4 3e 00			ld a,0 
9ec6 32 5e ea			ld (f_cursor_ptr), a 
9ec9			 
9ec9				; set start of word list in start of ram - for use when creating user words 
9ec9			 
9ec9 21 2c e4			ld hl, baseram 
9ecc 22 be e5			ld (os_last_new_uword), hl 
9ecf cd 70 9e			call user_word_eol 
9ed2				 
9ed2			;		call display_data_sp 
9ed2			;		call next_page_prompt 
9ed2			 
9ed2			 
9ed2			 
9ed2			 
9ed2 c9				ret 
9ed3			 
9ed3 .. 00		.bootforth: db " Forth Kernel Init ",0 
9ee7			 
9ee7			; TODO push to stack 
9ee7			 
9ee7			;  
9ee7			 
9ee7			if FORTH_PARSEV2 
9ee7			 
9ee7			 
9ee7				include "forth_parserv2.asm" 
9ee7			 
9ee7			endif 
9ee7			 
9ee7			 
9ee7			; parse cli version 1 
9ee7			 
9ee7			if FORTH_PARSEV1 
9ee7			 
9ee7			 
9ee7			 
9ee7			      include "forth_parserv1.asm" 
9ee7			endif 
9ee7				 
9ee7			if FORTH_PARSEV3 
9ee7			 
9ee7			 
9ee7			 
9ee7			      include "forth_parserv3.asm" 
9ee7				include "forth_wordsv3.asm" 
9ee7			endif 
9ee7			 
9ee7			if FORTH_PARSEV4 
9ee7			 
9ee7			 
9ee7			 
9ee7			      include "forth_parserv4.asm" 
9ee7				include "forth_wordsv4.asm" 
9ee7			endif 
9ee7			 
9ee7			if FORTH_PARSEV5 
9ee7			 
9ee7			 
9ee7			 
9ee7			      include "forth_parserv5.asm" 
9ee7			 
9ee7			 
9ee7			; A better parser without using malloc and string copies all over the place.  
9ee7			; Exec in situ should be faster 
9ee7			 
9ee7			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9ee7			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9ee7			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9ee7			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9ee7			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9ee7			WORD_SYS_END: equ 0   ; Opcode for all user words 
9ee7			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9ee7			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9ee7			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9ee7			 
9ee7			; Core word preamble macro 
9ee7			 
9ee7			CWHEAD:   macro nxtword opcode lit len opflags 
9ee7				db WORD_SYS_CORE+opcode             
9ee7				; internal op code number 
9ee7				dw nxtword            
9ee7				; link to next dict word block 
9ee7				db len + 1 
9ee7				; literal length of dict word inc zero term 
9ee7				db lit,0              
9ee7				; literal dict word 
9ee7			        ; TODO db opflags        
9ee7				endm 
9ee7			 
9ee7			 
9ee7			NEXTW: macro  
9ee7				jp macro_next 
9ee7				endm 
9ee7			 
9ee7			macro_next: 
9ee7			if DEBUG_FORTH_PARSE_KEY 
9ee7				DMARK "NXT" 
9ee7				CALLMONITOR 
9ee7			endif	 
9ee7			;	inc hl  ; skip token null term  
9ee7 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9eeb ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9eef 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9ef2			if DEBUG_FORTH_PARSE_KEY 
9ef2				DMARK "}AA" 
9ef2				CALLMONITOR 
9ef2			endif	 
9ef2 c3 f5 9f			jp execnext 
9ef5				;jp exec1 
9ef5			       
9ef5			 
9ef5			 
9ef5			; Another go at the parser to compile  
9ef5			 
9ef5			 
9ef5			; TODO rework parser to change all of the string words to byte tokens 
9ef5			; TODO do a search for  
9ef5			 
9ef5			; TODO first run normal parser to zero term sections 
9ef5			; TODO for each word do a token look up to get the op code 
9ef5			; TODO need some means to flag to the exec that this is a byte code form    
9ef5			 
9ef5			 
9ef5			forthcompile: 
9ef5			 
9ef5			; 
9ef5			; line parse: 
9ef5			;       parse raw input buffer 
9ef5			;       tokenise the words 
9ef5			;       malloc new copy (for looping etc) 
9ef5			;       copy to malloc + current pc in line to start of string and add line term 
9ef5			;       save on new rsp 
9ef5			; 
9ef5			 
9ef5			; hl to point to the line to tokenise 
9ef5			 
9ef5			;	push hl 
9ef5 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9ef8			 
9ef8			;	ld a,0		; string term on input 
9ef8			;	call strlent 
9ef8			 
9ef8			;	ld (os_tok_len), hl	 ; save string length 
9ef8			 
9ef8			;if DEBUG_FORTH_TOK 
9ef8			;	ex de,hl		 
9ef8			;endif 
9ef8			 
9ef8			;	pop hl 		; get back string pointer 
9ef8			 
9ef8			if DEBUG_FORTH_TOK 
9ef8						DMARK "TOc" 
9ef8				CALLMONITOR 
9ef8			endif 
9ef8 7e			.cptoken2:    ld a,(hl) 
9ef9 23				inc hl 
9efa fe 7f			cp FORTH_END_BUFFER 
9efc 28 29			jr z, .cptokendone2 
9efe fe 00			cp 0 
9f00 28 25			jr z, .cptokendone2 
9f02 fe 22			cp '"' 
9f04 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9f06 fe 20			cp ' ' 
9f08 20 ee			jr nz,  .cptoken2 
9f0a			 
9f0a			; TODO consume comments held between ( and ) 
9f0a			 
9f0a				; we have a space so change to zero term for dict match later 
9f0a 2b				dec hl 
9f0b 3e 00			ld a,0 
9f0d 77				ld (hl), a 
9f0e 23				inc hl 
9f0f 18 e7			jr .cptoken2 
9f11				 
9f11			 
9f11			.cptokenstr2: 
9f11				; skip all white space until either eol (because forgot to term) or end double quote 
9f11			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f11				;inc hl ; skip current double quote 
9f11 7e				ld a,(hl) 
9f12 23				inc hl 
9f13 fe 22			cp '"' 
9f15 28 e1			jr z, .cptoken2 
9f17 fe 7f			cp FORTH_END_BUFFER 
9f19 28 0c			jr z, .cptokendone2 
9f1b fe 00			cp 0 
9f1d 28 08			jr z, .cptokendone2 
9f1f fe 20			cp ' ' 
9f21 28 02			jr z, .cptmp2 
9f23 18 ec			jr .cptokenstr2 
9f25			 
9f25			.cptmp2:	; we have a space so change to zero term for dict match later 
9f25				;dec hl 
9f25				;ld a,"-"	; TODO remove this when working 
9f25				;ld (hl), a 
9f25				;inc hl 
9f25 18 ea			jr .cptokenstr2 
9f27			 
9f27			.cptokendone2: 
9f27				;inc hl 
9f27 3e 7f			ld a, FORTH_END_BUFFER 
9f29 77				ld (hl),a 
9f2a 23				inc hl 
9f2b 3e 21			ld a, '!' 
9f2d 77				ld (hl),a 
9f2e			 
9f2e 2a c2 e5			ld hl,(os_tok_ptr) 
9f31			         
9f31			if DEBUG_FORTH_TOK 
9f31						DMARK "Tc1" 
9f31				CALLMONITOR 
9f31			endif 
9f31			 
9f31				; push exec string to top of return stack 
9f31				FORTH_RSP_NEXT 
9f31 cd e1 9a			call macro_forth_rsp_next 
9f34				endm 
# End of macro FORTH_RSP_NEXT
9f34 c9				ret 
9f35			 
9f35			; Another go at the parser need to simplify the process 
9f35			 
9f35			forthparse: 
9f35			 
9f35			; 
9f35			; line parse: 
9f35			;       parse raw input buffer 
9f35			;       tokenise the words 
9f35			;       malloc new copy (for looping etc) 
9f35			;       copy to malloc + current pc in line to start of string and add line term 
9f35			;       save on new rsp 
9f35			; 
9f35			 
9f35			; hl to point to the line to tokenise 
9f35			 
9f35			;	push hl 
9f35 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
9f38			 
9f38			;	ld a,0		; string term on input 
9f38			;	call strlent 
9f38			 
9f38			;	ld (os_tok_len), hl	 ; save string length 
9f38			 
9f38			;if DEBUG_FORTH_TOK 
9f38			;	ex de,hl		 
9f38			;endif 
9f38			 
9f38			;	pop hl 		; get back string pointer 
9f38			 
9f38			if DEBUG_FORTH_TOK 
9f38						DMARK "TOK" 
9f38				CALLMONITOR 
9f38			endif 
9f38 7e			.ptoken2:    ld a,(hl) 
9f39 23				inc hl 
9f3a fe 7f			cp FORTH_END_BUFFER 
9f3c 28 29			jr z, .ptokendone2 
9f3e fe 00			cp 0 
9f40 28 25			jr z, .ptokendone2 
9f42 fe 22			cp '"' 
9f44 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9f46 fe 20			cp ' ' 
9f48 20 ee			jr nz,  .ptoken2 
9f4a			 
9f4a			; TODO consume comments held between ( and ) 
9f4a			 
9f4a				; we have a space so change to zero term for dict match later 
9f4a 2b				dec hl 
9f4b 3e 00			ld a,0 
9f4d 77				ld (hl), a 
9f4e 23				inc hl 
9f4f 18 e7			jr .ptoken2 
9f51				 
9f51			 
9f51			.ptokenstr2: 
9f51				; skip all white space until either eol (because forgot to term) or end double quote 
9f51			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9f51				;inc hl ; skip current double quote 
9f51 7e				ld a,(hl) 
9f52 23				inc hl 
9f53 fe 22			cp '"' 
9f55 28 e1			jr z, .ptoken2 
9f57 fe 7f			cp FORTH_END_BUFFER 
9f59 28 0c			jr z, .ptokendone2 
9f5b fe 00			cp 0 
9f5d 28 08			jr z, .ptokendone2 
9f5f fe 20			cp ' ' 
9f61 28 02			jr z, .ptmp2 
9f63 18 ec			jr .ptokenstr2 
9f65			 
9f65			.ptmp2:	; we have a space so change to zero term for dict match later 
9f65				;dec hl 
9f65				;ld a,"-"	; TODO remove this when working 
9f65				;ld (hl), a 
9f65				;inc hl 
9f65 18 ea			jr .ptokenstr2 
9f67			 
9f67			.ptokendone2: 
9f67				;inc hl 
9f67 3e 7f			ld a, FORTH_END_BUFFER 
9f69 77				ld (hl),a 
9f6a 23				inc hl 
9f6b 3e 21			ld a, '!' 
9f6d 77				ld (hl),a 
9f6e			 
9f6e 2a c2 e5			ld hl,(os_tok_ptr) 
9f71			         
9f71			if DEBUG_FORTH_TOK 
9f71						DMARK "TK1" 
9f71				CALLMONITOR 
9f71			endif 
9f71			 
9f71				; push exec string to top of return stack 
9f71				FORTH_RSP_NEXT 
9f71 cd e1 9a			call macro_forth_rsp_next 
9f74				endm 
# End of macro FORTH_RSP_NEXT
9f74 c9				ret 
9f75			 
9f75			; 
9f75			;	; malloc size + buffer pointer + if is loop flag 
9f75			;	ld hl,(os_tok_len) 		 ; get string length 
9f75			; 
9f75			;	ld a,l 
9f75			; 
9f75			;	cp 0			; we dont want to use a null string 
9f75			;	ret z 
9f75			; 
9f75			;;	add 3    ; prefix malloc with buffer for current word ptr 
9f75			; 
9f75			;	add 5     ; TODO when certain not over writing memory remove 
9f75			; 
9f75			;		 
9f75			; 
9f75			;if DEBUG_FORTH_TOK 
9f75			;			DMARK "TKE" 
9f75			;	CALLMONITOR 
9f75			;endif 
9f75			; 
9f75			;	ld l,a 
9f75			;	ld h,0 
9f75			;;	push hl   ; save required space for the copy later 
9f75			;	call malloc 
9f75			;if DEBUG_FORTH_TOK 
9f75			;			DMARK "TKM" 
9f75			;	CALLMONITOR 
9f75			;endif 
9f75			;	if DEBUG_FORTH_MALLOC_GUARD 
9f75			;		push af 
9f75			;		call ishlzero 
9f75			;;		ld a, l 
9f75			;;		add h 
9f75			;;		cp 0 
9f75			;		pop af 
9f75			;		 
9f75			;		call z,malloc_error 
9f75			;	endif 
9f75			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9f75			; 
9f75			; 
9f75			;if DEBUG_FORTH_TOK 
9f75			;			DMARK "TKR" 
9f75			;	CALLMONITOR 
9f75			;endif 
9f75			; 
9f75			;	FORTH_RSP_NEXT 
9f75			; 
9f75			;	;inc hl	 ; go past current buffer pointer 
9f75			;	;inc hl 
9f75			;	;inc hl   ; and past if loop flag 
9f75			;		; TODO Need to set flag  
9f75			; 
9f75			;	 
9f75			;	 
9f75			;	ex de,hl	; malloc is dest 
9f75			;	ld hl, (os_tok_len) 
9f75			;;	pop bc 
9f75			;	ld c, l                
9f75			;	ld b,0 
9f75			;	ld hl, (os_tok_ptr) 
9f75			; 
9f75			;if DEBUG_FORTH_TOK 
9f75			;			DMARK "TKT" 
9f75			;	CALLMONITOR 
9f75			;endif 
9f75			; 
9f75			;	; do str cpy 
9f75			; 
9f75			;	ldir      ; copy byte in hl to de 
9f75			; 
9f75			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9f75			; 
9f75			;if DEBUG_FORTH_TOK 
9f75			; 
9f75			;			DMARK "TKY" 
9f75			;	CALLMONITOR 
9f75			;endif 
9f75			;	;ld a,0 
9f75			;	;ld a,FORTH_END_BUFFER 
9f75			;	ex de, hl 
9f75			;	;dec hl			 ; go back over the space delim at the end of word 
9f75			;	;ld (hl),a 
9f75			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9f75			;	ld a,FORTH_END_BUFFER 
9f75			;	ld (hl),a 
9f75			;	inc hl 
9f75			;	ld a,FORTH_END_BUFFER 
9f75			;	ld (hl),a 
9f75			; 
9f75			;	; init the malloc area data 
9f75			;	; set pc for in current area 
9f75			;	;ld hl, (os_tok_malloc) 
9f75			;	;inc hl 
9f75			;	;inc hl 
9f75			;	;inc hl 
9f75			;	;ex de,hl 
9f75			;	;ld hl, (os_tok_malloc) 
9f75			;	;ld (hl),e 
9f75			;	;inc hl 
9f75			;	;ld (hl),d 
9f75			; 
9f75			; 
9f75			;	ld hl,(os_tok_malloc) 
9f75			;if DEBUG_FORTH_PARSE_KEY 
9f75			;			DMARK "TKU" 
9f75			;	CALLMONITOR 
9f75			;endif 
9f75			; 
9f75			;	ret 
9f75			 
9f75			forthexec: 
9f75			 
9f75			; line exec: 
9f75			; forth parser 
9f75			 
9f75			; 
9f75			;       get current exec line on rsp 
9f75			 
9f75				FORTH_RSP_TOS 
9f75 cd f8 9a			call macro_forth_rsp_tos 
9f78				endm 
# End of macro FORTH_RSP_TOS
9f78			 
9f78			;       restore current pc - hl points to malloc of data 
9f78			 
9f78				;ld e, (hl) 
9f78				;inc hl 
9f78				;ld d, (hl) 
9f78				;ex de,hl 
9f78			 
9f78			 
9f78			exec1: 
9f78 22 c2 e5			ld (os_tok_ptr), hl 
9f7b			 
9f7b				; copy our PC to working vars  
9f7b 22 40 ea			ld (cli_ptr), hl 
9f7e 22 3e ea			ld (cli_origptr), hl 
9f81			 
9f81 7e				ld a,(hl) 
9f82 fe 7f			cp FORTH_END_BUFFER 
9f84 c8				ret z 
9f85			 
9f85				; skip any nulls 
9f85			 
9f85 fe 00			cp 0 
9f87 20 03			jr nz, .execword 
9f89 23				inc hl 
9f8a 18 ec			jr exec1 
9f8c			 
9f8c			 
9f8c			.execword: 
9f8c			 
9f8c			 
9f8c			 
9f8c			if DEBUG_FORTH_PARSE_KEY 
9f8c						DMARK "KYQ" 
9f8c				CALLMONITOR 
9f8c			endif 
9f8c			;       while at start of word: 
9f8c			; get start of dict (in user area first) 
9f8c			 
9f8c 21 2c e4		ld hl, baseram 
9f8f			;ld hl, sysdict 
9f8f 22 42 ea		ld (cli_nextword),hl 
9f92			;           match word at pc 
9f92			;           exec word 
9f92			;           or push to dsp 
9f92			;           forward to next token 
9f92			;           if line term pop rsp and exit 
9f92			;        
9f92			 
9f92			if DEBUG_FORTH_PARSE_KEY 
9f92						DMARK "KYq" 
9f92				CALLMONITOR 
9f92			endif 
9f92			 
9f92			; 
9f92			; word comp 
9f92			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9f92			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9f92			;    move to start of word  
9f92			;    compare word to cli_token 
9f92			 
9f92			.execpnword:	; HL at start of a word in the dictionary to check 
9f92			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9f92			;	ld (cli_ptr), hl 
9f92			 
9f92 2a 42 ea			ld hl,(cli_nextword) 
9f95			 
9f95 cd 38 a0			call forth_tok_next 
9f98			; tok next start here 
9f98			;	; TODO skip compiled symbol for now 
9f98			;	inc hl 
9f98			; 
9f98			;	; save pointer to next word 
9f98			; 
9f98			;	; hl now points to the address of the next word pointer  
9f98			;	ld e, (hl) 
9f98			;	inc hl 
9f98			;	ld d, (hl) 
9f98			;	inc l 
9f98			; 
9f98			;	ex de,hl 
9f98			;if DEBUG_FORTH_PARSE_NEXTWORD 
9f98			;	push bc 
9f98			;	ld bc, (cli_nextword) 
9f98			;			DMARK "NXW" 
9f98			;	CALLMONITOR 
9f98			;	pop bc 
9f98			;endif 
9f98			; tok next end here 
9f98 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9f9b eb				ex de, hl 
9f9c			 
9f9c			 
9f9c				; save the pointer of the current token - 1 to check against 
9f9c				 
9f9c 22 46 ea			ld (cli_token), hl   
9f9f				; TODO maybe remove below save if no debug 
9f9f				; save token string ptr for any debug later 
9f9f 23				inc hl  
9fa0 22 48 ea			ld (cli_origtoken), hl 
9fa3 2b				dec hl 
9fa4				; save pointer to the start of the next dictionay word 
9fa4 7e				ld a,(hl)   ; get string length 
9fa5 47				ld b,a 
9fa6			.execpnwordinc:  
9fa6 23				inc hl 
9fa7 10 fd			djnz .execpnwordinc 
9fa9 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
9fac			 
9fac				; now check the word token against the string being parsed 
9fac			 
9fac 2a 46 ea			ld hl,(cli_token) 
9faf 23				inc hl     ; skip string length (use zero term instead to end) 
9fb0 22 46 ea			ld (cli_token), hl 
9fb3			 
9fb3			if DEBUG_FORTH_PARSE_KEY 
9fb3						DMARK "KY2" 
9fb3			endif 
9fb3			if DEBUG_FORTH_PARSE_EXEC 
9fb3				; see if disabled 
9fb3			 
9fb3			;	ld a, (os_view_disable) 
9fb3			;	cp '*' 
9fb3				ld a, (debug_vector) 
9fb3				cp $c9   ; RET  
9fb3				jr z, .skip 
9fb3			 
9fb3				push hl 
9fb3				push hl 
9fb3				call clear_display 
9fb3				ld de, .compword 
9fb3				ld a, display_row_1 
9fb3				call str_at_display 
9fb3				pop de 
9fb3				ld a, display_row_2 
9fb3				call str_at_display 
9fb3				ld hl,(cli_ptr) 
9fb3				ld a,(hl) 
9fb3			        ld hl, os_word_scratch 
9fb3				ld (hl),a 
9fb3				ld a,0 
9fb3				inc hl 
9fb3				ld (hl),a 	 
9fb3				ld de, os_word_scratch 
9fb3				ld a, display_row_2+10 
9fb3				call str_at_display 
9fb3				call update_display 
9fb3				ld a, 100 
9fb3				call aDelayInMS 
9fb3				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fb3				call delay250ms 
9fb3				endif 
9fb3				pop hl 
9fb3			.skip:  
9fb3			endif	 
9fb3			.execpnchar:    ; compare char between token and string to parse 
9fb3			 
9fb3			if DEBUG_FORTH_PARSE_KEY 
9fb3						DMARK "Ky3" 
9fb3			endif 
9fb3			if DEBUG_FORTH_PARSE_EXEC 
9fb3				; see if disabled 
9fb3			 
9fb3			;	ld a, (os_view_disable) 
9fb3			;	cp '*' 
9fb3				ld a, (debug_vector) 
9fb3				cp $C9  ; RET 
9fb3				jr z, .skip2 
9fb3			 
9fb3			;	call clear_display 
9fb3			ld hl,(cli_token) 
9fb3			ld a,(hl) 
9fb3			ld (os_word_scratch),a 
9fb3				ld hl,(cli_ptr) 
9fb3			ld a,(hl) 
9fb3				ld (os_word_scratch+1),a 
9fb3				ld a,0 
9fb3				ld (os_word_scratch+2),a 
9fb3				ld de,os_word_scratch 
9fb3				ld a,display_row_4 
9fb3				call str_at_display 
9fb3				call update_display 
9fb3			.skip2:  
9fb3			endif 
9fb3 2a 46 ea			ld hl,(cli_token) 
9fb6 7e				ld a, (hl)	 ; char in word token 
9fb7 23				inc hl 		; move to next char 
9fb8 22 46 ea			ld (cli_token), hl ; and save it 
9fbb 47				ld b,a 
9fbc			 
9fbc 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
9fbf 7e				ld a,(hl) 
9fc0 23				inc hl 
9fc1 22 40 ea			ld (cli_ptr), hl		; move to next char 
9fc4 cd 31 91			call toUpper 		; make sure the input string matches case 
9fc7			 
9fc7			if DEBUG_FORTH_PARSE 
9fc7			endif 
9fc7			 
9fc7				; input stream end of token is a space so get rid of it 
9fc7			 
9fc7			;	cp ' ' 
9fc7			;	jr nz, .pnskipspace 
9fc7			; 
9fc7			;	ld a, 0		; make same term as word token term 
9fc7			; 
9fc7			;.pnskipspace: 
9fc7			 
9fc7			if DEBUG_FORTH_PARSE_KEY 
9fc7						DMARK "KY7" 
9fc7			endif 
9fc7 b8				cp b 
9fc8 c2 de 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9fcb				 
9fcb			;    if same 
9fcb			;       scan for string terms 0 for token and 32 for input 
9fcb			 
9fcb				 
9fcb			if DEBUG_FORTH_PARSE_KEY 
9fcb						DMARK "KY8" 
9fcb			endif 
9fcb			 
9fcb 80				add b			 
9fcc fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9fce							; TODO need to make sure last word in zero term string is accounted for 
9fce 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9fd0			 
9fd0			 
9fd0				; at end of both strings so both are exact match 
9fd0			 
9fd0			;       skip ptr for next word 
9fd0			 
9fd0 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
9fd3 23				inc hl			 ; at next char 
9fd4 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
9fd7 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9fda				 
9fda				 
9fda			if DEBUG_FORTH_PARSE_KEY 
9fda						DMARK "KY3" 
9fda			endif 
9fda			 
9fda			 
9fda			 
9fda			;       exec code block 
9fda			if DEBUG_FORTH_JP 
9fda				call clear_display 
9fda				call update_display 
9fda				call delay1s 
9fda				ld hl, (cli_execword)     ; save for next check if no match on this word 
9fda				ld a,h 
9fda				ld hl, os_word_scratch 
9fda				call hexout 
9fda				ld hl, (cli_execword)     ; save for next check if no match on this word 
9fda				ld a,l 
9fda				ld hl, os_word_scratch+2 
9fda				call hexout 
9fda				ld hl, os_word_scratch+4 
9fda				ld a,0 
9fda				ld (hl),a 
9fda				ld de,os_word_scratch 
9fda				call str_at_display 
9fda					ld a, display_row_2 
9fda					call str_at_display 
9fda				ld de, (cli_origtoken) 
9fda				ld a, display_row_1+10 
9fda					call str_at_display 
9fda			 
9fda				ld a,display_row_1 
9fda				ld de, .foundword 
9fda				ld a, display_row_3 
9fda				call str_at_display 
9fda				call update_display 
9fda				call delay1s 
9fda				call delay1s 
9fda				call delay1s 
9fda			endif 
9fda			 
9fda			if DEBUG_FORTH_PARSE_KEY 
9fda						DMARK "KYj" 
9fda			endif 
9fda				; TODO save the word pointer in this exec 
9fda			 
9fda 2a 44 ea			ld hl,(cli_execword) 
9fdd e9				jp (hl) 
9fde			 
9fde			 
9fde			;    if not same 
9fde			;	scan for zero term 
9fde			;	get ptr for next word 
9fde			;	goto word comp 
9fde			 
9fde			.execpnskipword:	; get pointer to next word 
9fde 2a 42 ea			ld hl,(cli_nextword) 
9fe1			 
9fe1 7e				ld a,(hl) 
9fe2 fe 00			cp WORD_SYS_END 
9fe4			;	cp 0 
9fe4 28 09			jr z, .execendofdict			 ; at end of words 
9fe6			 
9fe6			if DEBUG_FORTH_PARSE_KEY 
9fe6						DMARK "KY4" 
9fe6			endif 
9fe6			if DEBUG_FORTH_PARSE_EXEC 
9fe6			 
9fe6				; see if disabled 
9fe6			 
9fe6			;	ld a, (os_view_disable) 
9fe6			;	cp '*' 
9fe6				ld a,(debug_vector) 
9fe6				cp $c9   ; RET 
9fe6				jr z, .noskip 
9fe6			 
9fe6			 
9fe6				ld de, .nowordfound 
9fe6				ld a, display_row_3 
9fe6				call str_at_display 
9fe6				call update_display 
9fe6				ld a, 100 
9fe6				call aDelayInMS 
9fe6				 
9fe6				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fe6					call delay250ms 
9fe6				endif 
9fe6			.noskip:  
9fe6			 
9fe6			endif	 
9fe6			 
9fe6 2a 3e ea			ld hl,(cli_origptr) 
9fe9 22 40 ea			ld (cli_ptr),hl 
9fec			 
9fec			if DEBUG_FORTH_PARSE_KEY 
9fec						DMARK "KY5" 
9fec			endif 
9fec c3 92 9f			jp .execpnword			; else go to next word 
9fef			 
9fef			.execendofdict:  
9fef			 
9fef			if DEBUG_FORTH_PARSE_KEY 
9fef						DMARK "KYe" 
9fef			endif 
9fef			if DEBUG_FORTH_PARSE_EXEC 
9fef				; see if disabled 
9fef			 
9fef			;	ld a, (os_view_disable) 
9fef			;	cp '*' 
9fef				ld a,(debug_vector) 
9fef				cp $c9   ; ret 
9fef				jr z, .ispskip 
9fef			 
9fef				call clear_display 
9fef				call update_display 
9fef				call delay1s 
9fef				ld de, (cli_origptr) 
9fef				ld a, display_row_1 
9fef				call str_at_display 
9fef				 
9fef				ld de, .enddict 
9fef				ld a, display_row_3 
9fef				call str_at_display 
9fef				call update_display 
9fef				ld a, 100 
9fef				call aDelayInMS 
9fef				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9fef				call delay1s 
9fef				call delay1s 
9fef				call delay1s 
9fef				endif 
9fef			.ispskip:  
9fef				 
9fef			endif	 
9fef			 
9fef			 
9fef			 
9fef				; if the word is not a keyword then must be a literal so push it to stack 
9fef			 
9fef			; push token to stack to end of word 
9fef			 
9fef				STACKFRAME ON $1efe $2f9f 
9fef				if DEBUG_STACK_IMB 
9fef					if ON 
9fef						exx 
9fef						ld de, $1efe 
9fef						ld a, d 
9fef						ld hl, curframe 
9fef						call hexout 
9fef						ld a, e 
9fef						ld hl, curframe+2 
9fef						call hexout 
9fef						ld hl, $1efe 
9fef						push hl 
9fef						ld hl, $2f9f 
9fef						push hl 
9fef						exx 
9fef					endif 
9fef				endif 
9fef			endm 
# End of macro STACKFRAME
9fef			 
9fef 2a c2 e5		ld hl,(os_tok_ptr) 
9ff2 cd a3 9c		call forth_apush 
9ff5			 
9ff5				STACKFRAMECHK ON $1efe $2f9f 
9ff5				if DEBUG_STACK_IMB 
9ff5					if ON 
9ff5						exx 
9ff5						ld hl, $2f9f 
9ff5						pop de   ; $2f9f 
9ff5						call cmp16 
9ff5						jr nz, .spnosame 
9ff5						ld hl, $1efe 
9ff5						pop de   ; $1efe 
9ff5						call cmp16 
9ff5						jr z, .spfrsame 
9ff5						.spnosame: call showsperror 
9ff5						.spfrsame: nop 
9ff5						exx 
9ff5					endif 
9ff5				endif 
9ff5			endm 
# End of macro STACKFRAMECHK
9ff5			 
9ff5			execnext: 
9ff5			 
9ff5			if DEBUG_FORTH_PARSE_KEY 
9ff5						DMARK "KY>" 
9ff5			endif 
9ff5			; move past token to next word 
9ff5			 
9ff5 2a c2 e5		ld hl, (os_tok_ptr) 
9ff8 3e 00		ld a, 0 
9ffa 01 ff 00		ld bc, 255     ; input buffer size 
9ffd ed b1		cpir 
9fff			 
9fff			if DEBUG_FORTH_PARSE_KEY 
9fff						DMARK "KY!" 
9fff				CALLMONITOR 
9fff			endif	 
9fff			; TODO this might place hl on the null, so will need to forward on??? 
9fff			;inc hl   ; see if this gets onto the next item 
9fff			 
9fff			 
9fff			; TODO pass a pointer to the buffer to push 
9fff			; TODO call function to push 
9fff			 
9fff			; look for end of input 
9fff			 
9fff			;inc hl 
9fff			;ld a,(hl) 
9fff			;cp FORTH_END_BUFFER 
9fff			;ret z 
9fff			 
9fff			 
9fff c3 78 9f		jp exec1 
a002			 
a002			 
a002			 
a002			 
a002			 
a002			 
a002			 
a002			 
a002			 
a002			findnexttok: 
a002			 
a002				; hl is pointer to move 
a002				; de is the token to locate 
a002			 
a002					if DEBUG_FORTH 
a002						DMARK "NTK" 
a002						CALLMONITOR 
a002					endif 
a002 d5				push de 
a003			 
a003			.fnt1:	 
a003				; find first char of token to locate 
a003			 
a003 1a				ld a, (de) 
a004 4f				ld c,a 
a005 7e				ld a,(hl) 
a006 cd 31 91			call toUpper 
a009					if DEBUG_FORTH 
a009						DMARK "NT1" 
a009						CALLMONITOR 
a009					endif 
a009 b9				cp c 
a00a			 
a00a 28 03			jr z, .fnt2cmpmorefirst	 
a00c			 
a00c				; first char not found move to next char 
a00c			 
a00c 23				inc hl 
a00d 18 f4			jr .fnt1 
a00f			 
a00f			.fnt2cmpmorefirst:	 
a00f				; first char of token found.  
a00f			 
a00f e5				push hl     ; save start of token just in case it is the right one 
a010 d9				exx 
a011 e1				pop hl        ; save it to hl' 
a012 d9				exx 
a013			 
a013			 
a013			.fnt2cmpmore:	 
a013				; compare the rest 
a013				 
a013 23				inc hl 
a014 13				inc de 
a015				 
a015 1a				ld a, (de) 
a016 4f				ld c,a 
a017 7e				ld a,(hl) 
a018 cd 31 91			call toUpper 
a01b			 
a01b					if DEBUG_FORTH 
a01b						DMARK "NT2" 
a01b						CALLMONITOR 
a01b					endif 
a01b				; c has the token to find char 
a01b				; a has the mem to scan char 
a01b			 
a01b b9				cp c 
a01c 28 04			jr z,.fntmatch1 
a01e			 
a01e				; they are not the same 
a01e			 
a01e					if DEBUG_FORTH 
a01e						DMARK "NT3" 
a01e						CALLMONITOR 
a01e					endif 
a01e d1				pop de	; reset de token to look for 
a01f d5				push de 
a020 18 e1			jr .fnt1 
a022				 
a022			.fntmatch1: 
a022			 
a022				; is the same char a null which means we might have a full hit? 
a022					if DEBUG_FORTH 
a022						DMARK "NT4" 
a022						CALLMONITOR 
a022					endif 
a022			 
a022 fe 00			cp 0 
a024 28 0b			jr z, .fntmatchyes 
a026			 
a026				; are we at the end of the token to find? 
a026			 
a026					if DEBUG_FORTH 
a026						DMARK "NT5" 
a026						CALLMONITOR 
a026					endif 
a026 3e 00			ld a, 0 
a028 b9				cp c 
a029			 
a029 c2 13 a0			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
a02c			 
a02c					if DEBUG_FORTH 
a02c						DMARK "NT6" 
a02c						CALLMONITOR 
a02c					endif 
a02c				; token to find is exhusted but no match to stream 
a02c			 
a02c				; restore tok pointer and continue on 
a02c d1				pop de 
a02d d5				push de 
a02e c3 03 a0			jp .fnt1 
a031			 
a031			 
a031			.fntmatchyes: 
a031			 
a031				; hl now contains the end of the found token 
a031			 
a031				; get rid of saved token pointer to find 
a031			 
a031 d1				pop de 
a032			 
a032					if DEBUG_FORTH 
a032						DMARK "NT9" 
a032						CALLMONITOR 
a032					endif 
a032			 
a032				; hl will be on the null term so forward on 
a032			 
a032				; get back the saved start of the token 
a032			 
a032 d9				exx 
a033 e5				push hl     ; save start of token just in case it is the right one 
a034 d9				exx 
a035 e1				pop hl        ; save it to hl 
a036			 
a036 c9				ret 
a037			 
a037			 
a037			; LIST needs to find a specific token   
a037			; FORGET needs to find a spefici token 
a037			 
a037			; SAVE needs to find all tokens by flag 
a037			; WORDS just needs to scan through all  by flag 
a037			; UWORDS needs to scan through all by flag 
a037			 
a037			 
a037			; given hl as pointer to start of dict look up string 
a037			; return hl as pointer to start of word block 
a037			; or 0 if not found 
a037			 
a037			forth_find_tok: 
a037 c9				ret 
a038			 
a038			; given hl as pointer to dict structure 
a038			; move to the next dict block structure 
a038			 
a038			forth_tok_next: 
a038				; hl now points to the address of the next word pointer  
a038				; TODO skip compiled symbol for now 
a038			;	push de 
a038 23				inc hl 
a039 5e				ld e, (hl) 
a03a 23				inc hl 
a03b 56				ld d, (hl) 
a03c 23				inc hl 
a03d			 
a03d eb				ex de,hl 
a03e			if DEBUG_FORTH_PARSE_NEXTWORD 
a03e				push bc 
a03e				ld bc, (cli_nextword) 
a03e						DMARK "NXW" 
a03e				CALLMONITOR 
a03e				pop bc 
a03e			endif 
a03e			;	pop de	 
a03e c9				ret 
a03f			 
a03f			 
a03f			 
a03f			; eof 
# End of file forth_parserv5.asm
a03f				include "forth_wordsv4.asm" 
a03f			 
a03f			; the core word dictionary v4 
a03f			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
a03f			 
a03f			; this is a linked list for each of the system words used 
a03f			; user defined words will follow the same format but will be in ram 
a03f			 
a03f			 
a03f			; 
a03f			; 
a03f			; define linked list: 
a03f			; 
a03f			; 1. compiled byte op code 
a03f			; 2. len of text word 
a03f			; 3. text word 
a03f			; 4. ptr to next dictionary word 
a03f			; 5. asm, calls etc for the word 
a03f			; 
a03f			;  if 1 == 0 then last word in dict  
a03f			;   
a03f			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
a03f			;  
a03f			;  
a03f			; create basic standard set of words 
a03f			; 
a03f			;  
a03f			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
a03f			; 2DUP 2DROP 2SWAP  
a03f			; @ C@ - get byte  
a03f			; ! C! - store byte 
a03f			; 0< true if less than zero 
a03f			; 0= true if zero 
a03f			; < >  
a03f			; = true if same 
a03f			; variables 
a03f			 
a03f			 
a03f			; Hardware specific words I may need 
a03f			; 
a03f			; IN OUT  
a03f			; calls to key util functions 
a03f			; calls to hardward abstraction stuff 
a03f			; easy control of frame buffers and lcd i/o 
a03f			; keyboard  
a03f			 
a03f			 
a03f			;DICT: macro 
a03f			; op_code, len, word, next 
a03f			;    word: 
a03f			;    db op_code 
a03f			;    ds word zero term 
a03f			;    dw next 
a03f			;    endm 
a03f			 
a03f			 
a03f			 
a03f			 
a03f			; op code 1 is a flag for user define words which are to be handled differently 
a03f			 
a03f			 
a03f			; 
a03f			; 
a03f			;    TODO on entry to a word this should be the expected environment 
a03f			;    hl - tos value if number then held, if string this is the ptr 
a03f			;    de -  
a03f			 
a03f			 
a03f			; opcode ranges 
a03f			; 0 - end of word dict 
a03f			; 255 - user define words 
a03f			 
a03f			sysdict: 
a03f			include "forth_opcodes.asm" 
a03f			; op codes for forth keywords 
a03f			; free to use code 0  
a03f				OPCODE_HEAP: equ  1 
a03f				OPCODE_EXEC: equ 2 
a03f				OPCODE_DUP: equ 3 
a03f				OPCODE_SWAP: equ 4 
a03f				OPCODE_COLN: equ 5 
a03f				OPCODE_SCOLN: equ 6 
a03f				OPCODE_DROP: equ 7 
a03f				OPCODE_DUP2: equ 8 
a03f				OPCODE_DROP2: equ 9 
a03f				OPCODE_SWAP2: equ 10 
a03f				OPCODE_AT: equ 11 
a03f				OPCODE_CAT: equ 12 
a03f				OPCODE_BANG: equ 13 
a03f				OPCODE_CBANG: equ 14 
a03f				OPCODE_SCALL: equ 15 
a03f				OPCODE_DEPTH: equ 16 
a03f				OPCODE_OVER: equ 17 
a03f				OPCODE_PAUSE: equ 18 
a03f				OPCODE_PAUSES: equ 19 
a03f				OPCODE_ROT: equ 20 
a03f			;free to reuse	OPCODE_WORDS: equ 21 
a03f			        OPCODE_NOT: equ 21 
a03f				OPCODE_UWORDS: equ 22 
a03f				OPCODE_BP: equ 23 
a03f				OPCODE_MONITOR: equ 24  
a03f				OPCODE_MALLOC: equ 25 
a03f				OPCODE_FREE: equ 26 
a03f				OPCODE_LIST: equ 27 
a03f				OPCODE_FORGET: equ 28 
a03f				OPCODE_NOP: equ 29 
a03f				OPCODE_COMO: equ 30 
a03f				OPCODE_COMC: equ 31 
a03f			;free to reuse	OPCODE_ENDCORE: equ 32 
a03f				OPCODE_AFTERSOUND: equ 33 
a03f				OPCODE_GP2: equ 34 
a03f				OPCODE_GP3: equ 35 
a03f				OPCODE_GP4: equ 36 
a03f				OPCODE_SIN: equ 37 
a03f				OPCODE_SOUT: equ 38 
a03f				OPCODE_SPIO: equ 39 
a03f				OPCODE_SPICEH: equ 40 
a03f				OPCODE_SPIOb: equ 41 
a03f				OPCODE_SPII: equ 42 
a03f				OPCODE_SESEL: equ 43 
a03f				OPCODE_CARTDEV: equ 44 
a03f			; free to reuse	OPCODE_ENDDEVICE: equ 45 
a03f				OPCODE_FB: equ 46 
a03f				OPCODE_EMIT: equ 47 
a03f				OPCODE_DOTH: equ 48 
a03f				OPCODE_DOTF: equ 49 
a03f				OPCODE_DOT: equ 50 
a03f				OPCODE_CLS: equ 51 
a03f				OPCODE_DRAW: equ 52 
a03f				OPCODE_DUMP: equ 53 
a03f				OPCODE_CDUMP: equ 54 
a03f				OPCODE_DAT: equ 55 
a03f				OPCODE_HOME: equ 56 
a03f				OPCODE_SPACE: equ 57 
a03f				OPCODE_SPACES: equ 58 
a03f				OPCODE_SCROLL: equ 59 
a03f				OPCODE_ATQ: equ 60 
a03f				OPCODE_AUTODSP: equ 61 
a03f				OPCODE_MENU: equ 62 
a03f			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
a03f				OPCODE_THEN: equ 64 
a03f				OPCODE_ELSE: equ 65 
a03f				OPCODE_DO: equ 66 
a03f				OPCODE_LOOP: equ 67 
a03f				OPCODE_I: equ 68 
a03f				OPCODE_DLOOP: equ 69  
a03f				OPCODE_REPEAT: equ 70  
a03f				OPCODE_UNTIL: equ 71 
a03f				OPCODE_ENDFLOW: equ 72 
a03f				OPCODE_WAITK: equ 73 
a03f				OPCODE_ACCEPT: equ 74 
a03f				OPCODE_EDIT: equ 75 
a03f			;free to reuse	OPCODE_ENDKEY: equ 76 
a03f				OPCODE_LZERO: equ 77 
a03f				OPCODE_TZERO: equ 78 
a03f				OPCODE_LESS: equ 79 
a03f				OPCODE_GT: equ 80 
a03f				OPCODE_EQUAL: equ 81  
a03f			;free to reuse	OPCODE_ENDLOGIC: equ 82 
a03f				OPCODE_NEG: equ 83 
a03f				OPCODE_DIV: equ 84 
a03f				OPCODE_MUL: equ 85 
a03f				OPCODE_MIN: equ 86 
a03f				OPCODE_MAX: equ 87 
a03f				OPCODE_RND16: equ 88 
a03f				OPCODE_RND8: equ 89 
a03f				OPCODE_RND: equ 90 
a03f			;free to reuse	OPCODE_ENDMATHS: equ 91  
a03f				OPCODE_BYNAME: equ 92 
a03f				OPCODE_DIR: equ 93 
a03f				OPCODE_SAVE: equ 94 
a03f				OPCODE_LOAD: equ 95 
a03f				OPCODE_BSAVE: equ 96 
a03f				OPCODE_BLOAD: equ 97 
a03f				OPCODE_SEO: equ 98  
a03f				OPCODE_SEI: equ 99 
a03f				OPCODE_SFREE: equ 100 
a03f				OPCODE_SIZE: equ 101 
a03f				OPCODE_CREATE: equ 102 
a03f				OPCODE_APPEND: equ 103 
a03f				OPCODE_SDEL: equ 104 
a03f				OPCODE_OPEN: equ 105 
a03f				OPCODE_READ: equ 106 
a03f				OPCODE_EOF: equ 106 
a03f				OPCODE_FORMAT: equ 107 
a03f				OPCODE_LABEL: equ 108 
a03f				OPCODE_LABELS: equ 109 
a03f			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
a03f				OPCODE_UPPER: equ 111 
a03f				OPCODE_LOWER: equ 112 
a03f				OPCODE_SUBSTR: equ 113 
a03f				OPCODE_LEFT: equ 114 
a03f				OPCODE_RIGHT: equ 115 
a03f				OPCODE_STR2NUM: equ 116 
a03f				OPCODE_NUM2STR: equ 117 
a03f				OPCODE_CONCAT: equ 118 
a03f				OPCODE_FIND: equ 119 
a03f				OPCODE_LEN: equ 120 
a03f				OPCODE_CHAR: equ 121 
a03f			; free to reuse	OPCODE_STRLEN: equ 122 
a03f			; free to reuse	OPCODE_ENDSTR: equ 123 
a03f				OPCODE_V0S: equ 124 
a03f				OPCODE_V0Q: equ 125 
a03f				OPCODE_V1S: equ 126 
a03f				OPCODE_V1Q: equ 127 
a03f				OPCODE_V2S: equ 128 
a03f				OPCODE_V2Q: equ 129 
a03f				OPCODE_V3S: equ 130 
a03f				OPCODE_V3Q: equ 131 
a03f			;free to reuse	OPCODE_END: equ 132 
a03f				OPCODE_ZDUP: equ 133 
a03f			 
a03f			; eof 
# End of file forth_opcodes.asm
a03f			 
a03f			include "forth_words_core.asm" 
a03f			 
a03f			; | ## Core Words 
a03f			 
a03f			;if MALLOC_4 
a03f			 
a03f			.HEAP: 
a03f				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
a03f 15				db WORD_SYS_CORE+OPCODE_HEAP             
a040 7e a0			dw .EXEC            
a042 05				db 4 + 1 
a043 .. 00			db "HEAP",0              
a048				endm 
# End of macro CWHEAD
a048			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
a048			; | | u1 - Current number of bytes in the heap 
a048			; | | u2 - Remaining bytes left on the heap 
a048			; | |  
a048			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
a048			 
a048			 
a048					if DEBUG_FORTH_WORDS_KEY 
a048						DMARK "HEP" 
a048 f5				push af  
a049 3a 5d a0			ld a, (.dmark)  
a04c 32 6b ee			ld (debug_mark),a  
a04f 3a 5e a0			ld a, (.dmark+1)  
a052 32 6c ee			ld (debug_mark+1),a  
a055 3a 5f a0			ld a, (.dmark+2)  
a058 32 6d ee			ld (debug_mark+2),a  
a05b 18 03			jr .pastdmark  
a05d ..			.dmark: db "HEP"  
a060 f1			.pastdmark: pop af  
a061			endm  
# End of macro DMARK
a061						CALLMONITOR 
a061 cd 6f ee			call debug_vector  
a064				endm  
# End of macro CALLMONITOR
a064					endif 
a064 2a 36 e4				ld hl, (free_list )      
a067 11 3b e4				ld de, heap_start 
a06a			 
a06a ed 52				sbc hl, de  
a06c			 
a06c cd 3a 9b				call forth_push_numhl 
a06f			 
a06f			 
a06f ed 5b 36 e4			ld de, (free_list )      
a073 21 a8 e2				ld hl, heap_end 
a076			 
a076 ed 52				sbc hl, de 
a078			 
a078 cd 3a 9b				call forth_push_numhl 
a07b					 
a07b			 
a07b					 
a07b			 
a07b			 
a07b			 
a07b					NEXTW 
a07b c3 e7 9e			jp macro_next 
a07e				endm 
# End of macro NEXTW
a07e			;endif 
a07e			 
a07e			.EXEC: 
a07e			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
a07e			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
a07e			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
a07e			;; > > 
a07e			;; > >   
a07e			;	STACKFRAME OFF $5efe $5f9f 
a07e			; 
a07e			;		if DEBUG_FORTH_WORDS_KEY 
a07e			;			DMARK "EXE" 
a07e			;			CALLMONITOR 
a07e			;		endif 
a07e			; 
a07e			;	FORTH_DSP_VALUEHL 
a07e			; 
a07e			;	FORTH_DSP_POP 
a07e			; 
a07e			;		if DEBUG_FORTH_WORDS 
a07e			;			DMARK "EX1" 
a07e			;			CALLMONITOR 
a07e			;		endif 
a07e			;;	ld e,(hl) 
a07e			;;	inc hl 
a07e			;;	ld d,(hl) 
a07e			;;	ex de,hl 
a07e			; 
a07e			;;		if DEBUG_FORTH_WORDS 
a07e			;;			DMARK "EX2" 
a07e			;;			CALLMONITOR 
a07e			;;		endif 
a07e			;	push hl 
a07e			; 
a07e			;	;ld a, 0 
a07e			;	;ld a, FORTH_END_BUFFER 
a07e			;	call strlenz 
a07e			;	inc hl   ; include zero term to copy 
a07e			;	inc hl   ; include term 
a07e			;	inc hl   ; include term 
a07e			;	ld b,0 
a07e			;	ld c,l 
a07e			;	pop hl 
a07e			;	ld de, execscratch 
a07e			;		if DEBUG_FORTH_WORDS 
a07e			;			DMARK "EX3" 
a07e			;			CALLMONITOR 
a07e			;		endif 
a07e			;	ldir 
a07e			; 
a07e			; 
a07e			;	ld hl, execscratch 
a07e			; 
a07e			;		if DEBUG_FORTH_WORDS 
a07e			;			DMARK "EXe" 
a07e			;			CALLMONITOR 
a07e			;		endif 
a07e			; 
a07e			;	call forthparse 
a07e			;	call forthexec 
a07e			;;	call forthexec_cleanup 
a07e			;;	call forthparse 
a07e			;;	call forthexec 
a07e			; 
a07e			;	STACKFRAMECHK OFF $5efe $5f9f 
a07e			; 
a07e			;	; an immediate word so no need to process any more words 
a07e			;	ret 
a07e			;	NEXTW 
a07e			 
a07e			; dead code - old version  
a07e			;	FORTH_RSP_NEXT 
a07e			 
a07e			;  
a07e			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
a07e			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
a07e			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
a07e			;	push hl 
a07e			;	push de 
a07e			;	push bc 
a07e			; 
a07e			; 
a07e			;		if DEBUG_FORTH_WORDS_KEY 
a07e			;			DMARK "EXR" 
a07e			;			CALLMONITOR 
a07e			;		endif 
a07e			; 
a07e			; 
a07e			; 
a07e			;	;v5 FORTH_DSP_VALUE 
a07e			;	FORTH_DSP_VALUEHL 
a07e			; 
a07e			;	; TODO do string type checks 
a07e			; 
a07e			;;v5	inc hl   ; skip type 
a07e			; 
a07e			;	push hl  ; source code  
a07e			;		if DEBUG_FORTH_WORDS 
a07e			;			DMARK "EX1" 
a07e			;			CALLMONITOR 
a07e			;		endif 
a07e			;	ld a, 0 
a07e			;	call strlent 
a07e			; 
a07e			;	inc hl 
a07e			;	inc hl 
a07e			;	inc hl 
a07e			;	inc hl 
a07e			; 
a07e			;	push hl    ; size 
a07e			; 
a07e			;		if DEBUG_FORTH_WORDS 
a07e			;			DMARK "EX2" 
a07e			;			CALLMONITOR 
a07e			;		endif 
a07e			;	call malloc 
a07e			; 
a07e			;	ex de, hl    ; de now contains malloc area 
a07e			;	pop bc   	; get byte count 
a07e			;	pop hl      ; get string to copy 
a07e			; 
a07e			;	push de     ; save malloc for free later 
a07e			; 
a07e			;		if DEBUG_FORTH_WORDS 
a07e			;			DMARK "EX3" 
a07e			;			CALLMONITOR 
a07e			;		endif 
a07e			;	ldir       ; duplicate string 
a07e			; 
a07e			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
a07e			;	 
a07e			;	; TODO fix the parse would be better than this...  
a07e			;	ex de, hl 
a07e			;	dec hl 
a07e			;	ld a, 0 
a07e			;	ld (hl), a 
a07e			;	dec hl 
a07e			;	ld a, ' ' 
a07e			;	ld (hl), a 
a07e			;	dec hl 
a07e			;	ld (hl), a 
a07e			; 
a07e			;	dec hl 
a07e			;	ld (hl), a 
a07e			; 
a07e			; 
a07e			;	FORTH_DSP_POP  
a07e			; 
a07e			;	pop hl     
a07e			;	push hl    ; save malloc area 
a07e			; 
a07e			;		if DEBUG_FORTH_WORDS 
a07e			;			DMARK "EX4" 
a07e			;			CALLMONITOR 
a07e			;		endif 
a07e			; 
a07e			;	call forthparse 
a07e			;	call forthexec 
a07e			;	 
a07e			;	pop hl 
a07e			;	if DEBUG_FORTH_WORDS 
a07e			;		DMARK "EX5" 
a07e			;		CALLMONITOR 
a07e			;	endif 
a07e			; 
a07e			;	if FORTH_ENABLE_FREE 
a07e			;	call free 
a07e			;	endif 
a07e			; 
a07e			;	if DEBUG_FORTH_WORDS 
a07e			;		DMARK "EX6" 
a07e			;		CALLMONITOR 
a07e			;	endif 
a07e			; 
a07e			;	pop bc 
a07e			;	pop de 
a07e			;	pop hl 
a07e			;;	FORTH_RSP_POP	  
a07e			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
a07e			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
a07e			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
a07e			; 
a07e			;	if DEBUG_FORTH_WORDS 
a07e			;		DMARK "EX7" 
a07e			;		CALLMONITOR 
a07e			;	endif 
a07e			;	NEXTW 
a07e			 
a07e			;.STKEXEC: 
a07e			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
a07e			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
a07e			; 
a07e			; 
a07e			;		if DEBUG_FORTH_WORDS_KEY 
a07e			;			DMARK "STX" 
a07e			;			CALLMONITOR 
a07e			;		endif 
a07e			; 
a07e			;	FORTH_DSP_VALUEHL 
a07e			; 
a07e			;	ld (store_tmp1), hl    ; count 
a07e			; 
a07e			;	FORTH_DSP_POP 
a07e			;.stkexec1: 
a07e			;	ld hl, (store_tmp1)   ; count 
a07e			;	ld a, 0 
a07e			;	cp l 
a07e			;	ret z 
a07e			; 
a07e			;	dec hl 
a07e			;	ld (store_tmp1), hl    ; count 
a07e			;	 
a07e			;	FORTH_DSP_VALUEHL 
a07e			;	push hl 
a07e			;	 
a07e			;		if DEBUG_FORTH_WORDS 
a07e			;			DMARK "EXp" 
a07e			;			CALLMONITOR 
a07e			;		endif 
a07e			;	FORTH_DSP_POP 
a07e			; 
a07e			;	call strlenz 
a07e			;	inc hl   ; include zero term to copy 
a07e			;	inc hl   ; include zero term to copy 
a07e			;	inc hl   ; include zero term to copy 
a07e			;	ld b,0 
a07e			;	ld c,l 
a07e			;	pop hl 
a07e			;	ld de, execscratch 
a07e			;		if DEBUG_FORTH_WORDS 
a07e			;			DMARK "EX3" 
a07e			;			CALLMONITOR 
a07e			;		endif 
a07e			;	ldir 
a07e			; 
a07e			; 
a07e			;	ld hl, execscratch 
a07e			; 
a07e			;		if DEBUG_FORTH_WORDS 
a07e			;			DMARK "EXP" 
a07e			;			CALLMONITOR 
a07e			;		endif 
a07e			; 
a07e			;	call forthparse 
a07e			;	ld hl, execscratch 
a07e			;		if DEBUG_FORTH_WORDS 
a07e			;			DMARK "EXx" 
a07e			;			CALLMONITOR 
a07e			;		endif 
a07e			;	call forthexec 
a07e			; 
a07e			;	jp .stkexec1 
a07e			; 
a07e			;	ret 
a07e			 
a07e			 
a07e			.DUP: 
a07e				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
a07e 17				db WORD_SYS_CORE+OPCODE_DUP             
a07f f4 a0			dw .ZDUP            
a081 04				db 3 + 1 
a082 .. 00			db "DUP",0              
a086				endm 
# End of macro CWHEAD
a086			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
a086			 
a086					if DEBUG_FORTH_WORDS_KEY 
a086						DMARK "DUP" 
a086 f5				push af  
a087 3a 9b a0			ld a, (.dmark)  
a08a 32 6b ee			ld (debug_mark),a  
a08d 3a 9c a0			ld a, (.dmark+1)  
a090 32 6c ee			ld (debug_mark+1),a  
a093 3a 9d a0			ld a, (.dmark+2)  
a096 32 6d ee			ld (debug_mark+2),a  
a099 18 03			jr .pastdmark  
a09b ..			.dmark: db "DUP"  
a09e f1			.pastdmark: pop af  
a09f			endm  
# End of macro DMARK
a09f						CALLMONITOR 
a09f cd 6f ee			call debug_vector  
a0a2				endm  
# End of macro CALLMONITOR
a0a2					endif 
a0a2			 
a0a2					FORTH_DSP 
a0a2 cd f7 9c			call macro_forth_dsp 
a0a5				endm 
# End of macro FORTH_DSP
a0a5			 
a0a5 7e					ld a, (HL) 
a0a6 fe 01				cp DS_TYPE_STR 
a0a8 20 25				jr nz, .dupinum 
a0aa			 
a0aa					; push another string 
a0aa			 
a0aa					FORTH_DSP_VALUEHL     		 
a0aa cd 31 9d			call macro_dsp_valuehl 
a0ad				endm 
# End of macro FORTH_DSP_VALUEHL
a0ad			 
a0ad				if DEBUG_FORTH_WORDS 
a0ad					DMARK "DUs" 
a0ad f5				push af  
a0ae 3a c2 a0			ld a, (.dmark)  
a0b1 32 6b ee			ld (debug_mark),a  
a0b4 3a c3 a0			ld a, (.dmark+1)  
a0b7 32 6c ee			ld (debug_mark+1),a  
a0ba 3a c4 a0			ld a, (.dmark+2)  
a0bd 32 6d ee			ld (debug_mark+2),a  
a0c0 18 03			jr .pastdmark  
a0c2 ..			.dmark: db "DUs"  
a0c5 f1			.pastdmark: pop af  
a0c6			endm  
# End of macro DMARK
a0c6					CALLMONITOR 
a0c6 cd 6f ee			call debug_vector  
a0c9				endm  
# End of macro CALLMONITOR
a0c9				endif 
a0c9 cd a8 9b				call forth_push_str 
a0cc			 
a0cc					NEXTW 
a0cc c3 e7 9e			jp macro_next 
a0cf				endm 
# End of macro NEXTW
a0cf			 
a0cf			 
a0cf			.dupinum: 
a0cf					 
a0cf			 
a0cf			 
a0cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0cf cd 31 9d			call macro_dsp_valuehl 
a0d2				endm 
# End of macro FORTH_DSP_VALUEHL
a0d2			 
a0d2				; TODO add floating point number detection 
a0d2			 
a0d2				if DEBUG_FORTH_WORDS 
a0d2					DMARK "DUi" 
a0d2 f5				push af  
a0d3 3a e7 a0			ld a, (.dmark)  
a0d6 32 6b ee			ld (debug_mark),a  
a0d9 3a e8 a0			ld a, (.dmark+1)  
a0dc 32 6c ee			ld (debug_mark+1),a  
a0df 3a e9 a0			ld a, (.dmark+2)  
a0e2 32 6d ee			ld (debug_mark+2),a  
a0e5 18 03			jr .pastdmark  
a0e7 ..			.dmark: db "DUi"  
a0ea f1			.pastdmark: pop af  
a0eb			endm  
# End of macro DMARK
a0eb					CALLMONITOR 
a0eb cd 6f ee			call debug_vector  
a0ee				endm  
# End of macro CALLMONITOR
a0ee				endif 
a0ee			 
a0ee cd 3a 9b				call forth_push_numhl 
a0f1					NEXTW 
a0f1 c3 e7 9e			jp macro_next 
a0f4				endm 
# End of macro NEXTW
a0f4			.ZDUP: 
a0f4				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a0f4 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a0f5 2c a1			dw .SWAP            
a0f7 05				db 4 + 1 
a0f8 .. 00			db "?DUP",0              
a0fd				endm 
# End of macro CWHEAD
a0fd			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a0fd			 
a0fd					if DEBUG_FORTH_WORDS_KEY 
a0fd						DMARK "qDU" 
a0fd f5				push af  
a0fe 3a 12 a1			ld a, (.dmark)  
a101 32 6b ee			ld (debug_mark),a  
a104 3a 13 a1			ld a, (.dmark+1)  
a107 32 6c ee			ld (debug_mark+1),a  
a10a 3a 14 a1			ld a, (.dmark+2)  
a10d 32 6d ee			ld (debug_mark+2),a  
a110 18 03			jr .pastdmark  
a112 ..			.dmark: db "qDU"  
a115 f1			.pastdmark: pop af  
a116			endm  
# End of macro DMARK
a116						CALLMONITOR 
a116 cd 6f ee			call debug_vector  
a119				endm  
# End of macro CALLMONITOR
a119					endif 
a119					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a119 cd 31 9d			call macro_dsp_valuehl 
a11c				endm 
# End of macro FORTH_DSP_VALUEHL
a11c			 
a11c e5					push hl 
a11d			 
a11d					; is it a zero? 
a11d			 
a11d 3e 00				ld a, 0 
a11f 84					add h 
a120 85					add l 
a121			 
a121 e1					pop hl 
a122			 
a122 fe 00				cp 0 
a124 28 03				jr z, .dup2orig 
a126			 
a126			 
a126 cd 3a 9b				call forth_push_numhl 
a129			 
a129			 
a129				; TODO add floating point number detection 
a129			 
a129			.dup2orig: 
a129			 
a129					NEXTW 
a129 c3 e7 9e			jp macro_next 
a12c				endm 
# End of macro NEXTW
a12c			.SWAP: 
a12c				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a12c 18				db WORD_SYS_CORE+OPCODE_SWAP             
a12d 6b a1			dw .COLN            
a12f 05				db 4 + 1 
a130 .. 00			db "SWAP",0              
a135				endm 
# End of macro CWHEAD
a135			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a135					if DEBUG_FORTH_WORDS_KEY 
a135						DMARK "SWP" 
a135 f5				push af  
a136 3a 4a a1			ld a, (.dmark)  
a139 32 6b ee			ld (debug_mark),a  
a13c 3a 4b a1			ld a, (.dmark+1)  
a13f 32 6c ee			ld (debug_mark+1),a  
a142 3a 4c a1			ld a, (.dmark+2)  
a145 32 6d ee			ld (debug_mark+2),a  
a148 18 03			jr .pastdmark  
a14a ..			.dmark: db "SWP"  
a14d f1			.pastdmark: pop af  
a14e			endm  
# End of macro DMARK
a14e						CALLMONITOR 
a14e cd 6f ee			call debug_vector  
a151				endm  
# End of macro CALLMONITOR
a151					endif 
a151			 
a151					FORTH_DSP_VALUEHL 
a151 cd 31 9d			call macro_dsp_valuehl 
a154				endm 
# End of macro FORTH_DSP_VALUEHL
a154 e5					push hl     ; w2 
a155			 
a155					FORTH_DSP_POP 
a155 cd e9 9d			call macro_forth_dsp_pop 
a158				endm 
# End of macro FORTH_DSP_POP
a158			 
a158					FORTH_DSP_VALUEHL 
a158 cd 31 9d			call macro_dsp_valuehl 
a15b				endm 
# End of macro FORTH_DSP_VALUEHL
a15b			 
a15b					FORTH_DSP_POP 
a15b cd e9 9d			call macro_forth_dsp_pop 
a15e				endm 
# End of macro FORTH_DSP_POP
a15e			 
a15e d1					pop de     ; w2	, hl = w1 
a15f			 
a15f eb					ex de, hl 
a160 d5					push de 
a161			 
a161 cd 3a 9b				call forth_push_numhl 
a164			 
a164 e1					pop hl 
a165			 
a165 cd 3a 9b				call forth_push_numhl 
a168					 
a168			 
a168					NEXTW 
a168 c3 e7 9e			jp macro_next 
a16b				endm 
# End of macro NEXTW
a16b			.COLN: 
a16b				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a16b 19				db WORD_SYS_CORE+OPCODE_COLN             
a16c f7 a2			dw .SCOLN            
a16e 02				db 1 + 1 
a16f .. 00			db ":",0              
a171				endm 
# End of macro CWHEAD
a171			; | : ( -- )         Create new word | DONE 
a171			 
a171					if DEBUG_FORTH_WORDS_KEY 
a171						DMARK "CLN" 
a171 f5				push af  
a172 3a 86 a1			ld a, (.dmark)  
a175 32 6b ee			ld (debug_mark),a  
a178 3a 87 a1			ld a, (.dmark+1)  
a17b 32 6c ee			ld (debug_mark+1),a  
a17e 3a 88 a1			ld a, (.dmark+2)  
a181 32 6d ee			ld (debug_mark+2),a  
a184 18 03			jr .pastdmark  
a186 ..			.dmark: db "CLN"  
a189 f1			.pastdmark: pop af  
a18a			endm  
# End of macro DMARK
a18a						CALLMONITOR 
a18a cd 6f ee			call debug_vector  
a18d				endm  
# End of macro CALLMONITOR
a18d					endif 
a18d				STACKFRAME OFF $8efe $989f 
a18d				if DEBUG_STACK_IMB 
a18d					if OFF 
a18d						exx 
a18d						ld de, $8efe 
a18d						ld a, d 
a18d						ld hl, curframe 
a18d						call hexout 
a18d						ld a, e 
a18d						ld hl, curframe+2 
a18d						call hexout 
a18d						ld hl, $8efe 
a18d						push hl 
a18d						ld hl, $989f 
a18d						push hl 
a18d						exx 
a18d					endif 
a18d				endif 
a18d			endm 
# End of macro STACKFRAME
a18d				; get parser buffer length  of new word 
a18d			 
a18d				 
a18d			 
a18d					; move tok past this to start of name defintition 
a18d					; TODO get word to define 
a18d					; TODO Move past word token 
a18d					; TODO get length of string up to the ';' 
a18d			 
a18d 2a c2 e5			ld hl, (os_tok_ptr) 
a190 23				inc hl 
a191 23				inc hl 
a192			 
a192 3e 3b			ld a, ';' 
a194 cd 45 91			call strlent 
a197			 
a197 7d				ld a,l 
a198 32 bd e2			ld (os_new_parse_len), a 
a19b			 
a19b			 
a19b			if DEBUG_FORTH_UWORD 
a19b ed 5b c2 e5		ld de, (os_tok_ptr) 
a19f						DMARK ":01" 
a19f f5				push af  
a1a0 3a b4 a1			ld a, (.dmark)  
a1a3 32 6b ee			ld (debug_mark),a  
a1a6 3a b5 a1			ld a, (.dmark+1)  
a1a9 32 6c ee			ld (debug_mark+1),a  
a1ac 3a b6 a1			ld a, (.dmark+2)  
a1af 32 6d ee			ld (debug_mark+2),a  
a1b2 18 03			jr .pastdmark  
a1b4 ..			.dmark: db ":01"  
a1b7 f1			.pastdmark: pop af  
a1b8			endm  
# End of macro DMARK
a1b8				CALLMONITOR 
a1b8 cd 6f ee			call debug_vector  
a1bb				endm  
# End of macro CALLMONITOR
a1bb			endif 
a1bb			 
a1bb			; 
a1bb			;  new word memory layout: 
a1bb			;  
a1bb			;    : adg 6666 ;  
a1bb			; 
a1bb			;    db   1     ; user defined word  
a1bb 23				inc hl    
a1bc			;    dw   sysdict 
a1bc 23				inc hl 
a1bd 23				inc hl 
a1be			;    db <word len>+1 (for null) 
a1be 23				inc hl 
a1bf			;    db .... <word> 
a1bf			; 
a1bf			 
a1bf 23				inc hl    ; some extras for the word preamble before the above 
a1c0 23				inc hl 
a1c1 23				inc hl 
a1c2 23				inc hl 
a1c3 23				inc hl 
a1c4 23				inc hl 
a1c5 23				inc hl  
a1c6 23				inc hl 
a1c7 23				inc hl 
a1c8 23				inc hl 
a1c9 23				inc hl 
a1ca 23				inc hl 
a1cb 23				inc hl 
a1cc 23				inc hl     ; TODO how many do we really need?     maybe only 6 
a1cd			;       exec word buffer 
a1cd			;	<ptr word>   
a1cd 23				inc hl 
a1ce 23				inc hl 
a1cf			;       <word list><null term> 7F final term 
a1cf			 
a1cf			 
a1cf			if DEBUG_FORTH_UWORD 
a1cf						DMARK ":02" 
a1cf f5				push af  
a1d0 3a e4 a1			ld a, (.dmark)  
a1d3 32 6b ee			ld (debug_mark),a  
a1d6 3a e5 a1			ld a, (.dmark+1)  
a1d9 32 6c ee			ld (debug_mark+1),a  
a1dc 3a e6 a1			ld a, (.dmark+2)  
a1df 32 6d ee			ld (debug_mark+2),a  
a1e2 18 03			jr .pastdmark  
a1e4 ..			.dmark: db ":02"  
a1e7 f1			.pastdmark: pop af  
a1e8			endm  
# End of macro DMARK
a1e8				CALLMONITOR 
a1e8 cd 6f ee			call debug_vector  
a1eb				endm  
# End of macro CALLMONITOR
a1eb			endif 
a1eb			 
a1eb				 
a1eb					; malloc the size 
a1eb			 
a1eb cd a3 91				call malloc 
a1ee 22 bf e2				ld (os_new_malloc), hl     ; save malloc start 
a1f1			 
a1f1			;    db   1     ; user defined word  
a1f1 3e 01				ld a, WORD_SYS_UWORD  
a1f3 77					ld (hl), a 
a1f4				 
a1f4 23				inc hl    
a1f5			;    dw   sysdict 
a1f5 11 3f a0			ld de, sysdict       ; continue on with the scan to the system dict 
a1f8 73				ld (hl), e 
a1f9 23				inc hl 
a1fa 72				ld (hl), d 
a1fb 23				inc hl 
a1fc			 
a1fc			 
a1fc			;    Setup dict word 
a1fc			 
a1fc 23				inc hl 
a1fd 22 b9 e2			ld (os_new_work_ptr), hl     ; save start of dict word  
a200			 
a200				; 1. get length of dict word 
a200			 
a200			 
a200 2a c2 e5			ld hl, (os_tok_ptr) 
a203 23				inc hl 
a204 23				inc hl    ; position to start of dict word 
a205 3e 00			ld a, 0 
a207 cd 45 91			call strlent 
a20a			 
a20a			 
a20a 23				inc hl    ; to include null??? 
a20b			 
a20b				; write length of dict word 
a20b			 
a20b ed 5b b9 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a20f 1b				dec de 
a210 eb				ex de, hl 
a211 73				ld (hl), e 
a212 eb				ex de, hl 
a213			 
a213				 
a213			 
a213				; copy  
a213 4d				ld c, l 
a214 06 00			ld b, 0 
a216 ed 5b b9 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a21a 2a c2 e5			ld hl, (os_tok_ptr) 
a21d 23				inc hl 
a21e 23				inc hl    ; position to start of dict word 
a21f				 
a21f			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a21f				 
a21f				; TODO need to convert word to upper case 
a21f			 
a21f			ucasetok:	 
a21f 7e				ld a,(hl) 
a220 cd 31 91			call toUpper 
a223 77				ld (hl),a 
a224 ed a0			ldi 
a226 f2 1f a2		 	jp p, ucasetok 
a229			 
a229			 
a229			 
a229				; de now points to start of where the word body code should be placed 
a229 ed 53 b9 e2		ld (os_new_work_ptr), de 
a22d				; hl now points to the words to throw at forthexec which needs to be copied 
a22d 22 b7 e2			ld (os_new_src_ptr), hl 
a230			 
a230				; TODO add 'call to forthexec' 
a230			 
a230			if DEBUG_FORTH_UWORD 
a230 c5				push bc 
a231 ed 4b bf e2		ld bc, (os_new_malloc) 
a235						DMARK ":0x" 
a235 f5				push af  
a236 3a 4a a2			ld a, (.dmark)  
a239 32 6b ee			ld (debug_mark),a  
a23c 3a 4b a2			ld a, (.dmark+1)  
a23f 32 6c ee			ld (debug_mark+1),a  
a242 3a 4c a2			ld a, (.dmark+2)  
a245 32 6d ee			ld (debug_mark+2),a  
a248 18 03			jr .pastdmark  
a24a ..			.dmark: db ":0x"  
a24d f1			.pastdmark: pop af  
a24e			endm  
# End of macro DMARK
a24e				CALLMONITOR 
a24e cd 6f ee			call debug_vector  
a251				endm  
# End of macro CALLMONITOR
a251 c1				pop bc 
a252			endif 
a252			 
a252			 
a252				; create word preamble which should be: 
a252			 
a252			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a252			 
a252				;    ld hl, <word code> 
a252				;    jp user_exec 
a252			        ;    <word code bytes> 
a252			 
a252			 
a252			;	inc de     ; TODO ??? or are we already past the word's null 
a252 eb				ex de, hl 
a253			 
a253 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a255			 
a255 23				inc hl 
a256 22 b3 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a259 23				inc hl 
a25a			 
a25a 23				inc hl 
a25b 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a25d			 
a25d 01 54 cb			ld bc, user_exec 
a260 23				inc hl 
a261 71				ld (hl), c     ; poke address of user_exec 
a262 23				inc hl 
a263 70				ld (hl), b     
a264			 ; 
a264			;	inc hl 
a264			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a264			; 
a264			; 
a264			;	ld bc, macro_forth_rsp_next 
a264			;	inc hl 
a264			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a264			;	inc hl 
a264			;	ld (hl), b     
a264			 ; 
a264			;	inc hl 
a264			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a264			; 
a264			; 
a264			;	inc hl 
a264			;	ld bc, forthexec 
a264			;	ld (hl), c     ; poke address of forthexec 
a264			;	inc hl 
a264			;	ld (hl), b      
a264			; 
a264			;	inc hl 
a264			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a264			; 
a264			;	ld bc, user_dict_next 
a264			;	inc hl 
a264			;	ld (hl), c     ; poke address of forthexec 
a264			;	inc hl 
a264			;	ld (hl), b      
a264			 
a264				; hl is now where we need to copy the word byte data to save this 
a264			 
a264 23				inc hl 
a265 22 b5 e2			ld (os_new_exec), hl 
a268				 
a268				; copy definition 
a268			 
a268 eb				ex de, hl 
a269			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a269			;	inc de    ; skip the PC for this parse 
a269 3a bd e2			ld a, (os_new_parse_len) 
a26c 4f				ld c, a 
a26d 06 00			ld b, 0 
a26f ed b0			ldir		 ; copy defintion 
a271			 
a271			 
a271				; poke the address of where the new word bytes live for forthexec 
a271			 
a271 2a b3 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a274			 
a274 ed 5b b5 e2		ld de, (os_new_exec)      
a278				 
a278 73				ld (hl), e 
a279 23				inc hl 
a27a 72				ld (hl), d 
a27b			 
a27b					; TODO copy last user dict word next link to this word 
a27b					; TODO update last user dict word to point to this word 
a27b			; 
a27b			; hl f923 de 812a ; bc 811a 
a27b			 
a27b			if DEBUG_FORTH_UWORD 
a27b c5				push bc 
a27c ed 4b bf e2		ld bc, (os_new_malloc) 
a280						DMARK ":0A" 
a280 f5				push af  
a281 3a 95 a2			ld a, (.dmark)  
a284 32 6b ee			ld (debug_mark),a  
a287 3a 96 a2			ld a, (.dmark+1)  
a28a 32 6c ee			ld (debug_mark+1),a  
a28d 3a 97 a2			ld a, (.dmark+2)  
a290 32 6d ee			ld (debug_mark+2),a  
a293 18 03			jr .pastdmark  
a295 ..			.dmark: db ":0A"  
a298 f1			.pastdmark: pop af  
a299			endm  
# End of macro DMARK
a299				CALLMONITOR 
a299 cd 6f ee			call debug_vector  
a29c				endm  
# End of macro CALLMONITOR
a29c c1				pop bc 
a29d			endif 
a29d			if DEBUG_FORTH_UWORD 
a29d c5				push bc 
a29e ed 4b bf e2		ld bc, (os_new_malloc) 
a2a2 03				inc bc 
a2a3 03				inc bc 
a2a4 03				inc bc 
a2a5 03				inc bc 
a2a6 03				inc bc 
a2a7 03				inc bc 
a2a8 03				inc bc 
a2a9 03				inc bc 
a2aa			 
a2aa						DMARK ":0B" 
a2aa f5				push af  
a2ab 3a bf a2			ld a, (.dmark)  
a2ae 32 6b ee			ld (debug_mark),a  
a2b1 3a c0 a2			ld a, (.dmark+1)  
a2b4 32 6c ee			ld (debug_mark+1),a  
a2b7 3a c1 a2			ld a, (.dmark+2)  
a2ba 32 6d ee			ld (debug_mark+2),a  
a2bd 18 03			jr .pastdmark  
a2bf ..			.dmark: db ":0B"  
a2c2 f1			.pastdmark: pop af  
a2c3			endm  
# End of macro DMARK
a2c3				CALLMONITOR 
a2c3 cd 6f ee			call debug_vector  
a2c6				endm  
# End of macro CALLMONITOR
a2c6 c1				pop bc 
a2c7			endif 
a2c7			 
a2c7			; update word dict linked list for new word 
a2c7			 
a2c7			 
a2c7 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a2ca 23			inc hl     ; move to next work linked list ptr 
a2cb			 
a2cb ed 5b bf e2	ld de, (os_new_malloc)		 ; new next word 
a2cf 73			ld (hl), e 
a2d0 23			inc hl 
a2d1 72			ld (hl), d 
a2d2			 
a2d2			if DEBUG_FORTH_UWORD 
a2d2 ed 4b be e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a2d6			endif 
a2d6			 
a2d6 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a2da			 
a2da			 
a2da			if DEBUG_FORTH_UWORD 
a2da						DMARK ":0+" 
a2da f5				push af  
a2db 3a ef a2			ld a, (.dmark)  
a2de 32 6b ee			ld (debug_mark),a  
a2e1 3a f0 a2			ld a, (.dmark+1)  
a2e4 32 6c ee			ld (debug_mark+1),a  
a2e7 3a f1 a2			ld a, (.dmark+2)  
a2ea 32 6d ee			ld (debug_mark+2),a  
a2ed 18 03			jr .pastdmark  
a2ef ..			.dmark: db ":0+"  
a2f2 f1			.pastdmark: pop af  
a2f3			endm  
# End of macro DMARK
a2f3				CALLMONITOR 
a2f3 cd 6f ee			call debug_vector  
a2f6				endm  
# End of macro CALLMONITOR
a2f6			endif 
a2f6			 
a2f6				STACKFRAMECHK OFF $8efe $989f 
a2f6				if DEBUG_STACK_IMB 
a2f6					if OFF 
a2f6						exx 
a2f6						ld hl, $989f 
a2f6						pop de   ; $989f 
a2f6						call cmp16 
a2f6						jr nz, .spnosame 
a2f6						ld hl, $8efe 
a2f6						pop de   ; $8efe 
a2f6						call cmp16 
a2f6						jr z, .spfrsame 
a2f6						.spnosame: call showsperror 
a2f6						.spfrsame: nop 
a2f6						exx 
a2f6					endif 
a2f6				endif 
a2f6			endm 
# End of macro STACKFRAMECHK
a2f6			 
a2f6 c9			ret    ; dont process any remaining parser tokens as they form new word 
a2f7			 
a2f7			 
a2f7			 
a2f7			 
a2f7			;		NEXT 
a2f7			.SCOLN: 
a2f7			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a2f7 06				db OPCODE_SCOLN 
a2f8 43 a3			dw .DROP 
a2fa 02				db 2 
a2fb .. 00			db ";",0           
a2fd			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a2fd					if DEBUG_FORTH_WORDS_KEY 
a2fd						DMARK "SCN" 
a2fd f5				push af  
a2fe 3a 12 a3			ld a, (.dmark)  
a301 32 6b ee			ld (debug_mark),a  
a304 3a 13 a3			ld a, (.dmark+1)  
a307 32 6c ee			ld (debug_mark+1),a  
a30a 3a 14 a3			ld a, (.dmark+2)  
a30d 32 6d ee			ld (debug_mark+2),a  
a310 18 03			jr .pastdmark  
a312 ..			.dmark: db "SCN"  
a315 f1			.pastdmark: pop af  
a316			endm  
# End of macro DMARK
a316						CALLMONITOR 
a316 cd 6f ee			call debug_vector  
a319				endm  
# End of macro CALLMONITOR
a319					endif 
a319					FORTH_RSP_TOS 
a319 cd f8 9a			call macro_forth_rsp_tos 
a31c				endm 
# End of macro FORTH_RSP_TOS
a31c e5					push hl 
a31d					FORTH_RSP_POP 
a31d cd 02 9b			call macro_forth_rsp_pop 
a320				endm 
# End of macro FORTH_RSP_POP
a320 e1					pop hl 
a321			;		ex de,hl 
a321 22 c2 e5				ld (os_tok_ptr),hl 
a324			 
a324			if DEBUG_FORTH_UWORD 
a324						DMARK "SCL" 
a324 f5				push af  
a325 3a 39 a3			ld a, (.dmark)  
a328 32 6b ee			ld (debug_mark),a  
a32b 3a 3a a3			ld a, (.dmark+1)  
a32e 32 6c ee			ld (debug_mark+1),a  
a331 3a 3b a3			ld a, (.dmark+2)  
a334 32 6d ee			ld (debug_mark+2),a  
a337 18 03			jr .pastdmark  
a339 ..			.dmark: db "SCL"  
a33c f1			.pastdmark: pop af  
a33d			endm  
# End of macro DMARK
a33d				CALLMONITOR 
a33d cd 6f ee			call debug_vector  
a340				endm  
# End of macro CALLMONITOR
a340			endif 
a340					NEXTW 
a340 c3 e7 9e			jp macro_next 
a343				endm 
# End of macro NEXTW
a343			 
a343			.DROP: 
a343				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a343 1b				db WORD_SYS_CORE+OPCODE_DROP             
a344 6e a3			dw .DUP2            
a346 05				db 4 + 1 
a347 .. 00			db "DROP",0              
a34c				endm 
# End of macro CWHEAD
a34c			; | DROP ( w -- )   drop the TOS item   | DONE 
a34c					if DEBUG_FORTH_WORDS_KEY 
a34c						DMARK "DRP" 
a34c f5				push af  
a34d 3a 61 a3			ld a, (.dmark)  
a350 32 6b ee			ld (debug_mark),a  
a353 3a 62 a3			ld a, (.dmark+1)  
a356 32 6c ee			ld (debug_mark+1),a  
a359 3a 63 a3			ld a, (.dmark+2)  
a35c 32 6d ee			ld (debug_mark+2),a  
a35f 18 03			jr .pastdmark  
a361 ..			.dmark: db "DRP"  
a364 f1			.pastdmark: pop af  
a365			endm  
# End of macro DMARK
a365						CALLMONITOR 
a365 cd 6f ee			call debug_vector  
a368				endm  
# End of macro CALLMONITOR
a368					endif 
a368					FORTH_DSP_POP 
a368 cd e9 9d			call macro_forth_dsp_pop 
a36b				endm 
# End of macro FORTH_DSP_POP
a36b					NEXTW 
a36b c3 e7 9e			jp macro_next 
a36e				endm 
# End of macro NEXTW
a36e			.DUP2: 
a36e				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a36e 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a36f b3 a3			dw .DROP2            
a371 05				db 4 + 1 
a372 .. 00			db "2DUP",0              
a377				endm 
# End of macro CWHEAD
a377			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a377					if DEBUG_FORTH_WORDS_KEY 
a377						DMARK "2DU" 
a377 f5				push af  
a378 3a 8c a3			ld a, (.dmark)  
a37b 32 6b ee			ld (debug_mark),a  
a37e 3a 8d a3			ld a, (.dmark+1)  
a381 32 6c ee			ld (debug_mark+1),a  
a384 3a 8e a3			ld a, (.dmark+2)  
a387 32 6d ee			ld (debug_mark+2),a  
a38a 18 03			jr .pastdmark  
a38c ..			.dmark: db "2DU"  
a38f f1			.pastdmark: pop af  
a390			endm  
# End of macro DMARK
a390						CALLMONITOR 
a390 cd 6f ee			call debug_vector  
a393				endm  
# End of macro CALLMONITOR
a393					endif 
a393					FORTH_DSP_VALUEHL 
a393 cd 31 9d			call macro_dsp_valuehl 
a396				endm 
# End of macro FORTH_DSP_VALUEHL
a396 e5					push hl      ; 2 
a397			 
a397					FORTH_DSP_POP 
a397 cd e9 9d			call macro_forth_dsp_pop 
a39a				endm 
# End of macro FORTH_DSP_POP
a39a					 
a39a					FORTH_DSP_VALUEHL 
a39a cd 31 9d			call macro_dsp_valuehl 
a39d				endm 
# End of macro FORTH_DSP_VALUEHL
a39d			;		push hl      ; 1 
a39d			 
a39d					FORTH_DSP_POP 
a39d cd e9 9d			call macro_forth_dsp_pop 
a3a0				endm 
# End of macro FORTH_DSP_POP
a3a0			 
a3a0			;		pop hl       ; 1 
a3a0 d1					pop de       ; 2 
a3a1			 
a3a1 cd 3a 9b				call forth_push_numhl 
a3a4 eb					ex de, hl 
a3a5 cd 3a 9b				call forth_push_numhl 
a3a8			 
a3a8					 
a3a8 eb					ex de, hl 
a3a9			 
a3a9 cd 3a 9b				call forth_push_numhl 
a3ac eb					ex de, hl 
a3ad cd 3a 9b				call forth_push_numhl 
a3b0			 
a3b0			 
a3b0					NEXTW 
a3b0 c3 e7 9e			jp macro_next 
a3b3				endm 
# End of macro NEXTW
a3b3			.DROP2: 
a3b3				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a3b3 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a3b4 e2 a3			dw .SWAP2            
a3b6 06				db 5 + 1 
a3b7 .. 00			db "2DROP",0              
a3bd				endm 
# End of macro CWHEAD
a3bd			; | 2DROP ( w w -- )    Double drop | DONE 
a3bd					if DEBUG_FORTH_WORDS_KEY 
a3bd						DMARK "2DR" 
a3bd f5				push af  
a3be 3a d2 a3			ld a, (.dmark)  
a3c1 32 6b ee			ld (debug_mark),a  
a3c4 3a d3 a3			ld a, (.dmark+1)  
a3c7 32 6c ee			ld (debug_mark+1),a  
a3ca 3a d4 a3			ld a, (.dmark+2)  
a3cd 32 6d ee			ld (debug_mark+2),a  
a3d0 18 03			jr .pastdmark  
a3d2 ..			.dmark: db "2DR"  
a3d5 f1			.pastdmark: pop af  
a3d6			endm  
# End of macro DMARK
a3d6						CALLMONITOR 
a3d6 cd 6f ee			call debug_vector  
a3d9				endm  
# End of macro CALLMONITOR
a3d9					endif 
a3d9					FORTH_DSP_POP 
a3d9 cd e9 9d			call macro_forth_dsp_pop 
a3dc				endm 
# End of macro FORTH_DSP_POP
a3dc					FORTH_DSP_POP 
a3dc cd e9 9d			call macro_forth_dsp_pop 
a3df				endm 
# End of macro FORTH_DSP_POP
a3df					NEXTW 
a3df c3 e7 9e			jp macro_next 
a3e2				endm 
# End of macro NEXTW
a3e2			.SWAP2: 
a3e2				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a3e2 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a3e3 0b a4			dw .AT            
a3e5 06				db 5 + 1 
a3e6 .. 00			db "2SWAP",0              
a3ec				endm 
# End of macro CWHEAD
a3ec			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a3ec					if DEBUG_FORTH_WORDS_KEY 
a3ec						DMARK "2SW" 
a3ec f5				push af  
a3ed 3a 01 a4			ld a, (.dmark)  
a3f0 32 6b ee			ld (debug_mark),a  
a3f3 3a 02 a4			ld a, (.dmark+1)  
a3f6 32 6c ee			ld (debug_mark+1),a  
a3f9 3a 03 a4			ld a, (.dmark+2)  
a3fc 32 6d ee			ld (debug_mark+2),a  
a3ff 18 03			jr .pastdmark  
a401 ..			.dmark: db "2SW"  
a404 f1			.pastdmark: pop af  
a405			endm  
# End of macro DMARK
a405						CALLMONITOR 
a405 cd 6f ee			call debug_vector  
a408				endm  
# End of macro CALLMONITOR
a408					endif 
a408					NEXTW 
a408 c3 e7 9e			jp macro_next 
a40b				endm 
# End of macro NEXTW
a40b			.AT: 
a40b				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a40b 1f				db WORD_SYS_CORE+OPCODE_AT             
a40c 3d a4			dw .CAT            
a40e 02				db 1 + 1 
a40f .. 00			db "@",0              
a411				endm 
# End of macro CWHEAD
a411			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a411			 
a411					if DEBUG_FORTH_WORDS_KEY 
a411						DMARK "AT." 
a411 f5				push af  
a412 3a 26 a4			ld a, (.dmark)  
a415 32 6b ee			ld (debug_mark),a  
a418 3a 27 a4			ld a, (.dmark+1)  
a41b 32 6c ee			ld (debug_mark+1),a  
a41e 3a 28 a4			ld a, (.dmark+2)  
a421 32 6d ee			ld (debug_mark+2),a  
a424 18 03			jr .pastdmark  
a426 ..			.dmark: db "AT."  
a429 f1			.pastdmark: pop af  
a42a			endm  
# End of macro DMARK
a42a						CALLMONITOR 
a42a cd 6f ee			call debug_vector  
a42d				endm  
# End of macro CALLMONITOR
a42d					endif 
a42d			.getbyteat:	 
a42d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a42d cd 31 9d			call macro_dsp_valuehl 
a430				endm 
# End of macro FORTH_DSP_VALUEHL
a430					 
a430			;		push hl 
a430				 
a430					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a430 cd e9 9d			call macro_forth_dsp_pop 
a433				endm 
# End of macro FORTH_DSP_POP
a433			 
a433			;		pop hl 
a433			 
a433 7e					ld a, (hl) 
a434			 
a434 6f					ld l, a 
a435 26 00				ld h, 0 
a437 cd 3a 9b				call forth_push_numhl 
a43a			 
a43a					NEXTW 
a43a c3 e7 9e			jp macro_next 
a43d				endm 
# End of macro NEXTW
a43d			.CAT: 
a43d				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a43d 20				db WORD_SYS_CORE+OPCODE_CAT             
a43e 66 a4			dw .BANG            
a440 03				db 2 + 1 
a441 .. 00			db "C@",0              
a444				endm 
# End of macro CWHEAD
a444			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a444					if DEBUG_FORTH_WORDS_KEY 
a444						DMARK "CAA" 
a444 f5				push af  
a445 3a 59 a4			ld a, (.dmark)  
a448 32 6b ee			ld (debug_mark),a  
a44b 3a 5a a4			ld a, (.dmark+1)  
a44e 32 6c ee			ld (debug_mark+1),a  
a451 3a 5b a4			ld a, (.dmark+2)  
a454 32 6d ee			ld (debug_mark+2),a  
a457 18 03			jr .pastdmark  
a459 ..			.dmark: db "CAA"  
a45c f1			.pastdmark: pop af  
a45d			endm  
# End of macro DMARK
a45d						CALLMONITOR 
a45d cd 6f ee			call debug_vector  
a460				endm  
# End of macro CALLMONITOR
a460					endif 
a460 c3 2d a4				jp .getbyteat 
a463					NEXTW 
a463 c3 e7 9e			jp macro_next 
a466				endm 
# End of macro NEXTW
a466			.BANG: 
a466				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a466 21				db WORD_SYS_CORE+OPCODE_BANG             
a467 9c a4			dw .CBANG            
a469 02				db 1 + 1 
a46a .. 00			db "!",0              
a46c				endm 
# End of macro CWHEAD
a46c			; | ! ( x w -- ) Store x at address w      | DONE 
a46c					if DEBUG_FORTH_WORDS_KEY 
a46c						DMARK "BNG" 
a46c f5				push af  
a46d 3a 81 a4			ld a, (.dmark)  
a470 32 6b ee			ld (debug_mark),a  
a473 3a 82 a4			ld a, (.dmark+1)  
a476 32 6c ee			ld (debug_mark+1),a  
a479 3a 83 a4			ld a, (.dmark+2)  
a47c 32 6d ee			ld (debug_mark+2),a  
a47f 18 03			jr .pastdmark  
a481 ..			.dmark: db "BNG"  
a484 f1			.pastdmark: pop af  
a485			endm  
# End of macro DMARK
a485						CALLMONITOR 
a485 cd 6f ee			call debug_vector  
a488				endm  
# End of macro CALLMONITOR
a488					endif 
a488			 
a488			.storebyteat:		 
a488					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a488 cd 31 9d			call macro_dsp_valuehl 
a48b				endm 
# End of macro FORTH_DSP_VALUEHL
a48b					 
a48b e5					push hl 
a48c				 
a48c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a48c cd e9 9d			call macro_forth_dsp_pop 
a48f				endm 
# End of macro FORTH_DSP_POP
a48f			 
a48f					; get byte to poke 
a48f			 
a48f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a48f cd 31 9d			call macro_dsp_valuehl 
a492				endm 
# End of macro FORTH_DSP_VALUEHL
a492 e5					push hl 
a493			 
a493			 
a493					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a493 cd e9 9d			call macro_forth_dsp_pop 
a496				endm 
# End of macro FORTH_DSP_POP
a496			 
a496			 
a496 d1					pop de 
a497 e1					pop hl 
a498			 
a498 73					ld (hl),e 
a499			 
a499			 
a499					NEXTW 
a499 c3 e7 9e			jp macro_next 
a49c				endm 
# End of macro NEXTW
a49c			.CBANG: 
a49c				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a49c 22				db WORD_SYS_CORE+OPCODE_CBANG             
a49d c5 a4			dw .SCALL            
a49f 03				db 2 + 1 
a4a0 .. 00			db "C!",0              
a4a3				endm 
# End of macro CWHEAD
a4a3			; | C!  ( x w -- ) Store x at address w  | DONE 
a4a3					if DEBUG_FORTH_WORDS_KEY 
a4a3						DMARK "CBA" 
a4a3 f5				push af  
a4a4 3a b8 a4			ld a, (.dmark)  
a4a7 32 6b ee			ld (debug_mark),a  
a4aa 3a b9 a4			ld a, (.dmark+1)  
a4ad 32 6c ee			ld (debug_mark+1),a  
a4b0 3a ba a4			ld a, (.dmark+2)  
a4b3 32 6d ee			ld (debug_mark+2),a  
a4b6 18 03			jr .pastdmark  
a4b8 ..			.dmark: db "CBA"  
a4bb f1			.pastdmark: pop af  
a4bc			endm  
# End of macro DMARK
a4bc						CALLMONITOR 
a4bc cd 6f ee			call debug_vector  
a4bf				endm  
# End of macro CALLMONITOR
a4bf					endif 
a4bf c3 88 a4				jp .storebyteat 
a4c2					NEXTW 
a4c2 c3 e7 9e			jp macro_next 
a4c5				endm 
# End of macro NEXTW
a4c5			.SCALL: 
a4c5				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a4c5 23				db WORD_SYS_CORE+OPCODE_SCALL             
a4c6 f9 a4			dw .DEPTH            
a4c8 05				db 4 + 1 
a4c9 .. 00			db "CALL",0              
a4ce				endm 
# End of macro CWHEAD
a4ce			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a4ce					if DEBUG_FORTH_WORDS_KEY 
a4ce						DMARK "CLL" 
a4ce f5				push af  
a4cf 3a e3 a4			ld a, (.dmark)  
a4d2 32 6b ee			ld (debug_mark),a  
a4d5 3a e4 a4			ld a, (.dmark+1)  
a4d8 32 6c ee			ld (debug_mark+1),a  
a4db 3a e5 a4			ld a, (.dmark+2)  
a4de 32 6d ee			ld (debug_mark+2),a  
a4e1 18 03			jr .pastdmark  
a4e3 ..			.dmark: db "CLL"  
a4e6 f1			.pastdmark: pop af  
a4e7			endm  
# End of macro DMARK
a4e7						CALLMONITOR 
a4e7 cd 6f ee			call debug_vector  
a4ea				endm  
# End of macro CALLMONITOR
a4ea					endif 
a4ea			 
a4ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4ea cd 31 9d			call macro_dsp_valuehl 
a4ed				endm 
# End of macro FORTH_DSP_VALUEHL
a4ed			 
a4ed			;		push hl 
a4ed			 
a4ed					; destroy value TOS 
a4ed			 
a4ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4ed cd e9 9d			call macro_forth_dsp_pop 
a4f0				endm 
# End of macro FORTH_DSP_POP
a4f0			 
a4f0						 
a4f0			;		pop hl 
a4f0			 
a4f0					; how to do a call with hl???? save SP? 
a4f0 cd 8b 9e				call forth_call_hl 
a4f3			 
a4f3			 
a4f3					; TODO push value back onto stack for another op etc 
a4f3			 
a4f3 cd 3a 9b				call forth_push_numhl 
a4f6					NEXTW 
a4f6 c3 e7 9e			jp macro_next 
a4f9				endm 
# End of macro NEXTW
a4f9			.DEPTH: 
a4f9				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a4f9 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a4fa 36 a5			dw .OVER            
a4fc 06				db 5 + 1 
a4fd .. 00			db "DEPTH",0              
a503				endm 
# End of macro CWHEAD
a503			; | DEPTH ( -- u ) Push count of stack | DONE 
a503					; take current TOS and remove from base value div by two to get count 
a503					if DEBUG_FORTH_WORDS_KEY 
a503						DMARK "DEP" 
a503 f5				push af  
a504 3a 18 a5			ld a, (.dmark)  
a507 32 6b ee			ld (debug_mark),a  
a50a 3a 19 a5			ld a, (.dmark+1)  
a50d 32 6c ee			ld (debug_mark+1),a  
a510 3a 1a a5			ld a, (.dmark+2)  
a513 32 6d ee			ld (debug_mark+2),a  
a516 18 03			jr .pastdmark  
a518 ..			.dmark: db "DEP"  
a51b f1			.pastdmark: pop af  
a51c			endm  
# End of macro DMARK
a51c						CALLMONITOR 
a51c cd 6f ee			call debug_vector  
a51f				endm  
# End of macro CALLMONITOR
a51f					endif 
a51f			 
a51f			 
a51f 2a ee e9			ld hl, (cli_data_sp) 
a522 11 28 e8			ld de, cli_data_stack 
a525 ed 52			sbc hl,de 
a527				 
a527				; div by size of stack item 
a527			 
a527 5d				ld e,l 
a528 0e 03			ld c, 3 
a52a cd 6c 8c			call Div8 
a52d			 
a52d 6f				ld l,a 
a52e 26 00			ld h,0 
a530			 
a530				;srl h 
a530				;rr l 
a530			 
a530 cd 3a 9b				call forth_push_numhl 
a533					NEXTW 
a533 c3 e7 9e			jp macro_next 
a536				endm 
# End of macro NEXTW
a536			.OVER: 
a536				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a536 42				db WORD_SYS_CORE+46             
a537 7d a5			dw .PAUSE            
a539 05				db 4 + 1 
a53a .. 00			db "OVER",0              
a53f				endm 
# End of macro CWHEAD
a53f			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a53f					if DEBUG_FORTH_WORDS_KEY 
a53f						DMARK "OVR" 
a53f f5				push af  
a540 3a 54 a5			ld a, (.dmark)  
a543 32 6b ee			ld (debug_mark),a  
a546 3a 55 a5			ld a, (.dmark+1)  
a549 32 6c ee			ld (debug_mark+1),a  
a54c 3a 56 a5			ld a, (.dmark+2)  
a54f 32 6d ee			ld (debug_mark+2),a  
a552 18 03			jr .pastdmark  
a554 ..			.dmark: db "OVR"  
a557 f1			.pastdmark: pop af  
a558			endm  
# End of macro DMARK
a558						CALLMONITOR 
a558 cd 6f ee			call debug_vector  
a55b				endm  
# End of macro CALLMONITOR
a55b					endif 
a55b			 
a55b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a55b cd 31 9d			call macro_dsp_valuehl 
a55e				endm 
# End of macro FORTH_DSP_VALUEHL
a55e e5					push hl    ; n2 
a55f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a55f cd e9 9d			call macro_forth_dsp_pop 
a562				endm 
# End of macro FORTH_DSP_POP
a562			 
a562					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a562 cd 31 9d			call macro_dsp_valuehl 
a565				endm 
# End of macro FORTH_DSP_VALUEHL
a565 e5					push hl    ; n1 
a566					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a566 cd e9 9d			call macro_forth_dsp_pop 
a569				endm 
# End of macro FORTH_DSP_POP
a569			 
a569 d1					pop de     ; n1 
a56a e1					pop hl     ; n2 
a56b			 
a56b d5					push de 
a56c e5					push hl 
a56d d5					push de 
a56e			 
a56e					; push back  
a56e			 
a56e e1					pop hl 
a56f cd 3a 9b				call forth_push_numhl 
a572 e1					pop hl 
a573 cd 3a 9b				call forth_push_numhl 
a576 e1					pop hl 
a577 cd 3a 9b				call forth_push_numhl 
a57a					NEXTW 
a57a c3 e7 9e			jp macro_next 
a57d				endm 
# End of macro NEXTW
a57d			 
a57d			.PAUSE: 
a57d				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a57d 43				db WORD_SYS_CORE+47             
a57e b2 a5			dw .PAUSES            
a580 08				db 7 + 1 
a581 .. 00			db "PAUSEMS",0              
a589				endm 
# End of macro CWHEAD
a589			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a589					if DEBUG_FORTH_WORDS_KEY 
a589						DMARK "PMS" 
a589 f5				push af  
a58a 3a 9e a5			ld a, (.dmark)  
a58d 32 6b ee			ld (debug_mark),a  
a590 3a 9f a5			ld a, (.dmark+1)  
a593 32 6c ee			ld (debug_mark+1),a  
a596 3a a0 a5			ld a, (.dmark+2)  
a599 32 6d ee			ld (debug_mark+2),a  
a59c 18 03			jr .pastdmark  
a59e ..			.dmark: db "PMS"  
a5a1 f1			.pastdmark: pop af  
a5a2			endm  
# End of macro DMARK
a5a2						CALLMONITOR 
a5a2 cd 6f ee			call debug_vector  
a5a5				endm  
# End of macro CALLMONITOR
a5a5					endif 
a5a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5a5 cd 31 9d			call macro_dsp_valuehl 
a5a8				endm 
# End of macro FORTH_DSP_VALUEHL
a5a8			;		push hl    ; n2 
a5a8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5a8 cd e9 9d			call macro_forth_dsp_pop 
a5ab				endm 
# End of macro FORTH_DSP_POP
a5ab			;		pop hl 
a5ab			 
a5ab 7d					ld a, l 
a5ac cd d7 89				call aDelayInMS 
a5af				       NEXTW 
a5af c3 e7 9e			jp macro_next 
a5b2				endm 
# End of macro NEXTW
a5b2			.PAUSES:  
a5b2				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a5b2 44				db WORD_SYS_CORE+48             
a5b3 21 a6			dw .ROT            
a5b5 06				db 5 + 1 
a5b6 .. 00			db "PAUSE",0              
a5bc				endm 
# End of macro CWHEAD
a5bc			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a5bc					if DEBUG_FORTH_WORDS_KEY 
a5bc						DMARK "PAU" 
a5bc f5				push af  
a5bd 3a d1 a5			ld a, (.dmark)  
a5c0 32 6b ee			ld (debug_mark),a  
a5c3 3a d2 a5			ld a, (.dmark+1)  
a5c6 32 6c ee			ld (debug_mark+1),a  
a5c9 3a d3 a5			ld a, (.dmark+2)  
a5cc 32 6d ee			ld (debug_mark+2),a  
a5cf 18 03			jr .pastdmark  
a5d1 ..			.dmark: db "PAU"  
a5d4 f1			.pastdmark: pop af  
a5d5			endm  
# End of macro DMARK
a5d5						CALLMONITOR 
a5d5 cd 6f ee			call debug_vector  
a5d8				endm  
# End of macro CALLMONITOR
a5d8					endif 
a5d8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5d8 cd 31 9d			call macro_dsp_valuehl 
a5db				endm 
# End of macro FORTH_DSP_VALUEHL
a5db			;		push hl    ; n2 
a5db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5db cd e9 9d			call macro_forth_dsp_pop 
a5de				endm 
# End of macro FORTH_DSP_POP
a5de			;		pop hl 
a5de 45					ld b, l 
a5df					if DEBUG_FORTH_WORDS 
a5df						DMARK "PAU" 
a5df f5				push af  
a5e0 3a f4 a5			ld a, (.dmark)  
a5e3 32 6b ee			ld (debug_mark),a  
a5e6 3a f5 a5			ld a, (.dmark+1)  
a5e9 32 6c ee			ld (debug_mark+1),a  
a5ec 3a f6 a5			ld a, (.dmark+2)  
a5ef 32 6d ee			ld (debug_mark+2),a  
a5f2 18 03			jr .pastdmark  
a5f4 ..			.dmark: db "PAU"  
a5f7 f1			.pastdmark: pop af  
a5f8			endm  
# End of macro DMARK
a5f8						CALLMONITOR 
a5f8 cd 6f ee			call debug_vector  
a5fb				endm  
# End of macro CALLMONITOR
a5fb					endif 
a5fb c5			.pauses1:	push bc 
a5fc cd f2 89				call delay1s 
a5ff c1					pop bc 
a600					if DEBUG_FORTH_WORDS 
a600						DMARK "PA1" 
a600 f5				push af  
a601 3a 15 a6			ld a, (.dmark)  
a604 32 6b ee			ld (debug_mark),a  
a607 3a 16 a6			ld a, (.dmark+1)  
a60a 32 6c ee			ld (debug_mark+1),a  
a60d 3a 17 a6			ld a, (.dmark+2)  
a610 32 6d ee			ld (debug_mark+2),a  
a613 18 03			jr .pastdmark  
a615 ..			.dmark: db "PA1"  
a618 f1			.pastdmark: pop af  
a619			endm  
# End of macro DMARK
a619						CALLMONITOR 
a619 cd 6f ee			call debug_vector  
a61c				endm  
# End of macro CALLMONITOR
a61c					endif 
a61c 10 dd				djnz .pauses1 
a61e			 
a61e				       NEXTW 
a61e c3 e7 9e			jp macro_next 
a621				endm 
# End of macro NEXTW
a621			.ROT: 
a621				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a621 45				db WORD_SYS_CORE+49             
a622 6f a6			dw .UWORDS            
a624 04				db 3 + 1 
a625 .. 00			db "ROT",0              
a629				endm 
# End of macro CWHEAD
a629			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a629					if DEBUG_FORTH_WORDS_KEY 
a629						DMARK "ROT" 
a629 f5				push af  
a62a 3a 3e a6			ld a, (.dmark)  
a62d 32 6b ee			ld (debug_mark),a  
a630 3a 3f a6			ld a, (.dmark+1)  
a633 32 6c ee			ld (debug_mark+1),a  
a636 3a 40 a6			ld a, (.dmark+2)  
a639 32 6d ee			ld (debug_mark+2),a  
a63c 18 03			jr .pastdmark  
a63e ..			.dmark: db "ROT"  
a641 f1			.pastdmark: pop af  
a642			endm  
# End of macro DMARK
a642						CALLMONITOR 
a642 cd 6f ee			call debug_vector  
a645				endm  
# End of macro CALLMONITOR
a645					endif 
a645			 
a645					FORTH_DSP_VALUEHL 
a645 cd 31 9d			call macro_dsp_valuehl 
a648				endm 
# End of macro FORTH_DSP_VALUEHL
a648 e5					push hl    ; u3  
a649			 
a649					FORTH_DSP_POP 
a649 cd e9 9d			call macro_forth_dsp_pop 
a64c				endm 
# End of macro FORTH_DSP_POP
a64c			   
a64c					FORTH_DSP_VALUEHL 
a64c cd 31 9d			call macro_dsp_valuehl 
a64f				endm 
# End of macro FORTH_DSP_VALUEHL
a64f e5					push hl     ; u2 
a650			 
a650					FORTH_DSP_POP 
a650 cd e9 9d			call macro_forth_dsp_pop 
a653				endm 
# End of macro FORTH_DSP_POP
a653			 
a653					FORTH_DSP_VALUEHL 
a653 cd 31 9d			call macro_dsp_valuehl 
a656				endm 
# End of macro FORTH_DSP_VALUEHL
a656 e5					push hl     ; u1 
a657			 
a657					FORTH_DSP_POP 
a657 cd e9 9d			call macro_forth_dsp_pop 
a65a				endm 
# End of macro FORTH_DSP_POP
a65a			 
a65a c1					pop bc      ; u1 
a65b e1					pop hl      ; u2 
a65c d1					pop de      ; u3 
a65d			 
a65d			 
a65d c5					push bc 
a65e d5					push de 
a65f e5					push hl 
a660			 
a660			 
a660 e1					pop hl 
a661 cd 3a 9b				call forth_push_numhl 
a664			 
a664 e1					pop hl 
a665 cd 3a 9b				call forth_push_numhl 
a668			 
a668 e1					pop hl 
a669 cd 3a 9b				call forth_push_numhl 
a66c					 
a66c			 
a66c			 
a66c			 
a66c			 
a66c			 
a66c				       NEXTW 
a66c c3 e7 9e			jp macro_next 
a66f				endm 
# End of macro NEXTW
a66f			 
a66f			.UWORDS: 
a66f				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a66f 50				db WORD_SYS_CORE+60             
a670 31 a7			dw .BP            
a672 07				db 6 + 1 
a673 .. 00			db "UWORDS",0              
a67a				endm 
# End of macro CWHEAD
a67a			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a67a			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a67a			; | | Following the count are the individual words. 
a67a			; | | 
a67a			; | | e.g. UWORDS 
a67a			; | | BOX DIRLIST 2 
a67a			; | |  
a67a			; | | Can be used to save the words to storage via: 
a67a			; | | UWORDS $01 DO $01 APPEND LOOP 
a67a				if DEBUG_FORTH_WORDS_KEY 
a67a					DMARK "UWR" 
a67a f5				push af  
a67b 3a 8f a6			ld a, (.dmark)  
a67e 32 6b ee			ld (debug_mark),a  
a681 3a 90 a6			ld a, (.dmark+1)  
a684 32 6c ee			ld (debug_mark+1),a  
a687 3a 91 a6			ld a, (.dmark+2)  
a68a 32 6d ee			ld (debug_mark+2),a  
a68d 18 03			jr .pastdmark  
a68f ..			.dmark: db "UWR"  
a692 f1			.pastdmark: pop af  
a693			endm  
# End of macro DMARK
a693					CALLMONITOR 
a693 cd 6f ee			call debug_vector  
a696				endm  
# End of macro CALLMONITOR
a696				endif 
a696 21 2c e4				ld hl, baseram 
a699					;ld hl, baseusermem 
a699 01 00 00				ld bc, 0    ; start a counter 
a69c			 
a69c				; skip dict stub 
a69c			 
a69c cd 38 a0				call forth_tok_next 
a69f			 
a69f			 
a69f			; while we have words to look for 
a69f			 
a69f 7e			.douscan:	ld a, (hl)      
a6a0				if DEBUG_FORTH_WORDS 
a6a0					DMARK "UWs" 
a6a0 f5				push af  
a6a1 3a b5 a6			ld a, (.dmark)  
a6a4 32 6b ee			ld (debug_mark),a  
a6a7 3a b6 a6			ld a, (.dmark+1)  
a6aa 32 6c ee			ld (debug_mark+1),a  
a6ad 3a b7 a6			ld a, (.dmark+2)  
a6b0 32 6d ee			ld (debug_mark+2),a  
a6b3 18 03			jr .pastdmark  
a6b5 ..			.dmark: db "UWs"  
a6b8 f1			.pastdmark: pop af  
a6b9			endm  
# End of macro DMARK
a6b9					CALLMONITOR 
a6b9 cd 6f ee			call debug_vector  
a6bc				endm  
# End of macro CALLMONITOR
a6bc				endif 
a6bc fe 00				cp WORD_SYS_END 
a6be 28 4d				jr z, .udone 
a6c0 fe 01				cp WORD_SYS_UWORD 
a6c2 20 44				jr nz, .nuword 
a6c4			 
a6c4				if DEBUG_FORTH_WORDS 
a6c4					DMARK "UWu" 
a6c4 f5				push af  
a6c5 3a d9 a6			ld a, (.dmark)  
a6c8 32 6b ee			ld (debug_mark),a  
a6cb 3a da a6			ld a, (.dmark+1)  
a6ce 32 6c ee			ld (debug_mark+1),a  
a6d1 3a db a6			ld a, (.dmark+2)  
a6d4 32 6d ee			ld (debug_mark+2),a  
a6d7 18 03			jr .pastdmark  
a6d9 ..			.dmark: db "UWu"  
a6dc f1			.pastdmark: pop af  
a6dd			endm  
# End of macro DMARK
a6dd					CALLMONITOR 
a6dd cd 6f ee			call debug_vector  
a6e0				endm  
# End of macro CALLMONITOR
a6e0				endif 
a6e0					; we have a uword so push its name to the stack 
a6e0			 
a6e0 e5				   	push hl  ; save so we can move to next dict block 
a6e1			 
a6e1					; skip opcode 
a6e1 23					inc hl  
a6e2					; skip next ptr 
a6e2 23					inc hl  
a6e3 23					inc hl 
a6e4					; skip len 
a6e4 23					inc hl 
a6e5				if DEBUG_FORTH_WORDS 
a6e5					DMARK "UWt" 
a6e5 f5				push af  
a6e6 3a fa a6			ld a, (.dmark)  
a6e9 32 6b ee			ld (debug_mark),a  
a6ec 3a fb a6			ld a, (.dmark+1)  
a6ef 32 6c ee			ld (debug_mark+1),a  
a6f2 3a fc a6			ld a, (.dmark+2)  
a6f5 32 6d ee			ld (debug_mark+2),a  
a6f8 18 03			jr .pastdmark  
a6fa ..			.dmark: db "UWt"  
a6fd f1			.pastdmark: pop af  
a6fe			endm  
# End of macro DMARK
a6fe					CALLMONITOR 
a6fe cd 6f ee			call debug_vector  
a701				endm  
# End of macro CALLMONITOR
a701				endif 
a701 03					inc bc 
a702			 
a702 c5					push bc 
a703 cd a8 9b				call forth_push_str 
a706 c1					pop bc 
a707			 
a707 e1					pop hl 	 
a708			 
a708 cd 38 a0		.nuword:	call forth_tok_next 
a70b 18 92				jr .douscan  
a70d			 
a70d			.udone:		 ; push count of uwords found 
a70d c5					push bc 
a70e e1					pop hl 
a70f			 
a70f				if DEBUG_FORTH_WORDS 
a70f					DMARK "UWc" 
a70f f5				push af  
a710 3a 24 a7			ld a, (.dmark)  
a713 32 6b ee			ld (debug_mark),a  
a716 3a 25 a7			ld a, (.dmark+1)  
a719 32 6c ee			ld (debug_mark+1),a  
a71c 3a 26 a7			ld a, (.dmark+2)  
a71f 32 6d ee			ld (debug_mark+2),a  
a722 18 03			jr .pastdmark  
a724 ..			.dmark: db "UWc"  
a727 f1			.pastdmark: pop af  
a728			endm  
# End of macro DMARK
a728					CALLMONITOR 
a728 cd 6f ee			call debug_vector  
a72b				endm  
# End of macro CALLMONITOR
a72b				endif 
a72b cd 3a 9b				call forth_push_numhl 
a72e			 
a72e			 
a72e				       NEXTW 
a72e c3 e7 9e			jp macro_next 
a731				endm 
# End of macro NEXTW
a731			 
a731			.BP: 
a731				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a731 54				db WORD_SYS_CORE+64             
a732 6b a7			dw .MONITOR            
a734 03				db 2 + 1 
a735 .. 00			db "BP",0              
a738				endm 
# End of macro CWHEAD
a738			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a738			; | | $00 Will enable the break points within specific code paths 
a738			; | | $01 Will disable break points 
a738			; | |  
a738			; | | By default break points are off. Either the above can be used to enable them 
a738			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a738			; | | and on release of the pressed key a message will be disaplayed to notify 
a738			; | | that break points are enabled. Pressing any key will then continue boot process. 
a738					; get byte count 
a738					if DEBUG_FORTH_WORDS_KEY 
a738						DMARK "BP." 
a738 f5				push af  
a739 3a 4d a7			ld a, (.dmark)  
a73c 32 6b ee			ld (debug_mark),a  
a73f 3a 4e a7			ld a, (.dmark+1)  
a742 32 6c ee			ld (debug_mark+1),a  
a745 3a 4f a7			ld a, (.dmark+2)  
a748 32 6d ee			ld (debug_mark+2),a  
a74b 18 03			jr .pastdmark  
a74d ..			.dmark: db "BP."  
a750 f1			.pastdmark: pop af  
a751			endm  
# End of macro DMARK
a751						CALLMONITOR 
a751 cd 6f ee			call debug_vector  
a754				endm  
# End of macro CALLMONITOR
a754					endif 
a754			 
a754					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a754 cd 31 9d			call macro_dsp_valuehl 
a757				endm 
# End of macro FORTH_DSP_VALUEHL
a757			 
a757			;		push hl 
a757			 
a757					; destroy value TOS 
a757			 
a757					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a757 cd e9 9d			call macro_forth_dsp_pop 
a75a				endm 
# End of macro FORTH_DSP_POP
a75a			 
a75a			;		pop hl 
a75a			 
a75a 3e 00				ld a,0 
a75c bd					cp l 
a75d 28 06				jr z, .bpset 
a75f			;		ld a, '*' 
a75f cd de 94				call bp_off 
a762					NEXTW 
a762 c3 e7 9e			jp macro_next 
a765				endm 
# End of macro NEXTW
a765			 
a765			.bpset:	 
a765					;	ld (os_view_disable), a 
a765 cd d2 94				call bp_on 
a768			 
a768			 
a768					NEXTW 
a768 c3 e7 9e			jp macro_next 
a76b				endm 
# End of macro NEXTW
a76b			 
a76b			 
a76b			.MONITOR: 
a76b				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a76b 55				db WORD_SYS_CORE+65             
a76c 9c a7			dw .MALLOC            
a76e 08				db 7 + 1 
a76f .. 00			db "MONITOR",0              
a777				endm 
# End of macro CWHEAD
a777			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a777			; | | At start the current various registers will be displayed with contents. 
a777			; | | Top right corner will show the most recent debug marker seen. 
a777			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a777			; | | and the return stack pointer (RSP). 
a777			; | | Pressing: 
a777			; | |    1 - Initial screen 
a777			; | |    2 - Display a data dump of HL 
a777			; | |    3 - Display a data dump of DE 
a777			; | |    4 - Display a data dump of BC 
a777			; | |    5 - Display a data dump of HL 
a777			; | |    6 - Display a data dump of DSP 
a777			; | |    7 - Display a data dump of RSP 
a777			; | |    8 - Display a data dump of what is at DSP 
a777			; | |    9 - Display a data dump of what is at RSP 
a777			; | |    0 - Exit monitor and continue running. This will also enable break points 
a777			; | |    * - Disable break points 
a777			; | |    # - Enter traditional monitor mode 
a777			; | | 
a777			; | | Monitor Mode 
a777			; | | ------------ 
a777			; | | A prompt of '>' will be shown for various commands: 
a777			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a777			; | |    C - Continue display a data dump from the last set address 
a777			; | |    M xxxx - Set start of memory edit at address xx 
a777			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a777			; | |    Q - Return to previous 
a777					if DEBUG_FORTH_WORDS_KEY 
a777						DMARK "MON" 
a777 f5				push af  
a778 3a 8c a7			ld a, (.dmark)  
a77b 32 6b ee			ld (debug_mark),a  
a77e 3a 8d a7			ld a, (.dmark+1)  
a781 32 6c ee			ld (debug_mark+1),a  
a784 3a 8e a7			ld a, (.dmark+2)  
a787 32 6d ee			ld (debug_mark+2),a  
a78a 18 03			jr .pastdmark  
a78c ..			.dmark: db "MON"  
a78f f1			.pastdmark: pop af  
a790			endm  
# End of macro DMARK
a790						CALLMONITOR 
a790 cd 6f ee			call debug_vector  
a793				endm  
# End of macro CALLMONITOR
a793					endif 
a793			;		ld a, 0 
a793			;		ld (os_view_disable), a 
a793 cd d2 94				call bp_on 
a796			 
a796					CALLMONITOR 
a796 cd 6f ee			call debug_vector  
a799				endm  
# End of macro CALLMONITOR
a799			 
a799			;	call monitor 
a799			 
a799					NEXTW 
a799 c3 e7 9e			jp macro_next 
a79c				endm 
# End of macro NEXTW
a79c			 
a79c			 
a79c			.MALLOC: 
a79c				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a79c 56				db WORD_SYS_CORE+66             
a79d c5 a7			dw .MALLOC2            
a79f 06				db 5 + 1 
a7a0 .. 00			db "ALLOT",0              
a7a6				endm 
# End of macro CWHEAD
a7a6			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7a6					if DEBUG_FORTH_WORDS_KEY 
a7a6						DMARK "ALL" 
a7a6 f5				push af  
a7a7 3a bb a7			ld a, (.dmark)  
a7aa 32 6b ee			ld (debug_mark),a  
a7ad 3a bc a7			ld a, (.dmark+1)  
a7b0 32 6c ee			ld (debug_mark+1),a  
a7b3 3a bd a7			ld a, (.dmark+2)  
a7b6 32 6d ee			ld (debug_mark+2),a  
a7b9 18 03			jr .pastdmark  
a7bb ..			.dmark: db "ALL"  
a7be f1			.pastdmark: pop af  
a7bf			endm  
# End of macro DMARK
a7bf						CALLMONITOR 
a7bf cd 6f ee			call debug_vector  
a7c2				endm  
# End of macro CALLMONITOR
a7c2					endif 
a7c2 c3 ec a7				jp .mallocc 
a7c5			.MALLOC2: 
a7c5				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a7c5 56				db WORD_SYS_CORE+66             
a7c6 03 a8			dw .FREE            
a7c8 07				db 6 + 1 
a7c9 .. 00			db "MALLOC",0              
a7d0				endm 
# End of macro CWHEAD
a7d0			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a7d0					; get byte count 
a7d0					if DEBUG_FORTH_WORDS_KEY 
a7d0						DMARK "MAL" 
a7d0 f5				push af  
a7d1 3a e5 a7			ld a, (.dmark)  
a7d4 32 6b ee			ld (debug_mark),a  
a7d7 3a e6 a7			ld a, (.dmark+1)  
a7da 32 6c ee			ld (debug_mark+1),a  
a7dd 3a e7 a7			ld a, (.dmark+2)  
a7e0 32 6d ee			ld (debug_mark+2),a  
a7e3 18 03			jr .pastdmark  
a7e5 ..			.dmark: db "MAL"  
a7e8 f1			.pastdmark: pop af  
a7e9			endm  
# End of macro DMARK
a7e9						CALLMONITOR 
a7e9 cd 6f ee			call debug_vector  
a7ec				endm  
# End of macro CALLMONITOR
a7ec					endif 
a7ec			.mallocc: 
a7ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7ec cd 31 9d			call macro_dsp_valuehl 
a7ef				endm 
# End of macro FORTH_DSP_VALUEHL
a7ef			 
a7ef			;		push hl 
a7ef			 
a7ef					; destroy value TOS 
a7ef			 
a7ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a7ef cd e9 9d			call macro_forth_dsp_pop 
a7f2				endm 
# End of macro FORTH_DSP_POP
a7f2			 
a7f2			;		pop hl 
a7f2 cd a3 91				call malloc 
a7f5				if DEBUG_FORTH_MALLOC_GUARD 
a7f5 f5					push af 
a7f6 cd 05 8d				call ishlzero 
a7f9			;		ld a, l 
a7f9			;		add h 
a7f9			;		cp 0 
a7f9 f1					pop af 
a7fa					 
a7fa cc 26 cc				call z,malloc_error 
a7fd				endif 
a7fd			 
a7fd cd 3a 9b				call forth_push_numhl 
a800					NEXTW 
a800 c3 e7 9e			jp macro_next 
a803				endm 
# End of macro NEXTW
a803			 
a803			.FREE: 
a803				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a803 57				db WORD_SYS_CORE+67             
a804 34 a8			dw .LIST            
a806 05				db 4 + 1 
a807 .. 00			db "FREE",0              
a80c				endm 
# End of macro CWHEAD
a80c			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a80c					if DEBUG_FORTH_WORDS_KEY 
a80c						DMARK "FRE" 
a80c f5				push af  
a80d 3a 21 a8			ld a, (.dmark)  
a810 32 6b ee			ld (debug_mark),a  
a813 3a 22 a8			ld a, (.dmark+1)  
a816 32 6c ee			ld (debug_mark+1),a  
a819 3a 23 a8			ld a, (.dmark+2)  
a81c 32 6d ee			ld (debug_mark+2),a  
a81f 18 03			jr .pastdmark  
a821 ..			.dmark: db "FRE"  
a824 f1			.pastdmark: pop af  
a825			endm  
# End of macro DMARK
a825						CALLMONITOR 
a825 cd 6f ee			call debug_vector  
a828				endm  
# End of macro CALLMONITOR
a828					endif 
a828					; get address 
a828			 
a828					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a828 cd 31 9d			call macro_dsp_valuehl 
a82b				endm 
# End of macro FORTH_DSP_VALUEHL
a82b			 
a82b			;		push hl 
a82b			 
a82b					; destroy value TOS 
a82b			 
a82b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a82b cd e9 9d			call macro_forth_dsp_pop 
a82e				endm 
# End of macro FORTH_DSP_POP
a82e			 
a82e			;		pop hl 
a82e			if FORTH_ENABLE_MALLOCFREE 
a82e cd 6d 92				call free 
a831			endif 
a831					NEXTW 
a831 c3 e7 9e			jp macro_next 
a834				endm 
# End of macro NEXTW
a834			.LIST: 
a834				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a834 5c				db WORD_SYS_CORE+72             
a835 22 aa			dw .FORGET            
a837 05				db 4 + 1 
a838 .. 00			db "LIST",0              
a83d				endm 
# End of macro CWHEAD
a83d			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a83d			; | | The quoted word must be in upper case. 
a83d				if DEBUG_FORTH_WORDS_KEY 
a83d					DMARK "LST" 
a83d f5				push af  
a83e 3a 52 a8			ld a, (.dmark)  
a841 32 6b ee			ld (debug_mark),a  
a844 3a 53 a8			ld a, (.dmark+1)  
a847 32 6c ee			ld (debug_mark+1),a  
a84a 3a 54 a8			ld a, (.dmark+2)  
a84d 32 6d ee			ld (debug_mark+2),a  
a850 18 03			jr .pastdmark  
a852 ..			.dmark: db "LST"  
a855 f1			.pastdmark: pop af  
a856			endm  
# End of macro DMARK
a856					CALLMONITOR 
a856 cd 6f ee			call debug_vector  
a859				endm  
# End of macro CALLMONITOR
a859				endif 
a859			 
a859					FORTH_DSP_VALUEHL 
a859 cd 31 9d			call macro_dsp_valuehl 
a85c				endm 
# End of macro FORTH_DSP_VALUEHL
a85c			 
a85c e5					push hl 
a85d					FORTH_DSP_POP 
a85d cd e9 9d			call macro_forth_dsp_pop 
a860				endm 
# End of macro FORTH_DSP_POP
a860 c1					pop bc 
a861			 
a861			; Start format of scratch string 
a861			 
a861 21 c1 e2				ld hl, scratch 
a864			 
a864 3e 3a				ld a, ':' 
a866 77					ld (hl),a 
a867 23					inc hl 
a868 3e 20				ld a, ' ' 
a86a 77					ld (hl), a 
a86b			 
a86b					; Get ptr to the word we need to look up 
a86b			 
a86b			;		FORTH_DSP_VALUEHL 
a86b					;v5 FORTH_DSP_VALUE 
a86b				; TODO type check 
a86b			;		inc hl    ; Skip type check  
a86b			;		push hl 
a86b			;		ex de, hl    ; put into DE 
a86b			 
a86b			 
a86b 21 2c e4				ld hl, baseram 
a86e					;ld hl, baseusermem 
a86e			 
a86e e5			push hl   ; sacreifical push 
a86f			 
a86f			.ldouscanm: 
a86f e1				pop hl 
a870			.ldouscan: 
a870				if DEBUG_FORTH_WORDS 
a870					DMARK "LSs" 
a870 f5				push af  
a871 3a 85 a8			ld a, (.dmark)  
a874 32 6b ee			ld (debug_mark),a  
a877 3a 86 a8			ld a, (.dmark+1)  
a87a 32 6c ee			ld (debug_mark+1),a  
a87d 3a 87 a8			ld a, (.dmark+2)  
a880 32 6d ee			ld (debug_mark+2),a  
a883 18 03			jr .pastdmark  
a885 ..			.dmark: db "LSs"  
a888 f1			.pastdmark: pop af  
a889			endm  
# End of macro DMARK
a889					CALLMONITOR 
a889 cd 6f ee			call debug_vector  
a88c				endm  
# End of macro CALLMONITOR
a88c				endif 
a88c				; skip dict stub 
a88c cd 38 a0				call forth_tok_next 
a88f			 
a88f			 
a88f			; while we have words to look for 
a88f			 
a88f 7e				ld a, (hl)      
a890				if DEBUG_FORTH_WORDS 
a890					DMARK "LSk" 
a890 f5				push af  
a891 3a a5 a8			ld a, (.dmark)  
a894 32 6b ee			ld (debug_mark),a  
a897 3a a6 a8			ld a, (.dmark+1)  
a89a 32 6c ee			ld (debug_mark+1),a  
a89d 3a a7 a8			ld a, (.dmark+2)  
a8a0 32 6d ee			ld (debug_mark+2),a  
a8a3 18 03			jr .pastdmark  
a8a5 ..			.dmark: db "LSk"  
a8a8 f1			.pastdmark: pop af  
a8a9			endm  
# End of macro DMARK
a8a9					CALLMONITOR 
a8a9 cd 6f ee			call debug_vector  
a8ac				endm  
# End of macro CALLMONITOR
a8ac				endif 
a8ac					;cp WORD_SYS_END 
a8ac					;jp z, .lunotfound 
a8ac			 
a8ac					; if we hit non uwords then gone too far 
a8ac fe 01				cp WORD_SYS_UWORD 
a8ae c2 de a9				jp nz, .lunotfound 
a8b1			 
a8b1				if DEBUG_FORTH_WORDS 
a8b1					DMARK "LSu" 
a8b1 f5				push af  
a8b2 3a c6 a8			ld a, (.dmark)  
a8b5 32 6b ee			ld (debug_mark),a  
a8b8 3a c7 a8			ld a, (.dmark+1)  
a8bb 32 6c ee			ld (debug_mark+1),a  
a8be 3a c8 a8			ld a, (.dmark+2)  
a8c1 32 6d ee			ld (debug_mark+2),a  
a8c4 18 03			jr .pastdmark  
a8c6 ..			.dmark: db "LSu"  
a8c9 f1			.pastdmark: pop af  
a8ca			endm  
# End of macro DMARK
a8ca					CALLMONITOR 
a8ca cd 6f ee			call debug_vector  
a8cd				endm  
# End of macro CALLMONITOR
a8cd				endif 
a8cd			 
a8cd					; found a uword but is it the one we want... 
a8cd			 
a8cd c5					push bc     ; uword to find is on bc 
a8ce d1					pop de 
a8cf			 
a8cf e5					push hl  ; to save the ptr 
a8d0			 
a8d0					; skip opcode 
a8d0 23					inc hl  
a8d1					; skip next ptr 
a8d1 23					inc hl  
a8d2 23					inc hl 
a8d3					; skip len 
a8d3 23					inc hl 
a8d4			 
a8d4				if DEBUG_FORTH_WORDS 
a8d4					DMARK "LSc" 
a8d4 f5				push af  
a8d5 3a e9 a8			ld a, (.dmark)  
a8d8 32 6b ee			ld (debug_mark),a  
a8db 3a ea a8			ld a, (.dmark+1)  
a8de 32 6c ee			ld (debug_mark+1),a  
a8e1 3a eb a8			ld a, (.dmark+2)  
a8e4 32 6d ee			ld (debug_mark+2),a  
a8e7 18 03			jr .pastdmark  
a8e9 ..			.dmark: db "LSc"  
a8ec f1			.pastdmark: pop af  
a8ed			endm  
# End of macro DMARK
a8ed					CALLMONITOR 
a8ed cd 6f ee			call debug_vector  
a8f0				endm  
# End of macro CALLMONITOR
a8f0				endif 
a8f0 cd 72 91				call strcmp 
a8f3 c2 6f a8				jp nz, .ldouscanm 
a8f6				 
a8f6			 
a8f6			 
a8f6					; we have a uword so push its name to the stack 
a8f6			 
a8f6			;	   	push hl  ; save so we can move to next dict block 
a8f6 e1			pop hl 
a8f7			 
a8f7				if DEBUG_FORTH_WORDS 
a8f7					DMARK "LSm" 
a8f7 f5				push af  
a8f8 3a 0c a9			ld a, (.dmark)  
a8fb 32 6b ee			ld (debug_mark),a  
a8fe 3a 0d a9			ld a, (.dmark+1)  
a901 32 6c ee			ld (debug_mark+1),a  
a904 3a 0e a9			ld a, (.dmark+2)  
a907 32 6d ee			ld (debug_mark+2),a  
a90a 18 03			jr .pastdmark  
a90c ..			.dmark: db "LSm"  
a90f f1			.pastdmark: pop af  
a910			endm  
# End of macro DMARK
a910					CALLMONITOR 
a910 cd 6f ee			call debug_vector  
a913				endm  
# End of macro CALLMONITOR
a913				endif 
a913			 
a913					; skip opcode 
a913 23					inc hl  
a914					; skip next ptr 
a914 23					inc hl  
a915 23					inc hl 
a916					; skip len 
a916 7e					ld a, (hl)   ; save length to add 
a917				if DEBUG_FORTH_WORDS 
a917					DMARK "LS2" 
a917 f5				push af  
a918 3a 2c a9			ld a, (.dmark)  
a91b 32 6b ee			ld (debug_mark),a  
a91e 3a 2d a9			ld a, (.dmark+1)  
a921 32 6c ee			ld (debug_mark+1),a  
a924 3a 2e a9			ld a, (.dmark+2)  
a927 32 6d ee			ld (debug_mark+2),a  
a92a 18 03			jr .pastdmark  
a92c ..			.dmark: db "LS2"  
a92f f1			.pastdmark: pop af  
a930			endm  
# End of macro DMARK
a930					CALLMONITOR 
a930 cd 6f ee			call debug_vector  
a933				endm  
# End of macro CALLMONITOR
a933				endif 
a933			 
a933					; save this location 
a933				 
a933 e5					push hl 
a934			 
a934 23					inc hl 
a935 11 c3 e2				ld de, scratch+2 
a938 4f					ld c, a 
a939 06 00				ld b, 0 
a93b			 
a93b				if DEBUG_FORTH_WORDS 
a93b					DMARK "LSn" 
a93b f5				push af  
a93c 3a 50 a9			ld a, (.dmark)  
a93f 32 6b ee			ld (debug_mark),a  
a942 3a 51 a9			ld a, (.dmark+1)  
a945 32 6c ee			ld (debug_mark+1),a  
a948 3a 52 a9			ld a, (.dmark+2)  
a94b 32 6d ee			ld (debug_mark+2),a  
a94e 18 03			jr .pastdmark  
a950 ..			.dmark: db "LSn"  
a953 f1			.pastdmark: pop af  
a954			endm  
# End of macro DMARK
a954					CALLMONITOR 
a954 cd 6f ee			call debug_vector  
a957				endm  
# End of macro CALLMONITOR
a957				endif 
a957			 
a957					; copy uword name to scratch 
a957			 
a957 ed b0				ldir 
a959			 
a959 1b					dec de 
a95a 3e 20				ld a, ' '    ; change null to space 
a95c 12					ld (de), a 
a95d			 
a95d 13					inc de 
a95e			 
a95e d5					push de 
a95f c1					pop bc     ; move scratch pointer to end of word name and save it 
a960			 
a960 e1					pop hl 
a961 7e					ld a, (hl) 
a962					;inc hl 
a962					; skip word string 
a962 cd dc 8c				call addatohl 
a965			 
a965 23					inc hl 
a966			 
a966				if DEBUG_FORTH_WORDS 
a966					DMARK "LS3" 
a966 f5				push af  
a967 3a 7b a9			ld a, (.dmark)  
a96a 32 6b ee			ld (debug_mark),a  
a96d 3a 7c a9			ld a, (.dmark+1)  
a970 32 6c ee			ld (debug_mark+1),a  
a973 3a 7d a9			ld a, (.dmark+2)  
a976 32 6d ee			ld (debug_mark+2),a  
a979 18 03			jr .pastdmark  
a97b ..			.dmark: db "LS3"  
a97e f1			.pastdmark: pop af  
a97f			endm  
# End of macro DMARK
a97f					CALLMONITOR 
a97f cd 6f ee			call debug_vector  
a982				endm  
# End of macro CALLMONITOR
a982				endif 
a982					; should now be at the start of the machine code to setup the eval of the uword 
a982					; now locate the ptr to the string defintion 
a982			 
a982					; skip ld hl, 
a982					; then load the ptr 
a982			; TODO use get from hl ptr 
a982 23					inc hl 
a983 5e					ld e, (hl) 
a984 23					inc hl 
a985 56					ld d, (hl) 
a986 eb					ex de, hl 
a987			 
a987			 
a987				if DEBUG_FORTH_WORDS 
a987					DMARK "LSt" 
a987 f5				push af  
a988 3a 9c a9			ld a, (.dmark)  
a98b 32 6b ee			ld (debug_mark),a  
a98e 3a 9d a9			ld a, (.dmark+1)  
a991 32 6c ee			ld (debug_mark+1),a  
a994 3a 9e a9			ld a, (.dmark+2)  
a997 32 6d ee			ld (debug_mark+2),a  
a99a 18 03			jr .pastdmark  
a99c ..			.dmark: db "LSt"  
a99f f1			.pastdmark: pop af  
a9a0			endm  
# End of macro DMARK
a9a0					CALLMONITOR 
a9a0 cd 6f ee			call debug_vector  
a9a3				endm  
# End of macro CALLMONITOR
a9a3				endif 
a9a3			 
a9a3			; cant push right now due to tokenised strings  
a9a3			 
a9a3			; get the destination of where to copy this definition to. 
a9a3			 
a9a3 c5					push bc 
a9a4 d1					pop de 
a9a5			 
a9a5 7e			.listl:         ld a,(hl) 
a9a6 fe 00				cp 0 
a9a8 28 09				jr z, .lreplsp     ; replace zero with space 
a9aa					;cp FORTH_END_BUFFER 
a9aa fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a9ac 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a9ae				 
a9ae					; just copy this char as is then 
a9ae			 
a9ae 12					ld (de), a 
a9af			 
a9af 23			.listnxt:	inc hl 
a9b0 13					inc de 
a9b1 18 f2				jr .listl 
a9b3			 
a9b3 3e 20		.lreplsp:	ld a,' ' 
a9b5 12					ld (de), a 
a9b6 18 f7				jr .listnxt 
a9b8			 
a9b8			; close up uword def 
a9b8			 
a9b8			.listdone: 
a9b8 12					ld (de), a 
a9b9 13					inc de 
a9ba 3e 00				ld a, 0 
a9bc 12					ld (de), a 
a9bd			 
a9bd			; now have def so clean up and push to stack 
a9bd			 
a9bd 21 c1 e2				ld hl, scratch 
a9c0				if DEBUG_FORTH_WORDS 
a9c0					DMARK "Ltp" 
a9c0 f5				push af  
a9c1 3a d5 a9			ld a, (.dmark)  
a9c4 32 6b ee			ld (debug_mark),a  
a9c7 3a d6 a9			ld a, (.dmark+1)  
a9ca 32 6c ee			ld (debug_mark+1),a  
a9cd 3a d7 a9			ld a, (.dmark+2)  
a9d0 32 6d ee			ld (debug_mark+2),a  
a9d3 18 03			jr .pastdmark  
a9d5 ..			.dmark: db "Ltp"  
a9d8 f1			.pastdmark: pop af  
a9d9			endm  
# End of macro DMARK
a9d9					CALLMONITOR 
a9d9 cd 6f ee			call debug_vector  
a9dc				endm  
# End of macro CALLMONITOR
a9dc				endif 
a9dc			 
a9dc 18 1f			jr .listpush 
a9de			 
a9de			;.lnuword:	pop hl 
a9de			;		call forth_tok_next 
a9de			;		jp .ldouscan  
a9de			 
a9de			.lunotfound:		  
a9de			 
a9de				if DEBUG_FORTH_WORDS 
a9de					DMARK "LSn" 
a9de f5				push af  
a9df 3a f3 a9			ld a, (.dmark)  
a9e2 32 6b ee			ld (debug_mark),a  
a9e5 3a f4 a9			ld a, (.dmark+1)  
a9e8 32 6c ee			ld (debug_mark+1),a  
a9eb 3a f5 a9			ld a, (.dmark+2)  
a9ee 32 6d ee			ld (debug_mark+2),a  
a9f1 18 03			jr .pastdmark  
a9f3 ..			.dmark: db "LSn"  
a9f6 f1			.pastdmark: pop af  
a9f7			endm  
# End of macro DMARK
a9f7					CALLMONITOR 
a9f7 cd 6f ee			call debug_vector  
a9fa				endm  
# End of macro CALLMONITOR
a9fa				endif 
a9fa			 
a9fa					 
a9fa			;		FORTH_DSP_POP 
a9fa			;		ld hl, .luno 
a9fa			 
a9fa					NEXTW			 
a9fa c3 e7 9e			jp macro_next 
a9fd				endm 
# End of macro NEXTW
a9fd			 
a9fd			.listpush: 
a9fd				if DEBUG_FORTH_WORDS 
a9fd					DMARK "LS>" 
a9fd f5				push af  
a9fe 3a 12 aa			ld a, (.dmark)  
aa01 32 6b ee			ld (debug_mark),a  
aa04 3a 13 aa			ld a, (.dmark+1)  
aa07 32 6c ee			ld (debug_mark+1),a  
aa0a 3a 14 aa			ld a, (.dmark+2)  
aa0d 32 6d ee			ld (debug_mark+2),a  
aa10 18 03			jr .pastdmark  
aa12 ..			.dmark: db "LS>"  
aa15 f1			.pastdmark: pop af  
aa16			endm  
# End of macro DMARK
aa16					CALLMONITOR 
aa16 cd 6f ee			call debug_vector  
aa19				endm  
# End of macro CALLMONITOR
aa19				endif 
aa19 cd a8 9b				call forth_push_str 
aa1c			 
aa1c			 
aa1c			 
aa1c					NEXTW 
aa1c c3 e7 9e			jp macro_next 
aa1f				endm 
# End of macro NEXTW
aa1f			 
aa1f			;.luno:    db "Word not found",0 
aa1f			 
aa1f			 
aa1f			 
aa1f			 
aa1f			 
aa1f			;		push hl   ; save pointer to start of uword def string 
aa1f			; 
aa1f			;; look for FORTH_EOL_LINE 
aa1f			;		ld a, FORTH_END_BUFFER 
aa1f			;		call strlent 
aa1f			; 
aa1f			;		inc hl		 ; space for coln def 
aa1f			;		inc hl 
aa1f			;		inc hl          ; space for terms 
aa1f			;		inc hl 
aa1f			; 
aa1f			;		ld a, 20   ; TODO get actual length 
aa1f			;		call addatohl    ; include a random amount of room for the uword name 
aa1f			; 
aa1f			;		 
aa1f			;	if DEBUG_FORTH_WORDS 
aa1f			;		DMARK "Lt1" 
aa1f			;		CALLMONITOR 
aa1f			;	endif 
aa1f			;		 
aa1f			; 
aa1f			;; malloc space for the string because we cant change it 
aa1f			; 
aa1f			;		call malloc 
aa1f			;	if DEBUG_FORTH_MALLOC_GUARD 
aa1f			;		push af 
aa1f			;		call ishlzero 
aa1f			;		pop af 
aa1f			;		 
aa1f			;		call z,malloc_error 
aa1f			;	endif 
aa1f			; 
aa1f			;	if DEBUG_FORTH_WORDS 
aa1f			;		DMARK "Lt2" 
aa1f			;		CALLMONITOR 
aa1f			;	endif 
aa1f			;		pop de 
aa1f			;		push hl    ; push the malloc to release later 
aa1f			;		push hl   ;  push back a copy for the later stack push 
aa1f			;		 
aa1f			;; copy the string swapping out the zero terms for spaces 
aa1f			; 
aa1f			;		; de has our source 
aa1f			;		; hl has our dest 
aa1f			; 
aa1f			;; add the coln def 
aa1f			; 
aa1f			;		ld a, ':' 
aa1f			;		ld (hl), a 
aa1f			;		inc hl 
aa1f			;		ld a, ' ' 
aa1f			;		ld (hl), a 
aa1f			;		inc hl 
aa1f			; 
aa1f			;; add the uname word 
aa1f			;		push de   ; save our string for now 
aa1f			;		ex de, hl 
aa1f			; 
aa1f			;		FORTH_DSP_VALUE 
aa1f			;		;v5 FORTH_DSP_VALUE 
aa1f			; 
aa1f			;		inc hl   ; skip type but we know by now this is OK 
aa1f			; 
aa1f			;.luword:	ld a,(hl) 
aa1f			;		cp 0 
aa1f			;		jr z, .luword2 
aa1f			;		ld (de), a 
aa1f			;		inc de 
aa1f			;		inc hl 
aa1f			;		jr .luword 
aa1f			; 
aa1f			;.luword2:	ld a, ' ' 
aa1f			;		ld (de), a 
aa1f			;;		inc hl 
aa1f			;;		inc de 
aa1f			;;		ld (de), a 
aa1f			;;		inc hl 
aa1f			;		inc de 
aa1f			; 
aa1f			;		ex de, hl 
aa1f			;		pop de 
aa1f			;		 
aa1f			;		 
aa1f			; 
aa1f			;; detoken that string and copy it 
aa1f			; 
aa1f			;	if DEBUG_FORTH_WORDS 
aa1f			;		DMARK "Lt2" 
aa1f			;		CALLMONITOR 
aa1f			;	endif 
aa1f			;.ldetok:	ld a, (de) 
aa1f			;		cp FORTH_END_BUFFER 
aa1f			;		jr z, .ldetokend 
aa1f			;		; swap out any zero term for space 
aa1f			;		cp 0 
aa1f			;		jr nz, .ldetoknext 
aa1f			;		ld a, ' ' 
aa1f			; 
aa1f			;	if DEBUG_FORTH_WORDS 
aa1f			;		DMARK "LtS" 
aa1f			;		CALLMONITOR 
aa1f			;	endif 
aa1f			;.ldetoknext:	ld (hl), a 
aa1f			;		inc de 
aa1f			;		inc hl 
aa1f			;		jr .ldetok 
aa1f			; 
aa1f			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
aa1f			;		ld (hl), a  
aa1f			; 
aa1f			;; free that temp malloc 
aa1f			; 
aa1f			;		pop hl    
aa1f			; 
aa1f			;	if DEBUG_FORTH_WORDS 
aa1f			;		DMARK "Lt4" 
aa1f			;		CALLMONITOR 
aa1f			;	endif 
aa1f			;		call forth_apushstrhl 
aa1f			; 
aa1f			;		; get rid of temp malloc area 
aa1f			; 
aa1f			;		pop hl 
aa1f			;		call free 
aa1f			; 
aa1f			;		jr .ludone 
aa1f			; 
aa1f			;.lnuword:	pop hl 
aa1f			;		call forth_tok_next 
aa1f			;		jp .ldouscan  
aa1f			; 
aa1f			;.ludone:		 pop hl 
aa1f			; 
aa1f					NEXTW 
aa1f c3 e7 9e			jp macro_next 
aa22				endm 
# End of macro NEXTW
aa22			 
aa22			.FORGET: 
aa22				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
aa22 5d				db WORD_SYS_CORE+73             
aa23 9b aa			dw .NOP            
aa25 07				db 6 + 1 
aa26 .. 00			db "FORGET",0              
aa2d				endm 
# End of macro CWHEAD
aa2d			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
aa2d			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
aa2d			; | |  
aa2d			; | | e.g. "MORE" forget 
aa2d					if DEBUG_FORTH_WORDS_KEY 
aa2d						DMARK "FRG" 
aa2d f5				push af  
aa2e 3a 42 aa			ld a, (.dmark)  
aa31 32 6b ee			ld (debug_mark),a  
aa34 3a 43 aa			ld a, (.dmark+1)  
aa37 32 6c ee			ld (debug_mark+1),a  
aa3a 3a 44 aa			ld a, (.dmark+2)  
aa3d 32 6d ee			ld (debug_mark+2),a  
aa40 18 03			jr .pastdmark  
aa42 ..			.dmark: db "FRG"  
aa45 f1			.pastdmark: pop af  
aa46			endm  
# End of macro DMARK
aa46						CALLMONITOR 
aa46 cd 6f ee			call debug_vector  
aa49				endm  
# End of macro CALLMONITOR
aa49					endif 
aa49			 
aa49				; find uword 
aa49			        ; update start of word with "_" 
aa49				; replace uword with deleted flag 
aa49			 
aa49			 
aa49			;	if DEBUG_FORTH_WORDS 
aa49			;		DMARK "FOG" 
aa49			;		CALLMONITOR 
aa49			;	endif 
aa49			 
aa49			 
aa49					; Get ptr to the word we need to look up 
aa49			 
aa49					FORTH_DSP_VALUEHL 
aa49 cd 31 9d			call macro_dsp_valuehl 
aa4c				endm 
# End of macro FORTH_DSP_VALUEHL
aa4c					;v5 FORTH_DSP_VALUE 
aa4c				; TODO type check 
aa4c			;		inc hl    ; Skip type check  
aa4c e5					push hl 
aa4d c1					pop bc 
aa4e			;		ex de, hl    ; put into DE 
aa4e			 
aa4e			 
aa4e 21 2c e4				ld hl, baseram 
aa51					;ld hl, baseusermem 
aa51			 
aa51				; skip dict stub 
aa51			;	call forth_tok_next 
aa51 e5			push hl   ; sacreifical push 
aa52			 
aa52			.fldouscanm: 
aa52 e1				pop hl 
aa53			.fldouscan: 
aa53			;	if DEBUG_FORTH_WORDS 
aa53			;		DMARK "LSs" 
aa53			;		CALLMONITOR 
aa53			;	endif 
aa53				; skip dict stub 
aa53 cd 38 a0				call forth_tok_next 
aa56			 
aa56			 
aa56			; while we have words to look for 
aa56			 
aa56 7e				ld a, (hl)      
aa57			;	if DEBUG_FORTH_WORDS 
aa57			;		DMARK "LSk" 
aa57			;		CALLMONITOR 
aa57			;	endif 
aa57 fe 00				cp WORD_SYS_END 
aa59 ca 95 aa				jp z, .flunotfound 
aa5c fe 01				cp WORD_SYS_UWORD 
aa5e c2 53 aa				jp nz, .fldouscan 
aa61			 
aa61			;	if DEBUG_FORTH_WORDS 
aa61			;		DMARK "LSu" 
aa61			;		CALLMONITOR 
aa61			;	endif 
aa61			 
aa61					; found a uword but is it the one we want... 
aa61			 
aa61 c5					push bc     ; uword to find is on bc 
aa62 d1					pop de 
aa63			 
aa63 e5					push hl  ; to save the ptr 
aa64			 
aa64					; skip opcode 
aa64 23					inc hl  
aa65					; skip next ptr 
aa65 23					inc hl  
aa66 23					inc hl 
aa67					; skip len 
aa67 23					inc hl 
aa68			 
aa68			;	if DEBUG_FORTH_WORDS 
aa68			;		DMARK "LSc" 
aa68			;		CALLMONITOR 
aa68			;	endif 
aa68 cd 72 91				call strcmp 
aa6b c2 52 aa				jp nz, .fldouscanm 
aa6e			; 
aa6e			; 
aa6e			;; while we have words to look for 
aa6e			; 
aa6e			;.fdouscan:	ld a, (hl)      
aa6e			;	if DEBUG_FORTH_WORDS 
aa6e			;		DMARK "LSs" 
aa6e			;		CALLMONITOR 
aa6e			;	endif 
aa6e			;		cp WORD_SYS_END 
aa6e			;		jp z, .fudone 
aa6e			;		cp WORD_SYS_UWORD 
aa6e			;		jp nz, .fnuword 
aa6e			; 
aa6e			;	if DEBUG_FORTH_WORDS 
aa6e			;		DMARK "FGu" 
aa6e			;		CALLMONITOR 
aa6e			;	endif 
aa6e			; 
aa6e			;		; found a uword but is it the one we want... 
aa6e			; 
aa6e			; 
aa6e			;	        pop de   ; get back the dsp name 
aa6e			;		push de 
aa6e			; 
aa6e			;		push hl  ; to save the ptr 
aa6e			; 
aa6e			;		; skip opcode 
aa6e			;		inc hl  
aa6e			;		; skip next ptr 
aa6e			;		inc hl  
aa6e			;		inc hl 
aa6e			;		; skip len 
aa6e			;		inc hl 
aa6e			; 
aa6e			;	if DEBUG_FORTH_WORDS 
aa6e			;		DMARK "FGc" 
aa6e			;		CALLMONITOR 
aa6e			;	endif 
aa6e			;		call strcmp 
aa6e			;		jp nz, .fnuword 
aa6e			 
aa6e			 
aa6e e1			pop hl 
aa6f			 
aa6f				 
aa6f				if DEBUG_FORTH_WORDS 
aa6f					DMARK "FGm" 
aa6f f5				push af  
aa70 3a 84 aa			ld a, (.dmark)  
aa73 32 6b ee			ld (debug_mark),a  
aa76 3a 85 aa			ld a, (.dmark+1)  
aa79 32 6c ee			ld (debug_mark+1),a  
aa7c 3a 86 aa			ld a, (.dmark+2)  
aa7f 32 6d ee			ld (debug_mark+2),a  
aa82 18 03			jr .pastdmark  
aa84 ..			.dmark: db "FGm"  
aa87 f1			.pastdmark: pop af  
aa88			endm  
# End of macro DMARK
aa88					CALLMONITOR 
aa88 cd 6f ee			call debug_vector  
aa8b				endm  
# End of macro CALLMONITOR
aa8b				endif 
aa8b			 
aa8b			 
aa8b			 
aa8b					; we have a uword so push its name to the stack 
aa8b			 
aa8b			;	   	push hl  ; save so we can move to next dict block 
aa8b			;pop hl 
aa8b			 
aa8b					; update opcode to deleted 
aa8b 3e 03				ld a, WORD_SYS_DELETED 
aa8d 77					ld (hl), a 
aa8e			 
aa8e 23					inc hl  
aa8f					; skip next ptr 
aa8f 23					inc hl  
aa90 23					inc hl 
aa91					; skip len 
aa91 23					inc hl 
aa92			 
aa92					; TODO change parser to skip deleted words but for now mark it out 
aa92 3e 5f				ld a, "_" 
aa94 77					ld  (hl),a 
aa95			 
aa95			;		jr .fudone 
aa95			; 
aa95			;.fnuword:	pop hl 
aa95			;		call forth_tok_next 
aa95			;		jp .fdouscan  
aa95			 
aa95			.flunotfound:		  
aa95			 
aa95			 
aa95					 
aa95					FORTH_DSP_POP 
aa95 cd e9 9d			call macro_forth_dsp_pop 
aa98				endm 
# End of macro FORTH_DSP_POP
aa98			;		ld hl, .luno 
aa98			;.fudone:		 pop hl 
aa98					NEXTW 
aa98 c3 e7 9e			jp macro_next 
aa9b				endm 
# End of macro NEXTW
aa9b			.NOP: 
aa9b				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
aa9b 61				db WORD_SYS_CORE+77             
aa9c c2 aa			dw .COMO            
aa9e 04				db 3 + 1 
aa9f .. 00			db "NOP",0              
aaa3				endm 
# End of macro CWHEAD
aaa3			; | NOP (  --  ) Do nothing | DONE 
aaa3					if DEBUG_FORTH_WORDS_KEY 
aaa3						DMARK "NOP" 
aaa3 f5				push af  
aaa4 3a b8 aa			ld a, (.dmark)  
aaa7 32 6b ee			ld (debug_mark),a  
aaaa 3a b9 aa			ld a, (.dmark+1)  
aaad 32 6c ee			ld (debug_mark+1),a  
aab0 3a ba aa			ld a, (.dmark+2)  
aab3 32 6d ee			ld (debug_mark+2),a  
aab6 18 03			jr .pastdmark  
aab8 ..			.dmark: db "NOP"  
aabb f1			.pastdmark: pop af  
aabc			endm  
# End of macro DMARK
aabc						CALLMONITOR 
aabc cd 6f ee			call debug_vector  
aabf				endm  
# End of macro CALLMONITOR
aabf					endif 
aabf				       NEXTW 
aabf c3 e7 9e			jp macro_next 
aac2				endm 
# End of macro NEXTW
aac2			.COMO: 
aac2				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
aac2 6e				db WORD_SYS_CORE+90             
aac3 14 ab			dw .COMC            
aac5 02				db 1 + 1 
aac6 .. 00			db "(",0              
aac8				endm 
# End of macro CWHEAD
aac8			; | ( ( -- )  Start of comment | DONE 
aac8			 
aac8			 
aac8 2a c2 e5				ld hl, ( os_tok_ptr) 
aacb 11 0f ab			ld de, .closepar 
aace					 
aace					if DEBUG_FORTH_WORDS 
aace						DMARK ").." 
aace f5				push af  
aacf 3a e3 aa			ld a, (.dmark)  
aad2 32 6b ee			ld (debug_mark),a  
aad5 3a e4 aa			ld a, (.dmark+1)  
aad8 32 6c ee			ld (debug_mark+1),a  
aadb 3a e5 aa			ld a, (.dmark+2)  
aade 32 6d ee			ld (debug_mark+2),a  
aae1 18 03			jr .pastdmark  
aae3 ..			.dmark: db ").."  
aae6 f1			.pastdmark: pop af  
aae7			endm  
# End of macro DMARK
aae7						CALLMONITOR 
aae7 cd 6f ee			call debug_vector  
aaea				endm  
# End of macro CALLMONITOR
aaea					endif 
aaea cd 02 a0			call findnexttok  
aaed			 
aaed					if DEBUG_FORTH_WORDS 
aaed						DMARK "IF5" 
aaed f5				push af  
aaee 3a 02 ab			ld a, (.dmark)  
aaf1 32 6b ee			ld (debug_mark),a  
aaf4 3a 03 ab			ld a, (.dmark+1)  
aaf7 32 6c ee			ld (debug_mark+1),a  
aafa 3a 04 ab			ld a, (.dmark+2)  
aafd 32 6d ee			ld (debug_mark+2),a  
ab00 18 03			jr .pastdmark  
ab02 ..			.dmark: db "IF5"  
ab05 f1			.pastdmark: pop af  
ab06			endm  
# End of macro DMARK
ab06						CALLMONITOR 
ab06 cd 6f ee			call debug_vector  
ab09				endm  
# End of macro CALLMONITOR
ab09					endif 
ab09				; replace below with ) exec using tok_ptr 
ab09 22 c2 e5			ld (os_tok_ptr), hl 
ab0c c3 78 9f			jp exec1 
ab0f			 
ab0f .. 00			.closepar:   db ")",0 
ab11			 
ab11				       NEXTW 
ab11 c3 e7 9e			jp macro_next 
ab14				endm 
# End of macro NEXTW
ab14			.COMC: 
ab14				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
ab14 6f				db WORD_SYS_CORE+91             
ab15 1d ab			dw .SCRATCH            
ab17 02				db 1 + 1 
ab18 .. 00			db ")",0              
ab1a				endm 
# End of macro CWHEAD
ab1a			; | ) ( -- )  End of comment |  DONE  
ab1a				       NEXTW 
ab1a c3 e7 9e			jp macro_next 
ab1d				endm 
# End of macro NEXTW
ab1d			 
ab1d			.SCRATCH: 
ab1d				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
ab1d 6f				db WORD_SYS_CORE+91             
ab1e 58 ab			dw .INC            
ab20 08				db 7 + 1 
ab21 .. 00			db "SCRATCH",0              
ab29				endm 
# End of macro CWHEAD
ab29			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
ab29			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
ab29			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
ab29			; | |  
ab29			; | | e.g.    : score $00 scratch ; 
ab29			; | |  
ab29			; | | $00 score ! 
ab29			; | | $01 score +! 
ab29			; | |  
ab29			; | | e.g.   : varword $0a scratch ;  
ab29			; | | 
ab29			; | | $8000 varword ! 
ab29					if DEBUG_FORTH_WORDS_KEY 
ab29						DMARK "SCR" 
ab29 f5				push af  
ab2a 3a 3e ab			ld a, (.dmark)  
ab2d 32 6b ee			ld (debug_mark),a  
ab30 3a 3f ab			ld a, (.dmark+1)  
ab33 32 6c ee			ld (debug_mark+1),a  
ab36 3a 40 ab			ld a, (.dmark+2)  
ab39 32 6d ee			ld (debug_mark+2),a  
ab3c 18 03			jr .pastdmark  
ab3e ..			.dmark: db "SCR"  
ab41 f1			.pastdmark: pop af  
ab42			endm  
# End of macro DMARK
ab42						CALLMONITOR 
ab42 cd 6f ee			call debug_vector  
ab45				endm  
# End of macro CALLMONITOR
ab45					endif 
ab45			 
ab45					FORTH_DSP_VALUEHL 
ab45 cd 31 9d			call macro_dsp_valuehl 
ab48				endm 
# End of macro FORTH_DSP_VALUEHL
ab48				 
ab48					FORTH_DSP_POP 
ab48 cd e9 9d			call macro_forth_dsp_pop 
ab4b				endm 
# End of macro FORTH_DSP_POP
ab4b			 
ab4b 7d					ld a, l 
ab4c 21 e6 e7				ld hl, os_var_array 
ab4f cd dc 8c				call addatohl 
ab52			 
ab52 cd 3a 9b				call forth_push_numhl 
ab55			 
ab55				       NEXTW 
ab55 c3 e7 9e			jp macro_next 
ab58				endm 
# End of macro NEXTW
ab58			 
ab58			.INC: 
ab58				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
ab58 6f				db WORD_SYS_CORE+91             
ab59 ac ab			dw .DEC            
ab5b 03				db 2 + 1 
ab5c .. 00			db "+!",0              
ab5f				endm 
# End of macro CWHEAD
ab5f			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
ab5f					if DEBUG_FORTH_WORDS_KEY 
ab5f						DMARK "+s_" 
ab5f f5				push af  
ab60 3a 74 ab			ld a, (.dmark)  
ab63 32 6b ee			ld (debug_mark),a  
ab66 3a 75 ab			ld a, (.dmark+1)  
ab69 32 6c ee			ld (debug_mark+1),a  
ab6c 3a 76 ab			ld a, (.dmark+2)  
ab6f 32 6d ee			ld (debug_mark+2),a  
ab72 18 03			jr .pastdmark  
ab74 ..			.dmark: db "+s_"  
ab77 f1			.pastdmark: pop af  
ab78			endm  
# End of macro DMARK
ab78						CALLMONITOR 
ab78 cd 6f ee			call debug_vector  
ab7b				endm  
# End of macro CALLMONITOR
ab7b					endif 
ab7b			 
ab7b					FORTH_DSP_VALUEHL 
ab7b cd 31 9d			call macro_dsp_valuehl 
ab7e				endm 
# End of macro FORTH_DSP_VALUEHL
ab7e			 
ab7e e5					push hl   ; save address 
ab7f			 
ab7f					FORTH_DSP_POP 
ab7f cd e9 9d			call macro_forth_dsp_pop 
ab82				endm 
# End of macro FORTH_DSP_POP
ab82			 
ab82					FORTH_DSP_VALUEHL 
ab82 cd 31 9d			call macro_dsp_valuehl 
ab85				endm 
# End of macro FORTH_DSP_VALUEHL
ab85			 
ab85					FORTH_DSP_POP 
ab85 cd e9 9d			call macro_forth_dsp_pop 
ab88				endm 
# End of macro FORTH_DSP_POP
ab88			 
ab88					; hl contains value to add to byte at a 
ab88				 
ab88 eb					ex de, hl 
ab89			 
ab89 e1					pop hl 
ab8a			 
ab8a					if DEBUG_FORTH_WORDS 
ab8a						DMARK "INC" 
ab8a f5				push af  
ab8b 3a 9f ab			ld a, (.dmark)  
ab8e 32 6b ee			ld (debug_mark),a  
ab91 3a a0 ab			ld a, (.dmark+1)  
ab94 32 6c ee			ld (debug_mark+1),a  
ab97 3a a1 ab			ld a, (.dmark+2)  
ab9a 32 6d ee			ld (debug_mark+2),a  
ab9d 18 03			jr .pastdmark  
ab9f ..			.dmark: db "INC"  
aba2 f1			.pastdmark: pop af  
aba3			endm  
# End of macro DMARK
aba3						CALLMONITOR 
aba3 cd 6f ee			call debug_vector  
aba6				endm  
# End of macro CALLMONITOR
aba6					endif 
aba6			 
aba6 7e					ld a,(hl) 
aba7 83					add e 
aba8 77					ld (hl),a 
aba9			 
aba9			 
aba9			 
aba9				       NEXTW 
aba9 c3 e7 9e			jp macro_next 
abac				endm 
# End of macro NEXTW
abac			 
abac			.DEC: 
abac				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
abac 6f				db WORD_SYS_CORE+91             
abad fd ab			dw .INC2            
abaf 03				db 2 + 1 
abb0 .. 00			db "-!",0              
abb3				endm 
# End of macro CWHEAD
abb3			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
abb3					if DEBUG_FORTH_WORDS_KEY 
abb3						DMARK "-s_" 
abb3 f5				push af  
abb4 3a c8 ab			ld a, (.dmark)  
abb7 32 6b ee			ld (debug_mark),a  
abba 3a c9 ab			ld a, (.dmark+1)  
abbd 32 6c ee			ld (debug_mark+1),a  
abc0 3a ca ab			ld a, (.dmark+2)  
abc3 32 6d ee			ld (debug_mark+2),a  
abc6 18 03			jr .pastdmark  
abc8 ..			.dmark: db "-s_"  
abcb f1			.pastdmark: pop af  
abcc			endm  
# End of macro DMARK
abcc						CALLMONITOR 
abcc cd 6f ee			call debug_vector  
abcf				endm  
# End of macro CALLMONITOR
abcf					endif 
abcf			 
abcf					FORTH_DSP_VALUEHL 
abcf cd 31 9d			call macro_dsp_valuehl 
abd2				endm 
# End of macro FORTH_DSP_VALUEHL
abd2			 
abd2 e5					push hl   ; save address 
abd3			 
abd3					FORTH_DSP_POP 
abd3 cd e9 9d			call macro_forth_dsp_pop 
abd6				endm 
# End of macro FORTH_DSP_POP
abd6			 
abd6					FORTH_DSP_VALUEHL 
abd6 cd 31 9d			call macro_dsp_valuehl 
abd9				endm 
# End of macro FORTH_DSP_VALUEHL
abd9			 
abd9					; hl contains value to add to byte at a 
abd9				 
abd9 eb					ex de, hl 
abda			 
abda e1					pop hl 
abdb			 
abdb					if DEBUG_FORTH_WORDS 
abdb						DMARK "DEC" 
abdb f5				push af  
abdc 3a f0 ab			ld a, (.dmark)  
abdf 32 6b ee			ld (debug_mark),a  
abe2 3a f1 ab			ld a, (.dmark+1)  
abe5 32 6c ee			ld (debug_mark+1),a  
abe8 3a f2 ab			ld a, (.dmark+2)  
abeb 32 6d ee			ld (debug_mark+2),a  
abee 18 03			jr .pastdmark  
abf0 ..			.dmark: db "DEC"  
abf3 f1			.pastdmark: pop af  
abf4			endm  
# End of macro DMARK
abf4						CALLMONITOR 
abf4 cd 6f ee			call debug_vector  
abf7				endm  
# End of macro CALLMONITOR
abf7					endif 
abf7			 
abf7 7e					ld a,(hl) 
abf8 93					sub e 
abf9 77					ld (hl),a 
abfa			 
abfa			 
abfa			 
abfa				       NEXTW 
abfa c3 e7 9e			jp macro_next 
abfd				endm 
# End of macro NEXTW
abfd			 
abfd			.INC2: 
abfd				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
abfd 6f				db WORD_SYS_CORE+91             
abfe a7 ac			dw .DEC2            
ac00 04				db 3 + 1 
ac01 .. 00			db "+2!",0              
ac05				endm 
# End of macro CWHEAD
ac05			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ac05			 
ac05					if DEBUG_FORTH_WORDS_KEY 
ac05						DMARK "+2s" 
ac05 f5				push af  
ac06 3a 1a ac			ld a, (.dmark)  
ac09 32 6b ee			ld (debug_mark),a  
ac0c 3a 1b ac			ld a, (.dmark+1)  
ac0f 32 6c ee			ld (debug_mark+1),a  
ac12 3a 1c ac			ld a, (.dmark+2)  
ac15 32 6d ee			ld (debug_mark+2),a  
ac18 18 03			jr .pastdmark  
ac1a ..			.dmark: db "+2s"  
ac1d f1			.pastdmark: pop af  
ac1e			endm  
# End of macro DMARK
ac1e						CALLMONITOR 
ac1e cd 6f ee			call debug_vector  
ac21				endm  
# End of macro CALLMONITOR
ac21					endif 
ac21			 
ac21					; Address 
ac21			 
ac21					FORTH_DSP_VALUEHL 
ac21 cd 31 9d			call macro_dsp_valuehl 
ac24				endm 
# End of macro FORTH_DSP_VALUEHL
ac24			 
ac24 e5					push hl    ; save address 
ac25			 
ac25					; load content into de 
ac25			 
ac25 5e					ld e,(hl) 
ac26 23					inc hl 
ac27 56					ld d, (hl) 
ac28			 
ac28					if DEBUG_FORTH_WORDS 
ac28						DMARK "+2a" 
ac28 f5				push af  
ac29 3a 3d ac			ld a, (.dmark)  
ac2c 32 6b ee			ld (debug_mark),a  
ac2f 3a 3e ac			ld a, (.dmark+1)  
ac32 32 6c ee			ld (debug_mark+1),a  
ac35 3a 3f ac			ld a, (.dmark+2)  
ac38 32 6d ee			ld (debug_mark+2),a  
ac3b 18 03			jr .pastdmark  
ac3d ..			.dmark: db "+2a"  
ac40 f1			.pastdmark: pop af  
ac41			endm  
# End of macro DMARK
ac41						CALLMONITOR 
ac41 cd 6f ee			call debug_vector  
ac44				endm  
# End of macro CALLMONITOR
ac44					endif 
ac44			 
ac44					FORTH_DSP_POP 
ac44 cd e9 9d			call macro_forth_dsp_pop 
ac47				endm 
# End of macro FORTH_DSP_POP
ac47			 
ac47					; Get value to add 
ac47			 
ac47					FORTH_DSP_VALUE 
ac47 cd 1a 9d			call macro_forth_dsp_value 
ac4a				endm 
# End of macro FORTH_DSP_VALUE
ac4a			 
ac4a					if DEBUG_FORTH_WORDS 
ac4a						DMARK "+2v" 
ac4a f5				push af  
ac4b 3a 5f ac			ld a, (.dmark)  
ac4e 32 6b ee			ld (debug_mark),a  
ac51 3a 60 ac			ld a, (.dmark+1)  
ac54 32 6c ee			ld (debug_mark+1),a  
ac57 3a 61 ac			ld a, (.dmark+2)  
ac5a 32 6d ee			ld (debug_mark+2),a  
ac5d 18 03			jr .pastdmark  
ac5f ..			.dmark: db "+2v"  
ac62 f1			.pastdmark: pop af  
ac63			endm  
# End of macro DMARK
ac63						CALLMONITOR 
ac63 cd 6f ee			call debug_vector  
ac66				endm  
# End of macro CALLMONITOR
ac66					endif 
ac66			 
ac66 19					add hl, de 
ac67			 
ac67					if DEBUG_FORTH_WORDS 
ac67						DMARK "+2+" 
ac67 f5				push af  
ac68 3a 7c ac			ld a, (.dmark)  
ac6b 32 6b ee			ld (debug_mark),a  
ac6e 3a 7d ac			ld a, (.dmark+1)  
ac71 32 6c ee			ld (debug_mark+1),a  
ac74 3a 7e ac			ld a, (.dmark+2)  
ac77 32 6d ee			ld (debug_mark+2),a  
ac7a 18 03			jr .pastdmark  
ac7c ..			.dmark: db "+2+"  
ac7f f1			.pastdmark: pop af  
ac80			endm  
# End of macro DMARK
ac80						CALLMONITOR 
ac80 cd 6f ee			call debug_vector  
ac83				endm  
# End of macro CALLMONITOR
ac83					endif 
ac83			 
ac83					; move result to de 
ac83			 
ac83 eb					ex de, hl 
ac84			 
ac84					; Address 
ac84			 
ac84 e1					pop hl 
ac85			 
ac85					; save it back 
ac85			 
ac85 73					ld (hl), e 
ac86 23					inc hl 
ac87 72					ld (hl), d 
ac88			 
ac88					if DEBUG_FORTH_WORDS 
ac88						DMARK "+2e" 
ac88 f5				push af  
ac89 3a 9d ac			ld a, (.dmark)  
ac8c 32 6b ee			ld (debug_mark),a  
ac8f 3a 9e ac			ld a, (.dmark+1)  
ac92 32 6c ee			ld (debug_mark+1),a  
ac95 3a 9f ac			ld a, (.dmark+2)  
ac98 32 6d ee			ld (debug_mark+2),a  
ac9b 18 03			jr .pastdmark  
ac9d ..			.dmark: db "+2e"  
aca0 f1			.pastdmark: pop af  
aca1			endm  
# End of macro DMARK
aca1						CALLMONITOR 
aca1 cd 6f ee			call debug_vector  
aca4				endm  
# End of macro CALLMONITOR
aca4					endif 
aca4			 
aca4			 
aca4			 
aca4			 
aca4			 
aca4				       NEXTW 
aca4 c3 e7 9e			jp macro_next 
aca7				endm 
# End of macro NEXTW
aca7			 
aca7			.DEC2: 
aca7				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
aca7 6f				db WORD_SYS_CORE+91             
aca8 53 ad			dw .GET2            
acaa 04				db 3 + 1 
acab .. 00			db "-2!",0              
acaf				endm 
# End of macro CWHEAD
acaf			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
acaf			 
acaf			 
acaf					if DEBUG_FORTH_WORDS_KEY 
acaf						DMARK "-2s" 
acaf f5				push af  
acb0 3a c4 ac			ld a, (.dmark)  
acb3 32 6b ee			ld (debug_mark),a  
acb6 3a c5 ac			ld a, (.dmark+1)  
acb9 32 6c ee			ld (debug_mark+1),a  
acbc 3a c6 ac			ld a, (.dmark+2)  
acbf 32 6d ee			ld (debug_mark+2),a  
acc2 18 03			jr .pastdmark  
acc4 ..			.dmark: db "-2s"  
acc7 f1			.pastdmark: pop af  
acc8			endm  
# End of macro DMARK
acc8						CALLMONITOR 
acc8 cd 6f ee			call debug_vector  
accb				endm  
# End of macro CALLMONITOR
accb					endif 
accb			 
accb					; Address 
accb			 
accb					FORTH_DSP_VALUEHL 
accb cd 31 9d			call macro_dsp_valuehl 
acce				endm 
# End of macro FORTH_DSP_VALUEHL
acce			 
acce e5					push hl    ; save address 
accf			 
accf					; load content into de 
accf			 
accf 5e					ld e,(hl) 
acd0 23					inc hl 
acd1 56					ld d, (hl) 
acd2			 
acd2					if DEBUG_FORTH_WORDS 
acd2						DMARK "-2a" 
acd2 f5				push af  
acd3 3a e7 ac			ld a, (.dmark)  
acd6 32 6b ee			ld (debug_mark),a  
acd9 3a e8 ac			ld a, (.dmark+1)  
acdc 32 6c ee			ld (debug_mark+1),a  
acdf 3a e9 ac			ld a, (.dmark+2)  
ace2 32 6d ee			ld (debug_mark+2),a  
ace5 18 03			jr .pastdmark  
ace7 ..			.dmark: db "-2a"  
acea f1			.pastdmark: pop af  
aceb			endm  
# End of macro DMARK
aceb						CALLMONITOR 
aceb cd 6f ee			call debug_vector  
acee				endm  
# End of macro CALLMONITOR
acee					endif 
acee			 
acee					FORTH_DSP_POP 
acee cd e9 9d			call macro_forth_dsp_pop 
acf1				endm 
# End of macro FORTH_DSP_POP
acf1			 
acf1					; Get value to remove 
acf1			 
acf1					FORTH_DSP_VALUE 
acf1 cd 1a 9d			call macro_forth_dsp_value 
acf4				endm 
# End of macro FORTH_DSP_VALUE
acf4			 
acf4					if DEBUG_FORTH_WORDS 
acf4						DMARK "-2v" 
acf4 f5				push af  
acf5 3a 09 ad			ld a, (.dmark)  
acf8 32 6b ee			ld (debug_mark),a  
acfb 3a 0a ad			ld a, (.dmark+1)  
acfe 32 6c ee			ld (debug_mark+1),a  
ad01 3a 0b ad			ld a, (.dmark+2)  
ad04 32 6d ee			ld (debug_mark+2),a  
ad07 18 03			jr .pastdmark  
ad09 ..			.dmark: db "-2v"  
ad0c f1			.pastdmark: pop af  
ad0d			endm  
# End of macro DMARK
ad0d						CALLMONITOR 
ad0d cd 6f ee			call debug_vector  
ad10				endm  
# End of macro CALLMONITOR
ad10					endif 
ad10			 
ad10 eb					ex de, hl 
ad11 ed 52				sbc hl, de 
ad13			 
ad13					if DEBUG_FORTH_WORDS 
ad13						DMARK "-2d" 
ad13 f5				push af  
ad14 3a 28 ad			ld a, (.dmark)  
ad17 32 6b ee			ld (debug_mark),a  
ad1a 3a 29 ad			ld a, (.dmark+1)  
ad1d 32 6c ee			ld (debug_mark+1),a  
ad20 3a 2a ad			ld a, (.dmark+2)  
ad23 32 6d ee			ld (debug_mark+2),a  
ad26 18 03			jr .pastdmark  
ad28 ..			.dmark: db "-2d"  
ad2b f1			.pastdmark: pop af  
ad2c			endm  
# End of macro DMARK
ad2c						CALLMONITOR 
ad2c cd 6f ee			call debug_vector  
ad2f				endm  
# End of macro CALLMONITOR
ad2f					endif 
ad2f			 
ad2f					; move result to de 
ad2f			 
ad2f eb					ex de, hl 
ad30			 
ad30					; Address 
ad30			 
ad30 e1					pop hl 
ad31			 
ad31					; save it back 
ad31			 
ad31 73					ld (hl), e 
ad32 23					inc hl 
ad33 72					ld (hl), d 
ad34			 
ad34					if DEBUG_FORTH_WORDS 
ad34						DMARK "-2e" 
ad34 f5				push af  
ad35 3a 49 ad			ld a, (.dmark)  
ad38 32 6b ee			ld (debug_mark),a  
ad3b 3a 4a ad			ld a, (.dmark+1)  
ad3e 32 6c ee			ld (debug_mark+1),a  
ad41 3a 4b ad			ld a, (.dmark+2)  
ad44 32 6d ee			ld (debug_mark+2),a  
ad47 18 03			jr .pastdmark  
ad49 ..			.dmark: db "-2e"  
ad4c f1			.pastdmark: pop af  
ad4d			endm  
# End of macro DMARK
ad4d						CALLMONITOR 
ad4d cd 6f ee			call debug_vector  
ad50				endm  
# End of macro CALLMONITOR
ad50					endif 
ad50			 
ad50			 
ad50			 
ad50			 
ad50			 
ad50				       NEXTW 
ad50 c3 e7 9e			jp macro_next 
ad53				endm 
# End of macro NEXTW
ad53			.GET2: 
ad53				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
ad53 6f				db WORD_SYS_CORE+91             
ad54 83 ad			dw .BANG2            
ad56 03				db 2 + 1 
ad57 .. 00			db "2@",0              
ad5a				endm 
# End of macro CWHEAD
ad5a			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
ad5a					if DEBUG_FORTH_WORDS_KEY 
ad5a						DMARK "2A_" 
ad5a f5				push af  
ad5b 3a 6f ad			ld a, (.dmark)  
ad5e 32 6b ee			ld (debug_mark),a  
ad61 3a 70 ad			ld a, (.dmark+1)  
ad64 32 6c ee			ld (debug_mark+1),a  
ad67 3a 71 ad			ld a, (.dmark+2)  
ad6a 32 6d ee			ld (debug_mark+2),a  
ad6d 18 03			jr .pastdmark  
ad6f ..			.dmark: db "2A_"  
ad72 f1			.pastdmark: pop af  
ad73			endm  
# End of macro DMARK
ad73						CALLMONITOR 
ad73 cd 6f ee			call debug_vector  
ad76				endm  
# End of macro CALLMONITOR
ad76					endif 
ad76			 
ad76					FORTH_DSP_VALUEHL 
ad76 cd 31 9d			call macro_dsp_valuehl 
ad79				endm 
# End of macro FORTH_DSP_VALUEHL
ad79			 
ad79 5e					ld e, (hl) 
ad7a 23					inc hl 
ad7b 56					ld d, (hl) 
ad7c			 
ad7c eb					ex de, hl 
ad7d			 
ad7d cd 3a 9b				call forth_push_numhl 
ad80			 
ad80				       NEXTW 
ad80 c3 e7 9e			jp macro_next 
ad83				endm 
# End of macro NEXTW
ad83			.BANG2: 
ad83				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ad83 6f				db WORD_SYS_CORE+91             
ad84 bb ad			dw .CONFIG            
ad86 03				db 2 + 1 
ad87 .. 00			db "2!",0              
ad8a				endm 
# End of macro CWHEAD
ad8a			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ad8a					if DEBUG_FORTH_WORDS_KEY 
ad8a						DMARK "2S_" 
ad8a f5				push af  
ad8b 3a 9f ad			ld a, (.dmark)  
ad8e 32 6b ee			ld (debug_mark),a  
ad91 3a a0 ad			ld a, (.dmark+1)  
ad94 32 6c ee			ld (debug_mark+1),a  
ad97 3a a1 ad			ld a, (.dmark+2)  
ad9a 32 6d ee			ld (debug_mark+2),a  
ad9d 18 03			jr .pastdmark  
ad9f ..			.dmark: db "2S_"  
ada2 f1			.pastdmark: pop af  
ada3			endm  
# End of macro DMARK
ada3						CALLMONITOR 
ada3 cd 6f ee			call debug_vector  
ada6				endm  
# End of macro CALLMONITOR
ada6					endif 
ada6			 
ada6					FORTH_DSP_VALUEHL 
ada6 cd 31 9d			call macro_dsp_valuehl 
ada9				endm 
# End of macro FORTH_DSP_VALUEHL
ada9			 
ada9 e5					push hl   ; save address 
adaa			 
adaa			 
adaa					FORTH_DSP_POP 
adaa cd e9 9d			call macro_forth_dsp_pop 
adad				endm 
# End of macro FORTH_DSP_POP
adad			 
adad					 
adad					FORTH_DSP_VALUEHL 
adad cd 31 9d			call macro_dsp_valuehl 
adb0				endm 
# End of macro FORTH_DSP_VALUEHL
adb0			 
adb0					FORTH_DSP_POP 
adb0 cd e9 9d			call macro_forth_dsp_pop 
adb3				endm 
# End of macro FORTH_DSP_POP
adb3			 
adb3 eb					ex de, hl    ; value now in de 
adb4			 
adb4 e1					pop hl 
adb5			 
adb5 73					ld (hl), e 
adb6			 
adb6 23					inc hl 
adb7			 
adb7 72					ld (hl), d 
adb8			 
adb8			 
adb8				       NEXTW 
adb8 c3 e7 9e			jp macro_next 
adbb				endm 
# End of macro NEXTW
adbb			.CONFIG: 
adbb				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
adbb 6f				db WORD_SYS_CORE+91             
adbc cc ad			dw .ADTOS            
adbe 07				db 6 + 1 
adbf .. 00			db "CONFIG",0              
adc6				endm 
# End of macro CWHEAD
adc6			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
adc6			 
adc6 cd 3c 93				call config 
adc9					NEXTW 
adc9 c3 e7 9e			jp macro_next 
adcc				endm 
# End of macro NEXTW
adcc			 
adcc			.ADTOS: 
adcc				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
adcc 6f				db WORD_SYS_CORE+91             
adcd e2 ad			dw .SBTOS            
adcf 03				db 2 + 1 
add0 .. 00			db "1+",0              
add3				endm 
# End of macro CWHEAD
add3			; | 1+ ( u -- u )  Increment value on TOS | DONE 
add3			 
add3					FORTH_DSP_VALUEHL 
add3 cd 31 9d			call macro_dsp_valuehl 
add6				endm 
# End of macro FORTH_DSP_VALUEHL
add6 e5					push hl 
add7			 
add7					FORTH_DSP_POP 
add7 cd e9 9d			call macro_forth_dsp_pop 
adda				endm 
# End of macro FORTH_DSP_POP
adda e1					pop hl 
addb			 
addb 23					inc hl 
addc cd 3a 9b				call forth_push_numhl 
addf					 
addf					NEXTW 
addf c3 e7 9e			jp macro_next 
ade2				endm 
# End of macro NEXTW
ade2			.SBTOS: 
ade2				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
ade2 6f				db WORD_SYS_CORE+91             
ade3 f8 ad			dw .ADSTORE            
ade5 03				db 2 + 1 
ade6 .. 00			db "1-",0              
ade9				endm 
# End of macro CWHEAD
ade9			; | 1- ( u -- u )  Decrement value on TOS | DONE 
ade9			 
ade9					FORTH_DSP_VALUEHL 
ade9 cd 31 9d			call macro_dsp_valuehl 
adec				endm 
# End of macro FORTH_DSP_VALUEHL
adec e5					push hl 
aded			 
aded					FORTH_DSP_POP 
aded cd e9 9d			call macro_forth_dsp_pop 
adf0				endm 
# End of macro FORTH_DSP_POP
adf0 e1					pop hl 
adf1			 
adf1 2b					dec hl 
adf2 cd 3a 9b				call forth_push_numhl 
adf5					 
adf5					NEXTW 
adf5 c3 e7 9e			jp macro_next 
adf8				endm 
# End of macro NEXTW
adf8			.ADSTORE: 
adf8				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
adf8 6f				db WORD_SYS_CORE+91             
adf9 0e ae			dw .ADWSTORE            
adfb 04				db 3 + 1 
adfc .. 00			db "1+!",0              
ae00				endm 
# End of macro CWHEAD
ae00			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
ae00			 
ae00					FORTH_DSP_VALUEHL 
ae00 cd 31 9d			call macro_dsp_valuehl 
ae03				endm 
# End of macro FORTH_DSP_VALUEHL
ae03 e5					push hl 
ae04			 
ae04					FORTH_DSP_POP 
ae04 cd e9 9d			call macro_forth_dsp_pop 
ae07				endm 
# End of macro FORTH_DSP_POP
ae07 e1					pop hl 
ae08			 
ae08 7e					ld a, (hl) 
ae09 3c					inc a 
ae0a 77					ld (hl), a 
ae0b					 
ae0b					NEXTW 
ae0b c3 e7 9e			jp macro_next 
ae0e				endm 
# End of macro NEXTW
ae0e			.ADWSTORE: 
ae0e				CWHEAD .ENDCORE 91 "1+2!" 4 WORD_FLAG_CODE 
ae0e 6f				db WORD_SYS_CORE+91             
ae0f 2c ae			dw .ENDCORE            
ae11 05				db 4 + 1 
ae12 .. 00			db "1+2!",0              
ae17				endm 
# End of macro CWHEAD
ae17			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
ae17			 
ae17					FORTH_DSP_VALUEHL 
ae17 cd 31 9d			call macro_dsp_valuehl 
ae1a				endm 
# End of macro FORTH_DSP_VALUEHL
ae1a e5					push hl 
ae1b			 
ae1b					FORTH_DSP_POP 
ae1b cd e9 9d			call macro_forth_dsp_pop 
ae1e				endm 
# End of macro FORTH_DSP_POP
ae1e e1					pop hl 
ae1f			 
ae1f e5					push hl 
ae20			 
ae20 cd 69 9e				call loadwordinhl 
ae23 23					inc hl 
ae24			 
ae24 d1					pop de 
ae25 eb					ex de, hl 
ae26 73					ld (hl), e 
ae27 23					inc hl 
ae28 72					ld (hl), d 
ae29					 
ae29					NEXTW 
ae29 c3 e7 9e			jp macro_next 
ae2c				endm 
# End of macro NEXTW
ae2c			.ENDCORE: 
ae2c			 
ae2c			; eof 
ae2c			 
ae2c			 
# End of file forth_words_core.asm
ae2c			include "forth_words_flow.asm" 
ae2c			 
ae2c			; | ## Program Flow Words 
ae2c			 
ae2c			.IF: 
ae2c				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ae2c 1e				db WORD_SYS_CORE+10             
ae2d 21 af			dw .THEN            
ae2f 03				db 2 + 1 
ae30 .. 00			db "IF",0              
ae33				endm 
# End of macro CWHEAD
ae33			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ae33			; 
ae33					if DEBUG_FORTH_WORDS_KEY 
ae33						DMARK "IF." 
ae33 f5				push af  
ae34 3a 48 ae			ld a, (.dmark)  
ae37 32 6b ee			ld (debug_mark),a  
ae3a 3a 49 ae			ld a, (.dmark+1)  
ae3d 32 6c ee			ld (debug_mark+1),a  
ae40 3a 4a ae			ld a, (.dmark+2)  
ae43 32 6d ee			ld (debug_mark+2),a  
ae46 18 03			jr .pastdmark  
ae48 ..			.dmark: db "IF."  
ae4b f1			.pastdmark: pop af  
ae4c			endm  
# End of macro DMARK
ae4c						CALLMONITOR 
ae4c cd 6f ee			call debug_vector  
ae4f				endm  
# End of macro CALLMONITOR
ae4f					endif 
ae4f			; eval TOS 
ae4f			 
ae4f				FORTH_DSP_VALUEHL 
ae4f cd 31 9d			call macro_dsp_valuehl 
ae52				endm 
# End of macro FORTH_DSP_VALUEHL
ae52			 
ae52			;	push hl 
ae52				FORTH_DSP_POP 
ae52 cd e9 9d			call macro_forth_dsp_pop 
ae55				endm 
# End of macro FORTH_DSP_POP
ae55			;	pop hl 
ae55			 
ae55					if DEBUG_FORTH_WORDS 
ae55						DMARK "IF1" 
ae55 f5				push af  
ae56 3a 6a ae			ld a, (.dmark)  
ae59 32 6b ee			ld (debug_mark),a  
ae5c 3a 6b ae			ld a, (.dmark+1)  
ae5f 32 6c ee			ld (debug_mark+1),a  
ae62 3a 6c ae			ld a, (.dmark+2)  
ae65 32 6d ee			ld (debug_mark+2),a  
ae68 18 03			jr .pastdmark  
ae6a ..			.dmark: db "IF1"  
ae6d f1			.pastdmark: pop af  
ae6e			endm  
# End of macro DMARK
ae6e						CALLMONITOR 
ae6e cd 6f ee			call debug_vector  
ae71				endm  
# End of macro CALLMONITOR
ae71					endif 
ae71 b7				or a        ; clear carry flag 
ae72 11 00 00			ld de, 0 
ae75 eb				ex de,hl 
ae76 ed 52			sbc hl, de 
ae78 c2 02 af			jp nz, .iftrue 
ae7b			 
ae7b					if DEBUG_FORTH_WORDS 
ae7b						DMARK "IF2" 
ae7b f5				push af  
ae7c 3a 90 ae			ld a, (.dmark)  
ae7f 32 6b ee			ld (debug_mark),a  
ae82 3a 91 ae			ld a, (.dmark+1)  
ae85 32 6c ee			ld (debug_mark+1),a  
ae88 3a 92 ae			ld a, (.dmark+2)  
ae8b 32 6d ee			ld (debug_mark+2),a  
ae8e 18 03			jr .pastdmark  
ae90 ..			.dmark: db "IF2"  
ae93 f1			.pastdmark: pop af  
ae94			endm  
# End of macro DMARK
ae94						CALLMONITOR 
ae94 cd 6f ee			call debug_vector  
ae97				endm  
# End of macro CALLMONITOR
ae97					endif 
ae97			 
ae97			; if not true then skip to THEN 
ae97			 
ae97				; TODO get tok_ptr 
ae97				; TODO consume toks until we get to THEN 
ae97			 
ae97 2a c2 e5			ld hl, (os_tok_ptr) 
ae9a					if DEBUG_FORTH_WORDS 
ae9a						DMARK "IF3" 
ae9a f5				push af  
ae9b 3a af ae			ld a, (.dmark)  
ae9e 32 6b ee			ld (debug_mark),a  
aea1 3a b0 ae			ld a, (.dmark+1)  
aea4 32 6c ee			ld (debug_mark+1),a  
aea7 3a b1 ae			ld a, (.dmark+2)  
aeaa 32 6d ee			ld (debug_mark+2),a  
aead 18 03			jr .pastdmark  
aeaf ..			.dmark: db "IF3"  
aeb2 f1			.pastdmark: pop af  
aeb3			endm  
# End of macro DMARK
aeb3						CALLMONITOR 
aeb3 cd 6f ee			call debug_vector  
aeb6				endm  
# End of macro CALLMONITOR
aeb6						 
aeb6					endif 
aeb6 11 fd ae			ld de, .ifthen 
aeb9					if DEBUG_FORTH_WORDS 
aeb9						DMARK "IF4" 
aeb9 f5				push af  
aeba 3a ce ae			ld a, (.dmark)  
aebd 32 6b ee			ld (debug_mark),a  
aec0 3a cf ae			ld a, (.dmark+1)  
aec3 32 6c ee			ld (debug_mark+1),a  
aec6 3a d0 ae			ld a, (.dmark+2)  
aec9 32 6d ee			ld (debug_mark+2),a  
aecc 18 03			jr .pastdmark  
aece ..			.dmark: db "IF4"  
aed1 f1			.pastdmark: pop af  
aed2			endm  
# End of macro DMARK
aed2						CALLMONITOR 
aed2 cd 6f ee			call debug_vector  
aed5				endm  
# End of macro CALLMONITOR
aed5					endif 
aed5 cd 02 a0			call findnexttok  
aed8			 
aed8					if DEBUG_FORTH_WORDS 
aed8						DMARK "IF5" 
aed8 f5				push af  
aed9 3a ed ae			ld a, (.dmark)  
aedc 32 6b ee			ld (debug_mark),a  
aedf 3a ee ae			ld a, (.dmark+1)  
aee2 32 6c ee			ld (debug_mark+1),a  
aee5 3a ef ae			ld a, (.dmark+2)  
aee8 32 6d ee			ld (debug_mark+2),a  
aeeb 18 03			jr .pastdmark  
aeed ..			.dmark: db "IF5"  
aef0 f1			.pastdmark: pop af  
aef1			endm  
# End of macro DMARK
aef1						CALLMONITOR 
aef1 cd 6f ee			call debug_vector  
aef4				endm  
# End of macro CALLMONITOR
aef4					endif 
aef4				; TODO replace below with ; exec using tok_ptr 
aef4 22 c2 e5			ld (os_tok_ptr), hl 
aef7 c3 78 9f			jp exec1 
aefa				NEXTW 
aefa c3 e7 9e			jp macro_next 
aefd				endm 
# End of macro NEXTW
aefd			 
aefd .. 00		.ifthen:  db "THEN",0 
af02			 
af02			.iftrue:		 
af02				; Exec next words normally 
af02			 
af02				; if true then exec following IF as normal 
af02					if DEBUG_FORTH_WORDS 
af02						DMARK "IFT" 
af02 f5				push af  
af03 3a 17 af			ld a, (.dmark)  
af06 32 6b ee			ld (debug_mark),a  
af09 3a 18 af			ld a, (.dmark+1)  
af0c 32 6c ee			ld (debug_mark+1),a  
af0f 3a 19 af			ld a, (.dmark+2)  
af12 32 6d ee			ld (debug_mark+2),a  
af15 18 03			jr .pastdmark  
af17 ..			.dmark: db "IFT"  
af1a f1			.pastdmark: pop af  
af1b			endm  
# End of macro DMARK
af1b						CALLMONITOR 
af1b cd 6f ee			call debug_vector  
af1e				endm  
# End of macro CALLMONITOR
af1e					endif 
af1e			 
af1e					NEXTW 
af1e c3 e7 9e			jp macro_next 
af21				endm 
# End of macro NEXTW
af21			.THEN: 
af21				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
af21 1f				db WORD_SYS_CORE+11             
af22 49 af			dw .ELSE            
af24 05				db 4 + 1 
af25 .. 00			db "THEN",0              
af2a				endm 
# End of macro CWHEAD
af2a			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
af2a					if DEBUG_FORTH_WORDS_KEY 
af2a						DMARK "THN" 
af2a f5				push af  
af2b 3a 3f af			ld a, (.dmark)  
af2e 32 6b ee			ld (debug_mark),a  
af31 3a 40 af			ld a, (.dmark+1)  
af34 32 6c ee			ld (debug_mark+1),a  
af37 3a 41 af			ld a, (.dmark+2)  
af3a 32 6d ee			ld (debug_mark+2),a  
af3d 18 03			jr .pastdmark  
af3f ..			.dmark: db "THN"  
af42 f1			.pastdmark: pop af  
af43			endm  
# End of macro DMARK
af43						CALLMONITOR 
af43 cd 6f ee			call debug_vector  
af46				endm  
# End of macro CALLMONITOR
af46					endif 
af46					NEXTW 
af46 c3 e7 9e			jp macro_next 
af49				endm 
# End of macro NEXTW
af49			.ELSE: 
af49				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
af49 20				db WORD_SYS_CORE+12             
af4a 71 af			dw .DO            
af4c 03				db 2 + 1 
af4d .. 00			db "ELSE",0              
af52				endm 
# End of macro CWHEAD
af52			; | ELSE ( -- ) Not supported - does nothing | TODO 
af52			 
af52					if DEBUG_FORTH_WORDS_KEY 
af52						DMARK "ELS" 
af52 f5				push af  
af53 3a 67 af			ld a, (.dmark)  
af56 32 6b ee			ld (debug_mark),a  
af59 3a 68 af			ld a, (.dmark+1)  
af5c 32 6c ee			ld (debug_mark+1),a  
af5f 3a 69 af			ld a, (.dmark+2)  
af62 32 6d ee			ld (debug_mark+2),a  
af65 18 03			jr .pastdmark  
af67 ..			.dmark: db "ELS"  
af6a f1			.pastdmark: pop af  
af6b			endm  
# End of macro DMARK
af6b						CALLMONITOR 
af6b cd 6f ee			call debug_vector  
af6e				endm  
# End of macro CALLMONITOR
af6e					endif 
af6e			 
af6e			 
af6e					NEXTW 
af6e c3 e7 9e			jp macro_next 
af71				endm 
# End of macro NEXTW
af71			.DO: 
af71				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
af71 21				db WORD_SYS_CORE+13             
af72 98 b0			dw .LOOP            
af74 03				db 2 + 1 
af75 .. 00			db "DO",0              
af78				endm 
# End of macro CWHEAD
af78			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
af78			 
af78					if DEBUG_FORTH_WORDS_KEY 
af78						DMARK "DO." 
af78 f5				push af  
af79 3a 8d af			ld a, (.dmark)  
af7c 32 6b ee			ld (debug_mark),a  
af7f 3a 8e af			ld a, (.dmark+1)  
af82 32 6c ee			ld (debug_mark+1),a  
af85 3a 8f af			ld a, (.dmark+2)  
af88 32 6d ee			ld (debug_mark+2),a  
af8b 18 03			jr .pastdmark  
af8d ..			.dmark: db "DO."  
af90 f1			.pastdmark: pop af  
af91			endm  
# End of macro DMARK
af91						CALLMONITOR 
af91 cd 6f ee			call debug_vector  
af94				endm  
# End of macro CALLMONITOR
af94					endif 
af94			;  push pc to rsp stack past the DO 
af94			 
af94 2a c2 e5				ld hl, (os_tok_ptr) 
af97 23					inc hl   ; D 
af98 23					inc hl  ; O 
af99 23					inc hl   ; null 
af9a					if DEBUG_FORTH_WORDS 
af9a						DMARK "DO2" 
af9a f5				push af  
af9b 3a af af			ld a, (.dmark)  
af9e 32 6b ee			ld (debug_mark),a  
afa1 3a b0 af			ld a, (.dmark+1)  
afa4 32 6c ee			ld (debug_mark+1),a  
afa7 3a b1 af			ld a, (.dmark+2)  
afaa 32 6d ee			ld (debug_mark+2),a  
afad 18 03			jr .pastdmark  
afaf ..			.dmark: db "DO2"  
afb2 f1			.pastdmark: pop af  
afb3			endm  
# End of macro DMARK
afb3						CALLMONITOR 
afb3 cd 6f ee			call debug_vector  
afb6				endm  
# End of macro CALLMONITOR
afb6					endif 
afb6					FORTH_RSP_NEXT 
afb6 cd e1 9a			call macro_forth_rsp_next 
afb9				endm 
# End of macro FORTH_RSP_NEXT
afb9					if DEBUG_FORTH_WORDS 
afb9						DMARK "DO3" 
afb9 f5				push af  
afba 3a ce af			ld a, (.dmark)  
afbd 32 6b ee			ld (debug_mark),a  
afc0 3a cf af			ld a, (.dmark+1)  
afc3 32 6c ee			ld (debug_mark+1),a  
afc6 3a d0 af			ld a, (.dmark+2)  
afc9 32 6d ee			ld (debug_mark+2),a  
afcc 18 03			jr .pastdmark  
afce ..			.dmark: db "DO3"  
afd1 f1			.pastdmark: pop af  
afd2			endm  
# End of macro DMARK
afd2						CALLMONITOR 
afd2 cd 6f ee			call debug_vector  
afd5				endm  
# End of macro CALLMONITOR
afd5					endif 
afd5			 
afd5					;if DEBUG_FORTH_WORDS 
afd5				;		push hl 
afd5			;		endif  
afd5			 
afd5			; get counters from data stack 
afd5			 
afd5			 
afd5					FORTH_DSP_VALUEHL 
afd5 cd 31 9d			call macro_dsp_valuehl 
afd8				endm 
# End of macro FORTH_DSP_VALUEHL
afd8 e5					push hl		 ; hl now has starting counter which needs to be tos 
afd9			 
afd9					if DEBUG_FORTH_WORDS 
afd9						DMARK "DO4" 
afd9 f5				push af  
afda 3a ee af			ld a, (.dmark)  
afdd 32 6b ee			ld (debug_mark),a  
afe0 3a ef af			ld a, (.dmark+1)  
afe3 32 6c ee			ld (debug_mark+1),a  
afe6 3a f0 af			ld a, (.dmark+2)  
afe9 32 6d ee			ld (debug_mark+2),a  
afec 18 03			jr .pastdmark  
afee ..			.dmark: db "DO4"  
aff1 f1			.pastdmark: pop af  
aff2			endm  
# End of macro DMARK
aff2						CALLMONITOR 
aff2 cd 6f ee			call debug_vector  
aff5				endm  
# End of macro CALLMONITOR
aff5					endif 
aff5					FORTH_DSP_POP 
aff5 cd e9 9d			call macro_forth_dsp_pop 
aff8				endm 
# End of macro FORTH_DSP_POP
aff8			 
aff8					if DEBUG_FORTH_WORDS 
aff8						DMARK "DO5" 
aff8 f5				push af  
aff9 3a 0d b0			ld a, (.dmark)  
affc 32 6b ee			ld (debug_mark),a  
afff 3a 0e b0			ld a, (.dmark+1)  
b002 32 6c ee			ld (debug_mark+1),a  
b005 3a 0f b0			ld a, (.dmark+2)  
b008 32 6d ee			ld (debug_mark+2),a  
b00b 18 03			jr .pastdmark  
b00d ..			.dmark: db "DO5"  
b010 f1			.pastdmark: pop af  
b011			endm  
# End of macro DMARK
b011						CALLMONITOR 
b011 cd 6f ee			call debug_vector  
b014				endm  
# End of macro CALLMONITOR
b014					endif 
b014			 
b014					FORTH_DSP_VALUEHL 
b014 cd 31 9d			call macro_dsp_valuehl 
b017				endm 
# End of macro FORTH_DSP_VALUEHL
b017			;		push hl		 ; hl now has starting limit counter 
b017			 
b017					if DEBUG_FORTH_WORDS 
b017						DMARK "DO6" 
b017 f5				push af  
b018 3a 2c b0			ld a, (.dmark)  
b01b 32 6b ee			ld (debug_mark),a  
b01e 3a 2d b0			ld a, (.dmark+1)  
b021 32 6c ee			ld (debug_mark+1),a  
b024 3a 2e b0			ld a, (.dmark+2)  
b027 32 6d ee			ld (debug_mark+2),a  
b02a 18 03			jr .pastdmark  
b02c ..			.dmark: db "DO6"  
b02f f1			.pastdmark: pop af  
b030			endm  
# End of macro DMARK
b030						CALLMONITOR 
b030 cd 6f ee			call debug_vector  
b033				endm  
# End of macro CALLMONITOR
b033					endif 
b033					FORTH_DSP_POP 
b033 cd e9 9d			call macro_forth_dsp_pop 
b036				endm 
# End of macro FORTH_DSP_POP
b036			 
b036			; put counters on the loop stack 
b036			 
b036			;		pop hl			 ; limit counter 
b036 d1					pop de			; start counter 
b037			 
b037					; push limit counter 
b037			 
b037					if DEBUG_FORTH_WORDS 
b037						DMARK "DO7" 
b037 f5				push af  
b038 3a 4c b0			ld a, (.dmark)  
b03b 32 6b ee			ld (debug_mark),a  
b03e 3a 4d b0			ld a, (.dmark+1)  
b041 32 6c ee			ld (debug_mark+1),a  
b044 3a 4e b0			ld a, (.dmark+2)  
b047 32 6d ee			ld (debug_mark+2),a  
b04a 18 03			jr .pastdmark  
b04c ..			.dmark: db "DO7"  
b04f f1			.pastdmark: pop af  
b050			endm  
# End of macro DMARK
b050						CALLMONITOR 
b050 cd 6f ee			call debug_vector  
b053				endm  
# End of macro CALLMONITOR
b053					endif 
b053					FORTH_LOOP_NEXT 
b053 cd 62 9d			call macro_forth_loop_next 
b056				endm 
# End of macro FORTH_LOOP_NEXT
b056			 
b056					; push start counter 
b056			 
b056 eb					ex de, hl 
b057					if DEBUG_FORTH_WORDS 
b057						DMARK "DO7" 
b057 f5				push af  
b058 3a 6c b0			ld a, (.dmark)  
b05b 32 6b ee			ld (debug_mark),a  
b05e 3a 6d b0			ld a, (.dmark+1)  
b061 32 6c ee			ld (debug_mark+1),a  
b064 3a 6e b0			ld a, (.dmark+2)  
b067 32 6d ee			ld (debug_mark+2),a  
b06a 18 03			jr .pastdmark  
b06c ..			.dmark: db "DO7"  
b06f f1			.pastdmark: pop af  
b070			endm  
# End of macro DMARK
b070						CALLMONITOR 
b070 cd 6f ee			call debug_vector  
b073				endm  
# End of macro CALLMONITOR
b073					endif 
b073					FORTH_LOOP_NEXT 
b073 cd 62 9d			call macro_forth_loop_next 
b076				endm 
# End of macro FORTH_LOOP_NEXT
b076			 
b076			 
b076					; init first round of I counter 
b076			 
b076 22 e6 e5				ld (os_current_i), hl 
b079			 
b079					if DEBUG_FORTH_WORDS 
b079						DMARK "DO8" 
b079 f5				push af  
b07a 3a 8e b0			ld a, (.dmark)  
b07d 32 6b ee			ld (debug_mark),a  
b080 3a 8f b0			ld a, (.dmark+1)  
b083 32 6c ee			ld (debug_mark+1),a  
b086 3a 90 b0			ld a, (.dmark+2)  
b089 32 6d ee			ld (debug_mark+2),a  
b08c 18 03			jr .pastdmark  
b08e ..			.dmark: db "DO8"  
b091 f1			.pastdmark: pop af  
b092			endm  
# End of macro DMARK
b092						CALLMONITOR 
b092 cd 6f ee			call debug_vector  
b095				endm  
# End of macro CALLMONITOR
b095					endif 
b095			 
b095					NEXTW 
b095 c3 e7 9e			jp macro_next 
b098				endm 
# End of macro NEXTW
b098			.LOOP: 
b098				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
b098 22				db WORD_SYS_CORE+14             
b099 b0 b1			dw .I            
b09b 05				db 4 + 1 
b09c .. 00			db "LOOP",0              
b0a1				endm 
# End of macro CWHEAD
b0a1			; | LOOP ( -- ) Increment and test loop counter  | DONE 
b0a1			 
b0a1				; pop tos as current loop count to hl 
b0a1			 
b0a1				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b0a1			 
b0a1				FORTH_LOOP_TOS 
b0a1 cd 95 9d			call macro_forth_loop_tos 
b0a4				endm 
# End of macro FORTH_LOOP_TOS
b0a4 e5				push hl 
b0a5			 
b0a5					if DEBUG_FORTH_WORDS_KEY 
b0a5						DMARK "LOP" 
b0a5 f5				push af  
b0a6 3a ba b0			ld a, (.dmark)  
b0a9 32 6b ee			ld (debug_mark),a  
b0ac 3a bb b0			ld a, (.dmark+1)  
b0af 32 6c ee			ld (debug_mark+1),a  
b0b2 3a bc b0			ld a, (.dmark+2)  
b0b5 32 6d ee			ld (debug_mark+2),a  
b0b8 18 03			jr .pastdmark  
b0ba ..			.dmark: db "LOP"  
b0bd f1			.pastdmark: pop af  
b0be			endm  
# End of macro DMARK
b0be						CALLMONITOR 
b0be cd 6f ee			call debug_vector  
b0c1				endm  
# End of macro CALLMONITOR
b0c1					endif 
b0c1				; next item on the stack is the limit. get it 
b0c1			 
b0c1			 
b0c1				FORTH_LOOP_POP 
b0c1 cd 9f 9d			call macro_forth_loop_pop 
b0c4				endm 
# End of macro FORTH_LOOP_POP
b0c4			 
b0c4				FORTH_LOOP_TOS 
b0c4 cd 95 9d			call macro_forth_loop_tos 
b0c7				endm 
# End of macro FORTH_LOOP_TOS
b0c7			 
b0c7 d1				pop de		 ; de = i, hl = limit 
b0c8			 
b0c8					if DEBUG_FORTH_WORDS 
b0c8						DMARK "LP1" 
b0c8 f5				push af  
b0c9 3a dd b0			ld a, (.dmark)  
b0cc 32 6b ee			ld (debug_mark),a  
b0cf 3a de b0			ld a, (.dmark+1)  
b0d2 32 6c ee			ld (debug_mark+1),a  
b0d5 3a df b0			ld a, (.dmark+2)  
b0d8 32 6d ee			ld (debug_mark+2),a  
b0db 18 03			jr .pastdmark  
b0dd ..			.dmark: db "LP1"  
b0e0 f1			.pastdmark: pop af  
b0e1			endm  
# End of macro DMARK
b0e1						CALLMONITOR 
b0e1 cd 6f ee			call debug_vector  
b0e4				endm  
# End of macro CALLMONITOR
b0e4					endif 
b0e4			 
b0e4				; go back to previous word 
b0e4			 
b0e4 d5				push de    ; save I for inc later 
b0e5			 
b0e5			 
b0e5				; get limit 
b0e5				;  is I at limit? 
b0e5			 
b0e5			 
b0e5					if DEBUG_FORTH_WORDS 
b0e5						DMARK "LP1" 
b0e5 f5				push af  
b0e6 3a fa b0			ld a, (.dmark)  
b0e9 32 6b ee			ld (debug_mark),a  
b0ec 3a fb b0			ld a, (.dmark+1)  
b0ef 32 6c ee			ld (debug_mark+1),a  
b0f2 3a fc b0			ld a, (.dmark+2)  
b0f5 32 6d ee			ld (debug_mark+2),a  
b0f8 18 03			jr .pastdmark  
b0fa ..			.dmark: db "LP1"  
b0fd f1			.pastdmark: pop af  
b0fe			endm  
# End of macro DMARK
b0fe						CALLMONITOR 
b0fe cd 6f ee			call debug_vector  
b101				endm  
# End of macro CALLMONITOR
b101					endif 
b101			 
b101 ed 52			sbc hl, de 
b103			 
b103			 
b103				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b103			 
b103 20 26				jr nz, .loopnotdone 
b105			 
b105 e1				pop hl   ; get rid of saved I 
b106				FORTH_LOOP_POP     ; get rid of limit 
b106 cd 9f 9d			call macro_forth_loop_pop 
b109				endm 
# End of macro FORTH_LOOP_POP
b109			 
b109				FORTH_RSP_POP     ; get rid of DO ptr 
b109 cd 02 9b			call macro_forth_rsp_pop 
b10c				endm 
# End of macro FORTH_RSP_POP
b10c			 
b10c			if DEBUG_FORTH_WORDS 
b10c						DMARK "LP>" 
b10c f5				push af  
b10d 3a 21 b1			ld a, (.dmark)  
b110 32 6b ee			ld (debug_mark),a  
b113 3a 22 b1			ld a, (.dmark+1)  
b116 32 6c ee			ld (debug_mark+1),a  
b119 3a 23 b1			ld a, (.dmark+2)  
b11c 32 6d ee			ld (debug_mark+2),a  
b11f 18 03			jr .pastdmark  
b121 ..			.dmark: db "LP>"  
b124 f1			.pastdmark: pop af  
b125			endm  
# End of macro DMARK
b125				CALLMONITOR 
b125 cd 6f ee			call debug_vector  
b128				endm  
# End of macro CALLMONITOR
b128			endif 
b128			 
b128					NEXTW 
b128 c3 e7 9e			jp macro_next 
b12b				endm 
# End of macro NEXTW
b12b				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b12b			 
b12b			.loopnotdone: 
b12b			 
b12b e1				pop hl    ; get I 
b12c 23				inc hl 
b12d			 
b12d			   	; save new I 
b12d			 
b12d			 
b12d					; set I counter 
b12d			 
b12d 22 e6 e5				ld (os_current_i), hl 
b130			 
b130					if DEBUG_FORTH_WORDS 
b130						DMARK "LPN" 
b130 f5				push af  
b131 3a 45 b1			ld a, (.dmark)  
b134 32 6b ee			ld (debug_mark),a  
b137 3a 46 b1			ld a, (.dmark+1)  
b13a 32 6c ee			ld (debug_mark+1),a  
b13d 3a 47 b1			ld a, (.dmark+2)  
b140 32 6d ee			ld (debug_mark+2),a  
b143 18 03			jr .pastdmark  
b145 ..			.dmark: db "LPN"  
b148 f1			.pastdmark: pop af  
b149			endm  
# End of macro DMARK
b149					CALLMONITOR 
b149 cd 6f ee			call debug_vector  
b14c				endm  
# End of macro CALLMONITOR
b14c					endif 
b14c					 
b14c				FORTH_LOOP_NEXT 
b14c cd 62 9d			call macro_forth_loop_next 
b14f				endm 
# End of macro FORTH_LOOP_NEXT
b14f			 
b14f			 
b14f					if DEBUG_FORTH_WORDS 
b14f eb						ex de,hl 
b150					endif 
b150			 
b150			;	; get DO ptr 
b150			; 
b150					if DEBUG_FORTH_WORDS 
b150						DMARK "LP7" 
b150 f5				push af  
b151 3a 65 b1			ld a, (.dmark)  
b154 32 6b ee			ld (debug_mark),a  
b157 3a 66 b1			ld a, (.dmark+1)  
b15a 32 6c ee			ld (debug_mark+1),a  
b15d 3a 67 b1			ld a, (.dmark+2)  
b160 32 6d ee			ld (debug_mark+2),a  
b163 18 03			jr .pastdmark  
b165 ..			.dmark: db "LP7"  
b168 f1			.pastdmark: pop af  
b169			endm  
# End of macro DMARK
b169					CALLMONITOR 
b169 cd 6f ee			call debug_vector  
b16c				endm  
# End of macro CALLMONITOR
b16c					endif 
b16c				FORTH_RSP_TOS 
b16c cd f8 9a			call macro_forth_rsp_tos 
b16f				endm 
# End of macro FORTH_RSP_TOS
b16f			 
b16f					if DEBUG_FORTH_WORDS 
b16f						DMARK "LP8" 
b16f f5				push af  
b170 3a 84 b1			ld a, (.dmark)  
b173 32 6b ee			ld (debug_mark),a  
b176 3a 85 b1			ld a, (.dmark+1)  
b179 32 6c ee			ld (debug_mark+1),a  
b17c 3a 86 b1			ld a, (.dmark+2)  
b17f 32 6d ee			ld (debug_mark+2),a  
b182 18 03			jr .pastdmark  
b184 ..			.dmark: db "LP8"  
b187 f1			.pastdmark: pop af  
b188			endm  
# End of macro DMARK
b188					CALLMONITOR 
b188 cd 6f ee			call debug_vector  
b18b				endm  
# End of macro CALLMONITOR
b18b					endif 
b18b				;push hl 
b18b			 
b18b				; not going to DO any more 
b18b				; get rid of the RSP pointer as DO will add it back in 
b18b				;FORTH_RSP_POP 
b18b				;pop hl 
b18b			 
b18b				;ld hl,(cli_ret_sp) 
b18b				;ld e, (hl) 
b18b				;inc hl 
b18b				;ld d, (hl) 
b18b				;ex de,hl 
b18b 22 c2 e5			ld (os_tok_ptr), hl 
b18e					if DEBUG_FORTH_WORDS 
b18e						DMARK "LP<" 
b18e f5				push af  
b18f 3a a3 b1			ld a, (.dmark)  
b192 32 6b ee			ld (debug_mark),a  
b195 3a a4 b1			ld a, (.dmark+1)  
b198 32 6c ee			ld (debug_mark+1),a  
b19b 3a a5 b1			ld a, (.dmark+2)  
b19e 32 6d ee			ld (debug_mark+2),a  
b1a1 18 03			jr .pastdmark  
b1a3 ..			.dmark: db "LP<"  
b1a6 f1			.pastdmark: pop af  
b1a7			endm  
# End of macro DMARK
b1a7					CALLMONITOR 
b1a7 cd 6f ee			call debug_vector  
b1aa				endm  
# End of macro CALLMONITOR
b1aa				endif 
b1aa c3 78 9f			jp exec1 
b1ad			 
b1ad					 
b1ad			 
b1ad			 
b1ad					NEXTW 
b1ad c3 e7 9e			jp macro_next 
b1b0				endm 
# End of macro NEXTW
b1b0			.I:  
b1b0			 
b1b0				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b1b0 5e				db WORD_SYS_CORE+74             
b1b1 db b1			dw .DLOOP            
b1b3 02				db 1 + 1 
b1b4 .. 00			db "I",0              
b1b6				endm 
# End of macro CWHEAD
b1b6			; | I ( -- ) Current loop counter | DONE 
b1b6					if DEBUG_FORTH_WORDS_KEY 
b1b6						DMARK "I.." 
b1b6 f5				push af  
b1b7 3a cb b1			ld a, (.dmark)  
b1ba 32 6b ee			ld (debug_mark),a  
b1bd 3a cc b1			ld a, (.dmark+1)  
b1c0 32 6c ee			ld (debug_mark+1),a  
b1c3 3a cd b1			ld a, (.dmark+2)  
b1c6 32 6d ee			ld (debug_mark+2),a  
b1c9 18 03			jr .pastdmark  
b1cb ..			.dmark: db "I.."  
b1ce f1			.pastdmark: pop af  
b1cf			endm  
# End of macro DMARK
b1cf						CALLMONITOR 
b1cf cd 6f ee			call debug_vector  
b1d2				endm  
# End of macro CALLMONITOR
b1d2					endif 
b1d2			 
b1d2 2a e6 e5				ld hl,(os_current_i) 
b1d5 cd 3a 9b				call forth_push_numhl 
b1d8			 
b1d8					NEXTW 
b1d8 c3 e7 9e			jp macro_next 
b1db				endm 
# End of macro NEXTW
b1db			.DLOOP: 
b1db				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b1db 5f				db WORD_SYS_CORE+75             
b1dc bc b2			dw .REPEAT            
b1de 06				db 5 + 1 
b1df .. 00			db "-LOOP",0              
b1e5				endm 
# End of macro CWHEAD
b1e5			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b1e5				; pop tos as current loop count to hl 
b1e5					if DEBUG_FORTH_WORDS_KEY 
b1e5						DMARK "-LP" 
b1e5 f5				push af  
b1e6 3a fa b1			ld a, (.dmark)  
b1e9 32 6b ee			ld (debug_mark),a  
b1ec 3a fb b1			ld a, (.dmark+1)  
b1ef 32 6c ee			ld (debug_mark+1),a  
b1f2 3a fc b1			ld a, (.dmark+2)  
b1f5 32 6d ee			ld (debug_mark+2),a  
b1f8 18 03			jr .pastdmark  
b1fa ..			.dmark: db "-LP"  
b1fd f1			.pastdmark: pop af  
b1fe			endm  
# End of macro DMARK
b1fe						CALLMONITOR 
b1fe cd 6f ee			call debug_vector  
b201				endm  
# End of macro CALLMONITOR
b201					endif 
b201			 
b201				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b201			 
b201				FORTH_LOOP_TOS 
b201 cd 95 9d			call macro_forth_loop_tos 
b204				endm 
# End of macro FORTH_LOOP_TOS
b204 e5				push hl 
b205			 
b205					if DEBUG_FORTH_WORDS 
b205						DMARK "-LP" 
b205 f5				push af  
b206 3a 1a b2			ld a, (.dmark)  
b209 32 6b ee			ld (debug_mark),a  
b20c 3a 1b b2			ld a, (.dmark+1)  
b20f 32 6c ee			ld (debug_mark+1),a  
b212 3a 1c b2			ld a, (.dmark+2)  
b215 32 6d ee			ld (debug_mark+2),a  
b218 18 03			jr .pastdmark  
b21a ..			.dmark: db "-LP"  
b21d f1			.pastdmark: pop af  
b21e			endm  
# End of macro DMARK
b21e						CALLMONITOR 
b21e cd 6f ee			call debug_vector  
b221				endm  
# End of macro CALLMONITOR
b221					endif 
b221				; next item on the stack is the limit. get it 
b221			 
b221			 
b221				FORTH_LOOP_POP 
b221 cd 9f 9d			call macro_forth_loop_pop 
b224				endm 
# End of macro FORTH_LOOP_POP
b224			 
b224				FORTH_LOOP_TOS 
b224 cd 95 9d			call macro_forth_loop_tos 
b227				endm 
# End of macro FORTH_LOOP_TOS
b227			 
b227 d1				pop de		 ; de = i, hl = limit 
b228			 
b228					if DEBUG_FORTH_WORDS 
b228						DMARK "-L1" 
b228 f5				push af  
b229 3a 3d b2			ld a, (.dmark)  
b22c 32 6b ee			ld (debug_mark),a  
b22f 3a 3e b2			ld a, (.dmark+1)  
b232 32 6c ee			ld (debug_mark+1),a  
b235 3a 3f b2			ld a, (.dmark+2)  
b238 32 6d ee			ld (debug_mark+2),a  
b23b 18 03			jr .pastdmark  
b23d ..			.dmark: db "-L1"  
b240 f1			.pastdmark: pop af  
b241			endm  
# End of macro DMARK
b241						CALLMONITOR 
b241 cd 6f ee			call debug_vector  
b244				endm  
# End of macro CALLMONITOR
b244					endif 
b244			 
b244				; go back to previous word 
b244			 
b244 d5				push de    ; save I for inc later 
b245			 
b245			 
b245				; get limit 
b245				;  is I at limit? 
b245			 
b245			 
b245					if DEBUG_FORTH_WORDS 
b245						DMARK "-L1" 
b245 f5				push af  
b246 3a 5a b2			ld a, (.dmark)  
b249 32 6b ee			ld (debug_mark),a  
b24c 3a 5b b2			ld a, (.dmark+1)  
b24f 32 6c ee			ld (debug_mark+1),a  
b252 3a 5c b2			ld a, (.dmark+2)  
b255 32 6d ee			ld (debug_mark+2),a  
b258 18 03			jr .pastdmark  
b25a ..			.dmark: db "-L1"  
b25d f1			.pastdmark: pop af  
b25e			endm  
# End of macro DMARK
b25e						CALLMONITOR 
b25e cd 6f ee			call debug_vector  
b261				endm  
# End of macro CALLMONITOR
b261					endif 
b261			 
b261 ed 52			sbc hl, de 
b263			 
b263			 
b263				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b263			 
b263 20 26				jr nz, .mloopnotdone 
b265			 
b265 e1				pop hl   ; get rid of saved I 
b266				FORTH_LOOP_POP     ; get rid of limit 
b266 cd 9f 9d			call macro_forth_loop_pop 
b269				endm 
# End of macro FORTH_LOOP_POP
b269			 
b269				FORTH_RSP_POP     ; get rid of DO ptr 
b269 cd 02 9b			call macro_forth_rsp_pop 
b26c				endm 
# End of macro FORTH_RSP_POP
b26c			 
b26c			if DEBUG_FORTH_WORDS 
b26c						DMARK "-L>" 
b26c f5				push af  
b26d 3a 81 b2			ld a, (.dmark)  
b270 32 6b ee			ld (debug_mark),a  
b273 3a 82 b2			ld a, (.dmark+1)  
b276 32 6c ee			ld (debug_mark+1),a  
b279 3a 83 b2			ld a, (.dmark+2)  
b27c 32 6d ee			ld (debug_mark+2),a  
b27f 18 03			jr .pastdmark  
b281 ..			.dmark: db "-L>"  
b284 f1			.pastdmark: pop af  
b285			endm  
# End of macro DMARK
b285				CALLMONITOR 
b285 cd 6f ee			call debug_vector  
b288				endm  
# End of macro CALLMONITOR
b288			endif 
b288			 
b288					NEXTW 
b288 c3 e7 9e			jp macro_next 
b28b				endm 
# End of macro NEXTW
b28b				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b28b			 
b28b			.mloopnotdone: 
b28b			 
b28b e1				pop hl    ; get I 
b28c 2b				dec hl 
b28d			 
b28d			   	; save new I 
b28d			 
b28d			 
b28d					; set I counter 
b28d			 
b28d 22 e6 e5				ld (os_current_i), hl 
b290			 
b290					 
b290				FORTH_LOOP_NEXT 
b290 cd 62 9d			call macro_forth_loop_next 
b293				endm 
# End of macro FORTH_LOOP_NEXT
b293			 
b293			 
b293					if DEBUG_FORTH_WORDS 
b293 eb						ex de,hl 
b294					endif 
b294			 
b294			;	; get DO ptr 
b294			; 
b294				FORTH_RSP_TOS 
b294 cd f8 9a			call macro_forth_rsp_tos 
b297				endm 
# End of macro FORTH_RSP_TOS
b297			 
b297				;push hl 
b297			 
b297				; not going to DO any more 
b297				; get rid of the RSP pointer as DO will add it back in 
b297				;FORTH_RSP_POP 
b297				;pop hl 
b297			 
b297			 
b297 22 c2 e5			ld (os_tok_ptr), hl 
b29a					if DEBUG_FORTH_WORDS 
b29a						DMARK "-L<" 
b29a f5				push af  
b29b 3a af b2			ld a, (.dmark)  
b29e 32 6b ee			ld (debug_mark),a  
b2a1 3a b0 b2			ld a, (.dmark+1)  
b2a4 32 6c ee			ld (debug_mark+1),a  
b2a7 3a b1 b2			ld a, (.dmark+2)  
b2aa 32 6d ee			ld (debug_mark+2),a  
b2ad 18 03			jr .pastdmark  
b2af ..			.dmark: db "-L<"  
b2b2 f1			.pastdmark: pop af  
b2b3			endm  
# End of macro DMARK
b2b3					CALLMONITOR 
b2b3 cd 6f ee			call debug_vector  
b2b6				endm  
# End of macro CALLMONITOR
b2b6				endif 
b2b6 c3 78 9f			jp exec1 
b2b9			 
b2b9					 
b2b9			 
b2b9			 
b2b9			 
b2b9				NEXTW 
b2b9 c3 e7 9e			jp macro_next 
b2bc				endm 
# End of macro NEXTW
b2bc			 
b2bc			 
b2bc			 
b2bc			 
b2bc			.REPEAT: 
b2bc				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b2bc 71				db WORD_SYS_CORE+93             
b2bd 0f b3			dw .UNTIL            
b2bf 06				db 5 + 1 
b2c0 .. 00			db "REPEAT",0              
b2c7				endm 
# End of macro CWHEAD
b2c7			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b2c7			;  push pc to rsp stack past the REPEAT 
b2c7					if DEBUG_FORTH_WORDS_KEY 
b2c7						DMARK "REP" 
b2c7 f5				push af  
b2c8 3a dc b2			ld a, (.dmark)  
b2cb 32 6b ee			ld (debug_mark),a  
b2ce 3a dd b2			ld a, (.dmark+1)  
b2d1 32 6c ee			ld (debug_mark+1),a  
b2d4 3a de b2			ld a, (.dmark+2)  
b2d7 32 6d ee			ld (debug_mark+2),a  
b2da 18 03			jr .pastdmark  
b2dc ..			.dmark: db "REP"  
b2df f1			.pastdmark: pop af  
b2e0			endm  
# End of macro DMARK
b2e0						CALLMONITOR 
b2e0 cd 6f ee			call debug_vector  
b2e3				endm  
# End of macro CALLMONITOR
b2e3					endif 
b2e3			 
b2e3 2a c2 e5				ld hl, (os_tok_ptr) 
b2e6 23					inc hl   ; R 
b2e7 23					inc hl  ; E 
b2e8 23					inc hl   ; P 
b2e9 23					inc hl   ; E 
b2ea 23					inc hl   ; A 
b2eb 23					inc hl   ; T 
b2ec 23					inc hl   ; zero 
b2ed					FORTH_RSP_NEXT 
b2ed cd e1 9a			call macro_forth_rsp_next 
b2f0				endm 
# End of macro FORTH_RSP_NEXT
b2f0			 
b2f0			 
b2f0					if DEBUG_FORTH_WORDS 
b2f0						DMARK "REP" 
b2f0 f5				push af  
b2f1 3a 05 b3			ld a, (.dmark)  
b2f4 32 6b ee			ld (debug_mark),a  
b2f7 3a 06 b3			ld a, (.dmark+1)  
b2fa 32 6c ee			ld (debug_mark+1),a  
b2fd 3a 07 b3			ld a, (.dmark+2)  
b300 32 6d ee			ld (debug_mark+2),a  
b303 18 03			jr .pastdmark  
b305 ..			.dmark: db "REP"  
b308 f1			.pastdmark: pop af  
b309			endm  
# End of macro DMARK
b309						;pop bc    ; TODO BUG ?????? what is this for???? 
b309						CALLMONITOR 
b309 cd 6f ee			call debug_vector  
b30c				endm  
# End of macro CALLMONITOR
b30c					endif 
b30c			 
b30c					NEXTW 
b30c c3 e7 9e			jp macro_next 
b30f				endm 
# End of macro NEXTW
b30f			;	       NEXTW 
b30f			 
b30f			.UNTIL: 
b30f				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b30f 72				db WORD_SYS_CORE+94             
b310 a6 b3			dw .ENDFLOW            
b312 06				db 5 + 1 
b313 .. 00			db "UNTIL",0              
b319				endm 
# End of macro CWHEAD
b319			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b319			 
b319				; pop tos as check 
b319			 
b319				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b319			 
b319				FORTH_DSP_VALUEHL 
b319 cd 31 9d			call macro_dsp_valuehl 
b31c				endm 
# End of macro FORTH_DSP_VALUEHL
b31c			 
b31c					if DEBUG_FORTH_WORDS_KEY 
b31c						DMARK "UNT" 
b31c f5				push af  
b31d 3a 31 b3			ld a, (.dmark)  
b320 32 6b ee			ld (debug_mark),a  
b323 3a 32 b3			ld a, (.dmark+1)  
b326 32 6c ee			ld (debug_mark+1),a  
b329 3a 33 b3			ld a, (.dmark+2)  
b32c 32 6d ee			ld (debug_mark+2),a  
b32f 18 03			jr .pastdmark  
b331 ..			.dmark: db "UNT"  
b334 f1			.pastdmark: pop af  
b335			endm  
# End of macro DMARK
b335						CALLMONITOR 
b335 cd 6f ee			call debug_vector  
b338				endm  
# End of macro CALLMONITOR
b338					endif 
b338			 
b338			;	push hl 
b338				FORTH_DSP_POP 
b338 cd e9 9d			call macro_forth_dsp_pop 
b33b				endm 
# End of macro FORTH_DSP_POP
b33b			 
b33b			;	pop hl 
b33b			 
b33b				; test if true 
b33b			 
b33b cd 05 8d			call ishlzero 
b33e			;	ld a,l 
b33e			;	add h 
b33e			; 
b33e			;	cp 0 
b33e			 
b33e 20 3e			jr nz, .untilnotdone 
b340			 
b340					if DEBUG_FORTH_WORDS 
b340						DMARK "UNf" 
b340 f5				push af  
b341 3a 55 b3			ld a, (.dmark)  
b344 32 6b ee			ld (debug_mark),a  
b347 3a 56 b3			ld a, (.dmark+1)  
b34a 32 6c ee			ld (debug_mark+1),a  
b34d 3a 57 b3			ld a, (.dmark+2)  
b350 32 6d ee			ld (debug_mark+2),a  
b353 18 03			jr .pastdmark  
b355 ..			.dmark: db "UNf"  
b358 f1			.pastdmark: pop af  
b359			endm  
# End of macro DMARK
b359						CALLMONITOR 
b359 cd 6f ee			call debug_vector  
b35c				endm  
# End of macro CALLMONITOR
b35c					endif 
b35c			 
b35c			 
b35c			 
b35c				FORTH_RSP_POP     ; get rid of DO ptr 
b35c cd 02 9b			call macro_forth_rsp_pop 
b35f				endm 
# End of macro FORTH_RSP_POP
b35f			 
b35f			if DEBUG_FORTH_WORDS 
b35f						DMARK "UN>" 
b35f f5				push af  
b360 3a 74 b3			ld a, (.dmark)  
b363 32 6b ee			ld (debug_mark),a  
b366 3a 75 b3			ld a, (.dmark+1)  
b369 32 6c ee			ld (debug_mark+1),a  
b36c 3a 76 b3			ld a, (.dmark+2)  
b36f 32 6d ee			ld (debug_mark+2),a  
b372 18 03			jr .pastdmark  
b374 ..			.dmark: db "UN>"  
b377 f1			.pastdmark: pop af  
b378			endm  
# End of macro DMARK
b378				CALLMONITOR 
b378 cd 6f ee			call debug_vector  
b37b				endm  
# End of macro CALLMONITOR
b37b			endif 
b37b			 
b37b					NEXTW 
b37b c3 e7 9e			jp macro_next 
b37e				endm 
# End of macro NEXTW
b37e				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b37e			 
b37e			.untilnotdone: 
b37e			 
b37e			 
b37e			;	; get DO ptr 
b37e			; 
b37e				FORTH_RSP_TOS 
b37e cd f8 9a			call macro_forth_rsp_tos 
b381				endm 
# End of macro FORTH_RSP_TOS
b381			 
b381				;push hl 
b381			 
b381				; not going to DO any more 
b381				; get rid of the RSP pointer as DO will add it back in 
b381				;FORTH_RSP_POP 
b381				;pop hl 
b381			 
b381			 
b381 22 c2 e5			ld (os_tok_ptr), hl 
b384					if DEBUG_FORTH_WORDS 
b384						DMARK "UN<" 
b384 f5				push af  
b385 3a 99 b3			ld a, (.dmark)  
b388 32 6b ee			ld (debug_mark),a  
b38b 3a 9a b3			ld a, (.dmark+1)  
b38e 32 6c ee			ld (debug_mark+1),a  
b391 3a 9b b3			ld a, (.dmark+2)  
b394 32 6d ee			ld (debug_mark+2),a  
b397 18 03			jr .pastdmark  
b399 ..			.dmark: db "UN<"  
b39c f1			.pastdmark: pop af  
b39d			endm  
# End of macro DMARK
b39d					CALLMONITOR 
b39d cd 6f ee			call debug_vector  
b3a0				endm  
# End of macro CALLMONITOR
b3a0				endif 
b3a0 c3 78 9f			jp exec1 
b3a3			 
b3a3					 
b3a3			 
b3a3			 
b3a3					NEXTW 
b3a3 c3 e7 9e			jp macro_next 
b3a6				endm 
# End of macro NEXTW
b3a6			 
b3a6			 
b3a6			.ENDFLOW: 
b3a6			 
b3a6			; eof 
b3a6			 
# End of file forth_words_flow.asm
b3a6			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b3a6			include "forth_words_logic.asm" 
b3a6			 
b3a6			; | ## Logic Words 
b3a6			 
b3a6			.NOT: 
b3a6				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b3a6 2d				db WORD_SYS_CORE+25             
b3a7 ee b3			dw .IS            
b3a9 04				db 3 + 1 
b3aa .. 00			db "NOT",0              
b3ae				endm 
# End of macro CWHEAD
b3ae			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b3ae					if DEBUG_FORTH_WORDS_KEY 
b3ae						DMARK "NOT" 
b3ae f5				push af  
b3af 3a c3 b3			ld a, (.dmark)  
b3b2 32 6b ee			ld (debug_mark),a  
b3b5 3a c4 b3			ld a, (.dmark+1)  
b3b8 32 6c ee			ld (debug_mark+1),a  
b3bb 3a c5 b3			ld a, (.dmark+2)  
b3be 32 6d ee			ld (debug_mark+2),a  
b3c1 18 03			jr .pastdmark  
b3c3 ..			.dmark: db "NOT"  
b3c6 f1			.pastdmark: pop af  
b3c7			endm  
# End of macro DMARK
b3c7						CALLMONITOR 
b3c7 cd 6f ee			call debug_vector  
b3ca				endm  
# End of macro CALLMONITOR
b3ca					endif 
b3ca					FORTH_DSP 
b3ca cd f7 9c			call macro_forth_dsp 
b3cd				endm 
# End of macro FORTH_DSP
b3cd 7e					ld a,(hl)	; get type of value on TOS 
b3ce fe 02				cp DS_TYPE_INUM  
b3d0 28 03				jr z, .noti 
b3d2					NEXTW 
b3d2 c3 e7 9e			jp macro_next 
b3d5				endm 
# End of macro NEXTW
b3d5			.noti:          FORTH_DSP_VALUEHL 
b3d5 cd 31 9d			call macro_dsp_valuehl 
b3d8				endm 
# End of macro FORTH_DSP_VALUEHL
b3d8			;		push hl 
b3d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3d8 cd e9 9d			call macro_forth_dsp_pop 
b3db				endm 
# End of macro FORTH_DSP_POP
b3db			;		pop hl 
b3db 3e 00				ld a,0 
b3dd bd					cp l 
b3de 28 04				jr z, .not2t 
b3e0 2e 00				ld l, 0 
b3e2 18 02				jr .notip 
b3e4			 
b3e4 2e ff		.not2t:		ld l, 255 
b3e6			 
b3e6 26 00		.notip:		ld h, 0	 
b3e8			 
b3e8 cd 3a 9b				call forth_push_numhl 
b3eb					NEXTW 
b3eb c3 e7 9e			jp macro_next 
b3ee				endm 
# End of macro NEXTW
b3ee			 
b3ee			.IS: 
b3ee				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b3ee 2d				db WORD_SYS_CORE+25             
b3ef 14 b4			dw .LZERO            
b3f1 03				db 2 + 1 
b3f2 .. 00			db "IS",0              
b3f5				endm 
# End of macro CWHEAD
b3f5			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b3f5					if DEBUG_FORTH_WORDS_KEY 
b3f5						DMARK "IS." 
b3f5 f5				push af  
b3f6 3a 0a b4			ld a, (.dmark)  
b3f9 32 6b ee			ld (debug_mark),a  
b3fc 3a 0b b4			ld a, (.dmark+1)  
b3ff 32 6c ee			ld (debug_mark+1),a  
b402 3a 0c b4			ld a, (.dmark+2)  
b405 32 6d ee			ld (debug_mark+2),a  
b408 18 03			jr .pastdmark  
b40a ..			.dmark: db "IS."  
b40d f1			.pastdmark: pop af  
b40e			endm  
# End of macro DMARK
b40e						CALLMONITOR 
b40e cd 6f ee			call debug_vector  
b411				endm  
# End of macro CALLMONITOR
b411					endif 
b411					NEXTW 
b411 c3 e7 9e			jp macro_next 
b414				endm 
# End of macro NEXTW
b414			.LZERO: 
b414				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b414 2d				db WORD_SYS_CORE+25             
b415 1e b4			dw .TZERO            
b417 03				db 2 + 1 
b418 .. 00			db "0<",0              
b41b				endm 
# End of macro CWHEAD
b41b			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b41b					NEXTW 
b41b c3 e7 9e			jp macro_next 
b41e				endm 
# End of macro NEXTW
b41e			.TZERO: 
b41e				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b41e 2e				db WORD_SYS_CORE+26             
b41f 65 b4			dw .LESS            
b421 03				db 2 + 1 
b422 .. 00			db "0=",0              
b425				endm 
# End of macro CWHEAD
b425			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
b425				; TODO add floating point number detection 
b425					;v5 FORTH_DSP_VALUE 
b425					if DEBUG_FORTH_WORDS_KEY 
b425						DMARK "0=." 
b425 f5				push af  
b426 3a 3a b4			ld a, (.dmark)  
b429 32 6b ee			ld (debug_mark),a  
b42c 3a 3b b4			ld a, (.dmark+1)  
b42f 32 6c ee			ld (debug_mark+1),a  
b432 3a 3c b4			ld a, (.dmark+2)  
b435 32 6d ee			ld (debug_mark+2),a  
b438 18 03			jr .pastdmark  
b43a ..			.dmark: db "0=."  
b43d f1			.pastdmark: pop af  
b43e			endm  
# End of macro DMARK
b43e						CALLMONITOR 
b43e cd 6f ee			call debug_vector  
b441				endm  
# End of macro CALLMONITOR
b441					endif 
b441					FORTH_DSP 
b441 cd f7 9c			call macro_forth_dsp 
b444				endm 
# End of macro FORTH_DSP
b444 7e					ld a,(hl)	; get type of value on TOS 
b445 fe 02				cp DS_TYPE_INUM  
b447 28 00				jr z, .tz_inum 
b449			 
b449				if FORTH_ENABLE_FLOATMATH 
b449					jr .tz_done 
b449			 
b449				endif 
b449					 
b449			 
b449			.tz_inum: 
b449					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b449 cd 31 9d			call macro_dsp_valuehl 
b44c				endm 
# End of macro FORTH_DSP_VALUEHL
b44c			 
b44c			;		push hl 
b44c			 
b44c					; destroy value TOS 
b44c			 
b44c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b44c cd e9 9d			call macro_forth_dsp_pop 
b44f				endm 
# End of macro FORTH_DSP_POP
b44f			 
b44f			;		pop hl 
b44f			 
b44f 3e 00				ld a,0 
b451			 
b451 bd					cp l 
b452 20 08				jr nz, .tz_notzero 
b454			 
b454 bc					cp h 
b455			 
b455 20 05				jr nz, .tz_notzero 
b457			 
b457			 
b457 21 01 00				ld hl, FORTH_TRUE 
b45a 18 03				jr .tz_done 
b45c			 
b45c 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b45f			 
b45f					; push value back onto stack for another op etc 
b45f			 
b45f			.tz_done: 
b45f cd 3a 9b				call forth_push_numhl 
b462			 
b462					NEXTW 
b462 c3 e7 9e			jp macro_next 
b465				endm 
# End of macro NEXTW
b465			.LESS: 
b465				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b465 2f				db WORD_SYS_CORE+27             
b466 ce b4			dw .GT            
b468 02				db 1 + 1 
b469 .. 00			db "<",0              
b46b				endm 
# End of macro CWHEAD
b46b			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b46b				; TODO add floating point number detection 
b46b					if DEBUG_FORTH_WORDS_KEY 
b46b						DMARK "LES" 
b46b f5				push af  
b46c 3a 80 b4			ld a, (.dmark)  
b46f 32 6b ee			ld (debug_mark),a  
b472 3a 81 b4			ld a, (.dmark+1)  
b475 32 6c ee			ld (debug_mark+1),a  
b478 3a 82 b4			ld a, (.dmark+2)  
b47b 32 6d ee			ld (debug_mark+2),a  
b47e 18 03			jr .pastdmark  
b480 ..			.dmark: db "LES"  
b483 f1			.pastdmark: pop af  
b484			endm  
# End of macro DMARK
b484						CALLMONITOR 
b484 cd 6f ee			call debug_vector  
b487				endm  
# End of macro CALLMONITOR
b487					endif 
b487					FORTH_DSP 
b487 cd f7 9c			call macro_forth_dsp 
b48a				endm 
# End of macro FORTH_DSP
b48a					;v5 FORTH_DSP_VALUE 
b48a 7e					ld a,(hl)	; get type of value on TOS 
b48b fe 02				cp DS_TYPE_INUM  
b48d 28 00				jr z, .less_inum 
b48f			 
b48f				if FORTH_ENABLE_FLOATMATH 
b48f					jr .less_done 
b48f			 
b48f				endif 
b48f					 
b48f			 
b48f			.less_inum: 
b48f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b48f cd 31 9d			call macro_dsp_valuehl 
b492				endm 
# End of macro FORTH_DSP_VALUEHL
b492			 
b492 e5					push hl  ; u2 
b493			 
b493					; destroy value TOS 
b493			 
b493					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b493 cd e9 9d			call macro_forth_dsp_pop 
b496				endm 
# End of macro FORTH_DSP_POP
b496			 
b496			 
b496					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b496 cd 31 9d			call macro_dsp_valuehl 
b499				endm 
# End of macro FORTH_DSP_VALUEHL
b499			 
b499 e5					push hl    ; u1 
b49a			 
b49a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b49a cd e9 9d			call macro_forth_dsp_pop 
b49d				endm 
# End of macro FORTH_DSP_POP
b49d			 
b49d			 
b49d b7			 or a      ;clear carry flag 
b49e 01 00 00		 ld bc, FORTH_FALSE 
b4a1 e1			  pop hl    ; u1 
b4a2 d1			  pop de    ; u2 
b4a3 ed 52		  sbc hl,de 
b4a5 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b4a7			 
b4a7 01 01 00		 ld bc, FORTH_TRUE 
b4aa			.lscont:  
b4aa c5					push bc 
b4ab e1					pop hl 
b4ac			 
b4ac					if DEBUG_FORTH_WORDS 
b4ac						DMARK "LT1" 
b4ac f5				push af  
b4ad 3a c1 b4			ld a, (.dmark)  
b4b0 32 6b ee			ld (debug_mark),a  
b4b3 3a c2 b4			ld a, (.dmark+1)  
b4b6 32 6c ee			ld (debug_mark+1),a  
b4b9 3a c3 b4			ld a, (.dmark+2)  
b4bc 32 6d ee			ld (debug_mark+2),a  
b4bf 18 03			jr .pastdmark  
b4c1 ..			.dmark: db "LT1"  
b4c4 f1			.pastdmark: pop af  
b4c5			endm  
# End of macro DMARK
b4c5						CALLMONITOR 
b4c5 cd 6f ee			call debug_vector  
b4c8				endm  
# End of macro CALLMONITOR
b4c8					endif 
b4c8 cd 3a 9b				call forth_push_numhl 
b4cb			 
b4cb					NEXTW 
b4cb c3 e7 9e			jp macro_next 
b4ce				endm 
# End of macro NEXTW
b4ce			.GT: 
b4ce				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b4ce 30				db WORD_SYS_CORE+28             
b4cf 37 b5			dw .EQUAL            
b4d1 02				db 1 + 1 
b4d2 .. 00			db ">",0              
b4d4				endm 
# End of macro CWHEAD
b4d4			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b4d4				; TODO add floating point number detection 
b4d4					if DEBUG_FORTH_WORDS_KEY 
b4d4						DMARK "GRT" 
b4d4 f5				push af  
b4d5 3a e9 b4			ld a, (.dmark)  
b4d8 32 6b ee			ld (debug_mark),a  
b4db 3a ea b4			ld a, (.dmark+1)  
b4de 32 6c ee			ld (debug_mark+1),a  
b4e1 3a eb b4			ld a, (.dmark+2)  
b4e4 32 6d ee			ld (debug_mark+2),a  
b4e7 18 03			jr .pastdmark  
b4e9 ..			.dmark: db "GRT"  
b4ec f1			.pastdmark: pop af  
b4ed			endm  
# End of macro DMARK
b4ed						CALLMONITOR 
b4ed cd 6f ee			call debug_vector  
b4f0				endm  
# End of macro CALLMONITOR
b4f0					endif 
b4f0					FORTH_DSP 
b4f0 cd f7 9c			call macro_forth_dsp 
b4f3				endm 
# End of macro FORTH_DSP
b4f3					;FORTH_DSP_VALUE 
b4f3 7e					ld a,(hl)	; get type of value on TOS 
b4f4 fe 02				cp DS_TYPE_INUM  
b4f6 28 00				jr z, .gt_inum 
b4f8			 
b4f8				if FORTH_ENABLE_FLOATMATH 
b4f8					jr .gt_done 
b4f8			 
b4f8				endif 
b4f8					 
b4f8			 
b4f8			.gt_inum: 
b4f8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4f8 cd 31 9d			call macro_dsp_valuehl 
b4fb				endm 
# End of macro FORTH_DSP_VALUEHL
b4fb			 
b4fb e5					push hl  ; u2 
b4fc			 
b4fc					; destroy value TOS 
b4fc			 
b4fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4fc cd e9 9d			call macro_forth_dsp_pop 
b4ff				endm 
# End of macro FORTH_DSP_POP
b4ff			 
b4ff			 
b4ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4ff cd 31 9d			call macro_dsp_valuehl 
b502				endm 
# End of macro FORTH_DSP_VALUEHL
b502			 
b502 e5					push hl    ; u1 
b503			 
b503					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b503 cd e9 9d			call macro_forth_dsp_pop 
b506				endm 
# End of macro FORTH_DSP_POP
b506			 
b506			 
b506 b7			 or a      ;clear carry flag 
b507 01 00 00		 ld bc, FORTH_FALSE 
b50a e1			  pop hl    ; u1 
b50b d1			  pop de    ; u2 
b50c ed 52		  sbc hl,de 
b50e 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b510			 
b510 01 01 00		 ld bc, FORTH_TRUE 
b513			.gtcont:  
b513 c5					push bc 
b514 e1					pop hl 
b515			 
b515					if DEBUG_FORTH_WORDS 
b515						DMARK "GT1" 
b515 f5				push af  
b516 3a 2a b5			ld a, (.dmark)  
b519 32 6b ee			ld (debug_mark),a  
b51c 3a 2b b5			ld a, (.dmark+1)  
b51f 32 6c ee			ld (debug_mark+1),a  
b522 3a 2c b5			ld a, (.dmark+2)  
b525 32 6d ee			ld (debug_mark+2),a  
b528 18 03			jr .pastdmark  
b52a ..			.dmark: db "GT1"  
b52d f1			.pastdmark: pop af  
b52e			endm  
# End of macro DMARK
b52e						CALLMONITOR 
b52e cd 6f ee			call debug_vector  
b531				endm  
# End of macro CALLMONITOR
b531					endif 
b531 cd 3a 9b				call forth_push_numhl 
b534			 
b534					NEXTW 
b534 c3 e7 9e			jp macro_next 
b537				endm 
# End of macro NEXTW
b537			.EQUAL: 
b537				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b537 31				db WORD_SYS_CORE+29             
b538 a2 b5			dw .ENDLOGIC            
b53a 02				db 1 + 1 
b53b .. 00			db "=",0              
b53d				endm 
# End of macro CWHEAD
b53d			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b53d				; TODO add floating point number detection 
b53d					if DEBUG_FORTH_WORDS_KEY 
b53d						DMARK "EQ." 
b53d f5				push af  
b53e 3a 52 b5			ld a, (.dmark)  
b541 32 6b ee			ld (debug_mark),a  
b544 3a 53 b5			ld a, (.dmark+1)  
b547 32 6c ee			ld (debug_mark+1),a  
b54a 3a 54 b5			ld a, (.dmark+2)  
b54d 32 6d ee			ld (debug_mark+2),a  
b550 18 03			jr .pastdmark  
b552 ..			.dmark: db "EQ."  
b555 f1			.pastdmark: pop af  
b556			endm  
# End of macro DMARK
b556						CALLMONITOR 
b556 cd 6f ee			call debug_vector  
b559				endm  
# End of macro CALLMONITOR
b559					endif 
b559					FORTH_DSP 
b559 cd f7 9c			call macro_forth_dsp 
b55c				endm 
# End of macro FORTH_DSP
b55c					;v5 FORTH_DSP_VALUE 
b55c 7e					ld a,(hl)	; get type of value on TOS 
b55d fe 02				cp DS_TYPE_INUM  
b55f 28 00				jr z, .eq_inum 
b561			 
b561				if FORTH_ENABLE_FLOATMATH 
b561					jr .eq_done 
b561			 
b561				endif 
b561					 
b561			 
b561			.eq_inum: 
b561					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b561 cd 31 9d			call macro_dsp_valuehl 
b564				endm 
# End of macro FORTH_DSP_VALUEHL
b564			 
b564 e5					push hl 
b565			 
b565					; destroy value TOS 
b565			 
b565					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b565 cd e9 9d			call macro_forth_dsp_pop 
b568				endm 
# End of macro FORTH_DSP_POP
b568			 
b568			 
b568					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b568 cd 31 9d			call macro_dsp_valuehl 
b56b				endm 
# End of macro FORTH_DSP_VALUEHL
b56b			 
b56b					; one value on hl get other one back 
b56b			 
b56b e5					push hl 
b56c			 
b56c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b56c cd e9 9d			call macro_forth_dsp_pop 
b56f				endm 
# End of macro FORTH_DSP_POP
b56f			 
b56f 0e 00				ld c, FORTH_FALSE 
b571			 
b571 e1					pop hl 
b572 d1					pop de 
b573			 
b573 7b					ld a, e 
b574 bd					cp l 
b575			 
b575 20 06				jr nz, .eq_done 
b577			 
b577 7a					ld a, d 
b578 bc					cp h 
b579			 
b579 20 02				jr nz, .eq_done 
b57b			 
b57b 0e 01				ld c, FORTH_TRUE 
b57d					 
b57d			 
b57d			 
b57d			.eq_done: 
b57d			 
b57d					; TODO push value back onto stack for another op etc 
b57d			 
b57d 26 00				ld h, 0 
b57f 69					ld l, c 
b580					if DEBUG_FORTH_WORDS 
b580						DMARK "EQ1" 
b580 f5				push af  
b581 3a 95 b5			ld a, (.dmark)  
b584 32 6b ee			ld (debug_mark),a  
b587 3a 96 b5			ld a, (.dmark+1)  
b58a 32 6c ee			ld (debug_mark+1),a  
b58d 3a 97 b5			ld a, (.dmark+2)  
b590 32 6d ee			ld (debug_mark+2),a  
b593 18 03			jr .pastdmark  
b595 ..			.dmark: db "EQ1"  
b598 f1			.pastdmark: pop af  
b599			endm  
# End of macro DMARK
b599						CALLMONITOR 
b599 cd 6f ee			call debug_vector  
b59c				endm  
# End of macro CALLMONITOR
b59c					endif 
b59c cd 3a 9b				call forth_push_numhl 
b59f			 
b59f					NEXTW 
b59f c3 e7 9e			jp macro_next 
b5a2				endm 
# End of macro NEXTW
b5a2			 
b5a2			 
b5a2			.ENDLOGIC: 
b5a2			; eof 
b5a2			 
b5a2			 
# End of file forth_words_logic.asm
b5a2			include "forth_words_maths.asm" 
b5a2			 
b5a2			; | ## Maths Words 
b5a2			 
b5a2			.PLUS:	 
b5a2				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b5a2 15				db WORD_SYS_CORE+1             
b5a3 00 b6			dw .NEG            
b5a5 02				db 1 + 1 
b5a6 .. 00			db "+",0              
b5a8				endm 
# End of macro CWHEAD
b5a8			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b5a8					if DEBUG_FORTH_WORDS_KEY 
b5a8						DMARK "PLU" 
b5a8 f5				push af  
b5a9 3a bd b5			ld a, (.dmark)  
b5ac 32 6b ee			ld (debug_mark),a  
b5af 3a be b5			ld a, (.dmark+1)  
b5b2 32 6c ee			ld (debug_mark+1),a  
b5b5 3a bf b5			ld a, (.dmark+2)  
b5b8 32 6d ee			ld (debug_mark+2),a  
b5bb 18 03			jr .pastdmark  
b5bd ..			.dmark: db "PLU"  
b5c0 f1			.pastdmark: pop af  
b5c1			endm  
# End of macro DMARK
b5c1						CALLMONITOR 
b5c1 cd 6f ee			call debug_vector  
b5c4				endm  
# End of macro CALLMONITOR
b5c4					endif 
b5c4					; add top two values and push back result 
b5c4			 
b5c4					;for v5 FORTH_DSP_VALUE 
b5c4					FORTH_DSP 
b5c4 cd f7 9c			call macro_forth_dsp 
b5c7				endm 
# End of macro FORTH_DSP
b5c7 7e					ld a,(hl)	; get type of value on TOS 
b5c8 fe 02				cp DS_TYPE_INUM  
b5ca 28 03				jr z, .dot_inum 
b5cc			 
b5cc					NEXTW 
b5cc c3 e7 9e			jp macro_next 
b5cf				endm 
# End of macro NEXTW
b5cf			 
b5cf			; float maths 
b5cf			 
b5cf				if FORTH_ENABLE_FLOATMATH 
b5cf						inc hl      ; now at start of numeric as string 
b5cf			 
b5cf					if DEBUG_FORTH_MATHS 
b5cf						DMARK "ADD" 
b5cf				CALLMONITOR 
b5cf					endif 
b5cf			 
b5cf					;ld ix, hl 
b5cf					call CON 
b5cf			 
b5cf			 
b5cf					push hl 
b5cf					 
b5cf					 
b5cf			 
b5cf						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b5cf			 
b5cf					; get next number 
b5cf			 
b5cf						FORTH_DSP_VALUE 
b5cf			 
b5cf						inc hl      ; now at start of numeric as string 
b5cf			 
b5cf					;ld ix, hl 
b5cf					call CON 
b5cf			 
b5cf					push hl 
b5cf			 
b5cf			 
b5cf						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5cf			 
b5cf						; TODO do add 
b5cf			 
b5cf						call IADD 
b5cf			 
b5cf						; TODO get result back as ascii 
b5cf			 
b5cf						; TODO push result  
b5cf			 
b5cf			 
b5cf			 
b5cf						jr .dot_done 
b5cf				endif 
b5cf			 
b5cf			.dot_inum: 
b5cf			 
b5cf			 
b5cf					if DEBUG_FORTH_DOT 
b5cf						DMARK "+IT" 
b5cf f5				push af  
b5d0 3a e4 b5			ld a, (.dmark)  
b5d3 32 6b ee			ld (debug_mark),a  
b5d6 3a e5 b5			ld a, (.dmark+1)  
b5d9 32 6c ee			ld (debug_mark+1),a  
b5dc 3a e6 b5			ld a, (.dmark+2)  
b5df 32 6d ee			ld (debug_mark+2),a  
b5e2 18 03			jr .pastdmark  
b5e4 ..			.dmark: db "+IT"  
b5e7 f1			.pastdmark: pop af  
b5e8			endm  
# End of macro DMARK
b5e8				CALLMONITOR 
b5e8 cd 6f ee			call debug_vector  
b5eb				endm  
# End of macro CALLMONITOR
b5eb					endif 
b5eb			 
b5eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5eb cd 31 9d			call macro_dsp_valuehl 
b5ee				endm 
# End of macro FORTH_DSP_VALUEHL
b5ee			 
b5ee				; TODO add floating point number detection 
b5ee			 
b5ee e5					push hl 
b5ef			 
b5ef					; destroy value TOS 
b5ef			 
b5ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5ef cd e9 9d			call macro_forth_dsp_pop 
b5f2				endm 
# End of macro FORTH_DSP_POP
b5f2			 
b5f2			 
b5f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5f2 cd 31 9d			call macro_dsp_valuehl 
b5f5				endm 
# End of macro FORTH_DSP_VALUEHL
b5f5			 
b5f5					; one value on hl get other one back 
b5f5			 
b5f5 d1					pop de 
b5f6			 
b5f6					; do the add 
b5f6			 
b5f6 19					add hl,de 
b5f7			 
b5f7					; save it 
b5f7			 
b5f7			;		push hl	 
b5f7			 
b5f7					; 
b5f7			 
b5f7					; destroy value TOS 
b5f7			 
b5f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5f7 cd e9 9d			call macro_forth_dsp_pop 
b5fa				endm 
# End of macro FORTH_DSP_POP
b5fa			 
b5fa					; TODO push value back onto stack for another op etc 
b5fa			 
b5fa			;		pop hl 
b5fa			 
b5fa			.dot_done: 
b5fa cd 3a 9b				call forth_push_numhl 
b5fd			 
b5fd					NEXTW 
b5fd c3 e7 9e			jp macro_next 
b600				endm 
# End of macro NEXTW
b600			.NEG: 
b600			 
b600				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b600 17				db WORD_SYS_CORE+3             
b601 43 b6			dw .DIV            
b603 02				db 1 + 1 
b604 .. 00			db "-",0              
b606				endm 
# End of macro CWHEAD
b606			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b606					if DEBUG_FORTH_WORDS_KEY 
b606						DMARK "SUB" 
b606 f5				push af  
b607 3a 1b b6			ld a, (.dmark)  
b60a 32 6b ee			ld (debug_mark),a  
b60d 3a 1c b6			ld a, (.dmark+1)  
b610 32 6c ee			ld (debug_mark+1),a  
b613 3a 1d b6			ld a, (.dmark+2)  
b616 32 6d ee			ld (debug_mark+2),a  
b619 18 03			jr .pastdmark  
b61b ..			.dmark: db "SUB"  
b61e f1			.pastdmark: pop af  
b61f			endm  
# End of macro DMARK
b61f						CALLMONITOR 
b61f cd 6f ee			call debug_vector  
b622				endm  
# End of macro CALLMONITOR
b622					endif 
b622			 
b622			 
b622				; TODO add floating point number detection 
b622					; v5 FORTH_DSP_VALUE 
b622					FORTH_DSP 
b622 cd f7 9c			call macro_forth_dsp 
b625				endm 
# End of macro FORTH_DSP
b625 7e					ld a,(hl)	; get type of value on TOS 
b626 fe 02				cp DS_TYPE_INUM  
b628 28 03				jr z, .neg_inum 
b62a			 
b62a					NEXTW 
b62a c3 e7 9e			jp macro_next 
b62d				endm 
# End of macro NEXTW
b62d			 
b62d			; float maths 
b62d			 
b62d				if FORTH_ENABLE_FLOATMATH 
b62d					jr .neg_done 
b62d			 
b62d				endif 
b62d					 
b62d			 
b62d			.neg_inum: 
b62d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b62d cd 31 9d			call macro_dsp_valuehl 
b630				endm 
# End of macro FORTH_DSP_VALUEHL
b630			 
b630 e5					push hl 
b631			 
b631					; destroy value TOS 
b631			 
b631					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b631 cd e9 9d			call macro_forth_dsp_pop 
b634				endm 
# End of macro FORTH_DSP_POP
b634			 
b634			 
b634					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b634 cd 31 9d			call macro_dsp_valuehl 
b637				endm 
# End of macro FORTH_DSP_VALUEHL
b637			 
b637					; one value on hl get other one back 
b637			 
b637 d1					pop de 
b638			 
b638					; do the sub 
b638			;		ex de, hl 
b638			 
b638 ed 52				sbc hl,de 
b63a			 
b63a					; save it 
b63a			 
b63a			;		push hl	 
b63a			 
b63a					; 
b63a			 
b63a					; destroy value TOS 
b63a			 
b63a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b63a cd e9 9d			call macro_forth_dsp_pop 
b63d				endm 
# End of macro FORTH_DSP_POP
b63d			 
b63d					; TODO push value back onto stack for another op etc 
b63d			 
b63d			;		pop hl 
b63d			 
b63d cd 3a 9b				call forth_push_numhl 
b640			.neg_done: 
b640			 
b640					NEXTW 
b640 c3 e7 9e			jp macro_next 
b643				endm 
# End of macro NEXTW
b643			.DIV: 
b643				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b643 18				db WORD_SYS_CORE+4             
b644 90 b6			dw .MUL            
b646 02				db 1 + 1 
b647 .. 00			db "/",0              
b649				endm 
# End of macro CWHEAD
b649			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b649					if DEBUG_FORTH_WORDS_KEY 
b649						DMARK "DIV" 
b649 f5				push af  
b64a 3a 5e b6			ld a, (.dmark)  
b64d 32 6b ee			ld (debug_mark),a  
b650 3a 5f b6			ld a, (.dmark+1)  
b653 32 6c ee			ld (debug_mark+1),a  
b656 3a 60 b6			ld a, (.dmark+2)  
b659 32 6d ee			ld (debug_mark+2),a  
b65c 18 03			jr .pastdmark  
b65e ..			.dmark: db "DIV"  
b661 f1			.pastdmark: pop af  
b662			endm  
# End of macro DMARK
b662						CALLMONITOR 
b662 cd 6f ee			call debug_vector  
b665				endm  
# End of macro CALLMONITOR
b665					endif 
b665				; TODO add floating point number detection 
b665					; v5 FORTH_DSP_VALUE 
b665					FORTH_DSP 
b665 cd f7 9c			call macro_forth_dsp 
b668				endm 
# End of macro FORTH_DSP
b668 7e					ld a,(hl)	; get type of value on TOS 
b669 fe 02				cp DS_TYPE_INUM  
b66b 28 03				jr z, .div_inum 
b66d			 
b66d				if FORTH_ENABLE_FLOATMATH 
b66d					jr .div_done 
b66d			 
b66d				endif 
b66d					NEXTW 
b66d c3 e7 9e			jp macro_next 
b670				endm 
# End of macro NEXTW
b670			.div_inum: 
b670			 
b670					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b670 cd 31 9d			call macro_dsp_valuehl 
b673				endm 
# End of macro FORTH_DSP_VALUEHL
b673			 
b673 e5					push hl    ; to go to bc 
b674			 
b674					; destroy value TOS 
b674			 
b674					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b674 cd e9 9d			call macro_forth_dsp_pop 
b677				endm 
# End of macro FORTH_DSP_POP
b677			 
b677			 
b677					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b677 cd 31 9d			call macro_dsp_valuehl 
b67a				endm 
# End of macro FORTH_DSP_VALUEHL
b67a			 
b67a					; hl to go to de 
b67a			 
b67a e5					push hl 
b67b			 
b67b c1					pop bc 
b67c d1					pop de		 
b67d			 
b67d			 
b67d					if DEBUG_FORTH_MATHS 
b67d						DMARK "DIV" 
b67d				CALLMONITOR 
b67d					endif 
b67d					; one value on hl but move to a get other one back 
b67d			 
b67d			        
b67d cd 39 8c			call Div16 
b680			 
b680			;	push af	 
b680 e5				push hl 
b681 c5				push bc 
b682			 
b682					if DEBUG_FORTH_MATHS 
b682						DMARK "DI1" 
b682				CALLMONITOR 
b682					endif 
b682			 
b682					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b682 cd e9 9d			call macro_forth_dsp_pop 
b685				endm 
# End of macro FORTH_DSP_POP
b685			 
b685			 
b685			 
b685 e1					pop hl    ; result 
b686			 
b686 cd 3a 9b				call forth_push_numhl 
b689			 
b689 e1					pop hl    ; reminder 
b68a			;		ld h,0 
b68a			;		ld l,d 
b68a			 
b68a cd 3a 9b				call forth_push_numhl 
b68d			.div_done: 
b68d					NEXTW 
b68d c3 e7 9e			jp macro_next 
b690				endm 
# End of macro NEXTW
b690			.MUL: 
b690				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b690 19				db WORD_SYS_CORE+5             
b691 d5 b6			dw .MIN            
b693 02				db 1 + 1 
b694 .. 00			db "*",0              
b696				endm 
# End of macro CWHEAD
b696			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b696				; TODO add floating point number detection 
b696					if DEBUG_FORTH_WORDS_KEY 
b696						DMARK "MUL" 
b696 f5				push af  
b697 3a ab b6			ld a, (.dmark)  
b69a 32 6b ee			ld (debug_mark),a  
b69d 3a ac b6			ld a, (.dmark+1)  
b6a0 32 6c ee			ld (debug_mark+1),a  
b6a3 3a ad b6			ld a, (.dmark+2)  
b6a6 32 6d ee			ld (debug_mark+2),a  
b6a9 18 03			jr .pastdmark  
b6ab ..			.dmark: db "MUL"  
b6ae f1			.pastdmark: pop af  
b6af			endm  
# End of macro DMARK
b6af						CALLMONITOR 
b6af cd 6f ee			call debug_vector  
b6b2				endm  
# End of macro CALLMONITOR
b6b2					endif 
b6b2					FORTH_DSP 
b6b2 cd f7 9c			call macro_forth_dsp 
b6b5				endm 
# End of macro FORTH_DSP
b6b5					; v5 FORTH_DSP_VALUE 
b6b5 7e					ld a,(hl)	; get type of value on TOS 
b6b6 fe 02				cp DS_TYPE_INUM  
b6b8 28 03				jr z, .mul_inum 
b6ba			 
b6ba				if FORTH_ENABLE_FLOATMATH 
b6ba					jr .mul_done 
b6ba			 
b6ba				endif 
b6ba			 
b6ba					NEXTW 
b6ba c3 e7 9e			jp macro_next 
b6bd				endm 
# End of macro NEXTW
b6bd			.mul_inum:	 
b6bd			 
b6bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6bd cd 31 9d			call macro_dsp_valuehl 
b6c0				endm 
# End of macro FORTH_DSP_VALUEHL
b6c0			 
b6c0 e5					push hl 
b6c1			 
b6c1					; destroy value TOS 
b6c1			 
b6c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6c1 cd e9 9d			call macro_forth_dsp_pop 
b6c4				endm 
# End of macro FORTH_DSP_POP
b6c4			 
b6c4			 
b6c4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6c4 cd 31 9d			call macro_dsp_valuehl 
b6c7				endm 
# End of macro FORTH_DSP_VALUEHL
b6c7			 
b6c7					; one value on hl but move to a get other one back 
b6c7			 
b6c7 7d					ld a, l 
b6c8			 
b6c8 d1					pop de 
b6c9			 
b6c9					; do the mull 
b6c9			;		ex de, hl 
b6c9			 
b6c9 cd 5f 8c				call Mult16 
b6cc					; save it 
b6cc			 
b6cc			;		push hl	 
b6cc			 
b6cc					; 
b6cc			 
b6cc					; destroy value TOS 
b6cc			 
b6cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6cc cd e9 9d			call macro_forth_dsp_pop 
b6cf				endm 
# End of macro FORTH_DSP_POP
b6cf			 
b6cf					; TODO push value back onto stack for another op etc 
b6cf			 
b6cf			;		pop hl 
b6cf			 
b6cf cd 3a 9b				call forth_push_numhl 
b6d2			 
b6d2			.mul_done: 
b6d2					NEXTW 
b6d2 c3 e7 9e			jp macro_next 
b6d5				endm 
# End of macro NEXTW
b6d5			 
b6d5			 
b6d5			 
b6d5			 
b6d5			.MIN: 
b6d5				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b6d5 49				db WORD_SYS_CORE+53             
b6d6 56 b7			dw .MAX            
b6d8 04				db 3 + 1 
b6d9 .. 00			db "MIN",0              
b6dd				endm 
# End of macro CWHEAD
b6dd			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b6dd					if DEBUG_FORTH_WORDS_KEY 
b6dd						DMARK "MIN" 
b6dd f5				push af  
b6de 3a f2 b6			ld a, (.dmark)  
b6e1 32 6b ee			ld (debug_mark),a  
b6e4 3a f3 b6			ld a, (.dmark+1)  
b6e7 32 6c ee			ld (debug_mark+1),a  
b6ea 3a f4 b6			ld a, (.dmark+2)  
b6ed 32 6d ee			ld (debug_mark+2),a  
b6f0 18 03			jr .pastdmark  
b6f2 ..			.dmark: db "MIN"  
b6f5 f1			.pastdmark: pop af  
b6f6			endm  
# End of macro DMARK
b6f6						CALLMONITOR 
b6f6 cd 6f ee			call debug_vector  
b6f9				endm  
# End of macro CALLMONITOR
b6f9					endif 
b6f9					; get u2 
b6f9			 
b6f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b6f9 cd 31 9d			call macro_dsp_valuehl 
b6fc				endm 
# End of macro FORTH_DSP_VALUEHL
b6fc			 
b6fc e5					push hl   ; u2 
b6fd			 
b6fd					; destroy value TOS 
b6fd			 
b6fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6fd cd e9 9d			call macro_forth_dsp_pop 
b700				endm 
# End of macro FORTH_DSP_POP
b700			 
b700					; get u1 
b700			 
b700					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b700 cd 31 9d			call macro_dsp_valuehl 
b703				endm 
# End of macro FORTH_DSP_VALUEHL
b703			 
b703 e5					push hl  ; u1 
b704			 
b704					; destroy value TOS 
b704			 
b704					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b704 cd e9 9d			call macro_forth_dsp_pop 
b707				endm 
# End of macro FORTH_DSP_POP
b707			 
b707 b7			 or a      ;clear carry flag 
b708 e1			  pop hl    ; u1 
b709 d1			  pop de    ; u2 
b70a e5				push hl   ; saved in case hl is lowest 
b70b ed 52		  sbc hl,de 
b70d 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b70f			 
b70f e1				pop hl 
b710					if DEBUG_FORTH_WORDS 
b710						DMARK "MIN" 
b710 f5				push af  
b711 3a 25 b7			ld a, (.dmark)  
b714 32 6b ee			ld (debug_mark),a  
b717 3a 26 b7			ld a, (.dmark+1)  
b71a 32 6c ee			ld (debug_mark+1),a  
b71d 3a 27 b7			ld a, (.dmark+2)  
b720 32 6d ee			ld (debug_mark+2),a  
b723 18 03			jr .pastdmark  
b725 ..			.dmark: db "MIN"  
b728 f1			.pastdmark: pop af  
b729			endm  
# End of macro DMARK
b729						CALLMONITOR 
b729 cd 6f ee			call debug_vector  
b72c				endm  
# End of macro CALLMONITOR
b72c					endif 
b72c cd 3a 9b				call forth_push_numhl 
b72f			 
b72f				       NEXTW 
b72f c3 e7 9e			jp macro_next 
b732				endm 
# End of macro NEXTW
b732			 
b732			.mincont:  
b732 c1				pop bc   ; tidy up 
b733 eb				ex de , hl  
b734					if DEBUG_FORTH_WORDS 
b734						DMARK "MI1" 
b734 f5				push af  
b735 3a 49 b7			ld a, (.dmark)  
b738 32 6b ee			ld (debug_mark),a  
b73b 3a 4a b7			ld a, (.dmark+1)  
b73e 32 6c ee			ld (debug_mark+1),a  
b741 3a 4b b7			ld a, (.dmark+2)  
b744 32 6d ee			ld (debug_mark+2),a  
b747 18 03			jr .pastdmark  
b749 ..			.dmark: db "MI1"  
b74c f1			.pastdmark: pop af  
b74d			endm  
# End of macro DMARK
b74d						CALLMONITOR 
b74d cd 6f ee			call debug_vector  
b750				endm  
# End of macro CALLMONITOR
b750					endif 
b750 cd 3a 9b				call forth_push_numhl 
b753			 
b753				       NEXTW 
b753 c3 e7 9e			jp macro_next 
b756				endm 
# End of macro NEXTW
b756			.MAX: 
b756				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b756 4a				db WORD_SYS_CORE+54             
b757 d7 b7			dw .RND16            
b759 04				db 3 + 1 
b75a .. 00			db "MAX",0              
b75e				endm 
# End of macro CWHEAD
b75e			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b75e					if DEBUG_FORTH_WORDS_KEY 
b75e						DMARK "MAX" 
b75e f5				push af  
b75f 3a 73 b7			ld a, (.dmark)  
b762 32 6b ee			ld (debug_mark),a  
b765 3a 74 b7			ld a, (.dmark+1)  
b768 32 6c ee			ld (debug_mark+1),a  
b76b 3a 75 b7			ld a, (.dmark+2)  
b76e 32 6d ee			ld (debug_mark+2),a  
b771 18 03			jr .pastdmark  
b773 ..			.dmark: db "MAX"  
b776 f1			.pastdmark: pop af  
b777			endm  
# End of macro DMARK
b777						CALLMONITOR 
b777 cd 6f ee			call debug_vector  
b77a				endm  
# End of macro CALLMONITOR
b77a					endif 
b77a					; get u2 
b77a			 
b77a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b77a cd 31 9d			call macro_dsp_valuehl 
b77d				endm 
# End of macro FORTH_DSP_VALUEHL
b77d			 
b77d e5					push hl   ; u2 
b77e			 
b77e					; destroy value TOS 
b77e			 
b77e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b77e cd e9 9d			call macro_forth_dsp_pop 
b781				endm 
# End of macro FORTH_DSP_POP
b781			 
b781					; get u1 
b781			 
b781					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b781 cd 31 9d			call macro_dsp_valuehl 
b784				endm 
# End of macro FORTH_DSP_VALUEHL
b784			 
b784 e5					push hl  ; u1 
b785			 
b785					; destroy value TOS 
b785			 
b785					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b785 cd e9 9d			call macro_forth_dsp_pop 
b788				endm 
# End of macro FORTH_DSP_POP
b788			 
b788 b7			 or a      ;clear carry flag 
b789 e1			  pop hl    ; u1 
b78a d1			  pop de    ; u2 
b78b e5				push hl   ; saved in case hl is lowest 
b78c ed 52		  sbc hl,de 
b78e 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b790			 
b790 e1				pop hl 
b791					if DEBUG_FORTH_WORDS 
b791						DMARK "MAX" 
b791 f5				push af  
b792 3a a6 b7			ld a, (.dmark)  
b795 32 6b ee			ld (debug_mark),a  
b798 3a a7 b7			ld a, (.dmark+1)  
b79b 32 6c ee			ld (debug_mark+1),a  
b79e 3a a8 b7			ld a, (.dmark+2)  
b7a1 32 6d ee			ld (debug_mark+2),a  
b7a4 18 03			jr .pastdmark  
b7a6 ..			.dmark: db "MAX"  
b7a9 f1			.pastdmark: pop af  
b7aa			endm  
# End of macro DMARK
b7aa						CALLMONITOR 
b7aa cd 6f ee			call debug_vector  
b7ad				endm  
# End of macro CALLMONITOR
b7ad					endif 
b7ad cd 3a 9b				call forth_push_numhl 
b7b0			 
b7b0				       NEXTW 
b7b0 c3 e7 9e			jp macro_next 
b7b3				endm 
# End of macro NEXTW
b7b3			 
b7b3			.maxcont:  
b7b3 c1				pop bc   ; tidy up 
b7b4 eb				ex de , hl  
b7b5					if DEBUG_FORTH_WORDS 
b7b5						DMARK "MA1" 
b7b5 f5				push af  
b7b6 3a ca b7			ld a, (.dmark)  
b7b9 32 6b ee			ld (debug_mark),a  
b7bc 3a cb b7			ld a, (.dmark+1)  
b7bf 32 6c ee			ld (debug_mark+1),a  
b7c2 3a cc b7			ld a, (.dmark+2)  
b7c5 32 6d ee			ld (debug_mark+2),a  
b7c8 18 03			jr .pastdmark  
b7ca ..			.dmark: db "MA1"  
b7cd f1			.pastdmark: pop af  
b7ce			endm  
# End of macro DMARK
b7ce						CALLMONITOR 
b7ce cd 6f ee			call debug_vector  
b7d1				endm  
# End of macro CALLMONITOR
b7d1					endif 
b7d1 cd 3a 9b				call forth_push_numhl 
b7d4				       NEXTW 
b7d4 c3 e7 9e			jp macro_next 
b7d7				endm 
# End of macro NEXTW
b7d7			 
b7d7			.RND16: 
b7d7				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b7d7 4e				db WORD_SYS_CORE+58             
b7d8 06 b8			dw .RND8            
b7da 06				db 5 + 1 
b7db .. 00			db "RND16",0              
b7e1				endm 
# End of macro CWHEAD
b7e1			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b7e1					if DEBUG_FORTH_WORDS_KEY 
b7e1						DMARK "R16" 
b7e1 f5				push af  
b7e2 3a f6 b7			ld a, (.dmark)  
b7e5 32 6b ee			ld (debug_mark),a  
b7e8 3a f7 b7			ld a, (.dmark+1)  
b7eb 32 6c ee			ld (debug_mark+1),a  
b7ee 3a f8 b7			ld a, (.dmark+2)  
b7f1 32 6d ee			ld (debug_mark+2),a  
b7f4 18 03			jr .pastdmark  
b7f6 ..			.dmark: db "R16"  
b7f9 f1			.pastdmark: pop af  
b7fa			endm  
# End of macro DMARK
b7fa						CALLMONITOR 
b7fa cd 6f ee			call debug_vector  
b7fd				endm  
# End of macro CALLMONITOR
b7fd					endif 
b7fd cd 03 8c				call prng16  
b800 cd 3a 9b				call forth_push_numhl 
b803				       NEXTW 
b803 c3 e7 9e			jp macro_next 
b806				endm 
# End of macro NEXTW
b806			.RND8: 
b806				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b806 60				db WORD_SYS_CORE+76             
b807 3b b8			dw .RND            
b809 05				db 4 + 1 
b80a .. 00			db "RND8",0              
b80f				endm 
# End of macro CWHEAD
b80f			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b80f					if DEBUG_FORTH_WORDS_KEY 
b80f						DMARK "RN8" 
b80f f5				push af  
b810 3a 24 b8			ld a, (.dmark)  
b813 32 6b ee			ld (debug_mark),a  
b816 3a 25 b8			ld a, (.dmark+1)  
b819 32 6c ee			ld (debug_mark+1),a  
b81c 3a 26 b8			ld a, (.dmark+2)  
b81f 32 6d ee			ld (debug_mark+2),a  
b822 18 03			jr .pastdmark  
b824 ..			.dmark: db "RN8"  
b827 f1			.pastdmark: pop af  
b828			endm  
# End of macro DMARK
b828						CALLMONITOR 
b828 cd 6f ee			call debug_vector  
b82b				endm  
# End of macro CALLMONITOR
b82b					endif 
b82b 2a a9 eb				ld hl,(xrandc) 
b82e 23					inc hl 
b82f cd 1d 8c				call xrnd 
b832 6f					ld l,a	 
b833 26 00				ld h,0 
b835 cd 3a 9b				call forth_push_numhl 
b838				       NEXTW 
b838 c3 e7 9e			jp macro_next 
b83b				endm 
# End of macro NEXTW
b83b			.RND: 
b83b				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b83b 60				db WORD_SYS_CORE+76             
b83c 41 b9			dw .ENDMATHS            
b83e 04				db 3 + 1 
b83f .. 00			db "RND",0              
b843				endm 
# End of macro CWHEAD
b843			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b843			 
b843					if DEBUG_FORTH_WORDS_KEY 
b843						DMARK "RND" 
b843 f5				push af  
b844 3a 58 b8			ld a, (.dmark)  
b847 32 6b ee			ld (debug_mark),a  
b84a 3a 59 b8			ld a, (.dmark+1)  
b84d 32 6c ee			ld (debug_mark+1),a  
b850 3a 5a b8			ld a, (.dmark+2)  
b853 32 6d ee			ld (debug_mark+2),a  
b856 18 03			jr .pastdmark  
b858 ..			.dmark: db "RND"  
b85b f1			.pastdmark: pop af  
b85c			endm  
# End of macro DMARK
b85c						CALLMONITOR 
b85c cd 6f ee			call debug_vector  
b85f				endm  
# End of macro CALLMONITOR
b85f					endif 
b85f					 
b85f					FORTH_DSP_VALUEHL    ; upper range 
b85f cd 31 9d			call macro_dsp_valuehl 
b862				endm 
# End of macro FORTH_DSP_VALUEHL
b862			 
b862 22 ad eb				ld (LFSRSeed), hl	 
b865			 
b865					if DEBUG_FORTH_WORDS 
b865						DMARK "RN1" 
b865 f5				push af  
b866 3a 7a b8			ld a, (.dmark)  
b869 32 6b ee			ld (debug_mark),a  
b86c 3a 7b b8			ld a, (.dmark+1)  
b86f 32 6c ee			ld (debug_mark+1),a  
b872 3a 7c b8			ld a, (.dmark+2)  
b875 32 6d ee			ld (debug_mark+2),a  
b878 18 03			jr .pastdmark  
b87a ..			.dmark: db "RN1"  
b87d f1			.pastdmark: pop af  
b87e			endm  
# End of macro DMARK
b87e						CALLMONITOR 
b87e cd 6f ee			call debug_vector  
b881				endm  
# End of macro CALLMONITOR
b881					endif 
b881					FORTH_DSP_POP 
b881 cd e9 9d			call macro_forth_dsp_pop 
b884				endm 
# End of macro FORTH_DSP_POP
b884			 
b884					FORTH_DSP_VALUEHL    ; low range 
b884 cd 31 9d			call macro_dsp_valuehl 
b887				endm 
# End of macro FORTH_DSP_VALUEHL
b887			 
b887					if DEBUG_FORTH_WORDS 
b887						DMARK "RN2" 
b887 f5				push af  
b888 3a 9c b8			ld a, (.dmark)  
b88b 32 6b ee			ld (debug_mark),a  
b88e 3a 9d b8			ld a, (.dmark+1)  
b891 32 6c ee			ld (debug_mark+1),a  
b894 3a 9e b8			ld a, (.dmark+2)  
b897 32 6d ee			ld (debug_mark+2),a  
b89a 18 03			jr .pastdmark  
b89c ..			.dmark: db "RN2"  
b89f f1			.pastdmark: pop af  
b8a0			endm  
# End of macro DMARK
b8a0						CALLMONITOR 
b8a0 cd 6f ee			call debug_vector  
b8a3				endm  
# End of macro CALLMONITOR
b8a3					endif 
b8a3 22 af eb				ld (LFSRSeed+2), hl 
b8a6			 
b8a6					FORTH_DSP_POP 
b8a6 cd e9 9d			call macro_forth_dsp_pop 
b8a9				endm 
# End of macro FORTH_DSP_POP
b8a9			 
b8a9 e5					push hl 
b8aa			 
b8aa e1			.inrange:	pop hl 
b8ab cd 03 8c				call prng16  
b8ae					if DEBUG_FORTH_WORDS 
b8ae						DMARK "RN3" 
b8ae f5				push af  
b8af 3a c3 b8			ld a, (.dmark)  
b8b2 32 6b ee			ld (debug_mark),a  
b8b5 3a c4 b8			ld a, (.dmark+1)  
b8b8 32 6c ee			ld (debug_mark+1),a  
b8bb 3a c5 b8			ld a, (.dmark+2)  
b8be 32 6d ee			ld (debug_mark+2),a  
b8c1 18 03			jr .pastdmark  
b8c3 ..			.dmark: db "RN3"  
b8c6 f1			.pastdmark: pop af  
b8c7			endm  
# End of macro DMARK
b8c7						CALLMONITOR 
b8c7 cd 6f ee			call debug_vector  
b8ca				endm  
# End of macro CALLMONITOR
b8ca					endif 
b8ca					 
b8ca					; if the range is 8bit knock out the high byte 
b8ca			 
b8ca ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
b8ce			 
b8ce 3e 00				ld a, 0 
b8d0 ba					cp d  
b8d1 20 1e				jr nz, .hirange 
b8d3 26 00				ld h, 0   ; knock it down to 8bit 
b8d5			 
b8d5					if DEBUG_FORTH_WORDS 
b8d5						DMARK "RNk" 
b8d5 f5				push af  
b8d6 3a ea b8			ld a, (.dmark)  
b8d9 32 6b ee			ld (debug_mark),a  
b8dc 3a eb b8			ld a, (.dmark+1)  
b8df 32 6c ee			ld (debug_mark+1),a  
b8e2 3a ec b8			ld a, (.dmark+2)  
b8e5 32 6d ee			ld (debug_mark+2),a  
b8e8 18 03			jr .pastdmark  
b8ea ..			.dmark: db "RNk"  
b8ed f1			.pastdmark: pop af  
b8ee			endm  
# End of macro DMARK
b8ee						CALLMONITOR 
b8ee cd 6f ee			call debug_vector  
b8f1				endm  
# End of macro CALLMONITOR
b8f1					endif 
b8f1			.hirange:   
b8f1 e5					push hl  
b8f2 b7					or a  
b8f3 ed 52		                sbc hl, de 
b8f5			 
b8f5					;call cmp16 
b8f5			 
b8f5 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b8f7 e1					pop hl 
b8f8 e5					push hl 
b8f9			 
b8f9					if DEBUG_FORTH_WORDS 
b8f9						DMARK "RN4" 
b8f9 f5				push af  
b8fa 3a 0e b9			ld a, (.dmark)  
b8fd 32 6b ee			ld (debug_mark),a  
b900 3a 0f b9			ld a, (.dmark+1)  
b903 32 6c ee			ld (debug_mark+1),a  
b906 3a 10 b9			ld a, (.dmark+2)  
b909 32 6d ee			ld (debug_mark+2),a  
b90c 18 03			jr .pastdmark  
b90e ..			.dmark: db "RN4"  
b911 f1			.pastdmark: pop af  
b912			endm  
# End of macro DMARK
b912						CALLMONITOR 
b912 cd 6f ee			call debug_vector  
b915				endm  
# End of macro CALLMONITOR
b915					endif 
b915 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
b919					;call cmp16 
b919				 
b919 b7					or a  
b91a ed 52		                sbc hl, de 
b91c 38 8c				jr c, .inrange 
b91e			 
b91e e1					pop hl 
b91f					 
b91f					if DEBUG_FORTH_WORDS 
b91f						DMARK "RNd" 
b91f f5				push af  
b920 3a 34 b9			ld a, (.dmark)  
b923 32 6b ee			ld (debug_mark),a  
b926 3a 35 b9			ld a, (.dmark+1)  
b929 32 6c ee			ld (debug_mark+1),a  
b92c 3a 36 b9			ld a, (.dmark+2)  
b92f 32 6d ee			ld (debug_mark+2),a  
b932 18 03			jr .pastdmark  
b934 ..			.dmark: db "RNd"  
b937 f1			.pastdmark: pop af  
b938			endm  
# End of macro DMARK
b938						CALLMONITOR 
b938 cd 6f ee			call debug_vector  
b93b				endm  
# End of macro CALLMONITOR
b93b					endif 
b93b			 
b93b			 
b93b cd 3a 9b				call forth_push_numhl 
b93e				       NEXTW 
b93e c3 e7 9e			jp macro_next 
b941				endm 
# End of macro NEXTW
b941			 
b941			.ENDMATHS: 
b941			 
b941			; eof 
b941			 
# End of file forth_words_maths.asm
b941			include "forth_words_display.asm" 
b941			 
b941			; | ## Display Words 
b941			 
b941			.ACT: 
b941			 
b941				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
b941 62				db WORD_SYS_CORE+78             
b942 8d b9			dw .INFO            
b944 07				db 6 + 1 
b945 .. 00			db "ACTIVE",0              
b94c				endm 
# End of macro CWHEAD
b94c			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
b94c			;  
b94c			; | | e.g. $ff $00 do active . $01 pause loop 
b94c			 
b94c					if DEBUG_FORTH_WORDS_KEY 
b94c						DMARK "ACT" 
b94c f5				push af  
b94d 3a 61 b9			ld a, (.dmark)  
b950 32 6b ee			ld (debug_mark),a  
b953 3a 62 b9			ld a, (.dmark+1)  
b956 32 6c ee			ld (debug_mark+1),a  
b959 3a 63 b9			ld a, (.dmark+2)  
b95c 32 6d ee			ld (debug_mark+2),a  
b95f 18 03			jr .pastdmark  
b961 ..			.dmark: db "ACT"  
b964 f1			.pastdmark: pop af  
b965			endm  
# End of macro DMARK
b965						CALLMONITOR 
b965 cd 6f ee			call debug_vector  
b968				endm  
# End of macro CALLMONITOR
b968					endif 
b968 cd 06 8a				call active 
b96b					if DEBUG_FORTH_WORDS 
b96b						DMARK "ACp" 
b96b f5				push af  
b96c 3a 80 b9			ld a, (.dmark)  
b96f 32 6b ee			ld (debug_mark),a  
b972 3a 81 b9			ld a, (.dmark+1)  
b975 32 6c ee			ld (debug_mark+1),a  
b978 3a 82 b9			ld a, (.dmark+2)  
b97b 32 6d ee			ld (debug_mark+2),a  
b97e 18 03			jr .pastdmark  
b980 ..			.dmark: db "ACp"  
b983 f1			.pastdmark: pop af  
b984			endm  
# End of macro DMARK
b984						CALLMONITOR 
b984 cd 6f ee			call debug_vector  
b987				endm  
# End of macro CALLMONITOR
b987					endif 
b987 cd a8 9b				call forth_push_str 
b98a			 
b98a					NEXTW 
b98a c3 e7 9e			jp macro_next 
b98d				endm 
# End of macro NEXTW
b98d			.INFO: 
b98d			 
b98d				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b98d 62				db WORD_SYS_CORE+78             
b98e aa b9			dw .ATP            
b990 05				db 4 + 1 
b991 .. 00			db "INFO",0              
b996				endm 
# End of macro CWHEAD
b996			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b996					FORTH_DSP_VALUEHL 
b996 cd 31 9d			call macro_dsp_valuehl 
b999				endm 
# End of macro FORTH_DSP_VALUEHL
b999			 
b999					FORTH_DSP_POP 
b999 cd e9 9d			call macro_forth_dsp_pop 
b99c				endm 
# End of macro FORTH_DSP_POP
b99c			 
b99c e5					push hl 
b99d			 
b99d					FORTH_DSP_VALUEHL 
b99d cd 31 9d			call macro_dsp_valuehl 
b9a0				endm 
# End of macro FORTH_DSP_VALUEHL
b9a0			 
b9a0					FORTH_DSP_POP 
b9a0 cd e9 9d			call macro_forth_dsp_pop 
b9a3				endm 
# End of macro FORTH_DSP_POP
b9a3			 
b9a3 d1					pop de 
b9a4			 
b9a4 cd 40 8a				call info_panel 
b9a7			 
b9a7			 
b9a7					NEXTW 
b9a7 c3 e7 9e			jp macro_next 
b9aa				endm 
# End of macro NEXTW
b9aa			.ATP: 
b9aa				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b9aa 62				db WORD_SYS_CORE+78             
b9ab 21 ba			dw .FB            
b9ad 04				db 3 + 1 
b9ae .. 00			db "AT?",0              
b9b2				endm 
# End of macro CWHEAD
b9b2			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b9b2					if DEBUG_FORTH_WORDS_KEY 
b9b2						DMARK "AT?" 
b9b2 f5				push af  
b9b3 3a c7 b9			ld a, (.dmark)  
b9b6 32 6b ee			ld (debug_mark),a  
b9b9 3a c8 b9			ld a, (.dmark+1)  
b9bc 32 6c ee			ld (debug_mark+1),a  
b9bf 3a c9 b9			ld a, (.dmark+2)  
b9c2 32 6d ee			ld (debug_mark+2),a  
b9c5 18 03			jr .pastdmark  
b9c7 ..			.dmark: db "AT?"  
b9ca f1			.pastdmark: pop af  
b9cb			endm  
# End of macro DMARK
b9cb						CALLMONITOR 
b9cb cd 6f ee			call debug_vector  
b9ce				endm  
# End of macro CALLMONITOR
b9ce					endif 
b9ce 3a 5e ea				ld a, (f_cursor_ptr) 
b9d1			 
b9d1			if DEBUG_FORTH_WORDS 
b9d1				DMARK "AT?" 
b9d1 f5				push af  
b9d2 3a e6 b9			ld a, (.dmark)  
b9d5 32 6b ee			ld (debug_mark),a  
b9d8 3a e7 b9			ld a, (.dmark+1)  
b9db 32 6c ee			ld (debug_mark+1),a  
b9de 3a e8 b9			ld a, (.dmark+2)  
b9e1 32 6d ee			ld (debug_mark+2),a  
b9e4 18 03			jr .pastdmark  
b9e6 ..			.dmark: db "AT?"  
b9e9 f1			.pastdmark: pop af  
b9ea			endm  
# End of macro DMARK
b9ea				CALLMONITOR 
b9ea cd 6f ee			call debug_vector  
b9ed				endm  
# End of macro CALLMONITOR
b9ed			endif	 
b9ed					; count the number of rows 
b9ed			 
b9ed 06 00				ld b, 0 
b9ef 4f			.atpr:		ld c, a    ; save in case we go below zero 
b9f0 d6 28				sub display_cols 
b9f2 f2 f8 b9				jp p, .atprunder 
b9f5 04					inc b 
b9f6 18 f7				jr .atpr 
b9f8			.atprunder:	 
b9f8			if DEBUG_FORTH_WORDS 
b9f8				DMARK "A?2" 
b9f8 f5				push af  
b9f9 3a 0d ba			ld a, (.dmark)  
b9fc 32 6b ee			ld (debug_mark),a  
b9ff 3a 0e ba			ld a, (.dmark+1)  
ba02 32 6c ee			ld (debug_mark+1),a  
ba05 3a 0f ba			ld a, (.dmark+2)  
ba08 32 6d ee			ld (debug_mark+2),a  
ba0b 18 03			jr .pastdmark  
ba0d ..			.dmark: db "A?2"  
ba10 f1			.pastdmark: pop af  
ba11			endm  
# End of macro DMARK
ba11				CALLMONITOR 
ba11 cd 6f ee			call debug_vector  
ba14				endm  
# End of macro CALLMONITOR
ba14			endif	 
ba14 26 00				ld h, 0 
ba16 69					ld l, c 
ba17 cd 3a 9b				call forth_push_numhl 
ba1a 68					ld l, b  
ba1b cd 3a 9b				call forth_push_numhl 
ba1e			 
ba1e			 
ba1e				NEXTW 
ba1e c3 e7 9e			jp macro_next 
ba21				endm 
# End of macro NEXTW
ba21			 
ba21			.FB: 
ba21				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
ba21 1b				db WORD_SYS_CORE+7             
ba22 6f ba			dw .EMIT            
ba24 03				db 2 + 1 
ba25 .. 00			db "FB",0              
ba28				endm 
# End of macro CWHEAD
ba28			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
ba28			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
ba28			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
ba28			; | | If automatic display is off then updates will not be shown until DRAW is used. 
ba28					if DEBUG_FORTH_WORDS_KEY 
ba28						DMARK "FB." 
ba28 f5				push af  
ba29 3a 3d ba			ld a, (.dmark)  
ba2c 32 6b ee			ld (debug_mark),a  
ba2f 3a 3e ba			ld a, (.dmark+1)  
ba32 32 6c ee			ld (debug_mark+1),a  
ba35 3a 3f ba			ld a, (.dmark+2)  
ba38 32 6d ee			ld (debug_mark+2),a  
ba3b 18 03			jr .pastdmark  
ba3d ..			.dmark: db "FB."  
ba40 f1			.pastdmark: pop af  
ba41			endm  
# End of macro DMARK
ba41						CALLMONITOR 
ba41 cd 6f ee			call debug_vector  
ba44				endm  
# End of macro CALLMONITOR
ba44					endif 
ba44			 
ba44					FORTH_DSP_VALUEHL 
ba44 cd 31 9d			call macro_dsp_valuehl 
ba47				endm 
# End of macro FORTH_DSP_VALUEHL
ba47			 
ba47 7d					ld a, l 
ba48 fe 01				cp 1 
ba4a 20 05				jr nz, .fbn1 
ba4c 21 10 ed				ld hl, display_fb1 
ba4f 18 15				jr .fbset 
ba51 fe 02		.fbn1:		cp 2 
ba53 20 05				jr nz, .fbn2 
ba55 21 ce eb				ld hl, display_fb2 
ba58 18 0c				jr .fbset 
ba5a fe 03		.fbn2:		cp 3 
ba5c 20 05				jr nz, .fbn3 
ba5e 21 6f ec				ld hl, display_fb3 
ba61 18 03				jr .fbset 
ba63			.fbn3:		 ; if invalid number select first 
ba63 21 10 ed				ld hl, display_fb1 
ba66 22 cc eb		.fbset:		ld (display_fb_active), hl 
ba69			 
ba69					FORTH_DSP_POP 
ba69 cd e9 9d			call macro_forth_dsp_pop 
ba6c				endm 
# End of macro FORTH_DSP_POP
ba6c			 
ba6c					NEXTW 
ba6c c3 e7 9e			jp macro_next 
ba6f				endm 
# End of macro NEXTW
ba6f			 
ba6f			 
ba6f			.EMIT: 
ba6f				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
ba6f 1b				db WORD_SYS_CORE+7             
ba70 c0 ba			dw .DOTH            
ba72 05				db 4 + 1 
ba73 .. 00			db "EMIT",0              
ba78				endm 
# End of macro CWHEAD
ba78			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
ba78					; get value off TOS and display it 
ba78			 
ba78					if DEBUG_FORTH_WORDS_KEY 
ba78						DMARK "EMT" 
ba78 f5				push af  
ba79 3a 8d ba			ld a, (.dmark)  
ba7c 32 6b ee			ld (debug_mark),a  
ba7f 3a 8e ba			ld a, (.dmark+1)  
ba82 32 6c ee			ld (debug_mark+1),a  
ba85 3a 8f ba			ld a, (.dmark+2)  
ba88 32 6d ee			ld (debug_mark+2),a  
ba8b 18 03			jr .pastdmark  
ba8d ..			.dmark: db "EMT"  
ba90 f1			.pastdmark: pop af  
ba91			endm  
# End of macro DMARK
ba91						CALLMONITOR 
ba91 cd 6f ee			call debug_vector  
ba94				endm  
# End of macro CALLMONITOR
ba94					endif 
ba94			 
ba94					FORTH_DSP_VALUEHL 
ba94 cd 31 9d			call macro_dsp_valuehl 
ba97				endm 
# End of macro FORTH_DSP_VALUEHL
ba97			 
ba97 7d					ld a,l 
ba98			 
ba98					; TODO write to display 
ba98			 
ba98 32 bf e4				ld (os_input), a 
ba9b 3e 00				ld a, 0 
ba9d 32 c0 e4				ld (os_input+1), a 
baa0					 
baa0 3a 5e ea				ld a, (f_cursor_ptr) 
baa3 11 bf e4				ld de, os_input 
baa6 cd c2 8a				call str_at_display 
baa9			 
baa9			 
baa9 3a 3c ea				ld a,(cli_autodisplay) 
baac fe 00				cp 0 
baae 28 03				jr z, .enoupdate 
bab0 cd d2 8a						call update_display 
bab3					.enoupdate: 
bab3			 
bab3 3a 5e ea				ld a, (f_cursor_ptr) 
bab6 3c					inc a 
bab7 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
baba			 
baba			 
baba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
baba cd e9 9d			call macro_forth_dsp_pop 
babd				endm 
# End of macro FORTH_DSP_POP
babd			  
babd			 
babd					NEXTW 
babd c3 e7 9e			jp macro_next 
bac0				endm 
# End of macro NEXTW
bac0			.DOTH: 
bac0				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
bac0 1c				db WORD_SYS_CORE+8             
bac1 f0 ba			dw .DOTF            
bac3 03				db 2 + 1 
bac4 .. 00			db ".-",0              
bac7				endm 
# End of macro CWHEAD
bac7			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
bac7					; get value off TOS and display it 
bac7					if DEBUG_FORTH_WORDS_KEY 
bac7						DMARK "DTD" 
bac7 f5				push af  
bac8 3a dc ba			ld a, (.dmark)  
bacb 32 6b ee			ld (debug_mark),a  
bace 3a dd ba			ld a, (.dmark+1)  
bad1 32 6c ee			ld (debug_mark+1),a  
bad4 3a de ba			ld a, (.dmark+2)  
bad7 32 6d ee			ld (debug_mark+2),a  
bada 18 03			jr .pastdmark  
badc ..			.dmark: db "DTD"  
badf f1			.pastdmark: pop af  
bae0			endm  
# End of macro DMARK
bae0						CALLMONITOR 
bae0 cd 6f ee			call debug_vector  
bae3				endm  
# End of macro CALLMONITOR
bae3					endif 
bae3 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
bae5 3e 00			ld a, 0 
bae7 32 3d ea			ld (cli_mvdot), a 
baea c3 47 bb			jp .dotgo 
baed				NEXTW 
baed c3 e7 9e			jp macro_next 
baf0				endm 
# End of macro NEXTW
baf0			.DOTF: 
baf0				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
baf0 1c				db WORD_SYS_CORE+8             
baf1 1e bb			dw .DOT            
baf3 03				db 2 + 1 
baf4 .. 00			db ".>",0              
baf7				endm 
# End of macro CWHEAD
baf7			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
baf7					; get value off TOS and display it 
baf7			        ; TODO BUG adds extra spaces 
baf7			        ; TODO BUG handle numerics? 
baf7					if DEBUG_FORTH_WORDS_KEY 
baf7						DMARK "DTC" 
baf7 f5				push af  
baf8 3a 0c bb			ld a, (.dmark)  
bafb 32 6b ee			ld (debug_mark),a  
bafe 3a 0d bb			ld a, (.dmark+1)  
bb01 32 6c ee			ld (debug_mark+1),a  
bb04 3a 0e bb			ld a, (.dmark+2)  
bb07 32 6d ee			ld (debug_mark+2),a  
bb0a 18 03			jr .pastdmark  
bb0c ..			.dmark: db "DTC"  
bb0f f1			.pastdmark: pop af  
bb10			endm  
# End of macro DMARK
bb10						CALLMONITOR 
bb10 cd 6f ee			call debug_vector  
bb13				endm  
# End of macro CALLMONITOR
bb13					endif 
bb13 3e 01			ld a, 1 
bb15 32 3d ea			ld (cli_mvdot), a 
bb18 c3 47 bb			jp .dotgo 
bb1b				NEXTW 
bb1b c3 e7 9e			jp macro_next 
bb1e				endm 
# End of macro NEXTW
bb1e			 
bb1e			.DOT: 
bb1e				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
bb1e 1c				db WORD_SYS_CORE+8             
bb1f fa bc			dw .CLS            
bb21 02				db 1 + 1 
bb22 .. 00			db ".",0              
bb24				endm 
# End of macro CWHEAD
bb24			        ; | . ( u -- ) Display TOS | DONE 
bb24					; get value off TOS and display it 
bb24			 
bb24					if DEBUG_FORTH_WORDS_KEY 
bb24						DMARK "DOT" 
bb24 f5				push af  
bb25 3a 39 bb			ld a, (.dmark)  
bb28 32 6b ee			ld (debug_mark),a  
bb2b 3a 3a bb			ld a, (.dmark+1)  
bb2e 32 6c ee			ld (debug_mark+1),a  
bb31 3a 3b bb			ld a, (.dmark+2)  
bb34 32 6d ee			ld (debug_mark+2),a  
bb37 18 03			jr .pastdmark  
bb39 ..			.dmark: db "DOT"  
bb3c f1			.pastdmark: pop af  
bb3d			endm  
# End of macro DMARK
bb3d						CALLMONITOR 
bb3d cd 6f ee			call debug_vector  
bb40				endm  
# End of macro CALLMONITOR
bb40					endif 
bb40 3e 00			ld a, 0 
bb42 32 3d ea			ld (cli_mvdot), a 
bb45 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
bb47				 
bb47			 
bb47			.dotgo: 
bb47			 
bb47			; move up type to on stack for parserv5 
bb47					FORTH_DSP 
bb47 cd f7 9c			call macro_forth_dsp 
bb4a				endm 
# End of macro FORTH_DSP
bb4a				;FORTH_DSP_VALUE  
bb4a			 
bb4a			if DEBUG_FORTH_DOT 
bb4a				DMARK "DOT" 
bb4a f5				push af  
bb4b 3a 5f bb			ld a, (.dmark)  
bb4e 32 6b ee			ld (debug_mark),a  
bb51 3a 60 bb			ld a, (.dmark+1)  
bb54 32 6c ee			ld (debug_mark+1),a  
bb57 3a 61 bb			ld a, (.dmark+2)  
bb5a 32 6d ee			ld (debug_mark+2),a  
bb5d 18 03			jr .pastdmark  
bb5f ..			.dmark: db "DOT"  
bb62 f1			.pastdmark: pop af  
bb63			endm  
# End of macro DMARK
bb63				CALLMONITOR 
bb63 cd 6f ee			call debug_vector  
bb66				endm  
# End of macro CALLMONITOR
bb66			endif	 
bb66			;		.print: 
bb66			 
bb66 7e				ld a,(hl)  ; work out what type of value is on the TOS 
bb67 23				inc hl   ; position to the actual value 
bb68 fe 01			cp DS_TYPE_STR 
bb6a 20 06			jr nz, .dotnum1  
bb6c			 
bb6c			; display string 
bb6c				FORTH_DSP_VALUE  
bb6c cd 1a 9d			call macro_forth_dsp_value 
bb6f				endm 
# End of macro FORTH_DSP_VALUE
bb6f eb				ex de,hl 
bb70 18 49			jr .dotwrite 
bb72			 
bb72			.dotnum1: 
bb72 fe 02			cp DS_TYPE_INUM 
bb74 20 44			jr nz, .dotflot 
bb76			 
bb76			 
bb76			; display number 
bb76			 
bb76			;	push hl 
bb76			;	call clear_display 
bb76			;	pop hl 
bb76			 
bb76 5e				ld e, (hl) 
bb77 23				inc hl 
bb78 56				ld d, (hl) 
bb79 21 c1 e2			ld hl, scratch 
bb7c			if DEBUG_FORTH_DOT 
bb7c				DMARK "DT1" 
bb7c f5				push af  
bb7d 3a 91 bb			ld a, (.dmark)  
bb80 32 6b ee			ld (debug_mark),a  
bb83 3a 92 bb			ld a, (.dmark+1)  
bb86 32 6c ee			ld (debug_mark+1),a  
bb89 3a 93 bb			ld a, (.dmark+2)  
bb8c 32 6d ee			ld (debug_mark+2),a  
bb8f 18 03			jr .pastdmark  
bb91 ..			.dmark: db "DT1"  
bb94 f1			.pastdmark: pop af  
bb95			endm  
# End of macro DMARK
bb95				CALLMONITOR 
bb95 cd 6f ee			call debug_vector  
bb98				endm  
# End of macro CALLMONITOR
bb98			endif	 
bb98			 
bb98 cd e9 90			call uitoa_16 
bb9b eb				ex de,hl 
bb9c			 
bb9c			if DEBUG_FORTH_DOT 
bb9c				DMARK "DT2" 
bb9c f5				push af  
bb9d 3a b1 bb			ld a, (.dmark)  
bba0 32 6b ee			ld (debug_mark),a  
bba3 3a b2 bb			ld a, (.dmark+1)  
bba6 32 6c ee			ld (debug_mark+1),a  
bba9 3a b3 bb			ld a, (.dmark+2)  
bbac 32 6d ee			ld (debug_mark+2),a  
bbaf 18 03			jr .pastdmark  
bbb1 ..			.dmark: db "DT2"  
bbb4 f1			.pastdmark: pop af  
bbb5			endm  
# End of macro DMARK
bbb5				CALLMONITOR 
bbb5 cd 6f ee			call debug_vector  
bbb8				endm  
# End of macro CALLMONITOR
bbb8			endif	 
bbb8			 
bbb8			;	ld de, os_word_scratch 
bbb8 18 01			jr .dotwrite 
bbba			 
bbba 00			.dotflot:   nop 
bbbb			; TODO print floating point number 
bbbb			 
bbbb			.dotwrite:		 
bbbb			 
bbbb					; if c is set then set all '-' to spaces 
bbbb					; need to also take into account .>  
bbbb			 
bbbb 3e 01				ld a, 1 
bbbd b9					cp c 
bbbe 20 67				jr nz, .nodashswap 
bbc0			 
bbc0					; DE has the string to write, working with HL 
bbc0			 
bbc0 06 ff				ld b, 255 
bbc2 d5					push de 
bbc3 e1					pop hl 
bbc4			 
bbc4			if DEBUG_FORTH_DOT 
bbc4				DMARK "DT-" 
bbc4 f5				push af  
bbc5 3a d9 bb			ld a, (.dmark)  
bbc8 32 6b ee			ld (debug_mark),a  
bbcb 3a da bb			ld a, (.dmark+1)  
bbce 32 6c ee			ld (debug_mark+1),a  
bbd1 3a db bb			ld a, (.dmark+2)  
bbd4 32 6d ee			ld (debug_mark+2),a  
bbd7 18 03			jr .pastdmark  
bbd9 ..			.dmark: db "DT-"  
bbdc f1			.pastdmark: pop af  
bbdd			endm  
# End of macro DMARK
bbdd				CALLMONITOR 
bbdd cd 6f ee			call debug_vector  
bbe0				endm  
# End of macro CALLMONITOR
bbe0			endif	 
bbe0 7e			.dashscan:	ld a, (hl) 
bbe1 fe 00				cp 0 
bbe3 28 42				jr z, .nodashswap 
bbe5 fe 2d				cp '-' 
bbe7 20 03				jr nz, .dashskip 
bbe9 3e 20				ld a, ' ' 
bbeb 77					ld (hl), a 
bbec 23			.dashskip:	inc hl 
bbed			if DEBUG_FORTH_DOT 
bbed				DMARK "D-2" 
bbed f5				push af  
bbee 3a 02 bc			ld a, (.dmark)  
bbf1 32 6b ee			ld (debug_mark),a  
bbf4 3a 03 bc			ld a, (.dmark+1)  
bbf7 32 6c ee			ld (debug_mark+1),a  
bbfa 3a 04 bc			ld a, (.dmark+2)  
bbfd 32 6d ee			ld (debug_mark+2),a  
bc00 18 03			jr .pastdmark  
bc02 ..			.dmark: db "D-2"  
bc05 f1			.pastdmark: pop af  
bc06			endm  
# End of macro DMARK
bc06				CALLMONITOR 
bc06 cd 6f ee			call debug_vector  
bc09				endm  
# End of macro CALLMONITOR
bc09			endif	 
bc09 10 d5				djnz .dashscan 
bc0b			 
bc0b			if DEBUG_FORTH_DOT 
bc0b				DMARK "D-1" 
bc0b f5				push af  
bc0c 3a 20 bc			ld a, (.dmark)  
bc0f 32 6b ee			ld (debug_mark),a  
bc12 3a 21 bc			ld a, (.dmark+1)  
bc15 32 6c ee			ld (debug_mark+1),a  
bc18 3a 22 bc			ld a, (.dmark+2)  
bc1b 32 6d ee			ld (debug_mark+2),a  
bc1e 18 03			jr .pastdmark  
bc20 ..			.dmark: db "D-1"  
bc23 f1			.pastdmark: pop af  
bc24			endm  
# End of macro DMARK
bc24				CALLMONITOR 
bc24 cd 6f ee			call debug_vector  
bc27				endm  
# End of macro CALLMONITOR
bc27			endif	 
bc27			 
bc27			.nodashswap: 
bc27			 
bc27			if DEBUG_FORTH_DOT 
bc27				DMARK "D-o" 
bc27 f5				push af  
bc28 3a 3c bc			ld a, (.dmark)  
bc2b 32 6b ee			ld (debug_mark),a  
bc2e 3a 3d bc			ld a, (.dmark+1)  
bc31 32 6c ee			ld (debug_mark+1),a  
bc34 3a 3e bc			ld a, (.dmark+2)  
bc37 32 6d ee			ld (debug_mark+2),a  
bc3a 18 03			jr .pastdmark  
bc3c ..			.dmark: db "D-o"  
bc3f f1			.pastdmark: pop af  
bc40			endm  
# End of macro DMARK
bc40				CALLMONITOR 
bc40 cd 6f ee			call debug_vector  
bc43				endm  
# End of macro CALLMONITOR
bc43			endif	 
bc43			 
bc43 d5					push de   ; save string start in case we need to advance print 
bc44			 
bc44 3a 5e ea				ld a, (f_cursor_ptr) 
bc47 cd c2 8a				call str_at_display 
bc4a 3a 3c ea				ld a,(cli_autodisplay) 
bc4d fe 00				cp 0 
bc4f 28 03				jr z, .noupdate 
bc51 cd d2 8a						call update_display 
bc54					.noupdate: 
bc54			 
bc54			 
bc54					; see if we need to advance the print position 
bc54			 
bc54 e1					pop hl   ; get back string 
bc55			;		ex de,hl 
bc55			 
bc55 3a 3d ea				ld a, (cli_mvdot) 
bc58			if DEBUG_FORTH_DOT 
bc58			;		ld e,a 
bc58				DMARK "D>1" 
bc58 f5				push af  
bc59 3a 6d bc			ld a, (.dmark)  
bc5c 32 6b ee			ld (debug_mark),a  
bc5f 3a 6e bc			ld a, (.dmark+1)  
bc62 32 6c ee			ld (debug_mark+1),a  
bc65 3a 6f bc			ld a, (.dmark+2)  
bc68 32 6d ee			ld (debug_mark+2),a  
bc6b 18 03			jr .pastdmark  
bc6d ..			.dmark: db "D>1"  
bc70 f1			.pastdmark: pop af  
bc71			endm  
# End of macro DMARK
bc71				CALLMONITOR 
bc71 cd 6f ee			call debug_vector  
bc74				endm  
# End of macro CALLMONITOR
bc74			endif	 
bc74 fe 00				cp 0 
bc76 28 44				jr z, .noadv 
bc78					; yes, lets advance the print position 
bc78 3e 00				ld a, 0 
bc7a cd 45 91				call strlent 
bc7d			if DEBUG_FORTH_DOT 
bc7d				DMARK "D-?" 
bc7d f5				push af  
bc7e 3a 92 bc			ld a, (.dmark)  
bc81 32 6b ee			ld (debug_mark),a  
bc84 3a 93 bc			ld a, (.dmark+1)  
bc87 32 6c ee			ld (debug_mark+1),a  
bc8a 3a 94 bc			ld a, (.dmark+2)  
bc8d 32 6d ee			ld (debug_mark+2),a  
bc90 18 03			jr .pastdmark  
bc92 ..			.dmark: db "D-?"  
bc95 f1			.pastdmark: pop af  
bc96			endm  
# End of macro DMARK
bc96				CALLMONITOR 
bc96 cd 6f ee			call debug_vector  
bc99				endm  
# End of macro CALLMONITOR
bc99			endif	 
bc99 3a 5e ea				ld a, (f_cursor_ptr) 
bc9c 85					add a,l 
bc9d					;call addatohl 
bc9d					;ld a, l 
bc9d 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
bca0			 
bca0			if DEBUG_FORTH_DOT 
bca0				DMARK "D->" 
bca0 f5				push af  
bca1 3a b5 bc			ld a, (.dmark)  
bca4 32 6b ee			ld (debug_mark),a  
bca7 3a b6 bc			ld a, (.dmark+1)  
bcaa 32 6c ee			ld (debug_mark+1),a  
bcad 3a b7 bc			ld a, (.dmark+2)  
bcb0 32 6d ee			ld (debug_mark+2),a  
bcb3 18 03			jr .pastdmark  
bcb5 ..			.dmark: db "D->"  
bcb8 f1			.pastdmark: pop af  
bcb9			endm  
# End of macro DMARK
bcb9				CALLMONITOR 
bcb9 cd 6f ee			call debug_vector  
bcbc				endm  
# End of macro CALLMONITOR
bcbc			endif	 
bcbc			 
bcbc			.noadv:	 
bcbc			 
bcbc					if DEBUG_FORTH_DOT_WAIT 
bcbc							call next_page_prompt 
bcbc					endif	 
bcbc			; TODO this pop off the stack causes a crash. i dont know why 
bcbc			 
bcbc			 
bcbc			if DEBUG_FORTH_DOT 
bcbc				DMARK "DTh" 
bcbc f5				push af  
bcbd 3a d1 bc			ld a, (.dmark)  
bcc0 32 6b ee			ld (debug_mark),a  
bcc3 3a d2 bc			ld a, (.dmark+1)  
bcc6 32 6c ee			ld (debug_mark+1),a  
bcc9 3a d3 bc			ld a, (.dmark+2)  
bccc 32 6d ee			ld (debug_mark+2),a  
bccf 18 03			jr .pastdmark  
bcd1 ..			.dmark: db "DTh"  
bcd4 f1			.pastdmark: pop af  
bcd5			endm  
# End of macro DMARK
bcd5				CALLMONITOR 
bcd5 cd 6f ee			call debug_vector  
bcd8				endm  
# End of macro CALLMONITOR
bcd8			endif	 
bcd8			 
bcd8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bcd8 cd e9 9d			call macro_forth_dsp_pop 
bcdb				endm 
# End of macro FORTH_DSP_POP
bcdb			 
bcdb			if DEBUG_FORTH_DOT 
bcdb				DMARK "DTi" 
bcdb f5				push af  
bcdc 3a f0 bc			ld a, (.dmark)  
bcdf 32 6b ee			ld (debug_mark),a  
bce2 3a f1 bc			ld a, (.dmark+1)  
bce5 32 6c ee			ld (debug_mark+1),a  
bce8 3a f2 bc			ld a, (.dmark+2)  
bceb 32 6d ee			ld (debug_mark+2),a  
bcee 18 03			jr .pastdmark  
bcf0 ..			.dmark: db "DTi"  
bcf3 f1			.pastdmark: pop af  
bcf4			endm  
# End of macro DMARK
bcf4				CALLMONITOR 
bcf4 cd 6f ee			call debug_vector  
bcf7				endm  
# End of macro CALLMONITOR
bcf7			endif	 
bcf7			 
bcf7			 
bcf7					NEXTW 
bcf7 c3 e7 9e			jp macro_next 
bcfa				endm 
# End of macro NEXTW
bcfa			 
bcfa			.CLS: 
bcfa				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
bcfa 35				db WORD_SYS_CORE+33             
bcfb 27 bd			dw .DRAW            
bcfd 04				db 3 + 1 
bcfe .. 00			db "CLS",0              
bd02				endm 
# End of macro CWHEAD
bd02			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
bd02					if DEBUG_FORTH_WORDS_KEY 
bd02						DMARK "CLS" 
bd02 f5				push af  
bd03 3a 17 bd			ld a, (.dmark)  
bd06 32 6b ee			ld (debug_mark),a  
bd09 3a 18 bd			ld a, (.dmark+1)  
bd0c 32 6c ee			ld (debug_mark+1),a  
bd0f 3a 19 bd			ld a, (.dmark+2)  
bd12 32 6d ee			ld (debug_mark+2),a  
bd15 18 03			jr .pastdmark  
bd17 ..			.dmark: db "CLS"  
bd1a f1			.pastdmark: pop af  
bd1b			endm  
# End of macro DMARK
bd1b						CALLMONITOR 
bd1b cd 6f ee			call debug_vector  
bd1e				endm  
# End of macro CALLMONITOR
bd1e					endif 
bd1e cd af 8a				call clear_display 
bd21 c3 35 be				jp .home		; and home cursor 
bd24					NEXTW 
bd24 c3 e7 9e			jp macro_next 
bd27				endm 
# End of macro NEXTW
bd27			 
bd27			.DRAW: 
bd27				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
bd27 36				db WORD_SYS_CORE+34             
bd28 52 bd			dw .DUMP            
bd2a 05				db 4 + 1 
bd2b .. 00			db "DRAW",0              
bd30				endm 
# End of macro CWHEAD
bd30			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
bd30					if DEBUG_FORTH_WORDS_KEY 
bd30						DMARK "DRW" 
bd30 f5				push af  
bd31 3a 45 bd			ld a, (.dmark)  
bd34 32 6b ee			ld (debug_mark),a  
bd37 3a 46 bd			ld a, (.dmark+1)  
bd3a 32 6c ee			ld (debug_mark+1),a  
bd3d 3a 47 bd			ld a, (.dmark+2)  
bd40 32 6d ee			ld (debug_mark+2),a  
bd43 18 03			jr .pastdmark  
bd45 ..			.dmark: db "DRW"  
bd48 f1			.pastdmark: pop af  
bd49			endm  
# End of macro DMARK
bd49						CALLMONITOR 
bd49 cd 6f ee			call debug_vector  
bd4c				endm  
# End of macro CALLMONITOR
bd4c					endif 
bd4c cd d2 8a				call update_display 
bd4f					NEXTW 
bd4f c3 e7 9e			jp macro_next 
bd52				endm 
# End of macro NEXTW
bd52			 
bd52			.DUMP: 
bd52				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bd52 37				db WORD_SYS_CORE+35             
bd53 8a bd			dw .CDUMP            
bd55 05				db 4 + 1 
bd56 .. 00			db "DUMP",0              
bd5b				endm 
# End of macro CWHEAD
bd5b			; | DUMP ( x -- ) With address x display dump   | DONE 
bd5b			; TODO pop address to use off of the stack 
bd5b					if DEBUG_FORTH_WORDS_KEY 
bd5b						DMARK "DUM" 
bd5b f5				push af  
bd5c 3a 70 bd			ld a, (.dmark)  
bd5f 32 6b ee			ld (debug_mark),a  
bd62 3a 71 bd			ld a, (.dmark+1)  
bd65 32 6c ee			ld (debug_mark+1),a  
bd68 3a 72 bd			ld a, (.dmark+2)  
bd6b 32 6d ee			ld (debug_mark+2),a  
bd6e 18 03			jr .pastdmark  
bd70 ..			.dmark: db "DUM"  
bd73 f1			.pastdmark: pop af  
bd74			endm  
# End of macro DMARK
bd74						CALLMONITOR 
bd74 cd 6f ee			call debug_vector  
bd77				endm  
# End of macro CALLMONITOR
bd77					endif 
bd77 cd af 8a				call clear_display 
bd7a			 
bd7a					; get address 
bd7a			 
bd7a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd7a cd 31 9d			call macro_dsp_valuehl 
bd7d				endm 
# End of macro FORTH_DSP_VALUEHL
bd7d				 
bd7d					; save it for cdump 
bd7d			 
bd7d 22 e4 e5				ld (os_cur_ptr),hl 
bd80			 
bd80					; destroy value TOS 
bd80			 
bd80					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd80 cd e9 9d			call macro_forth_dsp_pop 
bd83				endm 
# End of macro FORTH_DSP_POP
bd83			 
bd83 cd ba 99				call dumpcont	; skip old style of param parsing	 
bd86 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bd87					NEXTW 
bd87 c3 e7 9e			jp macro_next 
bd8a				endm 
# End of macro NEXTW
bd8a			.CDUMP: 
bd8a				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bd8a 38				db WORD_SYS_CORE+36             
bd8b ba bd			dw .DAT            
bd8d 06				db 5 + 1 
bd8e .. 00			db "CDUMP",0              
bd94				endm 
# End of macro CWHEAD
bd94			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bd94					if DEBUG_FORTH_WORDS_KEY 
bd94						DMARK "CDP" 
bd94 f5				push af  
bd95 3a a9 bd			ld a, (.dmark)  
bd98 32 6b ee			ld (debug_mark),a  
bd9b 3a aa bd			ld a, (.dmark+1)  
bd9e 32 6c ee			ld (debug_mark+1),a  
bda1 3a ab bd			ld a, (.dmark+2)  
bda4 32 6d ee			ld (debug_mark+2),a  
bda7 18 03			jr .pastdmark  
bda9 ..			.dmark: db "CDP"  
bdac f1			.pastdmark: pop af  
bdad			endm  
# End of macro DMARK
bdad						CALLMONITOR 
bdad cd 6f ee			call debug_vector  
bdb0				endm  
# End of macro CALLMONITOR
bdb0					endif 
bdb0 cd af 8a				call clear_display 
bdb3 cd ba 99				call dumpcont	 
bdb6 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bdb7					NEXTW 
bdb7 c3 e7 9e			jp macro_next 
bdba				endm 
# End of macro NEXTW
bdba			 
bdba			 
bdba			 
bdba			 
bdba			.DAT: 
bdba				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bdba 3d				db WORD_SYS_CORE+41             
bdbb 10 be			dw .HOME            
bdbd 03				db 2 + 1 
bdbe .. 00			db "AT",0              
bdc1				endm 
# End of macro CWHEAD
bdc1			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bdc1					if DEBUG_FORTH_WORDS_KEY 
bdc1						DMARK "AT." 
bdc1 f5				push af  
bdc2 3a d6 bd			ld a, (.dmark)  
bdc5 32 6b ee			ld (debug_mark),a  
bdc8 3a d7 bd			ld a, (.dmark+1)  
bdcb 32 6c ee			ld (debug_mark+1),a  
bdce 3a d8 bd			ld a, (.dmark+2)  
bdd1 32 6d ee			ld (debug_mark+2),a  
bdd4 18 03			jr .pastdmark  
bdd6 ..			.dmark: db "AT."  
bdd9 f1			.pastdmark: pop af  
bdda			endm  
# End of macro DMARK
bdda						CALLMONITOR 
bdda cd 6f ee			call debug_vector  
bddd				endm  
# End of macro CALLMONITOR
bddd					endif 
bddd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bddd cd 31 9d			call macro_dsp_valuehl 
bde0				endm 
# End of macro FORTH_DSP_VALUEHL
bde0			 
bde0			 
bde0					; TODO save cursor row 
bde0 7d					ld a,l 
bde1 fe 02				cp 2 
bde3 20 04				jr nz, .crow3 
bde5 3e 28				ld a, display_row_2 
bde7 18 12				jr .ccol1 
bde9 fe 03		.crow3:		cp 3 
bdeb 20 04				jr nz, .crow4 
bded 3e 50				ld a, display_row_3 
bdef 18 0a				jr .ccol1 
bdf1 fe 04		.crow4:		cp 4 
bdf3 20 04				jr nz, .crow1 
bdf5 3e 78				ld a, display_row_4 
bdf7 18 02				jr .ccol1 
bdf9 3e 00		.crow1:		ld a,display_row_1 
bdfb f5			.ccol1:		push af			; got row offset 
bdfc 6f					ld l,a 
bdfd 26 00				ld h,0 
bdff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bdff cd e9 9d			call macro_forth_dsp_pop 
be02				endm 
# End of macro FORTH_DSP_POP
be02					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be02 cd 31 9d			call macro_dsp_valuehl 
be05				endm 
# End of macro FORTH_DSP_VALUEHL
be05					; TODO save cursor col 
be05 f1					pop af 
be06 85					add l		; add col offset 
be07 32 5e ea				ld (f_cursor_ptr), a 
be0a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
be0a cd e9 9d			call macro_forth_dsp_pop 
be0d				endm 
# End of macro FORTH_DSP_POP
be0d			 
be0d					; calculate  
be0d			 
be0d					NEXTW 
be0d c3 e7 9e			jp macro_next 
be10				endm 
# End of macro NEXTW
be10			 
be10			 
be10			.HOME: 
be10				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
be10 41				db WORD_SYS_CORE+45             
be11 3d be			dw .SPACE            
be13 05				db 4 + 1 
be14 .. 00			db "HOME",0              
be19				endm 
# End of macro CWHEAD
be19			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
be19					if DEBUG_FORTH_WORDS_KEY 
be19						DMARK "HOM" 
be19 f5				push af  
be1a 3a 2e be			ld a, (.dmark)  
be1d 32 6b ee			ld (debug_mark),a  
be20 3a 2f be			ld a, (.dmark+1)  
be23 32 6c ee			ld (debug_mark+1),a  
be26 3a 30 be			ld a, (.dmark+2)  
be29 32 6d ee			ld (debug_mark+2),a  
be2c 18 03			jr .pastdmark  
be2e ..			.dmark: db "HOM"  
be31 f1			.pastdmark: pop af  
be32			endm  
# End of macro DMARK
be32						CALLMONITOR 
be32 cd 6f ee			call debug_vector  
be35				endm  
# End of macro CALLMONITOR
be35					endif 
be35 3e 00		.home:		ld a, 0		; and home cursor 
be37 32 5e ea				ld (f_cursor_ptr), a 
be3a					NEXTW 
be3a c3 e7 9e			jp macro_next 
be3d				endm 
# End of macro NEXTW
be3d			 
be3d			 
be3d			.SPACE: 
be3d				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
be3d 46				db WORD_SYS_CORE+50             
be3e 73 be			dw .SPACES            
be40 03				db 2 + 1 
be41 .. 00			db "BL",0              
be44				endm 
# End of macro CWHEAD
be44			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
be44					if DEBUG_FORTH_WORDS_KEY 
be44						DMARK "BL." 
be44 f5				push af  
be45 3a 59 be			ld a, (.dmark)  
be48 32 6b ee			ld (debug_mark),a  
be4b 3a 5a be			ld a, (.dmark+1)  
be4e 32 6c ee			ld (debug_mark+1),a  
be51 3a 5b be			ld a, (.dmark+2)  
be54 32 6d ee			ld (debug_mark+2),a  
be57 18 03			jr .pastdmark  
be59 ..			.dmark: db "BL."  
be5c f1			.pastdmark: pop af  
be5d			endm  
# End of macro DMARK
be5d						CALLMONITOR 
be5d cd 6f ee			call debug_vector  
be60				endm  
# End of macro CALLMONITOR
be60					endif 
be60 3e 20				ld a, " " 
be62 32 c1 e2				ld (scratch),a 
be65 3e 00				ld a, 0 
be67 32 c2 e2				ld (scratch+1),a 
be6a 21 c1 e2				ld hl, scratch 
be6d cd a8 9b				call forth_push_str 
be70					 
be70				       NEXTW 
be70 c3 e7 9e			jp macro_next 
be73				endm 
# End of macro NEXTW
be73			 
be73			;.blstr: db " ", 0 
be73			 
be73			.SPACES: 
be73				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
be73 47				db WORD_SYS_CORE+51             
be74 0e bf			dw .SCROLL            
be76 07				db 6 + 1 
be77 .. 00			db "SPACES",0              
be7e				endm 
# End of macro CWHEAD
be7e			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
be7e					if DEBUG_FORTH_WORDS_KEY 
be7e						DMARK "SPS" 
be7e f5				push af  
be7f 3a 93 be			ld a, (.dmark)  
be82 32 6b ee			ld (debug_mark),a  
be85 3a 94 be			ld a, (.dmark+1)  
be88 32 6c ee			ld (debug_mark+1),a  
be8b 3a 95 be			ld a, (.dmark+2)  
be8e 32 6d ee			ld (debug_mark+2),a  
be91 18 03			jr .pastdmark  
be93 ..			.dmark: db "SPS"  
be96 f1			.pastdmark: pop af  
be97			endm  
# End of macro DMARK
be97						CALLMONITOR 
be97 cd 6f ee			call debug_vector  
be9a				endm  
# End of macro CALLMONITOR
be9a					endif 
be9a			 
be9a			 
be9a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
be9a cd 31 9d			call macro_dsp_valuehl 
be9d				endm 
# End of macro FORTH_DSP_VALUEHL
be9d			 
be9d e5					push hl    ; u 
be9e					if DEBUG_FORTH_WORDS 
be9e						DMARK "SPA" 
be9e f5				push af  
be9f 3a b3 be			ld a, (.dmark)  
bea2 32 6b ee			ld (debug_mark),a  
bea5 3a b4 be			ld a, (.dmark+1)  
bea8 32 6c ee			ld (debug_mark+1),a  
beab 3a b5 be			ld a, (.dmark+2)  
beae 32 6d ee			ld (debug_mark+2),a  
beb1 18 03			jr .pastdmark  
beb3 ..			.dmark: db "SPA"  
beb6 f1			.pastdmark: pop af  
beb7			endm  
# End of macro DMARK
beb7						CALLMONITOR 
beb7 cd 6f ee			call debug_vector  
beba				endm  
# End of macro CALLMONITOR
beba					endif 
beba			 
beba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
beba cd e9 9d			call macro_forth_dsp_pop 
bebd				endm 
# End of macro FORTH_DSP_POP
bebd e1					pop hl 
bebe 0e 00				ld c, 0 
bec0 45					ld b, l 
bec1 21 c1 e2				ld hl, scratch  
bec4			 
bec4					if DEBUG_FORTH_WORDS 
bec4						DMARK "SP2" 
bec4 f5				push af  
bec5 3a d9 be			ld a, (.dmark)  
bec8 32 6b ee			ld (debug_mark),a  
becb 3a da be			ld a, (.dmark+1)  
bece 32 6c ee			ld (debug_mark+1),a  
bed1 3a db be			ld a, (.dmark+2)  
bed4 32 6d ee			ld (debug_mark+2),a  
bed7 18 03			jr .pastdmark  
bed9 ..			.dmark: db "SP2"  
bedc f1			.pastdmark: pop af  
bedd			endm  
# End of macro DMARK
bedd						CALLMONITOR 
bedd cd 6f ee			call debug_vector  
bee0				endm  
# End of macro CALLMONITOR
bee0					endif 
bee0 3e 20				ld a, ' ' 
bee2			.spaces1:	 
bee2 77					ld (hl),a 
bee3 23					inc hl 
bee4					 
bee4 10 fc				djnz .spaces1 
bee6 3e 00				ld a,0 
bee8 77					ld (hl),a 
bee9 21 c1 e2				ld hl, scratch 
beec					if DEBUG_FORTH_WORDS 
beec						DMARK "SP3" 
beec f5				push af  
beed 3a 01 bf			ld a, (.dmark)  
bef0 32 6b ee			ld (debug_mark),a  
bef3 3a 02 bf			ld a, (.dmark+1)  
bef6 32 6c ee			ld (debug_mark+1),a  
bef9 3a 03 bf			ld a, (.dmark+2)  
befc 32 6d ee			ld (debug_mark+2),a  
beff 18 03			jr .pastdmark  
bf01 ..			.dmark: db "SP3"  
bf04 f1			.pastdmark: pop af  
bf05			endm  
# End of macro DMARK
bf05						CALLMONITOR 
bf05 cd 6f ee			call debug_vector  
bf08				endm  
# End of macro CALLMONITOR
bf08					endif 
bf08 cd a8 9b				call forth_push_str 
bf0b			 
bf0b				       NEXTW 
bf0b c3 e7 9e			jp macro_next 
bf0e				endm 
# End of macro NEXTW
bf0e			 
bf0e			 
bf0e			 
bf0e			.SCROLL: 
bf0e				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bf0e 53				db WORD_SYS_CORE+63             
bf0f 3b bf			dw .SCROLLD            
bf11 07				db 6 + 1 
bf12 .. 00			db "SCROLL",0              
bf19				endm 
# End of macro CWHEAD
bf19			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bf19					if DEBUG_FORTH_WORDS_KEY 
bf19						DMARK "SCR" 
bf19 f5				push af  
bf1a 3a 2e bf			ld a, (.dmark)  
bf1d 32 6b ee			ld (debug_mark),a  
bf20 3a 2f bf			ld a, (.dmark+1)  
bf23 32 6c ee			ld (debug_mark+1),a  
bf26 3a 30 bf			ld a, (.dmark+2)  
bf29 32 6d ee			ld (debug_mark+2),a  
bf2c 18 03			jr .pastdmark  
bf2e ..			.dmark: db "SCR"  
bf31 f1			.pastdmark: pop af  
bf32			endm  
# End of macro DMARK
bf32						CALLMONITOR 
bf32 cd 6f ee			call debug_vector  
bf35				endm  
# End of macro CALLMONITOR
bf35					endif 
bf35			 
bf35 cd 71 8a			call scroll_up 
bf38			;	call update_display 
bf38			 
bf38					NEXTW 
bf38 c3 e7 9e			jp macro_next 
bf3b				endm 
# End of macro NEXTW
bf3b			 
bf3b			 
bf3b			 
bf3b			;		; get dir 
bf3b			; 
bf3b			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf3b			; 
bf3b			;		push hl 
bf3b			; 
bf3b			;		; destroy value TOS 
bf3b			; 
bf3b			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf3b			; 
bf3b			;		; get count 
bf3b			; 
bf3b			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf3b			; 
bf3b			;		push hl 
bf3b			; 
bf3b			;		; destroy value TOS 
bf3b			; 
bf3b			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bf3b			; 
bf3b			;		; one value on hl get other one back 
bf3b			; 
bf3b			;		pop bc    ; count 
bf3b			; 
bf3b			;		pop de   ; dir 
bf3b			; 
bf3b			; 
bf3b			;		ld b, c 
bf3b			; 
bf3b			;.scrolldir:     push bc 
bf3b			;		push de 
bf3b			; 
bf3b			;		ld a, 0 
bf3b			;		cp e 
bf3b			;		jr z, .scrollup  
bf3b			;		call scroll_down 
bf3b			;		jr .scrollnext 
bf3b			;.scrollup:	call scroll_up 
bf3b			; 
bf3b			;		 
bf3b			;.scrollnext: 
bf3b			;		pop de 
bf3b			;		pop bc 
bf3b			;		djnz .scrolldir 
bf3b			; 
bf3b			; 
bf3b			; 
bf3b			; 
bf3b			; 
bf3b			;		NEXTW 
bf3b			 
bf3b			.SCROLLD: 
bf3b				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bf3b 53				db WORD_SYS_CORE+63             
bf3c 69 bf			dw .ATQ            
bf3e 08				db 7 + 1 
bf3f .. 00			db "SCROLLD",0              
bf47				endm 
# End of macro CWHEAD
bf47			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bf47					if DEBUG_FORTH_WORDS_KEY 
bf47						DMARK "SCD" 
bf47 f5				push af  
bf48 3a 5c bf			ld a, (.dmark)  
bf4b 32 6b ee			ld (debug_mark),a  
bf4e 3a 5d bf			ld a, (.dmark+1)  
bf51 32 6c ee			ld (debug_mark+1),a  
bf54 3a 5e bf			ld a, (.dmark+2)  
bf57 32 6d ee			ld (debug_mark+2),a  
bf5a 18 03			jr .pastdmark  
bf5c ..			.dmark: db "SCD"  
bf5f f1			.pastdmark: pop af  
bf60			endm  
# End of macro DMARK
bf60						CALLMONITOR 
bf60 cd 6f ee			call debug_vector  
bf63				endm  
# End of macro CALLMONITOR
bf63					endif 
bf63			 
bf63 cd 95 8a			call scroll_down 
bf66			;	call update_display 
bf66			 
bf66					NEXTW 
bf66 c3 e7 9e			jp macro_next 
bf69				endm 
# End of macro NEXTW
bf69			 
bf69			 
bf69			.ATQ: 
bf69				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bf69 62				db WORD_SYS_CORE+78             
bf6a c7 bf			dw .AUTODSP            
bf6c 04				db 3 + 1 
bf6d .. 00			db "AT@",0              
bf71				endm 
# End of macro CWHEAD
bf71			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bf71					if DEBUG_FORTH_WORDS_KEY 
bf71						DMARK "ATA" 
bf71 f5				push af  
bf72 3a 86 bf			ld a, (.dmark)  
bf75 32 6b ee			ld (debug_mark),a  
bf78 3a 87 bf			ld a, (.dmark+1)  
bf7b 32 6c ee			ld (debug_mark+1),a  
bf7e 3a 88 bf			ld a, (.dmark+2)  
bf81 32 6d ee			ld (debug_mark+2),a  
bf84 18 03			jr .pastdmark  
bf86 ..			.dmark: db "ATA"  
bf89 f1			.pastdmark: pop af  
bf8a			endm  
# End of macro DMARK
bf8a						CALLMONITOR 
bf8a cd 6f ee			call debug_vector  
bf8d				endm  
# End of macro CALLMONITOR
bf8d					endif 
bf8d			 
bf8d			 
bf8d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bf8d cd 31 9d			call macro_dsp_valuehl 
bf90				endm 
# End of macro FORTH_DSP_VALUEHL
bf90			 
bf90					; TODO save cursor row 
bf90 7d					ld a,l 
bf91 fe 02				cp 2 
bf93 20 04				jr nz, .crow3aq 
bf95 3e 28				ld a, display_row_2 
bf97 18 12				jr .ccol1aq 
bf99 fe 03		.crow3aq:		cp 3 
bf9b 20 04				jr nz, .crow4aq 
bf9d 3e 50				ld a, display_row_3 
bf9f 18 0a				jr .ccol1aq 
bfa1 fe 04		.crow4aq:		cp 4 
bfa3 20 04				jr nz, .crow1aq 
bfa5 3e 78				ld a, display_row_4 
bfa7 18 02				jr .ccol1aq 
bfa9 3e 00		.crow1aq:		ld a,display_row_1 
bfab f5			.ccol1aq:		push af			; got row offset 
bfac 6f					ld l,a 
bfad 26 00				ld h,0 
bfaf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfaf cd e9 9d			call macro_forth_dsp_pop 
bfb2				endm 
# End of macro FORTH_DSP_POP
bfb2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfb2 cd 31 9d			call macro_dsp_valuehl 
bfb5				endm 
# End of macro FORTH_DSP_VALUEHL
bfb5					; TODO save cursor col 
bfb5 f1					pop af 
bfb6 85					add l		; add col offset 
bfb7			 
bfb7					; add current frame buffer address 
bfb7 2a cc eb				ld hl, (display_fb_active) 
bfba cd dc 8c				call addatohl 
bfbd			 
bfbd			 
bfbd			 
bfbd			 
bfbd					; get char frame buffer location offset in hl 
bfbd			 
bfbd 7e					ld a,(hl) 
bfbe 26 00				ld h, 0 
bfc0 6f					ld l, a 
bfc1			 
bfc1 cd 3a 9b				call forth_push_numhl 
bfc4			 
bfc4			 
bfc4					NEXTW 
bfc4 c3 e7 9e			jp macro_next 
bfc7				endm 
# End of macro NEXTW
bfc7			 
bfc7			.AUTODSP: 
bfc7				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bfc7 63				db WORD_SYS_CORE+79             
bfc8 dd bf			dw .MENU            
bfca 05				db 4 + 1 
bfcb .. 00			db "ADSP",0              
bfd0				endm 
# End of macro CWHEAD
bfd0			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bfd0			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bfd0			 
bfd0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bfd0 cd 31 9d			call macro_dsp_valuehl 
bfd3				endm 
# End of macro FORTH_DSP_VALUEHL
bfd3			 
bfd3			;		push hl 
bfd3			 
bfd3					; destroy value TOS 
bfd3			 
bfd3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bfd3 cd e9 9d			call macro_forth_dsp_pop 
bfd6				endm 
# End of macro FORTH_DSP_POP
bfd6			 
bfd6			;		pop hl 
bfd6			 
bfd6 7d					ld a,l 
bfd7 32 3c ea				ld (cli_autodisplay), a 
bfda				       NEXTW 
bfda c3 e7 9e			jp macro_next 
bfdd				endm 
# End of macro NEXTW
bfdd			 
bfdd			.MENU: 
bfdd				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bfdd 70				db WORD_SYS_CORE+92             
bfde 86 c0			dw .ENDDISPLAY            
bfe0 05				db 4 + 1 
bfe1 .. 00			db "MENU",0              
bfe6				endm 
# End of macro CWHEAD
bfe6			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bfe6			 
bfe6			;		; get number of items on the stack 
bfe6			; 
bfe6				 
bfe6					FORTH_DSP_VALUEHL 
bfe6 cd 31 9d			call macro_dsp_valuehl 
bfe9				endm 
# End of macro FORTH_DSP_VALUEHL
bfe9				 
bfe9					if DEBUG_FORTH_WORDS_KEY 
bfe9						DMARK "MNU" 
bfe9 f5				push af  
bfea 3a fe bf			ld a, (.dmark)  
bfed 32 6b ee			ld (debug_mark),a  
bff0 3a ff bf			ld a, (.dmark+1)  
bff3 32 6c ee			ld (debug_mark+1),a  
bff6 3a 00 c0			ld a, (.dmark+2)  
bff9 32 6d ee			ld (debug_mark+2),a  
bffc 18 03			jr .pastdmark  
bffe ..			.dmark: db "MNU"  
c001 f1			.pastdmark: pop af  
c002			endm  
# End of macro DMARK
c002						CALLMONITOR 
c002 cd 6f ee			call debug_vector  
c005				endm  
# End of macro CALLMONITOR
c005					endif 
c005			 
c005 45					ld b, l	 
c006 05					dec b 
c007			 
c007					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c007 cd e9 9d			call macro_forth_dsp_pop 
c00a				endm 
# End of macro FORTH_DSP_POP
c00a			 
c00a			 
c00a					; go directly through the stack to pluck out the string pointers and build an array 
c00a			 
c00a			;		FORTH_DSP 
c00a			 
c00a					; hl contains top most stack item 
c00a				 
c00a 11 c1 e2				ld de, scratch 
c00d			 
c00d			.mbuild: 
c00d			 
c00d					FORTH_DSP_VALUEHL 
c00d cd 31 9d			call macro_dsp_valuehl 
c010				endm 
# End of macro FORTH_DSP_VALUEHL
c010			 
c010					if DEBUG_FORTH_WORDS 
c010						DMARK "MN3" 
c010 f5				push af  
c011 3a 25 c0			ld a, (.dmark)  
c014 32 6b ee			ld (debug_mark),a  
c017 3a 26 c0			ld a, (.dmark+1)  
c01a 32 6c ee			ld (debug_mark+1),a  
c01d 3a 27 c0			ld a, (.dmark+2)  
c020 32 6d ee			ld (debug_mark+2),a  
c023 18 03			jr .pastdmark  
c025 ..			.dmark: db "MN3"  
c028 f1			.pastdmark: pop af  
c029			endm  
# End of macro DMARK
c029						CALLMONITOR 
c029 cd 6f ee			call debug_vector  
c02c				endm  
# End of macro CALLMONITOR
c02c					endif 
c02c eb					ex de, hl 
c02d 73					ld (hl), e 
c02e 23					inc hl 
c02f 72					ld (hl), d 
c030 23					inc hl 
c031 eb					ex de, hl 
c032			 
c032					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c032 cd e9 9d			call macro_forth_dsp_pop 
c035				endm 
# End of macro FORTH_DSP_POP
c035			 
c035 10 d6				djnz .mbuild 
c037			 
c037					; done add term 
c037			 
c037 eb					ex de, hl 
c038 36 00				ld (hl), 0 
c03a 23					inc hl 
c03b 36 00				ld (hl), 0 
c03d			 
c03d				 
c03d					 
c03d 21 c1 e2				ld hl, scratch 
c040			 
c040					if DEBUG_FORTH_WORDS 
c040						DMARK "MNx" 
c040 f5				push af  
c041 3a 55 c0			ld a, (.dmark)  
c044 32 6b ee			ld (debug_mark),a  
c047 3a 56 c0			ld a, (.dmark+1)  
c04a 32 6c ee			ld (debug_mark+1),a  
c04d 3a 57 c0			ld a, (.dmark+2)  
c050 32 6d ee			ld (debug_mark+2),a  
c053 18 03			jr .pastdmark  
c055 ..			.dmark: db "MNx"  
c058 f1			.pastdmark: pop af  
c059			endm  
# End of macro DMARK
c059						CALLMONITOR 
c059 cd 6f ee			call debug_vector  
c05c				endm  
# End of macro CALLMONITOR
c05c					endif 
c05c			 
c05c			 
c05c			 
c05c 3e 00				ld a, 0 
c05e cd e0 8a				call menu 
c061			 
c061			 
c061 6f					ld l, a 
c062 26 00				ld h, 0 
c064			 
c064					if DEBUG_FORTH_WORDS 
c064						DMARK "MNr" 
c064 f5				push af  
c065 3a 79 c0			ld a, (.dmark)  
c068 32 6b ee			ld (debug_mark),a  
c06b 3a 7a c0			ld a, (.dmark+1)  
c06e 32 6c ee			ld (debug_mark+1),a  
c071 3a 7b c0			ld a, (.dmark+2)  
c074 32 6d ee			ld (debug_mark+2),a  
c077 18 03			jr .pastdmark  
c079 ..			.dmark: db "MNr"  
c07c f1			.pastdmark: pop af  
c07d			endm  
# End of macro DMARK
c07d						CALLMONITOR 
c07d cd 6f ee			call debug_vector  
c080				endm  
# End of macro CALLMONITOR
c080					endif 
c080			 
c080 cd 3a 9b				call forth_push_numhl 
c083			 
c083			 
c083			 
c083			 
c083				       NEXTW 
c083 c3 e7 9e			jp macro_next 
c086				endm 
# End of macro NEXTW
c086			 
c086			 
c086			.ENDDISPLAY: 
c086			 
c086			; eof 
# End of file forth_words_display.asm
c086			include "forth_words_str.asm" 
c086			 
c086			; | ## String Words 
c086			 
c086			.PTR:   
c086			 
c086				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
c086 48				db WORD_SYS_CORE+52             
c087 b3 c0			dw .STYPE            
c089 04				db 3 + 1 
c08a .. 00			db "PTR",0              
c08e				endm 
# End of macro CWHEAD
c08e			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
c08e			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
c08e			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
c08e			 
c08e					if DEBUG_FORTH_WORDS_KEY 
c08e						DMARK "PTR" 
c08e f5				push af  
c08f 3a a3 c0			ld a, (.dmark)  
c092 32 6b ee			ld (debug_mark),a  
c095 3a a4 c0			ld a, (.dmark+1)  
c098 32 6c ee			ld (debug_mark+1),a  
c09b 3a a5 c0			ld a, (.dmark+2)  
c09e 32 6d ee			ld (debug_mark+2),a  
c0a1 18 03			jr .pastdmark  
c0a3 ..			.dmark: db "PTR"  
c0a6 f1			.pastdmark: pop af  
c0a7			endm  
# End of macro DMARK
c0a7						CALLMONITOR 
c0a7 cd 6f ee			call debug_vector  
c0aa				endm  
# End of macro CALLMONITOR
c0aa					endif 
c0aa					FORTH_DSP_VALUEHL 
c0aa cd 31 9d			call macro_dsp_valuehl 
c0ad				endm 
# End of macro FORTH_DSP_VALUEHL
c0ad cd 3a 9b				call forth_push_numhl 
c0b0			 
c0b0			 
c0b0					NEXTW 
c0b0 c3 e7 9e			jp macro_next 
c0b3				endm 
# End of macro NEXTW
c0b3			.STYPE: 
c0b3				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
c0b3 48				db WORD_SYS_CORE+52             
c0b4 02 c1			dw .UPPER            
c0b6 06				db 5 + 1 
c0b7 .. 00			db "STYPE",0              
c0bd				endm 
# End of macro CWHEAD
c0bd			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
c0bd					if DEBUG_FORTH_WORDS_KEY 
c0bd						DMARK "STY" 
c0bd f5				push af  
c0be 3a d2 c0			ld a, (.dmark)  
c0c1 32 6b ee			ld (debug_mark),a  
c0c4 3a d3 c0			ld a, (.dmark+1)  
c0c7 32 6c ee			ld (debug_mark+1),a  
c0ca 3a d4 c0			ld a, (.dmark+2)  
c0cd 32 6d ee			ld (debug_mark+2),a  
c0d0 18 03			jr .pastdmark  
c0d2 ..			.dmark: db "STY"  
c0d5 f1			.pastdmark: pop af  
c0d6			endm  
# End of macro DMARK
c0d6						CALLMONITOR 
c0d6 cd 6f ee			call debug_vector  
c0d9				endm  
# End of macro CALLMONITOR
c0d9					endif 
c0d9					FORTH_DSP 
c0d9 cd f7 9c			call macro_forth_dsp 
c0dc				endm 
# End of macro FORTH_DSP
c0dc					;v5 FORTH_DSP_VALUE 
c0dc			 
c0dc 7e					ld a, (hl) 
c0dd			 
c0dd f5					push af 
c0de			 
c0de			; Dont destroy TOS		FORTH_DSP_POP 
c0de			 
c0de f1					pop af 
c0df			 
c0df fe 01				cp DS_TYPE_STR 
c0e1 28 09				jr z, .typestr 
c0e3			 
c0e3 fe 02				cp DS_TYPE_INUM 
c0e5 28 0a				jr z, .typeinum 
c0e7			 
c0e7 21 00 c1				ld hl, .tna 
c0ea 18 0a				jr .tpush 
c0ec			 
c0ec 21 fc c0		.typestr:	ld hl, .tstr 
c0ef 18 05				jr .tpush 
c0f1 21 fe c0		.typeinum:	ld hl, .tinum 
c0f4 18 00				jr .tpush 
c0f6			 
c0f6			.tpush: 
c0f6			 
c0f6 cd a8 9b				call forth_push_str 
c0f9			 
c0f9					NEXTW 
c0f9 c3 e7 9e			jp macro_next 
c0fc				endm 
# End of macro NEXTW
c0fc .. 00		.tstr:	db "s",0 
c0fe .. 00		.tinum:  db "i",0 
c100 .. 00		.tna:   db "?", 0 
c102			 
c102			 
c102			.UPPER: 
c102				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
c102 48				db WORD_SYS_CORE+52             
c103 3d c1			dw .LOWER            
c105 06				db 5 + 1 
c106 .. 00			db "UPPER",0              
c10c				endm 
# End of macro CWHEAD
c10c			; | UPPER ( s -- s ) Upper case string s  | DONE 
c10c					if DEBUG_FORTH_WORDS_KEY 
c10c						DMARK "UPR" 
c10c f5				push af  
c10d 3a 21 c1			ld a, (.dmark)  
c110 32 6b ee			ld (debug_mark),a  
c113 3a 22 c1			ld a, (.dmark+1)  
c116 32 6c ee			ld (debug_mark+1),a  
c119 3a 23 c1			ld a, (.dmark+2)  
c11c 32 6d ee			ld (debug_mark+2),a  
c11f 18 03			jr .pastdmark  
c121 ..			.dmark: db "UPR"  
c124 f1			.pastdmark: pop af  
c125			endm  
# End of macro DMARK
c125						CALLMONITOR 
c125 cd 6f ee			call debug_vector  
c128				endm  
# End of macro CALLMONITOR
c128					endif 
c128			 
c128					FORTH_DSP 
c128 cd f7 9c			call macro_forth_dsp 
c12b				endm 
# End of macro FORTH_DSP
c12b					 
c12b			; TODO check is string type 
c12b			 
c12b					FORTH_DSP_VALUEHL 
c12b cd 31 9d			call macro_dsp_valuehl 
c12e				endm 
# End of macro FORTH_DSP_VALUEHL
c12e			; get pointer to string in hl 
c12e			 
c12e 7e			.toup:		ld a, (hl) 
c12f fe 00				cp 0 
c131 28 07				jr z, .toupdone 
c133			 
c133 cd 49 90				call to_upper 
c136			 
c136 77					ld (hl), a 
c137 23					inc hl 
c138 18 f4				jr .toup 
c13a			 
c13a					 
c13a			 
c13a			 
c13a			; for each char convert to upper 
c13a					 
c13a			.toupdone: 
c13a			 
c13a			 
c13a					NEXTW 
c13a c3 e7 9e			jp macro_next 
c13d				endm 
# End of macro NEXTW
c13d			.LOWER: 
c13d				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
c13d 48				db WORD_SYS_CORE+52             
c13e 78 c1			dw .TCASE            
c140 06				db 5 + 1 
c141 .. 00			db "LOWER",0              
c147				endm 
# End of macro CWHEAD
c147			; | LOWER ( s -- s ) Lower case string s  | DONE 
c147					if DEBUG_FORTH_WORDS_KEY 
c147						DMARK "LWR" 
c147 f5				push af  
c148 3a 5c c1			ld a, (.dmark)  
c14b 32 6b ee			ld (debug_mark),a  
c14e 3a 5d c1			ld a, (.dmark+1)  
c151 32 6c ee			ld (debug_mark+1),a  
c154 3a 5e c1			ld a, (.dmark+2)  
c157 32 6d ee			ld (debug_mark+2),a  
c15a 18 03			jr .pastdmark  
c15c ..			.dmark: db "LWR"  
c15f f1			.pastdmark: pop af  
c160			endm  
# End of macro DMARK
c160						CALLMONITOR 
c160 cd 6f ee			call debug_vector  
c163				endm  
# End of macro CALLMONITOR
c163					endif 
c163			 
c163					FORTH_DSP 
c163 cd f7 9c			call macro_forth_dsp 
c166				endm 
# End of macro FORTH_DSP
c166					 
c166			; TODO check is string type 
c166			 
c166					FORTH_DSP_VALUEHL 
c166 cd 31 9d			call macro_dsp_valuehl 
c169				endm 
# End of macro FORTH_DSP_VALUEHL
c169			; get pointer to string in hl 
c169			 
c169 7e			.tolow:		ld a, (hl) 
c16a fe 00				cp 0 
c16c 28 07				jr z, .tolowdone 
c16e			 
c16e cd 52 90				call to_lower 
c171			 
c171 77					ld (hl), a 
c172 23					inc hl 
c173 18 f4				jr .tolow 
c175			 
c175					 
c175			 
c175			 
c175			; for each char convert to low 
c175					 
c175			.tolowdone: 
c175					NEXTW 
c175 c3 e7 9e			jp macro_next 
c178				endm 
# End of macro NEXTW
c178			.TCASE: 
c178				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
c178 48				db WORD_SYS_CORE+52             
c179 ae c2			dw .SUBSTR            
c17b 06				db 5 + 1 
c17c .. 00			db "TCASE",0              
c182				endm 
# End of macro CWHEAD
c182			; | TCASE ( s -- s ) Title case string s  | DONE 
c182					if DEBUG_FORTH_WORDS_KEY 
c182						DMARK "TCS" 
c182 f5				push af  
c183 3a 97 c1			ld a, (.dmark)  
c186 32 6b ee			ld (debug_mark),a  
c189 3a 98 c1			ld a, (.dmark+1)  
c18c 32 6c ee			ld (debug_mark+1),a  
c18f 3a 99 c1			ld a, (.dmark+2)  
c192 32 6d ee			ld (debug_mark+2),a  
c195 18 03			jr .pastdmark  
c197 ..			.dmark: db "TCS"  
c19a f1			.pastdmark: pop af  
c19b			endm  
# End of macro DMARK
c19b						CALLMONITOR 
c19b cd 6f ee			call debug_vector  
c19e				endm  
# End of macro CALLMONITOR
c19e					endif 
c19e			 
c19e					FORTH_DSP 
c19e cd f7 9c			call macro_forth_dsp 
c1a1				endm 
# End of macro FORTH_DSP
c1a1					 
c1a1			; TODO check is string type 
c1a1			 
c1a1					FORTH_DSP_VALUEHL 
c1a1 cd 31 9d			call macro_dsp_valuehl 
c1a4				endm 
# End of macro FORTH_DSP_VALUEHL
c1a4			; get pointer to string in hl 
c1a4			 
c1a4					if DEBUG_FORTH_WORDS 
c1a4						DMARK "TC1" 
c1a4 f5				push af  
c1a5 3a b9 c1			ld a, (.dmark)  
c1a8 32 6b ee			ld (debug_mark),a  
c1ab 3a ba c1			ld a, (.dmark+1)  
c1ae 32 6c ee			ld (debug_mark+1),a  
c1b1 3a bb c1			ld a, (.dmark+2)  
c1b4 32 6d ee			ld (debug_mark+2),a  
c1b7 18 03			jr .pastdmark  
c1b9 ..			.dmark: db "TC1"  
c1bc f1			.pastdmark: pop af  
c1bd			endm  
# End of macro DMARK
c1bd						CALLMONITOR 
c1bd cd 6f ee			call debug_vector  
c1c0				endm  
# End of macro CALLMONITOR
c1c0					endif 
c1c0			 
c1c0					; first time in turn to upper case first char 
c1c0			 
c1c0 7e					ld a, (hl) 
c1c1 c3 4b c2				jp .totsiptou 
c1c4			 
c1c4			 
c1c4 7e			.tot:		ld a, (hl) 
c1c5 fe 00				cp 0 
c1c7 ca 8f c2				jp z, .totdone 
c1ca			 
c1ca					if DEBUG_FORTH_WORDS 
c1ca						DMARK "TC2" 
c1ca f5				push af  
c1cb 3a df c1			ld a, (.dmark)  
c1ce 32 6b ee			ld (debug_mark),a  
c1d1 3a e0 c1			ld a, (.dmark+1)  
c1d4 32 6c ee			ld (debug_mark+1),a  
c1d7 3a e1 c1			ld a, (.dmark+2)  
c1da 32 6d ee			ld (debug_mark+2),a  
c1dd 18 03			jr .pastdmark  
c1df ..			.dmark: db "TC2"  
c1e2 f1			.pastdmark: pop af  
c1e3			endm  
# End of macro DMARK
c1e3						CALLMONITOR 
c1e3 cd 6f ee			call debug_vector  
c1e6				endm  
# End of macro CALLMONITOR
c1e6					endif 
c1e6					; check to see if current char is a space 
c1e6			 
c1e6 fe 20				cp ' ' 
c1e8 28 21				jr z, .totsp 
c1ea cd 52 90				call to_lower 
c1ed					if DEBUG_FORTH_WORDS 
c1ed						DMARK "TC3" 
c1ed f5				push af  
c1ee 3a 02 c2			ld a, (.dmark)  
c1f1 32 6b ee			ld (debug_mark),a  
c1f4 3a 03 c2			ld a, (.dmark+1)  
c1f7 32 6c ee			ld (debug_mark+1),a  
c1fa 3a 04 c2			ld a, (.dmark+2)  
c1fd 32 6d ee			ld (debug_mark+2),a  
c200 18 03			jr .pastdmark  
c202 ..			.dmark: db "TC3"  
c205 f1			.pastdmark: pop af  
c206			endm  
# End of macro DMARK
c206						CALLMONITOR 
c206 cd 6f ee			call debug_vector  
c209				endm  
# End of macro CALLMONITOR
c209					endif 
c209 18 63				jr .totnxt 
c20b			 
c20b			.totsp:         ; on a space, find next char which should be upper 
c20b			 
c20b					if DEBUG_FORTH_WORDS 
c20b						DMARK "TC4" 
c20b f5				push af  
c20c 3a 20 c2			ld a, (.dmark)  
c20f 32 6b ee			ld (debug_mark),a  
c212 3a 21 c2			ld a, (.dmark+1)  
c215 32 6c ee			ld (debug_mark+1),a  
c218 3a 22 c2			ld a, (.dmark+2)  
c21b 32 6d ee			ld (debug_mark+2),a  
c21e 18 03			jr .pastdmark  
c220 ..			.dmark: db "TC4"  
c223 f1			.pastdmark: pop af  
c224			endm  
# End of macro DMARK
c224						CALLMONITOR 
c224 cd 6f ee			call debug_vector  
c227				endm  
# End of macro CALLMONITOR
c227					endif 
c227					;; 
c227			 
c227 fe 20				cp ' ' 
c229 20 20				jr nz, .totsiptou 
c22b 23					inc hl 
c22c 7e					ld a, (hl) 
c22d					if DEBUG_FORTH_WORDS 
c22d						DMARK "TC5" 
c22d f5				push af  
c22e 3a 42 c2			ld a, (.dmark)  
c231 32 6b ee			ld (debug_mark),a  
c234 3a 43 c2			ld a, (.dmark+1)  
c237 32 6c ee			ld (debug_mark+1),a  
c23a 3a 44 c2			ld a, (.dmark+2)  
c23d 32 6d ee			ld (debug_mark+2),a  
c240 18 03			jr .pastdmark  
c242 ..			.dmark: db "TC5"  
c245 f1			.pastdmark: pop af  
c246			endm  
# End of macro DMARK
c246						CALLMONITOR 
c246 cd 6f ee			call debug_vector  
c249				endm  
# End of macro CALLMONITOR
c249					endif 
c249 18 c0				jr .totsp 
c24b fe 00		.totsiptou:    cp 0 
c24d 28 40				jr z, .totdone 
c24f					; not space and not zero term so upper case it 
c24f cd 49 90				call to_upper 
c252			 
c252					if DEBUG_FORTH_WORDS 
c252						DMARK "TC6" 
c252 f5				push af  
c253 3a 67 c2			ld a, (.dmark)  
c256 32 6b ee			ld (debug_mark),a  
c259 3a 68 c2			ld a, (.dmark+1)  
c25c 32 6c ee			ld (debug_mark+1),a  
c25f 3a 69 c2			ld a, (.dmark+2)  
c262 32 6d ee			ld (debug_mark+2),a  
c265 18 03			jr .pastdmark  
c267 ..			.dmark: db "TC6"  
c26a f1			.pastdmark: pop af  
c26b			endm  
# End of macro DMARK
c26b						CALLMONITOR 
c26b cd 6f ee			call debug_vector  
c26e				endm  
# End of macro CALLMONITOR
c26e					endif 
c26e			 
c26e			 
c26e			.totnxt: 
c26e			 
c26e 77					ld (hl), a 
c26f 23					inc hl 
c270					if DEBUG_FORTH_WORDS 
c270						DMARK "TC7" 
c270 f5				push af  
c271 3a 85 c2			ld a, (.dmark)  
c274 32 6b ee			ld (debug_mark),a  
c277 3a 86 c2			ld a, (.dmark+1)  
c27a 32 6c ee			ld (debug_mark+1),a  
c27d 3a 87 c2			ld a, (.dmark+2)  
c280 32 6d ee			ld (debug_mark+2),a  
c283 18 03			jr .pastdmark  
c285 ..			.dmark: db "TC7"  
c288 f1			.pastdmark: pop af  
c289			endm  
# End of macro DMARK
c289						CALLMONITOR 
c289 cd 6f ee			call debug_vector  
c28c				endm  
# End of macro CALLMONITOR
c28c					endif 
c28c c3 c4 c1				jp .tot 
c28f			 
c28f					 
c28f			 
c28f			 
c28f			; for each char convert to low 
c28f					 
c28f			.totdone: 
c28f					if DEBUG_FORTH_WORDS 
c28f						DMARK "TCd" 
c28f f5				push af  
c290 3a a4 c2			ld a, (.dmark)  
c293 32 6b ee			ld (debug_mark),a  
c296 3a a5 c2			ld a, (.dmark+1)  
c299 32 6c ee			ld (debug_mark+1),a  
c29c 3a a6 c2			ld a, (.dmark+2)  
c29f 32 6d ee			ld (debug_mark+2),a  
c2a2 18 03			jr .pastdmark  
c2a4 ..			.dmark: db "TCd"  
c2a7 f1			.pastdmark: pop af  
c2a8			endm  
# End of macro DMARK
c2a8						CALLMONITOR 
c2a8 cd 6f ee			call debug_vector  
c2ab				endm  
# End of macro CALLMONITOR
c2ab					endif 
c2ab					NEXTW 
c2ab c3 e7 9e			jp macro_next 
c2ae				endm 
# End of macro NEXTW
c2ae			 
c2ae			.SUBSTR: 
c2ae				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c2ae 48				db WORD_SYS_CORE+52             
c2af 0c c3			dw .LEFT            
c2b1 07				db 6 + 1 
c2b2 .. 00			db "SUBSTR",0              
c2b9				endm 
# End of macro CWHEAD
c2b9			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c2b9			 
c2b9					if DEBUG_FORTH_WORDS_KEY 
c2b9						DMARK "SST" 
c2b9 f5				push af  
c2ba 3a ce c2			ld a, (.dmark)  
c2bd 32 6b ee			ld (debug_mark),a  
c2c0 3a cf c2			ld a, (.dmark+1)  
c2c3 32 6c ee			ld (debug_mark+1),a  
c2c6 3a d0 c2			ld a, (.dmark+2)  
c2c9 32 6d ee			ld (debug_mark+2),a  
c2cc 18 03			jr .pastdmark  
c2ce ..			.dmark: db "SST"  
c2d1 f1			.pastdmark: pop af  
c2d2			endm  
# End of macro DMARK
c2d2						CALLMONITOR 
c2d2 cd 6f ee			call debug_vector  
c2d5				endm  
# End of macro CALLMONITOR
c2d5					endif 
c2d5			; TODO check string type 
c2d5					FORTH_DSP_VALUEHL 
c2d5 cd 31 9d			call macro_dsp_valuehl 
c2d8				endm 
# End of macro FORTH_DSP_VALUEHL
c2d8			 
c2d8 e5					push hl      ; string length 
c2d9			 
c2d9					FORTH_DSP_POP 
c2d9 cd e9 9d			call macro_forth_dsp_pop 
c2dc				endm 
# End of macro FORTH_DSP_POP
c2dc			 
c2dc					FORTH_DSP_VALUEHL 
c2dc cd 31 9d			call macro_dsp_valuehl 
c2df				endm 
# End of macro FORTH_DSP_VALUEHL
c2df			 
c2df e5					push hl     ; start char 
c2e0			 
c2e0					FORTH_DSP_POP 
c2e0 cd e9 9d			call macro_forth_dsp_pop 
c2e3				endm 
# End of macro FORTH_DSP_POP
c2e3			 
c2e3			 
c2e3					FORTH_DSP_VALUE 
c2e3 cd 1a 9d			call macro_forth_dsp_value 
c2e6				endm 
# End of macro FORTH_DSP_VALUE
c2e6			 
c2e6 d1					pop de    ; get start post offset 
c2e7			 
c2e7 19					add hl, de    ; starting offset 
c2e8			 
c2e8 c1					pop bc 
c2e9 c5					push bc      ; grab size of string 
c2ea			 
c2ea e5					push hl    ; save string start  
c2eb			 
c2eb 26 00				ld h, 0 
c2ed 69					ld l, c 
c2ee 23					inc hl 
c2ef 23					inc hl 
c2f0			 
c2f0 cd a3 91				call malloc 
c2f3				if DEBUG_FORTH_MALLOC_GUARD 
c2f3 cc 26 cc				call z,malloc_error 
c2f6				endif 
c2f6			 
c2f6 eb					ex de, hl      ; save malloc area for string copy 
c2f7 e1					pop hl    ; get back source 
c2f8 c1					pop bc    ; get length of string back 
c2f9			 
c2f9 d5					push de    ; save malloc area for after we push 
c2fa ed b0				ldir     ; copy substr 
c2fc			 
c2fc			 
c2fc eb					ex de, hl 
c2fd 3e 00				ld a, 0 
c2ff 77					ld (hl), a   ; term substr 
c300			 
c300					 
c300 e1					pop hl    ; get malloc so we can push it 
c301 e5					push hl   ; save so we can free it afterwards 
c302			 
c302 cd a8 9b				call forth_push_str 
c305			 
c305 e1					pop hl 
c306 cd 6d 92				call free 
c309			 
c309					 
c309					 
c309			 
c309			 
c309					NEXTW 
c309 c3 e7 9e			jp macro_next 
c30c				endm 
# End of macro NEXTW
c30c			 
c30c			.LEFT: 
c30c				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c30c 48				db WORD_SYS_CORE+52             
c30d 34 c3			dw .RIGHT            
c30f 05				db 4 + 1 
c310 .. 00			db "LEFT",0              
c315				endm 
# End of macro CWHEAD
c315			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c315					if DEBUG_FORTH_WORDS_KEY 
c315						DMARK "LEF" 
c315 f5				push af  
c316 3a 2a c3			ld a, (.dmark)  
c319 32 6b ee			ld (debug_mark),a  
c31c 3a 2b c3			ld a, (.dmark+1)  
c31f 32 6c ee			ld (debug_mark+1),a  
c322 3a 2c c3			ld a, (.dmark+2)  
c325 32 6d ee			ld (debug_mark+2),a  
c328 18 03			jr .pastdmark  
c32a ..			.dmark: db "LEF"  
c32d f1			.pastdmark: pop af  
c32e			endm  
# End of macro DMARK
c32e						CALLMONITOR 
c32e cd 6f ee			call debug_vector  
c331				endm  
# End of macro CALLMONITOR
c331					endif 
c331			 
c331					NEXTW 
c331 c3 e7 9e			jp macro_next 
c334				endm 
# End of macro NEXTW
c334			.RIGHT: 
c334				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c334 48				db WORD_SYS_CORE+52             
c335 5d c3			dw .STR2NUM            
c337 06				db 5 + 1 
c338 .. 00			db "RIGHT",0              
c33e				endm 
# End of macro CWHEAD
c33e			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c33e					if DEBUG_FORTH_WORDS_KEY 
c33e						DMARK "RIG" 
c33e f5				push af  
c33f 3a 53 c3			ld a, (.dmark)  
c342 32 6b ee			ld (debug_mark),a  
c345 3a 54 c3			ld a, (.dmark+1)  
c348 32 6c ee			ld (debug_mark+1),a  
c34b 3a 55 c3			ld a, (.dmark+2)  
c34e 32 6d ee			ld (debug_mark+2),a  
c351 18 03			jr .pastdmark  
c353 ..			.dmark: db "RIG"  
c356 f1			.pastdmark: pop af  
c357			endm  
# End of macro DMARK
c357						CALLMONITOR 
c357 cd 6f ee			call debug_vector  
c35a				endm  
# End of macro CALLMONITOR
c35a					endif 
c35a			 
c35a					NEXTW 
c35a c3 e7 9e			jp macro_next 
c35d				endm 
# End of macro NEXTW
c35d			 
c35d			 
c35d			.STR2NUM: 
c35d				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c35d 48				db WORD_SYS_CORE+52             
c35e e9 c3			dw .NUM2STR            
c360 08				db 7 + 1 
c361 .. 00			db "STR2NUM",0              
c369				endm 
# End of macro CWHEAD
c369			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c369			 
c369			 
c369			; TODO STR type check to do 
c369					if DEBUG_FORTH_WORDS_KEY 
c369						DMARK "S2N" 
c369 f5				push af  
c36a 3a 7e c3			ld a, (.dmark)  
c36d 32 6b ee			ld (debug_mark),a  
c370 3a 7f c3			ld a, (.dmark+1)  
c373 32 6c ee			ld (debug_mark+1),a  
c376 3a 80 c3			ld a, (.dmark+2)  
c379 32 6d ee			ld (debug_mark+2),a  
c37c 18 03			jr .pastdmark  
c37e ..			.dmark: db "S2N"  
c381 f1			.pastdmark: pop af  
c382			endm  
# End of macro DMARK
c382						CALLMONITOR 
c382 cd 6f ee			call debug_vector  
c385				endm  
# End of macro CALLMONITOR
c385					endif 
c385			 
c385					;FORTH_DSP 
c385					FORTH_DSP_VALUE 
c385 cd 1a 9d			call macro_forth_dsp_value 
c388				endm 
# End of macro FORTH_DSP_VALUE
c388					;inc hl 
c388			 
c388 eb					ex de, hl 
c389					if DEBUG_FORTH_WORDS 
c389						DMARK "S2a" 
c389 f5				push af  
c38a 3a 9e c3			ld a, (.dmark)  
c38d 32 6b ee			ld (debug_mark),a  
c390 3a 9f c3			ld a, (.dmark+1)  
c393 32 6c ee			ld (debug_mark+1),a  
c396 3a a0 c3			ld a, (.dmark+2)  
c399 32 6d ee			ld (debug_mark+2),a  
c39c 18 03			jr .pastdmark  
c39e ..			.dmark: db "S2a"  
c3a1 f1			.pastdmark: pop af  
c3a2			endm  
# End of macro DMARK
c3a2						CALLMONITOR 
c3a2 cd 6f ee			call debug_vector  
c3a5				endm  
# End of macro CALLMONITOR
c3a5					endif 
c3a5 cd d1 90				call string_to_uint16 
c3a8			 
c3a8					if DEBUG_FORTH_WORDS 
c3a8						DMARK "S2b" 
c3a8 f5				push af  
c3a9 3a bd c3			ld a, (.dmark)  
c3ac 32 6b ee			ld (debug_mark),a  
c3af 3a be c3			ld a, (.dmark+1)  
c3b2 32 6c ee			ld (debug_mark+1),a  
c3b5 3a bf c3			ld a, (.dmark+2)  
c3b8 32 6d ee			ld (debug_mark+2),a  
c3bb 18 03			jr .pastdmark  
c3bd ..			.dmark: db "S2b"  
c3c0 f1			.pastdmark: pop af  
c3c1			endm  
# End of macro DMARK
c3c1						CALLMONITOR 
c3c1 cd 6f ee			call debug_vector  
c3c4				endm  
# End of macro CALLMONITOR
c3c4					endif 
c3c4			;		push hl 
c3c4					FORTH_DSP_POP 
c3c4 cd e9 9d			call macro_forth_dsp_pop 
c3c7				endm 
# End of macro FORTH_DSP_POP
c3c7			;		pop hl 
c3c7					 
c3c7					if DEBUG_FORTH_WORDS 
c3c7						DMARK "S2b" 
c3c7 f5				push af  
c3c8 3a dc c3			ld a, (.dmark)  
c3cb 32 6b ee			ld (debug_mark),a  
c3ce 3a dd c3			ld a, (.dmark+1)  
c3d1 32 6c ee			ld (debug_mark+1),a  
c3d4 3a de c3			ld a, (.dmark+2)  
c3d7 32 6d ee			ld (debug_mark+2),a  
c3da 18 03			jr .pastdmark  
c3dc ..			.dmark: db "S2b"  
c3df f1			.pastdmark: pop af  
c3e0			endm  
# End of macro DMARK
c3e0						CALLMONITOR 
c3e0 cd 6f ee			call debug_vector  
c3e3				endm  
# End of macro CALLMONITOR
c3e3					endif 
c3e3 cd 3a 9b				call forth_push_numhl	 
c3e6			 
c3e6				 
c3e6				       NEXTW 
c3e6 c3 e7 9e			jp macro_next 
c3e9				endm 
# End of macro NEXTW
c3e9			.NUM2STR: 
c3e9				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c3e9 48				db WORD_SYS_CORE+52             
c3ea f8 c3			dw .CONCAT            
c3ec 08				db 7 + 1 
c3ed .. 00			db "NUM2STR",0              
c3f5				endm 
# End of macro CWHEAD
c3f5			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
c3f5			 
c3f5			;		; malloc a string to target 
c3f5			;		ld hl, 10     ; TODO max string size should be fine 
c3f5			;		call malloc 
c3f5			;		push hl    ; save malloc location 
c3f5			; 
c3f5			; 
c3f5			;; TODO check int type 
c3f5			;		FORTH_DSP_VALUEHL 
c3f5			;		ld a, l 
c3f5			;		call DispAToASCII   
c3f5			;;TODO need to chage above call to dump into string 
c3f5			; 
c3f5			; 
c3f5			 
c3f5				       NEXTW 
c3f5 c3 e7 9e			jp macro_next 
c3f8				endm 
# End of macro NEXTW
c3f8			 
c3f8			.CONCAT: 
c3f8				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c3f8 48				db WORD_SYS_CORE+52             
c3f9 ab c4			dw .FIND            
c3fb 07				db 6 + 1 
c3fc .. 00			db "CONCAT",0              
c403				endm 
# End of macro CWHEAD
c403			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c403			 
c403			; TODO check string type 
c403			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c403			 
c403					if DEBUG_FORTH_WORDS_KEY 
c403						DMARK "CON" 
c403 f5				push af  
c404 3a 18 c4			ld a, (.dmark)  
c407 32 6b ee			ld (debug_mark),a  
c40a 3a 19 c4			ld a, (.dmark+1)  
c40d 32 6c ee			ld (debug_mark+1),a  
c410 3a 1a c4			ld a, (.dmark+2)  
c413 32 6d ee			ld (debug_mark+2),a  
c416 18 03			jr .pastdmark  
c418 ..			.dmark: db "CON"  
c41b f1			.pastdmark: pop af  
c41c			endm  
# End of macro DMARK
c41c						CALLMONITOR 
c41c cd 6f ee			call debug_vector  
c41f				endm  
# End of macro CALLMONITOR
c41f					endif 
c41f			 
c41f			 
c41f					FORTH_DSP_VALUE 
c41f cd 1a 9d			call macro_forth_dsp_value 
c422				endm 
# End of macro FORTH_DSP_VALUE
c422 e5					push hl   ; s2 
c423			 
c423					FORTH_DSP_POP 
c423 cd e9 9d			call macro_forth_dsp_pop 
c426				endm 
# End of macro FORTH_DSP_POP
c426			 
c426					FORTH_DSP_VALUE 
c426 cd 1a 9d			call macro_forth_dsp_value 
c429				endm 
# End of macro FORTH_DSP_VALUE
c429			 
c429 e5					push hl   ; s1 
c42a			 
c42a					FORTH_DSP_POP 
c42a cd e9 9d			call macro_forth_dsp_pop 
c42d				endm 
# End of macro FORTH_DSP_POP
c42d					 
c42d			 
c42d					; copy s1 
c42d			 
c42d				 
c42d					; save ptr 
c42d e1					pop hl  
c42e e5					push hl 
c42f 3e 00				ld a, 0 
c431 cd 45 91				call strlent 
c434					;inc hl    ; zer0 
c434 06 00				ld b, 0 
c436 4d					ld c, l 
c437 e1					pop hl		 
c438 11 c1 e2				ld de, scratch	 
c43b					if DEBUG_FORTH_WORDS 
c43b						DMARK "CO1" 
c43b f5				push af  
c43c 3a 50 c4			ld a, (.dmark)  
c43f 32 6b ee			ld (debug_mark),a  
c442 3a 51 c4			ld a, (.dmark+1)  
c445 32 6c ee			ld (debug_mark+1),a  
c448 3a 52 c4			ld a, (.dmark+2)  
c44b 32 6d ee			ld (debug_mark+2),a  
c44e 18 03			jr .pastdmark  
c450 ..			.dmark: db "CO1"  
c453 f1			.pastdmark: pop af  
c454			endm  
# End of macro DMARK
c454						CALLMONITOR 
c454 cd 6f ee			call debug_vector  
c457				endm  
# End of macro CALLMONITOR
c457					endif 
c457 ed b0				ldir 
c459			 
c459 e1					pop hl 
c45a e5					push hl 
c45b d5					push de 
c45c			 
c45c			 
c45c 3e 00				ld a, 0 
c45e cd 45 91				call strlent 
c461 23					inc hl    ; zer0 
c462 23					inc hl 
c463 06 00				ld b, 0 
c465 4d					ld c, l 
c466 d1					pop de 
c467 e1					pop hl		 
c468					if DEBUG_FORTH_WORDS 
c468						DMARK "CO2" 
c468 f5				push af  
c469 3a 7d c4			ld a, (.dmark)  
c46c 32 6b ee			ld (debug_mark),a  
c46f 3a 7e c4			ld a, (.dmark+1)  
c472 32 6c ee			ld (debug_mark+1),a  
c475 3a 7f c4			ld a, (.dmark+2)  
c478 32 6d ee			ld (debug_mark+2),a  
c47b 18 03			jr .pastdmark  
c47d ..			.dmark: db "CO2"  
c480 f1			.pastdmark: pop af  
c481			endm  
# End of macro DMARK
c481						CALLMONITOR 
c481 cd 6f ee			call debug_vector  
c484				endm  
# End of macro CALLMONITOR
c484					endif 
c484 ed b0				ldir 
c486			 
c486			 
c486			 
c486 21 c1 e2				ld hl, scratch 
c489					if DEBUG_FORTH_WORDS 
c489						DMARK "CO5" 
c489 f5				push af  
c48a 3a 9e c4			ld a, (.dmark)  
c48d 32 6b ee			ld (debug_mark),a  
c490 3a 9f c4			ld a, (.dmark+1)  
c493 32 6c ee			ld (debug_mark+1),a  
c496 3a a0 c4			ld a, (.dmark+2)  
c499 32 6d ee			ld (debug_mark+2),a  
c49c 18 03			jr .pastdmark  
c49e ..			.dmark: db "CO5"  
c4a1 f1			.pastdmark: pop af  
c4a2			endm  
# End of macro DMARK
c4a2						CALLMONITOR 
c4a2 cd 6f ee			call debug_vector  
c4a5				endm  
# End of macro CALLMONITOR
c4a5					endif 
c4a5			 
c4a5 cd a8 9b				call forth_push_str 
c4a8			 
c4a8			 
c4a8			 
c4a8			 
c4a8				       NEXTW 
c4a8 c3 e7 9e			jp macro_next 
c4ab				endm 
# End of macro NEXTW
c4ab			 
c4ab			 
c4ab			.FIND: 
c4ab				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c4ab 4b				db WORD_SYS_CORE+55             
c4ac 69 c5			dw .LEN            
c4ae 05				db 4 + 1 
c4af .. 00			db "FIND",0              
c4b4				endm 
# End of macro CWHEAD
c4b4			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c4b4			 
c4b4					if DEBUG_FORTH_WORDS_KEY 
c4b4						DMARK "FND" 
c4b4 f5				push af  
c4b5 3a c9 c4			ld a, (.dmark)  
c4b8 32 6b ee			ld (debug_mark),a  
c4bb 3a ca c4			ld a, (.dmark+1)  
c4be 32 6c ee			ld (debug_mark+1),a  
c4c1 3a cb c4			ld a, (.dmark+2)  
c4c4 32 6d ee			ld (debug_mark+2),a  
c4c7 18 03			jr .pastdmark  
c4c9 ..			.dmark: db "FND"  
c4cc f1			.pastdmark: pop af  
c4cd			endm  
# End of macro DMARK
c4cd						CALLMONITOR 
c4cd cd 6f ee			call debug_vector  
c4d0				endm  
# End of macro CALLMONITOR
c4d0					endif 
c4d0			 
c4d0			; TODO check string type 
c4d0					FORTH_DSP_VALUE 
c4d0 cd 1a 9d			call macro_forth_dsp_value 
c4d3				endm 
# End of macro FORTH_DSP_VALUE
c4d3			 
c4d3 e5					push hl    
c4d4 7e					ld a,(hl)    ; char to find   
c4d5			; TODO change char to substr 
c4d5			 
c4d5 f5					push af 
c4d6					 
c4d6			 
c4d6			 
c4d6					if DEBUG_FORTH_WORDS 
c4d6						DMARK "FN1" 
c4d6 f5				push af  
c4d7 3a eb c4			ld a, (.dmark)  
c4da 32 6b ee			ld (debug_mark),a  
c4dd 3a ec c4			ld a, (.dmark+1)  
c4e0 32 6c ee			ld (debug_mark+1),a  
c4e3 3a ed c4			ld a, (.dmark+2)  
c4e6 32 6d ee			ld (debug_mark+2),a  
c4e9 18 03			jr .pastdmark  
c4eb ..			.dmark: db "FN1"  
c4ee f1			.pastdmark: pop af  
c4ef			endm  
# End of macro DMARK
c4ef						CALLMONITOR 
c4ef cd 6f ee			call debug_vector  
c4f2				endm  
# End of macro CALLMONITOR
c4f2					endif 
c4f2			 
c4f2					FORTH_DSP_POP 
c4f2 cd e9 9d			call macro_forth_dsp_pop 
c4f5				endm 
# End of macro FORTH_DSP_POP
c4f5			 
c4f5					; string to search 
c4f5			 
c4f5					FORTH_DSP_VALUE 
c4f5 cd 1a 9d			call macro_forth_dsp_value 
c4f8				endm 
# End of macro FORTH_DSP_VALUE
c4f8			 
c4f8 d1					pop de  ; d is char to find  
c4f9			 
c4f9					if DEBUG_FORTH_WORDS 
c4f9						DMARK "FN2" 
c4f9 f5				push af  
c4fa 3a 0e c5			ld a, (.dmark)  
c4fd 32 6b ee			ld (debug_mark),a  
c500 3a 0f c5			ld a, (.dmark+1)  
c503 32 6c ee			ld (debug_mark+1),a  
c506 3a 10 c5			ld a, (.dmark+2)  
c509 32 6d ee			ld (debug_mark+2),a  
c50c 18 03			jr .pastdmark  
c50e ..			.dmark: db "FN2"  
c511 f1			.pastdmark: pop af  
c512			endm  
# End of macro DMARK
c512						CALLMONITOR 
c512 cd 6f ee			call debug_vector  
c515				endm  
# End of macro CALLMONITOR
c515					endif 
c515					 
c515 01 00 00				ld bc, 0 
c518 7e			.findchar:      ld a,(hl) 
c519 fe 00				cp 0   		 
c51b 28 27				jr z, .finddone     
c51d ba					cp d 
c51e 28 20				jr z, .foundchar 
c520 03					inc bc 
c521 23					inc hl 
c522					if DEBUG_FORTH_WORDS 
c522						DMARK "FN3" 
c522 f5				push af  
c523 3a 37 c5			ld a, (.dmark)  
c526 32 6b ee			ld (debug_mark),a  
c529 3a 38 c5			ld a, (.dmark+1)  
c52c 32 6c ee			ld (debug_mark+1),a  
c52f 3a 39 c5			ld a, (.dmark+2)  
c532 32 6d ee			ld (debug_mark+2),a  
c535 18 03			jr .pastdmark  
c537 ..			.dmark: db "FN3"  
c53a f1			.pastdmark: pop af  
c53b			endm  
# End of macro DMARK
c53b						CALLMONITOR 
c53b cd 6f ee			call debug_vector  
c53e				endm  
# End of macro CALLMONITOR
c53e					endif 
c53e 18 d8				jr .findchar 
c540			 
c540			 
c540 c5			.foundchar:	push bc 
c541 e1					pop hl 
c542 18 03				jr .findexit 
c544			 
c544			 
c544							 
c544			 
c544			.finddone:     ; got to end of string with no find 
c544 21 00 00				ld hl, 0 
c547			.findexit: 
c547			 
c547					if DEBUG_FORTH_WORDS 
c547						DMARK "FNd" 
c547 f5				push af  
c548 3a 5c c5			ld a, (.dmark)  
c54b 32 6b ee			ld (debug_mark),a  
c54e 3a 5d c5			ld a, (.dmark+1)  
c551 32 6c ee			ld (debug_mark+1),a  
c554 3a 5e c5			ld a, (.dmark+2)  
c557 32 6d ee			ld (debug_mark+2),a  
c55a 18 03			jr .pastdmark  
c55c ..			.dmark: db "FNd"  
c55f f1			.pastdmark: pop af  
c560			endm  
# End of macro DMARK
c560						CALLMONITOR 
c560 cd 6f ee			call debug_vector  
c563				endm  
# End of macro CALLMONITOR
c563					endif 
c563 cd 3a 9b			call forth_push_numhl 
c566			 
c566				       NEXTW 
c566 c3 e7 9e			jp macro_next 
c569				endm 
# End of macro NEXTW
c569			 
c569			.LEN: 
c569				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
c569 4c				db WORD_SYS_CORE+56             
c56a d3 c5			dw .ASC            
c56c 06				db 5 + 1 
c56d .. 00			db "COUNT",0              
c573				endm 
# End of macro CWHEAD
c573			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c573			 
c573					if DEBUG_FORTH_WORDS_KEY 
c573						DMARK "CNT" 
c573 f5				push af  
c574 3a 88 c5			ld a, (.dmark)  
c577 32 6b ee			ld (debug_mark),a  
c57a 3a 89 c5			ld a, (.dmark+1)  
c57d 32 6c ee			ld (debug_mark+1),a  
c580 3a 8a c5			ld a, (.dmark+2)  
c583 32 6d ee			ld (debug_mark+2),a  
c586 18 03			jr .pastdmark  
c588 ..			.dmark: db "CNT"  
c58b f1			.pastdmark: pop af  
c58c			endm  
# End of macro DMARK
c58c						CALLMONITOR 
c58c cd 6f ee			call debug_vector  
c58f				endm  
# End of macro CALLMONITOR
c58f					endif 
c58f			; TODO check string type 
c58f					FORTH_DSP_VALUE 
c58f cd 1a 9d			call macro_forth_dsp_value 
c592				endm 
# End of macro FORTH_DSP_VALUE
c592			 
c592			 
c592					if DEBUG_FORTH_WORDS 
c592						DMARK "CN?" 
c592 f5				push af  
c593 3a a7 c5			ld a, (.dmark)  
c596 32 6b ee			ld (debug_mark),a  
c599 3a a8 c5			ld a, (.dmark+1)  
c59c 32 6c ee			ld (debug_mark+1),a  
c59f 3a a9 c5			ld a, (.dmark+2)  
c5a2 32 6d ee			ld (debug_mark+2),a  
c5a5 18 03			jr .pastdmark  
c5a7 ..			.dmark: db "CN?"  
c5aa f1			.pastdmark: pop af  
c5ab			endm  
# End of macro DMARK
c5ab						CALLMONITOR 
c5ab cd 6f ee			call debug_vector  
c5ae				endm  
# End of macro CALLMONITOR
c5ae					endif 
c5ae cd 3a 91				call strlenz 
c5b1					if DEBUG_FORTH_WORDS 
c5b1						DMARK "CNl" 
c5b1 f5				push af  
c5b2 3a c6 c5			ld a, (.dmark)  
c5b5 32 6b ee			ld (debug_mark),a  
c5b8 3a c7 c5			ld a, (.dmark+1)  
c5bb 32 6c ee			ld (debug_mark+1),a  
c5be 3a c8 c5			ld a, (.dmark+2)  
c5c1 32 6d ee			ld (debug_mark+2),a  
c5c4 18 03			jr .pastdmark  
c5c6 ..			.dmark: db "CNl"  
c5c9 f1			.pastdmark: pop af  
c5ca			endm  
# End of macro DMARK
c5ca						CALLMONITOR 
c5ca cd 6f ee			call debug_vector  
c5cd				endm  
# End of macro CALLMONITOR
c5cd					endif 
c5cd			 
c5cd cd 3a 9b				call forth_push_numhl 
c5d0			 
c5d0			 
c5d0			 
c5d0				       NEXTW 
c5d0 c3 e7 9e			jp macro_next 
c5d3				endm 
# End of macro NEXTW
c5d3			.ASC: 
c5d3				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
c5d3 4d				db WORD_SYS_CORE+57             
c5d4 41 c6			dw .CHR            
c5d6 04				db 3 + 1 
c5d7 .. 00			db "ASC",0              
c5db				endm 
# End of macro CWHEAD
c5db			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c5db					if DEBUG_FORTH_WORDS_KEY 
c5db						DMARK "ASC" 
c5db f5				push af  
c5dc 3a f0 c5			ld a, (.dmark)  
c5df 32 6b ee			ld (debug_mark),a  
c5e2 3a f1 c5			ld a, (.dmark+1)  
c5e5 32 6c ee			ld (debug_mark+1),a  
c5e8 3a f2 c5			ld a, (.dmark+2)  
c5eb 32 6d ee			ld (debug_mark+2),a  
c5ee 18 03			jr .pastdmark  
c5f0 ..			.dmark: db "ASC"  
c5f3 f1			.pastdmark: pop af  
c5f4			endm  
# End of macro DMARK
c5f4						CALLMONITOR 
c5f4 cd 6f ee			call debug_vector  
c5f7				endm  
# End of macro CALLMONITOR
c5f7					endif 
c5f7					FORTH_DSP_VALUE 
c5f7 cd 1a 9d			call macro_forth_dsp_value 
c5fa				endm 
# End of macro FORTH_DSP_VALUE
c5fa					;v5 FORTH_DSP_VALUE 
c5fa			;		inc hl      ; now at start of numeric as string 
c5fa			 
c5fa e5					push hl 
c5fb			 
c5fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c5fb cd e9 9d			call macro_forth_dsp_pop 
c5fe				endm 
# End of macro FORTH_DSP_POP
c5fe			 
c5fe e1					pop hl 
c5ff			 
c5ff					if DEBUG_FORTH_WORDS 
c5ff						DMARK "AS1" 
c5ff f5				push af  
c600 3a 14 c6			ld a, (.dmark)  
c603 32 6b ee			ld (debug_mark),a  
c606 3a 15 c6			ld a, (.dmark+1)  
c609 32 6c ee			ld (debug_mark+1),a  
c60c 3a 16 c6			ld a, (.dmark+2)  
c60f 32 6d ee			ld (debug_mark+2),a  
c612 18 03			jr .pastdmark  
c614 ..			.dmark: db "AS1"  
c617 f1			.pastdmark: pop af  
c618			endm  
# End of macro DMARK
c618						CALLMONITOR 
c618 cd 6f ee			call debug_vector  
c61b				endm  
# End of macro CALLMONITOR
c61b					endif 
c61b					; push the content of a onto the stack as a value 
c61b			 
c61b 7e					ld a,(hl)   ; get char 
c61c 26 00				ld h,0 
c61e 6f					ld l,a 
c61f					if DEBUG_FORTH_WORDS 
c61f						DMARK "AS2" 
c61f f5				push af  
c620 3a 34 c6			ld a, (.dmark)  
c623 32 6b ee			ld (debug_mark),a  
c626 3a 35 c6			ld a, (.dmark+1)  
c629 32 6c ee			ld (debug_mark+1),a  
c62c 3a 36 c6			ld a, (.dmark+2)  
c62f 32 6d ee			ld (debug_mark+2),a  
c632 18 03			jr .pastdmark  
c634 ..			.dmark: db "AS2"  
c637 f1			.pastdmark: pop af  
c638			endm  
# End of macro DMARK
c638						CALLMONITOR 
c638 cd 6f ee			call debug_vector  
c63b				endm  
# End of macro CALLMONITOR
c63b					endif 
c63b cd 3a 9b				call forth_push_numhl 
c63e			 
c63e				       NEXTW 
c63e c3 e7 9e			jp macro_next 
c641				endm 
# End of macro NEXTW
c641			 
c641			.CHR: 
c641				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
c641 4d				db WORD_SYS_CORE+57             
c642 7d c6			dw .ENDSTR            
c644 04				db 3 + 1 
c645 .. 00			db "CHR",0              
c649				endm 
# End of macro CWHEAD
c649			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
c649					if DEBUG_FORTH_WORDS_KEY 
c649						DMARK "CHR" 
c649 f5				push af  
c64a 3a 5e c6			ld a, (.dmark)  
c64d 32 6b ee			ld (debug_mark),a  
c650 3a 5f c6			ld a, (.dmark+1)  
c653 32 6c ee			ld (debug_mark+1),a  
c656 3a 60 c6			ld a, (.dmark+2)  
c659 32 6d ee			ld (debug_mark+2),a  
c65c 18 03			jr .pastdmark  
c65e ..			.dmark: db "CHR"  
c661 f1			.pastdmark: pop af  
c662			endm  
# End of macro DMARK
c662						CALLMONITOR 
c662 cd 6f ee			call debug_vector  
c665				endm  
# End of macro CALLMONITOR
c665					endif 
c665					FORTH_DSP_VALUEHL 
c665 cd 31 9d			call macro_dsp_valuehl 
c668				endm 
# End of macro FORTH_DSP_VALUEHL
c668			 
c668					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c668 cd e9 9d			call macro_forth_dsp_pop 
c66b				endm 
# End of macro FORTH_DSP_POP
c66b			 
c66b					; save asci byte as a zero term string and push string 
c66b			 
c66b 7d					ld a,l 
c66c 32 c1 e2				ld (scratch), a 
c66f			 
c66f 3e 00				ld a, 0 
c671 32 c2 e2				ld (scratch+1), a 
c674			 
c674 21 c1 e2				ld hl, scratch 
c677 cd a8 9b				call forth_push_str 
c67a			 
c67a			 
c67a				       NEXTW 
c67a c3 e7 9e			jp macro_next 
c67d				endm 
# End of macro NEXTW
c67d			 
c67d			 
c67d			 
c67d			 
c67d			.ENDSTR: 
c67d			; eof 
c67d			 
# End of file forth_words_str.asm
c67d			include "forth_words_key.asm" 
c67d			 
c67d			; | ## Keyboard Words 
c67d			 
c67d			.KEY: 
c67d				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c67d 3e				db WORD_SYS_CORE+42             
c67e ad c6			dw .WAITK            
c680 04				db 3 + 1 
c681 .. 00			db "KEY",0              
c685				endm 
# End of macro CWHEAD
c685			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c685			 
c685					if DEBUG_FORTH_WORDS_KEY 
c685						DMARK "KEY" 
c685 f5				push af  
c686 3a 9a c6			ld a, (.dmark)  
c689 32 6b ee			ld (debug_mark),a  
c68c 3a 9b c6			ld a, (.dmark+1)  
c68f 32 6c ee			ld (debug_mark+1),a  
c692 3a 9c c6			ld a, (.dmark+2)  
c695 32 6d ee			ld (debug_mark+2),a  
c698 18 03			jr .pastdmark  
c69a ..			.dmark: db "KEY"  
c69d f1			.pastdmark: pop af  
c69e			endm  
# End of macro DMARK
c69e						CALLMONITOR 
c69e cd 6f ee			call debug_vector  
c6a1				endm  
# End of macro CALLMONITOR
c6a1					endif 
c6a1			; TODO currently waits 
c6a1 cd 1d e4				call cin 
c6a4					;call cin_wait 
c6a4 6f					ld l, a 
c6a5 26 00				ld h, 0 
c6a7 cd 3a 9b				call forth_push_numhl 
c6aa					NEXTW 
c6aa c3 e7 9e			jp macro_next 
c6ad				endm 
# End of macro NEXTW
c6ad			.WAITK: 
c6ad				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c6ad 3f				db WORD_SYS_CORE+43             
c6ae df c6			dw .ACCEPT            
c6b0 06				db 5 + 1 
c6b1 .. 00			db "WAITK",0              
c6b7				endm 
# End of macro CWHEAD
c6b7			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c6b7					if DEBUG_FORTH_WORDS_KEY 
c6b7						DMARK "WAI" 
c6b7 f5				push af  
c6b8 3a cc c6			ld a, (.dmark)  
c6bb 32 6b ee			ld (debug_mark),a  
c6be 3a cd c6			ld a, (.dmark+1)  
c6c1 32 6c ee			ld (debug_mark+1),a  
c6c4 3a ce c6			ld a, (.dmark+2)  
c6c7 32 6d ee			ld (debug_mark+2),a  
c6ca 18 03			jr .pastdmark  
c6cc ..			.dmark: db "WAI"  
c6cf f1			.pastdmark: pop af  
c6d0			endm  
# End of macro DMARK
c6d0						CALLMONITOR 
c6d0 cd 6f ee			call debug_vector  
c6d3				endm  
# End of macro CALLMONITOR
c6d3					endif 
c6d3 cd 17 e4				call cin_wait 
c6d6 6f					ld l, a 
c6d7 26 00				ld h, 0 
c6d9 cd 3a 9b				call forth_push_numhl 
c6dc					NEXTW 
c6dc c3 e7 9e			jp macro_next 
c6df				endm 
# End of macro NEXTW
c6df			.ACCEPT: 
c6df				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c6df 40				db WORD_SYS_CORE+44             
c6e0 3d c7			dw .EDIT            
c6e2 07				db 6 + 1 
c6e3 .. 00			db "ACCEPT",0              
c6ea				endm 
# End of macro CWHEAD
c6ea			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c6ea					; TODO crashes on push 
c6ea					if DEBUG_FORTH_WORDS_KEY 
c6ea						DMARK "ACC" 
c6ea f5				push af  
c6eb 3a ff c6			ld a, (.dmark)  
c6ee 32 6b ee			ld (debug_mark),a  
c6f1 3a 00 c7			ld a, (.dmark+1)  
c6f4 32 6c ee			ld (debug_mark+1),a  
c6f7 3a 01 c7			ld a, (.dmark+2)  
c6fa 32 6d ee			ld (debug_mark+2),a  
c6fd 18 03			jr .pastdmark  
c6ff ..			.dmark: db "ACC"  
c702 f1			.pastdmark: pop af  
c703			endm  
# End of macro DMARK
c703						CALLMONITOR 
c703 cd 6f ee			call debug_vector  
c706				endm  
# End of macro CALLMONITOR
c706					endif 
c706 21 bf e4				ld hl, os_input 
c709 3e 00				ld a, 0 
c70b 77					ld (hl),a 
c70c 3a 5e ea				ld a,(f_cursor_ptr) 
c70f 16 64				ld d, 100 
c711 0e 00				ld c, 0 
c713 1e 28				ld e, 40 
c715 cd 09 8d				call input_str 
c718					; TODO perhaps do a type check and wrap in quotes if not a number 
c718 21 bf e4				ld hl, os_input 
c71b					if DEBUG_FORTH_WORDS 
c71b						DMARK "AC1" 
c71b f5				push af  
c71c 3a 30 c7			ld a, (.dmark)  
c71f 32 6b ee			ld (debug_mark),a  
c722 3a 31 c7			ld a, (.dmark+1)  
c725 32 6c ee			ld (debug_mark+1),a  
c728 3a 32 c7			ld a, (.dmark+2)  
c72b 32 6d ee			ld (debug_mark+2),a  
c72e 18 03			jr .pastdmark  
c730 ..			.dmark: db "AC1"  
c733 f1			.pastdmark: pop af  
c734			endm  
# End of macro DMARK
c734						CALLMONITOR 
c734 cd 6f ee			call debug_vector  
c737				endm  
# End of macro CALLMONITOR
c737					endif 
c737 cd a8 9b				call forth_push_str 
c73a					NEXTW 
c73a c3 e7 9e			jp macro_next 
c73d				endm 
# End of macro NEXTW
c73d			 
c73d			.EDIT: 
c73d				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
c73d 40				db WORD_SYS_CORE+44             
c73e df c7			dw .DEDIT            
c740 05				db 4 + 1 
c741 .. 00			db "EDIT",0              
c746				endm 
# End of macro CWHEAD
c746			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c746			 
c746					; TODO does not copy from stack 
c746					if DEBUG_FORTH_WORDS_KEY 
c746						DMARK "EDT" 
c746 f5				push af  
c747 3a 5b c7			ld a, (.dmark)  
c74a 32 6b ee			ld (debug_mark),a  
c74d 3a 5c c7			ld a, (.dmark+1)  
c750 32 6c ee			ld (debug_mark+1),a  
c753 3a 5d c7			ld a, (.dmark+2)  
c756 32 6d ee			ld (debug_mark+2),a  
c759 18 03			jr .pastdmark  
c75b ..			.dmark: db "EDT"  
c75e f1			.pastdmark: pop af  
c75f			endm  
# End of macro DMARK
c75f						CALLMONITOR 
c75f cd 6f ee			call debug_vector  
c762				endm  
# End of macro CALLMONITOR
c762					endif 
c762			 
c762					;FORTH_DSP 
c762					FORTH_DSP_VALUEHL 
c762 cd 31 9d			call macro_dsp_valuehl 
c765				endm 
# End of macro FORTH_DSP_VALUEHL
c765			;		inc hl    ; TODO do type check 
c765			 
c765			;		call get_word_hl 
c765 e5					push hl 
c766					if DEBUG_FORTH_WORDS 
c766						DMARK "EDp" 
c766 f5				push af  
c767 3a 7b c7			ld a, (.dmark)  
c76a 32 6b ee			ld (debug_mark),a  
c76d 3a 7c c7			ld a, (.dmark+1)  
c770 32 6c ee			ld (debug_mark+1),a  
c773 3a 7d c7			ld a, (.dmark+2)  
c776 32 6d ee			ld (debug_mark+2),a  
c779 18 03			jr .pastdmark  
c77b ..			.dmark: db "EDp"  
c77e f1			.pastdmark: pop af  
c77f			endm  
# End of macro DMARK
c77f						CALLMONITOR 
c77f cd 6f ee			call debug_vector  
c782				endm  
# End of macro CALLMONITOR
c782					endif 
c782				;	ld a, 0 
c782 cd 3a 91				call strlenz 
c785 23					inc hl 
c786			 
c786 06 00				ld b, 0 
c788 4d					ld c, l 
c789			 
c789 e1					pop hl 
c78a 11 bf e4				ld de, os_input 
c78d					if DEBUG_FORTH_WORDS_KEY 
c78d						DMARK "EDc" 
c78d f5				push af  
c78e 3a a2 c7			ld a, (.dmark)  
c791 32 6b ee			ld (debug_mark),a  
c794 3a a3 c7			ld a, (.dmark+1)  
c797 32 6c ee			ld (debug_mark+1),a  
c79a 3a a4 c7			ld a, (.dmark+2)  
c79d 32 6d ee			ld (debug_mark+2),a  
c7a0 18 03			jr .pastdmark  
c7a2 ..			.dmark: db "EDc"  
c7a5 f1			.pastdmark: pop af  
c7a6			endm  
# End of macro DMARK
c7a6						CALLMONITOR 
c7a6 cd 6f ee			call debug_vector  
c7a9				endm  
# End of macro CALLMONITOR
c7a9					endif 
c7a9 ed b0				ldir 
c7ab			 
c7ab			 
c7ab 21 bf e4				ld hl, os_input 
c7ae					;ld a, 0 
c7ae					;ld (hl),a 
c7ae 3a 5e ea				ld a,(f_cursor_ptr) 
c7b1 16 64				ld d, 100 
c7b3 0e 00				ld c, 0 
c7b5 1e 28				ld e, 40 
c7b7 cd 09 8d				call input_str 
c7ba					; TODO perhaps do a type check and wrap in quotes if not a number 
c7ba 21 bf e4				ld hl, os_input 
c7bd					if DEBUG_FORTH_WORDS 
c7bd						DMARK "ED1" 
c7bd f5				push af  
c7be 3a d2 c7			ld a, (.dmark)  
c7c1 32 6b ee			ld (debug_mark),a  
c7c4 3a d3 c7			ld a, (.dmark+1)  
c7c7 32 6c ee			ld (debug_mark+1),a  
c7ca 3a d4 c7			ld a, (.dmark+2)  
c7cd 32 6d ee			ld (debug_mark+2),a  
c7d0 18 03			jr .pastdmark  
c7d2 ..			.dmark: db "ED1"  
c7d5 f1			.pastdmark: pop af  
c7d6			endm  
# End of macro DMARK
c7d6						CALLMONITOR 
c7d6 cd 6f ee			call debug_vector  
c7d9				endm  
# End of macro CALLMONITOR
c7d9					endif 
c7d9 cd a8 9b				call forth_push_str 
c7dc					NEXTW 
c7dc c3 e7 9e			jp macro_next 
c7df				endm 
# End of macro NEXTW
c7df			 
c7df			.DEDIT: 
c7df				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
c7df 40				db WORD_SYS_CORE+44             
c7e0 41 c8			dw .ENDKEY            
c7e2 06				db 5 + 1 
c7e3 .. 00			db "DEDIT",0              
c7e9				endm 
# End of macro CWHEAD
c7e9			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
c7e9			 
c7e9					; TODO does not copy from stack 
c7e9					if DEBUG_FORTH_WORDS_KEY 
c7e9						DMARK "DED" 
c7e9 f5				push af  
c7ea 3a fe c7			ld a, (.dmark)  
c7ed 32 6b ee			ld (debug_mark),a  
c7f0 3a ff c7			ld a, (.dmark+1)  
c7f3 32 6c ee			ld (debug_mark+1),a  
c7f6 3a 00 c8			ld a, (.dmark+2)  
c7f9 32 6d ee			ld (debug_mark+2),a  
c7fc 18 03			jr .pastdmark  
c7fe ..			.dmark: db "DED"  
c801 f1			.pastdmark: pop af  
c802			endm  
# End of macro DMARK
c802						CALLMONITOR 
c802 cd 6f ee			call debug_vector  
c805				endm  
# End of macro CALLMONITOR
c805					endif 
c805			 
c805					;FORTH_DSP 
c805					FORTH_DSP_VALUEHL 
c805 cd 31 9d			call macro_dsp_valuehl 
c808				endm 
# End of macro FORTH_DSP_VALUEHL
c808			;		inc hl    ; TODO do type check 
c808			 
c808			;		call get_word_hl 
c808 e5					push hl 
c809 e5					push hl 
c80a					FORTH_DSP_POP 
c80a cd e9 9d			call macro_forth_dsp_pop 
c80d				endm 
# End of macro FORTH_DSP_POP
c80d e1					pop hl 
c80e					if DEBUG_FORTH_WORDS 
c80e						DMARK "EDp" 
c80e f5				push af  
c80f 3a 23 c8			ld a, (.dmark)  
c812 32 6b ee			ld (debug_mark),a  
c815 3a 24 c8			ld a, (.dmark+1)  
c818 32 6c ee			ld (debug_mark+1),a  
c81b 3a 25 c8			ld a, (.dmark+2)  
c81e 32 6d ee			ld (debug_mark+2),a  
c821 18 03			jr .pastdmark  
c823 ..			.dmark: db "EDp"  
c826 f1			.pastdmark: pop af  
c827			endm  
# End of macro DMARK
c827						CALLMONITOR 
c827 cd 6f ee			call debug_vector  
c82a				endm  
# End of macro CALLMONITOR
c82a					endif 
c82a				;	ld a, 0 
c82a cd 3a 91				call strlenz 
c82d 23					inc hl 
c82e			 
c82e 06 00				ld b, 0 
c830 4d					ld c, l 
c831			 
c831 e1					pop hl 
c832			 
c832					;ld a, 0 
c832					;ld (hl),a 
c832 3a 5e ea				ld a,(f_cursor_ptr) 
c835 16 64				ld d, 100 
c837 0e 00				ld c, 0 
c839 1e 28				ld e, 40 
c83b cd 09 8d				call input_str 
c83e					; TODO perhaps do a type check and wrap in quotes if not a number 
c83e					NEXTW 
c83e c3 e7 9e			jp macro_next 
c841				endm 
# End of macro NEXTW
c841			 
c841			 
c841			.ENDKEY: 
c841			; eof 
c841			 
# End of file forth_words_key.asm
c841			include "forth_words_const.asm" 
c841			 
c841			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
c841			 
c841			 
c841			.SPITIME: 
c841				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
c841 77				db WORD_SYS_CORE+99             
c842 56 c8			dw .VA            
c844 08				db 7 + 1 
c845 .. 00			db "SPITIME",0              
c84d				endm 
# End of macro CWHEAD
c84d			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
c84d			; 
c84d			; | If using BANK devices then leave as is. 
c84d			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
c84d			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
c84d			 
c84d 21 64 ea				ld hl, spi_clktime  
c850 cd 3a 9b				call forth_push_numhl 
c853			 
c853					NEXTW 
c853 c3 e7 9e			jp macro_next 
c856				endm 
# End of macro NEXTW
c856			 
c856			 
c856			.VA: 
c856				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
c856 77				db WORD_SYS_CORE+99             
c857 66 c8			dw .SYMBOL            
c859 03				db 2 + 1 
c85a .. 00			db "VA",0              
c85d				endm 
# End of macro CWHEAD
c85d			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
c85d 21 28 ea				ld hl, cli_var_array 
c860 cd 3a 9b				call forth_push_numhl 
c863			 
c863					NEXTW 
c863 c3 e7 9e			jp macro_next 
c866				endm 
# End of macro NEXTW
c866			 
c866			.SYMBOL: 
c866				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
c866 77				db WORD_SYS_CORE+99             
c867 70 c9			dw .ENDCONST            
c869 07				db 6 + 1 
c86a .. 00			db "SYMBOL",0              
c871				endm 
# End of macro CWHEAD
c871			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
c871			; | 
c871			; | The value is the number reference and the final address is pushed to stack 
c871			 
c871			; | dw sym_table 
c871			; | dw nmi_vector 
c871			; | dw cli_autodisplay 
c871			; | dw cli_data_sp 
c871			; | dw cli_data_stack 
c871			; | dw cli_loop_sp 
c871			; | dw cli_loop_stack 
c871			; | dw cli_var_array 
c871			; | dw cursor_col 
c871			; | dw cursor_ptr 
c871			; | ; 10 
c871			; | dw cursor_row 
c871			; | dw debug_mark 
c871			; | dw display_fb0 
c871			; | dw display_fb1 
c871			; | dw display_fb2 
c871			; | dw display_fb3 
c871			; | dw display_fb_active 
c871			; | dw execscratch 
c871			; | dw f_cursor_ptr 
c871			; | dw hardware_word 
c871			; | ;20 
c871			; | dw input_at_cursor 
c871			; | dw input_at_pos 
c871			; | dw input_cur_flash 
c871			; | dw input_cur_onoff 
c871			; | dw input_cursor 
c871			; | dw input_display_size 
c871			; | dw input_len 
c871			; | dw input_ptr 
c871			; | dw input_size 
c871			; | dw input_start 
c871			; | ; 30 
c871			; | dw input_str 
c871			; | dw input_under_cursor 
c871			; | dw os_cli_cmd 
c871			; | dw os_cur_ptr 
c871			; | dw os_current_i 
c871			; | dw os_input 
c871			; | dw os_last_cmd 
c871			; | dw os_last_new_uword 
c871			; | dw debug_vector 
c871			; | dw os_view_hl 
c871			; | ;40 
c871			; | dw os_word_scratch 
c871			; | dw portbctl 
c871			; | dw portbdata 
c871			; | dw spi_cartdev 
c871			; | dw spi_cartdev2 
c871			; | dw spi_clktime 
c871			; | dw spi_device 
c871			; | dw spi_device_id 
c871			; | dw spi_portbyte 
c871			; | dw stackstore 
c871			; | ; 50 
c871			; | if STORAGE_SE 
c871			; | dw storage_actl 
c871			; | dw storage_adata 
c871			; | else 
c871			; | dw 0 
c871			; | dw 0 
c871			; | endif 
c871			; | dw storage_append 
c871			; | if STORAGE_SE 
c871			; | dw storage_bctl 
c871			; | else 
c871			; | dw 0 
c871			; | endif 
c871			; | dw store_bank_active 
c871			; | dw store_filecache 
c871			; | dw store_longread 
c871			; | dw store_openaddr 
c871			; | dw store_openext 
c871			; | dw store_openmaxext 
c871			; | ; 60 
c871			; | dw store_page 
c871			; | dw store_readbuf 
c871			; | dw store_readcont 
c871			; | dw store_readptr 
c871			; | dw store_tmpext 
c871			; | dw store_tmpid 
c871			; | dw store_tmppageid 
c871			; | dw malloc 
c871			; | dw free 
c871			; | dw cin 
c871			; | ; 70 
c871			; | dw cin_wait 
c871			; | dw forth_push_numhl 
c871			; | dw forth_push_str 
c871			 
c871					if DEBUG_FORTH_WORDS_KEY 
c871						DMARK "SYM" 
c871 f5				push af  
c872 3a 86 c8			ld a, (.dmark)  
c875 32 6b ee			ld (debug_mark),a  
c878 3a 87 c8			ld a, (.dmark+1)  
c87b 32 6c ee			ld (debug_mark+1),a  
c87e 3a 88 c8			ld a, (.dmark+2)  
c881 32 6d ee			ld (debug_mark+2),a  
c884 18 03			jr .pastdmark  
c886 ..			.dmark: db "SYM"  
c889 f1			.pastdmark: pop af  
c88a			endm  
# End of macro DMARK
c88a						CALLMONITOR 
c88a cd 6f ee			call debug_vector  
c88d				endm  
# End of macro CALLMONITOR
c88d					endif 
c88d			 
c88d					FORTH_DSP_VALUEHL 
c88d cd 31 9d			call macro_dsp_valuehl 
c890				endm 
# End of macro FORTH_DSP_VALUEHL
c890			 
c890 7d					ld a, l     
c891			 
c891			 
c891					if DEBUG_FORTH_WORDS 
c891						DMARK "SY1" 
c891 f5				push af  
c892 3a a6 c8			ld a, (.dmark)  
c895 32 6b ee			ld (debug_mark),a  
c898 3a a7 c8			ld a, (.dmark+1)  
c89b 32 6c ee			ld (debug_mark+1),a  
c89e 3a a8 c8			ld a, (.dmark+2)  
c8a1 32 6d ee			ld (debug_mark+2),a  
c8a4 18 03			jr .pastdmark  
c8a6 ..			.dmark: db "SY1"  
c8a9 f1			.pastdmark: pop af  
c8aa			endm  
# End of macro DMARK
c8aa						CALLMONITOR 
c8aa cd 6f ee			call debug_vector  
c8ad				endm  
# End of macro CALLMONITOR
c8ad					endif 
c8ad					 
c8ad f5					push af	 
c8ae					FORTH_DSP_POP 
c8ae cd e9 9d			call macro_forth_dsp_pop 
c8b1				endm 
# End of macro FORTH_DSP_POP
c8b1 f1					pop af 
c8b2			 
c8b2 cb 27				sla a  
c8b4				 
c8b4					 
c8b4					if DEBUG_FORTH_WORDS 
c8b4						DMARK "SY" 
c8b4 f5				push af  
c8b5 3a c9 c8			ld a, (.dmark)  
c8b8 32 6b ee			ld (debug_mark),a  
c8bb 3a ca c8			ld a, (.dmark+1)  
c8be 32 6c ee			ld (debug_mark+1),a  
c8c1 3a cb c8			ld a, (.dmark+2)  
c8c4 32 6d ee			ld (debug_mark+2),a  
c8c7 18 02			jr .pastdmark  
c8c9 ..			.dmark: db "SY"  
c8cb f1			.pastdmark: pop af  
c8cc			endm  
# End of macro DMARK
c8cc						CALLMONITOR 
c8cc cd 6f ee			call debug_vector  
c8cf				endm  
# End of macro CALLMONITOR
c8cf					endif 
c8cf			 
c8cf 21 de c8				ld hl, sym_table 
c8d2 cd dc 8c				call addatohl 
c8d5 cd 69 9e				call loadwordinhl 
c8d8 cd 3a 9b				call forth_push_numhl 
c8db			 
c8db			 
c8db				       NEXTW 
c8db c3 e7 9e			jp macro_next 
c8de				endm 
# End of macro NEXTW
c8de			 
c8de			sym_table: 
c8de			 
c8de			; 0 
c8de de c8		dw sym_table 
c8e0 72 ee		dw nmi_vector 
c8e2 3c ea		dw cli_autodisplay 
c8e4 ee e9		dw cli_data_sp 
c8e6 28 e8		dw cli_data_stack 
c8e8 f0 e9		dw cli_loop_sp 
c8ea 2a e9		dw cli_loop_stack 
c8ec 28 ea		dw cli_var_array 
c8ee c5 eb		dw cursor_col 
c8f0 c3 eb		dw cursor_ptr 
c8f2			; 10 
c8f2 c4 eb		dw cursor_row 
c8f4 6b ee		dw debug_mark 
c8f6 b1 ed		dw display_fb0 
c8f8 10 ed		dw display_fb1 
c8fa ce eb		dw display_fb2 
c8fc 6f ec		dw display_fb3 
c8fe cc eb		dw display_fb_active 
c900 c0 e3		dw execscratch 
c902 5e ea		dw f_cursor_ptr 
c904 75 ee		dw hardware_word 
c906			;20 
c906 62 ee		dw input_at_cursor 
c908 64 ee		dw input_at_pos 
c90a 60 ee		dw input_cur_flash 
c90c 5f ee		dw input_cur_onoff 
c90e 55 ee		dw input_cursor 
c910 65 ee		dw input_display_size 
c912 5a ee		dw input_len 
c914 69 ee		dw input_ptr 
c916 66 ee		dw input_size 
c918 67 ee		dw input_start 
c91a			; 30 
c91a 09 8d		dw input_str 
c91c 63 ee		dw input_under_cursor 
c91e e8 e5		dw os_cli_cmd 
c920 e4 e5		dw os_cur_ptr 
c922 e6 e5		dw os_current_i 
c924 bf e4		dw os_input 
c926 e7 e6		dw os_last_cmd 
c928 be e5		dw os_last_new_uword 
c92a 6f ee		dw debug_vector 
c92c af e2		dw os_view_hl 
c92e			;40 
c92e c6 e5		dw os_word_scratch 
c930 c3 00		dw portbctl 
c932 c1 00		dw portbdata 
c934 63 ea		dw spi_cartdev 
c936 62 ea		dw spi_cartdev2 
c938 64 ea		dw spi_clktime 
c93a 60 ea		dw spi_device 
c93c 5f ea		dw spi_device_id 
c93e 61 ea		dw spi_portbyte 
c940 a7 eb		dw stackstore 
c942			; 50 
c942			if STORAGE_SE 
c942			dw storage_actl 
c942			dw storage_adata 
c942			else 
c942 00 00		dw 0 
c944 00 00		dw 0 
c946			endif 
c946 69 88		dw storage_append 
c948			if STORAGE_SE 
c948			dw storage_bctl 
c948			else 
c948 00 00		dw 0 
c94a			endif 
c94a 93 eb		dw store_bank_active 
c94c 67 ea		dw store_filecache 
c94e 75 ea		dw store_longread 
c950 6b ea		dw store_openaddr 
c952 6a ea		dw store_openext 
c954 69 ea		dw store_openmaxext 
c956			; 60 
c956 7a ea		dw store_page 
c958 76 ea		dw store_readbuf 
c95a 6d ea		dw store_readcont 
c95c 78 ea		dw store_readptr 
c95e 6d ea		dw store_tmpext 
c960 6e ea		dw store_tmpid 
c962 65 ea		dw store_tmppageid 
c964 a3 91		dw malloc 
c966 6d 92		dw free 
c968 1d e4		dw cin 
c96a			; 70 
c96a 17 e4		dw cin_wait 
c96c 3a 9b		dw forth_push_numhl 
c96e a8 9b		dw forth_push_str 
c970			 
c970			 
c970			.ENDCONST: 
c970			 
c970			; eof 
c970			 
c970			 
# End of file forth_words_const.asm
c970			 
c970			if STORAGE_SE 
c970			   	include "forth_words_storage.asm" 
c970			endif 
c970				include "forth_words_device.asm" 
c970			; Device related words 
c970			 
c970			; | ## Device Words 
c970			 
c970			;if SOUND_ENABLE 
c970			;.NOTE: 
c970			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c970			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c970			;		if DEBUG_FORTH_WORDS_KEY 
c970			;			DMARK "NTE" 
c970			;			CALLMONITOR 
c970			;		endif 
c970			; 
c970			;	 
c970			; 
c970			;		NEXTW 
c970			;.AFTERSOUND: 
c970			;endif 
c970			 
c970			 
c970			USE_GPIO: equ 0 
c970			 
c970			if USE_GPIO 
c970			.GP1: 
c970				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c970			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c970					NEXTW 
c970			.GP2: 
c970				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c970			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c970			 
c970					NEXTW 
c970			 
c970			.GP3: 
c970				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c970			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c970			 
c970					NEXTW 
c970			 
c970			.GP4: 
c970				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c970			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c970			 
c970					NEXTW 
c970			.SIN: 
c970			 
c970			 
c970			endif 
c970			 
c970			 
c970				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c970 33				db WORD_SYS_CORE+31             
c971 a5 c9			dw .SOUT            
c973 03				db 2 + 1 
c974 .. 00			db "IN",0              
c977				endm 
# End of macro CWHEAD
c977			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c977					if DEBUG_FORTH_WORDS_KEY 
c977						DMARK "IN." 
c977 f5				push af  
c978 3a 8c c9			ld a, (.dmark)  
c97b 32 6b ee			ld (debug_mark),a  
c97e 3a 8d c9			ld a, (.dmark+1)  
c981 32 6c ee			ld (debug_mark+1),a  
c984 3a 8e c9			ld a, (.dmark+2)  
c987 32 6d ee			ld (debug_mark+2),a  
c98a 18 03			jr .pastdmark  
c98c ..			.dmark: db "IN."  
c98f f1			.pastdmark: pop af  
c990			endm  
# End of macro DMARK
c990						CALLMONITOR 
c990 cd 6f ee			call debug_vector  
c993				endm  
# End of macro CALLMONITOR
c993					endif 
c993					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c993 cd 31 9d			call macro_dsp_valuehl 
c996				endm 
# End of macro FORTH_DSP_VALUEHL
c996			 
c996 e5					push hl 
c997			 
c997					; destroy value TOS 
c997			 
c997					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c997 cd e9 9d			call macro_forth_dsp_pop 
c99a				endm 
# End of macro FORTH_DSP_POP
c99a			 
c99a					; one value on hl get other one back 
c99a			 
c99a c1					pop bc 
c99b			 
c99b					; do the sub 
c99b			;		ex de, hl 
c99b			 
c99b ed 68				in l,(c) 
c99d			 
c99d					; save it 
c99d			 
c99d 26 00				ld h,0 
c99f			 
c99f					; TODO push value back onto stack for another op etc 
c99f			 
c99f cd 3a 9b				call forth_push_numhl 
c9a2					NEXTW 
c9a2 c3 e7 9e			jp macro_next 
c9a5				endm 
# End of macro NEXTW
c9a5			.SOUT: 
c9a5				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c9a5 34				db WORD_SYS_CORE+32             
c9a6 f8 c9			dw .SPIO            
c9a8 04				db 3 + 1 
c9a9 .. 00			db "OUT",0              
c9ad				endm 
# End of macro CWHEAD
c9ad			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c9ad					if DEBUG_FORTH_WORDS_KEY 
c9ad						DMARK "OUT" 
c9ad f5				push af  
c9ae 3a c2 c9			ld a, (.dmark)  
c9b1 32 6b ee			ld (debug_mark),a  
c9b4 3a c3 c9			ld a, (.dmark+1)  
c9b7 32 6c ee			ld (debug_mark+1),a  
c9ba 3a c4 c9			ld a, (.dmark+2)  
c9bd 32 6d ee			ld (debug_mark+2),a  
c9c0 18 03			jr .pastdmark  
c9c2 ..			.dmark: db "OUT"  
c9c5 f1			.pastdmark: pop af  
c9c6			endm  
# End of macro DMARK
c9c6						CALLMONITOR 
c9c6 cd 6f ee			call debug_vector  
c9c9				endm  
# End of macro CALLMONITOR
c9c9					endif 
c9c9			 
c9c9					; get port 
c9c9			 
c9c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9c9 cd 31 9d			call macro_dsp_valuehl 
c9cc				endm 
# End of macro FORTH_DSP_VALUEHL
c9cc			 
c9cc e5					push hl 
c9cd			 
c9cd					; destroy value TOS 
c9cd			 
c9cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9cd cd e9 9d			call macro_forth_dsp_pop 
c9d0				endm 
# End of macro FORTH_DSP_POP
c9d0			 
c9d0					; get byte to send 
c9d0			 
c9d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9d0 cd 31 9d			call macro_dsp_valuehl 
c9d3				endm 
# End of macro FORTH_DSP_VALUEHL
c9d3			 
c9d3			;		push hl 
c9d3			 
c9d3					; destroy value TOS 
c9d3			 
c9d3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9d3 cd e9 9d			call macro_forth_dsp_pop 
c9d6				endm 
# End of macro FORTH_DSP_POP
c9d6			 
c9d6					; one value on hl get other one back 
c9d6			 
c9d6			;		pop hl 
c9d6			 
c9d6 c1					pop bc 
c9d7			 
c9d7					if DEBUG_FORTH_WORDS 
c9d7						DMARK "OUT" 
c9d7 f5				push af  
c9d8 3a ec c9			ld a, (.dmark)  
c9db 32 6b ee			ld (debug_mark),a  
c9de 3a ed c9			ld a, (.dmark+1)  
c9e1 32 6c ee			ld (debug_mark+1),a  
c9e4 3a ee c9			ld a, (.dmark+2)  
c9e7 32 6d ee			ld (debug_mark+2),a  
c9ea 18 03			jr .pastdmark  
c9ec ..			.dmark: db "OUT"  
c9ef f1			.pastdmark: pop af  
c9f0			endm  
# End of macro DMARK
c9f0						CALLMONITOR 
c9f0 cd 6f ee			call debug_vector  
c9f3				endm  
# End of macro CALLMONITOR
c9f3					endif 
c9f3			 
c9f3 ed 69				out (c), l 
c9f5			 
c9f5					NEXTW 
c9f5 c3 e7 9e			jp macro_next 
c9f8				endm 
# End of macro NEXTW
c9f8			 
c9f8			 
c9f8			.SPIO: 
c9f8			 
c9f8			if STORAGE_SE 
c9f8				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c9f8			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c9f8			 
c9f8					call spi_ce_low 
c9f8			    NEXTW 
c9f8			 
c9f8			.SPICEH: 
c9f8				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c9f8			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c9f8			 
c9f8					call spi_ce_high 
c9f8			    NEXTW 
c9f8			 
c9f8			 
c9f8			.SPIOb: 
c9f8			 
c9f8				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c9f8			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c9f8			 
c9f8					if DEBUG_FORTH_WORDS_KEY 
c9f8						DMARK "SPo" 
c9f8						CALLMONITOR 
c9f8					endif 
c9f8					; get port 
c9f8			 
c9f8			 
c9f8					; get byte to send 
c9f8			 
c9f8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9f8			 
c9f8			;		push hl    ; u1  
c9f8			 
c9f8					; destroy value TOS 
c9f8			 
c9f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9f8			 
c9f8					; one value on hl get other one back 
c9f8			 
c9f8			;		pop hl   ; u2 - addr 
c9f8			 
c9f8					; TODO Send SPI byte 
c9f8			 
c9f8			;		push hl 
c9f8			;		call spi_ce_low 
c9f8			;		pop hl 
c9f8					ld a, l 
c9f8					call spi_send_byte 
c9f8			;		call spi_ce_high 
c9f8			 
c9f8					NEXTW 
c9f8			 
c9f8			.SPII: 
c9f8				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c9f8			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c9f8					if DEBUG_FORTH_WORDS_KEY 
c9f8						DMARK "SPi" 
c9f8						CALLMONITOR 
c9f8					endif 
c9f8			 
c9f8					; TODO Get SPI byte 
c9f8			 
c9f8					call spi_read_byte 
c9f8			 
c9f8					if DEBUG_FORTH_WORDS 
c9f8						DMARK "Si2" 
c9f8						CALLMONITOR 
c9f8					endif 
c9f8					ld h, 0 
c9f8					ld l, a 
c9f8					if DEBUG_FORTH_WORDS 
c9f8						DMARK "Si3" 
c9f8						CALLMONITOR 
c9f8					endif 
c9f8					call forth_push_numhl 
c9f8			 
c9f8					NEXTW 
c9f8			 
c9f8			 
c9f8			 
c9f8			.SESEL: 
c9f8				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c9f8			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c9f8					if DEBUG_FORTH_WORDS_KEY 
c9f8						DMARK "BNK" 
c9f8						CALLMONITOR 
c9f8					endif 
c9f8			 
c9f8					ld a, 255 
c9f8					ld (spi_cartdev), a 
c9f8			 
c9f8					; get bank 
c9f8			 
c9f8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9f8			 
c9f8			;		push hl 
c9f8			 
c9f8					; destroy value TOS 
c9f8			 
c9f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9f8			 
c9f8					; one value on hl get other one back 
c9f8			 
c9f8			;		pop hl 
c9f8			 
c9f8			 
c9f8					ld c, SPI_CE_HIGH 
c9f8					ld b, '0'    ; human readable bank number 
c9f8			 
c9f8					ld a, l 
c9f8			 
c9f8					if DEBUG_FORTH_WORDS 
c9f8						DMARK "BNK" 
c9f8						CALLMONITOR 
c9f8					endif 
c9f8			 
c9f8					; active low 
c9f8			 
c9f8					cp 0 
c9f8					jr z, .bset 
c9f8					cp 1 
c9f8					jr nz, .b2 
c9f8					res 0, c 
c9f8					ld b, '1'    ; human readable bank number 
c9f8			.b2:		cp 2 
c9f8					jr nz, .b3 
c9f8					res 1, c 
c9f8					ld b, '2'    ; human readable bank number 
c9f8			.b3:		cp 3 
c9f8					jr nz, .b4 
c9f8					res 2, c 
c9f8					ld b, '3'    ; human readable bank number 
c9f8			.b4:		cp 4 
c9f8					jr nz, .b5 
c9f8					res 3, c 
c9f8					ld b, '4'    ; human readable bank number 
c9f8			.b5:		cp 5 
c9f8					jr nz, .bset 
c9f8					res 4, c 
c9f8					ld b, '5'    ; human readable bank number 
c9f8			 
c9f8			.bset: 
c9f8					ld a, c 
c9f8					ld (spi_device),a 
c9f8					ld a, b 
c9f8					ld (spi_device_id),a 
c9f8					if DEBUG_FORTH_WORDS 
c9f8						DMARK "BN2" 
c9f8						CALLMONITOR 
c9f8					endif 
c9f8			 
c9f8					; set default SPI clk pulse time as disabled for BANK use 
c9f8			 
c9f8					ld a, 0 
c9f8					ld (spi_clktime), a 
c9f8			 
c9f8					NEXTW 
c9f8			 
c9f8			.CARTDEV: 
c9f8				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c9f8			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c9f8					if DEBUG_FORTH_WORDS_KEY 
c9f8						DMARK "CDV" 
c9f8						CALLMONITOR 
c9f8					endif 
c9f8			 
c9f8					; disable se storage bank selection 
c9f8			 
c9f8					ld a, SPI_CE_HIGH		; ce high 
c9f8					ld (spi_device), a 
c9f8			 
c9f8					; get bank 
c9f8			 
c9f8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c9f8			 
c9f8			;		push hl 
c9f8			 
c9f8					; destroy value TOS 
c9f8			 
c9f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c9f8			 
c9f8					; one value on hl get other one back 
c9f8			 
c9f8			;		pop hl 
c9f8			 
c9f8					; active low 
c9f8			 
c9f8					ld c, 255 
c9f8			 
c9f8					ld a, l 
c9f8					if DEBUG_FORTH_WORDS 
c9f8						DMARK "CDV" 
c9f8						CALLMONITOR 
c9f8					endif 
c9f8					cp 0 
c9f8					jr z, .cset 
c9f8					cp 1 
c9f8					jr nz, .c2 
c9f8					res 0, c 
c9f8			.c2:		cp 2 
c9f8					jr nz, .c3 
c9f8					res 1, c 
c9f8			.c3:		cp 3 
c9f8					jr nz, .c4 
c9f8					res 2, c 
c9f8			.c4:		cp 4 
c9f8					jr nz, .c5 
c9f8					res 3, c 
c9f8			.c5:		cp 5 
c9f8					jr nz, .c6 
c9f8					res 4, c 
c9f8			.c6:		cp 6 
c9f8					jr nz, .c7 
c9f8					res 5, c 
c9f8			.c7:		cp 7 
c9f8					jr nz, .c8 
c9f8					res 6, c 
c9f8			.c8:		cp 8 
c9f8					jr nz, .cset 
c9f8					res 7, c 
c9f8			.cset:		ld a, c 
c9f8					ld (spi_cartdev),a 
c9f8			 
c9f8					if DEBUG_FORTH_WORDS 
c9f8						DMARK "CD2" 
c9f8						CALLMONITOR 
c9f8					endif 
c9f8			 
c9f8					; set default SPI clk pulse time as 10ms for CARTDEV use 
c9f8			 
c9f8					ld a, $0a 
c9f8					ld (spi_clktime), a 
c9f8					NEXTW 
c9f8			endif 
c9f8			 
c9f8			.ENDDEVICE: 
c9f8			; eof 
c9f8			 
# End of file forth_words_device.asm
c9f8			 
c9f8			; var handler 
c9f8			 
c9f8			 
c9f8			.VARS: 
c9f8				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
c9f8 77				db WORD_SYS_CORE+99             
c9f9 a9 ca			dw .V0            
c9fb 04				db 3 + 1 
c9fc .. 00			db "VAR",0              
ca00				endm 
# End of macro CWHEAD
ca00			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
ca00			;| 
ca00			;| The variable name should consist of a single letter. e.g. "a" 
ca00			;! If a full string is passed then only the first char is looked at 
ca00			;| Any other char could exceed bounds checks!  
ca00			 
ca00					if DEBUG_FORTH_WORDS_KEY 
ca00						DMARK "VAR" 
ca00 f5				push af  
ca01 3a 15 ca			ld a, (.dmark)  
ca04 32 6b ee			ld (debug_mark),a  
ca07 3a 16 ca			ld a, (.dmark+1)  
ca0a 32 6c ee			ld (debug_mark+1),a  
ca0d 3a 17 ca			ld a, (.dmark+2)  
ca10 32 6d ee			ld (debug_mark+2),a  
ca13 18 03			jr .pastdmark  
ca15 ..			.dmark: db "VAR"  
ca18 f1			.pastdmark: pop af  
ca19			endm  
# End of macro DMARK
ca19						CALLMONITOR 
ca19 cd 6f ee			call debug_vector  
ca1c				endm  
# End of macro CALLMONITOR
ca1c					endif 
ca1c			 
ca1c					FORTH_DSP_VALUEHL 
ca1c cd 31 9d			call macro_dsp_valuehl 
ca1f				endm 
# End of macro FORTH_DSP_VALUEHL
ca1f			 
ca1f 7e					ld a, (hl)    ; get first char on of the string 
ca20			 
ca20			 
ca20					if DEBUG_FORTH_WORDS 
ca20						DMARK "VR1" 
ca20 f5				push af  
ca21 3a 35 ca			ld a, (.dmark)  
ca24 32 6b ee			ld (debug_mark),a  
ca27 3a 36 ca			ld a, (.dmark+1)  
ca2a 32 6c ee			ld (debug_mark+1),a  
ca2d 3a 37 ca			ld a, (.dmark+2)  
ca30 32 6d ee			ld (debug_mark+2),a  
ca33 18 03			jr .pastdmark  
ca35 ..			.dmark: db "VR1"  
ca38 f1			.pastdmark: pop af  
ca39			endm  
# End of macro DMARK
ca39						CALLMONITOR 
ca39 cd 6f ee			call debug_vector  
ca3c				endm  
# End of macro CALLMONITOR
ca3c					endif 
ca3c					 
ca3c f5					push af	 
ca3d					FORTH_DSP_POP 
ca3d cd e9 9d			call macro_forth_dsp_pop 
ca40				endm 
# End of macro FORTH_DSP_POP
ca40 f1					pop af 
ca41			 
ca41					; convert to upper 
ca41			 
ca41 cd 49 90				call to_upper 
ca44					if DEBUG_FORTH_WORDS 
ca44						DMARK "Vaa" 
ca44 f5				push af  
ca45 3a 59 ca			ld a, (.dmark)  
ca48 32 6b ee			ld (debug_mark),a  
ca4b 3a 5a ca			ld a, (.dmark+1)  
ca4e 32 6c ee			ld (debug_mark+1),a  
ca51 3a 5b ca			ld a, (.dmark+2)  
ca54 32 6d ee			ld (debug_mark+2),a  
ca57 18 03			jr .pastdmark  
ca59 ..			.dmark: db "Vaa"  
ca5c f1			.pastdmark: pop af  
ca5d			endm  
# End of macro DMARK
ca5d						CALLMONITOR 
ca5d cd 6f ee			call debug_vector  
ca60				endm  
# End of macro CALLMONITOR
ca60					endif 
ca60 06 41				ld b, 'A' 
ca62 90					sub b			; set offset 
ca63					if DEBUG_FORTH_WORDS 
ca63						DMARK "Vbb" 
ca63 f5				push af  
ca64 3a 78 ca			ld a, (.dmark)  
ca67 32 6b ee			ld (debug_mark),a  
ca6a 3a 79 ca			ld a, (.dmark+1)  
ca6d 32 6c ee			ld (debug_mark+1),a  
ca70 3a 7a ca			ld a, (.dmark+2)  
ca73 32 6d ee			ld (debug_mark+2),a  
ca76 18 03			jr .pastdmark  
ca78 ..			.dmark: db "Vbb"  
ca7b f1			.pastdmark: pop af  
ca7c			endm  
# End of macro DMARK
ca7c						CALLMONITOR 
ca7c cd 6f ee			call debug_vector  
ca7f				endm  
# End of macro CALLMONITOR
ca7f					endif 
ca7f cb 27				sla a  
ca81				 
ca81					 
ca81					if DEBUG_FORTH_WORDS 
ca81						DMARK "VR2" 
ca81 f5				push af  
ca82 3a 96 ca			ld a, (.dmark)  
ca85 32 6b ee			ld (debug_mark),a  
ca88 3a 97 ca			ld a, (.dmark+1)  
ca8b 32 6c ee			ld (debug_mark+1),a  
ca8e 3a 98 ca			ld a, (.dmark+2)  
ca91 32 6d ee			ld (debug_mark+2),a  
ca94 18 03			jr .pastdmark  
ca96 ..			.dmark: db "VR2"  
ca99 f1			.pastdmark: pop af  
ca9a			endm  
# End of macro DMARK
ca9a						CALLMONITOR 
ca9a cd 6f ee			call debug_vector  
ca9d				endm  
# End of macro CALLMONITOR
ca9d					endif 
ca9d			 
ca9d 21 f4 e9				ld hl, cli_var_array2 
caa0 cd dc 8c				call addatohl 
caa3 cd 3a 9b				call forth_push_numhl 
caa6			 
caa6			 
caa6				       NEXTW 
caa6 c3 e7 9e			jp macro_next 
caa9				endm 
# End of macro NEXTW
caa9			.V0: 
caa9				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
caa9 78				db WORD_SYS_CORE+100             
caaa c1 ca			dw .V0Q            
caac 04				db 3 + 1 
caad .. 00			db "V0!",0              
cab1				endm 
# End of macro CWHEAD
cab1			;| V0! ( u1 -- )  Store value to v0  | DONE 
cab1			 
cab1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cab1 cd 31 9d			call macro_dsp_valuehl 
cab4				endm 
# End of macro FORTH_DSP_VALUEHL
cab4			 
cab4 11 28 ea				ld de, cli_var_array 
cab7			 
cab7 eb					ex de, hl 
cab8 73					ld (hl), e 
cab9 23					inc hl 
caba 72					ld (hl), d 
cabb			 
cabb					; destroy value TOS 
cabb			 
cabb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cabb cd e9 9d			call macro_forth_dsp_pop 
cabe				endm 
# End of macro FORTH_DSP_POP
cabe			 
cabe				       NEXTW 
cabe c3 e7 9e			jp macro_next 
cac1				endm 
# End of macro NEXTW
cac1			.V0Q: 
cac1				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
cac1 79				db WORD_SYS_CORE+101             
cac2 d2 ca			dw .V1S            
cac4 04				db 3 + 1 
cac5 .. 00			db "V0@",0              
cac9				endm 
# End of macro CWHEAD
cac9			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
cac9 2a 28 ea				ld hl, (cli_var_array) 
cacc cd 3a 9b				call forth_push_numhl 
cacf			 
cacf				       NEXTW 
cacf c3 e7 9e			jp macro_next 
cad2				endm 
# End of macro NEXTW
cad2			.V1S: 
cad2				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
cad2 7a				db WORD_SYS_CORE+102             
cad3 ea ca			dw .V1Q            
cad5 04				db 3 + 1 
cad6 .. 00			db "V1!",0              
cada				endm 
# End of macro CWHEAD
cada			;| V1! ( u1 -- )  Store value to v1 | DONE 
cada					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cada cd 31 9d			call macro_dsp_valuehl 
cadd				endm 
# End of macro FORTH_DSP_VALUEHL
cadd			 
cadd 11 2a ea				ld de, cli_var_array+2 
cae0				 
cae0 eb					ex de, hl 
cae1 73					ld (hl), e 
cae2 23					inc hl 
cae3 72					ld (hl), d 
cae4			 
cae4					; destroy value TOS 
cae4			 
cae4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cae4 cd e9 9d			call macro_forth_dsp_pop 
cae7				endm 
# End of macro FORTH_DSP_POP
cae7				       NEXTW 
cae7 c3 e7 9e			jp macro_next 
caea				endm 
# End of macro NEXTW
caea			.V1Q: 
caea				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
caea 7b				db WORD_SYS_CORE+103             
caeb fb ca			dw .V2S            
caed 04				db 3 + 1 
caee .. 00			db "V1@",0              
caf2				endm 
# End of macro CWHEAD
caf2			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
caf2 2a 2a ea				ld hl, (cli_var_array+2) 
caf5 cd 3a 9b				call forth_push_numhl 
caf8				       NEXTW 
caf8 c3 e7 9e			jp macro_next 
cafb				endm 
# End of macro NEXTW
cafb			.V2S: 
cafb				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
cafb 7c				db WORD_SYS_CORE+104             
cafc 13 cb			dw .V2Q            
cafe 04				db 3 + 1 
caff .. 00			db "V2!",0              
cb03				endm 
# End of macro CWHEAD
cb03			;| V2! ( u1 -- )  Store value to v2 | DONE 
cb03					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cb03 cd 31 9d			call macro_dsp_valuehl 
cb06				endm 
# End of macro FORTH_DSP_VALUEHL
cb06			 
cb06 11 2c ea				ld de, cli_var_array+4 
cb09				 
cb09 eb					ex de, hl 
cb0a 73					ld (hl), e 
cb0b 23					inc hl 
cb0c 72					ld (hl), d 
cb0d			 
cb0d					; destroy value TOS 
cb0d			 
cb0d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb0d cd e9 9d			call macro_forth_dsp_pop 
cb10				endm 
# End of macro FORTH_DSP_POP
cb10				       NEXTW 
cb10 c3 e7 9e			jp macro_next 
cb13				endm 
# End of macro NEXTW
cb13			.V2Q: 
cb13				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
cb13 7d				db WORD_SYS_CORE+105             
cb14 24 cb			dw .V3S            
cb16 04				db 3 + 1 
cb17 .. 00			db "V2@",0              
cb1b				endm 
# End of macro CWHEAD
cb1b			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
cb1b 2a 2c ea				ld hl, (cli_var_array+4) 
cb1e cd 3a 9b				call forth_push_numhl 
cb21				       NEXTW 
cb21 c3 e7 9e			jp macro_next 
cb24				endm 
# End of macro NEXTW
cb24			.V3S: 
cb24				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
cb24 7c				db WORD_SYS_CORE+104             
cb25 3c cb			dw .V3Q            
cb27 04				db 3 + 1 
cb28 .. 00			db "V3!",0              
cb2c				endm 
# End of macro CWHEAD
cb2c			;| V3! ( u1 -- )  Store value to v3 | DONE 
cb2c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
cb2c cd 31 9d			call macro_dsp_valuehl 
cb2f				endm 
# End of macro FORTH_DSP_VALUEHL
cb2f			 
cb2f 11 2e ea				ld de, cli_var_array+6 
cb32				 
cb32 eb					ex de, hl 
cb33 73					ld (hl), e 
cb34 23					inc hl 
cb35 72					ld (hl), d 
cb36			 
cb36					; destroy value TOS 
cb36			 
cb36					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
cb36 cd e9 9d			call macro_forth_dsp_pop 
cb39				endm 
# End of macro FORTH_DSP_POP
cb39				       NEXTW 
cb39 c3 e7 9e			jp macro_next 
cb3c				endm 
# End of macro NEXTW
cb3c			.V3Q: 
cb3c				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
cb3c 7d				db WORD_SYS_CORE+105             
cb3d 4d cb			dw .END            
cb3f 04				db 3 + 1 
cb40 .. 00			db "V3@",0              
cb44				endm 
# End of macro CWHEAD
cb44			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
cb44 2a 2e ea				ld hl, (cli_var_array+6) 
cb47 cd 3a 9b				call forth_push_numhl 
cb4a				       NEXTW 
cb4a c3 e7 9e			jp macro_next 
cb4d				endm 
# End of macro NEXTW
cb4d			 
cb4d			 
cb4d			 
cb4d			 
cb4d			 
cb4d			; end of dict marker 
cb4d			 
cb4d 00			.END:    db WORD_SYS_END 
cb4e 00 00			dw 0 
cb50 00				db 0 
cb51			 
cb51			; use to jp here for user dict words to save on macro expansion  
cb51			 
cb51			user_dict_next: 
cb51				NEXTW 
cb51 c3 e7 9e			jp macro_next 
cb54				endm 
# End of macro NEXTW
cb54			 
cb54			 
cb54			user_exec: 
cb54				;    ld hl, <word code> 
cb54				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
cb54				;    call forthexec 
cb54				;    jp user_dict_next   (NEXT) 
cb54			        ;    <word code bytes> 
cb54 eb				ex de, hl 
cb55 2a c2 e5			ld hl,(os_tok_ptr) 
cb58				 
cb58				FORTH_RSP_NEXT 
cb58 cd e1 9a			call macro_forth_rsp_next 
cb5b				endm 
# End of macro FORTH_RSP_NEXT
cb5b			 
cb5b			if DEBUG_FORTH_UWORD 
cb5b						DMARK "UEX" 
cb5b f5				push af  
cb5c 3a 70 cb			ld a, (.dmark)  
cb5f 32 6b ee			ld (debug_mark),a  
cb62 3a 71 cb			ld a, (.dmark+1)  
cb65 32 6c ee			ld (debug_mark+1),a  
cb68 3a 72 cb			ld a, (.dmark+2)  
cb6b 32 6d ee			ld (debug_mark+2),a  
cb6e 18 03			jr .pastdmark  
cb70 ..			.dmark: db "UEX"  
cb73 f1			.pastdmark: pop af  
cb74			endm  
# End of macro DMARK
cb74				CALLMONITOR 
cb74 cd 6f ee			call debug_vector  
cb77				endm  
# End of macro CALLMONITOR
cb77			endif 
cb77			 
cb77			 
cb77			 
cb77 eb				ex de, hl 
cb78 22 c2 e5			ld (os_tok_ptr), hl 
cb7b				 
cb7b				; Don't use next - Skips the first word in uword. 
cb7b			 
cb7b c3 78 9f			jp exec1 
cb7e			;	NEXT 
cb7e			 
cb7e			 
cb7e			; eof 
# End of file forth_wordsv4.asm
cb7e			endif 
cb7e			;;;;;;;;;;;;;; Debug code 
cb7e			 
cb7e			 
cb7e			;if DEBUG_FORTH_PARSE 
cb7e .. 00		.nowordfound: db "No match",0 
cb87 .. 00		.compword:	db "Comparing word ",0 
cb97 .. 00		.nextwordat:	db "Next word at",0 
cba4 .. 00		.charmatch:	db "Char match",0 
cbaf			;endif 
cbaf			if DEBUG_FORTH_JP 
cbaf			.foundword:	db "Word match. Exec..",0 
cbaf			endif 
cbaf			;if DEBUG_FORTH_PUSH 
cbaf .. 00		.enddict:	db "Dict end. Push.",0 
cbbf .. 00		.push_str:	db "Pushing string",0 
cbce .. 00		.push_num:	db "Pushing number",0 
cbdd .. 00		.data_sp:	db "SP:",0 
cbe1 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
cbf3 .. 00		.wordinde:	db "Word in DE (3/0):",0 
cc05 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
cc17			;endif 
cc17			;if DEBUG_FORTH_MALLOC 
cc17 .. 00		.push_malloc:	db "Malloc address",0 
cc26			;endif 
cc26			 
cc26			 
cc26			 
cc26			; display malloc address and current data stack pointer  
cc26			 
cc26			malloc_error: 
cc26 d5				push de 
cc27 f5				push af 
cc28 e5				push hl 
cc29 cd af 8a			call clear_display 
cc2c 11 4c cc			ld de, .mallocerr 
cc2f 3e 00			ld a,0 
cc31			;	ld de,os_word_scratch 
cc31 cd c2 8a			call str_at_display 
cc34 3e 11			ld a, display_row_1+17 
cc36 11 6b ee			ld de, debug_mark 
cc39 cd c2 8a			call str_at_display 
cc3c cd d2 8a			call update_display 
cc3f				;call break_point_state 
cc3f cd 17 e4			call cin_wait 
cc42			 
cc42			;	ld a, ' ' 
cc42			;	ld (os_view_disable), a 
cc42 cd d2 94			call bp_on 
cc45 e1				pop hl 
cc46 f1				pop af 
cc47 d1				pop de	 
cc48				CALLMONITOR 
cc48 cd 6f ee			call debug_vector  
cc4b				endm  
# End of macro CALLMONITOR
cc4b c9				ret 
cc4c			 
cc4c .. 00		.mallocerr: 	db "Malloc Error",0 
cc59			;if DEBUG_FORTH_PUSH 
cc59			display_data_sp: 
cc59 f5				push af 
cc5a			 
cc5a				; see if disabled 
cc5a			 
cc5a			 
cc5a 3a 6f ee			ld a, (debug_vector) 
cc5d fe c9			cp $C9  ; RET 
cc5f				;ld a, (os_view_disable) 
cc5f				;cp '*' 
cc5f 28 67			jr z, .skipdsp 
cc61			 
cc61 e5				push hl 
cc62 e5				push hl 
cc63 e5			push hl 
cc64 cd af 8a			call clear_display 
cc67 e1			pop hl 
cc68 7c				ld a,h 
cc69 21 c6 e5			ld hl, os_word_scratch 
cc6c cd dd 8f			call hexout 
cc6f e1				pop hl 
cc70 7d				ld a,l 
cc71 21 c8 e5			ld hl, os_word_scratch+2 
cc74 cd dd 8f			call hexout 
cc77 21 ca e5			ld hl, os_word_scratch+4 
cc7a 3e 00			ld a,0 
cc7c 77				ld (hl),a 
cc7d 11 c6 e5			ld de,os_word_scratch 
cc80 3e 28				ld a, display_row_2 
cc82 cd c2 8a				call str_at_display 
cc85 11 e1 cb			ld de, .wordinhl 
cc88 3e 00			ld a, display_row_1 
cc8a			 
cc8a cd c2 8a				call str_at_display 
cc8d 11 6b ee			ld de, debug_mark 
cc90 3e 11			ld a, display_row_1+17 
cc92			 
cc92 cd c2 8a				call str_at_display 
cc95			 
cc95				; display current data stack pointer 
cc95 11 dd cb			ld de,.data_sp 
cc98 3e 30				ld a, display_row_2 + 8 
cc9a cd c2 8a				call str_at_display 
cc9d			 
cc9d 2a ee e9			ld hl,(cli_data_sp) 
cca0 e5				push hl 
cca1 7c				ld a,h 
cca2 21 c6 e5			ld hl, os_word_scratch 
cca5 cd dd 8f			call hexout 
cca8 e1				pop hl 
cca9 7d				ld a,l 
ccaa 21 c8 e5			ld hl, os_word_scratch+2 
ccad cd dd 8f			call hexout 
ccb0 21 ca e5			ld hl, os_word_scratch+4 
ccb3 3e 00			ld a,0 
ccb5 77				ld (hl),a 
ccb6 11 c6 e5			ld de,os_word_scratch 
ccb9 3e 33				ld a, display_row_2 + 11 
ccbb cd c2 8a				call str_at_display 
ccbe			 
ccbe			 
ccbe cd d2 8a			call update_display 
ccc1 cd f2 89			call delay1s 
ccc4 cd f2 89			call delay1s 
ccc7 e1				pop hl 
ccc8			.skipdsp: 
ccc8 f1				pop af 
ccc9 c9				ret 
ccca			 
ccca			display_data_malloc: 
ccca			 
ccca f5				push af 
cccb e5				push hl 
cccc e5				push hl 
cccd e5			push hl 
ccce cd af 8a			call clear_display 
ccd1 e1			pop hl 
ccd2 7c				ld a,h 
ccd3 21 c6 e5			ld hl, os_word_scratch 
ccd6 cd dd 8f			call hexout 
ccd9 e1				pop hl 
ccda 7d				ld a,l 
ccdb 21 c8 e5			ld hl, os_word_scratch+2 
ccde cd dd 8f			call hexout 
cce1 21 ca e5			ld hl, os_word_scratch+4 
cce4 3e 00			ld a,0 
cce6 77				ld (hl),a 
cce7 11 c6 e5			ld de,os_word_scratch 
ccea 3e 28				ld a, display_row_2 
ccec cd c2 8a				call str_at_display 
ccef 11 17 cc			ld de, .push_malloc 
ccf2 3e 00			ld a, display_row_1 
ccf4			 
ccf4 cd c2 8a				call str_at_display 
ccf7			 
ccf7				; display current data stack pointer 
ccf7 11 dd cb			ld de,.data_sp 
ccfa 3e 30				ld a, display_row_2 + 8 
ccfc cd c2 8a				call str_at_display 
ccff			 
ccff 2a ee e9			ld hl,(cli_data_sp) 
cd02 e5				push hl 
cd03 7c				ld a,h 
cd04 21 c6 e5			ld hl, os_word_scratch 
cd07 cd dd 8f			call hexout 
cd0a e1				pop hl 
cd0b 7d				ld a,l 
cd0c 21 c8 e5			ld hl, os_word_scratch+2 
cd0f cd dd 8f			call hexout 
cd12 21 ca e5			ld hl, os_word_scratch+4 
cd15 3e 00			ld a,0 
cd17 77				ld (hl),a 
cd18 11 c6 e5			ld de,os_word_scratch 
cd1b 3e 33				ld a, display_row_2 + 11 
cd1d cd c2 8a				call str_at_display 
cd20			 
cd20 cd d2 8a			call update_display 
cd23 cd f2 89			call delay1s 
cd26 cd f2 89			call delay1s 
cd29 e1				pop hl 
cd2a f1				pop af 
cd2b c9				ret 
cd2c			;endif 
cd2c			 
cd2c			include "forth_autostart.asm" 
cd2c			; list of commands to perform at system start up 
cd2c			 
cd2c			startcmds: 
cd2c			;	dw test11 
cd2c			;	dw test12 
cd2c			;	dw test13 
cd2c			;	dw test14 
cd2c			;	dw test15 
cd2c			;	dw test16 
cd2c			;	dw test17 
cd2c			;	dw ifthtest1 
cd2c			;	dw ifthtest2 
cd2c			;	dw ifthtest3 
cd2c			;	dw mmtest1 
cd2c			;	dw mmtest2 
cd2c			;	dw mmtest3 
cd2c			;	dw mmtest4 
cd2c			;	dw mmtest5 
cd2c			;	dw mmtest6 
cd2c			;	dw iftest1 
cd2c			;	dw iftest2 
cd2c			;	dw iftest3 
cd2c			;	dw looptest1 
cd2c			;	dw looptest2 
cd2c			;	dw test1 
cd2c			;	dw test2 
cd2c			;	dw test3 
cd2c			;	dw test4 
cd2c			;	dw game2r 
cd2c			;	dw game2b1 
cd2c			;	dw game2b2 
cd2c			 
cd2c				; start up words that are actually useful 
cd2c			 
cd2c			;    dw spi1 
cd2c			;    dw spi2 
cd2c			;    dw spi3 
cd2c			;    dw spi4 
cd2c			;    dw spi5 
cd2c			;    dw spi6 
cd2c			;    dw spi7 
cd2c			; 
cd2c			;    dw spi8 
cd2c			;    dw spi9 
cd2c			;    dw spi10 
cd2c			 
cd2c			; file editor 
cd2c			;	dw edit1 
cd2c			;	dw edit2 
cd2c			;	dw edit3 
cd2c			 
cd2c			;	dw longread 
cd2c 2c d1			dw clrstack 
cd2e 60 d1			dw type 
cd30			;	dw stest 
cd30 85 d1			dw strncpy 
cd32			;	dw list 
cd32 e6 d1			dw start1 
cd34 f6 d1			dw start2 
cd36			;	dw start3 
cd36			;	dw start3b 
cd36			;	dw start3c 
cd36			 
cd36				; (unit) testing words 
cd36			 
cd36			;	dw mtesta 
cd36			;	dw mtestb 
cd36			;	dw mtestc 
cd36			;	dw mtestd 
cd36			;	dw mteste 
cd36			 
cd36				; demo/game words 
cd36			 
cd36			;        dw game3w 
cd36			;        dw game3p 
cd36			;        dw game3sc 
cd36			;        dw game3vsi 
cd36			;        dw game3vs 
cd36				 
cd36 4f dc			dw game2b 
cd38 bd dc			dw game2bf 
cd3a 07 dd			dw game2mba 
cd3c 9d dd			dw game2mbas 
cd3e df dd			dw game2mb 
cd40			 
cd40 10 d9			dw game1 
cd42 21 d9			dw game1a 
cd44 83 d9			dw game1b 
cd46 b8 d9			dw game1c 
cd48 ee d9			dw game1d 
cd4a 1f da			dw game1s 
cd4c 33 da			dw game1t 
cd4e 48 da			dw game1f 
cd50 7c da			dw game1z 
cd52 c0 da			dw game1zz 
cd54			 
cd54 2a d7			dw test5 
cd56 62 d7			dw test6 
cd58 9a d7			dw test7 
cd5a ae d7			dw test8 
cd5c da d7			dw test9 
cd5e f0 d7			dw test10 
cd60				 
cd60 97 db		        dw ssv5 
cd62 7b db		        dw ssv4 
cd64 5f db		        dw ssv3 
cd66 29 db		        dw ssv2 
cd68 b0 db		        dw ssv1 
cd6a f8 db		        dw ssv1cpm 
cd6c			;	dw keyup 
cd6c			;	dw keydown 
cd6c			;	dw keyleft 
cd6c			;	dw keyright 
cd6c			;	dw 	keyf1 
cd6c			;	dw keyf2 
cd6c			;	dw keyf3 
cd6c			;	dw keyf4 
cd6c			;	dw keyf5 
cd6c			;	dw keyf6 
cd6c			;	dw keyf7 
cd6c			;	dw keyf8 
cd6c			;	dw keyf9 
cd6c			;	dw keyf10 
cd6c			;	dw keyf11 
cd6c			;	dw keyf12 
cd6c			;	dw keytab 
cd6c			;	dw keycr 
cd6c			;	dw keyhome 
cd6c			;	dw keyend 
cd6c			;	dw keybs 
cd6c 00 00			db 0, 0	 
cd6e			 
cd6e			 
cd6e			; File Editor 
cd6e			 
cd6e			; ( id - ) use 'e' to edit the displayed line 
cd6e .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
cd8f .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cdc4			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
cdc4 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
cdfc			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
cdfc			 
cdfc			; SPI Net support words 
cdfc			 
cdfc			; v0! = node to send to 
cdfc			; ( str count - ) 
cdfc .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
ce55			 
ce55			; spiputchr ( char node - ) 
ce55 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
ce8b			 
ce8b			; spigetchr ( - n ) 
ce8b .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
ceb6			 
ceb6			; getnode ( - n ) 
ceb6 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
cee3			 
cee3			; ( str node - )  
cee3 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
cf49			; store string ( str i - ) 
cf49			 
cf49			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
cf49 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
cf9e			 
cf9e			; get string ( addr i -  )    TO FIX 
cf9e			 
cf9e .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
cff6			 
cff6			 
cff6			; NETCHAT (TODO) 
cff6			; Program to allow two nodes to chat with eachother 
cff6			; 
cff6			; v0 - target node 
cff6			;  
cff6			; accept input at 0,0 
cff6			; if input is string send spitype to target node 
cff6			; starting at row 2,0 , while spigetchr is not zero ->  
cff6			; 
cff6			; 
cff6			; TODO add paging of get request 
cff6			 
cff6			; ( node - ) 
cff6 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
d015 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
d06d .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
d0e5			 
d0e5			 
d0e5			; Long read of currently open file 
d0e5 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
d12c			 
d12c			; clear stack  
d12c			 
d12c .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
d160			 
d160			; type ( addr count - ) 
d160 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
d185			 
d185			; some direct memory words 
d185			; strncpy ( len t f -- t ) 
d185			 
d185 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
d1e6			 
d1e6 .. 00		start1:     	db ": bpon $00 bp ;",0 
d1f6 .. 00		start2:     	db ": bpoff $01 bp ;",0 
d207 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
d282 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
d2e2			 
d2e2			 
d2e2			; a handy word to list items on the stack 
d2e2			 
d2e2 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
d34c			 
d34c			 
d34c			; test stack  
d34c			; rnd8 stest 
d34c			 
d34c .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
d3c3			 
d3c3			; random malloc and free cycles 
d3c3			 
d3c3 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d478			 
d478			; fixed malloc and free cycles 
d478			 
d478 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
d51b			 
d51b			; fixed double string push and drop cycle  
d51b			 
d51b .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
d5d0			 
d5d0			; consistent fixed string push and drop cycle  
d5d0			 
d5d0 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d674			 
d674 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
d72a			 
d72a			;test1:		db ": aa 1 2 3 ;", 0 
d72a			;test2:     	db "111 aa 888 999",0 
d72a			;test3:     	db ": bb 77 ;",0 
d72a			;test4:     	db "$02 $01 do i . loop bb",0 
d72a			 
d72a .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
d762 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
d79a .. 00		test7:     	db ": box hline vline ;",0 
d7ae .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
d7da .. 00		test9:     	db ": sw $01 adsp world ;",0 
d7f0 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
d815 .. 00		test11:     	db "hello create .",0 
d824 .. 00		test12:     	db "hello2 create .",0 
d834			 
d834			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
d834			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
d834			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
d834			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
d834			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
d834			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
d834			 
d834			;iftest1:     	db "$0001 IF cls .",0 
d834			;iftest2:     	db "$0000 IF cls .",0 
d834			;iftest3:     	db "$0002 $0003 - IF cls .",0 
d834			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
d834			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
d834			 
d834			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d834			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d834			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
d834			 
d834			 
d834 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
d858 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
d888 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
d8ad .. 00		sound4: db ": cha $00 ; ",0 
d8ba .. 00		sound5: db ": chb $20 ; ",0 
d8c7 .. 00		sound6: db ": chc $40 ; ",0 
d8d4 .. 00		sound7: db ": chd $60 ; ",0 
d8e1 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
d8f9 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
d910			 
d910			 
d910			 
d910			 
d910			; a small guess the number game 
d910			 
d910 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
d921 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d983			 
d983 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d9b8 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d9ee .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
da1f .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
da33 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
da48 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
da7c .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
dac0			 
dac0			; Using 'ga' save a high score across multiple runs using external storage 
dac0			 
dac0 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
db29			 
db29			 
db29			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
db29			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
db29			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
db29			 
db29			; simple screen saver to test code memory reuse to destruction 
db29			 
db29 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
db5f .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
db7b .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
db97 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
dbb0 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
dbf8 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
dc4f			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
dc4f			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
dc4f			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
dc4f			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
dc4f			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
dc4f			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
dc4f			 
dc4f			 
dc4f			 
dc4f			; minesweeper/battleship finding game 
dc4f			; draws a game board of random ship/mine positions 
dc4f			; user enters coords to see if it hits on 
dc4f			; game ends when all are hit 
dc4f			; when hit or miss says how many may be in the area 
dc4f			 
dc4f			; setup the game board and then hide it 
dc4f .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
dcbd .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
dd07			; prompt for where to target 
dd07 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
dd9d .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
ddc2			; TODO see if the entered coords hits or misses pushes char hit of miss 
ddc2 .. 00		game2mbht:      db ": mbckht nop ;",0 
ddd1 .. 00		game2mbms:      db ": mbcms nop ;",0 
dddf			; TODO how many might be near by 
dddf .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
de5c			 
de5c			; Game 3 
de5c			 
de5c			; Vert scroller ski game - avoid the trees! 
de5c			 
de5c			; v0 score (ie turns) 
de5c			; v1 player pos 
de5c			; v2 left wall 
de5c			; v3 right wall 
de5c			 
de5c			; Draw side walls randomly 
de5c			 
de5c .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
de8a			 
de8a			; Draw player 
de8a .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
dea8			 
dea8			; TODO Get Key 
dea8			 
dea8			; TODO Move left right 
dea8			 
dea8			; scroll and move walls a bit 
dea8			 
dea8 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
ded9			 
ded9			; main game loop 
ded9			 
ded9 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
df05 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
df44			 
df44			; key board defs 
df44			 
df44 .. 00		keyup:       db ": keyup $05 ;",0 
df52 .. 00		keydown:       db ": keydown $0a ;",0 
df62 .. 00		keyleft:       db ": keyleft $0b ;",0 
df72 .. 00		keyright:       db ": keyright $0c ;",0 
df83 .. 00		keyf1:       db ": keyf1 $10 ;",0 
df91 .. 00		keyf2:       db ": keyf2 $11 ;",0 
df9f .. 00		keyf3:       db ": keyf3 $12 ;",0 
dfad .. 00		keyf4:       db ": keyf4 $13 ;",0 
dfbb .. 00		keyf5:       db ": keyf5 $14 ;",0 
dfc9 .. 00		keyf6:       db ": keyf6 $15 ;",0 
dfd7 .. 00		keyf7:       db ": keyf7 $16 ;",0 
dfe5 .. 00		keyf8:       db ": keyf8 $17 ;",0 
dff3 .. 00		keyf9:       db ": keyf9 $18 ;",0 
e001 .. 00		keyf10:       db ": keyf10 $19 ;",0 
e010 .. 00		keyf11:       db ": keyf11 $1a ;",0 
e01f .. 00		keyf12:       db ": keyf12 $1b ;",0 
e02e			 
e02e .. 00		keytab:       db ": keytab $09 ;",0 
e03d .. 00		keycr:       db ": keycr $0d ;",0 
e04b .. 00		keyhome:       db ": keyhome $0e ;",0 
e05b .. 00		keyend:       db ": keyend $0f ;",0 
e06a .. 00		keybs:       db ": keybs $08 ;",0 
e078			 
e078			   
e078			 
e078			 
e078			 
e078			; eof 
# End of file forth_autostart.asm
e078			 
e078			 
e078			 
e078			; stack over and underflow checks 
e078			 
e078			; init the words to detect the under/overflow 
e078			 
e078			chk_stk_init: 
e078				; a vague random number to check so we dont get any "lucky" hits 
e078 3e 2d			ld a, 45 
e07a 6f				ld l, a 
e07b 00				nop 
e07c 3e 17			ld a, 23 
e07e 67				ld h, a 
e07f			 
e07f 22 a9 e2			ld (chk_word), hl     ; the word we need to check against 
e082			 
e082			;	ld (chk_stund), hl	; stack points.... 
e082 22 00 ef			ld (chk_stovr), hl 
e085 22 ec e9			ld (chk_ret_und), hl 
e088 22 aa e9			ld (chk_ret_ovr), hl 
e08b 22 28 e9			ld (chk_loop_ovr), hl 
e08e 22 26 e8			ld (chk_data_ovr), hl 
e091 c9				ret 
e092				 
e092			check_stacks: 
e092				; check all stack words 
e092			 
e092 e5				push hl 
e093 d5				push de 
e094			 
e094			;	ld de,(chk_word) 
e094			;	ld hl, (chk_stund)	; stack points.... 
e094			;	if DEBUG_STK_FAULT 
e094			;		DMARK "FAa" 
e094			;		CALLMONITOR 
e094			;	endif 
e094			;	call cmp16 
e094			;	jp z, .chk_faulta 
e094			; 
e094			;	ld de, sfaultsu 
e094			;	jp .chk_fault 
e094			 
e094 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
e097 ed 5b a9 e2		ld de,(chk_word) 
e09b				if DEBUG_STK_FAULT 
e09b					DMARK "FAb" 
e09b					CALLMONITOR 
e09b				endif 
e09b cd fa 8c			call cmp16 
e09e 28 06			jr z, .chk_fault1 
e0a0 11 41 e1			ld de, sfaultso 
e0a3 c3 f5 e0			jp .chk_fault 
e0a6			.chk_fault1:  
e0a6 2a ec e9			ld hl, (chk_ret_und) 
e0a9 ed 5b a9 e2		ld de,(chk_word) 
e0ad				if DEBUG_STK_FAULT 
e0ad					DMARK "FAU" 
e0ad					CALLMONITOR 
e0ad				endif 
e0ad cd fa 8c			call cmp16 
e0b0 ca b9 e0			jp z, .chk_fault2 
e0b3 11 51 e1			ld de, sfaultru 
e0b6 c3 f5 e0			jp .chk_fault 
e0b9			.chk_fault2:  
e0b9 2a aa e9			ld hl, (chk_ret_ovr) 
e0bc ed 5b a9 e2		ld de,(chk_word) 
e0c0				if DEBUG_STK_FAULT 
e0c0					DMARK "FA1" 
e0c0					CALLMONITOR 
e0c0				endif 
e0c0 cd fa 8c			call cmp16 
e0c3 ca cc e0			jp z, .chk_fault3 
e0c6 11 5f e1			ld de, sfaultro 
e0c9 c3 f5 e0			jp .chk_fault 
e0cc			.chk_fault3:  
e0cc 2a 28 e9			ld hl, (chk_loop_ovr) 
e0cf ed 5b a9 e2		ld de,(chk_word) 
e0d3				if DEBUG_STK_FAULT 
e0d3					DMARK "FA2" 
e0d3					CALLMONITOR 
e0d3				endif 
e0d3 cd fa 8c			call cmp16 
e0d6 ca df e0			jp z, .chk_fault4 
e0d9 11 79 e1			ld de, sfaultlo 
e0dc c3 f5 e0			jp .chk_fault 
e0df			.chk_fault4:  
e0df 2a 26 e8			ld hl, (chk_data_ovr) 
e0e2 ed 5b a9 e2		ld de,(chk_word) 
e0e6				if DEBUG_STK_FAULT 
e0e6					DMARK "FA3" 
e0e6					CALLMONITOR 
e0e6				endif 
e0e6 cd fa 8c			call cmp16 
e0e9 ca f2 e0			jp z, .chk_fault5 
e0ec 11 93 e1			ld de, sfaultdo 
e0ef c3 f5 e0			jp .chk_fault 
e0f2			 
e0f2			 
e0f2			.chk_fault5:  
e0f2 d1				pop de 
e0f3 e1				pop hl 
e0f4			 
e0f4 c9				ret 
e0f5			 
e0f5 cd af 8a		.chk_fault: 	call clear_display 
e0f8 3e 28				ld a, display_row_2 
e0fa cd c2 8a				call str_at_display 
e0fd 11 23 e1				   ld de, .stackfault 
e100 3e 00				ld a, display_row_1 
e102 cd c2 8a				call str_at_display 
e105 11 6b ee				    ld de, debug_mark 
e108 3e 11				ld a, display_row_1+17 
e10a cd c2 8a				call str_at_display 
e10d cd d2 8a				call update_display 
e110			 
e110				; prompt before entering montior for investigating issue 
e110			 
e110 3e 78			ld a, display_row_4 
e112 11 2c 98			ld de, endprog 
e115			 
e115 cd d2 8a			call update_display		 
e118			 
e118 cd b2 9a			call next_page_prompt 
e11b			 
e11b d1				pop de 
e11c e1				pop hl 
e11d cd 80 98				call monitor 
e120 c3 8b 97				jp warmstart 
e123					;jp 0 
e123					;halt 
e123			 
e123			 
e123			 
e123 .. 00		.stackfault: 	db "Stack fault:",0 
e130			 
e130 .. 00		sfaultsu: 	db	"Stack under flow",0 
e141 .. 00		sfaultso: 	db	"Stack over flow",0 
e151 .. 00		sfaultru:	db "RTS underflow",0 
e15f .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
e179 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
e193 .. 00		sfaultdo:	db "DTS overflow", 0 
e1a0			 
e1a0			 
e1a0			fault_dsp_under: 
e1a0 11 b2 e1			ld de, .dsp_under 
e1a3 c3 62 e2			jp .show_fault 
e1a6			 
e1a6			fault_rsp_under: 
e1a6 11 c0 e1			ld de, .rsp_under 
e1a9 c3 62 e2			jp .show_fault 
e1ac			fault_loop_under: 
e1ac 11 ce e1			ld de, .loop_under 
e1af c3 62 e2			jp .show_fault 
e1b2			 
e1b2 .. 00		.dsp_under: db "DSP Underflow",0 
e1c0 .. 00		.rsp_under: db "RSP Underflow",0 
e1ce .. 00		.loop_under: db "LOOP Underflow",0 
e1dd			 
e1dd			 
e1dd d5			type_faultn: 	push de 
e1de e5					push hl 
e1df cd af 8a				call clear_display 
e1e2 11 09 e2				   ld de, .typefaultn 
e1e5 3e 00				ld a, display_row_1 
e1e7 cd c2 8a				call str_at_display 
e1ea 11 6b ee				    ld de, debug_mark 
e1ed 3e 11				ld a, display_row_1+17 
e1ef cd c2 8a				call str_at_display 
e1f2 cd d2 8a				call update_display 
e1f5			 
e1f5				; prompt before entering montior for investigating issue 
e1f5			 
e1f5 3e 78			ld a, display_row_4 
e1f7 11 2c 98			ld de, endprog 
e1fa			 
e1fa cd d2 8a			call update_display		 
e1fd			 
e1fd cd b2 9a			call next_page_prompt 
e200			 
e200 e5					push hl 
e201 d5					push de 
e202 cd 80 98				call monitor 
e205 c3 8b 97				jp warmstart 
e208 76					halt 
e209			 
e209			 
e209 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
e220			 
e220 d5			type_faults: 	push de 
e221 e5					push hl 
e222 cd af 8a				call clear_display 
e225 11 4b e2				   ld de, .typefaults 
e228 3e 00				ld a, display_row_1 
e22a cd c2 8a				call str_at_display 
e22d 11 6b ee				    ld de, debug_mark 
e230 3e 11				ld a, display_row_1+17 
e232 cd c2 8a				call str_at_display 
e235 cd d2 8a				call update_display 
e238			 
e238				; prompt before entering montior for investigating issue 
e238			 
e238 3e 78			ld a, display_row_4 
e23a 11 2c 98			ld de, endprog 
e23d			 
e23d cd d2 8a			call update_display		 
e240			 
e240 cd b2 9a			call next_page_prompt 
e243			 
e243 e1					pop hl 
e244 d1					pop de 
e245 cd 80 98				call monitor 
e248 c3 8b 97				jp warmstart 
e24b			 
e24b			 
e24b .. 00		.typefaults: db "STR Type Expected TOS!",0 
e262			 
e262			.show_fault: 	 
e262 d5					push de 
e263 cd af 8a				call clear_display 
e266 d1					pop de 
e267 3e 00				ld a, display_row_1 
e269 cd c2 8a				call str_at_display 
e26c 11 6b ee				    ld de, debug_mark 
e26f 3e 11				ld a, display_row_1+17 
e271 cd c2 8a				call str_at_display 
e274 cd d2 8a				call update_display 
e277			 
e277				; prompt before entering montior for investigating issue 
e277			 
e277 3e 78			ld a, display_row_4 
e279 11 2c 98			ld de, endprog 
e27c			 
e27c cd d2 8a			call update_display		 
e27f			 
e27f cd b2 9a			call next_page_prompt 
e282			 
e282 e1					pop hl 
e283 d1					pop de 
e284 cd 80 98				call monitor 
e287			; do a dump to cli and not warmstart so we preserve all of the uwords.  
e287			; TODO Make optional fault restart to cli or warm boot? 
e287					;jp warmstart 
e287 c3 d3 97				jp cli 
e28a 76					halt 
e28b			 
e28b			; handle the auto run of code from files in storage 
e28b			 
e28b			 
e28b			include "forth_startup.asm" 
e28b			; Which startup method to use? 
e28b			; 
e28b			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
e28b			; followed by loading of a list of scripts in eeprom 
e28b			 
e28b			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
e28b			; from eeprom 
e28b			 
e28b			; Select with define in main stubs 
e28b			 
e28b			if STARTUP_V1 
e28b				include "forth_startupv1.asm" 
e28b			; Startup script loading version 1 
e28b			 
e28b			; If SE storage is available first stage is to use the selected file 
e28b			; then go through the eeprom list 
e28b			 
e28b .. 00		sprompt1: db "Startup load...",0 
e29b .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
e2b1			 
e2b1			 
e2b1			 
e2b1			 
e2b1			forth_startup: 
e2b1 21 2c cd			ld hl, startcmds 
e2b4 3e 00			ld a, 0 
e2b6 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
e2b9			 
e2b9 e5			.start1:	push hl 
e2ba cd af 8a			call clear_display 
e2bd 11 8b e2			ld de, sprompt1 
e2c0 3e 00		        ld a, display_row_1 
e2c2 cd c2 8a			call str_at_display 
e2c5 11 9b e2			ld de, sprompt2 
e2c8 3e 28		        ld a, display_row_2 
e2ca cd c2 8a			call str_at_display 
e2cd e1				pop hl 
e2ce e5				push hl 
e2cf 5e				ld e,(hl) 
e2d0 23				inc hl 
e2d1 56				ld d,(hl) 
e2d2 3e 50		        ld a, display_row_3 
e2d4 cd c2 8a			call str_at_display 
e2d7 cd d2 8a			call update_display 
e2da			 
e2da			 
e2da 3a e7 e6			ld a, (os_last_cmd) 
e2dd fe 00			cp 0 
e2df 28 05			jr z, .startprompt 
e2e1 cd e6 89			call delay250ms 
e2e4 18 24			jr .startdo 
e2e6				 
e2e6				 
e2e6			 
e2e6			.startprompt: 
e2e6			 
e2e6 3e 9f			ld a,display_row_4 + display_cols - 1 
e2e8 11 b0 9a		        ld de, endprg 
e2eb cd c2 8a			call str_at_display 
e2ee cd d2 8a			call update_display 
e2f1 cd f2 89			call delay1s 
e2f4 cd 17 e4			call cin_wait 
e2f7						 
e2f7 fe 2a			cp '*' 
e2f9 28 5e			jr z, .startupend1 
e2fb fe 23			cp '#' 
e2fd 20 07			jr nz, .startno 
e2ff 3e 01			ld a, 1 
e301 32 e7 e6			ld (os_last_cmd),a 
e304 18 04			jr .startdo 
e306 fe 31		.startno:	cp '1' 
e308 28 3a			jr z,.startnxt  
e30a			 
e30a				; exec startup line 
e30a			.startdo:	 
e30a e1				pop hl 
e30b e5				push hl 
e30c				 
e30c 5e				ld e,(hl) 
e30d 23				inc hl 
e30e 56				ld d,(hl) 
e30f eb				ex de,hl 
e310			 
e310 e5				push hl 
e311			 
e311 3e 00			ld a, 0 
e313				;ld a, FORTH_END_BUFFER 
e313 cd 45 91			call strlent 
e316 23				inc hl   ; include zero term to copy 
e317 06 00			ld b,0 
e319 4d				ld c,l 
e31a e1				pop hl 
e31b 11 c1 e2			ld de, scratch 
e31e ed b0			ldir 
e320			 
e320			 
e320 21 c1 e2			ld hl, scratch 
e323 cd 35 9f			call forthparse 
e326 cd 75 9f			call forthexec 
e329 cd 87 9e			call forthexec_cleanup 
e32c			 
e32c 3e 78			ld a, display_row_4 
e32e 11 2c 98			ld de, endprog 
e331			 
e331 cd d2 8a			call update_display		 
e334			 
e334 3a e7 e6			ld a, (os_last_cmd) 
e337 fe 00			cp 0 
e339 20 09			jr nz, .startnxt 
e33b cd b2 9a			call next_page_prompt 
e33e cd af 8a		        call clear_display 
e341 cd d2 8a			call update_display		 
e344			 
e344				; move onto next startup line? 
e344			.startnxt: 
e344			 
e344 cd e6 89			call delay250ms 
e347 e1				pop hl 
e348			 
e348 23				inc hl 
e349 23				inc hl 
e34a			 
e34a e5				push hl 
e34b 5e				ld e, (hl) 
e34c 23				inc hl 
e34d 56				ld d, (hl) 
e34e e1				pop hl 
e34f				; TODO replace 0 test 
e34f			 
e34f eb				ex de, hl 
e350 cd 05 8d			call ishlzero 
e353			;	ld a,e 
e353			;	add d 
e353			;	cp 0    ; any left to do? 
e353 eb				ex de, hl 
e354 c2 b9 e2			jp nz, .start1 
e357 18 01			jr .startupend 
e359			 
e359 e1			.startupend1: pop hl 
e35a			.startupend: 
e35a			 
e35a cd af 8a			call clear_display 
e35d cd d2 8a			call update_display 
e360 c9				ret 
e361			if STORAGE_SE 
e361			 
e361			sprompt3: db "Loading from start-up file?:",0 
e361			sprompt4: db "(Y=Any key/N=No)",0 
e361			 
e361			 
e361			forth_autoload: 
e361			 
e361				; load block 0 of store 1 
e361				 
e361				ld a, $fe      ; bit 0 clear 
e361				ld (spi_device), a 
e361			 
e361				call storage_get_block_0 
e361			 
e361				ld a, (store_page+STORE_0_AUTOFILE) 
e361			 
e361				cp 0 
e361				ret z     ; auto start not enabled 
e361			 
e361				call clear_display 
e361			 
e361				; set bank 
e361			 
e361					ld a, (store_page+STORE_0_BANKRUN) 
e361					ld (spi_device), a 
e361			 
e361				; get file id to load from and get the file name to display 
e361			 
e361					ld a, (store_page+STORE_0_FILERUN) 
e361			 
e361					ld l, 0 
e361					ld h, a 
e361					ld de, store_page 
e361			 
e361					if DEBUG_FORTH_WORDS 
e361						DMARK "ASp" 
e361						CALLMONITOR 
e361					endif 
e361					call storage_read 
e361			 
e361					if DEBUG_FORTH_WORDS 
e361						DMARK "ASr" 
e361						CALLMONITOR 
e361					endif 
e361			 
e361					call ishlzero 
e361					ret z             ; file not found 
e361			 
e361					ld a, display_row_2 + 10 
e361					ld de, store_page+3 
e361					call str_at_display 
e361				 
e361			; 
e361			 
e361				ld a, display_row_1+5 
e361				ld de, sprompt3 
e361				call str_at_display 
e361				ld a, display_row_3+15 
e361				ld de, sprompt4 
e361				call str_at_display 
e361			 
e361				call update_display 
e361			 
e361				call cin_wait 
e361				cp 'n' 
e361				ret z 
e361				cp 'N' 
e361				ret z 
e361			 
e361				call delay1s 
e361			 
e361				ld a, (store_page+2) 
e361				ld (store_openmaxext), a    ; save count of ext 
e361				ld a, 1  
e361				ld (store_openext), a    ; save count of ext 
e361			 
e361			.autof:  
e361				ld l , a 
e361				 
e361				ld a, (store_page) 
e361				ld h, a	 
e361				ld de, store_page 
e361					if DEBUG_FORTH_WORDS 
e361						DMARK "ASl" 
e361						CALLMONITOR 
e361					endif 
e361					call storage_read 
e361				call ishlzero 
e361				ret z 
e361			;	jr z, .autoend 
e361			 
e361					if DEBUG_FORTH_WORDS 
e361						DMARK "ASc" 
e361						CALLMONITOR 
e361					endif 
e361				ld de, store_page+2 
e361				ld a, display_row_4 
e361				call str_at_display 
e361			 
e361				call update_display 
e361				call delay250ms 
e361			 
e361			 
e361			 
e361				ld hl, store_page+2 
e361				call forthparse 
e361				call forthexec 
e361				call forthexec_cleanup 
e361			 
e361				 
e361				ld a, (store_openext) 
e361				inc a 
e361				ld (store_openext), a    ; save count of ext 
e361			 
e361				jr .autof 
e361			;.autofdone: 
e361			; 
e361			;		if DEBUG_FORTH_WORDS 
e361			;			DMARK "ASx" 
e361			;			CALLMONITOR 
e361			;		endif 
e361			;;	call clear_display 
e361			;	ret 
e361			 
e361			 
e361			 
e361			endif 
# End of file forth_startupv1.asm
e361			endif 
e361			if STARTUP_V2 
e361				include "forth_startupv2.asm" 
e361			endif 
e361			 
# End of file forth_startup.asm
e361			 
e361			; eof 
# End of file forth_kernel.asm
e361			;include "nascombasic.asm" 
e361			 
e361			 
e361			; find out where the code ends if loaded into RAM (for SC114) 
e361			;endofcode:  
e361			;	nop 
e361			 
e361			 
e361			; jump to nmi vector 
e361			 
e361			init_nmi: 
e361 3e c9			ld a, $c9   ; RET 
e363 32 72 ee			ld (nmi_vector), a 
e366 c9				ret 
e367			nmi: 
e367 e5				push hl 
e368 d5				push de 
e369 c5				push bc 
e36a f5				push af 
e36b cd 72 ee			call nmi_vector 
e36e f5				push af 
e36f c5				push bc 
e370 d5				push de 
e371 e5				push hl 
e372 ed 4d			reti 
e374			 
e374			 
e374			; eof 
e374			 
# End of file main.asm
e374			;include "firmware_lcd_4x40.asm" 
e374			;;include "firmware_lcd_4x20.asm" 
e374			include "firmware_serial_display.asm" 
e374			 
e374			; Serial display interface for SC114 
e374			 
e374			 
e374			display_row_1: equ 0 
e374			display_row_2: equ display_row_1+display_cols 
e374			display_row_3: equ display_row_2 + display_cols 
e374			display_row_4: equ display_row_3 + display_cols 
e374			 
e374			kLCDWidth:  EQU display_cols             ;Width in characters 
e374			kLCD_Line1: EQU 0x00  
e374			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
e374			; E1 
e374			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
e374			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
e374			 
e374			lcd_init: 
e374				; no init as handled by the SCM bios 
e374 c9				ret 
e375			 
e375			 
e375			; low level functions for direct screen writes 
e375			 
e375			; output char at pos? 
e375			fLCD_Str: 
e375			        ;out (SC114_SIO_1_OUT),a 
e375 c5				push bc 
e376 0e 02			ld c, $02 
e378 f7				rst $30 
e379 c1				pop bc 
e37a c9				ret 
e37b			 
e37b			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
e37b			fLCD_Pos: 
e37b				; use ASCII escape to position 
e37b			        ;out (SC114_SIO_1_OUT),a 
e37b c5				push bc 
e37c 0e 02			ld c, $02 
e37e f7				rst $30 
e37f c1				pop bc 
e380			 
e380 c9				ret 
e381			 
e381			; output char at pos 
e381			fLCD_Data: 
e381			      ;  out (SC114_SIO_1_OUT),a 
e381 c5				push bc 
e382 0e 02			ld c, $02 
e384 f7				rst $30 
e385 c1				pop bc 
e386			 
e386 c9				ret 
e387			 
e387			; ascii cls  
e387			 
e387 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
e38b			 
e38b			; write the frame buffer given in hl to hardware  
e38b			write_display: 
e38b			 
e38b			API: equ 0 
e38b			 
e38b			if API 
e38b				push bc 
e38b				ld b, 4 
e38b			 
e38b			        ld (display_write_tmp), hl 	  
e38b			 
e38b				; clear and home cursor 
e38b			 
e38b				ld c, 6 
e38b				ld de, .cls 
e38b				rst $30 
e38b			 
e38b			 
e38b			.writeln: 
e38b			 
e38b				ld de, (display_write_tmp) 
e38b				ld c, 6 
e38b				rst $30 
e38b				ld c, 7 
e38b				rst $30 
e38b			 
e38b				ld hl, (display_write_tmp) 
e38b				ld de, display_cols 
e38b				add hl,de 
e38b				ld (display_write_tmp),hl 
e38b			 
e38b				djnz  .writeln 
e38b			 
e38b				pop bc 
e38b			 
e38b			 
e38b				ret 
e38b			endif 
e38b e5				push hl 
e38c c5				push bc 
e38d d5				push de 
e38e			 
e38e			;	ld c, 2 
e38e			;	;ld de, .cls 
e38e			;	ld a, 27 
e38e			;	rst $30 
e38e			;	ld c, 2 
e38e			;	;ld de, .cls 
e38e			;	ld a, '[' 
e38e			;	rst $30 
e38e			; 
e38e			;	ld c, 2 
e38e			;	;ld de, .cls 
e38e			;	ld a, 'H' 
e38e			;	rst $30 
e38e			; 
e38e			 
e38e 0e 02			ld c, 2 
e390				;ld de, .cls 
e390 3e 1b			ld a, 27 
e392 f7				rst $30 
e393			 
e393			 
e393 0e 02			ld c, 2 
e395				;ld de, .cls 
e395 3e 5b			ld a, '[' 
e397 f7				rst $30 
e398 0e 02			ld c, 2 
e39a				;ld de, .cls 
e39a 3e 32			ld a, '2' 
e39c f7				rst $30 
e39d 0e 02			ld c, 2 
e39f				;ld de, .cls 
e39f 3e 4a			ld a, 'J' 
e3a1 f7				rst $30 
e3a2 d1				pop de 
e3a3 c1				pop bc 
e3a4 e1				pop hl 
e3a5			 
e3a5			 
e3a5 22 c9 eb		        ld (display_write_tmp), hl 	  
e3a8 3e 00			ld a, kLCD_Line1 
e3aa			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e3aa 06 28			ld b, display_cols 
e3ac ed 5b c9 eb		ld de, (display_write_tmp) 
e3b0 cd 0e e4			call write_len_string 
e3b3				 
e3b3			 
e3b3 e5			push hl 
e3b4 d5			push de 
e3b5 c5			push bc 
e3b6 0e 07			ld c, 7 
e3b8 f7				rst $30 
e3b9 c1			pop bc 
e3ba d1			pop de 
e3bb e1			pop hl 
e3bc			 
e3bc				 
e3bc 2a c9 eb			ld hl, (display_write_tmp) 
e3bf 11 28 00			ld de, display_cols 
e3c2 19				add hl,de 
e3c3 22 c9 eb			ld (display_write_tmp),hl 
e3c6			 
e3c6				 
e3c6 3e 28			ld a, kLCD_Line2 
e3c8			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
e3c8 06 28			ld b, display_cols 
e3ca ed 5b c9 eb		ld de, (display_write_tmp) 
e3ce cd 0e e4			call write_len_string 
e3d1				 
e3d1 2a c9 eb			ld hl, (display_write_tmp) 
e3d4 11 28 00			ld de, display_cols 
e3d7 19				add hl,de 
e3d8 22 c9 eb			ld (display_write_tmp),hl 
e3db			 
e3db e5			push hl 
e3dc d5			push de 
e3dd c5			push bc 
e3de 0e 07			ld c, 7 
e3e0 f7				rst $30 
e3e1 c1			pop bc 
e3e2 d1			pop de 
e3e3 e1			pop hl 
e3e4			 
e3e4				 
e3e4 3e 50			ld a, kLCD_Line3 
e3e6			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
e3e6 06 28			ld b, display_cols 
e3e8 ed 5b c9 eb		ld de, (display_write_tmp) 
e3ec cd 0e e4			call write_len_string 
e3ef				 
e3ef 2a c9 eb			ld hl, (display_write_tmp) 
e3f2 11 28 00			ld de, display_cols 
e3f5 19				add hl,de 
e3f6 22 c9 eb			ld (display_write_tmp),hl 
e3f9			 
e3f9 e5			push hl 
e3fa d5			push de 
e3fb c5			push bc 
e3fc 0e 07			ld c, 7 
e3fe f7				rst $30 
e3ff c1			pop bc 
e400 d1			pop de 
e401 e1			pop hl 
e402			 
e402				 
e402 3e 78			ld a, kLCD_Line4 
e404			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
e404 06 28			ld b, display_cols 
e406 ed 5b c9 eb		ld de, (display_write_tmp) 
e40a cd 0e e4			call write_len_string 
e40d c9					ret 
e40e			 
e40e			 
e40e				; write out a fixed length string given in b from de 
e40e			 
e40e 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
e40f cd 81 e3		            CALL fLCD_Data      ;Write character to display 
e412 13				inc de 
e413 10 f9			djnz write_len_string 
e415 c9				ret 
e416			 
e416			 
e416			; eof 
# End of file firmware_serial_display.asm
e416			;include "firmware_key_5x10.asm" 
e416			;;include "firmware_key_4x10.asm" 
e416			include "firmware_key_serial.asm" 
e416			; Serial keyboard interface for SC114 
e416			 
e416			key_init: 
e416				; no init as handled by the SCM bios 
e416 c9				ret 
e417			 
e417			 
e417			cin_wait: 
e417			;	ld a, 0 
e417			;	ret 
e417			 
e417				;in a,(SC114_SIO_1_IN) 
e417			        ; Use SCM API to get from whatever console device we are using 
e417 c5				push bc 
e418 0e 01			ld c, $01 
e41a f7				rst $30 
e41b c1				pop bc 
e41c c9				ret 
e41d			 
e41d			cin: 
e41d			 
e41d			 
e41d c5				push bc 
e41e			 
e41e				; any key waiting to process? 
e41e 0e 03			ld c, $03 
e420 f7				rst $30 
e421 28 05			jr z, .cin_skip 
e423			 
e423				; yep, get it 
e423			 
e423 0e 01			ld c, $01 
e425 f7				rst $30 
e426 c1				pop bc 
e427 c9				ret 
e428			.cin_skip: 
e428 3e 00			ld a, 0 
e42a c1				pop bc 
e42b c9				ret 
e42c			 
e42c			 
e42c			 
e42c			 
# End of file firmware_key_serial.asm
e42c			endofcode:  
e42c			baseram:  
e42c 00				nop 
e42d			 
e42d			heap_start: equ baseram+15  ; Starting address of heap 
e42d			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
e42d			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
e42d			;VDU:  EQU     endofcode           ; BASIC Work space 
e42d			; eof 
e42d			 
# End of file os_mega_sc114.asm
e42d
