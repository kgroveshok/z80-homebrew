# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 96 1b			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 1  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_write_tmp-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
001c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
001c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
001c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
001c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 13 fd				ld hl, display_fb1  
001f 22 cf fb				ld (display_fb_active), hl  
0022			  
0022 cd 18 0d				call clear_display  
0025			  
0025 21 d1 fb				ld hl, display_fb2  
0028 22 cf fb				ld (display_fb_active), hl  
002b			  
002b cd 18 0d				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 b4 fd				ld hl, display_fb0  
0031 22 cf fb				ld (display_fb_active), hl  
0034			  
0034 cd 18 0d				call clear_display  
0037			  
0037			  
0037 cd a1 73				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd 38 76			call key_init  
003d cd fe 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd ef 13				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043 cd ac 15				call sound_init  
0046				endif  
0046			  
0046				; lcd test sequence  
0046					  
0046 cd 3b 0d			call update_display  
0049 cd 95 0c			call delay1s  
004c 3e 2b			ld a,'+'  
004e cd 1d 0d			call fill_display  
0051 cd 3b 0d			call update_display  
0054 cd 95 0c			call delay1s  
0057 3e 2a			ld a,'*'  
0059 cd 1d 0d			call fill_display  
005c cd 3b 0d			call update_display  
005f cd 95 0c			call delay1s  
0062 3e 2d			ld a,'-'  
0064 cd 1d 0d			call fill_display  
0067 cd 3b 0d			call update_display  
006a cd 95 0c			call delay1s  
006d			  
006d			; boot splash screen  
006d			if display_cols == 20	  
006d			        ld a, display_row_1    
006d			else  
006d 3e 0a		        ld a, display_row_1 +10   
006f			endif  
006f 11 c9 1a			ld de, prom_bootmsg  
0072 cd 2b 0d			call str_at_display  
0075 cd 3b 0d			call update_display  
0078			  
0078			  
0078 cd 95 0c			call delay1s  
007b cd 95 0c			call delay1s  
007e			if display_cols == 20	  
007e			            LD   A, display_row_3+2  
007e			else  
007e 3e 5c		            LD   A, display_row_3+12  
0080			endif  
0080 11 de 1a			ld de, prom_bootmsg1  
0083 cd 2b 0d			call str_at_display  
0086 cd 3b 0d			call update_display  
0089 cd 95 0c			call delay1s  
008c cd 95 0c			call delay1s  
008f			  
008f			;	ld a, display_row_4+3  
008f			;	ld de, bootmsg2  
008f			;	call str_at_display  
008f			;	call update_display  
008f			;	call delay1s  
008f			;	call delay1s  
008f			  
008f			; debug mark setup  
008f			  
008f 3e 5f		ld a, '_'  
0091 32 6e fe		ld (debug_mark),a  
0094 32 6f fe		ld (debug_mark+1),a  
0097 32 70 fe		ld (debug_mark+2),a  
009a 3e 00		ld a,0  
009c 32 71 fe		ld (debug_mark+3),a  
009f			  
009f c9					ret  
00a0			  
00a0			  
00a0			;bootmsg2:	db "Firmware v0.1",0  
00a0			  
00a0			; a 4x20 lcd  
00a0			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00a0			  
00a0			;if display_cols == 20  
00a0			;	include "firmware_lcd_4x20.asm"  
00a0			;endif  
00a0			  
00a0			;if display_cols == 40  
00a0			;	include "firmware_lcd_4x40.asm"  
00a0			;endif  
00a0			  
00a0			;  
00a0			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00a0			; TODO abstract the bit bang video out interface for dual display  
00a0			; TODO wire video out to tx pin on rc2014 bus  
00a0			  
00a0			; must supply cin, and cin_wait for low level hardware abstraction   
00a0			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00a0			; test scancode  
00a0			  
00a0			;;;;;  
00a0			;;;  
00a0			; Moved out to mini and maxi versions  
00a0			;  
00a0			; include "firmware_key_4x4.asm"  
00a0			; using existing 4 wire x 4 resistor array for input  
00a0			;include "firmware_key_4x10.asm"  
00a0			; need to mod the board for 5 rows due to resistor array  
00a0			;include "firmware_key_5x10.asm"  
00a0			  
00a0			; storage hardware interface  
00a0			  
00a0			; use microchip serial eeprom for storage  
00a0			  
00a0			  
00a0			if STORAGE_SE  
00a0				include "firmware_spi.asm"  
00a0			; my spi protocol (used by storage) 
00a0			 
00a0			; SPI pins 
00a0			 
00a0			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00a0			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00a0			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00a0			 
00a0			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00a0			; chip pin 4 gnd 
00a0			 
00a0			 
00a0			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00a0			SPI_CE1: equ 1      ;    port a1 pin 14  
00a0			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00a0			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00a0			SPI_CE4: equ 4      ; port a4     pin 10 
00a0			 
00a0			; active low AND masks 
00a0			 
00a0			;SPI_CE0_MASK: equ    255-1 
00a0			;SPI_CE1_MASK: equ   255-2 
00a0			;SPI_CE2_MASK: equ   255-4 
00a0			;SPI_CE3_MASK: equ   255-8 
00a0			;SPI_CE4_MASK: equ   255-16 
00a0			SPI_CE_HIGH:  equ 255 
00a0			 
00a0			 
00a0			 
00a0			;  Perform SCLK wait pulse 
00a0			 
00a0			spi_clk: 
00a0 f5				push af 
00a1 3a 6b fa			ld a, (spi_clktime) 
00a4 fe 00			cp 0 
00a6 28 03			jr z, .scskip 
00a8 cd 7a 0c			call aDelayInMS 
00ab			.scskip: 
00ab f1				pop af 
00ac c9				ret 
00ad			 
00ad			 
00ad			 
00ad			; TODO store port id for spi device ie dev c 
00ad			; TODO store pin for SO 
00ad			; TODO store pin for SI 
00ad			; TODO store pin for SCLK 
00ad			 
00ad			; 
00ad			 
00ad			; ensure that spi bus is in a stable state with default pins  
00ad			 
00ad			se_stable_spi:   
00ad			 
00ad				 ; set DI high, CE high , SCLK low 
00ad				;ld a, SPI_DI | SPI_CE0 
00ad 3e 07			ld a, SPI_DI  
00af cd b9 01			call spi_ce_high 
00b2 d3 80			 out (storage_adata),a 
00b4 32 68 fa			ld (spi_portbyte),a 
00b7			 
00b7				if DEBUG_SPI 
00b7					push hl 
00b7					ld l, a 
00b7					DMARK "SPI" 
00b7					CALLMONITOR 
00b7					pop hl 
00b7				endif 
00b7 c9				ret 
00b8			 
00b8			; byte to send in a 
00b8			 
00b8			spi_send_byte: 
00b8				; save byte to send for bit mask shift out 
00b8 4f			        ld c,a 
00b9 3a 68 fa			ld a,(spi_portbyte) 
00bc				  
00bc				; clock out	each bit of the byte msb first 
00bc			 
00bc 06 08			ld b, 8 
00be			.ssb1: 
00be				; clear so bit  
00be cb bf			res SPI_DI, a 
00c0 cb 11			rl c 
00c2				; if bit 7 is set then carry is set 
00c2 30 02			jr nc, .ssb2 
00c4 cb ff			set SPI_DI,a 
00c6			.ssb2:  ; output bit to ensure it is stable 
00c6 d3 80			out (storage_adata),a 
00c8 00				nop 
00c9				; clock bit high 
00c9 cb ef			set SPI_SCLK,a 
00cb d3 80			out (storage_adata),a 
00cd 00				nop 
00ce cd a0 00			call spi_clk 
00d1				; then low 
00d1 cb af			res SPI_SCLK,a 
00d3 d3 80			out (storage_adata),a 
00d5 00				nop 
00d6 cd a0 00			call spi_clk 
00d9 10 e3			djnz .ssb1 
00db			 
00db 32 68 fa			ld (spi_portbyte),a 
00de c9				ret 
00df			 
00df			; TODO low level get byte into A on spi 
00df			 
00df			spi_read_byte:  
00df			 
00df				; save byte to send for bit mask shift out 
00df 0e 00		    ld c,0 
00e1 3a 68 fa			ld a,(spi_portbyte) 
00e4				  
00e4				; clock out	each bit of the byte msb first 
00e4			 
00e4			 
00e4				; clock bit high 
00e4 cb ef			set SPI_SCLK,a 
00e6 d3 80			out (storage_adata),a 
00e8 00				nop 
00e9 cd a0 00			call spi_clk 
00ec			 
00ec			    ; read DO  
00ec			 
00ec cb f9		    set 7,c 
00ee db 80			in a,(storage_adata) 
00f0 cb 77		    bit SPI_DO,a 
00f2 20 02		    jr nz, .b7 
00f4 cb b9		    res 7,c 
00f6			.b7: 
00f6				; then low 
00f6 cb af			res SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb cd a0 00			call spi_clk 
00fe			     
00fe			 
00fe				; clock bit high 
00fe cb ef			set SPI_SCLK,a 
0100 d3 80			out (storage_adata),a 
0102 00				nop 
0103 cd a0 00			call spi_clk 
0106			 
0106			    ; read DO  
0106			 
0106 cb f1		    set 6,c 
0108 db 80			in a,(storage_adata) 
010a cb 77		    bit SPI_DO,a 
010c 20 02		    jr nz, .b6 
010e cb b1		    res 6,c 
0110			.b6: 
0110				; then low 
0110 cb af			res SPI_SCLK,a 
0112 d3 80			out (storage_adata),a 
0114 00				nop 
0115 cd a0 00			call spi_clk 
0118			 
0118				; clock bit high 
0118 cb ef			set SPI_SCLK,a 
011a d3 80			out (storage_adata),a 
011c 00				nop 
011d cd a0 00			call spi_clk 
0120			 
0120			 
0120			    ; read DO  
0120			 
0120 cb e9		    set 5,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b5 
0128 cb a9		    res 5,c 
012a			.b5: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f cd a0 00			call spi_clk 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137 cd a0 00			call spi_clk 
013a			 
013a			    ; read DO  
013a			 
013a cb e1		    set 4,c 
013c db 80			in a,(storage_adata) 
013e cb 77		    bit SPI_DO,a 
0140 20 02		    jr nz, .b4 
0142 cb a1		    res 4,c 
0144			.b4: 
0144				; then low 
0144 cb af			res SPI_SCLK,a 
0146 d3 80			out (storage_adata),a 
0148 00				nop 
0149 cd a0 00			call spi_clk 
014c				; clock bit high 
014c cb ef			set SPI_SCLK,a 
014e d3 80			out (storage_adata),a 
0150 00				nop 
0151 cd a0 00			call spi_clk 
0154			 
0154			    ; read DO  
0154			 
0154 cb d9		    set 3,c 
0156 db 80			in a,(storage_adata) 
0158 cb 77		    bit SPI_DO,a 
015a 20 02		    jr nz, .b3 
015c cb 99		    res 3,c 
015e			.b3: 
015e				; then low 
015e cb af			res SPI_SCLK,a 
0160 d3 80			out (storage_adata),a 
0162 00				nop 
0163 cd a0 00			call spi_clk 
0166				; clock bit high 
0166 cb ef			set SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b cd a0 00			call spi_clk 
016e			 
016e			    ; read DO  
016e			 
016e cb d1		    set 2,c 
0170 db 80			in a,(storage_adata) 
0172 cb 77		    bit SPI_DO,a 
0174 20 02		    jr nz, .b2 
0176 cb 91		    res 2,c 
0178			.b2: 
0178				; then low 
0178 cb af			res SPI_SCLK,a 
017a d3 80			out (storage_adata),a 
017c 00				nop 
017d cd a0 00			call spi_clk 
0180				; clock bit high 
0180 cb ef			set SPI_SCLK,a 
0182 d3 80			out (storage_adata),a 
0184 00				nop 
0185 cd a0 00			call spi_clk 
0188			 
0188			    ; read DO  
0188			 
0188 cb c9		    set 1,c 
018a db 80			in a,(storage_adata) 
018c cb 77		    bit SPI_DO,a 
018e 20 02		    jr nz, .b1 
0190 cb 89		    res 1,c 
0192			.b1: 
0192				; then low 
0192 cb af			res SPI_SCLK,a 
0194 d3 80			out (storage_adata),a 
0196 00				nop 
0197 cd a0 00			call spi_clk 
019a				; clock bit high 
019a cb ef			set SPI_SCLK,a 
019c d3 80			out (storage_adata),a 
019e 00				nop 
019f cd a0 00			call spi_clk 
01a2			 
01a2			    ; read DO  
01a2			 
01a2 cb c1		    set 0,c 
01a4 db 80			in a,(storage_adata) 
01a6 cb 77		    bit SPI_DO,a 
01a8 20 02		    jr nz, .b0 
01aa cb 81		    res 0,c 
01ac			.b0: 
01ac				; then low 
01ac cb af			res SPI_SCLK,a 
01ae d3 80			out (storage_adata),a 
01b0 00				nop 
01b1 cd a0 00			call spi_clk 
01b4			 
01b4			 
01b4 32 68 fa			ld (spi_portbyte),a 
01b7			 
01b7			    ; return byte 
01b7 79			    ld a,c 
01b8			 
01b8			 
01b8 c9				ret 
01b9			 
01b9			 
01b9			 
01b9			spi_ce_high: 
01b9			 
01b9				if DEBUG_SPI_HARD_CE0 
01b9			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01b9					ret 
01b9			 
01b9				endif 
01b9			 
01b9			 
01b9 f5				push af 
01ba			 
01ba				; send direct ce to port b 
01ba 3e ff			ld a, 255 
01bc d3 81			out (storage_bdata), a 
01be			 
01be f1				pop af 
01bf			 
01bf				; for port a that shares with spi lines AND the mask 
01bf			  
01bf				if DEBUG_SPI 
01bf					push hl 
01bf					ld h, a 
01bf				endif 
01bf			;	ld c, SPI_CE_HIGH 
01bf			;	and c 
01bf cb c7			set SPI_CE0, a 
01c1 cb cf			set SPI_CE1, a 
01c3 cb d7			set SPI_CE2, a 
01c5 cb df			set SPI_CE3, a 
01c7 cb e7			set SPI_CE4, a 
01c9			 
01c9				if DEBUG_SPI 
01c9					ld l, a 
01c9					DMARK "CEh" 
01c9					CALLMONITOR 
01c9					pop hl 
01c9				endif 
01c9 c9				ret 
01ca			 
01ca			 
01ca			spi_ce_low: 
01ca			 
01ca				if DEBUG_SPI_HARD_CE0 
01ca			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ca					ret 
01ca			 
01ca				endif 
01ca			 
01ca c5				push bc 
01cb f5				push af 
01cc			 
01cc				; send direct ce to port b 
01cc 3a 6a fa			ld a, (spi_cartdev) 
01cf d3 81			out (storage_bdata), a 
01d1			 
01d1			 
01d1			 
01d1				; for port a that shares with spi lines AND the mask 
01d1			 
01d1 3a 67 fa			ld a, (spi_device)  
01d4 4f				ld c, a 
01d5			 
01d5 f1				pop af 
01d6			 
01d6				; detect CEx 
01d6			 
01d6				if DEBUG_SPI 
01d6					push hl 
01d6					ld h, a 
01d6				endif 
01d6			 
01d6 cb 41			bit SPI_CE0, c 
01d8 20 04			jr nz, .cel1 
01da cb 87			res SPI_CE0, a 
01dc 18 1e			jr .celn 
01de			.cel1: 
01de cb 49			bit SPI_CE1, c 
01e0 20 04			jr nz, .cel2 
01e2 cb 8f			res SPI_CE1, a 
01e4 18 16			jr .celn 
01e6			.cel2: 
01e6 cb 51			bit SPI_CE2, c 
01e8 20 04			jr nz, .cel3 
01ea cb 97			res SPI_CE2, a 
01ec 18 0e			jr .celn 
01ee			.cel3: 
01ee cb 59			bit SPI_CE3, c 
01f0 20 04			jr nz, .cel4 
01f2 cb 9f			res SPI_CE3, a 
01f4 18 06			jr .celn 
01f6			.cel4: 
01f6 cb 61			bit SPI_CE4, c 
01f8 20 02			jr nz, .celn 
01fa cb a7			res SPI_CE4, a 
01fc			.celn: 
01fc			 
01fc			 
01fc			 
01fc			;	add c 
01fc			 
01fc				if DEBUG_SPI 
01fc					ld l, a 
01fc					DMARK "CEl" 
01fc					CALLMONITOR 
01fc					pop hl 
01fc				endif 
01fc c1				pop bc 
01fd c9				ret 
01fe			 
01fe			 
01fe			 
01fe			; eof 
01fe			 
01fe			 
01fe			 
01fe			 
01fe			 
# End of file firmware_spi.asm
01fe				include "firmware_seeprom.asm"  
01fe			; 
01fe			; persisent storage interface via microchip serial eeprom 
01fe			 
01fe			; port a pio 2 
01fe			; pa 7 - si 
01fe			; pa 6 - sclk  
01fe			; pa 5 - so 
01fe			; pa 4 - cs 
01fe			; pa 3 - cs 
01fe			; pa 2 - cs 
01fe			; pa 1 - cs 
01fe			; pa 0 - cs 
01fe			; 
01fe			; TODO get block 
01fe			; TODO save block 
01fe			; TODO load file 
01fe			; TODO save file 
01fe			; TODO get dir  
01fe			 
01fe			;  
01fe			storage_adata: equ Device_C    ; device c port a - onboard storage 
01fe			storage_actl: equ Device_C+2     ; device c port a 
01fe			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01fe			storage_bctl: equ Device_C+3     ; device c port b 
01fe			 
01fe			 
01fe			; TODO move these to hardware driver file 
01fe			 
01fe			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01fe			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01fe			; storage bank file system format 
01fe			; 
01fe			; first page of bank: 
01fe			; 	addr 0 - status check 
01fe			;       addr 1 - write protect flag 
01fe			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01fe			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01fe			;         TODO see if scanning whole of for available next file id is fast enough 
01fe			;	addr 4 > zero term string of bank label 
01fe			; 
01fe			;        
01fe			;  
01fe			; first page of any file: 
01fe			;      byte 0 - file id  
01fe			;      byte 1-17 - fixed file name  
01fe			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01fe			; 
01fe			; other pages of any file: 
01fe			;      byte 0 - file id 
01fe			;      byte 1> - file data 
01fe			; 
01fe			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01fe			;  
01fe			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01fe			 
01fe			 
01fe			;storage_so_bit: 5 
01fe			;storage_si_bit: 7 
01fe			;storage_sclk_bit: 6 
01fe			  
01fe			 
01fe			; init storage pio 
01fe			 
01fe			storage_init: 
01fe			 
01fe			 
01fe					; set default SPI clk pulse time as disabled 
01fe			 
01fe 3e 00				ld a, 0 
0200 32 6b fa				ld (spi_clktime), a 
0203			 
0203					; init hardware 
0203			 
0203 3e cf		            LD   A, 11001111b 
0205 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0207 3e 00		            LD   A, 00000000b 
0209 cb f7			set SPI_DO,a 
020b			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
020b d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
020d			 
020d 3e cf		            LD   A, 11001111b 
020f d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0211 3e 00		            LD   A, 00000000b 
0213 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
0215			 
0215				; set all external spi devices off  
0215 3e ff			ld a, 255 
0217 32 67 fa			ld (spi_device), a 
021a 32 6a fa			ld (spi_cartdev), a 
021d			 
021d					; ensure the spi bus is in a default stable state 
021d cd ad 00				call se_stable_spi 
0220			 
0220			; TODO scan spi bus and gather which storage banks are present 
0220			 
0220			; populate store_bank_active  
0220			; for each ce line activate and attempt to write first byte of bank and read back 
0220			; if zero is returned then bank is empty 
0220			;   
0220			; 
0220			 
0220					; init file extent cache to save on slow reads 
0220			 
0220			;	ld hl, store_filecache 
0220			;	ld de, 0 
0220			;	ld hl,(de)	 
0220			 
0220			 
0220 c9			    ret 
0221			 
0221			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0221			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0221			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0221			 
0221			; INSTRUCTION SET 
0221			; READ 0000 0011 Read data from memory array beginning at selected address 
0221			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0221			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0221			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0221			; RDSR 0000 0101 Read STATUS register 
0221			; WRSR 0000 0001 Write STATUS register 
0221			; PE 0100 0010 Page Erase – erase one page in memory array 
0221			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0221			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0221			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0221			 
0221			; TODO send byte steam for page without setting the address for every single byte 
0221			; TODO read byte  
0221			 
0221			; byte in a 
0221			; address in hl  
0221			se_writebyte: 
0221			        
0221			    ;   ld c, a 
0221 f5			        push af 
0222 e5			        push hl 
0223			 
0223			    ; initi write mode 
0223			    ; 
0223			    ;CS low 
0223			 
0223 3a 68 fa		       ld a,(spi_portbyte) 
0226 cd ca 01			call spi_ce_low 
0229			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0229 d3 80		       out (storage_adata),a 
022b 32 68 fa		       ld (spi_portbyte), a 
022e			 
022e			    ;clock out wren instruction 
022e			 
022e 3e 06		    ld a, store_wren_ins 
0230 cd b8 00		    call spi_send_byte  
0233			 
0233			    ;cs high to enable write latch 
0233			 
0233 3a 68 fa		       ld a,(spi_portbyte) 
0236 cd b9 01			call spi_ce_high 
0239			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0239 d3 80		       out (storage_adata),a 
023b 32 68 fa		       ld (spi_portbyte), a 
023e			 
023e 00				nop 
023f			    ; 
023f			    ; intial write data 
023f			    ; 
023f			    ; cs low 
023f			     
023f 3a 68 fa		       ld a,(spi_portbyte) 
0242 cd ca 01			call spi_ce_low 
0245			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0245 d3 80		       out (storage_adata),a 
0247 32 68 fa		       ld (spi_portbyte), a 
024a			 
024a			    ; clock out write instruction 
024a			     
024a 3e 02		    ld a, store_write_ins  
024c cd b8 00		    call spi_send_byte  
024f			 
024f			    ; clock out address (depending on address size) 
024f			     
024f e1			    pop hl 
0250 7c			    ld a,h    ; address out msb first 
0251 cd b8 00		    call spi_send_byte  
0254 7d			    ld a,l 
0255 cd b8 00		    call spi_send_byte  
0258			 
0258			    ; clock out byte(s) for page 
0258			 
0258 f1			    pop af 
0259 cd b8 00		    call spi_send_byte  
025c			 
025c			    ; end write with ce high 
025c 3a 68 fa		       ld a,(spi_portbyte) 
025f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
025f cd b9 01			call spi_ce_high 
0262 d3 80		       out (storage_adata),a 
0264 32 68 fa		       ld (spi_portbyte), a 
0267			 
0267				; pause for internal write cycle 
0267 3e 0a			ld a, 10 
0269 cd 7a 0c			call aDelayInMS 
026c c9			    ret 
026d			 
026d			; buffer to write in de 
026d			; address in hl  
026d			se_writepage: 
026d			        
026d			    ;   ld c, a 
026d d5				push de 
026e e5			        push hl 
026f			 
026f			    ; initi write mode 
026f			    ; 
026f			    ;CS low 
026f			 
026f 3a 68 fa		       ld a,(spi_portbyte) 
0272 cd ca 01			call spi_ce_low 
0275			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0275 d3 80		       out (storage_adata),a 
0277 32 68 fa		       ld (spi_portbyte), a 
027a			 
027a			    ;clock out wren instruction 
027a			 
027a 3e 06		    ld a, store_wren_ins 
027c cd b8 00		    call spi_send_byte  
027f			 
027f			    ;cs high to enable write latch 
027f			 
027f 3a 68 fa		       ld a,(spi_portbyte) 
0282 cd b9 01			call spi_ce_high 
0285			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0285 d3 80		       out (storage_adata),a 
0287 32 68 fa		       ld (spi_portbyte), a 
028a			 
028a 00				nop 
028b			    ; 
028b			    ; intial write data 
028b			    ; 
028b			    ; cs low 
028b			     
028b 3a 68 fa		       ld a,(spi_portbyte) 
028e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028e cd ca 01			call spi_ce_low 
0291 d3 80		       out (storage_adata),a 
0293 32 68 fa		       ld (spi_portbyte), a 
0296			 
0296			    ; clock out write instruction 
0296			     
0296 3e 02		    ld a, store_write_ins  
0298 cd b8 00		    call spi_send_byte  
029b			 
029b			    ; clock out address (depending on address size) 
029b			     
029b e1			    pop hl 
029c 7c			    ld a,h    ; address out msb first 
029d cd b8 00		    call spi_send_byte  
02a0 7d			    ld a,l 
02a1 cd b8 00		    call spi_send_byte  
02a4			 
02a4			    ; clock out byte(s) for page 
02a4			 
02a4 e1				pop hl 
02a5 06 40			ld b, STORE_BLOCK_PHY 
02a7			.bytewrite: 
02a7			 
02a7 7e				ld a,(hl) 
02a8 e5			    push hl 
02a9 c5				push bc 
02aa cd b8 00		    call spi_send_byte  
02ad c1				pop bc 
02ae e1				pop hl 
02af			 
02af			    ; end write with ce high 
02af 3a 68 fa		       ld a,(spi_portbyte) 
02b2 cd b9 01			call spi_ce_high 
02b5			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b5 d3 80		       out (storage_adata),a 
02b7 32 68 fa		       ld (spi_portbyte), a 
02ba			 
02ba 23				inc hl 
02bb 10 ea			djnz .bytewrite 
02bd			 
02bd				; pause for internal write cycle 
02bd 3e 64			ld a, 100 
02bf cd 7a 0c			call aDelayInMS 
02c2 c9			    ret 
02c3			; returns byte in a 
02c3			; address in hl  
02c3			se_readbyte: 
02c3 d5				push de 
02c4 c5				push bc 
02c5			 
02c5			    ;   ld c, a 
02c5 e5			        push hl 
02c6			 
02c6			    ; initi write mode 
02c6			    ; 
02c6			    ;CS low 
02c6			 
02c6 3a 68 fa		       ld a,(spi_portbyte) 
02c9 cd ca 01			call spi_ce_low 
02cc			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cc d3 80		       out (storage_adata),a 
02ce 32 68 fa		       ld (spi_portbyte), a 
02d1			 
02d1			    ;clock out wren instruction 
02d1			 
02d1 3e 03		    ld a, store_read_ins 
02d3 cd b8 00		    call spi_send_byte  
02d6			 
02d6			 
02d6			    ; clock out address (depending on address size) 
02d6			     
02d6 e1			    pop hl 
02d7 7c			    ld a,h    ; address out msb first 
02d8 cd b8 00		    call spi_send_byte  
02db 7d			    ld a,l 
02dc cd b8 00		    call spi_send_byte  
02df			 
02df			    ; clock in byte(s) for page 
02df			 
02df cd df 00		    call spi_read_byte  
02e2 f5				push af 
02e3			 
02e3			    ; end write with ce high 
02e3 3a 68 fa		       ld a,(spi_portbyte) 
02e6			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02e6 cd b9 01			call spi_ce_high 
02e9 d3 80		       out (storage_adata),a 
02eb 32 68 fa		       ld (spi_portbyte), a 
02ee			 
02ee f1				pop af 
02ef			 
02ef c1				pop bc 
02f0 d1				pop de 
02f1			 
02f1 c9			    ret 
02f2			 
02f2			if DEBUG_STORESE 
02f2			 
02f2			storageput:  
02f2			 
02f2			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02f2			 
02f2 21 ca f1			ld hl,scratch+2 
02f5 cd 03 13			call get_word_hl 
02f8			 
02f8				; stuff it here for the moment as it will be overwritten later anyway 
02f8			 
02f8 22 eb f4			ld (os_cur_ptr),hl	 
02fb			 
02fb			 
02fb			; get pointer to start of string 
02fb			 
02fb 21 cf f1			ld hl, scratch+7 
02fe			 
02fe			; loop writing char of string to eeprom 
02fe			 
02fe 7e			.writestr:	ld a,(hl) 
02ff fe 00				cp 0 
0301 28 12				jr z, .wsdone		; done writing 
0303 e5					push hl 
0304 2a eb f4				ld hl,(os_cur_ptr) 
0307 cd 21 02				call se_writebyte 
030a			 
030a 2a eb f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
030d 23					inc hl 
030e 22 eb f4				ld (os_cur_ptr),hl 
0311			 
0311					; restore string pointer and get next char 
0311			 
0311 e1					pop hl 
0312 23					inc hl 
0313 18 e9				jr .writestr 
0315			 
0315			 
0315			 
0315			.wsdone: 
0315			 
0315			 
0315			; when done load first page into a buffer  
0315			 
0315 21 00 80				ld hl,08000h		; start in ram 
0318 22 eb f4				ld (os_cur_ptr),hl 
031b 21 00 00				ld hl, 0		 ; start of page 
031e 22 f0 f1				ld (scratch+40),hl	; hang on to it 
0321			 
0321 06 80				ld b, 128		; actually get more then one page 
0323 c5			.wsload:	push bc 
0324 2a f0 f1				ld hl,(scratch+40) 
0327 e5					push hl 
0328 cd c3 02				call se_readbyte 
032b			 
032b					; a now as the byte 
032b			 
032b 2a eb f4				ld hl,(os_cur_ptr) 
032e 77					ld (hl),a 
032f					; inc next buffer area 
032f 23					inc hl 
0330 22 eb f4				ld (os_cur_ptr),hl 
0333			 
0333					; get eeprom position, inc and save for next round 
0333 e1					pop hl		 
0334 23					inc hl 
0335 22 f0 f1				ld (scratch+40),hl 
0338 c1					pop bc 
0339 10 e8				djnz .wsload 
033b			 
033b			; set 'd' pointer to start of buffer 
033b			 
033b 21 00 80				ld hl,08000h 
033e 22 eb f4				ld (os_cur_ptr),hl 
0341			 
0341			 
0341 c9			ret 
0342			 
0342			 
0342 c9			storageread: ret 
0343			 
0343			 
0343			 
0343			 
0343			 
0343			 
0343			endif 
0343			 
0343			 
0343			 
# End of file firmware_seeprom.asm
0343			else  
0343			   ; create some stubs for the labels  
0343			se_readbyte: ret  
0343			se_writebyte: ret  
0343			storage_init: ret  
0343			  
0343			endif  
0343			  
0343			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0343			;include "firmware_cf.asm"  
0343			  
0343			; load up high level storage hardward abstractions  
0343			include "firmware_storage.asm"  
0343			 
0343			; persisent storage hardware abstraction layer  
0343			 
0343			 
0343			 
0343			; Block 0 on storage is a config state 
0343			 
0343			 
0343			 
0343			; TODO add read phy block and write phy block functions 
0343			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0343			 
0343			; Abstraction layer  
0343			 
0343			; Logocial block size is same size as physical size - using tape concept 
0343			 
0343			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0343			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0343			 
0343			 
0343			 
0343			; Filesystem layout (Logical layout) 
0343			; 
0343			; Block 0 - Bank config  
0343			; 
0343			;      Byte - 0 file id counter 
0343			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0343			;      Byte - 3-20 zero terminated bank label 
0343			; 
0343			; Block 1 > File storage 
0343			; 
0343			;      Byte 0 file id    - block 0 file details 
0343			;      Byte 1 block id - block 0 is file  
0343			;            Byte 2-15 - File name 
0343			; 
0343			;       - to end of block data 
0343			; 
0343			 
0343			; Get ID for the file named in pointer held HL 
0343			; Returns ID in HL = 255 if no file found 
0343			 
0343			storage_getid: 
0343			 
0343 22 7a fa			ld (store_tmp1), hl 
0346			 
0346				if DEBUG_STORESE 
0346					DMARK "SGI" 
0346 f5				push af  
0347 3a 5b 03			ld a, (.dmark)  
034a 32 6e fe			ld (debug_mark),a  
034d 3a 5c 03			ld a, (.dmark+1)  
0350 32 6f fe			ld (debug_mark+1),a  
0353 3a 5d 03			ld a, (.dmark+2)  
0356 32 70 fe			ld (debug_mark+2),a  
0359 18 03			jr .pastdmark  
035b ..			.dmark: db "SGI"  
035e f1			.pastdmark: pop af  
035f			endm  
# End of macro DMARK
035f					CALLMONITOR 
035f cd f3 18			call break_point_state  
0362				endm  
# End of macro CALLMONITOR
0362				endif 
0362				; get block 0 and set counter for number of files to scan 
0362			 
0362 cd cd 04			call storage_get_block_0 
0365			 
0365 3a 81 fa			ld a, (store_page) 
0368 47				ld b, a 
0369			 
0369				; get extent 0 of each file id 
0369			 
0369				if DEBUG_STORESE 
0369					DMARK "SGc" 
0369 f5				push af  
036a 3a 7e 03			ld a, (.dmark)  
036d 32 6e fe			ld (debug_mark),a  
0370 3a 7f 03			ld a, (.dmark+1)  
0373 32 6f fe			ld (debug_mark+1),a  
0376 3a 80 03			ld a, (.dmark+2)  
0379 32 70 fe			ld (debug_mark+2),a  
037c 18 03			jr .pastdmark  
037e ..			.dmark: db "SGc"  
0381 f1			.pastdmark: pop af  
0382			endm  
# End of macro DMARK
0382					CALLMONITOR 
0382 cd f3 18			call break_point_state  
0385				endm  
# End of macro CALLMONITOR
0385				endif 
0385 60			.getloop:	ld h, b 
0386 2e 00				ld l, 0 
0388 c5					push bc 
0389			 
0389 11 81 fa				ld de, store_page 
038c				if DEBUG_STORESE 
038c					DMARK "SGr" 
038c f5				push af  
038d 3a a1 03			ld a, (.dmark)  
0390 32 6e fe			ld (debug_mark),a  
0393 3a a2 03			ld a, (.dmark+1)  
0396 32 6f fe			ld (debug_mark+1),a  
0399 3a a3 03			ld a, (.dmark+2)  
039c 32 70 fe			ld (debug_mark+2),a  
039f 18 03			jr .pastdmark  
03a1 ..			.dmark: db "SGr"  
03a4 f1			.pastdmark: pop af  
03a5			endm  
# End of macro DMARK
03a5					CALLMONITOR 
03a5 cd f3 18			call break_point_state  
03a8				endm  
# End of macro CALLMONITOR
03a8				endif 
03a8 cd 75 09				call storage_read 
03ab cd 75 0f				call ishlzero 
03ae 28 2d				jr z, .gap 
03b0					 
03b0					; have a file name read. Is it one we want. 
03b0			 
03b0 2a 7a fa				ld hl, (store_tmp1) 
03b3 11 84 fa				ld de, store_page+3   ; file name 
03b6			 
03b6				if DEBUG_STORESE 
03b6					DMARK "SGc" 
03b6 f5				push af  
03b7 3a cb 03			ld a, (.dmark)  
03ba 32 6e fe			ld (debug_mark),a  
03bd 3a cc 03			ld a, (.dmark+1)  
03c0 32 6f fe			ld (debug_mark+1),a  
03c3 3a cd 03			ld a, (.dmark+2)  
03c6 32 70 fe			ld (debug_mark+2),a  
03c9 18 03			jr .pastdmark  
03cb ..			.dmark: db "SGc"  
03ce f1			.pastdmark: pop af  
03cf			endm  
# End of macro DMARK
03cf					CALLMONITOR 
03cf cd f3 18			call break_point_state  
03d2				endm  
# End of macro CALLMONITOR
03d2				endif 
03d2 cd e2 13				call strcmp 
03d5 20 06				jr nz, .gap   ; not this one 
03d7			 
03d7 c1				        pop bc 
03d8			 
03d8 26 00				ld h, 0 
03da 68					ld l, b 
03db 18 22				jr .getdone 
03dd						 
03dd			 
03dd			 
03dd			 
03dd			.gap: 
03dd				if DEBUG_STORESE 
03dd					DMARK "SGg" 
03dd f5				push af  
03de 3a f2 03			ld a, (.dmark)  
03e1 32 6e fe			ld (debug_mark),a  
03e4 3a f3 03			ld a, (.dmark+1)  
03e7 32 6f fe			ld (debug_mark+1),a  
03ea 3a f4 03			ld a, (.dmark+2)  
03ed 32 70 fe			ld (debug_mark+2),a  
03f0 18 03			jr .pastdmark  
03f2 ..			.dmark: db "SGg"  
03f5 f1			.pastdmark: pop af  
03f6			endm  
# End of macro DMARK
03f6					CALLMONITOR 
03f6 cd f3 18			call break_point_state  
03f9				endm  
# End of macro CALLMONITOR
03f9				endif 
03f9			 
03f9 c1					pop bc 
03fa 10 89				djnz .getloop 
03fc 21 ff 00				ld hl, 255 
03ff			.getdone: 
03ff			 
03ff				if DEBUG_STORESE 
03ff					DMARK "SGe" 
03ff f5				push af  
0400 3a 14 04			ld a, (.dmark)  
0403 32 6e fe			ld (debug_mark),a  
0406 3a 15 04			ld a, (.dmark+1)  
0409 32 6f fe			ld (debug_mark+1),a  
040c 3a 16 04			ld a, (.dmark+2)  
040f 32 70 fe			ld (debug_mark+2),a  
0412 18 03			jr .pastdmark  
0414 ..			.dmark: db "SGe"  
0417 f1			.pastdmark: pop af  
0418			endm  
# End of macro DMARK
0418					CALLMONITOR 
0418 cd f3 18			call break_point_state  
041b				endm  
# End of macro CALLMONITOR
041b				endif 
041b			 
041b c9				ret 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			 
041c			; Read Block 
041c			; ---------- 
041c			; 
041c			; With current bank 
041c			;  
041c			; Get block number to read 
041c			; Load physical blocks starting at start block into buffer 
041c			 
041c			; de points to buffer to use 
041c			; hl holds logical block number  
041c			 
041c			storage_read_block: 
041c			 
041c				; TODO bank selection 
041c			 
041c				; for each of the physical blocks read it into the buffer 
041c 06 40			ld b, STORE_BLOCK_PHY 
041e			 
041e				if DEBUG_STORESE 
041e d5					push de 
041f				endif 
041f				 
041f			.rl1:    
041f			 
041f				; read physical block at hl into de 
041f			        ; increment hl and de to next read position on exit 
041f			 
041f e5				push hl 
0420 d5				push de	 
0421 c5				push bc 
0422			;	if DEBUG_STORESE 
0422			;		push af 
0422			;		ld a, 'R' 
0422			;		ld (debug_mark),a 
0422			;		pop af 
0422			;		CALLMONITOR 
0422			;	endif 
0422 cd c3 02			call se_readbyte 
0425			;	if DEBUG_STORESE 
0425			;		ld a,(spi_portbyte) 
0425			;		ld l, a 
0425			;		push af 
0425			;		ld a, '1' 
0425			;		ld (debug_mark),a 
0425			;		pop af 
0425			;		CALLMONITOR 
0425			;	endif 
0425 c1				pop bc 
0426 d1				pop de 
0427 e1				pop hl 
0428 12				ld (de),a 
0429 23				inc hl 
042a 13				inc de 
042b			 
042b			;	if DEBUG_STORESE 
042b			;		push af 
042b			;		ld a, 'r' 
042b			;		ld (debug_mark),a 
042b			;		pop af 
042b			;		CALLMONITOR 
042b			;	endif 
042b			 
042b 10 f2			djnz .rl1 
042d			 
042d				if DEBUG_STORESE 
042d					DMARK "SRB" 
042d f5				push af  
042e 3a 42 04			ld a, (.dmark)  
0431 32 6e fe			ld (debug_mark),a  
0434 3a 43 04			ld a, (.dmark+1)  
0437 32 6f fe			ld (debug_mark+1),a  
043a 3a 44 04			ld a, (.dmark+2)  
043d 32 70 fe			ld (debug_mark+2),a  
0440 18 03			jr .pastdmark  
0442 ..			.dmark: db "SRB"  
0445 f1			.pastdmark: pop af  
0446			endm  
# End of macro DMARK
0446 d1					pop de 
0447			; 
0447			;		push af 
0447			;		ld a, 'R' 
0447			;		ld (debug_mark),a 
0447			;		pop af 
0447					CALLMONITOR 
0447 cd f3 18			call break_point_state  
044a				endm  
# End of macro CALLMONITOR
044a				endif 
044a c9				ret	 
044b				 
044b			 
044b			; File Size 
044b			; --------- 
044b			; 
044b			;   hl file id 
044b			; 
044b			;  returns in hl the number of blocks 
044b			 
044b			storage_file_size: 
044b 5d				ld e, l 
044c 16 00			ld d, 0 
044e 21 40 00			ld hl, STORE_BLOCK_PHY 
0451					if DEBUG_FORTH_WORDS 
0451						DMARK "SIZ" 
0451 f5				push af  
0452 3a 66 04			ld a, (.dmark)  
0455 32 6e fe			ld (debug_mark),a  
0458 3a 67 04			ld a, (.dmark+1)  
045b 32 6f fe			ld (debug_mark+1),a  
045e 3a 68 04			ld a, (.dmark+2)  
0461 32 70 fe			ld (debug_mark+2),a  
0464 18 03			jr .pastdmark  
0466 ..			.dmark: db "SIZ"  
0469 f1			.pastdmark: pop af  
046a			endm  
# End of macro DMARK
046a						CALLMONITOR 
046a cd f3 18			call break_point_state  
046d				endm  
# End of macro CALLMONITOR
046d					endif 
046d cd 4f 07			call storage_findnextid 
0470			 
0470 cd 75 0f			call ishlzero 
0473			;	ld a, l 
0473			;	add h 
0473			;	cp 0 
0473 c8				ret z			; block not found so EOF 
0474			 
0474 11 81 fa			ld de, store_page 
0477 cd 1c 04			call storage_read_block 
047a			 
047a 3a 83 fa			ld a, (store_page+2)	 ; get extent count 
047d 6f				ld l, a 
047e 26 00			ld h, 0 
0480 c9			 	ret 
0481			 
0481			 
0481			; Write Block 
0481			; ----------- 
0481			; 
0481			; With current bank 
0481			;  
0481			; Get block number to write 
0481			; Write physical blocks starting at start block from buffer 
0481			  
0481			storage_write_block: 
0481				; TODO bank selection 
0481			 
0481				; for each of the physical blocks read it into the buffer 
0481 06 40			ld b, STORE_BLOCK_PHY 
0483			 
0483				if DEBUG_STORESE 
0483					DMARK "SWB" 
0483 f5				push af  
0484 3a 98 04			ld a, (.dmark)  
0487 32 6e fe			ld (debug_mark),a  
048a 3a 99 04			ld a, (.dmark+1)  
048d 32 6f fe			ld (debug_mark+1),a  
0490 3a 9a 04			ld a, (.dmark+2)  
0493 32 70 fe			ld (debug_mark+2),a  
0496 18 03			jr .pastdmark  
0498 ..			.dmark: db "SWB"  
049b f1			.pastdmark: pop af  
049c			endm  
# End of macro DMARK
049c			 
049c					;push af 
049c					;ld a, 'W' 
049c					;ld (debug_mark),a 
049c					;pop af 
049c					CALLMONITOR 
049c cd f3 18			call break_point_state  
049f				endm  
# End of macro CALLMONITOR
049f				endif 
049f			 
049f			; might not be working 
049f			;	call se_writepage 
049f			 
049f			;	ret 
049f			; 
049f			 
049f			 
049f			 
049f			.wl1:    
049f			 
049f				; read physical block at hl into de 
049f			        ; increment hl and de to next read position on exit 
049f			 
049f e5				push hl 
04a0 d5				push de	 
04a1 c5				push bc 
04a2 1a				ld a,(de) 
04a3				;if DEBUG_STORESE 
04a3			;		push af 
04a3			;		ld a, 'W' 
04a3			;		ld (debug_mark),a 
04a3			;		pop af 
04a3			;		CALLMONITOR 
04a3			;	endif 
04a3 cd 21 02			call se_writebyte 
04a6			;	call delay250ms 
04a6 00				nop 
04a7 00				nop 
04a8 00				nop 
04a9			;	if DEBUG_STORESE 
04a9			;		push af 
04a9			;		ld a, 'w' 
04a9			;		ld (debug_mark),a 
04a9			;		pop af 
04a9			;		CALLMONITOR 
04a9			;	endif 
04a9 c1				pop bc 
04aa d1				pop de 
04ab e1				pop hl 
04ac 23				inc hl 
04ad 13				inc de 
04ae			 
04ae			 
04ae 10 ef			djnz .wl1 
04b0			 
04b0				if DEBUG_STORESE 
04b0					DMARK "SW2" 
04b0 f5				push af  
04b1 3a c5 04			ld a, (.dmark)  
04b4 32 6e fe			ld (debug_mark),a  
04b7 3a c6 04			ld a, (.dmark+1)  
04ba 32 6f fe			ld (debug_mark+1),a  
04bd 3a c7 04			ld a, (.dmark+2)  
04c0 32 70 fe			ld (debug_mark+2),a  
04c3 18 03			jr .pastdmark  
04c5 ..			.dmark: db "SW2"  
04c8 f1			.pastdmark: pop af  
04c9			endm  
# End of macro DMARK
04c9			 
04c9					;push af 
04c9					;ld a, 'W' 
04c9					;ld (debug_mark),a 
04c9					;pop af 
04c9					CALLMONITOR 
04c9 cd f3 18			call break_point_state  
04cc				endm  
# End of macro CALLMONITOR
04cc				endif 
04cc c9				ret	 
04cd			 
04cd			; Init bank 
04cd			; --------- 
04cd			; 
04cd			; With current bank 
04cd			; 
04cd			; Setup block 0 config 
04cd			;     Set 0 file id counter 
04cd			;     Set formatted byte pattern 
04cd			;     Zero out bank label 
04cd			;      
04cd			; For every logical block write 0-1 byte as null 
04cd			 
04cd			storage_get_block_0: 
04cd			 
04cd				; TODO check presence 
04cd			 
04cd				; get block 0 config 
04cd			 
04cd 21 00 00			ld hl, 0 
04d0 11 81 fa			ld de, store_page 
04d3 cd 1c 04			call storage_read_block 
04d6			 
04d6				if DEBUG_STORESE 
04d6					DMARK "SB0" 
04d6 f5				push af  
04d7 3a eb 04			ld a, (.dmark)  
04da 32 6e fe			ld (debug_mark),a  
04dd 3a ec 04			ld a, (.dmark+1)  
04e0 32 6f fe			ld (debug_mark+1),a  
04e3 3a ed 04			ld a, (.dmark+2)  
04e6 32 70 fe			ld (debug_mark+2),a  
04e9 18 03			jr .pastdmark  
04eb ..			.dmark: db "SB0"  
04ee f1			.pastdmark: pop af  
04ef			endm  
# End of macro DMARK
04ef 11 81 fa				ld de, store_page 
04f2			;		push af 
04f2			;		ld a, 'i' 
04f2			;		ld (debug_mark),a 
04f2			;		pop af 
04f2					CALLMONITOR 
04f2 cd f3 18			call break_point_state  
04f5				endm  
# End of macro CALLMONITOR
04f5				endif 
04f5			 
04f5				; is this area formatted? 
04f5			 
04f5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04f5 2a 82 fa			ld hl, (store_page+1) 
04f8 3e 80			ld a,0x80 
04fa bd				cp l 
04fb 20 22			jr nz, .ininotformatted 
04fd				; do a double check 
04fd 3e 27			ld a, 0x27 
04ff bc				cp h 
0500 20 1d			jr nz, .ininotformatted 
0502			 
0502				; formatted then 
0502			 
0502				if DEBUG_STORESE 
0502					DMARK "SB1" 
0502 f5				push af  
0503 3a 17 05			ld a, (.dmark)  
0506 32 6e fe			ld (debug_mark),a  
0509 3a 18 05			ld a, (.dmark+1)  
050c 32 6f fe			ld (debug_mark+1),a  
050f 3a 19 05			ld a, (.dmark+2)  
0512 32 70 fe			ld (debug_mark+2),a  
0515 18 03			jr .pastdmark  
0517 ..			.dmark: db "SB1"  
051a f1			.pastdmark: pop af  
051b			endm  
# End of macro DMARK
051b					;push af 
051b					;ld a, 'I' 
051b					;ld (debug_mark),a 
051b					;pop af 
051b					CALLMONITOR 
051b cd f3 18			call break_point_state  
051e				endm  
# End of macro CALLMONITOR
051e				endif 
051e c9				ret 
051f			 
051f			.ininotformatted: 
051f				; bank not formatted so poke various bits to make sure 
051f			 
051f				if DEBUG_STORESE 
051f					DMARK "SB2" 
051f f5				push af  
0520 3a 34 05			ld a, (.dmark)  
0523 32 6e fe			ld (debug_mark),a  
0526 3a 35 05			ld a, (.dmark+1)  
0529 32 6f fe			ld (debug_mark+1),a  
052c 3a 36 05			ld a, (.dmark+2)  
052f 32 70 fe			ld (debug_mark+2),a  
0532 18 03			jr .pastdmark  
0534 ..			.dmark: db "SB2"  
0537 f1			.pastdmark: pop af  
0538			endm  
# End of macro DMARK
0538					;push af 
0538					;ld a, 'f' 
0538					;ld (debug_mark),a 
0538					;pop af 
0538					CALLMONITOR 
0538 cd f3 18			call break_point_state  
053b				endm  
# End of macro CALLMONITOR
053b				endif 
053b			 
053b cd 58 0c			call storage_clear_page 
053e			 
053e 21 81 fa			ld hl, store_page 
0541 3e 00			ld a, 0 
0543				 
0543 77				ld (hl),a   ; reset file counter 
0544			 
0544 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0547 22 82 fa		 	ld (store_page+1), hl	 
054a			 
054a				; set default label 
054a			 
054a 21 e6 05			ld hl, .defaultbanklabl 
054d 11 84 fa		 	ld de, store_page+3 
0550 01 0f 00			ld bc, 15 
0553 ed b0			ldir 
0555			 
0555				; Append the current bank id 
0555 21 8d fa			ld hl, store_page+3+9 
0558 3a 66 fa			ld a, (spi_device_id) 
055b 77				ld (hl), a 
055c			 
055c				; save default page 0 
055c			 
055c 21 00 00			ld hl, 0 
055f 11 81 fa			ld de, store_page 
0562				if DEBUG_STORESE 
0562					DMARK "SB3" 
0562 f5				push af  
0563 3a 77 05			ld a, (.dmark)  
0566 32 6e fe			ld (debug_mark),a  
0569 3a 78 05			ld a, (.dmark+1)  
056c 32 6f fe			ld (debug_mark+1),a  
056f 3a 79 05			ld a, (.dmark+2)  
0572 32 70 fe			ld (debug_mark+2),a  
0575 18 03			jr .pastdmark  
0577 ..			.dmark: db "SB3"  
057a f1			.pastdmark: pop af  
057b			endm  
# End of macro DMARK
057b			;		push af 
057b			;		ld a, 'F' 
057b			;		ld (debug_mark),a 
057b			;		pop af 
057b					CALLMONITOR 
057b cd f3 18			call break_point_state  
057e				endm  
# End of macro CALLMONITOR
057e				endif 
057e cd 81 04			call storage_write_block 
0581				if DEBUG_STORESE 
0581					DMARK "SB4" 
0581 f5				push af  
0582 3a 96 05			ld a, (.dmark)  
0585 32 6e fe			ld (debug_mark),a  
0588 3a 97 05			ld a, (.dmark+1)  
058b 32 6f fe			ld (debug_mark+1),a  
058e 3a 98 05			ld a, (.dmark+2)  
0591 32 70 fe			ld (debug_mark+2),a  
0594 18 03			jr .pastdmark  
0596 ..			.dmark: db "SB4"  
0599 f1			.pastdmark: pop af  
059a			endm  
# End of macro DMARK
059a			;		push af 
059a			;		ld a, '>' 
059a			;		ld (debug_mark),a 
059a			;		pop af 
059a					CALLMONITOR 
059a cd f3 18			call break_point_state  
059d				endm  
# End of macro CALLMONITOR
059d				endif 
059d			 
059d 00				nop 
059e 00				nop 
059f 00				nop 
05a0			 
05a0				; now set 0 in every page to mark as a free block 
05a0			 
05a0 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05a2 21 40 00			ld hl, STORE_BLOCK_PHY 
05a5			 
05a5 3e 00		.setmark1:   	ld a,0 
05a7 e5					push hl 
05a8 c5					push bc 
05a9 cd 21 02				call se_writebyte 
05ac 3e 0a			ld a, 10 
05ae cd 7a 0c			call aDelayInMS 
05b1 23				inc hl 
05b2 cd 21 02				call se_writebyte 
05b5 3e 0a			ld a, 10 
05b7 cd 7a 0c			call aDelayInMS 
05ba 2b				dec hl 
05bb c1					pop bc 
05bc e1					pop hl 
05bd 3e 40				ld a, STORE_BLOCK_PHY 
05bf cd 4c 0f				call addatohl 
05c2 10 e1				djnz .setmark1 
05c4			 
05c4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05c6 3e 00		.setmark2:   	ld a,0 
05c8 e5					push hl 
05c9 c5					push bc 
05ca cd 21 02				call se_writebyte 
05cd 3e 0a			ld a, 10 
05cf cd 7a 0c			call aDelayInMS 
05d2 23				inc hl 
05d3 cd 21 02				call se_writebyte 
05d6 3e 0a			ld a, 10 
05d8 cd 7a 0c			call aDelayInMS 
05db 2b				dec hl 
05dc c1					pop bc 
05dd e1					pop hl 
05de 3e 40				ld a, STORE_BLOCK_PHY 
05e0 cd 4c 0f				call addatohl 
05e3 10 e1				djnz .setmark2 
05e5			 
05e5					 
05e5			 
05e5			 
05e5 c9				ret 
05e6			 
05e6			 
05e6			 
05e6			 
05e6 .. 00		.defaultbanklabl:   db "BankLabel_",0 
05f1			 
05f1			 
05f1			 
05f1			; Label Bank 
05f1			; ---------- 
05f1			; 
05f1			; With current bank 
05f1			; Read block 0 
05f1			; Set label 
05f1			; Write block 0 
05f1			 
05f1			; label str pointer in hl 
05f1			 
05f1			storage_label:     
05f1			 
05f1				if DEBUG_STORESE 
05f1					DMARK "LBL" 
05f1 f5				push af  
05f2 3a 06 06			ld a, (.dmark)  
05f5 32 6e fe			ld (debug_mark),a  
05f8 3a 07 06			ld a, (.dmark+1)  
05fb 32 6f fe			ld (debug_mark+1),a  
05fe 3a 08 06			ld a, (.dmark+2)  
0601 32 70 fe			ld (debug_mark+2),a  
0604 18 03			jr .pastdmark  
0606 ..			.dmark: db "LBL"  
0609 f1			.pastdmark: pop af  
060a			endm  
# End of macro DMARK
060a					CALLMONITOR 
060a cd f3 18			call break_point_state  
060d				endm  
# End of macro CALLMONITOR
060d				endif 
060d			 
060d e5				push hl 
060e			 
060e cd cd 04			call storage_get_block_0 
0611			 
0611				; set default label 
0611			 
0611 e1				pop hl 
0612			 
0612 11 84 fa		 	ld de, store_page+3 
0615 01 0f 00			ld bc, 15 
0618				if DEBUG_STORESE 
0618					DMARK "LB3" 
0618 f5				push af  
0619 3a 2d 06			ld a, (.dmark)  
061c 32 6e fe			ld (debug_mark),a  
061f 3a 2e 06			ld a, (.dmark+1)  
0622 32 6f fe			ld (debug_mark+1),a  
0625 3a 2f 06			ld a, (.dmark+2)  
0628 32 70 fe			ld (debug_mark+2),a  
062b 18 03			jr .pastdmark  
062d ..			.dmark: db "LB3"  
0630 f1			.pastdmark: pop af  
0631			endm  
# End of macro DMARK
0631					CALLMONITOR 
0631 cd f3 18			call break_point_state  
0634				endm  
# End of macro CALLMONITOR
0634				endif 
0634 ed b0			ldir 
0636				; save default page 0 
0636			 
0636 21 00 00			ld hl, 0 
0639 11 81 fa			ld de, store_page 
063c				if DEBUG_STORESE 
063c					DMARK "LBW" 
063c f5				push af  
063d 3a 51 06			ld a, (.dmark)  
0640 32 6e fe			ld (debug_mark),a  
0643 3a 52 06			ld a, (.dmark+1)  
0646 32 6f fe			ld (debug_mark+1),a  
0649 3a 53 06			ld a, (.dmark+2)  
064c 32 70 fe			ld (debug_mark+2),a  
064f 18 03			jr .pastdmark  
0651 ..			.dmark: db "LBW"  
0654 f1			.pastdmark: pop af  
0655			endm  
# End of macro DMARK
0655					CALLMONITOR 
0655 cd f3 18			call break_point_state  
0658				endm  
# End of macro CALLMONITOR
0658				endif 
0658 cd 81 04			call storage_write_block 
065b			 
065b c9				ret 
065c			 
065c			 
065c			 
065c			; Read Block 0 - Config 
065c			; --------------------- 
065c			; 
065c			; With current bank 
065c			; Call presence test 
065c			;    If not present format/init bank  
065c			; Read block 0  
065c			;  
065c			 
065c			 
065c			; Dir 
065c			; --- 
065c			; 
065c			; With current bank 
065c			; Load Block 0 Config 
065c			; Get max file id number 
065c			; For each logical block 
065c			;    Read block read byte 2 
065c			;      if first block of file 
065c			;         Display file name 
065c			;         Display type flags for file 
065c			;        
065c			 
065c			; moving to words as this requires stack control 
065c			 
065c			 
065c			; Delete File 
065c			; ----------- 
065c			; 
065c			; With current bank 
065c			; 
065c			; Load Block 0 Config 
065c			; Get max file id number 
065c			; For each logical block 
065c			;    Read block file id 
065c			;      If first block of file and dont have file id 
065c			;         if file to delete 
065c			;         Save file id 
065c			;         Null file id 
065c			;         Write this block back 
065c			;      If file id is one saved 
065c			;         Null file id 
065c			;         Write this block back 
065c			 
065c			 
065c			.se_done: 
065c e1				pop hl 
065d c9				ret 
065e			 
065e			storage_erase: 
065e			 
065e				; hl contains the file id 
065e			 
065e 5d				ld e, l 
065f 16 00			ld d, 0 
0661 21 40 00			ld hl, STORE_BLOCK_PHY 
0664					if DEBUG_FORTH_WORDS 
0664						DMARK "ERA" 
0664 f5				push af  
0665 3a 79 06			ld a, (.dmark)  
0668 32 6e fe			ld (debug_mark),a  
066b 3a 7a 06			ld a, (.dmark+1)  
066e 32 6f fe			ld (debug_mark+1),a  
0671 3a 7b 06			ld a, (.dmark+2)  
0674 32 70 fe			ld (debug_mark+2),a  
0677 18 03			jr .pastdmark  
0679 ..			.dmark: db "ERA"  
067c f1			.pastdmark: pop af  
067d			endm  
# End of macro DMARK
067d						CALLMONITOR 
067d cd f3 18			call break_point_state  
0680				endm  
# End of macro CALLMONITOR
0680					endif 
0680 cd 4f 07			call storage_findnextid 
0683 cd 75 0f			call ishlzero 
0686 c8				ret z 
0687			 
0687 e5				push hl 
0688			 
0688				; TODO check file not found 
0688			 
0688 11 81 fa			ld de, store_page 
068b cd 1c 04			call storage_read_block 
068e			 
068e cd 75 0f			call ishlzero 
0691 ca 5c 06			jp z,.se_done 
0694			 
0694					if DEBUG_FORTH_WORDS 
0694						DMARK "ER1" 
0694 f5				push af  
0695 3a a9 06			ld a, (.dmark)  
0698 32 6e fe			ld (debug_mark),a  
069b 3a aa 06			ld a, (.dmark+1)  
069e 32 6f fe			ld (debug_mark+1),a  
06a1 3a ab 06			ld a, (.dmark+2)  
06a4 32 70 fe			ld (debug_mark+2),a  
06a7 18 03			jr .pastdmark  
06a9 ..			.dmark: db "ER1"  
06ac f1			.pastdmark: pop af  
06ad			endm  
# End of macro DMARK
06ad						CALLMONITOR 
06ad cd f3 18			call break_point_state  
06b0				endm  
# End of macro CALLMONITOR
06b0					endif 
06b0 3a 81 fa			ld a, (store_page)	; get file id 
06b3 32 75 fa			ld (store_tmpid), a 
06b6			 
06b6 3a 83 fa			ld a, (store_page+2)    ; get count of extends 
06b9 32 74 fa			ld (store_tmpext), a 
06bc			 
06bc				; wipe file header 
06bc			 
06bc e1				pop hl 
06bd 3e 00			ld a, 0 
06bf 32 81 fa			ld (store_page), a 
06c2 32 82 fa			ld (store_page+1),a 
06c5 11 81 fa			ld de, store_page 
06c8					if DEBUG_FORTH_WORDS 
06c8						DMARK "ER2" 
06c8 f5				push af  
06c9 3a dd 06			ld a, (.dmark)  
06cc 32 6e fe			ld (debug_mark),a  
06cf 3a de 06			ld a, (.dmark+1)  
06d2 32 6f fe			ld (debug_mark+1),a  
06d5 3a df 06			ld a, (.dmark+2)  
06d8 32 70 fe			ld (debug_mark+2),a  
06db 18 03			jr .pastdmark  
06dd ..			.dmark: db "ER2"  
06e0 f1			.pastdmark: pop af  
06e1			endm  
# End of macro DMARK
06e1						CALLMONITOR 
06e1 cd f3 18			call break_point_state  
06e4				endm  
# End of macro CALLMONITOR
06e4					endif 
06e4 cd 81 04			call storage_write_block 
06e7			 
06e7			 
06e7				; wipe file extents 
06e7			 
06e7 3a 74 fa			ld a, (store_tmpext) 
06ea 47				ld b, a 
06eb			 
06eb			.eraext:	  
06eb c5				push bc 
06ec			 
06ec 21 40 00			ld hl, STORE_BLOCK_PHY 
06ef 3a 75 fa			ld a,(store_tmpid) 
06f2 5f				ld e, a 
06f3 50				ld d, b	 
06f4					if DEBUG_FORTH_WORDS 
06f4						DMARK "ER3" 
06f4 f5				push af  
06f5 3a 09 07			ld a, (.dmark)  
06f8 32 6e fe			ld (debug_mark),a  
06fb 3a 0a 07			ld a, (.dmark+1)  
06fe 32 6f fe			ld (debug_mark+1),a  
0701 3a 0b 07			ld a, (.dmark+2)  
0704 32 70 fe			ld (debug_mark+2),a  
0707 18 03			jr .pastdmark  
0709 ..			.dmark: db "ER3"  
070c f1			.pastdmark: pop af  
070d			endm  
# End of macro DMARK
070d						CALLMONITOR 
070d cd f3 18			call break_point_state  
0710				endm  
# End of macro CALLMONITOR
0710					endif 
0710 cd 4f 07			call storage_findnextid 
0713 cd 75 0f			call ishlzero 
0716 ca 5c 06			jp z,.se_done 
0719			 
0719 e5				push hl 
071a 11 81 fa			ld de, store_page 
071d cd 1c 04			call storage_read_block 
0720			 
0720				; free block	 
0720			 
0720 3e 00			ld a, 0 
0722 32 81 fa			ld (store_page), a 
0725 32 82 fa			ld (store_page+1),a 
0728 11 81 fa			ld de, store_page 
072b e1				pop hl 
072c					if DEBUG_FORTH_WORDS 
072c						DMARK "ER4" 
072c f5				push af  
072d 3a 41 07			ld a, (.dmark)  
0730 32 6e fe			ld (debug_mark),a  
0733 3a 42 07			ld a, (.dmark+1)  
0736 32 6f fe			ld (debug_mark+1),a  
0739 3a 43 07			ld a, (.dmark+2)  
073c 32 70 fe			ld (debug_mark+2),a  
073f 18 03			jr .pastdmark  
0741 ..			.dmark: db "ER4"  
0744 f1			.pastdmark: pop af  
0745			endm  
# End of macro DMARK
0745						CALLMONITOR 
0745 cd f3 18			call break_point_state  
0748				endm  
# End of macro CALLMONITOR
0748					endif 
0748 cd 81 04			call storage_write_block 
074b			 
074b c1				pop bc 
074c 10 9d			djnz .eraext 
074e			 
074e c9				ret 
074f			 
074f			 
074f			; Find Free Block 
074f			; --------------- 
074f			; 
074f			; With current bank 
074f			;  
074f			; From given starting logical block 
074f			;    Read block  
074f			;    If no file id 
074f			;         Return block id 
074f			 
074f			 
074f			; hl starting page number 
074f			; hl contains free page number or zero if no pages free 
074f			; e contains the file id to locate 
074f			; d contains the block number 
074f			 
074f			; TODO change to find file id and use zero for free block 
074f			 
074f			storage_findnextid: 
074f			 
074f				; now locate first 0 page to mark as a free block 
074f			 
074f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0751			;	ld hl, STORE_BLOCK_PHY 
0751			 
0751					if DEBUG_FORTH_WORDS 
0751					DMARK "FNI" 
0751 f5				push af  
0752 3a 66 07			ld a, (.dmark)  
0755 32 6e fe			ld (debug_mark),a  
0758 3a 67 07			ld a, (.dmark+1)  
075b 32 6f fe			ld (debug_mark+1),a  
075e 3a 68 07			ld a, (.dmark+2)  
0761 32 70 fe			ld (debug_mark+2),a  
0764 18 03			jr .pastdmark  
0766 ..			.dmark: db "FNI"  
0769 f1			.pastdmark: pop af  
076a			endm  
# End of macro DMARK
076a						CALLMONITOR 
076a cd f3 18			call break_point_state  
076d				endm  
# End of macro CALLMONITOR
076d					endif 
076d			.ff1:   	 
076d e5					push hl 
076e c5					push bc 
076f d5					push de 
0770 cd c3 02				call se_readbyte 
0773 5f					ld e,a 
0774 23					inc hl 
0775 cd c3 02				call se_readbyte 
0778 57					ld d, a 
0779 e1					pop hl 
077a e5					push hl 
077b cd 6a 0f				call cmp16 
077e 28 49				jr z, .fffound 
0780			 
0780 d1					pop de 
0781 c1					pop bc 
0782 e1					pop hl 
0783			 
0783					; is found? 
0783					;cp e 
0783					;ret z 
0783			 
0783 3e 40				ld a, STORE_BLOCK_PHY 
0785 cd 4c 0f				call addatohl 
0788 10 e3				djnz .ff1 
078a			 
078a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
078c			.ff2:   	 
078c			 
078c e5					push hl 
078d c5					push bc 
078e d5					push de 
078f cd c3 02				call se_readbyte 
0792 5f					ld e,a 
0793 23					inc hl 
0794 cd c3 02				call se_readbyte 
0797 57					ld d, a 
0798			 
0798 e1					pop hl 
0799 e5					push hl 
079a cd 6a 0f				call cmp16 
079d 28 2a				jr z, .fffound 
079f			 
079f d1					pop de 
07a0 c1					pop bc 
07a1 e1					pop hl 
07a2					; is found? 
07a2					;cp e 
07a2					;ret z 
07a2			 
07a2 3e 40				ld a, STORE_BLOCK_PHY 
07a4 cd 4c 0f				call addatohl 
07a7 10 e3				djnz .ff2 
07a9			 
07a9			 
07a9					if DEBUG_FORTH_WORDS 
07a9					DMARK "FN-" 
07a9 f5				push af  
07aa 3a be 07			ld a, (.dmark)  
07ad 32 6e fe			ld (debug_mark),a  
07b0 3a bf 07			ld a, (.dmark+1)  
07b3 32 6f fe			ld (debug_mark+1),a  
07b6 3a c0 07			ld a, (.dmark+2)  
07b9 32 70 fe			ld (debug_mark+2),a  
07bc 18 03			jr .pastdmark  
07be ..			.dmark: db "FN-"  
07c1 f1			.pastdmark: pop af  
07c2			endm  
# End of macro DMARK
07c2					;	push af 
07c2					;	ld a, 'n' 
07c2					;	ld (debug_mark),a 
07c2					;	pop af 
07c2						CALLMONITOR 
07c2 cd f3 18			call break_point_state  
07c5				endm  
# End of macro CALLMONITOR
07c5					endif 
07c5				; no free marks! 
07c5 21 00 00				ld hl, 0 
07c8 c9				ret 
07c9			.fffound: 
07c9				 
07c9			 
07c9 d1					pop de 
07ca c1					pop bc 
07cb e1					pop hl 
07cc					if DEBUG_FORTH_WORDS 
07cc					DMARK "FNF" 
07cc f5				push af  
07cd 3a e1 07			ld a, (.dmark)  
07d0 32 6e fe			ld (debug_mark),a  
07d3 3a e2 07			ld a, (.dmark+1)  
07d6 32 6f fe			ld (debug_mark+1),a  
07d9 3a e3 07			ld a, (.dmark+2)  
07dc 32 70 fe			ld (debug_mark+2),a  
07df 18 03			jr .pastdmark  
07e1 ..			.dmark: db "FNF"  
07e4 f1			.pastdmark: pop af  
07e5			endm  
# End of macro DMARK
07e5					;	push af 
07e5					;	ld a, 'n' 
07e5					;	ld (debug_mark),a 
07e5					;	pop af 
07e5						CALLMONITOR 
07e5 cd f3 18			call break_point_state  
07e8				endm  
# End of macro CALLMONITOR
07e8					endif 
07e8 c9				ret 
07e9			 
07e9			 
07e9			 
07e9			; Free Space 
07e9			; ---------- 
07e9			; 
07e9			; With current bank 
07e9			; 
07e9			; Set block count to zero 
07e9			; Starting with first logical block 
07e9			;      Find free block  
07e9			;      If block id given, increment block count 
07e9			; 
07e9			;  
07e9			 
07e9			 
07e9			; hl contains count of free blocks 
07e9			 
07e9			storage_freeblocks: 
07e9			 
07e9				; now locate first 0 page to mark as a free block 
07e9			 
07e9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07eb 21 40 00			ld hl, STORE_BLOCK_PHY 
07ee 11 00 00			ld de, 0 
07f1			 
07f1			.fb1:   	 
07f1 e5					push hl 
07f2 c5					push bc 
07f3 d5					push de 
07f4 cd c3 02				call se_readbyte 
07f7 d1					pop de 
07f8 c1					pop bc 
07f9 e1					pop hl 
07fa			 
07fa					; is free? 
07fa fe 00				cp 0 
07fc 20 01				jr nz, .ff1cont 
07fe 13					inc de 
07ff			 
07ff			.ff1cont: 
07ff			 
07ff			 
07ff 3e 40				ld a, STORE_BLOCK_PHY 
0801 cd 4c 0f				call addatohl 
0804 10 eb				djnz .fb1 
0806			 
0806 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0808			.fb2:   	 
0808 e5					push hl 
0809 c5					push bc 
080a d5					push de 
080b cd c3 02				call se_readbyte 
080e d1					pop de 
080f c1					pop bc 
0810 e1					pop hl 
0811			 
0811					; is free? 
0811 fe 00				cp 0 
0813 20 01				jr nz, .ff2cont 
0815 13					inc de 
0816			 
0816			.ff2cont: 
0816			 
0816 3e 40				ld a, STORE_BLOCK_PHY 
0818 cd 4c 0f				call addatohl 
081b 10 eb				djnz .fb2 
081d			 
081d eb				ex de, hl 
081e c9				ret 
081f			 
081f			; Get File ID 
081f			; ----------- 
081f			; 
081f			; With current bank 
081f			;  
081f			; Load Block 0 Config 
081f			; Get max file id number 
081f			; For each logical block 
081f			;    Read block file id 
081f			;      If first block of file and dont have file id 
081f			;         if file get id and exit 
081f			 
081f			 
081f			 
081f			 
081f			; Create File 
081f			; ----------- 
081f			; 
081f			; With current bank  
081f			; Load Block 0 Config 
081f			; Get max file id number 
081f			; Increment file id number 
081f			; Save Config 
081f			; Find free block 
081f			; Set buffer with file name and file id 
081f			; Write buffer to free block  
081f			 
081f			 
081f			; hl point to file name 
081f			; hl returns file id 
081f			 
081f			; file format: 
081f			; byte 0 - file id 
081f			; byte 1 - extent number 
081f			; byte 2-> data 
081f			 
081f			; format for extent number 0: 
081f			; 
081f			; byte 0 - file id 
081f			; byte 1 - extent 0 
081f			; byte 2 - extent count 
081f			; byte 3 -> file name and meta data 
081f			 
081f			 
081f			storage_create: 
081f				if DEBUG_STORESE 
081f					DMARK "SCR" 
081f f5				push af  
0820 3a 34 08			ld a, (.dmark)  
0823 32 6e fe			ld (debug_mark),a  
0826 3a 35 08			ld a, (.dmark+1)  
0829 32 6f fe			ld (debug_mark+1),a  
082c 3a 36 08			ld a, (.dmark+2)  
082f 32 70 fe			ld (debug_mark+2),a  
0832 18 03			jr .pastdmark  
0834 ..			.dmark: db "SCR"  
0837 f1			.pastdmark: pop af  
0838			endm  
# End of macro DMARK
0838					CALLMONITOR 
0838 cd f3 18			call break_point_state  
083b				endm  
# End of macro CALLMONITOR
083b				endif 
083b			 
083b e5				push hl		; save file name pointer 
083c			 
083c cd cd 04			call storage_get_block_0 
083f			 
083f 3a 81 fa			ld a,(store_page)	; get current file id 
0842 3c				inc a 
0843 32 81 fa			ld (store_page),a 
0846				 
0846 32 75 fa			ld (store_tmpid),a			; save id 
0849			 
0849 21 00 00			ld hl, 0 
084c 11 81 fa			ld de, store_page 
084f				if DEBUG_STORESE 
084f					DMARK "SCw" 
084f f5				push af  
0850 3a 64 08			ld a, (.dmark)  
0853 32 6e fe			ld (debug_mark),a  
0856 3a 65 08			ld a, (.dmark+1)  
0859 32 6f fe			ld (debug_mark+1),a  
085c 3a 66 08			ld a, (.dmark+2)  
085f 32 70 fe			ld (debug_mark+2),a  
0862 18 03			jr .pastdmark  
0864 ..			.dmark: db "SCw"  
0867 f1			.pastdmark: pop af  
0868			endm  
# End of macro DMARK
0868					CALLMONITOR 
0868 cd f3 18			call break_point_state  
086b				endm  
# End of macro CALLMONITOR
086b				endif 
086b cd 81 04			call storage_write_block	 ; save update 
086e			 
086e				if DEBUG_STORESE 
086e 11 81 fa				ld de, store_page 
0871					DMARK "SCC" 
0871 f5				push af  
0872 3a 86 08			ld a, (.dmark)  
0875 32 6e fe			ld (debug_mark),a  
0878 3a 87 08			ld a, (.dmark+1)  
087b 32 6f fe			ld (debug_mark+1),a  
087e 3a 88 08			ld a, (.dmark+2)  
0881 32 70 fe			ld (debug_mark+2),a  
0884 18 03			jr .pastdmark  
0886 ..			.dmark: db "SCC"  
0889 f1			.pastdmark: pop af  
088a			endm  
# End of macro DMARK
088a					CALLMONITOR 
088a cd f3 18			call break_point_state  
088d				endm  
# End of macro CALLMONITOR
088d				endif 
088d				;  
088d				 
088d 21 40 00			ld hl, STORE_BLOCK_PHY 
0890 11 00 00			ld de, 0 
0893 cd 4f 07			call storage_findnextid 
0896			 
0896 22 6c fa			ld (store_tmppageid), hl    ; save page to use  
0899			 
0899				; TODO detect 0 = no spare blocks 
0899			 
0899				; hl now contains the free page to use for the file header page 
0899			 
0899				if DEBUG_STORESE 
0899				DMARK "SCF" 
0899 f5				push af  
089a 3a ae 08			ld a, (.dmark)  
089d 32 6e fe			ld (debug_mark),a  
08a0 3a af 08			ld a, (.dmark+1)  
08a3 32 6f fe			ld (debug_mark+1),a  
08a6 3a b0 08			ld a, (.dmark+2)  
08a9 32 70 fe			ld (debug_mark+2),a  
08ac 18 03			jr .pastdmark  
08ae ..			.dmark: db "SCF"  
08b1 f1			.pastdmark: pop af  
08b2			endm  
# End of macro DMARK
08b2					CALLMONITOR 
08b2 cd f3 18			call break_point_state  
08b5				endm  
# End of macro CALLMONITOR
08b5				endif 
08b5			 
08b5 22 6c fa			ld (store_tmppageid), hl 
08b8				 
08b8 3a 75 fa			ld a,(store_tmpid)    ; get file id 
08bb			;	ld a, (store_filecache)			; save to cache 
08bb			 
08bb 32 81 fa			ld (store_page),a    ; set page id 
08be 3e 00			ld a, 0			 ; extent 0 is file header 
08c0 32 82 fa			ld (store_page+1), a   ; set file extent 
08c3			 
08c3 32 83 fa			ld (store_page+2), a   ; extent count for the file 
08c6			 
08c6			;	inc hl 		; init block 0 of file 
08c6			;	inc hl   		; skip file and extent id 
08c6			 ;       ld a, 0 
08c6			;	ld (hl),a 
08c6			;	ld a, (store_filecache+1)  	; save to cache 
08c6			 
08c6			;	inc hl    ; file name 
08c6				 
08c6				 
08c6 11 84 fa			ld de, store_page+3    ; get buffer for term string to use as file name 
08c9				if DEBUG_STORESE 
08c9					DMARK "SCc" 
08c9 f5				push af  
08ca 3a de 08			ld a, (.dmark)  
08cd 32 6e fe			ld (debug_mark),a  
08d0 3a df 08			ld a, (.dmark+1)  
08d3 32 6f fe			ld (debug_mark+1),a  
08d6 3a e0 08			ld a, (.dmark+2)  
08d9 32 70 fe			ld (debug_mark+2),a  
08dc 18 03			jr .pastdmark  
08de ..			.dmark: db "SCc"  
08e1 f1			.pastdmark: pop af  
08e2			endm  
# End of macro DMARK
08e2					CALLMONITOR 
08e2 cd f3 18			call break_point_state  
08e5				endm  
# End of macro CALLMONITOR
08e5				endif 
08e5 e1				pop hl    ; get zero term string 
08e6 e5				push hl 
08e7 3e 00			ld a, 0 
08e9 cd b5 13			call strlent 
08ec 23				inc hl   ; cover zero term 
08ed 06 00			ld b,0 
08ef 4d				ld c,l 
08f0 e1				pop hl 
08f1				;ex de, hl 
08f1				if DEBUG_STORESE 
08f1					DMARK "SCa" 
08f1 f5				push af  
08f2 3a 06 09			ld a, (.dmark)  
08f5 32 6e fe			ld (debug_mark),a  
08f8 3a 07 09			ld a, (.dmark+1)  
08fb 32 6f fe			ld (debug_mark+1),a  
08fe 3a 08 09			ld a, (.dmark+2)  
0901 32 70 fe			ld (debug_mark+2),a  
0904 18 03			jr .pastdmark  
0906 ..			.dmark: db "SCa"  
0909 f1			.pastdmark: pop af  
090a			endm  
# End of macro DMARK
090a					;push af 
090a					;ld a, 'a' 
090a					;ld (debug_mark),a 
090a					;pop af 
090a					CALLMONITOR 
090a cd f3 18			call break_point_state  
090d				endm  
# End of macro CALLMONITOR
090d				endif 
090d ed b0			ldir    ; copy zero term string 
090f				if DEBUG_STORESE 
090f					DMARK "SCA" 
090f f5				push af  
0910 3a 24 09			ld a, (.dmark)  
0913 32 6e fe			ld (debug_mark),a  
0916 3a 25 09			ld a, (.dmark+1)  
0919 32 6f fe			ld (debug_mark+1),a  
091c 3a 26 09			ld a, (.dmark+2)  
091f 32 70 fe			ld (debug_mark+2),a  
0922 18 03			jr .pastdmark  
0924 ..			.dmark: db "SCA"  
0927 f1			.pastdmark: pop af  
0928			endm  
# End of macro DMARK
0928					CALLMONITOR 
0928 cd f3 18			call break_point_state  
092b				endm  
# End of macro CALLMONITOR
092b				endif 
092b			 
092b				; write file header page 
092b			 
092b 2a 6c fa			ld hl,(store_tmppageid) 
092e 11 81 fa			ld de, store_page 
0931				if DEBUG_STORESE 
0931					DMARK "SCb" 
0931 f5				push af  
0932 3a 46 09			ld a, (.dmark)  
0935 32 6e fe			ld (debug_mark),a  
0938 3a 47 09			ld a, (.dmark+1)  
093b 32 6f fe			ld (debug_mark+1),a  
093e 3a 48 09			ld a, (.dmark+2)  
0941 32 70 fe			ld (debug_mark+2),a  
0944 18 03			jr .pastdmark  
0946 ..			.dmark: db "SCb"  
0949 f1			.pastdmark: pop af  
094a			endm  
# End of macro DMARK
094a					;push af 
094a					;ld a, 'b' 
094a					;ld (debug_mark),a 
094a					;pop af 
094a					CALLMONITOR 
094a cd f3 18			call break_point_state  
094d				endm  
# End of macro CALLMONITOR
094d				endif 
094d cd 81 04			call storage_write_block 
0950			 
0950 3a 75 fa			ld a, (store_tmpid) 
0953 6f				ld l, a 
0954 26 00			ld h,0 
0956				if DEBUG_STORESE 
0956					DMARK "SCz" 
0956 f5				push af  
0957 3a 6b 09			ld a, (.dmark)  
095a 32 6e fe			ld (debug_mark),a  
095d 3a 6c 09			ld a, (.dmark+1)  
0960 32 6f fe			ld (debug_mark+1),a  
0963 3a 6d 09			ld a, (.dmark+2)  
0966 32 70 fe			ld (debug_mark+2),a  
0969 18 03			jr .pastdmark  
096b ..			.dmark: db "SCz"  
096e f1			.pastdmark: pop af  
096f			endm  
# End of macro DMARK
096f					CALLMONITOR 
096f cd f3 18			call break_point_state  
0972				endm  
# End of macro CALLMONITOR
0972				endif 
0972 c9				ret 
0973				 
0973			 
0973			 
0973			; 
0973			; Read File 
0973			; 
0973			; h - file id to locate 
0973			; l - extent to locate 
0973			; de - pointer to string to read into 
0973			; 
0973			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0973			 
0973			.sr_fail: 
0973 d1				pop de 
0974 c9				ret 
0975			 
0975			storage_read: 
0975			 
0975			 
0975 d5				push de 
0976			 
0976			; TODO BUG the above push is it popped before the RET Z? 
0976			 
0976			; TODO how to handle multiple part blocks 
0976			 
0976				; locate file extent to read 
0976			 
0976 5c				ld e, h 
0977 55				ld d, l 
0978			 
0978			.srext: 
0978 22 7f fa			ld (store_readptr), hl     ; save the current extent to load 
097b ed 53 7d fa		ld (store_readbuf), de     ; save the current buffer to load in to 
097f			 
097f 21 40 00			ld hl, STORE_BLOCK_PHY 
0982				if DEBUG_STORESE 
0982					DMARK "sre" 
0982 f5				push af  
0983 3a 97 09			ld a, (.dmark)  
0986 32 6e fe			ld (debug_mark),a  
0989 3a 98 09			ld a, (.dmark+1)  
098c 32 6f fe			ld (debug_mark+1),a  
098f 3a 99 09			ld a, (.dmark+2)  
0992 32 70 fe			ld (debug_mark+2),a  
0995 18 03			jr .pastdmark  
0997 ..			.dmark: db "sre"  
099a f1			.pastdmark: pop af  
099b			endm  
# End of macro DMARK
099b					CALLMONITOR 
099b cd f3 18			call break_point_state  
099e				endm  
# End of macro CALLMONITOR
099e				endif 
099e cd 4f 07			call storage_findnextid 
09a1			 
09a1				if DEBUG_STORESE 
09a1					DMARK "srf" 
09a1 f5				push af  
09a2 3a b6 09			ld a, (.dmark)  
09a5 32 6e fe			ld (debug_mark),a  
09a8 3a b7 09			ld a, (.dmark+1)  
09ab 32 6f fe			ld (debug_mark+1),a  
09ae 3a b8 09			ld a, (.dmark+2)  
09b1 32 70 fe			ld (debug_mark+2),a  
09b4 18 03			jr .pastdmark  
09b6 ..			.dmark: db "srf"  
09b9 f1			.pastdmark: pop af  
09ba			endm  
# End of macro DMARK
09ba					CALLMONITOR 
09ba cd f3 18			call break_point_state  
09bd				endm  
# End of macro CALLMONITOR
09bd				endif 
09bd cd 75 0f			call ishlzero 
09c0			;	ld a, l 
09c0			;	add h 
09c0			;	cp 0 
09c0 28 b1			jr z,.sr_fail			; block not found so EOF 
09c2			 
09c2				; save current address for use by higher level words etc 
09c2			 
09c2 22 72 fa			ld (store_openaddr),hl 
09c5			 
09c5			 
09c5				; hl contains page number to load 
09c5 d1				pop de   ; get storage 
09c6 ed 53 7d fa		ld (store_readbuf), de     ; current buffer to load in to 
09ca d5				push de 
09cb				if DEBUG_STORESE 
09cb					DMARK "srg" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 6e fe			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 6f fe			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 70 fe			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "srg"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd f3 18			call break_point_state  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7 cd 1c 04			call storage_read_block 
09ea			 
09ea				; if this a continuation read??? 
09ea			 
09ea 2a 7d fa			ld hl, (store_readbuf)     ; current buffer to load in to 
09ed			 
09ed 3e 3f			ld a, STORE_BLOCK_PHY-1 
09ef cd 4c 0f			call addatohl 
09f2 7e				ld a,(hl) 
09f3 fe 00			cp 0 
09f5 28 02			jr z, .markiscont 
09f7 3e ff			ld a, 255 
09f9			 
09f9			.markiscont: 
09f9 32 74 fa			ld (store_readcont), a 
09fc			 
09fc				if DEBUG_STORESE 
09fc					DMARK "srC" 
09fc f5				push af  
09fd 3a 11 0a			ld a, (.dmark)  
0a00 32 6e fe			ld (debug_mark),a  
0a03 3a 12 0a			ld a, (.dmark+1)  
0a06 32 6f fe			ld (debug_mark+1),a  
0a09 3a 13 0a			ld a, (.dmark+2)  
0a0c 32 70 fe			ld (debug_mark+2),a  
0a0f 18 03			jr .pastdmark  
0a11 ..			.dmark: db "srC"  
0a14 f1			.pastdmark: pop af  
0a15			endm  
# End of macro DMARK
0a15					CALLMONITOR 
0a15 cd f3 18			call break_point_state  
0a18				endm  
# End of macro CALLMONITOR
0a18				endif 
0a18				; only short reads enabled 
0a18			 
0a18 3a 7c fa			ld a, (store_longread) 
0a1b fe 00			cp 0 
0a1d ca ea 0a			jp z, .readdone 
0a20			 
0a20			; TODO if block has no zeros then need to read next block  
0a20			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a20			; check last byte of physical block. 
0a20			; if not zero then the next block needs to be loaded 
0a20			 
0a20			 
0a20 2a 7d fa			ld hl, (store_readbuf)     ; current buffer to load in to 
0a23			 
0a23 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a25 cd 4c 0f			call addatohl 
0a28				;dec hl 
0a28 7e				ld a,(hl) 
0a29				if DEBUG_STORESE 
0a29					DMARK "sr?" 
0a29 f5				push af  
0a2a 3a 3e 0a			ld a, (.dmark)  
0a2d 32 6e fe			ld (debug_mark),a  
0a30 3a 3f 0a			ld a, (.dmark+1)  
0a33 32 6f fe			ld (debug_mark+1),a  
0a36 3a 40 0a			ld a, (.dmark+2)  
0a39 32 70 fe			ld (debug_mark+2),a  
0a3c 18 03			jr .pastdmark  
0a3e ..			.dmark: db "sr?"  
0a41 f1			.pastdmark: pop af  
0a42			endm  
# End of macro DMARK
0a42					CALLMONITOR 
0a42 cd f3 18			call break_point_state  
0a45				endm  
# End of macro CALLMONITOR
0a45				endif 
0a45 fe 00			cp 0 
0a47 ca ea 0a			jp z, .readdone 
0a4a			 
0a4a				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a4a			 
0a4a 23				inc hl 
0a4b			 
0a4b 22 7d fa			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a4e			 
0a4e ed 5b 7f fa		ld de, (store_readptr)     ; save the current extent to load 
0a52			 
0a52 eb				ex de, hl 
0a53			 
0a53				; next ext 
0a53			 
0a53 23				inc hl 
0a54 22 7f fa			ld  (store_readptr), hl     ; save the current extent to load 
0a57			 
0a57				if DEBUG_STORESE 
0a57					DMARK "sF2" 
0a57 f5				push af  
0a58 3a 6c 0a			ld a, (.dmark)  
0a5b 32 6e fe			ld (debug_mark),a  
0a5e 3a 6d 0a			ld a, (.dmark+1)  
0a61 32 6f fe			ld (debug_mark+1),a  
0a64 3a 6e 0a			ld a, (.dmark+2)  
0a67 32 70 fe			ld (debug_mark+2),a  
0a6a 18 03			jr .pastdmark  
0a6c ..			.dmark: db "sF2"  
0a6f f1			.pastdmark: pop af  
0a70			endm  
# End of macro DMARK
0a70					CALLMONITOR 
0a70 cd f3 18			call break_point_state  
0a73				endm  
# End of macro CALLMONITOR
0a73				endif 
0a73			 
0a73				; get and load block 
0a73			 
0a73 cd 4f 07			call storage_findnextid 
0a76			 
0a76				if DEBUG_STORESE 
0a76					DMARK "sf2" 
0a76 f5				push af  
0a77 3a 8b 0a			ld a, (.dmark)  
0a7a 32 6e fe			ld (debug_mark),a  
0a7d 3a 8c 0a			ld a, (.dmark+1)  
0a80 32 6f fe			ld (debug_mark+1),a  
0a83 3a 8d 0a			ld a, (.dmark+2)  
0a86 32 70 fe			ld (debug_mark+2),a  
0a89 18 03			jr .pastdmark  
0a8b ..			.dmark: db "sf2"  
0a8e f1			.pastdmark: pop af  
0a8f			endm  
# End of macro DMARK
0a8f					CALLMONITOR 
0a8f cd f3 18			call break_point_state  
0a92				endm  
# End of macro CALLMONITOR
0a92				endif 
0a92 cd 75 0f			call ishlzero 
0a95			;	ld a, l 
0a95			;	add h 
0a95			;	cp 0 
0a95 ca 73 09			jp z,.sr_fail			; block not found so EOF 
0a98				 
0a98				; save current address for use by higher level words etc 
0a98			 
0a98 22 72 fa			ld (store_openaddr),hl 
0a9b			 
0a9b cd 1c 04			call storage_read_block 
0a9e			 
0a9e				; on a continuation block, we now have the file id and ext in the middle of the block 
0a9e				; we need to pull everything back  
0a9e			 
0a9e ed 5b 7d fa		ld de, (store_readbuf)     ; current buffer to nudge into 
0aa2 2a 7d fa			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aa5 23				inc hl 
0aa6 23				inc hl     ; skip id and ext 
0aa7 01 40 00			ld bc, STORE_BLOCK_PHY 
0aaa				if DEBUG_STORESE 
0aaa					DMARK "SR<" 
0aaa f5				push af  
0aab 3a bf 0a			ld a, (.dmark)  
0aae 32 6e fe			ld (debug_mark),a  
0ab1 3a c0 0a			ld a, (.dmark+1)  
0ab4 32 6f fe			ld (debug_mark+1),a  
0ab7 3a c1 0a			ld a, (.dmark+2)  
0aba 32 70 fe			ld (debug_mark+2),a  
0abd 18 03			jr .pastdmark  
0abf ..			.dmark: db "SR<"  
0ac2 f1			.pastdmark: pop af  
0ac3			endm  
# End of macro DMARK
0ac3					CALLMONITOR 
0ac3 cd f3 18			call break_point_state  
0ac6				endm  
# End of macro CALLMONITOR
0ac6				endif 
0ac6 ed b0			ldir     ; copy data 
0ac8			 
0ac8				; move the pointer back and pretend we have a full buffer for next recheck 
0ac8			 
0ac8 1b				dec de 
0ac9 1b				dec de 
0aca			 
0aca			; TODO do pop below now short circuit loop????? 
0aca c1				pop bc     ; get rid of spare de on stack 
0acb				if DEBUG_STORESE 
0acb					DMARK "SR>" 
0acb f5				push af  
0acc 3a e0 0a			ld a, (.dmark)  
0acf 32 6e fe			ld (debug_mark),a  
0ad2 3a e1 0a			ld a, (.dmark+1)  
0ad5 32 6f fe			ld (debug_mark+1),a  
0ad8 3a e2 0a			ld a, (.dmark+2)  
0adb 32 70 fe			ld (debug_mark+2),a  
0ade 18 03			jr .pastdmark  
0ae0 ..			.dmark: db "SR>"  
0ae3 f1			.pastdmark: pop af  
0ae4			endm  
# End of macro DMARK
0ae4					CALLMONITOR 
0ae4 cd f3 18			call break_point_state  
0ae7				endm  
# End of macro CALLMONITOR
0ae7				endif 
0ae7 c3 78 09			jp .srext 
0aea			 
0aea			 
0aea			 
0aea			 
0aea			 
0aea			.readdone:		 
0aea e1				pop hl 		 ; return start of data to show as not EOF 
0aeb 23				inc hl   ; past file id 
0aec 23				inc hl   ; past ext 
0aed				if DEBUG_STORESE 
0aed					DMARK "SRe" 
0aed f5				push af  
0aee 3a 02 0b			ld a, (.dmark)  
0af1 32 6e fe			ld (debug_mark),a  
0af4 3a 03 0b			ld a, (.dmark+1)  
0af7 32 6f fe			ld (debug_mark+1),a  
0afa 3a 04 0b			ld a, (.dmark+2)  
0afd 32 70 fe			ld (debug_mark+2),a  
0b00 18 03			jr .pastdmark  
0b02 ..			.dmark: db "SRe"  
0b05 f1			.pastdmark: pop af  
0b06			endm  
# End of macro DMARK
0b06					CALLMONITOR 
0b06 cd f3 18			call break_point_state  
0b09				endm  
# End of macro CALLMONITOR
0b09				endif 
0b09 c9					ret 
0b0a			 
0b0a			 
0b0a			 
0b0a			; 
0b0a			; Append File 
0b0a			; 
0b0a			; hl - file id to locate 
0b0a			; de - pointer to (multi block) string to write 
0b0a			 
0b0a			.sa_notfound: 
0b0a d1				pop de 
0b0b c9				ret 
0b0c			 
0b0c			 
0b0c			storage_append: 
0b0c				; hl -  file id to append to 
0b0c				; de - string to append 
0b0c			 
0b0c d5				push de 
0b0d				 
0b0d				if DEBUG_STORESE 
0b0d					DMARK "AP1" 
0b0d f5				push af  
0b0e 3a 22 0b			ld a, (.dmark)  
0b11 32 6e fe			ld (debug_mark),a  
0b14 3a 23 0b			ld a, (.dmark+1)  
0b17 32 6f fe			ld (debug_mark+1),a  
0b1a 3a 24 0b			ld a, (.dmark+2)  
0b1d 32 70 fe			ld (debug_mark+2),a  
0b20 18 03			jr .pastdmark  
0b22 ..			.dmark: db "AP1"  
0b25 f1			.pastdmark: pop af  
0b26			endm  
# End of macro DMARK
0b26					CALLMONITOR 
0b26 cd f3 18			call break_point_state  
0b29				endm  
# End of macro CALLMONITOR
0b29				endif 
0b29			 
0b29 7d				ld a, l 
0b2a 32 75 fa			ld (store_tmpid), a 
0b2d			 
0b2d				; get file header  
0b2d			 
0b2d 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b2f 3a 75 fa			ld a, (store_tmpid) 
0b32 5f				ld e, a 
0b33			 
0b33 21 40 00				ld hl, STORE_BLOCK_PHY 
0b36 cd 4f 07				call storage_findnextid 
0b39			 
0b39 cd 75 0f			call ishlzero 
0b3c 28 cc			jr z, .sa_notfound 
0b3e			 
0b3e 22 6c fa			ld (store_tmppageid), hl 
0b41			 
0b41				; TODO handle file id not found 
0b41			 
0b41				if DEBUG_STORESE 
0b41					DMARK "AP2" 
0b41 f5				push af  
0b42 3a 56 0b			ld a, (.dmark)  
0b45 32 6e fe			ld (debug_mark),a  
0b48 3a 57 0b			ld a, (.dmark+1)  
0b4b 32 6f fe			ld (debug_mark+1),a  
0b4e 3a 58 0b			ld a, (.dmark+2)  
0b51 32 70 fe			ld (debug_mark+2),a  
0b54 18 03			jr .pastdmark  
0b56 ..			.dmark: db "AP2"  
0b59 f1			.pastdmark: pop af  
0b5a			endm  
# End of macro DMARK
0b5a					CALLMONITOR 
0b5a cd f3 18			call break_point_state  
0b5d				endm  
# End of macro CALLMONITOR
0b5d				endif 
0b5d			 
0b5d				; update file extent count 
0b5d			 
0b5d 11 81 fa			ld de, store_page 
0b60			 
0b60 cd 1c 04			call storage_read_block 
0b63			 
0b63				if DEBUG_STORESE 
0b63					DMARK "AP3" 
0b63 f5				push af  
0b64 3a 78 0b			ld a, (.dmark)  
0b67 32 6e fe			ld (debug_mark),a  
0b6a 3a 79 0b			ld a, (.dmark+1)  
0b6d 32 6f fe			ld (debug_mark+1),a  
0b70 3a 7a 0b			ld a, (.dmark+2)  
0b73 32 70 fe			ld (debug_mark+2),a  
0b76 18 03			jr .pastdmark  
0b78 ..			.dmark: db "AP3"  
0b7b f1			.pastdmark: pop af  
0b7c			endm  
# End of macro DMARK
0b7c					CALLMONITOR 
0b7c cd f3 18			call break_point_state  
0b7f				endm  
# End of macro CALLMONITOR
0b7f				endif 
0b7f			;	ld (store_tmppageid), hl 
0b7f			 
0b7f 3a 83 fa			ld a, (store_page+2) 
0b82 3c				inc a 
0b83 32 83 fa			ld (store_page+2), a 
0b86 32 74 fa			ld (store_tmpext), a 
0b89				 
0b89				if DEBUG_STORESE 
0b89					DMARK "AP3" 
0b89 f5				push af  
0b8a 3a 9e 0b			ld a, (.dmark)  
0b8d 32 6e fe			ld (debug_mark),a  
0b90 3a 9f 0b			ld a, (.dmark+1)  
0b93 32 6f fe			ld (debug_mark+1),a  
0b96 3a a0 0b			ld a, (.dmark+2)  
0b99 32 70 fe			ld (debug_mark+2),a  
0b9c 18 03			jr .pastdmark  
0b9e ..			.dmark: db "AP3"  
0ba1 f1			.pastdmark: pop af  
0ba2			endm  
# End of macro DMARK
0ba2					CALLMONITOR 
0ba2 cd f3 18			call break_point_state  
0ba5				endm  
# End of macro CALLMONITOR
0ba5				endif 
0ba5 2a 6c fa			ld hl, (store_tmppageid) 
0ba8 11 81 fa			ld de, store_page 
0bab cd 81 04			call storage_write_block 
0bae			 
0bae				; find free block 
0bae			 
0bae 11 00 00			ld de, 0			 ; file extent to locate 
0bb1			 
0bb1 21 40 00				ld hl, STORE_BLOCK_PHY 
0bb4 cd 4f 07				call storage_findnextid 
0bb7 cd 75 0f			call ishlzero 
0bba ca 0a 0b			jp z, .sa_notfound 
0bbd			 
0bbd					; TODO handle no space left 
0bbd					 
0bbd 22 6c fa				ld (store_tmppageid), hl 
0bc0			 
0bc0				if DEBUG_STORESE 
0bc0					DMARK "AP4" 
0bc0 f5				push af  
0bc1 3a d5 0b			ld a, (.dmark)  
0bc4 32 6e fe			ld (debug_mark),a  
0bc7 3a d6 0b			ld a, (.dmark+1)  
0bca 32 6f fe			ld (debug_mark+1),a  
0bcd 3a d7 0b			ld a, (.dmark+2)  
0bd0 32 70 fe			ld (debug_mark+2),a  
0bd3 18 03			jr .pastdmark  
0bd5 ..			.dmark: db "AP4"  
0bd8 f1			.pastdmark: pop af  
0bd9			endm  
# End of macro DMARK
0bd9					CALLMONITOR 
0bd9 cd f3 18			call break_point_state  
0bdc				endm  
# End of macro CALLMONITOR
0bdc				endif 
0bdc					; init the buffer with zeros so we can id if the buffer is full or not 
0bdc			 
0bdc e5					push hl 
0bdd c5					push bc 
0bde			 
0bde 21 81 fa				ld hl, store_page 
0be1 06 40				ld b, STORE_BLOCK_PHY 
0be3 3e 00				ld a, 0 
0be5 77			.zeroblock:	ld (hl), a 
0be6 23					inc hl 
0be7 10 fc				djnz .zeroblock 
0be9			 
0be9 c1					pop bc 
0bea e1					pop hl 
0beb			 
0beb					; construct block 
0beb			 
0beb 3a 75 fa				ld a, (store_tmpid) 
0bee 32 81 fa				ld (store_page), a   ; file id 
0bf1 3a 74 fa				ld a, (store_tmpext)   ; extent for this block 
0bf4 32 82 fa				ld (store_page+1), a 
0bf7			 
0bf7 e1					pop hl    ; get string to write 
0bf8 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0bfa 11 83 fa				ld de, store_page+2 
0bfd			 
0bfd				if DEBUG_STORESE 
0bfd					DMARK "AP5" 
0bfd f5				push af  
0bfe 3a 12 0c			ld a, (.dmark)  
0c01 32 6e fe			ld (debug_mark),a  
0c04 3a 13 0c			ld a, (.dmark+1)  
0c07 32 6f fe			ld (debug_mark+1),a  
0c0a 3a 14 0c			ld a, (.dmark+2)  
0c0d 32 70 fe			ld (debug_mark+2),a  
0c10 18 03			jr .pastdmark  
0c12 ..			.dmark: db "AP5"  
0c15 f1			.pastdmark: pop af  
0c16			endm  
# End of macro DMARK
0c16					CALLMONITOR 
0c16 cd f3 18			call break_point_state  
0c19				endm  
# End of macro CALLMONITOR
0c19				endif 
0c19			 
0c19			 
0c19			 
0c19					; fill buffer with data until end of string or full block 
0c19			 
0c19 7e			.appd:		ld a, (hl) 
0c1a 12					ld (de), a 
0c1b fe 00				cp 0 
0c1d 28 04				jr z, .appdone 
0c1f 23					inc hl 
0c20 13					inc de 
0c21 10 f6				djnz .appd 
0c23			 
0c23 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c24 f5					push af   		; save last byte dumped 
0c25			 
0c25			 
0c25 2a 6c fa			ld hl, (store_tmppageid) 
0c28 11 81 fa			ld de, store_page 
0c2b				if DEBUG_STORESE 
0c2b					DMARK "AP6" 
0c2b f5				push af  
0c2c 3a 40 0c			ld a, (.dmark)  
0c2f 32 6e fe			ld (debug_mark),a  
0c32 3a 41 0c			ld a, (.dmark+1)  
0c35 32 6f fe			ld (debug_mark+1),a  
0c38 3a 42 0c			ld a, (.dmark+2)  
0c3b 32 70 fe			ld (debug_mark+2),a  
0c3e 18 03			jr .pastdmark  
0c40 ..			.dmark: db "AP6"  
0c43 f1			.pastdmark: pop af  
0c44			endm  
# End of macro DMARK
0c44					CALLMONITOR 
0c44 cd f3 18			call break_point_state  
0c47				endm  
# End of macro CALLMONITOR
0c47				endif 
0c47 cd 81 04				call storage_write_block 
0c4a			 
0c4a			 
0c4a				; was that a full block of data written? 
0c4a				; any more to write out? 
0c4a			 
0c4a				; if yes then set vars and jump to start of function again 
0c4a			 
0c4a f1					pop af 
0c4b d1					pop de 
0c4c			 
0c4c fe 00				cp 0		 ; no, string was fully written 
0c4e c8					ret z 
0c4f			 
0c4f					; setup vars for next cycle 
0c4f			 
0c4f 3a 75 fa				ld a, (store_tmpid) 
0c52 6f					ld l, a 
0c53 26 00				ld h, 0 
0c55			 
0c55 c3 0c 0b			 	jp storage_append	 ; yes, need to write out some more 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			 
0c58			if DEBUG_STORECF 
0c58			storageput:	 
0c58					ret 
0c58			storageread: 
0c58					ld hl, store_page 
0c58					ld b, 200 
0c58					ld a,0 
0c58			.src:		ld (hl),a 
0c58					inc hl 
0c58					djnz .src 
0c58					 
0c58			 
0c58					ld de, 0 
0c58					ld bc, 1 
0c58					ld hl, store_page 
0c58					call cfRead 
0c58			 
0c58				call cfGetError 
0c58				ld hl,scratch 
0c58				call hexout 
0c58				ld hl, scratch+2 
0c58				ld a, 0 
0c58				ld (hl),a 
0c58				ld de, scratch 
0c58				ld a,display_row_1 
0c58				call str_at_display 
0c58				call update_display 
0c58			 
0c58					ld hl, store_page 
0c58					ld (os_cur_ptr),hl 
0c58			 
0c58					ret 
0c58			endif 
0c58			 
0c58			 
0c58			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c58			 
0c58			storage_clear_page: 
0c58 e5				push hl 
0c59 d5				push de 
0c5a c5				push bc 
0c5b 21 81 fa			ld hl, store_page 
0c5e 3e 00			ld a, 0 
0c60 77				ld (hl), a 
0c61			 
0c61 11 82 fa			ld de, store_page+1 
0c64 01 18 01			ld bc, STORE_BLOCK_LOG 
0c67			 
0c67 ed b0			ldir 
0c69				 
0c69 c1				pop bc 
0c6a d1				pop de 
0c6b e1				pop hl 
0c6c c9				ret 
0c6d			 
0c6d			; eof 
# End of file firmware_storage.asm
0c6d			  
0c6d			; support routines for above hardware abstraction layer  
0c6d			  
0c6d			include "firmware_general.asm"        ; general support functions  
0c6d			 
0c6d			; word look up 
0c6d			 
0c6d			; in 
0c6d			; a is the index 
0c6d			; hl is pointer start of array 
0c6d			; 
0c6d			; returns 
0c6d			; hl to the word 
0c6d			; 
0c6d			 
0c6d			table_lookup:  
0c6d d5					push de 
0c6e eb					ex de, hl 
0c6f			 
0c6f 6f					ld l, a 
0c70 26 00				ld h, 0 
0c72 29					add hl, hl 
0c73 19					add hl, de 
0c74 7e					ld a, (hl) 
0c75 23					inc hl 
0c76 66					ld h,(hl) 
0c77 6f					ld l, a 
0c78			 
0c78 d1					pop de 
0c79 c9					ret 
0c7a			 
0c7a			; Delay loops 
0c7a			 
0c7a			 
0c7a			 
0c7a			aDelayInMS: 
0c7a c5				push bc 
0c7b 47				ld b,a 
0c7c			msdelay: 
0c7c c5				push bc 
0c7d				 
0c7d			 
0c7d 01 41 00			ld bc,041h 
0c80 cd 98 0c			call delayloop 
0c83 c1				pop bc 
0c84 05				dec b 
0c85 20 f5			jr nz,msdelay 
0c87			 
0c87			;if CPU_CLOCK_8MHZ 
0c87			;msdelay8: 
0c87			;	push bc 
0c87			;	 
0c87			; 
0c87			;	ld bc,041h 
0c87			;	call delayloop 
0c87			;	pop bc 
0c87			;	dec b 
0c87			;	jr nz,msdelay8 
0c87			;endif 
0c87			 
0c87			 
0c87 c1				pop bc 
0c88 c9				ret 
0c89			 
0c89			 
0c89			delay250ms: 
0c89				;push de 
0c89 01 00 40			ld bc, 04000h 
0c8c c3 98 0c			jp delayloop 
0c8f			delay500ms: 
0c8f				;push de 
0c8f 01 00 80			ld bc, 08000h 
0c92 c3 98 0c			jp delayloop 
0c95			delay1s: 
0c95				;push bc 
0c95			   ; Clobbers A, d and e 
0c95 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c98			delayloop: 
0c98 c5			    push bc 
0c99			 
0c99			if BASE_CPM 
0c99				ld bc, CPM_DELAY_TUNE 
0c99			.cpmloop: 
0c99				push bc 
0c99			 
0c99			endif 
0c99			 
0c99			 
0c99			 
0c99			delayloopi: 
0c99			;	push bc 
0c99			;.dl: 
0c99 cb 47		    bit     0,a    	; 8 
0c9b cb 47		    bit     0,a    	; 8 
0c9d cb 47		    bit     0,a    	; 8 
0c9f e6 ff		    and     255  	; 7 
0ca1 0b			    dec     bc      	; 6 
0ca2 79			    ld      a,c     	; 4 
0ca3 b0			    or      b     	; 4 
0ca4 c2 99 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0ca7			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0ca7				;pop de 
0ca7			;pop bc 
0ca7			 
0ca7			if BASE_CPM 
0ca7				pop bc 
0ca7				 
0ca7			    dec     bc      	; 6 
0ca7			    ld      a,c     	; 4 
0ca7			    or      b     	; 4 
0ca7			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0ca7				 
0ca7			 
0ca7			endif 
0ca7			;if CPU_CLOCK_8MHZ 
0ca7			;    pop bc 
0ca7			;    push bc 
0ca7			;.dl8: 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    and     255  	; 7 
0ca7			;    dec     bc      	; 6 
0ca7			;    ld      a,c     	; 4 
0ca7			;    or      b     	; 4 
0ca7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca7			;endif 
0ca7			 
0ca7			;if CPU_CLOCK_10MHZ 
0ca7			;    pop bc 
0ca7			;    push bc 
0ca7			;.dl8: 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    bit     0,a    	; 8 
0ca7			;    and     255  	; 7 
0ca7			;    dec     bc      	; 6 
0ca7			;    ld      a,c     	; 4 
0ca7			;    or      b     	; 4 
0ca7			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0ca7			;endif 
0ca7 c1			    pop bc 
0ca8			 
0ca8 c9				ret 
0ca9			 
0ca9			 
0ca9			 
0ca9			; eof 
# End of file firmware_general.asm
0ca9			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0ca9			; display routines that use the physical hardware abstraction layer 
0ca9			 
0ca9			 
0ca9			; information window 
0ca9			 
0ca9			; pass hl with 1st string to display 
0ca9			; pass de with 2nd string to display 
0ca9			 
0ca9			info_panel: 
0ca9 e5				push hl 
0caa			 
0caa 2a cf fb			ld hl, (display_fb_active) 
0cad e5				push hl    ; future de destination 
0cae 21 b4 fd				ld hl, display_fb0 
0cb1 22 cf fb				ld (display_fb_active), hl 
0cb4			 
0cb4			;	call clear_display 
0cb4			 
0cb4				if BASE_CPM 
0cb4				ld a, '.' 
0cb4				else 
0cb4 3e a5			ld a, 165 
0cb6				endif 
0cb6 cd 1d 0d			call fill_display 
0cb9			 
0cb9			 
0cb9 3e 55			ld a, display_row_3 + 5 
0cbb cd 2b 0d			call str_at_display 
0cbe			 
0cbe e1				pop hl 
0cbf d1				pop de 
0cc0			 
0cc0 e5				push hl 
0cc1			 
0cc1			 
0cc1 3e 2d			ld a, display_row_2 + 5 
0cc3 cd 2b 0d			call str_at_display 
0cc6			 
0cc6			 
0cc6 cd 3b 0d			call update_display 
0cc9 cd df 1e			call next_page_prompt 
0ccc cd 18 0d			call clear_display 
0ccf			 
0ccf				 
0ccf 21 13 fd				ld hl, display_fb1 
0cd2 22 cf fb				ld (display_fb_active), hl 
0cd5 cd 3b 0d			call update_display 
0cd8			 
0cd8 e1				pop hl 
0cd9			 
0cd9 c9				ret 
0cda			 
0cda			 
0cda			 
0cda			 
0cda			; TODO windowing? 
0cda			 
0cda			; TODO scroll line up 
0cda			 
0cda			scroll_up: 
0cda			 
0cda e5				push hl 
0cdb d5				push de 
0cdc c5				push bc 
0cdd			 
0cdd				; get frame buffer  
0cdd			 
0cdd 2a cf fb			ld hl, (display_fb_active) 
0ce0 e5				push hl    ; future de destination 
0ce1			 
0ce1 11 28 00			ld  de, display_cols 
0ce4 19				add hl, de 
0ce5			 
0ce5 d1				pop de 
0ce6			 
0ce6				;ex de, hl 
0ce6 01 9f 00			ld bc, display_fb_len -1  
0ce9			;if DEBUG_FORTH_WORDS 
0ce9			;	DMARK "SCL" 
0ce9			;	CALLMONITOR 
0ce9			;endif	 
0ce9 ed b0			ldir 
0ceb			 
0ceb				; wipe bottom row 
0ceb			 
0ceb			 
0ceb 2a cf fb			ld hl, (display_fb_active) 
0cee 11 a0 00			ld de, display_cols*display_rows 
0cf1 19				add hl, de 
0cf2 06 28			ld b, display_cols 
0cf4 3e 20			ld a, ' ' 
0cf6			.scwipe: 
0cf6 77				ld (hl), a 
0cf7 2b				dec hl 
0cf8 10 fc			djnz .scwipe 
0cfa			 
0cfa				;pop hl 
0cfa			 
0cfa c1				pop bc 
0cfb d1				pop de 
0cfc e1				pop hl 
0cfd			 
0cfd c9				ret 
0cfe			 
0cfe			 
0cfe			;scroll_upo: 
0cfe			;	ld de, display_row_1 
0cfe			 ;	ld hl, display_row_2 
0cfe			;	ld bc, display_cols 
0cfe			;	ldir 
0cfe			;	ld de, display_row_2 
0cfe			 ;	ld hl, display_row_3 
0cfe			;	ld bc, display_cols 
0cfe			;	ldir 
0cfe			;	ld de, display_row_3 
0cfe			 ;	ld hl, display_row_4 
0cfe			;	ld bc, display_cols 
0cfe			;	ldir 
0cfe			 
0cfe			; TODO clear row 4 
0cfe			 
0cfe			;	ret 
0cfe			 
0cfe				 
0cfe			scroll_down: 
0cfe			 
0cfe e5				push hl 
0cff d5				push de 
0d00 c5				push bc 
0d01			 
0d01				; get frame buffer  
0d01			 
0d01 2a cf fb			ld hl, (display_fb_active) 
0d04			 
0d04 11 9f 00			ld de, display_fb_len - 1 
0d07 19				add hl, de 
0d08			 
0d08 e5			push hl    ; future de destination 
0d09			 
0d09 11 28 00			ld  de, display_cols 
0d0c ed 52			sbc hl, de 
0d0e			 
0d0e			 
0d0e d1				pop de 
0d0f			 
0d0f			;	ex de, hl 
0d0f 01 9f 00			ld bc, display_fb_len -1  
0d12			 
0d12			 
0d12				 
0d12			 
0d12 ed b0			ldir 
0d14			 
0d14				; wipe bottom row 
0d14			 
0d14			 
0d14			;	ld hl, (display_fb_active) 
0d14			;;	ld de, display_cols*display_rows 
0d14			;;	add hl, de 
0d14			;	ld b, display_cols 
0d14			;	ld a, ' ' 
0d14			;.scwiped: 
0d14			;	ld (hl), a 
0d14			;	dec hl 
0d14			;	djnz .scwiped 
0d14			 
0d14				;pop hl 
0d14			 
0d14 c1				pop bc 
0d15 d1				pop de 
0d16 e1				pop hl 
0d17			 
0d17 c9				ret 
0d18			;scroll_down: 
0d18			;	ld de, display_row_4 
0d18			;	ld hl, display_row_3 
0d18			;	ld bc, display_cols 
0d18			;	ldir 
0d18			;	ld de, display_row_3 
0d18			; 	ld hl, display_row_2 
0d18			;	ld bc, display_cols 
0d18			;	ldir 
0d18			;	ld de, display_row_2 
0d18			;	ld hl, display_row_1 
0d18			;	ld bc, display_cols 
0d18			;	ldir 
0d18			;;; TODO clear row 1 
0d18			;	ret 
0d18			 
0d18			 
0d18			 
0d18			 
0d18			 
0d18			; clear active frame buffer 
0d18			 
0d18			clear_display: 
0d18 3e 20			ld a, ' ' 
0d1a c3 1d 0d			jp fill_display 
0d1d			 
0d1d			; fill active frame buffer with a char in A 
0d1d			 
0d1d			fill_display: 
0d1d 06 a0			ld b,display_fb_len 
0d1f 2a cf fb			ld hl, (display_fb_active) 
0d22 77			.fd1:	ld (hl),a 
0d23 23				inc hl 
0d24 10 fc			djnz .fd1 
0d26 23				inc hl 
0d27 3e 00			ld a,0 
0d29 77				ld (hl),a 
0d2a			 
0d2a			 
0d2a c9				ret 
0d2b			; Write string (DE) at pos (A) to active frame buffer 
0d2b			 
0d2b 2a cf fb		str_at_display:    ld hl,(display_fb_active) 
0d2e 06 00					ld b,0 
0d30 4f					ld c,a 
0d31 09					add hl,bc 
0d32 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0d33 b7			            OR   A              ;Null terminator? 
0d34 c8			            RET  Z              ;Yes, so finished 
0d35 77					ld (hl),a 
0d36 23				inc hl 
0d37 13			            INC  DE             ;Point to next character 
0d38 18 f8		            JR   .sad1     ;Repeat 
0d3a c9					ret 
0d3b			 
0d3b			; using current frame buffer write to physical display 
0d3b			 
0d3b			update_display: 
0d3b e5				push hl 
0d3c 2a cf fb			ld hl, (display_fb_active) 
0d3f cd cd 73			call write_display 
0d42 e1				pop hl 
0d43 c9				ret 
0d44			 
0d44			; TODO scrolling 
0d44			 
0d44			 
0d44			; move cursor right one char 
0d44			cursor_right: 
0d44			 
0d44				; TODO shift right 
0d44				; TODO if beyond max col 
0d44				; TODO       cursor_next_line 
0d44			 
0d44 c9				ret 
0d45			 
0d45			 
0d45			cursor_next_line: 
0d45				; TODO first char 
0d45				; TODO line down 
0d45				; TODO if past last row 
0d45				; TODO    scroll up 
0d45			 
0d45 c9				ret 
0d46			 
0d46			cursor_left: 
0d46				; TODO shift left 
0d46				; TODO if beyond left  
0d46				; TODO     cursor prev line 
0d46				 
0d46 c9				ret 
0d47			 
0d47			cursor_prev_line: 
0d47				; TODO last char 
0d47				; TODO line up 
0d47				; TODO if past first row 
0d47				; TODO   scroll down 
0d47			 
0d47 c9				ret 
0d48			 
0d48			 
0d48			cout: 
0d48				; A - char 
0d48 c9				ret 
0d49			 
0d49			 
0d49			; Display a menu and allow item selection (optional toggle items) 
0d49			; 
0d49			; format: 
0d49			; hl pointer to word array with zero term for items 
0d49			; e.g.    db item1 
0d49			;         db .... 
0d49			;         db 0 
0d49			; 
0d49			; a = starting menu item  
0d49			; 
0d49			; de = pointer item toggle array   (todo) 
0d49			; 
0d49			; returns item selected in a 1-... 
0d49			; returns 0 if back button pressed 
0d49			; 
0d49			; NOTE: Uses system frame buffer to display 
0d49			; 
0d49			; LEFT, Q = go back 
0d49			; RIGHT, SPACE, CR = select 
0d49			; UP, A - Up 
0d49			; DOWN, Z - Down 
0d49			 
0d49			 
0d49			 
0d49			 
0d49			 
0d49			menu: 
0d49			 
0d49					; keep array pointer 
0d49			 
0d49 22 7a fa				ld (store_tmp1), hl 
0d4c 32 78 fa				ld (store_tmp2), a 
0d4f			 
0d4f					; check for key bounce 
0d4f			 
0d4f			if BASE_KEV 
0d4f			 
0d4f cd 18 77		.mbounce:	call cin 
0d52 fe 00				cp 0 
0d54 20 f9				jr nz, .mbounce 
0d56			endif 
0d56					; for ease use ex 
0d56			 
0d56					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0d56 21 b4 fd				ld hl, display_fb0 
0d59 22 cf fb				ld (display_fb_active), hl 
0d5c			 
0d5c cd 18 0d		.mloop:		call clear_display 
0d5f cd 3b 0d				call update_display 
0d62			 
0d62					; draw selection id '>' at 1 
0d62			 
0d62					; init start of list display 
0d62			 
0d62 3e 05				ld a, 5 
0d64 32 76 fa				ld (store_tmp3), a   ; display row count 
0d67 3a 78 fa				ld a,( store_tmp2) 
0d6a 32 79 fa				ld (store_tmp2+1), a   ; display item count 
0d6d			 
0d6d					 
0d6d			.mitem:	 
0d6d			 
0d6d			 
0d6d 3a 79 fa				ld a,(store_tmp2+1) 
0d70 6f					ld l, a 
0d71 26 00				ld h, 0 
0d73 29					add hl, hl 
0d74 ed 5b 7a fa			ld de, (store_tmp1) 
0d78 19					add hl, de 
0d79 7e					ld a, (hl) 
0d7a 23					inc hl 
0d7b 66					ld h,(hl) 
0d7c 6f					ld l, a 
0d7d			 
0d7d cd 75 0f				call ishlzero 
0d80 28 1a				jr z, .mdone 
0d82			 
0d82 eb					ex de, hl 
0d83 3a 76 fa				ld a, (store_tmp3) 
0d86 cd 2b 0d				call str_at_display 
0d89					 
0d89			 
0d89					; next item 
0d89 3a 79 fa				ld a, (store_tmp2+1) 
0d8c 3c					inc a 
0d8d 32 79 fa				ld (store_tmp2+1), a   ; display item count 
0d90			 
0d90			 		; next row 
0d90			 
0d90 3a 76 fa				ld a, (store_tmp3) 
0d93 c6 28				add display_cols 
0d95 32 76 fa				ld (store_tmp3), a 
0d98			 
0d98					; at end of screen? 
0d98			 
0d98 fe 10				cp display_rows*4 
0d9a 20 d1				jr nz, .mitem 
0d9c			 
0d9c			 
0d9c			.mdone: 
0d9c cd 75 0f				call ishlzero 
0d9f 28 08				jr z, .nodn 
0da1			 
0da1 3e 78				ld a, display_row_4 
0da3 11 22 0e				ld de, .mdown 
0da6 cd 2b 0d				call str_at_display 
0da9			 
0da9					; draw options to fill the screens with active item on line 1 
0da9					; if current option is 2 or more then display ^ in top 
0da9			 
0da9 3a 78 fa		.nodn:		ld a, (store_tmp2) 
0dac fe 00				cp 0 
0dae 28 08				jr z, .noup 
0db0			 
0db0 3e 00				ld a, 0 
0db2 11 20 0e				ld de, .mup 
0db5 cd 2b 0d				call str_at_display 
0db8			 
0db8 3e 02		.noup:		ld a, 2 
0dba 11 1e 0e				ld de, .msel 
0dbd cd 2b 0d				call str_at_display 
0dc0			 
0dc0					; if current option + 1 is not null then display V in bottom 
0dc0					; get key 
0dc0 cd 3b 0d				call update_display 
0dc3			 
0dc3			 
0dc3					; handle key 
0dc3			 
0dc3 cd 07 77				call cin_wait 
0dc6			 
0dc6 fe 05				cp KEY_UP 
0dc8 28 2b				jr z, .mgoup 
0dca fe 61				cp 'a' 
0dcc 28 27				jr z, .mgoup 
0dce fe 0a				cp KEY_DOWN 
0dd0 28 32				jr z, .mgod 
0dd2 fe 7a				cp 'z' 
0dd4 28 2e				jr z, .mgod 
0dd6 fe 20				cp ' ' 
0dd8 28 34				jr z, .goend 
0dda fe 0c				cp KEY_RIGHT 
0ddc 28 30				jr z, .goend 
0dde fe 0d				cp KEY_CR 
0de0 28 2c				jr z, .goend 
0de2 fe 71				cp 'q' 
0de4 28 0b				jr z, .goback 
0de6			 
0de6 fe 0b				cp KEY_LEFT 
0de8 28 07				jr z, .goback 
0dea fe 08				cp KEY_BS 
0dec 28 03				jr z, .goback 
0dee c3 5c 0d				jp .mloop 
0df1			 
0df1			.goback: 
0df1 3e 00			ld a, 0 
0df3 18 1d			jr .goend2 
0df5			 
0df5				; move up one 
0df5			.mgoup: 
0df5 3a 78 fa				ld a, (store_tmp2) 
0df8 fe 00				cp 0 
0dfa ca 5c 0d				jp z, .mloop 
0dfd 3d					dec a 
0dfe 32 78 fa				ld (store_tmp2), a 
0e01 c3 5c 0d				jp .mloop 
0e04			 
0e04				; move down one 
0e04			.mgod: 
0e04 3a 78 fa				ld a, (store_tmp2) 
0e07 3c					inc a 
0e08 32 78 fa				ld (store_tmp2), a 
0e0b c3 5c 0d				jp .mloop 
0e0e			 
0e0e			 
0e0e			.goend: 
0e0e					; get selected item number 
0e0e			 
0e0e 3a 78 fa				ld a, (store_tmp2) 
0e11 3c					inc a 
0e12			 
0e12			.goend2: 
0e12 f5					push af 
0e13			 
0e13					; restore active fb 
0e13					; TODO BUG assumes fb1 
0e13			 
0e13 21 13 fd				ld hl, display_fb1 
0e16 22 cf fb				ld (display_fb_active), hl 
0e19			 
0e19					; restore main regs 
0e19			 
0e19			 
0e19 cd 3b 0d				call update_display 
0e1c			 
0e1c f1					pop af 
0e1d			 
0e1d c9				ret 
0e1e			 
0e1e .. 00		.msel:   db ">",0 
0e20 .. 00		.mup:   db "^",0 
0e22 .. 00		.mdown:   db "v",0 
0e24			 
0e24			 
0e24			; eof 
0e24			 
# End of file firmware_display.asm
0e24			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0e24			; random number generators 
0e24			 
0e24			 
0e24			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0e24			 
0e24			 
0e24			;-----> Generate a random number 
0e24			; output a=answer 0<=a<=255 
0e24			; all registers are preserved except: af 
0e24			random: 
0e24 e5			        push    hl 
0e25 d5			        push    de 
0e26 2a b1 fb		        ld      hl,(randData) 
0e29 ed 5f		        ld      a,r 
0e2b 57			        ld      d,a 
0e2c 5e			        ld      e,(hl) 
0e2d 19			        add     hl,de 
0e2e 85			        add     a,l 
0e2f ac			        xor     h 
0e30 22 b1 fb		        ld      (randData),hl 
0e33 d1			        pop     de 
0e34 e1			        pop     hl 
0e35 c9			        ret 
0e36			 
0e36			 
0e36			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0e36			 
0e36			 
0e36			 
0e36			;------LFSR------ 
0e36			;James Montelongo 
0e36			;optimized by Spencer Putt 
0e36			;out: 
0e36			; a = 8 bit random number 
0e36			RandLFSR: 
0e36 21 b7 fb		        ld hl,LFSRSeed+4 
0e39 5e			        ld e,(hl) 
0e3a 23			        inc hl 
0e3b 56			        ld d,(hl) 
0e3c 23			        inc hl 
0e3d 4e			        ld c,(hl) 
0e3e 23			        inc hl 
0e3f 7e			        ld a,(hl) 
0e40 47			        ld b,a 
0e41 cb 13		        rl e  
0e43 cb 12			rl d 
0e45 cb 11		        rl c  
0e47 17				rla 
0e48 cb 13		        rl e  
0e4a cb 12			rl d 
0e4c cb 11		        rl c  
0e4e 17				rla 
0e4f cb 13		        rl e  
0e51 cb 12			rl d 
0e53 cb 11		        rl c  
0e55 17				rla 
0e56 67			        ld h,a 
0e57 cb 13		        rl e  
0e59 cb 12			rl d 
0e5b cb 11		        rl c  
0e5d 17				rla 
0e5e a8			        xor b 
0e5f cb 13		        rl e  
0e61 cb 12			rl d 
0e63 ac			        xor h 
0e64 a9			        xor c 
0e65 aa			        xor d 
0e66 21 b9 fb		        ld hl,LFSRSeed+6 
0e69 11 ba fb		        ld de,LFSRSeed+7 
0e6c 01 07 00		        ld bc,7 
0e6f ed b8		        lddr 
0e71 12			        ld (de),a 
0e72 c9			        ret 
0e73			 
0e73			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0e73			 
0e73			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0e73			 
0e73			 
0e73			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0e73			 
0e73			prng16: 
0e73			;Inputs: 
0e73			;   (seed1) contains a 16-bit seed value 
0e73			;   (seed2) contains a NON-ZERO 16-bit seed value 
0e73			;Outputs: 
0e73			;   HL is the result 
0e73			;   BC is the result of the LCG, so not that great of quality 
0e73			;   DE is preserved 
0e73			;Destroys: 
0e73			;   AF 
0e73			;cycle: 4,294,901,760 (almost 4.3 billion) 
0e73			;160cc 
0e73			;26 bytes 
0e73 2a ab fb		    ld hl,(seed1) 
0e76 44			    ld b,h 
0e77 4d			    ld c,l 
0e78 29			    add hl,hl 
0e79 29			    add hl,hl 
0e7a 2c			    inc l 
0e7b 09			    add hl,bc 
0e7c 22 ab fb		    ld (seed1),hl 
0e7f 2a a9 fb		    ld hl,(seed2) 
0e82 29			    add hl,hl 
0e83 9f			    sbc a,a 
0e84 e6 2d		    and %00101101 
0e86 ad			    xor l 
0e87 6f			    ld l,a 
0e88 22 a9 fb		    ld (seed2),hl 
0e8b 09			    add hl,bc 
0e8c c9			    ret 
0e8d			 
0e8d			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0e8d			 
0e8d			rand32: 
0e8d			;Inputs: 
0e8d			;   (seed1_0) holds the lower 16 bits of the first seed 
0e8d			;   (seed1_1) holds the upper 16 bits of the first seed 
0e8d			;   (seed2_0) holds the lower 16 bits of the second seed 
0e8d			;   (seed2_1) holds the upper 16 bits of the second seed 
0e8d			;   **NOTE: seed2 must be non-zero 
0e8d			;Outputs: 
0e8d			;   HL is the result 
0e8d			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0e8d			;Destroys: 
0e8d			;   AF 
0e8d			;Tested and passes all CAcert tests 
0e8d			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0e8d			;it has a period of 18,446,744,069,414,584,320 
0e8d			;roughly 18.4 quintillion. 
0e8d			;LFSR taps: 0,2,6,7  = 11000101 
0e8d			;291cc 
0e8d			;seed1_0=$+1 
0e8d			;    ld hl,12345 
0e8d			;seed1_1=$+1 
0e8d			;    ld de,6789 
0e8d			;    ld b,h 
0e8d			;    ld c,l 
0e8d			;    add hl,hl \ rl e \ rl d 
0e8d			;    add hl,hl \ rl e \ rl d 
0e8d			;    inc l 
0e8d			;    add hl,bc 
0e8d			;    ld (seed1_0),hl 
0e8d			;    ld hl,(seed1_1) 
0e8d			;    adc hl,de 
0e8d			;    ld (seed1_1),hl 
0e8d			;    ex de,hl 
0e8d			;seed2_0=$+1 
0e8d			;    ld hl,9876 
0e8d			;seed2_1=$+1 
0e8d			;    ld bc,54321 
0e8d			;    add hl,hl \ rl c \ rl b 
0e8d			;    ld (seed2_1),bc 
0e8d			;    sbc a,a 
0e8d			;    and %11000101 
0e8d			;    xor l 
0e8d			;    ld l,a 
0e8d			;    ld (seed2_0),hl 
0e8d			;    ex de,hl 
0e8d			;    add hl,bc 
0e8d			;    ret 
0e8d			; 
0e8d			 
0e8d			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0e8d			; 20 bytes, 86 cycles (excluding ret) 
0e8d			 
0e8d			; returns   hl = pseudorandom number 
0e8d			; corrupts   a 
0e8d			 
0e8d			; generates 16-bit pseudorandom numbers with a period of 65535 
0e8d			; using the xorshift method: 
0e8d			 
0e8d			; hl ^= hl << 7 
0e8d			; hl ^= hl >> 9 
0e8d			; hl ^= hl << 8 
0e8d			 
0e8d			; some alternative shift triplets which also perform well are: 
0e8d			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0e8d			 
0e8d			;  org 32768 
0e8d			 
0e8d			xrnd: 
0e8d 2a af fb		  ld hl,(xrandc)       ; seed must not be 0 
0e90 3e 00		  ld a,0 
0e92 bd			  cp l 
0e93 20 02		  jr nz, .xrnd1 
0e95 2e 01		  ld l, 1 
0e97			.xrnd1: 
0e97			 
0e97 7c			  ld a,h 
0e98 1f			  rra 
0e99 7d			  ld a,l 
0e9a 1f			  rra 
0e9b ac			  xor h 
0e9c 67			  ld h,a 
0e9d 7d			  ld a,l 
0e9e 1f			  rra 
0e9f 7c			  ld a,h 
0ea0 1f			  rra 
0ea1 ad			  xor l 
0ea2 6f			  ld l,a 
0ea3 ac			  xor h 
0ea4 67			  ld h,a 
0ea5			 
0ea5 22 af fb		  ld (xrandc),hl 
0ea8			 
0ea8 c9			  ret 
0ea9			;  
0ea9			 
0ea9			 
0ea9			;;;; int maths 
0ea9			 
0ea9			; https://map.grauw.nl/articles/mult_div_shifts.php 
0ea9			; Divide 16-bit values (with 16-bit result) 
0ea9			; In: Divide BC by divider DE 
0ea9			; Out: BC = result, HL = rest 
0ea9			; 
0ea9			Div16: 
0ea9 21 00 00		    ld hl,0 
0eac 78			    ld a,b 
0ead 06 08		    ld b,8 
0eaf			Div16_Loop1: 
0eaf 17			    rla 
0eb0 ed 6a		    adc hl,hl 
0eb2 ed 52		    sbc hl,de 
0eb4 30 01		    jr nc,Div16_NoAdd1 
0eb6 19			    add hl,de 
0eb7			Div16_NoAdd1: 
0eb7 10 f6		    djnz Div16_Loop1 
0eb9 17			    rla 
0eba 2f			    cpl 
0ebb 47			    ld b,a 
0ebc 79			    ld a,c 
0ebd 48			    ld c,b 
0ebe 06 08		    ld b,8 
0ec0			Div16_Loop2: 
0ec0 17			    rla 
0ec1 ed 6a		    adc hl,hl 
0ec3 ed 52		    sbc hl,de 
0ec5 30 01		    jr nc,Div16_NoAdd2 
0ec7 19			    add hl,de 
0ec8			Div16_NoAdd2: 
0ec8 10 f6		    djnz Div16_Loop2 
0eca 17			    rla 
0ecb 2f			    cpl 
0ecc 41			    ld b,c 
0ecd 4f			    ld c,a 
0ece c9			ret 
0ecf			 
0ecf			 
0ecf			;http://z80-heaven.wikidot.com/math 
0ecf			; 
0ecf			;Inputs: 
0ecf			;     DE and A are factors 
0ecf			;Outputs: 
0ecf			;     A is not changed 
0ecf			;     B is 0 
0ecf			;     C is not changed 
0ecf			;     DE is not changed 
0ecf			;     HL is the product 
0ecf			;Time: 
0ecf			;     342+6x 
0ecf			; 
0ecf			Mult16: 
0ecf			 
0ecf 06 08		     ld b,8          ;7           7 
0ed1 21 00 00		     ld hl,0         ;10         10 
0ed4 29			       add hl,hl     ;11*8       88 
0ed5 07			       rlca          ;4*8        32 
0ed6 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0ed8 19			         add hl,de   ;--         -- 
0ed9 10 f9		       djnz $-5      ;13*7+8     99 
0edb c9			ret 
0edc			 
0edc			; 
0edc			; Square root of 16-bit value 
0edc			; In:  HL = value 
0edc			; Out:  D = result (rounded down) 
0edc			; 
0edc			;Sqr16: 
0edc			;    ld de,#0040 
0edc			;    ld a,l 
0edc			;    ld l,h 
0edc			;    ld h,d 
0edc			;    or a 
0edc			;    ld b,8 
0edc			;Sqr16_Loop: 
0edc			;    sbc hl,de 
0edc			;    jr nc,Sqr16_Skip 
0edc			;    add hl,de 
0edc			;Sqr16_Skip: 
0edc			;    ccf 
0edc			;    rl d 
0edc			;    add a,a 
0edc			;    adc hl,hl 
0edc			;    add a,a 
0edc			;    adc hl,hl 
0edc			;    djnz Sqr16_Loop 
0edc			;    ret 
0edc			; 
0edc			; 
0edc			; Divide 8-bit values 
0edc			; In: Divide E by divider C 
0edc			; Out: A = result, B = rest 
0edc			; 
0edc			Div8: 
0edc af			    xor a 
0edd 06 08		    ld b,8 
0edf			Div8_Loop: 
0edf cb 13		    rl e 
0ee1 17			    rla 
0ee2 91			    sub c 
0ee3 30 01		    jr nc,Div8_NoAdd 
0ee5 81			    add a,c 
0ee6			Div8_NoAdd: 
0ee6 10 f7		    djnz Div8_Loop 
0ee8 47			    ld b,a 
0ee9 7b			    ld a,e 
0eea 17			    rla 
0eeb 2f			    cpl 
0eec c9			    ret 
0eed			 
0eed			; 
0eed			; Multiply 8-bit value with a 16-bit value (unrolled) 
0eed			; In: Multiply A with DE 
0eed			; Out: HL = result 
0eed			; 
0eed			Mult12U: 
0eed 2e 00		    ld l,0 
0eef 87			    add a,a 
0ef0 30 01		    jr nc,Mult12U_NoAdd0 
0ef2 19			    add hl,de 
0ef3			Mult12U_NoAdd0: 
0ef3 29			    add hl,hl 
0ef4 87			    add a,a 
0ef5 30 01		    jr nc,Mult12U_NoAdd1 
0ef7 19			    add hl,de 
0ef8			Mult12U_NoAdd1: 
0ef8 29			    add hl,hl 
0ef9 87			    add a,a 
0efa 30 01		    jr nc,Mult12U_NoAdd2 
0efc 19			    add hl,de 
0efd			Mult12U_NoAdd2: 
0efd 29			    add hl,hl 
0efe 87			    add a,a 
0eff 30 01		    jr nc,Mult12U_NoAdd3 
0f01 19			    add hl,de 
0f02			Mult12U_NoAdd3: 
0f02 29			    add hl,hl 
0f03 87			    add a,a 
0f04 30 01		    jr nc,Mult12U_NoAdd4 
0f06 19			    add hl,de 
0f07			Mult12U_NoAdd4: 
0f07 29			    add hl,hl 
0f08 87			    add a,a 
0f09 30 01		    jr nc,Mult12U_NoAdd5 
0f0b 19			    add hl,de 
0f0c			Mult12U_NoAdd5: 
0f0c 29			    add hl,hl 
0f0d 87			    add a,a 
0f0e 30 01		    jr nc,Mult12U_NoAdd6 
0f10 19			    add hl,de 
0f11			Mult12U_NoAdd6: 
0f11 29			    add hl,hl 
0f12 87			    add a,a 
0f13 d0			    ret nc 
0f14 19			    add hl,de 
0f15 c9			    ret 
0f16			 
0f16			; 
0f16			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f16			; In: Multiply A with DE 
0f16			;      Put lowest value in A for most efficient calculation 
0f16			; Out: HL = result 
0f16			; 
0f16			Mult12R: 
0f16 21 00 00		    ld hl,0 
0f19			Mult12R_Loop: 
0f19 cb 3f		    srl a 
0f1b 30 01		    jr nc,Mult12R_NoAdd 
0f1d 19			    add hl,de 
0f1e			Mult12R_NoAdd: 
0f1e cb 23		    sla e 
0f20 cb 12		    rl d 
0f22 b7			    or a 
0f23 c2 19 0f		    jp nz,Mult12R_Loop 
0f26 c9			    ret 
0f27			 
0f27			; 
0f27			; Multiply 16-bit values (with 32-bit result) 
0f27			; In: Multiply BC with DE 
0f27			; Out: BCHL = result 
0f27			; 
0f27			Mult32: 
0f27 79			    ld a,c 
0f28 48			    ld c,b 
0f29 21 00 00		    ld hl,0 
0f2c 06 10		    ld b,16 
0f2e			Mult32_Loop: 
0f2e 29			    add hl,hl 
0f2f 17			    rla 
0f30 cb 11		    rl c 
0f32 30 07		    jr nc,Mult32_NoAdd 
0f34 19			    add hl,de 
0f35 ce 00		    adc a,0 
0f37 d2 3b 0f		    jp nc,Mult32_NoAdd 
0f3a 0c			    inc c 
0f3b			Mult32_NoAdd: 
0f3b 10 f1		    djnz Mult32_Loop 
0f3d 41			    ld b,c 
0f3e 4f			    ld c,a 
0f3f c9			    ret 
0f40			 
0f40			 
0f40			 
0f40			; 
0f40			; Multiply 8-bit values 
0f40			; In:  Multiply H with E 
0f40			; Out: HL = result 
0f40			; 
0f40			Mult8: 
0f40 16 00		    ld d,0 
0f42 6a			    ld l,d 
0f43 06 08		    ld b,8 
0f45			Mult8_Loop: 
0f45 29			    add hl,hl 
0f46 30 01		    jr nc,Mult8_NoAdd 
0f48 19			    add hl,de 
0f49			Mult8_NoAdd: 
0f49 10 fa		    djnz Mult8_Loop 
0f4b c9			    ret 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			 
0f4c			;;http://z80-heaven.wikidot.com/math 
0f4c			;;This divides DE by BC, storing the result in DE, remainder in HL 
0f4c			; 
0f4c			;DE_Div_BC:          ;1281-2x, x is at most 16 
0f4c			;     ld a,16        ;7 
0f4c			;     ld hl,0        ;10 
0f4c			;     jp $+5         ;10 
0f4c			;.DivLoop: 
0f4c			;       add hl,bc    ;-- 
0f4c			;       dec a        ;64 
0f4c			;       jr z,.DivLoopEnd        ;86 
0f4c			; 
0f4c			;       sla e        ;128 
0f4c			;       rl d         ;128 
0f4c			;       adc hl,hl    ;240 
0f4c			;       sbc hl,bc    ;240 
0f4c			;       jr nc,.DivLoop ;23|21 
0f4c			;       inc e        ;-- 
0f4c			;       jp .DivLoop+1 
0f4c			; 
0f4c			;.DivLoopEnd: 
0f4c			 
0f4c			;HL_Div_C: 
0f4c			;Inputs: 
0f4c			;     HL is the numerator 
0f4c			;     C is the denominator 
0f4c			;Outputs: 
0f4c			;     A is the remainder 
0f4c			;     B is 0 
0f4c			;     C is not changed 
0f4c			;     DE is not changed 
0f4c			;     HL is the quotient 
0f4c			; 
0f4c			;       ld b,16 
0f4c			;       xor a 
0f4c			;         add hl,hl 
0f4c			;         rla 
0f4c			;         cp c 
0f4c			;         jr c,$+4 
0f4c			;           inc l 
0f4c			;           sub c 
0f4c			;         djnz $-7 
0f4c			 
0f4c			; https://plutiedev.com/z80-add-8bit-to-16bit 
0f4c			 
0f4c			addatohl: 
0f4c 85			    add   a, l    ; A = A+L 
0f4d 6f			    ld    l, a    ; L = A+L 
0f4e 8c			    adc   a, h    ; A = A+L+H+carry 
0f4f 95			    sub   l       ; A = H+carry 
0f50 67			    ld    h, a    ; H = H+carry 
0f51 c9			ret 
0f52			 
0f52			addatode: 
0f52 83			    add   a, e    ; A = A+L 
0f53 5f			    ld    e, a    ; L = A+L 
0f54 8a			    adc   a, d    ; A = A+L+H+carry 
0f55 93			    sub   e       ; A = H+carry 
0f56 57			    ld    d, a    ; H = H+carry 
0f57 c9			ret 
0f58			 
0f58			 
0f58			addatobc: 
0f58 81			    add   a, c    ; A = A+L 
0f59 4f			    ld    c, a    ; L = A+L 
0f5a 88			    adc   a, b    ; A = A+L+H+carry 
0f5b 91			    sub   c       ; A = H+carry 
0f5c 47			    ld    b, a    ; H = H+carry 
0f5d c9			ret 
0f5e			 
0f5e			subafromhl: 
0f5e			   ; If A=0 do nothing 
0f5e			    ; Otherwise flip A's sign. Since 
0f5e			    ; the upper byte becomes -1, also 
0f5e			    ; substract 1 from H. 
0f5e ed 44		    neg 
0f60 ca 69 0f		    jp    z, Skip 
0f63 25			    dec   h 
0f64			     
0f64			    ; Now add the low byte as usual 
0f64			    ; Two's complement takes care of 
0f64			    ; ensuring the result is correct 
0f64 85			    add   a, l 
0f65 6f			    ld    l, a 
0f66 8c			    adc   a, h 
0f67 95			    sub   l 
0f68 67			    ld    h, a 
0f69			Skip: 
0f69 c9				ret 
0f6a			 
0f6a			 
0f6a			; compare hl and de 
0f6a			; returns:  
0f6a			; if hl = de, z=1, s=0, c0=0 
0f6a			; if hl > de, z=0, s=0, c=0 
0f6a			; if hl < de, z=0, s=1, c=1 
0f6a			cmp16:	 
0f6a b7				or a 
0f6b ed 52			sbc hl,de 
0f6d e0				ret po 
0f6e 7c				ld a,h 
0f6f 1f				rra 
0f70 ee 40			xor 01000000B 
0f72 37				scf 
0f73 8f				adc a,a 
0f74 c9				ret 
0f75			 
0f75			 
0f75			; test if hl contains zero   - A is destroyed 
0f75			 
0f75			ishlzero:    
0f75 b7				or a     ; reset flags 
0f76 7c				ld a, h 
0f77 b5				or l        	 
0f78			 
0f78 c9				ret 
0f79			 
0f79			 
0f79			 
0f79			 
0f79			if FORTH_ENABLE_FLOATMATH 
0f79			;include "float/bbcmath.z80" 
0f79			include "float/lpfpcalc.asm" 
0f79			endif 
0f79			 
0f79			 
0f79			; eof 
0f79			 
# End of file firmware_maths.asm
0f79			include "firmware_strings.asm"   ; string handling  
0f79			 
0f79			 
0f79			; TODO string len 
0f79			; input text string, end on cr with zero term 
0f79			; a offset into frame buffer to start prompt 
0f79			; d is max length 
0f79			; e is display size TODO 
0f79			; c is current cursor position 
0f79			; hl is ptr to where string will be stored 
0f79			 
0f79			 
0f79			; TODO check limit of buffer for new inserts 
0f79			; TODO check insert does not push beyond buffer 
0f79			; TODO scroll in a limited display area 
0f79			; TODO scroll whole screen on page wrap 
0f79			 
0f79			 
0f79			; TODO handle KEY_PREVWORD 
0f79			; TODO handle KEY_NEXTWORD 
0f79			; TODO handle KEY_HOME 
0f79			; TODO handle KEY_END 
0f79			; TODO use LCD cursor? 
0f79			 
0f79 32 67 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0f7c 81					add c 
0f7d 32 65 fe				ld (input_at_cursor),a	; save draw pos of cursor 
0f80 22 6a fe				ld (input_start), hl     ; save ptr to buffer 
0f83 79					ld a, c 
0f84 cd 4c 0f				call addatohl 
0f87 22 6c fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0f8a 7a					ld a,d 
0f8b 32 69 fe			        ld (input_size), a       ; save length of input area 
0f8e 79					ld a, c 
0f8f 32 58 fe				ld (input_cursor),a      ; init cursor start position  
0f92 7b					ld a,e 
0f93 32 68 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0f96					 
0f96					 
0f96			 
0f96			;		ld a,(input_ptr) 
0f96			;		ld (input_under_cursor),a 	; save what is under the cursor 
0f96			 
0f96			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0f96					; init cursor shape if not set by the cin routines 
0f96 21 c7 fb				ld hl, cursor_shape 
0f99 3e ff				ld a, 255 
0f9b 77					ld (hl), a 
0f9c 23					inc hl 
0f9d 3e 00				ld a, 0 
0f9f 77					ld (hl), a 
0fa0			 
0fa0 3e 0f				ld a, CUR_BLINK_RATE 
0fa2 32 63 fe				ld (input_cur_flash), a 
0fa5 3e 01				ld a, 1 
0fa7 32 62 fe				ld (input_cur_onoff),a 
0faa			 
0faa			;	if DEBUG_INPUT 
0faa			;		push af 
0faa			;		ld a, 'I' 
0faa			;		ld (debug_mark),a 
0faa			;		pop af 
0faa			;		CALLMONITOR 
0faa			;	endif 
0faa			.is1:		; main entry loop 
0faa			 
0faa			 
0faa			 
0faa					; pause 1ms 
0faa			 
0faa 3e 01				ld a, 1 
0fac cd 7a 0c				call aDelayInMS 
0faf			 
0faf					; dec flash counter 
0faf 3a 63 fe				ld a, (input_cur_flash) 
0fb2 3d					dec a 
0fb3 32 63 fe				ld (input_cur_flash), a 
0fb6 fe 00				cp 0 
0fb8 20 0d				jr nz, .nochgstate 
0fba			 
0fba			 
0fba					; change state 
0fba 3a 62 fe				ld a,(input_cur_onoff) 
0fbd ed 44				neg 
0fbf 32 62 fe				ld (input_cur_onoff),a 
0fc2			 
0fc2			 
0fc2					; reset on change of state 
0fc2 3e 0f				ld a, CUR_BLINK_RATE 
0fc4 32 63 fe				ld (input_cur_flash), a 
0fc7			 
0fc7			.nochgstate: 
0fc7					 
0fc7					 
0fc7			 
0fc7					; display cursor  
0fc7			 
0fc7			;		ld hl, (input_start) 
0fc7			;		ld a, (input_cursor) 
0fc7			;		call addatohl 
0fc7			 
0fc7					; get char under cursor and replace with cursor 
0fc7 2a 6c fe		ld hl, (input_ptr) 
0fca			;		ld a, (hl) 
0fca			;		ld (input_under_cursor),a 
0fca			;		ld a, '_' 
0fca			;		ld (hl), a 
0fca			 
0fca					; display string 
0fca			 
0fca ed 5b 6a fe			ld de, (input_start) 
0fce 3a 67 fe				ld a, (input_at_pos) 
0fd1 cd 2b 0d				call str_at_display 
0fd4			;	        call update_display 
0fd4			 
0fd4					; find place to put the cursor 
0fd4			;		add h 
0fd4			;		ld l, display_row_1 
0fd4			;		sub l 
0fd4			; (input_at_pos) 
0fd4					;ld c, a 
0fd4			;		ld a, (input_cursor) 
0fd4			;		ld l, (input_at_pos) 
0fd4			;		;ld b, h 
0fd4			;		add l 
0fd4			;		ld (input_at_cursor),a 
0fd4					;ld l,h 
0fd4			 
0fd4			;		ld h, 0 
0fd4			;		ld l,(input_at_pos) 
0fd4			;		ld a, (input_cursor) 
0fd4			;		call addatohl 
0fd4			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0fd4			;		call subafromhl 
0fd4			;		ld a,l 
0fd4			;		ld (input_at_cursor), a 
0fd4			 
0fd4				if DEBUG_INPUT 
0fd4					ld a, (hardware_diag) 
0fd4					cp 0 
0fd4					jr z, .skip_input_diag 
0fd4			 
0fd4					ld a,(input_at_pos) 
0fd4					ld hl, LFSRSeed 
0fd4					call hexout 
0fd4					ld a, (input_cursor) 
0fd4					ld hl, LFSRSeed+2 
0fd4					call hexout 
0fd4					ld a,(input_at_cursor) 
0fd4					ld hl, LFSRSeed+4 
0fd4					call hexout 
0fd4			 
0fd4					ld a,(input_cur_onoff) 
0fd4					ld hl, LFSRSeed+6 
0fd4					call hexout 
0fd4			 
0fd4					ld a,(input_cur_flash) 
0fd4					ld hl, LFSRSeed+8 
0fd4					call hexout 
0fd4			 
0fd4					ld a,(input_len) 
0fd4					ld hl, LFSRSeed+10 
0fd4					call hexout 
0fd4					ld hl, LFSRSeed+12 
0fd4					ld a, 0 
0fd4					ld (hl),a 
0fd4					ld a, display_row_4 
0fd4					ld de, LFSRSeed 
0fd4					call str_at_display 
0fd4					.skip_input_diag: 
0fd4				endif 
0fd4			 
0fd4					; decide on if we are showing the cursor this time round 
0fd4			 
0fd4 3a 62 fe				ld a, (input_cur_onoff) 
0fd7 fe ff				cp 255 
0fd9 28 13				jr z, .skipcur 
0fdb			 
0fdb			 
0fdb 3a 65 fe				ld a,(input_at_cursor) 
0fde 11 c7 fb				ld de, cursor_shape 
0fe1 cd 2b 0d				call str_at_display 
0fe4			 
0fe4					; save length of current input string 
0fe4 2a 6a fe				ld hl, (input_start) 
0fe7 cd aa 13				call strlenz 
0fea 7d					ld a,l 
0feb 32 5d fe				ld (input_len),a 
0fee			 
0fee			.skipcur: 
0fee			 
0fee cd 3b 0d			        call update_display 
0ff1					 
0ff1			 
0ff1			 
0ff1					; wait 
0ff1				 
0ff1					; TODO loop without wait to flash the cursor and char under cursor	 
0ff1 cd 18 77				call cin    ; _wait 
0ff4			 
0ff4 fe 00				cp 0 
0ff6 ca aa 0f				jp z, .is1 
0ff9			 
0ff9					; get ptr to char to input into 
0ff9			 
0ff9 4f					ld c,a 
0ffa 2a 6a fe				ld hl, (input_start) 
0ffd 3a 58 fe				ld a, (input_cursor) 
1000 cd 4c 0f				call addatohl 
1003 22 6c fe				ld (input_ptr), hl 
1006 79					ld a,c 
1007			 
1007					; replace char under cursor 
1007			 
1007			;		ld hl, (input_ptr) 
1007			;		ld a, (input_under_cursor) 	; get what is under the cursor 
1007			;		ld (hl), a 
1007			 
1007			;	if DEBUG_INPUT 
1007			;		push af 
1007			;		ld a, 'i' 
1007			;		ld (debug_mark),a 
1007			;		pop af 
1007			;		CALLMONITOR 
1007			;	endif 
1007 fe 0e				cp KEY_HOME 
1009 20 0e				jr nz, .iske 
100b			 
100b 3a 67 fe				ld a, (input_at_pos) 
100e 32 65 fe				ld (input_at_cursor),a 
1011 3e 00				ld a, 0 
1013 32 58 fe				ld (input_cursor), a 
1016 c3 aa 0f				jp .is1 
1019					 
1019 fe 0f		.iske:		cp KEY_END 
101b 20 03				jr nz, .isknw 
101d c3 aa 0f				jp .is1 
1020			 
1020 fe 06		.isknw:		cp KEY_NEXTWORD 
1022 20 1b				jr nz, .iskpw 
1024			 
1024 2a 6c fe		.isknwm:	ld hl, (input_ptr) 
1027 7e					ld a,(hl)	 
1028 fe 00				cp 0 
102a ca aa 0f				jp z, .is1    ; end of string 
102d fe 20				cp ' ' 
102f ca aa 0f				jp z, .is1    ; end of word 
1032 23					inc hl 
1033 22 6c fe				ld (input_ptr), hl 
1036 3a 65 fe				ld a, (input_at_cursor) 
1039 3c					inc a 
103a 32 65 fe				ld (input_at_cursor), a 
103d 18 e5				jr .isknwm 
103f			 
103f fe 07		.iskpw:		cp KEY_PREVWORD 
1041 20 1b				jr nz, .iskl 
1043			.iskpwm:	 
1043 2a 6c fe				ld hl, (input_ptr) 
1046 7e					ld a,(hl)	 
1047 fe 00				cp 0  
1049 ca aa 0f				jp z, .is1    ; end of string 
104c fe 20				cp ' ' 
104e ca aa 0f				jp z, .is1    ; end of word 
1051 2b					dec hl 
1052 22 6c fe				ld (input_ptr), hl 
1055 3a 65 fe				ld a, (input_at_cursor) 
1058 3d					dec a 
1059 32 65 fe				ld (input_at_cursor), a 
105c 18 e5				jr .iskpwm 
105e			 
105e			 
105e fe 0b		.iskl:		cp KEY_LEFT 
1060 20 27				jr nz, .isk1 
1062			 
1062 3a 58 fe				ld a, (input_cursor) 
1065			 
1065 fe 00				cp 0 
1067 ca aa 0f				jp z, .is1 		; at start of line to ignore  
106a			 
106a 3d					dec  a 		; TODO check underflow 
106b 32 58 fe				ld (input_cursor), a 
106e			 
106e 2a 6c fe				ld hl, (input_ptr) 
1071 2b					dec hl 
1072 22 6c fe				ld (input_ptr), hl 
1075					 
1075 3a 65 fe				ld a, (input_at_cursor) 
1078 3d					dec a 
1079 32 65 fe				ld (input_at_cursor), a 
107c			 
107c 3e 01				ld a, 1		; show cursor moving 
107e 32 62 fe				ld (input_cur_onoff),a 
1081 3e 0f				ld a, CUR_BLINK_RATE 
1083 32 63 fe				ld (input_cur_flash), a 
1086			 
1086 c3 aa 0f				jp .is1 
1089			 
1089 fe 0c		.isk1:		cp KEY_RIGHT 
108b 20 2a				jr nz, .isk2 
108d			 
108d 3a 5d fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1090 5f					ld e,a 
1091 3a 58 fe				ld a, (input_cursor) 
1094 bb					cp e 
1095 ca aa 0f				jp z, .is1		; at the end of string so dont go right 
1098			 
1098 3c					inc  a 		; TODO check overflow 
1099 32 58 fe				ld (input_cursor), a 
109c			 
109c 3a 65 fe				ld a, (input_at_cursor) 
109f 3c					inc a 
10a0 32 65 fe				ld (input_at_cursor), a 
10a3			 
10a3 2a 6c fe				ld hl, (input_ptr) 
10a6 23					inc hl 
10a7 22 6c fe				ld (input_ptr), hl 
10aa			 
10aa 3e 01				ld a, 1		; show cursor moving 
10ac 32 62 fe				ld (input_cur_onoff),a 
10af 3e 0f				ld a, CUR_BLINK_RATE 
10b1 32 63 fe				ld (input_cur_flash), a 
10b4			 
10b4 c3 aa 0f				jp .is1 
10b7			 
10b7 fe 05		.isk2:		cp KEY_UP 
10b9			 
10b9 20 26				jr nz, .isk3 
10bb			 
10bb					; swap last command with the current on 
10bb			 
10bb					; move cursor to start of string 
10bb 2a 6a fe				ld hl, (input_start) 
10be 22 6c fe				ld (input_ptr), hl 
10c1			 
10c1 3a 67 fe				ld a, (input_at_pos) 
10c4 32 65 fe				ld (input_at_cursor), a 
10c7			 
10c7 3e 00				ld a, 0 
10c9 32 58 fe				ld (input_cursor), a 
10cc					 
10cc					; swap input and last command buffers 
10cc			 
10cc 21 ef f4				ld hl, os_cli_cmd 
10cf 11 ee f5				ld de, os_last_cmd 
10d2 06 ff				ld b, 255 
10d4 7e			.swap1:		ld a, (hl) 
10d5 4f					ld c,a 
10d6 1a					ld a, (de) 
10d7 77					ld (hl), a 
10d8 79					ld a,c 
10d9 12					ld (de),a 
10da 23					inc hl 
10db 13					inc de 
10dc 10 f6				djnz .swap1 
10de			 
10de			 
10de			 
10de			 
10de			 
10de c3 aa 0f				jp .is1 
10e1			 
10e1 fe 08		.isk3:		cp KEY_BS 
10e3 20 3c				jr nz, .isk4 
10e5			 
10e5 3a 58 fe				ld a, (input_cursor) 
10e8			 
10e8 fe 00				cp 0 
10ea ca aa 0f				jp z, .is1 		; at start of line to ignore  
10ed			 
10ed 3d					dec  a 		; TODO check underflow 
10ee 32 58 fe				ld (input_cursor), a 
10f1			 
10f1					; hl is source 
10f1					; de needs to be source - 1 
10f1			 
10f1			;		ld a, 0 
10f1			;		dec hl 
10f1			;		ld (hl), a 
10f1			 
10f1 2a 6c fe				ld hl, (input_ptr) 
10f4 2b					dec hl 
10f5 22 6c fe				ld (input_ptr), hl 
10f8			 
10f8					; shift all data 
10f8			 
10f8 e5					push hl 
10f9 23					inc hl 
10fa d1					pop de 
10fb 3a 5d fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
10fe 4f					ld c,a 
10ff 06 00				ld b,0 
1101 ed b0				ldir  
1103			 
1103			 
1103			 
1103			 
1103 3a 65 fe				ld a, (input_at_cursor) 
1106 3d					dec a 
1107 32 65 fe				ld (input_at_cursor), a 
110a			 
110a			 
110a 3e 01				ld a, 1		; show cursor moving 
110c 32 62 fe				ld (input_cur_onoff),a 
110f 3e 0f				ld a, CUR_BLINK_RATE 
1111 32 63 fe				ld (input_cur_flash), a 
1114			 
1114					; remove char 
1114 3a 65 fe				ld a, (input_at_cursor) 
1117 3c					inc a 
1118 11 a2 11				ld de,.iblank 
111b cd 2b 0d				call str_at_display 
111e			 
111e c3 aa 0f				jp .is1 
1121			 
1121 fe 0d		.isk4:		cp KEY_CR 
1123 28 6c				jr z, .endinput 
1125			 
1125					; else add the key press to the end 
1125			 
1125 4f					ld c, a			; save key pressed 
1126			 
1126 7e					ld a,(hl)		; get what is currently under char 
1127			 
1127 fe 00				cp 0			; we are at the end of the string 
1129 20 2f				jr nz, .onchar 
112b					 
112b					; add a char to the end of the string 
112b				 
112b 71					ld (hl),c 
112c 23					inc hl 
112d			;		ld a,' ' 
112d			;		ld (hl),a 
112d			;		inc hl 
112d 3e 00				ld a,0 
112f 77					ld (hl),a 
1130 2b					dec hl 
1131			 
1131 3a 58 fe				ld a, (input_cursor) 
1134 3c					inc a				; TODO check max string length and scroll  
1135 32 58 fe				ld (input_cursor), a		; inc cursor pos 
1138							 
1138 3a 65 fe				ld a, (input_at_cursor) 
113b 3c					inc a 
113c 32 65 fe				ld (input_at_cursor), a 
113f			 
113f 2a 6c fe				ld hl, (input_ptr) 
1142 23					inc hl 
1143 22 6c fe				ld (input_ptr), hl 
1146			 
1146 2a 6c fe				ld hl, (input_ptr) 
1149 23					inc hl 
114a 22 6c fe				ld (input_ptr), hl 
114d			;	if DEBUG_INPUT 
114d			;		push af 
114d			;		ld a, '+' 
114d			;		ld (debug_mark),a 
114d			;		pop af 
114d			;		CALLMONITOR 
114d			;	endif 
114d 3e 01				ld a, 1		; show cursor moving 
114f 32 62 fe				ld (input_cur_onoff),a 
1152 3e 0f				ld a, CUR_BLINK_RATE 
1154 32 63 fe				ld (input_cur_flash), a 
1157 c3 aa 0f				jp .is1 
115a					 
115a			 
115a			 
115a					; if on a char then insert 
115a			.onchar: 
115a			 
115a					; TODO over flow check: make sure insert does not blow out buffer 
115a			 
115a					; need to do some maths to use lddr 
115a			 
115a e5					push hl   ; save char pos 
115b c5					push bc 
115c			 
115c 2a 6a fe				ld hl, (input_start) 
115f 3a 5d fe				ld a, (input_len) 
1162 cd 4c 0f				call addatohl  		; end of string 
1165 23					inc hl 
1166 23					inc hl		; past zero term 
1167 e5					push hl 
1168 23					inc hl 
1169 e5					push hl  
116a			 
116a								; start and end of lddr set, now how much to move? 
116a			 
116a							 
116a 3a 58 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
116d 47					ld b,a 
116e 3a 5d fe				ld a,(input_len) 
1171 5f					ld e,a 
1172 90					sub b 
1173 3c					inc a		;?? 
1174 3c					inc a		;?? 
1175 3c					inc a		;?? 
1176			 
1176 06 00				ld b,0 
1178 4f					ld c,a 
1179			 
1179				if DEBUG_INPUT 
1179					push af 
1179					ld a, 'i' 
1179					ld (debug_mark),a 
1179					pop af 
1179			;		CALLMONITOR 
1179				endif 
1179 d1					pop de 
117a e1					pop hl 
117b				if DEBUG_INPUT 
117b					push af 
117b					ld a, 'I' 
117b					ld (debug_mark),a 
117b					pop af 
117b			;		CALLMONITOR 
117b				endif 
117b ed b8				lddr 
117d				 
117d			 
117d			 
117d					; TODO have a key for insert/overwrite mode???? 
117d c1					pop bc 
117e e1					pop hl 
117f 71					ld (hl), c		; otherwise overwrite current char 
1180					 
1180			 
1180			 
1180			 
1180 3a 58 fe				ld a, (input_cursor) 
1183 3c					inc  a 		; TODO check overflow 
1184 32 58 fe				ld (input_cursor), a 
1187			 
1187 3a 65 fe				ld a, (input_at_cursor) 
118a 3c					inc a 
118b 32 65 fe				ld (input_at_cursor), a 
118e			 
118e c3 aa 0f				jp .is1 
1191			 
1191			.endinput:	; TODO look for end of string 
1191			 
1191					; add trailing space for end of token 
1191			 
1191 2a 6a fe				ld hl, (input_start) 
1194 3a 5d fe				ld a,(input_len) 
1197 cd 4c 0f				call addatohl 
119a 3e 20				ld a, ' ' 
119c 77					ld (hl),a 
119d					; TODO eof of parse marker 
119d			 
119d 23					inc hl 
119e 3e 00				ld a, 0 
11a0 77					ld (hl),a 
11a1			 
11a1			 
11a1 c9					ret 
11a2			 
11a2 .. 00		.iblank: db " ",0 
11a4			 
11a4			 
11a4 32 67 fe		input_str_prev:	ld (input_at_pos), a 
11a7 22 6a fe				ld (input_start), hl 
11aa 3e 01				ld a,1			; add cursor 
11ac 77					ld (hl),a 
11ad 23					inc hl 
11ae 3e 00				ld a,0 
11b0 77					ld (hl),a 
11b1 22 6c fe				ld (input_ptr), hl 
11b4 7a					ld a,d 
11b5 32 69 fe				ld (input_size), a 
11b8 3e 00				ld a,0 
11ba 32 58 fe				ld (input_cursor),a 
11bd			.instr1:	 
11bd			 
11bd					; TODO do block cursor 
11bd					; TODO switch cursor depending on the modifer key 
11bd			 
11bd					; update cursor shape change on key hold 
11bd			 
11bd 2a 6c fe				ld hl, (input_ptr) 
11c0 2b					dec hl 
11c1 3a c7 fb				ld a,(cursor_shape) 
11c4 77					ld (hl), a 
11c5			 
11c5					; display entered text 
11c5 3a 67 fe				ld a,(input_at_pos) 
11c8 cd dc 74		            	CALL fLCD_Pos       ;Position cursor to location in A 
11cb ed 5b 6a fe	            	LD   de, (input_start) 
11cf cd fe 74		            	CALL fLCD_Str       ;Display string pointed to by DE 
11d2			 
11d2 cd 18 77				call cin 
11d5 fe 00				cp 0 
11d7 28 e4				jr z, .instr1 
11d9			 
11d9					; proecess keyboard controls first 
11d9			 
11d9 2a 6c fe				ld hl,(input_ptr) 
11dc			 
11dc fe 0d				cp KEY_CR	 ; pressing enter ends input 
11de 28 5a				jr z, .instrcr 
11e0			 
11e0 fe 08				cp KEY_BS 	; back space 
11e2 20 0f				jr nz, .instr2 
11e4					; process back space 
11e4			 
11e4					; TODO stop back space if at start of string 
11e4 2b					dec hl 
11e5 2b					dec hl ; to over write cursor 
11e6 3a c7 fb				ld a,(cursor_shape) 
11e9					;ld a,0 
11e9 77					ld (hl),a 
11ea 23					inc hl 
11eb 3e 20				ld a," " 
11ed 77					ld (hl),a 
11ee 22 6c fe				ld (input_ptr),hl 
11f1					 
11f1			 
11f1 18 ca				jr .instr1 
11f3			 
11f3 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
11f5 20 06				jr nz, .instr3 
11f7 2b					dec hl 
11f8 22 6c fe				ld (input_ptr),hl 
11fb 18 c0				jr .instr1 
11fd				 
11fd fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
11ff 20 06				jr nz, .instr4 
1201 23					inc hl 
1202 22 6c fe				ld (input_ptr),hl 
1205 18 b6				jr .instr1 
1207			 
1207 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1209 20 06				jr nz, .instr5 
120b 2b					dec hl 
120c 22 6c fe				ld (input_ptr),hl 
120f 18 ac				jr .instr1 
1211			 
1211 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1213 20 06				jr nz, .instr6 
1215 2b					dec hl 
1216 22 6c fe				ld (input_ptr),hl 
1219 18 a2				jr .instr1 
121b fe 05		.instr6:        cp KEY_UP      ; recall last command 
121d 20 0b				jr nz, .instrnew 
121f			 
121f 21 c8 f1			ld hl, scratch 
1222 11 ee f5			ld de, os_last_cmd 
1225 cd 43 12			call strcpy 
1228 18 93				jr .instr1 
122a			 
122a			 
122a			.instrnew:	; no special key pressed to see if we have room to store it 
122a			 
122a					; TODO do string size test 
122a			 
122a 2b					dec hl ; to over write cursor 
122b 77					ld (hl),a 
122c 23					inc hl 
122d 3a c7 fb				ld a,(cursor_shape) 
1230 77					ld (hl),a 
1231 23					inc hl 
1232 3e 00				ld a,0 
1234 77					ld (hl),a 
1235			 
1235 22 6c fe				ld (input_ptr),hl 
1238					 
1238 18 83				jr .instr1 
123a 2b			.instrcr:	dec hl		; remove cursor 
123b 3e 20				ld a,' '	; TODO add a trailing space for safety 
123d 77					ld (hl),a 
123e 23					inc hl 
123f 3e 00				ld a,0 
1241 77					ld (hl),a 
1242			 
1242			 
1242					; if at end of line scroll up    
1242					; TODO detecting only end of line 4 for scroll up  
1242			 
1242					;ld   
1242			 
1242 c9					ret 
1243			 
1243			 
1243			; strcpy hl = dest, de source 
1243			 
1243 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1244 b7			            OR   A              ;Null terminator? 
1245 c8			            RET  Z              ;Yes, so finished 
1246 1a					ld a,(de) 
1247 77					ld (hl),a 
1248 13			            INC  DE             ;Point to next character 
1249 23					inc hl 
124a 18 f7		            JR   strcpy       ;Repeat 
124c c9					ret 
124d			 
124d			 
124d			; TODO string_at  
124d			; pass string which starts with lcd offset address and then null term string 
124d			 
124d			; TODO string to dec 
124d			; TODO string to hex 
124d			; TODO byte to string hex 
124d			; TODO byte to string dec 
124d			 
124d			 
124d			 
124d			; from z80uartmonitor 
124d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124d			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
124d			; pass hl for where to put the text 
124d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
124d c5			hexout:	PUSH BC 
124e f5					PUSH AF 
124f 47					LD B, A 
1250					; Upper nybble 
1250 cb 3f				SRL A 
1252 cb 3f				SRL A 
1254 cb 3f				SRL A 
1256 cb 3f				SRL A 
1258 cd 68 12				CALL tohex 
125b 77					ld (hl),a 
125c 23					inc hl	 
125d					 
125d					; Lower nybble 
125d 78					LD A, B 
125e e6 0f				AND 0FH 
1260 cd 68 12				CALL tohex 
1263 77					ld (hl),a 
1264 23					inc hl	 
1265					 
1265 f1					POP AF 
1266 c1					POP BC 
1267 c9					RET 
1268					 
1268			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1268			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1268			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1268			tohex: 
1268 e5					PUSH HL 
1269 d5					PUSH DE 
126a 16 00				LD D, 0 
126c 5f					LD E, A 
126d 21 75 12				LD HL, .DATA 
1270 19					ADD HL, DE 
1271 7e					LD A, (HL) 
1272 d1					POP DE 
1273 e1					POP HL 
1274 c9					RET 
1275			 
1275			.DATA: 
1275 30					DEFB	30h	; 0 
1276 31					DEFB	31h	; 1 
1277 32					DEFB	32h	; 2 
1278 33					DEFB	33h	; 3 
1279 34					DEFB	34h	; 4 
127a 35					DEFB	35h	; 5 
127b 36					DEFB	36h	; 6 
127c 37					DEFB	37h	; 7 
127d 38					DEFB	38h	; 8 
127e 39					DEFB	39h	; 9 
127f 41					DEFB	41h	; A 
1280 42					DEFB	42h	; B 
1281 43					DEFB	43h	; C 
1282 44					DEFB	44h	; D 
1283 45					DEFB	45h	; E 
1284 46					DEFB	46h	; F 
1285			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1285			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1285			;;    subtract $30, if result > 9 then subtract $7 more 
1285			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1285			atohex: 
1285 d6 30				SUB $30 
1287 fe 0a				CP 10 
1289 f8					RET M		; If result negative it was 0-9 so we're done 
128a d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
128c c9					RET		 
128d			 
128d			 
128d			 
128d			 
128d			; Get 2 ASCII characters as hex byte from pointer in hl 
128d			 
128d			BYTERD: 
128d 16 00			LD	D,00h		;Set up 
128f cd 97 12			CALL	HEXCON		;Get byte and convert to hex 
1292 87				ADD	A,A		;First nibble so 
1293 87				ADD	A,A		;multiply by 16 
1294 87				ADD	A,A		; 
1295 87				ADD	A,A		; 
1296 57				LD	D,A		;Save hi nibble in D 
1297			HEXCON: 
1297 7e				ld a, (hl)		;Get next chr 
1298 23				inc hl 
1299 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
129b fe 0a			CP	00Ah		;Is it 0-9 ? 
129d 38 02			JR	C,NALPHA	;If so miss next bit 
129f d6 07			SUB	007h		;Else convert alpha 
12a1			NALPHA: 
12a1 b2				OR	D		;Add hi nibble back 
12a2 c9				RET			; 
12a3			 
12a3			 
12a3			; 
12a3			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
12a3			; Since the routines get_byte and therefore get_nibble are called, only valid 
12a3			; characters (0-9a-f) are accepted. 
12a3			; 
12a3			;get_word        push    af 
12a3			;                call    get_byte        ; Get the upper byte 
12a3			;                ld      h, a 
12a3			;                call    get_byte        ; Get the lower byte 
12a3			;                ld      l, a 
12a3			;                pop     af 
12a3			;                ret 
12a3			; 
12a3			; Get a byte in hexadecimal notation. The result is returned in A. Since 
12a3			; the routine get_nibble is used only valid characters are accepted - the  
12a3			; input routine only accepts characters 0-9a-f. 
12a3			; 
12a3 c5			get_byte:        push    bc              ; Save contents of B (and C) 
12a4 7e					ld a,(hl) 
12a5 23					inc hl 
12a6 cd cb 12		                call    nibble2val      ; Get upper nibble 
12a9 cb 07		                rlc     a 
12ab cb 07		                rlc     a 
12ad cb 07		                rlc     a 
12af cb 07		                rlc     a 
12b1 47			                ld      b, a            ; Save upper four bits 
12b2 7e					ld a,(hl) 
12b3 cd cb 12		                call    nibble2val      ; Get lower nibble 
12b6 b0			                or      b               ; Combine both nibbles 
12b7 c1			                pop     bc              ; Restore B (and C) 
12b8 c9			                ret 
12b9			; 
12b9			; Get a hexadecimal digit from the serial line. This routine blocks until 
12b9			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
12b9			; to the serial line interface. The lower 4 bits of A contain the value of  
12b9			; that particular digit. 
12b9			; 
12b9			;get_nibble      ld a,(hl)           ; Read a character 
12b9			;                call    to_upper        ; Convert to upper case 
12b9			;                call    is_hex          ; Was it a hex digit? 
12b9			;                jr      nc, get_nibble  ; No, get another character 
12b9			 ;               call    nibble2val      ; Convert nibble to value 
12b9			 ;               call    print_nibble 
12b9			 ;               ret 
12b9			; 
12b9			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
12b9			; A valid hexadecimal digit is denoted by a set C flag. 
12b9			; 
12b9			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
12b9			;                ret     nc              ; Yes 
12b9			;                cp      '0'             ; Less than '0'? 
12b9			;                jr      nc, is_hex_1    ; No, continue 
12b9			;                ccf                     ; Complement carry (i.e. clear it) 
12b9			;                ret 
12b9			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
12b9			;                ret     c               ; Yes 
12b9			;                cp      'A'             ; Less than 'A'? 
12b9			;                jr      nc, is_hex_2    ; No, continue 
12b9			;                ccf                     ; Yes - clear carry and return 
12b9			;                ret 
12b9			;is_hex_2        scf                     ; Set carry 
12b9			;                ret 
12b9			; 
12b9			; Convert a single character contained in A to upper case: 
12b9			; 
12b9 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
12bb d8			                ret     c 
12bc fe 7b		                cp      'z' + 1         ; > 'z'? 
12be d0			                ret     nc              ; Nothing to do, either 
12bf e6 5f		                and     $5f             ; Convert to upper case 
12c1 c9			                ret 
12c2			 
12c2			 
12c2			to_lower: 
12c2			 
12c2			   ; if char is in [A-Z] make it lower case 
12c2			 
12c2			   ; enter : a = char 
12c2			   ; exit  : a = lower case char 
12c2			   ; uses  : af 
12c2			 
12c2 fe 41		   cp 'A' 
12c4 d8			   ret c 
12c5			    
12c5 fe 5b		   cp 'Z'+1 
12c7 d0			   ret nc 
12c8			    
12c8 f6 20		   or $20 
12ca c9			   ret 
12cb			 
12cb			; 
12cb			; Expects a hexadecimal digit (upper case!) in A and returns the 
12cb			; corresponding value in A. 
12cb			; 
12cb fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
12cd 38 02		                jr      c, nibble2val_1 ; Yes 
12cf d6 07		                sub     7               ; Adjust for A-F 
12d1 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
12d3 e6 0f		                and     $f              ; Only return lower 4 bits 
12d5 c9			                ret 
12d6			; 
12d6			; Print_nibble prints a single hex nibble which is contained in the lower  
12d6			; four bits of A: 
12d6			; 
12d6			;print_nibble    push    af              ; We won't destroy the contents of A 
12d6			;                and     $f              ; Just in case... 
12d6			;                add     a, '0'             ; If we have a digit we are done here. 
12d6			;                cp      '9' + 1         ; Is the result > 9? 
12d6			;                jr      c, print_nibble_1 
12d6			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
12d6			;print_nibble_1  call    putc            ; Print the nibble and 
12d6			;                pop     af              ; restore the original value of A 
12d6			;                ret 
12d6			;; 
12d6			;; Send a CR/LF pair: 
12d6			; 
12d6			;crlf            push    af 
12d6			;                ld      a, cr 
12d6			;                call    putc 
12d6			;                ld      a, lf 
12d6			;                call    putc 
12d6			;                pop     af 
12d6			;                ret 
12d6			; 
12d6			; Print_word prints the four hex digits of a word to the serial line. The  
12d6			; word is expected to be in HL. 
12d6			; 
12d6			;print_word      push    hl 
12d6			;                push    af 
12d6			;                ld      a, h 
12d6			;                call    print_byte 
12d6			;                ld      a, l 
12d6			;                call    print_byte 
12d6			;                pop     af 
12d6			;                pop     hl 
12d6			;                ret 
12d6			; 
12d6			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
12d6			; The byte to be printed is expected to be in A. 
12d6			; 
12d6			;print_byte      push    af              ; Save the contents of the registers 
12d6			;                push    bc 
12d6			;                ld      b, a 
12d6			;                rrca 
12d6			;                rrca 
12d6			;                rrca 
12d6			;                rrca 
12d6			;                call    print_nibble    ; Print high nibble 
12d6			;                ld      a, b 
12d6			;                call    print_nibble    ; Print low nibble 
12d6			;                pop     bc              ; Restore original register contents 
12d6			;                pop     af 
12d6			;                ret 
12d6			 
12d6			 
12d6			 
12d6			 
12d6			 
12d6			fourehexhl:  
12d6 7e				ld a,(hl) 
12d7 cd 85 12			call atohex 
12da cb 3f				SRL A 
12dc cb 3f				SRL A 
12de cb 3f				SRL A 
12e0 cb 3f				SRL A 
12e2 47				ld b, a 
12e3 23				inc hl 
12e4 7e				ld a,(hl) 
12e5 23				inc hl 
12e6 cd 85 12			call atohex 
12e9 80				add b 
12ea 57				ld d,a 
12eb 7e				ld a,(hl) 
12ec cd 85 12			call atohex 
12ef cb 3f				SRL A 
12f1 cb 3f				SRL A 
12f3 cb 3f				SRL A 
12f5 cb 3f				SRL A 
12f7 47				ld b, a 
12f8 23				inc hl 
12f9 7e				ld a,(hl) 
12fa 23				inc hl 
12fb cd 85 12			call atohex 
12fe 80				add b 
12ff 5f				ld e, a 
1300 d5				push de 
1301 e1				pop hl 
1302 c9				ret 
1303			 
1303			; pass hl. returns z set if the byte at hl is a digit 
1303			;isdigithl:  
1303			;	push bc 
1303			;	ld a,(hl) 
1303			;	cp ':' 
1303			;	jr nc, .isdf 		; > 
1303			;	cp '0' 
1303			;	jr c, .isdf		; < 
1303			; 
1303			;	; TODO find a better way to set z 
1303			; 
1303			;	ld b,a 
1303			;	cp b 
1303			;	pop bc 
1303			;	ret 
1303			; 
1303			;.isdf:	; not digit so clear z 
1303			; 
1303			;	; TODO find a better way to unset z 
1303			; 
1303			;	ld b,a 
1303			;	inc b 
1303			;	cp b 
1303			; 
1303			;	pop bc 
1303			;	ret 
1303				 
1303				 
1303			 
1303			 
1303			; pass hl as the four byte address to load 
1303			 
1303			get_word_hl:  
1303 e5				push hl 
1304 cd a3 12			call get_byte 
1307				 
1307 47				ld b, a 
1308			 
1308 e1				pop hl 
1309 23				inc hl 
130a 23				inc hl 
130b			 
130b			; TODO not able to handle a-f  
130b 7e				ld a,(hl) 
130c			;	;cp ':' 
130c			;	cp 'g' 
130c			;	jr nc, .single_byte_hl 		; > 
130c			;	cp 'G' 
130c			;	jr nc, .single_byte_hl 		; > 
130c			;	cp '0' 
130c			;	jr c, .single_byte_hl		; < 
130c			 
130c				;call isdigithl 
130c fe 00			cp 0 
130e 28 06			jr z, .single_byte_hl 
1310			 
1310			.getwhln:   ; hex word so get next byte 
1310			 
1310 cd a3 12			call get_byte 
1313 6f				ld l, a 
1314 60				ld h,b 
1315 c9				ret 
1316 68			.single_byte_hl:   ld l,b 
1317 26 00				ld h,0 
1319 c9					ret 
131a			 
131a			 
131a			 
131a			 
131a 21 7e 1c			ld hl,asc+1 
131d			;	ld a, (hl) 
131d			;	call nibble2val 
131d cd a3 12			call get_byte 
1320			 
1320			;	call fourehexhl 
1320 32 fc f1			ld (scratch+52),a 
1323				 
1323 21 fa f1			ld hl,scratch+50 
1326 22 eb f4			ld (os_cur_ptr),hl 
1329			 
1329 c9				ret 
132a			 
132a			 
132a			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
132a			 
132a			; Decimal Unsigned Version 
132a			 
132a			;Number in a to decimal ASCII 
132a			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
132a			;Example: display a=56 as "056" 
132a			;input: a = number 
132a			;Output: a=0,value of a in the screen 
132a			;destroys af,bc (don't know about hl and de) 
132a			DispAToASCII: 
132a 0e 9c			ld	c,-100 
132c cd 36 13			call	.Na1 
132f 0e f6			ld	c,-10 
1331 cd 36 13			call	.Na1 
1334 0e ff			ld	c,-1 
1336 06 2f		.Na1:	ld	b,'0'-1 
1338 04			.Na2:	inc	b 
1339 81				add	a,c 
133a 38 fc			jr	c,.Na2 
133c 91				sub	c		;works as add 100/10/1 
133d f5				push af		;safer than ld c,a 
133e 78				ld	a,b		;char is in b 
133f			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
133f f1				pop af		;safer than ld a,c 
1340 c9				ret 
1341			 
1341			; Decimal Signed Version 
1341			 
1341			; DispA 
1341			; -------------------------------------------------------------- 
1341			; Converts a signed integer value to a zero-terminated ASCII 
1341			; string representative of that value (using radix 10). 
1341			; -------------------------------------------------------------- 
1341			; INPUTS: 
1341			;     HL     Value to convert (two's complement integer). 
1341			;     DE     Base address of string destination. (pointer). 
1341			; -------------------------------------------------------------- 
1341			; OUTPUTS: 
1341			;     None 
1341			; -------------------------------------------------------------- 
1341			; REGISTERS/MEMORY DESTROYED 
1341			; AF HL 
1341			; -------------------------------------------------------------- 
1341			 
1341			;DispHLToASCII: 
1341			;   push    de 
1341			;   push    bc 
1341			; 
1341			;; Detect sign of HL. 
1341			;    bit    7, h 
1341			;    jr     z, ._DoConvert 
1341			; 
1341			;; HL is negative. Output '-' to string and negate HL. 
1341			;    ld     a, '-' 
1341			;    ld     (de), a 
1341			;    inc    de 
1341			; 
1341			;; Negate HL (using two's complement) 
1341			;    xor    a 
1341			;    sub    l 
1341			;    ld     l, a 
1341			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1341			;    sbc    a, h 
1341			;    ld     h, a 
1341			; 
1341			;; Convert HL to digit characters 
1341			;._DoConvert: 
1341			;    ld     b, 0     ; B will count character length of number 
1341			;-   ld     a, 10 
1341			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1341			;    push   af 
1341			;    inc    b 
1341			;    ld     a, h 
1341			;    or     l 
1341			;    jr     nz, - 
1341			; 
1341			;; Retrieve digits from stack 
1341			;-   pop    af 
1341			;    or     $30 
1341			;    ld     (de), a 
1341			;    inc    de 
1341			;    djnz   - 
1341			; 
1341			;; Terminate string with NULL 
1341			;    xor    a 
1341			;    ld     (de), a 
1341			; 
1341			;    pop    bc 
1341			;    pop    de 
1341			;    ret 
1341			 
1341			;Comments 
1341			; 
1341			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1341			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1341			;    Note that the output string will not be fixed-width. 
1341			; 
1341			;Example Usage 
1341			; 
1341			;    ld    hl, -1004 
1341			;    ld    de, OP1 
1341			;    call  DispA 
1341			;    ld    hl, OP1 
1341			;    syscall  PutS 
1341			 
1341			 
1341			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1341			 
1341			 
1341			;Converts an ASCII string to an unsigned 16-bit integer 
1341			;Quits when it reaches a non-decimal digit 
1341			 
1341			string_to_uint16: 
1341			atoui_16: 
1341			;Input: 
1341			;     DE points to the string 
1341			;Outputs: 
1341			;     HL is the result 
1341			;     A is the 8-bit value of the number 
1341			;     DE points to the byte after the number 
1341			;Destroys: 
1341			;     BC 
1341			;       if the string is non-empty, BC is HL/10 
1341			;Size:  24 bytes 
1341			;Speed: 42+d(104+{0,9}) 
1341			;       d is the number of digits in the number 
1341			;       max is 640 cycles for a 5 digit number 
1341			;Assuming no leading zeros: 
1341			;1 digit:  146cc 
1341			;2 digit:  250cc 
1341			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1341			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1341			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1341			;avg: 544.81158447265625cc (544+13297/16384) 
1341			;=============================================================== 
1341 21 00 00		  ld hl,0 
1344			.u16a: 
1344 1a			  ld a,(de) 
1345 d6 30		  sub 30h 
1347 fe 0a		  cp 10 
1349 d0			  ret nc 
134a 13			  inc de 
134b 44			  ld b,h 
134c 4d			  ld c,l 
134d 29			  add hl,hl 
134e 29			  add hl,hl 
134f 09			  add hl,bc 
1350 29			  add hl,hl 
1351 85			  add a,l 
1352 6f			  ld l,a 
1353 30 ef		  jr nc,.u16a 
1355 24			  inc h 
1356 c3 44 13		  jp .u16a 
1359			 
1359			 
1359			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1359			 
1359			;written by Zeda 
1359			;Converts a 16-bit unsigned integer to an ASCII string. 
1359			 
1359			uitoa_16: 
1359			;Input: 
1359			;   DE is the number to convert 
1359			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1359			;Output: 
1359			;   HL points to the null-terminated ASCII string 
1359			;      NOTE: This isn't necessarily the same as the input HL. 
1359 d5			  push de 
135a c5			  push bc 
135b f5			  push af 
135c eb			  ex de,hl 
135d			 
135d 01 f0 d8		  ld bc,-10000 
1360 3e 2f		  ld a,'0'-1 
1362 3c			  inc a 
1363 09			  add hl,bc  
1364 38 fc		   jr c,$-2 
1366 12			  ld (de),a 
1367 13			  inc de 
1368			 
1368 01 e8 03		  ld bc,1000 
136b 3e 3a		  ld a,'9'+1 
136d 3d			  dec a  
136e 09			  add hl,bc  
136f 30 fc		   jr nc,$-2 
1371 12			  ld (de),a 
1372 13			  inc de 
1373			 
1373 01 9c ff		  ld bc,-100 
1376 3e 2f		  ld a,'0'-1 
1378 3c			  inc a  
1379 09			  add hl,bc  
137a 38 fc		   jr c,$-2 
137c 12			  ld (de),a 
137d 13			  inc de 
137e			 
137e 7d			  ld a,l 
137f 26 3a		  ld h,'9'+1 
1381 25			  dec h  
1382 c6 0a		  add a,10  
1384 30 fb		   jr nc,$-3 
1386 c6 30		  add a,'0' 
1388 eb			  ex de,hl 
1389 72			  ld (hl),d 
138a 23			  inc hl 
138b 77			  ld (hl),a 
138c 23			  inc hl 
138d 36 00		  ld (hl),0 
138f			 
138f			;Now strip the leading zeros 
138f 0e fa		  ld c,-6 
1391 09			  add hl,bc 
1392 3e 30		  ld a,'0' 
1394 23			  inc hl  
1395 be			  cp (hl)  
1396 28 fc		  jr z,$-2 
1398			 
1398			;Make sure that the string is non-empty! 
1398 7e			  ld a,(hl) 
1399 b7			  or a 
139a 20 01		  jr nz,.atoub 
139c 2b			  dec hl 
139d			.atoub: 
139d			 
139d f1			  pop af 
139e c1			  pop bc 
139f d1			  pop de 
13a0 c9			  ret 
13a1			 
13a1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
13a1			 
13a1			toUpper: 
13a1			;A is the char. 
13a1			;If A is a lowercase letter, this sets it to the matching uppercase 
13a1			;18cc or 30cc or 41cc 
13a1			;avg: 26.75cc 
13a1 fe 61		  cp 'a' 
13a3 d8			  ret c 
13a4 fe 7b		  cp 'z'+1 
13a6 d0			  ret nc 
13a7 d6 20		  sub 'a'-'A' 
13a9 c9			  ret 
13aa			 
13aa			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
13aa			 
13aa			; String Length 
13aa			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
13aa			 
13aa			; Get the length of the null-terminated string starting at $8000 hl 
13aa			;    LD     HL, $8000 
13aa			 
13aa			strlenz: 
13aa			 
13aa af			    XOR    A               ; Zero is the value we are looking for. 
13ab 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
13ac 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
13ad			                           ; 65, 536 bytes (the entire addressable memory space). 
13ad ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13af			 
13af			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13af 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
13b0 6f			    LD     L, A             ; number of bytes 
13b1 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13b3 2b			    DEC    HL              ; Compensate for null. 
13b4 c9				ret 
13b5			 
13b5			; Get the length of the A terminated string starting at $8000 hl 
13b5			;    LD     HL, $8000 
13b5			 
13b5			strlent: 
13b5			 
13b5			                  ; A is the value we are looking for. 
13b5 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
13b7 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
13b9			                           ; 65, 536 bytes (the entire addressable memory space). 
13b9 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13bb			 
13bb			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13bb 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
13bd 2e 00		    LD     L, 0             ; number of bytes 
13bf ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13c1 2b			    DEC    HL              ; Compensate for null. 
13c2 c9				ret 
13c3			 
13c3			 
13c3			;Comparing Strings 
13c3			 
13c3			;IN    HL     Address of string1. 
13c3			;      DE     Address of string2. 
13c3			 
13c3			; doc given but wrong??? 
13c3			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
13c3			;      carry  Set if string1 > string2, reset if string1 <= string2. 
13c3			; tested 
13c3			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
13c3			 
13c3			strcmp_old: 
13c3 e5			    PUSH   HL 
13c4 d5			    PUSH   DE 
13c5			 
13c5 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
13c6 be			    CP     (HL)            ; (want to minimize work). 
13c7 38 01		    JR     C, Str1IsBigger 
13c9 7e			    LD     A, (HL) 
13ca			 
13ca			Str1IsBigger: 
13ca 4f			    LD     C, A             ; Put length in BC 
13cb 06 00		    LD     B, 0 
13cd 13			    INC    DE              ; Increment pointers to meat of string. 
13ce 23			    INC    HL 
13cf			 
13cf			CmpLoop: 
13cf 1a			    LD     A, (DE)          ; Compare bytes. 
13d0 ed a1		    CPI 
13d2 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
13d4 13			    INC    DE              ; Update pointer. 
13d5 ea cf 13		    JP     PE, CmpLoop 
13d8			 
13d8 d1			    POP    DE 
13d9 e1			    POP    HL 
13da 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
13db be			    CP     (HL) 
13dc c9			    RET 
13dd			 
13dd			NoMatch: 
13dd 2b			    DEC    HL 
13de be			    CP     (HL)            ; Compare again to affect carry. 
13df d1			    POP    DE 
13e0 e1			    POP    HL 
13e1 c9			    RET 
13e2			 
13e2			;; test strmp 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str2 
13e2			;call strcmp 
13e2			;jr z, .z1 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "NZ1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.z1: 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "ZZ1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str1 
13e2			;call strcmp 
13e2			;jr z, .z2 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "NZ2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.z2: 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "ZZ2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str2 
13e2			;call strcmp 
13e2			;jr c, .c1 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "Nc1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.c1: 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "cc1" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			; 
13e2			;ld de, .str1 
13e2			;ld hl, .str1 
13e2			;call strcmp 
13e2			;jr c, .c2 
13e2			;;this 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "Nc2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;.c2: 
13e2			; 
13e2			;	if DEBUG_FORTH_WORDS 
13e2			;		DMARK "cc2" 
13e2			;		CALLMONITOR 
13e2			;	endif 
13e2			;	NEXTW 
13e2			;.str1:   db "string1",0 
13e2			;.str2:   db "string2",0 
13e2			 
13e2			; only care about direct match or not 
13e2			; hl and de strings 
13e2			; zero set if the same 
13e2			 
13e2			strcmp: 
13e2 1a				ld a, (de) 
13e3 be				cp (hl) 
13e4 28 02			jr z, .ssame 
13e6 b7				or a 
13e7 c9				ret 
13e8			 
13e8			.ssame:  
13e8 fe 00			cp 0 
13ea c8				ret z 
13eb			 
13eb 23				inc hl 
13ec 13				inc de 
13ed 18 f3			jr strcmp 
13ef				 
13ef				 
13ef			 
13ef			 
13ef			 
13ef			 
13ef			; eof 
13ef			 
13ef			 
13ef			 
13ef			 
13ef			 
13ef			 
# End of file firmware_strings.asm
13ef			include "firmware_memory.asm"   ; malloc and free  
13ef			 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef			.mallocsize: db "Wants malloc >256",0 
13ef			.mallocasize: db "MALLOC gives >256",0 
13ef			.malloczero: db "MALLOC gives zero",0 
13ef			 
13ef			malloc_guard_zerolen: 
13ef				push hl 
13ef				push de 
13ef				push af 
13ef			 
13ef				ld de, 0 
13ef			        call cmp16 
13ef				jr nz, .lowalloz 
13ef			 
13ef				push hl 
13ef				push de 
13ef					ld hl, display_fb0 
13ef					ld (display_fb_active), hl 
13ef				call clear_display 
13ef				ld a, 0 
13ef				ld de, .malloczero 
13ef				call str_at_display 
13ef				call update_display 
13ef				call delay1s 
13ef				call delay1s 
13ef				ld a, 0 
13ef				ld (os_view_disable), a 
13ef			 
13ef				pop de 
13ef				pop hl 
13ef			 
13ef				 
13ef			 
13ef				CALLMONITOR 
13ef			.lowalloz: 
13ef			 
13ef			 
13ef				pop af 
13ef				pop de 
13ef				pop hl 
13ef			ret 
13ef			 
13ef			malloc_guard_entry: 
13ef				push hl 
13ef				push de 
13ef				push af 
13ef			 
13ef			 	or a      ;clear carry flag 
13ef				push hl 
13ef				ld de, 255 
13ef				sbc hl, de 
13ef				jr c, .lowalloc 
13ef			 
13ef				push de 
13ef					ld hl, display_fb0 
13ef					ld (display_fb_active), hl 
13ef				call clear_display 
13ef				ld a, 0 
13ef				ld de, .mallocsize 
13ef				call str_at_display 
13ef				call update_display 
13ef				call delay1s 
13ef				call delay1s 
13ef				ld a, 0 
13ef				ld (os_view_disable), a 
13ef			 
13ef				pop de 
13ef				pop hl 
13ef			 
13ef				 
13ef			 
13ef				CALLMONITOR 
13ef				jr .lowdone 
13ef			.lowalloc: 
13ef			 
13ef			 
13ef				pop hl 
13ef			.lowdone:	pop af 
13ef				pop de 
13ef				pop hl 
13ef			ret 
13ef			 
13ef			malloc_guard_exit: 
13ef				push hl 
13ef				push de 
13ef				push af 
13ef			 
13ef			 	or a      ;clear carry flag 
13ef				push hl 
13ef				ld de, 255 
13ef				sbc hl, de 
13ef				jr c, .lowallocx 
13ef			 
13ef				push de 
13ef					ld hl, display_fb0 
13ef					ld (display_fb_active), hl 
13ef				call clear_display 
13ef				ld a, 0 
13ef				ld de, .mallocasize 
13ef				call str_at_display 
13ef				call update_display 
13ef				call delay1s 
13ef				call delay1s 
13ef				ld a, 0 
13ef				ld (os_view_disable), a 
13ef				pop de 
13ef				pop hl 
13ef			 
13ef				CALLMONITOR 
13ef				jr .lowdonex 
13ef			.lowallocx: 
13ef			 
13ef				pop hl 
13ef			.lowdonex:	pop af 
13ef				pop de 
13ef				pop hl 
13ef			ret 
13ef			endif 
13ef			 
13ef			if MALLOC_2 
13ef			; Z80 Malloc and Free Functions 
13ef			 
13ef			; Malloc Function: 
13ef			; Input: 
13ef			;   HL: Size of block to allocate 
13ef			; Output: 
13ef			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ef			 
13ef			malloc: 
13ef				 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef			call malloc_guard_entry 
13ef			endif 
13ef			 
13ef			 
13ef			 
13ef			 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "mal" 
13ef						CALLMONITOR 
13ef					endif 
13ef			    push af            ; Save AF register 
13ef			    ld a, l            ; Load low byte of size into A 
13ef			    or h               ; Check if size is zero 
13ef			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
13ef			 
13ef			    ; Allocate memory 
13ef			    ld hl, (heap_start) ; Load start of heap into HL 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "ma1" 
13ef						CALLMONITOR 
13ef					endif 
13ef			    call malloc_internal ; Call internal malloc function 
13ef			    pop af             ; Restore AF register 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret                ; Return 
13ef			 
13ef			; Free Function: 
13ef			; Input: 
13ef			;   HL: Pointer to memory block to free 
13ef			; Output: 
13ef			;   None 
13ef			 
13ef			free: 
13ef			    push af            ; Save AF register 
13ef			    ld a, l            ; Load low byte of pointer into A 
13ef			    or h               ; Check if pointer is NULL 
13ef			    jp z, free_exit    ; If pointer is NULL, exit 
13ef			 
13ef			    ; Free memory 
13ef			    ld hl, (heap_start) ; Load start of heap into HL 
13ef			    call free_internal  ; Call internal free function 
13ef			    pop af             ; Restore AF register 
13ef			    ret                ; Return 
13ef			 
13ef			; Internal Malloc Function: 
13ef			; Input: 
13ef			;   HL: Size of block to allocate 
13ef			; Output: 
13ef			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13ef			 
13ef			malloc_internal: 
13ef			    ld bc, 2           ; Number of bytes to allocate for management overhead 
13ef			    add hl, bc         ; Add management overhead to requested size 
13ef			    ex de, hl          ; Save total size in DE, and keep it in HL 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "ma2" 
13ef						CALLMONITOR 
13ef					endif 
13ef			 
13ef			    ; Search for free memory block 
13ef			    ld de, (heap_end)  ; Load end of heap into DE 
13ef			    ld bc, 0           ; Initialize counter 
13ef			 
13ef					if DEBUG_FORTH_MALLOC 
13ef						DMARK "ma2" 
13ef						CALLMONITOR 
13ef					endif 
13ef			malloc_search_loop: 
13ef			    ; Check if current block is free 
13ef			    ld a, (hl)         ; Load current block's status (free or used) 
13ef			    cp 0               ; Compare with zero (free) 
13ef			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
13ef			 
13ef			    ; Check if current block is large enough 
13ef			    ld a, (hl+1)       ; Load high byte of block size 
13ef			    cp l               ; Compare with low byte of requested size 
13ef			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
13ef			 
13ef			    ld a, (hl+2)       ; Load low byte of block size 
13ef			    cp h               ; Compare with high byte of requested size 
13ef			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
13ef			 
13ef			    ; Mark block as used 
13ef			    ld (hl), 0xFF      ; Set status byte to indicate used block 
13ef			 
13ef			    ; Calculate remaining space in block 
13ef			    ld bc, 0           ; Clear BC 
13ef			    add hl, bc         ; Increment HL to point to start of data block 
13ef			    add hl, de         ; HL = HL + DE (total size) 
13ef			    ld bc, 1           ; Number of bytes to allocate for management overhead 
13ef			    add hl, bc         ; Add management overhead to start of data block 
13ef			 
13ef			    ; Save pointer to allocated block in HL 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef						DMARK "ma5" 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret 
13ef			 
13ef			malloc_skip_block_check: 
13ef			    ; Move to the next block 
13ef			    ld bc, 3           ; Size of management overhead 
13ef			    add hl, bc         ; Move to the next block 
13ef			    inc de             ; Increment counter 
13ef			 
13ef			    ; Check if we have reached the end of heap 
13ef			    ld a, e            ; Load low byte of heap end address 
13ef			    cp (hl)            ; Compare with low byte of current address 
13ef			    jr nz, malloc_search_loop  ; If not equal, continue searching 
13ef			    ld a, d            ; Load high byte of heap end address 
13ef			    cp 0               ; Check if it's zero (end of memory) 
13ef			    jr nz, malloc_search_loop  ; If not zero, continue searching 
13ef			 
13ef			    ; If we reached here, allocation failed 
13ef			    xor a              ; Set result to NULL 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef						DMARK "ma6" 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret 
13ef			malloc_exit: 
13ef			if DEBUG_FORTH_MALLOC_HIGH 
13ef						DMARK "ma7" 
13ef			call malloc_guard_exit 
13ef			call malloc_guard_zerolen 
13ef			endif 
13ef			    ret 
13ef			 
13ef			; Internal Free Function: 
13ef			; Input: 
13ef			;   HL: Pointer to memory block to free 
13ef			; Output: 
13ef			;   None 
13ef			 
13ef			free_internal: 
13ef			    ld de, (heap_start) ; Load start of heap into DE 
13ef			    ld bc, 0            ; Initialize counter 
13ef			 
13ef			free_search_loop: 
13ef			    ; Check if current block contains the pointer 
13ef			    ld a, l             ; Load low byte of pointer 
13ef			    cp (hl+1)           ; Compare with high byte of current block's address 
13ef			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ef			    ld a, h             ; Load high byte of pointer 
13ef			    cp (hl+2)           ; Compare with low byte of current block's address 
13ef			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13ef			 
13ef			    ; Mark block as free 
13ef			    ld (hl), 0          ; Set status byte to indicate free block 
13ef			    ret                 ; Return 
13ef			 
13ef			free_skip_block_check: 
13ef			    ; Move to the next block 
13ef			    ld bc, 3            ; Size of management overhead 
13ef			    add hl, bc          ; Move to the next block 
13ef			    inc de              ; Increment counter 
13ef			 
13ef			    ; Check if we have reached the end of heap 
13ef			    ld a, e             ; Load low byte of heap end address 
13ef			    cp (hl)             ; Compare with low byte of current address 
13ef			    jr nz, free_search_loop  ; If not equal, continue searching 
13ef			    ld a, d             ; Load high byte of heap end address 
13ef			    cp 0                ; Check if it's zero (end of memory) 
13ef			    jr nz, free_search_loop  ; If not zero, continue searching 
13ef			 
13ef			    ; If we reached here, pointer is not found in heap 
13ef			    ret 
13ef			 
13ef			free_exit: 
13ef			    ret                 ; Return 
13ef			 
13ef			; Define heap start and end addresses 
13ef			;heap_start:    .dw 0xC000   ; Start of heap 
13ef			;heap_end:      .dw 0xE000   ; End of heap 
13ef			 
13ef			endif 
13ef			 
13ef			 
13ef			if MALLOC_1 
13ef			 
13ef			 
13ef			 
13ef			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
13ef			 
13ef			;moved to firmware.asm 
13ef			;heap_start        .equ  0x9000      ; Starting address of heap 
13ef			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
13ef			 
13ef			;      .org 0 
13ef			;      jp    main 
13ef			 
13ef			 
13ef			;      .org  0x100 
13ef			;main: 
13ef			;      ld    HL, 0x8100 
13ef			;      ld    SP, HL 
13ef			; 
13ef			;      call  heap_init 
13ef			; 
13ef			;      ; Make some allocations 
13ef			;      ld    HL, 12 
13ef			;      call  malloc            ; Allocates 0x9004 
13ef			; 
13ef			;      ld    HL, 12 
13ef			;      call  malloc            ; Allocates 0x9014 
13ef			; 
13ef			;      ld    HL, 12 
13ef			;      call  malloc            ; Allocates 0x9024 
13ef			; 
13ef			;      ; Free some allocations 
13ef			;      ld    HL, 0x9014 
13ef			;      call  free 
13ef			; 
13ef			;      ld    HL, 0x9004 
13ef			;      call  free 
13ef			; 
13ef			;      ld    HL, 0x9024 
13ef			;      call  free 
13ef			; 
13ef			; 
13ef			;      halt 
13ef			 
13ef			 
13ef			;------------------------------------------------------------------------------ 
13ef			;     heap_init                                                               : 
13ef			;                                                                             : 
13ef			; Description                                                                 : 
13ef			;     Initialise the heap and make it ready for malloc and free operations.   : 
13ef			;                                                                             : 
13ef			;     The heap is maintained as a linked list, starting with an initial       : 
13ef			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
13ef			;     the first free block in the heap. Each block then points to the next    : 
13ef			;     free block within the heap, and the free list ends at the first block   : 
13ef			;     with a null pointer to the next free block.                             : 
13ef			;                                                                             : 
13ef			; Parameters                                                                  : 
13ef			;     Inputs are compile-time only. Two defines which specify the starting    : 
13ef			;     address of the heap and its size are required, along with a memory      : 
13ef			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
13ef			;     principally stores a pointer to the first free block in the heap.       : 
13ef			;                                                                             : 
13ef			; Returns                                                                     : 
13ef			;     Nothing                                                                 : 
13ef			;------------------------------------------------------------------------------ 
13ef			heap_init: 
13ef e5			      push  HL 
13f0			 
13f0			      ; Initialise free list struct 
13f0 21 0e 80		      ld    HL, heap_start 
13f3 22 0a 80		      ld    (free_list), HL 
13f6 21 00 00		      ld    HL, 0 
13f9 22 0c 80		      ld    (free_list+2), HL 
13fc			 
13fc			      ; Insert first free block at bottom of heap, consumes entire heap 
13fc 21 aa f1		      ld    HL, heap_start+heap_size-4 
13ff 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1402 21 9c 71		      ld    HL, heap_size-4 
1405 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1408			 
1408			      ; Insert end of free list block at top of heap - two null words will 
1408			      ; terminate the free list 
1408 21 00 00		      ld    HL, 0 
140b 22 ac f1		      ld    (heap_start+heap_size-2), HL 
140e 22 aa f1		      ld    (heap_start+heap_size-4), HL 
1411			 
1411 e1			      pop   HL 
1412			 
1412 c9			      ret 
1413			 
1413			 
1413			;------------------------------------------------------------------------------ 
1413			;     malloc                                                                  : 
1413			;                                                                             : 
1413			; Description                                                                 : 
1413			;     Allocates the wanted space from the heap and returns the address of the : 
1413			;     first useable byte of the allocation.                                   : 
1413			;                                                                             : 
1413			;     Allocations can happen in one of two ways:                              : 
1413			;                                                                             : 
1413			;     1. A free block may be found which is the exact size wanted. In this    : 
1413			;        case the block is removed from the free list and retuedn to the      : 
1413			;        caller.                                                              : 
1413			;     2. A free block may be found which is larger than the size wanted. In   : 
1413			;        this case, the larger block is split into two. The first portion of  : 
1413			;        this block will become the requested space by the malloc call and    : 
1413			;        is returned to the caller. The second portion becomes a new free     : 
1413			;        block, and the free list is adjusted to maintain continuity via this : 
1413			;        newly created block.                                                 : 
1413			;                                                                             : 
1413			;     malloc does not set any initial value in the allocated space, the       : 
1413			;     caller is required to do this as required.                              : 
1413			;                                                                             : 
1413			;     This implementation of malloc uses the stack exclusively, and is        : 
1413			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1413			;     advisable to disable interrupts before calling malloc, and recommended  : 
1413			;     to avoid the use of malloc inside ISRs in general.                      : 
1413			;                                                                             : 
1413			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1413			;                                                                             : 
1413			; Parameters                                                                  : 
1413			;     HL  Number of bytes wanted                                              : 
1413			;                                                                             : 
1413			; Returns                                                                     : 
1413			;     HL  Address of the first useable byte of the allocation                 : 
1413			;                                                                             : 
1413			; Flags                                                                       : 
1413			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1413			;                                                                             : 
1413			; Stack frame                                                                 : 
1413			;       |             |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |     BC      |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |     DE      |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |     IX      |                                                       : 
1413			;       +-------------+                                                       : 
1413			;       |  prev_free  |                                                       : 
1413			;   +4  +-------------+                                                       : 
1413			;       |  this_free  |                                                       : 
1413			;   +2  +-------------+                                                       : 
1413			;       |  next_free  |                                                       : 
1413			;   +0  +-------------+                                                       : 
1413			;       |             |                                                       : 
1413			;                                                                             : 
1413			;------------------------------------------------------------------------------ 
1413			 
1413			 
1413			;malloc: 
1413			; 
1413			;	SAVESP ON 1 
1413			; 
1413			;	call malloc_code 
1413			; 
1413			;	CHECKSP ON 1 
1413			;	ret 
1413			 
1413			 
1413			malloc: 
1413 c5			      push  BC 
1414 d5			      push  DE 
1415 dd e5		      push  IX 
1417			if DEBUG_FORTH_MALLOC_HIGH 
1417			call malloc_guard_entry 
1417			endif 
1417			 
1417					if DEBUG_FORTH_MALLOC 
1417						DMARK "mal" 
1417						CALLMONITOR 
1417					endif 
1417 7c			      ld    A, H                    ; Exit if no space requested 
1418 b5			      or    L 
1419 ca d8 14		      jp    Z, malloc_early_exit 
141c			 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			; 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			;inc hl 
141c			 
141c			 
141c			 
141c			 
141c					if DEBUG_FORTH_MALLOC 
141c						DMARK "maA" 
141c						CALLMONITOR 
141c					endif 
141c			      ; Set up stack frame 
141c eb			      ex    DE, HL 
141d 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1420 39			      add   HL, SP 
1421 f9			      ld    SP, HL 
1422 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1426 dd 39		      add   IX, SP 
1428			 
1428			      ; Setup initial state 
1428 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
142b 19			      add   HL, DE 
142c			 
142c 44			      ld    B, H                    ; Move want to BC 
142d 4d			      ld    C, L 
142e			 
142e 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
1431 dd 75 04		      ld    (IX+4), L 
1434 dd 74 05		      ld    (IX+5), H 
1437			 
1437 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1438 23			      inc   HL 
1439 56			      ld    D, (HL) 
143a dd 73 02		      ld    (IX+2), E 
143d dd 72 03		      ld    (IX+3), D 
1440 eb			      ex    DE, HL                  ; this_free ptr into HL 
1441			 
1441					if DEBUG_FORTH_MALLOC 
1441						DMARK "maB" 
1441						CALLMONITOR 
1441					endif 
1441			      ; Loop through free block list to find some space 
1441			malloc_find_space: 
1441 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1442 23			      inc   HL 
1443 56			      ld    D, (HL) 
1444			 
1444 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1445 b3			      or    E 
1446 ca d2 14		      jp    Z, malloc_no_space 
1449			 
1449 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
144c dd 72 01		      ld    (IX+1), D 
144f			 
144f			      ; Does this block have enough space to make the allocation? 
144f 23			      inc   HL                      ; Load free block size into DE 
1450 5e			      ld    E, (HL) 
1451 23			      inc   HL 
1452 56			      ld    D, (HL) 
1453			 
1453 eb			      ex    DE, HL                  ; Check size of block against want 
1454 b7			      or    A                       ; Ensure carry flag clear 
1455 ed 42		      sbc   HL, BC 
1457 e5			      push  HL                      ; Store the result for later (new block size) 
1458			 
1458 ca a7 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
145b 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
145d			 
145d			      ; this_free block is not big enough, setup ptrs to test next free block 
145d e1			      pop   HL                      ; Discard previous result 
145e			 
145e dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1461 dd 66 03		      ld    H, (IX+3) 
1464 dd 75 04		      ld    (IX+4), L 
1467 dd 74 05		      ld    (IX+5), H 
146a			 
146a dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
146d dd 66 01		      ld    H, (IX+1) 
1470 dd 75 02		      ld    (IX+2), L 
1473 dd 74 03		      ld    (IX+3), H 
1476			 
1476					if DEBUG_FORTH_MALLOC 
1476						DMARK "MA>" 
1476						CALLMONITOR 
1476					endif 
1476 18 c9		      jr    malloc_find_space 
1478			 
1478			      ; split a bigger block into two - requested size and remaining size 
1478			malloc_alloc_split: 
1478					if DEBUG_FORTH_MALLOC 
1478						DMARK "MAs" 
1478						CALLMONITOR 
1478					endif 
1478 eb			      ex    DE, HL                  ; Calculate address of new free block 
1479 2b			      dec   HL 
147a 2b			      dec   HL 
147b 2b			      dec   HL 
147c 09			      add   HL, BC 
147d			 
147d			      ; Create a new block and point it at next_free 
147d dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1480 dd 56 01		      ld    D, (IX+1) 
1483			 
1483 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1484 23			      inc   HL 
1485 72			      ld    (HL), D 
1486			 
1486 d1			      pop   DE                      ; Store size of new block into new block 
1487 23			      inc   HL 
1488 73			      ld    (HL), E 
1489 23			      inc   HL 
148a 72			      ld    (HL), D 
148b			 
148b			      ; Update this_free ptr to point to new block 
148b 2b			      dec   HL 
148c 2b			      dec   HL 
148d 2b			      dec   HL 
148e			 
148e dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1491 dd 56 03		      ld    D, (IX+3) 
1494			 
1494 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1497 dd 74 03		      ld    (IX+3), H 
149a			 
149a			      ; Modify this_free block to be allocation 
149a eb			      ex    DE, HL 
149b af			      xor   A                       ; Null the next block ptr of allocated block 
149c 77			      ld    (HL), A 
149d 23			      inc   HL 
149e 77			      ld    (HL), A 
149f			 
149f 23			      inc   HL                      ; Store want size into allocated block 
14a0 71			      ld    (HL), C 
14a1 23			      inc   HL 
14a2 70			      ld    (HL), B 
14a3 23			      inc   HL 
14a4 e5			      push  HL                      ; Address of allocation to return 
14a5			 
14a5 18 19		      jr    malloc_update_links 
14a7			 
14a7			malloc_alloc_fit: 
14a7 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
14a8			 
14a8					if DEBUG_FORTH_MALLOC 
14a8						DMARK "MAf" 
14a8						CALLMONITOR 
14a8					endif 
14a8			      ; Modify this_free block to be allocation 
14a8 eb			      ex    DE, HL 
14a9 2b			      dec   HL 
14aa 2b			      dec   HL 
14ab 2b			      dec   HL 
14ac			 
14ac af			      xor   A                       ; Null the next block ptr of allocated block 
14ad 77			      ld    (HL), A 
14ae 23			      inc   HL 
14af 77			      ld    (HL), A 
14b0			 
14b0 23			      inc   HL                      ; Store address of allocation to return 
14b1 23			      inc   HL 
14b2 23			      inc   HL 
14b3 e5			      push  HL 
14b4			 
14b4			      ; Copy next_free ptr to this_free, remove allocated block from free list 
14b4 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
14b7 dd 66 01		      ld    H, (IX+1) 
14ba			 
14ba dd 75 02		      ld    (IX+2), L               ; HL to this_free 
14bd dd 74 03		      ld    (IX+3), H 
14c0			 
14c0			 
14c0			malloc_update_links: 
14c0			      ; Update prev_free ptr to point to this_free 
14c0 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
14c3 dd 66 05		      ld    H, (IX+5) 
14c6			 
14c6 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
14c9 dd 56 03		      ld    D, (IX+3) 
14cc			 
14cc 73			      ld    (HL), E                 ; this_free ptr into prev_free 
14cd 23			      inc   HL 
14ce 72			      ld    (HL), D 
14cf			 
14cf					if DEBUG_FORTH_MALLOC 
14cf						DMARK "Mul" 
14cf						CALLMONITOR 
14cf					endif 
14cf			      ; Clear the Z flag to indicate successful allocation 
14cf 7a			      ld    A, D 
14d0 b3			      or    E 
14d1			 
14d1 d1			      pop   DE                      ; Address of allocation 
14d2					if DEBUG_FORTH_MALLOC 
14d2						DMARK "MAu" 
14d2						CALLMONITOR 
14d2					endif 
14d2			 
14d2			malloc_no_space: 
14d2 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
14d5 39			      add   HL, SP 
14d6 f9			      ld    SP, HL 
14d7			 
14d7 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
14d8					if DEBUG_FORTH_MALLOC 
14d8						DMARK "MAN" 
14d8						CALLMONITOR 
14d8					endif 
14d8			 
14d8			malloc_early_exit: 
14d8					if DEBUG_FORTH_MALLOC 
14d8						DMARK "MAx" 
14d8						CALLMONITOR 
14d8					endif 
14d8 dd e1		      pop   IX 
14da d1			      pop   DE 
14db c1			      pop   BC 
14dc			 
14dc			if DEBUG_FORTH_MALLOC_HIGH 
14dc			call malloc_guard_exit 
14dc			call malloc_guard_zerolen 
14dc			endif 
14dc c9			      ret 
14dd			 
14dd			 
14dd			;------------------------------------------------------------------------------ 
14dd			;     free                                                                    : 
14dd			;                                                                             : 
14dd			; Description                                                                 : 
14dd			;     Return the space pointed to by HL to the heap. HL must be an address as : 
14dd			;     returned by malloc, otherwise the behaviour is undefined.               : 
14dd			;                                                                             : 
14dd			;     Where possible, directly adjacent free blocks will be merged together   : 
14dd			;     into larger blocks to help ensure that the heap does not become         : 
14dd			;     excessively fragmented.                                                 : 
14dd			;                                                                             : 
14dd			;     free does not clear or set any other value into the freed space, and    : 
14dd			;     therefore its contents may be visible through subsequent malloc's. The  : 
14dd			;     caller should clear the freed space as required.                        : 
14dd			;                                                                             : 
14dd			;     This implementation of free uses the stack exclusively, and is          : 
14dd			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
14dd			;     advisable to disable interrupts before calling free, and recommended    : 
14dd			;     to avoid the use of free inside ISRs in general.                        : 
14dd			;                                                                             : 
14dd			;     NOTE: heap_init must be called before malloc and free can be used.      : 
14dd			;                                                                             : 
14dd			; Parameters                                                                  : 
14dd			;     HL  Pointer to address of first byte of allocation to be freed          : 
14dd			;                                                                             : 
14dd			; Returns                                                                     : 
14dd			;     Nothing                                                                 : 
14dd			;                                                                             : 
14dd			; Stack frame                                                                 : 
14dd			;       |             |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |     BC      |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |     DE      |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |     IX      |                                                       : 
14dd			;       +-------------+                                                       : 
14dd			;       |  prev_free  |                                                       : 
14dd			;   +2  +-------------+                                                       : 
14dd			;       |  next_free  |                                                       : 
14dd			;   +0  +-------------+                                                       : 
14dd			;       |             |                                                       : 
14dd			;                                                                             : 
14dd			;------------------------------------------------------------------------------ 
14dd			free: 
14dd c5			      push  BC 
14de d5			      push  DE 
14df dd e5		      push  IX 
14e1			 
14e1 7c			      ld    A, H                    ; Exit if ptr is null 
14e2 b5			      or    L 
14e3 ca a7 15		      jp    Z, free_early_exit 
14e6			 
14e6			      ; Set up stack frame 
14e6 eb			      ex    DE, HL 
14e7 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
14ea 39			      add   HL, SP 
14eb f9			      ld    SP, HL 
14ec dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14f0 dd 39		      add   IX, SP 
14f2			 
14f2			      ; The address in HL points to the start of the useable allocated space, 
14f2			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
14f2			      ; address of the block itself. 
14f2 eb			      ex    DE, HL 
14f3 11 fc ff		      ld    DE, -4 
14f6 19			      add   HL, DE 
14f7			 
14f7			      ; An allocated block must have a null next block pointer in it 
14f7 7e			      ld    A, (HL) 
14f8 23			      inc   HL 
14f9 b6			      or    (HL) 
14fa c2 a2 15		      jp    NZ, free_done 
14fd			 
14fd 2b			      dec   HL 
14fe			 
14fe 44			      ld    B, H                    ; Copy HL to BC 
14ff 4d			      ld    C, L 
1500			 
1500			      ; Loop through the free list to find the first block with an address 
1500			      ; higher than the block being freed 
1500 21 0a 80		      ld    HL, free_list 
1503			 
1503			free_find_higher_block: 
1503 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1504 23			      inc   HL 
1505 56			      ld    D, (HL) 
1506 2b			      dec   HL 
1507			 
1507 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
150a dd 72 01		      ld    (IX+1), D 
150d dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1510 dd 74 03		      ld    (IX+3), H 
1513			 
1513 78			      ld    A, B                    ; Check if DE is greater than BC 
1514 ba			      cp    D                       ; Compare MSB first 
1515 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1517 30 04		      jr    NC, free_find_higher_block_skip 
1519 79			      ld    A, C 
151a bb			      cp    E                       ; Then compare LSB 
151b 38 08		      jr    C, free_found_higher_block 
151d			 
151d			free_find_higher_block_skip: 
151d 7a			      ld    A, D                    ; Reached the end of the free list? 
151e b3			      or    E 
151f ca a2 15		      jp    Z, free_done 
1522			 
1522 eb			      ex    DE, HL 
1523			 
1523 18 de		      jr    free_find_higher_block 
1525			 
1525			free_found_higher_block: 
1525			      ; Insert freed block between prev and next free blocks 
1525 71			      ld    (HL), C                 ; Point prev free block to freed block 
1526 23			      inc   HL 
1527 70			      ld    (HL), B 
1528			 
1528 60			      ld    H, B                    ; Point freed block at next free block 
1529 69			      ld    L, C 
152a 73			      ld    (HL), E 
152b 23			      inc   HL 
152c 72			      ld    (HL), D 
152d			 
152d			      ; Check if the freed block is adjacent to the next free block 
152d 23			      inc   HL                      ; Load size of freed block into HL 
152e 5e			      ld    E, (HL) 
152f 23			      inc   HL 
1530 56			      ld    D, (HL) 
1531 eb			      ex    DE, HL 
1532			 
1532 09			      add   HL, BC                  ; Add addr of freed block and its size 
1533			 
1533 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1536 dd 56 01		      ld    D, (IX+1) 
1539			 
1539 b7			      or    A                       ; Clear the carry flag 
153a ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
153c 20 22		      jr    NZ, free_check_adjacent_to_prev 
153e			 
153e			      ; Freed block is adjacent to next, merge into one bigger block 
153e eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
153f 5e			      ld    E, (HL) 
1540 23			      inc   HL 
1541 56			      ld    D, (HL) 
1542 e5			      push  HL                      ; Save ptr to next block for later 
1543			 
1543 60			      ld    H, B                    ; Store ptr from next block into freed block 
1544 69			      ld    L, C 
1545 73			      ld    (HL), E 
1546 23			      inc   HL 
1547 72			      ld    (HL), D 
1548			 
1548 e1			      pop   HL                      ; Restore ptr to next block 
1549 23			      inc   HL                      ; Load size of next block into DE 
154a 5e			      ld    E, (HL) 
154b 23			      inc   HL 
154c 56			      ld    D, (HL) 
154d d5			      push  DE                      ; Save next block size for later 
154e			 
154e 60			      ld    H, B                    ; Load size of freed block into HL 
154f 69			      ld    L, C 
1550 23			      inc   HL 
1551 23			      inc   HL 
1552 5e			      ld    E, (HL) 
1553 23			      inc   HL 
1554 56			      ld    D, (HL) 
1555 eb			      ex    DE, HL 
1556			 
1556 d1			      pop   DE                      ; Restore size of next block 
1557 19			      add   HL, DE                  ; Add sizes of both blocks 
1558 eb			      ex    DE, HL 
1559			 
1559 60			      ld    H, B                    ; Store new bigger size into freed block 
155a 69			      ld    L, C 
155b 23			      inc   HL 
155c 23			      inc   HL 
155d 73			      ld    (HL), E 
155e 23			      inc   HL 
155f 72			      ld    (HL), D 
1560			 
1560			free_check_adjacent_to_prev: 
1560			      ; Check if the freed block is adjacent to the prev free block 
1560 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1563 dd 66 03		      ld    H, (IX+3) 
1566			 
1566 23			      inc   HL                      ; Size of prev free block into DE 
1567 23			      inc   HL 
1568 5e			      ld    E, (HL) 
1569 23			      inc   HL 
156a 56			      ld    D, (HL) 
156b 2b			      dec   HL 
156c 2b			      dec   HL 
156d 2b			      dec   HL 
156e			 
156e 19			      add   HL, DE                  ; Add prev block addr and size 
156f			 
156f b7			      or    A                       ; Clear the carry flag 
1570 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1572 20 2e		      jr    NZ, free_done 
1574			 
1574			      ; Freed block is adjacent to prev, merge into one bigger block 
1574 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1575 69			      ld    L, C 
1576 5e			      ld    E, (HL) 
1577 23			      inc   HL 
1578 56			      ld    D, (HL) 
1579 e5			      push  HL                      ; Save freed block ptr for later 
157a			 
157a dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
157d dd 66 03		      ld    H, (IX+3) 
1580 73			      ld    (HL), E 
1581 23			      inc   HL 
1582 72			      ld    (HL), D 
1583			 
1583 e1			      pop   HL                      ; Restore freed block ptr 
1584 23			      inc   HL                      ; Load size of freed block into DE 
1585 5e			      ld    E, (HL) 
1586 23			      inc   HL 
1587 56			      ld    D, (HL) 
1588 d5			      push  DE                      ; Save freed block size for later 
1589			 
1589 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
158c dd 66 03		      ld    H, (IX+3) 
158f 23			      inc   HL 
1590 23			      inc   HL 
1591 5e			      ld    E, (HL) 
1592 23			      inc   HL 
1593 56			      ld    D, (HL) 
1594			 
1594 e1			      pop   HL                      ; Add sizes of both blocks 
1595 19			      add   HL, DE 
1596 eb			      ex    DE, HL 
1597			 
1597 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
159a dd 66 03		      ld    H, (IX+3) 
159d 23			      inc   HL 
159e 23			      inc   HL 
159f 73			      ld    (HL), E 
15a0 23			      inc   HL 
15a1 72			      ld    (HL), D 
15a2			 
15a2			free_done: 
15a2 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
15a5 39			      add   HL, SP 
15a6 f9			      ld    SP, HL 
15a7			 
15a7			free_early_exit: 
15a7 dd e1		      pop   IX 
15a9 d1			      pop   DE 
15aa c1			      pop   BC 
15ab			 
15ab c9			      ret 
15ac			 
15ac			; moved to firmware.asm 
15ac			; 
15ac			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15ac			;                  .dw   0 
15ac			 
15ac			 
15ac			endif 
15ac			 
15ac			 
15ac			if MALLOC_3 
15ac			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
15ac			;heap_start        .equ  0x9000      ; Starting address of heap 
15ac			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
15ac			; 
15ac			 ;     .org 0 
15ac			  ;    jp    main 
15ac			; 
15ac			; 
15ac			 ;     .org  0x100 
15ac			;main: 
15ac			 ;     ld    HL, 0x8100 
15ac			  ;    ld    SP, HL 
15ac			; 
15ac			;      call  heap_init 
15ac			 
15ac			      ; Make some allocations 
15ac			;      ld    HL, 12 
15ac			;      call  malloc            ; Allocates 0x9004 
15ac			; 
15ac			 ;     ld    HL, 12 
15ac			;      call  malloc            ; Allocates 0x9014 
15ac			 
15ac			;      ld    HL, 12 
15ac			;      call  malloc            ; Allocates 0x9024 
15ac			 
15ac			      ; Free some allocations 
15ac			;      ld    HL, 0x9014 
15ac			;      call  free 
15ac			 
15ac			;      ld    HL, 0x9004 
15ac			;      call  free 
15ac			; 
15ac			;      ld    HL, 0x9024 
15ac			;      call  free 
15ac			 
15ac			 
15ac			 ;     halt 
15ac			 
15ac			 
15ac			;------------------------------------------------------------------------------ 
15ac			;     heap_init                                                               : 
15ac			;                                                                             : 
15ac			; Description                                                                 : 
15ac			;     Initialise the heap and make it ready for malloc and free operations.   : 
15ac			;                                                                             : 
15ac			;     The heap is maintained as a linked list, starting with an initial       : 
15ac			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
15ac			;     the first free block in the heap. Each block then points to the next    : 
15ac			;     free block within the heap, and the free list ends at the first block   : 
15ac			;     with a null pointer to the next free block.                             : 
15ac			;                                                                             : 
15ac			; Parameters                                                                  : 
15ac			;     Inputs are compile-time only. Two defines which specify the starting    : 
15ac			;     address of the heap and its size are required, along with a memory      : 
15ac			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
15ac			;     principally stores a pointer to the first free block in the heap.       : 
15ac			;                                                                             : 
15ac			; Returns                                                                     : 
15ac			;     Nothing                                                                 : 
15ac			;------------------------------------------------------------------------------ 
15ac			heap_init: 
15ac			      push  HL 
15ac			 
15ac			      ; Initialise free list struct 
15ac			      ld    HL, heap_start 
15ac			      ld    (free_list), HL 
15ac			      ld    HL, 0 
15ac			      ld    (free_list+2), HL 
15ac			 
15ac			      ; Insert first free block at bottom of heap, consumes entire heap 
15ac			      ld    HL, heap_start+heap_size-4 
15ac			      ld    (heap_start), HL        ; Next block (end of free list) 
15ac			      ld    HL, heap_size-4 
15ac			      ld    (heap_start+2), HL      ; Block size 
15ac			 
15ac			      ; Insert end of free list block at top of heap - two null words will 
15ac			      ; terminate the free list 
15ac			      ld    HL, 0 
15ac			      ld    (heap_start+heap_size-2), HL 
15ac			      ld    (heap_start+heap_size-4), HL 
15ac			 
15ac			      pop   HL 
15ac			 
15ac			      ret 
15ac			 
15ac			 
15ac			;------------------------------------------------------------------------------ 
15ac			;     malloc                                                                  : 
15ac			;                                                                             : 
15ac			; Description                                                                 : 
15ac			;     Allocates the wanted space from the heap and returns the address of the : 
15ac			;     first useable byte of the allocation.                                   : 
15ac			;                                                                             : 
15ac			;     Allocations can happen in one of two ways:                              : 
15ac			;                                                                             : 
15ac			;     1. A free block may be found which is the exact size wanted. In this    : 
15ac			;        case the block is removed from the free list and retuedn to the      : 
15ac			;        caller.                                                              : 
15ac			;     2. A free block may be found which is larger than the size wanted. In   : 
15ac			;        this case, the larger block is split into two. The first portion of  : 
15ac			;        this block will become the requested space by the malloc call and    : 
15ac			;        is returned to the caller. The second portion becomes a new free     : 
15ac			;        block, and the free list is adjusted to maintain continuity via this : 
15ac			;        newly created block.                                                 : 
15ac			;                                                                             : 
15ac			;     malloc does not set any initial value in the allocated space, the       : 
15ac			;     caller is required to do this as required.                              : 
15ac			;                                                                             : 
15ac			;     This implementation of malloc uses the stack exclusively, and is        : 
15ac			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15ac			;     advisable to disable interrupts before calling malloc, and recommended  : 
15ac			;     to avoid the use of malloc inside ISRs in general.                      : 
15ac			;                                                                             : 
15ac			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15ac			;                                                                             : 
15ac			; Parameters                                                                  : 
15ac			;     HL  Number of bytes wanted                                              : 
15ac			;                                                                             : 
15ac			; Returns                                                                     : 
15ac			;     HL  Address of the first useable byte of the allocation                 : 
15ac			;                                                                             : 
15ac			; Flags                                                                       : 
15ac			;     Z   Set if the allocation did not succeed, clear otherwise              : 
15ac			;                                                                             : 
15ac			; Stack frame                                                                 : 
15ac			;       |             |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     BC      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     DE      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     IX      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |  prev_free  |                                                       : 
15ac			;   +4  +-------------+                                                       : 
15ac			;       |  this_free  |                                                       : 
15ac			;   +2  +-------------+                                                       : 
15ac			;       |  next_free  |                                                       : 
15ac			;   +0  +-------------+                                                       : 
15ac			;       |             |                                                       : 
15ac			;                                                                             : 
15ac			;------------------------------------------------------------------------------ 
15ac			malloc: 
15ac			      push  BC 
15ac			      push  DE 
15ac			      push  IX 
15ac			 
15ac			      ld    A, H                    ; Exit if no space requested 
15ac			      or    L 
15ac			      jp    Z, malloc_early_exit 
15ac			 
15ac			      ; Set up stack frame 
15ac			      ex    DE, HL 
15ac			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			      ld    IX, 0                   ; Use IX as a frame pointer 
15ac			      add   IX, SP 
15ac			 
15ac			      ; Setup initial state 
15ac			      ld    HL, 4                   ; want must also include space used by block struct 
15ac			      add   HL, DE 
15ac			 
15ac			      ld    B, H                    ; Move want to BC 
15ac			      ld    C, L 
15ac			 
15ac			      ld    HL, free_list           ; Store prev_free ptr to stack 
15ac			      ld    (IX+4), L 
15ac			      ld    (IX+5), H 
15ac			 
15ac			      ld    E, (HL)                 ; Store this_free ptr to stack 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      ld    (IX+2), E 
15ac			      ld    (IX+3), D 
15ac			      ex    DE, HL                  ; this_free ptr into HL 
15ac			 
15ac			      ; Loop through free block list to find some space 
15ac			malloc_find_space: 
15ac			      ld    E, (HL)                 ; Load next_free ptr into DE 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			 
15ac			      ld    A, D                    ; Check for null next_free ptr - end of free list 
15ac			      or    E 
15ac			      jp    Z, malloc_no_space 
15ac			 
15ac			      ld    (IX+0), E               ; Store next_free ptr to stack 
15ac			      ld    (IX+1), D 
15ac			 
15ac			      ; Does this block have enough space to make the allocation? 
15ac			      inc   HL                      ; Load free block size into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			 
15ac			      ex    DE, HL                  ; Check size of block against want 
15ac			      or    A                       ; Ensure carry flag clear 
15ac			      sbc   HL, BC 
15ac			      push  HL                      ; Store the result for later (new block size) 
15ac			 
15ac			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
15ac			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
15ac			 
15ac			      ; this_free block is not big enough, setup ptrs to test next free block 
15ac			      pop   HL                      ; Discard previous result 
15ac			 
15ac			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
15ac			      ld    H, (IX+3) 
15ac			      ld    (IX+4), L 
15ac			      ld    (IX+5), H 
15ac			 
15ac			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
15ac			      ld    H, (IX+1) 
15ac			      ld    (IX+2), L 
15ac			      ld    (IX+3), H 
15ac			 
15ac			      jr    malloc_find_space 
15ac			 
15ac			      ; split a bigger block into two - requested size and remaining size 
15ac			malloc_alloc_split: 
15ac			      ex    DE, HL                  ; Calculate address of new free block 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      add   HL, BC 
15ac			 
15ac			      ; Create a new block and point it at next_free 
15ac			      ld    E, (IX+0)               ; Load next_free ptr into DE 
15ac			      ld    D, (IX+1) 
15ac			 
15ac			      ld    (HL), E                 ; Store next_free ptr into new block 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      pop   DE                      ; Store size of new block into new block 
15ac			      inc   HL 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      ; Update this_free ptr to point to new block 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			 
15ac			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
15ac			      ld    D, (IX+3) 
15ac			 
15ac			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
15ac			      ld    (IX+3), H 
15ac			 
15ac			      ; Modify this_free block to be allocation 
15ac			      ex    DE, HL 
15ac			      xor   A                       ; Null the next block ptr of allocated block 
15ac			      ld    (HL), A 
15ac			      inc   HL 
15ac			      ld    (HL), A 
15ac			 
15ac			      inc   HL                      ; Store want size into allocated block 
15ac			      ld    (HL), C 
15ac			      inc   HL 
15ac			      ld    (HL), B 
15ac			      inc   HL 
15ac			      push  HL                      ; Address of allocation to return 
15ac			 
15ac			      jr    malloc_update_links 
15ac			 
15ac			malloc_alloc_fit: 
15ac			      pop   HL                      ; Dont need new block size, want is exact fit 
15ac			 
15ac			      ; Modify this_free block to be allocation 
15ac			      ex    DE, HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			 
15ac			      xor   A                       ; Null the next block ptr of allocated block 
15ac			      ld    (HL), A 
15ac			      inc   HL 
15ac			      ld    (HL), A 
15ac			 
15ac			      inc   HL                      ; Store address of allocation to return 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      push  HL 
15ac			 
15ac			      ; Copy next_free ptr to this_free, remove allocated block from free list 
15ac			      ld    L, (IX+0)               ; next_free to HL 
15ac			      ld    H, (IX+1) 
15ac			 
15ac			      ld    (IX+2), L               ; HL to this_free 
15ac			      ld    (IX+3), H 
15ac			 
15ac			 
15ac			malloc_update_links: 
15ac			      ; Update prev_free ptr to point to this_free 
15ac			      ld    L, (IX+4)               ; prev_free ptr to HL 
15ac			      ld    H, (IX+5) 
15ac			 
15ac			      ld    E, (IX+2)               ; this_free ptr to DE 
15ac			      ld    D, (IX+3) 
15ac			 
15ac			      ld    (HL), E                 ; this_free ptr into prev_free 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      ; Clear the Z flag to indicate successful allocation 
15ac			      ld    A, D 
15ac			      or    E 
15ac			 
15ac			      pop   DE                      ; Address of allocation 
15ac			 
15ac			malloc_no_space: 
15ac			      ld    HL, 6                   ; Clean up stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			 
15ac			      ex    DE, HL                  ; Alloc addr into HL for return 
15ac			 
15ac			malloc_early_exit: 
15ac			      pop   IX 
15ac			      pop   DE 
15ac			      pop   BC 
15ac			 
15ac			      ret 
15ac			 
15ac			 
15ac			;------------------------------------------------------------------------------ 
15ac			;     free                                                                    : 
15ac			;                                                                             : 
15ac			; Description                                                                 : 
15ac			;     Return the space pointed to by HL to the heap. HL must be an address as : 
15ac			;     returned by malloc, otherwise the behaviour is undefined.               : 
15ac			;                                                                             : 
15ac			;     Where possible, directly adjacent free blocks will be merged together   : 
15ac			;     into larger blocks to help ensure that the heap does not become         : 
15ac			;     excessively fragmented.                                                 : 
15ac			;                                                                             : 
15ac			;     free does not clear or set any other value into the freed space, and    : 
15ac			;     therefore its contents may be visible through subsequent malloc's. The  : 
15ac			;     caller should clear the freed space as required.                        : 
15ac			;                                                                             : 
15ac			;     This implementation of free uses the stack exclusively, and is          : 
15ac			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15ac			;     advisable to disable interrupts before calling free, and recommended    : 
15ac			;     to avoid the use of free inside ISRs in general.                        : 
15ac			;                                                                             : 
15ac			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15ac			;                                                                             : 
15ac			; Parameters                                                                  : 
15ac			;     HL  Pointer to address of first byte of allocation to be freed          : 
15ac			;                                                                             : 
15ac			; Returns                                                                     : 
15ac			;     Nothing                                                                 : 
15ac			;                                                                             : 
15ac			; Stack frame                                                                 : 
15ac			;       |             |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     BC      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     DE      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |     IX      |                                                       : 
15ac			;       +-------------+                                                       : 
15ac			;       |  prev_free  |                                                       : 
15ac			;   +2  +-------------+                                                       : 
15ac			;       |  next_free  |                                                       : 
15ac			;   +0  +-------------+                                                       : 
15ac			;       |             |                                                       : 
15ac			;                                                                             : 
15ac			;------------------------------------------------------------------------------ 
15ac			free: 
15ac			      push  BC 
15ac			      push  DE 
15ac			      push  IX 
15ac			 
15ac			      ld    A, H                    ; Exit if ptr is null 
15ac			      or    L 
15ac			      jp    Z, free_early_exit 
15ac			 
15ac			      ; Set up stack frame 
15ac			      ex    DE, HL 
15ac			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			      ld    IX, 0                   ; Use IX as a frame pointer 
15ac			      add   IX, SP 
15ac			 
15ac			      ; The address in HL points to the start of the useable allocated space, 
15ac			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
15ac			      ; address of the block itself. 
15ac			      ex    DE, HL 
15ac			      ld    DE, -4 
15ac			      add   HL, DE 
15ac			 
15ac			      ; An allocated block must have a null next block pointer in it 
15ac			      ld    A, (HL) 
15ac			      inc   HL 
15ac			      or    (HL) 
15ac			      jp    NZ, free_done 
15ac			 
15ac			      dec   HL 
15ac			 
15ac			      ld    B, H                    ; Copy HL to BC 
15ac			      ld    C, L 
15ac			 
15ac			      ; Loop through the free list to find the first block with an address 
15ac			      ; higher than the block being freed 
15ac			      ld    HL, free_list 
15ac			 
15ac			free_find_higher_block: 
15ac			      ld    E, (HL)                 ; Load next ptr from free block 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      dec   HL 
15ac			 
15ac			      ld    (IX+0), E               ; Save ptr to next free block 
15ac			      ld    (IX+1), D 
15ac			      ld    (IX+2), L               ; Save ptr to prev free block 
15ac			      ld    (IX+3), H 
15ac			 
15ac			      ld    A, B                    ; Check if DE is greater than BC 
15ac			      cp    D                       ; Compare MSB first 
15ac			      jr    Z, $+4                  ; MSB the same, compare LSB 
15ac			      jr    NC, free_find_higher_block_skip 
15ac			      ld    A, C 
15ac			      cp    E                       ; Then compare LSB 
15ac			      jr    C, free_found_higher_block 
15ac			 
15ac			free_find_higher_block_skip: 
15ac			      ld    A, D                    ; Reached the end of the free list? 
15ac			      or    E 
15ac			      jp    Z, free_done 
15ac			 
15ac			      ex    DE, HL 
15ac			 
15ac			      jr    free_find_higher_block 
15ac			 
15ac			free_found_higher_block: 
15ac			      ; Insert freed block between prev and next free blocks 
15ac			      ld    (HL), C                 ; Point prev free block to freed block 
15ac			      inc   HL 
15ac			      ld    (HL), B 
15ac			 
15ac			      ld    H, B                    ; Point freed block at next free block 
15ac			      ld    L, C 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      ; Check if the freed block is adjacent to the next free block 
15ac			      inc   HL                      ; Load size of freed block into HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      ex    DE, HL 
15ac			 
15ac			      add   HL, BC                  ; Add addr of freed block and its size 
15ac			 
15ac			      ld    E, (IX+0)               ; Load addr of next free block into DE 
15ac			      ld    D, (IX+1) 
15ac			 
15ac			      or    A                       ; Clear the carry flag 
15ac			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15ac			      jr    NZ, free_check_adjacent_to_prev 
15ac			 
15ac			      ; Freed block is adjacent to next, merge into one bigger block 
15ac			      ex    DE, HL                  ; Load next ptr from next block into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  HL                      ; Save ptr to next block for later 
15ac			 
15ac			      ld    H, B                    ; Store ptr from next block into freed block 
15ac			      ld    L, C 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      pop   HL                      ; Restore ptr to next block 
15ac			      inc   HL                      ; Load size of next block into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  DE                      ; Save next block size for later 
15ac			 
15ac			      ld    H, B                    ; Load size of freed block into HL 
15ac			      ld    L, C 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      ex    DE, HL 
15ac			 
15ac			      pop   DE                      ; Restore size of next block 
15ac			      add   HL, DE                  ; Add sizes of both blocks 
15ac			      ex    DE, HL 
15ac			 
15ac			      ld    H, B                    ; Store new bigger size into freed block 
15ac			      ld    L, C 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			free_check_adjacent_to_prev: 
15ac			      ; Check if the freed block is adjacent to the prev free block 
15ac			      ld    L, (IX+2)               ; Prev free block ptr into HL 
15ac			      ld    H, (IX+3) 
15ac			 
15ac			      inc   HL                      ; Size of prev free block into DE 
15ac			      inc   HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			      dec   HL 
15ac			 
15ac			      add   HL, DE                  ; Add prev block addr and size 
15ac			 
15ac			      or    A                       ; Clear the carry flag 
15ac			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15ac			      jr    NZ, free_done 
15ac			 
15ac			      ; Freed block is adjacent to prev, merge into one bigger block 
15ac			      ld    H, B                    ; Load next ptr from freed block into DE 
15ac			      ld    L, C 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  HL                      ; Save freed block ptr for later 
15ac			 
15ac			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
15ac			      ld    H, (IX+3) 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			      pop   HL                      ; Restore freed block ptr 
15ac			      inc   HL                      ; Load size of freed block into DE 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			      push  DE                      ; Save freed block size for later 
15ac			 
15ac			      ld    L, (IX+2)               ; Load size of prev block into DE 
15ac			      ld    H, (IX+3) 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    E, (HL) 
15ac			      inc   HL 
15ac			      ld    D, (HL) 
15ac			 
15ac			      pop   HL                      ; Add sizes of both blocks 
15ac			      add   HL, DE 
15ac			      ex    DE, HL 
15ac			 
15ac			      ld    L, (IX+2)               ; Store new bigger size into prev block 
15ac			      ld    H, (IX+3) 
15ac			      inc   HL 
15ac			      inc   HL 
15ac			      ld    (HL), E 
15ac			      inc   HL 
15ac			      ld    (HL), D 
15ac			 
15ac			free_done: 
15ac			      ld    HL, 4                   ; Clean up stack frame 
15ac			      add   HL, SP 
15ac			      ld    SP, HL 
15ac			 
15ac			free_early_exit: 
15ac			      pop   IX 
15ac			      pop   DE 
15ac			      pop   BC 
15ac			 
15ac			      ret 
15ac			 
15ac			 
15ac			;      .org 0x8000 
15ac			; 
15ac			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15ac			 ;                 .dw   0 
15ac			 
15ac			endif 
15ac			 
15ac			 
15ac			if MALLOC_4 
15ac			 
15ac			; My memory allocation code. Very very simple.... 
15ac			; allocate space under 250 chars 
15ac			 
15ac			heap_init: 
15ac				; init start of heap as zero 
15ac				;  
15ac			 
15ac				ld hl, heap_start 
15ac				ld a, 0 
15ac				ld (hl), a      ; empty block 
15ac				inc hl 
15ac				ld a, 0 
15ac				ld (hl), a      ; length of block 
15ac				; write end of list 
15ac				inc hl 
15ac				ld a,(hl) 
15ac				inc hl 
15ac				ld a,(hl) 
15ac				 
15ac			 
15ac				; init some malloc vars 
15ac			 
15ac				ld hl, 0 
15ac				ld (free_list), hl       ; store last malloc location 
15ac			 
15ac				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
15ac				ld a, 0 
15ac				ld (hl), a 
15ac			 
15ac			 
15ac				ld hl, heap_start 
15ac				;  
15ac				  
15ac				ret 
15ac			 
15ac			 
15ac			;    free block marker 
15ac			;    requested size  
15ac			;    pointer to next block 
15ac			;    .... 
15ac			;    next block marker 
15ac			 
15ac			 
15ac			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
15ac			; 
15ac			 
15ac			 
15ac			malloc:  
15ac				push de 
15ac				push bc 
15ac				push af 
15ac			 
15ac				; hl space required 
15ac				 
15ac				ld c, l    ; hold space   (TODO only a max of 255) 
15ac			 
15ac			;	inc c     ; TODO BUG need to fix memory leak on push str 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			;	inc c 
15ac			 
15ac			 
15ac			 
15ac				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
15ac			 
15ac				ld a, (free_list+3) 
15ac				cp 0 
15ac				jr z, .contheap 
15ac			 
15ac				ld hl, (free_list)     ; get last alloc 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mrs" 
15ac						CALLMONITOR 
15ac					endif 
15ac				jr .startalloc 
15ac			 
15ac			.contheap: 
15ac				ld hl, heap_start 
15ac			 
15ac			.startalloc: 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mym" 
15ac						CALLMONITOR 
15ac					endif 
15ac			.findblock: 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mmf" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac				ld a,(hl)  
15ac				; if byte is zero then clear to use 
15ac			 
15ac				cp 0 
15ac				jr z, .foundemptyblock 
15ac			 
15ac				; if byte is not clear 
15ac				;     then byte is offset to next block 
15ac			 
15ac				inc hl 
15ac				ld a, (hl) ; get size 
15ac			.nextblock:	inc hl 
15ac					ld e, (hl) 
15ac					inc hl 
15ac					ld d, (hl) 
15ac					ex de, hl 
15ac			;	inc hl  ; move past the store space 
15ac			;	inc hl  ; move past zero index  
15ac			 
15ac				; TODO detect no more space 
15ac			 
15ac				push hl 
15ac				ld de, heap_end 
15ac				call cmp16 
15ac				pop hl 
15ac				jr nc, .nospace 
15ac			 
15ac				jr .findblock 
15ac			 
15ac			.nospace: ld hl, 0 
15ac				jp .exit 
15ac			 
15ac			 
15ac			.foundemptyblock:	 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mme" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			; TODO has block enough space if reusing??? 
15ac			 
15ac				;  
15ac			 
15ac			; see if this block has been previously used 
15ac				inc hl 
15ac				ld a, (hl) 
15ac				dec hl 
15ac				cp 0 
15ac				jr z, .newblock 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "meR" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			; no reusing previously allocated block 
15ac			 
15ac			; is it smaller than previously used? 
15ac				 
15ac				inc hl    ; move to size 
15ac				ld a, c 
15ac				sub (hl)        ; we want c < (hl) 
15ac				dec hl    ; move back to marker 
15ac			        jr z, .findblock 
15ac			 
15ac				; update with the new size which should be lower 
15ac			 
15ac			        ;inc  hl   ; negate next move. move back to size  
15ac			 
15ac			.newblock: 
15ac				; need to be at marker here 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "meN" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			 
15ac				ld a, c 
15ac			 
15ac				ld (free_list+3), a	 ; flag resume from last malloc  
15ac				ld (free_list), hl    ; save out last location 
15ac			 
15ac			 
15ac				;inc a     ; space for length byte 
15ac				ld (hl), a     ; save block in use marker 
15ac			 
15ac				inc hl   ; move to space marker 
15ac				ld (hl), a    ; save new space 
15ac			 
15ac				inc hl   ; move to start of allocated area 
15ac				 
15ac			;	push hl     ; save where we are - 1  
15ac			 
15ac			;	inc hl  ; move past zero index  
15ac				; skip space to set down new marker 
15ac			 
15ac				; provide some extra space for now 
15ac			 
15ac				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
15ac				inc a 
15ac				inc a 
15ac			 
15ac				push hl   ; save where we are in the node block 
15ac			 
15ac				call addatohl 
15ac			 
15ac				; write linked list point 
15ac			 
15ac				pop de     ; get our node position 
15ac				ex de, hl 
15ac			 
15ac				ld (hl), e 
15ac				inc hl 
15ac				ld (hl), d 
15ac			 
15ac				inc hl 
15ac			 
15ac				; now at start of allocated data so save pointer 
15ac			 
15ac				push hl 
15ac			 
15ac				; jump to position of next node and setup empty header in DE 
15ac			 
15ac				ex de, hl 
15ac			 
15ac			;	inc hl ; move past end of block 
15ac			 
15ac				ld a, 0 
15ac				ld (hl), a   ; empty marker 
15ac				inc hl 
15ac				ld (hl), a   ; size 
15ac				inc hl  
15ac				ld (hl), a   ; ptr 
15ac				inc hl 
15ac				ld (hl), a   ; ptr 
15ac			 
15ac			 
15ac				pop hl 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "mmr" 
15ac						CALLMONITOR 
15ac					endif 
15ac			 
15ac			.exit: 
15ac				pop af 
15ac				pop bc 
15ac				pop de  
15ac				ret 
15ac			 
15ac			 
15ac			 
15ac			 
15ac			free:  
15ac				push hl 
15ac				push af 
15ac				; get address in hl 
15ac			 
15ac					if DEBUG_FORTH_MALLOC_INT 
15ac						DMARK "fre" 
15ac						CALLMONITOR 
15ac					endif 
15ac				; data is at hl - move to block count 
15ac				dec hl 
15ac				dec hl    ; get past pointer 
15ac				dec hl 
15ac			 
15ac				ld a, (hl)    ; need this for a validation check 
15ac			 
15ac				dec hl    ; move to block marker 
15ac			 
15ac				; now check that the block count and block marker are the same  
15ac			        ; this checks that we are on a malloc node and not random memory 
15ac			        ; OK a faint chance this could be a problem but rare - famous last words! 
15ac			 
15ac				ld c, a 
15ac				ld a, (hl)    
15ac			 
15ac				cp c 
15ac				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
15ac			 
15ac				; yes good chance we are on a malloc node 
15ac			 
15ac				ld a, 0      
15ac				ld (hl), a   ; mark as free 
15ac			 
15ac				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
15ac			 
15ac			.freeignore:  
15ac			 
15ac				pop af 
15ac				pop hl 
15ac			 
15ac				ret 
15ac			 
15ac			 
15ac			 
15ac			endif 
15ac			 
15ac			; eof 
# End of file firmware_memory.asm
15ac			  
15ac			; device C  
15ac			if SOUND_ENABLE  
15ac				include "firmware_sound.asm"  
15ac			; Sound abstraction layer 
15ac			 
15ac			; support different sound chips through common interface 
15ac			 
15ac			SOUND_DEVICE_AY: equ 0 
15ac			 
15ac			SOUND_DEVICE: equ Device_A 
15ac			 
15ac			 
15ac			 
15ac			if SOUND_DEVICE_AY 
15ac				include "firmware_sound_ay38910.asm" 
15ac			else 
15ac				include "firmware_sound_sn76489an.asm" 
15ac			 
15ac			; Device support for SN76489AN sound chip 
15ac			 
15ac			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
15ac			; http://danceswithferrets.org/geekblog/?p=93 
15ac			; https://www.smspower.org/Development/SN76489 
15ac			 
15ac			; D0 [ 3] 
15ac			; D1 [ 2] 
15ac			; D2 [ 1] 
15ac			; D3 [15] 
15ac			; D4 [13] 
15ac			; D5 [12] 
15ac			; D6 [11] 
15ac			; D7 [10] 
15ac			; /WE [ 5] 
15ac			; CLK [14] 
15ac			; /OE [ 6] 
15ac			; AUDIO [ 7] 
15ac			; GND 8 
15ac			; +5 16 
15ac			; 
15ac			 
15ac			; Write sequence: 
15ac			; CE low 
15ac			; Data bus 
15ac			; WE low then high 
15ac			; 32 clock cycles / 8ns write time at 4mhz 
15ac			; 
15ac			; https://github.com/jblang/SN76489 
15ac			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
15ac			; Tried: 
15ac			; 
15ac			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
15ac			; 
15ac			; Connected WE to OR too 
15ac			;  
15ac			; That enabled the clock when required 
15ac			; However still random bus corruption. Need further investigation 
15ac			 
15ac			 
15ac			SOUND_LATCH: equ 10000000B 
15ac			SOUND_DATA: equ 0B 
15ac			SOUND_CH0:  equ 0B    ; Tone 
15ac			SOUND_CH1: equ 0100000B        ; Tone 
15ac			SOUND_CH2: equ 1000000B   ; Tone 
15ac			SOUND_CH3: equ 1100000B    ; Noise 
15ac			SOUND_VOL: equ 10000B 
15ac			SOUND_TONE: equ 0B 
15ac			 
15ac			 
15ac			sound_init: 
15ac 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
15ae cd c3 15			call note_send_byte 
15b1 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
15b3 cd c3 15			call note_send_byte 
15b6 cd 89 0c			call delay250ms 
15b9 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
15bb cd c3 15			call note_send_byte 
15be cd 89 0c			call delay250ms 
15c1 c9				ret 
15c2			 
15c2			; Play a note 
15c2			; h = note 
15c2			; l = duration 
15c2			; a = channel 
15c2			 
15c2			 
15c2			;  frequ = clock / ( 2 x reg valu x 32 )  
15c2			 
15c2			note:  
15c2				 
15c2			 
15c2 c9				ret 
15c3			 
15c3			note_send_byte: 
15c3				; byte in a 
15c3			 
15c3				; we high 
15c3 d3 40			out (Device_B), a 
15c5			;	ld a, 1 
15c5			;	call aDelayInMS 
15c5 00				nop  
15c6 00				nop  
15c7 00				nop  
15c8 00				nop  
15c9				; we low 
15c9 d3 40			out (Device_B), a 
15cb			;	ld a, 1 
15cb			;	call aDelayInMS 
15cb 00				nop  
15cc 00				nop  
15cd 00				nop  
15ce 00				nop  
15cf				; we high 
15cf d3 40			out (Device_B), a 
15d1			;	ld a, 1 
15d1			;	call aDelayInMS 
15d1 00				nop  
15d2 00				nop  
15d3 00				nop  
15d4 00				nop  
15d5			 
15d5			 
15d5 c9				ret 
15d6			 
15d6			;void SilenceAllChannels() 
15d6			;{ 
15d6			;  SendByte(0x9f); 
15d6			;  SendByte(0xbf); 
15d6			;  SendByte(0xdf); 
15d6			;  SendByte(0xff); 
15d6			;} 
15d6			 
15d6			 
15d6			; eof 
15d6			 
# End of file firmware_sound_sn76489an.asm
15d6			endif 
15d6			 
15d6			 
15d6			; Abstraction entry points 
15d6			 
15d6			; init  
15d6			 
15d6			; sound_init in specific hardware files 
15d6			 
15d6			; Play a note 
15d6			; h = note 
15d6			; l = duration 
15d6			; a = channel 
15d6			 
15d6			;note:     
15d6			;	ret 
15d6			 
15d6			 
15d6			 
15d6			 
15d6			; eof 
15d6			 
# End of file firmware_sound.asm
15d6			endif  
15d6			  
15d6			include "firmware_diags.asm"  
15d6			; Hardware diags menu 
15d6			 
15d6			 
15d6			config: 
15d6			 
15d6 3e 00			ld a, 0 
15d8 21 06 16			ld hl, .configmn 
15db cd 49 0d			call menu 
15de			 
15de fe 00			cp 0 
15e0 c8				ret z 
15e1			 
15e1 fe 01			cp 1 
15e3 cc df 16			call z, .savetostore 
15e6			 
15e6 fe 02			cp 2 
15e8 cc 2d 16			call z, .selautoload 
15eb fe 03			cp 3 
15ed cc 16 16			call z, .disautoload 
15f0 fe 04			cp 4 
15f2 cc dd 16			call z, .selbank 
15f5 fe 05			cp 5 
15f7 cc ba 17			call z, .debug_tog 
15fa fe 06			cp 6 
15fc cc fd 18			call z, .bpsgo 
15ff fe 07			cp 7 
1601 cc e0 17			call z, hardware_diags 
1604			 
1604 18 d0			jr config 
1606			 
1606			.configmn: 
1606 ee 1a			dw prom_c3 
1608 05 1b			dw prom_c2 
160a 1a 1b			dw prom_c2a 
160c 30 1b			dw prom_c2b 
160e			;	dw prom_c4 
160e 4d 1b			dw prom_m4 
1610 68 1b			dw prom_m4b 
1612 70 1b			dw prom_c1 
1614 00 00			dw 0 
1616				 
1616			 
1616			 
1616			 
1616			.disautoload: 
1616				if STORAGE_SE 
1616 3e fe			ld a, $fe      ; bit 0 clear 
1618 32 67 fa			ld (spi_device), a 
161b			 
161b cd cd 04			call storage_get_block_0 
161e			 
161e 3e 00			ld a, 0 
1620 32 a2 fa			ld (store_page+STORE_0_AUTOFILE), a 
1623			 
1623 21 00 00				ld hl, 0 
1626 11 81 fa				ld de, store_page 
1629 cd 81 04			call storage_write_block	 ; save update 
162c				else 
162c			 
162c				ld hl, prom_notav 
162c				ld de, prom_empty 
162c				call info_panel 
162c				endif 
162c			 
162c			 
162c c9				ret 
162d			 
162d			 
162d			 
162d			; Select auto start 
162d			 
162d			.selautoload: 
162d			 
162d				 
162d				if STORAGE_SE 
162d			 
162d cd 04 17				call config_dir 
1630 21 c8 f1			        ld hl, scratch 
1633 3e 00				ld a, 0 
1635 cd 49 0d				call menu 
1638			 
1638 fe 00				cp 0 
163a c8					ret z 
163b			 
163b 3d					dec a 
163c			 
163c			 
163c					; locate menu option 
163c			 
163c 21 c8 f1				ld hl, scratch 
163f cd 6d 0c				call table_lookup 
1642			 
1642					if DEBUG_FORTH_WORDS 
1642						DMARK "ALl" 
1642 f5				push af  
1643 3a 57 16			ld a, (.dmark)  
1646 32 6e fe			ld (debug_mark),a  
1649 3a 58 16			ld a, (.dmark+1)  
164c 32 6f fe			ld (debug_mark+1),a  
164f 3a 59 16			ld a, (.dmark+2)  
1652 32 70 fe			ld (debug_mark+2),a  
1655 18 03			jr .pastdmark  
1657 ..			.dmark: db "ALl"  
165a f1			.pastdmark: pop af  
165b			endm  
# End of macro DMARK
165b						CALLMONITOR 
165b cd f3 18			call break_point_state  
165e				endm  
# End of macro CALLMONITOR
165e					endif 
165e					; with the pointer to the menu it, the byte following the zero term is the file id 
165e			 
165e 3e 00				ld a, 0 
1660 01 32 00				ld bc, 50   ; max of bytes to look at 
1663 ed b1				cpir  
1665			 
1665					if DEBUG_FORTH_WORDS 
1665						DMARK "ALb" 
1665 f5				push af  
1666 3a 7a 16			ld a, (.dmark)  
1669 32 6e fe			ld (debug_mark),a  
166c 3a 7b 16			ld a, (.dmark+1)  
166f 32 6f fe			ld (debug_mark+1),a  
1672 3a 7c 16			ld a, (.dmark+2)  
1675 32 70 fe			ld (debug_mark+2),a  
1678 18 03			jr .pastdmark  
167a ..			.dmark: db "ALb"  
167d f1			.pastdmark: pop af  
167e			endm  
# End of macro DMARK
167e						CALLMONITOR 
167e cd f3 18			call break_point_state  
1681				endm  
# End of macro CALLMONITOR
1681					endif 
1681					;inc hl 
1681			 
1681 7e					ld a, (hl)   ; file id 
1682					 
1682				        ; save bank and file ids 
1682			 
1682 f5					push af 
1683			 
1683			; TODO need to save to block 0 on bank 1	 
1683			 
1683 cd cd 04				call storage_get_block_0 
1686			 
1686					if DEBUG_FORTH_WORDS 
1686						DMARK "AL0" 
1686 f5				push af  
1687 3a 9b 16			ld a, (.dmark)  
168a 32 6e fe			ld (debug_mark),a  
168d 3a 9c 16			ld a, (.dmark+1)  
1690 32 6f fe			ld (debug_mark+1),a  
1693 3a 9d 16			ld a, (.dmark+2)  
1696 32 70 fe			ld (debug_mark+2),a  
1699 18 03			jr .pastdmark  
169b ..			.dmark: db "AL0"  
169e f1			.pastdmark: pop af  
169f			endm  
# End of macro DMARK
169f						CALLMONITOR 
169f cd f3 18			call break_point_state  
16a2				endm  
# End of macro CALLMONITOR
16a2					endif 
16a2 f1					pop af 
16a3			 
16a3 32 a5 fa				ld (store_page+STORE_0_FILERUN),a 
16a6					 
16a6					; save bank id 
16a6			 
16a6 3a 67 fa				ld a,(spi_device) 
16a9 32 a4 fa				ld (store_page+STORE_0_BANKRUN),a 
16ac			 
16ac					; enable auto run of store file 
16ac			 
16ac 3e 01				ld a, 1 
16ae 32 a2 fa				ld (store_page+STORE_0_AUTOFILE),a 
16b1			 
16b1					; save buffer 
16b1			 
16b1 21 00 00				ld hl, 0 
16b4 11 81 fa				ld de, store_page 
16b7					if DEBUG_FORTH_WORDS 
16b7						DMARK "ALw" 
16b7 f5				push af  
16b8 3a cc 16			ld a, (.dmark)  
16bb 32 6e fe			ld (debug_mark),a  
16be 3a cd 16			ld a, (.dmark+1)  
16c1 32 6f fe			ld (debug_mark+1),a  
16c4 3a ce 16			ld a, (.dmark+2)  
16c7 32 70 fe			ld (debug_mark+2),a  
16ca 18 03			jr .pastdmark  
16cc ..			.dmark: db "ALw"  
16cf f1			.pastdmark: pop af  
16d0			endm  
# End of macro DMARK
16d0						CALLMONITOR 
16d0 cd f3 18			call break_point_state  
16d3				endm  
# End of macro CALLMONITOR
16d3					endif 
16d3 cd 81 04			call storage_write_block	 ; save update 
16d6			  
16d6			 
16d6			 
16d6			 
16d6 21 c8 f1				ld hl, scratch 
16d9 cd f1 16				call config_fdir 
16dc			 
16dc				else 
16dc			 
16dc				ld hl, prom_notav 
16dc				ld de, prom_empty 
16dc				call info_panel 
16dc			 
16dc				endif 
16dc c9				ret 
16dd			 
16dd			 
16dd			 
16dd			; Select storage bank 
16dd			 
16dd			.selbank: 
16dd			 
16dd				if STORAGE_SE 
16dd				else 
16dd			 
16dd				ld hl, prom_notav 
16dd				ld de, prom_empty 
16dd				call info_panel 
16dd				endif 
16dd				 
16dd c9				ret 
16de			 
16de			if STORAGE_SE 
16de			 
16de			.config_ldir:   
16de				; Load storage bank labels into menu array 
16de			 
16de				 
16de			 
16de			 
16de c9				ret 
16df			 
16df			 
16df			endif 
16df			 
16df			 
16df			; Save user words to storage 
16df			 
16df			.savetostore: 
16df			 
16df				if STORAGE_SE 
16df			 
16df cd 04 17				call config_dir 
16e2 21 c8 f1			        ld hl, scratch 
16e5 3e 00				ld a, 0 
16e7 cd 49 0d				call menu 
16ea					 
16ea 21 c8 f1				ld hl, scratch 
16ed cd f1 16				call config_fdir 
16f0			 
16f0				else 
16f0			 
16f0				ld hl, prom_notav 
16f0				ld de, prom_empty 
16f0				call info_panel 
16f0			 
16f0				endif 
16f0			 
16f0 c9				ret 
16f1			 
16f1			 
16f1			 
16f1			if STORAGE_SE 
16f1			 
16f1			config_fdir: 
16f1				; using the scratch dir go through and release the memory allocated for each string 
16f1				 
16f1 21 c8 f1			ld hl, scratch 
16f4 5e			.cfdir:	ld e,(hl) 
16f5 23				inc hl 
16f6 56				ld d,(hl) 
16f7 23				inc hl 
16f8			 
16f8 eb				ex de, hl 
16f9 cd 75 0f			call ishlzero 
16fc c8				ret z     ; return on null pointer 
16fd cd dd 14			call free 
1700 eb				ex de, hl 
1701 18 f1			jr .cfdir 
1703			 
1703			 
1703 c9				ret 
1704			 
1704			 
1704			config_dir: 
1704			 
1704				; for the config menus that need to build a directory of storage call this routine 
1704				; it will construct a menu in scratch to pass to menu 
1704			 
1704				; open storage device 
1704			 
1704				; execute DIR to build a list of files and their ids into scratch in menu format 
1704				; once the menu has finished then will need to call config_fdir to release the strings 
1704				 
1704				; c = number items 
1704			 
1704				 
1704 cd cd 04			call storage_get_block_0 
1707			 
1707 21 81 fa			ld hl, store_page     ; get current id count 
170a 46				ld b, (hl) 
170b 0e 00			ld c, 0    ; count of files   
170d			 
170d			 
170d 21 c8 f1			ld hl, scratch 
1710 22 78 fa			ld (store_tmp2), hl    ; location to poke strings 
1713			 
1713				; check for empty drive 
1713			 
1713 3e 00			ld a, 0 
1715 b8				cp b 
1716 ca b0 17			jp z, .dirdone 
1719			 
1719				 
1719					if DEBUG_FORTH_WORDS 
1719						DMARK "Cdc" 
1719 f5				push af  
171a 3a 2e 17			ld a, (.dmark)  
171d 32 6e fe			ld (debug_mark),a  
1720 3a 2f 17			ld a, (.dmark+1)  
1723 32 6f fe			ld (debug_mark+1),a  
1726 3a 30 17			ld a, (.dmark+2)  
1729 32 70 fe			ld (debug_mark+2),a  
172c 18 03			jr .pastdmark  
172e ..			.dmark: db "Cdc"  
1731 f1			.pastdmark: pop af  
1732			endm  
# End of macro DMARK
1732						CALLMONITOR 
1732 cd f3 18			call break_point_state  
1735				endm  
# End of macro CALLMONITOR
1735					endif 
1735			 
1735			 
1735			.diritem:	 
1735 c5				push bc 
1736				; for each of the current ids do a search for them and if found push to stack 
1736			 
1736 21 40 00				ld hl, STORE_BLOCK_PHY 
1739 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
173b 58					ld e,b 
173c			 
173c cd 4f 07				call storage_findnextid 
173f			 
173f			 
173f					; if found hl will be non zero 
173f			 
173f cd 75 0f				call ishlzero 
1742 28 69				jr z, .dirnotfound 
1744			 
1744					; increase count 
1744			 
1744 c1					pop bc	 
1745 0c					inc c 
1746 c5					push bc 
1747					 
1747			 
1747					; get file header and push the file name 
1747			 
1747 11 81 fa				ld de, store_page 
174a cd 1c 04				call storage_read_block 
174d			 
174d					; push file id to stack 
174d				 
174d 3a 81 fa				ld a, (store_page) 
1750 26 00				ld h, 0 
1752 6f					ld l, a 
1753			 
1753					;call forth_push_numhl 
1753					; TODO store id 
1753			 
1753 e5					push hl 
1754			 
1754					; push extent count to stack  
1754				 
1754 21 84 fa				ld hl, store_page+3 
1757			 
1757					; get file name length 
1757			 
1757 cd aa 13				call strlenz   
175a			 
175a 23					inc hl   ; cover zero term 
175b 23					inc hl  ; stick the id at the end of the area 
175c			 
175c e5					push hl 
175d c1					pop bc    ; move length to bc 
175e			 
175e cd 13 14				call malloc 
1761			 
1761					; TODO save malloc area to scratch 
1761			 
1761 eb					ex de, hl 
1762 2a 78 fa				ld hl, (store_tmp2) 
1765 73					ld (hl), e 
1766 23					inc hl 
1767 72					ld (hl), d 
1768 23					inc hl 
1769 22 78 fa				ld (store_tmp2), hl 
176c			 
176c					 
176c			 
176c					;pop hl   ; get source 
176c			;		ex de, hl    ; swap aronund	 
176c			 
176c 21 84 fa				ld hl, store_page+3 
176f					if DEBUG_FORTH_WORDS 
176f						DMARK "CFd" 
176f f5				push af  
1770 3a 84 17			ld a, (.dmark)  
1773 32 6e fe			ld (debug_mark),a  
1776 3a 85 17			ld a, (.dmark+1)  
1779 32 6f fe			ld (debug_mark+1),a  
177c 3a 86 17			ld a, (.dmark+2)  
177f 32 70 fe			ld (debug_mark+2),a  
1782 18 03			jr .pastdmark  
1784 ..			.dmark: db "CFd"  
1787 f1			.pastdmark: pop af  
1788			endm  
# End of macro DMARK
1788						CALLMONITOR 
1788 cd f3 18			call break_point_state  
178b				endm  
# End of macro CALLMONITOR
178b					endif 
178b ed b0				ldir 
178d			 
178d					; de is past string, move back one and store id 
178d					 
178d 1b					dec de 
178e			 
178e					; store file id 
178e			 
178e e1					pop hl 
178f eb					ex de,hl 
1790 73					ld (hl), e 
1791			 
1791					if DEBUG_FORTH_WORDS 
1791						DMARK "Cdi" 
1791 f5				push af  
1792 3a a6 17			ld a, (.dmark)  
1795 32 6e fe			ld (debug_mark),a  
1798 3a a7 17			ld a, (.dmark+1)  
179b 32 6f fe			ld (debug_mark+1),a  
179e 3a a8 17			ld a, (.dmark+2)  
17a1 32 70 fe			ld (debug_mark+2),a  
17a4 18 03			jr .pastdmark  
17a6 ..			.dmark: db "Cdi"  
17a9 f1			.pastdmark: pop af  
17aa			endm  
# End of macro DMARK
17aa						CALLMONITOR 
17aa cd f3 18			call break_point_state  
17ad				endm  
# End of macro CALLMONITOR
17ad					endif 
17ad					 
17ad			.dirnotfound: 
17ad c1					pop bc     
17ae 10 85				djnz .diritem 
17b0				 
17b0			.dirdone:	 
17b0			 
17b0 3e 00				ld a, 0 
17b2 2a 78 fa				ld hl, (store_tmp2) 
17b5 77					ld (hl), a 
17b6 23					inc hl 
17b7 77					ld (hl), a 
17b8 23					inc hl 
17b9					; push a count of the dir items found 
17b9			 
17b9			;		ld h, 0 
17b9			;		ld l, c 
17b9			 
17b9 c9				ret 
17ba			 
17ba			endif 
17ba			 
17ba			 
17ba			; Settings 
17ba			; Run  
17ba			 
17ba			 
17ba			 
17ba			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
17ba			;;hd_menu2:   db "        2: Editor",0   
17ba			;hd_menu2:   db "        2: Editor       6: Menu",0   
17ba			;hd_menu3:   db "        3: Storage",0 
17ba			;hd_menu4:   db "0=quit  4: Debug",0 
17ba			;hd_don:     db "ON",0 
17ba			;hd_doff:     db "OFF",0 
17ba			; 
17ba			; 
17ba			; 
17ba			;hardware_diags_old:       
17ba			; 
17ba			;.diagmenu: 
17ba			;	call clear_display 
17ba			;	ld a, display_row_1 
17ba			;	ld de, hd_menu1 
17ba			;	call str_at_display 
17ba			; 
17ba			;	ld a, display_row_2 
17ba			;	ld de, hd_menu2 
17ba			;	call str_at_display 
17ba			; 
17ba			;	ld a, display_row_3 
17ba			;	ld de, hd_menu3 
17ba			;	call str_at_display 
17ba			; 
17ba			;	ld a,  display_row_4 
17ba			;	ld de, hd_menu4 
17ba			;	call str_at_display 
17ba			; 
17ba			;	; display debug state 
17ba			; 
17ba			;	ld de, hd_don 
17ba			;	ld a, (os_view_disable) 
17ba			;	cp 0 
17ba			;	jr z, .distog 
17ba			;	ld de, hd_doff 
17ba			;.distog: ld a, display_row_4+17 
17ba			;	call str_at_display 
17ba			; 
17ba			;	call update_display 
17ba			; 
17ba			;	call cin_wait 
17ba			; 
17ba			; 
17ba			; 
17ba			;	cp '4' 
17ba			;	jr nz, .diagn1 
17ba			; 
17ba			;	; debug toggle 
17ba			; 
17ba			;	ld a, (os_view_disable) 
17ba			;	ld b, '*' 
17ba			;	cp 0 
17ba			;	jr z, .debtog 
17ba			;	ld b, 0 
17ba			;.debtog:	 
17ba			;	ld a,b 
17ba			;	ld (os_view_disable),a 
17ba			; 
17ba			;.diagn1: cp '0' 
17ba			;	 ret z 
17ba			; 
17ba			;;	cp '1' 
17ba			;;       jp z, matrix	 
17ba			;;   TODO keyboard matrix test 
17ba			; 
17ba			;	cp '2' 
17ba			;	jp z, .diagedit 
17ba			; 
17ba			;;	cp '6' 
17ba			;;	jp z, .menutest 
17ba			;;if ENABLE_BASIC 
17ba			;;	cp '6' 
17ba			;;	jp z, basic 
17ba			;;endif 
17ba			 ; 
17ba			;	jp .diagmenu 
17ba			; 
17ba			; 
17ba			;	ret 
17ba			 
17ba			 
17ba			.debug_tog: 
17ba 21 01 18			ld hl, .menudebug 
17bd				 
17bd 3a b9 f1			ld a, (os_view_disable) 
17c0 fe 2a			cp '*' 
17c2 20 04			jr nz,.tdon  
17c4 3e 01			ld a, 1 
17c6 18 02			jr .tog1 
17c8 3e 00		.tdon: ld a, 0 
17ca			 
17ca			.tog1: 
17ca cd 49 0d			call menu 
17cd fe 00			cp 0 
17cf c8				ret z 
17d0 fe 01			cp 1    ; disable debug 
17d2 28 04			jr z, .dtog0 
17d4 3e 2a			ld a, '*' 
17d6 18 02			jr .dtogset 
17d8 3e 00		.dtog0: ld a, 0 
17da 32 b9 f1		.dtogset:  ld (os_view_disable), a 
17dd c3 ba 17			jp .debug_tog 
17e0			 
17e0			 
17e0			hardware_diags:       
17e0			 
17e0			.diagm: 
17e0 21 f3 17			ld hl, .menuitems 
17e3 3e 00			ld a, 0 
17e5 cd 49 0d			call menu 
17e8			 
17e8 fe 00		         cp 0 
17ea c8				 ret z 
17eb			 
17eb fe 02			cp 2 
17ed ca 4c 18			jp z, .diagedit 
17f0			 
17f0			;	cp '6' 
17f0			;	jp z, .menutest 
17f0			;if ENABLE_BASIC 
17f0			;	cp '6' 
17f0			;	jp z, basic 
17f0			;endif 
17f0			  
17f0 c3 e0 17			jp .diagm 
17f3			 
17f3				 
17f3 07 18		.menuitems:   	dw .m1 
17f5 12 18				dw .m2 
17f7 19 18				dw .m3 
17f9 21 18				dw .m5 
17fb 27 18				dw .m5a 
17fd 30 18				dw .m5b 
17ff 00 00				dw 0 
1801			 
1801			.menudebug: 
1801 39 18				dw .m6 
1803 42 18				dw .m7 
1805 00 00				dw 0 
1807			 
1807 .. 00		.m1:   db "Key Matrix",0 
1812 .. 00		.m2:   db "Editor",0 
1819 .. 00		.m3:   db "Storage",0 
1821 .. 00		.m5:   db "Sound",0 
1827 .. 00		.m5a:  db "RAM Test",0 
1830 .. 00		.m5b:  db "LCD Test",0 
1839			 
1839 .. 00		.m6:   db "Debug ON",0 
1842 .. 00		.m7:   db "Debug OFF",0 
184c			 
184c			; debug editor 
184c			 
184c			.diagedit: 
184c			 
184c 21 c8 f1			ld hl, scratch 
184f			;	ld bc, 250 
184f			;	ldir 
184f				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
184f 3e 00			ld a, 0 
1851 77				ld (hl), a 
1852 23				inc hl 
1853 77				ld (hl), a 
1854 23				inc hl 
1855 77				ld (hl), a 
1856			 
1856 cd 18 0d		        call clear_display 
1859 cd 3b 0d			call update_display 
185c				;ld a, 1 
185c				;ld (hardware_diag), a 
185c			.diloop: 
185c 3e 00			ld a, display_row_1 
185e 0e 00			ld c, 0 
1860 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1862 1e 28			ld e, 40 
1864			 
1864 21 c8 f1			ld hl, scratch	 
1867 cd 79 0f			call input_str 
186a			 
186a 3e 28			ld a, display_row_2 
186c 11 c8 f1			ld de, scratch 
186f cd 2b 0d			call str_at_display 
1872 cd 3b 0d			call update_display 
1875			 
1875 c3 5c 18			jp .diloop 
1878			 
1878			 
1878			; pass word in hl 
1878			; a has display location 
1878			display_word_at: 
1878 f5				push af 
1879 e5				push hl 
187a 7c				ld a,h 
187b 21 cd f4			ld hl, os_word_scratch 
187e cd 4d 12			call hexout 
1881 e1				pop hl 
1882 7d				ld a,l 
1883 21 cf f4			ld hl, os_word_scratch+2 
1886 cd 4d 12			call hexout 
1889 21 d1 f4			ld hl, os_word_scratch+4 
188c 3e 00			ld a,0 
188e 77				ld (hl),a 
188f 11 cd f4			ld de,os_word_scratch 
1892 f1				pop af 
1893 cd 2b 0d				call str_at_display 
1896 c9				ret 
1897			 
1897			display_ptr_state: 
1897			 
1897				; to restore afterwards 
1897			 
1897 d5				push de 
1898 c5				push bc 
1899 e5				push hl 
189a f5				push af 
189b			 
189b				; for use in here 
189b			 
189b			;	push bc 
189b			;	push de 
189b			;	push hl 
189b			;	push af 
189b			 
189b cd 18 0d			call clear_display 
189e			 
189e 11 71 1a			ld de, .ptrstate 
18a1 3e 00			ld a, display_row_1 
18a3 cd 2b 0d			call str_at_display 
18a6			 
18a6				; display debug step 
18a6			 
18a6			 
18a6 11 6e fe			ld de, debug_mark 
18a9 3e 26			ld a, display_row_1+display_cols-2 
18ab cd 2b 0d			call str_at_display 
18ae			 
18ae				; display a 
18ae 11 7b 1a			ld de, .ptrcliptr 
18b1 3e 28			ld a, display_row_2 
18b3 cd 2b 0d			call str_at_display 
18b6			 
18b6 f1				pop af 
18b7 2a 47 fa			ld hl,(cli_ptr) 
18ba 3e 30			ld a, display_row_2+8 
18bc cd 78 18			call display_word_at 
18bf			 
18bf			 
18bf				; display hl 
18bf			 
18bf			 
18bf 11 83 1a			ld de, .ptrclioptr 
18c2 3e 32			ld a, display_row_2+10 
18c4 cd 2b 0d			call str_at_display 
18c7			; 
18c7			;	pop hl 
18c7 3e 35			ld a, display_row_2+13 
18c9 2a 45 fa			ld hl,(cli_origptr) 
18cc cd 78 18			call display_word_at 
18cf			; 
18cf			;	 
18cf			;	; display de 
18cf			 
18cf			;	ld de, .regstatede 
18cf			;	ld a, display_row_3 
18cf			;	call str_at_display 
18cf			 
18cf			;	pop de 
18cf			;	ld h,d 
18cf			;	ld l, e 
18cf			;	ld a, display_row_3+3 
18cf			;	call display_word_at 
18cf			 
18cf			 
18cf				; display bc 
18cf			 
18cf			;	ld de, .regstatebc 
18cf			;	ld a, display_row_3+10 
18cf			;	call str_at_display 
18cf			 
18cf			;	pop bc 
18cf			;	ld h,b 
18cf			;	ld l, c 
18cf			;	ld a, display_row_3+13 
18cf			;	call display_word_at 
18cf			 
18cf			 
18cf				; display dsp 
18cf			 
18cf			;	ld de, .regstatedsp 
18cf			;	ld a, display_row_4 
18cf			;	call str_at_display 
18cf			 
18cf				 
18cf			;	ld hl,(cli_data_sp) 
18cf			;	ld a, display_row_4+4 
18cf			;	call display_word_at 
18cf			 
18cf				; display rsp 
18cf			 
18cf 11 b2 1a			ld de, .regstatersp 
18d2 3e 82			ld a, display_row_4+10 
18d4 cd 2b 0d			call str_at_display 
18d7			 
18d7				 
18d7 2a f9 f9			ld hl,(cli_ret_sp) 
18da 3e 86			ld a, display_row_4+14 
18dc cd 78 18			call display_word_at 
18df			 
18df cd 3b 0d			call update_display 
18e2			 
18e2 cd 95 0c			call delay1s 
18e5 cd 95 0c			call delay1s 
18e8 cd 95 0c			call delay1s 
18eb			 
18eb			 
18eb cd df 1e			call next_page_prompt 
18ee			 
18ee				; restore  
18ee			 
18ee f1				pop af 
18ef e1				pop hl 
18f0 c1				pop bc 
18f1 d1				pop de 
18f2 c9				ret 
18f3			 
18f3			break_point_state: 
18f3 f5				push af 
18f4			 
18f4				; see if disabled 
18f4			 
18f4 3a b9 f1			ld a, (os_view_disable) 
18f7 fe 2a			cp '*' 
18f9 20 02			jr nz, .bpsgo 
18fb f1				pop af 
18fc c9				ret 
18fd			 
18fd			.bpsgo: 
18fd f1				pop af 
18fe f5				push af 
18ff 22 b5 f1			ld (os_view_hl), hl 
1902 ed 53 b3 f1		ld (os_view_de), de 
1906 ed 43 b1 f1		ld (os_view_bc), bc 
190a e5				push hl 
190b 6f				ld l, a 
190c 26 00			ld h, 0 
190e 22 b7 f1			ld (os_view_af),hl 
1911			 
1911 21 b4 fd				ld hl, display_fb0 
1914 22 cf fb				ld (display_fb_active), hl 
1917 e1				pop hl	 
1918			 
1918 3e 31			ld a, '1' 
191a fe 2a		.bps1:  cp '*' 
191c 20 03			jr nz, .bps1b 
191e 32 b9 f1			ld (os_view_disable),a 
1921 fe 31		.bps1b:  cp '1' 
1923 20 14			jr nz, .bps2 
1925			 
1925				; display reg 
1925			 
1925				 
1925			 
1925 3a b7 f1			ld a, (os_view_af) 
1928 2a b5 f1			ld hl, (os_view_hl) 
192b ed 5b b3 f1		ld de, (os_view_de) 
192f ed 4b b1 f1		ld bc, (os_view_bc) 
1933 cd cd 19			call display_reg_state 
1936 c3 b9 19			jp .bpschk 
1939			 
1939 fe 32		.bps2:  cp '2' 
193b 20 08			jr nz, .bps3 
193d				 
193d				; display hl 
193d 2a b5 f1			ld hl, (os_view_hl) 
1940 cd b7 1a			call display_dump_at_hl 
1943			 
1943 18 74			jr .bpschk 
1945			 
1945 fe 33		.bps3:  cp '3' 
1947 20 08			jr nz, .bps4 
1949			 
1949			        ; display de 
1949 2a b3 f1			ld hl, (os_view_de) 
194c cd b7 1a			call display_dump_at_hl 
194f			 
194f 18 68			jr .bpschk 
1951 fe 34		.bps4:  cp '4' 
1953 20 08			jr nz, .bps5 
1955			 
1955			        ; display bc 
1955 2a b1 f1			ld hl, (os_view_bc) 
1958 cd b7 1a			call display_dump_at_hl 
195b			 
195b 18 5c			jr .bpschk 
195d fe 35		.bps5:  cp '5' 
195f 20 08		        jr nz, .bps7 
1961			 
1961				; display cur ptr 
1961 2a 47 fa			ld hl, (cli_ptr) 
1964 cd b7 1a			call display_dump_at_hl 
1967			 
1967 18 50			jr .bpschk 
1969 fe 36		.bps7:  cp '6' 
196b 20 08			jr nz, .bps8b 
196d				 
196d				; display cur orig ptr 
196d 2a 45 fa			ld hl, (cli_origptr) 
1970 cd b7 1a			call display_dump_at_hl 
1973 18 44			jr .bpschk 
1975 fe 37		.bps8b:  cp '7' 
1977 20 08			jr nz, .bps9 
1979				 
1979				; display dsp 
1979 2a f5 f9			ld hl, (cli_data_sp) 
197c cd b7 1a			call display_dump_at_hl 
197f			 
197f 18 38			jr .bpschk 
1981 fe 39		.bps9:  cp '9' 
1983 20 05			jr nz, .bps8c 
1985				 
1985				; display SP 
1985			;	ld hl, sp 
1985 cd b7 1a			call display_dump_at_hl 
1988			 
1988 18 2f			jr .bpschk 
198a fe 38		.bps8c:  cp '8' 
198c 20 08			jr nz, .bps8d 
198e				 
198e				; display rsp 
198e 2a f9 f9			ld hl, (cli_ret_sp) 
1991 cd b7 1a			call display_dump_at_hl 
1994			 
1994 18 23			jr .bpschk 
1996 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1998 20 05			jr nz, .bps8 
199a cd d5 1c			call monitor 
199d			 
199d 18 1a			jr .bpschk 
199f fe 30		.bps8:  cp '0' 
19a1 20 16			jr nz, .bpschk 
19a3			 
19a3 21 13 fd				ld hl, display_fb1 
19a6 22 cf fb				ld (display_fb_active), hl 
19a9 cd 3b 0d				call update_display 
19ac			 
19ac				;ld a, (os_view_af) 
19ac 2a b5 f1			ld hl, (os_view_hl) 
19af ed 5b b3 f1		ld de, (os_view_de) 
19b3 ed 4b b1 f1		ld bc, (os_view_bc) 
19b7 f1				pop af 
19b8 c9				ret 
19b9			 
19b9			.bpschk:   
19b9 cd 95 0c			call delay1s 
19bc 3e 9f		ld a,display_row_4 + display_cols - 1 
19be 11 dd 1e		        ld de, endprg 
19c1 cd 2b 0d			call str_at_display 
19c4 cd 3b 0d			call update_display 
19c7 cd 07 77			call cin_wait 
19ca			 
19ca c3 1a 19			jp .bps1 
19cd			 
19cd			 
19cd			display_reg_state: 
19cd			 
19cd				; to restore afterwards 
19cd			 
19cd d5				push de 
19ce c5				push bc 
19cf e5				push hl 
19d0 f5				push af 
19d1			 
19d1				; for use in here 
19d1			 
19d1 c5				push bc 
19d2 d5				push de 
19d3 e5				push hl 
19d4 f5				push af 
19d5			 
19d5 cd 18 0d			call clear_display 
19d8			 
19d8 11 8d 1a			ld de, .regstate 
19db 3e 00			ld a, display_row_1 
19dd cd 2b 0d			call str_at_display 
19e0			 
19e0				; display debug step 
19e0			 
19e0			 
19e0 11 6e fe			ld de, debug_mark 
19e3 3e 25			ld a, display_row_1+display_cols-3 
19e5 cd 2b 0d			call str_at_display 
19e8			 
19e8				; display a 
19e8 11 a9 1a			ld de, .regstatea 
19eb 3e 28			ld a, display_row_2 
19ed cd 2b 0d			call str_at_display 
19f0			 
19f0 e1				pop hl 
19f1			;	ld h,0 
19f1			;	ld l, a 
19f1 3e 2b			ld a, display_row_2+3 
19f3 cd 78 18			call display_word_at 
19f6			 
19f6			 
19f6				; display hl 
19f6			 
19f6			 
19f6 11 9d 1a			ld de, .regstatehl 
19f9 3e 32			ld a, display_row_2+10 
19fb cd 2b 0d			call str_at_display 
19fe			 
19fe e1				pop hl 
19ff 3e 35			ld a, display_row_2+13 
1a01 cd 78 18			call display_word_at 
1a04			 
1a04				 
1a04				; display de 
1a04			 
1a04 11 a1 1a			ld de, .regstatede 
1a07 3e 50			ld a, display_row_3 
1a09 cd 2b 0d			call str_at_display 
1a0c			 
1a0c e1				pop hl 
1a0d			;	ld h,d 
1a0d			;	ld l, e 
1a0d 3e 53			ld a, display_row_3+3 
1a0f cd 78 18			call display_word_at 
1a12			 
1a12			 
1a12				; display bc 
1a12			 
1a12 11 a5 1a			ld de, .regstatebc 
1a15 3e 5a			ld a, display_row_3+10 
1a17 cd 2b 0d			call str_at_display 
1a1a			 
1a1a e1				pop hl 
1a1b			;	ld h,b 
1a1b			;	ld l, c 
1a1b 3e 5d			ld a, display_row_3+13 
1a1d cd 78 18			call display_word_at 
1a20			 
1a20			 
1a20				; display dsp 
1a20			 
1a20 11 ad 1a			ld de, .regstatedsp 
1a23 3e 78			ld a, display_row_4 
1a25 cd 2b 0d			call str_at_display 
1a28			 
1a28				 
1a28 2a f5 f9			ld hl,(cli_data_sp) 
1a2b 3e 7c			ld a, display_row_4+4 
1a2d cd 78 18			call display_word_at 
1a30			 
1a30				; display rsp 
1a30			 
1a30 11 b2 1a			ld de, .regstatersp 
1a33 3e 82			ld a, display_row_4+10 
1a35 cd 2b 0d			call str_at_display 
1a38			 
1a38				 
1a38 2a f9 f9			ld hl,(cli_ret_sp) 
1a3b 3e 86			ld a, display_row_4+14 
1a3d cd 78 18			call display_word_at 
1a40			 
1a40 cd 3b 0d			call update_display 
1a43			 
1a43			;	call delay1s 
1a43			;	call delay1s 
1a43			;	call delay1s 
1a43			 
1a43			 
1a43			;	call next_page_prompt 
1a43			 
1a43				; restore  
1a43			 
1a43 f1				pop af 
1a44 e1				pop hl 
1a45 c1				pop bc 
1a46 d1				pop de 
1a47 c9				ret 
1a48			 
1a48 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1a5c .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1a71 .. 00		.ptrstate:	db "Ptr State",0 
1a7b .. 00		.ptrcliptr:     db "cli_ptr",0 
1a83 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1a8d .. 00		.regstate:	db "Reg State (1/0)",0 
1a9d .. 00		.regstatehl:	db "HL:",0 
1aa1 .. 00		.regstatede:	db "DE:",0 
1aa5 .. 00		.regstatebc:	db "BC:",0 
1aa9 .. 00		.regstatea:	db "A :",0 
1aad .. 00		.regstatedsp:	db "DSP:",0 
1ab2 .. 00		.regstatersp:	db "RSP:",0 
1ab7			 
1ab7			display_dump_at_hl: 
1ab7 e5				push hl 
1ab8 d5				push de 
1ab9 c5				push bc 
1aba f5				push af 
1abb			 
1abb 22 eb f4			ld (os_cur_ptr),hl	 
1abe cd 18 0d			call clear_display 
1ac1 cd e7 1d			call dumpcont 
1ac4			;	call delay1s 
1ac4			;	call next_page_prompt 
1ac4			 
1ac4			 
1ac4 f1				pop af 
1ac5 c1				pop bc 
1ac6 d1				pop de 
1ac7 e1				pop hl 
1ac8 c9				ret 
1ac9			 
1ac9			;if ENABLE_BASIC 
1ac9			;	include "nascombasic.asm" 
1ac9			;	basic: 
1ac9			;	include "forth/FORTH.ASM" 
1ac9			;endif 
1ac9			 
1ac9			; eof 
1ac9			 
1ac9			 
# End of file firmware_diags.asm
1ac9			  
1ac9			include "firmware_prompts.asm"  
1ac9			; Prompts  
1ac9			 
1ac9			; boot messages 
1ac9			 
1ac9 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1ade .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1aee			 
1aee			 
1aee			; config menus 
1aee			 
1aee .. 00		prom_c3: db "Add Dictionary To File",0 
1b05 .. 00		prom_c2: db "Select Autoload File",0 
1b1a .. 00		prom_c2a: db "Disable Autoload File", 0 
1b30 .. 00		prom_c2b: db "Select Storage Bank",0 
1b44 .. 00		prom_c4: db "Settings",0 
1b4d .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1b68 .. 00		prom_m4b:   db "Monitor",0 
1b70 .. 00		prom_c1: db "Hardware Diags",0 
1b7f			 
1b7f			 
1b7f .. 00		prom_notav:    db "Feature not available",0 
1b95 .. 00		prom_empty:    db "",0 
1b96			 
1b96			; eof 
1b96			 
# End of file firmware_prompts.asm
1b96			  
1b96			  
1b96			; eof  
1b96			  
# End of file firmware.asm
1b96			 
1b96			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1b96			;if BASE_KEV  
1b96			;baseram: equ 08000h 
1b96			;endif 
1b96			 
1b96			;if BASE_SC114 
1b96			;baseram:     equ    endofcode 
1b96			;endif 
1b96			 
1b96			 
1b96			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1b96			 
1b96			; start system 
1b96			 
1b96			coldstart: 
1b96				; set sp 
1b96				; di/ei 
1b96			 
1b96 f3				di 
1b97 31 fd ff			ld sp, tos 
1b9a			;	ei 
1b9a			 
1b9a			 
1b9a				; disable breakpoint by default 
1b9a			 
1b9a 3e 2a			ld a,'*' 
1b9c 32 b9 f1			ld (os_view_disable),a 
1b9f			 
1b9f				; init hardware 
1b9f			 
1b9f				; init keyboard and screen hardware 
1b9f			 
1b9f cd 1c 00			call hardware_init 
1ba2			 
1ba2			 
1ba2 cd 95 0c			call delay1s 
1ba5 3e 58			ld a, display_row_3+8 
1ba7 11 03 00			ld de, buildtime 
1baa cd 2b 0d			call str_at_display 
1bad cd 3b 0d			call update_display 
1bb0			 
1bb0 cd 95 0c			call delay1s 
1bb3 cd 95 0c			call delay1s 
1bb6 cd 95 0c			call delay1s 
1bb9			 
1bb9				; detect if any keys are held down to enable breakpoints at start up 
1bb9			 
1bb9 cd 18 77			call cin  
1bbc fe 00			cp 0 
1bbe 28 03			jr z, .nokeys 
1bc0			 
1bc0				;call hardware_diags 
1bc0 cd d6 15			call config 
1bc3			 
1bc3			;	ld de, .bpen 
1bc3			;	ld a, display_row_4 
1bc3			;	call str_at_display 
1bc3			;	call update_display 
1bc3			; 
1bc3			;	ld a,0 
1bc3			;	ld (os_view_disable),a 
1bc3			; 
1bc3			;.bpwait: 
1bc3			;	call cin 
1bc3			;	cp 0 
1bc3			;	jr z, .bpwait 
1bc3			;	jr .nokeys 
1bc3			; 
1bc3			; 
1bc3			;.bpen:  db "Break points enabled!",0 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			.nokeys: 
1bc3			 
1bc3			 
1bc3				 
1bc3			 
1bc3			;jp  testkey 
1bc3			 
1bc3			;call storage_get_block_0 
1bc3			; 
1bc3			;ld hl, 0 
1bc3			;ld de, store_page 
1bc3			;call storage_read_block 
1bc3			 
1bc3				 
1bc3			;ld hl, 10 
1bc3			;ld de, store_page 
1bc3			;call storage_read_block 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			 
1bc3			;stop:	nop 
1bc3			;	jp stop 
1bc3			 
1bc3			 
1bc3			 
1bc3			main: 
1bc3 cd 18 0d			call clear_display 
1bc6 cd 3b 0d			call update_display 
1bc9			 
1bc9			 
1bc9			 
1bc9			;	call testlcd 
1bc9			 
1bc9			 
1bc9			 
1bc9 cd e4 22			call forth_init 
1bcc			 
1bcc			 
1bcc			warmstart: 
1bcc cd ba 22			call forth_warmstart 
1bcf			 
1bcf				; run startup word load 
1bcf			        ; TODO prevent this running at warmstart after crash  
1bcf			 
1bcf				if STARTUP_ENABLE 
1bcf					if STORAGE_SE 
1bcf cd a6 72					call forth_autoload 
1bd2					endif 
1bd2 cd b5 6f				call forth_startup 
1bd5			 
1bd5			 
1bd5				endif 
1bd5			 
1bd5				; show free memory after boot 
1bd5 11 6f 1c			ld de, freeram 
1bd8 3e 00			ld a, display_row_1 
1bda cd 2b 0d			call str_at_display 
1bdd			 
1bdd			; Or use heap_size word???? 
1bdd 21 ae f1			ld hl, heap_end 
1be0 11 0e 80			ld de, heap_start 
1be3 ed 52			sbc hl, de 
1be5 e5				push hl 
1be6 7c				ld a,h	         	 
1be7 21 cd f4			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1bea cd 4d 12			call hexout 
1bed e1			   	pop hl 
1bee			 
1bee 7d				ld a,l 
1bef 21 cf f4			ld hl, os_word_scratch+2 
1bf2 cd 4d 12			call hexout 
1bf5 21 d1 f4			ld hl, os_word_scratch+4 
1bf8 3e 00			ld a, 0 
1bfa 77				ld (hl),a 
1bfb 11 cd f4			ld de, os_word_scratch 
1bfe 3e 0d			ld a, display_row_1 + 13 
1c00 cd 2b 0d			call str_at_display 
1c03 cd 3b 0d			call update_display 
1c06			 
1c06			 
1c06				;call demo 
1c06			 
1c06			 
1c06				; init scratch input area for cli commands 
1c06			 
1c06 21 ef f4			ld hl, os_cli_cmd 
1c09 3e 00			ld a,0 
1c0b 77				ld (hl),a 
1c0c 23				inc hl 
1c0d 77				ld (hl),a 
1c0e			 
1c0e 3e 00			ld a,0 
1c10 32 ee f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1c13			 
1c13 32 eb f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1c16 32 ec f4			ld (os_cur_ptr+1),a	 
1c19			 
1c19 32 cd f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1c1c 32 ce f4			ld (os_word_scratch+1),a	 
1c1f				 
1c1f			 
1c1f				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c1f 21 ef f4			ld hl, os_cli_cmd 
1c22			 
1c22 3e 00			ld a, 0		 ; init cli input 
1c24 77				ld (hl), a 
1c25 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c27			cli: 
1c27				; show cli prompt 
1c27				;push af 
1c27				;ld a, 0 
1c27				;ld de, prompt 
1c27				;call str_at_display 
1c27			 
1c27				;call update_display 
1c27				;pop af 
1c27				;inc a 
1c27				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1c27 0e 00			ld c, 0 
1c29 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1c2b 1e 28			ld e, 40 
1c2d			 
1c2d 21 ef f4			ld hl, os_cli_cmd 
1c30			 
1c30				STACKFRAME OFF $fefe $9f9f 
1c30				if DEBUG_STACK_IMB 
1c30					if OFF 
1c30						exx 
1c30						ld de, $fefe 
1c30						ld a, d 
1c30						ld hl, curframe 
1c30						call hexout 
1c30						ld a, e 
1c30						ld hl, curframe+2 
1c30						call hexout 
1c30						ld hl, $fefe 
1c30						push hl 
1c30						ld hl, $9f9f 
1c30						push hl 
1c30						exx 
1c30					endif 
1c30				endif 
1c30			endm 
# End of macro STACKFRAME
1c30			 
1c30 cd 79 0f			call input_str 
1c33			 
1c33				STACKFRAMECHK OFF $fefe $9f9f 
1c33				if DEBUG_STACK_IMB 
1c33					if OFF 
1c33						exx 
1c33						ld hl, $9f9f 
1c33						pop de   ; $9f9f 
1c33						call cmp16 
1c33						jr nz, .spnosame 
1c33						ld hl, $fefe 
1c33						pop de   ; $fefe 
1c33						call cmp16 
1c33						jr z, .spfrsame 
1c33						.spnosame: call showsperror 
1c33						.spfrsame: nop 
1c33						exx 
1c33					endif 
1c33				endif 
1c33			endm 
# End of macro STACKFRAMECHK
1c33			 
1c33				; copy input to last command 
1c33			 
1c33 21 ef f4			ld hl, os_cli_cmd 
1c36 11 ee f5			ld de, os_last_cmd 
1c39 01 ff 00			ld bc, 255 
1c3c ed b0			ldir 
1c3e			 
1c3e				; wipe current buffer 
1c3e			 
1c3e			;	ld a, 0 
1c3e			;	ld hl, os_cli_cmd 
1c3e			;	ld de, os_cli_cmd+1 
1c3e			;	ld bc, 254 
1c3e			;	ldir 
1c3e				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1c3e			;	call strcpy 
1c3e			;	ld a, 0 
1c3e			;	ld (hl), a 
1c3e			;	inc hl 
1c3e			;	ld (hl), a 
1c3e			;	inc hl 
1c3e			;	ld (hl), a 
1c3e			 
1c3e				; switch frame buffer to program  
1c3e			 
1c3e 21 13 fd				ld hl, display_fb1 
1c41 22 cf fb				ld (display_fb_active), hl 
1c44			 
1c44			;	nop 
1c44				STACKFRAME ON $fbfe $8f9f 
1c44				if DEBUG_STACK_IMB 
1c44					if ON 
1c44						exx 
1c44						ld de, $fbfe 
1c44						ld a, d 
1c44						ld hl, curframe 
1c44						call hexout 
1c44						ld a, e 
1c44						ld hl, curframe+2 
1c44						call hexout 
1c44						ld hl, $fbfe 
1c44						push hl 
1c44						ld hl, $8f9f 
1c44						push hl 
1c44						exx 
1c44					endif 
1c44				endif 
1c44			endm 
# End of macro STACKFRAME
1c44				; first time into the parser so pass over the current scratch pad 
1c44 21 ef f4			ld hl,os_cli_cmd 
1c47				; tokenise the entered statement(s) in HL 
1c47 cd 62 23			call forthparse 
1c4a			        ; exec forth statements in top of return stack 
1c4a cd a2 23			call forthexec 
1c4d				;call forthexec_cleanup 
1c4d			;	call parsenext 
1c4d			 
1c4d				STACKFRAMECHK ON $fbfe $8f9f 
1c4d				if DEBUG_STACK_IMB 
1c4d					if ON 
1c4d						exx 
1c4d						ld hl, $8f9f 
1c4d						pop de   ; $8f9f 
1c4d						call cmp16 
1c4d						jr nz, .spnosame 
1c4d						ld hl, $fbfe 
1c4d						pop de   ; $fbfe 
1c4d						call cmp16 
1c4d						jr z, .spfrsame 
1c4d						.spnosame: call showsperror 
1c4d						.spfrsame: nop 
1c4d						exx 
1c4d					endif 
1c4d				endif 
1c4d			endm 
# End of macro STACKFRAMECHK
1c4d				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1c4d			 
1c4d 3e 78			ld a, display_row_4 
1c4f 11 81 1c			ld de, endprog 
1c52			 
1c52 cd 3b 0d			call update_display		 
1c55			 
1c55 cd df 1e			call next_page_prompt 
1c58			 
1c58				; switch frame buffer to cli 
1c58			 
1c58 21 b4 fd				ld hl, display_fb0 
1c5b 22 cf fb				ld (display_fb_active), hl 
1c5e			 
1c5e			 
1c5e cd 18 0d		        call clear_display 
1c61 cd 3b 0d			call update_display		 
1c64			 
1c64 21 ef f4			ld hl, os_cli_cmd 
1c67			 
1c67 3e 00			ld a, 0		 ; init cli input 
1c69 77				ld (hl), a 
1c6a			 
1c6a				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1c6a			 
1c6a				; now on last line 
1c6a			 
1c6a				; TODO scroll screen up 
1c6a			 
1c6a				; TODO instead just clear screen and place at top of screen 
1c6a			 
1c6a			;	ld a, 0 
1c6a			;	ld (f_cursor_ptr),a 
1c6a			 
1c6a				;call clear_display 
1c6a				;call update_display 
1c6a			 
1c6a				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c6a 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c6c c3 27 1c			jp cli 
1c6f			 
1c6f .. 00		freeram: db "Free bytes: $",0 
1c7d ..			asc: db "1A2F" 
1c81 .. 00		endprog: db "End prog...",0 
1c8d			 
1c8d			testenter2:   
1c8d 21 fa f1			ld hl,scratch+50 
1c90 22 eb f4			ld (os_cur_ptr),hl 
1c93 c3 27 1c			jp cli 
1c96			 
1c96			testenter:  
1c96			 
1c96 21 7d 1c			ld hl,asc 
1c99			;	ld a,(hl) 
1c99			;	call nibble2val 
1c99 cd a3 12			call get_byte 
1c9c			 
1c9c			 
1c9c			;	ld a,(hl) 
1c9c			;	call atohex 
1c9c			 
1c9c			;	call fourehexhl 
1c9c 32 fa f1			ld (scratch+50),a 
1c9f			 
1c9f			 
1c9f			 
1c9f 21 7f 1c			ld hl,asc+2 
1ca2			;	ld a, (hl) 
1ca2			;	call nibble2val 
1ca2 cd a3 12			call get_byte 
1ca5			 
1ca5			;	call fourehexhl 
1ca5 32 fc f1			ld (scratch+52),a 
1ca8				 
1ca8 21 fa f1			ld hl,scratch+50 
1cab 22 eb f4			ld (os_cur_ptr),hl 
1cae c3 27 1c			jp cli 
1cb1			 
1cb1			enter:	 
1cb1 3a cc f1			ld a,(scratch+4) 
1cb4 fe 00			cp 0 
1cb6 28 0c			jr z, .entercont 
1cb8				; no, not a null term line so has an address to work out.... 
1cb8			 
1cb8 21 ca f1			ld hl,scratch+2 
1cbb cd 03 13			call get_word_hl 
1cbe			 
1cbe 22 eb f4			ld (os_cur_ptr),hl	 
1cc1 c3 27 1c			jp cli 
1cc4			 
1cc4			 
1cc4			.entercont:  
1cc4			 
1cc4 21 ca f1			ld hl, scratch+2 
1cc7 cd a3 12			call get_byte 
1cca			 
1cca 2a eb f4		   	ld hl,(os_cur_ptr) 
1ccd 77					ld (hl),a 
1cce 23					inc hl 
1ccf 22 eb f4				ld (os_cur_ptr),hl 
1cd2				 
1cd2			; get byte  
1cd2			 
1cd2			 
1cd2 c3 27 1c			jp cli 
1cd5			 
1cd5			 
1cd5			; basic monitor support 
1cd5			 
1cd5			monitor: 
1cd5				;  
1cd5 cd 18 0d			call clear_display 
1cd8 3e 00			ld a, 0 
1cda 11 22 1d			ld de, .monprompt 
1cdd cd 2b 0d			call str_at_display 
1ce0 cd 3b 0d			call update_display 
1ce3			 
1ce3				; get a monitor command 
1ce3			 
1ce3 0e 00			ld c, 0     ; entry at top left 
1ce5 16 64			ld d, 100   ; max buffer size 
1ce7 1e 0f			ld e, 15    ; input scroll area 
1ce9 3e 00			ld a, 0     ; init string 
1ceb 21 c6 f3			ld hl, os_input 
1cee 77				ld (hl), a 
1cef 23				inc hl 
1cf0 77				ld (hl), a 
1cf1 21 c6 f3			ld hl, os_input 
1cf4 3e 01			ld a, 1     ; init string 
1cf6 cd 79 0f			call input_str 
1cf9			 
1cf9 cd 18 0d		        call clear_display 
1cfc cd 3b 0d			call update_display		 
1cff			 
1cff 3a c6 f3			ld a, (os_input) 
1d02 cd a1 13			call toUpper 
1d05 fe 48		        cp 'H' 
1d07 28 6f		        jr z, .monhelp 
1d09 fe 44			cp 'D'		; dump 
1d0b ca 99 1d			jp z, .mondump	 
1d0e fe 43			cp 'C'		; dump 
1d10 ca b3 1d			jp z, .moncdump	 
1d13 fe 4d			cp 'M'		; dump 
1d15 ca 24 1d			jp z, .moneditstart 
1d18 fe 55			cp 'U'		; dump 
1d1a 28 14			jr z, .monedit	 
1d1c fe 51			cp 'Q'		; dump 
1d1e c8				ret z	 
1d1f			 
1d1f			 
1d1f				; TODO "S" to access symbol by name and not need the address 
1d1f				; TODO "F" to find a string in memory 
1d1f			 
1d1f c3 d5 1c			jp monitor 
1d22			 
1d22 .. 00		.monprompt: db ">", 0 
1d24			 
1d24			.moneditstart: 
1d24				; get starting address 
1d24			 
1d24 21 c8 f3			ld hl,os_input+2 
1d27 cd 03 13			call get_word_hl 
1d2a			 
1d2a 22 eb f4			ld (os_cur_ptr),hl	 
1d2d			 
1d2d c3 d5 1c			jp monitor 
1d30			 
1d30			.monedit: 
1d30				; get byte to load 
1d30			 
1d30 21 c8 f3			ld hl,os_input+2 
1d33 cd a3 12			call get_byte 
1d36			 
1d36				; get address to update 
1d36 2a eb f4			ld hl, (os_cur_ptr) 
1d39			 
1d39				; update byte 
1d39			 
1d39 77				ld (hl), a 
1d3a			 
1d3a				; move to next address and save it 
1d3a			 
1d3a 23				inc hl 
1d3b 22 eb f4			ld (os_cur_ptr),hl	 
1d3e			 
1d3e c3 d5 1c			jp monitor 
1d41			 
1d41			 
1d41 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1d55 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1d71 .. 00		.monhelptext3:  db "Q-Quit",0 
1d78			        
1d78			.monhelp: 
1d78 3e 00			ld a, display_row_1 
1d7a 11 41 1d		        ld de, .monhelptext1 
1d7d			 
1d7d cd 2b 0d			call str_at_display 
1d80 3e 28			ld a, display_row_2 
1d82 11 55 1d		        ld de, .monhelptext2 
1d85					 
1d85 cd 2b 0d			call str_at_display 
1d88 3e 50			ld a, display_row_3 
1d8a 11 71 1d		        ld de, .monhelptext3 
1d8d					 
1d8d cd 2b 0d			call str_at_display 
1d90 cd 3b 0d			call update_display		 
1d93			 
1d93 cd df 1e			call next_page_prompt 
1d96 c3 d5 1c			jp monitor 
1d99			 
1d99			.mondump:    
1d99 21 c8 f3			ld hl,os_input+2 
1d9c cd 03 13			call get_word_hl 
1d9f			 
1d9f 22 eb f4			ld (os_cur_ptr),hl	 
1da2 cd e7 1d			call dumpcont 
1da5 3e 78			ld a, display_row_4 
1da7 11 81 1c			ld de, endprog 
1daa			 
1daa cd 3b 0d			call update_display		 
1dad			 
1dad cd df 1e			call next_page_prompt 
1db0 c3 d5 1c			jp monitor 
1db3			.moncdump: 
1db3 cd e7 1d			call dumpcont 
1db6 3e 78			ld a, display_row_4 
1db8 11 81 1c			ld de, endprog 
1dbb			 
1dbb cd 3b 0d			call update_display		 
1dbe			 
1dbe cd df 1e			call next_page_prompt 
1dc1 c3 d5 1c			jp monitor 
1dc4			 
1dc4			 
1dc4			; TODO symbol access  
1dc4			 
1dc4			.symbols:     ;; A list of symbols that can be called up  
1dc4 b4 fd			dw display_fb0 
1dc6 .. 00			db "fb0",0  
1dca 81 fa		     	dw store_page 
1dcc .. 00			db "store_page",0 
1dd7			 
1dd7			 
1dd7			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1dd7			 
1dd7 3a c9 f1			ld a,(scratch+1) 
1dda fe 00			cp 0 
1ddc 28 09			jr z, dumpcont 
1dde			 
1dde				; no, not a null term line so has an address to work out.... 
1dde			 
1dde 21 ca f1			ld hl,scratch+2 
1de1 cd 03 13			call get_word_hl 
1de4			 
1de4 22 eb f4			ld (os_cur_ptr),hl	 
1de7			 
1de7			 
1de7			 
1de7			dumpcont: 
1de7			 
1de7				; dump bytes at ptr 
1de7			 
1de7			 
1de7 3e 00			ld a, display_row_1 
1de9 2a cf fb			ld hl, (display_fb_active) 
1dec cd 4c 0f			call addatohl 
1def cd 17 1e			call .dumpbyterow 
1df2			 
1df2 3e 28			ld a, display_row_2 
1df4 2a cf fb			ld hl, (display_fb_active) 
1df7 cd 4c 0f			call addatohl 
1dfa cd 17 1e			call .dumpbyterow 
1dfd			 
1dfd			 
1dfd 3e 50			ld a, display_row_3 
1dff 2a cf fb			ld hl, (display_fb_active) 
1e02 cd 4c 0f			call addatohl 
1e05 cd 17 1e			call .dumpbyterow 
1e08			 
1e08 3e 78			ld a, display_row_4 
1e0a 2a cf fb			ld hl, (display_fb_active) 
1e0d cd 4c 0f			call addatohl 
1e10 cd 17 1e			call .dumpbyterow 
1e13			 
1e13 cd 3b 0d			call update_display 
1e16			;		jp cli 
1e16 c9				ret 
1e17			 
1e17			.dumpbyterow: 
1e17			 
1e17				;push af 
1e17			 
1e17 e5				push hl 
1e18			 
1e18				; calc where to poke the ascii 
1e18			if display_cols == 20 
1e18				ld a, 16 
1e18			else 
1e18 3e 1f			ld a, 31 
1e1a			endif 
1e1a			 
1e1a cd 4c 0f			call addatohl 
1e1d 22 cd f4			ld (os_word_scratch),hl  		; save pos for later 
1e20			 
1e20			 
1e20			; display decoding address 
1e20 2a eb f4		   	ld hl,(os_cur_ptr) 
1e23			 
1e23 7c				ld a,h 
1e24 e1				pop hl 
1e25 e5				push hl 
1e26			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1e26 cd 4d 12			call hexout 
1e29 2a eb f4		   	ld hl,(os_cur_ptr) 
1e2c			 
1e2c 7d				ld a,l 
1e2d e1				pop hl 
1e2e 23				inc hl 
1e2f 23				inc hl 
1e30 e5				push hl 
1e31			;	ld hl, os_word_scratch+2 
1e31 cd 4d 12			call hexout 
1e34 e1				pop hl 
1e35 23				inc hl 
1e36 23				inc hl 
1e37				;ld hl, os_word_scratch+4 
1e37 3e 3a			ld a, ':' 
1e39 77				ld (hl),a 
1e3a 23				inc hl 
1e3b				;ld a, 0 
1e3b				;ld (hl),a 
1e3b				;ld de, os_word_scratch 
1e3b				;pop af 
1e3b				;push af 
1e3b			;		ld a, display_row_2 
1e3b			;		call str_at_display 
1e3b			;		call update_display 
1e3b			 
1e3b			 
1e3b			;pop af 
1e3b			;	add 5 
1e3b			 
1e3b			if display_cols == 20 
1e3b				ld b, 4 
1e3b			else 
1e3b 06 08			ld b, 8 
1e3d			endif	 
1e3d			 
1e3d			.dumpbyte: 
1e3d c5				push bc 
1e3e e5				push hl 
1e3f			 
1e3f			 
1e3f 2a eb f4		   	ld hl,(os_cur_ptr) 
1e42 7e					ld a,(hl) 
1e43			 
1e43					; poke the ascii to display 
1e43 2a cd f4				ld hl,(os_word_scratch) 
1e46 77					ld (hl),a 
1e47 23					inc hl 
1e48 22 cd f4				ld (os_word_scratch),hl 
1e4b			 
1e4b					 
1e4b			 
1e4b			 
1e4b e1					pop hl 
1e4c e5					push hl 
1e4d			 
1e4d cd 4d 12				call hexout 
1e50			 
1e50					 
1e50 2a eb f4		   	ld hl,(os_cur_ptr) 
1e53 23				inc hl 
1e54 22 eb f4		   	ld (os_cur_ptr),hl 
1e57			 
1e57 e1					pop hl 
1e58 23					inc hl 
1e59 23					inc hl 
1e5a 23					inc hl 
1e5b			 
1e5b			 
1e5b			 
1e5b					;ld a,0 
1e5b					;ld (os_word_scratch+2),a 
1e5b					;pop af 
1e5b					;push af 
1e5b			 
1e5b					;ld de, os_word_scratch 
1e5b					;call str_at_display 
1e5b			;		call update_display 
1e5b			;		pop af 
1e5b c1					pop bc 
1e5c c6 03				add 3 
1e5e 10 dd			djnz .dumpbyte 
1e60			 
1e60				 
1e60			 
1e60 c9				ret 
1e61			 
1e61			jump:	 
1e61			 
1e61 21 ca f1			ld hl,scratch+2 
1e64 cd 03 13			call get_word_hl 
1e67				;ld hl,(scratch+2) 
1e67				;call fourehexhl 
1e67			 
1e67 22 eb f4			ld (os_cur_ptr),hl	 
1e6a			 
1e6a e9				jp (hl) 
1e6b			 
1e6b			 
1e6b			 
1e6b			; TODO implement a basic monitor mode to start with 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			 
1e6b			; testing and demo code during development 
1e6b			 
1e6b			 
1e6b .. 00		str1: db "Enter some text...",0 
1e7e .. 00		clear: db "                    ",0 
1e93			 
1e93			demo: 
1e93			 
1e93			 
1e93			 
1e93			;	call update_display 
1e93			 
1e93				; init scratch input area for testing 
1e93 21 c8 f1			ld hl, scratch	 
1e96 3e 00			ld a,0 
1e98 77				ld (hl),a 
1e99			 
1e99			 
1e99 3e 28		            LD   A, display_row_2 
1e9b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e9b 11 6b 1e		            LD   DE, str1 
1e9e cd 2b 0d			call str_at_display 
1ea1			 
1ea1			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ea1			cloop:	 
1ea1 3e 50		            LD   A, display_row_3 
1ea3			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ea3 11 7e 1e		            LD   DE, clear 
1ea6			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1ea6 cd 2b 0d				call str_at_display 
1ea9 3e 78			ld a, display_row_4 
1eab 11 db 1e			ld de, prompt 
1eae			 
1eae cd 2b 0d				call str_at_display 
1eb1 cd 3b 0d			call update_display 
1eb4			 
1eb4 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1eb6 16 0a			ld d, 10 
1eb8 21 c8 f1			ld hl, scratch	 
1ebb cd 79 0f			call input_str 
1ebe			 
1ebe			;	call clear_display 
1ebe			;'	call update_display 
1ebe			 
1ebe 3e 00		            LD   A, display_row_1 
1ec0			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ec0 11 7e 1e		            LD   DE, clear 
1ec3 cd 2b 0d				call str_at_display 
1ec6			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ec6 3e 00		            LD   A, display_row_1 
1ec8			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ec8 11 c8 f1		            LD   DE, scratch 
1ecb			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ecb cd 2b 0d				call str_at_display 
1ece cd 3b 0d			call update_display 
1ed1			 
1ed1 3e 00				ld a,0 
1ed3 21 c8 f1			ld hl, scratch 
1ed6 77				ld (hl),a 
1ed7			 
1ed7 00				nop 
1ed8 c3 a1 1e			jp cloop 
1edb			 
1edb			 
1edb			 
1edb			; OS Prompt 
1edb			 
1edb .. 00		prompt: db ">",0 
1edd .. 00		endprg: db "?",0 
1edf			 
1edf			 
1edf			; handy next page prompt 
1edf			next_page_prompt: 
1edf e5				push hl 
1ee0 d5				push de 
1ee1 f5				push af 
1ee2 c5				push bc 
1ee3			 
1ee3 3e 9f			ld a,display_row_4 + display_cols - 1 
1ee5 11 dd 1e		        ld de, endprg 
1ee8 cd 2b 0d			call str_at_display 
1eeb cd 3b 0d			call update_display 
1eee cd 07 77			call cin_wait 
1ef1 c1				pop bc 
1ef2 f1				pop af 
1ef3 d1				pop de 
1ef4 e1				pop hl 
1ef5			 
1ef5			 
1ef5 c9				ret 
1ef6			 
1ef6			 
1ef6			; forth parser 
1ef6			 
1ef6			; My forth kernel 
1ef6			include "forth_kernel.asm" 
1ef6			; 
1ef6			; kernel to the forth OS 
1ef6			 
1ef6			DS_TYPE_STR: equ 1     ; string type 
1ef6			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1ef6			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1ef6			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1ef6			 
1ef6			FORTH_PARSEV1: equ 0 
1ef6			FORTH_PARSEV2: equ 0 
1ef6			FORTH_PARSEV3: equ 0 
1ef6			FORTH_PARSEV4: equ 0 
1ef6			FORTH_PARSEV5: equ 1 
1ef6			 
1ef6			;if FORTH_PARSEV5 
1ef6			;	FORTH_END_BUFFER: equ 0 
1ef6			;else 
1ef6			FORTH_END_BUFFER: equ 127 
1ef6			;endif 
1ef6			 
1ef6			FORTH_TRUE: equ 1 
1ef6			FORTH_FALSE: equ 0 
1ef6			 
1ef6			if FORTH_PARSEV4 
1ef6			include "forth_stackops.asm" 
1ef6			endif 
1ef6			 
1ef6			if FORTH_PARSEV5 
1ef6			include "forth_stackopsv5.asm" 
1ef6			 
1ef6			; Stack operations for v5 parser on wards 
1ef6			; * DATA stack 
1ef6			; * LOOP stack 
1ef6			; * RETURN stack 
1ef6			 
1ef6			 
1ef6			 
1ef6			FORTH_CHK_DSP_UNDER: macro 
1ef6				push hl 
1ef6				push de 
1ef6				ld hl,(cli_data_sp) 
1ef6				ld de, cli_data_stack 
1ef6				call cmp16 
1ef6				jp c, fault_dsp_under 
1ef6				pop de 
1ef6				pop hl 
1ef6				endm 
1ef6			 
1ef6			 
1ef6			FORTH_CHK_RSP_UNDER: macro 
1ef6				push hl 
1ef6				push de 
1ef6				ld hl,(cli_ret_sp) 
1ef6				ld de, cli_ret_stack 
1ef6				call cmp16 
1ef6				jp c, fault_rsp_under 
1ef6				pop de 
1ef6				pop hl 
1ef6				endm 
1ef6			 
1ef6			FORTH_CHK_LOOP_UNDER: macro 
1ef6				push hl 
1ef6				push de 
1ef6				ld hl,(cli_loop_sp) 
1ef6				ld de, cli_loop_stack 
1ef6				call cmp16 
1ef6				jp c, fault_loop_under 
1ef6				pop de 
1ef6				pop hl 
1ef6				endm 
1ef6			 
1ef6			FORTH_ERR_TOS_NOTSTR: macro 
1ef6				; TOSO might need more for checks when used 
1ef6				push af 
1ef6				ld a,(hl) 
1ef6				cp DS_TYPE_STR 
1ef6				jp nz, type_faultn   
1ef6				pop af 
1ef6				endm 
1ef6			 
1ef6			FORTH_ERR_TOS_NOTNUM: macro 
1ef6				push af 
1ef6				ld a,(hl) 
1ef6				cp DS_TYPE_INUM 
1ef6				jp nz, type_faultn   
1ef6				pop af 
1ef6				endm 
1ef6			 
1ef6			 
1ef6			; increase data stack pointer and save hl to it 
1ef6				 
1ef6			FORTH_DSP_NEXT: macro 
1ef6				call macro_forth_dsp_next 
1ef6				endm 
1ef6			 
1ef6			 
1ef6			macro_forth_dsp_next: 
1ef6				if DEBUG_FORTH_STACK_GUARD 
1ef6 cd 7f 70				call check_stacks 
1ef9				endif 
1ef9 e5				push hl 
1efa d5				push de 
1efb eb				ex de,hl 
1efc 2a f5 f9			ld hl,(cli_data_sp) 
1eff 23				inc hl 
1f00 23				inc hl 
1f01			 
1f01			; PARSEV5 
1f01 23				inc hl 
1f02 22 f5 f9			ld (cli_data_sp),hl 
1f05 73				ld (hl), e 
1f06 23				inc hl 
1f07 72				ld (hl), d 
1f08 d1				pop de 
1f09 e1				pop hl 
1f0a				if DEBUG_FORTH_STACK_GUARD 
1f0a cd 7f 70				call check_stacks 
1f0d				endif 
1f0d c9				ret 
1f0e			 
1f0e			 
1f0e			; increase ret stack pointer and save hl to it 
1f0e				 
1f0e			FORTH_RSP_NEXT: macro 
1f0e				call macro_forth_rsp_next 
1f0e				endm 
1f0e			 
1f0e			macro_forth_rsp_next: 
1f0e				if DEBUG_FORTH_STACK_GUARD 
1f0e cd 7f 70				call check_stacks 
1f11				endif 
1f11 e5				push hl 
1f12 d5				push de 
1f13 eb				ex de,hl 
1f14 2a f9 f9			ld hl,(cli_ret_sp) 
1f17 23				inc hl 
1f18 23				inc hl 
1f19 22 f9 f9			ld (cli_ret_sp),hl 
1f1c 73				ld (hl), e 
1f1d 23				inc hl 
1f1e 72				ld (hl), d 
1f1f d1				pop de 
1f20 e1				pop hl 
1f21				if DEBUG_FORTH_STACK_GUARD 
1f21 cd 7f 70				call check_stacks 
1f24				endif 
1f24 c9				ret 
1f25			 
1f25			; get current ret stack pointer and save to hl  
1f25				 
1f25			FORTH_RSP_TOS: macro 
1f25				call macro_forth_rsp_tos 
1f25				endm 
1f25			 
1f25			macro_forth_rsp_tos: 
1f25				;push de 
1f25 2a f9 f9			ld hl,(cli_ret_sp) 
1f28 cd 60 1f			call loadhlptrtohl 
1f2b				;ld e, (hl) 
1f2b				;inc hl 
1f2b				;ld d, (hl) 
1f2b				;ex de, hl 
1f2b					if DEBUG_FORTH_WORDS 
1f2b			;			DMARK "RST" 
1f2b						CALLMONITOR 
1f2b cd f3 18			call break_point_state  
1f2e				endm  
# End of macro CALLMONITOR
1f2e					endif 
1f2e				;pop de 
1f2e c9				ret 
1f2f			 
1f2f			; pop ret stack pointer 
1f2f				 
1f2f			FORTH_RSP_POP: macro 
1f2f				call macro_forth_rsp_pop 
1f2f				endm 
1f2f			 
1f2f			 
1f2f			macro_forth_rsp_pop: 
1f2f				if DEBUG_FORTH_STACK_GUARD 
1f2f			;		DMARK "RPP" 
1f2f cd 7f 70				call check_stacks 
1f32					FORTH_CHK_RSP_UNDER 
1f32 e5				push hl 
1f33 d5				push de 
1f34 2a f9 f9			ld hl,(cli_ret_sp) 
1f37 11 b3 f9			ld de, cli_ret_stack 
1f3a cd 6a 0f			call cmp16 
1f3d da 93 71			jp c, fault_rsp_under 
1f40 d1				pop de 
1f41 e1				pop hl 
1f42				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f42				endif 
1f42 e5				push hl 
1f43 2a f9 f9			ld hl,(cli_ret_sp) 
1f46			 
1f46			 
1f46				if FORTH_ENABLE_FREE 
1f46			 
1f46					; get pointer 
1f46			 
1f46					push de 
1f46					push hl 
1f46			 
1f46					ld e, (hl) 
1f46					inc hl 
1f46					ld d, (hl) 
1f46			 
1f46					ex de, hl 
1f46					call free 
1f46			 
1f46					pop hl 
1f46					pop de 
1f46			 
1f46			 
1f46				endif 
1f46			 
1f46			 
1f46 2b				dec hl 
1f47 2b				dec hl 
1f48 22 f9 f9			ld (cli_ret_sp), hl 
1f4b				; do stack underflow checks 
1f4b e1				pop hl 
1f4c				if DEBUG_FORTH_STACK_GUARD 
1f4c cd 7f 70				call check_stacks 
1f4f					FORTH_CHK_RSP_UNDER 
1f4f e5				push hl 
1f50 d5				push de 
1f51 2a f9 f9			ld hl,(cli_ret_sp) 
1f54 11 b3 f9			ld de, cli_ret_stack 
1f57 cd 6a 0f			call cmp16 
1f5a da 93 71			jp c, fault_rsp_under 
1f5d d1				pop de 
1f5e e1				pop hl 
1f5f				endm 
# End of macro FORTH_CHK_RSP_UNDER
1f5f				endif 
1f5f c9				ret 
1f60			 
1f60			 
1f60			 
1f60			; routine to load word pointed to by hl into hl 
1f60			 
1f60			loadhlptrtohl: 
1f60			 
1f60 d5				push de 
1f61 5e				ld e, (hl) 
1f62 23				inc hl 
1f63 56				ld d, (hl) 
1f64 eb				ex de, hl 
1f65 d1				pop de 
1f66			 
1f66 c9				ret 
1f67			 
1f67			 
1f67			 
1f67			 
1f67			 
1f67			; push a number held in HL onto the data stack 
1f67			; entry point for pushing a value when already in hl used in function above 
1f67			 
1f67			forth_push_numhl: 
1f67			 
1f67 e5				push hl    ; save value to push 
1f68			 
1f68			if DEBUG_FORTH_PUSH 
1f68				; see if disabled 
1f68			 
1f68			 
1f68 f5				push af 
1f69 3a b9 f1			ld a, (os_view_disable) 
1f6c fe 2a			cp '*' 
1f6e 28 34			jr z, .pskip2 
1f70 e5				push hl 
1f71 e5			push hl 
1f72 cd 18 0d			call clear_display 
1f75 e1			pop hl 
1f76 7c				ld a,h 
1f77 21 cd f4			ld hl, os_word_scratch 
1f7a cd 4d 12			call hexout 
1f7d e1				pop hl 
1f7e 7d				ld a,l 
1f7f 21 cf f4			ld hl, os_word_scratch+2 
1f82 cd 4d 12			call hexout 
1f85			 
1f85 21 d1 f4			ld hl, os_word_scratch+4 
1f88 3e 00			ld a,0 
1f8a 77				ld (hl),a 
1f8b 11 cd f4			ld de,os_word_scratch 
1f8e 3e 28				ld a, display_row_2 
1f90 cd 2b 0d				call str_at_display 
1f93 11 8e 5b			ld de, .push_num 
1f96 3e 00			ld a, display_row_1 
1f98			 
1f98 cd 2b 0d				call str_at_display 
1f9b			 
1f9b			 
1f9b cd 3b 0d			call update_display 
1f9e cd 95 0c			call delay1s 
1fa1 cd 95 0c			call delay1s 
1fa4			.pskip2:  
1fa4			 
1fa4 f1				pop af 
1fa5			endif	 
1fa5			 
1fa5			 
1fa5				FORTH_DSP_NEXT 
1fa5 cd f6 1e			call macro_forth_dsp_next 
1fa8				endm 
# End of macro FORTH_DSP_NEXT
1fa8			 
1fa8 2a f5 f9			ld hl, (cli_data_sp) 
1fab			 
1fab				; save item type 
1fab 3e 02			ld a,  DS_TYPE_INUM 
1fad 77				ld (hl), a 
1fae 23				inc hl 
1faf			 
1faf				; get word off stack 
1faf d1				pop de 
1fb0 7b				ld a,e 
1fb1 77				ld (hl), a 
1fb2 23				inc hl 
1fb3 7a				ld a,d 
1fb4 77				ld (hl), a 
1fb5			 
1fb5			if DEBUG_FORTH_PUSH 
1fb5 2b				dec hl 
1fb6 2b				dec hl 
1fb7 2b				dec hl 
1fb8						DMARK "PH5" 
1fb8 f5				push af  
1fb9 3a cd 1f			ld a, (.dmark)  
1fbc 32 6e fe			ld (debug_mark),a  
1fbf 3a ce 1f			ld a, (.dmark+1)  
1fc2 32 6f fe			ld (debug_mark+1),a  
1fc5 3a cf 1f			ld a, (.dmark+2)  
1fc8 32 70 fe			ld (debug_mark+2),a  
1fcb 18 03			jr .pastdmark  
1fcd ..			.dmark: db "PH5"  
1fd0 f1			.pastdmark: pop af  
1fd1			endm  
# End of macro DMARK
1fd1				CALLMONITOR 
1fd1 cd f3 18			call break_point_state  
1fd4				endm  
# End of macro CALLMONITOR
1fd4			endif	 
1fd4			 
1fd4 c9				ret 
1fd5			 
1fd5			 
1fd5			; Push a string to stack pointed to by hl 
1fd5			 
1fd5			forth_push_str: 
1fd5			 
1fd5			if DEBUG_FORTH_PUSH 
1fd5						DMARK "PSQ" 
1fd5 f5				push af  
1fd6 3a ea 1f			ld a, (.dmark)  
1fd9 32 6e fe			ld (debug_mark),a  
1fdc 3a eb 1f			ld a, (.dmark+1)  
1fdf 32 6f fe			ld (debug_mark+1),a  
1fe2 3a ec 1f			ld a, (.dmark+2)  
1fe5 32 70 fe			ld (debug_mark+2),a  
1fe8 18 03			jr .pastdmark  
1fea ..			.dmark: db "PSQ"  
1fed f1			.pastdmark: pop af  
1fee			endm  
# End of macro DMARK
1fee				CALLMONITOR 
1fee cd f3 18			call break_point_state  
1ff1				endm  
# End of macro CALLMONITOR
1ff1			endif	 
1ff1			    
1ff1 e5				push hl 
1ff2 e5				push hl 
1ff3			 
1ff3			;	ld a, 0   ; find end of string 
1ff3 cd aa 13			call strlenz 
1ff6			if DEBUG_FORTH_PUSH 
1ff6						DMARK "PQ2" 
1ff6 f5				push af  
1ff7 3a 0b 20			ld a, (.dmark)  
1ffa 32 6e fe			ld (debug_mark),a  
1ffd 3a 0c 20			ld a, (.dmark+1)  
2000 32 6f fe			ld (debug_mark+1),a  
2003 3a 0d 20			ld a, (.dmark+2)  
2006 32 70 fe			ld (debug_mark+2),a  
2009 18 03			jr .pastdmark  
200b ..			.dmark: db "PQ2"  
200e f1			.pastdmark: pop af  
200f			endm  
# End of macro DMARK
200f				CALLMONITOR 
200f cd f3 18			call break_point_state  
2012				endm  
# End of macro CALLMONITOR
2012			endif	 
2012 eb				ex de, hl 
2013 e1				pop hl   ; get ptr to start of string 
2014			if DEBUG_FORTH_PUSH 
2014						DMARK "PQ3" 
2014 f5				push af  
2015 3a 29 20			ld a, (.dmark)  
2018 32 6e fe			ld (debug_mark),a  
201b 3a 2a 20			ld a, (.dmark+1)  
201e 32 6f fe			ld (debug_mark+1),a  
2021 3a 2b 20			ld a, (.dmark+2)  
2024 32 70 fe			ld (debug_mark+2),a  
2027 18 03			jr .pastdmark  
2029 ..			.dmark: db "PQ3"  
202c f1			.pastdmark: pop af  
202d			endm  
# End of macro DMARK
202d				CALLMONITOR 
202d cd f3 18			call break_point_state  
2030				endm  
# End of macro CALLMONITOR
2030			endif	 
2030 19				add hl,de 
2031			if DEBUG_FORTH_PUSH 
2031						DMARK "PQE" 
2031 f5				push af  
2032 3a 46 20			ld a, (.dmark)  
2035 32 6e fe			ld (debug_mark),a  
2038 3a 47 20			ld a, (.dmark+1)  
203b 32 6f fe			ld (debug_mark+1),a  
203e 3a 48 20			ld a, (.dmark+2)  
2041 32 70 fe			ld (debug_mark+2),a  
2044 18 03			jr .pastdmark  
2046 ..			.dmark: db "PQE"  
2049 f1			.pastdmark: pop af  
204a			endm  
# End of macro DMARK
204a				CALLMONITOR 
204a cd f3 18			call break_point_state  
204d				endm  
# End of macro CALLMONITOR
204d			endif	 
204d			 
204d 2b				dec hl    ; see if there is an optional trailing double quote 
204e 7e				ld a,(hl) 
204f fe 22			cp '"' 
2051 20 03			jr nz, .strnoq 
2053 3e 00			ld a, 0      ; get rid of double quote 
2055 77				ld (hl), a 
2056 23			.strnoq: inc hl 
2057			 
2057 3e 00			ld a, 0 
2059 77				ld (hl), a     ; add null term and get rid of trailing double quote 
205a			 
205a 13				inc de ; add one for the type string 
205b 13				inc de ; add one for null term??? 
205c			 
205c				; tos is get string pointer again 
205c				; de contains space to allocate 
205c				 
205c d5				push de 
205d			 
205d eb				ex de, hl 
205e			 
205e				;push af 
205e			 
205e			if DEBUG_FORTH_PUSH 
205e						DMARK "PHm" 
205e f5				push af  
205f 3a 73 20			ld a, (.dmark)  
2062 32 6e fe			ld (debug_mark),a  
2065 3a 74 20			ld a, (.dmark+1)  
2068 32 6f fe			ld (debug_mark+1),a  
206b 3a 75 20			ld a, (.dmark+2)  
206e 32 70 fe			ld (debug_mark+2),a  
2071 18 03			jr .pastdmark  
2073 ..			.dmark: db "PHm"  
2076 f1			.pastdmark: pop af  
2077			endm  
# End of macro DMARK
2077				CALLMONITOR 
2077 cd f3 18			call break_point_state  
207a				endm  
# End of macro CALLMONITOR
207a			endif	 
207a cd 13 14			call malloc	; on ret hl now contains allocated memory 
207d				if DEBUG_FORTH_MALLOC_GUARD 
207d cc e6 5b				call z,malloc_error 
2080				endif 
2080			 
2080				 
2080 c1				pop bc    ; get length 
2081 d1				pop de   ;  get string start    
2082			 
2082				; hl has destination from malloc 
2082			 
2082 eb				ex de, hl    ; prep for ldir 
2083			 
2083 d5				push de   ; save malloc area for DSP later 
2084				;push hl   ; save malloc area for DSP later 
2084			 
2084			if DEBUG_FORTH_PUSH 
2084						DMARK "PHc" 
2084 f5				push af  
2085 3a 99 20			ld a, (.dmark)  
2088 32 6e fe			ld (debug_mark),a  
208b 3a 9a 20			ld a, (.dmark+1)  
208e 32 6f fe			ld (debug_mark+1),a  
2091 3a 9b 20			ld a, (.dmark+2)  
2094 32 70 fe			ld (debug_mark+2),a  
2097 18 03			jr .pastdmark  
2099 ..			.dmark: db "PHc"  
209c f1			.pastdmark: pop af  
209d			endm  
# End of macro DMARK
209d				CALLMONITOR 
209d cd f3 18			call break_point_state  
20a0				endm  
# End of macro CALLMONITOR
20a0			endif	 
20a0			 
20a0			 
20a0 ed b0			ldir 
20a2			 
20a2			 
20a2				; push malloc to data stack     macro?????  
20a2			 
20a2				FORTH_DSP_NEXT 
20a2 cd f6 1e			call macro_forth_dsp_next 
20a5				endm 
# End of macro FORTH_DSP_NEXT
20a5			 
20a5				; save value and type 
20a5			 
20a5 2a f5 f9			ld hl, (cli_data_sp) 
20a8			 
20a8				; save item type 
20a8 3e 01			ld a,  DS_TYPE_STR 
20aa 77				ld (hl), a 
20ab 23				inc hl 
20ac			 
20ac				; get malloc word off stack 
20ac d1				pop de 
20ad 73				ld (hl), e 
20ae 23				inc hl 
20af 72				ld (hl), d 
20b0			 
20b0			 
20b0			 
20b0			if DEBUG_FORTH_PUSH 
20b0 2a f5 f9			ld hl, (cli_data_sp) 
20b3						DMARK "PHS" 
20b3 f5				push af  
20b4 3a c8 20			ld a, (.dmark)  
20b7 32 6e fe			ld (debug_mark),a  
20ba 3a c9 20			ld a, (.dmark+1)  
20bd 32 6f fe			ld (debug_mark+1),a  
20c0 3a ca 20			ld a, (.dmark+2)  
20c3 32 70 fe			ld (debug_mark+2),a  
20c6 18 03			jr .pastdmark  
20c8 ..			.dmark: db "PHS"  
20cb f1			.pastdmark: pop af  
20cc			endm  
# End of macro DMARK
20cc				CALLMONITOR 
20cc cd f3 18			call break_point_state  
20cf				endm  
# End of macro CALLMONITOR
20cf			;	ex de,hl 
20cf			endif	 
20cf				; in case of spaces, skip the ptr past the copied string 
20cf				;pop af 
20cf				;ld (cli_origptr),hl 
20cf			 
20cf c9				ret 
20d0			 
20d0			 
20d0			 
20d0			; TODO ascii push input onto stack given hl to start of input 
20d0			 
20d0			; identify type 
20d0			; if starts with a " then a string 
20d0			; otherwise it is a number 
20d0			;  
20d0			; if a string 
20d0			;     scan for ending " to get length of string to malloc for + 1 
20d0			;     malloc 
20d0			;     put pointer to string on stack first byte flags as string 
20d0			; 
20d0			; else a number 
20d0			;    look for number format identifier 
20d0			;    $xx hex 
20d0			;    %xxxxx bin 
20d0			;    xxxxx decimal 
20d0			;    convert number to 16bit word.  
20d0			;    malloc word + 1 with flag to identiy as num 
20d0			;    put pointer to number on stack 
20d0			;   
20d0			;  
20d0			  
20d0			forth_apush: 
20d0				; kernel push 
20d0			 
20d0			if DEBUG_FORTH_PUSH 
20d0						DMARK "PSH" 
20d0 f5				push af  
20d1 3a e5 20			ld a, (.dmark)  
20d4 32 6e fe			ld (debug_mark),a  
20d7 3a e6 20			ld a, (.dmark+1)  
20da 32 6f fe			ld (debug_mark+1),a  
20dd 3a e7 20			ld a, (.dmark+2)  
20e0 32 70 fe			ld (debug_mark+2),a  
20e3 18 03			jr .pastdmark  
20e5 ..			.dmark: db "PSH"  
20e8 f1			.pastdmark: pop af  
20e9			endm  
# End of macro DMARK
20e9				CALLMONITOR 
20e9 cd f3 18			call break_point_state  
20ec				endm  
# End of macro CALLMONITOR
20ec			endif	 
20ec				; identify input type 
20ec			 
20ec 7e				ld a,(hl) 
20ed fe 22			cp '"' 
20ef 28 0a			jr z, .fapstr 
20f1 fe 24			cp '$' 
20f3 ca 1b 21			jp z, .faphex 
20f6 fe 25			cp '%' 
20f8 ca 03 21			jp z, .fapbin 
20fb			;	cp 'b' 
20fb			;	jp z, .fabin 
20fb				; else decimal 
20fb			 
20fb				; TODO do decimal conversion 
20fb				; decimal is stored as a 16bit word 
20fb			 
20fb				; by default everything is a string if type is not detected 
20fb			.fapstr: ; 
20fb fe 22			cp '"' 
20fd 20 01			jr nz, .strnoqu 
20ff 23				inc hl 
2100			.strnoqu: 
2100 c3 d5 1f			jp forth_push_str 
2103			 
2103			 
2103			 
2103			.fapbin:    ; push a binary string.  
2103 11 00 00			ld de, 0   ; hold a 16bit value 
2106			 
2106 23			.fapbinshift:	inc hl  
2107 7e				ld a,(hl) 
2108 fe 00			cp 0     ; done scanning  
210a 28 0b			jr z, .fapbdone  	; got it in HL so push  
210c			 
210c				; left shift de 
210c eb				ex de, hl	 
210d 29				add hl, hl 
210e			 
210e				; is 1 
210e fe 31			cp '1' 
2110 20 02			jr nz, .binzero 
2112 cb 4d			bit 1, l 
2114			.binzero: 
2114 eb				ex de, hl	 ; save current de 
2115 18 ef			jr .fapbinshift 
2117			 
2117			.fapbdone: 
2117 eb				ex de, hl 
2118 c3 67 1f			jp forth_push_numhl 
211b			 
211b			 
211b			.faphex:   ; hex is always stored as a 16bit word 
211b				; skip number prefix 
211b 23				inc hl 
211c				; turn ascii into number 
211c cd 03 13			call get_word_hl	; ret 16bit word in hl 
211f			 
211f c3 67 1f			jp forth_push_numhl 
2122			 
2122 00				 nop 
2123			 
2123			.fabin:   ; TODO bin conversion 
2123			 
2123			 
2123 c9				ret 
2124			 
2124			 
2124			; get either a string ptr or a 16bit word from the data stack 
2124			 
2124			FORTH_DSP: macro 
2124				call macro_forth_dsp 
2124				endm 
2124			 
2124			macro_forth_dsp: 
2124				; data stack pointer points to current word on tos 
2124			 
2124 2a f5 f9			ld hl,(cli_data_sp) 
2127			 
2127				if DEBUG_FORTH_PUSH 
2127						DMARK "DSP" 
2127 f5				push af  
2128 3a 3c 21			ld a, (.dmark)  
212b 32 6e fe			ld (debug_mark),a  
212e 3a 3d 21			ld a, (.dmark+1)  
2131 32 6f fe			ld (debug_mark+1),a  
2134 3a 3e 21			ld a, (.dmark+2)  
2137 32 70 fe			ld (debug_mark+2),a  
213a 18 03			jr .pastdmark  
213c ..			.dmark: db "DSP"  
213f f1			.pastdmark: pop af  
2140			endm  
# End of macro DMARK
2140			 
2140 cd 1b 5c				call display_data_sp 
2143				;call break_point_state 
2143				;rst 030h 
2143				CALLMONITOR 
2143 cd f3 18			call break_point_state  
2146				endm  
# End of macro CALLMONITOR
2146				endif 
2146			 
2146 c9				ret 
2147			 
2147			; return hl to start of value on stack 
2147			 
2147			FORTH_DSP_VALUE: macro 
2147				call macro_forth_dsp_value 
2147				endm 
2147			 
2147			macro_forth_dsp_value: 
2147			 
2147				FORTH_DSP 
2147 cd 24 21			call macro_forth_dsp 
214a				endm 
# End of macro FORTH_DSP
214a			 
214a d5				push de 
214b			 
214b 23				inc hl ; skip type 
214c			 
214c 5e				ld e, (hl) 
214d 23				inc hl 
214e 56				ld d, (hl) 
214f eb				ex de,hl  
2150			 
2150 d1				pop de 
2151			 
2151 c9				ret 
2152			 
2152			; return hl to start of value to second item on stack 
2152			 
2152			FORTH_DSP_VALUEM1: macro 
2152				call macro_forth_dsp_value_m1 
2152				endm 
2152			 
2152			macro_forth_dsp_value_m1: 
2152			 
2152				FORTH_DSP 
2152 cd 24 21			call macro_forth_dsp 
2155				endm 
# End of macro FORTH_DSP
2155			 
2155 2b				dec hl 
2156 2b				dec hl 
2157			;	dec hl 
2157			 
2157 d5				push de 
2158			 
2158 5e				ld e, (hl) 
2159 23				inc hl 
215a 56				ld d, (hl) 
215b eb				ex de,hl  
215c			 
215c d1				pop de 
215d			 
215d c9				ret 
215e			 
215e				 
215e			 
215e			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
215e			 
215e			FORTH_DSP_POP: macro 
215e				call macro_forth_dsp_pop 
215e				endm 
215e			 
215e			 
215e			; get the tos data type 
215e			 
215e			FORTH_DSP_TYPE:   macro 
215e			 
215e				;FORTH_DSP_VALUE 
215e				FORTH_DSP 
215e				 
215e				; hl points to value 
215e				; check type 
215e			 
215e				ld a,(hl) 
215e			 
215e				endm 
215e			 
215e			; load the tos value into hl 
215e			 
215e			 
215e			FORTH_DSP_VALUEHL:  macro 
215e				call macro_dsp_valuehl 
215e				endm 
215e			 
215e			 
215e			 
215e			macro_dsp_valuehl: 
215e				FORTH_DSP_VALUE 
215e cd 47 21			call macro_forth_dsp_value 
2161				endm 
# End of macro FORTH_DSP_VALUE
2161			 
2161				;FORTH_ERR_TOS_NOTNUM 
2161			 
2161				;inc hl   ; skip type id 
2161			 
2161			;	push de 
2161			; 
2161			;	ld e, (hl) 
2161			;	inc hl 
2161			;	ld d, (hl) 
2161			;	ex de,hl  
2161			 
2161			;	pop de 
2161			 
2161				if DEBUG_FORTH_PUSH 
2161						DMARK "DVL" 
2161 f5				push af  
2162 3a 76 21			ld a, (.dmark)  
2165 32 6e fe			ld (debug_mark),a  
2168 3a 77 21			ld a, (.dmark+1)  
216b 32 6f fe			ld (debug_mark+1),a  
216e 3a 78 21			ld a, (.dmark+2)  
2171 32 70 fe			ld (debug_mark+2),a  
2174 18 03			jr .pastdmark  
2176 ..			.dmark: db "DVL"  
2179 f1			.pastdmark: pop af  
217a			endm  
# End of macro DMARK
217a				CALLMONITOR 
217a cd f3 18			call break_point_state  
217d				endm  
# End of macro CALLMONITOR
217d				endif 
217d c9				ret 
217e			 
217e			forth_apushstrhl:      
217e				; push of string requires use of cli_origptr 
217e				; bodge use 
217e			 
217e				; get current cli_origptr, save, update with temp pointer  
217e ed 5b 45 fa		ld de, (cli_origptr) 
2182 22 45 fa			ld (cli_origptr), hl 
2185 d5				push de 
2186 cd d0 20			call forth_apush 
2189 d1				pop de 
218a ed 53 45 fa		ld (cli_origptr), de 
218e c9			        ret	 
218f			 
218f			 
218f			; increase loop stack pointer and save hl to it 
218f				 
218f			FORTH_LOOP_NEXT: macro 
218f				call macro_forth_loop_next 
218f				;nop 
218f				endm 
218f			 
218f			macro_forth_loop_next: 
218f				if DEBUG_FORTH_STACK_GUARD 
218f cd 7f 70				call check_stacks 
2192				endif 
2192 e5				push hl 
2193 d5				push de 
2194 eb				ex de,hl 
2195 2a f7 f9			ld hl,(cli_loop_sp) 
2198 23				inc hl 
2199 23				inc hl 
219a					if DEBUG_FORTH_WORDS 
219a						DMARK "LNX" 
219a f5				push af  
219b 3a af 21			ld a, (.dmark)  
219e 32 6e fe			ld (debug_mark),a  
21a1 3a b0 21			ld a, (.dmark+1)  
21a4 32 6f fe			ld (debug_mark+1),a  
21a7 3a b1 21			ld a, (.dmark+2)  
21aa 32 70 fe			ld (debug_mark+2),a  
21ad 18 03			jr .pastdmark  
21af ..			.dmark: db "LNX"  
21b2 f1			.pastdmark: pop af  
21b3			endm  
# End of macro DMARK
21b3						CALLMONITOR 
21b3 cd f3 18			call break_point_state  
21b6				endm  
# End of macro CALLMONITOR
21b6					endif 
21b6 22 f7 f9			ld (cli_loop_sp),hl 
21b9 73				ld (hl), e 
21ba 23				inc hl 
21bb 72				ld (hl), d 
21bc d1				pop de    ; been reversed so save a swap on restore 
21bd e1				pop hl 
21be				if DEBUG_FORTH_STACK_GUARD 
21be cd 7f 70				call check_stacks 
21c1				endif 
21c1 c9				ret 
21c2			 
21c2			; get current ret stack pointer and save to hl  
21c2				 
21c2			FORTH_LOOP_TOS: macro 
21c2				call macro_forth_loop_tos 
21c2				endm 
21c2			 
21c2			macro_forth_loop_tos: 
21c2 d5				push de 
21c3 2a f7 f9			ld hl,(cli_loop_sp) 
21c6 5e				ld e, (hl) 
21c7 23				inc hl 
21c8 56				ld d, (hl) 
21c9 eb				ex de, hl 
21ca d1				pop de 
21cb c9				ret 
21cc			 
21cc			; pop loop stack pointer 
21cc				 
21cc			FORTH_LOOP_POP: macro 
21cc				call macro_forth_loop_pop 
21cc				endm 
21cc			 
21cc			 
21cc			macro_forth_loop_pop: 
21cc				if DEBUG_FORTH_STACK_GUARD 
21cc					DMARK "LPP" 
21cc f5				push af  
21cd 3a e1 21			ld a, (.dmark)  
21d0 32 6e fe			ld (debug_mark),a  
21d3 3a e2 21			ld a, (.dmark+1)  
21d6 32 6f fe			ld (debug_mark+1),a  
21d9 3a e3 21			ld a, (.dmark+2)  
21dc 32 70 fe			ld (debug_mark+2),a  
21df 18 03			jr .pastdmark  
21e1 ..			.dmark: db "LPP"  
21e4 f1			.pastdmark: pop af  
21e5			endm  
# End of macro DMARK
21e5 cd 7f 70				call check_stacks 
21e8					FORTH_CHK_LOOP_UNDER 
21e8 e5				push hl 
21e9 d5				push de 
21ea 2a f7 f9			ld hl,(cli_loop_sp) 
21ed 11 31 f9			ld de, cli_loop_stack 
21f0 cd 6a 0f			call cmp16 
21f3 da 99 71			jp c, fault_loop_under 
21f6 d1				pop de 
21f7 e1				pop hl 
21f8				endm 
# End of macro FORTH_CHK_LOOP_UNDER
21f8				endif 
21f8 e5				push hl 
21f9 2a f7 f9			ld hl,(cli_loop_sp) 
21fc 2b				dec hl 
21fd 2b				dec hl 
21fe 22 f7 f9			ld (cli_loop_sp), hl 
2201				; TODO do stack underflow checks 
2201 e1				pop hl 
2202				if DEBUG_FORTH_STACK_GUARD 
2202 cd 7f 70				call check_stacks 
2205					FORTH_CHK_LOOP_UNDER 
2205 e5				push hl 
2206 d5				push de 
2207 2a f7 f9			ld hl,(cli_loop_sp) 
220a 11 31 f9			ld de, cli_loop_stack 
220d cd 6a 0f			call cmp16 
2210 da 99 71			jp c, fault_loop_under 
2213 d1				pop de 
2214 e1				pop hl 
2215				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2215				endif 
2215 c9				ret 
2216			 
2216			macro_forth_dsp_pop: 
2216			 
2216 e5				push hl 
2217			 
2217				; release malloc data 
2217			 
2217				if DEBUG_FORTH_STACK_GUARD 
2217 cd 7f 70				call check_stacks 
221a					FORTH_CHK_DSP_UNDER 
221a e5				push hl 
221b d5				push de 
221c 2a f5 f9			ld hl,(cli_data_sp) 
221f 11 2f f7			ld de, cli_data_stack 
2222 cd 6a 0f			call cmp16 
2225 da 8d 71			jp c, fault_dsp_under 
2228 d1				pop de 
2229 e1				pop hl 
222a				endm 
# End of macro FORTH_CHK_DSP_UNDER
222a				endif 
222a				;ld hl,(cli_data_sp) 
222a			if DEBUG_FORTH_DOT 
222a				DMARK "DPP" 
222a f5				push af  
222b 3a 3f 22			ld a, (.dmark)  
222e 32 6e fe			ld (debug_mark),a  
2231 3a 40 22			ld a, (.dmark+1)  
2234 32 6f fe			ld (debug_mark+1),a  
2237 3a 41 22			ld a, (.dmark+2)  
223a 32 70 fe			ld (debug_mark+2),a  
223d 18 03			jr .pastdmark  
223f ..			.dmark: db "DPP"  
2242 f1			.pastdmark: pop af  
2243			endm  
# End of macro DMARK
2243				CALLMONITOR 
2243 cd f3 18			call break_point_state  
2246				endm  
# End of macro CALLMONITOR
2246			endif	 
2246			 
2246			 
2246			if FORTH_ENABLE_DSPPOPFREE 
2246			 
2246				FORTH_DSP 
2246 cd 24 21			call macro_forth_dsp 
2249				endm 
# End of macro FORTH_DSP
2249			 
2249 7e				ld a, (hl) 
224a fe 01			cp DS_TYPE_STR 
224c 20 23			jr nz, .skippopfree 
224e			 
224e				FORTH_DSP_VALUEHL 
224e cd 5e 21			call macro_dsp_valuehl 
2251				endm 
# End of macro FORTH_DSP_VALUEHL
2251 00				nop 
2252			if DEBUG_FORTH_DOT 
2252				DMARK "DPf" 
2252 f5				push af  
2253 3a 67 22			ld a, (.dmark)  
2256 32 6e fe			ld (debug_mark),a  
2259 3a 68 22			ld a, (.dmark+1)  
225c 32 6f fe			ld (debug_mark+1),a  
225f 3a 69 22			ld a, (.dmark+2)  
2262 32 70 fe			ld (debug_mark+2),a  
2265 18 03			jr .pastdmark  
2267 ..			.dmark: db "DPf"  
226a f1			.pastdmark: pop af  
226b			endm  
# End of macro DMARK
226b				CALLMONITOR 
226b cd f3 18			call break_point_state  
226e				endm  
# End of macro CALLMONITOR
226e			endif	 
226e cd dd 14			call free 
2271			.skippopfree: 
2271				 
2271			 
2271			endif 
2271			 
2271			if DEBUG_FORTH_DOT_KEY 
2271				DMARK "DP2" 
2271				CALLMONITOR 
2271			endif	 
2271			 
2271				; move pointer down 
2271			 
2271 2a f5 f9			ld hl,(cli_data_sp) 
2274 2b				dec hl 
2275 2b				dec hl 
2276			; PARSEV5 
2276 2b				dec hl 
2277 22 f5 f9			ld (cli_data_sp), hl 
227a			 
227a				if DEBUG_FORTH_STACK_GUARD 
227a cd 7f 70				call check_stacks 
227d					FORTH_CHK_DSP_UNDER 
227d e5				push hl 
227e d5				push de 
227f 2a f5 f9			ld hl,(cli_data_sp) 
2282 11 2f f7			ld de, cli_data_stack 
2285 cd 6a 0f			call cmp16 
2288 da 8d 71			jp c, fault_dsp_under 
228b d1				pop de 
228c e1				pop hl 
228d				endm 
# End of macro FORTH_CHK_DSP_UNDER
228d				endif 
228d			 
228d e1				pop hl 
228e			 
228e c9				ret 
228f			 
228f			getwordathl: 
228f				; hl points to an address 
228f				; load hl with the word at that address 
228f			 
228f d5				push de 
2290			 
2290 5e				ld e, (hl) 
2291 23				inc hl 
2292 56				ld d, (hl) 
2293 eb				ex de, hl 
2294			 
2294 d1				pop de 
2295 c9				ret 
2296			 
2296			 
2296			 
2296			 
2296			 
2296			; eof 
2296			 
# End of file forth_stackopsv5.asm
2296			endif 
2296			 
2296			loadwordinhl:	 
2296			 
2296 d5				push de 
2297			 
2297 5e				ld e, (hl) 
2298 23				inc hl 
2299 56				ld d, (hl) 
229a eb				ex de,hl  
229b			 
229b d1				pop de 
229c			 
229c c9				ret 
229d			 
229d			user_word_eol:  
229d				; hl contains the pointer to where to create a linked list item from the end 
229d				; of the user dict to continue on at the system word dict 
229d				 
229d				; poke the stub of the word list linked list to repoint to rom words 
229d			 
229d				; stub format 
229d				; db   word id 
229d				; dw    link to next word 
229d			        ; db char length of token 
229d				; db string + 0 term 
229d				; db exec code....  
229d			 
229d 3e 00			ld a, WORD_SYS_ROOT     ; root word 
229f 77				ld (hl), a		; word id 
22a0 23				inc hl 
22a1			 
22a1 11 6c 24			ld de, sysdict 
22a4 73				ld (hl), e		; next word link ie system dict 
22a5 23				inc hl 
22a6 72				ld (hl), d		; next word link ie system dict 
22a7 23				inc hl	 
22a8			 
22a8			;	ld (hl), sysdict		; next word link ie system dict 
22a8			;	inc hl 
22a8			;	inc hl 
22a8			 
22a8			;	inc hl 
22a8			;	inc hl 
22a8			 
22a8 3e 02			ld a, 2			; word length is 0 
22aa 77				ld (hl), a	 
22ab 23				inc hl 
22ac			 
22ac 3e 7e			ld a, '~'			; word length is 0 
22ae 77				ld (hl), a	 
22af 23				inc hl 
22b0 3e 00			ld a, 0			; save empty word 
22b2 77				ld (hl), a 
22b3			 
22b3 c9				ret 
22b4			 
22b4				 
22b4			 
22b4			forthexec_cleanup: 
22b4				FORTH_RSP_POP 
22b4 cd 2f 1f			call macro_forth_rsp_pop 
22b7				endm 
# End of macro FORTH_RSP_POP
22b7 c9				ret 
22b8			 
22b8			forth_call_hl: 
22b8				; taking hl 
22b8 e5				push hl 
22b9 c9				ret 
22ba			 
22ba			; this is called to reset Forth system but keep existing uwords etc 
22ba			 
22ba			forth_warmstart: 
22ba				; setup stack over/under flow checks 
22ba				if DEBUG_FORTH_STACK_GUARD 
22ba cd 65 70				call chk_stk_init 
22bd				endif 
22bd			 
22bd				; init stack pointers  - * these stacks go upwards *  
22bd 21 b3 f9			ld hl, cli_ret_stack 
22c0 22 f9 f9			ld (cli_ret_sp), hl	 
22c3				; set bottom of stack 
22c3 3e 00			ld a,0 
22c5 77				ld (hl),a 
22c6 23				inc hl 
22c7 77				ld (hl),a 
22c8			 
22c8 21 2f f7			ld hl, cli_data_stack 
22cb 22 f5 f9			ld (cli_data_sp), hl	 
22ce				; set bottom of stack 
22ce 3e 00			ld a,0 
22d0 77				ld (hl),a 
22d1 23				inc hl 
22d2 77				ld (hl),a 
22d3			 
22d3 21 31 f9			ld hl, cli_loop_stack 
22d6 22 f7 f9			ld (cli_loop_sp), hl	 
22d9				; set bottom of stack 
22d9 3e 00			ld a,0 
22db 77				ld (hl),a 
22dc 23				inc hl 
22dd 77				ld (hl),a 
22de			 
22de				; init extent of current open file 
22de			 
22de 3e 00			ld a, 0 
22e0 32 71 fa			ld (store_openext), a 
22e3			 
22e3 c9				ret 
22e4			 
22e4			 
22e4			; Cold Start - this is called to setup the whole Forth system 
22e4			 
22e4			forth_init: 
22e4			 
22e4				; setup stack over/under flow checks 
22e4			 
22e4			;	if DEBUG_FORTH_STACK_GUARD 
22e4			;		call chk_stk_init 
22e4			;	endif 
22e4			 
22e4				; enable auto display updates (slow.....) 
22e4			 
22e4 3e 01			ld a, 1 
22e6 32 43 fa			ld (cli_autodisplay), a 
22e9			 
22e9				; if storage is in use disable long reads for now 
22e9 3e 00			ld a, 0 
22eb 32 7c fa			ld (store_longread), a 
22ee			 
22ee			 
22ee				; show start up screen 
22ee			 
22ee cd 18 0d			call clear_display 
22f1			 
22f1 3e 00			ld a,0 
22f3 32 65 fa			ld (f_cursor_ptr), a 
22f6			 
22f6				; set start of word list in start of ram - for use when creating user words 
22f6			 
22f6 21 00 80			ld hl, baseram 
22f9 22 c5 f4			ld (os_last_new_uword), hl 
22fc cd 9d 22			call user_word_eol 
22ff				 
22ff			;		call display_data_sp 
22ff			;		call next_page_prompt 
22ff			 
22ff			 
22ff			 
22ff			 
22ff c9				ret 
2300			 
2300 .. 00		.bootforth: db " Forth Kernel Init ",0 
2314			 
2314			; TODO push to stack 
2314			 
2314			;  
2314			 
2314			if FORTH_PARSEV2 
2314			 
2314			 
2314				include "forth_parserv2.asm" 
2314			 
2314			endif 
2314			 
2314			 
2314			; parse cli version 1 
2314			 
2314			if FORTH_PARSEV1 
2314			 
2314			 
2314			 
2314			      include "forth_parserv1.asm" 
2314			endif 
2314				 
2314			if FORTH_PARSEV3 
2314			 
2314			 
2314			 
2314			      include "forth_parserv3.asm" 
2314				include "forth_wordsv3.asm" 
2314			endif 
2314			 
2314			if FORTH_PARSEV4 
2314			 
2314			 
2314			 
2314			      include "forth_parserv4.asm" 
2314				include "forth_wordsv4.asm" 
2314			endif 
2314			 
2314			if FORTH_PARSEV5 
2314			 
2314			 
2314			 
2314			      include "forth_parserv5.asm" 
2314			 
2314			 
2314			; A better parser without using malloc and string copies all over the place.  
2314			; Exec in situ should be faster 
2314			 
2314			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2314			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2314			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2314			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2314			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2314			WORD_SYS_END: equ 0   ; Opcode for all user words 
2314			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2314			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2314			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2314			 
2314			; Core word preamble macro 
2314			 
2314			CWHEAD:   macro nxtword opcode lit len opflags 
2314				db WORD_SYS_CORE+opcode             
2314				; internal op code number 
2314				dw nxtword            
2314				; link to next dict word block 
2314				db len + 1 
2314				; literal length of dict word inc zero term 
2314				db lit,0              
2314				; literal dict word 
2314			        ; TODO db opflags        
2314				endm 
2314			 
2314			 
2314			NEXTW: macro  
2314				jp macro_next 
2314				endm 
2314			 
2314			macro_next: 
2314			if DEBUG_FORTH_PARSE_KEY 
2314				DMARK "NXT" 
2314				CALLMONITOR 
2314			endif	 
2314			;	inc hl  ; skip token null term  
2314 ed 4b 47 fa		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2318 ed 5b 45 fa		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
231c 2a c9 f4			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
231f			if DEBUG_FORTH_PARSE_KEY 
231f				DMARK "}AA" 
231f				CALLMONITOR 
231f			endif	 
231f c3 22 24			jp execnext 
2322				;jp exec1 
2322			       
2322			 
2322			 
2322			; Another go at the parser to compile  
2322			 
2322			 
2322			; TODO rework parser to change all of the string words to byte tokens 
2322			; TODO do a search for  
2322			 
2322			; TODO first run normal parser to zero term sections 
2322			; TODO for each word do a token look up to get the op code 
2322			; TODO need some means to flag to the exec that this is a byte code form    
2322			 
2322			 
2322			forthcompile: 
2322			 
2322			; 
2322			; line parse: 
2322			;       parse raw input buffer 
2322			;       tokenise the words 
2322			;       malloc new copy (for looping etc) 
2322			;       copy to malloc + current pc in line to start of string and add line term 
2322			;       save on new rsp 
2322			; 
2322			 
2322			; hl to point to the line to tokenise 
2322			 
2322			;	push hl 
2322 22 c9 f4			ld (os_tok_ptr), hl  ; save ptr to string 
2325			 
2325			;	ld a,0		; string term on input 
2325			;	call strlent 
2325			 
2325			;	ld (os_tok_len), hl	 ; save string length 
2325			 
2325			;if DEBUG_FORTH_TOK 
2325			;	ex de,hl		 
2325			;endif 
2325			 
2325			;	pop hl 		; get back string pointer 
2325			 
2325			if DEBUG_FORTH_TOK 
2325						DMARK "TOc" 
2325				CALLMONITOR 
2325			endif 
2325 7e			.cptoken2:    ld a,(hl) 
2326 23				inc hl 
2327 fe 7f			cp FORTH_END_BUFFER 
2329 28 29			jr z, .cptokendone2 
232b fe 00			cp 0 
232d 28 25			jr z, .cptokendone2 
232f fe 22			cp '"' 
2331 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2333 fe 20			cp ' ' 
2335 20 ee			jr nz,  .cptoken2 
2337			 
2337			; TODO consume comments held between ( and ) 
2337			 
2337				; we have a space so change to zero term for dict match later 
2337 2b				dec hl 
2338 3e 00			ld a,0 
233a 77				ld (hl), a 
233b 23				inc hl 
233c 18 e7			jr .cptoken2 
233e				 
233e			 
233e			.cptokenstr2: 
233e				; skip all white space until either eol (because forgot to term) or end double quote 
233e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
233e				;inc hl ; skip current double quote 
233e 7e				ld a,(hl) 
233f 23				inc hl 
2340 fe 22			cp '"' 
2342 28 e1			jr z, .cptoken2 
2344 fe 7f			cp FORTH_END_BUFFER 
2346 28 0c			jr z, .cptokendone2 
2348 fe 00			cp 0 
234a 28 08			jr z, .cptokendone2 
234c fe 20			cp ' ' 
234e 28 02			jr z, .cptmp2 
2350 18 ec			jr .cptokenstr2 
2352			 
2352			.cptmp2:	; we have a space so change to zero term for dict match later 
2352				;dec hl 
2352				;ld a,"-"	; TODO remove this when working 
2352				;ld (hl), a 
2352				;inc hl 
2352 18 ea			jr .cptokenstr2 
2354			 
2354			.cptokendone2: 
2354				;inc hl 
2354 3e 7f			ld a, FORTH_END_BUFFER 
2356 77				ld (hl),a 
2357 23				inc hl 
2358 3e 21			ld a, '!' 
235a 77				ld (hl),a 
235b			 
235b 2a c9 f4			ld hl,(os_tok_ptr) 
235e			         
235e			if DEBUG_FORTH_TOK 
235e						DMARK "Tc1" 
235e				CALLMONITOR 
235e			endif 
235e			 
235e				; push exec string to top of return stack 
235e				FORTH_RSP_NEXT 
235e cd 0e 1f			call macro_forth_rsp_next 
2361				endm 
# End of macro FORTH_RSP_NEXT
2361 c9				ret 
2362			 
2362			; Another go at the parser need to simplify the process 
2362			 
2362			forthparse: 
2362			 
2362			; 
2362			; line parse: 
2362			;       parse raw input buffer 
2362			;       tokenise the words 
2362			;       malloc new copy (for looping etc) 
2362			;       copy to malloc + current pc in line to start of string and add line term 
2362			;       save on new rsp 
2362			; 
2362			 
2362			; hl to point to the line to tokenise 
2362			 
2362			;	push hl 
2362 22 c9 f4			ld (os_tok_ptr), hl  ; save ptr to string 
2365			 
2365			;	ld a,0		; string term on input 
2365			;	call strlent 
2365			 
2365			;	ld (os_tok_len), hl	 ; save string length 
2365			 
2365			;if DEBUG_FORTH_TOK 
2365			;	ex de,hl		 
2365			;endif 
2365			 
2365			;	pop hl 		; get back string pointer 
2365			 
2365			if DEBUG_FORTH_TOK 
2365						DMARK "TOK" 
2365				CALLMONITOR 
2365			endif 
2365 7e			.ptoken2:    ld a,(hl) 
2366 23				inc hl 
2367 fe 7f			cp FORTH_END_BUFFER 
2369 28 29			jr z, .ptokendone2 
236b fe 00			cp 0 
236d 28 25			jr z, .ptokendone2 
236f fe 22			cp '"' 
2371 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2373 fe 20			cp ' ' 
2375 20 ee			jr nz,  .ptoken2 
2377			 
2377			; TODO consume comments held between ( and ) 
2377			 
2377				; we have a space so change to zero term for dict match later 
2377 2b				dec hl 
2378 3e 00			ld a,0 
237a 77				ld (hl), a 
237b 23				inc hl 
237c 18 e7			jr .ptoken2 
237e				 
237e			 
237e			.ptokenstr2: 
237e				; skip all white space until either eol (because forgot to term) or end double quote 
237e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
237e				;inc hl ; skip current double quote 
237e 7e				ld a,(hl) 
237f 23				inc hl 
2380 fe 22			cp '"' 
2382 28 e1			jr z, .ptoken2 
2384 fe 7f			cp FORTH_END_BUFFER 
2386 28 0c			jr z, .ptokendone2 
2388 fe 00			cp 0 
238a 28 08			jr z, .ptokendone2 
238c fe 20			cp ' ' 
238e 28 02			jr z, .ptmp2 
2390 18 ec			jr .ptokenstr2 
2392			 
2392			.ptmp2:	; we have a space so change to zero term for dict match later 
2392				;dec hl 
2392				;ld a,"-"	; TODO remove this when working 
2392				;ld (hl), a 
2392				;inc hl 
2392 18 ea			jr .ptokenstr2 
2394			 
2394			.ptokendone2: 
2394				;inc hl 
2394 3e 7f			ld a, FORTH_END_BUFFER 
2396 77				ld (hl),a 
2397 23				inc hl 
2398 3e 21			ld a, '!' 
239a 77				ld (hl),a 
239b			 
239b 2a c9 f4			ld hl,(os_tok_ptr) 
239e			         
239e			if DEBUG_FORTH_TOK 
239e						DMARK "TK1" 
239e				CALLMONITOR 
239e			endif 
239e			 
239e				; push exec string to top of return stack 
239e				FORTH_RSP_NEXT 
239e cd 0e 1f			call macro_forth_rsp_next 
23a1				endm 
# End of macro FORTH_RSP_NEXT
23a1 c9				ret 
23a2			 
23a2			; 
23a2			;	; malloc size + buffer pointer + if is loop flag 
23a2			;	ld hl,(os_tok_len) 		 ; get string length 
23a2			; 
23a2			;	ld a,l 
23a2			; 
23a2			;	cp 0			; we dont want to use a null string 
23a2			;	ret z 
23a2			; 
23a2			;;	add 3    ; prefix malloc with buffer for current word ptr 
23a2			; 
23a2			;	add 5     ; TODO when certain not over writing memory remove 
23a2			; 
23a2			;		 
23a2			; 
23a2			;if DEBUG_FORTH_TOK 
23a2			;			DMARK "TKE" 
23a2			;	CALLMONITOR 
23a2			;endif 
23a2			; 
23a2			;	ld l,a 
23a2			;	ld h,0 
23a2			;;	push hl   ; save required space for the copy later 
23a2			;	call malloc 
23a2			;if DEBUG_FORTH_TOK 
23a2			;			DMARK "TKM" 
23a2			;	CALLMONITOR 
23a2			;endif 
23a2			;	if DEBUG_FORTH_MALLOC_GUARD 
23a2			;		push af 
23a2			;		call ishlzero 
23a2			;;		ld a, l 
23a2			;;		add h 
23a2			;;		cp 0 
23a2			;		pop af 
23a2			;		 
23a2			;		call z,malloc_error 
23a2			;	endif 
23a2			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
23a2			; 
23a2			; 
23a2			;if DEBUG_FORTH_TOK 
23a2			;			DMARK "TKR" 
23a2			;	CALLMONITOR 
23a2			;endif 
23a2			; 
23a2			;	FORTH_RSP_NEXT 
23a2			; 
23a2			;	;inc hl	 ; go past current buffer pointer 
23a2			;	;inc hl 
23a2			;	;inc hl   ; and past if loop flag 
23a2			;		; TODO Need to set flag  
23a2			; 
23a2			;	 
23a2			;	 
23a2			;	ex de,hl	; malloc is dest 
23a2			;	ld hl, (os_tok_len) 
23a2			;;	pop bc 
23a2			;	ld c, l                
23a2			;	ld b,0 
23a2			;	ld hl, (os_tok_ptr) 
23a2			; 
23a2			;if DEBUG_FORTH_TOK 
23a2			;			DMARK "TKT" 
23a2			;	CALLMONITOR 
23a2			;endif 
23a2			; 
23a2			;	; do str cpy 
23a2			; 
23a2			;	ldir      ; copy byte in hl to de 
23a2			; 
23a2			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
23a2			; 
23a2			;if DEBUG_FORTH_TOK 
23a2			; 
23a2			;			DMARK "TKY" 
23a2			;	CALLMONITOR 
23a2			;endif 
23a2			;	;ld a,0 
23a2			;	;ld a,FORTH_END_BUFFER 
23a2			;	ex de, hl 
23a2			;	;dec hl			 ; go back over the space delim at the end of word 
23a2			;	;ld (hl),a 
23a2			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
23a2			;	ld a,FORTH_END_BUFFER 
23a2			;	ld (hl),a 
23a2			;	inc hl 
23a2			;	ld a,FORTH_END_BUFFER 
23a2			;	ld (hl),a 
23a2			; 
23a2			;	; init the malloc area data 
23a2			;	; set pc for in current area 
23a2			;	;ld hl, (os_tok_malloc) 
23a2			;	;inc hl 
23a2			;	;inc hl 
23a2			;	;inc hl 
23a2			;	;ex de,hl 
23a2			;	;ld hl, (os_tok_malloc) 
23a2			;	;ld (hl),e 
23a2			;	;inc hl 
23a2			;	;ld (hl),d 
23a2			; 
23a2			; 
23a2			;	ld hl,(os_tok_malloc) 
23a2			;if DEBUG_FORTH_PARSE_KEY 
23a2			;			DMARK "TKU" 
23a2			;	CALLMONITOR 
23a2			;endif 
23a2			; 
23a2			;	ret 
23a2			 
23a2			forthexec: 
23a2			 
23a2			; line exec: 
23a2			; forth parser 
23a2			 
23a2			; 
23a2			;       get current exec line on rsp 
23a2			 
23a2				FORTH_RSP_TOS 
23a2 cd 25 1f			call macro_forth_rsp_tos 
23a5				endm 
# End of macro FORTH_RSP_TOS
23a5			 
23a5			;       restore current pc - hl points to malloc of data 
23a5			 
23a5				;ld e, (hl) 
23a5				;inc hl 
23a5				;ld d, (hl) 
23a5				;ex de,hl 
23a5			 
23a5			 
23a5			exec1: 
23a5 22 c9 f4			ld (os_tok_ptr), hl 
23a8			 
23a8				; copy our PC to working vars  
23a8 22 47 fa			ld (cli_ptr), hl 
23ab 22 45 fa			ld (cli_origptr), hl 
23ae			 
23ae 7e				ld a,(hl) 
23af fe 7f			cp FORTH_END_BUFFER 
23b1 c8				ret z 
23b2			 
23b2				; skip any nulls 
23b2			 
23b2 fe 00			cp 0 
23b4 20 03			jr nz, .execword 
23b6 23				inc hl 
23b7 18 ec			jr exec1 
23b9			 
23b9			 
23b9			.execword: 
23b9			 
23b9			 
23b9			 
23b9			if DEBUG_FORTH_PARSE_KEY 
23b9						DMARK "KYQ" 
23b9				CALLMONITOR 
23b9			endif 
23b9			;       while at start of word: 
23b9			; get start of dict (in user area first) 
23b9			 
23b9 21 00 80		ld hl, baseram 
23bc			;ld hl, sysdict 
23bc 22 49 fa		ld (cli_nextword),hl 
23bf			;           match word at pc 
23bf			;           exec word 
23bf			;           or push to dsp 
23bf			;           forward to next token 
23bf			;           if line term pop rsp and exit 
23bf			;        
23bf			 
23bf			if DEBUG_FORTH_PARSE_KEY 
23bf						DMARK "KYq" 
23bf				CALLMONITOR 
23bf			endif 
23bf			 
23bf			; 
23bf			; word comp 
23bf			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
23bf			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
23bf			;    move to start of word  
23bf			;    compare word to cli_token 
23bf			 
23bf			.execpnword:	; HL at start of a word in the dictionary to check 
23bf			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
23bf			;	ld (cli_ptr), hl 
23bf			 
23bf 2a 49 fa			ld hl,(cli_nextword) 
23c2			 
23c2 cd 65 24			call forth_tok_next 
23c5			; tok next start here 
23c5			;	; TODO skip compiled symbol for now 
23c5			;	inc hl 
23c5			; 
23c5			;	; save pointer to next word 
23c5			; 
23c5			;	; hl now points to the address of the next word pointer  
23c5			;	ld e, (hl) 
23c5			;	inc hl 
23c5			;	ld d, (hl) 
23c5			;	inc l 
23c5			; 
23c5			;	ex de,hl 
23c5			;if DEBUG_FORTH_PARSE_NEXTWORD 
23c5			;	push bc 
23c5			;	ld bc, (cli_nextword) 
23c5			;			DMARK "NXW" 
23c5			;	CALLMONITOR 
23c5			;	pop bc 
23c5			;endif 
23c5			; tok next end here 
23c5 22 49 fa			ld (cli_nextword), hl     ; save for next check if no match on this word 
23c8 eb				ex de, hl 
23c9			 
23c9			 
23c9				; save the pointer of the current token - 1 to check against 
23c9				 
23c9 22 4d fa			ld (cli_token), hl   
23cc				; TODO maybe remove below save if no debug 
23cc				; save token string ptr for any debug later 
23cc 23				inc hl  
23cd 22 4f fa			ld (cli_origtoken), hl 
23d0 2b				dec hl 
23d1				; save pointer to the start of the next dictionay word 
23d1 7e				ld a,(hl)   ; get string length 
23d2 47				ld b,a 
23d3			.execpnwordinc:  
23d3 23				inc hl 
23d4 10 fd			djnz .execpnwordinc 
23d6 22 4b fa			ld (cli_execword), hl      ; save start of this words code 
23d9			 
23d9				; now check the word token against the string being parsed 
23d9			 
23d9 2a 4d fa			ld hl,(cli_token) 
23dc 23				inc hl     ; skip string length (use zero term instead to end) 
23dd 22 4d fa			ld (cli_token), hl 
23e0			 
23e0			if DEBUG_FORTH_PARSE_KEY 
23e0						DMARK "KY2" 
23e0			endif 
23e0			if DEBUG_FORTH_PARSE_EXEC 
23e0				; see if disabled 
23e0			 
23e0				ld a, (os_view_disable) 
23e0				cp '*' 
23e0				jr z, .skip 
23e0			 
23e0				push hl 
23e0				push hl 
23e0				call clear_display 
23e0				ld de, .compword 
23e0				ld a, display_row_1 
23e0				call str_at_display 
23e0				pop de 
23e0				ld a, display_row_2 
23e0				call str_at_display 
23e0				ld hl,(cli_ptr) 
23e0				ld a,(hl) 
23e0			        ld hl, os_word_scratch 
23e0				ld (hl),a 
23e0				ld a,0 
23e0				inc hl 
23e0				ld (hl),a 	 
23e0				ld de, os_word_scratch 
23e0				ld a, display_row_2+10 
23e0				call str_at_display 
23e0				call update_display 
23e0				ld a, 100 
23e0				call aDelayInMS 
23e0				if DEBUG_FORTH_PARSE_EXEC_SLOW 
23e0				call delay250ms 
23e0				endif 
23e0				pop hl 
23e0			.skip:  
23e0			endif	 
23e0			.execpnchar:    ; compare char between token and string to parse 
23e0			 
23e0			if DEBUG_FORTH_PARSE_KEY 
23e0						DMARK "Ky3" 
23e0			endif 
23e0			if DEBUG_FORTH_PARSE_EXEC 
23e0				; see if disabled 
23e0			 
23e0				ld a, (os_view_disable) 
23e0				cp '*' 
23e0				jr z, .skip2 
23e0			 
23e0			;	call clear_display 
23e0			ld hl,(cli_token) 
23e0			ld a,(hl) 
23e0			ld (os_word_scratch),a 
23e0				ld hl,(cli_ptr) 
23e0			ld a,(hl) 
23e0				ld (os_word_scratch+1),a 
23e0				ld a,0 
23e0				ld (os_word_scratch+2),a 
23e0				ld de,os_word_scratch 
23e0				ld a,display_row_4 
23e0				call str_at_display 
23e0				call update_display 
23e0			.skip2:  
23e0			endif 
23e0 2a 4d fa			ld hl,(cli_token) 
23e3 7e				ld a, (hl)	 ; char in word token 
23e4 23				inc hl 		; move to next char 
23e5 22 4d fa			ld (cli_token), hl ; and save it 
23e8 47				ld b,a 
23e9			 
23e9 2a 47 fa			ld hl,(cli_ptr) ;	get the char from the string to parse 
23ec 7e				ld a,(hl) 
23ed 23				inc hl 
23ee 22 47 fa			ld (cli_ptr), hl		; move to next char 
23f1 cd a1 13			call toUpper 		; make sure the input string matches case 
23f4			 
23f4			if DEBUG_FORTH_PARSE 
23f4			endif 
23f4			 
23f4				; input stream end of token is a space so get rid of it 
23f4			 
23f4			;	cp ' ' 
23f4			;	jr nz, .pnskipspace 
23f4			; 
23f4			;	ld a, 0		; make same term as word token term 
23f4			; 
23f4			;.pnskipspace: 
23f4			 
23f4			if DEBUG_FORTH_PARSE_KEY 
23f4						DMARK "KY7" 
23f4			endif 
23f4 b8				cp b 
23f5 c2 0b 24			jp nz, .execpnskipword	 ; no match so move to next word 
23f8				 
23f8			;    if same 
23f8			;       scan for string terms 0 for token and 32 for input 
23f8			 
23f8				 
23f8			if DEBUG_FORTH_PARSE_KEY 
23f8						DMARK "KY8" 
23f8			endif 
23f8			 
23f8 80				add b			 
23f9 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
23fb							; TODO need to make sure last word in zero term string is accounted for 
23fb 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
23fd			 
23fd			 
23fd				; at end of both strings so both are exact match 
23fd			 
23fd			;       skip ptr for next word 
23fd			 
23fd 2a 47 fa			ld hl,(cli_ptr) 	; at input string term 
2400 23				inc hl			 ; at next char 
2401 22 47 fa			ld (cli_ptr), hl     ; save for next round of the parser 
2404 22 45 fa			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2407				 
2407				 
2407			if DEBUG_FORTH_PARSE_KEY 
2407						DMARK "KY3" 
2407			endif 
2407			 
2407			 
2407			 
2407			;       exec code block 
2407			if DEBUG_FORTH_JP 
2407				call clear_display 
2407				call update_display 
2407				call delay1s 
2407				ld hl, (cli_execword)     ; save for next check if no match on this word 
2407				ld a,h 
2407				ld hl, os_word_scratch 
2407				call hexout 
2407				ld hl, (cli_execword)     ; save for next check if no match on this word 
2407				ld a,l 
2407				ld hl, os_word_scratch+2 
2407				call hexout 
2407				ld hl, os_word_scratch+4 
2407				ld a,0 
2407				ld (hl),a 
2407				ld de,os_word_scratch 
2407				call str_at_display 
2407					ld a, display_row_2 
2407					call str_at_display 
2407				ld de, (cli_origtoken) 
2407				ld a, display_row_1+10 
2407					call str_at_display 
2407			 
2407				ld a,display_row_1 
2407				ld de, .foundword 
2407				ld a, display_row_3 
2407				call str_at_display 
2407				call update_display 
2407				call delay1s 
2407				call delay1s 
2407				call delay1s 
2407			endif 
2407			 
2407			if DEBUG_FORTH_PARSE_KEY 
2407						DMARK "KYj" 
2407			endif 
2407				; TODO save the word pointer in this exec 
2407			 
2407 2a 4b fa			ld hl,(cli_execword) 
240a e9				jp (hl) 
240b			 
240b			 
240b			;    if not same 
240b			;	scan for zero term 
240b			;	get ptr for next word 
240b			;	goto word comp 
240b			 
240b			.execpnskipword:	; get pointer to next word 
240b 2a 49 fa			ld hl,(cli_nextword) 
240e			 
240e 7e				ld a,(hl) 
240f fe 00			cp WORD_SYS_END 
2411			;	cp 0 
2411 28 09			jr z, .execendofdict			 ; at end of words 
2413			 
2413			if DEBUG_FORTH_PARSE_KEY 
2413						DMARK "KY4" 
2413			endif 
2413			if DEBUG_FORTH_PARSE_EXEC 
2413			 
2413				; see if disabled 
2413			 
2413				ld a, (os_view_disable) 
2413				cp '*' 
2413				jr z, .noskip 
2413			 
2413			 
2413				ld de, .nowordfound 
2413				ld a, display_row_3 
2413				call str_at_display 
2413				call update_display 
2413				ld a, 100 
2413				call aDelayInMS 
2413				 
2413				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2413					call delay250ms 
2413				endif 
2413			.noskip:  
2413			 
2413			endif	 
2413			 
2413 2a 45 fa			ld hl,(cli_origptr) 
2416 22 47 fa			ld (cli_ptr),hl 
2419			 
2419			if DEBUG_FORTH_PARSE_KEY 
2419						DMARK "KY5" 
2419			endif 
2419 c3 bf 23			jp .execpnword			; else go to next word 
241c			 
241c			.execendofdict:  
241c			 
241c			if DEBUG_FORTH_PARSE_KEY 
241c						DMARK "KYe" 
241c			endif 
241c			if DEBUG_FORTH_PARSE_EXEC 
241c				; see if disabled 
241c			 
241c				ld a, (os_view_disable) 
241c				cp '*' 
241c				jr z, .ispskip 
241c			 
241c				call clear_display 
241c				call update_display 
241c				call delay1s 
241c				ld de, (cli_origptr) 
241c				ld a, display_row_1 
241c				call str_at_display 
241c				 
241c				ld de, .enddict 
241c				ld a, display_row_3 
241c				call str_at_display 
241c				call update_display 
241c				ld a, 100 
241c				call aDelayInMS 
241c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
241c				call delay1s 
241c				call delay1s 
241c				call delay1s 
241c				endif 
241c			.ispskip:  
241c				 
241c			endif	 
241c			 
241c			 
241c			 
241c				; if the word is not a keyword then must be a literal so push it to stack 
241c			 
241c			; push token to stack to end of word 
241c			 
241c				STACKFRAME ON $1efe $2f9f 
241c				if DEBUG_STACK_IMB 
241c					if ON 
241c						exx 
241c						ld de, $1efe 
241c						ld a, d 
241c						ld hl, curframe 
241c						call hexout 
241c						ld a, e 
241c						ld hl, curframe+2 
241c						call hexout 
241c						ld hl, $1efe 
241c						push hl 
241c						ld hl, $2f9f 
241c						push hl 
241c						exx 
241c					endif 
241c				endif 
241c			endm 
# End of macro STACKFRAME
241c			 
241c 2a c9 f4		ld hl,(os_tok_ptr) 
241f cd d0 20		call forth_apush 
2422			 
2422				STACKFRAMECHK ON $1efe $2f9f 
2422				if DEBUG_STACK_IMB 
2422					if ON 
2422						exx 
2422						ld hl, $2f9f 
2422						pop de   ; $2f9f 
2422						call cmp16 
2422						jr nz, .spnosame 
2422						ld hl, $1efe 
2422						pop de   ; $1efe 
2422						call cmp16 
2422						jr z, .spfrsame 
2422						.spnosame: call showsperror 
2422						.spfrsame: nop 
2422						exx 
2422					endif 
2422				endif 
2422			endm 
# End of macro STACKFRAMECHK
2422			 
2422			execnext: 
2422			 
2422			if DEBUG_FORTH_PARSE_KEY 
2422						DMARK "KY>" 
2422			endif 
2422			; move past token to next word 
2422			 
2422 2a c9 f4		ld hl, (os_tok_ptr) 
2425 3e 00		ld a, 0 
2427 01 ff 00		ld bc, 255     ; input buffer size 
242a ed b1		cpir 
242c			 
242c			if DEBUG_FORTH_PARSE_KEY 
242c						DMARK "KY!" 
242c				CALLMONITOR 
242c			endif	 
242c			; TODO this might place hl on the null, so will need to forward on??? 
242c			;inc hl   ; see if this gets onto the next item 
242c			 
242c			 
242c			; TODO pass a pointer to the buffer to push 
242c			; TODO call function to push 
242c			 
242c			; look for end of input 
242c			 
242c			;inc hl 
242c			;ld a,(hl) 
242c			;cp FORTH_END_BUFFER 
242c			;ret z 
242c			 
242c			 
242c c3 a5 23		jp exec1 
242f			 
242f			 
242f			 
242f			 
242f			 
242f			 
242f			 
242f			 
242f			 
242f			findnexttok: 
242f			 
242f				; hl is pointer to move 
242f				; de is the token to locate 
242f			 
242f					if DEBUG_FORTH 
242f						DMARK "NTK" 
242f						CALLMONITOR 
242f					endif 
242f d5				push de 
2430			 
2430			.fnt1:	 
2430				; find first char of token to locate 
2430			 
2430 1a				ld a, (de) 
2431 4f				ld c,a 
2432 7e				ld a,(hl) 
2433 cd a1 13			call toUpper 
2436					if DEBUG_FORTH 
2436						DMARK "NT1" 
2436						CALLMONITOR 
2436					endif 
2436 b9				cp c 
2437			 
2437 28 03			jr z, .fnt2cmpmorefirst	 
2439			 
2439				; first char not found move to next char 
2439			 
2439 23				inc hl 
243a 18 f4			jr .fnt1 
243c			 
243c			.fnt2cmpmorefirst:	 
243c				; first char of token found.  
243c			 
243c e5				push hl     ; save start of token just in case it is the right one 
243d d9				exx 
243e e1				pop hl        ; save it to hl' 
243f d9				exx 
2440			 
2440			 
2440			.fnt2cmpmore:	 
2440				; compare the rest 
2440				 
2440 23				inc hl 
2441 13				inc de 
2442				 
2442 1a				ld a, (de) 
2443 4f				ld c,a 
2444 7e				ld a,(hl) 
2445 cd a1 13			call toUpper 
2448			 
2448					if DEBUG_FORTH 
2448						DMARK "NT2" 
2448						CALLMONITOR 
2448					endif 
2448				; c has the token to find char 
2448				; a has the mem to scan char 
2448			 
2448 b9				cp c 
2449 28 04			jr z,.fntmatch1 
244b			 
244b				; they are not the same 
244b			 
244b					if DEBUG_FORTH 
244b						DMARK "NT3" 
244b						CALLMONITOR 
244b					endif 
244b d1				pop de	; reset de token to look for 
244c d5				push de 
244d 18 e1			jr .fnt1 
244f				 
244f			.fntmatch1: 
244f			 
244f				; is the same char a null which means we might have a full hit? 
244f					if DEBUG_FORTH 
244f						DMARK "NT4" 
244f						CALLMONITOR 
244f					endif 
244f			 
244f fe 00			cp 0 
2451 28 0b			jr z, .fntmatchyes 
2453			 
2453				; are we at the end of the token to find? 
2453			 
2453					if DEBUG_FORTH 
2453						DMARK "NT5" 
2453						CALLMONITOR 
2453					endif 
2453 3e 00			ld a, 0 
2455 b9				cp c 
2456			 
2456 c2 40 24			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2459			 
2459					if DEBUG_FORTH 
2459						DMARK "NT6" 
2459						CALLMONITOR 
2459					endif 
2459				; token to find is exhusted but no match to stream 
2459			 
2459				; restore tok pointer and continue on 
2459 d1				pop de 
245a d5				push de 
245b c3 30 24			jp .fnt1 
245e			 
245e			 
245e			.fntmatchyes: 
245e			 
245e				; hl now contains the end of the found token 
245e			 
245e				; get rid of saved token pointer to find 
245e			 
245e d1				pop de 
245f			 
245f					if DEBUG_FORTH 
245f						DMARK "NT9" 
245f						CALLMONITOR 
245f					endif 
245f			 
245f				; hl will be on the null term so forward on 
245f			 
245f				; get back the saved start of the token 
245f			 
245f d9				exx 
2460 e5				push hl     ; save start of token just in case it is the right one 
2461 d9				exx 
2462 e1				pop hl        ; save it to hl 
2463			 
2463 c9				ret 
2464			 
2464			 
2464			; LIST needs to find a specific token   
2464			; FORGET needs to find a spefici token 
2464			 
2464			; SAVE needs to find all tokens by flag 
2464			; WORDS just needs to scan through all  by flag 
2464			; UWORDS needs to scan through all by flag 
2464			 
2464			 
2464			; given hl as pointer to start of dict look up string 
2464			; return hl as pointer to start of word block 
2464			; or 0 if not found 
2464			 
2464			forth_find_tok: 
2464 c9				ret 
2465			 
2465			; given hl as pointer to dict structure 
2465			; move to the next dict block structure 
2465			 
2465			forth_tok_next: 
2465				; hl now points to the address of the next word pointer  
2465				; TODO skip compiled symbol for now 
2465			;	push de 
2465 23				inc hl 
2466 5e				ld e, (hl) 
2467 23				inc hl 
2468 56				ld d, (hl) 
2469 23				inc hl 
246a			 
246a eb				ex de,hl 
246b			if DEBUG_FORTH_PARSE_NEXTWORD 
246b				push bc 
246b				ld bc, (cli_nextword) 
246b						DMARK "NXW" 
246b				CALLMONITOR 
246b				pop bc 
246b			endif 
246b			;	pop de	 
246b c9				ret 
246c			 
246c			 
246c			 
246c			; eof 
# End of file forth_parserv5.asm
246c				include "forth_wordsv4.asm" 
246c			 
246c			; the core word dictionary v4 
246c			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
246c			 
246c			; this is a linked list for each of the system words used 
246c			; user defined words will follow the same format but will be in ram 
246c			 
246c			 
246c			; 
246c			; 
246c			; define linked list: 
246c			; 
246c			; 1. compiled byte op code 
246c			; 2. len of text word 
246c			; 3. text word 
246c			; 4. ptr to next dictionary word 
246c			; 5. asm, calls etc for the word 
246c			; 
246c			;  if 1 == 0 then last word in dict  
246c			;   
246c			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
246c			;  
246c			;  
246c			; create basic standard set of words 
246c			; 
246c			;  
246c			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
246c			; 2DUP 2DROP 2SWAP  
246c			; @ C@ - get byte  
246c			; ! C! - store byte 
246c			; 0< true if less than zero 
246c			; 0= true if zero 
246c			; < >  
246c			; = true if same 
246c			; variables 
246c			 
246c			 
246c			; Hardware specific words I may need 
246c			; 
246c			; IN OUT  
246c			; calls to key util functions 
246c			; calls to hardward abstraction stuff 
246c			; easy control of frame buffers and lcd i/o 
246c			; keyboard  
246c			 
246c			 
246c			;DICT: macro 
246c			; op_code, len, word, next 
246c			;    word: 
246c			;    db op_code 
246c			;    ds word zero term 
246c			;    dw next 
246c			;    endm 
246c			 
246c			 
246c			 
246c			 
246c			; op code 1 is a flag for user define words which are to be handled differently 
246c			 
246c			 
246c			; 
246c			; 
246c			;    TODO on entry to a word this should be the expected environment 
246c			;    hl - tos value if number then held, if string this is the ptr 
246c			;    de -  
246c			 
246c			 
246c			; opcode ranges 
246c			; 0 - end of word dict 
246c			; 255 - user define words 
246c			 
246c			sysdict: 
246c			include "forth_opcodes.asm" 
246c			; op codes for forth keywords 
246c			; free to use code 0  
246c				OPCODE_HEAP: equ  1 
246c				OPCODE_EXEC: equ 2 
246c				OPCODE_DUP: equ 3 
246c				OPCODE_SWAP: equ 4 
246c				OPCODE_COLN: equ 5 
246c				OPCODE_SCOLN: equ 6 
246c				OPCODE_DROP: equ 7 
246c				OPCODE_DUP2: equ 8 
246c				OPCODE_DROP2: equ 9 
246c				OPCODE_SWAP2: equ 10 
246c				OPCODE_AT: equ 11 
246c				OPCODE_CAT: equ 12 
246c				OPCODE_BANG: equ 13 
246c				OPCODE_CBANG: equ 14 
246c				OPCODE_SCALL: equ 15 
246c				OPCODE_DEPTH: equ 16 
246c				OPCODE_OVER: equ 17 
246c				OPCODE_PAUSE: equ 18 
246c				OPCODE_PAUSES: equ 19 
246c				OPCODE_ROT: equ 20 
246c			;free to reuse	OPCODE_WORDS: equ 21 
246c			        OPCODE_NOT: equ 21 
246c				OPCODE_UWORDS: equ 22 
246c				OPCODE_BP: equ 23 
246c				OPCODE_MONITOR: equ 24  
246c				OPCODE_MALLOC: equ 25 
246c				OPCODE_FREE: equ 26 
246c				OPCODE_LIST: equ 27 
246c				OPCODE_FORGET: equ 28 
246c				OPCODE_NOP: equ 29 
246c				OPCODE_COMO: equ 30 
246c				OPCODE_COMC: equ 31 
246c			;free to reuse	OPCODE_ENDCORE: equ 32 
246c				OPCODE_AFTERSOUND: equ 33 
246c				OPCODE_GP2: equ 34 
246c				OPCODE_GP3: equ 35 
246c				OPCODE_GP4: equ 36 
246c				OPCODE_SIN: equ 37 
246c				OPCODE_SOUT: equ 38 
246c				OPCODE_SPIO: equ 39 
246c				OPCODE_SPICEH: equ 40 
246c				OPCODE_SPIOb: equ 41 
246c				OPCODE_SPII: equ 42 
246c				OPCODE_SESEL: equ 43 
246c				OPCODE_CARTDEV: equ 44 
246c			; free to reuse	OPCODE_ENDDEVICE: equ 45 
246c				OPCODE_FB: equ 46 
246c				OPCODE_EMIT: equ 47 
246c				OPCODE_DOTH: equ 48 
246c				OPCODE_DOTF: equ 49 
246c				OPCODE_DOT: equ 50 
246c				OPCODE_CLS: equ 51 
246c				OPCODE_DRAW: equ 52 
246c				OPCODE_DUMP: equ 53 
246c				OPCODE_CDUMP: equ 54 
246c				OPCODE_DAT: equ 55 
246c				OPCODE_HOME: equ 56 
246c				OPCODE_SPACE: equ 57 
246c				OPCODE_SPACES: equ 58 
246c				OPCODE_SCROLL: equ 59 
246c				OPCODE_ATQ: equ 60 
246c				OPCODE_AUTODSP: equ 61 
246c				OPCODE_MENU: equ 62 
246c			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
246c				OPCODE_THEN: equ 64 
246c				OPCODE_ELSE: equ 65 
246c				OPCODE_DO: equ 66 
246c				OPCODE_LOOP: equ 67 
246c				OPCODE_I: equ 68 
246c				OPCODE_DLOOP: equ 69  
246c				OPCODE_REPEAT: equ 70  
246c				OPCODE_UNTIL: equ 71 
246c				OPCODE_ENDFLOW: equ 72 
246c				OPCODE_WAITK: equ 73 
246c				OPCODE_ACCEPT: equ 74 
246c				OPCODE_EDIT: equ 75 
246c			;free to reuse	OPCODE_ENDKEY: equ 76 
246c				OPCODE_LZERO: equ 77 
246c				OPCODE_TZERO: equ 78 
246c				OPCODE_LESS: equ 79 
246c				OPCODE_GT: equ 80 
246c				OPCODE_EQUAL: equ 81  
246c			;free to reuse	OPCODE_ENDLOGIC: equ 82 
246c				OPCODE_NEG: equ 83 
246c				OPCODE_DIV: equ 84 
246c				OPCODE_MUL: equ 85 
246c				OPCODE_MIN: equ 86 
246c				OPCODE_MAX: equ 87 
246c				OPCODE_RND16: equ 88 
246c				OPCODE_RND8: equ 89 
246c				OPCODE_RND: equ 90 
246c			;free to reuse	OPCODE_ENDMATHS: equ 91  
246c				OPCODE_BYNAME: equ 92 
246c				OPCODE_DIR: equ 93 
246c				OPCODE_SAVE: equ 94 
246c				OPCODE_LOAD: equ 95 
246c				OPCODE_BSAVE: equ 96 
246c				OPCODE_BLOAD: equ 97 
246c				OPCODE_SEO: equ 98  
246c				OPCODE_SEI: equ 99 
246c				OPCODE_SFREE: equ 100 
246c				OPCODE_SIZE: equ 101 
246c				OPCODE_CREATE: equ 102 
246c				OPCODE_APPEND: equ 103 
246c				OPCODE_SDEL: equ 104 
246c				OPCODE_OPEN: equ 105 
246c				OPCODE_READ: equ 106 
246c				OPCODE_EOF: equ 106 
246c				OPCODE_FORMAT: equ 107 
246c				OPCODE_LABEL: equ 108 
246c				OPCODE_LABELS: equ 109 
246c			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
246c				OPCODE_UPPER: equ 111 
246c				OPCODE_LOWER: equ 112 
246c				OPCODE_SUBSTR: equ 113 
246c				OPCODE_LEFT: equ 114 
246c				OPCODE_RIGHT: equ 115 
246c				OPCODE_STR2NUM: equ 116 
246c				OPCODE_NUM2STR: equ 117 
246c				OPCODE_CONCAT: equ 118 
246c				OPCODE_FIND: equ 119 
246c				OPCODE_LEN: equ 120 
246c				OPCODE_CHAR: equ 121 
246c			; free to reuse	OPCODE_STRLEN: equ 122 
246c			; free to reuse	OPCODE_ENDSTR: equ 123 
246c				OPCODE_V0S: equ 124 
246c				OPCODE_V0Q: equ 125 
246c				OPCODE_V1S: equ 126 
246c				OPCODE_V1Q: equ 127 
246c				OPCODE_V2S: equ 128 
246c				OPCODE_V2Q: equ 129 
246c				OPCODE_V3S: equ 130 
246c				OPCODE_V3Q: equ 131 
246c			;free to reuse	OPCODE_END: equ 132 
246c				OPCODE_ZDUP: equ 133 
246c			 
246c			; eof 
# End of file forth_opcodes.asm
246c			 
246c			include "forth_words_core.asm" 
246c			 
246c			; | ## Core Words 
246c			 
246c			;if MALLOC_4 
246c			 
246c			.HEAP: 
246c				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
246c 15				db WORD_SYS_CORE+OPCODE_HEAP             
246d ab 24			dw .EXEC            
246f 05				db 4 + 1 
2470 .. 00			db "HEAP",0              
2475				endm 
# End of macro CWHEAD
2475			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2475			; | | u1 - Current number of bytes in the heap 
2475			; | | u2 - Remaining bytes left on the heap 
2475			; | |  
2475			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2475			 
2475			 
2475					if DEBUG_FORTH_WORDS_KEY 
2475						DMARK "HEP" 
2475 f5				push af  
2476 3a 8a 24			ld a, (.dmark)  
2479 32 6e fe			ld (debug_mark),a  
247c 3a 8b 24			ld a, (.dmark+1)  
247f 32 6f fe			ld (debug_mark+1),a  
2482 3a 8c 24			ld a, (.dmark+2)  
2485 32 70 fe			ld (debug_mark+2),a  
2488 18 03			jr .pastdmark  
248a ..			.dmark: db "HEP"  
248d f1			.pastdmark: pop af  
248e			endm  
# End of macro DMARK
248e						CALLMONITOR 
248e cd f3 18			call break_point_state  
2491				endm  
# End of macro CALLMONITOR
2491					endif 
2491 2a 0a 80				ld hl, (free_list )      
2494 11 0e 80				ld de, heap_start 
2497			 
2497 ed 52				sbc hl, de  
2499			 
2499 cd 67 1f				call forth_push_numhl 
249c			 
249c			 
249c ed 5b 0a 80			ld de, (free_list )      
24a0 21 ae f1				ld hl, heap_end 
24a3			 
24a3 ed 52				sbc hl, de 
24a5			 
24a5 cd 67 1f				call forth_push_numhl 
24a8					 
24a8			 
24a8					 
24a8			 
24a8			 
24a8			 
24a8					NEXTW 
24a8 c3 14 23			jp macro_next 
24ab				endm 
# End of macro NEXTW
24ab			;endif 
24ab			 
24ab			.EXEC: 
24ab			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
24ab			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
24ab			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
24ab			;; > > 
24ab			;; > >   
24ab			;	STACKFRAME OFF $5efe $5f9f 
24ab			; 
24ab			;		if DEBUG_FORTH_WORDS_KEY 
24ab			;			DMARK "EXE" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			; 
24ab			;	FORTH_DSP_VALUEHL 
24ab			; 
24ab			;	FORTH_DSP_POP 
24ab			; 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EX1" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			;;	ld e,(hl) 
24ab			;;	inc hl 
24ab			;;	ld d,(hl) 
24ab			;;	ex de,hl 
24ab			; 
24ab			;;		if DEBUG_FORTH_WORDS 
24ab			;;			DMARK "EX2" 
24ab			;;			CALLMONITOR 
24ab			;;		endif 
24ab			;	push hl 
24ab			; 
24ab			;	;ld a, 0 
24ab			;	;ld a, FORTH_END_BUFFER 
24ab			;	call strlenz 
24ab			;	inc hl   ; include zero term to copy 
24ab			;	inc hl   ; include term 
24ab			;	inc hl   ; include term 
24ab			;	ld b,0 
24ab			;	ld c,l 
24ab			;	pop hl 
24ab			;	ld de, execscratch 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EX3" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			;	ldir 
24ab			; 
24ab			; 
24ab			;	ld hl, execscratch 
24ab			; 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EXe" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			; 
24ab			;	call forthparse 
24ab			;	call forthexec 
24ab			;;	call forthexec_cleanup 
24ab			;;	call forthparse 
24ab			;;	call forthexec 
24ab			; 
24ab			;	STACKFRAMECHK OFF $5efe $5f9f 
24ab			; 
24ab			;	; an immediate word so no need to process any more words 
24ab			;	ret 
24ab			;	NEXTW 
24ab			 
24ab			; dead code - old version  
24ab			;	FORTH_RSP_NEXT 
24ab			 
24ab			;  
24ab			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
24ab			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
24ab			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
24ab			;	push hl 
24ab			;	push de 
24ab			;	push bc 
24ab			; 
24ab			; 
24ab			;		if DEBUG_FORTH_WORDS_KEY 
24ab			;			DMARK "EXR" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			; 
24ab			; 
24ab			; 
24ab			;	;v5 FORTH_DSP_VALUE 
24ab			;	FORTH_DSP_VALUEHL 
24ab			; 
24ab			;	; TODO do string type checks 
24ab			; 
24ab			;;v5	inc hl   ; skip type 
24ab			; 
24ab			;	push hl  ; source code  
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EX1" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			;	ld a, 0 
24ab			;	call strlent 
24ab			; 
24ab			;	inc hl 
24ab			;	inc hl 
24ab			;	inc hl 
24ab			;	inc hl 
24ab			; 
24ab			;	push hl    ; size 
24ab			; 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EX2" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			;	call malloc 
24ab			; 
24ab			;	ex de, hl    ; de now contains malloc area 
24ab			;	pop bc   	; get byte count 
24ab			;	pop hl      ; get string to copy 
24ab			; 
24ab			;	push de     ; save malloc for free later 
24ab			; 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EX3" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			;	ldir       ; duplicate string 
24ab			; 
24ab			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
24ab			;	 
24ab			;	; TODO fix the parse would be better than this...  
24ab			;	ex de, hl 
24ab			;	dec hl 
24ab			;	ld a, 0 
24ab			;	ld (hl), a 
24ab			;	dec hl 
24ab			;	ld a, ' ' 
24ab			;	ld (hl), a 
24ab			;	dec hl 
24ab			;	ld (hl), a 
24ab			; 
24ab			;	dec hl 
24ab			;	ld (hl), a 
24ab			; 
24ab			; 
24ab			;	FORTH_DSP_POP  
24ab			; 
24ab			;	pop hl     
24ab			;	push hl    ; save malloc area 
24ab			; 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EX4" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			; 
24ab			;	call forthparse 
24ab			;	call forthexec 
24ab			;	 
24ab			;	pop hl 
24ab			;	if DEBUG_FORTH_WORDS 
24ab			;		DMARK "EX5" 
24ab			;		CALLMONITOR 
24ab			;	endif 
24ab			; 
24ab			;	if FORTH_ENABLE_FREE 
24ab			;	call free 
24ab			;	endif 
24ab			; 
24ab			;	if DEBUG_FORTH_WORDS 
24ab			;		DMARK "EX6" 
24ab			;		CALLMONITOR 
24ab			;	endif 
24ab			; 
24ab			;	pop bc 
24ab			;	pop de 
24ab			;	pop hl 
24ab			;;	FORTH_RSP_POP	  
24ab			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
24ab			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
24ab			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
24ab			; 
24ab			;	if DEBUG_FORTH_WORDS 
24ab			;		DMARK "EX7" 
24ab			;		CALLMONITOR 
24ab			;	endif 
24ab			;	NEXTW 
24ab			 
24ab			;.STKEXEC: 
24ab			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
24ab			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
24ab			; 
24ab			; 
24ab			;		if DEBUG_FORTH_WORDS_KEY 
24ab			;			DMARK "STX" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			; 
24ab			;	FORTH_DSP_VALUEHL 
24ab			; 
24ab			;	ld (store_tmp1), hl    ; count 
24ab			; 
24ab			;	FORTH_DSP_POP 
24ab			;.stkexec1: 
24ab			;	ld hl, (store_tmp1)   ; count 
24ab			;	ld a, 0 
24ab			;	cp l 
24ab			;	ret z 
24ab			; 
24ab			;	dec hl 
24ab			;	ld (store_tmp1), hl    ; count 
24ab			;	 
24ab			;	FORTH_DSP_VALUEHL 
24ab			;	push hl 
24ab			;	 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EXp" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			;	FORTH_DSP_POP 
24ab			; 
24ab			;	call strlenz 
24ab			;	inc hl   ; include zero term to copy 
24ab			;	inc hl   ; include zero term to copy 
24ab			;	inc hl   ; include zero term to copy 
24ab			;	ld b,0 
24ab			;	ld c,l 
24ab			;	pop hl 
24ab			;	ld de, execscratch 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EX3" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			;	ldir 
24ab			; 
24ab			; 
24ab			;	ld hl, execscratch 
24ab			; 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EXP" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			; 
24ab			;	call forthparse 
24ab			;	ld hl, execscratch 
24ab			;		if DEBUG_FORTH_WORDS 
24ab			;			DMARK "EXx" 
24ab			;			CALLMONITOR 
24ab			;		endif 
24ab			;	call forthexec 
24ab			; 
24ab			;	jp .stkexec1 
24ab			; 
24ab			;	ret 
24ab			 
24ab			 
24ab			.DUP: 
24ab				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
24ab 17				db WORD_SYS_CORE+OPCODE_DUP             
24ac 21 25			dw .ZDUP            
24ae 04				db 3 + 1 
24af .. 00			db "DUP",0              
24b3				endm 
# End of macro CWHEAD
24b3			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
24b3			 
24b3					if DEBUG_FORTH_WORDS_KEY 
24b3						DMARK "DUP" 
24b3 f5				push af  
24b4 3a c8 24			ld a, (.dmark)  
24b7 32 6e fe			ld (debug_mark),a  
24ba 3a c9 24			ld a, (.dmark+1)  
24bd 32 6f fe			ld (debug_mark+1),a  
24c0 3a ca 24			ld a, (.dmark+2)  
24c3 32 70 fe			ld (debug_mark+2),a  
24c6 18 03			jr .pastdmark  
24c8 ..			.dmark: db "DUP"  
24cb f1			.pastdmark: pop af  
24cc			endm  
# End of macro DMARK
24cc						CALLMONITOR 
24cc cd f3 18			call break_point_state  
24cf				endm  
# End of macro CALLMONITOR
24cf					endif 
24cf			 
24cf					FORTH_DSP 
24cf cd 24 21			call macro_forth_dsp 
24d2				endm 
# End of macro FORTH_DSP
24d2			 
24d2 7e					ld a, (HL) 
24d3 fe 01				cp DS_TYPE_STR 
24d5 20 25				jr nz, .dupinum 
24d7			 
24d7					; push another string 
24d7			 
24d7					FORTH_DSP_VALUEHL     		 
24d7 cd 5e 21			call macro_dsp_valuehl 
24da				endm 
# End of macro FORTH_DSP_VALUEHL
24da			 
24da				if DEBUG_FORTH_WORDS 
24da					DMARK "DUs" 
24da f5				push af  
24db 3a ef 24			ld a, (.dmark)  
24de 32 6e fe			ld (debug_mark),a  
24e1 3a f0 24			ld a, (.dmark+1)  
24e4 32 6f fe			ld (debug_mark+1),a  
24e7 3a f1 24			ld a, (.dmark+2)  
24ea 32 70 fe			ld (debug_mark+2),a  
24ed 18 03			jr .pastdmark  
24ef ..			.dmark: db "DUs"  
24f2 f1			.pastdmark: pop af  
24f3			endm  
# End of macro DMARK
24f3					CALLMONITOR 
24f3 cd f3 18			call break_point_state  
24f6				endm  
# End of macro CALLMONITOR
24f6				endif 
24f6 cd d5 1f				call forth_push_str 
24f9			 
24f9					NEXTW 
24f9 c3 14 23			jp macro_next 
24fc				endm 
# End of macro NEXTW
24fc			 
24fc			 
24fc			.dupinum: 
24fc					 
24fc			 
24fc			 
24fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24fc cd 5e 21			call macro_dsp_valuehl 
24ff				endm 
# End of macro FORTH_DSP_VALUEHL
24ff			 
24ff				; TODO add floating point number detection 
24ff			 
24ff				if DEBUG_FORTH_WORDS 
24ff					DMARK "DUi" 
24ff f5				push af  
2500 3a 14 25			ld a, (.dmark)  
2503 32 6e fe			ld (debug_mark),a  
2506 3a 15 25			ld a, (.dmark+1)  
2509 32 6f fe			ld (debug_mark+1),a  
250c 3a 16 25			ld a, (.dmark+2)  
250f 32 70 fe			ld (debug_mark+2),a  
2512 18 03			jr .pastdmark  
2514 ..			.dmark: db "DUi"  
2517 f1			.pastdmark: pop af  
2518			endm  
# End of macro DMARK
2518					CALLMONITOR 
2518 cd f3 18			call break_point_state  
251b				endm  
# End of macro CALLMONITOR
251b				endif 
251b			 
251b cd 67 1f				call forth_push_numhl 
251e					NEXTW 
251e c3 14 23			jp macro_next 
2521				endm 
# End of macro NEXTW
2521			.ZDUP: 
2521				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2521 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2522 59 25			dw .SWAP            
2524 05				db 4 + 1 
2525 .. 00			db "?DUP",0              
252a				endm 
# End of macro CWHEAD
252a			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
252a			 
252a					if DEBUG_FORTH_WORDS_KEY 
252a						DMARK "qDU" 
252a f5				push af  
252b 3a 3f 25			ld a, (.dmark)  
252e 32 6e fe			ld (debug_mark),a  
2531 3a 40 25			ld a, (.dmark+1)  
2534 32 6f fe			ld (debug_mark+1),a  
2537 3a 41 25			ld a, (.dmark+2)  
253a 32 70 fe			ld (debug_mark+2),a  
253d 18 03			jr .pastdmark  
253f ..			.dmark: db "qDU"  
2542 f1			.pastdmark: pop af  
2543			endm  
# End of macro DMARK
2543						CALLMONITOR 
2543 cd f3 18			call break_point_state  
2546				endm  
# End of macro CALLMONITOR
2546					endif 
2546					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2546 cd 5e 21			call macro_dsp_valuehl 
2549				endm 
# End of macro FORTH_DSP_VALUEHL
2549			 
2549 e5					push hl 
254a			 
254a					; is it a zero? 
254a			 
254a 3e 00				ld a, 0 
254c 84					add h 
254d 85					add l 
254e			 
254e e1					pop hl 
254f			 
254f fe 00				cp 0 
2551 28 03				jr z, .dup2orig 
2553			 
2553			 
2553 cd 67 1f				call forth_push_numhl 
2556			 
2556			 
2556				; TODO add floating point number detection 
2556			 
2556			.dup2orig: 
2556			 
2556					NEXTW 
2556 c3 14 23			jp macro_next 
2559				endm 
# End of macro NEXTW
2559			.SWAP: 
2559				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2559 18				db WORD_SYS_CORE+OPCODE_SWAP             
255a 98 25			dw .COLN            
255c 05				db 4 + 1 
255d .. 00			db "SWAP",0              
2562				endm 
# End of macro CWHEAD
2562			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2562					if DEBUG_FORTH_WORDS_KEY 
2562						DMARK "SWP" 
2562 f5				push af  
2563 3a 77 25			ld a, (.dmark)  
2566 32 6e fe			ld (debug_mark),a  
2569 3a 78 25			ld a, (.dmark+1)  
256c 32 6f fe			ld (debug_mark+1),a  
256f 3a 79 25			ld a, (.dmark+2)  
2572 32 70 fe			ld (debug_mark+2),a  
2575 18 03			jr .pastdmark  
2577 ..			.dmark: db "SWP"  
257a f1			.pastdmark: pop af  
257b			endm  
# End of macro DMARK
257b						CALLMONITOR 
257b cd f3 18			call break_point_state  
257e				endm  
# End of macro CALLMONITOR
257e					endif 
257e			 
257e					FORTH_DSP_VALUEHL 
257e cd 5e 21			call macro_dsp_valuehl 
2581				endm 
# End of macro FORTH_DSP_VALUEHL
2581 e5					push hl     ; w2 
2582			 
2582					FORTH_DSP_POP 
2582 cd 16 22			call macro_forth_dsp_pop 
2585				endm 
# End of macro FORTH_DSP_POP
2585			 
2585					FORTH_DSP_VALUEHL 
2585 cd 5e 21			call macro_dsp_valuehl 
2588				endm 
# End of macro FORTH_DSP_VALUEHL
2588			 
2588					FORTH_DSP_POP 
2588 cd 16 22			call macro_forth_dsp_pop 
258b				endm 
# End of macro FORTH_DSP_POP
258b			 
258b d1					pop de     ; w2	, hl = w1 
258c			 
258c eb					ex de, hl 
258d d5					push de 
258e			 
258e cd 67 1f				call forth_push_numhl 
2591			 
2591 e1					pop hl 
2592			 
2592 cd 67 1f				call forth_push_numhl 
2595					 
2595			 
2595					NEXTW 
2595 c3 14 23			jp macro_next 
2598				endm 
# End of macro NEXTW
2598			.COLN: 
2598				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2598 19				db WORD_SYS_CORE+OPCODE_COLN             
2599 24 27			dw .SCOLN            
259b 02				db 1 + 1 
259c .. 00			db ":",0              
259e				endm 
# End of macro CWHEAD
259e			; | : ( -- )         Create new word | DONE 
259e			 
259e					if DEBUG_FORTH_WORDS_KEY 
259e						DMARK "CLN" 
259e f5				push af  
259f 3a b3 25			ld a, (.dmark)  
25a2 32 6e fe			ld (debug_mark),a  
25a5 3a b4 25			ld a, (.dmark+1)  
25a8 32 6f fe			ld (debug_mark+1),a  
25ab 3a b5 25			ld a, (.dmark+2)  
25ae 32 70 fe			ld (debug_mark+2),a  
25b1 18 03			jr .pastdmark  
25b3 ..			.dmark: db "CLN"  
25b6 f1			.pastdmark: pop af  
25b7			endm  
# End of macro DMARK
25b7						CALLMONITOR 
25b7 cd f3 18			call break_point_state  
25ba				endm  
# End of macro CALLMONITOR
25ba					endif 
25ba				STACKFRAME OFF $8efe $989f 
25ba				if DEBUG_STACK_IMB 
25ba					if OFF 
25ba						exx 
25ba						ld de, $8efe 
25ba						ld a, d 
25ba						ld hl, curframe 
25ba						call hexout 
25ba						ld a, e 
25ba						ld hl, curframe+2 
25ba						call hexout 
25ba						ld hl, $8efe 
25ba						push hl 
25ba						ld hl, $989f 
25ba						push hl 
25ba						exx 
25ba					endif 
25ba				endif 
25ba			endm 
# End of macro STACKFRAME
25ba				; get parser buffer length  of new word 
25ba			 
25ba				 
25ba			 
25ba					; move tok past this to start of name defintition 
25ba					; TODO get word to define 
25ba					; TODO Move past word token 
25ba					; TODO get length of string up to the ';' 
25ba			 
25ba 2a c9 f4			ld hl, (os_tok_ptr) 
25bd 23				inc hl 
25be 23				inc hl 
25bf			 
25bf 3e 3b			ld a, ';' 
25c1 cd b5 13			call strlent 
25c4			 
25c4 7d				ld a,l 
25c5 32 c4 f1			ld (os_new_parse_len), a 
25c8			 
25c8			 
25c8			if DEBUG_FORTH_UWORD 
25c8 ed 5b c9 f4		ld de, (os_tok_ptr) 
25cc						DMARK ":01" 
25cc f5				push af  
25cd 3a e1 25			ld a, (.dmark)  
25d0 32 6e fe			ld (debug_mark),a  
25d3 3a e2 25			ld a, (.dmark+1)  
25d6 32 6f fe			ld (debug_mark+1),a  
25d9 3a e3 25			ld a, (.dmark+2)  
25dc 32 70 fe			ld (debug_mark+2),a  
25df 18 03			jr .pastdmark  
25e1 ..			.dmark: db ":01"  
25e4 f1			.pastdmark: pop af  
25e5			endm  
# End of macro DMARK
25e5				CALLMONITOR 
25e5 cd f3 18			call break_point_state  
25e8				endm  
# End of macro CALLMONITOR
25e8			endif 
25e8			 
25e8			; 
25e8			;  new word memory layout: 
25e8			;  
25e8			;    : adg 6666 ;  
25e8			; 
25e8			;    db   1     ; user defined word  
25e8 23				inc hl    
25e9			;    dw   sysdict 
25e9 23				inc hl 
25ea 23				inc hl 
25eb			;    db <word len>+1 (for null) 
25eb 23				inc hl 
25ec			;    db .... <word> 
25ec			; 
25ec			 
25ec 23				inc hl    ; some extras for the word preamble before the above 
25ed 23				inc hl 
25ee 23				inc hl 
25ef 23				inc hl 
25f0 23				inc hl 
25f1 23				inc hl 
25f2 23				inc hl  
25f3 23				inc hl 
25f4 23				inc hl 
25f5 23				inc hl 
25f6 23				inc hl 
25f7 23				inc hl 
25f8 23				inc hl 
25f9 23				inc hl     ; TODO how many do we really need?     maybe only 6 
25fa			;       exec word buffer 
25fa			;	<ptr word>   
25fa 23				inc hl 
25fb 23				inc hl 
25fc			;       <word list><null term> 7F final term 
25fc			 
25fc			 
25fc			if DEBUG_FORTH_UWORD 
25fc						DMARK ":02" 
25fc f5				push af  
25fd 3a 11 26			ld a, (.dmark)  
2600 32 6e fe			ld (debug_mark),a  
2603 3a 12 26			ld a, (.dmark+1)  
2606 32 6f fe			ld (debug_mark+1),a  
2609 3a 13 26			ld a, (.dmark+2)  
260c 32 70 fe			ld (debug_mark+2),a  
260f 18 03			jr .pastdmark  
2611 ..			.dmark: db ":02"  
2614 f1			.pastdmark: pop af  
2615			endm  
# End of macro DMARK
2615				CALLMONITOR 
2615 cd f3 18			call break_point_state  
2618				endm  
# End of macro CALLMONITOR
2618			endif 
2618			 
2618				 
2618					; malloc the size 
2618			 
2618 cd 13 14				call malloc 
261b 22 c6 f1				ld (os_new_malloc), hl     ; save malloc start 
261e			 
261e			;    db   1     ; user defined word  
261e 3e 01				ld a, WORD_SYS_UWORD  
2620 77					ld (hl), a 
2621				 
2621 23				inc hl    
2622			;    dw   sysdict 
2622 11 6c 24			ld de, sysdict       ; continue on with the scan to the system dict 
2625 73				ld (hl), e 
2626 23				inc hl 
2627 72				ld (hl), d 
2628 23				inc hl 
2629			 
2629			 
2629			;    Setup dict word 
2629			 
2629 23				inc hl 
262a 22 c0 f1			ld (os_new_work_ptr), hl     ; save start of dict word  
262d			 
262d				; 1. get length of dict word 
262d			 
262d			 
262d 2a c9 f4			ld hl, (os_tok_ptr) 
2630 23				inc hl 
2631 23				inc hl    ; position to start of dict word 
2632 3e 00			ld a, 0 
2634 cd b5 13			call strlent 
2637			 
2637			 
2637 23				inc hl    ; to include null??? 
2638			 
2638				; write length of dict word 
2638			 
2638 ed 5b c0 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
263c 1b				dec de 
263d eb				ex de, hl 
263e 73				ld (hl), e 
263f eb				ex de, hl 
2640			 
2640				 
2640			 
2640				; copy  
2640 4d				ld c, l 
2641 06 00			ld b, 0 
2643 ed 5b c0 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2647 2a c9 f4			ld hl, (os_tok_ptr) 
264a 23				inc hl 
264b 23				inc hl    ; position to start of dict word 
264c				 
264c			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
264c				 
264c				; TODO need to convert word to upper case 
264c			 
264c			ucasetok:	 
264c 7e				ld a,(hl) 
264d cd a1 13			call toUpper 
2650 77				ld (hl),a 
2651 ed a0			ldi 
2653 f2 4c 26		 	jp p, ucasetok 
2656			 
2656			 
2656			 
2656				; de now points to start of where the word body code should be placed 
2656 ed 53 c0 f1		ld (os_new_work_ptr), de 
265a				; hl now points to the words to throw at forthexec which needs to be copied 
265a 22 be f1			ld (os_new_src_ptr), hl 
265d			 
265d				; TODO add 'call to forthexec' 
265d			 
265d			if DEBUG_FORTH_UWORD 
265d c5				push bc 
265e ed 4b c6 f1		ld bc, (os_new_malloc) 
2662						DMARK ":0x" 
2662 f5				push af  
2663 3a 77 26			ld a, (.dmark)  
2666 32 6e fe			ld (debug_mark),a  
2669 3a 78 26			ld a, (.dmark+1)  
266c 32 6f fe			ld (debug_mark+1),a  
266f 3a 79 26			ld a, (.dmark+2)  
2672 32 70 fe			ld (debug_mark+2),a  
2675 18 03			jr .pastdmark  
2677 ..			.dmark: db ":0x"  
267a f1			.pastdmark: pop af  
267b			endm  
# End of macro DMARK
267b				CALLMONITOR 
267b cd f3 18			call break_point_state  
267e				endm  
# End of macro CALLMONITOR
267e c1				pop bc 
267f			endif 
267f			 
267f			 
267f				; create word preamble which should be: 
267f			 
267f			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
267f			 
267f				;    ld hl, <word code> 
267f				;    jp user_exec 
267f			        ;    <word code bytes> 
267f			 
267f			 
267f			;	inc de     ; TODO ??? or are we already past the word's null 
267f eb				ex de, hl 
2680			 
2680 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2682			 
2682 23				inc hl 
2683 22 ba f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2686 23				inc hl 
2687			 
2687 23				inc hl 
2688 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
268a			 
268a 01 14 5b			ld bc, user_exec 
268d 23				inc hl 
268e 71				ld (hl), c     ; poke address of user_exec 
268f 23				inc hl 
2690 70				ld (hl), b     
2691			 ; 
2691			;	inc hl 
2691			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2691			; 
2691			; 
2691			;	ld bc, macro_forth_rsp_next 
2691			;	inc hl 
2691			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2691			;	inc hl 
2691			;	ld (hl), b     
2691			 ; 
2691			;	inc hl 
2691			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2691			; 
2691			; 
2691			;	inc hl 
2691			;	ld bc, forthexec 
2691			;	ld (hl), c     ; poke address of forthexec 
2691			;	inc hl 
2691			;	ld (hl), b      
2691			; 
2691			;	inc hl 
2691			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2691			; 
2691			;	ld bc, user_dict_next 
2691			;	inc hl 
2691			;	ld (hl), c     ; poke address of forthexec 
2691			;	inc hl 
2691			;	ld (hl), b      
2691			 
2691				; hl is now where we need to copy the word byte data to save this 
2691			 
2691 23				inc hl 
2692 22 bc f1			ld (os_new_exec), hl 
2695				 
2695				; copy definition 
2695			 
2695 eb				ex de, hl 
2696			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2696			;	inc de    ; skip the PC for this parse 
2696 3a c4 f1			ld a, (os_new_parse_len) 
2699 4f				ld c, a 
269a 06 00			ld b, 0 
269c ed b0			ldir		 ; copy defintion 
269e			 
269e			 
269e				; poke the address of where the new word bytes live for forthexec 
269e			 
269e 2a ba f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
26a1			 
26a1 ed 5b bc f1		ld de, (os_new_exec)      
26a5				 
26a5 73				ld (hl), e 
26a6 23				inc hl 
26a7 72				ld (hl), d 
26a8			 
26a8					; TODO copy last user dict word next link to this word 
26a8					; TODO update last user dict word to point to this word 
26a8			; 
26a8			; hl f923 de 812a ; bc 811a 
26a8			 
26a8			if DEBUG_FORTH_UWORD 
26a8 c5				push bc 
26a9 ed 4b c6 f1		ld bc, (os_new_malloc) 
26ad						DMARK ":0A" 
26ad f5				push af  
26ae 3a c2 26			ld a, (.dmark)  
26b1 32 6e fe			ld (debug_mark),a  
26b4 3a c3 26			ld a, (.dmark+1)  
26b7 32 6f fe			ld (debug_mark+1),a  
26ba 3a c4 26			ld a, (.dmark+2)  
26bd 32 70 fe			ld (debug_mark+2),a  
26c0 18 03			jr .pastdmark  
26c2 ..			.dmark: db ":0A"  
26c5 f1			.pastdmark: pop af  
26c6			endm  
# End of macro DMARK
26c6				CALLMONITOR 
26c6 cd f3 18			call break_point_state  
26c9				endm  
# End of macro CALLMONITOR
26c9 c1				pop bc 
26ca			endif 
26ca			if DEBUG_FORTH_UWORD 
26ca c5				push bc 
26cb ed 4b c6 f1		ld bc, (os_new_malloc) 
26cf 03				inc bc 
26d0 03				inc bc 
26d1 03				inc bc 
26d2 03				inc bc 
26d3 03				inc bc 
26d4 03				inc bc 
26d5 03				inc bc 
26d6 03				inc bc 
26d7			 
26d7						DMARK ":0B" 
26d7 f5				push af  
26d8 3a ec 26			ld a, (.dmark)  
26db 32 6e fe			ld (debug_mark),a  
26de 3a ed 26			ld a, (.dmark+1)  
26e1 32 6f fe			ld (debug_mark+1),a  
26e4 3a ee 26			ld a, (.dmark+2)  
26e7 32 70 fe			ld (debug_mark+2),a  
26ea 18 03			jr .pastdmark  
26ec ..			.dmark: db ":0B"  
26ef f1			.pastdmark: pop af  
26f0			endm  
# End of macro DMARK
26f0				CALLMONITOR 
26f0 cd f3 18			call break_point_state  
26f3				endm  
# End of macro CALLMONITOR
26f3 c1				pop bc 
26f4			endif 
26f4			 
26f4			; update word dict linked list for new word 
26f4			 
26f4			 
26f4 2a c5 f4		ld hl, (os_last_new_uword)		; get the start of the last added uword 
26f7 23			inc hl     ; move to next work linked list ptr 
26f8			 
26f8 ed 5b c6 f1	ld de, (os_new_malloc)		 ; new next word 
26fc 73			ld (hl), e 
26fd 23			inc hl 
26fe 72			ld (hl), d 
26ff			 
26ff			if DEBUG_FORTH_UWORD 
26ff ed 4b c5 f4		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2703			endif 
2703			 
2703 ed 53 c5 f4	ld (os_last_new_uword), de      ; update last new uword ptr 
2707			 
2707			 
2707			if DEBUG_FORTH_UWORD 
2707						DMARK ":0+" 
2707 f5				push af  
2708 3a 1c 27			ld a, (.dmark)  
270b 32 6e fe			ld (debug_mark),a  
270e 3a 1d 27			ld a, (.dmark+1)  
2711 32 6f fe			ld (debug_mark+1),a  
2714 3a 1e 27			ld a, (.dmark+2)  
2717 32 70 fe			ld (debug_mark+2),a  
271a 18 03			jr .pastdmark  
271c ..			.dmark: db ":0+"  
271f f1			.pastdmark: pop af  
2720			endm  
# End of macro DMARK
2720				CALLMONITOR 
2720 cd f3 18			call break_point_state  
2723				endm  
# End of macro CALLMONITOR
2723			endif 
2723			 
2723				STACKFRAMECHK OFF $8efe $989f 
2723				if DEBUG_STACK_IMB 
2723					if OFF 
2723						exx 
2723						ld hl, $989f 
2723						pop de   ; $989f 
2723						call cmp16 
2723						jr nz, .spnosame 
2723						ld hl, $8efe 
2723						pop de   ; $8efe 
2723						call cmp16 
2723						jr z, .spfrsame 
2723						.spnosame: call showsperror 
2723						.spfrsame: nop 
2723						exx 
2723					endif 
2723				endif 
2723			endm 
# End of macro STACKFRAMECHK
2723			 
2723 c9			ret    ; dont process any remaining parser tokens as they form new word 
2724			 
2724			 
2724			 
2724			 
2724			;		NEXT 
2724			.SCOLN: 
2724			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2724 06				db OPCODE_SCOLN 
2725 70 27			dw .DROP 
2727 02				db 2 
2728 .. 00			db ";",0           
272a			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
272a					if DEBUG_FORTH_WORDS_KEY 
272a						DMARK "SCN" 
272a f5				push af  
272b 3a 3f 27			ld a, (.dmark)  
272e 32 6e fe			ld (debug_mark),a  
2731 3a 40 27			ld a, (.dmark+1)  
2734 32 6f fe			ld (debug_mark+1),a  
2737 3a 41 27			ld a, (.dmark+2)  
273a 32 70 fe			ld (debug_mark+2),a  
273d 18 03			jr .pastdmark  
273f ..			.dmark: db "SCN"  
2742 f1			.pastdmark: pop af  
2743			endm  
# End of macro DMARK
2743						CALLMONITOR 
2743 cd f3 18			call break_point_state  
2746				endm  
# End of macro CALLMONITOR
2746					endif 
2746					FORTH_RSP_TOS 
2746 cd 25 1f			call macro_forth_rsp_tos 
2749				endm 
# End of macro FORTH_RSP_TOS
2749 e5					push hl 
274a					FORTH_RSP_POP 
274a cd 2f 1f			call macro_forth_rsp_pop 
274d				endm 
# End of macro FORTH_RSP_POP
274d e1					pop hl 
274e			;		ex de,hl 
274e 22 c9 f4				ld (os_tok_ptr),hl 
2751			 
2751			if DEBUG_FORTH_UWORD 
2751						DMARK "SCL" 
2751 f5				push af  
2752 3a 66 27			ld a, (.dmark)  
2755 32 6e fe			ld (debug_mark),a  
2758 3a 67 27			ld a, (.dmark+1)  
275b 32 6f fe			ld (debug_mark+1),a  
275e 3a 68 27			ld a, (.dmark+2)  
2761 32 70 fe			ld (debug_mark+2),a  
2764 18 03			jr .pastdmark  
2766 ..			.dmark: db "SCL"  
2769 f1			.pastdmark: pop af  
276a			endm  
# End of macro DMARK
276a				CALLMONITOR 
276a cd f3 18			call break_point_state  
276d				endm  
# End of macro CALLMONITOR
276d			endif 
276d					NEXTW 
276d c3 14 23			jp macro_next 
2770				endm 
# End of macro NEXTW
2770			 
2770			.DROP: 
2770				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2770 1b				db WORD_SYS_CORE+OPCODE_DROP             
2771 9b 27			dw .DUP2            
2773 05				db 4 + 1 
2774 .. 00			db "DROP",0              
2779				endm 
# End of macro CWHEAD
2779			; | DROP ( w -- )   drop the TOS item   | DONE 
2779					if DEBUG_FORTH_WORDS_KEY 
2779						DMARK "DRP" 
2779 f5				push af  
277a 3a 8e 27			ld a, (.dmark)  
277d 32 6e fe			ld (debug_mark),a  
2780 3a 8f 27			ld a, (.dmark+1)  
2783 32 6f fe			ld (debug_mark+1),a  
2786 3a 90 27			ld a, (.dmark+2)  
2789 32 70 fe			ld (debug_mark+2),a  
278c 18 03			jr .pastdmark  
278e ..			.dmark: db "DRP"  
2791 f1			.pastdmark: pop af  
2792			endm  
# End of macro DMARK
2792						CALLMONITOR 
2792 cd f3 18			call break_point_state  
2795				endm  
# End of macro CALLMONITOR
2795					endif 
2795					FORTH_DSP_POP 
2795 cd 16 22			call macro_forth_dsp_pop 
2798				endm 
# End of macro FORTH_DSP_POP
2798					NEXTW 
2798 c3 14 23			jp macro_next 
279b				endm 
# End of macro NEXTW
279b			.DUP2: 
279b				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
279b 1c				db WORD_SYS_CORE+OPCODE_DUP2             
279c e0 27			dw .DROP2            
279e 05				db 4 + 1 
279f .. 00			db "2DUP",0              
27a4				endm 
# End of macro CWHEAD
27a4			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
27a4					if DEBUG_FORTH_WORDS_KEY 
27a4						DMARK "2DU" 
27a4 f5				push af  
27a5 3a b9 27			ld a, (.dmark)  
27a8 32 6e fe			ld (debug_mark),a  
27ab 3a ba 27			ld a, (.dmark+1)  
27ae 32 6f fe			ld (debug_mark+1),a  
27b1 3a bb 27			ld a, (.dmark+2)  
27b4 32 70 fe			ld (debug_mark+2),a  
27b7 18 03			jr .pastdmark  
27b9 ..			.dmark: db "2DU"  
27bc f1			.pastdmark: pop af  
27bd			endm  
# End of macro DMARK
27bd						CALLMONITOR 
27bd cd f3 18			call break_point_state  
27c0				endm  
# End of macro CALLMONITOR
27c0					endif 
27c0					FORTH_DSP_VALUEHL 
27c0 cd 5e 21			call macro_dsp_valuehl 
27c3				endm 
# End of macro FORTH_DSP_VALUEHL
27c3 e5					push hl      ; 2 
27c4			 
27c4					FORTH_DSP_POP 
27c4 cd 16 22			call macro_forth_dsp_pop 
27c7				endm 
# End of macro FORTH_DSP_POP
27c7					 
27c7					FORTH_DSP_VALUEHL 
27c7 cd 5e 21			call macro_dsp_valuehl 
27ca				endm 
# End of macro FORTH_DSP_VALUEHL
27ca			;		push hl      ; 1 
27ca			 
27ca					FORTH_DSP_POP 
27ca cd 16 22			call macro_forth_dsp_pop 
27cd				endm 
# End of macro FORTH_DSP_POP
27cd			 
27cd			;		pop hl       ; 1 
27cd d1					pop de       ; 2 
27ce			 
27ce cd 67 1f				call forth_push_numhl 
27d1 eb					ex de, hl 
27d2 cd 67 1f				call forth_push_numhl 
27d5			 
27d5					 
27d5 eb					ex de, hl 
27d6			 
27d6 cd 67 1f				call forth_push_numhl 
27d9 eb					ex de, hl 
27da cd 67 1f				call forth_push_numhl 
27dd			 
27dd			 
27dd					NEXTW 
27dd c3 14 23			jp macro_next 
27e0				endm 
# End of macro NEXTW
27e0			.DROP2: 
27e0				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
27e0 1d				db WORD_SYS_CORE+OPCODE_DROP2             
27e1 0f 28			dw .SWAP2            
27e3 06				db 5 + 1 
27e4 .. 00			db "2DROP",0              
27ea				endm 
# End of macro CWHEAD
27ea			; | 2DROP ( w w -- )    Double drop | DONE 
27ea					if DEBUG_FORTH_WORDS_KEY 
27ea						DMARK "2DR" 
27ea f5				push af  
27eb 3a ff 27			ld a, (.dmark)  
27ee 32 6e fe			ld (debug_mark),a  
27f1 3a 00 28			ld a, (.dmark+1)  
27f4 32 6f fe			ld (debug_mark+1),a  
27f7 3a 01 28			ld a, (.dmark+2)  
27fa 32 70 fe			ld (debug_mark+2),a  
27fd 18 03			jr .pastdmark  
27ff ..			.dmark: db "2DR"  
2802 f1			.pastdmark: pop af  
2803			endm  
# End of macro DMARK
2803						CALLMONITOR 
2803 cd f3 18			call break_point_state  
2806				endm  
# End of macro CALLMONITOR
2806					endif 
2806					FORTH_DSP_POP 
2806 cd 16 22			call macro_forth_dsp_pop 
2809				endm 
# End of macro FORTH_DSP_POP
2809					FORTH_DSP_POP 
2809 cd 16 22			call macro_forth_dsp_pop 
280c				endm 
# End of macro FORTH_DSP_POP
280c					NEXTW 
280c c3 14 23			jp macro_next 
280f				endm 
# End of macro NEXTW
280f			.SWAP2: 
280f				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
280f 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2810 38 28			dw .AT            
2812 06				db 5 + 1 
2813 .. 00			db "2SWAP",0              
2819				endm 
# End of macro CWHEAD
2819			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2819					if DEBUG_FORTH_WORDS_KEY 
2819						DMARK "2SW" 
2819 f5				push af  
281a 3a 2e 28			ld a, (.dmark)  
281d 32 6e fe			ld (debug_mark),a  
2820 3a 2f 28			ld a, (.dmark+1)  
2823 32 6f fe			ld (debug_mark+1),a  
2826 3a 30 28			ld a, (.dmark+2)  
2829 32 70 fe			ld (debug_mark+2),a  
282c 18 03			jr .pastdmark  
282e ..			.dmark: db "2SW"  
2831 f1			.pastdmark: pop af  
2832			endm  
# End of macro DMARK
2832						CALLMONITOR 
2832 cd f3 18			call break_point_state  
2835				endm  
# End of macro CALLMONITOR
2835					endif 
2835					NEXTW 
2835 c3 14 23			jp macro_next 
2838				endm 
# End of macro NEXTW
2838			.AT: 
2838				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2838 1f				db WORD_SYS_CORE+OPCODE_AT             
2839 6a 28			dw .CAT            
283b 02				db 1 + 1 
283c .. 00			db "@",0              
283e				endm 
# End of macro CWHEAD
283e			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
283e			 
283e					if DEBUG_FORTH_WORDS_KEY 
283e						DMARK "AT." 
283e f5				push af  
283f 3a 53 28			ld a, (.dmark)  
2842 32 6e fe			ld (debug_mark),a  
2845 3a 54 28			ld a, (.dmark+1)  
2848 32 6f fe			ld (debug_mark+1),a  
284b 3a 55 28			ld a, (.dmark+2)  
284e 32 70 fe			ld (debug_mark+2),a  
2851 18 03			jr .pastdmark  
2853 ..			.dmark: db "AT."  
2856 f1			.pastdmark: pop af  
2857			endm  
# End of macro DMARK
2857						CALLMONITOR 
2857 cd f3 18			call break_point_state  
285a				endm  
# End of macro CALLMONITOR
285a					endif 
285a			.getbyteat:	 
285a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
285a cd 5e 21			call macro_dsp_valuehl 
285d				endm 
# End of macro FORTH_DSP_VALUEHL
285d					 
285d			;		push hl 
285d				 
285d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
285d cd 16 22			call macro_forth_dsp_pop 
2860				endm 
# End of macro FORTH_DSP_POP
2860			 
2860			;		pop hl 
2860			 
2860 7e					ld a, (hl) 
2861			 
2861 6f					ld l, a 
2862 26 00				ld h, 0 
2864 cd 67 1f				call forth_push_numhl 
2867			 
2867					NEXTW 
2867 c3 14 23			jp macro_next 
286a				endm 
# End of macro NEXTW
286a			.CAT: 
286a				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
286a 20				db WORD_SYS_CORE+OPCODE_CAT             
286b 93 28			dw .BANG            
286d 03				db 2 + 1 
286e .. 00			db "C@",0              
2871				endm 
# End of macro CWHEAD
2871			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2871					if DEBUG_FORTH_WORDS_KEY 
2871						DMARK "CAA" 
2871 f5				push af  
2872 3a 86 28			ld a, (.dmark)  
2875 32 6e fe			ld (debug_mark),a  
2878 3a 87 28			ld a, (.dmark+1)  
287b 32 6f fe			ld (debug_mark+1),a  
287e 3a 88 28			ld a, (.dmark+2)  
2881 32 70 fe			ld (debug_mark+2),a  
2884 18 03			jr .pastdmark  
2886 ..			.dmark: db "CAA"  
2889 f1			.pastdmark: pop af  
288a			endm  
# End of macro DMARK
288a						CALLMONITOR 
288a cd f3 18			call break_point_state  
288d				endm  
# End of macro CALLMONITOR
288d					endif 
288d c3 5a 28				jp .getbyteat 
2890					NEXTW 
2890 c3 14 23			jp macro_next 
2893				endm 
# End of macro NEXTW
2893			.BANG: 
2893				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2893 21				db WORD_SYS_CORE+OPCODE_BANG             
2894 c9 28			dw .CBANG            
2896 02				db 1 + 1 
2897 .. 00			db "!",0              
2899				endm 
# End of macro CWHEAD
2899			; | ! ( x w -- ) Store x at address w      | DONE 
2899					if DEBUG_FORTH_WORDS_KEY 
2899						DMARK "BNG" 
2899 f5				push af  
289a 3a ae 28			ld a, (.dmark)  
289d 32 6e fe			ld (debug_mark),a  
28a0 3a af 28			ld a, (.dmark+1)  
28a3 32 6f fe			ld (debug_mark+1),a  
28a6 3a b0 28			ld a, (.dmark+2)  
28a9 32 70 fe			ld (debug_mark+2),a  
28ac 18 03			jr .pastdmark  
28ae ..			.dmark: db "BNG"  
28b1 f1			.pastdmark: pop af  
28b2			endm  
# End of macro DMARK
28b2						CALLMONITOR 
28b2 cd f3 18			call break_point_state  
28b5				endm  
# End of macro CALLMONITOR
28b5					endif 
28b5			 
28b5			.storebyteat:		 
28b5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28b5 cd 5e 21			call macro_dsp_valuehl 
28b8				endm 
# End of macro FORTH_DSP_VALUEHL
28b8					 
28b8 e5					push hl 
28b9				 
28b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28b9 cd 16 22			call macro_forth_dsp_pop 
28bc				endm 
# End of macro FORTH_DSP_POP
28bc			 
28bc					; get byte to poke 
28bc			 
28bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28bc cd 5e 21			call macro_dsp_valuehl 
28bf				endm 
# End of macro FORTH_DSP_VALUEHL
28bf e5					push hl 
28c0			 
28c0			 
28c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28c0 cd 16 22			call macro_forth_dsp_pop 
28c3				endm 
# End of macro FORTH_DSP_POP
28c3			 
28c3			 
28c3 d1					pop de 
28c4 e1					pop hl 
28c5			 
28c5 73					ld (hl),e 
28c6			 
28c6			 
28c6					NEXTW 
28c6 c3 14 23			jp macro_next 
28c9				endm 
# End of macro NEXTW
28c9			.CBANG: 
28c9				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
28c9 22				db WORD_SYS_CORE+OPCODE_CBANG             
28ca f2 28			dw .SCALL            
28cc 03				db 2 + 1 
28cd .. 00			db "C!",0              
28d0				endm 
# End of macro CWHEAD
28d0			; | C!  ( x w -- ) Store x at address w  | DONE 
28d0					if DEBUG_FORTH_WORDS_KEY 
28d0						DMARK "CBA" 
28d0 f5				push af  
28d1 3a e5 28			ld a, (.dmark)  
28d4 32 6e fe			ld (debug_mark),a  
28d7 3a e6 28			ld a, (.dmark+1)  
28da 32 6f fe			ld (debug_mark+1),a  
28dd 3a e7 28			ld a, (.dmark+2)  
28e0 32 70 fe			ld (debug_mark+2),a  
28e3 18 03			jr .pastdmark  
28e5 ..			.dmark: db "CBA"  
28e8 f1			.pastdmark: pop af  
28e9			endm  
# End of macro DMARK
28e9						CALLMONITOR 
28e9 cd f3 18			call break_point_state  
28ec				endm  
# End of macro CALLMONITOR
28ec					endif 
28ec c3 b5 28				jp .storebyteat 
28ef					NEXTW 
28ef c3 14 23			jp macro_next 
28f2				endm 
# End of macro NEXTW
28f2			.SCALL: 
28f2				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
28f2 23				db WORD_SYS_CORE+OPCODE_SCALL             
28f3 26 29			dw .DEPTH            
28f5 05				db 4 + 1 
28f6 .. 00			db "CALL",0              
28fb				endm 
# End of macro CWHEAD
28fb			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
28fb					if DEBUG_FORTH_WORDS_KEY 
28fb						DMARK "CLL" 
28fb f5				push af  
28fc 3a 10 29			ld a, (.dmark)  
28ff 32 6e fe			ld (debug_mark),a  
2902 3a 11 29			ld a, (.dmark+1)  
2905 32 6f fe			ld (debug_mark+1),a  
2908 3a 12 29			ld a, (.dmark+2)  
290b 32 70 fe			ld (debug_mark+2),a  
290e 18 03			jr .pastdmark  
2910 ..			.dmark: db "CLL"  
2913 f1			.pastdmark: pop af  
2914			endm  
# End of macro DMARK
2914						CALLMONITOR 
2914 cd f3 18			call break_point_state  
2917				endm  
# End of macro CALLMONITOR
2917					endif 
2917			 
2917					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2917 cd 5e 21			call macro_dsp_valuehl 
291a				endm 
# End of macro FORTH_DSP_VALUEHL
291a			 
291a			;		push hl 
291a			 
291a					; destroy value TOS 
291a			 
291a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
291a cd 16 22			call macro_forth_dsp_pop 
291d				endm 
# End of macro FORTH_DSP_POP
291d			 
291d						 
291d			;		pop hl 
291d			 
291d					; how to do a call with hl???? save SP? 
291d cd b8 22				call forth_call_hl 
2920			 
2920			 
2920					; TODO push value back onto stack for another op etc 
2920			 
2920 cd 67 1f				call forth_push_numhl 
2923					NEXTW 
2923 c3 14 23			jp macro_next 
2926				endm 
# End of macro NEXTW
2926			.DEPTH: 
2926				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2926 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2927 63 29			dw .OVER            
2929 06				db 5 + 1 
292a .. 00			db "DEPTH",0              
2930				endm 
# End of macro CWHEAD
2930			; | DEPTH ( -- u ) Push count of stack | DONE 
2930					; take current TOS and remove from base value div by two to get count 
2930					if DEBUG_FORTH_WORDS_KEY 
2930						DMARK "DEP" 
2930 f5				push af  
2931 3a 45 29			ld a, (.dmark)  
2934 32 6e fe			ld (debug_mark),a  
2937 3a 46 29			ld a, (.dmark+1)  
293a 32 6f fe			ld (debug_mark+1),a  
293d 3a 47 29			ld a, (.dmark+2)  
2940 32 70 fe			ld (debug_mark+2),a  
2943 18 03			jr .pastdmark  
2945 ..			.dmark: db "DEP"  
2948 f1			.pastdmark: pop af  
2949			endm  
# End of macro DMARK
2949						CALLMONITOR 
2949 cd f3 18			call break_point_state  
294c				endm  
# End of macro CALLMONITOR
294c					endif 
294c			 
294c			 
294c 2a f5 f9			ld hl, (cli_data_sp) 
294f 11 2f f7			ld de, cli_data_stack 
2952 ed 52			sbc hl,de 
2954				 
2954				; div by size of stack item 
2954			 
2954 5d				ld e,l 
2955 0e 03			ld c, 3 
2957 cd dc 0e			call Div8 
295a			 
295a 6f				ld l,a 
295b 26 00			ld h,0 
295d			 
295d				;srl h 
295d				;rr l 
295d			 
295d cd 67 1f				call forth_push_numhl 
2960					NEXTW 
2960 c3 14 23			jp macro_next 
2963				endm 
# End of macro NEXTW
2963			.OVER: 
2963				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2963 42				db WORD_SYS_CORE+46             
2964 aa 29			dw .PAUSE            
2966 05				db 4 + 1 
2967 .. 00			db "OVER",0              
296c				endm 
# End of macro CWHEAD
296c			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
296c					if DEBUG_FORTH_WORDS_KEY 
296c						DMARK "OVR" 
296c f5				push af  
296d 3a 81 29			ld a, (.dmark)  
2970 32 6e fe			ld (debug_mark),a  
2973 3a 82 29			ld a, (.dmark+1)  
2976 32 6f fe			ld (debug_mark+1),a  
2979 3a 83 29			ld a, (.dmark+2)  
297c 32 70 fe			ld (debug_mark+2),a  
297f 18 03			jr .pastdmark  
2981 ..			.dmark: db "OVR"  
2984 f1			.pastdmark: pop af  
2985			endm  
# End of macro DMARK
2985						CALLMONITOR 
2985 cd f3 18			call break_point_state  
2988				endm  
# End of macro CALLMONITOR
2988					endif 
2988			 
2988					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2988 cd 5e 21			call macro_dsp_valuehl 
298b				endm 
# End of macro FORTH_DSP_VALUEHL
298b e5					push hl    ; n2 
298c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
298c cd 16 22			call macro_forth_dsp_pop 
298f				endm 
# End of macro FORTH_DSP_POP
298f			 
298f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
298f cd 5e 21			call macro_dsp_valuehl 
2992				endm 
# End of macro FORTH_DSP_VALUEHL
2992 e5					push hl    ; n1 
2993					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2993 cd 16 22			call macro_forth_dsp_pop 
2996				endm 
# End of macro FORTH_DSP_POP
2996			 
2996 d1					pop de     ; n1 
2997 e1					pop hl     ; n2 
2998			 
2998 d5					push de 
2999 e5					push hl 
299a d5					push de 
299b			 
299b					; push back  
299b			 
299b e1					pop hl 
299c cd 67 1f				call forth_push_numhl 
299f e1					pop hl 
29a0 cd 67 1f				call forth_push_numhl 
29a3 e1					pop hl 
29a4 cd 67 1f				call forth_push_numhl 
29a7					NEXTW 
29a7 c3 14 23			jp macro_next 
29aa				endm 
# End of macro NEXTW
29aa			 
29aa			.PAUSE: 
29aa				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
29aa 43				db WORD_SYS_CORE+47             
29ab df 29			dw .PAUSES            
29ad 08				db 7 + 1 
29ae .. 00			db "PAUSEMS",0              
29b6				endm 
# End of macro CWHEAD
29b6			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
29b6					if DEBUG_FORTH_WORDS_KEY 
29b6						DMARK "PMS" 
29b6 f5				push af  
29b7 3a cb 29			ld a, (.dmark)  
29ba 32 6e fe			ld (debug_mark),a  
29bd 3a cc 29			ld a, (.dmark+1)  
29c0 32 6f fe			ld (debug_mark+1),a  
29c3 3a cd 29			ld a, (.dmark+2)  
29c6 32 70 fe			ld (debug_mark+2),a  
29c9 18 03			jr .pastdmark  
29cb ..			.dmark: db "PMS"  
29ce f1			.pastdmark: pop af  
29cf			endm  
# End of macro DMARK
29cf						CALLMONITOR 
29cf cd f3 18			call break_point_state  
29d2				endm  
# End of macro CALLMONITOR
29d2					endif 
29d2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29d2 cd 5e 21			call macro_dsp_valuehl 
29d5				endm 
# End of macro FORTH_DSP_VALUEHL
29d5			;		push hl    ; n2 
29d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29d5 cd 16 22			call macro_forth_dsp_pop 
29d8				endm 
# End of macro FORTH_DSP_POP
29d8			;		pop hl 
29d8			 
29d8 7d					ld a, l 
29d9 cd 7a 0c				call aDelayInMS 
29dc				       NEXTW 
29dc c3 14 23			jp macro_next 
29df				endm 
# End of macro NEXTW
29df			.PAUSES:  
29df				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
29df 44				db WORD_SYS_CORE+48             
29e0 4e 2a			dw .ROT            
29e2 06				db 5 + 1 
29e3 .. 00			db "PAUSE",0              
29e9				endm 
# End of macro CWHEAD
29e9			; | PAUSE ( n -- )  Pause for n seconds | DONE 
29e9					if DEBUG_FORTH_WORDS_KEY 
29e9						DMARK "PAU" 
29e9 f5				push af  
29ea 3a fe 29			ld a, (.dmark)  
29ed 32 6e fe			ld (debug_mark),a  
29f0 3a ff 29			ld a, (.dmark+1)  
29f3 32 6f fe			ld (debug_mark+1),a  
29f6 3a 00 2a			ld a, (.dmark+2)  
29f9 32 70 fe			ld (debug_mark+2),a  
29fc 18 03			jr .pastdmark  
29fe ..			.dmark: db "PAU"  
2a01 f1			.pastdmark: pop af  
2a02			endm  
# End of macro DMARK
2a02						CALLMONITOR 
2a02 cd f3 18			call break_point_state  
2a05				endm  
# End of macro CALLMONITOR
2a05					endif 
2a05					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a05 cd 5e 21			call macro_dsp_valuehl 
2a08				endm 
# End of macro FORTH_DSP_VALUEHL
2a08			;		push hl    ; n2 
2a08					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a08 cd 16 22			call macro_forth_dsp_pop 
2a0b				endm 
# End of macro FORTH_DSP_POP
2a0b			;		pop hl 
2a0b 45					ld b, l 
2a0c					if DEBUG_FORTH_WORDS 
2a0c						DMARK "PAU" 
2a0c f5				push af  
2a0d 3a 21 2a			ld a, (.dmark)  
2a10 32 6e fe			ld (debug_mark),a  
2a13 3a 22 2a			ld a, (.dmark+1)  
2a16 32 6f fe			ld (debug_mark+1),a  
2a19 3a 23 2a			ld a, (.dmark+2)  
2a1c 32 70 fe			ld (debug_mark+2),a  
2a1f 18 03			jr .pastdmark  
2a21 ..			.dmark: db "PAU"  
2a24 f1			.pastdmark: pop af  
2a25			endm  
# End of macro DMARK
2a25						CALLMONITOR 
2a25 cd f3 18			call break_point_state  
2a28				endm  
# End of macro CALLMONITOR
2a28					endif 
2a28 c5			.pauses1:	push bc 
2a29 cd 95 0c				call delay1s 
2a2c c1					pop bc 
2a2d					if DEBUG_FORTH_WORDS 
2a2d						DMARK "PA1" 
2a2d f5				push af  
2a2e 3a 42 2a			ld a, (.dmark)  
2a31 32 6e fe			ld (debug_mark),a  
2a34 3a 43 2a			ld a, (.dmark+1)  
2a37 32 6f fe			ld (debug_mark+1),a  
2a3a 3a 44 2a			ld a, (.dmark+2)  
2a3d 32 70 fe			ld (debug_mark+2),a  
2a40 18 03			jr .pastdmark  
2a42 ..			.dmark: db "PA1"  
2a45 f1			.pastdmark: pop af  
2a46			endm  
# End of macro DMARK
2a46						CALLMONITOR 
2a46 cd f3 18			call break_point_state  
2a49				endm  
# End of macro CALLMONITOR
2a49					endif 
2a49 10 dd				djnz .pauses1 
2a4b			 
2a4b				       NEXTW 
2a4b c3 14 23			jp macro_next 
2a4e				endm 
# End of macro NEXTW
2a4e			.ROT: 
2a4e				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2a4e 45				db WORD_SYS_CORE+49             
2a4f 9c 2a			dw .UWORDS            
2a51 04				db 3 + 1 
2a52 .. 00			db "ROT",0              
2a56				endm 
# End of macro CWHEAD
2a56			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2a56					if DEBUG_FORTH_WORDS_KEY 
2a56						DMARK "ROT" 
2a56 f5				push af  
2a57 3a 6b 2a			ld a, (.dmark)  
2a5a 32 6e fe			ld (debug_mark),a  
2a5d 3a 6c 2a			ld a, (.dmark+1)  
2a60 32 6f fe			ld (debug_mark+1),a  
2a63 3a 6d 2a			ld a, (.dmark+2)  
2a66 32 70 fe			ld (debug_mark+2),a  
2a69 18 03			jr .pastdmark  
2a6b ..			.dmark: db "ROT"  
2a6e f1			.pastdmark: pop af  
2a6f			endm  
# End of macro DMARK
2a6f						CALLMONITOR 
2a6f cd f3 18			call break_point_state  
2a72				endm  
# End of macro CALLMONITOR
2a72					endif 
2a72			 
2a72					FORTH_DSP_VALUEHL 
2a72 cd 5e 21			call macro_dsp_valuehl 
2a75				endm 
# End of macro FORTH_DSP_VALUEHL
2a75 e5					push hl    ; u3  
2a76			 
2a76					FORTH_DSP_POP 
2a76 cd 16 22			call macro_forth_dsp_pop 
2a79				endm 
# End of macro FORTH_DSP_POP
2a79			   
2a79					FORTH_DSP_VALUEHL 
2a79 cd 5e 21			call macro_dsp_valuehl 
2a7c				endm 
# End of macro FORTH_DSP_VALUEHL
2a7c e5					push hl     ; u2 
2a7d			 
2a7d					FORTH_DSP_POP 
2a7d cd 16 22			call macro_forth_dsp_pop 
2a80				endm 
# End of macro FORTH_DSP_POP
2a80			 
2a80					FORTH_DSP_VALUEHL 
2a80 cd 5e 21			call macro_dsp_valuehl 
2a83				endm 
# End of macro FORTH_DSP_VALUEHL
2a83 e5					push hl     ; u1 
2a84			 
2a84					FORTH_DSP_POP 
2a84 cd 16 22			call macro_forth_dsp_pop 
2a87				endm 
# End of macro FORTH_DSP_POP
2a87			 
2a87 c1					pop bc      ; u1 
2a88 e1					pop hl      ; u2 
2a89 d1					pop de      ; u3 
2a8a			 
2a8a			 
2a8a c5					push bc 
2a8b d5					push de 
2a8c e5					push hl 
2a8d			 
2a8d			 
2a8d e1					pop hl 
2a8e cd 67 1f				call forth_push_numhl 
2a91			 
2a91 e1					pop hl 
2a92 cd 67 1f				call forth_push_numhl 
2a95			 
2a95 e1					pop hl 
2a96 cd 67 1f				call forth_push_numhl 
2a99					 
2a99			 
2a99			 
2a99			 
2a99			 
2a99			 
2a99				       NEXTW 
2a99 c3 14 23			jp macro_next 
2a9c				endm 
# End of macro NEXTW
2a9c			 
2a9c			.UWORDS: 
2a9c				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2a9c 50				db WORD_SYS_CORE+60             
2a9d 5e 2b			dw .BP            
2a9f 07				db 6 + 1 
2aa0 .. 00			db "UWORDS",0              
2aa7				endm 
# End of macro CWHEAD
2aa7			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2aa7			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2aa7			; | | Following the count are the individual words. 
2aa7			; | | 
2aa7			; | | e.g. UWORDS 
2aa7			; | | BOX DIRLIST 2 
2aa7			; | |  
2aa7			; | | Can be used to save the words to storage via: 
2aa7			; | | UWORDS $01 DO $01 APPEND LOOP 
2aa7				if DEBUG_FORTH_WORDS_KEY 
2aa7					DMARK "UWR" 
2aa7 f5				push af  
2aa8 3a bc 2a			ld a, (.dmark)  
2aab 32 6e fe			ld (debug_mark),a  
2aae 3a bd 2a			ld a, (.dmark+1)  
2ab1 32 6f fe			ld (debug_mark+1),a  
2ab4 3a be 2a			ld a, (.dmark+2)  
2ab7 32 70 fe			ld (debug_mark+2),a  
2aba 18 03			jr .pastdmark  
2abc ..			.dmark: db "UWR"  
2abf f1			.pastdmark: pop af  
2ac0			endm  
# End of macro DMARK
2ac0					CALLMONITOR 
2ac0 cd f3 18			call break_point_state  
2ac3				endm  
# End of macro CALLMONITOR
2ac3				endif 
2ac3 21 00 80				ld hl, baseram 
2ac6					;ld hl, baseusermem 
2ac6 01 00 00				ld bc, 0    ; start a counter 
2ac9			 
2ac9				; skip dict stub 
2ac9			 
2ac9 cd 65 24				call forth_tok_next 
2acc			 
2acc			 
2acc			; while we have words to look for 
2acc			 
2acc 7e			.douscan:	ld a, (hl)      
2acd				if DEBUG_FORTH_WORDS 
2acd					DMARK "UWs" 
2acd f5				push af  
2ace 3a e2 2a			ld a, (.dmark)  
2ad1 32 6e fe			ld (debug_mark),a  
2ad4 3a e3 2a			ld a, (.dmark+1)  
2ad7 32 6f fe			ld (debug_mark+1),a  
2ada 3a e4 2a			ld a, (.dmark+2)  
2add 32 70 fe			ld (debug_mark+2),a  
2ae0 18 03			jr .pastdmark  
2ae2 ..			.dmark: db "UWs"  
2ae5 f1			.pastdmark: pop af  
2ae6			endm  
# End of macro DMARK
2ae6					CALLMONITOR 
2ae6 cd f3 18			call break_point_state  
2ae9				endm  
# End of macro CALLMONITOR
2ae9				endif 
2ae9 fe 00				cp WORD_SYS_END 
2aeb 28 4d				jr z, .udone 
2aed fe 01				cp WORD_SYS_UWORD 
2aef 20 44				jr nz, .nuword 
2af1			 
2af1				if DEBUG_FORTH_WORDS 
2af1					DMARK "UWu" 
2af1 f5				push af  
2af2 3a 06 2b			ld a, (.dmark)  
2af5 32 6e fe			ld (debug_mark),a  
2af8 3a 07 2b			ld a, (.dmark+1)  
2afb 32 6f fe			ld (debug_mark+1),a  
2afe 3a 08 2b			ld a, (.dmark+2)  
2b01 32 70 fe			ld (debug_mark+2),a  
2b04 18 03			jr .pastdmark  
2b06 ..			.dmark: db "UWu"  
2b09 f1			.pastdmark: pop af  
2b0a			endm  
# End of macro DMARK
2b0a					CALLMONITOR 
2b0a cd f3 18			call break_point_state  
2b0d				endm  
# End of macro CALLMONITOR
2b0d				endif 
2b0d					; we have a uword so push its name to the stack 
2b0d			 
2b0d e5				   	push hl  ; save so we can move to next dict block 
2b0e			 
2b0e					; skip opcode 
2b0e 23					inc hl  
2b0f					; skip next ptr 
2b0f 23					inc hl  
2b10 23					inc hl 
2b11					; skip len 
2b11 23					inc hl 
2b12				if DEBUG_FORTH_WORDS 
2b12					DMARK "UWt" 
2b12 f5				push af  
2b13 3a 27 2b			ld a, (.dmark)  
2b16 32 6e fe			ld (debug_mark),a  
2b19 3a 28 2b			ld a, (.dmark+1)  
2b1c 32 6f fe			ld (debug_mark+1),a  
2b1f 3a 29 2b			ld a, (.dmark+2)  
2b22 32 70 fe			ld (debug_mark+2),a  
2b25 18 03			jr .pastdmark  
2b27 ..			.dmark: db "UWt"  
2b2a f1			.pastdmark: pop af  
2b2b			endm  
# End of macro DMARK
2b2b					CALLMONITOR 
2b2b cd f3 18			call break_point_state  
2b2e				endm  
# End of macro CALLMONITOR
2b2e				endif 
2b2e 03					inc bc 
2b2f			 
2b2f c5					push bc 
2b30 cd d5 1f				call forth_push_str 
2b33 c1					pop bc 
2b34			 
2b34 e1					pop hl 	 
2b35			 
2b35 cd 65 24		.nuword:	call forth_tok_next 
2b38 18 92				jr .douscan  
2b3a			 
2b3a			.udone:		 ; push count of uwords found 
2b3a c5					push bc 
2b3b e1					pop hl 
2b3c			 
2b3c				if DEBUG_FORTH_WORDS 
2b3c					DMARK "UWc" 
2b3c f5				push af  
2b3d 3a 51 2b			ld a, (.dmark)  
2b40 32 6e fe			ld (debug_mark),a  
2b43 3a 52 2b			ld a, (.dmark+1)  
2b46 32 6f fe			ld (debug_mark+1),a  
2b49 3a 53 2b			ld a, (.dmark+2)  
2b4c 32 70 fe			ld (debug_mark+2),a  
2b4f 18 03			jr .pastdmark  
2b51 ..			.dmark: db "UWc"  
2b54 f1			.pastdmark: pop af  
2b55			endm  
# End of macro DMARK
2b55					CALLMONITOR 
2b55 cd f3 18			call break_point_state  
2b58				endm  
# End of macro CALLMONITOR
2b58				endif 
2b58 cd 67 1f				call forth_push_numhl 
2b5b			 
2b5b			 
2b5b				       NEXTW 
2b5b c3 14 23			jp macro_next 
2b5e				endm 
# End of macro NEXTW
2b5e			 
2b5e			.BP: 
2b5e				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2b5e 54				db WORD_SYS_CORE+64             
2b5f 94 2b			dw .MONITOR            
2b61 03				db 2 + 1 
2b62 .. 00			db "BP",0              
2b65				endm 
# End of macro CWHEAD
2b65			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2b65			; | | $00 Will enable the break points within specific code paths 
2b65			; | | $01 Will disable break points 
2b65			; | |  
2b65			; | | By default break points are off. Either the above can be used to enable them 
2b65			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2b65			; | | and on release of the pressed key a message will be disaplayed to notify 
2b65			; | | that break points are enabled. Pressing any key will then continue boot process. 
2b65					; get byte count 
2b65					if DEBUG_FORTH_WORDS_KEY 
2b65						DMARK "BP." 
2b65 f5				push af  
2b66 3a 7a 2b			ld a, (.dmark)  
2b69 32 6e fe			ld (debug_mark),a  
2b6c 3a 7b 2b			ld a, (.dmark+1)  
2b6f 32 6f fe			ld (debug_mark+1),a  
2b72 3a 7c 2b			ld a, (.dmark+2)  
2b75 32 70 fe			ld (debug_mark+2),a  
2b78 18 03			jr .pastdmark  
2b7a ..			.dmark: db "BP."  
2b7d f1			.pastdmark: pop af  
2b7e			endm  
# End of macro DMARK
2b7e						CALLMONITOR 
2b7e cd f3 18			call break_point_state  
2b81				endm  
# End of macro CALLMONITOR
2b81					endif 
2b81			 
2b81					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b81 cd 5e 21			call macro_dsp_valuehl 
2b84				endm 
# End of macro FORTH_DSP_VALUEHL
2b84			 
2b84			;		push hl 
2b84			 
2b84					; destroy value TOS 
2b84			 
2b84					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b84 cd 16 22			call macro_forth_dsp_pop 
2b87				endm 
# End of macro FORTH_DSP_POP
2b87			 
2b87			;		pop hl 
2b87			 
2b87 3e 00				ld a,0 
2b89 bd					cp l 
2b8a 28 02				jr z, .bpset 
2b8c 3e 2a				ld a, '*' 
2b8e			 
2b8e 32 b9 f1		.bpset:		ld (os_view_disable), a 
2b91			 
2b91			 
2b91					NEXTW 
2b91 c3 14 23			jp macro_next 
2b94				endm 
# End of macro NEXTW
2b94			 
2b94			 
2b94			.MONITOR: 
2b94				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2b94 55				db WORD_SYS_CORE+65             
2b95 c7 2b			dw .MALLOC            
2b97 08				db 7 + 1 
2b98 .. 00			db "MONITOR",0              
2ba0				endm 
# End of macro CWHEAD
2ba0			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2ba0			; | | At start the current various registers will be displayed with contents. 
2ba0			; | | Top right corner will show the most recent debug marker seen. 
2ba0			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2ba0			; | | and the return stack pointer (RSP). 
2ba0			; | | Pressing: 
2ba0			; | |    1 - Initial screen 
2ba0			; | |    2 - Display a data dump of HL 
2ba0			; | |    3 - Display a data dump of DE 
2ba0			; | |    4 - Display a data dump of BC 
2ba0			; | |    5 - Display a data dump of HL 
2ba0			; | |    6 - Display a data dump of DSP 
2ba0			; | |    7 - Display a data dump of RSP 
2ba0			; | |    8 - Display a data dump of what is at DSP 
2ba0			; | |    9 - Display a data dump of what is at RSP 
2ba0			; | |    0 - Exit monitor and continue running. This will also enable break points 
2ba0			; | |    * - Disable break points 
2ba0			; | |    # - Enter traditional monitor mode 
2ba0			; | | 
2ba0			; | | Monitor Mode 
2ba0			; | | ------------ 
2ba0			; | | A prompt of '>' will be shown for various commands: 
2ba0			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2ba0			; | |    C - Continue display a data dump from the last set address 
2ba0			; | |    M xxxx - Set start of memory edit at address xx 
2ba0			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2ba0			; | |    Q - Return to previous 
2ba0					if DEBUG_FORTH_WORDS_KEY 
2ba0						DMARK "MON" 
2ba0 f5				push af  
2ba1 3a b5 2b			ld a, (.dmark)  
2ba4 32 6e fe			ld (debug_mark),a  
2ba7 3a b6 2b			ld a, (.dmark+1)  
2baa 32 6f fe			ld (debug_mark+1),a  
2bad 3a b7 2b			ld a, (.dmark+2)  
2bb0 32 70 fe			ld (debug_mark+2),a  
2bb3 18 03			jr .pastdmark  
2bb5 ..			.dmark: db "MON"  
2bb8 f1			.pastdmark: pop af  
2bb9			endm  
# End of macro DMARK
2bb9						CALLMONITOR 
2bb9 cd f3 18			call break_point_state  
2bbc				endm  
# End of macro CALLMONITOR
2bbc					endif 
2bbc 3e 00				ld a, 0 
2bbe 32 b9 f1				ld (os_view_disable), a 
2bc1			 
2bc1					CALLMONITOR 
2bc1 cd f3 18			call break_point_state  
2bc4				endm  
# End of macro CALLMONITOR
2bc4			 
2bc4			;	call monitor 
2bc4			 
2bc4					NEXTW 
2bc4 c3 14 23			jp macro_next 
2bc7				endm 
# End of macro NEXTW
2bc7			 
2bc7			 
2bc7			.MALLOC: 
2bc7				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2bc7 56				db WORD_SYS_CORE+66             
2bc8 f0 2b			dw .MALLOC2            
2bca 06				db 5 + 1 
2bcb .. 00			db "ALLOT",0              
2bd1				endm 
# End of macro CWHEAD
2bd1			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2bd1					if DEBUG_FORTH_WORDS_KEY 
2bd1						DMARK "ALL" 
2bd1 f5				push af  
2bd2 3a e6 2b			ld a, (.dmark)  
2bd5 32 6e fe			ld (debug_mark),a  
2bd8 3a e7 2b			ld a, (.dmark+1)  
2bdb 32 6f fe			ld (debug_mark+1),a  
2bde 3a e8 2b			ld a, (.dmark+2)  
2be1 32 70 fe			ld (debug_mark+2),a  
2be4 18 03			jr .pastdmark  
2be6 ..			.dmark: db "ALL"  
2be9 f1			.pastdmark: pop af  
2bea			endm  
# End of macro DMARK
2bea						CALLMONITOR 
2bea cd f3 18			call break_point_state  
2bed				endm  
# End of macro CALLMONITOR
2bed					endif 
2bed c3 17 2c				jp .mallocc 
2bf0			.MALLOC2: 
2bf0				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2bf0 56				db WORD_SYS_CORE+66             
2bf1 2e 2c			dw .FREE            
2bf3 07				db 6 + 1 
2bf4 .. 00			db "MALLOC",0              
2bfb				endm 
# End of macro CWHEAD
2bfb			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2bfb					; get byte count 
2bfb					if DEBUG_FORTH_WORDS_KEY 
2bfb						DMARK "MAL" 
2bfb f5				push af  
2bfc 3a 10 2c			ld a, (.dmark)  
2bff 32 6e fe			ld (debug_mark),a  
2c02 3a 11 2c			ld a, (.dmark+1)  
2c05 32 6f fe			ld (debug_mark+1),a  
2c08 3a 12 2c			ld a, (.dmark+2)  
2c0b 32 70 fe			ld (debug_mark+2),a  
2c0e 18 03			jr .pastdmark  
2c10 ..			.dmark: db "MAL"  
2c13 f1			.pastdmark: pop af  
2c14			endm  
# End of macro DMARK
2c14						CALLMONITOR 
2c14 cd f3 18			call break_point_state  
2c17				endm  
# End of macro CALLMONITOR
2c17					endif 
2c17			.mallocc: 
2c17					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c17 cd 5e 21			call macro_dsp_valuehl 
2c1a				endm 
# End of macro FORTH_DSP_VALUEHL
2c1a			 
2c1a			;		push hl 
2c1a			 
2c1a					; destroy value TOS 
2c1a			 
2c1a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c1a cd 16 22			call macro_forth_dsp_pop 
2c1d				endm 
# End of macro FORTH_DSP_POP
2c1d			 
2c1d			;		pop hl 
2c1d cd 13 14				call malloc 
2c20				if DEBUG_FORTH_MALLOC_GUARD 
2c20 f5					push af 
2c21 cd 75 0f				call ishlzero 
2c24			;		ld a, l 
2c24			;		add h 
2c24			;		cp 0 
2c24 f1					pop af 
2c25					 
2c25 cc e6 5b				call z,malloc_error 
2c28				endif 
2c28			 
2c28 cd 67 1f				call forth_push_numhl 
2c2b					NEXTW 
2c2b c3 14 23			jp macro_next 
2c2e				endm 
# End of macro NEXTW
2c2e			 
2c2e			.FREE: 
2c2e				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2c2e 57				db WORD_SYS_CORE+67             
2c2f 5f 2c			dw .LIST            
2c31 05				db 4 + 1 
2c32 .. 00			db "FREE",0              
2c37				endm 
# End of macro CWHEAD
2c37			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2c37					if DEBUG_FORTH_WORDS_KEY 
2c37						DMARK "FRE" 
2c37 f5				push af  
2c38 3a 4c 2c			ld a, (.dmark)  
2c3b 32 6e fe			ld (debug_mark),a  
2c3e 3a 4d 2c			ld a, (.dmark+1)  
2c41 32 6f fe			ld (debug_mark+1),a  
2c44 3a 4e 2c			ld a, (.dmark+2)  
2c47 32 70 fe			ld (debug_mark+2),a  
2c4a 18 03			jr .pastdmark  
2c4c ..			.dmark: db "FRE"  
2c4f f1			.pastdmark: pop af  
2c50			endm  
# End of macro DMARK
2c50						CALLMONITOR 
2c50 cd f3 18			call break_point_state  
2c53				endm  
# End of macro CALLMONITOR
2c53					endif 
2c53					; get address 
2c53			 
2c53					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c53 cd 5e 21			call macro_dsp_valuehl 
2c56				endm 
# End of macro FORTH_DSP_VALUEHL
2c56			 
2c56			;		push hl 
2c56			 
2c56					; destroy value TOS 
2c56			 
2c56					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c56 cd 16 22			call macro_forth_dsp_pop 
2c59				endm 
# End of macro FORTH_DSP_POP
2c59			 
2c59			;		pop hl 
2c59			if FORTH_ENABLE_MALLOCFREE 
2c59 cd dd 14				call free 
2c5c			endif 
2c5c					NEXTW 
2c5c c3 14 23			jp macro_next 
2c5f				endm 
# End of macro NEXTW
2c5f			.LIST: 
2c5f				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2c5f 5c				db WORD_SYS_CORE+72             
2c60 4d 2e			dw .FORGET            
2c62 05				db 4 + 1 
2c63 .. 00			db "LIST",0              
2c68				endm 
# End of macro CWHEAD
2c68			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2c68			; | | The quoted word must be in upper case. 
2c68				if DEBUG_FORTH_WORDS_KEY 
2c68					DMARK "LST" 
2c68 f5				push af  
2c69 3a 7d 2c			ld a, (.dmark)  
2c6c 32 6e fe			ld (debug_mark),a  
2c6f 3a 7e 2c			ld a, (.dmark+1)  
2c72 32 6f fe			ld (debug_mark+1),a  
2c75 3a 7f 2c			ld a, (.dmark+2)  
2c78 32 70 fe			ld (debug_mark+2),a  
2c7b 18 03			jr .pastdmark  
2c7d ..			.dmark: db "LST"  
2c80 f1			.pastdmark: pop af  
2c81			endm  
# End of macro DMARK
2c81					CALLMONITOR 
2c81 cd f3 18			call break_point_state  
2c84				endm  
# End of macro CALLMONITOR
2c84				endif 
2c84			 
2c84					FORTH_DSP_VALUEHL 
2c84 cd 5e 21			call macro_dsp_valuehl 
2c87				endm 
# End of macro FORTH_DSP_VALUEHL
2c87			 
2c87 e5					push hl 
2c88					FORTH_DSP_POP 
2c88 cd 16 22			call macro_forth_dsp_pop 
2c8b				endm 
# End of macro FORTH_DSP_POP
2c8b c1					pop bc 
2c8c			 
2c8c			; Start format of scratch string 
2c8c			 
2c8c 21 c8 f1				ld hl, scratch 
2c8f			 
2c8f 3e 3a				ld a, ':' 
2c91 77					ld (hl),a 
2c92 23					inc hl 
2c93 3e 20				ld a, ' ' 
2c95 77					ld (hl), a 
2c96			 
2c96					; Get ptr to the word we need to look up 
2c96			 
2c96			;		FORTH_DSP_VALUEHL 
2c96					;v5 FORTH_DSP_VALUE 
2c96				; TODO type check 
2c96			;		inc hl    ; Skip type check  
2c96			;		push hl 
2c96			;		ex de, hl    ; put into DE 
2c96			 
2c96			 
2c96 21 00 80				ld hl, baseram 
2c99					;ld hl, baseusermem 
2c99			 
2c99 e5			push hl   ; sacreifical push 
2c9a			 
2c9a			.ldouscanm: 
2c9a e1				pop hl 
2c9b			.ldouscan: 
2c9b				if DEBUG_FORTH_WORDS 
2c9b					DMARK "LSs" 
2c9b f5				push af  
2c9c 3a b0 2c			ld a, (.dmark)  
2c9f 32 6e fe			ld (debug_mark),a  
2ca2 3a b1 2c			ld a, (.dmark+1)  
2ca5 32 6f fe			ld (debug_mark+1),a  
2ca8 3a b2 2c			ld a, (.dmark+2)  
2cab 32 70 fe			ld (debug_mark+2),a  
2cae 18 03			jr .pastdmark  
2cb0 ..			.dmark: db "LSs"  
2cb3 f1			.pastdmark: pop af  
2cb4			endm  
# End of macro DMARK
2cb4					CALLMONITOR 
2cb4 cd f3 18			call break_point_state  
2cb7				endm  
# End of macro CALLMONITOR
2cb7				endif 
2cb7				; skip dict stub 
2cb7 cd 65 24				call forth_tok_next 
2cba			 
2cba			 
2cba			; while we have words to look for 
2cba			 
2cba 7e				ld a, (hl)      
2cbb				if DEBUG_FORTH_WORDS 
2cbb					DMARK "LSk" 
2cbb f5				push af  
2cbc 3a d0 2c			ld a, (.dmark)  
2cbf 32 6e fe			ld (debug_mark),a  
2cc2 3a d1 2c			ld a, (.dmark+1)  
2cc5 32 6f fe			ld (debug_mark+1),a  
2cc8 3a d2 2c			ld a, (.dmark+2)  
2ccb 32 70 fe			ld (debug_mark+2),a  
2cce 18 03			jr .pastdmark  
2cd0 ..			.dmark: db "LSk"  
2cd3 f1			.pastdmark: pop af  
2cd4			endm  
# End of macro DMARK
2cd4					CALLMONITOR 
2cd4 cd f3 18			call break_point_state  
2cd7				endm  
# End of macro CALLMONITOR
2cd7				endif 
2cd7					;cp WORD_SYS_END 
2cd7					;jp z, .lunotfound 
2cd7			 
2cd7					; if we hit non uwords then gone too far 
2cd7 fe 01				cp WORD_SYS_UWORD 
2cd9 c2 09 2e				jp nz, .lunotfound 
2cdc			 
2cdc				if DEBUG_FORTH_WORDS 
2cdc					DMARK "LSu" 
2cdc f5				push af  
2cdd 3a f1 2c			ld a, (.dmark)  
2ce0 32 6e fe			ld (debug_mark),a  
2ce3 3a f2 2c			ld a, (.dmark+1)  
2ce6 32 6f fe			ld (debug_mark+1),a  
2ce9 3a f3 2c			ld a, (.dmark+2)  
2cec 32 70 fe			ld (debug_mark+2),a  
2cef 18 03			jr .pastdmark  
2cf1 ..			.dmark: db "LSu"  
2cf4 f1			.pastdmark: pop af  
2cf5			endm  
# End of macro DMARK
2cf5					CALLMONITOR 
2cf5 cd f3 18			call break_point_state  
2cf8				endm  
# End of macro CALLMONITOR
2cf8				endif 
2cf8			 
2cf8					; found a uword but is it the one we want... 
2cf8			 
2cf8 c5					push bc     ; uword to find is on bc 
2cf9 d1					pop de 
2cfa			 
2cfa e5					push hl  ; to save the ptr 
2cfb			 
2cfb					; skip opcode 
2cfb 23					inc hl  
2cfc					; skip next ptr 
2cfc 23					inc hl  
2cfd 23					inc hl 
2cfe					; skip len 
2cfe 23					inc hl 
2cff			 
2cff				if DEBUG_FORTH_WORDS 
2cff					DMARK "LSc" 
2cff f5				push af  
2d00 3a 14 2d			ld a, (.dmark)  
2d03 32 6e fe			ld (debug_mark),a  
2d06 3a 15 2d			ld a, (.dmark+1)  
2d09 32 6f fe			ld (debug_mark+1),a  
2d0c 3a 16 2d			ld a, (.dmark+2)  
2d0f 32 70 fe			ld (debug_mark+2),a  
2d12 18 03			jr .pastdmark  
2d14 ..			.dmark: db "LSc"  
2d17 f1			.pastdmark: pop af  
2d18			endm  
# End of macro DMARK
2d18					CALLMONITOR 
2d18 cd f3 18			call break_point_state  
2d1b				endm  
# End of macro CALLMONITOR
2d1b				endif 
2d1b cd e2 13				call strcmp 
2d1e c2 9a 2c				jp nz, .ldouscanm 
2d21				 
2d21			 
2d21			 
2d21					; we have a uword so push its name to the stack 
2d21			 
2d21			;	   	push hl  ; save so we can move to next dict block 
2d21 e1			pop hl 
2d22			 
2d22				if DEBUG_FORTH_WORDS 
2d22					DMARK "LSm" 
2d22 f5				push af  
2d23 3a 37 2d			ld a, (.dmark)  
2d26 32 6e fe			ld (debug_mark),a  
2d29 3a 38 2d			ld a, (.dmark+1)  
2d2c 32 6f fe			ld (debug_mark+1),a  
2d2f 3a 39 2d			ld a, (.dmark+2)  
2d32 32 70 fe			ld (debug_mark+2),a  
2d35 18 03			jr .pastdmark  
2d37 ..			.dmark: db "LSm"  
2d3a f1			.pastdmark: pop af  
2d3b			endm  
# End of macro DMARK
2d3b					CALLMONITOR 
2d3b cd f3 18			call break_point_state  
2d3e				endm  
# End of macro CALLMONITOR
2d3e				endif 
2d3e			 
2d3e					; skip opcode 
2d3e 23					inc hl  
2d3f					; skip next ptr 
2d3f 23					inc hl  
2d40 23					inc hl 
2d41					; skip len 
2d41 7e					ld a, (hl)   ; save length to add 
2d42				if DEBUG_FORTH_WORDS 
2d42					DMARK "LS2" 
2d42 f5				push af  
2d43 3a 57 2d			ld a, (.dmark)  
2d46 32 6e fe			ld (debug_mark),a  
2d49 3a 58 2d			ld a, (.dmark+1)  
2d4c 32 6f fe			ld (debug_mark+1),a  
2d4f 3a 59 2d			ld a, (.dmark+2)  
2d52 32 70 fe			ld (debug_mark+2),a  
2d55 18 03			jr .pastdmark  
2d57 ..			.dmark: db "LS2"  
2d5a f1			.pastdmark: pop af  
2d5b			endm  
# End of macro DMARK
2d5b					CALLMONITOR 
2d5b cd f3 18			call break_point_state  
2d5e				endm  
# End of macro CALLMONITOR
2d5e				endif 
2d5e			 
2d5e					; save this location 
2d5e				 
2d5e e5					push hl 
2d5f			 
2d5f 23					inc hl 
2d60 11 ca f1				ld de, scratch+2 
2d63 4f					ld c, a 
2d64 06 00				ld b, 0 
2d66			 
2d66				if DEBUG_FORTH_WORDS 
2d66					DMARK "LSn" 
2d66 f5				push af  
2d67 3a 7b 2d			ld a, (.dmark)  
2d6a 32 6e fe			ld (debug_mark),a  
2d6d 3a 7c 2d			ld a, (.dmark+1)  
2d70 32 6f fe			ld (debug_mark+1),a  
2d73 3a 7d 2d			ld a, (.dmark+2)  
2d76 32 70 fe			ld (debug_mark+2),a  
2d79 18 03			jr .pastdmark  
2d7b ..			.dmark: db "LSn"  
2d7e f1			.pastdmark: pop af  
2d7f			endm  
# End of macro DMARK
2d7f					CALLMONITOR 
2d7f cd f3 18			call break_point_state  
2d82				endm  
# End of macro CALLMONITOR
2d82				endif 
2d82			 
2d82					; copy uword name to scratch 
2d82			 
2d82 ed b0				ldir 
2d84			 
2d84 1b					dec de 
2d85 3e 20				ld a, ' '    ; change null to space 
2d87 12					ld (de), a 
2d88			 
2d88 13					inc de 
2d89			 
2d89 d5					push de 
2d8a c1					pop bc     ; move scratch pointer to end of word name and save it 
2d8b			 
2d8b e1					pop hl 
2d8c 7e					ld a, (hl) 
2d8d					;inc hl 
2d8d					; skip word string 
2d8d cd 4c 0f				call addatohl 
2d90			 
2d90 23					inc hl 
2d91			 
2d91				if DEBUG_FORTH_WORDS 
2d91					DMARK "LS3" 
2d91 f5				push af  
2d92 3a a6 2d			ld a, (.dmark)  
2d95 32 6e fe			ld (debug_mark),a  
2d98 3a a7 2d			ld a, (.dmark+1)  
2d9b 32 6f fe			ld (debug_mark+1),a  
2d9e 3a a8 2d			ld a, (.dmark+2)  
2da1 32 70 fe			ld (debug_mark+2),a  
2da4 18 03			jr .pastdmark  
2da6 ..			.dmark: db "LS3"  
2da9 f1			.pastdmark: pop af  
2daa			endm  
# End of macro DMARK
2daa					CALLMONITOR 
2daa cd f3 18			call break_point_state  
2dad				endm  
# End of macro CALLMONITOR
2dad				endif 
2dad					; should now be at the start of the machine code to setup the eval of the uword 
2dad					; now locate the ptr to the string defintion 
2dad			 
2dad					; skip ld hl, 
2dad					; then load the ptr 
2dad			; TODO use get from hl ptr 
2dad 23					inc hl 
2dae 5e					ld e, (hl) 
2daf 23					inc hl 
2db0 56					ld d, (hl) 
2db1 eb					ex de, hl 
2db2			 
2db2			 
2db2				if DEBUG_FORTH_WORDS 
2db2					DMARK "LSt" 
2db2 f5				push af  
2db3 3a c7 2d			ld a, (.dmark)  
2db6 32 6e fe			ld (debug_mark),a  
2db9 3a c8 2d			ld a, (.dmark+1)  
2dbc 32 6f fe			ld (debug_mark+1),a  
2dbf 3a c9 2d			ld a, (.dmark+2)  
2dc2 32 70 fe			ld (debug_mark+2),a  
2dc5 18 03			jr .pastdmark  
2dc7 ..			.dmark: db "LSt"  
2dca f1			.pastdmark: pop af  
2dcb			endm  
# End of macro DMARK
2dcb					CALLMONITOR 
2dcb cd f3 18			call break_point_state  
2dce				endm  
# End of macro CALLMONITOR
2dce				endif 
2dce			 
2dce			; cant push right now due to tokenised strings  
2dce			 
2dce			; get the destination of where to copy this definition to. 
2dce			 
2dce c5					push bc 
2dcf d1					pop de 
2dd0			 
2dd0 7e			.listl:         ld a,(hl) 
2dd1 fe 00				cp 0 
2dd3 28 09				jr z, .lreplsp     ; replace zero with space 
2dd5					;cp FORTH_END_BUFFER 
2dd5 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2dd7 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2dd9				 
2dd9					; just copy this char as is then 
2dd9			 
2dd9 12					ld (de), a 
2dda			 
2dda 23			.listnxt:	inc hl 
2ddb 13					inc de 
2ddc 18 f2				jr .listl 
2dde			 
2dde 3e 20		.lreplsp:	ld a,' ' 
2de0 12					ld (de), a 
2de1 18 f7				jr .listnxt 
2de3			 
2de3			; close up uword def 
2de3			 
2de3			.listdone: 
2de3 12					ld (de), a 
2de4 13					inc de 
2de5 3e 00				ld a, 0 
2de7 12					ld (de), a 
2de8			 
2de8			; now have def so clean up and push to stack 
2de8			 
2de8 21 c8 f1				ld hl, scratch 
2deb				if DEBUG_FORTH_WORDS 
2deb					DMARK "Ltp" 
2deb f5				push af  
2dec 3a 00 2e			ld a, (.dmark)  
2def 32 6e fe			ld (debug_mark),a  
2df2 3a 01 2e			ld a, (.dmark+1)  
2df5 32 6f fe			ld (debug_mark+1),a  
2df8 3a 02 2e			ld a, (.dmark+2)  
2dfb 32 70 fe			ld (debug_mark+2),a  
2dfe 18 03			jr .pastdmark  
2e00 ..			.dmark: db "Ltp"  
2e03 f1			.pastdmark: pop af  
2e04			endm  
# End of macro DMARK
2e04					CALLMONITOR 
2e04 cd f3 18			call break_point_state  
2e07				endm  
# End of macro CALLMONITOR
2e07				endif 
2e07			 
2e07 18 1f			jr .listpush 
2e09			 
2e09			;.lnuword:	pop hl 
2e09			;		call forth_tok_next 
2e09			;		jp .ldouscan  
2e09			 
2e09			.lunotfound:		  
2e09			 
2e09				if DEBUG_FORTH_WORDS 
2e09					DMARK "LSn" 
2e09 f5				push af  
2e0a 3a 1e 2e			ld a, (.dmark)  
2e0d 32 6e fe			ld (debug_mark),a  
2e10 3a 1f 2e			ld a, (.dmark+1)  
2e13 32 6f fe			ld (debug_mark+1),a  
2e16 3a 20 2e			ld a, (.dmark+2)  
2e19 32 70 fe			ld (debug_mark+2),a  
2e1c 18 03			jr .pastdmark  
2e1e ..			.dmark: db "LSn"  
2e21 f1			.pastdmark: pop af  
2e22			endm  
# End of macro DMARK
2e22					CALLMONITOR 
2e22 cd f3 18			call break_point_state  
2e25				endm  
# End of macro CALLMONITOR
2e25				endif 
2e25			 
2e25					 
2e25			;		FORTH_DSP_POP 
2e25			;		ld hl, .luno 
2e25			 
2e25					NEXTW			 
2e25 c3 14 23			jp macro_next 
2e28				endm 
# End of macro NEXTW
2e28			 
2e28			.listpush: 
2e28				if DEBUG_FORTH_WORDS 
2e28					DMARK "LS>" 
2e28 f5				push af  
2e29 3a 3d 2e			ld a, (.dmark)  
2e2c 32 6e fe			ld (debug_mark),a  
2e2f 3a 3e 2e			ld a, (.dmark+1)  
2e32 32 6f fe			ld (debug_mark+1),a  
2e35 3a 3f 2e			ld a, (.dmark+2)  
2e38 32 70 fe			ld (debug_mark+2),a  
2e3b 18 03			jr .pastdmark  
2e3d ..			.dmark: db "LS>"  
2e40 f1			.pastdmark: pop af  
2e41			endm  
# End of macro DMARK
2e41					CALLMONITOR 
2e41 cd f3 18			call break_point_state  
2e44				endm  
# End of macro CALLMONITOR
2e44				endif 
2e44 cd d5 1f				call forth_push_str 
2e47			 
2e47			 
2e47			 
2e47					NEXTW 
2e47 c3 14 23			jp macro_next 
2e4a				endm 
# End of macro NEXTW
2e4a			 
2e4a			;.luno:    db "Word not found",0 
2e4a			 
2e4a			 
2e4a			 
2e4a			 
2e4a			 
2e4a			;		push hl   ; save pointer to start of uword def string 
2e4a			; 
2e4a			;; look for FORTH_EOL_LINE 
2e4a			;		ld a, FORTH_END_BUFFER 
2e4a			;		call strlent 
2e4a			; 
2e4a			;		inc hl		 ; space for coln def 
2e4a			;		inc hl 
2e4a			;		inc hl          ; space for terms 
2e4a			;		inc hl 
2e4a			; 
2e4a			;		ld a, 20   ; TODO get actual length 
2e4a			;		call addatohl    ; include a random amount of room for the uword name 
2e4a			; 
2e4a			;		 
2e4a			;	if DEBUG_FORTH_WORDS 
2e4a			;		DMARK "Lt1" 
2e4a			;		CALLMONITOR 
2e4a			;	endif 
2e4a			;		 
2e4a			; 
2e4a			;; malloc space for the string because we cant change it 
2e4a			; 
2e4a			;		call malloc 
2e4a			;	if DEBUG_FORTH_MALLOC_GUARD 
2e4a			;		push af 
2e4a			;		call ishlzero 
2e4a			;		pop af 
2e4a			;		 
2e4a			;		call z,malloc_error 
2e4a			;	endif 
2e4a			; 
2e4a			;	if DEBUG_FORTH_WORDS 
2e4a			;		DMARK "Lt2" 
2e4a			;		CALLMONITOR 
2e4a			;	endif 
2e4a			;		pop de 
2e4a			;		push hl    ; push the malloc to release later 
2e4a			;		push hl   ;  push back a copy for the later stack push 
2e4a			;		 
2e4a			;; copy the string swapping out the zero terms for spaces 
2e4a			; 
2e4a			;		; de has our source 
2e4a			;		; hl has our dest 
2e4a			; 
2e4a			;; add the coln def 
2e4a			; 
2e4a			;		ld a, ':' 
2e4a			;		ld (hl), a 
2e4a			;		inc hl 
2e4a			;		ld a, ' ' 
2e4a			;		ld (hl), a 
2e4a			;		inc hl 
2e4a			; 
2e4a			;; add the uname word 
2e4a			;		push de   ; save our string for now 
2e4a			;		ex de, hl 
2e4a			; 
2e4a			;		FORTH_DSP_VALUE 
2e4a			;		;v5 FORTH_DSP_VALUE 
2e4a			; 
2e4a			;		inc hl   ; skip type but we know by now this is OK 
2e4a			; 
2e4a			;.luword:	ld a,(hl) 
2e4a			;		cp 0 
2e4a			;		jr z, .luword2 
2e4a			;		ld (de), a 
2e4a			;		inc de 
2e4a			;		inc hl 
2e4a			;		jr .luword 
2e4a			; 
2e4a			;.luword2:	ld a, ' ' 
2e4a			;		ld (de), a 
2e4a			;;		inc hl 
2e4a			;;		inc de 
2e4a			;;		ld (de), a 
2e4a			;;		inc hl 
2e4a			;		inc de 
2e4a			; 
2e4a			;		ex de, hl 
2e4a			;		pop de 
2e4a			;		 
2e4a			;		 
2e4a			; 
2e4a			;; detoken that string and copy it 
2e4a			; 
2e4a			;	if DEBUG_FORTH_WORDS 
2e4a			;		DMARK "Lt2" 
2e4a			;		CALLMONITOR 
2e4a			;	endif 
2e4a			;.ldetok:	ld a, (de) 
2e4a			;		cp FORTH_END_BUFFER 
2e4a			;		jr z, .ldetokend 
2e4a			;		; swap out any zero term for space 
2e4a			;		cp 0 
2e4a			;		jr nz, .ldetoknext 
2e4a			;		ld a, ' ' 
2e4a			; 
2e4a			;	if DEBUG_FORTH_WORDS 
2e4a			;		DMARK "LtS" 
2e4a			;		CALLMONITOR 
2e4a			;	endif 
2e4a			;.ldetoknext:	ld (hl), a 
2e4a			;		inc de 
2e4a			;		inc hl 
2e4a			;		jr .ldetok 
2e4a			; 
2e4a			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2e4a			;		ld (hl), a  
2e4a			; 
2e4a			;; free that temp malloc 
2e4a			; 
2e4a			;		pop hl    
2e4a			; 
2e4a			;	if DEBUG_FORTH_WORDS 
2e4a			;		DMARK "Lt4" 
2e4a			;		CALLMONITOR 
2e4a			;	endif 
2e4a			;		call forth_apushstrhl 
2e4a			; 
2e4a			;		; get rid of temp malloc area 
2e4a			; 
2e4a			;		pop hl 
2e4a			;		call free 
2e4a			; 
2e4a			;		jr .ludone 
2e4a			; 
2e4a			;.lnuword:	pop hl 
2e4a			;		call forth_tok_next 
2e4a			;		jp .ldouscan  
2e4a			; 
2e4a			;.ludone:		 pop hl 
2e4a			; 
2e4a					NEXTW 
2e4a c3 14 23			jp macro_next 
2e4d				endm 
# End of macro NEXTW
2e4d			 
2e4d			.FORGET: 
2e4d				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2e4d 5d				db WORD_SYS_CORE+73             
2e4e c6 2e			dw .NOP            
2e50 07				db 6 + 1 
2e51 .. 00			db "FORGET",0              
2e58				endm 
# End of macro CWHEAD
2e58			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2e58			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2e58			; | |  
2e58			; | | e.g. "MORE" forget 
2e58					if DEBUG_FORTH_WORDS_KEY 
2e58						DMARK "FRG" 
2e58 f5				push af  
2e59 3a 6d 2e			ld a, (.dmark)  
2e5c 32 6e fe			ld (debug_mark),a  
2e5f 3a 6e 2e			ld a, (.dmark+1)  
2e62 32 6f fe			ld (debug_mark+1),a  
2e65 3a 6f 2e			ld a, (.dmark+2)  
2e68 32 70 fe			ld (debug_mark+2),a  
2e6b 18 03			jr .pastdmark  
2e6d ..			.dmark: db "FRG"  
2e70 f1			.pastdmark: pop af  
2e71			endm  
# End of macro DMARK
2e71						CALLMONITOR 
2e71 cd f3 18			call break_point_state  
2e74				endm  
# End of macro CALLMONITOR
2e74					endif 
2e74			 
2e74				; find uword 
2e74			        ; update start of word with "_" 
2e74				; replace uword with deleted flag 
2e74			 
2e74			 
2e74			;	if DEBUG_FORTH_WORDS 
2e74			;		DMARK "FOG" 
2e74			;		CALLMONITOR 
2e74			;	endif 
2e74			 
2e74			 
2e74					; Get ptr to the word we need to look up 
2e74			 
2e74					FORTH_DSP_VALUEHL 
2e74 cd 5e 21			call macro_dsp_valuehl 
2e77				endm 
# End of macro FORTH_DSP_VALUEHL
2e77					;v5 FORTH_DSP_VALUE 
2e77				; TODO type check 
2e77			;		inc hl    ; Skip type check  
2e77 e5					push hl 
2e78 c1					pop bc 
2e79			;		ex de, hl    ; put into DE 
2e79			 
2e79			 
2e79 21 00 80				ld hl, baseram 
2e7c					;ld hl, baseusermem 
2e7c			 
2e7c				; skip dict stub 
2e7c			;	call forth_tok_next 
2e7c e5			push hl   ; sacreifical push 
2e7d			 
2e7d			.fldouscanm: 
2e7d e1				pop hl 
2e7e			.fldouscan: 
2e7e			;	if DEBUG_FORTH_WORDS 
2e7e			;		DMARK "LSs" 
2e7e			;		CALLMONITOR 
2e7e			;	endif 
2e7e				; skip dict stub 
2e7e cd 65 24				call forth_tok_next 
2e81			 
2e81			 
2e81			; while we have words to look for 
2e81			 
2e81 7e				ld a, (hl)      
2e82			;	if DEBUG_FORTH_WORDS 
2e82			;		DMARK "LSk" 
2e82			;		CALLMONITOR 
2e82			;	endif 
2e82 fe 00				cp WORD_SYS_END 
2e84 ca c0 2e				jp z, .flunotfound 
2e87 fe 01				cp WORD_SYS_UWORD 
2e89 c2 7e 2e				jp nz, .fldouscan 
2e8c			 
2e8c			;	if DEBUG_FORTH_WORDS 
2e8c			;		DMARK "LSu" 
2e8c			;		CALLMONITOR 
2e8c			;	endif 
2e8c			 
2e8c					; found a uword but is it the one we want... 
2e8c			 
2e8c c5					push bc     ; uword to find is on bc 
2e8d d1					pop de 
2e8e			 
2e8e e5					push hl  ; to save the ptr 
2e8f			 
2e8f					; skip opcode 
2e8f 23					inc hl  
2e90					; skip next ptr 
2e90 23					inc hl  
2e91 23					inc hl 
2e92					; skip len 
2e92 23					inc hl 
2e93			 
2e93			;	if DEBUG_FORTH_WORDS 
2e93			;		DMARK "LSc" 
2e93			;		CALLMONITOR 
2e93			;	endif 
2e93 cd e2 13				call strcmp 
2e96 c2 7d 2e				jp nz, .fldouscanm 
2e99			; 
2e99			; 
2e99			;; while we have words to look for 
2e99			; 
2e99			;.fdouscan:	ld a, (hl)      
2e99			;	if DEBUG_FORTH_WORDS 
2e99			;		DMARK "LSs" 
2e99			;		CALLMONITOR 
2e99			;	endif 
2e99			;		cp WORD_SYS_END 
2e99			;		jp z, .fudone 
2e99			;		cp WORD_SYS_UWORD 
2e99			;		jp nz, .fnuword 
2e99			; 
2e99			;	if DEBUG_FORTH_WORDS 
2e99			;		DMARK "FGu" 
2e99			;		CALLMONITOR 
2e99			;	endif 
2e99			; 
2e99			;		; found a uword but is it the one we want... 
2e99			; 
2e99			; 
2e99			;	        pop de   ; get back the dsp name 
2e99			;		push de 
2e99			; 
2e99			;		push hl  ; to save the ptr 
2e99			; 
2e99			;		; skip opcode 
2e99			;		inc hl  
2e99			;		; skip next ptr 
2e99			;		inc hl  
2e99			;		inc hl 
2e99			;		; skip len 
2e99			;		inc hl 
2e99			; 
2e99			;	if DEBUG_FORTH_WORDS 
2e99			;		DMARK "FGc" 
2e99			;		CALLMONITOR 
2e99			;	endif 
2e99			;		call strcmp 
2e99			;		jp nz, .fnuword 
2e99			 
2e99			 
2e99 e1			pop hl 
2e9a			 
2e9a				 
2e9a				if DEBUG_FORTH_WORDS 
2e9a					DMARK "FGm" 
2e9a f5				push af  
2e9b 3a af 2e			ld a, (.dmark)  
2e9e 32 6e fe			ld (debug_mark),a  
2ea1 3a b0 2e			ld a, (.dmark+1)  
2ea4 32 6f fe			ld (debug_mark+1),a  
2ea7 3a b1 2e			ld a, (.dmark+2)  
2eaa 32 70 fe			ld (debug_mark+2),a  
2ead 18 03			jr .pastdmark  
2eaf ..			.dmark: db "FGm"  
2eb2 f1			.pastdmark: pop af  
2eb3			endm  
# End of macro DMARK
2eb3					CALLMONITOR 
2eb3 cd f3 18			call break_point_state  
2eb6				endm  
# End of macro CALLMONITOR
2eb6				endif 
2eb6			 
2eb6			 
2eb6			 
2eb6					; we have a uword so push its name to the stack 
2eb6			 
2eb6			;	   	push hl  ; save so we can move to next dict block 
2eb6			;pop hl 
2eb6			 
2eb6					; update opcode to deleted 
2eb6 3e 03				ld a, WORD_SYS_DELETED 
2eb8 77					ld (hl), a 
2eb9			 
2eb9 23					inc hl  
2eba					; skip next ptr 
2eba 23					inc hl  
2ebb 23					inc hl 
2ebc					; skip len 
2ebc 23					inc hl 
2ebd			 
2ebd					; TODO change parser to skip deleted words but for now mark it out 
2ebd 3e 5f				ld a, "_" 
2ebf 77					ld  (hl),a 
2ec0			 
2ec0			;		jr .fudone 
2ec0			; 
2ec0			;.fnuword:	pop hl 
2ec0			;		call forth_tok_next 
2ec0			;		jp .fdouscan  
2ec0			 
2ec0			.flunotfound:		  
2ec0			 
2ec0			 
2ec0					 
2ec0					FORTH_DSP_POP 
2ec0 cd 16 22			call macro_forth_dsp_pop 
2ec3				endm 
# End of macro FORTH_DSP_POP
2ec3			;		ld hl, .luno 
2ec3			;.fudone:		 pop hl 
2ec3					NEXTW 
2ec3 c3 14 23			jp macro_next 
2ec6				endm 
# End of macro NEXTW
2ec6			.NOP: 
2ec6				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2ec6 61				db WORD_SYS_CORE+77             
2ec7 ed 2e			dw .COMO            
2ec9 04				db 3 + 1 
2eca .. 00			db "NOP",0              
2ece				endm 
# End of macro CWHEAD
2ece			; | NOP (  --  ) Do nothing | DONE 
2ece					if DEBUG_FORTH_WORDS_KEY 
2ece						DMARK "NOP" 
2ece f5				push af  
2ecf 3a e3 2e			ld a, (.dmark)  
2ed2 32 6e fe			ld (debug_mark),a  
2ed5 3a e4 2e			ld a, (.dmark+1)  
2ed8 32 6f fe			ld (debug_mark+1),a  
2edb 3a e5 2e			ld a, (.dmark+2)  
2ede 32 70 fe			ld (debug_mark+2),a  
2ee1 18 03			jr .pastdmark  
2ee3 ..			.dmark: db "NOP"  
2ee6 f1			.pastdmark: pop af  
2ee7			endm  
# End of macro DMARK
2ee7						CALLMONITOR 
2ee7 cd f3 18			call break_point_state  
2eea				endm  
# End of macro CALLMONITOR
2eea					endif 
2eea				       NEXTW 
2eea c3 14 23			jp macro_next 
2eed				endm 
# End of macro NEXTW
2eed			.COMO: 
2eed				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2eed 6e				db WORD_SYS_CORE+90             
2eee 3f 2f			dw .COMC            
2ef0 02				db 1 + 1 
2ef1 .. 00			db "(",0              
2ef3				endm 
# End of macro CWHEAD
2ef3			; | ( ( -- )  Start of comment | DONE 
2ef3			 
2ef3			 
2ef3 2a c9 f4				ld hl, ( os_tok_ptr) 
2ef6 11 3a 2f			ld de, .closepar 
2ef9					 
2ef9					if DEBUG_FORTH_WORDS 
2ef9						DMARK ").." 
2ef9 f5				push af  
2efa 3a 0e 2f			ld a, (.dmark)  
2efd 32 6e fe			ld (debug_mark),a  
2f00 3a 0f 2f			ld a, (.dmark+1)  
2f03 32 6f fe			ld (debug_mark+1),a  
2f06 3a 10 2f			ld a, (.dmark+2)  
2f09 32 70 fe			ld (debug_mark+2),a  
2f0c 18 03			jr .pastdmark  
2f0e ..			.dmark: db ").."  
2f11 f1			.pastdmark: pop af  
2f12			endm  
# End of macro DMARK
2f12						CALLMONITOR 
2f12 cd f3 18			call break_point_state  
2f15				endm  
# End of macro CALLMONITOR
2f15					endif 
2f15 cd 2f 24			call findnexttok  
2f18			 
2f18					if DEBUG_FORTH_WORDS 
2f18						DMARK "IF5" 
2f18 f5				push af  
2f19 3a 2d 2f			ld a, (.dmark)  
2f1c 32 6e fe			ld (debug_mark),a  
2f1f 3a 2e 2f			ld a, (.dmark+1)  
2f22 32 6f fe			ld (debug_mark+1),a  
2f25 3a 2f 2f			ld a, (.dmark+2)  
2f28 32 70 fe			ld (debug_mark+2),a  
2f2b 18 03			jr .pastdmark  
2f2d ..			.dmark: db "IF5"  
2f30 f1			.pastdmark: pop af  
2f31			endm  
# End of macro DMARK
2f31						CALLMONITOR 
2f31 cd f3 18			call break_point_state  
2f34				endm  
# End of macro CALLMONITOR
2f34					endif 
2f34				; replace below with ) exec using tok_ptr 
2f34 22 c9 f4			ld (os_tok_ptr), hl 
2f37 c3 a5 23			jp exec1 
2f3a			 
2f3a .. 00			.closepar:   db ")",0 
2f3c			 
2f3c				       NEXTW 
2f3c c3 14 23			jp macro_next 
2f3f				endm 
# End of macro NEXTW
2f3f			.COMC: 
2f3f				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2f3f 6f				db WORD_SYS_CORE+91             
2f40 48 2f			dw .SCRATCH            
2f42 02				db 1 + 1 
2f43 .. 00			db ")",0              
2f45				endm 
# End of macro CWHEAD
2f45			; | ) ( -- )  End of comment |  DONE  
2f45				       NEXTW 
2f45 c3 14 23			jp macro_next 
2f48				endm 
# End of macro NEXTW
2f48			 
2f48			.SCRATCH: 
2f48				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2f48 6f				db WORD_SYS_CORE+91             
2f49 83 2f			dw .INC            
2f4b 08				db 7 + 1 
2f4c .. 00			db "SCRATCH",0              
2f54				endm 
# End of macro CWHEAD
2f54			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2f54			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2f54			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2f54			; | |  
2f54			; | | e.g.    : score $00 scratch ; 
2f54			; | |  
2f54			; | | $00 score ! 
2f54			; | | $01 score +! 
2f54			; | |  
2f54			; | | e.g.   : varword $0a scratch ;  
2f54			; | | 
2f54			; | | $8000 varword ! 
2f54					if DEBUG_FORTH_WORDS_KEY 
2f54						DMARK "SCR" 
2f54 f5				push af  
2f55 3a 69 2f			ld a, (.dmark)  
2f58 32 6e fe			ld (debug_mark),a  
2f5b 3a 6a 2f			ld a, (.dmark+1)  
2f5e 32 6f fe			ld (debug_mark+1),a  
2f61 3a 6b 2f			ld a, (.dmark+2)  
2f64 32 70 fe			ld (debug_mark+2),a  
2f67 18 03			jr .pastdmark  
2f69 ..			.dmark: db "SCR"  
2f6c f1			.pastdmark: pop af  
2f6d			endm  
# End of macro DMARK
2f6d						CALLMONITOR 
2f6d cd f3 18			call break_point_state  
2f70				endm  
# End of macro CALLMONITOR
2f70					endif 
2f70			 
2f70					FORTH_DSP_VALUEHL 
2f70 cd 5e 21			call macro_dsp_valuehl 
2f73				endm 
# End of macro FORTH_DSP_VALUEHL
2f73				 
2f73					FORTH_DSP_POP 
2f73 cd 16 22			call macro_forth_dsp_pop 
2f76				endm 
# End of macro FORTH_DSP_POP
2f76			 
2f76 7d					ld a, l 
2f77 21 ed f6				ld hl, os_var_array 
2f7a cd 4c 0f				call addatohl 
2f7d			 
2f7d cd 67 1f				call forth_push_numhl 
2f80			 
2f80				       NEXTW 
2f80 c3 14 23			jp macro_next 
2f83				endm 
# End of macro NEXTW
2f83			 
2f83			.INC: 
2f83				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2f83 6f				db WORD_SYS_CORE+91             
2f84 d7 2f			dw .DEC            
2f86 03				db 2 + 1 
2f87 .. 00			db "+!",0              
2f8a				endm 
# End of macro CWHEAD
2f8a			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2f8a					if DEBUG_FORTH_WORDS_KEY 
2f8a						DMARK "+s_" 
2f8a f5				push af  
2f8b 3a 9f 2f			ld a, (.dmark)  
2f8e 32 6e fe			ld (debug_mark),a  
2f91 3a a0 2f			ld a, (.dmark+1)  
2f94 32 6f fe			ld (debug_mark+1),a  
2f97 3a a1 2f			ld a, (.dmark+2)  
2f9a 32 70 fe			ld (debug_mark+2),a  
2f9d 18 03			jr .pastdmark  
2f9f ..			.dmark: db "+s_"  
2fa2 f1			.pastdmark: pop af  
2fa3			endm  
# End of macro DMARK
2fa3						CALLMONITOR 
2fa3 cd f3 18			call break_point_state  
2fa6				endm  
# End of macro CALLMONITOR
2fa6					endif 
2fa6			 
2fa6					FORTH_DSP_VALUEHL 
2fa6 cd 5e 21			call macro_dsp_valuehl 
2fa9				endm 
# End of macro FORTH_DSP_VALUEHL
2fa9			 
2fa9 e5					push hl   ; save address 
2faa			 
2faa					FORTH_DSP_POP 
2faa cd 16 22			call macro_forth_dsp_pop 
2fad				endm 
# End of macro FORTH_DSP_POP
2fad			 
2fad					FORTH_DSP_VALUEHL 
2fad cd 5e 21			call macro_dsp_valuehl 
2fb0				endm 
# End of macro FORTH_DSP_VALUEHL
2fb0			 
2fb0					FORTH_DSP_POP 
2fb0 cd 16 22			call macro_forth_dsp_pop 
2fb3				endm 
# End of macro FORTH_DSP_POP
2fb3			 
2fb3					; hl contains value to add to byte at a 
2fb3				 
2fb3 eb					ex de, hl 
2fb4			 
2fb4 e1					pop hl 
2fb5			 
2fb5					if DEBUG_FORTH_WORDS 
2fb5						DMARK "INC" 
2fb5 f5				push af  
2fb6 3a ca 2f			ld a, (.dmark)  
2fb9 32 6e fe			ld (debug_mark),a  
2fbc 3a cb 2f			ld a, (.dmark+1)  
2fbf 32 6f fe			ld (debug_mark+1),a  
2fc2 3a cc 2f			ld a, (.dmark+2)  
2fc5 32 70 fe			ld (debug_mark+2),a  
2fc8 18 03			jr .pastdmark  
2fca ..			.dmark: db "INC"  
2fcd f1			.pastdmark: pop af  
2fce			endm  
# End of macro DMARK
2fce						CALLMONITOR 
2fce cd f3 18			call break_point_state  
2fd1				endm  
# End of macro CALLMONITOR
2fd1					endif 
2fd1			 
2fd1 7e					ld a,(hl) 
2fd2 83					add e 
2fd3 77					ld (hl),a 
2fd4			 
2fd4			 
2fd4			 
2fd4				       NEXTW 
2fd4 c3 14 23			jp macro_next 
2fd7				endm 
# End of macro NEXTW
2fd7			 
2fd7			.DEC: 
2fd7				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2fd7 6f				db WORD_SYS_CORE+91             
2fd8 28 30			dw .INC2            
2fda 03				db 2 + 1 
2fdb .. 00			db "-!",0              
2fde				endm 
# End of macro CWHEAD
2fde			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2fde					if DEBUG_FORTH_WORDS_KEY 
2fde						DMARK "-s_" 
2fde f5				push af  
2fdf 3a f3 2f			ld a, (.dmark)  
2fe2 32 6e fe			ld (debug_mark),a  
2fe5 3a f4 2f			ld a, (.dmark+1)  
2fe8 32 6f fe			ld (debug_mark+1),a  
2feb 3a f5 2f			ld a, (.dmark+2)  
2fee 32 70 fe			ld (debug_mark+2),a  
2ff1 18 03			jr .pastdmark  
2ff3 ..			.dmark: db "-s_"  
2ff6 f1			.pastdmark: pop af  
2ff7			endm  
# End of macro DMARK
2ff7						CALLMONITOR 
2ff7 cd f3 18			call break_point_state  
2ffa				endm  
# End of macro CALLMONITOR
2ffa					endif 
2ffa			 
2ffa					FORTH_DSP_VALUEHL 
2ffa cd 5e 21			call macro_dsp_valuehl 
2ffd				endm 
# End of macro FORTH_DSP_VALUEHL
2ffd			 
2ffd e5					push hl   ; save address 
2ffe			 
2ffe					FORTH_DSP_POP 
2ffe cd 16 22			call macro_forth_dsp_pop 
3001				endm 
# End of macro FORTH_DSP_POP
3001			 
3001					FORTH_DSP_VALUEHL 
3001 cd 5e 21			call macro_dsp_valuehl 
3004				endm 
# End of macro FORTH_DSP_VALUEHL
3004			 
3004					; hl contains value to add to byte at a 
3004				 
3004 eb					ex de, hl 
3005			 
3005 e1					pop hl 
3006			 
3006					if DEBUG_FORTH_WORDS 
3006						DMARK "DEC" 
3006 f5				push af  
3007 3a 1b 30			ld a, (.dmark)  
300a 32 6e fe			ld (debug_mark),a  
300d 3a 1c 30			ld a, (.dmark+1)  
3010 32 6f fe			ld (debug_mark+1),a  
3013 3a 1d 30			ld a, (.dmark+2)  
3016 32 70 fe			ld (debug_mark+2),a  
3019 18 03			jr .pastdmark  
301b ..			.dmark: db "DEC"  
301e f1			.pastdmark: pop af  
301f			endm  
# End of macro DMARK
301f						CALLMONITOR 
301f cd f3 18			call break_point_state  
3022				endm  
# End of macro CALLMONITOR
3022					endif 
3022			 
3022 7e					ld a,(hl) 
3023 93					sub e 
3024 77					ld (hl),a 
3025			 
3025			 
3025			 
3025				       NEXTW 
3025 c3 14 23			jp macro_next 
3028				endm 
# End of macro NEXTW
3028			 
3028			.INC2: 
3028				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
3028 6f				db WORD_SYS_CORE+91             
3029 d2 30			dw .DEC2            
302b 04				db 3 + 1 
302c .. 00			db "+2!",0              
3030				endm 
# End of macro CWHEAD
3030			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
3030			 
3030					if DEBUG_FORTH_WORDS_KEY 
3030						DMARK "+2s" 
3030 f5				push af  
3031 3a 45 30			ld a, (.dmark)  
3034 32 6e fe			ld (debug_mark),a  
3037 3a 46 30			ld a, (.dmark+1)  
303a 32 6f fe			ld (debug_mark+1),a  
303d 3a 47 30			ld a, (.dmark+2)  
3040 32 70 fe			ld (debug_mark+2),a  
3043 18 03			jr .pastdmark  
3045 ..			.dmark: db "+2s"  
3048 f1			.pastdmark: pop af  
3049			endm  
# End of macro DMARK
3049						CALLMONITOR 
3049 cd f3 18			call break_point_state  
304c				endm  
# End of macro CALLMONITOR
304c					endif 
304c			 
304c					; Address 
304c			 
304c					FORTH_DSP_VALUEHL 
304c cd 5e 21			call macro_dsp_valuehl 
304f				endm 
# End of macro FORTH_DSP_VALUEHL
304f			 
304f e5					push hl    ; save address 
3050			 
3050					; load content into de 
3050			 
3050 5e					ld e,(hl) 
3051 23					inc hl 
3052 56					ld d, (hl) 
3053			 
3053					if DEBUG_FORTH_WORDS 
3053						DMARK "+2a" 
3053 f5				push af  
3054 3a 68 30			ld a, (.dmark)  
3057 32 6e fe			ld (debug_mark),a  
305a 3a 69 30			ld a, (.dmark+1)  
305d 32 6f fe			ld (debug_mark+1),a  
3060 3a 6a 30			ld a, (.dmark+2)  
3063 32 70 fe			ld (debug_mark+2),a  
3066 18 03			jr .pastdmark  
3068 ..			.dmark: db "+2a"  
306b f1			.pastdmark: pop af  
306c			endm  
# End of macro DMARK
306c						CALLMONITOR 
306c cd f3 18			call break_point_state  
306f				endm  
# End of macro CALLMONITOR
306f					endif 
306f			 
306f					FORTH_DSP_POP 
306f cd 16 22			call macro_forth_dsp_pop 
3072				endm 
# End of macro FORTH_DSP_POP
3072			 
3072					; Get value to add 
3072			 
3072					FORTH_DSP_VALUE 
3072 cd 47 21			call macro_forth_dsp_value 
3075				endm 
# End of macro FORTH_DSP_VALUE
3075			 
3075					if DEBUG_FORTH_WORDS 
3075						DMARK "+2v" 
3075 f5				push af  
3076 3a 8a 30			ld a, (.dmark)  
3079 32 6e fe			ld (debug_mark),a  
307c 3a 8b 30			ld a, (.dmark+1)  
307f 32 6f fe			ld (debug_mark+1),a  
3082 3a 8c 30			ld a, (.dmark+2)  
3085 32 70 fe			ld (debug_mark+2),a  
3088 18 03			jr .pastdmark  
308a ..			.dmark: db "+2v"  
308d f1			.pastdmark: pop af  
308e			endm  
# End of macro DMARK
308e						CALLMONITOR 
308e cd f3 18			call break_point_state  
3091				endm  
# End of macro CALLMONITOR
3091					endif 
3091			 
3091 19					add hl, de 
3092			 
3092					if DEBUG_FORTH_WORDS 
3092						DMARK "+2+" 
3092 f5				push af  
3093 3a a7 30			ld a, (.dmark)  
3096 32 6e fe			ld (debug_mark),a  
3099 3a a8 30			ld a, (.dmark+1)  
309c 32 6f fe			ld (debug_mark+1),a  
309f 3a a9 30			ld a, (.dmark+2)  
30a2 32 70 fe			ld (debug_mark+2),a  
30a5 18 03			jr .pastdmark  
30a7 ..			.dmark: db "+2+"  
30aa f1			.pastdmark: pop af  
30ab			endm  
# End of macro DMARK
30ab						CALLMONITOR 
30ab cd f3 18			call break_point_state  
30ae				endm  
# End of macro CALLMONITOR
30ae					endif 
30ae			 
30ae					; move result to de 
30ae			 
30ae eb					ex de, hl 
30af			 
30af					; Address 
30af			 
30af e1					pop hl 
30b0			 
30b0					; save it back 
30b0			 
30b0 73					ld (hl), e 
30b1 23					inc hl 
30b2 72					ld (hl), d 
30b3			 
30b3					if DEBUG_FORTH_WORDS 
30b3						DMARK "+2e" 
30b3 f5				push af  
30b4 3a c8 30			ld a, (.dmark)  
30b7 32 6e fe			ld (debug_mark),a  
30ba 3a c9 30			ld a, (.dmark+1)  
30bd 32 6f fe			ld (debug_mark+1),a  
30c0 3a ca 30			ld a, (.dmark+2)  
30c3 32 70 fe			ld (debug_mark+2),a  
30c6 18 03			jr .pastdmark  
30c8 ..			.dmark: db "+2e"  
30cb f1			.pastdmark: pop af  
30cc			endm  
# End of macro DMARK
30cc						CALLMONITOR 
30cc cd f3 18			call break_point_state  
30cf				endm  
# End of macro CALLMONITOR
30cf					endif 
30cf			 
30cf			 
30cf			 
30cf			 
30cf			 
30cf				       NEXTW 
30cf c3 14 23			jp macro_next 
30d2				endm 
# End of macro NEXTW
30d2			 
30d2			.DEC2: 
30d2				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
30d2 6f				db WORD_SYS_CORE+91             
30d3 7e 31			dw .GET2            
30d5 04				db 3 + 1 
30d6 .. 00			db "-2!",0              
30da				endm 
# End of macro CWHEAD
30da			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
30da			 
30da			 
30da					if DEBUG_FORTH_WORDS_KEY 
30da						DMARK "-2s" 
30da f5				push af  
30db 3a ef 30			ld a, (.dmark)  
30de 32 6e fe			ld (debug_mark),a  
30e1 3a f0 30			ld a, (.dmark+1)  
30e4 32 6f fe			ld (debug_mark+1),a  
30e7 3a f1 30			ld a, (.dmark+2)  
30ea 32 70 fe			ld (debug_mark+2),a  
30ed 18 03			jr .pastdmark  
30ef ..			.dmark: db "-2s"  
30f2 f1			.pastdmark: pop af  
30f3			endm  
# End of macro DMARK
30f3						CALLMONITOR 
30f3 cd f3 18			call break_point_state  
30f6				endm  
# End of macro CALLMONITOR
30f6					endif 
30f6			 
30f6					; Address 
30f6			 
30f6					FORTH_DSP_VALUEHL 
30f6 cd 5e 21			call macro_dsp_valuehl 
30f9				endm 
# End of macro FORTH_DSP_VALUEHL
30f9			 
30f9 e5					push hl    ; save address 
30fa			 
30fa					; load content into de 
30fa			 
30fa 5e					ld e,(hl) 
30fb 23					inc hl 
30fc 56					ld d, (hl) 
30fd			 
30fd					if DEBUG_FORTH_WORDS 
30fd						DMARK "-2a" 
30fd f5				push af  
30fe 3a 12 31			ld a, (.dmark)  
3101 32 6e fe			ld (debug_mark),a  
3104 3a 13 31			ld a, (.dmark+1)  
3107 32 6f fe			ld (debug_mark+1),a  
310a 3a 14 31			ld a, (.dmark+2)  
310d 32 70 fe			ld (debug_mark+2),a  
3110 18 03			jr .pastdmark  
3112 ..			.dmark: db "-2a"  
3115 f1			.pastdmark: pop af  
3116			endm  
# End of macro DMARK
3116						CALLMONITOR 
3116 cd f3 18			call break_point_state  
3119				endm  
# End of macro CALLMONITOR
3119					endif 
3119			 
3119					FORTH_DSP_POP 
3119 cd 16 22			call macro_forth_dsp_pop 
311c				endm 
# End of macro FORTH_DSP_POP
311c			 
311c					; Get value to remove 
311c			 
311c					FORTH_DSP_VALUE 
311c cd 47 21			call macro_forth_dsp_value 
311f				endm 
# End of macro FORTH_DSP_VALUE
311f			 
311f					if DEBUG_FORTH_WORDS 
311f						DMARK "-2v" 
311f f5				push af  
3120 3a 34 31			ld a, (.dmark)  
3123 32 6e fe			ld (debug_mark),a  
3126 3a 35 31			ld a, (.dmark+1)  
3129 32 6f fe			ld (debug_mark+1),a  
312c 3a 36 31			ld a, (.dmark+2)  
312f 32 70 fe			ld (debug_mark+2),a  
3132 18 03			jr .pastdmark  
3134 ..			.dmark: db "-2v"  
3137 f1			.pastdmark: pop af  
3138			endm  
# End of macro DMARK
3138						CALLMONITOR 
3138 cd f3 18			call break_point_state  
313b				endm  
# End of macro CALLMONITOR
313b					endif 
313b			 
313b eb					ex de, hl 
313c ed 52				sbc hl, de 
313e			 
313e					if DEBUG_FORTH_WORDS 
313e						DMARK "-2d" 
313e f5				push af  
313f 3a 53 31			ld a, (.dmark)  
3142 32 6e fe			ld (debug_mark),a  
3145 3a 54 31			ld a, (.dmark+1)  
3148 32 6f fe			ld (debug_mark+1),a  
314b 3a 55 31			ld a, (.dmark+2)  
314e 32 70 fe			ld (debug_mark+2),a  
3151 18 03			jr .pastdmark  
3153 ..			.dmark: db "-2d"  
3156 f1			.pastdmark: pop af  
3157			endm  
# End of macro DMARK
3157						CALLMONITOR 
3157 cd f3 18			call break_point_state  
315a				endm  
# End of macro CALLMONITOR
315a					endif 
315a			 
315a					; move result to de 
315a			 
315a eb					ex de, hl 
315b			 
315b					; Address 
315b			 
315b e1					pop hl 
315c			 
315c					; save it back 
315c			 
315c 73					ld (hl), e 
315d 23					inc hl 
315e 72					ld (hl), d 
315f			 
315f					if DEBUG_FORTH_WORDS 
315f						DMARK "-2e" 
315f f5				push af  
3160 3a 74 31			ld a, (.dmark)  
3163 32 6e fe			ld (debug_mark),a  
3166 3a 75 31			ld a, (.dmark+1)  
3169 32 6f fe			ld (debug_mark+1),a  
316c 3a 76 31			ld a, (.dmark+2)  
316f 32 70 fe			ld (debug_mark+2),a  
3172 18 03			jr .pastdmark  
3174 ..			.dmark: db "-2e"  
3177 f1			.pastdmark: pop af  
3178			endm  
# End of macro DMARK
3178						CALLMONITOR 
3178 cd f3 18			call break_point_state  
317b				endm  
# End of macro CALLMONITOR
317b					endif 
317b			 
317b			 
317b			 
317b			 
317b			 
317b				       NEXTW 
317b c3 14 23			jp macro_next 
317e				endm 
# End of macro NEXTW
317e			.GET2: 
317e				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
317e 6f				db WORD_SYS_CORE+91             
317f ae 31			dw .BANG2            
3181 03				db 2 + 1 
3182 .. 00			db "2@",0              
3185				endm 
# End of macro CWHEAD
3185			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3185					if DEBUG_FORTH_WORDS_KEY 
3185						DMARK "2A_" 
3185 f5				push af  
3186 3a 9a 31			ld a, (.dmark)  
3189 32 6e fe			ld (debug_mark),a  
318c 3a 9b 31			ld a, (.dmark+1)  
318f 32 6f fe			ld (debug_mark+1),a  
3192 3a 9c 31			ld a, (.dmark+2)  
3195 32 70 fe			ld (debug_mark+2),a  
3198 18 03			jr .pastdmark  
319a ..			.dmark: db "2A_"  
319d f1			.pastdmark: pop af  
319e			endm  
# End of macro DMARK
319e						CALLMONITOR 
319e cd f3 18			call break_point_state  
31a1				endm  
# End of macro CALLMONITOR
31a1					endif 
31a1			 
31a1					FORTH_DSP_VALUEHL 
31a1 cd 5e 21			call macro_dsp_valuehl 
31a4				endm 
# End of macro FORTH_DSP_VALUEHL
31a4			 
31a4 5e					ld e, (hl) 
31a5 23					inc hl 
31a6 56					ld d, (hl) 
31a7			 
31a7 eb					ex de, hl 
31a8			 
31a8 cd 67 1f				call forth_push_numhl 
31ab			 
31ab				       NEXTW 
31ab c3 14 23			jp macro_next 
31ae				endm 
# End of macro NEXTW
31ae			.BANG2: 
31ae				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
31ae 6f				db WORD_SYS_CORE+91             
31af e6 31			dw .CONFIG            
31b1 03				db 2 + 1 
31b2 .. 00			db "2!",0              
31b5				endm 
# End of macro CWHEAD
31b5			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
31b5					if DEBUG_FORTH_WORDS_KEY 
31b5						DMARK "2S_" 
31b5 f5				push af  
31b6 3a ca 31			ld a, (.dmark)  
31b9 32 6e fe			ld (debug_mark),a  
31bc 3a cb 31			ld a, (.dmark+1)  
31bf 32 6f fe			ld (debug_mark+1),a  
31c2 3a cc 31			ld a, (.dmark+2)  
31c5 32 70 fe			ld (debug_mark+2),a  
31c8 18 03			jr .pastdmark  
31ca ..			.dmark: db "2S_"  
31cd f1			.pastdmark: pop af  
31ce			endm  
# End of macro DMARK
31ce						CALLMONITOR 
31ce cd f3 18			call break_point_state  
31d1				endm  
# End of macro CALLMONITOR
31d1					endif 
31d1			 
31d1					FORTH_DSP_VALUEHL 
31d1 cd 5e 21			call macro_dsp_valuehl 
31d4				endm 
# End of macro FORTH_DSP_VALUEHL
31d4			 
31d4 e5					push hl   ; save address 
31d5			 
31d5			 
31d5					FORTH_DSP_POP 
31d5 cd 16 22			call macro_forth_dsp_pop 
31d8				endm 
# End of macro FORTH_DSP_POP
31d8			 
31d8					 
31d8					FORTH_DSP_VALUEHL 
31d8 cd 5e 21			call macro_dsp_valuehl 
31db				endm 
# End of macro FORTH_DSP_VALUEHL
31db			 
31db					FORTH_DSP_POP 
31db cd 16 22			call macro_forth_dsp_pop 
31de				endm 
# End of macro FORTH_DSP_POP
31de			 
31de eb					ex de, hl    ; value now in de 
31df			 
31df e1					pop hl 
31e0			 
31e0 73					ld (hl), e 
31e1			 
31e1 23					inc hl 
31e2			 
31e2 72					ld (hl), d 
31e3			 
31e3			 
31e3				       NEXTW 
31e3 c3 14 23			jp macro_next 
31e6				endm 
# End of macro NEXTW
31e6			.CONFIG: 
31e6				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
31e6 6f				db WORD_SYS_CORE+91             
31e7 f7 31			dw .ENDCORE            
31e9 07				db 6 + 1 
31ea .. 00			db "CONFIG",0              
31f1				endm 
# End of macro CWHEAD
31f1			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
31f1			 
31f1 cd d6 15				call config 
31f4					NEXTW 
31f4 c3 14 23			jp macro_next 
31f7				endm 
# End of macro NEXTW
31f7			.ENDCORE: 
31f7			 
31f7			; eof 
31f7			 
31f7			 
# End of file forth_words_core.asm
31f7			include "forth_words_flow.asm" 
31f7			 
31f7			; | ## Program Flow Words 
31f7			 
31f7			.IF: 
31f7				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
31f7 1e				db WORD_SYS_CORE+10             
31f8 ec 32			dw .THEN            
31fa 03				db 2 + 1 
31fb .. 00			db "IF",0              
31fe				endm 
# End of macro CWHEAD
31fe			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
31fe			; 
31fe					if DEBUG_FORTH_WORDS_KEY 
31fe						DMARK "IF." 
31fe f5				push af  
31ff 3a 13 32			ld a, (.dmark)  
3202 32 6e fe			ld (debug_mark),a  
3205 3a 14 32			ld a, (.dmark+1)  
3208 32 6f fe			ld (debug_mark+1),a  
320b 3a 15 32			ld a, (.dmark+2)  
320e 32 70 fe			ld (debug_mark+2),a  
3211 18 03			jr .pastdmark  
3213 ..			.dmark: db "IF."  
3216 f1			.pastdmark: pop af  
3217			endm  
# End of macro DMARK
3217						CALLMONITOR 
3217 cd f3 18			call break_point_state  
321a				endm  
# End of macro CALLMONITOR
321a					endif 
321a			; eval TOS 
321a			 
321a				FORTH_DSP_VALUEHL 
321a cd 5e 21			call macro_dsp_valuehl 
321d				endm 
# End of macro FORTH_DSP_VALUEHL
321d			 
321d			;	push hl 
321d				FORTH_DSP_POP 
321d cd 16 22			call macro_forth_dsp_pop 
3220				endm 
# End of macro FORTH_DSP_POP
3220			;	pop hl 
3220			 
3220					if DEBUG_FORTH_WORDS 
3220						DMARK "IF1" 
3220 f5				push af  
3221 3a 35 32			ld a, (.dmark)  
3224 32 6e fe			ld (debug_mark),a  
3227 3a 36 32			ld a, (.dmark+1)  
322a 32 6f fe			ld (debug_mark+1),a  
322d 3a 37 32			ld a, (.dmark+2)  
3230 32 70 fe			ld (debug_mark+2),a  
3233 18 03			jr .pastdmark  
3235 ..			.dmark: db "IF1"  
3238 f1			.pastdmark: pop af  
3239			endm  
# End of macro DMARK
3239						CALLMONITOR 
3239 cd f3 18			call break_point_state  
323c				endm  
# End of macro CALLMONITOR
323c					endif 
323c b7				or a        ; clear carry flag 
323d 11 00 00			ld de, 0 
3240 eb				ex de,hl 
3241 ed 52			sbc hl, de 
3243 c2 cd 32			jp nz, .iftrue 
3246			 
3246					if DEBUG_FORTH_WORDS 
3246						DMARK "IF2" 
3246 f5				push af  
3247 3a 5b 32			ld a, (.dmark)  
324a 32 6e fe			ld (debug_mark),a  
324d 3a 5c 32			ld a, (.dmark+1)  
3250 32 6f fe			ld (debug_mark+1),a  
3253 3a 5d 32			ld a, (.dmark+2)  
3256 32 70 fe			ld (debug_mark+2),a  
3259 18 03			jr .pastdmark  
325b ..			.dmark: db "IF2"  
325e f1			.pastdmark: pop af  
325f			endm  
# End of macro DMARK
325f						CALLMONITOR 
325f cd f3 18			call break_point_state  
3262				endm  
# End of macro CALLMONITOR
3262					endif 
3262			 
3262			; if not true then skip to THEN 
3262			 
3262				; TODO get tok_ptr 
3262				; TODO consume toks until we get to THEN 
3262			 
3262 2a c9 f4			ld hl, (os_tok_ptr) 
3265					if DEBUG_FORTH_WORDS 
3265						DMARK "IF3" 
3265 f5				push af  
3266 3a 7a 32			ld a, (.dmark)  
3269 32 6e fe			ld (debug_mark),a  
326c 3a 7b 32			ld a, (.dmark+1)  
326f 32 6f fe			ld (debug_mark+1),a  
3272 3a 7c 32			ld a, (.dmark+2)  
3275 32 70 fe			ld (debug_mark+2),a  
3278 18 03			jr .pastdmark  
327a ..			.dmark: db "IF3"  
327d f1			.pastdmark: pop af  
327e			endm  
# End of macro DMARK
327e						CALLMONITOR 
327e cd f3 18			call break_point_state  
3281				endm  
# End of macro CALLMONITOR
3281						 
3281					endif 
3281 11 c8 32			ld de, .ifthen 
3284					if DEBUG_FORTH_WORDS 
3284						DMARK "IF4" 
3284 f5				push af  
3285 3a 99 32			ld a, (.dmark)  
3288 32 6e fe			ld (debug_mark),a  
328b 3a 9a 32			ld a, (.dmark+1)  
328e 32 6f fe			ld (debug_mark+1),a  
3291 3a 9b 32			ld a, (.dmark+2)  
3294 32 70 fe			ld (debug_mark+2),a  
3297 18 03			jr .pastdmark  
3299 ..			.dmark: db "IF4"  
329c f1			.pastdmark: pop af  
329d			endm  
# End of macro DMARK
329d						CALLMONITOR 
329d cd f3 18			call break_point_state  
32a0				endm  
# End of macro CALLMONITOR
32a0					endif 
32a0 cd 2f 24			call findnexttok  
32a3			 
32a3					if DEBUG_FORTH_WORDS 
32a3						DMARK "IF5" 
32a3 f5				push af  
32a4 3a b8 32			ld a, (.dmark)  
32a7 32 6e fe			ld (debug_mark),a  
32aa 3a b9 32			ld a, (.dmark+1)  
32ad 32 6f fe			ld (debug_mark+1),a  
32b0 3a ba 32			ld a, (.dmark+2)  
32b3 32 70 fe			ld (debug_mark+2),a  
32b6 18 03			jr .pastdmark  
32b8 ..			.dmark: db "IF5"  
32bb f1			.pastdmark: pop af  
32bc			endm  
# End of macro DMARK
32bc						CALLMONITOR 
32bc cd f3 18			call break_point_state  
32bf				endm  
# End of macro CALLMONITOR
32bf					endif 
32bf				; TODO replace below with ; exec using tok_ptr 
32bf 22 c9 f4			ld (os_tok_ptr), hl 
32c2 c3 a5 23			jp exec1 
32c5				NEXTW 
32c5 c3 14 23			jp macro_next 
32c8				endm 
# End of macro NEXTW
32c8			 
32c8 .. 00		.ifthen:  db "THEN",0 
32cd			 
32cd			.iftrue:		 
32cd				; Exec next words normally 
32cd			 
32cd				; if true then exec following IF as normal 
32cd					if DEBUG_FORTH_WORDS 
32cd						DMARK "IFT" 
32cd f5				push af  
32ce 3a e2 32			ld a, (.dmark)  
32d1 32 6e fe			ld (debug_mark),a  
32d4 3a e3 32			ld a, (.dmark+1)  
32d7 32 6f fe			ld (debug_mark+1),a  
32da 3a e4 32			ld a, (.dmark+2)  
32dd 32 70 fe			ld (debug_mark+2),a  
32e0 18 03			jr .pastdmark  
32e2 ..			.dmark: db "IFT"  
32e5 f1			.pastdmark: pop af  
32e6			endm  
# End of macro DMARK
32e6						CALLMONITOR 
32e6 cd f3 18			call break_point_state  
32e9				endm  
# End of macro CALLMONITOR
32e9					endif 
32e9			 
32e9					NEXTW 
32e9 c3 14 23			jp macro_next 
32ec				endm 
# End of macro NEXTW
32ec			.THEN: 
32ec				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
32ec 1f				db WORD_SYS_CORE+11             
32ed 14 33			dw .ELSE            
32ef 05				db 4 + 1 
32f0 .. 00			db "THEN",0              
32f5				endm 
# End of macro CWHEAD
32f5			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
32f5					if DEBUG_FORTH_WORDS_KEY 
32f5						DMARK "THN" 
32f5 f5				push af  
32f6 3a 0a 33			ld a, (.dmark)  
32f9 32 6e fe			ld (debug_mark),a  
32fc 3a 0b 33			ld a, (.dmark+1)  
32ff 32 6f fe			ld (debug_mark+1),a  
3302 3a 0c 33			ld a, (.dmark+2)  
3305 32 70 fe			ld (debug_mark+2),a  
3308 18 03			jr .pastdmark  
330a ..			.dmark: db "THN"  
330d f1			.pastdmark: pop af  
330e			endm  
# End of macro DMARK
330e						CALLMONITOR 
330e cd f3 18			call break_point_state  
3311				endm  
# End of macro CALLMONITOR
3311					endif 
3311					NEXTW 
3311 c3 14 23			jp macro_next 
3314				endm 
# End of macro NEXTW
3314			.ELSE: 
3314				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3314 20				db WORD_SYS_CORE+12             
3315 3c 33			dw .DO            
3317 03				db 2 + 1 
3318 .. 00			db "ELSE",0              
331d				endm 
# End of macro CWHEAD
331d			; | ELSE ( -- ) Not supported - does nothing | TODO 
331d			 
331d					if DEBUG_FORTH_WORDS_KEY 
331d						DMARK "ELS" 
331d f5				push af  
331e 3a 32 33			ld a, (.dmark)  
3321 32 6e fe			ld (debug_mark),a  
3324 3a 33 33			ld a, (.dmark+1)  
3327 32 6f fe			ld (debug_mark+1),a  
332a 3a 34 33			ld a, (.dmark+2)  
332d 32 70 fe			ld (debug_mark+2),a  
3330 18 03			jr .pastdmark  
3332 ..			.dmark: db "ELS"  
3335 f1			.pastdmark: pop af  
3336			endm  
# End of macro DMARK
3336						CALLMONITOR 
3336 cd f3 18			call break_point_state  
3339				endm  
# End of macro CALLMONITOR
3339					endif 
3339			 
3339			 
3339					NEXTW 
3339 c3 14 23			jp macro_next 
333c				endm 
# End of macro NEXTW
333c			.DO: 
333c				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
333c 21				db WORD_SYS_CORE+13             
333d 63 34			dw .LOOP            
333f 03				db 2 + 1 
3340 .. 00			db "DO",0              
3343				endm 
# End of macro CWHEAD
3343			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3343			 
3343					if DEBUG_FORTH_WORDS_KEY 
3343						DMARK "DO." 
3343 f5				push af  
3344 3a 58 33			ld a, (.dmark)  
3347 32 6e fe			ld (debug_mark),a  
334a 3a 59 33			ld a, (.dmark+1)  
334d 32 6f fe			ld (debug_mark+1),a  
3350 3a 5a 33			ld a, (.dmark+2)  
3353 32 70 fe			ld (debug_mark+2),a  
3356 18 03			jr .pastdmark  
3358 ..			.dmark: db "DO."  
335b f1			.pastdmark: pop af  
335c			endm  
# End of macro DMARK
335c						CALLMONITOR 
335c cd f3 18			call break_point_state  
335f				endm  
# End of macro CALLMONITOR
335f					endif 
335f			;  push pc to rsp stack past the DO 
335f			 
335f 2a c9 f4				ld hl, (os_tok_ptr) 
3362 23					inc hl   ; D 
3363 23					inc hl  ; O 
3364 23					inc hl   ; null 
3365					if DEBUG_FORTH_WORDS 
3365						DMARK "DO2" 
3365 f5				push af  
3366 3a 7a 33			ld a, (.dmark)  
3369 32 6e fe			ld (debug_mark),a  
336c 3a 7b 33			ld a, (.dmark+1)  
336f 32 6f fe			ld (debug_mark+1),a  
3372 3a 7c 33			ld a, (.dmark+2)  
3375 32 70 fe			ld (debug_mark+2),a  
3378 18 03			jr .pastdmark  
337a ..			.dmark: db "DO2"  
337d f1			.pastdmark: pop af  
337e			endm  
# End of macro DMARK
337e						CALLMONITOR 
337e cd f3 18			call break_point_state  
3381				endm  
# End of macro CALLMONITOR
3381					endif 
3381					FORTH_RSP_NEXT 
3381 cd 0e 1f			call macro_forth_rsp_next 
3384				endm 
# End of macro FORTH_RSP_NEXT
3384					if DEBUG_FORTH_WORDS 
3384						DMARK "DO3" 
3384 f5				push af  
3385 3a 99 33			ld a, (.dmark)  
3388 32 6e fe			ld (debug_mark),a  
338b 3a 9a 33			ld a, (.dmark+1)  
338e 32 6f fe			ld (debug_mark+1),a  
3391 3a 9b 33			ld a, (.dmark+2)  
3394 32 70 fe			ld (debug_mark+2),a  
3397 18 03			jr .pastdmark  
3399 ..			.dmark: db "DO3"  
339c f1			.pastdmark: pop af  
339d			endm  
# End of macro DMARK
339d						CALLMONITOR 
339d cd f3 18			call break_point_state  
33a0				endm  
# End of macro CALLMONITOR
33a0					endif 
33a0			 
33a0					;if DEBUG_FORTH_WORDS 
33a0				;		push hl 
33a0			;		endif  
33a0			 
33a0			; get counters from data stack 
33a0			 
33a0			 
33a0					FORTH_DSP_VALUEHL 
33a0 cd 5e 21			call macro_dsp_valuehl 
33a3				endm 
# End of macro FORTH_DSP_VALUEHL
33a3 e5					push hl		 ; hl now has starting counter which needs to be tos 
33a4			 
33a4					if DEBUG_FORTH_WORDS 
33a4						DMARK "DO4" 
33a4 f5				push af  
33a5 3a b9 33			ld a, (.dmark)  
33a8 32 6e fe			ld (debug_mark),a  
33ab 3a ba 33			ld a, (.dmark+1)  
33ae 32 6f fe			ld (debug_mark+1),a  
33b1 3a bb 33			ld a, (.dmark+2)  
33b4 32 70 fe			ld (debug_mark+2),a  
33b7 18 03			jr .pastdmark  
33b9 ..			.dmark: db "DO4"  
33bc f1			.pastdmark: pop af  
33bd			endm  
# End of macro DMARK
33bd						CALLMONITOR 
33bd cd f3 18			call break_point_state  
33c0				endm  
# End of macro CALLMONITOR
33c0					endif 
33c0					FORTH_DSP_POP 
33c0 cd 16 22			call macro_forth_dsp_pop 
33c3				endm 
# End of macro FORTH_DSP_POP
33c3			 
33c3					if DEBUG_FORTH_WORDS 
33c3						DMARK "DO5" 
33c3 f5				push af  
33c4 3a d8 33			ld a, (.dmark)  
33c7 32 6e fe			ld (debug_mark),a  
33ca 3a d9 33			ld a, (.dmark+1)  
33cd 32 6f fe			ld (debug_mark+1),a  
33d0 3a da 33			ld a, (.dmark+2)  
33d3 32 70 fe			ld (debug_mark+2),a  
33d6 18 03			jr .pastdmark  
33d8 ..			.dmark: db "DO5"  
33db f1			.pastdmark: pop af  
33dc			endm  
# End of macro DMARK
33dc						CALLMONITOR 
33dc cd f3 18			call break_point_state  
33df				endm  
# End of macro CALLMONITOR
33df					endif 
33df			 
33df					FORTH_DSP_VALUEHL 
33df cd 5e 21			call macro_dsp_valuehl 
33e2				endm 
# End of macro FORTH_DSP_VALUEHL
33e2			;		push hl		 ; hl now has starting limit counter 
33e2			 
33e2					if DEBUG_FORTH_WORDS 
33e2						DMARK "DO6" 
33e2 f5				push af  
33e3 3a f7 33			ld a, (.dmark)  
33e6 32 6e fe			ld (debug_mark),a  
33e9 3a f8 33			ld a, (.dmark+1)  
33ec 32 6f fe			ld (debug_mark+1),a  
33ef 3a f9 33			ld a, (.dmark+2)  
33f2 32 70 fe			ld (debug_mark+2),a  
33f5 18 03			jr .pastdmark  
33f7 ..			.dmark: db "DO6"  
33fa f1			.pastdmark: pop af  
33fb			endm  
# End of macro DMARK
33fb						CALLMONITOR 
33fb cd f3 18			call break_point_state  
33fe				endm  
# End of macro CALLMONITOR
33fe					endif 
33fe					FORTH_DSP_POP 
33fe cd 16 22			call macro_forth_dsp_pop 
3401				endm 
# End of macro FORTH_DSP_POP
3401			 
3401			; put counters on the loop stack 
3401			 
3401			;		pop hl			 ; limit counter 
3401 d1					pop de			; start counter 
3402			 
3402					; push limit counter 
3402			 
3402					if DEBUG_FORTH_WORDS 
3402						DMARK "DO7" 
3402 f5				push af  
3403 3a 17 34			ld a, (.dmark)  
3406 32 6e fe			ld (debug_mark),a  
3409 3a 18 34			ld a, (.dmark+1)  
340c 32 6f fe			ld (debug_mark+1),a  
340f 3a 19 34			ld a, (.dmark+2)  
3412 32 70 fe			ld (debug_mark+2),a  
3415 18 03			jr .pastdmark  
3417 ..			.dmark: db "DO7"  
341a f1			.pastdmark: pop af  
341b			endm  
# End of macro DMARK
341b						CALLMONITOR 
341b cd f3 18			call break_point_state  
341e				endm  
# End of macro CALLMONITOR
341e					endif 
341e					FORTH_LOOP_NEXT 
341e cd 8f 21			call macro_forth_loop_next 
3421				endm 
# End of macro FORTH_LOOP_NEXT
3421			 
3421					; push start counter 
3421			 
3421 eb					ex de, hl 
3422					if DEBUG_FORTH_WORDS 
3422						DMARK "DO7" 
3422 f5				push af  
3423 3a 37 34			ld a, (.dmark)  
3426 32 6e fe			ld (debug_mark),a  
3429 3a 38 34			ld a, (.dmark+1)  
342c 32 6f fe			ld (debug_mark+1),a  
342f 3a 39 34			ld a, (.dmark+2)  
3432 32 70 fe			ld (debug_mark+2),a  
3435 18 03			jr .pastdmark  
3437 ..			.dmark: db "DO7"  
343a f1			.pastdmark: pop af  
343b			endm  
# End of macro DMARK
343b						CALLMONITOR 
343b cd f3 18			call break_point_state  
343e				endm  
# End of macro CALLMONITOR
343e					endif 
343e					FORTH_LOOP_NEXT 
343e cd 8f 21			call macro_forth_loop_next 
3441				endm 
# End of macro FORTH_LOOP_NEXT
3441			 
3441			 
3441					; init first round of I counter 
3441			 
3441 22 ed f4				ld (os_current_i), hl 
3444			 
3444					if DEBUG_FORTH_WORDS 
3444						DMARK "DO8" 
3444 f5				push af  
3445 3a 59 34			ld a, (.dmark)  
3448 32 6e fe			ld (debug_mark),a  
344b 3a 5a 34			ld a, (.dmark+1)  
344e 32 6f fe			ld (debug_mark+1),a  
3451 3a 5b 34			ld a, (.dmark+2)  
3454 32 70 fe			ld (debug_mark+2),a  
3457 18 03			jr .pastdmark  
3459 ..			.dmark: db "DO8"  
345c f1			.pastdmark: pop af  
345d			endm  
# End of macro DMARK
345d						CALLMONITOR 
345d cd f3 18			call break_point_state  
3460				endm  
# End of macro CALLMONITOR
3460					endif 
3460			 
3460					NEXTW 
3460 c3 14 23			jp macro_next 
3463				endm 
# End of macro NEXTW
3463			.LOOP: 
3463				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3463 22				db WORD_SYS_CORE+14             
3464 7b 35			dw .I            
3466 05				db 4 + 1 
3467 .. 00			db "LOOP",0              
346c				endm 
# End of macro CWHEAD
346c			; | LOOP ( -- ) Increment and test loop counter  | DONE 
346c			 
346c				; pop tos as current loop count to hl 
346c			 
346c				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
346c			 
346c				FORTH_LOOP_TOS 
346c cd c2 21			call macro_forth_loop_tos 
346f				endm 
# End of macro FORTH_LOOP_TOS
346f e5				push hl 
3470			 
3470					if DEBUG_FORTH_WORDS_KEY 
3470						DMARK "LOP" 
3470 f5				push af  
3471 3a 85 34			ld a, (.dmark)  
3474 32 6e fe			ld (debug_mark),a  
3477 3a 86 34			ld a, (.dmark+1)  
347a 32 6f fe			ld (debug_mark+1),a  
347d 3a 87 34			ld a, (.dmark+2)  
3480 32 70 fe			ld (debug_mark+2),a  
3483 18 03			jr .pastdmark  
3485 ..			.dmark: db "LOP"  
3488 f1			.pastdmark: pop af  
3489			endm  
# End of macro DMARK
3489						CALLMONITOR 
3489 cd f3 18			call break_point_state  
348c				endm  
# End of macro CALLMONITOR
348c					endif 
348c				; next item on the stack is the limit. get it 
348c			 
348c			 
348c				FORTH_LOOP_POP 
348c cd cc 21			call macro_forth_loop_pop 
348f				endm 
# End of macro FORTH_LOOP_POP
348f			 
348f				FORTH_LOOP_TOS 
348f cd c2 21			call macro_forth_loop_tos 
3492				endm 
# End of macro FORTH_LOOP_TOS
3492			 
3492 d1				pop de		 ; de = i, hl = limit 
3493			 
3493					if DEBUG_FORTH_WORDS 
3493						DMARK "LP1" 
3493 f5				push af  
3494 3a a8 34			ld a, (.dmark)  
3497 32 6e fe			ld (debug_mark),a  
349a 3a a9 34			ld a, (.dmark+1)  
349d 32 6f fe			ld (debug_mark+1),a  
34a0 3a aa 34			ld a, (.dmark+2)  
34a3 32 70 fe			ld (debug_mark+2),a  
34a6 18 03			jr .pastdmark  
34a8 ..			.dmark: db "LP1"  
34ab f1			.pastdmark: pop af  
34ac			endm  
# End of macro DMARK
34ac						CALLMONITOR 
34ac cd f3 18			call break_point_state  
34af				endm  
# End of macro CALLMONITOR
34af					endif 
34af			 
34af				; go back to previous word 
34af			 
34af d5				push de    ; save I for inc later 
34b0			 
34b0			 
34b0				; get limit 
34b0				;  is I at limit? 
34b0			 
34b0			 
34b0					if DEBUG_FORTH_WORDS 
34b0						DMARK "LP1" 
34b0 f5				push af  
34b1 3a c5 34			ld a, (.dmark)  
34b4 32 6e fe			ld (debug_mark),a  
34b7 3a c6 34			ld a, (.dmark+1)  
34ba 32 6f fe			ld (debug_mark+1),a  
34bd 3a c7 34			ld a, (.dmark+2)  
34c0 32 70 fe			ld (debug_mark+2),a  
34c3 18 03			jr .pastdmark  
34c5 ..			.dmark: db "LP1"  
34c8 f1			.pastdmark: pop af  
34c9			endm  
# End of macro DMARK
34c9						CALLMONITOR 
34c9 cd f3 18			call break_point_state  
34cc				endm  
# End of macro CALLMONITOR
34cc					endif 
34cc			 
34cc ed 52			sbc hl, de 
34ce			 
34ce			 
34ce				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
34ce			 
34ce 20 26				jr nz, .loopnotdone 
34d0			 
34d0 e1				pop hl   ; get rid of saved I 
34d1				FORTH_LOOP_POP     ; get rid of limit 
34d1 cd cc 21			call macro_forth_loop_pop 
34d4				endm 
# End of macro FORTH_LOOP_POP
34d4			 
34d4				FORTH_RSP_POP     ; get rid of DO ptr 
34d4 cd 2f 1f			call macro_forth_rsp_pop 
34d7				endm 
# End of macro FORTH_RSP_POP
34d7			 
34d7			if DEBUG_FORTH_WORDS 
34d7						DMARK "LP>" 
34d7 f5				push af  
34d8 3a ec 34			ld a, (.dmark)  
34db 32 6e fe			ld (debug_mark),a  
34de 3a ed 34			ld a, (.dmark+1)  
34e1 32 6f fe			ld (debug_mark+1),a  
34e4 3a ee 34			ld a, (.dmark+2)  
34e7 32 70 fe			ld (debug_mark+2),a  
34ea 18 03			jr .pastdmark  
34ec ..			.dmark: db "LP>"  
34ef f1			.pastdmark: pop af  
34f0			endm  
# End of macro DMARK
34f0				CALLMONITOR 
34f0 cd f3 18			call break_point_state  
34f3				endm  
# End of macro CALLMONITOR
34f3			endif 
34f3			 
34f3					NEXTW 
34f3 c3 14 23			jp macro_next 
34f6				endm 
# End of macro NEXTW
34f6				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34f6			 
34f6			.loopnotdone: 
34f6			 
34f6 e1				pop hl    ; get I 
34f7 23				inc hl 
34f8			 
34f8			   	; save new I 
34f8			 
34f8			 
34f8					; set I counter 
34f8			 
34f8 22 ed f4				ld (os_current_i), hl 
34fb			 
34fb					if DEBUG_FORTH_WORDS 
34fb						DMARK "LPN" 
34fb f5				push af  
34fc 3a 10 35			ld a, (.dmark)  
34ff 32 6e fe			ld (debug_mark),a  
3502 3a 11 35			ld a, (.dmark+1)  
3505 32 6f fe			ld (debug_mark+1),a  
3508 3a 12 35			ld a, (.dmark+2)  
350b 32 70 fe			ld (debug_mark+2),a  
350e 18 03			jr .pastdmark  
3510 ..			.dmark: db "LPN"  
3513 f1			.pastdmark: pop af  
3514			endm  
# End of macro DMARK
3514					CALLMONITOR 
3514 cd f3 18			call break_point_state  
3517				endm  
# End of macro CALLMONITOR
3517					endif 
3517					 
3517				FORTH_LOOP_NEXT 
3517 cd 8f 21			call macro_forth_loop_next 
351a				endm 
# End of macro FORTH_LOOP_NEXT
351a			 
351a			 
351a					if DEBUG_FORTH_WORDS 
351a eb						ex de,hl 
351b					endif 
351b			 
351b			;	; get DO ptr 
351b			; 
351b					if DEBUG_FORTH_WORDS 
351b						DMARK "LP7" 
351b f5				push af  
351c 3a 30 35			ld a, (.dmark)  
351f 32 6e fe			ld (debug_mark),a  
3522 3a 31 35			ld a, (.dmark+1)  
3525 32 6f fe			ld (debug_mark+1),a  
3528 3a 32 35			ld a, (.dmark+2)  
352b 32 70 fe			ld (debug_mark+2),a  
352e 18 03			jr .pastdmark  
3530 ..			.dmark: db "LP7"  
3533 f1			.pastdmark: pop af  
3534			endm  
# End of macro DMARK
3534					CALLMONITOR 
3534 cd f3 18			call break_point_state  
3537				endm  
# End of macro CALLMONITOR
3537					endif 
3537				FORTH_RSP_TOS 
3537 cd 25 1f			call macro_forth_rsp_tos 
353a				endm 
# End of macro FORTH_RSP_TOS
353a			 
353a					if DEBUG_FORTH_WORDS 
353a						DMARK "LP8" 
353a f5				push af  
353b 3a 4f 35			ld a, (.dmark)  
353e 32 6e fe			ld (debug_mark),a  
3541 3a 50 35			ld a, (.dmark+1)  
3544 32 6f fe			ld (debug_mark+1),a  
3547 3a 51 35			ld a, (.dmark+2)  
354a 32 70 fe			ld (debug_mark+2),a  
354d 18 03			jr .pastdmark  
354f ..			.dmark: db "LP8"  
3552 f1			.pastdmark: pop af  
3553			endm  
# End of macro DMARK
3553					CALLMONITOR 
3553 cd f3 18			call break_point_state  
3556				endm  
# End of macro CALLMONITOR
3556					endif 
3556				;push hl 
3556			 
3556				; not going to DO any more 
3556				; get rid of the RSP pointer as DO will add it back in 
3556				;FORTH_RSP_POP 
3556				;pop hl 
3556			 
3556				;ld hl,(cli_ret_sp) 
3556				;ld e, (hl) 
3556				;inc hl 
3556				;ld d, (hl) 
3556				;ex de,hl 
3556 22 c9 f4			ld (os_tok_ptr), hl 
3559					if DEBUG_FORTH_WORDS 
3559						DMARK "LP<" 
3559 f5				push af  
355a 3a 6e 35			ld a, (.dmark)  
355d 32 6e fe			ld (debug_mark),a  
3560 3a 6f 35			ld a, (.dmark+1)  
3563 32 6f fe			ld (debug_mark+1),a  
3566 3a 70 35			ld a, (.dmark+2)  
3569 32 70 fe			ld (debug_mark+2),a  
356c 18 03			jr .pastdmark  
356e ..			.dmark: db "LP<"  
3571 f1			.pastdmark: pop af  
3572			endm  
# End of macro DMARK
3572					CALLMONITOR 
3572 cd f3 18			call break_point_state  
3575				endm  
# End of macro CALLMONITOR
3575				endif 
3575 c3 a5 23			jp exec1 
3578			 
3578					 
3578			 
3578			 
3578					NEXTW 
3578 c3 14 23			jp macro_next 
357b				endm 
# End of macro NEXTW
357b			.I:  
357b			 
357b				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
357b 5e				db WORD_SYS_CORE+74             
357c a6 35			dw .DLOOP            
357e 02				db 1 + 1 
357f .. 00			db "I",0              
3581				endm 
# End of macro CWHEAD
3581			; | I ( -- ) Current loop counter | DONE 
3581					if DEBUG_FORTH_WORDS_KEY 
3581						DMARK "I.." 
3581 f5				push af  
3582 3a 96 35			ld a, (.dmark)  
3585 32 6e fe			ld (debug_mark),a  
3588 3a 97 35			ld a, (.dmark+1)  
358b 32 6f fe			ld (debug_mark+1),a  
358e 3a 98 35			ld a, (.dmark+2)  
3591 32 70 fe			ld (debug_mark+2),a  
3594 18 03			jr .pastdmark  
3596 ..			.dmark: db "I.."  
3599 f1			.pastdmark: pop af  
359a			endm  
# End of macro DMARK
359a						CALLMONITOR 
359a cd f3 18			call break_point_state  
359d				endm  
# End of macro CALLMONITOR
359d					endif 
359d			 
359d 2a ed f4				ld hl,(os_current_i) 
35a0 cd 67 1f				call forth_push_numhl 
35a3			 
35a3					NEXTW 
35a3 c3 14 23			jp macro_next 
35a6				endm 
# End of macro NEXTW
35a6			.DLOOP: 
35a6				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
35a6 5f				db WORD_SYS_CORE+75             
35a7 87 36			dw .REPEAT            
35a9 06				db 5 + 1 
35aa .. 00			db "-LOOP",0              
35b0				endm 
# End of macro CWHEAD
35b0			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
35b0				; pop tos as current loop count to hl 
35b0					if DEBUG_FORTH_WORDS_KEY 
35b0						DMARK "-LP" 
35b0 f5				push af  
35b1 3a c5 35			ld a, (.dmark)  
35b4 32 6e fe			ld (debug_mark),a  
35b7 3a c6 35			ld a, (.dmark+1)  
35ba 32 6f fe			ld (debug_mark+1),a  
35bd 3a c7 35			ld a, (.dmark+2)  
35c0 32 70 fe			ld (debug_mark+2),a  
35c3 18 03			jr .pastdmark  
35c5 ..			.dmark: db "-LP"  
35c8 f1			.pastdmark: pop af  
35c9			endm  
# End of macro DMARK
35c9						CALLMONITOR 
35c9 cd f3 18			call break_point_state  
35cc				endm  
# End of macro CALLMONITOR
35cc					endif 
35cc			 
35cc				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
35cc			 
35cc				FORTH_LOOP_TOS 
35cc cd c2 21			call macro_forth_loop_tos 
35cf				endm 
# End of macro FORTH_LOOP_TOS
35cf e5				push hl 
35d0			 
35d0					if DEBUG_FORTH_WORDS 
35d0						DMARK "-LP" 
35d0 f5				push af  
35d1 3a e5 35			ld a, (.dmark)  
35d4 32 6e fe			ld (debug_mark),a  
35d7 3a e6 35			ld a, (.dmark+1)  
35da 32 6f fe			ld (debug_mark+1),a  
35dd 3a e7 35			ld a, (.dmark+2)  
35e0 32 70 fe			ld (debug_mark+2),a  
35e3 18 03			jr .pastdmark  
35e5 ..			.dmark: db "-LP"  
35e8 f1			.pastdmark: pop af  
35e9			endm  
# End of macro DMARK
35e9						CALLMONITOR 
35e9 cd f3 18			call break_point_state  
35ec				endm  
# End of macro CALLMONITOR
35ec					endif 
35ec				; next item on the stack is the limit. get it 
35ec			 
35ec			 
35ec				FORTH_LOOP_POP 
35ec cd cc 21			call macro_forth_loop_pop 
35ef				endm 
# End of macro FORTH_LOOP_POP
35ef			 
35ef				FORTH_LOOP_TOS 
35ef cd c2 21			call macro_forth_loop_tos 
35f2				endm 
# End of macro FORTH_LOOP_TOS
35f2			 
35f2 d1				pop de		 ; de = i, hl = limit 
35f3			 
35f3					if DEBUG_FORTH_WORDS 
35f3						DMARK "-L1" 
35f3 f5				push af  
35f4 3a 08 36			ld a, (.dmark)  
35f7 32 6e fe			ld (debug_mark),a  
35fa 3a 09 36			ld a, (.dmark+1)  
35fd 32 6f fe			ld (debug_mark+1),a  
3600 3a 0a 36			ld a, (.dmark+2)  
3603 32 70 fe			ld (debug_mark+2),a  
3606 18 03			jr .pastdmark  
3608 ..			.dmark: db "-L1"  
360b f1			.pastdmark: pop af  
360c			endm  
# End of macro DMARK
360c						CALLMONITOR 
360c cd f3 18			call break_point_state  
360f				endm  
# End of macro CALLMONITOR
360f					endif 
360f			 
360f				; go back to previous word 
360f			 
360f d5				push de    ; save I for inc later 
3610			 
3610			 
3610				; get limit 
3610				;  is I at limit? 
3610			 
3610			 
3610					if DEBUG_FORTH_WORDS 
3610						DMARK "-L1" 
3610 f5				push af  
3611 3a 25 36			ld a, (.dmark)  
3614 32 6e fe			ld (debug_mark),a  
3617 3a 26 36			ld a, (.dmark+1)  
361a 32 6f fe			ld (debug_mark+1),a  
361d 3a 27 36			ld a, (.dmark+2)  
3620 32 70 fe			ld (debug_mark+2),a  
3623 18 03			jr .pastdmark  
3625 ..			.dmark: db "-L1"  
3628 f1			.pastdmark: pop af  
3629			endm  
# End of macro DMARK
3629						CALLMONITOR 
3629 cd f3 18			call break_point_state  
362c				endm  
# End of macro CALLMONITOR
362c					endif 
362c			 
362c ed 52			sbc hl, de 
362e			 
362e			 
362e				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
362e			 
362e 20 26				jr nz, .mloopnotdone 
3630			 
3630 e1				pop hl   ; get rid of saved I 
3631				FORTH_LOOP_POP     ; get rid of limit 
3631 cd cc 21			call macro_forth_loop_pop 
3634				endm 
# End of macro FORTH_LOOP_POP
3634			 
3634				FORTH_RSP_POP     ; get rid of DO ptr 
3634 cd 2f 1f			call macro_forth_rsp_pop 
3637				endm 
# End of macro FORTH_RSP_POP
3637			 
3637			if DEBUG_FORTH_WORDS 
3637						DMARK "-L>" 
3637 f5				push af  
3638 3a 4c 36			ld a, (.dmark)  
363b 32 6e fe			ld (debug_mark),a  
363e 3a 4d 36			ld a, (.dmark+1)  
3641 32 6f fe			ld (debug_mark+1),a  
3644 3a 4e 36			ld a, (.dmark+2)  
3647 32 70 fe			ld (debug_mark+2),a  
364a 18 03			jr .pastdmark  
364c ..			.dmark: db "-L>"  
364f f1			.pastdmark: pop af  
3650			endm  
# End of macro DMARK
3650				CALLMONITOR 
3650 cd f3 18			call break_point_state  
3653				endm  
# End of macro CALLMONITOR
3653			endif 
3653			 
3653					NEXTW 
3653 c3 14 23			jp macro_next 
3656				endm 
# End of macro NEXTW
3656				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3656			 
3656			.mloopnotdone: 
3656			 
3656 e1				pop hl    ; get I 
3657 2b				dec hl 
3658			 
3658			   	; save new I 
3658			 
3658			 
3658					; set I counter 
3658			 
3658 22 ed f4				ld (os_current_i), hl 
365b			 
365b					 
365b				FORTH_LOOP_NEXT 
365b cd 8f 21			call macro_forth_loop_next 
365e				endm 
# End of macro FORTH_LOOP_NEXT
365e			 
365e			 
365e					if DEBUG_FORTH_WORDS 
365e eb						ex de,hl 
365f					endif 
365f			 
365f			;	; get DO ptr 
365f			; 
365f				FORTH_RSP_TOS 
365f cd 25 1f			call macro_forth_rsp_tos 
3662				endm 
# End of macro FORTH_RSP_TOS
3662			 
3662				;push hl 
3662			 
3662				; not going to DO any more 
3662				; get rid of the RSP pointer as DO will add it back in 
3662				;FORTH_RSP_POP 
3662				;pop hl 
3662			 
3662			 
3662 22 c9 f4			ld (os_tok_ptr), hl 
3665					if DEBUG_FORTH_WORDS 
3665						DMARK "-L<" 
3665 f5				push af  
3666 3a 7a 36			ld a, (.dmark)  
3669 32 6e fe			ld (debug_mark),a  
366c 3a 7b 36			ld a, (.dmark+1)  
366f 32 6f fe			ld (debug_mark+1),a  
3672 3a 7c 36			ld a, (.dmark+2)  
3675 32 70 fe			ld (debug_mark+2),a  
3678 18 03			jr .pastdmark  
367a ..			.dmark: db "-L<"  
367d f1			.pastdmark: pop af  
367e			endm  
# End of macro DMARK
367e					CALLMONITOR 
367e cd f3 18			call break_point_state  
3681				endm  
# End of macro CALLMONITOR
3681				endif 
3681 c3 a5 23			jp exec1 
3684			 
3684					 
3684			 
3684			 
3684			 
3684				NEXTW 
3684 c3 14 23			jp macro_next 
3687				endm 
# End of macro NEXTW
3687			 
3687			 
3687			 
3687			 
3687			.REPEAT: 
3687				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3687 71				db WORD_SYS_CORE+93             
3688 da 36			dw .UNTIL            
368a 06				db 5 + 1 
368b .. 00			db "REPEAT",0              
3692				endm 
# End of macro CWHEAD
3692			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3692			;  push pc to rsp stack past the REPEAT 
3692					if DEBUG_FORTH_WORDS_KEY 
3692						DMARK "REP" 
3692 f5				push af  
3693 3a a7 36			ld a, (.dmark)  
3696 32 6e fe			ld (debug_mark),a  
3699 3a a8 36			ld a, (.dmark+1)  
369c 32 6f fe			ld (debug_mark+1),a  
369f 3a a9 36			ld a, (.dmark+2)  
36a2 32 70 fe			ld (debug_mark+2),a  
36a5 18 03			jr .pastdmark  
36a7 ..			.dmark: db "REP"  
36aa f1			.pastdmark: pop af  
36ab			endm  
# End of macro DMARK
36ab						CALLMONITOR 
36ab cd f3 18			call break_point_state  
36ae				endm  
# End of macro CALLMONITOR
36ae					endif 
36ae			 
36ae 2a c9 f4				ld hl, (os_tok_ptr) 
36b1 23					inc hl   ; R 
36b2 23					inc hl  ; E 
36b3 23					inc hl   ; P 
36b4 23					inc hl   ; E 
36b5 23					inc hl   ; A 
36b6 23					inc hl   ; T 
36b7 23					inc hl   ; zero 
36b8					FORTH_RSP_NEXT 
36b8 cd 0e 1f			call macro_forth_rsp_next 
36bb				endm 
# End of macro FORTH_RSP_NEXT
36bb			 
36bb			 
36bb					if DEBUG_FORTH_WORDS 
36bb						DMARK "REP" 
36bb f5				push af  
36bc 3a d0 36			ld a, (.dmark)  
36bf 32 6e fe			ld (debug_mark),a  
36c2 3a d1 36			ld a, (.dmark+1)  
36c5 32 6f fe			ld (debug_mark+1),a  
36c8 3a d2 36			ld a, (.dmark+2)  
36cb 32 70 fe			ld (debug_mark+2),a  
36ce 18 03			jr .pastdmark  
36d0 ..			.dmark: db "REP"  
36d3 f1			.pastdmark: pop af  
36d4			endm  
# End of macro DMARK
36d4						;pop bc    ; TODO BUG ?????? what is this for???? 
36d4						CALLMONITOR 
36d4 cd f3 18			call break_point_state  
36d7				endm  
# End of macro CALLMONITOR
36d7					endif 
36d7			 
36d7					NEXTW 
36d7 c3 14 23			jp macro_next 
36da				endm 
# End of macro NEXTW
36da			;	       NEXTW 
36da			 
36da			.UNTIL: 
36da				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
36da 72				db WORD_SYS_CORE+94             
36db 71 37			dw .ENDFLOW            
36dd 06				db 5 + 1 
36de .. 00			db "UNTIL",0              
36e4				endm 
# End of macro CWHEAD
36e4			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
36e4			 
36e4				; pop tos as check 
36e4			 
36e4				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
36e4			 
36e4				FORTH_DSP_VALUEHL 
36e4 cd 5e 21			call macro_dsp_valuehl 
36e7				endm 
# End of macro FORTH_DSP_VALUEHL
36e7			 
36e7					if DEBUG_FORTH_WORDS_KEY 
36e7						DMARK "UNT" 
36e7 f5				push af  
36e8 3a fc 36			ld a, (.dmark)  
36eb 32 6e fe			ld (debug_mark),a  
36ee 3a fd 36			ld a, (.dmark+1)  
36f1 32 6f fe			ld (debug_mark+1),a  
36f4 3a fe 36			ld a, (.dmark+2)  
36f7 32 70 fe			ld (debug_mark+2),a  
36fa 18 03			jr .pastdmark  
36fc ..			.dmark: db "UNT"  
36ff f1			.pastdmark: pop af  
3700			endm  
# End of macro DMARK
3700						CALLMONITOR 
3700 cd f3 18			call break_point_state  
3703				endm  
# End of macro CALLMONITOR
3703					endif 
3703			 
3703			;	push hl 
3703				FORTH_DSP_POP 
3703 cd 16 22			call macro_forth_dsp_pop 
3706				endm 
# End of macro FORTH_DSP_POP
3706			 
3706			;	pop hl 
3706			 
3706				; test if true 
3706			 
3706 cd 75 0f			call ishlzero 
3709			;	ld a,l 
3709			;	add h 
3709			; 
3709			;	cp 0 
3709			 
3709 20 3e			jr nz, .untilnotdone 
370b			 
370b					if DEBUG_FORTH_WORDS 
370b						DMARK "UNf" 
370b f5				push af  
370c 3a 20 37			ld a, (.dmark)  
370f 32 6e fe			ld (debug_mark),a  
3712 3a 21 37			ld a, (.dmark+1)  
3715 32 6f fe			ld (debug_mark+1),a  
3718 3a 22 37			ld a, (.dmark+2)  
371b 32 70 fe			ld (debug_mark+2),a  
371e 18 03			jr .pastdmark  
3720 ..			.dmark: db "UNf"  
3723 f1			.pastdmark: pop af  
3724			endm  
# End of macro DMARK
3724						CALLMONITOR 
3724 cd f3 18			call break_point_state  
3727				endm  
# End of macro CALLMONITOR
3727					endif 
3727			 
3727			 
3727			 
3727				FORTH_RSP_POP     ; get rid of DO ptr 
3727 cd 2f 1f			call macro_forth_rsp_pop 
372a				endm 
# End of macro FORTH_RSP_POP
372a			 
372a			if DEBUG_FORTH_WORDS 
372a						DMARK "UN>" 
372a f5				push af  
372b 3a 3f 37			ld a, (.dmark)  
372e 32 6e fe			ld (debug_mark),a  
3731 3a 40 37			ld a, (.dmark+1)  
3734 32 6f fe			ld (debug_mark+1),a  
3737 3a 41 37			ld a, (.dmark+2)  
373a 32 70 fe			ld (debug_mark+2),a  
373d 18 03			jr .pastdmark  
373f ..			.dmark: db "UN>"  
3742 f1			.pastdmark: pop af  
3743			endm  
# End of macro DMARK
3743				CALLMONITOR 
3743 cd f3 18			call break_point_state  
3746				endm  
# End of macro CALLMONITOR
3746			endif 
3746			 
3746					NEXTW 
3746 c3 14 23			jp macro_next 
3749				endm 
# End of macro NEXTW
3749				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3749			 
3749			.untilnotdone: 
3749			 
3749			 
3749			;	; get DO ptr 
3749			; 
3749				FORTH_RSP_TOS 
3749 cd 25 1f			call macro_forth_rsp_tos 
374c				endm 
# End of macro FORTH_RSP_TOS
374c			 
374c				;push hl 
374c			 
374c				; not going to DO any more 
374c				; get rid of the RSP pointer as DO will add it back in 
374c				;FORTH_RSP_POP 
374c				;pop hl 
374c			 
374c			 
374c 22 c9 f4			ld (os_tok_ptr), hl 
374f					if DEBUG_FORTH_WORDS 
374f						DMARK "UN<" 
374f f5				push af  
3750 3a 64 37			ld a, (.dmark)  
3753 32 6e fe			ld (debug_mark),a  
3756 3a 65 37			ld a, (.dmark+1)  
3759 32 6f fe			ld (debug_mark+1),a  
375c 3a 66 37			ld a, (.dmark+2)  
375f 32 70 fe			ld (debug_mark+2),a  
3762 18 03			jr .pastdmark  
3764 ..			.dmark: db "UN<"  
3767 f1			.pastdmark: pop af  
3768			endm  
# End of macro DMARK
3768					CALLMONITOR 
3768 cd f3 18			call break_point_state  
376b				endm  
# End of macro CALLMONITOR
376b				endif 
376b c3 a5 23			jp exec1 
376e			 
376e					 
376e			 
376e			 
376e					NEXTW 
376e c3 14 23			jp macro_next 
3771				endm 
# End of macro NEXTW
3771			 
3771			 
3771			.ENDFLOW: 
3771			 
3771			; eof 
3771			 
# End of file forth_words_flow.asm
3771			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3771			include "forth_words_logic.asm" 
3771			 
3771			; | ## Logic Words 
3771			 
3771			.NOT: 
3771				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3771 2d				db WORD_SYS_CORE+25             
3772 b9 37			dw .IS            
3774 04				db 3 + 1 
3775 .. 00			db "NOT",0              
3779				endm 
# End of macro CWHEAD
3779			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3779					if DEBUG_FORTH_WORDS_KEY 
3779						DMARK "NOT" 
3779 f5				push af  
377a 3a 8e 37			ld a, (.dmark)  
377d 32 6e fe			ld (debug_mark),a  
3780 3a 8f 37			ld a, (.dmark+1)  
3783 32 6f fe			ld (debug_mark+1),a  
3786 3a 90 37			ld a, (.dmark+2)  
3789 32 70 fe			ld (debug_mark+2),a  
378c 18 03			jr .pastdmark  
378e ..			.dmark: db "NOT"  
3791 f1			.pastdmark: pop af  
3792			endm  
# End of macro DMARK
3792						CALLMONITOR 
3792 cd f3 18			call break_point_state  
3795				endm  
# End of macro CALLMONITOR
3795					endif 
3795					FORTH_DSP 
3795 cd 24 21			call macro_forth_dsp 
3798				endm 
# End of macro FORTH_DSP
3798 7e					ld a,(hl)	; get type of value on TOS 
3799 fe 02				cp DS_TYPE_INUM  
379b 28 03				jr z, .noti 
379d					NEXTW 
379d c3 14 23			jp macro_next 
37a0				endm 
# End of macro NEXTW
37a0			.noti:          FORTH_DSP_VALUEHL 
37a0 cd 5e 21			call macro_dsp_valuehl 
37a3				endm 
# End of macro FORTH_DSP_VALUEHL
37a3			;		push hl 
37a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37a3 cd 16 22			call macro_forth_dsp_pop 
37a6				endm 
# End of macro FORTH_DSP_POP
37a6			;		pop hl 
37a6 3e 00				ld a,0 
37a8 bd					cp l 
37a9 28 04				jr z, .not2t 
37ab 2e 00				ld l, 0 
37ad 18 02				jr .notip 
37af			 
37af 2e ff		.not2t:		ld l, 255 
37b1			 
37b1 26 00		.notip:		ld h, 0	 
37b3			 
37b3 cd 67 1f				call forth_push_numhl 
37b6					NEXTW 
37b6 c3 14 23			jp macro_next 
37b9				endm 
# End of macro NEXTW
37b9			 
37b9			.IS: 
37b9				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
37b9 2d				db WORD_SYS_CORE+25             
37ba df 37			dw .LZERO            
37bc 03				db 2 + 1 
37bd .. 00			db "IS",0              
37c0				endm 
# End of macro CWHEAD
37c0			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
37c0					if DEBUG_FORTH_WORDS_KEY 
37c0						DMARK "IS." 
37c0 f5				push af  
37c1 3a d5 37			ld a, (.dmark)  
37c4 32 6e fe			ld (debug_mark),a  
37c7 3a d6 37			ld a, (.dmark+1)  
37ca 32 6f fe			ld (debug_mark+1),a  
37cd 3a d7 37			ld a, (.dmark+2)  
37d0 32 70 fe			ld (debug_mark+2),a  
37d3 18 03			jr .pastdmark  
37d5 ..			.dmark: db "IS."  
37d8 f1			.pastdmark: pop af  
37d9			endm  
# End of macro DMARK
37d9						CALLMONITOR 
37d9 cd f3 18			call break_point_state  
37dc				endm  
# End of macro CALLMONITOR
37dc					endif 
37dc					NEXTW 
37dc c3 14 23			jp macro_next 
37df				endm 
# End of macro NEXTW
37df			.LZERO: 
37df				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
37df 2d				db WORD_SYS_CORE+25             
37e0 e9 37			dw .TZERO            
37e2 03				db 2 + 1 
37e3 .. 00			db "0<",0              
37e6				endm 
# End of macro CWHEAD
37e6			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
37e6					NEXTW 
37e6 c3 14 23			jp macro_next 
37e9				endm 
# End of macro NEXTW
37e9			.TZERO: 
37e9				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
37e9 2e				db WORD_SYS_CORE+26             
37ea 30 38			dw .LESS            
37ec 03				db 2 + 1 
37ed .. 00			db "0=",0              
37f0				endm 
# End of macro CWHEAD
37f0			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
37f0				; TODO add floating point number detection 
37f0					;v5 FORTH_DSP_VALUE 
37f0					if DEBUG_FORTH_WORDS_KEY 
37f0						DMARK "0=." 
37f0 f5				push af  
37f1 3a 05 38			ld a, (.dmark)  
37f4 32 6e fe			ld (debug_mark),a  
37f7 3a 06 38			ld a, (.dmark+1)  
37fa 32 6f fe			ld (debug_mark+1),a  
37fd 3a 07 38			ld a, (.dmark+2)  
3800 32 70 fe			ld (debug_mark+2),a  
3803 18 03			jr .pastdmark  
3805 ..			.dmark: db "0=."  
3808 f1			.pastdmark: pop af  
3809			endm  
# End of macro DMARK
3809						CALLMONITOR 
3809 cd f3 18			call break_point_state  
380c				endm  
# End of macro CALLMONITOR
380c					endif 
380c					FORTH_DSP 
380c cd 24 21			call macro_forth_dsp 
380f				endm 
# End of macro FORTH_DSP
380f 7e					ld a,(hl)	; get type of value on TOS 
3810 fe 02				cp DS_TYPE_INUM  
3812 28 00				jr z, .tz_inum 
3814			 
3814				if FORTH_ENABLE_FLOATMATH 
3814					jr .tz_done 
3814			 
3814				endif 
3814					 
3814			 
3814			.tz_inum: 
3814					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3814 cd 5e 21			call macro_dsp_valuehl 
3817				endm 
# End of macro FORTH_DSP_VALUEHL
3817			 
3817			;		push hl 
3817			 
3817					; destroy value TOS 
3817			 
3817					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3817 cd 16 22			call macro_forth_dsp_pop 
381a				endm 
# End of macro FORTH_DSP_POP
381a			 
381a			;		pop hl 
381a			 
381a 3e 00				ld a,0 
381c			 
381c bd					cp l 
381d 20 08				jr nz, .tz_notzero 
381f			 
381f bc					cp h 
3820			 
3820 20 05				jr nz, .tz_notzero 
3822			 
3822			 
3822 21 01 00				ld hl, FORTH_TRUE 
3825 18 03				jr .tz_done 
3827			 
3827 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
382a			 
382a					; push value back onto stack for another op etc 
382a			 
382a			.tz_done: 
382a cd 67 1f				call forth_push_numhl 
382d			 
382d					NEXTW 
382d c3 14 23			jp macro_next 
3830				endm 
# End of macro NEXTW
3830			.LESS: 
3830				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3830 2f				db WORD_SYS_CORE+27             
3831 99 38			dw .GT            
3833 02				db 1 + 1 
3834 .. 00			db "<",0              
3836				endm 
# End of macro CWHEAD
3836			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3836				; TODO add floating point number detection 
3836					if DEBUG_FORTH_WORDS_KEY 
3836						DMARK "LES" 
3836 f5				push af  
3837 3a 4b 38			ld a, (.dmark)  
383a 32 6e fe			ld (debug_mark),a  
383d 3a 4c 38			ld a, (.dmark+1)  
3840 32 6f fe			ld (debug_mark+1),a  
3843 3a 4d 38			ld a, (.dmark+2)  
3846 32 70 fe			ld (debug_mark+2),a  
3849 18 03			jr .pastdmark  
384b ..			.dmark: db "LES"  
384e f1			.pastdmark: pop af  
384f			endm  
# End of macro DMARK
384f						CALLMONITOR 
384f cd f3 18			call break_point_state  
3852				endm  
# End of macro CALLMONITOR
3852					endif 
3852					FORTH_DSP 
3852 cd 24 21			call macro_forth_dsp 
3855				endm 
# End of macro FORTH_DSP
3855					;v5 FORTH_DSP_VALUE 
3855 7e					ld a,(hl)	; get type of value on TOS 
3856 fe 02				cp DS_TYPE_INUM  
3858 28 00				jr z, .less_inum 
385a			 
385a				if FORTH_ENABLE_FLOATMATH 
385a					jr .less_done 
385a			 
385a				endif 
385a					 
385a			 
385a			.less_inum: 
385a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
385a cd 5e 21			call macro_dsp_valuehl 
385d				endm 
# End of macro FORTH_DSP_VALUEHL
385d			 
385d e5					push hl  ; u2 
385e			 
385e					; destroy value TOS 
385e			 
385e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
385e cd 16 22			call macro_forth_dsp_pop 
3861				endm 
# End of macro FORTH_DSP_POP
3861			 
3861			 
3861					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3861 cd 5e 21			call macro_dsp_valuehl 
3864				endm 
# End of macro FORTH_DSP_VALUEHL
3864			 
3864 e5					push hl    ; u1 
3865			 
3865					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3865 cd 16 22			call macro_forth_dsp_pop 
3868				endm 
# End of macro FORTH_DSP_POP
3868			 
3868			 
3868 b7			 or a      ;clear carry flag 
3869 01 00 00		 ld bc, FORTH_FALSE 
386c e1			  pop hl    ; u1 
386d d1			  pop de    ; u2 
386e ed 52		  sbc hl,de 
3870 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3872			 
3872 01 01 00		 ld bc, FORTH_TRUE 
3875			.lscont:  
3875 c5					push bc 
3876 e1					pop hl 
3877			 
3877					if DEBUG_FORTH_WORDS 
3877						DMARK "LT1" 
3877 f5				push af  
3878 3a 8c 38			ld a, (.dmark)  
387b 32 6e fe			ld (debug_mark),a  
387e 3a 8d 38			ld a, (.dmark+1)  
3881 32 6f fe			ld (debug_mark+1),a  
3884 3a 8e 38			ld a, (.dmark+2)  
3887 32 70 fe			ld (debug_mark+2),a  
388a 18 03			jr .pastdmark  
388c ..			.dmark: db "LT1"  
388f f1			.pastdmark: pop af  
3890			endm  
# End of macro DMARK
3890						CALLMONITOR 
3890 cd f3 18			call break_point_state  
3893				endm  
# End of macro CALLMONITOR
3893					endif 
3893 cd 67 1f				call forth_push_numhl 
3896			 
3896					NEXTW 
3896 c3 14 23			jp macro_next 
3899				endm 
# End of macro NEXTW
3899			.GT: 
3899				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3899 30				db WORD_SYS_CORE+28             
389a 02 39			dw .EQUAL            
389c 02				db 1 + 1 
389d .. 00			db ">",0              
389f				endm 
# End of macro CWHEAD
389f			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
389f				; TODO add floating point number detection 
389f					if DEBUG_FORTH_WORDS_KEY 
389f						DMARK "GRT" 
389f f5				push af  
38a0 3a b4 38			ld a, (.dmark)  
38a3 32 6e fe			ld (debug_mark),a  
38a6 3a b5 38			ld a, (.dmark+1)  
38a9 32 6f fe			ld (debug_mark+1),a  
38ac 3a b6 38			ld a, (.dmark+2)  
38af 32 70 fe			ld (debug_mark+2),a  
38b2 18 03			jr .pastdmark  
38b4 ..			.dmark: db "GRT"  
38b7 f1			.pastdmark: pop af  
38b8			endm  
# End of macro DMARK
38b8						CALLMONITOR 
38b8 cd f3 18			call break_point_state  
38bb				endm  
# End of macro CALLMONITOR
38bb					endif 
38bb					FORTH_DSP 
38bb cd 24 21			call macro_forth_dsp 
38be				endm 
# End of macro FORTH_DSP
38be					;FORTH_DSP_VALUE 
38be 7e					ld a,(hl)	; get type of value on TOS 
38bf fe 02				cp DS_TYPE_INUM  
38c1 28 00				jr z, .gt_inum 
38c3			 
38c3				if FORTH_ENABLE_FLOATMATH 
38c3					jr .gt_done 
38c3			 
38c3				endif 
38c3					 
38c3			 
38c3			.gt_inum: 
38c3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38c3 cd 5e 21			call macro_dsp_valuehl 
38c6				endm 
# End of macro FORTH_DSP_VALUEHL
38c6			 
38c6 e5					push hl  ; u2 
38c7			 
38c7					; destroy value TOS 
38c7			 
38c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38c7 cd 16 22			call macro_forth_dsp_pop 
38ca				endm 
# End of macro FORTH_DSP_POP
38ca			 
38ca			 
38ca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38ca cd 5e 21			call macro_dsp_valuehl 
38cd				endm 
# End of macro FORTH_DSP_VALUEHL
38cd			 
38cd e5					push hl    ; u1 
38ce			 
38ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38ce cd 16 22			call macro_forth_dsp_pop 
38d1				endm 
# End of macro FORTH_DSP_POP
38d1			 
38d1			 
38d1 b7			 or a      ;clear carry flag 
38d2 01 00 00		 ld bc, FORTH_FALSE 
38d5 e1			  pop hl    ; u1 
38d6 d1			  pop de    ; u2 
38d7 ed 52		  sbc hl,de 
38d9 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
38db			 
38db 01 01 00		 ld bc, FORTH_TRUE 
38de			.gtcont:  
38de c5					push bc 
38df e1					pop hl 
38e0			 
38e0					if DEBUG_FORTH_WORDS 
38e0						DMARK "GT1" 
38e0 f5				push af  
38e1 3a f5 38			ld a, (.dmark)  
38e4 32 6e fe			ld (debug_mark),a  
38e7 3a f6 38			ld a, (.dmark+1)  
38ea 32 6f fe			ld (debug_mark+1),a  
38ed 3a f7 38			ld a, (.dmark+2)  
38f0 32 70 fe			ld (debug_mark+2),a  
38f3 18 03			jr .pastdmark  
38f5 ..			.dmark: db "GT1"  
38f8 f1			.pastdmark: pop af  
38f9			endm  
# End of macro DMARK
38f9						CALLMONITOR 
38f9 cd f3 18			call break_point_state  
38fc				endm  
# End of macro CALLMONITOR
38fc					endif 
38fc cd 67 1f				call forth_push_numhl 
38ff			 
38ff					NEXTW 
38ff c3 14 23			jp macro_next 
3902				endm 
# End of macro NEXTW
3902			.EQUAL: 
3902				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3902 31				db WORD_SYS_CORE+29             
3903 6d 39			dw .ENDLOGIC            
3905 02				db 1 + 1 
3906 .. 00			db "=",0              
3908				endm 
# End of macro CWHEAD
3908			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3908				; TODO add floating point number detection 
3908					if DEBUG_FORTH_WORDS_KEY 
3908						DMARK "EQ." 
3908 f5				push af  
3909 3a 1d 39			ld a, (.dmark)  
390c 32 6e fe			ld (debug_mark),a  
390f 3a 1e 39			ld a, (.dmark+1)  
3912 32 6f fe			ld (debug_mark+1),a  
3915 3a 1f 39			ld a, (.dmark+2)  
3918 32 70 fe			ld (debug_mark+2),a  
391b 18 03			jr .pastdmark  
391d ..			.dmark: db "EQ."  
3920 f1			.pastdmark: pop af  
3921			endm  
# End of macro DMARK
3921						CALLMONITOR 
3921 cd f3 18			call break_point_state  
3924				endm  
# End of macro CALLMONITOR
3924					endif 
3924					FORTH_DSP 
3924 cd 24 21			call macro_forth_dsp 
3927				endm 
# End of macro FORTH_DSP
3927					;v5 FORTH_DSP_VALUE 
3927 7e					ld a,(hl)	; get type of value on TOS 
3928 fe 02				cp DS_TYPE_INUM  
392a 28 00				jr z, .eq_inum 
392c			 
392c				if FORTH_ENABLE_FLOATMATH 
392c					jr .eq_done 
392c			 
392c				endif 
392c					 
392c			 
392c			.eq_inum: 
392c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
392c cd 5e 21			call macro_dsp_valuehl 
392f				endm 
# End of macro FORTH_DSP_VALUEHL
392f			 
392f e5					push hl 
3930			 
3930					; destroy value TOS 
3930			 
3930					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3930 cd 16 22			call macro_forth_dsp_pop 
3933				endm 
# End of macro FORTH_DSP_POP
3933			 
3933			 
3933					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3933 cd 5e 21			call macro_dsp_valuehl 
3936				endm 
# End of macro FORTH_DSP_VALUEHL
3936			 
3936					; one value on hl get other one back 
3936			 
3936 e5					push hl 
3937			 
3937					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3937 cd 16 22			call macro_forth_dsp_pop 
393a				endm 
# End of macro FORTH_DSP_POP
393a			 
393a 0e 00				ld c, FORTH_FALSE 
393c			 
393c e1					pop hl 
393d d1					pop de 
393e			 
393e 7b					ld a, e 
393f bd					cp l 
3940			 
3940 20 06				jr nz, .eq_done 
3942			 
3942 7a					ld a, d 
3943 bc					cp h 
3944			 
3944 20 02				jr nz, .eq_done 
3946			 
3946 0e 01				ld c, FORTH_TRUE 
3948					 
3948			 
3948			 
3948			.eq_done: 
3948			 
3948					; TODO push value back onto stack for another op etc 
3948			 
3948 26 00				ld h, 0 
394a 69					ld l, c 
394b					if DEBUG_FORTH_WORDS 
394b						DMARK "EQ1" 
394b f5				push af  
394c 3a 60 39			ld a, (.dmark)  
394f 32 6e fe			ld (debug_mark),a  
3952 3a 61 39			ld a, (.dmark+1)  
3955 32 6f fe			ld (debug_mark+1),a  
3958 3a 62 39			ld a, (.dmark+2)  
395b 32 70 fe			ld (debug_mark+2),a  
395e 18 03			jr .pastdmark  
3960 ..			.dmark: db "EQ1"  
3963 f1			.pastdmark: pop af  
3964			endm  
# End of macro DMARK
3964						CALLMONITOR 
3964 cd f3 18			call break_point_state  
3967				endm  
# End of macro CALLMONITOR
3967					endif 
3967 cd 67 1f				call forth_push_numhl 
396a			 
396a					NEXTW 
396a c3 14 23			jp macro_next 
396d				endm 
# End of macro NEXTW
396d			 
396d			 
396d			.ENDLOGIC: 
396d			; eof 
396d			 
396d			 
# End of file forth_words_logic.asm
396d			include "forth_words_maths.asm" 
396d			 
396d			; | ## Maths Words 
396d			 
396d			.PLUS:	 
396d				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
396d 15				db WORD_SYS_CORE+1             
396e cb 39			dw .NEG            
3970 02				db 1 + 1 
3971 .. 00			db "+",0              
3973				endm 
# End of macro CWHEAD
3973			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3973					if DEBUG_FORTH_WORDS_KEY 
3973						DMARK "PLU" 
3973 f5				push af  
3974 3a 88 39			ld a, (.dmark)  
3977 32 6e fe			ld (debug_mark),a  
397a 3a 89 39			ld a, (.dmark+1)  
397d 32 6f fe			ld (debug_mark+1),a  
3980 3a 8a 39			ld a, (.dmark+2)  
3983 32 70 fe			ld (debug_mark+2),a  
3986 18 03			jr .pastdmark  
3988 ..			.dmark: db "PLU"  
398b f1			.pastdmark: pop af  
398c			endm  
# End of macro DMARK
398c						CALLMONITOR 
398c cd f3 18			call break_point_state  
398f				endm  
# End of macro CALLMONITOR
398f					endif 
398f					; add top two values and push back result 
398f			 
398f					;for v5 FORTH_DSP_VALUE 
398f					FORTH_DSP 
398f cd 24 21			call macro_forth_dsp 
3992				endm 
# End of macro FORTH_DSP
3992 7e					ld a,(hl)	; get type of value on TOS 
3993 fe 02				cp DS_TYPE_INUM  
3995 28 03				jr z, .dot_inum 
3997			 
3997					NEXTW 
3997 c3 14 23			jp macro_next 
399a				endm 
# End of macro NEXTW
399a			 
399a			; float maths 
399a			 
399a				if FORTH_ENABLE_FLOATMATH 
399a						inc hl      ; now at start of numeric as string 
399a			 
399a					if DEBUG_FORTH_MATHS 
399a						DMARK "ADD" 
399a				CALLMONITOR 
399a					endif 
399a			 
399a					;ld ix, hl 
399a					call CON 
399a			 
399a			 
399a					push hl 
399a					 
399a					 
399a			 
399a						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
399a			 
399a					; get next number 
399a			 
399a						FORTH_DSP_VALUE 
399a			 
399a						inc hl      ; now at start of numeric as string 
399a			 
399a					;ld ix, hl 
399a					call CON 
399a			 
399a					push hl 
399a			 
399a			 
399a						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
399a			 
399a						; TODO do add 
399a			 
399a						call IADD 
399a			 
399a						; TODO get result back as ascii 
399a			 
399a						; TODO push result  
399a			 
399a			 
399a			 
399a						jr .dot_done 
399a				endif 
399a			 
399a			.dot_inum: 
399a			 
399a			 
399a					if DEBUG_FORTH_DOT 
399a						DMARK "+IT" 
399a f5				push af  
399b 3a af 39			ld a, (.dmark)  
399e 32 6e fe			ld (debug_mark),a  
39a1 3a b0 39			ld a, (.dmark+1)  
39a4 32 6f fe			ld (debug_mark+1),a  
39a7 3a b1 39			ld a, (.dmark+2)  
39aa 32 70 fe			ld (debug_mark+2),a  
39ad 18 03			jr .pastdmark  
39af ..			.dmark: db "+IT"  
39b2 f1			.pastdmark: pop af  
39b3			endm  
# End of macro DMARK
39b3				CALLMONITOR 
39b3 cd f3 18			call break_point_state  
39b6				endm  
# End of macro CALLMONITOR
39b6					endif 
39b6			 
39b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b6 cd 5e 21			call macro_dsp_valuehl 
39b9				endm 
# End of macro FORTH_DSP_VALUEHL
39b9			 
39b9				; TODO add floating point number detection 
39b9			 
39b9 e5					push hl 
39ba			 
39ba					; destroy value TOS 
39ba			 
39ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39ba cd 16 22			call macro_forth_dsp_pop 
39bd				endm 
# End of macro FORTH_DSP_POP
39bd			 
39bd			 
39bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39bd cd 5e 21			call macro_dsp_valuehl 
39c0				endm 
# End of macro FORTH_DSP_VALUEHL
39c0			 
39c0					; one value on hl get other one back 
39c0			 
39c0 d1					pop de 
39c1			 
39c1					; do the add 
39c1			 
39c1 19					add hl,de 
39c2			 
39c2					; save it 
39c2			 
39c2			;		push hl	 
39c2			 
39c2					; 
39c2			 
39c2					; destroy value TOS 
39c2			 
39c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c2 cd 16 22			call macro_forth_dsp_pop 
39c5				endm 
# End of macro FORTH_DSP_POP
39c5			 
39c5					; TODO push value back onto stack for another op etc 
39c5			 
39c5			;		pop hl 
39c5			 
39c5			.dot_done: 
39c5 cd 67 1f				call forth_push_numhl 
39c8			 
39c8					NEXTW 
39c8 c3 14 23			jp macro_next 
39cb				endm 
# End of macro NEXTW
39cb			.NEG: 
39cb			 
39cb				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
39cb 17				db WORD_SYS_CORE+3             
39cc 0e 3a			dw .DIV            
39ce 02				db 1 + 1 
39cf .. 00			db "-",0              
39d1				endm 
# End of macro CWHEAD
39d1			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
39d1					if DEBUG_FORTH_WORDS_KEY 
39d1						DMARK "SUB" 
39d1 f5				push af  
39d2 3a e6 39			ld a, (.dmark)  
39d5 32 6e fe			ld (debug_mark),a  
39d8 3a e7 39			ld a, (.dmark+1)  
39db 32 6f fe			ld (debug_mark+1),a  
39de 3a e8 39			ld a, (.dmark+2)  
39e1 32 70 fe			ld (debug_mark+2),a  
39e4 18 03			jr .pastdmark  
39e6 ..			.dmark: db "SUB"  
39e9 f1			.pastdmark: pop af  
39ea			endm  
# End of macro DMARK
39ea						CALLMONITOR 
39ea cd f3 18			call break_point_state  
39ed				endm  
# End of macro CALLMONITOR
39ed					endif 
39ed			 
39ed			 
39ed				; TODO add floating point number detection 
39ed					; v5 FORTH_DSP_VALUE 
39ed					FORTH_DSP 
39ed cd 24 21			call macro_forth_dsp 
39f0				endm 
# End of macro FORTH_DSP
39f0 7e					ld a,(hl)	; get type of value on TOS 
39f1 fe 02				cp DS_TYPE_INUM  
39f3 28 03				jr z, .neg_inum 
39f5			 
39f5					NEXTW 
39f5 c3 14 23			jp macro_next 
39f8				endm 
# End of macro NEXTW
39f8			 
39f8			; float maths 
39f8			 
39f8				if FORTH_ENABLE_FLOATMATH 
39f8					jr .neg_done 
39f8			 
39f8				endif 
39f8					 
39f8			 
39f8			.neg_inum: 
39f8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39f8 cd 5e 21			call macro_dsp_valuehl 
39fb				endm 
# End of macro FORTH_DSP_VALUEHL
39fb			 
39fb e5					push hl 
39fc			 
39fc					; destroy value TOS 
39fc			 
39fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39fc cd 16 22			call macro_forth_dsp_pop 
39ff				endm 
# End of macro FORTH_DSP_POP
39ff			 
39ff			 
39ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39ff cd 5e 21			call macro_dsp_valuehl 
3a02				endm 
# End of macro FORTH_DSP_VALUEHL
3a02			 
3a02					; one value on hl get other one back 
3a02			 
3a02 d1					pop de 
3a03			 
3a03					; do the sub 
3a03			;		ex de, hl 
3a03			 
3a03 ed 52				sbc hl,de 
3a05			 
3a05					; save it 
3a05			 
3a05			;		push hl	 
3a05			 
3a05					; 
3a05			 
3a05					; destroy value TOS 
3a05			 
3a05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a05 cd 16 22			call macro_forth_dsp_pop 
3a08				endm 
# End of macro FORTH_DSP_POP
3a08			 
3a08					; TODO push value back onto stack for another op etc 
3a08			 
3a08			;		pop hl 
3a08			 
3a08 cd 67 1f				call forth_push_numhl 
3a0b			.neg_done: 
3a0b			 
3a0b					NEXTW 
3a0b c3 14 23			jp macro_next 
3a0e				endm 
# End of macro NEXTW
3a0e			.DIV: 
3a0e				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3a0e 18				db WORD_SYS_CORE+4             
3a0f 5b 3a			dw .MUL            
3a11 02				db 1 + 1 
3a12 .. 00			db "/",0              
3a14				endm 
# End of macro CWHEAD
3a14			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3a14					if DEBUG_FORTH_WORDS_KEY 
3a14						DMARK "DIV" 
3a14 f5				push af  
3a15 3a 29 3a			ld a, (.dmark)  
3a18 32 6e fe			ld (debug_mark),a  
3a1b 3a 2a 3a			ld a, (.dmark+1)  
3a1e 32 6f fe			ld (debug_mark+1),a  
3a21 3a 2b 3a			ld a, (.dmark+2)  
3a24 32 70 fe			ld (debug_mark+2),a  
3a27 18 03			jr .pastdmark  
3a29 ..			.dmark: db "DIV"  
3a2c f1			.pastdmark: pop af  
3a2d			endm  
# End of macro DMARK
3a2d						CALLMONITOR 
3a2d cd f3 18			call break_point_state  
3a30				endm  
# End of macro CALLMONITOR
3a30					endif 
3a30				; TODO add floating point number detection 
3a30					; v5 FORTH_DSP_VALUE 
3a30					FORTH_DSP 
3a30 cd 24 21			call macro_forth_dsp 
3a33				endm 
# End of macro FORTH_DSP
3a33 7e					ld a,(hl)	; get type of value on TOS 
3a34 fe 02				cp DS_TYPE_INUM  
3a36 28 03				jr z, .div_inum 
3a38			 
3a38				if FORTH_ENABLE_FLOATMATH 
3a38					jr .div_done 
3a38			 
3a38				endif 
3a38					NEXTW 
3a38 c3 14 23			jp macro_next 
3a3b				endm 
# End of macro NEXTW
3a3b			.div_inum: 
3a3b			 
3a3b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a3b cd 5e 21			call macro_dsp_valuehl 
3a3e				endm 
# End of macro FORTH_DSP_VALUEHL
3a3e			 
3a3e e5					push hl    ; to go to bc 
3a3f			 
3a3f					; destroy value TOS 
3a3f			 
3a3f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a3f cd 16 22			call macro_forth_dsp_pop 
3a42				endm 
# End of macro FORTH_DSP_POP
3a42			 
3a42			 
3a42					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a42 cd 5e 21			call macro_dsp_valuehl 
3a45				endm 
# End of macro FORTH_DSP_VALUEHL
3a45			 
3a45					; hl to go to de 
3a45			 
3a45 e5					push hl 
3a46			 
3a46 c1					pop bc 
3a47 d1					pop de		 
3a48			 
3a48			 
3a48					if DEBUG_FORTH_MATHS 
3a48						DMARK "DIV" 
3a48				CALLMONITOR 
3a48					endif 
3a48					; one value on hl but move to a get other one back 
3a48			 
3a48			        
3a48 cd a9 0e			call Div16 
3a4b			 
3a4b			;	push af	 
3a4b e5				push hl 
3a4c c5				push bc 
3a4d			 
3a4d					if DEBUG_FORTH_MATHS 
3a4d						DMARK "DI1" 
3a4d				CALLMONITOR 
3a4d					endif 
3a4d			 
3a4d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a4d cd 16 22			call macro_forth_dsp_pop 
3a50				endm 
# End of macro FORTH_DSP_POP
3a50			 
3a50			 
3a50			 
3a50 e1					pop hl    ; result 
3a51			 
3a51 cd 67 1f				call forth_push_numhl 
3a54			 
3a54 e1					pop hl    ; reminder 
3a55			;		ld h,0 
3a55			;		ld l,d 
3a55			 
3a55 cd 67 1f				call forth_push_numhl 
3a58			.div_done: 
3a58					NEXTW 
3a58 c3 14 23			jp macro_next 
3a5b				endm 
# End of macro NEXTW
3a5b			.MUL: 
3a5b				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3a5b 19				db WORD_SYS_CORE+5             
3a5c a0 3a			dw .MIN            
3a5e 02				db 1 + 1 
3a5f .. 00			db "*",0              
3a61				endm 
# End of macro CWHEAD
3a61			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3a61				; TODO add floating point number detection 
3a61					if DEBUG_FORTH_WORDS_KEY 
3a61						DMARK "MUL" 
3a61 f5				push af  
3a62 3a 76 3a			ld a, (.dmark)  
3a65 32 6e fe			ld (debug_mark),a  
3a68 3a 77 3a			ld a, (.dmark+1)  
3a6b 32 6f fe			ld (debug_mark+1),a  
3a6e 3a 78 3a			ld a, (.dmark+2)  
3a71 32 70 fe			ld (debug_mark+2),a  
3a74 18 03			jr .pastdmark  
3a76 ..			.dmark: db "MUL"  
3a79 f1			.pastdmark: pop af  
3a7a			endm  
# End of macro DMARK
3a7a						CALLMONITOR 
3a7a cd f3 18			call break_point_state  
3a7d				endm  
# End of macro CALLMONITOR
3a7d					endif 
3a7d					FORTH_DSP 
3a7d cd 24 21			call macro_forth_dsp 
3a80				endm 
# End of macro FORTH_DSP
3a80					; v5 FORTH_DSP_VALUE 
3a80 7e					ld a,(hl)	; get type of value on TOS 
3a81 fe 02				cp DS_TYPE_INUM  
3a83 28 03				jr z, .mul_inum 
3a85			 
3a85				if FORTH_ENABLE_FLOATMATH 
3a85					jr .mul_done 
3a85			 
3a85				endif 
3a85			 
3a85					NEXTW 
3a85 c3 14 23			jp macro_next 
3a88				endm 
# End of macro NEXTW
3a88			.mul_inum:	 
3a88			 
3a88					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a88 cd 5e 21			call macro_dsp_valuehl 
3a8b				endm 
# End of macro FORTH_DSP_VALUEHL
3a8b			 
3a8b e5					push hl 
3a8c			 
3a8c					; destroy value TOS 
3a8c			 
3a8c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a8c cd 16 22			call macro_forth_dsp_pop 
3a8f				endm 
# End of macro FORTH_DSP_POP
3a8f			 
3a8f			 
3a8f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a8f cd 5e 21			call macro_dsp_valuehl 
3a92				endm 
# End of macro FORTH_DSP_VALUEHL
3a92			 
3a92					; one value on hl but move to a get other one back 
3a92			 
3a92 7d					ld a, l 
3a93			 
3a93 d1					pop de 
3a94			 
3a94					; do the mull 
3a94			;		ex de, hl 
3a94			 
3a94 cd cf 0e				call Mult16 
3a97					; save it 
3a97			 
3a97			;		push hl	 
3a97			 
3a97					; 
3a97			 
3a97					; destroy value TOS 
3a97			 
3a97					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a97 cd 16 22			call macro_forth_dsp_pop 
3a9a				endm 
# End of macro FORTH_DSP_POP
3a9a			 
3a9a					; TODO push value back onto stack for another op etc 
3a9a			 
3a9a			;		pop hl 
3a9a			 
3a9a cd 67 1f				call forth_push_numhl 
3a9d			 
3a9d			.mul_done: 
3a9d					NEXTW 
3a9d c3 14 23			jp macro_next 
3aa0				endm 
# End of macro NEXTW
3aa0			 
3aa0			 
3aa0			 
3aa0			 
3aa0			.MIN: 
3aa0				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3aa0 49				db WORD_SYS_CORE+53             
3aa1 21 3b			dw .MAX            
3aa3 04				db 3 + 1 
3aa4 .. 00			db "MIN",0              
3aa8				endm 
# End of macro CWHEAD
3aa8			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3aa8					if DEBUG_FORTH_WORDS_KEY 
3aa8						DMARK "MIN" 
3aa8 f5				push af  
3aa9 3a bd 3a			ld a, (.dmark)  
3aac 32 6e fe			ld (debug_mark),a  
3aaf 3a be 3a			ld a, (.dmark+1)  
3ab2 32 6f fe			ld (debug_mark+1),a  
3ab5 3a bf 3a			ld a, (.dmark+2)  
3ab8 32 70 fe			ld (debug_mark+2),a  
3abb 18 03			jr .pastdmark  
3abd ..			.dmark: db "MIN"  
3ac0 f1			.pastdmark: pop af  
3ac1			endm  
# End of macro DMARK
3ac1						CALLMONITOR 
3ac1 cd f3 18			call break_point_state  
3ac4				endm  
# End of macro CALLMONITOR
3ac4					endif 
3ac4					; get u2 
3ac4			 
3ac4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ac4 cd 5e 21			call macro_dsp_valuehl 
3ac7				endm 
# End of macro FORTH_DSP_VALUEHL
3ac7			 
3ac7 e5					push hl   ; u2 
3ac8			 
3ac8					; destroy value TOS 
3ac8			 
3ac8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ac8 cd 16 22			call macro_forth_dsp_pop 
3acb				endm 
# End of macro FORTH_DSP_POP
3acb			 
3acb					; get u1 
3acb			 
3acb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3acb cd 5e 21			call macro_dsp_valuehl 
3ace				endm 
# End of macro FORTH_DSP_VALUEHL
3ace			 
3ace e5					push hl  ; u1 
3acf			 
3acf					; destroy value TOS 
3acf			 
3acf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3acf cd 16 22			call macro_forth_dsp_pop 
3ad2				endm 
# End of macro FORTH_DSP_POP
3ad2			 
3ad2 b7			 or a      ;clear carry flag 
3ad3 e1			  pop hl    ; u1 
3ad4 d1			  pop de    ; u2 
3ad5 e5				push hl   ; saved in case hl is lowest 
3ad6 ed 52		  sbc hl,de 
3ad8 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3ada			 
3ada e1				pop hl 
3adb					if DEBUG_FORTH_WORDS 
3adb						DMARK "MIN" 
3adb f5				push af  
3adc 3a f0 3a			ld a, (.dmark)  
3adf 32 6e fe			ld (debug_mark),a  
3ae2 3a f1 3a			ld a, (.dmark+1)  
3ae5 32 6f fe			ld (debug_mark+1),a  
3ae8 3a f2 3a			ld a, (.dmark+2)  
3aeb 32 70 fe			ld (debug_mark+2),a  
3aee 18 03			jr .pastdmark  
3af0 ..			.dmark: db "MIN"  
3af3 f1			.pastdmark: pop af  
3af4			endm  
# End of macro DMARK
3af4						CALLMONITOR 
3af4 cd f3 18			call break_point_state  
3af7				endm  
# End of macro CALLMONITOR
3af7					endif 
3af7 cd 67 1f				call forth_push_numhl 
3afa			 
3afa				       NEXTW 
3afa c3 14 23			jp macro_next 
3afd				endm 
# End of macro NEXTW
3afd			 
3afd			.mincont:  
3afd c1				pop bc   ; tidy up 
3afe eb				ex de , hl  
3aff					if DEBUG_FORTH_WORDS 
3aff						DMARK "MI1" 
3aff f5				push af  
3b00 3a 14 3b			ld a, (.dmark)  
3b03 32 6e fe			ld (debug_mark),a  
3b06 3a 15 3b			ld a, (.dmark+1)  
3b09 32 6f fe			ld (debug_mark+1),a  
3b0c 3a 16 3b			ld a, (.dmark+2)  
3b0f 32 70 fe			ld (debug_mark+2),a  
3b12 18 03			jr .pastdmark  
3b14 ..			.dmark: db "MI1"  
3b17 f1			.pastdmark: pop af  
3b18			endm  
# End of macro DMARK
3b18						CALLMONITOR 
3b18 cd f3 18			call break_point_state  
3b1b				endm  
# End of macro CALLMONITOR
3b1b					endif 
3b1b cd 67 1f				call forth_push_numhl 
3b1e			 
3b1e				       NEXTW 
3b1e c3 14 23			jp macro_next 
3b21				endm 
# End of macro NEXTW
3b21			.MAX: 
3b21				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3b21 4a				db WORD_SYS_CORE+54             
3b22 a2 3b			dw .RND16            
3b24 04				db 3 + 1 
3b25 .. 00			db "MAX",0              
3b29				endm 
# End of macro CWHEAD
3b29			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3b29					if DEBUG_FORTH_WORDS_KEY 
3b29						DMARK "MAX" 
3b29 f5				push af  
3b2a 3a 3e 3b			ld a, (.dmark)  
3b2d 32 6e fe			ld (debug_mark),a  
3b30 3a 3f 3b			ld a, (.dmark+1)  
3b33 32 6f fe			ld (debug_mark+1),a  
3b36 3a 40 3b			ld a, (.dmark+2)  
3b39 32 70 fe			ld (debug_mark+2),a  
3b3c 18 03			jr .pastdmark  
3b3e ..			.dmark: db "MAX"  
3b41 f1			.pastdmark: pop af  
3b42			endm  
# End of macro DMARK
3b42						CALLMONITOR 
3b42 cd f3 18			call break_point_state  
3b45				endm  
# End of macro CALLMONITOR
3b45					endif 
3b45					; get u2 
3b45			 
3b45					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b45 cd 5e 21			call macro_dsp_valuehl 
3b48				endm 
# End of macro FORTH_DSP_VALUEHL
3b48			 
3b48 e5					push hl   ; u2 
3b49			 
3b49					; destroy value TOS 
3b49			 
3b49					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b49 cd 16 22			call macro_forth_dsp_pop 
3b4c				endm 
# End of macro FORTH_DSP_POP
3b4c			 
3b4c					; get u1 
3b4c			 
3b4c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b4c cd 5e 21			call macro_dsp_valuehl 
3b4f				endm 
# End of macro FORTH_DSP_VALUEHL
3b4f			 
3b4f e5					push hl  ; u1 
3b50			 
3b50					; destroy value TOS 
3b50			 
3b50					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b50 cd 16 22			call macro_forth_dsp_pop 
3b53				endm 
# End of macro FORTH_DSP_POP
3b53			 
3b53 b7			 or a      ;clear carry flag 
3b54 e1			  pop hl    ; u1 
3b55 d1			  pop de    ; u2 
3b56 e5				push hl   ; saved in case hl is lowest 
3b57 ed 52		  sbc hl,de 
3b59 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3b5b			 
3b5b e1				pop hl 
3b5c					if DEBUG_FORTH_WORDS 
3b5c						DMARK "MAX" 
3b5c f5				push af  
3b5d 3a 71 3b			ld a, (.dmark)  
3b60 32 6e fe			ld (debug_mark),a  
3b63 3a 72 3b			ld a, (.dmark+1)  
3b66 32 6f fe			ld (debug_mark+1),a  
3b69 3a 73 3b			ld a, (.dmark+2)  
3b6c 32 70 fe			ld (debug_mark+2),a  
3b6f 18 03			jr .pastdmark  
3b71 ..			.dmark: db "MAX"  
3b74 f1			.pastdmark: pop af  
3b75			endm  
# End of macro DMARK
3b75						CALLMONITOR 
3b75 cd f3 18			call break_point_state  
3b78				endm  
# End of macro CALLMONITOR
3b78					endif 
3b78 cd 67 1f				call forth_push_numhl 
3b7b			 
3b7b				       NEXTW 
3b7b c3 14 23			jp macro_next 
3b7e				endm 
# End of macro NEXTW
3b7e			 
3b7e			.maxcont:  
3b7e c1				pop bc   ; tidy up 
3b7f eb				ex de , hl  
3b80					if DEBUG_FORTH_WORDS 
3b80						DMARK "MA1" 
3b80 f5				push af  
3b81 3a 95 3b			ld a, (.dmark)  
3b84 32 6e fe			ld (debug_mark),a  
3b87 3a 96 3b			ld a, (.dmark+1)  
3b8a 32 6f fe			ld (debug_mark+1),a  
3b8d 3a 97 3b			ld a, (.dmark+2)  
3b90 32 70 fe			ld (debug_mark+2),a  
3b93 18 03			jr .pastdmark  
3b95 ..			.dmark: db "MA1"  
3b98 f1			.pastdmark: pop af  
3b99			endm  
# End of macro DMARK
3b99						CALLMONITOR 
3b99 cd f3 18			call break_point_state  
3b9c				endm  
# End of macro CALLMONITOR
3b9c					endif 
3b9c cd 67 1f				call forth_push_numhl 
3b9f				       NEXTW 
3b9f c3 14 23			jp macro_next 
3ba2				endm 
# End of macro NEXTW
3ba2			 
3ba2			.RND16: 
3ba2				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3ba2 4e				db WORD_SYS_CORE+58             
3ba3 d1 3b			dw .RND8            
3ba5 06				db 5 + 1 
3ba6 .. 00			db "RND16",0              
3bac				endm 
# End of macro CWHEAD
3bac			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3bac					if DEBUG_FORTH_WORDS_KEY 
3bac						DMARK "R16" 
3bac f5				push af  
3bad 3a c1 3b			ld a, (.dmark)  
3bb0 32 6e fe			ld (debug_mark),a  
3bb3 3a c2 3b			ld a, (.dmark+1)  
3bb6 32 6f fe			ld (debug_mark+1),a  
3bb9 3a c3 3b			ld a, (.dmark+2)  
3bbc 32 70 fe			ld (debug_mark+2),a  
3bbf 18 03			jr .pastdmark  
3bc1 ..			.dmark: db "R16"  
3bc4 f1			.pastdmark: pop af  
3bc5			endm  
# End of macro DMARK
3bc5						CALLMONITOR 
3bc5 cd f3 18			call break_point_state  
3bc8				endm  
# End of macro CALLMONITOR
3bc8					endif 
3bc8 cd 73 0e				call prng16  
3bcb cd 67 1f				call forth_push_numhl 
3bce				       NEXTW 
3bce c3 14 23			jp macro_next 
3bd1				endm 
# End of macro NEXTW
3bd1			.RND8: 
3bd1				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3bd1 60				db WORD_SYS_CORE+76             
3bd2 06 3c			dw .RND            
3bd4 05				db 4 + 1 
3bd5 .. 00			db "RND8",0              
3bda				endm 
# End of macro CWHEAD
3bda			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3bda					if DEBUG_FORTH_WORDS_KEY 
3bda						DMARK "RN8" 
3bda f5				push af  
3bdb 3a ef 3b			ld a, (.dmark)  
3bde 32 6e fe			ld (debug_mark),a  
3be1 3a f0 3b			ld a, (.dmark+1)  
3be4 32 6f fe			ld (debug_mark+1),a  
3be7 3a f1 3b			ld a, (.dmark+2)  
3bea 32 70 fe			ld (debug_mark+2),a  
3bed 18 03			jr .pastdmark  
3bef ..			.dmark: db "RN8"  
3bf2 f1			.pastdmark: pop af  
3bf3			endm  
# End of macro DMARK
3bf3						CALLMONITOR 
3bf3 cd f3 18			call break_point_state  
3bf6				endm  
# End of macro CALLMONITOR
3bf6					endif 
3bf6 2a af fb				ld hl,(xrandc) 
3bf9 23					inc hl 
3bfa cd 8d 0e				call xrnd 
3bfd 6f					ld l,a	 
3bfe 26 00				ld h,0 
3c00 cd 67 1f				call forth_push_numhl 
3c03				       NEXTW 
3c03 c3 14 23			jp macro_next 
3c06				endm 
# End of macro NEXTW
3c06			.RND: 
3c06				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3c06 60				db WORD_SYS_CORE+76             
3c07 0c 3d			dw .ENDMATHS            
3c09 04				db 3 + 1 
3c0a .. 00			db "RND",0              
3c0e				endm 
# End of macro CWHEAD
3c0e			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3c0e			 
3c0e					if DEBUG_FORTH_WORDS_KEY 
3c0e						DMARK "RND" 
3c0e f5				push af  
3c0f 3a 23 3c			ld a, (.dmark)  
3c12 32 6e fe			ld (debug_mark),a  
3c15 3a 24 3c			ld a, (.dmark+1)  
3c18 32 6f fe			ld (debug_mark+1),a  
3c1b 3a 25 3c			ld a, (.dmark+2)  
3c1e 32 70 fe			ld (debug_mark+2),a  
3c21 18 03			jr .pastdmark  
3c23 ..			.dmark: db "RND"  
3c26 f1			.pastdmark: pop af  
3c27			endm  
# End of macro DMARK
3c27						CALLMONITOR 
3c27 cd f3 18			call break_point_state  
3c2a				endm  
# End of macro CALLMONITOR
3c2a					endif 
3c2a					 
3c2a					FORTH_DSP_VALUEHL    ; upper range 
3c2a cd 5e 21			call macro_dsp_valuehl 
3c2d				endm 
# End of macro FORTH_DSP_VALUEHL
3c2d			 
3c2d 22 b3 fb				ld (LFSRSeed), hl	 
3c30			 
3c30					if DEBUG_FORTH_WORDS 
3c30						DMARK "RN1" 
3c30 f5				push af  
3c31 3a 45 3c			ld a, (.dmark)  
3c34 32 6e fe			ld (debug_mark),a  
3c37 3a 46 3c			ld a, (.dmark+1)  
3c3a 32 6f fe			ld (debug_mark+1),a  
3c3d 3a 47 3c			ld a, (.dmark+2)  
3c40 32 70 fe			ld (debug_mark+2),a  
3c43 18 03			jr .pastdmark  
3c45 ..			.dmark: db "RN1"  
3c48 f1			.pastdmark: pop af  
3c49			endm  
# End of macro DMARK
3c49						CALLMONITOR 
3c49 cd f3 18			call break_point_state  
3c4c				endm  
# End of macro CALLMONITOR
3c4c					endif 
3c4c					FORTH_DSP_POP 
3c4c cd 16 22			call macro_forth_dsp_pop 
3c4f				endm 
# End of macro FORTH_DSP_POP
3c4f			 
3c4f					FORTH_DSP_VALUEHL    ; low range 
3c4f cd 5e 21			call macro_dsp_valuehl 
3c52				endm 
# End of macro FORTH_DSP_VALUEHL
3c52			 
3c52					if DEBUG_FORTH_WORDS 
3c52						DMARK "RN2" 
3c52 f5				push af  
3c53 3a 67 3c			ld a, (.dmark)  
3c56 32 6e fe			ld (debug_mark),a  
3c59 3a 68 3c			ld a, (.dmark+1)  
3c5c 32 6f fe			ld (debug_mark+1),a  
3c5f 3a 69 3c			ld a, (.dmark+2)  
3c62 32 70 fe			ld (debug_mark+2),a  
3c65 18 03			jr .pastdmark  
3c67 ..			.dmark: db "RN2"  
3c6a f1			.pastdmark: pop af  
3c6b			endm  
# End of macro DMARK
3c6b						CALLMONITOR 
3c6b cd f3 18			call break_point_state  
3c6e				endm  
# End of macro CALLMONITOR
3c6e					endif 
3c6e 22 b5 fb				ld (LFSRSeed+2), hl 
3c71			 
3c71					FORTH_DSP_POP 
3c71 cd 16 22			call macro_forth_dsp_pop 
3c74				endm 
# End of macro FORTH_DSP_POP
3c74			 
3c74 e5					push hl 
3c75			 
3c75 e1			.inrange:	pop hl 
3c76 cd 73 0e				call prng16  
3c79					if DEBUG_FORTH_WORDS 
3c79						DMARK "RN3" 
3c79 f5				push af  
3c7a 3a 8e 3c			ld a, (.dmark)  
3c7d 32 6e fe			ld (debug_mark),a  
3c80 3a 8f 3c			ld a, (.dmark+1)  
3c83 32 6f fe			ld (debug_mark+1),a  
3c86 3a 90 3c			ld a, (.dmark+2)  
3c89 32 70 fe			ld (debug_mark+2),a  
3c8c 18 03			jr .pastdmark  
3c8e ..			.dmark: db "RN3"  
3c91 f1			.pastdmark: pop af  
3c92			endm  
# End of macro DMARK
3c92						CALLMONITOR 
3c92 cd f3 18			call break_point_state  
3c95				endm  
# End of macro CALLMONITOR
3c95					endif 
3c95					 
3c95					; if the range is 8bit knock out the high byte 
3c95			 
3c95 ed 5b b3 fb			ld de, (LFSRSeed)     ; check high level 
3c99			 
3c99 3e 00				ld a, 0 
3c9b ba					cp d  
3c9c 20 1e				jr nz, .hirange 
3c9e 26 00				ld h, 0   ; knock it down to 8bit 
3ca0			 
3ca0					if DEBUG_FORTH_WORDS 
3ca0						DMARK "RNk" 
3ca0 f5				push af  
3ca1 3a b5 3c			ld a, (.dmark)  
3ca4 32 6e fe			ld (debug_mark),a  
3ca7 3a b6 3c			ld a, (.dmark+1)  
3caa 32 6f fe			ld (debug_mark+1),a  
3cad 3a b7 3c			ld a, (.dmark+2)  
3cb0 32 70 fe			ld (debug_mark+2),a  
3cb3 18 03			jr .pastdmark  
3cb5 ..			.dmark: db "RNk"  
3cb8 f1			.pastdmark: pop af  
3cb9			endm  
# End of macro DMARK
3cb9						CALLMONITOR 
3cb9 cd f3 18			call break_point_state  
3cbc				endm  
# End of macro CALLMONITOR
3cbc					endif 
3cbc			.hirange:   
3cbc e5					push hl  
3cbd b7					or a  
3cbe ed 52		                sbc hl, de 
3cc0			 
3cc0					;call cmp16 
3cc0			 
3cc0 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3cc2 e1					pop hl 
3cc3 e5					push hl 
3cc4			 
3cc4					if DEBUG_FORTH_WORDS 
3cc4						DMARK "RN4" 
3cc4 f5				push af  
3cc5 3a d9 3c			ld a, (.dmark)  
3cc8 32 6e fe			ld (debug_mark),a  
3ccb 3a da 3c			ld a, (.dmark+1)  
3cce 32 6f fe			ld (debug_mark+1),a  
3cd1 3a db 3c			ld a, (.dmark+2)  
3cd4 32 70 fe			ld (debug_mark+2),a  
3cd7 18 03			jr .pastdmark  
3cd9 ..			.dmark: db "RN4"  
3cdc f1			.pastdmark: pop af  
3cdd			endm  
# End of macro DMARK
3cdd						CALLMONITOR 
3cdd cd f3 18			call break_point_state  
3ce0				endm  
# End of macro CALLMONITOR
3ce0					endif 
3ce0 ed 5b b5 fb			ld de, (LFSRSeed+2)   ; check low range 
3ce4					;call cmp16 
3ce4				 
3ce4 b7					or a  
3ce5 ed 52		                sbc hl, de 
3ce7 38 8c				jr c, .inrange 
3ce9			 
3ce9 e1					pop hl 
3cea					 
3cea					if DEBUG_FORTH_WORDS 
3cea						DMARK "RNd" 
3cea f5				push af  
3ceb 3a ff 3c			ld a, (.dmark)  
3cee 32 6e fe			ld (debug_mark),a  
3cf1 3a 00 3d			ld a, (.dmark+1)  
3cf4 32 6f fe			ld (debug_mark+1),a  
3cf7 3a 01 3d			ld a, (.dmark+2)  
3cfa 32 70 fe			ld (debug_mark+2),a  
3cfd 18 03			jr .pastdmark  
3cff ..			.dmark: db "RNd"  
3d02 f1			.pastdmark: pop af  
3d03			endm  
# End of macro DMARK
3d03						CALLMONITOR 
3d03 cd f3 18			call break_point_state  
3d06				endm  
# End of macro CALLMONITOR
3d06					endif 
3d06			 
3d06			 
3d06 cd 67 1f				call forth_push_numhl 
3d09				       NEXTW 
3d09 c3 14 23			jp macro_next 
3d0c				endm 
# End of macro NEXTW
3d0c			 
3d0c			.ENDMATHS: 
3d0c			 
3d0c			; eof 
3d0c			 
# End of file forth_words_maths.asm
3d0c			include "forth_words_display.asm" 
3d0c			 
3d0c			; | ## Display Words 
3d0c			 
3d0c			.INFO: 
3d0c			 
3d0c				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3d0c 62				db WORD_SYS_CORE+78             
3d0d 29 3d			dw .ATP            
3d0f 05				db 4 + 1 
3d10 .. 00			db "INFO",0              
3d15				endm 
# End of macro CWHEAD
3d15			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3d15					FORTH_DSP_VALUEHL 
3d15 cd 5e 21			call macro_dsp_valuehl 
3d18				endm 
# End of macro FORTH_DSP_VALUEHL
3d18			 
3d18					FORTH_DSP_POP 
3d18 cd 16 22			call macro_forth_dsp_pop 
3d1b				endm 
# End of macro FORTH_DSP_POP
3d1b			 
3d1b e5					push hl 
3d1c			 
3d1c					FORTH_DSP_VALUEHL 
3d1c cd 5e 21			call macro_dsp_valuehl 
3d1f				endm 
# End of macro FORTH_DSP_VALUEHL
3d1f			 
3d1f					FORTH_DSP_POP 
3d1f cd 16 22			call macro_forth_dsp_pop 
3d22				endm 
# End of macro FORTH_DSP_POP
3d22			 
3d22 d1					pop de 
3d23			 
3d23 cd a9 0c				call info_panel 
3d26			 
3d26			 
3d26					NEXTW 
3d26 c3 14 23			jp macro_next 
3d29				endm 
# End of macro NEXTW
3d29			.ATP: 
3d29				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3d29 62				db WORD_SYS_CORE+78             
3d2a a0 3d			dw .FB            
3d2c 04				db 3 + 1 
3d2d .. 00			db "AT?",0              
3d31				endm 
# End of macro CWHEAD
3d31			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3d31					if DEBUG_FORTH_WORDS_KEY 
3d31						DMARK "AT?" 
3d31 f5				push af  
3d32 3a 46 3d			ld a, (.dmark)  
3d35 32 6e fe			ld (debug_mark),a  
3d38 3a 47 3d			ld a, (.dmark+1)  
3d3b 32 6f fe			ld (debug_mark+1),a  
3d3e 3a 48 3d			ld a, (.dmark+2)  
3d41 32 70 fe			ld (debug_mark+2),a  
3d44 18 03			jr .pastdmark  
3d46 ..			.dmark: db "AT?"  
3d49 f1			.pastdmark: pop af  
3d4a			endm  
# End of macro DMARK
3d4a						CALLMONITOR 
3d4a cd f3 18			call break_point_state  
3d4d				endm  
# End of macro CALLMONITOR
3d4d					endif 
3d4d 3a 65 fa				ld a, (f_cursor_ptr) 
3d50			 
3d50			if DEBUG_FORTH_WORDS 
3d50				DMARK "AT?" 
3d50 f5				push af  
3d51 3a 65 3d			ld a, (.dmark)  
3d54 32 6e fe			ld (debug_mark),a  
3d57 3a 66 3d			ld a, (.dmark+1)  
3d5a 32 6f fe			ld (debug_mark+1),a  
3d5d 3a 67 3d			ld a, (.dmark+2)  
3d60 32 70 fe			ld (debug_mark+2),a  
3d63 18 03			jr .pastdmark  
3d65 ..			.dmark: db "AT?"  
3d68 f1			.pastdmark: pop af  
3d69			endm  
# End of macro DMARK
3d69				CALLMONITOR 
3d69 cd f3 18			call break_point_state  
3d6c				endm  
# End of macro CALLMONITOR
3d6c			endif	 
3d6c					; count the number of rows 
3d6c			 
3d6c 06 00				ld b, 0 
3d6e 4f			.atpr:		ld c, a    ; save in case we go below zero 
3d6f d6 28				sub display_cols 
3d71 f2 77 3d				jp p, .atprunder 
3d74 04					inc b 
3d75 18 f7				jr .atpr 
3d77			.atprunder:	 
3d77			if DEBUG_FORTH_WORDS 
3d77				DMARK "A?2" 
3d77 f5				push af  
3d78 3a 8c 3d			ld a, (.dmark)  
3d7b 32 6e fe			ld (debug_mark),a  
3d7e 3a 8d 3d			ld a, (.dmark+1)  
3d81 32 6f fe			ld (debug_mark+1),a  
3d84 3a 8e 3d			ld a, (.dmark+2)  
3d87 32 70 fe			ld (debug_mark+2),a  
3d8a 18 03			jr .pastdmark  
3d8c ..			.dmark: db "A?2"  
3d8f f1			.pastdmark: pop af  
3d90			endm  
# End of macro DMARK
3d90				CALLMONITOR 
3d90 cd f3 18			call break_point_state  
3d93				endm  
# End of macro CALLMONITOR
3d93			endif	 
3d93 26 00				ld h, 0 
3d95 69					ld l, c 
3d96 cd 67 1f				call forth_push_numhl 
3d99 68					ld l, b  
3d9a cd 67 1f				call forth_push_numhl 
3d9d			 
3d9d			 
3d9d				NEXTW 
3d9d c3 14 23			jp macro_next 
3da0				endm 
# End of macro NEXTW
3da0			 
3da0			.FB: 
3da0				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3da0 1b				db WORD_SYS_CORE+7             
3da1 ee 3d			dw .EMIT            
3da3 03				db 2 + 1 
3da4 .. 00			db "FB",0              
3da7				endm 
# End of macro CWHEAD
3da7			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3da7			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3da7			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3da7			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3da7					if DEBUG_FORTH_WORDS_KEY 
3da7						DMARK "FB." 
3da7 f5				push af  
3da8 3a bc 3d			ld a, (.dmark)  
3dab 32 6e fe			ld (debug_mark),a  
3dae 3a bd 3d			ld a, (.dmark+1)  
3db1 32 6f fe			ld (debug_mark+1),a  
3db4 3a be 3d			ld a, (.dmark+2)  
3db7 32 70 fe			ld (debug_mark+2),a  
3dba 18 03			jr .pastdmark  
3dbc ..			.dmark: db "FB."  
3dbf f1			.pastdmark: pop af  
3dc0			endm  
# End of macro DMARK
3dc0						CALLMONITOR 
3dc0 cd f3 18			call break_point_state  
3dc3				endm  
# End of macro CALLMONITOR
3dc3					endif 
3dc3			 
3dc3					FORTH_DSP_VALUEHL 
3dc3 cd 5e 21			call macro_dsp_valuehl 
3dc6				endm 
# End of macro FORTH_DSP_VALUEHL
3dc6			 
3dc6 7d					ld a, l 
3dc7 fe 01				cp 1 
3dc9 20 05				jr nz, .fbn1 
3dcb 21 13 fd				ld hl, display_fb1 
3dce 18 15				jr .fbset 
3dd0 fe 02		.fbn1:		cp 2 
3dd2 20 05				jr nz, .fbn2 
3dd4 21 d1 fb				ld hl, display_fb2 
3dd7 18 0c				jr .fbset 
3dd9 fe 03		.fbn2:		cp 3 
3ddb 20 05				jr nz, .fbn3 
3ddd 21 72 fc				ld hl, display_fb3 
3de0 18 03				jr .fbset 
3de2			.fbn3:		 ; if invalid number select first 
3de2 21 13 fd				ld hl, display_fb1 
3de5 22 cf fb		.fbset:		ld (display_fb_active), hl 
3de8			 
3de8					FORTH_DSP_POP 
3de8 cd 16 22			call macro_forth_dsp_pop 
3deb				endm 
# End of macro FORTH_DSP_POP
3deb			 
3deb					NEXTW 
3deb c3 14 23			jp macro_next 
3dee				endm 
# End of macro NEXTW
3dee			 
3dee			 
3dee			.EMIT: 
3dee				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3dee 1b				db WORD_SYS_CORE+7             
3def 3f 3e			dw .DOTH            
3df1 05				db 4 + 1 
3df2 .. 00			db "EMIT",0              
3df7				endm 
# End of macro CWHEAD
3df7			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3df7					; get value off TOS and display it 
3df7			 
3df7					if DEBUG_FORTH_WORDS_KEY 
3df7						DMARK "EMT" 
3df7 f5				push af  
3df8 3a 0c 3e			ld a, (.dmark)  
3dfb 32 6e fe			ld (debug_mark),a  
3dfe 3a 0d 3e			ld a, (.dmark+1)  
3e01 32 6f fe			ld (debug_mark+1),a  
3e04 3a 0e 3e			ld a, (.dmark+2)  
3e07 32 70 fe			ld (debug_mark+2),a  
3e0a 18 03			jr .pastdmark  
3e0c ..			.dmark: db "EMT"  
3e0f f1			.pastdmark: pop af  
3e10			endm  
# End of macro DMARK
3e10						CALLMONITOR 
3e10 cd f3 18			call break_point_state  
3e13				endm  
# End of macro CALLMONITOR
3e13					endif 
3e13			 
3e13					FORTH_DSP_VALUEHL 
3e13 cd 5e 21			call macro_dsp_valuehl 
3e16				endm 
# End of macro FORTH_DSP_VALUEHL
3e16			 
3e16 7d					ld a,l 
3e17			 
3e17					; TODO write to display 
3e17			 
3e17 32 c6 f3				ld (os_input), a 
3e1a 3e 00				ld a, 0 
3e1c 32 c7 f3				ld (os_input+1), a 
3e1f					 
3e1f 3a 65 fa				ld a, (f_cursor_ptr) 
3e22 11 c6 f3				ld de, os_input 
3e25 cd 2b 0d				call str_at_display 
3e28			 
3e28			 
3e28 3a 43 fa				ld a,(cli_autodisplay) 
3e2b fe 00				cp 0 
3e2d 28 03				jr z, .enoupdate 
3e2f cd 3b 0d						call update_display 
3e32					.enoupdate: 
3e32			 
3e32 3a 65 fa				ld a, (f_cursor_ptr) 
3e35 3c					inc a 
3e36 32 65 fa				ld (f_cursor_ptr), a   ; save new pos 
3e39			 
3e39			 
3e39					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e39 cd 16 22			call macro_forth_dsp_pop 
3e3c				endm 
# End of macro FORTH_DSP_POP
3e3c			  
3e3c			 
3e3c					NEXTW 
3e3c c3 14 23			jp macro_next 
3e3f				endm 
# End of macro NEXTW
3e3f			.DOTH: 
3e3f				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3e3f 1c				db WORD_SYS_CORE+8             
3e40 6f 3e			dw .DOTF            
3e42 03				db 2 + 1 
3e43 .. 00			db ".-",0              
3e46				endm 
# End of macro CWHEAD
3e46			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3e46					; get value off TOS and display it 
3e46					if DEBUG_FORTH_WORDS_KEY 
3e46						DMARK "DTD" 
3e46 f5				push af  
3e47 3a 5b 3e			ld a, (.dmark)  
3e4a 32 6e fe			ld (debug_mark),a  
3e4d 3a 5c 3e			ld a, (.dmark+1)  
3e50 32 6f fe			ld (debug_mark+1),a  
3e53 3a 5d 3e			ld a, (.dmark+2)  
3e56 32 70 fe			ld (debug_mark+2),a  
3e59 18 03			jr .pastdmark  
3e5b ..			.dmark: db "DTD"  
3e5e f1			.pastdmark: pop af  
3e5f			endm  
# End of macro DMARK
3e5f						CALLMONITOR 
3e5f cd f3 18			call break_point_state  
3e62				endm  
# End of macro CALLMONITOR
3e62					endif 
3e62 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3e64 3e 00			ld a, 0 
3e66 32 44 fa			ld (cli_mvdot), a 
3e69 c3 c6 3e			jp .dotgo 
3e6c				NEXTW 
3e6c c3 14 23			jp macro_next 
3e6f				endm 
# End of macro NEXTW
3e6f			.DOTF: 
3e6f				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3e6f 1c				db WORD_SYS_CORE+8             
3e70 9d 3e			dw .DOT            
3e72 03				db 2 + 1 
3e73 .. 00			db ".>",0              
3e76				endm 
# End of macro CWHEAD
3e76			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3e76					; get value off TOS and display it 
3e76			        ; TODO BUG adds extra spaces 
3e76			        ; TODO BUG handle numerics? 
3e76					if DEBUG_FORTH_WORDS_KEY 
3e76						DMARK "DTC" 
3e76 f5				push af  
3e77 3a 8b 3e			ld a, (.dmark)  
3e7a 32 6e fe			ld (debug_mark),a  
3e7d 3a 8c 3e			ld a, (.dmark+1)  
3e80 32 6f fe			ld (debug_mark+1),a  
3e83 3a 8d 3e			ld a, (.dmark+2)  
3e86 32 70 fe			ld (debug_mark+2),a  
3e89 18 03			jr .pastdmark  
3e8b ..			.dmark: db "DTC"  
3e8e f1			.pastdmark: pop af  
3e8f			endm  
# End of macro DMARK
3e8f						CALLMONITOR 
3e8f cd f3 18			call break_point_state  
3e92				endm  
# End of macro CALLMONITOR
3e92					endif 
3e92 3e 01			ld a, 1 
3e94 32 44 fa			ld (cli_mvdot), a 
3e97 c3 c6 3e			jp .dotgo 
3e9a				NEXTW 
3e9a c3 14 23			jp macro_next 
3e9d				endm 
# End of macro NEXTW
3e9d			 
3e9d			.DOT: 
3e9d				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3e9d 1c				db WORD_SYS_CORE+8             
3e9e 79 40			dw .CLS            
3ea0 02				db 1 + 1 
3ea1 .. 00			db ".",0              
3ea3				endm 
# End of macro CWHEAD
3ea3			        ; | . ( u -- ) Display TOS | DONE 
3ea3					; get value off TOS and display it 
3ea3			 
3ea3					if DEBUG_FORTH_WORDS_KEY 
3ea3						DMARK "DOT" 
3ea3 f5				push af  
3ea4 3a b8 3e			ld a, (.dmark)  
3ea7 32 6e fe			ld (debug_mark),a  
3eaa 3a b9 3e			ld a, (.dmark+1)  
3ead 32 6f fe			ld (debug_mark+1),a  
3eb0 3a ba 3e			ld a, (.dmark+2)  
3eb3 32 70 fe			ld (debug_mark+2),a  
3eb6 18 03			jr .pastdmark  
3eb8 ..			.dmark: db "DOT"  
3ebb f1			.pastdmark: pop af  
3ebc			endm  
# End of macro DMARK
3ebc						CALLMONITOR 
3ebc cd f3 18			call break_point_state  
3ebf				endm  
# End of macro CALLMONITOR
3ebf					endif 
3ebf 3e 00			ld a, 0 
3ec1 32 44 fa			ld (cli_mvdot), a 
3ec4 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3ec6				 
3ec6			 
3ec6			.dotgo: 
3ec6			 
3ec6			; move up type to on stack for parserv5 
3ec6					FORTH_DSP 
3ec6 cd 24 21			call macro_forth_dsp 
3ec9				endm 
# End of macro FORTH_DSP
3ec9				;FORTH_DSP_VALUE  
3ec9			 
3ec9			if DEBUG_FORTH_DOT 
3ec9				DMARK "DOT" 
3ec9 f5				push af  
3eca 3a de 3e			ld a, (.dmark)  
3ecd 32 6e fe			ld (debug_mark),a  
3ed0 3a df 3e			ld a, (.dmark+1)  
3ed3 32 6f fe			ld (debug_mark+1),a  
3ed6 3a e0 3e			ld a, (.dmark+2)  
3ed9 32 70 fe			ld (debug_mark+2),a  
3edc 18 03			jr .pastdmark  
3ede ..			.dmark: db "DOT"  
3ee1 f1			.pastdmark: pop af  
3ee2			endm  
# End of macro DMARK
3ee2				CALLMONITOR 
3ee2 cd f3 18			call break_point_state  
3ee5				endm  
# End of macro CALLMONITOR
3ee5			endif	 
3ee5			;		.print: 
3ee5			 
3ee5 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3ee6 23				inc hl   ; position to the actual value 
3ee7 fe 01			cp DS_TYPE_STR 
3ee9 20 06			jr nz, .dotnum1  
3eeb			 
3eeb			; display string 
3eeb				FORTH_DSP_VALUE  
3eeb cd 47 21			call macro_forth_dsp_value 
3eee				endm 
# End of macro FORTH_DSP_VALUE
3eee eb				ex de,hl 
3eef 18 49			jr .dotwrite 
3ef1			 
3ef1			.dotnum1: 
3ef1 fe 02			cp DS_TYPE_INUM 
3ef3 20 44			jr nz, .dotflot 
3ef5			 
3ef5			 
3ef5			; display number 
3ef5			 
3ef5			;	push hl 
3ef5			;	call clear_display 
3ef5			;	pop hl 
3ef5			 
3ef5 5e				ld e, (hl) 
3ef6 23				inc hl 
3ef7 56				ld d, (hl) 
3ef8 21 c8 f1			ld hl, scratch 
3efb			if DEBUG_FORTH_DOT 
3efb				DMARK "DT1" 
3efb f5				push af  
3efc 3a 10 3f			ld a, (.dmark)  
3eff 32 6e fe			ld (debug_mark),a  
3f02 3a 11 3f			ld a, (.dmark+1)  
3f05 32 6f fe			ld (debug_mark+1),a  
3f08 3a 12 3f			ld a, (.dmark+2)  
3f0b 32 70 fe			ld (debug_mark+2),a  
3f0e 18 03			jr .pastdmark  
3f10 ..			.dmark: db "DT1"  
3f13 f1			.pastdmark: pop af  
3f14			endm  
# End of macro DMARK
3f14				CALLMONITOR 
3f14 cd f3 18			call break_point_state  
3f17				endm  
# End of macro CALLMONITOR
3f17			endif	 
3f17			 
3f17 cd 59 13			call uitoa_16 
3f1a eb				ex de,hl 
3f1b			 
3f1b			if DEBUG_FORTH_DOT 
3f1b				DMARK "DT2" 
3f1b f5				push af  
3f1c 3a 30 3f			ld a, (.dmark)  
3f1f 32 6e fe			ld (debug_mark),a  
3f22 3a 31 3f			ld a, (.dmark+1)  
3f25 32 6f fe			ld (debug_mark+1),a  
3f28 3a 32 3f			ld a, (.dmark+2)  
3f2b 32 70 fe			ld (debug_mark+2),a  
3f2e 18 03			jr .pastdmark  
3f30 ..			.dmark: db "DT2"  
3f33 f1			.pastdmark: pop af  
3f34			endm  
# End of macro DMARK
3f34				CALLMONITOR 
3f34 cd f3 18			call break_point_state  
3f37				endm  
# End of macro CALLMONITOR
3f37			endif	 
3f37			 
3f37			;	ld de, os_word_scratch 
3f37 18 01			jr .dotwrite 
3f39			 
3f39 00			.dotflot:   nop 
3f3a			; TODO print floating point number 
3f3a			 
3f3a			.dotwrite:		 
3f3a			 
3f3a					; if c is set then set all '-' to spaces 
3f3a					; need to also take into account .>  
3f3a			 
3f3a 3e 01				ld a, 1 
3f3c b9					cp c 
3f3d 20 67				jr nz, .nodashswap 
3f3f			 
3f3f					; DE has the string to write, working with HL 
3f3f			 
3f3f 06 ff				ld b, 255 
3f41 d5					push de 
3f42 e1					pop hl 
3f43			 
3f43			if DEBUG_FORTH_DOT 
3f43				DMARK "DT-" 
3f43 f5				push af  
3f44 3a 58 3f			ld a, (.dmark)  
3f47 32 6e fe			ld (debug_mark),a  
3f4a 3a 59 3f			ld a, (.dmark+1)  
3f4d 32 6f fe			ld (debug_mark+1),a  
3f50 3a 5a 3f			ld a, (.dmark+2)  
3f53 32 70 fe			ld (debug_mark+2),a  
3f56 18 03			jr .pastdmark  
3f58 ..			.dmark: db "DT-"  
3f5b f1			.pastdmark: pop af  
3f5c			endm  
# End of macro DMARK
3f5c				CALLMONITOR 
3f5c cd f3 18			call break_point_state  
3f5f				endm  
# End of macro CALLMONITOR
3f5f			endif	 
3f5f 7e			.dashscan:	ld a, (hl) 
3f60 fe 00				cp 0 
3f62 28 42				jr z, .nodashswap 
3f64 fe 2d				cp '-' 
3f66 20 03				jr nz, .dashskip 
3f68 3e 20				ld a, ' ' 
3f6a 77					ld (hl), a 
3f6b 23			.dashskip:	inc hl 
3f6c			if DEBUG_FORTH_DOT 
3f6c				DMARK "D-2" 
3f6c f5				push af  
3f6d 3a 81 3f			ld a, (.dmark)  
3f70 32 6e fe			ld (debug_mark),a  
3f73 3a 82 3f			ld a, (.dmark+1)  
3f76 32 6f fe			ld (debug_mark+1),a  
3f79 3a 83 3f			ld a, (.dmark+2)  
3f7c 32 70 fe			ld (debug_mark+2),a  
3f7f 18 03			jr .pastdmark  
3f81 ..			.dmark: db "D-2"  
3f84 f1			.pastdmark: pop af  
3f85			endm  
# End of macro DMARK
3f85				CALLMONITOR 
3f85 cd f3 18			call break_point_state  
3f88				endm  
# End of macro CALLMONITOR
3f88			endif	 
3f88 10 d5				djnz .dashscan 
3f8a			 
3f8a			if DEBUG_FORTH_DOT 
3f8a				DMARK "D-1" 
3f8a f5				push af  
3f8b 3a 9f 3f			ld a, (.dmark)  
3f8e 32 6e fe			ld (debug_mark),a  
3f91 3a a0 3f			ld a, (.dmark+1)  
3f94 32 6f fe			ld (debug_mark+1),a  
3f97 3a a1 3f			ld a, (.dmark+2)  
3f9a 32 70 fe			ld (debug_mark+2),a  
3f9d 18 03			jr .pastdmark  
3f9f ..			.dmark: db "D-1"  
3fa2 f1			.pastdmark: pop af  
3fa3			endm  
# End of macro DMARK
3fa3				CALLMONITOR 
3fa3 cd f3 18			call break_point_state  
3fa6				endm  
# End of macro CALLMONITOR
3fa6			endif	 
3fa6			 
3fa6			.nodashswap: 
3fa6			 
3fa6			if DEBUG_FORTH_DOT 
3fa6				DMARK "D-o" 
3fa6 f5				push af  
3fa7 3a bb 3f			ld a, (.dmark)  
3faa 32 6e fe			ld (debug_mark),a  
3fad 3a bc 3f			ld a, (.dmark+1)  
3fb0 32 6f fe			ld (debug_mark+1),a  
3fb3 3a bd 3f			ld a, (.dmark+2)  
3fb6 32 70 fe			ld (debug_mark+2),a  
3fb9 18 03			jr .pastdmark  
3fbb ..			.dmark: db "D-o"  
3fbe f1			.pastdmark: pop af  
3fbf			endm  
# End of macro DMARK
3fbf				CALLMONITOR 
3fbf cd f3 18			call break_point_state  
3fc2				endm  
# End of macro CALLMONITOR
3fc2			endif	 
3fc2			 
3fc2 d5					push de   ; save string start in case we need to advance print 
3fc3			 
3fc3 3a 65 fa				ld a, (f_cursor_ptr) 
3fc6 cd 2b 0d				call str_at_display 
3fc9 3a 43 fa				ld a,(cli_autodisplay) 
3fcc fe 00				cp 0 
3fce 28 03				jr z, .noupdate 
3fd0 cd 3b 0d						call update_display 
3fd3					.noupdate: 
3fd3			 
3fd3			 
3fd3					; see if we need to advance the print position 
3fd3			 
3fd3 e1					pop hl   ; get back string 
3fd4			;		ex de,hl 
3fd4			 
3fd4 3a 44 fa				ld a, (cli_mvdot) 
3fd7			if DEBUG_FORTH_DOT 
3fd7			;		ld e,a 
3fd7				DMARK "D>1" 
3fd7 f5				push af  
3fd8 3a ec 3f			ld a, (.dmark)  
3fdb 32 6e fe			ld (debug_mark),a  
3fde 3a ed 3f			ld a, (.dmark+1)  
3fe1 32 6f fe			ld (debug_mark+1),a  
3fe4 3a ee 3f			ld a, (.dmark+2)  
3fe7 32 70 fe			ld (debug_mark+2),a  
3fea 18 03			jr .pastdmark  
3fec ..			.dmark: db "D>1"  
3fef f1			.pastdmark: pop af  
3ff0			endm  
# End of macro DMARK
3ff0				CALLMONITOR 
3ff0 cd f3 18			call break_point_state  
3ff3				endm  
# End of macro CALLMONITOR
3ff3			endif	 
3ff3 fe 00				cp 0 
3ff5 28 44				jr z, .noadv 
3ff7					; yes, lets advance the print position 
3ff7 3e 00				ld a, 0 
3ff9 cd b5 13				call strlent 
3ffc			if DEBUG_FORTH_DOT 
3ffc				DMARK "D-?" 
3ffc f5				push af  
3ffd 3a 11 40			ld a, (.dmark)  
4000 32 6e fe			ld (debug_mark),a  
4003 3a 12 40			ld a, (.dmark+1)  
4006 32 6f fe			ld (debug_mark+1),a  
4009 3a 13 40			ld a, (.dmark+2)  
400c 32 70 fe			ld (debug_mark+2),a  
400f 18 03			jr .pastdmark  
4011 ..			.dmark: db "D-?"  
4014 f1			.pastdmark: pop af  
4015			endm  
# End of macro DMARK
4015				CALLMONITOR 
4015 cd f3 18			call break_point_state  
4018				endm  
# End of macro CALLMONITOR
4018			endif	 
4018 3a 65 fa				ld a, (f_cursor_ptr) 
401b 85					add a,l 
401c					;call addatohl 
401c					;ld a, l 
401c 32 65 fa				ld (f_cursor_ptr), a   ; save new pos 
401f			 
401f			if DEBUG_FORTH_DOT 
401f				DMARK "D->" 
401f f5				push af  
4020 3a 34 40			ld a, (.dmark)  
4023 32 6e fe			ld (debug_mark),a  
4026 3a 35 40			ld a, (.dmark+1)  
4029 32 6f fe			ld (debug_mark+1),a  
402c 3a 36 40			ld a, (.dmark+2)  
402f 32 70 fe			ld (debug_mark+2),a  
4032 18 03			jr .pastdmark  
4034 ..			.dmark: db "D->"  
4037 f1			.pastdmark: pop af  
4038			endm  
# End of macro DMARK
4038				CALLMONITOR 
4038 cd f3 18			call break_point_state  
403b				endm  
# End of macro CALLMONITOR
403b			endif	 
403b			 
403b			.noadv:	 
403b			 
403b					if DEBUG_FORTH_DOT_WAIT 
403b							call next_page_prompt 
403b					endif	 
403b			; TODO this pop off the stack causes a crash. i dont know why 
403b			 
403b			 
403b			if DEBUG_FORTH_DOT 
403b				DMARK "DTh" 
403b f5				push af  
403c 3a 50 40			ld a, (.dmark)  
403f 32 6e fe			ld (debug_mark),a  
4042 3a 51 40			ld a, (.dmark+1)  
4045 32 6f fe			ld (debug_mark+1),a  
4048 3a 52 40			ld a, (.dmark+2)  
404b 32 70 fe			ld (debug_mark+2),a  
404e 18 03			jr .pastdmark  
4050 ..			.dmark: db "DTh"  
4053 f1			.pastdmark: pop af  
4054			endm  
# End of macro DMARK
4054				CALLMONITOR 
4054 cd f3 18			call break_point_state  
4057				endm  
# End of macro CALLMONITOR
4057			endif	 
4057			 
4057					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4057 cd 16 22			call macro_forth_dsp_pop 
405a				endm 
# End of macro FORTH_DSP_POP
405a			 
405a			if DEBUG_FORTH_DOT 
405a				DMARK "DTi" 
405a f5				push af  
405b 3a 6f 40			ld a, (.dmark)  
405e 32 6e fe			ld (debug_mark),a  
4061 3a 70 40			ld a, (.dmark+1)  
4064 32 6f fe			ld (debug_mark+1),a  
4067 3a 71 40			ld a, (.dmark+2)  
406a 32 70 fe			ld (debug_mark+2),a  
406d 18 03			jr .pastdmark  
406f ..			.dmark: db "DTi"  
4072 f1			.pastdmark: pop af  
4073			endm  
# End of macro DMARK
4073				CALLMONITOR 
4073 cd f3 18			call break_point_state  
4076				endm  
# End of macro CALLMONITOR
4076			endif	 
4076			 
4076			 
4076					NEXTW 
4076 c3 14 23			jp macro_next 
4079				endm 
# End of macro NEXTW
4079			 
4079			.CLS: 
4079				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4079 35				db WORD_SYS_CORE+33             
407a a6 40			dw .DRAW            
407c 04				db 3 + 1 
407d .. 00			db "CLS",0              
4081				endm 
# End of macro CWHEAD
4081			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4081					if DEBUG_FORTH_WORDS_KEY 
4081						DMARK "CLS" 
4081 f5				push af  
4082 3a 96 40			ld a, (.dmark)  
4085 32 6e fe			ld (debug_mark),a  
4088 3a 97 40			ld a, (.dmark+1)  
408b 32 6f fe			ld (debug_mark+1),a  
408e 3a 98 40			ld a, (.dmark+2)  
4091 32 70 fe			ld (debug_mark+2),a  
4094 18 03			jr .pastdmark  
4096 ..			.dmark: db "CLS"  
4099 f1			.pastdmark: pop af  
409a			endm  
# End of macro DMARK
409a						CALLMONITOR 
409a cd f3 18			call break_point_state  
409d				endm  
# End of macro CALLMONITOR
409d					endif 
409d cd 18 0d				call clear_display 
40a0 c3 b4 41				jp .home		; and home cursor 
40a3					NEXTW 
40a3 c3 14 23			jp macro_next 
40a6				endm 
# End of macro NEXTW
40a6			 
40a6			.DRAW: 
40a6				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
40a6 36				db WORD_SYS_CORE+34             
40a7 d1 40			dw .DUMP            
40a9 05				db 4 + 1 
40aa .. 00			db "DRAW",0              
40af				endm 
# End of macro CWHEAD
40af			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
40af					if DEBUG_FORTH_WORDS_KEY 
40af						DMARK "DRW" 
40af f5				push af  
40b0 3a c4 40			ld a, (.dmark)  
40b3 32 6e fe			ld (debug_mark),a  
40b6 3a c5 40			ld a, (.dmark+1)  
40b9 32 6f fe			ld (debug_mark+1),a  
40bc 3a c6 40			ld a, (.dmark+2)  
40bf 32 70 fe			ld (debug_mark+2),a  
40c2 18 03			jr .pastdmark  
40c4 ..			.dmark: db "DRW"  
40c7 f1			.pastdmark: pop af  
40c8			endm  
# End of macro DMARK
40c8						CALLMONITOR 
40c8 cd f3 18			call break_point_state  
40cb				endm  
# End of macro CALLMONITOR
40cb					endif 
40cb cd 3b 0d				call update_display 
40ce					NEXTW 
40ce c3 14 23			jp macro_next 
40d1				endm 
# End of macro NEXTW
40d1			 
40d1			.DUMP: 
40d1				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
40d1 37				db WORD_SYS_CORE+35             
40d2 09 41			dw .CDUMP            
40d4 05				db 4 + 1 
40d5 .. 00			db "DUMP",0              
40da				endm 
# End of macro CWHEAD
40da			; | DUMP ( x -- ) With address x display dump   | DONE 
40da			; TODO pop address to use off of the stack 
40da					if DEBUG_FORTH_WORDS_KEY 
40da						DMARK "DUM" 
40da f5				push af  
40db 3a ef 40			ld a, (.dmark)  
40de 32 6e fe			ld (debug_mark),a  
40e1 3a f0 40			ld a, (.dmark+1)  
40e4 32 6f fe			ld (debug_mark+1),a  
40e7 3a f1 40			ld a, (.dmark+2)  
40ea 32 70 fe			ld (debug_mark+2),a  
40ed 18 03			jr .pastdmark  
40ef ..			.dmark: db "DUM"  
40f2 f1			.pastdmark: pop af  
40f3			endm  
# End of macro DMARK
40f3						CALLMONITOR 
40f3 cd f3 18			call break_point_state  
40f6				endm  
# End of macro CALLMONITOR
40f6					endif 
40f6 cd 18 0d				call clear_display 
40f9			 
40f9					; get address 
40f9			 
40f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40f9 cd 5e 21			call macro_dsp_valuehl 
40fc				endm 
# End of macro FORTH_DSP_VALUEHL
40fc				 
40fc					; save it for cdump 
40fc			 
40fc 22 eb f4				ld (os_cur_ptr),hl 
40ff			 
40ff					; destroy value TOS 
40ff			 
40ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40ff cd 16 22			call macro_forth_dsp_pop 
4102				endm 
# End of macro FORTH_DSP_POP
4102			 
4102 cd e7 1d				call dumpcont	; skip old style of param parsing	 
4105 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
4106					NEXTW 
4106 c3 14 23			jp macro_next 
4109				endm 
# End of macro NEXTW
4109			.CDUMP: 
4109				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
4109 38				db WORD_SYS_CORE+36             
410a 39 41			dw .DAT            
410c 06				db 5 + 1 
410d .. 00			db "CDUMP",0              
4113				endm 
# End of macro CWHEAD
4113			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
4113					if DEBUG_FORTH_WORDS_KEY 
4113						DMARK "CDP" 
4113 f5				push af  
4114 3a 28 41			ld a, (.dmark)  
4117 32 6e fe			ld (debug_mark),a  
411a 3a 29 41			ld a, (.dmark+1)  
411d 32 6f fe			ld (debug_mark+1),a  
4120 3a 2a 41			ld a, (.dmark+2)  
4123 32 70 fe			ld (debug_mark+2),a  
4126 18 03			jr .pastdmark  
4128 ..			.dmark: db "CDP"  
412b f1			.pastdmark: pop af  
412c			endm  
# End of macro DMARK
412c						CALLMONITOR 
412c cd f3 18			call break_point_state  
412f				endm  
# End of macro CALLMONITOR
412f					endif 
412f cd 18 0d				call clear_display 
4132 cd e7 1d				call dumpcont	 
4135 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4136					NEXTW 
4136 c3 14 23			jp macro_next 
4139				endm 
# End of macro NEXTW
4139			 
4139			 
4139			 
4139			 
4139			.DAT: 
4139				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
4139 3d				db WORD_SYS_CORE+41             
413a 8f 41			dw .HOME            
413c 03				db 2 + 1 
413d .. 00			db "AT",0              
4140				endm 
# End of macro CWHEAD
4140			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
4140					if DEBUG_FORTH_WORDS_KEY 
4140						DMARK "AT." 
4140 f5				push af  
4141 3a 55 41			ld a, (.dmark)  
4144 32 6e fe			ld (debug_mark),a  
4147 3a 56 41			ld a, (.dmark+1)  
414a 32 6f fe			ld (debug_mark+1),a  
414d 3a 57 41			ld a, (.dmark+2)  
4150 32 70 fe			ld (debug_mark+2),a  
4153 18 03			jr .pastdmark  
4155 ..			.dmark: db "AT."  
4158 f1			.pastdmark: pop af  
4159			endm  
# End of macro DMARK
4159						CALLMONITOR 
4159 cd f3 18			call break_point_state  
415c				endm  
# End of macro CALLMONITOR
415c					endif 
415c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
415c cd 5e 21			call macro_dsp_valuehl 
415f				endm 
# End of macro FORTH_DSP_VALUEHL
415f			 
415f			 
415f					; TODO save cursor row 
415f 7d					ld a,l 
4160 fe 02				cp 2 
4162 20 04				jr nz, .crow3 
4164 3e 28				ld a, display_row_2 
4166 18 12				jr .ccol1 
4168 fe 03		.crow3:		cp 3 
416a 20 04				jr nz, .crow4 
416c 3e 50				ld a, display_row_3 
416e 18 0a				jr .ccol1 
4170 fe 04		.crow4:		cp 4 
4172 20 04				jr nz, .crow1 
4174 3e 78				ld a, display_row_4 
4176 18 02				jr .ccol1 
4178 3e 00		.crow1:		ld a,display_row_1 
417a f5			.ccol1:		push af			; got row offset 
417b 6f					ld l,a 
417c 26 00				ld h,0 
417e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
417e cd 16 22			call macro_forth_dsp_pop 
4181				endm 
# End of macro FORTH_DSP_POP
4181					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4181 cd 5e 21			call macro_dsp_valuehl 
4184				endm 
# End of macro FORTH_DSP_VALUEHL
4184					; TODO save cursor col 
4184 f1					pop af 
4185 85					add l		; add col offset 
4186 32 65 fa				ld (f_cursor_ptr), a 
4189					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4189 cd 16 22			call macro_forth_dsp_pop 
418c				endm 
# End of macro FORTH_DSP_POP
418c			 
418c					; calculate  
418c			 
418c					NEXTW 
418c c3 14 23			jp macro_next 
418f				endm 
# End of macro NEXTW
418f			 
418f			 
418f			.HOME: 
418f				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
418f 41				db WORD_SYS_CORE+45             
4190 bc 41			dw .SPACE            
4192 05				db 4 + 1 
4193 .. 00			db "HOME",0              
4198				endm 
# End of macro CWHEAD
4198			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4198					if DEBUG_FORTH_WORDS_KEY 
4198						DMARK "HOM" 
4198 f5				push af  
4199 3a ad 41			ld a, (.dmark)  
419c 32 6e fe			ld (debug_mark),a  
419f 3a ae 41			ld a, (.dmark+1)  
41a2 32 6f fe			ld (debug_mark+1),a  
41a5 3a af 41			ld a, (.dmark+2)  
41a8 32 70 fe			ld (debug_mark+2),a  
41ab 18 03			jr .pastdmark  
41ad ..			.dmark: db "HOM"  
41b0 f1			.pastdmark: pop af  
41b1			endm  
# End of macro DMARK
41b1						CALLMONITOR 
41b1 cd f3 18			call break_point_state  
41b4				endm  
# End of macro CALLMONITOR
41b4					endif 
41b4 3e 00		.home:		ld a, 0		; and home cursor 
41b6 32 65 fa				ld (f_cursor_ptr), a 
41b9					NEXTW 
41b9 c3 14 23			jp macro_next 
41bc				endm 
# End of macro NEXTW
41bc			 
41bc			 
41bc			.SPACE: 
41bc				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
41bc 46				db WORD_SYS_CORE+50             
41bd f2 41			dw .SPACES            
41bf 03				db 2 + 1 
41c0 .. 00			db "BL",0              
41c3				endm 
# End of macro CWHEAD
41c3			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
41c3					if DEBUG_FORTH_WORDS_KEY 
41c3						DMARK "BL." 
41c3 f5				push af  
41c4 3a d8 41			ld a, (.dmark)  
41c7 32 6e fe			ld (debug_mark),a  
41ca 3a d9 41			ld a, (.dmark+1)  
41cd 32 6f fe			ld (debug_mark+1),a  
41d0 3a da 41			ld a, (.dmark+2)  
41d3 32 70 fe			ld (debug_mark+2),a  
41d6 18 03			jr .pastdmark  
41d8 ..			.dmark: db "BL."  
41db f1			.pastdmark: pop af  
41dc			endm  
# End of macro DMARK
41dc						CALLMONITOR 
41dc cd f3 18			call break_point_state  
41df				endm  
# End of macro CALLMONITOR
41df					endif 
41df 3e 20				ld a, " " 
41e1 32 c8 f1				ld (scratch),a 
41e4 3e 00				ld a, 0 
41e6 32 c9 f1				ld (scratch+1),a 
41e9 21 c8 f1				ld hl, scratch 
41ec cd d5 1f				call forth_push_str 
41ef					 
41ef				       NEXTW 
41ef c3 14 23			jp macro_next 
41f2				endm 
# End of macro NEXTW
41f2			 
41f2			;.blstr: db " ", 0 
41f2			 
41f2			.SPACES: 
41f2				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
41f2 47				db WORD_SYS_CORE+51             
41f3 8d 42			dw .SCROLL            
41f5 07				db 6 + 1 
41f6 .. 00			db "SPACES",0              
41fd				endm 
# End of macro CWHEAD
41fd			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
41fd					if DEBUG_FORTH_WORDS_KEY 
41fd						DMARK "SPS" 
41fd f5				push af  
41fe 3a 12 42			ld a, (.dmark)  
4201 32 6e fe			ld (debug_mark),a  
4204 3a 13 42			ld a, (.dmark+1)  
4207 32 6f fe			ld (debug_mark+1),a  
420a 3a 14 42			ld a, (.dmark+2)  
420d 32 70 fe			ld (debug_mark+2),a  
4210 18 03			jr .pastdmark  
4212 ..			.dmark: db "SPS"  
4215 f1			.pastdmark: pop af  
4216			endm  
# End of macro DMARK
4216						CALLMONITOR 
4216 cd f3 18			call break_point_state  
4219				endm  
# End of macro CALLMONITOR
4219					endif 
4219			 
4219			 
4219					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4219 cd 5e 21			call macro_dsp_valuehl 
421c				endm 
# End of macro FORTH_DSP_VALUEHL
421c			 
421c e5					push hl    ; u 
421d					if DEBUG_FORTH_WORDS 
421d						DMARK "SPA" 
421d f5				push af  
421e 3a 32 42			ld a, (.dmark)  
4221 32 6e fe			ld (debug_mark),a  
4224 3a 33 42			ld a, (.dmark+1)  
4227 32 6f fe			ld (debug_mark+1),a  
422a 3a 34 42			ld a, (.dmark+2)  
422d 32 70 fe			ld (debug_mark+2),a  
4230 18 03			jr .pastdmark  
4232 ..			.dmark: db "SPA"  
4235 f1			.pastdmark: pop af  
4236			endm  
# End of macro DMARK
4236						CALLMONITOR 
4236 cd f3 18			call break_point_state  
4239				endm  
# End of macro CALLMONITOR
4239					endif 
4239			 
4239					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4239 cd 16 22			call macro_forth_dsp_pop 
423c				endm 
# End of macro FORTH_DSP_POP
423c e1					pop hl 
423d 0e 00				ld c, 0 
423f 45					ld b, l 
4240 21 c8 f1				ld hl, scratch  
4243			 
4243					if DEBUG_FORTH_WORDS 
4243						DMARK "SP2" 
4243 f5				push af  
4244 3a 58 42			ld a, (.dmark)  
4247 32 6e fe			ld (debug_mark),a  
424a 3a 59 42			ld a, (.dmark+1)  
424d 32 6f fe			ld (debug_mark+1),a  
4250 3a 5a 42			ld a, (.dmark+2)  
4253 32 70 fe			ld (debug_mark+2),a  
4256 18 03			jr .pastdmark  
4258 ..			.dmark: db "SP2"  
425b f1			.pastdmark: pop af  
425c			endm  
# End of macro DMARK
425c						CALLMONITOR 
425c cd f3 18			call break_point_state  
425f				endm  
# End of macro CALLMONITOR
425f					endif 
425f 3e 20				ld a, ' ' 
4261			.spaces1:	 
4261 77					ld (hl),a 
4262 23					inc hl 
4263					 
4263 10 fc				djnz .spaces1 
4265 3e 00				ld a,0 
4267 77					ld (hl),a 
4268 21 c8 f1				ld hl, scratch 
426b					if DEBUG_FORTH_WORDS 
426b						DMARK "SP3" 
426b f5				push af  
426c 3a 80 42			ld a, (.dmark)  
426f 32 6e fe			ld (debug_mark),a  
4272 3a 81 42			ld a, (.dmark+1)  
4275 32 6f fe			ld (debug_mark+1),a  
4278 3a 82 42			ld a, (.dmark+2)  
427b 32 70 fe			ld (debug_mark+2),a  
427e 18 03			jr .pastdmark  
4280 ..			.dmark: db "SP3"  
4283 f1			.pastdmark: pop af  
4284			endm  
# End of macro DMARK
4284						CALLMONITOR 
4284 cd f3 18			call break_point_state  
4287				endm  
# End of macro CALLMONITOR
4287					endif 
4287 cd d5 1f				call forth_push_str 
428a			 
428a				       NEXTW 
428a c3 14 23			jp macro_next 
428d				endm 
# End of macro NEXTW
428d			 
428d			 
428d			 
428d			.SCROLL: 
428d				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
428d 53				db WORD_SYS_CORE+63             
428e ba 42			dw .SCROLLD            
4290 07				db 6 + 1 
4291 .. 00			db "SCROLL",0              
4298				endm 
# End of macro CWHEAD
4298			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4298					if DEBUG_FORTH_WORDS_KEY 
4298						DMARK "SCR" 
4298 f5				push af  
4299 3a ad 42			ld a, (.dmark)  
429c 32 6e fe			ld (debug_mark),a  
429f 3a ae 42			ld a, (.dmark+1)  
42a2 32 6f fe			ld (debug_mark+1),a  
42a5 3a af 42			ld a, (.dmark+2)  
42a8 32 70 fe			ld (debug_mark+2),a  
42ab 18 03			jr .pastdmark  
42ad ..			.dmark: db "SCR"  
42b0 f1			.pastdmark: pop af  
42b1			endm  
# End of macro DMARK
42b1						CALLMONITOR 
42b1 cd f3 18			call break_point_state  
42b4				endm  
# End of macro CALLMONITOR
42b4					endif 
42b4			 
42b4 cd da 0c			call scroll_up 
42b7			;	call update_display 
42b7			 
42b7					NEXTW 
42b7 c3 14 23			jp macro_next 
42ba				endm 
# End of macro NEXTW
42ba			 
42ba			 
42ba			 
42ba			;		; get dir 
42ba			; 
42ba			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42ba			; 
42ba			;		push hl 
42ba			; 
42ba			;		; destroy value TOS 
42ba			; 
42ba			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42ba			; 
42ba			;		; get count 
42ba			; 
42ba			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42ba			; 
42ba			;		push hl 
42ba			; 
42ba			;		; destroy value TOS 
42ba			; 
42ba			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42ba			; 
42ba			;		; one value on hl get other one back 
42ba			; 
42ba			;		pop bc    ; count 
42ba			; 
42ba			;		pop de   ; dir 
42ba			; 
42ba			; 
42ba			;		ld b, c 
42ba			; 
42ba			;.scrolldir:     push bc 
42ba			;		push de 
42ba			; 
42ba			;		ld a, 0 
42ba			;		cp e 
42ba			;		jr z, .scrollup  
42ba			;		call scroll_down 
42ba			;		jr .scrollnext 
42ba			;.scrollup:	call scroll_up 
42ba			; 
42ba			;		 
42ba			;.scrollnext: 
42ba			;		pop de 
42ba			;		pop bc 
42ba			;		djnz .scrolldir 
42ba			; 
42ba			; 
42ba			; 
42ba			; 
42ba			; 
42ba			;		NEXTW 
42ba			 
42ba			.SCROLLD: 
42ba				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
42ba 53				db WORD_SYS_CORE+63             
42bb e8 42			dw .ATQ            
42bd 08				db 7 + 1 
42be .. 00			db "SCROLLD",0              
42c6				endm 
# End of macro CWHEAD
42c6			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
42c6					if DEBUG_FORTH_WORDS_KEY 
42c6						DMARK "SCD" 
42c6 f5				push af  
42c7 3a db 42			ld a, (.dmark)  
42ca 32 6e fe			ld (debug_mark),a  
42cd 3a dc 42			ld a, (.dmark+1)  
42d0 32 6f fe			ld (debug_mark+1),a  
42d3 3a dd 42			ld a, (.dmark+2)  
42d6 32 70 fe			ld (debug_mark+2),a  
42d9 18 03			jr .pastdmark  
42db ..			.dmark: db "SCD"  
42de f1			.pastdmark: pop af  
42df			endm  
# End of macro DMARK
42df						CALLMONITOR 
42df cd f3 18			call break_point_state  
42e2				endm  
# End of macro CALLMONITOR
42e2					endif 
42e2			 
42e2 cd fe 0c			call scroll_down 
42e5			;	call update_display 
42e5			 
42e5					NEXTW 
42e5 c3 14 23			jp macro_next 
42e8				endm 
# End of macro NEXTW
42e8			 
42e8			 
42e8			.ATQ: 
42e8				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
42e8 62				db WORD_SYS_CORE+78             
42e9 46 43			dw .AUTODSP            
42eb 04				db 3 + 1 
42ec .. 00			db "AT@",0              
42f0				endm 
# End of macro CWHEAD
42f0			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
42f0					if DEBUG_FORTH_WORDS_KEY 
42f0						DMARK "ATA" 
42f0 f5				push af  
42f1 3a 05 43			ld a, (.dmark)  
42f4 32 6e fe			ld (debug_mark),a  
42f7 3a 06 43			ld a, (.dmark+1)  
42fa 32 6f fe			ld (debug_mark+1),a  
42fd 3a 07 43			ld a, (.dmark+2)  
4300 32 70 fe			ld (debug_mark+2),a  
4303 18 03			jr .pastdmark  
4305 ..			.dmark: db "ATA"  
4308 f1			.pastdmark: pop af  
4309			endm  
# End of macro DMARK
4309						CALLMONITOR 
4309 cd f3 18			call break_point_state  
430c				endm  
# End of macro CALLMONITOR
430c					endif 
430c			 
430c			 
430c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
430c cd 5e 21			call macro_dsp_valuehl 
430f				endm 
# End of macro FORTH_DSP_VALUEHL
430f			 
430f					; TODO save cursor row 
430f 7d					ld a,l 
4310 fe 02				cp 2 
4312 20 04				jr nz, .crow3aq 
4314 3e 28				ld a, display_row_2 
4316 18 12				jr .ccol1aq 
4318 fe 03		.crow3aq:		cp 3 
431a 20 04				jr nz, .crow4aq 
431c 3e 50				ld a, display_row_3 
431e 18 0a				jr .ccol1aq 
4320 fe 04		.crow4aq:		cp 4 
4322 20 04				jr nz, .crow1aq 
4324 3e 78				ld a, display_row_4 
4326 18 02				jr .ccol1aq 
4328 3e 00		.crow1aq:		ld a,display_row_1 
432a f5			.ccol1aq:		push af			; got row offset 
432b 6f					ld l,a 
432c 26 00				ld h,0 
432e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
432e cd 16 22			call macro_forth_dsp_pop 
4331				endm 
# End of macro FORTH_DSP_POP
4331					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4331 cd 5e 21			call macro_dsp_valuehl 
4334				endm 
# End of macro FORTH_DSP_VALUEHL
4334					; TODO save cursor col 
4334 f1					pop af 
4335 85					add l		; add col offset 
4336			 
4336					; add current frame buffer address 
4336 2a cf fb				ld hl, (display_fb_active) 
4339 cd 4c 0f				call addatohl 
433c			 
433c			 
433c			 
433c			 
433c					; get char frame buffer location offset in hl 
433c			 
433c 7e					ld a,(hl) 
433d 26 00				ld h, 0 
433f 6f					ld l, a 
4340			 
4340 cd 67 1f				call forth_push_numhl 
4343			 
4343			 
4343					NEXTW 
4343 c3 14 23			jp macro_next 
4346				endm 
# End of macro NEXTW
4346			 
4346			.AUTODSP: 
4346				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4346 63				db WORD_SYS_CORE+79             
4347 5c 43			dw .MENU            
4349 05				db 4 + 1 
434a .. 00			db "ADSP",0              
434f				endm 
# End of macro CWHEAD
434f			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
434f			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
434f			 
434f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
434f cd 5e 21			call macro_dsp_valuehl 
4352				endm 
# End of macro FORTH_DSP_VALUEHL
4352			 
4352			;		push hl 
4352			 
4352					; destroy value TOS 
4352			 
4352					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4352 cd 16 22			call macro_forth_dsp_pop 
4355				endm 
# End of macro FORTH_DSP_POP
4355			 
4355			;		pop hl 
4355			 
4355 7d					ld a,l 
4356 32 43 fa				ld (cli_autodisplay), a 
4359				       NEXTW 
4359 c3 14 23			jp macro_next 
435c				endm 
# End of macro NEXTW
435c			 
435c			.MENU: 
435c				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
435c 70				db WORD_SYS_CORE+92             
435d 05 44			dw .ENDDISPLAY            
435f 05				db 4 + 1 
4360 .. 00			db "MENU",0              
4365				endm 
# End of macro CWHEAD
4365			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
4365			 
4365			;		; get number of items on the stack 
4365			; 
4365				 
4365					FORTH_DSP_VALUEHL 
4365 cd 5e 21			call macro_dsp_valuehl 
4368				endm 
# End of macro FORTH_DSP_VALUEHL
4368				 
4368					if DEBUG_FORTH_WORDS_KEY 
4368						DMARK "MNU" 
4368 f5				push af  
4369 3a 7d 43			ld a, (.dmark)  
436c 32 6e fe			ld (debug_mark),a  
436f 3a 7e 43			ld a, (.dmark+1)  
4372 32 6f fe			ld (debug_mark+1),a  
4375 3a 7f 43			ld a, (.dmark+2)  
4378 32 70 fe			ld (debug_mark+2),a  
437b 18 03			jr .pastdmark  
437d ..			.dmark: db "MNU"  
4380 f1			.pastdmark: pop af  
4381			endm  
# End of macro DMARK
4381						CALLMONITOR 
4381 cd f3 18			call break_point_state  
4384				endm  
# End of macro CALLMONITOR
4384					endif 
4384			 
4384 45					ld b, l	 
4385 05					dec b 
4386			 
4386					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4386 cd 16 22			call macro_forth_dsp_pop 
4389				endm 
# End of macro FORTH_DSP_POP
4389			 
4389			 
4389					; go directly through the stack to pluck out the string pointers and build an array 
4389			 
4389			;		FORTH_DSP 
4389			 
4389					; hl contains top most stack item 
4389				 
4389 11 c8 f1				ld de, scratch 
438c			 
438c			.mbuild: 
438c			 
438c					FORTH_DSP_VALUEHL 
438c cd 5e 21			call macro_dsp_valuehl 
438f				endm 
# End of macro FORTH_DSP_VALUEHL
438f			 
438f					if DEBUG_FORTH_WORDS 
438f						DMARK "MN3" 
438f f5				push af  
4390 3a a4 43			ld a, (.dmark)  
4393 32 6e fe			ld (debug_mark),a  
4396 3a a5 43			ld a, (.dmark+1)  
4399 32 6f fe			ld (debug_mark+1),a  
439c 3a a6 43			ld a, (.dmark+2)  
439f 32 70 fe			ld (debug_mark+2),a  
43a2 18 03			jr .pastdmark  
43a4 ..			.dmark: db "MN3"  
43a7 f1			.pastdmark: pop af  
43a8			endm  
# End of macro DMARK
43a8						CALLMONITOR 
43a8 cd f3 18			call break_point_state  
43ab				endm  
# End of macro CALLMONITOR
43ab					endif 
43ab eb					ex de, hl 
43ac 73					ld (hl), e 
43ad 23					inc hl 
43ae 72					ld (hl), d 
43af 23					inc hl 
43b0 eb					ex de, hl 
43b1			 
43b1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43b1 cd 16 22			call macro_forth_dsp_pop 
43b4				endm 
# End of macro FORTH_DSP_POP
43b4			 
43b4 10 d6				djnz .mbuild 
43b6			 
43b6					; done add term 
43b6			 
43b6 eb					ex de, hl 
43b7 36 00				ld (hl), 0 
43b9 23					inc hl 
43ba 36 00				ld (hl), 0 
43bc			 
43bc				 
43bc					 
43bc 21 c8 f1				ld hl, scratch 
43bf			 
43bf					if DEBUG_FORTH_WORDS 
43bf						DMARK "MNx" 
43bf f5				push af  
43c0 3a d4 43			ld a, (.dmark)  
43c3 32 6e fe			ld (debug_mark),a  
43c6 3a d5 43			ld a, (.dmark+1)  
43c9 32 6f fe			ld (debug_mark+1),a  
43cc 3a d6 43			ld a, (.dmark+2)  
43cf 32 70 fe			ld (debug_mark+2),a  
43d2 18 03			jr .pastdmark  
43d4 ..			.dmark: db "MNx"  
43d7 f1			.pastdmark: pop af  
43d8			endm  
# End of macro DMARK
43d8						CALLMONITOR 
43d8 cd f3 18			call break_point_state  
43db				endm  
# End of macro CALLMONITOR
43db					endif 
43db			 
43db			 
43db			 
43db 3e 00				ld a, 0 
43dd cd 49 0d				call menu 
43e0			 
43e0			 
43e0 6f					ld l, a 
43e1 26 00				ld h, 0 
43e3			 
43e3					if DEBUG_FORTH_WORDS 
43e3						DMARK "MNr" 
43e3 f5				push af  
43e4 3a f8 43			ld a, (.dmark)  
43e7 32 6e fe			ld (debug_mark),a  
43ea 3a f9 43			ld a, (.dmark+1)  
43ed 32 6f fe			ld (debug_mark+1),a  
43f0 3a fa 43			ld a, (.dmark+2)  
43f3 32 70 fe			ld (debug_mark+2),a  
43f6 18 03			jr .pastdmark  
43f8 ..			.dmark: db "MNr"  
43fb f1			.pastdmark: pop af  
43fc			endm  
# End of macro DMARK
43fc						CALLMONITOR 
43fc cd f3 18			call break_point_state  
43ff				endm  
# End of macro CALLMONITOR
43ff					endif 
43ff			 
43ff cd 67 1f				call forth_push_numhl 
4402			 
4402			 
4402			 
4402			 
4402				       NEXTW 
4402 c3 14 23			jp macro_next 
4405				endm 
# End of macro NEXTW
4405			 
4405			 
4405			.ENDDISPLAY: 
4405			 
4405			; eof 
# End of file forth_words_display.asm
4405			include "forth_words_str.asm" 
4405			 
4405			; | ## String Words 
4405			 
4405			.PTR:   
4405			 
4405				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4405 48				db WORD_SYS_CORE+52             
4406 32 44			dw .STYPE            
4408 04				db 3 + 1 
4409 .. 00			db "PTR",0              
440d				endm 
# End of macro CWHEAD
440d			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
440d			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
440d			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
440d			 
440d					if DEBUG_FORTH_WORDS_KEY 
440d						DMARK "PTR" 
440d f5				push af  
440e 3a 22 44			ld a, (.dmark)  
4411 32 6e fe			ld (debug_mark),a  
4414 3a 23 44			ld a, (.dmark+1)  
4417 32 6f fe			ld (debug_mark+1),a  
441a 3a 24 44			ld a, (.dmark+2)  
441d 32 70 fe			ld (debug_mark+2),a  
4420 18 03			jr .pastdmark  
4422 ..			.dmark: db "PTR"  
4425 f1			.pastdmark: pop af  
4426			endm  
# End of macro DMARK
4426						CALLMONITOR 
4426 cd f3 18			call break_point_state  
4429				endm  
# End of macro CALLMONITOR
4429					endif 
4429					FORTH_DSP_VALUEHL 
4429 cd 5e 21			call macro_dsp_valuehl 
442c				endm 
# End of macro FORTH_DSP_VALUEHL
442c cd 67 1f				call forth_push_numhl 
442f			 
442f			 
442f					NEXTW 
442f c3 14 23			jp macro_next 
4432				endm 
# End of macro NEXTW
4432			.STYPE: 
4432				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4432 48				db WORD_SYS_CORE+52             
4433 81 44			dw .UPPER            
4435 06				db 5 + 1 
4436 .. 00			db "STYPE",0              
443c				endm 
# End of macro CWHEAD
443c			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
443c					if DEBUG_FORTH_WORDS_KEY 
443c						DMARK "STY" 
443c f5				push af  
443d 3a 51 44			ld a, (.dmark)  
4440 32 6e fe			ld (debug_mark),a  
4443 3a 52 44			ld a, (.dmark+1)  
4446 32 6f fe			ld (debug_mark+1),a  
4449 3a 53 44			ld a, (.dmark+2)  
444c 32 70 fe			ld (debug_mark+2),a  
444f 18 03			jr .pastdmark  
4451 ..			.dmark: db "STY"  
4454 f1			.pastdmark: pop af  
4455			endm  
# End of macro DMARK
4455						CALLMONITOR 
4455 cd f3 18			call break_point_state  
4458				endm  
# End of macro CALLMONITOR
4458					endif 
4458					FORTH_DSP 
4458 cd 24 21			call macro_forth_dsp 
445b				endm 
# End of macro FORTH_DSP
445b					;v5 FORTH_DSP_VALUE 
445b			 
445b 7e					ld a, (hl) 
445c			 
445c f5					push af 
445d			 
445d			; Dont destroy TOS		FORTH_DSP_POP 
445d			 
445d f1					pop af 
445e			 
445e fe 01				cp DS_TYPE_STR 
4460 28 09				jr z, .typestr 
4462			 
4462 fe 02				cp DS_TYPE_INUM 
4464 28 0a				jr z, .typeinum 
4466			 
4466 21 7f 44				ld hl, .tna 
4469 18 0a				jr .tpush 
446b			 
446b 21 7b 44		.typestr:	ld hl, .tstr 
446e 18 05				jr .tpush 
4470 21 7d 44		.typeinum:	ld hl, .tinum 
4473 18 00				jr .tpush 
4475			 
4475			.tpush: 
4475			 
4475 cd d5 1f				call forth_push_str 
4478			 
4478					NEXTW 
4478 c3 14 23			jp macro_next 
447b				endm 
# End of macro NEXTW
447b .. 00		.tstr:	db "s",0 
447d .. 00		.tinum:  db "i",0 
447f .. 00		.tna:   db "?", 0 
4481			 
4481			 
4481			.UPPER: 
4481				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4481 48				db WORD_SYS_CORE+52             
4482 bc 44			dw .LOWER            
4484 06				db 5 + 1 
4485 .. 00			db "UPPER",0              
448b				endm 
# End of macro CWHEAD
448b			; | UPPER ( s -- s ) Upper case string s  | DONE 
448b					if DEBUG_FORTH_WORDS_KEY 
448b						DMARK "UPR" 
448b f5				push af  
448c 3a a0 44			ld a, (.dmark)  
448f 32 6e fe			ld (debug_mark),a  
4492 3a a1 44			ld a, (.dmark+1)  
4495 32 6f fe			ld (debug_mark+1),a  
4498 3a a2 44			ld a, (.dmark+2)  
449b 32 70 fe			ld (debug_mark+2),a  
449e 18 03			jr .pastdmark  
44a0 ..			.dmark: db "UPR"  
44a3 f1			.pastdmark: pop af  
44a4			endm  
# End of macro DMARK
44a4						CALLMONITOR 
44a4 cd f3 18			call break_point_state  
44a7				endm  
# End of macro CALLMONITOR
44a7					endif 
44a7			 
44a7					FORTH_DSP 
44a7 cd 24 21			call macro_forth_dsp 
44aa				endm 
# End of macro FORTH_DSP
44aa					 
44aa			; TODO check is string type 
44aa			 
44aa					FORTH_DSP_VALUEHL 
44aa cd 5e 21			call macro_dsp_valuehl 
44ad				endm 
# End of macro FORTH_DSP_VALUEHL
44ad			; get pointer to string in hl 
44ad			 
44ad 7e			.toup:		ld a, (hl) 
44ae fe 00				cp 0 
44b0 28 07				jr z, .toupdone 
44b2			 
44b2 cd b9 12				call to_upper 
44b5			 
44b5 77					ld (hl), a 
44b6 23					inc hl 
44b7 18 f4				jr .toup 
44b9			 
44b9					 
44b9			 
44b9			 
44b9			; for each char convert to upper 
44b9					 
44b9			.toupdone: 
44b9			 
44b9			 
44b9					NEXTW 
44b9 c3 14 23			jp macro_next 
44bc				endm 
# End of macro NEXTW
44bc			.LOWER: 
44bc				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
44bc 48				db WORD_SYS_CORE+52             
44bd f7 44			dw .TCASE            
44bf 06				db 5 + 1 
44c0 .. 00			db "LOWER",0              
44c6				endm 
# End of macro CWHEAD
44c6			; | LOWER ( s -- s ) Lower case string s  | DONE 
44c6					if DEBUG_FORTH_WORDS_KEY 
44c6						DMARK "LWR" 
44c6 f5				push af  
44c7 3a db 44			ld a, (.dmark)  
44ca 32 6e fe			ld (debug_mark),a  
44cd 3a dc 44			ld a, (.dmark+1)  
44d0 32 6f fe			ld (debug_mark+1),a  
44d3 3a dd 44			ld a, (.dmark+2)  
44d6 32 70 fe			ld (debug_mark+2),a  
44d9 18 03			jr .pastdmark  
44db ..			.dmark: db "LWR"  
44de f1			.pastdmark: pop af  
44df			endm  
# End of macro DMARK
44df						CALLMONITOR 
44df cd f3 18			call break_point_state  
44e2				endm  
# End of macro CALLMONITOR
44e2					endif 
44e2			 
44e2					FORTH_DSP 
44e2 cd 24 21			call macro_forth_dsp 
44e5				endm 
# End of macro FORTH_DSP
44e5					 
44e5			; TODO check is string type 
44e5			 
44e5					FORTH_DSP_VALUEHL 
44e5 cd 5e 21			call macro_dsp_valuehl 
44e8				endm 
# End of macro FORTH_DSP_VALUEHL
44e8			; get pointer to string in hl 
44e8			 
44e8 7e			.tolow:		ld a, (hl) 
44e9 fe 00				cp 0 
44eb 28 07				jr z, .tolowdone 
44ed			 
44ed cd c2 12				call to_lower 
44f0			 
44f0 77					ld (hl), a 
44f1 23					inc hl 
44f2 18 f4				jr .tolow 
44f4			 
44f4					 
44f4			 
44f4			 
44f4			; for each char convert to low 
44f4					 
44f4			.tolowdone: 
44f4					NEXTW 
44f4 c3 14 23			jp macro_next 
44f7				endm 
# End of macro NEXTW
44f7			.TCASE: 
44f7				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
44f7 48				db WORD_SYS_CORE+52             
44f8 2d 46			dw .SUBSTR            
44fa 06				db 5 + 1 
44fb .. 00			db "TCASE",0              
4501				endm 
# End of macro CWHEAD
4501			; | TCASE ( s -- s ) Title case string s  | DONE 
4501					if DEBUG_FORTH_WORDS_KEY 
4501						DMARK "TCS" 
4501 f5				push af  
4502 3a 16 45			ld a, (.dmark)  
4505 32 6e fe			ld (debug_mark),a  
4508 3a 17 45			ld a, (.dmark+1)  
450b 32 6f fe			ld (debug_mark+1),a  
450e 3a 18 45			ld a, (.dmark+2)  
4511 32 70 fe			ld (debug_mark+2),a  
4514 18 03			jr .pastdmark  
4516 ..			.dmark: db "TCS"  
4519 f1			.pastdmark: pop af  
451a			endm  
# End of macro DMARK
451a						CALLMONITOR 
451a cd f3 18			call break_point_state  
451d				endm  
# End of macro CALLMONITOR
451d					endif 
451d			 
451d					FORTH_DSP 
451d cd 24 21			call macro_forth_dsp 
4520				endm 
# End of macro FORTH_DSP
4520					 
4520			; TODO check is string type 
4520			 
4520					FORTH_DSP_VALUEHL 
4520 cd 5e 21			call macro_dsp_valuehl 
4523				endm 
# End of macro FORTH_DSP_VALUEHL
4523			; get pointer to string in hl 
4523			 
4523					if DEBUG_FORTH_WORDS 
4523						DMARK "TC1" 
4523 f5				push af  
4524 3a 38 45			ld a, (.dmark)  
4527 32 6e fe			ld (debug_mark),a  
452a 3a 39 45			ld a, (.dmark+1)  
452d 32 6f fe			ld (debug_mark+1),a  
4530 3a 3a 45			ld a, (.dmark+2)  
4533 32 70 fe			ld (debug_mark+2),a  
4536 18 03			jr .pastdmark  
4538 ..			.dmark: db "TC1"  
453b f1			.pastdmark: pop af  
453c			endm  
# End of macro DMARK
453c						CALLMONITOR 
453c cd f3 18			call break_point_state  
453f				endm  
# End of macro CALLMONITOR
453f					endif 
453f			 
453f					; first time in turn to upper case first char 
453f			 
453f 7e					ld a, (hl) 
4540 c3 ca 45				jp .totsiptou 
4543			 
4543			 
4543 7e			.tot:		ld a, (hl) 
4544 fe 00				cp 0 
4546 ca 0e 46				jp z, .totdone 
4549			 
4549					if DEBUG_FORTH_WORDS 
4549						DMARK "TC2" 
4549 f5				push af  
454a 3a 5e 45			ld a, (.dmark)  
454d 32 6e fe			ld (debug_mark),a  
4550 3a 5f 45			ld a, (.dmark+1)  
4553 32 6f fe			ld (debug_mark+1),a  
4556 3a 60 45			ld a, (.dmark+2)  
4559 32 70 fe			ld (debug_mark+2),a  
455c 18 03			jr .pastdmark  
455e ..			.dmark: db "TC2"  
4561 f1			.pastdmark: pop af  
4562			endm  
# End of macro DMARK
4562						CALLMONITOR 
4562 cd f3 18			call break_point_state  
4565				endm  
# End of macro CALLMONITOR
4565					endif 
4565					; check to see if current char is a space 
4565			 
4565 fe 20				cp ' ' 
4567 28 21				jr z, .totsp 
4569 cd c2 12				call to_lower 
456c					if DEBUG_FORTH_WORDS 
456c						DMARK "TC3" 
456c f5				push af  
456d 3a 81 45			ld a, (.dmark)  
4570 32 6e fe			ld (debug_mark),a  
4573 3a 82 45			ld a, (.dmark+1)  
4576 32 6f fe			ld (debug_mark+1),a  
4579 3a 83 45			ld a, (.dmark+2)  
457c 32 70 fe			ld (debug_mark+2),a  
457f 18 03			jr .pastdmark  
4581 ..			.dmark: db "TC3"  
4584 f1			.pastdmark: pop af  
4585			endm  
# End of macro DMARK
4585						CALLMONITOR 
4585 cd f3 18			call break_point_state  
4588				endm  
# End of macro CALLMONITOR
4588					endif 
4588 18 63				jr .totnxt 
458a			 
458a			.totsp:         ; on a space, find next char which should be upper 
458a			 
458a					if DEBUG_FORTH_WORDS 
458a						DMARK "TC4" 
458a f5				push af  
458b 3a 9f 45			ld a, (.dmark)  
458e 32 6e fe			ld (debug_mark),a  
4591 3a a0 45			ld a, (.dmark+1)  
4594 32 6f fe			ld (debug_mark+1),a  
4597 3a a1 45			ld a, (.dmark+2)  
459a 32 70 fe			ld (debug_mark+2),a  
459d 18 03			jr .pastdmark  
459f ..			.dmark: db "TC4"  
45a2 f1			.pastdmark: pop af  
45a3			endm  
# End of macro DMARK
45a3						CALLMONITOR 
45a3 cd f3 18			call break_point_state  
45a6				endm  
# End of macro CALLMONITOR
45a6					endif 
45a6					;; 
45a6			 
45a6 fe 20				cp ' ' 
45a8 20 20				jr nz, .totsiptou 
45aa 23					inc hl 
45ab 7e					ld a, (hl) 
45ac					if DEBUG_FORTH_WORDS 
45ac						DMARK "TC5" 
45ac f5				push af  
45ad 3a c1 45			ld a, (.dmark)  
45b0 32 6e fe			ld (debug_mark),a  
45b3 3a c2 45			ld a, (.dmark+1)  
45b6 32 6f fe			ld (debug_mark+1),a  
45b9 3a c3 45			ld a, (.dmark+2)  
45bc 32 70 fe			ld (debug_mark+2),a  
45bf 18 03			jr .pastdmark  
45c1 ..			.dmark: db "TC5"  
45c4 f1			.pastdmark: pop af  
45c5			endm  
# End of macro DMARK
45c5						CALLMONITOR 
45c5 cd f3 18			call break_point_state  
45c8				endm  
# End of macro CALLMONITOR
45c8					endif 
45c8 18 c0				jr .totsp 
45ca fe 00		.totsiptou:    cp 0 
45cc 28 40				jr z, .totdone 
45ce					; not space and not zero term so upper case it 
45ce cd b9 12				call to_upper 
45d1			 
45d1					if DEBUG_FORTH_WORDS 
45d1						DMARK "TC6" 
45d1 f5				push af  
45d2 3a e6 45			ld a, (.dmark)  
45d5 32 6e fe			ld (debug_mark),a  
45d8 3a e7 45			ld a, (.dmark+1)  
45db 32 6f fe			ld (debug_mark+1),a  
45de 3a e8 45			ld a, (.dmark+2)  
45e1 32 70 fe			ld (debug_mark+2),a  
45e4 18 03			jr .pastdmark  
45e6 ..			.dmark: db "TC6"  
45e9 f1			.pastdmark: pop af  
45ea			endm  
# End of macro DMARK
45ea						CALLMONITOR 
45ea cd f3 18			call break_point_state  
45ed				endm  
# End of macro CALLMONITOR
45ed					endif 
45ed			 
45ed			 
45ed			.totnxt: 
45ed			 
45ed 77					ld (hl), a 
45ee 23					inc hl 
45ef					if DEBUG_FORTH_WORDS 
45ef						DMARK "TC7" 
45ef f5				push af  
45f0 3a 04 46			ld a, (.dmark)  
45f3 32 6e fe			ld (debug_mark),a  
45f6 3a 05 46			ld a, (.dmark+1)  
45f9 32 6f fe			ld (debug_mark+1),a  
45fc 3a 06 46			ld a, (.dmark+2)  
45ff 32 70 fe			ld (debug_mark+2),a  
4602 18 03			jr .pastdmark  
4604 ..			.dmark: db "TC7"  
4607 f1			.pastdmark: pop af  
4608			endm  
# End of macro DMARK
4608						CALLMONITOR 
4608 cd f3 18			call break_point_state  
460b				endm  
# End of macro CALLMONITOR
460b					endif 
460b c3 43 45				jp .tot 
460e			 
460e					 
460e			 
460e			 
460e			; for each char convert to low 
460e					 
460e			.totdone: 
460e					if DEBUG_FORTH_WORDS 
460e						DMARK "TCd" 
460e f5				push af  
460f 3a 23 46			ld a, (.dmark)  
4612 32 6e fe			ld (debug_mark),a  
4615 3a 24 46			ld a, (.dmark+1)  
4618 32 6f fe			ld (debug_mark+1),a  
461b 3a 25 46			ld a, (.dmark+2)  
461e 32 70 fe			ld (debug_mark+2),a  
4621 18 03			jr .pastdmark  
4623 ..			.dmark: db "TCd"  
4626 f1			.pastdmark: pop af  
4627			endm  
# End of macro DMARK
4627						CALLMONITOR 
4627 cd f3 18			call break_point_state  
462a				endm  
# End of macro CALLMONITOR
462a					endif 
462a					NEXTW 
462a c3 14 23			jp macro_next 
462d				endm 
# End of macro NEXTW
462d			 
462d			.SUBSTR: 
462d				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
462d 48				db WORD_SYS_CORE+52             
462e 8b 46			dw .LEFT            
4630 07				db 6 + 1 
4631 .. 00			db "SUBSTR",0              
4638				endm 
# End of macro CWHEAD
4638			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4638			 
4638					if DEBUG_FORTH_WORDS_KEY 
4638						DMARK "SST" 
4638 f5				push af  
4639 3a 4d 46			ld a, (.dmark)  
463c 32 6e fe			ld (debug_mark),a  
463f 3a 4e 46			ld a, (.dmark+1)  
4642 32 6f fe			ld (debug_mark+1),a  
4645 3a 4f 46			ld a, (.dmark+2)  
4648 32 70 fe			ld (debug_mark+2),a  
464b 18 03			jr .pastdmark  
464d ..			.dmark: db "SST"  
4650 f1			.pastdmark: pop af  
4651			endm  
# End of macro DMARK
4651						CALLMONITOR 
4651 cd f3 18			call break_point_state  
4654				endm  
# End of macro CALLMONITOR
4654					endif 
4654			; TODO check string type 
4654					FORTH_DSP_VALUEHL 
4654 cd 5e 21			call macro_dsp_valuehl 
4657				endm 
# End of macro FORTH_DSP_VALUEHL
4657			 
4657 e5					push hl      ; string length 
4658			 
4658					FORTH_DSP_POP 
4658 cd 16 22			call macro_forth_dsp_pop 
465b				endm 
# End of macro FORTH_DSP_POP
465b			 
465b					FORTH_DSP_VALUEHL 
465b cd 5e 21			call macro_dsp_valuehl 
465e				endm 
# End of macro FORTH_DSP_VALUEHL
465e			 
465e e5					push hl     ; start char 
465f			 
465f					FORTH_DSP_POP 
465f cd 16 22			call macro_forth_dsp_pop 
4662				endm 
# End of macro FORTH_DSP_POP
4662			 
4662			 
4662					FORTH_DSP_VALUE 
4662 cd 47 21			call macro_forth_dsp_value 
4665				endm 
# End of macro FORTH_DSP_VALUE
4665			 
4665 d1					pop de    ; get start post offset 
4666			 
4666 19					add hl, de    ; starting offset 
4667			 
4667 c1					pop bc 
4668 c5					push bc      ; grab size of string 
4669			 
4669 e5					push hl    ; save string start  
466a			 
466a 26 00				ld h, 0 
466c 69					ld l, c 
466d 23					inc hl 
466e 23					inc hl 
466f			 
466f cd 13 14				call malloc 
4672				if DEBUG_FORTH_MALLOC_GUARD 
4672 cc e6 5b				call z,malloc_error 
4675				endif 
4675			 
4675 eb					ex de, hl      ; save malloc area for string copy 
4676 e1					pop hl    ; get back source 
4677 c1					pop bc    ; get length of string back 
4678			 
4678 d5					push de    ; save malloc area for after we push 
4679 ed b0				ldir     ; copy substr 
467b			 
467b			 
467b eb					ex de, hl 
467c 3e 00				ld a, 0 
467e 77					ld (hl), a   ; term substr 
467f			 
467f					 
467f e1					pop hl    ; get malloc so we can push it 
4680 e5					push hl   ; save so we can free it afterwards 
4681			 
4681 cd d5 1f				call forth_push_str 
4684			 
4684 e1					pop hl 
4685 cd dd 14				call free 
4688			 
4688					 
4688					 
4688			 
4688			 
4688					NEXTW 
4688 c3 14 23			jp macro_next 
468b				endm 
# End of macro NEXTW
468b			 
468b			.LEFT: 
468b				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
468b 48				db WORD_SYS_CORE+52             
468c b3 46			dw .RIGHT            
468e 05				db 4 + 1 
468f .. 00			db "LEFT",0              
4694				endm 
# End of macro CWHEAD
4694			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4694					if DEBUG_FORTH_WORDS_KEY 
4694						DMARK "LEF" 
4694 f5				push af  
4695 3a a9 46			ld a, (.dmark)  
4698 32 6e fe			ld (debug_mark),a  
469b 3a aa 46			ld a, (.dmark+1)  
469e 32 6f fe			ld (debug_mark+1),a  
46a1 3a ab 46			ld a, (.dmark+2)  
46a4 32 70 fe			ld (debug_mark+2),a  
46a7 18 03			jr .pastdmark  
46a9 ..			.dmark: db "LEF"  
46ac f1			.pastdmark: pop af  
46ad			endm  
# End of macro DMARK
46ad						CALLMONITOR 
46ad cd f3 18			call break_point_state  
46b0				endm  
# End of macro CALLMONITOR
46b0					endif 
46b0			 
46b0					NEXTW 
46b0 c3 14 23			jp macro_next 
46b3				endm 
# End of macro NEXTW
46b3			.RIGHT: 
46b3				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
46b3 48				db WORD_SYS_CORE+52             
46b4 dc 46			dw .STR2NUM            
46b6 06				db 5 + 1 
46b7 .. 00			db "RIGHT",0              
46bd				endm 
# End of macro CWHEAD
46bd			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
46bd					if DEBUG_FORTH_WORDS_KEY 
46bd						DMARK "RIG" 
46bd f5				push af  
46be 3a d2 46			ld a, (.dmark)  
46c1 32 6e fe			ld (debug_mark),a  
46c4 3a d3 46			ld a, (.dmark+1)  
46c7 32 6f fe			ld (debug_mark+1),a  
46ca 3a d4 46			ld a, (.dmark+2)  
46cd 32 70 fe			ld (debug_mark+2),a  
46d0 18 03			jr .pastdmark  
46d2 ..			.dmark: db "RIG"  
46d5 f1			.pastdmark: pop af  
46d6			endm  
# End of macro DMARK
46d6						CALLMONITOR 
46d6 cd f3 18			call break_point_state  
46d9				endm  
# End of macro CALLMONITOR
46d9					endif 
46d9			 
46d9					NEXTW 
46d9 c3 14 23			jp macro_next 
46dc				endm 
# End of macro NEXTW
46dc			 
46dc			 
46dc			.STR2NUM: 
46dc				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
46dc 48				db WORD_SYS_CORE+52             
46dd 68 47			dw .NUM2STR            
46df 08				db 7 + 1 
46e0 .. 00			db "STR2NUM",0              
46e8				endm 
# End of macro CWHEAD
46e8			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
46e8			 
46e8			 
46e8			; TODO STR type check to do 
46e8					if DEBUG_FORTH_WORDS_KEY 
46e8						DMARK "S2N" 
46e8 f5				push af  
46e9 3a fd 46			ld a, (.dmark)  
46ec 32 6e fe			ld (debug_mark),a  
46ef 3a fe 46			ld a, (.dmark+1)  
46f2 32 6f fe			ld (debug_mark+1),a  
46f5 3a ff 46			ld a, (.dmark+2)  
46f8 32 70 fe			ld (debug_mark+2),a  
46fb 18 03			jr .pastdmark  
46fd ..			.dmark: db "S2N"  
4700 f1			.pastdmark: pop af  
4701			endm  
# End of macro DMARK
4701						CALLMONITOR 
4701 cd f3 18			call break_point_state  
4704				endm  
# End of macro CALLMONITOR
4704					endif 
4704			 
4704					;FORTH_DSP 
4704					FORTH_DSP_VALUE 
4704 cd 47 21			call macro_forth_dsp_value 
4707				endm 
# End of macro FORTH_DSP_VALUE
4707					;inc hl 
4707			 
4707 eb					ex de, hl 
4708					if DEBUG_FORTH_WORDS 
4708						DMARK "S2a" 
4708 f5				push af  
4709 3a 1d 47			ld a, (.dmark)  
470c 32 6e fe			ld (debug_mark),a  
470f 3a 1e 47			ld a, (.dmark+1)  
4712 32 6f fe			ld (debug_mark+1),a  
4715 3a 1f 47			ld a, (.dmark+2)  
4718 32 70 fe			ld (debug_mark+2),a  
471b 18 03			jr .pastdmark  
471d ..			.dmark: db "S2a"  
4720 f1			.pastdmark: pop af  
4721			endm  
# End of macro DMARK
4721						CALLMONITOR 
4721 cd f3 18			call break_point_state  
4724				endm  
# End of macro CALLMONITOR
4724					endif 
4724 cd 41 13				call string_to_uint16 
4727			 
4727					if DEBUG_FORTH_WORDS 
4727						DMARK "S2b" 
4727 f5				push af  
4728 3a 3c 47			ld a, (.dmark)  
472b 32 6e fe			ld (debug_mark),a  
472e 3a 3d 47			ld a, (.dmark+1)  
4731 32 6f fe			ld (debug_mark+1),a  
4734 3a 3e 47			ld a, (.dmark+2)  
4737 32 70 fe			ld (debug_mark+2),a  
473a 18 03			jr .pastdmark  
473c ..			.dmark: db "S2b"  
473f f1			.pastdmark: pop af  
4740			endm  
# End of macro DMARK
4740						CALLMONITOR 
4740 cd f3 18			call break_point_state  
4743				endm  
# End of macro CALLMONITOR
4743					endif 
4743			;		push hl 
4743					FORTH_DSP_POP 
4743 cd 16 22			call macro_forth_dsp_pop 
4746				endm 
# End of macro FORTH_DSP_POP
4746			;		pop hl 
4746					 
4746					if DEBUG_FORTH_WORDS 
4746						DMARK "S2b" 
4746 f5				push af  
4747 3a 5b 47			ld a, (.dmark)  
474a 32 6e fe			ld (debug_mark),a  
474d 3a 5c 47			ld a, (.dmark+1)  
4750 32 6f fe			ld (debug_mark+1),a  
4753 3a 5d 47			ld a, (.dmark+2)  
4756 32 70 fe			ld (debug_mark+2),a  
4759 18 03			jr .pastdmark  
475b ..			.dmark: db "S2b"  
475e f1			.pastdmark: pop af  
475f			endm  
# End of macro DMARK
475f						CALLMONITOR 
475f cd f3 18			call break_point_state  
4762				endm  
# End of macro CALLMONITOR
4762					endif 
4762 cd 67 1f				call forth_push_numhl	 
4765			 
4765				 
4765				       NEXTW 
4765 c3 14 23			jp macro_next 
4768				endm 
# End of macro NEXTW
4768			.NUM2STR: 
4768				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4768 48				db WORD_SYS_CORE+52             
4769 77 47			dw .CONCAT            
476b 08				db 7 + 1 
476c .. 00			db "NUM2STR",0              
4774				endm 
# End of macro CWHEAD
4774			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4774			 
4774			;		; malloc a string to target 
4774			;		ld hl, 10     ; TODO max string size should be fine 
4774			;		call malloc 
4774			;		push hl    ; save malloc location 
4774			; 
4774			; 
4774			;; TODO check int type 
4774			;		FORTH_DSP_VALUEHL 
4774			;		ld a, l 
4774			;		call DispAToASCII   
4774			;;TODO need to chage above call to dump into string 
4774			; 
4774			; 
4774			 
4774				       NEXTW 
4774 c3 14 23			jp macro_next 
4777				endm 
# End of macro NEXTW
4777			 
4777			.CONCAT: 
4777				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4777 48				db WORD_SYS_CORE+52             
4778 2a 48			dw .FIND            
477a 07				db 6 + 1 
477b .. 00			db "CONCAT",0              
4782				endm 
# End of macro CWHEAD
4782			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4782			 
4782			; TODO check string type 
4782			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4782			 
4782					if DEBUG_FORTH_WORDS_KEY 
4782						DMARK "CON" 
4782 f5				push af  
4783 3a 97 47			ld a, (.dmark)  
4786 32 6e fe			ld (debug_mark),a  
4789 3a 98 47			ld a, (.dmark+1)  
478c 32 6f fe			ld (debug_mark+1),a  
478f 3a 99 47			ld a, (.dmark+2)  
4792 32 70 fe			ld (debug_mark+2),a  
4795 18 03			jr .pastdmark  
4797 ..			.dmark: db "CON"  
479a f1			.pastdmark: pop af  
479b			endm  
# End of macro DMARK
479b						CALLMONITOR 
479b cd f3 18			call break_point_state  
479e				endm  
# End of macro CALLMONITOR
479e					endif 
479e			 
479e			 
479e					FORTH_DSP_VALUE 
479e cd 47 21			call macro_forth_dsp_value 
47a1				endm 
# End of macro FORTH_DSP_VALUE
47a1 e5					push hl   ; s2 
47a2			 
47a2					FORTH_DSP_POP 
47a2 cd 16 22			call macro_forth_dsp_pop 
47a5				endm 
# End of macro FORTH_DSP_POP
47a5			 
47a5					FORTH_DSP_VALUE 
47a5 cd 47 21			call macro_forth_dsp_value 
47a8				endm 
# End of macro FORTH_DSP_VALUE
47a8			 
47a8 e5					push hl   ; s1 
47a9			 
47a9					FORTH_DSP_POP 
47a9 cd 16 22			call macro_forth_dsp_pop 
47ac				endm 
# End of macro FORTH_DSP_POP
47ac					 
47ac			 
47ac					; copy s1 
47ac			 
47ac				 
47ac					; save ptr 
47ac e1					pop hl  
47ad e5					push hl 
47ae 3e 00				ld a, 0 
47b0 cd b5 13				call strlent 
47b3					;inc hl    ; zer0 
47b3 06 00				ld b, 0 
47b5 4d					ld c, l 
47b6 e1					pop hl		 
47b7 11 c8 f1				ld de, scratch	 
47ba					if DEBUG_FORTH_WORDS 
47ba						DMARK "CO1" 
47ba f5				push af  
47bb 3a cf 47			ld a, (.dmark)  
47be 32 6e fe			ld (debug_mark),a  
47c1 3a d0 47			ld a, (.dmark+1)  
47c4 32 6f fe			ld (debug_mark+1),a  
47c7 3a d1 47			ld a, (.dmark+2)  
47ca 32 70 fe			ld (debug_mark+2),a  
47cd 18 03			jr .pastdmark  
47cf ..			.dmark: db "CO1"  
47d2 f1			.pastdmark: pop af  
47d3			endm  
# End of macro DMARK
47d3						CALLMONITOR 
47d3 cd f3 18			call break_point_state  
47d6				endm  
# End of macro CALLMONITOR
47d6					endif 
47d6 ed b0				ldir 
47d8			 
47d8 e1					pop hl 
47d9 e5					push hl 
47da d5					push de 
47db			 
47db			 
47db 3e 00				ld a, 0 
47dd cd b5 13				call strlent 
47e0 23					inc hl    ; zer0 
47e1 23					inc hl 
47e2 06 00				ld b, 0 
47e4 4d					ld c, l 
47e5 d1					pop de 
47e6 e1					pop hl		 
47e7					if DEBUG_FORTH_WORDS 
47e7						DMARK "CO2" 
47e7 f5				push af  
47e8 3a fc 47			ld a, (.dmark)  
47eb 32 6e fe			ld (debug_mark),a  
47ee 3a fd 47			ld a, (.dmark+1)  
47f1 32 6f fe			ld (debug_mark+1),a  
47f4 3a fe 47			ld a, (.dmark+2)  
47f7 32 70 fe			ld (debug_mark+2),a  
47fa 18 03			jr .pastdmark  
47fc ..			.dmark: db "CO2"  
47ff f1			.pastdmark: pop af  
4800			endm  
# End of macro DMARK
4800						CALLMONITOR 
4800 cd f3 18			call break_point_state  
4803				endm  
# End of macro CALLMONITOR
4803					endif 
4803 ed b0				ldir 
4805			 
4805			 
4805			 
4805 21 c8 f1				ld hl, scratch 
4808					if DEBUG_FORTH_WORDS 
4808						DMARK "CO5" 
4808 f5				push af  
4809 3a 1d 48			ld a, (.dmark)  
480c 32 6e fe			ld (debug_mark),a  
480f 3a 1e 48			ld a, (.dmark+1)  
4812 32 6f fe			ld (debug_mark+1),a  
4815 3a 1f 48			ld a, (.dmark+2)  
4818 32 70 fe			ld (debug_mark+2),a  
481b 18 03			jr .pastdmark  
481d ..			.dmark: db "CO5"  
4820 f1			.pastdmark: pop af  
4821			endm  
# End of macro DMARK
4821						CALLMONITOR 
4821 cd f3 18			call break_point_state  
4824				endm  
# End of macro CALLMONITOR
4824					endif 
4824			 
4824 cd d5 1f				call forth_push_str 
4827			 
4827			 
4827			 
4827			 
4827				       NEXTW 
4827 c3 14 23			jp macro_next 
482a				endm 
# End of macro NEXTW
482a			 
482a			 
482a			.FIND: 
482a				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
482a 4b				db WORD_SYS_CORE+55             
482b e8 48			dw .LEN            
482d 05				db 4 + 1 
482e .. 00			db "FIND",0              
4833				endm 
# End of macro CWHEAD
4833			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4833			 
4833					if DEBUG_FORTH_WORDS_KEY 
4833						DMARK "FND" 
4833 f5				push af  
4834 3a 48 48			ld a, (.dmark)  
4837 32 6e fe			ld (debug_mark),a  
483a 3a 49 48			ld a, (.dmark+1)  
483d 32 6f fe			ld (debug_mark+1),a  
4840 3a 4a 48			ld a, (.dmark+2)  
4843 32 70 fe			ld (debug_mark+2),a  
4846 18 03			jr .pastdmark  
4848 ..			.dmark: db "FND"  
484b f1			.pastdmark: pop af  
484c			endm  
# End of macro DMARK
484c						CALLMONITOR 
484c cd f3 18			call break_point_state  
484f				endm  
# End of macro CALLMONITOR
484f					endif 
484f			 
484f			; TODO check string type 
484f					FORTH_DSP_VALUE 
484f cd 47 21			call macro_forth_dsp_value 
4852				endm 
# End of macro FORTH_DSP_VALUE
4852			 
4852 e5					push hl    
4853 7e					ld a,(hl)    ; char to find   
4854			; TODO change char to substr 
4854			 
4854 f5					push af 
4855					 
4855			 
4855			 
4855					if DEBUG_FORTH_WORDS 
4855						DMARK "FN1" 
4855 f5				push af  
4856 3a 6a 48			ld a, (.dmark)  
4859 32 6e fe			ld (debug_mark),a  
485c 3a 6b 48			ld a, (.dmark+1)  
485f 32 6f fe			ld (debug_mark+1),a  
4862 3a 6c 48			ld a, (.dmark+2)  
4865 32 70 fe			ld (debug_mark+2),a  
4868 18 03			jr .pastdmark  
486a ..			.dmark: db "FN1"  
486d f1			.pastdmark: pop af  
486e			endm  
# End of macro DMARK
486e						CALLMONITOR 
486e cd f3 18			call break_point_state  
4871				endm  
# End of macro CALLMONITOR
4871					endif 
4871			 
4871					FORTH_DSP_POP 
4871 cd 16 22			call macro_forth_dsp_pop 
4874				endm 
# End of macro FORTH_DSP_POP
4874			 
4874					; string to search 
4874			 
4874					FORTH_DSP_VALUE 
4874 cd 47 21			call macro_forth_dsp_value 
4877				endm 
# End of macro FORTH_DSP_VALUE
4877			 
4877 d1					pop de  ; d is char to find  
4878			 
4878					if DEBUG_FORTH_WORDS 
4878						DMARK "FN2" 
4878 f5				push af  
4879 3a 8d 48			ld a, (.dmark)  
487c 32 6e fe			ld (debug_mark),a  
487f 3a 8e 48			ld a, (.dmark+1)  
4882 32 6f fe			ld (debug_mark+1),a  
4885 3a 8f 48			ld a, (.dmark+2)  
4888 32 70 fe			ld (debug_mark+2),a  
488b 18 03			jr .pastdmark  
488d ..			.dmark: db "FN2"  
4890 f1			.pastdmark: pop af  
4891			endm  
# End of macro DMARK
4891						CALLMONITOR 
4891 cd f3 18			call break_point_state  
4894				endm  
# End of macro CALLMONITOR
4894					endif 
4894					 
4894 01 00 00				ld bc, 0 
4897 7e			.findchar:      ld a,(hl) 
4898 fe 00				cp 0   		 
489a 28 27				jr z, .finddone     
489c ba					cp d 
489d 28 20				jr z, .foundchar 
489f 03					inc bc 
48a0 23					inc hl 
48a1					if DEBUG_FORTH_WORDS 
48a1						DMARK "FN3" 
48a1 f5				push af  
48a2 3a b6 48			ld a, (.dmark)  
48a5 32 6e fe			ld (debug_mark),a  
48a8 3a b7 48			ld a, (.dmark+1)  
48ab 32 6f fe			ld (debug_mark+1),a  
48ae 3a b8 48			ld a, (.dmark+2)  
48b1 32 70 fe			ld (debug_mark+2),a  
48b4 18 03			jr .pastdmark  
48b6 ..			.dmark: db "FN3"  
48b9 f1			.pastdmark: pop af  
48ba			endm  
# End of macro DMARK
48ba						CALLMONITOR 
48ba cd f3 18			call break_point_state  
48bd				endm  
# End of macro CALLMONITOR
48bd					endif 
48bd 18 d8				jr .findchar 
48bf			 
48bf			 
48bf c5			.foundchar:	push bc 
48c0 e1					pop hl 
48c1 18 03				jr .findexit 
48c3			 
48c3			 
48c3							 
48c3			 
48c3			.finddone:     ; got to end of string with no find 
48c3 21 00 00				ld hl, 0 
48c6			.findexit: 
48c6			 
48c6					if DEBUG_FORTH_WORDS 
48c6						DMARK "FNd" 
48c6 f5				push af  
48c7 3a db 48			ld a, (.dmark)  
48ca 32 6e fe			ld (debug_mark),a  
48cd 3a dc 48			ld a, (.dmark+1)  
48d0 32 6f fe			ld (debug_mark+1),a  
48d3 3a dd 48			ld a, (.dmark+2)  
48d6 32 70 fe			ld (debug_mark+2),a  
48d9 18 03			jr .pastdmark  
48db ..			.dmark: db "FNd"  
48de f1			.pastdmark: pop af  
48df			endm  
# End of macro DMARK
48df						CALLMONITOR 
48df cd f3 18			call break_point_state  
48e2				endm  
# End of macro CALLMONITOR
48e2					endif 
48e2 cd 67 1f			call forth_push_numhl 
48e5			 
48e5				       NEXTW 
48e5 c3 14 23			jp macro_next 
48e8				endm 
# End of macro NEXTW
48e8			 
48e8			.LEN: 
48e8				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
48e8 4c				db WORD_SYS_CORE+56             
48e9 52 49			dw .ASC            
48eb 06				db 5 + 1 
48ec .. 00			db "COUNT",0              
48f2				endm 
# End of macro CWHEAD
48f2			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
48f2			 
48f2					if DEBUG_FORTH_WORDS_KEY 
48f2						DMARK "CNT" 
48f2 f5				push af  
48f3 3a 07 49			ld a, (.dmark)  
48f6 32 6e fe			ld (debug_mark),a  
48f9 3a 08 49			ld a, (.dmark+1)  
48fc 32 6f fe			ld (debug_mark+1),a  
48ff 3a 09 49			ld a, (.dmark+2)  
4902 32 70 fe			ld (debug_mark+2),a  
4905 18 03			jr .pastdmark  
4907 ..			.dmark: db "CNT"  
490a f1			.pastdmark: pop af  
490b			endm  
# End of macro DMARK
490b						CALLMONITOR 
490b cd f3 18			call break_point_state  
490e				endm  
# End of macro CALLMONITOR
490e					endif 
490e			; TODO check string type 
490e					FORTH_DSP_VALUE 
490e cd 47 21			call macro_forth_dsp_value 
4911				endm 
# End of macro FORTH_DSP_VALUE
4911			 
4911			 
4911					if DEBUG_FORTH_WORDS 
4911						DMARK "CN?" 
4911 f5				push af  
4912 3a 26 49			ld a, (.dmark)  
4915 32 6e fe			ld (debug_mark),a  
4918 3a 27 49			ld a, (.dmark+1)  
491b 32 6f fe			ld (debug_mark+1),a  
491e 3a 28 49			ld a, (.dmark+2)  
4921 32 70 fe			ld (debug_mark+2),a  
4924 18 03			jr .pastdmark  
4926 ..			.dmark: db "CN?"  
4929 f1			.pastdmark: pop af  
492a			endm  
# End of macro DMARK
492a						CALLMONITOR 
492a cd f3 18			call break_point_state  
492d				endm  
# End of macro CALLMONITOR
492d					endif 
492d cd aa 13				call strlenz 
4930					if DEBUG_FORTH_WORDS 
4930						DMARK "CNl" 
4930 f5				push af  
4931 3a 45 49			ld a, (.dmark)  
4934 32 6e fe			ld (debug_mark),a  
4937 3a 46 49			ld a, (.dmark+1)  
493a 32 6f fe			ld (debug_mark+1),a  
493d 3a 47 49			ld a, (.dmark+2)  
4940 32 70 fe			ld (debug_mark+2),a  
4943 18 03			jr .pastdmark  
4945 ..			.dmark: db "CNl"  
4948 f1			.pastdmark: pop af  
4949			endm  
# End of macro DMARK
4949						CALLMONITOR 
4949 cd f3 18			call break_point_state  
494c				endm  
# End of macro CALLMONITOR
494c					endif 
494c			 
494c cd 67 1f				call forth_push_numhl 
494f			 
494f			 
494f			 
494f				       NEXTW 
494f c3 14 23			jp macro_next 
4952				endm 
# End of macro NEXTW
4952			.ASC: 
4952				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4952 4d				db WORD_SYS_CORE+57             
4953 c0 49			dw .CHR            
4955 04				db 3 + 1 
4956 .. 00			db "ASC",0              
495a				endm 
# End of macro CWHEAD
495a			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
495a					if DEBUG_FORTH_WORDS_KEY 
495a						DMARK "ASC" 
495a f5				push af  
495b 3a 6f 49			ld a, (.dmark)  
495e 32 6e fe			ld (debug_mark),a  
4961 3a 70 49			ld a, (.dmark+1)  
4964 32 6f fe			ld (debug_mark+1),a  
4967 3a 71 49			ld a, (.dmark+2)  
496a 32 70 fe			ld (debug_mark+2),a  
496d 18 03			jr .pastdmark  
496f ..			.dmark: db "ASC"  
4972 f1			.pastdmark: pop af  
4973			endm  
# End of macro DMARK
4973						CALLMONITOR 
4973 cd f3 18			call break_point_state  
4976				endm  
# End of macro CALLMONITOR
4976					endif 
4976					FORTH_DSP_VALUE 
4976 cd 47 21			call macro_forth_dsp_value 
4979				endm 
# End of macro FORTH_DSP_VALUE
4979					;v5 FORTH_DSP_VALUE 
4979			;		inc hl      ; now at start of numeric as string 
4979			 
4979 e5					push hl 
497a			 
497a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
497a cd 16 22			call macro_forth_dsp_pop 
497d				endm 
# End of macro FORTH_DSP_POP
497d			 
497d e1					pop hl 
497e			 
497e					if DEBUG_FORTH_WORDS 
497e						DMARK "AS1" 
497e f5				push af  
497f 3a 93 49			ld a, (.dmark)  
4982 32 6e fe			ld (debug_mark),a  
4985 3a 94 49			ld a, (.dmark+1)  
4988 32 6f fe			ld (debug_mark+1),a  
498b 3a 95 49			ld a, (.dmark+2)  
498e 32 70 fe			ld (debug_mark+2),a  
4991 18 03			jr .pastdmark  
4993 ..			.dmark: db "AS1"  
4996 f1			.pastdmark: pop af  
4997			endm  
# End of macro DMARK
4997						CALLMONITOR 
4997 cd f3 18			call break_point_state  
499a				endm  
# End of macro CALLMONITOR
499a					endif 
499a					; push the content of a onto the stack as a value 
499a			 
499a 7e					ld a,(hl)   ; get char 
499b 26 00				ld h,0 
499d 6f					ld l,a 
499e					if DEBUG_FORTH_WORDS 
499e						DMARK "AS2" 
499e f5				push af  
499f 3a b3 49			ld a, (.dmark)  
49a2 32 6e fe			ld (debug_mark),a  
49a5 3a b4 49			ld a, (.dmark+1)  
49a8 32 6f fe			ld (debug_mark+1),a  
49ab 3a b5 49			ld a, (.dmark+2)  
49ae 32 70 fe			ld (debug_mark+2),a  
49b1 18 03			jr .pastdmark  
49b3 ..			.dmark: db "AS2"  
49b6 f1			.pastdmark: pop af  
49b7			endm  
# End of macro DMARK
49b7						CALLMONITOR 
49b7 cd f3 18			call break_point_state  
49ba				endm  
# End of macro CALLMONITOR
49ba					endif 
49ba cd 67 1f				call forth_push_numhl 
49bd			 
49bd				       NEXTW 
49bd c3 14 23			jp macro_next 
49c0				endm 
# End of macro NEXTW
49c0			 
49c0			.CHR: 
49c0				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
49c0 4d				db WORD_SYS_CORE+57             
49c1 fc 49			dw .ENDSTR            
49c3 04				db 3 + 1 
49c4 .. 00			db "CHR",0              
49c8				endm 
# End of macro CWHEAD
49c8			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
49c8					if DEBUG_FORTH_WORDS_KEY 
49c8						DMARK "CHR" 
49c8 f5				push af  
49c9 3a dd 49			ld a, (.dmark)  
49cc 32 6e fe			ld (debug_mark),a  
49cf 3a de 49			ld a, (.dmark+1)  
49d2 32 6f fe			ld (debug_mark+1),a  
49d5 3a df 49			ld a, (.dmark+2)  
49d8 32 70 fe			ld (debug_mark+2),a  
49db 18 03			jr .pastdmark  
49dd ..			.dmark: db "CHR"  
49e0 f1			.pastdmark: pop af  
49e1			endm  
# End of macro DMARK
49e1						CALLMONITOR 
49e1 cd f3 18			call break_point_state  
49e4				endm  
# End of macro CALLMONITOR
49e4					endif 
49e4					FORTH_DSP_VALUEHL 
49e4 cd 5e 21			call macro_dsp_valuehl 
49e7				endm 
# End of macro FORTH_DSP_VALUEHL
49e7			 
49e7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
49e7 cd 16 22			call macro_forth_dsp_pop 
49ea				endm 
# End of macro FORTH_DSP_POP
49ea			 
49ea					; save asci byte as a zero term string and push string 
49ea			 
49ea 7d					ld a,l 
49eb 32 c8 f1				ld (scratch), a 
49ee			 
49ee 3e 00				ld a, 0 
49f0 32 c9 f1				ld (scratch+1), a 
49f3			 
49f3 21 c8 f1				ld hl, scratch 
49f6 cd d5 1f				call forth_push_str 
49f9			 
49f9			 
49f9				       NEXTW 
49f9 c3 14 23			jp macro_next 
49fc				endm 
# End of macro NEXTW
49fc			 
49fc			 
49fc			 
49fc			 
49fc			.ENDSTR: 
49fc			; eof 
49fc			 
# End of file forth_words_str.asm
49fc			include "forth_words_key.asm" 
49fc			 
49fc			; | ## Keyboard Words 
49fc			 
49fc			.KEY: 
49fc				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
49fc 3e				db WORD_SYS_CORE+42             
49fd 2c 4a			dw .WAITK            
49ff 04				db 3 + 1 
4a00 .. 00			db "KEY",0              
4a04				endm 
# End of macro CWHEAD
4a04			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4a04			 
4a04					if DEBUG_FORTH_WORDS_KEY 
4a04						DMARK "KEY" 
4a04 f5				push af  
4a05 3a 19 4a			ld a, (.dmark)  
4a08 32 6e fe			ld (debug_mark),a  
4a0b 3a 1a 4a			ld a, (.dmark+1)  
4a0e 32 6f fe			ld (debug_mark+1),a  
4a11 3a 1b 4a			ld a, (.dmark+2)  
4a14 32 70 fe			ld (debug_mark+2),a  
4a17 18 03			jr .pastdmark  
4a19 ..			.dmark: db "KEY"  
4a1c f1			.pastdmark: pop af  
4a1d			endm  
# End of macro DMARK
4a1d						CALLMONITOR 
4a1d cd f3 18			call break_point_state  
4a20				endm  
# End of macro CALLMONITOR
4a20					endif 
4a20			; TODO currently waits 
4a20 cd 18 77				call cin 
4a23					;call cin_wait 
4a23 6f					ld l, a 
4a24 26 00				ld h, 0 
4a26 cd 67 1f				call forth_push_numhl 
4a29					NEXTW 
4a29 c3 14 23			jp macro_next 
4a2c				endm 
# End of macro NEXTW
4a2c			.WAITK: 
4a2c				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4a2c 3f				db WORD_SYS_CORE+43             
4a2d 5e 4a			dw .ACCEPT            
4a2f 06				db 5 + 1 
4a30 .. 00			db "WAITK",0              
4a36				endm 
# End of macro CWHEAD
4a36			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4a36					if DEBUG_FORTH_WORDS_KEY 
4a36						DMARK "WAI" 
4a36 f5				push af  
4a37 3a 4b 4a			ld a, (.dmark)  
4a3a 32 6e fe			ld (debug_mark),a  
4a3d 3a 4c 4a			ld a, (.dmark+1)  
4a40 32 6f fe			ld (debug_mark+1),a  
4a43 3a 4d 4a			ld a, (.dmark+2)  
4a46 32 70 fe			ld (debug_mark+2),a  
4a49 18 03			jr .pastdmark  
4a4b ..			.dmark: db "WAI"  
4a4e f1			.pastdmark: pop af  
4a4f			endm  
# End of macro DMARK
4a4f						CALLMONITOR 
4a4f cd f3 18			call break_point_state  
4a52				endm  
# End of macro CALLMONITOR
4a52					endif 
4a52 cd 07 77				call cin_wait 
4a55 6f					ld l, a 
4a56 26 00				ld h, 0 
4a58 cd 67 1f				call forth_push_numhl 
4a5b					NEXTW 
4a5b c3 14 23			jp macro_next 
4a5e				endm 
# End of macro NEXTW
4a5e			.ACCEPT: 
4a5e				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4a5e 40				db WORD_SYS_CORE+44             
4a5f bc 4a			dw .EDIT            
4a61 07				db 6 + 1 
4a62 .. 00			db "ACCEPT",0              
4a69				endm 
# End of macro CWHEAD
4a69			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4a69					; TODO crashes on push 
4a69					if DEBUG_FORTH_WORDS_KEY 
4a69						DMARK "ACC" 
4a69 f5				push af  
4a6a 3a 7e 4a			ld a, (.dmark)  
4a6d 32 6e fe			ld (debug_mark),a  
4a70 3a 7f 4a			ld a, (.dmark+1)  
4a73 32 6f fe			ld (debug_mark+1),a  
4a76 3a 80 4a			ld a, (.dmark+2)  
4a79 32 70 fe			ld (debug_mark+2),a  
4a7c 18 03			jr .pastdmark  
4a7e ..			.dmark: db "ACC"  
4a81 f1			.pastdmark: pop af  
4a82			endm  
# End of macro DMARK
4a82						CALLMONITOR 
4a82 cd f3 18			call break_point_state  
4a85				endm  
# End of macro CALLMONITOR
4a85					endif 
4a85 21 c6 f3				ld hl, os_input 
4a88 3e 00				ld a, 0 
4a8a 77					ld (hl),a 
4a8b 3a 65 fa				ld a,(f_cursor_ptr) 
4a8e 16 64				ld d, 100 
4a90 0e 00				ld c, 0 
4a92 1e 28				ld e, 40 
4a94 cd 79 0f				call input_str 
4a97					; TODO perhaps do a type check and wrap in quotes if not a number 
4a97 21 c6 f3				ld hl, os_input 
4a9a					if DEBUG_FORTH_WORDS 
4a9a						DMARK "AC1" 
4a9a f5				push af  
4a9b 3a af 4a			ld a, (.dmark)  
4a9e 32 6e fe			ld (debug_mark),a  
4aa1 3a b0 4a			ld a, (.dmark+1)  
4aa4 32 6f fe			ld (debug_mark+1),a  
4aa7 3a b1 4a			ld a, (.dmark+2)  
4aaa 32 70 fe			ld (debug_mark+2),a  
4aad 18 03			jr .pastdmark  
4aaf ..			.dmark: db "AC1"  
4ab2 f1			.pastdmark: pop af  
4ab3			endm  
# End of macro DMARK
4ab3						CALLMONITOR 
4ab3 cd f3 18			call break_point_state  
4ab6				endm  
# End of macro CALLMONITOR
4ab6					endif 
4ab6 cd d5 1f				call forth_push_str 
4ab9					NEXTW 
4ab9 c3 14 23			jp macro_next 
4abc				endm 
# End of macro NEXTW
4abc			 
4abc			.EDIT: 
4abc				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4abc 40				db WORD_SYS_CORE+44             
4abd 5e 4b			dw .DEDIT            
4abf 05				db 4 + 1 
4ac0 .. 00			db "EDIT",0              
4ac5				endm 
# End of macro CWHEAD
4ac5			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4ac5			 
4ac5					; TODO does not copy from stack 
4ac5					if DEBUG_FORTH_WORDS_KEY 
4ac5						DMARK "EDT" 
4ac5 f5				push af  
4ac6 3a da 4a			ld a, (.dmark)  
4ac9 32 6e fe			ld (debug_mark),a  
4acc 3a db 4a			ld a, (.dmark+1)  
4acf 32 6f fe			ld (debug_mark+1),a  
4ad2 3a dc 4a			ld a, (.dmark+2)  
4ad5 32 70 fe			ld (debug_mark+2),a  
4ad8 18 03			jr .pastdmark  
4ada ..			.dmark: db "EDT"  
4add f1			.pastdmark: pop af  
4ade			endm  
# End of macro DMARK
4ade						CALLMONITOR 
4ade cd f3 18			call break_point_state  
4ae1				endm  
# End of macro CALLMONITOR
4ae1					endif 
4ae1			 
4ae1					;FORTH_DSP 
4ae1					FORTH_DSP_VALUEHL 
4ae1 cd 5e 21			call macro_dsp_valuehl 
4ae4				endm 
# End of macro FORTH_DSP_VALUEHL
4ae4			;		inc hl    ; TODO do type check 
4ae4			 
4ae4			;		call get_word_hl 
4ae4 e5					push hl 
4ae5					if DEBUG_FORTH_WORDS 
4ae5						DMARK "EDp" 
4ae5 f5				push af  
4ae6 3a fa 4a			ld a, (.dmark)  
4ae9 32 6e fe			ld (debug_mark),a  
4aec 3a fb 4a			ld a, (.dmark+1)  
4aef 32 6f fe			ld (debug_mark+1),a  
4af2 3a fc 4a			ld a, (.dmark+2)  
4af5 32 70 fe			ld (debug_mark+2),a  
4af8 18 03			jr .pastdmark  
4afa ..			.dmark: db "EDp"  
4afd f1			.pastdmark: pop af  
4afe			endm  
# End of macro DMARK
4afe						CALLMONITOR 
4afe cd f3 18			call break_point_state  
4b01				endm  
# End of macro CALLMONITOR
4b01					endif 
4b01				;	ld a, 0 
4b01 cd aa 13				call strlenz 
4b04 23					inc hl 
4b05			 
4b05 06 00				ld b, 0 
4b07 4d					ld c, l 
4b08			 
4b08 e1					pop hl 
4b09 11 c6 f3				ld de, os_input 
4b0c					if DEBUG_FORTH_WORDS_KEY 
4b0c						DMARK "EDc" 
4b0c f5				push af  
4b0d 3a 21 4b			ld a, (.dmark)  
4b10 32 6e fe			ld (debug_mark),a  
4b13 3a 22 4b			ld a, (.dmark+1)  
4b16 32 6f fe			ld (debug_mark+1),a  
4b19 3a 23 4b			ld a, (.dmark+2)  
4b1c 32 70 fe			ld (debug_mark+2),a  
4b1f 18 03			jr .pastdmark  
4b21 ..			.dmark: db "EDc"  
4b24 f1			.pastdmark: pop af  
4b25			endm  
# End of macro DMARK
4b25						CALLMONITOR 
4b25 cd f3 18			call break_point_state  
4b28				endm  
# End of macro CALLMONITOR
4b28					endif 
4b28 ed b0				ldir 
4b2a			 
4b2a			 
4b2a 21 c6 f3				ld hl, os_input 
4b2d					;ld a, 0 
4b2d					;ld (hl),a 
4b2d 3a 65 fa				ld a,(f_cursor_ptr) 
4b30 16 64				ld d, 100 
4b32 0e 00				ld c, 0 
4b34 1e 28				ld e, 40 
4b36 cd 79 0f				call input_str 
4b39					; TODO perhaps do a type check and wrap in quotes if not a number 
4b39 21 c6 f3				ld hl, os_input 
4b3c					if DEBUG_FORTH_WORDS 
4b3c						DMARK "ED1" 
4b3c f5				push af  
4b3d 3a 51 4b			ld a, (.dmark)  
4b40 32 6e fe			ld (debug_mark),a  
4b43 3a 52 4b			ld a, (.dmark+1)  
4b46 32 6f fe			ld (debug_mark+1),a  
4b49 3a 53 4b			ld a, (.dmark+2)  
4b4c 32 70 fe			ld (debug_mark+2),a  
4b4f 18 03			jr .pastdmark  
4b51 ..			.dmark: db "ED1"  
4b54 f1			.pastdmark: pop af  
4b55			endm  
# End of macro DMARK
4b55						CALLMONITOR 
4b55 cd f3 18			call break_point_state  
4b58				endm  
# End of macro CALLMONITOR
4b58					endif 
4b58 cd d5 1f				call forth_push_str 
4b5b					NEXTW 
4b5b c3 14 23			jp macro_next 
4b5e				endm 
# End of macro NEXTW
4b5e			 
4b5e			.DEDIT: 
4b5e				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4b5e 40				db WORD_SYS_CORE+44             
4b5f c0 4b			dw .ENDKEY            
4b61 06				db 5 + 1 
4b62 .. 00			db "DEDIT",0              
4b68				endm 
# End of macro CWHEAD
4b68			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4b68			 
4b68					; TODO does not copy from stack 
4b68					if DEBUG_FORTH_WORDS_KEY 
4b68						DMARK "DED" 
4b68 f5				push af  
4b69 3a 7d 4b			ld a, (.dmark)  
4b6c 32 6e fe			ld (debug_mark),a  
4b6f 3a 7e 4b			ld a, (.dmark+1)  
4b72 32 6f fe			ld (debug_mark+1),a  
4b75 3a 7f 4b			ld a, (.dmark+2)  
4b78 32 70 fe			ld (debug_mark+2),a  
4b7b 18 03			jr .pastdmark  
4b7d ..			.dmark: db "DED"  
4b80 f1			.pastdmark: pop af  
4b81			endm  
# End of macro DMARK
4b81						CALLMONITOR 
4b81 cd f3 18			call break_point_state  
4b84				endm  
# End of macro CALLMONITOR
4b84					endif 
4b84			 
4b84					;FORTH_DSP 
4b84					FORTH_DSP_VALUEHL 
4b84 cd 5e 21			call macro_dsp_valuehl 
4b87				endm 
# End of macro FORTH_DSP_VALUEHL
4b87			;		inc hl    ; TODO do type check 
4b87			 
4b87			;		call get_word_hl 
4b87 e5					push hl 
4b88 e5					push hl 
4b89					FORTH_DSP_POP 
4b89 cd 16 22			call macro_forth_dsp_pop 
4b8c				endm 
# End of macro FORTH_DSP_POP
4b8c e1					pop hl 
4b8d					if DEBUG_FORTH_WORDS 
4b8d						DMARK "EDp" 
4b8d f5				push af  
4b8e 3a a2 4b			ld a, (.dmark)  
4b91 32 6e fe			ld (debug_mark),a  
4b94 3a a3 4b			ld a, (.dmark+1)  
4b97 32 6f fe			ld (debug_mark+1),a  
4b9a 3a a4 4b			ld a, (.dmark+2)  
4b9d 32 70 fe			ld (debug_mark+2),a  
4ba0 18 03			jr .pastdmark  
4ba2 ..			.dmark: db "EDp"  
4ba5 f1			.pastdmark: pop af  
4ba6			endm  
# End of macro DMARK
4ba6						CALLMONITOR 
4ba6 cd f3 18			call break_point_state  
4ba9				endm  
# End of macro CALLMONITOR
4ba9					endif 
4ba9				;	ld a, 0 
4ba9 cd aa 13				call strlenz 
4bac 23					inc hl 
4bad			 
4bad 06 00				ld b, 0 
4baf 4d					ld c, l 
4bb0			 
4bb0 e1					pop hl 
4bb1			 
4bb1					;ld a, 0 
4bb1					;ld (hl),a 
4bb1 3a 65 fa				ld a,(f_cursor_ptr) 
4bb4 16 64				ld d, 100 
4bb6 0e 00				ld c, 0 
4bb8 1e 28				ld e, 40 
4bba cd 79 0f				call input_str 
4bbd					; TODO perhaps do a type check and wrap in quotes if not a number 
4bbd					NEXTW 
4bbd c3 14 23			jp macro_next 
4bc0				endm 
# End of macro NEXTW
4bc0			 
4bc0			 
4bc0			.ENDKEY: 
4bc0			; eof 
4bc0			 
# End of file forth_words_key.asm
4bc0			include "forth_words_const.asm" 
4bc0			 
4bc0			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4bc0			 
4bc0			 
4bc0			.SPITIME: 
4bc0				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4bc0 77				db WORD_SYS_CORE+99             
4bc1 d5 4b			dw .VA            
4bc3 08				db 7 + 1 
4bc4 .. 00			db "SPITIME",0              
4bcc				endm 
# End of macro CWHEAD
4bcc			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4bcc			; 
4bcc			; | If using BANK devices then leave as is. 
4bcc			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4bcc			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4bcc			 
4bcc 21 6b fa				ld hl, spi_clktime  
4bcf cd 67 1f				call forth_push_numhl 
4bd2			 
4bd2					NEXTW 
4bd2 c3 14 23			jp macro_next 
4bd5				endm 
# End of macro NEXTW
4bd5			 
4bd5			 
4bd5			.VA: 
4bd5				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4bd5 77				db WORD_SYS_CORE+99             
4bd6 e5 4b			dw .SYMBOL            
4bd8 03				db 2 + 1 
4bd9 .. 00			db "VA",0              
4bdc				endm 
# End of macro CWHEAD
4bdc			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4bdc 21 2f fa				ld hl, cli_var_array 
4bdf cd 67 1f				call forth_push_numhl 
4be2			 
4be2					NEXTW 
4be2 c3 14 23			jp macro_next 
4be5				endm 
# End of macro NEXTW
4be5			 
4be5			.SYMBOL: 
4be5				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4be5 77				db WORD_SYS_CORE+99             
4be6 1d 4d			dw .ENDCONST            
4be8 07				db 6 + 1 
4be9 .. 00			db "SYMBOL",0              
4bf0				endm 
# End of macro CWHEAD
4bf0			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4bf0			; | 
4bf0			; | The value is the number reference and the final address is pushed to stack 
4bf0			 
4bf0					if DEBUG_FORTH_WORDS_KEY 
4bf0						DMARK "SYM" 
4bf0 f5				push af  
4bf1 3a 05 4c			ld a, (.dmark)  
4bf4 32 6e fe			ld (debug_mark),a  
4bf7 3a 06 4c			ld a, (.dmark+1)  
4bfa 32 6f fe			ld (debug_mark+1),a  
4bfd 3a 07 4c			ld a, (.dmark+2)  
4c00 32 70 fe			ld (debug_mark+2),a  
4c03 18 03			jr .pastdmark  
4c05 ..			.dmark: db "SYM"  
4c08 f1			.pastdmark: pop af  
4c09			endm  
# End of macro DMARK
4c09						CALLMONITOR 
4c09 cd f3 18			call break_point_state  
4c0c				endm  
# End of macro CALLMONITOR
4c0c					endif 
4c0c			 
4c0c					FORTH_DSP_VALUEHL 
4c0c cd 5e 21			call macro_dsp_valuehl 
4c0f				endm 
# End of macro FORTH_DSP_VALUEHL
4c0f			 
4c0f 7d					ld a, l     
4c10			 
4c10			 
4c10					if DEBUG_FORTH_WORDS 
4c10						DMARK "SY1" 
4c10 f5				push af  
4c11 3a 25 4c			ld a, (.dmark)  
4c14 32 6e fe			ld (debug_mark),a  
4c17 3a 26 4c			ld a, (.dmark+1)  
4c1a 32 6f fe			ld (debug_mark+1),a  
4c1d 3a 27 4c			ld a, (.dmark+2)  
4c20 32 70 fe			ld (debug_mark+2),a  
4c23 18 03			jr .pastdmark  
4c25 ..			.dmark: db "SY1"  
4c28 f1			.pastdmark: pop af  
4c29			endm  
# End of macro DMARK
4c29						CALLMONITOR 
4c29 cd f3 18			call break_point_state  
4c2c				endm  
# End of macro CALLMONITOR
4c2c					endif 
4c2c					 
4c2c f5					push af	 
4c2d					FORTH_DSP_POP 
4c2d cd 16 22			call macro_forth_dsp_pop 
4c30				endm 
# End of macro FORTH_DSP_POP
4c30 f1					pop af 
4c31			 
4c31 cb 27				sla a  
4c33				 
4c33					 
4c33					if DEBUG_FORTH_WORDS 
4c33						DMARK "SY" 
4c33 f5				push af  
4c34 3a 48 4c			ld a, (.dmark)  
4c37 32 6e fe			ld (debug_mark),a  
4c3a 3a 49 4c			ld a, (.dmark+1)  
4c3d 32 6f fe			ld (debug_mark+1),a  
4c40 3a 4a 4c			ld a, (.dmark+2)  
4c43 32 70 fe			ld (debug_mark+2),a  
4c46 18 02			jr .pastdmark  
4c48 ..			.dmark: db "SY"  
4c4a f1			.pastdmark: pop af  
4c4b			endm  
# End of macro DMARK
4c4b						CALLMONITOR 
4c4b cd f3 18			call break_point_state  
4c4e				endm  
# End of macro CALLMONITOR
4c4e					endif 
4c4e			 
4c4e 21 5d 4c				ld hl, sym_table 
4c51 cd 4c 0f				call addatohl 
4c54 cd 96 22				call loadwordinhl 
4c57 cd 67 1f				call forth_push_numhl 
4c5a			 
4c5a			 
4c5a				       NEXTW 
4c5a c3 14 23			jp macro_next 
4c5d				endm 
# End of macro NEXTW
4c5d			 
4c5d			sym_table: 
4c5d			 
4c5d			; 0 
4c5d 43 fa		dw cli_autodisplay 
4c5f 51 fa		dw cli_buffer 
4c61 f5 f9		dw cli_data_sp 
4c63 2f f7		dw cli_data_stack 
4c65 4b fa		dw cli_execword 
4c67 f7 f9		dw cli_loop_sp 
4c69 31 f9		dw cli_loop_stack 
4c6b 44 fa		dw cli_mvdot 
4c6d 49 fa		dw cli_nextword 
4c6f 45 fa		dw cli_origptr 
4c71 4f fa		dw cli_origtoken 
4c73			; 11 
4c73 47 fa		dw cli_ptr 
4c75 f9 f9		dw cli_ret_sp 
4c77 b3 f9		dw cli_ret_stack 
4c79 4d fa		dw cli_token 
4c7b 2f fa		dw cli_var_array 
4c7d cb fb		dw cursor_col 
4c7f c9 fb		dw cursor_ptr 
4c81 ca fb		dw cursor_row 
4c83 c7 fb		dw cursor_shape 
4c85 6e fe		dw debug_mark 
4c87			; 21 
4c87 b4 fd		dw display_fb0 
4c89 13 fd		dw display_fb1 
4c8b d1 fb		dw display_fb2 
4c8d 72 fc		dw display_fb3 
4c8f cf fb		dw display_fb_active 
4c91 c7 f2		dw execscratch 
4c93 65 fa		dw f_cursor_ptr 
4c95 72 fe		dw hardware_word 
4c97 65 fe		dw input_at_cursor 
4c99 67 fe		dw input_at_pos 
4c9b			; 31 
4c9b 63 fe		dw input_cur_flash 
4c9d 62 fe		dw input_cur_onoff 
4c9f 58 fe		dw input_cursor 
4ca1 68 fe		dw input_display_size 
4ca3 5d fe		dw input_len 
4ca5 6c fe		dw input_ptr 
4ca7 69 fe		dw input_size 
4ca9 6a fe		dw input_start 
4cab 79 0f		dw input_str 
4cad 66 fe		dw input_under_cursor 
4caf			; 41 
4caf 57 fe		dw key_actual_pressed 
4cb1 82 fe		dw key_fa 
4cb3 7e fe		dw key_face_held 
4cb5 81 fe		dw key_fb 
4cb7 80 fe		dw key_fc 
4cb9 7f fe		dw key_fd 
4cbb 88 fe		dw key_held 
4cbd 87 fe		dw key_held_prev 
4cbf 38 76		dw key_init 
4cc1 83 fe		dw key_repeat_ct 
4cc3			; 51 
4cc3 05 00		dw key_rows 
4cc5 55 fe		dw key_shift 
4cc7 56 fe		dw key_symbol 
4cc9 89 fe		dw keyscan_scancol 
4ccb 93 fe		dw keyscan_table 
4ccd f2 fe		dw keyscan_table_row1 
4ccf e7 fe		dw keyscan_table_row2 
4cd1 dc fe		dw keyscan_table_row3 
4cd3 d1 fe		dw keyscan_table_row4 
4cd5 c6 fe		dw keyscan_table_row5 
4cd7			; 61 
4cd7 ef f4		dw os_cli_cmd 
4cd9 eb f4		dw os_cur_ptr 
4cdb ed f4		dw os_current_i 
4cdd c6 f3		dw os_input 
4cdf ee f5		dw os_last_cmd 
4ce1 c5 f4		dw os_last_new_uword 
4ce3 b9 f1		dw os_view_disable 
4ce5 b5 f1		dw os_view_hl 
4ce7 cd f4		dw os_word_scratch 
4ce9 c3 00		dw portbctl 
4ceb			; 71 
4ceb c1 00		dw portbdata 
4ced 6a fa		dw spi_cartdev 
4cef 69 fa		dw spi_cartdev2 
4cf1 6b fa		dw spi_clktime 
4cf3 67 fa		dw spi_device 
4cf5 66 fa		dw spi_device_id 
4cf7 68 fa		dw spi_portbyte 
4cf9 ad fb		dw stackstore 
4cfb			if STORAGE_SE 
4cfb 82 00		dw storage_actl 
4cfd 80 00		dw storage_adata 
4cff			else 
4cff			dw 0 
4cff			dw 0 
4cff			endif 
4cff			; 81 
4cff 0c 0b		dw storage_append 
4d01			if STORAGE_SE 
4d01 83 00		dw storage_bctl 
4d03			else 
4d03			dw 0 
4d03			endif 
4d03 99 fb		dw store_bank_active 
4d05 6e fa		dw store_filecache 
4d07 7c fa		dw store_longread 
4d09 72 fa		dw store_openaddr 
4d0b 71 fa		dw store_openext 
4d0d 70 fa		dw store_openmaxext 
4d0f 81 fa		dw store_page 
4d11 7d fa		dw store_readbuf 
4d13			; 91 
4d13 74 fa		dw store_readcont 
4d15 7f fa		dw store_readptr 
4d17 74 fa		dw store_tmpext 
4d19 75 fa		dw store_tmpid 
4d1b 6c fa		dw store_tmppageid 
4d1d			 
4d1d			 
4d1d			.ENDCONST: 
4d1d			 
4d1d			; eof 
4d1d			 
4d1d			 
# End of file forth_words_const.asm
4d1d			 
4d1d			if STORAGE_SE 
4d1d			   	include "forth_words_storage.asm" 
4d1d			 
4d1d			; | ## Fixed Storage Words 
4d1d			 
4d1d			.RENAME: 
4d1d			  
4d1d				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4d1d 3a				db WORD_SYS_CORE+38             
4d1e 13 4e			dw .RECORD            
4d20 07				db 6 + 1 
4d21 .. 00			db "RENAME",0              
4d28				endm 
# End of macro CWHEAD
4d28			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | TODO 
4d28			; | | Compatible with PicoSPINet  
4d28					if DEBUG_FORTH_WORDS_KEY 
4d28						DMARK "REN" 
4d28 f5				push af  
4d29 3a 3d 4d			ld a, (.dmark)  
4d2c 32 6e fe			ld (debug_mark),a  
4d2f 3a 3e 4d			ld a, (.dmark+1)  
4d32 32 6f fe			ld (debug_mark+1),a  
4d35 3a 3f 4d			ld a, (.dmark+2)  
4d38 32 70 fe			ld (debug_mark+2),a  
4d3b 18 03			jr .pastdmark  
4d3d ..			.dmark: db "REN"  
4d40 f1			.pastdmark: pop af  
4d41			endm  
# End of macro DMARK
4d41						CALLMONITOR 
4d41 cd f3 18			call break_point_state  
4d44				endm  
# End of macro CALLMONITOR
4d44					endif 
4d44			 
4d44			 
4d44					; preserve some internal vars used by other file handing routines 
4d44			 
4d44 2a 72 fa				ld hl, (store_openaddr) 
4d47 e5					push hl 
4d48 3a 74 fa				ld a, (store_readcont) 
4d4b f5					push af 
4d4c			 
4d4c					FORTH_DSP_VALUEHL 
4d4c cd 5e 21			call macro_dsp_valuehl 
4d4f				endm 
# End of macro FORTH_DSP_VALUEHL
4d4f			 
4d4f					; move ext and id around for the file header 
4d4f			 
4d4f 65					ld h, l 
4d50 2e 00				ld l, 0 
4d52			 
4d52 e5					push hl    ; id 
4d53			 
4d53					FORTH_DSP_POP 
4d53 cd 16 22			call macro_forth_dsp_pop 
4d56				endm 
# End of macro FORTH_DSP_POP
4d56			 
4d56					; Locate the file header 
4d56			 
4d56 e1					pop hl 
4d57 e5					push hl 
4d58 11 81 fa				ld de, store_page      ; get block zero of file 
4d5b					if DEBUG_FORTH_WORDS 
4d5b						DMARK "REr" 
4d5b f5				push af  
4d5c 3a 70 4d			ld a, (.dmark)  
4d5f 32 6e fe			ld (debug_mark),a  
4d62 3a 71 4d			ld a, (.dmark+1)  
4d65 32 6f fe			ld (debug_mark+1),a  
4d68 3a 72 4d			ld a, (.dmark+2)  
4d6b 32 70 fe			ld (debug_mark+2),a  
4d6e 18 03			jr .pastdmark  
4d70 ..			.dmark: db "REr"  
4d73 f1			.pastdmark: pop af  
4d74			endm  
# End of macro DMARK
4d74						CALLMONITOR 
4d74 cd f3 18			call break_point_state  
4d77				endm  
# End of macro CALLMONITOR
4d77					endif 
4d77 cd 75 09				call storage_read 
4d7a			 
4d7a cd 75 0f			call ishlzero 
4d7d 20 05			jr nz, .rnfound 
4d7f			 
4d7f				; file does not exist so indicate with 255 extents in use 
4d7f			 
4d7f 3e ff			ld a, 255 
4d81 e1				pop hl ; clear dup hl 
4d82 18 7b			jr .skiprneof 
4d84			 
4d84			 
4d84			.rnfound: 
4d84					; file found so rename 
4d84			 
4d84					FORTH_DSP_VALUEHL 
4d84 cd 5e 21			call macro_dsp_valuehl 
4d87				endm 
# End of macro FORTH_DSP_VALUEHL
4d87			 
4d87 e5				push hl 
4d88 3e 00			ld a, 0 
4d8a cd b5 13			call strlent 
4d8d 23				inc hl   ; cover zero term 
4d8e 06 00			ld b,0 
4d90 4d				ld c,l 
4d91 e1				pop hl 
4d92 11 84 fa				ld de, store_page + 3 
4d95 ed b0				ldir 
4d97			 
4d97 11 81 fa				ld de, store_page 
4d9a					if DEBUG_FORTH_WORDS 
4d9a						DMARK "RER" 
4d9a f5				push af  
4d9b 3a af 4d			ld a, (.dmark)  
4d9e 32 6e fe			ld (debug_mark),a  
4da1 3a b0 4d			ld a, (.dmark+1)  
4da4 32 6f fe			ld (debug_mark+1),a  
4da7 3a b1 4d			ld a, (.dmark+2)  
4daa 32 70 fe			ld (debug_mark+2),a  
4dad 18 03			jr .pastdmark  
4daf ..			.dmark: db "RER"  
4db2 f1			.pastdmark: pop af  
4db3			endm  
# End of macro DMARK
4db3						CALLMONITOR 
4db3 cd f3 18			call break_point_state  
4db6				endm  
# End of macro CALLMONITOR
4db6					endif 
4db6			 
4db6 e1					pop hl    ; get orig file id and mangle it for find id 
4db7 55					ld d, l 
4db8 5c					ld e, h 
4db9			 
4db9 21 00 00				ld hl, 0 
4dbc					if DEBUG_FORTH_WORDS 
4dbc						DMARK "REf" 
4dbc f5				push af  
4dbd 3a d1 4d			ld a, (.dmark)  
4dc0 32 6e fe			ld (debug_mark),a  
4dc3 3a d2 4d			ld a, (.dmark+1)  
4dc6 32 6f fe			ld (debug_mark+1),a  
4dc9 3a d3 4d			ld a, (.dmark+2)  
4dcc 32 70 fe			ld (debug_mark+2),a  
4dcf 18 03			jr .pastdmark  
4dd1 ..			.dmark: db "REf"  
4dd4 f1			.pastdmark: pop af  
4dd5			endm  
# End of macro DMARK
4dd5						CALLMONITOR 
4dd5 cd f3 18			call break_point_state  
4dd8				endm  
# End of macro CALLMONITOR
4dd8					endif 
4dd8 cd 4f 07				call storage_findnextid 
4ddb 11 81 fa				ld de, store_page 
4dde					if DEBUG_FORTH_WORDS 
4dde						DMARK "REw" 
4dde f5				push af  
4ddf 3a f3 4d			ld a, (.dmark)  
4de2 32 6e fe			ld (debug_mark),a  
4de5 3a f4 4d			ld a, (.dmark+1)  
4de8 32 6f fe			ld (debug_mark+1),a  
4deb 3a f5 4d			ld a, (.dmark+2)  
4dee 32 70 fe			ld (debug_mark+2),a  
4df1 18 03			jr .pastdmark  
4df3 ..			.dmark: db "REw"  
4df6 f1			.pastdmark: pop af  
4df7			endm  
# End of macro DMARK
4df7						CALLMONITOR 
4df7 cd f3 18			call break_point_state  
4dfa				endm  
# End of macro CALLMONITOR
4dfa					endif 
4dfa cd 81 04				call storage_write_block 
4dfd			 
4dfd 3e 00				ld a, 0 
4dff			.skiprneof: 
4dff					; drop file name 
4dff					FORTH_DSP_POP 
4dff cd 16 22			call macro_forth_dsp_pop 
4e02				endm 
# End of macro FORTH_DSP_POP
4e02			 
4e02 6f					ld l, a 
4e03 26 00				ld h, 0 
4e05 cd 67 1f				call forth_push_numhl 
4e08			 
4e08			 
4e08 f1					pop af 
4e09 32 74 fa				ld (store_readcont),a 
4e0c e1					pop hl 
4e0d 22 72 fa				ld (store_openaddr), hl 
4e10						 
4e10				NEXTW 
4e10 c3 14 23			jp macro_next 
4e13				endm 
# End of macro NEXTW
4e13			.RECORD: 
4e13			  
4e13				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4e13 3a				db WORD_SYS_CORE+38             
4e14 b7 4e			dw .BREAD            
4e16 07				db 6 + 1 
4e17 .. 00			db "RECORD",0              
4e1e				endm 
# End of macro CWHEAD
4e1e			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4e1e			; | | Compatible with PicoSPINet  
4e1e			 
4e1e					if DEBUG_FORTH_WORDS_KEY 
4e1e						DMARK "REC" 
4e1e f5				push af  
4e1f 3a 33 4e			ld a, (.dmark)  
4e22 32 6e fe			ld (debug_mark),a  
4e25 3a 34 4e			ld a, (.dmark+1)  
4e28 32 6f fe			ld (debug_mark+1),a  
4e2b 3a 35 4e			ld a, (.dmark+2)  
4e2e 32 70 fe			ld (debug_mark+2),a  
4e31 18 03			jr .pastdmark  
4e33 ..			.dmark: db "REC"  
4e36 f1			.pastdmark: pop af  
4e37			endm  
# End of macro DMARK
4e37						CALLMONITOR 
4e37 cd f3 18			call break_point_state  
4e3a				endm  
# End of macro CALLMONITOR
4e3a					endif 
4e3a			 
4e3a					FORTH_DSP_VALUEHL 
4e3a cd 5e 21			call macro_dsp_valuehl 
4e3d				endm 
# End of macro FORTH_DSP_VALUEHL
4e3d			 
4e3d e5					push hl    ; id 
4e3e			 
4e3e					FORTH_DSP_POP 
4e3e cd 16 22			call macro_forth_dsp_pop 
4e41				endm 
# End of macro FORTH_DSP_POP
4e41			 
4e41					FORTH_DSP_VALUEHL 
4e41 cd 5e 21			call macro_dsp_valuehl 
4e44				endm 
# End of macro FORTH_DSP_VALUEHL
4e44			 
4e44					FORTH_DSP_POP 
4e44 cd 16 22			call macro_forth_dsp_pop 
4e47				endm 
# End of macro FORTH_DSP_POP
4e47			 
4e47 d1					pop de     ; get file id 
4e48			 
4e48					; e = file id 
4e48					; l = file extent 
4e48			 
4e48			 
4e48					; construct request to access file extent 
4e48			 
4e48			;		ld a, e 
4e48 63					ld h, e 
4e49					 
4e49					 
4e49					 
4e49			 
4e49					; e has id 
4e49			 
4e49 11 81 fa			ld de, store_page 
4e4c					if DEBUG_FORTH_WORDS 
4e4c						DMARK "REr" 
4e4c f5				push af  
4e4d 3a 61 4e			ld a, (.dmark)  
4e50 32 6e fe			ld (debug_mark),a  
4e53 3a 62 4e			ld a, (.dmark+1)  
4e56 32 6f fe			ld (debug_mark+1),a  
4e59 3a 63 4e			ld a, (.dmark+2)  
4e5c 32 70 fe			ld (debug_mark+2),a  
4e5f 18 03			jr .pastdmark  
4e61 ..			.dmark: db "REr"  
4e64 f1			.pastdmark: pop af  
4e65			endm  
# End of macro DMARK
4e65						CALLMONITOR 
4e65 cd f3 18			call break_point_state  
4e68				endm  
# End of macro CALLMONITOR
4e68					endif 
4e68 cd 75 09				call storage_read 
4e6b cd 75 0f			call ishlzero 
4e6e 28 22			jr z, .recnotfound 
4e70			 
4e70			 
4e70					if DEBUG_FORTH_WORDS 
4e70						DMARK "REe" 
4e70 f5				push af  
4e71 3a 85 4e			ld a, (.dmark)  
4e74 32 6e fe			ld (debug_mark),a  
4e77 3a 86 4e			ld a, (.dmark+1)  
4e7a 32 6f fe			ld (debug_mark+1),a  
4e7d 3a 87 4e			ld a, (.dmark+2)  
4e80 32 70 fe			ld (debug_mark+2),a  
4e83 18 03			jr .pastdmark  
4e85 ..			.dmark: db "REe"  
4e88 f1			.pastdmark: pop af  
4e89			endm  
# End of macro DMARK
4e89						CALLMONITOR 
4e89 cd f3 18			call break_point_state  
4e8c				endm  
# End of macro CALLMONITOR
4e8c					endif 
4e8c cd d5 1f			call forth_push_str 
4e8f			 
4e8f					NEXTW 
4e8f c3 14 23			jp macro_next 
4e92				endm 
# End of macro NEXTW
4e92			 
4e92			.recnotfound: 
4e92					if DEBUG_FORTH_WORDS 
4e92						DMARK "REf" 
4e92 f5				push af  
4e93 3a a7 4e			ld a, (.dmark)  
4e96 32 6e fe			ld (debug_mark),a  
4e99 3a a8 4e			ld a, (.dmark+1)  
4e9c 32 6f fe			ld (debug_mark+1),a  
4e9f 3a a9 4e			ld a, (.dmark+2)  
4ea2 32 70 fe			ld (debug_mark+2),a  
4ea5 18 03			jr .pastdmark  
4ea7 ..			.dmark: db "REf"  
4eaa f1			.pastdmark: pop af  
4eab			endm  
# End of macro DMARK
4eab						CALLMONITOR 
4eab cd f3 18			call break_point_state  
4eae				endm  
# End of macro CALLMONITOR
4eae					endif 
4eae 21 ff 00			ld hl, 255 
4eb1 cd 67 1f			call forth_push_numhl 
4eb4				NEXTW 
4eb4 c3 14 23			jp macro_next 
4eb7				endm 
# End of macro NEXTW
4eb7			 
4eb7			 
4eb7			.BREAD: 
4eb7			  
4eb7				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
4eb7 3a				db WORD_SYS_CORE+38             
4eb8 3a 4f			dw .BWRITE            
4eba 06				db 5 + 1 
4ebb .. 00			db "BREAD",0              
4ec1				endm 
# End of macro CWHEAD
4ec1			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
4ec1			; | | Compatible with PicoSPINet  
4ec1				 
4ec1					if DEBUG_FORTH_WORDS_KEY 
4ec1						DMARK "BRD" 
4ec1 f5				push af  
4ec2 3a d6 4e			ld a, (.dmark)  
4ec5 32 6e fe			ld (debug_mark),a  
4ec8 3a d7 4e			ld a, (.dmark+1)  
4ecb 32 6f fe			ld (debug_mark+1),a  
4ece 3a d8 4e			ld a, (.dmark+2)  
4ed1 32 70 fe			ld (debug_mark+2),a  
4ed4 18 03			jr .pastdmark  
4ed6 ..			.dmark: db "BRD"  
4ed9 f1			.pastdmark: pop af  
4eda			endm  
# End of macro DMARK
4eda						CALLMONITOR 
4eda cd f3 18			call break_point_state  
4edd				endm  
# End of macro CALLMONITOR
4edd					endif 
4edd			 
4edd				FORTH_DSP_VALUEHL 
4edd cd 5e 21			call macro_dsp_valuehl 
4ee0				endm 
# End of macro FORTH_DSP_VALUEHL
4ee0			 
4ee0				FORTH_DSP_POP 
4ee0 cd 16 22			call macro_forth_dsp_pop 
4ee3				endm 
# End of macro FORTH_DSP_POP
4ee3			 
4ee3				; calc block address 
4ee3			 
4ee3 eb				ex de, hl 
4ee4 3e 40			ld a, STORE_BLOCK_PHY 
4ee6 cd cf 0e			call Mult16 
4ee9			 
4ee9			 
4ee9 11 81 fa			ld de, store_page 
4eec			 
4eec					if DEBUG_FORTH_WORDS 
4eec						DMARK "BR1" 
4eec f5				push af  
4eed 3a 01 4f			ld a, (.dmark)  
4ef0 32 6e fe			ld (debug_mark),a  
4ef3 3a 02 4f			ld a, (.dmark+1)  
4ef6 32 6f fe			ld (debug_mark+1),a  
4ef9 3a 03 4f			ld a, (.dmark+2)  
4efc 32 70 fe			ld (debug_mark+2),a  
4eff 18 03			jr .pastdmark  
4f01 ..			.dmark: db "BR1"  
4f04 f1			.pastdmark: pop af  
4f05			endm  
# End of macro DMARK
4f05						CALLMONITOR 
4f05 cd f3 18			call break_point_state  
4f08				endm  
# End of macro CALLMONITOR
4f08					endif 
4f08			 
4f08 cd 1c 04			call storage_read_block 
4f0b			 
4f0b cd 75 0f			call ishlzero 
4f0e 20 05			jr nz, .brfound 
4f10			 
4f10 cd 67 1f			call forth_push_numhl 
4f13 18 22			jr .brdone 
4f15			 
4f15			 
4f15			.brfound: 
4f15 21 83 fa		        ld hl, store_page+2 
4f18			 
4f18					if DEBUG_FORTH_WORDS 
4f18						DMARK "BR2" 
4f18 f5				push af  
4f19 3a 2d 4f			ld a, (.dmark)  
4f1c 32 6e fe			ld (debug_mark),a  
4f1f 3a 2e 4f			ld a, (.dmark+1)  
4f22 32 6f fe			ld (debug_mark+1),a  
4f25 3a 2f 4f			ld a, (.dmark+2)  
4f28 32 70 fe			ld (debug_mark+2),a  
4f2b 18 03			jr .pastdmark  
4f2d ..			.dmark: db "BR2"  
4f30 f1			.pastdmark: pop af  
4f31			endm  
# End of macro DMARK
4f31						CALLMONITOR 
4f31 cd f3 18			call break_point_state  
4f34				endm  
# End of macro CALLMONITOR
4f34					endif 
4f34			 
4f34 cd d5 1f			call forth_push_str 
4f37			 
4f37			 
4f37			.brdone: 
4f37			 
4f37					NEXTW 
4f37 c3 14 23			jp macro_next 
4f3a				endm 
# End of macro NEXTW
4f3a			.BWRITE: 
4f3a				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4f3a 3a				db WORD_SYS_CORE+38             
4f3b cf 4f			dw .BUPD            
4f3d 07				db 6 + 1 
4f3e .. 00			db "BWRITE",0              
4f45				endm 
# End of macro CWHEAD
4f45			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
4f45			; | | Compatible with PicoSPINet  
4f45			 
4f45					if DEBUG_FORTH_WORDS_KEY 
4f45						DMARK "BWR" 
4f45 f5				push af  
4f46 3a 5a 4f			ld a, (.dmark)  
4f49 32 6e fe			ld (debug_mark),a  
4f4c 3a 5b 4f			ld a, (.dmark+1)  
4f4f 32 6f fe			ld (debug_mark+1),a  
4f52 3a 5c 4f			ld a, (.dmark+2)  
4f55 32 70 fe			ld (debug_mark+2),a  
4f58 18 03			jr .pastdmark  
4f5a ..			.dmark: db "BWR"  
4f5d f1			.pastdmark: pop af  
4f5e			endm  
# End of macro DMARK
4f5e						CALLMONITOR 
4f5e cd f3 18			call break_point_state  
4f61				endm  
# End of macro CALLMONITOR
4f61					endif 
4f61			 
4f61				FORTH_DSP_VALUEHL 
4f61 cd 5e 21			call macro_dsp_valuehl 
4f64				endm 
# End of macro FORTH_DSP_VALUEHL
4f64			 
4f64				; calc block address 
4f64			 
4f64 eb				ex de, hl 
4f65 3e 40			ld a, STORE_BLOCK_PHY 
4f67 cd cf 0e			call Mult16 
4f6a			 
4f6a e5				push hl         ; address 
4f6b			 
4f6b				FORTH_DSP_POP 
4f6b cd 16 22			call macro_forth_dsp_pop 
4f6e				endm 
# End of macro FORTH_DSP_POP
4f6e			 
4f6e				FORTH_DSP_VALUEHL 
4f6e cd 5e 21			call macro_dsp_valuehl 
4f71				endm 
# End of macro FORTH_DSP_VALUEHL
4f71			 
4f71				FORTH_DSP_POP 
4f71 cd 16 22			call macro_forth_dsp_pop 
4f74				endm 
# End of macro FORTH_DSP_POP
4f74			 
4f74 cd 58 0c			call storage_clear_page 
4f77			 
4f77				; copy string to store page 
4f77			 
4f77 e5				push hl     ; save string address 
4f78			 
4f78 3e 00			ld a, 0 
4f7a cd b5 13			call strlent 
4f7d			 
4f7d 23				inc hl 
4f7e			 
4f7e 4d				ld c, l 
4f7f 06 00			ld b, 0 
4f81			 
4f81 e1				pop hl 
4f82 11 83 fa			ld de, store_page + 2 
4f85					if DEBUG_FORTH_WORDS 
4f85						DMARK "BW1" 
4f85 f5				push af  
4f86 3a 9a 4f			ld a, (.dmark)  
4f89 32 6e fe			ld (debug_mark),a  
4f8c 3a 9b 4f			ld a, (.dmark+1)  
4f8f 32 6f fe			ld (debug_mark+1),a  
4f92 3a 9c 4f			ld a, (.dmark+2)  
4f95 32 70 fe			ld (debug_mark+2),a  
4f98 18 03			jr .pastdmark  
4f9a ..			.dmark: db "BW1"  
4f9d f1			.pastdmark: pop af  
4f9e			endm  
# End of macro DMARK
4f9e						CALLMONITOR 
4f9e cd f3 18			call break_point_state  
4fa1				endm  
# End of macro CALLMONITOR
4fa1					endif 
4fa1 ed b0			ldir 
4fa3			 
4fa3			 
4fa3				; poke the start of the block with flags to prevent high level file ops hitting the block 
4fa3			 
4fa3 21 ff ff			ld hl, $ffff 
4fa6			 
4fa6 22 81 fa			ld (store_page), hl	 
4fa9				 
4fa9 e1				pop hl    ; get address 
4faa 11 81 fa			ld de, store_page 
4fad			 
4fad					if DEBUG_FORTH_WORDS 
4fad						DMARK "BW2" 
4fad f5				push af  
4fae 3a c2 4f			ld a, (.dmark)  
4fb1 32 6e fe			ld (debug_mark),a  
4fb4 3a c3 4f			ld a, (.dmark+1)  
4fb7 32 6f fe			ld (debug_mark+1),a  
4fba 3a c4 4f			ld a, (.dmark+2)  
4fbd 32 70 fe			ld (debug_mark+2),a  
4fc0 18 03			jr .pastdmark  
4fc2 ..			.dmark: db "BW2"  
4fc5 f1			.pastdmark: pop af  
4fc6			endm  
# End of macro DMARK
4fc6						CALLMONITOR 
4fc6 cd f3 18			call break_point_state  
4fc9				endm  
# End of macro CALLMONITOR
4fc9					endif 
4fc9			 
4fc9 cd 81 04			call storage_write_block 
4fcc			 
4fcc					NEXTW 
4fcc c3 14 23			jp macro_next 
4fcf				endm 
# End of macro NEXTW
4fcf			 
4fcf			.BUPD: 
4fcf				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4fcf 3a				db WORD_SYS_CORE+38             
4fd0 25 50			dw .BYID            
4fd2 05				db 4 + 1 
4fd3 .. 00			db "BUPD",0              
4fd8				endm 
# End of macro CWHEAD
4fd8			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
4fd8			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4fd8			; | | or completely different file system structure. 
4fd8			; | | Compatible with PicoSPINet  
4fd8			 
4fd8					if DEBUG_FORTH_WORDS_KEY 
4fd8						DMARK "BUD" 
4fd8 f5				push af  
4fd9 3a ed 4f			ld a, (.dmark)  
4fdc 32 6e fe			ld (debug_mark),a  
4fdf 3a ee 4f			ld a, (.dmark+1)  
4fe2 32 6f fe			ld (debug_mark+1),a  
4fe5 3a ef 4f			ld a, (.dmark+2)  
4fe8 32 70 fe			ld (debug_mark+2),a  
4feb 18 03			jr .pastdmark  
4fed ..			.dmark: db "BUD"  
4ff0 f1			.pastdmark: pop af  
4ff1			endm  
# End of macro DMARK
4ff1						CALLMONITOR 
4ff1 cd f3 18			call break_point_state  
4ff4				endm  
# End of macro CALLMONITOR
4ff4					endif 
4ff4			 
4ff4				FORTH_DSP_VALUEHL 
4ff4 cd 5e 21			call macro_dsp_valuehl 
4ff7				endm 
# End of macro FORTH_DSP_VALUEHL
4ff7			 
4ff7				; calc block address 
4ff7			 
4ff7 eb				ex de, hl 
4ff8 3e 40			ld a, STORE_BLOCK_PHY 
4ffa cd cf 0e			call Mult16 
4ffd			 
4ffd				FORTH_DSP_POP 
4ffd cd 16 22			call macro_forth_dsp_pop 
5000				endm 
# End of macro FORTH_DSP_POP
5000			 
5000			 
5000 11 81 fa			ld de, store_page 
5003			 
5003					if DEBUG_FORTH_WORDS 
5003						DMARK "BUe" 
5003 f5				push af  
5004 3a 18 50			ld a, (.dmark)  
5007 32 6e fe			ld (debug_mark),a  
500a 3a 19 50			ld a, (.dmark+1)  
500d 32 6f fe			ld (debug_mark+1),a  
5010 3a 1a 50			ld a, (.dmark+2)  
5013 32 70 fe			ld (debug_mark+2),a  
5016 18 03			jr .pastdmark  
5018 ..			.dmark: db "BUe"  
501b f1			.pastdmark: pop af  
501c			endm  
# End of macro DMARK
501c						CALLMONITOR 
501c cd f3 18			call break_point_state  
501f				endm  
# End of macro CALLMONITOR
501f					endif 
501f			 
501f cd 81 04			call storage_write_block 
5022			 
5022					NEXTW 
5022 c3 14 23			jp macro_next 
5025				endm 
# End of macro NEXTW
5025			 
5025			.BYID: 
5025			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
5025			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
5025			; 
5025			;		 
5025			;		if DEBUG_FORTH_WORDS_KEY 
5025			;			DMARK "BYID" 
5025			;			CALLMONITOR 
5025			;		endif 
5025			; 
5025			;		; get direct address 
5025			; 
5025			;		FORTH_DSP_VALUEHL 
5025			; 
5025			;		FORTH_DSP_POP 
5025			; 
5025			;	; calc block address 
5025			; 
5025			;	ex de, hl 
5025			;	ld a, STORE_BLOCK_PHY 
5025			;	call Mult16 
5025			;	;	do BREAD with number as param 
5025			;	; push the file name	 
5025			;	ld de, store_page 
5025			;	call storage_read_block 
5025			 ;       ld hl, store_page+2 
5025			; 
5025			; 
5025			;		NEXTW 
5025			;.BYNAME: 
5025				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
5025 3a				db WORD_SYS_CORE+38             
5026 3e 50			dw .DIR            
5028 06				db 5 + 1 
5029 .. 00			db "GETID",0              
502f				endm 
# End of macro CWHEAD
502f			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
502f			; | | Compatible with PicoSPINet  
502f			 
502f					; get pointer to file name to seek 
502f			 
502f					FORTH_DSP_VALUEHL 
502f cd 5e 21			call macro_dsp_valuehl 
5032				endm 
# End of macro FORTH_DSP_VALUEHL
5032			 
5032			 
5032 cd 43 03				call storage_getid  
5035			 
5035					FORTH_DSP_POP 
5035 cd 16 22			call macro_forth_dsp_pop 
5038				endm 
# End of macro FORTH_DSP_POP
5038			 
5038 cd 67 1f				call forth_push_numhl 
503b			 
503b					NEXTW 
503b c3 14 23			jp macro_next 
503e				endm 
# End of macro NEXTW
503e			; 
503e			.DIR: 
503e				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
503e 3a				db WORD_SYS_CORE+38             
503f 42 51			dw .SAVE            
5041 04				db 3 + 1 
5042 .. 00			db "DIR",0              
5046				endm 
# End of macro CWHEAD
5046			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
5046			; | | Compatible with PicoSPINet  
5046			 
5046					if DEBUG_FORTH_WORDS_KEY 
5046						DMARK "DIR" 
5046 f5				push af  
5047 3a 5b 50			ld a, (.dmark)  
504a 32 6e fe			ld (debug_mark),a  
504d 3a 5c 50			ld a, (.dmark+1)  
5050 32 6f fe			ld (debug_mark+1),a  
5053 3a 5d 50			ld a, (.dmark+2)  
5056 32 70 fe			ld (debug_mark+2),a  
5059 18 03			jr .pastdmark  
505b ..			.dmark: db "DIR"  
505e f1			.pastdmark: pop af  
505f			endm  
# End of macro DMARK
505f						CALLMONITOR 
505f cd f3 18			call break_point_state  
5062				endm  
# End of macro CALLMONITOR
5062					endif 
5062 cd cd 04			call storage_get_block_0 
5065			 
5065 21 81 fa			ld hl, store_page     ; get current id count 
5068 46				ld b, (hl) 
5069 0e 00			ld c, 0    ; count of files   
506b					if DEBUG_FORTH_WORDS 
506b						DMARK "DI1" 
506b f5				push af  
506c 3a 80 50			ld a, (.dmark)  
506f 32 6e fe			ld (debug_mark),a  
5072 3a 81 50			ld a, (.dmark+1)  
5075 32 6f fe			ld (debug_mark+1),a  
5078 3a 82 50			ld a, (.dmark+2)  
507b 32 70 fe			ld (debug_mark+2),a  
507e 18 03			jr .pastdmark  
5080 ..			.dmark: db "DI1"  
5083 f1			.pastdmark: pop af  
5084			endm  
# End of macro DMARK
5084						CALLMONITOR 
5084 cd f3 18			call break_point_state  
5087				endm  
# End of macro CALLMONITOR
5087					endif 
5087			 
5087				; check for empty drive 
5087			 
5087 3e 00			ld a, 0 
5089 b8				cp b 
508a ca f8 50			jp z, .dirdone 
508d			 
508d				; for each of the current ids do a search for them and if found push to stack 
508d			 
508d c5			.diritem:	push bc 
508e 21 40 00				ld hl, STORE_BLOCK_PHY 
5091 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
5093 58					ld e,b 
5094			 
5094			;		if DEBUG_FORTH_WORDS 
5094			;			DMARK "DI2" 
5094			;			CALLMONITOR 
5094			;		endif 
5094			 
5094 cd 4f 07				call storage_findnextid 
5097			 
5097			;		if DEBUG_FORTH_WORDS 
5097			;			DMARK "DI3" 
5097			;			CALLMONITOR 
5097			;		endif 
5097			 
5097					; if found hl will be non zero 
5097			 
5097 cd 75 0f				call ishlzero 
509a			;		ld a, l 
509a			;		add h 
509a			; 
509a			;		cp 0 
509a 28 59				jr z, .dirnotfound 
509c			 
509c					; increase count 
509c			 
509c c1					pop bc	 
509d 0c					inc c 
509e c5					push bc 
509f					 
509f			 
509f					; get file header and push the file name 
509f			 
509f 11 81 fa				ld de, store_page 
50a2 cd 1c 04				call storage_read_block 
50a5			 
50a5					; push file id to stack 
50a5				 
50a5 3a 81 fa				ld a, (store_page) 
50a8 26 00				ld h, 0 
50aa 6f					ld l, a 
50ab cd 67 1f				call forth_push_numhl 
50ae			 
50ae					; push extent count to stack  
50ae				 
50ae 3a 83 fa				ld a, (store_page+2) 
50b1 26 00				ld h, 0 
50b3 6f					ld l, a 
50b4 cd 67 1f				call forth_push_numhl 
50b7			 
50b7					; push file name 
50b7			 
50b7 21 84 fa				ld hl, store_page+3 
50ba					if DEBUG_FORTH_WORDS 
50ba						DMARK "DI5" 
50ba f5				push af  
50bb 3a cf 50			ld a, (.dmark)  
50be 32 6e fe			ld (debug_mark),a  
50c1 3a d0 50			ld a, (.dmark+1)  
50c4 32 6f fe			ld (debug_mark+1),a  
50c7 3a d1 50			ld a, (.dmark+2)  
50ca 32 70 fe			ld (debug_mark+2),a  
50cd 18 03			jr .pastdmark  
50cf ..			.dmark: db "DI5"  
50d2 f1			.pastdmark: pop af  
50d3			endm  
# End of macro DMARK
50d3						CALLMONITOR 
50d3 cd f3 18			call break_point_state  
50d6				endm  
# End of macro CALLMONITOR
50d6					endif 
50d6 cd d5 1f				call forth_push_str 
50d9					if DEBUG_FORTH_WORDS 
50d9						DMARK "DI6" 
50d9 f5				push af  
50da 3a ee 50			ld a, (.dmark)  
50dd 32 6e fe			ld (debug_mark),a  
50e0 3a ef 50			ld a, (.dmark+1)  
50e3 32 6f fe			ld (debug_mark+1),a  
50e6 3a f0 50			ld a, (.dmark+2)  
50e9 32 70 fe			ld (debug_mark+2),a  
50ec 18 03			jr .pastdmark  
50ee ..			.dmark: db "DI6"  
50f1 f1			.pastdmark: pop af  
50f2			endm  
# End of macro DMARK
50f2						CALLMONITOR 
50f2 cd f3 18			call break_point_state  
50f5				endm  
# End of macro CALLMONITOR
50f5					endif 
50f5			.dirnotfound: 
50f5 c1					pop bc     
50f6 10 95				djnz .diritem 
50f8				 
50f8			.dirdone:	 
50f8					if DEBUG_FORTH_WORDS 
50f8						DMARK "DI7" 
50f8 f5				push af  
50f9 3a 0d 51			ld a, (.dmark)  
50fc 32 6e fe			ld (debug_mark),a  
50ff 3a 0e 51			ld a, (.dmark+1)  
5102 32 6f fe			ld (debug_mark+1),a  
5105 3a 0f 51			ld a, (.dmark+2)  
5108 32 70 fe			ld (debug_mark+2),a  
510b 18 03			jr .pastdmark  
510d ..			.dmark: db "DI7"  
5110 f1			.pastdmark: pop af  
5111			endm  
# End of macro DMARK
5111						CALLMONITOR 
5111 cd f3 18			call break_point_state  
5114				endm  
# End of macro CALLMONITOR
5114					endif 
5114			 
5114					; push a count of the dir items found 
5114			 
5114 26 00				ld h, 0 
5116 69					ld l, c 
5117 cd 67 1f				call forth_push_numhl 
511a			 
511a					; push the bank label 
511a			 
511a cd cd 04				call storage_get_block_0 
511d			 
511d				 
511d 21 84 fa		 		ld hl, store_page+3 
5120			 
5120					if DEBUG_FORTH_WORDS 
5120						DMARK "DI8" 
5120 f5				push af  
5121 3a 35 51			ld a, (.dmark)  
5124 32 6e fe			ld (debug_mark),a  
5127 3a 36 51			ld a, (.dmark+1)  
512a 32 6f fe			ld (debug_mark+1),a  
512d 3a 37 51			ld a, (.dmark+2)  
5130 32 70 fe			ld (debug_mark+2),a  
5133 18 03			jr .pastdmark  
5135 ..			.dmark: db "DI8"  
5138 f1			.pastdmark: pop af  
5139			endm  
# End of macro DMARK
5139						CALLMONITOR 
5139 cd f3 18			call break_point_state  
513c				endm  
# End of macro CALLMONITOR
513c					endif 
513c cd d5 1f				call forth_push_str 
513f			 
513f			 
513f				 
513f					NEXTW 
513f c3 14 23			jp macro_next 
5142				endm 
# End of macro NEXTW
5142			.SAVE: 
5142			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
5142			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
5142			;		NEXTW 
5142			;.LOAD: 
5142			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
5142			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
5142			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
5142			;; > > The LOAD command can not be used in any user words or compound lines. 
5142			; 
5142			;		; store_openext use it. If zero it is EOF 
5142			; 
5142			;		; read block from current stream id 
5142			;		; if the block does not contain zero term keep reading blocks until zero found 
5142			;		; push the block to stack 
5142			;		; save the block id to stream 
5142			; 
5142			; 
5142			;		FORTH_DSP_VALUEHL 
5142			; 
5142			;;		push hl 
5142			; 
5142			;	if DEBUG_STORESE 
5142			;		DMARK "LOA" 
5142			;		CALLMONITOR 
5142			;	endif 
5142			;		FORTH_DSP_POP 
5142			; 
5142			;;		pop hl 
5142			; 
5142			;		ld h, l 
5142			;		ld l, 0 
5142			; 
5142			;		push hl     ; stack holds current file id and extent to work with 
5142			; 
5142			; 
5142			;		ld de, store_page      ; get block zero of file 
5142			;	if DEBUG_STORESE 
5142			;		DMARK "LO0" 
5142			;		CALLMONITOR 
5142			;	endif 
5142			;		call storage_read 
5142			; 
5142			;		ld a, (store_page+2)    ; max extents for this file 
5142			;		ld  (store_openmaxext),a   ; get our limit 
5142			; 
5142			;	if DEBUG_STORESE 
5142			;		DMARK "LOE" 
5142			;		CALLMONITOR 
5142			;	endif 
5142			; 
5142			;; TODO dont know why max extents are not present 
5142			;;		cp 0 
5142			;;		jp z, .loadeof     ; dont read past eof 
5142			; 
5142			;;		ld a, 1   ; start from the head of the file 
5142			; 
5142			;.loadline:	pop hl 
5142			;		inc hl 
5142			;		ld  a, (store_openmaxext)   ; get our limit 
5142			;	if DEBUG_STORESE 
5142			;		DMARK "LOx" 
5142			;		CALLMONITOR 
5142			;	endif 
5142			;		inc a 
5142			;		cp l 
5142			;		jp z, .loadeof 
5142			;		push hl    ; save current extent 
5142			; 
5142			;		ld de, store_page 
5142			; 
5142			;	if DEBUG_STORESE 
5142			;		DMARK "LO1" 
5142			;		CALLMONITOR 
5142			;	endif 
5142			;		call storage_read 
5142			; 
5142			;	if DEBUG_STORESE 
5142			;		DMARK "LO2" 
5142			;		CALLMONITOR 
5142			;	endif 
5142			;	call ishlzero 
5142			;	ld a, l 
5142			;	add h 
5142			;	cp 0 
5142			;	jr z, .loadeof 
5142			; 
5142			;	; not eof so hl should point to data to exec 
5142			; 
5142			;	; will need to add the FORTH_END_BUFFER flag 
5142			 ; 
5142			;	ld hl, store_page+2 
5142			;	ld bc, 255 
5142			;	ld a, 0 
5142			;	cpir 
5142			;	if DEBUG_STORESE 
5142			;		DMARK "LOt" 
5142			;		CALLMONITOR 
5142			;	endif 
5142			;	dec hl 
5142			;	ld a, ' ' 
5142			;	ld (hl), a 
5142			;	inc hl 
5142			;	ld (hl), a 
5142			;	inc hl 
5142			;	ld (hl), a 
5142			;	inc hl 
5142			;	ld a, FORTH_END_BUFFER 
5142			;	ld (hl), a 
5142			; 
5142			;	; TODO handle more than a single block read 
5142			; 
5142			; 
5142			;	ld hl, store_page+2 
5142			; 
5142			;	ld (os_tok_ptr), hl 
5142			; 
5142			;	if DEBUG_STORESE 
5142			;		DMARK "LO3" 
5142			;		CALLMONITOR 
5142			;	endif 
5142			; 
5142			;	call forthparse 
5142			;	call forthexec 
5142			;	call forthexec_cleanup 
5142			; 
5142			;	; go to next extent 
5142			; 
5142			;	; get next block  or mark as eof 
5142			;	jp .loadline 
5142			; 
5142			; 
5142			; 
5142			;	       NEXTW 
5142			;.loadeof:	ld a, 0 
5142			;		ld (store_openext), a 
5142			; 
5142			;	if DEBUG_STORESE 
5142			;		DMARK "LOF" 
5142			;		CALLMONITOR 
5142			;	endif 
5142			;		ret 
5142			;		;NEXTW 
5142			;.BSAVE:   
5142			; 
5142			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
5142			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
5142			;		NEXTW 
5142			;.BLOAD: 
5142			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
5142			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
5142			;		NEXTW 
5142			;;;; counter gap 
5142			 
5142			 
5142			.SEO: 
5142				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
5142 64				db WORD_SYS_CORE+80             
5143 61 51			dw .SEI            
5145 04				db 3 + 1 
5146 .. 00			db "SEO",0              
514a				endm 
# End of macro CWHEAD
514a			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
514a			 
514a					; get port 
514a			 
514a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
514a cd 5e 21			call macro_dsp_valuehl 
514d				endm 
# End of macro FORTH_DSP_VALUEHL
514d			 
514d e5					push hl    ; u2 - byte 
514e			 
514e					; destroy value TOS 
514e			 
514e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
514e cd 16 22			call macro_forth_dsp_pop 
5151				endm 
# End of macro FORTH_DSP_POP
5151			 
5151					; get byte to send 
5151			 
5151					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5151 cd 5e 21			call macro_dsp_valuehl 
5154				endm 
# End of macro FORTH_DSP_VALUEHL
5154			 
5154 e5					push hl    ; u1 - addr 
5155			 
5155					; destroy value TOS 
5155			 
5155					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5155 cd 16 22			call macro_forth_dsp_pop 
5158				endm 
# End of macro FORTH_DSP_POP
5158			 
5158					; one value on hl get other one back 
5158			 
5158 d1					pop de   ; u1 - byte 
5159			 
5159 e1					pop hl   ; u2 - addr 
515a			 
515a					; TODO Send SPI byte 
515a			 
515a			 
515a 7b					ld a, e 
515b cd 21 02				call se_writebyte 
515e			 
515e					 
515e			 
515e					NEXTW 
515e c3 14 23			jp macro_next 
5161				endm 
# End of macro NEXTW
5161			 
5161			.SEI: 
5161				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
5161 65				db WORD_SYS_CORE+81             
5162 7b 51			dw .SFREE            
5164 04				db 3 + 1 
5165 .. 00			db "SEI",0              
5169				endm 
# End of macro CWHEAD
5169			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5169			 
5169					; get port 
5169			 
5169					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5169 cd 5e 21			call macro_dsp_valuehl 
516c				endm 
# End of macro FORTH_DSP_VALUEHL
516c			 
516c			;		push hl 
516c			 
516c					; destroy value TOS 
516c			 
516c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
516c cd 16 22			call macro_forth_dsp_pop 
516f				endm 
# End of macro FORTH_DSP_POP
516f			 
516f					; one value on hl get other one back 
516f			 
516f			;		pop hl 
516f			 
516f			 
516f					; TODO Get SPI byte 
516f			 
516f cd c3 02				call se_readbyte 
5172			 
5172 26 00				ld h, 0 
5174 6f					ld l, a 
5175 cd 67 1f				call forth_push_numhl 
5178			 
5178					NEXTW 
5178 c3 14 23			jp macro_next 
517b				endm 
# End of macro NEXTW
517b			 
517b			.SFREE: 
517b				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
517b 67				db WORD_SYS_CORE+83             
517c aa 51			dw .SIZE            
517e 06				db 5 + 1 
517f .. 00			db "FFREE",0              
5185				endm 
# End of macro CWHEAD
5185			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
5185			; | | Compatible with PicoSPINet  
5185					if DEBUG_FORTH_WORDS_KEY 
5185						DMARK "FFR" 
5185 f5				push af  
5186 3a 9a 51			ld a, (.dmark)  
5189 32 6e fe			ld (debug_mark),a  
518c 3a 9b 51			ld a, (.dmark+1)  
518f 32 6f fe			ld (debug_mark+1),a  
5192 3a 9c 51			ld a, (.dmark+2)  
5195 32 70 fe			ld (debug_mark+2),a  
5198 18 03			jr .pastdmark  
519a ..			.dmark: db "FFR"  
519d f1			.pastdmark: pop af  
519e			endm  
# End of macro DMARK
519e						CALLMONITOR 
519e cd f3 18			call break_point_state  
51a1				endm  
# End of macro CALLMONITOR
51a1					endif 
51a1			 
51a1 cd e9 07				call storage_freeblocks 
51a4			 
51a4 cd 67 1f				call forth_push_numhl 
51a7			 
51a7				       NEXTW 
51a7 c3 14 23			jp macro_next 
51aa				endm 
# End of macro NEXTW
51aa			.SIZE: 
51aa				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
51aa 67				db WORD_SYS_CORE+83             
51ab de 51			dw .CREATE            
51ad 05				db 4 + 1 
51ae .. 00			db "SIZE",0              
51b3				endm 
# End of macro CWHEAD
51b3			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
51b3			; | | Compatible with PicoSPINet  
51b3					if DEBUG_FORTH_WORDS_KEY 
51b3						DMARK "SIZ" 
51b3 f5				push af  
51b4 3a c8 51			ld a, (.dmark)  
51b7 32 6e fe			ld (debug_mark),a  
51ba 3a c9 51			ld a, (.dmark+1)  
51bd 32 6f fe			ld (debug_mark+1),a  
51c0 3a ca 51			ld a, (.dmark+2)  
51c3 32 70 fe			ld (debug_mark+2),a  
51c6 18 03			jr .pastdmark  
51c8 ..			.dmark: db "SIZ"  
51cb f1			.pastdmark: pop af  
51cc			endm  
# End of macro DMARK
51cc						CALLMONITOR 
51cc cd f3 18			call break_point_state  
51cf				endm  
# End of macro CALLMONITOR
51cf					endif 
51cf			 
51cf					FORTH_DSP_VALUEHL 
51cf cd 5e 21			call macro_dsp_valuehl 
51d2				endm 
# End of macro FORTH_DSP_VALUEHL
51d2			;		push hl 
51d2					FORTH_DSP_POP 
51d2 cd 16 22			call macro_forth_dsp_pop 
51d5				endm 
# End of macro FORTH_DSP_POP
51d5			;		pop hl 
51d5 cd 4b 04				call storage_file_size 
51d8			 
51d8 cd 67 1f				call forth_push_numhl 
51db			  
51db			 
51db				       NEXTW 
51db c3 14 23			jp macro_next 
51de				endm 
# End of macro NEXTW
51de			 
51de			.CREATE: 
51de				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
51de 68				db WORD_SYS_CORE+84             
51df 4c 52			dw .APPEND            
51e1 07				db 6 + 1 
51e2 .. 00			db "CREATE",0              
51e9				endm 
# End of macro CWHEAD
51e9			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
51e9			; | | e.g.  
51e9			; | | TestProgram CREATE 
51e9			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
51e9			; | |  
51e9			; | | Max file IDs are 255. 
51e9			; | |  
51e9			; | | Compatible with PicoSPINet  
51e9					 
51e9					if DEBUG_FORTH_WORDS_KEY 
51e9						DMARK "CRT" 
51e9 f5				push af  
51ea 3a fe 51			ld a, (.dmark)  
51ed 32 6e fe			ld (debug_mark),a  
51f0 3a ff 51			ld a, (.dmark+1)  
51f3 32 6f fe			ld (debug_mark+1),a  
51f6 3a 00 52			ld a, (.dmark+2)  
51f9 32 70 fe			ld (debug_mark+2),a  
51fc 18 03			jr .pastdmark  
51fe ..			.dmark: db "CRT"  
5201 f1			.pastdmark: pop af  
5202			endm  
# End of macro DMARK
5202						CALLMONITOR 
5202 cd f3 18			call break_point_state  
5205				endm  
# End of macro CALLMONITOR
5205					endif 
5205			;		call storage_get_block_0 
5205			 
5205					; TODO pop hl 
5205			 
5205					;v5 FORTH_DSP_VALUE 
5205					FORTH_DSP_VALUE 
5205 cd 47 21			call macro_forth_dsp_value 
5208				endm 
# End of macro FORTH_DSP_VALUE
5208			 
5208				if DEBUG_STORESE 
5208					DMARK "CR1" 
5208 f5				push af  
5209 3a 1d 52			ld a, (.dmark)  
520c 32 6e fe			ld (debug_mark),a  
520f 3a 1e 52			ld a, (.dmark+1)  
5212 32 6f fe			ld (debug_mark+1),a  
5215 3a 1f 52			ld a, (.dmark+2)  
5218 32 70 fe			ld (debug_mark+2),a  
521b 18 03			jr .pastdmark  
521d ..			.dmark: db "CR1"  
5220 f1			.pastdmark: pop af  
5221			endm  
# End of macro DMARK
5221					CALLMONITOR 
5221 cd f3 18			call break_point_state  
5224				endm  
# End of macro CALLMONITOR
5224				endif 
5224			;		push hl 
5224			;		FORTH_DSP_POP 
5224			;		pop hl 
5224			 
5224			;		inc hl   ; move past the type marker 
5224			 
5224 cd 1f 08				call storage_create 
5227			 
5227				if DEBUG_STORESE 
5227					DMARK "CT1" 
5227 f5				push af  
5228 3a 3c 52			ld a, (.dmark)  
522b 32 6e fe			ld (debug_mark),a  
522e 3a 3d 52			ld a, (.dmark+1)  
5231 32 6f fe			ld (debug_mark+1),a  
5234 3a 3e 52			ld a, (.dmark+2)  
5237 32 70 fe			ld (debug_mark+2),a  
523a 18 03			jr .pastdmark  
523c ..			.dmark: db "CT1"  
523f f1			.pastdmark: pop af  
5240			endm  
# End of macro DMARK
5240					CALLMONITOR 
5240 cd f3 18			call break_point_state  
5243				endm  
# End of macro CALLMONITOR
5243				endif 
5243			;		push hl 
5243					FORTH_DSP_POP 
5243 cd 16 22			call macro_forth_dsp_pop 
5246				endm 
# End of macro FORTH_DSP_POP
5246			;		pop hl 
5246					; push file id to stack 
5246 cd 67 1f				call forth_push_numhl 
5249			 
5249			 
5249			 
5249				       NEXTW 
5249 c3 14 23			jp macro_next 
524c				endm 
# End of macro NEXTW
524c			 
524c			.APPEND: 
524c				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
524c 69				db WORD_SYS_CORE+85             
524d dd 52			dw .SDEL            
524f 07				db 6 + 1 
5250 .. 00			db "APPEND",0              
5257				endm 
# End of macro CWHEAD
5257			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5257			; | | e.g. 
5257			; | | Test CREATE      -> $01 
5257			; | | "A string to add to file" $01 APPEND 
5257			; | |  
5257			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5257			; | | Compatible with PicoSPINet  
5257					if DEBUG_FORTH_WORDS_KEY 
5257						DMARK "APP" 
5257 f5				push af  
5258 3a 6c 52			ld a, (.dmark)  
525b 32 6e fe			ld (debug_mark),a  
525e 3a 6d 52			ld a, (.dmark+1)  
5261 32 6f fe			ld (debug_mark+1),a  
5264 3a 6e 52			ld a, (.dmark+2)  
5267 32 70 fe			ld (debug_mark+2),a  
526a 18 03			jr .pastdmark  
526c ..			.dmark: db "APP"  
526f f1			.pastdmark: pop af  
5270			endm  
# End of macro DMARK
5270						CALLMONITOR 
5270 cd f3 18			call break_point_state  
5273				endm  
# End of macro CALLMONITOR
5273					endif 
5273			 
5273					FORTH_DSP_VALUEHL 
5273 cd 5e 21			call macro_dsp_valuehl 
5276				endm 
# End of macro FORTH_DSP_VALUEHL
5276 e5					push hl 	; save file id 
5277			 
5277				if DEBUG_STORESE 
5277					DMARK "AP1" 
5277 f5				push af  
5278 3a 8c 52			ld a, (.dmark)  
527b 32 6e fe			ld (debug_mark),a  
527e 3a 8d 52			ld a, (.dmark+1)  
5281 32 6f fe			ld (debug_mark+1),a  
5284 3a 8e 52			ld a, (.dmark+2)  
5287 32 70 fe			ld (debug_mark+2),a  
528a 18 03			jr .pastdmark  
528c ..			.dmark: db "AP1"  
528f f1			.pastdmark: pop af  
5290			endm  
# End of macro DMARK
5290					CALLMONITOR 
5290 cd f3 18			call break_point_state  
5293				endm  
# End of macro CALLMONITOR
5293				endif 
5293					FORTH_DSP_POP 
5293 cd 16 22			call macro_forth_dsp_pop 
5296				endm 
# End of macro FORTH_DSP_POP
5296			 
5296					FORTH_DSP_VALUEHL 
5296 cd 5e 21			call macro_dsp_valuehl 
5299				endm 
# End of macro FORTH_DSP_VALUEHL
5299					;v5 FORTH_DSP_VALUE 
5299 e5					push hl 	; save ptr to string to save 
529a			 
529a				if DEBUG_STORESE 
529a					DMARK "AP1" 
529a f5				push af  
529b 3a af 52			ld a, (.dmark)  
529e 32 6e fe			ld (debug_mark),a  
52a1 3a b0 52			ld a, (.dmark+1)  
52a4 32 6f fe			ld (debug_mark+1),a  
52a7 3a b1 52			ld a, (.dmark+2)  
52aa 32 70 fe			ld (debug_mark+2),a  
52ad 18 03			jr .pastdmark  
52af ..			.dmark: db "AP1"  
52b2 f1			.pastdmark: pop af  
52b3			endm  
# End of macro DMARK
52b3					CALLMONITOR 
52b3 cd f3 18			call break_point_state  
52b6				endm  
# End of macro CALLMONITOR
52b6				endif 
52b6					FORTH_DSP_POP 
52b6 cd 16 22			call macro_forth_dsp_pop 
52b9				endm 
# End of macro FORTH_DSP_POP
52b9			 
52b9 d1					pop de 
52ba e1					pop hl 
52bb				if DEBUG_STORESE 
52bb					DMARK "AP2" 
52bb f5				push af  
52bc 3a d0 52			ld a, (.dmark)  
52bf 32 6e fe			ld (debug_mark),a  
52c2 3a d1 52			ld a, (.dmark+1)  
52c5 32 6f fe			ld (debug_mark+1),a  
52c8 3a d2 52			ld a, (.dmark+2)  
52cb 32 70 fe			ld (debug_mark+2),a  
52ce 18 03			jr .pastdmark  
52d0 ..			.dmark: db "AP2"  
52d3 f1			.pastdmark: pop af  
52d4			endm  
# End of macro DMARK
52d4					CALLMONITOR 
52d4 cd f3 18			call break_point_state  
52d7				endm  
# End of macro CALLMONITOR
52d7				endif 
52d7					;inc de ; skip var type indicator 
52d7			 
52d7					; TODO how to append numerics???? 
52d7			 
52d7 cd 0c 0b				call storage_append		 
52da			 
52da				       NEXTW 
52da c3 14 23			jp macro_next 
52dd				endm 
# End of macro NEXTW
52dd			.SDEL: 
52dd				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
52dd 6a				db WORD_SYS_CORE+86             
52de 29 53			dw .OPEN            
52e0 05				db 4 + 1 
52e1 .. 00			db "ERA",0              
52e5				endm 
# End of macro CWHEAD
52e5			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
52e5			; | | Compatible with PicoSPINet  
52e5					FORTH_DSP_VALUEHL 
52e5 cd 5e 21			call macro_dsp_valuehl 
52e8				endm 
# End of macro FORTH_DSP_VALUEHL
52e8			;		push hl 	; save file id 
52e8			 
52e8					if DEBUG_FORTH_WORDS_KEY 
52e8						DMARK "ERA" 
52e8 f5				push af  
52e9 3a fd 52			ld a, (.dmark)  
52ec 32 6e fe			ld (debug_mark),a  
52ef 3a fe 52			ld a, (.dmark+1)  
52f2 32 6f fe			ld (debug_mark+1),a  
52f5 3a ff 52			ld a, (.dmark+2)  
52f8 32 70 fe			ld (debug_mark+2),a  
52fb 18 03			jr .pastdmark  
52fd ..			.dmark: db "ERA"  
5300 f1			.pastdmark: pop af  
5301			endm  
# End of macro DMARK
5301						CALLMONITOR 
5301 cd f3 18			call break_point_state  
5304				endm  
# End of macro CALLMONITOR
5304					endif 
5304				if DEBUG_STORESE 
5304					DMARK "ER1" 
5304 f5				push af  
5305 3a 19 53			ld a, (.dmark)  
5308 32 6e fe			ld (debug_mark),a  
530b 3a 1a 53			ld a, (.dmark+1)  
530e 32 6f fe			ld (debug_mark+1),a  
5311 3a 1b 53			ld a, (.dmark+2)  
5314 32 70 fe			ld (debug_mark+2),a  
5317 18 03			jr .pastdmark  
5319 ..			.dmark: db "ER1"  
531c f1			.pastdmark: pop af  
531d			endm  
# End of macro DMARK
531d					CALLMONITOR 
531d cd f3 18			call break_point_state  
5320				endm  
# End of macro CALLMONITOR
5320				endif 
5320					FORTH_DSP_POP 
5320 cd 16 22			call macro_forth_dsp_pop 
5323				endm 
# End of macro FORTH_DSP_POP
5323			 
5323			;		pop hl 
5323			 
5323 cd 5e 06				call storage_erase 
5326				       NEXTW 
5326 c3 14 23			jp macro_next 
5329				endm 
# End of macro NEXTW
5329			 
5329			.OPEN: 
5329				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
5329 6b				db WORD_SYS_CORE+87             
532a bd 53			dw .READ            
532c 05				db 4 + 1 
532d .. 00			db "OPEN",0              
5332				endm 
# End of macro CWHEAD
5332			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
5332			; | | e.g. 
5332			; | | $01 OPEN $01 DO $01 READ . LOOP 
5332			; | | 
5332			; | | Will return with 255 blocks if the file does not exist 
5332			; | | Compatible with PicoSPINet  
5332			 
5332					if DEBUG_FORTH_WORDS_KEY 
5332						DMARK "OPN" 
5332 f5				push af  
5333 3a 47 53			ld a, (.dmark)  
5336 32 6e fe			ld (debug_mark),a  
5339 3a 48 53			ld a, (.dmark+1)  
533c 32 6f fe			ld (debug_mark+1),a  
533f 3a 49 53			ld a, (.dmark+2)  
5342 32 70 fe			ld (debug_mark+2),a  
5345 18 03			jr .pastdmark  
5347 ..			.dmark: db "OPN"  
534a f1			.pastdmark: pop af  
534b			endm  
# End of macro DMARK
534b						CALLMONITOR 
534b cd f3 18			call break_point_state  
534e				endm  
# End of macro CALLMONITOR
534e					endif 
534e					; TODO handle multiple file opens 
534e			 
534e 3e 01			       	ld a, 1 
5350 32 71 fa				ld (store_openext), a 
5353			 
5353					; get max extents for this file 
5353				 
5353								 
5353					FORTH_DSP_VALUEHL 
5353 cd 5e 21			call macro_dsp_valuehl 
5356				endm 
# End of macro FORTH_DSP_VALUEHL
5356			 
5356 65					ld h, l 
5357 2e 00				ld l, 0 
5359			 
5359					; store file id 
5359			 
5359 7c					ld a, h 
535a 32 6e fa				ld (store_filecache), a 
535d			 
535d				if DEBUG_STORESE 
535d					DMARK "OPN" 
535d f5				push af  
535e 3a 72 53			ld a, (.dmark)  
5361 32 6e fe			ld (debug_mark),a  
5364 3a 73 53			ld a, (.dmark+1)  
5367 32 6f fe			ld (debug_mark+1),a  
536a 3a 74 53			ld a, (.dmark+2)  
536d 32 70 fe			ld (debug_mark+2),a  
5370 18 03			jr .pastdmark  
5372 ..			.dmark: db "OPN"  
5375 f1			.pastdmark: pop af  
5376			endm  
# End of macro DMARK
5376					CALLMONITOR 
5376 cd f3 18			call break_point_state  
5379				endm  
# End of macro CALLMONITOR
5379				endif 
5379			;		push hl 
5379					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5379 cd 16 22			call macro_forth_dsp_pop 
537c				endm 
# End of macro FORTH_DSP_POP
537c			;		pop hl 
537c						 
537c 11 81 fa				ld de, store_page      ; get block zero of file 
537f cd 75 09				call storage_read 
5382 cd 75 0f			call ishlzero 
5385 20 04			jr nz, .opfound 
5387			 
5387				; file does not exist so indicate with 255 extents in use 
5387			 
5387 3e ff			ld a, 255 
5389 18 29			jr .skipopeneof 
538b			 
538b			 
538b			.opfound: 
538b			 
538b			 
538b 3a 83 fa				ld a, (store_page+2)    ; max extents for this file 
538e 32 70 fa				ld  (store_openmaxext), a   ; get our limit and push 
5391					 
5391				if DEBUG_STORESE 
5391					DMARK "OPx" 
5391 f5				push af  
5392 3a a6 53			ld a, (.dmark)  
5395 32 6e fe			ld (debug_mark),a  
5398 3a a7 53			ld a, (.dmark+1)  
539b 32 6f fe			ld (debug_mark+1),a  
539e 3a a8 53			ld a, (.dmark+2)  
53a1 32 70 fe			ld (debug_mark+2),a  
53a4 18 03			jr .pastdmark  
53a6 ..			.dmark: db "OPx"  
53a9 f1			.pastdmark: pop af  
53aa			endm  
# End of macro DMARK
53aa					CALLMONITOR 
53aa cd f3 18			call break_point_state  
53ad				endm  
# End of macro CALLMONITOR
53ad				endif 
53ad fe 00				cp 0 
53af 20 03				jr nz, .skipopeneof 
53b1					; have opened an empty file 
53b1					 
53b1 32 71 fa				ld (store_openext), a 
53b4			 
53b4			.skipopeneof: 
53b4			 
53b4 6f					ld l, a 
53b5 26 00				ld h, 0 
53b7 cd 67 1f				call forth_push_numhl 
53ba			 
53ba			 
53ba				       NEXTW 
53ba c3 14 23			jp macro_next 
53bd				endm 
# End of macro NEXTW
53bd			.READ: 
53bd				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
53bd 6c				db WORD_SYS_CORE+88             
53be e7 54			dw .EOF            
53c0 05				db 4 + 1 
53c1 .. 00			db "READ",0              
53c6				endm 
# End of macro CWHEAD
53c6			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
53c6			; | | e.g. 
53c6			; | | $01 OPEN $01 DO READ . LOOP 
53c6			; | | 
53c6			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
53c6			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
53c6			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
53c6			; | | two bytes contain the file id and extent. 
53c6			; | |  
53c6			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
53c6			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
53c6			; | | Compatible with PicoSPINet  
53c6			 
53c6					if DEBUG_FORTH_WORDS_KEY 
53c6						DMARK "REA" 
53c6 f5				push af  
53c7 3a db 53			ld a, (.dmark)  
53ca 32 6e fe			ld (debug_mark),a  
53cd 3a dc 53			ld a, (.dmark+1)  
53d0 32 6f fe			ld (debug_mark+1),a  
53d3 3a dd 53			ld a, (.dmark+2)  
53d6 32 70 fe			ld (debug_mark+2),a  
53d9 18 03			jr .pastdmark  
53db ..			.dmark: db "REA"  
53de f1			.pastdmark: pop af  
53df			endm  
# End of macro DMARK
53df						CALLMONITOR 
53df cd f3 18			call break_point_state  
53e2				endm  
# End of macro CALLMONITOR
53e2					endif 
53e2					; store_openext use it. If zero it is EOF 
53e2			 
53e2					; read block from current stream id 
53e2					; if the block does not contain zero term keep reading blocks until zero found 
53e2					; push the block to stack 
53e2					; save the block id to stream 
53e2			 
53e2			 
53e2 cd 14 55				call .testeof 
53e5 3e 01				ld a, 1 
53e7 bd					cp l 
53e8 ca c3 54				jp z, .ateof 
53eb			 
53eb			 
53eb			;		FORTH_DSP_VALUEHL 
53eb			 
53eb			;		push hl 
53eb			 
53eb			;	if DEBUG_STORESE 
53eb			;		DMARK "REA" 
53eb			;		CALLMONITOR 
53eb			;	endif 
53eb			;		FORTH_DSP_POP 
53eb			 
53eb			;		pop hl 
53eb				 
53eb 3a 6e fa				ld a, (store_filecache) 
53ee 67					ld h,a 
53ef			 
53ef 3a 71 fa				ld a, (store_openext) 
53f2 6f					ld l, a 
53f3					 
53f3 fe 00				cp 0 
53f5 ca c3 54				jp z, .ateof     ; dont read past eof 
53f8			 
53f8 cd 58 0c				call storage_clear_page 
53fb			 
53fb 11 81 fa				ld de, store_page 
53fe				if DEBUG_STORESE 
53fe					DMARK "RE1" 
53fe f5				push af  
53ff 3a 13 54			ld a, (.dmark)  
5402 32 6e fe			ld (debug_mark),a  
5405 3a 14 54			ld a, (.dmark+1)  
5408 32 6f fe			ld (debug_mark+1),a  
540b 3a 15 54			ld a, (.dmark+2)  
540e 32 70 fe			ld (debug_mark+2),a  
5411 18 03			jr .pastdmark  
5413 ..			.dmark: db "RE1"  
5416 f1			.pastdmark: pop af  
5417			endm  
# End of macro DMARK
5417					CALLMONITOR 
5417 cd f3 18			call break_point_state  
541a				endm  
# End of macro CALLMONITOR
541a				endif 
541a cd 75 09				call storage_read 
541d			 
541d				if DEBUG_STORESE 
541d					DMARK "RE2" 
541d f5				push af  
541e 3a 32 54			ld a, (.dmark)  
5421 32 6e fe			ld (debug_mark),a  
5424 3a 33 54			ld a, (.dmark+1)  
5427 32 6f fe			ld (debug_mark+1),a  
542a 3a 34 54			ld a, (.dmark+2)  
542d 32 70 fe			ld (debug_mark+2),a  
5430 18 03			jr .pastdmark  
5432 ..			.dmark: db "RE2"  
5435 f1			.pastdmark: pop af  
5436			endm  
# End of macro DMARK
5436					CALLMONITOR 
5436 cd f3 18			call break_point_state  
5439				endm  
# End of macro CALLMONITOR
5439				endif 
5439 cd 75 0f			call ishlzero 
543c			;	ld a, l 
543c			;	add h 
543c			;	cp 0 
543c ca c3 54			jp z, .readeof 
543f			 
543f				; not eof so hl should point to data to push to stack 
543f			 
543f				if DEBUG_STORESE 
543f					DMARK "RE3" 
543f f5				push af  
5440 3a 54 54			ld a, (.dmark)  
5443 32 6e fe			ld (debug_mark),a  
5446 3a 55 54			ld a, (.dmark+1)  
5449 32 6f fe			ld (debug_mark+1),a  
544c 3a 56 54			ld a, (.dmark+2)  
544f 32 70 fe			ld (debug_mark+2),a  
5452 18 03			jr .pastdmark  
5454 ..			.dmark: db "RE3"  
5457 f1			.pastdmark: pop af  
5458			endm  
# End of macro DMARK
5458					CALLMONITOR 
5458 cd f3 18			call break_point_state  
545b				endm  
# End of macro CALLMONITOR
545b				endif 
545b cd d5 1f			call forth_push_str 
545e			 
545e				if DEBUG_STORESE 
545e					DMARK "RE4" 
545e f5				push af  
545f 3a 73 54			ld a, (.dmark)  
5462 32 6e fe			ld (debug_mark),a  
5465 3a 74 54			ld a, (.dmark+1)  
5468 32 6f fe			ld (debug_mark+1),a  
546b 3a 75 54			ld a, (.dmark+2)  
546e 32 70 fe			ld (debug_mark+2),a  
5471 18 03			jr .pastdmark  
5473 ..			.dmark: db "RE4"  
5476 f1			.pastdmark: pop af  
5477			endm  
# End of macro DMARK
5477					CALLMONITOR 
5477 cd f3 18			call break_point_state  
547a				endm  
# End of macro CALLMONITOR
547a				endif 
547a				; get next block  or mark as eof 
547a			 
547a 3a 70 fa			ld a, (store_openmaxext)   ; get our limit 
547d 4f				ld c, a	 
547e 3a 71 fa			ld a, (store_openext) 
5481			 
5481				if DEBUG_STORESE 
5481					DMARK "RE5" 
5481 f5				push af  
5482 3a 96 54			ld a, (.dmark)  
5485 32 6e fe			ld (debug_mark),a  
5488 3a 97 54			ld a, (.dmark+1)  
548b 32 6f fe			ld (debug_mark+1),a  
548e 3a 98 54			ld a, (.dmark+2)  
5491 32 70 fe			ld (debug_mark+2),a  
5494 18 03			jr .pastdmark  
5496 ..			.dmark: db "RE5"  
5499 f1			.pastdmark: pop af  
549a			endm  
# End of macro DMARK
549a					CALLMONITOR 
549a cd f3 18			call break_point_state  
549d				endm  
# End of macro CALLMONITOR
549d				endif 
549d b9				cp c 
549e 28 23			jr z, .readeof     ; at last extent 
54a0			 
54a0 3c					inc a 
54a1 32 71 fa				ld (store_openext), a 
54a4			 
54a4				if DEBUG_STORESE 
54a4					DMARK "RE6" 
54a4 f5				push af  
54a5 3a b9 54			ld a, (.dmark)  
54a8 32 6e fe			ld (debug_mark),a  
54ab 3a ba 54			ld a, (.dmark+1)  
54ae 32 6f fe			ld (debug_mark+1),a  
54b1 3a bb 54			ld a, (.dmark+2)  
54b4 32 70 fe			ld (debug_mark+2),a  
54b7 18 03			jr .pastdmark  
54b9 ..			.dmark: db "RE6"  
54bc f1			.pastdmark: pop af  
54bd			endm  
# End of macro DMARK
54bd					CALLMONITOR 
54bd cd f3 18			call break_point_state  
54c0				endm  
# End of macro CALLMONITOR
54c0				endif 
54c0			 
54c0			 
54c0				       NEXTW 
54c0 c3 14 23			jp macro_next 
54c3				endm 
# End of macro NEXTW
54c3			.ateof: 
54c3				;	ld hl, .showeof 
54c3				;	call forth_push_str 
54c3 3e 00		.readeof:	ld a, 0 
54c5 32 71 fa				ld (store_openext), a 
54c8			 
54c8					 
54c8				if DEBUG_STORESE 
54c8					DMARK "REF" 
54c8 f5				push af  
54c9 3a dd 54			ld a, (.dmark)  
54cc 32 6e fe			ld (debug_mark),a  
54cf 3a de 54			ld a, (.dmark+1)  
54d2 32 6f fe			ld (debug_mark+1),a  
54d5 3a df 54			ld a, (.dmark+2)  
54d8 32 70 fe			ld (debug_mark+2),a  
54db 18 03			jr .pastdmark  
54dd ..			.dmark: db "REF"  
54e0 f1			.pastdmark: pop af  
54e1			endm  
# End of macro DMARK
54e1					CALLMONITOR 
54e1 cd f3 18			call break_point_state  
54e4				endm  
# End of macro CALLMONITOR
54e4				endif 
54e4				       NEXTW 
54e4 c3 14 23			jp macro_next 
54e7				endm 
# End of macro NEXTW
54e7			 
54e7			;.showeof:   db "eof", 0 
54e7			 
54e7			 
54e7			.EOF: 
54e7				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
54e7 6d				db WORD_SYS_CORE+89             
54e8 29 55			dw .FORMAT            
54ea 04				db 3 + 1 
54eb .. 00			db "EOF",0              
54ef				endm 
# End of macro CWHEAD
54ef			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
54ef			; | | e.g. 
54ef			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
54ef			; | | Compatible with PicoSPINet  
54ef					; TODO if current block id for stream is zero then push true else false 
54ef			 
54ef					if DEBUG_FORTH_WORDS_KEY 
54ef						DMARK "EOF" 
54ef f5				push af  
54f0 3a 04 55			ld a, (.dmark)  
54f3 32 6e fe			ld (debug_mark),a  
54f6 3a 05 55			ld a, (.dmark+1)  
54f9 32 6f fe			ld (debug_mark+1),a  
54fc 3a 06 55			ld a, (.dmark+2)  
54ff 32 70 fe			ld (debug_mark+2),a  
5502 18 03			jr .pastdmark  
5504 ..			.dmark: db "EOF"  
5507 f1			.pastdmark: pop af  
5508			endm  
# End of macro DMARK
5508						CALLMONITOR 
5508 cd f3 18			call break_point_state  
550b				endm  
# End of macro CALLMONITOR
550b					endif 
550b			 
550b					; TODO handlue multiple file streams 
550b			 
550b			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
550b cd 14 55				call .testeof 
550e cd 67 1f				call forth_push_numhl 
5511			 
5511			 
5511				       NEXTW 
5511 c3 14 23			jp macro_next 
5514				endm 
# End of macro NEXTW
5514			 
5514			.testeof: 
5514 2e 01				ld l, 1 
5516 3a 70 fa				ld a, (store_openmaxext) 
5519 fe 00				cp 0 
551b 28 09				jr  z, .eofdone   ; empty file 
551d 3a 71 fa				ld a, (store_openext) 
5520 fe 00				cp 0 
5522 28 02				jr  z, .eofdone 
5524 2e 00				ld l, 0 
5526 26 00		.eofdone:	ld h, 0 
5528 c9					ret 
5529			 
5529			 
5529			 
5529			 
5529			.FORMAT: 
5529				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5529 6d				db WORD_SYS_CORE+89             
552a 7a 55			dw .LABEL            
552c 07				db 6 + 1 
552d .. 00			db "FORMAT",0              
5534				endm 
# End of macro CWHEAD
5534			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5534			; | | Compatible with PicoSPINet  
5534					; TODO if current block id for stream is zero then push true else false 
5534				 
5534				if DEBUG_STORESE 
5534					DMARK "FOR" 
5534 f5				push af  
5535 3a 49 55			ld a, (.dmark)  
5538 32 6e fe			ld (debug_mark),a  
553b 3a 4a 55			ld a, (.dmark+1)  
553e 32 6f fe			ld (debug_mark+1),a  
5541 3a 4b 55			ld a, (.dmark+2)  
5544 32 70 fe			ld (debug_mark+2),a  
5547 18 03			jr .pastdmark  
5549 ..			.dmark: db "FOR"  
554c f1			.pastdmark: pop af  
554d			endm  
# End of macro DMARK
554d					CALLMONITOR 
554d cd f3 18			call break_point_state  
5550				endm  
# End of macro CALLMONITOR
5550				endif 
5550					; Wipes the bank check flags to cause a reformat on next block 0 read 
5550			 
5550 21 01 00				ld hl, 1 
5553 3e 00				ld a, 0 
5555 cd 21 02				call se_writebyte 
5558			 
5558				if DEBUG_STORESE 
5558					DMARK "FO0" 
5558 f5				push af  
5559 3a 6d 55			ld a, (.dmark)  
555c 32 6e fe			ld (debug_mark),a  
555f 3a 6e 55			ld a, (.dmark+1)  
5562 32 6f fe			ld (debug_mark+1),a  
5565 3a 6f 55			ld a, (.dmark+2)  
5568 32 70 fe			ld (debug_mark+2),a  
556b 18 03			jr .pastdmark  
556d ..			.dmark: db "FO0"  
5570 f1			.pastdmark: pop af  
5571			endm  
# End of macro DMARK
5571					CALLMONITOR 
5571 cd f3 18			call break_point_state  
5574				endm  
# End of macro CALLMONITOR
5574				endif 
5574					; force bank init 
5574			 
5574 cd cd 04				call storage_get_block_0 
5577					 
5577				       NEXTW 
5577 c3 14 23			jp macro_next 
557a				endm 
# End of macro NEXTW
557a			.LABEL: 
557a				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
557a 6d				db WORD_SYS_CORE+89             
557b c8 55			dw .STOREPAGE            
557d 06				db 5 + 1 
557e .. 00			db "LABEL",0              
5584				endm 
# End of macro CWHEAD
5584			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5584			; | | Compatible with PicoSPINet  
5584					; TODO test to see if bank is selected 
5584				 
5584					if DEBUG_FORTH_WORDS_KEY 
5584						DMARK "LBL" 
5584 f5				push af  
5585 3a 99 55			ld a, (.dmark)  
5588 32 6e fe			ld (debug_mark),a  
558b 3a 9a 55			ld a, (.dmark+1)  
558e 32 6f fe			ld (debug_mark+1),a  
5591 3a 9b 55			ld a, (.dmark+2)  
5594 32 70 fe			ld (debug_mark+2),a  
5597 18 03			jr .pastdmark  
5599 ..			.dmark: db "LBL"  
559c f1			.pastdmark: pop af  
559d			endm  
# End of macro DMARK
559d						CALLMONITOR 
559d cd f3 18			call break_point_state  
55a0				endm  
# End of macro CALLMONITOR
55a0					endif 
55a0			;	if DEBUG_STORESE 
55a0			;		DMARK "LBL" 
55a0			;		CALLMONITOR 
55a0			;	endif 
55a0					FORTH_DSP_VALUEHL 
55a0 cd 5e 21			call macro_dsp_valuehl 
55a3				endm 
# End of macro FORTH_DSP_VALUEHL
55a3					;v5FORTH_DSP_VALUE 
55a3					 
55a3			;		push hl 
55a3					FORTH_DSP_POP 
55a3 cd 16 22			call macro_forth_dsp_pop 
55a6				endm 
# End of macro FORTH_DSP_POP
55a6			;		pop hl 
55a6			 
55a6			;v5		inc hl   ; move past the type marker 
55a6			 
55a6				if DEBUG_STORESE 
55a6					DMARK "LBl" 
55a6 f5				push af  
55a7 3a bb 55			ld a, (.dmark)  
55aa 32 6e fe			ld (debug_mark),a  
55ad 3a bc 55			ld a, (.dmark+1)  
55b0 32 6f fe			ld (debug_mark+1),a  
55b3 3a bd 55			ld a, (.dmark+2)  
55b6 32 70 fe			ld (debug_mark+2),a  
55b9 18 03			jr .pastdmark  
55bb ..			.dmark: db "LBl"  
55be f1			.pastdmark: pop af  
55bf			endm  
# End of macro DMARK
55bf					CALLMONITOR 
55bf cd f3 18			call break_point_state  
55c2				endm  
# End of macro CALLMONITOR
55c2				endif 
55c2 cd f1 05				call storage_label 
55c5			 
55c5				       NEXTW 
55c5 c3 14 23			jp macro_next 
55c8				endm 
# End of macro NEXTW
55c8			.STOREPAGE: 
55c8				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
55c8 6d				db WORD_SYS_CORE+89             
55c9 fb 55			dw .LABELS            
55cb 0a				db 9 + 1 
55cc .. 00			db "STOREPAGE",0              
55d6				endm 
# End of macro CWHEAD
55d6			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
55d6			; | | Compatible with PicoSPINet  
55d6					; TODO test to see if bank is selected 
55d6				 
55d6					if DEBUG_FORTH_WORDS_KEY 
55d6						DMARK "STP" 
55d6 f5				push af  
55d7 3a eb 55			ld a, (.dmark)  
55da 32 6e fe			ld (debug_mark),a  
55dd 3a ec 55			ld a, (.dmark+1)  
55e0 32 6f fe			ld (debug_mark+1),a  
55e3 3a ed 55			ld a, (.dmark+2)  
55e6 32 70 fe			ld (debug_mark+2),a  
55e9 18 03			jr .pastdmark  
55eb ..			.dmark: db "STP"  
55ee f1			.pastdmark: pop af  
55ef			endm  
# End of macro DMARK
55ef						CALLMONITOR 
55ef cd f3 18			call break_point_state  
55f2				endm  
# End of macro CALLMONITOR
55f2					endif 
55f2			;	if DEBUG_STORESE 
55f2			;		DMARK "STP" 
55f2			;		CALLMONITOR 
55f2			;	endif 
55f2			 
55f2 21 81 fa			ld hl, store_page 
55f5 cd 67 1f			call forth_push_numhl 
55f8			 
55f8			 
55f8				       NEXTW 
55f8 c3 14 23			jp macro_next 
55fb				endm 
# End of macro NEXTW
55fb			.LABELS: 
55fb				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
55fb 6d				db WORD_SYS_CORE+89             
55fc 85 56			dw .SCONST1            
55fe 07				db 6 + 1 
55ff .. 00			db "LABELS",0              
5606				endm 
# End of macro CWHEAD
5606			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
5606			; | | *NOT* Compatible with PicoSPINet  
5606					;  
5606			 
5606					; save the current device selected to restore afterwards 
5606				 
5606 3a 67 fa				ld a, (spi_device) 
5609 f5					push af 
560a			 
560a			 
560a					; run through each of the banks 
560a			 
560a 21 01 00				ld hl, 1 
560d cd 67 1f				call forth_push_numhl 
5610 3e ff				ld a, SPI_CE_HIGH 
5612 cb 87				res SPI_CE0, a 
5614 32 67 fa				ld (spi_device), a 
5617 cd cd 04				call storage_get_block_0 
561a 21 84 fa				ld hl, store_page+3 
561d cd d5 1f				call forth_push_str 
5620			 
5620					 
5620 21 02 00				ld hl, 2 
5623 cd 67 1f				call forth_push_numhl 
5626 3e ff				ld a, SPI_CE_HIGH 
5628 cb 8f				res SPI_CE1, a 
562a 32 67 fa				ld (spi_device), a 
562d cd cd 04				call storage_get_block_0 
5630 21 84 fa				ld hl, store_page+3 
5633 cd d5 1f				call forth_push_str 
5636			 
5636					 
5636 21 03 00				ld hl, 3 
5639 cd 67 1f				call forth_push_numhl 
563c 3e ff				ld a, SPI_CE_HIGH 
563e cb 97				res SPI_CE2, a 
5640 32 67 fa				ld (spi_device), a 
5643 cd cd 04				call storage_get_block_0 
5646 21 84 fa				ld hl, store_page+3 
5649 cd d5 1f				call forth_push_str 
564c			 
564c			 
564c 21 04 00				ld hl, 4 
564f cd 67 1f				call forth_push_numhl 
5652 3e ff				ld a, SPI_CE_HIGH 
5654 cb 9f				res SPI_CE3, a 
5656 32 67 fa				ld (spi_device), a 
5659 cd cd 04				call storage_get_block_0 
565c 21 84 fa				ld hl, store_page+3 
565f cd d5 1f				call forth_push_str 
5662			 
5662					 
5662			 
5662 21 05 00				ld hl, 5 
5665 cd 67 1f				call forth_push_numhl 
5668 3e ff				ld a, SPI_CE_HIGH 
566a cb a7				res SPI_CE4, a 
566c 32 67 fa				ld (spi_device), a 
566f cd cd 04				call storage_get_block_0 
5672 21 84 fa				ld hl, store_page+3 
5675 cd d5 1f				call forth_push_str 
5678			 
5678					 
5678					; push fixed count of storage devices (on board) for now 
5678			 
5678 21 05 00				ld hl, 5 
567b cd 67 1f				call forth_push_numhl 
567e			 
567e					; restore selected device  
567e				 
567e f1					pop af 
567f 32 67 fa				ld (spi_device), a 
5682			 
5682				       NEXTW 
5682 c3 14 23			jp macro_next 
5685				endm 
# End of macro NEXTW
5685			 
5685			.SCONST1: 
5685				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5685 6d				db WORD_SYS_CORE+89             
5686 9c 56			dw .SCONST2            
5688 07				db 6 + 1 
5689 .. 00			db "FILEID",0              
5690				endm 
# End of macro CWHEAD
5690			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5690			; | | Compatible with PicoSPINet  
5690 3a 6e fa				ld a, (store_filecache) 
5693 26 00				ld h, 0 
5695 6f					ld l, a 
5696 cd 67 1f				call forth_push_numhl 
5699					NEXTW 
5699 c3 14 23			jp macro_next 
569c				endm 
# End of macro NEXTW
569c			.SCONST2: 
569c				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
569c 6d				db WORD_SYS_CORE+89             
569d b4 56			dw .SCONST3            
569f 08				db 7 + 1 
56a0 .. 00			db "FILEEXT",0              
56a8				endm 
# End of macro CWHEAD
56a8			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
56a8			; | | Compatible with PicoSPINet  
56a8 3a 71 fa				ld a, (store_openext) 
56ab 26 00				ld h, 0 
56ad 6f					ld l, a 
56ae cd 67 1f				call forth_push_numhl 
56b1					NEXTW 
56b1 c3 14 23			jp macro_next 
56b4				endm 
# End of macro NEXTW
56b4			.SCONST3: 
56b4				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
56b4 6d				db WORD_SYS_CORE+89             
56b5 cc 56			dw .SCONST4            
56b7 08				db 7 + 1 
56b8 .. 00			db "FILEMAX",0              
56c0				endm 
# End of macro CWHEAD
56c0			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
56c0			; | | Compatible with PicoSPINet  
56c0 3a 70 fa				ld a, (store_openmaxext) 
56c3 26 00				ld h, 0 
56c5 6f					ld l, a 
56c6 cd 67 1f				call forth_push_numhl 
56c9					NEXTW 
56c9 c3 14 23			jp macro_next 
56cc				endm 
# End of macro NEXTW
56cc			.SCONST4: 
56cc				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
56cc 6d				db WORD_SYS_CORE+89             
56cd e2 56			dw .SCONST5            
56cf 09				db 8 + 1 
56d0 .. 00			db "FILEADDR",0              
56d9				endm 
# End of macro CWHEAD
56d9			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currenlty open file to stack | DONE 
56d9			; | | Compatible with PicoSPINet  
56d9 2a 72 fa				ld hl, (store_openaddr) 
56dc cd 67 1f				call forth_push_numhl 
56df					NEXTW 
56df c3 14 23			jp macro_next 
56e2				endm 
# End of macro NEXTW
56e2			.SCONST5: 
56e2				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
56e2 6d				db WORD_SYS_CORE+89             
56e3 03 57			dw .SCONST6            
56e5 09				db 8 + 1 
56e6 .. 00			db "FILEPAGE",0              
56ef				endm 
# End of macro CWHEAD
56ef			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
56ef			; | | Compatible with PicoSPINet  
56ef 2a 72 fa				ld hl, (store_openaddr) 
56f2 e5					push hl 
56f3 c1					pop bc 
56f4 16 00				ld d, 0 
56f6 1e 40				ld e, STORE_BLOCK_PHY 
56f8 cd a9 0e				call Div16 
56fb c5					push bc 
56fc e1					pop hl 
56fd cd 67 1f				call forth_push_numhl 
5700					NEXTW 
5700 c3 14 23			jp macro_next 
5703				endm 
# End of macro NEXTW
5703			.SCONST6: 
5703				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5703 6d				db WORD_SYS_CORE+89             
5704 1c 57			dw .ENDSTORAGE            
5706 09				db 8 + 1 
5707 .. 00			db "READCONT",0              
5710				endm 
# End of macro CWHEAD
5710			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
5710			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
5710			; | | a further read should, if applicable, be CONCAT to the previous read. 
5710			; | | Compatible with PicoSPINet  
5710 3a 74 fa				ld a, (store_readcont) 
5713 26 00				ld h, 0 
5715 6f					ld l, a 
5716 cd 67 1f				call forth_push_numhl 
5719					NEXTW 
5719 c3 14 23			jp macro_next 
571c				endm 
# End of macro NEXTW
571c			.ENDSTORAGE: 
571c			; eof 
# End of file forth_words_storage.asm
571c			endif 
571c				include "forth_words_device.asm" 
571c			; Device related words 
571c			 
571c			; | ## Device Words 
571c			 
571c			;if SOUND_ENABLE 
571c			;.NOTE: 
571c			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
571c			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
571c			;		if DEBUG_FORTH_WORDS_KEY 
571c			;			DMARK "NTE" 
571c			;			CALLMONITOR 
571c			;		endif 
571c			; 
571c			;	 
571c			; 
571c			;		NEXTW 
571c			;.AFTERSOUND: 
571c			;endif 
571c			 
571c			 
571c			USE_GPIO: equ 0 
571c			 
571c			if USE_GPIO 
571c			.GP1: 
571c				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
571c			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
571c					NEXTW 
571c			.GP2: 
571c				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
571c			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
571c			 
571c					NEXTW 
571c			 
571c			.GP3: 
571c				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
571c			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
571c			 
571c					NEXTW 
571c			 
571c			.GP4: 
571c				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
571c			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
571c			 
571c					NEXTW 
571c			.SIN: 
571c			 
571c			 
571c			endif 
571c			 
571c			 
571c				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
571c 33				db WORD_SYS_CORE+31             
571d 51 57			dw .SOUT            
571f 03				db 2 + 1 
5720 .. 00			db "IN",0              
5723				endm 
# End of macro CWHEAD
5723			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5723					if DEBUG_FORTH_WORDS_KEY 
5723						DMARK "IN." 
5723 f5				push af  
5724 3a 38 57			ld a, (.dmark)  
5727 32 6e fe			ld (debug_mark),a  
572a 3a 39 57			ld a, (.dmark+1)  
572d 32 6f fe			ld (debug_mark+1),a  
5730 3a 3a 57			ld a, (.dmark+2)  
5733 32 70 fe			ld (debug_mark+2),a  
5736 18 03			jr .pastdmark  
5738 ..			.dmark: db "IN."  
573b f1			.pastdmark: pop af  
573c			endm  
# End of macro DMARK
573c						CALLMONITOR 
573c cd f3 18			call break_point_state  
573f				endm  
# End of macro CALLMONITOR
573f					endif 
573f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
573f cd 5e 21			call macro_dsp_valuehl 
5742				endm 
# End of macro FORTH_DSP_VALUEHL
5742			 
5742 e5					push hl 
5743			 
5743					; destroy value TOS 
5743			 
5743					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5743 cd 16 22			call macro_forth_dsp_pop 
5746				endm 
# End of macro FORTH_DSP_POP
5746			 
5746					; one value on hl get other one back 
5746			 
5746 c1					pop bc 
5747			 
5747					; do the sub 
5747			;		ex de, hl 
5747			 
5747 ed 68				in l,(c) 
5749			 
5749					; save it 
5749			 
5749 26 00				ld h,0 
574b			 
574b					; TODO push value back onto stack for another op etc 
574b			 
574b cd 67 1f				call forth_push_numhl 
574e					NEXTW 
574e c3 14 23			jp macro_next 
5751				endm 
# End of macro NEXTW
5751			.SOUT: 
5751				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5751 34				db WORD_SYS_CORE+32             
5752 a4 57			dw .SPIO            
5754 04				db 3 + 1 
5755 .. 00			db "OUT",0              
5759				endm 
# End of macro CWHEAD
5759			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5759					if DEBUG_FORTH_WORDS_KEY 
5759						DMARK "OUT" 
5759 f5				push af  
575a 3a 6e 57			ld a, (.dmark)  
575d 32 6e fe			ld (debug_mark),a  
5760 3a 6f 57			ld a, (.dmark+1)  
5763 32 6f fe			ld (debug_mark+1),a  
5766 3a 70 57			ld a, (.dmark+2)  
5769 32 70 fe			ld (debug_mark+2),a  
576c 18 03			jr .pastdmark  
576e ..			.dmark: db "OUT"  
5771 f1			.pastdmark: pop af  
5772			endm  
# End of macro DMARK
5772						CALLMONITOR 
5772 cd f3 18			call break_point_state  
5775				endm  
# End of macro CALLMONITOR
5775					endif 
5775			 
5775					; get port 
5775			 
5775					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5775 cd 5e 21			call macro_dsp_valuehl 
5778				endm 
# End of macro FORTH_DSP_VALUEHL
5778			 
5778 e5					push hl 
5779			 
5779					; destroy value TOS 
5779			 
5779					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5779 cd 16 22			call macro_forth_dsp_pop 
577c				endm 
# End of macro FORTH_DSP_POP
577c			 
577c					; get byte to send 
577c			 
577c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
577c cd 5e 21			call macro_dsp_valuehl 
577f				endm 
# End of macro FORTH_DSP_VALUEHL
577f			 
577f			;		push hl 
577f			 
577f					; destroy value TOS 
577f			 
577f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
577f cd 16 22			call macro_forth_dsp_pop 
5782				endm 
# End of macro FORTH_DSP_POP
5782			 
5782					; one value on hl get other one back 
5782			 
5782			;		pop hl 
5782			 
5782 c1					pop bc 
5783			 
5783					if DEBUG_FORTH_WORDS 
5783						DMARK "OUT" 
5783 f5				push af  
5784 3a 98 57			ld a, (.dmark)  
5787 32 6e fe			ld (debug_mark),a  
578a 3a 99 57			ld a, (.dmark+1)  
578d 32 6f fe			ld (debug_mark+1),a  
5790 3a 9a 57			ld a, (.dmark+2)  
5793 32 70 fe			ld (debug_mark+2),a  
5796 18 03			jr .pastdmark  
5798 ..			.dmark: db "OUT"  
579b f1			.pastdmark: pop af  
579c			endm  
# End of macro DMARK
579c						CALLMONITOR 
579c cd f3 18			call break_point_state  
579f				endm  
# End of macro CALLMONITOR
579f					endif 
579f			 
579f ed 69				out (c), l 
57a1			 
57a1					NEXTW 
57a1 c3 14 23			jp macro_next 
57a4				endm 
# End of macro NEXTW
57a4			 
57a4			 
57a4			.SPIO: 
57a4			 
57a4			if STORAGE_SE 
57a4				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
57a4 51				db WORD_SYS_CORE+61             
57a5 b5 57			dw .SPICEH            
57a7 07				db 6 + 1 
57a8 .. 00			db "SPICEL",0              
57af				endm 
# End of macro CWHEAD
57af			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
57af			 
57af cd ca 01				call spi_ce_low 
57b2			    NEXTW 
57b2 c3 14 23			jp macro_next 
57b5				endm 
# End of macro NEXTW
57b5			 
57b5			.SPICEH: 
57b5				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
57b5 51				db WORD_SYS_CORE+61             
57b6 c6 57			dw .SPIOb            
57b8 07				db 6 + 1 
57b9 .. 00			db "SPICEH",0              
57c0				endm 
# End of macro CWHEAD
57c0			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
57c0			 
57c0 cd b9 01				call spi_ce_high 
57c3			    NEXTW 
57c3 c3 14 23			jp macro_next 
57c6				endm 
# End of macro NEXTW
57c6			 
57c6			 
57c6			.SPIOb: 
57c6			 
57c6				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
57c6 51				db WORD_SYS_CORE+61             
57c7 f8 57			dw .SPII            
57c9 05				db 4 + 1 
57ca .. 00			db "SPIO",0              
57cf				endm 
# End of macro CWHEAD
57cf			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
57cf			 
57cf					if DEBUG_FORTH_WORDS_KEY 
57cf						DMARK "SPo" 
57cf f5				push af  
57d0 3a e4 57			ld a, (.dmark)  
57d3 32 6e fe			ld (debug_mark),a  
57d6 3a e5 57			ld a, (.dmark+1)  
57d9 32 6f fe			ld (debug_mark+1),a  
57dc 3a e6 57			ld a, (.dmark+2)  
57df 32 70 fe			ld (debug_mark+2),a  
57e2 18 03			jr .pastdmark  
57e4 ..			.dmark: db "SPo"  
57e7 f1			.pastdmark: pop af  
57e8			endm  
# End of macro DMARK
57e8						CALLMONITOR 
57e8 cd f3 18			call break_point_state  
57eb				endm  
# End of macro CALLMONITOR
57eb					endif 
57eb					; get port 
57eb			 
57eb			 
57eb					; get byte to send 
57eb			 
57eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
57eb cd 5e 21			call macro_dsp_valuehl 
57ee				endm 
# End of macro FORTH_DSP_VALUEHL
57ee			 
57ee			;		push hl    ; u1  
57ee			 
57ee					; destroy value TOS 
57ee			 
57ee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
57ee cd 16 22			call macro_forth_dsp_pop 
57f1				endm 
# End of macro FORTH_DSP_POP
57f1			 
57f1					; one value on hl get other one back 
57f1			 
57f1			;		pop hl   ; u2 - addr 
57f1			 
57f1					; TODO Send SPI byte 
57f1			 
57f1			;		push hl 
57f1			;		call spi_ce_low 
57f1			;		pop hl 
57f1 7d					ld a, l 
57f2 cd b8 00				call spi_send_byte 
57f5			;		call spi_ce_high 
57f5			 
57f5					NEXTW 
57f5 c3 14 23			jp macro_next 
57f8				endm 
# End of macro NEXTW
57f8			 
57f8			.SPII: 
57f8				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
57f8 52				db WORD_SYS_CORE+62             
57f9 61 58			dw .SESEL            
57fb 06				db 5 + 1 
57fc .. 00			db "SPII",0              
5801				endm 
# End of macro CWHEAD
5801			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5801					if DEBUG_FORTH_WORDS_KEY 
5801						DMARK "SPi" 
5801 f5				push af  
5802 3a 16 58			ld a, (.dmark)  
5805 32 6e fe			ld (debug_mark),a  
5808 3a 17 58			ld a, (.dmark+1)  
580b 32 6f fe			ld (debug_mark+1),a  
580e 3a 18 58			ld a, (.dmark+2)  
5811 32 70 fe			ld (debug_mark+2),a  
5814 18 03			jr .pastdmark  
5816 ..			.dmark: db "SPi"  
5819 f1			.pastdmark: pop af  
581a			endm  
# End of macro DMARK
581a						CALLMONITOR 
581a cd f3 18			call break_point_state  
581d				endm  
# End of macro CALLMONITOR
581d					endif 
581d			 
581d					; TODO Get SPI byte 
581d			 
581d cd df 00				call spi_read_byte 
5820			 
5820					if DEBUG_FORTH_WORDS 
5820						DMARK "Si2" 
5820 f5				push af  
5821 3a 35 58			ld a, (.dmark)  
5824 32 6e fe			ld (debug_mark),a  
5827 3a 36 58			ld a, (.dmark+1)  
582a 32 6f fe			ld (debug_mark+1),a  
582d 3a 37 58			ld a, (.dmark+2)  
5830 32 70 fe			ld (debug_mark+2),a  
5833 18 03			jr .pastdmark  
5835 ..			.dmark: db "Si2"  
5838 f1			.pastdmark: pop af  
5839			endm  
# End of macro DMARK
5839						CALLMONITOR 
5839 cd f3 18			call break_point_state  
583c				endm  
# End of macro CALLMONITOR
583c					endif 
583c 26 00				ld h, 0 
583e 6f					ld l, a 
583f					if DEBUG_FORTH_WORDS 
583f						DMARK "Si3" 
583f f5				push af  
5840 3a 54 58			ld a, (.dmark)  
5843 32 6e fe			ld (debug_mark),a  
5846 3a 55 58			ld a, (.dmark+1)  
5849 32 6f fe			ld (debug_mark+1),a  
584c 3a 56 58			ld a, (.dmark+2)  
584f 32 70 fe			ld (debug_mark+2),a  
5852 18 03			jr .pastdmark  
5854 ..			.dmark: db "Si3"  
5857 f1			.pastdmark: pop af  
5858			endm  
# End of macro DMARK
5858						CALLMONITOR 
5858 cd f3 18			call break_point_state  
585b				endm  
# End of macro CALLMONITOR
585b					endif 
585b cd 67 1f				call forth_push_numhl 
585e			 
585e					NEXTW 
585e c3 14 23			jp macro_next 
5861				endm 
# End of macro NEXTW
5861			 
5861			 
5861			 
5861			.SESEL: 
5861				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5861 66				db WORD_SYS_CORE+82             
5862 0a 59			dw .CARTDEV            
5864 05				db 4 + 1 
5865 .. 00			db "BANK",0              
586a				endm 
# End of macro CWHEAD
586a			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
586a					if DEBUG_FORTH_WORDS_KEY 
586a						DMARK "BNK" 
586a f5				push af  
586b 3a 7f 58			ld a, (.dmark)  
586e 32 6e fe			ld (debug_mark),a  
5871 3a 80 58			ld a, (.dmark+1)  
5874 32 6f fe			ld (debug_mark+1),a  
5877 3a 81 58			ld a, (.dmark+2)  
587a 32 70 fe			ld (debug_mark+2),a  
587d 18 03			jr .pastdmark  
587f ..			.dmark: db "BNK"  
5882 f1			.pastdmark: pop af  
5883			endm  
# End of macro DMARK
5883						CALLMONITOR 
5883 cd f3 18			call break_point_state  
5886				endm  
# End of macro CALLMONITOR
5886					endif 
5886			 
5886 3e ff				ld a, 255 
5888 32 6a fa				ld (spi_cartdev), a 
588b			 
588b					; get bank 
588b			 
588b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
588b cd 5e 21			call macro_dsp_valuehl 
588e				endm 
# End of macro FORTH_DSP_VALUEHL
588e			 
588e			;		push hl 
588e			 
588e					; destroy value TOS 
588e			 
588e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
588e cd 16 22			call macro_forth_dsp_pop 
5891				endm 
# End of macro FORTH_DSP_POP
5891			 
5891					; one value on hl get other one back 
5891			 
5891			;		pop hl 
5891			 
5891			 
5891 0e ff				ld c, SPI_CE_HIGH 
5893 06 30				ld b, '0'    ; human readable bank number 
5895			 
5895 7d					ld a, l 
5896			 
5896					if DEBUG_FORTH_WORDS 
5896						DMARK "BNK" 
5896 f5				push af  
5897 3a ab 58			ld a, (.dmark)  
589a 32 6e fe			ld (debug_mark),a  
589d 3a ac 58			ld a, (.dmark+1)  
58a0 32 6f fe			ld (debug_mark+1),a  
58a3 3a ad 58			ld a, (.dmark+2)  
58a6 32 70 fe			ld (debug_mark+2),a  
58a9 18 03			jr .pastdmark  
58ab ..			.dmark: db "BNK"  
58ae f1			.pastdmark: pop af  
58af			endm  
# End of macro DMARK
58af						CALLMONITOR 
58af cd f3 18			call break_point_state  
58b2				endm  
# End of macro CALLMONITOR
58b2					endif 
58b2			 
58b2					; active low 
58b2			 
58b2 fe 00				cp 0 
58b4 28 28				jr z, .bset 
58b6 fe 01				cp 1 
58b8 20 04				jr nz, .b2 
58ba cb 81				res 0, c 
58bc 06 31				ld b, '1'    ; human readable bank number 
58be fe 02		.b2:		cp 2 
58c0 20 04				jr nz, .b3 
58c2 cb 89				res 1, c 
58c4 06 32				ld b, '2'    ; human readable bank number 
58c6 fe 03		.b3:		cp 3 
58c8 20 04				jr nz, .b4 
58ca cb 91				res 2, c 
58cc 06 33				ld b, '3'    ; human readable bank number 
58ce fe 04		.b4:		cp 4 
58d0 20 04				jr nz, .b5 
58d2 cb 99				res 3, c 
58d4 06 34				ld b, '4'    ; human readable bank number 
58d6 fe 05		.b5:		cp 5 
58d8 20 04				jr nz, .bset 
58da cb a1				res 4, c 
58dc 06 35				ld b, '5'    ; human readable bank number 
58de			 
58de			.bset: 
58de 79					ld a, c 
58df 32 67 fa				ld (spi_device),a 
58e2 78					ld a, b 
58e3 32 66 fa				ld (spi_device_id),a 
58e6					if DEBUG_FORTH_WORDS 
58e6						DMARK "BN2" 
58e6 f5				push af  
58e7 3a fb 58			ld a, (.dmark)  
58ea 32 6e fe			ld (debug_mark),a  
58ed 3a fc 58			ld a, (.dmark+1)  
58f0 32 6f fe			ld (debug_mark+1),a  
58f3 3a fd 58			ld a, (.dmark+2)  
58f6 32 70 fe			ld (debug_mark+2),a  
58f9 18 03			jr .pastdmark  
58fb ..			.dmark: db "BN2"  
58fe f1			.pastdmark: pop af  
58ff			endm  
# End of macro DMARK
58ff						CALLMONITOR 
58ff cd f3 18			call break_point_state  
5902				endm  
# End of macro CALLMONITOR
5902					endif 
5902			 
5902					; set default SPI clk pulse time as disabled for BANK use 
5902			 
5902 3e 00				ld a, 0 
5904 32 6b fa				ld (spi_clktime), a 
5907			 
5907					NEXTW 
5907 c3 14 23			jp macro_next 
590a				endm 
# End of macro NEXTW
590a			 
590a			.CARTDEV: 
590a				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
590a 66				db WORD_SYS_CORE+82             
590b b8 59			dw .ENDDEVICE            
590d 08				db 7 + 1 
590e .. 00			db "CARTDEV",0              
5916				endm 
# End of macro CWHEAD
5916			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5916					if DEBUG_FORTH_WORDS_KEY 
5916						DMARK "CDV" 
5916 f5				push af  
5917 3a 2b 59			ld a, (.dmark)  
591a 32 6e fe			ld (debug_mark),a  
591d 3a 2c 59			ld a, (.dmark+1)  
5920 32 6f fe			ld (debug_mark+1),a  
5923 3a 2d 59			ld a, (.dmark+2)  
5926 32 70 fe			ld (debug_mark+2),a  
5929 18 03			jr .pastdmark  
592b ..			.dmark: db "CDV"  
592e f1			.pastdmark: pop af  
592f			endm  
# End of macro DMARK
592f						CALLMONITOR 
592f cd f3 18			call break_point_state  
5932				endm  
# End of macro CALLMONITOR
5932					endif 
5932			 
5932					; disable se storage bank selection 
5932			 
5932 3e ff				ld a, SPI_CE_HIGH		; ce high 
5934 32 67 fa				ld (spi_device), a 
5937			 
5937					; get bank 
5937			 
5937					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5937 cd 5e 21			call macro_dsp_valuehl 
593a				endm 
# End of macro FORTH_DSP_VALUEHL
593a			 
593a			;		push hl 
593a			 
593a					; destroy value TOS 
593a			 
593a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
593a cd 16 22			call macro_forth_dsp_pop 
593d				endm 
# End of macro FORTH_DSP_POP
593d			 
593d					; one value on hl get other one back 
593d			 
593d			;		pop hl 
593d			 
593d					; active low 
593d			 
593d 0e ff				ld c, 255 
593f			 
593f 7d					ld a, l 
5940					if DEBUG_FORTH_WORDS 
5940						DMARK "CDV" 
5940 f5				push af  
5941 3a 55 59			ld a, (.dmark)  
5944 32 6e fe			ld (debug_mark),a  
5947 3a 56 59			ld a, (.dmark+1)  
594a 32 6f fe			ld (debug_mark+1),a  
594d 3a 57 59			ld a, (.dmark+2)  
5950 32 70 fe			ld (debug_mark+2),a  
5953 18 03			jr .pastdmark  
5955 ..			.dmark: db "CDV"  
5958 f1			.pastdmark: pop af  
5959			endm  
# End of macro DMARK
5959						CALLMONITOR 
5959 cd f3 18			call break_point_state  
595c				endm  
# End of macro CALLMONITOR
595c					endif 
595c fe 00				cp 0 
595e 28 30				jr z, .cset 
5960 fe 01				cp 1 
5962 20 02				jr nz, .c2 
5964 cb 81				res 0, c 
5966 fe 02		.c2:		cp 2 
5968 20 02				jr nz, .c3 
596a cb 89				res 1, c 
596c fe 03		.c3:		cp 3 
596e 20 02				jr nz, .c4 
5970 cb 91				res 2, c 
5972 fe 04		.c4:		cp 4 
5974 20 02				jr nz, .c5 
5976 cb 99				res 3, c 
5978 fe 05		.c5:		cp 5 
597a 20 02				jr nz, .c6 
597c cb a1				res 4, c 
597e fe 06		.c6:		cp 6 
5980 20 02				jr nz, .c7 
5982 cb a9				res 5, c 
5984 fe 07		.c7:		cp 7 
5986 20 02				jr nz, .c8 
5988 cb b1				res 6, c 
598a fe 08		.c8:		cp 8 
598c 20 02				jr nz, .cset 
598e cb b9				res 7, c 
5990 79			.cset:		ld a, c 
5991 32 6a fa				ld (spi_cartdev),a 
5994			 
5994					if DEBUG_FORTH_WORDS 
5994						DMARK "CD2" 
5994 f5				push af  
5995 3a a9 59			ld a, (.dmark)  
5998 32 6e fe			ld (debug_mark),a  
599b 3a aa 59			ld a, (.dmark+1)  
599e 32 6f fe			ld (debug_mark+1),a  
59a1 3a ab 59			ld a, (.dmark+2)  
59a4 32 70 fe			ld (debug_mark+2),a  
59a7 18 03			jr .pastdmark  
59a9 ..			.dmark: db "CD2"  
59ac f1			.pastdmark: pop af  
59ad			endm  
# End of macro DMARK
59ad						CALLMONITOR 
59ad cd f3 18			call break_point_state  
59b0				endm  
# End of macro CALLMONITOR
59b0					endif 
59b0			 
59b0					; set default SPI clk pulse time as 10ms for CARTDEV use 
59b0			 
59b0 3e 0a				ld a, $0a 
59b2 32 6b fa				ld (spi_clktime), a 
59b5					NEXTW 
59b5 c3 14 23			jp macro_next 
59b8				endm 
# End of macro NEXTW
59b8			endif 
59b8			 
59b8			.ENDDEVICE: 
59b8			; eof 
59b8			 
# End of file forth_words_device.asm
59b8			 
59b8			; var handler 
59b8			 
59b8			 
59b8			.VARS: 
59b8				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
59b8 77				db WORD_SYS_CORE+99             
59b9 69 5a			dw .V0            
59bb 04				db 3 + 1 
59bc .. 00			db "VAR",0              
59c0				endm 
# End of macro CWHEAD
59c0			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
59c0			;| 
59c0			;| The variable name should consist of a single letter. e.g. "a" 
59c0			;! If a full string is passed then only the first char is looked at 
59c0			;| Any other char could exceed bounds checks!  
59c0			 
59c0					if DEBUG_FORTH_WORDS_KEY 
59c0						DMARK "VAR" 
59c0 f5				push af  
59c1 3a d5 59			ld a, (.dmark)  
59c4 32 6e fe			ld (debug_mark),a  
59c7 3a d6 59			ld a, (.dmark+1)  
59ca 32 6f fe			ld (debug_mark+1),a  
59cd 3a d7 59			ld a, (.dmark+2)  
59d0 32 70 fe			ld (debug_mark+2),a  
59d3 18 03			jr .pastdmark  
59d5 ..			.dmark: db "VAR"  
59d8 f1			.pastdmark: pop af  
59d9			endm  
# End of macro DMARK
59d9						CALLMONITOR 
59d9 cd f3 18			call break_point_state  
59dc				endm  
# End of macro CALLMONITOR
59dc					endif 
59dc			 
59dc					FORTH_DSP_VALUEHL 
59dc cd 5e 21			call macro_dsp_valuehl 
59df				endm 
# End of macro FORTH_DSP_VALUEHL
59df			 
59df 7e					ld a, (hl)    ; get first char on of the string 
59e0			 
59e0			 
59e0					if DEBUG_FORTH_WORDS 
59e0						DMARK "VR1" 
59e0 f5				push af  
59e1 3a f5 59			ld a, (.dmark)  
59e4 32 6e fe			ld (debug_mark),a  
59e7 3a f6 59			ld a, (.dmark+1)  
59ea 32 6f fe			ld (debug_mark+1),a  
59ed 3a f7 59			ld a, (.dmark+2)  
59f0 32 70 fe			ld (debug_mark+2),a  
59f3 18 03			jr .pastdmark  
59f5 ..			.dmark: db "VR1"  
59f8 f1			.pastdmark: pop af  
59f9			endm  
# End of macro DMARK
59f9						CALLMONITOR 
59f9 cd f3 18			call break_point_state  
59fc				endm  
# End of macro CALLMONITOR
59fc					endif 
59fc					 
59fc f5					push af	 
59fd					FORTH_DSP_POP 
59fd cd 16 22			call macro_forth_dsp_pop 
5a00				endm 
# End of macro FORTH_DSP_POP
5a00 f1					pop af 
5a01			 
5a01					; convert to upper 
5a01			 
5a01 cd b9 12				call to_upper 
5a04					if DEBUG_FORTH_WORDS 
5a04						DMARK "Vaa" 
5a04 f5				push af  
5a05 3a 19 5a			ld a, (.dmark)  
5a08 32 6e fe			ld (debug_mark),a  
5a0b 3a 1a 5a			ld a, (.dmark+1)  
5a0e 32 6f fe			ld (debug_mark+1),a  
5a11 3a 1b 5a			ld a, (.dmark+2)  
5a14 32 70 fe			ld (debug_mark+2),a  
5a17 18 03			jr .pastdmark  
5a19 ..			.dmark: db "Vaa"  
5a1c f1			.pastdmark: pop af  
5a1d			endm  
# End of macro DMARK
5a1d						CALLMONITOR 
5a1d cd f3 18			call break_point_state  
5a20				endm  
# End of macro CALLMONITOR
5a20					endif 
5a20 06 41				ld b, 'A' 
5a22 90					sub b			; set offset 
5a23					if DEBUG_FORTH_WORDS 
5a23						DMARK "Vbb" 
5a23 f5				push af  
5a24 3a 38 5a			ld a, (.dmark)  
5a27 32 6e fe			ld (debug_mark),a  
5a2a 3a 39 5a			ld a, (.dmark+1)  
5a2d 32 6f fe			ld (debug_mark+1),a  
5a30 3a 3a 5a			ld a, (.dmark+2)  
5a33 32 70 fe			ld (debug_mark+2),a  
5a36 18 03			jr .pastdmark  
5a38 ..			.dmark: db "Vbb"  
5a3b f1			.pastdmark: pop af  
5a3c			endm  
# End of macro DMARK
5a3c						CALLMONITOR 
5a3c cd f3 18			call break_point_state  
5a3f				endm  
# End of macro CALLMONITOR
5a3f					endif 
5a3f cb 27				sla a  
5a41				 
5a41					 
5a41					if DEBUG_FORTH_WORDS 
5a41						DMARK "VR2" 
5a41 f5				push af  
5a42 3a 56 5a			ld a, (.dmark)  
5a45 32 6e fe			ld (debug_mark),a  
5a48 3a 57 5a			ld a, (.dmark+1)  
5a4b 32 6f fe			ld (debug_mark+1),a  
5a4e 3a 58 5a			ld a, (.dmark+2)  
5a51 32 70 fe			ld (debug_mark+2),a  
5a54 18 03			jr .pastdmark  
5a56 ..			.dmark: db "VR2"  
5a59 f1			.pastdmark: pop af  
5a5a			endm  
# End of macro DMARK
5a5a						CALLMONITOR 
5a5a cd f3 18			call break_point_state  
5a5d				endm  
# End of macro CALLMONITOR
5a5d					endif 
5a5d			 
5a5d 21 fb f9				ld hl, cli_var_array2 
5a60 cd 4c 0f				call addatohl 
5a63 cd 67 1f				call forth_push_numhl 
5a66			 
5a66			 
5a66				       NEXTW 
5a66 c3 14 23			jp macro_next 
5a69				endm 
# End of macro NEXTW
5a69			.V0: 
5a69				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5a69 78				db WORD_SYS_CORE+100             
5a6a 81 5a			dw .V0Q            
5a6c 04				db 3 + 1 
5a6d .. 00			db "V0!",0              
5a71				endm 
# End of macro CWHEAD
5a71			;| V0! ( u1 -- )  Store value to v0  | DONE 
5a71			 
5a71					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a71 cd 5e 21			call macro_dsp_valuehl 
5a74				endm 
# End of macro FORTH_DSP_VALUEHL
5a74			 
5a74 11 2f fa				ld de, cli_var_array 
5a77			 
5a77 eb					ex de, hl 
5a78 73					ld (hl), e 
5a79 23					inc hl 
5a7a 72					ld (hl), d 
5a7b			 
5a7b					; destroy value TOS 
5a7b			 
5a7b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a7b cd 16 22			call macro_forth_dsp_pop 
5a7e				endm 
# End of macro FORTH_DSP_POP
5a7e			 
5a7e				       NEXTW 
5a7e c3 14 23			jp macro_next 
5a81				endm 
# End of macro NEXTW
5a81			.V0Q: 
5a81				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5a81 79				db WORD_SYS_CORE+101             
5a82 92 5a			dw .V1S            
5a84 04				db 3 + 1 
5a85 .. 00			db "V0@",0              
5a89				endm 
# End of macro CWHEAD
5a89			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5a89 2a 2f fa				ld hl, (cli_var_array) 
5a8c cd 67 1f				call forth_push_numhl 
5a8f			 
5a8f				       NEXTW 
5a8f c3 14 23			jp macro_next 
5a92				endm 
# End of macro NEXTW
5a92			.V1S: 
5a92				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5a92 7a				db WORD_SYS_CORE+102             
5a93 aa 5a			dw .V1Q            
5a95 04				db 3 + 1 
5a96 .. 00			db "V1!",0              
5a9a				endm 
# End of macro CWHEAD
5a9a			;| V1! ( u1 -- )  Store value to v1 | DONE 
5a9a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a9a cd 5e 21			call macro_dsp_valuehl 
5a9d				endm 
# End of macro FORTH_DSP_VALUEHL
5a9d			 
5a9d 11 31 fa				ld de, cli_var_array+2 
5aa0				 
5aa0 eb					ex de, hl 
5aa1 73					ld (hl), e 
5aa2 23					inc hl 
5aa3 72					ld (hl), d 
5aa4			 
5aa4					; destroy value TOS 
5aa4			 
5aa4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5aa4 cd 16 22			call macro_forth_dsp_pop 
5aa7				endm 
# End of macro FORTH_DSP_POP
5aa7				       NEXTW 
5aa7 c3 14 23			jp macro_next 
5aaa				endm 
# End of macro NEXTW
5aaa			.V1Q: 
5aaa				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5aaa 7b				db WORD_SYS_CORE+103             
5aab bb 5a			dw .V2S            
5aad 04				db 3 + 1 
5aae .. 00			db "V1@",0              
5ab2				endm 
# End of macro CWHEAD
5ab2			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5ab2 2a 31 fa				ld hl, (cli_var_array+2) 
5ab5 cd 67 1f				call forth_push_numhl 
5ab8				       NEXTW 
5ab8 c3 14 23			jp macro_next 
5abb				endm 
# End of macro NEXTW
5abb			.V2S: 
5abb				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5abb 7c				db WORD_SYS_CORE+104             
5abc d3 5a			dw .V2Q            
5abe 04				db 3 + 1 
5abf .. 00			db "V2!",0              
5ac3				endm 
# End of macro CWHEAD
5ac3			;| V2! ( u1 -- )  Store value to v2 | DONE 
5ac3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ac3 cd 5e 21			call macro_dsp_valuehl 
5ac6				endm 
# End of macro FORTH_DSP_VALUEHL
5ac6			 
5ac6 11 33 fa				ld de, cli_var_array+4 
5ac9				 
5ac9 eb					ex de, hl 
5aca 73					ld (hl), e 
5acb 23					inc hl 
5acc 72					ld (hl), d 
5acd			 
5acd					; destroy value TOS 
5acd			 
5acd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5acd cd 16 22			call macro_forth_dsp_pop 
5ad0				endm 
# End of macro FORTH_DSP_POP
5ad0				       NEXTW 
5ad0 c3 14 23			jp macro_next 
5ad3				endm 
# End of macro NEXTW
5ad3			.V2Q: 
5ad3				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5ad3 7d				db WORD_SYS_CORE+105             
5ad4 e4 5a			dw .V3S            
5ad6 04				db 3 + 1 
5ad7 .. 00			db "V2@",0              
5adb				endm 
# End of macro CWHEAD
5adb			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5adb 2a 33 fa				ld hl, (cli_var_array+4) 
5ade cd 67 1f				call forth_push_numhl 
5ae1				       NEXTW 
5ae1 c3 14 23			jp macro_next 
5ae4				endm 
# End of macro NEXTW
5ae4			.V3S: 
5ae4				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5ae4 7c				db WORD_SYS_CORE+104             
5ae5 fc 5a			dw .V3Q            
5ae7 04				db 3 + 1 
5ae8 .. 00			db "V3!",0              
5aec				endm 
# End of macro CWHEAD
5aec			;| V3! ( u1 -- )  Store value to v3 | DONE 
5aec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5aec cd 5e 21			call macro_dsp_valuehl 
5aef				endm 
# End of macro FORTH_DSP_VALUEHL
5aef			 
5aef 11 35 fa				ld de, cli_var_array+6 
5af2				 
5af2 eb					ex de, hl 
5af3 73					ld (hl), e 
5af4 23					inc hl 
5af5 72					ld (hl), d 
5af6			 
5af6					; destroy value TOS 
5af6			 
5af6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5af6 cd 16 22			call macro_forth_dsp_pop 
5af9				endm 
# End of macro FORTH_DSP_POP
5af9				       NEXTW 
5af9 c3 14 23			jp macro_next 
5afc				endm 
# End of macro NEXTW
5afc			.V3Q: 
5afc				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5afc 7d				db WORD_SYS_CORE+105             
5afd 0d 5b			dw .END            
5aff 04				db 3 + 1 
5b00 .. 00			db "V3@",0              
5b04				endm 
# End of macro CWHEAD
5b04			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5b04 2a 35 fa				ld hl, (cli_var_array+6) 
5b07 cd 67 1f				call forth_push_numhl 
5b0a				       NEXTW 
5b0a c3 14 23			jp macro_next 
5b0d				endm 
# End of macro NEXTW
5b0d			 
5b0d			 
5b0d			 
5b0d			 
5b0d			 
5b0d			; end of dict marker 
5b0d			 
5b0d 00			.END:    db WORD_SYS_END 
5b0e 00 00			dw 0 
5b10 00				db 0 
5b11			 
5b11			; use to jp here for user dict words to save on macro expansion  
5b11			 
5b11			user_dict_next: 
5b11				NEXTW 
5b11 c3 14 23			jp macro_next 
5b14				endm 
# End of macro NEXTW
5b14			 
5b14			 
5b14			user_exec: 
5b14				;    ld hl, <word code> 
5b14				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5b14				;    call forthexec 
5b14				;    jp user_dict_next   (NEXT) 
5b14			        ;    <word code bytes> 
5b14 eb				ex de, hl 
5b15 2a c9 f4			ld hl,(os_tok_ptr) 
5b18				 
5b18				FORTH_RSP_NEXT 
5b18 cd 0e 1f			call macro_forth_rsp_next 
5b1b				endm 
# End of macro FORTH_RSP_NEXT
5b1b			 
5b1b			if DEBUG_FORTH_UWORD 
5b1b						DMARK "UEX" 
5b1b f5				push af  
5b1c 3a 30 5b			ld a, (.dmark)  
5b1f 32 6e fe			ld (debug_mark),a  
5b22 3a 31 5b			ld a, (.dmark+1)  
5b25 32 6f fe			ld (debug_mark+1),a  
5b28 3a 32 5b			ld a, (.dmark+2)  
5b2b 32 70 fe			ld (debug_mark+2),a  
5b2e 18 03			jr .pastdmark  
5b30 ..			.dmark: db "UEX"  
5b33 f1			.pastdmark: pop af  
5b34			endm  
# End of macro DMARK
5b34				CALLMONITOR 
5b34 cd f3 18			call break_point_state  
5b37				endm  
# End of macro CALLMONITOR
5b37			endif 
5b37			 
5b37			 
5b37			 
5b37 eb				ex de, hl 
5b38 22 c9 f4			ld (os_tok_ptr), hl 
5b3b				 
5b3b				; Don't use next - Skips the first word in uword. 
5b3b			 
5b3b c3 a5 23			jp exec1 
5b3e			;	NEXT 
5b3e			 
5b3e			 
5b3e			; eof 
# End of file forth_wordsv4.asm
5b3e			endif 
5b3e			;;;;;;;;;;;;;; Debug code 
5b3e			 
5b3e			 
5b3e			;if DEBUG_FORTH_PARSE 
5b3e .. 00		.nowordfound: db "No match",0 
5b47 .. 00		.compword:	db "Comparing word ",0 
5b57 .. 00		.nextwordat:	db "Next word at",0 
5b64 .. 00		.charmatch:	db "Char match",0 
5b6f			;endif 
5b6f			if DEBUG_FORTH_JP 
5b6f			.foundword:	db "Word match. Exec..",0 
5b6f			endif 
5b6f			;if DEBUG_FORTH_PUSH 
5b6f .. 00		.enddict:	db "Dict end. Push.",0 
5b7f .. 00		.push_str:	db "Pushing string",0 
5b8e .. 00		.push_num:	db "Pushing number",0 
5b9d .. 00		.data_sp:	db "SP:",0 
5ba1 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5bb3 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5bc5 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5bd7			;endif 
5bd7			;if DEBUG_FORTH_MALLOC 
5bd7 .. 00		.push_malloc:	db "Malloc address",0 
5be6			;endif 
5be6			 
5be6			 
5be6			 
5be6			; display malloc address and current data stack pointer  
5be6			 
5be6			malloc_error: 
5be6 d5				push de 
5be7 f5				push af 
5be8 e5				push hl 
5be9 cd 18 0d			call clear_display 
5bec 11 0e 5c			ld de, .mallocerr 
5bef 3e 00			ld a,0 
5bf1			;	ld de,os_word_scratch 
5bf1 cd 2b 0d			call str_at_display 
5bf4 3e 11			ld a, display_row_1+17 
5bf6 11 6e fe			ld de, debug_mark 
5bf9 cd 2b 0d			call str_at_display 
5bfc cd 3b 0d			call update_display 
5bff				;call break_point_state 
5bff cd 07 77			call cin_wait 
5c02			 
5c02 3e 20			ld a, ' ' 
5c04 32 b9 f1			ld (os_view_disable), a 
5c07 e1				pop hl 
5c08 f1				pop af 
5c09 d1				pop de	 
5c0a				CALLMONITOR 
5c0a cd f3 18			call break_point_state  
5c0d				endm  
# End of macro CALLMONITOR
5c0d c9				ret 
5c0e			 
5c0e .. 00		.mallocerr: 	db "Malloc Error",0 
5c1b			;if DEBUG_FORTH_PUSH 
5c1b			display_data_sp: 
5c1b f5				push af 
5c1c			 
5c1c				; see if disabled 
5c1c			 
5c1c 3a b9 f1			ld a, (os_view_disable) 
5c1f fe 2a			cp '*' 
5c21 28 67			jr z, .skipdsp 
5c23			 
5c23 e5				push hl 
5c24 e5				push hl 
5c25 e5			push hl 
5c26 cd 18 0d			call clear_display 
5c29 e1			pop hl 
5c2a 7c				ld a,h 
5c2b 21 cd f4			ld hl, os_word_scratch 
5c2e cd 4d 12			call hexout 
5c31 e1				pop hl 
5c32 7d				ld a,l 
5c33 21 cf f4			ld hl, os_word_scratch+2 
5c36 cd 4d 12			call hexout 
5c39 21 d1 f4			ld hl, os_word_scratch+4 
5c3c 3e 00			ld a,0 
5c3e 77				ld (hl),a 
5c3f 11 cd f4			ld de,os_word_scratch 
5c42 3e 28				ld a, display_row_2 
5c44 cd 2b 0d				call str_at_display 
5c47 11 a1 5b			ld de, .wordinhl 
5c4a 3e 00			ld a, display_row_1 
5c4c			 
5c4c cd 2b 0d				call str_at_display 
5c4f 11 6e fe			ld de, debug_mark 
5c52 3e 11			ld a, display_row_1+17 
5c54			 
5c54 cd 2b 0d				call str_at_display 
5c57			 
5c57				; display current data stack pointer 
5c57 11 9d 5b			ld de,.data_sp 
5c5a 3e 30				ld a, display_row_2 + 8 
5c5c cd 2b 0d				call str_at_display 
5c5f			 
5c5f 2a f5 f9			ld hl,(cli_data_sp) 
5c62 e5				push hl 
5c63 7c				ld a,h 
5c64 21 cd f4			ld hl, os_word_scratch 
5c67 cd 4d 12			call hexout 
5c6a e1				pop hl 
5c6b 7d				ld a,l 
5c6c 21 cf f4			ld hl, os_word_scratch+2 
5c6f cd 4d 12			call hexout 
5c72 21 d1 f4			ld hl, os_word_scratch+4 
5c75 3e 00			ld a,0 
5c77 77				ld (hl),a 
5c78 11 cd f4			ld de,os_word_scratch 
5c7b 3e 33				ld a, display_row_2 + 11 
5c7d cd 2b 0d				call str_at_display 
5c80			 
5c80			 
5c80 cd 3b 0d			call update_display 
5c83 cd 95 0c			call delay1s 
5c86 cd 95 0c			call delay1s 
5c89 e1				pop hl 
5c8a			.skipdsp: 
5c8a f1				pop af 
5c8b c9				ret 
5c8c			 
5c8c			display_data_malloc: 
5c8c			 
5c8c f5				push af 
5c8d e5				push hl 
5c8e e5				push hl 
5c8f e5			push hl 
5c90 cd 18 0d			call clear_display 
5c93 e1			pop hl 
5c94 7c				ld a,h 
5c95 21 cd f4			ld hl, os_word_scratch 
5c98 cd 4d 12			call hexout 
5c9b e1				pop hl 
5c9c 7d				ld a,l 
5c9d 21 cf f4			ld hl, os_word_scratch+2 
5ca0 cd 4d 12			call hexout 
5ca3 21 d1 f4			ld hl, os_word_scratch+4 
5ca6 3e 00			ld a,0 
5ca8 77				ld (hl),a 
5ca9 11 cd f4			ld de,os_word_scratch 
5cac 3e 28				ld a, display_row_2 
5cae cd 2b 0d				call str_at_display 
5cb1 11 d7 5b			ld de, .push_malloc 
5cb4 3e 00			ld a, display_row_1 
5cb6			 
5cb6 cd 2b 0d				call str_at_display 
5cb9			 
5cb9				; display current data stack pointer 
5cb9 11 9d 5b			ld de,.data_sp 
5cbc 3e 30				ld a, display_row_2 + 8 
5cbe cd 2b 0d				call str_at_display 
5cc1			 
5cc1 2a f5 f9			ld hl,(cli_data_sp) 
5cc4 e5				push hl 
5cc5 7c				ld a,h 
5cc6 21 cd f4			ld hl, os_word_scratch 
5cc9 cd 4d 12			call hexout 
5ccc e1				pop hl 
5ccd 7d				ld a,l 
5cce 21 cf f4			ld hl, os_word_scratch+2 
5cd1 cd 4d 12			call hexout 
5cd4 21 d1 f4			ld hl, os_word_scratch+4 
5cd7 3e 00			ld a,0 
5cd9 77				ld (hl),a 
5cda 11 cd f4			ld de,os_word_scratch 
5cdd 3e 33				ld a, display_row_2 + 11 
5cdf cd 2b 0d				call str_at_display 
5ce2			 
5ce2 cd 3b 0d			call update_display 
5ce5 cd 95 0c			call delay1s 
5ce8 cd 95 0c			call delay1s 
5ceb e1				pop hl 
5cec f1				pop af 
5ced c9				ret 
5cee			;endif 
5cee			 
5cee			include "forth_autostart.asm" 
5cee			; list of commands to perform at system start up 
5cee			 
5cee			startcmds: 
5cee			;	dw test11 
5cee			;	dw test12 
5cee			;	dw test13 
5cee			;	dw test14 
5cee			;	dw test15 
5cee			;	dw test16 
5cee			;	dw test17 
5cee			;	dw ifthtest1 
5cee			;	dw ifthtest2 
5cee			;	dw ifthtest3 
5cee			;	dw mmtest1 
5cee			;	dw mmtest2 
5cee			;	dw mmtest3 
5cee			;	dw mmtest4 
5cee			;	dw mmtest5 
5cee			;	dw mmtest6 
5cee			;	dw iftest1 
5cee			;	dw iftest2 
5cee			;	dw iftest3 
5cee			;	dw looptest1 
5cee			;	dw looptest2 
5cee			;	dw test1 
5cee			;	dw test2 
5cee			;	dw test3 
5cee			;	dw test4 
5cee			;	dw game2r 
5cee			;	dw game2b1 
5cee			;	dw game2b2 
5cee			 
5cee				; start up words that are actually useful 
5cee			 
5cee f6 5d		    dw spi1 
5cf0 4f 5e		    dw spi2 
5cf2 dd 5e		    dw spi3 
5cf4 85 5e		    dw spi4 
5cf6 b0 5e		    dw spi5 
5cf8 43 5f		    dw spi6 
5cfa 98 5f		    dw spi7 
5cfc			 
5cfc f0 5f		    dw spi8 
5cfe 0f 60		    dw spi9 
5d00 67 60		    dw spi10 
5d02			 
5d02			; file editor 
5d02 68 5d			dw edit1 
5d04 89 5d			dw edit2 
5d06 be 5d			dw edit3 
5d08			 
5d08 da 60			dw longread 
5d0a 21 61			dw clrstack 
5d0c 54 61			dw type 
5d0e 3f 63			dw stest 
5d10 78 61			dw strncpy 
5d12 d5 62			dw list 
5d14 d9 61			dw start1 
5d16 e9 61			dw start2 
5d18			;	dw start3 
5d18 fa 61			dw start3b 
5d1a 75 62			dw start3c 
5d1c			 
5d1c				; (unit) testing words 
5d1c			 
5d1c b6 63			dw mtesta 
5d1e 6b 64			dw mtestb 
5d20 0e 65			dw mtestc 
5d22 c3 65			dw mtestd 
5d24 67 66			dw mteste 
5d26			 
5d26				; demo/game words 
5d26			 
5d26 73 6d		        dw game3w 
5d28 a1 6d		        dw game3p 
5d2a bf 6d		        dw game3sc 
5d2c f0 6d		        dw game3vsi 
5d2e 1c 6e		        dw game3vs 
5d30				 
5d30 66 6b			dw game2b 
5d32 d4 6b			dw game2bf 
5d34 1e 6c			dw game2mba 
5d36 b4 6c			dw game2mbas 
5d38 f6 6c			dw game2mb 
5d3a			 
5d3a 27 68			dw game1 
5d3c 38 68			dw game1a 
5d3e 9a 68			dw game1b 
5d40 cf 68			dw game1c 
5d42 05 69			dw game1d 
5d44 36 69			dw game1s 
5d46 4a 69			dw game1t 
5d48 5f 69			dw game1f 
5d4a 93 69			dw game1z 
5d4c d7 69			dw game1zz 
5d4e			 
5d4e 1d 67			dw test5 
5d50 55 67			dw test6 
5d52 8d 67			dw test7 
5d54 a1 67			dw test8 
5d56 cd 67			dw test9 
5d58 e3 67			dw test10 
5d5a				 
5d5a ae 6a		        dw ssv5 
5d5c 92 6a		        dw ssv4 
5d5e 76 6a		        dw ssv3 
5d60 40 6a		        dw ssv2 
5d62 c7 6a		        dw ssv1 
5d64 0f 6b		        dw ssv1cpm 
5d66			;	dw keyup 
5d66			;	dw keydown 
5d66			;	dw keyleft 
5d66			;	dw keyright 
5d66			;	dw 	keyf1 
5d66			;	dw keyf2 
5d66			;	dw keyf3 
5d66			;	dw keyf4 
5d66			;	dw keyf5 
5d66			;	dw keyf6 
5d66			;	dw keyf7 
5d66			;	dw keyf8 
5d66			;	dw keyf9 
5d66			;	dw keyf10 
5d66			;	dw keyf11 
5d66			;	dw keyf12 
5d66			;	dw keytab 
5d66			;	dw keycr 
5d66			;	dw keyhome 
5d66			;	dw keyend 
5d66			;	dw keybs 
5d66 00 00			db 0, 0	 
5d68			 
5d68			 
5d68			; File Editor 
5d68			 
5d68			; ( id - ) use 'e' to edit the displayed line 
5d68 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5d89 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5dbe			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5dbe .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5df6			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5df6			 
5df6			; SPI Net support words 
5df6			 
5df6			; v0! = node to send to 
5df6			; ( str count - ) 
5df6 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
5e4f			 
5e4f			; spiputchr ( char node - ) 
5e4f .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
5e85			 
5e85			; spigetchr ( - n ) 
5e85 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
5eb0			 
5eb0			; getnode ( - n ) 
5eb0 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
5edd			 
5edd			; ( str node - )  
5edd .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5f43			; store string ( str i - ) 
5f43			 
5f43			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5f43 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
5f98			 
5f98			; get string ( addr i -  )    TO FIX 
5f98			 
5f98 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5ff0			 
5ff0			 
5ff0			; NETCHAT (TODO) 
5ff0			; Program to allow two nodes to chat with eachother 
5ff0			; 
5ff0			; v0 - target node 
5ff0			;  
5ff0			; accept input at 0,0 
5ff0			; if input is string send spitype to target node 
5ff0			; starting at row 2,0 , while spigetchr is not zero ->  
5ff0			; 
5ff0			; 
5ff0			; TODO add paging of get request 
5ff0			 
5ff0			; ( node - ) 
5ff0 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
600f .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
6067 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until ;", 0 
60da			 
60da			 
60da			; Long read of currently open file 
60da .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
6121			 
6121			; clear stack  
6121			 
6121 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
6154			 
6154			; type ( addr count - ) 
6154 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
6178			 
6178			; some direct memory words 
6178			; strncpy ( len t f -- t ) 
6178			 
6178 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
61d9			 
61d9 .. 00		start1:     	db ": bpon $00 bp ;",0 
61e9 .. 00		start2:     	db ": bpoff $01 bp ;",0 
61fa .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
6275 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
62d5			 
62d5			 
62d5			; a handy word to list items on the stack 
62d5			 
62d5 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
633f			 
633f			 
633f			; test stack  
633f			; rnd8 stest 
633f			 
633f .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
63b6			 
63b6			; random malloc and free cycles 
63b6			 
63b6 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
646b			 
646b			; fixed malloc and free cycles 
646b			 
646b .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
650e			 
650e			; fixed double string push and drop cycle  
650e			 
650e .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
65c3			 
65c3			; consistent fixed string push and drop cycle  
65c3			 
65c3 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6667			 
6667 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
671d			 
671d			;test1:		db ": aa 1 2 3 ;", 0 
671d			;test2:     	db "111 aa 888 999",0 
671d			;test3:     	db ": bb 77 ;",0 
671d			;test4:     	db "$02 $01 do i . loop bb",0 
671d			 
671d .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6755 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
678d .. 00		test7:     	db ": box hline vline ;",0 
67a1 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
67cd .. 00		test9:     	db ": sw $01 adsp world ;",0 
67e3 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
6808 .. 00		test11:     	db "hello create .",0 
6817 .. 00		test12:     	db "hello2 create .",0 
6827			 
6827			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6827			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6827			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6827			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6827			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6827			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6827			 
6827			;iftest1:     	db "$0001 IF cls .",0 
6827			;iftest2:     	db "$0000 IF cls .",0 
6827			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6827			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6827			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6827			 
6827			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6827			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6827			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6827			 
6827			 
6827			 
6827			; a small guess the number game 
6827			 
6827 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6838 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
689a			 
689a .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
68cf .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6905 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6936 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
694a .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
695f .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6993 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
69d7			 
69d7			; Using 'ga' save a high score across multiple runs using external storage 
69d7			 
69d7 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6a40			 
6a40			 
6a40			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6a40			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6a40			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6a40			 
6a40			; simple screen saver to test code memory reuse to destruction 
6a40			 
6a40 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6a76 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6a92 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6aae .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6ac7 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6b0f .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6b66			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6b66			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6b66			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6b66			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6b66			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6b66			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6b66			 
6b66			 
6b66			 
6b66			; minesweeper/battleship finding game 
6b66			; draws a game board of random ship/mine positions 
6b66			; user enters coords to see if it hits on 
6b66			; game ends when all are hit 
6b66			; when hit or miss says how many may be in the area 
6b66			 
6b66			; setup the game board and then hide it 
6b66 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6bd4 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6c1e			; prompt for where to target 
6c1e .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6cb4 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6cd9			; TODO see if the entered coords hits or misses pushes char hit of miss 
6cd9 .. 00		game2mbht:      db ": mbckht nop ;",0 
6ce8 .. 00		game2mbms:      db ": mbcms nop ;",0 
6cf6			; TODO how many might be near by 
6cf6 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6d73			 
6d73			; Game 3 
6d73			 
6d73			; Vert scroller ski game - avoid the trees! 
6d73			 
6d73			; v0 score (ie turns) 
6d73			; v1 player pos 
6d73			; v2 left wall 
6d73			; v3 right wall 
6d73			 
6d73			; Draw side walls randomly 
6d73			 
6d73 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6da1			 
6da1			; Draw player 
6da1 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6dbf			 
6dbf			; TODO Get Key 
6dbf			 
6dbf			; TODO Move left right 
6dbf			 
6dbf			; scroll and move walls a bit 
6dbf			 
6dbf .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6df0			 
6df0			; main game loop 
6df0			 
6df0 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6e1c .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6e5b			 
6e5b			; key board defs 
6e5b			 
6e5b .. 00		keyup:       db ": keyup $05 ;",0 
6e69 .. 00		keydown:       db ": keydown $0a ;",0 
6e79 .. 00		keyleft:       db ": keyleft $0b ;",0 
6e89 .. 00		keyright:       db ": keyright $0c ;",0 
6e9a .. 00		keyf1:       db ": keyf1 $10 ;",0 
6ea8 .. 00		keyf2:       db ": keyf2 $11 ;",0 
6eb6 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6ec4 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6ed2 .. 00		keyf5:       db ": keyf5 $14 ;",0 
6ee0 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6eee .. 00		keyf7:       db ": keyf7 $16 ;",0 
6efc .. 00		keyf8:       db ": keyf8 $17 ;",0 
6f0a .. 00		keyf9:       db ": keyf9 $18 ;",0 
6f18 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6f27 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6f36 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6f45			 
6f45 .. 00		keytab:       db ": keytab $09 ;",0 
6f54 .. 00		keycr:       db ": keycr $0d ;",0 
6f62 .. 00		keyhome:       db ": keyhome $0e ;",0 
6f72 .. 00		keyend:       db ": keyend $0f ;",0 
6f81 .. 00		keybs:       db ": keybs $08 ;",0 
6f8f			 
6f8f			   
6f8f			 
6f8f			 
6f8f			 
6f8f			; eof 
# End of file forth_autostart.asm
6f8f			 
6f8f .. 00		sprompt1: db "Startup load...",0 
6f9f .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6fb5			 
6fb5			 
6fb5			 
6fb5			 
6fb5			forth_startup: 
6fb5 21 ee 5c			ld hl, startcmds 
6fb8 3e 00			ld a, 0 
6fba 32 ee f5			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6fbd			 
6fbd e5			.start1:	push hl 
6fbe cd 18 0d			call clear_display 
6fc1 11 8f 6f			ld de, sprompt1 
6fc4 3e 00		        ld a, display_row_1 
6fc6 cd 2b 0d			call str_at_display 
6fc9 11 9f 6f			ld de, sprompt2 
6fcc 3e 28		        ld a, display_row_2 
6fce cd 2b 0d			call str_at_display 
6fd1 e1				pop hl 
6fd2 e5				push hl 
6fd3 5e				ld e,(hl) 
6fd4 23				inc hl 
6fd5 56				ld d,(hl) 
6fd6 3e 50		        ld a, display_row_3 
6fd8 cd 2b 0d			call str_at_display 
6fdb cd 3b 0d			call update_display 
6fde			 
6fde			 
6fde 3a ee f5			ld a, (os_last_cmd) 
6fe1 fe 00			cp 0 
6fe3 28 05			jr z, .startprompt 
6fe5 cd 89 0c			call delay250ms 
6fe8 18 24			jr .startdo 
6fea				 
6fea				 
6fea			 
6fea			.startprompt: 
6fea			 
6fea 3e 9f			ld a,display_row_4 + display_cols - 1 
6fec 11 dd 1e		        ld de, endprg 
6fef cd 2b 0d			call str_at_display 
6ff2 cd 3b 0d			call update_display 
6ff5 cd 95 0c			call delay1s 
6ff8 cd 07 77			call cin_wait 
6ffb						 
6ffb fe 2a			cp '*' 
6ffd 28 5e			jr z, .startupend1 
6fff fe 23			cp '#' 
7001 20 07			jr nz, .startno 
7003 3e 01			ld a, 1 
7005 32 ee f5			ld (os_last_cmd),a 
7008 18 04			jr .startdo 
700a fe 31		.startno:	cp '1' 
700c 28 3a			jr z,.startnxt  
700e			 
700e				; exec startup line 
700e			.startdo:	 
700e e1				pop hl 
700f e5				push hl 
7010				 
7010 5e				ld e,(hl) 
7011 23				inc hl 
7012 56				ld d,(hl) 
7013 eb				ex de,hl 
7014			 
7014 e5				push hl 
7015			 
7015 3e 00			ld a, 0 
7017				;ld a, FORTH_END_BUFFER 
7017 cd b5 13			call strlent 
701a 23				inc hl   ; include zero term to copy 
701b 06 00			ld b,0 
701d 4d				ld c,l 
701e e1				pop hl 
701f 11 c8 f1			ld de, scratch 
7022 ed b0			ldir 
7024			 
7024			 
7024 21 c8 f1			ld hl, scratch 
7027 cd 62 23			call forthparse 
702a cd a2 23			call forthexec 
702d cd b4 22			call forthexec_cleanup 
7030			 
7030 3e 78			ld a, display_row_4 
7032 11 81 1c			ld de, endprog 
7035			 
7035 cd 3b 0d			call update_display		 
7038			 
7038 3a ee f5			ld a, (os_last_cmd) 
703b fe 00			cp 0 
703d 20 09			jr nz, .startnxt 
703f cd df 1e			call next_page_prompt 
7042 cd 18 0d		        call clear_display 
7045 cd 3b 0d			call update_display		 
7048			 
7048				; move onto next startup line? 
7048			.startnxt: 
7048			 
7048 cd 89 0c			call delay250ms 
704b e1				pop hl 
704c			 
704c 23				inc hl 
704d 23				inc hl 
704e			 
704e e5				push hl 
704f 5e				ld e, (hl) 
7050 23				inc hl 
7051 56				ld d, (hl) 
7052 e1				pop hl 
7053				; TODO replace 0 test 
7053			 
7053 eb				ex de, hl 
7054 cd 75 0f			call ishlzero 
7057			;	ld a,e 
7057			;	add d 
7057			;	cp 0    ; any left to do? 
7057 eb				ex de, hl 
7058 c2 bd 6f			jp nz, .start1 
705b 18 01			jr .startupend 
705d			 
705d e1			.startupend1: pop hl 
705e			.startupend: 
705e			 
705e cd 18 0d			call clear_display 
7061 cd 3b 0d			call update_display 
7064 c9				ret 
7065			 
7065			 
7065			; stack over and underflow checks 
7065			 
7065			; init the words to detect the under/overflow 
7065			 
7065			chk_stk_init: 
7065				; a vague random number to check so we dont get any "lucky" hits 
7065 3e 2d			ld a, 45 
7067 6f				ld l, a 
7068 00				nop 
7069 3e 17			ld a, 23 
706b 67				ld h, a 
706c			 
706c 22 af f1			ld (chk_word), hl     ; the word we need to check against 
706f			 
706f			;	ld (chk_stund), hl	; stack points.... 
706f 22 fd fe			ld (chk_stovr), hl 
7072 22 f3 f9			ld (chk_ret_und), hl 
7075 22 b1 f9			ld (chk_ret_ovr), hl 
7078 22 2f f9			ld (chk_loop_ovr), hl 
707b 22 2d f7			ld (chk_data_ovr), hl 
707e c9				ret 
707f				 
707f			check_stacks: 
707f				; check all stack words 
707f			 
707f e5				push hl 
7080 d5				push de 
7081			 
7081			;	ld de,(chk_word) 
7081			;	ld hl, (chk_stund)	; stack points.... 
7081			;	if DEBUG_STK_FAULT 
7081			;		DMARK "FAa" 
7081			;		CALLMONITOR 
7081			;	endif 
7081			;	call cmp16 
7081			;	jp z, .chk_faulta 
7081			; 
7081			;	ld de, sfaultsu 
7081			;	jp .chk_fault 
7081			 
7081 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
7084 ed 5b af f1		ld de,(chk_word) 
7088				if DEBUG_STK_FAULT 
7088					DMARK "FAb" 
7088					CALLMONITOR 
7088				endif 
7088 cd 6a 0f			call cmp16 
708b 28 06			jr z, .chk_fault1 
708d 11 2e 71			ld de, sfaultso 
7090 c3 e2 70			jp .chk_fault 
7093			.chk_fault1:  
7093 2a f3 f9			ld hl, (chk_ret_und) 
7096 ed 5b af f1		ld de,(chk_word) 
709a				if DEBUG_STK_FAULT 
709a					DMARK "FAU" 
709a					CALLMONITOR 
709a				endif 
709a cd 6a 0f			call cmp16 
709d ca a6 70			jp z, .chk_fault2 
70a0 11 3e 71			ld de, sfaultru 
70a3 c3 e2 70			jp .chk_fault 
70a6			.chk_fault2:  
70a6 2a b1 f9			ld hl, (chk_ret_ovr) 
70a9 ed 5b af f1		ld de,(chk_word) 
70ad				if DEBUG_STK_FAULT 
70ad					DMARK "FA1" 
70ad					CALLMONITOR 
70ad				endif 
70ad cd 6a 0f			call cmp16 
70b0 ca b9 70			jp z, .chk_fault3 
70b3 11 4c 71			ld de, sfaultro 
70b6 c3 e2 70			jp .chk_fault 
70b9			.chk_fault3:  
70b9 2a 2f f9			ld hl, (chk_loop_ovr) 
70bc ed 5b af f1		ld de,(chk_word) 
70c0				if DEBUG_STK_FAULT 
70c0					DMARK "FA2" 
70c0					CALLMONITOR 
70c0				endif 
70c0 cd 6a 0f			call cmp16 
70c3 ca cc 70			jp z, .chk_fault4 
70c6 11 66 71			ld de, sfaultlo 
70c9 c3 e2 70			jp .chk_fault 
70cc			.chk_fault4:  
70cc 2a 2d f7			ld hl, (chk_data_ovr) 
70cf ed 5b af f1		ld de,(chk_word) 
70d3				if DEBUG_STK_FAULT 
70d3					DMARK "FA3" 
70d3					CALLMONITOR 
70d3				endif 
70d3 cd 6a 0f			call cmp16 
70d6 ca df 70			jp z, .chk_fault5 
70d9 11 80 71			ld de, sfaultdo 
70dc c3 e2 70			jp .chk_fault 
70df			 
70df			 
70df			.chk_fault5:  
70df d1				pop de 
70e0 e1				pop hl 
70e1			 
70e1 c9				ret 
70e2			 
70e2 cd 18 0d		.chk_fault: 	call clear_display 
70e5 3e 28				ld a, display_row_2 
70e7 cd 2b 0d				call str_at_display 
70ea 11 10 71				   ld de, .stackfault 
70ed 3e 00				ld a, display_row_1 
70ef cd 2b 0d				call str_at_display 
70f2 11 6e fe				    ld de, debug_mark 
70f5 3e 11				ld a, display_row_1+17 
70f7 cd 2b 0d				call str_at_display 
70fa cd 3b 0d				call update_display 
70fd			 
70fd				; prompt before entering montior for investigating issue 
70fd			 
70fd 3e 78			ld a, display_row_4 
70ff 11 81 1c			ld de, endprog 
7102			 
7102 cd 3b 0d			call update_display		 
7105			 
7105 cd df 1e			call next_page_prompt 
7108			 
7108 d1				pop de 
7109 e1				pop hl 
710a cd d5 1c				call monitor 
710d c3 cc 1b				jp warmstart 
7110					;jp 0 
7110					;halt 
7110			 
7110			 
7110			 
7110 .. 00		.stackfault: 	db "Stack fault:",0 
711d			 
711d .. 00		sfaultsu: 	db	"Stack under flow",0 
712e .. 00		sfaultso: 	db	"Stack over flow",0 
713e .. 00		sfaultru:	db "RTS underflow",0 
714c .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
7166 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
7180 .. 00		sfaultdo:	db "DTS overflow", 0 
718d			 
718d			 
718d			fault_dsp_under: 
718d 11 9f 71			ld de, .dsp_under 
7190 c3 4f 72			jp .show_fault 
7193			 
7193			fault_rsp_under: 
7193 11 ad 71			ld de, .rsp_under 
7196 c3 4f 72			jp .show_fault 
7199			fault_loop_under: 
7199 11 bb 71			ld de, .loop_under 
719c c3 4f 72			jp .show_fault 
719f			 
719f .. 00		.dsp_under: db "DSP Underflow",0 
71ad .. 00		.rsp_under: db "RSP Underflow",0 
71bb .. 00		.loop_under: db "LOOP Underflow",0 
71ca			 
71ca			 
71ca d5			type_faultn: 	push de 
71cb e5					push hl 
71cc cd 18 0d				call clear_display 
71cf 11 f6 71				   ld de, .typefaultn 
71d2 3e 00				ld a, display_row_1 
71d4 cd 2b 0d				call str_at_display 
71d7 11 6e fe				    ld de, debug_mark 
71da 3e 11				ld a, display_row_1+17 
71dc cd 2b 0d				call str_at_display 
71df cd 3b 0d				call update_display 
71e2			 
71e2				; prompt before entering montior for investigating issue 
71e2			 
71e2 3e 78			ld a, display_row_4 
71e4 11 81 1c			ld de, endprog 
71e7			 
71e7 cd 3b 0d			call update_display		 
71ea			 
71ea cd df 1e			call next_page_prompt 
71ed			 
71ed e5					push hl 
71ee d5					push de 
71ef cd d5 1c				call monitor 
71f2 c3 cc 1b				jp warmstart 
71f5 76					halt 
71f6			 
71f6			 
71f6 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
720d			 
720d d5			type_faults: 	push de 
720e e5					push hl 
720f cd 18 0d				call clear_display 
7212 11 38 72				   ld de, .typefaults 
7215 3e 00				ld a, display_row_1 
7217 cd 2b 0d				call str_at_display 
721a 11 6e fe				    ld de, debug_mark 
721d 3e 11				ld a, display_row_1+17 
721f cd 2b 0d				call str_at_display 
7222 cd 3b 0d				call update_display 
7225			 
7225				; prompt before entering montior for investigating issue 
7225			 
7225 3e 78			ld a, display_row_4 
7227 11 81 1c			ld de, endprog 
722a			 
722a cd 3b 0d			call update_display		 
722d			 
722d cd df 1e			call next_page_prompt 
7230			 
7230 e1					pop hl 
7231 d1					pop de 
7232 cd d5 1c				call monitor 
7235 c3 cc 1b				jp warmstart 
7238			 
7238			 
7238 .. 00		.typefaults: db "STR Type Expected TOS!",0 
724f			 
724f			.show_fault: 	 
724f d5					push de 
7250 cd 18 0d				call clear_display 
7253 d1					pop de 
7254 3e 00				ld a, display_row_1 
7256 cd 2b 0d				call str_at_display 
7259 11 6e fe				    ld de, debug_mark 
725c 3e 11				ld a, display_row_1+17 
725e cd 2b 0d				call str_at_display 
7261 cd 3b 0d				call update_display 
7264			 
7264				; prompt before entering montior for investigating issue 
7264			 
7264 3e 78			ld a, display_row_4 
7266 11 81 1c			ld de, endprog 
7269			 
7269 cd 3b 0d			call update_display		 
726c			 
726c cd df 1e			call next_page_prompt 
726f			 
726f e1					pop hl 
7270 d1					pop de 
7271 cd d5 1c				call monitor 
7274			; do a dump to cli and not warmstart so we preserve all of the uwords.  
7274			; TODO Make optional fault restart to cli or warm boot? 
7274					;jp warmstart 
7274 c3 27 1c				jp cli 
7277 76					halt 
7278			 
7278			; handle the auto run of code from files in storage 
7278			 
7278			 
7278			if STORAGE_SE 
7278			 
7278 .. 00		sprompt3: db "Loading from start-up file?:",0 
7295 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
72a6			 
72a6			 
72a6			forth_autoload: 
72a6			 
72a6				; load block 0 of store 1 
72a6				 
72a6 3e fe			ld a, $fe      ; bit 0 clear 
72a8 32 67 fa			ld (spi_device), a 
72ab			 
72ab cd cd 04			call storage_get_block_0 
72ae			 
72ae 3a a2 fa			ld a, (store_page+STORE_0_AUTOFILE) 
72b1			 
72b1 fe 00			cp 0 
72b3 c8				ret z     ; auto start not enabled 
72b4			 
72b4 cd 18 0d			call clear_display 
72b7			 
72b7				; set bank 
72b7			 
72b7 3a a4 fa				ld a, (store_page+STORE_0_BANKRUN) 
72ba 32 67 fa				ld (spi_device), a 
72bd			 
72bd				; get file id to load from and get the file name to display 
72bd			 
72bd 3a a5 fa				ld a, (store_page+STORE_0_FILERUN) 
72c0			 
72c0 2e 00				ld l, 0 
72c2 67					ld h, a 
72c3 11 81 fa				ld de, store_page 
72c6			 
72c6					if DEBUG_FORTH_WORDS 
72c6						DMARK "ASp" 
72c6 f5				push af  
72c7 3a db 72			ld a, (.dmark)  
72ca 32 6e fe			ld (debug_mark),a  
72cd 3a dc 72			ld a, (.dmark+1)  
72d0 32 6f fe			ld (debug_mark+1),a  
72d3 3a dd 72			ld a, (.dmark+2)  
72d6 32 70 fe			ld (debug_mark+2),a  
72d9 18 03			jr .pastdmark  
72db ..			.dmark: db "ASp"  
72de f1			.pastdmark: pop af  
72df			endm  
# End of macro DMARK
72df						CALLMONITOR 
72df cd f3 18			call break_point_state  
72e2				endm  
# End of macro CALLMONITOR
72e2					endif 
72e2 cd 75 09				call storage_read 
72e5			 
72e5					if DEBUG_FORTH_WORDS 
72e5						DMARK "ASr" 
72e5 f5				push af  
72e6 3a fa 72			ld a, (.dmark)  
72e9 32 6e fe			ld (debug_mark),a  
72ec 3a fb 72			ld a, (.dmark+1)  
72ef 32 6f fe			ld (debug_mark+1),a  
72f2 3a fc 72			ld a, (.dmark+2)  
72f5 32 70 fe			ld (debug_mark+2),a  
72f8 18 03			jr .pastdmark  
72fa ..			.dmark: db "ASr"  
72fd f1			.pastdmark: pop af  
72fe			endm  
# End of macro DMARK
72fe						CALLMONITOR 
72fe cd f3 18			call break_point_state  
7301				endm  
# End of macro CALLMONITOR
7301					endif 
7301			 
7301 cd 75 0f				call ishlzero 
7304 c8					ret z             ; file not found 
7305			 
7305 3e 32				ld a, display_row_2 + 10 
7307 11 84 fa				ld de, store_page+3 
730a cd 2b 0d				call str_at_display 
730d				 
730d			; 
730d			 
730d 3e 05			ld a, display_row_1+5 
730f 11 78 72			ld de, sprompt3 
7312 cd 2b 0d			call str_at_display 
7315 3e 5f			ld a, display_row_3+15 
7317 11 95 72			ld de, sprompt4 
731a cd 2b 0d			call str_at_display 
731d			 
731d cd 3b 0d			call update_display 
7320			 
7320 cd 07 77			call cin_wait 
7323 fe 6e			cp 'n' 
7325 c8				ret z 
7326 fe 4e			cp 'N' 
7328 c8				ret z 
7329			 
7329 cd 95 0c			call delay1s 
732c			 
732c 3a 83 fa			ld a, (store_page+2) 
732f 32 70 fa			ld (store_openmaxext), a    ; save count of ext 
7332 3e 01			ld a, 1  
7334 32 71 fa			ld (store_openext), a    ; save count of ext 
7337			 
7337			.autof:  
7337 6f				ld l , a 
7338				 
7338 3a 81 fa			ld a, (store_page) 
733b 67				ld h, a	 
733c 11 81 fa			ld de, store_page 
733f					if DEBUG_FORTH_WORDS 
733f						DMARK "ASl" 
733f f5				push af  
7340 3a 54 73			ld a, (.dmark)  
7343 32 6e fe			ld (debug_mark),a  
7346 3a 55 73			ld a, (.dmark+1)  
7349 32 6f fe			ld (debug_mark+1),a  
734c 3a 56 73			ld a, (.dmark+2)  
734f 32 70 fe			ld (debug_mark+2),a  
7352 18 03			jr .pastdmark  
7354 ..			.dmark: db "ASl"  
7357 f1			.pastdmark: pop af  
7358			endm  
# End of macro DMARK
7358						CALLMONITOR 
7358 cd f3 18			call break_point_state  
735b				endm  
# End of macro CALLMONITOR
735b					endif 
735b cd 75 09				call storage_read 
735e cd 75 0f			call ishlzero 
7361 c8				ret z 
7362			;	jr z, .autoend 
7362			 
7362					if DEBUG_FORTH_WORDS 
7362						DMARK "ASc" 
7362 f5				push af  
7363 3a 77 73			ld a, (.dmark)  
7366 32 6e fe			ld (debug_mark),a  
7369 3a 78 73			ld a, (.dmark+1)  
736c 32 6f fe			ld (debug_mark+1),a  
736f 3a 79 73			ld a, (.dmark+2)  
7372 32 70 fe			ld (debug_mark+2),a  
7375 18 03			jr .pastdmark  
7377 ..			.dmark: db "ASc"  
737a f1			.pastdmark: pop af  
737b			endm  
# End of macro DMARK
737b						CALLMONITOR 
737b cd f3 18			call break_point_state  
737e				endm  
# End of macro CALLMONITOR
737e					endif 
737e 11 83 fa			ld de, store_page+2 
7381 3e 78			ld a, display_row_4 
7383 cd 2b 0d			call str_at_display 
7386			 
7386 cd 3b 0d			call update_display 
7389 cd 89 0c			call delay250ms 
738c			 
738c			 
738c			 
738c 21 83 fa			ld hl, store_page+2 
738f cd 62 23			call forthparse 
7392 cd a2 23			call forthexec 
7395 cd b4 22			call forthexec_cleanup 
7398			 
7398				 
7398 3a 71 fa			ld a, (store_openext) 
739b 3c				inc a 
739c 32 71 fa			ld (store_openext), a    ; save count of ext 
739f			 
739f 18 96			jr .autof 
73a1			;.autofdone: 
73a1			; 
73a1			;		if DEBUG_FORTH_WORDS 
73a1			;			DMARK "ASx" 
73a1			;			CALLMONITOR 
73a1			;		endif 
73a1			;;	call clear_display 
73a1			;	ret 
73a1			 
73a1			 
73a1			 
73a1			endif 
73a1			 
73a1			 
73a1			; eof 
# End of file forth_kernel.asm
73a1			;include "nascombasic.asm" 
73a1			 
73a1			 
73a1			; find out where the code ends if loaded into RAM (for SC114) 
73a1			;endofcode:  
73a1			;	nop 
73a1			 
73a1			 
73a1			; eof 
73a1			 
# End of file main.asm
73a1			include "firmware_lcd_4x40.asm" 
73a1			; **********************************************************************  
73a1			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
73a1			; **********************************************************************  
73a1			;  
73a1			; **  Written as a Small Computer Monitor App  
73a1			; **  www.scc.me.uk  
73a1			;  
73a1			; History  
73a1			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
73a1			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
73a1			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
73a1			;  
73a1			; **********************************************************************  
73a1			;  
73a1			; This program is an example of one of the methods of interfacing an   
73a1			; alphanumeric LCD module.   
73a1			;  
73a1			; In this example the display is connected to either a Z80 PIO or a   
73a1			; simple 8-bit output port.   
73a1			;  
73a1			; This interfacing method uses 4-bit data mode and uses time delays  
73a1			; rather than polling the display's ready status. As a result the   
73a1			; interface only requires 6 simple output lines:  
73a1			;   Output bit 0 = not used  
73a1			;   Output bit 1 = not used  
73a1			;   Output bit 2 = RS         High = data, Low = instruction  
73a1			;   Output bit 3 = E          Active high  
73a1			;   Output bit 4 = DB4  
73a1			;   Output bit 5 = DB5  
73a1			;   Output bit 6 = DB6  
73a1			;   Output bit 7 = DB7  
73a1			; Display's R/W is connected to 0v so it is always in write mode  
73a1			;  
73a1			; This set up should work with any system supporting the RC2014 bus  
73a1			  
73a1			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
73a1			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
73a1			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
73a1			;  
73a1			; **********************************************************************  
73a1			  
73a1			; Additonal for 4x40. E1 and E2 instead of just E   
73a1			; TODO swipe vidout signal on port a to activate E2  
73a1			  
73a1			; **********************************************************************  
73a1			; **  Constants  
73a1			; **********************************************************************  
73a1			; LCD constants required by LCD support module  
73a1			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
73a1			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
73a1			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
73a1			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
73a1			; TODO Decide which E is being set  
73a1			kLCDWidth:  EQU display_cols             ;Width in characters  
73a1			  
73a1			; **********************************************************************  
73a1			; **  Code library usage  
73a1			; **********************************************************************  
73a1			  
73a1			; send character to current cursor position  
73a1			; wraps and/or scrolls screen automatically  
73a1			  
73a1			  
73a1			  
73a1			lcd_init:  
73a1			  
73a1			; SCMonAPI functions used  
73a1			  
73a1			; Alphanumeric LCD functions used  
73a1			; no need to specify specific functions for this module  
73a1			  
73a1 3e cf		            LD   A, 11001111b  
73a3 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
73a5 3e 00		            LD   A, 00000000b  
73a7 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
73a9			  
73a9			; Initialise alphanumeric LCD module  
73a9 3e 00				ld a, 0  
73ab 32 ce fb				ld (display_lcde1e2), a  
73ae cd 2f 74		            CALL fLCD_Init      ;Initialise LCD module  
73b1 3e 01				ld a, 1  
73b3 32 ce fb				ld (display_lcde1e2), a  
73b6 cd 2f 74		            CALL fLCD_Init      ;Initialise LCD module  
73b9			  
73b9 c9				ret  
73ba			  
73ba			;  
73ba			;;  
73ba			; lcd functions  
73ba			;  
73ba			;  
73ba			  
73ba			; what is at cursor position   
73ba			  
73ba			;get_cursor:	ld de, (cursor_row)   ;  row + col  
73ba			;		call curptr  
73ba			;		ret  
73ba			  
73ba			  
73ba			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
73ba			  
73ba			curptr:  
73ba c5				push bc  
73bb 21 b4 fd			ld hl, display_fb0  
73be			cpr:	  
73be				; loop for cursor whole row  
73be 0e 28			ld c, display_cols  
73c0 23			cpr1:	inc hl  
73c1 0d				dec c  
73c2 20 fc			jr nz, cpr1  
73c4 05				dec b  
73c5 20 f7			jr nz, cpr  
73c7			  
73c7				; add col	  
73c7			  
73c7 23			cpr2:	inc hl  
73c8 1d				dec e  
73c9 20 fc			jr nz, cpr2  
73cb			  
73cb c1				pop bc  
73cc c9				ret  
73cd				  
73cd			  
73cd			  
73cd			  
73cd			  
73cd			; write the frame buffer given in hl to hardware   
73cd 22 cc fb		write_display: ld (display_write_tmp), hl 	   
73d0 3e 00			ld a, kLCD_Line1  
73d2 cd dc 74		            CALL fLCD_Pos       ;Position cursor to location in A  
73d5 06 28			ld b, display_cols  
73d7 ed 5b cc fb		ld de, (display_write_tmp)  
73db cd 27 74			call write_len_string  
73de				  
73de				  
73de 2a cc fb			ld hl, (display_write_tmp)  
73e1 11 28 00			ld de, display_cols  
73e4 19				add hl,de  
73e5 22 cc fb			ld (display_write_tmp),hl  
73e8			  
73e8				  
73e8 3e 28			ld a, kLCD_Line2  
73ea cd dc 74		            CALL fLCD_Pos       ;Position cursor to location in A  
73ed 06 28			ld b, display_cols  
73ef ed 5b cc fb		ld de, (display_write_tmp)  
73f3 cd 27 74			call write_len_string  
73f6				  
73f6 2a cc fb			ld hl, (display_write_tmp)  
73f9 11 28 00			ld de, display_cols  
73fc 19				add hl,de  
73fd 22 cc fb			ld (display_write_tmp),hl  
7400			  
7400				  
7400 3e 50			ld a, kLCD_Line3  
7402 cd dc 74		            CALL fLCD_Pos       ;Position cursor to location in A  
7405 06 28			ld b, display_cols  
7407 ed 5b cc fb		ld de, (display_write_tmp)  
740b cd 27 74			call write_len_string  
740e				  
740e 2a cc fb			ld hl, (display_write_tmp)  
7411 11 28 00			ld de, display_cols  
7414 19				add hl,de  
7415 22 cc fb			ld (display_write_tmp),hl  
7418			  
7418				  
7418 3e 78			ld a, kLCD_Line4  
741a cd dc 74		            CALL fLCD_Pos       ;Position cursor to location in A  
741d 06 28			ld b, display_cols  
741f ed 5b cc fb		ld de, (display_write_tmp)  
7423 cd 27 74			call write_len_string  
7426 c9					ret  
7427				  
7427				; write out a fixed length string given in b from de  
7427			  
7427 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
7428 cd 94 74		            CALL fLCD_Data      ;Write character to display  
742b 13				inc de  
742c 10 f9			djnz write_len_string  
742e c9				ret  
742f			  
742f			; Some other things to do  
742f			;            LD   A, kLCD_Clear ;Display clear  
742f			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
742f			;            LD   A, kLCD_Under ;Display on with underscore cursor  
742f			;            LD   A, kLCD_On     ;Display on with no cursor  
742f			;            ;LD   A, kLCD_Off   ;Display off  
742f			;            CALL fLCD_Inst      ;Send instruction to display  
742f			;  
742f			;  
742f			;            halt  
742f			;  
742f			;  
742f			;MsgHello:   DB  "Hello World!",0  
742f			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
742f			  
742f			; Custom characters 5 pixels wide by 8 pixels high  
742f			; Up to 8 custom characters can be defined  
742f			;BitMaps:      
742f			;; Character 0x00 = Battery icon  
742f			;            DB  01110b  
742f			;            DB  11011b  
742f			;            DB  10001b  
742f			;            DB  10001b  
742f			;            DB  11111b  
742f			;            DB  11111b  
742f			;            DB  11111b  
742f			;            DB  11111b  
742f			;; Character 0x01 = Bluetooth icon  
742f			;            DB  01100b  
742f			;            DB  01010b  
742f			;            DB  11100b  
742f			;            DB  01000b  
742f			;            DB  11100b  
742f			;            DB  01010b  
742f			;            DB  01100b  
742f			;            DB  00000b  
742f			;  
742f			  
742f			  
742f			; **********************************************************************  
742f			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
742f			; **********************************************************************  
742f			;  
742f			; **  Written as a Small Computer Monitor App   
742f			; **  Version 0.1 SCC 2018-05-16  
742f			; **  www.scc.me.uk  
742f			;  
742f			; **********************************************************************  
742f			;  
742f			; This module provides support for alphanumeric LCD modules using with  
742f			; *  HD44780 (or compatible) controller  
742f			; *  5 x 7 pixel fonts  
742f			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
742f			; *  Interface via six digital outputs to the display (see below)  
742f			;  
742f			; LCD module pinout:  
742f			;   1  Vss   0v supply  
742f			;   2  Vdd   5v supply  
742f			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
742f			;   4  RS    High = data, Low = instruction  
742f			;   5  R/W   High = Read, Low = Write  
742f			;   6  E     Enable signal (active high)  
742f			;   7  DB0   Data bit 0  
742f			;   8  DB1   Data bit 1  
742f			;   9  DB2   Data bit 2  
742f			;  10  DB3   Data bit 3  
742f			;  11  DB4   Data bit 4  
742f			;  12  DB5   Data bit 5  
742f			;  13  DB6   Data bit 6  
742f			;  14  DB7   Data bit 7  
742f			;  15  A     Backlight anode (+)  
742f			;  16  K     Backlight cathode (-)  
742f			;  
742f			; This interfacing method uses 4-bit data mode and uses time delays  
742f			; rather than polling the display's ready status. As a result the   
742f			; interface only requires 6 simple output lines:  
742f			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
742f			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
742f			;   LCD DB4 = Microcomputer output port bit 4  
742f			;   LCD DB5 = Microcomputer output port bit 5  
742f			;   LCD DB6 = Microcomputer output port bit 6  
742f			;   LCD DB7 = Microcomputer output port bit 7  
742f			; Display's R/W is connected to 0v so it is always in write mode  
742f			; All 6 connections must be on the same port address <kLCDPrt>  
742f			; This method also allows a decent length of cable from micro to LCD  
742f			;  
742f			; **********************************************************************  
742f			;  
742f			; To include the code for any given function provided by this module,   
742f			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
742f			; the parent source file.  
742f			; For example:  #REQUIRES   uHexPrefix  
742f			;  
742f			; Also #INCLUDE this file at some point after the #REQUIRES statements  
742f			; in the parent source file.  
742f			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
742f			;  
742f			; These are the function names provided by this module:  
742f			; fLCD_Init                     ;Initialise LCD  
742f			; fLCD_Inst                     ;Send instruction to LCD  
742f			; fLCD_Data                     ;Send data byte to LCD  
742f			; fLCD_Pos                      ;Position cursor  
742f			; fLCD_Str                      ;Display string  
742f			; fLCD_Def                      ;Define custom character  
742f			;  
742f			; **********************************************************************  
742f			;  
742f			; Requires SCMonAPI.asm to also be included in the project  
742f			;  
742f			  
742f			  
742f			; **********************************************************************  
742f			; **  Constants  
742f			; **********************************************************************  
742f			  
742f			; Constants that must be defined externally  
742f			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
742f			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
742f			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
742f			;kLCDWidth: EQU 20             ;Width in characters  
742f			  
742f			; general line offsets in any frame buffer  
742f			  
742f			  
742f			display_row_1: equ 0  
742f			display_row_2: equ display_row_1+display_cols  
742f			display_row_3: equ display_row_2 + display_cols  
742f			display_row_4: equ display_row_3 + display_cols  
742f			;display_row_4_eol:   
742f			  
742f			  
742f			; Cursor position values for the start of each line  
742f			  
742f			; E  
742f			kLCD_Line1: EQU 0x00   
742f			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
742f			; E1  
742f			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
742f			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
742f			  
742f			; Instructions to send as A register to fLCD_Inst  
742f			kLCD_Clear: EQU 00000001b     ;LCD clear  
742f			kLCD_Off:   EQU 00001000b     ;LCD off  
742f			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
742f			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
742f			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
742f			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
742f			  
742f			; Constants used by this code module  
742f			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
742f			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
742f			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
742f			  
742f			  
742f			  
742f			; **********************************************************************  
742f			; **  LCD support functions  
742f			; **********************************************************************  
742f			  
742f			; Initialise alphanumeric LCD module  
742f			; LCD control register codes:  
742f			;   DL   0 = 4-bit mode        1 = 8-bit mode  
742f			;   N    0 = 1-line mode       1 = 2-line mode  
742f			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
742f			;   D    0 = Display off       1 = Display on  
742f			;   C    0 = Cursor off        1 = Cursor on  
742f			;   B    0 = Blinking off      1 = Blinking on  
742f			;   ID   0 = Decrement mode    1 = Increment mode  
742f			;   SH   0 = Entire shift off  1 = Entire shift on  
742f 3e 28		fLCD_Init:  LD   A, 40  
7431 cd 56 75		            CALL LCDDelay       ;Delay 40ms after power up  
7434			; For reliable reset set 8-bit mode - 3 times  
7434 cd 26 75		            CALL WrFn8bit       ;Function = 8-bit mode  
7437 cd 26 75		            CALL WrFn8bit       ;Function = 8-bit mode  
743a cd 26 75		            CALL WrFn8bit       ;Function = 8-bit mode  
743d			; Set 4-bit mode  
743d cd 22 75		            CALL WrFn4bit       ;Function = 4-bit mode  
7440 cd 54 75		            CALL LCDDelay1      ;Delay 37 us or more  
7443			; Function set  
7443 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
7445 cd 58 74		            CALL fLCD_Inst      ;2 line, display on  
7448			; Display On/Off control  
7448 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
744a cd 58 74		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
744d			; Display Clear  
744d 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
744f cd 58 74		            CALL fLCD_Inst      ;Clear display  
7452			; Entry mode  
7452 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
7454 cd 58 74		            CALL fLCD_Inst      ;Increment mode, shift off  
7457			; Display module now initialised  
7457 c9			            RET  
7458			; ok to here  
7458			  
7458			; Write instruction to LCD  
7458			;   On entry: A = Instruction byte to be written  
7458			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7458 f5			fLCD_Inst:  PUSH AF  
7459 f5			            PUSH AF  
745a cd 6c 74		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
745d f1			            POP  AF  
745e 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
745f 17			            RLA  
7460 17			            RLA  
7461 17			            RLA  
7462 cd 6c 74		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
7465 3e 02		            LD   A, 2  
7467 cd 56 75		            CALL LCDDelay       ;Delay 2 ms to complete   
746a f1			            POP  AF  
746b c9			            RET  
746c			Wr4bits:   
746c f5					push af  
746d 3a ce fb				ld a, (display_lcde1e2)  
7470 fe 00				cp 0     ; e  
7472 20 10				jr nz, .wea2	  
7474 f1					pop af  
7475 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7477 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7479 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
747b cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
747d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
747f cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
7481 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7483 c9			            RET  
7484 f1			.wea2:		pop af  
7485 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7487 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7489 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
748b cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
748d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
748f cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
7491 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7493 c9			            RET  
7494			  
7494			  
7494			; Write data to LCD  
7494			;   On entry: A = Data byte to be written  
7494			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7494 f5			fLCD_Data:  PUSH AF  
7495 f5			            PUSH AF  
7496 cd a8 74		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7499 f1			            POP  AF  
749a 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
749b 17			            RLA  
749c 17			            RLA  
749d 17			            RLA  
749e cd a8 74		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
74a1 3e 96		            LD   A, 150  
74a3 3d			Wait:      DEC  A              ;Wait a while to allow data   
74a4 20 fd		            JR   NZ, Wait      ;  write to complete  
74a6 f1			            POP  AF  
74a7 c9			            RET  
74a8			Wr4bitsa:     
74a8 f5					push af  
74a9 3a ce fb				ld a, (display_lcde1e2)  
74ac fe 00				cp 0     ; e1  
74ae 20 16				jr nz, .we2	  
74b0 f1					pop af  
74b1 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
74b3 cb d7		            SET  kLCDBitRS, A  
74b5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
74b7 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
74b9 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
74bb d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
74bd cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
74bf d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
74c1 cb 97		            RES  kLCDBitRS, A  
74c3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
74c5 c9			            RET  
74c6 f1			.we2:		pop af  
74c7 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
74c9 cb d7		            SET  kLCDBitRS, A  
74cb d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
74cd cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
74cf cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
74d1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
74d3 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
74d5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
74d7 cb 97		            RES  kLCDBitRS, A  
74d9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
74db c9			            RET  
74dc			  
74dc			  
74dc			; Position cursor to specified location  
74dc			;   On entry: A = Cursor position  
74dc			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
74dc f5			fLCD_Pos:   PUSH AF  
74dd					; at this point set the E1 or E2 flag depending on position  
74dd			  
74dd c5					push bc  
74de			;		push af  
74de 06 00				ld b, 0  
74e0 4f					ld c, a  
74e1 3e 4f				ld a, kLCD_Line3-1  
74e3 b7			 		or a      ;clear carry flag  
74e4 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
74e5 38 04				jr c, .pe1  
74e7			  
74e7					; E selection  
74e7 cb 80				res 0, b         ; bit 0 unset e  
74e9			;		pop af    ; before line 3 so recover orig pos  
74e9			;		ld c, a    ; save for poking back  
74e9 18 06				jr .peset	          
74eb			.pe1:          	; E2 selection  
74eb cb c0				set 0, b         ; bit 0 set e1  
74ed 79					ld a, c  
74ee de 4f				sbc a, kLCD_Line3-1  
74f0 4f					ld c, a	         ; save caculated offset  
74f1			;		pop af     ; bin this original value now we have calculated form  
74f1			  
74f1			.peset:		; set bit  
74f1 78					ld a, b  
74f2 32 ce fb				ld (display_lcde1e2), a 	  
74f5 79					ld a, c  
74f6 c1					pop bc  
74f7			  
74f7 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
74f9 cd 58 74		            CALL fLCD_Inst      ;Write instruction to LCD  
74fc f1			            POP  AF  
74fd c9			            RET  
74fe			  
74fe			  
74fe			; Output text string to LCD  
74fe			;   On entry: DE = Pointer to null terminated text string  
74fe			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
74fe 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
74ff b7			            OR   A              ;Null terminator?  
7500 c8			            RET  Z              ;Yes, so finished  
7501 cd 94 74		            CALL fLCD_Data      ;Write character to display  
7504 13			            INC  DE             ;Point to next character  
7505 18 f7		            JR   fLCD_Str       ;Repeat  
7507 c9					ret  
7508			  
7508			; Define custom character  
7508			;   On entry: A = Character number (0 to 7)  
7508			;             DE = Pointer to character bitmap data  
7508			;   On exit:  A = Next character number  
7508			;             DE = Next location following bitmap  
7508			;             BC HL IX IY I AF' BC' DE' HL' preserved  
7508			; Character is   
7508 c5			fLCD_Def:   PUSH BC  
7509 f5			            PUSH AF  
750a 07			            RLCA                ;Calculate location  
750b 07			            RLCA                ;  for bitmap data  
750c 07			            RLCA                ;  = 8 x CharacterNumber  
750d f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
750f cd 58 74		            CALL fLCD_Inst      ;Write instruction to LCD  
7512 06 00		            LD   B, 0  
7514 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
7515 cd 94 74		            CALL fLCD_Data      ;Write byte to display  
7518 13			            INC  DE             ;Point to next byte  
7519 04			            INC  B              ;Count bytes  
751a cb 58		            BIT  3, B           ;Finish all 8 bytes?  
751c 28 f6		            JR   Z, Loop       ;No, so repeat  
751e f1			            POP  AF  
751f 3c			            INC  A              ;Increment character number  
7520 c1			            POP  BC  
7521 c9			            RET  
7522			  
7522			  
7522			; **********************************************************************  
7522			; **  Private functions  
7522			; **********************************************************************  
7522			  
7522			; Write function to LCD  
7522			;   On entry: A = Function byte to be written  
7522			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7522 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
7524 18 02		            JR   WrFunc  
7526 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
7528 f5			WrFunc:     PUSH AF  
7529 f5					push af  
752a 3a ce fb				ld a, (display_lcde1e2)  
752d fe 00				cp 0     ; e1  
752f 20 0f				jr nz, .wfea2	  
7531 f1					pop af  
7532 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7534 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
7536 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7538 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
753a cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
753c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
753e 18 0d			jr .wfskip  
7540 f1			.wfea2:		pop af  
7541 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7543 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
7545 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7547 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7549 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
754b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
754d 3e 05		.wfskip:            LD  A, 5  
754f cd 56 75		            CALL LCDDelay       ;Delay 5 ms to complete  
7552 f1			            POP  AF  
7553 c9			            RET  
7554			  
7554			  
7554			; Delay in milliseconds  
7554			;   On entry: A = Number of milliseconds delay  
7554			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7554 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
7556 d5			LCDDelay:   PUSH DE  
7557 5f			            LD   E, A           ;Delay by 'A' ms  
7558 16 00		            LD   D, 0  
755a cd 7a 0c		            CALL aDelayInMS  
755d d1			            POP  DE  
755e c9			            RET  
755f			  
755f			  
755f			testlcd:  
755f 3e 00			ld a, kLCD_Line1  
7561 cd dc 74			call fLCD_Pos  
7564 06 28			ld b, 40  
7566 11 94 75			ld de, .ttext1  
7569 cd 27 74			call write_len_string  
756c			  
756c 3e 28			ld a, kLCD_Line2  
756e cd dc 74			call fLCD_Pos  
7571 06 28			ld b, 40  
7573 11 bd 75			ld de, .ttext2  
7576 cd 27 74			call write_len_string  
7579 3e 50			ld a, kLCD_Line3  
757b cd dc 74			call fLCD_Pos  
757e 06 28			ld b, 40  
7580 11 e6 75			ld de, .ttext3  
7583 cd 27 74			call write_len_string  
7586 3e 78			ld a, kLCD_Line4  
7588 cd dc 74			call fLCD_Pos  
758b 06 28			ld b, 40  
758d 11 0f 76			ld de, .ttext4  
7590 cd 27 74			call write_len_string  
7593			  
7593 76				halt  
7594			  
7594			  
7594 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
75bd .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
75e6 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
760f .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
7638			   
7638			  
7638			  
7638			; eof  
7638			  
# End of file firmware_lcd_4x40.asm
7638			;include "firmware_lcd_4x20.asm" 
7638			include "firmware_key_5x10.asm" 
7638			; 5 x 10 decade counter scanner  
7638			  
7638			  
7638			; TODO do cursor shape change for shift keys  
7638			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
7638			  
7638			  
7638			; bit mask for each scan column and row for teing the matrix  
7638			  
7638			  
7638			key_init:  
7638			  
7638			; SCMonAPI functions used  
7638			  
7638			; Alphanumeric LCD functions used  
7638			; no need to specify specific functions for this module  
7638			  
7638			  
7638 3e cf		            LD   A, 11001111b  
763a d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
763c			;            LD   A, 00000000b  
763c 3e 1f		            LD   A, 00011111b  
763e d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
7640			  
7640			  
7640				; TODO Configure cursor shapes  
7640			  
7640				; Load cursor shapes   
7640 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
7642 11 52 76		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
7645 06 02		            LD   B, 2           ;Number of characters to define  
7647 cd 08 75		.DefLoop:   CALL fLCD_Def       ;Define custom character  
764a 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
764c			  
764c 3e 01				ld a, 1  
764e 32 c7 fb			ld (cursor_shape),a  
7651 c9				ret  
7652			  
7652			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
7652			; Up to 8 custom characters can be defined  
7652			.cursor_shapes:      
7652			;; Character 0x00 = Normal  
7652 1f			            DB  11111b  
7653 1f			            DB  11111b  
7654 1f			            DB  11111b  
7655 1f			            DB  11111b  
7656 1f			            DB  11111b  
7657 1f			            DB  11111b  
7658 1f			            DB  11111b  
7659 1f			            DB  11111b  
765a			;; Character 0x01 = Modifier  
765a 1f			            DB  11111b  
765b 1b			            DB  11011b  
765c 1b			            DB  11011b  
765d 1b			            DB  11011b  
765e 1b			            DB  11011b  
765f 1f			            DB  11111b  
7660 1b			            DB  11011b  
7661 1f			            DB  11111b  
7662			  
7662			  
7662			  
7662			  
7662			; Display custom character 0  
7662			;            LD   A, kLCD_Line1+14  
7662			;            CALL fLCD_Pos       ;Position cursor to location in A  
7662			;            LD   A, 0  
7662			;            CALL fLCD_Data      ;Write character in A at cursor  
7662			  
7662			; Display custom character 1  
7662			;            LD   A, kLCD_Line2+14  
7662			;            CALL fLCD_Pos      ;Position cursor to location in A  
7662			;            LD   A, 1  
7662			;            CALL fLCD_Data     ;Write character in A at cursor  
7662			  
7662			; keyboard scanning   
7662			  
7662			; character in from keyboard  
7662			  
7662			; mapping for the pcb layout  
7662			  
7662			.matrix_to_char:  
7662 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
766d .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
7678 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
7683 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
768e .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7699			.matrix_to_shift:  
7699			  
7699 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
76a4 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
76af 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
76ba 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
76c5 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
76d0			  
76d0			.matrix_to_symbolshift:  
76d0			  
76d0 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
76db .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
76e6 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
76f1			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
76f1 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
76fc .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
7707			  
7707			  
7707			  
7707			; mapping for a simple straight through breadboard layout  
7707			  
7707			;.matrix_to_char:  
7707			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7707			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
7707			;		db "asdfghjkl",KEY_CR,0  
7707			;		db "qwertyuiop",0  
7707			;		 db "1234567890",0  
7707			;.matrix_to_shift:  
7707			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
7707			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
7707			;		db "ASDFGHJKL",KEY_CR,0  
7707			;		db "QWERTYUIOP",0  
7707			;		 db "!",'"',"#$%^&*()",0  
7707			;.matrix_to_symbolshift:  
7707			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7707			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
7707			;		db "_?*fghjk=",KEY_CR,0  
7707			;		db "-/+*[]{}@#",0  
7707			;		 db "1234567890",0  
7707			  
7707			;.matrix_to_char: db "D#0*C987B654A321"  
7707			  
7707			  
7707				  
7707			  
7707			; add cin and cin_wait  
7707			  
7707 cd 18 77		cin_wait: 	call cin  
770a						if DEBUG_KEYCINWAIT  
770a							push af  
770a							  
770a							ld hl,key_repeat_ct  
770a							ld (hl),a  
770a							inc hl  
770a							call hexout  
770a							ld hl,key_repeat_ct+3  
770a							ld a,0  
770a							ld (hl),a  
770a			  
770a							    LD   A, kLCD_Line1+11  
770a							    CALL fLCD_Pos       ;Position cursor to location in A  
770a							    LD   DE, key_repeat_ct  
770a							    ;LD   DE, MsgHello  
770a							    CALL fLCD_Str       ;Display string pointed to by DE  
770a			  
770a			  
770a			  
770a							pop af  
770a						endif  
770a fe 00			cp 0  
770c 28 f9			jr z, cin_wait   ; block until key press  
770e			  
770e							if DEBUG_KEYCINWAIT  
770e								push af  
770e			  
770e								ld a, 'A'	  
770e								ld hl,key_repeat_ct  
770e								ld (hl),a  
770e								inc hl  
770e								ld a,0  
770e								ld (hl),a  
770e			  
770e								    LD   A, kLCD_Line2+11  
770e								    CALL fLCD_Pos       ;Position cursor to location in A  
770e								    LD   DE, key_repeat_ct  
770e								    ;LD   DE, MsgHello  
770e								    CALL fLCD_Str       ;Display string pointed to by DE  
770e			  
770e							call delay500ms  
770e			  
770e								pop af  
770e							endif  
770e f5				push af   ; save key pressed  
770f			  
770f			.cin_wait1:	  
770f							if DEBUG_KEYCINWAIT  
770f								push af  
770f			  
770f								ld a, 'b'	  
770f								ld hl,key_repeat_ct  
770f								ld (hl),a  
770f								inc hl  
770f								ld a,0  
770f								ld (hl),a  
770f			  
770f								    LD   A, kLCD_Line2+11  
770f								    CALL fLCD_Pos       ;Position cursor to location in A  
770f								    LD   DE, key_repeat_ct  
770f								    ;LD   DE, MsgHello  
770f								    CALL fLCD_Str       ;Display string pointed to by DE  
770f			  
770f			  
770f							call delay500ms  
770f			  
770f								pop af  
770f							endif  
770f			  
770f cd 18 77		call cin  
7712 fe 00			cp 0  
7714 20 f9			jr nz, .cin_wait1  	; wait for key release  
7716			if DEBUG_KEYCINWAIT  
7716				push af  
7716			  
7716				ld a, '3'	  
7716				ld hl,key_repeat_ct  
7716				ld (hl),a  
7716				inc hl  
7716				ld a,0  
7716				ld (hl),a  
7716			  
7716			            LD   A, kLCD_Line2+11  
7716			            CALL fLCD_Pos       ;Position cursor to location in A  
7716			            LD   DE, key_repeat_ct  
7716			            ;LD   DE, MsgHello  
7716			            CALL fLCD_Str       ;Display string pointed to by DE  
7716			  
7716			  
7716			call delay500ms  
7716			  
7716				pop af  
7716			endif  
7716			  
7716 f1				pop af   ; get key  
7717 c9				ret  
7718			  
7718			  
7718 cd 2c 77		cin: 	call .mtoc  
771b			  
771b			if DEBUG_KEYCIN  
771b				push af  
771b				  
771b				ld hl,key_repeat_ct  
771b				ld (hl),a  
771b				inc hl  
771b				call hexout  
771b				ld hl,key_repeat_ct+3  
771b				ld a,0  
771b				ld (hl),a  
771b			  
771b			            LD   A, kLCD_Line3+15  
771b			            CALL fLCD_Pos       ;Position cursor to location in A  
771b			            LD   DE, key_repeat_ct  
771b			            ;LD   DE, MsgHello  
771b			            CALL fLCD_Str       ;Display string pointed to by DE  
771b			  
771b			  
771b			call delay500ms  
771b			  
771b				pop af  
771b			endif  
771b			  
771b			  
771b				; no key held  
771b fe 00			cp 0  
771d c8				ret z  
771e			  
771e			if DEBUG_KEYCIN  
771e				push af  
771e			  
771e				ld a, '1'	  
771e				ld hl,key_repeat_ct  
771e				ld (hl),a  
771e				inc hl  
771e				ld a,0  
771e				ld (hl),a  
771e			  
771e			            LD   A, kLCD_Line4+15  
771e			            CALL fLCD_Pos       ;Position cursor to location in A  
771e			            LD   DE, key_repeat_ct  
771e			            ;LD   DE, MsgHello  
771e			            CALL fLCD_Str       ;Display string pointed to by DE  
771e			  
771e			  
771e			call delay500ms  
771e			  
771e				pop af  
771e			endif  
771e			  
771e				; stop key bounce  
771e			  
771e 32 88 fe			ld (key_held),a		 ; save it  
7721 47				ld b, a  
7722			  
7722 c5			.cina1:	push bc  
7723			if DEBUG_KEYCIN  
7723				push af  
7723			  
7723				ld hl,key_repeat_ct  
7723				inc hl  
7723				call hexout  
7723				ld hl,key_repeat_ct+3  
7723				ld a,0  
7723				ld (hl),a  
7723				ld hl,key_repeat_ct  
7723				ld a, '2'	  
7723				ld (hl),a  
7723			  
7723			            LD   A, kLCD_Line4+15  
7723			            CALL fLCD_Pos       ;Position cursor to location in A  
7723			            LD   DE, key_repeat_ct  
7723			            ;LD   DE, MsgHello  
7723			            CALL fLCD_Str       ;Display string pointed to by DE  
7723			  
7723				pop af  
7723			endif  
7723 cd 2c 77			call .mtoc  
7726 c1				pop bc  
7727 b8				cp b  
7728 28 f8			jr z, .cina1  
772a 78				ld a,b		  
772b			if DEBUG_KEYCIN  
772b				push af  
772b			  
772b				ld hl,key_repeat_ct  
772b				inc hl  
772b				call hexout  
772b				ld hl,key_repeat_ct+3  
772b				ld a,0  
772b				ld (hl),a  
772b				ld hl,key_repeat_ct  
772b				ld a, '3'	  
772b				ld (hl),a  
772b			  
772b			            LD   A, kLCD_Line4+15  
772b			            CALL fLCD_Pos       ;Position cursor to location in A  
772b			            LD   DE, key_repeat_ct  
772b			            ;LD   DE, MsgHello  
772b			            CALL fLCD_Str       ;Display string pointed to by DE  
772b			  
772b				pop af  
772b			endif  
772b c9				ret  
772c			  
772c			; detect keyboard modifier key press and apply new overlay to the face key held  
772c			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
772c			  
772c			;.cin_map_modifier:   
772c			;	ld a, (hl)  
772c			;	and 255  
772c			;	ret NZ		; modifier key not flagged  
772c			;  
772c			;	; get key face  
772c			;  
772c			;	ld b,(key_face_held)  
772c			;  
772c			;	ld b, key_cols * key_rows  
772c			;  
772c			;	push de  
772c			;	pop hl  
772c			;  
772c			;.mmod1: ld a,(hl)   ; get map test  
772c			;	cp b  
772c			;	jr z, .mmod2  
772c			;  
772c			;  
772c			;  
772c			;.mmod2: inc hl    ;   
772c			;  
772c			;	  
772c			;  
772c			;	  
772c			;  
772c			;	ld hl,key_actual_pressed  
772c			;	ld (hl),a,  
772c			;	ret  
772c			  
772c			; map matrix key held to char on face of key  
772c			  
772c			.mtoc:  
772c			  
772c			; test decade counter strobes  
772c			  
772c			;.decadetest1:  
772c			  
772c			; reset counter  
772c			;ld a, 128  
772c			;out (portbdata),a  
772c			  
772c			  
772c			;ld b, 5  
772c			;.dec1:  
772c			;ld a, 0  
772c			;out (portbdata),a  
772c			;call delay1s  
772c			  
772c			;ld a, 32  
772c			;out (portbdata),a  
772c			;call delay1s  
772c			;call delay1s  
772c			;call delay1s  
772c			;  
772c			;ld a, 64+32  
772c			;out (portbdata),a  
772c			;call delay1s  
772c			;;djnz .dec1  
772c			;  
772c			;jp .decadetest1  
772c			  
772c			  
772c			  
772c			  
772c			  
772c			  
772c			  
772c			  
772c			  
772c			  
772c				; scan keyboard matrix and generate raw scan map  
772c cd bf 77			call matrix  
772f			  
772f				; reuse c bit 0 left modifer button - ie shift  
772f			        ; reuse c bit 1 for right modifer button - ie symbol shift  
772f				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
772f			  
772f 0e 00			ld c, 0  
7731			  
7731				; TODO set flags for modifer key presses   
7731				; TODO do a search for modifer key...  
7731			  
7731				;ld hl,keyscan_table_row4  
7731 21 e7 fe			ld hl,keyscan_table_row2  
7734			  
7734 7e				ld a, (hl)  
7735 fe 23			cp '#'  
7737 20 07			jr nz, .nextmodcheck  
7739 cb c1			set 0, c  
773b 21 99 76			ld hl, .matrix_to_shift  
773e 18 21			jr .dokeymap  
7740				; TODO for now igonre  
7740			.nextmodcheck:  
7740 21 dc fe			ld hl,keyscan_table_row3  
7743			  
7743 7e				ld a, (hl)  
7744 fe 23			cp '#'  
7746 20 07			jr nz, .nextmodcheck2  
7748 cb c9			set 1, c   
774a 21 d0 76			ld hl, .matrix_to_symbolshift  
774d 18 12			jr .dokeymap  
774f			.nextmodcheck2:  
774f 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
7752			  
7752 7e				ld a, (hl)  
7753 fe 23			cp '#'  
7755 20 07			jr nz, .donemodcheck  
7757 cb c9			set 1, c   
7759 21 99 76			ld hl, .matrix_to_shift  
775c 18 03			jr .dokeymap  
775e			  
775e				; no modifer found so just map to normal keys  
775e				; get mtoc map matrix to respective keys  
775e			;	ld hl, .matrix_to_char  
775e			;	ld hl, .matrix_to_char  
775e			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
775e			;	ld a, KEY_SHIFT  
775e			;	call findchar  
775e			;  
775e			;	; got offset to key modifer in b  
775e			;  
775e			;	ld hl,keyscan_table_row5  
775e			;  
775e			;	ld a,b  
775e			;	call addatohl  
775e			;	ld a,(hl)  
775e			;  
775e			;	cp '#'  
775e			;	jr nz, .nextmodcheck  
775e			;	set 0, c  
775e			;	ld hl, .matrix_to_char  
775e			;	jr .dokeymap  
775e			;	; TODO for now igonre  
775e			;.nextmodcheck:  
775e			;	ld hl, .matrix_to_symbolshift  
775e			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
775e			;	ld a, KEY_SYMBOLSHIFT  
775e			;	call findchar  
775e			;  
775e			;  
775e			;	; got offset to key modifer in b  
775e			;  
775e			;	ld hl,keyscan_table_row5  
775e			;  
775e			;	ld a,b  
775e			;	call addatohl  
775e			;	ld a,(hl)  
775e			;  
775e			;	cp '#'  
775e			;	jr nz, .donemodcheck  
775e			;	set 1, c   
775e			;	ld hl, .matrix_to_symbolshift  
775e			;	jr .dokeymap  
775e			  
775e			  
775e			  
775e			.donemodcheck:  
775e				; no modifer found so just map to normal keys  
775e				; get mtoc map matrix to respective keys  
775e 21 62 76			ld hl, .matrix_to_char  
7761			  
7761			.dokeymap:  
7761				;ld (key_fa), c   
7761 cd 7a 77			call .mapkeys  
7764			  
7764			  
7764			if DEBUG_KEY  
7764			  
7764			; Display text on first line  
7764			            LD   A, kLCD_Line1  
7764			            CALL fLCD_Pos       ;Position cursor to location in A  
7764			            LD   DE, keyscan_table_row1  
7764			            ;LD   DE, MsgHello  
7764			            CALL fLCD_Str       ;Display string pointed to by DE  
7764			  
7764			; Display text on second line  
7764			            LD   A, kLCD_Line2  
7764			            CALL fLCD_Pos       ;Position cursor to location in A  
7764			            LD   DE, keyscan_table_row2  
7764			            CALL fLCD_Str       ;Display string pointed to by DE  
7764			            LD   A, kLCD_Line3  
7764			            CALL fLCD_Pos       ;Position cursor to location in A  
7764			            LD   DE, keyscan_table_row3  
7764			            CALL fLCD_Str       ;Display string pointed to by DE  
7764			            LD   A, kLCD_Line4  
7764			            CALL fLCD_Pos       ;Position cursor to location in A  
7764			            LD   DE, keyscan_table_row4  
7764			            CALL fLCD_Str       ;Display string pointed to by DE  
7764			            LD   A, kLCD_Line1+10  
7764			            CALL fLCD_Pos       ;Position cursor to location in A  
7764			            LD   DE, keyscan_table_row5  
7764			            CALL fLCD_Str       ;Display string pointed to by DE  
7764			  
7764				;call delay250ms  
7764			endif  
7764			;	jp testkey  
7764			  
7764			; get first char reported  
7764			  
7764 21 c6 fe			ld hl,keyscan_table_row5  
7767			  
7767				;ld b, 46   ; 30 keys to remap + 8 nulls   
7767 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7769			.findkey:  
7769 7e				ld a,(hl)  
776a fe 00			cp 0  
776c 28 04			jr z, .nextkey  
776e fe 7e			cp KEY_MATRIX_NO_PRESS  
7770 20 06			jr nz, .foundkey  
7772			.nextkey:  
7772 23				inc hl  
7773 10 f4			djnz .findkey  
7775 3e 00			ld a,0  
7777 c9				ret  
7778			.foundkey:  
7778 7e				ld a,(hl)  
7779 c9				ret  
777a				  
777a			  
777a			; convert the raw key map given hl for destination key  
777a			.mapkeys:  
777a 11 c6 fe			ld de,keyscan_table_row5  
777d			  
777d 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
777f			.remap:  
777f 1a				ld a,(de)  
7780 fe 23			cp '#'  
7782 20 02			jr nz, .remapnext  
7784				;CALLMONITOR  
7784 7e				ld a,(hl)  
7785 12				ld (de),a  
7786			  
7786			  
7786			  
7786			.remapnext:  
7786 23				inc hl  
7787 13				inc de  
7788 10 f5			djnz .remap  
778a				  
778a c9				ret  
778b			  
778b			  
778b			  
778b			.mtocold2:  
778b			  
778b			;	; flag if key D is held down and remove from reporting  
778b			;	ld bc, .key_map_fd    
778b			;	ld hl, keyscan_table  
778b			;	ld de, key_fd  
778b			;	call .key_shift_hold  
778b			;	cp 255  
778b			;	jr z, .cinmap  
778b			;	; flag if key C is held down and remove from reporting  
778b			;	ld bc, .key_map_fc    
778b			;	ld hl, keyscan_table+key_cols  
778b			;	ld de, key_fc  
778b			;	call .key_shift_hold  
778b			;	cp 255  
778b			;	jr z, .cinmap  
778b			;	; flag if key B is held down and remove from reporting  
778b			;	ld bc, .key_map_fb    
778b			;	ld hl, keyscan_table+(key_cols*2)  
778b			;	ld de, key_fb  
778b			;	call .key_shift_hold  
778b			;	cp 255  
778b			;	jr z, .cinmap  
778b			;	; flag if key A is held down and remove from reporting  
778b			;	ld bc, .key_map_fa    
778b			;	ld hl, keyscan_table+(key_cols*3)  
778b			;	ld de, key_fa  
778b			;	call .key_shift_hold  
778b			;	cp 255  
778b			;	jr z, .cinmap  
778b			  
778b 11 62 76			ld de, .matrix_to_char  
778e			  
778e			  
778e			.cinmap1:   
778e				if DEBUG_KEY  
778e			            LD   A, kLCD_Line4  
778e			            CALL fLCD_Pos       ;Position cursor to location in A  
778e					push de  
778e			            LD   DE, keyscan_table  
778e			            CALL fLCD_Str       ;Display string pointed to by DE  
778e					pop de  
778e				endif  
778e			  
778e				; scan key matrix table for any held key  
778e			  
778e				; de holds either the default matrix or one selected above  
778e			  
778e 21 93 fe			ld hl, keyscan_table  
7791 06 32			ld b,key_cols*key_rows  
7793			  
7793 7e			.cin11:	ld a,(hl)  
7794 fe 23			cp '#'  
7796 28 08			jr z, .cinhit1  
7798 23				inc hl  
7799 13				inc de  
779a 05				dec b  
779b 20 f6			jr nz, .cin11  
779d				; no key found held  
779d 3e 00			ld a,0  
779f c9				ret  
77a0 d5			.cinhit1: push de  
77a1 e1				pop hl  
77a2 7e				ld a,(hl)  
77a3 c9				ret  
77a4			  
77a4			; flag a control key is held   
77a4			; hl is key pin, de is flag indicator  
77a4			  
77a4			.key_shift_hold1:  
77a4 c5				push bc  
77a5 3e 01			ld a, 1  
77a7 32 c7 fb			ld (cursor_shape),a  
77aa 06 00			ld b, 0  
77ac 7e				ld a, (hl)  
77ad fe 2e			cp '.'  
77af 28 0a			jr z, .key_shift11  
77b1 06 ff			ld b, 255  
77b3 3e 2b			ld a, '+'    ; hide key from later scans  
77b5 77				ld (hl),a  
77b6 3e 02			ld a, 2  
77b8 32 c7 fb			ld (cursor_shape),a  
77bb			.key_shift11:  
77bb				; write flag indicator  
77bb 78				ld a,b  
77bc 12				ld (de),a  
77bd			  
77bd d1				pop de    ; de now holds the key map ptr  
77be c9				ret  
77bf			  
77bf				  
77bf			  
77bf			; scans keyboard matrix and flags key press in memory array	  
77bf				  
77bf			matrix:  
77bf				;call matrix  
77bf				; TODO optimise the code....  
77bf			  
77bf			  
77bf			;ld hl, keyscan_table_row1  
77bf			;ld de, keyscan_table_row1+1  
77bf			;ld bc,46  
77bf			;ld a,KEY_MATRIX_NO_PRESS  
77bf			;ldir  
77bf			  
77bf			  
77bf			  
77bf			; reset counter  
77bf 3e 80		ld a, 128  
77c1 d3 c1		out (portbdata),a  
77c3			  
77c3 06 0a		ld b, 10  
77c5 0e 00		ld c, 0       ; current clock toggle  
77c7			  
77c7			.colscan:  
77c7			  
77c7			; set current column  
77c7			; disable clock enable and set clock low  
77c7			  
77c7			;ld a, 0  
77c7			;out (portbdata),a  
77c7			  
77c7			; For each column scan for switches  
77c7			  
77c7 c5			push bc  
77c8 21 89 fe		ld hl, keyscan_scancol  
77cb cd d4 78		call .rowscan  
77ce c1			pop bc  
77cf			  
77cf			  
77cf			; get back current column  
77cf			  
77cf			; translate the row scan  
77cf			  
77cf			;   
77cf			; row 1  
77cf			  
77cf 78			ld a,b  
77d0			  
77d0 21 fc fe		LD   hl, keyscan_table_row1+10  
77d3			  
77d3 cd 5e 0f		call subafromhl  
77d6			;call addatohl  
77d6			  
77d6 11 89 fe		ld de, keyscan_scancol  
77d9			  
77d9 1a			ld a,(de)  
77da 77			ld (hl),a  
77db			  
77db			  
77db			  
77db			  
77db			; row 2  
77db			  
77db 78			ld a,b  
77dc			  
77dc 21 f1 fe		LD   hl, keyscan_table_row2+10  
77df			  
77df			;call addatohl  
77df cd 5e 0f		call subafromhl  
77e2			  
77e2			  
77e2 11 8a fe		ld de, keyscan_scancol+1  
77e5			  
77e5 1a			ld a,(de)  
77e6 77			ld (hl),a  
77e7			  
77e7			  
77e7			; row 3  
77e7			  
77e7 78			ld a,b  
77e8			  
77e8 21 e6 fe		LD   hl, keyscan_table_row3+10  
77eb			  
77eb			;call addatohl  
77eb cd 5e 0f		call subafromhl  
77ee			  
77ee 11 8b fe		ld de, keyscan_scancol+2  
77f1			  
77f1 1a			ld a,(de)  
77f2 77			ld (hl),a  
77f3			  
77f3			  
77f3			  
77f3			; row 4  
77f3			  
77f3 78			ld a,b  
77f4			  
77f4 21 db fe		LD   hl, keyscan_table_row4+10  
77f7			  
77f7			;call addatohl  
77f7 cd 5e 0f		call subafromhl  
77fa			  
77fa 11 8c fe		ld de, keyscan_scancol+3  
77fd			  
77fd 1a			ld a,(de)  
77fe 77			ld (hl),a  
77ff			  
77ff			; row 5  
77ff			  
77ff 78			ld a,b  
7800			  
7800 21 d0 fe		LD   hl, keyscan_table_row5+10  
7803			  
7803			;call addatohl  
7803 cd 5e 0f		call subafromhl  
7806			  
7806 11 8d fe		ld de, keyscan_scancol+4  
7809			  
7809 1a			ld a,(de)  
780a 77			ld (hl),a  
780b			  
780b			; handshake next column  
780b			  
780b			  
780b 3e 40		ld a, 64  
780d d3 c1		out (portbdata),a  
780f			  
780f 3e 00		ld a, 0  
7811 d3 c1		out (portbdata),a  
7813			  
7813			; toggle clk and move to next column  
7813			;ld a, 64  
7813			;cp c  
7813			;  
7813			;jr z, .coltoglow  
7813			;ld c, a  
7813			;jr .coltog  
7813			;.coltoglow:  
7813			;ld c, 0  
7813			;.coltog:  
7813			;ld a, c  
7813			;out (portbdata),a  
7813			  
7813 10 b2		djnz .colscan  
7815			  
7815 3e 0a		ld a,10  
7817 21 f2 fe		LD   hl, keyscan_table_row1  
781a cd 4c 0f		call addatohl  
781d 3e 00		ld a, 0  
781f 77			ld (hl), a  
7820			  
7820			  
7820 3e 0a		ld a,10  
7822 21 e7 fe		LD   hl, keyscan_table_row2  
7825 cd 4c 0f		call addatohl  
7828 3e 00		ld a, 0  
782a 77			ld (hl), a  
782b			  
782b 3e 0a		ld a,10  
782d 21 dc fe		LD   hl, keyscan_table_row3  
7830 cd 4c 0f		call addatohl  
7833 3e 00		ld a, 0  
7835 77			ld (hl), a  
7836			  
7836 3e 0a		ld a,10  
7838 21 d1 fe		LD   hl, keyscan_table_row4  
783b cd 4c 0f		call addatohl  
783e 3e 00		ld a, 0  
7840 77			ld (hl), a  
7841			  
7841 3e 0a		ld a,10  
7843 21 c6 fe		LD   hl, keyscan_table_row5  
7846 cd 4c 0f		call addatohl  
7849 3e 00		ld a, 0  
784b 77			ld (hl), a  
784c			  
784c			if DEBUG_KEY_MATRIX  
784c			  
784c			; Display text on first line  
784c			            LD   A, kLCD_Line1  
784c			            CALL fLCD_Pos       ;Position cursor to location in A  
784c			            LD   DE, keyscan_table_row1  
784c			            ;LD   DE, MsgHello  
784c			            CALL fLCD_Str       ;Display string pointed to by DE  
784c			  
784c			; Display text on second line  
784c			            LD   A, kLCD_Line2  
784c			            CALL fLCD_Pos       ;Position cursor to location in A  
784c			            LD   DE, keyscan_table_row2  
784c			            CALL fLCD_Str       ;Display string pointed to by DE  
784c			            LD   A, kLCD_Line3  
784c			            CALL fLCD_Pos       ;Position cursor to location in A  
784c			            LD   DE, keyscan_table_row3  
784c			            CALL fLCD_Str       ;Display string pointed to by DE  
784c			            LD   A, kLCD_Line4  
784c			            CALL fLCD_Pos       ;Position cursor to location in A  
784c			            LD   DE, keyscan_table_row4  
784c			            CALL fLCD_Str       ;Display string pointed to by DE  
784c			            LD   A, kLCD_Line4+10  
784c			            CALL fLCD_Pos       ;Position cursor to location in A  
784c			            LD   DE, keyscan_table_row5  
784c			            CALL fLCD_Str       ;Display string pointed to by DE  
784c			  
784c			;call delay250ms  
784c				jp matrix  
784c			endif  
784c c9			ret  
784d			  
784d			; using decade counter....  
784d			  
784d			  
784d			; TODO reset decade counter to start of scan  
784d			  
784d			; reset 15  
784d			; clock 14  
784d			; ce 13  
784d			  
784d			; 1 - q5  
784d			; 2 - q1  
784d			; 3 - q0  
784d			; 4 - q2  
784d			; 5 - q6  
784d			; 6 - q7  
784d			; 7 - q3  
784d			; 8 - vss  
784d			; 9 - q8  
784d			; 10 - q4  
784d			; 11 - q9  
784d			; 12 - cout  
784d			; 16 - vdd  
784d			  
784d			; clock      ce       reset     output  
784d			; 0          x        0         n  
784d			; x          1        0         n  
784d			; x          x        1         q0  
784d			; rising     0        0         n+1  
784d			; falling    x        0         n  
784d			; x          rising   0         n  
784d			; 1          falling  0         x+1  
784d			;  
784d			; x = dont care, if n < 5 carry = 1 otherwise 0  
784d			  
784d			;   
784d			; reset   
784d			; 13=0, 14=0, 15=1 .. 15=0  
784d			;  
784d			; handshake line  
784d			; 14=1.... read line 14=0  
784d			  
784d			  
784d			  
784d			  
784d			  
784d			; TODO hand shake clock for next column scan  
784d			; TODO detect each row  
784d			  
784d			  
784d			  
784d			  
784d			; reset 128  
784d			; clock 64  
784d			; ce 32  
784d			  
784d			  
784d			.cyclestart:  
784d			  
784d			; reset counter  
784d 3e 80		ld a, 128  
784f d3 c1		out (portbdata),a  
7851			  
7851			; loop leds  
7851 06 0a		ld b,10  
7853			  
7853			.cycle1:  
7853 c5			push bc  
7854 3e 00		ld a, 0  
7856 d3 c1		out (portbdata),a  
7858 cd 89 0c		call delay250ms  
785b			  
785b 3e 40		ld a, 64  
785d d3 c1		out (portbdata),a  
785f cd 89 0c		call delay250ms  
7862			  
7862 3e 00		ld a, 0  
7864 d3 c1		out (portbdata),a  
7866 cd 89 0c		call delay250ms  
7869			  
7869 c1			pop bc  
786a 10 e7		djnz .cycle1  
786c			  
786c			  
786c 18 df		jr .cyclestart  
786e			  
786e			  
786e			  
786e			  
786e			  
786e			  
786e			  
786e			  
786e			  
786e			; map matrix key held to char on face of key  
786e			  
786e			;.mtocold:  
786e			;  
786e			;  
786e			;; reset counter  
786e			;ld a, 128  
786e			;out (portbdata),a  
786e			;  
786e			;  
786e			;; scan keyboard row 1  
786e			;ld a, 0  
786e			;out (portbdata),a  
786e			;;ld a, 64  
786e			;;out (portbdata),a  
786e			;  
786e			;  
786e			;	ld a, 128  
786e			;	ld hl, keyscan_table  
786e			;	call .rowscan  
786e			;  
786e			;;ld a, 0  
786e			;;out (portbdata),a  
786e			;ld a, 64  
786e			;out (portbdata),a  
786e			;  
786e			;	ld a, 64  
786e			;	ld hl, keyscan_table+key_cols  
786e			;	call .rowscan  
786e			;  
786e			;ld a, 0  
786e			;out (portbdata),a  
786e			;;ld a, 64  
786e			;;out (portbdata),a  
786e			;	ld a, 32  
786e			;	ld hl, keyscan_table+(key_cols*2)  
786e			;	call .rowscan  
786e			;  
786e			;  
786e			;;ld a, 0  
786e			;;out (portbdata),a  
786e			;ld a, 64  
786e			;out (portbdata),a  
786e			;  
786e			;	ld a, 16  
786e			;	ld hl, keyscan_table+(key_cols*3)  
786e			;	call .rowscan  
786e			;  
786e			;  
786e			;	; flag if key D is held down and remove from reporting  
786e			;	ld bc, .key_map_fd    
786e			;	ld hl, keyscan_table  
786e			;	ld de, key_fd  
786e			;	call .key_shift_hold  
786e			;	cp 255  
786e			;	jr z, .cinmap  
786e			;	; flag if key C is held down and remove from reporting  
786e			;	ld bc, .key_map_fc    
786e			;	ld hl, keyscan_table+key_cols  
786e			;	ld de, key_fc  
786e			;	call .key_shift_hold  
786e			;	cp 255  
786e			;	jr z, .cinmap  
786e			;	; flag if key B is held down and remove from reporting  
786e			;	ld bc, .key_map_fb    
786e			;	ld hl, keyscan_table+(key_cols*2)  
786e			;	ld de, key_fb  
786e			;	call .key_shift_hold  
786e			;	cp 255  
786e			;	jr z, .cinmap  
786e			;	; flag if key A is held down and remove from reporting  
786e			;	ld bc, .key_map_fa    
786e			;	ld hl, keyscan_table+(key_cols*3)  
786e			;	ld de, key_fa  
786e			;	call .key_shift_hold  
786e			;	cp 255  
786e			;	jr z, .cinmap  
786e			;  
786e			;	ld de, .matrix_to_char  
786e			;  
786e			;  
786e			;.cinmap:   
786e			;	if DEBUG_KEY  
786e			;            LD   A, kLCD_Line4  
786e			;            CALL fLCD_Pos       ;Position cursor to location in A  
786e			;		push de  
786e			;            LD   DE, keyscan_table  
786e			;            CALL fLCD_Str       ;Display string pointed to by DE  
786e			;		pop de  
786e			;	endif  
786e			  
786e				; scan key matrix table for any held key  
786e			  
786e				; de holds either the default matrix or one selected above  
786e			  
786e			;	ld hl, keyscan_table  
786e			;	ld b,key_cols*key_rows  
786e			;  
786e			;.cin1:	ld a,(hl)  
786e			;	cp '#'  
786e			;	jr z, .cinhit  
786e			;	inc hl  
786e			;	inc de  
786e			;	dec b  
786e			;	jr nz, .cin1  
786e			;	; no key found held  
786e			;	ld a,0  
786e			;	ret  
786e			;.cinhit: push de  
786e			;	pop hl  
786e			;	ld a,(hl)  
786e			;	ret  
786e			  
786e			; flag a control key is held   
786e			; hl is key pin, de is flag indicator  
786e			  
786e			;.key_shift_hold:  
786e			;	push bc  
786e			;	ld a, 1  
786e			;	ld (cursor_shape),a  
786e			;	ld b, 0  
786e			;	ld a, (hl)  
786e			;	cp '.'  
786e			;	jr z, .key_shift1  
786e			;	ld b, 255  
786e			;	ld a, '+'    ; hide key from later scans  
786e			;	ld (hl),a  
786e			;	ld a, 2  
786e			;	ld (cursor_shape),a  
786e			;.key_shift1:  
786e			;	; write flag indicator  
786e			;	ld a,b  
786e			;	ld (de),a  
786e			;  
786e			;	pop de    ; de now holds the key map ptr  
786e			;	ret  
786e			  
786e				  
786e				  
786e			  
786e			  
786e			  
786e			  
786e			  
786e			  
786e			  
786e			  
786e			  
786e			  
786e			  
786e			;	push hl  
786e			;	push de  
786e			;	push bc  
786e			;	call keyscan  
786e			;	; map key matrix to ascii value of key face  
786e			;  
786e			;	ld hl, key_face_map  
786e			;	ld de, keyscan_table  
786e			;  
786e			;	; get how many keys to look at  
786e			;	ld b, keyscan_table_len  
786e			;	  
786e			;  
786e			;	; at this stage fall out on first key hit  
786e			;	; TODO handle multiple key press  
786e			;  
786e			;map1:	ld a,(hl)  
786e			;	cp '#'  
786e			;	jr z, keyhit  
786e			;	inc hl  
786e			;	inc de  
786e			;	dec b  
786e			;	jr nz, map1  
786e			;nohit:	ld a, 0  
786e			;	jr keydone  
786e			;keyhit: push de  
786e			;	pop hl  
786e			;	ld a,(hl)  
786e			;keydone:  
786e			;	push bc  
786e			;	push de  
786e			; 	push hl  
786e			;	ret   
786e			;  
786e			  
786e			  
786e			  
786e			  
786e			; scan physical key matrix  
786e			  
786e			  
786e			;keyscan:  
786e			;  
786e			;; for each key_row use keyscanr bit mask for out  
786e			;; then read in for keyscanc bitmask  
786e			;; save result of row scan to keyscantable  
786e			;  
786e			;; scan keyboard row 1  
786e			;  
786e			;	ld b, key_rows  
786e			;	ld hl, key_scanr  
786e			;	ld de, keyscan_table  
786e			;  
786e			;rowloop:  
786e			;  
786e			;	ld a,(hl)		; out bit mask to energise keyboard row  
786e			;	call rowscan  
786e			;	inc hl  
786e			;	dec b  
786e			;	jr nz, rowloop  
786e			;  
786e			;	ret  
786e			;  
786e			;  
786e			;; pass a out bitmask, b row number  
786e			;arowscan:   
786e			;	push bc  
786e			;  
786e			;	ld d, b  
786e			;  
786e			;	; calculate buffer location for this row  
786e			;  
786e			;	ld hl, keyscan_table	  
786e			;kbufr:  ld e, key_cols  
786e			;kbufc:	inc hl  
786e			;	dec e  
786e			;	jr nz, kbufc  
786e			;	dec d  
786e			;	jr nz, kbufr  
786e			;  
786e			;	; energise row and read columns  
786e			;  
786e			;	out (portbdata),a  
786e			;	in a,(portbdata)  
786e			;	ld c,a  
786e			;  
786e			;  
786e			;	; save buffer loc  
786e			;  
786e			;	ld (keybufptr), hl  
786e			;  
786e			;	ld hl, key_scanc  
786e			;	ld d, key_cols  
786e			;  
786e			;	; for each column check each bit mask  
786e			;  
786e			;colloop:  
786e			;	  
786e			;  
786e			;	; reset flags for the row   
786e			;  
786e			;	ld b,'.'  
786e			;	and (hl)  
786e			;	jr z, maskskip  
786e			;	ld b,'#'  
786e			;maskskip:  
786e			;	; save  key state  
786e			;	push hl  
786e			;	ld hl, (keybufptr)  
786e			;	ld (hl), b  
786e			;	inc hl  
786e			;	ld (keybufptr), hl  
786e			;  
786e			;	; move to next bit mask  
786e			;	pop hl  
786e			;	inc hl  
786e			;  
786e			;	dec d  
786e			;	jr nz, colloop  
786e			;  
786e			;	ret  
786e			;  
786e			;  
786e			;;  
786e			; lcd functions  
786e			;  
786e			;  
786e			  
786e			;if DEBUG_KEY_MATRIX  
786e			  
786e			; test function to display hardware view of matrix state  
786e			  
786e			matrixold:  
786e			  
786e			  
786e			  
786e			; reset counter  
786e 3e 80		ld a, 128  
7870 d3 c1		out (portbdata),a  
7872			; scan keyboard row 1  
7872 3e 00		ld a, 0  
7874 d3 c1		out (portbdata),a  
7876			;ld a, 64  
7876			;out (portbdata),a  
7876 3e 80			ld a, 128  
7878 21 f2 fe			ld hl, keyscan_table_row1  
787b cd d4 78			call .rowscan  
787e			  
787e			;ld a, 0  
787e			;out (portbdata),a  
787e 3e 40		ld a, 64  
7880 d3 c1		out (portbdata),a  
7882 3e 40			ld a, 64  
7884 21 e7 fe			ld hl, keyscan_table_row2  
7887 cd d4 78			call .rowscan  
788a			  
788a 3e 00		ld a, 0  
788c d3 c1		out (portbdata),a  
788e			;ld a, 64  
788e			;out (portbdata),a  
788e 3e 20			ld a, 32  
7890 21 dc fe			ld hl, keyscan_table_row3  
7893 cd d4 78			call .rowscan  
7896			  
7896			;ld a, 0  
7896			;out (portbdata),a  
7896 3e 40		ld a, 64  
7898 d3 c1		out (portbdata),a  
789a 3e 10			ld a, 16  
789c 21 d1 fe			ld hl, keyscan_table_row4  
789f cd d4 78			call .rowscan  
78a2			  
78a2			; Display text on first line  
78a2 3e 00		            LD   A, kLCD_Line1  
78a4 cd dc 74		            CALL fLCD_Pos       ;Position cursor to location in A  
78a7 11 f2 fe		            LD   DE, keyscan_table_row1  
78aa			            ;LD   DE, MsgHello  
78aa cd fe 74		            CALL fLCD_Str       ;Display string pointed to by DE  
78ad			  
78ad			; Display text on second line  
78ad 3e 28		            LD   A, kLCD_Line2  
78af cd dc 74		            CALL fLCD_Pos       ;Position cursor to location in A  
78b2 11 e7 fe		            LD   DE, keyscan_table_row2  
78b5 cd fe 74		            CALL fLCD_Str       ;Display string pointed to by DE  
78b8 3e 50		            LD   A, kLCD_Line3  
78ba cd dc 74		            CALL fLCD_Pos       ;Position cursor to location in A  
78bd 11 dc fe		            LD   DE, keyscan_table_row3  
78c0 cd fe 74		            CALL fLCD_Str       ;Display string pointed to by DE  
78c3 3e 78		            LD   A, kLCD_Line4  
78c5 cd dc 74		            CALL fLCD_Pos       ;Position cursor to location in A  
78c8 11 d1 fe		            LD   DE, keyscan_table_row4  
78cb cd fe 74		            CALL fLCD_Str       ;Display string pointed to by DE  
78ce			  
78ce cd 89 0c			call delay250ms  
78d1 c3 bf 77			jp matrix  
78d4			  
78d4			; pass de as row display flags  
78d4			.rowscan:   
78d4			;	out (portbdata),a  
78d4 db c1			in a,(portbdata)  
78d6 4f				ld c,a  
78d7				; reset flags for the row   
78d7 06 7e			ld b,KEY_MATRIX_NO_PRESS  
78d9 e6 01			and 1  
78db 28 02			jr z, .p1on  
78dd 06 23			ld b,'#'  
78df			.p1on:  
78df 70				ld (hl), b  
78e0 23				inc hl  
78e1			  
78e1 06 7e			ld b,KEY_MATRIX_NO_PRESS  
78e3 79				ld a,c  
78e4 e6 02			and 2  
78e6			;	bit 0,a  
78e6 28 02			jr z, .p2on  
78e8 06 23			ld b,'#'  
78ea			.p2on:  
78ea 70				ld (hl), b  
78eb 23				inc hl  
78ec			;  
78ec 06 7e			ld b,KEY_MATRIX_NO_PRESS  
78ee 79				ld a,c  
78ef e6 04			and 4  
78f1			;;	bit 0,a  
78f1 28 02			jr z, .p3on  
78f3 06 23			ld b,'#'  
78f5			.p3on:  
78f5 70				ld (hl), b  
78f6 23				inc hl  
78f7			;;  
78f7 06 7e			ld b,KEY_MATRIX_NO_PRESS  
78f9			;;	bit 0,a  
78f9 79				ld a,c  
78fa e6 08			and 8  
78fc 28 02			jr z, .p4on  
78fe 06 23			ld b,'#'  
7900			.p4on:  
7900 70				ld (hl), b  
7901 23				inc hl  
7902			  
7902 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7904			;;	bit 0,a  
7904 79				ld a,c  
7905 e6 10			and 16  
7907 28 02			jr z, .p5on  
7909 06 23			ld b,'#'  
790b			.p5on:  
790b 70				ld (hl), b  
790c 23				inc hl  
790d			; zero term  
790d 06 00			ld b,0  
790f 70				ld (hl), b  
7910			  
7910 c9			.rscandone: ret  
7911			  
7911			;addatohl:  
7911			;  
7911			 ;add   a, l    ; A = A+L  
7911			  ;  ld    l, a    ; L = A+L  
7911			   ; adc   a, h    ; A = A+L+H+carry  
7911			   ; sub   l       ; A = H+carry  
7911			   ; ld    h, a    ; H = H+carry  
7911			  
7911			;ret  
7911			; eof  
# End of file firmware_key_5x10.asm
7911			;include "firmware_key_4x10.asm" 
7911			 
7911			heap_size:    equ heap_end - heap_start 
7911			;eof 
# End of file os_mega.asm
7911
