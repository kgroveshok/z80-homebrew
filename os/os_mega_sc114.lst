# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 d9 94			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			;        nop  
8003			;        nop 
8003			;;	org 05h		; null out bdos call 
8003			; 
8003			;        nop  
8003			;        nop  
8003			;        nop 
8003			;;	org 08h 
8003			;;; 
8003			;;	jp cin		; rst 8 - char in 
8003			;;; 
8003			; 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;	org 010h 
8003			;; 
8003			;	jp cout		; rest 010h  - char out 
8003			;; 
8003			;	org 01bh   
8003			; 
8003			;	;jp  		; rst 01bh   - write string to display 
8003			;	jp str_at_display 
8003			; 
8003			; 
8003			;	org 020h 
8003			; 
8003			;	; jp		 ; rst 020h - read char at screen location 
8003			; 
8003			;	org 028h 
8003			 
8003				; jp		 ; rst 028h  - storage i/o 
8003			 
8003			; 	org 030h 
8003			;	jp break_point_state 
8003			  
8003			; $30  
8003			; org 038h 
8003			; $38 
8003			 
8003			; TODO any more important entry points to add to jump table for easier coding use? 
8003			 
8003			 
8003			include "firmware.asm" 
8003			  
8003			; main constants (used here and in firmware)  
8003			  
8003			; TODO have page 0 of storage as bios  
8003			  
8003			Device_A: equ 0h  
8003			Device_B: equ 040h          ; Sound  
8003			  
8003			if BASE_KEV  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_SC114  
8003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			; TODO fixup for CPM  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			Device_D: equ 0c0h             ; Keyboard and LCD  
8003			  
8003			; Odd specific debug points for testing hardware dev  
8003			  
8003			DEBUG_SOUND: equ 1  
8003			DEBUG_STK_FAULT: equ 0  
8003			DEBUG_INPUT: equ 0     ; Debug input entry code  
8003			DEBUG_KEYCINWAIT: equ 0  
8003			DEBUG_KEYCIN: equ 0  
8003			DEBUG_KEY: equ 0  
8003			DEBUG_KEY_MATRIX: equ 0  
8003			DEBUG_STORECF: equ 0  
8003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
8003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
8003			DEBUG_SPI: equ 0    ; low level spi tests  
8003			  
8003			; Enable many break points  
8003			  
8003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
8003			DEBUG_FORTH_JP: equ 0    ; 4  
8003			DEBUG_FORTH_MALLOC: equ 0  
8003			DEBUG_FORTH_MALLOC_INT: equ 0  
8003			DEBUG_FORTH_DOT: equ 0  
8003			DEBUG_FORTH_DOT_WAIT: equ 0  
8003			DEBUG_FORTH_MATHS: equ 0  
8003			DEBUG_FORTH_TOK: equ 0    ; 4  
8003			DEBUG_FORTH_PARSE: equ 0    ; 3  
8003			DEBUG_FORTH: equ 0  ;2  
8003			DEBUG_FORTH_WORDS: equ 1   ; 1  
8003			DEBUG_FORTH_PUSH: equ 1   ; 1  
8003			DEBUG_FORTH_UWORD: equ 1   ; 1  
8003			  
8003			; Enable key point breakpoints  
8003			  
8003			DEBUG_FORTH_DOT_KEY: equ 0  
8003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
8003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
8003			  
8003			; Debug stack imbalances  
8003			  
8003			ON: equ 1  
8003			OFF: equ 0  
8003			  
8003			DEBUG_STACK_IMB: equ 0  
8003			STACK_IMB_STORE: equ 20  
8003			  
8003			; House keeping and protections  
8003			  
8003			DEBUG_FORTH_STACK_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
8003			FORTH_ENABLE_FREE: equ 0  
8003			FORTH_ENABLE_MALLOCFREE: equ 1  
8003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
8003			FORTH_ENABLE_FLOATMATH: equ 0  
8003			  
8003			  
8003			CALLMONITOR: macro  
8003				call break_point_state  
8003				endm  
8003			  
8003			MALLOC_1: equ 1        ; from dk88   
8003			MALLOC_2: equ 0           ; broke  
8003			MALLOC_3: equ 0           ; really broke  
8003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
8003			  
8003			if BASE_KEV   
8003			stacksize: equ 512*2  
8003			  
8003			STACK_RET_SIZE: equ 128  
8003			STACK_LOOP_SIZE: equ 512  
8003			STACK_DATA_SIZE: equ 512  
8003			endif  
8003			if BASE_SC114  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			;if STORAGE_SE == 0  
8003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
8003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
8003			;endif  
8003			  
8003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
8003			  
8003			STORE_0_AUTOFILE: equ $21  
8003			STORE_0_BANKRUN: equ $23  
8003			STORE_0_FILERUN: equ $24  
8003			  
8003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
8003			  
8003			STORE_0_AUTORUN: equ $20  
8003			  
8003			; Blocks where directory table is held  
8003			  
8003			; Reducing the number of entries increases the max file size  
8003			  
8003			;STORE_DIR_START: equ 1  
8003			;STORE_DIR_END: equ 33  
8003			  
8003			; Blocks from where file data is stored  
8003			  
8003			;STORE_DATA_START: equ STORE_DIR_END + 1  
8003			  
8003			; Block indicators (<32 are data files)  
8003			  
8003			;STORE_BLOCK_CFG: equ $8f       ; config block  
8003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
8003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
8003			;STORE_BLOCK_FREE: equ $85       ; data block free  
8003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
8003			  
8003			  
8003			  
8003			; Directory entry flags  
8003			  
8003			;STORE_DIR_FREE: equ 0  
8003			;STORE_DIR_FILE:  equ 1  
8003			  
8003			; Structure offsets to directory entries  
8003			;STORE_DE_FLAG: equ 0  
8003			;STORE_DE_MAXEXT: equ 1  
8003			;STORE_DE_FILENAME: equ 2  
8003			  
8003			; Structure offsets to block 0  
8003			  
8003			;STORE_BK0_ISFOR: equ 1  
8003			;STORE_BK0_LABEL: equ 3  
8003			  
8003			; memory allocation   
8003			  
8003			chk_stund: equ tos+2           ; underflow check word  
8003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
8003			  
8003			; keyscan table needs rows x cols buffer  
8003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
8003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
8003			  
8003			keyscan_table_row1: equ chk_stovr -key_cols-1  
8003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
8003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
8003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
8003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
8003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
8003			keyscan_scancol: equ keyscan_table-key_cols  
8003			;keyscan_table_len: equ key_rows*key_cols  
8003			;keybufptr: equ keyscan_table - 2  
8003			;keysymbol: equ keybufptr - 1  
8003			key_held: equ keyscan_scancol-1	; currently held  
8003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
8003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
8003			key_fa: equ key_repeat_ct -1 ;  
8003			key_fb: equ key_fa -1 ;  
8003			key_fc: equ key_fb -1 ;  
8003			key_fd: equ key_fc -1 ;  
8003			key_face_held: equ key_fd - 1   
8003			  
8003			; flag for enabling/disabling various hardware diags   
8003			  
8003			hardware_diag: equ key_face_held - 1  
8003			  
8003			; hardware config switches  
8003			; TODO add bitmasks on includes for hardware  
8003			; high byte for expansion ids  
8003			;     0000 0000  no card inserted  
8003			;     0000 0001  storage card inserted  
8003			;     0000 0010  spi sd card active  
8003			  
8003			;       
8003			; low byte:  
8003			;     0000 0001   4x4 keypad  
8003			;     0000 0010   full keyboard  
8003			;     0000 0011   spi/ext keyboard  
8003			;     0000 0100   20x4 lcd  
8003			;     0000 1000   40x4 lcd  
8003			;     0000 1100   spi/ext display  
8003			;     0001 0000   ide interface available  
8003			  
8003			hardware_word: equ hardware_diag - 2  
8003			  
8003			; debug marker - optional display of debug point on the debug screens  
8003			  
8003			debug_mark: equ hardware_word - 4  
8003			  
8003			; input_str vars  
8003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
8003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
8003			input_size: equ input_start -1  ; number of chars  
8003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
8003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
8003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
8003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
8003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
8003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
8003			input_len: equ input_cur_onoff - 5 ; length of current input  
8003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
8003			  
8003			CUR_BLINK_RATE: equ 15  
8003			  
8003			key_actual_pressed: equ input_cursor - 1   
8003			key_symbol: equ key_actual_pressed - 1   
8003			key_shift: equ key_symbol - 1   
8003			  
8003			; Display allocation  
8003			  
8003			;display_rows: equ 4     ; move out to mini and mega files  
8003			;display_cols: equ 20  
8003			  
8003			display_fb_len: equ display_rows*display_cols  
8003			  
8003			; primary frame buffer     
8003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
8003			; working frame buffers  
8003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
8003			display_fb3: equ  display_fb1-display_fb_len - 1  
8003			display_fb2: equ  display_fb3-display_fb_len - 1  
8003			;  
8003			; pointer to active frame buffer  
8003			display_fb_active: equ display_fb2 - 2  
8003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
8003			display_write_tmp: equ display_lcde1e2 - 2  
8003			  
8003			  
8003			;  
8003			  
8003			;; can load into de directory  
8003			cursor_col: equ display_write_tmp-1  
8003			cursor_row: equ cursor_col-1  
8003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
8003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
8003			  
8003			; maths vars  
8003			  
8003			LFSRSeed: equ cursor_shape -20   
8003			randData: equ LFSRSeed - 2  
8003			xrandc: equ randData - 2  
8003			stackstore: equ xrandc - 2  
8003			seed1: equ  stackstore -2   
8003			seed2: equ seed1 - 2  
8003			  
8003			; cf storage vars  
8003			  
8003			iErrorNum:  equ seed2-1         ;Error number  
8003			iErrorReg:  equ iErrorNum -1              ;Error register  
8003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
8003			  
8003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
8003			  
8003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
8003			  
8003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
8003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
8003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
8003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
8003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
8003			store_tmpid: equ store_tmp3 - 1		; page temp id  
8003			store_tmpext: equ store_tmpid - 1		; file extent temp  
8003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
8003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
8003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
8003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
8003			;  
8003			; spi vars  
8003			  
8003			  
8003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
8003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
8003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
8003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
8003			spi_device_id: equ spi_device - 1    ; human readable bank number  
8003			  
8003			;;;;; forth cli params  
8003			  
8003			; TODO use a different frame buffer for forth???  
8003			  
8003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
8003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
8003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
8003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
8003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
8003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
8003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
8003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
8003			  
8003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
8003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
8003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
8003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
8003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
8003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
8003			  
8003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
8003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
8003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
8003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
8003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
8003			  
8003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
8003			  
8003			; os/forth token vars  
8003			  
8003			os_last_cmd: equ os_var_array-255  
8003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
8003			os_current_i: equ os_cli_cmd-2  
8003			os_cur_ptr: equ os_current_i-2  
8003			os_word_scratch: equ os_cur_ptr-30  
8003			os_tok_len: equ os_word_scratch - 2  
8003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
8003			os_tok_malloc: equ os_tok_ptr - 2  
8003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
8003			os_input: equ os_last_new_uword-255  
8003			execscratch: equ os_input-255        ; exec cmd eval buffer  
8003			scratch: equ execscratch-255  
8003			  
8003			  
8003			; temp locations for new word processing to save on adding more   
8003			  
8003			os_new_malloc: equ scratch-2  
8003			os_new_parse_len: equ os_new_malloc - 2  
8003			os_new_word_len: equ os_new_parse_len - 2  
8003			os_new_work_ptr: equ os_new_word_len - 2  
8003			os_new_src_ptr: equ os_new_work_ptr - 2  
8003			os_new_exec: equ os_new_src_ptr - 2  
8003			os_new_exec_ptr: equ os_new_exec - 2  
8003			  
8003			; resume memory alloocations....  
8003			  
8003			os_view_disable: equ os_new_exec_ptr - 1  
8003			os_view_af: equ os_view_disable - 2  
8003			os_view_hl: equ os_view_af -2  
8003			os_view_de: equ os_view_hl - 2  
8003			os_view_bc: equ os_view_de - 2  
8003			  
8003			; stack checksum word  
8003			if DEBUG_STACK_IMB  
8003				curframe: equ  os_view_de - 5  
8003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
8003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			else  
8003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			endif  
8003			  
8003			; with data stack could see memory filled with junk. need some memory management   
8003			; malloc and free entry points added  
8003			  
8003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
8003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			;heap_end: equ free_list-1  ; Starting address of heap  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			heap_end: equ chk_word-1  ; Starting address of heap  
8003			  
8003			  
8003			;if BASE_KEV   
8003			;heap_start: equ 0800eh  ; Starting address of heap  
8003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;heap_start: equ baseram+15  ; Starting address of heap  
8003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;endif  
8003			  
8003			  
8003			;;;;  
8003			  
8003			  
8003			; change below to point to last memory alloc above  
8003			topusermem:  equ   heap_start  
8003			  
8003			;if BASE_KEV   
8003			;baseusermem: equ 08000h  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;;aseusermem:     equ    12  
8003			;baseusermem:     equ    prompt  
8003			;;baseusermem:     equ    endofcode  
8003			;endif  
8003			  
8003			  
8003			; **********************************************************************  
8003			; **  Constants  
8003			; **********************************************************************  
8003			  
8003			; Constants used by this code module  
8003			kDataReg:   EQU Device_D           ;PIO port A data register  
8003			kContReg:   EQU Device_D+2           ;PIO port A control register  
8003			  
8003			  
8003			portbdata:  equ Device_D+1    ; port b data  
8003			portbctl:   equ Device_D+3    ; port b control  
8003			  
8003			  
8003			;KEY_SHIFT:   equ 5  
8003			;KEY_SYMBOLSHIFT:  equ 6  
8003			  
8003			KEY_SHIFTLOCK: equ 4  
8003			  
8003			  
8003			KEY_UP: equ 5  
8003			KEY_NEXTWORD: equ 6  
8003			KEY_PREVWORD: equ 7  
8003			KEY_BS: equ 8  
8003			KEY_TAB:  equ 9  
8003			KEY_DOWN: equ 10  
8003			KEY_LEFT: equ 11  
8003			KEY_RIGHT: equ 12  
8003			KEY_CR:   equ 13  
8003			KEY_HOME: equ 14  
8003			KEY_END: equ 15  
8003			  
8003			KEY_F1: equ 16  
8003			KEY_F2: equ 17  
8003			KEY_F3: equ 18  
8003			KEY_F4: equ 19  
8003			  
8003			KEY_F5: equ 20  
8003			KEY_F6: equ 21  
8003			KEY_F7: equ 22  
8003			KEY_F8: equ 23  
8003			  
8003			KEY_F9: equ 24  
8003			KEY_F10: equ 25  
8003			KEY_F11: equ 26  
8003			KEY_F12: equ 27  
8003			  
8003			;if DEBUG_KEY  
8003			;	KEY_MATRIX_NO_PRESS: equ '.'  
8003			;	KEY_SHIFT:   equ '.'  
8003			;	KEY_SYMBOLSHIFT:  equ '.'  
8003			;else  
8003				KEY_SHIFT:   equ '~'  
8003				KEY_SYMBOLSHIFT:  equ '~'  
8003				KEY_MATRIX_NO_PRESS: equ '~'  
8003			;endi  
8003			  
8003			  
8003			  
8003			  
8003			; Macro to make adding debug marks easier  
8003			  
8003			DMARK: macro str  
8003				push af  
8003				ld a, (.dmark)  
8003				ld (debug_mark),a  
8003				ld a, (.dmark+1)  
8003				ld (debug_mark+1),a  
8003				ld a, (.dmark+2)  
8003				ld (debug_mark+2),a  
8003				jr .pastdmark  
8003			.dmark: db str  
8003			.pastdmark: pop af  
8003			  
8003			endm  
8003			  
8003			  
8003			; macro to detect for stack imbalances  
8003			  
8003			include "stackimbal.asm"  
8003			; Macro and code to detect stock imbalances 
8003			 
8003			SPPUSH: equ 0 
8003			 
8003			; Add a stack frame which can be checked before return 
8003			 
8003			STACKFRAME: macro onoff frame1 frame2 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003						exx 
8003			 
8003						ld de, frame1 
8003						ld a, d 
8003						ld hl, curframe 
8003						call hexout 
8003						ld a, e 
8003						ld hl, curframe+2 
8003						call hexout 
8003			  
8003						ld hl, frame1 
8003						push hl 
8003						ld hl, frame2 
8003						push hl 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			endm 
8003			 
8003			STACKFRAMECHK: macro onoff frame1 frame2 
8003			 
8003					 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						exx 
8003						; check stack frame SP 
8003			 
8003						ld hl, frame2 
8003						pop de   ; frame2 
8003			 
8003						call cmp16 
8003						jr nz, .spnosame 
8003						 
8003			 
8003						ld hl, frame1 
8003						pop de   ; frame1 
8003			 
8003						call cmp16 
8003						jr z, .spfrsame 
8003			 
8003						.spnosame: call showsperror 
8003			 
8003						.spfrsame: nop 
8003			 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			 
8003			 
8003			endm 
8003			 
8003			 
8003			; for a sub routine, wrap SP collection and comparisons 
8003			 
8003			; Usage: 
8003			; 
8003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
8003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
8003			 
8003			SAVESP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003			 
8003						ld (store_sp+(storeword*4)), sp 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			CHECKSP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003			 
8003						; save SP after last save 
8003				 
8003						ld (store_sp+(storeword*4)+2), sp 
8003			 
8003						push hl 
8003						ld hl, store_sp+(storeword*4) 
8003						call check_stack_sp  
8003						pop hl 
8003			 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			if DEBUG_STACK_IMB 
8003			 
8003			check_stack_sp: 
8003					push de 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					push de 
8003			 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					pop hl 
8003			 
8003			 
8003					; check to see if the same 
8003			 
8003					call cmp16 
8003					jr z, .spsame 
8003			 
8003					; not same 
8003			 
8003					call showsperror 
8003			.spsame: 
8003			 
8003					pop de 
8003			 
8003					ret 
8003			 
8003			.sperr:  db "Stack imbalance",0 
8003			 
8003			 
8003			showsperror: 
8003			 
8003			 
8003				push hl 
8003				push af 
8003				push de 
8003				call clear_display 
8003				ld de, .sperr 
8003				ld a,0 
8003			;	ld de,os_word_scratch 
8003				call str_at_display 
8003				ld a, display_row_1+17 
8003				ld de, debug_mark 
8003				call str_at_display 
8003				ld a, 0 
8003				ld (curframe+4),a 
8003				ld hl, curframe 
8003				ld de, os_word_scratch 
8003				ld a, display_row_4 
8003				call str_at_display 
8003				call update_display 
8003				;call break_point_state 
8003				call cin_wait 
8003			 
8003				ld a, ' ' 
8003				ld (os_view_disable), a 
8003				pop de	 
8003				pop af 
8003				pop hl 
8003				CALLMONITOR 
8003				ret 
8003			 
8003			endif 
8003			 
8003			 
8003			 
8003			; eof 
# End of file stackimbal.asm
8003			  
8003			;TODO macro to calc col and row offset into screen  
8003			  
8003			  
8003			  
8003			hardware_init:  
8003			  
8003 3e 00				ld a, 0  
8005 32 80 ee				ld (hardware_diag), a  
8008			  
8008					; clear all the buffers  
8008			  
8008 21 1f ed				ld hl, display_fb1  
800b 22 db eb				ld (display_fb_active), hl  
800e			  
800e cd 7a 88				call clear_display  
8011			  
8011 21 dd eb				ld hl, display_fb2  
8014 22 db eb				ld (display_fb_active), hl  
8017			  
8017 cd 7a 88				call clear_display  
801a			  
801a					; init primary frame buffer area  
801a 21 c0 ed				ld hl, display_fb0  
801d 22 db eb				ld (display_fb_active), hl  
8020			  
8020 cd 7a 88				call clear_display  
8023			  
8023			  
8023 cd cb d7				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8026			  
8026 cd 6d d8			call key_init  
8029 cd b0 80			call storage_init  
802c			  
802c				; setup malloc functions  
802c			  
802c				if MALLOC_1  
802c cd 4a 8f				call  heap_init  
802f				endif  
802f				if MALLOC_4  
802f					call  heap_init  
802f				endif  
802f			  
802f				; init sound hardware if present  
802f			  
802f				if SOUND_ENABLE  
802f					call sound_init  
802f				endif  
802f			  
802f				; lcd test sequence  
802f					  
802f cd 9d 88			call update_display  
8032 cd fa 87			call delay1s  
8035 3e 2b			ld a,'+'  
8037 cd 7f 88			call fill_display  
803a cd 9d 88			call update_display  
803d cd fa 87			call delay1s  
8040 3e 2a			ld a,'*'  
8042 cd 7f 88			call fill_display  
8045 cd 9d 88			call update_display  
8048 cd fa 87			call delay1s  
804b 3e 2d			ld a,'-'  
804d cd 7f 88			call fill_display  
8050 cd 9d 88			call update_display  
8053 cd fa 87			call delay1s  
8056			  
8056			; boot splash screen  
8056			if display_cols == 20	  
8056			        ld a, display_row_1    
8056			else  
8056 3e 0a		        ld a, display_row_1 +10   
8058			endif  
8058 11 89 80			ld de, bootmsg  
805b cd 8d 88			call str_at_display  
805e cd 9d 88			call update_display  
8061			  
8061			  
8061 cd fa 87			call delay1s  
8064 cd fa 87			call delay1s  
8067			if display_cols == 20	  
8067			            LD   A, display_row_3+2  
8067			else  
8067 3e 5c		            LD   A, display_row_3+12  
8069			endif  
8069 11 9e 80			ld de, bootmsg1  
806c cd 8d 88			call str_at_display  
806f cd 9d 88			call update_display  
8072 cd fa 87			call delay1s  
8075 cd fa 87			call delay1s  
8078			  
8078			;	ld a, display_row_4+3  
8078			;	ld de, bootmsg2  
8078			;	call str_at_display  
8078			;	call update_display  
8078			;	call delay1s  
8078			;	call delay1s  
8078			  
8078			; debug mark setup  
8078			  
8078 3e 5f		ld a, '_'  
807a 32 7a ee		ld (debug_mark),a  
807d 32 7b ee		ld (debug_mark+1),a  
8080 32 7c ee		ld (debug_mark+2),a  
8083 3e 00		ld a,0  
8085 32 7d ee		ld (debug_mark+3),a  
8088			  
8088 c9					ret  
8089			  
8089			  
8089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
809e .. 00		bootmsg1:	db "by Kevin Groves",0  
80ae			;bootmsg2:	db "Firmware v0.1",0  
80ae			  
80ae			; a 4x20 lcd  
80ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80ae			  
80ae			;if display_cols == 20  
80ae			;	include "firmware_lcd_4x20.asm"  
80ae			;endif  
80ae			  
80ae			;if display_cols == 40  
80ae			;	include "firmware_lcd_4x40.asm"  
80ae			;endif  
80ae			  
80ae			;  
80ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80ae			; TODO abstract the bit bang video out interface for dual display  
80ae			; TODO wire video out to tx pin on rc2014 bus  
80ae			  
80ae			; must supply cin, and cin_wait for low level hardware abstraction   
80ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80ae			; test scancode  
80ae			  
80ae			;;;;;  
80ae			;;;  
80ae			; Moved out to mini and maxi versions  
80ae			;  
80ae			; include "firmware_key_4x4.asm"  
80ae			; using existing 4 wire x 4 resistor array for input  
80ae			;include "firmware_key_4x10.asm"  
80ae			; need to mod the board for 5 rows due to resistor array  
80ae			;include "firmware_key_5x10.asm"  
80ae			  
80ae			; storage hardware interface  
80ae			  
80ae			; use microchip serial eeprom for storage  
80ae			  
80ae			  
80ae			if STORAGE_SE  
80ae				include "firmware_spi.asm"  
80ae				include "firmware_seeprom.asm"  
80ae			else  
80ae			   ; create some stubs for the labels  
80ae c9			se_readbyte: ret  
80af c9			se_writebyte: ret  
80b0 c9			storage_init: ret  
80b1			  
80b1			endif  
80b1			  
80b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80b1			;include "firmware_cf.asm"  
80b1			  
80b1			; load up high level storage hardward abstractions  
80b1			include "firmware_storage.asm"  
80b1			 
80b1			; persisent storage hardware abstraction layer  
80b1			 
80b1			 
80b1			 
80b1			; Block 0 on storage is a config state 
80b1			 
80b1			 
80b1			 
80b1			; TODO add read phy block and write phy block functions 
80b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80b1			 
80b1			; Abstraction layer  
80b1			 
80b1			; Logocial block size is same size as physical size - using tape concept 
80b1			 
80b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80b1			 
80b1			 
80b1			 
80b1			; Filesystem layout (Logical layout) 
80b1			; 
80b1			; Block 0 - Bank config  
80b1			; 
80b1			;      Byte - 0 file id counter 
80b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80b1			;      Byte - 3-20 zero terminated bank label 
80b1			; 
80b1			; Block 1 > File storage 
80b1			; 
80b1			;      Byte 0 file id    - block 0 file details 
80b1			;      Byte 1 block id - block 0 is file  
80b1			;            Byte 2-15 - File name 
80b1			; 
80b1			;       - to end of block data 
80b1			; 
80b1			 
80b1			 
80b1			; Read Block 
80b1			; ---------- 
80b1			; 
80b1			; With current bank 
80b1			;  
80b1			; Get block number to read 
80b1			; Load physical blocks starting at start block into buffer 
80b1			 
80b1			; de points to buffer to use 
80b1			; hl holds logical block number  
80b1			 
80b1			storage_read_block: 
80b1			 
80b1				; TODO bank selection 
80b1			 
80b1				; for each of the physical blocks read it into the buffer 
80b1 06 40			ld b, STORE_BLOCK_PHY 
80b3			 
80b3				if DEBUG_STORESE 
80b3 d5					push de 
80b4				endif 
80b4				 
80b4			.rl1:    
80b4			 
80b4				; read physical block at hl into de 
80b4			        ; increment hl and de to next read position on exit 
80b4			 
80b4 e5				push hl 
80b5 d5				push de	 
80b6 c5				push bc 
80b7			;	if DEBUG_STORESE 
80b7			;		push af 
80b7			;		ld a, 'R' 
80b7			;		ld (debug_mark),a 
80b7			;		pop af 
80b7			;		CALLMONITOR 
80b7			;	endif 
80b7 cd ae 80			call se_readbyte 
80ba			;	if DEBUG_STORESE 
80ba			;		ld a,(spi_portbyte) 
80ba			;		ld l, a 
80ba			;		push af 
80ba			;		ld a, '1' 
80ba			;		ld (debug_mark),a 
80ba			;		pop af 
80ba			;		CALLMONITOR 
80ba			;	endif 
80ba c1				pop bc 
80bb d1				pop de 
80bc e1				pop hl 
80bd 12				ld (de),a 
80be 23				inc hl 
80bf 13				inc de 
80c0			 
80c0			;	if DEBUG_STORESE 
80c0			;		push af 
80c0			;		ld a, 'r' 
80c0			;		ld (debug_mark),a 
80c0			;		pop af 
80c0			;		CALLMONITOR 
80c0			;	endif 
80c0			 
80c0 10 f2			djnz .rl1 
80c2			 
80c2				if DEBUG_STORESE 
80c2					DMARK "SRB" 
80c2 f5				push af  
80c3 3a d7 80			ld a, (.dmark)  
80c6 32 7a ee			ld (debug_mark),a  
80c9 3a d8 80			ld a, (.dmark+1)  
80cc 32 7b ee			ld (debug_mark+1),a  
80cf 3a d9 80			ld a, (.dmark+2)  
80d2 32 7c ee			ld (debug_mark+2),a  
80d5 18 03			jr .pastdmark  
80d7 ..			.dmark: db "SRB"  
80da f1			.pastdmark: pop af  
80db			endm  
# End of macro DMARK
80db d1					pop de 
80dc			; 
80dc			;		push af 
80dc			;		ld a, 'R' 
80dc			;		ld (debug_mark),a 
80dc			;		pop af 
80dc					CALLMONITOR 
80dc cd 03 93			call break_point_state  
80df				endm  
# End of macro CALLMONITOR
80df				endif 
80df c9				ret	 
80e0				 
80e0			 
80e0			; File Size 
80e0			; --------- 
80e0			; 
80e0			;   hl file id 
80e0			; 
80e0			;  returns in hl the number of blocks 
80e0			 
80e0			storage_file_size: 
80e0 5d				ld e, l 
80e1 16 00			ld d, 0 
80e3 21 40 00			ld hl, STORE_BLOCK_PHY 
80e6					if DEBUG_FORTH_WORDS 
80e6						DMARK "SIZ" 
80e6 f5				push af  
80e7 3a fb 80			ld a, (.dmark)  
80ea 32 7a ee			ld (debug_mark),a  
80ed 3a fc 80			ld a, (.dmark+1)  
80f0 32 7b ee			ld (debug_mark+1),a  
80f3 3a fd 80			ld a, (.dmark+2)  
80f6 32 7c ee			ld (debug_mark+2),a  
80f9 18 03			jr .pastdmark  
80fb ..			.dmark: db "SIZ"  
80fe f1			.pastdmark: pop af  
80ff			endm  
# End of macro DMARK
80ff						CALLMONITOR 
80ff cd 03 93			call break_point_state  
8102				endm  
# End of macro CALLMONITOR
8102					endif 
8102 cd d2 83			call storage_findnextid 
8105			 
8105 cd d0 8a			call ishlzero 
8108			;	ld a, l 
8108			;	add h 
8108			;	cp 0 
8108 c8				ret z			; block not found so EOF 
8109			 
8109 11 65 eb			ld de, store_page 
810c cd b1 80			call storage_read_block 
810f			 
810f 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
8112 6f				ld l, a 
8113 26 00			ld h, 0 
8115 c9			 	ret 
8116			 
8116			 
8116			; Write Block 
8116			; ----------- 
8116			; 
8116			; With current bank 
8116			;  
8116			; Get block number to write 
8116			; Write physical blocks starting at start block from buffer 
8116			  
8116			storage_write_block: 
8116				; TODO bank selection 
8116			 
8116				; for each of the physical blocks read it into the buffer 
8116 06 40			ld b, STORE_BLOCK_PHY 
8118			 
8118				if DEBUG_STORESE 
8118					DMARK "SWB" 
8118 f5				push af  
8119 3a 2d 81			ld a, (.dmark)  
811c 32 7a ee			ld (debug_mark),a  
811f 3a 2e 81			ld a, (.dmark+1)  
8122 32 7b ee			ld (debug_mark+1),a  
8125 3a 2f 81			ld a, (.dmark+2)  
8128 32 7c ee			ld (debug_mark+2),a  
812b 18 03			jr .pastdmark  
812d ..			.dmark: db "SWB"  
8130 f1			.pastdmark: pop af  
8131			endm  
# End of macro DMARK
8131			 
8131					;push af 
8131					;ld a, 'W' 
8131					;ld (debug_mark),a 
8131					;pop af 
8131					CALLMONITOR 
8131 cd 03 93			call break_point_state  
8134				endm  
# End of macro CALLMONITOR
8134				endif 
8134			 
8134			; might not be working 
8134			;	call se_writepage 
8134			 
8134			;	ret 
8134			; 
8134			 
8134			 
8134			 
8134			.wl1:    
8134			 
8134				; read physical block at hl into de 
8134			        ; increment hl and de to next read position on exit 
8134			 
8134 e5				push hl 
8135 d5				push de	 
8136 c5				push bc 
8137 1a				ld a,(de) 
8138				;if DEBUG_STORESE 
8138			;		push af 
8138			;		ld a, 'W' 
8138			;		ld (debug_mark),a 
8138			;		pop af 
8138			;		CALLMONITOR 
8138			;	endif 
8138 cd af 80			call se_writebyte 
813b			;	call delay250ms 
813b 00				nop 
813c 00				nop 
813d 00				nop 
813e			;	if DEBUG_STORESE 
813e			;		push af 
813e			;		ld a, 'w' 
813e			;		ld (debug_mark),a 
813e			;		pop af 
813e			;		CALLMONITOR 
813e			;	endif 
813e c1				pop bc 
813f d1				pop de 
8140 e1				pop hl 
8141 23				inc hl 
8142 13				inc de 
8143			 
8143			 
8143 10 ef			djnz .wl1 
8145			 
8145				if DEBUG_STORESE 
8145					DMARK "SW2" 
8145 f5				push af  
8146 3a 5a 81			ld a, (.dmark)  
8149 32 7a ee			ld (debug_mark),a  
814c 3a 5b 81			ld a, (.dmark+1)  
814f 32 7b ee			ld (debug_mark+1),a  
8152 3a 5c 81			ld a, (.dmark+2)  
8155 32 7c ee			ld (debug_mark+2),a  
8158 18 03			jr .pastdmark  
815a ..			.dmark: db "SW2"  
815d f1			.pastdmark: pop af  
815e			endm  
# End of macro DMARK
815e			 
815e					;push af 
815e					;ld a, 'W' 
815e					;ld (debug_mark),a 
815e					;pop af 
815e					CALLMONITOR 
815e cd 03 93			call break_point_state  
8161				endm  
# End of macro CALLMONITOR
8161				endif 
8161 c9				ret	 
8162			 
8162			; Init bank 
8162			; --------- 
8162			; 
8162			; With current bank 
8162			; 
8162			; Setup block 0 config 
8162			;     Set 0 file id counter 
8162			;     Set formatted byte pattern 
8162			;     Zero out bank label 
8162			;      
8162			; For every logical block write 0-1 byte as null 
8162			 
8162			storage_get_block_0: 
8162			 
8162				; TODO check presence 
8162			 
8162				; get block 0 config 
8162			 
8162 21 00 00			ld hl, 0 
8165 11 65 eb			ld de, store_page 
8168 cd b1 80			call storage_read_block 
816b			 
816b				if DEBUG_STORESE 
816b					DMARK "SB0" 
816b f5				push af  
816c 3a 80 81			ld a, (.dmark)  
816f 32 7a ee			ld (debug_mark),a  
8172 3a 81 81			ld a, (.dmark+1)  
8175 32 7b ee			ld (debug_mark+1),a  
8178 3a 82 81			ld a, (.dmark+2)  
817b 32 7c ee			ld (debug_mark+2),a  
817e 18 03			jr .pastdmark  
8180 ..			.dmark: db "SB0"  
8183 f1			.pastdmark: pop af  
8184			endm  
# End of macro DMARK
8184 11 65 eb				ld de, store_page 
8187			;		push af 
8187			;		ld a, 'i' 
8187			;		ld (debug_mark),a 
8187			;		pop af 
8187					CALLMONITOR 
8187 cd 03 93			call break_point_state  
818a				endm  
# End of macro CALLMONITOR
818a				endif 
818a			 
818a				; is this area formatted? 
818a			 
818a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
818a 2a 66 eb			ld hl, (store_page+1) 
818d 3e 80			ld a,0x80 
818f bd				cp l 
8190 20 22			jr nz, .ininotformatted 
8192				; do a double check 
8192 3e 27			ld a, 0x27 
8194 bc				cp h 
8195 20 1d			jr nz, .ininotformatted 
8197			 
8197				; formatted then 
8197			 
8197				if DEBUG_STORESE 
8197					DMARK "SB1" 
8197 f5				push af  
8198 3a ac 81			ld a, (.dmark)  
819b 32 7a ee			ld (debug_mark),a  
819e 3a ad 81			ld a, (.dmark+1)  
81a1 32 7b ee			ld (debug_mark+1),a  
81a4 3a ae 81			ld a, (.dmark+2)  
81a7 32 7c ee			ld (debug_mark+2),a  
81aa 18 03			jr .pastdmark  
81ac ..			.dmark: db "SB1"  
81af f1			.pastdmark: pop af  
81b0			endm  
# End of macro DMARK
81b0					;push af 
81b0					;ld a, 'I' 
81b0					;ld (debug_mark),a 
81b0					;pop af 
81b0					CALLMONITOR 
81b0 cd 03 93			call break_point_state  
81b3				endm  
# End of macro CALLMONITOR
81b3				endif 
81b3 c9				ret 
81b4			 
81b4			.ininotformatted: 
81b4				; bank not formatted so poke various bits to make sure 
81b4			 
81b4				if DEBUG_STORESE 
81b4					DMARK "SB2" 
81b4 f5				push af  
81b5 3a c9 81			ld a, (.dmark)  
81b8 32 7a ee			ld (debug_mark),a  
81bb 3a ca 81			ld a, (.dmark+1)  
81be 32 7b ee			ld (debug_mark+1),a  
81c1 3a cb 81			ld a, (.dmark+2)  
81c4 32 7c ee			ld (debug_mark+2),a  
81c7 18 03			jr .pastdmark  
81c9 ..			.dmark: db "SB2"  
81cc f1			.pastdmark: pop af  
81cd			endm  
# End of macro DMARK
81cd					;push af 
81cd					;ld a, 'f' 
81cd					;ld (debug_mark),a 
81cd					;pop af 
81cd					CALLMONITOR 
81cd cd 03 93			call break_point_state  
81d0				endm  
# End of macro CALLMONITOR
81d0				endif 
81d0			 
81d0 cd bd 87			call storage_clear_page 
81d3			 
81d3 21 65 eb			ld hl, store_page 
81d6 3e 00			ld a, 0 
81d8				 
81d8 77				ld (hl),a   ; reset file counter 
81d9			 
81d9 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
81dc 22 66 eb		 	ld (store_page+1), hl	 
81df			 
81df				; set default label 
81df			 
81df 21 7b 82			ld hl, .defaultbanklabl 
81e2 11 68 eb		 	ld de, store_page+3 
81e5 01 0f 00			ld bc, 15 
81e8 ed b0			ldir 
81ea			 
81ea				; Append the current bank id 
81ea 21 71 eb			ld hl, store_page+3+9 
81ed 3a 4a eb			ld a, (spi_device_id) 
81f0 77				ld (hl), a 
81f1			 
81f1				; save default page 0 
81f1			 
81f1 21 00 00			ld hl, 0 
81f4 11 65 eb			ld de, store_page 
81f7				if DEBUG_STORESE 
81f7					DMARK "SB3" 
81f7 f5				push af  
81f8 3a 0c 82			ld a, (.dmark)  
81fb 32 7a ee			ld (debug_mark),a  
81fe 3a 0d 82			ld a, (.dmark+1)  
8201 32 7b ee			ld (debug_mark+1),a  
8204 3a 0e 82			ld a, (.dmark+2)  
8207 32 7c ee			ld (debug_mark+2),a  
820a 18 03			jr .pastdmark  
820c ..			.dmark: db "SB3"  
820f f1			.pastdmark: pop af  
8210			endm  
# End of macro DMARK
8210			;		push af 
8210			;		ld a, 'F' 
8210			;		ld (debug_mark),a 
8210			;		pop af 
8210					CALLMONITOR 
8210 cd 03 93			call break_point_state  
8213				endm  
# End of macro CALLMONITOR
8213				endif 
8213 cd 16 81			call storage_write_block 
8216				if DEBUG_STORESE 
8216					DMARK "SB4" 
8216 f5				push af  
8217 3a 2b 82			ld a, (.dmark)  
821a 32 7a ee			ld (debug_mark),a  
821d 3a 2c 82			ld a, (.dmark+1)  
8220 32 7b ee			ld (debug_mark+1),a  
8223 3a 2d 82			ld a, (.dmark+2)  
8226 32 7c ee			ld (debug_mark+2),a  
8229 18 03			jr .pastdmark  
822b ..			.dmark: db "SB4"  
822e f1			.pastdmark: pop af  
822f			endm  
# End of macro DMARK
822f			;		push af 
822f			;		ld a, '>' 
822f			;		ld (debug_mark),a 
822f			;		pop af 
822f					CALLMONITOR 
822f cd 03 93			call break_point_state  
8232				endm  
# End of macro CALLMONITOR
8232				endif 
8232			 
8232 00				nop 
8233 00				nop 
8234 00				nop 
8235			 
8235				; now set 0 in every page to mark as a free block 
8235			 
8235 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8237 21 40 00			ld hl, STORE_BLOCK_PHY 
823a			 
823a 3e 00		.setmark1:   	ld a,0 
823c e5					push hl 
823d c5					push bc 
823e cd af 80				call se_writebyte 
8241 3e 0a			ld a, 10 
8243 cd df 87			call aDelayInMS 
8246 23				inc hl 
8247 cd af 80				call se_writebyte 
824a 3e 0a			ld a, 10 
824c cd df 87			call aDelayInMS 
824f 2b				dec hl 
8250 c1					pop bc 
8251 e1					pop hl 
8252 3e 40				ld a, STORE_BLOCK_PHY 
8254 cd a7 8a				call addatohl 
8257 10 e1				djnz .setmark1 
8259			 
8259 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
825b 3e 00		.setmark2:   	ld a,0 
825d e5					push hl 
825e c5					push bc 
825f cd af 80				call se_writebyte 
8262 3e 0a			ld a, 10 
8264 cd df 87			call aDelayInMS 
8267 23				inc hl 
8268 cd af 80				call se_writebyte 
826b 3e 0a			ld a, 10 
826d cd df 87			call aDelayInMS 
8270 2b				dec hl 
8271 c1					pop bc 
8272 e1					pop hl 
8273 3e 40				ld a, STORE_BLOCK_PHY 
8275 cd a7 8a				call addatohl 
8278 10 e1				djnz .setmark2 
827a			 
827a					 
827a			 
827a			 
827a c9				ret 
827b			 
827b			 
827b			 
827b			 
827b .. 00		.defaultbanklabl:   db "BankLabel_",0 
8286			 
8286			 
8286			 
8286			; Label Bank 
8286			; ---------- 
8286			; 
8286			; With current bank 
8286			; Read block 0 
8286			; Set label 
8286			; Write block 0 
8286			 
8286			; label str pointer in hl 
8286			 
8286			storage_label:     
8286			 
8286				if DEBUG_STORESE 
8286					DMARK "LBL" 
8286 f5				push af  
8287 3a 9b 82			ld a, (.dmark)  
828a 32 7a ee			ld (debug_mark),a  
828d 3a 9c 82			ld a, (.dmark+1)  
8290 32 7b ee			ld (debug_mark+1),a  
8293 3a 9d 82			ld a, (.dmark+2)  
8296 32 7c ee			ld (debug_mark+2),a  
8299 18 03			jr .pastdmark  
829b ..			.dmark: db "LBL"  
829e f1			.pastdmark: pop af  
829f			endm  
# End of macro DMARK
829f					CALLMONITOR 
829f cd 03 93			call break_point_state  
82a2				endm  
# End of macro CALLMONITOR
82a2				endif 
82a2			 
82a2 e5				push hl 
82a3			 
82a3 cd 62 81			call storage_get_block_0 
82a6			 
82a6				; set default label 
82a6			 
82a6 e1				pop hl 
82a7			 
82a7 11 68 eb		 	ld de, store_page+3 
82aa 01 0f 00			ld bc, 15 
82ad				if DEBUG_STORESE 
82ad					DMARK "LB3" 
82ad f5				push af  
82ae 3a c2 82			ld a, (.dmark)  
82b1 32 7a ee			ld (debug_mark),a  
82b4 3a c3 82			ld a, (.dmark+1)  
82b7 32 7b ee			ld (debug_mark+1),a  
82ba 3a c4 82			ld a, (.dmark+2)  
82bd 32 7c ee			ld (debug_mark+2),a  
82c0 18 03			jr .pastdmark  
82c2 ..			.dmark: db "LB3"  
82c5 f1			.pastdmark: pop af  
82c6			endm  
# End of macro DMARK
82c6					CALLMONITOR 
82c6 cd 03 93			call break_point_state  
82c9				endm  
# End of macro CALLMONITOR
82c9				endif 
82c9 ed b0			ldir 
82cb				; save default page 0 
82cb			 
82cb 21 00 00			ld hl, 0 
82ce 11 65 eb			ld de, store_page 
82d1				if DEBUG_STORESE 
82d1					DMARK "LBW" 
82d1 f5				push af  
82d2 3a e6 82			ld a, (.dmark)  
82d5 32 7a ee			ld (debug_mark),a  
82d8 3a e7 82			ld a, (.dmark+1)  
82db 32 7b ee			ld (debug_mark+1),a  
82de 3a e8 82			ld a, (.dmark+2)  
82e1 32 7c ee			ld (debug_mark+2),a  
82e4 18 03			jr .pastdmark  
82e6 ..			.dmark: db "LBW"  
82e9 f1			.pastdmark: pop af  
82ea			endm  
# End of macro DMARK
82ea					CALLMONITOR 
82ea cd 03 93			call break_point_state  
82ed				endm  
# End of macro CALLMONITOR
82ed				endif 
82ed cd 16 81			call storage_write_block 
82f0			 
82f0 c9				ret 
82f1			 
82f1			 
82f1			 
82f1			; Read Block 0 - Config 
82f1			; --------------------- 
82f1			; 
82f1			; With current bank 
82f1			; Call presence test 
82f1			;    If not present format/init bank  
82f1			; Read block 0  
82f1			;  
82f1			 
82f1			 
82f1			; Dir 
82f1			; --- 
82f1			; 
82f1			; With current bank 
82f1			; Load Block 0 Config 
82f1			; Get max file id number 
82f1			; For each logical block 
82f1			;    Read block read byte 2 
82f1			;      if first block of file 
82f1			;         Display file name 
82f1			;         Display type flags for file 
82f1			;        
82f1			 
82f1			; moving to words as this requires stack control 
82f1			 
82f1			 
82f1			; Delete File 
82f1			; ----------- 
82f1			; 
82f1			; With current bank 
82f1			; 
82f1			; Load Block 0 Config 
82f1			; Get max file id number 
82f1			; For each logical block 
82f1			;    Read block file id 
82f1			;      If first block of file and dont have file id 
82f1			;         if file to delete 
82f1			;         Save file id 
82f1			;         Null file id 
82f1			;         Write this block back 
82f1			;      If file id is one saved 
82f1			;         Null file id 
82f1			;         Write this block back 
82f1			 
82f1			storage_erase: 
82f1			 
82f1				; hl contains the file id 
82f1			 
82f1 5d				ld e, l 
82f2 16 00			ld d, 0 
82f4 21 40 00			ld hl, STORE_BLOCK_PHY 
82f7					if DEBUG_FORTH_WORDS 
82f7						DMARK "ERA" 
82f7 f5				push af  
82f8 3a 0c 83			ld a, (.dmark)  
82fb 32 7a ee			ld (debug_mark),a  
82fe 3a 0d 83			ld a, (.dmark+1)  
8301 32 7b ee			ld (debug_mark+1),a  
8304 3a 0e 83			ld a, (.dmark+2)  
8307 32 7c ee			ld (debug_mark+2),a  
830a 18 03			jr .pastdmark  
830c ..			.dmark: db "ERA"  
830f f1			.pastdmark: pop af  
8310			endm  
# End of macro DMARK
8310						CALLMONITOR 
8310 cd 03 93			call break_point_state  
8313				endm  
# End of macro CALLMONITOR
8313					endif 
8313 cd d2 83			call storage_findnextid 
8316			 
8316 e5				push hl 
8317			 
8317				; TODO check file not found 
8317			 
8317 11 65 eb			ld de, store_page 
831a cd b1 80			call storage_read_block 
831d			 
831d					if DEBUG_FORTH_WORDS 
831d						DMARK "ER1" 
831d f5				push af  
831e 3a 32 83			ld a, (.dmark)  
8321 32 7a ee			ld (debug_mark),a  
8324 3a 33 83			ld a, (.dmark+1)  
8327 32 7b ee			ld (debug_mark+1),a  
832a 3a 34 83			ld a, (.dmark+2)  
832d 32 7c ee			ld (debug_mark+2),a  
8330 18 03			jr .pastdmark  
8332 ..			.dmark: db "ER1"  
8335 f1			.pastdmark: pop af  
8336			endm  
# End of macro DMARK
8336						CALLMONITOR 
8336 cd 03 93			call break_point_state  
8339				endm  
# End of macro CALLMONITOR
8339					endif 
8339 3a 65 eb			ld a, (store_page)	; get file id 
833c 32 5e eb			ld (store_tmpid), a 
833f			 
833f 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
8342 32 5d eb			ld (store_tmpext), a 
8345			 
8345				; wipe file header 
8345			 
8345 e1				pop hl 
8346 3e 00			ld a, 0 
8348 32 65 eb			ld (store_page), a 
834b 32 66 eb			ld (store_page+1),a 
834e 11 65 eb			ld de, store_page 
8351					if DEBUG_FORTH_WORDS 
8351						DMARK "ER2" 
8351 f5				push af  
8352 3a 66 83			ld a, (.dmark)  
8355 32 7a ee			ld (debug_mark),a  
8358 3a 67 83			ld a, (.dmark+1)  
835b 32 7b ee			ld (debug_mark+1),a  
835e 3a 68 83			ld a, (.dmark+2)  
8361 32 7c ee			ld (debug_mark+2),a  
8364 18 03			jr .pastdmark  
8366 ..			.dmark: db "ER2"  
8369 f1			.pastdmark: pop af  
836a			endm  
# End of macro DMARK
836a						CALLMONITOR 
836a cd 03 93			call break_point_state  
836d				endm  
# End of macro CALLMONITOR
836d					endif 
836d cd 16 81			call storage_write_block 
8370			 
8370			 
8370				; wipe file extents 
8370			 
8370 3a 5d eb			ld a, (store_tmpext) 
8373 47				ld b, a 
8374			 
8374			.eraext:	  
8374 c5				push bc 
8375			 
8375 21 40 00			ld hl, STORE_BLOCK_PHY 
8378 3a 5e eb			ld a,(store_tmpid) 
837b 5f				ld e, a 
837c 50				ld d, b	 
837d					if DEBUG_FORTH_WORDS 
837d						DMARK "ER3" 
837d f5				push af  
837e 3a 92 83			ld a, (.dmark)  
8381 32 7a ee			ld (debug_mark),a  
8384 3a 93 83			ld a, (.dmark+1)  
8387 32 7b ee			ld (debug_mark+1),a  
838a 3a 94 83			ld a, (.dmark+2)  
838d 32 7c ee			ld (debug_mark+2),a  
8390 18 03			jr .pastdmark  
8392 ..			.dmark: db "ER3"  
8395 f1			.pastdmark: pop af  
8396			endm  
# End of macro DMARK
8396						CALLMONITOR 
8396 cd 03 93			call break_point_state  
8399				endm  
# End of macro CALLMONITOR
8399					endif 
8399 cd d2 83			call storage_findnextid 
839c			 
839c e5				push hl 
839d 11 65 eb			ld de, store_page 
83a0 cd b1 80			call storage_read_block 
83a3			 
83a3				; free block	 
83a3			 
83a3 3e 00			ld a, 0 
83a5 32 65 eb			ld (store_page), a 
83a8 32 66 eb			ld (store_page+1),a 
83ab 11 65 eb			ld de, store_page 
83ae e1				pop hl 
83af					if DEBUG_FORTH_WORDS 
83af						DMARK "ER4" 
83af f5				push af  
83b0 3a c4 83			ld a, (.dmark)  
83b3 32 7a ee			ld (debug_mark),a  
83b6 3a c5 83			ld a, (.dmark+1)  
83b9 32 7b ee			ld (debug_mark+1),a  
83bc 3a c6 83			ld a, (.dmark+2)  
83bf 32 7c ee			ld (debug_mark+2),a  
83c2 18 03			jr .pastdmark  
83c4 ..			.dmark: db "ER4"  
83c7 f1			.pastdmark: pop af  
83c8			endm  
# End of macro DMARK
83c8						CALLMONITOR 
83c8 cd 03 93			call break_point_state  
83cb				endm  
# End of macro CALLMONITOR
83cb					endif 
83cb cd 16 81			call storage_write_block 
83ce			 
83ce c1				pop bc 
83cf 10 a3			djnz .eraext 
83d1			 
83d1 c9				ret 
83d2			 
83d2			 
83d2			; Find Free Block 
83d2			; --------------- 
83d2			; 
83d2			; With current bank 
83d2			;  
83d2			; From given starting logical block 
83d2			;    Read block  
83d2			;    If no file id 
83d2			;         Return block id 
83d2			 
83d2			 
83d2			; hl starting page number 
83d2			; hl contains free page number or zero if no pages free 
83d2			; e contains the file id to locate 
83d2			; d contains the block number 
83d2			 
83d2			; TODO change to find file id and use zero for free block 
83d2			 
83d2			storage_findnextid: 
83d2			 
83d2				; now locate first 0 page to mark as a free block 
83d2			 
83d2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
83d4			;	ld hl, STORE_BLOCK_PHY 
83d4			 
83d4					if DEBUG_FORTH_WORDS 
83d4					DMARK "FNI" 
83d4 f5				push af  
83d5 3a e9 83			ld a, (.dmark)  
83d8 32 7a ee			ld (debug_mark),a  
83db 3a ea 83			ld a, (.dmark+1)  
83de 32 7b ee			ld (debug_mark+1),a  
83e1 3a eb 83			ld a, (.dmark+2)  
83e4 32 7c ee			ld (debug_mark+2),a  
83e7 18 03			jr .pastdmark  
83e9 ..			.dmark: db "FNI"  
83ec f1			.pastdmark: pop af  
83ed			endm  
# End of macro DMARK
83ed						CALLMONITOR 
83ed cd 03 93			call break_point_state  
83f0				endm  
# End of macro CALLMONITOR
83f0					endif 
83f0			.ff1:   	 
83f0 e5					push hl 
83f1 c5					push bc 
83f2 d5					push de 
83f3 cd ae 80				call se_readbyte 
83f6 5f					ld e,a 
83f7 23					inc hl 
83f8 cd ae 80				call se_readbyte 
83fb 57					ld d, a 
83fc e1					pop hl 
83fd e5					push hl 
83fe cd c5 8a				call cmp16 
8401 28 49				jr z, .fffound 
8403			 
8403 d1					pop de 
8404 c1					pop bc 
8405 e1					pop hl 
8406			 
8406					; is found? 
8406					;cp e 
8406					;ret z 
8406			 
8406 3e 40				ld a, STORE_BLOCK_PHY 
8408 cd a7 8a				call addatohl 
840b 10 e3				djnz .ff1 
840d			 
840d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
840f			.ff2:   	 
840f			 
840f e5					push hl 
8410 c5					push bc 
8411 d5					push de 
8412 cd ae 80				call se_readbyte 
8415 5f					ld e,a 
8416 23					inc hl 
8417 cd ae 80				call se_readbyte 
841a 57					ld d, a 
841b			 
841b e1					pop hl 
841c e5					push hl 
841d cd c5 8a				call cmp16 
8420 28 2a				jr z, .fffound 
8422			 
8422 d1					pop de 
8423 c1					pop bc 
8424 e1					pop hl 
8425					; is found? 
8425					;cp e 
8425					;ret z 
8425			 
8425 3e 40				ld a, STORE_BLOCK_PHY 
8427 cd a7 8a				call addatohl 
842a 10 e3				djnz .ff2 
842c			 
842c			 
842c					if DEBUG_FORTH_WORDS 
842c					DMARK "FN-" 
842c f5				push af  
842d 3a 41 84			ld a, (.dmark)  
8430 32 7a ee			ld (debug_mark),a  
8433 3a 42 84			ld a, (.dmark+1)  
8436 32 7b ee			ld (debug_mark+1),a  
8439 3a 43 84			ld a, (.dmark+2)  
843c 32 7c ee			ld (debug_mark+2),a  
843f 18 03			jr .pastdmark  
8441 ..			.dmark: db "FN-"  
8444 f1			.pastdmark: pop af  
8445			endm  
# End of macro DMARK
8445					;	push af 
8445					;	ld a, 'n' 
8445					;	ld (debug_mark),a 
8445					;	pop af 
8445						CALLMONITOR 
8445 cd 03 93			call break_point_state  
8448				endm  
# End of macro CALLMONITOR
8448					endif 
8448				; no free marks! 
8448 21 00 00				ld hl, 0 
844b c9				ret 
844c			.fffound: 
844c				 
844c			 
844c d1					pop de 
844d c1					pop bc 
844e e1					pop hl 
844f					if DEBUG_FORTH_WORDS 
844f					DMARK "FNF" 
844f f5				push af  
8450 3a 64 84			ld a, (.dmark)  
8453 32 7a ee			ld (debug_mark),a  
8456 3a 65 84			ld a, (.dmark+1)  
8459 32 7b ee			ld (debug_mark+1),a  
845c 3a 66 84			ld a, (.dmark+2)  
845f 32 7c ee			ld (debug_mark+2),a  
8462 18 03			jr .pastdmark  
8464 ..			.dmark: db "FNF"  
8467 f1			.pastdmark: pop af  
8468			endm  
# End of macro DMARK
8468					;	push af 
8468					;	ld a, 'n' 
8468					;	ld (debug_mark),a 
8468					;	pop af 
8468						CALLMONITOR 
8468 cd 03 93			call break_point_state  
846b				endm  
# End of macro CALLMONITOR
846b					endif 
846b c9				ret 
846c			 
846c			 
846c			 
846c			; Free Space 
846c			; ---------- 
846c			; 
846c			; With current bank 
846c			; 
846c			; Set block count to zero 
846c			; Starting with first logical block 
846c			;      Find free block  
846c			;      If block id given, increment block count 
846c			; 
846c			;  
846c			 
846c			 
846c			; hl contains count of free blocks 
846c			 
846c			storage_freeblocks: 
846c			 
846c				; now locate first 0 page to mark as a free block 
846c			 
846c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
846e 21 40 00			ld hl, STORE_BLOCK_PHY 
8471 11 00 00			ld de, 0 
8474			 
8474			.fb1:   	 
8474 e5					push hl 
8475 c5					push bc 
8476 d5					push de 
8477 cd ae 80				call se_readbyte 
847a d1					pop de 
847b c1					pop bc 
847c e1					pop hl 
847d			 
847d					; is free? 
847d fe 00				cp 0 
847f 20 01				jr nz, .ff1cont 
8481 13					inc de 
8482			 
8482			.ff1cont: 
8482			 
8482			 
8482 3e 40				ld a, STORE_BLOCK_PHY 
8484 cd a7 8a				call addatohl 
8487 10 eb				djnz .fb1 
8489			 
8489 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
848b			.fb2:   	 
848b e5					push hl 
848c c5					push bc 
848d d5					push de 
848e cd ae 80				call se_readbyte 
8491 d1					pop de 
8492 c1					pop bc 
8493 e1					pop hl 
8494			 
8494					; is free? 
8494 fe 00				cp 0 
8496 20 01				jr nz, .ff2cont 
8498 13					inc de 
8499			 
8499			.ff2cont: 
8499			 
8499 3e 40				ld a, STORE_BLOCK_PHY 
849b cd a7 8a				call addatohl 
849e 10 eb				djnz .fb2 
84a0			 
84a0 eb				ex de, hl 
84a1 c9				ret 
84a2			 
84a2			; Get File ID 
84a2			; ----------- 
84a2			; 
84a2			; With current bank 
84a2			;  
84a2			; Load Block 0 Config 
84a2			; Get max file id number 
84a2			; For each logical block 
84a2			;    Read block file id 
84a2			;      If first block of file and dont have file id 
84a2			;         if file get id and exit 
84a2			 
84a2			 
84a2			 
84a2			 
84a2			; Create File 
84a2			; ----------- 
84a2			; 
84a2			; With current bank  
84a2			; Load Block 0 Config 
84a2			; Get max file id number 
84a2			; Increment file id number 
84a2			; Save Config 
84a2			; Find free block 
84a2			; Set buffer with file name and file id 
84a2			; Write buffer to free block  
84a2			 
84a2			 
84a2			; hl point to file name 
84a2			; hl returns file id 
84a2			 
84a2			; file format: 
84a2			; byte 0 - file id 
84a2			; byte 1 - extent number 
84a2			; byte 2-> data 
84a2			 
84a2			; format for extent number 0: 
84a2			; 
84a2			; byte 0 - file id 
84a2			; byte 1 - extent 0 
84a2			; byte 2 - extent count 
84a2			; byte 3 -> file name and meta data 
84a2			 
84a2			 
84a2			storage_create: 
84a2				if DEBUG_STORESE 
84a2					DMARK "SCR" 
84a2 f5				push af  
84a3 3a b7 84			ld a, (.dmark)  
84a6 32 7a ee			ld (debug_mark),a  
84a9 3a b8 84			ld a, (.dmark+1)  
84ac 32 7b ee			ld (debug_mark+1),a  
84af 3a b9 84			ld a, (.dmark+2)  
84b2 32 7c ee			ld (debug_mark+2),a  
84b5 18 03			jr .pastdmark  
84b7 ..			.dmark: db "SCR"  
84ba f1			.pastdmark: pop af  
84bb			endm  
# End of macro DMARK
84bb					CALLMONITOR 
84bb cd 03 93			call break_point_state  
84be				endm  
# End of macro CALLMONITOR
84be				endif 
84be			 
84be e5				push hl		; save file name pointer 
84bf			 
84bf cd 62 81			call storage_get_block_0 
84c2			 
84c2 3a 65 eb			ld a,(store_page)	; get current file id 
84c5 3c				inc a 
84c6 32 65 eb			ld (store_page),a 
84c9				 
84c9 32 5e eb			ld (store_tmpid),a			; save id 
84cc			 
84cc 21 00 00			ld hl, 0 
84cf 11 65 eb			ld de, store_page 
84d2				if DEBUG_STORESE 
84d2					DMARK "SCw" 
84d2 f5				push af  
84d3 3a e7 84			ld a, (.dmark)  
84d6 32 7a ee			ld (debug_mark),a  
84d9 3a e8 84			ld a, (.dmark+1)  
84dc 32 7b ee			ld (debug_mark+1),a  
84df 3a e9 84			ld a, (.dmark+2)  
84e2 32 7c ee			ld (debug_mark+2),a  
84e5 18 03			jr .pastdmark  
84e7 ..			.dmark: db "SCw"  
84ea f1			.pastdmark: pop af  
84eb			endm  
# End of macro DMARK
84eb					CALLMONITOR 
84eb cd 03 93			call break_point_state  
84ee				endm  
# End of macro CALLMONITOR
84ee				endif 
84ee cd 16 81			call storage_write_block	 ; save update 
84f1			 
84f1				if DEBUG_STORESE 
84f1 11 65 eb				ld de, store_page 
84f4					DMARK "SCC" 
84f4 f5				push af  
84f5 3a 09 85			ld a, (.dmark)  
84f8 32 7a ee			ld (debug_mark),a  
84fb 3a 0a 85			ld a, (.dmark+1)  
84fe 32 7b ee			ld (debug_mark+1),a  
8501 3a 0b 85			ld a, (.dmark+2)  
8504 32 7c ee			ld (debug_mark+2),a  
8507 18 03			jr .pastdmark  
8509 ..			.dmark: db "SCC"  
850c f1			.pastdmark: pop af  
850d			endm  
# End of macro DMARK
850d					CALLMONITOR 
850d cd 03 93			call break_point_state  
8510				endm  
# End of macro CALLMONITOR
8510				endif 
8510				;  
8510				 
8510 21 40 00			ld hl, STORE_BLOCK_PHY 
8513 11 00 00			ld de, 0 
8516 cd d2 83			call storage_findnextid 
8519			 
8519 22 4f eb			ld (store_tmppageid), hl    ; save page to use  
851c			 
851c				; TODO detect 0 = no spare blocks 
851c			 
851c				; hl now contains the free page to use for the file header page 
851c			 
851c				if DEBUG_STORESE 
851c				DMARK "SCF" 
851c f5				push af  
851d 3a 31 85			ld a, (.dmark)  
8520 32 7a ee			ld (debug_mark),a  
8523 3a 32 85			ld a, (.dmark+1)  
8526 32 7b ee			ld (debug_mark+1),a  
8529 3a 33 85			ld a, (.dmark+2)  
852c 32 7c ee			ld (debug_mark+2),a  
852f 18 03			jr .pastdmark  
8531 ..			.dmark: db "SCF"  
8534 f1			.pastdmark: pop af  
8535			endm  
# End of macro DMARK
8535					CALLMONITOR 
8535 cd 03 93			call break_point_state  
8538				endm  
# End of macro CALLMONITOR
8538				endif 
8538			 
8538 22 4f eb			ld (store_tmppageid), hl 
853b				 
853b 3a 5e eb			ld a,(store_tmpid)    ; get file id 
853e			;	ld a, (store_filecache)			; save to cache 
853e			 
853e 32 65 eb			ld (store_page),a    ; set page id 
8541 3e 00			ld a, 0			 ; extent 0 is file header 
8543 32 66 eb			ld (store_page+1), a   ; set file extent 
8546			 
8546 32 67 eb			ld (store_page+2), a   ; extent count for the file 
8549			 
8549			;	inc hl 		; init block 0 of file 
8549			;	inc hl   		; skip file and extent id 
8549			 ;       ld a, 0 
8549			;	ld (hl),a 
8549			;	ld a, (store_filecache+1)  	; save to cache 
8549			 
8549			;	inc hl    ; file name 
8549				 
8549				 
8549 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
854c				if DEBUG_STORESE 
854c					DMARK "SCc" 
854c f5				push af  
854d 3a 61 85			ld a, (.dmark)  
8550 32 7a ee			ld (debug_mark),a  
8553 3a 62 85			ld a, (.dmark+1)  
8556 32 7b ee			ld (debug_mark+1),a  
8559 3a 63 85			ld a, (.dmark+2)  
855c 32 7c ee			ld (debug_mark+2),a  
855f 18 03			jr .pastdmark  
8561 ..			.dmark: db "SCc"  
8564 f1			.pastdmark: pop af  
8565			endm  
# End of macro DMARK
8565					CALLMONITOR 
8565 cd 03 93			call break_point_state  
8568				endm  
# End of macro CALLMONITOR
8568				endif 
8568 e1				pop hl    ; get zero term string 
8569 e5				push hl 
856a 3e 00			ld a, 0 
856c cd 10 8f			call strlent 
856f 23				inc hl   ; cover zero term 
8570 06 00			ld b,0 
8572 4d				ld c,l 
8573 e1				pop hl 
8574				;ex de, hl 
8574				if DEBUG_STORESE 
8574					DMARK "SCa" 
8574 f5				push af  
8575 3a 89 85			ld a, (.dmark)  
8578 32 7a ee			ld (debug_mark),a  
857b 3a 8a 85			ld a, (.dmark+1)  
857e 32 7b ee			ld (debug_mark+1),a  
8581 3a 8b 85			ld a, (.dmark+2)  
8584 32 7c ee			ld (debug_mark+2),a  
8587 18 03			jr .pastdmark  
8589 ..			.dmark: db "SCa"  
858c f1			.pastdmark: pop af  
858d			endm  
# End of macro DMARK
858d					;push af 
858d					;ld a, 'a' 
858d					;ld (debug_mark),a 
858d					;pop af 
858d					CALLMONITOR 
858d cd 03 93			call break_point_state  
8590				endm  
# End of macro CALLMONITOR
8590				endif 
8590 ed b0			ldir    ; copy zero term string 
8592				if DEBUG_STORESE 
8592					DMARK "SCA" 
8592 f5				push af  
8593 3a a7 85			ld a, (.dmark)  
8596 32 7a ee			ld (debug_mark),a  
8599 3a a8 85			ld a, (.dmark+1)  
859c 32 7b ee			ld (debug_mark+1),a  
859f 3a a9 85			ld a, (.dmark+2)  
85a2 32 7c ee			ld (debug_mark+2),a  
85a5 18 03			jr .pastdmark  
85a7 ..			.dmark: db "SCA"  
85aa f1			.pastdmark: pop af  
85ab			endm  
# End of macro DMARK
85ab					CALLMONITOR 
85ab cd 03 93			call break_point_state  
85ae				endm  
# End of macro CALLMONITOR
85ae				endif 
85ae			 
85ae				; write file header page 
85ae			 
85ae 2a 4f eb			ld hl,(store_tmppageid) 
85b1 11 65 eb			ld de, store_page 
85b4				if DEBUG_STORESE 
85b4					DMARK "SCb" 
85b4 f5				push af  
85b5 3a c9 85			ld a, (.dmark)  
85b8 32 7a ee			ld (debug_mark),a  
85bb 3a ca 85			ld a, (.dmark+1)  
85be 32 7b ee			ld (debug_mark+1),a  
85c1 3a cb 85			ld a, (.dmark+2)  
85c4 32 7c ee			ld (debug_mark+2),a  
85c7 18 03			jr .pastdmark  
85c9 ..			.dmark: db "SCb"  
85cc f1			.pastdmark: pop af  
85cd			endm  
# End of macro DMARK
85cd					;push af 
85cd					;ld a, 'b' 
85cd					;ld (debug_mark),a 
85cd					;pop af 
85cd					CALLMONITOR 
85cd cd 03 93			call break_point_state  
85d0				endm  
# End of macro CALLMONITOR
85d0				endif 
85d0 cd 16 81			call storage_write_block 
85d3			 
85d3 3a 5e eb			ld a, (store_tmpid) 
85d6 6f				ld l, a 
85d7 26 00			ld h,0 
85d9				if DEBUG_STORESE 
85d9					DMARK "SCz" 
85d9 f5				push af  
85da 3a ee 85			ld a, (.dmark)  
85dd 32 7a ee			ld (debug_mark),a  
85e0 3a ef 85			ld a, (.dmark+1)  
85e3 32 7b ee			ld (debug_mark+1),a  
85e6 3a f0 85			ld a, (.dmark+2)  
85e9 32 7c ee			ld (debug_mark+2),a  
85ec 18 03			jr .pastdmark  
85ee ..			.dmark: db "SCz"  
85f1 f1			.pastdmark: pop af  
85f2			endm  
# End of macro DMARK
85f2					CALLMONITOR 
85f2 cd 03 93			call break_point_state  
85f5				endm  
# End of macro CALLMONITOR
85f5				endif 
85f5 c9				ret 
85f6				 
85f6			 
85f6			 
85f6			; 
85f6			; Read File 
85f6			; 
85f6			; h - file id to locate 
85f6			; l - extent to locate 
85f6			; de - pointer to string to read into 
85f6			; 
85f6			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
85f6			storage_read: 
85f6 d5				push de 
85f7			 
85f7			; TODO BUG the above push is it popped before the RET Z? 
85f7			 
85f7			; TODO how to handle multiple part blocks 
85f7			 
85f7				; locate file extent to read 
85f7			 
85f7 5c				ld e, h 
85f8 55				ld d, l 
85f9 21 40 00			ld hl, STORE_BLOCK_PHY 
85fc				if DEBUG_STORESE 
85fc					DMARK "SRE" 
85fc f5				push af  
85fd 3a 11 86			ld a, (.dmark)  
8600 32 7a ee			ld (debug_mark),a  
8603 3a 12 86			ld a, (.dmark+1)  
8606 32 7b ee			ld (debug_mark+1),a  
8609 3a 13 86			ld a, (.dmark+2)  
860c 32 7c ee			ld (debug_mark+2),a  
860f 18 03			jr .pastdmark  
8611 ..			.dmark: db "SRE"  
8614 f1			.pastdmark: pop af  
8615			endm  
# End of macro DMARK
8615					CALLMONITOR 
8615 cd 03 93			call break_point_state  
8618				endm  
# End of macro CALLMONITOR
8618				endif 
8618 cd d2 83			call storage_findnextid 
861b			 
861b				if DEBUG_STORESE 
861b					DMARK "SRf" 
861b f5				push af  
861c 3a 30 86			ld a, (.dmark)  
861f 32 7a ee			ld (debug_mark),a  
8622 3a 31 86			ld a, (.dmark+1)  
8625 32 7b ee			ld (debug_mark+1),a  
8628 3a 32 86			ld a, (.dmark+2)  
862b 32 7c ee			ld (debug_mark+2),a  
862e 18 03			jr .pastdmark  
8630 ..			.dmark: db "SRf"  
8633 f1			.pastdmark: pop af  
8634			endm  
# End of macro DMARK
8634					CALLMONITOR 
8634 cd 03 93			call break_point_state  
8637				endm  
# End of macro CALLMONITOR
8637				endif 
8637 cd d0 8a			call ishlzero 
863a			;	ld a, l 
863a			;	add h 
863a			;	cp 0 
863a c8				ret z			; block not found so EOF 
863b			 
863b				; hl contains page number to load 
863b d1				pop de   ; get storage 
863c d5				push de 
863d				if DEBUG_STORESE 
863d					DMARK "SRg" 
863d f5				push af  
863e 3a 52 86			ld a, (.dmark)  
8641 32 7a ee			ld (debug_mark),a  
8644 3a 53 86			ld a, (.dmark+1)  
8647 32 7b ee			ld (debug_mark+1),a  
864a 3a 54 86			ld a, (.dmark+2)  
864d 32 7c ee			ld (debug_mark+2),a  
8650 18 03			jr .pastdmark  
8652 ..			.dmark: db "SRg"  
8655 f1			.pastdmark: pop af  
8656			endm  
# End of macro DMARK
8656					CALLMONITOR 
8656 cd 03 93			call break_point_state  
8659				endm  
# End of macro CALLMONITOR
8659				endif 
8659 cd b1 80			call storage_read_block 
865c			 
865c			 
865c			; TODO if block has no zeros then need to read next block  
865c			 
865c			 
865c					 
865c e1				pop hl 		 ; return start of data to show as not EOF 
865d 23				inc hl   ; past file id 
865e 23				inc hl   ; past ext 
865f				if DEBUG_STORESE 
865f					DMARK "SRe" 
865f f5				push af  
8660 3a 74 86			ld a, (.dmark)  
8663 32 7a ee			ld (debug_mark),a  
8666 3a 75 86			ld a, (.dmark+1)  
8669 32 7b ee			ld (debug_mark+1),a  
866c 3a 76 86			ld a, (.dmark+2)  
866f 32 7c ee			ld (debug_mark+2),a  
8672 18 03			jr .pastdmark  
8674 ..			.dmark: db "SRe"  
8677 f1			.pastdmark: pop af  
8678			endm  
# End of macro DMARK
8678					CALLMONITOR 
8678 cd 03 93			call break_point_state  
867b				endm  
# End of macro CALLMONITOR
867b				endif 
867b c9					ret 
867c			 
867c			 
867c			 
867c			; 
867c			; Append File 
867c			; 
867c			; hl - file id to locate 
867c			; de - pointer to (multi block) string to write 
867c			 
867c			 
867c			storage_append: 
867c				; hl -  file id to append to 
867c				; de - string to append 
867c			 
867c d5				push de 
867d				 
867d				if DEBUG_STORESE 
867d					DMARK "AP1" 
867d f5				push af  
867e 3a 92 86			ld a, (.dmark)  
8681 32 7a ee			ld (debug_mark),a  
8684 3a 93 86			ld a, (.dmark+1)  
8687 32 7b ee			ld (debug_mark+1),a  
868a 3a 94 86			ld a, (.dmark+2)  
868d 32 7c ee			ld (debug_mark+2),a  
8690 18 03			jr .pastdmark  
8692 ..			.dmark: db "AP1"  
8695 f1			.pastdmark: pop af  
8696			endm  
# End of macro DMARK
8696					CALLMONITOR 
8696 cd 03 93			call break_point_state  
8699				endm  
# End of macro CALLMONITOR
8699				endif 
8699			 
8699 7d				ld a, l 
869a 32 5e eb			ld (store_tmpid), a 
869d			 
869d				; get file header  
869d			 
869d 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
869f 3a 5e eb			ld a, (store_tmpid) 
86a2 5f				ld e, a 
86a3			 
86a3 21 40 00				ld hl, STORE_BLOCK_PHY 
86a6 cd d2 83				call storage_findnextid 
86a9			 
86a9 22 4f eb			ld (store_tmppageid), hl 
86ac			 
86ac				; TODO handle file id not found 
86ac			 
86ac				if DEBUG_STORESE 
86ac					DMARK "AP2" 
86ac f5				push af  
86ad 3a c1 86			ld a, (.dmark)  
86b0 32 7a ee			ld (debug_mark),a  
86b3 3a c2 86			ld a, (.dmark+1)  
86b6 32 7b ee			ld (debug_mark+1),a  
86b9 3a c3 86			ld a, (.dmark+2)  
86bc 32 7c ee			ld (debug_mark+2),a  
86bf 18 03			jr .pastdmark  
86c1 ..			.dmark: db "AP2"  
86c4 f1			.pastdmark: pop af  
86c5			endm  
# End of macro DMARK
86c5					CALLMONITOR 
86c5 cd 03 93			call break_point_state  
86c8				endm  
# End of macro CALLMONITOR
86c8				endif 
86c8			 
86c8				; update file extent count 
86c8			 
86c8 11 65 eb			ld de, store_page 
86cb			 
86cb cd b1 80			call storage_read_block 
86ce			 
86ce				if DEBUG_STORESE 
86ce					DMARK "AP3" 
86ce f5				push af  
86cf 3a e3 86			ld a, (.dmark)  
86d2 32 7a ee			ld (debug_mark),a  
86d5 3a e4 86			ld a, (.dmark+1)  
86d8 32 7b ee			ld (debug_mark+1),a  
86db 3a e5 86			ld a, (.dmark+2)  
86de 32 7c ee			ld (debug_mark+2),a  
86e1 18 03			jr .pastdmark  
86e3 ..			.dmark: db "AP3"  
86e6 f1			.pastdmark: pop af  
86e7			endm  
# End of macro DMARK
86e7					CALLMONITOR 
86e7 cd 03 93			call break_point_state  
86ea				endm  
# End of macro CALLMONITOR
86ea				endif 
86ea			;	ld (store_tmppageid), hl 
86ea			 
86ea 3a 67 eb			ld a, (store_page+2) 
86ed 3c				inc a 
86ee 32 67 eb			ld (store_page+2), a 
86f1 32 5d eb			ld (store_tmpext), a 
86f4				 
86f4				if DEBUG_STORESE 
86f4					DMARK "AP3" 
86f4 f5				push af  
86f5 3a 09 87			ld a, (.dmark)  
86f8 32 7a ee			ld (debug_mark),a  
86fb 3a 0a 87			ld a, (.dmark+1)  
86fe 32 7b ee			ld (debug_mark+1),a  
8701 3a 0b 87			ld a, (.dmark+2)  
8704 32 7c ee			ld (debug_mark+2),a  
8707 18 03			jr .pastdmark  
8709 ..			.dmark: db "AP3"  
870c f1			.pastdmark: pop af  
870d			endm  
# End of macro DMARK
870d					CALLMONITOR 
870d cd 03 93			call break_point_state  
8710				endm  
# End of macro CALLMONITOR
8710				endif 
8710 2a 4f eb			ld hl, (store_tmppageid) 
8713 11 65 eb			ld de, store_page 
8716 cd 16 81			call storage_write_block 
8719			 
8719				; find free block 
8719			 
8719 11 00 00			ld de, 0			 ; file extent to locate 
871c			 
871c 21 40 00				ld hl, STORE_BLOCK_PHY 
871f cd d2 83				call storage_findnextid 
8722			 
8722					; TODO handle no space left 
8722					 
8722 22 4f eb				ld (store_tmppageid), hl 
8725			 
8725				if DEBUG_STORESE 
8725					DMARK "AP4" 
8725 f5				push af  
8726 3a 3a 87			ld a, (.dmark)  
8729 32 7a ee			ld (debug_mark),a  
872c 3a 3b 87			ld a, (.dmark+1)  
872f 32 7b ee			ld (debug_mark+1),a  
8732 3a 3c 87			ld a, (.dmark+2)  
8735 32 7c ee			ld (debug_mark+2),a  
8738 18 03			jr .pastdmark  
873a ..			.dmark: db "AP4"  
873d f1			.pastdmark: pop af  
873e			endm  
# End of macro DMARK
873e					CALLMONITOR 
873e cd 03 93			call break_point_state  
8741				endm  
# End of macro CALLMONITOR
8741				endif 
8741					; init the buffer with zeros so we can id if the buffer is full or not 
8741			 
8741 e5					push hl 
8742 c5					push bc 
8743			 
8743 21 65 eb				ld hl, store_page 
8746 06 40				ld b, STORE_BLOCK_PHY 
8748 3e 00				ld a, 0 
874a 77			.zeroblock:	ld (hl), a 
874b 23					inc hl 
874c 10 fc				djnz .zeroblock 
874e			 
874e c1					pop bc 
874f e1					pop hl 
8750			 
8750					; construct block 
8750			 
8750 3a 5e eb				ld a, (store_tmpid) 
8753 32 65 eb				ld (store_page), a   ; file id 
8756 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
8759 32 66 eb				ld (store_page+1), a 
875c			 
875c e1					pop hl    ; get string to write 
875d 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
875f 11 67 eb				ld de, store_page+2 
8762			 
8762				if DEBUG_STORESE 
8762					DMARK "AP5" 
8762 f5				push af  
8763 3a 77 87			ld a, (.dmark)  
8766 32 7a ee			ld (debug_mark),a  
8769 3a 78 87			ld a, (.dmark+1)  
876c 32 7b ee			ld (debug_mark+1),a  
876f 3a 79 87			ld a, (.dmark+2)  
8772 32 7c ee			ld (debug_mark+2),a  
8775 18 03			jr .pastdmark  
8777 ..			.dmark: db "AP5"  
877a f1			.pastdmark: pop af  
877b			endm  
# End of macro DMARK
877b					CALLMONITOR 
877b cd 03 93			call break_point_state  
877e				endm  
# End of macro CALLMONITOR
877e				endif 
877e			 
877e			 
877e			 
877e					; fill buffer with data until end of string or full block 
877e			 
877e 7e			.appd:		ld a, (hl) 
877f 12					ld (de), a 
8780 fe 00				cp 0 
8782 28 04				jr z, .appdone 
8784 23					inc hl 
8785 13					inc de 
8786 10 f6				djnz .appd 
8788			 
8788 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
8789 f5					push af   		; save last byte dumped 
878a			 
878a			 
878a 2a 4f eb			ld hl, (store_tmppageid) 
878d 11 65 eb			ld de, store_page 
8790				if DEBUG_STORESE 
8790					DMARK "AP6" 
8790 f5				push af  
8791 3a a5 87			ld a, (.dmark)  
8794 32 7a ee			ld (debug_mark),a  
8797 3a a6 87			ld a, (.dmark+1)  
879a 32 7b ee			ld (debug_mark+1),a  
879d 3a a7 87			ld a, (.dmark+2)  
87a0 32 7c ee			ld (debug_mark+2),a  
87a3 18 03			jr .pastdmark  
87a5 ..			.dmark: db "AP6"  
87a8 f1			.pastdmark: pop af  
87a9			endm  
# End of macro DMARK
87a9					CALLMONITOR 
87a9 cd 03 93			call break_point_state  
87ac				endm  
# End of macro CALLMONITOR
87ac				endif 
87ac cd 16 81				call storage_write_block 
87af			 
87af			 
87af				; was that a full block of data written? 
87af				; any more to write out? 
87af			 
87af				; if yes then set vars and jump to start of function again 
87af			 
87af f1					pop af 
87b0 d1					pop de 
87b1			 
87b1 fe 00				cp 0		 ; no, string was fully written 
87b3 c8					ret z 
87b4			 
87b4					; setup vars for next cycle 
87b4			 
87b4 3a 5e eb				ld a, (store_tmpid) 
87b7 6f					ld l, a 
87b8 26 00				ld h, 0 
87ba			 
87ba c3 7c 86			 	jp storage_append	 ; yes, need to write out some more 
87bd			 
87bd			 
87bd			 
87bd			 
87bd			 
87bd			 
87bd			 
87bd			if DEBUG_STORECF 
87bd			storageput:	 
87bd					ret 
87bd			storageread: 
87bd					ld hl, store_page 
87bd					ld b, 200 
87bd					ld a,0 
87bd			.src:		ld (hl),a 
87bd					inc hl 
87bd					djnz .src 
87bd					 
87bd			 
87bd					ld de, 0 
87bd					ld bc, 1 
87bd					ld hl, store_page 
87bd					call cfRead 
87bd			 
87bd				call cfGetError 
87bd				ld hl,scratch 
87bd				call hexout 
87bd				ld hl, scratch+2 
87bd				ld a, 0 
87bd				ld (hl),a 
87bd				ld de, scratch 
87bd				ld a,display_row_1 
87bd				call str_at_display 
87bd				call update_display 
87bd			 
87bd					ld hl, store_page 
87bd					ld (os_cur_ptr),hl 
87bd			 
87bd					ret 
87bd			endif 
87bd			 
87bd			 
87bd			; Clear out the main buffer store (used to remove junk before writing a new block) 
87bd			 
87bd			storage_clear_page: 
87bd e5				push hl 
87be d5				push de 
87bf c5				push bc 
87c0 21 65 eb			ld hl, store_page 
87c3 3e 00			ld a, 0 
87c5 77				ld (hl), a 
87c6			 
87c6 11 66 eb			ld de, store_page+1 
87c9 01 40 00			ld bc, STORE_BLOCK_PHY 
87cc			 
87cc ed b0			ldir 
87ce				 
87ce c1				pop bc 
87cf d1				pop de 
87d0 e1				pop hl 
87d1 c9				ret 
87d2			 
87d2			; eof 
# End of file firmware_storage.asm
87d2			  
87d2			; support routines for above hardware abstraction layer  
87d2			  
87d2			include "firmware_general.asm"        ; general support functions  
87d2			 
87d2			; word look up 
87d2			 
87d2			; in 
87d2			; a is the index 
87d2			; hl is pointer start of array 
87d2			; 
87d2			; returns 
87d2			; hl to the word 
87d2			; 
87d2			 
87d2			table_lookup:  
87d2 d5					push de 
87d3 eb					ex de, hl 
87d4			 
87d4 6f					ld l, a 
87d5 26 00				ld h, 0 
87d7 29					add hl, hl 
87d8 19					add hl, de 
87d9 7e					ld a, (hl) 
87da 23					inc hl 
87db 66					ld h,(hl) 
87dc 6f					ld l, a 
87dd			 
87dd d1					pop de 
87de c9					ret 
87df			 
87df			; Delay loops 
87df			 
87df			 
87df			 
87df			aDelayInMS: 
87df c5				push bc 
87e0 47				ld b,a 
87e1			msdelay: 
87e1 c5				push bc 
87e2				 
87e2			 
87e2 01 41 00			ld bc,041h 
87e5 cd fd 87			call delayloop 
87e8 c1				pop bc 
87e9 05				dec b 
87ea 20 f5			jr nz,msdelay 
87ec			 
87ec			;if CPU_CLOCK_8MHZ 
87ec			;msdelay8: 
87ec			;	push bc 
87ec			;	 
87ec			; 
87ec			;	ld bc,041h 
87ec			;	call delayloop 
87ec			;	pop bc 
87ec			;	dec b 
87ec			;	jr nz,msdelay8 
87ec			;endif 
87ec			 
87ec			 
87ec c1				pop bc 
87ed c9				ret 
87ee			 
87ee			 
87ee			delay250ms: 
87ee				;push de 
87ee 01 00 40			ld bc, 04000h 
87f1 c3 fd 87			jp delayloop 
87f4			delay500ms: 
87f4				;push de 
87f4 01 00 80			ld bc, 08000h 
87f7 c3 fd 87			jp delayloop 
87fa			delay1s: 
87fa				;push bc 
87fa			   ; Clobbers A, d and e 
87fa 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
87fd			delayloop: 
87fd c5			    push bc 
87fe			 
87fe			if BASE_CPM 
87fe				ld bc, CPM_DELAY_TUNE 
87fe			.cpmloop: 
87fe				push bc 
87fe			 
87fe			endif 
87fe			 
87fe			 
87fe			 
87fe			delayloopi: 
87fe			;	push bc 
87fe			;.dl: 
87fe cb 47		    bit     0,a    	; 8 
8800 cb 47		    bit     0,a    	; 8 
8802 cb 47		    bit     0,a    	; 8 
8804 e6 ff		    and     255  	; 7 
8806 0b			    dec     bc      	; 6 
8807 79			    ld      a,c     	; 4 
8808 b0			    or      b     	; 4 
8809 c2 fe 87		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
880c			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
880c				;pop de 
880c			;pop bc 
880c			 
880c			if BASE_CPM 
880c				pop bc 
880c				 
880c			    dec     bc      	; 6 
880c			    ld      a,c     	; 4 
880c			    or      b     	; 4 
880c			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
880c				 
880c			 
880c			endif 
880c			;if CPU_CLOCK_8MHZ 
880c			;    pop bc 
880c			;    push bc 
880c			;.dl8: 
880c			;    bit     0,a    	; 8 
880c			;    bit     0,a    	; 8 
880c			;    bit     0,a    	; 8 
880c			;    and     255  	; 7 
880c			;    dec     bc      	; 6 
880c			;    ld      a,c     	; 4 
880c			;    or      b     	; 4 
880c			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
880c			;endif 
880c			 
880c			;if CPU_CLOCK_10MHZ 
880c			;    pop bc 
880c			;    push bc 
880c			;.dl8: 
880c			;    bit     0,a    	; 8 
880c			;    bit     0,a    	; 8 
880c			;    bit     0,a    	; 8 
880c			;    and     255  	; 7 
880c			;    dec     bc      	; 6 
880c			;    ld      a,c     	; 4 
880c			;    or      b     	; 4 
880c			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
880c			;endif 
880c c1			    pop bc 
880d			 
880d c9				ret 
880e			 
880e			 
880e			 
880e			; eof 
# End of file firmware_general.asm
880e			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
880e			; display routines that use the physical hardware abstraction layer 
880e			 
880e			 
880e			; information window 
880e			 
880e			; pass hl with 1st string to display 
880e			; pass de with 2nd string to display 
880e			 
880e			info_panel: 
880e e5				push hl 
880f			 
880f 2a db eb			ld hl, (display_fb_active) 
8812 e5				push hl    ; future de destination 
8813 21 c0 ed				ld hl, display_fb0 
8816 22 db eb				ld (display_fb_active), hl 
8819			 
8819 cd 7a 88			call clear_display 
881c			 
881c			 
881c 3e 55			ld a, display_row_3 + 5 
881e cd 8d 88			call str_at_display 
8821			 
8821 e1				pop hl 
8822 d1				pop de 
8823			 
8823 e5				push hl 
8824			 
8824			 
8824 3e 2d			ld a, display_row_2 + 5 
8826 cd 8d 88			call str_at_display 
8829			 
8829			 
8829 cd 9d 88			call update_display 
882c cd 08 98			call next_page_prompt 
882f cd 7a 88			call clear_display 
8832			 
8832				 
8832 21 1f ed				ld hl, display_fb1 
8835 22 db eb				ld (display_fb_active), hl 
8838 cd 9d 88			call update_display 
883b			 
883b			 
883b c9				ret 
883c			 
883c			 
883c			 
883c			 
883c			; TODO windowing? 
883c			 
883c			; TODO scroll line up 
883c			 
883c			scroll_up: 
883c			 
883c e5				push hl 
883d d5				push de 
883e c5				push bc 
883f			 
883f				; get frame buffer  
883f			 
883f 2a db eb			ld hl, (display_fb_active) 
8842 e5				push hl    ; future de destination 
8843			 
8843 11 28 00			ld  de, display_cols 
8846 19				add hl, de 
8847			 
8847 d1				pop de 
8848			 
8848				;ex de, hl 
8848 01 9f 00			ld bc, display_fb_len -1  
884b			;if DEBUG_FORTH_WORDS 
884b			;	DMARK "SCL" 
884b			;	CALLMONITOR 
884b			;endif	 
884b ed b0			ldir 
884d			 
884d				; wipe bottom row 
884d			 
884d			 
884d 2a db eb			ld hl, (display_fb_active) 
8850 11 a0 00			ld de, display_cols*display_rows 
8853 19				add hl, de 
8854 06 28			ld b, display_cols 
8856 3e 20			ld a, ' ' 
8858			.scwipe: 
8858 77				ld (hl), a 
8859 2b				dec hl 
885a 10 fc			djnz .scwipe 
885c			 
885c				;pop hl 
885c			 
885c c1				pop bc 
885d d1				pop de 
885e e1				pop hl 
885f			 
885f c9				ret 
8860			 
8860			 
8860			;scroll_upo: 
8860			;	ld de, display_row_1 
8860			 ;	ld hl, display_row_2 
8860			;	ld bc, display_cols 
8860			;	ldir 
8860			;	ld de, display_row_2 
8860			 ;	ld hl, display_row_3 
8860			;	ld bc, display_cols 
8860			;	ldir 
8860			;	ld de, display_row_3 
8860			 ;	ld hl, display_row_4 
8860			;	ld bc, display_cols 
8860			;	ldir 
8860			 
8860			; TODO clear row 4 
8860			 
8860			;	ret 
8860			 
8860				 
8860			scroll_down: 
8860			 
8860 e5				push hl 
8861 d5				push de 
8862 c5				push bc 
8863			 
8863				; get frame buffer  
8863			 
8863 2a db eb			ld hl, (display_fb_active) 
8866			 
8866 11 9f 00			ld de, display_fb_len - 1 
8869 19				add hl, de 
886a			 
886a e5			push hl    ; future de destination 
886b			 
886b 11 28 00			ld  de, display_cols 
886e ed 52			sbc hl, de 
8870			 
8870			 
8870 d1				pop de 
8871			 
8871			;	ex de, hl 
8871 01 9f 00			ld bc, display_fb_len -1  
8874			 
8874			 
8874				 
8874			 
8874 ed b0			ldir 
8876			 
8876				; wipe bottom row 
8876			 
8876			 
8876			;	ld hl, (display_fb_active) 
8876			;;	ld de, display_cols*display_rows 
8876			;;	add hl, de 
8876			;	ld b, display_cols 
8876			;	ld a, ' ' 
8876			;.scwiped: 
8876			;	ld (hl), a 
8876			;	dec hl 
8876			;	djnz .scwiped 
8876			 
8876				;pop hl 
8876			 
8876 c1				pop bc 
8877 d1				pop de 
8878 e1				pop hl 
8879			 
8879 c9				ret 
887a			;scroll_down: 
887a			;	ld de, display_row_4 
887a			;	ld hl, display_row_3 
887a			;	ld bc, display_cols 
887a			;	ldir 
887a			;	ld de, display_row_3 
887a			; 	ld hl, display_row_2 
887a			;	ld bc, display_cols 
887a			;	ldir 
887a			;	ld de, display_row_2 
887a			;	ld hl, display_row_1 
887a			;	ld bc, display_cols 
887a			;	ldir 
887a			;;; TODO clear row 1 
887a			;	ret 
887a			 
887a			 
887a			 
887a			 
887a			 
887a			; clear active frame buffer 
887a			 
887a			clear_display: 
887a 3e 20			ld a, ' ' 
887c c3 7f 88			jp fill_display 
887f			 
887f			; fill active frame buffer with a char in A 
887f			 
887f			fill_display: 
887f 06 a0			ld b,display_fb_len 
8881 2a db eb			ld hl, (display_fb_active) 
8884 77			.fd1:	ld (hl),a 
8885 23				inc hl 
8886 10 fc			djnz .fd1 
8888 23				inc hl 
8889 3e 00			ld a,0 
888b 77				ld (hl),a 
888c			 
888c			 
888c c9				ret 
888d			; Write string (DE) at pos (A) to active frame buffer 
888d			 
888d 2a db eb		str_at_display:    ld hl,(display_fb_active) 
8890 06 00					ld b,0 
8892 4f					ld c,a 
8893 09					add hl,bc 
8894 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8895 b7			            OR   A              ;Null terminator? 
8896 c8			            RET  Z              ;Yes, so finished 
8897 77					ld (hl),a 
8898 23				inc hl 
8899 13			            INC  DE             ;Point to next character 
889a 18 f8		            JR   .sad1     ;Repeat 
889c c9					ret 
889d			 
889d			; using current frame buffer write to physical display 
889d			 
889d			update_display: 
889d e5				push hl 
889e 2a db eb			ld hl, (display_fb_active) 
88a1 cd e2 d7			call write_display 
88a4 e1				pop hl 
88a5 c9				ret 
88a6			 
88a6			; TODO scrolling 
88a6			 
88a6			 
88a6			; move cursor right one char 
88a6			cursor_right: 
88a6			 
88a6				; TODO shift right 
88a6				; TODO if beyond max col 
88a6				; TODO       cursor_next_line 
88a6			 
88a6 c9				ret 
88a7			 
88a7			 
88a7			cursor_next_line: 
88a7				; TODO first char 
88a7				; TODO line down 
88a7				; TODO if past last row 
88a7				; TODO    scroll up 
88a7			 
88a7 c9				ret 
88a8			 
88a8			cursor_left: 
88a8				; TODO shift left 
88a8				; TODO if beyond left  
88a8				; TODO     cursor prev line 
88a8				 
88a8 c9				ret 
88a9			 
88a9			cursor_prev_line: 
88a9				; TODO last char 
88a9				; TODO line up 
88a9				; TODO if past first row 
88a9				; TODO   scroll down 
88a9			 
88a9 c9				ret 
88aa			 
88aa			 
88aa			cout: 
88aa				; A - char 
88aa c9				ret 
88ab			 
88ab			 
88ab			; Display a menu and allow item selection (optional toggle items) 
88ab			; 
88ab			; format: 
88ab			; hl pointer to word array with zero term for items 
88ab			; e.g.    db item1 
88ab			;         db .... 
88ab			;         db 0 
88ab			; 
88ab			; a = starting menu item  
88ab			; 
88ab			; de = pointer item toggle array   (todo) 
88ab			; 
88ab			; returns item selected in a 1-... 
88ab			; returns 0 if back button pressed 
88ab			; 
88ab			; NOTE: Uses system frame buffer to display 
88ab			; 
88ab			; LEFT, Q = go back 
88ab			; RIGHT, SPACE, CR = select 
88ab			; UP, A - Up 
88ab			; DOWN, Z - Down 
88ab			 
88ab			 
88ab			 
88ab			 
88ab			 
88ab			menu: 
88ab			 
88ab					; keep array pointer 
88ab			 
88ab 22 63 eb				ld (store_tmp1), hl 
88ae 32 61 eb				ld (store_tmp2), a 
88b1			 
88b1					; check for key bounce 
88b1			 
88b1			if BASE_KEV 
88b1			 
88b1			.mbounce:	call cin 
88b1					cp 0 
88b1					jr nz, .mbounce 
88b1			endif 
88b1					; for ease use ex 
88b1			 
88b1					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
88b1 21 c0 ed				ld hl, display_fb0 
88b4 22 db eb				ld (display_fb_active), hl 
88b7			 
88b7 cd 7a 88		.mloop:		call clear_display 
88ba cd 9d 88				call update_display 
88bd			 
88bd					; draw selection id '>' at 1 
88bd			 
88bd					; init start of list display 
88bd			 
88bd 3e 05				ld a, 5 
88bf 32 5f eb				ld (store_tmp3), a   ; display row count 
88c2 3a 61 eb				ld a,( store_tmp2) 
88c5 32 62 eb				ld (store_tmp2+1), a   ; display item count 
88c8			 
88c8					 
88c8			.mitem:	 
88c8			 
88c8			 
88c8 3a 62 eb				ld a,(store_tmp2+1) 
88cb 6f					ld l, a 
88cc 26 00				ld h, 0 
88ce 29					add hl, hl 
88cf ed 5b 63 eb			ld de, (store_tmp1) 
88d3 19					add hl, de 
88d4 7e					ld a, (hl) 
88d5 23					inc hl 
88d6 66					ld h,(hl) 
88d7 6f					ld l, a 
88d8			 
88d8 cd d0 8a				call ishlzero 
88db 28 1a				jr z, .mdone 
88dd			 
88dd eb					ex de, hl 
88de 3a 5f eb				ld a, (store_tmp3) 
88e1 cd 8d 88				call str_at_display 
88e4					 
88e4			 
88e4					; next item 
88e4 3a 62 eb				ld a, (store_tmp2+1) 
88e7 3c					inc a 
88e8 32 62 eb				ld (store_tmp2+1), a   ; display item count 
88eb			 
88eb			 		; next row 
88eb			 
88eb 3a 5f eb				ld a, (store_tmp3) 
88ee c6 28				add display_cols 
88f0 32 5f eb				ld (store_tmp3), a 
88f3			 
88f3					; at end of screen? 
88f3			 
88f3 fe 10				cp display_rows*4 
88f5 20 d1				jr nz, .mitem 
88f7			 
88f7			 
88f7			.mdone: 
88f7 cd d0 8a				call ishlzero 
88fa 28 08				jr z, .nodn 
88fc			 
88fc 3e 78				ld a, display_row_4 
88fe 11 7d 89				ld de, .mdown 
8901 cd 8d 88				call str_at_display 
8904			 
8904					; draw options to fill the screens with active item on line 1 
8904					; if current option is 2 or more then display ^ in top 
8904			 
8904 3a 61 eb		.nodn:		ld a, (store_tmp2) 
8907 fe 00				cp 0 
8909 28 08				jr z, .noup 
890b			 
890b 3e 00				ld a, 0 
890d 11 7b 89				ld de, .mup 
8910 cd 8d 88				call str_at_display 
8913			 
8913 3e 02		.noup:		ld a, 2 
8915 11 79 89				ld de, .msel 
8918 cd 8d 88				call str_at_display 
891b			 
891b					; if current option + 1 is not null then display V in bottom 
891b					; get key 
891b cd 9d 88				call update_display 
891e			 
891e			 
891e					; handle key 
891e			 
891e cd 6e d8				call cin_wait 
8921			 
8921 fe 05				cp KEY_UP 
8923 28 2b				jr z, .mgoup 
8925 fe 61				cp 'a' 
8927 28 27				jr z, .mgoup 
8929 fe 0a				cp KEY_DOWN 
892b 28 32				jr z, .mgod 
892d fe 7a				cp 'z' 
892f 28 2e				jr z, .mgod 
8931 fe 20				cp ' ' 
8933 28 34				jr z, .goend 
8935 fe 0c				cp KEY_RIGHT 
8937 28 30				jr z, .goend 
8939 fe 0d				cp KEY_CR 
893b 28 2c				jr z, .goend 
893d fe 71				cp 'q' 
893f 28 0b				jr z, .goback 
8941			 
8941 fe 0b				cp KEY_LEFT 
8943 28 07				jr z, .goback 
8945 fe 08				cp KEY_BS 
8947 28 03				jr z, .goback 
8949 c3 b7 88				jp .mloop 
894c			 
894c			.goback: 
894c 3e 00			ld a, 0 
894e 18 1d			jr .goend2 
8950			 
8950				; move up one 
8950			.mgoup: 
8950 3a 61 eb				ld a, (store_tmp2) 
8953 fe 00				cp 0 
8955 ca b7 88				jp z, .mloop 
8958 3d					dec a 
8959 32 61 eb				ld (store_tmp2), a 
895c c3 b7 88				jp .mloop 
895f			 
895f				; move down one 
895f			.mgod: 
895f 3a 61 eb				ld a, (store_tmp2) 
8962 3c					inc a 
8963 32 61 eb				ld (store_tmp2), a 
8966 c3 b7 88				jp .mloop 
8969			 
8969			 
8969			.goend: 
8969					; get selected item number 
8969			 
8969 3a 61 eb				ld a, (store_tmp2) 
896c 3c					inc a 
896d			 
896d			.goend2: 
896d f5					push af 
896e			 
896e					; restore active fb 
896e					; TODO BUG assumes fb1 
896e			 
896e 21 1f ed				ld hl, display_fb1 
8971 22 db eb				ld (display_fb_active), hl 
8974			 
8974					; restore main regs 
8974			 
8974			 
8974 cd 9d 88				call update_display 
8977			 
8977 f1					pop af 
8978			 
8978 c9				ret 
8979			 
8979 .. 00		.msel:   db ">",0 
897b .. 00		.mup:   db "^",0 
897d .. 00		.mdown:   db "v",0 
897f			 
897f			 
897f			; eof 
897f			 
# End of file firmware_display.asm
897f			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
897f			; random number generators 
897f			 
897f			 
897f			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
897f			 
897f			 
897f			;-----> Generate a random number 
897f			; output a=answer 0<=a<=255 
897f			; all registers are preserved except: af 
897f			random: 
897f e5			        push    hl 
8980 d5			        push    de 
8981 2a bd eb		        ld      hl,(randData) 
8984 ed 5f		        ld      a,r 
8986 57			        ld      d,a 
8987 5e			        ld      e,(hl) 
8988 19			        add     hl,de 
8989 85			        add     a,l 
898a ac			        xor     h 
898b 22 bd eb		        ld      (randData),hl 
898e d1			        pop     de 
898f e1			        pop     hl 
8990 c9			        ret 
8991			 
8991			 
8991			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8991			 
8991			 
8991			 
8991			;------LFSR------ 
8991			;James Montelongo 
8991			;optimized by Spencer Putt 
8991			;out: 
8991			; a = 8 bit random number 
8991			RandLFSR: 
8991 21 c3 eb		        ld hl,LFSRSeed+4 
8994 5e			        ld e,(hl) 
8995 23			        inc hl 
8996 56			        ld d,(hl) 
8997 23			        inc hl 
8998 4e			        ld c,(hl) 
8999 23			        inc hl 
899a 7e			        ld a,(hl) 
899b 47			        ld b,a 
899c cb 13		        rl e  
899e cb 12			rl d 
89a0 cb 11		        rl c  
89a2 17				rla 
89a3 cb 13		        rl e  
89a5 cb 12			rl d 
89a7 cb 11		        rl c  
89a9 17				rla 
89aa cb 13		        rl e  
89ac cb 12			rl d 
89ae cb 11		        rl c  
89b0 17				rla 
89b1 67			        ld h,a 
89b2 cb 13		        rl e  
89b4 cb 12			rl d 
89b6 cb 11		        rl c  
89b8 17				rla 
89b9 a8			        xor b 
89ba cb 13		        rl e  
89bc cb 12			rl d 
89be ac			        xor h 
89bf a9			        xor c 
89c0 aa			        xor d 
89c1 21 c5 eb		        ld hl,LFSRSeed+6 
89c4 11 c6 eb		        ld de,LFSRSeed+7 
89c7 01 07 00		        ld bc,7 
89ca ed b8		        lddr 
89cc 12			        ld (de),a 
89cd c9			        ret 
89ce			 
89ce			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
89ce			 
89ce			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
89ce			 
89ce			 
89ce			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
89ce			 
89ce			prng16: 
89ce			;Inputs: 
89ce			;   (seed1) contains a 16-bit seed value 
89ce			;   (seed2) contains a NON-ZERO 16-bit seed value 
89ce			;Outputs: 
89ce			;   HL is the result 
89ce			;   BC is the result of the LCG, so not that great of quality 
89ce			;   DE is preserved 
89ce			;Destroys: 
89ce			;   AF 
89ce			;cycle: 4,294,901,760 (almost 4.3 billion) 
89ce			;160cc 
89ce			;26 bytes 
89ce 2a b7 eb		    ld hl,(seed1) 
89d1 44			    ld b,h 
89d2 4d			    ld c,l 
89d3 29			    add hl,hl 
89d4 29			    add hl,hl 
89d5 2c			    inc l 
89d6 09			    add hl,bc 
89d7 22 b7 eb		    ld (seed1),hl 
89da 2a b5 eb		    ld hl,(seed2) 
89dd 29			    add hl,hl 
89de 9f			    sbc a,a 
89df e6 2d		    and %00101101 
89e1 ad			    xor l 
89e2 6f			    ld l,a 
89e3 22 b5 eb		    ld (seed2),hl 
89e6 09			    add hl,bc 
89e7 c9			    ret 
89e8			 
89e8			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
89e8			 
89e8			rand32: 
89e8			;Inputs: 
89e8			;   (seed1_0) holds the lower 16 bits of the first seed 
89e8			;   (seed1_1) holds the upper 16 bits of the first seed 
89e8			;   (seed2_0) holds the lower 16 bits of the second seed 
89e8			;   (seed2_1) holds the upper 16 bits of the second seed 
89e8			;   **NOTE: seed2 must be non-zero 
89e8			;Outputs: 
89e8			;   HL is the result 
89e8			;   BC,DE can be used as lower quality values, but are not independent of HL. 
89e8			;Destroys: 
89e8			;   AF 
89e8			;Tested and passes all CAcert tests 
89e8			;Uses a very simple 32-bit LCG and 32-bit LFSR 
89e8			;it has a period of 18,446,744,069,414,584,320 
89e8			;roughly 18.4 quintillion. 
89e8			;LFSR taps: 0,2,6,7  = 11000101 
89e8			;291cc 
89e8			;seed1_0=$+1 
89e8			;    ld hl,12345 
89e8			;seed1_1=$+1 
89e8			;    ld de,6789 
89e8			;    ld b,h 
89e8			;    ld c,l 
89e8			;    add hl,hl \ rl e \ rl d 
89e8			;    add hl,hl \ rl e \ rl d 
89e8			;    inc l 
89e8			;    add hl,bc 
89e8			;    ld (seed1_0),hl 
89e8			;    ld hl,(seed1_1) 
89e8			;    adc hl,de 
89e8			;    ld (seed1_1),hl 
89e8			;    ex de,hl 
89e8			;seed2_0=$+1 
89e8			;    ld hl,9876 
89e8			;seed2_1=$+1 
89e8			;    ld bc,54321 
89e8			;    add hl,hl \ rl c \ rl b 
89e8			;    ld (seed2_1),bc 
89e8			;    sbc a,a 
89e8			;    and %11000101 
89e8			;    xor l 
89e8			;    ld l,a 
89e8			;    ld (seed2_0),hl 
89e8			;    ex de,hl 
89e8			;    add hl,bc 
89e8			;    ret 
89e8			; 
89e8			 
89e8			; 16-bit xorshift pseudorandom number generator by John Metcalf 
89e8			; 20 bytes, 86 cycles (excluding ret) 
89e8			 
89e8			; returns   hl = pseudorandom number 
89e8			; corrupts   a 
89e8			 
89e8			; generates 16-bit pseudorandom numbers with a period of 65535 
89e8			; using the xorshift method: 
89e8			 
89e8			; hl ^= hl << 7 
89e8			; hl ^= hl >> 9 
89e8			; hl ^= hl << 8 
89e8			 
89e8			; some alternative shift triplets which also perform well are: 
89e8			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
89e8			 
89e8			;  org 32768 
89e8			 
89e8			xrnd: 
89e8 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
89eb 3e 00		  ld a,0 
89ed bd			  cp l 
89ee 20 02		  jr nz, .xrnd1 
89f0 2e 01		  ld l, 1 
89f2			.xrnd1: 
89f2			 
89f2 7c			  ld a,h 
89f3 1f			  rra 
89f4 7d			  ld a,l 
89f5 1f			  rra 
89f6 ac			  xor h 
89f7 67			  ld h,a 
89f8 7d			  ld a,l 
89f9 1f			  rra 
89fa 7c			  ld a,h 
89fb 1f			  rra 
89fc ad			  xor l 
89fd 6f			  ld l,a 
89fe ac			  xor h 
89ff 67			  ld h,a 
8a00			 
8a00 22 bb eb		  ld (xrandc),hl 
8a03			 
8a03 c9			  ret 
8a04			;  
8a04			 
8a04			 
8a04			;;;; int maths 
8a04			 
8a04			; https://map.grauw.nl/articles/mult_div_shifts.php 
8a04			; Divide 16-bit values (with 16-bit result) 
8a04			; In: Divide BC by divider DE 
8a04			; Out: BC = result, HL = rest 
8a04			; 
8a04			Div16: 
8a04 21 00 00		    ld hl,0 
8a07 78			    ld a,b 
8a08 06 08		    ld b,8 
8a0a			Div16_Loop1: 
8a0a 17			    rla 
8a0b ed 6a		    adc hl,hl 
8a0d ed 52		    sbc hl,de 
8a0f 30 01		    jr nc,Div16_NoAdd1 
8a11 19			    add hl,de 
8a12			Div16_NoAdd1: 
8a12 10 f6		    djnz Div16_Loop1 
8a14 17			    rla 
8a15 2f			    cpl 
8a16 47			    ld b,a 
8a17 79			    ld a,c 
8a18 48			    ld c,b 
8a19 06 08		    ld b,8 
8a1b			Div16_Loop2: 
8a1b 17			    rla 
8a1c ed 6a		    adc hl,hl 
8a1e ed 52		    sbc hl,de 
8a20 30 01		    jr nc,Div16_NoAdd2 
8a22 19			    add hl,de 
8a23			Div16_NoAdd2: 
8a23 10 f6		    djnz Div16_Loop2 
8a25 17			    rla 
8a26 2f			    cpl 
8a27 41			    ld b,c 
8a28 4f			    ld c,a 
8a29 c9			ret 
8a2a			 
8a2a			 
8a2a			;http://z80-heaven.wikidot.com/math 
8a2a			; 
8a2a			;Inputs: 
8a2a			;     DE and A are factors 
8a2a			;Outputs: 
8a2a			;     A is not changed 
8a2a			;     B is 0 
8a2a			;     C is not changed 
8a2a			;     DE is not changed 
8a2a			;     HL is the product 
8a2a			;Time: 
8a2a			;     342+6x 
8a2a			; 
8a2a			Mult16: 
8a2a			 
8a2a 06 08		     ld b,8          ;7           7 
8a2c 21 00 00		     ld hl,0         ;10         10 
8a2f 29			       add hl,hl     ;11*8       88 
8a30 07			       rlca          ;4*8        32 
8a31 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8a33 19			         add hl,de   ;--         -- 
8a34 10 f9		       djnz $-5      ;13*7+8     99 
8a36 c9			ret 
8a37			 
8a37			; 
8a37			; Square root of 16-bit value 
8a37			; In:  HL = value 
8a37			; Out:  D = result (rounded down) 
8a37			; 
8a37			;Sqr16: 
8a37			;    ld de,#0040 
8a37			;    ld a,l 
8a37			;    ld l,h 
8a37			;    ld h,d 
8a37			;    or a 
8a37			;    ld b,8 
8a37			;Sqr16_Loop: 
8a37			;    sbc hl,de 
8a37			;    jr nc,Sqr16_Skip 
8a37			;    add hl,de 
8a37			;Sqr16_Skip: 
8a37			;    ccf 
8a37			;    rl d 
8a37			;    add a,a 
8a37			;    adc hl,hl 
8a37			;    add a,a 
8a37			;    adc hl,hl 
8a37			;    djnz Sqr16_Loop 
8a37			;    ret 
8a37			; 
8a37			; 
8a37			; Divide 8-bit values 
8a37			; In: Divide E by divider C 
8a37			; Out: A = result, B = rest 
8a37			; 
8a37			Div8: 
8a37 af			    xor a 
8a38 06 08		    ld b,8 
8a3a			Div8_Loop: 
8a3a cb 13		    rl e 
8a3c 17			    rla 
8a3d 91			    sub c 
8a3e 30 01		    jr nc,Div8_NoAdd 
8a40 81			    add a,c 
8a41			Div8_NoAdd: 
8a41 10 f7		    djnz Div8_Loop 
8a43 47			    ld b,a 
8a44 7b			    ld a,e 
8a45 17			    rla 
8a46 2f			    cpl 
8a47 c9			    ret 
8a48			 
8a48			; 
8a48			; Multiply 8-bit value with a 16-bit value (unrolled) 
8a48			; In: Multiply A with DE 
8a48			; Out: HL = result 
8a48			; 
8a48			Mult12U: 
8a48 2e 00		    ld l,0 
8a4a 87			    add a,a 
8a4b 30 01		    jr nc,Mult12U_NoAdd0 
8a4d 19			    add hl,de 
8a4e			Mult12U_NoAdd0: 
8a4e 29			    add hl,hl 
8a4f 87			    add a,a 
8a50 30 01		    jr nc,Mult12U_NoAdd1 
8a52 19			    add hl,de 
8a53			Mult12U_NoAdd1: 
8a53 29			    add hl,hl 
8a54 87			    add a,a 
8a55 30 01		    jr nc,Mult12U_NoAdd2 
8a57 19			    add hl,de 
8a58			Mult12U_NoAdd2: 
8a58 29			    add hl,hl 
8a59 87			    add a,a 
8a5a 30 01		    jr nc,Mult12U_NoAdd3 
8a5c 19			    add hl,de 
8a5d			Mult12U_NoAdd3: 
8a5d 29			    add hl,hl 
8a5e 87			    add a,a 
8a5f 30 01		    jr nc,Mult12U_NoAdd4 
8a61 19			    add hl,de 
8a62			Mult12U_NoAdd4: 
8a62 29			    add hl,hl 
8a63 87			    add a,a 
8a64 30 01		    jr nc,Mult12U_NoAdd5 
8a66 19			    add hl,de 
8a67			Mult12U_NoAdd5: 
8a67 29			    add hl,hl 
8a68 87			    add a,a 
8a69 30 01		    jr nc,Mult12U_NoAdd6 
8a6b 19			    add hl,de 
8a6c			Mult12U_NoAdd6: 
8a6c 29			    add hl,hl 
8a6d 87			    add a,a 
8a6e d0			    ret nc 
8a6f 19			    add hl,de 
8a70 c9			    ret 
8a71			 
8a71			; 
8a71			; Multiply 8-bit value with a 16-bit value (right rotating) 
8a71			; In: Multiply A with DE 
8a71			;      Put lowest value in A for most efficient calculation 
8a71			; Out: HL = result 
8a71			; 
8a71			Mult12R: 
8a71 21 00 00		    ld hl,0 
8a74			Mult12R_Loop: 
8a74 cb 3f		    srl a 
8a76 30 01		    jr nc,Mult12R_NoAdd 
8a78 19			    add hl,de 
8a79			Mult12R_NoAdd: 
8a79 cb 23		    sla e 
8a7b cb 12		    rl d 
8a7d b7			    or a 
8a7e c2 74 8a		    jp nz,Mult12R_Loop 
8a81 c9			    ret 
8a82			 
8a82			; 
8a82			; Multiply 16-bit values (with 32-bit result) 
8a82			; In: Multiply BC with DE 
8a82			; Out: BCHL = result 
8a82			; 
8a82			Mult32: 
8a82 79			    ld a,c 
8a83 48			    ld c,b 
8a84 21 00 00		    ld hl,0 
8a87 06 10		    ld b,16 
8a89			Mult32_Loop: 
8a89 29			    add hl,hl 
8a8a 17			    rla 
8a8b cb 11		    rl c 
8a8d 30 07		    jr nc,Mult32_NoAdd 
8a8f 19			    add hl,de 
8a90 ce 00		    adc a,0 
8a92 d2 96 8a		    jp nc,Mult32_NoAdd 
8a95 0c			    inc c 
8a96			Mult32_NoAdd: 
8a96 10 f1		    djnz Mult32_Loop 
8a98 41			    ld b,c 
8a99 4f			    ld c,a 
8a9a c9			    ret 
8a9b			 
8a9b			 
8a9b			 
8a9b			; 
8a9b			; Multiply 8-bit values 
8a9b			; In:  Multiply H with E 
8a9b			; Out: HL = result 
8a9b			; 
8a9b			Mult8: 
8a9b 16 00		    ld d,0 
8a9d 6a			    ld l,d 
8a9e 06 08		    ld b,8 
8aa0			Mult8_Loop: 
8aa0 29			    add hl,hl 
8aa1 30 01		    jr nc,Mult8_NoAdd 
8aa3 19			    add hl,de 
8aa4			Mult8_NoAdd: 
8aa4 10 fa		    djnz Mult8_Loop 
8aa6 c9			    ret 
8aa7			 
8aa7			 
8aa7			 
8aa7			 
8aa7			 
8aa7			 
8aa7			 
8aa7			 
8aa7			;;http://z80-heaven.wikidot.com/math 
8aa7			;;This divides DE by BC, storing the result in DE, remainder in HL 
8aa7			; 
8aa7			;DE_Div_BC:          ;1281-2x, x is at most 16 
8aa7			;     ld a,16        ;7 
8aa7			;     ld hl,0        ;10 
8aa7			;     jp $+5         ;10 
8aa7			;.DivLoop: 
8aa7			;       add hl,bc    ;-- 
8aa7			;       dec a        ;64 
8aa7			;       jr z,.DivLoopEnd        ;86 
8aa7			; 
8aa7			;       sla e        ;128 
8aa7			;       rl d         ;128 
8aa7			;       adc hl,hl    ;240 
8aa7			;       sbc hl,bc    ;240 
8aa7			;       jr nc,.DivLoop ;23|21 
8aa7			;       inc e        ;-- 
8aa7			;       jp .DivLoop+1 
8aa7			; 
8aa7			;.DivLoopEnd: 
8aa7			 
8aa7			;HL_Div_C: 
8aa7			;Inputs: 
8aa7			;     HL is the numerator 
8aa7			;     C is the denominator 
8aa7			;Outputs: 
8aa7			;     A is the remainder 
8aa7			;     B is 0 
8aa7			;     C is not changed 
8aa7			;     DE is not changed 
8aa7			;     HL is the quotient 
8aa7			; 
8aa7			;       ld b,16 
8aa7			;       xor a 
8aa7			;         add hl,hl 
8aa7			;         rla 
8aa7			;         cp c 
8aa7			;         jr c,$+4 
8aa7			;           inc l 
8aa7			;           sub c 
8aa7			;         djnz $-7 
8aa7			 
8aa7			; https://plutiedev.com/z80-add-8bit-to-16bit 
8aa7			 
8aa7			addatohl: 
8aa7 85			    add   a, l    ; A = A+L 
8aa8 6f			    ld    l, a    ; L = A+L 
8aa9 8c			    adc   a, h    ; A = A+L+H+carry 
8aaa 95			    sub   l       ; A = H+carry 
8aab 67			    ld    h, a    ; H = H+carry 
8aac c9			ret 
8aad			 
8aad			addatode: 
8aad 83			    add   a, e    ; A = A+L 
8aae 5f			    ld    e, a    ; L = A+L 
8aaf 8a			    adc   a, d    ; A = A+L+H+carry 
8ab0 93			    sub   e       ; A = H+carry 
8ab1 57			    ld    d, a    ; H = H+carry 
8ab2 c9			ret 
8ab3			 
8ab3			 
8ab3			addatobc: 
8ab3 81			    add   a, c    ; A = A+L 
8ab4 4f			    ld    c, a    ; L = A+L 
8ab5 88			    adc   a, b    ; A = A+L+H+carry 
8ab6 91			    sub   c       ; A = H+carry 
8ab7 47			    ld    b, a    ; H = H+carry 
8ab8 c9			ret 
8ab9			 
8ab9			subafromhl: 
8ab9			   ; If A=0 do nothing 
8ab9			    ; Otherwise flip A's sign. Since 
8ab9			    ; the upper byte becomes -1, also 
8ab9			    ; substract 1 from H. 
8ab9 ed 44		    neg 
8abb ca c4 8a		    jp    z, Skip 
8abe 25			    dec   h 
8abf			     
8abf			    ; Now add the low byte as usual 
8abf			    ; Two's complement takes care of 
8abf			    ; ensuring the result is correct 
8abf 85			    add   a, l 
8ac0 6f			    ld    l, a 
8ac1 8c			    adc   a, h 
8ac2 95			    sub   l 
8ac3 67			    ld    h, a 
8ac4			Skip: 
8ac4 c9				ret 
8ac5			 
8ac5			 
8ac5			; compare hl and de 
8ac5			; returns:  
8ac5			; if hl = de, z=1, s=0, c0=0 
8ac5			; if hl > de, z=0, s=0, c=0 
8ac5			; if hl < de, z=0, s=1, c=1 
8ac5			cmp16:	 
8ac5 b7				or a 
8ac6 ed 52			sbc hl,de 
8ac8 e0				ret po 
8ac9 7c				ld a,h 
8aca 1f				rra 
8acb ee 40			xor 01000000B 
8acd 37				scf 
8ace 8f				adc a,a 
8acf c9				ret 
8ad0			 
8ad0			 
8ad0			; test if hl contains zero   - A is destroyed 
8ad0			 
8ad0			ishlzero:    
8ad0 b7				or a     ; reset flags 
8ad1 7c				ld a, h 
8ad2 b5				or l        	 
8ad3			 
8ad3 c9				ret 
8ad4			 
8ad4			 
8ad4			 
8ad4			 
8ad4			if FORTH_ENABLE_FLOATMATH 
8ad4			;include "float/bbcmath.z80" 
8ad4			include "float/lpfpcalc.asm" 
8ad4			endif 
8ad4			 
8ad4			 
8ad4			; eof 
8ad4			 
# End of file firmware_maths.asm
8ad4			include "firmware_strings.asm"   ; string handling  
8ad4			 
8ad4			 
8ad4			; TODO string len 
8ad4			; input text string, end on cr with zero term 
8ad4			; a offset into frame buffer to start prompt 
8ad4			; d is max length 
8ad4			; e is display size TODO 
8ad4			; c is current cursor position 
8ad4			; hl is ptr to where string will be stored 
8ad4			 
8ad4			 
8ad4			; TODO check limit of buffer for new inserts 
8ad4			; TODO check insert does not push beyond buffer 
8ad4			; TODO scroll in a limited display area 
8ad4			; TODO scroll whole screen on page wrap 
8ad4			 
8ad4			 
8ad4			; TODO handle KEY_PREVWORD 
8ad4			; TODO handle KEY_NEXTWORD 
8ad4			; TODO handle KEY_HOME 
8ad4			; TODO handle KEY_END 
8ad4			; TODO use LCD cursor? 
8ad4			 
8ad4 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8ad7 81					add c 
8ad8 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8adb 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
8ade 79					ld a, c 
8adf cd a7 8a				call addatohl 
8ae2 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8ae5 7a					ld a,d 
8ae6 32 75 ee			        ld (input_size), a       ; save length of input area 
8ae9 79					ld a, c 
8aea 32 64 ee				ld (input_cursor),a      ; init cursor start position  
8aed 7b					ld a,e 
8aee 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8af1					 
8af1					 
8af1			 
8af1			;		ld a,(input_ptr) 
8af1			;		ld (input_under_cursor),a 	; save what is under the cursor 
8af1			 
8af1			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8af1					; init cursor shape if not set by the cin routines 
8af1 21 d3 eb				ld hl, cursor_shape 
8af4 3e ff				ld a, 255 
8af6 77					ld (hl), a 
8af7 23					inc hl 
8af8 3e 00				ld a, 0 
8afa 77					ld (hl), a 
8afb			 
8afb 3e 0f				ld a, CUR_BLINK_RATE 
8afd 32 6f ee				ld (input_cur_flash), a 
8b00 3e 01				ld a, 1 
8b02 32 6e ee				ld (input_cur_onoff),a 
8b05			 
8b05			;	if DEBUG_INPUT 
8b05			;		push af 
8b05			;		ld a, 'I' 
8b05			;		ld (debug_mark),a 
8b05			;		pop af 
8b05			;		CALLMONITOR 
8b05			;	endif 
8b05			.is1:		; main entry loop 
8b05			 
8b05			 
8b05			 
8b05					; pause 1ms 
8b05			 
8b05 3e 01				ld a, 1 
8b07 cd df 87				call aDelayInMS 
8b0a			 
8b0a					; dec flash counter 
8b0a 3a 6f ee				ld a, (input_cur_flash) 
8b0d 3d					dec a 
8b0e 32 6f ee				ld (input_cur_flash), a 
8b11 fe 00				cp 0 
8b13 20 0d				jr nz, .nochgstate 
8b15			 
8b15			 
8b15					; change state 
8b15 3a 6e ee				ld a,(input_cur_onoff) 
8b18 ed 44				neg 
8b1a 32 6e ee				ld (input_cur_onoff),a 
8b1d			 
8b1d			 
8b1d					; reset on change of state 
8b1d 3e 0f				ld a, CUR_BLINK_RATE 
8b1f 32 6f ee				ld (input_cur_flash), a 
8b22			 
8b22			.nochgstate: 
8b22					 
8b22					 
8b22			 
8b22					; display cursor  
8b22			 
8b22			;		ld hl, (input_start) 
8b22			;		ld a, (input_cursor) 
8b22			;		call addatohl 
8b22			 
8b22					; get char under cursor and replace with cursor 
8b22 2a 78 ee		ld hl, (input_ptr) 
8b25			;		ld a, (hl) 
8b25			;		ld (input_under_cursor),a 
8b25			;		ld a, '_' 
8b25			;		ld (hl), a 
8b25			 
8b25					; display string 
8b25			 
8b25 ed 5b 76 ee			ld de, (input_start) 
8b29 3a 73 ee				ld a, (input_at_pos) 
8b2c cd 8d 88				call str_at_display 
8b2f			;	        call update_display 
8b2f			 
8b2f					; find place to put the cursor 
8b2f			;		add h 
8b2f			;		ld l, display_row_1 
8b2f			;		sub l 
8b2f			; (input_at_pos) 
8b2f					;ld c, a 
8b2f			;		ld a, (input_cursor) 
8b2f			;		ld l, (input_at_pos) 
8b2f			;		;ld b, h 
8b2f			;		add l 
8b2f			;		ld (input_at_cursor),a 
8b2f					;ld l,h 
8b2f			 
8b2f			;		ld h, 0 
8b2f			;		ld l,(input_at_pos) 
8b2f			;		ld a, (input_cursor) 
8b2f			;		call addatohl 
8b2f			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8b2f			;		call subafromhl 
8b2f			;		ld a,l 
8b2f			;		ld (input_at_cursor), a 
8b2f			 
8b2f				if DEBUG_INPUT 
8b2f					ld a, (hardware_diag) 
8b2f					cp 0 
8b2f					jr z, .skip_input_diag 
8b2f			 
8b2f					ld a,(input_at_pos) 
8b2f					ld hl, LFSRSeed 
8b2f					call hexout 
8b2f					ld a, (input_cursor) 
8b2f					ld hl, LFSRSeed+2 
8b2f					call hexout 
8b2f					ld a,(input_at_cursor) 
8b2f					ld hl, LFSRSeed+4 
8b2f					call hexout 
8b2f			 
8b2f					ld a,(input_cur_onoff) 
8b2f					ld hl, LFSRSeed+6 
8b2f					call hexout 
8b2f			 
8b2f					ld a,(input_cur_flash) 
8b2f					ld hl, LFSRSeed+8 
8b2f					call hexout 
8b2f			 
8b2f					ld a,(input_len) 
8b2f					ld hl, LFSRSeed+10 
8b2f					call hexout 
8b2f					ld hl, LFSRSeed+12 
8b2f					ld a, 0 
8b2f					ld (hl),a 
8b2f					ld a, display_row_4 
8b2f					ld de, LFSRSeed 
8b2f					call str_at_display 
8b2f					.skip_input_diag: 
8b2f				endif 
8b2f			 
8b2f					; decide on if we are showing the cursor this time round 
8b2f			 
8b2f 3a 6e ee				ld a, (input_cur_onoff) 
8b32 fe ff				cp 255 
8b34 28 13				jr z, .skipcur 
8b36			 
8b36			 
8b36 3a 71 ee				ld a,(input_at_cursor) 
8b39 11 d3 eb				ld de, cursor_shape 
8b3c cd 8d 88				call str_at_display 
8b3f			 
8b3f					; save length of current input string 
8b3f 2a 76 ee				ld hl, (input_start) 
8b42 cd 05 8f				call strlenz 
8b45 7d					ld a,l 
8b46 32 69 ee				ld (input_len),a 
8b49			 
8b49			.skipcur: 
8b49			 
8b49 cd 9d 88			        call update_display 
8b4c					 
8b4c			 
8b4c			 
8b4c					; wait 
8b4c				 
8b4c					; TODO loop without wait to flash the cursor and char under cursor	 
8b4c cd 74 d8				call cin    ; _wait 
8b4f			 
8b4f fe 00				cp 0 
8b51 ca 05 8b				jp z, .is1 
8b54			 
8b54					; get ptr to char to input into 
8b54			 
8b54 4f					ld c,a 
8b55 2a 76 ee				ld hl, (input_start) 
8b58 3a 64 ee				ld a, (input_cursor) 
8b5b cd a7 8a				call addatohl 
8b5e 22 78 ee				ld (input_ptr), hl 
8b61 79					ld a,c 
8b62			 
8b62					; replace char under cursor 
8b62			 
8b62			;		ld hl, (input_ptr) 
8b62			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8b62			;		ld (hl), a 
8b62			 
8b62			;	if DEBUG_INPUT 
8b62			;		push af 
8b62			;		ld a, 'i' 
8b62			;		ld (debug_mark),a 
8b62			;		pop af 
8b62			;		CALLMONITOR 
8b62			;	endif 
8b62 fe 0e				cp KEY_HOME 
8b64 20 0e				jr nz, .iske 
8b66			 
8b66 3a 73 ee				ld a, (input_at_pos) 
8b69 32 71 ee				ld (input_at_cursor),a 
8b6c 3e 00				ld a, 0 
8b6e 32 64 ee				ld (input_cursor), a 
8b71 c3 05 8b				jp .is1 
8b74					 
8b74 fe 0f		.iske:		cp KEY_END 
8b76 20 03				jr nz, .isknw 
8b78 c3 05 8b				jp .is1 
8b7b			 
8b7b fe 06		.isknw:		cp KEY_NEXTWORD 
8b7d 20 1b				jr nz, .iskpw 
8b7f			 
8b7f 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
8b82 7e					ld a,(hl)	 
8b83 fe 00				cp 0 
8b85 ca 05 8b				jp z, .is1    ; end of string 
8b88 fe 20				cp ' ' 
8b8a ca 05 8b				jp z, .is1    ; end of word 
8b8d 23					inc hl 
8b8e 22 78 ee				ld (input_ptr), hl 
8b91 3a 71 ee				ld a, (input_at_cursor) 
8b94 3c					inc a 
8b95 32 71 ee				ld (input_at_cursor), a 
8b98 18 e5				jr .isknwm 
8b9a			 
8b9a fe 07		.iskpw:		cp KEY_PREVWORD 
8b9c 20 1b				jr nz, .iskl 
8b9e			.iskpwm:	 
8b9e 2a 78 ee				ld hl, (input_ptr) 
8ba1 7e					ld a,(hl)	 
8ba2 fe 00				cp 0  
8ba4 ca 05 8b				jp z, .is1    ; end of string 
8ba7 fe 20				cp ' ' 
8ba9 ca 05 8b				jp z, .is1    ; end of word 
8bac 2b					dec hl 
8bad 22 78 ee				ld (input_ptr), hl 
8bb0 3a 71 ee				ld a, (input_at_cursor) 
8bb3 3d					dec a 
8bb4 32 71 ee				ld (input_at_cursor), a 
8bb7 18 e5				jr .iskpwm 
8bb9			 
8bb9			 
8bb9 fe 0b		.iskl:		cp KEY_LEFT 
8bbb 20 27				jr nz, .isk1 
8bbd			 
8bbd 3a 64 ee				ld a, (input_cursor) 
8bc0			 
8bc0 fe 00				cp 0 
8bc2 ca 05 8b				jp z, .is1 		; at start of line to ignore  
8bc5			 
8bc5 3d					dec  a 		; TODO check underflow 
8bc6 32 64 ee				ld (input_cursor), a 
8bc9			 
8bc9 2a 78 ee				ld hl, (input_ptr) 
8bcc 2b					dec hl 
8bcd 22 78 ee				ld (input_ptr), hl 
8bd0					 
8bd0 3a 71 ee				ld a, (input_at_cursor) 
8bd3 3d					dec a 
8bd4 32 71 ee				ld (input_at_cursor), a 
8bd7			 
8bd7 3e 01				ld a, 1		; show cursor moving 
8bd9 32 6e ee				ld (input_cur_onoff),a 
8bdc 3e 0f				ld a, CUR_BLINK_RATE 
8bde 32 6f ee				ld (input_cur_flash), a 
8be1			 
8be1 c3 05 8b				jp .is1 
8be4			 
8be4 fe 0c		.isk1:		cp KEY_RIGHT 
8be6 20 2a				jr nz, .isk2 
8be8			 
8be8 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8beb 5f					ld e,a 
8bec 3a 64 ee				ld a, (input_cursor) 
8bef bb					cp e 
8bf0 ca 05 8b				jp z, .is1		; at the end of string so dont go right 
8bf3			 
8bf3 3c					inc  a 		; TODO check overflow 
8bf4 32 64 ee				ld (input_cursor), a 
8bf7			 
8bf7 3a 71 ee				ld a, (input_at_cursor) 
8bfa 3c					inc a 
8bfb 32 71 ee				ld (input_at_cursor), a 
8bfe			 
8bfe 2a 78 ee				ld hl, (input_ptr) 
8c01 23					inc hl 
8c02 22 78 ee				ld (input_ptr), hl 
8c05			 
8c05 3e 01				ld a, 1		; show cursor moving 
8c07 32 6e ee				ld (input_cur_onoff),a 
8c0a 3e 0f				ld a, CUR_BLINK_RATE 
8c0c 32 6f ee				ld (input_cur_flash), a 
8c0f			 
8c0f c3 05 8b				jp .is1 
8c12			 
8c12 fe 05		.isk2:		cp KEY_UP 
8c14			 
8c14 20 26				jr nz, .isk3 
8c16			 
8c16					; swap last command with the current on 
8c16			 
8c16					; move cursor to start of string 
8c16 2a 76 ee				ld hl, (input_start) 
8c19 22 78 ee				ld (input_ptr), hl 
8c1c			 
8c1c 3a 73 ee				ld a, (input_at_pos) 
8c1f 32 71 ee				ld (input_at_cursor), a 
8c22			 
8c22 3e 00				ld a, 0 
8c24 32 64 ee				ld (input_cursor), a 
8c27					 
8c27					; swap input and last command buffers 
8c27			 
8c27 21 87 e6				ld hl, os_cli_cmd 
8c2a 11 86 e7				ld de, os_last_cmd 
8c2d 06 ff				ld b, 255 
8c2f 7e			.swap1:		ld a, (hl) 
8c30 4f					ld c,a 
8c31 1a					ld a, (de) 
8c32 77					ld (hl), a 
8c33 79					ld a,c 
8c34 12					ld (de),a 
8c35 23					inc hl 
8c36 13					inc de 
8c37 10 f6				djnz .swap1 
8c39			 
8c39			 
8c39			 
8c39			 
8c39			 
8c39 c3 05 8b				jp .is1 
8c3c			 
8c3c fe 08		.isk3:		cp KEY_BS 
8c3e 20 3c				jr nz, .isk4 
8c40			 
8c40 3a 64 ee				ld a, (input_cursor) 
8c43			 
8c43 fe 00				cp 0 
8c45 ca 05 8b				jp z, .is1 		; at start of line to ignore  
8c48			 
8c48 3d					dec  a 		; TODO check underflow 
8c49 32 64 ee				ld (input_cursor), a 
8c4c			 
8c4c					; hl is source 
8c4c					; de needs to be source - 1 
8c4c			 
8c4c			;		ld a, 0 
8c4c			;		dec hl 
8c4c			;		ld (hl), a 
8c4c			 
8c4c 2a 78 ee				ld hl, (input_ptr) 
8c4f 2b					dec hl 
8c50 22 78 ee				ld (input_ptr), hl 
8c53			 
8c53					; shift all data 
8c53			 
8c53 e5					push hl 
8c54 23					inc hl 
8c55 d1					pop de 
8c56 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8c59 4f					ld c,a 
8c5a 06 00				ld b,0 
8c5c ed b0				ldir  
8c5e			 
8c5e			 
8c5e			 
8c5e			 
8c5e 3a 71 ee				ld a, (input_at_cursor) 
8c61 3d					dec a 
8c62 32 71 ee				ld (input_at_cursor), a 
8c65			 
8c65			 
8c65 3e 01				ld a, 1		; show cursor moving 
8c67 32 6e ee				ld (input_cur_onoff),a 
8c6a 3e 0f				ld a, CUR_BLINK_RATE 
8c6c 32 6f ee				ld (input_cur_flash), a 
8c6f			 
8c6f					; remove char 
8c6f 3a 71 ee				ld a, (input_at_cursor) 
8c72 3c					inc a 
8c73 11 fd 8c				ld de,.iblank 
8c76 cd 8d 88				call str_at_display 
8c79			 
8c79 c3 05 8b				jp .is1 
8c7c			 
8c7c fe 0d		.isk4:		cp KEY_CR 
8c7e 28 6c				jr z, .endinput 
8c80			 
8c80					; else add the key press to the end 
8c80			 
8c80 4f					ld c, a			; save key pressed 
8c81			 
8c81 7e					ld a,(hl)		; get what is currently under char 
8c82			 
8c82 fe 00				cp 0			; we are at the end of the string 
8c84 20 2f				jr nz, .onchar 
8c86					 
8c86					; add a char to the end of the string 
8c86				 
8c86 71					ld (hl),c 
8c87 23					inc hl 
8c88			;		ld a,' ' 
8c88			;		ld (hl),a 
8c88			;		inc hl 
8c88 3e 00				ld a,0 
8c8a 77					ld (hl),a 
8c8b 2b					dec hl 
8c8c			 
8c8c 3a 64 ee				ld a, (input_cursor) 
8c8f 3c					inc a				; TODO check max string length and scroll  
8c90 32 64 ee				ld (input_cursor), a		; inc cursor pos 
8c93							 
8c93 3a 71 ee				ld a, (input_at_cursor) 
8c96 3c					inc a 
8c97 32 71 ee				ld (input_at_cursor), a 
8c9a			 
8c9a 2a 78 ee				ld hl, (input_ptr) 
8c9d 23					inc hl 
8c9e 22 78 ee				ld (input_ptr), hl 
8ca1			 
8ca1 2a 78 ee				ld hl, (input_ptr) 
8ca4 23					inc hl 
8ca5 22 78 ee				ld (input_ptr), hl 
8ca8			;	if DEBUG_INPUT 
8ca8			;		push af 
8ca8			;		ld a, '+' 
8ca8			;		ld (debug_mark),a 
8ca8			;		pop af 
8ca8			;		CALLMONITOR 
8ca8			;	endif 
8ca8 3e 01				ld a, 1		; show cursor moving 
8caa 32 6e ee				ld (input_cur_onoff),a 
8cad 3e 0f				ld a, CUR_BLINK_RATE 
8caf 32 6f ee				ld (input_cur_flash), a 
8cb2 c3 05 8b				jp .is1 
8cb5					 
8cb5			 
8cb5			 
8cb5					; if on a char then insert 
8cb5			.onchar: 
8cb5			 
8cb5					; TODO over flow check: make sure insert does not blow out buffer 
8cb5			 
8cb5					; need to do some maths to use lddr 
8cb5			 
8cb5 e5					push hl   ; save char pos 
8cb6 c5					push bc 
8cb7			 
8cb7 2a 76 ee				ld hl, (input_start) 
8cba 3a 69 ee				ld a, (input_len) 
8cbd cd a7 8a				call addatohl  		; end of string 
8cc0 23					inc hl 
8cc1 23					inc hl		; past zero term 
8cc2 e5					push hl 
8cc3 23					inc hl 
8cc4 e5					push hl  
8cc5			 
8cc5								; start and end of lddr set, now how much to move? 
8cc5			 
8cc5							 
8cc5 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8cc8 47					ld b,a 
8cc9 3a 69 ee				ld a,(input_len) 
8ccc 5f					ld e,a 
8ccd 90					sub b 
8cce 3c					inc a		;?? 
8ccf 3c					inc a		;?? 
8cd0 3c					inc a		;?? 
8cd1			 
8cd1 06 00				ld b,0 
8cd3 4f					ld c,a 
8cd4			 
8cd4				if DEBUG_INPUT 
8cd4					push af 
8cd4					ld a, 'i' 
8cd4					ld (debug_mark),a 
8cd4					pop af 
8cd4			;		CALLMONITOR 
8cd4				endif 
8cd4 d1					pop de 
8cd5 e1					pop hl 
8cd6				if DEBUG_INPUT 
8cd6					push af 
8cd6					ld a, 'I' 
8cd6					ld (debug_mark),a 
8cd6					pop af 
8cd6			;		CALLMONITOR 
8cd6				endif 
8cd6 ed b8				lddr 
8cd8				 
8cd8			 
8cd8			 
8cd8					; TODO have a key for insert/overwrite mode???? 
8cd8 c1					pop bc 
8cd9 e1					pop hl 
8cda 71					ld (hl), c		; otherwise overwrite current char 
8cdb					 
8cdb			 
8cdb			 
8cdb			 
8cdb 3a 64 ee				ld a, (input_cursor) 
8cde 3c					inc  a 		; TODO check overflow 
8cdf 32 64 ee				ld (input_cursor), a 
8ce2			 
8ce2 3a 71 ee				ld a, (input_at_cursor) 
8ce5 3c					inc a 
8ce6 32 71 ee				ld (input_at_cursor), a 
8ce9			 
8ce9 c3 05 8b				jp .is1 
8cec			 
8cec			.endinput:	; TODO look for end of string 
8cec			 
8cec					; add trailing space for end of token 
8cec			 
8cec 2a 76 ee				ld hl, (input_start) 
8cef 3a 69 ee				ld a,(input_len) 
8cf2 cd a7 8a				call addatohl 
8cf5 3e 20				ld a, ' ' 
8cf7 77					ld (hl),a 
8cf8					; TODO eof of parse marker 
8cf8			 
8cf8 23					inc hl 
8cf9 3e 00				ld a, 0 
8cfb 77					ld (hl),a 
8cfc			 
8cfc			 
8cfc c9					ret 
8cfd			 
8cfd .. 00		.iblank: db " ",0 
8cff			 
8cff			 
8cff 32 73 ee		input_str_prev:	ld (input_at_pos), a 
8d02 22 76 ee				ld (input_start), hl 
8d05 3e 01				ld a,1			; add cursor 
8d07 77					ld (hl),a 
8d08 23					inc hl 
8d09 3e 00				ld a,0 
8d0b 77					ld (hl),a 
8d0c 22 78 ee				ld (input_ptr), hl 
8d0f 7a					ld a,d 
8d10 32 75 ee				ld (input_size), a 
8d13 3e 00				ld a,0 
8d15 32 64 ee				ld (input_cursor),a 
8d18			.instr1:	 
8d18			 
8d18					; TODO do block cursor 
8d18					; TODO switch cursor depending on the modifer key 
8d18			 
8d18					; update cursor shape change on key hold 
8d18			 
8d18 2a 78 ee				ld hl, (input_ptr) 
8d1b 2b					dec hl 
8d1c 3a d3 eb				ld a,(cursor_shape) 
8d1f 77					ld (hl), a 
8d20			 
8d20					; display entered text 
8d20 3a 73 ee				ld a,(input_at_pos) 
8d23 cd d2 d7		            	CALL fLCD_Pos       ;Position cursor to location in A 
8d26 ed 5b 76 ee	            	LD   de, (input_start) 
8d2a cd cc d7		            	CALL fLCD_Str       ;Display string pointed to by DE 
8d2d			 
8d2d cd 74 d8				call cin 
8d30 fe 00				cp 0 
8d32 28 e4				jr z, .instr1 
8d34			 
8d34					; proecess keyboard controls first 
8d34			 
8d34 2a 78 ee				ld hl,(input_ptr) 
8d37			 
8d37 fe 0d				cp KEY_CR	 ; pressing enter ends input 
8d39 28 5a				jr z, .instrcr 
8d3b			 
8d3b fe 08				cp KEY_BS 	; back space 
8d3d 20 0f				jr nz, .instr2 
8d3f					; process back space 
8d3f			 
8d3f					; TODO stop back space if at start of string 
8d3f 2b					dec hl 
8d40 2b					dec hl ; to over write cursor 
8d41 3a d3 eb				ld a,(cursor_shape) 
8d44					;ld a,0 
8d44 77					ld (hl),a 
8d45 23					inc hl 
8d46 3e 20				ld a," " 
8d48 77					ld (hl),a 
8d49 22 78 ee				ld (input_ptr),hl 
8d4c					 
8d4c			 
8d4c 18 ca				jr .instr1 
8d4e			 
8d4e fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8d50 20 06				jr nz, .instr3 
8d52 2b					dec hl 
8d53 22 78 ee				ld (input_ptr),hl 
8d56 18 c0				jr .instr1 
8d58				 
8d58 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8d5a 20 06				jr nz, .instr4 
8d5c 23					inc hl 
8d5d 22 78 ee				ld (input_ptr),hl 
8d60 18 b6				jr .instr1 
8d62			 
8d62 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8d64 20 06				jr nz, .instr5 
8d66 2b					dec hl 
8d67 22 78 ee				ld (input_ptr),hl 
8d6a 18 ac				jr .instr1 
8d6c			 
8d6c fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8d6e 20 06				jr nz, .instr6 
8d70 2b					dec hl 
8d71 22 78 ee				ld (input_ptr),hl 
8d74 18 a2				jr .instr1 
8d76 fe 05		.instr6:        cp KEY_UP      ; recall last command 
8d78 20 0b				jr nz, .instrnew 
8d7a			 
8d7a 21 60 e3			ld hl, scratch 
8d7d 11 86 e7			ld de, os_last_cmd 
8d80 cd 9e 8d			call strcpy 
8d83 18 93				jr .instr1 
8d85			 
8d85			 
8d85			.instrnew:	; no special key pressed to see if we have room to store it 
8d85			 
8d85					; TODO do string size test 
8d85			 
8d85 2b					dec hl ; to over write cursor 
8d86 77					ld (hl),a 
8d87 23					inc hl 
8d88 3a d3 eb				ld a,(cursor_shape) 
8d8b 77					ld (hl),a 
8d8c 23					inc hl 
8d8d 3e 00				ld a,0 
8d8f 77					ld (hl),a 
8d90			 
8d90 22 78 ee				ld (input_ptr),hl 
8d93					 
8d93 18 83				jr .instr1 
8d95 2b			.instrcr:	dec hl		; remove cursor 
8d96 3e 20				ld a,' '	; TODO add a trailing space for safety 
8d98 77					ld (hl),a 
8d99 23					inc hl 
8d9a 3e 00				ld a,0 
8d9c 77					ld (hl),a 
8d9d			 
8d9d			 
8d9d					; if at end of line scroll up    
8d9d					; TODO detecting only end of line 4 for scroll up  
8d9d			 
8d9d					;ld   
8d9d			 
8d9d c9					ret 
8d9e			 
8d9e			 
8d9e			; strcpy hl = dest, de source 
8d9e			 
8d9e 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8d9f b7			            OR   A              ;Null terminator? 
8da0 c8			            RET  Z              ;Yes, so finished 
8da1 1a					ld a,(de) 
8da2 77					ld (hl),a 
8da3 13			            INC  DE             ;Point to next character 
8da4 23					inc hl 
8da5 18 f7		            JR   strcpy       ;Repeat 
8da7 c9					ret 
8da8			 
8da8			 
8da8			; TODO string_at  
8da8			; pass string which starts with lcd offset address and then null term string 
8da8			 
8da8			; TODO string to dec 
8da8			; TODO string to hex 
8da8			; TODO byte to string hex 
8da8			; TODO byte to string dec 
8da8			 
8da8			 
8da8			 
8da8			; from z80uartmonitor 
8da8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8da8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8da8			; pass hl for where to put the text 
8da8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8da8 c5			hexout:	PUSH BC 
8da9 f5					PUSH AF 
8daa 47					LD B, A 
8dab					; Upper nybble 
8dab cb 3f				SRL A 
8dad cb 3f				SRL A 
8daf cb 3f				SRL A 
8db1 cb 3f				SRL A 
8db3 cd c3 8d				CALL tohex 
8db6 77					ld (hl),a 
8db7 23					inc hl	 
8db8					 
8db8					; Lower nybble 
8db8 78					LD A, B 
8db9 e6 0f				AND 0FH 
8dbb cd c3 8d				CALL tohex 
8dbe 77					ld (hl),a 
8dbf 23					inc hl	 
8dc0					 
8dc0 f1					POP AF 
8dc1 c1					POP BC 
8dc2 c9					RET 
8dc3					 
8dc3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dc3			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8dc3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dc3			tohex: 
8dc3 e5					PUSH HL 
8dc4 d5					PUSH DE 
8dc5 16 00				LD D, 0 
8dc7 5f					LD E, A 
8dc8 21 d0 8d				LD HL, .DATA 
8dcb 19					ADD HL, DE 
8dcc 7e					LD A, (HL) 
8dcd d1					POP DE 
8dce e1					POP HL 
8dcf c9					RET 
8dd0			 
8dd0			.DATA: 
8dd0 30					DEFB	30h	; 0 
8dd1 31					DEFB	31h	; 1 
8dd2 32					DEFB	32h	; 2 
8dd3 33					DEFB	33h	; 3 
8dd4 34					DEFB	34h	; 4 
8dd5 35					DEFB	35h	; 5 
8dd6 36					DEFB	36h	; 6 
8dd7 37					DEFB	37h	; 7 
8dd8 38					DEFB	38h	; 8 
8dd9 39					DEFB	39h	; 9 
8dda 41					DEFB	41h	; A 
8ddb 42					DEFB	42h	; B 
8ddc 43					DEFB	43h	; C 
8ddd 44					DEFB	44h	; D 
8dde 45					DEFB	45h	; E 
8ddf 46					DEFB	46h	; F 
8de0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8de0			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8de0			;;    subtract $30, if result > 9 then subtract $7 more 
8de0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8de0			atohex: 
8de0 d6 30				SUB $30 
8de2 fe 0a				CP 10 
8de4 f8					RET M		; If result negative it was 0-9 so we're done 
8de5 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8de7 c9					RET		 
8de8			 
8de8			 
8de8			 
8de8			 
8de8			; Get 2 ASCII characters as hex byte from pointer in hl 
8de8			 
8de8			BYTERD: 
8de8 16 00			LD	D,00h		;Set up 
8dea cd f2 8d			CALL	HEXCON		;Get byte and convert to hex 
8ded 87				ADD	A,A		;First nibble so 
8dee 87				ADD	A,A		;multiply by 16 
8def 87				ADD	A,A		; 
8df0 87				ADD	A,A		; 
8df1 57				LD	D,A		;Save hi nibble in D 
8df2			HEXCON: 
8df2 7e				ld a, (hl)		;Get next chr 
8df3 23				inc hl 
8df4 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8df6 fe 0a			CP	00Ah		;Is it 0-9 ? 
8df8 38 02			JR	C,NALPHA	;If so miss next bit 
8dfa d6 07			SUB	007h		;Else convert alpha 
8dfc			NALPHA: 
8dfc b2				OR	D		;Add hi nibble back 
8dfd c9				RET			; 
8dfe			 
8dfe			 
8dfe			; 
8dfe			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8dfe			; Since the routines get_byte and therefore get_nibble are called, only valid 
8dfe			; characters (0-9a-f) are accepted. 
8dfe			; 
8dfe			;get_word        push    af 
8dfe			;                call    get_byte        ; Get the upper byte 
8dfe			;                ld      h, a 
8dfe			;                call    get_byte        ; Get the lower byte 
8dfe			;                ld      l, a 
8dfe			;                pop     af 
8dfe			;                ret 
8dfe			; 
8dfe			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8dfe			; the routine get_nibble is used only valid characters are accepted - the  
8dfe			; input routine only accepts characters 0-9a-f. 
8dfe			; 
8dfe c5			get_byte:        push    bc              ; Save contents of B (and C) 
8dff 7e					ld a,(hl) 
8e00 23					inc hl 
8e01 cd 26 8e		                call    nibble2val      ; Get upper nibble 
8e04 cb 07		                rlc     a 
8e06 cb 07		                rlc     a 
8e08 cb 07		                rlc     a 
8e0a cb 07		                rlc     a 
8e0c 47			                ld      b, a            ; Save upper four bits 
8e0d 7e					ld a,(hl) 
8e0e cd 26 8e		                call    nibble2val      ; Get lower nibble 
8e11 b0			                or      b               ; Combine both nibbles 
8e12 c1			                pop     bc              ; Restore B (and C) 
8e13 c9			                ret 
8e14			; 
8e14			; Get a hexadecimal digit from the serial line. This routine blocks until 
8e14			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8e14			; to the serial line interface. The lower 4 bits of A contain the value of  
8e14			; that particular digit. 
8e14			; 
8e14			;get_nibble      ld a,(hl)           ; Read a character 
8e14			;                call    to_upper        ; Convert to upper case 
8e14			;                call    is_hex          ; Was it a hex digit? 
8e14			;                jr      nc, get_nibble  ; No, get another character 
8e14			 ;               call    nibble2val      ; Convert nibble to value 
8e14			 ;               call    print_nibble 
8e14			 ;               ret 
8e14			; 
8e14			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8e14			; A valid hexadecimal digit is denoted by a set C flag. 
8e14			; 
8e14			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8e14			;                ret     nc              ; Yes 
8e14			;                cp      '0'             ; Less than '0'? 
8e14			;                jr      nc, is_hex_1    ; No, continue 
8e14			;                ccf                     ; Complement carry (i.e. clear it) 
8e14			;                ret 
8e14			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8e14			;                ret     c               ; Yes 
8e14			;                cp      'A'             ; Less than 'A'? 
8e14			;                jr      nc, is_hex_2    ; No, continue 
8e14			;                ccf                     ; Yes - clear carry and return 
8e14			;                ret 
8e14			;is_hex_2        scf                     ; Set carry 
8e14			;                ret 
8e14			; 
8e14			; Convert a single character contained in A to upper case: 
8e14			; 
8e14 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8e16 d8			                ret     c 
8e17 fe 7b		                cp      'z' + 1         ; > 'z'? 
8e19 d0			                ret     nc              ; Nothing to do, either 
8e1a e6 5f		                and     $5f             ; Convert to upper case 
8e1c c9			                ret 
8e1d			 
8e1d			 
8e1d			to_lower: 
8e1d			 
8e1d			   ; if char is in [A-Z] make it lower case 
8e1d			 
8e1d			   ; enter : a = char 
8e1d			   ; exit  : a = lower case char 
8e1d			   ; uses  : af 
8e1d			 
8e1d fe 41		   cp 'A' 
8e1f d8			   ret c 
8e20			    
8e20 fe 5b		   cp 'Z'+1 
8e22 d0			   ret nc 
8e23			    
8e23 f6 20		   or $20 
8e25 c9			   ret 
8e26			 
8e26			; 
8e26			; Expects a hexadecimal digit (upper case!) in A and returns the 
8e26			; corresponding value in A. 
8e26			; 
8e26 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8e28 38 02		                jr      c, nibble2val_1 ; Yes 
8e2a d6 07		                sub     7               ; Adjust for A-F 
8e2c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8e2e e6 0f		                and     $f              ; Only return lower 4 bits 
8e30 c9			                ret 
8e31			; 
8e31			; Print_nibble prints a single hex nibble which is contained in the lower  
8e31			; four bits of A: 
8e31			; 
8e31			;print_nibble    push    af              ; We won't destroy the contents of A 
8e31			;                and     $f              ; Just in case... 
8e31			;                add     a, '0'             ; If we have a digit we are done here. 
8e31			;                cp      '9' + 1         ; Is the result > 9? 
8e31			;                jr      c, print_nibble_1 
8e31			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8e31			;print_nibble_1  call    putc            ; Print the nibble and 
8e31			;                pop     af              ; restore the original value of A 
8e31			;                ret 
8e31			;; 
8e31			;; Send a CR/LF pair: 
8e31			; 
8e31			;crlf            push    af 
8e31			;                ld      a, cr 
8e31			;                call    putc 
8e31			;                ld      a, lf 
8e31			;                call    putc 
8e31			;                pop     af 
8e31			;                ret 
8e31			; 
8e31			; Print_word prints the four hex digits of a word to the serial line. The  
8e31			; word is expected to be in HL. 
8e31			; 
8e31			;print_word      push    hl 
8e31			;                push    af 
8e31			;                ld      a, h 
8e31			;                call    print_byte 
8e31			;                ld      a, l 
8e31			;                call    print_byte 
8e31			;                pop     af 
8e31			;                pop     hl 
8e31			;                ret 
8e31			; 
8e31			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8e31			; The byte to be printed is expected to be in A. 
8e31			; 
8e31			;print_byte      push    af              ; Save the contents of the registers 
8e31			;                push    bc 
8e31			;                ld      b, a 
8e31			;                rrca 
8e31			;                rrca 
8e31			;                rrca 
8e31			;                rrca 
8e31			;                call    print_nibble    ; Print high nibble 
8e31			;                ld      a, b 
8e31			;                call    print_nibble    ; Print low nibble 
8e31			;                pop     bc              ; Restore original register contents 
8e31			;                pop     af 
8e31			;                ret 
8e31			 
8e31			 
8e31			 
8e31			 
8e31			 
8e31			fourehexhl:  
8e31 7e				ld a,(hl) 
8e32 cd e0 8d			call atohex 
8e35 cb 3f				SRL A 
8e37 cb 3f				SRL A 
8e39 cb 3f				SRL A 
8e3b cb 3f				SRL A 
8e3d 47				ld b, a 
8e3e 23				inc hl 
8e3f 7e				ld a,(hl) 
8e40 23				inc hl 
8e41 cd e0 8d			call atohex 
8e44 80				add b 
8e45 57				ld d,a 
8e46 7e				ld a,(hl) 
8e47 cd e0 8d			call atohex 
8e4a cb 3f				SRL A 
8e4c cb 3f				SRL A 
8e4e cb 3f				SRL A 
8e50 cb 3f				SRL A 
8e52 47				ld b, a 
8e53 23				inc hl 
8e54 7e				ld a,(hl) 
8e55 23				inc hl 
8e56 cd e0 8d			call atohex 
8e59 80				add b 
8e5a 5f				ld e, a 
8e5b d5				push de 
8e5c e1				pop hl 
8e5d c9				ret 
8e5e			 
8e5e			; pass hl. returns z set if the byte at hl is a digit 
8e5e			;isdigithl:  
8e5e			;	push bc 
8e5e			;	ld a,(hl) 
8e5e			;	cp ':' 
8e5e			;	jr nc, .isdf 		; > 
8e5e			;	cp '0' 
8e5e			;	jr c, .isdf		; < 
8e5e			; 
8e5e			;	; TODO find a better way to set z 
8e5e			; 
8e5e			;	ld b,a 
8e5e			;	cp b 
8e5e			;	pop bc 
8e5e			;	ret 
8e5e			; 
8e5e			;.isdf:	; not digit so clear z 
8e5e			; 
8e5e			;	; TODO find a better way to unset z 
8e5e			; 
8e5e			;	ld b,a 
8e5e			;	inc b 
8e5e			;	cp b 
8e5e			; 
8e5e			;	pop bc 
8e5e			;	ret 
8e5e				 
8e5e				 
8e5e			 
8e5e			 
8e5e			; pass hl as the four byte address to load 
8e5e			 
8e5e			get_word_hl:  
8e5e e5				push hl 
8e5f cd fe 8d			call get_byte 
8e62				 
8e62 47				ld b, a 
8e63			 
8e63 e1				pop hl 
8e64 23				inc hl 
8e65 23				inc hl 
8e66			 
8e66			; TODO not able to handle a-f  
8e66 7e				ld a,(hl) 
8e67			;	;cp ':' 
8e67			;	cp 'g' 
8e67			;	jr nc, .single_byte_hl 		; > 
8e67			;	cp 'G' 
8e67			;	jr nc, .single_byte_hl 		; > 
8e67			;	cp '0' 
8e67			;	jr c, .single_byte_hl		; < 
8e67			 
8e67				;call isdigithl 
8e67 fe 00			cp 0 
8e69 28 06			jr z, .single_byte_hl 
8e6b			 
8e6b			.getwhln:   ; hex word so get next byte 
8e6b			 
8e6b cd fe 8d			call get_byte 
8e6e 6f				ld l, a 
8e6f 60				ld h,b 
8e70 c9				ret 
8e71 68			.single_byte_hl:   ld l,b 
8e72 26 00				ld h,0 
8e74 c9					ret 
8e75			 
8e75			 
8e75			 
8e75			 
8e75 21 a7 95			ld hl,asc+1 
8e78			;	ld a, (hl) 
8e78			;	call nibble2val 
8e78 cd fe 8d			call get_byte 
8e7b			 
8e7b			;	call fourehexhl 
8e7b 32 94 e3			ld (scratch+52),a 
8e7e				 
8e7e 21 92 e3			ld hl,scratch+50 
8e81 22 83 e6			ld (os_cur_ptr),hl 
8e84			 
8e84 c9				ret 
8e85			 
8e85			 
8e85			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8e85			 
8e85			; Decimal Unsigned Version 
8e85			 
8e85			;Number in a to decimal ASCII 
8e85			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8e85			;Example: display a=56 as "056" 
8e85			;input: a = number 
8e85			;Output: a=0,value of a in the screen 
8e85			;destroys af,bc (don't know about hl and de) 
8e85			DispAToASCII: 
8e85 0e 9c			ld	c,-100 
8e87 cd 91 8e			call	.Na1 
8e8a 0e f6			ld	c,-10 
8e8c cd 91 8e			call	.Na1 
8e8f 0e ff			ld	c,-1 
8e91 06 2f		.Na1:	ld	b,'0'-1 
8e93 04			.Na2:	inc	b 
8e94 81				add	a,c 
8e95 38 fc			jr	c,.Na2 
8e97 91				sub	c		;works as add 100/10/1 
8e98 f5				push af		;safer than ld c,a 
8e99 78				ld	a,b		;char is in b 
8e9a			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8e9a f1				pop af		;safer than ld a,c 
8e9b c9				ret 
8e9c			 
8e9c			; Decimal Signed Version 
8e9c			 
8e9c			; DispA 
8e9c			; -------------------------------------------------------------- 
8e9c			; Converts a signed integer value to a zero-terminated ASCII 
8e9c			; string representative of that value (using radix 10). 
8e9c			; -------------------------------------------------------------- 
8e9c			; INPUTS: 
8e9c			;     HL     Value to convert (two's complement integer). 
8e9c			;     DE     Base address of string destination. (pointer). 
8e9c			; -------------------------------------------------------------- 
8e9c			; OUTPUTS: 
8e9c			;     None 
8e9c			; -------------------------------------------------------------- 
8e9c			; REGISTERS/MEMORY DESTROYED 
8e9c			; AF HL 
8e9c			; -------------------------------------------------------------- 
8e9c			 
8e9c			;DispHLToASCII: 
8e9c			;   push    de 
8e9c			;   push    bc 
8e9c			; 
8e9c			;; Detect sign of HL. 
8e9c			;    bit    7, h 
8e9c			;    jr     z, ._DoConvert 
8e9c			; 
8e9c			;; HL is negative. Output '-' to string and negate HL. 
8e9c			;    ld     a, '-' 
8e9c			;    ld     (de), a 
8e9c			;    inc    de 
8e9c			; 
8e9c			;; Negate HL (using two's complement) 
8e9c			;    xor    a 
8e9c			;    sub    l 
8e9c			;    ld     l, a 
8e9c			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8e9c			;    sbc    a, h 
8e9c			;    ld     h, a 
8e9c			; 
8e9c			;; Convert HL to digit characters 
8e9c			;._DoConvert: 
8e9c			;    ld     b, 0     ; B will count character length of number 
8e9c			;-   ld     a, 10 
8e9c			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8e9c			;    push   af 
8e9c			;    inc    b 
8e9c			;    ld     a, h 
8e9c			;    or     l 
8e9c			;    jr     nz, - 
8e9c			; 
8e9c			;; Retrieve digits from stack 
8e9c			;-   pop    af 
8e9c			;    or     $30 
8e9c			;    ld     (de), a 
8e9c			;    inc    de 
8e9c			;    djnz   - 
8e9c			; 
8e9c			;; Terminate string with NULL 
8e9c			;    xor    a 
8e9c			;    ld     (de), a 
8e9c			; 
8e9c			;    pop    bc 
8e9c			;    pop    de 
8e9c			;    ret 
8e9c			 
8e9c			;Comments 
8e9c			; 
8e9c			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8e9c			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8e9c			;    Note that the output string will not be fixed-width. 
8e9c			; 
8e9c			;Example Usage 
8e9c			; 
8e9c			;    ld    hl, -1004 
8e9c			;    ld    de, OP1 
8e9c			;    call  DispA 
8e9c			;    ld    hl, OP1 
8e9c			;    syscall  PutS 
8e9c			 
8e9c			 
8e9c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8e9c			 
8e9c			 
8e9c			;Converts an ASCII string to an unsigned 16-bit integer 
8e9c			;Quits when it reaches a non-decimal digit 
8e9c			 
8e9c			string_to_uint16: 
8e9c			atoui_16: 
8e9c			;Input: 
8e9c			;     DE points to the string 
8e9c			;Outputs: 
8e9c			;     HL is the result 
8e9c			;     A is the 8-bit value of the number 
8e9c			;     DE points to the byte after the number 
8e9c			;Destroys: 
8e9c			;     BC 
8e9c			;       if the string is non-empty, BC is HL/10 
8e9c			;Size:  24 bytes 
8e9c			;Speed: 42+d(104+{0,9}) 
8e9c			;       d is the number of digits in the number 
8e9c			;       max is 640 cycles for a 5 digit number 
8e9c			;Assuming no leading zeros: 
8e9c			;1 digit:  146cc 
8e9c			;2 digit:  250cc 
8e9c			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8e9c			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8e9c			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8e9c			;avg: 544.81158447265625cc (544+13297/16384) 
8e9c			;=============================================================== 
8e9c 21 00 00		  ld hl,0 
8e9f			.u16a: 
8e9f 1a			  ld a,(de) 
8ea0 d6 30		  sub 30h 
8ea2 fe 0a		  cp 10 
8ea4 d0			  ret nc 
8ea5 13			  inc de 
8ea6 44			  ld b,h 
8ea7 4d			  ld c,l 
8ea8 29			  add hl,hl 
8ea9 29			  add hl,hl 
8eaa 09			  add hl,bc 
8eab 29			  add hl,hl 
8eac 85			  add a,l 
8ead 6f			  ld l,a 
8eae 30 ef		  jr nc,.u16a 
8eb0 24			  inc h 
8eb1 c3 9f 8e		  jp .u16a 
8eb4			 
8eb4			 
8eb4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8eb4			 
8eb4			;written by Zeda 
8eb4			;Converts a 16-bit unsigned integer to an ASCII string. 
8eb4			 
8eb4			uitoa_16: 
8eb4			;Input: 
8eb4			;   DE is the number to convert 
8eb4			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8eb4			;Output: 
8eb4			;   HL points to the null-terminated ASCII string 
8eb4			;      NOTE: This isn't necessarily the same as the input HL. 
8eb4 d5			  push de 
8eb5 c5			  push bc 
8eb6 f5			  push af 
8eb7 eb			  ex de,hl 
8eb8			 
8eb8 01 f0 d8		  ld bc,-10000 
8ebb 3e 2f		  ld a,'0'-1 
8ebd 3c			  inc a 
8ebe 09			  add hl,bc  
8ebf 38 fc		   jr c,$-2 
8ec1 12			  ld (de),a 
8ec2 13			  inc de 
8ec3			 
8ec3 01 e8 03		  ld bc,1000 
8ec6 3e 3a		  ld a,'9'+1 
8ec8 3d			  dec a  
8ec9 09			  add hl,bc  
8eca 30 fc		   jr nc,$-2 
8ecc 12			  ld (de),a 
8ecd 13			  inc de 
8ece			 
8ece 01 9c ff		  ld bc,-100 
8ed1 3e 2f		  ld a,'0'-1 
8ed3 3c			  inc a  
8ed4 09			  add hl,bc  
8ed5 38 fc		   jr c,$-2 
8ed7 12			  ld (de),a 
8ed8 13			  inc de 
8ed9			 
8ed9 7d			  ld a,l 
8eda 26 3a		  ld h,'9'+1 
8edc 25			  dec h  
8edd c6 0a		  add a,10  
8edf 30 fb		   jr nc,$-3 
8ee1 c6 30		  add a,'0' 
8ee3 eb			  ex de,hl 
8ee4 72			  ld (hl),d 
8ee5 23			  inc hl 
8ee6 77			  ld (hl),a 
8ee7 23			  inc hl 
8ee8 36 00		  ld (hl),0 
8eea			 
8eea			;Now strip the leading zeros 
8eea 0e fa		  ld c,-6 
8eec 09			  add hl,bc 
8eed 3e 30		  ld a,'0' 
8eef 23			  inc hl  
8ef0 be			  cp (hl)  
8ef1 28 fc		  jr z,$-2 
8ef3			 
8ef3			;Make sure that the string is non-empty! 
8ef3 7e			  ld a,(hl) 
8ef4 b7			  or a 
8ef5 20 01		  jr nz,.atoub 
8ef7 2b			  dec hl 
8ef8			.atoub: 
8ef8			 
8ef8 f1			  pop af 
8ef9 c1			  pop bc 
8efa d1			  pop de 
8efb c9			  ret 
8efc			 
8efc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
8efc			 
8efc			toUpper: 
8efc			;A is the char. 
8efc			;If A is a lowercase letter, this sets it to the matching uppercase 
8efc			;18cc or 30cc or 41cc 
8efc			;avg: 26.75cc 
8efc fe 61		  cp 'a' 
8efe d8			  ret c 
8eff fe 7b		  cp 'z'+1 
8f01 d0			  ret nc 
8f02 d6 20		  sub 'a'-'A' 
8f04 c9			  ret 
8f05			 
8f05			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
8f05			 
8f05			; String Length 
8f05			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
8f05			 
8f05			; Get the length of the null-terminated string starting at $8000 hl 
8f05			;    LD     HL, $8000 
8f05			 
8f05			strlenz: 
8f05			 
8f05 af			    XOR    A               ; Zero is the value we are looking for. 
8f06 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
8f07 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
8f08			                           ; 65, 536 bytes (the entire addressable memory space). 
8f08 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8f0a			 
8f0a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8f0a 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
8f0b 6f			    LD     L, A             ; number of bytes 
8f0c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8f0e 2b			    DEC    HL              ; Compensate for null. 
8f0f c9				ret 
8f10			 
8f10			; Get the length of the A terminated string starting at $8000 hl 
8f10			;    LD     HL, $8000 
8f10			 
8f10			strlent: 
8f10			 
8f10			                  ; A is the value we are looking for. 
8f10 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
8f12 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
8f14			                           ; 65, 536 bytes (the entire addressable memory space). 
8f14 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8f16			 
8f16			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8f16 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
8f18 2e 00		    LD     L, 0             ; number of bytes 
8f1a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8f1c 2b			    DEC    HL              ; Compensate for null. 
8f1d c9				ret 
8f1e			 
8f1e			 
8f1e			;Comparing Strings 
8f1e			 
8f1e			;IN    HL     Address of string1. 
8f1e			;      DE     Address of string2. 
8f1e			 
8f1e			; doc given but wrong??? 
8f1e			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
8f1e			;      carry  Set if string1 > string2, reset if string1 <= string2. 
8f1e			; tested 
8f1e			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
8f1e			 
8f1e			strcmp_old: 
8f1e e5			    PUSH   HL 
8f1f d5			    PUSH   DE 
8f20			 
8f20 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
8f21 be			    CP     (HL)            ; (want to minimize work). 
8f22 38 01		    JR     C, Str1IsBigger 
8f24 7e			    LD     A, (HL) 
8f25			 
8f25			Str1IsBigger: 
8f25 4f			    LD     C, A             ; Put length in BC 
8f26 06 00		    LD     B, 0 
8f28 13			    INC    DE              ; Increment pointers to meat of string. 
8f29 23			    INC    HL 
8f2a			 
8f2a			CmpLoop: 
8f2a 1a			    LD     A, (DE)          ; Compare bytes. 
8f2b ed a1		    CPI 
8f2d 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
8f2f 13			    INC    DE              ; Update pointer. 
8f30 ea 2a 8f		    JP     PE, CmpLoop 
8f33			 
8f33 d1			    POP    DE 
8f34 e1			    POP    HL 
8f35 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
8f36 be			    CP     (HL) 
8f37 c9			    RET 
8f38			 
8f38			NoMatch: 
8f38 2b			    DEC    HL 
8f39 be			    CP     (HL)            ; Compare again to affect carry. 
8f3a d1			    POP    DE 
8f3b e1			    POP    HL 
8f3c c9			    RET 
8f3d			 
8f3d			;; test strmp 
8f3d			; 
8f3d			;ld de, .str1 
8f3d			;ld hl, .str2 
8f3d			;call strcmp 
8f3d			;jr z, .z1 
8f3d			;;this 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "NZ1" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			;.z1: 
8f3d			; 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "ZZ1" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			; 
8f3d			;ld de, .str1 
8f3d			;ld hl, .str1 
8f3d			;call strcmp 
8f3d			;jr z, .z2 
8f3d			;;this 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "NZ2" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			;.z2: 
8f3d			; 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "ZZ2" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			; 
8f3d			;ld de, .str1 
8f3d			;ld hl, .str2 
8f3d			;call strcmp 
8f3d			;jr c, .c1 
8f3d			; 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "Nc1" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			;.c1: 
8f3d			;;this 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "cc1" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			; 
8f3d			;ld de, .str1 
8f3d			;ld hl, .str1 
8f3d			;call strcmp 
8f3d			;jr c, .c2 
8f3d			;;this 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "Nc2" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			;.c2: 
8f3d			; 
8f3d			;	if DEBUG_FORTH_WORDS 
8f3d			;		DMARK "cc2" 
8f3d			;		CALLMONITOR 
8f3d			;	endif 
8f3d			;	NEXTW 
8f3d			;.str1:   db "string1",0 
8f3d			;.str2:   db "string2",0 
8f3d			 
8f3d			; only care about direct match or not 
8f3d			; hl and de strings 
8f3d			; zero set if the same 
8f3d			 
8f3d			strcmp: 
8f3d 1a				ld a, (de) 
8f3e be				cp (hl) 
8f3f 28 02			jr z, .ssame 
8f41 b7				or a 
8f42 c9				ret 
8f43			 
8f43			.ssame:  
8f43 fe 00			cp 0 
8f45 c8				ret z 
8f46			 
8f46 23				inc hl 
8f47 13				inc de 
8f48 18 f3			jr strcmp 
8f4a				 
8f4a				 
8f4a			 
8f4a			 
8f4a			 
8f4a			 
8f4a			; eof 
8f4a			 
8f4a			 
8f4a			 
8f4a			 
8f4a			 
8f4a			 
# End of file firmware_strings.asm
8f4a			include "firmware_memory.asm"   ; malloc and free  
8f4a			 
8f4a			if DEBUG_FORTH_MALLOC_HIGH 
8f4a			.mallocsize: db "Wants malloc >256",0 
8f4a			.mallocasize: db "MALLOC gives >256",0 
8f4a			.malloczero: db "MALLOC gives zero",0 
8f4a			 
8f4a			malloc_guard_zerolen: 
8f4a				push hl 
8f4a				push de 
8f4a				push af 
8f4a			 
8f4a				ld de, 0 
8f4a			        call cmp16 
8f4a				jr nz, .lowalloz 
8f4a			 
8f4a				push hl 
8f4a				push de 
8f4a					ld hl, display_fb0 
8f4a					ld (display_fb_active), hl 
8f4a				call clear_display 
8f4a				ld a, 0 
8f4a				ld de, .malloczero 
8f4a				call str_at_display 
8f4a				call update_display 
8f4a				call delay1s 
8f4a				call delay1s 
8f4a				ld a, 0 
8f4a				ld (os_view_disable), a 
8f4a			 
8f4a				pop de 
8f4a				pop hl 
8f4a			 
8f4a				 
8f4a			 
8f4a				CALLMONITOR 
8f4a			.lowalloz: 
8f4a			 
8f4a			 
8f4a				pop af 
8f4a				pop de 
8f4a				pop hl 
8f4a			ret 
8f4a			 
8f4a			malloc_guard_entry: 
8f4a				push hl 
8f4a				push de 
8f4a				push af 
8f4a			 
8f4a			 	or a      ;clear carry flag 
8f4a				push hl 
8f4a				ld de, 255 
8f4a				sbc hl, de 
8f4a				jr c, .lowalloc 
8f4a			 
8f4a				push de 
8f4a					ld hl, display_fb0 
8f4a					ld (display_fb_active), hl 
8f4a				call clear_display 
8f4a				ld a, 0 
8f4a				ld de, .mallocsize 
8f4a				call str_at_display 
8f4a				call update_display 
8f4a				call delay1s 
8f4a				call delay1s 
8f4a				ld a, 0 
8f4a				ld (os_view_disable), a 
8f4a			 
8f4a				pop de 
8f4a				pop hl 
8f4a			 
8f4a				 
8f4a			 
8f4a				CALLMONITOR 
8f4a				jr .lowdone 
8f4a			.lowalloc: 
8f4a			 
8f4a			 
8f4a				pop hl 
8f4a			.lowdone:	pop af 
8f4a				pop de 
8f4a				pop hl 
8f4a			ret 
8f4a			 
8f4a			malloc_guard_exit: 
8f4a				push hl 
8f4a				push de 
8f4a				push af 
8f4a			 
8f4a			 	or a      ;clear carry flag 
8f4a				push hl 
8f4a				ld de, 255 
8f4a				sbc hl, de 
8f4a				jr c, .lowallocx 
8f4a			 
8f4a				push de 
8f4a					ld hl, display_fb0 
8f4a					ld (display_fb_active), hl 
8f4a				call clear_display 
8f4a				ld a, 0 
8f4a				ld de, .mallocasize 
8f4a				call str_at_display 
8f4a				call update_display 
8f4a				call delay1s 
8f4a				call delay1s 
8f4a				ld a, 0 
8f4a				ld (os_view_disable), a 
8f4a				pop de 
8f4a				pop hl 
8f4a			 
8f4a				CALLMONITOR 
8f4a				jr .lowdonex 
8f4a			.lowallocx: 
8f4a			 
8f4a				pop hl 
8f4a			.lowdonex:	pop af 
8f4a				pop de 
8f4a				pop hl 
8f4a			ret 
8f4a			endif 
8f4a			 
8f4a			if MALLOC_2 
8f4a			; Z80 Malloc and Free Functions 
8f4a			 
8f4a			; Malloc Function: 
8f4a			; Input: 
8f4a			;   HL: Size of block to allocate 
8f4a			; Output: 
8f4a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f4a			 
8f4a			malloc: 
8f4a				 
8f4a			if DEBUG_FORTH_MALLOC_HIGH 
8f4a			call malloc_guard_entry 
8f4a			endif 
8f4a			 
8f4a			 
8f4a			 
8f4a			 
8f4a					if DEBUG_FORTH_MALLOC 
8f4a						DMARK "mal" 
8f4a						CALLMONITOR 
8f4a					endif 
8f4a			    push af            ; Save AF register 
8f4a			    ld a, l            ; Load low byte of size into A 
8f4a			    or h               ; Check if size is zero 
8f4a			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
8f4a			 
8f4a			    ; Allocate memory 
8f4a			    ld hl, (heap_start) ; Load start of heap into HL 
8f4a					if DEBUG_FORTH_MALLOC 
8f4a						DMARK "ma1" 
8f4a						CALLMONITOR 
8f4a					endif 
8f4a			    call malloc_internal ; Call internal malloc function 
8f4a			    pop af             ; Restore AF register 
8f4a			if DEBUG_FORTH_MALLOC_HIGH 
8f4a			call malloc_guard_exit 
8f4a			call malloc_guard_zerolen 
8f4a			endif 
8f4a			    ret                ; Return 
8f4a			 
8f4a			; Free Function: 
8f4a			; Input: 
8f4a			;   HL: Pointer to memory block to free 
8f4a			; Output: 
8f4a			;   None 
8f4a			 
8f4a			free: 
8f4a			    push af            ; Save AF register 
8f4a			    ld a, l            ; Load low byte of pointer into A 
8f4a			    or h               ; Check if pointer is NULL 
8f4a			    jp z, free_exit    ; If pointer is NULL, exit 
8f4a			 
8f4a			    ; Free memory 
8f4a			    ld hl, (heap_start) ; Load start of heap into HL 
8f4a			    call free_internal  ; Call internal free function 
8f4a			    pop af             ; Restore AF register 
8f4a			    ret                ; Return 
8f4a			 
8f4a			; Internal Malloc Function: 
8f4a			; Input: 
8f4a			;   HL: Size of block to allocate 
8f4a			; Output: 
8f4a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f4a			 
8f4a			malloc_internal: 
8f4a			    ld bc, 2           ; Number of bytes to allocate for management overhead 
8f4a			    add hl, bc         ; Add management overhead to requested size 
8f4a			    ex de, hl          ; Save total size in DE, and keep it in HL 
8f4a					if DEBUG_FORTH_MALLOC 
8f4a						DMARK "ma2" 
8f4a						CALLMONITOR 
8f4a					endif 
8f4a			 
8f4a			    ; Search for free memory block 
8f4a			    ld de, (heap_end)  ; Load end of heap into DE 
8f4a			    ld bc, 0           ; Initialize counter 
8f4a			 
8f4a					if DEBUG_FORTH_MALLOC 
8f4a						DMARK "ma2" 
8f4a						CALLMONITOR 
8f4a					endif 
8f4a			malloc_search_loop: 
8f4a			    ; Check if current block is free 
8f4a			    ld a, (hl)         ; Load current block's status (free or used) 
8f4a			    cp 0               ; Compare with zero (free) 
8f4a			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
8f4a			 
8f4a			    ; Check if current block is large enough 
8f4a			    ld a, (hl+1)       ; Load high byte of block size 
8f4a			    cp l               ; Compare with low byte of requested size 
8f4a			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
8f4a			 
8f4a			    ld a, (hl+2)       ; Load low byte of block size 
8f4a			    cp h               ; Compare with high byte of requested size 
8f4a			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
8f4a			 
8f4a			    ; Mark block as used 
8f4a			    ld (hl), 0xFF      ; Set status byte to indicate used block 
8f4a			 
8f4a			    ; Calculate remaining space in block 
8f4a			    ld bc, 0           ; Clear BC 
8f4a			    add hl, bc         ; Increment HL to point to start of data block 
8f4a			    add hl, de         ; HL = HL + DE (total size) 
8f4a			    ld bc, 1           ; Number of bytes to allocate for management overhead 
8f4a			    add hl, bc         ; Add management overhead to start of data block 
8f4a			 
8f4a			    ; Save pointer to allocated block in HL 
8f4a			if DEBUG_FORTH_MALLOC_HIGH 
8f4a						DMARK "ma5" 
8f4a			call malloc_guard_exit 
8f4a			call malloc_guard_zerolen 
8f4a			endif 
8f4a			    ret 
8f4a			 
8f4a			malloc_skip_block_check: 
8f4a			    ; Move to the next block 
8f4a			    ld bc, 3           ; Size of management overhead 
8f4a			    add hl, bc         ; Move to the next block 
8f4a			    inc de             ; Increment counter 
8f4a			 
8f4a			    ; Check if we have reached the end of heap 
8f4a			    ld a, e            ; Load low byte of heap end address 
8f4a			    cp (hl)            ; Compare with low byte of current address 
8f4a			    jr nz, malloc_search_loop  ; If not equal, continue searching 
8f4a			    ld a, d            ; Load high byte of heap end address 
8f4a			    cp 0               ; Check if it's zero (end of memory) 
8f4a			    jr nz, malloc_search_loop  ; If not zero, continue searching 
8f4a			 
8f4a			    ; If we reached here, allocation failed 
8f4a			    xor a              ; Set result to NULL 
8f4a			if DEBUG_FORTH_MALLOC_HIGH 
8f4a						DMARK "ma6" 
8f4a			call malloc_guard_exit 
8f4a			call malloc_guard_zerolen 
8f4a			endif 
8f4a			    ret 
8f4a			malloc_exit: 
8f4a			if DEBUG_FORTH_MALLOC_HIGH 
8f4a						DMARK "ma7" 
8f4a			call malloc_guard_exit 
8f4a			call malloc_guard_zerolen 
8f4a			endif 
8f4a			    ret 
8f4a			 
8f4a			; Internal Free Function: 
8f4a			; Input: 
8f4a			;   HL: Pointer to memory block to free 
8f4a			; Output: 
8f4a			;   None 
8f4a			 
8f4a			free_internal: 
8f4a			    ld de, (heap_start) ; Load start of heap into DE 
8f4a			    ld bc, 0            ; Initialize counter 
8f4a			 
8f4a			free_search_loop: 
8f4a			    ; Check if current block contains the pointer 
8f4a			    ld a, l             ; Load low byte of pointer 
8f4a			    cp (hl+1)           ; Compare with high byte of current block's address 
8f4a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f4a			    ld a, h             ; Load high byte of pointer 
8f4a			    cp (hl+2)           ; Compare with low byte of current block's address 
8f4a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f4a			 
8f4a			    ; Mark block as free 
8f4a			    ld (hl), 0          ; Set status byte to indicate free block 
8f4a			    ret                 ; Return 
8f4a			 
8f4a			free_skip_block_check: 
8f4a			    ; Move to the next block 
8f4a			    ld bc, 3            ; Size of management overhead 
8f4a			    add hl, bc          ; Move to the next block 
8f4a			    inc de              ; Increment counter 
8f4a			 
8f4a			    ; Check if we have reached the end of heap 
8f4a			    ld a, e             ; Load low byte of heap end address 
8f4a			    cp (hl)             ; Compare with low byte of current address 
8f4a			    jr nz, free_search_loop  ; If not equal, continue searching 
8f4a			    ld a, d             ; Load high byte of heap end address 
8f4a			    cp 0                ; Check if it's zero (end of memory) 
8f4a			    jr nz, free_search_loop  ; If not zero, continue searching 
8f4a			 
8f4a			    ; If we reached here, pointer is not found in heap 
8f4a			    ret 
8f4a			 
8f4a			free_exit: 
8f4a			    ret                 ; Return 
8f4a			 
8f4a			; Define heap start and end addresses 
8f4a			;heap_start:    .dw 0xC000   ; Start of heap 
8f4a			;heap_end:      .dw 0xE000   ; End of heap 
8f4a			 
8f4a			endif 
8f4a			 
8f4a			 
8f4a			if MALLOC_1 
8f4a			 
8f4a			 
8f4a			 
8f4a			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
8f4a			 
8f4a			;moved to firmware.asm 
8f4a			;heap_start        .equ  0x9000      ; Starting address of heap 
8f4a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
8f4a			 
8f4a			;      .org 0 
8f4a			;      jp    main 
8f4a			 
8f4a			 
8f4a			;      .org  0x100 
8f4a			;main: 
8f4a			;      ld    HL, 0x8100 
8f4a			;      ld    SP, HL 
8f4a			; 
8f4a			;      call  heap_init 
8f4a			; 
8f4a			;      ; Make some allocations 
8f4a			;      ld    HL, 12 
8f4a			;      call  malloc            ; Allocates 0x9004 
8f4a			; 
8f4a			;      ld    HL, 12 
8f4a			;      call  malloc            ; Allocates 0x9014 
8f4a			; 
8f4a			;      ld    HL, 12 
8f4a			;      call  malloc            ; Allocates 0x9024 
8f4a			; 
8f4a			;      ; Free some allocations 
8f4a			;      ld    HL, 0x9014 
8f4a			;      call  free 
8f4a			; 
8f4a			;      ld    HL, 0x9004 
8f4a			;      call  free 
8f4a			; 
8f4a			;      ld    HL, 0x9024 
8f4a			;      call  free 
8f4a			; 
8f4a			; 
8f4a			;      halt 
8f4a			 
8f4a			 
8f4a			;------------------------------------------------------------------------------ 
8f4a			;     heap_init                                                               : 
8f4a			;                                                                             : 
8f4a			; Description                                                                 : 
8f4a			;     Initialise the heap and make it ready for malloc and free operations.   : 
8f4a			;                                                                             : 
8f4a			;     The heap is maintained as a linked list, starting with an initial       : 
8f4a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
8f4a			;     the first free block in the heap. Each block then points to the next    : 
8f4a			;     free block within the heap, and the free list ends at the first block   : 
8f4a			;     with a null pointer to the next free block.                             : 
8f4a			;                                                                             : 
8f4a			; Parameters                                                                  : 
8f4a			;     Inputs are compile-time only. Two defines which specify the starting    : 
8f4a			;     address of the heap and its size are required, along with a memory      : 
8f4a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
8f4a			;     principally stores a pointer to the first free block in the heap.       : 
8f4a			;                                                                             : 
8f4a			; Returns                                                                     : 
8f4a			;     Nothing                                                                 : 
8f4a			;------------------------------------------------------------------------------ 
8f4a			heap_init: 
8f4a e5			      push  HL 
8f4b			 
8f4b			      ; Initialise free list struct 
8f4b 21 92 d8		      ld    HL, heap_start 
8f4e 22 8d d8		      ld    (free_list), HL 
8f51 21 00 00		      ld    HL, 0 
8f54 22 8f d8		      ld    (free_list+2), HL 
8f57			 
8f57			      ; Insert first free block at bottom of heap, consumes entire heap 
8f57 21 42 e3		      ld    HL, heap_start+heap_size-4 
8f5a 22 92 d8		      ld    (heap_start), HL        ; Next block (end of free list) 
8f5d 21 b0 0a		      ld    HL, heap_size-4 
8f60 22 94 d8		      ld    (heap_start+2), HL      ; Block size 
8f63			 
8f63			      ; Insert end of free list block at top of heap - two null words will 
8f63			      ; terminate the free list 
8f63 21 00 00		      ld    HL, 0 
8f66 22 44 e3		      ld    (heap_start+heap_size-2), HL 
8f69 22 42 e3		      ld    (heap_start+heap_size-4), HL 
8f6c			 
8f6c e1			      pop   HL 
8f6d			 
8f6d c9			      ret 
8f6e			 
8f6e			 
8f6e			;------------------------------------------------------------------------------ 
8f6e			;     malloc                                                                  : 
8f6e			;                                                                             : 
8f6e			; Description                                                                 : 
8f6e			;     Allocates the wanted space from the heap and returns the address of the : 
8f6e			;     first useable byte of the allocation.                                   : 
8f6e			;                                                                             : 
8f6e			;     Allocations can happen in one of two ways:                              : 
8f6e			;                                                                             : 
8f6e			;     1. A free block may be found which is the exact size wanted. In this    : 
8f6e			;        case the block is removed from the free list and retuedn to the      : 
8f6e			;        caller.                                                              : 
8f6e			;     2. A free block may be found which is larger than the size wanted. In   : 
8f6e			;        this case, the larger block is split into two. The first portion of  : 
8f6e			;        this block will become the requested space by the malloc call and    : 
8f6e			;        is returned to the caller. The second portion becomes a new free     : 
8f6e			;        block, and the free list is adjusted to maintain continuity via this : 
8f6e			;        newly created block.                                                 : 
8f6e			;                                                                             : 
8f6e			;     malloc does not set any initial value in the allocated space, the       : 
8f6e			;     caller is required to do this as required.                              : 
8f6e			;                                                                             : 
8f6e			;     This implementation of malloc uses the stack exclusively, and is        : 
8f6e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8f6e			;     advisable to disable interrupts before calling malloc, and recommended  : 
8f6e			;     to avoid the use of malloc inside ISRs in general.                      : 
8f6e			;                                                                             : 
8f6e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8f6e			;                                                                             : 
8f6e			; Parameters                                                                  : 
8f6e			;     HL  Number of bytes wanted                                              : 
8f6e			;                                                                             : 
8f6e			; Returns                                                                     : 
8f6e			;     HL  Address of the first useable byte of the allocation                 : 
8f6e			;                                                                             : 
8f6e			; Flags                                                                       : 
8f6e			;     Z   Set if the allocation did not succeed, clear otherwise              : 
8f6e			;                                                                             : 
8f6e			; Stack frame                                                                 : 
8f6e			;       |             |                                                       : 
8f6e			;       +-------------+                                                       : 
8f6e			;       |     BC      |                                                       : 
8f6e			;       +-------------+                                                       : 
8f6e			;       |     DE      |                                                       : 
8f6e			;       +-------------+                                                       : 
8f6e			;       |     IX      |                                                       : 
8f6e			;       +-------------+                                                       : 
8f6e			;       |  prev_free  |                                                       : 
8f6e			;   +4  +-------------+                                                       : 
8f6e			;       |  this_free  |                                                       : 
8f6e			;   +2  +-------------+                                                       : 
8f6e			;       |  next_free  |                                                       : 
8f6e			;   +0  +-------------+                                                       : 
8f6e			;       |             |                                                       : 
8f6e			;                                                                             : 
8f6e			;------------------------------------------------------------------------------ 
8f6e			 
8f6e			 
8f6e			;malloc: 
8f6e			; 
8f6e			;	SAVESP ON 1 
8f6e			; 
8f6e			;	call malloc_code 
8f6e			; 
8f6e			;	CHECKSP ON 1 
8f6e			;	ret 
8f6e			 
8f6e			 
8f6e			malloc: 
8f6e c5			      push  BC 
8f6f d5			      push  DE 
8f70 dd e5		      push  IX 
8f72			if DEBUG_FORTH_MALLOC_HIGH 
8f72			call malloc_guard_entry 
8f72			endif 
8f72			 
8f72					if DEBUG_FORTH_MALLOC 
8f72						DMARK "mal" 
8f72						CALLMONITOR 
8f72					endif 
8f72 7c			      ld    A, H                    ; Exit if no space requested 
8f73 b5			      or    L 
8f74 ca 33 90		      jp    Z, malloc_early_exit 
8f77			 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			; 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			;inc hl 
8f77			 
8f77			 
8f77			 
8f77			 
8f77					if DEBUG_FORTH_MALLOC 
8f77						DMARK "maA" 
8f77						CALLMONITOR 
8f77					endif 
8f77			      ; Set up stack frame 
8f77 eb			      ex    DE, HL 
8f78 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
8f7b 39			      add   HL, SP 
8f7c f9			      ld    SP, HL 
8f7d dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
8f81 dd 39		      add   IX, SP 
8f83			 
8f83			      ; Setup initial state 
8f83 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
8f86 19			      add   HL, DE 
8f87			 
8f87 44			      ld    B, H                    ; Move want to BC 
8f88 4d			      ld    C, L 
8f89			 
8f89 21 8d d8		      ld    HL, free_list           ; Store prev_free ptr to stack 
8f8c dd 75 04		      ld    (IX+4), L 
8f8f dd 74 05		      ld    (IX+5), H 
8f92			 
8f92 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
8f93 23			      inc   HL 
8f94 56			      ld    D, (HL) 
8f95 dd 73 02		      ld    (IX+2), E 
8f98 dd 72 03		      ld    (IX+3), D 
8f9b eb			      ex    DE, HL                  ; this_free ptr into HL 
8f9c			 
8f9c					if DEBUG_FORTH_MALLOC 
8f9c						DMARK "maB" 
8f9c						CALLMONITOR 
8f9c					endif 
8f9c			      ; Loop through free block list to find some space 
8f9c			malloc_find_space: 
8f9c 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
8f9d 23			      inc   HL 
8f9e 56			      ld    D, (HL) 
8f9f			 
8f9f 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
8fa0 b3			      or    E 
8fa1 ca 2d 90		      jp    Z, malloc_no_space 
8fa4			 
8fa4 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
8fa7 dd 72 01		      ld    (IX+1), D 
8faa			 
8faa			      ; Does this block have enough space to make the allocation? 
8faa 23			      inc   HL                      ; Load free block size into DE 
8fab 5e			      ld    E, (HL) 
8fac 23			      inc   HL 
8fad 56			      ld    D, (HL) 
8fae			 
8fae eb			      ex    DE, HL                  ; Check size of block against want 
8faf b7			      or    A                       ; Ensure carry flag clear 
8fb0 ed 42		      sbc   HL, BC 
8fb2 e5			      push  HL                      ; Store the result for later (new block size) 
8fb3			 
8fb3 ca 02 90		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
8fb6 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
8fb8			 
8fb8			      ; this_free block is not big enough, setup ptrs to test next free block 
8fb8 e1			      pop   HL                      ; Discard previous result 
8fb9			 
8fb9 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
8fbc dd 66 03		      ld    H, (IX+3) 
8fbf dd 75 04		      ld    (IX+4), L 
8fc2 dd 74 05		      ld    (IX+5), H 
8fc5			 
8fc5 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
8fc8 dd 66 01		      ld    H, (IX+1) 
8fcb dd 75 02		      ld    (IX+2), L 
8fce dd 74 03		      ld    (IX+3), H 
8fd1			 
8fd1					if DEBUG_FORTH_MALLOC 
8fd1						DMARK "MA>" 
8fd1						CALLMONITOR 
8fd1					endif 
8fd1 18 c9		      jr    malloc_find_space 
8fd3			 
8fd3			      ; split a bigger block into two - requested size and remaining size 
8fd3			malloc_alloc_split: 
8fd3					if DEBUG_FORTH_MALLOC 
8fd3						DMARK "MAs" 
8fd3						CALLMONITOR 
8fd3					endif 
8fd3 eb			      ex    DE, HL                  ; Calculate address of new free block 
8fd4 2b			      dec   HL 
8fd5 2b			      dec   HL 
8fd6 2b			      dec   HL 
8fd7 09			      add   HL, BC 
8fd8			 
8fd8			      ; Create a new block and point it at next_free 
8fd8 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
8fdb dd 56 01		      ld    D, (IX+1) 
8fde			 
8fde 73			      ld    (HL), E                 ; Store next_free ptr into new block 
8fdf 23			      inc   HL 
8fe0 72			      ld    (HL), D 
8fe1			 
8fe1 d1			      pop   DE                      ; Store size of new block into new block 
8fe2 23			      inc   HL 
8fe3 73			      ld    (HL), E 
8fe4 23			      inc   HL 
8fe5 72			      ld    (HL), D 
8fe6			 
8fe6			      ; Update this_free ptr to point to new block 
8fe6 2b			      dec   HL 
8fe7 2b			      dec   HL 
8fe8 2b			      dec   HL 
8fe9			 
8fe9 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
8fec dd 56 03		      ld    D, (IX+3) 
8fef			 
8fef dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
8ff2 dd 74 03		      ld    (IX+3), H 
8ff5			 
8ff5			      ; Modify this_free block to be allocation 
8ff5 eb			      ex    DE, HL 
8ff6 af			      xor   A                       ; Null the next block ptr of allocated block 
8ff7 77			      ld    (HL), A 
8ff8 23			      inc   HL 
8ff9 77			      ld    (HL), A 
8ffa			 
8ffa 23			      inc   HL                      ; Store want size into allocated block 
8ffb 71			      ld    (HL), C 
8ffc 23			      inc   HL 
8ffd 70			      ld    (HL), B 
8ffe 23			      inc   HL 
8fff e5			      push  HL                      ; Address of allocation to return 
9000			 
9000 18 19		      jr    malloc_update_links 
9002			 
9002			malloc_alloc_fit: 
9002 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9003			 
9003					if DEBUG_FORTH_MALLOC 
9003						DMARK "MAf" 
9003						CALLMONITOR 
9003					endif 
9003			      ; Modify this_free block to be allocation 
9003 eb			      ex    DE, HL 
9004 2b			      dec   HL 
9005 2b			      dec   HL 
9006 2b			      dec   HL 
9007			 
9007 af			      xor   A                       ; Null the next block ptr of allocated block 
9008 77			      ld    (HL), A 
9009 23			      inc   HL 
900a 77			      ld    (HL), A 
900b			 
900b 23			      inc   HL                      ; Store address of allocation to return 
900c 23			      inc   HL 
900d 23			      inc   HL 
900e e5			      push  HL 
900f			 
900f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
900f dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9012 dd 66 01		      ld    H, (IX+1) 
9015			 
9015 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
9018 dd 74 03		      ld    (IX+3), H 
901b			 
901b			 
901b			malloc_update_links: 
901b			      ; Update prev_free ptr to point to this_free 
901b dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
901e dd 66 05		      ld    H, (IX+5) 
9021			 
9021 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9024 dd 56 03		      ld    D, (IX+3) 
9027			 
9027 73			      ld    (HL), E                 ; this_free ptr into prev_free 
9028 23			      inc   HL 
9029 72			      ld    (HL), D 
902a			 
902a					if DEBUG_FORTH_MALLOC 
902a						DMARK "Mul" 
902a						CALLMONITOR 
902a					endif 
902a			      ; Clear the Z flag to indicate successful allocation 
902a 7a			      ld    A, D 
902b b3			      or    E 
902c			 
902c d1			      pop   DE                      ; Address of allocation 
902d					if DEBUG_FORTH_MALLOC 
902d						DMARK "MAu" 
902d						CALLMONITOR 
902d					endif 
902d			 
902d			malloc_no_space: 
902d 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9030 39			      add   HL, SP 
9031 f9			      ld    SP, HL 
9032			 
9032 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9033					if DEBUG_FORTH_MALLOC 
9033						DMARK "MAN" 
9033						CALLMONITOR 
9033					endif 
9033			 
9033			malloc_early_exit: 
9033					if DEBUG_FORTH_MALLOC 
9033						DMARK "MAx" 
9033						CALLMONITOR 
9033					endif 
9033 dd e1		      pop   IX 
9035 d1			      pop   DE 
9036 c1			      pop   BC 
9037			 
9037			if DEBUG_FORTH_MALLOC_HIGH 
9037			call malloc_guard_exit 
9037			call malloc_guard_zerolen 
9037			endif 
9037 c9			      ret 
9038			 
9038			 
9038			;------------------------------------------------------------------------------ 
9038			;     free                                                                    : 
9038			;                                                                             : 
9038			; Description                                                                 : 
9038			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9038			;     returned by malloc, otherwise the behaviour is undefined.               : 
9038			;                                                                             : 
9038			;     Where possible, directly adjacent free blocks will be merged together   : 
9038			;     into larger blocks to help ensure that the heap does not become         : 
9038			;     excessively fragmented.                                                 : 
9038			;                                                                             : 
9038			;     free does not clear or set any other value into the freed space, and    : 
9038			;     therefore its contents may be visible through subsequent malloc's. The  : 
9038			;     caller should clear the freed space as required.                        : 
9038			;                                                                             : 
9038			;     This implementation of free uses the stack exclusively, and is          : 
9038			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9038			;     advisable to disable interrupts before calling free, and recommended    : 
9038			;     to avoid the use of free inside ISRs in general.                        : 
9038			;                                                                             : 
9038			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9038			;                                                                             : 
9038			; Parameters                                                                  : 
9038			;     HL  Pointer to address of first byte of allocation to be freed          : 
9038			;                                                                             : 
9038			; Returns                                                                     : 
9038			;     Nothing                                                                 : 
9038			;                                                                             : 
9038			; Stack frame                                                                 : 
9038			;       |             |                                                       : 
9038			;       +-------------+                                                       : 
9038			;       |     BC      |                                                       : 
9038			;       +-------------+                                                       : 
9038			;       |     DE      |                                                       : 
9038			;       +-------------+                                                       : 
9038			;       |     IX      |                                                       : 
9038			;       +-------------+                                                       : 
9038			;       |  prev_free  |                                                       : 
9038			;   +2  +-------------+                                                       : 
9038			;       |  next_free  |                                                       : 
9038			;   +0  +-------------+                                                       : 
9038			;       |             |                                                       : 
9038			;                                                                             : 
9038			;------------------------------------------------------------------------------ 
9038			free: 
9038 c5			      push  BC 
9039 d5			      push  DE 
903a dd e5		      push  IX 
903c			 
903c 7c			      ld    A, H                    ; Exit if ptr is null 
903d b5			      or    L 
903e ca 02 91		      jp    Z, free_early_exit 
9041			 
9041			      ; Set up stack frame 
9041 eb			      ex    DE, HL 
9042 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9045 39			      add   HL, SP 
9046 f9			      ld    SP, HL 
9047 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
904b dd 39		      add   IX, SP 
904d			 
904d			      ; The address in HL points to the start of the useable allocated space, 
904d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
904d			      ; address of the block itself. 
904d eb			      ex    DE, HL 
904e 11 fc ff		      ld    DE, -4 
9051 19			      add   HL, DE 
9052			 
9052			      ; An allocated block must have a null next block pointer in it 
9052 7e			      ld    A, (HL) 
9053 23			      inc   HL 
9054 b6			      or    (HL) 
9055 c2 fd 90		      jp    NZ, free_done 
9058			 
9058 2b			      dec   HL 
9059			 
9059 44			      ld    B, H                    ; Copy HL to BC 
905a 4d			      ld    C, L 
905b			 
905b			      ; Loop through the free list to find the first block with an address 
905b			      ; higher than the block being freed 
905b 21 8d d8		      ld    HL, free_list 
905e			 
905e			free_find_higher_block: 
905e 5e			      ld    E, (HL)                 ; Load next ptr from free block 
905f 23			      inc   HL 
9060 56			      ld    D, (HL) 
9061 2b			      dec   HL 
9062			 
9062 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9065 dd 72 01		      ld    (IX+1), D 
9068 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
906b dd 74 03		      ld    (IX+3), H 
906e			 
906e 78			      ld    A, B                    ; Check if DE is greater than BC 
906f ba			      cp    D                       ; Compare MSB first 
9070 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
9072 30 04		      jr    NC, free_find_higher_block_skip 
9074 79			      ld    A, C 
9075 bb			      cp    E                       ; Then compare LSB 
9076 38 08		      jr    C, free_found_higher_block 
9078			 
9078			free_find_higher_block_skip: 
9078 7a			      ld    A, D                    ; Reached the end of the free list? 
9079 b3			      or    E 
907a ca fd 90		      jp    Z, free_done 
907d			 
907d eb			      ex    DE, HL 
907e			 
907e 18 de		      jr    free_find_higher_block 
9080			 
9080			free_found_higher_block: 
9080			      ; Insert freed block between prev and next free blocks 
9080 71			      ld    (HL), C                 ; Point prev free block to freed block 
9081 23			      inc   HL 
9082 70			      ld    (HL), B 
9083			 
9083 60			      ld    H, B                    ; Point freed block at next free block 
9084 69			      ld    L, C 
9085 73			      ld    (HL), E 
9086 23			      inc   HL 
9087 72			      ld    (HL), D 
9088			 
9088			      ; Check if the freed block is adjacent to the next free block 
9088 23			      inc   HL                      ; Load size of freed block into HL 
9089 5e			      ld    E, (HL) 
908a 23			      inc   HL 
908b 56			      ld    D, (HL) 
908c eb			      ex    DE, HL 
908d			 
908d 09			      add   HL, BC                  ; Add addr of freed block and its size 
908e			 
908e dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
9091 dd 56 01		      ld    D, (IX+1) 
9094			 
9094 b7			      or    A                       ; Clear the carry flag 
9095 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9097 20 22		      jr    NZ, free_check_adjacent_to_prev 
9099			 
9099			      ; Freed block is adjacent to next, merge into one bigger block 
9099 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
909a 5e			      ld    E, (HL) 
909b 23			      inc   HL 
909c 56			      ld    D, (HL) 
909d e5			      push  HL                      ; Save ptr to next block for later 
909e			 
909e 60			      ld    H, B                    ; Store ptr from next block into freed block 
909f 69			      ld    L, C 
90a0 73			      ld    (HL), E 
90a1 23			      inc   HL 
90a2 72			      ld    (HL), D 
90a3			 
90a3 e1			      pop   HL                      ; Restore ptr to next block 
90a4 23			      inc   HL                      ; Load size of next block into DE 
90a5 5e			      ld    E, (HL) 
90a6 23			      inc   HL 
90a7 56			      ld    D, (HL) 
90a8 d5			      push  DE                      ; Save next block size for later 
90a9			 
90a9 60			      ld    H, B                    ; Load size of freed block into HL 
90aa 69			      ld    L, C 
90ab 23			      inc   HL 
90ac 23			      inc   HL 
90ad 5e			      ld    E, (HL) 
90ae 23			      inc   HL 
90af 56			      ld    D, (HL) 
90b0 eb			      ex    DE, HL 
90b1			 
90b1 d1			      pop   DE                      ; Restore size of next block 
90b2 19			      add   HL, DE                  ; Add sizes of both blocks 
90b3 eb			      ex    DE, HL 
90b4			 
90b4 60			      ld    H, B                    ; Store new bigger size into freed block 
90b5 69			      ld    L, C 
90b6 23			      inc   HL 
90b7 23			      inc   HL 
90b8 73			      ld    (HL), E 
90b9 23			      inc   HL 
90ba 72			      ld    (HL), D 
90bb			 
90bb			free_check_adjacent_to_prev: 
90bb			      ; Check if the freed block is adjacent to the prev free block 
90bb dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
90be dd 66 03		      ld    H, (IX+3) 
90c1			 
90c1 23			      inc   HL                      ; Size of prev free block into DE 
90c2 23			      inc   HL 
90c3 5e			      ld    E, (HL) 
90c4 23			      inc   HL 
90c5 56			      ld    D, (HL) 
90c6 2b			      dec   HL 
90c7 2b			      dec   HL 
90c8 2b			      dec   HL 
90c9			 
90c9 19			      add   HL, DE                  ; Add prev block addr and size 
90ca			 
90ca b7			      or    A                       ; Clear the carry flag 
90cb ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
90cd 20 2e		      jr    NZ, free_done 
90cf			 
90cf			      ; Freed block is adjacent to prev, merge into one bigger block 
90cf 60			      ld    H, B                    ; Load next ptr from freed block into DE 
90d0 69			      ld    L, C 
90d1 5e			      ld    E, (HL) 
90d2 23			      inc   HL 
90d3 56			      ld    D, (HL) 
90d4 e5			      push  HL                      ; Save freed block ptr for later 
90d5			 
90d5 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
90d8 dd 66 03		      ld    H, (IX+3) 
90db 73			      ld    (HL), E 
90dc 23			      inc   HL 
90dd 72			      ld    (HL), D 
90de			 
90de e1			      pop   HL                      ; Restore freed block ptr 
90df 23			      inc   HL                      ; Load size of freed block into DE 
90e0 5e			      ld    E, (HL) 
90e1 23			      inc   HL 
90e2 56			      ld    D, (HL) 
90e3 d5			      push  DE                      ; Save freed block size for later 
90e4			 
90e4 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
90e7 dd 66 03		      ld    H, (IX+3) 
90ea 23			      inc   HL 
90eb 23			      inc   HL 
90ec 5e			      ld    E, (HL) 
90ed 23			      inc   HL 
90ee 56			      ld    D, (HL) 
90ef			 
90ef e1			      pop   HL                      ; Add sizes of both blocks 
90f0 19			      add   HL, DE 
90f1 eb			      ex    DE, HL 
90f2			 
90f2 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
90f5 dd 66 03		      ld    H, (IX+3) 
90f8 23			      inc   HL 
90f9 23			      inc   HL 
90fa 73			      ld    (HL), E 
90fb 23			      inc   HL 
90fc 72			      ld    (HL), D 
90fd			 
90fd			free_done: 
90fd 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9100 39			      add   HL, SP 
9101 f9			      ld    SP, HL 
9102			 
9102			free_early_exit: 
9102 dd e1		      pop   IX 
9104 d1			      pop   DE 
9105 c1			      pop   BC 
9106			 
9106 c9			      ret 
9107			 
9107			; moved to firmware.asm 
9107			; 
9107			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9107			;                  .dw   0 
9107			 
9107			 
9107			endif 
9107			 
9107			 
9107			if MALLOC_3 
9107			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
9107			;heap_start        .equ  0x9000      ; Starting address of heap 
9107			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
9107			; 
9107			 ;     .org 0 
9107			  ;    jp    main 
9107			; 
9107			; 
9107			 ;     .org  0x100 
9107			;main: 
9107			 ;     ld    HL, 0x8100 
9107			  ;    ld    SP, HL 
9107			; 
9107			;      call  heap_init 
9107			 
9107			      ; Make some allocations 
9107			;      ld    HL, 12 
9107			;      call  malloc            ; Allocates 0x9004 
9107			; 
9107			 ;     ld    HL, 12 
9107			;      call  malloc            ; Allocates 0x9014 
9107			 
9107			;      ld    HL, 12 
9107			;      call  malloc            ; Allocates 0x9024 
9107			 
9107			      ; Free some allocations 
9107			;      ld    HL, 0x9014 
9107			;      call  free 
9107			 
9107			;      ld    HL, 0x9004 
9107			;      call  free 
9107			; 
9107			;      ld    HL, 0x9024 
9107			;      call  free 
9107			 
9107			 
9107			 ;     halt 
9107			 
9107			 
9107			;------------------------------------------------------------------------------ 
9107			;     heap_init                                                               : 
9107			;                                                                             : 
9107			; Description                                                                 : 
9107			;     Initialise the heap and make it ready for malloc and free operations.   : 
9107			;                                                                             : 
9107			;     The heap is maintained as a linked list, starting with an initial       : 
9107			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
9107			;     the first free block in the heap. Each block then points to the next    : 
9107			;     free block within the heap, and the free list ends at the first block   : 
9107			;     with a null pointer to the next free block.                             : 
9107			;                                                                             : 
9107			; Parameters                                                                  : 
9107			;     Inputs are compile-time only. Two defines which specify the starting    : 
9107			;     address of the heap and its size are required, along with a memory      : 
9107			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
9107			;     principally stores a pointer to the first free block in the heap.       : 
9107			;                                                                             : 
9107			; Returns                                                                     : 
9107			;     Nothing                                                                 : 
9107			;------------------------------------------------------------------------------ 
9107			heap_init: 
9107			      push  HL 
9107			 
9107			      ; Initialise free list struct 
9107			      ld    HL, heap_start 
9107			      ld    (free_list), HL 
9107			      ld    HL, 0 
9107			      ld    (free_list+2), HL 
9107			 
9107			      ; Insert first free block at bottom of heap, consumes entire heap 
9107			      ld    HL, heap_start+heap_size-4 
9107			      ld    (heap_start), HL        ; Next block (end of free list) 
9107			      ld    HL, heap_size-4 
9107			      ld    (heap_start+2), HL      ; Block size 
9107			 
9107			      ; Insert end of free list block at top of heap - two null words will 
9107			      ; terminate the free list 
9107			      ld    HL, 0 
9107			      ld    (heap_start+heap_size-2), HL 
9107			      ld    (heap_start+heap_size-4), HL 
9107			 
9107			      pop   HL 
9107			 
9107			      ret 
9107			 
9107			 
9107			;------------------------------------------------------------------------------ 
9107			;     malloc                                                                  : 
9107			;                                                                             : 
9107			; Description                                                                 : 
9107			;     Allocates the wanted space from the heap and returns the address of the : 
9107			;     first useable byte of the allocation.                                   : 
9107			;                                                                             : 
9107			;     Allocations can happen in one of two ways:                              : 
9107			;                                                                             : 
9107			;     1. A free block may be found which is the exact size wanted. In this    : 
9107			;        case the block is removed from the free list and retuedn to the      : 
9107			;        caller.                                                              : 
9107			;     2. A free block may be found which is larger than the size wanted. In   : 
9107			;        this case, the larger block is split into two. The first portion of  : 
9107			;        this block will become the requested space by the malloc call and    : 
9107			;        is returned to the caller. The second portion becomes a new free     : 
9107			;        block, and the free list is adjusted to maintain continuity via this : 
9107			;        newly created block.                                                 : 
9107			;                                                                             : 
9107			;     malloc does not set any initial value in the allocated space, the       : 
9107			;     caller is required to do this as required.                              : 
9107			;                                                                             : 
9107			;     This implementation of malloc uses the stack exclusively, and is        : 
9107			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9107			;     advisable to disable interrupts before calling malloc, and recommended  : 
9107			;     to avoid the use of malloc inside ISRs in general.                      : 
9107			;                                                                             : 
9107			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9107			;                                                                             : 
9107			; Parameters                                                                  : 
9107			;     HL  Number of bytes wanted                                              : 
9107			;                                                                             : 
9107			; Returns                                                                     : 
9107			;     HL  Address of the first useable byte of the allocation                 : 
9107			;                                                                             : 
9107			; Flags                                                                       : 
9107			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9107			;                                                                             : 
9107			; Stack frame                                                                 : 
9107			;       |             |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     BC      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     DE      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     IX      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |  prev_free  |                                                       : 
9107			;   +4  +-------------+                                                       : 
9107			;       |  this_free  |                                                       : 
9107			;   +2  +-------------+                                                       : 
9107			;       |  next_free  |                                                       : 
9107			;   +0  +-------------+                                                       : 
9107			;       |             |                                                       : 
9107			;                                                                             : 
9107			;------------------------------------------------------------------------------ 
9107			malloc: 
9107			      push  BC 
9107			      push  DE 
9107			      push  IX 
9107			 
9107			      ld    A, H                    ; Exit if no space requested 
9107			      or    L 
9107			      jp    Z, malloc_early_exit 
9107			 
9107			      ; Set up stack frame 
9107			      ex    DE, HL 
9107			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9107			      add   HL, SP 
9107			      ld    SP, HL 
9107			      ld    IX, 0                   ; Use IX as a frame pointer 
9107			      add   IX, SP 
9107			 
9107			      ; Setup initial state 
9107			      ld    HL, 4                   ; want must also include space used by block struct 
9107			      add   HL, DE 
9107			 
9107			      ld    B, H                    ; Move want to BC 
9107			      ld    C, L 
9107			 
9107			      ld    HL, free_list           ; Store prev_free ptr to stack 
9107			      ld    (IX+4), L 
9107			      ld    (IX+5), H 
9107			 
9107			      ld    E, (HL)                 ; Store this_free ptr to stack 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      ld    (IX+2), E 
9107			      ld    (IX+3), D 
9107			      ex    DE, HL                  ; this_free ptr into HL 
9107			 
9107			      ; Loop through free block list to find some space 
9107			malloc_find_space: 
9107			      ld    E, (HL)                 ; Load next_free ptr into DE 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			 
9107			      ld    A, D                    ; Check for null next_free ptr - end of free list 
9107			      or    E 
9107			      jp    Z, malloc_no_space 
9107			 
9107			      ld    (IX+0), E               ; Store next_free ptr to stack 
9107			      ld    (IX+1), D 
9107			 
9107			      ; Does this block have enough space to make the allocation? 
9107			      inc   HL                      ; Load free block size into DE 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			 
9107			      ex    DE, HL                  ; Check size of block against want 
9107			      or    A                       ; Ensure carry flag clear 
9107			      sbc   HL, BC 
9107			      push  HL                      ; Store the result for later (new block size) 
9107			 
9107			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
9107			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
9107			 
9107			      ; this_free block is not big enough, setup ptrs to test next free block 
9107			      pop   HL                      ; Discard previous result 
9107			 
9107			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
9107			      ld    H, (IX+3) 
9107			      ld    (IX+4), L 
9107			      ld    (IX+5), H 
9107			 
9107			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
9107			      ld    H, (IX+1) 
9107			      ld    (IX+2), L 
9107			      ld    (IX+3), H 
9107			 
9107			      jr    malloc_find_space 
9107			 
9107			      ; split a bigger block into two - requested size and remaining size 
9107			malloc_alloc_split: 
9107			      ex    DE, HL                  ; Calculate address of new free block 
9107			      dec   HL 
9107			      dec   HL 
9107			      dec   HL 
9107			      add   HL, BC 
9107			 
9107			      ; Create a new block and point it at next_free 
9107			      ld    E, (IX+0)               ; Load next_free ptr into DE 
9107			      ld    D, (IX+1) 
9107			 
9107			      ld    (HL), E                 ; Store next_free ptr into new block 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			      pop   DE                      ; Store size of new block into new block 
9107			      inc   HL 
9107			      ld    (HL), E 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			      ; Update this_free ptr to point to new block 
9107			      dec   HL 
9107			      dec   HL 
9107			      dec   HL 
9107			 
9107			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9107			      ld    D, (IX+3) 
9107			 
9107			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9107			      ld    (IX+3), H 
9107			 
9107			      ; Modify this_free block to be allocation 
9107			      ex    DE, HL 
9107			      xor   A                       ; Null the next block ptr of allocated block 
9107			      ld    (HL), A 
9107			      inc   HL 
9107			      ld    (HL), A 
9107			 
9107			      inc   HL                      ; Store want size into allocated block 
9107			      ld    (HL), C 
9107			      inc   HL 
9107			      ld    (HL), B 
9107			      inc   HL 
9107			      push  HL                      ; Address of allocation to return 
9107			 
9107			      jr    malloc_update_links 
9107			 
9107			malloc_alloc_fit: 
9107			      pop   HL                      ; Dont need new block size, want is exact fit 
9107			 
9107			      ; Modify this_free block to be allocation 
9107			      ex    DE, HL 
9107			      dec   HL 
9107			      dec   HL 
9107			      dec   HL 
9107			 
9107			      xor   A                       ; Null the next block ptr of allocated block 
9107			      ld    (HL), A 
9107			      inc   HL 
9107			      ld    (HL), A 
9107			 
9107			      inc   HL                      ; Store address of allocation to return 
9107			      inc   HL 
9107			      inc   HL 
9107			      push  HL 
9107			 
9107			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9107			      ld    L, (IX+0)               ; next_free to HL 
9107			      ld    H, (IX+1) 
9107			 
9107			      ld    (IX+2), L               ; HL to this_free 
9107			      ld    (IX+3), H 
9107			 
9107			 
9107			malloc_update_links: 
9107			      ; Update prev_free ptr to point to this_free 
9107			      ld    L, (IX+4)               ; prev_free ptr to HL 
9107			      ld    H, (IX+5) 
9107			 
9107			      ld    E, (IX+2)               ; this_free ptr to DE 
9107			      ld    D, (IX+3) 
9107			 
9107			      ld    (HL), E                 ; this_free ptr into prev_free 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			      ; Clear the Z flag to indicate successful allocation 
9107			      ld    A, D 
9107			      or    E 
9107			 
9107			      pop   DE                      ; Address of allocation 
9107			 
9107			malloc_no_space: 
9107			      ld    HL, 6                   ; Clean up stack frame 
9107			      add   HL, SP 
9107			      ld    SP, HL 
9107			 
9107			      ex    DE, HL                  ; Alloc addr into HL for return 
9107			 
9107			malloc_early_exit: 
9107			      pop   IX 
9107			      pop   DE 
9107			      pop   BC 
9107			 
9107			      ret 
9107			 
9107			 
9107			;------------------------------------------------------------------------------ 
9107			;     free                                                                    : 
9107			;                                                                             : 
9107			; Description                                                                 : 
9107			;     Return the space pointed to by HL to the heap. HL must be an address as : 
9107			;     returned by malloc, otherwise the behaviour is undefined.               : 
9107			;                                                                             : 
9107			;     Where possible, directly adjacent free blocks will be merged together   : 
9107			;     into larger blocks to help ensure that the heap does not become         : 
9107			;     excessively fragmented.                                                 : 
9107			;                                                                             : 
9107			;     free does not clear or set any other value into the freed space, and    : 
9107			;     therefore its contents may be visible through subsequent malloc's. The  : 
9107			;     caller should clear the freed space as required.                        : 
9107			;                                                                             : 
9107			;     This implementation of free uses the stack exclusively, and is          : 
9107			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9107			;     advisable to disable interrupts before calling free, and recommended    : 
9107			;     to avoid the use of free inside ISRs in general.                        : 
9107			;                                                                             : 
9107			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9107			;                                                                             : 
9107			; Parameters                                                                  : 
9107			;     HL  Pointer to address of first byte of allocation to be freed          : 
9107			;                                                                             : 
9107			; Returns                                                                     : 
9107			;     Nothing                                                                 : 
9107			;                                                                             : 
9107			; Stack frame                                                                 : 
9107			;       |             |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     BC      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     DE      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |     IX      |                                                       : 
9107			;       +-------------+                                                       : 
9107			;       |  prev_free  |                                                       : 
9107			;   +2  +-------------+                                                       : 
9107			;       |  next_free  |                                                       : 
9107			;   +0  +-------------+                                                       : 
9107			;       |             |                                                       : 
9107			;                                                                             : 
9107			;------------------------------------------------------------------------------ 
9107			free: 
9107			      push  BC 
9107			      push  DE 
9107			      push  IX 
9107			 
9107			      ld    A, H                    ; Exit if ptr is null 
9107			      or    L 
9107			      jp    Z, free_early_exit 
9107			 
9107			      ; Set up stack frame 
9107			      ex    DE, HL 
9107			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9107			      add   HL, SP 
9107			      ld    SP, HL 
9107			      ld    IX, 0                   ; Use IX as a frame pointer 
9107			      add   IX, SP 
9107			 
9107			      ; The address in HL points to the start of the useable allocated space, 
9107			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9107			      ; address of the block itself. 
9107			      ex    DE, HL 
9107			      ld    DE, -4 
9107			      add   HL, DE 
9107			 
9107			      ; An allocated block must have a null next block pointer in it 
9107			      ld    A, (HL) 
9107			      inc   HL 
9107			      or    (HL) 
9107			      jp    NZ, free_done 
9107			 
9107			      dec   HL 
9107			 
9107			      ld    B, H                    ; Copy HL to BC 
9107			      ld    C, L 
9107			 
9107			      ; Loop through the free list to find the first block with an address 
9107			      ; higher than the block being freed 
9107			      ld    HL, free_list 
9107			 
9107			free_find_higher_block: 
9107			      ld    E, (HL)                 ; Load next ptr from free block 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      dec   HL 
9107			 
9107			      ld    (IX+0), E               ; Save ptr to next free block 
9107			      ld    (IX+1), D 
9107			      ld    (IX+2), L               ; Save ptr to prev free block 
9107			      ld    (IX+3), H 
9107			 
9107			      ld    A, B                    ; Check if DE is greater than BC 
9107			      cp    D                       ; Compare MSB first 
9107			      jr    Z, $+4                  ; MSB the same, compare LSB 
9107			      jr    NC, free_find_higher_block_skip 
9107			      ld    A, C 
9107			      cp    E                       ; Then compare LSB 
9107			      jr    C, free_found_higher_block 
9107			 
9107			free_find_higher_block_skip: 
9107			      ld    A, D                    ; Reached the end of the free list? 
9107			      or    E 
9107			      jp    Z, free_done 
9107			 
9107			      ex    DE, HL 
9107			 
9107			      jr    free_find_higher_block 
9107			 
9107			free_found_higher_block: 
9107			      ; Insert freed block between prev and next free blocks 
9107			      ld    (HL), C                 ; Point prev free block to freed block 
9107			      inc   HL 
9107			      ld    (HL), B 
9107			 
9107			      ld    H, B                    ; Point freed block at next free block 
9107			      ld    L, C 
9107			      ld    (HL), E 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			      ; Check if the freed block is adjacent to the next free block 
9107			      inc   HL                      ; Load size of freed block into HL 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      ex    DE, HL 
9107			 
9107			      add   HL, BC                  ; Add addr of freed block and its size 
9107			 
9107			      ld    E, (IX+0)               ; Load addr of next free block into DE 
9107			      ld    D, (IX+1) 
9107			 
9107			      or    A                       ; Clear the carry flag 
9107			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
9107			      jr    NZ, free_check_adjacent_to_prev 
9107			 
9107			      ; Freed block is adjacent to next, merge into one bigger block 
9107			      ex    DE, HL                  ; Load next ptr from next block into DE 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      push  HL                      ; Save ptr to next block for later 
9107			 
9107			      ld    H, B                    ; Store ptr from next block into freed block 
9107			      ld    L, C 
9107			      ld    (HL), E 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			      pop   HL                      ; Restore ptr to next block 
9107			      inc   HL                      ; Load size of next block into DE 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      push  DE                      ; Save next block size for later 
9107			 
9107			      ld    H, B                    ; Load size of freed block into HL 
9107			      ld    L, C 
9107			      inc   HL 
9107			      inc   HL 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      ex    DE, HL 
9107			 
9107			      pop   DE                      ; Restore size of next block 
9107			      add   HL, DE                  ; Add sizes of both blocks 
9107			      ex    DE, HL 
9107			 
9107			      ld    H, B                    ; Store new bigger size into freed block 
9107			      ld    L, C 
9107			      inc   HL 
9107			      inc   HL 
9107			      ld    (HL), E 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			free_check_adjacent_to_prev: 
9107			      ; Check if the freed block is adjacent to the prev free block 
9107			      ld    L, (IX+2)               ; Prev free block ptr into HL 
9107			      ld    H, (IX+3) 
9107			 
9107			      inc   HL                      ; Size of prev free block into DE 
9107			      inc   HL 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      dec   HL 
9107			      dec   HL 
9107			      dec   HL 
9107			 
9107			      add   HL, DE                  ; Add prev block addr and size 
9107			 
9107			      or    A                       ; Clear the carry flag 
9107			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
9107			      jr    NZ, free_done 
9107			 
9107			      ; Freed block is adjacent to prev, merge into one bigger block 
9107			      ld    H, B                    ; Load next ptr from freed block into DE 
9107			      ld    L, C 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      push  HL                      ; Save freed block ptr for later 
9107			 
9107			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
9107			      ld    H, (IX+3) 
9107			      ld    (HL), E 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			      pop   HL                      ; Restore freed block ptr 
9107			      inc   HL                      ; Load size of freed block into DE 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			      push  DE                      ; Save freed block size for later 
9107			 
9107			      ld    L, (IX+2)               ; Load size of prev block into DE 
9107			      ld    H, (IX+3) 
9107			      inc   HL 
9107			      inc   HL 
9107			      ld    E, (HL) 
9107			      inc   HL 
9107			      ld    D, (HL) 
9107			 
9107			      pop   HL                      ; Add sizes of both blocks 
9107			      add   HL, DE 
9107			      ex    DE, HL 
9107			 
9107			      ld    L, (IX+2)               ; Store new bigger size into prev block 
9107			      ld    H, (IX+3) 
9107			      inc   HL 
9107			      inc   HL 
9107			      ld    (HL), E 
9107			      inc   HL 
9107			      ld    (HL), D 
9107			 
9107			free_done: 
9107			      ld    HL, 4                   ; Clean up stack frame 
9107			      add   HL, SP 
9107			      ld    SP, HL 
9107			 
9107			free_early_exit: 
9107			      pop   IX 
9107			      pop   DE 
9107			      pop   BC 
9107			 
9107			      ret 
9107			 
9107			 
9107			;      .org 0x8000 
9107			; 
9107			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
9107			 ;                 .dw   0 
9107			 
9107			endif 
9107			 
9107			 
9107			if MALLOC_4 
9107			 
9107			; My memory allocation code. Very very simple.... 
9107			; allocate space under 250 chars 
9107			 
9107			heap_init: 
9107				; init start of heap as zero 
9107				;  
9107			 
9107				ld hl, heap_start 
9107				ld a, 0 
9107				ld (hl), a      ; empty block 
9107				inc hl 
9107				ld a, 0 
9107				ld (hl), a      ; length of block 
9107				; write end of list 
9107				inc hl 
9107				ld a,(hl) 
9107				inc hl 
9107				ld a,(hl) 
9107				 
9107			 
9107				; init some malloc vars 
9107			 
9107				ld hl, 0 
9107				ld (free_list), hl       ; store last malloc location 
9107			 
9107				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
9107				ld a, 0 
9107				ld (hl), a 
9107			 
9107			 
9107				ld hl, heap_start 
9107				;  
9107				  
9107				ret 
9107			 
9107			 
9107			;    free block marker 
9107			;    requested size  
9107			;    pointer to next block 
9107			;    .... 
9107			;    next block marker 
9107			 
9107			 
9107			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
9107			; 
9107			 
9107			 
9107			malloc:  
9107				push de 
9107				push bc 
9107				push af 
9107			 
9107				; hl space required 
9107				 
9107				ld c, l    ; hold space   (TODO only a max of 255) 
9107			 
9107			;	inc c     ; TODO BUG need to fix memory leak on push str 
9107			;	inc c 
9107			;	inc c 
9107			;	inc c 
9107			;	inc c 
9107			;	inc c 
9107			;	inc c 
9107			 
9107			 
9107			 
9107				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
9107			 
9107				ld a, (free_list+3) 
9107				cp 0 
9107				jr z, .contheap 
9107			 
9107				ld hl, (free_list)     ; get last alloc 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "mrs" 
9107						CALLMONITOR 
9107					endif 
9107				jr .startalloc 
9107			 
9107			.contheap: 
9107				ld hl, heap_start 
9107			 
9107			.startalloc: 
9107			 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "mym" 
9107						CALLMONITOR 
9107					endif 
9107			.findblock: 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "mmf" 
9107						CALLMONITOR 
9107					endif 
9107			 
9107				ld a,(hl)  
9107				; if byte is zero then clear to use 
9107			 
9107				cp 0 
9107				jr z, .foundemptyblock 
9107			 
9107				; if byte is not clear 
9107				;     then byte is offset to next block 
9107			 
9107				inc hl 
9107				ld a, (hl) ; get size 
9107			.nextblock:	inc hl 
9107					ld e, (hl) 
9107					inc hl 
9107					ld d, (hl) 
9107					ex de, hl 
9107			;	inc hl  ; move past the store space 
9107			;	inc hl  ; move past zero index  
9107			 
9107				; TODO detect no more space 
9107			 
9107				push hl 
9107				ld de, heap_end 
9107				call cmp16 
9107				pop hl 
9107				jr nc, .nospace 
9107			 
9107				jr .findblock 
9107			 
9107			.nospace: ld hl, 0 
9107				jp .exit 
9107			 
9107			 
9107			.foundemptyblock:	 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "mme" 
9107						CALLMONITOR 
9107					endif 
9107			 
9107			; TODO has block enough space if reusing??? 
9107			 
9107				;  
9107			 
9107			; see if this block has been previously used 
9107				inc hl 
9107				ld a, (hl) 
9107				dec hl 
9107				cp 0 
9107				jr z, .newblock 
9107			 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "meR" 
9107						CALLMONITOR 
9107					endif 
9107			 
9107			; no reusing previously allocated block 
9107			 
9107			; is it smaller than previously used? 
9107				 
9107				inc hl    ; move to size 
9107				ld a, c 
9107				sub (hl)        ; we want c < (hl) 
9107				dec hl    ; move back to marker 
9107			        jr z, .findblock 
9107			 
9107				; update with the new size which should be lower 
9107			 
9107			        ;inc  hl   ; negate next move. move back to size  
9107			 
9107			.newblock: 
9107				; need to be at marker here 
9107			 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "meN" 
9107						CALLMONITOR 
9107					endif 
9107			 
9107			 
9107				ld a, c 
9107			 
9107				ld (free_list+3), a	 ; flag resume from last malloc  
9107				ld (free_list), hl    ; save out last location 
9107			 
9107			 
9107				;inc a     ; space for length byte 
9107				ld (hl), a     ; save block in use marker 
9107			 
9107				inc hl   ; move to space marker 
9107				ld (hl), a    ; save new space 
9107			 
9107				inc hl   ; move to start of allocated area 
9107				 
9107			;	push hl     ; save where we are - 1  
9107			 
9107			;	inc hl  ; move past zero index  
9107				; skip space to set down new marker 
9107			 
9107				; provide some extra space for now 
9107			 
9107				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
9107				inc a 
9107				inc a 
9107			 
9107				push hl   ; save where we are in the node block 
9107			 
9107				call addatohl 
9107			 
9107				; write linked list point 
9107			 
9107				pop de     ; get our node position 
9107				ex de, hl 
9107			 
9107				ld (hl), e 
9107				inc hl 
9107				ld (hl), d 
9107			 
9107				inc hl 
9107			 
9107				; now at start of allocated data so save pointer 
9107			 
9107				push hl 
9107			 
9107				; jump to position of next node and setup empty header in DE 
9107			 
9107				ex de, hl 
9107			 
9107			;	inc hl ; move past end of block 
9107			 
9107				ld a, 0 
9107				ld (hl), a   ; empty marker 
9107				inc hl 
9107				ld (hl), a   ; size 
9107				inc hl  
9107				ld (hl), a   ; ptr 
9107				inc hl 
9107				ld (hl), a   ; ptr 
9107			 
9107			 
9107				pop hl 
9107			 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "mmr" 
9107						CALLMONITOR 
9107					endif 
9107			 
9107			.exit: 
9107				pop af 
9107				pop bc 
9107				pop de  
9107				ret 
9107			 
9107			 
9107			 
9107			 
9107			free:  
9107				push hl 
9107				push af 
9107				; get address in hl 
9107			 
9107					if DEBUG_FORTH_MALLOC_INT 
9107						DMARK "fre" 
9107						CALLMONITOR 
9107					endif 
9107				; data is at hl - move to block count 
9107				dec hl 
9107				dec hl    ; get past pointer 
9107				dec hl 
9107			 
9107				ld a, (hl)    ; need this for a validation check 
9107			 
9107				dec hl    ; move to block marker 
9107			 
9107				; now check that the block count and block marker are the same  
9107			        ; this checks that we are on a malloc node and not random memory 
9107			        ; OK a faint chance this could be a problem but rare - famous last words! 
9107			 
9107				ld c, a 
9107				ld a, (hl)    
9107			 
9107				cp c 
9107				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
9107			 
9107				; yes good chance we are on a malloc node 
9107			 
9107				ld a, 0      
9107				ld (hl), a   ; mark as free 
9107			 
9107				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
9107			 
9107			.freeignore:  
9107			 
9107				pop af 
9107				pop hl 
9107			 
9107				ret 
9107			 
9107			 
9107			 
9107			endif 
9107			 
9107			; eof 
# End of file firmware_memory.asm
9107			  
9107			; device C  
9107			if SOUND_ENABLE  
9107				include "firmware_sound.asm"  
9107			endif  
9107			  
9107			include "firmware_diags.asm"  
9107			; Hardware diags menu 
9107			 
9107			 
9107			config: 
9107			 
9107 3e 00			ld a, 0 
9109 21 32 91			ld hl, .configmn 
910c cd ab 88			call menu 
910f			 
910f fe 00			cp 0 
9111 c8				ret z 
9112			 
9112 fe 01			cp 1 
9114 cc c4 91			call z, .savetostore 
9117			 
9117 fe 02			cp 2 
9119 cc c2 91			call z, .selautoload 
911c fe 03			cp 3 
911e cc c3 91			call z, .selbank 
9121 fe 05			cp 5 
9123 cc c5 91			call z, .debug_tog 
9126 fe 06			cp 6 
9128 cc 0d 93			call z, .bpsgo 
912b fe 07			cp 7 
912d cc eb 91			call z, hardware_diags 
9130			 
9130 18 d5			jr config 
9132			 
9132			.configmn: 
9132 42 91			dw .c3 
9134 5e 91			dw .c2 
9136 73 91			dw .c2b 
9138 87 91			dw .c4 
913a 90 91			dw .m4 
913c ab 91			dw .m4b 
913e b3 91			dw .c1 
9140 00 00			dw 0 
9142				 
9142			 
9142 .. 00		.c3: db "Add User Dictionary To File",0 
915e .. 00		.c2: db "Select Autoload File",0 
9173 .. 00		.c2b: db "Select Storage Bank",0 
9187 .. 00		.c4: db "Settings",0 
9190 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
91ab .. 00		.m4b:   db "Monitor",0 
91b3 .. 00		.c1: db "Hardware Diags",0 
91c2			 
91c2			 
91c2			 
91c2			; Select auto start 
91c2			 
91c2			.selautoload: 
91c2			 
91c2				 
91c2				if STORAGE_SE 
91c2			 
91c2					call config_dir 
91c2				        ld hl, scratch 
91c2					ld a, 0 
91c2					call menu 
91c2			 
91c2					cp 0 
91c2					ret z 
91c2			 
91c2					dec a 
91c2			 
91c2			 
91c2					; locate menu option 
91c2			 
91c2					ld hl, scratch 
91c2					call table_lookup 
91c2			 
91c2					if DEBUG_FORTH_WORDS 
91c2						DMARK "ALl" 
91c2						CALLMONITOR 
91c2					endif 
91c2					; with the pointer to the menu it, the byte following the zero term is the file id 
91c2			 
91c2					ld a, 0 
91c2					ld bc, 50   ; max of bytes to look at 
91c2					cpir  
91c2			 
91c2					if DEBUG_FORTH_WORDS 
91c2						DMARK "ALb" 
91c2						CALLMONITOR 
91c2					endif 
91c2					;inc hl 
91c2			 
91c2					ld a, (hl)   ; file id 
91c2					 
91c2				        ; save bank and file ids 
91c2			 
91c2					push af 
91c2			 
91c2			; TODO need to save to block 0 on bank 1	 
91c2			 
91c2					call storage_get_block_0 
91c2			 
91c2					if DEBUG_FORTH_WORDS 
91c2						DMARK "AL0" 
91c2						CALLMONITOR 
91c2					endif 
91c2					pop af 
91c2			 
91c2					ld (store_page+STORE_0_FILERUN),a 
91c2					 
91c2					; save bank id 
91c2			 
91c2					ld a,(spi_device) 
91c2					ld (store_page+STORE_0_BANKRUN),a 
91c2			 
91c2					; enable auto run of store file 
91c2			 
91c2					ld a, 1 
91c2					ld (store_page+STORE_0_AUTOFILE),a 
91c2			 
91c2					; save buffer 
91c2			 
91c2					ld hl, 0 
91c2					ld de, store_page 
91c2					if DEBUG_FORTH_WORDS 
91c2						DMARK "ALw" 
91c2						CALLMONITOR 
91c2					endif 
91c2				call storage_write_block	 ; save update 
91c2			  
91c2			 
91c2			 
91c2			 
91c2					ld hl, scratch 
91c2					call config_fdir 
91c2			 
91c2			 
91c2				endif 
91c2 c9				ret 
91c3			 
91c3			 
91c3			 
91c3			; Select storage bank 
91c3			 
91c3			.selbank: 
91c3			 
91c3				if STORAGE_SE 
91c3				endif 
91c3				 
91c3 c9				ret 
91c4			 
91c4			if STORAGE_SE 
91c4			 
91c4			.config_ldir:   
91c4				; Load storage bank labels into menu array 
91c4			 
91c4				 
91c4			 
91c4			 
91c4				ret 
91c4			 
91c4			 
91c4			endif 
91c4			 
91c4			 
91c4			; Save user words to storage 
91c4			 
91c4			.savetostore: 
91c4			 
91c4				if STORAGE_SE 
91c4			 
91c4					call config_dir 
91c4				        ld hl, scratch 
91c4					ld a, 0 
91c4					call menu 
91c4					 
91c4					ld hl, scratch 
91c4					call config_fdir 
91c4			 
91c4			 
91c4				endif 
91c4			 
91c4 c9				ret 
91c5			 
91c5			 
91c5			 
91c5			if STORAGE_SE 
91c5			 
91c5			config_fdir: 
91c5				; using the scratch dir go through and release the memory allocated for each string 
91c5				 
91c5				ld hl, scratch 
91c5			.cfdir:	ld e,(hl) 
91c5				inc hl 
91c5				ld d,(hl) 
91c5				inc hl 
91c5			 
91c5				ex de, hl 
91c5				call ishlzero 
91c5				ret z     ; return on null pointer 
91c5				call free 
91c5				ex de, hl 
91c5				jr .cfdir 
91c5			 
91c5			 
91c5				ret 
91c5			 
91c5			 
91c5			config_dir: 
91c5			 
91c5				; for the config menus that need to build a directory of storage call this routine 
91c5				; it will construct a menu in scratch to pass to menu 
91c5			 
91c5				; open storage device 
91c5			 
91c5				; execute DIR to build a list of files and their ids into scratch in menu format 
91c5				; once the menu has finished then will need to call config_fdir to release the strings 
91c5				 
91c5				; c = number items 
91c5			 
91c5				 
91c5				call storage_get_block_0 
91c5			 
91c5				ld hl, store_page     ; get current id count 
91c5				ld b, (hl) 
91c5				ld c, 0    ; count of files   
91c5			 
91c5			 
91c5				ld hl, scratch 
91c5				ld (store_tmp2), hl    ; location to poke strings 
91c5			 
91c5				; check for empty drive 
91c5			 
91c5				ld a, 0 
91c5				cp b 
91c5				jp z, .dirdone 
91c5			 
91c5				 
91c5					if DEBUG_FORTH_WORDS 
91c5						DMARK "Cdc" 
91c5						CALLMONITOR 
91c5					endif 
91c5			 
91c5			 
91c5			.diritem:	 
91c5				push bc 
91c5				; for each of the current ids do a search for them and if found push to stack 
91c5			 
91c5					ld hl, STORE_BLOCK_PHY 
91c5					ld d, 0		 ; look for extent 0 of block id as this contains file name 
91c5					ld e,b 
91c5			 
91c5					call storage_findnextid 
91c5			 
91c5			 
91c5					; if found hl will be non zero 
91c5			 
91c5					call ishlzero 
91c5					jr z, .dirnotfound 
91c5			 
91c5					; increase count 
91c5			 
91c5					pop bc	 
91c5					inc c 
91c5					push bc 
91c5					 
91c5			 
91c5					; get file header and push the file name 
91c5			 
91c5					ld de, store_page 
91c5					call storage_read_block 
91c5			 
91c5					; push file id to stack 
91c5				 
91c5					ld a, (store_page) 
91c5					ld h, 0 
91c5					ld l, a 
91c5			 
91c5					;call forth_push_numhl 
91c5					; TODO store id 
91c5			 
91c5					push hl 
91c5			 
91c5					; push extent count to stack  
91c5				 
91c5					ld hl, store_page+3 
91c5			 
91c5					; get file name length 
91c5			 
91c5					call strlenz   
91c5			 
91c5					inc hl   ; cover zero term 
91c5					inc hl  ; stick the id at the end of the area 
91c5			 
91c5					push hl 
91c5					pop bc    ; move length to bc 
91c5			 
91c5					call malloc 
91c5			 
91c5					; TODO save malloc area to scratch 
91c5			 
91c5					ex de, hl 
91c5					ld hl, (store_tmp2) 
91c5					ld (hl), e 
91c5					inc hl 
91c5					ld (hl), d 
91c5					inc hl 
91c5					ld (store_tmp2), hl 
91c5			 
91c5					 
91c5			 
91c5					;pop hl   ; get source 
91c5			;		ex de, hl    ; swap aronund	 
91c5			 
91c5					ld hl, store_page+3 
91c5					if DEBUG_FORTH_WORDS 
91c5						DMARK "CFd" 
91c5						CALLMONITOR 
91c5					endif 
91c5					ldir 
91c5			 
91c5					; de is past string, move back one and store id 
91c5					 
91c5					dec de 
91c5			 
91c5					; store file id 
91c5			 
91c5					pop hl 
91c5					ex de,hl 
91c5					ld (hl), e 
91c5			 
91c5					if DEBUG_FORTH_WORDS 
91c5						DMARK "Cdi" 
91c5						CALLMONITOR 
91c5					endif 
91c5					 
91c5			.dirnotfound: 
91c5					pop bc     
91c5					djnz .diritem 
91c5				 
91c5			.dirdone:	 
91c5			 
91c5					ld a, 0 
91c5					ld hl, (store_tmp2) 
91c5					ld (hl), a 
91c5					inc hl 
91c5					ld (hl), a 
91c5					inc hl 
91c5					; push a count of the dir items found 
91c5			 
91c5			;		ld h, 0 
91c5			;		ld l, c 
91c5			 
91c5				ret 
91c5			 
91c5			endif 
91c5			 
91c5			 
91c5			; Settings 
91c5			; Run  
91c5			 
91c5			 
91c5			 
91c5			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
91c5			;;hd_menu2:   db "        2: Editor",0   
91c5			;hd_menu2:   db "        2: Editor       6: Menu",0   
91c5			;hd_menu3:   db "        3: Storage",0 
91c5			;hd_menu4:   db "0=quit  4: Debug",0 
91c5			;hd_don:     db "ON",0 
91c5			;hd_doff:     db "OFF",0 
91c5			; 
91c5			; 
91c5			; 
91c5			;hardware_diags_old:       
91c5			; 
91c5			;.diagmenu: 
91c5			;	call clear_display 
91c5			;	ld a, display_row_1 
91c5			;	ld de, hd_menu1 
91c5			;	call str_at_display 
91c5			; 
91c5			;	ld a, display_row_2 
91c5			;	ld de, hd_menu2 
91c5			;	call str_at_display 
91c5			; 
91c5			;	ld a, display_row_3 
91c5			;	ld de, hd_menu3 
91c5			;	call str_at_display 
91c5			; 
91c5			;	ld a,  display_row_4 
91c5			;	ld de, hd_menu4 
91c5			;	call str_at_display 
91c5			; 
91c5			;	; display debug state 
91c5			; 
91c5			;	ld de, hd_don 
91c5			;	ld a, (os_view_disable) 
91c5			;	cp 0 
91c5			;	jr z, .distog 
91c5			;	ld de, hd_doff 
91c5			;.distog: ld a, display_row_4+17 
91c5			;	call str_at_display 
91c5			; 
91c5			;	call update_display 
91c5			; 
91c5			;	call cin_wait 
91c5			; 
91c5			; 
91c5			; 
91c5			;	cp '4' 
91c5			;	jr nz, .diagn1 
91c5			; 
91c5			;	; debug toggle 
91c5			; 
91c5			;	ld a, (os_view_disable) 
91c5			;	ld b, '*' 
91c5			;	cp 0 
91c5			;	jr z, .debtog 
91c5			;	ld b, 0 
91c5			;.debtog:	 
91c5			;	ld a,b 
91c5			;	ld (os_view_disable),a 
91c5			; 
91c5			;.diagn1: cp '0' 
91c5			;	 ret z 
91c5			; 
91c5			;;	cp '1' 
91c5			;;       jp z, matrix	 
91c5			;;   TODO keyboard matrix test 
91c5			; 
91c5			;	cp '2' 
91c5			;	jp z, .diagedit 
91c5			; 
91c5			;;	cp '6' 
91c5			;;	jp z, .menutest 
91c5			;;if ENABLE_BASIC 
91c5			;;	cp '6' 
91c5			;;	jp z, basic 
91c5			;;endif 
91c5			 ; 
91c5			;	jp .diagmenu 
91c5			; 
91c5			; 
91c5			;	ret 
91c5			 
91c5			 
91c5			.debug_tog: 
91c5 21 0c 92			ld hl, .menudebug 
91c8				 
91c8 3a 51 e3			ld a, (os_view_disable) 
91cb fe 2a			cp '*' 
91cd 20 04			jr nz,.tdon  
91cf 3e 01			ld a, 1 
91d1 18 02			jr .tog1 
91d3 3e 00		.tdon: ld a, 0 
91d5			 
91d5			.tog1: 
91d5 cd ab 88			call menu 
91d8 fe 00			cp 0 
91da c8				ret z 
91db fe 01			cp 1    ; disable debug 
91dd 28 04			jr z, .dtog0 
91df 3e 2a			ld a, '*' 
91e1 18 02			jr .dtogset 
91e3 3e 00		.dtog0: ld a, 0 
91e5 32 51 e3		.dtogset:  ld (os_view_disable), a 
91e8 c3 c5 91			jp .debug_tog 
91eb			 
91eb			 
91eb			hardware_diags:       
91eb			 
91eb			.diagm: 
91eb 21 fe 91			ld hl, .menuitems 
91ee 3e 00			ld a, 0 
91f0 cd ab 88			call menu 
91f3			 
91f3 fe 00		         cp 0 
91f5 c8				 ret z 
91f6			 
91f6 fe 02			cp 2 
91f8 ca 57 92			jp z, .diagedit 
91fb			 
91fb			;	cp '6' 
91fb			;	jp z, .menutest 
91fb			;if ENABLE_BASIC 
91fb			;	cp '6' 
91fb			;	jp z, basic 
91fb			;endif 
91fb			  
91fb c3 eb 91			jp .diagm 
91fe			 
91fe				 
91fe 12 92		.menuitems:   	dw .m1 
9200 1d 92				dw .m2 
9202 24 92				dw .m3 
9204 2c 92				dw .m5 
9206 32 92				dw .m5a 
9208 3b 92				dw .m5b 
920a 00 00				dw 0 
920c			 
920c			.menudebug: 
920c 44 92				dw .m6 
920e 4d 92				dw .m7 
9210 00 00				dw 0 
9212			 
9212 .. 00		.m1:   db "Key Matrix",0 
921d .. 00		.m2:   db "Editor",0 
9224 .. 00		.m3:   db "Storage",0 
922c .. 00		.m5:   db "Sound",0 
9232 .. 00		.m5a:  db "RAM Test",0 
923b .. 00		.m5b:  db "LCD Test",0 
9244			 
9244 .. 00		.m6:   db "Debug ON",0 
924d .. 00		.m7:   db "Debug OFF",0 
9257			 
9257			; debug editor 
9257			 
9257			.diagedit: 
9257			 
9257 21 60 e3			ld hl, scratch 
925a			;	ld bc, 250 
925a			;	ldir 
925a				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
925a 3e 00			ld a, 0 
925c 77				ld (hl), a 
925d 23				inc hl 
925e 77				ld (hl), a 
925f 23				inc hl 
9260 77				ld (hl), a 
9261			 
9261 cd 7a 88		        call clear_display 
9264 cd 9d 88			call update_display 
9267 3e 01			ld a, 1 
9269 32 80 ee			ld (hardware_diag), a 
926c			.diloop: 
926c 3e 00			ld a, display_row_1 
926e 0e 00			ld c, 0 
9270 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9272 1e 28			ld e, 40 
9274			 
9274 21 60 e3			ld hl, scratch	 
9277 cd d4 8a			call input_str 
927a			 
927a 3e 28			ld a, display_row_2 
927c 11 60 e3			ld de, scratch 
927f cd 8d 88			call str_at_display 
9282 cd 9d 88			call update_display 
9285			 
9285 c3 6c 92			jp .diloop 
9288			 
9288			 
9288			; pass word in hl 
9288			; a has display location 
9288			display_word_at: 
9288 f5				push af 
9289 e5				push hl 
928a 7c				ld a,h 
928b 21 65 e6			ld hl, os_word_scratch 
928e cd a8 8d			call hexout 
9291 e1				pop hl 
9292 7d				ld a,l 
9293 21 67 e6			ld hl, os_word_scratch+2 
9296 cd a8 8d			call hexout 
9299 21 69 e6			ld hl, os_word_scratch+4 
929c 3e 00			ld a,0 
929e 77				ld (hl),a 
929f 11 65 e6			ld de,os_word_scratch 
92a2 f1				pop af 
92a3 cd 8d 88				call str_at_display 
92a6 c9				ret 
92a7			 
92a7			display_ptr_state: 
92a7			 
92a7				; to restore afterwards 
92a7			 
92a7 d5				push de 
92a8 c5				push bc 
92a9 e5				push hl 
92aa f5				push af 
92ab			 
92ab				; for use in here 
92ab			 
92ab			;	push bc 
92ab			;	push de 
92ab			;	push hl 
92ab			;	push af 
92ab			 
92ab cd 7a 88			call clear_display 
92ae			 
92ae 11 81 94			ld de, .ptrstate 
92b1 3e 00			ld a, display_row_1 
92b3 cd 8d 88			call str_at_display 
92b6			 
92b6				; display debug step 
92b6			 
92b6			 
92b6 11 7a ee			ld de, debug_mark 
92b9 3e 26			ld a, display_row_1+display_cols-2 
92bb cd 8d 88			call str_at_display 
92be			 
92be				; display a 
92be 11 8b 94			ld de, .ptrcliptr 
92c1 3e 28			ld a, display_row_2 
92c3 cd 8d 88			call str_at_display 
92c6			 
92c6 f1				pop af 
92c7 2a 2b eb			ld hl,(cli_ptr) 
92ca 3e 30			ld a, display_row_2+8 
92cc cd 88 92			call display_word_at 
92cf			 
92cf			 
92cf				; display hl 
92cf			 
92cf			 
92cf 11 93 94			ld de, .ptrclioptr 
92d2 3e 32			ld a, display_row_2+10 
92d4 cd 8d 88			call str_at_display 
92d7			; 
92d7			;	pop hl 
92d7 3e 35			ld a, display_row_2+13 
92d9 2a 29 eb			ld hl,(cli_origptr) 
92dc cd 88 92			call display_word_at 
92df			; 
92df			;	 
92df			;	; display de 
92df			 
92df			;	ld de, .regstatede 
92df			;	ld a, display_row_3 
92df			;	call str_at_display 
92df			 
92df			;	pop de 
92df			;	ld h,d 
92df			;	ld l, e 
92df			;	ld a, display_row_3+3 
92df			;	call display_word_at 
92df			 
92df			 
92df				; display bc 
92df			 
92df			;	ld de, .regstatebc 
92df			;	ld a, display_row_3+10 
92df			;	call str_at_display 
92df			 
92df			;	pop bc 
92df			;	ld h,b 
92df			;	ld l, c 
92df			;	ld a, display_row_3+13 
92df			;	call display_word_at 
92df			 
92df			 
92df				; display dsp 
92df			 
92df			;	ld de, .regstatedsp 
92df			;	ld a, display_row_4 
92df			;	call str_at_display 
92df			 
92df				 
92df			;	ld hl,(cli_data_sp) 
92df			;	ld a, display_row_4+4 
92df			;	call display_word_at 
92df			 
92df				; display rsp 
92df			 
92df 11 c2 94			ld de, .regstatersp 
92e2 3e 82			ld a, display_row_4+10 
92e4 cd 8d 88			call str_at_display 
92e7			 
92e7				 
92e7 2a 11 eb			ld hl,(cli_ret_sp) 
92ea 3e 86			ld a, display_row_4+14 
92ec cd 88 92			call display_word_at 
92ef			 
92ef cd 9d 88			call update_display 
92f2			 
92f2 cd fa 87			call delay1s 
92f5 cd fa 87			call delay1s 
92f8 cd fa 87			call delay1s 
92fb			 
92fb			 
92fb cd 08 98			call next_page_prompt 
92fe			 
92fe				; restore  
92fe			 
92fe f1				pop af 
92ff e1				pop hl 
9300 c1				pop bc 
9301 d1				pop de 
9302 c9				ret 
9303			 
9303			break_point_state: 
9303 f5				push af 
9304			 
9304				; see if disabled 
9304			 
9304 3a 51 e3			ld a, (os_view_disable) 
9307 fe 2a			cp '*' 
9309 20 02			jr nz, .bpsgo 
930b f1				pop af 
930c c9				ret 
930d			 
930d			.bpsgo: 
930d f1				pop af 
930e f5				push af 
930f 22 4d e3			ld (os_view_hl), hl 
9312 ed 53 4b e3		ld (os_view_de), de 
9316 ed 43 49 e3		ld (os_view_bc), bc 
931a e5				push hl 
931b 6f				ld l, a 
931c 26 00			ld h, 0 
931e 22 4f e3			ld (os_view_af),hl 
9321			 
9321 21 c0 ed				ld hl, display_fb0 
9324 22 db eb				ld (display_fb_active), hl 
9327 e1				pop hl	 
9328			 
9328 3e 31			ld a, '1' 
932a fe 2a		.bps1:  cp '*' 
932c 20 03			jr nz, .bps1b 
932e 32 51 e3			ld (os_view_disable),a 
9331 fe 31		.bps1b:  cp '1' 
9333 20 14			jr nz, .bps2 
9335			 
9335				; display reg 
9335			 
9335				 
9335			 
9335 3a 4f e3			ld a, (os_view_af) 
9338 2a 4d e3			ld hl, (os_view_hl) 
933b ed 5b 4b e3		ld de, (os_view_de) 
933f ed 4b 49 e3		ld bc, (os_view_bc) 
9343 cd dd 93			call display_reg_state 
9346 c3 c9 93			jp .bpschk 
9349			 
9349 fe 32		.bps2:  cp '2' 
934b 20 08			jr nz, .bps3 
934d				 
934d				; display hl 
934d 2a 4d e3			ld hl, (os_view_hl) 
9350 cd c7 94			call display_dump_at_hl 
9353			 
9353 18 74			jr .bpschk 
9355			 
9355 fe 33		.bps3:  cp '3' 
9357 20 08			jr nz, .bps4 
9359			 
9359			        ; display de 
9359 2a 4b e3			ld hl, (os_view_de) 
935c cd c7 94			call display_dump_at_hl 
935f			 
935f 18 68			jr .bpschk 
9361 fe 34		.bps4:  cp '4' 
9363 20 08			jr nz, .bps5 
9365			 
9365			        ; display bc 
9365 2a 49 e3			ld hl, (os_view_bc) 
9368 cd c7 94			call display_dump_at_hl 
936b			 
936b 18 5c			jr .bpschk 
936d fe 35		.bps5:  cp '5' 
936f 20 08		        jr nz, .bps7 
9371			 
9371				; display cur ptr 
9371 2a 2b eb			ld hl, (cli_ptr) 
9374 cd c7 94			call display_dump_at_hl 
9377			 
9377 18 50			jr .bpschk 
9379 fe 36		.bps7:  cp '6' 
937b 20 08			jr nz, .bps8b 
937d				 
937d				; display cur orig ptr 
937d 2a 29 eb			ld hl, (cli_origptr) 
9380 cd c7 94			call display_dump_at_hl 
9383 18 44			jr .bpschk 
9385 fe 37		.bps8b:  cp '7' 
9387 20 08			jr nz, .bps9 
9389				 
9389				; display dsp 
9389 2a 0d eb			ld hl, (cli_data_sp) 
938c cd c7 94			call display_dump_at_hl 
938f			 
938f 18 38			jr .bpschk 
9391 fe 39		.bps9:  cp '9' 
9393 20 05			jr nz, .bps8c 
9395				 
9395				; display SP 
9395			;	ld hl, sp 
9395 cd c7 94			call display_dump_at_hl 
9398			 
9398 18 2f			jr .bpschk 
939a fe 38		.bps8c:  cp '8' 
939c 20 08			jr nz, .bps8d 
939e				 
939e				; display rsp 
939e 2a 11 eb			ld hl, (cli_ret_sp) 
93a1 cd c7 94			call display_dump_at_hl 
93a4			 
93a4 18 23			jr .bpschk 
93a6 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
93a8 20 05			jr nz, .bps8 
93aa cd fe 95			call monitor 
93ad			 
93ad 18 1a			jr .bpschk 
93af fe 30		.bps8:  cp '0' 
93b1 20 16			jr nz, .bpschk 
93b3			 
93b3 21 1f ed				ld hl, display_fb1 
93b6 22 db eb				ld (display_fb_active), hl 
93b9 cd 9d 88				call update_display 
93bc			 
93bc				;ld a, (os_view_af) 
93bc 2a 4d e3			ld hl, (os_view_hl) 
93bf ed 5b 4b e3		ld de, (os_view_de) 
93c3 ed 4b 49 e3		ld bc, (os_view_bc) 
93c7 f1				pop af 
93c8 c9				ret 
93c9			 
93c9			.bpschk:   
93c9 cd fa 87			call delay1s 
93cc 3e 9f		ld a,display_row_4 + display_cols - 1 
93ce 11 06 98		        ld de, endprg 
93d1 cd 8d 88			call str_at_display 
93d4 cd 9d 88			call update_display 
93d7 cd 6e d8			call cin_wait 
93da			 
93da c3 2a 93			jp .bps1 
93dd			 
93dd			 
93dd			display_reg_state: 
93dd			 
93dd				; to restore afterwards 
93dd			 
93dd d5				push de 
93de c5				push bc 
93df e5				push hl 
93e0 f5				push af 
93e1			 
93e1				; for use in here 
93e1			 
93e1 c5				push bc 
93e2 d5				push de 
93e3 e5				push hl 
93e4 f5				push af 
93e5			 
93e5 cd 7a 88			call clear_display 
93e8			 
93e8 11 9d 94			ld de, .regstate 
93eb 3e 00			ld a, display_row_1 
93ed cd 8d 88			call str_at_display 
93f0			 
93f0				; display debug step 
93f0			 
93f0			 
93f0 11 7a ee			ld de, debug_mark 
93f3 3e 25			ld a, display_row_1+display_cols-3 
93f5 cd 8d 88			call str_at_display 
93f8			 
93f8				; display a 
93f8 11 b9 94			ld de, .regstatea 
93fb 3e 28			ld a, display_row_2 
93fd cd 8d 88			call str_at_display 
9400			 
9400 e1				pop hl 
9401			;	ld h,0 
9401			;	ld l, a 
9401 3e 2b			ld a, display_row_2+3 
9403 cd 88 92			call display_word_at 
9406			 
9406			 
9406				; display hl 
9406			 
9406			 
9406 11 ad 94			ld de, .regstatehl 
9409 3e 32			ld a, display_row_2+10 
940b cd 8d 88			call str_at_display 
940e			 
940e e1				pop hl 
940f 3e 35			ld a, display_row_2+13 
9411 cd 88 92			call display_word_at 
9414			 
9414				 
9414				; display de 
9414			 
9414 11 b1 94			ld de, .regstatede 
9417 3e 50			ld a, display_row_3 
9419 cd 8d 88			call str_at_display 
941c			 
941c e1				pop hl 
941d			;	ld h,d 
941d			;	ld l, e 
941d 3e 53			ld a, display_row_3+3 
941f cd 88 92			call display_word_at 
9422			 
9422			 
9422				; display bc 
9422			 
9422 11 b5 94			ld de, .regstatebc 
9425 3e 5a			ld a, display_row_3+10 
9427 cd 8d 88			call str_at_display 
942a			 
942a e1				pop hl 
942b			;	ld h,b 
942b			;	ld l, c 
942b 3e 5d			ld a, display_row_3+13 
942d cd 88 92			call display_word_at 
9430			 
9430			 
9430				; display dsp 
9430			 
9430 11 bd 94			ld de, .regstatedsp 
9433 3e 78			ld a, display_row_4 
9435 cd 8d 88			call str_at_display 
9438			 
9438				 
9438 2a 0d eb			ld hl,(cli_data_sp) 
943b 3e 7c			ld a, display_row_4+4 
943d cd 88 92			call display_word_at 
9440			 
9440				; display rsp 
9440			 
9440 11 c2 94			ld de, .regstatersp 
9443 3e 82			ld a, display_row_4+10 
9445 cd 8d 88			call str_at_display 
9448			 
9448				 
9448 2a 11 eb			ld hl,(cli_ret_sp) 
944b 3e 86			ld a, display_row_4+14 
944d cd 88 92			call display_word_at 
9450			 
9450 cd 9d 88			call update_display 
9453			 
9453			;	call delay1s 
9453			;	call delay1s 
9453			;	call delay1s 
9453			 
9453			 
9453			;	call next_page_prompt 
9453			 
9453				; restore  
9453			 
9453 f1				pop af 
9454 e1				pop hl 
9455 c1				pop bc 
9456 d1				pop de 
9457 c9				ret 
9458			 
9458 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
946c .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
9481 .. 00		.ptrstate:	db "Ptr State",0 
948b .. 00		.ptrcliptr:     db "cli_ptr",0 
9493 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
949d .. 00		.regstate:	db "Reg State (1/0)",0 
94ad .. 00		.regstatehl:	db "HL:",0 
94b1 .. 00		.regstatede:	db "DE:",0 
94b5 .. 00		.regstatebc:	db "BC:",0 
94b9 .. 00		.regstatea:	db "A :",0 
94bd .. 00		.regstatedsp:	db "DSP:",0 
94c2 .. 00		.regstatersp:	db "RSP:",0 
94c7			 
94c7			display_dump_at_hl: 
94c7 e5				push hl 
94c8 d5				push de 
94c9 c5				push bc 
94ca f5				push af 
94cb			 
94cb 22 83 e6			ld (os_cur_ptr),hl	 
94ce cd 7a 88			call clear_display 
94d1 cd 10 97			call dumpcont 
94d4			;	call delay1s 
94d4			;	call next_page_prompt 
94d4			 
94d4			 
94d4 f1				pop af 
94d5 c1				pop bc 
94d6 d1				pop de 
94d7 e1				pop hl 
94d8 c9				ret 
94d9			 
94d9			;if ENABLE_BASIC 
94d9			;	include "nascombasic.asm" 
94d9			;	basic: 
94d9			;	include "forth/FORTH.ASM" 
94d9			;endif 
94d9			 
94d9			; eof 
94d9			 
94d9			 
# End of file firmware_diags.asm
94d9			  
94d9			  
94d9			  
94d9			  
94d9			; eof  
94d9			  
# End of file firmware.asm
94d9			 
94d9			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
94d9			;if BASE_KEV  
94d9			;baseram: equ 08000h 
94d9			;endif 
94d9			 
94d9			;if BASE_SC114 
94d9			;baseram:     equ    endofcode 
94d9			;endif 
94d9			 
94d9			 
94d9			; start system 
94d9			 
94d9			coldstart: 
94d9				; set sp 
94d9				; di/ei 
94d9			 
94d9 f3				di 
94da 31 00 f0			ld sp, tos 
94dd			;	ei 
94dd			 
94dd			 
94dd				; disable breakpoint by default 
94dd			 
94dd 3e 2a			ld a,'*' 
94df 32 51 e3			ld (os_view_disable),a 
94e2			 
94e2				; init hardware 
94e2			 
94e2				; init keyboard and screen hardware 
94e2			 
94e2 cd 03 80			call hardware_init 
94e5			 
94e5			 
94e5				; detect if any keys are held down to enable breakpoints at start up 
94e5			 
94e5 cd 74 d8			call cin  
94e8 fe 00			cp 0 
94ea 28 03			jr z, .nokeys 
94ec			 
94ec				;call hardware_diags 
94ec cd 07 91			call config 
94ef			 
94ef			;	ld de, .bpen 
94ef			;	ld a, display_row_4 
94ef			;	call str_at_display 
94ef			;	call update_display 
94ef			; 
94ef			;	ld a,0 
94ef			;	ld (os_view_disable),a 
94ef			; 
94ef			;.bpwait: 
94ef			;	call cin 
94ef			;	cp 0 
94ef			;	jr z, .bpwait 
94ef			;	jr .nokeys 
94ef			; 
94ef			; 
94ef			;.bpen:  db "Break points enabled!",0 
94ef			 
94ef			 
94ef			 
94ef			 
94ef			 
94ef			 
94ef			.nokeys: 
94ef			 
94ef			 
94ef				 
94ef			 
94ef			;jp  testkey 
94ef			 
94ef			;call storage_get_block_0 
94ef			; 
94ef			;ld hl, 0 
94ef			;ld de, store_page 
94ef			;call storage_read_block 
94ef			 
94ef				 
94ef			;ld hl, 10 
94ef			;ld de, store_page 
94ef			;call storage_read_block 
94ef			 
94ef			 
94ef			 
94ef			 
94ef			 
94ef			;stop:	nop 
94ef			;	jp stop 
94ef			 
94ef			 
94ef			 
94ef			main: 
94ef cd 7a 88			call clear_display 
94f2 cd 9d 88			call update_display 
94f5			 
94f5			 
94f5			 
94f5			;	call testlcd 
94f5			 
94f5			 
94f5			 
94f5 cd ce 9b			call forth_init 
94f8			 
94f8			 
94f8			warmstart: 
94f8 cd a4 9b			call forth_warmstart 
94fb			 
94fb				; run startup word load 
94fb			        ; TODO prevent this running at warmstart after crash  
94fb			 
94fb				if STARTUP_ENABLE 
94fb cd 08 d5				call forth_startup 
94fe			 
94fe					if STORAGE_SE 
94fe						call forth_autoload 
94fe					endif 
94fe			 
94fe				endif 
94fe			 
94fe				; show free memory after boot 
94fe 11 98 95			ld de, freeram 
9501 3e 00			ld a, display_row_1 
9503 cd 8d 88			call str_at_display 
9506			 
9506			; Or use heap_size word???? 
9506 21 46 e3			ld hl, heap_end 
9509 11 92 d8			ld de, heap_start 
950c ed 52			sbc hl, de 
950e e5				push hl 
950f 7c				ld a,h	         	 
9510 21 65 e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9513 cd a8 8d			call hexout 
9516 e1			   	pop hl 
9517			 
9517 7d				ld a,l 
9518 21 67 e6			ld hl, os_word_scratch+2 
951b cd a8 8d			call hexout 
951e 21 69 e6			ld hl, os_word_scratch+4 
9521 3e 00			ld a, 0 
9523 77				ld (hl),a 
9524 11 65 e6			ld de, os_word_scratch 
9527 3e 0d			ld a, display_row_1 + 13 
9529 cd 8d 88			call str_at_display 
952c cd 9d 88			call update_display 
952f			 
952f			 
952f				;call demo 
952f			 
952f			 
952f				; init scratch input area for cli commands 
952f			 
952f 21 87 e6			ld hl, os_cli_cmd 
9532 3e 00			ld a,0 
9534 77				ld (hl),a 
9535 23				inc hl 
9536 77				ld (hl),a 
9537			 
9537 3e 00			ld a,0 
9539 32 86 e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
953c			 
953c 32 83 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
953f 32 84 e6			ld (os_cur_ptr+1),a	 
9542			 
9542 32 65 e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
9545 32 66 e6			ld (os_word_scratch+1),a	 
9548				 
9548			 
9548				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9548 21 87 e6			ld hl, os_cli_cmd 
954b			 
954b 3e 00			ld a, 0		 ; init cli input 
954d 77				ld (hl), a 
954e 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9550			cli: 
9550				; show cli prompt 
9550				;push af 
9550				;ld a, 0 
9550				;ld de, prompt 
9550				;call str_at_display 
9550			 
9550				;call update_display 
9550				;pop af 
9550				;inc a 
9550				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9550 0e 00			ld c, 0 
9552 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
9554 1e 28			ld e, 40 
9556			 
9556 21 87 e6			ld hl, os_cli_cmd 
9559			 
9559				STACKFRAME OFF $fefe $9f9f 
9559				if DEBUG_STACK_IMB 
9559					if OFF 
9559						exx 
9559						ld de, $fefe 
9559						ld a, d 
9559						ld hl, curframe 
9559						call hexout 
9559						ld a, e 
9559						ld hl, curframe+2 
9559						call hexout 
9559						ld hl, $fefe 
9559						push hl 
9559						ld hl, $9f9f 
9559						push hl 
9559						exx 
9559					endif 
9559				endif 
9559			endm 
# End of macro STACKFRAME
9559			 
9559 cd d4 8a			call input_str 
955c			 
955c				STACKFRAMECHK OFF $fefe $9f9f 
955c				if DEBUG_STACK_IMB 
955c					if OFF 
955c						exx 
955c						ld hl, $9f9f 
955c						pop de   ; $9f9f 
955c						call cmp16 
955c						jr nz, .spnosame 
955c						ld hl, $fefe 
955c						pop de   ; $fefe 
955c						call cmp16 
955c						jr z, .spfrsame 
955c						.spnosame: call showsperror 
955c						.spfrsame: nop 
955c						exx 
955c					endif 
955c				endif 
955c			endm 
# End of macro STACKFRAMECHK
955c			 
955c				; copy input to last command 
955c			 
955c 21 87 e6			ld hl, os_cli_cmd 
955f 11 86 e7			ld de, os_last_cmd 
9562 01 ff 00			ld bc, 255 
9565 ed b0			ldir 
9567			 
9567				; wipe current buffer 
9567			 
9567			;	ld a, 0 
9567			;	ld hl, os_cli_cmd 
9567			;	ld de, os_cli_cmd+1 
9567			;	ld bc, 254 
9567			;	ldir 
9567				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9567			;	call strcpy 
9567			;	ld a, 0 
9567			;	ld (hl), a 
9567			;	inc hl 
9567			;	ld (hl), a 
9567			;	inc hl 
9567			;	ld (hl), a 
9567			 
9567				; switch frame buffer to program  
9567			 
9567 21 1f ed				ld hl, display_fb1 
956a 22 db eb				ld (display_fb_active), hl 
956d			 
956d			;	nop 
956d				STACKFRAME ON $fbfe $8f9f 
956d				if DEBUG_STACK_IMB 
956d					if ON 
956d						exx 
956d						ld de, $fbfe 
956d						ld a, d 
956d						ld hl, curframe 
956d						call hexout 
956d						ld a, e 
956d						ld hl, curframe+2 
956d						call hexout 
956d						ld hl, $fbfe 
956d						push hl 
956d						ld hl, $8f9f 
956d						push hl 
956d						exx 
956d					endif 
956d				endif 
956d			endm 
# End of macro STACKFRAME
956d				; first time into the parser so pass over the current scratch pad 
956d 21 87 e6			ld hl,os_cli_cmd 
9570				; tokenise the entered statement(s) in HL 
9570 cd 47 9c			call forthparse 
9573			        ; exec forth statements in top of return stack 
9573 cd 87 9c			call forthexec 
9576				;call forthexec_cleanup 
9576			;	call parsenext 
9576			 
9576				STACKFRAMECHK ON $fbfe $8f9f 
9576				if DEBUG_STACK_IMB 
9576					if ON 
9576						exx 
9576						ld hl, $8f9f 
9576						pop de   ; $8f9f 
9576						call cmp16 
9576						jr nz, .spnosame 
9576						ld hl, $fbfe 
9576						pop de   ; $fbfe 
9576						call cmp16 
9576						jr z, .spfrsame 
9576						.spnosame: call showsperror 
9576						.spfrsame: nop 
9576						exx 
9576					endif 
9576				endif 
9576			endm 
# End of macro STACKFRAMECHK
9576				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
9576			 
9576 3e 78			ld a, display_row_4 
9578 11 aa 95			ld de, endprog 
957b			 
957b cd 9d 88			call update_display		 
957e			 
957e cd 08 98			call next_page_prompt 
9581			 
9581				; switch frame buffer to cli 
9581			 
9581 21 c0 ed				ld hl, display_fb0 
9584 22 db eb				ld (display_fb_active), hl 
9587			 
9587			 
9587 cd 7a 88		        call clear_display 
958a cd 9d 88			call update_display		 
958d			 
958d 21 87 e6			ld hl, os_cli_cmd 
9590			 
9590 3e 00			ld a, 0		 ; init cli input 
9592 77				ld (hl), a 
9593			 
9593				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9593			 
9593				; now on last line 
9593			 
9593				; TODO scroll screen up 
9593			 
9593				; TODO instead just clear screen and place at top of screen 
9593			 
9593			;	ld a, 0 
9593			;	ld (f_cursor_ptr),a 
9593			 
9593				;call clear_display 
9593				;call update_display 
9593			 
9593				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9593 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9595 c3 50 95			jp cli 
9598			 
9598 .. 00		freeram: db "Free bytes: $",0 
95a6 ..			asc: db "1A2F" 
95aa .. 00		endprog: db "End prog...",0 
95b6			 
95b6			testenter2:   
95b6 21 92 e3			ld hl,scratch+50 
95b9 22 83 e6			ld (os_cur_ptr),hl 
95bc c3 50 95			jp cli 
95bf			 
95bf			testenter:  
95bf			 
95bf 21 a6 95			ld hl,asc 
95c2			;	ld a,(hl) 
95c2			;	call nibble2val 
95c2 cd fe 8d			call get_byte 
95c5			 
95c5			 
95c5			;	ld a,(hl) 
95c5			;	call atohex 
95c5			 
95c5			;	call fourehexhl 
95c5 32 92 e3			ld (scratch+50),a 
95c8			 
95c8			 
95c8			 
95c8 21 a8 95			ld hl,asc+2 
95cb			;	ld a, (hl) 
95cb			;	call nibble2val 
95cb cd fe 8d			call get_byte 
95ce			 
95ce			;	call fourehexhl 
95ce 32 94 e3			ld (scratch+52),a 
95d1				 
95d1 21 92 e3			ld hl,scratch+50 
95d4 22 83 e6			ld (os_cur_ptr),hl 
95d7 c3 50 95			jp cli 
95da			 
95da			enter:	 
95da 3a 64 e3			ld a,(scratch+4) 
95dd fe 00			cp 0 
95df 28 0c			jr z, .entercont 
95e1				; no, not a null term line so has an address to work out.... 
95e1			 
95e1 21 62 e3			ld hl,scratch+2 
95e4 cd 5e 8e			call get_word_hl 
95e7			 
95e7 22 83 e6			ld (os_cur_ptr),hl	 
95ea c3 50 95			jp cli 
95ed			 
95ed			 
95ed			.entercont:  
95ed			 
95ed 21 62 e3			ld hl, scratch+2 
95f0 cd fe 8d			call get_byte 
95f3			 
95f3 2a 83 e6		   	ld hl,(os_cur_ptr) 
95f6 77					ld (hl),a 
95f7 23					inc hl 
95f8 22 83 e6				ld (os_cur_ptr),hl 
95fb				 
95fb			; get byte  
95fb			 
95fb			 
95fb c3 50 95			jp cli 
95fe			 
95fe			 
95fe			; basic monitor support 
95fe			 
95fe			monitor: 
95fe				;  
95fe cd 7a 88			call clear_display 
9601 3e 00			ld a, 0 
9603 11 4b 96			ld de, .monprompt 
9606 cd 8d 88			call str_at_display 
9609 cd 9d 88			call update_display 
960c			 
960c				; get a monitor command 
960c			 
960c 0e 00			ld c, 0     ; entry at top left 
960e 16 64			ld d, 100   ; max buffer size 
9610 1e 0f			ld e, 15    ; input scroll area 
9612 3e 00			ld a, 0     ; init string 
9614 21 5e e5			ld hl, os_input 
9617 77				ld (hl), a 
9618 23				inc hl 
9619 77				ld (hl), a 
961a 21 5e e5			ld hl, os_input 
961d 3e 01			ld a, 1     ; init string 
961f cd d4 8a			call input_str 
9622			 
9622 cd 7a 88		        call clear_display 
9625 cd 9d 88			call update_display		 
9628			 
9628 3a 5e e5			ld a, (os_input) 
962b cd fc 8e			call toUpper 
962e fe 48		        cp 'H' 
9630 28 6f		        jr z, .monhelp 
9632 fe 44			cp 'D'		; dump 
9634 ca c2 96			jp z, .mondump	 
9637 fe 43			cp 'C'		; dump 
9639 ca dc 96			jp z, .moncdump	 
963c fe 4d			cp 'M'		; dump 
963e ca 4d 96			jp z, .moneditstart 
9641 fe 55			cp 'U'		; dump 
9643 28 14			jr z, .monedit	 
9645 fe 51			cp 'Q'		; dump 
9647 c8				ret z	 
9648			 
9648			 
9648				; TODO "S" to access symbol by name and not need the address 
9648				; TODO "F" to find a string in memory 
9648			 
9648 c3 fe 95			jp monitor 
964b			 
964b .. 00		.monprompt: db ">", 0 
964d			 
964d			.moneditstart: 
964d				; get starting address 
964d			 
964d 21 60 e5			ld hl,os_input+2 
9650 cd 5e 8e			call get_word_hl 
9653			 
9653 22 83 e6			ld (os_cur_ptr),hl	 
9656			 
9656 c3 fe 95			jp monitor 
9659			 
9659			.monedit: 
9659				; get byte to load 
9659			 
9659 21 60 e5			ld hl,os_input+2 
965c cd fe 8d			call get_byte 
965f			 
965f				; get address to update 
965f 2a 83 e6			ld hl, (os_cur_ptr) 
9662			 
9662				; update byte 
9662			 
9662 77				ld (hl), a 
9663			 
9663				; move to next address and save it 
9663			 
9663 23				inc hl 
9664 22 83 e6			ld (os_cur_ptr),hl	 
9667			 
9667 c3 fe 95			jp monitor 
966a			 
966a			 
966a .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
967e .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
969a .. 00		.monhelptext3:  db "Q-Quit",0 
96a1			        
96a1			.monhelp: 
96a1 3e 00			ld a, display_row_1 
96a3 11 6a 96		        ld de, .monhelptext1 
96a6			 
96a6 cd 8d 88			call str_at_display 
96a9 3e 28			ld a, display_row_2 
96ab 11 7e 96		        ld de, .monhelptext2 
96ae					 
96ae cd 8d 88			call str_at_display 
96b1 3e 50			ld a, display_row_3 
96b3 11 9a 96		        ld de, .monhelptext3 
96b6					 
96b6 cd 8d 88			call str_at_display 
96b9 cd 9d 88			call update_display		 
96bc			 
96bc cd 08 98			call next_page_prompt 
96bf c3 fe 95			jp monitor 
96c2			 
96c2			.mondump:    
96c2 21 60 e5			ld hl,os_input+2 
96c5 cd 5e 8e			call get_word_hl 
96c8			 
96c8 22 83 e6			ld (os_cur_ptr),hl	 
96cb cd 10 97			call dumpcont 
96ce 3e 78			ld a, display_row_4 
96d0 11 aa 95			ld de, endprog 
96d3			 
96d3 cd 9d 88			call update_display		 
96d6			 
96d6 cd 08 98			call next_page_prompt 
96d9 c3 fe 95			jp monitor 
96dc			.moncdump: 
96dc cd 10 97			call dumpcont 
96df 3e 78			ld a, display_row_4 
96e1 11 aa 95			ld de, endprog 
96e4			 
96e4 cd 9d 88			call update_display		 
96e7			 
96e7 cd 08 98			call next_page_prompt 
96ea c3 fe 95			jp monitor 
96ed			 
96ed			 
96ed			; TODO symbol access  
96ed			 
96ed			.symbols:     ;; A list of symbols that can be called up  
96ed c0 ed			dw display_fb0 
96ef .. 00			db "fb0",0  
96f3 65 eb		     	dw store_page 
96f5 .. 00			db "store_page",0 
9700			 
9700			 
9700			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
9700			 
9700 3a 61 e3			ld a,(scratch+1) 
9703 fe 00			cp 0 
9705 28 09			jr z, dumpcont 
9707			 
9707				; no, not a null term line so has an address to work out.... 
9707			 
9707 21 62 e3			ld hl,scratch+2 
970a cd 5e 8e			call get_word_hl 
970d			 
970d 22 83 e6			ld (os_cur_ptr),hl	 
9710			 
9710			 
9710			 
9710			dumpcont: 
9710			 
9710				; dump bytes at ptr 
9710			 
9710			 
9710 3e 00			ld a, display_row_1 
9712 2a db eb			ld hl, (display_fb_active) 
9715 cd a7 8a			call addatohl 
9718 cd 40 97			call .dumpbyterow 
971b			 
971b 3e 28			ld a, display_row_2 
971d 2a db eb			ld hl, (display_fb_active) 
9720 cd a7 8a			call addatohl 
9723 cd 40 97			call .dumpbyterow 
9726			 
9726			 
9726 3e 50			ld a, display_row_3 
9728 2a db eb			ld hl, (display_fb_active) 
972b cd a7 8a			call addatohl 
972e cd 40 97			call .dumpbyterow 
9731			 
9731 3e 78			ld a, display_row_4 
9733 2a db eb			ld hl, (display_fb_active) 
9736 cd a7 8a			call addatohl 
9739 cd 40 97			call .dumpbyterow 
973c			 
973c cd 9d 88			call update_display 
973f			;		jp cli 
973f c9				ret 
9740			 
9740			.dumpbyterow: 
9740			 
9740				;push af 
9740			 
9740 e5				push hl 
9741			 
9741				; calc where to poke the ascii 
9741			if display_cols == 20 
9741				ld a, 16 
9741			else 
9741 3e 1f			ld a, 31 
9743			endif 
9743			 
9743 cd a7 8a			call addatohl 
9746 22 65 e6			ld (os_word_scratch),hl  		; save pos for later 
9749			 
9749			 
9749			; display decoding address 
9749 2a 83 e6		   	ld hl,(os_cur_ptr) 
974c			 
974c 7c				ld a,h 
974d e1				pop hl 
974e e5				push hl 
974f			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
974f cd a8 8d			call hexout 
9752 2a 83 e6		   	ld hl,(os_cur_ptr) 
9755			 
9755 7d				ld a,l 
9756 e1				pop hl 
9757 23				inc hl 
9758 23				inc hl 
9759 e5				push hl 
975a			;	ld hl, os_word_scratch+2 
975a cd a8 8d			call hexout 
975d e1				pop hl 
975e 23				inc hl 
975f 23				inc hl 
9760				;ld hl, os_word_scratch+4 
9760 3e 3a			ld a, ':' 
9762 77				ld (hl),a 
9763 23				inc hl 
9764				;ld a, 0 
9764				;ld (hl),a 
9764				;ld de, os_word_scratch 
9764				;pop af 
9764				;push af 
9764			;		ld a, display_row_2 
9764			;		call str_at_display 
9764			;		call update_display 
9764			 
9764			 
9764			;pop af 
9764			;	add 5 
9764			 
9764			if display_cols == 20 
9764				ld b, 4 
9764			else 
9764 06 08			ld b, 8 
9766			endif	 
9766			 
9766			.dumpbyte: 
9766 c5				push bc 
9767 e5				push hl 
9768			 
9768			 
9768 2a 83 e6		   	ld hl,(os_cur_ptr) 
976b 7e					ld a,(hl) 
976c			 
976c					; poke the ascii to display 
976c 2a 65 e6				ld hl,(os_word_scratch) 
976f 77					ld (hl),a 
9770 23					inc hl 
9771 22 65 e6				ld (os_word_scratch),hl 
9774			 
9774					 
9774			 
9774			 
9774 e1					pop hl 
9775 e5					push hl 
9776			 
9776 cd a8 8d				call hexout 
9779			 
9779					 
9779 2a 83 e6		   	ld hl,(os_cur_ptr) 
977c 23				inc hl 
977d 22 83 e6		   	ld (os_cur_ptr),hl 
9780			 
9780 e1					pop hl 
9781 23					inc hl 
9782 23					inc hl 
9783 23					inc hl 
9784			 
9784			 
9784			 
9784					;ld a,0 
9784					;ld (os_word_scratch+2),a 
9784					;pop af 
9784					;push af 
9784			 
9784					;ld de, os_word_scratch 
9784					;call str_at_display 
9784			;		call update_display 
9784			;		pop af 
9784 c1					pop bc 
9785 c6 03				add 3 
9787 10 dd			djnz .dumpbyte 
9789			 
9789				 
9789			 
9789 c9				ret 
978a			 
978a			jump:	 
978a			 
978a 21 62 e3			ld hl,scratch+2 
978d cd 5e 8e			call get_word_hl 
9790				;ld hl,(scratch+2) 
9790				;call fourehexhl 
9790			 
9790 22 83 e6			ld (os_cur_ptr),hl	 
9793			 
9793 e9				jp (hl) 
9794			 
9794			 
9794			 
9794			; TODO implement a basic monitor mode to start with 
9794			 
9794			 
9794			 
9794			 
9794			 
9794			 
9794			 
9794			 
9794			 
9794			; testing and demo code during development 
9794			 
9794			 
9794 .. 00		str1: db "Enter some text...",0 
97a7 .. 00		clear: db "                    ",0 
97bc			 
97bc			demo: 
97bc			 
97bc			 
97bc			 
97bc			;	call update_display 
97bc			 
97bc				; init scratch input area for testing 
97bc 21 60 e3			ld hl, scratch	 
97bf 3e 00			ld a,0 
97c1 77				ld (hl),a 
97c2			 
97c2			 
97c2 3e 28		            LD   A, display_row_2 
97c4			;            CALL fLCD_Pos       ;Position cursor to location in A 
97c4 11 94 97		            LD   DE, str1 
97c7 cd 8d 88			call str_at_display 
97ca			 
97ca			;            CALL fLCD_Str       ;Display string pointed to by DE 
97ca			cloop:	 
97ca 3e 50		            LD   A, display_row_3 
97cc			;            CALL fLCD_Pos       ;Position cursor to location in A 
97cc 11 a7 97		            LD   DE, clear 
97cf			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
97cf cd 8d 88				call str_at_display 
97d2 3e 78			ld a, display_row_4 
97d4 11 04 98			ld de, prompt 
97d7			 
97d7 cd 8d 88				call str_at_display 
97da cd 9d 88			call update_display 
97dd			 
97dd 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
97df 16 0a			ld d, 10 
97e1 21 60 e3			ld hl, scratch	 
97e4 cd d4 8a			call input_str 
97e7			 
97e7			;	call clear_display 
97e7			;'	call update_display 
97e7			 
97e7 3e 00		            LD   A, display_row_1 
97e9			;            CALL fLCD_Pos       ;Position cursor to location in A 
97e9 11 a7 97		            LD   DE, clear 
97ec cd 8d 88				call str_at_display 
97ef			;            CALL fLCD_Str       ;Display string pointed to by DE 
97ef 3e 00		            LD   A, display_row_1 
97f1			;            CALL fLCD_Pos       ;Position cursor to location in A 
97f1 11 60 e3		            LD   DE, scratch 
97f4			;            CALL fLCD_Str       ;Display string pointed to by DE 
97f4 cd 8d 88				call str_at_display 
97f7 cd 9d 88			call update_display 
97fa			 
97fa 3e 00				ld a,0 
97fc 21 60 e3			ld hl, scratch 
97ff 77				ld (hl),a 
9800			 
9800 00				nop 
9801 c3 ca 97			jp cloop 
9804			 
9804			 
9804			 
9804			; OS Prompt 
9804			 
9804 .. 00		prompt: db ">",0 
9806 .. 00		endprg: db "?",0 
9808			 
9808			 
9808			; handy next page prompt 
9808			next_page_prompt: 
9808 e5				push hl 
9809 d5				push de 
980a f5				push af 
980b c5				push bc 
980c			 
980c 3e 9f			ld a,display_row_4 + display_cols - 1 
980e 11 06 98		        ld de, endprg 
9811 cd 8d 88			call str_at_display 
9814 cd 9d 88			call update_display 
9817 cd 6e d8			call cin_wait 
981a c1				pop bc 
981b f1				pop af 
981c d1				pop de 
981d e1				pop hl 
981e			 
981e			 
981e c9				ret 
981f			 
981f			 
981f			; forth parser 
981f			 
981f			; My forth kernel 
981f			include "forth_kernel.asm" 
981f			; 
981f			; kernel to the forth OS 
981f			 
981f			DS_TYPE_STR: equ 1     ; string type 
981f			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
981f			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
981f			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
981f			 
981f			FORTH_PARSEV1: equ 0 
981f			FORTH_PARSEV2: equ 0 
981f			FORTH_PARSEV3: equ 0 
981f			FORTH_PARSEV4: equ 0 
981f			FORTH_PARSEV5: equ 1 
981f			 
981f			;if FORTH_PARSEV5 
981f			;	FORTH_END_BUFFER: equ 0 
981f			;else 
981f			FORTH_END_BUFFER: equ 127 
981f			;endif 
981f			 
981f			FORTH_TRUE: equ 1 
981f			FORTH_FALSE: equ 0 
981f			 
981f			if FORTH_PARSEV4 
981f			include "forth_stackops.asm" 
981f			endif 
981f			 
981f			if FORTH_PARSEV5 
981f			include "forth_stackopsv5.asm" 
981f			 
981f			; Stack operations for v5 parser on wards 
981f			; * DATA stack 
981f			; * LOOP stack 
981f			; * RETURN stack 
981f			 
981f			 
981f			 
981f			FORTH_CHK_DSP_UNDER: macro 
981f				push hl 
981f				push de 
981f				ld hl,(cli_data_sp) 
981f				ld de, cli_data_stack 
981f				call cmp16 
981f				jp c, fault_dsp_under 
981f				pop de 
981f				pop hl 
981f				endm 
981f			 
981f			 
981f			FORTH_CHK_RSP_UNDER: macro 
981f				push hl 
981f				push de 
981f				ld hl,(cli_ret_sp) 
981f				ld de, cli_ret_stack 
981f				call cmp16 
981f				jp c, fault_rsp_under 
981f				pop de 
981f				pop hl 
981f				endm 
981f			 
981f			FORTH_CHK_LOOP_UNDER: macro 
981f				push hl 
981f				push de 
981f				ld hl,(cli_loop_sp) 
981f				ld de, cli_loop_stack 
981f				call cmp16 
981f				jp c, fault_loop_under 
981f				pop de 
981f				pop hl 
981f				endm 
981f			 
981f			FORTH_ERR_TOS_NOTSTR: macro 
981f				; TOSO might need more for checks when used 
981f				push af 
981f				ld a,(hl) 
981f				cp DS_TYPE_STR 
981f				jp nz, type_faultn   
981f				pop af 
981f				endm 
981f			 
981f			FORTH_ERR_TOS_NOTNUM: macro 
981f				push af 
981f				ld a,(hl) 
981f				cp DS_TYPE_INUM 
981f				jp nz, type_faultn   
981f				pop af 
981f				endm 
981f			 
981f			 
981f			; increase data stack pointer and save hl to it 
981f				 
981f			FORTH_DSP_NEXT: macro 
981f				call macro_forth_dsp_next 
981f				endm 
981f			 
981f			 
981f			macro_forth_dsp_next: 
981f				if DEBUG_FORTH_STACK_GUARD 
981f cd d2 d5				call check_stacks 
9822				endif 
9822 e5				push hl 
9823 d5				push de 
9824 eb				ex de,hl 
9825 2a 0d eb			ld hl,(cli_data_sp) 
9828 23				inc hl 
9829 23				inc hl 
982a			 
982a			; PARSEV5 
982a 23				inc hl 
982b 22 0d eb			ld (cli_data_sp),hl 
982e 73				ld (hl), e 
982f 23				inc hl 
9830 72				ld (hl), d 
9831 d1				pop de 
9832 e1				pop hl 
9833				if DEBUG_FORTH_STACK_GUARD 
9833 cd d2 d5				call check_stacks 
9836				endif 
9836 c9				ret 
9837			 
9837			 
9837			; increase ret stack pointer and save hl to it 
9837				 
9837			FORTH_RSP_NEXT: macro 
9837				call macro_forth_rsp_next 
9837				endm 
9837			 
9837			macro_forth_rsp_next: 
9837				if DEBUG_FORTH_STACK_GUARD 
9837 cd d2 d5				call check_stacks 
983a				endif 
983a e5				push hl 
983b d5				push de 
983c eb				ex de,hl 
983d 2a 11 eb			ld hl,(cli_ret_sp) 
9840 23				inc hl 
9841 23				inc hl 
9842 22 11 eb			ld (cli_ret_sp),hl 
9845 73				ld (hl), e 
9846 23				inc hl 
9847 72				ld (hl), d 
9848 d1				pop de 
9849 e1				pop hl 
984a				if DEBUG_FORTH_STACK_GUARD 
984a cd d2 d5				call check_stacks 
984d				endif 
984d c9				ret 
984e			 
984e			; get current ret stack pointer and save to hl  
984e				 
984e			FORTH_RSP_TOS: macro 
984e				call macro_forth_rsp_tos 
984e				endm 
984e			 
984e			macro_forth_rsp_tos: 
984e				;push de 
984e 2a 11 eb			ld hl,(cli_ret_sp) 
9851 cd 89 98			call loadhlptrtohl 
9854				;ld e, (hl) 
9854				;inc hl 
9854				;ld d, (hl) 
9854				;ex de, hl 
9854					if DEBUG_FORTH_WORDS 
9854			;			DMARK "RST" 
9854						CALLMONITOR 
9854 cd 03 93			call break_point_state  
9857				endm  
# End of macro CALLMONITOR
9857					endif 
9857				;pop de 
9857 c9				ret 
9858			 
9858			; pop ret stack pointer 
9858				 
9858			FORTH_RSP_POP: macro 
9858				call macro_forth_rsp_pop 
9858				endm 
9858			 
9858			 
9858			macro_forth_rsp_pop: 
9858				if DEBUG_FORTH_STACK_GUARD 
9858			;		DMARK "RPP" 
9858 cd d2 d5				call check_stacks 
985b					FORTH_CHK_RSP_UNDER 
985b e5				push hl 
985c d5				push de 
985d 2a 11 eb			ld hl,(cli_ret_sp) 
9860 11 cb ea			ld de, cli_ret_stack 
9863 cd c5 8a			call cmp16 
9866 da e6 d6			jp c, fault_rsp_under 
9869 d1				pop de 
986a e1				pop hl 
986b				endm 
# End of macro FORTH_CHK_RSP_UNDER
986b				endif 
986b e5				push hl 
986c 2a 11 eb			ld hl,(cli_ret_sp) 
986f			 
986f			 
986f				if FORTH_ENABLE_FREE 
986f			 
986f					; get pointer 
986f			 
986f					push de 
986f					push hl 
986f			 
986f					ld e, (hl) 
986f					inc hl 
986f					ld d, (hl) 
986f			 
986f					ex de, hl 
986f					call free 
986f			 
986f					pop hl 
986f					pop de 
986f			 
986f			 
986f				endif 
986f			 
986f			 
986f 2b				dec hl 
9870 2b				dec hl 
9871 22 11 eb			ld (cli_ret_sp), hl 
9874				; do stack underflow checks 
9874 e1				pop hl 
9875				if DEBUG_FORTH_STACK_GUARD 
9875 cd d2 d5				call check_stacks 
9878					FORTH_CHK_RSP_UNDER 
9878 e5				push hl 
9879 d5				push de 
987a 2a 11 eb			ld hl,(cli_ret_sp) 
987d 11 cb ea			ld de, cli_ret_stack 
9880 cd c5 8a			call cmp16 
9883 da e6 d6			jp c, fault_rsp_under 
9886 d1				pop de 
9887 e1				pop hl 
9888				endm 
# End of macro FORTH_CHK_RSP_UNDER
9888				endif 
9888 c9				ret 
9889			 
9889			 
9889			 
9889			; routine to load word pointed to by hl into hl 
9889			 
9889			loadhlptrtohl: 
9889			 
9889 d5				push de 
988a 5e				ld e, (hl) 
988b 23				inc hl 
988c 56				ld d, (hl) 
988d eb				ex de, hl 
988e d1				pop de 
988f			 
988f c9				ret 
9890			 
9890			 
9890			 
9890			 
9890			 
9890			; push a number held in HL onto the data stack 
9890			; entry point for pushing a value when already in hl used in function above 
9890			 
9890			forth_push_numhl: 
9890			 
9890 e5				push hl    ; save value to push 
9891			 
9891			if DEBUG_FORTH_PUSH 
9891				; see if disabled 
9891			 
9891			 
9891 f5				push af 
9892 3a 51 e3			ld a, (os_view_disable) 
9895 fe 2a			cp '*' 
9897 28 34			jr z, .pskip2 
9899 e5				push hl 
989a e5			push hl 
989b cd 7a 88			call clear_display 
989e e1			pop hl 
989f 7c				ld a,h 
98a0 21 65 e6			ld hl, os_word_scratch 
98a3 cd a8 8d			call hexout 
98a6 e1				pop hl 
98a7 7d				ld a,l 
98a8 21 67 e6			ld hl, os_word_scratch+2 
98ab cd a8 8d			call hexout 
98ae			 
98ae 21 69 e6			ld hl, os_word_scratch+4 
98b1 3e 00			ld a,0 
98b3 77				ld (hl),a 
98b4 11 65 e6			ld de,os_word_scratch 
98b7 3e 28				ld a, display_row_2 
98b9 cd 8d 88				call str_at_display 
98bc 11 e0 c4			ld de, .push_num 
98bf 3e 00			ld a, display_row_1 
98c1			 
98c1 cd 8d 88				call str_at_display 
98c4			 
98c4			 
98c4 cd 9d 88			call update_display 
98c7 cd fa 87			call delay1s 
98ca cd fa 87			call delay1s 
98cd			.pskip2:  
98cd			 
98cd f1				pop af 
98ce			endif	 
98ce			 
98ce			 
98ce				FORTH_DSP_NEXT 
98ce cd 1f 98			call macro_forth_dsp_next 
98d1				endm 
# End of macro FORTH_DSP_NEXT
98d1			 
98d1 2a 0d eb			ld hl, (cli_data_sp) 
98d4			 
98d4				; save item type 
98d4 3e 02			ld a,  DS_TYPE_INUM 
98d6 77				ld (hl), a 
98d7 23				inc hl 
98d8			 
98d8				; get word off stack 
98d8 d1				pop de 
98d9 7b				ld a,e 
98da 77				ld (hl), a 
98db 23				inc hl 
98dc 7a				ld a,d 
98dd 77				ld (hl), a 
98de			 
98de			if DEBUG_FORTH_PUSH 
98de 2b				dec hl 
98df 2b				dec hl 
98e0 2b				dec hl 
98e1						DMARK "PH5" 
98e1 f5				push af  
98e2 3a f6 98			ld a, (.dmark)  
98e5 32 7a ee			ld (debug_mark),a  
98e8 3a f7 98			ld a, (.dmark+1)  
98eb 32 7b ee			ld (debug_mark+1),a  
98ee 3a f8 98			ld a, (.dmark+2)  
98f1 32 7c ee			ld (debug_mark+2),a  
98f4 18 03			jr .pastdmark  
98f6 ..			.dmark: db "PH5"  
98f9 f1			.pastdmark: pop af  
98fa			endm  
# End of macro DMARK
98fa				CALLMONITOR 
98fa cd 03 93			call break_point_state  
98fd				endm  
# End of macro CALLMONITOR
98fd			endif	 
98fd			 
98fd c9				ret 
98fe			 
98fe			 
98fe			; Push a string to stack pointed to by hl 
98fe			 
98fe			forth_push_str: 
98fe			 
98fe			if DEBUG_FORTH_PUSH 
98fe						DMARK "PSQ" 
98fe f5				push af  
98ff 3a 13 99			ld a, (.dmark)  
9902 32 7a ee			ld (debug_mark),a  
9905 3a 14 99			ld a, (.dmark+1)  
9908 32 7b ee			ld (debug_mark+1),a  
990b 3a 15 99			ld a, (.dmark+2)  
990e 32 7c ee			ld (debug_mark+2),a  
9911 18 03			jr .pastdmark  
9913 ..			.dmark: db "PSQ"  
9916 f1			.pastdmark: pop af  
9917			endm  
# End of macro DMARK
9917				CALLMONITOR 
9917 cd 03 93			call break_point_state  
991a				endm  
# End of macro CALLMONITOR
991a			endif	 
991a			    
991a e5				push hl 
991b e5				push hl 
991c			 
991c			;	ld a, 0   ; find end of string 
991c cd 05 8f			call strlenz 
991f			if DEBUG_FORTH_PUSH 
991f						DMARK "PQ2" 
991f f5				push af  
9920 3a 34 99			ld a, (.dmark)  
9923 32 7a ee			ld (debug_mark),a  
9926 3a 35 99			ld a, (.dmark+1)  
9929 32 7b ee			ld (debug_mark+1),a  
992c 3a 36 99			ld a, (.dmark+2)  
992f 32 7c ee			ld (debug_mark+2),a  
9932 18 03			jr .pastdmark  
9934 ..			.dmark: db "PQ2"  
9937 f1			.pastdmark: pop af  
9938			endm  
# End of macro DMARK
9938				CALLMONITOR 
9938 cd 03 93			call break_point_state  
993b				endm  
# End of macro CALLMONITOR
993b			endif	 
993b eb				ex de, hl 
993c e1				pop hl   ; get ptr to start of string 
993d			if DEBUG_FORTH_PUSH 
993d						DMARK "PQ3" 
993d f5				push af  
993e 3a 52 99			ld a, (.dmark)  
9941 32 7a ee			ld (debug_mark),a  
9944 3a 53 99			ld a, (.dmark+1)  
9947 32 7b ee			ld (debug_mark+1),a  
994a 3a 54 99			ld a, (.dmark+2)  
994d 32 7c ee			ld (debug_mark+2),a  
9950 18 03			jr .pastdmark  
9952 ..			.dmark: db "PQ3"  
9955 f1			.pastdmark: pop af  
9956			endm  
# End of macro DMARK
9956				CALLMONITOR 
9956 cd 03 93			call break_point_state  
9959				endm  
# End of macro CALLMONITOR
9959			endif	 
9959 19				add hl,de 
995a			if DEBUG_FORTH_PUSH 
995a						DMARK "PQE" 
995a f5				push af  
995b 3a 6f 99			ld a, (.dmark)  
995e 32 7a ee			ld (debug_mark),a  
9961 3a 70 99			ld a, (.dmark+1)  
9964 32 7b ee			ld (debug_mark+1),a  
9967 3a 71 99			ld a, (.dmark+2)  
996a 32 7c ee			ld (debug_mark+2),a  
996d 18 03			jr .pastdmark  
996f ..			.dmark: db "PQE"  
9972 f1			.pastdmark: pop af  
9973			endm  
# End of macro DMARK
9973				CALLMONITOR 
9973 cd 03 93			call break_point_state  
9976				endm  
# End of macro CALLMONITOR
9976			endif	 
9976			 
9976 2b				dec hl    ; see if there is an optional trailing double quote 
9977 7e				ld a,(hl) 
9978 fe 22			cp '"' 
997a 20 03			jr nz, .strnoq 
997c 3e 00			ld a, 0      ; get rid of double quote 
997e 77				ld (hl), a 
997f 23			.strnoq: inc hl 
9980			 
9980 3e 00			ld a, 0 
9982 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9983			 
9983 13				inc de ; add one for the type string 
9984 13				inc de ; add one for null term??? 
9985			 
9985				; tos is get string pointer again 
9985				; de contains space to allocate 
9985				 
9985 d5				push de 
9986			 
9986 eb				ex de, hl 
9987			 
9987				;push af 
9987			 
9987			if DEBUG_FORTH_PUSH 
9987						DMARK "PHm" 
9987 f5				push af  
9988 3a 9c 99			ld a, (.dmark)  
998b 32 7a ee			ld (debug_mark),a  
998e 3a 9d 99			ld a, (.dmark+1)  
9991 32 7b ee			ld (debug_mark+1),a  
9994 3a 9e 99			ld a, (.dmark+2)  
9997 32 7c ee			ld (debug_mark+2),a  
999a 18 03			jr .pastdmark  
999c ..			.dmark: db "PHm"  
999f f1			.pastdmark: pop af  
99a0			endm  
# End of macro DMARK
99a0				CALLMONITOR 
99a0 cd 03 93			call break_point_state  
99a3				endm  
# End of macro CALLMONITOR
99a3			endif	 
99a3 cd 6e 8f			call malloc	; on ret hl now contains allocated memory 
99a6				if DEBUG_FORTH_MALLOC_GUARD 
99a6 cc 38 c5				call z,malloc_error 
99a9				endif 
99a9			 
99a9				 
99a9 c1				pop bc    ; get length 
99aa d1				pop de   ;  get string start    
99ab			 
99ab				; hl has destination from malloc 
99ab			 
99ab eb				ex de, hl    ; prep for ldir 
99ac			 
99ac d5				push de   ; save malloc area for DSP later 
99ad				;push hl   ; save malloc area for DSP later 
99ad			 
99ad			if DEBUG_FORTH_PUSH 
99ad						DMARK "PHc" 
99ad f5				push af  
99ae 3a c2 99			ld a, (.dmark)  
99b1 32 7a ee			ld (debug_mark),a  
99b4 3a c3 99			ld a, (.dmark+1)  
99b7 32 7b ee			ld (debug_mark+1),a  
99ba 3a c4 99			ld a, (.dmark+2)  
99bd 32 7c ee			ld (debug_mark+2),a  
99c0 18 03			jr .pastdmark  
99c2 ..			.dmark: db "PHc"  
99c5 f1			.pastdmark: pop af  
99c6			endm  
# End of macro DMARK
99c6				CALLMONITOR 
99c6 cd 03 93			call break_point_state  
99c9				endm  
# End of macro CALLMONITOR
99c9			endif	 
99c9			 
99c9			 
99c9 ed b0			ldir 
99cb			 
99cb			 
99cb				; push malloc to data stack     macro?????  
99cb			 
99cb				FORTH_DSP_NEXT 
99cb cd 1f 98			call macro_forth_dsp_next 
99ce				endm 
# End of macro FORTH_DSP_NEXT
99ce			 
99ce				; save value and type 
99ce			 
99ce 2a 0d eb			ld hl, (cli_data_sp) 
99d1			 
99d1				; save item type 
99d1 3e 01			ld a,  DS_TYPE_STR 
99d3 77				ld (hl), a 
99d4 23				inc hl 
99d5			 
99d5				; get malloc word off stack 
99d5 d1				pop de 
99d6 73				ld (hl), e 
99d7 23				inc hl 
99d8 72				ld (hl), d 
99d9			 
99d9			 
99d9			 
99d9			if DEBUG_FORTH_PUSH 
99d9 2a 0d eb			ld hl, (cli_data_sp) 
99dc						DMARK "PHS" 
99dc f5				push af  
99dd 3a f1 99			ld a, (.dmark)  
99e0 32 7a ee			ld (debug_mark),a  
99e3 3a f2 99			ld a, (.dmark+1)  
99e6 32 7b ee			ld (debug_mark+1),a  
99e9 3a f3 99			ld a, (.dmark+2)  
99ec 32 7c ee			ld (debug_mark+2),a  
99ef 18 03			jr .pastdmark  
99f1 ..			.dmark: db "PHS"  
99f4 f1			.pastdmark: pop af  
99f5			endm  
# End of macro DMARK
99f5				CALLMONITOR 
99f5 cd 03 93			call break_point_state  
99f8				endm  
# End of macro CALLMONITOR
99f8			;	ex de,hl 
99f8			endif	 
99f8				; in case of spaces, skip the ptr past the copied string 
99f8				;pop af 
99f8				;ld (cli_origptr),hl 
99f8			 
99f8 c9				ret 
99f9			 
99f9			 
99f9			 
99f9			; TODO ascii push input onto stack given hl to start of input 
99f9			 
99f9			; identify type 
99f9			; if starts with a " then a string 
99f9			; otherwise it is a number 
99f9			;  
99f9			; if a string 
99f9			;     scan for ending " to get length of string to malloc for + 1 
99f9			;     malloc 
99f9			;     put pointer to string on stack first byte flags as string 
99f9			; 
99f9			; else a number 
99f9			;    look for number format identifier 
99f9			;    $xx hex 
99f9			;    %xxxxx bin 
99f9			;    xxxxx decimal 
99f9			;    convert number to 16bit word.  
99f9			;    malloc word + 1 with flag to identiy as num 
99f9			;    put pointer to number on stack 
99f9			;   
99f9			;  
99f9			  
99f9			forth_apush: 
99f9				; kernel push 
99f9			 
99f9			if DEBUG_FORTH_PUSH 
99f9						DMARK "PSH" 
99f9 f5				push af  
99fa 3a 0e 9a			ld a, (.dmark)  
99fd 32 7a ee			ld (debug_mark),a  
9a00 3a 0f 9a			ld a, (.dmark+1)  
9a03 32 7b ee			ld (debug_mark+1),a  
9a06 3a 10 9a			ld a, (.dmark+2)  
9a09 32 7c ee			ld (debug_mark+2),a  
9a0c 18 03			jr .pastdmark  
9a0e ..			.dmark: db "PSH"  
9a11 f1			.pastdmark: pop af  
9a12			endm  
# End of macro DMARK
9a12				CALLMONITOR 
9a12 cd 03 93			call break_point_state  
9a15				endm  
# End of macro CALLMONITOR
9a15			endif	 
9a15				; identify input type 
9a15			 
9a15 7e				ld a,(hl) 
9a16 fe 22			cp '"' 
9a18 28 0a			jr z, .fapstr 
9a1a fe 24			cp '$' 
9a1c ca 44 9a			jp z, .faphex 
9a1f fe 25			cp '%' 
9a21 ca 2c 9a			jp z, .fapbin 
9a24			;	cp 'b' 
9a24			;	jp z, .fabin 
9a24				; else decimal 
9a24			 
9a24				; TODO do decimal conversion 
9a24				; decimal is stored as a 16bit word 
9a24			 
9a24				; by default everything is a string if type is not detected 
9a24			.fapstr: ; 
9a24 fe 22			cp '"' 
9a26 20 01			jr nz, .strnoqu 
9a28 23				inc hl 
9a29			.strnoqu: 
9a29 c3 fe 98			jp forth_push_str 
9a2c			 
9a2c			 
9a2c			 
9a2c			.fapbin:    ; push a binary string.  
9a2c 11 00 00			ld de, 0   ; hold a 16bit value 
9a2f			 
9a2f 23			.fapbinshift:	inc hl  
9a30 7e				ld a,(hl) 
9a31 fe 00			cp 0     ; done scanning  
9a33 28 0b			jr z, .fapbdone  	; got it in HL so push  
9a35			 
9a35				; left shift de 
9a35 eb				ex de, hl	 
9a36 29				add hl, hl 
9a37			 
9a37				; is 1 
9a37 fe 31			cp '1' 
9a39 20 02			jr nz, .binzero 
9a3b cb 4d			bit 1, l 
9a3d			.binzero: 
9a3d eb				ex de, hl	 ; save current de 
9a3e 18 ef			jr .fapbinshift 
9a40			 
9a40			.fapbdone: 
9a40 eb				ex de, hl 
9a41 c3 90 98			jp forth_push_numhl 
9a44			 
9a44			 
9a44			.faphex:   ; hex is always stored as a 16bit word 
9a44				; skip number prefix 
9a44 23				inc hl 
9a45				; turn ascii into number 
9a45 cd 5e 8e			call get_word_hl	; ret 16bit word in hl 
9a48			 
9a48 c3 90 98			jp forth_push_numhl 
9a4b			 
9a4b 00				 nop 
9a4c			 
9a4c			.fabin:   ; TODO bin conversion 
9a4c			 
9a4c			 
9a4c c9				ret 
9a4d			 
9a4d			 
9a4d			; get either a string ptr or a 16bit word from the data stack 
9a4d			 
9a4d			FORTH_DSP: macro 
9a4d				call macro_forth_dsp 
9a4d				endm 
9a4d			 
9a4d			macro_forth_dsp: 
9a4d				; data stack pointer points to current word on tos 
9a4d			 
9a4d 2a 0d eb			ld hl,(cli_data_sp) 
9a50			 
9a50				if DEBUG_FORTH_PUSH 
9a50						DMARK "DSP" 
9a50 f5				push af  
9a51 3a 65 9a			ld a, (.dmark)  
9a54 32 7a ee			ld (debug_mark),a  
9a57 3a 66 9a			ld a, (.dmark+1)  
9a5a 32 7b ee			ld (debug_mark+1),a  
9a5d 3a 67 9a			ld a, (.dmark+2)  
9a60 32 7c ee			ld (debug_mark+2),a  
9a63 18 03			jr .pastdmark  
9a65 ..			.dmark: db "DSP"  
9a68 f1			.pastdmark: pop af  
9a69			endm  
# End of macro DMARK
9a69			 
9a69 cd 6d c5				call display_data_sp 
9a6c				;call break_point_state 
9a6c				;rst 030h 
9a6c				CALLMONITOR 
9a6c cd 03 93			call break_point_state  
9a6f				endm  
# End of macro CALLMONITOR
9a6f				endif 
9a6f			 
9a6f c9				ret 
9a70			 
9a70			; return hl to start of value on stack 
9a70			 
9a70			FORTH_DSP_VALUE: macro 
9a70				call macro_forth_dsp_value 
9a70				endm 
9a70			 
9a70			macro_forth_dsp_value: 
9a70			 
9a70				FORTH_DSP 
9a70 cd 4d 9a			call macro_forth_dsp 
9a73				endm 
# End of macro FORTH_DSP
9a73			 
9a73 d5				push de 
9a74			 
9a74 23				inc hl ; skip type 
9a75			 
9a75 5e				ld e, (hl) 
9a76 23				inc hl 
9a77 56				ld d, (hl) 
9a78 eb				ex de,hl  
9a79			 
9a79 d1				pop de 
9a7a			 
9a7a c9				ret 
9a7b			 
9a7b			; return hl to start of value to second item on stack 
9a7b			 
9a7b			FORTH_DSP_VALUEM1: macro 
9a7b				call macro_forth_dsp_value_m1 
9a7b				endm 
9a7b			 
9a7b			macro_forth_dsp_value_m1: 
9a7b			 
9a7b				FORTH_DSP 
9a7b cd 4d 9a			call macro_forth_dsp 
9a7e				endm 
# End of macro FORTH_DSP
9a7e			 
9a7e 2b				dec hl 
9a7f 2b				dec hl 
9a80			;	dec hl 
9a80			 
9a80 d5				push de 
9a81			 
9a81 5e				ld e, (hl) 
9a82 23				inc hl 
9a83 56				ld d, (hl) 
9a84 eb				ex de,hl  
9a85			 
9a85 d1				pop de 
9a86			 
9a86 c9				ret 
9a87			 
9a87				 
9a87			 
9a87			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9a87			 
9a87			FORTH_DSP_POP: macro 
9a87				call macro_forth_dsp_pop 
9a87				endm 
9a87			 
9a87			 
9a87			; get the tos data type 
9a87			 
9a87			FORTH_DSP_TYPE:   macro 
9a87			 
9a87				;FORTH_DSP_VALUE 
9a87				FORTH_DSP 
9a87				 
9a87				; hl points to value 
9a87				; check type 
9a87			 
9a87				ld a,(hl) 
9a87			 
9a87				endm 
9a87			 
9a87			; load the tos value into hl 
9a87			 
9a87			 
9a87			FORTH_DSP_VALUEHL:  macro 
9a87				call macro_dsp_valuehl 
9a87				endm 
9a87			 
9a87			 
9a87			 
9a87			macro_dsp_valuehl: 
9a87				FORTH_DSP_VALUE 
9a87 cd 70 9a			call macro_forth_dsp_value 
9a8a				endm 
# End of macro FORTH_DSP_VALUE
9a8a			 
9a8a				;FORTH_ERR_TOS_NOTNUM 
9a8a			 
9a8a				;inc hl   ; skip type id 
9a8a			 
9a8a			;	push de 
9a8a			; 
9a8a			;	ld e, (hl) 
9a8a			;	inc hl 
9a8a			;	ld d, (hl) 
9a8a			;	ex de,hl  
9a8a			 
9a8a			;	pop de 
9a8a			 
9a8a				if DEBUG_FORTH_PUSH 
9a8a						DMARK "DVL" 
9a8a f5				push af  
9a8b 3a 9f 9a			ld a, (.dmark)  
9a8e 32 7a ee			ld (debug_mark),a  
9a91 3a a0 9a			ld a, (.dmark+1)  
9a94 32 7b ee			ld (debug_mark+1),a  
9a97 3a a1 9a			ld a, (.dmark+2)  
9a9a 32 7c ee			ld (debug_mark+2),a  
9a9d 18 03			jr .pastdmark  
9a9f ..			.dmark: db "DVL"  
9aa2 f1			.pastdmark: pop af  
9aa3			endm  
# End of macro DMARK
9aa3				CALLMONITOR 
9aa3 cd 03 93			call break_point_state  
9aa6				endm  
# End of macro CALLMONITOR
9aa6				endif 
9aa6 c9				ret 
9aa7			 
9aa7			forth_apushstrhl:      
9aa7				; push of string requires use of cli_origptr 
9aa7				; bodge use 
9aa7			 
9aa7				; get current cli_origptr, save, update with temp pointer  
9aa7 ed 5b 29 eb		ld de, (cli_origptr) 
9aab 22 29 eb			ld (cli_origptr), hl 
9aae d5				push de 
9aaf cd f9 99			call forth_apush 
9ab2 d1				pop de 
9ab3 ed 53 29 eb		ld (cli_origptr), de 
9ab7 c9			        ret	 
9ab8			 
9ab8			 
9ab8			; increase loop stack pointer and save hl to it 
9ab8				 
9ab8			FORTH_LOOP_NEXT: macro 
9ab8				call macro_forth_loop_next 
9ab8				;nop 
9ab8				endm 
9ab8			 
9ab8			macro_forth_loop_next: 
9ab8				if DEBUG_FORTH_STACK_GUARD 
9ab8 cd d2 d5				call check_stacks 
9abb				endif 
9abb e5				push hl 
9abc d5				push de 
9abd eb				ex de,hl 
9abe 2a 0f eb			ld hl,(cli_loop_sp) 
9ac1 23				inc hl 
9ac2 23				inc hl 
9ac3					if DEBUG_FORTH_WORDS 
9ac3						DMARK "LNX" 
9ac3 f5				push af  
9ac4 3a d8 9a			ld a, (.dmark)  
9ac7 32 7a ee			ld (debug_mark),a  
9aca 3a d9 9a			ld a, (.dmark+1)  
9acd 32 7b ee			ld (debug_mark+1),a  
9ad0 3a da 9a			ld a, (.dmark+2)  
9ad3 32 7c ee			ld (debug_mark+2),a  
9ad6 18 03			jr .pastdmark  
9ad8 ..			.dmark: db "LNX"  
9adb f1			.pastdmark: pop af  
9adc			endm  
# End of macro DMARK
9adc						CALLMONITOR 
9adc cd 03 93			call break_point_state  
9adf				endm  
# End of macro CALLMONITOR
9adf					endif 
9adf 22 0f eb			ld (cli_loop_sp),hl 
9ae2 73				ld (hl), e 
9ae3 23				inc hl 
9ae4 72				ld (hl), d 
9ae5 d1				pop de    ; been reversed so save a swap on restore 
9ae6 e1				pop hl 
9ae7				if DEBUG_FORTH_STACK_GUARD 
9ae7 cd d2 d5				call check_stacks 
9aea				endif 
9aea c9				ret 
9aeb			 
9aeb			; get current ret stack pointer and save to hl  
9aeb				 
9aeb			FORTH_LOOP_TOS: macro 
9aeb				call macro_forth_loop_tos 
9aeb				endm 
9aeb			 
9aeb			macro_forth_loop_tos: 
9aeb d5				push de 
9aec 2a 0f eb			ld hl,(cli_loop_sp) 
9aef 5e				ld e, (hl) 
9af0 23				inc hl 
9af1 56				ld d, (hl) 
9af2 eb				ex de, hl 
9af3 d1				pop de 
9af4 c9				ret 
9af5			 
9af5			; pop loop stack pointer 
9af5				 
9af5			FORTH_LOOP_POP: macro 
9af5				call macro_forth_loop_pop 
9af5				endm 
9af5			 
9af5			 
9af5			macro_forth_loop_pop: 
9af5				if DEBUG_FORTH_STACK_GUARD 
9af5					DMARK "LPP" 
9af5 f5				push af  
9af6 3a 0a 9b			ld a, (.dmark)  
9af9 32 7a ee			ld (debug_mark),a  
9afc 3a 0b 9b			ld a, (.dmark+1)  
9aff 32 7b ee			ld (debug_mark+1),a  
9b02 3a 0c 9b			ld a, (.dmark+2)  
9b05 32 7c ee			ld (debug_mark+2),a  
9b08 18 03			jr .pastdmark  
9b0a ..			.dmark: db "LPP"  
9b0d f1			.pastdmark: pop af  
9b0e			endm  
# End of macro DMARK
9b0e cd d2 d5				call check_stacks 
9b11					FORTH_CHK_LOOP_UNDER 
9b11 e5				push hl 
9b12 d5				push de 
9b13 2a 0f eb			ld hl,(cli_loop_sp) 
9b16 11 c9 e9			ld de, cli_loop_stack 
9b19 cd c5 8a			call cmp16 
9b1c da ec d6			jp c, fault_loop_under 
9b1f d1				pop de 
9b20 e1				pop hl 
9b21				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9b21				endif 
9b21 e5				push hl 
9b22 2a 0f eb			ld hl,(cli_loop_sp) 
9b25 2b				dec hl 
9b26 2b				dec hl 
9b27 22 0f eb			ld (cli_loop_sp), hl 
9b2a				; TODO do stack underflow checks 
9b2a e1				pop hl 
9b2b				if DEBUG_FORTH_STACK_GUARD 
9b2b cd d2 d5				call check_stacks 
9b2e					FORTH_CHK_LOOP_UNDER 
9b2e e5				push hl 
9b2f d5				push de 
9b30 2a 0f eb			ld hl,(cli_loop_sp) 
9b33 11 c9 e9			ld de, cli_loop_stack 
9b36 cd c5 8a			call cmp16 
9b39 da ec d6			jp c, fault_loop_under 
9b3c d1				pop de 
9b3d e1				pop hl 
9b3e				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9b3e				endif 
9b3e c9				ret 
9b3f			 
9b3f			macro_forth_dsp_pop: 
9b3f			 
9b3f e5				push hl 
9b40			 
9b40				; release malloc data 
9b40			 
9b40				if DEBUG_FORTH_STACK_GUARD 
9b40 cd d2 d5				call check_stacks 
9b43					FORTH_CHK_DSP_UNDER 
9b43 e5				push hl 
9b44 d5				push de 
9b45 2a 0d eb			ld hl,(cli_data_sp) 
9b48 11 c7 e8			ld de, cli_data_stack 
9b4b cd c5 8a			call cmp16 
9b4e da e0 d6			jp c, fault_dsp_under 
9b51 d1				pop de 
9b52 e1				pop hl 
9b53				endm 
# End of macro FORTH_CHK_DSP_UNDER
9b53				endif 
9b53				;ld hl,(cli_data_sp) 
9b53			if DEBUG_FORTH_DOT 
9b53				DMARK "DPP" 
9b53				CALLMONITOR 
9b53			endif	 
9b53			 
9b53			 
9b53			if FORTH_ENABLE_DSPPOPFREE 
9b53			 
9b53				FORTH_DSP 
9b53 cd 4d 9a			call macro_forth_dsp 
9b56				endm 
# End of macro FORTH_DSP
9b56			 
9b56 7e				ld a, (hl) 
9b57 fe 01			cp DS_TYPE_STR 
9b59 20 07			jr nz, .skippopfree 
9b5b			 
9b5b				FORTH_DSP_VALUEHL 
9b5b cd 87 9a			call macro_dsp_valuehl 
9b5e				endm 
# End of macro FORTH_DSP_VALUEHL
9b5e 00				nop 
9b5f			if DEBUG_FORTH_DOT 
9b5f				DMARK "DPf" 
9b5f				CALLMONITOR 
9b5f			endif	 
9b5f cd 38 90			call free 
9b62			.skippopfree: 
9b62				 
9b62			 
9b62			endif 
9b62			 
9b62			if DEBUG_FORTH_DOT_KEY 
9b62				DMARK "DP2" 
9b62				CALLMONITOR 
9b62			endif	 
9b62			 
9b62				; move pointer down 
9b62			 
9b62 2a 0d eb			ld hl,(cli_data_sp) 
9b65 2b				dec hl 
9b66 2b				dec hl 
9b67			; PARSEV5 
9b67 2b				dec hl 
9b68 22 0d eb			ld (cli_data_sp), hl 
9b6b			 
9b6b				if DEBUG_FORTH_STACK_GUARD 
9b6b cd d2 d5				call check_stacks 
9b6e					FORTH_CHK_DSP_UNDER 
9b6e e5				push hl 
9b6f d5				push de 
9b70 2a 0d eb			ld hl,(cli_data_sp) 
9b73 11 c7 e8			ld de, cli_data_stack 
9b76 cd c5 8a			call cmp16 
9b79 da e0 d6			jp c, fault_dsp_under 
9b7c d1				pop de 
9b7d e1				pop hl 
9b7e				endm 
# End of macro FORTH_CHK_DSP_UNDER
9b7e				endif 
9b7e			 
9b7e e1				pop hl 
9b7f			 
9b7f c9				ret 
9b80			 
9b80			getwordathl: 
9b80				; hl points to an address 
9b80				; load hl with the word at that address 
9b80			 
9b80 d5				push de 
9b81			 
9b81 5e				ld e, (hl) 
9b82 23				inc hl 
9b83 56				ld d, (hl) 
9b84 eb				ex de, hl 
9b85			 
9b85 d1				pop de 
9b86 c9				ret 
9b87			 
9b87			 
9b87			 
9b87			 
9b87			 
9b87			; eof 
9b87			 
# End of file forth_stackopsv5.asm
9b87			endif 
9b87			 
9b87			user_word_eol:  
9b87				; hl contains the pointer to where to create a linked list item from the end 
9b87				; of the user dict to continue on at the system word dict 
9b87				 
9b87				; poke the stub of the word list linked list to repoint to rom words 
9b87			 
9b87				; stub format 
9b87				; db   word id 
9b87				; dw    link to next word 
9b87			        ; db char length of token 
9b87				; db string + 0 term 
9b87				; db exec code....  
9b87			 
9b87 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9b89 77				ld (hl), a		; word id 
9b8a 23				inc hl 
9b8b			 
9b8b 11 51 9d			ld de, sysdict 
9b8e 73				ld (hl), e		; next word link ie system dict 
9b8f 23				inc hl 
9b90 72				ld (hl), d		; next word link ie system dict 
9b91 23				inc hl	 
9b92			 
9b92			;	ld (hl), sysdict		; next word link ie system dict 
9b92			;	inc hl 
9b92			;	inc hl 
9b92			 
9b92			;	inc hl 
9b92			;	inc hl 
9b92			 
9b92 3e 02			ld a, 2			; word length is 0 
9b94 77				ld (hl), a	 
9b95 23				inc hl 
9b96			 
9b96 3e 7e			ld a, '~'			; word length is 0 
9b98 77				ld (hl), a	 
9b99 23				inc hl 
9b9a 3e 00			ld a, 0			; save empty word 
9b9c 77				ld (hl), a 
9b9d			 
9b9d c9				ret 
9b9e			 
9b9e				 
9b9e			 
9b9e			forthexec_cleanup: 
9b9e				FORTH_RSP_POP 
9b9e cd 58 98			call macro_forth_rsp_pop 
9ba1				endm 
# End of macro FORTH_RSP_POP
9ba1 c9				ret 
9ba2			 
9ba2			forth_call_hl: 
9ba2				; taking hl 
9ba2 e5				push hl 
9ba3 c9				ret 
9ba4			 
9ba4			; this is called to reset Forth system but keep existing uwords etc 
9ba4			 
9ba4			forth_warmstart: 
9ba4				; setup stack over/under flow checks 
9ba4				if DEBUG_FORTH_STACK_GUARD 
9ba4 cd b8 d5				call chk_stk_init 
9ba7				endif 
9ba7			 
9ba7				; init stack pointers  - * these stacks go upwards *  
9ba7 21 cb ea			ld hl, cli_ret_stack 
9baa 22 11 eb			ld (cli_ret_sp), hl	 
9bad				; set bottom of stack 
9bad 3e 00			ld a,0 
9baf 77				ld (hl),a 
9bb0 23				inc hl 
9bb1 77				ld (hl),a 
9bb2			 
9bb2 21 c7 e8			ld hl, cli_data_stack 
9bb5 22 0d eb			ld (cli_data_sp), hl	 
9bb8				; set bottom of stack 
9bb8 3e 00			ld a,0 
9bba 77				ld (hl),a 
9bbb 23				inc hl 
9bbc 77				ld (hl),a 
9bbd			 
9bbd 21 c9 e9			ld hl, cli_loop_stack 
9bc0 22 0f eb			ld (cli_loop_sp), hl	 
9bc3				; set bottom of stack 
9bc3 3e 00			ld a,0 
9bc5 77				ld (hl),a 
9bc6 23				inc hl 
9bc7 77				ld (hl),a 
9bc8			 
9bc8				; init extent of current open file 
9bc8			 
9bc8 3e 00			ld a, 0 
9bca 32 5c eb			ld (store_openext), a 
9bcd			 
9bcd c9				ret 
9bce			 
9bce			 
9bce			; Cold Start - this is called to setup the whole Forth system 
9bce			 
9bce			forth_init: 
9bce			 
9bce				; setup stack over/under flow checks 
9bce			 
9bce			;	if DEBUG_FORTH_STACK_GUARD 
9bce			;		call chk_stk_init 
9bce			;	endif 
9bce			 
9bce				; enable auto display updates (slow.....) 
9bce			 
9bce 3e 01			ld a, 1 
9bd0 32 27 eb			ld (cli_autodisplay), a 
9bd3			 
9bd3			 
9bd3			 
9bd3				; show start up screen 
9bd3			 
9bd3 cd 7a 88			call clear_display 
9bd6			 
9bd6 3e 00			ld a,0 
9bd8 32 49 eb			ld (f_cursor_ptr), a 
9bdb			 
9bdb				; set start of word list in start of ram - for use when creating user words 
9bdb			 
9bdb 21 83 d8			ld hl, baseram 
9bde 22 5d e6			ld (os_last_new_uword), hl 
9be1 cd 87 9b			call user_word_eol 
9be4				 
9be4			;		call display_data_sp 
9be4			;		call next_page_prompt 
9be4			 
9be4			 
9be4			 
9be4			 
9be4 c9				ret 
9be5			 
9be5 .. 00		.bootforth: db " Forth Kernel Init ",0 
9bf9			 
9bf9			; TODO push to stack 
9bf9			 
9bf9			;  
9bf9			 
9bf9			if FORTH_PARSEV2 
9bf9			 
9bf9			 
9bf9				include "forth_parserv2.asm" 
9bf9			 
9bf9			endif 
9bf9			 
9bf9			 
9bf9			; parse cli version 1 
9bf9			 
9bf9			if FORTH_PARSEV1 
9bf9			 
9bf9			 
9bf9			 
9bf9			      include "forth_parserv1.asm" 
9bf9			endif 
9bf9				 
9bf9			if FORTH_PARSEV3 
9bf9			 
9bf9			 
9bf9			 
9bf9			      include "forth_parserv3.asm" 
9bf9				include "forth_wordsv3.asm" 
9bf9			endif 
9bf9			 
9bf9			if FORTH_PARSEV4 
9bf9			 
9bf9			 
9bf9			 
9bf9			      include "forth_parserv4.asm" 
9bf9				include "forth_wordsv4.asm" 
9bf9			endif 
9bf9			 
9bf9			if FORTH_PARSEV5 
9bf9			 
9bf9			 
9bf9			 
9bf9			      include "forth_parserv5.asm" 
9bf9			 
9bf9			 
9bf9			; A better parser without using malloc and string copies all over the place.  
9bf9			; Exec in situ should be faster 
9bf9			 
9bf9			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9bf9			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9bf9			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9bf9			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9bf9			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9bf9			WORD_SYS_END: equ 0   ; Opcode for all user words 
9bf9			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9bf9			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9bf9			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9bf9			 
9bf9			; Core word preamble macro 
9bf9			 
9bf9			CWHEAD:   macro nxtword opcode lit len opflags 
9bf9				db WORD_SYS_CORE+opcode             
9bf9				; internal op code number 
9bf9				dw nxtword            
9bf9				; link to next dict word block 
9bf9				db len + 1 
9bf9				; literal length of dict word inc zero term 
9bf9				db lit,0              
9bf9				; literal dict word 
9bf9			        ; TODO db opflags        
9bf9				endm 
9bf9			 
9bf9			 
9bf9			NEXTW: macro  
9bf9				jp macro_next 
9bf9				endm 
9bf9			 
9bf9			macro_next: 
9bf9			if DEBUG_FORTH_PARSE_KEY 
9bf9				DMARK "NXT" 
9bf9				CALLMONITOR 
9bf9			endif	 
9bf9			;	inc hl  ; skip token null term  
9bf9 ed 4b 2b eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9bfd ed 5b 29 eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9c01 2a 61 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9c04			if DEBUG_FORTH_PARSE_KEY 
9c04				DMARK "}AA" 
9c04				CALLMONITOR 
9c04			endif	 
9c04 c3 07 9d			jp execnext 
9c07				;jp exec1 
9c07			       
9c07			 
9c07			 
9c07			; Another go at the parser to compile  
9c07			 
9c07			 
9c07			; TODO rework parser to change all of the string words to byte tokens 
9c07			; TODO do a search for  
9c07			 
9c07			; TODO first run normal parser to zero term sections 
9c07			; TODO for each word do a token look up to get the op code 
9c07			; TODO need some means to flag to the exec that this is a byte code form    
9c07			 
9c07			 
9c07			forthcompile: 
9c07			 
9c07			; 
9c07			; line parse: 
9c07			;       parse raw input buffer 
9c07			;       tokenise the words 
9c07			;       malloc new copy (for looping etc) 
9c07			;       copy to malloc + current pc in line to start of string and add line term 
9c07			;       save on new rsp 
9c07			; 
9c07			 
9c07			; hl to point to the line to tokenise 
9c07			 
9c07			;	push hl 
9c07 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
9c0a			 
9c0a			;	ld a,0		; string term on input 
9c0a			;	call strlent 
9c0a			 
9c0a			;	ld (os_tok_len), hl	 ; save string length 
9c0a			 
9c0a			;if DEBUG_FORTH_TOK 
9c0a			;	ex de,hl		 
9c0a			;endif 
9c0a			 
9c0a			;	pop hl 		; get back string pointer 
9c0a			 
9c0a			if DEBUG_FORTH_TOK 
9c0a						DMARK "TOc" 
9c0a				CALLMONITOR 
9c0a			endif 
9c0a 7e			.cptoken2:    ld a,(hl) 
9c0b 23				inc hl 
9c0c fe 7f			cp FORTH_END_BUFFER 
9c0e 28 29			jr z, .cptokendone2 
9c10 fe 00			cp 0 
9c12 28 25			jr z, .cptokendone2 
9c14 fe 22			cp '"' 
9c16 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9c18 fe 20			cp ' ' 
9c1a 20 ee			jr nz,  .cptoken2 
9c1c			 
9c1c			; TODO consume comments held between ( and ) 
9c1c			 
9c1c				; we have a space so change to zero term for dict match later 
9c1c 2b				dec hl 
9c1d 3e 00			ld a,0 
9c1f 77				ld (hl), a 
9c20 23				inc hl 
9c21 18 e7			jr .cptoken2 
9c23				 
9c23			 
9c23			.cptokenstr2: 
9c23				; skip all white space until either eol (because forgot to term) or end double quote 
9c23			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9c23				;inc hl ; skip current double quote 
9c23 7e				ld a,(hl) 
9c24 23				inc hl 
9c25 fe 22			cp '"' 
9c27 28 e1			jr z, .cptoken2 
9c29 fe 7f			cp FORTH_END_BUFFER 
9c2b 28 0c			jr z, .cptokendone2 
9c2d fe 00			cp 0 
9c2f 28 08			jr z, .cptokendone2 
9c31 fe 20			cp ' ' 
9c33 28 02			jr z, .cptmp2 
9c35 18 ec			jr .cptokenstr2 
9c37			 
9c37			.cptmp2:	; we have a space so change to zero term for dict match later 
9c37				;dec hl 
9c37				;ld a,"-"	; TODO remove this when working 
9c37				;ld (hl), a 
9c37				;inc hl 
9c37 18 ea			jr .cptokenstr2 
9c39			 
9c39			.cptokendone2: 
9c39				;inc hl 
9c39 3e 7f			ld a, FORTH_END_BUFFER 
9c3b 77				ld (hl),a 
9c3c 23				inc hl 
9c3d 3e 21			ld a, '!' 
9c3f 77				ld (hl),a 
9c40			 
9c40 2a 61 e6			ld hl,(os_tok_ptr) 
9c43			         
9c43			if DEBUG_FORTH_TOK 
9c43						DMARK "Tc1" 
9c43				CALLMONITOR 
9c43			endif 
9c43			 
9c43				; push exec string to top of return stack 
9c43				FORTH_RSP_NEXT 
9c43 cd 37 98			call macro_forth_rsp_next 
9c46				endm 
# End of macro FORTH_RSP_NEXT
9c46 c9				ret 
9c47			 
9c47			; Another go at the parser need to simplify the process 
9c47			 
9c47			forthparse: 
9c47			 
9c47			; 
9c47			; line parse: 
9c47			;       parse raw input buffer 
9c47			;       tokenise the words 
9c47			;       malloc new copy (for looping etc) 
9c47			;       copy to malloc + current pc in line to start of string and add line term 
9c47			;       save on new rsp 
9c47			; 
9c47			 
9c47			; hl to point to the line to tokenise 
9c47			 
9c47			;	push hl 
9c47 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
9c4a			 
9c4a			;	ld a,0		; string term on input 
9c4a			;	call strlent 
9c4a			 
9c4a			;	ld (os_tok_len), hl	 ; save string length 
9c4a			 
9c4a			;if DEBUG_FORTH_TOK 
9c4a			;	ex de,hl		 
9c4a			;endif 
9c4a			 
9c4a			;	pop hl 		; get back string pointer 
9c4a			 
9c4a			if DEBUG_FORTH_TOK 
9c4a						DMARK "TOK" 
9c4a				CALLMONITOR 
9c4a			endif 
9c4a 7e			.ptoken2:    ld a,(hl) 
9c4b 23				inc hl 
9c4c fe 7f			cp FORTH_END_BUFFER 
9c4e 28 29			jr z, .ptokendone2 
9c50 fe 00			cp 0 
9c52 28 25			jr z, .ptokendone2 
9c54 fe 22			cp '"' 
9c56 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9c58 fe 20			cp ' ' 
9c5a 20 ee			jr nz,  .ptoken2 
9c5c			 
9c5c			; TODO consume comments held between ( and ) 
9c5c			 
9c5c				; we have a space so change to zero term for dict match later 
9c5c 2b				dec hl 
9c5d 3e 00			ld a,0 
9c5f 77				ld (hl), a 
9c60 23				inc hl 
9c61 18 e7			jr .ptoken2 
9c63				 
9c63			 
9c63			.ptokenstr2: 
9c63				; skip all white space until either eol (because forgot to term) or end double quote 
9c63			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9c63				;inc hl ; skip current double quote 
9c63 7e				ld a,(hl) 
9c64 23				inc hl 
9c65 fe 22			cp '"' 
9c67 28 e1			jr z, .ptoken2 
9c69 fe 7f			cp FORTH_END_BUFFER 
9c6b 28 0c			jr z, .ptokendone2 
9c6d fe 00			cp 0 
9c6f 28 08			jr z, .ptokendone2 
9c71 fe 20			cp ' ' 
9c73 28 02			jr z, .ptmp2 
9c75 18 ec			jr .ptokenstr2 
9c77			 
9c77			.ptmp2:	; we have a space so change to zero term for dict match later 
9c77				;dec hl 
9c77				;ld a,"-"	; TODO remove this when working 
9c77				;ld (hl), a 
9c77				;inc hl 
9c77 18 ea			jr .ptokenstr2 
9c79			 
9c79			.ptokendone2: 
9c79				;inc hl 
9c79 3e 7f			ld a, FORTH_END_BUFFER 
9c7b 77				ld (hl),a 
9c7c 23				inc hl 
9c7d 3e 21			ld a, '!' 
9c7f 77				ld (hl),a 
9c80			 
9c80 2a 61 e6			ld hl,(os_tok_ptr) 
9c83			         
9c83			if DEBUG_FORTH_TOK 
9c83						DMARK "TK1" 
9c83				CALLMONITOR 
9c83			endif 
9c83			 
9c83				; push exec string to top of return stack 
9c83				FORTH_RSP_NEXT 
9c83 cd 37 98			call macro_forth_rsp_next 
9c86				endm 
# End of macro FORTH_RSP_NEXT
9c86 c9				ret 
9c87			 
9c87			; 
9c87			;	; malloc size + buffer pointer + if is loop flag 
9c87			;	ld hl,(os_tok_len) 		 ; get string length 
9c87			; 
9c87			;	ld a,l 
9c87			; 
9c87			;	cp 0			; we dont want to use a null string 
9c87			;	ret z 
9c87			; 
9c87			;;	add 3    ; prefix malloc with buffer for current word ptr 
9c87			; 
9c87			;	add 5     ; TODO when certain not over writing memory remove 
9c87			; 
9c87			;		 
9c87			; 
9c87			;if DEBUG_FORTH_TOK 
9c87			;			DMARK "TKE" 
9c87			;	CALLMONITOR 
9c87			;endif 
9c87			; 
9c87			;	ld l,a 
9c87			;	ld h,0 
9c87			;;	push hl   ; save required space for the copy later 
9c87			;	call malloc 
9c87			;if DEBUG_FORTH_TOK 
9c87			;			DMARK "TKM" 
9c87			;	CALLMONITOR 
9c87			;endif 
9c87			;	if DEBUG_FORTH_MALLOC_GUARD 
9c87			;		push af 
9c87			;		call ishlzero 
9c87			;;		ld a, l 
9c87			;;		add h 
9c87			;;		cp 0 
9c87			;		pop af 
9c87			;		 
9c87			;		call z,malloc_error 
9c87			;	endif 
9c87			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9c87			; 
9c87			; 
9c87			;if DEBUG_FORTH_TOK 
9c87			;			DMARK "TKR" 
9c87			;	CALLMONITOR 
9c87			;endif 
9c87			; 
9c87			;	FORTH_RSP_NEXT 
9c87			; 
9c87			;	;inc hl	 ; go past current buffer pointer 
9c87			;	;inc hl 
9c87			;	;inc hl   ; and past if loop flag 
9c87			;		; TODO Need to set flag  
9c87			; 
9c87			;	 
9c87			;	 
9c87			;	ex de,hl	; malloc is dest 
9c87			;	ld hl, (os_tok_len) 
9c87			;;	pop bc 
9c87			;	ld c, l                
9c87			;	ld b,0 
9c87			;	ld hl, (os_tok_ptr) 
9c87			; 
9c87			;if DEBUG_FORTH_TOK 
9c87			;			DMARK "TKT" 
9c87			;	CALLMONITOR 
9c87			;endif 
9c87			; 
9c87			;	; do str cpy 
9c87			; 
9c87			;	ldir      ; copy byte in hl to de 
9c87			; 
9c87			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9c87			; 
9c87			;if DEBUG_FORTH_TOK 
9c87			; 
9c87			;			DMARK "TKY" 
9c87			;	CALLMONITOR 
9c87			;endif 
9c87			;	;ld a,0 
9c87			;	;ld a,FORTH_END_BUFFER 
9c87			;	ex de, hl 
9c87			;	;dec hl			 ; go back over the space delim at the end of word 
9c87			;	;ld (hl),a 
9c87			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9c87			;	ld a,FORTH_END_BUFFER 
9c87			;	ld (hl),a 
9c87			;	inc hl 
9c87			;	ld a,FORTH_END_BUFFER 
9c87			;	ld (hl),a 
9c87			; 
9c87			;	; init the malloc area data 
9c87			;	; set pc for in current area 
9c87			;	;ld hl, (os_tok_malloc) 
9c87			;	;inc hl 
9c87			;	;inc hl 
9c87			;	;inc hl 
9c87			;	;ex de,hl 
9c87			;	;ld hl, (os_tok_malloc) 
9c87			;	;ld (hl),e 
9c87			;	;inc hl 
9c87			;	;ld (hl),d 
9c87			; 
9c87			; 
9c87			;	ld hl,(os_tok_malloc) 
9c87			;if DEBUG_FORTH_PARSE_KEY 
9c87			;			DMARK "TKU" 
9c87			;	CALLMONITOR 
9c87			;endif 
9c87			; 
9c87			;	ret 
9c87			 
9c87			forthexec: 
9c87			 
9c87			; line exec: 
9c87			; forth parser 
9c87			 
9c87			; 
9c87			;       get current exec line on rsp 
9c87			 
9c87				FORTH_RSP_TOS 
9c87 cd 4e 98			call macro_forth_rsp_tos 
9c8a				endm 
# End of macro FORTH_RSP_TOS
9c8a			 
9c8a			;       restore current pc - hl points to malloc of data 
9c8a			 
9c8a				;ld e, (hl) 
9c8a				;inc hl 
9c8a				;ld d, (hl) 
9c8a				;ex de,hl 
9c8a			 
9c8a			 
9c8a			exec1: 
9c8a 22 61 e6			ld (os_tok_ptr), hl 
9c8d			 
9c8d				; copy our PC to working vars  
9c8d 22 2b eb			ld (cli_ptr), hl 
9c90 22 29 eb			ld (cli_origptr), hl 
9c93			 
9c93 7e				ld a,(hl) 
9c94 fe 7f			cp FORTH_END_BUFFER 
9c96 c8				ret z 
9c97			 
9c97				; skip any nulls 
9c97			 
9c97 fe 00			cp 0 
9c99 20 03			jr nz, .execword 
9c9b 23				inc hl 
9c9c 18 ec			jr exec1 
9c9e			 
9c9e			 
9c9e			.execword: 
9c9e			 
9c9e			 
9c9e			 
9c9e			if DEBUG_FORTH_PARSE_KEY 
9c9e						DMARK "KYQ" 
9c9e				CALLMONITOR 
9c9e			endif 
9c9e			;       while at start of word: 
9c9e			; get start of dict (in user area first) 
9c9e			 
9c9e 21 83 d8		ld hl, baseram 
9ca1			;ld hl, sysdict 
9ca1 22 2d eb		ld (cli_nextword),hl 
9ca4			;           match word at pc 
9ca4			;           exec word 
9ca4			;           or push to dsp 
9ca4			;           forward to next token 
9ca4			;           if line term pop rsp and exit 
9ca4			;        
9ca4			 
9ca4			if DEBUG_FORTH_PARSE_KEY 
9ca4						DMARK "KYq" 
9ca4				CALLMONITOR 
9ca4			endif 
9ca4			 
9ca4			; 
9ca4			; word comp 
9ca4			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9ca4			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9ca4			;    move to start of word  
9ca4			;    compare word to cli_token 
9ca4			 
9ca4			.execpnword:	; HL at start of a word in the dictionary to check 
9ca4			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9ca4			;	ld (cli_ptr), hl 
9ca4			 
9ca4 2a 2d eb			ld hl,(cli_nextword) 
9ca7			 
9ca7 cd 4a 9d			call forth_tok_next 
9caa			; tok next start here 
9caa			;	; TODO skip compiled symbol for now 
9caa			;	inc hl 
9caa			; 
9caa			;	; save pointer to next word 
9caa			; 
9caa			;	; hl now points to the address of the next word pointer  
9caa			;	ld e, (hl) 
9caa			;	inc hl 
9caa			;	ld d, (hl) 
9caa			;	inc l 
9caa			; 
9caa			;	ex de,hl 
9caa			;if DEBUG_FORTH_PARSE_NEXTWORD 
9caa			;	push bc 
9caa			;	ld bc, (cli_nextword) 
9caa			;			DMARK "NXW" 
9caa			;	CALLMONITOR 
9caa			;	pop bc 
9caa			;endif 
9caa			; tok next end here 
9caa 22 2d eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
9cad eb				ex de, hl 
9cae			 
9cae			 
9cae				; save the pointer of the current token - 1 to check against 
9cae				 
9cae 22 31 eb			ld (cli_token), hl   
9cb1				; TODO maybe remove below save if no debug 
9cb1				; save token string ptr for any debug later 
9cb1 23				inc hl  
9cb2 22 33 eb			ld (cli_origtoken), hl 
9cb5 2b				dec hl 
9cb6				; save pointer to the start of the next dictionay word 
9cb6 7e				ld a,(hl)   ; get string length 
9cb7 47				ld b,a 
9cb8			.execpnwordinc:  
9cb8 23				inc hl 
9cb9 10 fd			djnz .execpnwordinc 
9cbb 22 2f eb			ld (cli_execword), hl      ; save start of this words code 
9cbe			 
9cbe				; now check the word token against the string being parsed 
9cbe			 
9cbe 2a 31 eb			ld hl,(cli_token) 
9cc1 23				inc hl     ; skip string length (use zero term instead to end) 
9cc2 22 31 eb			ld (cli_token), hl 
9cc5			 
9cc5			if DEBUG_FORTH_PARSE_KEY 
9cc5						DMARK "KY2" 
9cc5			endif 
9cc5			if DEBUG_FORTH_PARSE_EXEC 
9cc5				; see if disabled 
9cc5			 
9cc5				ld a, (os_view_disable) 
9cc5				cp '*' 
9cc5				jr z, .skip 
9cc5			 
9cc5				push hl 
9cc5				push hl 
9cc5				call clear_display 
9cc5				ld de, .compword 
9cc5				ld a, display_row_1 
9cc5				call str_at_display 
9cc5				pop de 
9cc5				ld a, display_row_2 
9cc5				call str_at_display 
9cc5				ld hl,(cli_ptr) 
9cc5				ld a,(hl) 
9cc5			        ld hl, os_word_scratch 
9cc5				ld (hl),a 
9cc5				ld a,0 
9cc5				inc hl 
9cc5				ld (hl),a 	 
9cc5				ld de, os_word_scratch 
9cc5				ld a, display_row_2+10 
9cc5				call str_at_display 
9cc5				call update_display 
9cc5				ld a, 100 
9cc5				call aDelayInMS 
9cc5				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9cc5				call delay250ms 
9cc5				endif 
9cc5				pop hl 
9cc5			.skip:  
9cc5			endif	 
9cc5			.execpnchar:    ; compare char between token and string to parse 
9cc5			 
9cc5			if DEBUG_FORTH_PARSE_KEY 
9cc5						DMARK "Ky3" 
9cc5			endif 
9cc5			if DEBUG_FORTH_PARSE_EXEC 
9cc5				; see if disabled 
9cc5			 
9cc5				ld a, (os_view_disable) 
9cc5				cp '*' 
9cc5				jr z, .skip2 
9cc5			 
9cc5			;	call clear_display 
9cc5			ld hl,(cli_token) 
9cc5			ld a,(hl) 
9cc5			ld (os_word_scratch),a 
9cc5				ld hl,(cli_ptr) 
9cc5			ld a,(hl) 
9cc5				ld (os_word_scratch+1),a 
9cc5				ld a,0 
9cc5				ld (os_word_scratch+2),a 
9cc5				ld de,os_word_scratch 
9cc5				ld a,display_row_4 
9cc5				call str_at_display 
9cc5				call update_display 
9cc5			.skip2:  
9cc5			endif 
9cc5 2a 31 eb			ld hl,(cli_token) 
9cc8 7e				ld a, (hl)	 ; char in word token 
9cc9 23				inc hl 		; move to next char 
9cca 22 31 eb			ld (cli_token), hl ; and save it 
9ccd 47				ld b,a 
9cce			 
9cce 2a 2b eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
9cd1 7e				ld a,(hl) 
9cd2 23				inc hl 
9cd3 22 2b eb			ld (cli_ptr), hl		; move to next char 
9cd6 cd fc 8e			call toUpper 		; make sure the input string matches case 
9cd9			 
9cd9			if DEBUG_FORTH_PARSE 
9cd9			endif 
9cd9			 
9cd9				; input stream end of token is a space so get rid of it 
9cd9			 
9cd9			;	cp ' ' 
9cd9			;	jr nz, .pnskipspace 
9cd9			; 
9cd9			;	ld a, 0		; make same term as word token term 
9cd9			; 
9cd9			;.pnskipspace: 
9cd9			 
9cd9			if DEBUG_FORTH_PARSE_KEY 
9cd9						DMARK "KY7" 
9cd9			endif 
9cd9 b8				cp b 
9cda c2 f0 9c			jp nz, .execpnskipword	 ; no match so move to next word 
9cdd				 
9cdd			;    if same 
9cdd			;       scan for string terms 0 for token and 32 for input 
9cdd			 
9cdd				 
9cdd			if DEBUG_FORTH_PARSE_KEY 
9cdd						DMARK "KY8" 
9cdd			endif 
9cdd			 
9cdd 80				add b			 
9cde fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9ce0							; TODO need to make sure last word in zero term string is accounted for 
9ce0 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9ce2			 
9ce2			 
9ce2				; at end of both strings so both are exact match 
9ce2			 
9ce2			;       skip ptr for next word 
9ce2			 
9ce2 2a 2b eb			ld hl,(cli_ptr) 	; at input string term 
9ce5 23				inc hl			 ; at next char 
9ce6 22 2b eb			ld (cli_ptr), hl     ; save for next round of the parser 
9ce9 22 29 eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9cec				 
9cec				 
9cec			if DEBUG_FORTH_PARSE_KEY 
9cec						DMARK "KY3" 
9cec			endif 
9cec			 
9cec			 
9cec			 
9cec			;       exec code block 
9cec			if DEBUG_FORTH_JP 
9cec				call clear_display 
9cec				call update_display 
9cec				call delay1s 
9cec				ld hl, (cli_execword)     ; save for next check if no match on this word 
9cec				ld a,h 
9cec				ld hl, os_word_scratch 
9cec				call hexout 
9cec				ld hl, (cli_execword)     ; save for next check if no match on this word 
9cec				ld a,l 
9cec				ld hl, os_word_scratch+2 
9cec				call hexout 
9cec				ld hl, os_word_scratch+4 
9cec				ld a,0 
9cec				ld (hl),a 
9cec				ld de,os_word_scratch 
9cec				call str_at_display 
9cec					ld a, display_row_2 
9cec					call str_at_display 
9cec				ld de, (cli_origtoken) 
9cec				ld a, display_row_1+10 
9cec					call str_at_display 
9cec			 
9cec				ld a,display_row_1 
9cec				ld de, .foundword 
9cec				ld a, display_row_3 
9cec				call str_at_display 
9cec				call update_display 
9cec				call delay1s 
9cec				call delay1s 
9cec				call delay1s 
9cec			endif 
9cec			 
9cec			if DEBUG_FORTH_PARSE_KEY 
9cec						DMARK "KYj" 
9cec			endif 
9cec				; TODO save the word pointer in this exec 
9cec			 
9cec 2a 2f eb			ld hl,(cli_execword) 
9cef e9				jp (hl) 
9cf0			 
9cf0			 
9cf0			;    if not same 
9cf0			;	scan for zero term 
9cf0			;	get ptr for next word 
9cf0			;	goto word comp 
9cf0			 
9cf0			.execpnskipword:	; get pointer to next word 
9cf0 2a 2d eb			ld hl,(cli_nextword) 
9cf3			 
9cf3 7e				ld a,(hl) 
9cf4 fe 00			cp WORD_SYS_END 
9cf6			;	cp 0 
9cf6 28 09			jr z, .execendofdict			 ; at end of words 
9cf8			 
9cf8			if DEBUG_FORTH_PARSE_KEY 
9cf8						DMARK "KY4" 
9cf8			endif 
9cf8			if DEBUG_FORTH_PARSE_EXEC 
9cf8			 
9cf8				; see if disabled 
9cf8			 
9cf8				ld a, (os_view_disable) 
9cf8				cp '*' 
9cf8				jr z, .noskip 
9cf8			 
9cf8			 
9cf8				ld de, .nowordfound 
9cf8				ld a, display_row_3 
9cf8				call str_at_display 
9cf8				call update_display 
9cf8				ld a, 100 
9cf8				call aDelayInMS 
9cf8				 
9cf8				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9cf8					call delay250ms 
9cf8				endif 
9cf8			.noskip:  
9cf8			 
9cf8			endif	 
9cf8			 
9cf8 2a 29 eb			ld hl,(cli_origptr) 
9cfb 22 2b eb			ld (cli_ptr),hl 
9cfe			 
9cfe			if DEBUG_FORTH_PARSE_KEY 
9cfe						DMARK "KY5" 
9cfe			endif 
9cfe c3 a4 9c			jp .execpnword			; else go to next word 
9d01			 
9d01			.execendofdict:  
9d01			 
9d01			if DEBUG_FORTH_PARSE_KEY 
9d01						DMARK "KYe" 
9d01			endif 
9d01			if DEBUG_FORTH_PARSE_EXEC 
9d01				; see if disabled 
9d01			 
9d01				ld a, (os_view_disable) 
9d01				cp '*' 
9d01				jr z, .ispskip 
9d01			 
9d01				call clear_display 
9d01				call update_display 
9d01				call delay1s 
9d01				ld de, (cli_origptr) 
9d01				ld a, display_row_1 
9d01				call str_at_display 
9d01				 
9d01				ld de, .enddict 
9d01				ld a, display_row_3 
9d01				call str_at_display 
9d01				call update_display 
9d01				ld a, 100 
9d01				call aDelayInMS 
9d01				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9d01				call delay1s 
9d01				call delay1s 
9d01				call delay1s 
9d01				endif 
9d01			.ispskip:  
9d01				 
9d01			endif	 
9d01			 
9d01			 
9d01			 
9d01				; if the word is not a keyword then must be a literal so push it to stack 
9d01			 
9d01			; push token to stack to end of word 
9d01			 
9d01				STACKFRAME ON $1efe $2f9f 
9d01				if DEBUG_STACK_IMB 
9d01					if ON 
9d01						exx 
9d01						ld de, $1efe 
9d01						ld a, d 
9d01						ld hl, curframe 
9d01						call hexout 
9d01						ld a, e 
9d01						ld hl, curframe+2 
9d01						call hexout 
9d01						ld hl, $1efe 
9d01						push hl 
9d01						ld hl, $2f9f 
9d01						push hl 
9d01						exx 
9d01					endif 
9d01				endif 
9d01			endm 
# End of macro STACKFRAME
9d01			 
9d01 2a 61 e6		ld hl,(os_tok_ptr) 
9d04 cd f9 99		call forth_apush 
9d07			 
9d07				STACKFRAMECHK ON $1efe $2f9f 
9d07				if DEBUG_STACK_IMB 
9d07					if ON 
9d07						exx 
9d07						ld hl, $2f9f 
9d07						pop de   ; $2f9f 
9d07						call cmp16 
9d07						jr nz, .spnosame 
9d07						ld hl, $1efe 
9d07						pop de   ; $1efe 
9d07						call cmp16 
9d07						jr z, .spfrsame 
9d07						.spnosame: call showsperror 
9d07						.spfrsame: nop 
9d07						exx 
9d07					endif 
9d07				endif 
9d07			endm 
# End of macro STACKFRAMECHK
9d07			 
9d07			execnext: 
9d07			 
9d07			if DEBUG_FORTH_PARSE_KEY 
9d07						DMARK "KY>" 
9d07			endif 
9d07			; move past token to next word 
9d07			 
9d07 2a 61 e6		ld hl, (os_tok_ptr) 
9d0a 3e 00		ld a, 0 
9d0c 01 ff 00		ld bc, 255     ; input buffer size 
9d0f ed b1		cpir 
9d11			 
9d11			if DEBUG_FORTH_PARSE_KEY 
9d11						DMARK "KY!" 
9d11				CALLMONITOR 
9d11			endif	 
9d11			; TODO this might place hl on the null, so will need to forward on??? 
9d11			;inc hl   ; see if this gets onto the next item 
9d11			 
9d11			 
9d11			; TODO pass a pointer to the buffer to push 
9d11			; TODO call function to push 
9d11			 
9d11			; look for end of input 
9d11			 
9d11			;inc hl 
9d11			;ld a,(hl) 
9d11			;cp FORTH_END_BUFFER 
9d11			;ret z 
9d11			 
9d11			 
9d11 c3 8a 9c		jp exec1 
9d14			 
9d14			 
9d14			 
9d14			 
9d14			 
9d14			 
9d14			 
9d14			 
9d14			 
9d14			findnexttok: 
9d14			 
9d14				; hl is pointer to move 
9d14				; de is the token to locate 
9d14			 
9d14					if DEBUG_FORTH 
9d14						DMARK "NTK" 
9d14						CALLMONITOR 
9d14					endif 
9d14 d5				push de 
9d15			 
9d15			.fnt1:	 
9d15				; find first char of token to locate 
9d15			 
9d15 1a				ld a, (de) 
9d16 4f				ld c,a 
9d17 7e				ld a,(hl) 
9d18 cd fc 8e			call toUpper 
9d1b					if DEBUG_FORTH 
9d1b						DMARK "NT1" 
9d1b						CALLMONITOR 
9d1b					endif 
9d1b b9				cp c 
9d1c			 
9d1c 28 03			jr z, .fnt2cmpmorefirst	 
9d1e			 
9d1e				; first char not found move to next char 
9d1e			 
9d1e 23				inc hl 
9d1f 18 f4			jr .fnt1 
9d21			 
9d21			.fnt2cmpmorefirst:	 
9d21				; first char of token found.  
9d21			 
9d21 e5				push hl     ; save start of token just in case it is the right one 
9d22 d9				exx 
9d23 e1				pop hl        ; save it to hl' 
9d24 d9				exx 
9d25			 
9d25			 
9d25			.fnt2cmpmore:	 
9d25				; compare the rest 
9d25				 
9d25 23				inc hl 
9d26 13				inc de 
9d27				 
9d27 1a				ld a, (de) 
9d28 4f				ld c,a 
9d29 7e				ld a,(hl) 
9d2a cd fc 8e			call toUpper 
9d2d			 
9d2d					if DEBUG_FORTH 
9d2d						DMARK "NT2" 
9d2d						CALLMONITOR 
9d2d					endif 
9d2d				; c has the token to find char 
9d2d				; a has the mem to scan char 
9d2d			 
9d2d b9				cp c 
9d2e 28 04			jr z,.fntmatch1 
9d30			 
9d30				; they are not the same 
9d30			 
9d30					if DEBUG_FORTH 
9d30						DMARK "NT3" 
9d30						CALLMONITOR 
9d30					endif 
9d30 d1				pop de	; reset de token to look for 
9d31 d5				push de 
9d32 18 e1			jr .fnt1 
9d34				 
9d34			.fntmatch1: 
9d34			 
9d34				; is the same char a null which means we might have a full hit? 
9d34					if DEBUG_FORTH 
9d34						DMARK "NT4" 
9d34						CALLMONITOR 
9d34					endif 
9d34			 
9d34 fe 00			cp 0 
9d36 28 0b			jr z, .fntmatchyes 
9d38			 
9d38				; are we at the end of the token to find? 
9d38			 
9d38					if DEBUG_FORTH 
9d38						DMARK "NT5" 
9d38						CALLMONITOR 
9d38					endif 
9d38 3e 00			ld a, 0 
9d3a b9				cp c 
9d3b			 
9d3b c2 25 9d			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9d3e			 
9d3e					if DEBUG_FORTH 
9d3e						DMARK "NT6" 
9d3e						CALLMONITOR 
9d3e					endif 
9d3e				; token to find is exhusted but no match to stream 
9d3e			 
9d3e				; restore tok pointer and continue on 
9d3e d1				pop de 
9d3f d5				push de 
9d40 c3 15 9d			jp .fnt1 
9d43			 
9d43			 
9d43			.fntmatchyes: 
9d43			 
9d43				; hl now contains the end of the found token 
9d43			 
9d43				; get rid of saved token pointer to find 
9d43			 
9d43 d1				pop de 
9d44			 
9d44					if DEBUG_FORTH 
9d44						DMARK "NT9" 
9d44						CALLMONITOR 
9d44					endif 
9d44			 
9d44				; hl will be on the null term so forward on 
9d44			 
9d44				; get back the saved start of the token 
9d44			 
9d44 d9				exx 
9d45 e5				push hl     ; save start of token just in case it is the right one 
9d46 d9				exx 
9d47 e1				pop hl        ; save it to hl 
9d48			 
9d48 c9				ret 
9d49			 
9d49			 
9d49			; LIST needs to find a specific token   
9d49			; FORGET needs to find a spefici token 
9d49			 
9d49			; SAVE needs to find all tokens by flag 
9d49			; WORDS just needs to scan through all  by flag 
9d49			; UWORDS needs to scan through all by flag 
9d49			 
9d49			 
9d49			; given hl as pointer to start of dict look up string 
9d49			; return hl as pointer to start of word block 
9d49			; or 0 if not found 
9d49			 
9d49			forth_find_tok: 
9d49 c9				ret 
9d4a			 
9d4a			; given hl as pointer to dict structure 
9d4a			; move to the next dict block structure 
9d4a			 
9d4a			forth_tok_next: 
9d4a				; hl now points to the address of the next word pointer  
9d4a				; TODO skip compiled symbol for now 
9d4a			;	push de 
9d4a 23				inc hl 
9d4b 5e				ld e, (hl) 
9d4c 23				inc hl 
9d4d 56				ld d, (hl) 
9d4e 23				inc hl 
9d4f			 
9d4f eb				ex de,hl 
9d50			if DEBUG_FORTH_PARSE_NEXTWORD 
9d50				push bc 
9d50				ld bc, (cli_nextword) 
9d50						DMARK "NXW" 
9d50				CALLMONITOR 
9d50				pop bc 
9d50			endif 
9d50			;	pop de	 
9d50 c9				ret 
9d51			 
9d51			 
9d51			 
9d51			; eof 
# End of file forth_parserv5.asm
9d51				include "forth_wordsv4.asm" 
9d51			 
9d51			; the core word dictionary v4 
9d51			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9d51			 
9d51			; this is a linked list for each of the system words used 
9d51			; user defined words will follow the same format but will be in ram 
9d51			 
9d51			 
9d51			; 
9d51			; 
9d51			; define linked list: 
9d51			; 
9d51			; 1. compiled byte op code 
9d51			; 2. len of text word 
9d51			; 3. text word 
9d51			; 4. ptr to next dictionary word 
9d51			; 5. asm, calls etc for the word 
9d51			; 
9d51			;  if 1 == 0 then last word in dict  
9d51			;   
9d51			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9d51			;  
9d51			;  
9d51			; create basic standard set of words 
9d51			; 
9d51			;  
9d51			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9d51			; 2DUP 2DROP 2SWAP  
9d51			; @ C@ - get byte  
9d51			; ! C! - store byte 
9d51			; 0< true if less than zero 
9d51			; 0= true if zero 
9d51			; < >  
9d51			; = true if same 
9d51			; variables 
9d51			 
9d51			 
9d51			; Hardware specific words I may need 
9d51			; 
9d51			; IN OUT  
9d51			; calls to key util functions 
9d51			; calls to hardward abstraction stuff 
9d51			; easy control of frame buffers and lcd i/o 
9d51			; keyboard  
9d51			 
9d51			 
9d51			;DICT: macro 
9d51			; op_code, len, word, next 
9d51			;    word: 
9d51			;    db op_code 
9d51			;    ds word zero term 
9d51			;    dw next 
9d51			;    endm 
9d51			 
9d51			 
9d51			 
9d51			 
9d51			; op code 1 is a flag for user define words which are to be handled differently 
9d51			 
9d51			 
9d51			; 
9d51			; 
9d51			;    TODO on entry to a word this should be the expected environment 
9d51			;    hl - tos value if number then held, if string this is the ptr 
9d51			;    de -  
9d51			 
9d51			 
9d51			; opcode ranges 
9d51			; 0 - end of word dict 
9d51			; 255 - user define words 
9d51			 
9d51			sysdict: 
9d51			include "forth_opcodes.asm" 
9d51			; op codes for forth keywords 
9d51			; free to use code 0  
9d51				OPCODE_HEAP: equ  1 
9d51				OPCODE_EXEC: equ 2 
9d51				OPCODE_DUP: equ 3 
9d51				OPCODE_SWAP: equ 4 
9d51				OPCODE_COLN: equ 5 
9d51				OPCODE_SCOLN: equ 6 
9d51				OPCODE_DROP: equ 7 
9d51				OPCODE_DUP2: equ 8 
9d51				OPCODE_DROP2: equ 9 
9d51				OPCODE_SWAP2: equ 10 
9d51				OPCODE_AT: equ 11 
9d51				OPCODE_CAT: equ 12 
9d51				OPCODE_BANG: equ 13 
9d51				OPCODE_CBANG: equ 14 
9d51				OPCODE_SCALL: equ 15 
9d51				OPCODE_DEPTH: equ 16 
9d51				OPCODE_OVER: equ 17 
9d51				OPCODE_PAUSE: equ 18 
9d51				OPCODE_PAUSES: equ 19 
9d51				OPCODE_ROT: equ 20 
9d51			;free to reuse	OPCODE_WORDS: equ 21 
9d51			        OPCODE_NOT: equ 21 
9d51				OPCODE_UWORDS: equ 22 
9d51				OPCODE_BP: equ 23 
9d51				OPCODE_MONITOR: equ 24  
9d51				OPCODE_MALLOC: equ 25 
9d51				OPCODE_FREE: equ 26 
9d51				OPCODE_LIST: equ 27 
9d51				OPCODE_FORGET: equ 28 
9d51				OPCODE_NOP: equ 29 
9d51				OPCODE_COMO: equ 30 
9d51				OPCODE_COMC: equ 31 
9d51			;free to reuse	OPCODE_ENDCORE: equ 32 
9d51				OPCODE_AFTERSOUND: equ 33 
9d51				OPCODE_GP2: equ 34 
9d51				OPCODE_GP3: equ 35 
9d51				OPCODE_GP4: equ 36 
9d51				OPCODE_SIN: equ 37 
9d51				OPCODE_SOUT: equ 38 
9d51				OPCODE_SPIO: equ 39 
9d51				OPCODE_SPICEH: equ 40 
9d51				OPCODE_SPIOb: equ 41 
9d51				OPCODE_SPII: equ 42 
9d51				OPCODE_SESEL: equ 43 
9d51				OPCODE_CARTDEV: equ 44 
9d51			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9d51				OPCODE_FB: equ 46 
9d51				OPCODE_EMIT: equ 47 
9d51				OPCODE_DOTH: equ 48 
9d51				OPCODE_DOTF: equ 49 
9d51				OPCODE_DOT: equ 50 
9d51				OPCODE_CLS: equ 51 
9d51				OPCODE_DRAW: equ 52 
9d51				OPCODE_DUMP: equ 53 
9d51				OPCODE_CDUMP: equ 54 
9d51				OPCODE_DAT: equ 55 
9d51				OPCODE_HOME: equ 56 
9d51				OPCODE_SPACE: equ 57 
9d51				OPCODE_SPACES: equ 58 
9d51				OPCODE_SCROLL: equ 59 
9d51				OPCODE_ATQ: equ 60 
9d51				OPCODE_AUTODSP: equ 61 
9d51				OPCODE_MENU: equ 62 
9d51			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9d51				OPCODE_THEN: equ 64 
9d51				OPCODE_ELSE: equ 65 
9d51				OPCODE_DO: equ 66 
9d51				OPCODE_LOOP: equ 67 
9d51				OPCODE_I: equ 68 
9d51				OPCODE_DLOOP: equ 69  
9d51				OPCODE_REPEAT: equ 70  
9d51				OPCODE_UNTIL: equ 71 
9d51				OPCODE_ENDFLOW: equ 72 
9d51				OPCODE_WAITK: equ 73 
9d51				OPCODE_ACCEPT: equ 74 
9d51				OPCODE_EDIT: equ 75 
9d51			;free to reuse	OPCODE_ENDKEY: equ 76 
9d51				OPCODE_LZERO: equ 77 
9d51				OPCODE_TZERO: equ 78 
9d51				OPCODE_LESS: equ 79 
9d51				OPCODE_GT: equ 80 
9d51				OPCODE_EQUAL: equ 81  
9d51			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9d51				OPCODE_NEG: equ 83 
9d51				OPCODE_DIV: equ 84 
9d51				OPCODE_MUL: equ 85 
9d51				OPCODE_MIN: equ 86 
9d51				OPCODE_MAX: equ 87 
9d51				OPCODE_RND16: equ 88 
9d51				OPCODE_RND8: equ 89 
9d51				OPCODE_RND: equ 90 
9d51			;free to reuse	OPCODE_ENDMATHS: equ 91  
9d51				OPCODE_BYNAME: equ 92 
9d51				OPCODE_DIR: equ 93 
9d51				OPCODE_SAVE: equ 94 
9d51				OPCODE_LOAD: equ 95 
9d51				OPCODE_BSAVE: equ 96 
9d51				OPCODE_BLOAD: equ 97 
9d51				OPCODE_SEO: equ 98  
9d51				OPCODE_SEI: equ 99 
9d51				OPCODE_SFREE: equ 100 
9d51				OPCODE_SIZE: equ 101 
9d51				OPCODE_CREATE: equ 102 
9d51				OPCODE_APPEND: equ 103 
9d51				OPCODE_SDEL: equ 104 
9d51				OPCODE_OPEN: equ 105 
9d51				OPCODE_READ: equ 106 
9d51				OPCODE_EOF: equ 106 
9d51				OPCODE_FORMAT: equ 107 
9d51				OPCODE_LABEL: equ 108 
9d51				OPCODE_LABELS: equ 109 
9d51			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9d51				OPCODE_UPPER: equ 111 
9d51				OPCODE_LOWER: equ 112 
9d51				OPCODE_SUBSTR: equ 113 
9d51				OPCODE_LEFT: equ 114 
9d51				OPCODE_RIGHT: equ 115 
9d51				OPCODE_STR2NUM: equ 116 
9d51				OPCODE_NUM2STR: equ 117 
9d51				OPCODE_CONCAT: equ 118 
9d51				OPCODE_FIND: equ 119 
9d51				OPCODE_LEN: equ 120 
9d51				OPCODE_CHAR: equ 121 
9d51			; free to reuse	OPCODE_STRLEN: equ 122 
9d51			; free to reuse	OPCODE_ENDSTR: equ 123 
9d51				OPCODE_V0S: equ 124 
9d51				OPCODE_V0Q: equ 125 
9d51				OPCODE_V1S: equ 126 
9d51				OPCODE_V1Q: equ 127 
9d51				OPCODE_V2S: equ 128 
9d51				OPCODE_V2Q: equ 129 
9d51				OPCODE_V3S: equ 130 
9d51				OPCODE_V3Q: equ 131 
9d51			;free to reuse	OPCODE_END: equ 132 
9d51				OPCODE_ZDUP: equ 133 
9d51			 
9d51			; eof 
# End of file forth_opcodes.asm
9d51			 
9d51			include "forth_words_core.asm" 
9d51			 
9d51			; | ## Core Words 
9d51			 
9d51			;if MALLOC_4 
9d51			 
9d51			.HEAP: 
9d51				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9d51 15				db WORD_SYS_CORE+OPCODE_HEAP             
9d52 90 9d			dw .EXEC            
9d54 05				db 4 + 1 
9d55 .. 00			db "HEAP",0              
9d5a				endm 
# End of macro CWHEAD
9d5a			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9d5a			; | | u1 - Current number of bytes in the heap 
9d5a			; | | u2 - Remaining bytes left on the heap 
9d5a			; | |  
9d5a			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9d5a			 
9d5a			 
9d5a					if DEBUG_FORTH_WORDS_KEY 
9d5a						DMARK "HEP" 
9d5a f5				push af  
9d5b 3a 6f 9d			ld a, (.dmark)  
9d5e 32 7a ee			ld (debug_mark),a  
9d61 3a 70 9d			ld a, (.dmark+1)  
9d64 32 7b ee			ld (debug_mark+1),a  
9d67 3a 71 9d			ld a, (.dmark+2)  
9d6a 32 7c ee			ld (debug_mark+2),a  
9d6d 18 03			jr .pastdmark  
9d6f ..			.dmark: db "HEP"  
9d72 f1			.pastdmark: pop af  
9d73			endm  
# End of macro DMARK
9d73						CALLMONITOR 
9d73 cd 03 93			call break_point_state  
9d76				endm  
# End of macro CALLMONITOR
9d76					endif 
9d76 2a 8d d8				ld hl, (free_list )      
9d79 11 92 d8				ld de, heap_start 
9d7c			 
9d7c ed 52				sbc hl, de  
9d7e			 
9d7e cd 90 98				call forth_push_numhl 
9d81			 
9d81			 
9d81 ed 5b 8d d8			ld de, (free_list )      
9d85 21 46 e3				ld hl, heap_end 
9d88			 
9d88 ed 52				sbc hl, de 
9d8a			 
9d8a cd 90 98				call forth_push_numhl 
9d8d					 
9d8d			 
9d8d					 
9d8d			 
9d8d			 
9d8d			 
9d8d					NEXTW 
9d8d c3 f9 9b			jp macro_next 
9d90				endm 
# End of macro NEXTW
9d90			;endif 
9d90			 
9d90			.EXEC: 
9d90				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9d90 16				db WORD_SYS_CORE+OPCODE_EXEC             
9d91 2c 9e			dw .STKEXEC            
9d93 05				db 4 + 1 
9d94 .. 00			db "EXEC",0              
9d99				endm 
# End of macro CWHEAD
9d99			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
9d99			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9d99			; | | 
9d99			; | |   
9d99				STACKFRAME OFF $5efe $5f9f 
9d99				if DEBUG_STACK_IMB 
9d99					if OFF 
9d99						exx 
9d99						ld de, $5efe 
9d99						ld a, d 
9d99						ld hl, curframe 
9d99						call hexout 
9d99						ld a, e 
9d99						ld hl, curframe+2 
9d99						call hexout 
9d99						ld hl, $5efe 
9d99						push hl 
9d99						ld hl, $5f9f 
9d99						push hl 
9d99						exx 
9d99					endif 
9d99				endif 
9d99			endm 
# End of macro STACKFRAME
9d99			 
9d99					if DEBUG_FORTH_WORDS_KEY 
9d99						DMARK "EXE" 
9d99 f5				push af  
9d9a 3a ae 9d			ld a, (.dmark)  
9d9d 32 7a ee			ld (debug_mark),a  
9da0 3a af 9d			ld a, (.dmark+1)  
9da3 32 7b ee			ld (debug_mark+1),a  
9da6 3a b0 9d			ld a, (.dmark+2)  
9da9 32 7c ee			ld (debug_mark+2),a  
9dac 18 03			jr .pastdmark  
9dae ..			.dmark: db "EXE"  
9db1 f1			.pastdmark: pop af  
9db2			endm  
# End of macro DMARK
9db2						CALLMONITOR 
9db2 cd 03 93			call break_point_state  
9db5				endm  
# End of macro CALLMONITOR
9db5					endif 
9db5			 
9db5				FORTH_DSP_VALUEHL 
9db5 cd 87 9a			call macro_dsp_valuehl 
9db8				endm 
# End of macro FORTH_DSP_VALUEHL
9db8			 
9db8				FORTH_DSP_POP 
9db8 cd 3f 9b			call macro_forth_dsp_pop 
9dbb				endm 
# End of macro FORTH_DSP_POP
9dbb			 
9dbb					if DEBUG_FORTH_WORDS 
9dbb						DMARK "EX1" 
9dbb f5				push af  
9dbc 3a d0 9d			ld a, (.dmark)  
9dbf 32 7a ee			ld (debug_mark),a  
9dc2 3a d1 9d			ld a, (.dmark+1)  
9dc5 32 7b ee			ld (debug_mark+1),a  
9dc8 3a d2 9d			ld a, (.dmark+2)  
9dcb 32 7c ee			ld (debug_mark+2),a  
9dce 18 03			jr .pastdmark  
9dd0 ..			.dmark: db "EX1"  
9dd3 f1			.pastdmark: pop af  
9dd4			endm  
# End of macro DMARK
9dd4						CALLMONITOR 
9dd4 cd 03 93			call break_point_state  
9dd7				endm  
# End of macro CALLMONITOR
9dd7					endif 
9dd7			;	ld e,(hl) 
9dd7			;	inc hl 
9dd7			;	ld d,(hl) 
9dd7			;	ex de,hl 
9dd7			 
9dd7			;		if DEBUG_FORTH_WORDS 
9dd7			;			DMARK "EX2" 
9dd7			;			CALLMONITOR 
9dd7			;		endif 
9dd7 e5				push hl 
9dd8			 
9dd8				;ld a, 0 
9dd8				;ld a, FORTH_END_BUFFER 
9dd8 cd 05 8f			call strlenz 
9ddb 23				inc hl   ; include zero term to copy 
9ddc 23				inc hl   ; include term 
9ddd 23				inc hl   ; include term 
9dde 06 00			ld b,0 
9de0 4d				ld c,l 
9de1 e1				pop hl 
9de2 11 5f e4			ld de, execscratch 
9de5					if DEBUG_FORTH_WORDS 
9de5						DMARK "EX3" 
9de5 f5				push af  
9de6 3a fa 9d			ld a, (.dmark)  
9de9 32 7a ee			ld (debug_mark),a  
9dec 3a fb 9d			ld a, (.dmark+1)  
9def 32 7b ee			ld (debug_mark+1),a  
9df2 3a fc 9d			ld a, (.dmark+2)  
9df5 32 7c ee			ld (debug_mark+2),a  
9df8 18 03			jr .pastdmark  
9dfa ..			.dmark: db "EX3"  
9dfd f1			.pastdmark: pop af  
9dfe			endm  
# End of macro DMARK
9dfe						CALLMONITOR 
9dfe cd 03 93			call break_point_state  
9e01				endm  
# End of macro CALLMONITOR
9e01					endif 
9e01 ed b0			ldir 
9e03			 
9e03			 
9e03 21 5f e4			ld hl, execscratch 
9e06			 
9e06					if DEBUG_FORTH_WORDS 
9e06						DMARK "EXe" 
9e06 f5				push af  
9e07 3a 1b 9e			ld a, (.dmark)  
9e0a 32 7a ee			ld (debug_mark),a  
9e0d 3a 1c 9e			ld a, (.dmark+1)  
9e10 32 7b ee			ld (debug_mark+1),a  
9e13 3a 1d 9e			ld a, (.dmark+2)  
9e16 32 7c ee			ld (debug_mark+2),a  
9e19 18 03			jr .pastdmark  
9e1b ..			.dmark: db "EXe"  
9e1e f1			.pastdmark: pop af  
9e1f			endm  
# End of macro DMARK
9e1f						CALLMONITOR 
9e1f cd 03 93			call break_point_state  
9e22				endm  
# End of macro CALLMONITOR
9e22					endif 
9e22			 
9e22 cd 47 9c			call forthparse 
9e25 cd 87 9c			call forthexec 
9e28			;	call forthexec_cleanup 
9e28			;	call forthparse 
9e28			;	call forthexec 
9e28			 
9e28				STACKFRAMECHK OFF $5efe $5f9f 
9e28				if DEBUG_STACK_IMB 
9e28					if OFF 
9e28						exx 
9e28						ld hl, $5f9f 
9e28						pop de   ; $5f9f 
9e28						call cmp16 
9e28						jr nz, .spnosame 
9e28						ld hl, $5efe 
9e28						pop de   ; $5efe 
9e28						call cmp16 
9e28						jr z, .spfrsame 
9e28						.spnosame: call showsperror 
9e28						.spfrsame: nop 
9e28						exx 
9e28					endif 
9e28				endif 
9e28			endm 
# End of macro STACKFRAMECHK
9e28			 
9e28				; an immediate word so no need to process any more words 
9e28 c9				ret 
9e29				NEXTW 
9e29 c3 f9 9b			jp macro_next 
9e2c				endm 
# End of macro NEXTW
9e2c			 
9e2c			; dead code - old version  
9e2c			;	FORTH_RSP_NEXT 
9e2c			 
9e2c			;  
9e2c			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9e2c			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9e2c			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9e2c			;	push hl 
9e2c			;	push de 
9e2c			;	push bc 
9e2c			; 
9e2c			; 
9e2c			;		if DEBUG_FORTH_WORDS_KEY 
9e2c			;			DMARK "EXR" 
9e2c			;			CALLMONITOR 
9e2c			;		endif 
9e2c			; 
9e2c			; 
9e2c			; 
9e2c			;	;v5 FORTH_DSP_VALUE 
9e2c			;	FORTH_DSP_VALUEHL 
9e2c			; 
9e2c			;	; TODO do string type checks 
9e2c			; 
9e2c			;;v5	inc hl   ; skip type 
9e2c			; 
9e2c			;	push hl  ; source code  
9e2c			;		if DEBUG_FORTH_WORDS 
9e2c			;			DMARK "EX1" 
9e2c			;			CALLMONITOR 
9e2c			;		endif 
9e2c			;	ld a, 0 
9e2c			;	call strlent 
9e2c			; 
9e2c			;	inc hl 
9e2c			;	inc hl 
9e2c			;	inc hl 
9e2c			;	inc hl 
9e2c			; 
9e2c			;	push hl    ; size 
9e2c			; 
9e2c			;		if DEBUG_FORTH_WORDS 
9e2c			;			DMARK "EX2" 
9e2c			;			CALLMONITOR 
9e2c			;		endif 
9e2c			;	call malloc 
9e2c			; 
9e2c			;	ex de, hl    ; de now contains malloc area 
9e2c			;	pop bc   	; get byte count 
9e2c			;	pop hl      ; get string to copy 
9e2c			; 
9e2c			;	push de     ; save malloc for free later 
9e2c			; 
9e2c			;		if DEBUG_FORTH_WORDS 
9e2c			;			DMARK "EX3" 
9e2c			;			CALLMONITOR 
9e2c			;		endif 
9e2c			;	ldir       ; duplicate string 
9e2c			; 
9e2c			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9e2c			;	 
9e2c			;	; TODO fix the parse would be better than this...  
9e2c			;	ex de, hl 
9e2c			;	dec hl 
9e2c			;	ld a, 0 
9e2c			;	ld (hl), a 
9e2c			;	dec hl 
9e2c			;	ld a, ' ' 
9e2c			;	ld (hl), a 
9e2c			;	dec hl 
9e2c			;	ld (hl), a 
9e2c			; 
9e2c			;	dec hl 
9e2c			;	ld (hl), a 
9e2c			; 
9e2c			; 
9e2c			;	FORTH_DSP_POP  
9e2c			; 
9e2c			;	pop hl     
9e2c			;	push hl    ; save malloc area 
9e2c			; 
9e2c			;		if DEBUG_FORTH_WORDS 
9e2c			;			DMARK "EX4" 
9e2c			;			CALLMONITOR 
9e2c			;		endif 
9e2c			; 
9e2c			;	call forthparse 
9e2c			;	call forthexec 
9e2c			;	 
9e2c			;	pop hl 
9e2c			;	if DEBUG_FORTH_WORDS 
9e2c			;		DMARK "EX5" 
9e2c			;		CALLMONITOR 
9e2c			;	endif 
9e2c			; 
9e2c			;	if FORTH_ENABLE_FREE 
9e2c			;	call free 
9e2c			;	endif 
9e2c			; 
9e2c			;	if DEBUG_FORTH_WORDS 
9e2c			;		DMARK "EX6" 
9e2c			;		CALLMONITOR 
9e2c			;	endif 
9e2c			; 
9e2c			;	pop bc 
9e2c			;	pop de 
9e2c			;	pop hl 
9e2c			;;	FORTH_RSP_POP	  
9e2c			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9e2c			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9e2c			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9e2c			; 
9e2c			;	if DEBUG_FORTH_WORDS 
9e2c			;		DMARK "EX7" 
9e2c			;		CALLMONITOR 
9e2c			;	endif 
9e2c			;	NEXTW 
9e2c			 
9e2c			.STKEXEC: 
9e2c				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9e2c 3f				db WORD_SYS_CORE+43             
9e2d 74 9f			dw .ZDUP            
9e2f 08				db 7 + 1 
9e30 .. 00			db "STKEXEC",0              
9e38				endm 
# End of macro CWHEAD
9e38			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
9e38			 
9e38			 
9e38					if DEBUG_FORTH_WORDS_KEY 
9e38						DMARK "STX" 
9e38 f5				push af  
9e39 3a 4d 9e			ld a, (.dmark)  
9e3c 32 7a ee			ld (debug_mark),a  
9e3f 3a 4e 9e			ld a, (.dmark+1)  
9e42 32 7b ee			ld (debug_mark+1),a  
9e45 3a 4f 9e			ld a, (.dmark+2)  
9e48 32 7c ee			ld (debug_mark+2),a  
9e4b 18 03			jr .pastdmark  
9e4d ..			.dmark: db "STX"  
9e50 f1			.pastdmark: pop af  
9e51			endm  
# End of macro DMARK
9e51						CALLMONITOR 
9e51 cd 03 93			call break_point_state  
9e54				endm  
# End of macro CALLMONITOR
9e54					endif 
9e54			 
9e54				FORTH_DSP_VALUEHL 
9e54 cd 87 9a			call macro_dsp_valuehl 
9e57				endm 
# End of macro FORTH_DSP_VALUEHL
9e57			 
9e57 22 63 eb			ld (store_tmp1), hl    ; count 
9e5a			 
9e5a				FORTH_DSP_POP 
9e5a cd 3f 9b			call macro_forth_dsp_pop 
9e5d				endm 
# End of macro FORTH_DSP_POP
9e5d			.stkexec1: 
9e5d 2a 63 eb			ld hl, (store_tmp1)   ; count 
9e60 3e 00			ld a, 0 
9e62 bd				cp l 
9e63 c8				ret z 
9e64			 
9e64 2b				dec hl 
9e65 22 63 eb			ld (store_tmp1), hl    ; count 
9e68				 
9e68				FORTH_DSP_VALUEHL 
9e68 cd 87 9a			call macro_dsp_valuehl 
9e6b				endm 
# End of macro FORTH_DSP_VALUEHL
9e6b e5				push hl 
9e6c				 
9e6c					if DEBUG_FORTH_WORDS 
9e6c						DMARK "EXp" 
9e6c f5				push af  
9e6d 3a 81 9e			ld a, (.dmark)  
9e70 32 7a ee			ld (debug_mark),a  
9e73 3a 82 9e			ld a, (.dmark+1)  
9e76 32 7b ee			ld (debug_mark+1),a  
9e79 3a 83 9e			ld a, (.dmark+2)  
9e7c 32 7c ee			ld (debug_mark+2),a  
9e7f 18 03			jr .pastdmark  
9e81 ..			.dmark: db "EXp"  
9e84 f1			.pastdmark: pop af  
9e85			endm  
# End of macro DMARK
9e85						CALLMONITOR 
9e85 cd 03 93			call break_point_state  
9e88				endm  
# End of macro CALLMONITOR
9e88					endif 
9e88				FORTH_DSP_POP 
9e88 cd 3f 9b			call macro_forth_dsp_pop 
9e8b				endm 
# End of macro FORTH_DSP_POP
9e8b			 
9e8b cd 05 8f			call strlenz 
9e8e 23				inc hl   ; include zero term to copy 
9e8f 23				inc hl   ; include zero term to copy 
9e90 23				inc hl   ; include zero term to copy 
9e91 06 00			ld b,0 
9e93 4d				ld c,l 
9e94 e1				pop hl 
9e95 11 5f e4			ld de, execscratch 
9e98					if DEBUG_FORTH_WORDS 
9e98						DMARK "EX3" 
9e98 f5				push af  
9e99 3a ad 9e			ld a, (.dmark)  
9e9c 32 7a ee			ld (debug_mark),a  
9e9f 3a ae 9e			ld a, (.dmark+1)  
9ea2 32 7b ee			ld (debug_mark+1),a  
9ea5 3a af 9e			ld a, (.dmark+2)  
9ea8 32 7c ee			ld (debug_mark+2),a  
9eab 18 03			jr .pastdmark  
9ead ..			.dmark: db "EX3"  
9eb0 f1			.pastdmark: pop af  
9eb1			endm  
# End of macro DMARK
9eb1						CALLMONITOR 
9eb1 cd 03 93			call break_point_state  
9eb4				endm  
# End of macro CALLMONITOR
9eb4					endif 
9eb4 ed b0			ldir 
9eb6			 
9eb6			 
9eb6 21 5f e4			ld hl, execscratch 
9eb9			 
9eb9					if DEBUG_FORTH_WORDS 
9eb9						DMARK "EXP" 
9eb9 f5				push af  
9eba 3a ce 9e			ld a, (.dmark)  
9ebd 32 7a ee			ld (debug_mark),a  
9ec0 3a cf 9e			ld a, (.dmark+1)  
9ec3 32 7b ee			ld (debug_mark+1),a  
9ec6 3a d0 9e			ld a, (.dmark+2)  
9ec9 32 7c ee			ld (debug_mark+2),a  
9ecc 18 03			jr .pastdmark  
9ece ..			.dmark: db "EXP"  
9ed1 f1			.pastdmark: pop af  
9ed2			endm  
# End of macro DMARK
9ed2						CALLMONITOR 
9ed2 cd 03 93			call break_point_state  
9ed5				endm  
# End of macro CALLMONITOR
9ed5					endif 
9ed5			 
9ed5 cd 47 9c			call forthparse 
9ed8 21 5f e4			ld hl, execscratch 
9edb					if DEBUG_FORTH_WORDS 
9edb						DMARK "EXx" 
9edb f5				push af  
9edc 3a f0 9e			ld a, (.dmark)  
9edf 32 7a ee			ld (debug_mark),a  
9ee2 3a f1 9e			ld a, (.dmark+1)  
9ee5 32 7b ee			ld (debug_mark+1),a  
9ee8 3a f2 9e			ld a, (.dmark+2)  
9eeb 32 7c ee			ld (debug_mark+2),a  
9eee 18 03			jr .pastdmark  
9ef0 ..			.dmark: db "EXx"  
9ef3 f1			.pastdmark: pop af  
9ef4			endm  
# End of macro DMARK
9ef4						CALLMONITOR 
9ef4 cd 03 93			call break_point_state  
9ef7				endm  
# End of macro CALLMONITOR
9ef7					endif 
9ef7 cd 87 9c			call forthexec 
9efa			 
9efa c3 5d 9e			jp .stkexec1 
9efd			 
9efd c9				ret 
9efe			 
9efe			 
9efe			.DUP: 
9efe				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9efe 17				db WORD_SYS_CORE+OPCODE_DUP             
9eff 74 9f			dw .ZDUP            
9f01 04				db 3 + 1 
9f02 .. 00			db "DUP",0              
9f06				endm 
# End of macro CWHEAD
9f06			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9f06			 
9f06					if DEBUG_FORTH_WORDS_KEY 
9f06						DMARK "DUP" 
9f06 f5				push af  
9f07 3a 1b 9f			ld a, (.dmark)  
9f0a 32 7a ee			ld (debug_mark),a  
9f0d 3a 1c 9f			ld a, (.dmark+1)  
9f10 32 7b ee			ld (debug_mark+1),a  
9f13 3a 1d 9f			ld a, (.dmark+2)  
9f16 32 7c ee			ld (debug_mark+2),a  
9f19 18 03			jr .pastdmark  
9f1b ..			.dmark: db "DUP"  
9f1e f1			.pastdmark: pop af  
9f1f			endm  
# End of macro DMARK
9f1f						CALLMONITOR 
9f1f cd 03 93			call break_point_state  
9f22				endm  
# End of macro CALLMONITOR
9f22					endif 
9f22			 
9f22					FORTH_DSP 
9f22 cd 4d 9a			call macro_forth_dsp 
9f25				endm 
# End of macro FORTH_DSP
9f25			 
9f25 7e					ld a, (HL) 
9f26 fe 01				cp DS_TYPE_STR 
9f28 20 25				jr nz, .dupinum 
9f2a			 
9f2a					; push another string 
9f2a			 
9f2a					FORTH_DSP_VALUEHL     		 
9f2a cd 87 9a			call macro_dsp_valuehl 
9f2d				endm 
# End of macro FORTH_DSP_VALUEHL
9f2d			 
9f2d				if DEBUG_FORTH_WORDS 
9f2d					DMARK "DUs" 
9f2d f5				push af  
9f2e 3a 42 9f			ld a, (.dmark)  
9f31 32 7a ee			ld (debug_mark),a  
9f34 3a 43 9f			ld a, (.dmark+1)  
9f37 32 7b ee			ld (debug_mark+1),a  
9f3a 3a 44 9f			ld a, (.dmark+2)  
9f3d 32 7c ee			ld (debug_mark+2),a  
9f40 18 03			jr .pastdmark  
9f42 ..			.dmark: db "DUs"  
9f45 f1			.pastdmark: pop af  
9f46			endm  
# End of macro DMARK
9f46					CALLMONITOR 
9f46 cd 03 93			call break_point_state  
9f49				endm  
# End of macro CALLMONITOR
9f49				endif 
9f49 cd fe 98				call forth_push_str 
9f4c			 
9f4c					NEXTW 
9f4c c3 f9 9b			jp macro_next 
9f4f				endm 
# End of macro NEXTW
9f4f			 
9f4f			 
9f4f			.dupinum: 
9f4f					 
9f4f			 
9f4f			 
9f4f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9f4f cd 87 9a			call macro_dsp_valuehl 
9f52				endm 
# End of macro FORTH_DSP_VALUEHL
9f52			 
9f52				; TODO add floating point number detection 
9f52			 
9f52				if DEBUG_FORTH_WORDS 
9f52					DMARK "DUi" 
9f52 f5				push af  
9f53 3a 67 9f			ld a, (.dmark)  
9f56 32 7a ee			ld (debug_mark),a  
9f59 3a 68 9f			ld a, (.dmark+1)  
9f5c 32 7b ee			ld (debug_mark+1),a  
9f5f 3a 69 9f			ld a, (.dmark+2)  
9f62 32 7c ee			ld (debug_mark+2),a  
9f65 18 03			jr .pastdmark  
9f67 ..			.dmark: db "DUi"  
9f6a f1			.pastdmark: pop af  
9f6b			endm  
# End of macro DMARK
9f6b					CALLMONITOR 
9f6b cd 03 93			call break_point_state  
9f6e				endm  
# End of macro CALLMONITOR
9f6e				endif 
9f6e			 
9f6e cd 90 98				call forth_push_numhl 
9f71					NEXTW 
9f71 c3 f9 9b			jp macro_next 
9f74				endm 
# End of macro NEXTW
9f74			.ZDUP: 
9f74				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9f74 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9f75 ac 9f			dw .SWAP            
9f77 05				db 4 + 1 
9f78 .. 00			db "?DUP",0              
9f7d				endm 
# End of macro CWHEAD
9f7d			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
9f7d			 
9f7d					if DEBUG_FORTH_WORDS_KEY 
9f7d						DMARK "qDU" 
9f7d f5				push af  
9f7e 3a 92 9f			ld a, (.dmark)  
9f81 32 7a ee			ld (debug_mark),a  
9f84 3a 93 9f			ld a, (.dmark+1)  
9f87 32 7b ee			ld (debug_mark+1),a  
9f8a 3a 94 9f			ld a, (.dmark+2)  
9f8d 32 7c ee			ld (debug_mark+2),a  
9f90 18 03			jr .pastdmark  
9f92 ..			.dmark: db "qDU"  
9f95 f1			.pastdmark: pop af  
9f96			endm  
# End of macro DMARK
9f96						CALLMONITOR 
9f96 cd 03 93			call break_point_state  
9f99				endm  
# End of macro CALLMONITOR
9f99					endif 
9f99					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9f99 cd 87 9a			call macro_dsp_valuehl 
9f9c				endm 
# End of macro FORTH_DSP_VALUEHL
9f9c			 
9f9c e5					push hl 
9f9d			 
9f9d					; is it a zero? 
9f9d			 
9f9d 3e 00				ld a, 0 
9f9f 84					add h 
9fa0 85					add l 
9fa1			 
9fa1 e1					pop hl 
9fa2			 
9fa2 fe 00				cp 0 
9fa4 28 03				jr z, .dup2orig 
9fa6			 
9fa6			 
9fa6 cd 90 98				call forth_push_numhl 
9fa9			 
9fa9			 
9fa9				; TODO add floating point number detection 
9fa9			 
9fa9			.dup2orig: 
9fa9			 
9fa9					NEXTW 
9fa9 c3 f9 9b			jp macro_next 
9fac				endm 
# End of macro NEXTW
9fac			.SWAP: 
9fac				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
9fac 18				db WORD_SYS_CORE+OPCODE_SWAP             
9fad eb 9f			dw .COLN            
9faf 05				db 4 + 1 
9fb0 .. 00			db "SWAP",0              
9fb5				endm 
# End of macro CWHEAD
9fb5			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
9fb5					if DEBUG_FORTH_WORDS_KEY 
9fb5						DMARK "SWP" 
9fb5 f5				push af  
9fb6 3a ca 9f			ld a, (.dmark)  
9fb9 32 7a ee			ld (debug_mark),a  
9fbc 3a cb 9f			ld a, (.dmark+1)  
9fbf 32 7b ee			ld (debug_mark+1),a  
9fc2 3a cc 9f			ld a, (.dmark+2)  
9fc5 32 7c ee			ld (debug_mark+2),a  
9fc8 18 03			jr .pastdmark  
9fca ..			.dmark: db "SWP"  
9fcd f1			.pastdmark: pop af  
9fce			endm  
# End of macro DMARK
9fce						CALLMONITOR 
9fce cd 03 93			call break_point_state  
9fd1				endm  
# End of macro CALLMONITOR
9fd1					endif 
9fd1			 
9fd1					FORTH_DSP_VALUEHL 
9fd1 cd 87 9a			call macro_dsp_valuehl 
9fd4				endm 
# End of macro FORTH_DSP_VALUEHL
9fd4 e5					push hl     ; w2 
9fd5			 
9fd5					FORTH_DSP_POP 
9fd5 cd 3f 9b			call macro_forth_dsp_pop 
9fd8				endm 
# End of macro FORTH_DSP_POP
9fd8			 
9fd8					FORTH_DSP_VALUEHL 
9fd8 cd 87 9a			call macro_dsp_valuehl 
9fdb				endm 
# End of macro FORTH_DSP_VALUEHL
9fdb			 
9fdb					FORTH_DSP_POP 
9fdb cd 3f 9b			call macro_forth_dsp_pop 
9fde				endm 
# End of macro FORTH_DSP_POP
9fde			 
9fde d1					pop de     ; w2	, hl = w1 
9fdf			 
9fdf eb					ex de, hl 
9fe0 d5					push de 
9fe1			 
9fe1 cd 90 98				call forth_push_numhl 
9fe4			 
9fe4 e1					pop hl 
9fe5			 
9fe5 cd 90 98				call forth_push_numhl 
9fe8					 
9fe8			 
9fe8					NEXTW 
9fe8 c3 f9 9b			jp macro_next 
9feb				endm 
# End of macro NEXTW
9feb			.COLN: 
9feb				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
9feb 19				db WORD_SYS_CORE+OPCODE_COLN             
9fec 77 a1			dw .SCOLN            
9fee 02				db 1 + 1 
9fef .. 00			db ":",0              
9ff1				endm 
# End of macro CWHEAD
9ff1			; | : ( -- )         Create new word | DONE 
9ff1			 
9ff1					if DEBUG_FORTH_WORDS_KEY 
9ff1						DMARK "CLN" 
9ff1 f5				push af  
9ff2 3a 06 a0			ld a, (.dmark)  
9ff5 32 7a ee			ld (debug_mark),a  
9ff8 3a 07 a0			ld a, (.dmark+1)  
9ffb 32 7b ee			ld (debug_mark+1),a  
9ffe 3a 08 a0			ld a, (.dmark+2)  
a001 32 7c ee			ld (debug_mark+2),a  
a004 18 03			jr .pastdmark  
a006 ..			.dmark: db "CLN"  
a009 f1			.pastdmark: pop af  
a00a			endm  
# End of macro DMARK
a00a						CALLMONITOR 
a00a cd 03 93			call break_point_state  
a00d				endm  
# End of macro CALLMONITOR
a00d					endif 
a00d				STACKFRAME OFF $8efe $989f 
a00d				if DEBUG_STACK_IMB 
a00d					if OFF 
a00d						exx 
a00d						ld de, $8efe 
a00d						ld a, d 
a00d						ld hl, curframe 
a00d						call hexout 
a00d						ld a, e 
a00d						ld hl, curframe+2 
a00d						call hexout 
a00d						ld hl, $8efe 
a00d						push hl 
a00d						ld hl, $989f 
a00d						push hl 
a00d						exx 
a00d					endif 
a00d				endif 
a00d			endm 
# End of macro STACKFRAME
a00d				; get parser buffer length  of new word 
a00d			 
a00d				 
a00d			 
a00d					; move tok past this to start of name defintition 
a00d					; TODO get word to define 
a00d					; TODO Move past word token 
a00d					; TODO get length of string up to the ';' 
a00d			 
a00d 2a 61 e6			ld hl, (os_tok_ptr) 
a010 23				inc hl 
a011 23				inc hl 
a012			 
a012 3e 3b			ld a, ';' 
a014 cd 10 8f			call strlent 
a017			 
a017 7d				ld a,l 
a018 32 5c e3			ld (os_new_parse_len), a 
a01b			 
a01b			 
a01b			if DEBUG_FORTH_UWORD 
a01b ed 5b 61 e6		ld de, (os_tok_ptr) 
a01f						DMARK ":01" 
a01f f5				push af  
a020 3a 34 a0			ld a, (.dmark)  
a023 32 7a ee			ld (debug_mark),a  
a026 3a 35 a0			ld a, (.dmark+1)  
a029 32 7b ee			ld (debug_mark+1),a  
a02c 3a 36 a0			ld a, (.dmark+2)  
a02f 32 7c ee			ld (debug_mark+2),a  
a032 18 03			jr .pastdmark  
a034 ..			.dmark: db ":01"  
a037 f1			.pastdmark: pop af  
a038			endm  
# End of macro DMARK
a038				CALLMONITOR 
a038 cd 03 93			call break_point_state  
a03b				endm  
# End of macro CALLMONITOR
a03b			endif 
a03b			 
a03b			; 
a03b			;  new word memory layout: 
a03b			;  
a03b			;    : adg 6666 ;  
a03b			; 
a03b			;    db   1     ; user defined word  
a03b 23				inc hl    
a03c			;    dw   sysdict 
a03c 23				inc hl 
a03d 23				inc hl 
a03e			;    db <word len>+1 (for null) 
a03e 23				inc hl 
a03f			;    db .... <word> 
a03f			; 
a03f			 
a03f 23				inc hl    ; some extras for the word preamble before the above 
a040 23				inc hl 
a041 23				inc hl 
a042 23				inc hl 
a043 23				inc hl 
a044 23				inc hl 
a045 23				inc hl  
a046 23				inc hl 
a047 23				inc hl 
a048 23				inc hl 
a049 23				inc hl 
a04a 23				inc hl 
a04b 23				inc hl 
a04c 23				inc hl     ; TODO how many do we really need?     maybe only 6 
a04d			;       exec word buffer 
a04d			;	<ptr word>   
a04d 23				inc hl 
a04e 23				inc hl 
a04f			;       <word list><null term> 7F final term 
a04f			 
a04f			 
a04f			if DEBUG_FORTH_UWORD 
a04f						DMARK ":02" 
a04f f5				push af  
a050 3a 64 a0			ld a, (.dmark)  
a053 32 7a ee			ld (debug_mark),a  
a056 3a 65 a0			ld a, (.dmark+1)  
a059 32 7b ee			ld (debug_mark+1),a  
a05c 3a 66 a0			ld a, (.dmark+2)  
a05f 32 7c ee			ld (debug_mark+2),a  
a062 18 03			jr .pastdmark  
a064 ..			.dmark: db ":02"  
a067 f1			.pastdmark: pop af  
a068			endm  
# End of macro DMARK
a068				CALLMONITOR 
a068 cd 03 93			call break_point_state  
a06b				endm  
# End of macro CALLMONITOR
a06b			endif 
a06b			 
a06b				 
a06b					; malloc the size 
a06b			 
a06b cd 6e 8f				call malloc 
a06e 22 5e e3				ld (os_new_malloc), hl     ; save malloc start 
a071			 
a071			;    db   1     ; user defined word  
a071 3e 01				ld a, WORD_SYS_UWORD  
a073 77					ld (hl), a 
a074				 
a074 23				inc hl    
a075			;    dw   sysdict 
a075 11 51 9d			ld de, sysdict       ; continue on with the scan to the system dict 
a078 73				ld (hl), e 
a079 23				inc hl 
a07a 72				ld (hl), d 
a07b 23				inc hl 
a07c			 
a07c			 
a07c			;    Setup dict word 
a07c			 
a07c 23				inc hl 
a07d 22 58 e3			ld (os_new_work_ptr), hl     ; save start of dict word  
a080			 
a080				; 1. get length of dict word 
a080			 
a080			 
a080 2a 61 e6			ld hl, (os_tok_ptr) 
a083 23				inc hl 
a084 23				inc hl    ; position to start of dict word 
a085 3e 00			ld a, 0 
a087 cd 10 8f			call strlent 
a08a			 
a08a			 
a08a 23				inc hl    ; to include null??? 
a08b			 
a08b				; write length of dict word 
a08b			 
a08b ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a08f 1b				dec de 
a090 eb				ex de, hl 
a091 73				ld (hl), e 
a092 eb				ex de, hl 
a093			 
a093				 
a093			 
a093				; copy  
a093 4d				ld c, l 
a094 06 00			ld b, 0 
a096 ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a09a 2a 61 e6			ld hl, (os_tok_ptr) 
a09d 23				inc hl 
a09e 23				inc hl    ; position to start of dict word 
a09f				 
a09f			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a09f				 
a09f				; TODO need to convert word to upper case 
a09f			 
a09f			ucasetok:	 
a09f 7e				ld a,(hl) 
a0a0 cd fc 8e			call toUpper 
a0a3 77				ld (hl),a 
a0a4 ed a0			ldi 
a0a6 f2 9f a0		 	jp p, ucasetok 
a0a9			 
a0a9			 
a0a9			 
a0a9				; de now points to start of where the word body code should be placed 
a0a9 ed 53 58 e3		ld (os_new_work_ptr), de 
a0ad				; hl now points to the words to throw at forthexec which needs to be copied 
a0ad 22 56 e3			ld (os_new_src_ptr), hl 
a0b0			 
a0b0				; TODO add 'call to forthexec' 
a0b0			 
a0b0			if DEBUG_FORTH_UWORD 
a0b0 c5				push bc 
a0b1 ed 4b 5e e3		ld bc, (os_new_malloc) 
a0b5						DMARK ":0x" 
a0b5 f5				push af  
a0b6 3a ca a0			ld a, (.dmark)  
a0b9 32 7a ee			ld (debug_mark),a  
a0bc 3a cb a0			ld a, (.dmark+1)  
a0bf 32 7b ee			ld (debug_mark+1),a  
a0c2 3a cc a0			ld a, (.dmark+2)  
a0c5 32 7c ee			ld (debug_mark+2),a  
a0c8 18 03			jr .pastdmark  
a0ca ..			.dmark: db ":0x"  
a0cd f1			.pastdmark: pop af  
a0ce			endm  
# End of macro DMARK
a0ce				CALLMONITOR 
a0ce cd 03 93			call break_point_state  
a0d1				endm  
# End of macro CALLMONITOR
a0d1 c1				pop bc 
a0d2			endif 
a0d2			 
a0d2			 
a0d2				; create word preamble which should be: 
a0d2			 
a0d2			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a0d2			 
a0d2				;    ld hl, <word code> 
a0d2				;    jp user_exec 
a0d2			        ;    <word code bytes> 
a0d2			 
a0d2			 
a0d2			;	inc de     ; TODO ??? or are we already past the word's null 
a0d2 eb				ex de, hl 
a0d3			 
a0d3 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a0d5			 
a0d5 23				inc hl 
a0d6 22 52 e3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a0d9 23				inc hl 
a0da			 
a0da 23				inc hl 
a0db 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a0dd			 
a0dd 01 66 c4			ld bc, user_exec 
a0e0 23				inc hl 
a0e1 71				ld (hl), c     ; poke address of user_exec 
a0e2 23				inc hl 
a0e3 70				ld (hl), b     
a0e4			 ; 
a0e4			;	inc hl 
a0e4			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a0e4			; 
a0e4			; 
a0e4			;	ld bc, macro_forth_rsp_next 
a0e4			;	inc hl 
a0e4			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a0e4			;	inc hl 
a0e4			;	ld (hl), b     
a0e4			 ; 
a0e4			;	inc hl 
a0e4			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a0e4			; 
a0e4			; 
a0e4			;	inc hl 
a0e4			;	ld bc, forthexec 
a0e4			;	ld (hl), c     ; poke address of forthexec 
a0e4			;	inc hl 
a0e4			;	ld (hl), b      
a0e4			; 
a0e4			;	inc hl 
a0e4			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a0e4			; 
a0e4			;	ld bc, user_dict_next 
a0e4			;	inc hl 
a0e4			;	ld (hl), c     ; poke address of forthexec 
a0e4			;	inc hl 
a0e4			;	ld (hl), b      
a0e4			 
a0e4				; hl is now where we need to copy the word byte data to save this 
a0e4			 
a0e4 23				inc hl 
a0e5 22 54 e3			ld (os_new_exec), hl 
a0e8				 
a0e8				; copy definition 
a0e8			 
a0e8 eb				ex de, hl 
a0e9			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a0e9			;	inc de    ; skip the PC for this parse 
a0e9 3a 5c e3			ld a, (os_new_parse_len) 
a0ec 4f				ld c, a 
a0ed 06 00			ld b, 0 
a0ef ed b0			ldir		 ; copy defintion 
a0f1			 
a0f1			 
a0f1				; poke the address of where the new word bytes live for forthexec 
a0f1			 
a0f1 2a 52 e3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a0f4			 
a0f4 ed 5b 54 e3		ld de, (os_new_exec)      
a0f8				 
a0f8 73				ld (hl), e 
a0f9 23				inc hl 
a0fa 72				ld (hl), d 
a0fb			 
a0fb					; TODO copy last user dict word next link to this word 
a0fb					; TODO update last user dict word to point to this word 
a0fb			; 
a0fb			; hl f923 de 812a ; bc 811a 
a0fb			 
a0fb			if DEBUG_FORTH_UWORD 
a0fb c5				push bc 
a0fc ed 4b 5e e3		ld bc, (os_new_malloc) 
a100						DMARK ":0A" 
a100 f5				push af  
a101 3a 15 a1			ld a, (.dmark)  
a104 32 7a ee			ld (debug_mark),a  
a107 3a 16 a1			ld a, (.dmark+1)  
a10a 32 7b ee			ld (debug_mark+1),a  
a10d 3a 17 a1			ld a, (.dmark+2)  
a110 32 7c ee			ld (debug_mark+2),a  
a113 18 03			jr .pastdmark  
a115 ..			.dmark: db ":0A"  
a118 f1			.pastdmark: pop af  
a119			endm  
# End of macro DMARK
a119				CALLMONITOR 
a119 cd 03 93			call break_point_state  
a11c				endm  
# End of macro CALLMONITOR
a11c c1				pop bc 
a11d			endif 
a11d			if DEBUG_FORTH_UWORD 
a11d c5				push bc 
a11e ed 4b 5e e3		ld bc, (os_new_malloc) 
a122 03				inc bc 
a123 03				inc bc 
a124 03				inc bc 
a125 03				inc bc 
a126 03				inc bc 
a127 03				inc bc 
a128 03				inc bc 
a129 03				inc bc 
a12a			 
a12a						DMARK ":0B" 
a12a f5				push af  
a12b 3a 3f a1			ld a, (.dmark)  
a12e 32 7a ee			ld (debug_mark),a  
a131 3a 40 a1			ld a, (.dmark+1)  
a134 32 7b ee			ld (debug_mark+1),a  
a137 3a 41 a1			ld a, (.dmark+2)  
a13a 32 7c ee			ld (debug_mark+2),a  
a13d 18 03			jr .pastdmark  
a13f ..			.dmark: db ":0B"  
a142 f1			.pastdmark: pop af  
a143			endm  
# End of macro DMARK
a143				CALLMONITOR 
a143 cd 03 93			call break_point_state  
a146				endm  
# End of macro CALLMONITOR
a146 c1				pop bc 
a147			endif 
a147			 
a147			; update word dict linked list for new word 
a147			 
a147			 
a147 2a 5d e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a14a 23			inc hl     ; move to next work linked list ptr 
a14b			 
a14b ed 5b 5e e3	ld de, (os_new_malloc)		 ; new next word 
a14f 73			ld (hl), e 
a150 23			inc hl 
a151 72			ld (hl), d 
a152			 
a152			if DEBUG_FORTH_UWORD 
a152 ed 4b 5d e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a156			endif 
a156			 
a156 ed 53 5d e6	ld (os_last_new_uword), de      ; update last new uword ptr 
a15a			 
a15a			 
a15a			if DEBUG_FORTH_UWORD 
a15a						DMARK ":0+" 
a15a f5				push af  
a15b 3a 6f a1			ld a, (.dmark)  
a15e 32 7a ee			ld (debug_mark),a  
a161 3a 70 a1			ld a, (.dmark+1)  
a164 32 7b ee			ld (debug_mark+1),a  
a167 3a 71 a1			ld a, (.dmark+2)  
a16a 32 7c ee			ld (debug_mark+2),a  
a16d 18 03			jr .pastdmark  
a16f ..			.dmark: db ":0+"  
a172 f1			.pastdmark: pop af  
a173			endm  
# End of macro DMARK
a173				CALLMONITOR 
a173 cd 03 93			call break_point_state  
a176				endm  
# End of macro CALLMONITOR
a176			endif 
a176			 
a176				STACKFRAMECHK OFF $8efe $989f 
a176				if DEBUG_STACK_IMB 
a176					if OFF 
a176						exx 
a176						ld hl, $989f 
a176						pop de   ; $989f 
a176						call cmp16 
a176						jr nz, .spnosame 
a176						ld hl, $8efe 
a176						pop de   ; $8efe 
a176						call cmp16 
a176						jr z, .spfrsame 
a176						.spnosame: call showsperror 
a176						.spfrsame: nop 
a176						exx 
a176					endif 
a176				endif 
a176			endm 
# End of macro STACKFRAMECHK
a176			 
a176 c9			ret    ; dont process any remaining parser tokens as they form new word 
a177			 
a177			 
a177			 
a177			 
a177			;		NEXT 
a177			.SCOLN: 
a177			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a177 06				db OPCODE_SCOLN 
a178 c3 a1			dw .DROP 
a17a 02				db 2 
a17b .. 00			db ";",0           
a17d			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a17d					if DEBUG_FORTH_WORDS_KEY 
a17d						DMARK "SCN" 
a17d f5				push af  
a17e 3a 92 a1			ld a, (.dmark)  
a181 32 7a ee			ld (debug_mark),a  
a184 3a 93 a1			ld a, (.dmark+1)  
a187 32 7b ee			ld (debug_mark+1),a  
a18a 3a 94 a1			ld a, (.dmark+2)  
a18d 32 7c ee			ld (debug_mark+2),a  
a190 18 03			jr .pastdmark  
a192 ..			.dmark: db "SCN"  
a195 f1			.pastdmark: pop af  
a196			endm  
# End of macro DMARK
a196						CALLMONITOR 
a196 cd 03 93			call break_point_state  
a199				endm  
# End of macro CALLMONITOR
a199					endif 
a199					FORTH_RSP_TOS 
a199 cd 4e 98			call macro_forth_rsp_tos 
a19c				endm 
# End of macro FORTH_RSP_TOS
a19c e5					push hl 
a19d					FORTH_RSP_POP 
a19d cd 58 98			call macro_forth_rsp_pop 
a1a0				endm 
# End of macro FORTH_RSP_POP
a1a0 e1					pop hl 
a1a1			;		ex de,hl 
a1a1 22 61 e6				ld (os_tok_ptr),hl 
a1a4			 
a1a4			if DEBUG_FORTH_UWORD 
a1a4						DMARK "SCL" 
a1a4 f5				push af  
a1a5 3a b9 a1			ld a, (.dmark)  
a1a8 32 7a ee			ld (debug_mark),a  
a1ab 3a ba a1			ld a, (.dmark+1)  
a1ae 32 7b ee			ld (debug_mark+1),a  
a1b1 3a bb a1			ld a, (.dmark+2)  
a1b4 32 7c ee			ld (debug_mark+2),a  
a1b7 18 03			jr .pastdmark  
a1b9 ..			.dmark: db "SCL"  
a1bc f1			.pastdmark: pop af  
a1bd			endm  
# End of macro DMARK
a1bd				CALLMONITOR 
a1bd cd 03 93			call break_point_state  
a1c0				endm  
# End of macro CALLMONITOR
a1c0			endif 
a1c0					NEXTW 
a1c0 c3 f9 9b			jp macro_next 
a1c3				endm 
# End of macro NEXTW
a1c3			 
a1c3			.DROP: 
a1c3				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a1c3 1b				db WORD_SYS_CORE+OPCODE_DROP             
a1c4 ee a1			dw .DUP2            
a1c6 05				db 4 + 1 
a1c7 .. 00			db "DROP",0              
a1cc				endm 
# End of macro CWHEAD
a1cc			; | DROP ( w -- )   drop the TOS item   | DONE 
a1cc					if DEBUG_FORTH_WORDS_KEY 
a1cc						DMARK "DRP" 
a1cc f5				push af  
a1cd 3a e1 a1			ld a, (.dmark)  
a1d0 32 7a ee			ld (debug_mark),a  
a1d3 3a e2 a1			ld a, (.dmark+1)  
a1d6 32 7b ee			ld (debug_mark+1),a  
a1d9 3a e3 a1			ld a, (.dmark+2)  
a1dc 32 7c ee			ld (debug_mark+2),a  
a1df 18 03			jr .pastdmark  
a1e1 ..			.dmark: db "DRP"  
a1e4 f1			.pastdmark: pop af  
a1e5			endm  
# End of macro DMARK
a1e5						CALLMONITOR 
a1e5 cd 03 93			call break_point_state  
a1e8				endm  
# End of macro CALLMONITOR
a1e8					endif 
a1e8					FORTH_DSP_POP 
a1e8 cd 3f 9b			call macro_forth_dsp_pop 
a1eb				endm 
# End of macro FORTH_DSP_POP
a1eb					NEXTW 
a1eb c3 f9 9b			jp macro_next 
a1ee				endm 
# End of macro NEXTW
a1ee			.DUP2: 
a1ee				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a1ee 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a1ef 33 a2			dw .DROP2            
a1f1 05				db 4 + 1 
a1f2 .. 00			db "2DUP",0              
a1f7				endm 
# End of macro CWHEAD
a1f7			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a1f7					if DEBUG_FORTH_WORDS_KEY 
a1f7						DMARK "2DU" 
a1f7 f5				push af  
a1f8 3a 0c a2			ld a, (.dmark)  
a1fb 32 7a ee			ld (debug_mark),a  
a1fe 3a 0d a2			ld a, (.dmark+1)  
a201 32 7b ee			ld (debug_mark+1),a  
a204 3a 0e a2			ld a, (.dmark+2)  
a207 32 7c ee			ld (debug_mark+2),a  
a20a 18 03			jr .pastdmark  
a20c ..			.dmark: db "2DU"  
a20f f1			.pastdmark: pop af  
a210			endm  
# End of macro DMARK
a210						CALLMONITOR 
a210 cd 03 93			call break_point_state  
a213				endm  
# End of macro CALLMONITOR
a213					endif 
a213					FORTH_DSP_VALUEHL 
a213 cd 87 9a			call macro_dsp_valuehl 
a216				endm 
# End of macro FORTH_DSP_VALUEHL
a216 e5					push hl      ; 2 
a217			 
a217					FORTH_DSP_POP 
a217 cd 3f 9b			call macro_forth_dsp_pop 
a21a				endm 
# End of macro FORTH_DSP_POP
a21a					 
a21a					FORTH_DSP_VALUEHL 
a21a cd 87 9a			call macro_dsp_valuehl 
a21d				endm 
# End of macro FORTH_DSP_VALUEHL
a21d			;		push hl      ; 1 
a21d			 
a21d					FORTH_DSP_POP 
a21d cd 3f 9b			call macro_forth_dsp_pop 
a220				endm 
# End of macro FORTH_DSP_POP
a220			 
a220			;		pop hl       ; 1 
a220 d1					pop de       ; 2 
a221			 
a221 cd 90 98				call forth_push_numhl 
a224 eb					ex de, hl 
a225 cd 90 98				call forth_push_numhl 
a228			 
a228					 
a228 eb					ex de, hl 
a229			 
a229 cd 90 98				call forth_push_numhl 
a22c eb					ex de, hl 
a22d cd 90 98				call forth_push_numhl 
a230			 
a230			 
a230					NEXTW 
a230 c3 f9 9b			jp macro_next 
a233				endm 
# End of macro NEXTW
a233			.DROP2: 
a233				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a233 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a234 62 a2			dw .SWAP2            
a236 06				db 5 + 1 
a237 .. 00			db "2DROP",0              
a23d				endm 
# End of macro CWHEAD
a23d			; | 2DROP ( w w -- )    Double drop | DONE 
a23d					if DEBUG_FORTH_WORDS_KEY 
a23d						DMARK "2DR" 
a23d f5				push af  
a23e 3a 52 a2			ld a, (.dmark)  
a241 32 7a ee			ld (debug_mark),a  
a244 3a 53 a2			ld a, (.dmark+1)  
a247 32 7b ee			ld (debug_mark+1),a  
a24a 3a 54 a2			ld a, (.dmark+2)  
a24d 32 7c ee			ld (debug_mark+2),a  
a250 18 03			jr .pastdmark  
a252 ..			.dmark: db "2DR"  
a255 f1			.pastdmark: pop af  
a256			endm  
# End of macro DMARK
a256						CALLMONITOR 
a256 cd 03 93			call break_point_state  
a259				endm  
# End of macro CALLMONITOR
a259					endif 
a259					FORTH_DSP_POP 
a259 cd 3f 9b			call macro_forth_dsp_pop 
a25c				endm 
# End of macro FORTH_DSP_POP
a25c					FORTH_DSP_POP 
a25c cd 3f 9b			call macro_forth_dsp_pop 
a25f				endm 
# End of macro FORTH_DSP_POP
a25f					NEXTW 
a25f c3 f9 9b			jp macro_next 
a262				endm 
# End of macro NEXTW
a262			.SWAP2: 
a262				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a262 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a263 8b a2			dw .AT            
a265 06				db 5 + 1 
a266 .. 00			db "2SWAP",0              
a26c				endm 
# End of macro CWHEAD
a26c			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a26c					if DEBUG_FORTH_WORDS_KEY 
a26c						DMARK "2SW" 
a26c f5				push af  
a26d 3a 81 a2			ld a, (.dmark)  
a270 32 7a ee			ld (debug_mark),a  
a273 3a 82 a2			ld a, (.dmark+1)  
a276 32 7b ee			ld (debug_mark+1),a  
a279 3a 83 a2			ld a, (.dmark+2)  
a27c 32 7c ee			ld (debug_mark+2),a  
a27f 18 03			jr .pastdmark  
a281 ..			.dmark: db "2SW"  
a284 f1			.pastdmark: pop af  
a285			endm  
# End of macro DMARK
a285						CALLMONITOR 
a285 cd 03 93			call break_point_state  
a288				endm  
# End of macro CALLMONITOR
a288					endif 
a288					NEXTW 
a288 c3 f9 9b			jp macro_next 
a28b				endm 
# End of macro NEXTW
a28b			.AT: 
a28b				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a28b 1f				db WORD_SYS_CORE+OPCODE_AT             
a28c bd a2			dw .CAT            
a28e 02				db 1 + 1 
a28f .. 00			db "@",0              
a291				endm 
# End of macro CWHEAD
a291			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a291			 
a291					if DEBUG_FORTH_WORDS_KEY 
a291						DMARK "AT." 
a291 f5				push af  
a292 3a a6 a2			ld a, (.dmark)  
a295 32 7a ee			ld (debug_mark),a  
a298 3a a7 a2			ld a, (.dmark+1)  
a29b 32 7b ee			ld (debug_mark+1),a  
a29e 3a a8 a2			ld a, (.dmark+2)  
a2a1 32 7c ee			ld (debug_mark+2),a  
a2a4 18 03			jr .pastdmark  
a2a6 ..			.dmark: db "AT."  
a2a9 f1			.pastdmark: pop af  
a2aa			endm  
# End of macro DMARK
a2aa						CALLMONITOR 
a2aa cd 03 93			call break_point_state  
a2ad				endm  
# End of macro CALLMONITOR
a2ad					endif 
a2ad			.getbyteat:	 
a2ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2ad cd 87 9a			call macro_dsp_valuehl 
a2b0				endm 
# End of macro FORTH_DSP_VALUEHL
a2b0					 
a2b0			;		push hl 
a2b0				 
a2b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2b0 cd 3f 9b			call macro_forth_dsp_pop 
a2b3				endm 
# End of macro FORTH_DSP_POP
a2b3			 
a2b3			;		pop hl 
a2b3			 
a2b3 7e					ld a, (hl) 
a2b4			 
a2b4 6f					ld l, a 
a2b5 26 00				ld h, 0 
a2b7 cd 90 98				call forth_push_numhl 
a2ba			 
a2ba					NEXTW 
a2ba c3 f9 9b			jp macro_next 
a2bd				endm 
# End of macro NEXTW
a2bd			.CAT: 
a2bd				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a2bd 20				db WORD_SYS_CORE+OPCODE_CAT             
a2be e6 a2			dw .BANG            
a2c0 03				db 2 + 1 
a2c1 .. 00			db "C@",0              
a2c4				endm 
# End of macro CWHEAD
a2c4			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a2c4					if DEBUG_FORTH_WORDS_KEY 
a2c4						DMARK "CAA" 
a2c4 f5				push af  
a2c5 3a d9 a2			ld a, (.dmark)  
a2c8 32 7a ee			ld (debug_mark),a  
a2cb 3a da a2			ld a, (.dmark+1)  
a2ce 32 7b ee			ld (debug_mark+1),a  
a2d1 3a db a2			ld a, (.dmark+2)  
a2d4 32 7c ee			ld (debug_mark+2),a  
a2d7 18 03			jr .pastdmark  
a2d9 ..			.dmark: db "CAA"  
a2dc f1			.pastdmark: pop af  
a2dd			endm  
# End of macro DMARK
a2dd						CALLMONITOR 
a2dd cd 03 93			call break_point_state  
a2e0				endm  
# End of macro CALLMONITOR
a2e0					endif 
a2e0 c3 ad a2				jp .getbyteat 
a2e3					NEXTW 
a2e3 c3 f9 9b			jp macro_next 
a2e6				endm 
# End of macro NEXTW
a2e6			.BANG: 
a2e6				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a2e6 21				db WORD_SYS_CORE+OPCODE_BANG             
a2e7 1c a3			dw .CBANG            
a2e9 02				db 1 + 1 
a2ea .. 00			db "!",0              
a2ec				endm 
# End of macro CWHEAD
a2ec			; | ! ( x w -- ) Store x at address w      | DONE 
a2ec					if DEBUG_FORTH_WORDS_KEY 
a2ec						DMARK "BNG" 
a2ec f5				push af  
a2ed 3a 01 a3			ld a, (.dmark)  
a2f0 32 7a ee			ld (debug_mark),a  
a2f3 3a 02 a3			ld a, (.dmark+1)  
a2f6 32 7b ee			ld (debug_mark+1),a  
a2f9 3a 03 a3			ld a, (.dmark+2)  
a2fc 32 7c ee			ld (debug_mark+2),a  
a2ff 18 03			jr .pastdmark  
a301 ..			.dmark: db "BNG"  
a304 f1			.pastdmark: pop af  
a305			endm  
# End of macro DMARK
a305						CALLMONITOR 
a305 cd 03 93			call break_point_state  
a308				endm  
# End of macro CALLMONITOR
a308					endif 
a308			 
a308			.storebyteat:		 
a308					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a308 cd 87 9a			call macro_dsp_valuehl 
a30b				endm 
# End of macro FORTH_DSP_VALUEHL
a30b					 
a30b e5					push hl 
a30c				 
a30c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a30c cd 3f 9b			call macro_forth_dsp_pop 
a30f				endm 
# End of macro FORTH_DSP_POP
a30f			 
a30f					; get byte to poke 
a30f			 
a30f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a30f cd 87 9a			call macro_dsp_valuehl 
a312				endm 
# End of macro FORTH_DSP_VALUEHL
a312 e5					push hl 
a313			 
a313			 
a313					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a313 cd 3f 9b			call macro_forth_dsp_pop 
a316				endm 
# End of macro FORTH_DSP_POP
a316			 
a316			 
a316 d1					pop de 
a317 e1					pop hl 
a318			 
a318 73					ld (hl),e 
a319			 
a319			 
a319					NEXTW 
a319 c3 f9 9b			jp macro_next 
a31c				endm 
# End of macro NEXTW
a31c			.CBANG: 
a31c				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a31c 22				db WORD_SYS_CORE+OPCODE_CBANG             
a31d 45 a3			dw .SCALL            
a31f 03				db 2 + 1 
a320 .. 00			db "C!",0              
a323				endm 
# End of macro CWHEAD
a323			; | C!  ( x w -- ) Store x at address w  | DONE 
a323					if DEBUG_FORTH_WORDS_KEY 
a323						DMARK "CBA" 
a323 f5				push af  
a324 3a 38 a3			ld a, (.dmark)  
a327 32 7a ee			ld (debug_mark),a  
a32a 3a 39 a3			ld a, (.dmark+1)  
a32d 32 7b ee			ld (debug_mark+1),a  
a330 3a 3a a3			ld a, (.dmark+2)  
a333 32 7c ee			ld (debug_mark+2),a  
a336 18 03			jr .pastdmark  
a338 ..			.dmark: db "CBA"  
a33b f1			.pastdmark: pop af  
a33c			endm  
# End of macro DMARK
a33c						CALLMONITOR 
a33c cd 03 93			call break_point_state  
a33f				endm  
# End of macro CALLMONITOR
a33f					endif 
a33f c3 08 a3				jp .storebyteat 
a342					NEXTW 
a342 c3 f9 9b			jp macro_next 
a345				endm 
# End of macro NEXTW
a345			.SCALL: 
a345				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a345 23				db WORD_SYS_CORE+OPCODE_SCALL             
a346 79 a3			dw .DEPTH            
a348 05				db 4 + 1 
a349 .. 00			db "CALL",0              
a34e				endm 
# End of macro CWHEAD
a34e			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a34e					if DEBUG_FORTH_WORDS_KEY 
a34e						DMARK "CLL" 
a34e f5				push af  
a34f 3a 63 a3			ld a, (.dmark)  
a352 32 7a ee			ld (debug_mark),a  
a355 3a 64 a3			ld a, (.dmark+1)  
a358 32 7b ee			ld (debug_mark+1),a  
a35b 3a 65 a3			ld a, (.dmark+2)  
a35e 32 7c ee			ld (debug_mark+2),a  
a361 18 03			jr .pastdmark  
a363 ..			.dmark: db "CLL"  
a366 f1			.pastdmark: pop af  
a367			endm  
# End of macro DMARK
a367						CALLMONITOR 
a367 cd 03 93			call break_point_state  
a36a				endm  
# End of macro CALLMONITOR
a36a					endif 
a36a			 
a36a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a36a cd 87 9a			call macro_dsp_valuehl 
a36d				endm 
# End of macro FORTH_DSP_VALUEHL
a36d			 
a36d			;		push hl 
a36d			 
a36d					; destroy value TOS 
a36d			 
a36d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a36d cd 3f 9b			call macro_forth_dsp_pop 
a370				endm 
# End of macro FORTH_DSP_POP
a370			 
a370						 
a370			;		pop hl 
a370			 
a370					; how to do a call with hl???? save SP? 
a370 cd a2 9b				call forth_call_hl 
a373			 
a373			 
a373					; TODO push value back onto stack for another op etc 
a373			 
a373 cd 90 98				call forth_push_numhl 
a376					NEXTW 
a376 c3 f9 9b			jp macro_next 
a379				endm 
# End of macro NEXTW
a379			.DEPTH: 
a379				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a379 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a37a b6 a3			dw .OVER            
a37c 06				db 5 + 1 
a37d .. 00			db "DEPTH",0              
a383				endm 
# End of macro CWHEAD
a383			; | DEPTH ( -- u ) Push count of stack | DONE 
a383					; take current TOS and remove from base value div by two to get count 
a383					if DEBUG_FORTH_WORDS_KEY 
a383						DMARK "DEP" 
a383 f5				push af  
a384 3a 98 a3			ld a, (.dmark)  
a387 32 7a ee			ld (debug_mark),a  
a38a 3a 99 a3			ld a, (.dmark+1)  
a38d 32 7b ee			ld (debug_mark+1),a  
a390 3a 9a a3			ld a, (.dmark+2)  
a393 32 7c ee			ld (debug_mark+2),a  
a396 18 03			jr .pastdmark  
a398 ..			.dmark: db "DEP"  
a39b f1			.pastdmark: pop af  
a39c			endm  
# End of macro DMARK
a39c						CALLMONITOR 
a39c cd 03 93			call break_point_state  
a39f				endm  
# End of macro CALLMONITOR
a39f					endif 
a39f			 
a39f			 
a39f 2a 0d eb			ld hl, (cli_data_sp) 
a3a2 11 c7 e8			ld de, cli_data_stack 
a3a5 ed 52			sbc hl,de 
a3a7				 
a3a7				; div by size of stack item 
a3a7			 
a3a7 5d				ld e,l 
a3a8 0e 03			ld c, 3 
a3aa cd 37 8a			call Div8 
a3ad			 
a3ad 6f				ld l,a 
a3ae 26 00			ld h,0 
a3b0			 
a3b0				;srl h 
a3b0				;rr l 
a3b0			 
a3b0 cd 90 98				call forth_push_numhl 
a3b3					NEXTW 
a3b3 c3 f9 9b			jp macro_next 
a3b6				endm 
# End of macro NEXTW
a3b6			.OVER: 
a3b6				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a3b6 42				db WORD_SYS_CORE+46             
a3b7 fd a3			dw .PAUSE            
a3b9 05				db 4 + 1 
a3ba .. 00			db "OVER",0              
a3bf				endm 
# End of macro CWHEAD
a3bf			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a3bf					if DEBUG_FORTH_WORDS_KEY 
a3bf						DMARK "OVR" 
a3bf f5				push af  
a3c0 3a d4 a3			ld a, (.dmark)  
a3c3 32 7a ee			ld (debug_mark),a  
a3c6 3a d5 a3			ld a, (.dmark+1)  
a3c9 32 7b ee			ld (debug_mark+1),a  
a3cc 3a d6 a3			ld a, (.dmark+2)  
a3cf 32 7c ee			ld (debug_mark+2),a  
a3d2 18 03			jr .pastdmark  
a3d4 ..			.dmark: db "OVR"  
a3d7 f1			.pastdmark: pop af  
a3d8			endm  
# End of macro DMARK
a3d8						CALLMONITOR 
a3d8 cd 03 93			call break_point_state  
a3db				endm  
# End of macro CALLMONITOR
a3db					endif 
a3db			 
a3db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3db cd 87 9a			call macro_dsp_valuehl 
a3de				endm 
# End of macro FORTH_DSP_VALUEHL
a3de e5					push hl    ; n2 
a3df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3df cd 3f 9b			call macro_forth_dsp_pop 
a3e2				endm 
# End of macro FORTH_DSP_POP
a3e2			 
a3e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3e2 cd 87 9a			call macro_dsp_valuehl 
a3e5				endm 
# End of macro FORTH_DSP_VALUEHL
a3e5 e5					push hl    ; n1 
a3e6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3e6 cd 3f 9b			call macro_forth_dsp_pop 
a3e9				endm 
# End of macro FORTH_DSP_POP
a3e9			 
a3e9 d1					pop de     ; n1 
a3ea e1					pop hl     ; n2 
a3eb			 
a3eb d5					push de 
a3ec e5					push hl 
a3ed d5					push de 
a3ee			 
a3ee					; push back  
a3ee			 
a3ee e1					pop hl 
a3ef cd 90 98				call forth_push_numhl 
a3f2 e1					pop hl 
a3f3 cd 90 98				call forth_push_numhl 
a3f6 e1					pop hl 
a3f7 cd 90 98				call forth_push_numhl 
a3fa					NEXTW 
a3fa c3 f9 9b			jp macro_next 
a3fd				endm 
# End of macro NEXTW
a3fd			 
a3fd			.PAUSE: 
a3fd				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a3fd 43				db WORD_SYS_CORE+47             
a3fe 32 a4			dw .PAUSES            
a400 08				db 7 + 1 
a401 .. 00			db "PAUSEMS",0              
a409				endm 
# End of macro CWHEAD
a409			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a409					if DEBUG_FORTH_WORDS_KEY 
a409						DMARK "PMS" 
a409 f5				push af  
a40a 3a 1e a4			ld a, (.dmark)  
a40d 32 7a ee			ld (debug_mark),a  
a410 3a 1f a4			ld a, (.dmark+1)  
a413 32 7b ee			ld (debug_mark+1),a  
a416 3a 20 a4			ld a, (.dmark+2)  
a419 32 7c ee			ld (debug_mark+2),a  
a41c 18 03			jr .pastdmark  
a41e ..			.dmark: db "PMS"  
a421 f1			.pastdmark: pop af  
a422			endm  
# End of macro DMARK
a422						CALLMONITOR 
a422 cd 03 93			call break_point_state  
a425				endm  
# End of macro CALLMONITOR
a425					endif 
a425					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a425 cd 87 9a			call macro_dsp_valuehl 
a428				endm 
# End of macro FORTH_DSP_VALUEHL
a428			;		push hl    ; n2 
a428					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a428 cd 3f 9b			call macro_forth_dsp_pop 
a42b				endm 
# End of macro FORTH_DSP_POP
a42b			;		pop hl 
a42b			 
a42b 7d					ld a, l 
a42c cd df 87				call aDelayInMS 
a42f				       NEXTW 
a42f c3 f9 9b			jp macro_next 
a432				endm 
# End of macro NEXTW
a432			.PAUSES:  
a432				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a432 44				db WORD_SYS_CORE+48             
a433 a1 a4			dw .ROT            
a435 06				db 5 + 1 
a436 .. 00			db "PAUSE",0              
a43c				endm 
# End of macro CWHEAD
a43c			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a43c					if DEBUG_FORTH_WORDS_KEY 
a43c						DMARK "PAU" 
a43c f5				push af  
a43d 3a 51 a4			ld a, (.dmark)  
a440 32 7a ee			ld (debug_mark),a  
a443 3a 52 a4			ld a, (.dmark+1)  
a446 32 7b ee			ld (debug_mark+1),a  
a449 3a 53 a4			ld a, (.dmark+2)  
a44c 32 7c ee			ld (debug_mark+2),a  
a44f 18 03			jr .pastdmark  
a451 ..			.dmark: db "PAU"  
a454 f1			.pastdmark: pop af  
a455			endm  
# End of macro DMARK
a455						CALLMONITOR 
a455 cd 03 93			call break_point_state  
a458				endm  
# End of macro CALLMONITOR
a458					endif 
a458					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a458 cd 87 9a			call macro_dsp_valuehl 
a45b				endm 
# End of macro FORTH_DSP_VALUEHL
a45b			;		push hl    ; n2 
a45b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a45b cd 3f 9b			call macro_forth_dsp_pop 
a45e				endm 
# End of macro FORTH_DSP_POP
a45e			;		pop hl 
a45e 45					ld b, l 
a45f					if DEBUG_FORTH_WORDS 
a45f						DMARK "PAU" 
a45f f5				push af  
a460 3a 74 a4			ld a, (.dmark)  
a463 32 7a ee			ld (debug_mark),a  
a466 3a 75 a4			ld a, (.dmark+1)  
a469 32 7b ee			ld (debug_mark+1),a  
a46c 3a 76 a4			ld a, (.dmark+2)  
a46f 32 7c ee			ld (debug_mark+2),a  
a472 18 03			jr .pastdmark  
a474 ..			.dmark: db "PAU"  
a477 f1			.pastdmark: pop af  
a478			endm  
# End of macro DMARK
a478						CALLMONITOR 
a478 cd 03 93			call break_point_state  
a47b				endm  
# End of macro CALLMONITOR
a47b					endif 
a47b c5			.pauses1:	push bc 
a47c cd fa 87				call delay1s 
a47f c1					pop bc 
a480					if DEBUG_FORTH_WORDS 
a480						DMARK "PA1" 
a480 f5				push af  
a481 3a 95 a4			ld a, (.dmark)  
a484 32 7a ee			ld (debug_mark),a  
a487 3a 96 a4			ld a, (.dmark+1)  
a48a 32 7b ee			ld (debug_mark+1),a  
a48d 3a 97 a4			ld a, (.dmark+2)  
a490 32 7c ee			ld (debug_mark+2),a  
a493 18 03			jr .pastdmark  
a495 ..			.dmark: db "PA1"  
a498 f1			.pastdmark: pop af  
a499			endm  
# End of macro DMARK
a499						CALLMONITOR 
a499 cd 03 93			call break_point_state  
a49c				endm  
# End of macro CALLMONITOR
a49c					endif 
a49c 10 dd				djnz .pauses1 
a49e			 
a49e				       NEXTW 
a49e c3 f9 9b			jp macro_next 
a4a1				endm 
# End of macro NEXTW
a4a1			.ROT: 
a4a1				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a4a1 45				db WORD_SYS_CORE+49             
a4a2 ef a4			dw .UWORDS            
a4a4 04				db 3 + 1 
a4a5 .. 00			db "ROT",0              
a4a9				endm 
# End of macro CWHEAD
a4a9			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a4a9					if DEBUG_FORTH_WORDS_KEY 
a4a9						DMARK "ROT" 
a4a9 f5				push af  
a4aa 3a be a4			ld a, (.dmark)  
a4ad 32 7a ee			ld (debug_mark),a  
a4b0 3a bf a4			ld a, (.dmark+1)  
a4b3 32 7b ee			ld (debug_mark+1),a  
a4b6 3a c0 a4			ld a, (.dmark+2)  
a4b9 32 7c ee			ld (debug_mark+2),a  
a4bc 18 03			jr .pastdmark  
a4be ..			.dmark: db "ROT"  
a4c1 f1			.pastdmark: pop af  
a4c2			endm  
# End of macro DMARK
a4c2						CALLMONITOR 
a4c2 cd 03 93			call break_point_state  
a4c5				endm  
# End of macro CALLMONITOR
a4c5					endif 
a4c5			 
a4c5					FORTH_DSP_VALUEHL 
a4c5 cd 87 9a			call macro_dsp_valuehl 
a4c8				endm 
# End of macro FORTH_DSP_VALUEHL
a4c8 e5					push hl    ; u3  
a4c9			 
a4c9					FORTH_DSP_POP 
a4c9 cd 3f 9b			call macro_forth_dsp_pop 
a4cc				endm 
# End of macro FORTH_DSP_POP
a4cc			   
a4cc					FORTH_DSP_VALUEHL 
a4cc cd 87 9a			call macro_dsp_valuehl 
a4cf				endm 
# End of macro FORTH_DSP_VALUEHL
a4cf e5					push hl     ; u2 
a4d0			 
a4d0					FORTH_DSP_POP 
a4d0 cd 3f 9b			call macro_forth_dsp_pop 
a4d3				endm 
# End of macro FORTH_DSP_POP
a4d3			 
a4d3					FORTH_DSP_VALUEHL 
a4d3 cd 87 9a			call macro_dsp_valuehl 
a4d6				endm 
# End of macro FORTH_DSP_VALUEHL
a4d6 e5					push hl     ; u1 
a4d7			 
a4d7					FORTH_DSP_POP 
a4d7 cd 3f 9b			call macro_forth_dsp_pop 
a4da				endm 
# End of macro FORTH_DSP_POP
a4da			 
a4da c1					pop bc      ; u1 
a4db e1					pop hl      ; u2 
a4dc d1					pop de      ; u3 
a4dd			 
a4dd			 
a4dd c5					push bc 
a4de d5					push de 
a4df e5					push hl 
a4e0			 
a4e0			 
a4e0 e1					pop hl 
a4e1 cd 90 98				call forth_push_numhl 
a4e4			 
a4e4 e1					pop hl 
a4e5 cd 90 98				call forth_push_numhl 
a4e8			 
a4e8 e1					pop hl 
a4e9 cd 90 98				call forth_push_numhl 
a4ec					 
a4ec			 
a4ec			 
a4ec			 
a4ec			 
a4ec			 
a4ec				       NEXTW 
a4ec c3 f9 9b			jp macro_next 
a4ef				endm 
# End of macro NEXTW
a4ef			 
a4ef			.UWORDS: 
a4ef				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a4ef 50				db WORD_SYS_CORE+60             
a4f0 b1 a5			dw .BP            
a4f2 07				db 6 + 1 
a4f3 .. 00			db "UWORDS",0              
a4fa				endm 
# End of macro CWHEAD
a4fa			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a4fa			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a4fa			; | | Following the count are the individual words. 
a4fa			; | | 
a4fa			; | | e.g. UWORDS 
a4fa			; | | BOX DIRLIST 2 
a4fa			; | |  
a4fa			; | | Can be used to save the words to storage via: 
a4fa			; | | UWORDS $01 DO $01 APPEND LOOP 
a4fa				if DEBUG_FORTH_WORDS_KEY 
a4fa					DMARK "UWR" 
a4fa f5				push af  
a4fb 3a 0f a5			ld a, (.dmark)  
a4fe 32 7a ee			ld (debug_mark),a  
a501 3a 10 a5			ld a, (.dmark+1)  
a504 32 7b ee			ld (debug_mark+1),a  
a507 3a 11 a5			ld a, (.dmark+2)  
a50a 32 7c ee			ld (debug_mark+2),a  
a50d 18 03			jr .pastdmark  
a50f ..			.dmark: db "UWR"  
a512 f1			.pastdmark: pop af  
a513			endm  
# End of macro DMARK
a513					CALLMONITOR 
a513 cd 03 93			call break_point_state  
a516				endm  
# End of macro CALLMONITOR
a516				endif 
a516 21 83 d8				ld hl, baseram 
a519					;ld hl, baseusermem 
a519 01 00 00				ld bc, 0    ; start a counter 
a51c			 
a51c				; skip dict stub 
a51c			 
a51c cd 4a 9d				call forth_tok_next 
a51f			 
a51f			 
a51f			; while we have words to look for 
a51f			 
a51f 7e			.douscan:	ld a, (hl)      
a520				if DEBUG_FORTH_WORDS 
a520					DMARK "UWs" 
a520 f5				push af  
a521 3a 35 a5			ld a, (.dmark)  
a524 32 7a ee			ld (debug_mark),a  
a527 3a 36 a5			ld a, (.dmark+1)  
a52a 32 7b ee			ld (debug_mark+1),a  
a52d 3a 37 a5			ld a, (.dmark+2)  
a530 32 7c ee			ld (debug_mark+2),a  
a533 18 03			jr .pastdmark  
a535 ..			.dmark: db "UWs"  
a538 f1			.pastdmark: pop af  
a539			endm  
# End of macro DMARK
a539					CALLMONITOR 
a539 cd 03 93			call break_point_state  
a53c				endm  
# End of macro CALLMONITOR
a53c				endif 
a53c fe 00				cp WORD_SYS_END 
a53e 28 4d				jr z, .udone 
a540 fe 01				cp WORD_SYS_UWORD 
a542 20 44				jr nz, .nuword 
a544			 
a544				if DEBUG_FORTH_WORDS 
a544					DMARK "UWu" 
a544 f5				push af  
a545 3a 59 a5			ld a, (.dmark)  
a548 32 7a ee			ld (debug_mark),a  
a54b 3a 5a a5			ld a, (.dmark+1)  
a54e 32 7b ee			ld (debug_mark+1),a  
a551 3a 5b a5			ld a, (.dmark+2)  
a554 32 7c ee			ld (debug_mark+2),a  
a557 18 03			jr .pastdmark  
a559 ..			.dmark: db "UWu"  
a55c f1			.pastdmark: pop af  
a55d			endm  
# End of macro DMARK
a55d					CALLMONITOR 
a55d cd 03 93			call break_point_state  
a560				endm  
# End of macro CALLMONITOR
a560				endif 
a560					; we have a uword so push its name to the stack 
a560			 
a560 e5				   	push hl  ; save so we can move to next dict block 
a561			 
a561					; skip opcode 
a561 23					inc hl  
a562					; skip next ptr 
a562 23					inc hl  
a563 23					inc hl 
a564					; skip len 
a564 23					inc hl 
a565				if DEBUG_FORTH_WORDS 
a565					DMARK "UWt" 
a565 f5				push af  
a566 3a 7a a5			ld a, (.dmark)  
a569 32 7a ee			ld (debug_mark),a  
a56c 3a 7b a5			ld a, (.dmark+1)  
a56f 32 7b ee			ld (debug_mark+1),a  
a572 3a 7c a5			ld a, (.dmark+2)  
a575 32 7c ee			ld (debug_mark+2),a  
a578 18 03			jr .pastdmark  
a57a ..			.dmark: db "UWt"  
a57d f1			.pastdmark: pop af  
a57e			endm  
# End of macro DMARK
a57e					CALLMONITOR 
a57e cd 03 93			call break_point_state  
a581				endm  
# End of macro CALLMONITOR
a581				endif 
a581 03					inc bc 
a582			 
a582 c5					push bc 
a583 cd fe 98				call forth_push_str 
a586 c1					pop bc 
a587			 
a587 e1					pop hl 	 
a588			 
a588 cd 4a 9d		.nuword:	call forth_tok_next 
a58b 18 92				jr .douscan  
a58d			 
a58d			.udone:		 ; push count of uwords found 
a58d c5					push bc 
a58e e1					pop hl 
a58f			 
a58f				if DEBUG_FORTH_WORDS 
a58f					DMARK "UWc" 
a58f f5				push af  
a590 3a a4 a5			ld a, (.dmark)  
a593 32 7a ee			ld (debug_mark),a  
a596 3a a5 a5			ld a, (.dmark+1)  
a599 32 7b ee			ld (debug_mark+1),a  
a59c 3a a6 a5			ld a, (.dmark+2)  
a59f 32 7c ee			ld (debug_mark+2),a  
a5a2 18 03			jr .pastdmark  
a5a4 ..			.dmark: db "UWc"  
a5a7 f1			.pastdmark: pop af  
a5a8			endm  
# End of macro DMARK
a5a8					CALLMONITOR 
a5a8 cd 03 93			call break_point_state  
a5ab				endm  
# End of macro CALLMONITOR
a5ab				endif 
a5ab cd 90 98				call forth_push_numhl 
a5ae			 
a5ae			 
a5ae				       NEXTW 
a5ae c3 f9 9b			jp macro_next 
a5b1				endm 
# End of macro NEXTW
a5b1			 
a5b1			.BP: 
a5b1				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a5b1 54				db WORD_SYS_CORE+64             
a5b2 e7 a5			dw .MONITOR            
a5b4 03				db 2 + 1 
a5b5 .. 00			db "BP",0              
a5b8				endm 
# End of macro CWHEAD
a5b8			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a5b8			; | | $00 Will enable the break points within specific code paths 
a5b8			; | | $01 Will disable break points 
a5b8			; | |  
a5b8			; | | By default break points are off. Either the above can be used to enable them 
a5b8			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a5b8			; | | and on release of the pressed key a message will be disaplayed to notify 
a5b8			; | | that break points are enabled. Pressing any key will then continue boot process. 
a5b8					; get byte count 
a5b8					if DEBUG_FORTH_WORDS_KEY 
a5b8						DMARK "BP." 
a5b8 f5				push af  
a5b9 3a cd a5			ld a, (.dmark)  
a5bc 32 7a ee			ld (debug_mark),a  
a5bf 3a ce a5			ld a, (.dmark+1)  
a5c2 32 7b ee			ld (debug_mark+1),a  
a5c5 3a cf a5			ld a, (.dmark+2)  
a5c8 32 7c ee			ld (debug_mark+2),a  
a5cb 18 03			jr .pastdmark  
a5cd ..			.dmark: db "BP."  
a5d0 f1			.pastdmark: pop af  
a5d1			endm  
# End of macro DMARK
a5d1						CALLMONITOR 
a5d1 cd 03 93			call break_point_state  
a5d4				endm  
# End of macro CALLMONITOR
a5d4					endif 
a5d4			 
a5d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5d4 cd 87 9a			call macro_dsp_valuehl 
a5d7				endm 
# End of macro FORTH_DSP_VALUEHL
a5d7			 
a5d7			;		push hl 
a5d7			 
a5d7					; destroy value TOS 
a5d7			 
a5d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5d7 cd 3f 9b			call macro_forth_dsp_pop 
a5da				endm 
# End of macro FORTH_DSP_POP
a5da			 
a5da			;		pop hl 
a5da			 
a5da 3e 00				ld a,0 
a5dc bd					cp l 
a5dd 28 02				jr z, .bpset 
a5df 3e 2a				ld a, '*' 
a5e1			 
a5e1 32 51 e3		.bpset:		ld (os_view_disable), a 
a5e4			 
a5e4			 
a5e4					NEXTW 
a5e4 c3 f9 9b			jp macro_next 
a5e7				endm 
# End of macro NEXTW
a5e7			 
a5e7			 
a5e7			.MONITOR: 
a5e7				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a5e7 55				db WORD_SYS_CORE+65             
a5e8 1a a6			dw .MALLOC            
a5ea 08				db 7 + 1 
a5eb .. 00			db "MONITOR",0              
a5f3				endm 
# End of macro CWHEAD
a5f3			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a5f3			; | | At start the current various registers will be displayed with contents. 
a5f3			; | | Top right corner will show the most recent debug marker seen. 
a5f3			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a5f3			; | | and the return stack pointer (RSP). 
a5f3			; | | Pressing: 
a5f3			; | |    1 - Initial screen 
a5f3			; | |    2 - Display a data dump of HL 
a5f3			; | |    3 - Display a data dump of DE 
a5f3			; | |    4 - Display a data dump of BC 
a5f3			; | |    5 - Display a data dump of HL 
a5f3			; | |    6 - Display a data dump of DSP 
a5f3			; | |    7 - Display a data dump of RSP 
a5f3			; | |    8 - Display a data dump of what is at DSP 
a5f3			; | |    9 - Display a data dump of what is at RSP 
a5f3			; | |    0 - Exit monitor and continue running. This will also enable break points 
a5f3			; | |    * - Disable break points 
a5f3			; | |    # - Enter traditional monitor mode 
a5f3			; | | 
a5f3			; | | Monitor Mode 
a5f3			; | | ------------ 
a5f3			; | | A prompt of '>' will be shown for various commands: 
a5f3			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a5f3			; | |    C - Continue display a data dump from the last set address 
a5f3			; | |    M xxxx - Set start of memory edit at address xx 
a5f3			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a5f3			; | |    Q - Return to previous 
a5f3					if DEBUG_FORTH_WORDS_KEY 
a5f3						DMARK "MON" 
a5f3 f5				push af  
a5f4 3a 08 a6			ld a, (.dmark)  
a5f7 32 7a ee			ld (debug_mark),a  
a5fa 3a 09 a6			ld a, (.dmark+1)  
a5fd 32 7b ee			ld (debug_mark+1),a  
a600 3a 0a a6			ld a, (.dmark+2)  
a603 32 7c ee			ld (debug_mark+2),a  
a606 18 03			jr .pastdmark  
a608 ..			.dmark: db "MON"  
a60b f1			.pastdmark: pop af  
a60c			endm  
# End of macro DMARK
a60c						CALLMONITOR 
a60c cd 03 93			call break_point_state  
a60f				endm  
# End of macro CALLMONITOR
a60f					endif 
a60f 3e 00				ld a, 0 
a611 32 51 e3				ld (os_view_disable), a 
a614			 
a614					CALLMONITOR 
a614 cd 03 93			call break_point_state  
a617				endm  
# End of macro CALLMONITOR
a617			 
a617			;	call monitor 
a617			 
a617					NEXTW 
a617 c3 f9 9b			jp macro_next 
a61a				endm 
# End of macro NEXTW
a61a			 
a61a			 
a61a			.MALLOC: 
a61a				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a61a 56				db WORD_SYS_CORE+66             
a61b 43 a6			dw .MALLOC2            
a61d 06				db 5 + 1 
a61e .. 00			db "ALLOT",0              
a624				endm 
# End of macro CWHEAD
a624			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a624					if DEBUG_FORTH_WORDS_KEY 
a624						DMARK "ALL" 
a624 f5				push af  
a625 3a 39 a6			ld a, (.dmark)  
a628 32 7a ee			ld (debug_mark),a  
a62b 3a 3a a6			ld a, (.dmark+1)  
a62e 32 7b ee			ld (debug_mark+1),a  
a631 3a 3b a6			ld a, (.dmark+2)  
a634 32 7c ee			ld (debug_mark+2),a  
a637 18 03			jr .pastdmark  
a639 ..			.dmark: db "ALL"  
a63c f1			.pastdmark: pop af  
a63d			endm  
# End of macro DMARK
a63d						CALLMONITOR 
a63d cd 03 93			call break_point_state  
a640				endm  
# End of macro CALLMONITOR
a640					endif 
a640 c3 6a a6				jp .mallocc 
a643			.MALLOC2: 
a643				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a643 56				db WORD_SYS_CORE+66             
a644 81 a6			dw .FREE            
a646 07				db 6 + 1 
a647 .. 00			db "MALLOC",0              
a64e				endm 
# End of macro CWHEAD
a64e			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a64e					; get byte count 
a64e					if DEBUG_FORTH_WORDS_KEY 
a64e						DMARK "MAL" 
a64e f5				push af  
a64f 3a 63 a6			ld a, (.dmark)  
a652 32 7a ee			ld (debug_mark),a  
a655 3a 64 a6			ld a, (.dmark+1)  
a658 32 7b ee			ld (debug_mark+1),a  
a65b 3a 65 a6			ld a, (.dmark+2)  
a65e 32 7c ee			ld (debug_mark+2),a  
a661 18 03			jr .pastdmark  
a663 ..			.dmark: db "MAL"  
a666 f1			.pastdmark: pop af  
a667			endm  
# End of macro DMARK
a667						CALLMONITOR 
a667 cd 03 93			call break_point_state  
a66a				endm  
# End of macro CALLMONITOR
a66a					endif 
a66a			.mallocc: 
a66a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a66a cd 87 9a			call macro_dsp_valuehl 
a66d				endm 
# End of macro FORTH_DSP_VALUEHL
a66d			 
a66d			;		push hl 
a66d			 
a66d					; destroy value TOS 
a66d			 
a66d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a66d cd 3f 9b			call macro_forth_dsp_pop 
a670				endm 
# End of macro FORTH_DSP_POP
a670			 
a670			;		pop hl 
a670 cd 6e 8f				call malloc 
a673				if DEBUG_FORTH_MALLOC_GUARD 
a673 f5					push af 
a674 cd d0 8a				call ishlzero 
a677			;		ld a, l 
a677			;		add h 
a677			;		cp 0 
a677 f1					pop af 
a678					 
a678 cc 38 c5				call z,malloc_error 
a67b				endif 
a67b			 
a67b cd 90 98				call forth_push_numhl 
a67e					NEXTW 
a67e c3 f9 9b			jp macro_next 
a681				endm 
# End of macro NEXTW
a681			 
a681			.FREE: 
a681				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a681 57				db WORD_SYS_CORE+67             
a682 b2 a6			dw .LIST            
a684 05				db 4 + 1 
a685 .. 00			db "FREE",0              
a68a				endm 
# End of macro CWHEAD
a68a			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a68a					if DEBUG_FORTH_WORDS_KEY 
a68a						DMARK "FRE" 
a68a f5				push af  
a68b 3a 9f a6			ld a, (.dmark)  
a68e 32 7a ee			ld (debug_mark),a  
a691 3a a0 a6			ld a, (.dmark+1)  
a694 32 7b ee			ld (debug_mark+1),a  
a697 3a a1 a6			ld a, (.dmark+2)  
a69a 32 7c ee			ld (debug_mark+2),a  
a69d 18 03			jr .pastdmark  
a69f ..			.dmark: db "FRE"  
a6a2 f1			.pastdmark: pop af  
a6a3			endm  
# End of macro DMARK
a6a3						CALLMONITOR 
a6a3 cd 03 93			call break_point_state  
a6a6				endm  
# End of macro CALLMONITOR
a6a6					endif 
a6a6					; get address 
a6a6			 
a6a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a6a6 cd 87 9a			call macro_dsp_valuehl 
a6a9				endm 
# End of macro FORTH_DSP_VALUEHL
a6a9			 
a6a9			;		push hl 
a6a9			 
a6a9					; destroy value TOS 
a6a9			 
a6a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a6a9 cd 3f 9b			call macro_forth_dsp_pop 
a6ac				endm 
# End of macro FORTH_DSP_POP
a6ac			 
a6ac			;		pop hl 
a6ac			if FORTH_ENABLE_MALLOCFREE 
a6ac cd 38 90				call free 
a6af			endif 
a6af					NEXTW 
a6af c3 f9 9b			jp macro_next 
a6b2				endm 
# End of macro NEXTW
a6b2			.LIST: 
a6b2				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a6b2 5c				db WORD_SYS_CORE+72             
a6b3 75 a8			dw .FORGET            
a6b5 05				db 4 + 1 
a6b6 .. 00			db "LIST",0              
a6bb				endm 
# End of macro CWHEAD
a6bb			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a6bb			; | | The quoted word must be in upper case. 
a6bb				if DEBUG_FORTH_WORDS_KEY 
a6bb					DMARK "LST" 
a6bb f5				push af  
a6bc 3a d0 a6			ld a, (.dmark)  
a6bf 32 7a ee			ld (debug_mark),a  
a6c2 3a d1 a6			ld a, (.dmark+1)  
a6c5 32 7b ee			ld (debug_mark+1),a  
a6c8 3a d2 a6			ld a, (.dmark+2)  
a6cb 32 7c ee			ld (debug_mark+2),a  
a6ce 18 03			jr .pastdmark  
a6d0 ..			.dmark: db "LST"  
a6d3 f1			.pastdmark: pop af  
a6d4			endm  
# End of macro DMARK
a6d4					CALLMONITOR 
a6d4 cd 03 93			call break_point_state  
a6d7				endm  
# End of macro CALLMONITOR
a6d7				endif 
a6d7			 
a6d7					FORTH_DSP_VALUEHL 
a6d7 cd 87 9a			call macro_dsp_valuehl 
a6da				endm 
# End of macro FORTH_DSP_VALUEHL
a6da			 
a6da e5					push hl 
a6db c1					pop bc 
a6dc			 
a6dc			; Start format of scratch string 
a6dc			 
a6dc 21 60 e3				ld hl, scratch 
a6df			 
a6df 3e 3a				ld a, ':' 
a6e1 77					ld (hl),a 
a6e2 23					inc hl 
a6e3 3e 20				ld a, ' ' 
a6e5 77					ld (hl), a 
a6e6			 
a6e6					; Get ptr to the word we need to look up 
a6e6			 
a6e6			;		FORTH_DSP_VALUEHL 
a6e6					;v5 FORTH_DSP_VALUE 
a6e6				; TODO type check 
a6e6			;		inc hl    ; Skip type check  
a6e6			;		push hl 
a6e6			;		ex de, hl    ; put into DE 
a6e6			 
a6e6			 
a6e6 21 83 d8				ld hl, baseram 
a6e9					;ld hl, baseusermem 
a6e9			 
a6e9 e5			push hl   ; sacreifical push 
a6ea			 
a6ea			.ldouscanm: 
a6ea e1				pop hl 
a6eb			.ldouscan: 
a6eb				if DEBUG_FORTH_WORDS 
a6eb					DMARK "LSs" 
a6eb f5				push af  
a6ec 3a 00 a7			ld a, (.dmark)  
a6ef 32 7a ee			ld (debug_mark),a  
a6f2 3a 01 a7			ld a, (.dmark+1)  
a6f5 32 7b ee			ld (debug_mark+1),a  
a6f8 3a 02 a7			ld a, (.dmark+2)  
a6fb 32 7c ee			ld (debug_mark+2),a  
a6fe 18 03			jr .pastdmark  
a700 ..			.dmark: db "LSs"  
a703 f1			.pastdmark: pop af  
a704			endm  
# End of macro DMARK
a704					CALLMONITOR 
a704 cd 03 93			call break_point_state  
a707				endm  
# End of macro CALLMONITOR
a707				endif 
a707				; skip dict stub 
a707 cd 4a 9d				call forth_tok_next 
a70a			 
a70a			 
a70a			; while we have words to look for 
a70a			 
a70a 7e				ld a, (hl)      
a70b				if DEBUG_FORTH_WORDS 
a70b					DMARK "LSk" 
a70b f5				push af  
a70c 3a 20 a7			ld a, (.dmark)  
a70f 32 7a ee			ld (debug_mark),a  
a712 3a 21 a7			ld a, (.dmark+1)  
a715 32 7b ee			ld (debug_mark+1),a  
a718 3a 22 a7			ld a, (.dmark+2)  
a71b 32 7c ee			ld (debug_mark+2),a  
a71e 18 03			jr .pastdmark  
a720 ..			.dmark: db "LSk"  
a723 f1			.pastdmark: pop af  
a724			endm  
# End of macro DMARK
a724					CALLMONITOR 
a724 cd 03 93			call break_point_state  
a727				endm  
# End of macro CALLMONITOR
a727				endif 
a727 fe 00				cp WORD_SYS_END 
a729 ca 5c a8				jp z, .lunotfound 
a72c fe 01				cp WORD_SYS_UWORD 
a72e c2 eb a6				jp nz, .ldouscan 
a731			 
a731				if DEBUG_FORTH_WORDS 
a731					DMARK "LSu" 
a731 f5				push af  
a732 3a 46 a7			ld a, (.dmark)  
a735 32 7a ee			ld (debug_mark),a  
a738 3a 47 a7			ld a, (.dmark+1)  
a73b 32 7b ee			ld (debug_mark+1),a  
a73e 3a 48 a7			ld a, (.dmark+2)  
a741 32 7c ee			ld (debug_mark+2),a  
a744 18 03			jr .pastdmark  
a746 ..			.dmark: db "LSu"  
a749 f1			.pastdmark: pop af  
a74a			endm  
# End of macro DMARK
a74a					CALLMONITOR 
a74a cd 03 93			call break_point_state  
a74d				endm  
# End of macro CALLMONITOR
a74d				endif 
a74d			 
a74d					; found a uword but is it the one we want... 
a74d			 
a74d c5					push bc     ; uword to find is on bc 
a74e d1					pop de 
a74f			 
a74f e5					push hl  ; to save the ptr 
a750			 
a750					; skip opcode 
a750 23					inc hl  
a751					; skip next ptr 
a751 23					inc hl  
a752 23					inc hl 
a753					; skip len 
a753 23					inc hl 
a754			 
a754				if DEBUG_FORTH_WORDS 
a754					DMARK "LSc" 
a754 f5				push af  
a755 3a 69 a7			ld a, (.dmark)  
a758 32 7a ee			ld (debug_mark),a  
a75b 3a 6a a7			ld a, (.dmark+1)  
a75e 32 7b ee			ld (debug_mark+1),a  
a761 3a 6b a7			ld a, (.dmark+2)  
a764 32 7c ee			ld (debug_mark+2),a  
a767 18 03			jr .pastdmark  
a769 ..			.dmark: db "LSc"  
a76c f1			.pastdmark: pop af  
a76d			endm  
# End of macro DMARK
a76d					CALLMONITOR 
a76d cd 03 93			call break_point_state  
a770				endm  
# End of macro CALLMONITOR
a770				endif 
a770 cd 3d 8f				call strcmp 
a773 c2 ea a6				jp nz, .ldouscanm 
a776				 
a776			 
a776			 
a776					; we have a uword so push its name to the stack 
a776			 
a776			;	   	push hl  ; save so we can move to next dict block 
a776 e1			pop hl 
a777			 
a777				if DEBUG_FORTH_WORDS 
a777					DMARK "LSm" 
a777 f5				push af  
a778 3a 8c a7			ld a, (.dmark)  
a77b 32 7a ee			ld (debug_mark),a  
a77e 3a 8d a7			ld a, (.dmark+1)  
a781 32 7b ee			ld (debug_mark+1),a  
a784 3a 8e a7			ld a, (.dmark+2)  
a787 32 7c ee			ld (debug_mark+2),a  
a78a 18 03			jr .pastdmark  
a78c ..			.dmark: db "LSm"  
a78f f1			.pastdmark: pop af  
a790			endm  
# End of macro DMARK
a790					CALLMONITOR 
a790 cd 03 93			call break_point_state  
a793				endm  
# End of macro CALLMONITOR
a793				endif 
a793			 
a793					; skip opcode 
a793 23					inc hl  
a794					; skip next ptr 
a794 23					inc hl  
a795 23					inc hl 
a796					; skip len 
a796 7e					ld a, (hl)   ; save length to add 
a797				if DEBUG_FORTH_WORDS 
a797					DMARK "LS2" 
a797 f5				push af  
a798 3a ac a7			ld a, (.dmark)  
a79b 32 7a ee			ld (debug_mark),a  
a79e 3a ad a7			ld a, (.dmark+1)  
a7a1 32 7b ee			ld (debug_mark+1),a  
a7a4 3a ae a7			ld a, (.dmark+2)  
a7a7 32 7c ee			ld (debug_mark+2),a  
a7aa 18 03			jr .pastdmark  
a7ac ..			.dmark: db "LS2"  
a7af f1			.pastdmark: pop af  
a7b0			endm  
# End of macro DMARK
a7b0					CALLMONITOR 
a7b0 cd 03 93			call break_point_state  
a7b3				endm  
# End of macro CALLMONITOR
a7b3				endif 
a7b3			 
a7b3					; save this location 
a7b3				 
a7b3 e5					push hl 
a7b4			 
a7b4 23					inc hl 
a7b5 11 62 e3				ld de, scratch+2 
a7b8 4f					ld c, a 
a7b9 06 00				ld b, 0 
a7bb			 
a7bb				if DEBUG_FORTH_WORDS 
a7bb					DMARK "LSn" 
a7bb f5				push af  
a7bc 3a d0 a7			ld a, (.dmark)  
a7bf 32 7a ee			ld (debug_mark),a  
a7c2 3a d1 a7			ld a, (.dmark+1)  
a7c5 32 7b ee			ld (debug_mark+1),a  
a7c8 3a d2 a7			ld a, (.dmark+2)  
a7cb 32 7c ee			ld (debug_mark+2),a  
a7ce 18 03			jr .pastdmark  
a7d0 ..			.dmark: db "LSn"  
a7d3 f1			.pastdmark: pop af  
a7d4			endm  
# End of macro DMARK
a7d4					CALLMONITOR 
a7d4 cd 03 93			call break_point_state  
a7d7				endm  
# End of macro CALLMONITOR
a7d7				endif 
a7d7			 
a7d7					; copy uword name to scratch 
a7d7			 
a7d7 ed b0				ldir 
a7d9			 
a7d9 1b					dec de 
a7da 3e 20				ld a, ' '    ; change null to space 
a7dc 12					ld (de), a 
a7dd			 
a7dd 13					inc de 
a7de			 
a7de d5					push de 
a7df c1					pop bc     ; move scratch pointer to end of word name and save it 
a7e0			 
a7e0 e1					pop hl 
a7e1 7e					ld a, (hl) 
a7e2					;inc hl 
a7e2					; skip word string 
a7e2 cd a7 8a				call addatohl 
a7e5			 
a7e5 23					inc hl 
a7e6			 
a7e6				if DEBUG_FORTH_WORDS 
a7e6					DMARK "LS3" 
a7e6 f5				push af  
a7e7 3a fb a7			ld a, (.dmark)  
a7ea 32 7a ee			ld (debug_mark),a  
a7ed 3a fc a7			ld a, (.dmark+1)  
a7f0 32 7b ee			ld (debug_mark+1),a  
a7f3 3a fd a7			ld a, (.dmark+2)  
a7f6 32 7c ee			ld (debug_mark+2),a  
a7f9 18 03			jr .pastdmark  
a7fb ..			.dmark: db "LS3"  
a7fe f1			.pastdmark: pop af  
a7ff			endm  
# End of macro DMARK
a7ff					CALLMONITOR 
a7ff cd 03 93			call break_point_state  
a802				endm  
# End of macro CALLMONITOR
a802				endif 
a802					; should now be at the start of the machine code to setup the eval of the uword 
a802					; now locate the ptr to the string defintion 
a802			 
a802					; skip ld hl, 
a802					; then load the ptr 
a802			 
a802 23					inc hl 
a803 5e					ld e, (hl) 
a804 23					inc hl 
a805 56					ld d, (hl) 
a806 eb					ex de, hl 
a807			 
a807			 
a807				if DEBUG_FORTH_WORDS 
a807					DMARK "LSt" 
a807 f5				push af  
a808 3a 1c a8			ld a, (.dmark)  
a80b 32 7a ee			ld (debug_mark),a  
a80e 3a 1d a8			ld a, (.dmark+1)  
a811 32 7b ee			ld (debug_mark+1),a  
a814 3a 1e a8			ld a, (.dmark+2)  
a817 32 7c ee			ld (debug_mark+2),a  
a81a 18 03			jr .pastdmark  
a81c ..			.dmark: db "LSt"  
a81f f1			.pastdmark: pop af  
a820			endm  
# End of macro DMARK
a820					CALLMONITOR 
a820 cd 03 93			call break_point_state  
a823				endm  
# End of macro CALLMONITOR
a823				endif 
a823			 
a823			; cant push right now due to tokenised strings  
a823			 
a823			; get the destination of where to copy this definition to. 
a823			 
a823 c5					push bc 
a824 d1					pop de 
a825			 
a825 7e			.listl:         ld a,(hl) 
a826 fe 00				cp 0 
a828 28 09				jr z, .lreplsp     ; replace zero with space 
a82a fe 7f				cp FORTH_END_BUFFER 
a82c 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a82e				 
a82e					; just copy this char as is then 
a82e			 
a82e 12					ld (de), a 
a82f			 
a82f 23			.listnxt:	inc hl 
a830 13					inc de 
a831 18 f2				jr .listl 
a833			 
a833 3e 20		.lreplsp:	ld a,' ' 
a835 12					ld (de), a 
a836 18 f7				jr .listnxt 
a838			 
a838			; close up uword def 
a838			 
a838			.listdone: 
a838 3e 00				ld a, 0 
a83a 12					ld (de), a 
a83b			 
a83b			; now have def so clean up and push to stack 
a83b			 
a83b 21 60 e3				ld hl, scratch 
a83e				if DEBUG_FORTH_WORDS 
a83e					DMARK "Ltp" 
a83e f5				push af  
a83f 3a 53 a8			ld a, (.dmark)  
a842 32 7a ee			ld (debug_mark),a  
a845 3a 54 a8			ld a, (.dmark+1)  
a848 32 7b ee			ld (debug_mark+1),a  
a84b 3a 55 a8			ld a, (.dmark+2)  
a84e 32 7c ee			ld (debug_mark+2),a  
a851 18 03			jr .pastdmark  
a853 ..			.dmark: db "Ltp"  
a856 f1			.pastdmark: pop af  
a857			endm  
# End of macro DMARK
a857					CALLMONITOR 
a857 cd 03 93			call break_point_state  
a85a				endm  
# End of macro CALLMONITOR
a85a				endif 
a85a			 
a85a 18 06			jr .listpush 
a85c			 
a85c			;.lnuword:	pop hl 
a85c			;		call forth_tok_next 
a85c			;		jp .ldouscan  
a85c			 
a85c			.lunotfound:		  
a85c			 
a85c			 
a85c					 
a85c					FORTH_DSP_POP 
a85c cd 3f 9b			call macro_forth_dsp_pop 
a85f				endm 
# End of macro FORTH_DSP_POP
a85f 21 68 a8				ld hl, .luno 
a862						 
a862			 
a862			.listpush: 
a862 cd fe 98				call forth_push_str 
a865			 
a865			 
a865			 
a865					NEXTW 
a865 c3 f9 9b			jp macro_next 
a868				endm 
# End of macro NEXTW
a868			 
a868 .. 00		.luno:    db "Not found",0 
a872			 
a872			 
a872			 
a872			 
a872			 
a872			;		push hl   ; save pointer to start of uword def string 
a872			; 
a872			;; look for FORTH_EOL_LINE 
a872			;		ld a, FORTH_END_BUFFER 
a872			;		call strlent 
a872			; 
a872			;		inc hl		 ; space for coln def 
a872			;		inc hl 
a872			;		inc hl          ; space for terms 
a872			;		inc hl 
a872			; 
a872			;		ld a, 20   ; TODO get actual length 
a872			;		call addatohl    ; include a random amount of room for the uword name 
a872			; 
a872			;		 
a872			;	if DEBUG_FORTH_WORDS 
a872			;		DMARK "Lt1" 
a872			;		CALLMONITOR 
a872			;	endif 
a872			;		 
a872			; 
a872			;; malloc space for the string because we cant change it 
a872			; 
a872			;		call malloc 
a872			;	if DEBUG_FORTH_MALLOC_GUARD 
a872			;		push af 
a872			;		call ishlzero 
a872			;		pop af 
a872			;		 
a872			;		call z,malloc_error 
a872			;	endif 
a872			; 
a872			;	if DEBUG_FORTH_WORDS 
a872			;		DMARK "Lt2" 
a872			;		CALLMONITOR 
a872			;	endif 
a872			;		pop de 
a872			;		push hl    ; push the malloc to release later 
a872			;		push hl   ;  push back a copy for the later stack push 
a872			;		 
a872			;; copy the string swapping out the zero terms for spaces 
a872			; 
a872			;		; de has our source 
a872			;		; hl has our dest 
a872			; 
a872			;; add the coln def 
a872			; 
a872			;		ld a, ':' 
a872			;		ld (hl), a 
a872			;		inc hl 
a872			;		ld a, ' ' 
a872			;		ld (hl), a 
a872			;		inc hl 
a872			; 
a872			;; add the uname word 
a872			;		push de   ; save our string for now 
a872			;		ex de, hl 
a872			; 
a872			;		FORTH_DSP_VALUE 
a872			;		;v5 FORTH_DSP_VALUE 
a872			; 
a872			;		inc hl   ; skip type but we know by now this is OK 
a872			; 
a872			;.luword:	ld a,(hl) 
a872			;		cp 0 
a872			;		jr z, .luword2 
a872			;		ld (de), a 
a872			;		inc de 
a872			;		inc hl 
a872			;		jr .luword 
a872			; 
a872			;.luword2:	ld a, ' ' 
a872			;		ld (de), a 
a872			;;		inc hl 
a872			;;		inc de 
a872			;;		ld (de), a 
a872			;;		inc hl 
a872			;		inc de 
a872			; 
a872			;		ex de, hl 
a872			;		pop de 
a872			;		 
a872			;		 
a872			; 
a872			;; detoken that string and copy it 
a872			; 
a872			;	if DEBUG_FORTH_WORDS 
a872			;		DMARK "Lt2" 
a872			;		CALLMONITOR 
a872			;	endif 
a872			;.ldetok:	ld a, (de) 
a872			;		cp FORTH_END_BUFFER 
a872			;		jr z, .ldetokend 
a872			;		; swap out any zero term for space 
a872			;		cp 0 
a872			;		jr nz, .ldetoknext 
a872			;		ld a, ' ' 
a872			; 
a872			;	if DEBUG_FORTH_WORDS 
a872			;		DMARK "LtS" 
a872			;		CALLMONITOR 
a872			;	endif 
a872			;.ldetoknext:	ld (hl), a 
a872			;		inc de 
a872			;		inc hl 
a872			;		jr .ldetok 
a872			; 
a872			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a872			;		ld (hl), a  
a872			; 
a872			;; free that temp malloc 
a872			; 
a872			;		pop hl    
a872			; 
a872			;	if DEBUG_FORTH_WORDS 
a872			;		DMARK "Lt4" 
a872			;		CALLMONITOR 
a872			;	endif 
a872			;		call forth_apushstrhl 
a872			; 
a872			;		; get rid of temp malloc area 
a872			; 
a872			;		pop hl 
a872			;		call free 
a872			; 
a872			;		jr .ludone 
a872			; 
a872			;.lnuword:	pop hl 
a872			;		call forth_tok_next 
a872			;		jp .ldouscan  
a872			; 
a872			;.ludone:		 pop hl 
a872			; 
a872					NEXTW 
a872 c3 f9 9b			jp macro_next 
a875				endm 
# End of macro NEXTW
a875			 
a875			.FORGET: 
a875				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a875 5d				db WORD_SYS_CORE+73             
a876 ee a8			dw .NOP            
a878 07				db 6 + 1 
a879 .. 00			db "FORGET",0              
a880				endm 
# End of macro CWHEAD
a880			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a880			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a880			; | |  
a880			; | | e.g. "MORE" forget 
a880					if DEBUG_FORTH_WORDS_KEY 
a880						DMARK "FRG" 
a880 f5				push af  
a881 3a 95 a8			ld a, (.dmark)  
a884 32 7a ee			ld (debug_mark),a  
a887 3a 96 a8			ld a, (.dmark+1)  
a88a 32 7b ee			ld (debug_mark+1),a  
a88d 3a 97 a8			ld a, (.dmark+2)  
a890 32 7c ee			ld (debug_mark+2),a  
a893 18 03			jr .pastdmark  
a895 ..			.dmark: db "FRG"  
a898 f1			.pastdmark: pop af  
a899			endm  
# End of macro DMARK
a899						CALLMONITOR 
a899 cd 03 93			call break_point_state  
a89c				endm  
# End of macro CALLMONITOR
a89c					endif 
a89c			 
a89c				; find uword 
a89c			        ; update start of word with "_" 
a89c				; replace uword with deleted flag 
a89c			 
a89c			 
a89c			;	if DEBUG_FORTH_WORDS 
a89c			;		DMARK "FOG" 
a89c			;		CALLMONITOR 
a89c			;	endif 
a89c			 
a89c			 
a89c					; Get ptr to the word we need to look up 
a89c			 
a89c					FORTH_DSP_VALUEHL 
a89c cd 87 9a			call macro_dsp_valuehl 
a89f				endm 
# End of macro FORTH_DSP_VALUEHL
a89f					;v5 FORTH_DSP_VALUE 
a89f				; TODO type check 
a89f			;		inc hl    ; Skip type check  
a89f e5					push hl 
a8a0 c1					pop bc 
a8a1			;		ex de, hl    ; put into DE 
a8a1			 
a8a1			 
a8a1 21 83 d8				ld hl, baseram 
a8a4					;ld hl, baseusermem 
a8a4			 
a8a4				; skip dict stub 
a8a4			;	call forth_tok_next 
a8a4 e5			push hl   ; sacreifical push 
a8a5			 
a8a5			.fldouscanm: 
a8a5 e1				pop hl 
a8a6			.fldouscan: 
a8a6			;	if DEBUG_FORTH_WORDS 
a8a6			;		DMARK "LSs" 
a8a6			;		CALLMONITOR 
a8a6			;	endif 
a8a6				; skip dict stub 
a8a6 cd 4a 9d				call forth_tok_next 
a8a9			 
a8a9			 
a8a9			; while we have words to look for 
a8a9			 
a8a9 7e				ld a, (hl)      
a8aa			;	if DEBUG_FORTH_WORDS 
a8aa			;		DMARK "LSk" 
a8aa			;		CALLMONITOR 
a8aa			;	endif 
a8aa fe 00				cp WORD_SYS_END 
a8ac ca e8 a8				jp z, .flunotfound 
a8af fe 01				cp WORD_SYS_UWORD 
a8b1 c2 a6 a8				jp nz, .fldouscan 
a8b4			 
a8b4			;	if DEBUG_FORTH_WORDS 
a8b4			;		DMARK "LSu" 
a8b4			;		CALLMONITOR 
a8b4			;	endif 
a8b4			 
a8b4					; found a uword but is it the one we want... 
a8b4			 
a8b4 c5					push bc     ; uword to find is on bc 
a8b5 d1					pop de 
a8b6			 
a8b6 e5					push hl  ; to save the ptr 
a8b7			 
a8b7					; skip opcode 
a8b7 23					inc hl  
a8b8					; skip next ptr 
a8b8 23					inc hl  
a8b9 23					inc hl 
a8ba					; skip len 
a8ba 23					inc hl 
a8bb			 
a8bb			;	if DEBUG_FORTH_WORDS 
a8bb			;		DMARK "LSc" 
a8bb			;		CALLMONITOR 
a8bb			;	endif 
a8bb cd 3d 8f				call strcmp 
a8be c2 a5 a8				jp nz, .fldouscanm 
a8c1			; 
a8c1			; 
a8c1			;; while we have words to look for 
a8c1			; 
a8c1			;.fdouscan:	ld a, (hl)      
a8c1			;	if DEBUG_FORTH_WORDS 
a8c1			;		DMARK "LSs" 
a8c1			;		CALLMONITOR 
a8c1			;	endif 
a8c1			;		cp WORD_SYS_END 
a8c1			;		jp z, .fudone 
a8c1			;		cp WORD_SYS_UWORD 
a8c1			;		jp nz, .fnuword 
a8c1			; 
a8c1			;	if DEBUG_FORTH_WORDS 
a8c1			;		DMARK "FGu" 
a8c1			;		CALLMONITOR 
a8c1			;	endif 
a8c1			; 
a8c1			;		; found a uword but is it the one we want... 
a8c1			; 
a8c1			; 
a8c1			;	        pop de   ; get back the dsp name 
a8c1			;		push de 
a8c1			; 
a8c1			;		push hl  ; to save the ptr 
a8c1			; 
a8c1			;		; skip opcode 
a8c1			;		inc hl  
a8c1			;		; skip next ptr 
a8c1			;		inc hl  
a8c1			;		inc hl 
a8c1			;		; skip len 
a8c1			;		inc hl 
a8c1			; 
a8c1			;	if DEBUG_FORTH_WORDS 
a8c1			;		DMARK "FGc" 
a8c1			;		CALLMONITOR 
a8c1			;	endif 
a8c1			;		call strcmp 
a8c1			;		jp nz, .fnuword 
a8c1			 
a8c1			 
a8c1 e1			pop hl 
a8c2			 
a8c2				 
a8c2				if DEBUG_FORTH_WORDS 
a8c2					DMARK "FGm" 
a8c2 f5				push af  
a8c3 3a d7 a8			ld a, (.dmark)  
a8c6 32 7a ee			ld (debug_mark),a  
a8c9 3a d8 a8			ld a, (.dmark+1)  
a8cc 32 7b ee			ld (debug_mark+1),a  
a8cf 3a d9 a8			ld a, (.dmark+2)  
a8d2 32 7c ee			ld (debug_mark+2),a  
a8d5 18 03			jr .pastdmark  
a8d7 ..			.dmark: db "FGm"  
a8da f1			.pastdmark: pop af  
a8db			endm  
# End of macro DMARK
a8db					CALLMONITOR 
a8db cd 03 93			call break_point_state  
a8de				endm  
# End of macro CALLMONITOR
a8de				endif 
a8de			 
a8de			 
a8de			 
a8de					; we have a uword so push its name to the stack 
a8de			 
a8de			;	   	push hl  ; save so we can move to next dict block 
a8de			;pop hl 
a8de			 
a8de					; update opcode to deleted 
a8de 3e 03				ld a, WORD_SYS_DELETED 
a8e0 77					ld (hl), a 
a8e1			 
a8e1 23					inc hl  
a8e2					; skip next ptr 
a8e2 23					inc hl  
a8e3 23					inc hl 
a8e4					; skip len 
a8e4 23					inc hl 
a8e5			 
a8e5					; TODO change parser to skip deleted words but for now mark it out 
a8e5 3e 5f				ld a, "_" 
a8e7 77					ld  (hl),a 
a8e8			 
a8e8			;		jr .fudone 
a8e8			; 
a8e8			;.fnuword:	pop hl 
a8e8			;		call forth_tok_next 
a8e8			;		jp .fdouscan  
a8e8			 
a8e8			.flunotfound:		  
a8e8			 
a8e8			 
a8e8					 
a8e8					FORTH_DSP_POP 
a8e8 cd 3f 9b			call macro_forth_dsp_pop 
a8eb				endm 
# End of macro FORTH_DSP_POP
a8eb			;		ld hl, .luno 
a8eb			;.fudone:		 pop hl 
a8eb					NEXTW 
a8eb c3 f9 9b			jp macro_next 
a8ee				endm 
# End of macro NEXTW
a8ee			.NOP: 
a8ee				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a8ee 61				db WORD_SYS_CORE+77             
a8ef 15 a9			dw .COMO            
a8f1 04				db 3 + 1 
a8f2 .. 00			db "NOP",0              
a8f6				endm 
# End of macro CWHEAD
a8f6			; | NOP (  --  ) Do nothing | DONE 
a8f6					if DEBUG_FORTH_WORDS_KEY 
a8f6						DMARK "NOP" 
a8f6 f5				push af  
a8f7 3a 0b a9			ld a, (.dmark)  
a8fa 32 7a ee			ld (debug_mark),a  
a8fd 3a 0c a9			ld a, (.dmark+1)  
a900 32 7b ee			ld (debug_mark+1),a  
a903 3a 0d a9			ld a, (.dmark+2)  
a906 32 7c ee			ld (debug_mark+2),a  
a909 18 03			jr .pastdmark  
a90b ..			.dmark: db "NOP"  
a90e f1			.pastdmark: pop af  
a90f			endm  
# End of macro DMARK
a90f						CALLMONITOR 
a90f cd 03 93			call break_point_state  
a912				endm  
# End of macro CALLMONITOR
a912					endif 
a912				       NEXTW 
a912 c3 f9 9b			jp macro_next 
a915				endm 
# End of macro NEXTW
a915			.COMO: 
a915				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
a915 6e				db WORD_SYS_CORE+90             
a916 67 a9			dw .COMC            
a918 02				db 1 + 1 
a919 .. 00			db "(",0              
a91b				endm 
# End of macro CWHEAD
a91b			; | ( ( -- )  Start of comment | DONE 
a91b			 
a91b			 
a91b 2a 61 e6				ld hl, ( os_tok_ptr) 
a91e 11 62 a9			ld de, .closepar 
a921					 
a921					if DEBUG_FORTH_WORDS 
a921						DMARK ").." 
a921 f5				push af  
a922 3a 36 a9			ld a, (.dmark)  
a925 32 7a ee			ld (debug_mark),a  
a928 3a 37 a9			ld a, (.dmark+1)  
a92b 32 7b ee			ld (debug_mark+1),a  
a92e 3a 38 a9			ld a, (.dmark+2)  
a931 32 7c ee			ld (debug_mark+2),a  
a934 18 03			jr .pastdmark  
a936 ..			.dmark: db ").."  
a939 f1			.pastdmark: pop af  
a93a			endm  
# End of macro DMARK
a93a						CALLMONITOR 
a93a cd 03 93			call break_point_state  
a93d				endm  
# End of macro CALLMONITOR
a93d					endif 
a93d cd 14 9d			call findnexttok  
a940			 
a940					if DEBUG_FORTH_WORDS 
a940						DMARK "IF5" 
a940 f5				push af  
a941 3a 55 a9			ld a, (.dmark)  
a944 32 7a ee			ld (debug_mark),a  
a947 3a 56 a9			ld a, (.dmark+1)  
a94a 32 7b ee			ld (debug_mark+1),a  
a94d 3a 57 a9			ld a, (.dmark+2)  
a950 32 7c ee			ld (debug_mark+2),a  
a953 18 03			jr .pastdmark  
a955 ..			.dmark: db "IF5"  
a958 f1			.pastdmark: pop af  
a959			endm  
# End of macro DMARK
a959						CALLMONITOR 
a959 cd 03 93			call break_point_state  
a95c				endm  
# End of macro CALLMONITOR
a95c					endif 
a95c				; replace below with ) exec using tok_ptr 
a95c 22 61 e6			ld (os_tok_ptr), hl 
a95f c3 8a 9c			jp exec1 
a962			 
a962 .. 00			.closepar:   db ")",0 
a964			 
a964				       NEXTW 
a964 c3 f9 9b			jp macro_next 
a967				endm 
# End of macro NEXTW
a967			.COMC: 
a967				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
a967 6f				db WORD_SYS_CORE+91             
a968 70 a9			dw .SCRATCH            
a96a 02				db 1 + 1 
a96b .. 00			db ")",0              
a96d				endm 
# End of macro CWHEAD
a96d			; | ) ( -- )  End of comment |  DONE  
a96d				       NEXTW 
a96d c3 f9 9b			jp macro_next 
a970				endm 
# End of macro NEXTW
a970			 
a970			.SCRATCH: 
a970				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
a970 6f				db WORD_SYS_CORE+91             
a971 ab a9			dw .INC            
a973 08				db 7 + 1 
a974 .. 00			db "SCRATCH",0              
a97c				endm 
# End of macro CWHEAD
a97c			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
a97c			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
a97c			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
a97c			; | |  
a97c			; | | e.g.    : score $00 scratch ; 
a97c			; | |  
a97c			; | | $00 score ! 
a97c			; | | $01 score +! 
a97c			; | |  
a97c			; | | e.g.   : varword $0a scratch ;  
a97c			; | | 
a97c			; | | $8000 varword ! 
a97c					if DEBUG_FORTH_WORDS_KEY 
a97c						DMARK "SCR" 
a97c f5				push af  
a97d 3a 91 a9			ld a, (.dmark)  
a980 32 7a ee			ld (debug_mark),a  
a983 3a 92 a9			ld a, (.dmark+1)  
a986 32 7b ee			ld (debug_mark+1),a  
a989 3a 93 a9			ld a, (.dmark+2)  
a98c 32 7c ee			ld (debug_mark+2),a  
a98f 18 03			jr .pastdmark  
a991 ..			.dmark: db "SCR"  
a994 f1			.pastdmark: pop af  
a995			endm  
# End of macro DMARK
a995						CALLMONITOR 
a995 cd 03 93			call break_point_state  
a998				endm  
# End of macro CALLMONITOR
a998					endif 
a998			 
a998					FORTH_DSP_VALUEHL 
a998 cd 87 9a			call macro_dsp_valuehl 
a99b				endm 
# End of macro FORTH_DSP_VALUEHL
a99b				 
a99b					FORTH_DSP_POP 
a99b cd 3f 9b			call macro_forth_dsp_pop 
a99e				endm 
# End of macro FORTH_DSP_POP
a99e			 
a99e 7d					ld a, l 
a99f 21 85 e8				ld hl, os_var_array 
a9a2 cd a7 8a				call addatohl 
a9a5			 
a9a5 cd 90 98				call forth_push_numhl 
a9a8			 
a9a8				       NEXTW 
a9a8 c3 f9 9b			jp macro_next 
a9ab				endm 
# End of macro NEXTW
a9ab			 
a9ab			.INC: 
a9ab				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
a9ab 6f				db WORD_SYS_CORE+91             
a9ac ff a9			dw .DEC            
a9ae 03				db 2 + 1 
a9af .. 00			db "+!",0              
a9b2				endm 
# End of macro CWHEAD
a9b2			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
a9b2					if DEBUG_FORTH_WORDS_KEY 
a9b2						DMARK "+s_" 
a9b2 f5				push af  
a9b3 3a c7 a9			ld a, (.dmark)  
a9b6 32 7a ee			ld (debug_mark),a  
a9b9 3a c8 a9			ld a, (.dmark+1)  
a9bc 32 7b ee			ld (debug_mark+1),a  
a9bf 3a c9 a9			ld a, (.dmark+2)  
a9c2 32 7c ee			ld (debug_mark+2),a  
a9c5 18 03			jr .pastdmark  
a9c7 ..			.dmark: db "+s_"  
a9ca f1			.pastdmark: pop af  
a9cb			endm  
# End of macro DMARK
a9cb						CALLMONITOR 
a9cb cd 03 93			call break_point_state  
a9ce				endm  
# End of macro CALLMONITOR
a9ce					endif 
a9ce			 
a9ce					FORTH_DSP_VALUEHL 
a9ce cd 87 9a			call macro_dsp_valuehl 
a9d1				endm 
# End of macro FORTH_DSP_VALUEHL
a9d1			 
a9d1 e5					push hl   ; save address 
a9d2			 
a9d2					FORTH_DSP_POP 
a9d2 cd 3f 9b			call macro_forth_dsp_pop 
a9d5				endm 
# End of macro FORTH_DSP_POP
a9d5			 
a9d5					FORTH_DSP_VALUEHL 
a9d5 cd 87 9a			call macro_dsp_valuehl 
a9d8				endm 
# End of macro FORTH_DSP_VALUEHL
a9d8			 
a9d8					FORTH_DSP_POP 
a9d8 cd 3f 9b			call macro_forth_dsp_pop 
a9db				endm 
# End of macro FORTH_DSP_POP
a9db			 
a9db					; hl contains value to add to byte at a 
a9db				 
a9db eb					ex de, hl 
a9dc			 
a9dc e1					pop hl 
a9dd			 
a9dd					if DEBUG_FORTH_WORDS 
a9dd						DMARK "INC" 
a9dd f5				push af  
a9de 3a f2 a9			ld a, (.dmark)  
a9e1 32 7a ee			ld (debug_mark),a  
a9e4 3a f3 a9			ld a, (.dmark+1)  
a9e7 32 7b ee			ld (debug_mark+1),a  
a9ea 3a f4 a9			ld a, (.dmark+2)  
a9ed 32 7c ee			ld (debug_mark+2),a  
a9f0 18 03			jr .pastdmark  
a9f2 ..			.dmark: db "INC"  
a9f5 f1			.pastdmark: pop af  
a9f6			endm  
# End of macro DMARK
a9f6						CALLMONITOR 
a9f6 cd 03 93			call break_point_state  
a9f9				endm  
# End of macro CALLMONITOR
a9f9					endif 
a9f9			 
a9f9 7e					ld a,(hl) 
a9fa 83					add e 
a9fb 77					ld (hl),a 
a9fc			 
a9fc			 
a9fc			 
a9fc				       NEXTW 
a9fc c3 f9 9b			jp macro_next 
a9ff				endm 
# End of macro NEXTW
a9ff			 
a9ff			.DEC: 
a9ff				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
a9ff 6f				db WORD_SYS_CORE+91             
aa00 50 aa			dw .INC2            
aa02 03				db 2 + 1 
aa03 .. 00			db "-!",0              
aa06				endm 
# End of macro CWHEAD
aa06			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
aa06					if DEBUG_FORTH_WORDS_KEY 
aa06						DMARK "-s_" 
aa06 f5				push af  
aa07 3a 1b aa			ld a, (.dmark)  
aa0a 32 7a ee			ld (debug_mark),a  
aa0d 3a 1c aa			ld a, (.dmark+1)  
aa10 32 7b ee			ld (debug_mark+1),a  
aa13 3a 1d aa			ld a, (.dmark+2)  
aa16 32 7c ee			ld (debug_mark+2),a  
aa19 18 03			jr .pastdmark  
aa1b ..			.dmark: db "-s_"  
aa1e f1			.pastdmark: pop af  
aa1f			endm  
# End of macro DMARK
aa1f						CALLMONITOR 
aa1f cd 03 93			call break_point_state  
aa22				endm  
# End of macro CALLMONITOR
aa22					endif 
aa22			 
aa22					FORTH_DSP_VALUEHL 
aa22 cd 87 9a			call macro_dsp_valuehl 
aa25				endm 
# End of macro FORTH_DSP_VALUEHL
aa25			 
aa25 e5					push hl   ; save address 
aa26			 
aa26					FORTH_DSP_POP 
aa26 cd 3f 9b			call macro_forth_dsp_pop 
aa29				endm 
# End of macro FORTH_DSP_POP
aa29			 
aa29					FORTH_DSP_VALUEHL 
aa29 cd 87 9a			call macro_dsp_valuehl 
aa2c				endm 
# End of macro FORTH_DSP_VALUEHL
aa2c			 
aa2c					; hl contains value to add to byte at a 
aa2c				 
aa2c eb					ex de, hl 
aa2d			 
aa2d e1					pop hl 
aa2e			 
aa2e					if DEBUG_FORTH_WORDS 
aa2e						DMARK "DEC" 
aa2e f5				push af  
aa2f 3a 43 aa			ld a, (.dmark)  
aa32 32 7a ee			ld (debug_mark),a  
aa35 3a 44 aa			ld a, (.dmark+1)  
aa38 32 7b ee			ld (debug_mark+1),a  
aa3b 3a 45 aa			ld a, (.dmark+2)  
aa3e 32 7c ee			ld (debug_mark+2),a  
aa41 18 03			jr .pastdmark  
aa43 ..			.dmark: db "DEC"  
aa46 f1			.pastdmark: pop af  
aa47			endm  
# End of macro DMARK
aa47						CALLMONITOR 
aa47 cd 03 93			call break_point_state  
aa4a				endm  
# End of macro CALLMONITOR
aa4a					endif 
aa4a			 
aa4a 7e					ld a,(hl) 
aa4b 93					sub e 
aa4c 77					ld (hl),a 
aa4d			 
aa4d			 
aa4d			 
aa4d				       NEXTW 
aa4d c3 f9 9b			jp macro_next 
aa50				endm 
# End of macro NEXTW
aa50			 
aa50			.INC2: 
aa50				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
aa50 6f				db WORD_SYS_CORE+91             
aa51 fa aa			dw .DEC2            
aa53 04				db 3 + 1 
aa54 .. 00			db "+2!",0              
aa58				endm 
# End of macro CWHEAD
aa58			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
aa58			 
aa58					if DEBUG_FORTH_WORDS_KEY 
aa58						DMARK "+2s" 
aa58 f5				push af  
aa59 3a 6d aa			ld a, (.dmark)  
aa5c 32 7a ee			ld (debug_mark),a  
aa5f 3a 6e aa			ld a, (.dmark+1)  
aa62 32 7b ee			ld (debug_mark+1),a  
aa65 3a 6f aa			ld a, (.dmark+2)  
aa68 32 7c ee			ld (debug_mark+2),a  
aa6b 18 03			jr .pastdmark  
aa6d ..			.dmark: db "+2s"  
aa70 f1			.pastdmark: pop af  
aa71			endm  
# End of macro DMARK
aa71						CALLMONITOR 
aa71 cd 03 93			call break_point_state  
aa74				endm  
# End of macro CALLMONITOR
aa74					endif 
aa74			 
aa74					; Address 
aa74			 
aa74					FORTH_DSP_VALUEHL 
aa74 cd 87 9a			call macro_dsp_valuehl 
aa77				endm 
# End of macro FORTH_DSP_VALUEHL
aa77			 
aa77 e5					push hl    ; save address 
aa78			 
aa78					; load content into de 
aa78			 
aa78 5e					ld e,(hl) 
aa79 23					inc hl 
aa7a 56					ld d, (hl) 
aa7b			 
aa7b					if DEBUG_FORTH_WORDS 
aa7b						DMARK "+2a" 
aa7b f5				push af  
aa7c 3a 90 aa			ld a, (.dmark)  
aa7f 32 7a ee			ld (debug_mark),a  
aa82 3a 91 aa			ld a, (.dmark+1)  
aa85 32 7b ee			ld (debug_mark+1),a  
aa88 3a 92 aa			ld a, (.dmark+2)  
aa8b 32 7c ee			ld (debug_mark+2),a  
aa8e 18 03			jr .pastdmark  
aa90 ..			.dmark: db "+2a"  
aa93 f1			.pastdmark: pop af  
aa94			endm  
# End of macro DMARK
aa94						CALLMONITOR 
aa94 cd 03 93			call break_point_state  
aa97				endm  
# End of macro CALLMONITOR
aa97					endif 
aa97			 
aa97					FORTH_DSP_POP 
aa97 cd 3f 9b			call macro_forth_dsp_pop 
aa9a				endm 
# End of macro FORTH_DSP_POP
aa9a			 
aa9a					; Get value to add 
aa9a			 
aa9a					FORTH_DSP_VALUE 
aa9a cd 70 9a			call macro_forth_dsp_value 
aa9d				endm 
# End of macro FORTH_DSP_VALUE
aa9d			 
aa9d					if DEBUG_FORTH_WORDS 
aa9d						DMARK "+2v" 
aa9d f5				push af  
aa9e 3a b2 aa			ld a, (.dmark)  
aaa1 32 7a ee			ld (debug_mark),a  
aaa4 3a b3 aa			ld a, (.dmark+1)  
aaa7 32 7b ee			ld (debug_mark+1),a  
aaaa 3a b4 aa			ld a, (.dmark+2)  
aaad 32 7c ee			ld (debug_mark+2),a  
aab0 18 03			jr .pastdmark  
aab2 ..			.dmark: db "+2v"  
aab5 f1			.pastdmark: pop af  
aab6			endm  
# End of macro DMARK
aab6						CALLMONITOR 
aab6 cd 03 93			call break_point_state  
aab9				endm  
# End of macro CALLMONITOR
aab9					endif 
aab9			 
aab9 19					add hl, de 
aaba			 
aaba					if DEBUG_FORTH_WORDS 
aaba						DMARK "+2+" 
aaba f5				push af  
aabb 3a cf aa			ld a, (.dmark)  
aabe 32 7a ee			ld (debug_mark),a  
aac1 3a d0 aa			ld a, (.dmark+1)  
aac4 32 7b ee			ld (debug_mark+1),a  
aac7 3a d1 aa			ld a, (.dmark+2)  
aaca 32 7c ee			ld (debug_mark+2),a  
aacd 18 03			jr .pastdmark  
aacf ..			.dmark: db "+2+"  
aad2 f1			.pastdmark: pop af  
aad3			endm  
# End of macro DMARK
aad3						CALLMONITOR 
aad3 cd 03 93			call break_point_state  
aad6				endm  
# End of macro CALLMONITOR
aad6					endif 
aad6			 
aad6					; move result to de 
aad6			 
aad6 eb					ex de, hl 
aad7			 
aad7					; Address 
aad7			 
aad7 e1					pop hl 
aad8			 
aad8					; save it back 
aad8			 
aad8 73					ld (hl), e 
aad9 23					inc hl 
aada 72					ld (hl), d 
aadb			 
aadb					if DEBUG_FORTH_WORDS 
aadb						DMARK "+2e" 
aadb f5				push af  
aadc 3a f0 aa			ld a, (.dmark)  
aadf 32 7a ee			ld (debug_mark),a  
aae2 3a f1 aa			ld a, (.dmark+1)  
aae5 32 7b ee			ld (debug_mark+1),a  
aae8 3a f2 aa			ld a, (.dmark+2)  
aaeb 32 7c ee			ld (debug_mark+2),a  
aaee 18 03			jr .pastdmark  
aaf0 ..			.dmark: db "+2e"  
aaf3 f1			.pastdmark: pop af  
aaf4			endm  
# End of macro DMARK
aaf4						CALLMONITOR 
aaf4 cd 03 93			call break_point_state  
aaf7				endm  
# End of macro CALLMONITOR
aaf7					endif 
aaf7			 
aaf7			 
aaf7			 
aaf7			 
aaf7			 
aaf7				       NEXTW 
aaf7 c3 f9 9b			jp macro_next 
aafa				endm 
# End of macro NEXTW
aafa			 
aafa			.DEC2: 
aafa				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
aafa 6f				db WORD_SYS_CORE+91             
aafb a6 ab			dw .GET2            
aafd 04				db 3 + 1 
aafe .. 00			db "-2!",0              
ab02				endm 
# End of macro CWHEAD
ab02			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
ab02			 
ab02			 
ab02					if DEBUG_FORTH_WORDS_KEY 
ab02						DMARK "-2s" 
ab02 f5				push af  
ab03 3a 17 ab			ld a, (.dmark)  
ab06 32 7a ee			ld (debug_mark),a  
ab09 3a 18 ab			ld a, (.dmark+1)  
ab0c 32 7b ee			ld (debug_mark+1),a  
ab0f 3a 19 ab			ld a, (.dmark+2)  
ab12 32 7c ee			ld (debug_mark+2),a  
ab15 18 03			jr .pastdmark  
ab17 ..			.dmark: db "-2s"  
ab1a f1			.pastdmark: pop af  
ab1b			endm  
# End of macro DMARK
ab1b						CALLMONITOR 
ab1b cd 03 93			call break_point_state  
ab1e				endm  
# End of macro CALLMONITOR
ab1e					endif 
ab1e			 
ab1e					; Address 
ab1e			 
ab1e					FORTH_DSP_VALUEHL 
ab1e cd 87 9a			call macro_dsp_valuehl 
ab21				endm 
# End of macro FORTH_DSP_VALUEHL
ab21			 
ab21 e5					push hl    ; save address 
ab22			 
ab22					; load content into de 
ab22			 
ab22 5e					ld e,(hl) 
ab23 23					inc hl 
ab24 56					ld d, (hl) 
ab25			 
ab25					if DEBUG_FORTH_WORDS 
ab25						DMARK "-2a" 
ab25 f5				push af  
ab26 3a 3a ab			ld a, (.dmark)  
ab29 32 7a ee			ld (debug_mark),a  
ab2c 3a 3b ab			ld a, (.dmark+1)  
ab2f 32 7b ee			ld (debug_mark+1),a  
ab32 3a 3c ab			ld a, (.dmark+2)  
ab35 32 7c ee			ld (debug_mark+2),a  
ab38 18 03			jr .pastdmark  
ab3a ..			.dmark: db "-2a"  
ab3d f1			.pastdmark: pop af  
ab3e			endm  
# End of macro DMARK
ab3e						CALLMONITOR 
ab3e cd 03 93			call break_point_state  
ab41				endm  
# End of macro CALLMONITOR
ab41					endif 
ab41			 
ab41					FORTH_DSP_POP 
ab41 cd 3f 9b			call macro_forth_dsp_pop 
ab44				endm 
# End of macro FORTH_DSP_POP
ab44			 
ab44					; Get value to remove 
ab44			 
ab44					FORTH_DSP_VALUE 
ab44 cd 70 9a			call macro_forth_dsp_value 
ab47				endm 
# End of macro FORTH_DSP_VALUE
ab47			 
ab47					if DEBUG_FORTH_WORDS 
ab47						DMARK "-2v" 
ab47 f5				push af  
ab48 3a 5c ab			ld a, (.dmark)  
ab4b 32 7a ee			ld (debug_mark),a  
ab4e 3a 5d ab			ld a, (.dmark+1)  
ab51 32 7b ee			ld (debug_mark+1),a  
ab54 3a 5e ab			ld a, (.dmark+2)  
ab57 32 7c ee			ld (debug_mark+2),a  
ab5a 18 03			jr .pastdmark  
ab5c ..			.dmark: db "-2v"  
ab5f f1			.pastdmark: pop af  
ab60			endm  
# End of macro DMARK
ab60						CALLMONITOR 
ab60 cd 03 93			call break_point_state  
ab63				endm  
# End of macro CALLMONITOR
ab63					endif 
ab63			 
ab63 eb					ex de, hl 
ab64 ed 52				sbc hl, de 
ab66			 
ab66					if DEBUG_FORTH_WORDS 
ab66						DMARK "-2d" 
ab66 f5				push af  
ab67 3a 7b ab			ld a, (.dmark)  
ab6a 32 7a ee			ld (debug_mark),a  
ab6d 3a 7c ab			ld a, (.dmark+1)  
ab70 32 7b ee			ld (debug_mark+1),a  
ab73 3a 7d ab			ld a, (.dmark+2)  
ab76 32 7c ee			ld (debug_mark+2),a  
ab79 18 03			jr .pastdmark  
ab7b ..			.dmark: db "-2d"  
ab7e f1			.pastdmark: pop af  
ab7f			endm  
# End of macro DMARK
ab7f						CALLMONITOR 
ab7f cd 03 93			call break_point_state  
ab82				endm  
# End of macro CALLMONITOR
ab82					endif 
ab82			 
ab82					; move result to de 
ab82			 
ab82 eb					ex de, hl 
ab83			 
ab83					; Address 
ab83			 
ab83 e1					pop hl 
ab84			 
ab84					; save it back 
ab84			 
ab84 73					ld (hl), e 
ab85 23					inc hl 
ab86 72					ld (hl), d 
ab87			 
ab87					if DEBUG_FORTH_WORDS 
ab87						DMARK "-2e" 
ab87 f5				push af  
ab88 3a 9c ab			ld a, (.dmark)  
ab8b 32 7a ee			ld (debug_mark),a  
ab8e 3a 9d ab			ld a, (.dmark+1)  
ab91 32 7b ee			ld (debug_mark+1),a  
ab94 3a 9e ab			ld a, (.dmark+2)  
ab97 32 7c ee			ld (debug_mark+2),a  
ab9a 18 03			jr .pastdmark  
ab9c ..			.dmark: db "-2e"  
ab9f f1			.pastdmark: pop af  
aba0			endm  
# End of macro DMARK
aba0						CALLMONITOR 
aba0 cd 03 93			call break_point_state  
aba3				endm  
# End of macro CALLMONITOR
aba3					endif 
aba3			 
aba3			 
aba3			 
aba3			 
aba3			 
aba3				       NEXTW 
aba3 c3 f9 9b			jp macro_next 
aba6				endm 
# End of macro NEXTW
aba6			.GET2: 
aba6				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
aba6 6f				db WORD_SYS_CORE+91             
aba7 d6 ab			dw .BANG2            
aba9 03				db 2 + 1 
abaa .. 00			db "2@",0              
abad				endm 
# End of macro CWHEAD
abad			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
abad					if DEBUG_FORTH_WORDS_KEY 
abad						DMARK "2A_" 
abad f5				push af  
abae 3a c2 ab			ld a, (.dmark)  
abb1 32 7a ee			ld (debug_mark),a  
abb4 3a c3 ab			ld a, (.dmark+1)  
abb7 32 7b ee			ld (debug_mark+1),a  
abba 3a c4 ab			ld a, (.dmark+2)  
abbd 32 7c ee			ld (debug_mark+2),a  
abc0 18 03			jr .pastdmark  
abc2 ..			.dmark: db "2A_"  
abc5 f1			.pastdmark: pop af  
abc6			endm  
# End of macro DMARK
abc6						CALLMONITOR 
abc6 cd 03 93			call break_point_state  
abc9				endm  
# End of macro CALLMONITOR
abc9					endif 
abc9			 
abc9					FORTH_DSP_VALUEHL 
abc9 cd 87 9a			call macro_dsp_valuehl 
abcc				endm 
# End of macro FORTH_DSP_VALUEHL
abcc			 
abcc 5e					ld e, (hl) 
abcd 23					inc hl 
abce 56					ld d, (hl) 
abcf			 
abcf eb					ex de, hl 
abd0			 
abd0 cd 90 98				call forth_push_numhl 
abd3			 
abd3				       NEXTW 
abd3 c3 f9 9b			jp macro_next 
abd6				endm 
# End of macro NEXTW
abd6			.BANG2: 
abd6				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
abd6 6f				db WORD_SYS_CORE+91             
abd7 0e ac			dw .CONFIG            
abd9 03				db 2 + 1 
abda .. 00			db "2!",0              
abdd				endm 
# End of macro CWHEAD
abdd			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
abdd					if DEBUG_FORTH_WORDS_KEY 
abdd						DMARK "2S_" 
abdd f5				push af  
abde 3a f2 ab			ld a, (.dmark)  
abe1 32 7a ee			ld (debug_mark),a  
abe4 3a f3 ab			ld a, (.dmark+1)  
abe7 32 7b ee			ld (debug_mark+1),a  
abea 3a f4 ab			ld a, (.dmark+2)  
abed 32 7c ee			ld (debug_mark+2),a  
abf0 18 03			jr .pastdmark  
abf2 ..			.dmark: db "2S_"  
abf5 f1			.pastdmark: pop af  
abf6			endm  
# End of macro DMARK
abf6						CALLMONITOR 
abf6 cd 03 93			call break_point_state  
abf9				endm  
# End of macro CALLMONITOR
abf9					endif 
abf9			 
abf9					FORTH_DSP_VALUEHL 
abf9 cd 87 9a			call macro_dsp_valuehl 
abfc				endm 
# End of macro FORTH_DSP_VALUEHL
abfc			 
abfc e5					push hl   ; save address 
abfd			 
abfd			 
abfd					FORTH_DSP_POP 
abfd cd 3f 9b			call macro_forth_dsp_pop 
ac00				endm 
# End of macro FORTH_DSP_POP
ac00			 
ac00					 
ac00					FORTH_DSP_VALUEHL 
ac00 cd 87 9a			call macro_dsp_valuehl 
ac03				endm 
# End of macro FORTH_DSP_VALUEHL
ac03			 
ac03					FORTH_DSP_POP 
ac03 cd 3f 9b			call macro_forth_dsp_pop 
ac06				endm 
# End of macro FORTH_DSP_POP
ac06			 
ac06 eb					ex de, hl    ; value now in de 
ac07			 
ac07 e1					pop hl 
ac08			 
ac08 73					ld (hl), e 
ac09			 
ac09 23					inc hl 
ac0a			 
ac0a 72					ld (hl), d 
ac0b			 
ac0b			 
ac0b				       NEXTW 
ac0b c3 f9 9b			jp macro_next 
ac0e				endm 
# End of macro NEXTW
ac0e			.CONFIG: 
ac0e				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
ac0e 6f				db WORD_SYS_CORE+91             
ac0f 1f ac			dw .ENDCORE            
ac11 07				db 6 + 1 
ac12 .. 00			db "CONFIG",0              
ac19				endm 
# End of macro CWHEAD
ac19			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
ac19			 
ac19 cd 07 91				call config 
ac1c					NEXTW 
ac1c c3 f9 9b			jp macro_next 
ac1f				endm 
# End of macro NEXTW
ac1f			.ENDCORE: 
ac1f			 
ac1f			; eof 
ac1f			 
ac1f			 
# End of file forth_words_core.asm
ac1f			include "forth_words_flow.asm" 
ac1f			 
ac1f			; | ## Program Flow Words 
ac1f			 
ac1f			.IF: 
ac1f				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ac1f 1e				db WORD_SYS_CORE+10             
ac20 14 ad			dw .THEN            
ac22 03				db 2 + 1 
ac23 .. 00			db "IF",0              
ac26				endm 
# End of macro CWHEAD
ac26			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ac26			; 
ac26					if DEBUG_FORTH_WORDS_KEY 
ac26						DMARK "IF." 
ac26 f5				push af  
ac27 3a 3b ac			ld a, (.dmark)  
ac2a 32 7a ee			ld (debug_mark),a  
ac2d 3a 3c ac			ld a, (.dmark+1)  
ac30 32 7b ee			ld (debug_mark+1),a  
ac33 3a 3d ac			ld a, (.dmark+2)  
ac36 32 7c ee			ld (debug_mark+2),a  
ac39 18 03			jr .pastdmark  
ac3b ..			.dmark: db "IF."  
ac3e f1			.pastdmark: pop af  
ac3f			endm  
# End of macro DMARK
ac3f						CALLMONITOR 
ac3f cd 03 93			call break_point_state  
ac42				endm  
# End of macro CALLMONITOR
ac42					endif 
ac42			; eval TOS 
ac42			 
ac42				FORTH_DSP_VALUEHL 
ac42 cd 87 9a			call macro_dsp_valuehl 
ac45				endm 
# End of macro FORTH_DSP_VALUEHL
ac45			 
ac45			;	push hl 
ac45				FORTH_DSP_POP 
ac45 cd 3f 9b			call macro_forth_dsp_pop 
ac48				endm 
# End of macro FORTH_DSP_POP
ac48			;	pop hl 
ac48			 
ac48					if DEBUG_FORTH_WORDS 
ac48						DMARK "IF1" 
ac48 f5				push af  
ac49 3a 5d ac			ld a, (.dmark)  
ac4c 32 7a ee			ld (debug_mark),a  
ac4f 3a 5e ac			ld a, (.dmark+1)  
ac52 32 7b ee			ld (debug_mark+1),a  
ac55 3a 5f ac			ld a, (.dmark+2)  
ac58 32 7c ee			ld (debug_mark+2),a  
ac5b 18 03			jr .pastdmark  
ac5d ..			.dmark: db "IF1"  
ac60 f1			.pastdmark: pop af  
ac61			endm  
# End of macro DMARK
ac61						CALLMONITOR 
ac61 cd 03 93			call break_point_state  
ac64				endm  
# End of macro CALLMONITOR
ac64					endif 
ac64 b7				or a        ; clear carry flag 
ac65 11 00 00			ld de, 0 
ac68 eb				ex de,hl 
ac69 ed 52			sbc hl, de 
ac6b c2 f5 ac			jp nz, .iftrue 
ac6e			 
ac6e					if DEBUG_FORTH_WORDS 
ac6e						DMARK "IF2" 
ac6e f5				push af  
ac6f 3a 83 ac			ld a, (.dmark)  
ac72 32 7a ee			ld (debug_mark),a  
ac75 3a 84 ac			ld a, (.dmark+1)  
ac78 32 7b ee			ld (debug_mark+1),a  
ac7b 3a 85 ac			ld a, (.dmark+2)  
ac7e 32 7c ee			ld (debug_mark+2),a  
ac81 18 03			jr .pastdmark  
ac83 ..			.dmark: db "IF2"  
ac86 f1			.pastdmark: pop af  
ac87			endm  
# End of macro DMARK
ac87						CALLMONITOR 
ac87 cd 03 93			call break_point_state  
ac8a				endm  
# End of macro CALLMONITOR
ac8a					endif 
ac8a			 
ac8a			; if not true then skip to THEN 
ac8a			 
ac8a				; TODO get tok_ptr 
ac8a				; TODO consume toks until we get to THEN 
ac8a			 
ac8a 2a 61 e6			ld hl, (os_tok_ptr) 
ac8d					if DEBUG_FORTH_WORDS 
ac8d						DMARK "IF3" 
ac8d f5				push af  
ac8e 3a a2 ac			ld a, (.dmark)  
ac91 32 7a ee			ld (debug_mark),a  
ac94 3a a3 ac			ld a, (.dmark+1)  
ac97 32 7b ee			ld (debug_mark+1),a  
ac9a 3a a4 ac			ld a, (.dmark+2)  
ac9d 32 7c ee			ld (debug_mark+2),a  
aca0 18 03			jr .pastdmark  
aca2 ..			.dmark: db "IF3"  
aca5 f1			.pastdmark: pop af  
aca6			endm  
# End of macro DMARK
aca6						CALLMONITOR 
aca6 cd 03 93			call break_point_state  
aca9				endm  
# End of macro CALLMONITOR
aca9						 
aca9					endif 
aca9 11 f0 ac			ld de, .ifthen 
acac					if DEBUG_FORTH_WORDS 
acac						DMARK "IF4" 
acac f5				push af  
acad 3a c1 ac			ld a, (.dmark)  
acb0 32 7a ee			ld (debug_mark),a  
acb3 3a c2 ac			ld a, (.dmark+1)  
acb6 32 7b ee			ld (debug_mark+1),a  
acb9 3a c3 ac			ld a, (.dmark+2)  
acbc 32 7c ee			ld (debug_mark+2),a  
acbf 18 03			jr .pastdmark  
acc1 ..			.dmark: db "IF4"  
acc4 f1			.pastdmark: pop af  
acc5			endm  
# End of macro DMARK
acc5						CALLMONITOR 
acc5 cd 03 93			call break_point_state  
acc8				endm  
# End of macro CALLMONITOR
acc8					endif 
acc8 cd 14 9d			call findnexttok  
accb			 
accb					if DEBUG_FORTH_WORDS 
accb						DMARK "IF5" 
accb f5				push af  
accc 3a e0 ac			ld a, (.dmark)  
accf 32 7a ee			ld (debug_mark),a  
acd2 3a e1 ac			ld a, (.dmark+1)  
acd5 32 7b ee			ld (debug_mark+1),a  
acd8 3a e2 ac			ld a, (.dmark+2)  
acdb 32 7c ee			ld (debug_mark+2),a  
acde 18 03			jr .pastdmark  
ace0 ..			.dmark: db "IF5"  
ace3 f1			.pastdmark: pop af  
ace4			endm  
# End of macro DMARK
ace4						CALLMONITOR 
ace4 cd 03 93			call break_point_state  
ace7				endm  
# End of macro CALLMONITOR
ace7					endif 
ace7				; TODO replace below with ; exec using tok_ptr 
ace7 22 61 e6			ld (os_tok_ptr), hl 
acea c3 8a 9c			jp exec1 
aced				NEXTW 
aced c3 f9 9b			jp macro_next 
acf0				endm 
# End of macro NEXTW
acf0			 
acf0 .. 00		.ifthen:  db "THEN",0 
acf5			 
acf5			.iftrue:		 
acf5				; Exec next words normally 
acf5			 
acf5				; if true then exec following IF as normal 
acf5					if DEBUG_FORTH_WORDS 
acf5						DMARK "IFT" 
acf5 f5				push af  
acf6 3a 0a ad			ld a, (.dmark)  
acf9 32 7a ee			ld (debug_mark),a  
acfc 3a 0b ad			ld a, (.dmark+1)  
acff 32 7b ee			ld (debug_mark+1),a  
ad02 3a 0c ad			ld a, (.dmark+2)  
ad05 32 7c ee			ld (debug_mark+2),a  
ad08 18 03			jr .pastdmark  
ad0a ..			.dmark: db "IFT"  
ad0d f1			.pastdmark: pop af  
ad0e			endm  
# End of macro DMARK
ad0e						CALLMONITOR 
ad0e cd 03 93			call break_point_state  
ad11				endm  
# End of macro CALLMONITOR
ad11					endif 
ad11			 
ad11					NEXTW 
ad11 c3 f9 9b			jp macro_next 
ad14				endm 
# End of macro NEXTW
ad14			.THEN: 
ad14				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
ad14 1f				db WORD_SYS_CORE+11             
ad15 3c ad			dw .ELSE            
ad17 05				db 4 + 1 
ad18 .. 00			db "THEN",0              
ad1d				endm 
# End of macro CWHEAD
ad1d			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
ad1d					if DEBUG_FORTH_WORDS_KEY 
ad1d						DMARK "THN" 
ad1d f5				push af  
ad1e 3a 32 ad			ld a, (.dmark)  
ad21 32 7a ee			ld (debug_mark),a  
ad24 3a 33 ad			ld a, (.dmark+1)  
ad27 32 7b ee			ld (debug_mark+1),a  
ad2a 3a 34 ad			ld a, (.dmark+2)  
ad2d 32 7c ee			ld (debug_mark+2),a  
ad30 18 03			jr .pastdmark  
ad32 ..			.dmark: db "THN"  
ad35 f1			.pastdmark: pop af  
ad36			endm  
# End of macro DMARK
ad36						CALLMONITOR 
ad36 cd 03 93			call break_point_state  
ad39				endm  
# End of macro CALLMONITOR
ad39					endif 
ad39					NEXTW 
ad39 c3 f9 9b			jp macro_next 
ad3c				endm 
# End of macro NEXTW
ad3c			.ELSE: 
ad3c				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
ad3c 20				db WORD_SYS_CORE+12             
ad3d 64 ad			dw .DO            
ad3f 03				db 2 + 1 
ad40 .. 00			db "ELSE",0              
ad45				endm 
# End of macro CWHEAD
ad45			; | ELSE ( -- ) Not supported - does nothing | TODO 
ad45			 
ad45					if DEBUG_FORTH_WORDS_KEY 
ad45						DMARK "ELS" 
ad45 f5				push af  
ad46 3a 5a ad			ld a, (.dmark)  
ad49 32 7a ee			ld (debug_mark),a  
ad4c 3a 5b ad			ld a, (.dmark+1)  
ad4f 32 7b ee			ld (debug_mark+1),a  
ad52 3a 5c ad			ld a, (.dmark+2)  
ad55 32 7c ee			ld (debug_mark+2),a  
ad58 18 03			jr .pastdmark  
ad5a ..			.dmark: db "ELS"  
ad5d f1			.pastdmark: pop af  
ad5e			endm  
# End of macro DMARK
ad5e						CALLMONITOR 
ad5e cd 03 93			call break_point_state  
ad61				endm  
# End of macro CALLMONITOR
ad61					endif 
ad61			 
ad61			 
ad61					NEXTW 
ad61 c3 f9 9b			jp macro_next 
ad64				endm 
# End of macro NEXTW
ad64			.DO: 
ad64				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
ad64 21				db WORD_SYS_CORE+13             
ad65 8b ae			dw .LOOP            
ad67 03				db 2 + 1 
ad68 .. 00			db "DO",0              
ad6b				endm 
# End of macro CWHEAD
ad6b			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
ad6b			 
ad6b					if DEBUG_FORTH_WORDS_KEY 
ad6b						DMARK "DO." 
ad6b f5				push af  
ad6c 3a 80 ad			ld a, (.dmark)  
ad6f 32 7a ee			ld (debug_mark),a  
ad72 3a 81 ad			ld a, (.dmark+1)  
ad75 32 7b ee			ld (debug_mark+1),a  
ad78 3a 82 ad			ld a, (.dmark+2)  
ad7b 32 7c ee			ld (debug_mark+2),a  
ad7e 18 03			jr .pastdmark  
ad80 ..			.dmark: db "DO."  
ad83 f1			.pastdmark: pop af  
ad84			endm  
# End of macro DMARK
ad84						CALLMONITOR 
ad84 cd 03 93			call break_point_state  
ad87				endm  
# End of macro CALLMONITOR
ad87					endif 
ad87			;  push pc to rsp stack past the DO 
ad87			 
ad87 2a 61 e6				ld hl, (os_tok_ptr) 
ad8a 23					inc hl   ; D 
ad8b 23					inc hl  ; O 
ad8c 23					inc hl   ; null 
ad8d					if DEBUG_FORTH_WORDS 
ad8d						DMARK "DO2" 
ad8d f5				push af  
ad8e 3a a2 ad			ld a, (.dmark)  
ad91 32 7a ee			ld (debug_mark),a  
ad94 3a a3 ad			ld a, (.dmark+1)  
ad97 32 7b ee			ld (debug_mark+1),a  
ad9a 3a a4 ad			ld a, (.dmark+2)  
ad9d 32 7c ee			ld (debug_mark+2),a  
ada0 18 03			jr .pastdmark  
ada2 ..			.dmark: db "DO2"  
ada5 f1			.pastdmark: pop af  
ada6			endm  
# End of macro DMARK
ada6						CALLMONITOR 
ada6 cd 03 93			call break_point_state  
ada9				endm  
# End of macro CALLMONITOR
ada9					endif 
ada9					FORTH_RSP_NEXT 
ada9 cd 37 98			call macro_forth_rsp_next 
adac				endm 
# End of macro FORTH_RSP_NEXT
adac					if DEBUG_FORTH_WORDS 
adac						DMARK "DO3" 
adac f5				push af  
adad 3a c1 ad			ld a, (.dmark)  
adb0 32 7a ee			ld (debug_mark),a  
adb3 3a c2 ad			ld a, (.dmark+1)  
adb6 32 7b ee			ld (debug_mark+1),a  
adb9 3a c3 ad			ld a, (.dmark+2)  
adbc 32 7c ee			ld (debug_mark+2),a  
adbf 18 03			jr .pastdmark  
adc1 ..			.dmark: db "DO3"  
adc4 f1			.pastdmark: pop af  
adc5			endm  
# End of macro DMARK
adc5						CALLMONITOR 
adc5 cd 03 93			call break_point_state  
adc8				endm  
# End of macro CALLMONITOR
adc8					endif 
adc8			 
adc8					;if DEBUG_FORTH_WORDS 
adc8				;		push hl 
adc8			;		endif  
adc8			 
adc8			; get counters from data stack 
adc8			 
adc8			 
adc8					FORTH_DSP_VALUEHL 
adc8 cd 87 9a			call macro_dsp_valuehl 
adcb				endm 
# End of macro FORTH_DSP_VALUEHL
adcb e5					push hl		 ; hl now has starting counter which needs to be tos 
adcc			 
adcc					if DEBUG_FORTH_WORDS 
adcc						DMARK "DO4" 
adcc f5				push af  
adcd 3a e1 ad			ld a, (.dmark)  
add0 32 7a ee			ld (debug_mark),a  
add3 3a e2 ad			ld a, (.dmark+1)  
add6 32 7b ee			ld (debug_mark+1),a  
add9 3a e3 ad			ld a, (.dmark+2)  
addc 32 7c ee			ld (debug_mark+2),a  
addf 18 03			jr .pastdmark  
ade1 ..			.dmark: db "DO4"  
ade4 f1			.pastdmark: pop af  
ade5			endm  
# End of macro DMARK
ade5						CALLMONITOR 
ade5 cd 03 93			call break_point_state  
ade8				endm  
# End of macro CALLMONITOR
ade8					endif 
ade8					FORTH_DSP_POP 
ade8 cd 3f 9b			call macro_forth_dsp_pop 
adeb				endm 
# End of macro FORTH_DSP_POP
adeb			 
adeb					if DEBUG_FORTH_WORDS 
adeb						DMARK "DO5" 
adeb f5				push af  
adec 3a 00 ae			ld a, (.dmark)  
adef 32 7a ee			ld (debug_mark),a  
adf2 3a 01 ae			ld a, (.dmark+1)  
adf5 32 7b ee			ld (debug_mark+1),a  
adf8 3a 02 ae			ld a, (.dmark+2)  
adfb 32 7c ee			ld (debug_mark+2),a  
adfe 18 03			jr .pastdmark  
ae00 ..			.dmark: db "DO5"  
ae03 f1			.pastdmark: pop af  
ae04			endm  
# End of macro DMARK
ae04						CALLMONITOR 
ae04 cd 03 93			call break_point_state  
ae07				endm  
# End of macro CALLMONITOR
ae07					endif 
ae07			 
ae07					FORTH_DSP_VALUEHL 
ae07 cd 87 9a			call macro_dsp_valuehl 
ae0a				endm 
# End of macro FORTH_DSP_VALUEHL
ae0a			;		push hl		 ; hl now has starting limit counter 
ae0a			 
ae0a					if DEBUG_FORTH_WORDS 
ae0a						DMARK "DO6" 
ae0a f5				push af  
ae0b 3a 1f ae			ld a, (.dmark)  
ae0e 32 7a ee			ld (debug_mark),a  
ae11 3a 20 ae			ld a, (.dmark+1)  
ae14 32 7b ee			ld (debug_mark+1),a  
ae17 3a 21 ae			ld a, (.dmark+2)  
ae1a 32 7c ee			ld (debug_mark+2),a  
ae1d 18 03			jr .pastdmark  
ae1f ..			.dmark: db "DO6"  
ae22 f1			.pastdmark: pop af  
ae23			endm  
# End of macro DMARK
ae23						CALLMONITOR 
ae23 cd 03 93			call break_point_state  
ae26				endm  
# End of macro CALLMONITOR
ae26					endif 
ae26					FORTH_DSP_POP 
ae26 cd 3f 9b			call macro_forth_dsp_pop 
ae29				endm 
# End of macro FORTH_DSP_POP
ae29			 
ae29			; put counters on the loop stack 
ae29			 
ae29			;		pop hl			 ; limit counter 
ae29 d1					pop de			; start counter 
ae2a			 
ae2a					; push limit counter 
ae2a			 
ae2a					if DEBUG_FORTH_WORDS 
ae2a						DMARK "DO7" 
ae2a f5				push af  
ae2b 3a 3f ae			ld a, (.dmark)  
ae2e 32 7a ee			ld (debug_mark),a  
ae31 3a 40 ae			ld a, (.dmark+1)  
ae34 32 7b ee			ld (debug_mark+1),a  
ae37 3a 41 ae			ld a, (.dmark+2)  
ae3a 32 7c ee			ld (debug_mark+2),a  
ae3d 18 03			jr .pastdmark  
ae3f ..			.dmark: db "DO7"  
ae42 f1			.pastdmark: pop af  
ae43			endm  
# End of macro DMARK
ae43						CALLMONITOR 
ae43 cd 03 93			call break_point_state  
ae46				endm  
# End of macro CALLMONITOR
ae46					endif 
ae46					FORTH_LOOP_NEXT 
ae46 cd b8 9a			call macro_forth_loop_next 
ae49				endm 
# End of macro FORTH_LOOP_NEXT
ae49			 
ae49					; push start counter 
ae49			 
ae49 eb					ex de, hl 
ae4a					if DEBUG_FORTH_WORDS 
ae4a						DMARK "DO7" 
ae4a f5				push af  
ae4b 3a 5f ae			ld a, (.dmark)  
ae4e 32 7a ee			ld (debug_mark),a  
ae51 3a 60 ae			ld a, (.dmark+1)  
ae54 32 7b ee			ld (debug_mark+1),a  
ae57 3a 61 ae			ld a, (.dmark+2)  
ae5a 32 7c ee			ld (debug_mark+2),a  
ae5d 18 03			jr .pastdmark  
ae5f ..			.dmark: db "DO7"  
ae62 f1			.pastdmark: pop af  
ae63			endm  
# End of macro DMARK
ae63						CALLMONITOR 
ae63 cd 03 93			call break_point_state  
ae66				endm  
# End of macro CALLMONITOR
ae66					endif 
ae66					FORTH_LOOP_NEXT 
ae66 cd b8 9a			call macro_forth_loop_next 
ae69				endm 
# End of macro FORTH_LOOP_NEXT
ae69			 
ae69			 
ae69					; init first round of I counter 
ae69			 
ae69 22 85 e6				ld (os_current_i), hl 
ae6c			 
ae6c					if DEBUG_FORTH_WORDS 
ae6c						DMARK "DO8" 
ae6c f5				push af  
ae6d 3a 81 ae			ld a, (.dmark)  
ae70 32 7a ee			ld (debug_mark),a  
ae73 3a 82 ae			ld a, (.dmark+1)  
ae76 32 7b ee			ld (debug_mark+1),a  
ae79 3a 83 ae			ld a, (.dmark+2)  
ae7c 32 7c ee			ld (debug_mark+2),a  
ae7f 18 03			jr .pastdmark  
ae81 ..			.dmark: db "DO8"  
ae84 f1			.pastdmark: pop af  
ae85			endm  
# End of macro DMARK
ae85						CALLMONITOR 
ae85 cd 03 93			call break_point_state  
ae88				endm  
# End of macro CALLMONITOR
ae88					endif 
ae88			 
ae88					NEXTW 
ae88 c3 f9 9b			jp macro_next 
ae8b				endm 
# End of macro NEXTW
ae8b			.LOOP: 
ae8b				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
ae8b 22				db WORD_SYS_CORE+14             
ae8c a3 af			dw .I            
ae8e 05				db 4 + 1 
ae8f .. 00			db "LOOP",0              
ae94				endm 
# End of macro CWHEAD
ae94			; | LOOP ( -- ) Increment and test loop counter  | DONE 
ae94			 
ae94				; pop tos as current loop count to hl 
ae94			 
ae94				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
ae94			 
ae94				FORTH_LOOP_TOS 
ae94 cd eb 9a			call macro_forth_loop_tos 
ae97				endm 
# End of macro FORTH_LOOP_TOS
ae97 e5				push hl 
ae98			 
ae98					if DEBUG_FORTH_WORDS_KEY 
ae98						DMARK "LOP" 
ae98 f5				push af  
ae99 3a ad ae			ld a, (.dmark)  
ae9c 32 7a ee			ld (debug_mark),a  
ae9f 3a ae ae			ld a, (.dmark+1)  
aea2 32 7b ee			ld (debug_mark+1),a  
aea5 3a af ae			ld a, (.dmark+2)  
aea8 32 7c ee			ld (debug_mark+2),a  
aeab 18 03			jr .pastdmark  
aead ..			.dmark: db "LOP"  
aeb0 f1			.pastdmark: pop af  
aeb1			endm  
# End of macro DMARK
aeb1						CALLMONITOR 
aeb1 cd 03 93			call break_point_state  
aeb4				endm  
# End of macro CALLMONITOR
aeb4					endif 
aeb4				; next item on the stack is the limit. get it 
aeb4			 
aeb4			 
aeb4				FORTH_LOOP_POP 
aeb4 cd f5 9a			call macro_forth_loop_pop 
aeb7				endm 
# End of macro FORTH_LOOP_POP
aeb7			 
aeb7				FORTH_LOOP_TOS 
aeb7 cd eb 9a			call macro_forth_loop_tos 
aeba				endm 
# End of macro FORTH_LOOP_TOS
aeba			 
aeba d1				pop de		 ; de = i, hl = limit 
aebb			 
aebb					if DEBUG_FORTH_WORDS 
aebb						DMARK "LP1" 
aebb f5				push af  
aebc 3a d0 ae			ld a, (.dmark)  
aebf 32 7a ee			ld (debug_mark),a  
aec2 3a d1 ae			ld a, (.dmark+1)  
aec5 32 7b ee			ld (debug_mark+1),a  
aec8 3a d2 ae			ld a, (.dmark+2)  
aecb 32 7c ee			ld (debug_mark+2),a  
aece 18 03			jr .pastdmark  
aed0 ..			.dmark: db "LP1"  
aed3 f1			.pastdmark: pop af  
aed4			endm  
# End of macro DMARK
aed4						CALLMONITOR 
aed4 cd 03 93			call break_point_state  
aed7				endm  
# End of macro CALLMONITOR
aed7					endif 
aed7			 
aed7				; go back to previous word 
aed7			 
aed7 d5				push de    ; save I for inc later 
aed8			 
aed8			 
aed8				; get limit 
aed8				;  is I at limit? 
aed8			 
aed8			 
aed8					if DEBUG_FORTH_WORDS 
aed8						DMARK "LP1" 
aed8 f5				push af  
aed9 3a ed ae			ld a, (.dmark)  
aedc 32 7a ee			ld (debug_mark),a  
aedf 3a ee ae			ld a, (.dmark+1)  
aee2 32 7b ee			ld (debug_mark+1),a  
aee5 3a ef ae			ld a, (.dmark+2)  
aee8 32 7c ee			ld (debug_mark+2),a  
aeeb 18 03			jr .pastdmark  
aeed ..			.dmark: db "LP1"  
aef0 f1			.pastdmark: pop af  
aef1			endm  
# End of macro DMARK
aef1						CALLMONITOR 
aef1 cd 03 93			call break_point_state  
aef4				endm  
# End of macro CALLMONITOR
aef4					endif 
aef4			 
aef4 ed 52			sbc hl, de 
aef6			 
aef6			 
aef6				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
aef6			 
aef6 20 26				jr nz, .loopnotdone 
aef8			 
aef8 e1				pop hl   ; get rid of saved I 
aef9				FORTH_LOOP_POP     ; get rid of limit 
aef9 cd f5 9a			call macro_forth_loop_pop 
aefc				endm 
# End of macro FORTH_LOOP_POP
aefc			 
aefc				FORTH_RSP_POP     ; get rid of DO ptr 
aefc cd 58 98			call macro_forth_rsp_pop 
aeff				endm 
# End of macro FORTH_RSP_POP
aeff			 
aeff			if DEBUG_FORTH_WORDS 
aeff						DMARK "LP>" 
aeff f5				push af  
af00 3a 14 af			ld a, (.dmark)  
af03 32 7a ee			ld (debug_mark),a  
af06 3a 15 af			ld a, (.dmark+1)  
af09 32 7b ee			ld (debug_mark+1),a  
af0c 3a 16 af			ld a, (.dmark+2)  
af0f 32 7c ee			ld (debug_mark+2),a  
af12 18 03			jr .pastdmark  
af14 ..			.dmark: db "LP>"  
af17 f1			.pastdmark: pop af  
af18			endm  
# End of macro DMARK
af18				CALLMONITOR 
af18 cd 03 93			call break_point_state  
af1b				endm  
# End of macro CALLMONITOR
af1b			endif 
af1b			 
af1b					NEXTW 
af1b c3 f9 9b			jp macro_next 
af1e				endm 
# End of macro NEXTW
af1e				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
af1e			 
af1e			.loopnotdone: 
af1e			 
af1e e1				pop hl    ; get I 
af1f 23				inc hl 
af20			 
af20			   	; save new I 
af20			 
af20			 
af20					; set I counter 
af20			 
af20 22 85 e6				ld (os_current_i), hl 
af23			 
af23					if DEBUG_FORTH_WORDS 
af23						DMARK "LPN" 
af23 f5				push af  
af24 3a 38 af			ld a, (.dmark)  
af27 32 7a ee			ld (debug_mark),a  
af2a 3a 39 af			ld a, (.dmark+1)  
af2d 32 7b ee			ld (debug_mark+1),a  
af30 3a 3a af			ld a, (.dmark+2)  
af33 32 7c ee			ld (debug_mark+2),a  
af36 18 03			jr .pastdmark  
af38 ..			.dmark: db "LPN"  
af3b f1			.pastdmark: pop af  
af3c			endm  
# End of macro DMARK
af3c					CALLMONITOR 
af3c cd 03 93			call break_point_state  
af3f				endm  
# End of macro CALLMONITOR
af3f					endif 
af3f					 
af3f				FORTH_LOOP_NEXT 
af3f cd b8 9a			call macro_forth_loop_next 
af42				endm 
# End of macro FORTH_LOOP_NEXT
af42			 
af42			 
af42					if DEBUG_FORTH_WORDS 
af42 eb						ex de,hl 
af43					endif 
af43			 
af43			;	; get DO ptr 
af43			; 
af43					if DEBUG_FORTH_WORDS 
af43						DMARK "LP7" 
af43 f5				push af  
af44 3a 58 af			ld a, (.dmark)  
af47 32 7a ee			ld (debug_mark),a  
af4a 3a 59 af			ld a, (.dmark+1)  
af4d 32 7b ee			ld (debug_mark+1),a  
af50 3a 5a af			ld a, (.dmark+2)  
af53 32 7c ee			ld (debug_mark+2),a  
af56 18 03			jr .pastdmark  
af58 ..			.dmark: db "LP7"  
af5b f1			.pastdmark: pop af  
af5c			endm  
# End of macro DMARK
af5c					CALLMONITOR 
af5c cd 03 93			call break_point_state  
af5f				endm  
# End of macro CALLMONITOR
af5f					endif 
af5f				FORTH_RSP_TOS 
af5f cd 4e 98			call macro_forth_rsp_tos 
af62				endm 
# End of macro FORTH_RSP_TOS
af62			 
af62					if DEBUG_FORTH_WORDS 
af62						DMARK "LP8" 
af62 f5				push af  
af63 3a 77 af			ld a, (.dmark)  
af66 32 7a ee			ld (debug_mark),a  
af69 3a 78 af			ld a, (.dmark+1)  
af6c 32 7b ee			ld (debug_mark+1),a  
af6f 3a 79 af			ld a, (.dmark+2)  
af72 32 7c ee			ld (debug_mark+2),a  
af75 18 03			jr .pastdmark  
af77 ..			.dmark: db "LP8"  
af7a f1			.pastdmark: pop af  
af7b			endm  
# End of macro DMARK
af7b					CALLMONITOR 
af7b cd 03 93			call break_point_state  
af7e				endm  
# End of macro CALLMONITOR
af7e					endif 
af7e				;push hl 
af7e			 
af7e				; not going to DO any more 
af7e				; get rid of the RSP pointer as DO will add it back in 
af7e				;FORTH_RSP_POP 
af7e				;pop hl 
af7e			 
af7e				;ld hl,(cli_ret_sp) 
af7e				;ld e, (hl) 
af7e				;inc hl 
af7e				;ld d, (hl) 
af7e				;ex de,hl 
af7e 22 61 e6			ld (os_tok_ptr), hl 
af81					if DEBUG_FORTH_WORDS 
af81						DMARK "LP<" 
af81 f5				push af  
af82 3a 96 af			ld a, (.dmark)  
af85 32 7a ee			ld (debug_mark),a  
af88 3a 97 af			ld a, (.dmark+1)  
af8b 32 7b ee			ld (debug_mark+1),a  
af8e 3a 98 af			ld a, (.dmark+2)  
af91 32 7c ee			ld (debug_mark+2),a  
af94 18 03			jr .pastdmark  
af96 ..			.dmark: db "LP<"  
af99 f1			.pastdmark: pop af  
af9a			endm  
# End of macro DMARK
af9a					CALLMONITOR 
af9a cd 03 93			call break_point_state  
af9d				endm  
# End of macro CALLMONITOR
af9d				endif 
af9d c3 8a 9c			jp exec1 
afa0			 
afa0					 
afa0			 
afa0			 
afa0					NEXTW 
afa0 c3 f9 9b			jp macro_next 
afa3				endm 
# End of macro NEXTW
afa3			.I:  
afa3			 
afa3				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
afa3 5e				db WORD_SYS_CORE+74             
afa4 ce af			dw .DLOOP            
afa6 02				db 1 + 1 
afa7 .. 00			db "I",0              
afa9				endm 
# End of macro CWHEAD
afa9			; | I ( -- ) Current loop counter | DONE 
afa9					if DEBUG_FORTH_WORDS_KEY 
afa9						DMARK "I.." 
afa9 f5				push af  
afaa 3a be af			ld a, (.dmark)  
afad 32 7a ee			ld (debug_mark),a  
afb0 3a bf af			ld a, (.dmark+1)  
afb3 32 7b ee			ld (debug_mark+1),a  
afb6 3a c0 af			ld a, (.dmark+2)  
afb9 32 7c ee			ld (debug_mark+2),a  
afbc 18 03			jr .pastdmark  
afbe ..			.dmark: db "I.."  
afc1 f1			.pastdmark: pop af  
afc2			endm  
# End of macro DMARK
afc2						CALLMONITOR 
afc2 cd 03 93			call break_point_state  
afc5				endm  
# End of macro CALLMONITOR
afc5					endif 
afc5			 
afc5 2a 85 e6				ld hl,(os_current_i) 
afc8 cd 90 98				call forth_push_numhl 
afcb			 
afcb					NEXTW 
afcb c3 f9 9b			jp macro_next 
afce				endm 
# End of macro NEXTW
afce			.DLOOP: 
afce				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
afce 5f				db WORD_SYS_CORE+75             
afcf af b0			dw .REPEAT            
afd1 06				db 5 + 1 
afd2 .. 00			db "-LOOP",0              
afd8				endm 
# End of macro CWHEAD
afd8			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
afd8				; pop tos as current loop count to hl 
afd8					if DEBUG_FORTH_WORDS_KEY 
afd8						DMARK "-LP" 
afd8 f5				push af  
afd9 3a ed af			ld a, (.dmark)  
afdc 32 7a ee			ld (debug_mark),a  
afdf 3a ee af			ld a, (.dmark+1)  
afe2 32 7b ee			ld (debug_mark+1),a  
afe5 3a ef af			ld a, (.dmark+2)  
afe8 32 7c ee			ld (debug_mark+2),a  
afeb 18 03			jr .pastdmark  
afed ..			.dmark: db "-LP"  
aff0 f1			.pastdmark: pop af  
aff1			endm  
# End of macro DMARK
aff1						CALLMONITOR 
aff1 cd 03 93			call break_point_state  
aff4				endm  
# End of macro CALLMONITOR
aff4					endif 
aff4			 
aff4				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
aff4			 
aff4				FORTH_LOOP_TOS 
aff4 cd eb 9a			call macro_forth_loop_tos 
aff7				endm 
# End of macro FORTH_LOOP_TOS
aff7 e5				push hl 
aff8			 
aff8					if DEBUG_FORTH_WORDS 
aff8						DMARK "-LP" 
aff8 f5				push af  
aff9 3a 0d b0			ld a, (.dmark)  
affc 32 7a ee			ld (debug_mark),a  
afff 3a 0e b0			ld a, (.dmark+1)  
b002 32 7b ee			ld (debug_mark+1),a  
b005 3a 0f b0			ld a, (.dmark+2)  
b008 32 7c ee			ld (debug_mark+2),a  
b00b 18 03			jr .pastdmark  
b00d ..			.dmark: db "-LP"  
b010 f1			.pastdmark: pop af  
b011			endm  
# End of macro DMARK
b011						CALLMONITOR 
b011 cd 03 93			call break_point_state  
b014				endm  
# End of macro CALLMONITOR
b014					endif 
b014				; next item on the stack is the limit. get it 
b014			 
b014			 
b014				FORTH_LOOP_POP 
b014 cd f5 9a			call macro_forth_loop_pop 
b017				endm 
# End of macro FORTH_LOOP_POP
b017			 
b017				FORTH_LOOP_TOS 
b017 cd eb 9a			call macro_forth_loop_tos 
b01a				endm 
# End of macro FORTH_LOOP_TOS
b01a			 
b01a d1				pop de		 ; de = i, hl = limit 
b01b			 
b01b					if DEBUG_FORTH_WORDS 
b01b						DMARK "-L1" 
b01b f5				push af  
b01c 3a 30 b0			ld a, (.dmark)  
b01f 32 7a ee			ld (debug_mark),a  
b022 3a 31 b0			ld a, (.dmark+1)  
b025 32 7b ee			ld (debug_mark+1),a  
b028 3a 32 b0			ld a, (.dmark+2)  
b02b 32 7c ee			ld (debug_mark+2),a  
b02e 18 03			jr .pastdmark  
b030 ..			.dmark: db "-L1"  
b033 f1			.pastdmark: pop af  
b034			endm  
# End of macro DMARK
b034						CALLMONITOR 
b034 cd 03 93			call break_point_state  
b037				endm  
# End of macro CALLMONITOR
b037					endif 
b037			 
b037				; go back to previous word 
b037			 
b037 d5				push de    ; save I for inc later 
b038			 
b038			 
b038				; get limit 
b038				;  is I at limit? 
b038			 
b038			 
b038					if DEBUG_FORTH_WORDS 
b038						DMARK "-L1" 
b038 f5				push af  
b039 3a 4d b0			ld a, (.dmark)  
b03c 32 7a ee			ld (debug_mark),a  
b03f 3a 4e b0			ld a, (.dmark+1)  
b042 32 7b ee			ld (debug_mark+1),a  
b045 3a 4f b0			ld a, (.dmark+2)  
b048 32 7c ee			ld (debug_mark+2),a  
b04b 18 03			jr .pastdmark  
b04d ..			.dmark: db "-L1"  
b050 f1			.pastdmark: pop af  
b051			endm  
# End of macro DMARK
b051						CALLMONITOR 
b051 cd 03 93			call break_point_state  
b054				endm  
# End of macro CALLMONITOR
b054					endif 
b054			 
b054 ed 52			sbc hl, de 
b056			 
b056			 
b056				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b056			 
b056 20 26				jr nz, .mloopnotdone 
b058			 
b058 e1				pop hl   ; get rid of saved I 
b059				FORTH_LOOP_POP     ; get rid of limit 
b059 cd f5 9a			call macro_forth_loop_pop 
b05c				endm 
# End of macro FORTH_LOOP_POP
b05c			 
b05c				FORTH_RSP_POP     ; get rid of DO ptr 
b05c cd 58 98			call macro_forth_rsp_pop 
b05f				endm 
# End of macro FORTH_RSP_POP
b05f			 
b05f			if DEBUG_FORTH_WORDS 
b05f						DMARK "-L>" 
b05f f5				push af  
b060 3a 74 b0			ld a, (.dmark)  
b063 32 7a ee			ld (debug_mark),a  
b066 3a 75 b0			ld a, (.dmark+1)  
b069 32 7b ee			ld (debug_mark+1),a  
b06c 3a 76 b0			ld a, (.dmark+2)  
b06f 32 7c ee			ld (debug_mark+2),a  
b072 18 03			jr .pastdmark  
b074 ..			.dmark: db "-L>"  
b077 f1			.pastdmark: pop af  
b078			endm  
# End of macro DMARK
b078				CALLMONITOR 
b078 cd 03 93			call break_point_state  
b07b				endm  
# End of macro CALLMONITOR
b07b			endif 
b07b			 
b07b					NEXTW 
b07b c3 f9 9b			jp macro_next 
b07e				endm 
# End of macro NEXTW
b07e				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b07e			 
b07e			.mloopnotdone: 
b07e			 
b07e e1				pop hl    ; get I 
b07f 2b				dec hl 
b080			 
b080			   	; save new I 
b080			 
b080			 
b080					; set I counter 
b080			 
b080 22 85 e6				ld (os_current_i), hl 
b083			 
b083					 
b083				FORTH_LOOP_NEXT 
b083 cd b8 9a			call macro_forth_loop_next 
b086				endm 
# End of macro FORTH_LOOP_NEXT
b086			 
b086			 
b086					if DEBUG_FORTH_WORDS 
b086 eb						ex de,hl 
b087					endif 
b087			 
b087			;	; get DO ptr 
b087			; 
b087				FORTH_RSP_TOS 
b087 cd 4e 98			call macro_forth_rsp_tos 
b08a				endm 
# End of macro FORTH_RSP_TOS
b08a			 
b08a				;push hl 
b08a			 
b08a				; not going to DO any more 
b08a				; get rid of the RSP pointer as DO will add it back in 
b08a				;FORTH_RSP_POP 
b08a				;pop hl 
b08a			 
b08a			 
b08a 22 61 e6			ld (os_tok_ptr), hl 
b08d					if DEBUG_FORTH_WORDS 
b08d						DMARK "-L<" 
b08d f5				push af  
b08e 3a a2 b0			ld a, (.dmark)  
b091 32 7a ee			ld (debug_mark),a  
b094 3a a3 b0			ld a, (.dmark+1)  
b097 32 7b ee			ld (debug_mark+1),a  
b09a 3a a4 b0			ld a, (.dmark+2)  
b09d 32 7c ee			ld (debug_mark+2),a  
b0a0 18 03			jr .pastdmark  
b0a2 ..			.dmark: db "-L<"  
b0a5 f1			.pastdmark: pop af  
b0a6			endm  
# End of macro DMARK
b0a6					CALLMONITOR 
b0a6 cd 03 93			call break_point_state  
b0a9				endm  
# End of macro CALLMONITOR
b0a9				endif 
b0a9 c3 8a 9c			jp exec1 
b0ac			 
b0ac					 
b0ac			 
b0ac			 
b0ac			 
b0ac				NEXTW 
b0ac c3 f9 9b			jp macro_next 
b0af				endm 
# End of macro NEXTW
b0af			 
b0af			 
b0af			 
b0af			 
b0af			.REPEAT: 
b0af				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b0af 71				db WORD_SYS_CORE+93             
b0b0 02 b1			dw .UNTIL            
b0b2 06				db 5 + 1 
b0b3 .. 00			db "REPEAT",0              
b0ba				endm 
# End of macro CWHEAD
b0ba			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b0ba			;  push pc to rsp stack past the REPEAT 
b0ba					if DEBUG_FORTH_WORDS_KEY 
b0ba						DMARK "REP" 
b0ba f5				push af  
b0bb 3a cf b0			ld a, (.dmark)  
b0be 32 7a ee			ld (debug_mark),a  
b0c1 3a d0 b0			ld a, (.dmark+1)  
b0c4 32 7b ee			ld (debug_mark+1),a  
b0c7 3a d1 b0			ld a, (.dmark+2)  
b0ca 32 7c ee			ld (debug_mark+2),a  
b0cd 18 03			jr .pastdmark  
b0cf ..			.dmark: db "REP"  
b0d2 f1			.pastdmark: pop af  
b0d3			endm  
# End of macro DMARK
b0d3						CALLMONITOR 
b0d3 cd 03 93			call break_point_state  
b0d6				endm  
# End of macro CALLMONITOR
b0d6					endif 
b0d6			 
b0d6 2a 61 e6				ld hl, (os_tok_ptr) 
b0d9 23					inc hl   ; R 
b0da 23					inc hl  ; E 
b0db 23					inc hl   ; P 
b0dc 23					inc hl   ; E 
b0dd 23					inc hl   ; A 
b0de 23					inc hl   ; T 
b0df 23					inc hl   ; zero 
b0e0					FORTH_RSP_NEXT 
b0e0 cd 37 98			call macro_forth_rsp_next 
b0e3				endm 
# End of macro FORTH_RSP_NEXT
b0e3			 
b0e3			 
b0e3					if DEBUG_FORTH_WORDS 
b0e3						DMARK "REP" 
b0e3 f5				push af  
b0e4 3a f8 b0			ld a, (.dmark)  
b0e7 32 7a ee			ld (debug_mark),a  
b0ea 3a f9 b0			ld a, (.dmark+1)  
b0ed 32 7b ee			ld (debug_mark+1),a  
b0f0 3a fa b0			ld a, (.dmark+2)  
b0f3 32 7c ee			ld (debug_mark+2),a  
b0f6 18 03			jr .pastdmark  
b0f8 ..			.dmark: db "REP"  
b0fb f1			.pastdmark: pop af  
b0fc			endm  
# End of macro DMARK
b0fc						;pop bc    ; TODO BUG ?????? what is this for???? 
b0fc						CALLMONITOR 
b0fc cd 03 93			call break_point_state  
b0ff				endm  
# End of macro CALLMONITOR
b0ff					endif 
b0ff			 
b0ff					NEXTW 
b0ff c3 f9 9b			jp macro_next 
b102				endm 
# End of macro NEXTW
b102			;	       NEXTW 
b102			 
b102			.UNTIL: 
b102				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b102 72				db WORD_SYS_CORE+94             
b103 99 b1			dw .ENDFLOW            
b105 06				db 5 + 1 
b106 .. 00			db "UNTIL",0              
b10c				endm 
# End of macro CWHEAD
b10c			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b10c			 
b10c				; pop tos as check 
b10c			 
b10c				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b10c			 
b10c				FORTH_DSP_VALUEHL 
b10c cd 87 9a			call macro_dsp_valuehl 
b10f				endm 
# End of macro FORTH_DSP_VALUEHL
b10f			 
b10f					if DEBUG_FORTH_WORDS_KEY 
b10f						DMARK "UNT" 
b10f f5				push af  
b110 3a 24 b1			ld a, (.dmark)  
b113 32 7a ee			ld (debug_mark),a  
b116 3a 25 b1			ld a, (.dmark+1)  
b119 32 7b ee			ld (debug_mark+1),a  
b11c 3a 26 b1			ld a, (.dmark+2)  
b11f 32 7c ee			ld (debug_mark+2),a  
b122 18 03			jr .pastdmark  
b124 ..			.dmark: db "UNT"  
b127 f1			.pastdmark: pop af  
b128			endm  
# End of macro DMARK
b128						CALLMONITOR 
b128 cd 03 93			call break_point_state  
b12b				endm  
# End of macro CALLMONITOR
b12b					endif 
b12b			 
b12b			;	push hl 
b12b				FORTH_DSP_POP 
b12b cd 3f 9b			call macro_forth_dsp_pop 
b12e				endm 
# End of macro FORTH_DSP_POP
b12e			 
b12e			;	pop hl 
b12e			 
b12e				; test if true 
b12e			 
b12e cd d0 8a			call ishlzero 
b131			;	ld a,l 
b131			;	add h 
b131			; 
b131			;	cp 0 
b131			 
b131 20 3e			jr nz, .untilnotdone 
b133			 
b133					if DEBUG_FORTH_WORDS 
b133						DMARK "UNf" 
b133 f5				push af  
b134 3a 48 b1			ld a, (.dmark)  
b137 32 7a ee			ld (debug_mark),a  
b13a 3a 49 b1			ld a, (.dmark+1)  
b13d 32 7b ee			ld (debug_mark+1),a  
b140 3a 4a b1			ld a, (.dmark+2)  
b143 32 7c ee			ld (debug_mark+2),a  
b146 18 03			jr .pastdmark  
b148 ..			.dmark: db "UNf"  
b14b f1			.pastdmark: pop af  
b14c			endm  
# End of macro DMARK
b14c						CALLMONITOR 
b14c cd 03 93			call break_point_state  
b14f				endm  
# End of macro CALLMONITOR
b14f					endif 
b14f			 
b14f			 
b14f			 
b14f				FORTH_RSP_POP     ; get rid of DO ptr 
b14f cd 58 98			call macro_forth_rsp_pop 
b152				endm 
# End of macro FORTH_RSP_POP
b152			 
b152			if DEBUG_FORTH_WORDS 
b152						DMARK "UN>" 
b152 f5				push af  
b153 3a 67 b1			ld a, (.dmark)  
b156 32 7a ee			ld (debug_mark),a  
b159 3a 68 b1			ld a, (.dmark+1)  
b15c 32 7b ee			ld (debug_mark+1),a  
b15f 3a 69 b1			ld a, (.dmark+2)  
b162 32 7c ee			ld (debug_mark+2),a  
b165 18 03			jr .pastdmark  
b167 ..			.dmark: db "UN>"  
b16a f1			.pastdmark: pop af  
b16b			endm  
# End of macro DMARK
b16b				CALLMONITOR 
b16b cd 03 93			call break_point_state  
b16e				endm  
# End of macro CALLMONITOR
b16e			endif 
b16e			 
b16e					NEXTW 
b16e c3 f9 9b			jp macro_next 
b171				endm 
# End of macro NEXTW
b171				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b171			 
b171			.untilnotdone: 
b171			 
b171			 
b171			;	; get DO ptr 
b171			; 
b171				FORTH_RSP_TOS 
b171 cd 4e 98			call macro_forth_rsp_tos 
b174				endm 
# End of macro FORTH_RSP_TOS
b174			 
b174				;push hl 
b174			 
b174				; not going to DO any more 
b174				; get rid of the RSP pointer as DO will add it back in 
b174				;FORTH_RSP_POP 
b174				;pop hl 
b174			 
b174			 
b174 22 61 e6			ld (os_tok_ptr), hl 
b177					if DEBUG_FORTH_WORDS 
b177						DMARK "UN<" 
b177 f5				push af  
b178 3a 8c b1			ld a, (.dmark)  
b17b 32 7a ee			ld (debug_mark),a  
b17e 3a 8d b1			ld a, (.dmark+1)  
b181 32 7b ee			ld (debug_mark+1),a  
b184 3a 8e b1			ld a, (.dmark+2)  
b187 32 7c ee			ld (debug_mark+2),a  
b18a 18 03			jr .pastdmark  
b18c ..			.dmark: db "UN<"  
b18f f1			.pastdmark: pop af  
b190			endm  
# End of macro DMARK
b190					CALLMONITOR 
b190 cd 03 93			call break_point_state  
b193				endm  
# End of macro CALLMONITOR
b193				endif 
b193 c3 8a 9c			jp exec1 
b196			 
b196					 
b196			 
b196			 
b196					NEXTW 
b196 c3 f9 9b			jp macro_next 
b199				endm 
# End of macro NEXTW
b199			 
b199			 
b199			.ENDFLOW: 
b199			 
b199			; eof 
b199			 
# End of file forth_words_flow.asm
b199			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b199			include "forth_words_logic.asm" 
b199			 
b199			; | ## Logic Words 
b199			 
b199			.NOT: 
b199				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b199 2d				db WORD_SYS_CORE+25             
b19a e1 b1			dw .IS            
b19c 04				db 3 + 1 
b19d .. 00			db "NOT",0              
b1a1				endm 
# End of macro CWHEAD
b1a1			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b1a1					if DEBUG_FORTH_WORDS_KEY 
b1a1						DMARK "NOT" 
b1a1 f5				push af  
b1a2 3a b6 b1			ld a, (.dmark)  
b1a5 32 7a ee			ld (debug_mark),a  
b1a8 3a b7 b1			ld a, (.dmark+1)  
b1ab 32 7b ee			ld (debug_mark+1),a  
b1ae 3a b8 b1			ld a, (.dmark+2)  
b1b1 32 7c ee			ld (debug_mark+2),a  
b1b4 18 03			jr .pastdmark  
b1b6 ..			.dmark: db "NOT"  
b1b9 f1			.pastdmark: pop af  
b1ba			endm  
# End of macro DMARK
b1ba						CALLMONITOR 
b1ba cd 03 93			call break_point_state  
b1bd				endm  
# End of macro CALLMONITOR
b1bd					endif 
b1bd					FORTH_DSP 
b1bd cd 4d 9a			call macro_forth_dsp 
b1c0				endm 
# End of macro FORTH_DSP
b1c0 7e					ld a,(hl)	; get type of value on TOS 
b1c1 fe 02				cp DS_TYPE_INUM  
b1c3 28 03				jr z, .noti 
b1c5					NEXTW 
b1c5 c3 f9 9b			jp macro_next 
b1c8				endm 
# End of macro NEXTW
b1c8			.noti:          FORTH_DSP_VALUEHL 
b1c8 cd 87 9a			call macro_dsp_valuehl 
b1cb				endm 
# End of macro FORTH_DSP_VALUEHL
b1cb			;		push hl 
b1cb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1cb cd 3f 9b			call macro_forth_dsp_pop 
b1ce				endm 
# End of macro FORTH_DSP_POP
b1ce			;		pop hl 
b1ce 3e 00				ld a,0 
b1d0 bd					cp l 
b1d1 28 04				jr z, .not2t 
b1d3 2e 00				ld l, 0 
b1d5 18 02				jr .notip 
b1d7			 
b1d7 2e ff		.not2t:		ld l, 255 
b1d9			 
b1d9 26 00		.notip:		ld h, 0	 
b1db			 
b1db cd 90 98				call forth_push_numhl 
b1de					NEXTW 
b1de c3 f9 9b			jp macro_next 
b1e1				endm 
# End of macro NEXTW
b1e1			 
b1e1			.IS: 
b1e1				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b1e1 2d				db WORD_SYS_CORE+25             
b1e2 07 b2			dw .LZERO            
b1e4 03				db 2 + 1 
b1e5 .. 00			db "IS",0              
b1e8				endm 
# End of macro CWHEAD
b1e8			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b1e8					if DEBUG_FORTH_WORDS_KEY 
b1e8						DMARK "IS." 
b1e8 f5				push af  
b1e9 3a fd b1			ld a, (.dmark)  
b1ec 32 7a ee			ld (debug_mark),a  
b1ef 3a fe b1			ld a, (.dmark+1)  
b1f2 32 7b ee			ld (debug_mark+1),a  
b1f5 3a ff b1			ld a, (.dmark+2)  
b1f8 32 7c ee			ld (debug_mark+2),a  
b1fb 18 03			jr .pastdmark  
b1fd ..			.dmark: db "IS."  
b200 f1			.pastdmark: pop af  
b201			endm  
# End of macro DMARK
b201						CALLMONITOR 
b201 cd 03 93			call break_point_state  
b204				endm  
# End of macro CALLMONITOR
b204					endif 
b204					NEXTW 
b204 c3 f9 9b			jp macro_next 
b207				endm 
# End of macro NEXTW
b207			.LZERO: 
b207				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b207 2d				db WORD_SYS_CORE+25             
b208 11 b2			dw .TZERO            
b20a 03				db 2 + 1 
b20b .. 00			db "0<",0              
b20e				endm 
# End of macro CWHEAD
b20e			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b20e					NEXTW 
b20e c3 f9 9b			jp macro_next 
b211				endm 
# End of macro NEXTW
b211			.TZERO: 
b211				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b211 2e				db WORD_SYS_CORE+26             
b212 58 b2			dw .LESS            
b214 03				db 2 + 1 
b215 .. 00			db "0=",0              
b218				endm 
# End of macro CWHEAD
b218			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b218				; TODO add floating point number detection 
b218					;v5 FORTH_DSP_VALUE 
b218					if DEBUG_FORTH_WORDS_KEY 
b218						DMARK "0=." 
b218 f5				push af  
b219 3a 2d b2			ld a, (.dmark)  
b21c 32 7a ee			ld (debug_mark),a  
b21f 3a 2e b2			ld a, (.dmark+1)  
b222 32 7b ee			ld (debug_mark+1),a  
b225 3a 2f b2			ld a, (.dmark+2)  
b228 32 7c ee			ld (debug_mark+2),a  
b22b 18 03			jr .pastdmark  
b22d ..			.dmark: db "0=."  
b230 f1			.pastdmark: pop af  
b231			endm  
# End of macro DMARK
b231						CALLMONITOR 
b231 cd 03 93			call break_point_state  
b234				endm  
# End of macro CALLMONITOR
b234					endif 
b234					FORTH_DSP 
b234 cd 4d 9a			call macro_forth_dsp 
b237				endm 
# End of macro FORTH_DSP
b237 7e					ld a,(hl)	; get type of value on TOS 
b238 fe 02				cp DS_TYPE_INUM  
b23a 28 00				jr z, .tz_inum 
b23c			 
b23c				if FORTH_ENABLE_FLOATMATH 
b23c					jr .tz_done 
b23c			 
b23c				endif 
b23c					 
b23c			 
b23c			.tz_inum: 
b23c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b23c cd 87 9a			call macro_dsp_valuehl 
b23f				endm 
# End of macro FORTH_DSP_VALUEHL
b23f			 
b23f			;		push hl 
b23f			 
b23f					; destroy value TOS 
b23f			 
b23f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b23f cd 3f 9b			call macro_forth_dsp_pop 
b242				endm 
# End of macro FORTH_DSP_POP
b242			 
b242			;		pop hl 
b242			 
b242 3e 00				ld a,0 
b244			 
b244 bd					cp l 
b245 20 08				jr nz, .tz_notzero 
b247			 
b247 bc					cp h 
b248			 
b248 20 05				jr nz, .tz_notzero 
b24a			 
b24a			 
b24a 21 01 00				ld hl, FORTH_TRUE 
b24d 18 03				jr .tz_done 
b24f			 
b24f 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b252			 
b252					; push value back onto stack for another op etc 
b252			 
b252			.tz_done: 
b252 cd 90 98				call forth_push_numhl 
b255			 
b255					NEXTW 
b255 c3 f9 9b			jp macro_next 
b258				endm 
# End of macro NEXTW
b258			.LESS: 
b258				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b258 2f				db WORD_SYS_CORE+27             
b259 c1 b2			dw .GT            
b25b 02				db 1 + 1 
b25c .. 00			db "<",0              
b25e				endm 
# End of macro CWHEAD
b25e			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b25e				; TODO add floating point number detection 
b25e					if DEBUG_FORTH_WORDS_KEY 
b25e						DMARK "LES" 
b25e f5				push af  
b25f 3a 73 b2			ld a, (.dmark)  
b262 32 7a ee			ld (debug_mark),a  
b265 3a 74 b2			ld a, (.dmark+1)  
b268 32 7b ee			ld (debug_mark+1),a  
b26b 3a 75 b2			ld a, (.dmark+2)  
b26e 32 7c ee			ld (debug_mark+2),a  
b271 18 03			jr .pastdmark  
b273 ..			.dmark: db "LES"  
b276 f1			.pastdmark: pop af  
b277			endm  
# End of macro DMARK
b277						CALLMONITOR 
b277 cd 03 93			call break_point_state  
b27a				endm  
# End of macro CALLMONITOR
b27a					endif 
b27a					FORTH_DSP 
b27a cd 4d 9a			call macro_forth_dsp 
b27d				endm 
# End of macro FORTH_DSP
b27d					;v5 FORTH_DSP_VALUE 
b27d 7e					ld a,(hl)	; get type of value on TOS 
b27e fe 02				cp DS_TYPE_INUM  
b280 28 00				jr z, .less_inum 
b282			 
b282				if FORTH_ENABLE_FLOATMATH 
b282					jr .less_done 
b282			 
b282				endif 
b282					 
b282			 
b282			.less_inum: 
b282					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b282 cd 87 9a			call macro_dsp_valuehl 
b285				endm 
# End of macro FORTH_DSP_VALUEHL
b285			 
b285 e5					push hl  ; u2 
b286			 
b286					; destroy value TOS 
b286			 
b286					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b286 cd 3f 9b			call macro_forth_dsp_pop 
b289				endm 
# End of macro FORTH_DSP_POP
b289			 
b289			 
b289					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b289 cd 87 9a			call macro_dsp_valuehl 
b28c				endm 
# End of macro FORTH_DSP_VALUEHL
b28c			 
b28c e5					push hl    ; u1 
b28d			 
b28d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b28d cd 3f 9b			call macro_forth_dsp_pop 
b290				endm 
# End of macro FORTH_DSP_POP
b290			 
b290			 
b290 b7			 or a      ;clear carry flag 
b291 01 00 00		 ld bc, FORTH_FALSE 
b294 e1			  pop hl    ; u1 
b295 d1			  pop de    ; u2 
b296 ed 52		  sbc hl,de 
b298 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b29a			 
b29a 01 01 00		 ld bc, FORTH_TRUE 
b29d			.lscont:  
b29d c5					push bc 
b29e e1					pop hl 
b29f			 
b29f					if DEBUG_FORTH_WORDS 
b29f						DMARK "LT1" 
b29f f5				push af  
b2a0 3a b4 b2			ld a, (.dmark)  
b2a3 32 7a ee			ld (debug_mark),a  
b2a6 3a b5 b2			ld a, (.dmark+1)  
b2a9 32 7b ee			ld (debug_mark+1),a  
b2ac 3a b6 b2			ld a, (.dmark+2)  
b2af 32 7c ee			ld (debug_mark+2),a  
b2b2 18 03			jr .pastdmark  
b2b4 ..			.dmark: db "LT1"  
b2b7 f1			.pastdmark: pop af  
b2b8			endm  
# End of macro DMARK
b2b8						CALLMONITOR 
b2b8 cd 03 93			call break_point_state  
b2bb				endm  
# End of macro CALLMONITOR
b2bb					endif 
b2bb cd 90 98				call forth_push_numhl 
b2be			 
b2be					NEXTW 
b2be c3 f9 9b			jp macro_next 
b2c1				endm 
# End of macro NEXTW
b2c1			.GT: 
b2c1				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b2c1 30				db WORD_SYS_CORE+28             
b2c2 2a b3			dw .EQUAL            
b2c4 02				db 1 + 1 
b2c5 .. 00			db ">",0              
b2c7				endm 
# End of macro CWHEAD
b2c7			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b2c7				; TODO add floating point number detection 
b2c7					if DEBUG_FORTH_WORDS_KEY 
b2c7						DMARK "GRT" 
b2c7 f5				push af  
b2c8 3a dc b2			ld a, (.dmark)  
b2cb 32 7a ee			ld (debug_mark),a  
b2ce 3a dd b2			ld a, (.dmark+1)  
b2d1 32 7b ee			ld (debug_mark+1),a  
b2d4 3a de b2			ld a, (.dmark+2)  
b2d7 32 7c ee			ld (debug_mark+2),a  
b2da 18 03			jr .pastdmark  
b2dc ..			.dmark: db "GRT"  
b2df f1			.pastdmark: pop af  
b2e0			endm  
# End of macro DMARK
b2e0						CALLMONITOR 
b2e0 cd 03 93			call break_point_state  
b2e3				endm  
# End of macro CALLMONITOR
b2e3					endif 
b2e3					FORTH_DSP 
b2e3 cd 4d 9a			call macro_forth_dsp 
b2e6				endm 
# End of macro FORTH_DSP
b2e6					;FORTH_DSP_VALUE 
b2e6 7e					ld a,(hl)	; get type of value on TOS 
b2e7 fe 02				cp DS_TYPE_INUM  
b2e9 28 00				jr z, .gt_inum 
b2eb			 
b2eb				if FORTH_ENABLE_FLOATMATH 
b2eb					jr .gt_done 
b2eb			 
b2eb				endif 
b2eb					 
b2eb			 
b2eb			.gt_inum: 
b2eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2eb cd 87 9a			call macro_dsp_valuehl 
b2ee				endm 
# End of macro FORTH_DSP_VALUEHL
b2ee			 
b2ee e5					push hl  ; u2 
b2ef			 
b2ef					; destroy value TOS 
b2ef			 
b2ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2ef cd 3f 9b			call macro_forth_dsp_pop 
b2f2				endm 
# End of macro FORTH_DSP_POP
b2f2			 
b2f2			 
b2f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2f2 cd 87 9a			call macro_dsp_valuehl 
b2f5				endm 
# End of macro FORTH_DSP_VALUEHL
b2f5			 
b2f5 e5					push hl    ; u1 
b2f6			 
b2f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2f6 cd 3f 9b			call macro_forth_dsp_pop 
b2f9				endm 
# End of macro FORTH_DSP_POP
b2f9			 
b2f9			 
b2f9 b7			 or a      ;clear carry flag 
b2fa 01 00 00		 ld bc, FORTH_FALSE 
b2fd e1			  pop hl    ; u1 
b2fe d1			  pop de    ; u2 
b2ff ed 52		  sbc hl,de 
b301 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b303			 
b303 01 01 00		 ld bc, FORTH_TRUE 
b306			.gtcont:  
b306 c5					push bc 
b307 e1					pop hl 
b308			 
b308					if DEBUG_FORTH_WORDS 
b308						DMARK "GT1" 
b308 f5				push af  
b309 3a 1d b3			ld a, (.dmark)  
b30c 32 7a ee			ld (debug_mark),a  
b30f 3a 1e b3			ld a, (.dmark+1)  
b312 32 7b ee			ld (debug_mark+1),a  
b315 3a 1f b3			ld a, (.dmark+2)  
b318 32 7c ee			ld (debug_mark+2),a  
b31b 18 03			jr .pastdmark  
b31d ..			.dmark: db "GT1"  
b320 f1			.pastdmark: pop af  
b321			endm  
# End of macro DMARK
b321						CALLMONITOR 
b321 cd 03 93			call break_point_state  
b324				endm  
# End of macro CALLMONITOR
b324					endif 
b324 cd 90 98				call forth_push_numhl 
b327			 
b327					NEXTW 
b327 c3 f9 9b			jp macro_next 
b32a				endm 
# End of macro NEXTW
b32a			.EQUAL: 
b32a				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b32a 31				db WORD_SYS_CORE+29             
b32b 95 b3			dw .ENDLOGIC            
b32d 02				db 1 + 1 
b32e .. 00			db "=",0              
b330				endm 
# End of macro CWHEAD
b330			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b330				; TODO add floating point number detection 
b330					if DEBUG_FORTH_WORDS_KEY 
b330						DMARK "EQ." 
b330 f5				push af  
b331 3a 45 b3			ld a, (.dmark)  
b334 32 7a ee			ld (debug_mark),a  
b337 3a 46 b3			ld a, (.dmark+1)  
b33a 32 7b ee			ld (debug_mark+1),a  
b33d 3a 47 b3			ld a, (.dmark+2)  
b340 32 7c ee			ld (debug_mark+2),a  
b343 18 03			jr .pastdmark  
b345 ..			.dmark: db "EQ."  
b348 f1			.pastdmark: pop af  
b349			endm  
# End of macro DMARK
b349						CALLMONITOR 
b349 cd 03 93			call break_point_state  
b34c				endm  
# End of macro CALLMONITOR
b34c					endif 
b34c					FORTH_DSP 
b34c cd 4d 9a			call macro_forth_dsp 
b34f				endm 
# End of macro FORTH_DSP
b34f					;v5 FORTH_DSP_VALUE 
b34f 7e					ld a,(hl)	; get type of value on TOS 
b350 fe 02				cp DS_TYPE_INUM  
b352 28 00				jr z, .eq_inum 
b354			 
b354				if FORTH_ENABLE_FLOATMATH 
b354					jr .eq_done 
b354			 
b354				endif 
b354					 
b354			 
b354			.eq_inum: 
b354					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b354 cd 87 9a			call macro_dsp_valuehl 
b357				endm 
# End of macro FORTH_DSP_VALUEHL
b357			 
b357 e5					push hl 
b358			 
b358					; destroy value TOS 
b358			 
b358					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b358 cd 3f 9b			call macro_forth_dsp_pop 
b35b				endm 
# End of macro FORTH_DSP_POP
b35b			 
b35b			 
b35b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b35b cd 87 9a			call macro_dsp_valuehl 
b35e				endm 
# End of macro FORTH_DSP_VALUEHL
b35e			 
b35e					; one value on hl get other one back 
b35e			 
b35e e5					push hl 
b35f			 
b35f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b35f cd 3f 9b			call macro_forth_dsp_pop 
b362				endm 
# End of macro FORTH_DSP_POP
b362			 
b362 0e 00				ld c, FORTH_FALSE 
b364			 
b364 e1					pop hl 
b365 d1					pop de 
b366			 
b366 7b					ld a, e 
b367 bd					cp l 
b368			 
b368 20 06				jr nz, .eq_done 
b36a			 
b36a 7a					ld a, d 
b36b bc					cp h 
b36c			 
b36c 20 02				jr nz, .eq_done 
b36e			 
b36e 0e 01				ld c, FORTH_TRUE 
b370					 
b370			 
b370			 
b370			.eq_done: 
b370			 
b370					; TODO push value back onto stack for another op etc 
b370			 
b370 26 00				ld h, 0 
b372 69					ld l, c 
b373					if DEBUG_FORTH_WORDS 
b373						DMARK "EQ1" 
b373 f5				push af  
b374 3a 88 b3			ld a, (.dmark)  
b377 32 7a ee			ld (debug_mark),a  
b37a 3a 89 b3			ld a, (.dmark+1)  
b37d 32 7b ee			ld (debug_mark+1),a  
b380 3a 8a b3			ld a, (.dmark+2)  
b383 32 7c ee			ld (debug_mark+2),a  
b386 18 03			jr .pastdmark  
b388 ..			.dmark: db "EQ1"  
b38b f1			.pastdmark: pop af  
b38c			endm  
# End of macro DMARK
b38c						CALLMONITOR 
b38c cd 03 93			call break_point_state  
b38f				endm  
# End of macro CALLMONITOR
b38f					endif 
b38f cd 90 98				call forth_push_numhl 
b392			 
b392					NEXTW 
b392 c3 f9 9b			jp macro_next 
b395				endm 
# End of macro NEXTW
b395			 
b395			 
b395			.ENDLOGIC: 
b395			; eof 
b395			 
b395			 
# End of file forth_words_logic.asm
b395			include "forth_words_maths.asm" 
b395			 
b395			; | ## Maths Words 
b395			 
b395			.PLUS:	 
b395				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b395 15				db WORD_SYS_CORE+1             
b396 d7 b3			dw .NEG            
b398 02				db 1 + 1 
b399 .. 00			db "+",0              
b39b				endm 
# End of macro CWHEAD
b39b			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b39b					if DEBUG_FORTH_WORDS_KEY 
b39b						DMARK "PLU" 
b39b f5				push af  
b39c 3a b0 b3			ld a, (.dmark)  
b39f 32 7a ee			ld (debug_mark),a  
b3a2 3a b1 b3			ld a, (.dmark+1)  
b3a5 32 7b ee			ld (debug_mark+1),a  
b3a8 3a b2 b3			ld a, (.dmark+2)  
b3ab 32 7c ee			ld (debug_mark+2),a  
b3ae 18 03			jr .pastdmark  
b3b0 ..			.dmark: db "PLU"  
b3b3 f1			.pastdmark: pop af  
b3b4			endm  
# End of macro DMARK
b3b4						CALLMONITOR 
b3b4 cd 03 93			call break_point_state  
b3b7				endm  
# End of macro CALLMONITOR
b3b7					endif 
b3b7					; add top two values and push back result 
b3b7			 
b3b7					;for v5 FORTH_DSP_VALUE 
b3b7					FORTH_DSP 
b3b7 cd 4d 9a			call macro_forth_dsp 
b3ba				endm 
# End of macro FORTH_DSP
b3ba 7e					ld a,(hl)	; get type of value on TOS 
b3bb fe 02				cp DS_TYPE_INUM  
b3bd 28 03				jr z, .dot_inum 
b3bf			 
b3bf					NEXTW 
b3bf c3 f9 9b			jp macro_next 
b3c2				endm 
# End of macro NEXTW
b3c2			 
b3c2			; float maths 
b3c2			 
b3c2				if FORTH_ENABLE_FLOATMATH 
b3c2						inc hl      ; now at start of numeric as string 
b3c2			 
b3c2					if DEBUG_FORTH_MATHS 
b3c2						DMARK "ADD" 
b3c2				CALLMONITOR 
b3c2					endif 
b3c2			 
b3c2					;ld ix, hl 
b3c2					call CON 
b3c2			 
b3c2			 
b3c2					push hl 
b3c2					 
b3c2					 
b3c2			 
b3c2						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b3c2			 
b3c2					; get next number 
b3c2			 
b3c2						FORTH_DSP_VALUE 
b3c2			 
b3c2						inc hl      ; now at start of numeric as string 
b3c2			 
b3c2					;ld ix, hl 
b3c2					call CON 
b3c2			 
b3c2					push hl 
b3c2			 
b3c2			 
b3c2						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3c2			 
b3c2						; TODO do add 
b3c2			 
b3c2						call IADD 
b3c2			 
b3c2						; TODO get result back as ascii 
b3c2			 
b3c2						; TODO push result  
b3c2			 
b3c2			 
b3c2			 
b3c2						jr .dot_done 
b3c2				endif 
b3c2			 
b3c2			.dot_inum: 
b3c2			 
b3c2			 
b3c2					if DEBUG_FORTH_DOT 
b3c2						DMARK "+IT" 
b3c2				CALLMONITOR 
b3c2					endif 
b3c2			 
b3c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3c2 cd 87 9a			call macro_dsp_valuehl 
b3c5				endm 
# End of macro FORTH_DSP_VALUEHL
b3c5			 
b3c5				; TODO add floating point number detection 
b3c5			 
b3c5 e5					push hl 
b3c6			 
b3c6					; destroy value TOS 
b3c6			 
b3c6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3c6 cd 3f 9b			call macro_forth_dsp_pop 
b3c9				endm 
# End of macro FORTH_DSP_POP
b3c9			 
b3c9			 
b3c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3c9 cd 87 9a			call macro_dsp_valuehl 
b3cc				endm 
# End of macro FORTH_DSP_VALUEHL
b3cc			 
b3cc					; one value on hl get other one back 
b3cc			 
b3cc d1					pop de 
b3cd			 
b3cd					; do the add 
b3cd			 
b3cd 19					add hl,de 
b3ce			 
b3ce					; save it 
b3ce			 
b3ce			;		push hl	 
b3ce			 
b3ce					; 
b3ce			 
b3ce					; destroy value TOS 
b3ce			 
b3ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3ce cd 3f 9b			call macro_forth_dsp_pop 
b3d1				endm 
# End of macro FORTH_DSP_POP
b3d1			 
b3d1					; TODO push value back onto stack for another op etc 
b3d1			 
b3d1			;		pop hl 
b3d1			 
b3d1			.dot_done: 
b3d1 cd 90 98				call forth_push_numhl 
b3d4			 
b3d4					NEXTW 
b3d4 c3 f9 9b			jp macro_next 
b3d7				endm 
# End of macro NEXTW
b3d7			.NEG: 
b3d7			 
b3d7				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b3d7 17				db WORD_SYS_CORE+3             
b3d8 1a b4			dw .DIV            
b3da 02				db 1 + 1 
b3db .. 00			db "-",0              
b3dd				endm 
# End of macro CWHEAD
b3dd			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b3dd					if DEBUG_FORTH_WORDS_KEY 
b3dd						DMARK "SUB" 
b3dd f5				push af  
b3de 3a f2 b3			ld a, (.dmark)  
b3e1 32 7a ee			ld (debug_mark),a  
b3e4 3a f3 b3			ld a, (.dmark+1)  
b3e7 32 7b ee			ld (debug_mark+1),a  
b3ea 3a f4 b3			ld a, (.dmark+2)  
b3ed 32 7c ee			ld (debug_mark+2),a  
b3f0 18 03			jr .pastdmark  
b3f2 ..			.dmark: db "SUB"  
b3f5 f1			.pastdmark: pop af  
b3f6			endm  
# End of macro DMARK
b3f6						CALLMONITOR 
b3f6 cd 03 93			call break_point_state  
b3f9				endm  
# End of macro CALLMONITOR
b3f9					endif 
b3f9			 
b3f9			 
b3f9				; TODO add floating point number detection 
b3f9					; v5 FORTH_DSP_VALUE 
b3f9					FORTH_DSP 
b3f9 cd 4d 9a			call macro_forth_dsp 
b3fc				endm 
# End of macro FORTH_DSP
b3fc 7e					ld a,(hl)	; get type of value on TOS 
b3fd fe 02				cp DS_TYPE_INUM  
b3ff 28 03				jr z, .neg_inum 
b401			 
b401					NEXTW 
b401 c3 f9 9b			jp macro_next 
b404				endm 
# End of macro NEXTW
b404			 
b404			; float maths 
b404			 
b404				if FORTH_ENABLE_FLOATMATH 
b404					jr .neg_done 
b404			 
b404				endif 
b404					 
b404			 
b404			.neg_inum: 
b404					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b404 cd 87 9a			call macro_dsp_valuehl 
b407				endm 
# End of macro FORTH_DSP_VALUEHL
b407			 
b407 e5					push hl 
b408			 
b408					; destroy value TOS 
b408			 
b408					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b408 cd 3f 9b			call macro_forth_dsp_pop 
b40b				endm 
# End of macro FORTH_DSP_POP
b40b			 
b40b			 
b40b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b40b cd 87 9a			call macro_dsp_valuehl 
b40e				endm 
# End of macro FORTH_DSP_VALUEHL
b40e			 
b40e					; one value on hl get other one back 
b40e			 
b40e d1					pop de 
b40f			 
b40f					; do the sub 
b40f			;		ex de, hl 
b40f			 
b40f ed 52				sbc hl,de 
b411			 
b411					; save it 
b411			 
b411			;		push hl	 
b411			 
b411					; 
b411			 
b411					; destroy value TOS 
b411			 
b411					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b411 cd 3f 9b			call macro_forth_dsp_pop 
b414				endm 
# End of macro FORTH_DSP_POP
b414			 
b414					; TODO push value back onto stack for another op etc 
b414			 
b414			;		pop hl 
b414			 
b414 cd 90 98				call forth_push_numhl 
b417			.neg_done: 
b417			 
b417					NEXTW 
b417 c3 f9 9b			jp macro_next 
b41a				endm 
# End of macro NEXTW
b41a			.DIV: 
b41a				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b41a 18				db WORD_SYS_CORE+4             
b41b 67 b4			dw .MUL            
b41d 02				db 1 + 1 
b41e .. 00			db "/",0              
b420				endm 
# End of macro CWHEAD
b420			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b420					if DEBUG_FORTH_WORDS_KEY 
b420						DMARK "DIV" 
b420 f5				push af  
b421 3a 35 b4			ld a, (.dmark)  
b424 32 7a ee			ld (debug_mark),a  
b427 3a 36 b4			ld a, (.dmark+1)  
b42a 32 7b ee			ld (debug_mark+1),a  
b42d 3a 37 b4			ld a, (.dmark+2)  
b430 32 7c ee			ld (debug_mark+2),a  
b433 18 03			jr .pastdmark  
b435 ..			.dmark: db "DIV"  
b438 f1			.pastdmark: pop af  
b439			endm  
# End of macro DMARK
b439						CALLMONITOR 
b439 cd 03 93			call break_point_state  
b43c				endm  
# End of macro CALLMONITOR
b43c					endif 
b43c				; TODO add floating point number detection 
b43c					; v5 FORTH_DSP_VALUE 
b43c					FORTH_DSP 
b43c cd 4d 9a			call macro_forth_dsp 
b43f				endm 
# End of macro FORTH_DSP
b43f 7e					ld a,(hl)	; get type of value on TOS 
b440 fe 02				cp DS_TYPE_INUM  
b442 28 03				jr z, .div_inum 
b444			 
b444				if FORTH_ENABLE_FLOATMATH 
b444					jr .div_done 
b444			 
b444				endif 
b444					NEXTW 
b444 c3 f9 9b			jp macro_next 
b447				endm 
# End of macro NEXTW
b447			.div_inum: 
b447			 
b447					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b447 cd 87 9a			call macro_dsp_valuehl 
b44a				endm 
# End of macro FORTH_DSP_VALUEHL
b44a			 
b44a e5					push hl    ; to go to bc 
b44b			 
b44b					; destroy value TOS 
b44b			 
b44b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b44b cd 3f 9b			call macro_forth_dsp_pop 
b44e				endm 
# End of macro FORTH_DSP_POP
b44e			 
b44e			 
b44e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b44e cd 87 9a			call macro_dsp_valuehl 
b451				endm 
# End of macro FORTH_DSP_VALUEHL
b451			 
b451					; hl to go to de 
b451			 
b451 e5					push hl 
b452			 
b452 c1					pop bc 
b453 d1					pop de		 
b454			 
b454			 
b454					if DEBUG_FORTH_MATHS 
b454						DMARK "DIV" 
b454				CALLMONITOR 
b454					endif 
b454					; one value on hl but move to a get other one back 
b454			 
b454			        
b454 cd 04 8a			call Div16 
b457			 
b457			;	push af	 
b457 e5				push hl 
b458 c5				push bc 
b459			 
b459					if DEBUG_FORTH_MATHS 
b459						DMARK "DI1" 
b459				CALLMONITOR 
b459					endif 
b459			 
b459					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b459 cd 3f 9b			call macro_forth_dsp_pop 
b45c				endm 
# End of macro FORTH_DSP_POP
b45c			 
b45c			 
b45c			 
b45c e1					pop hl    ; result 
b45d			 
b45d cd 90 98				call forth_push_numhl 
b460			 
b460 e1					pop hl    ; reminder 
b461			;		ld h,0 
b461			;		ld l,d 
b461			 
b461 cd 90 98				call forth_push_numhl 
b464			.div_done: 
b464					NEXTW 
b464 c3 f9 9b			jp macro_next 
b467				endm 
# End of macro NEXTW
b467			.MUL: 
b467				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b467 19				db WORD_SYS_CORE+5             
b468 ac b4			dw .MIN            
b46a 02				db 1 + 1 
b46b .. 00			db "*",0              
b46d				endm 
# End of macro CWHEAD
b46d			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b46d				; TODO add floating point number detection 
b46d					if DEBUG_FORTH_WORDS_KEY 
b46d						DMARK "MUL" 
b46d f5				push af  
b46e 3a 82 b4			ld a, (.dmark)  
b471 32 7a ee			ld (debug_mark),a  
b474 3a 83 b4			ld a, (.dmark+1)  
b477 32 7b ee			ld (debug_mark+1),a  
b47a 3a 84 b4			ld a, (.dmark+2)  
b47d 32 7c ee			ld (debug_mark+2),a  
b480 18 03			jr .pastdmark  
b482 ..			.dmark: db "MUL"  
b485 f1			.pastdmark: pop af  
b486			endm  
# End of macro DMARK
b486						CALLMONITOR 
b486 cd 03 93			call break_point_state  
b489				endm  
# End of macro CALLMONITOR
b489					endif 
b489					FORTH_DSP 
b489 cd 4d 9a			call macro_forth_dsp 
b48c				endm 
# End of macro FORTH_DSP
b48c					; v5 FORTH_DSP_VALUE 
b48c 7e					ld a,(hl)	; get type of value on TOS 
b48d fe 02				cp DS_TYPE_INUM  
b48f 28 03				jr z, .mul_inum 
b491			 
b491				if FORTH_ENABLE_FLOATMATH 
b491					jr .mul_done 
b491			 
b491				endif 
b491			 
b491					NEXTW 
b491 c3 f9 9b			jp macro_next 
b494				endm 
# End of macro NEXTW
b494			.mul_inum:	 
b494			 
b494					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b494 cd 87 9a			call macro_dsp_valuehl 
b497				endm 
# End of macro FORTH_DSP_VALUEHL
b497			 
b497 e5					push hl 
b498			 
b498					; destroy value TOS 
b498			 
b498					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b498 cd 3f 9b			call macro_forth_dsp_pop 
b49b				endm 
# End of macro FORTH_DSP_POP
b49b			 
b49b			 
b49b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b49b cd 87 9a			call macro_dsp_valuehl 
b49e				endm 
# End of macro FORTH_DSP_VALUEHL
b49e			 
b49e					; one value on hl but move to a get other one back 
b49e			 
b49e 7d					ld a, l 
b49f			 
b49f d1					pop de 
b4a0			 
b4a0					; do the mull 
b4a0			;		ex de, hl 
b4a0			 
b4a0 cd 2a 8a				call Mult16 
b4a3					; save it 
b4a3			 
b4a3			;		push hl	 
b4a3			 
b4a3					; 
b4a3			 
b4a3					; destroy value TOS 
b4a3			 
b4a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4a3 cd 3f 9b			call macro_forth_dsp_pop 
b4a6				endm 
# End of macro FORTH_DSP_POP
b4a6			 
b4a6					; TODO push value back onto stack for another op etc 
b4a6			 
b4a6			;		pop hl 
b4a6			 
b4a6 cd 90 98				call forth_push_numhl 
b4a9			 
b4a9			.mul_done: 
b4a9					NEXTW 
b4a9 c3 f9 9b			jp macro_next 
b4ac				endm 
# End of macro NEXTW
b4ac			 
b4ac			 
b4ac			 
b4ac			 
b4ac			.MIN: 
b4ac				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b4ac 49				db WORD_SYS_CORE+53             
b4ad 2d b5			dw .MAX            
b4af 04				db 3 + 1 
b4b0 .. 00			db "MIN",0              
b4b4				endm 
# End of macro CWHEAD
b4b4			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b4b4					if DEBUG_FORTH_WORDS_KEY 
b4b4						DMARK "MIN" 
b4b4 f5				push af  
b4b5 3a c9 b4			ld a, (.dmark)  
b4b8 32 7a ee			ld (debug_mark),a  
b4bb 3a ca b4			ld a, (.dmark+1)  
b4be 32 7b ee			ld (debug_mark+1),a  
b4c1 3a cb b4			ld a, (.dmark+2)  
b4c4 32 7c ee			ld (debug_mark+2),a  
b4c7 18 03			jr .pastdmark  
b4c9 ..			.dmark: db "MIN"  
b4cc f1			.pastdmark: pop af  
b4cd			endm  
# End of macro DMARK
b4cd						CALLMONITOR 
b4cd cd 03 93			call break_point_state  
b4d0				endm  
# End of macro CALLMONITOR
b4d0					endif 
b4d0					; get u2 
b4d0			 
b4d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4d0 cd 87 9a			call macro_dsp_valuehl 
b4d3				endm 
# End of macro FORTH_DSP_VALUEHL
b4d3			 
b4d3 e5					push hl   ; u2 
b4d4			 
b4d4					; destroy value TOS 
b4d4			 
b4d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4d4 cd 3f 9b			call macro_forth_dsp_pop 
b4d7				endm 
# End of macro FORTH_DSP_POP
b4d7			 
b4d7					; get u1 
b4d7			 
b4d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b4d7 cd 87 9a			call macro_dsp_valuehl 
b4da				endm 
# End of macro FORTH_DSP_VALUEHL
b4da			 
b4da e5					push hl  ; u1 
b4db			 
b4db					; destroy value TOS 
b4db			 
b4db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b4db cd 3f 9b			call macro_forth_dsp_pop 
b4de				endm 
# End of macro FORTH_DSP_POP
b4de			 
b4de b7			 or a      ;clear carry flag 
b4df e1			  pop hl    ; u1 
b4e0 d1			  pop de    ; u2 
b4e1 e5				push hl   ; saved in case hl is lowest 
b4e2 ed 52		  sbc hl,de 
b4e4 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b4e6			 
b4e6 e1				pop hl 
b4e7					if DEBUG_FORTH_WORDS 
b4e7						DMARK "MIN" 
b4e7 f5				push af  
b4e8 3a fc b4			ld a, (.dmark)  
b4eb 32 7a ee			ld (debug_mark),a  
b4ee 3a fd b4			ld a, (.dmark+1)  
b4f1 32 7b ee			ld (debug_mark+1),a  
b4f4 3a fe b4			ld a, (.dmark+2)  
b4f7 32 7c ee			ld (debug_mark+2),a  
b4fa 18 03			jr .pastdmark  
b4fc ..			.dmark: db "MIN"  
b4ff f1			.pastdmark: pop af  
b500			endm  
# End of macro DMARK
b500						CALLMONITOR 
b500 cd 03 93			call break_point_state  
b503				endm  
# End of macro CALLMONITOR
b503					endif 
b503 cd 90 98				call forth_push_numhl 
b506			 
b506				       NEXTW 
b506 c3 f9 9b			jp macro_next 
b509				endm 
# End of macro NEXTW
b509			 
b509			.mincont:  
b509 c1				pop bc   ; tidy up 
b50a eb				ex de , hl  
b50b					if DEBUG_FORTH_WORDS 
b50b						DMARK "MI1" 
b50b f5				push af  
b50c 3a 20 b5			ld a, (.dmark)  
b50f 32 7a ee			ld (debug_mark),a  
b512 3a 21 b5			ld a, (.dmark+1)  
b515 32 7b ee			ld (debug_mark+1),a  
b518 3a 22 b5			ld a, (.dmark+2)  
b51b 32 7c ee			ld (debug_mark+2),a  
b51e 18 03			jr .pastdmark  
b520 ..			.dmark: db "MI1"  
b523 f1			.pastdmark: pop af  
b524			endm  
# End of macro DMARK
b524						CALLMONITOR 
b524 cd 03 93			call break_point_state  
b527				endm  
# End of macro CALLMONITOR
b527					endif 
b527 cd 90 98				call forth_push_numhl 
b52a			 
b52a				       NEXTW 
b52a c3 f9 9b			jp macro_next 
b52d				endm 
# End of macro NEXTW
b52d			.MAX: 
b52d				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b52d 4a				db WORD_SYS_CORE+54             
b52e ae b5			dw .RND16            
b530 04				db 3 + 1 
b531 .. 00			db "MAX",0              
b535				endm 
# End of macro CWHEAD
b535			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b535					if DEBUG_FORTH_WORDS_KEY 
b535						DMARK "MAX" 
b535 f5				push af  
b536 3a 4a b5			ld a, (.dmark)  
b539 32 7a ee			ld (debug_mark),a  
b53c 3a 4b b5			ld a, (.dmark+1)  
b53f 32 7b ee			ld (debug_mark+1),a  
b542 3a 4c b5			ld a, (.dmark+2)  
b545 32 7c ee			ld (debug_mark+2),a  
b548 18 03			jr .pastdmark  
b54a ..			.dmark: db "MAX"  
b54d f1			.pastdmark: pop af  
b54e			endm  
# End of macro DMARK
b54e						CALLMONITOR 
b54e cd 03 93			call break_point_state  
b551				endm  
# End of macro CALLMONITOR
b551					endif 
b551					; get u2 
b551			 
b551					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b551 cd 87 9a			call macro_dsp_valuehl 
b554				endm 
# End of macro FORTH_DSP_VALUEHL
b554			 
b554 e5					push hl   ; u2 
b555			 
b555					; destroy value TOS 
b555			 
b555					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b555 cd 3f 9b			call macro_forth_dsp_pop 
b558				endm 
# End of macro FORTH_DSP_POP
b558			 
b558					; get u1 
b558			 
b558					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b558 cd 87 9a			call macro_dsp_valuehl 
b55b				endm 
# End of macro FORTH_DSP_VALUEHL
b55b			 
b55b e5					push hl  ; u1 
b55c			 
b55c					; destroy value TOS 
b55c			 
b55c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b55c cd 3f 9b			call macro_forth_dsp_pop 
b55f				endm 
# End of macro FORTH_DSP_POP
b55f			 
b55f b7			 or a      ;clear carry flag 
b560 e1			  pop hl    ; u1 
b561 d1			  pop de    ; u2 
b562 e5				push hl   ; saved in case hl is lowest 
b563 ed 52		  sbc hl,de 
b565 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b567			 
b567 e1				pop hl 
b568					if DEBUG_FORTH_WORDS 
b568						DMARK "MAX" 
b568 f5				push af  
b569 3a 7d b5			ld a, (.dmark)  
b56c 32 7a ee			ld (debug_mark),a  
b56f 3a 7e b5			ld a, (.dmark+1)  
b572 32 7b ee			ld (debug_mark+1),a  
b575 3a 7f b5			ld a, (.dmark+2)  
b578 32 7c ee			ld (debug_mark+2),a  
b57b 18 03			jr .pastdmark  
b57d ..			.dmark: db "MAX"  
b580 f1			.pastdmark: pop af  
b581			endm  
# End of macro DMARK
b581						CALLMONITOR 
b581 cd 03 93			call break_point_state  
b584				endm  
# End of macro CALLMONITOR
b584					endif 
b584 cd 90 98				call forth_push_numhl 
b587			 
b587				       NEXTW 
b587 c3 f9 9b			jp macro_next 
b58a				endm 
# End of macro NEXTW
b58a			 
b58a			.maxcont:  
b58a c1				pop bc   ; tidy up 
b58b eb				ex de , hl  
b58c					if DEBUG_FORTH_WORDS 
b58c						DMARK "MA1" 
b58c f5				push af  
b58d 3a a1 b5			ld a, (.dmark)  
b590 32 7a ee			ld (debug_mark),a  
b593 3a a2 b5			ld a, (.dmark+1)  
b596 32 7b ee			ld (debug_mark+1),a  
b599 3a a3 b5			ld a, (.dmark+2)  
b59c 32 7c ee			ld (debug_mark+2),a  
b59f 18 03			jr .pastdmark  
b5a1 ..			.dmark: db "MA1"  
b5a4 f1			.pastdmark: pop af  
b5a5			endm  
# End of macro DMARK
b5a5						CALLMONITOR 
b5a5 cd 03 93			call break_point_state  
b5a8				endm  
# End of macro CALLMONITOR
b5a8					endif 
b5a8 cd 90 98				call forth_push_numhl 
b5ab				       NEXTW 
b5ab c3 f9 9b			jp macro_next 
b5ae				endm 
# End of macro NEXTW
b5ae			 
b5ae			.RND16: 
b5ae				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b5ae 4e				db WORD_SYS_CORE+58             
b5af dd b5			dw .RND8            
b5b1 06				db 5 + 1 
b5b2 .. 00			db "RND16",0              
b5b8				endm 
# End of macro CWHEAD
b5b8			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b5b8					if DEBUG_FORTH_WORDS_KEY 
b5b8						DMARK "R16" 
b5b8 f5				push af  
b5b9 3a cd b5			ld a, (.dmark)  
b5bc 32 7a ee			ld (debug_mark),a  
b5bf 3a ce b5			ld a, (.dmark+1)  
b5c2 32 7b ee			ld (debug_mark+1),a  
b5c5 3a cf b5			ld a, (.dmark+2)  
b5c8 32 7c ee			ld (debug_mark+2),a  
b5cb 18 03			jr .pastdmark  
b5cd ..			.dmark: db "R16"  
b5d0 f1			.pastdmark: pop af  
b5d1			endm  
# End of macro DMARK
b5d1						CALLMONITOR 
b5d1 cd 03 93			call break_point_state  
b5d4				endm  
# End of macro CALLMONITOR
b5d4					endif 
b5d4 cd ce 89				call prng16  
b5d7 cd 90 98				call forth_push_numhl 
b5da				       NEXTW 
b5da c3 f9 9b			jp macro_next 
b5dd				endm 
# End of macro NEXTW
b5dd			.RND8: 
b5dd				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b5dd 60				db WORD_SYS_CORE+76             
b5de 12 b6			dw .RND            
b5e0 05				db 4 + 1 
b5e1 .. 00			db "RND8",0              
b5e6				endm 
# End of macro CWHEAD
b5e6			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b5e6					if DEBUG_FORTH_WORDS_KEY 
b5e6						DMARK "RN8" 
b5e6 f5				push af  
b5e7 3a fb b5			ld a, (.dmark)  
b5ea 32 7a ee			ld (debug_mark),a  
b5ed 3a fc b5			ld a, (.dmark+1)  
b5f0 32 7b ee			ld (debug_mark+1),a  
b5f3 3a fd b5			ld a, (.dmark+2)  
b5f6 32 7c ee			ld (debug_mark+2),a  
b5f9 18 03			jr .pastdmark  
b5fb ..			.dmark: db "RN8"  
b5fe f1			.pastdmark: pop af  
b5ff			endm  
# End of macro DMARK
b5ff						CALLMONITOR 
b5ff cd 03 93			call break_point_state  
b602				endm  
# End of macro CALLMONITOR
b602					endif 
b602 2a bb eb				ld hl,(xrandc) 
b605 23					inc hl 
b606 cd e8 89				call xrnd 
b609 6f					ld l,a	 
b60a 26 00				ld h,0 
b60c cd 90 98				call forth_push_numhl 
b60f				       NEXTW 
b60f c3 f9 9b			jp macro_next 
b612				endm 
# End of macro NEXTW
b612			.RND: 
b612				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b612 60				db WORD_SYS_CORE+76             
b613 18 b7			dw .ENDMATHS            
b615 04				db 3 + 1 
b616 .. 00			db "RND",0              
b61a				endm 
# End of macro CWHEAD
b61a			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b61a			 
b61a					if DEBUG_FORTH_WORDS_KEY 
b61a						DMARK "RND" 
b61a f5				push af  
b61b 3a 2f b6			ld a, (.dmark)  
b61e 32 7a ee			ld (debug_mark),a  
b621 3a 30 b6			ld a, (.dmark+1)  
b624 32 7b ee			ld (debug_mark+1),a  
b627 3a 31 b6			ld a, (.dmark+2)  
b62a 32 7c ee			ld (debug_mark+2),a  
b62d 18 03			jr .pastdmark  
b62f ..			.dmark: db "RND"  
b632 f1			.pastdmark: pop af  
b633			endm  
# End of macro DMARK
b633						CALLMONITOR 
b633 cd 03 93			call break_point_state  
b636				endm  
# End of macro CALLMONITOR
b636					endif 
b636					 
b636					FORTH_DSP_VALUEHL    ; upper range 
b636 cd 87 9a			call macro_dsp_valuehl 
b639				endm 
# End of macro FORTH_DSP_VALUEHL
b639			 
b639 22 bf eb				ld (LFSRSeed), hl	 
b63c			 
b63c					if DEBUG_FORTH_WORDS 
b63c						DMARK "RN1" 
b63c f5				push af  
b63d 3a 51 b6			ld a, (.dmark)  
b640 32 7a ee			ld (debug_mark),a  
b643 3a 52 b6			ld a, (.dmark+1)  
b646 32 7b ee			ld (debug_mark+1),a  
b649 3a 53 b6			ld a, (.dmark+2)  
b64c 32 7c ee			ld (debug_mark+2),a  
b64f 18 03			jr .pastdmark  
b651 ..			.dmark: db "RN1"  
b654 f1			.pastdmark: pop af  
b655			endm  
# End of macro DMARK
b655						CALLMONITOR 
b655 cd 03 93			call break_point_state  
b658				endm  
# End of macro CALLMONITOR
b658					endif 
b658					FORTH_DSP_POP 
b658 cd 3f 9b			call macro_forth_dsp_pop 
b65b				endm 
# End of macro FORTH_DSP_POP
b65b			 
b65b					FORTH_DSP_VALUEHL    ; low range 
b65b cd 87 9a			call macro_dsp_valuehl 
b65e				endm 
# End of macro FORTH_DSP_VALUEHL
b65e			 
b65e					if DEBUG_FORTH_WORDS 
b65e						DMARK "RN2" 
b65e f5				push af  
b65f 3a 73 b6			ld a, (.dmark)  
b662 32 7a ee			ld (debug_mark),a  
b665 3a 74 b6			ld a, (.dmark+1)  
b668 32 7b ee			ld (debug_mark+1),a  
b66b 3a 75 b6			ld a, (.dmark+2)  
b66e 32 7c ee			ld (debug_mark+2),a  
b671 18 03			jr .pastdmark  
b673 ..			.dmark: db "RN2"  
b676 f1			.pastdmark: pop af  
b677			endm  
# End of macro DMARK
b677						CALLMONITOR 
b677 cd 03 93			call break_point_state  
b67a				endm  
# End of macro CALLMONITOR
b67a					endif 
b67a 22 c1 eb				ld (LFSRSeed+2), hl 
b67d			 
b67d					FORTH_DSP_POP 
b67d cd 3f 9b			call macro_forth_dsp_pop 
b680				endm 
# End of macro FORTH_DSP_POP
b680			 
b680 e5					push hl 
b681			 
b681 e1			.inrange:	pop hl 
b682 cd ce 89				call prng16  
b685					if DEBUG_FORTH_WORDS 
b685						DMARK "RN3" 
b685 f5				push af  
b686 3a 9a b6			ld a, (.dmark)  
b689 32 7a ee			ld (debug_mark),a  
b68c 3a 9b b6			ld a, (.dmark+1)  
b68f 32 7b ee			ld (debug_mark+1),a  
b692 3a 9c b6			ld a, (.dmark+2)  
b695 32 7c ee			ld (debug_mark+2),a  
b698 18 03			jr .pastdmark  
b69a ..			.dmark: db "RN3"  
b69d f1			.pastdmark: pop af  
b69e			endm  
# End of macro DMARK
b69e						CALLMONITOR 
b69e cd 03 93			call break_point_state  
b6a1				endm  
# End of macro CALLMONITOR
b6a1					endif 
b6a1					 
b6a1					; if the range is 8bit knock out the high byte 
b6a1			 
b6a1 ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
b6a5			 
b6a5 3e 00				ld a, 0 
b6a7 ba					cp d  
b6a8 20 1e				jr nz, .hirange 
b6aa 26 00				ld h, 0   ; knock it down to 8bit 
b6ac			 
b6ac					if DEBUG_FORTH_WORDS 
b6ac						DMARK "RNk" 
b6ac f5				push af  
b6ad 3a c1 b6			ld a, (.dmark)  
b6b0 32 7a ee			ld (debug_mark),a  
b6b3 3a c2 b6			ld a, (.dmark+1)  
b6b6 32 7b ee			ld (debug_mark+1),a  
b6b9 3a c3 b6			ld a, (.dmark+2)  
b6bc 32 7c ee			ld (debug_mark+2),a  
b6bf 18 03			jr .pastdmark  
b6c1 ..			.dmark: db "RNk"  
b6c4 f1			.pastdmark: pop af  
b6c5			endm  
# End of macro DMARK
b6c5						CALLMONITOR 
b6c5 cd 03 93			call break_point_state  
b6c8				endm  
# End of macro CALLMONITOR
b6c8					endif 
b6c8			.hirange:   
b6c8 e5					push hl  
b6c9 b7					or a  
b6ca ed 52		                sbc hl, de 
b6cc			 
b6cc					;call cmp16 
b6cc			 
b6cc 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b6ce e1					pop hl 
b6cf e5					push hl 
b6d0			 
b6d0					if DEBUG_FORTH_WORDS 
b6d0						DMARK "RN4" 
b6d0 f5				push af  
b6d1 3a e5 b6			ld a, (.dmark)  
b6d4 32 7a ee			ld (debug_mark),a  
b6d7 3a e6 b6			ld a, (.dmark+1)  
b6da 32 7b ee			ld (debug_mark+1),a  
b6dd 3a e7 b6			ld a, (.dmark+2)  
b6e0 32 7c ee			ld (debug_mark+2),a  
b6e3 18 03			jr .pastdmark  
b6e5 ..			.dmark: db "RN4"  
b6e8 f1			.pastdmark: pop af  
b6e9			endm  
# End of macro DMARK
b6e9						CALLMONITOR 
b6e9 cd 03 93			call break_point_state  
b6ec				endm  
# End of macro CALLMONITOR
b6ec					endif 
b6ec ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
b6f0					;call cmp16 
b6f0				 
b6f0 b7					or a  
b6f1 ed 52		                sbc hl, de 
b6f3 38 8c				jr c, .inrange 
b6f5			 
b6f5 e1					pop hl 
b6f6					 
b6f6					if DEBUG_FORTH_WORDS 
b6f6						DMARK "RNd" 
b6f6 f5				push af  
b6f7 3a 0b b7			ld a, (.dmark)  
b6fa 32 7a ee			ld (debug_mark),a  
b6fd 3a 0c b7			ld a, (.dmark+1)  
b700 32 7b ee			ld (debug_mark+1),a  
b703 3a 0d b7			ld a, (.dmark+2)  
b706 32 7c ee			ld (debug_mark+2),a  
b709 18 03			jr .pastdmark  
b70b ..			.dmark: db "RNd"  
b70e f1			.pastdmark: pop af  
b70f			endm  
# End of macro DMARK
b70f						CALLMONITOR 
b70f cd 03 93			call break_point_state  
b712				endm  
# End of macro CALLMONITOR
b712					endif 
b712			 
b712			 
b712 cd 90 98				call forth_push_numhl 
b715				       NEXTW 
b715 c3 f9 9b			jp macro_next 
b718				endm 
# End of macro NEXTW
b718			 
b718			.ENDMATHS: 
b718			 
b718			; eof 
b718			 
# End of file forth_words_maths.asm
b718			include "forth_words_display.asm" 
b718			 
b718			; | ## Display Words 
b718			 
b718			.ATP: 
b718				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b718 62				db WORD_SYS_CORE+78             
b719 8f b7			dw .FB            
b71b 04				db 3 + 1 
b71c .. 00			db "AT?",0              
b720				endm 
# End of macro CWHEAD
b720			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b720					if DEBUG_FORTH_WORDS_KEY 
b720						DMARK "AT?" 
b720 f5				push af  
b721 3a 35 b7			ld a, (.dmark)  
b724 32 7a ee			ld (debug_mark),a  
b727 3a 36 b7			ld a, (.dmark+1)  
b72a 32 7b ee			ld (debug_mark+1),a  
b72d 3a 37 b7			ld a, (.dmark+2)  
b730 32 7c ee			ld (debug_mark+2),a  
b733 18 03			jr .pastdmark  
b735 ..			.dmark: db "AT?"  
b738 f1			.pastdmark: pop af  
b739			endm  
# End of macro DMARK
b739						CALLMONITOR 
b739 cd 03 93			call break_point_state  
b73c				endm  
# End of macro CALLMONITOR
b73c					endif 
b73c 3a 49 eb				ld a, (f_cursor_ptr) 
b73f			 
b73f			if DEBUG_FORTH_WORDS 
b73f				DMARK "AT?" 
b73f f5				push af  
b740 3a 54 b7			ld a, (.dmark)  
b743 32 7a ee			ld (debug_mark),a  
b746 3a 55 b7			ld a, (.dmark+1)  
b749 32 7b ee			ld (debug_mark+1),a  
b74c 3a 56 b7			ld a, (.dmark+2)  
b74f 32 7c ee			ld (debug_mark+2),a  
b752 18 03			jr .pastdmark  
b754 ..			.dmark: db "AT?"  
b757 f1			.pastdmark: pop af  
b758			endm  
# End of macro DMARK
b758				CALLMONITOR 
b758 cd 03 93			call break_point_state  
b75b				endm  
# End of macro CALLMONITOR
b75b			endif	 
b75b					; count the number of rows 
b75b			 
b75b 06 00				ld b, 0 
b75d 4f			.atpr:		ld c, a    ; save in case we go below zero 
b75e d6 28				sub display_cols 
b760 f2 66 b7				jp p, .atprunder 
b763 04					inc b 
b764 18 f7				jr .atpr 
b766			.atprunder:	 
b766			if DEBUG_FORTH_WORDS 
b766				DMARK "A?2" 
b766 f5				push af  
b767 3a 7b b7			ld a, (.dmark)  
b76a 32 7a ee			ld (debug_mark),a  
b76d 3a 7c b7			ld a, (.dmark+1)  
b770 32 7b ee			ld (debug_mark+1),a  
b773 3a 7d b7			ld a, (.dmark+2)  
b776 32 7c ee			ld (debug_mark+2),a  
b779 18 03			jr .pastdmark  
b77b ..			.dmark: db "A?2"  
b77e f1			.pastdmark: pop af  
b77f			endm  
# End of macro DMARK
b77f				CALLMONITOR 
b77f cd 03 93			call break_point_state  
b782				endm  
# End of macro CALLMONITOR
b782			endif	 
b782 26 00				ld h, 0 
b784 69					ld l, c 
b785 cd 90 98				call forth_push_numhl 
b788 68					ld l, b  
b789 cd 90 98				call forth_push_numhl 
b78c			 
b78c			 
b78c				NEXTW 
b78c c3 f9 9b			jp macro_next 
b78f				endm 
# End of macro NEXTW
b78f			 
b78f			.FB: 
b78f				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b78f 1b				db WORD_SYS_CORE+7             
b790 dd b7			dw .EMIT            
b792 03				db 2 + 1 
b793 .. 00			db "FB",0              
b796				endm 
# End of macro CWHEAD
b796			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b796			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b796			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b796			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b796					if DEBUG_FORTH_WORDS_KEY 
b796						DMARK "FB." 
b796 f5				push af  
b797 3a ab b7			ld a, (.dmark)  
b79a 32 7a ee			ld (debug_mark),a  
b79d 3a ac b7			ld a, (.dmark+1)  
b7a0 32 7b ee			ld (debug_mark+1),a  
b7a3 3a ad b7			ld a, (.dmark+2)  
b7a6 32 7c ee			ld (debug_mark+2),a  
b7a9 18 03			jr .pastdmark  
b7ab ..			.dmark: db "FB."  
b7ae f1			.pastdmark: pop af  
b7af			endm  
# End of macro DMARK
b7af						CALLMONITOR 
b7af cd 03 93			call break_point_state  
b7b2				endm  
# End of macro CALLMONITOR
b7b2					endif 
b7b2			 
b7b2					FORTH_DSP_VALUEHL 
b7b2 cd 87 9a			call macro_dsp_valuehl 
b7b5				endm 
# End of macro FORTH_DSP_VALUEHL
b7b5			 
b7b5 7d					ld a, l 
b7b6 fe 01				cp 1 
b7b8 20 05				jr nz, .fbn1 
b7ba 21 1f ed				ld hl, display_fb1 
b7bd 18 15				jr .fbset 
b7bf fe 02		.fbn1:		cp 2 
b7c1 20 05				jr nz, .fbn2 
b7c3 21 dd eb				ld hl, display_fb2 
b7c6 18 0c				jr .fbset 
b7c8 fe 03		.fbn2:		cp 3 
b7ca 20 05				jr nz, .fbn3 
b7cc 21 7e ec				ld hl, display_fb3 
b7cf 18 03				jr .fbset 
b7d1			.fbn3:		 ; if invalid number select first 
b7d1 21 1f ed				ld hl, display_fb1 
b7d4 22 db eb		.fbset:		ld (display_fb_active), hl 
b7d7			 
b7d7					FORTH_DSP_POP 
b7d7 cd 3f 9b			call macro_forth_dsp_pop 
b7da				endm 
# End of macro FORTH_DSP_POP
b7da			 
b7da					NEXTW 
b7da c3 f9 9b			jp macro_next 
b7dd				endm 
# End of macro NEXTW
b7dd			 
b7dd			 
b7dd			.EMIT: 
b7dd				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b7dd 1b				db WORD_SYS_CORE+7             
b7de 2e b8			dw .DOTH            
b7e0 05				db 4 + 1 
b7e1 .. 00			db "EMIT",0              
b7e6				endm 
# End of macro CWHEAD
b7e6			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b7e6					; get value off TOS and display it 
b7e6			 
b7e6					if DEBUG_FORTH_WORDS_KEY 
b7e6						DMARK "EMT" 
b7e6 f5				push af  
b7e7 3a fb b7			ld a, (.dmark)  
b7ea 32 7a ee			ld (debug_mark),a  
b7ed 3a fc b7			ld a, (.dmark+1)  
b7f0 32 7b ee			ld (debug_mark+1),a  
b7f3 3a fd b7			ld a, (.dmark+2)  
b7f6 32 7c ee			ld (debug_mark+2),a  
b7f9 18 03			jr .pastdmark  
b7fb ..			.dmark: db "EMT"  
b7fe f1			.pastdmark: pop af  
b7ff			endm  
# End of macro DMARK
b7ff						CALLMONITOR 
b7ff cd 03 93			call break_point_state  
b802				endm  
# End of macro CALLMONITOR
b802					endif 
b802			 
b802					FORTH_DSP_VALUEHL 
b802 cd 87 9a			call macro_dsp_valuehl 
b805				endm 
# End of macro FORTH_DSP_VALUEHL
b805			 
b805 7d					ld a,l 
b806			 
b806					; TODO write to display 
b806			 
b806 32 5e e5				ld (os_input), a 
b809 3e 00				ld a, 0 
b80b 32 5f e5				ld (os_input+1), a 
b80e					 
b80e 3a 49 eb				ld a, (f_cursor_ptr) 
b811 11 5e e5				ld de, os_input 
b814 cd 8d 88				call str_at_display 
b817			 
b817			 
b817 3a 27 eb				ld a,(cli_autodisplay) 
b81a fe 00				cp 0 
b81c 28 03				jr z, .enoupdate 
b81e cd 9d 88						call update_display 
b821					.enoupdate: 
b821			 
b821 3a 49 eb				ld a, (f_cursor_ptr) 
b824 3c					inc a 
b825 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
b828			 
b828			 
b828					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b828 cd 3f 9b			call macro_forth_dsp_pop 
b82b				endm 
# End of macro FORTH_DSP_POP
b82b			  
b82b			 
b82b					NEXTW 
b82b c3 f9 9b			jp macro_next 
b82e				endm 
# End of macro NEXTW
b82e			.DOTH: 
b82e				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b82e 1c				db WORD_SYS_CORE+8             
b82f 5e b8			dw .DOTF            
b831 03				db 2 + 1 
b832 .. 00			db ".-",0              
b835				endm 
# End of macro CWHEAD
b835			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b835					; get value off TOS and display it 
b835					if DEBUG_FORTH_WORDS_KEY 
b835						DMARK "DTD" 
b835 f5				push af  
b836 3a 4a b8			ld a, (.dmark)  
b839 32 7a ee			ld (debug_mark),a  
b83c 3a 4b b8			ld a, (.dmark+1)  
b83f 32 7b ee			ld (debug_mark+1),a  
b842 3a 4c b8			ld a, (.dmark+2)  
b845 32 7c ee			ld (debug_mark+2),a  
b848 18 03			jr .pastdmark  
b84a ..			.dmark: db "DTD"  
b84d f1			.pastdmark: pop af  
b84e			endm  
# End of macro DMARK
b84e						CALLMONITOR 
b84e cd 03 93			call break_point_state  
b851				endm  
# End of macro CALLMONITOR
b851					endif 
b851 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
b853 3e 00			ld a, 0 
b855 32 28 eb			ld (cli_mvdot), a 
b858 c3 b5 b8			jp .dotgo 
b85b				NEXTW 
b85b c3 f9 9b			jp macro_next 
b85e				endm 
# End of macro NEXTW
b85e			.DOTF: 
b85e				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
b85e 1c				db WORD_SYS_CORE+8             
b85f 8c b8			dw .DOT            
b861 03				db 2 + 1 
b862 .. 00			db ".>",0              
b865				endm 
# End of macro CWHEAD
b865			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
b865					; get value off TOS and display it 
b865			        ; TODO BUG adds extra spaces 
b865			        ; TODO BUG handle numerics? 
b865					if DEBUG_FORTH_WORDS_KEY 
b865						DMARK "DTC" 
b865 f5				push af  
b866 3a 7a b8			ld a, (.dmark)  
b869 32 7a ee			ld (debug_mark),a  
b86c 3a 7b b8			ld a, (.dmark+1)  
b86f 32 7b ee			ld (debug_mark+1),a  
b872 3a 7c b8			ld a, (.dmark+2)  
b875 32 7c ee			ld (debug_mark+2),a  
b878 18 03			jr .pastdmark  
b87a ..			.dmark: db "DTC"  
b87d f1			.pastdmark: pop af  
b87e			endm  
# End of macro DMARK
b87e						CALLMONITOR 
b87e cd 03 93			call break_point_state  
b881				endm  
# End of macro CALLMONITOR
b881					endif 
b881 3e 01			ld a, 1 
b883 32 28 eb			ld (cli_mvdot), a 
b886 c3 b5 b8			jp .dotgo 
b889				NEXTW 
b889 c3 f9 9b			jp macro_next 
b88c				endm 
# End of macro NEXTW
b88c			 
b88c			.DOT: 
b88c				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
b88c 1c				db WORD_SYS_CORE+8             
b88d 18 b9			dw .CLS            
b88f 02				db 1 + 1 
b890 .. 00			db ".",0              
b892				endm 
# End of macro CWHEAD
b892			        ; | . ( u -- ) Display TOS | DONE 
b892					; get value off TOS and display it 
b892			 
b892					if DEBUG_FORTH_WORDS_KEY 
b892						DMARK "DOT" 
b892 f5				push af  
b893 3a a7 b8			ld a, (.dmark)  
b896 32 7a ee			ld (debug_mark),a  
b899 3a a8 b8			ld a, (.dmark+1)  
b89c 32 7b ee			ld (debug_mark+1),a  
b89f 3a a9 b8			ld a, (.dmark+2)  
b8a2 32 7c ee			ld (debug_mark+2),a  
b8a5 18 03			jr .pastdmark  
b8a7 ..			.dmark: db "DOT"  
b8aa f1			.pastdmark: pop af  
b8ab			endm  
# End of macro DMARK
b8ab						CALLMONITOR 
b8ab cd 03 93			call break_point_state  
b8ae				endm  
# End of macro CALLMONITOR
b8ae					endif 
b8ae 3e 00			ld a, 0 
b8b0 32 28 eb			ld (cli_mvdot), a 
b8b3 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
b8b5				 
b8b5			 
b8b5			.dotgo: 
b8b5			 
b8b5			; move up type to on stack for parserv5 
b8b5					FORTH_DSP 
b8b5 cd 4d 9a			call macro_forth_dsp 
b8b8				endm 
# End of macro FORTH_DSP
b8b8				;FORTH_DSP_VALUE  
b8b8			 
b8b8			if DEBUG_FORTH_DOT 
b8b8				DMARK "DOT" 
b8b8				CALLMONITOR 
b8b8			endif	 
b8b8			;		.print: 
b8b8			 
b8b8 7e				ld a,(hl)  ; work out what type of value is on the TOS 
b8b9 23				inc hl   ; position to the actual value 
b8ba fe 01			cp DS_TYPE_STR 
b8bc 20 06			jr nz, .dotnum1  
b8be			 
b8be			; display string 
b8be				FORTH_DSP_VALUE  
b8be cd 70 9a			call macro_forth_dsp_value 
b8c1				endm 
# End of macro FORTH_DSP_VALUE
b8c1 eb				ex de,hl 
b8c2 18 11			jr .dotwrite 
b8c4			 
b8c4			.dotnum1: 
b8c4 fe 02			cp DS_TYPE_INUM 
b8c6 20 0c			jr nz, .dotflot 
b8c8			 
b8c8			 
b8c8			; display number 
b8c8			 
b8c8			;	push hl 
b8c8			;	call clear_display 
b8c8			;	pop hl 
b8c8			 
b8c8 5e				ld e, (hl) 
b8c9 23				inc hl 
b8ca 56				ld d, (hl) 
b8cb 21 60 e3			ld hl, scratch 
b8ce			if DEBUG_FORTH_DOT 
b8ce				DMARK "DT1" 
b8ce				CALLMONITOR 
b8ce			endif	 
b8ce			 
b8ce cd b4 8e			call uitoa_16 
b8d1 eb				ex de,hl 
b8d2			 
b8d2			if DEBUG_FORTH_DOT 
b8d2				DMARK "DT2" 
b8d2				CALLMONITOR 
b8d2			endif	 
b8d2			 
b8d2			;	ld de, os_word_scratch 
b8d2 18 01			jr .dotwrite 
b8d4			 
b8d4 00			.dotflot:   nop 
b8d5			; TODO print floating point number 
b8d5			 
b8d5			.dotwrite:		 
b8d5			 
b8d5					; if c is set then set all '-' to spaces 
b8d5					; need to also take into account .>  
b8d5			 
b8d5 3e 01				ld a, 1 
b8d7 b9					cp c 
b8d8 20 13				jr nz, .nodashswap 
b8da			 
b8da					; DE has the string to write, working with HL 
b8da			 
b8da 06 ff				ld b, 255 
b8dc d5					push de 
b8dd e1					pop hl 
b8de			 
b8de			if DEBUG_FORTH_DOT 
b8de				DMARK "DT-" 
b8de				CALLMONITOR 
b8de			endif	 
b8de 7e			.dashscan:	ld a, (hl) 
b8df fe 00				cp 0 
b8e1 28 0a				jr z, .nodashswap 
b8e3 fe 2d				cp '-' 
b8e5 20 03				jr nz, .dashskip 
b8e7 3e 20				ld a, ' ' 
b8e9 77					ld (hl), a 
b8ea 23			.dashskip:	inc hl 
b8eb			if DEBUG_FORTH_DOT 
b8eb				DMARK "D-2" 
b8eb				CALLMONITOR 
b8eb			endif	 
b8eb 10 f1				djnz .dashscan 
b8ed			 
b8ed			if DEBUG_FORTH_DOT 
b8ed				DMARK "D-1" 
b8ed				CALLMONITOR 
b8ed			endif	 
b8ed			 
b8ed			.nodashswap: 
b8ed			 
b8ed e5					push hl   ; save string start in case we need to advance print 
b8ee			 
b8ee 3a 49 eb				ld a, (f_cursor_ptr) 
b8f1 cd 8d 88				call str_at_display 
b8f4 3a 27 eb				ld a,(cli_autodisplay) 
b8f7 fe 00				cp 0 
b8f9 28 03				jr z, .noupdate 
b8fb cd 9d 88						call update_display 
b8fe					.noupdate: 
b8fe			 
b8fe			 
b8fe					; see if we need to advance the print position 
b8fe			 
b8fe e1					pop hl   ; get back string 
b8ff			 
b8ff 3a 28 eb				ld a, (cli_mvdot) 
b902			if DEBUG_FORTH_DOT 
b902					ld e,a 
b902				DMARK "D>1" 
b902				CALLMONITOR 
b902			endif	 
b902 fe 00				cp 0 
b904 28 0c				jr z, .noadv 
b906					; yes, lets advance the print position 
b906 3e 00				ld a, 0 
b908 cd 10 8f				call strlent 
b90b 3a 49 eb				ld a, (f_cursor_ptr) 
b90e 85					add a,l 
b90f					;call addatohl 
b90f					;ld a, l 
b90f 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
b912			 
b912			if DEBUG_FORTH_DOT 
b912				DMARK "D->" 
b912				CALLMONITOR 
b912			endif	 
b912			 
b912			.noadv:	 
b912			 
b912					if DEBUG_FORTH_DOT_WAIT 
b912							call next_page_prompt 
b912					endif	 
b912			; TODO this pop off the stack causes a crash. i dont know why 
b912			 
b912			 
b912			if DEBUG_FORTH_DOT 
b912				DMARK "DTh" 
b912				CALLMONITOR 
b912			endif	 
b912			 
b912					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b912 cd 3f 9b			call macro_forth_dsp_pop 
b915				endm 
# End of macro FORTH_DSP_POP
b915			 
b915			if DEBUG_FORTH_DOT 
b915				DMARK "DTi" 
b915				CALLMONITOR 
b915			endif	 
b915			 
b915			 
b915					NEXTW 
b915 c3 f9 9b			jp macro_next 
b918				endm 
# End of macro NEXTW
b918			 
b918			.CLS: 
b918				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
b918 35				db WORD_SYS_CORE+33             
b919 45 b9			dw .DRAW            
b91b 04				db 3 + 1 
b91c .. 00			db "CLS",0              
b920				endm 
# End of macro CWHEAD
b920			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
b920					if DEBUG_FORTH_WORDS_KEY 
b920						DMARK "CLS" 
b920 f5				push af  
b921 3a 35 b9			ld a, (.dmark)  
b924 32 7a ee			ld (debug_mark),a  
b927 3a 36 b9			ld a, (.dmark+1)  
b92a 32 7b ee			ld (debug_mark+1),a  
b92d 3a 37 b9			ld a, (.dmark+2)  
b930 32 7c ee			ld (debug_mark+2),a  
b933 18 03			jr .pastdmark  
b935 ..			.dmark: db "CLS"  
b938 f1			.pastdmark: pop af  
b939			endm  
# End of macro DMARK
b939						CALLMONITOR 
b939 cd 03 93			call break_point_state  
b93c				endm  
# End of macro CALLMONITOR
b93c					endif 
b93c cd 7a 88				call clear_display 
b93f c3 53 ba				jp .home		; and home cursor 
b942					NEXTW 
b942 c3 f9 9b			jp macro_next 
b945				endm 
# End of macro NEXTW
b945			 
b945			.DRAW: 
b945				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
b945 36				db WORD_SYS_CORE+34             
b946 70 b9			dw .DUMP            
b948 05				db 4 + 1 
b949 .. 00			db "DRAW",0              
b94e				endm 
# End of macro CWHEAD
b94e			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
b94e					if DEBUG_FORTH_WORDS_KEY 
b94e						DMARK "DRW" 
b94e f5				push af  
b94f 3a 63 b9			ld a, (.dmark)  
b952 32 7a ee			ld (debug_mark),a  
b955 3a 64 b9			ld a, (.dmark+1)  
b958 32 7b ee			ld (debug_mark+1),a  
b95b 3a 65 b9			ld a, (.dmark+2)  
b95e 32 7c ee			ld (debug_mark+2),a  
b961 18 03			jr .pastdmark  
b963 ..			.dmark: db "DRW"  
b966 f1			.pastdmark: pop af  
b967			endm  
# End of macro DMARK
b967						CALLMONITOR 
b967 cd 03 93			call break_point_state  
b96a				endm  
# End of macro CALLMONITOR
b96a					endif 
b96a cd 9d 88				call update_display 
b96d					NEXTW 
b96d c3 f9 9b			jp macro_next 
b970				endm 
# End of macro NEXTW
b970			 
b970			.DUMP: 
b970				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
b970 37				db WORD_SYS_CORE+35             
b971 a8 b9			dw .CDUMP            
b973 05				db 4 + 1 
b974 .. 00			db "DUMP",0              
b979				endm 
# End of macro CWHEAD
b979			; | DUMP ( x -- ) With address x display dump   | DONE 
b979			; TODO pop address to use off of the stack 
b979					if DEBUG_FORTH_WORDS_KEY 
b979						DMARK "DUM" 
b979 f5				push af  
b97a 3a 8e b9			ld a, (.dmark)  
b97d 32 7a ee			ld (debug_mark),a  
b980 3a 8f b9			ld a, (.dmark+1)  
b983 32 7b ee			ld (debug_mark+1),a  
b986 3a 90 b9			ld a, (.dmark+2)  
b989 32 7c ee			ld (debug_mark+2),a  
b98c 18 03			jr .pastdmark  
b98e ..			.dmark: db "DUM"  
b991 f1			.pastdmark: pop af  
b992			endm  
# End of macro DMARK
b992						CALLMONITOR 
b992 cd 03 93			call break_point_state  
b995				endm  
# End of macro CALLMONITOR
b995					endif 
b995 cd 7a 88				call clear_display 
b998			 
b998					; get address 
b998			 
b998					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b998 cd 87 9a			call macro_dsp_valuehl 
b99b				endm 
# End of macro FORTH_DSP_VALUEHL
b99b				 
b99b					; save it for cdump 
b99b			 
b99b 22 83 e6				ld (os_cur_ptr),hl 
b99e			 
b99e					; destroy value TOS 
b99e			 
b99e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b99e cd 3f 9b			call macro_forth_dsp_pop 
b9a1				endm 
# End of macro FORTH_DSP_POP
b9a1			 
b9a1 cd 10 97				call dumpcont	; skip old style of param parsing	 
b9a4 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
b9a5					NEXTW 
b9a5 c3 f9 9b			jp macro_next 
b9a8				endm 
# End of macro NEXTW
b9a8			.CDUMP: 
b9a8				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
b9a8 38				db WORD_SYS_CORE+36             
b9a9 d8 b9			dw .DAT            
b9ab 06				db 5 + 1 
b9ac .. 00			db "CDUMP",0              
b9b2				endm 
# End of macro CWHEAD
b9b2			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
b9b2					if DEBUG_FORTH_WORDS_KEY 
b9b2						DMARK "CDP" 
b9b2 f5				push af  
b9b3 3a c7 b9			ld a, (.dmark)  
b9b6 32 7a ee			ld (debug_mark),a  
b9b9 3a c8 b9			ld a, (.dmark+1)  
b9bc 32 7b ee			ld (debug_mark+1),a  
b9bf 3a c9 b9			ld a, (.dmark+2)  
b9c2 32 7c ee			ld (debug_mark+2),a  
b9c5 18 03			jr .pastdmark  
b9c7 ..			.dmark: db "CDP"  
b9ca f1			.pastdmark: pop af  
b9cb			endm  
# End of macro DMARK
b9cb						CALLMONITOR 
b9cb cd 03 93			call break_point_state  
b9ce				endm  
# End of macro CALLMONITOR
b9ce					endif 
b9ce cd 7a 88				call clear_display 
b9d1 cd 10 97				call dumpcont	 
b9d4 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
b9d5					NEXTW 
b9d5 c3 f9 9b			jp macro_next 
b9d8				endm 
# End of macro NEXTW
b9d8			 
b9d8			 
b9d8			 
b9d8			 
b9d8			.DAT: 
b9d8				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
b9d8 3d				db WORD_SYS_CORE+41             
b9d9 2e ba			dw .HOME            
b9db 03				db 2 + 1 
b9dc .. 00			db "AT",0              
b9df				endm 
# End of macro CWHEAD
b9df			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
b9df					if DEBUG_FORTH_WORDS_KEY 
b9df						DMARK "AT." 
b9df f5				push af  
b9e0 3a f4 b9			ld a, (.dmark)  
b9e3 32 7a ee			ld (debug_mark),a  
b9e6 3a f5 b9			ld a, (.dmark+1)  
b9e9 32 7b ee			ld (debug_mark+1),a  
b9ec 3a f6 b9			ld a, (.dmark+2)  
b9ef 32 7c ee			ld (debug_mark+2),a  
b9f2 18 03			jr .pastdmark  
b9f4 ..			.dmark: db "AT."  
b9f7 f1			.pastdmark: pop af  
b9f8			endm  
# End of macro DMARK
b9f8						CALLMONITOR 
b9f8 cd 03 93			call break_point_state  
b9fb				endm  
# End of macro CALLMONITOR
b9fb					endif 
b9fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9fb cd 87 9a			call macro_dsp_valuehl 
b9fe				endm 
# End of macro FORTH_DSP_VALUEHL
b9fe			 
b9fe			 
b9fe					; TODO save cursor row 
b9fe 7d					ld a,l 
b9ff fe 02				cp 2 
ba01 20 04				jr nz, .crow3 
ba03 3e 28				ld a, display_row_2 
ba05 18 12				jr .ccol1 
ba07 fe 03		.crow3:		cp 3 
ba09 20 04				jr nz, .crow4 
ba0b 3e 50				ld a, display_row_3 
ba0d 18 0a				jr .ccol1 
ba0f fe 04		.crow4:		cp 4 
ba11 20 04				jr nz, .crow1 
ba13 3e 78				ld a, display_row_4 
ba15 18 02				jr .ccol1 
ba17 3e 00		.crow1:		ld a,display_row_1 
ba19 f5			.ccol1:		push af			; got row offset 
ba1a 6f					ld l,a 
ba1b 26 00				ld h,0 
ba1d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba1d cd 3f 9b			call macro_forth_dsp_pop 
ba20				endm 
# End of macro FORTH_DSP_POP
ba20					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba20 cd 87 9a			call macro_dsp_valuehl 
ba23				endm 
# End of macro FORTH_DSP_VALUEHL
ba23					; TODO save cursor col 
ba23 f1					pop af 
ba24 85					add l		; add col offset 
ba25 32 49 eb				ld (f_cursor_ptr), a 
ba28					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba28 cd 3f 9b			call macro_forth_dsp_pop 
ba2b				endm 
# End of macro FORTH_DSP_POP
ba2b			 
ba2b					; calculate  
ba2b			 
ba2b					NEXTW 
ba2b c3 f9 9b			jp macro_next 
ba2e				endm 
# End of macro NEXTW
ba2e			 
ba2e			 
ba2e			.HOME: 
ba2e				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
ba2e 41				db WORD_SYS_CORE+45             
ba2f 5b ba			dw .SPACE            
ba31 05				db 4 + 1 
ba32 .. 00			db "HOME",0              
ba37				endm 
# End of macro CWHEAD
ba37			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
ba37					if DEBUG_FORTH_WORDS_KEY 
ba37						DMARK "HOM" 
ba37 f5				push af  
ba38 3a 4c ba			ld a, (.dmark)  
ba3b 32 7a ee			ld (debug_mark),a  
ba3e 3a 4d ba			ld a, (.dmark+1)  
ba41 32 7b ee			ld (debug_mark+1),a  
ba44 3a 4e ba			ld a, (.dmark+2)  
ba47 32 7c ee			ld (debug_mark+2),a  
ba4a 18 03			jr .pastdmark  
ba4c ..			.dmark: db "HOM"  
ba4f f1			.pastdmark: pop af  
ba50			endm  
# End of macro DMARK
ba50						CALLMONITOR 
ba50 cd 03 93			call break_point_state  
ba53				endm  
# End of macro CALLMONITOR
ba53					endif 
ba53 3e 00		.home:		ld a, 0		; and home cursor 
ba55 32 49 eb				ld (f_cursor_ptr), a 
ba58					NEXTW 
ba58 c3 f9 9b			jp macro_next 
ba5b				endm 
# End of macro NEXTW
ba5b			 
ba5b			 
ba5b			.SPACE: 
ba5b				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
ba5b 46				db WORD_SYS_CORE+50             
ba5c 89 ba			dw .SPACES            
ba5e 03				db 2 + 1 
ba5f .. 00			db "BL",0              
ba62				endm 
# End of macro CWHEAD
ba62			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
ba62					if DEBUG_FORTH_WORDS_KEY 
ba62						DMARK "BL." 
ba62 f5				push af  
ba63 3a 77 ba			ld a, (.dmark)  
ba66 32 7a ee			ld (debug_mark),a  
ba69 3a 78 ba			ld a, (.dmark+1)  
ba6c 32 7b ee			ld (debug_mark+1),a  
ba6f 3a 79 ba			ld a, (.dmark+2)  
ba72 32 7c ee			ld (debug_mark+2),a  
ba75 18 03			jr .pastdmark  
ba77 ..			.dmark: db "BL."  
ba7a f1			.pastdmark: pop af  
ba7b			endm  
# End of macro DMARK
ba7b						CALLMONITOR 
ba7b cd 03 93			call break_point_state  
ba7e				endm  
# End of macro CALLMONITOR
ba7e					endif 
ba7e 21 87 ba				ld hl, .blstr 
ba81 cd fe 98				call forth_push_str 
ba84					 
ba84				       NEXTW 
ba84 c3 f9 9b			jp macro_next 
ba87				endm 
# End of macro NEXTW
ba87			 
ba87 .. 00		.blstr: db " ", 0 
ba89			 
ba89			.SPACES: 
ba89				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
ba89 47				db WORD_SYS_CORE+51             
ba8a 24 bb			dw .SCROLL            
ba8c 07				db 6 + 1 
ba8d .. 00			db "SPACES",0              
ba94				endm 
# End of macro CWHEAD
ba94			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
ba94					if DEBUG_FORTH_WORDS_KEY 
ba94						DMARK "SPS" 
ba94 f5				push af  
ba95 3a a9 ba			ld a, (.dmark)  
ba98 32 7a ee			ld (debug_mark),a  
ba9b 3a aa ba			ld a, (.dmark+1)  
ba9e 32 7b ee			ld (debug_mark+1),a  
baa1 3a ab ba			ld a, (.dmark+2)  
baa4 32 7c ee			ld (debug_mark+2),a  
baa7 18 03			jr .pastdmark  
baa9 ..			.dmark: db "SPS"  
baac f1			.pastdmark: pop af  
baad			endm  
# End of macro DMARK
baad						CALLMONITOR 
baad cd 03 93			call break_point_state  
bab0				endm  
# End of macro CALLMONITOR
bab0					endif 
bab0			 
bab0			 
bab0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bab0 cd 87 9a			call macro_dsp_valuehl 
bab3				endm 
# End of macro FORTH_DSP_VALUEHL
bab3			 
bab3			;		push hl    ; u 
bab3					if DEBUG_FORTH_WORDS 
bab3						DMARK "SPA" 
bab3 f5				push af  
bab4 3a c8 ba			ld a, (.dmark)  
bab7 32 7a ee			ld (debug_mark),a  
baba 3a c9 ba			ld a, (.dmark+1)  
babd 32 7b ee			ld (debug_mark+1),a  
bac0 3a ca ba			ld a, (.dmark+2)  
bac3 32 7c ee			ld (debug_mark+2),a  
bac6 18 03			jr .pastdmark  
bac8 ..			.dmark: db "SPA"  
bacb f1			.pastdmark: pop af  
bacc			endm  
# End of macro DMARK
bacc						CALLMONITOR 
bacc cd 03 93			call break_point_state  
bacf				endm  
# End of macro CALLMONITOR
bacf					endif 
bacf			 
bacf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bacf cd 3f 9b			call macro_forth_dsp_pop 
bad2				endm 
# End of macro FORTH_DSP_POP
bad2			;		pop hl 
bad2 4d					ld c, l 
bad3 06 00				ld b, 0 
bad5 21 60 e3				ld hl, scratch  
bad8			 
bad8					if DEBUG_FORTH_WORDS 
bad8						DMARK "SP2" 
bad8 f5				push af  
bad9 3a ed ba			ld a, (.dmark)  
badc 32 7a ee			ld (debug_mark),a  
badf 3a ee ba			ld a, (.dmark+1)  
bae2 32 7b ee			ld (debug_mark+1),a  
bae5 3a ef ba			ld a, (.dmark+2)  
bae8 32 7c ee			ld (debug_mark+2),a  
baeb 18 03			jr .pastdmark  
baed ..			.dmark: db "SP2"  
baf0 f1			.pastdmark: pop af  
baf1			endm  
# End of macro DMARK
baf1						CALLMONITOR 
baf1 cd 03 93			call break_point_state  
baf4				endm  
# End of macro CALLMONITOR
baf4					endif 
baf4 3e 20				ld a, ' ' 
baf6 c5			.spaces1:	push bc 
baf7 77					ld (hl),a 
baf8 23					inc hl 
baf9 c1					pop bc 
bafa 10 fa				djnz .spaces1 
bafc 3e 00				ld a,0 
bafe 77					ld (hl),a 
baff 21 60 e3				ld hl, scratch 
bb02					if DEBUG_FORTH_WORDS 
bb02						DMARK "SP3" 
bb02 f5				push af  
bb03 3a 17 bb			ld a, (.dmark)  
bb06 32 7a ee			ld (debug_mark),a  
bb09 3a 18 bb			ld a, (.dmark+1)  
bb0c 32 7b ee			ld (debug_mark+1),a  
bb0f 3a 19 bb			ld a, (.dmark+2)  
bb12 32 7c ee			ld (debug_mark+2),a  
bb15 18 03			jr .pastdmark  
bb17 ..			.dmark: db "SP3"  
bb1a f1			.pastdmark: pop af  
bb1b			endm  
# End of macro DMARK
bb1b						CALLMONITOR 
bb1b cd 03 93			call break_point_state  
bb1e				endm  
# End of macro CALLMONITOR
bb1e					endif 
bb1e cd f9 99				call forth_apush 
bb21			 
bb21				       NEXTW 
bb21 c3 f9 9b			jp macro_next 
bb24				endm 
# End of macro NEXTW
bb24			 
bb24			 
bb24			 
bb24			.SCROLL: 
bb24				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bb24 53				db WORD_SYS_CORE+63             
bb25 51 bb			dw .SCROLLD            
bb27 07				db 6 + 1 
bb28 .. 00			db "SCROLL",0              
bb2f				endm 
# End of macro CWHEAD
bb2f			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bb2f					if DEBUG_FORTH_WORDS_KEY 
bb2f						DMARK "SCR" 
bb2f f5				push af  
bb30 3a 44 bb			ld a, (.dmark)  
bb33 32 7a ee			ld (debug_mark),a  
bb36 3a 45 bb			ld a, (.dmark+1)  
bb39 32 7b ee			ld (debug_mark+1),a  
bb3c 3a 46 bb			ld a, (.dmark+2)  
bb3f 32 7c ee			ld (debug_mark+2),a  
bb42 18 03			jr .pastdmark  
bb44 ..			.dmark: db "SCR"  
bb47 f1			.pastdmark: pop af  
bb48			endm  
# End of macro DMARK
bb48						CALLMONITOR 
bb48 cd 03 93			call break_point_state  
bb4b				endm  
# End of macro CALLMONITOR
bb4b					endif 
bb4b			 
bb4b cd 3c 88			call scroll_up 
bb4e			;	call update_display 
bb4e			 
bb4e					NEXTW 
bb4e c3 f9 9b			jp macro_next 
bb51				endm 
# End of macro NEXTW
bb51			 
bb51			 
bb51			 
bb51			;		; get dir 
bb51			; 
bb51			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb51			; 
bb51			;		push hl 
bb51			; 
bb51			;		; destroy value TOS 
bb51			; 
bb51			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb51			; 
bb51			;		; get count 
bb51			; 
bb51			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb51			; 
bb51			;		push hl 
bb51			; 
bb51			;		; destroy value TOS 
bb51			; 
bb51			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb51			; 
bb51			;		; one value on hl get other one back 
bb51			; 
bb51			;		pop bc    ; count 
bb51			; 
bb51			;		pop de   ; dir 
bb51			; 
bb51			; 
bb51			;		ld b, c 
bb51			; 
bb51			;.scrolldir:     push bc 
bb51			;		push de 
bb51			; 
bb51			;		ld a, 0 
bb51			;		cp e 
bb51			;		jr z, .scrollup  
bb51			;		call scroll_down 
bb51			;		jr .scrollnext 
bb51			;.scrollup:	call scroll_up 
bb51			; 
bb51			;		 
bb51			;.scrollnext: 
bb51			;		pop de 
bb51			;		pop bc 
bb51			;		djnz .scrolldir 
bb51			; 
bb51			; 
bb51			; 
bb51			; 
bb51			; 
bb51			;		NEXTW 
bb51			 
bb51			.SCROLLD: 
bb51				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bb51 53				db WORD_SYS_CORE+63             
bb52 7f bb			dw .ATQ            
bb54 08				db 7 + 1 
bb55 .. 00			db "SCROLLD",0              
bb5d				endm 
# End of macro CWHEAD
bb5d			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bb5d					if DEBUG_FORTH_WORDS_KEY 
bb5d						DMARK "SCD" 
bb5d f5				push af  
bb5e 3a 72 bb			ld a, (.dmark)  
bb61 32 7a ee			ld (debug_mark),a  
bb64 3a 73 bb			ld a, (.dmark+1)  
bb67 32 7b ee			ld (debug_mark+1),a  
bb6a 3a 74 bb			ld a, (.dmark+2)  
bb6d 32 7c ee			ld (debug_mark+2),a  
bb70 18 03			jr .pastdmark  
bb72 ..			.dmark: db "SCD"  
bb75 f1			.pastdmark: pop af  
bb76			endm  
# End of macro DMARK
bb76						CALLMONITOR 
bb76 cd 03 93			call break_point_state  
bb79				endm  
# End of macro CALLMONITOR
bb79					endif 
bb79			 
bb79 cd 60 88			call scroll_down 
bb7c			;	call update_display 
bb7c			 
bb7c					NEXTW 
bb7c c3 f9 9b			jp macro_next 
bb7f				endm 
# End of macro NEXTW
bb7f			 
bb7f			 
bb7f			.ATQ: 
bb7f				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bb7f 62				db WORD_SYS_CORE+78             
bb80 dd bb			dw .AUTODSP            
bb82 04				db 3 + 1 
bb83 .. 00			db "AT@",0              
bb87				endm 
# End of macro CWHEAD
bb87			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bb87					if DEBUG_FORTH_WORDS_KEY 
bb87						DMARK "ATA" 
bb87 f5				push af  
bb88 3a 9c bb			ld a, (.dmark)  
bb8b 32 7a ee			ld (debug_mark),a  
bb8e 3a 9d bb			ld a, (.dmark+1)  
bb91 32 7b ee			ld (debug_mark+1),a  
bb94 3a 9e bb			ld a, (.dmark+2)  
bb97 32 7c ee			ld (debug_mark+2),a  
bb9a 18 03			jr .pastdmark  
bb9c ..			.dmark: db "ATA"  
bb9f f1			.pastdmark: pop af  
bba0			endm  
# End of macro DMARK
bba0						CALLMONITOR 
bba0 cd 03 93			call break_point_state  
bba3				endm  
# End of macro CALLMONITOR
bba3					endif 
bba3			 
bba3			 
bba3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bba3 cd 87 9a			call macro_dsp_valuehl 
bba6				endm 
# End of macro FORTH_DSP_VALUEHL
bba6			 
bba6					; TODO save cursor row 
bba6 7d					ld a,l 
bba7 fe 02				cp 2 
bba9 20 04				jr nz, .crow3aq 
bbab 3e 28				ld a, display_row_2 
bbad 18 12				jr .ccol1aq 
bbaf fe 03		.crow3aq:		cp 3 
bbb1 20 04				jr nz, .crow4aq 
bbb3 3e 50				ld a, display_row_3 
bbb5 18 0a				jr .ccol1aq 
bbb7 fe 04		.crow4aq:		cp 4 
bbb9 20 04				jr nz, .crow1aq 
bbbb 3e 78				ld a, display_row_4 
bbbd 18 02				jr .ccol1aq 
bbbf 3e 00		.crow1aq:		ld a,display_row_1 
bbc1 f5			.ccol1aq:		push af			; got row offset 
bbc2 6f					ld l,a 
bbc3 26 00				ld h,0 
bbc5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bbc5 cd 3f 9b			call macro_forth_dsp_pop 
bbc8				endm 
# End of macro FORTH_DSP_POP
bbc8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bbc8 cd 87 9a			call macro_dsp_valuehl 
bbcb				endm 
# End of macro FORTH_DSP_VALUEHL
bbcb					; TODO save cursor col 
bbcb f1					pop af 
bbcc 85					add l		; add col offset 
bbcd			 
bbcd					; add current frame buffer address 
bbcd 2a db eb				ld hl, (display_fb_active) 
bbd0 cd a7 8a				call addatohl 
bbd3			 
bbd3			 
bbd3			 
bbd3			 
bbd3					; get char frame buffer location offset in hl 
bbd3			 
bbd3 7e					ld a,(hl) 
bbd4 26 00				ld h, 0 
bbd6 6f					ld l, a 
bbd7			 
bbd7 cd 90 98				call forth_push_numhl 
bbda			 
bbda			 
bbda					NEXTW 
bbda c3 f9 9b			jp macro_next 
bbdd				endm 
# End of macro NEXTW
bbdd			 
bbdd			.AUTODSP: 
bbdd				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bbdd 63				db WORD_SYS_CORE+79             
bbde f3 bb			dw .MENU            
bbe0 05				db 4 + 1 
bbe1 .. 00			db "ADSP",0              
bbe6				endm 
# End of macro CWHEAD
bbe6			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bbe6			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bbe6			 
bbe6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bbe6 cd 87 9a			call macro_dsp_valuehl 
bbe9				endm 
# End of macro FORTH_DSP_VALUEHL
bbe9			 
bbe9			;		push hl 
bbe9			 
bbe9					; destroy value TOS 
bbe9			 
bbe9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bbe9 cd 3f 9b			call macro_forth_dsp_pop 
bbec				endm 
# End of macro FORTH_DSP_POP
bbec			 
bbec			;		pop hl 
bbec			 
bbec 7d					ld a,l 
bbed 32 27 eb				ld (cli_autodisplay), a 
bbf0				       NEXTW 
bbf0 c3 f9 9b			jp macro_next 
bbf3				endm 
# End of macro NEXTW
bbf3			 
bbf3			.MENU: 
bbf3				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bbf3 70				db WORD_SYS_CORE+92             
bbf4 9c bc			dw .ENDDISPLAY            
bbf6 05				db 4 + 1 
bbf7 .. 00			db "MENU",0              
bbfc				endm 
# End of macro CWHEAD
bbfc			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bbfc			 
bbfc			;		; get number of items on the stack 
bbfc			; 
bbfc				 
bbfc					FORTH_DSP_VALUEHL 
bbfc cd 87 9a			call macro_dsp_valuehl 
bbff				endm 
# End of macro FORTH_DSP_VALUEHL
bbff				 
bbff					if DEBUG_FORTH_WORDS_KEY 
bbff						DMARK "MNU" 
bbff f5				push af  
bc00 3a 14 bc			ld a, (.dmark)  
bc03 32 7a ee			ld (debug_mark),a  
bc06 3a 15 bc			ld a, (.dmark+1)  
bc09 32 7b ee			ld (debug_mark+1),a  
bc0c 3a 16 bc			ld a, (.dmark+2)  
bc0f 32 7c ee			ld (debug_mark+2),a  
bc12 18 03			jr .pastdmark  
bc14 ..			.dmark: db "MNU"  
bc17 f1			.pastdmark: pop af  
bc18			endm  
# End of macro DMARK
bc18						CALLMONITOR 
bc18 cd 03 93			call break_point_state  
bc1b				endm  
# End of macro CALLMONITOR
bc1b					endif 
bc1b			 
bc1b 45					ld b, l	 
bc1c 05					dec b 
bc1d			 
bc1d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc1d cd 3f 9b			call macro_forth_dsp_pop 
bc20				endm 
# End of macro FORTH_DSP_POP
bc20			 
bc20			 
bc20					; go directly through the stack to pluck out the string pointers and build an array 
bc20			 
bc20			;		FORTH_DSP 
bc20			 
bc20					; hl contains top most stack item 
bc20				 
bc20 11 60 e3				ld de, scratch 
bc23			 
bc23			.mbuild: 
bc23			 
bc23					FORTH_DSP_VALUEHL 
bc23 cd 87 9a			call macro_dsp_valuehl 
bc26				endm 
# End of macro FORTH_DSP_VALUEHL
bc26			 
bc26					if DEBUG_FORTH_WORDS 
bc26						DMARK "MN3" 
bc26 f5				push af  
bc27 3a 3b bc			ld a, (.dmark)  
bc2a 32 7a ee			ld (debug_mark),a  
bc2d 3a 3c bc			ld a, (.dmark+1)  
bc30 32 7b ee			ld (debug_mark+1),a  
bc33 3a 3d bc			ld a, (.dmark+2)  
bc36 32 7c ee			ld (debug_mark+2),a  
bc39 18 03			jr .pastdmark  
bc3b ..			.dmark: db "MN3"  
bc3e f1			.pastdmark: pop af  
bc3f			endm  
# End of macro DMARK
bc3f						CALLMONITOR 
bc3f cd 03 93			call break_point_state  
bc42				endm  
# End of macro CALLMONITOR
bc42					endif 
bc42 eb					ex de, hl 
bc43 73					ld (hl), e 
bc44 23					inc hl 
bc45 72					ld (hl), d 
bc46 23					inc hl 
bc47 eb					ex de, hl 
bc48			 
bc48					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc48 cd 3f 9b			call macro_forth_dsp_pop 
bc4b				endm 
# End of macro FORTH_DSP_POP
bc4b			 
bc4b 10 d6				djnz .mbuild 
bc4d			 
bc4d					; done add term 
bc4d			 
bc4d eb					ex de, hl 
bc4e 36 00				ld (hl), 0 
bc50 23					inc hl 
bc51 36 00				ld (hl), 0 
bc53			 
bc53				 
bc53					 
bc53 21 60 e3				ld hl, scratch 
bc56			 
bc56					if DEBUG_FORTH_WORDS 
bc56						DMARK "MNx" 
bc56 f5				push af  
bc57 3a 6b bc			ld a, (.dmark)  
bc5a 32 7a ee			ld (debug_mark),a  
bc5d 3a 6c bc			ld a, (.dmark+1)  
bc60 32 7b ee			ld (debug_mark+1),a  
bc63 3a 6d bc			ld a, (.dmark+2)  
bc66 32 7c ee			ld (debug_mark+2),a  
bc69 18 03			jr .pastdmark  
bc6b ..			.dmark: db "MNx"  
bc6e f1			.pastdmark: pop af  
bc6f			endm  
# End of macro DMARK
bc6f						CALLMONITOR 
bc6f cd 03 93			call break_point_state  
bc72				endm  
# End of macro CALLMONITOR
bc72					endif 
bc72			 
bc72			 
bc72			 
bc72 3e 00				ld a, 0 
bc74 cd ab 88				call menu 
bc77			 
bc77			 
bc77 6f					ld l, a 
bc78 26 00				ld h, 0 
bc7a			 
bc7a					if DEBUG_FORTH_WORDS 
bc7a						DMARK "MNr" 
bc7a f5				push af  
bc7b 3a 8f bc			ld a, (.dmark)  
bc7e 32 7a ee			ld (debug_mark),a  
bc81 3a 90 bc			ld a, (.dmark+1)  
bc84 32 7b ee			ld (debug_mark+1),a  
bc87 3a 91 bc			ld a, (.dmark+2)  
bc8a 32 7c ee			ld (debug_mark+2),a  
bc8d 18 03			jr .pastdmark  
bc8f ..			.dmark: db "MNr"  
bc92 f1			.pastdmark: pop af  
bc93			endm  
# End of macro DMARK
bc93						CALLMONITOR 
bc93 cd 03 93			call break_point_state  
bc96				endm  
# End of macro CALLMONITOR
bc96					endif 
bc96			 
bc96 cd 90 98				call forth_push_numhl 
bc99			 
bc99			 
bc99			 
bc99			 
bc99				       NEXTW 
bc99 c3 f9 9b			jp macro_next 
bc9c				endm 
# End of macro NEXTW
bc9c			 
bc9c			 
bc9c			.ENDDISPLAY: 
bc9c			 
bc9c			; eof 
# End of file forth_words_display.asm
bc9c			include "forth_words_str.asm" 
bc9c			 
bc9c			; | ## String Words 
bc9c			 
bc9c			.PTR:   
bc9c			 
bc9c				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
bc9c 48				db WORD_SYS_CORE+52             
bc9d c9 bc			dw .STYPE            
bc9f 04				db 3 + 1 
bca0 .. 00			db "PTR",0              
bca4				endm 
# End of macro CWHEAD
bca4			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
bca4			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
bca4			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
bca4			 
bca4					if DEBUG_FORTH_WORDS_KEY 
bca4						DMARK "PTR" 
bca4 f5				push af  
bca5 3a b9 bc			ld a, (.dmark)  
bca8 32 7a ee			ld (debug_mark),a  
bcab 3a ba bc			ld a, (.dmark+1)  
bcae 32 7b ee			ld (debug_mark+1),a  
bcb1 3a bb bc			ld a, (.dmark+2)  
bcb4 32 7c ee			ld (debug_mark+2),a  
bcb7 18 03			jr .pastdmark  
bcb9 ..			.dmark: db "PTR"  
bcbc f1			.pastdmark: pop af  
bcbd			endm  
# End of macro DMARK
bcbd						CALLMONITOR 
bcbd cd 03 93			call break_point_state  
bcc0				endm  
# End of macro CALLMONITOR
bcc0					endif 
bcc0					FORTH_DSP_VALUEHL 
bcc0 cd 87 9a			call macro_dsp_valuehl 
bcc3				endm 
# End of macro FORTH_DSP_VALUEHL
bcc3 cd 90 98				call forth_push_numhl 
bcc6			 
bcc6			 
bcc6					NEXTW 
bcc6 c3 f9 9b			jp macro_next 
bcc9				endm 
# End of macro NEXTW
bcc9			.STYPE: 
bcc9				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
bcc9 48				db WORD_SYS_CORE+52             
bcca 18 bd			dw .UPPER            
bccc 06				db 5 + 1 
bccd .. 00			db "STYPE",0              
bcd3				endm 
# End of macro CWHEAD
bcd3			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
bcd3					if DEBUG_FORTH_WORDS_KEY 
bcd3						DMARK "STY" 
bcd3 f5				push af  
bcd4 3a e8 bc			ld a, (.dmark)  
bcd7 32 7a ee			ld (debug_mark),a  
bcda 3a e9 bc			ld a, (.dmark+1)  
bcdd 32 7b ee			ld (debug_mark+1),a  
bce0 3a ea bc			ld a, (.dmark+2)  
bce3 32 7c ee			ld (debug_mark+2),a  
bce6 18 03			jr .pastdmark  
bce8 ..			.dmark: db "STY"  
bceb f1			.pastdmark: pop af  
bcec			endm  
# End of macro DMARK
bcec						CALLMONITOR 
bcec cd 03 93			call break_point_state  
bcef				endm  
# End of macro CALLMONITOR
bcef					endif 
bcef					FORTH_DSP 
bcef cd 4d 9a			call macro_forth_dsp 
bcf2				endm 
# End of macro FORTH_DSP
bcf2					;v5 FORTH_DSP_VALUE 
bcf2			 
bcf2 7e					ld a, (hl) 
bcf3			 
bcf3 f5					push af 
bcf4			 
bcf4			; Dont destroy TOS		FORTH_DSP_POP 
bcf4			 
bcf4 f1					pop af 
bcf5			 
bcf5 fe 01				cp DS_TYPE_STR 
bcf7 28 09				jr z, .typestr 
bcf9			 
bcf9 fe 02				cp DS_TYPE_INUM 
bcfb 28 0a				jr z, .typeinum 
bcfd			 
bcfd 21 16 bd				ld hl, .tna 
bd00 18 0a				jr .tpush 
bd02			 
bd02 21 12 bd		.typestr:	ld hl, .tstr 
bd05 18 05				jr .tpush 
bd07 21 14 bd		.typeinum:	ld hl, .tinum 
bd0a 18 00				jr .tpush 
bd0c			 
bd0c			.tpush: 
bd0c			 
bd0c cd fe 98				call forth_push_str 
bd0f			 
bd0f					NEXTW 
bd0f c3 f9 9b			jp macro_next 
bd12				endm 
# End of macro NEXTW
bd12 .. 00		.tstr:	db "s",0 
bd14 .. 00		.tinum:  db "i",0 
bd16 .. 00		.tna:   db "?", 0 
bd18			 
bd18			 
bd18			.UPPER: 
bd18				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
bd18 48				db WORD_SYS_CORE+52             
bd19 53 bd			dw .LOWER            
bd1b 06				db 5 + 1 
bd1c .. 00			db "UPPER",0              
bd22				endm 
# End of macro CWHEAD
bd22			; | UPPER ( s -- s ) Upper case string s  | DONE 
bd22					if DEBUG_FORTH_WORDS_KEY 
bd22						DMARK "UPR" 
bd22 f5				push af  
bd23 3a 37 bd			ld a, (.dmark)  
bd26 32 7a ee			ld (debug_mark),a  
bd29 3a 38 bd			ld a, (.dmark+1)  
bd2c 32 7b ee			ld (debug_mark+1),a  
bd2f 3a 39 bd			ld a, (.dmark+2)  
bd32 32 7c ee			ld (debug_mark+2),a  
bd35 18 03			jr .pastdmark  
bd37 ..			.dmark: db "UPR"  
bd3a f1			.pastdmark: pop af  
bd3b			endm  
# End of macro DMARK
bd3b						CALLMONITOR 
bd3b cd 03 93			call break_point_state  
bd3e				endm  
# End of macro CALLMONITOR
bd3e					endif 
bd3e			 
bd3e					FORTH_DSP 
bd3e cd 4d 9a			call macro_forth_dsp 
bd41				endm 
# End of macro FORTH_DSP
bd41					 
bd41			; TODO check is string type 
bd41			 
bd41					FORTH_DSP_VALUEHL 
bd41 cd 87 9a			call macro_dsp_valuehl 
bd44				endm 
# End of macro FORTH_DSP_VALUEHL
bd44			; get pointer to string in hl 
bd44			 
bd44 7e			.toup:		ld a, (hl) 
bd45 fe 00				cp 0 
bd47 28 07				jr z, .toupdone 
bd49			 
bd49 cd 14 8e				call to_upper 
bd4c			 
bd4c 77					ld (hl), a 
bd4d 23					inc hl 
bd4e 18 f4				jr .toup 
bd50			 
bd50					 
bd50			 
bd50			 
bd50			; for each char convert to upper 
bd50					 
bd50			.toupdone: 
bd50			 
bd50			 
bd50					NEXTW 
bd50 c3 f9 9b			jp macro_next 
bd53				endm 
# End of macro NEXTW
bd53			.LOWER: 
bd53				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
bd53 48				db WORD_SYS_CORE+52             
bd54 8e bd			dw .TCASE            
bd56 06				db 5 + 1 
bd57 .. 00			db "LOWER",0              
bd5d				endm 
# End of macro CWHEAD
bd5d			; | LOWER ( s -- s ) Lower case string s  | DONE 
bd5d					if DEBUG_FORTH_WORDS_KEY 
bd5d						DMARK "LWR" 
bd5d f5				push af  
bd5e 3a 72 bd			ld a, (.dmark)  
bd61 32 7a ee			ld (debug_mark),a  
bd64 3a 73 bd			ld a, (.dmark+1)  
bd67 32 7b ee			ld (debug_mark+1),a  
bd6a 3a 74 bd			ld a, (.dmark+2)  
bd6d 32 7c ee			ld (debug_mark+2),a  
bd70 18 03			jr .pastdmark  
bd72 ..			.dmark: db "LWR"  
bd75 f1			.pastdmark: pop af  
bd76			endm  
# End of macro DMARK
bd76						CALLMONITOR 
bd76 cd 03 93			call break_point_state  
bd79				endm  
# End of macro CALLMONITOR
bd79					endif 
bd79			 
bd79					FORTH_DSP 
bd79 cd 4d 9a			call macro_forth_dsp 
bd7c				endm 
# End of macro FORTH_DSP
bd7c					 
bd7c			; TODO check is string type 
bd7c			 
bd7c					FORTH_DSP_VALUEHL 
bd7c cd 87 9a			call macro_dsp_valuehl 
bd7f				endm 
# End of macro FORTH_DSP_VALUEHL
bd7f			; get pointer to string in hl 
bd7f			 
bd7f 7e			.tolow:		ld a, (hl) 
bd80 fe 00				cp 0 
bd82 28 07				jr z, .tolowdone 
bd84			 
bd84 cd 1d 8e				call to_lower 
bd87			 
bd87 77					ld (hl), a 
bd88 23					inc hl 
bd89 18 f4				jr .tolow 
bd8b			 
bd8b					 
bd8b			 
bd8b			 
bd8b			; for each char convert to low 
bd8b					 
bd8b			.tolowdone: 
bd8b					NEXTW 
bd8b c3 f9 9b			jp macro_next 
bd8e				endm 
# End of macro NEXTW
bd8e			.TCASE: 
bd8e				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
bd8e 48				db WORD_SYS_CORE+52             
bd8f c4 be			dw .SUBSTR            
bd91 06				db 5 + 1 
bd92 .. 00			db "TCASE",0              
bd98				endm 
# End of macro CWHEAD
bd98			; | TCASE ( s -- s ) Title case string s  | DONE 
bd98					if DEBUG_FORTH_WORDS_KEY 
bd98						DMARK "TCS" 
bd98 f5				push af  
bd99 3a ad bd			ld a, (.dmark)  
bd9c 32 7a ee			ld (debug_mark),a  
bd9f 3a ae bd			ld a, (.dmark+1)  
bda2 32 7b ee			ld (debug_mark+1),a  
bda5 3a af bd			ld a, (.dmark+2)  
bda8 32 7c ee			ld (debug_mark+2),a  
bdab 18 03			jr .pastdmark  
bdad ..			.dmark: db "TCS"  
bdb0 f1			.pastdmark: pop af  
bdb1			endm  
# End of macro DMARK
bdb1						CALLMONITOR 
bdb1 cd 03 93			call break_point_state  
bdb4				endm  
# End of macro CALLMONITOR
bdb4					endif 
bdb4			 
bdb4					FORTH_DSP 
bdb4 cd 4d 9a			call macro_forth_dsp 
bdb7				endm 
# End of macro FORTH_DSP
bdb7					 
bdb7			; TODO check is string type 
bdb7			 
bdb7					FORTH_DSP_VALUEHL 
bdb7 cd 87 9a			call macro_dsp_valuehl 
bdba				endm 
# End of macro FORTH_DSP_VALUEHL
bdba			; get pointer to string in hl 
bdba			 
bdba					if DEBUG_FORTH_WORDS 
bdba						DMARK "TC1" 
bdba f5				push af  
bdbb 3a cf bd			ld a, (.dmark)  
bdbe 32 7a ee			ld (debug_mark),a  
bdc1 3a d0 bd			ld a, (.dmark+1)  
bdc4 32 7b ee			ld (debug_mark+1),a  
bdc7 3a d1 bd			ld a, (.dmark+2)  
bdca 32 7c ee			ld (debug_mark+2),a  
bdcd 18 03			jr .pastdmark  
bdcf ..			.dmark: db "TC1"  
bdd2 f1			.pastdmark: pop af  
bdd3			endm  
# End of macro DMARK
bdd3						CALLMONITOR 
bdd3 cd 03 93			call break_point_state  
bdd6				endm  
# End of macro CALLMONITOR
bdd6					endif 
bdd6			 
bdd6					; first time in turn to upper case first char 
bdd6			 
bdd6 7e					ld a, (hl) 
bdd7 c3 61 be				jp .totsiptou 
bdda			 
bdda			 
bdda 7e			.tot:		ld a, (hl) 
bddb fe 00				cp 0 
bddd ca a5 be				jp z, .totdone 
bde0			 
bde0					if DEBUG_FORTH_WORDS 
bde0						DMARK "TC2" 
bde0 f5				push af  
bde1 3a f5 bd			ld a, (.dmark)  
bde4 32 7a ee			ld (debug_mark),a  
bde7 3a f6 bd			ld a, (.dmark+1)  
bdea 32 7b ee			ld (debug_mark+1),a  
bded 3a f7 bd			ld a, (.dmark+2)  
bdf0 32 7c ee			ld (debug_mark+2),a  
bdf3 18 03			jr .pastdmark  
bdf5 ..			.dmark: db "TC2"  
bdf8 f1			.pastdmark: pop af  
bdf9			endm  
# End of macro DMARK
bdf9						CALLMONITOR 
bdf9 cd 03 93			call break_point_state  
bdfc				endm  
# End of macro CALLMONITOR
bdfc					endif 
bdfc					; check to see if current char is a space 
bdfc			 
bdfc fe 20				cp ' ' 
bdfe 28 21				jr z, .totsp 
be00 cd 1d 8e				call to_lower 
be03					if DEBUG_FORTH_WORDS 
be03						DMARK "TC3" 
be03 f5				push af  
be04 3a 18 be			ld a, (.dmark)  
be07 32 7a ee			ld (debug_mark),a  
be0a 3a 19 be			ld a, (.dmark+1)  
be0d 32 7b ee			ld (debug_mark+1),a  
be10 3a 1a be			ld a, (.dmark+2)  
be13 32 7c ee			ld (debug_mark+2),a  
be16 18 03			jr .pastdmark  
be18 ..			.dmark: db "TC3"  
be1b f1			.pastdmark: pop af  
be1c			endm  
# End of macro DMARK
be1c						CALLMONITOR 
be1c cd 03 93			call break_point_state  
be1f				endm  
# End of macro CALLMONITOR
be1f					endif 
be1f 18 63				jr .totnxt 
be21			 
be21			.totsp:         ; on a space, find next char which should be upper 
be21			 
be21					if DEBUG_FORTH_WORDS 
be21						DMARK "TC4" 
be21 f5				push af  
be22 3a 36 be			ld a, (.dmark)  
be25 32 7a ee			ld (debug_mark),a  
be28 3a 37 be			ld a, (.dmark+1)  
be2b 32 7b ee			ld (debug_mark+1),a  
be2e 3a 38 be			ld a, (.dmark+2)  
be31 32 7c ee			ld (debug_mark+2),a  
be34 18 03			jr .pastdmark  
be36 ..			.dmark: db "TC4"  
be39 f1			.pastdmark: pop af  
be3a			endm  
# End of macro DMARK
be3a						CALLMONITOR 
be3a cd 03 93			call break_point_state  
be3d				endm  
# End of macro CALLMONITOR
be3d					endif 
be3d					;; 
be3d			 
be3d fe 20				cp ' ' 
be3f 20 20				jr nz, .totsiptou 
be41 23					inc hl 
be42 7e					ld a, (hl) 
be43					if DEBUG_FORTH_WORDS 
be43						DMARK "TC5" 
be43 f5				push af  
be44 3a 58 be			ld a, (.dmark)  
be47 32 7a ee			ld (debug_mark),a  
be4a 3a 59 be			ld a, (.dmark+1)  
be4d 32 7b ee			ld (debug_mark+1),a  
be50 3a 5a be			ld a, (.dmark+2)  
be53 32 7c ee			ld (debug_mark+2),a  
be56 18 03			jr .pastdmark  
be58 ..			.dmark: db "TC5"  
be5b f1			.pastdmark: pop af  
be5c			endm  
# End of macro DMARK
be5c						CALLMONITOR 
be5c cd 03 93			call break_point_state  
be5f				endm  
# End of macro CALLMONITOR
be5f					endif 
be5f 18 c0				jr .totsp 
be61 fe 00		.totsiptou:    cp 0 
be63 28 40				jr z, .totdone 
be65					; not space and not zero term so upper case it 
be65 cd 14 8e				call to_upper 
be68			 
be68					if DEBUG_FORTH_WORDS 
be68						DMARK "TC6" 
be68 f5				push af  
be69 3a 7d be			ld a, (.dmark)  
be6c 32 7a ee			ld (debug_mark),a  
be6f 3a 7e be			ld a, (.dmark+1)  
be72 32 7b ee			ld (debug_mark+1),a  
be75 3a 7f be			ld a, (.dmark+2)  
be78 32 7c ee			ld (debug_mark+2),a  
be7b 18 03			jr .pastdmark  
be7d ..			.dmark: db "TC6"  
be80 f1			.pastdmark: pop af  
be81			endm  
# End of macro DMARK
be81						CALLMONITOR 
be81 cd 03 93			call break_point_state  
be84				endm  
# End of macro CALLMONITOR
be84					endif 
be84			 
be84			 
be84			.totnxt: 
be84			 
be84 77					ld (hl), a 
be85 23					inc hl 
be86					if DEBUG_FORTH_WORDS 
be86						DMARK "TC7" 
be86 f5				push af  
be87 3a 9b be			ld a, (.dmark)  
be8a 32 7a ee			ld (debug_mark),a  
be8d 3a 9c be			ld a, (.dmark+1)  
be90 32 7b ee			ld (debug_mark+1),a  
be93 3a 9d be			ld a, (.dmark+2)  
be96 32 7c ee			ld (debug_mark+2),a  
be99 18 03			jr .pastdmark  
be9b ..			.dmark: db "TC7"  
be9e f1			.pastdmark: pop af  
be9f			endm  
# End of macro DMARK
be9f						CALLMONITOR 
be9f cd 03 93			call break_point_state  
bea2				endm  
# End of macro CALLMONITOR
bea2					endif 
bea2 c3 da bd				jp .tot 
bea5			 
bea5					 
bea5			 
bea5			 
bea5			; for each char convert to low 
bea5					 
bea5			.totdone: 
bea5					if DEBUG_FORTH_WORDS 
bea5						DMARK "TCd" 
bea5 f5				push af  
bea6 3a ba be			ld a, (.dmark)  
bea9 32 7a ee			ld (debug_mark),a  
beac 3a bb be			ld a, (.dmark+1)  
beaf 32 7b ee			ld (debug_mark+1),a  
beb2 3a bc be			ld a, (.dmark+2)  
beb5 32 7c ee			ld (debug_mark+2),a  
beb8 18 03			jr .pastdmark  
beba ..			.dmark: db "TCd"  
bebd f1			.pastdmark: pop af  
bebe			endm  
# End of macro DMARK
bebe						CALLMONITOR 
bebe cd 03 93			call break_point_state  
bec1				endm  
# End of macro CALLMONITOR
bec1					endif 
bec1					NEXTW 
bec1 c3 f9 9b			jp macro_next 
bec4				endm 
# End of macro NEXTW
bec4			 
bec4			.SUBSTR: 
bec4				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
bec4 48				db WORD_SYS_CORE+52             
bec5 22 bf			dw .LEFT            
bec7 07				db 6 + 1 
bec8 .. 00			db "SUBSTR",0              
becf				endm 
# End of macro CWHEAD
becf			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
becf			 
becf					if DEBUG_FORTH_WORDS_KEY 
becf						DMARK "SST" 
becf f5				push af  
bed0 3a e4 be			ld a, (.dmark)  
bed3 32 7a ee			ld (debug_mark),a  
bed6 3a e5 be			ld a, (.dmark+1)  
bed9 32 7b ee			ld (debug_mark+1),a  
bedc 3a e6 be			ld a, (.dmark+2)  
bedf 32 7c ee			ld (debug_mark+2),a  
bee2 18 03			jr .pastdmark  
bee4 ..			.dmark: db "SST"  
bee7 f1			.pastdmark: pop af  
bee8			endm  
# End of macro DMARK
bee8						CALLMONITOR 
bee8 cd 03 93			call break_point_state  
beeb				endm  
# End of macro CALLMONITOR
beeb					endif 
beeb			; TODO check string type 
beeb					FORTH_DSP_VALUEHL 
beeb cd 87 9a			call macro_dsp_valuehl 
beee				endm 
# End of macro FORTH_DSP_VALUEHL
beee			 
beee e5					push hl      ; string length 
beef			 
beef					FORTH_DSP_POP 
beef cd 3f 9b			call macro_forth_dsp_pop 
bef2				endm 
# End of macro FORTH_DSP_POP
bef2			 
bef2					FORTH_DSP_VALUEHL 
bef2 cd 87 9a			call macro_dsp_valuehl 
bef5				endm 
# End of macro FORTH_DSP_VALUEHL
bef5			 
bef5 e5					push hl     ; start char 
bef6			 
bef6					FORTH_DSP_POP 
bef6 cd 3f 9b			call macro_forth_dsp_pop 
bef9				endm 
# End of macro FORTH_DSP_POP
bef9			 
bef9			 
bef9					FORTH_DSP_VALUE 
bef9 cd 70 9a			call macro_forth_dsp_value 
befc				endm 
# End of macro FORTH_DSP_VALUE
befc			 
befc d1					pop de    ; get start post offset 
befd			 
befd 19					add hl, de    ; starting offset 
befe			 
befe c1					pop bc 
beff c5					push bc      ; grab size of string 
bf00			 
bf00 e5					push hl    ; save string start  
bf01			 
bf01 26 00				ld h, 0 
bf03 69					ld l, c 
bf04 23					inc hl 
bf05 23					inc hl 
bf06			 
bf06 cd 6e 8f				call malloc 
bf09				if DEBUG_FORTH_MALLOC_GUARD 
bf09 cc 38 c5				call z,malloc_error 
bf0c				endif 
bf0c			 
bf0c eb					ex de, hl      ; save malloc area for string copy 
bf0d e1					pop hl    ; get back source 
bf0e c1					pop bc    ; get length of string back 
bf0f			 
bf0f d5					push de    ; save malloc area for after we push 
bf10 ed b0				ldir     ; copy substr 
bf12			 
bf12			 
bf12 eb					ex de, hl 
bf13 3e 00				ld a, 0 
bf15 77					ld (hl), a   ; term substr 
bf16			 
bf16					 
bf16 e1					pop hl    ; get malloc so we can push it 
bf17 e5					push hl   ; save so we can free it afterwards 
bf18			 
bf18 cd fe 98				call forth_push_str 
bf1b			 
bf1b e1					pop hl 
bf1c cd 38 90				call free 
bf1f			 
bf1f					 
bf1f					 
bf1f			 
bf1f			 
bf1f					NEXTW 
bf1f c3 f9 9b			jp macro_next 
bf22				endm 
# End of macro NEXTW
bf22			 
bf22			.LEFT: 
bf22				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
bf22 48				db WORD_SYS_CORE+52             
bf23 4a bf			dw .RIGHT            
bf25 05				db 4 + 1 
bf26 .. 00			db "LEFT",0              
bf2b				endm 
# End of macro CWHEAD
bf2b			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
bf2b					if DEBUG_FORTH_WORDS_KEY 
bf2b						DMARK "LEF" 
bf2b f5				push af  
bf2c 3a 40 bf			ld a, (.dmark)  
bf2f 32 7a ee			ld (debug_mark),a  
bf32 3a 41 bf			ld a, (.dmark+1)  
bf35 32 7b ee			ld (debug_mark+1),a  
bf38 3a 42 bf			ld a, (.dmark+2)  
bf3b 32 7c ee			ld (debug_mark+2),a  
bf3e 18 03			jr .pastdmark  
bf40 ..			.dmark: db "LEF"  
bf43 f1			.pastdmark: pop af  
bf44			endm  
# End of macro DMARK
bf44						CALLMONITOR 
bf44 cd 03 93			call break_point_state  
bf47				endm  
# End of macro CALLMONITOR
bf47					endif 
bf47			 
bf47					NEXTW 
bf47 c3 f9 9b			jp macro_next 
bf4a				endm 
# End of macro NEXTW
bf4a			.RIGHT: 
bf4a				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
bf4a 48				db WORD_SYS_CORE+52             
bf4b 73 bf			dw .STR2NUM            
bf4d 06				db 5 + 1 
bf4e .. 00			db "RIGHT",0              
bf54				endm 
# End of macro CWHEAD
bf54			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
bf54					if DEBUG_FORTH_WORDS_KEY 
bf54						DMARK "RIG" 
bf54 f5				push af  
bf55 3a 69 bf			ld a, (.dmark)  
bf58 32 7a ee			ld (debug_mark),a  
bf5b 3a 6a bf			ld a, (.dmark+1)  
bf5e 32 7b ee			ld (debug_mark+1),a  
bf61 3a 6b bf			ld a, (.dmark+2)  
bf64 32 7c ee			ld (debug_mark+2),a  
bf67 18 03			jr .pastdmark  
bf69 ..			.dmark: db "RIG"  
bf6c f1			.pastdmark: pop af  
bf6d			endm  
# End of macro DMARK
bf6d						CALLMONITOR 
bf6d cd 03 93			call break_point_state  
bf70				endm  
# End of macro CALLMONITOR
bf70					endif 
bf70			 
bf70					NEXTW 
bf70 c3 f9 9b			jp macro_next 
bf73				endm 
# End of macro NEXTW
bf73			 
bf73			 
bf73			.STR2NUM: 
bf73				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
bf73 48				db WORD_SYS_CORE+52             
bf74 ff bf			dw .NUM2STR            
bf76 08				db 7 + 1 
bf77 .. 00			db "STR2NUM",0              
bf7f				endm 
# End of macro CWHEAD
bf7f			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
bf7f			 
bf7f			 
bf7f			; TODO STR type check to do 
bf7f					if DEBUG_FORTH_WORDS_KEY 
bf7f						DMARK "S2N" 
bf7f f5				push af  
bf80 3a 94 bf			ld a, (.dmark)  
bf83 32 7a ee			ld (debug_mark),a  
bf86 3a 95 bf			ld a, (.dmark+1)  
bf89 32 7b ee			ld (debug_mark+1),a  
bf8c 3a 96 bf			ld a, (.dmark+2)  
bf8f 32 7c ee			ld (debug_mark+2),a  
bf92 18 03			jr .pastdmark  
bf94 ..			.dmark: db "S2N"  
bf97 f1			.pastdmark: pop af  
bf98			endm  
# End of macro DMARK
bf98						CALLMONITOR 
bf98 cd 03 93			call break_point_state  
bf9b				endm  
# End of macro CALLMONITOR
bf9b					endif 
bf9b			 
bf9b					;FORTH_DSP 
bf9b					FORTH_DSP_VALUE 
bf9b cd 70 9a			call macro_forth_dsp_value 
bf9e				endm 
# End of macro FORTH_DSP_VALUE
bf9e					;inc hl 
bf9e			 
bf9e eb					ex de, hl 
bf9f					if DEBUG_FORTH_WORDS 
bf9f						DMARK "S2a" 
bf9f f5				push af  
bfa0 3a b4 bf			ld a, (.dmark)  
bfa3 32 7a ee			ld (debug_mark),a  
bfa6 3a b5 bf			ld a, (.dmark+1)  
bfa9 32 7b ee			ld (debug_mark+1),a  
bfac 3a b6 bf			ld a, (.dmark+2)  
bfaf 32 7c ee			ld (debug_mark+2),a  
bfb2 18 03			jr .pastdmark  
bfb4 ..			.dmark: db "S2a"  
bfb7 f1			.pastdmark: pop af  
bfb8			endm  
# End of macro DMARK
bfb8						CALLMONITOR 
bfb8 cd 03 93			call break_point_state  
bfbb				endm  
# End of macro CALLMONITOR
bfbb					endif 
bfbb cd 9c 8e				call string_to_uint16 
bfbe			 
bfbe					if DEBUG_FORTH_WORDS 
bfbe						DMARK "S2b" 
bfbe f5				push af  
bfbf 3a d3 bf			ld a, (.dmark)  
bfc2 32 7a ee			ld (debug_mark),a  
bfc5 3a d4 bf			ld a, (.dmark+1)  
bfc8 32 7b ee			ld (debug_mark+1),a  
bfcb 3a d5 bf			ld a, (.dmark+2)  
bfce 32 7c ee			ld (debug_mark+2),a  
bfd1 18 03			jr .pastdmark  
bfd3 ..			.dmark: db "S2b"  
bfd6 f1			.pastdmark: pop af  
bfd7			endm  
# End of macro DMARK
bfd7						CALLMONITOR 
bfd7 cd 03 93			call break_point_state  
bfda				endm  
# End of macro CALLMONITOR
bfda					endif 
bfda			;		push hl 
bfda					FORTH_DSP_POP 
bfda cd 3f 9b			call macro_forth_dsp_pop 
bfdd				endm 
# End of macro FORTH_DSP_POP
bfdd			;		pop hl 
bfdd					 
bfdd					if DEBUG_FORTH_WORDS 
bfdd						DMARK "S2b" 
bfdd f5				push af  
bfde 3a f2 bf			ld a, (.dmark)  
bfe1 32 7a ee			ld (debug_mark),a  
bfe4 3a f3 bf			ld a, (.dmark+1)  
bfe7 32 7b ee			ld (debug_mark+1),a  
bfea 3a f4 bf			ld a, (.dmark+2)  
bfed 32 7c ee			ld (debug_mark+2),a  
bff0 18 03			jr .pastdmark  
bff2 ..			.dmark: db "S2b"  
bff5 f1			.pastdmark: pop af  
bff6			endm  
# End of macro DMARK
bff6						CALLMONITOR 
bff6 cd 03 93			call break_point_state  
bff9				endm  
# End of macro CALLMONITOR
bff9					endif 
bff9 cd 90 98				call forth_push_numhl	 
bffc			 
bffc				 
bffc				       NEXTW 
bffc c3 f9 9b			jp macro_next 
bfff				endm 
# End of macro NEXTW
bfff			.NUM2STR: 
bfff				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
bfff 48				db WORD_SYS_CORE+52             
c000 0e c0			dw .CONCAT            
c002 08				db 7 + 1 
c003 .. 00			db "NUM2STR",0              
c00b				endm 
# End of macro CWHEAD
c00b			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
c00b			 
c00b			;		; malloc a string to target 
c00b			;		ld hl, 10     ; TODO max string size should be fine 
c00b			;		call malloc 
c00b			;		push hl    ; save malloc location 
c00b			; 
c00b			; 
c00b			;; TODO check int type 
c00b			;		FORTH_DSP_VALUEHL 
c00b			;		ld a, l 
c00b			;		call DispAToASCII   
c00b			;;TODO need to chage above call to dump into string 
c00b			; 
c00b			; 
c00b			 
c00b				       NEXTW 
c00b c3 f9 9b			jp macro_next 
c00e				endm 
# End of macro NEXTW
c00e			 
c00e			.CONCAT: 
c00e				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c00e 48				db WORD_SYS_CORE+52             
c00f c1 c0			dw .FIND            
c011 07				db 6 + 1 
c012 .. 00			db "CONCAT",0              
c019				endm 
# End of macro CWHEAD
c019			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c019			 
c019			; TODO check string type 
c019			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c019			 
c019					if DEBUG_FORTH_WORDS_KEY 
c019						DMARK "CON" 
c019 f5				push af  
c01a 3a 2e c0			ld a, (.dmark)  
c01d 32 7a ee			ld (debug_mark),a  
c020 3a 2f c0			ld a, (.dmark+1)  
c023 32 7b ee			ld (debug_mark+1),a  
c026 3a 30 c0			ld a, (.dmark+2)  
c029 32 7c ee			ld (debug_mark+2),a  
c02c 18 03			jr .pastdmark  
c02e ..			.dmark: db "CON"  
c031 f1			.pastdmark: pop af  
c032			endm  
# End of macro DMARK
c032						CALLMONITOR 
c032 cd 03 93			call break_point_state  
c035				endm  
# End of macro CALLMONITOR
c035					endif 
c035			 
c035			 
c035					FORTH_DSP_VALUE 
c035 cd 70 9a			call macro_forth_dsp_value 
c038				endm 
# End of macro FORTH_DSP_VALUE
c038 e5					push hl   ; s2 
c039			 
c039					FORTH_DSP_POP 
c039 cd 3f 9b			call macro_forth_dsp_pop 
c03c				endm 
# End of macro FORTH_DSP_POP
c03c			 
c03c					FORTH_DSP_VALUE 
c03c cd 70 9a			call macro_forth_dsp_value 
c03f				endm 
# End of macro FORTH_DSP_VALUE
c03f			 
c03f e5					push hl   ; s1 
c040			 
c040					FORTH_DSP_POP 
c040 cd 3f 9b			call macro_forth_dsp_pop 
c043				endm 
# End of macro FORTH_DSP_POP
c043					 
c043			 
c043					; copy s1 
c043			 
c043				 
c043					; save ptr 
c043 e1					pop hl  
c044 e5					push hl 
c045 3e 00				ld a, 0 
c047 cd 10 8f				call strlent 
c04a					;inc hl    ; zer0 
c04a 06 00				ld b, 0 
c04c 4d					ld c, l 
c04d e1					pop hl		 
c04e 11 60 e3				ld de, scratch	 
c051					if DEBUG_FORTH_WORDS 
c051						DMARK "CO1" 
c051 f5				push af  
c052 3a 66 c0			ld a, (.dmark)  
c055 32 7a ee			ld (debug_mark),a  
c058 3a 67 c0			ld a, (.dmark+1)  
c05b 32 7b ee			ld (debug_mark+1),a  
c05e 3a 68 c0			ld a, (.dmark+2)  
c061 32 7c ee			ld (debug_mark+2),a  
c064 18 03			jr .pastdmark  
c066 ..			.dmark: db "CO1"  
c069 f1			.pastdmark: pop af  
c06a			endm  
# End of macro DMARK
c06a						CALLMONITOR 
c06a cd 03 93			call break_point_state  
c06d				endm  
# End of macro CALLMONITOR
c06d					endif 
c06d ed b0				ldir 
c06f			 
c06f e1					pop hl 
c070 e5					push hl 
c071 d5					push de 
c072			 
c072			 
c072 3e 00				ld a, 0 
c074 cd 10 8f				call strlent 
c077 23					inc hl    ; zer0 
c078 23					inc hl 
c079 06 00				ld b, 0 
c07b 4d					ld c, l 
c07c d1					pop de 
c07d e1					pop hl		 
c07e					if DEBUG_FORTH_WORDS 
c07e						DMARK "CO2" 
c07e f5				push af  
c07f 3a 93 c0			ld a, (.dmark)  
c082 32 7a ee			ld (debug_mark),a  
c085 3a 94 c0			ld a, (.dmark+1)  
c088 32 7b ee			ld (debug_mark+1),a  
c08b 3a 95 c0			ld a, (.dmark+2)  
c08e 32 7c ee			ld (debug_mark+2),a  
c091 18 03			jr .pastdmark  
c093 ..			.dmark: db "CO2"  
c096 f1			.pastdmark: pop af  
c097			endm  
# End of macro DMARK
c097						CALLMONITOR 
c097 cd 03 93			call break_point_state  
c09a				endm  
# End of macro CALLMONITOR
c09a					endif 
c09a ed b0				ldir 
c09c			 
c09c			 
c09c			 
c09c 21 60 e3				ld hl, scratch 
c09f					if DEBUG_FORTH_WORDS 
c09f						DMARK "CO5" 
c09f f5				push af  
c0a0 3a b4 c0			ld a, (.dmark)  
c0a3 32 7a ee			ld (debug_mark),a  
c0a6 3a b5 c0			ld a, (.dmark+1)  
c0a9 32 7b ee			ld (debug_mark+1),a  
c0ac 3a b6 c0			ld a, (.dmark+2)  
c0af 32 7c ee			ld (debug_mark+2),a  
c0b2 18 03			jr .pastdmark  
c0b4 ..			.dmark: db "CO5"  
c0b7 f1			.pastdmark: pop af  
c0b8			endm  
# End of macro DMARK
c0b8						CALLMONITOR 
c0b8 cd 03 93			call break_point_state  
c0bb				endm  
# End of macro CALLMONITOR
c0bb					endif 
c0bb			 
c0bb cd fe 98				call forth_push_str 
c0be			 
c0be			 
c0be			 
c0be			 
c0be				       NEXTW 
c0be c3 f9 9b			jp macro_next 
c0c1				endm 
# End of macro NEXTW
c0c1			 
c0c1			 
c0c1			.FIND: 
c0c1				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c0c1 4b				db WORD_SYS_CORE+55             
c0c2 7f c1			dw .LEN            
c0c4 05				db 4 + 1 
c0c5 .. 00			db "FIND",0              
c0ca				endm 
# End of macro CWHEAD
c0ca			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c0ca			 
c0ca					if DEBUG_FORTH_WORDS_KEY 
c0ca						DMARK "FND" 
c0ca f5				push af  
c0cb 3a df c0			ld a, (.dmark)  
c0ce 32 7a ee			ld (debug_mark),a  
c0d1 3a e0 c0			ld a, (.dmark+1)  
c0d4 32 7b ee			ld (debug_mark+1),a  
c0d7 3a e1 c0			ld a, (.dmark+2)  
c0da 32 7c ee			ld (debug_mark+2),a  
c0dd 18 03			jr .pastdmark  
c0df ..			.dmark: db "FND"  
c0e2 f1			.pastdmark: pop af  
c0e3			endm  
# End of macro DMARK
c0e3						CALLMONITOR 
c0e3 cd 03 93			call break_point_state  
c0e6				endm  
# End of macro CALLMONITOR
c0e6					endif 
c0e6			 
c0e6			; TODO check string type 
c0e6					FORTH_DSP_VALUE 
c0e6 cd 70 9a			call macro_forth_dsp_value 
c0e9				endm 
# End of macro FORTH_DSP_VALUE
c0e9			 
c0e9 e5					push hl    
c0ea 7e					ld a,(hl)    ; char to find   
c0eb			; TODO change char to substr 
c0eb			 
c0eb f5					push af 
c0ec					 
c0ec			 
c0ec			 
c0ec					if DEBUG_FORTH_WORDS 
c0ec						DMARK "FN1" 
c0ec f5				push af  
c0ed 3a 01 c1			ld a, (.dmark)  
c0f0 32 7a ee			ld (debug_mark),a  
c0f3 3a 02 c1			ld a, (.dmark+1)  
c0f6 32 7b ee			ld (debug_mark+1),a  
c0f9 3a 03 c1			ld a, (.dmark+2)  
c0fc 32 7c ee			ld (debug_mark+2),a  
c0ff 18 03			jr .pastdmark  
c101 ..			.dmark: db "FN1"  
c104 f1			.pastdmark: pop af  
c105			endm  
# End of macro DMARK
c105						CALLMONITOR 
c105 cd 03 93			call break_point_state  
c108				endm  
# End of macro CALLMONITOR
c108					endif 
c108			 
c108					FORTH_DSP_POP 
c108 cd 3f 9b			call macro_forth_dsp_pop 
c10b				endm 
# End of macro FORTH_DSP_POP
c10b			 
c10b					; string to search 
c10b			 
c10b					FORTH_DSP_VALUE 
c10b cd 70 9a			call macro_forth_dsp_value 
c10e				endm 
# End of macro FORTH_DSP_VALUE
c10e			 
c10e d1					pop de  ; d is char to find  
c10f			 
c10f					if DEBUG_FORTH_WORDS 
c10f						DMARK "FN2" 
c10f f5				push af  
c110 3a 24 c1			ld a, (.dmark)  
c113 32 7a ee			ld (debug_mark),a  
c116 3a 25 c1			ld a, (.dmark+1)  
c119 32 7b ee			ld (debug_mark+1),a  
c11c 3a 26 c1			ld a, (.dmark+2)  
c11f 32 7c ee			ld (debug_mark+2),a  
c122 18 03			jr .pastdmark  
c124 ..			.dmark: db "FN2"  
c127 f1			.pastdmark: pop af  
c128			endm  
# End of macro DMARK
c128						CALLMONITOR 
c128 cd 03 93			call break_point_state  
c12b				endm  
# End of macro CALLMONITOR
c12b					endif 
c12b					 
c12b 01 00 00				ld bc, 0 
c12e 7e			.findchar:      ld a,(hl) 
c12f fe 00				cp 0   		 
c131 28 27				jr z, .finddone     
c133 ba					cp d 
c134 28 20				jr z, .foundchar 
c136 03					inc bc 
c137 23					inc hl 
c138					if DEBUG_FORTH_WORDS 
c138						DMARK "FN3" 
c138 f5				push af  
c139 3a 4d c1			ld a, (.dmark)  
c13c 32 7a ee			ld (debug_mark),a  
c13f 3a 4e c1			ld a, (.dmark+1)  
c142 32 7b ee			ld (debug_mark+1),a  
c145 3a 4f c1			ld a, (.dmark+2)  
c148 32 7c ee			ld (debug_mark+2),a  
c14b 18 03			jr .pastdmark  
c14d ..			.dmark: db "FN3"  
c150 f1			.pastdmark: pop af  
c151			endm  
# End of macro DMARK
c151						CALLMONITOR 
c151 cd 03 93			call break_point_state  
c154				endm  
# End of macro CALLMONITOR
c154					endif 
c154 18 d8				jr .findchar 
c156			 
c156			 
c156 c5			.foundchar:	push bc 
c157 e1					pop hl 
c158 18 03				jr .findexit 
c15a			 
c15a			 
c15a							 
c15a			 
c15a			.finddone:     ; got to end of string with no find 
c15a 21 00 00				ld hl, 0 
c15d			.findexit: 
c15d			 
c15d					if DEBUG_FORTH_WORDS 
c15d						DMARK "FNd" 
c15d f5				push af  
c15e 3a 72 c1			ld a, (.dmark)  
c161 32 7a ee			ld (debug_mark),a  
c164 3a 73 c1			ld a, (.dmark+1)  
c167 32 7b ee			ld (debug_mark+1),a  
c16a 3a 74 c1			ld a, (.dmark+2)  
c16d 32 7c ee			ld (debug_mark+2),a  
c170 18 03			jr .pastdmark  
c172 ..			.dmark: db "FNd"  
c175 f1			.pastdmark: pop af  
c176			endm  
# End of macro DMARK
c176						CALLMONITOR 
c176 cd 03 93			call break_point_state  
c179				endm  
# End of macro CALLMONITOR
c179					endif 
c179 cd 90 98			call forth_push_numhl 
c17c			 
c17c				       NEXTW 
c17c c3 f9 9b			jp macro_next 
c17f				endm 
# End of macro NEXTW
c17f			 
c17f			.LEN: 
c17f				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
c17f 4c				db WORD_SYS_CORE+56             
c180 b4 c1			dw .CHAR            
c182 06				db 5 + 1 
c183 .. 00			db "COUNT",0              
c189				endm 
# End of macro CWHEAD
c189			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
c189			 
c189					if DEBUG_FORTH_WORDS_KEY 
c189						DMARK "CNT" 
c189 f5				push af  
c18a 3a 9e c1			ld a, (.dmark)  
c18d 32 7a ee			ld (debug_mark),a  
c190 3a 9f c1			ld a, (.dmark+1)  
c193 32 7b ee			ld (debug_mark+1),a  
c196 3a a0 c1			ld a, (.dmark+2)  
c199 32 7c ee			ld (debug_mark+2),a  
c19c 18 03			jr .pastdmark  
c19e ..			.dmark: db "CNT"  
c1a1 f1			.pastdmark: pop af  
c1a2			endm  
# End of macro DMARK
c1a2						CALLMONITOR 
c1a2 cd 03 93			call break_point_state  
c1a5				endm  
# End of macro CALLMONITOR
c1a5					endif 
c1a5			; TODO check string type 
c1a5					FORTH_DSP 
c1a5 cd 4d 9a			call macro_forth_dsp 
c1a8				endm 
# End of macro FORTH_DSP
c1a8					;v5FORTH_DSP_VALUE 
c1a8			 
c1a8 23					inc hl 
c1a9			 
c1a9 3e 00				ld a, 0 
c1ab cd 10 8f				call strlent 
c1ae			 
c1ae cd 90 98				call forth_push_numhl 
c1b1			 
c1b1			 
c1b1			 
c1b1				       NEXTW 
c1b1 c3 f9 9b			jp macro_next 
c1b4				endm 
# End of macro NEXTW
c1b4			.CHAR: 
c1b4				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
c1b4 4d				db WORD_SYS_CORE+57             
c1b5 ea c1			dw .ENDSTR            
c1b7 05				db 4 + 1 
c1b8 .. 00			db "CHAR",0              
c1bd				endm 
# End of macro CWHEAD
c1bd			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c1bd					if DEBUG_FORTH_WORDS_KEY 
c1bd						DMARK "CHR" 
c1bd f5				push af  
c1be 3a d2 c1			ld a, (.dmark)  
c1c1 32 7a ee			ld (debug_mark),a  
c1c4 3a d3 c1			ld a, (.dmark+1)  
c1c7 32 7b ee			ld (debug_mark+1),a  
c1ca 3a d4 c1			ld a, (.dmark+2)  
c1cd 32 7c ee			ld (debug_mark+2),a  
c1d0 18 03			jr .pastdmark  
c1d2 ..			.dmark: db "CHR"  
c1d5 f1			.pastdmark: pop af  
c1d6			endm  
# End of macro DMARK
c1d6						CALLMONITOR 
c1d6 cd 03 93			call break_point_state  
c1d9				endm  
# End of macro CALLMONITOR
c1d9					endif 
c1d9					FORTH_DSP 
c1d9 cd 4d 9a			call macro_forth_dsp 
c1dc				endm 
# End of macro FORTH_DSP
c1dc					;v5 FORTH_DSP_VALUE 
c1dc 23					inc hl      ; now at start of numeric as string 
c1dd			 
c1dd			;		push hl 
c1dd			 
c1dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c1dd cd 3f 9b			call macro_forth_dsp_pop 
c1e0				endm 
# End of macro FORTH_DSP_POP
c1e0			 
c1e0			;		pop hl 
c1e0			 
c1e0					; push the content of a onto the stack as a value 
c1e0			 
c1e0 7e					ld a,(hl)   ; get char 
c1e1 26 00				ld h,0 
c1e3 6f					ld l,a 
c1e4 cd 90 98				call forth_push_numhl 
c1e7			 
c1e7				       NEXTW 
c1e7 c3 f9 9b			jp macro_next 
c1ea				endm 
# End of macro NEXTW
c1ea			 
c1ea			 
c1ea			 
c1ea			 
c1ea			.ENDSTR: 
c1ea			; eof 
c1ea			 
# End of file forth_words_str.asm
c1ea			include "forth_words_key.asm" 
c1ea			 
c1ea			; | ## Keyboard Words 
c1ea			 
c1ea			.KEY: 
c1ea				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c1ea 3e				db WORD_SYS_CORE+42             
c1eb 1a c2			dw .WAITK            
c1ed 04				db 3 + 1 
c1ee .. 00			db "KEY",0              
c1f2				endm 
# End of macro CWHEAD
c1f2			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c1f2			 
c1f2					if DEBUG_FORTH_WORDS_KEY 
c1f2						DMARK "KEY" 
c1f2 f5				push af  
c1f3 3a 07 c2			ld a, (.dmark)  
c1f6 32 7a ee			ld (debug_mark),a  
c1f9 3a 08 c2			ld a, (.dmark+1)  
c1fc 32 7b ee			ld (debug_mark+1),a  
c1ff 3a 09 c2			ld a, (.dmark+2)  
c202 32 7c ee			ld (debug_mark+2),a  
c205 18 03			jr .pastdmark  
c207 ..			.dmark: db "KEY"  
c20a f1			.pastdmark: pop af  
c20b			endm  
# End of macro DMARK
c20b						CALLMONITOR 
c20b cd 03 93			call break_point_state  
c20e				endm  
# End of macro CALLMONITOR
c20e					endif 
c20e			; TODO currently waits 
c20e cd 74 d8				call cin 
c211					;call cin_wait 
c211 6f					ld l, a 
c212 26 00				ld h, 0 
c214 cd 90 98				call forth_push_numhl 
c217					NEXTW 
c217 c3 f9 9b			jp macro_next 
c21a				endm 
# End of macro NEXTW
c21a			.WAITK: 
c21a				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c21a 3f				db WORD_SYS_CORE+43             
c21b 4c c2			dw .ACCEPT            
c21d 06				db 5 + 1 
c21e .. 00			db "WAITK",0              
c224				endm 
# End of macro CWHEAD
c224			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c224					if DEBUG_FORTH_WORDS_KEY 
c224						DMARK "WAI" 
c224 f5				push af  
c225 3a 39 c2			ld a, (.dmark)  
c228 32 7a ee			ld (debug_mark),a  
c22b 3a 3a c2			ld a, (.dmark+1)  
c22e 32 7b ee			ld (debug_mark+1),a  
c231 3a 3b c2			ld a, (.dmark+2)  
c234 32 7c ee			ld (debug_mark+2),a  
c237 18 03			jr .pastdmark  
c239 ..			.dmark: db "WAI"  
c23c f1			.pastdmark: pop af  
c23d			endm  
# End of macro DMARK
c23d						CALLMONITOR 
c23d cd 03 93			call break_point_state  
c240				endm  
# End of macro CALLMONITOR
c240					endif 
c240 cd 6e d8				call cin_wait 
c243 6f					ld l, a 
c244 26 00				ld h, 0 
c246 cd 90 98				call forth_push_numhl 
c249					NEXTW 
c249 c3 f9 9b			jp macro_next 
c24c				endm 
# End of macro NEXTW
c24c			.ACCEPT: 
c24c				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c24c 40				db WORD_SYS_CORE+44             
c24d aa c2			dw .EDIT            
c24f 07				db 6 + 1 
c250 .. 00			db "ACCEPT",0              
c257				endm 
# End of macro CWHEAD
c257			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c257					; TODO crashes on push 
c257					if DEBUG_FORTH_WORDS_KEY 
c257						DMARK "ACC" 
c257 f5				push af  
c258 3a 6c c2			ld a, (.dmark)  
c25b 32 7a ee			ld (debug_mark),a  
c25e 3a 6d c2			ld a, (.dmark+1)  
c261 32 7b ee			ld (debug_mark+1),a  
c264 3a 6e c2			ld a, (.dmark+2)  
c267 32 7c ee			ld (debug_mark+2),a  
c26a 18 03			jr .pastdmark  
c26c ..			.dmark: db "ACC"  
c26f f1			.pastdmark: pop af  
c270			endm  
# End of macro DMARK
c270						CALLMONITOR 
c270 cd 03 93			call break_point_state  
c273				endm  
# End of macro CALLMONITOR
c273					endif 
c273 21 5e e5				ld hl, os_input 
c276 3e 00				ld a, 0 
c278 77					ld (hl),a 
c279 3a 49 eb				ld a,(f_cursor_ptr) 
c27c 16 64				ld d, 100 
c27e 0e 00				ld c, 0 
c280 1e 28				ld e, 40 
c282 cd d4 8a				call input_str 
c285					; TODO perhaps do a type check and wrap in quotes if not a number 
c285 21 5e e5				ld hl, os_input 
c288					if DEBUG_FORTH_WORDS 
c288						DMARK "AC1" 
c288 f5				push af  
c289 3a 9d c2			ld a, (.dmark)  
c28c 32 7a ee			ld (debug_mark),a  
c28f 3a 9e c2			ld a, (.dmark+1)  
c292 32 7b ee			ld (debug_mark+1),a  
c295 3a 9f c2			ld a, (.dmark+2)  
c298 32 7c ee			ld (debug_mark+2),a  
c29b 18 03			jr .pastdmark  
c29d ..			.dmark: db "AC1"  
c2a0 f1			.pastdmark: pop af  
c2a1			endm  
# End of macro DMARK
c2a1						CALLMONITOR 
c2a1 cd 03 93			call break_point_state  
c2a4				endm  
# End of macro CALLMONITOR
c2a4					endif 
c2a4 cd fe 98				call forth_push_str 
c2a7					NEXTW 
c2a7 c3 f9 9b			jp macro_next 
c2aa				endm 
# End of macro NEXTW
c2aa			 
c2aa			.EDIT: 
c2aa				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
c2aa 40				db WORD_SYS_CORE+44             
c2ab 33 c3			dw .ENDKEY            
c2ad 05				db 4 + 1 
c2ae .. 00			db "EDIT",0              
c2b3				endm 
# End of macro CWHEAD
c2b3			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c2b3			 
c2b3					; TODO does not copy from stack 
c2b3					if DEBUG_FORTH_WORDS_KEY 
c2b3						DMARK "EDT" 
c2b3 f5				push af  
c2b4 3a c8 c2			ld a, (.dmark)  
c2b7 32 7a ee			ld (debug_mark),a  
c2ba 3a c9 c2			ld a, (.dmark+1)  
c2bd 32 7b ee			ld (debug_mark+1),a  
c2c0 3a ca c2			ld a, (.dmark+2)  
c2c3 32 7c ee			ld (debug_mark+2),a  
c2c6 18 03			jr .pastdmark  
c2c8 ..			.dmark: db "EDT"  
c2cb f1			.pastdmark: pop af  
c2cc			endm  
# End of macro DMARK
c2cc						CALLMONITOR 
c2cc cd 03 93			call break_point_state  
c2cf				endm  
# End of macro CALLMONITOR
c2cf					endif 
c2cf			 
c2cf					FORTH_DSP 
c2cf cd 4d 9a			call macro_forth_dsp 
c2d2				endm 
# End of macro FORTH_DSP
c2d2					;v5 FORTH_DSP_VALUE 
c2d2 23					inc hl    ; TODO do type check 
c2d3			 
c2d3 e5					push hl 
c2d4 3e 00				ld a, 0 
c2d6 cd 10 8f				call strlent 
c2d9 23					inc hl 
c2da			 
c2da 06 00				ld b, 0 
c2dc 4d					ld c, l 
c2dd			 
c2dd e1					pop hl 
c2de 11 5e e5				ld de, os_input 
c2e1					if DEBUG_FORTH_WORDS_KEY 
c2e1						DMARK "EDc" 
c2e1 f5				push af  
c2e2 3a f6 c2			ld a, (.dmark)  
c2e5 32 7a ee			ld (debug_mark),a  
c2e8 3a f7 c2			ld a, (.dmark+1)  
c2eb 32 7b ee			ld (debug_mark+1),a  
c2ee 3a f8 c2			ld a, (.dmark+2)  
c2f1 32 7c ee			ld (debug_mark+2),a  
c2f4 18 03			jr .pastdmark  
c2f6 ..			.dmark: db "EDc"  
c2f9 f1			.pastdmark: pop af  
c2fa			endm  
# End of macro DMARK
c2fa						CALLMONITOR 
c2fa cd 03 93			call break_point_state  
c2fd				endm  
# End of macro CALLMONITOR
c2fd					endif 
c2fd ed b0				ldir 
c2ff			 
c2ff			 
c2ff 21 5e e5				ld hl, os_input 
c302					;ld a, 0 
c302					;ld (hl),a 
c302 3a 49 eb				ld a,(f_cursor_ptr) 
c305 16 64				ld d, 100 
c307 0e 00				ld c, 0 
c309 1e 28				ld e, 40 
c30b cd d4 8a				call input_str 
c30e					; TODO perhaps do a type check and wrap in quotes if not a number 
c30e 21 5e e5				ld hl, os_input 
c311					if DEBUG_FORTH_WORDS 
c311						DMARK "ED1" 
c311 f5				push af  
c312 3a 26 c3			ld a, (.dmark)  
c315 32 7a ee			ld (debug_mark),a  
c318 3a 27 c3			ld a, (.dmark+1)  
c31b 32 7b ee			ld (debug_mark+1),a  
c31e 3a 28 c3			ld a, (.dmark+2)  
c321 32 7c ee			ld (debug_mark+2),a  
c324 18 03			jr .pastdmark  
c326 ..			.dmark: db "ED1"  
c329 f1			.pastdmark: pop af  
c32a			endm  
# End of macro DMARK
c32a						CALLMONITOR 
c32a cd 03 93			call break_point_state  
c32d				endm  
# End of macro CALLMONITOR
c32d					endif 
c32d cd fe 98				call forth_push_str 
c330					NEXTW 
c330 c3 f9 9b			jp macro_next 
c333				endm 
# End of macro NEXTW
c333			 
c333			 
c333			 
c333			.ENDKEY: 
c333			; eof 
c333			 
# End of file forth_words_key.asm
c333			 
c333			if STORAGE_SE 
c333			   	include "forth_words_storage.asm" 
c333			endif 
c333				include "forth_words_device.asm" 
c333			; Device related words 
c333			 
c333			; | ## Device Words 
c333			 
c333			if SOUND_ENABLE 
c333			.NOTE: 
c333				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c333			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c333					if DEBUG_FORTH_WORDS_KEY 
c333						DMARK "NTE" 
c333						CALLMONITOR 
c333					endif 
c333			 
c333				 
c333			 
c333					NEXTW 
c333			.AFTERSOUND: 
c333			endif 
c333			 
c333			 
c333			USE_GPIO: equ 0 
c333			 
c333			if USE_GPIO 
c333			.GP1: 
c333				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c333			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c333					NEXTW 
c333			.GP2: 
c333				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c333			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c333			 
c333					NEXTW 
c333			 
c333			.GP3: 
c333				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c333			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c333			 
c333					NEXTW 
c333			 
c333			.GP4: 
c333				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c333			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c333			 
c333					NEXTW 
c333			.SIN: 
c333			 
c333			 
c333			endif 
c333			 
c333			 
c333				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c333 33				db WORD_SYS_CORE+31             
c334 68 c3			dw .SOUT            
c336 03				db 2 + 1 
c337 .. 00			db "IN",0              
c33a				endm 
# End of macro CWHEAD
c33a			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c33a					if DEBUG_FORTH_WORDS_KEY 
c33a						DMARK "IN." 
c33a f5				push af  
c33b 3a 4f c3			ld a, (.dmark)  
c33e 32 7a ee			ld (debug_mark),a  
c341 3a 50 c3			ld a, (.dmark+1)  
c344 32 7b ee			ld (debug_mark+1),a  
c347 3a 51 c3			ld a, (.dmark+2)  
c34a 32 7c ee			ld (debug_mark+2),a  
c34d 18 03			jr .pastdmark  
c34f ..			.dmark: db "IN."  
c352 f1			.pastdmark: pop af  
c353			endm  
# End of macro DMARK
c353						CALLMONITOR 
c353 cd 03 93			call break_point_state  
c356				endm  
# End of macro CALLMONITOR
c356					endif 
c356					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c356 cd 87 9a			call macro_dsp_valuehl 
c359				endm 
# End of macro FORTH_DSP_VALUEHL
c359			 
c359 e5					push hl 
c35a			 
c35a					; destroy value TOS 
c35a			 
c35a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c35a cd 3f 9b			call macro_forth_dsp_pop 
c35d				endm 
# End of macro FORTH_DSP_POP
c35d			 
c35d					; one value on hl get other one back 
c35d			 
c35d c1					pop bc 
c35e			 
c35e					; do the sub 
c35e			;		ex de, hl 
c35e			 
c35e ed 68				in l,(c) 
c360			 
c360					; save it 
c360			 
c360 26 00				ld h,0 
c362			 
c362					; TODO push value back onto stack for another op etc 
c362			 
c362 cd 90 98				call forth_push_numhl 
c365					NEXTW 
c365 c3 f9 9b			jp macro_next 
c368				endm 
# End of macro NEXTW
c368			.SOUT: 
c368				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c368 34				db WORD_SYS_CORE+32             
c369 bb c3			dw .SPIO            
c36b 04				db 3 + 1 
c36c .. 00			db "OUT",0              
c370				endm 
# End of macro CWHEAD
c370			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c370					if DEBUG_FORTH_WORDS_KEY 
c370						DMARK "OUT" 
c370 f5				push af  
c371 3a 85 c3			ld a, (.dmark)  
c374 32 7a ee			ld (debug_mark),a  
c377 3a 86 c3			ld a, (.dmark+1)  
c37a 32 7b ee			ld (debug_mark+1),a  
c37d 3a 87 c3			ld a, (.dmark+2)  
c380 32 7c ee			ld (debug_mark+2),a  
c383 18 03			jr .pastdmark  
c385 ..			.dmark: db "OUT"  
c388 f1			.pastdmark: pop af  
c389			endm  
# End of macro DMARK
c389						CALLMONITOR 
c389 cd 03 93			call break_point_state  
c38c				endm  
# End of macro CALLMONITOR
c38c					endif 
c38c			 
c38c					; get port 
c38c			 
c38c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c38c cd 87 9a			call macro_dsp_valuehl 
c38f				endm 
# End of macro FORTH_DSP_VALUEHL
c38f			 
c38f e5					push hl 
c390			 
c390					; destroy value TOS 
c390			 
c390					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c390 cd 3f 9b			call macro_forth_dsp_pop 
c393				endm 
# End of macro FORTH_DSP_POP
c393			 
c393					; get byte to send 
c393			 
c393					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c393 cd 87 9a			call macro_dsp_valuehl 
c396				endm 
# End of macro FORTH_DSP_VALUEHL
c396			 
c396			;		push hl 
c396			 
c396					; destroy value TOS 
c396			 
c396					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c396 cd 3f 9b			call macro_forth_dsp_pop 
c399				endm 
# End of macro FORTH_DSP_POP
c399			 
c399					; one value on hl get other one back 
c399			 
c399			;		pop hl 
c399			 
c399 c1					pop bc 
c39a			 
c39a					if DEBUG_FORTH_WORDS 
c39a						DMARK "OUT" 
c39a f5				push af  
c39b 3a af c3			ld a, (.dmark)  
c39e 32 7a ee			ld (debug_mark),a  
c3a1 3a b0 c3			ld a, (.dmark+1)  
c3a4 32 7b ee			ld (debug_mark+1),a  
c3a7 3a b1 c3			ld a, (.dmark+2)  
c3aa 32 7c ee			ld (debug_mark+2),a  
c3ad 18 03			jr .pastdmark  
c3af ..			.dmark: db "OUT"  
c3b2 f1			.pastdmark: pop af  
c3b3			endm  
# End of macro DMARK
c3b3						CALLMONITOR 
c3b3 cd 03 93			call break_point_state  
c3b6				endm  
# End of macro CALLMONITOR
c3b6					endif 
c3b6			 
c3b6 ed 69				out (c), l 
c3b8			 
c3b8					NEXTW 
c3b8 c3 f9 9b			jp macro_next 
c3bb				endm 
# End of macro NEXTW
c3bb			 
c3bb			 
c3bb			.SPIO: 
c3bb			 
c3bb			if STORAGE_SE 
c3bb				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c3bb			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c3bb			 
c3bb					call spi_ce_low 
c3bb			    NEXTW 
c3bb			 
c3bb			.SPICEH: 
c3bb				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c3bb			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c3bb			 
c3bb					call spi_ce_high 
c3bb			    NEXTW 
c3bb			 
c3bb			 
c3bb			.SPIOb: 
c3bb			 
c3bb				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c3bb			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c3bb			 
c3bb					; get port 
c3bb			 
c3bb			 
c3bb					; get byte to send 
c3bb			 
c3bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3bb			 
c3bb			;		push hl    ; u1  
c3bb			 
c3bb					; destroy value TOS 
c3bb			 
c3bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3bb			 
c3bb					; one value on hl get other one back 
c3bb			 
c3bb			;		pop hl   ; u2 - addr 
c3bb			 
c3bb					; TODO Send SPI byte 
c3bb			 
c3bb					ld a, l 
c3bb					call spi_send_byte 
c3bb			 
c3bb					NEXTW 
c3bb			 
c3bb			.SPII: 
c3bb				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c3bb			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c3bb			 
c3bb					; TODO Get SPI byte 
c3bb			 
c3bb					call spi_read_byte 
c3bb			 
c3bb					ld h, 0 
c3bb					ld l, a 
c3bb					call forth_push_numhl 
c3bb			 
c3bb					NEXTW 
c3bb			 
c3bb			 
c3bb			 
c3bb			.SESEL: 
c3bb				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c3bb			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c3bb					if DEBUG_FORTH_WORDS_KEY 
c3bb						DMARK "BNK" 
c3bb						CALLMONITOR 
c3bb					endif 
c3bb			 
c3bb					ld a, 255 
c3bb					ld (spi_cartdev), a 
c3bb			 
c3bb					; get bank 
c3bb			 
c3bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3bb			 
c3bb			;		push hl 
c3bb			 
c3bb					; destroy value TOS 
c3bb			 
c3bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3bb			 
c3bb					; one value on hl get other one back 
c3bb			 
c3bb			;		pop hl 
c3bb			 
c3bb			 
c3bb					ld c, SPI_CE_HIGH 
c3bb					ld b, '0'    ; human readable bank number 
c3bb			 
c3bb					ld a, l 
c3bb			 
c3bb					if DEBUG_FORTH_WORDS 
c3bb						DMARK "BNK" 
c3bb						CALLMONITOR 
c3bb					endif 
c3bb			 
c3bb					; active low 
c3bb			 
c3bb					cp 0 
c3bb					jr z, .bset 
c3bb					cp 1 
c3bb					jr nz, .b2 
c3bb					res 0, c 
c3bb					ld b, '1'    ; human readable bank number 
c3bb			.b2:		cp 2 
c3bb					jr nz, .b3 
c3bb					res 1, c 
c3bb					ld b, '2'    ; human readable bank number 
c3bb			.b3:		cp 3 
c3bb					jr nz, .b4 
c3bb					res 2, c 
c3bb					ld b, '3'    ; human readable bank number 
c3bb			.b4:		cp 4 
c3bb					jr nz, .b5 
c3bb					res 3, c 
c3bb					ld b, '4'    ; human readable bank number 
c3bb			.b5:		cp 5 
c3bb					jr nz, .bset 
c3bb					res 4, c 
c3bb					ld b, '5'    ; human readable bank number 
c3bb			 
c3bb			.bset: 
c3bb					ld a, c 
c3bb					ld (spi_device),a 
c3bb					ld a, b 
c3bb					ld (spi_device_id),a 
c3bb					if DEBUG_FORTH_WORDS 
c3bb						DMARK "BN2" 
c3bb						CALLMONITOR 
c3bb					endif 
c3bb			 
c3bb					NEXTW 
c3bb			 
c3bb			.CARTDEV: 
c3bb				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c3bb			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c3bb					if DEBUG_FORTH_WORDS_KEY 
c3bb						DMARK "CDV" 
c3bb						CALLMONITOR 
c3bb					endif 
c3bb			 
c3bb					; disable se storage bank selection 
c3bb			 
c3bb					ld a, SPI_CE_HIGH		; ce high 
c3bb					ld (spi_device), a 
c3bb			 
c3bb					; get bank 
c3bb			 
c3bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3bb			 
c3bb			;		push hl 
c3bb			 
c3bb					; destroy value TOS 
c3bb			 
c3bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3bb			 
c3bb					; one value on hl get other one back 
c3bb			 
c3bb			;		pop hl 
c3bb			 
c3bb					; active low 
c3bb			 
c3bb					ld c, 255 
c3bb			 
c3bb					ld a, l 
c3bb					if DEBUG_FORTH_WORDS 
c3bb						DMARK "CDV" 
c3bb						CALLMONITOR 
c3bb					endif 
c3bb					cp 0 
c3bb					jr z, .cset 
c3bb					cp 1 
c3bb					jr nz, .c2 
c3bb					res 0, c 
c3bb			.c2:		cp 2 
c3bb					jr nz, .c3 
c3bb					res 1, c 
c3bb			.c3:		cp 3 
c3bb					jr nz, .c4 
c3bb					res 2, c 
c3bb			.c4:		cp 4 
c3bb					jr nz, .c5 
c3bb					res 3, c 
c3bb			.c5:		cp 5 
c3bb					jr nz, .c6 
c3bb					res 4, c 
c3bb			.c6:		cp 6 
c3bb					jr nz, .c7 
c3bb					res 5, c 
c3bb			.c7:		cp 7 
c3bb					jr nz, .c8 
c3bb					res 6, c 
c3bb			.c8:		cp 8 
c3bb					jr nz, .cset 
c3bb					res 7, c 
c3bb			.cset:		ld a, c 
c3bb					ld (spi_cartdev),a 
c3bb			 
c3bb					if DEBUG_FORTH_WORDS 
c3bb						DMARK "CD2" 
c3bb						CALLMONITOR 
c3bb					endif 
c3bb					NEXTW 
c3bb			endif 
c3bb			 
c3bb			.ENDDEVICE: 
c3bb			; eof 
c3bb			 
# End of file forth_words_device.asm
c3bb			 
c3bb			; var handler 
c3bb			 
c3bb			 
c3bb			.VARS: 
c3bb				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
c3bb 78				db WORD_SYS_CORE+100             
c3bc d3 c3			dw .V0Q            
c3be 04				db 3 + 1 
c3bf .. 00			db "V0!",0              
c3c3				endm 
# End of macro CWHEAD
c3c3			;| V0! ( u1 -- )  Store value to v0  | DONE 
c3c3			 
c3c3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3c3 cd 87 9a			call macro_dsp_valuehl 
c3c6				endm 
# End of macro FORTH_DSP_VALUEHL
c3c6			 
c3c6 11 13 eb				ld de, cli_var_array 
c3c9			 
c3c9 eb					ex de, hl 
c3ca 73					ld (hl), e 
c3cb 23					inc hl 
c3cc 72					ld (hl), d 
c3cd			 
c3cd					; destroy value TOS 
c3cd			 
c3cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3cd cd 3f 9b			call macro_forth_dsp_pop 
c3d0				endm 
# End of macro FORTH_DSP_POP
c3d0			 
c3d0				       NEXTW 
c3d0 c3 f9 9b			jp macro_next 
c3d3				endm 
# End of macro NEXTW
c3d3			.V0Q: 
c3d3				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c3d3 79				db WORD_SYS_CORE+101             
c3d4 e4 c3			dw .V1S            
c3d6 04				db 3 + 1 
c3d7 .. 00			db "V0@",0              
c3db				endm 
# End of macro CWHEAD
c3db			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c3db 2a 13 eb				ld hl, (cli_var_array) 
c3de cd 90 98				call forth_push_numhl 
c3e1			 
c3e1				       NEXTW 
c3e1 c3 f9 9b			jp macro_next 
c3e4				endm 
# End of macro NEXTW
c3e4			.V1S: 
c3e4				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c3e4 7a				db WORD_SYS_CORE+102             
c3e5 fc c3			dw .V1Q            
c3e7 04				db 3 + 1 
c3e8 .. 00			db "V1!",0              
c3ec				endm 
# End of macro CWHEAD
c3ec			;| V1! ( u1 -- )  Store value to v1 | DONE 
c3ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c3ec cd 87 9a			call macro_dsp_valuehl 
c3ef				endm 
# End of macro FORTH_DSP_VALUEHL
c3ef			 
c3ef 11 15 eb				ld de, cli_var_array+2 
c3f2				 
c3f2 eb					ex de, hl 
c3f3 73					ld (hl), e 
c3f4 23					inc hl 
c3f5 72					ld (hl), d 
c3f6			 
c3f6					; destroy value TOS 
c3f6			 
c3f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3f6 cd 3f 9b			call macro_forth_dsp_pop 
c3f9				endm 
# End of macro FORTH_DSP_POP
c3f9				       NEXTW 
c3f9 c3 f9 9b			jp macro_next 
c3fc				endm 
# End of macro NEXTW
c3fc			.V1Q: 
c3fc				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c3fc 7b				db WORD_SYS_CORE+103             
c3fd 0d c4			dw .V2S            
c3ff 04				db 3 + 1 
c400 .. 00			db "V1@",0              
c404				endm 
# End of macro CWHEAD
c404			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c404 2a 15 eb				ld hl, (cli_var_array+2) 
c407 cd 90 98				call forth_push_numhl 
c40a				       NEXTW 
c40a c3 f9 9b			jp macro_next 
c40d				endm 
# End of macro NEXTW
c40d			.V2S: 
c40d				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c40d 7c				db WORD_SYS_CORE+104             
c40e 25 c4			dw .V2Q            
c410 04				db 3 + 1 
c411 .. 00			db "V2!",0              
c415				endm 
# End of macro CWHEAD
c415			;| V2! ( u1 -- )  Store value to v2 | DONE 
c415					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c415 cd 87 9a			call macro_dsp_valuehl 
c418				endm 
# End of macro FORTH_DSP_VALUEHL
c418			 
c418 11 17 eb				ld de, cli_var_array+4 
c41b				 
c41b eb					ex de, hl 
c41c 73					ld (hl), e 
c41d 23					inc hl 
c41e 72					ld (hl), d 
c41f			 
c41f					; destroy value TOS 
c41f			 
c41f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c41f cd 3f 9b			call macro_forth_dsp_pop 
c422				endm 
# End of macro FORTH_DSP_POP
c422				       NEXTW 
c422 c3 f9 9b			jp macro_next 
c425				endm 
# End of macro NEXTW
c425			.V2Q: 
c425				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c425 7d				db WORD_SYS_CORE+105             
c426 36 c4			dw .V3S            
c428 04				db 3 + 1 
c429 .. 00			db "V2@",0              
c42d				endm 
# End of macro CWHEAD
c42d			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c42d 2a 17 eb				ld hl, (cli_var_array+4) 
c430 cd 90 98				call forth_push_numhl 
c433				       NEXTW 
c433 c3 f9 9b			jp macro_next 
c436				endm 
# End of macro NEXTW
c436			.V3S: 
c436				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c436 7c				db WORD_SYS_CORE+104             
c437 4e c4			dw .V3Q            
c439 04				db 3 + 1 
c43a .. 00			db "V3!",0              
c43e				endm 
# End of macro CWHEAD
c43e			;| V3! ( u1 -- )  Store value to v3 | DONE 
c43e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c43e cd 87 9a			call macro_dsp_valuehl 
c441				endm 
# End of macro FORTH_DSP_VALUEHL
c441			 
c441 11 19 eb				ld de, cli_var_array+6 
c444				 
c444 eb					ex de, hl 
c445 73					ld (hl), e 
c446 23					inc hl 
c447 72					ld (hl), d 
c448			 
c448					; destroy value TOS 
c448			 
c448					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c448 cd 3f 9b			call macro_forth_dsp_pop 
c44b				endm 
# End of macro FORTH_DSP_POP
c44b				       NEXTW 
c44b c3 f9 9b			jp macro_next 
c44e				endm 
# End of macro NEXTW
c44e			.V3Q: 
c44e				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c44e 7d				db WORD_SYS_CORE+105             
c44f 5f c4			dw .END            
c451 04				db 3 + 1 
c452 .. 00			db "V3@",0              
c456				endm 
# End of macro CWHEAD
c456			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c456 2a 19 eb				ld hl, (cli_var_array+6) 
c459 cd 90 98				call forth_push_numhl 
c45c				       NEXTW 
c45c c3 f9 9b			jp macro_next 
c45f				endm 
# End of macro NEXTW
c45f			 
c45f			 
c45f			 
c45f			 
c45f			 
c45f			; end of dict marker 
c45f			 
c45f 00			.END:    db WORD_SYS_END 
c460 00 00			dw 0 
c462 00				db 0 
c463			 
c463			; use to jp here for user dict words to save on macro expansion  
c463			 
c463			user_dict_next: 
c463				NEXTW 
c463 c3 f9 9b			jp macro_next 
c466				endm 
# End of macro NEXTW
c466			 
c466			 
c466			user_exec: 
c466				;    ld hl, <word code> 
c466				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c466				;    call forthexec 
c466				;    jp user_dict_next   (NEXT) 
c466			        ;    <word code bytes> 
c466 eb				ex de, hl 
c467 2a 61 e6			ld hl,(os_tok_ptr) 
c46a				 
c46a				FORTH_RSP_NEXT 
c46a cd 37 98			call macro_forth_rsp_next 
c46d				endm 
# End of macro FORTH_RSP_NEXT
c46d			 
c46d			if DEBUG_FORTH_UWORD 
c46d						DMARK "UEX" 
c46d f5				push af  
c46e 3a 82 c4			ld a, (.dmark)  
c471 32 7a ee			ld (debug_mark),a  
c474 3a 83 c4			ld a, (.dmark+1)  
c477 32 7b ee			ld (debug_mark+1),a  
c47a 3a 84 c4			ld a, (.dmark+2)  
c47d 32 7c ee			ld (debug_mark+2),a  
c480 18 03			jr .pastdmark  
c482 ..			.dmark: db "UEX"  
c485 f1			.pastdmark: pop af  
c486			endm  
# End of macro DMARK
c486				CALLMONITOR 
c486 cd 03 93			call break_point_state  
c489				endm  
# End of macro CALLMONITOR
c489			endif 
c489			 
c489			 
c489			 
c489 eb				ex de, hl 
c48a 22 61 e6			ld (os_tok_ptr), hl 
c48d				 
c48d				; Don't use next - Skips the first word in uword. 
c48d			 
c48d c3 8a 9c			jp exec1 
c490			;	NEXT 
c490			 
c490			 
c490			; eof 
# End of file forth_wordsv4.asm
c490			endif 
c490			;;;;;;;;;;;;;; Debug code 
c490			 
c490			 
c490			;if DEBUG_FORTH_PARSE 
c490 .. 00		.nowordfound: db "No match",0 
c499 .. 00		.compword:	db "Comparing word ",0 
c4a9 .. 00		.nextwordat:	db "Next word at",0 
c4b6 .. 00		.charmatch:	db "Char match",0 
c4c1			;endif 
c4c1			if DEBUG_FORTH_JP 
c4c1			.foundword:	db "Word match. Exec..",0 
c4c1			endif 
c4c1			;if DEBUG_FORTH_PUSH 
c4c1 .. 00		.enddict:	db "Dict end. Push.",0 
c4d1 .. 00		.push_str:	db "Pushing string",0 
c4e0 .. 00		.push_num:	db "Pushing number",0 
c4ef .. 00		.data_sp:	db "SP:",0 
c4f3 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c505 .. 00		.wordinde:	db "Word in DE (3/0):",0 
c517 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c529			;endif 
c529			;if DEBUG_FORTH_MALLOC 
c529 .. 00		.push_malloc:	db "Malloc address",0 
c538			;endif 
c538			 
c538			 
c538			 
c538			; display malloc address and current data stack pointer  
c538			 
c538			malloc_error: 
c538 d5				push de 
c539 f5				push af 
c53a e5				push hl 
c53b cd 7a 88			call clear_display 
c53e 11 60 c5			ld de, .mallocerr 
c541 3e 00			ld a,0 
c543			;	ld de,os_word_scratch 
c543 cd 8d 88			call str_at_display 
c546 3e 11			ld a, display_row_1+17 
c548 11 7a ee			ld de, debug_mark 
c54b cd 8d 88			call str_at_display 
c54e cd 9d 88			call update_display 
c551				;call break_point_state 
c551 cd 6e d8			call cin_wait 
c554			 
c554 3e 20			ld a, ' ' 
c556 32 51 e3			ld (os_view_disable), a 
c559 e1				pop hl 
c55a f1				pop af 
c55b d1				pop de	 
c55c				CALLMONITOR 
c55c cd 03 93			call break_point_state  
c55f				endm  
# End of macro CALLMONITOR
c55f c9				ret 
c560			 
c560 .. 00		.mallocerr: 	db "Malloc Error",0 
c56d			;if DEBUG_FORTH_PUSH 
c56d			display_data_sp: 
c56d f5				push af 
c56e			 
c56e				; see if disabled 
c56e			 
c56e 3a 51 e3			ld a, (os_view_disable) 
c571 fe 2a			cp '*' 
c573 28 67			jr z, .skipdsp 
c575			 
c575 e5				push hl 
c576 e5				push hl 
c577 e5			push hl 
c578 cd 7a 88			call clear_display 
c57b e1			pop hl 
c57c 7c				ld a,h 
c57d 21 65 e6			ld hl, os_word_scratch 
c580 cd a8 8d			call hexout 
c583 e1				pop hl 
c584 7d				ld a,l 
c585 21 67 e6			ld hl, os_word_scratch+2 
c588 cd a8 8d			call hexout 
c58b 21 69 e6			ld hl, os_word_scratch+4 
c58e 3e 00			ld a,0 
c590 77				ld (hl),a 
c591 11 65 e6			ld de,os_word_scratch 
c594 3e 28				ld a, display_row_2 
c596 cd 8d 88				call str_at_display 
c599 11 f3 c4			ld de, .wordinhl 
c59c 3e 00			ld a, display_row_1 
c59e			 
c59e cd 8d 88				call str_at_display 
c5a1 11 7a ee			ld de, debug_mark 
c5a4 3e 11			ld a, display_row_1+17 
c5a6			 
c5a6 cd 8d 88				call str_at_display 
c5a9			 
c5a9				; display current data stack pointer 
c5a9 11 ef c4			ld de,.data_sp 
c5ac 3e 30				ld a, display_row_2 + 8 
c5ae cd 8d 88				call str_at_display 
c5b1			 
c5b1 2a 0d eb			ld hl,(cli_data_sp) 
c5b4 e5				push hl 
c5b5 7c				ld a,h 
c5b6 21 65 e6			ld hl, os_word_scratch 
c5b9 cd a8 8d			call hexout 
c5bc e1				pop hl 
c5bd 7d				ld a,l 
c5be 21 67 e6			ld hl, os_word_scratch+2 
c5c1 cd a8 8d			call hexout 
c5c4 21 69 e6			ld hl, os_word_scratch+4 
c5c7 3e 00			ld a,0 
c5c9 77				ld (hl),a 
c5ca 11 65 e6			ld de,os_word_scratch 
c5cd 3e 33				ld a, display_row_2 + 11 
c5cf cd 8d 88				call str_at_display 
c5d2			 
c5d2			 
c5d2 cd 9d 88			call update_display 
c5d5 cd fa 87			call delay1s 
c5d8 cd fa 87			call delay1s 
c5db e1				pop hl 
c5dc			.skipdsp: 
c5dc f1				pop af 
c5dd c9				ret 
c5de			 
c5de			display_data_malloc: 
c5de			 
c5de f5				push af 
c5df e5				push hl 
c5e0 e5				push hl 
c5e1 e5			push hl 
c5e2 cd 7a 88			call clear_display 
c5e5 e1			pop hl 
c5e6 7c				ld a,h 
c5e7 21 65 e6			ld hl, os_word_scratch 
c5ea cd a8 8d			call hexout 
c5ed e1				pop hl 
c5ee 7d				ld a,l 
c5ef 21 67 e6			ld hl, os_word_scratch+2 
c5f2 cd a8 8d			call hexout 
c5f5 21 69 e6			ld hl, os_word_scratch+4 
c5f8 3e 00			ld a,0 
c5fa 77				ld (hl),a 
c5fb 11 65 e6			ld de,os_word_scratch 
c5fe 3e 28				ld a, display_row_2 
c600 cd 8d 88				call str_at_display 
c603 11 29 c5			ld de, .push_malloc 
c606 3e 00			ld a, display_row_1 
c608			 
c608 cd 8d 88				call str_at_display 
c60b			 
c60b				; display current data stack pointer 
c60b 11 ef c4			ld de,.data_sp 
c60e 3e 30				ld a, display_row_2 + 8 
c610 cd 8d 88				call str_at_display 
c613			 
c613 2a 0d eb			ld hl,(cli_data_sp) 
c616 e5				push hl 
c617 7c				ld a,h 
c618 21 65 e6			ld hl, os_word_scratch 
c61b cd a8 8d			call hexout 
c61e e1				pop hl 
c61f 7d				ld a,l 
c620 21 67 e6			ld hl, os_word_scratch+2 
c623 cd a8 8d			call hexout 
c626 21 69 e6			ld hl, os_word_scratch+4 
c629 3e 00			ld a,0 
c62b 77				ld (hl),a 
c62c 11 65 e6			ld de,os_word_scratch 
c62f 3e 33				ld a, display_row_2 + 11 
c631 cd 8d 88				call str_at_display 
c634			 
c634 cd 9d 88			call update_display 
c637 cd fa 87			call delay1s 
c63a cd fa 87			call delay1s 
c63d e1				pop hl 
c63e f1				pop af 
c63f c9				ret 
c640			;endif 
c640			 
c640			include "forth_autostart.asm" 
c640			; list of commands to perform at system start up 
c640			 
c640			startcmds: 
c640			;	dw test11 
c640			;	dw test12 
c640			;	dw test13 
c640			;	dw test14 
c640			;	dw test15 
c640			;	dw test16 
c640			;	dw test17 
c640			;	dw ifthtest1 
c640			;	dw ifthtest2 
c640			;	dw ifthtest3 
c640			;	dw mmtest1 
c640			;	dw mmtest2 
c640			;	dw mmtest3 
c640			;	dw mmtest4 
c640			;	dw mmtest5 
c640			;	dw mmtest6 
c640			;	dw iftest1 
c640			;	dw iftest2 
c640			;	dw iftest3 
c640			;	dw looptest1 
c640			;	dw looptest2 
c640			;	dw test1 
c640			;	dw test2 
c640			;	dw test3 
c640			;	dw test4 
c640			;	dw game2r 
c640			;	dw game2b1 
c640			;	dw game2b2 
c640			 
c640				; start up words that are actually useful 
c640			 
c640 9e c6			dw clrstack 
c642 d1 c6			dw type 
c644 92 c8			dw stest 
c646 f5 c6			dw strncpy 
c648 33 c8			dw list 
c64a 56 c7			dw start1 
c64c 68 c7			dw start2 
c64e			;	dw start3 
c64e 7b c7			dw start3b 
c650 d3 c7			dw start3c 
c652			 
c652				; (unit) testing words 
c652			 
c652 09 c9			dw mtesta 
c654 be c9			dw mtestb 
c656 61 ca			dw mtestc 
c658 16 cb			dw mtestd 
c65a ba cb			dw mteste 
c65c			 
c65c				; demo/game words 
c65c			 
c65c c6 d2		        dw game3w 
c65e f4 d2		        dw game3p 
c660 12 d3		        dw game3sc 
c662 43 d3		        dw game3vsi 
c664 6f d3		        dw game3vs 
c666				 
c666 b9 d0			dw game2b 
c668 27 d1			dw game2bf 
c66a 71 d1			dw game2mba 
c66c 07 d2			dw game2mbas 
c66e 49 d2			dw game2mb 
c670			 
c670 7a cd			dw game1 
c672 8b cd			dw game1a 
c674 ed cd			dw game1b 
c676 22 ce			dw game1c 
c678 58 ce			dw game1d 
c67a 89 ce			dw game1s 
c67c 9d ce			dw game1t 
c67e b2 ce			dw game1f 
c680 e6 ce			dw game1z 
c682 2a cf			dw game1zz 
c684			 
c684 70 cc			dw test5 
c686 a8 cc			dw test6 
c688 e0 cc			dw test7 
c68a f4 cc			dw test8 
c68c 20 cd			dw test9 
c68e 36 cd			dw test10 
c690				 
c690 01 d0		        dw ssv5 
c692 e5 cf		        dw ssv4 
c694 c9 cf		        dw ssv3 
c696 93 cf		        dw ssv2 
c698 1a d0		        dw ssv1 
c69a 62 d0		        dw ssv1cpm 
c69c			;	dw keyup 
c69c			;	dw keydown 
c69c			;	dw keyleft 
c69c			;	dw keyright 
c69c			;	dw 	keyf1 
c69c			;	dw keyf2 
c69c			;	dw keyf3 
c69c			;	dw keyf4 
c69c			;	dw keyf5 
c69c			;	dw keyf6 
c69c			;	dw keyf7 
c69c			;	dw keyf8 
c69c			;	dw keyf9 
c69c			;	dw keyf10 
c69c			;	dw keyf11 
c69c			;	dw keyf12 
c69c			;	dw keytab 
c69c			;	dw keycr 
c69c			;	dw keyhome 
c69c			;	dw keyend 
c69c			;	dw keybs 
c69c 00 00			db 0, 0	 
c69e			 
c69e			 
c69e			; clear stack  
c69e			 
c69e .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
c6d1			 
c6d1			; type ( addr count - ) 
c6d1 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
c6f5			 
c6f5			; some direct memory words 
c6f5			; strncpy ( len t f -- t ) 
c6f5			 
c6f5 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
c756			 
c756 .. 00		start1:     	db ": bpon $0000 bp ;",0 
c768 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
c77b			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
c77b .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
c7d3 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
c833			 
c833			 
c833			; a handy word to list items on the stack 
c833			 
c833 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
c892			 
c892			 
c892			; test stack  
c892			; rnd8 stest 
c892			 
c892 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
c909			 
c909			; random malloc and free cycles 
c909			 
c909 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c9be			 
c9be			; fixed malloc and free cycles 
c9be			 
c9be .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
ca61			 
ca61			; fixed double string push and drop cycle  
ca61			 
ca61 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
cb16			 
cb16			; consistent fixed string push and drop cycle  
cb16			 
cb16 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cbba			 
cbba .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cc70			 
cc70			;test1:		db ": aa 1 2 3 ;", 0 
cc70			;test2:     	db "111 aa 888 999",0 
cc70			;test3:     	db ": bb 77 ;",0 
cc70			;test4:     	db "$02 $01 do i . loop bb",0 
cc70			 
cc70 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
cca8 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
cce0 .. 00		test7:     	db ": box hline vline ;",0 
ccf4 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
cd20 .. 00		test9:     	db ": sw $01 adsp world ;",0 
cd36 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
cd5b .. 00		test11:     	db "hello create .",0 
cd6a .. 00		test12:     	db "hello2 create .",0 
cd7a			 
cd7a			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
cd7a			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
cd7a			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
cd7a			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
cd7a			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
cd7a			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
cd7a			 
cd7a			;iftest1:     	db "$0001 IF cls .",0 
cd7a			;iftest2:     	db "$0000 IF cls .",0 
cd7a			;iftest3:     	db "$0002 $0003 - IF cls .",0 
cd7a			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
cd7a			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
cd7a			 
cd7a			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cd7a			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cd7a			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cd7a			 
cd7a			 
cd7a			 
cd7a			; a small guess the number game 
cd7a			 
cd7a .. 00		game1:          db ": gsn rnd8 v1! ;",0 
cd8b .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
cded			 
cded .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
ce22 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
ce58 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
ce89 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
ce9d .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
ceb2 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
cee6 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
cf2a			 
cf2a			; Using 'ga' save a high score across multiple runs using external storage 
cf2a			 
cf2a .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
cf93			 
cf93			 
cf93			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
cf93			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
cf93			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
cf93			 
cf93			; simple screen saver to test code memory reuse to destruction 
cf93			 
cf93 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
cfc9 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
cfe5 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
d001 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
d01a .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
d062 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
d0b9			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
d0b9			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
d0b9			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
d0b9			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
d0b9			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
d0b9			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
d0b9			 
d0b9			 
d0b9			 
d0b9			; minesweeper/battleship finding game 
d0b9			; draws a game board of random ship/mine positions 
d0b9			; user enters coords to see if it hits on 
d0b9			; game ends when all are hit 
d0b9			; when hit or miss says how many may be in the area 
d0b9			 
d0b9			; setup the game board and then hide it 
d0b9 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
d127 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d171			; prompt for where to target 
d171 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d207 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d22c			; TODO see if the entered coords hits or misses pushes char hit of miss 
d22c .. 00		game2mbht:      db ": mbckht nop ;",0 
d23b .. 00		game2mbms:      db ": mbcms nop ;",0 
d249			; TODO how many might be near by 
d249 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d2c6			 
d2c6			; Game 3 
d2c6			 
d2c6			; Vert scroller ski game - avoid the trees! 
d2c6			 
d2c6			; v0 score (ie turns) 
d2c6			; v1 player pos 
d2c6			; v2 left wall 
d2c6			; v3 right wall 
d2c6			 
d2c6			; Draw side walls randomly 
d2c6			 
d2c6 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d2f4			 
d2f4			; Draw player 
d2f4 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d312			 
d312			; TODO Get Key 
d312			 
d312			; TODO Move left right 
d312			 
d312			; scroll and move walls a bit 
d312			 
d312 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d343			 
d343			; main game loop 
d343			 
d343 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d36f .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d3ae			 
d3ae			; key board defs 
d3ae			 
d3ae .. 00		keyup:       db ": keyup $05 ;",0 
d3bc .. 00		keydown:       db ": keydown $0a ;",0 
d3cc .. 00		keyleft:       db ": keyleft $0b ;",0 
d3dc .. 00		keyright:       db ": keyright $0c ;",0 
d3ed .. 00		keyf1:       db ": keyf1 $10 ;",0 
d3fb .. 00		keyf2:       db ": keyf2 $11 ;",0 
d409 .. 00		keyf3:       db ": keyf3 $12 ;",0 
d417 .. 00		keyf4:       db ": keyf4 $13 ;",0 
d425 .. 00		keyf5:       db ": keyf5 $14 ;",0 
d433 .. 00		keyf6:       db ": keyf6 $15 ;",0 
d441 .. 00		keyf7:       db ": keyf7 $16 ;",0 
d44f .. 00		keyf8:       db ": keyf8 $17 ;",0 
d45d .. 00		keyf9:       db ": keyf9 $18 ;",0 
d46b .. 00		keyf10:       db ": keyf10 $19 ;",0 
d47a .. 00		keyf11:       db ": keyf11 $1a ;",0 
d489 .. 00		keyf12:       db ": keyf12 $1b ;",0 
d498			 
d498 .. 00		keytab:       db ": keytab $09 ;",0 
d4a7 .. 00		keycr:       db ": keycr $0d ;",0 
d4b5 .. 00		keyhome:       db ": keyhome $0e ;",0 
d4c5 .. 00		keyend:       db ": keyend $0f ;",0 
d4d4 .. 00		keybs:       db ": keybs $08 ;",0 
d4e2			 
d4e2			   
d4e2			 
d4e2			 
d4e2			 
d4e2			; eof 
# End of file forth_autostart.asm
d4e2			 
d4e2 .. 00		sprompt1: db "Startup load...",0 
d4f2 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
d508			 
d508			 
d508			 
d508			 
d508			forth_startup: 
d508 21 40 c6			ld hl, startcmds 
d50b 3e 00			ld a, 0 
d50d 32 86 e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
d510			 
d510 e5			.start1:	push hl 
d511 cd 7a 88			call clear_display 
d514 11 e2 d4			ld de, sprompt1 
d517 3e 00		        ld a, display_row_1 
d519 cd 8d 88			call str_at_display 
d51c 11 f2 d4			ld de, sprompt2 
d51f 3e 28		        ld a, display_row_2 
d521 cd 8d 88			call str_at_display 
d524 e1				pop hl 
d525 e5				push hl 
d526 5e				ld e,(hl) 
d527 23				inc hl 
d528 56				ld d,(hl) 
d529 3e 50		        ld a, display_row_3 
d52b cd 8d 88			call str_at_display 
d52e cd 9d 88			call update_display 
d531			 
d531			 
d531 3a 86 e7			ld a, (os_last_cmd) 
d534 fe 00			cp 0 
d536 28 05			jr z, .startprompt 
d538 cd ee 87			call delay250ms 
d53b 18 24			jr .startdo 
d53d				 
d53d				 
d53d			 
d53d			.startprompt: 
d53d			 
d53d 3e 9f			ld a,display_row_4 + display_cols - 1 
d53f 11 06 98		        ld de, endprg 
d542 cd 8d 88			call str_at_display 
d545 cd 9d 88			call update_display 
d548 cd fa 87			call delay1s 
d54b cd 6e d8			call cin_wait 
d54e						 
d54e fe 2a			cp '*' 
d550 28 5e			jr z, .startupend1 
d552 fe 23			cp '#' 
d554 20 07			jr nz, .startno 
d556 3e 01			ld a, 1 
d558 32 86 e7			ld (os_last_cmd),a 
d55b 18 04			jr .startdo 
d55d fe 31		.startno:	cp '1' 
d55f 28 3a			jr z,.startnxt  
d561			 
d561				; exec startup line 
d561			.startdo:	 
d561 e1				pop hl 
d562 e5				push hl 
d563				 
d563 5e				ld e,(hl) 
d564 23				inc hl 
d565 56				ld d,(hl) 
d566 eb				ex de,hl 
d567			 
d567 e5				push hl 
d568			 
d568 3e 00			ld a, 0 
d56a				;ld a, FORTH_END_BUFFER 
d56a cd 10 8f			call strlent 
d56d 23				inc hl   ; include zero term to copy 
d56e 06 00			ld b,0 
d570 4d				ld c,l 
d571 e1				pop hl 
d572 11 60 e3			ld de, scratch 
d575 ed b0			ldir 
d577			 
d577			 
d577 21 60 e3			ld hl, scratch 
d57a cd 47 9c			call forthparse 
d57d cd 87 9c			call forthexec 
d580 cd 9e 9b			call forthexec_cleanup 
d583			 
d583 3e 78			ld a, display_row_4 
d585 11 aa 95			ld de, endprog 
d588			 
d588 cd 9d 88			call update_display		 
d58b			 
d58b 3a 86 e7			ld a, (os_last_cmd) 
d58e fe 00			cp 0 
d590 20 09			jr nz, .startnxt 
d592 cd 08 98			call next_page_prompt 
d595 cd 7a 88		        call clear_display 
d598 cd 9d 88			call update_display		 
d59b			 
d59b				; move onto next startup line? 
d59b			.startnxt: 
d59b			 
d59b cd ee 87			call delay250ms 
d59e e1				pop hl 
d59f			 
d59f 23				inc hl 
d5a0 23				inc hl 
d5a1			 
d5a1 e5				push hl 
d5a2 5e				ld e, (hl) 
d5a3 23				inc hl 
d5a4 56				ld d, (hl) 
d5a5 e1				pop hl 
d5a6				; TODO replace 0 test 
d5a6			 
d5a6 eb				ex de, hl 
d5a7 cd d0 8a			call ishlzero 
d5aa			;	ld a,e 
d5aa			;	add d 
d5aa			;	cp 0    ; any left to do? 
d5aa eb				ex de, hl 
d5ab c2 10 d5			jp nz, .start1 
d5ae 18 01			jr .startupend 
d5b0			 
d5b0 e1			.startupend1: pop hl 
d5b1			.startupend: 
d5b1			 
d5b1 cd 7a 88			call clear_display 
d5b4 cd 9d 88			call update_display 
d5b7 c9				ret 
d5b8			 
d5b8			 
d5b8			; stack over and underflow checks 
d5b8			 
d5b8			; init the words to detect the under/overflow 
d5b8			 
d5b8			chk_stk_init: 
d5b8				; a vague random number to check so we dont get any "lucky" hits 
d5b8 3e 2d			ld a, 45 
d5ba 6f				ld l, a 
d5bb 00				nop 
d5bc 3e 17			ld a, 23 
d5be 67				ld h, a 
d5bf			 
d5bf 22 47 e3			ld (chk_word), hl     ; the word we need to check against 
d5c2			 
d5c2			;	ld (chk_stund), hl	; stack points.... 
d5c2 22 00 ef			ld (chk_stovr), hl 
d5c5 22 0b eb			ld (chk_ret_und), hl 
d5c8 22 c9 ea			ld (chk_ret_ovr), hl 
d5cb 22 c7 e9			ld (chk_loop_ovr), hl 
d5ce 22 c5 e8			ld (chk_data_ovr), hl 
d5d1 c9				ret 
d5d2				 
d5d2			check_stacks: 
d5d2				; check all stack words 
d5d2			 
d5d2 e5				push hl 
d5d3 d5				push de 
d5d4			 
d5d4			;	ld de,(chk_word) 
d5d4			;	ld hl, (chk_stund)	; stack points.... 
d5d4			;	if DEBUG_STK_FAULT 
d5d4			;		DMARK "FAa" 
d5d4			;		CALLMONITOR 
d5d4			;	endif 
d5d4			;	call cmp16 
d5d4			;	jp z, .chk_faulta 
d5d4			; 
d5d4			;	ld de, sfaultsu 
d5d4			;	jp .chk_fault 
d5d4			 
d5d4 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d5d7 ed 5b 47 e3		ld de,(chk_word) 
d5db				if DEBUG_STK_FAULT 
d5db					DMARK "FAb" 
d5db					CALLMONITOR 
d5db				endif 
d5db cd c5 8a			call cmp16 
d5de 28 06			jr z, .chk_fault1 
d5e0 11 81 d6			ld de, sfaultso 
d5e3 c3 35 d6			jp .chk_fault 
d5e6			.chk_fault1:  
d5e6 2a 0b eb			ld hl, (chk_ret_und) 
d5e9 ed 5b 47 e3		ld de,(chk_word) 
d5ed				if DEBUG_STK_FAULT 
d5ed					DMARK "FAU" 
d5ed					CALLMONITOR 
d5ed				endif 
d5ed cd c5 8a			call cmp16 
d5f0 ca f9 d5			jp z, .chk_fault2 
d5f3 11 91 d6			ld de, sfaultru 
d5f6 c3 35 d6			jp .chk_fault 
d5f9			.chk_fault2:  
d5f9 2a c9 ea			ld hl, (chk_ret_ovr) 
d5fc ed 5b 47 e3		ld de,(chk_word) 
d600				if DEBUG_STK_FAULT 
d600					DMARK "FA1" 
d600					CALLMONITOR 
d600				endif 
d600 cd c5 8a			call cmp16 
d603 ca 0c d6			jp z, .chk_fault3 
d606 11 9f d6			ld de, sfaultro 
d609 c3 35 d6			jp .chk_fault 
d60c			.chk_fault3:  
d60c 2a c7 e9			ld hl, (chk_loop_ovr) 
d60f ed 5b 47 e3		ld de,(chk_word) 
d613				if DEBUG_STK_FAULT 
d613					DMARK "FA2" 
d613					CALLMONITOR 
d613				endif 
d613 cd c5 8a			call cmp16 
d616 ca 1f d6			jp z, .chk_fault4 
d619 11 b9 d6			ld de, sfaultlo 
d61c c3 35 d6			jp .chk_fault 
d61f			.chk_fault4:  
d61f 2a c5 e8			ld hl, (chk_data_ovr) 
d622 ed 5b 47 e3		ld de,(chk_word) 
d626				if DEBUG_STK_FAULT 
d626					DMARK "FA3" 
d626					CALLMONITOR 
d626				endif 
d626 cd c5 8a			call cmp16 
d629 ca 32 d6			jp z, .chk_fault5 
d62c 11 d3 d6			ld de, sfaultdo 
d62f c3 35 d6			jp .chk_fault 
d632			 
d632			 
d632			.chk_fault5:  
d632 d1				pop de 
d633 e1				pop hl 
d634			 
d634 c9				ret 
d635			 
d635 cd 7a 88		.chk_fault: 	call clear_display 
d638 3e 28				ld a, display_row_2 
d63a cd 8d 88				call str_at_display 
d63d 11 63 d6				   ld de, .stackfault 
d640 3e 00				ld a, display_row_1 
d642 cd 8d 88				call str_at_display 
d645 11 7a ee				    ld de, debug_mark 
d648 3e 11				ld a, display_row_1+17 
d64a cd 8d 88				call str_at_display 
d64d cd 9d 88				call update_display 
d650			 
d650				; prompt before entering montior for investigating issue 
d650			 
d650 3e 78			ld a, display_row_4 
d652 11 aa 95			ld de, endprog 
d655			 
d655 cd 9d 88			call update_display		 
d658			 
d658 cd 08 98			call next_page_prompt 
d65b			 
d65b d1				pop de 
d65c e1				pop hl 
d65d cd fe 95				call monitor 
d660 c3 f8 94				jp warmstart 
d663					;jp 0 
d663					;halt 
d663			 
d663			 
d663			 
d663 .. 00		.stackfault: 	db "Stack fault:",0 
d670			 
d670 .. 00		sfaultsu: 	db	"Stack under flow",0 
d681 .. 00		sfaultso: 	db	"Stack over flow",0 
d691 .. 00		sfaultru:	db "RTS underflow",0 
d69f .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
d6b9 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
d6d3 .. 00		sfaultdo:	db "DTS overflow", 0 
d6e0			 
d6e0			 
d6e0			fault_dsp_under: 
d6e0 11 f2 d6			ld de, .dsp_under 
d6e3 c3 a2 d7			jp .show_fault 
d6e6			 
d6e6			fault_rsp_under: 
d6e6 11 00 d7			ld de, .rsp_under 
d6e9 c3 a2 d7			jp .show_fault 
d6ec			fault_loop_under: 
d6ec 11 0e d7			ld de, .loop_under 
d6ef c3 a2 d7			jp .show_fault 
d6f2			 
d6f2 .. 00		.dsp_under: db "DSP Underflow",0 
d700 .. 00		.rsp_under: db "RSP Underflow",0 
d70e .. 00		.loop_under: db "LOOP Underflow",0 
d71d			 
d71d			 
d71d d5			type_faultn: 	push de 
d71e e5					push hl 
d71f cd 7a 88				call clear_display 
d722 11 49 d7				   ld de, .typefaultn 
d725 3e 00				ld a, display_row_1 
d727 cd 8d 88				call str_at_display 
d72a 11 7a ee				    ld de, debug_mark 
d72d 3e 11				ld a, display_row_1+17 
d72f cd 8d 88				call str_at_display 
d732 cd 9d 88				call update_display 
d735			 
d735				; prompt before entering montior for investigating issue 
d735			 
d735 3e 78			ld a, display_row_4 
d737 11 aa 95			ld de, endprog 
d73a			 
d73a cd 9d 88			call update_display		 
d73d			 
d73d cd 08 98			call next_page_prompt 
d740			 
d740 e5					push hl 
d741 d5					push de 
d742 cd fe 95				call monitor 
d745 c3 f8 94				jp warmstart 
d748 76					halt 
d749			 
d749			 
d749 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
d760			 
d760 d5			type_faults: 	push de 
d761 e5					push hl 
d762 cd 7a 88				call clear_display 
d765 11 8b d7				   ld de, .typefaults 
d768 3e 00				ld a, display_row_1 
d76a cd 8d 88				call str_at_display 
d76d 11 7a ee				    ld de, debug_mark 
d770 3e 11				ld a, display_row_1+17 
d772 cd 8d 88				call str_at_display 
d775 cd 9d 88				call update_display 
d778			 
d778				; prompt before entering montior for investigating issue 
d778			 
d778 3e 78			ld a, display_row_4 
d77a 11 aa 95			ld de, endprog 
d77d			 
d77d cd 9d 88			call update_display		 
d780			 
d780 cd 08 98			call next_page_prompt 
d783			 
d783 e1					pop hl 
d784 d1					pop de 
d785 cd fe 95				call monitor 
d788 c3 f8 94				jp warmstart 
d78b			 
d78b			 
d78b .. 00		.typefaults: db "STR Type Expected TOS!",0 
d7a2			 
d7a2			.show_fault: 	 
d7a2 d5					push de 
d7a3 cd 7a 88				call clear_display 
d7a6 d1					pop de 
d7a7 3e 00				ld a, display_row_1 
d7a9 cd 8d 88				call str_at_display 
d7ac 11 7a ee				    ld de, debug_mark 
d7af 3e 11				ld a, display_row_1+17 
d7b1 cd 8d 88				call str_at_display 
d7b4 cd 9d 88				call update_display 
d7b7			 
d7b7				; prompt before entering montior for investigating issue 
d7b7			 
d7b7 3e 78			ld a, display_row_4 
d7b9 11 aa 95			ld de, endprog 
d7bc			 
d7bc cd 9d 88			call update_display		 
d7bf			 
d7bf cd 08 98			call next_page_prompt 
d7c2			 
d7c2 e1					pop hl 
d7c3 d1					pop de 
d7c4 cd fe 95				call monitor 
d7c7			; do a dump to cli and not warmstart so we preserve all of the uwords.  
d7c7			; TODO Make optional fault restart to cli or warm boot? 
d7c7					;jp warmstart 
d7c7 c3 50 95				jp cli 
d7ca 76					halt 
d7cb			 
d7cb			; handle the auto run of code from files in storage 
d7cb			 
d7cb			 
d7cb			if STORAGE_SE 
d7cb			 
d7cb			sprompt3: db "Loading from start-up file?:",0 
d7cb			sprompt4: db "(Y=Any key/N=No)",0 
d7cb			 
d7cb			 
d7cb			forth_autoload: 
d7cb			 
d7cb				; load block 0 of store 1 
d7cb				 
d7cb				ld a, $fe      ; bit 0 clear 
d7cb				ld (spi_device), a 
d7cb			 
d7cb				call storage_get_block_0 
d7cb			 
d7cb				ld a, (store_page+STORE_0_AUTOFILE) 
d7cb			 
d7cb				cp 0 
d7cb				ret z     ; auto start not enabled 
d7cb			 
d7cb				call clear_display 
d7cb			 
d7cb				; set bank 
d7cb			 
d7cb					ld a, (store_page+STORE_0_BANKRUN) 
d7cb					ld (spi_device), a 
d7cb			 
d7cb				; get file id to load from and get the file name to display 
d7cb			 
d7cb					ld a, (store_page+STORE_0_FILERUN) 
d7cb			 
d7cb					ld l, 0 
d7cb					ld h, a 
d7cb					ld de, store_page 
d7cb			 
d7cb					if DEBUG_FORTH_WORDS 
d7cb						DMARK "ASp" 
d7cb						CALLMONITOR 
d7cb					endif 
d7cb					call storage_read 
d7cb			 
d7cb					if DEBUG_FORTH_WORDS 
d7cb						DMARK "ASr" 
d7cb						CALLMONITOR 
d7cb					endif 
d7cb			 
d7cb					call ishlzero 
d7cb					ret z             ; file not found 
d7cb			 
d7cb					ld a, display_row_2 + 10 
d7cb					ld de, store_page+3 
d7cb					call str_at_display 
d7cb				 
d7cb			; 
d7cb			 
d7cb				ld a, display_row_1+5 
d7cb				ld de, sprompt3 
d7cb				call str_at_display 
d7cb				ld a, display_row_3+15 
d7cb				ld de, sprompt4 
d7cb				call str_at_display 
d7cb			 
d7cb				call update_display 
d7cb			 
d7cb				call cin_wait 
d7cb				cp 'n' 
d7cb				ret z 
d7cb				cp 'N' 
d7cb				ret z 
d7cb			 
d7cb				call delay1s 
d7cb			 
d7cb				ld a, (store_page+2) 
d7cb				ld (store_openmaxext), a    ; save count of ext 
d7cb				ld a, 1  
d7cb				ld (store_openext), a    ; save count of ext 
d7cb			 
d7cb			.autof:  
d7cb				ld l , a 
d7cb				 
d7cb				ld a, (store_page) 
d7cb				ld h, a	 
d7cb				ld de, store_page 
d7cb					if DEBUG_FORTH_WORDS 
d7cb						DMARK "ASl" 
d7cb						CALLMONITOR 
d7cb					endif 
d7cb					call storage_read 
d7cb				call ishlzero 
d7cb				jr z, .autofdone 
d7cb			 
d7cb				ld de, store_page+2 
d7cb				ld a, display_row_4 
d7cb				call str_at_display 
d7cb			 
d7cb				call update_display 
d7cb				call delay250ms 
d7cb			 
d7cb			 
d7cb			 
d7cb				ld hl, store_page+2 
d7cb				call forthparse 
d7cb				call forthexec 
d7cb				call forthexec_cleanup 
d7cb			 
d7cb				 
d7cb				ld a, (store_openext) 
d7cb				inc a 
d7cb				ld (store_openext), a    ; save count of ext 
d7cb			 
d7cb				jr .autof 
d7cb			 
d7cb			.autofdone: 
d7cb			 
d7cb					if DEBUG_FORTH_WORDS 
d7cb						DMARK "ASx" 
d7cb						CALLMONITOR 
d7cb					endif 
d7cb				call clear_display 
d7cb				ret 
d7cb			 
d7cb			 
d7cb			 
d7cb			endif 
d7cb			 
d7cb			 
d7cb			; eof 
# End of file forth_kernel.asm
d7cb			;include "nascombasic.asm" 
d7cb			 
d7cb			 
d7cb			; find out where the code ends if loaded into RAM (for SC114) 
d7cb			;endofcode:  
d7cb			;	nop 
d7cb			 
d7cb			 
d7cb			; eof 
d7cb			 
# End of file main.asm
d7cb			;include "firmware_lcd_4x40.asm" 
d7cb			;;include "firmware_lcd_4x20.asm" 
d7cb			include "firmware_serial_display.asm" 
d7cb			 
d7cb			; Serial display interface for SC114 
d7cb			 
d7cb			 
d7cb			display_row_1: equ 0 
d7cb			display_row_2: equ display_row_1+display_cols 
d7cb			display_row_3: equ display_row_2 + display_cols 
d7cb			display_row_4: equ display_row_3 + display_cols 
d7cb			 
d7cb			kLCDWidth:  EQU display_cols             ;Width in characters 
d7cb			kLCD_Line1: EQU 0x00  
d7cb			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
d7cb			; E1 
d7cb			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
d7cb			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
d7cb			 
d7cb			lcd_init: 
d7cb				; no init as handled by the SCM bios 
d7cb c9				ret 
d7cc			 
d7cc			 
d7cc			; low level functions for direct screen writes 
d7cc			 
d7cc			; output char at pos? 
d7cc			fLCD_Str: 
d7cc			        ;out (SC114_SIO_1_OUT),a 
d7cc c5				push bc 
d7cd 0e 02			ld c, $02 
d7cf f7				rst $30 
d7d0 c1				pop bc 
d7d1 c9				ret 
d7d2			 
d7d2			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
d7d2			fLCD_Pos: 
d7d2				; use ASCII escape to position 
d7d2			        ;out (SC114_SIO_1_OUT),a 
d7d2 c5				push bc 
d7d3 0e 02			ld c, $02 
d7d5 f7				rst $30 
d7d6 c1				pop bc 
d7d7			 
d7d7 c9				ret 
d7d8			 
d7d8			; output char at pos 
d7d8			fLCD_Data: 
d7d8			      ;  out (SC114_SIO_1_OUT),a 
d7d8 c5				push bc 
d7d9 0e 02			ld c, $02 
d7db f7				rst $30 
d7dc c1				pop bc 
d7dd			 
d7dd c9				ret 
d7de			 
d7de			; ascii cls  
d7de			 
d7de 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
d7e2			 
d7e2			; write the frame buffer given in hl to hardware  
d7e2			write_display: 
d7e2			 
d7e2			API: equ 0 
d7e2			 
d7e2			if API 
d7e2				push bc 
d7e2				ld b, 4 
d7e2			 
d7e2			        ld (display_write_tmp), hl 	  
d7e2			 
d7e2				; clear and home cursor 
d7e2			 
d7e2				ld c, 6 
d7e2				ld de, .cls 
d7e2				rst $30 
d7e2			 
d7e2			 
d7e2			.writeln: 
d7e2			 
d7e2				ld de, (display_write_tmp) 
d7e2				ld c, 6 
d7e2				rst $30 
d7e2				ld c, 7 
d7e2				rst $30 
d7e2			 
d7e2				ld hl, (display_write_tmp) 
d7e2				ld de, display_cols 
d7e2				add hl,de 
d7e2				ld (display_write_tmp),hl 
d7e2			 
d7e2				djnz  .writeln 
d7e2			 
d7e2				pop bc 
d7e2			 
d7e2			 
d7e2				ret 
d7e2			endif 
d7e2 e5				push hl 
d7e3 c5				push bc 
d7e4 d5				push de 
d7e5			 
d7e5			;	ld c, 2 
d7e5			;	;ld de, .cls 
d7e5			;	ld a, 27 
d7e5			;	rst $30 
d7e5			;	ld c, 2 
d7e5			;	;ld de, .cls 
d7e5			;	ld a, '[' 
d7e5			;	rst $30 
d7e5			; 
d7e5			;	ld c, 2 
d7e5			;	;ld de, .cls 
d7e5			;	ld a, 'H' 
d7e5			;	rst $30 
d7e5			; 
d7e5			 
d7e5 0e 02			ld c, 2 
d7e7				;ld de, .cls 
d7e7 3e 1b			ld a, 27 
d7e9 f7				rst $30 
d7ea			 
d7ea			 
d7ea 0e 02			ld c, 2 
d7ec				;ld de, .cls 
d7ec 3e 5b			ld a, '[' 
d7ee f7				rst $30 
d7ef 0e 02			ld c, 2 
d7f1				;ld de, .cls 
d7f1 3e 32			ld a, '2' 
d7f3 f7				rst $30 
d7f4 0e 02			ld c, 2 
d7f6				;ld de, .cls 
d7f6 3e 4a			ld a, 'J' 
d7f8 f7				rst $30 
d7f9 d1				pop de 
d7fa c1				pop bc 
d7fb e1				pop hl 
d7fc			 
d7fc			 
d7fc 22 d8 eb		        ld (display_write_tmp), hl 	  
d7ff 3e 00			ld a, kLCD_Line1 
d801			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d801 06 28			ld b, display_cols 
d803 ed 5b d8 eb		ld de, (display_write_tmp) 
d807 cd 65 d8			call write_len_string 
d80a				 
d80a			 
d80a e5			push hl 
d80b d5			push de 
d80c c5			push bc 
d80d 0e 07			ld c, 7 
d80f f7				rst $30 
d810 c1			pop bc 
d811 d1			pop de 
d812 e1			pop hl 
d813			 
d813				 
d813 2a d8 eb			ld hl, (display_write_tmp) 
d816 11 28 00			ld de, display_cols 
d819 19				add hl,de 
d81a 22 d8 eb			ld (display_write_tmp),hl 
d81d			 
d81d				 
d81d 3e 28			ld a, kLCD_Line2 
d81f			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d81f 06 28			ld b, display_cols 
d821 ed 5b d8 eb		ld de, (display_write_tmp) 
d825 cd 65 d8			call write_len_string 
d828				 
d828 2a d8 eb			ld hl, (display_write_tmp) 
d82b 11 28 00			ld de, display_cols 
d82e 19				add hl,de 
d82f 22 d8 eb			ld (display_write_tmp),hl 
d832			 
d832 e5			push hl 
d833 d5			push de 
d834 c5			push bc 
d835 0e 07			ld c, 7 
d837 f7				rst $30 
d838 c1			pop bc 
d839 d1			pop de 
d83a e1			pop hl 
d83b			 
d83b				 
d83b 3e 50			ld a, kLCD_Line3 
d83d			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
d83d 06 28			ld b, display_cols 
d83f ed 5b d8 eb		ld de, (display_write_tmp) 
d843 cd 65 d8			call write_len_string 
d846				 
d846 2a d8 eb			ld hl, (display_write_tmp) 
d849 11 28 00			ld de, display_cols 
d84c 19				add hl,de 
d84d 22 d8 eb			ld (display_write_tmp),hl 
d850			 
d850 e5			push hl 
d851 d5			push de 
d852 c5			push bc 
d853 0e 07			ld c, 7 
d855 f7				rst $30 
d856 c1			pop bc 
d857 d1			pop de 
d858 e1			pop hl 
d859			 
d859				 
d859 3e 78			ld a, kLCD_Line4 
d85b			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
d85b 06 28			ld b, display_cols 
d85d ed 5b d8 eb		ld de, (display_write_tmp) 
d861 cd 65 d8			call write_len_string 
d864 c9					ret 
d865			 
d865			 
d865				; write out a fixed length string given in b from de 
d865			 
d865 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
d866 cd d8 d7		            CALL fLCD_Data      ;Write character to display 
d869 13				inc de 
d86a 10 f9			djnz write_len_string 
d86c c9				ret 
d86d			 
d86d			 
d86d			; eof 
# End of file firmware_serial_display.asm
d86d			;include "firmware_key_5x10.asm" 
d86d			;;include "firmware_key_4x10.asm" 
d86d			include "firmware_key_serial.asm" 
d86d			; Serial keyboard interface for SC114 
d86d			 
d86d			key_init: 
d86d				; no init as handled by the SCM bios 
d86d c9				ret 
d86e			 
d86e			 
d86e			cin_wait: 
d86e			;	ld a, 0 
d86e			;	ret 
d86e			 
d86e				;in a,(SC114_SIO_1_IN) 
d86e			        ; Use SCM API to get from whatever console device we are using 
d86e c5				push bc 
d86f 0e 01			ld c, $01 
d871 f7				rst $30 
d872 c1				pop bc 
d873 c9				ret 
d874			 
d874			cin: 
d874			 
d874			 
d874 c5				push bc 
d875			 
d875				; any key waiting to process? 
d875 0e 03			ld c, $03 
d877 f7				rst $30 
d878 28 05			jr z, .cin_skip 
d87a			 
d87a				; yep, get it 
d87a			 
d87a 0e 01			ld c, $01 
d87c f7				rst $30 
d87d c1				pop bc 
d87e c9				ret 
d87f			.cin_skip: 
d87f 3e 00			ld a, 0 
d881 c1				pop bc 
d882 c9				ret 
d883			 
d883			 
d883			 
d883			 
# End of file firmware_key_serial.asm
d883			endofcode:  
d883			baseram:  
d883 00				nop 
d884			 
d884			heap_start: equ baseram+15  ; Starting address of heap 
d884			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
d884			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
d884			;VDU:  EQU     endofcode           ; BASIC Work space 
d884			; eof 
d884			 
# End of file os_mega_sc114.asm
d884
