# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 f3 94			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			;        nop  
8003			;        nop 
8003			;;	org 05h		; null out bdos call 
8003			; 
8003			;        nop  
8003			;        nop  
8003			;        nop 
8003			;;	org 08h 
8003			;;; 
8003			;;	jp cin		; rst 8 - char in 
8003			;;; 
8003			; 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;	org 010h 
8003			;; 
8003			;	jp cout		; rest 010h  - char out 
8003			;; 
8003			;	org 01bh   
8003			; 
8003			;	;jp  		; rst 01bh   - write string to display 
8003			;	jp str_at_display 
8003			; 
8003			; 
8003			;	org 020h 
8003			; 
8003			;	; jp		 ; rst 020h - read char at screen location 
8003			; 
8003			;	org 028h 
8003			 
8003				; jp		 ; rst 028h  - storage i/o 
8003			 
8003			; 	org 030h 
8003			;	jp break_point_state 
8003			  
8003			; $30  
8003			; org 038h 
8003			; $38 
8003			 
8003			; TODO any more important entry points to add to jump table for easier coding use? 
8003			 
8003			 
8003			include "firmware.asm" 
8003			  
8003			; main constants (used here and in firmware)  
8003			  
8003			; TODO have page 0 of storage as bios  
8003			  
8003			Device_A: equ 0h  
8003			Device_B: equ 040h          ; Sound  
8003			  
8003			if BASE_KEV  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_SC114  
8003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			; TODO fixup for CPM  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			Device_D: equ 0c0h             ; Keyboard and LCD  
8003			  
8003			; Odd specific debug points for testing hardware dev  
8003			  
8003			DEBUG_SOUND: equ 1  
8003			DEBUG_STK_FAULT: equ 0  
8003			DEBUG_INPUT: equ 0     ; Debug input entry code  
8003			DEBUG_KEYCINWAIT: equ 0  
8003			DEBUG_KEYCIN: equ 0  
8003			DEBUG_KEY: equ 0  
8003			DEBUG_KEY_MATRIX: equ 0  
8003			DEBUG_STORECF: equ 0  
8003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
8003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
8003			DEBUG_SPI: equ 0    ; low level spi tests  
8003			  
8003			; Enable many break points  
8003			  
8003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
8003			DEBUG_FORTH_JP: equ 0    ; 4  
8003			DEBUG_FORTH_MALLOC: equ 0  
8003			DEBUG_FORTH_MALLOC_INT: equ 0  
8003			DEBUG_FORTH_DOT: equ 0  
8003			DEBUG_FORTH_DOT_WAIT: equ 0  
8003			DEBUG_FORTH_MATHS: equ 0  
8003			DEBUG_FORTH_TOK: equ 0    ; 4  
8003			DEBUG_FORTH_PARSE: equ 0    ; 3  
8003			DEBUG_FORTH: equ 0  ;2  
8003			DEBUG_FORTH_WORDS: equ 1   ; 1  
8003			DEBUG_FORTH_PUSH: equ 1   ; 1  
8003			DEBUG_FORTH_UWORD: equ 1   ; 1  
8003			  
8003			; Enable key point breakpoints  
8003			  
8003			DEBUG_FORTH_DOT_KEY: equ 0  
8003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
8003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
8003			  
8003			; Debug stack imbalances  
8003			  
8003			ON: equ 1  
8003			OFF: equ 0  
8003			  
8003			DEBUG_STACK_IMB: equ 0  
8003			STACK_IMB_STORE: equ 20  
8003			  
8003			; House keeping and protections  
8003			  
8003			DEBUG_FORTH_STACK_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
8003			FORTH_ENABLE_FREE: equ 0  
8003			FORTH_ENABLE_MALLOCFREE: equ 1  
8003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
8003			FORTH_ENABLE_FLOATMATH: equ 0  
8003			  
8003			  
8003			CALLMONITOR: macro  
8003				call break_point_state  
8003				endm  
8003			  
8003			MALLOC_1: equ 1        ; from dk88   
8003			MALLOC_2: equ 0           ; broke  
8003			MALLOC_3: equ 0           ; really broke  
8003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
8003			  
8003			if BASE_KEV   
8003			stacksize: equ 512*2  
8003			  
8003			STACK_RET_SIZE: equ 128  
8003			STACK_LOOP_SIZE: equ 512  
8003			STACK_DATA_SIZE: equ 512  
8003			endif  
8003			if BASE_SC114  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			;if STORAGE_SE == 0  
8003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
8003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
8003			;endif  
8003			  
8003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
8003			  
8003			STORE_0_AUTOFILE: equ $21  
8003			STORE_0_BANKRUN: equ $23  
8003			STORE_0_FILERUN: equ $24  
8003			  
8003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
8003			  
8003			STORE_0_AUTORUN: equ $20  
8003			  
8003			; Blocks where directory table is held  
8003			  
8003			; Reducing the number of entries increases the max file size  
8003			  
8003			;STORE_DIR_START: equ 1  
8003			;STORE_DIR_END: equ 33  
8003			  
8003			; Blocks from where file data is stored  
8003			  
8003			;STORE_DATA_START: equ STORE_DIR_END + 1  
8003			  
8003			; Block indicators (<32 are data files)  
8003			  
8003			;STORE_BLOCK_CFG: equ $8f       ; config block  
8003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
8003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
8003			;STORE_BLOCK_FREE: equ $85       ; data block free  
8003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
8003			  
8003			  
8003			  
8003			; Directory entry flags  
8003			  
8003			;STORE_DIR_FREE: equ 0  
8003			;STORE_DIR_FILE:  equ 1  
8003			  
8003			; Structure offsets to directory entries  
8003			;STORE_DE_FLAG: equ 0  
8003			;STORE_DE_MAXEXT: equ 1  
8003			;STORE_DE_FILENAME: equ 2  
8003			  
8003			; Structure offsets to block 0  
8003			  
8003			;STORE_BK0_ISFOR: equ 1  
8003			;STORE_BK0_LABEL: equ 3  
8003			  
8003			; memory allocation   
8003			  
8003			chk_stund: equ tos+2           ; underflow check word  
8003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
8003			  
8003			; keyscan table needs rows x cols buffer  
8003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
8003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
8003			  
8003			keyscan_table_row1: equ chk_stovr -key_cols-1  
8003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
8003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
8003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
8003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
8003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
8003			keyscan_scancol: equ keyscan_table-key_cols  
8003			;keyscan_table_len: equ key_rows*key_cols  
8003			;keybufptr: equ keyscan_table - 2  
8003			;keysymbol: equ keybufptr - 1  
8003			key_held: equ keyscan_scancol-1	; currently held  
8003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
8003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
8003			key_fa: equ key_repeat_ct -1 ;  
8003			key_fb: equ key_fa -1 ;  
8003			key_fc: equ key_fb -1 ;  
8003			key_fd: equ key_fc -1 ;  
8003			key_face_held: equ key_fd - 1   
8003			  
8003			; flag for enabling/disabling various hardware diags   
8003			  
8003			hardware_diag: equ key_face_held - 1  
8003			  
8003			; hardware config switches  
8003			; TODO add bitmasks on includes for hardware  
8003			; high byte for expansion ids  
8003			;     0000 0000  no card inserted  
8003			;     0000 0001  storage card inserted  
8003			;     0000 0010  spi sd card active  
8003			  
8003			;       
8003			; low byte:  
8003			;     0000 0001   4x4 keypad  
8003			;     0000 0010   full keyboard  
8003			;     0000 0011   spi/ext keyboard  
8003			;     0000 0100   20x4 lcd  
8003			;     0000 1000   40x4 lcd  
8003			;     0000 1100   spi/ext display  
8003			;     0001 0000   ide interface available  
8003			  
8003			hardware_word: equ hardware_diag - 2  
8003			  
8003			; debug marker - optional display of debug point on the debug screens  
8003			  
8003			debug_mark: equ hardware_word - 4  
8003			  
8003			; input_str vars  
8003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
8003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
8003			input_size: equ input_start -1  ; number of chars  
8003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
8003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
8003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
8003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
8003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
8003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
8003			input_len: equ input_cur_onoff - 5 ; length of current input  
8003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
8003			  
8003			CUR_BLINK_RATE: equ 15  
8003			  
8003			key_actual_pressed: equ input_cursor - 1   
8003			key_symbol: equ key_actual_pressed - 1   
8003			key_shift: equ key_symbol - 1   
8003			  
8003			; Display allocation  
8003			  
8003			;display_rows: equ 4     ; move out to mini and mega files  
8003			;display_cols: equ 20  
8003			  
8003			display_fb_len: equ display_rows*display_cols  
8003			  
8003			; primary frame buffer     
8003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
8003			; working frame buffers  
8003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
8003			display_fb3: equ  display_fb1-display_fb_len - 1  
8003			display_fb2: equ  display_fb3-display_fb_len - 1  
8003			;  
8003			; pointer to active frame buffer  
8003			display_fb_active: equ display_fb2 - 2  
8003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
8003			display_write_tmp: equ display_lcde1e2 - 2  
8003			  
8003			  
8003			;  
8003			  
8003			;; can load into de directory  
8003			cursor_col: equ display_write_tmp-1  
8003			cursor_row: equ cursor_col-1  
8003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
8003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
8003			  
8003			; maths vars  
8003			  
8003			LFSRSeed: equ cursor_shape -20   
8003			randData: equ LFSRSeed - 2  
8003			xrandc: equ randData - 2  
8003			stackstore: equ xrandc - 2  
8003			seed1: equ  stackstore -2   
8003			seed2: equ seed1 - 2  
8003			  
8003			; cf storage vars  
8003			  
8003			iErrorNum:  equ seed2-1         ;Error number  
8003			iErrorReg:  equ iErrorNum -1              ;Error register  
8003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
8003			  
8003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
8003			  
8003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
8003			  
8003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
8003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
8003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
8003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
8003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
8003			store_tmpid: equ store_tmp3 - 1		; page temp id  
8003			store_tmpext: equ store_tmpid - 1		; file extent temp  
8003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
8003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
8003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
8003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
8003			;  
8003			; spi vars  
8003			  
8003			  
8003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
8003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
8003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
8003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
8003			spi_device_id: equ spi_device - 1    ; human readable bank number  
8003			  
8003			;;;;; forth cli params  
8003			  
8003			; TODO use a different frame buffer for forth???  
8003			  
8003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
8003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
8003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
8003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
8003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
8003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
8003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
8003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
8003			  
8003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
8003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
8003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
8003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
8003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
8003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
8003			  
8003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
8003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
8003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
8003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
8003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
8003			  
8003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
8003			  
8003			; os/forth token vars  
8003			  
8003			os_last_cmd: equ os_var_array-255  
8003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
8003			os_current_i: equ os_cli_cmd-2  
8003			os_cur_ptr: equ os_current_i-2  
8003			os_word_scratch: equ os_cur_ptr-30  
8003			os_tok_len: equ os_word_scratch - 2  
8003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
8003			os_tok_malloc: equ os_tok_ptr - 2  
8003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
8003			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
8003			execscratch: equ os_input-255        ; exec cmd eval buffer  
8003			scratch: equ execscratch-255  
8003			  
8003			  
8003			; temp locations for new word processing to save on adding more   
8003			  
8003			os_new_malloc: equ scratch-2  
8003			os_new_parse_len: equ os_new_malloc - 2  
8003			os_new_word_len: equ os_new_parse_len - 2  
8003			os_new_work_ptr: equ os_new_word_len - 2  
8003			os_new_src_ptr: equ os_new_work_ptr - 2  
8003			os_new_exec: equ os_new_src_ptr - 2  
8003			os_new_exec_ptr: equ os_new_exec - 2  
8003			  
8003			; resume memory alloocations....  
8003			  
8003			os_view_disable: equ os_new_exec_ptr - 1  
8003			os_view_af: equ os_view_disable - 2  
8003			os_view_hl: equ os_view_af -2  
8003			os_view_de: equ os_view_hl - 2  
8003			os_view_bc: equ os_view_de - 2  
8003			  
8003			; stack checksum word  
8003			if DEBUG_STACK_IMB  
8003				curframe: equ  os_view_de - 5  
8003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
8003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			else  
8003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			endif  
8003			  
8003			; with data stack could see memory filled with junk. need some memory management   
8003			; malloc and free entry points added  
8003			  
8003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
8003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			;heap_end: equ free_list-1  ; Starting address of heap  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			heap_end: equ chk_word-1  ; Starting address of heap  
8003			  
8003			  
8003			;if BASE_KEV   
8003			;heap_start: equ 0800eh  ; Starting address of heap  
8003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;heap_start: equ baseram+15  ; Starting address of heap  
8003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;endif  
8003			  
8003			  
8003			;;;;  
8003			  
8003			  
8003			; change below to point to last memory alloc above  
8003			topusermem:  equ   heap_start  
8003			  
8003			;if BASE_KEV   
8003			;baseusermem: equ 08000h  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;;aseusermem:     equ    12  
8003			;baseusermem:     equ    prompt  
8003			;;baseusermem:     equ    endofcode  
8003			;endif  
8003			  
8003			  
8003			; **********************************************************************  
8003			; **  Constants  
8003			; **********************************************************************  
8003			  
8003			; Constants used by this code module  
8003			kDataReg:   EQU Device_D           ;PIO port A data register  
8003			kContReg:   EQU Device_D+2           ;PIO port A control register  
8003			  
8003			  
8003			portbdata:  equ Device_D+1    ; port b data  
8003			portbctl:   equ Device_D+3    ; port b control  
8003			  
8003			  
8003			;KEY_SHIFT:   equ 5  
8003			;KEY_SYMBOLSHIFT:  equ 6  
8003			  
8003			KEY_SHIFTLOCK: equ 4  
8003			  
8003			  
8003			KEY_UP: equ 5  
8003			KEY_NEXTWORD: equ 6  
8003			KEY_PREVWORD: equ 7  
8003			KEY_BS: equ 8  
8003			KEY_TAB:  equ 9  
8003			KEY_DOWN: equ 10  
8003			KEY_LEFT: equ 11  
8003			KEY_RIGHT: equ 12  
8003			KEY_CR:   equ 13  
8003			KEY_HOME: equ 14  
8003			KEY_END: equ 15  
8003			  
8003			KEY_F1: equ 16  
8003			KEY_F2: equ 17  
8003			KEY_F3: equ 18  
8003			KEY_F4: equ 19  
8003			  
8003			KEY_F5: equ 20  
8003			KEY_F6: equ 21  
8003			KEY_F7: equ 22  
8003			KEY_F8: equ 23  
8003			  
8003			KEY_F9: equ 24  
8003			KEY_F10: equ 25  
8003			KEY_F11: equ 26  
8003			KEY_F12: equ 27  
8003			  
8003			;if DEBUG_KEY  
8003			;	KEY_MATRIX_NO_PRESS: equ '.'  
8003			;	KEY_SHIFT:   equ '.'  
8003			;	KEY_SYMBOLSHIFT:  equ '.'  
8003			;else  
8003				KEY_SHIFT:   equ '~'  
8003				KEY_SYMBOLSHIFT:  equ '~'  
8003				KEY_MATRIX_NO_PRESS: equ '~'  
8003			;endi  
8003			  
8003			  
8003			  
8003			  
8003			; Macro to make adding debug marks easier  
8003			  
8003			DMARK: macro str  
8003				push af  
8003				ld a, (.dmark)  
8003				ld (debug_mark),a  
8003				ld a, (.dmark+1)  
8003				ld (debug_mark+1),a  
8003				ld a, (.dmark+2)  
8003				ld (debug_mark+2),a  
8003				jr .pastdmark  
8003			.dmark: db str  
8003			.pastdmark: pop af  
8003			  
8003			endm  
8003			  
8003			  
8003			; macro to detect for stack imbalances  
8003			  
8003			include "stackimbal.asm"  
8003			; Macro and code to detect stock imbalances 
8003			 
8003			SPPUSH: equ 0 
8003			 
8003			; Add a stack frame which can be checked before return 
8003			 
8003			STACKFRAME: macro onoff frame1 frame2 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003						exx 
8003			 
8003						ld de, frame1 
8003						ld a, d 
8003						ld hl, curframe 
8003						call hexout 
8003						ld a, e 
8003						ld hl, curframe+2 
8003						call hexout 
8003			  
8003						ld hl, frame1 
8003						push hl 
8003						ld hl, frame2 
8003						push hl 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			endm 
8003			 
8003			STACKFRAMECHK: macro onoff frame1 frame2 
8003			 
8003					 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						exx 
8003						; check stack frame SP 
8003			 
8003						ld hl, frame2 
8003						pop de   ; frame2 
8003			 
8003						call cmp16 
8003						jr nz, .spnosame 
8003						 
8003			 
8003						ld hl, frame1 
8003						pop de   ; frame1 
8003			 
8003						call cmp16 
8003						jr z, .spfrsame 
8003			 
8003						.spnosame: call showsperror 
8003			 
8003						.spfrsame: nop 
8003			 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			 
8003			 
8003			endm 
8003			 
8003			 
8003			; for a sub routine, wrap SP collection and comparisons 
8003			 
8003			; Usage: 
8003			; 
8003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
8003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
8003			 
8003			SAVESP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003			 
8003						ld (store_sp+(storeword*4)), sp 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			CHECKSP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003			 
8003						; save SP after last save 
8003				 
8003						ld (store_sp+(storeword*4)+2), sp 
8003			 
8003						push hl 
8003						ld hl, store_sp+(storeword*4) 
8003						call check_stack_sp  
8003						pop hl 
8003			 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			if DEBUG_STACK_IMB 
8003			 
8003			check_stack_sp: 
8003					push de 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					push de 
8003			 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					pop hl 
8003			 
8003			 
8003					; check to see if the same 
8003			 
8003					call cmp16 
8003					jr z, .spsame 
8003			 
8003					; not same 
8003			 
8003					call showsperror 
8003			.spsame: 
8003			 
8003					pop de 
8003			 
8003					ret 
8003			 
8003			.sperr:  db "Stack imbalance",0 
8003			 
8003			 
8003			showsperror: 
8003			 
8003			 
8003				push hl 
8003				push af 
8003				push de 
8003				call clear_display 
8003				ld de, .sperr 
8003				ld a,0 
8003			;	ld de,os_word_scratch 
8003				call str_at_display 
8003				ld a, display_row_1+17 
8003				ld de, debug_mark 
8003				call str_at_display 
8003				ld a, 0 
8003				ld (curframe+4),a 
8003				ld hl, curframe 
8003				ld de, os_word_scratch 
8003				ld a, display_row_4 
8003				call str_at_display 
8003				call update_display 
8003				;call break_point_state 
8003				call cin_wait 
8003			 
8003				ld a, ' ' 
8003				ld (os_view_disable), a 
8003				pop de	 
8003				pop af 
8003				pop hl 
8003				CALLMONITOR 
8003				ret 
8003			 
8003			endif 
8003			 
8003			 
8003			 
8003			; eof 
# End of file stackimbal.asm
8003			  
8003			;TODO macro to calc col and row offset into screen  
8003			  
8003			  
8003			  
8003			hardware_init:  
8003			  
8003 3e 00				ld a, 0  
8005 32 80 ee				ld (hardware_diag), a  
8008			  
8008					; clear all the buffers  
8008			  
8008 21 1f ed				ld hl, display_fb1  
800b 22 db eb				ld (display_fb_active), hl  
800e			  
800e cd 7d 88				call clear_display  
8011			  
8011 21 dd eb				ld hl, display_fb2  
8014 22 db eb				ld (display_fb_active), hl  
8017			  
8017 cd 7d 88				call clear_display  
801a			  
801a					; init primary frame buffer area  
801a 21 c0 ed				ld hl, display_fb0  
801d 22 db eb				ld (display_fb_active), hl  
8020			  
8020 cd 7d 88				call clear_display  
8023			  
8023			  
8023 cd 90 d6				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8026			  
8026 cd 32 d7			call key_init  
8029 cd b0 80			call storage_init  
802c			  
802c				; setup malloc functions  
802c			  
802c				if MALLOC_1  
802c cd 4d 8f				call  heap_init  
802f				endif  
802f				if MALLOC_4  
802f					call  heap_init  
802f				endif  
802f			  
802f				; init sound hardware if present  
802f			  
802f				if SOUND_ENABLE  
802f					call sound_init  
802f				endif  
802f			  
802f				; lcd test sequence  
802f					  
802f cd a0 88			call update_display  
8032 cd fd 87			call delay1s  
8035 3e 2b			ld a,'+'  
8037 cd 82 88			call fill_display  
803a cd a0 88			call update_display  
803d cd fd 87			call delay1s  
8040 3e 2a			ld a,'*'  
8042 cd 82 88			call fill_display  
8045 cd a0 88			call update_display  
8048 cd fd 87			call delay1s  
804b 3e 2d			ld a,'-'  
804d cd 82 88			call fill_display  
8050 cd a0 88			call update_display  
8053 cd fd 87			call delay1s  
8056			  
8056			; boot splash screen  
8056			if display_cols == 20	  
8056			        ld a, display_row_1    
8056			else  
8056 3e 0a		        ld a, display_row_1 +10   
8058			endif  
8058 11 89 80			ld de, bootmsg  
805b cd 90 88			call str_at_display  
805e cd a0 88			call update_display  
8061			  
8061			  
8061 cd fd 87			call delay1s  
8064 cd fd 87			call delay1s  
8067			if display_cols == 20	  
8067			            LD   A, display_row_3+2  
8067			else  
8067 3e 5c		            LD   A, display_row_3+12  
8069			endif  
8069 11 9e 80			ld de, bootmsg1  
806c cd 90 88			call str_at_display  
806f cd a0 88			call update_display  
8072 cd fd 87			call delay1s  
8075 cd fd 87			call delay1s  
8078			  
8078			;	ld a, display_row_4+3  
8078			;	ld de, bootmsg2  
8078			;	call str_at_display  
8078			;	call update_display  
8078			;	call delay1s  
8078			;	call delay1s  
8078			  
8078			; debug mark setup  
8078			  
8078 3e 5f		ld a, '_'  
807a 32 7a ee		ld (debug_mark),a  
807d 32 7b ee		ld (debug_mark+1),a  
8080 32 7c ee		ld (debug_mark+2),a  
8083 3e 00		ld a,0  
8085 32 7d ee		ld (debug_mark+3),a  
8088			  
8088 c9					ret  
8089			  
8089			  
8089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
809e .. 00		bootmsg1:	db "by Kevin Groves",0  
80ae			;bootmsg2:	db "Firmware v0.1",0  
80ae			  
80ae			; a 4x20 lcd  
80ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80ae			  
80ae			;if display_cols == 20  
80ae			;	include "firmware_lcd_4x20.asm"  
80ae			;endif  
80ae			  
80ae			;if display_cols == 40  
80ae			;	include "firmware_lcd_4x40.asm"  
80ae			;endif  
80ae			  
80ae			;  
80ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80ae			; TODO abstract the bit bang video out interface for dual display  
80ae			; TODO wire video out to tx pin on rc2014 bus  
80ae			  
80ae			; must supply cin, and cin_wait for low level hardware abstraction   
80ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80ae			; test scancode  
80ae			  
80ae			;;;;;  
80ae			;;;  
80ae			; Moved out to mini and maxi versions  
80ae			;  
80ae			; include "firmware_key_4x4.asm"  
80ae			; using existing 4 wire x 4 resistor array for input  
80ae			;include "firmware_key_4x10.asm"  
80ae			; need to mod the board for 5 rows due to resistor array  
80ae			;include "firmware_key_5x10.asm"  
80ae			  
80ae			; storage hardware interface  
80ae			  
80ae			; use microchip serial eeprom for storage  
80ae			  
80ae			  
80ae			if STORAGE_SE  
80ae				include "firmware_spi.asm"  
80ae				include "firmware_seeprom.asm"  
80ae			else  
80ae			   ; create some stubs for the labels  
80ae c9			se_readbyte: ret  
80af c9			se_writebyte: ret  
80b0 c9			storage_init: ret  
80b1			  
80b1			endif  
80b1			  
80b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80b1			;include "firmware_cf.asm"  
80b1			  
80b1			; load up high level storage hardward abstractions  
80b1			include "firmware_storage.asm"  
80b1			 
80b1			; persisent storage hardware abstraction layer  
80b1			 
80b1			 
80b1			 
80b1			; Block 0 on storage is a config state 
80b1			 
80b1			 
80b1			 
80b1			; TODO add read phy block and write phy block functions 
80b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80b1			 
80b1			; Abstraction layer  
80b1			 
80b1			; Logocial block size is same size as physical size - using tape concept 
80b1			 
80b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80b1			 
80b1			 
80b1			 
80b1			; Filesystem layout (Logical layout) 
80b1			; 
80b1			; Block 0 - Bank config  
80b1			; 
80b1			;      Byte - 0 file id counter 
80b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80b1			;      Byte - 3-20 zero terminated bank label 
80b1			; 
80b1			; Block 1 > File storage 
80b1			; 
80b1			;      Byte 0 file id    - block 0 file details 
80b1			;      Byte 1 block id - block 0 is file  
80b1			;            Byte 2-15 - File name 
80b1			; 
80b1			;       - to end of block data 
80b1			; 
80b1			 
80b1			 
80b1			; Read Block 
80b1			; ---------- 
80b1			; 
80b1			; With current bank 
80b1			;  
80b1			; Get block number to read 
80b1			; Load physical blocks starting at start block into buffer 
80b1			 
80b1			; de points to buffer to use 
80b1			; hl holds logical block number  
80b1			 
80b1			storage_read_block: 
80b1			 
80b1				; TODO bank selection 
80b1			 
80b1				; for each of the physical blocks read it into the buffer 
80b1 06 40			ld b, STORE_BLOCK_PHY 
80b3			 
80b3				if DEBUG_STORESE 
80b3 d5					push de 
80b4				endif 
80b4				 
80b4			.rl1:    
80b4			 
80b4				; read physical block at hl into de 
80b4			        ; increment hl and de to next read position on exit 
80b4			 
80b4 e5				push hl 
80b5 d5				push de	 
80b6 c5				push bc 
80b7			;	if DEBUG_STORESE 
80b7			;		push af 
80b7			;		ld a, 'R' 
80b7			;		ld (debug_mark),a 
80b7			;		pop af 
80b7			;		CALLMONITOR 
80b7			;	endif 
80b7 cd ae 80			call se_readbyte 
80ba			;	if DEBUG_STORESE 
80ba			;		ld a,(spi_portbyte) 
80ba			;		ld l, a 
80ba			;		push af 
80ba			;		ld a, '1' 
80ba			;		ld (debug_mark),a 
80ba			;		pop af 
80ba			;		CALLMONITOR 
80ba			;	endif 
80ba c1				pop bc 
80bb d1				pop de 
80bc e1				pop hl 
80bd 12				ld (de),a 
80be 23				inc hl 
80bf 13				inc de 
80c0			 
80c0			;	if DEBUG_STORESE 
80c0			;		push af 
80c0			;		ld a, 'r' 
80c0			;		ld (debug_mark),a 
80c0			;		pop af 
80c0			;		CALLMONITOR 
80c0			;	endif 
80c0			 
80c0 10 f2			djnz .rl1 
80c2			 
80c2				if DEBUG_STORESE 
80c2					DMARK "SRB" 
80c2 f5				push af  
80c3 3a d7 80			ld a, (.dmark)  
80c6 32 7a ee			ld (debug_mark),a  
80c9 3a d8 80			ld a, (.dmark+1)  
80cc 32 7b ee			ld (debug_mark+1),a  
80cf 3a d9 80			ld a, (.dmark+2)  
80d2 32 7c ee			ld (debug_mark+2),a  
80d5 18 03			jr .pastdmark  
80d7 ..			.dmark: db "SRB"  
80da f1			.pastdmark: pop af  
80db			endm  
# End of macro DMARK
80db d1					pop de 
80dc			; 
80dc			;		push af 
80dc			;		ld a, 'R' 
80dc			;		ld (debug_mark),a 
80dc			;		pop af 
80dc					CALLMONITOR 
80dc cd 1d 93			call break_point_state  
80df				endm  
# End of macro CALLMONITOR
80df				endif 
80df c9				ret	 
80e0				 
80e0			 
80e0			; File Size 
80e0			; --------- 
80e0			; 
80e0			;   hl file id 
80e0			; 
80e0			;  returns in hl the number of blocks 
80e0			 
80e0			storage_file_size: 
80e0 5d				ld e, l 
80e1 16 00			ld d, 0 
80e3 21 40 00			ld hl, STORE_BLOCK_PHY 
80e6					if DEBUG_FORTH_WORDS 
80e6						DMARK "SIZ" 
80e6 f5				push af  
80e7 3a fb 80			ld a, (.dmark)  
80ea 32 7a ee			ld (debug_mark),a  
80ed 3a fc 80			ld a, (.dmark+1)  
80f0 32 7b ee			ld (debug_mark+1),a  
80f3 3a fd 80			ld a, (.dmark+2)  
80f6 32 7c ee			ld (debug_mark+2),a  
80f9 18 03			jr .pastdmark  
80fb ..			.dmark: db "SIZ"  
80fe f1			.pastdmark: pop af  
80ff			endm  
# End of macro DMARK
80ff						CALLMONITOR 
80ff cd 1d 93			call break_point_state  
8102				endm  
# End of macro CALLMONITOR
8102					endif 
8102 cd d2 83			call storage_findnextid 
8105			 
8105 cd d3 8a			call ishlzero 
8108			;	ld a, l 
8108			;	add h 
8108			;	cp 0 
8108 c8				ret z			; block not found so EOF 
8109			 
8109 11 65 eb			ld de, store_page 
810c cd b1 80			call storage_read_block 
810f			 
810f 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
8112 6f				ld l, a 
8113 26 00			ld h, 0 
8115 c9			 	ret 
8116			 
8116			 
8116			; Write Block 
8116			; ----------- 
8116			; 
8116			; With current bank 
8116			;  
8116			; Get block number to write 
8116			; Write physical blocks starting at start block from buffer 
8116			  
8116			storage_write_block: 
8116				; TODO bank selection 
8116			 
8116				; for each of the physical blocks read it into the buffer 
8116 06 40			ld b, STORE_BLOCK_PHY 
8118			 
8118				if DEBUG_STORESE 
8118					DMARK "SWB" 
8118 f5				push af  
8119 3a 2d 81			ld a, (.dmark)  
811c 32 7a ee			ld (debug_mark),a  
811f 3a 2e 81			ld a, (.dmark+1)  
8122 32 7b ee			ld (debug_mark+1),a  
8125 3a 2f 81			ld a, (.dmark+2)  
8128 32 7c ee			ld (debug_mark+2),a  
812b 18 03			jr .pastdmark  
812d ..			.dmark: db "SWB"  
8130 f1			.pastdmark: pop af  
8131			endm  
# End of macro DMARK
8131			 
8131					;push af 
8131					;ld a, 'W' 
8131					;ld (debug_mark),a 
8131					;pop af 
8131					CALLMONITOR 
8131 cd 1d 93			call break_point_state  
8134				endm  
# End of macro CALLMONITOR
8134				endif 
8134			 
8134			; might not be working 
8134			;	call se_writepage 
8134			 
8134			;	ret 
8134			; 
8134			 
8134			 
8134			 
8134			.wl1:    
8134			 
8134				; read physical block at hl into de 
8134			        ; increment hl and de to next read position on exit 
8134			 
8134 e5				push hl 
8135 d5				push de	 
8136 c5				push bc 
8137 1a				ld a,(de) 
8138				;if DEBUG_STORESE 
8138			;		push af 
8138			;		ld a, 'W' 
8138			;		ld (debug_mark),a 
8138			;		pop af 
8138			;		CALLMONITOR 
8138			;	endif 
8138 cd af 80			call se_writebyte 
813b			;	call delay250ms 
813b 00				nop 
813c 00				nop 
813d 00				nop 
813e			;	if DEBUG_STORESE 
813e			;		push af 
813e			;		ld a, 'w' 
813e			;		ld (debug_mark),a 
813e			;		pop af 
813e			;		CALLMONITOR 
813e			;	endif 
813e c1				pop bc 
813f d1				pop de 
8140 e1				pop hl 
8141 23				inc hl 
8142 13				inc de 
8143			 
8143			 
8143 10 ef			djnz .wl1 
8145			 
8145				if DEBUG_STORESE 
8145					DMARK "SW2" 
8145 f5				push af  
8146 3a 5a 81			ld a, (.dmark)  
8149 32 7a ee			ld (debug_mark),a  
814c 3a 5b 81			ld a, (.dmark+1)  
814f 32 7b ee			ld (debug_mark+1),a  
8152 3a 5c 81			ld a, (.dmark+2)  
8155 32 7c ee			ld (debug_mark+2),a  
8158 18 03			jr .pastdmark  
815a ..			.dmark: db "SW2"  
815d f1			.pastdmark: pop af  
815e			endm  
# End of macro DMARK
815e			 
815e					;push af 
815e					;ld a, 'W' 
815e					;ld (debug_mark),a 
815e					;pop af 
815e					CALLMONITOR 
815e cd 1d 93			call break_point_state  
8161				endm  
# End of macro CALLMONITOR
8161				endif 
8161 c9				ret	 
8162			 
8162			; Init bank 
8162			; --------- 
8162			; 
8162			; With current bank 
8162			; 
8162			; Setup block 0 config 
8162			;     Set 0 file id counter 
8162			;     Set formatted byte pattern 
8162			;     Zero out bank label 
8162			;      
8162			; For every logical block write 0-1 byte as null 
8162			 
8162			storage_get_block_0: 
8162			 
8162				; TODO check presence 
8162			 
8162				; get block 0 config 
8162			 
8162 21 00 00			ld hl, 0 
8165 11 65 eb			ld de, store_page 
8168 cd b1 80			call storage_read_block 
816b			 
816b				if DEBUG_STORESE 
816b					DMARK "SB0" 
816b f5				push af  
816c 3a 80 81			ld a, (.dmark)  
816f 32 7a ee			ld (debug_mark),a  
8172 3a 81 81			ld a, (.dmark+1)  
8175 32 7b ee			ld (debug_mark+1),a  
8178 3a 82 81			ld a, (.dmark+2)  
817b 32 7c ee			ld (debug_mark+2),a  
817e 18 03			jr .pastdmark  
8180 ..			.dmark: db "SB0"  
8183 f1			.pastdmark: pop af  
8184			endm  
# End of macro DMARK
8184 11 65 eb				ld de, store_page 
8187			;		push af 
8187			;		ld a, 'i' 
8187			;		ld (debug_mark),a 
8187			;		pop af 
8187					CALLMONITOR 
8187 cd 1d 93			call break_point_state  
818a				endm  
# End of macro CALLMONITOR
818a				endif 
818a			 
818a				; is this area formatted? 
818a			 
818a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
818a 2a 66 eb			ld hl, (store_page+1) 
818d 3e 80			ld a,0x80 
818f bd				cp l 
8190 20 22			jr nz, .ininotformatted 
8192				; do a double check 
8192 3e 27			ld a, 0x27 
8194 bc				cp h 
8195 20 1d			jr nz, .ininotformatted 
8197			 
8197				; formatted then 
8197			 
8197				if DEBUG_STORESE 
8197					DMARK "SB1" 
8197 f5				push af  
8198 3a ac 81			ld a, (.dmark)  
819b 32 7a ee			ld (debug_mark),a  
819e 3a ad 81			ld a, (.dmark+1)  
81a1 32 7b ee			ld (debug_mark+1),a  
81a4 3a ae 81			ld a, (.dmark+2)  
81a7 32 7c ee			ld (debug_mark+2),a  
81aa 18 03			jr .pastdmark  
81ac ..			.dmark: db "SB1"  
81af f1			.pastdmark: pop af  
81b0			endm  
# End of macro DMARK
81b0					;push af 
81b0					;ld a, 'I' 
81b0					;ld (debug_mark),a 
81b0					;pop af 
81b0					CALLMONITOR 
81b0 cd 1d 93			call break_point_state  
81b3				endm  
# End of macro CALLMONITOR
81b3				endif 
81b3 c9				ret 
81b4			 
81b4			.ininotformatted: 
81b4				; bank not formatted so poke various bits to make sure 
81b4			 
81b4				if DEBUG_STORESE 
81b4					DMARK "SB2" 
81b4 f5				push af  
81b5 3a c9 81			ld a, (.dmark)  
81b8 32 7a ee			ld (debug_mark),a  
81bb 3a ca 81			ld a, (.dmark+1)  
81be 32 7b ee			ld (debug_mark+1),a  
81c1 3a cb 81			ld a, (.dmark+2)  
81c4 32 7c ee			ld (debug_mark+2),a  
81c7 18 03			jr .pastdmark  
81c9 ..			.dmark: db "SB2"  
81cc f1			.pastdmark: pop af  
81cd			endm  
# End of macro DMARK
81cd					;push af 
81cd					;ld a, 'f' 
81cd					;ld (debug_mark),a 
81cd					;pop af 
81cd					CALLMONITOR 
81cd cd 1d 93			call break_point_state  
81d0				endm  
# End of macro CALLMONITOR
81d0				endif 
81d0			 
81d0 cd c0 87			call storage_clear_page 
81d3			 
81d3 21 65 eb			ld hl, store_page 
81d6 3e 00			ld a, 0 
81d8				 
81d8 77				ld (hl),a   ; reset file counter 
81d9			 
81d9 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
81dc 22 66 eb		 	ld (store_page+1), hl	 
81df			 
81df				; set default label 
81df			 
81df 21 7b 82			ld hl, .defaultbanklabl 
81e2 11 68 eb		 	ld de, store_page+3 
81e5 01 0f 00			ld bc, 15 
81e8 ed b0			ldir 
81ea			 
81ea				; Append the current bank id 
81ea 21 71 eb			ld hl, store_page+3+9 
81ed 3a 4a eb			ld a, (spi_device_id) 
81f0 77				ld (hl), a 
81f1			 
81f1				; save default page 0 
81f1			 
81f1 21 00 00			ld hl, 0 
81f4 11 65 eb			ld de, store_page 
81f7				if DEBUG_STORESE 
81f7					DMARK "SB3" 
81f7 f5				push af  
81f8 3a 0c 82			ld a, (.dmark)  
81fb 32 7a ee			ld (debug_mark),a  
81fe 3a 0d 82			ld a, (.dmark+1)  
8201 32 7b ee			ld (debug_mark+1),a  
8204 3a 0e 82			ld a, (.dmark+2)  
8207 32 7c ee			ld (debug_mark+2),a  
820a 18 03			jr .pastdmark  
820c ..			.dmark: db "SB3"  
820f f1			.pastdmark: pop af  
8210			endm  
# End of macro DMARK
8210			;		push af 
8210			;		ld a, 'F' 
8210			;		ld (debug_mark),a 
8210			;		pop af 
8210					CALLMONITOR 
8210 cd 1d 93			call break_point_state  
8213				endm  
# End of macro CALLMONITOR
8213				endif 
8213 cd 16 81			call storage_write_block 
8216				if DEBUG_STORESE 
8216					DMARK "SB4" 
8216 f5				push af  
8217 3a 2b 82			ld a, (.dmark)  
821a 32 7a ee			ld (debug_mark),a  
821d 3a 2c 82			ld a, (.dmark+1)  
8220 32 7b ee			ld (debug_mark+1),a  
8223 3a 2d 82			ld a, (.dmark+2)  
8226 32 7c ee			ld (debug_mark+2),a  
8229 18 03			jr .pastdmark  
822b ..			.dmark: db "SB4"  
822e f1			.pastdmark: pop af  
822f			endm  
# End of macro DMARK
822f			;		push af 
822f			;		ld a, '>' 
822f			;		ld (debug_mark),a 
822f			;		pop af 
822f					CALLMONITOR 
822f cd 1d 93			call break_point_state  
8232				endm  
# End of macro CALLMONITOR
8232				endif 
8232			 
8232 00				nop 
8233 00				nop 
8234 00				nop 
8235			 
8235				; now set 0 in every page to mark as a free block 
8235			 
8235 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8237 21 40 00			ld hl, STORE_BLOCK_PHY 
823a			 
823a 3e 00		.setmark1:   	ld a,0 
823c e5					push hl 
823d c5					push bc 
823e cd af 80				call se_writebyte 
8241 3e 0a			ld a, 10 
8243 cd e2 87			call aDelayInMS 
8246 23				inc hl 
8247 cd af 80				call se_writebyte 
824a 3e 0a			ld a, 10 
824c cd e2 87			call aDelayInMS 
824f 2b				dec hl 
8250 c1					pop bc 
8251 e1					pop hl 
8252 3e 40				ld a, STORE_BLOCK_PHY 
8254 cd aa 8a				call addatohl 
8257 10 e1				djnz .setmark1 
8259			 
8259 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
825b 3e 00		.setmark2:   	ld a,0 
825d e5					push hl 
825e c5					push bc 
825f cd af 80				call se_writebyte 
8262 3e 0a			ld a, 10 
8264 cd e2 87			call aDelayInMS 
8267 23				inc hl 
8268 cd af 80				call se_writebyte 
826b 3e 0a			ld a, 10 
826d cd e2 87			call aDelayInMS 
8270 2b				dec hl 
8271 c1					pop bc 
8272 e1					pop hl 
8273 3e 40				ld a, STORE_BLOCK_PHY 
8275 cd aa 8a				call addatohl 
8278 10 e1				djnz .setmark2 
827a			 
827a					 
827a			 
827a			 
827a c9				ret 
827b			 
827b			 
827b			 
827b			 
827b .. 00		.defaultbanklabl:   db "BankLabel_",0 
8286			 
8286			 
8286			 
8286			; Label Bank 
8286			; ---------- 
8286			; 
8286			; With current bank 
8286			; Read block 0 
8286			; Set label 
8286			; Write block 0 
8286			 
8286			; label str pointer in hl 
8286			 
8286			storage_label:     
8286			 
8286				if DEBUG_STORESE 
8286					DMARK "LBL" 
8286 f5				push af  
8287 3a 9b 82			ld a, (.dmark)  
828a 32 7a ee			ld (debug_mark),a  
828d 3a 9c 82			ld a, (.dmark+1)  
8290 32 7b ee			ld (debug_mark+1),a  
8293 3a 9d 82			ld a, (.dmark+2)  
8296 32 7c ee			ld (debug_mark+2),a  
8299 18 03			jr .pastdmark  
829b ..			.dmark: db "LBL"  
829e f1			.pastdmark: pop af  
829f			endm  
# End of macro DMARK
829f					CALLMONITOR 
829f cd 1d 93			call break_point_state  
82a2				endm  
# End of macro CALLMONITOR
82a2				endif 
82a2			 
82a2 e5				push hl 
82a3			 
82a3 cd 62 81			call storage_get_block_0 
82a6			 
82a6				; set default label 
82a6			 
82a6 e1				pop hl 
82a7			 
82a7 11 68 eb		 	ld de, store_page+3 
82aa 01 0f 00			ld bc, 15 
82ad				if DEBUG_STORESE 
82ad					DMARK "LB3" 
82ad f5				push af  
82ae 3a c2 82			ld a, (.dmark)  
82b1 32 7a ee			ld (debug_mark),a  
82b4 3a c3 82			ld a, (.dmark+1)  
82b7 32 7b ee			ld (debug_mark+1),a  
82ba 3a c4 82			ld a, (.dmark+2)  
82bd 32 7c ee			ld (debug_mark+2),a  
82c0 18 03			jr .pastdmark  
82c2 ..			.dmark: db "LB3"  
82c5 f1			.pastdmark: pop af  
82c6			endm  
# End of macro DMARK
82c6					CALLMONITOR 
82c6 cd 1d 93			call break_point_state  
82c9				endm  
# End of macro CALLMONITOR
82c9				endif 
82c9 ed b0			ldir 
82cb				; save default page 0 
82cb			 
82cb 21 00 00			ld hl, 0 
82ce 11 65 eb			ld de, store_page 
82d1				if DEBUG_STORESE 
82d1					DMARK "LBW" 
82d1 f5				push af  
82d2 3a e6 82			ld a, (.dmark)  
82d5 32 7a ee			ld (debug_mark),a  
82d8 3a e7 82			ld a, (.dmark+1)  
82db 32 7b ee			ld (debug_mark+1),a  
82de 3a e8 82			ld a, (.dmark+2)  
82e1 32 7c ee			ld (debug_mark+2),a  
82e4 18 03			jr .pastdmark  
82e6 ..			.dmark: db "LBW"  
82e9 f1			.pastdmark: pop af  
82ea			endm  
# End of macro DMARK
82ea					CALLMONITOR 
82ea cd 1d 93			call break_point_state  
82ed				endm  
# End of macro CALLMONITOR
82ed				endif 
82ed cd 16 81			call storage_write_block 
82f0			 
82f0 c9				ret 
82f1			 
82f1			 
82f1			 
82f1			; Read Block 0 - Config 
82f1			; --------------------- 
82f1			; 
82f1			; With current bank 
82f1			; Call presence test 
82f1			;    If not present format/init bank  
82f1			; Read block 0  
82f1			;  
82f1			 
82f1			 
82f1			; Dir 
82f1			; --- 
82f1			; 
82f1			; With current bank 
82f1			; Load Block 0 Config 
82f1			; Get max file id number 
82f1			; For each logical block 
82f1			;    Read block read byte 2 
82f1			;      if first block of file 
82f1			;         Display file name 
82f1			;         Display type flags for file 
82f1			;        
82f1			 
82f1			; moving to words as this requires stack control 
82f1			 
82f1			 
82f1			; Delete File 
82f1			; ----------- 
82f1			; 
82f1			; With current bank 
82f1			; 
82f1			; Load Block 0 Config 
82f1			; Get max file id number 
82f1			; For each logical block 
82f1			;    Read block file id 
82f1			;      If first block of file and dont have file id 
82f1			;         if file to delete 
82f1			;         Save file id 
82f1			;         Null file id 
82f1			;         Write this block back 
82f1			;      If file id is one saved 
82f1			;         Null file id 
82f1			;         Write this block back 
82f1			 
82f1			storage_erase: 
82f1			 
82f1				; hl contains the file id 
82f1			 
82f1 5d				ld e, l 
82f2 16 00			ld d, 0 
82f4 21 40 00			ld hl, STORE_BLOCK_PHY 
82f7					if DEBUG_FORTH_WORDS 
82f7						DMARK "ERA" 
82f7 f5				push af  
82f8 3a 0c 83			ld a, (.dmark)  
82fb 32 7a ee			ld (debug_mark),a  
82fe 3a 0d 83			ld a, (.dmark+1)  
8301 32 7b ee			ld (debug_mark+1),a  
8304 3a 0e 83			ld a, (.dmark+2)  
8307 32 7c ee			ld (debug_mark+2),a  
830a 18 03			jr .pastdmark  
830c ..			.dmark: db "ERA"  
830f f1			.pastdmark: pop af  
8310			endm  
# End of macro DMARK
8310						CALLMONITOR 
8310 cd 1d 93			call break_point_state  
8313				endm  
# End of macro CALLMONITOR
8313					endif 
8313 cd d2 83			call storage_findnextid 
8316			 
8316 e5				push hl 
8317			 
8317				; TODO check file not found 
8317			 
8317 11 65 eb			ld de, store_page 
831a cd b1 80			call storage_read_block 
831d			 
831d					if DEBUG_FORTH_WORDS 
831d						DMARK "ER1" 
831d f5				push af  
831e 3a 32 83			ld a, (.dmark)  
8321 32 7a ee			ld (debug_mark),a  
8324 3a 33 83			ld a, (.dmark+1)  
8327 32 7b ee			ld (debug_mark+1),a  
832a 3a 34 83			ld a, (.dmark+2)  
832d 32 7c ee			ld (debug_mark+2),a  
8330 18 03			jr .pastdmark  
8332 ..			.dmark: db "ER1"  
8335 f1			.pastdmark: pop af  
8336			endm  
# End of macro DMARK
8336						CALLMONITOR 
8336 cd 1d 93			call break_point_state  
8339				endm  
# End of macro CALLMONITOR
8339					endif 
8339 3a 65 eb			ld a, (store_page)	; get file id 
833c 32 5e eb			ld (store_tmpid), a 
833f			 
833f 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
8342 32 5d eb			ld (store_tmpext), a 
8345			 
8345				; wipe file header 
8345			 
8345 e1				pop hl 
8346 3e 00			ld a, 0 
8348 32 65 eb			ld (store_page), a 
834b 32 66 eb			ld (store_page+1),a 
834e 11 65 eb			ld de, store_page 
8351					if DEBUG_FORTH_WORDS 
8351						DMARK "ER2" 
8351 f5				push af  
8352 3a 66 83			ld a, (.dmark)  
8355 32 7a ee			ld (debug_mark),a  
8358 3a 67 83			ld a, (.dmark+1)  
835b 32 7b ee			ld (debug_mark+1),a  
835e 3a 68 83			ld a, (.dmark+2)  
8361 32 7c ee			ld (debug_mark+2),a  
8364 18 03			jr .pastdmark  
8366 ..			.dmark: db "ER2"  
8369 f1			.pastdmark: pop af  
836a			endm  
# End of macro DMARK
836a						CALLMONITOR 
836a cd 1d 93			call break_point_state  
836d				endm  
# End of macro CALLMONITOR
836d					endif 
836d cd 16 81			call storage_write_block 
8370			 
8370			 
8370				; wipe file extents 
8370			 
8370 3a 5d eb			ld a, (store_tmpext) 
8373 47				ld b, a 
8374			 
8374			.eraext:	  
8374 c5				push bc 
8375			 
8375 21 40 00			ld hl, STORE_BLOCK_PHY 
8378 3a 5e eb			ld a,(store_tmpid) 
837b 5f				ld e, a 
837c 50				ld d, b	 
837d					if DEBUG_FORTH_WORDS 
837d						DMARK "ER3" 
837d f5				push af  
837e 3a 92 83			ld a, (.dmark)  
8381 32 7a ee			ld (debug_mark),a  
8384 3a 93 83			ld a, (.dmark+1)  
8387 32 7b ee			ld (debug_mark+1),a  
838a 3a 94 83			ld a, (.dmark+2)  
838d 32 7c ee			ld (debug_mark+2),a  
8390 18 03			jr .pastdmark  
8392 ..			.dmark: db "ER3"  
8395 f1			.pastdmark: pop af  
8396			endm  
# End of macro DMARK
8396						CALLMONITOR 
8396 cd 1d 93			call break_point_state  
8399				endm  
# End of macro CALLMONITOR
8399					endif 
8399 cd d2 83			call storage_findnextid 
839c			 
839c e5				push hl 
839d 11 65 eb			ld de, store_page 
83a0 cd b1 80			call storage_read_block 
83a3			 
83a3				; free block	 
83a3			 
83a3 3e 00			ld a, 0 
83a5 32 65 eb			ld (store_page), a 
83a8 32 66 eb			ld (store_page+1),a 
83ab 11 65 eb			ld de, store_page 
83ae e1				pop hl 
83af					if DEBUG_FORTH_WORDS 
83af						DMARK "ER4" 
83af f5				push af  
83b0 3a c4 83			ld a, (.dmark)  
83b3 32 7a ee			ld (debug_mark),a  
83b6 3a c5 83			ld a, (.dmark+1)  
83b9 32 7b ee			ld (debug_mark+1),a  
83bc 3a c6 83			ld a, (.dmark+2)  
83bf 32 7c ee			ld (debug_mark+2),a  
83c2 18 03			jr .pastdmark  
83c4 ..			.dmark: db "ER4"  
83c7 f1			.pastdmark: pop af  
83c8			endm  
# End of macro DMARK
83c8						CALLMONITOR 
83c8 cd 1d 93			call break_point_state  
83cb				endm  
# End of macro CALLMONITOR
83cb					endif 
83cb cd 16 81			call storage_write_block 
83ce			 
83ce c1				pop bc 
83cf 10 a3			djnz .eraext 
83d1			 
83d1 c9				ret 
83d2			 
83d2			 
83d2			; Find Free Block 
83d2			; --------------- 
83d2			; 
83d2			; With current bank 
83d2			;  
83d2			; From given starting logical block 
83d2			;    Read block  
83d2			;    If no file id 
83d2			;         Return block id 
83d2			 
83d2			 
83d2			; hl starting page number 
83d2			; hl contains free page number or zero if no pages free 
83d2			; e contains the file id to locate 
83d2			; d contains the block number 
83d2			 
83d2			; TODO change to find file id and use zero for free block 
83d2			 
83d2			storage_findnextid: 
83d2			 
83d2				; now locate first 0 page to mark as a free block 
83d2			 
83d2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
83d4			;	ld hl, STORE_BLOCK_PHY 
83d4			 
83d4					if DEBUG_FORTH_WORDS 
83d4					DMARK "FNI" 
83d4 f5				push af  
83d5 3a e9 83			ld a, (.dmark)  
83d8 32 7a ee			ld (debug_mark),a  
83db 3a ea 83			ld a, (.dmark+1)  
83de 32 7b ee			ld (debug_mark+1),a  
83e1 3a eb 83			ld a, (.dmark+2)  
83e4 32 7c ee			ld (debug_mark+2),a  
83e7 18 03			jr .pastdmark  
83e9 ..			.dmark: db "FNI"  
83ec f1			.pastdmark: pop af  
83ed			endm  
# End of macro DMARK
83ed						CALLMONITOR 
83ed cd 1d 93			call break_point_state  
83f0				endm  
# End of macro CALLMONITOR
83f0					endif 
83f0			.ff1:   	 
83f0 e5					push hl 
83f1 c5					push bc 
83f2 d5					push de 
83f3 cd ae 80				call se_readbyte 
83f6 5f					ld e,a 
83f7 23					inc hl 
83f8 cd ae 80				call se_readbyte 
83fb 57					ld d, a 
83fc e1					pop hl 
83fd e5					push hl 
83fe cd c8 8a				call cmp16 
8401 28 49				jr z, .fffound 
8403			 
8403 d1					pop de 
8404 c1					pop bc 
8405 e1					pop hl 
8406			 
8406					; is found? 
8406					;cp e 
8406					;ret z 
8406			 
8406 3e 40				ld a, STORE_BLOCK_PHY 
8408 cd aa 8a				call addatohl 
840b 10 e3				djnz .ff1 
840d			 
840d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
840f			.ff2:   	 
840f			 
840f e5					push hl 
8410 c5					push bc 
8411 d5					push de 
8412 cd ae 80				call se_readbyte 
8415 5f					ld e,a 
8416 23					inc hl 
8417 cd ae 80				call se_readbyte 
841a 57					ld d, a 
841b			 
841b e1					pop hl 
841c e5					push hl 
841d cd c8 8a				call cmp16 
8420 28 2a				jr z, .fffound 
8422			 
8422 d1					pop de 
8423 c1					pop bc 
8424 e1					pop hl 
8425					; is found? 
8425					;cp e 
8425					;ret z 
8425			 
8425 3e 40				ld a, STORE_BLOCK_PHY 
8427 cd aa 8a				call addatohl 
842a 10 e3				djnz .ff2 
842c			 
842c			 
842c					if DEBUG_FORTH_WORDS 
842c					DMARK "FN-" 
842c f5				push af  
842d 3a 41 84			ld a, (.dmark)  
8430 32 7a ee			ld (debug_mark),a  
8433 3a 42 84			ld a, (.dmark+1)  
8436 32 7b ee			ld (debug_mark+1),a  
8439 3a 43 84			ld a, (.dmark+2)  
843c 32 7c ee			ld (debug_mark+2),a  
843f 18 03			jr .pastdmark  
8441 ..			.dmark: db "FN-"  
8444 f1			.pastdmark: pop af  
8445			endm  
# End of macro DMARK
8445					;	push af 
8445					;	ld a, 'n' 
8445					;	ld (debug_mark),a 
8445					;	pop af 
8445						CALLMONITOR 
8445 cd 1d 93			call break_point_state  
8448				endm  
# End of macro CALLMONITOR
8448					endif 
8448				; no free marks! 
8448 21 00 00				ld hl, 0 
844b c9				ret 
844c			.fffound: 
844c				 
844c			 
844c d1					pop de 
844d c1					pop bc 
844e e1					pop hl 
844f					if DEBUG_FORTH_WORDS 
844f					DMARK "FNF" 
844f f5				push af  
8450 3a 64 84			ld a, (.dmark)  
8453 32 7a ee			ld (debug_mark),a  
8456 3a 65 84			ld a, (.dmark+1)  
8459 32 7b ee			ld (debug_mark+1),a  
845c 3a 66 84			ld a, (.dmark+2)  
845f 32 7c ee			ld (debug_mark+2),a  
8462 18 03			jr .pastdmark  
8464 ..			.dmark: db "FNF"  
8467 f1			.pastdmark: pop af  
8468			endm  
# End of macro DMARK
8468					;	push af 
8468					;	ld a, 'n' 
8468					;	ld (debug_mark),a 
8468					;	pop af 
8468						CALLMONITOR 
8468 cd 1d 93			call break_point_state  
846b				endm  
# End of macro CALLMONITOR
846b					endif 
846b c9				ret 
846c			 
846c			 
846c			 
846c			; Free Space 
846c			; ---------- 
846c			; 
846c			; With current bank 
846c			; 
846c			; Set block count to zero 
846c			; Starting with first logical block 
846c			;      Find free block  
846c			;      If block id given, increment block count 
846c			; 
846c			;  
846c			 
846c			 
846c			; hl contains count of free blocks 
846c			 
846c			storage_freeblocks: 
846c			 
846c				; now locate first 0 page to mark as a free block 
846c			 
846c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
846e 21 40 00			ld hl, STORE_BLOCK_PHY 
8471 11 00 00			ld de, 0 
8474			 
8474			.fb1:   	 
8474 e5					push hl 
8475 c5					push bc 
8476 d5					push de 
8477 cd ae 80				call se_readbyte 
847a d1					pop de 
847b c1					pop bc 
847c e1					pop hl 
847d			 
847d					; is free? 
847d fe 00				cp 0 
847f 20 01				jr nz, .ff1cont 
8481 13					inc de 
8482			 
8482			.ff1cont: 
8482			 
8482			 
8482 3e 40				ld a, STORE_BLOCK_PHY 
8484 cd aa 8a				call addatohl 
8487 10 eb				djnz .fb1 
8489			 
8489 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
848b			.fb2:   	 
848b e5					push hl 
848c c5					push bc 
848d d5					push de 
848e cd ae 80				call se_readbyte 
8491 d1					pop de 
8492 c1					pop bc 
8493 e1					pop hl 
8494			 
8494					; is free? 
8494 fe 00				cp 0 
8496 20 01				jr nz, .ff2cont 
8498 13					inc de 
8499			 
8499			.ff2cont: 
8499			 
8499 3e 40				ld a, STORE_BLOCK_PHY 
849b cd aa 8a				call addatohl 
849e 10 eb				djnz .fb2 
84a0			 
84a0 eb				ex de, hl 
84a1 c9				ret 
84a2			 
84a2			; Get File ID 
84a2			; ----------- 
84a2			; 
84a2			; With current bank 
84a2			;  
84a2			; Load Block 0 Config 
84a2			; Get max file id number 
84a2			; For each logical block 
84a2			;    Read block file id 
84a2			;      If first block of file and dont have file id 
84a2			;         if file get id and exit 
84a2			 
84a2			 
84a2			 
84a2			 
84a2			; Create File 
84a2			; ----------- 
84a2			; 
84a2			; With current bank  
84a2			; Load Block 0 Config 
84a2			; Get max file id number 
84a2			; Increment file id number 
84a2			; Save Config 
84a2			; Find free block 
84a2			; Set buffer with file name and file id 
84a2			; Write buffer to free block  
84a2			 
84a2			 
84a2			; hl point to file name 
84a2			; hl returns file id 
84a2			 
84a2			; file format: 
84a2			; byte 0 - file id 
84a2			; byte 1 - extent number 
84a2			; byte 2-> data 
84a2			 
84a2			; format for extent number 0: 
84a2			; 
84a2			; byte 0 - file id 
84a2			; byte 1 - extent 0 
84a2			; byte 2 - extent count 
84a2			; byte 3 -> file name and meta data 
84a2			 
84a2			 
84a2			storage_create: 
84a2				if DEBUG_STORESE 
84a2					DMARK "SCR" 
84a2 f5				push af  
84a3 3a b7 84			ld a, (.dmark)  
84a6 32 7a ee			ld (debug_mark),a  
84a9 3a b8 84			ld a, (.dmark+1)  
84ac 32 7b ee			ld (debug_mark+1),a  
84af 3a b9 84			ld a, (.dmark+2)  
84b2 32 7c ee			ld (debug_mark+2),a  
84b5 18 03			jr .pastdmark  
84b7 ..			.dmark: db "SCR"  
84ba f1			.pastdmark: pop af  
84bb			endm  
# End of macro DMARK
84bb					CALLMONITOR 
84bb cd 1d 93			call break_point_state  
84be				endm  
# End of macro CALLMONITOR
84be				endif 
84be			 
84be e5				push hl		; save file name pointer 
84bf			 
84bf cd 62 81			call storage_get_block_0 
84c2			 
84c2 3a 65 eb			ld a,(store_page)	; get current file id 
84c5 3c				inc a 
84c6 32 65 eb			ld (store_page),a 
84c9				 
84c9 32 5e eb			ld (store_tmpid),a			; save id 
84cc			 
84cc 21 00 00			ld hl, 0 
84cf 11 65 eb			ld de, store_page 
84d2				if DEBUG_STORESE 
84d2					DMARK "SCw" 
84d2 f5				push af  
84d3 3a e7 84			ld a, (.dmark)  
84d6 32 7a ee			ld (debug_mark),a  
84d9 3a e8 84			ld a, (.dmark+1)  
84dc 32 7b ee			ld (debug_mark+1),a  
84df 3a e9 84			ld a, (.dmark+2)  
84e2 32 7c ee			ld (debug_mark+2),a  
84e5 18 03			jr .pastdmark  
84e7 ..			.dmark: db "SCw"  
84ea f1			.pastdmark: pop af  
84eb			endm  
# End of macro DMARK
84eb					CALLMONITOR 
84eb cd 1d 93			call break_point_state  
84ee				endm  
# End of macro CALLMONITOR
84ee				endif 
84ee cd 16 81			call storage_write_block	 ; save update 
84f1			 
84f1				if DEBUG_STORESE 
84f1 11 65 eb				ld de, store_page 
84f4					DMARK "SCC" 
84f4 f5				push af  
84f5 3a 09 85			ld a, (.dmark)  
84f8 32 7a ee			ld (debug_mark),a  
84fb 3a 0a 85			ld a, (.dmark+1)  
84fe 32 7b ee			ld (debug_mark+1),a  
8501 3a 0b 85			ld a, (.dmark+2)  
8504 32 7c ee			ld (debug_mark+2),a  
8507 18 03			jr .pastdmark  
8509 ..			.dmark: db "SCC"  
850c f1			.pastdmark: pop af  
850d			endm  
# End of macro DMARK
850d					CALLMONITOR 
850d cd 1d 93			call break_point_state  
8510				endm  
# End of macro CALLMONITOR
8510				endif 
8510				;  
8510				 
8510 21 40 00			ld hl, STORE_BLOCK_PHY 
8513 11 00 00			ld de, 0 
8516 cd d2 83			call storage_findnextid 
8519			 
8519 22 4f eb			ld (store_tmppageid), hl    ; save page to use  
851c			 
851c				; TODO detect 0 = no spare blocks 
851c			 
851c				; hl now contains the free page to use for the file header page 
851c			 
851c				if DEBUG_STORESE 
851c				DMARK "SCF" 
851c f5				push af  
851d 3a 31 85			ld a, (.dmark)  
8520 32 7a ee			ld (debug_mark),a  
8523 3a 32 85			ld a, (.dmark+1)  
8526 32 7b ee			ld (debug_mark+1),a  
8529 3a 33 85			ld a, (.dmark+2)  
852c 32 7c ee			ld (debug_mark+2),a  
852f 18 03			jr .pastdmark  
8531 ..			.dmark: db "SCF"  
8534 f1			.pastdmark: pop af  
8535			endm  
# End of macro DMARK
8535					CALLMONITOR 
8535 cd 1d 93			call break_point_state  
8538				endm  
# End of macro CALLMONITOR
8538				endif 
8538			 
8538 22 4f eb			ld (store_tmppageid), hl 
853b				 
853b 3a 5e eb			ld a,(store_tmpid)    ; get file id 
853e			;	ld a, (store_filecache)			; save to cache 
853e			 
853e 32 65 eb			ld (store_page),a    ; set page id 
8541 3e 00			ld a, 0			 ; extent 0 is file header 
8543 32 66 eb			ld (store_page+1), a   ; set file extent 
8546			 
8546 32 67 eb			ld (store_page+2), a   ; extent count for the file 
8549			 
8549			;	inc hl 		; init block 0 of file 
8549			;	inc hl   		; skip file and extent id 
8549			 ;       ld a, 0 
8549			;	ld (hl),a 
8549			;	ld a, (store_filecache+1)  	; save to cache 
8549			 
8549			;	inc hl    ; file name 
8549				 
8549				 
8549 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
854c				if DEBUG_STORESE 
854c					DMARK "SCc" 
854c f5				push af  
854d 3a 61 85			ld a, (.dmark)  
8550 32 7a ee			ld (debug_mark),a  
8553 3a 62 85			ld a, (.dmark+1)  
8556 32 7b ee			ld (debug_mark+1),a  
8559 3a 63 85			ld a, (.dmark+2)  
855c 32 7c ee			ld (debug_mark+2),a  
855f 18 03			jr .pastdmark  
8561 ..			.dmark: db "SCc"  
8564 f1			.pastdmark: pop af  
8565			endm  
# End of macro DMARK
8565					CALLMONITOR 
8565 cd 1d 93			call break_point_state  
8568				endm  
# End of macro CALLMONITOR
8568				endif 
8568 e1				pop hl    ; get zero term string 
8569 e5				push hl 
856a 3e 00			ld a, 0 
856c cd 13 8f			call strlent 
856f 23				inc hl   ; cover zero term 
8570 06 00			ld b,0 
8572 4d				ld c,l 
8573 e1				pop hl 
8574				;ex de, hl 
8574				if DEBUG_STORESE 
8574					DMARK "SCa" 
8574 f5				push af  
8575 3a 89 85			ld a, (.dmark)  
8578 32 7a ee			ld (debug_mark),a  
857b 3a 8a 85			ld a, (.dmark+1)  
857e 32 7b ee			ld (debug_mark+1),a  
8581 3a 8b 85			ld a, (.dmark+2)  
8584 32 7c ee			ld (debug_mark+2),a  
8587 18 03			jr .pastdmark  
8589 ..			.dmark: db "SCa"  
858c f1			.pastdmark: pop af  
858d			endm  
# End of macro DMARK
858d					;push af 
858d					;ld a, 'a' 
858d					;ld (debug_mark),a 
858d					;pop af 
858d					CALLMONITOR 
858d cd 1d 93			call break_point_state  
8590				endm  
# End of macro CALLMONITOR
8590				endif 
8590 ed b0			ldir    ; copy zero term string 
8592				if DEBUG_STORESE 
8592					DMARK "SCA" 
8592 f5				push af  
8593 3a a7 85			ld a, (.dmark)  
8596 32 7a ee			ld (debug_mark),a  
8599 3a a8 85			ld a, (.dmark+1)  
859c 32 7b ee			ld (debug_mark+1),a  
859f 3a a9 85			ld a, (.dmark+2)  
85a2 32 7c ee			ld (debug_mark+2),a  
85a5 18 03			jr .pastdmark  
85a7 ..			.dmark: db "SCA"  
85aa f1			.pastdmark: pop af  
85ab			endm  
# End of macro DMARK
85ab					CALLMONITOR 
85ab cd 1d 93			call break_point_state  
85ae				endm  
# End of macro CALLMONITOR
85ae				endif 
85ae			 
85ae				; write file header page 
85ae			 
85ae 2a 4f eb			ld hl,(store_tmppageid) 
85b1 11 65 eb			ld de, store_page 
85b4				if DEBUG_STORESE 
85b4					DMARK "SCb" 
85b4 f5				push af  
85b5 3a c9 85			ld a, (.dmark)  
85b8 32 7a ee			ld (debug_mark),a  
85bb 3a ca 85			ld a, (.dmark+1)  
85be 32 7b ee			ld (debug_mark+1),a  
85c1 3a cb 85			ld a, (.dmark+2)  
85c4 32 7c ee			ld (debug_mark+2),a  
85c7 18 03			jr .pastdmark  
85c9 ..			.dmark: db "SCb"  
85cc f1			.pastdmark: pop af  
85cd			endm  
# End of macro DMARK
85cd					;push af 
85cd					;ld a, 'b' 
85cd					;ld (debug_mark),a 
85cd					;pop af 
85cd					CALLMONITOR 
85cd cd 1d 93			call break_point_state  
85d0				endm  
# End of macro CALLMONITOR
85d0				endif 
85d0 cd 16 81			call storage_write_block 
85d3			 
85d3 3a 5e eb			ld a, (store_tmpid) 
85d6 6f				ld l, a 
85d7 26 00			ld h,0 
85d9				if DEBUG_STORESE 
85d9					DMARK "SCz" 
85d9 f5				push af  
85da 3a ee 85			ld a, (.dmark)  
85dd 32 7a ee			ld (debug_mark),a  
85e0 3a ef 85			ld a, (.dmark+1)  
85e3 32 7b ee			ld (debug_mark+1),a  
85e6 3a f0 85			ld a, (.dmark+2)  
85e9 32 7c ee			ld (debug_mark+2),a  
85ec 18 03			jr .pastdmark  
85ee ..			.dmark: db "SCz"  
85f1 f1			.pastdmark: pop af  
85f2			endm  
# End of macro DMARK
85f2					CALLMONITOR 
85f2 cd 1d 93			call break_point_state  
85f5				endm  
# End of macro CALLMONITOR
85f5				endif 
85f5 c9				ret 
85f6				 
85f6			 
85f6			 
85f6			; 
85f6			; Read File 
85f6			; 
85f6			; h - file id to locate 
85f6			; l - extent to locate 
85f6			; de - pointer to string to read into 
85f6			; 
85f6			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
85f6			 
85f6			.sr_fail: 
85f6 d1				pop de 
85f7 c9				ret 
85f8			 
85f8			storage_read: 
85f8 d5				push de 
85f9			 
85f9			; TODO BUG the above push is it popped before the RET Z? 
85f9			 
85f9			; TODO how to handle multiple part blocks 
85f9			 
85f9				; locate file extent to read 
85f9			 
85f9 5c				ld e, h 
85fa 55				ld d, l 
85fb 21 40 00			ld hl, STORE_BLOCK_PHY 
85fe				if DEBUG_STORESE 
85fe					DMARK "SRE" 
85fe f5				push af  
85ff 3a 13 86			ld a, (.dmark)  
8602 32 7a ee			ld (debug_mark),a  
8605 3a 14 86			ld a, (.dmark+1)  
8608 32 7b ee			ld (debug_mark+1),a  
860b 3a 15 86			ld a, (.dmark+2)  
860e 32 7c ee			ld (debug_mark+2),a  
8611 18 03			jr .pastdmark  
8613 ..			.dmark: db "SRE"  
8616 f1			.pastdmark: pop af  
8617			endm  
# End of macro DMARK
8617					CALLMONITOR 
8617 cd 1d 93			call break_point_state  
861a				endm  
# End of macro CALLMONITOR
861a				endif 
861a cd d2 83			call storage_findnextid 
861d			 
861d				if DEBUG_STORESE 
861d					DMARK "SRf" 
861d f5				push af  
861e 3a 32 86			ld a, (.dmark)  
8621 32 7a ee			ld (debug_mark),a  
8624 3a 33 86			ld a, (.dmark+1)  
8627 32 7b ee			ld (debug_mark+1),a  
862a 3a 34 86			ld a, (.dmark+2)  
862d 32 7c ee			ld (debug_mark+2),a  
8630 18 03			jr .pastdmark  
8632 ..			.dmark: db "SRf"  
8635 f1			.pastdmark: pop af  
8636			endm  
# End of macro DMARK
8636					CALLMONITOR 
8636 cd 1d 93			call break_point_state  
8639				endm  
# End of macro CALLMONITOR
8639				endif 
8639 cd d3 8a			call ishlzero 
863c			;	ld a, l 
863c			;	add h 
863c			;	cp 0 
863c 28 b8			jr z,.sr_fail			; block not found so EOF 
863e			 
863e				; hl contains page number to load 
863e d1				pop de   ; get storage 
863f d5				push de 
8640				if DEBUG_STORESE 
8640					DMARK "SRg" 
8640 f5				push af  
8641 3a 55 86			ld a, (.dmark)  
8644 32 7a ee			ld (debug_mark),a  
8647 3a 56 86			ld a, (.dmark+1)  
864a 32 7b ee			ld (debug_mark+1),a  
864d 3a 57 86			ld a, (.dmark+2)  
8650 32 7c ee			ld (debug_mark+2),a  
8653 18 03			jr .pastdmark  
8655 ..			.dmark: db "SRg"  
8658 f1			.pastdmark: pop af  
8659			endm  
# End of macro DMARK
8659					CALLMONITOR 
8659 cd 1d 93			call break_point_state  
865c				endm  
# End of macro CALLMONITOR
865c				endif 
865c cd b1 80			call storage_read_block 
865f			 
865f			 
865f			; TODO if block has no zeros then need to read next block  
865f			 
865f			 
865f					 
865f e1				pop hl 		 ; return start of data to show as not EOF 
8660 23				inc hl   ; past file id 
8661 23				inc hl   ; past ext 
8662				if DEBUG_STORESE 
8662					DMARK "SRe" 
8662 f5				push af  
8663 3a 77 86			ld a, (.dmark)  
8666 32 7a ee			ld (debug_mark),a  
8669 3a 78 86			ld a, (.dmark+1)  
866c 32 7b ee			ld (debug_mark+1),a  
866f 3a 79 86			ld a, (.dmark+2)  
8672 32 7c ee			ld (debug_mark+2),a  
8675 18 03			jr .pastdmark  
8677 ..			.dmark: db "SRe"  
867a f1			.pastdmark: pop af  
867b			endm  
# End of macro DMARK
867b					CALLMONITOR 
867b cd 1d 93			call break_point_state  
867e				endm  
# End of macro CALLMONITOR
867e				endif 
867e c9					ret 
867f			 
867f			 
867f			 
867f			; 
867f			; Append File 
867f			; 
867f			; hl - file id to locate 
867f			; de - pointer to (multi block) string to write 
867f			 
867f			 
867f			storage_append: 
867f				; hl -  file id to append to 
867f				; de - string to append 
867f			 
867f d5				push de 
8680				 
8680				if DEBUG_STORESE 
8680					DMARK "AP1" 
8680 f5				push af  
8681 3a 95 86			ld a, (.dmark)  
8684 32 7a ee			ld (debug_mark),a  
8687 3a 96 86			ld a, (.dmark+1)  
868a 32 7b ee			ld (debug_mark+1),a  
868d 3a 97 86			ld a, (.dmark+2)  
8690 32 7c ee			ld (debug_mark+2),a  
8693 18 03			jr .pastdmark  
8695 ..			.dmark: db "AP1"  
8698 f1			.pastdmark: pop af  
8699			endm  
# End of macro DMARK
8699					CALLMONITOR 
8699 cd 1d 93			call break_point_state  
869c				endm  
# End of macro CALLMONITOR
869c				endif 
869c			 
869c 7d				ld a, l 
869d 32 5e eb			ld (store_tmpid), a 
86a0			 
86a0				; get file header  
86a0			 
86a0 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
86a2 3a 5e eb			ld a, (store_tmpid) 
86a5 5f				ld e, a 
86a6			 
86a6 21 40 00				ld hl, STORE_BLOCK_PHY 
86a9 cd d2 83				call storage_findnextid 
86ac			 
86ac 22 4f eb			ld (store_tmppageid), hl 
86af			 
86af				; TODO handle file id not found 
86af			 
86af				if DEBUG_STORESE 
86af					DMARK "AP2" 
86af f5				push af  
86b0 3a c4 86			ld a, (.dmark)  
86b3 32 7a ee			ld (debug_mark),a  
86b6 3a c5 86			ld a, (.dmark+1)  
86b9 32 7b ee			ld (debug_mark+1),a  
86bc 3a c6 86			ld a, (.dmark+2)  
86bf 32 7c ee			ld (debug_mark+2),a  
86c2 18 03			jr .pastdmark  
86c4 ..			.dmark: db "AP2"  
86c7 f1			.pastdmark: pop af  
86c8			endm  
# End of macro DMARK
86c8					CALLMONITOR 
86c8 cd 1d 93			call break_point_state  
86cb				endm  
# End of macro CALLMONITOR
86cb				endif 
86cb			 
86cb				; update file extent count 
86cb			 
86cb 11 65 eb			ld de, store_page 
86ce			 
86ce cd b1 80			call storage_read_block 
86d1			 
86d1				if DEBUG_STORESE 
86d1					DMARK "AP3" 
86d1 f5				push af  
86d2 3a e6 86			ld a, (.dmark)  
86d5 32 7a ee			ld (debug_mark),a  
86d8 3a e7 86			ld a, (.dmark+1)  
86db 32 7b ee			ld (debug_mark+1),a  
86de 3a e8 86			ld a, (.dmark+2)  
86e1 32 7c ee			ld (debug_mark+2),a  
86e4 18 03			jr .pastdmark  
86e6 ..			.dmark: db "AP3"  
86e9 f1			.pastdmark: pop af  
86ea			endm  
# End of macro DMARK
86ea					CALLMONITOR 
86ea cd 1d 93			call break_point_state  
86ed				endm  
# End of macro CALLMONITOR
86ed				endif 
86ed			;	ld (store_tmppageid), hl 
86ed			 
86ed 3a 67 eb			ld a, (store_page+2) 
86f0 3c				inc a 
86f1 32 67 eb			ld (store_page+2), a 
86f4 32 5d eb			ld (store_tmpext), a 
86f7				 
86f7				if DEBUG_STORESE 
86f7					DMARK "AP3" 
86f7 f5				push af  
86f8 3a 0c 87			ld a, (.dmark)  
86fb 32 7a ee			ld (debug_mark),a  
86fe 3a 0d 87			ld a, (.dmark+1)  
8701 32 7b ee			ld (debug_mark+1),a  
8704 3a 0e 87			ld a, (.dmark+2)  
8707 32 7c ee			ld (debug_mark+2),a  
870a 18 03			jr .pastdmark  
870c ..			.dmark: db "AP3"  
870f f1			.pastdmark: pop af  
8710			endm  
# End of macro DMARK
8710					CALLMONITOR 
8710 cd 1d 93			call break_point_state  
8713				endm  
# End of macro CALLMONITOR
8713				endif 
8713 2a 4f eb			ld hl, (store_tmppageid) 
8716 11 65 eb			ld de, store_page 
8719 cd 16 81			call storage_write_block 
871c			 
871c				; find free block 
871c			 
871c 11 00 00			ld de, 0			 ; file extent to locate 
871f			 
871f 21 40 00				ld hl, STORE_BLOCK_PHY 
8722 cd d2 83				call storage_findnextid 
8725			 
8725					; TODO handle no space left 
8725					 
8725 22 4f eb				ld (store_tmppageid), hl 
8728			 
8728				if DEBUG_STORESE 
8728					DMARK "AP4" 
8728 f5				push af  
8729 3a 3d 87			ld a, (.dmark)  
872c 32 7a ee			ld (debug_mark),a  
872f 3a 3e 87			ld a, (.dmark+1)  
8732 32 7b ee			ld (debug_mark+1),a  
8735 3a 3f 87			ld a, (.dmark+2)  
8738 32 7c ee			ld (debug_mark+2),a  
873b 18 03			jr .pastdmark  
873d ..			.dmark: db "AP4"  
8740 f1			.pastdmark: pop af  
8741			endm  
# End of macro DMARK
8741					CALLMONITOR 
8741 cd 1d 93			call break_point_state  
8744				endm  
# End of macro CALLMONITOR
8744				endif 
8744					; init the buffer with zeros so we can id if the buffer is full or not 
8744			 
8744 e5					push hl 
8745 c5					push bc 
8746			 
8746 21 65 eb				ld hl, store_page 
8749 06 40				ld b, STORE_BLOCK_PHY 
874b 3e 00				ld a, 0 
874d 77			.zeroblock:	ld (hl), a 
874e 23					inc hl 
874f 10 fc				djnz .zeroblock 
8751			 
8751 c1					pop bc 
8752 e1					pop hl 
8753			 
8753					; construct block 
8753			 
8753 3a 5e eb				ld a, (store_tmpid) 
8756 32 65 eb				ld (store_page), a   ; file id 
8759 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
875c 32 66 eb				ld (store_page+1), a 
875f			 
875f e1					pop hl    ; get string to write 
8760 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8762 11 67 eb				ld de, store_page+2 
8765			 
8765				if DEBUG_STORESE 
8765					DMARK "AP5" 
8765 f5				push af  
8766 3a 7a 87			ld a, (.dmark)  
8769 32 7a ee			ld (debug_mark),a  
876c 3a 7b 87			ld a, (.dmark+1)  
876f 32 7b ee			ld (debug_mark+1),a  
8772 3a 7c 87			ld a, (.dmark+2)  
8775 32 7c ee			ld (debug_mark+2),a  
8778 18 03			jr .pastdmark  
877a ..			.dmark: db "AP5"  
877d f1			.pastdmark: pop af  
877e			endm  
# End of macro DMARK
877e					CALLMONITOR 
877e cd 1d 93			call break_point_state  
8781				endm  
# End of macro CALLMONITOR
8781				endif 
8781			 
8781			 
8781			 
8781					; fill buffer with data until end of string or full block 
8781			 
8781 7e			.appd:		ld a, (hl) 
8782 12					ld (de), a 
8783 fe 00				cp 0 
8785 28 04				jr z, .appdone 
8787 23					inc hl 
8788 13					inc de 
8789 10 f6				djnz .appd 
878b			 
878b e5			.appdone:	push hl		 	; save current source in case we need to go around again 
878c f5					push af   		; save last byte dumped 
878d			 
878d			 
878d 2a 4f eb			ld hl, (store_tmppageid) 
8790 11 65 eb			ld de, store_page 
8793				if DEBUG_STORESE 
8793					DMARK "AP6" 
8793 f5				push af  
8794 3a a8 87			ld a, (.dmark)  
8797 32 7a ee			ld (debug_mark),a  
879a 3a a9 87			ld a, (.dmark+1)  
879d 32 7b ee			ld (debug_mark+1),a  
87a0 3a aa 87			ld a, (.dmark+2)  
87a3 32 7c ee			ld (debug_mark+2),a  
87a6 18 03			jr .pastdmark  
87a8 ..			.dmark: db "AP6"  
87ab f1			.pastdmark: pop af  
87ac			endm  
# End of macro DMARK
87ac					CALLMONITOR 
87ac cd 1d 93			call break_point_state  
87af				endm  
# End of macro CALLMONITOR
87af				endif 
87af cd 16 81				call storage_write_block 
87b2			 
87b2			 
87b2				; was that a full block of data written? 
87b2				; any more to write out? 
87b2			 
87b2				; if yes then set vars and jump to start of function again 
87b2			 
87b2 f1					pop af 
87b3 d1					pop de 
87b4			 
87b4 fe 00				cp 0		 ; no, string was fully written 
87b6 c8					ret z 
87b7			 
87b7					; setup vars for next cycle 
87b7			 
87b7 3a 5e eb				ld a, (store_tmpid) 
87ba 6f					ld l, a 
87bb 26 00				ld h, 0 
87bd			 
87bd c3 7f 86			 	jp storage_append	 ; yes, need to write out some more 
87c0			 
87c0			 
87c0			 
87c0			 
87c0			 
87c0			 
87c0			 
87c0			if DEBUG_STORECF 
87c0			storageput:	 
87c0					ret 
87c0			storageread: 
87c0					ld hl, store_page 
87c0					ld b, 200 
87c0					ld a,0 
87c0			.src:		ld (hl),a 
87c0					inc hl 
87c0					djnz .src 
87c0					 
87c0			 
87c0					ld de, 0 
87c0					ld bc, 1 
87c0					ld hl, store_page 
87c0					call cfRead 
87c0			 
87c0				call cfGetError 
87c0				ld hl,scratch 
87c0				call hexout 
87c0				ld hl, scratch+2 
87c0				ld a, 0 
87c0				ld (hl),a 
87c0				ld de, scratch 
87c0				ld a,display_row_1 
87c0				call str_at_display 
87c0				call update_display 
87c0			 
87c0					ld hl, store_page 
87c0					ld (os_cur_ptr),hl 
87c0			 
87c0					ret 
87c0			endif 
87c0			 
87c0			 
87c0			; Clear out the main buffer store (used to remove junk before writing a new block) 
87c0			 
87c0			storage_clear_page: 
87c0 e5				push hl 
87c1 d5				push de 
87c2 c5				push bc 
87c3 21 65 eb			ld hl, store_page 
87c6 3e 00			ld a, 0 
87c8 77				ld (hl), a 
87c9			 
87c9 11 66 eb			ld de, store_page+1 
87cc 01 40 00			ld bc, STORE_BLOCK_PHY 
87cf			 
87cf ed b0			ldir 
87d1				 
87d1 c1				pop bc 
87d2 d1				pop de 
87d3 e1				pop hl 
87d4 c9				ret 
87d5			 
87d5			; eof 
# End of file firmware_storage.asm
87d5			  
87d5			; support routines for above hardware abstraction layer  
87d5			  
87d5			include "firmware_general.asm"        ; general support functions  
87d5			 
87d5			; word look up 
87d5			 
87d5			; in 
87d5			; a is the index 
87d5			; hl is pointer start of array 
87d5			; 
87d5			; returns 
87d5			; hl to the word 
87d5			; 
87d5			 
87d5			table_lookup:  
87d5 d5					push de 
87d6 eb					ex de, hl 
87d7			 
87d7 6f					ld l, a 
87d8 26 00				ld h, 0 
87da 29					add hl, hl 
87db 19					add hl, de 
87dc 7e					ld a, (hl) 
87dd 23					inc hl 
87de 66					ld h,(hl) 
87df 6f					ld l, a 
87e0			 
87e0 d1					pop de 
87e1 c9					ret 
87e2			 
87e2			; Delay loops 
87e2			 
87e2			 
87e2			 
87e2			aDelayInMS: 
87e2 c5				push bc 
87e3 47				ld b,a 
87e4			msdelay: 
87e4 c5				push bc 
87e5				 
87e5			 
87e5 01 41 00			ld bc,041h 
87e8 cd 00 88			call delayloop 
87eb c1				pop bc 
87ec 05				dec b 
87ed 20 f5			jr nz,msdelay 
87ef			 
87ef			;if CPU_CLOCK_8MHZ 
87ef			;msdelay8: 
87ef			;	push bc 
87ef			;	 
87ef			; 
87ef			;	ld bc,041h 
87ef			;	call delayloop 
87ef			;	pop bc 
87ef			;	dec b 
87ef			;	jr nz,msdelay8 
87ef			;endif 
87ef			 
87ef			 
87ef c1				pop bc 
87f0 c9				ret 
87f1			 
87f1			 
87f1			delay250ms: 
87f1				;push de 
87f1 01 00 40			ld bc, 04000h 
87f4 c3 00 88			jp delayloop 
87f7			delay500ms: 
87f7				;push de 
87f7 01 00 80			ld bc, 08000h 
87fa c3 00 88			jp delayloop 
87fd			delay1s: 
87fd				;push bc 
87fd			   ; Clobbers A, d and e 
87fd 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
8800			delayloop: 
8800 c5			    push bc 
8801			 
8801			if BASE_CPM 
8801				ld bc, CPM_DELAY_TUNE 
8801			.cpmloop: 
8801				push bc 
8801			 
8801			endif 
8801			 
8801			 
8801			 
8801			delayloopi: 
8801			;	push bc 
8801			;.dl: 
8801 cb 47		    bit     0,a    	; 8 
8803 cb 47		    bit     0,a    	; 8 
8805 cb 47		    bit     0,a    	; 8 
8807 e6 ff		    and     255  	; 7 
8809 0b			    dec     bc      	; 6 
880a 79			    ld      a,c     	; 4 
880b b0			    or      b     	; 4 
880c c2 01 88		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
880f			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
880f				;pop de 
880f			;pop bc 
880f			 
880f			if BASE_CPM 
880f				pop bc 
880f				 
880f			    dec     bc      	; 6 
880f			    ld      a,c     	; 4 
880f			    or      b     	; 4 
880f			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
880f				 
880f			 
880f			endif 
880f			;if CPU_CLOCK_8MHZ 
880f			;    pop bc 
880f			;    push bc 
880f			;.dl8: 
880f			;    bit     0,a    	; 8 
880f			;    bit     0,a    	; 8 
880f			;    bit     0,a    	; 8 
880f			;    and     255  	; 7 
880f			;    dec     bc      	; 6 
880f			;    ld      a,c     	; 4 
880f			;    or      b     	; 4 
880f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
880f			;endif 
880f			 
880f			;if CPU_CLOCK_10MHZ 
880f			;    pop bc 
880f			;    push bc 
880f			;.dl8: 
880f			;    bit     0,a    	; 8 
880f			;    bit     0,a    	; 8 
880f			;    bit     0,a    	; 8 
880f			;    and     255  	; 7 
880f			;    dec     bc      	; 6 
880f			;    ld      a,c     	; 4 
880f			;    or      b     	; 4 
880f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
880f			;endif 
880f c1			    pop bc 
8810			 
8810 c9				ret 
8811			 
8811			 
8811			 
8811			; eof 
# End of file firmware_general.asm
8811			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8811			; display routines that use the physical hardware abstraction layer 
8811			 
8811			 
8811			; information window 
8811			 
8811			; pass hl with 1st string to display 
8811			; pass de with 2nd string to display 
8811			 
8811			info_panel: 
8811 e5				push hl 
8812			 
8812 2a db eb			ld hl, (display_fb_active) 
8815 e5				push hl    ; future de destination 
8816 21 c0 ed				ld hl, display_fb0 
8819 22 db eb				ld (display_fb_active), hl 
881c			 
881c cd 7d 88			call clear_display 
881f			 
881f			 
881f 3e 55			ld a, display_row_3 + 5 
8821 cd 90 88			call str_at_display 
8824			 
8824 e1				pop hl 
8825 d1				pop de 
8826			 
8826 e5				push hl 
8827			 
8827			 
8827 3e 2d			ld a, display_row_2 + 5 
8829 cd 90 88			call str_at_display 
882c			 
882c			 
882c cd a0 88			call update_display 
882f cd 22 98			call next_page_prompt 
8832 cd 7d 88			call clear_display 
8835			 
8835				 
8835 21 1f ed				ld hl, display_fb1 
8838 22 db eb				ld (display_fb_active), hl 
883b cd a0 88			call update_display 
883e			 
883e			 
883e c9				ret 
883f			 
883f			 
883f			 
883f			 
883f			; TODO windowing? 
883f			 
883f			; TODO scroll line up 
883f			 
883f			scroll_up: 
883f			 
883f e5				push hl 
8840 d5				push de 
8841 c5				push bc 
8842			 
8842				; get frame buffer  
8842			 
8842 2a db eb			ld hl, (display_fb_active) 
8845 e5				push hl    ; future de destination 
8846			 
8846 11 28 00			ld  de, display_cols 
8849 19				add hl, de 
884a			 
884a d1				pop de 
884b			 
884b				;ex de, hl 
884b 01 9f 00			ld bc, display_fb_len -1  
884e			;if DEBUG_FORTH_WORDS 
884e			;	DMARK "SCL" 
884e			;	CALLMONITOR 
884e			;endif	 
884e ed b0			ldir 
8850			 
8850				; wipe bottom row 
8850			 
8850			 
8850 2a db eb			ld hl, (display_fb_active) 
8853 11 a0 00			ld de, display_cols*display_rows 
8856 19				add hl, de 
8857 06 28			ld b, display_cols 
8859 3e 20			ld a, ' ' 
885b			.scwipe: 
885b 77				ld (hl), a 
885c 2b				dec hl 
885d 10 fc			djnz .scwipe 
885f			 
885f				;pop hl 
885f			 
885f c1				pop bc 
8860 d1				pop de 
8861 e1				pop hl 
8862			 
8862 c9				ret 
8863			 
8863			 
8863			;scroll_upo: 
8863			;	ld de, display_row_1 
8863			 ;	ld hl, display_row_2 
8863			;	ld bc, display_cols 
8863			;	ldir 
8863			;	ld de, display_row_2 
8863			 ;	ld hl, display_row_3 
8863			;	ld bc, display_cols 
8863			;	ldir 
8863			;	ld de, display_row_3 
8863			 ;	ld hl, display_row_4 
8863			;	ld bc, display_cols 
8863			;	ldir 
8863			 
8863			; TODO clear row 4 
8863			 
8863			;	ret 
8863			 
8863				 
8863			scroll_down: 
8863			 
8863 e5				push hl 
8864 d5				push de 
8865 c5				push bc 
8866			 
8866				; get frame buffer  
8866			 
8866 2a db eb			ld hl, (display_fb_active) 
8869			 
8869 11 9f 00			ld de, display_fb_len - 1 
886c 19				add hl, de 
886d			 
886d e5			push hl    ; future de destination 
886e			 
886e 11 28 00			ld  de, display_cols 
8871 ed 52			sbc hl, de 
8873			 
8873			 
8873 d1				pop de 
8874			 
8874			;	ex de, hl 
8874 01 9f 00			ld bc, display_fb_len -1  
8877			 
8877			 
8877				 
8877			 
8877 ed b0			ldir 
8879			 
8879				; wipe bottom row 
8879			 
8879			 
8879			;	ld hl, (display_fb_active) 
8879			;;	ld de, display_cols*display_rows 
8879			;;	add hl, de 
8879			;	ld b, display_cols 
8879			;	ld a, ' ' 
8879			;.scwiped: 
8879			;	ld (hl), a 
8879			;	dec hl 
8879			;	djnz .scwiped 
8879			 
8879				;pop hl 
8879			 
8879 c1				pop bc 
887a d1				pop de 
887b e1				pop hl 
887c			 
887c c9				ret 
887d			;scroll_down: 
887d			;	ld de, display_row_4 
887d			;	ld hl, display_row_3 
887d			;	ld bc, display_cols 
887d			;	ldir 
887d			;	ld de, display_row_3 
887d			; 	ld hl, display_row_2 
887d			;	ld bc, display_cols 
887d			;	ldir 
887d			;	ld de, display_row_2 
887d			;	ld hl, display_row_1 
887d			;	ld bc, display_cols 
887d			;	ldir 
887d			;;; TODO clear row 1 
887d			;	ret 
887d			 
887d			 
887d			 
887d			 
887d			 
887d			; clear active frame buffer 
887d			 
887d			clear_display: 
887d 3e 20			ld a, ' ' 
887f c3 82 88			jp fill_display 
8882			 
8882			; fill active frame buffer with a char in A 
8882			 
8882			fill_display: 
8882 06 a0			ld b,display_fb_len 
8884 2a db eb			ld hl, (display_fb_active) 
8887 77			.fd1:	ld (hl),a 
8888 23				inc hl 
8889 10 fc			djnz .fd1 
888b 23				inc hl 
888c 3e 00			ld a,0 
888e 77				ld (hl),a 
888f			 
888f			 
888f c9				ret 
8890			; Write string (DE) at pos (A) to active frame buffer 
8890			 
8890 2a db eb		str_at_display:    ld hl,(display_fb_active) 
8893 06 00					ld b,0 
8895 4f					ld c,a 
8896 09					add hl,bc 
8897 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8898 b7			            OR   A              ;Null terminator? 
8899 c8			            RET  Z              ;Yes, so finished 
889a 77					ld (hl),a 
889b 23				inc hl 
889c 13			            INC  DE             ;Point to next character 
889d 18 f8		            JR   .sad1     ;Repeat 
889f c9					ret 
88a0			 
88a0			; using current frame buffer write to physical display 
88a0			 
88a0			update_display: 
88a0 e5				push hl 
88a1 2a db eb			ld hl, (display_fb_active) 
88a4 cd a7 d6			call write_display 
88a7 e1				pop hl 
88a8 c9				ret 
88a9			 
88a9			; TODO scrolling 
88a9			 
88a9			 
88a9			; move cursor right one char 
88a9			cursor_right: 
88a9			 
88a9				; TODO shift right 
88a9				; TODO if beyond max col 
88a9				; TODO       cursor_next_line 
88a9			 
88a9 c9				ret 
88aa			 
88aa			 
88aa			cursor_next_line: 
88aa				; TODO first char 
88aa				; TODO line down 
88aa				; TODO if past last row 
88aa				; TODO    scroll up 
88aa			 
88aa c9				ret 
88ab			 
88ab			cursor_left: 
88ab				; TODO shift left 
88ab				; TODO if beyond left  
88ab				; TODO     cursor prev line 
88ab				 
88ab c9				ret 
88ac			 
88ac			cursor_prev_line: 
88ac				; TODO last char 
88ac				; TODO line up 
88ac				; TODO if past first row 
88ac				; TODO   scroll down 
88ac			 
88ac c9				ret 
88ad			 
88ad			 
88ad			cout: 
88ad				; A - char 
88ad c9				ret 
88ae			 
88ae			 
88ae			; Display a menu and allow item selection (optional toggle items) 
88ae			; 
88ae			; format: 
88ae			; hl pointer to word array with zero term for items 
88ae			; e.g.    db item1 
88ae			;         db .... 
88ae			;         db 0 
88ae			; 
88ae			; a = starting menu item  
88ae			; 
88ae			; de = pointer item toggle array   (todo) 
88ae			; 
88ae			; returns item selected in a 1-... 
88ae			; returns 0 if back button pressed 
88ae			; 
88ae			; NOTE: Uses system frame buffer to display 
88ae			; 
88ae			; LEFT, Q = go back 
88ae			; RIGHT, SPACE, CR = select 
88ae			; UP, A - Up 
88ae			; DOWN, Z - Down 
88ae			 
88ae			 
88ae			 
88ae			 
88ae			 
88ae			menu: 
88ae			 
88ae					; keep array pointer 
88ae			 
88ae 22 63 eb				ld (store_tmp1), hl 
88b1 32 61 eb				ld (store_tmp2), a 
88b4			 
88b4					; check for key bounce 
88b4			 
88b4			if BASE_KEV 
88b4			 
88b4			.mbounce:	call cin 
88b4					cp 0 
88b4					jr nz, .mbounce 
88b4			endif 
88b4					; for ease use ex 
88b4			 
88b4					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
88b4 21 c0 ed				ld hl, display_fb0 
88b7 22 db eb				ld (display_fb_active), hl 
88ba			 
88ba cd 7d 88		.mloop:		call clear_display 
88bd cd a0 88				call update_display 
88c0			 
88c0					; draw selection id '>' at 1 
88c0			 
88c0					; init start of list display 
88c0			 
88c0 3e 05				ld a, 5 
88c2 32 5f eb				ld (store_tmp3), a   ; display row count 
88c5 3a 61 eb				ld a,( store_tmp2) 
88c8 32 62 eb				ld (store_tmp2+1), a   ; display item count 
88cb			 
88cb					 
88cb			.mitem:	 
88cb			 
88cb			 
88cb 3a 62 eb				ld a,(store_tmp2+1) 
88ce 6f					ld l, a 
88cf 26 00				ld h, 0 
88d1 29					add hl, hl 
88d2 ed 5b 63 eb			ld de, (store_tmp1) 
88d6 19					add hl, de 
88d7 7e					ld a, (hl) 
88d8 23					inc hl 
88d9 66					ld h,(hl) 
88da 6f					ld l, a 
88db			 
88db cd d3 8a				call ishlzero 
88de 28 1a				jr z, .mdone 
88e0			 
88e0 eb					ex de, hl 
88e1 3a 5f eb				ld a, (store_tmp3) 
88e4 cd 90 88				call str_at_display 
88e7					 
88e7			 
88e7					; next item 
88e7 3a 62 eb				ld a, (store_tmp2+1) 
88ea 3c					inc a 
88eb 32 62 eb				ld (store_tmp2+1), a   ; display item count 
88ee			 
88ee			 		; next row 
88ee			 
88ee 3a 5f eb				ld a, (store_tmp3) 
88f1 c6 28				add display_cols 
88f3 32 5f eb				ld (store_tmp3), a 
88f6			 
88f6					; at end of screen? 
88f6			 
88f6 fe 10				cp display_rows*4 
88f8 20 d1				jr nz, .mitem 
88fa			 
88fa			 
88fa			.mdone: 
88fa cd d3 8a				call ishlzero 
88fd 28 08				jr z, .nodn 
88ff			 
88ff 3e 78				ld a, display_row_4 
8901 11 80 89				ld de, .mdown 
8904 cd 90 88				call str_at_display 
8907			 
8907					; draw options to fill the screens with active item on line 1 
8907					; if current option is 2 or more then display ^ in top 
8907			 
8907 3a 61 eb		.nodn:		ld a, (store_tmp2) 
890a fe 00				cp 0 
890c 28 08				jr z, .noup 
890e			 
890e 3e 00				ld a, 0 
8910 11 7e 89				ld de, .mup 
8913 cd 90 88				call str_at_display 
8916			 
8916 3e 02		.noup:		ld a, 2 
8918 11 7c 89				ld de, .msel 
891b cd 90 88				call str_at_display 
891e			 
891e					; if current option + 1 is not null then display V in bottom 
891e					; get key 
891e cd a0 88				call update_display 
8921			 
8921			 
8921					; handle key 
8921			 
8921 cd 33 d7				call cin_wait 
8924			 
8924 fe 05				cp KEY_UP 
8926 28 2b				jr z, .mgoup 
8928 fe 61				cp 'a' 
892a 28 27				jr z, .mgoup 
892c fe 0a				cp KEY_DOWN 
892e 28 32				jr z, .mgod 
8930 fe 7a				cp 'z' 
8932 28 2e				jr z, .mgod 
8934 fe 20				cp ' ' 
8936 28 34				jr z, .goend 
8938 fe 0c				cp KEY_RIGHT 
893a 28 30				jr z, .goend 
893c fe 0d				cp KEY_CR 
893e 28 2c				jr z, .goend 
8940 fe 71				cp 'q' 
8942 28 0b				jr z, .goback 
8944			 
8944 fe 0b				cp KEY_LEFT 
8946 28 07				jr z, .goback 
8948 fe 08				cp KEY_BS 
894a 28 03				jr z, .goback 
894c c3 ba 88				jp .mloop 
894f			 
894f			.goback: 
894f 3e 00			ld a, 0 
8951 18 1d			jr .goend2 
8953			 
8953				; move up one 
8953			.mgoup: 
8953 3a 61 eb				ld a, (store_tmp2) 
8956 fe 00				cp 0 
8958 ca ba 88				jp z, .mloop 
895b 3d					dec a 
895c 32 61 eb				ld (store_tmp2), a 
895f c3 ba 88				jp .mloop 
8962			 
8962				; move down one 
8962			.mgod: 
8962 3a 61 eb				ld a, (store_tmp2) 
8965 3c					inc a 
8966 32 61 eb				ld (store_tmp2), a 
8969 c3 ba 88				jp .mloop 
896c			 
896c			 
896c			.goend: 
896c					; get selected item number 
896c			 
896c 3a 61 eb				ld a, (store_tmp2) 
896f 3c					inc a 
8970			 
8970			.goend2: 
8970 f5					push af 
8971			 
8971					; restore active fb 
8971					; TODO BUG assumes fb1 
8971			 
8971 21 1f ed				ld hl, display_fb1 
8974 22 db eb				ld (display_fb_active), hl 
8977			 
8977					; restore main regs 
8977			 
8977			 
8977 cd a0 88				call update_display 
897a			 
897a f1					pop af 
897b			 
897b c9				ret 
897c			 
897c .. 00		.msel:   db ">",0 
897e .. 00		.mup:   db "^",0 
8980 .. 00		.mdown:   db "v",0 
8982			 
8982			 
8982			; eof 
8982			 
# End of file firmware_display.asm
8982			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8982			; random number generators 
8982			 
8982			 
8982			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8982			 
8982			 
8982			;-----> Generate a random number 
8982			; output a=answer 0<=a<=255 
8982			; all registers are preserved except: af 
8982			random: 
8982 e5			        push    hl 
8983 d5			        push    de 
8984 2a bd eb		        ld      hl,(randData) 
8987 ed 5f		        ld      a,r 
8989 57			        ld      d,a 
898a 5e			        ld      e,(hl) 
898b 19			        add     hl,de 
898c 85			        add     a,l 
898d ac			        xor     h 
898e 22 bd eb		        ld      (randData),hl 
8991 d1			        pop     de 
8992 e1			        pop     hl 
8993 c9			        ret 
8994			 
8994			 
8994			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8994			 
8994			 
8994			 
8994			;------LFSR------ 
8994			;James Montelongo 
8994			;optimized by Spencer Putt 
8994			;out: 
8994			; a = 8 bit random number 
8994			RandLFSR: 
8994 21 c3 eb		        ld hl,LFSRSeed+4 
8997 5e			        ld e,(hl) 
8998 23			        inc hl 
8999 56			        ld d,(hl) 
899a 23			        inc hl 
899b 4e			        ld c,(hl) 
899c 23			        inc hl 
899d 7e			        ld a,(hl) 
899e 47			        ld b,a 
899f cb 13		        rl e  
89a1 cb 12			rl d 
89a3 cb 11		        rl c  
89a5 17				rla 
89a6 cb 13		        rl e  
89a8 cb 12			rl d 
89aa cb 11		        rl c  
89ac 17				rla 
89ad cb 13		        rl e  
89af cb 12			rl d 
89b1 cb 11		        rl c  
89b3 17				rla 
89b4 67			        ld h,a 
89b5 cb 13		        rl e  
89b7 cb 12			rl d 
89b9 cb 11		        rl c  
89bb 17				rla 
89bc a8			        xor b 
89bd cb 13		        rl e  
89bf cb 12			rl d 
89c1 ac			        xor h 
89c2 a9			        xor c 
89c3 aa			        xor d 
89c4 21 c5 eb		        ld hl,LFSRSeed+6 
89c7 11 c6 eb		        ld de,LFSRSeed+7 
89ca 01 07 00		        ld bc,7 
89cd ed b8		        lddr 
89cf 12			        ld (de),a 
89d0 c9			        ret 
89d1			 
89d1			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
89d1			 
89d1			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
89d1			 
89d1			 
89d1			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
89d1			 
89d1			prng16: 
89d1			;Inputs: 
89d1			;   (seed1) contains a 16-bit seed value 
89d1			;   (seed2) contains a NON-ZERO 16-bit seed value 
89d1			;Outputs: 
89d1			;   HL is the result 
89d1			;   BC is the result of the LCG, so not that great of quality 
89d1			;   DE is preserved 
89d1			;Destroys: 
89d1			;   AF 
89d1			;cycle: 4,294,901,760 (almost 4.3 billion) 
89d1			;160cc 
89d1			;26 bytes 
89d1 2a b7 eb		    ld hl,(seed1) 
89d4 44			    ld b,h 
89d5 4d			    ld c,l 
89d6 29			    add hl,hl 
89d7 29			    add hl,hl 
89d8 2c			    inc l 
89d9 09			    add hl,bc 
89da 22 b7 eb		    ld (seed1),hl 
89dd 2a b5 eb		    ld hl,(seed2) 
89e0 29			    add hl,hl 
89e1 9f			    sbc a,a 
89e2 e6 2d		    and %00101101 
89e4 ad			    xor l 
89e5 6f			    ld l,a 
89e6 22 b5 eb		    ld (seed2),hl 
89e9 09			    add hl,bc 
89ea c9			    ret 
89eb			 
89eb			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
89eb			 
89eb			rand32: 
89eb			;Inputs: 
89eb			;   (seed1_0) holds the lower 16 bits of the first seed 
89eb			;   (seed1_1) holds the upper 16 bits of the first seed 
89eb			;   (seed2_0) holds the lower 16 bits of the second seed 
89eb			;   (seed2_1) holds the upper 16 bits of the second seed 
89eb			;   **NOTE: seed2 must be non-zero 
89eb			;Outputs: 
89eb			;   HL is the result 
89eb			;   BC,DE can be used as lower quality values, but are not independent of HL. 
89eb			;Destroys: 
89eb			;   AF 
89eb			;Tested and passes all CAcert tests 
89eb			;Uses a very simple 32-bit LCG and 32-bit LFSR 
89eb			;it has a period of 18,446,744,069,414,584,320 
89eb			;roughly 18.4 quintillion. 
89eb			;LFSR taps: 0,2,6,7  = 11000101 
89eb			;291cc 
89eb			;seed1_0=$+1 
89eb			;    ld hl,12345 
89eb			;seed1_1=$+1 
89eb			;    ld de,6789 
89eb			;    ld b,h 
89eb			;    ld c,l 
89eb			;    add hl,hl \ rl e \ rl d 
89eb			;    add hl,hl \ rl e \ rl d 
89eb			;    inc l 
89eb			;    add hl,bc 
89eb			;    ld (seed1_0),hl 
89eb			;    ld hl,(seed1_1) 
89eb			;    adc hl,de 
89eb			;    ld (seed1_1),hl 
89eb			;    ex de,hl 
89eb			;seed2_0=$+1 
89eb			;    ld hl,9876 
89eb			;seed2_1=$+1 
89eb			;    ld bc,54321 
89eb			;    add hl,hl \ rl c \ rl b 
89eb			;    ld (seed2_1),bc 
89eb			;    sbc a,a 
89eb			;    and %11000101 
89eb			;    xor l 
89eb			;    ld l,a 
89eb			;    ld (seed2_0),hl 
89eb			;    ex de,hl 
89eb			;    add hl,bc 
89eb			;    ret 
89eb			; 
89eb			 
89eb			; 16-bit xorshift pseudorandom number generator by John Metcalf 
89eb			; 20 bytes, 86 cycles (excluding ret) 
89eb			 
89eb			; returns   hl = pseudorandom number 
89eb			; corrupts   a 
89eb			 
89eb			; generates 16-bit pseudorandom numbers with a period of 65535 
89eb			; using the xorshift method: 
89eb			 
89eb			; hl ^= hl << 7 
89eb			; hl ^= hl >> 9 
89eb			; hl ^= hl << 8 
89eb			 
89eb			; some alternative shift triplets which also perform well are: 
89eb			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
89eb			 
89eb			;  org 32768 
89eb			 
89eb			xrnd: 
89eb 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
89ee 3e 00		  ld a,0 
89f0 bd			  cp l 
89f1 20 02		  jr nz, .xrnd1 
89f3 2e 01		  ld l, 1 
89f5			.xrnd1: 
89f5			 
89f5 7c			  ld a,h 
89f6 1f			  rra 
89f7 7d			  ld a,l 
89f8 1f			  rra 
89f9 ac			  xor h 
89fa 67			  ld h,a 
89fb 7d			  ld a,l 
89fc 1f			  rra 
89fd 7c			  ld a,h 
89fe 1f			  rra 
89ff ad			  xor l 
8a00 6f			  ld l,a 
8a01 ac			  xor h 
8a02 67			  ld h,a 
8a03			 
8a03 22 bb eb		  ld (xrandc),hl 
8a06			 
8a06 c9			  ret 
8a07			;  
8a07			 
8a07			 
8a07			;;;; int maths 
8a07			 
8a07			; https://map.grauw.nl/articles/mult_div_shifts.php 
8a07			; Divide 16-bit values (with 16-bit result) 
8a07			; In: Divide BC by divider DE 
8a07			; Out: BC = result, HL = rest 
8a07			; 
8a07			Div16: 
8a07 21 00 00		    ld hl,0 
8a0a 78			    ld a,b 
8a0b 06 08		    ld b,8 
8a0d			Div16_Loop1: 
8a0d 17			    rla 
8a0e ed 6a		    adc hl,hl 
8a10 ed 52		    sbc hl,de 
8a12 30 01		    jr nc,Div16_NoAdd1 
8a14 19			    add hl,de 
8a15			Div16_NoAdd1: 
8a15 10 f6		    djnz Div16_Loop1 
8a17 17			    rla 
8a18 2f			    cpl 
8a19 47			    ld b,a 
8a1a 79			    ld a,c 
8a1b 48			    ld c,b 
8a1c 06 08		    ld b,8 
8a1e			Div16_Loop2: 
8a1e 17			    rla 
8a1f ed 6a		    adc hl,hl 
8a21 ed 52		    sbc hl,de 
8a23 30 01		    jr nc,Div16_NoAdd2 
8a25 19			    add hl,de 
8a26			Div16_NoAdd2: 
8a26 10 f6		    djnz Div16_Loop2 
8a28 17			    rla 
8a29 2f			    cpl 
8a2a 41			    ld b,c 
8a2b 4f			    ld c,a 
8a2c c9			ret 
8a2d			 
8a2d			 
8a2d			;http://z80-heaven.wikidot.com/math 
8a2d			; 
8a2d			;Inputs: 
8a2d			;     DE and A are factors 
8a2d			;Outputs: 
8a2d			;     A is not changed 
8a2d			;     B is 0 
8a2d			;     C is not changed 
8a2d			;     DE is not changed 
8a2d			;     HL is the product 
8a2d			;Time: 
8a2d			;     342+6x 
8a2d			; 
8a2d			Mult16: 
8a2d			 
8a2d 06 08		     ld b,8          ;7           7 
8a2f 21 00 00		     ld hl,0         ;10         10 
8a32 29			       add hl,hl     ;11*8       88 
8a33 07			       rlca          ;4*8        32 
8a34 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8a36 19			         add hl,de   ;--         -- 
8a37 10 f9		       djnz $-5      ;13*7+8     99 
8a39 c9			ret 
8a3a			 
8a3a			; 
8a3a			; Square root of 16-bit value 
8a3a			; In:  HL = value 
8a3a			; Out:  D = result (rounded down) 
8a3a			; 
8a3a			;Sqr16: 
8a3a			;    ld de,#0040 
8a3a			;    ld a,l 
8a3a			;    ld l,h 
8a3a			;    ld h,d 
8a3a			;    or a 
8a3a			;    ld b,8 
8a3a			;Sqr16_Loop: 
8a3a			;    sbc hl,de 
8a3a			;    jr nc,Sqr16_Skip 
8a3a			;    add hl,de 
8a3a			;Sqr16_Skip: 
8a3a			;    ccf 
8a3a			;    rl d 
8a3a			;    add a,a 
8a3a			;    adc hl,hl 
8a3a			;    add a,a 
8a3a			;    adc hl,hl 
8a3a			;    djnz Sqr16_Loop 
8a3a			;    ret 
8a3a			; 
8a3a			; 
8a3a			; Divide 8-bit values 
8a3a			; In: Divide E by divider C 
8a3a			; Out: A = result, B = rest 
8a3a			; 
8a3a			Div8: 
8a3a af			    xor a 
8a3b 06 08		    ld b,8 
8a3d			Div8_Loop: 
8a3d cb 13		    rl e 
8a3f 17			    rla 
8a40 91			    sub c 
8a41 30 01		    jr nc,Div8_NoAdd 
8a43 81			    add a,c 
8a44			Div8_NoAdd: 
8a44 10 f7		    djnz Div8_Loop 
8a46 47			    ld b,a 
8a47 7b			    ld a,e 
8a48 17			    rla 
8a49 2f			    cpl 
8a4a c9			    ret 
8a4b			 
8a4b			; 
8a4b			; Multiply 8-bit value with a 16-bit value (unrolled) 
8a4b			; In: Multiply A with DE 
8a4b			; Out: HL = result 
8a4b			; 
8a4b			Mult12U: 
8a4b 2e 00		    ld l,0 
8a4d 87			    add a,a 
8a4e 30 01		    jr nc,Mult12U_NoAdd0 
8a50 19			    add hl,de 
8a51			Mult12U_NoAdd0: 
8a51 29			    add hl,hl 
8a52 87			    add a,a 
8a53 30 01		    jr nc,Mult12U_NoAdd1 
8a55 19			    add hl,de 
8a56			Mult12U_NoAdd1: 
8a56 29			    add hl,hl 
8a57 87			    add a,a 
8a58 30 01		    jr nc,Mult12U_NoAdd2 
8a5a 19			    add hl,de 
8a5b			Mult12U_NoAdd2: 
8a5b 29			    add hl,hl 
8a5c 87			    add a,a 
8a5d 30 01		    jr nc,Mult12U_NoAdd3 
8a5f 19			    add hl,de 
8a60			Mult12U_NoAdd3: 
8a60 29			    add hl,hl 
8a61 87			    add a,a 
8a62 30 01		    jr nc,Mult12U_NoAdd4 
8a64 19			    add hl,de 
8a65			Mult12U_NoAdd4: 
8a65 29			    add hl,hl 
8a66 87			    add a,a 
8a67 30 01		    jr nc,Mult12U_NoAdd5 
8a69 19			    add hl,de 
8a6a			Mult12U_NoAdd5: 
8a6a 29			    add hl,hl 
8a6b 87			    add a,a 
8a6c 30 01		    jr nc,Mult12U_NoAdd6 
8a6e 19			    add hl,de 
8a6f			Mult12U_NoAdd6: 
8a6f 29			    add hl,hl 
8a70 87			    add a,a 
8a71 d0			    ret nc 
8a72 19			    add hl,de 
8a73 c9			    ret 
8a74			 
8a74			; 
8a74			; Multiply 8-bit value with a 16-bit value (right rotating) 
8a74			; In: Multiply A with DE 
8a74			;      Put lowest value in A for most efficient calculation 
8a74			; Out: HL = result 
8a74			; 
8a74			Mult12R: 
8a74 21 00 00		    ld hl,0 
8a77			Mult12R_Loop: 
8a77 cb 3f		    srl a 
8a79 30 01		    jr nc,Mult12R_NoAdd 
8a7b 19			    add hl,de 
8a7c			Mult12R_NoAdd: 
8a7c cb 23		    sla e 
8a7e cb 12		    rl d 
8a80 b7			    or a 
8a81 c2 77 8a		    jp nz,Mult12R_Loop 
8a84 c9			    ret 
8a85			 
8a85			; 
8a85			; Multiply 16-bit values (with 32-bit result) 
8a85			; In: Multiply BC with DE 
8a85			; Out: BCHL = result 
8a85			; 
8a85			Mult32: 
8a85 79			    ld a,c 
8a86 48			    ld c,b 
8a87 21 00 00		    ld hl,0 
8a8a 06 10		    ld b,16 
8a8c			Mult32_Loop: 
8a8c 29			    add hl,hl 
8a8d 17			    rla 
8a8e cb 11		    rl c 
8a90 30 07		    jr nc,Mult32_NoAdd 
8a92 19			    add hl,de 
8a93 ce 00		    adc a,0 
8a95 d2 99 8a		    jp nc,Mult32_NoAdd 
8a98 0c			    inc c 
8a99			Mult32_NoAdd: 
8a99 10 f1		    djnz Mult32_Loop 
8a9b 41			    ld b,c 
8a9c 4f			    ld c,a 
8a9d c9			    ret 
8a9e			 
8a9e			 
8a9e			 
8a9e			; 
8a9e			; Multiply 8-bit values 
8a9e			; In:  Multiply H with E 
8a9e			; Out: HL = result 
8a9e			; 
8a9e			Mult8: 
8a9e 16 00		    ld d,0 
8aa0 6a			    ld l,d 
8aa1 06 08		    ld b,8 
8aa3			Mult8_Loop: 
8aa3 29			    add hl,hl 
8aa4 30 01		    jr nc,Mult8_NoAdd 
8aa6 19			    add hl,de 
8aa7			Mult8_NoAdd: 
8aa7 10 fa		    djnz Mult8_Loop 
8aa9 c9			    ret 
8aaa			 
8aaa			 
8aaa			 
8aaa			 
8aaa			 
8aaa			 
8aaa			 
8aaa			 
8aaa			;;http://z80-heaven.wikidot.com/math 
8aaa			;;This divides DE by BC, storing the result in DE, remainder in HL 
8aaa			; 
8aaa			;DE_Div_BC:          ;1281-2x, x is at most 16 
8aaa			;     ld a,16        ;7 
8aaa			;     ld hl,0        ;10 
8aaa			;     jp $+5         ;10 
8aaa			;.DivLoop: 
8aaa			;       add hl,bc    ;-- 
8aaa			;       dec a        ;64 
8aaa			;       jr z,.DivLoopEnd        ;86 
8aaa			; 
8aaa			;       sla e        ;128 
8aaa			;       rl d         ;128 
8aaa			;       adc hl,hl    ;240 
8aaa			;       sbc hl,bc    ;240 
8aaa			;       jr nc,.DivLoop ;23|21 
8aaa			;       inc e        ;-- 
8aaa			;       jp .DivLoop+1 
8aaa			; 
8aaa			;.DivLoopEnd: 
8aaa			 
8aaa			;HL_Div_C: 
8aaa			;Inputs: 
8aaa			;     HL is the numerator 
8aaa			;     C is the denominator 
8aaa			;Outputs: 
8aaa			;     A is the remainder 
8aaa			;     B is 0 
8aaa			;     C is not changed 
8aaa			;     DE is not changed 
8aaa			;     HL is the quotient 
8aaa			; 
8aaa			;       ld b,16 
8aaa			;       xor a 
8aaa			;         add hl,hl 
8aaa			;         rla 
8aaa			;         cp c 
8aaa			;         jr c,$+4 
8aaa			;           inc l 
8aaa			;           sub c 
8aaa			;         djnz $-7 
8aaa			 
8aaa			; https://plutiedev.com/z80-add-8bit-to-16bit 
8aaa			 
8aaa			addatohl: 
8aaa 85			    add   a, l    ; A = A+L 
8aab 6f			    ld    l, a    ; L = A+L 
8aac 8c			    adc   a, h    ; A = A+L+H+carry 
8aad 95			    sub   l       ; A = H+carry 
8aae 67			    ld    h, a    ; H = H+carry 
8aaf c9			ret 
8ab0			 
8ab0			addatode: 
8ab0 83			    add   a, e    ; A = A+L 
8ab1 5f			    ld    e, a    ; L = A+L 
8ab2 8a			    adc   a, d    ; A = A+L+H+carry 
8ab3 93			    sub   e       ; A = H+carry 
8ab4 57			    ld    d, a    ; H = H+carry 
8ab5 c9			ret 
8ab6			 
8ab6			 
8ab6			addatobc: 
8ab6 81			    add   a, c    ; A = A+L 
8ab7 4f			    ld    c, a    ; L = A+L 
8ab8 88			    adc   a, b    ; A = A+L+H+carry 
8ab9 91			    sub   c       ; A = H+carry 
8aba 47			    ld    b, a    ; H = H+carry 
8abb c9			ret 
8abc			 
8abc			subafromhl: 
8abc			   ; If A=0 do nothing 
8abc			    ; Otherwise flip A's sign. Since 
8abc			    ; the upper byte becomes -1, also 
8abc			    ; substract 1 from H. 
8abc ed 44		    neg 
8abe ca c7 8a		    jp    z, Skip 
8ac1 25			    dec   h 
8ac2			     
8ac2			    ; Now add the low byte as usual 
8ac2			    ; Two's complement takes care of 
8ac2			    ; ensuring the result is correct 
8ac2 85			    add   a, l 
8ac3 6f			    ld    l, a 
8ac4 8c			    adc   a, h 
8ac5 95			    sub   l 
8ac6 67			    ld    h, a 
8ac7			Skip: 
8ac7 c9				ret 
8ac8			 
8ac8			 
8ac8			; compare hl and de 
8ac8			; returns:  
8ac8			; if hl = de, z=1, s=0, c0=0 
8ac8			; if hl > de, z=0, s=0, c=0 
8ac8			; if hl < de, z=0, s=1, c=1 
8ac8			cmp16:	 
8ac8 b7				or a 
8ac9 ed 52			sbc hl,de 
8acb e0				ret po 
8acc 7c				ld a,h 
8acd 1f				rra 
8ace ee 40			xor 01000000B 
8ad0 37				scf 
8ad1 8f				adc a,a 
8ad2 c9				ret 
8ad3			 
8ad3			 
8ad3			; test if hl contains zero   - A is destroyed 
8ad3			 
8ad3			ishlzero:    
8ad3 b7				or a     ; reset flags 
8ad4 7c				ld a, h 
8ad5 b5				or l        	 
8ad6			 
8ad6 c9				ret 
8ad7			 
8ad7			 
8ad7			 
8ad7			 
8ad7			if FORTH_ENABLE_FLOATMATH 
8ad7			;include "float/bbcmath.z80" 
8ad7			include "float/lpfpcalc.asm" 
8ad7			endif 
8ad7			 
8ad7			 
8ad7			; eof 
8ad7			 
# End of file firmware_maths.asm
8ad7			include "firmware_strings.asm"   ; string handling  
8ad7			 
8ad7			 
8ad7			; TODO string len 
8ad7			; input text string, end on cr with zero term 
8ad7			; a offset into frame buffer to start prompt 
8ad7			; d is max length 
8ad7			; e is display size TODO 
8ad7			; c is current cursor position 
8ad7			; hl is ptr to where string will be stored 
8ad7			 
8ad7			 
8ad7			; TODO check limit of buffer for new inserts 
8ad7			; TODO check insert does not push beyond buffer 
8ad7			; TODO scroll in a limited display area 
8ad7			; TODO scroll whole screen on page wrap 
8ad7			 
8ad7			 
8ad7			; TODO handle KEY_PREVWORD 
8ad7			; TODO handle KEY_NEXTWORD 
8ad7			; TODO handle KEY_HOME 
8ad7			; TODO handle KEY_END 
8ad7			; TODO use LCD cursor? 
8ad7			 
8ad7 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8ada 81					add c 
8adb 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8ade 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
8ae1 79					ld a, c 
8ae2 cd aa 8a				call addatohl 
8ae5 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8ae8 7a					ld a,d 
8ae9 32 75 ee			        ld (input_size), a       ; save length of input area 
8aec 79					ld a, c 
8aed 32 64 ee				ld (input_cursor),a      ; init cursor start position  
8af0 7b					ld a,e 
8af1 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8af4					 
8af4					 
8af4			 
8af4			;		ld a,(input_ptr) 
8af4			;		ld (input_under_cursor),a 	; save what is under the cursor 
8af4			 
8af4			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8af4					; init cursor shape if not set by the cin routines 
8af4 21 d3 eb				ld hl, cursor_shape 
8af7 3e ff				ld a, 255 
8af9 77					ld (hl), a 
8afa 23					inc hl 
8afb 3e 00				ld a, 0 
8afd 77					ld (hl), a 
8afe			 
8afe 3e 0f				ld a, CUR_BLINK_RATE 
8b00 32 6f ee				ld (input_cur_flash), a 
8b03 3e 01				ld a, 1 
8b05 32 6e ee				ld (input_cur_onoff),a 
8b08			 
8b08			;	if DEBUG_INPUT 
8b08			;		push af 
8b08			;		ld a, 'I' 
8b08			;		ld (debug_mark),a 
8b08			;		pop af 
8b08			;		CALLMONITOR 
8b08			;	endif 
8b08			.is1:		; main entry loop 
8b08			 
8b08			 
8b08			 
8b08					; pause 1ms 
8b08			 
8b08 3e 01				ld a, 1 
8b0a cd e2 87				call aDelayInMS 
8b0d			 
8b0d					; dec flash counter 
8b0d 3a 6f ee				ld a, (input_cur_flash) 
8b10 3d					dec a 
8b11 32 6f ee				ld (input_cur_flash), a 
8b14 fe 00				cp 0 
8b16 20 0d				jr nz, .nochgstate 
8b18			 
8b18			 
8b18					; change state 
8b18 3a 6e ee				ld a,(input_cur_onoff) 
8b1b ed 44				neg 
8b1d 32 6e ee				ld (input_cur_onoff),a 
8b20			 
8b20			 
8b20					; reset on change of state 
8b20 3e 0f				ld a, CUR_BLINK_RATE 
8b22 32 6f ee				ld (input_cur_flash), a 
8b25			 
8b25			.nochgstate: 
8b25					 
8b25					 
8b25			 
8b25					; display cursor  
8b25			 
8b25			;		ld hl, (input_start) 
8b25			;		ld a, (input_cursor) 
8b25			;		call addatohl 
8b25			 
8b25					; get char under cursor and replace with cursor 
8b25 2a 78 ee		ld hl, (input_ptr) 
8b28			;		ld a, (hl) 
8b28			;		ld (input_under_cursor),a 
8b28			;		ld a, '_' 
8b28			;		ld (hl), a 
8b28			 
8b28					; display string 
8b28			 
8b28 ed 5b 76 ee			ld de, (input_start) 
8b2c 3a 73 ee				ld a, (input_at_pos) 
8b2f cd 90 88				call str_at_display 
8b32			;	        call update_display 
8b32			 
8b32					; find place to put the cursor 
8b32			;		add h 
8b32			;		ld l, display_row_1 
8b32			;		sub l 
8b32			; (input_at_pos) 
8b32					;ld c, a 
8b32			;		ld a, (input_cursor) 
8b32			;		ld l, (input_at_pos) 
8b32			;		;ld b, h 
8b32			;		add l 
8b32			;		ld (input_at_cursor),a 
8b32					;ld l,h 
8b32			 
8b32			;		ld h, 0 
8b32			;		ld l,(input_at_pos) 
8b32			;		ld a, (input_cursor) 
8b32			;		call addatohl 
8b32			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8b32			;		call subafromhl 
8b32			;		ld a,l 
8b32			;		ld (input_at_cursor), a 
8b32			 
8b32				if DEBUG_INPUT 
8b32					ld a, (hardware_diag) 
8b32					cp 0 
8b32					jr z, .skip_input_diag 
8b32			 
8b32					ld a,(input_at_pos) 
8b32					ld hl, LFSRSeed 
8b32					call hexout 
8b32					ld a, (input_cursor) 
8b32					ld hl, LFSRSeed+2 
8b32					call hexout 
8b32					ld a,(input_at_cursor) 
8b32					ld hl, LFSRSeed+4 
8b32					call hexout 
8b32			 
8b32					ld a,(input_cur_onoff) 
8b32					ld hl, LFSRSeed+6 
8b32					call hexout 
8b32			 
8b32					ld a,(input_cur_flash) 
8b32					ld hl, LFSRSeed+8 
8b32					call hexout 
8b32			 
8b32					ld a,(input_len) 
8b32					ld hl, LFSRSeed+10 
8b32					call hexout 
8b32					ld hl, LFSRSeed+12 
8b32					ld a, 0 
8b32					ld (hl),a 
8b32					ld a, display_row_4 
8b32					ld de, LFSRSeed 
8b32					call str_at_display 
8b32					.skip_input_diag: 
8b32				endif 
8b32			 
8b32					; decide on if we are showing the cursor this time round 
8b32			 
8b32 3a 6e ee				ld a, (input_cur_onoff) 
8b35 fe ff				cp 255 
8b37 28 13				jr z, .skipcur 
8b39			 
8b39			 
8b39 3a 71 ee				ld a,(input_at_cursor) 
8b3c 11 d3 eb				ld de, cursor_shape 
8b3f cd 90 88				call str_at_display 
8b42			 
8b42					; save length of current input string 
8b42 2a 76 ee				ld hl, (input_start) 
8b45 cd 08 8f				call strlenz 
8b48 7d					ld a,l 
8b49 32 69 ee				ld (input_len),a 
8b4c			 
8b4c			.skipcur: 
8b4c			 
8b4c cd a0 88			        call update_display 
8b4f					 
8b4f			 
8b4f			 
8b4f					; wait 
8b4f				 
8b4f					; TODO loop without wait to flash the cursor and char under cursor	 
8b4f cd 39 d7				call cin    ; _wait 
8b52			 
8b52 fe 00				cp 0 
8b54 ca 08 8b				jp z, .is1 
8b57			 
8b57					; get ptr to char to input into 
8b57			 
8b57 4f					ld c,a 
8b58 2a 76 ee				ld hl, (input_start) 
8b5b 3a 64 ee				ld a, (input_cursor) 
8b5e cd aa 8a				call addatohl 
8b61 22 78 ee				ld (input_ptr), hl 
8b64 79					ld a,c 
8b65			 
8b65					; replace char under cursor 
8b65			 
8b65			;		ld hl, (input_ptr) 
8b65			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8b65			;		ld (hl), a 
8b65			 
8b65			;	if DEBUG_INPUT 
8b65			;		push af 
8b65			;		ld a, 'i' 
8b65			;		ld (debug_mark),a 
8b65			;		pop af 
8b65			;		CALLMONITOR 
8b65			;	endif 
8b65 fe 0e				cp KEY_HOME 
8b67 20 0e				jr nz, .iske 
8b69			 
8b69 3a 73 ee				ld a, (input_at_pos) 
8b6c 32 71 ee				ld (input_at_cursor),a 
8b6f 3e 00				ld a, 0 
8b71 32 64 ee				ld (input_cursor), a 
8b74 c3 08 8b				jp .is1 
8b77					 
8b77 fe 0f		.iske:		cp KEY_END 
8b79 20 03				jr nz, .isknw 
8b7b c3 08 8b				jp .is1 
8b7e			 
8b7e fe 06		.isknw:		cp KEY_NEXTWORD 
8b80 20 1b				jr nz, .iskpw 
8b82			 
8b82 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
8b85 7e					ld a,(hl)	 
8b86 fe 00				cp 0 
8b88 ca 08 8b				jp z, .is1    ; end of string 
8b8b fe 20				cp ' ' 
8b8d ca 08 8b				jp z, .is1    ; end of word 
8b90 23					inc hl 
8b91 22 78 ee				ld (input_ptr), hl 
8b94 3a 71 ee				ld a, (input_at_cursor) 
8b97 3c					inc a 
8b98 32 71 ee				ld (input_at_cursor), a 
8b9b 18 e5				jr .isknwm 
8b9d			 
8b9d fe 07		.iskpw:		cp KEY_PREVWORD 
8b9f 20 1b				jr nz, .iskl 
8ba1			.iskpwm:	 
8ba1 2a 78 ee				ld hl, (input_ptr) 
8ba4 7e					ld a,(hl)	 
8ba5 fe 00				cp 0  
8ba7 ca 08 8b				jp z, .is1    ; end of string 
8baa fe 20				cp ' ' 
8bac ca 08 8b				jp z, .is1    ; end of word 
8baf 2b					dec hl 
8bb0 22 78 ee				ld (input_ptr), hl 
8bb3 3a 71 ee				ld a, (input_at_cursor) 
8bb6 3d					dec a 
8bb7 32 71 ee				ld (input_at_cursor), a 
8bba 18 e5				jr .iskpwm 
8bbc			 
8bbc			 
8bbc fe 0b		.iskl:		cp KEY_LEFT 
8bbe 20 27				jr nz, .isk1 
8bc0			 
8bc0 3a 64 ee				ld a, (input_cursor) 
8bc3			 
8bc3 fe 00				cp 0 
8bc5 ca 08 8b				jp z, .is1 		; at start of line to ignore  
8bc8			 
8bc8 3d					dec  a 		; TODO check underflow 
8bc9 32 64 ee				ld (input_cursor), a 
8bcc			 
8bcc 2a 78 ee				ld hl, (input_ptr) 
8bcf 2b					dec hl 
8bd0 22 78 ee				ld (input_ptr), hl 
8bd3					 
8bd3 3a 71 ee				ld a, (input_at_cursor) 
8bd6 3d					dec a 
8bd7 32 71 ee				ld (input_at_cursor), a 
8bda			 
8bda 3e 01				ld a, 1		; show cursor moving 
8bdc 32 6e ee				ld (input_cur_onoff),a 
8bdf 3e 0f				ld a, CUR_BLINK_RATE 
8be1 32 6f ee				ld (input_cur_flash), a 
8be4			 
8be4 c3 08 8b				jp .is1 
8be7			 
8be7 fe 0c		.isk1:		cp KEY_RIGHT 
8be9 20 2a				jr nz, .isk2 
8beb			 
8beb 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8bee 5f					ld e,a 
8bef 3a 64 ee				ld a, (input_cursor) 
8bf2 bb					cp e 
8bf3 ca 08 8b				jp z, .is1		; at the end of string so dont go right 
8bf6			 
8bf6 3c					inc  a 		; TODO check overflow 
8bf7 32 64 ee				ld (input_cursor), a 
8bfa			 
8bfa 3a 71 ee				ld a, (input_at_cursor) 
8bfd 3c					inc a 
8bfe 32 71 ee				ld (input_at_cursor), a 
8c01			 
8c01 2a 78 ee				ld hl, (input_ptr) 
8c04 23					inc hl 
8c05 22 78 ee				ld (input_ptr), hl 
8c08			 
8c08 3e 01				ld a, 1		; show cursor moving 
8c0a 32 6e ee				ld (input_cur_onoff),a 
8c0d 3e 0f				ld a, CUR_BLINK_RATE 
8c0f 32 6f ee				ld (input_cur_flash), a 
8c12			 
8c12 c3 08 8b				jp .is1 
8c15			 
8c15 fe 05		.isk2:		cp KEY_UP 
8c17			 
8c17 20 26				jr nz, .isk3 
8c19			 
8c19					; swap last command with the current on 
8c19			 
8c19					; move cursor to start of string 
8c19 2a 76 ee				ld hl, (input_start) 
8c1c 22 78 ee				ld (input_ptr), hl 
8c1f			 
8c1f 3a 73 ee				ld a, (input_at_pos) 
8c22 32 71 ee				ld (input_at_cursor), a 
8c25			 
8c25 3e 00				ld a, 0 
8c27 32 64 ee				ld (input_cursor), a 
8c2a					 
8c2a					; swap input and last command buffers 
8c2a			 
8c2a 21 87 e6				ld hl, os_cli_cmd 
8c2d 11 86 e7				ld de, os_last_cmd 
8c30 06 ff				ld b, 255 
8c32 7e			.swap1:		ld a, (hl) 
8c33 4f					ld c,a 
8c34 1a					ld a, (de) 
8c35 77					ld (hl), a 
8c36 79					ld a,c 
8c37 12					ld (de),a 
8c38 23					inc hl 
8c39 13					inc de 
8c3a 10 f6				djnz .swap1 
8c3c			 
8c3c			 
8c3c			 
8c3c			 
8c3c			 
8c3c c3 08 8b				jp .is1 
8c3f			 
8c3f fe 08		.isk3:		cp KEY_BS 
8c41 20 3c				jr nz, .isk4 
8c43			 
8c43 3a 64 ee				ld a, (input_cursor) 
8c46			 
8c46 fe 00				cp 0 
8c48 ca 08 8b				jp z, .is1 		; at start of line to ignore  
8c4b			 
8c4b 3d					dec  a 		; TODO check underflow 
8c4c 32 64 ee				ld (input_cursor), a 
8c4f			 
8c4f					; hl is source 
8c4f					; de needs to be source - 1 
8c4f			 
8c4f			;		ld a, 0 
8c4f			;		dec hl 
8c4f			;		ld (hl), a 
8c4f			 
8c4f 2a 78 ee				ld hl, (input_ptr) 
8c52 2b					dec hl 
8c53 22 78 ee				ld (input_ptr), hl 
8c56			 
8c56					; shift all data 
8c56			 
8c56 e5					push hl 
8c57 23					inc hl 
8c58 d1					pop de 
8c59 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8c5c 4f					ld c,a 
8c5d 06 00				ld b,0 
8c5f ed b0				ldir  
8c61			 
8c61			 
8c61			 
8c61			 
8c61 3a 71 ee				ld a, (input_at_cursor) 
8c64 3d					dec a 
8c65 32 71 ee				ld (input_at_cursor), a 
8c68			 
8c68			 
8c68 3e 01				ld a, 1		; show cursor moving 
8c6a 32 6e ee				ld (input_cur_onoff),a 
8c6d 3e 0f				ld a, CUR_BLINK_RATE 
8c6f 32 6f ee				ld (input_cur_flash), a 
8c72			 
8c72					; remove char 
8c72 3a 71 ee				ld a, (input_at_cursor) 
8c75 3c					inc a 
8c76 11 00 8d				ld de,.iblank 
8c79 cd 90 88				call str_at_display 
8c7c			 
8c7c c3 08 8b				jp .is1 
8c7f			 
8c7f fe 0d		.isk4:		cp KEY_CR 
8c81 28 6c				jr z, .endinput 
8c83			 
8c83					; else add the key press to the end 
8c83			 
8c83 4f					ld c, a			; save key pressed 
8c84			 
8c84 7e					ld a,(hl)		; get what is currently under char 
8c85			 
8c85 fe 00				cp 0			; we are at the end of the string 
8c87 20 2f				jr nz, .onchar 
8c89					 
8c89					; add a char to the end of the string 
8c89				 
8c89 71					ld (hl),c 
8c8a 23					inc hl 
8c8b			;		ld a,' ' 
8c8b			;		ld (hl),a 
8c8b			;		inc hl 
8c8b 3e 00				ld a,0 
8c8d 77					ld (hl),a 
8c8e 2b					dec hl 
8c8f			 
8c8f 3a 64 ee				ld a, (input_cursor) 
8c92 3c					inc a				; TODO check max string length and scroll  
8c93 32 64 ee				ld (input_cursor), a		; inc cursor pos 
8c96							 
8c96 3a 71 ee				ld a, (input_at_cursor) 
8c99 3c					inc a 
8c9a 32 71 ee				ld (input_at_cursor), a 
8c9d			 
8c9d 2a 78 ee				ld hl, (input_ptr) 
8ca0 23					inc hl 
8ca1 22 78 ee				ld (input_ptr), hl 
8ca4			 
8ca4 2a 78 ee				ld hl, (input_ptr) 
8ca7 23					inc hl 
8ca8 22 78 ee				ld (input_ptr), hl 
8cab			;	if DEBUG_INPUT 
8cab			;		push af 
8cab			;		ld a, '+' 
8cab			;		ld (debug_mark),a 
8cab			;		pop af 
8cab			;		CALLMONITOR 
8cab			;	endif 
8cab 3e 01				ld a, 1		; show cursor moving 
8cad 32 6e ee				ld (input_cur_onoff),a 
8cb0 3e 0f				ld a, CUR_BLINK_RATE 
8cb2 32 6f ee				ld (input_cur_flash), a 
8cb5 c3 08 8b				jp .is1 
8cb8					 
8cb8			 
8cb8			 
8cb8					; if on a char then insert 
8cb8			.onchar: 
8cb8			 
8cb8					; TODO over flow check: make sure insert does not blow out buffer 
8cb8			 
8cb8					; need to do some maths to use lddr 
8cb8			 
8cb8 e5					push hl   ; save char pos 
8cb9 c5					push bc 
8cba			 
8cba 2a 76 ee				ld hl, (input_start) 
8cbd 3a 69 ee				ld a, (input_len) 
8cc0 cd aa 8a				call addatohl  		; end of string 
8cc3 23					inc hl 
8cc4 23					inc hl		; past zero term 
8cc5 e5					push hl 
8cc6 23					inc hl 
8cc7 e5					push hl  
8cc8			 
8cc8								; start and end of lddr set, now how much to move? 
8cc8			 
8cc8							 
8cc8 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8ccb 47					ld b,a 
8ccc 3a 69 ee				ld a,(input_len) 
8ccf 5f					ld e,a 
8cd0 90					sub b 
8cd1 3c					inc a		;?? 
8cd2 3c					inc a		;?? 
8cd3 3c					inc a		;?? 
8cd4			 
8cd4 06 00				ld b,0 
8cd6 4f					ld c,a 
8cd7			 
8cd7				if DEBUG_INPUT 
8cd7					push af 
8cd7					ld a, 'i' 
8cd7					ld (debug_mark),a 
8cd7					pop af 
8cd7			;		CALLMONITOR 
8cd7				endif 
8cd7 d1					pop de 
8cd8 e1					pop hl 
8cd9				if DEBUG_INPUT 
8cd9					push af 
8cd9					ld a, 'I' 
8cd9					ld (debug_mark),a 
8cd9					pop af 
8cd9			;		CALLMONITOR 
8cd9				endif 
8cd9 ed b8				lddr 
8cdb				 
8cdb			 
8cdb			 
8cdb					; TODO have a key for insert/overwrite mode???? 
8cdb c1					pop bc 
8cdc e1					pop hl 
8cdd 71					ld (hl), c		; otherwise overwrite current char 
8cde					 
8cde			 
8cde			 
8cde			 
8cde 3a 64 ee				ld a, (input_cursor) 
8ce1 3c					inc  a 		; TODO check overflow 
8ce2 32 64 ee				ld (input_cursor), a 
8ce5			 
8ce5 3a 71 ee				ld a, (input_at_cursor) 
8ce8 3c					inc a 
8ce9 32 71 ee				ld (input_at_cursor), a 
8cec			 
8cec c3 08 8b				jp .is1 
8cef			 
8cef			.endinput:	; TODO look for end of string 
8cef			 
8cef					; add trailing space for end of token 
8cef			 
8cef 2a 76 ee				ld hl, (input_start) 
8cf2 3a 69 ee				ld a,(input_len) 
8cf5 cd aa 8a				call addatohl 
8cf8 3e 20				ld a, ' ' 
8cfa 77					ld (hl),a 
8cfb					; TODO eof of parse marker 
8cfb			 
8cfb 23					inc hl 
8cfc 3e 00				ld a, 0 
8cfe 77					ld (hl),a 
8cff			 
8cff			 
8cff c9					ret 
8d00			 
8d00 .. 00		.iblank: db " ",0 
8d02			 
8d02			 
8d02 32 73 ee		input_str_prev:	ld (input_at_pos), a 
8d05 22 76 ee				ld (input_start), hl 
8d08 3e 01				ld a,1			; add cursor 
8d0a 77					ld (hl),a 
8d0b 23					inc hl 
8d0c 3e 00				ld a,0 
8d0e 77					ld (hl),a 
8d0f 22 78 ee				ld (input_ptr), hl 
8d12 7a					ld a,d 
8d13 32 75 ee				ld (input_size), a 
8d16 3e 00				ld a,0 
8d18 32 64 ee				ld (input_cursor),a 
8d1b			.instr1:	 
8d1b			 
8d1b					; TODO do block cursor 
8d1b					; TODO switch cursor depending on the modifer key 
8d1b			 
8d1b					; update cursor shape change on key hold 
8d1b			 
8d1b 2a 78 ee				ld hl, (input_ptr) 
8d1e 2b					dec hl 
8d1f 3a d3 eb				ld a,(cursor_shape) 
8d22 77					ld (hl), a 
8d23			 
8d23					; display entered text 
8d23 3a 73 ee				ld a,(input_at_pos) 
8d26 cd 97 d6		            	CALL fLCD_Pos       ;Position cursor to location in A 
8d29 ed 5b 76 ee	            	LD   de, (input_start) 
8d2d cd 91 d6		            	CALL fLCD_Str       ;Display string pointed to by DE 
8d30			 
8d30 cd 39 d7				call cin 
8d33 fe 00				cp 0 
8d35 28 e4				jr z, .instr1 
8d37			 
8d37					; proecess keyboard controls first 
8d37			 
8d37 2a 78 ee				ld hl,(input_ptr) 
8d3a			 
8d3a fe 0d				cp KEY_CR	 ; pressing enter ends input 
8d3c 28 5a				jr z, .instrcr 
8d3e			 
8d3e fe 08				cp KEY_BS 	; back space 
8d40 20 0f				jr nz, .instr2 
8d42					; process back space 
8d42			 
8d42					; TODO stop back space if at start of string 
8d42 2b					dec hl 
8d43 2b					dec hl ; to over write cursor 
8d44 3a d3 eb				ld a,(cursor_shape) 
8d47					;ld a,0 
8d47 77					ld (hl),a 
8d48 23					inc hl 
8d49 3e 20				ld a," " 
8d4b 77					ld (hl),a 
8d4c 22 78 ee				ld (input_ptr),hl 
8d4f					 
8d4f			 
8d4f 18 ca				jr .instr1 
8d51			 
8d51 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8d53 20 06				jr nz, .instr3 
8d55 2b					dec hl 
8d56 22 78 ee				ld (input_ptr),hl 
8d59 18 c0				jr .instr1 
8d5b				 
8d5b fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8d5d 20 06				jr nz, .instr4 
8d5f 23					inc hl 
8d60 22 78 ee				ld (input_ptr),hl 
8d63 18 b6				jr .instr1 
8d65			 
8d65 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8d67 20 06				jr nz, .instr5 
8d69 2b					dec hl 
8d6a 22 78 ee				ld (input_ptr),hl 
8d6d 18 ac				jr .instr1 
8d6f			 
8d6f fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8d71 20 06				jr nz, .instr6 
8d73 2b					dec hl 
8d74 22 78 ee				ld (input_ptr),hl 
8d77 18 a2				jr .instr1 
8d79 fe 05		.instr6:        cp KEY_UP      ; recall last command 
8d7b 20 0b				jr nz, .instrnew 
8d7d			 
8d7d 21 60 e3			ld hl, scratch 
8d80 11 86 e7			ld de, os_last_cmd 
8d83 cd a1 8d			call strcpy 
8d86 18 93				jr .instr1 
8d88			 
8d88			 
8d88			.instrnew:	; no special key pressed to see if we have room to store it 
8d88			 
8d88					; TODO do string size test 
8d88			 
8d88 2b					dec hl ; to over write cursor 
8d89 77					ld (hl),a 
8d8a 23					inc hl 
8d8b 3a d3 eb				ld a,(cursor_shape) 
8d8e 77					ld (hl),a 
8d8f 23					inc hl 
8d90 3e 00				ld a,0 
8d92 77					ld (hl),a 
8d93			 
8d93 22 78 ee				ld (input_ptr),hl 
8d96					 
8d96 18 83				jr .instr1 
8d98 2b			.instrcr:	dec hl		; remove cursor 
8d99 3e 20				ld a,' '	; TODO add a trailing space for safety 
8d9b 77					ld (hl),a 
8d9c 23					inc hl 
8d9d 3e 00				ld a,0 
8d9f 77					ld (hl),a 
8da0			 
8da0			 
8da0					; if at end of line scroll up    
8da0					; TODO detecting only end of line 4 for scroll up  
8da0			 
8da0					;ld   
8da0			 
8da0 c9					ret 
8da1			 
8da1			 
8da1			; strcpy hl = dest, de source 
8da1			 
8da1 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8da2 b7			            OR   A              ;Null terminator? 
8da3 c8			            RET  Z              ;Yes, so finished 
8da4 1a					ld a,(de) 
8da5 77					ld (hl),a 
8da6 13			            INC  DE             ;Point to next character 
8da7 23					inc hl 
8da8 18 f7		            JR   strcpy       ;Repeat 
8daa c9					ret 
8dab			 
8dab			 
8dab			; TODO string_at  
8dab			; pass string which starts with lcd offset address and then null term string 
8dab			 
8dab			; TODO string to dec 
8dab			; TODO string to hex 
8dab			; TODO byte to string hex 
8dab			; TODO byte to string dec 
8dab			 
8dab			 
8dab			 
8dab			; from z80uartmonitor 
8dab			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dab			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8dab			; pass hl for where to put the text 
8dab			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dab c5			hexout:	PUSH BC 
8dac f5					PUSH AF 
8dad 47					LD B, A 
8dae					; Upper nybble 
8dae cb 3f				SRL A 
8db0 cb 3f				SRL A 
8db2 cb 3f				SRL A 
8db4 cb 3f				SRL A 
8db6 cd c6 8d				CALL tohex 
8db9 77					ld (hl),a 
8dba 23					inc hl	 
8dbb					 
8dbb					; Lower nybble 
8dbb 78					LD A, B 
8dbc e6 0f				AND 0FH 
8dbe cd c6 8d				CALL tohex 
8dc1 77					ld (hl),a 
8dc2 23					inc hl	 
8dc3					 
8dc3 f1					POP AF 
8dc4 c1					POP BC 
8dc5 c9					RET 
8dc6					 
8dc6			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dc6			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8dc6			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dc6			tohex: 
8dc6 e5					PUSH HL 
8dc7 d5					PUSH DE 
8dc8 16 00				LD D, 0 
8dca 5f					LD E, A 
8dcb 21 d3 8d				LD HL, .DATA 
8dce 19					ADD HL, DE 
8dcf 7e					LD A, (HL) 
8dd0 d1					POP DE 
8dd1 e1					POP HL 
8dd2 c9					RET 
8dd3			 
8dd3			.DATA: 
8dd3 30					DEFB	30h	; 0 
8dd4 31					DEFB	31h	; 1 
8dd5 32					DEFB	32h	; 2 
8dd6 33					DEFB	33h	; 3 
8dd7 34					DEFB	34h	; 4 
8dd8 35					DEFB	35h	; 5 
8dd9 36					DEFB	36h	; 6 
8dda 37					DEFB	37h	; 7 
8ddb 38					DEFB	38h	; 8 
8ddc 39					DEFB	39h	; 9 
8ddd 41					DEFB	41h	; A 
8dde 42					DEFB	42h	; B 
8ddf 43					DEFB	43h	; C 
8de0 44					DEFB	44h	; D 
8de1 45					DEFB	45h	; E 
8de2 46					DEFB	46h	; F 
8de3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8de3			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8de3			;;    subtract $30, if result > 9 then subtract $7 more 
8de3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8de3			atohex: 
8de3 d6 30				SUB $30 
8de5 fe 0a				CP 10 
8de7 f8					RET M		; If result negative it was 0-9 so we're done 
8de8 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8dea c9					RET		 
8deb			 
8deb			 
8deb			 
8deb			 
8deb			; Get 2 ASCII characters as hex byte from pointer in hl 
8deb			 
8deb			BYTERD: 
8deb 16 00			LD	D,00h		;Set up 
8ded cd f5 8d			CALL	HEXCON		;Get byte and convert to hex 
8df0 87				ADD	A,A		;First nibble so 
8df1 87				ADD	A,A		;multiply by 16 
8df2 87				ADD	A,A		; 
8df3 87				ADD	A,A		; 
8df4 57				LD	D,A		;Save hi nibble in D 
8df5			HEXCON: 
8df5 7e				ld a, (hl)		;Get next chr 
8df6 23				inc hl 
8df7 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8df9 fe 0a			CP	00Ah		;Is it 0-9 ? 
8dfb 38 02			JR	C,NALPHA	;If so miss next bit 
8dfd d6 07			SUB	007h		;Else convert alpha 
8dff			NALPHA: 
8dff b2				OR	D		;Add hi nibble back 
8e00 c9				RET			; 
8e01			 
8e01			 
8e01			; 
8e01			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8e01			; Since the routines get_byte and therefore get_nibble are called, only valid 
8e01			; characters (0-9a-f) are accepted. 
8e01			; 
8e01			;get_word        push    af 
8e01			;                call    get_byte        ; Get the upper byte 
8e01			;                ld      h, a 
8e01			;                call    get_byte        ; Get the lower byte 
8e01			;                ld      l, a 
8e01			;                pop     af 
8e01			;                ret 
8e01			; 
8e01			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8e01			; the routine get_nibble is used only valid characters are accepted - the  
8e01			; input routine only accepts characters 0-9a-f. 
8e01			; 
8e01 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8e02 7e					ld a,(hl) 
8e03 23					inc hl 
8e04 cd 29 8e		                call    nibble2val      ; Get upper nibble 
8e07 cb 07		                rlc     a 
8e09 cb 07		                rlc     a 
8e0b cb 07		                rlc     a 
8e0d cb 07		                rlc     a 
8e0f 47			                ld      b, a            ; Save upper four bits 
8e10 7e					ld a,(hl) 
8e11 cd 29 8e		                call    nibble2val      ; Get lower nibble 
8e14 b0			                or      b               ; Combine both nibbles 
8e15 c1			                pop     bc              ; Restore B (and C) 
8e16 c9			                ret 
8e17			; 
8e17			; Get a hexadecimal digit from the serial line. This routine blocks until 
8e17			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8e17			; to the serial line interface. The lower 4 bits of A contain the value of  
8e17			; that particular digit. 
8e17			; 
8e17			;get_nibble      ld a,(hl)           ; Read a character 
8e17			;                call    to_upper        ; Convert to upper case 
8e17			;                call    is_hex          ; Was it a hex digit? 
8e17			;                jr      nc, get_nibble  ; No, get another character 
8e17			 ;               call    nibble2val      ; Convert nibble to value 
8e17			 ;               call    print_nibble 
8e17			 ;               ret 
8e17			; 
8e17			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8e17			; A valid hexadecimal digit is denoted by a set C flag. 
8e17			; 
8e17			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8e17			;                ret     nc              ; Yes 
8e17			;                cp      '0'             ; Less than '0'? 
8e17			;                jr      nc, is_hex_1    ; No, continue 
8e17			;                ccf                     ; Complement carry (i.e. clear it) 
8e17			;                ret 
8e17			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8e17			;                ret     c               ; Yes 
8e17			;                cp      'A'             ; Less than 'A'? 
8e17			;                jr      nc, is_hex_2    ; No, continue 
8e17			;                ccf                     ; Yes - clear carry and return 
8e17			;                ret 
8e17			;is_hex_2        scf                     ; Set carry 
8e17			;                ret 
8e17			; 
8e17			; Convert a single character contained in A to upper case: 
8e17			; 
8e17 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8e19 d8			                ret     c 
8e1a fe 7b		                cp      'z' + 1         ; > 'z'? 
8e1c d0			                ret     nc              ; Nothing to do, either 
8e1d e6 5f		                and     $5f             ; Convert to upper case 
8e1f c9			                ret 
8e20			 
8e20			 
8e20			to_lower: 
8e20			 
8e20			   ; if char is in [A-Z] make it lower case 
8e20			 
8e20			   ; enter : a = char 
8e20			   ; exit  : a = lower case char 
8e20			   ; uses  : af 
8e20			 
8e20 fe 41		   cp 'A' 
8e22 d8			   ret c 
8e23			    
8e23 fe 5b		   cp 'Z'+1 
8e25 d0			   ret nc 
8e26			    
8e26 f6 20		   or $20 
8e28 c9			   ret 
8e29			 
8e29			; 
8e29			; Expects a hexadecimal digit (upper case!) in A and returns the 
8e29			; corresponding value in A. 
8e29			; 
8e29 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8e2b 38 02		                jr      c, nibble2val_1 ; Yes 
8e2d d6 07		                sub     7               ; Adjust for A-F 
8e2f d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8e31 e6 0f		                and     $f              ; Only return lower 4 bits 
8e33 c9			                ret 
8e34			; 
8e34			; Print_nibble prints a single hex nibble which is contained in the lower  
8e34			; four bits of A: 
8e34			; 
8e34			;print_nibble    push    af              ; We won't destroy the contents of A 
8e34			;                and     $f              ; Just in case... 
8e34			;                add     a, '0'             ; If we have a digit we are done here. 
8e34			;                cp      '9' + 1         ; Is the result > 9? 
8e34			;                jr      c, print_nibble_1 
8e34			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8e34			;print_nibble_1  call    putc            ; Print the nibble and 
8e34			;                pop     af              ; restore the original value of A 
8e34			;                ret 
8e34			;; 
8e34			;; Send a CR/LF pair: 
8e34			; 
8e34			;crlf            push    af 
8e34			;                ld      a, cr 
8e34			;                call    putc 
8e34			;                ld      a, lf 
8e34			;                call    putc 
8e34			;                pop     af 
8e34			;                ret 
8e34			; 
8e34			; Print_word prints the four hex digits of a word to the serial line. The  
8e34			; word is expected to be in HL. 
8e34			; 
8e34			;print_word      push    hl 
8e34			;                push    af 
8e34			;                ld      a, h 
8e34			;                call    print_byte 
8e34			;                ld      a, l 
8e34			;                call    print_byte 
8e34			;                pop     af 
8e34			;                pop     hl 
8e34			;                ret 
8e34			; 
8e34			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8e34			; The byte to be printed is expected to be in A. 
8e34			; 
8e34			;print_byte      push    af              ; Save the contents of the registers 
8e34			;                push    bc 
8e34			;                ld      b, a 
8e34			;                rrca 
8e34			;                rrca 
8e34			;                rrca 
8e34			;                rrca 
8e34			;                call    print_nibble    ; Print high nibble 
8e34			;                ld      a, b 
8e34			;                call    print_nibble    ; Print low nibble 
8e34			;                pop     bc              ; Restore original register contents 
8e34			;                pop     af 
8e34			;                ret 
8e34			 
8e34			 
8e34			 
8e34			 
8e34			 
8e34			fourehexhl:  
8e34 7e				ld a,(hl) 
8e35 cd e3 8d			call atohex 
8e38 cb 3f				SRL A 
8e3a cb 3f				SRL A 
8e3c cb 3f				SRL A 
8e3e cb 3f				SRL A 
8e40 47				ld b, a 
8e41 23				inc hl 
8e42 7e				ld a,(hl) 
8e43 23				inc hl 
8e44 cd e3 8d			call atohex 
8e47 80				add b 
8e48 57				ld d,a 
8e49 7e				ld a,(hl) 
8e4a cd e3 8d			call atohex 
8e4d cb 3f				SRL A 
8e4f cb 3f				SRL A 
8e51 cb 3f				SRL A 
8e53 cb 3f				SRL A 
8e55 47				ld b, a 
8e56 23				inc hl 
8e57 7e				ld a,(hl) 
8e58 23				inc hl 
8e59 cd e3 8d			call atohex 
8e5c 80				add b 
8e5d 5f				ld e, a 
8e5e d5				push de 
8e5f e1				pop hl 
8e60 c9				ret 
8e61			 
8e61			; pass hl. returns z set if the byte at hl is a digit 
8e61			;isdigithl:  
8e61			;	push bc 
8e61			;	ld a,(hl) 
8e61			;	cp ':' 
8e61			;	jr nc, .isdf 		; > 
8e61			;	cp '0' 
8e61			;	jr c, .isdf		; < 
8e61			; 
8e61			;	; TODO find a better way to set z 
8e61			; 
8e61			;	ld b,a 
8e61			;	cp b 
8e61			;	pop bc 
8e61			;	ret 
8e61			; 
8e61			;.isdf:	; not digit so clear z 
8e61			; 
8e61			;	; TODO find a better way to unset z 
8e61			; 
8e61			;	ld b,a 
8e61			;	inc b 
8e61			;	cp b 
8e61			; 
8e61			;	pop bc 
8e61			;	ret 
8e61				 
8e61				 
8e61			 
8e61			 
8e61			; pass hl as the four byte address to load 
8e61			 
8e61			get_word_hl:  
8e61 e5				push hl 
8e62 cd 01 8e			call get_byte 
8e65				 
8e65 47				ld b, a 
8e66			 
8e66 e1				pop hl 
8e67 23				inc hl 
8e68 23				inc hl 
8e69			 
8e69			; TODO not able to handle a-f  
8e69 7e				ld a,(hl) 
8e6a			;	;cp ':' 
8e6a			;	cp 'g' 
8e6a			;	jr nc, .single_byte_hl 		; > 
8e6a			;	cp 'G' 
8e6a			;	jr nc, .single_byte_hl 		; > 
8e6a			;	cp '0' 
8e6a			;	jr c, .single_byte_hl		; < 
8e6a			 
8e6a				;call isdigithl 
8e6a fe 00			cp 0 
8e6c 28 06			jr z, .single_byte_hl 
8e6e			 
8e6e			.getwhln:   ; hex word so get next byte 
8e6e			 
8e6e cd 01 8e			call get_byte 
8e71 6f				ld l, a 
8e72 60				ld h,b 
8e73 c9				ret 
8e74 68			.single_byte_hl:   ld l,b 
8e75 26 00				ld h,0 
8e77 c9					ret 
8e78			 
8e78			 
8e78			 
8e78			 
8e78 21 c1 95			ld hl,asc+1 
8e7b			;	ld a, (hl) 
8e7b			;	call nibble2val 
8e7b cd 01 8e			call get_byte 
8e7e			 
8e7e			;	call fourehexhl 
8e7e 32 94 e3			ld (scratch+52),a 
8e81				 
8e81 21 92 e3			ld hl,scratch+50 
8e84 22 83 e6			ld (os_cur_ptr),hl 
8e87			 
8e87 c9				ret 
8e88			 
8e88			 
8e88			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8e88			 
8e88			; Decimal Unsigned Version 
8e88			 
8e88			;Number in a to decimal ASCII 
8e88			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8e88			;Example: display a=56 as "056" 
8e88			;input: a = number 
8e88			;Output: a=0,value of a in the screen 
8e88			;destroys af,bc (don't know about hl and de) 
8e88			DispAToASCII: 
8e88 0e 9c			ld	c,-100 
8e8a cd 94 8e			call	.Na1 
8e8d 0e f6			ld	c,-10 
8e8f cd 94 8e			call	.Na1 
8e92 0e ff			ld	c,-1 
8e94 06 2f		.Na1:	ld	b,'0'-1 
8e96 04			.Na2:	inc	b 
8e97 81				add	a,c 
8e98 38 fc			jr	c,.Na2 
8e9a 91				sub	c		;works as add 100/10/1 
8e9b f5				push af		;safer than ld c,a 
8e9c 78				ld	a,b		;char is in b 
8e9d			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8e9d f1				pop af		;safer than ld a,c 
8e9e c9				ret 
8e9f			 
8e9f			; Decimal Signed Version 
8e9f			 
8e9f			; DispA 
8e9f			; -------------------------------------------------------------- 
8e9f			; Converts a signed integer value to a zero-terminated ASCII 
8e9f			; string representative of that value (using radix 10). 
8e9f			; -------------------------------------------------------------- 
8e9f			; INPUTS: 
8e9f			;     HL     Value to convert (two's complement integer). 
8e9f			;     DE     Base address of string destination. (pointer). 
8e9f			; -------------------------------------------------------------- 
8e9f			; OUTPUTS: 
8e9f			;     None 
8e9f			; -------------------------------------------------------------- 
8e9f			; REGISTERS/MEMORY DESTROYED 
8e9f			; AF HL 
8e9f			; -------------------------------------------------------------- 
8e9f			 
8e9f			;DispHLToASCII: 
8e9f			;   push    de 
8e9f			;   push    bc 
8e9f			; 
8e9f			;; Detect sign of HL. 
8e9f			;    bit    7, h 
8e9f			;    jr     z, ._DoConvert 
8e9f			; 
8e9f			;; HL is negative. Output '-' to string and negate HL. 
8e9f			;    ld     a, '-' 
8e9f			;    ld     (de), a 
8e9f			;    inc    de 
8e9f			; 
8e9f			;; Negate HL (using two's complement) 
8e9f			;    xor    a 
8e9f			;    sub    l 
8e9f			;    ld     l, a 
8e9f			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8e9f			;    sbc    a, h 
8e9f			;    ld     h, a 
8e9f			; 
8e9f			;; Convert HL to digit characters 
8e9f			;._DoConvert: 
8e9f			;    ld     b, 0     ; B will count character length of number 
8e9f			;-   ld     a, 10 
8e9f			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8e9f			;    push   af 
8e9f			;    inc    b 
8e9f			;    ld     a, h 
8e9f			;    or     l 
8e9f			;    jr     nz, - 
8e9f			; 
8e9f			;; Retrieve digits from stack 
8e9f			;-   pop    af 
8e9f			;    or     $30 
8e9f			;    ld     (de), a 
8e9f			;    inc    de 
8e9f			;    djnz   - 
8e9f			; 
8e9f			;; Terminate string with NULL 
8e9f			;    xor    a 
8e9f			;    ld     (de), a 
8e9f			; 
8e9f			;    pop    bc 
8e9f			;    pop    de 
8e9f			;    ret 
8e9f			 
8e9f			;Comments 
8e9f			; 
8e9f			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8e9f			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8e9f			;    Note that the output string will not be fixed-width. 
8e9f			; 
8e9f			;Example Usage 
8e9f			; 
8e9f			;    ld    hl, -1004 
8e9f			;    ld    de, OP1 
8e9f			;    call  DispA 
8e9f			;    ld    hl, OP1 
8e9f			;    syscall  PutS 
8e9f			 
8e9f			 
8e9f			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8e9f			 
8e9f			 
8e9f			;Converts an ASCII string to an unsigned 16-bit integer 
8e9f			;Quits when it reaches a non-decimal digit 
8e9f			 
8e9f			string_to_uint16: 
8e9f			atoui_16: 
8e9f			;Input: 
8e9f			;     DE points to the string 
8e9f			;Outputs: 
8e9f			;     HL is the result 
8e9f			;     A is the 8-bit value of the number 
8e9f			;     DE points to the byte after the number 
8e9f			;Destroys: 
8e9f			;     BC 
8e9f			;       if the string is non-empty, BC is HL/10 
8e9f			;Size:  24 bytes 
8e9f			;Speed: 42+d(104+{0,9}) 
8e9f			;       d is the number of digits in the number 
8e9f			;       max is 640 cycles for a 5 digit number 
8e9f			;Assuming no leading zeros: 
8e9f			;1 digit:  146cc 
8e9f			;2 digit:  250cc 
8e9f			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8e9f			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8e9f			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8e9f			;avg: 544.81158447265625cc (544+13297/16384) 
8e9f			;=============================================================== 
8e9f 21 00 00		  ld hl,0 
8ea2			.u16a: 
8ea2 1a			  ld a,(de) 
8ea3 d6 30		  sub 30h 
8ea5 fe 0a		  cp 10 
8ea7 d0			  ret nc 
8ea8 13			  inc de 
8ea9 44			  ld b,h 
8eaa 4d			  ld c,l 
8eab 29			  add hl,hl 
8eac 29			  add hl,hl 
8ead 09			  add hl,bc 
8eae 29			  add hl,hl 
8eaf 85			  add a,l 
8eb0 6f			  ld l,a 
8eb1 30 ef		  jr nc,.u16a 
8eb3 24			  inc h 
8eb4 c3 a2 8e		  jp .u16a 
8eb7			 
8eb7			 
8eb7			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8eb7			 
8eb7			;written by Zeda 
8eb7			;Converts a 16-bit unsigned integer to an ASCII string. 
8eb7			 
8eb7			uitoa_16: 
8eb7			;Input: 
8eb7			;   DE is the number to convert 
8eb7			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8eb7			;Output: 
8eb7			;   HL points to the null-terminated ASCII string 
8eb7			;      NOTE: This isn't necessarily the same as the input HL. 
8eb7 d5			  push de 
8eb8 c5			  push bc 
8eb9 f5			  push af 
8eba eb			  ex de,hl 
8ebb			 
8ebb 01 f0 d8		  ld bc,-10000 
8ebe 3e 2f		  ld a,'0'-1 
8ec0 3c			  inc a 
8ec1 09			  add hl,bc  
8ec2 38 fc		   jr c,$-2 
8ec4 12			  ld (de),a 
8ec5 13			  inc de 
8ec6			 
8ec6 01 e8 03		  ld bc,1000 
8ec9 3e 3a		  ld a,'9'+1 
8ecb 3d			  dec a  
8ecc 09			  add hl,bc  
8ecd 30 fc		   jr nc,$-2 
8ecf 12			  ld (de),a 
8ed0 13			  inc de 
8ed1			 
8ed1 01 9c ff		  ld bc,-100 
8ed4 3e 2f		  ld a,'0'-1 
8ed6 3c			  inc a  
8ed7 09			  add hl,bc  
8ed8 38 fc		   jr c,$-2 
8eda 12			  ld (de),a 
8edb 13			  inc de 
8edc			 
8edc 7d			  ld a,l 
8edd 26 3a		  ld h,'9'+1 
8edf 25			  dec h  
8ee0 c6 0a		  add a,10  
8ee2 30 fb		   jr nc,$-3 
8ee4 c6 30		  add a,'0' 
8ee6 eb			  ex de,hl 
8ee7 72			  ld (hl),d 
8ee8 23			  inc hl 
8ee9 77			  ld (hl),a 
8eea 23			  inc hl 
8eeb 36 00		  ld (hl),0 
8eed			 
8eed			;Now strip the leading zeros 
8eed 0e fa		  ld c,-6 
8eef 09			  add hl,bc 
8ef0 3e 30		  ld a,'0' 
8ef2 23			  inc hl  
8ef3 be			  cp (hl)  
8ef4 28 fc		  jr z,$-2 
8ef6			 
8ef6			;Make sure that the string is non-empty! 
8ef6 7e			  ld a,(hl) 
8ef7 b7			  or a 
8ef8 20 01		  jr nz,.atoub 
8efa 2b			  dec hl 
8efb			.atoub: 
8efb			 
8efb f1			  pop af 
8efc c1			  pop bc 
8efd d1			  pop de 
8efe c9			  ret 
8eff			 
8eff			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
8eff			 
8eff			toUpper: 
8eff			;A is the char. 
8eff			;If A is a lowercase letter, this sets it to the matching uppercase 
8eff			;18cc or 30cc or 41cc 
8eff			;avg: 26.75cc 
8eff fe 61		  cp 'a' 
8f01 d8			  ret c 
8f02 fe 7b		  cp 'z'+1 
8f04 d0			  ret nc 
8f05 d6 20		  sub 'a'-'A' 
8f07 c9			  ret 
8f08			 
8f08			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
8f08			 
8f08			; String Length 
8f08			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
8f08			 
8f08			; Get the length of the null-terminated string starting at $8000 hl 
8f08			;    LD     HL, $8000 
8f08			 
8f08			strlenz: 
8f08			 
8f08 af			    XOR    A               ; Zero is the value we are looking for. 
8f09 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
8f0a 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
8f0b			                           ; 65, 536 bytes (the entire addressable memory space). 
8f0b ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8f0d			 
8f0d			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8f0d 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
8f0e 6f			    LD     L, A             ; number of bytes 
8f0f ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8f11 2b			    DEC    HL              ; Compensate for null. 
8f12 c9				ret 
8f13			 
8f13			; Get the length of the A terminated string starting at $8000 hl 
8f13			;    LD     HL, $8000 
8f13			 
8f13			strlent: 
8f13			 
8f13			                  ; A is the value we are looking for. 
8f13 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
8f15 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
8f17			                           ; 65, 536 bytes (the entire addressable memory space). 
8f17 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8f19			 
8f19			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8f19 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
8f1b 2e 00		    LD     L, 0             ; number of bytes 
8f1d ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8f1f 2b			    DEC    HL              ; Compensate for null. 
8f20 c9				ret 
8f21			 
8f21			 
8f21			;Comparing Strings 
8f21			 
8f21			;IN    HL     Address of string1. 
8f21			;      DE     Address of string2. 
8f21			 
8f21			; doc given but wrong??? 
8f21			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
8f21			;      carry  Set if string1 > string2, reset if string1 <= string2. 
8f21			; tested 
8f21			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
8f21			 
8f21			strcmp_old: 
8f21 e5			    PUSH   HL 
8f22 d5			    PUSH   DE 
8f23			 
8f23 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
8f24 be			    CP     (HL)            ; (want to minimize work). 
8f25 38 01		    JR     C, Str1IsBigger 
8f27 7e			    LD     A, (HL) 
8f28			 
8f28			Str1IsBigger: 
8f28 4f			    LD     C, A             ; Put length in BC 
8f29 06 00		    LD     B, 0 
8f2b 13			    INC    DE              ; Increment pointers to meat of string. 
8f2c 23			    INC    HL 
8f2d			 
8f2d			CmpLoop: 
8f2d 1a			    LD     A, (DE)          ; Compare bytes. 
8f2e ed a1		    CPI 
8f30 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
8f32 13			    INC    DE              ; Update pointer. 
8f33 ea 2d 8f		    JP     PE, CmpLoop 
8f36			 
8f36 d1			    POP    DE 
8f37 e1			    POP    HL 
8f38 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
8f39 be			    CP     (HL) 
8f3a c9			    RET 
8f3b			 
8f3b			NoMatch: 
8f3b 2b			    DEC    HL 
8f3c be			    CP     (HL)            ; Compare again to affect carry. 
8f3d d1			    POP    DE 
8f3e e1			    POP    HL 
8f3f c9			    RET 
8f40			 
8f40			;; test strmp 
8f40			; 
8f40			;ld de, .str1 
8f40			;ld hl, .str2 
8f40			;call strcmp 
8f40			;jr z, .z1 
8f40			;;this 
8f40			;	if DEBUG_FORTH_WORDS 
8f40			;		DMARK "NZ1" 
8f40			;		CALLMONITOR 
8f40			;	endif 
8f40			;.z1: 
8f40			; 
8f40			;	if DEBUG_FORTH_WORDS 
8f40			;		DMARK "ZZ1" 
8f40			;		CALLMONITOR 
8f40			;	endif 
8f40			; 
8f40			;ld de, .str1 
8f40			;ld hl, .str1 
8f40			;call strcmp 
8f40			;jr z, .z2 
8f40			;;this 
8f40			;	if DEBUG_FORTH_WORDS 
8f40			;		DMARK "NZ2" 
8f40			;		CALLMONITOR 
8f40			;	endif 
8f40			;.z2: 
8f40			; 
8f40			;	if DEBUG_FORTH_WORDS 
8f40			;		DMARK "ZZ2" 
8f40			;		CALLMONITOR 
8f40			;	endif 
8f40			; 
8f40			;ld de, .str1 
8f40			;ld hl, .str2 
8f40			;call strcmp 
8f40			;jr c, .c1 
8f40			; 
8f40			;	if DEBUG_FORTH_WORDS 
8f40			;		DMARK "Nc1" 
8f40			;		CALLMONITOR 
8f40			;	endif 
8f40			;.c1: 
8f40			;;this 
8f40			;	if DEBUG_FORTH_WORDS 
8f40			;		DMARK "cc1" 
8f40			;		CALLMONITOR 
8f40			;	endif 
8f40			; 
8f40			;ld de, .str1 
8f40			;ld hl, .str1 
8f40			;call strcmp 
8f40			;jr c, .c2 
8f40			;;this 
8f40			;	if DEBUG_FORTH_WORDS 
8f40			;		DMARK "Nc2" 
8f40			;		CALLMONITOR 
8f40			;	endif 
8f40			;.c2: 
8f40			; 
8f40			;	if DEBUG_FORTH_WORDS 
8f40			;		DMARK "cc2" 
8f40			;		CALLMONITOR 
8f40			;	endif 
8f40			;	NEXTW 
8f40			;.str1:   db "string1",0 
8f40			;.str2:   db "string2",0 
8f40			 
8f40			; only care about direct match or not 
8f40			; hl and de strings 
8f40			; zero set if the same 
8f40			 
8f40			strcmp: 
8f40 1a				ld a, (de) 
8f41 be				cp (hl) 
8f42 28 02			jr z, .ssame 
8f44 b7				or a 
8f45 c9				ret 
8f46			 
8f46			.ssame:  
8f46 fe 00			cp 0 
8f48 c8				ret z 
8f49			 
8f49 23				inc hl 
8f4a 13				inc de 
8f4b 18 f3			jr strcmp 
8f4d				 
8f4d				 
8f4d			 
8f4d			 
8f4d			 
8f4d			 
8f4d			; eof 
8f4d			 
8f4d			 
8f4d			 
8f4d			 
8f4d			 
8f4d			 
# End of file firmware_strings.asm
8f4d			include "firmware_memory.asm"   ; malloc and free  
8f4d			 
8f4d			if DEBUG_FORTH_MALLOC_HIGH 
8f4d			.mallocsize: db "Wants malloc >256",0 
8f4d			.mallocasize: db "MALLOC gives >256",0 
8f4d			.malloczero: db "MALLOC gives zero",0 
8f4d			 
8f4d			malloc_guard_zerolen: 
8f4d				push hl 
8f4d				push de 
8f4d				push af 
8f4d			 
8f4d				ld de, 0 
8f4d			        call cmp16 
8f4d				jr nz, .lowalloz 
8f4d			 
8f4d				push hl 
8f4d				push de 
8f4d					ld hl, display_fb0 
8f4d					ld (display_fb_active), hl 
8f4d				call clear_display 
8f4d				ld a, 0 
8f4d				ld de, .malloczero 
8f4d				call str_at_display 
8f4d				call update_display 
8f4d				call delay1s 
8f4d				call delay1s 
8f4d				ld a, 0 
8f4d				ld (os_view_disable), a 
8f4d			 
8f4d				pop de 
8f4d				pop hl 
8f4d			 
8f4d				 
8f4d			 
8f4d				CALLMONITOR 
8f4d			.lowalloz: 
8f4d			 
8f4d			 
8f4d				pop af 
8f4d				pop de 
8f4d				pop hl 
8f4d			ret 
8f4d			 
8f4d			malloc_guard_entry: 
8f4d				push hl 
8f4d				push de 
8f4d				push af 
8f4d			 
8f4d			 	or a      ;clear carry flag 
8f4d				push hl 
8f4d				ld de, 255 
8f4d				sbc hl, de 
8f4d				jr c, .lowalloc 
8f4d			 
8f4d				push de 
8f4d					ld hl, display_fb0 
8f4d					ld (display_fb_active), hl 
8f4d				call clear_display 
8f4d				ld a, 0 
8f4d				ld de, .mallocsize 
8f4d				call str_at_display 
8f4d				call update_display 
8f4d				call delay1s 
8f4d				call delay1s 
8f4d				ld a, 0 
8f4d				ld (os_view_disable), a 
8f4d			 
8f4d				pop de 
8f4d				pop hl 
8f4d			 
8f4d				 
8f4d			 
8f4d				CALLMONITOR 
8f4d				jr .lowdone 
8f4d			.lowalloc: 
8f4d			 
8f4d			 
8f4d				pop hl 
8f4d			.lowdone:	pop af 
8f4d				pop de 
8f4d				pop hl 
8f4d			ret 
8f4d			 
8f4d			malloc_guard_exit: 
8f4d				push hl 
8f4d				push de 
8f4d				push af 
8f4d			 
8f4d			 	or a      ;clear carry flag 
8f4d				push hl 
8f4d				ld de, 255 
8f4d				sbc hl, de 
8f4d				jr c, .lowallocx 
8f4d			 
8f4d				push de 
8f4d					ld hl, display_fb0 
8f4d					ld (display_fb_active), hl 
8f4d				call clear_display 
8f4d				ld a, 0 
8f4d				ld de, .mallocasize 
8f4d				call str_at_display 
8f4d				call update_display 
8f4d				call delay1s 
8f4d				call delay1s 
8f4d				ld a, 0 
8f4d				ld (os_view_disable), a 
8f4d				pop de 
8f4d				pop hl 
8f4d			 
8f4d				CALLMONITOR 
8f4d				jr .lowdonex 
8f4d			.lowallocx: 
8f4d			 
8f4d				pop hl 
8f4d			.lowdonex:	pop af 
8f4d				pop de 
8f4d				pop hl 
8f4d			ret 
8f4d			endif 
8f4d			 
8f4d			if MALLOC_2 
8f4d			; Z80 Malloc and Free Functions 
8f4d			 
8f4d			; Malloc Function: 
8f4d			; Input: 
8f4d			;   HL: Size of block to allocate 
8f4d			; Output: 
8f4d			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f4d			 
8f4d			malloc: 
8f4d				 
8f4d			if DEBUG_FORTH_MALLOC_HIGH 
8f4d			call malloc_guard_entry 
8f4d			endif 
8f4d			 
8f4d			 
8f4d			 
8f4d			 
8f4d					if DEBUG_FORTH_MALLOC 
8f4d						DMARK "mal" 
8f4d						CALLMONITOR 
8f4d					endif 
8f4d			    push af            ; Save AF register 
8f4d			    ld a, l            ; Load low byte of size into A 
8f4d			    or h               ; Check if size is zero 
8f4d			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
8f4d			 
8f4d			    ; Allocate memory 
8f4d			    ld hl, (heap_start) ; Load start of heap into HL 
8f4d					if DEBUG_FORTH_MALLOC 
8f4d						DMARK "ma1" 
8f4d						CALLMONITOR 
8f4d					endif 
8f4d			    call malloc_internal ; Call internal malloc function 
8f4d			    pop af             ; Restore AF register 
8f4d			if DEBUG_FORTH_MALLOC_HIGH 
8f4d			call malloc_guard_exit 
8f4d			call malloc_guard_zerolen 
8f4d			endif 
8f4d			    ret                ; Return 
8f4d			 
8f4d			; Free Function: 
8f4d			; Input: 
8f4d			;   HL: Pointer to memory block to free 
8f4d			; Output: 
8f4d			;   None 
8f4d			 
8f4d			free: 
8f4d			    push af            ; Save AF register 
8f4d			    ld a, l            ; Load low byte of pointer into A 
8f4d			    or h               ; Check if pointer is NULL 
8f4d			    jp z, free_exit    ; If pointer is NULL, exit 
8f4d			 
8f4d			    ; Free memory 
8f4d			    ld hl, (heap_start) ; Load start of heap into HL 
8f4d			    call free_internal  ; Call internal free function 
8f4d			    pop af             ; Restore AF register 
8f4d			    ret                ; Return 
8f4d			 
8f4d			; Internal Malloc Function: 
8f4d			; Input: 
8f4d			;   HL: Size of block to allocate 
8f4d			; Output: 
8f4d			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f4d			 
8f4d			malloc_internal: 
8f4d			    ld bc, 2           ; Number of bytes to allocate for management overhead 
8f4d			    add hl, bc         ; Add management overhead to requested size 
8f4d			    ex de, hl          ; Save total size in DE, and keep it in HL 
8f4d					if DEBUG_FORTH_MALLOC 
8f4d						DMARK "ma2" 
8f4d						CALLMONITOR 
8f4d					endif 
8f4d			 
8f4d			    ; Search for free memory block 
8f4d			    ld de, (heap_end)  ; Load end of heap into DE 
8f4d			    ld bc, 0           ; Initialize counter 
8f4d			 
8f4d					if DEBUG_FORTH_MALLOC 
8f4d						DMARK "ma2" 
8f4d						CALLMONITOR 
8f4d					endif 
8f4d			malloc_search_loop: 
8f4d			    ; Check if current block is free 
8f4d			    ld a, (hl)         ; Load current block's status (free or used) 
8f4d			    cp 0               ; Compare with zero (free) 
8f4d			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
8f4d			 
8f4d			    ; Check if current block is large enough 
8f4d			    ld a, (hl+1)       ; Load high byte of block size 
8f4d			    cp l               ; Compare with low byte of requested size 
8f4d			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
8f4d			 
8f4d			    ld a, (hl+2)       ; Load low byte of block size 
8f4d			    cp h               ; Compare with high byte of requested size 
8f4d			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
8f4d			 
8f4d			    ; Mark block as used 
8f4d			    ld (hl), 0xFF      ; Set status byte to indicate used block 
8f4d			 
8f4d			    ; Calculate remaining space in block 
8f4d			    ld bc, 0           ; Clear BC 
8f4d			    add hl, bc         ; Increment HL to point to start of data block 
8f4d			    add hl, de         ; HL = HL + DE (total size) 
8f4d			    ld bc, 1           ; Number of bytes to allocate for management overhead 
8f4d			    add hl, bc         ; Add management overhead to start of data block 
8f4d			 
8f4d			    ; Save pointer to allocated block in HL 
8f4d			if DEBUG_FORTH_MALLOC_HIGH 
8f4d						DMARK "ma5" 
8f4d			call malloc_guard_exit 
8f4d			call malloc_guard_zerolen 
8f4d			endif 
8f4d			    ret 
8f4d			 
8f4d			malloc_skip_block_check: 
8f4d			    ; Move to the next block 
8f4d			    ld bc, 3           ; Size of management overhead 
8f4d			    add hl, bc         ; Move to the next block 
8f4d			    inc de             ; Increment counter 
8f4d			 
8f4d			    ; Check if we have reached the end of heap 
8f4d			    ld a, e            ; Load low byte of heap end address 
8f4d			    cp (hl)            ; Compare with low byte of current address 
8f4d			    jr nz, malloc_search_loop  ; If not equal, continue searching 
8f4d			    ld a, d            ; Load high byte of heap end address 
8f4d			    cp 0               ; Check if it's zero (end of memory) 
8f4d			    jr nz, malloc_search_loop  ; If not zero, continue searching 
8f4d			 
8f4d			    ; If we reached here, allocation failed 
8f4d			    xor a              ; Set result to NULL 
8f4d			if DEBUG_FORTH_MALLOC_HIGH 
8f4d						DMARK "ma6" 
8f4d			call malloc_guard_exit 
8f4d			call malloc_guard_zerolen 
8f4d			endif 
8f4d			    ret 
8f4d			malloc_exit: 
8f4d			if DEBUG_FORTH_MALLOC_HIGH 
8f4d						DMARK "ma7" 
8f4d			call malloc_guard_exit 
8f4d			call malloc_guard_zerolen 
8f4d			endif 
8f4d			    ret 
8f4d			 
8f4d			; Internal Free Function: 
8f4d			; Input: 
8f4d			;   HL: Pointer to memory block to free 
8f4d			; Output: 
8f4d			;   None 
8f4d			 
8f4d			free_internal: 
8f4d			    ld de, (heap_start) ; Load start of heap into DE 
8f4d			    ld bc, 0            ; Initialize counter 
8f4d			 
8f4d			free_search_loop: 
8f4d			    ; Check if current block contains the pointer 
8f4d			    ld a, l             ; Load low byte of pointer 
8f4d			    cp (hl+1)           ; Compare with high byte of current block's address 
8f4d			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f4d			    ld a, h             ; Load high byte of pointer 
8f4d			    cp (hl+2)           ; Compare with low byte of current block's address 
8f4d			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f4d			 
8f4d			    ; Mark block as free 
8f4d			    ld (hl), 0          ; Set status byte to indicate free block 
8f4d			    ret                 ; Return 
8f4d			 
8f4d			free_skip_block_check: 
8f4d			    ; Move to the next block 
8f4d			    ld bc, 3            ; Size of management overhead 
8f4d			    add hl, bc          ; Move to the next block 
8f4d			    inc de              ; Increment counter 
8f4d			 
8f4d			    ; Check if we have reached the end of heap 
8f4d			    ld a, e             ; Load low byte of heap end address 
8f4d			    cp (hl)             ; Compare with low byte of current address 
8f4d			    jr nz, free_search_loop  ; If not equal, continue searching 
8f4d			    ld a, d             ; Load high byte of heap end address 
8f4d			    cp 0                ; Check if it's zero (end of memory) 
8f4d			    jr nz, free_search_loop  ; If not zero, continue searching 
8f4d			 
8f4d			    ; If we reached here, pointer is not found in heap 
8f4d			    ret 
8f4d			 
8f4d			free_exit: 
8f4d			    ret                 ; Return 
8f4d			 
8f4d			; Define heap start and end addresses 
8f4d			;heap_start:    .dw 0xC000   ; Start of heap 
8f4d			;heap_end:      .dw 0xE000   ; End of heap 
8f4d			 
8f4d			endif 
8f4d			 
8f4d			 
8f4d			if MALLOC_1 
8f4d			 
8f4d			 
8f4d			 
8f4d			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
8f4d			 
8f4d			;moved to firmware.asm 
8f4d			;heap_start        .equ  0x9000      ; Starting address of heap 
8f4d			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
8f4d			 
8f4d			;      .org 0 
8f4d			;      jp    main 
8f4d			 
8f4d			 
8f4d			;      .org  0x100 
8f4d			;main: 
8f4d			;      ld    HL, 0x8100 
8f4d			;      ld    SP, HL 
8f4d			; 
8f4d			;      call  heap_init 
8f4d			; 
8f4d			;      ; Make some allocations 
8f4d			;      ld    HL, 12 
8f4d			;      call  malloc            ; Allocates 0x9004 
8f4d			; 
8f4d			;      ld    HL, 12 
8f4d			;      call  malloc            ; Allocates 0x9014 
8f4d			; 
8f4d			;      ld    HL, 12 
8f4d			;      call  malloc            ; Allocates 0x9024 
8f4d			; 
8f4d			;      ; Free some allocations 
8f4d			;      ld    HL, 0x9014 
8f4d			;      call  free 
8f4d			; 
8f4d			;      ld    HL, 0x9004 
8f4d			;      call  free 
8f4d			; 
8f4d			;      ld    HL, 0x9024 
8f4d			;      call  free 
8f4d			; 
8f4d			; 
8f4d			;      halt 
8f4d			 
8f4d			 
8f4d			;------------------------------------------------------------------------------ 
8f4d			;     heap_init                                                               : 
8f4d			;                                                                             : 
8f4d			; Description                                                                 : 
8f4d			;     Initialise the heap and make it ready for malloc and free operations.   : 
8f4d			;                                                                             : 
8f4d			;     The heap is maintained as a linked list, starting with an initial       : 
8f4d			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
8f4d			;     the first free block in the heap. Each block then points to the next    : 
8f4d			;     free block within the heap, and the free list ends at the first block   : 
8f4d			;     with a null pointer to the next free block.                             : 
8f4d			;                                                                             : 
8f4d			; Parameters                                                                  : 
8f4d			;     Inputs are compile-time only. Two defines which specify the starting    : 
8f4d			;     address of the heap and its size are required, along with a memory      : 
8f4d			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
8f4d			;     principally stores a pointer to the first free block in the heap.       : 
8f4d			;                                                                             : 
8f4d			; Returns                                                                     : 
8f4d			;     Nothing                                                                 : 
8f4d			;------------------------------------------------------------------------------ 
8f4d			heap_init: 
8f4d e5			      push  HL 
8f4e			 
8f4e			      ; Initialise free list struct 
8f4e 21 57 d7		      ld    HL, heap_start 
8f51 22 52 d7		      ld    (free_list), HL 
8f54 21 00 00		      ld    HL, 0 
8f57 22 54 d7		      ld    (free_list+2), HL 
8f5a			 
8f5a			      ; Insert first free block at bottom of heap, consumes entire heap 
8f5a 21 42 e3		      ld    HL, heap_start+heap_size-4 
8f5d 22 57 d7		      ld    (heap_start), HL        ; Next block (end of free list) 
8f60 21 eb 0b		      ld    HL, heap_size-4 
8f63 22 59 d7		      ld    (heap_start+2), HL      ; Block size 
8f66			 
8f66			      ; Insert end of free list block at top of heap - two null words will 
8f66			      ; terminate the free list 
8f66 21 00 00		      ld    HL, 0 
8f69 22 44 e3		      ld    (heap_start+heap_size-2), HL 
8f6c 22 42 e3		      ld    (heap_start+heap_size-4), HL 
8f6f			 
8f6f e1			      pop   HL 
8f70			 
8f70 c9			      ret 
8f71			 
8f71			 
8f71			;------------------------------------------------------------------------------ 
8f71			;     malloc                                                                  : 
8f71			;                                                                             : 
8f71			; Description                                                                 : 
8f71			;     Allocates the wanted space from the heap and returns the address of the : 
8f71			;     first useable byte of the allocation.                                   : 
8f71			;                                                                             : 
8f71			;     Allocations can happen in one of two ways:                              : 
8f71			;                                                                             : 
8f71			;     1. A free block may be found which is the exact size wanted. In this    : 
8f71			;        case the block is removed from the free list and retuedn to the      : 
8f71			;        caller.                                                              : 
8f71			;     2. A free block may be found which is larger than the size wanted. In   : 
8f71			;        this case, the larger block is split into two. The first portion of  : 
8f71			;        this block will become the requested space by the malloc call and    : 
8f71			;        is returned to the caller. The second portion becomes a new free     : 
8f71			;        block, and the free list is adjusted to maintain continuity via this : 
8f71			;        newly created block.                                                 : 
8f71			;                                                                             : 
8f71			;     malloc does not set any initial value in the allocated space, the       : 
8f71			;     caller is required to do this as required.                              : 
8f71			;                                                                             : 
8f71			;     This implementation of malloc uses the stack exclusively, and is        : 
8f71			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8f71			;     advisable to disable interrupts before calling malloc, and recommended  : 
8f71			;     to avoid the use of malloc inside ISRs in general.                      : 
8f71			;                                                                             : 
8f71			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8f71			;                                                                             : 
8f71			; Parameters                                                                  : 
8f71			;     HL  Number of bytes wanted                                              : 
8f71			;                                                                             : 
8f71			; Returns                                                                     : 
8f71			;     HL  Address of the first useable byte of the allocation                 : 
8f71			;                                                                             : 
8f71			; Flags                                                                       : 
8f71			;     Z   Set if the allocation did not succeed, clear otherwise              : 
8f71			;                                                                             : 
8f71			; Stack frame                                                                 : 
8f71			;       |             |                                                       : 
8f71			;       +-------------+                                                       : 
8f71			;       |     BC      |                                                       : 
8f71			;       +-------------+                                                       : 
8f71			;       |     DE      |                                                       : 
8f71			;       +-------------+                                                       : 
8f71			;       |     IX      |                                                       : 
8f71			;       +-------------+                                                       : 
8f71			;       |  prev_free  |                                                       : 
8f71			;   +4  +-------------+                                                       : 
8f71			;       |  this_free  |                                                       : 
8f71			;   +2  +-------------+                                                       : 
8f71			;       |  next_free  |                                                       : 
8f71			;   +0  +-------------+                                                       : 
8f71			;       |             |                                                       : 
8f71			;                                                                             : 
8f71			;------------------------------------------------------------------------------ 
8f71			 
8f71			 
8f71			;malloc: 
8f71			; 
8f71			;	SAVESP ON 1 
8f71			; 
8f71			;	call malloc_code 
8f71			; 
8f71			;	CHECKSP ON 1 
8f71			;	ret 
8f71			 
8f71			 
8f71			malloc: 
8f71 c5			      push  BC 
8f72 d5			      push  DE 
8f73 dd e5		      push  IX 
8f75			if DEBUG_FORTH_MALLOC_HIGH 
8f75			call malloc_guard_entry 
8f75			endif 
8f75			 
8f75					if DEBUG_FORTH_MALLOC 
8f75						DMARK "mal" 
8f75						CALLMONITOR 
8f75					endif 
8f75 7c			      ld    A, H                    ; Exit if no space requested 
8f76 b5			      or    L 
8f77 ca 36 90		      jp    Z, malloc_early_exit 
8f7a			 
8f7a			;inc hl 
8f7a			;inc hl 
8f7a			;inc hl 
8f7a			; 
8f7a			;inc hl 
8f7a			;inc hl 
8f7a			;inc hl 
8f7a			;inc hl 
8f7a			;inc hl 
8f7a			;inc hl 
8f7a			;inc hl 
8f7a			;inc hl 
8f7a			;inc hl 
8f7a			 
8f7a			 
8f7a			 
8f7a			 
8f7a					if DEBUG_FORTH_MALLOC 
8f7a						DMARK "maA" 
8f7a						CALLMONITOR 
8f7a					endif 
8f7a			      ; Set up stack frame 
8f7a eb			      ex    DE, HL 
8f7b 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
8f7e 39			      add   HL, SP 
8f7f f9			      ld    SP, HL 
8f80 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
8f84 dd 39		      add   IX, SP 
8f86			 
8f86			      ; Setup initial state 
8f86 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
8f89 19			      add   HL, DE 
8f8a			 
8f8a 44			      ld    B, H                    ; Move want to BC 
8f8b 4d			      ld    C, L 
8f8c			 
8f8c 21 52 d7		      ld    HL, free_list           ; Store prev_free ptr to stack 
8f8f dd 75 04		      ld    (IX+4), L 
8f92 dd 74 05		      ld    (IX+5), H 
8f95			 
8f95 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
8f96 23			      inc   HL 
8f97 56			      ld    D, (HL) 
8f98 dd 73 02		      ld    (IX+2), E 
8f9b dd 72 03		      ld    (IX+3), D 
8f9e eb			      ex    DE, HL                  ; this_free ptr into HL 
8f9f			 
8f9f					if DEBUG_FORTH_MALLOC 
8f9f						DMARK "maB" 
8f9f						CALLMONITOR 
8f9f					endif 
8f9f			      ; Loop through free block list to find some space 
8f9f			malloc_find_space: 
8f9f 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
8fa0 23			      inc   HL 
8fa1 56			      ld    D, (HL) 
8fa2			 
8fa2 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
8fa3 b3			      or    E 
8fa4 ca 30 90		      jp    Z, malloc_no_space 
8fa7			 
8fa7 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
8faa dd 72 01		      ld    (IX+1), D 
8fad			 
8fad			      ; Does this block have enough space to make the allocation? 
8fad 23			      inc   HL                      ; Load free block size into DE 
8fae 5e			      ld    E, (HL) 
8faf 23			      inc   HL 
8fb0 56			      ld    D, (HL) 
8fb1			 
8fb1 eb			      ex    DE, HL                  ; Check size of block against want 
8fb2 b7			      or    A                       ; Ensure carry flag clear 
8fb3 ed 42		      sbc   HL, BC 
8fb5 e5			      push  HL                      ; Store the result for later (new block size) 
8fb6			 
8fb6 ca 05 90		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
8fb9 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
8fbb			 
8fbb			      ; this_free block is not big enough, setup ptrs to test next free block 
8fbb e1			      pop   HL                      ; Discard previous result 
8fbc			 
8fbc dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
8fbf dd 66 03		      ld    H, (IX+3) 
8fc2 dd 75 04		      ld    (IX+4), L 
8fc5 dd 74 05		      ld    (IX+5), H 
8fc8			 
8fc8 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
8fcb dd 66 01		      ld    H, (IX+1) 
8fce dd 75 02		      ld    (IX+2), L 
8fd1 dd 74 03		      ld    (IX+3), H 
8fd4			 
8fd4					if DEBUG_FORTH_MALLOC 
8fd4						DMARK "MA>" 
8fd4						CALLMONITOR 
8fd4					endif 
8fd4 18 c9		      jr    malloc_find_space 
8fd6			 
8fd6			      ; split a bigger block into two - requested size and remaining size 
8fd6			malloc_alloc_split: 
8fd6					if DEBUG_FORTH_MALLOC 
8fd6						DMARK "MAs" 
8fd6						CALLMONITOR 
8fd6					endif 
8fd6 eb			      ex    DE, HL                  ; Calculate address of new free block 
8fd7 2b			      dec   HL 
8fd8 2b			      dec   HL 
8fd9 2b			      dec   HL 
8fda 09			      add   HL, BC 
8fdb			 
8fdb			      ; Create a new block and point it at next_free 
8fdb dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
8fde dd 56 01		      ld    D, (IX+1) 
8fe1			 
8fe1 73			      ld    (HL), E                 ; Store next_free ptr into new block 
8fe2 23			      inc   HL 
8fe3 72			      ld    (HL), D 
8fe4			 
8fe4 d1			      pop   DE                      ; Store size of new block into new block 
8fe5 23			      inc   HL 
8fe6 73			      ld    (HL), E 
8fe7 23			      inc   HL 
8fe8 72			      ld    (HL), D 
8fe9			 
8fe9			      ; Update this_free ptr to point to new block 
8fe9 2b			      dec   HL 
8fea 2b			      dec   HL 
8feb 2b			      dec   HL 
8fec			 
8fec dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
8fef dd 56 03		      ld    D, (IX+3) 
8ff2			 
8ff2 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
8ff5 dd 74 03		      ld    (IX+3), H 
8ff8			 
8ff8			      ; Modify this_free block to be allocation 
8ff8 eb			      ex    DE, HL 
8ff9 af			      xor   A                       ; Null the next block ptr of allocated block 
8ffa 77			      ld    (HL), A 
8ffb 23			      inc   HL 
8ffc 77			      ld    (HL), A 
8ffd			 
8ffd 23			      inc   HL                      ; Store want size into allocated block 
8ffe 71			      ld    (HL), C 
8fff 23			      inc   HL 
9000 70			      ld    (HL), B 
9001 23			      inc   HL 
9002 e5			      push  HL                      ; Address of allocation to return 
9003			 
9003 18 19		      jr    malloc_update_links 
9005			 
9005			malloc_alloc_fit: 
9005 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9006			 
9006					if DEBUG_FORTH_MALLOC 
9006						DMARK "MAf" 
9006						CALLMONITOR 
9006					endif 
9006			      ; Modify this_free block to be allocation 
9006 eb			      ex    DE, HL 
9007 2b			      dec   HL 
9008 2b			      dec   HL 
9009 2b			      dec   HL 
900a			 
900a af			      xor   A                       ; Null the next block ptr of allocated block 
900b 77			      ld    (HL), A 
900c 23			      inc   HL 
900d 77			      ld    (HL), A 
900e			 
900e 23			      inc   HL                      ; Store address of allocation to return 
900f 23			      inc   HL 
9010 23			      inc   HL 
9011 e5			      push  HL 
9012			 
9012			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9012 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9015 dd 66 01		      ld    H, (IX+1) 
9018			 
9018 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
901b dd 74 03		      ld    (IX+3), H 
901e			 
901e			 
901e			malloc_update_links: 
901e			      ; Update prev_free ptr to point to this_free 
901e dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9021 dd 66 05		      ld    H, (IX+5) 
9024			 
9024 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9027 dd 56 03		      ld    D, (IX+3) 
902a			 
902a 73			      ld    (HL), E                 ; this_free ptr into prev_free 
902b 23			      inc   HL 
902c 72			      ld    (HL), D 
902d			 
902d					if DEBUG_FORTH_MALLOC 
902d						DMARK "Mul" 
902d						CALLMONITOR 
902d					endif 
902d			      ; Clear the Z flag to indicate successful allocation 
902d 7a			      ld    A, D 
902e b3			      or    E 
902f			 
902f d1			      pop   DE                      ; Address of allocation 
9030					if DEBUG_FORTH_MALLOC 
9030						DMARK "MAu" 
9030						CALLMONITOR 
9030					endif 
9030			 
9030			malloc_no_space: 
9030 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9033 39			      add   HL, SP 
9034 f9			      ld    SP, HL 
9035			 
9035 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9036					if DEBUG_FORTH_MALLOC 
9036						DMARK "MAN" 
9036						CALLMONITOR 
9036					endif 
9036			 
9036			malloc_early_exit: 
9036					if DEBUG_FORTH_MALLOC 
9036						DMARK "MAx" 
9036						CALLMONITOR 
9036					endif 
9036 dd e1		      pop   IX 
9038 d1			      pop   DE 
9039 c1			      pop   BC 
903a			 
903a			if DEBUG_FORTH_MALLOC_HIGH 
903a			call malloc_guard_exit 
903a			call malloc_guard_zerolen 
903a			endif 
903a c9			      ret 
903b			 
903b			 
903b			;------------------------------------------------------------------------------ 
903b			;     free                                                                    : 
903b			;                                                                             : 
903b			; Description                                                                 : 
903b			;     Return the space pointed to by HL to the heap. HL must be an address as : 
903b			;     returned by malloc, otherwise the behaviour is undefined.               : 
903b			;                                                                             : 
903b			;     Where possible, directly adjacent free blocks will be merged together   : 
903b			;     into larger blocks to help ensure that the heap does not become         : 
903b			;     excessively fragmented.                                                 : 
903b			;                                                                             : 
903b			;     free does not clear or set any other value into the freed space, and    : 
903b			;     therefore its contents may be visible through subsequent malloc's. The  : 
903b			;     caller should clear the freed space as required.                        : 
903b			;                                                                             : 
903b			;     This implementation of free uses the stack exclusively, and is          : 
903b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
903b			;     advisable to disable interrupts before calling free, and recommended    : 
903b			;     to avoid the use of free inside ISRs in general.                        : 
903b			;                                                                             : 
903b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
903b			;                                                                             : 
903b			; Parameters                                                                  : 
903b			;     HL  Pointer to address of first byte of allocation to be freed          : 
903b			;                                                                             : 
903b			; Returns                                                                     : 
903b			;     Nothing                                                                 : 
903b			;                                                                             : 
903b			; Stack frame                                                                 : 
903b			;       |             |                                                       : 
903b			;       +-------------+                                                       : 
903b			;       |     BC      |                                                       : 
903b			;       +-------------+                                                       : 
903b			;       |     DE      |                                                       : 
903b			;       +-------------+                                                       : 
903b			;       |     IX      |                                                       : 
903b			;       +-------------+                                                       : 
903b			;       |  prev_free  |                                                       : 
903b			;   +2  +-------------+                                                       : 
903b			;       |  next_free  |                                                       : 
903b			;   +0  +-------------+                                                       : 
903b			;       |             |                                                       : 
903b			;                                                                             : 
903b			;------------------------------------------------------------------------------ 
903b			free: 
903b c5			      push  BC 
903c d5			      push  DE 
903d dd e5		      push  IX 
903f			 
903f 7c			      ld    A, H                    ; Exit if ptr is null 
9040 b5			      or    L 
9041 ca 05 91		      jp    Z, free_early_exit 
9044			 
9044			      ; Set up stack frame 
9044 eb			      ex    DE, HL 
9045 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9048 39			      add   HL, SP 
9049 f9			      ld    SP, HL 
904a dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
904e dd 39		      add   IX, SP 
9050			 
9050			      ; The address in HL points to the start of the useable allocated space, 
9050			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9050			      ; address of the block itself. 
9050 eb			      ex    DE, HL 
9051 11 fc ff		      ld    DE, -4 
9054 19			      add   HL, DE 
9055			 
9055			      ; An allocated block must have a null next block pointer in it 
9055 7e			      ld    A, (HL) 
9056 23			      inc   HL 
9057 b6			      or    (HL) 
9058 c2 00 91		      jp    NZ, free_done 
905b			 
905b 2b			      dec   HL 
905c			 
905c 44			      ld    B, H                    ; Copy HL to BC 
905d 4d			      ld    C, L 
905e			 
905e			      ; Loop through the free list to find the first block with an address 
905e			      ; higher than the block being freed 
905e 21 52 d7		      ld    HL, free_list 
9061			 
9061			free_find_higher_block: 
9061 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9062 23			      inc   HL 
9063 56			      ld    D, (HL) 
9064 2b			      dec   HL 
9065			 
9065 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9068 dd 72 01		      ld    (IX+1), D 
906b dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
906e dd 74 03		      ld    (IX+3), H 
9071			 
9071 78			      ld    A, B                    ; Check if DE is greater than BC 
9072 ba			      cp    D                       ; Compare MSB first 
9073 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
9075 30 04		      jr    NC, free_find_higher_block_skip 
9077 79			      ld    A, C 
9078 bb			      cp    E                       ; Then compare LSB 
9079 38 08		      jr    C, free_found_higher_block 
907b			 
907b			free_find_higher_block_skip: 
907b 7a			      ld    A, D                    ; Reached the end of the free list? 
907c b3			      or    E 
907d ca 00 91		      jp    Z, free_done 
9080			 
9080 eb			      ex    DE, HL 
9081			 
9081 18 de		      jr    free_find_higher_block 
9083			 
9083			free_found_higher_block: 
9083			      ; Insert freed block between prev and next free blocks 
9083 71			      ld    (HL), C                 ; Point prev free block to freed block 
9084 23			      inc   HL 
9085 70			      ld    (HL), B 
9086			 
9086 60			      ld    H, B                    ; Point freed block at next free block 
9087 69			      ld    L, C 
9088 73			      ld    (HL), E 
9089 23			      inc   HL 
908a 72			      ld    (HL), D 
908b			 
908b			      ; Check if the freed block is adjacent to the next free block 
908b 23			      inc   HL                      ; Load size of freed block into HL 
908c 5e			      ld    E, (HL) 
908d 23			      inc   HL 
908e 56			      ld    D, (HL) 
908f eb			      ex    DE, HL 
9090			 
9090 09			      add   HL, BC                  ; Add addr of freed block and its size 
9091			 
9091 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
9094 dd 56 01		      ld    D, (IX+1) 
9097			 
9097 b7			      or    A                       ; Clear the carry flag 
9098 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
909a 20 22		      jr    NZ, free_check_adjacent_to_prev 
909c			 
909c			      ; Freed block is adjacent to next, merge into one bigger block 
909c eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
909d 5e			      ld    E, (HL) 
909e 23			      inc   HL 
909f 56			      ld    D, (HL) 
90a0 e5			      push  HL                      ; Save ptr to next block for later 
90a1			 
90a1 60			      ld    H, B                    ; Store ptr from next block into freed block 
90a2 69			      ld    L, C 
90a3 73			      ld    (HL), E 
90a4 23			      inc   HL 
90a5 72			      ld    (HL), D 
90a6			 
90a6 e1			      pop   HL                      ; Restore ptr to next block 
90a7 23			      inc   HL                      ; Load size of next block into DE 
90a8 5e			      ld    E, (HL) 
90a9 23			      inc   HL 
90aa 56			      ld    D, (HL) 
90ab d5			      push  DE                      ; Save next block size for later 
90ac			 
90ac 60			      ld    H, B                    ; Load size of freed block into HL 
90ad 69			      ld    L, C 
90ae 23			      inc   HL 
90af 23			      inc   HL 
90b0 5e			      ld    E, (HL) 
90b1 23			      inc   HL 
90b2 56			      ld    D, (HL) 
90b3 eb			      ex    DE, HL 
90b4			 
90b4 d1			      pop   DE                      ; Restore size of next block 
90b5 19			      add   HL, DE                  ; Add sizes of both blocks 
90b6 eb			      ex    DE, HL 
90b7			 
90b7 60			      ld    H, B                    ; Store new bigger size into freed block 
90b8 69			      ld    L, C 
90b9 23			      inc   HL 
90ba 23			      inc   HL 
90bb 73			      ld    (HL), E 
90bc 23			      inc   HL 
90bd 72			      ld    (HL), D 
90be			 
90be			free_check_adjacent_to_prev: 
90be			      ; Check if the freed block is adjacent to the prev free block 
90be dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
90c1 dd 66 03		      ld    H, (IX+3) 
90c4			 
90c4 23			      inc   HL                      ; Size of prev free block into DE 
90c5 23			      inc   HL 
90c6 5e			      ld    E, (HL) 
90c7 23			      inc   HL 
90c8 56			      ld    D, (HL) 
90c9 2b			      dec   HL 
90ca 2b			      dec   HL 
90cb 2b			      dec   HL 
90cc			 
90cc 19			      add   HL, DE                  ; Add prev block addr and size 
90cd			 
90cd b7			      or    A                       ; Clear the carry flag 
90ce ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
90d0 20 2e		      jr    NZ, free_done 
90d2			 
90d2			      ; Freed block is adjacent to prev, merge into one bigger block 
90d2 60			      ld    H, B                    ; Load next ptr from freed block into DE 
90d3 69			      ld    L, C 
90d4 5e			      ld    E, (HL) 
90d5 23			      inc   HL 
90d6 56			      ld    D, (HL) 
90d7 e5			      push  HL                      ; Save freed block ptr for later 
90d8			 
90d8 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
90db dd 66 03		      ld    H, (IX+3) 
90de 73			      ld    (HL), E 
90df 23			      inc   HL 
90e0 72			      ld    (HL), D 
90e1			 
90e1 e1			      pop   HL                      ; Restore freed block ptr 
90e2 23			      inc   HL                      ; Load size of freed block into DE 
90e3 5e			      ld    E, (HL) 
90e4 23			      inc   HL 
90e5 56			      ld    D, (HL) 
90e6 d5			      push  DE                      ; Save freed block size for later 
90e7			 
90e7 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
90ea dd 66 03		      ld    H, (IX+3) 
90ed 23			      inc   HL 
90ee 23			      inc   HL 
90ef 5e			      ld    E, (HL) 
90f0 23			      inc   HL 
90f1 56			      ld    D, (HL) 
90f2			 
90f2 e1			      pop   HL                      ; Add sizes of both blocks 
90f3 19			      add   HL, DE 
90f4 eb			      ex    DE, HL 
90f5			 
90f5 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
90f8 dd 66 03		      ld    H, (IX+3) 
90fb 23			      inc   HL 
90fc 23			      inc   HL 
90fd 73			      ld    (HL), E 
90fe 23			      inc   HL 
90ff 72			      ld    (HL), D 
9100			 
9100			free_done: 
9100 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9103 39			      add   HL, SP 
9104 f9			      ld    SP, HL 
9105			 
9105			free_early_exit: 
9105 dd e1		      pop   IX 
9107 d1			      pop   DE 
9108 c1			      pop   BC 
9109			 
9109 c9			      ret 
910a			 
910a			; moved to firmware.asm 
910a			; 
910a			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
910a			;                  .dw   0 
910a			 
910a			 
910a			endif 
910a			 
910a			 
910a			if MALLOC_3 
910a			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
910a			;heap_start        .equ  0x9000      ; Starting address of heap 
910a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
910a			; 
910a			 ;     .org 0 
910a			  ;    jp    main 
910a			; 
910a			; 
910a			 ;     .org  0x100 
910a			;main: 
910a			 ;     ld    HL, 0x8100 
910a			  ;    ld    SP, HL 
910a			; 
910a			;      call  heap_init 
910a			 
910a			      ; Make some allocations 
910a			;      ld    HL, 12 
910a			;      call  malloc            ; Allocates 0x9004 
910a			; 
910a			 ;     ld    HL, 12 
910a			;      call  malloc            ; Allocates 0x9014 
910a			 
910a			;      ld    HL, 12 
910a			;      call  malloc            ; Allocates 0x9024 
910a			 
910a			      ; Free some allocations 
910a			;      ld    HL, 0x9014 
910a			;      call  free 
910a			 
910a			;      ld    HL, 0x9004 
910a			;      call  free 
910a			; 
910a			;      ld    HL, 0x9024 
910a			;      call  free 
910a			 
910a			 
910a			 ;     halt 
910a			 
910a			 
910a			;------------------------------------------------------------------------------ 
910a			;     heap_init                                                               : 
910a			;                                                                             : 
910a			; Description                                                                 : 
910a			;     Initialise the heap and make it ready for malloc and free operations.   : 
910a			;                                                                             : 
910a			;     The heap is maintained as a linked list, starting with an initial       : 
910a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
910a			;     the first free block in the heap. Each block then points to the next    : 
910a			;     free block within the heap, and the free list ends at the first block   : 
910a			;     with a null pointer to the next free block.                             : 
910a			;                                                                             : 
910a			; Parameters                                                                  : 
910a			;     Inputs are compile-time only. Two defines which specify the starting    : 
910a			;     address of the heap and its size are required, along with a memory      : 
910a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
910a			;     principally stores a pointer to the first free block in the heap.       : 
910a			;                                                                             : 
910a			; Returns                                                                     : 
910a			;     Nothing                                                                 : 
910a			;------------------------------------------------------------------------------ 
910a			heap_init: 
910a			      push  HL 
910a			 
910a			      ; Initialise free list struct 
910a			      ld    HL, heap_start 
910a			      ld    (free_list), HL 
910a			      ld    HL, 0 
910a			      ld    (free_list+2), HL 
910a			 
910a			      ; Insert first free block at bottom of heap, consumes entire heap 
910a			      ld    HL, heap_start+heap_size-4 
910a			      ld    (heap_start), HL        ; Next block (end of free list) 
910a			      ld    HL, heap_size-4 
910a			      ld    (heap_start+2), HL      ; Block size 
910a			 
910a			      ; Insert end of free list block at top of heap - two null words will 
910a			      ; terminate the free list 
910a			      ld    HL, 0 
910a			      ld    (heap_start+heap_size-2), HL 
910a			      ld    (heap_start+heap_size-4), HL 
910a			 
910a			      pop   HL 
910a			 
910a			      ret 
910a			 
910a			 
910a			;------------------------------------------------------------------------------ 
910a			;     malloc                                                                  : 
910a			;                                                                             : 
910a			; Description                                                                 : 
910a			;     Allocates the wanted space from the heap and returns the address of the : 
910a			;     first useable byte of the allocation.                                   : 
910a			;                                                                             : 
910a			;     Allocations can happen in one of two ways:                              : 
910a			;                                                                             : 
910a			;     1. A free block may be found which is the exact size wanted. In this    : 
910a			;        case the block is removed from the free list and retuedn to the      : 
910a			;        caller.                                                              : 
910a			;     2. A free block may be found which is larger than the size wanted. In   : 
910a			;        this case, the larger block is split into two. The first portion of  : 
910a			;        this block will become the requested space by the malloc call and    : 
910a			;        is returned to the caller. The second portion becomes a new free     : 
910a			;        block, and the free list is adjusted to maintain continuity via this : 
910a			;        newly created block.                                                 : 
910a			;                                                                             : 
910a			;     malloc does not set any initial value in the allocated space, the       : 
910a			;     caller is required to do this as required.                              : 
910a			;                                                                             : 
910a			;     This implementation of malloc uses the stack exclusively, and is        : 
910a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
910a			;     advisable to disable interrupts before calling malloc, and recommended  : 
910a			;     to avoid the use of malloc inside ISRs in general.                      : 
910a			;                                                                             : 
910a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
910a			;                                                                             : 
910a			; Parameters                                                                  : 
910a			;     HL  Number of bytes wanted                                              : 
910a			;                                                                             : 
910a			; Returns                                                                     : 
910a			;     HL  Address of the first useable byte of the allocation                 : 
910a			;                                                                             : 
910a			; Flags                                                                       : 
910a			;     Z   Set if the allocation did not succeed, clear otherwise              : 
910a			;                                                                             : 
910a			; Stack frame                                                                 : 
910a			;       |             |                                                       : 
910a			;       +-------------+                                                       : 
910a			;       |     BC      |                                                       : 
910a			;       +-------------+                                                       : 
910a			;       |     DE      |                                                       : 
910a			;       +-------------+                                                       : 
910a			;       |     IX      |                                                       : 
910a			;       +-------------+                                                       : 
910a			;       |  prev_free  |                                                       : 
910a			;   +4  +-------------+                                                       : 
910a			;       |  this_free  |                                                       : 
910a			;   +2  +-------------+                                                       : 
910a			;       |  next_free  |                                                       : 
910a			;   +0  +-------------+                                                       : 
910a			;       |             |                                                       : 
910a			;                                                                             : 
910a			;------------------------------------------------------------------------------ 
910a			malloc: 
910a			      push  BC 
910a			      push  DE 
910a			      push  IX 
910a			 
910a			      ld    A, H                    ; Exit if no space requested 
910a			      or    L 
910a			      jp    Z, malloc_early_exit 
910a			 
910a			      ; Set up stack frame 
910a			      ex    DE, HL 
910a			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
910a			      add   HL, SP 
910a			      ld    SP, HL 
910a			      ld    IX, 0                   ; Use IX as a frame pointer 
910a			      add   IX, SP 
910a			 
910a			      ; Setup initial state 
910a			      ld    HL, 4                   ; want must also include space used by block struct 
910a			      add   HL, DE 
910a			 
910a			      ld    B, H                    ; Move want to BC 
910a			      ld    C, L 
910a			 
910a			      ld    HL, free_list           ; Store prev_free ptr to stack 
910a			      ld    (IX+4), L 
910a			      ld    (IX+5), H 
910a			 
910a			      ld    E, (HL)                 ; Store this_free ptr to stack 
910a			      inc   HL 
910a			      ld    D, (HL) 
910a			      ld    (IX+2), E 
910a			      ld    (IX+3), D 
910a			      ex    DE, HL                  ; this_free ptr into HL 
910a			 
910a			      ; Loop through free block list to find some space 
910a			malloc_find_space: 
910a			      ld    E, (HL)                 ; Load next_free ptr into DE 
910a			      inc   HL 
910a			      ld    D, (HL) 
910a			 
910a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
910a			      or    E 
910a			      jp    Z, malloc_no_space 
910a			 
910a			      ld    (IX+0), E               ; Store next_free ptr to stack 
910a			      ld    (IX+1), D 
910a			 
910a			      ; Does this block have enough space to make the allocation? 
910a			      inc   HL                      ; Load free block size into DE 
910a			      ld    E, (HL) 
910a			      inc   HL 
910a			      ld    D, (HL) 
910a			 
910a			      ex    DE, HL                  ; Check size of block against want 
910a			      or    A                       ; Ensure carry flag clear 
910a			      sbc   HL, BC 
910a			      push  HL                      ; Store the result for later (new block size) 
910a			 
910a			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
910a			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
910a			 
910a			      ; this_free block is not big enough, setup ptrs to test next free block 
910a			      pop   HL                      ; Discard previous result 
910a			 
910a			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
910a			      ld    H, (IX+3) 
910a			      ld    (IX+4), L 
910a			      ld    (IX+5), H 
910a			 
910a			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
910a			      ld    H, (IX+1) 
910a			      ld    (IX+2), L 
910a			      ld    (IX+3), H 
910a			 
910a			      jr    malloc_find_space 
910a			 
910a			      ; split a bigger block into two - requested size and remaining size 
910a			malloc_alloc_split: 
910a			      ex    DE, HL                  ; Calculate address of new free block 
910a			      dec   HL 
910a			      dec   HL 
910a			      dec   HL 
910a			      add   HL, BC 
910a			 
910a			      ; Create a new block and point it at next_free 
910a			      ld    E, (IX+0)               ; Load next_free ptr into DE 
910a			      ld    D, (IX+1) 
910a			 
910a			      ld    (HL), E                 ; Store next_free ptr into new block 
910a			      inc   HL 
910a			      ld    (HL), D 
910a			 
910a			      pop   DE                      ; Store size of new block into new block 
910a			      inc   HL 
910a			      ld    (HL), E 
910a			      inc   HL 
910a			      ld    (HL), D 
910a			 
910a			      ; Update this_free ptr to point to new block 
910a			      dec   HL 
910a			      dec   HL 
910a			      dec   HL 
910a			 
910a			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
910a			      ld    D, (IX+3) 
910a			 
910a			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
910a			      ld    (IX+3), H 
910a			 
910a			      ; Modify this_free block to be allocation 
910a			      ex    DE, HL 
910a			      xor   A                       ; Null the next block ptr of allocated block 
910a			      ld    (HL), A 
910a			      inc   HL 
910a			      ld    (HL), A 
910a			 
910a			      inc   HL                      ; Store want size into allocated block 
910a			      ld    (HL), C 
910a			      inc   HL 
910a			      ld    (HL), B 
910a			      inc   HL 
910a			      push  HL                      ; Address of allocation to return 
910a			 
910a			      jr    malloc_update_links 
910a			 
910a			malloc_alloc_fit: 
910a			      pop   HL                      ; Dont need new block size, want is exact fit 
910a			 
910a			      ; Modify this_free block to be allocation 
910a			      ex    DE, HL 
910a			      dec   HL 
910a			      dec   HL 
910a			      dec   HL 
910a			 
910a			      xor   A                       ; Null the next block ptr of allocated block 
910a			      ld    (HL), A 
910a			      inc   HL 
910a			      ld    (HL), A 
910a			 
910a			      inc   HL                      ; Store address of allocation to return 
910a			      inc   HL 
910a			      inc   HL 
910a			      push  HL 
910a			 
910a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
910a			      ld    L, (IX+0)               ; next_free to HL 
910a			      ld    H, (IX+1) 
910a			 
910a			      ld    (IX+2), L               ; HL to this_free 
910a			      ld    (IX+3), H 
910a			 
910a			 
910a			malloc_update_links: 
910a			      ; Update prev_free ptr to point to this_free 
910a			      ld    L, (IX+4)               ; prev_free ptr to HL 
910a			      ld    H, (IX+5) 
910a			 
910a			      ld    E, (IX+2)               ; this_free ptr to DE 
910a			      ld    D, (IX+3) 
910a			 
910a			      ld    (HL), E                 ; this_free ptr into prev_free 
910a			      inc   HL 
910a			      ld    (HL), D 
910a			 
910a			      ; Clear the Z flag to indicate successful allocation 
910a			      ld    A, D 
910a			      or    E 
910a			 
910a			      pop   DE                      ; Address of allocation 
910a			 
910a			malloc_no_space: 
910a			      ld    HL, 6                   ; Clean up stack frame 
910a			      add   HL, SP 
910a			      ld    SP, HL 
910a			 
910a			      ex    DE, HL                  ; Alloc addr into HL for return 
910a			 
910a			malloc_early_exit: 
910a			      pop   IX 
910a			      pop   DE 
910a			      pop   BC 
910a			 
910a			      ret 
910a			 
910a			 
910a			;------------------------------------------------------------------------------ 
910a			;     free                                                                    : 
910a			;                                                                             : 
910a			; Description                                                                 : 
910a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
910a			;     returned by malloc, otherwise the behaviour is undefined.               : 
910a			;                                                                             : 
910a			;     Where possible, directly adjacent free blocks will be merged together   : 
910a			;     into larger blocks to help ensure that the heap does not become         : 
910a			;     excessively fragmented.                                                 : 
910a			;                                                                             : 
910a			;     free does not clear or set any other value into the freed space, and    : 
910a			;     therefore its contents may be visible through subsequent malloc's. The  : 
910a			;     caller should clear the freed space as required.                        : 
910a			;                                                                             : 
910a			;     This implementation of free uses the stack exclusively, and is          : 
910a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
910a			;     advisable to disable interrupts before calling free, and recommended    : 
910a			;     to avoid the use of free inside ISRs in general.                        : 
910a			;                                                                             : 
910a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
910a			;                                                                             : 
910a			; Parameters                                                                  : 
910a			;     HL  Pointer to address of first byte of allocation to be freed          : 
910a			;                                                                             : 
910a			; Returns                                                                     : 
910a			;     Nothing                                                                 : 
910a			;                                                                             : 
910a			; Stack frame                                                                 : 
910a			;       |             |                                                       : 
910a			;       +-------------+                                                       : 
910a			;       |     BC      |                                                       : 
910a			;       +-------------+                                                       : 
910a			;       |     DE      |                                                       : 
910a			;       +-------------+                                                       : 
910a			;       |     IX      |                                                       : 
910a			;       +-------------+                                                       : 
910a			;       |  prev_free  |                                                       : 
910a			;   +2  +-------------+                                                       : 
910a			;       |  next_free  |                                                       : 
910a			;   +0  +-------------+                                                       : 
910a			;       |             |                                                       : 
910a			;                                                                             : 
910a			;------------------------------------------------------------------------------ 
910a			free: 
910a			      push  BC 
910a			      push  DE 
910a			      push  IX 
910a			 
910a			      ld    A, H                    ; Exit if ptr is null 
910a			      or    L 
910a			      jp    Z, free_early_exit 
910a			 
910a			      ; Set up stack frame 
910a			      ex    DE, HL 
910a			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
910a			      add   HL, SP 
910a			      ld    SP, HL 
910a			      ld    IX, 0                   ; Use IX as a frame pointer 
910a			      add   IX, SP 
910a			 
910a			      ; The address in HL points to the start of the useable allocated space, 
910a			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
910a			      ; address of the block itself. 
910a			      ex    DE, HL 
910a			      ld    DE, -4 
910a			      add   HL, DE 
910a			 
910a			      ; An allocated block must have a null next block pointer in it 
910a			      ld    A, (HL) 
910a			      inc   HL 
910a			      or    (HL) 
910a			      jp    NZ, free_done 
910a			 
910a			      dec   HL 
910a			 
910a			      ld    B, H                    ; Copy HL to BC 
910a			      ld    C, L 
910a			 
910a			      ; Loop through the free list to find the first block with an address 
910a			      ; higher than the block being freed 
910a			      ld    HL, free_list 
910a			 
910a			free_find_higher_block: 
910a			      ld    E, (HL)                 ; Load next ptr from free block 
910a			      inc   HL 
910a			      ld    D, (HL) 
910a			      dec   HL 
910a			 
910a			      ld    (IX+0), E               ; Save ptr to next free block 
910a			      ld    (IX+1), D 
910a			      ld    (IX+2), L               ; Save ptr to prev free block 
910a			      ld    (IX+3), H 
910a			 
910a			      ld    A, B                    ; Check if DE is greater than BC 
910a			      cp    D                       ; Compare MSB first 
910a			      jr    Z, $+4                  ; MSB the same, compare LSB 
910a			      jr    NC, free_find_higher_block_skip 
910a			      ld    A, C 
910a			      cp    E                       ; Then compare LSB 
910a			      jr    C, free_found_higher_block 
910a			 
910a			free_find_higher_block_skip: 
910a			      ld    A, D                    ; Reached the end of the free list? 
910a			      or    E 
910a			      jp    Z, free_done 
910a			 
910a			      ex    DE, HL 
910a			 
910a			      jr    free_find_higher_block 
910a			 
910a			free_found_higher_block: 
910a			      ; Insert freed block between prev and next free blocks 
910a			      ld    (HL), C                 ; Point prev free block to freed block 
910a			      inc   HL 
910a			      ld    (HL), B 
910a			 
910a			      ld    H, B                    ; Point freed block at next free block 
910a			      ld    L, C 
910a			      ld    (HL), E 
910a			      inc   HL 
910a			      ld    (HL), D 
910a			 
910a			      ; Check if the freed block is adjacent to the next free block 
910a			      inc   HL                      ; Load size of freed block into HL 
910a			      ld    E, (HL) 
910a			      inc   HL 
910a			      ld    D, (HL) 
910a			      ex    DE, HL 
910a			 
910a			      add   HL, BC                  ; Add addr of freed block and its size 
910a			 
910a			      ld    E, (IX+0)               ; Load addr of next free block into DE 
910a			      ld    D, (IX+1) 
910a			 
910a			      or    A                       ; Clear the carry flag 
910a			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
910a			      jr    NZ, free_check_adjacent_to_prev 
910a			 
910a			      ; Freed block is adjacent to next, merge into one bigger block 
910a			      ex    DE, HL                  ; Load next ptr from next block into DE 
910a			      ld    E, (HL) 
910a			      inc   HL 
910a			      ld    D, (HL) 
910a			      push  HL                      ; Save ptr to next block for later 
910a			 
910a			      ld    H, B                    ; Store ptr from next block into freed block 
910a			      ld    L, C 
910a			      ld    (HL), E 
910a			      inc   HL 
910a			      ld    (HL), D 
910a			 
910a			      pop   HL                      ; Restore ptr to next block 
910a			      inc   HL                      ; Load size of next block into DE 
910a			      ld    E, (HL) 
910a			      inc   HL 
910a			      ld    D, (HL) 
910a			      push  DE                      ; Save next block size for later 
910a			 
910a			      ld    H, B                    ; Load size of freed block into HL 
910a			      ld    L, C 
910a			      inc   HL 
910a			      inc   HL 
910a			      ld    E, (HL) 
910a			      inc   HL 
910a			      ld    D, (HL) 
910a			      ex    DE, HL 
910a			 
910a			      pop   DE                      ; Restore size of next block 
910a			      add   HL, DE                  ; Add sizes of both blocks 
910a			      ex    DE, HL 
910a			 
910a			      ld    H, B                    ; Store new bigger size into freed block 
910a			      ld    L, C 
910a			      inc   HL 
910a			      inc   HL 
910a			      ld    (HL), E 
910a			      inc   HL 
910a			      ld    (HL), D 
910a			 
910a			free_check_adjacent_to_prev: 
910a			      ; Check if the freed block is adjacent to the prev free block 
910a			      ld    L, (IX+2)               ; Prev free block ptr into HL 
910a			      ld    H, (IX+3) 
910a			 
910a			      inc   HL                      ; Size of prev free block into DE 
910a			      inc   HL 
910a			      ld    E, (HL) 
910a			      inc   HL 
910a			      ld    D, (HL) 
910a			      dec   HL 
910a			      dec   HL 
910a			      dec   HL 
910a			 
910a			      add   HL, DE                  ; Add prev block addr and size 
910a			 
910a			      or    A                       ; Clear the carry flag 
910a			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
910a			      jr    NZ, free_done 
910a			 
910a			      ; Freed block is adjacent to prev, merge into one bigger block 
910a			      ld    H, B                    ; Load next ptr from freed block into DE 
910a			      ld    L, C 
910a			      ld    E, (HL) 
910a			      inc   HL 
910a			      ld    D, (HL) 
910a			      push  HL                      ; Save freed block ptr for later 
910a			 
910a			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
910a			      ld    H, (IX+3) 
910a			      ld    (HL), E 
910a			      inc   HL 
910a			      ld    (HL), D 
910a			 
910a			      pop   HL                      ; Restore freed block ptr 
910a			      inc   HL                      ; Load size of freed block into DE 
910a			      ld    E, (HL) 
910a			      inc   HL 
910a			      ld    D, (HL) 
910a			      push  DE                      ; Save freed block size for later 
910a			 
910a			      ld    L, (IX+2)               ; Load size of prev block into DE 
910a			      ld    H, (IX+3) 
910a			      inc   HL 
910a			      inc   HL 
910a			      ld    E, (HL) 
910a			      inc   HL 
910a			      ld    D, (HL) 
910a			 
910a			      pop   HL                      ; Add sizes of both blocks 
910a			      add   HL, DE 
910a			      ex    DE, HL 
910a			 
910a			      ld    L, (IX+2)               ; Store new bigger size into prev block 
910a			      ld    H, (IX+3) 
910a			      inc   HL 
910a			      inc   HL 
910a			      ld    (HL), E 
910a			      inc   HL 
910a			      ld    (HL), D 
910a			 
910a			free_done: 
910a			      ld    HL, 4                   ; Clean up stack frame 
910a			      add   HL, SP 
910a			      ld    SP, HL 
910a			 
910a			free_early_exit: 
910a			      pop   IX 
910a			      pop   DE 
910a			      pop   BC 
910a			 
910a			      ret 
910a			 
910a			 
910a			;      .org 0x8000 
910a			; 
910a			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
910a			 ;                 .dw   0 
910a			 
910a			endif 
910a			 
910a			 
910a			if MALLOC_4 
910a			 
910a			; My memory allocation code. Very very simple.... 
910a			; allocate space under 250 chars 
910a			 
910a			heap_init: 
910a				; init start of heap as zero 
910a				;  
910a			 
910a				ld hl, heap_start 
910a				ld a, 0 
910a				ld (hl), a      ; empty block 
910a				inc hl 
910a				ld a, 0 
910a				ld (hl), a      ; length of block 
910a				; write end of list 
910a				inc hl 
910a				ld a,(hl) 
910a				inc hl 
910a				ld a,(hl) 
910a				 
910a			 
910a				; init some malloc vars 
910a			 
910a				ld hl, 0 
910a				ld (free_list), hl       ; store last malloc location 
910a			 
910a				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
910a				ld a, 0 
910a				ld (hl), a 
910a			 
910a			 
910a				ld hl, heap_start 
910a				;  
910a				  
910a				ret 
910a			 
910a			 
910a			;    free block marker 
910a			;    requested size  
910a			;    pointer to next block 
910a			;    .... 
910a			;    next block marker 
910a			 
910a			 
910a			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
910a			; 
910a			 
910a			 
910a			malloc:  
910a				push de 
910a				push bc 
910a				push af 
910a			 
910a				; hl space required 
910a				 
910a				ld c, l    ; hold space   (TODO only a max of 255) 
910a			 
910a			;	inc c     ; TODO BUG need to fix memory leak on push str 
910a			;	inc c 
910a			;	inc c 
910a			;	inc c 
910a			;	inc c 
910a			;	inc c 
910a			;	inc c 
910a			 
910a			 
910a			 
910a				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
910a			 
910a				ld a, (free_list+3) 
910a				cp 0 
910a				jr z, .contheap 
910a			 
910a				ld hl, (free_list)     ; get last alloc 
910a					if DEBUG_FORTH_MALLOC_INT 
910a						DMARK "mrs" 
910a						CALLMONITOR 
910a					endif 
910a				jr .startalloc 
910a			 
910a			.contheap: 
910a				ld hl, heap_start 
910a			 
910a			.startalloc: 
910a			 
910a					if DEBUG_FORTH_MALLOC_INT 
910a						DMARK "mym" 
910a						CALLMONITOR 
910a					endif 
910a			.findblock: 
910a					if DEBUG_FORTH_MALLOC_INT 
910a						DMARK "mmf" 
910a						CALLMONITOR 
910a					endif 
910a			 
910a				ld a,(hl)  
910a				; if byte is zero then clear to use 
910a			 
910a				cp 0 
910a				jr z, .foundemptyblock 
910a			 
910a				; if byte is not clear 
910a				;     then byte is offset to next block 
910a			 
910a				inc hl 
910a				ld a, (hl) ; get size 
910a			.nextblock:	inc hl 
910a					ld e, (hl) 
910a					inc hl 
910a					ld d, (hl) 
910a					ex de, hl 
910a			;	inc hl  ; move past the store space 
910a			;	inc hl  ; move past zero index  
910a			 
910a				; TODO detect no more space 
910a			 
910a				push hl 
910a				ld de, heap_end 
910a				call cmp16 
910a				pop hl 
910a				jr nc, .nospace 
910a			 
910a				jr .findblock 
910a			 
910a			.nospace: ld hl, 0 
910a				jp .exit 
910a			 
910a			 
910a			.foundemptyblock:	 
910a					if DEBUG_FORTH_MALLOC_INT 
910a						DMARK "mme" 
910a						CALLMONITOR 
910a					endif 
910a			 
910a			; TODO has block enough space if reusing??? 
910a			 
910a				;  
910a			 
910a			; see if this block has been previously used 
910a				inc hl 
910a				ld a, (hl) 
910a				dec hl 
910a				cp 0 
910a				jr z, .newblock 
910a			 
910a					if DEBUG_FORTH_MALLOC_INT 
910a						DMARK "meR" 
910a						CALLMONITOR 
910a					endif 
910a			 
910a			; no reusing previously allocated block 
910a			 
910a			; is it smaller than previously used? 
910a				 
910a				inc hl    ; move to size 
910a				ld a, c 
910a				sub (hl)        ; we want c < (hl) 
910a				dec hl    ; move back to marker 
910a			        jr z, .findblock 
910a			 
910a				; update with the new size which should be lower 
910a			 
910a			        ;inc  hl   ; negate next move. move back to size  
910a			 
910a			.newblock: 
910a				; need to be at marker here 
910a			 
910a					if DEBUG_FORTH_MALLOC_INT 
910a						DMARK "meN" 
910a						CALLMONITOR 
910a					endif 
910a			 
910a			 
910a				ld a, c 
910a			 
910a				ld (free_list+3), a	 ; flag resume from last malloc  
910a				ld (free_list), hl    ; save out last location 
910a			 
910a			 
910a				;inc a     ; space for length byte 
910a				ld (hl), a     ; save block in use marker 
910a			 
910a				inc hl   ; move to space marker 
910a				ld (hl), a    ; save new space 
910a			 
910a				inc hl   ; move to start of allocated area 
910a				 
910a			;	push hl     ; save where we are - 1  
910a			 
910a			;	inc hl  ; move past zero index  
910a				; skip space to set down new marker 
910a			 
910a				; provide some extra space for now 
910a			 
910a				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
910a				inc a 
910a				inc a 
910a			 
910a				push hl   ; save where we are in the node block 
910a			 
910a				call addatohl 
910a			 
910a				; write linked list point 
910a			 
910a				pop de     ; get our node position 
910a				ex de, hl 
910a			 
910a				ld (hl), e 
910a				inc hl 
910a				ld (hl), d 
910a			 
910a				inc hl 
910a			 
910a				; now at start of allocated data so save pointer 
910a			 
910a				push hl 
910a			 
910a				; jump to position of next node and setup empty header in DE 
910a			 
910a				ex de, hl 
910a			 
910a			;	inc hl ; move past end of block 
910a			 
910a				ld a, 0 
910a				ld (hl), a   ; empty marker 
910a				inc hl 
910a				ld (hl), a   ; size 
910a				inc hl  
910a				ld (hl), a   ; ptr 
910a				inc hl 
910a				ld (hl), a   ; ptr 
910a			 
910a			 
910a				pop hl 
910a			 
910a					if DEBUG_FORTH_MALLOC_INT 
910a						DMARK "mmr" 
910a						CALLMONITOR 
910a					endif 
910a			 
910a			.exit: 
910a				pop af 
910a				pop bc 
910a				pop de  
910a				ret 
910a			 
910a			 
910a			 
910a			 
910a			free:  
910a				push hl 
910a				push af 
910a				; get address in hl 
910a			 
910a					if DEBUG_FORTH_MALLOC_INT 
910a						DMARK "fre" 
910a						CALLMONITOR 
910a					endif 
910a				; data is at hl - move to block count 
910a				dec hl 
910a				dec hl    ; get past pointer 
910a				dec hl 
910a			 
910a				ld a, (hl)    ; need this for a validation check 
910a			 
910a				dec hl    ; move to block marker 
910a			 
910a				; now check that the block count and block marker are the same  
910a			        ; this checks that we are on a malloc node and not random memory 
910a			        ; OK a faint chance this could be a problem but rare - famous last words! 
910a			 
910a				ld c, a 
910a				ld a, (hl)    
910a			 
910a				cp c 
910a				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
910a			 
910a				; yes good chance we are on a malloc node 
910a			 
910a				ld a, 0      
910a				ld (hl), a   ; mark as free 
910a			 
910a				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
910a			 
910a			.freeignore:  
910a			 
910a				pop af 
910a				pop hl 
910a			 
910a				ret 
910a			 
910a			 
910a			 
910a			endif 
910a			 
910a			; eof 
# End of file firmware_memory.asm
910a			  
910a			; device C  
910a			if SOUND_ENABLE  
910a				include "firmware_sound.asm"  
910a			endif  
910a			  
910a			include "firmware_diags.asm"  
910a			; Hardware diags menu 
910a			 
910a			 
910a			config: 
910a			 
910a 3e 00			ld a, 0 
910c 21 3a 91			ld hl, .configmn 
910f cd ae 88			call menu 
9112			 
9112 fe 00			cp 0 
9114 c8				ret z 
9115			 
9115 fe 01			cp 1 
9117 cc de 91			call z, .savetostore 
911a			 
911a fe 02			cp 2 
911c cc dc 91			call z, .selautoload 
911f fe 03			cp 3 
9121 cc db 91			call z, .disautoload 
9124 fe 04			cp 4 
9126 cc dd 91			call z, .selbank 
9129 fe 05			cp 5 
912b cc df 91			call z, .debug_tog 
912e fe 06			cp 6 
9130 cc 27 93			call z, .bpsgo 
9133 fe 07			cp 7 
9135 cc 05 92			call z, hardware_diags 
9138			 
9138 18 d0			jr config 
913a			 
913a			.configmn: 
913a 4a 91			dw .c3 
913c 61 91			dw .c2 
913e 76 91			dw .c2a 
9140 8c 91			dw .c2b 
9142			;	dw .c4 
9142 a9 91			dw .m4 
9144 c4 91			dw .m4b 
9146 cc 91			dw .c1 
9148 00 00			dw 0 
914a				 
914a			 
914a .. 00		.c3: db "Add Dictionary To File",0 
9161 .. 00		.c2: db "Select Autoload File",0 
9176 .. 00		.c2a: db "Disable Autoload File", 0 
918c .. 00		.c2b: db "Select Storage Bank",0 
91a0 .. 00		.c4: db "Settings",0 
91a9 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
91c4 .. 00		.m4b:   db "Monitor",0 
91cc .. 00		.c1: db "Hardware Diags",0 
91db			 
91db			 
91db			.disautoload: 
91db				if STORAGE_SE 
91db				ld a, $fe      ; bit 0 clear 
91db				ld (spi_device), a 
91db			 
91db				call storage_get_block_0 
91db			 
91db				ld a, 0 
91db				ld (store_page+STORE_0_AUTOFILE), a 
91db			 
91db					ld hl, 0 
91db					ld de, store_page 
91db				call storage_write_block	 ; save update 
91db				endif 
91db			 
91db			 
91db c9				ret 
91dc			 
91dc			 
91dc			 
91dc			; Select auto start 
91dc			 
91dc			.selautoload: 
91dc			 
91dc				 
91dc				if STORAGE_SE 
91dc			 
91dc					call config_dir 
91dc				        ld hl, scratch 
91dc					ld a, 0 
91dc					call menu 
91dc			 
91dc					cp 0 
91dc					ret z 
91dc			 
91dc					dec a 
91dc			 
91dc			 
91dc					; locate menu option 
91dc			 
91dc					ld hl, scratch 
91dc					call table_lookup 
91dc			 
91dc					if DEBUG_FORTH_WORDS 
91dc						DMARK "ALl" 
91dc						CALLMONITOR 
91dc					endif 
91dc					; with the pointer to the menu it, the byte following the zero term is the file id 
91dc			 
91dc					ld a, 0 
91dc					ld bc, 50   ; max of bytes to look at 
91dc					cpir  
91dc			 
91dc					if DEBUG_FORTH_WORDS 
91dc						DMARK "ALb" 
91dc						CALLMONITOR 
91dc					endif 
91dc					;inc hl 
91dc			 
91dc					ld a, (hl)   ; file id 
91dc					 
91dc				        ; save bank and file ids 
91dc			 
91dc					push af 
91dc			 
91dc			; TODO need to save to block 0 on bank 1	 
91dc			 
91dc					call storage_get_block_0 
91dc			 
91dc					if DEBUG_FORTH_WORDS 
91dc						DMARK "AL0" 
91dc						CALLMONITOR 
91dc					endif 
91dc					pop af 
91dc			 
91dc					ld (store_page+STORE_0_FILERUN),a 
91dc					 
91dc					; save bank id 
91dc			 
91dc					ld a,(spi_device) 
91dc					ld (store_page+STORE_0_BANKRUN),a 
91dc			 
91dc					; enable auto run of store file 
91dc			 
91dc					ld a, 1 
91dc					ld (store_page+STORE_0_AUTOFILE),a 
91dc			 
91dc					; save buffer 
91dc			 
91dc					ld hl, 0 
91dc					ld de, store_page 
91dc					if DEBUG_FORTH_WORDS 
91dc						DMARK "ALw" 
91dc						CALLMONITOR 
91dc					endif 
91dc				call storage_write_block	 ; save update 
91dc			  
91dc			 
91dc			 
91dc			 
91dc					ld hl, scratch 
91dc					call config_fdir 
91dc			 
91dc			 
91dc				endif 
91dc c9				ret 
91dd			 
91dd			 
91dd			 
91dd			; Select storage bank 
91dd			 
91dd			.selbank: 
91dd			 
91dd				if STORAGE_SE 
91dd				endif 
91dd				 
91dd c9				ret 
91de			 
91de			if STORAGE_SE 
91de			 
91de			.config_ldir:   
91de				; Load storage bank labels into menu array 
91de			 
91de				 
91de			 
91de			 
91de				ret 
91de			 
91de			 
91de			endif 
91de			 
91de			 
91de			; Save user words to storage 
91de			 
91de			.savetostore: 
91de			 
91de				if STORAGE_SE 
91de			 
91de					call config_dir 
91de				        ld hl, scratch 
91de					ld a, 0 
91de					call menu 
91de					 
91de					ld hl, scratch 
91de					call config_fdir 
91de			 
91de			 
91de				endif 
91de			 
91de c9				ret 
91df			 
91df			 
91df			 
91df			if STORAGE_SE 
91df			 
91df			config_fdir: 
91df				; using the scratch dir go through and release the memory allocated for each string 
91df				 
91df				ld hl, scratch 
91df			.cfdir:	ld e,(hl) 
91df				inc hl 
91df				ld d,(hl) 
91df				inc hl 
91df			 
91df				ex de, hl 
91df				call ishlzero 
91df				ret z     ; return on null pointer 
91df				call free 
91df				ex de, hl 
91df				jr .cfdir 
91df			 
91df			 
91df				ret 
91df			 
91df			 
91df			config_dir: 
91df			 
91df				; for the config menus that need to build a directory of storage call this routine 
91df				; it will construct a menu in scratch to pass to menu 
91df			 
91df				; open storage device 
91df			 
91df				; execute DIR to build a list of files and their ids into scratch in menu format 
91df				; once the menu has finished then will need to call config_fdir to release the strings 
91df				 
91df				; c = number items 
91df			 
91df				 
91df				call storage_get_block_0 
91df			 
91df				ld hl, store_page     ; get current id count 
91df				ld b, (hl) 
91df				ld c, 0    ; count of files   
91df			 
91df			 
91df				ld hl, scratch 
91df				ld (store_tmp2), hl    ; location to poke strings 
91df			 
91df				; check for empty drive 
91df			 
91df				ld a, 0 
91df				cp b 
91df				jp z, .dirdone 
91df			 
91df				 
91df					if DEBUG_FORTH_WORDS 
91df						DMARK "Cdc" 
91df						CALLMONITOR 
91df					endif 
91df			 
91df			 
91df			.diritem:	 
91df				push bc 
91df				; for each of the current ids do a search for them and if found push to stack 
91df			 
91df					ld hl, STORE_BLOCK_PHY 
91df					ld d, 0		 ; look for extent 0 of block id as this contains file name 
91df					ld e,b 
91df			 
91df					call storage_findnextid 
91df			 
91df			 
91df					; if found hl will be non zero 
91df			 
91df					call ishlzero 
91df					jr z, .dirnotfound 
91df			 
91df					; increase count 
91df			 
91df					pop bc	 
91df					inc c 
91df					push bc 
91df					 
91df			 
91df					; get file header and push the file name 
91df			 
91df					ld de, store_page 
91df					call storage_read_block 
91df			 
91df					; push file id to stack 
91df				 
91df					ld a, (store_page) 
91df					ld h, 0 
91df					ld l, a 
91df			 
91df					;call forth_push_numhl 
91df					; TODO store id 
91df			 
91df					push hl 
91df			 
91df					; push extent count to stack  
91df				 
91df					ld hl, store_page+3 
91df			 
91df					; get file name length 
91df			 
91df					call strlenz   
91df			 
91df					inc hl   ; cover zero term 
91df					inc hl  ; stick the id at the end of the area 
91df			 
91df					push hl 
91df					pop bc    ; move length to bc 
91df			 
91df					call malloc 
91df			 
91df					; TODO save malloc area to scratch 
91df			 
91df					ex de, hl 
91df					ld hl, (store_tmp2) 
91df					ld (hl), e 
91df					inc hl 
91df					ld (hl), d 
91df					inc hl 
91df					ld (store_tmp2), hl 
91df			 
91df					 
91df			 
91df					;pop hl   ; get source 
91df			;		ex de, hl    ; swap aronund	 
91df			 
91df					ld hl, store_page+3 
91df					if DEBUG_FORTH_WORDS 
91df						DMARK "CFd" 
91df						CALLMONITOR 
91df					endif 
91df					ldir 
91df			 
91df					; de is past string, move back one and store id 
91df					 
91df					dec de 
91df			 
91df					; store file id 
91df			 
91df					pop hl 
91df					ex de,hl 
91df					ld (hl), e 
91df			 
91df					if DEBUG_FORTH_WORDS 
91df						DMARK "Cdi" 
91df						CALLMONITOR 
91df					endif 
91df					 
91df			.dirnotfound: 
91df					pop bc     
91df					djnz .diritem 
91df				 
91df			.dirdone:	 
91df			 
91df					ld a, 0 
91df					ld hl, (store_tmp2) 
91df					ld (hl), a 
91df					inc hl 
91df					ld (hl), a 
91df					inc hl 
91df					; push a count of the dir items found 
91df			 
91df			;		ld h, 0 
91df			;		ld l, c 
91df			 
91df				ret 
91df			 
91df			endif 
91df			 
91df			 
91df			; Settings 
91df			; Run  
91df			 
91df			 
91df			 
91df			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
91df			;;hd_menu2:   db "        2: Editor",0   
91df			;hd_menu2:   db "        2: Editor       6: Menu",0   
91df			;hd_menu3:   db "        3: Storage",0 
91df			;hd_menu4:   db "0=quit  4: Debug",0 
91df			;hd_don:     db "ON",0 
91df			;hd_doff:     db "OFF",0 
91df			; 
91df			; 
91df			; 
91df			;hardware_diags_old:       
91df			; 
91df			;.diagmenu: 
91df			;	call clear_display 
91df			;	ld a, display_row_1 
91df			;	ld de, hd_menu1 
91df			;	call str_at_display 
91df			; 
91df			;	ld a, display_row_2 
91df			;	ld de, hd_menu2 
91df			;	call str_at_display 
91df			; 
91df			;	ld a, display_row_3 
91df			;	ld de, hd_menu3 
91df			;	call str_at_display 
91df			; 
91df			;	ld a,  display_row_4 
91df			;	ld de, hd_menu4 
91df			;	call str_at_display 
91df			; 
91df			;	; display debug state 
91df			; 
91df			;	ld de, hd_don 
91df			;	ld a, (os_view_disable) 
91df			;	cp 0 
91df			;	jr z, .distog 
91df			;	ld de, hd_doff 
91df			;.distog: ld a, display_row_4+17 
91df			;	call str_at_display 
91df			; 
91df			;	call update_display 
91df			; 
91df			;	call cin_wait 
91df			; 
91df			; 
91df			; 
91df			;	cp '4' 
91df			;	jr nz, .diagn1 
91df			; 
91df			;	; debug toggle 
91df			; 
91df			;	ld a, (os_view_disable) 
91df			;	ld b, '*' 
91df			;	cp 0 
91df			;	jr z, .debtog 
91df			;	ld b, 0 
91df			;.debtog:	 
91df			;	ld a,b 
91df			;	ld (os_view_disable),a 
91df			; 
91df			;.diagn1: cp '0' 
91df			;	 ret z 
91df			; 
91df			;;	cp '1' 
91df			;;       jp z, matrix	 
91df			;;   TODO keyboard matrix test 
91df			; 
91df			;	cp '2' 
91df			;	jp z, .diagedit 
91df			; 
91df			;;	cp '6' 
91df			;;	jp z, .menutest 
91df			;;if ENABLE_BASIC 
91df			;;	cp '6' 
91df			;;	jp z, basic 
91df			;;endif 
91df			 ; 
91df			;	jp .diagmenu 
91df			; 
91df			; 
91df			;	ret 
91df			 
91df			 
91df			.debug_tog: 
91df 21 26 92			ld hl, .menudebug 
91e2				 
91e2 3a 51 e3			ld a, (os_view_disable) 
91e5 fe 2a			cp '*' 
91e7 20 04			jr nz,.tdon  
91e9 3e 01			ld a, 1 
91eb 18 02			jr .tog1 
91ed 3e 00		.tdon: ld a, 0 
91ef			 
91ef			.tog1: 
91ef cd ae 88			call menu 
91f2 fe 00			cp 0 
91f4 c8				ret z 
91f5 fe 01			cp 1    ; disable debug 
91f7 28 04			jr z, .dtog0 
91f9 3e 2a			ld a, '*' 
91fb 18 02			jr .dtogset 
91fd 3e 00		.dtog0: ld a, 0 
91ff 32 51 e3		.dtogset:  ld (os_view_disable), a 
9202 c3 df 91			jp .debug_tog 
9205			 
9205			 
9205			hardware_diags:       
9205			 
9205			.diagm: 
9205 21 18 92			ld hl, .menuitems 
9208 3e 00			ld a, 0 
920a cd ae 88			call menu 
920d			 
920d fe 00		         cp 0 
920f c8				 ret z 
9210			 
9210 fe 02			cp 2 
9212 ca 71 92			jp z, .diagedit 
9215			 
9215			;	cp '6' 
9215			;	jp z, .menutest 
9215			;if ENABLE_BASIC 
9215			;	cp '6' 
9215			;	jp z, basic 
9215			;endif 
9215			  
9215 c3 05 92			jp .diagm 
9218			 
9218				 
9218 2c 92		.menuitems:   	dw .m1 
921a 37 92				dw .m2 
921c 3e 92				dw .m3 
921e 46 92				dw .m5 
9220 4c 92				dw .m5a 
9222 55 92				dw .m5b 
9224 00 00				dw 0 
9226			 
9226			.menudebug: 
9226 5e 92				dw .m6 
9228 67 92				dw .m7 
922a 00 00				dw 0 
922c			 
922c .. 00		.m1:   db "Key Matrix",0 
9237 .. 00		.m2:   db "Editor",0 
923e .. 00		.m3:   db "Storage",0 
9246 .. 00		.m5:   db "Sound",0 
924c .. 00		.m5a:  db "RAM Test",0 
9255 .. 00		.m5b:  db "LCD Test",0 
925e			 
925e .. 00		.m6:   db "Debug ON",0 
9267 .. 00		.m7:   db "Debug OFF",0 
9271			 
9271			; debug editor 
9271			 
9271			.diagedit: 
9271			 
9271 21 60 e3			ld hl, scratch 
9274			;	ld bc, 250 
9274			;	ldir 
9274				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9274 3e 00			ld a, 0 
9276 77				ld (hl), a 
9277 23				inc hl 
9278 77				ld (hl), a 
9279 23				inc hl 
927a 77				ld (hl), a 
927b			 
927b cd 7d 88		        call clear_display 
927e cd a0 88			call update_display 
9281 3e 01			ld a, 1 
9283 32 80 ee			ld (hardware_diag), a 
9286			.diloop: 
9286 3e 00			ld a, display_row_1 
9288 0e 00			ld c, 0 
928a 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
928c 1e 28			ld e, 40 
928e			 
928e 21 60 e3			ld hl, scratch	 
9291 cd d7 8a			call input_str 
9294			 
9294 3e 28			ld a, display_row_2 
9296 11 60 e3			ld de, scratch 
9299 cd 90 88			call str_at_display 
929c cd a0 88			call update_display 
929f			 
929f c3 86 92			jp .diloop 
92a2			 
92a2			 
92a2			; pass word in hl 
92a2			; a has display location 
92a2			display_word_at: 
92a2 f5				push af 
92a3 e5				push hl 
92a4 7c				ld a,h 
92a5 21 65 e6			ld hl, os_word_scratch 
92a8 cd ab 8d			call hexout 
92ab e1				pop hl 
92ac 7d				ld a,l 
92ad 21 67 e6			ld hl, os_word_scratch+2 
92b0 cd ab 8d			call hexout 
92b3 21 69 e6			ld hl, os_word_scratch+4 
92b6 3e 00			ld a,0 
92b8 77				ld (hl),a 
92b9 11 65 e6			ld de,os_word_scratch 
92bc f1				pop af 
92bd cd 90 88				call str_at_display 
92c0 c9				ret 
92c1			 
92c1			display_ptr_state: 
92c1			 
92c1				; to restore afterwards 
92c1			 
92c1 d5				push de 
92c2 c5				push bc 
92c3 e5				push hl 
92c4 f5				push af 
92c5			 
92c5				; for use in here 
92c5			 
92c5			;	push bc 
92c5			;	push de 
92c5			;	push hl 
92c5			;	push af 
92c5			 
92c5 cd 7d 88			call clear_display 
92c8			 
92c8 11 9b 94			ld de, .ptrstate 
92cb 3e 00			ld a, display_row_1 
92cd cd 90 88			call str_at_display 
92d0			 
92d0				; display debug step 
92d0			 
92d0			 
92d0 11 7a ee			ld de, debug_mark 
92d3 3e 26			ld a, display_row_1+display_cols-2 
92d5 cd 90 88			call str_at_display 
92d8			 
92d8				; display a 
92d8 11 a5 94			ld de, .ptrcliptr 
92db 3e 28			ld a, display_row_2 
92dd cd 90 88			call str_at_display 
92e0			 
92e0 f1				pop af 
92e1 2a 2b eb			ld hl,(cli_ptr) 
92e4 3e 30			ld a, display_row_2+8 
92e6 cd a2 92			call display_word_at 
92e9			 
92e9			 
92e9				; display hl 
92e9			 
92e9			 
92e9 11 ad 94			ld de, .ptrclioptr 
92ec 3e 32			ld a, display_row_2+10 
92ee cd 90 88			call str_at_display 
92f1			; 
92f1			;	pop hl 
92f1 3e 35			ld a, display_row_2+13 
92f3 2a 29 eb			ld hl,(cli_origptr) 
92f6 cd a2 92			call display_word_at 
92f9			; 
92f9			;	 
92f9			;	; display de 
92f9			 
92f9			;	ld de, .regstatede 
92f9			;	ld a, display_row_3 
92f9			;	call str_at_display 
92f9			 
92f9			;	pop de 
92f9			;	ld h,d 
92f9			;	ld l, e 
92f9			;	ld a, display_row_3+3 
92f9			;	call display_word_at 
92f9			 
92f9			 
92f9				; display bc 
92f9			 
92f9			;	ld de, .regstatebc 
92f9			;	ld a, display_row_3+10 
92f9			;	call str_at_display 
92f9			 
92f9			;	pop bc 
92f9			;	ld h,b 
92f9			;	ld l, c 
92f9			;	ld a, display_row_3+13 
92f9			;	call display_word_at 
92f9			 
92f9			 
92f9				; display dsp 
92f9			 
92f9			;	ld de, .regstatedsp 
92f9			;	ld a, display_row_4 
92f9			;	call str_at_display 
92f9			 
92f9				 
92f9			;	ld hl,(cli_data_sp) 
92f9			;	ld a, display_row_4+4 
92f9			;	call display_word_at 
92f9			 
92f9				; display rsp 
92f9			 
92f9 11 dc 94			ld de, .regstatersp 
92fc 3e 82			ld a, display_row_4+10 
92fe cd 90 88			call str_at_display 
9301			 
9301				 
9301 2a 11 eb			ld hl,(cli_ret_sp) 
9304 3e 86			ld a, display_row_4+14 
9306 cd a2 92			call display_word_at 
9309			 
9309 cd a0 88			call update_display 
930c			 
930c cd fd 87			call delay1s 
930f cd fd 87			call delay1s 
9312 cd fd 87			call delay1s 
9315			 
9315			 
9315 cd 22 98			call next_page_prompt 
9318			 
9318				; restore  
9318			 
9318 f1				pop af 
9319 e1				pop hl 
931a c1				pop bc 
931b d1				pop de 
931c c9				ret 
931d			 
931d			break_point_state: 
931d f5				push af 
931e			 
931e				; see if disabled 
931e			 
931e 3a 51 e3			ld a, (os_view_disable) 
9321 fe 2a			cp '*' 
9323 20 02			jr nz, .bpsgo 
9325 f1				pop af 
9326 c9				ret 
9327			 
9327			.bpsgo: 
9327 f1				pop af 
9328 f5				push af 
9329 22 4d e3			ld (os_view_hl), hl 
932c ed 53 4b e3		ld (os_view_de), de 
9330 ed 43 49 e3		ld (os_view_bc), bc 
9334 e5				push hl 
9335 6f				ld l, a 
9336 26 00			ld h, 0 
9338 22 4f e3			ld (os_view_af),hl 
933b			 
933b 21 c0 ed				ld hl, display_fb0 
933e 22 db eb				ld (display_fb_active), hl 
9341 e1				pop hl	 
9342			 
9342 3e 31			ld a, '1' 
9344 fe 2a		.bps1:  cp '*' 
9346 20 03			jr nz, .bps1b 
9348 32 51 e3			ld (os_view_disable),a 
934b fe 31		.bps1b:  cp '1' 
934d 20 14			jr nz, .bps2 
934f			 
934f				; display reg 
934f			 
934f				 
934f			 
934f 3a 4f e3			ld a, (os_view_af) 
9352 2a 4d e3			ld hl, (os_view_hl) 
9355 ed 5b 4b e3		ld de, (os_view_de) 
9359 ed 4b 49 e3		ld bc, (os_view_bc) 
935d cd f7 93			call display_reg_state 
9360 c3 e3 93			jp .bpschk 
9363			 
9363 fe 32		.bps2:  cp '2' 
9365 20 08			jr nz, .bps3 
9367				 
9367				; display hl 
9367 2a 4d e3			ld hl, (os_view_hl) 
936a cd e1 94			call display_dump_at_hl 
936d			 
936d 18 74			jr .bpschk 
936f			 
936f fe 33		.bps3:  cp '3' 
9371 20 08			jr nz, .bps4 
9373			 
9373			        ; display de 
9373 2a 4b e3			ld hl, (os_view_de) 
9376 cd e1 94			call display_dump_at_hl 
9379			 
9379 18 68			jr .bpschk 
937b fe 34		.bps4:  cp '4' 
937d 20 08			jr nz, .bps5 
937f			 
937f			        ; display bc 
937f 2a 49 e3			ld hl, (os_view_bc) 
9382 cd e1 94			call display_dump_at_hl 
9385			 
9385 18 5c			jr .bpschk 
9387 fe 35		.bps5:  cp '5' 
9389 20 08		        jr nz, .bps7 
938b			 
938b				; display cur ptr 
938b 2a 2b eb			ld hl, (cli_ptr) 
938e cd e1 94			call display_dump_at_hl 
9391			 
9391 18 50			jr .bpschk 
9393 fe 36		.bps7:  cp '6' 
9395 20 08			jr nz, .bps8b 
9397				 
9397				; display cur orig ptr 
9397 2a 29 eb			ld hl, (cli_origptr) 
939a cd e1 94			call display_dump_at_hl 
939d 18 44			jr .bpschk 
939f fe 37		.bps8b:  cp '7' 
93a1 20 08			jr nz, .bps9 
93a3				 
93a3				; display dsp 
93a3 2a 0d eb			ld hl, (cli_data_sp) 
93a6 cd e1 94			call display_dump_at_hl 
93a9			 
93a9 18 38			jr .bpschk 
93ab fe 39		.bps9:  cp '9' 
93ad 20 05			jr nz, .bps8c 
93af				 
93af				; display SP 
93af			;	ld hl, sp 
93af cd e1 94			call display_dump_at_hl 
93b2			 
93b2 18 2f			jr .bpschk 
93b4 fe 38		.bps8c:  cp '8' 
93b6 20 08			jr nz, .bps8d 
93b8				 
93b8				; display rsp 
93b8 2a 11 eb			ld hl, (cli_ret_sp) 
93bb cd e1 94			call display_dump_at_hl 
93be			 
93be 18 23			jr .bpschk 
93c0 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
93c2 20 05			jr nz, .bps8 
93c4 cd 18 96			call monitor 
93c7			 
93c7 18 1a			jr .bpschk 
93c9 fe 30		.bps8:  cp '0' 
93cb 20 16			jr nz, .bpschk 
93cd			 
93cd 21 1f ed				ld hl, display_fb1 
93d0 22 db eb				ld (display_fb_active), hl 
93d3 cd a0 88				call update_display 
93d6			 
93d6				;ld a, (os_view_af) 
93d6 2a 4d e3			ld hl, (os_view_hl) 
93d9 ed 5b 4b e3		ld de, (os_view_de) 
93dd ed 4b 49 e3		ld bc, (os_view_bc) 
93e1 f1				pop af 
93e2 c9				ret 
93e3			 
93e3			.bpschk:   
93e3 cd fd 87			call delay1s 
93e6 3e 9f		ld a,display_row_4 + display_cols - 1 
93e8 11 20 98		        ld de, endprg 
93eb cd 90 88			call str_at_display 
93ee cd a0 88			call update_display 
93f1 cd 33 d7			call cin_wait 
93f4			 
93f4 c3 44 93			jp .bps1 
93f7			 
93f7			 
93f7			display_reg_state: 
93f7			 
93f7				; to restore afterwards 
93f7			 
93f7 d5				push de 
93f8 c5				push bc 
93f9 e5				push hl 
93fa f5				push af 
93fb			 
93fb				; for use in here 
93fb			 
93fb c5				push bc 
93fc d5				push de 
93fd e5				push hl 
93fe f5				push af 
93ff			 
93ff cd 7d 88			call clear_display 
9402			 
9402 11 b7 94			ld de, .regstate 
9405 3e 00			ld a, display_row_1 
9407 cd 90 88			call str_at_display 
940a			 
940a				; display debug step 
940a			 
940a			 
940a 11 7a ee			ld de, debug_mark 
940d 3e 25			ld a, display_row_1+display_cols-3 
940f cd 90 88			call str_at_display 
9412			 
9412				; display a 
9412 11 d3 94			ld de, .regstatea 
9415 3e 28			ld a, display_row_2 
9417 cd 90 88			call str_at_display 
941a			 
941a e1				pop hl 
941b			;	ld h,0 
941b			;	ld l, a 
941b 3e 2b			ld a, display_row_2+3 
941d cd a2 92			call display_word_at 
9420			 
9420			 
9420				; display hl 
9420			 
9420			 
9420 11 c7 94			ld de, .regstatehl 
9423 3e 32			ld a, display_row_2+10 
9425 cd 90 88			call str_at_display 
9428			 
9428 e1				pop hl 
9429 3e 35			ld a, display_row_2+13 
942b cd a2 92			call display_word_at 
942e			 
942e				 
942e				; display de 
942e			 
942e 11 cb 94			ld de, .regstatede 
9431 3e 50			ld a, display_row_3 
9433 cd 90 88			call str_at_display 
9436			 
9436 e1				pop hl 
9437			;	ld h,d 
9437			;	ld l, e 
9437 3e 53			ld a, display_row_3+3 
9439 cd a2 92			call display_word_at 
943c			 
943c			 
943c				; display bc 
943c			 
943c 11 cf 94			ld de, .regstatebc 
943f 3e 5a			ld a, display_row_3+10 
9441 cd 90 88			call str_at_display 
9444			 
9444 e1				pop hl 
9445			;	ld h,b 
9445			;	ld l, c 
9445 3e 5d			ld a, display_row_3+13 
9447 cd a2 92			call display_word_at 
944a			 
944a			 
944a				; display dsp 
944a			 
944a 11 d7 94			ld de, .regstatedsp 
944d 3e 78			ld a, display_row_4 
944f cd 90 88			call str_at_display 
9452			 
9452				 
9452 2a 0d eb			ld hl,(cli_data_sp) 
9455 3e 7c			ld a, display_row_4+4 
9457 cd a2 92			call display_word_at 
945a			 
945a				; display rsp 
945a			 
945a 11 dc 94			ld de, .regstatersp 
945d 3e 82			ld a, display_row_4+10 
945f cd 90 88			call str_at_display 
9462			 
9462				 
9462 2a 11 eb			ld hl,(cli_ret_sp) 
9465 3e 86			ld a, display_row_4+14 
9467 cd a2 92			call display_word_at 
946a			 
946a cd a0 88			call update_display 
946d			 
946d			;	call delay1s 
946d			;	call delay1s 
946d			;	call delay1s 
946d			 
946d			 
946d			;	call next_page_prompt 
946d			 
946d				; restore  
946d			 
946d f1				pop af 
946e e1				pop hl 
946f c1				pop bc 
9470 d1				pop de 
9471 c9				ret 
9472			 
9472 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
9486 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
949b .. 00		.ptrstate:	db "Ptr State",0 
94a5 .. 00		.ptrcliptr:     db "cli_ptr",0 
94ad .. 00		.ptrclioptr:     db "cli_o_ptr",0 
94b7 .. 00		.regstate:	db "Reg State (1/0)",0 
94c7 .. 00		.regstatehl:	db "HL:",0 
94cb .. 00		.regstatede:	db "DE:",0 
94cf .. 00		.regstatebc:	db "BC:",0 
94d3 .. 00		.regstatea:	db "A :",0 
94d7 .. 00		.regstatedsp:	db "DSP:",0 
94dc .. 00		.regstatersp:	db "RSP:",0 
94e1			 
94e1			display_dump_at_hl: 
94e1 e5				push hl 
94e2 d5				push de 
94e3 c5				push bc 
94e4 f5				push af 
94e5			 
94e5 22 83 e6			ld (os_cur_ptr),hl	 
94e8 cd 7d 88			call clear_display 
94eb cd 2a 97			call dumpcont 
94ee			;	call delay1s 
94ee			;	call next_page_prompt 
94ee			 
94ee			 
94ee f1				pop af 
94ef c1				pop bc 
94f0 d1				pop de 
94f1 e1				pop hl 
94f2 c9				ret 
94f3			 
94f3			;if ENABLE_BASIC 
94f3			;	include "nascombasic.asm" 
94f3			;	basic: 
94f3			;	include "forth/FORTH.ASM" 
94f3			;endif 
94f3			 
94f3			; eof 
94f3			 
94f3			 
# End of file firmware_diags.asm
94f3			  
94f3			  
94f3			  
94f3			  
94f3			; eof  
94f3			  
# End of file firmware.asm
94f3			 
94f3			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
94f3			;if BASE_KEV  
94f3			;baseram: equ 08000h 
94f3			;endif 
94f3			 
94f3			;if BASE_SC114 
94f3			;baseram:     equ    endofcode 
94f3			;endif 
94f3			 
94f3			 
94f3			; start system 
94f3			 
94f3			coldstart: 
94f3				; set sp 
94f3				; di/ei 
94f3			 
94f3 f3				di 
94f4 31 00 f0			ld sp, tos 
94f7			;	ei 
94f7			 
94f7			 
94f7				; disable breakpoint by default 
94f7			 
94f7 3e 2a			ld a,'*' 
94f9 32 51 e3			ld (os_view_disable),a 
94fc			 
94fc				; init hardware 
94fc			 
94fc				; init keyboard and screen hardware 
94fc			 
94fc cd 03 80			call hardware_init 
94ff			 
94ff			 
94ff				; detect if any keys are held down to enable breakpoints at start up 
94ff			 
94ff cd 39 d7			call cin  
9502 fe 00			cp 0 
9504 28 03			jr z, .nokeys 
9506			 
9506				;call hardware_diags 
9506 cd 0a 91			call config 
9509			 
9509			;	ld de, .bpen 
9509			;	ld a, display_row_4 
9509			;	call str_at_display 
9509			;	call update_display 
9509			; 
9509			;	ld a,0 
9509			;	ld (os_view_disable),a 
9509			; 
9509			;.bpwait: 
9509			;	call cin 
9509			;	cp 0 
9509			;	jr z, .bpwait 
9509			;	jr .nokeys 
9509			; 
9509			; 
9509			;.bpen:  db "Break points enabled!",0 
9509			 
9509			 
9509			 
9509			 
9509			 
9509			 
9509			.nokeys: 
9509			 
9509			 
9509				 
9509			 
9509			;jp  testkey 
9509			 
9509			;call storage_get_block_0 
9509			; 
9509			;ld hl, 0 
9509			;ld de, store_page 
9509			;call storage_read_block 
9509			 
9509				 
9509			;ld hl, 10 
9509			;ld de, store_page 
9509			;call storage_read_block 
9509			 
9509			 
9509			 
9509			 
9509			 
9509			;stop:	nop 
9509			;	jp stop 
9509			 
9509			 
9509			 
9509			main: 
9509 cd 7d 88			call clear_display 
950c cd a0 88			call update_display 
950f			 
950f			 
950f			 
950f			;	call testlcd 
950f			 
950f			 
950f			 
950f cd e8 9b			call forth_init 
9512			 
9512			 
9512			warmstart: 
9512 cd be 9b			call forth_warmstart 
9515			 
9515				; run startup word load 
9515			        ; TODO prevent this running at warmstart after crash  
9515			 
9515				if STARTUP_ENABLE 
9515					if STORAGE_SE 
9515						call forth_autoload 
9515					endif 
9515 cd cd d3				call forth_startup 
9518			 
9518			 
9518				endif 
9518			 
9518				; show free memory after boot 
9518 11 b2 95			ld de, freeram 
951b 3e 00			ld a, display_row_1 
951d cd 90 88			call str_at_display 
9520			 
9520			; Or use heap_size word???? 
9520 21 46 e3			ld hl, heap_end 
9523 11 57 d7			ld de, heap_start 
9526 ed 52			sbc hl, de 
9528 e5				push hl 
9529 7c				ld a,h	         	 
952a 21 65 e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
952d cd ab 8d			call hexout 
9530 e1			   	pop hl 
9531			 
9531 7d				ld a,l 
9532 21 67 e6			ld hl, os_word_scratch+2 
9535 cd ab 8d			call hexout 
9538 21 69 e6			ld hl, os_word_scratch+4 
953b 3e 00			ld a, 0 
953d 77				ld (hl),a 
953e 11 65 e6			ld de, os_word_scratch 
9541 3e 0d			ld a, display_row_1 + 13 
9543 cd 90 88			call str_at_display 
9546 cd a0 88			call update_display 
9549			 
9549			 
9549				;call demo 
9549			 
9549			 
9549				; init scratch input area for cli commands 
9549			 
9549 21 87 e6			ld hl, os_cli_cmd 
954c 3e 00			ld a,0 
954e 77				ld (hl),a 
954f 23				inc hl 
9550 77				ld (hl),a 
9551			 
9551 3e 00			ld a,0 
9553 32 86 e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
9556			 
9556 32 83 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
9559 32 84 e6			ld (os_cur_ptr+1),a	 
955c			 
955c 32 65 e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
955f 32 66 e6			ld (os_word_scratch+1),a	 
9562				 
9562			 
9562				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9562 21 87 e6			ld hl, os_cli_cmd 
9565			 
9565 3e 00			ld a, 0		 ; init cli input 
9567 77				ld (hl), a 
9568 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
956a			cli: 
956a				; show cli prompt 
956a				;push af 
956a				;ld a, 0 
956a				;ld de, prompt 
956a				;call str_at_display 
956a			 
956a				;call update_display 
956a				;pop af 
956a				;inc a 
956a				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
956a 0e 00			ld c, 0 
956c 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
956e 1e 28			ld e, 40 
9570			 
9570 21 87 e6			ld hl, os_cli_cmd 
9573			 
9573				STACKFRAME OFF $fefe $9f9f 
9573				if DEBUG_STACK_IMB 
9573					if OFF 
9573						exx 
9573						ld de, $fefe 
9573						ld a, d 
9573						ld hl, curframe 
9573						call hexout 
9573						ld a, e 
9573						ld hl, curframe+2 
9573						call hexout 
9573						ld hl, $fefe 
9573						push hl 
9573						ld hl, $9f9f 
9573						push hl 
9573						exx 
9573					endif 
9573				endif 
9573			endm 
# End of macro STACKFRAME
9573			 
9573 cd d7 8a			call input_str 
9576			 
9576				STACKFRAMECHK OFF $fefe $9f9f 
9576				if DEBUG_STACK_IMB 
9576					if OFF 
9576						exx 
9576						ld hl, $9f9f 
9576						pop de   ; $9f9f 
9576						call cmp16 
9576						jr nz, .spnosame 
9576						ld hl, $fefe 
9576						pop de   ; $fefe 
9576						call cmp16 
9576						jr z, .spfrsame 
9576						.spnosame: call showsperror 
9576						.spfrsame: nop 
9576						exx 
9576					endif 
9576				endif 
9576			endm 
# End of macro STACKFRAMECHK
9576			 
9576				; copy input to last command 
9576			 
9576 21 87 e6			ld hl, os_cli_cmd 
9579 11 86 e7			ld de, os_last_cmd 
957c 01 ff 00			ld bc, 255 
957f ed b0			ldir 
9581			 
9581				; wipe current buffer 
9581			 
9581			;	ld a, 0 
9581			;	ld hl, os_cli_cmd 
9581			;	ld de, os_cli_cmd+1 
9581			;	ld bc, 254 
9581			;	ldir 
9581				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9581			;	call strcpy 
9581			;	ld a, 0 
9581			;	ld (hl), a 
9581			;	inc hl 
9581			;	ld (hl), a 
9581			;	inc hl 
9581			;	ld (hl), a 
9581			 
9581				; switch frame buffer to program  
9581			 
9581 21 1f ed				ld hl, display_fb1 
9584 22 db eb				ld (display_fb_active), hl 
9587			 
9587			;	nop 
9587				STACKFRAME ON $fbfe $8f9f 
9587				if DEBUG_STACK_IMB 
9587					if ON 
9587						exx 
9587						ld de, $fbfe 
9587						ld a, d 
9587						ld hl, curframe 
9587						call hexout 
9587						ld a, e 
9587						ld hl, curframe+2 
9587						call hexout 
9587						ld hl, $fbfe 
9587						push hl 
9587						ld hl, $8f9f 
9587						push hl 
9587						exx 
9587					endif 
9587				endif 
9587			endm 
# End of macro STACKFRAME
9587				; first time into the parser so pass over the current scratch pad 
9587 21 87 e6			ld hl,os_cli_cmd 
958a				; tokenise the entered statement(s) in HL 
958a cd 61 9c			call forthparse 
958d			        ; exec forth statements in top of return stack 
958d cd a1 9c			call forthexec 
9590				;call forthexec_cleanup 
9590			;	call parsenext 
9590			 
9590				STACKFRAMECHK ON $fbfe $8f9f 
9590				if DEBUG_STACK_IMB 
9590					if ON 
9590						exx 
9590						ld hl, $8f9f 
9590						pop de   ; $8f9f 
9590						call cmp16 
9590						jr nz, .spnosame 
9590						ld hl, $fbfe 
9590						pop de   ; $fbfe 
9590						call cmp16 
9590						jr z, .spfrsame 
9590						.spnosame: call showsperror 
9590						.spfrsame: nop 
9590						exx 
9590					endif 
9590				endif 
9590			endm 
# End of macro STACKFRAMECHK
9590				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
9590			 
9590 3e 78			ld a, display_row_4 
9592 11 c4 95			ld de, endprog 
9595			 
9595 cd a0 88			call update_display		 
9598			 
9598 cd 22 98			call next_page_prompt 
959b			 
959b				; switch frame buffer to cli 
959b			 
959b 21 c0 ed				ld hl, display_fb0 
959e 22 db eb				ld (display_fb_active), hl 
95a1			 
95a1			 
95a1 cd 7d 88		        call clear_display 
95a4 cd a0 88			call update_display		 
95a7			 
95a7 21 87 e6			ld hl, os_cli_cmd 
95aa			 
95aa 3e 00			ld a, 0		 ; init cli input 
95ac 77				ld (hl), a 
95ad			 
95ad				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
95ad			 
95ad				; now on last line 
95ad			 
95ad				; TODO scroll screen up 
95ad			 
95ad				; TODO instead just clear screen and place at top of screen 
95ad			 
95ad			;	ld a, 0 
95ad			;	ld (f_cursor_ptr),a 
95ad			 
95ad				;call clear_display 
95ad				;call update_display 
95ad			 
95ad				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
95ad 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
95af c3 6a 95			jp cli 
95b2			 
95b2 .. 00		freeram: db "Free bytes: $",0 
95c0 ..			asc: db "1A2F" 
95c4 .. 00		endprog: db "End prog...",0 
95d0			 
95d0			testenter2:   
95d0 21 92 e3			ld hl,scratch+50 
95d3 22 83 e6			ld (os_cur_ptr),hl 
95d6 c3 6a 95			jp cli 
95d9			 
95d9			testenter:  
95d9			 
95d9 21 c0 95			ld hl,asc 
95dc			;	ld a,(hl) 
95dc			;	call nibble2val 
95dc cd 01 8e			call get_byte 
95df			 
95df			 
95df			;	ld a,(hl) 
95df			;	call atohex 
95df			 
95df			;	call fourehexhl 
95df 32 92 e3			ld (scratch+50),a 
95e2			 
95e2			 
95e2			 
95e2 21 c2 95			ld hl,asc+2 
95e5			;	ld a, (hl) 
95e5			;	call nibble2val 
95e5 cd 01 8e			call get_byte 
95e8			 
95e8			;	call fourehexhl 
95e8 32 94 e3			ld (scratch+52),a 
95eb				 
95eb 21 92 e3			ld hl,scratch+50 
95ee 22 83 e6			ld (os_cur_ptr),hl 
95f1 c3 6a 95			jp cli 
95f4			 
95f4			enter:	 
95f4 3a 64 e3			ld a,(scratch+4) 
95f7 fe 00			cp 0 
95f9 28 0c			jr z, .entercont 
95fb				; no, not a null term line so has an address to work out.... 
95fb			 
95fb 21 62 e3			ld hl,scratch+2 
95fe cd 61 8e			call get_word_hl 
9601			 
9601 22 83 e6			ld (os_cur_ptr),hl	 
9604 c3 6a 95			jp cli 
9607			 
9607			 
9607			.entercont:  
9607			 
9607 21 62 e3			ld hl, scratch+2 
960a cd 01 8e			call get_byte 
960d			 
960d 2a 83 e6		   	ld hl,(os_cur_ptr) 
9610 77					ld (hl),a 
9611 23					inc hl 
9612 22 83 e6				ld (os_cur_ptr),hl 
9615				 
9615			; get byte  
9615			 
9615			 
9615 c3 6a 95			jp cli 
9618			 
9618			 
9618			; basic monitor support 
9618			 
9618			monitor: 
9618				;  
9618 cd 7d 88			call clear_display 
961b 3e 00			ld a, 0 
961d 11 65 96			ld de, .monprompt 
9620 cd 90 88			call str_at_display 
9623 cd a0 88			call update_display 
9626			 
9626				; get a monitor command 
9626			 
9626 0e 00			ld c, 0     ; entry at top left 
9628 16 64			ld d, 100   ; max buffer size 
962a 1e 0f			ld e, 15    ; input scroll area 
962c 3e 00			ld a, 0     ; init string 
962e 21 5e e5			ld hl, os_input 
9631 77				ld (hl), a 
9632 23				inc hl 
9633 77				ld (hl), a 
9634 21 5e e5			ld hl, os_input 
9637 3e 01			ld a, 1     ; init string 
9639 cd d7 8a			call input_str 
963c			 
963c cd 7d 88		        call clear_display 
963f cd a0 88			call update_display		 
9642			 
9642 3a 5e e5			ld a, (os_input) 
9645 cd ff 8e			call toUpper 
9648 fe 48		        cp 'H' 
964a 28 6f		        jr z, .monhelp 
964c fe 44			cp 'D'		; dump 
964e ca dc 96			jp z, .mondump	 
9651 fe 43			cp 'C'		; dump 
9653 ca f6 96			jp z, .moncdump	 
9656 fe 4d			cp 'M'		; dump 
9658 ca 67 96			jp z, .moneditstart 
965b fe 55			cp 'U'		; dump 
965d 28 14			jr z, .monedit	 
965f fe 51			cp 'Q'		; dump 
9661 c8				ret z	 
9662			 
9662			 
9662				; TODO "S" to access symbol by name and not need the address 
9662				; TODO "F" to find a string in memory 
9662			 
9662 c3 18 96			jp monitor 
9665			 
9665 .. 00		.monprompt: db ">", 0 
9667			 
9667			.moneditstart: 
9667				; get starting address 
9667			 
9667 21 60 e5			ld hl,os_input+2 
966a cd 61 8e			call get_word_hl 
966d			 
966d 22 83 e6			ld (os_cur_ptr),hl	 
9670			 
9670 c3 18 96			jp monitor 
9673			 
9673			.monedit: 
9673				; get byte to load 
9673			 
9673 21 60 e5			ld hl,os_input+2 
9676 cd 01 8e			call get_byte 
9679			 
9679				; get address to update 
9679 2a 83 e6			ld hl, (os_cur_ptr) 
967c			 
967c				; update byte 
967c			 
967c 77				ld (hl), a 
967d			 
967d				; move to next address and save it 
967d			 
967d 23				inc hl 
967e 22 83 e6			ld (os_cur_ptr),hl	 
9681			 
9681 c3 18 96			jp monitor 
9684			 
9684			 
9684 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
9698 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
96b4 .. 00		.monhelptext3:  db "Q-Quit",0 
96bb			        
96bb			.monhelp: 
96bb 3e 00			ld a, display_row_1 
96bd 11 84 96		        ld de, .monhelptext1 
96c0			 
96c0 cd 90 88			call str_at_display 
96c3 3e 28			ld a, display_row_2 
96c5 11 98 96		        ld de, .monhelptext2 
96c8					 
96c8 cd 90 88			call str_at_display 
96cb 3e 50			ld a, display_row_3 
96cd 11 b4 96		        ld de, .monhelptext3 
96d0					 
96d0 cd 90 88			call str_at_display 
96d3 cd a0 88			call update_display		 
96d6			 
96d6 cd 22 98			call next_page_prompt 
96d9 c3 18 96			jp monitor 
96dc			 
96dc			.mondump:    
96dc 21 60 e5			ld hl,os_input+2 
96df cd 61 8e			call get_word_hl 
96e2			 
96e2 22 83 e6			ld (os_cur_ptr),hl	 
96e5 cd 2a 97			call dumpcont 
96e8 3e 78			ld a, display_row_4 
96ea 11 c4 95			ld de, endprog 
96ed			 
96ed cd a0 88			call update_display		 
96f0			 
96f0 cd 22 98			call next_page_prompt 
96f3 c3 18 96			jp monitor 
96f6			.moncdump: 
96f6 cd 2a 97			call dumpcont 
96f9 3e 78			ld a, display_row_4 
96fb 11 c4 95			ld de, endprog 
96fe			 
96fe cd a0 88			call update_display		 
9701			 
9701 cd 22 98			call next_page_prompt 
9704 c3 18 96			jp monitor 
9707			 
9707			 
9707			; TODO symbol access  
9707			 
9707			.symbols:     ;; A list of symbols that can be called up  
9707 c0 ed			dw display_fb0 
9709 .. 00			db "fb0",0  
970d 65 eb		     	dw store_page 
970f .. 00			db "store_page",0 
971a			 
971a			 
971a			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
971a			 
971a 3a 61 e3			ld a,(scratch+1) 
971d fe 00			cp 0 
971f 28 09			jr z, dumpcont 
9721			 
9721				; no, not a null term line so has an address to work out.... 
9721			 
9721 21 62 e3			ld hl,scratch+2 
9724 cd 61 8e			call get_word_hl 
9727			 
9727 22 83 e6			ld (os_cur_ptr),hl	 
972a			 
972a			 
972a			 
972a			dumpcont: 
972a			 
972a				; dump bytes at ptr 
972a			 
972a			 
972a 3e 00			ld a, display_row_1 
972c 2a db eb			ld hl, (display_fb_active) 
972f cd aa 8a			call addatohl 
9732 cd 5a 97			call .dumpbyterow 
9735			 
9735 3e 28			ld a, display_row_2 
9737 2a db eb			ld hl, (display_fb_active) 
973a cd aa 8a			call addatohl 
973d cd 5a 97			call .dumpbyterow 
9740			 
9740			 
9740 3e 50			ld a, display_row_3 
9742 2a db eb			ld hl, (display_fb_active) 
9745 cd aa 8a			call addatohl 
9748 cd 5a 97			call .dumpbyterow 
974b			 
974b 3e 78			ld a, display_row_4 
974d 2a db eb			ld hl, (display_fb_active) 
9750 cd aa 8a			call addatohl 
9753 cd 5a 97			call .dumpbyterow 
9756			 
9756 cd a0 88			call update_display 
9759			;		jp cli 
9759 c9				ret 
975a			 
975a			.dumpbyterow: 
975a			 
975a				;push af 
975a			 
975a e5				push hl 
975b			 
975b				; calc where to poke the ascii 
975b			if display_cols == 20 
975b				ld a, 16 
975b			else 
975b 3e 1f			ld a, 31 
975d			endif 
975d			 
975d cd aa 8a			call addatohl 
9760 22 65 e6			ld (os_word_scratch),hl  		; save pos for later 
9763			 
9763			 
9763			; display decoding address 
9763 2a 83 e6		   	ld hl,(os_cur_ptr) 
9766			 
9766 7c				ld a,h 
9767 e1				pop hl 
9768 e5				push hl 
9769			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9769 cd ab 8d			call hexout 
976c 2a 83 e6		   	ld hl,(os_cur_ptr) 
976f			 
976f 7d				ld a,l 
9770 e1				pop hl 
9771 23				inc hl 
9772 23				inc hl 
9773 e5				push hl 
9774			;	ld hl, os_word_scratch+2 
9774 cd ab 8d			call hexout 
9777 e1				pop hl 
9778 23				inc hl 
9779 23				inc hl 
977a				;ld hl, os_word_scratch+4 
977a 3e 3a			ld a, ':' 
977c 77				ld (hl),a 
977d 23				inc hl 
977e				;ld a, 0 
977e				;ld (hl),a 
977e				;ld de, os_word_scratch 
977e				;pop af 
977e				;push af 
977e			;		ld a, display_row_2 
977e			;		call str_at_display 
977e			;		call update_display 
977e			 
977e			 
977e			;pop af 
977e			;	add 5 
977e			 
977e			if display_cols == 20 
977e				ld b, 4 
977e			else 
977e 06 08			ld b, 8 
9780			endif	 
9780			 
9780			.dumpbyte: 
9780 c5				push bc 
9781 e5				push hl 
9782			 
9782			 
9782 2a 83 e6		   	ld hl,(os_cur_ptr) 
9785 7e					ld a,(hl) 
9786			 
9786					; poke the ascii to display 
9786 2a 65 e6				ld hl,(os_word_scratch) 
9789 77					ld (hl),a 
978a 23					inc hl 
978b 22 65 e6				ld (os_word_scratch),hl 
978e			 
978e					 
978e			 
978e			 
978e e1					pop hl 
978f e5					push hl 
9790			 
9790 cd ab 8d				call hexout 
9793			 
9793					 
9793 2a 83 e6		   	ld hl,(os_cur_ptr) 
9796 23				inc hl 
9797 22 83 e6		   	ld (os_cur_ptr),hl 
979a			 
979a e1					pop hl 
979b 23					inc hl 
979c 23					inc hl 
979d 23					inc hl 
979e			 
979e			 
979e			 
979e					;ld a,0 
979e					;ld (os_word_scratch+2),a 
979e					;pop af 
979e					;push af 
979e			 
979e					;ld de, os_word_scratch 
979e					;call str_at_display 
979e			;		call update_display 
979e			;		pop af 
979e c1					pop bc 
979f c6 03				add 3 
97a1 10 dd			djnz .dumpbyte 
97a3			 
97a3				 
97a3			 
97a3 c9				ret 
97a4			 
97a4			jump:	 
97a4			 
97a4 21 62 e3			ld hl,scratch+2 
97a7 cd 61 8e			call get_word_hl 
97aa				;ld hl,(scratch+2) 
97aa				;call fourehexhl 
97aa			 
97aa 22 83 e6			ld (os_cur_ptr),hl	 
97ad			 
97ad e9				jp (hl) 
97ae			 
97ae			 
97ae			 
97ae			; TODO implement a basic monitor mode to start with 
97ae			 
97ae			 
97ae			 
97ae			 
97ae			 
97ae			 
97ae			 
97ae			 
97ae			 
97ae			; testing and demo code during development 
97ae			 
97ae			 
97ae .. 00		str1: db "Enter some text...",0 
97c1 .. 00		clear: db "                    ",0 
97d6			 
97d6			demo: 
97d6			 
97d6			 
97d6			 
97d6			;	call update_display 
97d6			 
97d6				; init scratch input area for testing 
97d6 21 60 e3			ld hl, scratch	 
97d9 3e 00			ld a,0 
97db 77				ld (hl),a 
97dc			 
97dc			 
97dc 3e 28		            LD   A, display_row_2 
97de			;            CALL fLCD_Pos       ;Position cursor to location in A 
97de 11 ae 97		            LD   DE, str1 
97e1 cd 90 88			call str_at_display 
97e4			 
97e4			;            CALL fLCD_Str       ;Display string pointed to by DE 
97e4			cloop:	 
97e4 3e 50		            LD   A, display_row_3 
97e6			;            CALL fLCD_Pos       ;Position cursor to location in A 
97e6 11 c1 97		            LD   DE, clear 
97e9			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
97e9 cd 90 88				call str_at_display 
97ec 3e 78			ld a, display_row_4 
97ee 11 1e 98			ld de, prompt 
97f1			 
97f1 cd 90 88				call str_at_display 
97f4 cd a0 88			call update_display 
97f7			 
97f7 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
97f9 16 0a			ld d, 10 
97fb 21 60 e3			ld hl, scratch	 
97fe cd d7 8a			call input_str 
9801			 
9801			;	call clear_display 
9801			;'	call update_display 
9801			 
9801 3e 00		            LD   A, display_row_1 
9803			;            CALL fLCD_Pos       ;Position cursor to location in A 
9803 11 c1 97		            LD   DE, clear 
9806 cd 90 88				call str_at_display 
9809			;            CALL fLCD_Str       ;Display string pointed to by DE 
9809 3e 00		            LD   A, display_row_1 
980b			;            CALL fLCD_Pos       ;Position cursor to location in A 
980b 11 60 e3		            LD   DE, scratch 
980e			;            CALL fLCD_Str       ;Display string pointed to by DE 
980e cd 90 88				call str_at_display 
9811 cd a0 88			call update_display 
9814			 
9814 3e 00				ld a,0 
9816 21 60 e3			ld hl, scratch 
9819 77				ld (hl),a 
981a			 
981a 00				nop 
981b c3 e4 97			jp cloop 
981e			 
981e			 
981e			 
981e			; OS Prompt 
981e			 
981e .. 00		prompt: db ">",0 
9820 .. 00		endprg: db "?",0 
9822			 
9822			 
9822			; handy next page prompt 
9822			next_page_prompt: 
9822 e5				push hl 
9823 d5				push de 
9824 f5				push af 
9825 c5				push bc 
9826			 
9826 3e 9f			ld a,display_row_4 + display_cols - 1 
9828 11 20 98		        ld de, endprg 
982b cd 90 88			call str_at_display 
982e cd a0 88			call update_display 
9831 cd 33 d7			call cin_wait 
9834 c1				pop bc 
9835 f1				pop af 
9836 d1				pop de 
9837 e1				pop hl 
9838			 
9838			 
9838 c9				ret 
9839			 
9839			 
9839			; forth parser 
9839			 
9839			; My forth kernel 
9839			include "forth_kernel.asm" 
9839			; 
9839			; kernel to the forth OS 
9839			 
9839			DS_TYPE_STR: equ 1     ; string type 
9839			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9839			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9839			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9839			 
9839			FORTH_PARSEV1: equ 0 
9839			FORTH_PARSEV2: equ 0 
9839			FORTH_PARSEV3: equ 0 
9839			FORTH_PARSEV4: equ 0 
9839			FORTH_PARSEV5: equ 1 
9839			 
9839			;if FORTH_PARSEV5 
9839			;	FORTH_END_BUFFER: equ 0 
9839			;else 
9839			FORTH_END_BUFFER: equ 127 
9839			;endif 
9839			 
9839			FORTH_TRUE: equ 1 
9839			FORTH_FALSE: equ 0 
9839			 
9839			if FORTH_PARSEV4 
9839			include "forth_stackops.asm" 
9839			endif 
9839			 
9839			if FORTH_PARSEV5 
9839			include "forth_stackopsv5.asm" 
9839			 
9839			; Stack operations for v5 parser on wards 
9839			; * DATA stack 
9839			; * LOOP stack 
9839			; * RETURN stack 
9839			 
9839			 
9839			 
9839			FORTH_CHK_DSP_UNDER: macro 
9839				push hl 
9839				push de 
9839				ld hl,(cli_data_sp) 
9839				ld de, cli_data_stack 
9839				call cmp16 
9839				jp c, fault_dsp_under 
9839				pop de 
9839				pop hl 
9839				endm 
9839			 
9839			 
9839			FORTH_CHK_RSP_UNDER: macro 
9839				push hl 
9839				push de 
9839				ld hl,(cli_ret_sp) 
9839				ld de, cli_ret_stack 
9839				call cmp16 
9839				jp c, fault_rsp_under 
9839				pop de 
9839				pop hl 
9839				endm 
9839			 
9839			FORTH_CHK_LOOP_UNDER: macro 
9839				push hl 
9839				push de 
9839				ld hl,(cli_loop_sp) 
9839				ld de, cli_loop_stack 
9839				call cmp16 
9839				jp c, fault_loop_under 
9839				pop de 
9839				pop hl 
9839				endm 
9839			 
9839			FORTH_ERR_TOS_NOTSTR: macro 
9839				; TOSO might need more for checks when used 
9839				push af 
9839				ld a,(hl) 
9839				cp DS_TYPE_STR 
9839				jp nz, type_faultn   
9839				pop af 
9839				endm 
9839			 
9839			FORTH_ERR_TOS_NOTNUM: macro 
9839				push af 
9839				ld a,(hl) 
9839				cp DS_TYPE_INUM 
9839				jp nz, type_faultn   
9839				pop af 
9839				endm 
9839			 
9839			 
9839			; increase data stack pointer and save hl to it 
9839				 
9839			FORTH_DSP_NEXT: macro 
9839				call macro_forth_dsp_next 
9839				endm 
9839			 
9839			 
9839			macro_forth_dsp_next: 
9839				if DEBUG_FORTH_STACK_GUARD 
9839 cd 97 d4				call check_stacks 
983c				endif 
983c e5				push hl 
983d d5				push de 
983e eb				ex de,hl 
983f 2a 0d eb			ld hl,(cli_data_sp) 
9842 23				inc hl 
9843 23				inc hl 
9844			 
9844			; PARSEV5 
9844 23				inc hl 
9845 22 0d eb			ld (cli_data_sp),hl 
9848 73				ld (hl), e 
9849 23				inc hl 
984a 72				ld (hl), d 
984b d1				pop de 
984c e1				pop hl 
984d				if DEBUG_FORTH_STACK_GUARD 
984d cd 97 d4				call check_stacks 
9850				endif 
9850 c9				ret 
9851			 
9851			 
9851			; increase ret stack pointer and save hl to it 
9851				 
9851			FORTH_RSP_NEXT: macro 
9851				call macro_forth_rsp_next 
9851				endm 
9851			 
9851			macro_forth_rsp_next: 
9851				if DEBUG_FORTH_STACK_GUARD 
9851 cd 97 d4				call check_stacks 
9854				endif 
9854 e5				push hl 
9855 d5				push de 
9856 eb				ex de,hl 
9857 2a 11 eb			ld hl,(cli_ret_sp) 
985a 23				inc hl 
985b 23				inc hl 
985c 22 11 eb			ld (cli_ret_sp),hl 
985f 73				ld (hl), e 
9860 23				inc hl 
9861 72				ld (hl), d 
9862 d1				pop de 
9863 e1				pop hl 
9864				if DEBUG_FORTH_STACK_GUARD 
9864 cd 97 d4				call check_stacks 
9867				endif 
9867 c9				ret 
9868			 
9868			; get current ret stack pointer and save to hl  
9868				 
9868			FORTH_RSP_TOS: macro 
9868				call macro_forth_rsp_tos 
9868				endm 
9868			 
9868			macro_forth_rsp_tos: 
9868				;push de 
9868 2a 11 eb			ld hl,(cli_ret_sp) 
986b cd a3 98			call loadhlptrtohl 
986e				;ld e, (hl) 
986e				;inc hl 
986e				;ld d, (hl) 
986e				;ex de, hl 
986e					if DEBUG_FORTH_WORDS 
986e			;			DMARK "RST" 
986e						CALLMONITOR 
986e cd 1d 93			call break_point_state  
9871				endm  
# End of macro CALLMONITOR
9871					endif 
9871				;pop de 
9871 c9				ret 
9872			 
9872			; pop ret stack pointer 
9872				 
9872			FORTH_RSP_POP: macro 
9872				call macro_forth_rsp_pop 
9872				endm 
9872			 
9872			 
9872			macro_forth_rsp_pop: 
9872				if DEBUG_FORTH_STACK_GUARD 
9872			;		DMARK "RPP" 
9872 cd 97 d4				call check_stacks 
9875					FORTH_CHK_RSP_UNDER 
9875 e5				push hl 
9876 d5				push de 
9877 2a 11 eb			ld hl,(cli_ret_sp) 
987a 11 cb ea			ld de, cli_ret_stack 
987d cd c8 8a			call cmp16 
9880 da ab d5			jp c, fault_rsp_under 
9883 d1				pop de 
9884 e1				pop hl 
9885				endm 
# End of macro FORTH_CHK_RSP_UNDER
9885				endif 
9885 e5				push hl 
9886 2a 11 eb			ld hl,(cli_ret_sp) 
9889			 
9889			 
9889				if FORTH_ENABLE_FREE 
9889			 
9889					; get pointer 
9889			 
9889					push de 
9889					push hl 
9889			 
9889					ld e, (hl) 
9889					inc hl 
9889					ld d, (hl) 
9889			 
9889					ex de, hl 
9889					call free 
9889			 
9889					pop hl 
9889					pop de 
9889			 
9889			 
9889				endif 
9889			 
9889			 
9889 2b				dec hl 
988a 2b				dec hl 
988b 22 11 eb			ld (cli_ret_sp), hl 
988e				; do stack underflow checks 
988e e1				pop hl 
988f				if DEBUG_FORTH_STACK_GUARD 
988f cd 97 d4				call check_stacks 
9892					FORTH_CHK_RSP_UNDER 
9892 e5				push hl 
9893 d5				push de 
9894 2a 11 eb			ld hl,(cli_ret_sp) 
9897 11 cb ea			ld de, cli_ret_stack 
989a cd c8 8a			call cmp16 
989d da ab d5			jp c, fault_rsp_under 
98a0 d1				pop de 
98a1 e1				pop hl 
98a2				endm 
# End of macro FORTH_CHK_RSP_UNDER
98a2				endif 
98a2 c9				ret 
98a3			 
98a3			 
98a3			 
98a3			; routine to load word pointed to by hl into hl 
98a3			 
98a3			loadhlptrtohl: 
98a3			 
98a3 d5				push de 
98a4 5e				ld e, (hl) 
98a5 23				inc hl 
98a6 56				ld d, (hl) 
98a7 eb				ex de, hl 
98a8 d1				pop de 
98a9			 
98a9 c9				ret 
98aa			 
98aa			 
98aa			 
98aa			 
98aa			 
98aa			; push a number held in HL onto the data stack 
98aa			; entry point for pushing a value when already in hl used in function above 
98aa			 
98aa			forth_push_numhl: 
98aa			 
98aa e5				push hl    ; save value to push 
98ab			 
98ab			if DEBUG_FORTH_PUSH 
98ab				; see if disabled 
98ab			 
98ab			 
98ab f5				push af 
98ac 3a 51 e3			ld a, (os_view_disable) 
98af fe 2a			cp '*' 
98b1 28 34			jr z, .pskip2 
98b3 e5				push hl 
98b4 e5			push hl 
98b5 cd 7d 88			call clear_display 
98b8 e1			pop hl 
98b9 7c				ld a,h 
98ba 21 65 e6			ld hl, os_word_scratch 
98bd cd ab 8d			call hexout 
98c0 e1				pop hl 
98c1 7d				ld a,l 
98c2 21 67 e6			ld hl, os_word_scratch+2 
98c5 cd ab 8d			call hexout 
98c8			 
98c8 21 69 e6			ld hl, os_word_scratch+4 
98cb 3e 00			ld a,0 
98cd 77				ld (hl),a 
98ce 11 65 e6			ld de,os_word_scratch 
98d1 3e 28				ld a, display_row_2 
98d3 cd 90 88				call str_at_display 
98d6 11 a5 c3			ld de, .push_num 
98d9 3e 00			ld a, display_row_1 
98db			 
98db cd 90 88				call str_at_display 
98de			 
98de			 
98de cd a0 88			call update_display 
98e1 cd fd 87			call delay1s 
98e4 cd fd 87			call delay1s 
98e7			.pskip2:  
98e7			 
98e7 f1				pop af 
98e8			endif	 
98e8			 
98e8			 
98e8				FORTH_DSP_NEXT 
98e8 cd 39 98			call macro_forth_dsp_next 
98eb				endm 
# End of macro FORTH_DSP_NEXT
98eb			 
98eb 2a 0d eb			ld hl, (cli_data_sp) 
98ee			 
98ee				; save item type 
98ee 3e 02			ld a,  DS_TYPE_INUM 
98f0 77				ld (hl), a 
98f1 23				inc hl 
98f2			 
98f2				; get word off stack 
98f2 d1				pop de 
98f3 7b				ld a,e 
98f4 77				ld (hl), a 
98f5 23				inc hl 
98f6 7a				ld a,d 
98f7 77				ld (hl), a 
98f8			 
98f8			if DEBUG_FORTH_PUSH 
98f8 2b				dec hl 
98f9 2b				dec hl 
98fa 2b				dec hl 
98fb						DMARK "PH5" 
98fb f5				push af  
98fc 3a 10 99			ld a, (.dmark)  
98ff 32 7a ee			ld (debug_mark),a  
9902 3a 11 99			ld a, (.dmark+1)  
9905 32 7b ee			ld (debug_mark+1),a  
9908 3a 12 99			ld a, (.dmark+2)  
990b 32 7c ee			ld (debug_mark+2),a  
990e 18 03			jr .pastdmark  
9910 ..			.dmark: db "PH5"  
9913 f1			.pastdmark: pop af  
9914			endm  
# End of macro DMARK
9914				CALLMONITOR 
9914 cd 1d 93			call break_point_state  
9917				endm  
# End of macro CALLMONITOR
9917			endif	 
9917			 
9917 c9				ret 
9918			 
9918			 
9918			; Push a string to stack pointed to by hl 
9918			 
9918			forth_push_str: 
9918			 
9918			if DEBUG_FORTH_PUSH 
9918						DMARK "PSQ" 
9918 f5				push af  
9919 3a 2d 99			ld a, (.dmark)  
991c 32 7a ee			ld (debug_mark),a  
991f 3a 2e 99			ld a, (.dmark+1)  
9922 32 7b ee			ld (debug_mark+1),a  
9925 3a 2f 99			ld a, (.dmark+2)  
9928 32 7c ee			ld (debug_mark+2),a  
992b 18 03			jr .pastdmark  
992d ..			.dmark: db "PSQ"  
9930 f1			.pastdmark: pop af  
9931			endm  
# End of macro DMARK
9931				CALLMONITOR 
9931 cd 1d 93			call break_point_state  
9934				endm  
# End of macro CALLMONITOR
9934			endif	 
9934			    
9934 e5				push hl 
9935 e5				push hl 
9936			 
9936			;	ld a, 0   ; find end of string 
9936 cd 08 8f			call strlenz 
9939			if DEBUG_FORTH_PUSH 
9939						DMARK "PQ2" 
9939 f5				push af  
993a 3a 4e 99			ld a, (.dmark)  
993d 32 7a ee			ld (debug_mark),a  
9940 3a 4f 99			ld a, (.dmark+1)  
9943 32 7b ee			ld (debug_mark+1),a  
9946 3a 50 99			ld a, (.dmark+2)  
9949 32 7c ee			ld (debug_mark+2),a  
994c 18 03			jr .pastdmark  
994e ..			.dmark: db "PQ2"  
9951 f1			.pastdmark: pop af  
9952			endm  
# End of macro DMARK
9952				CALLMONITOR 
9952 cd 1d 93			call break_point_state  
9955				endm  
# End of macro CALLMONITOR
9955			endif	 
9955 eb				ex de, hl 
9956 e1				pop hl   ; get ptr to start of string 
9957			if DEBUG_FORTH_PUSH 
9957						DMARK "PQ3" 
9957 f5				push af  
9958 3a 6c 99			ld a, (.dmark)  
995b 32 7a ee			ld (debug_mark),a  
995e 3a 6d 99			ld a, (.dmark+1)  
9961 32 7b ee			ld (debug_mark+1),a  
9964 3a 6e 99			ld a, (.dmark+2)  
9967 32 7c ee			ld (debug_mark+2),a  
996a 18 03			jr .pastdmark  
996c ..			.dmark: db "PQ3"  
996f f1			.pastdmark: pop af  
9970			endm  
# End of macro DMARK
9970				CALLMONITOR 
9970 cd 1d 93			call break_point_state  
9973				endm  
# End of macro CALLMONITOR
9973			endif	 
9973 19				add hl,de 
9974			if DEBUG_FORTH_PUSH 
9974						DMARK "PQE" 
9974 f5				push af  
9975 3a 89 99			ld a, (.dmark)  
9978 32 7a ee			ld (debug_mark),a  
997b 3a 8a 99			ld a, (.dmark+1)  
997e 32 7b ee			ld (debug_mark+1),a  
9981 3a 8b 99			ld a, (.dmark+2)  
9984 32 7c ee			ld (debug_mark+2),a  
9987 18 03			jr .pastdmark  
9989 ..			.dmark: db "PQE"  
998c f1			.pastdmark: pop af  
998d			endm  
# End of macro DMARK
998d				CALLMONITOR 
998d cd 1d 93			call break_point_state  
9990				endm  
# End of macro CALLMONITOR
9990			endif	 
9990			 
9990 2b				dec hl    ; see if there is an optional trailing double quote 
9991 7e				ld a,(hl) 
9992 fe 22			cp '"' 
9994 20 03			jr nz, .strnoq 
9996 3e 00			ld a, 0      ; get rid of double quote 
9998 77				ld (hl), a 
9999 23			.strnoq: inc hl 
999a			 
999a 3e 00			ld a, 0 
999c 77				ld (hl), a     ; add null term and get rid of trailing double quote 
999d			 
999d 13				inc de ; add one for the type string 
999e 13				inc de ; add one for null term??? 
999f			 
999f				; tos is get string pointer again 
999f				; de contains space to allocate 
999f				 
999f d5				push de 
99a0			 
99a0 eb				ex de, hl 
99a1			 
99a1				;push af 
99a1			 
99a1			if DEBUG_FORTH_PUSH 
99a1						DMARK "PHm" 
99a1 f5				push af  
99a2 3a b6 99			ld a, (.dmark)  
99a5 32 7a ee			ld (debug_mark),a  
99a8 3a b7 99			ld a, (.dmark+1)  
99ab 32 7b ee			ld (debug_mark+1),a  
99ae 3a b8 99			ld a, (.dmark+2)  
99b1 32 7c ee			ld (debug_mark+2),a  
99b4 18 03			jr .pastdmark  
99b6 ..			.dmark: db "PHm"  
99b9 f1			.pastdmark: pop af  
99ba			endm  
# End of macro DMARK
99ba				CALLMONITOR 
99ba cd 1d 93			call break_point_state  
99bd				endm  
# End of macro CALLMONITOR
99bd			endif	 
99bd cd 71 8f			call malloc	; on ret hl now contains allocated memory 
99c0				if DEBUG_FORTH_MALLOC_GUARD 
99c0 cc fd c3				call z,malloc_error 
99c3				endif 
99c3			 
99c3				 
99c3 c1				pop bc    ; get length 
99c4 d1				pop de   ;  get string start    
99c5			 
99c5				; hl has destination from malloc 
99c5			 
99c5 eb				ex de, hl    ; prep for ldir 
99c6			 
99c6 d5				push de   ; save malloc area for DSP later 
99c7				;push hl   ; save malloc area for DSP later 
99c7			 
99c7			if DEBUG_FORTH_PUSH 
99c7						DMARK "PHc" 
99c7 f5				push af  
99c8 3a dc 99			ld a, (.dmark)  
99cb 32 7a ee			ld (debug_mark),a  
99ce 3a dd 99			ld a, (.dmark+1)  
99d1 32 7b ee			ld (debug_mark+1),a  
99d4 3a de 99			ld a, (.dmark+2)  
99d7 32 7c ee			ld (debug_mark+2),a  
99da 18 03			jr .pastdmark  
99dc ..			.dmark: db "PHc"  
99df f1			.pastdmark: pop af  
99e0			endm  
# End of macro DMARK
99e0				CALLMONITOR 
99e0 cd 1d 93			call break_point_state  
99e3				endm  
# End of macro CALLMONITOR
99e3			endif	 
99e3			 
99e3			 
99e3 ed b0			ldir 
99e5			 
99e5			 
99e5				; push malloc to data stack     macro?????  
99e5			 
99e5				FORTH_DSP_NEXT 
99e5 cd 39 98			call macro_forth_dsp_next 
99e8				endm 
# End of macro FORTH_DSP_NEXT
99e8			 
99e8				; save value and type 
99e8			 
99e8 2a 0d eb			ld hl, (cli_data_sp) 
99eb			 
99eb				; save item type 
99eb 3e 01			ld a,  DS_TYPE_STR 
99ed 77				ld (hl), a 
99ee 23				inc hl 
99ef			 
99ef				; get malloc word off stack 
99ef d1				pop de 
99f0 73				ld (hl), e 
99f1 23				inc hl 
99f2 72				ld (hl), d 
99f3			 
99f3			 
99f3			 
99f3			if DEBUG_FORTH_PUSH 
99f3 2a 0d eb			ld hl, (cli_data_sp) 
99f6						DMARK "PHS" 
99f6 f5				push af  
99f7 3a 0b 9a			ld a, (.dmark)  
99fa 32 7a ee			ld (debug_mark),a  
99fd 3a 0c 9a			ld a, (.dmark+1)  
9a00 32 7b ee			ld (debug_mark+1),a  
9a03 3a 0d 9a			ld a, (.dmark+2)  
9a06 32 7c ee			ld (debug_mark+2),a  
9a09 18 03			jr .pastdmark  
9a0b ..			.dmark: db "PHS"  
9a0e f1			.pastdmark: pop af  
9a0f			endm  
# End of macro DMARK
9a0f				CALLMONITOR 
9a0f cd 1d 93			call break_point_state  
9a12				endm  
# End of macro CALLMONITOR
9a12			;	ex de,hl 
9a12			endif	 
9a12				; in case of spaces, skip the ptr past the copied string 
9a12				;pop af 
9a12				;ld (cli_origptr),hl 
9a12			 
9a12 c9				ret 
9a13			 
9a13			 
9a13			 
9a13			; TODO ascii push input onto stack given hl to start of input 
9a13			 
9a13			; identify type 
9a13			; if starts with a " then a string 
9a13			; otherwise it is a number 
9a13			;  
9a13			; if a string 
9a13			;     scan for ending " to get length of string to malloc for + 1 
9a13			;     malloc 
9a13			;     put pointer to string on stack first byte flags as string 
9a13			; 
9a13			; else a number 
9a13			;    look for number format identifier 
9a13			;    $xx hex 
9a13			;    %xxxxx bin 
9a13			;    xxxxx decimal 
9a13			;    convert number to 16bit word.  
9a13			;    malloc word + 1 with flag to identiy as num 
9a13			;    put pointer to number on stack 
9a13			;   
9a13			;  
9a13			  
9a13			forth_apush: 
9a13				; kernel push 
9a13			 
9a13			if DEBUG_FORTH_PUSH 
9a13						DMARK "PSH" 
9a13 f5				push af  
9a14 3a 28 9a			ld a, (.dmark)  
9a17 32 7a ee			ld (debug_mark),a  
9a1a 3a 29 9a			ld a, (.dmark+1)  
9a1d 32 7b ee			ld (debug_mark+1),a  
9a20 3a 2a 9a			ld a, (.dmark+2)  
9a23 32 7c ee			ld (debug_mark+2),a  
9a26 18 03			jr .pastdmark  
9a28 ..			.dmark: db "PSH"  
9a2b f1			.pastdmark: pop af  
9a2c			endm  
# End of macro DMARK
9a2c				CALLMONITOR 
9a2c cd 1d 93			call break_point_state  
9a2f				endm  
# End of macro CALLMONITOR
9a2f			endif	 
9a2f				; identify input type 
9a2f			 
9a2f 7e				ld a,(hl) 
9a30 fe 22			cp '"' 
9a32 28 0a			jr z, .fapstr 
9a34 fe 24			cp '$' 
9a36 ca 5e 9a			jp z, .faphex 
9a39 fe 25			cp '%' 
9a3b ca 46 9a			jp z, .fapbin 
9a3e			;	cp 'b' 
9a3e			;	jp z, .fabin 
9a3e				; else decimal 
9a3e			 
9a3e				; TODO do decimal conversion 
9a3e				; decimal is stored as a 16bit word 
9a3e			 
9a3e				; by default everything is a string if type is not detected 
9a3e			.fapstr: ; 
9a3e fe 22			cp '"' 
9a40 20 01			jr nz, .strnoqu 
9a42 23				inc hl 
9a43			.strnoqu: 
9a43 c3 18 99			jp forth_push_str 
9a46			 
9a46			 
9a46			 
9a46			.fapbin:    ; push a binary string.  
9a46 11 00 00			ld de, 0   ; hold a 16bit value 
9a49			 
9a49 23			.fapbinshift:	inc hl  
9a4a 7e				ld a,(hl) 
9a4b fe 00			cp 0     ; done scanning  
9a4d 28 0b			jr z, .fapbdone  	; got it in HL so push  
9a4f			 
9a4f				; left shift de 
9a4f eb				ex de, hl	 
9a50 29				add hl, hl 
9a51			 
9a51				; is 1 
9a51 fe 31			cp '1' 
9a53 20 02			jr nz, .binzero 
9a55 cb 4d			bit 1, l 
9a57			.binzero: 
9a57 eb				ex de, hl	 ; save current de 
9a58 18 ef			jr .fapbinshift 
9a5a			 
9a5a			.fapbdone: 
9a5a eb				ex de, hl 
9a5b c3 aa 98			jp forth_push_numhl 
9a5e			 
9a5e			 
9a5e			.faphex:   ; hex is always stored as a 16bit word 
9a5e				; skip number prefix 
9a5e 23				inc hl 
9a5f				; turn ascii into number 
9a5f cd 61 8e			call get_word_hl	; ret 16bit word in hl 
9a62			 
9a62 c3 aa 98			jp forth_push_numhl 
9a65			 
9a65 00				 nop 
9a66			 
9a66			.fabin:   ; TODO bin conversion 
9a66			 
9a66			 
9a66 c9				ret 
9a67			 
9a67			 
9a67			; get either a string ptr or a 16bit word from the data stack 
9a67			 
9a67			FORTH_DSP: macro 
9a67				call macro_forth_dsp 
9a67				endm 
9a67			 
9a67			macro_forth_dsp: 
9a67				; data stack pointer points to current word on tos 
9a67			 
9a67 2a 0d eb			ld hl,(cli_data_sp) 
9a6a			 
9a6a				if DEBUG_FORTH_PUSH 
9a6a						DMARK "DSP" 
9a6a f5				push af  
9a6b 3a 7f 9a			ld a, (.dmark)  
9a6e 32 7a ee			ld (debug_mark),a  
9a71 3a 80 9a			ld a, (.dmark+1)  
9a74 32 7b ee			ld (debug_mark+1),a  
9a77 3a 81 9a			ld a, (.dmark+2)  
9a7a 32 7c ee			ld (debug_mark+2),a  
9a7d 18 03			jr .pastdmark  
9a7f ..			.dmark: db "DSP"  
9a82 f1			.pastdmark: pop af  
9a83			endm  
# End of macro DMARK
9a83			 
9a83 cd 32 c4				call display_data_sp 
9a86				;call break_point_state 
9a86				;rst 030h 
9a86				CALLMONITOR 
9a86 cd 1d 93			call break_point_state  
9a89				endm  
# End of macro CALLMONITOR
9a89				endif 
9a89			 
9a89 c9				ret 
9a8a			 
9a8a			; return hl to start of value on stack 
9a8a			 
9a8a			FORTH_DSP_VALUE: macro 
9a8a				call macro_forth_dsp_value 
9a8a				endm 
9a8a			 
9a8a			macro_forth_dsp_value: 
9a8a			 
9a8a				FORTH_DSP 
9a8a cd 67 9a			call macro_forth_dsp 
9a8d				endm 
# End of macro FORTH_DSP
9a8d			 
9a8d d5				push de 
9a8e			 
9a8e 23				inc hl ; skip type 
9a8f			 
9a8f 5e				ld e, (hl) 
9a90 23				inc hl 
9a91 56				ld d, (hl) 
9a92 eb				ex de,hl  
9a93			 
9a93 d1				pop de 
9a94			 
9a94 c9				ret 
9a95			 
9a95			; return hl to start of value to second item on stack 
9a95			 
9a95			FORTH_DSP_VALUEM1: macro 
9a95				call macro_forth_dsp_value_m1 
9a95				endm 
9a95			 
9a95			macro_forth_dsp_value_m1: 
9a95			 
9a95				FORTH_DSP 
9a95 cd 67 9a			call macro_forth_dsp 
9a98				endm 
# End of macro FORTH_DSP
9a98			 
9a98 2b				dec hl 
9a99 2b				dec hl 
9a9a			;	dec hl 
9a9a			 
9a9a d5				push de 
9a9b			 
9a9b 5e				ld e, (hl) 
9a9c 23				inc hl 
9a9d 56				ld d, (hl) 
9a9e eb				ex de,hl  
9a9f			 
9a9f d1				pop de 
9aa0			 
9aa0 c9				ret 
9aa1			 
9aa1				 
9aa1			 
9aa1			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9aa1			 
9aa1			FORTH_DSP_POP: macro 
9aa1				call macro_forth_dsp_pop 
9aa1				endm 
9aa1			 
9aa1			 
9aa1			; get the tos data type 
9aa1			 
9aa1			FORTH_DSP_TYPE:   macro 
9aa1			 
9aa1				;FORTH_DSP_VALUE 
9aa1				FORTH_DSP 
9aa1				 
9aa1				; hl points to value 
9aa1				; check type 
9aa1			 
9aa1				ld a,(hl) 
9aa1			 
9aa1				endm 
9aa1			 
9aa1			; load the tos value into hl 
9aa1			 
9aa1			 
9aa1			FORTH_DSP_VALUEHL:  macro 
9aa1				call macro_dsp_valuehl 
9aa1				endm 
9aa1			 
9aa1			 
9aa1			 
9aa1			macro_dsp_valuehl: 
9aa1				FORTH_DSP_VALUE 
9aa1 cd 8a 9a			call macro_forth_dsp_value 
9aa4				endm 
# End of macro FORTH_DSP_VALUE
9aa4			 
9aa4				;FORTH_ERR_TOS_NOTNUM 
9aa4			 
9aa4				;inc hl   ; skip type id 
9aa4			 
9aa4			;	push de 
9aa4			; 
9aa4			;	ld e, (hl) 
9aa4			;	inc hl 
9aa4			;	ld d, (hl) 
9aa4			;	ex de,hl  
9aa4			 
9aa4			;	pop de 
9aa4			 
9aa4				if DEBUG_FORTH_PUSH 
9aa4						DMARK "DVL" 
9aa4 f5				push af  
9aa5 3a b9 9a			ld a, (.dmark)  
9aa8 32 7a ee			ld (debug_mark),a  
9aab 3a ba 9a			ld a, (.dmark+1)  
9aae 32 7b ee			ld (debug_mark+1),a  
9ab1 3a bb 9a			ld a, (.dmark+2)  
9ab4 32 7c ee			ld (debug_mark+2),a  
9ab7 18 03			jr .pastdmark  
9ab9 ..			.dmark: db "DVL"  
9abc f1			.pastdmark: pop af  
9abd			endm  
# End of macro DMARK
9abd				CALLMONITOR 
9abd cd 1d 93			call break_point_state  
9ac0				endm  
# End of macro CALLMONITOR
9ac0				endif 
9ac0 c9				ret 
9ac1			 
9ac1			forth_apushstrhl:      
9ac1				; push of string requires use of cli_origptr 
9ac1				; bodge use 
9ac1			 
9ac1				; get current cli_origptr, save, update with temp pointer  
9ac1 ed 5b 29 eb		ld de, (cli_origptr) 
9ac5 22 29 eb			ld (cli_origptr), hl 
9ac8 d5				push de 
9ac9 cd 13 9a			call forth_apush 
9acc d1				pop de 
9acd ed 53 29 eb		ld (cli_origptr), de 
9ad1 c9			        ret	 
9ad2			 
9ad2			 
9ad2			; increase loop stack pointer and save hl to it 
9ad2				 
9ad2			FORTH_LOOP_NEXT: macro 
9ad2				call macro_forth_loop_next 
9ad2				;nop 
9ad2				endm 
9ad2			 
9ad2			macro_forth_loop_next: 
9ad2				if DEBUG_FORTH_STACK_GUARD 
9ad2 cd 97 d4				call check_stacks 
9ad5				endif 
9ad5 e5				push hl 
9ad6 d5				push de 
9ad7 eb				ex de,hl 
9ad8 2a 0f eb			ld hl,(cli_loop_sp) 
9adb 23				inc hl 
9adc 23				inc hl 
9add					if DEBUG_FORTH_WORDS 
9add						DMARK "LNX" 
9add f5				push af  
9ade 3a f2 9a			ld a, (.dmark)  
9ae1 32 7a ee			ld (debug_mark),a  
9ae4 3a f3 9a			ld a, (.dmark+1)  
9ae7 32 7b ee			ld (debug_mark+1),a  
9aea 3a f4 9a			ld a, (.dmark+2)  
9aed 32 7c ee			ld (debug_mark+2),a  
9af0 18 03			jr .pastdmark  
9af2 ..			.dmark: db "LNX"  
9af5 f1			.pastdmark: pop af  
9af6			endm  
# End of macro DMARK
9af6						CALLMONITOR 
9af6 cd 1d 93			call break_point_state  
9af9				endm  
# End of macro CALLMONITOR
9af9					endif 
9af9 22 0f eb			ld (cli_loop_sp),hl 
9afc 73				ld (hl), e 
9afd 23				inc hl 
9afe 72				ld (hl), d 
9aff d1				pop de    ; been reversed so save a swap on restore 
9b00 e1				pop hl 
9b01				if DEBUG_FORTH_STACK_GUARD 
9b01 cd 97 d4				call check_stacks 
9b04				endif 
9b04 c9				ret 
9b05			 
9b05			; get current ret stack pointer and save to hl  
9b05				 
9b05			FORTH_LOOP_TOS: macro 
9b05				call macro_forth_loop_tos 
9b05				endm 
9b05			 
9b05			macro_forth_loop_tos: 
9b05 d5				push de 
9b06 2a 0f eb			ld hl,(cli_loop_sp) 
9b09 5e				ld e, (hl) 
9b0a 23				inc hl 
9b0b 56				ld d, (hl) 
9b0c eb				ex de, hl 
9b0d d1				pop de 
9b0e c9				ret 
9b0f			 
9b0f			; pop loop stack pointer 
9b0f				 
9b0f			FORTH_LOOP_POP: macro 
9b0f				call macro_forth_loop_pop 
9b0f				endm 
9b0f			 
9b0f			 
9b0f			macro_forth_loop_pop: 
9b0f				if DEBUG_FORTH_STACK_GUARD 
9b0f					DMARK "LPP" 
9b0f f5				push af  
9b10 3a 24 9b			ld a, (.dmark)  
9b13 32 7a ee			ld (debug_mark),a  
9b16 3a 25 9b			ld a, (.dmark+1)  
9b19 32 7b ee			ld (debug_mark+1),a  
9b1c 3a 26 9b			ld a, (.dmark+2)  
9b1f 32 7c ee			ld (debug_mark+2),a  
9b22 18 03			jr .pastdmark  
9b24 ..			.dmark: db "LPP"  
9b27 f1			.pastdmark: pop af  
9b28			endm  
# End of macro DMARK
9b28 cd 97 d4				call check_stacks 
9b2b					FORTH_CHK_LOOP_UNDER 
9b2b e5				push hl 
9b2c d5				push de 
9b2d 2a 0f eb			ld hl,(cli_loop_sp) 
9b30 11 c9 e9			ld de, cli_loop_stack 
9b33 cd c8 8a			call cmp16 
9b36 da b1 d5			jp c, fault_loop_under 
9b39 d1				pop de 
9b3a e1				pop hl 
9b3b				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9b3b				endif 
9b3b e5				push hl 
9b3c 2a 0f eb			ld hl,(cli_loop_sp) 
9b3f 2b				dec hl 
9b40 2b				dec hl 
9b41 22 0f eb			ld (cli_loop_sp), hl 
9b44				; TODO do stack underflow checks 
9b44 e1				pop hl 
9b45				if DEBUG_FORTH_STACK_GUARD 
9b45 cd 97 d4				call check_stacks 
9b48					FORTH_CHK_LOOP_UNDER 
9b48 e5				push hl 
9b49 d5				push de 
9b4a 2a 0f eb			ld hl,(cli_loop_sp) 
9b4d 11 c9 e9			ld de, cli_loop_stack 
9b50 cd c8 8a			call cmp16 
9b53 da b1 d5			jp c, fault_loop_under 
9b56 d1				pop de 
9b57 e1				pop hl 
9b58				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9b58				endif 
9b58 c9				ret 
9b59			 
9b59			macro_forth_dsp_pop: 
9b59			 
9b59 e5				push hl 
9b5a			 
9b5a				; release malloc data 
9b5a			 
9b5a				if DEBUG_FORTH_STACK_GUARD 
9b5a cd 97 d4				call check_stacks 
9b5d					FORTH_CHK_DSP_UNDER 
9b5d e5				push hl 
9b5e d5				push de 
9b5f 2a 0d eb			ld hl,(cli_data_sp) 
9b62 11 c7 e8			ld de, cli_data_stack 
9b65 cd c8 8a			call cmp16 
9b68 da a5 d5			jp c, fault_dsp_under 
9b6b d1				pop de 
9b6c e1				pop hl 
9b6d				endm 
# End of macro FORTH_CHK_DSP_UNDER
9b6d				endif 
9b6d				;ld hl,(cli_data_sp) 
9b6d			if DEBUG_FORTH_DOT 
9b6d				DMARK "DPP" 
9b6d				CALLMONITOR 
9b6d			endif	 
9b6d			 
9b6d			 
9b6d			if FORTH_ENABLE_DSPPOPFREE 
9b6d			 
9b6d				FORTH_DSP 
9b6d cd 67 9a			call macro_forth_dsp 
9b70				endm 
# End of macro FORTH_DSP
9b70			 
9b70 7e				ld a, (hl) 
9b71 fe 01			cp DS_TYPE_STR 
9b73 20 07			jr nz, .skippopfree 
9b75			 
9b75				FORTH_DSP_VALUEHL 
9b75 cd a1 9a			call macro_dsp_valuehl 
9b78				endm 
# End of macro FORTH_DSP_VALUEHL
9b78 00				nop 
9b79			if DEBUG_FORTH_DOT 
9b79				DMARK "DPf" 
9b79				CALLMONITOR 
9b79			endif	 
9b79 cd 3b 90			call free 
9b7c			.skippopfree: 
9b7c				 
9b7c			 
9b7c			endif 
9b7c			 
9b7c			if DEBUG_FORTH_DOT_KEY 
9b7c				DMARK "DP2" 
9b7c				CALLMONITOR 
9b7c			endif	 
9b7c			 
9b7c				; move pointer down 
9b7c			 
9b7c 2a 0d eb			ld hl,(cli_data_sp) 
9b7f 2b				dec hl 
9b80 2b				dec hl 
9b81			; PARSEV5 
9b81 2b				dec hl 
9b82 22 0d eb			ld (cli_data_sp), hl 
9b85			 
9b85				if DEBUG_FORTH_STACK_GUARD 
9b85 cd 97 d4				call check_stacks 
9b88					FORTH_CHK_DSP_UNDER 
9b88 e5				push hl 
9b89 d5				push de 
9b8a 2a 0d eb			ld hl,(cli_data_sp) 
9b8d 11 c7 e8			ld de, cli_data_stack 
9b90 cd c8 8a			call cmp16 
9b93 da a5 d5			jp c, fault_dsp_under 
9b96 d1				pop de 
9b97 e1				pop hl 
9b98				endm 
# End of macro FORTH_CHK_DSP_UNDER
9b98				endif 
9b98			 
9b98 e1				pop hl 
9b99			 
9b99 c9				ret 
9b9a			 
9b9a			getwordathl: 
9b9a				; hl points to an address 
9b9a				; load hl with the word at that address 
9b9a			 
9b9a d5				push de 
9b9b			 
9b9b 5e				ld e, (hl) 
9b9c 23				inc hl 
9b9d 56				ld d, (hl) 
9b9e eb				ex de, hl 
9b9f			 
9b9f d1				pop de 
9ba0 c9				ret 
9ba1			 
9ba1			 
9ba1			 
9ba1			 
9ba1			 
9ba1			; eof 
9ba1			 
# End of file forth_stackopsv5.asm
9ba1			endif 
9ba1			 
9ba1			user_word_eol:  
9ba1				; hl contains the pointer to where to create a linked list item from the end 
9ba1				; of the user dict to continue on at the system word dict 
9ba1				 
9ba1				; poke the stub of the word list linked list to repoint to rom words 
9ba1			 
9ba1				; stub format 
9ba1				; db   word id 
9ba1				; dw    link to next word 
9ba1			        ; db char length of token 
9ba1				; db string + 0 term 
9ba1				; db exec code....  
9ba1			 
9ba1 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9ba3 77				ld (hl), a		; word id 
9ba4 23				inc hl 
9ba5			 
9ba5 11 6b 9d			ld de, sysdict 
9ba8 73				ld (hl), e		; next word link ie system dict 
9ba9 23				inc hl 
9baa 72				ld (hl), d		; next word link ie system dict 
9bab 23				inc hl	 
9bac			 
9bac			;	ld (hl), sysdict		; next word link ie system dict 
9bac			;	inc hl 
9bac			;	inc hl 
9bac			 
9bac			;	inc hl 
9bac			;	inc hl 
9bac			 
9bac 3e 02			ld a, 2			; word length is 0 
9bae 77				ld (hl), a	 
9baf 23				inc hl 
9bb0			 
9bb0 3e 7e			ld a, '~'			; word length is 0 
9bb2 77				ld (hl), a	 
9bb3 23				inc hl 
9bb4 3e 00			ld a, 0			; save empty word 
9bb6 77				ld (hl), a 
9bb7			 
9bb7 c9				ret 
9bb8			 
9bb8				 
9bb8			 
9bb8			forthexec_cleanup: 
9bb8				FORTH_RSP_POP 
9bb8 cd 72 98			call macro_forth_rsp_pop 
9bbb				endm 
# End of macro FORTH_RSP_POP
9bbb c9				ret 
9bbc			 
9bbc			forth_call_hl: 
9bbc				; taking hl 
9bbc e5				push hl 
9bbd c9				ret 
9bbe			 
9bbe			; this is called to reset Forth system but keep existing uwords etc 
9bbe			 
9bbe			forth_warmstart: 
9bbe				; setup stack over/under flow checks 
9bbe				if DEBUG_FORTH_STACK_GUARD 
9bbe cd 7d d4				call chk_stk_init 
9bc1				endif 
9bc1			 
9bc1				; init stack pointers  - * these stacks go upwards *  
9bc1 21 cb ea			ld hl, cli_ret_stack 
9bc4 22 11 eb			ld (cli_ret_sp), hl	 
9bc7				; set bottom of stack 
9bc7 3e 00			ld a,0 
9bc9 77				ld (hl),a 
9bca 23				inc hl 
9bcb 77				ld (hl),a 
9bcc			 
9bcc 21 c7 e8			ld hl, cli_data_stack 
9bcf 22 0d eb			ld (cli_data_sp), hl	 
9bd2				; set bottom of stack 
9bd2 3e 00			ld a,0 
9bd4 77				ld (hl),a 
9bd5 23				inc hl 
9bd6 77				ld (hl),a 
9bd7			 
9bd7 21 c9 e9			ld hl, cli_loop_stack 
9bda 22 0f eb			ld (cli_loop_sp), hl	 
9bdd				; set bottom of stack 
9bdd 3e 00			ld a,0 
9bdf 77				ld (hl),a 
9be0 23				inc hl 
9be1 77				ld (hl),a 
9be2			 
9be2				; init extent of current open file 
9be2			 
9be2 3e 00			ld a, 0 
9be4 32 5c eb			ld (store_openext), a 
9be7			 
9be7 c9				ret 
9be8			 
9be8			 
9be8			; Cold Start - this is called to setup the whole Forth system 
9be8			 
9be8			forth_init: 
9be8			 
9be8				; setup stack over/under flow checks 
9be8			 
9be8			;	if DEBUG_FORTH_STACK_GUARD 
9be8			;		call chk_stk_init 
9be8			;	endif 
9be8			 
9be8				; enable auto display updates (slow.....) 
9be8			 
9be8 3e 01			ld a, 1 
9bea 32 27 eb			ld (cli_autodisplay), a 
9bed			 
9bed			 
9bed			 
9bed				; show start up screen 
9bed			 
9bed cd 7d 88			call clear_display 
9bf0			 
9bf0 3e 00			ld a,0 
9bf2 32 49 eb			ld (f_cursor_ptr), a 
9bf5			 
9bf5				; set start of word list in start of ram - for use when creating user words 
9bf5			 
9bf5 21 48 d7			ld hl, baseram 
9bf8 22 5d e6			ld (os_last_new_uword), hl 
9bfb cd a1 9b			call user_word_eol 
9bfe				 
9bfe			;		call display_data_sp 
9bfe			;		call next_page_prompt 
9bfe			 
9bfe			 
9bfe			 
9bfe			 
9bfe c9				ret 
9bff			 
9bff .. 00		.bootforth: db " Forth Kernel Init ",0 
9c13			 
9c13			; TODO push to stack 
9c13			 
9c13			;  
9c13			 
9c13			if FORTH_PARSEV2 
9c13			 
9c13			 
9c13				include "forth_parserv2.asm" 
9c13			 
9c13			endif 
9c13			 
9c13			 
9c13			; parse cli version 1 
9c13			 
9c13			if FORTH_PARSEV1 
9c13			 
9c13			 
9c13			 
9c13			      include "forth_parserv1.asm" 
9c13			endif 
9c13				 
9c13			if FORTH_PARSEV3 
9c13			 
9c13			 
9c13			 
9c13			      include "forth_parserv3.asm" 
9c13				include "forth_wordsv3.asm" 
9c13			endif 
9c13			 
9c13			if FORTH_PARSEV4 
9c13			 
9c13			 
9c13			 
9c13			      include "forth_parserv4.asm" 
9c13				include "forth_wordsv4.asm" 
9c13			endif 
9c13			 
9c13			if FORTH_PARSEV5 
9c13			 
9c13			 
9c13			 
9c13			      include "forth_parserv5.asm" 
9c13			 
9c13			 
9c13			; A better parser without using malloc and string copies all over the place.  
9c13			; Exec in situ should be faster 
9c13			 
9c13			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9c13			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9c13			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9c13			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9c13			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9c13			WORD_SYS_END: equ 0   ; Opcode for all user words 
9c13			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9c13			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9c13			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9c13			 
9c13			; Core word preamble macro 
9c13			 
9c13			CWHEAD:   macro nxtword opcode lit len opflags 
9c13				db WORD_SYS_CORE+opcode             
9c13				; internal op code number 
9c13				dw nxtword            
9c13				; link to next dict word block 
9c13				db len + 1 
9c13				; literal length of dict word inc zero term 
9c13				db lit,0              
9c13				; literal dict word 
9c13			        ; TODO db opflags        
9c13				endm 
9c13			 
9c13			 
9c13			NEXTW: macro  
9c13				jp macro_next 
9c13				endm 
9c13			 
9c13			macro_next: 
9c13			if DEBUG_FORTH_PARSE_KEY 
9c13				DMARK "NXT" 
9c13				CALLMONITOR 
9c13			endif	 
9c13			;	inc hl  ; skip token null term  
9c13 ed 4b 2b eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9c17 ed 5b 29 eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9c1b 2a 61 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9c1e			if DEBUG_FORTH_PARSE_KEY 
9c1e				DMARK "}AA" 
9c1e				CALLMONITOR 
9c1e			endif	 
9c1e c3 21 9d			jp execnext 
9c21				;jp exec1 
9c21			       
9c21			 
9c21			 
9c21			; Another go at the parser to compile  
9c21			 
9c21			 
9c21			; TODO rework parser to change all of the string words to byte tokens 
9c21			; TODO do a search for  
9c21			 
9c21			; TODO first run normal parser to zero term sections 
9c21			; TODO for each word do a token look up to get the op code 
9c21			; TODO need some means to flag to the exec that this is a byte code form    
9c21			 
9c21			 
9c21			forthcompile: 
9c21			 
9c21			; 
9c21			; line parse: 
9c21			;       parse raw input buffer 
9c21			;       tokenise the words 
9c21			;       malloc new copy (for looping etc) 
9c21			;       copy to malloc + current pc in line to start of string and add line term 
9c21			;       save on new rsp 
9c21			; 
9c21			 
9c21			; hl to point to the line to tokenise 
9c21			 
9c21			;	push hl 
9c21 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
9c24			 
9c24			;	ld a,0		; string term on input 
9c24			;	call strlent 
9c24			 
9c24			;	ld (os_tok_len), hl	 ; save string length 
9c24			 
9c24			;if DEBUG_FORTH_TOK 
9c24			;	ex de,hl		 
9c24			;endif 
9c24			 
9c24			;	pop hl 		; get back string pointer 
9c24			 
9c24			if DEBUG_FORTH_TOK 
9c24						DMARK "TOc" 
9c24				CALLMONITOR 
9c24			endif 
9c24 7e			.cptoken2:    ld a,(hl) 
9c25 23				inc hl 
9c26 fe 7f			cp FORTH_END_BUFFER 
9c28 28 29			jr z, .cptokendone2 
9c2a fe 00			cp 0 
9c2c 28 25			jr z, .cptokendone2 
9c2e fe 22			cp '"' 
9c30 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9c32 fe 20			cp ' ' 
9c34 20 ee			jr nz,  .cptoken2 
9c36			 
9c36			; TODO consume comments held between ( and ) 
9c36			 
9c36				; we have a space so change to zero term for dict match later 
9c36 2b				dec hl 
9c37 3e 00			ld a,0 
9c39 77				ld (hl), a 
9c3a 23				inc hl 
9c3b 18 e7			jr .cptoken2 
9c3d				 
9c3d			 
9c3d			.cptokenstr2: 
9c3d				; skip all white space until either eol (because forgot to term) or end double quote 
9c3d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9c3d				;inc hl ; skip current double quote 
9c3d 7e				ld a,(hl) 
9c3e 23				inc hl 
9c3f fe 22			cp '"' 
9c41 28 e1			jr z, .cptoken2 
9c43 fe 7f			cp FORTH_END_BUFFER 
9c45 28 0c			jr z, .cptokendone2 
9c47 fe 00			cp 0 
9c49 28 08			jr z, .cptokendone2 
9c4b fe 20			cp ' ' 
9c4d 28 02			jr z, .cptmp2 
9c4f 18 ec			jr .cptokenstr2 
9c51			 
9c51			.cptmp2:	; we have a space so change to zero term for dict match later 
9c51				;dec hl 
9c51				;ld a,"-"	; TODO remove this when working 
9c51				;ld (hl), a 
9c51				;inc hl 
9c51 18 ea			jr .cptokenstr2 
9c53			 
9c53			.cptokendone2: 
9c53				;inc hl 
9c53 3e 7f			ld a, FORTH_END_BUFFER 
9c55 77				ld (hl),a 
9c56 23				inc hl 
9c57 3e 21			ld a, '!' 
9c59 77				ld (hl),a 
9c5a			 
9c5a 2a 61 e6			ld hl,(os_tok_ptr) 
9c5d			         
9c5d			if DEBUG_FORTH_TOK 
9c5d						DMARK "Tc1" 
9c5d				CALLMONITOR 
9c5d			endif 
9c5d			 
9c5d				; push exec string to top of return stack 
9c5d				FORTH_RSP_NEXT 
9c5d cd 51 98			call macro_forth_rsp_next 
9c60				endm 
# End of macro FORTH_RSP_NEXT
9c60 c9				ret 
9c61			 
9c61			; Another go at the parser need to simplify the process 
9c61			 
9c61			forthparse: 
9c61			 
9c61			; 
9c61			; line parse: 
9c61			;       parse raw input buffer 
9c61			;       tokenise the words 
9c61			;       malloc new copy (for looping etc) 
9c61			;       copy to malloc + current pc in line to start of string and add line term 
9c61			;       save on new rsp 
9c61			; 
9c61			 
9c61			; hl to point to the line to tokenise 
9c61			 
9c61			;	push hl 
9c61 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
9c64			 
9c64			;	ld a,0		; string term on input 
9c64			;	call strlent 
9c64			 
9c64			;	ld (os_tok_len), hl	 ; save string length 
9c64			 
9c64			;if DEBUG_FORTH_TOK 
9c64			;	ex de,hl		 
9c64			;endif 
9c64			 
9c64			;	pop hl 		; get back string pointer 
9c64			 
9c64			if DEBUG_FORTH_TOK 
9c64						DMARK "TOK" 
9c64				CALLMONITOR 
9c64			endif 
9c64 7e			.ptoken2:    ld a,(hl) 
9c65 23				inc hl 
9c66 fe 7f			cp FORTH_END_BUFFER 
9c68 28 29			jr z, .ptokendone2 
9c6a fe 00			cp 0 
9c6c 28 25			jr z, .ptokendone2 
9c6e fe 22			cp '"' 
9c70 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9c72 fe 20			cp ' ' 
9c74 20 ee			jr nz,  .ptoken2 
9c76			 
9c76			; TODO consume comments held between ( and ) 
9c76			 
9c76				; we have a space so change to zero term for dict match later 
9c76 2b				dec hl 
9c77 3e 00			ld a,0 
9c79 77				ld (hl), a 
9c7a 23				inc hl 
9c7b 18 e7			jr .ptoken2 
9c7d				 
9c7d			 
9c7d			.ptokenstr2: 
9c7d				; skip all white space until either eol (because forgot to term) or end double quote 
9c7d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9c7d				;inc hl ; skip current double quote 
9c7d 7e				ld a,(hl) 
9c7e 23				inc hl 
9c7f fe 22			cp '"' 
9c81 28 e1			jr z, .ptoken2 
9c83 fe 7f			cp FORTH_END_BUFFER 
9c85 28 0c			jr z, .ptokendone2 
9c87 fe 00			cp 0 
9c89 28 08			jr z, .ptokendone2 
9c8b fe 20			cp ' ' 
9c8d 28 02			jr z, .ptmp2 
9c8f 18 ec			jr .ptokenstr2 
9c91			 
9c91			.ptmp2:	; we have a space so change to zero term for dict match later 
9c91				;dec hl 
9c91				;ld a,"-"	; TODO remove this when working 
9c91				;ld (hl), a 
9c91				;inc hl 
9c91 18 ea			jr .ptokenstr2 
9c93			 
9c93			.ptokendone2: 
9c93				;inc hl 
9c93 3e 7f			ld a, FORTH_END_BUFFER 
9c95 77				ld (hl),a 
9c96 23				inc hl 
9c97 3e 21			ld a, '!' 
9c99 77				ld (hl),a 
9c9a			 
9c9a 2a 61 e6			ld hl,(os_tok_ptr) 
9c9d			         
9c9d			if DEBUG_FORTH_TOK 
9c9d						DMARK "TK1" 
9c9d				CALLMONITOR 
9c9d			endif 
9c9d			 
9c9d				; push exec string to top of return stack 
9c9d				FORTH_RSP_NEXT 
9c9d cd 51 98			call macro_forth_rsp_next 
9ca0				endm 
# End of macro FORTH_RSP_NEXT
9ca0 c9				ret 
9ca1			 
9ca1			; 
9ca1			;	; malloc size + buffer pointer + if is loop flag 
9ca1			;	ld hl,(os_tok_len) 		 ; get string length 
9ca1			; 
9ca1			;	ld a,l 
9ca1			; 
9ca1			;	cp 0			; we dont want to use a null string 
9ca1			;	ret z 
9ca1			; 
9ca1			;;	add 3    ; prefix malloc with buffer for current word ptr 
9ca1			; 
9ca1			;	add 5     ; TODO when certain not over writing memory remove 
9ca1			; 
9ca1			;		 
9ca1			; 
9ca1			;if DEBUG_FORTH_TOK 
9ca1			;			DMARK "TKE" 
9ca1			;	CALLMONITOR 
9ca1			;endif 
9ca1			; 
9ca1			;	ld l,a 
9ca1			;	ld h,0 
9ca1			;;	push hl   ; save required space for the copy later 
9ca1			;	call malloc 
9ca1			;if DEBUG_FORTH_TOK 
9ca1			;			DMARK "TKM" 
9ca1			;	CALLMONITOR 
9ca1			;endif 
9ca1			;	if DEBUG_FORTH_MALLOC_GUARD 
9ca1			;		push af 
9ca1			;		call ishlzero 
9ca1			;;		ld a, l 
9ca1			;;		add h 
9ca1			;;		cp 0 
9ca1			;		pop af 
9ca1			;		 
9ca1			;		call z,malloc_error 
9ca1			;	endif 
9ca1			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9ca1			; 
9ca1			; 
9ca1			;if DEBUG_FORTH_TOK 
9ca1			;			DMARK "TKR" 
9ca1			;	CALLMONITOR 
9ca1			;endif 
9ca1			; 
9ca1			;	FORTH_RSP_NEXT 
9ca1			; 
9ca1			;	;inc hl	 ; go past current buffer pointer 
9ca1			;	;inc hl 
9ca1			;	;inc hl   ; and past if loop flag 
9ca1			;		; TODO Need to set flag  
9ca1			; 
9ca1			;	 
9ca1			;	 
9ca1			;	ex de,hl	; malloc is dest 
9ca1			;	ld hl, (os_tok_len) 
9ca1			;;	pop bc 
9ca1			;	ld c, l                
9ca1			;	ld b,0 
9ca1			;	ld hl, (os_tok_ptr) 
9ca1			; 
9ca1			;if DEBUG_FORTH_TOK 
9ca1			;			DMARK "TKT" 
9ca1			;	CALLMONITOR 
9ca1			;endif 
9ca1			; 
9ca1			;	; do str cpy 
9ca1			; 
9ca1			;	ldir      ; copy byte in hl to de 
9ca1			; 
9ca1			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9ca1			; 
9ca1			;if DEBUG_FORTH_TOK 
9ca1			; 
9ca1			;			DMARK "TKY" 
9ca1			;	CALLMONITOR 
9ca1			;endif 
9ca1			;	;ld a,0 
9ca1			;	;ld a,FORTH_END_BUFFER 
9ca1			;	ex de, hl 
9ca1			;	;dec hl			 ; go back over the space delim at the end of word 
9ca1			;	;ld (hl),a 
9ca1			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9ca1			;	ld a,FORTH_END_BUFFER 
9ca1			;	ld (hl),a 
9ca1			;	inc hl 
9ca1			;	ld a,FORTH_END_BUFFER 
9ca1			;	ld (hl),a 
9ca1			; 
9ca1			;	; init the malloc area data 
9ca1			;	; set pc for in current area 
9ca1			;	;ld hl, (os_tok_malloc) 
9ca1			;	;inc hl 
9ca1			;	;inc hl 
9ca1			;	;inc hl 
9ca1			;	;ex de,hl 
9ca1			;	;ld hl, (os_tok_malloc) 
9ca1			;	;ld (hl),e 
9ca1			;	;inc hl 
9ca1			;	;ld (hl),d 
9ca1			; 
9ca1			; 
9ca1			;	ld hl,(os_tok_malloc) 
9ca1			;if DEBUG_FORTH_PARSE_KEY 
9ca1			;			DMARK "TKU" 
9ca1			;	CALLMONITOR 
9ca1			;endif 
9ca1			; 
9ca1			;	ret 
9ca1			 
9ca1			forthexec: 
9ca1			 
9ca1			; line exec: 
9ca1			; forth parser 
9ca1			 
9ca1			; 
9ca1			;       get current exec line on rsp 
9ca1			 
9ca1				FORTH_RSP_TOS 
9ca1 cd 68 98			call macro_forth_rsp_tos 
9ca4				endm 
# End of macro FORTH_RSP_TOS
9ca4			 
9ca4			;       restore current pc - hl points to malloc of data 
9ca4			 
9ca4				;ld e, (hl) 
9ca4				;inc hl 
9ca4				;ld d, (hl) 
9ca4				;ex de,hl 
9ca4			 
9ca4			 
9ca4			exec1: 
9ca4 22 61 e6			ld (os_tok_ptr), hl 
9ca7			 
9ca7				; copy our PC to working vars  
9ca7 22 2b eb			ld (cli_ptr), hl 
9caa 22 29 eb			ld (cli_origptr), hl 
9cad			 
9cad 7e				ld a,(hl) 
9cae fe 7f			cp FORTH_END_BUFFER 
9cb0 c8				ret z 
9cb1			 
9cb1				; skip any nulls 
9cb1			 
9cb1 fe 00			cp 0 
9cb3 20 03			jr nz, .execword 
9cb5 23				inc hl 
9cb6 18 ec			jr exec1 
9cb8			 
9cb8			 
9cb8			.execword: 
9cb8			 
9cb8			 
9cb8			 
9cb8			if DEBUG_FORTH_PARSE_KEY 
9cb8						DMARK "KYQ" 
9cb8				CALLMONITOR 
9cb8			endif 
9cb8			;       while at start of word: 
9cb8			; get start of dict (in user area first) 
9cb8			 
9cb8 21 48 d7		ld hl, baseram 
9cbb			;ld hl, sysdict 
9cbb 22 2d eb		ld (cli_nextword),hl 
9cbe			;           match word at pc 
9cbe			;           exec word 
9cbe			;           or push to dsp 
9cbe			;           forward to next token 
9cbe			;           if line term pop rsp and exit 
9cbe			;        
9cbe			 
9cbe			if DEBUG_FORTH_PARSE_KEY 
9cbe						DMARK "KYq" 
9cbe				CALLMONITOR 
9cbe			endif 
9cbe			 
9cbe			; 
9cbe			; word comp 
9cbe			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9cbe			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9cbe			;    move to start of word  
9cbe			;    compare word to cli_token 
9cbe			 
9cbe			.execpnword:	; HL at start of a word in the dictionary to check 
9cbe			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9cbe			;	ld (cli_ptr), hl 
9cbe			 
9cbe 2a 2d eb			ld hl,(cli_nextword) 
9cc1			 
9cc1 cd 64 9d			call forth_tok_next 
9cc4			; tok next start here 
9cc4			;	; TODO skip compiled symbol for now 
9cc4			;	inc hl 
9cc4			; 
9cc4			;	; save pointer to next word 
9cc4			; 
9cc4			;	; hl now points to the address of the next word pointer  
9cc4			;	ld e, (hl) 
9cc4			;	inc hl 
9cc4			;	ld d, (hl) 
9cc4			;	inc l 
9cc4			; 
9cc4			;	ex de,hl 
9cc4			;if DEBUG_FORTH_PARSE_NEXTWORD 
9cc4			;	push bc 
9cc4			;	ld bc, (cli_nextword) 
9cc4			;			DMARK "NXW" 
9cc4			;	CALLMONITOR 
9cc4			;	pop bc 
9cc4			;endif 
9cc4			; tok next end here 
9cc4 22 2d eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
9cc7 eb				ex de, hl 
9cc8			 
9cc8			 
9cc8				; save the pointer of the current token - 1 to check against 
9cc8				 
9cc8 22 31 eb			ld (cli_token), hl   
9ccb				; TODO maybe remove below save if no debug 
9ccb				; save token string ptr for any debug later 
9ccb 23				inc hl  
9ccc 22 33 eb			ld (cli_origtoken), hl 
9ccf 2b				dec hl 
9cd0				; save pointer to the start of the next dictionay word 
9cd0 7e				ld a,(hl)   ; get string length 
9cd1 47				ld b,a 
9cd2			.execpnwordinc:  
9cd2 23				inc hl 
9cd3 10 fd			djnz .execpnwordinc 
9cd5 22 2f eb			ld (cli_execword), hl      ; save start of this words code 
9cd8			 
9cd8				; now check the word token against the string being parsed 
9cd8			 
9cd8 2a 31 eb			ld hl,(cli_token) 
9cdb 23				inc hl     ; skip string length (use zero term instead to end) 
9cdc 22 31 eb			ld (cli_token), hl 
9cdf			 
9cdf			if DEBUG_FORTH_PARSE_KEY 
9cdf						DMARK "KY2" 
9cdf			endif 
9cdf			if DEBUG_FORTH_PARSE_EXEC 
9cdf				; see if disabled 
9cdf			 
9cdf				ld a, (os_view_disable) 
9cdf				cp '*' 
9cdf				jr z, .skip 
9cdf			 
9cdf				push hl 
9cdf				push hl 
9cdf				call clear_display 
9cdf				ld de, .compword 
9cdf				ld a, display_row_1 
9cdf				call str_at_display 
9cdf				pop de 
9cdf				ld a, display_row_2 
9cdf				call str_at_display 
9cdf				ld hl,(cli_ptr) 
9cdf				ld a,(hl) 
9cdf			        ld hl, os_word_scratch 
9cdf				ld (hl),a 
9cdf				ld a,0 
9cdf				inc hl 
9cdf				ld (hl),a 	 
9cdf				ld de, os_word_scratch 
9cdf				ld a, display_row_2+10 
9cdf				call str_at_display 
9cdf				call update_display 
9cdf				ld a, 100 
9cdf				call aDelayInMS 
9cdf				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9cdf				call delay250ms 
9cdf				endif 
9cdf				pop hl 
9cdf			.skip:  
9cdf			endif	 
9cdf			.execpnchar:    ; compare char between token and string to parse 
9cdf			 
9cdf			if DEBUG_FORTH_PARSE_KEY 
9cdf						DMARK "Ky3" 
9cdf			endif 
9cdf			if DEBUG_FORTH_PARSE_EXEC 
9cdf				; see if disabled 
9cdf			 
9cdf				ld a, (os_view_disable) 
9cdf				cp '*' 
9cdf				jr z, .skip2 
9cdf			 
9cdf			;	call clear_display 
9cdf			ld hl,(cli_token) 
9cdf			ld a,(hl) 
9cdf			ld (os_word_scratch),a 
9cdf				ld hl,(cli_ptr) 
9cdf			ld a,(hl) 
9cdf				ld (os_word_scratch+1),a 
9cdf				ld a,0 
9cdf				ld (os_word_scratch+2),a 
9cdf				ld de,os_word_scratch 
9cdf				ld a,display_row_4 
9cdf				call str_at_display 
9cdf				call update_display 
9cdf			.skip2:  
9cdf			endif 
9cdf 2a 31 eb			ld hl,(cli_token) 
9ce2 7e				ld a, (hl)	 ; char in word token 
9ce3 23				inc hl 		; move to next char 
9ce4 22 31 eb			ld (cli_token), hl ; and save it 
9ce7 47				ld b,a 
9ce8			 
9ce8 2a 2b eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
9ceb 7e				ld a,(hl) 
9cec 23				inc hl 
9ced 22 2b eb			ld (cli_ptr), hl		; move to next char 
9cf0 cd ff 8e			call toUpper 		; make sure the input string matches case 
9cf3			 
9cf3			if DEBUG_FORTH_PARSE 
9cf3			endif 
9cf3			 
9cf3				; input stream end of token is a space so get rid of it 
9cf3			 
9cf3			;	cp ' ' 
9cf3			;	jr nz, .pnskipspace 
9cf3			; 
9cf3			;	ld a, 0		; make same term as word token term 
9cf3			; 
9cf3			;.pnskipspace: 
9cf3			 
9cf3			if DEBUG_FORTH_PARSE_KEY 
9cf3						DMARK "KY7" 
9cf3			endif 
9cf3 b8				cp b 
9cf4 c2 0a 9d			jp nz, .execpnskipword	 ; no match so move to next word 
9cf7				 
9cf7			;    if same 
9cf7			;       scan for string terms 0 for token and 32 for input 
9cf7			 
9cf7				 
9cf7			if DEBUG_FORTH_PARSE_KEY 
9cf7						DMARK "KY8" 
9cf7			endif 
9cf7			 
9cf7 80				add b			 
9cf8 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9cfa							; TODO need to make sure last word in zero term string is accounted for 
9cfa 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9cfc			 
9cfc			 
9cfc				; at end of both strings so both are exact match 
9cfc			 
9cfc			;       skip ptr for next word 
9cfc			 
9cfc 2a 2b eb			ld hl,(cli_ptr) 	; at input string term 
9cff 23				inc hl			 ; at next char 
9d00 22 2b eb			ld (cli_ptr), hl     ; save for next round of the parser 
9d03 22 29 eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9d06				 
9d06				 
9d06			if DEBUG_FORTH_PARSE_KEY 
9d06						DMARK "KY3" 
9d06			endif 
9d06			 
9d06			 
9d06			 
9d06			;       exec code block 
9d06			if DEBUG_FORTH_JP 
9d06				call clear_display 
9d06				call update_display 
9d06				call delay1s 
9d06				ld hl, (cli_execword)     ; save for next check if no match on this word 
9d06				ld a,h 
9d06				ld hl, os_word_scratch 
9d06				call hexout 
9d06				ld hl, (cli_execword)     ; save for next check if no match on this word 
9d06				ld a,l 
9d06				ld hl, os_word_scratch+2 
9d06				call hexout 
9d06				ld hl, os_word_scratch+4 
9d06				ld a,0 
9d06				ld (hl),a 
9d06				ld de,os_word_scratch 
9d06				call str_at_display 
9d06					ld a, display_row_2 
9d06					call str_at_display 
9d06				ld de, (cli_origtoken) 
9d06				ld a, display_row_1+10 
9d06					call str_at_display 
9d06			 
9d06				ld a,display_row_1 
9d06				ld de, .foundword 
9d06				ld a, display_row_3 
9d06				call str_at_display 
9d06				call update_display 
9d06				call delay1s 
9d06				call delay1s 
9d06				call delay1s 
9d06			endif 
9d06			 
9d06			if DEBUG_FORTH_PARSE_KEY 
9d06						DMARK "KYj" 
9d06			endif 
9d06				; TODO save the word pointer in this exec 
9d06			 
9d06 2a 2f eb			ld hl,(cli_execword) 
9d09 e9				jp (hl) 
9d0a			 
9d0a			 
9d0a			;    if not same 
9d0a			;	scan for zero term 
9d0a			;	get ptr for next word 
9d0a			;	goto word comp 
9d0a			 
9d0a			.execpnskipword:	; get pointer to next word 
9d0a 2a 2d eb			ld hl,(cli_nextword) 
9d0d			 
9d0d 7e				ld a,(hl) 
9d0e fe 00			cp WORD_SYS_END 
9d10			;	cp 0 
9d10 28 09			jr z, .execendofdict			 ; at end of words 
9d12			 
9d12			if DEBUG_FORTH_PARSE_KEY 
9d12						DMARK "KY4" 
9d12			endif 
9d12			if DEBUG_FORTH_PARSE_EXEC 
9d12			 
9d12				; see if disabled 
9d12			 
9d12				ld a, (os_view_disable) 
9d12				cp '*' 
9d12				jr z, .noskip 
9d12			 
9d12			 
9d12				ld de, .nowordfound 
9d12				ld a, display_row_3 
9d12				call str_at_display 
9d12				call update_display 
9d12				ld a, 100 
9d12				call aDelayInMS 
9d12				 
9d12				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9d12					call delay250ms 
9d12				endif 
9d12			.noskip:  
9d12			 
9d12			endif	 
9d12			 
9d12 2a 29 eb			ld hl,(cli_origptr) 
9d15 22 2b eb			ld (cli_ptr),hl 
9d18			 
9d18			if DEBUG_FORTH_PARSE_KEY 
9d18						DMARK "KY5" 
9d18			endif 
9d18 c3 be 9c			jp .execpnword			; else go to next word 
9d1b			 
9d1b			.execendofdict:  
9d1b			 
9d1b			if DEBUG_FORTH_PARSE_KEY 
9d1b						DMARK "KYe" 
9d1b			endif 
9d1b			if DEBUG_FORTH_PARSE_EXEC 
9d1b				; see if disabled 
9d1b			 
9d1b				ld a, (os_view_disable) 
9d1b				cp '*' 
9d1b				jr z, .ispskip 
9d1b			 
9d1b				call clear_display 
9d1b				call update_display 
9d1b				call delay1s 
9d1b				ld de, (cli_origptr) 
9d1b				ld a, display_row_1 
9d1b				call str_at_display 
9d1b				 
9d1b				ld de, .enddict 
9d1b				ld a, display_row_3 
9d1b				call str_at_display 
9d1b				call update_display 
9d1b				ld a, 100 
9d1b				call aDelayInMS 
9d1b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9d1b				call delay1s 
9d1b				call delay1s 
9d1b				call delay1s 
9d1b				endif 
9d1b			.ispskip:  
9d1b				 
9d1b			endif	 
9d1b			 
9d1b			 
9d1b			 
9d1b				; if the word is not a keyword then must be a literal so push it to stack 
9d1b			 
9d1b			; push token to stack to end of word 
9d1b			 
9d1b				STACKFRAME ON $1efe $2f9f 
9d1b				if DEBUG_STACK_IMB 
9d1b					if ON 
9d1b						exx 
9d1b						ld de, $1efe 
9d1b						ld a, d 
9d1b						ld hl, curframe 
9d1b						call hexout 
9d1b						ld a, e 
9d1b						ld hl, curframe+2 
9d1b						call hexout 
9d1b						ld hl, $1efe 
9d1b						push hl 
9d1b						ld hl, $2f9f 
9d1b						push hl 
9d1b						exx 
9d1b					endif 
9d1b				endif 
9d1b			endm 
# End of macro STACKFRAME
9d1b			 
9d1b 2a 61 e6		ld hl,(os_tok_ptr) 
9d1e cd 13 9a		call forth_apush 
9d21			 
9d21				STACKFRAMECHK ON $1efe $2f9f 
9d21				if DEBUG_STACK_IMB 
9d21					if ON 
9d21						exx 
9d21						ld hl, $2f9f 
9d21						pop de   ; $2f9f 
9d21						call cmp16 
9d21						jr nz, .spnosame 
9d21						ld hl, $1efe 
9d21						pop de   ; $1efe 
9d21						call cmp16 
9d21						jr z, .spfrsame 
9d21						.spnosame: call showsperror 
9d21						.spfrsame: nop 
9d21						exx 
9d21					endif 
9d21				endif 
9d21			endm 
# End of macro STACKFRAMECHK
9d21			 
9d21			execnext: 
9d21			 
9d21			if DEBUG_FORTH_PARSE_KEY 
9d21						DMARK "KY>" 
9d21			endif 
9d21			; move past token to next word 
9d21			 
9d21 2a 61 e6		ld hl, (os_tok_ptr) 
9d24 3e 00		ld a, 0 
9d26 01 ff 00		ld bc, 255     ; input buffer size 
9d29 ed b1		cpir 
9d2b			 
9d2b			if DEBUG_FORTH_PARSE_KEY 
9d2b						DMARK "KY!" 
9d2b				CALLMONITOR 
9d2b			endif	 
9d2b			; TODO this might place hl on the null, so will need to forward on??? 
9d2b			;inc hl   ; see if this gets onto the next item 
9d2b			 
9d2b			 
9d2b			; TODO pass a pointer to the buffer to push 
9d2b			; TODO call function to push 
9d2b			 
9d2b			; look for end of input 
9d2b			 
9d2b			;inc hl 
9d2b			;ld a,(hl) 
9d2b			;cp FORTH_END_BUFFER 
9d2b			;ret z 
9d2b			 
9d2b			 
9d2b c3 a4 9c		jp exec1 
9d2e			 
9d2e			 
9d2e			 
9d2e			 
9d2e			 
9d2e			 
9d2e			 
9d2e			 
9d2e			 
9d2e			findnexttok: 
9d2e			 
9d2e				; hl is pointer to move 
9d2e				; de is the token to locate 
9d2e			 
9d2e					if DEBUG_FORTH 
9d2e						DMARK "NTK" 
9d2e						CALLMONITOR 
9d2e					endif 
9d2e d5				push de 
9d2f			 
9d2f			.fnt1:	 
9d2f				; find first char of token to locate 
9d2f			 
9d2f 1a				ld a, (de) 
9d30 4f				ld c,a 
9d31 7e				ld a,(hl) 
9d32 cd ff 8e			call toUpper 
9d35					if DEBUG_FORTH 
9d35						DMARK "NT1" 
9d35						CALLMONITOR 
9d35					endif 
9d35 b9				cp c 
9d36			 
9d36 28 03			jr z, .fnt2cmpmorefirst	 
9d38			 
9d38				; first char not found move to next char 
9d38			 
9d38 23				inc hl 
9d39 18 f4			jr .fnt1 
9d3b			 
9d3b			.fnt2cmpmorefirst:	 
9d3b				; first char of token found.  
9d3b			 
9d3b e5				push hl     ; save start of token just in case it is the right one 
9d3c d9				exx 
9d3d e1				pop hl        ; save it to hl' 
9d3e d9				exx 
9d3f			 
9d3f			 
9d3f			.fnt2cmpmore:	 
9d3f				; compare the rest 
9d3f				 
9d3f 23				inc hl 
9d40 13				inc de 
9d41				 
9d41 1a				ld a, (de) 
9d42 4f				ld c,a 
9d43 7e				ld a,(hl) 
9d44 cd ff 8e			call toUpper 
9d47			 
9d47					if DEBUG_FORTH 
9d47						DMARK "NT2" 
9d47						CALLMONITOR 
9d47					endif 
9d47				; c has the token to find char 
9d47				; a has the mem to scan char 
9d47			 
9d47 b9				cp c 
9d48 28 04			jr z,.fntmatch1 
9d4a			 
9d4a				; they are not the same 
9d4a			 
9d4a					if DEBUG_FORTH 
9d4a						DMARK "NT3" 
9d4a						CALLMONITOR 
9d4a					endif 
9d4a d1				pop de	; reset de token to look for 
9d4b d5				push de 
9d4c 18 e1			jr .fnt1 
9d4e				 
9d4e			.fntmatch1: 
9d4e			 
9d4e				; is the same char a null which means we might have a full hit? 
9d4e					if DEBUG_FORTH 
9d4e						DMARK "NT4" 
9d4e						CALLMONITOR 
9d4e					endif 
9d4e			 
9d4e fe 00			cp 0 
9d50 28 0b			jr z, .fntmatchyes 
9d52			 
9d52				; are we at the end of the token to find? 
9d52			 
9d52					if DEBUG_FORTH 
9d52						DMARK "NT5" 
9d52						CALLMONITOR 
9d52					endif 
9d52 3e 00			ld a, 0 
9d54 b9				cp c 
9d55			 
9d55 c2 3f 9d			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9d58			 
9d58					if DEBUG_FORTH 
9d58						DMARK "NT6" 
9d58						CALLMONITOR 
9d58					endif 
9d58				; token to find is exhusted but no match to stream 
9d58			 
9d58				; restore tok pointer and continue on 
9d58 d1				pop de 
9d59 d5				push de 
9d5a c3 2f 9d			jp .fnt1 
9d5d			 
9d5d			 
9d5d			.fntmatchyes: 
9d5d			 
9d5d				; hl now contains the end of the found token 
9d5d			 
9d5d				; get rid of saved token pointer to find 
9d5d			 
9d5d d1				pop de 
9d5e			 
9d5e					if DEBUG_FORTH 
9d5e						DMARK "NT9" 
9d5e						CALLMONITOR 
9d5e					endif 
9d5e			 
9d5e				; hl will be on the null term so forward on 
9d5e			 
9d5e				; get back the saved start of the token 
9d5e			 
9d5e d9				exx 
9d5f e5				push hl     ; save start of token just in case it is the right one 
9d60 d9				exx 
9d61 e1				pop hl        ; save it to hl 
9d62			 
9d62 c9				ret 
9d63			 
9d63			 
9d63			; LIST needs to find a specific token   
9d63			; FORGET needs to find a spefici token 
9d63			 
9d63			; SAVE needs to find all tokens by flag 
9d63			; WORDS just needs to scan through all  by flag 
9d63			; UWORDS needs to scan through all by flag 
9d63			 
9d63			 
9d63			; given hl as pointer to start of dict look up string 
9d63			; return hl as pointer to start of word block 
9d63			; or 0 if not found 
9d63			 
9d63			forth_find_tok: 
9d63 c9				ret 
9d64			 
9d64			; given hl as pointer to dict structure 
9d64			; move to the next dict block structure 
9d64			 
9d64			forth_tok_next: 
9d64				; hl now points to the address of the next word pointer  
9d64				; TODO skip compiled symbol for now 
9d64			;	push de 
9d64 23				inc hl 
9d65 5e				ld e, (hl) 
9d66 23				inc hl 
9d67 56				ld d, (hl) 
9d68 23				inc hl 
9d69			 
9d69 eb				ex de,hl 
9d6a			if DEBUG_FORTH_PARSE_NEXTWORD 
9d6a				push bc 
9d6a				ld bc, (cli_nextword) 
9d6a						DMARK "NXW" 
9d6a				CALLMONITOR 
9d6a				pop bc 
9d6a			endif 
9d6a			;	pop de	 
9d6a c9				ret 
9d6b			 
9d6b			 
9d6b			 
9d6b			; eof 
# End of file forth_parserv5.asm
9d6b				include "forth_wordsv4.asm" 
9d6b			 
9d6b			; the core word dictionary v4 
9d6b			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9d6b			 
9d6b			; this is a linked list for each of the system words used 
9d6b			; user defined words will follow the same format but will be in ram 
9d6b			 
9d6b			 
9d6b			; 
9d6b			; 
9d6b			; define linked list: 
9d6b			; 
9d6b			; 1. compiled byte op code 
9d6b			; 2. len of text word 
9d6b			; 3. text word 
9d6b			; 4. ptr to next dictionary word 
9d6b			; 5. asm, calls etc for the word 
9d6b			; 
9d6b			;  if 1 == 0 then last word in dict  
9d6b			;   
9d6b			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9d6b			;  
9d6b			;  
9d6b			; create basic standard set of words 
9d6b			; 
9d6b			;  
9d6b			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9d6b			; 2DUP 2DROP 2SWAP  
9d6b			; @ C@ - get byte  
9d6b			; ! C! - store byte 
9d6b			; 0< true if less than zero 
9d6b			; 0= true if zero 
9d6b			; < >  
9d6b			; = true if same 
9d6b			; variables 
9d6b			 
9d6b			 
9d6b			; Hardware specific words I may need 
9d6b			; 
9d6b			; IN OUT  
9d6b			; calls to key util functions 
9d6b			; calls to hardward abstraction stuff 
9d6b			; easy control of frame buffers and lcd i/o 
9d6b			; keyboard  
9d6b			 
9d6b			 
9d6b			;DICT: macro 
9d6b			; op_code, len, word, next 
9d6b			;    word: 
9d6b			;    db op_code 
9d6b			;    ds word zero term 
9d6b			;    dw next 
9d6b			;    endm 
9d6b			 
9d6b			 
9d6b			 
9d6b			 
9d6b			; op code 1 is a flag for user define words which are to be handled differently 
9d6b			 
9d6b			 
9d6b			; 
9d6b			; 
9d6b			;    TODO on entry to a word this should be the expected environment 
9d6b			;    hl - tos value if number then held, if string this is the ptr 
9d6b			;    de -  
9d6b			 
9d6b			 
9d6b			; opcode ranges 
9d6b			; 0 - end of word dict 
9d6b			; 255 - user define words 
9d6b			 
9d6b			sysdict: 
9d6b			include "forth_opcodes.asm" 
9d6b			; op codes for forth keywords 
9d6b			; free to use code 0  
9d6b				OPCODE_HEAP: equ  1 
9d6b				OPCODE_EXEC: equ 2 
9d6b				OPCODE_DUP: equ 3 
9d6b				OPCODE_SWAP: equ 4 
9d6b				OPCODE_COLN: equ 5 
9d6b				OPCODE_SCOLN: equ 6 
9d6b				OPCODE_DROP: equ 7 
9d6b				OPCODE_DUP2: equ 8 
9d6b				OPCODE_DROP2: equ 9 
9d6b				OPCODE_SWAP2: equ 10 
9d6b				OPCODE_AT: equ 11 
9d6b				OPCODE_CAT: equ 12 
9d6b				OPCODE_BANG: equ 13 
9d6b				OPCODE_CBANG: equ 14 
9d6b				OPCODE_SCALL: equ 15 
9d6b				OPCODE_DEPTH: equ 16 
9d6b				OPCODE_OVER: equ 17 
9d6b				OPCODE_PAUSE: equ 18 
9d6b				OPCODE_PAUSES: equ 19 
9d6b				OPCODE_ROT: equ 20 
9d6b			;free to reuse	OPCODE_WORDS: equ 21 
9d6b			        OPCODE_NOT: equ 21 
9d6b				OPCODE_UWORDS: equ 22 
9d6b				OPCODE_BP: equ 23 
9d6b				OPCODE_MONITOR: equ 24  
9d6b				OPCODE_MALLOC: equ 25 
9d6b				OPCODE_FREE: equ 26 
9d6b				OPCODE_LIST: equ 27 
9d6b				OPCODE_FORGET: equ 28 
9d6b				OPCODE_NOP: equ 29 
9d6b				OPCODE_COMO: equ 30 
9d6b				OPCODE_COMC: equ 31 
9d6b			;free to reuse	OPCODE_ENDCORE: equ 32 
9d6b				OPCODE_AFTERSOUND: equ 33 
9d6b				OPCODE_GP2: equ 34 
9d6b				OPCODE_GP3: equ 35 
9d6b				OPCODE_GP4: equ 36 
9d6b				OPCODE_SIN: equ 37 
9d6b				OPCODE_SOUT: equ 38 
9d6b				OPCODE_SPIO: equ 39 
9d6b				OPCODE_SPICEH: equ 40 
9d6b				OPCODE_SPIOb: equ 41 
9d6b				OPCODE_SPII: equ 42 
9d6b				OPCODE_SESEL: equ 43 
9d6b				OPCODE_CARTDEV: equ 44 
9d6b			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9d6b				OPCODE_FB: equ 46 
9d6b				OPCODE_EMIT: equ 47 
9d6b				OPCODE_DOTH: equ 48 
9d6b				OPCODE_DOTF: equ 49 
9d6b				OPCODE_DOT: equ 50 
9d6b				OPCODE_CLS: equ 51 
9d6b				OPCODE_DRAW: equ 52 
9d6b				OPCODE_DUMP: equ 53 
9d6b				OPCODE_CDUMP: equ 54 
9d6b				OPCODE_DAT: equ 55 
9d6b				OPCODE_HOME: equ 56 
9d6b				OPCODE_SPACE: equ 57 
9d6b				OPCODE_SPACES: equ 58 
9d6b				OPCODE_SCROLL: equ 59 
9d6b				OPCODE_ATQ: equ 60 
9d6b				OPCODE_AUTODSP: equ 61 
9d6b				OPCODE_MENU: equ 62 
9d6b			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9d6b				OPCODE_THEN: equ 64 
9d6b				OPCODE_ELSE: equ 65 
9d6b				OPCODE_DO: equ 66 
9d6b				OPCODE_LOOP: equ 67 
9d6b				OPCODE_I: equ 68 
9d6b				OPCODE_DLOOP: equ 69  
9d6b				OPCODE_REPEAT: equ 70  
9d6b				OPCODE_UNTIL: equ 71 
9d6b				OPCODE_ENDFLOW: equ 72 
9d6b				OPCODE_WAITK: equ 73 
9d6b				OPCODE_ACCEPT: equ 74 
9d6b				OPCODE_EDIT: equ 75 
9d6b			;free to reuse	OPCODE_ENDKEY: equ 76 
9d6b				OPCODE_LZERO: equ 77 
9d6b				OPCODE_TZERO: equ 78 
9d6b				OPCODE_LESS: equ 79 
9d6b				OPCODE_GT: equ 80 
9d6b				OPCODE_EQUAL: equ 81  
9d6b			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9d6b				OPCODE_NEG: equ 83 
9d6b				OPCODE_DIV: equ 84 
9d6b				OPCODE_MUL: equ 85 
9d6b				OPCODE_MIN: equ 86 
9d6b				OPCODE_MAX: equ 87 
9d6b				OPCODE_RND16: equ 88 
9d6b				OPCODE_RND8: equ 89 
9d6b				OPCODE_RND: equ 90 
9d6b			;free to reuse	OPCODE_ENDMATHS: equ 91  
9d6b				OPCODE_BYNAME: equ 92 
9d6b				OPCODE_DIR: equ 93 
9d6b				OPCODE_SAVE: equ 94 
9d6b				OPCODE_LOAD: equ 95 
9d6b				OPCODE_BSAVE: equ 96 
9d6b				OPCODE_BLOAD: equ 97 
9d6b				OPCODE_SEO: equ 98  
9d6b				OPCODE_SEI: equ 99 
9d6b				OPCODE_SFREE: equ 100 
9d6b				OPCODE_SIZE: equ 101 
9d6b				OPCODE_CREATE: equ 102 
9d6b				OPCODE_APPEND: equ 103 
9d6b				OPCODE_SDEL: equ 104 
9d6b				OPCODE_OPEN: equ 105 
9d6b				OPCODE_READ: equ 106 
9d6b				OPCODE_EOF: equ 106 
9d6b				OPCODE_FORMAT: equ 107 
9d6b				OPCODE_LABEL: equ 108 
9d6b				OPCODE_LABELS: equ 109 
9d6b			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9d6b				OPCODE_UPPER: equ 111 
9d6b				OPCODE_LOWER: equ 112 
9d6b				OPCODE_SUBSTR: equ 113 
9d6b				OPCODE_LEFT: equ 114 
9d6b				OPCODE_RIGHT: equ 115 
9d6b				OPCODE_STR2NUM: equ 116 
9d6b				OPCODE_NUM2STR: equ 117 
9d6b				OPCODE_CONCAT: equ 118 
9d6b				OPCODE_FIND: equ 119 
9d6b				OPCODE_LEN: equ 120 
9d6b				OPCODE_CHAR: equ 121 
9d6b			; free to reuse	OPCODE_STRLEN: equ 122 
9d6b			; free to reuse	OPCODE_ENDSTR: equ 123 
9d6b				OPCODE_V0S: equ 124 
9d6b				OPCODE_V0Q: equ 125 
9d6b				OPCODE_V1S: equ 126 
9d6b				OPCODE_V1Q: equ 127 
9d6b				OPCODE_V2S: equ 128 
9d6b				OPCODE_V2Q: equ 129 
9d6b				OPCODE_V3S: equ 130 
9d6b				OPCODE_V3Q: equ 131 
9d6b			;free to reuse	OPCODE_END: equ 132 
9d6b				OPCODE_ZDUP: equ 133 
9d6b			 
9d6b			; eof 
# End of file forth_opcodes.asm
9d6b			 
9d6b			include "forth_words_core.asm" 
9d6b			 
9d6b			; | ## Core Words 
9d6b			 
9d6b			;if MALLOC_4 
9d6b			 
9d6b			.HEAP: 
9d6b				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9d6b 15				db WORD_SYS_CORE+OPCODE_HEAP             
9d6c aa 9d			dw .EXEC            
9d6e 05				db 4 + 1 
9d6f .. 00			db "HEAP",0              
9d74				endm 
# End of macro CWHEAD
9d74			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9d74			; | | u1 - Current number of bytes in the heap 
9d74			; | | u2 - Remaining bytes left on the heap 
9d74			; | |  
9d74			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9d74			 
9d74			 
9d74					if DEBUG_FORTH_WORDS_KEY 
9d74						DMARK "HEP" 
9d74 f5				push af  
9d75 3a 89 9d			ld a, (.dmark)  
9d78 32 7a ee			ld (debug_mark),a  
9d7b 3a 8a 9d			ld a, (.dmark+1)  
9d7e 32 7b ee			ld (debug_mark+1),a  
9d81 3a 8b 9d			ld a, (.dmark+2)  
9d84 32 7c ee			ld (debug_mark+2),a  
9d87 18 03			jr .pastdmark  
9d89 ..			.dmark: db "HEP"  
9d8c f1			.pastdmark: pop af  
9d8d			endm  
# End of macro DMARK
9d8d						CALLMONITOR 
9d8d cd 1d 93			call break_point_state  
9d90				endm  
# End of macro CALLMONITOR
9d90					endif 
9d90 2a 52 d7				ld hl, (free_list )      
9d93 11 57 d7				ld de, heap_start 
9d96			 
9d96 ed 52				sbc hl, de  
9d98			 
9d98 cd aa 98				call forth_push_numhl 
9d9b			 
9d9b			 
9d9b ed 5b 52 d7			ld de, (free_list )      
9d9f 21 46 e3				ld hl, heap_end 
9da2			 
9da2 ed 52				sbc hl, de 
9da4			 
9da4 cd aa 98				call forth_push_numhl 
9da7					 
9da7			 
9da7					 
9da7			 
9da7			 
9da7			 
9da7					NEXTW 
9da7 c3 13 9c			jp macro_next 
9daa				endm 
# End of macro NEXTW
9daa			;endif 
9daa			 
9daa			.EXEC: 
9daa			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9daa			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9daa			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9daa			;; > > 
9daa			;; > >   
9daa			;	STACKFRAME OFF $5efe $5f9f 
9daa			; 
9daa			;		if DEBUG_FORTH_WORDS_KEY 
9daa			;			DMARK "EXE" 
9daa			;			CALLMONITOR 
9daa			;		endif 
9daa			; 
9daa			;	FORTH_DSP_VALUEHL 
9daa			; 
9daa			;	FORTH_DSP_POP 
9daa			; 
9daa			;		if DEBUG_FORTH_WORDS 
9daa			;			DMARK "EX1" 
9daa			;			CALLMONITOR 
9daa			;		endif 
9daa			;;	ld e,(hl) 
9daa			;;	inc hl 
9daa			;;	ld d,(hl) 
9daa			;;	ex de,hl 
9daa			; 
9daa			;;		if DEBUG_FORTH_WORDS 
9daa			;;			DMARK "EX2" 
9daa			;;			CALLMONITOR 
9daa			;;		endif 
9daa			;	push hl 
9daa			; 
9daa			;	;ld a, 0 
9daa			;	;ld a, FORTH_END_BUFFER 
9daa			;	call strlenz 
9daa			;	inc hl   ; include zero term to copy 
9daa			;	inc hl   ; include term 
9daa			;	inc hl   ; include term 
9daa			;	ld b,0 
9daa			;	ld c,l 
9daa			;	pop hl 
9daa			;	ld de, execscratch 
9daa			;		if DEBUG_FORTH_WORDS 
9daa			;			DMARK "EX3" 
9daa			;			CALLMONITOR 
9daa			;		endif 
9daa			;	ldir 
9daa			; 
9daa			; 
9daa			;	ld hl, execscratch 
9daa			; 
9daa			;		if DEBUG_FORTH_WORDS 
9daa			;			DMARK "EXe" 
9daa			;			CALLMONITOR 
9daa			;		endif 
9daa			; 
9daa			;	call forthparse 
9daa			;	call forthexec 
9daa			;;	call forthexec_cleanup 
9daa			;;	call forthparse 
9daa			;;	call forthexec 
9daa			; 
9daa			;	STACKFRAMECHK OFF $5efe $5f9f 
9daa			; 
9daa			;	; an immediate word so no need to process any more words 
9daa			;	ret 
9daa			;	NEXTW 
9daa			 
9daa			; dead code - old version  
9daa			;	FORTH_RSP_NEXT 
9daa			 
9daa			;  
9daa			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9daa			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9daa			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9daa			;	push hl 
9daa			;	push de 
9daa			;	push bc 
9daa			; 
9daa			; 
9daa			;		if DEBUG_FORTH_WORDS_KEY 
9daa			;			DMARK "EXR" 
9daa			;			CALLMONITOR 
9daa			;		endif 
9daa			; 
9daa			; 
9daa			; 
9daa			;	;v5 FORTH_DSP_VALUE 
9daa			;	FORTH_DSP_VALUEHL 
9daa			; 
9daa			;	; TODO do string type checks 
9daa			; 
9daa			;;v5	inc hl   ; skip type 
9daa			; 
9daa			;	push hl  ; source code  
9daa			;		if DEBUG_FORTH_WORDS 
9daa			;			DMARK "EX1" 
9daa			;			CALLMONITOR 
9daa			;		endif 
9daa			;	ld a, 0 
9daa			;	call strlent 
9daa			; 
9daa			;	inc hl 
9daa			;	inc hl 
9daa			;	inc hl 
9daa			;	inc hl 
9daa			; 
9daa			;	push hl    ; size 
9daa			; 
9daa			;		if DEBUG_FORTH_WORDS 
9daa			;			DMARK "EX2" 
9daa			;			CALLMONITOR 
9daa			;		endif 
9daa			;	call malloc 
9daa			; 
9daa			;	ex de, hl    ; de now contains malloc area 
9daa			;	pop bc   	; get byte count 
9daa			;	pop hl      ; get string to copy 
9daa			; 
9daa			;	push de     ; save malloc for free later 
9daa			; 
9daa			;		if DEBUG_FORTH_WORDS 
9daa			;			DMARK "EX3" 
9daa			;			CALLMONITOR 
9daa			;		endif 
9daa			;	ldir       ; duplicate string 
9daa			; 
9daa			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9daa			;	 
9daa			;	; TODO fix the parse would be better than this...  
9daa			;	ex de, hl 
9daa			;	dec hl 
9daa			;	ld a, 0 
9daa			;	ld (hl), a 
9daa			;	dec hl 
9daa			;	ld a, ' ' 
9daa			;	ld (hl), a 
9daa			;	dec hl 
9daa			;	ld (hl), a 
9daa			; 
9daa			;	dec hl 
9daa			;	ld (hl), a 
9daa			; 
9daa			; 
9daa			;	FORTH_DSP_POP  
9daa			; 
9daa			;	pop hl     
9daa			;	push hl    ; save malloc area 
9daa			; 
9daa			;		if DEBUG_FORTH_WORDS 
9daa			;			DMARK "EX4" 
9daa			;			CALLMONITOR 
9daa			;		endif 
9daa			; 
9daa			;	call forthparse 
9daa			;	call forthexec 
9daa			;	 
9daa			;	pop hl 
9daa			;	if DEBUG_FORTH_WORDS 
9daa			;		DMARK "EX5" 
9daa			;		CALLMONITOR 
9daa			;	endif 
9daa			; 
9daa			;	if FORTH_ENABLE_FREE 
9daa			;	call free 
9daa			;	endif 
9daa			; 
9daa			;	if DEBUG_FORTH_WORDS 
9daa			;		DMARK "EX6" 
9daa			;		CALLMONITOR 
9daa			;	endif 
9daa			; 
9daa			;	pop bc 
9daa			;	pop de 
9daa			;	pop hl 
9daa			;;	FORTH_RSP_POP	  
9daa			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9daa			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9daa			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9daa			; 
9daa			;	if DEBUG_FORTH_WORDS 
9daa			;		DMARK "EX7" 
9daa			;		CALLMONITOR 
9daa			;	endif 
9daa			;	NEXTW 
9daa			 
9daa			;.STKEXEC: 
9daa			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9daa			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9daa			; 
9daa			; 
9daa			;		if DEBUG_FORTH_WORDS_KEY 
9daa			;			DMARK "STX" 
9daa			;			CALLMONITOR 
9daa			;		endif 
9daa			; 
9daa			;	FORTH_DSP_VALUEHL 
9daa			; 
9daa			;	ld (store_tmp1), hl    ; count 
9daa			; 
9daa			;	FORTH_DSP_POP 
9daa			;.stkexec1: 
9daa			;	ld hl, (store_tmp1)   ; count 
9daa			;	ld a, 0 
9daa			;	cp l 
9daa			;	ret z 
9daa			; 
9daa			;	dec hl 
9daa			;	ld (store_tmp1), hl    ; count 
9daa			;	 
9daa			;	FORTH_DSP_VALUEHL 
9daa			;	push hl 
9daa			;	 
9daa			;		if DEBUG_FORTH_WORDS 
9daa			;			DMARK "EXp" 
9daa			;			CALLMONITOR 
9daa			;		endif 
9daa			;	FORTH_DSP_POP 
9daa			; 
9daa			;	call strlenz 
9daa			;	inc hl   ; include zero term to copy 
9daa			;	inc hl   ; include zero term to copy 
9daa			;	inc hl   ; include zero term to copy 
9daa			;	ld b,0 
9daa			;	ld c,l 
9daa			;	pop hl 
9daa			;	ld de, execscratch 
9daa			;		if DEBUG_FORTH_WORDS 
9daa			;			DMARK "EX3" 
9daa			;			CALLMONITOR 
9daa			;		endif 
9daa			;	ldir 
9daa			; 
9daa			; 
9daa			;	ld hl, execscratch 
9daa			; 
9daa			;		if DEBUG_FORTH_WORDS 
9daa			;			DMARK "EXP" 
9daa			;			CALLMONITOR 
9daa			;		endif 
9daa			; 
9daa			;	call forthparse 
9daa			;	ld hl, execscratch 
9daa			;		if DEBUG_FORTH_WORDS 
9daa			;			DMARK "EXx" 
9daa			;			CALLMONITOR 
9daa			;		endif 
9daa			;	call forthexec 
9daa			; 
9daa			;	jp .stkexec1 
9daa			; 
9daa			;	ret 
9daa			 
9daa			 
9daa			.DUP: 
9daa				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9daa 17				db WORD_SYS_CORE+OPCODE_DUP             
9dab 20 9e			dw .ZDUP            
9dad 04				db 3 + 1 
9dae .. 00			db "DUP",0              
9db2				endm 
# End of macro CWHEAD
9db2			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9db2			 
9db2					if DEBUG_FORTH_WORDS_KEY 
9db2						DMARK "DUP" 
9db2 f5				push af  
9db3 3a c7 9d			ld a, (.dmark)  
9db6 32 7a ee			ld (debug_mark),a  
9db9 3a c8 9d			ld a, (.dmark+1)  
9dbc 32 7b ee			ld (debug_mark+1),a  
9dbf 3a c9 9d			ld a, (.dmark+2)  
9dc2 32 7c ee			ld (debug_mark+2),a  
9dc5 18 03			jr .pastdmark  
9dc7 ..			.dmark: db "DUP"  
9dca f1			.pastdmark: pop af  
9dcb			endm  
# End of macro DMARK
9dcb						CALLMONITOR 
9dcb cd 1d 93			call break_point_state  
9dce				endm  
# End of macro CALLMONITOR
9dce					endif 
9dce			 
9dce					FORTH_DSP 
9dce cd 67 9a			call macro_forth_dsp 
9dd1				endm 
# End of macro FORTH_DSP
9dd1			 
9dd1 7e					ld a, (HL) 
9dd2 fe 01				cp DS_TYPE_STR 
9dd4 20 25				jr nz, .dupinum 
9dd6			 
9dd6					; push another string 
9dd6			 
9dd6					FORTH_DSP_VALUEHL     		 
9dd6 cd a1 9a			call macro_dsp_valuehl 
9dd9				endm 
# End of macro FORTH_DSP_VALUEHL
9dd9			 
9dd9				if DEBUG_FORTH_WORDS 
9dd9					DMARK "DUs" 
9dd9 f5				push af  
9dda 3a ee 9d			ld a, (.dmark)  
9ddd 32 7a ee			ld (debug_mark),a  
9de0 3a ef 9d			ld a, (.dmark+1)  
9de3 32 7b ee			ld (debug_mark+1),a  
9de6 3a f0 9d			ld a, (.dmark+2)  
9de9 32 7c ee			ld (debug_mark+2),a  
9dec 18 03			jr .pastdmark  
9dee ..			.dmark: db "DUs"  
9df1 f1			.pastdmark: pop af  
9df2			endm  
# End of macro DMARK
9df2					CALLMONITOR 
9df2 cd 1d 93			call break_point_state  
9df5				endm  
# End of macro CALLMONITOR
9df5				endif 
9df5 cd 18 99				call forth_push_str 
9df8			 
9df8					NEXTW 
9df8 c3 13 9c			jp macro_next 
9dfb				endm 
# End of macro NEXTW
9dfb			 
9dfb			 
9dfb			.dupinum: 
9dfb					 
9dfb			 
9dfb			 
9dfb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9dfb cd a1 9a			call macro_dsp_valuehl 
9dfe				endm 
# End of macro FORTH_DSP_VALUEHL
9dfe			 
9dfe				; TODO add floating point number detection 
9dfe			 
9dfe				if DEBUG_FORTH_WORDS 
9dfe					DMARK "DUi" 
9dfe f5				push af  
9dff 3a 13 9e			ld a, (.dmark)  
9e02 32 7a ee			ld (debug_mark),a  
9e05 3a 14 9e			ld a, (.dmark+1)  
9e08 32 7b ee			ld (debug_mark+1),a  
9e0b 3a 15 9e			ld a, (.dmark+2)  
9e0e 32 7c ee			ld (debug_mark+2),a  
9e11 18 03			jr .pastdmark  
9e13 ..			.dmark: db "DUi"  
9e16 f1			.pastdmark: pop af  
9e17			endm  
# End of macro DMARK
9e17					CALLMONITOR 
9e17 cd 1d 93			call break_point_state  
9e1a				endm  
# End of macro CALLMONITOR
9e1a				endif 
9e1a			 
9e1a cd aa 98				call forth_push_numhl 
9e1d					NEXTW 
9e1d c3 13 9c			jp macro_next 
9e20				endm 
# End of macro NEXTW
9e20			.ZDUP: 
9e20				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9e20 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9e21 58 9e			dw .SWAP            
9e23 05				db 4 + 1 
9e24 .. 00			db "?DUP",0              
9e29				endm 
# End of macro CWHEAD
9e29			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
9e29			 
9e29					if DEBUG_FORTH_WORDS_KEY 
9e29						DMARK "qDU" 
9e29 f5				push af  
9e2a 3a 3e 9e			ld a, (.dmark)  
9e2d 32 7a ee			ld (debug_mark),a  
9e30 3a 3f 9e			ld a, (.dmark+1)  
9e33 32 7b ee			ld (debug_mark+1),a  
9e36 3a 40 9e			ld a, (.dmark+2)  
9e39 32 7c ee			ld (debug_mark+2),a  
9e3c 18 03			jr .pastdmark  
9e3e ..			.dmark: db "qDU"  
9e41 f1			.pastdmark: pop af  
9e42			endm  
# End of macro DMARK
9e42						CALLMONITOR 
9e42 cd 1d 93			call break_point_state  
9e45				endm  
# End of macro CALLMONITOR
9e45					endif 
9e45					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9e45 cd a1 9a			call macro_dsp_valuehl 
9e48				endm 
# End of macro FORTH_DSP_VALUEHL
9e48			 
9e48 e5					push hl 
9e49			 
9e49					; is it a zero? 
9e49			 
9e49 3e 00				ld a, 0 
9e4b 84					add h 
9e4c 85					add l 
9e4d			 
9e4d e1					pop hl 
9e4e			 
9e4e fe 00				cp 0 
9e50 28 03				jr z, .dup2orig 
9e52			 
9e52			 
9e52 cd aa 98				call forth_push_numhl 
9e55			 
9e55			 
9e55				; TODO add floating point number detection 
9e55			 
9e55			.dup2orig: 
9e55			 
9e55					NEXTW 
9e55 c3 13 9c			jp macro_next 
9e58				endm 
# End of macro NEXTW
9e58			.SWAP: 
9e58				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
9e58 18				db WORD_SYS_CORE+OPCODE_SWAP             
9e59 97 9e			dw .COLN            
9e5b 05				db 4 + 1 
9e5c .. 00			db "SWAP",0              
9e61				endm 
# End of macro CWHEAD
9e61			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
9e61					if DEBUG_FORTH_WORDS_KEY 
9e61						DMARK "SWP" 
9e61 f5				push af  
9e62 3a 76 9e			ld a, (.dmark)  
9e65 32 7a ee			ld (debug_mark),a  
9e68 3a 77 9e			ld a, (.dmark+1)  
9e6b 32 7b ee			ld (debug_mark+1),a  
9e6e 3a 78 9e			ld a, (.dmark+2)  
9e71 32 7c ee			ld (debug_mark+2),a  
9e74 18 03			jr .pastdmark  
9e76 ..			.dmark: db "SWP"  
9e79 f1			.pastdmark: pop af  
9e7a			endm  
# End of macro DMARK
9e7a						CALLMONITOR 
9e7a cd 1d 93			call break_point_state  
9e7d				endm  
# End of macro CALLMONITOR
9e7d					endif 
9e7d			 
9e7d					FORTH_DSP_VALUEHL 
9e7d cd a1 9a			call macro_dsp_valuehl 
9e80				endm 
# End of macro FORTH_DSP_VALUEHL
9e80 e5					push hl     ; w2 
9e81			 
9e81					FORTH_DSP_POP 
9e81 cd 59 9b			call macro_forth_dsp_pop 
9e84				endm 
# End of macro FORTH_DSP_POP
9e84			 
9e84					FORTH_DSP_VALUEHL 
9e84 cd a1 9a			call macro_dsp_valuehl 
9e87				endm 
# End of macro FORTH_DSP_VALUEHL
9e87			 
9e87					FORTH_DSP_POP 
9e87 cd 59 9b			call macro_forth_dsp_pop 
9e8a				endm 
# End of macro FORTH_DSP_POP
9e8a			 
9e8a d1					pop de     ; w2	, hl = w1 
9e8b			 
9e8b eb					ex de, hl 
9e8c d5					push de 
9e8d			 
9e8d cd aa 98				call forth_push_numhl 
9e90			 
9e90 e1					pop hl 
9e91			 
9e91 cd aa 98				call forth_push_numhl 
9e94					 
9e94			 
9e94					NEXTW 
9e94 c3 13 9c			jp macro_next 
9e97				endm 
# End of macro NEXTW
9e97			.COLN: 
9e97				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
9e97 19				db WORD_SYS_CORE+OPCODE_COLN             
9e98 23 a0			dw .SCOLN            
9e9a 02				db 1 + 1 
9e9b .. 00			db ":",0              
9e9d				endm 
# End of macro CWHEAD
9e9d			; | : ( -- )         Create new word | DONE 
9e9d			 
9e9d					if DEBUG_FORTH_WORDS_KEY 
9e9d						DMARK "CLN" 
9e9d f5				push af  
9e9e 3a b2 9e			ld a, (.dmark)  
9ea1 32 7a ee			ld (debug_mark),a  
9ea4 3a b3 9e			ld a, (.dmark+1)  
9ea7 32 7b ee			ld (debug_mark+1),a  
9eaa 3a b4 9e			ld a, (.dmark+2)  
9ead 32 7c ee			ld (debug_mark+2),a  
9eb0 18 03			jr .pastdmark  
9eb2 ..			.dmark: db "CLN"  
9eb5 f1			.pastdmark: pop af  
9eb6			endm  
# End of macro DMARK
9eb6						CALLMONITOR 
9eb6 cd 1d 93			call break_point_state  
9eb9				endm  
# End of macro CALLMONITOR
9eb9					endif 
9eb9				STACKFRAME OFF $8efe $989f 
9eb9				if DEBUG_STACK_IMB 
9eb9					if OFF 
9eb9						exx 
9eb9						ld de, $8efe 
9eb9						ld a, d 
9eb9						ld hl, curframe 
9eb9						call hexout 
9eb9						ld a, e 
9eb9						ld hl, curframe+2 
9eb9						call hexout 
9eb9						ld hl, $8efe 
9eb9						push hl 
9eb9						ld hl, $989f 
9eb9						push hl 
9eb9						exx 
9eb9					endif 
9eb9				endif 
9eb9			endm 
# End of macro STACKFRAME
9eb9				; get parser buffer length  of new word 
9eb9			 
9eb9				 
9eb9			 
9eb9					; move tok past this to start of name defintition 
9eb9					; TODO get word to define 
9eb9					; TODO Move past word token 
9eb9					; TODO get length of string up to the ';' 
9eb9			 
9eb9 2a 61 e6			ld hl, (os_tok_ptr) 
9ebc 23				inc hl 
9ebd 23				inc hl 
9ebe			 
9ebe 3e 3b			ld a, ';' 
9ec0 cd 13 8f			call strlent 
9ec3			 
9ec3 7d				ld a,l 
9ec4 32 5c e3			ld (os_new_parse_len), a 
9ec7			 
9ec7			 
9ec7			if DEBUG_FORTH_UWORD 
9ec7 ed 5b 61 e6		ld de, (os_tok_ptr) 
9ecb						DMARK ":01" 
9ecb f5				push af  
9ecc 3a e0 9e			ld a, (.dmark)  
9ecf 32 7a ee			ld (debug_mark),a  
9ed2 3a e1 9e			ld a, (.dmark+1)  
9ed5 32 7b ee			ld (debug_mark+1),a  
9ed8 3a e2 9e			ld a, (.dmark+2)  
9edb 32 7c ee			ld (debug_mark+2),a  
9ede 18 03			jr .pastdmark  
9ee0 ..			.dmark: db ":01"  
9ee3 f1			.pastdmark: pop af  
9ee4			endm  
# End of macro DMARK
9ee4				CALLMONITOR 
9ee4 cd 1d 93			call break_point_state  
9ee7				endm  
# End of macro CALLMONITOR
9ee7			endif 
9ee7			 
9ee7			; 
9ee7			;  new word memory layout: 
9ee7			;  
9ee7			;    : adg 6666 ;  
9ee7			; 
9ee7			;    db   1     ; user defined word  
9ee7 23				inc hl    
9ee8			;    dw   sysdict 
9ee8 23				inc hl 
9ee9 23				inc hl 
9eea			;    db <word len>+1 (for null) 
9eea 23				inc hl 
9eeb			;    db .... <word> 
9eeb			; 
9eeb			 
9eeb 23				inc hl    ; some extras for the word preamble before the above 
9eec 23				inc hl 
9eed 23				inc hl 
9eee 23				inc hl 
9eef 23				inc hl 
9ef0 23				inc hl 
9ef1 23				inc hl  
9ef2 23				inc hl 
9ef3 23				inc hl 
9ef4 23				inc hl 
9ef5 23				inc hl 
9ef6 23				inc hl 
9ef7 23				inc hl 
9ef8 23				inc hl     ; TODO how many do we really need?     maybe only 6 
9ef9			;       exec word buffer 
9ef9			;	<ptr word>   
9ef9 23				inc hl 
9efa 23				inc hl 
9efb			;       <word list><null term> 7F final term 
9efb			 
9efb			 
9efb			if DEBUG_FORTH_UWORD 
9efb						DMARK ":02" 
9efb f5				push af  
9efc 3a 10 9f			ld a, (.dmark)  
9eff 32 7a ee			ld (debug_mark),a  
9f02 3a 11 9f			ld a, (.dmark+1)  
9f05 32 7b ee			ld (debug_mark+1),a  
9f08 3a 12 9f			ld a, (.dmark+2)  
9f0b 32 7c ee			ld (debug_mark+2),a  
9f0e 18 03			jr .pastdmark  
9f10 ..			.dmark: db ":02"  
9f13 f1			.pastdmark: pop af  
9f14			endm  
# End of macro DMARK
9f14				CALLMONITOR 
9f14 cd 1d 93			call break_point_state  
9f17				endm  
# End of macro CALLMONITOR
9f17			endif 
9f17			 
9f17				 
9f17					; malloc the size 
9f17			 
9f17 cd 71 8f				call malloc 
9f1a 22 5e e3				ld (os_new_malloc), hl     ; save malloc start 
9f1d			 
9f1d			;    db   1     ; user defined word  
9f1d 3e 01				ld a, WORD_SYS_UWORD  
9f1f 77					ld (hl), a 
9f20				 
9f20 23				inc hl    
9f21			;    dw   sysdict 
9f21 11 6b 9d			ld de, sysdict       ; continue on with the scan to the system dict 
9f24 73				ld (hl), e 
9f25 23				inc hl 
9f26 72				ld (hl), d 
9f27 23				inc hl 
9f28			 
9f28			 
9f28			;    Setup dict word 
9f28			 
9f28 23				inc hl 
9f29 22 58 e3			ld (os_new_work_ptr), hl     ; save start of dict word  
9f2c			 
9f2c				; 1. get length of dict word 
9f2c			 
9f2c			 
9f2c 2a 61 e6			ld hl, (os_tok_ptr) 
9f2f 23				inc hl 
9f30 23				inc hl    ; position to start of dict word 
9f31 3e 00			ld a, 0 
9f33 cd 13 8f			call strlent 
9f36			 
9f36			 
9f36 23				inc hl    ; to include null??? 
9f37			 
9f37				; write length of dict word 
9f37			 
9f37 ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9f3b 1b				dec de 
9f3c eb				ex de, hl 
9f3d 73				ld (hl), e 
9f3e eb				ex de, hl 
9f3f			 
9f3f				 
9f3f			 
9f3f				; copy  
9f3f 4d				ld c, l 
9f40 06 00			ld b, 0 
9f42 ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9f46 2a 61 e6			ld hl, (os_tok_ptr) 
9f49 23				inc hl 
9f4a 23				inc hl    ; position to start of dict word 
9f4b				 
9f4b			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
9f4b				 
9f4b				; TODO need to convert word to upper case 
9f4b			 
9f4b			ucasetok:	 
9f4b 7e				ld a,(hl) 
9f4c cd ff 8e			call toUpper 
9f4f 77				ld (hl),a 
9f50 ed a0			ldi 
9f52 f2 4b 9f		 	jp p, ucasetok 
9f55			 
9f55			 
9f55			 
9f55				; de now points to start of where the word body code should be placed 
9f55 ed 53 58 e3		ld (os_new_work_ptr), de 
9f59				; hl now points to the words to throw at forthexec which needs to be copied 
9f59 22 56 e3			ld (os_new_src_ptr), hl 
9f5c			 
9f5c				; TODO add 'call to forthexec' 
9f5c			 
9f5c			if DEBUG_FORTH_UWORD 
9f5c c5				push bc 
9f5d ed 4b 5e e3		ld bc, (os_new_malloc) 
9f61						DMARK ":0x" 
9f61 f5				push af  
9f62 3a 76 9f			ld a, (.dmark)  
9f65 32 7a ee			ld (debug_mark),a  
9f68 3a 77 9f			ld a, (.dmark+1)  
9f6b 32 7b ee			ld (debug_mark+1),a  
9f6e 3a 78 9f			ld a, (.dmark+2)  
9f71 32 7c ee			ld (debug_mark+2),a  
9f74 18 03			jr .pastdmark  
9f76 ..			.dmark: db ":0x"  
9f79 f1			.pastdmark: pop af  
9f7a			endm  
# End of macro DMARK
9f7a				CALLMONITOR 
9f7a cd 1d 93			call break_point_state  
9f7d				endm  
# End of macro CALLMONITOR
9f7d c1				pop bc 
9f7e			endif 
9f7e			 
9f7e			 
9f7e				; create word preamble which should be: 
9f7e			 
9f7e			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
9f7e			 
9f7e				;    ld hl, <word code> 
9f7e				;    jp user_exec 
9f7e			        ;    <word code bytes> 
9f7e			 
9f7e			 
9f7e			;	inc de     ; TODO ??? or are we already past the word's null 
9f7e eb				ex de, hl 
9f7f			 
9f7f 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
9f81			 
9f81 23				inc hl 
9f82 22 52 e3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
9f85 23				inc hl 
9f86			 
9f86 23				inc hl 
9f87 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
9f89			 
9f89 01 2b c3			ld bc, user_exec 
9f8c 23				inc hl 
9f8d 71				ld (hl), c     ; poke address of user_exec 
9f8e 23				inc hl 
9f8f 70				ld (hl), b     
9f90			 ; 
9f90			;	inc hl 
9f90			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9f90			; 
9f90			; 
9f90			;	ld bc, macro_forth_rsp_next 
9f90			;	inc hl 
9f90			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
9f90			;	inc hl 
9f90			;	ld (hl), b     
9f90			 ; 
9f90			;	inc hl 
9f90			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9f90			; 
9f90			; 
9f90			;	inc hl 
9f90			;	ld bc, forthexec 
9f90			;	ld (hl), c     ; poke address of forthexec 
9f90			;	inc hl 
9f90			;	ld (hl), b      
9f90			; 
9f90			;	inc hl 
9f90			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
9f90			; 
9f90			;	ld bc, user_dict_next 
9f90			;	inc hl 
9f90			;	ld (hl), c     ; poke address of forthexec 
9f90			;	inc hl 
9f90			;	ld (hl), b      
9f90			 
9f90				; hl is now where we need to copy the word byte data to save this 
9f90			 
9f90 23				inc hl 
9f91 22 54 e3			ld (os_new_exec), hl 
9f94				 
9f94				; copy definition 
9f94			 
9f94 eb				ex de, hl 
9f95			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
9f95			;	inc de    ; skip the PC for this parse 
9f95 3a 5c e3			ld a, (os_new_parse_len) 
9f98 4f				ld c, a 
9f99 06 00			ld b, 0 
9f9b ed b0			ldir		 ; copy defintion 
9f9d			 
9f9d			 
9f9d				; poke the address of where the new word bytes live for forthexec 
9f9d			 
9f9d 2a 52 e3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
9fa0			 
9fa0 ed 5b 54 e3		ld de, (os_new_exec)      
9fa4				 
9fa4 73				ld (hl), e 
9fa5 23				inc hl 
9fa6 72				ld (hl), d 
9fa7			 
9fa7					; TODO copy last user dict word next link to this word 
9fa7					; TODO update last user dict word to point to this word 
9fa7			; 
9fa7			; hl f923 de 812a ; bc 811a 
9fa7			 
9fa7			if DEBUG_FORTH_UWORD 
9fa7 c5				push bc 
9fa8 ed 4b 5e e3		ld bc, (os_new_malloc) 
9fac						DMARK ":0A" 
9fac f5				push af  
9fad 3a c1 9f			ld a, (.dmark)  
9fb0 32 7a ee			ld (debug_mark),a  
9fb3 3a c2 9f			ld a, (.dmark+1)  
9fb6 32 7b ee			ld (debug_mark+1),a  
9fb9 3a c3 9f			ld a, (.dmark+2)  
9fbc 32 7c ee			ld (debug_mark+2),a  
9fbf 18 03			jr .pastdmark  
9fc1 ..			.dmark: db ":0A"  
9fc4 f1			.pastdmark: pop af  
9fc5			endm  
# End of macro DMARK
9fc5				CALLMONITOR 
9fc5 cd 1d 93			call break_point_state  
9fc8				endm  
# End of macro CALLMONITOR
9fc8 c1				pop bc 
9fc9			endif 
9fc9			if DEBUG_FORTH_UWORD 
9fc9 c5				push bc 
9fca ed 4b 5e e3		ld bc, (os_new_malloc) 
9fce 03				inc bc 
9fcf 03				inc bc 
9fd0 03				inc bc 
9fd1 03				inc bc 
9fd2 03				inc bc 
9fd3 03				inc bc 
9fd4 03				inc bc 
9fd5 03				inc bc 
9fd6			 
9fd6						DMARK ":0B" 
9fd6 f5				push af  
9fd7 3a eb 9f			ld a, (.dmark)  
9fda 32 7a ee			ld (debug_mark),a  
9fdd 3a ec 9f			ld a, (.dmark+1)  
9fe0 32 7b ee			ld (debug_mark+1),a  
9fe3 3a ed 9f			ld a, (.dmark+2)  
9fe6 32 7c ee			ld (debug_mark+2),a  
9fe9 18 03			jr .pastdmark  
9feb ..			.dmark: db ":0B"  
9fee f1			.pastdmark: pop af  
9fef			endm  
# End of macro DMARK
9fef				CALLMONITOR 
9fef cd 1d 93			call break_point_state  
9ff2				endm  
# End of macro CALLMONITOR
9ff2 c1				pop bc 
9ff3			endif 
9ff3			 
9ff3			; update word dict linked list for new word 
9ff3			 
9ff3			 
9ff3 2a 5d e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
9ff6 23			inc hl     ; move to next work linked list ptr 
9ff7			 
9ff7 ed 5b 5e e3	ld de, (os_new_malloc)		 ; new next word 
9ffb 73			ld (hl), e 
9ffc 23			inc hl 
9ffd 72			ld (hl), d 
9ffe			 
9ffe			if DEBUG_FORTH_UWORD 
9ffe ed 4b 5d e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a002			endif 
a002			 
a002 ed 53 5d e6	ld (os_last_new_uword), de      ; update last new uword ptr 
a006			 
a006			 
a006			if DEBUG_FORTH_UWORD 
a006						DMARK ":0+" 
a006 f5				push af  
a007 3a 1b a0			ld a, (.dmark)  
a00a 32 7a ee			ld (debug_mark),a  
a00d 3a 1c a0			ld a, (.dmark+1)  
a010 32 7b ee			ld (debug_mark+1),a  
a013 3a 1d a0			ld a, (.dmark+2)  
a016 32 7c ee			ld (debug_mark+2),a  
a019 18 03			jr .pastdmark  
a01b ..			.dmark: db ":0+"  
a01e f1			.pastdmark: pop af  
a01f			endm  
# End of macro DMARK
a01f				CALLMONITOR 
a01f cd 1d 93			call break_point_state  
a022				endm  
# End of macro CALLMONITOR
a022			endif 
a022			 
a022				STACKFRAMECHK OFF $8efe $989f 
a022				if DEBUG_STACK_IMB 
a022					if OFF 
a022						exx 
a022						ld hl, $989f 
a022						pop de   ; $989f 
a022						call cmp16 
a022						jr nz, .spnosame 
a022						ld hl, $8efe 
a022						pop de   ; $8efe 
a022						call cmp16 
a022						jr z, .spfrsame 
a022						.spnosame: call showsperror 
a022						.spfrsame: nop 
a022						exx 
a022					endif 
a022				endif 
a022			endm 
# End of macro STACKFRAMECHK
a022			 
a022 c9			ret    ; dont process any remaining parser tokens as they form new word 
a023			 
a023			 
a023			 
a023			 
a023			;		NEXT 
a023			.SCOLN: 
a023			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a023 06				db OPCODE_SCOLN 
a024 6f a0			dw .DROP 
a026 02				db 2 
a027 .. 00			db ";",0           
a029			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a029					if DEBUG_FORTH_WORDS_KEY 
a029						DMARK "SCN" 
a029 f5				push af  
a02a 3a 3e a0			ld a, (.dmark)  
a02d 32 7a ee			ld (debug_mark),a  
a030 3a 3f a0			ld a, (.dmark+1)  
a033 32 7b ee			ld (debug_mark+1),a  
a036 3a 40 a0			ld a, (.dmark+2)  
a039 32 7c ee			ld (debug_mark+2),a  
a03c 18 03			jr .pastdmark  
a03e ..			.dmark: db "SCN"  
a041 f1			.pastdmark: pop af  
a042			endm  
# End of macro DMARK
a042						CALLMONITOR 
a042 cd 1d 93			call break_point_state  
a045				endm  
# End of macro CALLMONITOR
a045					endif 
a045					FORTH_RSP_TOS 
a045 cd 68 98			call macro_forth_rsp_tos 
a048				endm 
# End of macro FORTH_RSP_TOS
a048 e5					push hl 
a049					FORTH_RSP_POP 
a049 cd 72 98			call macro_forth_rsp_pop 
a04c				endm 
# End of macro FORTH_RSP_POP
a04c e1					pop hl 
a04d			;		ex de,hl 
a04d 22 61 e6				ld (os_tok_ptr),hl 
a050			 
a050			if DEBUG_FORTH_UWORD 
a050						DMARK "SCL" 
a050 f5				push af  
a051 3a 65 a0			ld a, (.dmark)  
a054 32 7a ee			ld (debug_mark),a  
a057 3a 66 a0			ld a, (.dmark+1)  
a05a 32 7b ee			ld (debug_mark+1),a  
a05d 3a 67 a0			ld a, (.dmark+2)  
a060 32 7c ee			ld (debug_mark+2),a  
a063 18 03			jr .pastdmark  
a065 ..			.dmark: db "SCL"  
a068 f1			.pastdmark: pop af  
a069			endm  
# End of macro DMARK
a069				CALLMONITOR 
a069 cd 1d 93			call break_point_state  
a06c				endm  
# End of macro CALLMONITOR
a06c			endif 
a06c					NEXTW 
a06c c3 13 9c			jp macro_next 
a06f				endm 
# End of macro NEXTW
a06f			 
a06f			.DROP: 
a06f				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a06f 1b				db WORD_SYS_CORE+OPCODE_DROP             
a070 9a a0			dw .DUP2            
a072 05				db 4 + 1 
a073 .. 00			db "DROP",0              
a078				endm 
# End of macro CWHEAD
a078			; | DROP ( w -- )   drop the TOS item   | DONE 
a078					if DEBUG_FORTH_WORDS_KEY 
a078						DMARK "DRP" 
a078 f5				push af  
a079 3a 8d a0			ld a, (.dmark)  
a07c 32 7a ee			ld (debug_mark),a  
a07f 3a 8e a0			ld a, (.dmark+1)  
a082 32 7b ee			ld (debug_mark+1),a  
a085 3a 8f a0			ld a, (.dmark+2)  
a088 32 7c ee			ld (debug_mark+2),a  
a08b 18 03			jr .pastdmark  
a08d ..			.dmark: db "DRP"  
a090 f1			.pastdmark: pop af  
a091			endm  
# End of macro DMARK
a091						CALLMONITOR 
a091 cd 1d 93			call break_point_state  
a094				endm  
# End of macro CALLMONITOR
a094					endif 
a094					FORTH_DSP_POP 
a094 cd 59 9b			call macro_forth_dsp_pop 
a097				endm 
# End of macro FORTH_DSP_POP
a097					NEXTW 
a097 c3 13 9c			jp macro_next 
a09a				endm 
# End of macro NEXTW
a09a			.DUP2: 
a09a				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a09a 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a09b df a0			dw .DROP2            
a09d 05				db 4 + 1 
a09e .. 00			db "2DUP",0              
a0a3				endm 
# End of macro CWHEAD
a0a3			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a0a3					if DEBUG_FORTH_WORDS_KEY 
a0a3						DMARK "2DU" 
a0a3 f5				push af  
a0a4 3a b8 a0			ld a, (.dmark)  
a0a7 32 7a ee			ld (debug_mark),a  
a0aa 3a b9 a0			ld a, (.dmark+1)  
a0ad 32 7b ee			ld (debug_mark+1),a  
a0b0 3a ba a0			ld a, (.dmark+2)  
a0b3 32 7c ee			ld (debug_mark+2),a  
a0b6 18 03			jr .pastdmark  
a0b8 ..			.dmark: db "2DU"  
a0bb f1			.pastdmark: pop af  
a0bc			endm  
# End of macro DMARK
a0bc						CALLMONITOR 
a0bc cd 1d 93			call break_point_state  
a0bf				endm  
# End of macro CALLMONITOR
a0bf					endif 
a0bf					FORTH_DSP_VALUEHL 
a0bf cd a1 9a			call macro_dsp_valuehl 
a0c2				endm 
# End of macro FORTH_DSP_VALUEHL
a0c2 e5					push hl      ; 2 
a0c3			 
a0c3					FORTH_DSP_POP 
a0c3 cd 59 9b			call macro_forth_dsp_pop 
a0c6				endm 
# End of macro FORTH_DSP_POP
a0c6					 
a0c6					FORTH_DSP_VALUEHL 
a0c6 cd a1 9a			call macro_dsp_valuehl 
a0c9				endm 
# End of macro FORTH_DSP_VALUEHL
a0c9			;		push hl      ; 1 
a0c9			 
a0c9					FORTH_DSP_POP 
a0c9 cd 59 9b			call macro_forth_dsp_pop 
a0cc				endm 
# End of macro FORTH_DSP_POP
a0cc			 
a0cc			;		pop hl       ; 1 
a0cc d1					pop de       ; 2 
a0cd			 
a0cd cd aa 98				call forth_push_numhl 
a0d0 eb					ex de, hl 
a0d1 cd aa 98				call forth_push_numhl 
a0d4			 
a0d4					 
a0d4 eb					ex de, hl 
a0d5			 
a0d5 cd aa 98				call forth_push_numhl 
a0d8 eb					ex de, hl 
a0d9 cd aa 98				call forth_push_numhl 
a0dc			 
a0dc			 
a0dc					NEXTW 
a0dc c3 13 9c			jp macro_next 
a0df				endm 
# End of macro NEXTW
a0df			.DROP2: 
a0df				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a0df 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a0e0 0e a1			dw .SWAP2            
a0e2 06				db 5 + 1 
a0e3 .. 00			db "2DROP",0              
a0e9				endm 
# End of macro CWHEAD
a0e9			; | 2DROP ( w w -- )    Double drop | DONE 
a0e9					if DEBUG_FORTH_WORDS_KEY 
a0e9						DMARK "2DR" 
a0e9 f5				push af  
a0ea 3a fe a0			ld a, (.dmark)  
a0ed 32 7a ee			ld (debug_mark),a  
a0f0 3a ff a0			ld a, (.dmark+1)  
a0f3 32 7b ee			ld (debug_mark+1),a  
a0f6 3a 00 a1			ld a, (.dmark+2)  
a0f9 32 7c ee			ld (debug_mark+2),a  
a0fc 18 03			jr .pastdmark  
a0fe ..			.dmark: db "2DR"  
a101 f1			.pastdmark: pop af  
a102			endm  
# End of macro DMARK
a102						CALLMONITOR 
a102 cd 1d 93			call break_point_state  
a105				endm  
# End of macro CALLMONITOR
a105					endif 
a105					FORTH_DSP_POP 
a105 cd 59 9b			call macro_forth_dsp_pop 
a108				endm 
# End of macro FORTH_DSP_POP
a108					FORTH_DSP_POP 
a108 cd 59 9b			call macro_forth_dsp_pop 
a10b				endm 
# End of macro FORTH_DSP_POP
a10b					NEXTW 
a10b c3 13 9c			jp macro_next 
a10e				endm 
# End of macro NEXTW
a10e			.SWAP2: 
a10e				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a10e 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a10f 37 a1			dw .AT            
a111 06				db 5 + 1 
a112 .. 00			db "2SWAP",0              
a118				endm 
# End of macro CWHEAD
a118			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a118					if DEBUG_FORTH_WORDS_KEY 
a118						DMARK "2SW" 
a118 f5				push af  
a119 3a 2d a1			ld a, (.dmark)  
a11c 32 7a ee			ld (debug_mark),a  
a11f 3a 2e a1			ld a, (.dmark+1)  
a122 32 7b ee			ld (debug_mark+1),a  
a125 3a 2f a1			ld a, (.dmark+2)  
a128 32 7c ee			ld (debug_mark+2),a  
a12b 18 03			jr .pastdmark  
a12d ..			.dmark: db "2SW"  
a130 f1			.pastdmark: pop af  
a131			endm  
# End of macro DMARK
a131						CALLMONITOR 
a131 cd 1d 93			call break_point_state  
a134				endm  
# End of macro CALLMONITOR
a134					endif 
a134					NEXTW 
a134 c3 13 9c			jp macro_next 
a137				endm 
# End of macro NEXTW
a137			.AT: 
a137				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a137 1f				db WORD_SYS_CORE+OPCODE_AT             
a138 69 a1			dw .CAT            
a13a 02				db 1 + 1 
a13b .. 00			db "@",0              
a13d				endm 
# End of macro CWHEAD
a13d			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a13d			 
a13d					if DEBUG_FORTH_WORDS_KEY 
a13d						DMARK "AT." 
a13d f5				push af  
a13e 3a 52 a1			ld a, (.dmark)  
a141 32 7a ee			ld (debug_mark),a  
a144 3a 53 a1			ld a, (.dmark+1)  
a147 32 7b ee			ld (debug_mark+1),a  
a14a 3a 54 a1			ld a, (.dmark+2)  
a14d 32 7c ee			ld (debug_mark+2),a  
a150 18 03			jr .pastdmark  
a152 ..			.dmark: db "AT."  
a155 f1			.pastdmark: pop af  
a156			endm  
# End of macro DMARK
a156						CALLMONITOR 
a156 cd 1d 93			call break_point_state  
a159				endm  
# End of macro CALLMONITOR
a159					endif 
a159			.getbyteat:	 
a159					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a159 cd a1 9a			call macro_dsp_valuehl 
a15c				endm 
# End of macro FORTH_DSP_VALUEHL
a15c					 
a15c			;		push hl 
a15c				 
a15c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a15c cd 59 9b			call macro_forth_dsp_pop 
a15f				endm 
# End of macro FORTH_DSP_POP
a15f			 
a15f			;		pop hl 
a15f			 
a15f 7e					ld a, (hl) 
a160			 
a160 6f					ld l, a 
a161 26 00				ld h, 0 
a163 cd aa 98				call forth_push_numhl 
a166			 
a166					NEXTW 
a166 c3 13 9c			jp macro_next 
a169				endm 
# End of macro NEXTW
a169			.CAT: 
a169				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a169 20				db WORD_SYS_CORE+OPCODE_CAT             
a16a 92 a1			dw .BANG            
a16c 03				db 2 + 1 
a16d .. 00			db "C@",0              
a170				endm 
# End of macro CWHEAD
a170			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a170					if DEBUG_FORTH_WORDS_KEY 
a170						DMARK "CAA" 
a170 f5				push af  
a171 3a 85 a1			ld a, (.dmark)  
a174 32 7a ee			ld (debug_mark),a  
a177 3a 86 a1			ld a, (.dmark+1)  
a17a 32 7b ee			ld (debug_mark+1),a  
a17d 3a 87 a1			ld a, (.dmark+2)  
a180 32 7c ee			ld (debug_mark+2),a  
a183 18 03			jr .pastdmark  
a185 ..			.dmark: db "CAA"  
a188 f1			.pastdmark: pop af  
a189			endm  
# End of macro DMARK
a189						CALLMONITOR 
a189 cd 1d 93			call break_point_state  
a18c				endm  
# End of macro CALLMONITOR
a18c					endif 
a18c c3 59 a1				jp .getbyteat 
a18f					NEXTW 
a18f c3 13 9c			jp macro_next 
a192				endm 
# End of macro NEXTW
a192			.BANG: 
a192				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a192 21				db WORD_SYS_CORE+OPCODE_BANG             
a193 c8 a1			dw .CBANG            
a195 02				db 1 + 1 
a196 .. 00			db "!",0              
a198				endm 
# End of macro CWHEAD
a198			; | ! ( x w -- ) Store x at address w      | DONE 
a198					if DEBUG_FORTH_WORDS_KEY 
a198						DMARK "BNG" 
a198 f5				push af  
a199 3a ad a1			ld a, (.dmark)  
a19c 32 7a ee			ld (debug_mark),a  
a19f 3a ae a1			ld a, (.dmark+1)  
a1a2 32 7b ee			ld (debug_mark+1),a  
a1a5 3a af a1			ld a, (.dmark+2)  
a1a8 32 7c ee			ld (debug_mark+2),a  
a1ab 18 03			jr .pastdmark  
a1ad ..			.dmark: db "BNG"  
a1b0 f1			.pastdmark: pop af  
a1b1			endm  
# End of macro DMARK
a1b1						CALLMONITOR 
a1b1 cd 1d 93			call break_point_state  
a1b4				endm  
# End of macro CALLMONITOR
a1b4					endif 
a1b4			 
a1b4			.storebyteat:		 
a1b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a1b4 cd a1 9a			call macro_dsp_valuehl 
a1b7				endm 
# End of macro FORTH_DSP_VALUEHL
a1b7					 
a1b7 e5					push hl 
a1b8				 
a1b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a1b8 cd 59 9b			call macro_forth_dsp_pop 
a1bb				endm 
# End of macro FORTH_DSP_POP
a1bb			 
a1bb					; get byte to poke 
a1bb			 
a1bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a1bb cd a1 9a			call macro_dsp_valuehl 
a1be				endm 
# End of macro FORTH_DSP_VALUEHL
a1be e5					push hl 
a1bf			 
a1bf			 
a1bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a1bf cd 59 9b			call macro_forth_dsp_pop 
a1c2				endm 
# End of macro FORTH_DSP_POP
a1c2			 
a1c2			 
a1c2 d1					pop de 
a1c3 e1					pop hl 
a1c4			 
a1c4 73					ld (hl),e 
a1c5			 
a1c5			 
a1c5					NEXTW 
a1c5 c3 13 9c			jp macro_next 
a1c8				endm 
# End of macro NEXTW
a1c8			.CBANG: 
a1c8				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a1c8 22				db WORD_SYS_CORE+OPCODE_CBANG             
a1c9 f1 a1			dw .SCALL            
a1cb 03				db 2 + 1 
a1cc .. 00			db "C!",0              
a1cf				endm 
# End of macro CWHEAD
a1cf			; | C!  ( x w -- ) Store x at address w  | DONE 
a1cf					if DEBUG_FORTH_WORDS_KEY 
a1cf						DMARK "CBA" 
a1cf f5				push af  
a1d0 3a e4 a1			ld a, (.dmark)  
a1d3 32 7a ee			ld (debug_mark),a  
a1d6 3a e5 a1			ld a, (.dmark+1)  
a1d9 32 7b ee			ld (debug_mark+1),a  
a1dc 3a e6 a1			ld a, (.dmark+2)  
a1df 32 7c ee			ld (debug_mark+2),a  
a1e2 18 03			jr .pastdmark  
a1e4 ..			.dmark: db "CBA"  
a1e7 f1			.pastdmark: pop af  
a1e8			endm  
# End of macro DMARK
a1e8						CALLMONITOR 
a1e8 cd 1d 93			call break_point_state  
a1eb				endm  
# End of macro CALLMONITOR
a1eb					endif 
a1eb c3 b4 a1				jp .storebyteat 
a1ee					NEXTW 
a1ee c3 13 9c			jp macro_next 
a1f1				endm 
# End of macro NEXTW
a1f1			.SCALL: 
a1f1				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a1f1 23				db WORD_SYS_CORE+OPCODE_SCALL             
a1f2 25 a2			dw .DEPTH            
a1f4 05				db 4 + 1 
a1f5 .. 00			db "CALL",0              
a1fa				endm 
# End of macro CWHEAD
a1fa			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a1fa					if DEBUG_FORTH_WORDS_KEY 
a1fa						DMARK "CLL" 
a1fa f5				push af  
a1fb 3a 0f a2			ld a, (.dmark)  
a1fe 32 7a ee			ld (debug_mark),a  
a201 3a 10 a2			ld a, (.dmark+1)  
a204 32 7b ee			ld (debug_mark+1),a  
a207 3a 11 a2			ld a, (.dmark+2)  
a20a 32 7c ee			ld (debug_mark+2),a  
a20d 18 03			jr .pastdmark  
a20f ..			.dmark: db "CLL"  
a212 f1			.pastdmark: pop af  
a213			endm  
# End of macro DMARK
a213						CALLMONITOR 
a213 cd 1d 93			call break_point_state  
a216				endm  
# End of macro CALLMONITOR
a216					endif 
a216			 
a216					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a216 cd a1 9a			call macro_dsp_valuehl 
a219				endm 
# End of macro FORTH_DSP_VALUEHL
a219			 
a219			;		push hl 
a219			 
a219					; destroy value TOS 
a219			 
a219					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a219 cd 59 9b			call macro_forth_dsp_pop 
a21c				endm 
# End of macro FORTH_DSP_POP
a21c			 
a21c						 
a21c			;		pop hl 
a21c			 
a21c					; how to do a call with hl???? save SP? 
a21c cd bc 9b				call forth_call_hl 
a21f			 
a21f			 
a21f					; TODO push value back onto stack for another op etc 
a21f			 
a21f cd aa 98				call forth_push_numhl 
a222					NEXTW 
a222 c3 13 9c			jp macro_next 
a225				endm 
# End of macro NEXTW
a225			.DEPTH: 
a225				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a225 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a226 62 a2			dw .OVER            
a228 06				db 5 + 1 
a229 .. 00			db "DEPTH",0              
a22f				endm 
# End of macro CWHEAD
a22f			; | DEPTH ( -- u ) Push count of stack | DONE 
a22f					; take current TOS and remove from base value div by two to get count 
a22f					if DEBUG_FORTH_WORDS_KEY 
a22f						DMARK "DEP" 
a22f f5				push af  
a230 3a 44 a2			ld a, (.dmark)  
a233 32 7a ee			ld (debug_mark),a  
a236 3a 45 a2			ld a, (.dmark+1)  
a239 32 7b ee			ld (debug_mark+1),a  
a23c 3a 46 a2			ld a, (.dmark+2)  
a23f 32 7c ee			ld (debug_mark+2),a  
a242 18 03			jr .pastdmark  
a244 ..			.dmark: db "DEP"  
a247 f1			.pastdmark: pop af  
a248			endm  
# End of macro DMARK
a248						CALLMONITOR 
a248 cd 1d 93			call break_point_state  
a24b				endm  
# End of macro CALLMONITOR
a24b					endif 
a24b			 
a24b			 
a24b 2a 0d eb			ld hl, (cli_data_sp) 
a24e 11 c7 e8			ld de, cli_data_stack 
a251 ed 52			sbc hl,de 
a253				 
a253				; div by size of stack item 
a253			 
a253 5d				ld e,l 
a254 0e 03			ld c, 3 
a256 cd 3a 8a			call Div8 
a259			 
a259 6f				ld l,a 
a25a 26 00			ld h,0 
a25c			 
a25c				;srl h 
a25c				;rr l 
a25c			 
a25c cd aa 98				call forth_push_numhl 
a25f					NEXTW 
a25f c3 13 9c			jp macro_next 
a262				endm 
# End of macro NEXTW
a262			.OVER: 
a262				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a262 42				db WORD_SYS_CORE+46             
a263 a9 a2			dw .PAUSE            
a265 05				db 4 + 1 
a266 .. 00			db "OVER",0              
a26b				endm 
# End of macro CWHEAD
a26b			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a26b					if DEBUG_FORTH_WORDS_KEY 
a26b						DMARK "OVR" 
a26b f5				push af  
a26c 3a 80 a2			ld a, (.dmark)  
a26f 32 7a ee			ld (debug_mark),a  
a272 3a 81 a2			ld a, (.dmark+1)  
a275 32 7b ee			ld (debug_mark+1),a  
a278 3a 82 a2			ld a, (.dmark+2)  
a27b 32 7c ee			ld (debug_mark+2),a  
a27e 18 03			jr .pastdmark  
a280 ..			.dmark: db "OVR"  
a283 f1			.pastdmark: pop af  
a284			endm  
# End of macro DMARK
a284						CALLMONITOR 
a284 cd 1d 93			call break_point_state  
a287				endm  
# End of macro CALLMONITOR
a287					endif 
a287			 
a287					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a287 cd a1 9a			call macro_dsp_valuehl 
a28a				endm 
# End of macro FORTH_DSP_VALUEHL
a28a e5					push hl    ; n2 
a28b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a28b cd 59 9b			call macro_forth_dsp_pop 
a28e				endm 
# End of macro FORTH_DSP_POP
a28e			 
a28e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a28e cd a1 9a			call macro_dsp_valuehl 
a291				endm 
# End of macro FORTH_DSP_VALUEHL
a291 e5					push hl    ; n1 
a292					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a292 cd 59 9b			call macro_forth_dsp_pop 
a295				endm 
# End of macro FORTH_DSP_POP
a295			 
a295 d1					pop de     ; n1 
a296 e1					pop hl     ; n2 
a297			 
a297 d5					push de 
a298 e5					push hl 
a299 d5					push de 
a29a			 
a29a					; push back  
a29a			 
a29a e1					pop hl 
a29b cd aa 98				call forth_push_numhl 
a29e e1					pop hl 
a29f cd aa 98				call forth_push_numhl 
a2a2 e1					pop hl 
a2a3 cd aa 98				call forth_push_numhl 
a2a6					NEXTW 
a2a6 c3 13 9c			jp macro_next 
a2a9				endm 
# End of macro NEXTW
a2a9			 
a2a9			.PAUSE: 
a2a9				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a2a9 43				db WORD_SYS_CORE+47             
a2aa de a2			dw .PAUSES            
a2ac 08				db 7 + 1 
a2ad .. 00			db "PAUSEMS",0              
a2b5				endm 
# End of macro CWHEAD
a2b5			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a2b5					if DEBUG_FORTH_WORDS_KEY 
a2b5						DMARK "PMS" 
a2b5 f5				push af  
a2b6 3a ca a2			ld a, (.dmark)  
a2b9 32 7a ee			ld (debug_mark),a  
a2bc 3a cb a2			ld a, (.dmark+1)  
a2bf 32 7b ee			ld (debug_mark+1),a  
a2c2 3a cc a2			ld a, (.dmark+2)  
a2c5 32 7c ee			ld (debug_mark+2),a  
a2c8 18 03			jr .pastdmark  
a2ca ..			.dmark: db "PMS"  
a2cd f1			.pastdmark: pop af  
a2ce			endm  
# End of macro DMARK
a2ce						CALLMONITOR 
a2ce cd 1d 93			call break_point_state  
a2d1				endm  
# End of macro CALLMONITOR
a2d1					endif 
a2d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2d1 cd a1 9a			call macro_dsp_valuehl 
a2d4				endm 
# End of macro FORTH_DSP_VALUEHL
a2d4			;		push hl    ; n2 
a2d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2d4 cd 59 9b			call macro_forth_dsp_pop 
a2d7				endm 
# End of macro FORTH_DSP_POP
a2d7			;		pop hl 
a2d7			 
a2d7 7d					ld a, l 
a2d8 cd e2 87				call aDelayInMS 
a2db				       NEXTW 
a2db c3 13 9c			jp macro_next 
a2de				endm 
# End of macro NEXTW
a2de			.PAUSES:  
a2de				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a2de 44				db WORD_SYS_CORE+48             
a2df 4d a3			dw .ROT            
a2e1 06				db 5 + 1 
a2e2 .. 00			db "PAUSE",0              
a2e8				endm 
# End of macro CWHEAD
a2e8			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a2e8					if DEBUG_FORTH_WORDS_KEY 
a2e8						DMARK "PAU" 
a2e8 f5				push af  
a2e9 3a fd a2			ld a, (.dmark)  
a2ec 32 7a ee			ld (debug_mark),a  
a2ef 3a fe a2			ld a, (.dmark+1)  
a2f2 32 7b ee			ld (debug_mark+1),a  
a2f5 3a ff a2			ld a, (.dmark+2)  
a2f8 32 7c ee			ld (debug_mark+2),a  
a2fb 18 03			jr .pastdmark  
a2fd ..			.dmark: db "PAU"  
a300 f1			.pastdmark: pop af  
a301			endm  
# End of macro DMARK
a301						CALLMONITOR 
a301 cd 1d 93			call break_point_state  
a304				endm  
# End of macro CALLMONITOR
a304					endif 
a304					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a304 cd a1 9a			call macro_dsp_valuehl 
a307				endm 
# End of macro FORTH_DSP_VALUEHL
a307			;		push hl    ; n2 
a307					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a307 cd 59 9b			call macro_forth_dsp_pop 
a30a				endm 
# End of macro FORTH_DSP_POP
a30a			;		pop hl 
a30a 45					ld b, l 
a30b					if DEBUG_FORTH_WORDS 
a30b						DMARK "PAU" 
a30b f5				push af  
a30c 3a 20 a3			ld a, (.dmark)  
a30f 32 7a ee			ld (debug_mark),a  
a312 3a 21 a3			ld a, (.dmark+1)  
a315 32 7b ee			ld (debug_mark+1),a  
a318 3a 22 a3			ld a, (.dmark+2)  
a31b 32 7c ee			ld (debug_mark+2),a  
a31e 18 03			jr .pastdmark  
a320 ..			.dmark: db "PAU"  
a323 f1			.pastdmark: pop af  
a324			endm  
# End of macro DMARK
a324						CALLMONITOR 
a324 cd 1d 93			call break_point_state  
a327				endm  
# End of macro CALLMONITOR
a327					endif 
a327 c5			.pauses1:	push bc 
a328 cd fd 87				call delay1s 
a32b c1					pop bc 
a32c					if DEBUG_FORTH_WORDS 
a32c						DMARK "PA1" 
a32c f5				push af  
a32d 3a 41 a3			ld a, (.dmark)  
a330 32 7a ee			ld (debug_mark),a  
a333 3a 42 a3			ld a, (.dmark+1)  
a336 32 7b ee			ld (debug_mark+1),a  
a339 3a 43 a3			ld a, (.dmark+2)  
a33c 32 7c ee			ld (debug_mark+2),a  
a33f 18 03			jr .pastdmark  
a341 ..			.dmark: db "PA1"  
a344 f1			.pastdmark: pop af  
a345			endm  
# End of macro DMARK
a345						CALLMONITOR 
a345 cd 1d 93			call break_point_state  
a348				endm  
# End of macro CALLMONITOR
a348					endif 
a348 10 dd				djnz .pauses1 
a34a			 
a34a				       NEXTW 
a34a c3 13 9c			jp macro_next 
a34d				endm 
# End of macro NEXTW
a34d			.ROT: 
a34d				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a34d 45				db WORD_SYS_CORE+49             
a34e 9b a3			dw .UWORDS            
a350 04				db 3 + 1 
a351 .. 00			db "ROT",0              
a355				endm 
# End of macro CWHEAD
a355			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a355					if DEBUG_FORTH_WORDS_KEY 
a355						DMARK "ROT" 
a355 f5				push af  
a356 3a 6a a3			ld a, (.dmark)  
a359 32 7a ee			ld (debug_mark),a  
a35c 3a 6b a3			ld a, (.dmark+1)  
a35f 32 7b ee			ld (debug_mark+1),a  
a362 3a 6c a3			ld a, (.dmark+2)  
a365 32 7c ee			ld (debug_mark+2),a  
a368 18 03			jr .pastdmark  
a36a ..			.dmark: db "ROT"  
a36d f1			.pastdmark: pop af  
a36e			endm  
# End of macro DMARK
a36e						CALLMONITOR 
a36e cd 1d 93			call break_point_state  
a371				endm  
# End of macro CALLMONITOR
a371					endif 
a371			 
a371					FORTH_DSP_VALUEHL 
a371 cd a1 9a			call macro_dsp_valuehl 
a374				endm 
# End of macro FORTH_DSP_VALUEHL
a374 e5					push hl    ; u3  
a375			 
a375					FORTH_DSP_POP 
a375 cd 59 9b			call macro_forth_dsp_pop 
a378				endm 
# End of macro FORTH_DSP_POP
a378			   
a378					FORTH_DSP_VALUEHL 
a378 cd a1 9a			call macro_dsp_valuehl 
a37b				endm 
# End of macro FORTH_DSP_VALUEHL
a37b e5					push hl     ; u2 
a37c			 
a37c					FORTH_DSP_POP 
a37c cd 59 9b			call macro_forth_dsp_pop 
a37f				endm 
# End of macro FORTH_DSP_POP
a37f			 
a37f					FORTH_DSP_VALUEHL 
a37f cd a1 9a			call macro_dsp_valuehl 
a382				endm 
# End of macro FORTH_DSP_VALUEHL
a382 e5					push hl     ; u1 
a383			 
a383					FORTH_DSP_POP 
a383 cd 59 9b			call macro_forth_dsp_pop 
a386				endm 
# End of macro FORTH_DSP_POP
a386			 
a386 c1					pop bc      ; u1 
a387 e1					pop hl      ; u2 
a388 d1					pop de      ; u3 
a389			 
a389			 
a389 c5					push bc 
a38a d5					push de 
a38b e5					push hl 
a38c			 
a38c			 
a38c e1					pop hl 
a38d cd aa 98				call forth_push_numhl 
a390			 
a390 e1					pop hl 
a391 cd aa 98				call forth_push_numhl 
a394			 
a394 e1					pop hl 
a395 cd aa 98				call forth_push_numhl 
a398					 
a398			 
a398			 
a398			 
a398			 
a398			 
a398				       NEXTW 
a398 c3 13 9c			jp macro_next 
a39b				endm 
# End of macro NEXTW
a39b			 
a39b			.UWORDS: 
a39b				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a39b 50				db WORD_SYS_CORE+60             
a39c 5d a4			dw .BP            
a39e 07				db 6 + 1 
a39f .. 00			db "UWORDS",0              
a3a6				endm 
# End of macro CWHEAD
a3a6			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a3a6			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a3a6			; | | Following the count are the individual words. 
a3a6			; | | 
a3a6			; | | e.g. UWORDS 
a3a6			; | | BOX DIRLIST 2 
a3a6			; | |  
a3a6			; | | Can be used to save the words to storage via: 
a3a6			; | | UWORDS $01 DO $01 APPEND LOOP 
a3a6				if DEBUG_FORTH_WORDS_KEY 
a3a6					DMARK "UWR" 
a3a6 f5				push af  
a3a7 3a bb a3			ld a, (.dmark)  
a3aa 32 7a ee			ld (debug_mark),a  
a3ad 3a bc a3			ld a, (.dmark+1)  
a3b0 32 7b ee			ld (debug_mark+1),a  
a3b3 3a bd a3			ld a, (.dmark+2)  
a3b6 32 7c ee			ld (debug_mark+2),a  
a3b9 18 03			jr .pastdmark  
a3bb ..			.dmark: db "UWR"  
a3be f1			.pastdmark: pop af  
a3bf			endm  
# End of macro DMARK
a3bf					CALLMONITOR 
a3bf cd 1d 93			call break_point_state  
a3c2				endm  
# End of macro CALLMONITOR
a3c2				endif 
a3c2 21 48 d7				ld hl, baseram 
a3c5					;ld hl, baseusermem 
a3c5 01 00 00				ld bc, 0    ; start a counter 
a3c8			 
a3c8				; skip dict stub 
a3c8			 
a3c8 cd 64 9d				call forth_tok_next 
a3cb			 
a3cb			 
a3cb			; while we have words to look for 
a3cb			 
a3cb 7e			.douscan:	ld a, (hl)      
a3cc				if DEBUG_FORTH_WORDS 
a3cc					DMARK "UWs" 
a3cc f5				push af  
a3cd 3a e1 a3			ld a, (.dmark)  
a3d0 32 7a ee			ld (debug_mark),a  
a3d3 3a e2 a3			ld a, (.dmark+1)  
a3d6 32 7b ee			ld (debug_mark+1),a  
a3d9 3a e3 a3			ld a, (.dmark+2)  
a3dc 32 7c ee			ld (debug_mark+2),a  
a3df 18 03			jr .pastdmark  
a3e1 ..			.dmark: db "UWs"  
a3e4 f1			.pastdmark: pop af  
a3e5			endm  
# End of macro DMARK
a3e5					CALLMONITOR 
a3e5 cd 1d 93			call break_point_state  
a3e8				endm  
# End of macro CALLMONITOR
a3e8				endif 
a3e8 fe 00				cp WORD_SYS_END 
a3ea 28 4d				jr z, .udone 
a3ec fe 01				cp WORD_SYS_UWORD 
a3ee 20 44				jr nz, .nuword 
a3f0			 
a3f0				if DEBUG_FORTH_WORDS 
a3f0					DMARK "UWu" 
a3f0 f5				push af  
a3f1 3a 05 a4			ld a, (.dmark)  
a3f4 32 7a ee			ld (debug_mark),a  
a3f7 3a 06 a4			ld a, (.dmark+1)  
a3fa 32 7b ee			ld (debug_mark+1),a  
a3fd 3a 07 a4			ld a, (.dmark+2)  
a400 32 7c ee			ld (debug_mark+2),a  
a403 18 03			jr .pastdmark  
a405 ..			.dmark: db "UWu"  
a408 f1			.pastdmark: pop af  
a409			endm  
# End of macro DMARK
a409					CALLMONITOR 
a409 cd 1d 93			call break_point_state  
a40c				endm  
# End of macro CALLMONITOR
a40c				endif 
a40c					; we have a uword so push its name to the stack 
a40c			 
a40c e5				   	push hl  ; save so we can move to next dict block 
a40d			 
a40d					; skip opcode 
a40d 23					inc hl  
a40e					; skip next ptr 
a40e 23					inc hl  
a40f 23					inc hl 
a410					; skip len 
a410 23					inc hl 
a411				if DEBUG_FORTH_WORDS 
a411					DMARK "UWt" 
a411 f5				push af  
a412 3a 26 a4			ld a, (.dmark)  
a415 32 7a ee			ld (debug_mark),a  
a418 3a 27 a4			ld a, (.dmark+1)  
a41b 32 7b ee			ld (debug_mark+1),a  
a41e 3a 28 a4			ld a, (.dmark+2)  
a421 32 7c ee			ld (debug_mark+2),a  
a424 18 03			jr .pastdmark  
a426 ..			.dmark: db "UWt"  
a429 f1			.pastdmark: pop af  
a42a			endm  
# End of macro DMARK
a42a					CALLMONITOR 
a42a cd 1d 93			call break_point_state  
a42d				endm  
# End of macro CALLMONITOR
a42d				endif 
a42d 03					inc bc 
a42e			 
a42e c5					push bc 
a42f cd 18 99				call forth_push_str 
a432 c1					pop bc 
a433			 
a433 e1					pop hl 	 
a434			 
a434 cd 64 9d		.nuword:	call forth_tok_next 
a437 18 92				jr .douscan  
a439			 
a439			.udone:		 ; push count of uwords found 
a439 c5					push bc 
a43a e1					pop hl 
a43b			 
a43b				if DEBUG_FORTH_WORDS 
a43b					DMARK "UWc" 
a43b f5				push af  
a43c 3a 50 a4			ld a, (.dmark)  
a43f 32 7a ee			ld (debug_mark),a  
a442 3a 51 a4			ld a, (.dmark+1)  
a445 32 7b ee			ld (debug_mark+1),a  
a448 3a 52 a4			ld a, (.dmark+2)  
a44b 32 7c ee			ld (debug_mark+2),a  
a44e 18 03			jr .pastdmark  
a450 ..			.dmark: db "UWc"  
a453 f1			.pastdmark: pop af  
a454			endm  
# End of macro DMARK
a454					CALLMONITOR 
a454 cd 1d 93			call break_point_state  
a457				endm  
# End of macro CALLMONITOR
a457				endif 
a457 cd aa 98				call forth_push_numhl 
a45a			 
a45a			 
a45a				       NEXTW 
a45a c3 13 9c			jp macro_next 
a45d				endm 
# End of macro NEXTW
a45d			 
a45d			.BP: 
a45d				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a45d 54				db WORD_SYS_CORE+64             
a45e 93 a4			dw .MONITOR            
a460 03				db 2 + 1 
a461 .. 00			db "BP",0              
a464				endm 
# End of macro CWHEAD
a464			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a464			; | | $00 Will enable the break points within specific code paths 
a464			; | | $01 Will disable break points 
a464			; | |  
a464			; | | By default break points are off. Either the above can be used to enable them 
a464			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a464			; | | and on release of the pressed key a message will be disaplayed to notify 
a464			; | | that break points are enabled. Pressing any key will then continue boot process. 
a464					; get byte count 
a464					if DEBUG_FORTH_WORDS_KEY 
a464						DMARK "BP." 
a464 f5				push af  
a465 3a 79 a4			ld a, (.dmark)  
a468 32 7a ee			ld (debug_mark),a  
a46b 3a 7a a4			ld a, (.dmark+1)  
a46e 32 7b ee			ld (debug_mark+1),a  
a471 3a 7b a4			ld a, (.dmark+2)  
a474 32 7c ee			ld (debug_mark+2),a  
a477 18 03			jr .pastdmark  
a479 ..			.dmark: db "BP."  
a47c f1			.pastdmark: pop af  
a47d			endm  
# End of macro DMARK
a47d						CALLMONITOR 
a47d cd 1d 93			call break_point_state  
a480				endm  
# End of macro CALLMONITOR
a480					endif 
a480			 
a480					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a480 cd a1 9a			call macro_dsp_valuehl 
a483				endm 
# End of macro FORTH_DSP_VALUEHL
a483			 
a483			;		push hl 
a483			 
a483					; destroy value TOS 
a483			 
a483					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a483 cd 59 9b			call macro_forth_dsp_pop 
a486				endm 
# End of macro FORTH_DSP_POP
a486			 
a486			;		pop hl 
a486			 
a486 3e 00				ld a,0 
a488 bd					cp l 
a489 28 02				jr z, .bpset 
a48b 3e 2a				ld a, '*' 
a48d			 
a48d 32 51 e3		.bpset:		ld (os_view_disable), a 
a490			 
a490			 
a490					NEXTW 
a490 c3 13 9c			jp macro_next 
a493				endm 
# End of macro NEXTW
a493			 
a493			 
a493			.MONITOR: 
a493				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a493 55				db WORD_SYS_CORE+65             
a494 c6 a4			dw .MALLOC            
a496 08				db 7 + 1 
a497 .. 00			db "MONITOR",0              
a49f				endm 
# End of macro CWHEAD
a49f			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a49f			; | | At start the current various registers will be displayed with contents. 
a49f			; | | Top right corner will show the most recent debug marker seen. 
a49f			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a49f			; | | and the return stack pointer (RSP). 
a49f			; | | Pressing: 
a49f			; | |    1 - Initial screen 
a49f			; | |    2 - Display a data dump of HL 
a49f			; | |    3 - Display a data dump of DE 
a49f			; | |    4 - Display a data dump of BC 
a49f			; | |    5 - Display a data dump of HL 
a49f			; | |    6 - Display a data dump of DSP 
a49f			; | |    7 - Display a data dump of RSP 
a49f			; | |    8 - Display a data dump of what is at DSP 
a49f			; | |    9 - Display a data dump of what is at RSP 
a49f			; | |    0 - Exit monitor and continue running. This will also enable break points 
a49f			; | |    * - Disable break points 
a49f			; | |    # - Enter traditional monitor mode 
a49f			; | | 
a49f			; | | Monitor Mode 
a49f			; | | ------------ 
a49f			; | | A prompt of '>' will be shown for various commands: 
a49f			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a49f			; | |    C - Continue display a data dump from the last set address 
a49f			; | |    M xxxx - Set start of memory edit at address xx 
a49f			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a49f			; | |    Q - Return to previous 
a49f					if DEBUG_FORTH_WORDS_KEY 
a49f						DMARK "MON" 
a49f f5				push af  
a4a0 3a b4 a4			ld a, (.dmark)  
a4a3 32 7a ee			ld (debug_mark),a  
a4a6 3a b5 a4			ld a, (.dmark+1)  
a4a9 32 7b ee			ld (debug_mark+1),a  
a4ac 3a b6 a4			ld a, (.dmark+2)  
a4af 32 7c ee			ld (debug_mark+2),a  
a4b2 18 03			jr .pastdmark  
a4b4 ..			.dmark: db "MON"  
a4b7 f1			.pastdmark: pop af  
a4b8			endm  
# End of macro DMARK
a4b8						CALLMONITOR 
a4b8 cd 1d 93			call break_point_state  
a4bb				endm  
# End of macro CALLMONITOR
a4bb					endif 
a4bb 3e 00				ld a, 0 
a4bd 32 51 e3				ld (os_view_disable), a 
a4c0			 
a4c0					CALLMONITOR 
a4c0 cd 1d 93			call break_point_state  
a4c3				endm  
# End of macro CALLMONITOR
a4c3			 
a4c3			;	call monitor 
a4c3			 
a4c3					NEXTW 
a4c3 c3 13 9c			jp macro_next 
a4c6				endm 
# End of macro NEXTW
a4c6			 
a4c6			 
a4c6			.MALLOC: 
a4c6				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a4c6 56				db WORD_SYS_CORE+66             
a4c7 ef a4			dw .MALLOC2            
a4c9 06				db 5 + 1 
a4ca .. 00			db "ALLOT",0              
a4d0				endm 
# End of macro CWHEAD
a4d0			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a4d0					if DEBUG_FORTH_WORDS_KEY 
a4d0						DMARK "ALL" 
a4d0 f5				push af  
a4d1 3a e5 a4			ld a, (.dmark)  
a4d4 32 7a ee			ld (debug_mark),a  
a4d7 3a e6 a4			ld a, (.dmark+1)  
a4da 32 7b ee			ld (debug_mark+1),a  
a4dd 3a e7 a4			ld a, (.dmark+2)  
a4e0 32 7c ee			ld (debug_mark+2),a  
a4e3 18 03			jr .pastdmark  
a4e5 ..			.dmark: db "ALL"  
a4e8 f1			.pastdmark: pop af  
a4e9			endm  
# End of macro DMARK
a4e9						CALLMONITOR 
a4e9 cd 1d 93			call break_point_state  
a4ec				endm  
# End of macro CALLMONITOR
a4ec					endif 
a4ec c3 16 a5				jp .mallocc 
a4ef			.MALLOC2: 
a4ef				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a4ef 56				db WORD_SYS_CORE+66             
a4f0 2d a5			dw .FREE            
a4f2 07				db 6 + 1 
a4f3 .. 00			db "MALLOC",0              
a4fa				endm 
# End of macro CWHEAD
a4fa			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a4fa					; get byte count 
a4fa					if DEBUG_FORTH_WORDS_KEY 
a4fa						DMARK "MAL" 
a4fa f5				push af  
a4fb 3a 0f a5			ld a, (.dmark)  
a4fe 32 7a ee			ld (debug_mark),a  
a501 3a 10 a5			ld a, (.dmark+1)  
a504 32 7b ee			ld (debug_mark+1),a  
a507 3a 11 a5			ld a, (.dmark+2)  
a50a 32 7c ee			ld (debug_mark+2),a  
a50d 18 03			jr .pastdmark  
a50f ..			.dmark: db "MAL"  
a512 f1			.pastdmark: pop af  
a513			endm  
# End of macro DMARK
a513						CALLMONITOR 
a513 cd 1d 93			call break_point_state  
a516				endm  
# End of macro CALLMONITOR
a516					endif 
a516			.mallocc: 
a516					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a516 cd a1 9a			call macro_dsp_valuehl 
a519				endm 
# End of macro FORTH_DSP_VALUEHL
a519			 
a519			;		push hl 
a519			 
a519					; destroy value TOS 
a519			 
a519					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a519 cd 59 9b			call macro_forth_dsp_pop 
a51c				endm 
# End of macro FORTH_DSP_POP
a51c			 
a51c			;		pop hl 
a51c cd 71 8f				call malloc 
a51f				if DEBUG_FORTH_MALLOC_GUARD 
a51f f5					push af 
a520 cd d3 8a				call ishlzero 
a523			;		ld a, l 
a523			;		add h 
a523			;		cp 0 
a523 f1					pop af 
a524					 
a524 cc fd c3				call z,malloc_error 
a527				endif 
a527			 
a527 cd aa 98				call forth_push_numhl 
a52a					NEXTW 
a52a c3 13 9c			jp macro_next 
a52d				endm 
# End of macro NEXTW
a52d			 
a52d			.FREE: 
a52d				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a52d 57				db WORD_SYS_CORE+67             
a52e 5e a5			dw .LIST            
a530 05				db 4 + 1 
a531 .. 00			db "FREE",0              
a536				endm 
# End of macro CWHEAD
a536			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a536					if DEBUG_FORTH_WORDS_KEY 
a536						DMARK "FRE" 
a536 f5				push af  
a537 3a 4b a5			ld a, (.dmark)  
a53a 32 7a ee			ld (debug_mark),a  
a53d 3a 4c a5			ld a, (.dmark+1)  
a540 32 7b ee			ld (debug_mark+1),a  
a543 3a 4d a5			ld a, (.dmark+2)  
a546 32 7c ee			ld (debug_mark+2),a  
a549 18 03			jr .pastdmark  
a54b ..			.dmark: db "FRE"  
a54e f1			.pastdmark: pop af  
a54f			endm  
# End of macro DMARK
a54f						CALLMONITOR 
a54f cd 1d 93			call break_point_state  
a552				endm  
# End of macro CALLMONITOR
a552					endif 
a552					; get address 
a552			 
a552					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a552 cd a1 9a			call macro_dsp_valuehl 
a555				endm 
# End of macro FORTH_DSP_VALUEHL
a555			 
a555			;		push hl 
a555			 
a555					; destroy value TOS 
a555			 
a555					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a555 cd 59 9b			call macro_forth_dsp_pop 
a558				endm 
# End of macro FORTH_DSP_POP
a558			 
a558			;		pop hl 
a558			if FORTH_ENABLE_MALLOCFREE 
a558 cd 3b 90				call free 
a55b			endif 
a55b					NEXTW 
a55b c3 13 9c			jp macro_next 
a55e				endm 
# End of macro NEXTW
a55e			.LIST: 
a55e				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a55e 5c				db WORD_SYS_CORE+72             
a55f 21 a7			dw .FORGET            
a561 05				db 4 + 1 
a562 .. 00			db "LIST",0              
a567				endm 
# End of macro CWHEAD
a567			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a567			; | | The quoted word must be in upper case. 
a567				if DEBUG_FORTH_WORDS_KEY 
a567					DMARK "LST" 
a567 f5				push af  
a568 3a 7c a5			ld a, (.dmark)  
a56b 32 7a ee			ld (debug_mark),a  
a56e 3a 7d a5			ld a, (.dmark+1)  
a571 32 7b ee			ld (debug_mark+1),a  
a574 3a 7e a5			ld a, (.dmark+2)  
a577 32 7c ee			ld (debug_mark+2),a  
a57a 18 03			jr .pastdmark  
a57c ..			.dmark: db "LST"  
a57f f1			.pastdmark: pop af  
a580			endm  
# End of macro DMARK
a580					CALLMONITOR 
a580 cd 1d 93			call break_point_state  
a583				endm  
# End of macro CALLMONITOR
a583				endif 
a583			 
a583					FORTH_DSP_VALUEHL 
a583 cd a1 9a			call macro_dsp_valuehl 
a586				endm 
# End of macro FORTH_DSP_VALUEHL
a586			 
a586 e5					push hl 
a587 c1					pop bc 
a588			 
a588			; Start format of scratch string 
a588			 
a588 21 60 e3				ld hl, scratch 
a58b			 
a58b 3e 3a				ld a, ':' 
a58d 77					ld (hl),a 
a58e 23					inc hl 
a58f 3e 20				ld a, ' ' 
a591 77					ld (hl), a 
a592			 
a592					; Get ptr to the word we need to look up 
a592			 
a592			;		FORTH_DSP_VALUEHL 
a592					;v5 FORTH_DSP_VALUE 
a592				; TODO type check 
a592			;		inc hl    ; Skip type check  
a592			;		push hl 
a592			;		ex de, hl    ; put into DE 
a592			 
a592			 
a592 21 48 d7				ld hl, baseram 
a595					;ld hl, baseusermem 
a595			 
a595 e5			push hl   ; sacreifical push 
a596			 
a596			.ldouscanm: 
a596 e1				pop hl 
a597			.ldouscan: 
a597				if DEBUG_FORTH_WORDS 
a597					DMARK "LSs" 
a597 f5				push af  
a598 3a ac a5			ld a, (.dmark)  
a59b 32 7a ee			ld (debug_mark),a  
a59e 3a ad a5			ld a, (.dmark+1)  
a5a1 32 7b ee			ld (debug_mark+1),a  
a5a4 3a ae a5			ld a, (.dmark+2)  
a5a7 32 7c ee			ld (debug_mark+2),a  
a5aa 18 03			jr .pastdmark  
a5ac ..			.dmark: db "LSs"  
a5af f1			.pastdmark: pop af  
a5b0			endm  
# End of macro DMARK
a5b0					CALLMONITOR 
a5b0 cd 1d 93			call break_point_state  
a5b3				endm  
# End of macro CALLMONITOR
a5b3				endif 
a5b3				; skip dict stub 
a5b3 cd 64 9d				call forth_tok_next 
a5b6			 
a5b6			 
a5b6			; while we have words to look for 
a5b6			 
a5b6 7e				ld a, (hl)      
a5b7				if DEBUG_FORTH_WORDS 
a5b7					DMARK "LSk" 
a5b7 f5				push af  
a5b8 3a cc a5			ld a, (.dmark)  
a5bb 32 7a ee			ld (debug_mark),a  
a5be 3a cd a5			ld a, (.dmark+1)  
a5c1 32 7b ee			ld (debug_mark+1),a  
a5c4 3a ce a5			ld a, (.dmark+2)  
a5c7 32 7c ee			ld (debug_mark+2),a  
a5ca 18 03			jr .pastdmark  
a5cc ..			.dmark: db "LSk"  
a5cf f1			.pastdmark: pop af  
a5d0			endm  
# End of macro DMARK
a5d0					CALLMONITOR 
a5d0 cd 1d 93			call break_point_state  
a5d3				endm  
# End of macro CALLMONITOR
a5d3				endif 
a5d3 fe 00				cp WORD_SYS_END 
a5d5 ca 08 a7				jp z, .lunotfound 
a5d8 fe 01				cp WORD_SYS_UWORD 
a5da c2 97 a5				jp nz, .ldouscan 
a5dd			 
a5dd				if DEBUG_FORTH_WORDS 
a5dd					DMARK "LSu" 
a5dd f5				push af  
a5de 3a f2 a5			ld a, (.dmark)  
a5e1 32 7a ee			ld (debug_mark),a  
a5e4 3a f3 a5			ld a, (.dmark+1)  
a5e7 32 7b ee			ld (debug_mark+1),a  
a5ea 3a f4 a5			ld a, (.dmark+2)  
a5ed 32 7c ee			ld (debug_mark+2),a  
a5f0 18 03			jr .pastdmark  
a5f2 ..			.dmark: db "LSu"  
a5f5 f1			.pastdmark: pop af  
a5f6			endm  
# End of macro DMARK
a5f6					CALLMONITOR 
a5f6 cd 1d 93			call break_point_state  
a5f9				endm  
# End of macro CALLMONITOR
a5f9				endif 
a5f9			 
a5f9					; found a uword but is it the one we want... 
a5f9			 
a5f9 c5					push bc     ; uword to find is on bc 
a5fa d1					pop de 
a5fb			 
a5fb e5					push hl  ; to save the ptr 
a5fc			 
a5fc					; skip opcode 
a5fc 23					inc hl  
a5fd					; skip next ptr 
a5fd 23					inc hl  
a5fe 23					inc hl 
a5ff					; skip len 
a5ff 23					inc hl 
a600			 
a600				if DEBUG_FORTH_WORDS 
a600					DMARK "LSc" 
a600 f5				push af  
a601 3a 15 a6			ld a, (.dmark)  
a604 32 7a ee			ld (debug_mark),a  
a607 3a 16 a6			ld a, (.dmark+1)  
a60a 32 7b ee			ld (debug_mark+1),a  
a60d 3a 17 a6			ld a, (.dmark+2)  
a610 32 7c ee			ld (debug_mark+2),a  
a613 18 03			jr .pastdmark  
a615 ..			.dmark: db "LSc"  
a618 f1			.pastdmark: pop af  
a619			endm  
# End of macro DMARK
a619					CALLMONITOR 
a619 cd 1d 93			call break_point_state  
a61c				endm  
# End of macro CALLMONITOR
a61c				endif 
a61c cd 40 8f				call strcmp 
a61f c2 96 a5				jp nz, .ldouscanm 
a622				 
a622			 
a622			 
a622					; we have a uword so push its name to the stack 
a622			 
a622			;	   	push hl  ; save so we can move to next dict block 
a622 e1			pop hl 
a623			 
a623				if DEBUG_FORTH_WORDS 
a623					DMARK "LSm" 
a623 f5				push af  
a624 3a 38 a6			ld a, (.dmark)  
a627 32 7a ee			ld (debug_mark),a  
a62a 3a 39 a6			ld a, (.dmark+1)  
a62d 32 7b ee			ld (debug_mark+1),a  
a630 3a 3a a6			ld a, (.dmark+2)  
a633 32 7c ee			ld (debug_mark+2),a  
a636 18 03			jr .pastdmark  
a638 ..			.dmark: db "LSm"  
a63b f1			.pastdmark: pop af  
a63c			endm  
# End of macro DMARK
a63c					CALLMONITOR 
a63c cd 1d 93			call break_point_state  
a63f				endm  
# End of macro CALLMONITOR
a63f				endif 
a63f			 
a63f					; skip opcode 
a63f 23					inc hl  
a640					; skip next ptr 
a640 23					inc hl  
a641 23					inc hl 
a642					; skip len 
a642 7e					ld a, (hl)   ; save length to add 
a643				if DEBUG_FORTH_WORDS 
a643					DMARK "LS2" 
a643 f5				push af  
a644 3a 58 a6			ld a, (.dmark)  
a647 32 7a ee			ld (debug_mark),a  
a64a 3a 59 a6			ld a, (.dmark+1)  
a64d 32 7b ee			ld (debug_mark+1),a  
a650 3a 5a a6			ld a, (.dmark+2)  
a653 32 7c ee			ld (debug_mark+2),a  
a656 18 03			jr .pastdmark  
a658 ..			.dmark: db "LS2"  
a65b f1			.pastdmark: pop af  
a65c			endm  
# End of macro DMARK
a65c					CALLMONITOR 
a65c cd 1d 93			call break_point_state  
a65f				endm  
# End of macro CALLMONITOR
a65f				endif 
a65f			 
a65f					; save this location 
a65f				 
a65f e5					push hl 
a660			 
a660 23					inc hl 
a661 11 62 e3				ld de, scratch+2 
a664 4f					ld c, a 
a665 06 00				ld b, 0 
a667			 
a667				if DEBUG_FORTH_WORDS 
a667					DMARK "LSn" 
a667 f5				push af  
a668 3a 7c a6			ld a, (.dmark)  
a66b 32 7a ee			ld (debug_mark),a  
a66e 3a 7d a6			ld a, (.dmark+1)  
a671 32 7b ee			ld (debug_mark+1),a  
a674 3a 7e a6			ld a, (.dmark+2)  
a677 32 7c ee			ld (debug_mark+2),a  
a67a 18 03			jr .pastdmark  
a67c ..			.dmark: db "LSn"  
a67f f1			.pastdmark: pop af  
a680			endm  
# End of macro DMARK
a680					CALLMONITOR 
a680 cd 1d 93			call break_point_state  
a683				endm  
# End of macro CALLMONITOR
a683				endif 
a683			 
a683					; copy uword name to scratch 
a683			 
a683 ed b0				ldir 
a685			 
a685 1b					dec de 
a686 3e 20				ld a, ' '    ; change null to space 
a688 12					ld (de), a 
a689			 
a689 13					inc de 
a68a			 
a68a d5					push de 
a68b c1					pop bc     ; move scratch pointer to end of word name and save it 
a68c			 
a68c e1					pop hl 
a68d 7e					ld a, (hl) 
a68e					;inc hl 
a68e					; skip word string 
a68e cd aa 8a				call addatohl 
a691			 
a691 23					inc hl 
a692			 
a692				if DEBUG_FORTH_WORDS 
a692					DMARK "LS3" 
a692 f5				push af  
a693 3a a7 a6			ld a, (.dmark)  
a696 32 7a ee			ld (debug_mark),a  
a699 3a a8 a6			ld a, (.dmark+1)  
a69c 32 7b ee			ld (debug_mark+1),a  
a69f 3a a9 a6			ld a, (.dmark+2)  
a6a2 32 7c ee			ld (debug_mark+2),a  
a6a5 18 03			jr .pastdmark  
a6a7 ..			.dmark: db "LS3"  
a6aa f1			.pastdmark: pop af  
a6ab			endm  
# End of macro DMARK
a6ab					CALLMONITOR 
a6ab cd 1d 93			call break_point_state  
a6ae				endm  
# End of macro CALLMONITOR
a6ae				endif 
a6ae					; should now be at the start of the machine code to setup the eval of the uword 
a6ae					; now locate the ptr to the string defintion 
a6ae			 
a6ae					; skip ld hl, 
a6ae					; then load the ptr 
a6ae			 
a6ae 23					inc hl 
a6af 5e					ld e, (hl) 
a6b0 23					inc hl 
a6b1 56					ld d, (hl) 
a6b2 eb					ex de, hl 
a6b3			 
a6b3			 
a6b3				if DEBUG_FORTH_WORDS 
a6b3					DMARK "LSt" 
a6b3 f5				push af  
a6b4 3a c8 a6			ld a, (.dmark)  
a6b7 32 7a ee			ld (debug_mark),a  
a6ba 3a c9 a6			ld a, (.dmark+1)  
a6bd 32 7b ee			ld (debug_mark+1),a  
a6c0 3a ca a6			ld a, (.dmark+2)  
a6c3 32 7c ee			ld (debug_mark+2),a  
a6c6 18 03			jr .pastdmark  
a6c8 ..			.dmark: db "LSt"  
a6cb f1			.pastdmark: pop af  
a6cc			endm  
# End of macro DMARK
a6cc					CALLMONITOR 
a6cc cd 1d 93			call break_point_state  
a6cf				endm  
# End of macro CALLMONITOR
a6cf				endif 
a6cf			 
a6cf			; cant push right now due to tokenised strings  
a6cf			 
a6cf			; get the destination of where to copy this definition to. 
a6cf			 
a6cf c5					push bc 
a6d0 d1					pop de 
a6d1			 
a6d1 7e			.listl:         ld a,(hl) 
a6d2 fe 00				cp 0 
a6d4 28 09				jr z, .lreplsp     ; replace zero with space 
a6d6 fe 7f				cp FORTH_END_BUFFER 
a6d8 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a6da				 
a6da					; just copy this char as is then 
a6da			 
a6da 12					ld (de), a 
a6db			 
a6db 23			.listnxt:	inc hl 
a6dc 13					inc de 
a6dd 18 f2				jr .listl 
a6df			 
a6df 3e 20		.lreplsp:	ld a,' ' 
a6e1 12					ld (de), a 
a6e2 18 f7				jr .listnxt 
a6e4			 
a6e4			; close up uword def 
a6e4			 
a6e4			.listdone: 
a6e4 3e 00				ld a, 0 
a6e6 12					ld (de), a 
a6e7			 
a6e7			; now have def so clean up and push to stack 
a6e7			 
a6e7 21 60 e3				ld hl, scratch 
a6ea				if DEBUG_FORTH_WORDS 
a6ea					DMARK "Ltp" 
a6ea f5				push af  
a6eb 3a ff a6			ld a, (.dmark)  
a6ee 32 7a ee			ld (debug_mark),a  
a6f1 3a 00 a7			ld a, (.dmark+1)  
a6f4 32 7b ee			ld (debug_mark+1),a  
a6f7 3a 01 a7			ld a, (.dmark+2)  
a6fa 32 7c ee			ld (debug_mark+2),a  
a6fd 18 03			jr .pastdmark  
a6ff ..			.dmark: db "Ltp"  
a702 f1			.pastdmark: pop af  
a703			endm  
# End of macro DMARK
a703					CALLMONITOR 
a703 cd 1d 93			call break_point_state  
a706				endm  
# End of macro CALLMONITOR
a706				endif 
a706			 
a706 18 06			jr .listpush 
a708			 
a708			;.lnuword:	pop hl 
a708			;		call forth_tok_next 
a708			;		jp .ldouscan  
a708			 
a708			.lunotfound:		  
a708			 
a708			 
a708					 
a708					FORTH_DSP_POP 
a708 cd 59 9b			call macro_forth_dsp_pop 
a70b				endm 
# End of macro FORTH_DSP_POP
a70b 21 14 a7				ld hl, .luno 
a70e						 
a70e			 
a70e			.listpush: 
a70e cd 18 99				call forth_push_str 
a711			 
a711			 
a711			 
a711					NEXTW 
a711 c3 13 9c			jp macro_next 
a714				endm 
# End of macro NEXTW
a714			 
a714 .. 00		.luno:    db "Not found",0 
a71e			 
a71e			 
a71e			 
a71e			 
a71e			 
a71e			;		push hl   ; save pointer to start of uword def string 
a71e			; 
a71e			;; look for FORTH_EOL_LINE 
a71e			;		ld a, FORTH_END_BUFFER 
a71e			;		call strlent 
a71e			; 
a71e			;		inc hl		 ; space for coln def 
a71e			;		inc hl 
a71e			;		inc hl          ; space for terms 
a71e			;		inc hl 
a71e			; 
a71e			;		ld a, 20   ; TODO get actual length 
a71e			;		call addatohl    ; include a random amount of room for the uword name 
a71e			; 
a71e			;		 
a71e			;	if DEBUG_FORTH_WORDS 
a71e			;		DMARK "Lt1" 
a71e			;		CALLMONITOR 
a71e			;	endif 
a71e			;		 
a71e			; 
a71e			;; malloc space for the string because we cant change it 
a71e			; 
a71e			;		call malloc 
a71e			;	if DEBUG_FORTH_MALLOC_GUARD 
a71e			;		push af 
a71e			;		call ishlzero 
a71e			;		pop af 
a71e			;		 
a71e			;		call z,malloc_error 
a71e			;	endif 
a71e			; 
a71e			;	if DEBUG_FORTH_WORDS 
a71e			;		DMARK "Lt2" 
a71e			;		CALLMONITOR 
a71e			;	endif 
a71e			;		pop de 
a71e			;		push hl    ; push the malloc to release later 
a71e			;		push hl   ;  push back a copy for the later stack push 
a71e			;		 
a71e			;; copy the string swapping out the zero terms for spaces 
a71e			; 
a71e			;		; de has our source 
a71e			;		; hl has our dest 
a71e			; 
a71e			;; add the coln def 
a71e			; 
a71e			;		ld a, ':' 
a71e			;		ld (hl), a 
a71e			;		inc hl 
a71e			;		ld a, ' ' 
a71e			;		ld (hl), a 
a71e			;		inc hl 
a71e			; 
a71e			;; add the uname word 
a71e			;		push de   ; save our string for now 
a71e			;		ex de, hl 
a71e			; 
a71e			;		FORTH_DSP_VALUE 
a71e			;		;v5 FORTH_DSP_VALUE 
a71e			; 
a71e			;		inc hl   ; skip type but we know by now this is OK 
a71e			; 
a71e			;.luword:	ld a,(hl) 
a71e			;		cp 0 
a71e			;		jr z, .luword2 
a71e			;		ld (de), a 
a71e			;		inc de 
a71e			;		inc hl 
a71e			;		jr .luword 
a71e			; 
a71e			;.luword2:	ld a, ' ' 
a71e			;		ld (de), a 
a71e			;;		inc hl 
a71e			;;		inc de 
a71e			;;		ld (de), a 
a71e			;;		inc hl 
a71e			;		inc de 
a71e			; 
a71e			;		ex de, hl 
a71e			;		pop de 
a71e			;		 
a71e			;		 
a71e			; 
a71e			;; detoken that string and copy it 
a71e			; 
a71e			;	if DEBUG_FORTH_WORDS 
a71e			;		DMARK "Lt2" 
a71e			;		CALLMONITOR 
a71e			;	endif 
a71e			;.ldetok:	ld a, (de) 
a71e			;		cp FORTH_END_BUFFER 
a71e			;		jr z, .ldetokend 
a71e			;		; swap out any zero term for space 
a71e			;		cp 0 
a71e			;		jr nz, .ldetoknext 
a71e			;		ld a, ' ' 
a71e			; 
a71e			;	if DEBUG_FORTH_WORDS 
a71e			;		DMARK "LtS" 
a71e			;		CALLMONITOR 
a71e			;	endif 
a71e			;.ldetoknext:	ld (hl), a 
a71e			;		inc de 
a71e			;		inc hl 
a71e			;		jr .ldetok 
a71e			; 
a71e			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a71e			;		ld (hl), a  
a71e			; 
a71e			;; free that temp malloc 
a71e			; 
a71e			;		pop hl    
a71e			; 
a71e			;	if DEBUG_FORTH_WORDS 
a71e			;		DMARK "Lt4" 
a71e			;		CALLMONITOR 
a71e			;	endif 
a71e			;		call forth_apushstrhl 
a71e			; 
a71e			;		; get rid of temp malloc area 
a71e			; 
a71e			;		pop hl 
a71e			;		call free 
a71e			; 
a71e			;		jr .ludone 
a71e			; 
a71e			;.lnuword:	pop hl 
a71e			;		call forth_tok_next 
a71e			;		jp .ldouscan  
a71e			; 
a71e			;.ludone:		 pop hl 
a71e			; 
a71e					NEXTW 
a71e c3 13 9c			jp macro_next 
a721				endm 
# End of macro NEXTW
a721			 
a721			.FORGET: 
a721				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a721 5d				db WORD_SYS_CORE+73             
a722 9a a7			dw .NOP            
a724 07				db 6 + 1 
a725 .. 00			db "FORGET",0              
a72c				endm 
# End of macro CWHEAD
a72c			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a72c			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a72c			; | |  
a72c			; | | e.g. "MORE" forget 
a72c					if DEBUG_FORTH_WORDS_KEY 
a72c						DMARK "FRG" 
a72c f5				push af  
a72d 3a 41 a7			ld a, (.dmark)  
a730 32 7a ee			ld (debug_mark),a  
a733 3a 42 a7			ld a, (.dmark+1)  
a736 32 7b ee			ld (debug_mark+1),a  
a739 3a 43 a7			ld a, (.dmark+2)  
a73c 32 7c ee			ld (debug_mark+2),a  
a73f 18 03			jr .pastdmark  
a741 ..			.dmark: db "FRG"  
a744 f1			.pastdmark: pop af  
a745			endm  
# End of macro DMARK
a745						CALLMONITOR 
a745 cd 1d 93			call break_point_state  
a748				endm  
# End of macro CALLMONITOR
a748					endif 
a748			 
a748				; find uword 
a748			        ; update start of word with "_" 
a748				; replace uword with deleted flag 
a748			 
a748			 
a748			;	if DEBUG_FORTH_WORDS 
a748			;		DMARK "FOG" 
a748			;		CALLMONITOR 
a748			;	endif 
a748			 
a748			 
a748					; Get ptr to the word we need to look up 
a748			 
a748					FORTH_DSP_VALUEHL 
a748 cd a1 9a			call macro_dsp_valuehl 
a74b				endm 
# End of macro FORTH_DSP_VALUEHL
a74b					;v5 FORTH_DSP_VALUE 
a74b				; TODO type check 
a74b			;		inc hl    ; Skip type check  
a74b e5					push hl 
a74c c1					pop bc 
a74d			;		ex de, hl    ; put into DE 
a74d			 
a74d			 
a74d 21 48 d7				ld hl, baseram 
a750					;ld hl, baseusermem 
a750			 
a750				; skip dict stub 
a750			;	call forth_tok_next 
a750 e5			push hl   ; sacreifical push 
a751			 
a751			.fldouscanm: 
a751 e1				pop hl 
a752			.fldouscan: 
a752			;	if DEBUG_FORTH_WORDS 
a752			;		DMARK "LSs" 
a752			;		CALLMONITOR 
a752			;	endif 
a752				; skip dict stub 
a752 cd 64 9d				call forth_tok_next 
a755			 
a755			 
a755			; while we have words to look for 
a755			 
a755 7e				ld a, (hl)      
a756			;	if DEBUG_FORTH_WORDS 
a756			;		DMARK "LSk" 
a756			;		CALLMONITOR 
a756			;	endif 
a756 fe 00				cp WORD_SYS_END 
a758 ca 94 a7				jp z, .flunotfound 
a75b fe 01				cp WORD_SYS_UWORD 
a75d c2 52 a7				jp nz, .fldouscan 
a760			 
a760			;	if DEBUG_FORTH_WORDS 
a760			;		DMARK "LSu" 
a760			;		CALLMONITOR 
a760			;	endif 
a760			 
a760					; found a uword but is it the one we want... 
a760			 
a760 c5					push bc     ; uword to find is on bc 
a761 d1					pop de 
a762			 
a762 e5					push hl  ; to save the ptr 
a763			 
a763					; skip opcode 
a763 23					inc hl  
a764					; skip next ptr 
a764 23					inc hl  
a765 23					inc hl 
a766					; skip len 
a766 23					inc hl 
a767			 
a767			;	if DEBUG_FORTH_WORDS 
a767			;		DMARK "LSc" 
a767			;		CALLMONITOR 
a767			;	endif 
a767 cd 40 8f				call strcmp 
a76a c2 51 a7				jp nz, .fldouscanm 
a76d			; 
a76d			; 
a76d			;; while we have words to look for 
a76d			; 
a76d			;.fdouscan:	ld a, (hl)      
a76d			;	if DEBUG_FORTH_WORDS 
a76d			;		DMARK "LSs" 
a76d			;		CALLMONITOR 
a76d			;	endif 
a76d			;		cp WORD_SYS_END 
a76d			;		jp z, .fudone 
a76d			;		cp WORD_SYS_UWORD 
a76d			;		jp nz, .fnuword 
a76d			; 
a76d			;	if DEBUG_FORTH_WORDS 
a76d			;		DMARK "FGu" 
a76d			;		CALLMONITOR 
a76d			;	endif 
a76d			; 
a76d			;		; found a uword but is it the one we want... 
a76d			; 
a76d			; 
a76d			;	        pop de   ; get back the dsp name 
a76d			;		push de 
a76d			; 
a76d			;		push hl  ; to save the ptr 
a76d			; 
a76d			;		; skip opcode 
a76d			;		inc hl  
a76d			;		; skip next ptr 
a76d			;		inc hl  
a76d			;		inc hl 
a76d			;		; skip len 
a76d			;		inc hl 
a76d			; 
a76d			;	if DEBUG_FORTH_WORDS 
a76d			;		DMARK "FGc" 
a76d			;		CALLMONITOR 
a76d			;	endif 
a76d			;		call strcmp 
a76d			;		jp nz, .fnuword 
a76d			 
a76d			 
a76d e1			pop hl 
a76e			 
a76e				 
a76e				if DEBUG_FORTH_WORDS 
a76e					DMARK "FGm" 
a76e f5				push af  
a76f 3a 83 a7			ld a, (.dmark)  
a772 32 7a ee			ld (debug_mark),a  
a775 3a 84 a7			ld a, (.dmark+1)  
a778 32 7b ee			ld (debug_mark+1),a  
a77b 3a 85 a7			ld a, (.dmark+2)  
a77e 32 7c ee			ld (debug_mark+2),a  
a781 18 03			jr .pastdmark  
a783 ..			.dmark: db "FGm"  
a786 f1			.pastdmark: pop af  
a787			endm  
# End of macro DMARK
a787					CALLMONITOR 
a787 cd 1d 93			call break_point_state  
a78a				endm  
# End of macro CALLMONITOR
a78a				endif 
a78a			 
a78a			 
a78a			 
a78a					; we have a uword so push its name to the stack 
a78a			 
a78a			;	   	push hl  ; save so we can move to next dict block 
a78a			;pop hl 
a78a			 
a78a					; update opcode to deleted 
a78a 3e 03				ld a, WORD_SYS_DELETED 
a78c 77					ld (hl), a 
a78d			 
a78d 23					inc hl  
a78e					; skip next ptr 
a78e 23					inc hl  
a78f 23					inc hl 
a790					; skip len 
a790 23					inc hl 
a791			 
a791					; TODO change parser to skip deleted words but for now mark it out 
a791 3e 5f				ld a, "_" 
a793 77					ld  (hl),a 
a794			 
a794			;		jr .fudone 
a794			; 
a794			;.fnuword:	pop hl 
a794			;		call forth_tok_next 
a794			;		jp .fdouscan  
a794			 
a794			.flunotfound:		  
a794			 
a794			 
a794					 
a794					FORTH_DSP_POP 
a794 cd 59 9b			call macro_forth_dsp_pop 
a797				endm 
# End of macro FORTH_DSP_POP
a797			;		ld hl, .luno 
a797			;.fudone:		 pop hl 
a797					NEXTW 
a797 c3 13 9c			jp macro_next 
a79a				endm 
# End of macro NEXTW
a79a			.NOP: 
a79a				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a79a 61				db WORD_SYS_CORE+77             
a79b c1 a7			dw .COMO            
a79d 04				db 3 + 1 
a79e .. 00			db "NOP",0              
a7a2				endm 
# End of macro CWHEAD
a7a2			; | NOP (  --  ) Do nothing | DONE 
a7a2					if DEBUG_FORTH_WORDS_KEY 
a7a2						DMARK "NOP" 
a7a2 f5				push af  
a7a3 3a b7 a7			ld a, (.dmark)  
a7a6 32 7a ee			ld (debug_mark),a  
a7a9 3a b8 a7			ld a, (.dmark+1)  
a7ac 32 7b ee			ld (debug_mark+1),a  
a7af 3a b9 a7			ld a, (.dmark+2)  
a7b2 32 7c ee			ld (debug_mark+2),a  
a7b5 18 03			jr .pastdmark  
a7b7 ..			.dmark: db "NOP"  
a7ba f1			.pastdmark: pop af  
a7bb			endm  
# End of macro DMARK
a7bb						CALLMONITOR 
a7bb cd 1d 93			call break_point_state  
a7be				endm  
# End of macro CALLMONITOR
a7be					endif 
a7be				       NEXTW 
a7be c3 13 9c			jp macro_next 
a7c1				endm 
# End of macro NEXTW
a7c1			.COMO: 
a7c1				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
a7c1 6e				db WORD_SYS_CORE+90             
a7c2 13 a8			dw .COMC            
a7c4 02				db 1 + 1 
a7c5 .. 00			db "(",0              
a7c7				endm 
# End of macro CWHEAD
a7c7			; | ( ( -- )  Start of comment | DONE 
a7c7			 
a7c7			 
a7c7 2a 61 e6				ld hl, ( os_tok_ptr) 
a7ca 11 0e a8			ld de, .closepar 
a7cd					 
a7cd					if DEBUG_FORTH_WORDS 
a7cd						DMARK ").." 
a7cd f5				push af  
a7ce 3a e2 a7			ld a, (.dmark)  
a7d1 32 7a ee			ld (debug_mark),a  
a7d4 3a e3 a7			ld a, (.dmark+1)  
a7d7 32 7b ee			ld (debug_mark+1),a  
a7da 3a e4 a7			ld a, (.dmark+2)  
a7dd 32 7c ee			ld (debug_mark+2),a  
a7e0 18 03			jr .pastdmark  
a7e2 ..			.dmark: db ").."  
a7e5 f1			.pastdmark: pop af  
a7e6			endm  
# End of macro DMARK
a7e6						CALLMONITOR 
a7e6 cd 1d 93			call break_point_state  
a7e9				endm  
# End of macro CALLMONITOR
a7e9					endif 
a7e9 cd 2e 9d			call findnexttok  
a7ec			 
a7ec					if DEBUG_FORTH_WORDS 
a7ec						DMARK "IF5" 
a7ec f5				push af  
a7ed 3a 01 a8			ld a, (.dmark)  
a7f0 32 7a ee			ld (debug_mark),a  
a7f3 3a 02 a8			ld a, (.dmark+1)  
a7f6 32 7b ee			ld (debug_mark+1),a  
a7f9 3a 03 a8			ld a, (.dmark+2)  
a7fc 32 7c ee			ld (debug_mark+2),a  
a7ff 18 03			jr .pastdmark  
a801 ..			.dmark: db "IF5"  
a804 f1			.pastdmark: pop af  
a805			endm  
# End of macro DMARK
a805						CALLMONITOR 
a805 cd 1d 93			call break_point_state  
a808				endm  
# End of macro CALLMONITOR
a808					endif 
a808				; replace below with ) exec using tok_ptr 
a808 22 61 e6			ld (os_tok_ptr), hl 
a80b c3 a4 9c			jp exec1 
a80e			 
a80e .. 00			.closepar:   db ")",0 
a810			 
a810				       NEXTW 
a810 c3 13 9c			jp macro_next 
a813				endm 
# End of macro NEXTW
a813			.COMC: 
a813				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
a813 6f				db WORD_SYS_CORE+91             
a814 1c a8			dw .SCRATCH            
a816 02				db 1 + 1 
a817 .. 00			db ")",0              
a819				endm 
# End of macro CWHEAD
a819			; | ) ( -- )  End of comment |  DONE  
a819				       NEXTW 
a819 c3 13 9c			jp macro_next 
a81c				endm 
# End of macro NEXTW
a81c			 
a81c			.SCRATCH: 
a81c				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
a81c 6f				db WORD_SYS_CORE+91             
a81d 57 a8			dw .INC            
a81f 08				db 7 + 1 
a820 .. 00			db "SCRATCH",0              
a828				endm 
# End of macro CWHEAD
a828			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
a828			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
a828			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
a828			; | |  
a828			; | | e.g.    : score $00 scratch ; 
a828			; | |  
a828			; | | $00 score ! 
a828			; | | $01 score +! 
a828			; | |  
a828			; | | e.g.   : varword $0a scratch ;  
a828			; | | 
a828			; | | $8000 varword ! 
a828					if DEBUG_FORTH_WORDS_KEY 
a828						DMARK "SCR" 
a828 f5				push af  
a829 3a 3d a8			ld a, (.dmark)  
a82c 32 7a ee			ld (debug_mark),a  
a82f 3a 3e a8			ld a, (.dmark+1)  
a832 32 7b ee			ld (debug_mark+1),a  
a835 3a 3f a8			ld a, (.dmark+2)  
a838 32 7c ee			ld (debug_mark+2),a  
a83b 18 03			jr .pastdmark  
a83d ..			.dmark: db "SCR"  
a840 f1			.pastdmark: pop af  
a841			endm  
# End of macro DMARK
a841						CALLMONITOR 
a841 cd 1d 93			call break_point_state  
a844				endm  
# End of macro CALLMONITOR
a844					endif 
a844			 
a844					FORTH_DSP_VALUEHL 
a844 cd a1 9a			call macro_dsp_valuehl 
a847				endm 
# End of macro FORTH_DSP_VALUEHL
a847				 
a847					FORTH_DSP_POP 
a847 cd 59 9b			call macro_forth_dsp_pop 
a84a				endm 
# End of macro FORTH_DSP_POP
a84a			 
a84a 7d					ld a, l 
a84b 21 85 e8				ld hl, os_var_array 
a84e cd aa 8a				call addatohl 
a851			 
a851 cd aa 98				call forth_push_numhl 
a854			 
a854				       NEXTW 
a854 c3 13 9c			jp macro_next 
a857				endm 
# End of macro NEXTW
a857			 
a857			.INC: 
a857				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
a857 6f				db WORD_SYS_CORE+91             
a858 ab a8			dw .DEC            
a85a 03				db 2 + 1 
a85b .. 00			db "+!",0              
a85e				endm 
# End of macro CWHEAD
a85e			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
a85e					if DEBUG_FORTH_WORDS_KEY 
a85e						DMARK "+s_" 
a85e f5				push af  
a85f 3a 73 a8			ld a, (.dmark)  
a862 32 7a ee			ld (debug_mark),a  
a865 3a 74 a8			ld a, (.dmark+1)  
a868 32 7b ee			ld (debug_mark+1),a  
a86b 3a 75 a8			ld a, (.dmark+2)  
a86e 32 7c ee			ld (debug_mark+2),a  
a871 18 03			jr .pastdmark  
a873 ..			.dmark: db "+s_"  
a876 f1			.pastdmark: pop af  
a877			endm  
# End of macro DMARK
a877						CALLMONITOR 
a877 cd 1d 93			call break_point_state  
a87a				endm  
# End of macro CALLMONITOR
a87a					endif 
a87a			 
a87a					FORTH_DSP_VALUEHL 
a87a cd a1 9a			call macro_dsp_valuehl 
a87d				endm 
# End of macro FORTH_DSP_VALUEHL
a87d			 
a87d e5					push hl   ; save address 
a87e			 
a87e					FORTH_DSP_POP 
a87e cd 59 9b			call macro_forth_dsp_pop 
a881				endm 
# End of macro FORTH_DSP_POP
a881			 
a881					FORTH_DSP_VALUEHL 
a881 cd a1 9a			call macro_dsp_valuehl 
a884				endm 
# End of macro FORTH_DSP_VALUEHL
a884			 
a884					FORTH_DSP_POP 
a884 cd 59 9b			call macro_forth_dsp_pop 
a887				endm 
# End of macro FORTH_DSP_POP
a887			 
a887					; hl contains value to add to byte at a 
a887				 
a887 eb					ex de, hl 
a888			 
a888 e1					pop hl 
a889			 
a889					if DEBUG_FORTH_WORDS 
a889						DMARK "INC" 
a889 f5				push af  
a88a 3a 9e a8			ld a, (.dmark)  
a88d 32 7a ee			ld (debug_mark),a  
a890 3a 9f a8			ld a, (.dmark+1)  
a893 32 7b ee			ld (debug_mark+1),a  
a896 3a a0 a8			ld a, (.dmark+2)  
a899 32 7c ee			ld (debug_mark+2),a  
a89c 18 03			jr .pastdmark  
a89e ..			.dmark: db "INC"  
a8a1 f1			.pastdmark: pop af  
a8a2			endm  
# End of macro DMARK
a8a2						CALLMONITOR 
a8a2 cd 1d 93			call break_point_state  
a8a5				endm  
# End of macro CALLMONITOR
a8a5					endif 
a8a5			 
a8a5 7e					ld a,(hl) 
a8a6 83					add e 
a8a7 77					ld (hl),a 
a8a8			 
a8a8			 
a8a8			 
a8a8				       NEXTW 
a8a8 c3 13 9c			jp macro_next 
a8ab				endm 
# End of macro NEXTW
a8ab			 
a8ab			.DEC: 
a8ab				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
a8ab 6f				db WORD_SYS_CORE+91             
a8ac fc a8			dw .INC2            
a8ae 03				db 2 + 1 
a8af .. 00			db "-!",0              
a8b2				endm 
# End of macro CWHEAD
a8b2			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
a8b2					if DEBUG_FORTH_WORDS_KEY 
a8b2						DMARK "-s_" 
a8b2 f5				push af  
a8b3 3a c7 a8			ld a, (.dmark)  
a8b6 32 7a ee			ld (debug_mark),a  
a8b9 3a c8 a8			ld a, (.dmark+1)  
a8bc 32 7b ee			ld (debug_mark+1),a  
a8bf 3a c9 a8			ld a, (.dmark+2)  
a8c2 32 7c ee			ld (debug_mark+2),a  
a8c5 18 03			jr .pastdmark  
a8c7 ..			.dmark: db "-s_"  
a8ca f1			.pastdmark: pop af  
a8cb			endm  
# End of macro DMARK
a8cb						CALLMONITOR 
a8cb cd 1d 93			call break_point_state  
a8ce				endm  
# End of macro CALLMONITOR
a8ce					endif 
a8ce			 
a8ce					FORTH_DSP_VALUEHL 
a8ce cd a1 9a			call macro_dsp_valuehl 
a8d1				endm 
# End of macro FORTH_DSP_VALUEHL
a8d1			 
a8d1 e5					push hl   ; save address 
a8d2			 
a8d2					FORTH_DSP_POP 
a8d2 cd 59 9b			call macro_forth_dsp_pop 
a8d5				endm 
# End of macro FORTH_DSP_POP
a8d5			 
a8d5					FORTH_DSP_VALUEHL 
a8d5 cd a1 9a			call macro_dsp_valuehl 
a8d8				endm 
# End of macro FORTH_DSP_VALUEHL
a8d8			 
a8d8					; hl contains value to add to byte at a 
a8d8				 
a8d8 eb					ex de, hl 
a8d9			 
a8d9 e1					pop hl 
a8da			 
a8da					if DEBUG_FORTH_WORDS 
a8da						DMARK "DEC" 
a8da f5				push af  
a8db 3a ef a8			ld a, (.dmark)  
a8de 32 7a ee			ld (debug_mark),a  
a8e1 3a f0 a8			ld a, (.dmark+1)  
a8e4 32 7b ee			ld (debug_mark+1),a  
a8e7 3a f1 a8			ld a, (.dmark+2)  
a8ea 32 7c ee			ld (debug_mark+2),a  
a8ed 18 03			jr .pastdmark  
a8ef ..			.dmark: db "DEC"  
a8f2 f1			.pastdmark: pop af  
a8f3			endm  
# End of macro DMARK
a8f3						CALLMONITOR 
a8f3 cd 1d 93			call break_point_state  
a8f6				endm  
# End of macro CALLMONITOR
a8f6					endif 
a8f6			 
a8f6 7e					ld a,(hl) 
a8f7 93					sub e 
a8f8 77					ld (hl),a 
a8f9			 
a8f9			 
a8f9			 
a8f9				       NEXTW 
a8f9 c3 13 9c			jp macro_next 
a8fc				endm 
# End of macro NEXTW
a8fc			 
a8fc			.INC2: 
a8fc				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
a8fc 6f				db WORD_SYS_CORE+91             
a8fd a6 a9			dw .DEC2            
a8ff 04				db 3 + 1 
a900 .. 00			db "+2!",0              
a904				endm 
# End of macro CWHEAD
a904			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
a904			 
a904					if DEBUG_FORTH_WORDS_KEY 
a904						DMARK "+2s" 
a904 f5				push af  
a905 3a 19 a9			ld a, (.dmark)  
a908 32 7a ee			ld (debug_mark),a  
a90b 3a 1a a9			ld a, (.dmark+1)  
a90e 32 7b ee			ld (debug_mark+1),a  
a911 3a 1b a9			ld a, (.dmark+2)  
a914 32 7c ee			ld (debug_mark+2),a  
a917 18 03			jr .pastdmark  
a919 ..			.dmark: db "+2s"  
a91c f1			.pastdmark: pop af  
a91d			endm  
# End of macro DMARK
a91d						CALLMONITOR 
a91d cd 1d 93			call break_point_state  
a920				endm  
# End of macro CALLMONITOR
a920					endif 
a920			 
a920					; Address 
a920			 
a920					FORTH_DSP_VALUEHL 
a920 cd a1 9a			call macro_dsp_valuehl 
a923				endm 
# End of macro FORTH_DSP_VALUEHL
a923			 
a923 e5					push hl    ; save address 
a924			 
a924					; load content into de 
a924			 
a924 5e					ld e,(hl) 
a925 23					inc hl 
a926 56					ld d, (hl) 
a927			 
a927					if DEBUG_FORTH_WORDS 
a927						DMARK "+2a" 
a927 f5				push af  
a928 3a 3c a9			ld a, (.dmark)  
a92b 32 7a ee			ld (debug_mark),a  
a92e 3a 3d a9			ld a, (.dmark+1)  
a931 32 7b ee			ld (debug_mark+1),a  
a934 3a 3e a9			ld a, (.dmark+2)  
a937 32 7c ee			ld (debug_mark+2),a  
a93a 18 03			jr .pastdmark  
a93c ..			.dmark: db "+2a"  
a93f f1			.pastdmark: pop af  
a940			endm  
# End of macro DMARK
a940						CALLMONITOR 
a940 cd 1d 93			call break_point_state  
a943				endm  
# End of macro CALLMONITOR
a943					endif 
a943			 
a943					FORTH_DSP_POP 
a943 cd 59 9b			call macro_forth_dsp_pop 
a946				endm 
# End of macro FORTH_DSP_POP
a946			 
a946					; Get value to add 
a946			 
a946					FORTH_DSP_VALUE 
a946 cd 8a 9a			call macro_forth_dsp_value 
a949				endm 
# End of macro FORTH_DSP_VALUE
a949			 
a949					if DEBUG_FORTH_WORDS 
a949						DMARK "+2v" 
a949 f5				push af  
a94a 3a 5e a9			ld a, (.dmark)  
a94d 32 7a ee			ld (debug_mark),a  
a950 3a 5f a9			ld a, (.dmark+1)  
a953 32 7b ee			ld (debug_mark+1),a  
a956 3a 60 a9			ld a, (.dmark+2)  
a959 32 7c ee			ld (debug_mark+2),a  
a95c 18 03			jr .pastdmark  
a95e ..			.dmark: db "+2v"  
a961 f1			.pastdmark: pop af  
a962			endm  
# End of macro DMARK
a962						CALLMONITOR 
a962 cd 1d 93			call break_point_state  
a965				endm  
# End of macro CALLMONITOR
a965					endif 
a965			 
a965 19					add hl, de 
a966			 
a966					if DEBUG_FORTH_WORDS 
a966						DMARK "+2+" 
a966 f5				push af  
a967 3a 7b a9			ld a, (.dmark)  
a96a 32 7a ee			ld (debug_mark),a  
a96d 3a 7c a9			ld a, (.dmark+1)  
a970 32 7b ee			ld (debug_mark+1),a  
a973 3a 7d a9			ld a, (.dmark+2)  
a976 32 7c ee			ld (debug_mark+2),a  
a979 18 03			jr .pastdmark  
a97b ..			.dmark: db "+2+"  
a97e f1			.pastdmark: pop af  
a97f			endm  
# End of macro DMARK
a97f						CALLMONITOR 
a97f cd 1d 93			call break_point_state  
a982				endm  
# End of macro CALLMONITOR
a982					endif 
a982			 
a982					; move result to de 
a982			 
a982 eb					ex de, hl 
a983			 
a983					; Address 
a983			 
a983 e1					pop hl 
a984			 
a984					; save it back 
a984			 
a984 73					ld (hl), e 
a985 23					inc hl 
a986 72					ld (hl), d 
a987			 
a987					if DEBUG_FORTH_WORDS 
a987						DMARK "+2e" 
a987 f5				push af  
a988 3a 9c a9			ld a, (.dmark)  
a98b 32 7a ee			ld (debug_mark),a  
a98e 3a 9d a9			ld a, (.dmark+1)  
a991 32 7b ee			ld (debug_mark+1),a  
a994 3a 9e a9			ld a, (.dmark+2)  
a997 32 7c ee			ld (debug_mark+2),a  
a99a 18 03			jr .pastdmark  
a99c ..			.dmark: db "+2e"  
a99f f1			.pastdmark: pop af  
a9a0			endm  
# End of macro DMARK
a9a0						CALLMONITOR 
a9a0 cd 1d 93			call break_point_state  
a9a3				endm  
# End of macro CALLMONITOR
a9a3					endif 
a9a3			 
a9a3			 
a9a3			 
a9a3			 
a9a3			 
a9a3				       NEXTW 
a9a3 c3 13 9c			jp macro_next 
a9a6				endm 
# End of macro NEXTW
a9a6			 
a9a6			.DEC2: 
a9a6				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
a9a6 6f				db WORD_SYS_CORE+91             
a9a7 52 aa			dw .GET2            
a9a9 04				db 3 + 1 
a9aa .. 00			db "-2!",0              
a9ae				endm 
# End of macro CWHEAD
a9ae			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
a9ae			 
a9ae			 
a9ae					if DEBUG_FORTH_WORDS_KEY 
a9ae						DMARK "-2s" 
a9ae f5				push af  
a9af 3a c3 a9			ld a, (.dmark)  
a9b2 32 7a ee			ld (debug_mark),a  
a9b5 3a c4 a9			ld a, (.dmark+1)  
a9b8 32 7b ee			ld (debug_mark+1),a  
a9bb 3a c5 a9			ld a, (.dmark+2)  
a9be 32 7c ee			ld (debug_mark+2),a  
a9c1 18 03			jr .pastdmark  
a9c3 ..			.dmark: db "-2s"  
a9c6 f1			.pastdmark: pop af  
a9c7			endm  
# End of macro DMARK
a9c7						CALLMONITOR 
a9c7 cd 1d 93			call break_point_state  
a9ca				endm  
# End of macro CALLMONITOR
a9ca					endif 
a9ca			 
a9ca					; Address 
a9ca			 
a9ca					FORTH_DSP_VALUEHL 
a9ca cd a1 9a			call macro_dsp_valuehl 
a9cd				endm 
# End of macro FORTH_DSP_VALUEHL
a9cd			 
a9cd e5					push hl    ; save address 
a9ce			 
a9ce					; load content into de 
a9ce			 
a9ce 5e					ld e,(hl) 
a9cf 23					inc hl 
a9d0 56					ld d, (hl) 
a9d1			 
a9d1					if DEBUG_FORTH_WORDS 
a9d1						DMARK "-2a" 
a9d1 f5				push af  
a9d2 3a e6 a9			ld a, (.dmark)  
a9d5 32 7a ee			ld (debug_mark),a  
a9d8 3a e7 a9			ld a, (.dmark+1)  
a9db 32 7b ee			ld (debug_mark+1),a  
a9de 3a e8 a9			ld a, (.dmark+2)  
a9e1 32 7c ee			ld (debug_mark+2),a  
a9e4 18 03			jr .pastdmark  
a9e6 ..			.dmark: db "-2a"  
a9e9 f1			.pastdmark: pop af  
a9ea			endm  
# End of macro DMARK
a9ea						CALLMONITOR 
a9ea cd 1d 93			call break_point_state  
a9ed				endm  
# End of macro CALLMONITOR
a9ed					endif 
a9ed			 
a9ed					FORTH_DSP_POP 
a9ed cd 59 9b			call macro_forth_dsp_pop 
a9f0				endm 
# End of macro FORTH_DSP_POP
a9f0			 
a9f0					; Get value to remove 
a9f0			 
a9f0					FORTH_DSP_VALUE 
a9f0 cd 8a 9a			call macro_forth_dsp_value 
a9f3				endm 
# End of macro FORTH_DSP_VALUE
a9f3			 
a9f3					if DEBUG_FORTH_WORDS 
a9f3						DMARK "-2v" 
a9f3 f5				push af  
a9f4 3a 08 aa			ld a, (.dmark)  
a9f7 32 7a ee			ld (debug_mark),a  
a9fa 3a 09 aa			ld a, (.dmark+1)  
a9fd 32 7b ee			ld (debug_mark+1),a  
aa00 3a 0a aa			ld a, (.dmark+2)  
aa03 32 7c ee			ld (debug_mark+2),a  
aa06 18 03			jr .pastdmark  
aa08 ..			.dmark: db "-2v"  
aa0b f1			.pastdmark: pop af  
aa0c			endm  
# End of macro DMARK
aa0c						CALLMONITOR 
aa0c cd 1d 93			call break_point_state  
aa0f				endm  
# End of macro CALLMONITOR
aa0f					endif 
aa0f			 
aa0f eb					ex de, hl 
aa10 ed 52				sbc hl, de 
aa12			 
aa12					if DEBUG_FORTH_WORDS 
aa12						DMARK "-2d" 
aa12 f5				push af  
aa13 3a 27 aa			ld a, (.dmark)  
aa16 32 7a ee			ld (debug_mark),a  
aa19 3a 28 aa			ld a, (.dmark+1)  
aa1c 32 7b ee			ld (debug_mark+1),a  
aa1f 3a 29 aa			ld a, (.dmark+2)  
aa22 32 7c ee			ld (debug_mark+2),a  
aa25 18 03			jr .pastdmark  
aa27 ..			.dmark: db "-2d"  
aa2a f1			.pastdmark: pop af  
aa2b			endm  
# End of macro DMARK
aa2b						CALLMONITOR 
aa2b cd 1d 93			call break_point_state  
aa2e				endm  
# End of macro CALLMONITOR
aa2e					endif 
aa2e			 
aa2e					; move result to de 
aa2e			 
aa2e eb					ex de, hl 
aa2f			 
aa2f					; Address 
aa2f			 
aa2f e1					pop hl 
aa30			 
aa30					; save it back 
aa30			 
aa30 73					ld (hl), e 
aa31 23					inc hl 
aa32 72					ld (hl), d 
aa33			 
aa33					if DEBUG_FORTH_WORDS 
aa33						DMARK "-2e" 
aa33 f5				push af  
aa34 3a 48 aa			ld a, (.dmark)  
aa37 32 7a ee			ld (debug_mark),a  
aa3a 3a 49 aa			ld a, (.dmark+1)  
aa3d 32 7b ee			ld (debug_mark+1),a  
aa40 3a 4a aa			ld a, (.dmark+2)  
aa43 32 7c ee			ld (debug_mark+2),a  
aa46 18 03			jr .pastdmark  
aa48 ..			.dmark: db "-2e"  
aa4b f1			.pastdmark: pop af  
aa4c			endm  
# End of macro DMARK
aa4c						CALLMONITOR 
aa4c cd 1d 93			call break_point_state  
aa4f				endm  
# End of macro CALLMONITOR
aa4f					endif 
aa4f			 
aa4f			 
aa4f			 
aa4f			 
aa4f			 
aa4f				       NEXTW 
aa4f c3 13 9c			jp macro_next 
aa52				endm 
# End of macro NEXTW
aa52			.GET2: 
aa52				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
aa52 6f				db WORD_SYS_CORE+91             
aa53 82 aa			dw .BANG2            
aa55 03				db 2 + 1 
aa56 .. 00			db "2@",0              
aa59				endm 
# End of macro CWHEAD
aa59			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
aa59					if DEBUG_FORTH_WORDS_KEY 
aa59						DMARK "2A_" 
aa59 f5				push af  
aa5a 3a 6e aa			ld a, (.dmark)  
aa5d 32 7a ee			ld (debug_mark),a  
aa60 3a 6f aa			ld a, (.dmark+1)  
aa63 32 7b ee			ld (debug_mark+1),a  
aa66 3a 70 aa			ld a, (.dmark+2)  
aa69 32 7c ee			ld (debug_mark+2),a  
aa6c 18 03			jr .pastdmark  
aa6e ..			.dmark: db "2A_"  
aa71 f1			.pastdmark: pop af  
aa72			endm  
# End of macro DMARK
aa72						CALLMONITOR 
aa72 cd 1d 93			call break_point_state  
aa75				endm  
# End of macro CALLMONITOR
aa75					endif 
aa75			 
aa75					FORTH_DSP_VALUEHL 
aa75 cd a1 9a			call macro_dsp_valuehl 
aa78				endm 
# End of macro FORTH_DSP_VALUEHL
aa78			 
aa78 5e					ld e, (hl) 
aa79 23					inc hl 
aa7a 56					ld d, (hl) 
aa7b			 
aa7b eb					ex de, hl 
aa7c			 
aa7c cd aa 98				call forth_push_numhl 
aa7f			 
aa7f				       NEXTW 
aa7f c3 13 9c			jp macro_next 
aa82				endm 
# End of macro NEXTW
aa82			.BANG2: 
aa82				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
aa82 6f				db WORD_SYS_CORE+91             
aa83 ba aa			dw .CONFIG            
aa85 03				db 2 + 1 
aa86 .. 00			db "2!",0              
aa89				endm 
# End of macro CWHEAD
aa89			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
aa89					if DEBUG_FORTH_WORDS_KEY 
aa89						DMARK "2S_" 
aa89 f5				push af  
aa8a 3a 9e aa			ld a, (.dmark)  
aa8d 32 7a ee			ld (debug_mark),a  
aa90 3a 9f aa			ld a, (.dmark+1)  
aa93 32 7b ee			ld (debug_mark+1),a  
aa96 3a a0 aa			ld a, (.dmark+2)  
aa99 32 7c ee			ld (debug_mark+2),a  
aa9c 18 03			jr .pastdmark  
aa9e ..			.dmark: db "2S_"  
aaa1 f1			.pastdmark: pop af  
aaa2			endm  
# End of macro DMARK
aaa2						CALLMONITOR 
aaa2 cd 1d 93			call break_point_state  
aaa5				endm  
# End of macro CALLMONITOR
aaa5					endif 
aaa5			 
aaa5					FORTH_DSP_VALUEHL 
aaa5 cd a1 9a			call macro_dsp_valuehl 
aaa8				endm 
# End of macro FORTH_DSP_VALUEHL
aaa8			 
aaa8 e5					push hl   ; save address 
aaa9			 
aaa9			 
aaa9					FORTH_DSP_POP 
aaa9 cd 59 9b			call macro_forth_dsp_pop 
aaac				endm 
# End of macro FORTH_DSP_POP
aaac			 
aaac					 
aaac					FORTH_DSP_VALUEHL 
aaac cd a1 9a			call macro_dsp_valuehl 
aaaf				endm 
# End of macro FORTH_DSP_VALUEHL
aaaf			 
aaaf					FORTH_DSP_POP 
aaaf cd 59 9b			call macro_forth_dsp_pop 
aab2				endm 
# End of macro FORTH_DSP_POP
aab2			 
aab2 eb					ex de, hl    ; value now in de 
aab3			 
aab3 e1					pop hl 
aab4			 
aab4 73					ld (hl), e 
aab5			 
aab5 23					inc hl 
aab6			 
aab6 72					ld (hl), d 
aab7			 
aab7			 
aab7				       NEXTW 
aab7 c3 13 9c			jp macro_next 
aaba				endm 
# End of macro NEXTW
aaba			.CONFIG: 
aaba				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
aaba 6f				db WORD_SYS_CORE+91             
aabb cb aa			dw .ENDCORE            
aabd 07				db 6 + 1 
aabe .. 00			db "CONFIG",0              
aac5				endm 
# End of macro CWHEAD
aac5			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
aac5			 
aac5 cd 0a 91				call config 
aac8					NEXTW 
aac8 c3 13 9c			jp macro_next 
aacb				endm 
# End of macro NEXTW
aacb			.ENDCORE: 
aacb			 
aacb			; eof 
aacb			 
aacb			 
# End of file forth_words_core.asm
aacb			include "forth_words_flow.asm" 
aacb			 
aacb			; | ## Program Flow Words 
aacb			 
aacb			.IF: 
aacb				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
aacb 1e				db WORD_SYS_CORE+10             
aacc c0 ab			dw .THEN            
aace 03				db 2 + 1 
aacf .. 00			db "IF",0              
aad2				endm 
# End of macro CWHEAD
aad2			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
aad2			; 
aad2					if DEBUG_FORTH_WORDS_KEY 
aad2						DMARK "IF." 
aad2 f5				push af  
aad3 3a e7 aa			ld a, (.dmark)  
aad6 32 7a ee			ld (debug_mark),a  
aad9 3a e8 aa			ld a, (.dmark+1)  
aadc 32 7b ee			ld (debug_mark+1),a  
aadf 3a e9 aa			ld a, (.dmark+2)  
aae2 32 7c ee			ld (debug_mark+2),a  
aae5 18 03			jr .pastdmark  
aae7 ..			.dmark: db "IF."  
aaea f1			.pastdmark: pop af  
aaeb			endm  
# End of macro DMARK
aaeb						CALLMONITOR 
aaeb cd 1d 93			call break_point_state  
aaee				endm  
# End of macro CALLMONITOR
aaee					endif 
aaee			; eval TOS 
aaee			 
aaee				FORTH_DSP_VALUEHL 
aaee cd a1 9a			call macro_dsp_valuehl 
aaf1				endm 
# End of macro FORTH_DSP_VALUEHL
aaf1			 
aaf1			;	push hl 
aaf1				FORTH_DSP_POP 
aaf1 cd 59 9b			call macro_forth_dsp_pop 
aaf4				endm 
# End of macro FORTH_DSP_POP
aaf4			;	pop hl 
aaf4			 
aaf4					if DEBUG_FORTH_WORDS 
aaf4						DMARK "IF1" 
aaf4 f5				push af  
aaf5 3a 09 ab			ld a, (.dmark)  
aaf8 32 7a ee			ld (debug_mark),a  
aafb 3a 0a ab			ld a, (.dmark+1)  
aafe 32 7b ee			ld (debug_mark+1),a  
ab01 3a 0b ab			ld a, (.dmark+2)  
ab04 32 7c ee			ld (debug_mark+2),a  
ab07 18 03			jr .pastdmark  
ab09 ..			.dmark: db "IF1"  
ab0c f1			.pastdmark: pop af  
ab0d			endm  
# End of macro DMARK
ab0d						CALLMONITOR 
ab0d cd 1d 93			call break_point_state  
ab10				endm  
# End of macro CALLMONITOR
ab10					endif 
ab10 b7				or a        ; clear carry flag 
ab11 11 00 00			ld de, 0 
ab14 eb				ex de,hl 
ab15 ed 52			sbc hl, de 
ab17 c2 a1 ab			jp nz, .iftrue 
ab1a			 
ab1a					if DEBUG_FORTH_WORDS 
ab1a						DMARK "IF2" 
ab1a f5				push af  
ab1b 3a 2f ab			ld a, (.dmark)  
ab1e 32 7a ee			ld (debug_mark),a  
ab21 3a 30 ab			ld a, (.dmark+1)  
ab24 32 7b ee			ld (debug_mark+1),a  
ab27 3a 31 ab			ld a, (.dmark+2)  
ab2a 32 7c ee			ld (debug_mark+2),a  
ab2d 18 03			jr .pastdmark  
ab2f ..			.dmark: db "IF2"  
ab32 f1			.pastdmark: pop af  
ab33			endm  
# End of macro DMARK
ab33						CALLMONITOR 
ab33 cd 1d 93			call break_point_state  
ab36				endm  
# End of macro CALLMONITOR
ab36					endif 
ab36			 
ab36			; if not true then skip to THEN 
ab36			 
ab36				; TODO get tok_ptr 
ab36				; TODO consume toks until we get to THEN 
ab36			 
ab36 2a 61 e6			ld hl, (os_tok_ptr) 
ab39					if DEBUG_FORTH_WORDS 
ab39						DMARK "IF3" 
ab39 f5				push af  
ab3a 3a 4e ab			ld a, (.dmark)  
ab3d 32 7a ee			ld (debug_mark),a  
ab40 3a 4f ab			ld a, (.dmark+1)  
ab43 32 7b ee			ld (debug_mark+1),a  
ab46 3a 50 ab			ld a, (.dmark+2)  
ab49 32 7c ee			ld (debug_mark+2),a  
ab4c 18 03			jr .pastdmark  
ab4e ..			.dmark: db "IF3"  
ab51 f1			.pastdmark: pop af  
ab52			endm  
# End of macro DMARK
ab52						CALLMONITOR 
ab52 cd 1d 93			call break_point_state  
ab55				endm  
# End of macro CALLMONITOR
ab55						 
ab55					endif 
ab55 11 9c ab			ld de, .ifthen 
ab58					if DEBUG_FORTH_WORDS 
ab58						DMARK "IF4" 
ab58 f5				push af  
ab59 3a 6d ab			ld a, (.dmark)  
ab5c 32 7a ee			ld (debug_mark),a  
ab5f 3a 6e ab			ld a, (.dmark+1)  
ab62 32 7b ee			ld (debug_mark+1),a  
ab65 3a 6f ab			ld a, (.dmark+2)  
ab68 32 7c ee			ld (debug_mark+2),a  
ab6b 18 03			jr .pastdmark  
ab6d ..			.dmark: db "IF4"  
ab70 f1			.pastdmark: pop af  
ab71			endm  
# End of macro DMARK
ab71						CALLMONITOR 
ab71 cd 1d 93			call break_point_state  
ab74				endm  
# End of macro CALLMONITOR
ab74					endif 
ab74 cd 2e 9d			call findnexttok  
ab77			 
ab77					if DEBUG_FORTH_WORDS 
ab77						DMARK "IF5" 
ab77 f5				push af  
ab78 3a 8c ab			ld a, (.dmark)  
ab7b 32 7a ee			ld (debug_mark),a  
ab7e 3a 8d ab			ld a, (.dmark+1)  
ab81 32 7b ee			ld (debug_mark+1),a  
ab84 3a 8e ab			ld a, (.dmark+2)  
ab87 32 7c ee			ld (debug_mark+2),a  
ab8a 18 03			jr .pastdmark  
ab8c ..			.dmark: db "IF5"  
ab8f f1			.pastdmark: pop af  
ab90			endm  
# End of macro DMARK
ab90						CALLMONITOR 
ab90 cd 1d 93			call break_point_state  
ab93				endm  
# End of macro CALLMONITOR
ab93					endif 
ab93				; TODO replace below with ; exec using tok_ptr 
ab93 22 61 e6			ld (os_tok_ptr), hl 
ab96 c3 a4 9c			jp exec1 
ab99				NEXTW 
ab99 c3 13 9c			jp macro_next 
ab9c				endm 
# End of macro NEXTW
ab9c			 
ab9c .. 00		.ifthen:  db "THEN",0 
aba1			 
aba1			.iftrue:		 
aba1				; Exec next words normally 
aba1			 
aba1				; if true then exec following IF as normal 
aba1					if DEBUG_FORTH_WORDS 
aba1						DMARK "IFT" 
aba1 f5				push af  
aba2 3a b6 ab			ld a, (.dmark)  
aba5 32 7a ee			ld (debug_mark),a  
aba8 3a b7 ab			ld a, (.dmark+1)  
abab 32 7b ee			ld (debug_mark+1),a  
abae 3a b8 ab			ld a, (.dmark+2)  
abb1 32 7c ee			ld (debug_mark+2),a  
abb4 18 03			jr .pastdmark  
abb6 ..			.dmark: db "IFT"  
abb9 f1			.pastdmark: pop af  
abba			endm  
# End of macro DMARK
abba						CALLMONITOR 
abba cd 1d 93			call break_point_state  
abbd				endm  
# End of macro CALLMONITOR
abbd					endif 
abbd			 
abbd					NEXTW 
abbd c3 13 9c			jp macro_next 
abc0				endm 
# End of macro NEXTW
abc0			.THEN: 
abc0				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
abc0 1f				db WORD_SYS_CORE+11             
abc1 e8 ab			dw .ELSE            
abc3 05				db 4 + 1 
abc4 .. 00			db "THEN",0              
abc9				endm 
# End of macro CWHEAD
abc9			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
abc9					if DEBUG_FORTH_WORDS_KEY 
abc9						DMARK "THN" 
abc9 f5				push af  
abca 3a de ab			ld a, (.dmark)  
abcd 32 7a ee			ld (debug_mark),a  
abd0 3a df ab			ld a, (.dmark+1)  
abd3 32 7b ee			ld (debug_mark+1),a  
abd6 3a e0 ab			ld a, (.dmark+2)  
abd9 32 7c ee			ld (debug_mark+2),a  
abdc 18 03			jr .pastdmark  
abde ..			.dmark: db "THN"  
abe1 f1			.pastdmark: pop af  
abe2			endm  
# End of macro DMARK
abe2						CALLMONITOR 
abe2 cd 1d 93			call break_point_state  
abe5				endm  
# End of macro CALLMONITOR
abe5					endif 
abe5					NEXTW 
abe5 c3 13 9c			jp macro_next 
abe8				endm 
# End of macro NEXTW
abe8			.ELSE: 
abe8				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
abe8 20				db WORD_SYS_CORE+12             
abe9 10 ac			dw .DO            
abeb 03				db 2 + 1 
abec .. 00			db "ELSE",0              
abf1				endm 
# End of macro CWHEAD
abf1			; | ELSE ( -- ) Not supported - does nothing | TODO 
abf1			 
abf1					if DEBUG_FORTH_WORDS_KEY 
abf1						DMARK "ELS" 
abf1 f5				push af  
abf2 3a 06 ac			ld a, (.dmark)  
abf5 32 7a ee			ld (debug_mark),a  
abf8 3a 07 ac			ld a, (.dmark+1)  
abfb 32 7b ee			ld (debug_mark+1),a  
abfe 3a 08 ac			ld a, (.dmark+2)  
ac01 32 7c ee			ld (debug_mark+2),a  
ac04 18 03			jr .pastdmark  
ac06 ..			.dmark: db "ELS"  
ac09 f1			.pastdmark: pop af  
ac0a			endm  
# End of macro DMARK
ac0a						CALLMONITOR 
ac0a cd 1d 93			call break_point_state  
ac0d				endm  
# End of macro CALLMONITOR
ac0d					endif 
ac0d			 
ac0d			 
ac0d					NEXTW 
ac0d c3 13 9c			jp macro_next 
ac10				endm 
# End of macro NEXTW
ac10			.DO: 
ac10				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
ac10 21				db WORD_SYS_CORE+13             
ac11 37 ad			dw .LOOP            
ac13 03				db 2 + 1 
ac14 .. 00			db "DO",0              
ac17				endm 
# End of macro CWHEAD
ac17			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
ac17			 
ac17					if DEBUG_FORTH_WORDS_KEY 
ac17						DMARK "DO." 
ac17 f5				push af  
ac18 3a 2c ac			ld a, (.dmark)  
ac1b 32 7a ee			ld (debug_mark),a  
ac1e 3a 2d ac			ld a, (.dmark+1)  
ac21 32 7b ee			ld (debug_mark+1),a  
ac24 3a 2e ac			ld a, (.dmark+2)  
ac27 32 7c ee			ld (debug_mark+2),a  
ac2a 18 03			jr .pastdmark  
ac2c ..			.dmark: db "DO."  
ac2f f1			.pastdmark: pop af  
ac30			endm  
# End of macro DMARK
ac30						CALLMONITOR 
ac30 cd 1d 93			call break_point_state  
ac33				endm  
# End of macro CALLMONITOR
ac33					endif 
ac33			;  push pc to rsp stack past the DO 
ac33			 
ac33 2a 61 e6				ld hl, (os_tok_ptr) 
ac36 23					inc hl   ; D 
ac37 23					inc hl  ; O 
ac38 23					inc hl   ; null 
ac39					if DEBUG_FORTH_WORDS 
ac39						DMARK "DO2" 
ac39 f5				push af  
ac3a 3a 4e ac			ld a, (.dmark)  
ac3d 32 7a ee			ld (debug_mark),a  
ac40 3a 4f ac			ld a, (.dmark+1)  
ac43 32 7b ee			ld (debug_mark+1),a  
ac46 3a 50 ac			ld a, (.dmark+2)  
ac49 32 7c ee			ld (debug_mark+2),a  
ac4c 18 03			jr .pastdmark  
ac4e ..			.dmark: db "DO2"  
ac51 f1			.pastdmark: pop af  
ac52			endm  
# End of macro DMARK
ac52						CALLMONITOR 
ac52 cd 1d 93			call break_point_state  
ac55				endm  
# End of macro CALLMONITOR
ac55					endif 
ac55					FORTH_RSP_NEXT 
ac55 cd 51 98			call macro_forth_rsp_next 
ac58				endm 
# End of macro FORTH_RSP_NEXT
ac58					if DEBUG_FORTH_WORDS 
ac58						DMARK "DO3" 
ac58 f5				push af  
ac59 3a 6d ac			ld a, (.dmark)  
ac5c 32 7a ee			ld (debug_mark),a  
ac5f 3a 6e ac			ld a, (.dmark+1)  
ac62 32 7b ee			ld (debug_mark+1),a  
ac65 3a 6f ac			ld a, (.dmark+2)  
ac68 32 7c ee			ld (debug_mark+2),a  
ac6b 18 03			jr .pastdmark  
ac6d ..			.dmark: db "DO3"  
ac70 f1			.pastdmark: pop af  
ac71			endm  
# End of macro DMARK
ac71						CALLMONITOR 
ac71 cd 1d 93			call break_point_state  
ac74				endm  
# End of macro CALLMONITOR
ac74					endif 
ac74			 
ac74					;if DEBUG_FORTH_WORDS 
ac74				;		push hl 
ac74			;		endif  
ac74			 
ac74			; get counters from data stack 
ac74			 
ac74			 
ac74					FORTH_DSP_VALUEHL 
ac74 cd a1 9a			call macro_dsp_valuehl 
ac77				endm 
# End of macro FORTH_DSP_VALUEHL
ac77 e5					push hl		 ; hl now has starting counter which needs to be tos 
ac78			 
ac78					if DEBUG_FORTH_WORDS 
ac78						DMARK "DO4" 
ac78 f5				push af  
ac79 3a 8d ac			ld a, (.dmark)  
ac7c 32 7a ee			ld (debug_mark),a  
ac7f 3a 8e ac			ld a, (.dmark+1)  
ac82 32 7b ee			ld (debug_mark+1),a  
ac85 3a 8f ac			ld a, (.dmark+2)  
ac88 32 7c ee			ld (debug_mark+2),a  
ac8b 18 03			jr .pastdmark  
ac8d ..			.dmark: db "DO4"  
ac90 f1			.pastdmark: pop af  
ac91			endm  
# End of macro DMARK
ac91						CALLMONITOR 
ac91 cd 1d 93			call break_point_state  
ac94				endm  
# End of macro CALLMONITOR
ac94					endif 
ac94					FORTH_DSP_POP 
ac94 cd 59 9b			call macro_forth_dsp_pop 
ac97				endm 
# End of macro FORTH_DSP_POP
ac97			 
ac97					if DEBUG_FORTH_WORDS 
ac97						DMARK "DO5" 
ac97 f5				push af  
ac98 3a ac ac			ld a, (.dmark)  
ac9b 32 7a ee			ld (debug_mark),a  
ac9e 3a ad ac			ld a, (.dmark+1)  
aca1 32 7b ee			ld (debug_mark+1),a  
aca4 3a ae ac			ld a, (.dmark+2)  
aca7 32 7c ee			ld (debug_mark+2),a  
acaa 18 03			jr .pastdmark  
acac ..			.dmark: db "DO5"  
acaf f1			.pastdmark: pop af  
acb0			endm  
# End of macro DMARK
acb0						CALLMONITOR 
acb0 cd 1d 93			call break_point_state  
acb3				endm  
# End of macro CALLMONITOR
acb3					endif 
acb3			 
acb3					FORTH_DSP_VALUEHL 
acb3 cd a1 9a			call macro_dsp_valuehl 
acb6				endm 
# End of macro FORTH_DSP_VALUEHL
acb6			;		push hl		 ; hl now has starting limit counter 
acb6			 
acb6					if DEBUG_FORTH_WORDS 
acb6						DMARK "DO6" 
acb6 f5				push af  
acb7 3a cb ac			ld a, (.dmark)  
acba 32 7a ee			ld (debug_mark),a  
acbd 3a cc ac			ld a, (.dmark+1)  
acc0 32 7b ee			ld (debug_mark+1),a  
acc3 3a cd ac			ld a, (.dmark+2)  
acc6 32 7c ee			ld (debug_mark+2),a  
acc9 18 03			jr .pastdmark  
accb ..			.dmark: db "DO6"  
acce f1			.pastdmark: pop af  
accf			endm  
# End of macro DMARK
accf						CALLMONITOR 
accf cd 1d 93			call break_point_state  
acd2				endm  
# End of macro CALLMONITOR
acd2					endif 
acd2					FORTH_DSP_POP 
acd2 cd 59 9b			call macro_forth_dsp_pop 
acd5				endm 
# End of macro FORTH_DSP_POP
acd5			 
acd5			; put counters on the loop stack 
acd5			 
acd5			;		pop hl			 ; limit counter 
acd5 d1					pop de			; start counter 
acd6			 
acd6					; push limit counter 
acd6			 
acd6					if DEBUG_FORTH_WORDS 
acd6						DMARK "DO7" 
acd6 f5				push af  
acd7 3a eb ac			ld a, (.dmark)  
acda 32 7a ee			ld (debug_mark),a  
acdd 3a ec ac			ld a, (.dmark+1)  
ace0 32 7b ee			ld (debug_mark+1),a  
ace3 3a ed ac			ld a, (.dmark+2)  
ace6 32 7c ee			ld (debug_mark+2),a  
ace9 18 03			jr .pastdmark  
aceb ..			.dmark: db "DO7"  
acee f1			.pastdmark: pop af  
acef			endm  
# End of macro DMARK
acef						CALLMONITOR 
acef cd 1d 93			call break_point_state  
acf2				endm  
# End of macro CALLMONITOR
acf2					endif 
acf2					FORTH_LOOP_NEXT 
acf2 cd d2 9a			call macro_forth_loop_next 
acf5				endm 
# End of macro FORTH_LOOP_NEXT
acf5			 
acf5					; push start counter 
acf5			 
acf5 eb					ex de, hl 
acf6					if DEBUG_FORTH_WORDS 
acf6						DMARK "DO7" 
acf6 f5				push af  
acf7 3a 0b ad			ld a, (.dmark)  
acfa 32 7a ee			ld (debug_mark),a  
acfd 3a 0c ad			ld a, (.dmark+1)  
ad00 32 7b ee			ld (debug_mark+1),a  
ad03 3a 0d ad			ld a, (.dmark+2)  
ad06 32 7c ee			ld (debug_mark+2),a  
ad09 18 03			jr .pastdmark  
ad0b ..			.dmark: db "DO7"  
ad0e f1			.pastdmark: pop af  
ad0f			endm  
# End of macro DMARK
ad0f						CALLMONITOR 
ad0f cd 1d 93			call break_point_state  
ad12				endm  
# End of macro CALLMONITOR
ad12					endif 
ad12					FORTH_LOOP_NEXT 
ad12 cd d2 9a			call macro_forth_loop_next 
ad15				endm 
# End of macro FORTH_LOOP_NEXT
ad15			 
ad15			 
ad15					; init first round of I counter 
ad15			 
ad15 22 85 e6				ld (os_current_i), hl 
ad18			 
ad18					if DEBUG_FORTH_WORDS 
ad18						DMARK "DO8" 
ad18 f5				push af  
ad19 3a 2d ad			ld a, (.dmark)  
ad1c 32 7a ee			ld (debug_mark),a  
ad1f 3a 2e ad			ld a, (.dmark+1)  
ad22 32 7b ee			ld (debug_mark+1),a  
ad25 3a 2f ad			ld a, (.dmark+2)  
ad28 32 7c ee			ld (debug_mark+2),a  
ad2b 18 03			jr .pastdmark  
ad2d ..			.dmark: db "DO8"  
ad30 f1			.pastdmark: pop af  
ad31			endm  
# End of macro DMARK
ad31						CALLMONITOR 
ad31 cd 1d 93			call break_point_state  
ad34				endm  
# End of macro CALLMONITOR
ad34					endif 
ad34			 
ad34					NEXTW 
ad34 c3 13 9c			jp macro_next 
ad37				endm 
# End of macro NEXTW
ad37			.LOOP: 
ad37				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
ad37 22				db WORD_SYS_CORE+14             
ad38 4f ae			dw .I            
ad3a 05				db 4 + 1 
ad3b .. 00			db "LOOP",0              
ad40				endm 
# End of macro CWHEAD
ad40			; | LOOP ( -- ) Increment and test loop counter  | DONE 
ad40			 
ad40				; pop tos as current loop count to hl 
ad40			 
ad40				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
ad40			 
ad40				FORTH_LOOP_TOS 
ad40 cd 05 9b			call macro_forth_loop_tos 
ad43				endm 
# End of macro FORTH_LOOP_TOS
ad43 e5				push hl 
ad44			 
ad44					if DEBUG_FORTH_WORDS_KEY 
ad44						DMARK "LOP" 
ad44 f5				push af  
ad45 3a 59 ad			ld a, (.dmark)  
ad48 32 7a ee			ld (debug_mark),a  
ad4b 3a 5a ad			ld a, (.dmark+1)  
ad4e 32 7b ee			ld (debug_mark+1),a  
ad51 3a 5b ad			ld a, (.dmark+2)  
ad54 32 7c ee			ld (debug_mark+2),a  
ad57 18 03			jr .pastdmark  
ad59 ..			.dmark: db "LOP"  
ad5c f1			.pastdmark: pop af  
ad5d			endm  
# End of macro DMARK
ad5d						CALLMONITOR 
ad5d cd 1d 93			call break_point_state  
ad60				endm  
# End of macro CALLMONITOR
ad60					endif 
ad60				; next item on the stack is the limit. get it 
ad60			 
ad60			 
ad60				FORTH_LOOP_POP 
ad60 cd 0f 9b			call macro_forth_loop_pop 
ad63				endm 
# End of macro FORTH_LOOP_POP
ad63			 
ad63				FORTH_LOOP_TOS 
ad63 cd 05 9b			call macro_forth_loop_tos 
ad66				endm 
# End of macro FORTH_LOOP_TOS
ad66			 
ad66 d1				pop de		 ; de = i, hl = limit 
ad67			 
ad67					if DEBUG_FORTH_WORDS 
ad67						DMARK "LP1" 
ad67 f5				push af  
ad68 3a 7c ad			ld a, (.dmark)  
ad6b 32 7a ee			ld (debug_mark),a  
ad6e 3a 7d ad			ld a, (.dmark+1)  
ad71 32 7b ee			ld (debug_mark+1),a  
ad74 3a 7e ad			ld a, (.dmark+2)  
ad77 32 7c ee			ld (debug_mark+2),a  
ad7a 18 03			jr .pastdmark  
ad7c ..			.dmark: db "LP1"  
ad7f f1			.pastdmark: pop af  
ad80			endm  
# End of macro DMARK
ad80						CALLMONITOR 
ad80 cd 1d 93			call break_point_state  
ad83				endm  
# End of macro CALLMONITOR
ad83					endif 
ad83			 
ad83				; go back to previous word 
ad83			 
ad83 d5				push de    ; save I for inc later 
ad84			 
ad84			 
ad84				; get limit 
ad84				;  is I at limit? 
ad84			 
ad84			 
ad84					if DEBUG_FORTH_WORDS 
ad84						DMARK "LP1" 
ad84 f5				push af  
ad85 3a 99 ad			ld a, (.dmark)  
ad88 32 7a ee			ld (debug_mark),a  
ad8b 3a 9a ad			ld a, (.dmark+1)  
ad8e 32 7b ee			ld (debug_mark+1),a  
ad91 3a 9b ad			ld a, (.dmark+2)  
ad94 32 7c ee			ld (debug_mark+2),a  
ad97 18 03			jr .pastdmark  
ad99 ..			.dmark: db "LP1"  
ad9c f1			.pastdmark: pop af  
ad9d			endm  
# End of macro DMARK
ad9d						CALLMONITOR 
ad9d cd 1d 93			call break_point_state  
ada0				endm  
# End of macro CALLMONITOR
ada0					endif 
ada0			 
ada0 ed 52			sbc hl, de 
ada2			 
ada2			 
ada2				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
ada2			 
ada2 20 26				jr nz, .loopnotdone 
ada4			 
ada4 e1				pop hl   ; get rid of saved I 
ada5				FORTH_LOOP_POP     ; get rid of limit 
ada5 cd 0f 9b			call macro_forth_loop_pop 
ada8				endm 
# End of macro FORTH_LOOP_POP
ada8			 
ada8				FORTH_RSP_POP     ; get rid of DO ptr 
ada8 cd 72 98			call macro_forth_rsp_pop 
adab				endm 
# End of macro FORTH_RSP_POP
adab			 
adab			if DEBUG_FORTH_WORDS 
adab						DMARK "LP>" 
adab f5				push af  
adac 3a c0 ad			ld a, (.dmark)  
adaf 32 7a ee			ld (debug_mark),a  
adb2 3a c1 ad			ld a, (.dmark+1)  
adb5 32 7b ee			ld (debug_mark+1),a  
adb8 3a c2 ad			ld a, (.dmark+2)  
adbb 32 7c ee			ld (debug_mark+2),a  
adbe 18 03			jr .pastdmark  
adc0 ..			.dmark: db "LP>"  
adc3 f1			.pastdmark: pop af  
adc4			endm  
# End of macro DMARK
adc4				CALLMONITOR 
adc4 cd 1d 93			call break_point_state  
adc7				endm  
# End of macro CALLMONITOR
adc7			endif 
adc7			 
adc7					NEXTW 
adc7 c3 13 9c			jp macro_next 
adca				endm 
# End of macro NEXTW
adca				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
adca			 
adca			.loopnotdone: 
adca			 
adca e1				pop hl    ; get I 
adcb 23				inc hl 
adcc			 
adcc			   	; save new I 
adcc			 
adcc			 
adcc					; set I counter 
adcc			 
adcc 22 85 e6				ld (os_current_i), hl 
adcf			 
adcf					if DEBUG_FORTH_WORDS 
adcf						DMARK "LPN" 
adcf f5				push af  
add0 3a e4 ad			ld a, (.dmark)  
add3 32 7a ee			ld (debug_mark),a  
add6 3a e5 ad			ld a, (.dmark+1)  
add9 32 7b ee			ld (debug_mark+1),a  
addc 3a e6 ad			ld a, (.dmark+2)  
addf 32 7c ee			ld (debug_mark+2),a  
ade2 18 03			jr .pastdmark  
ade4 ..			.dmark: db "LPN"  
ade7 f1			.pastdmark: pop af  
ade8			endm  
# End of macro DMARK
ade8					CALLMONITOR 
ade8 cd 1d 93			call break_point_state  
adeb				endm  
# End of macro CALLMONITOR
adeb					endif 
adeb					 
adeb				FORTH_LOOP_NEXT 
adeb cd d2 9a			call macro_forth_loop_next 
adee				endm 
# End of macro FORTH_LOOP_NEXT
adee			 
adee			 
adee					if DEBUG_FORTH_WORDS 
adee eb						ex de,hl 
adef					endif 
adef			 
adef			;	; get DO ptr 
adef			; 
adef					if DEBUG_FORTH_WORDS 
adef						DMARK "LP7" 
adef f5				push af  
adf0 3a 04 ae			ld a, (.dmark)  
adf3 32 7a ee			ld (debug_mark),a  
adf6 3a 05 ae			ld a, (.dmark+1)  
adf9 32 7b ee			ld (debug_mark+1),a  
adfc 3a 06 ae			ld a, (.dmark+2)  
adff 32 7c ee			ld (debug_mark+2),a  
ae02 18 03			jr .pastdmark  
ae04 ..			.dmark: db "LP7"  
ae07 f1			.pastdmark: pop af  
ae08			endm  
# End of macro DMARK
ae08					CALLMONITOR 
ae08 cd 1d 93			call break_point_state  
ae0b				endm  
# End of macro CALLMONITOR
ae0b					endif 
ae0b				FORTH_RSP_TOS 
ae0b cd 68 98			call macro_forth_rsp_tos 
ae0e				endm 
# End of macro FORTH_RSP_TOS
ae0e			 
ae0e					if DEBUG_FORTH_WORDS 
ae0e						DMARK "LP8" 
ae0e f5				push af  
ae0f 3a 23 ae			ld a, (.dmark)  
ae12 32 7a ee			ld (debug_mark),a  
ae15 3a 24 ae			ld a, (.dmark+1)  
ae18 32 7b ee			ld (debug_mark+1),a  
ae1b 3a 25 ae			ld a, (.dmark+2)  
ae1e 32 7c ee			ld (debug_mark+2),a  
ae21 18 03			jr .pastdmark  
ae23 ..			.dmark: db "LP8"  
ae26 f1			.pastdmark: pop af  
ae27			endm  
# End of macro DMARK
ae27					CALLMONITOR 
ae27 cd 1d 93			call break_point_state  
ae2a				endm  
# End of macro CALLMONITOR
ae2a					endif 
ae2a				;push hl 
ae2a			 
ae2a				; not going to DO any more 
ae2a				; get rid of the RSP pointer as DO will add it back in 
ae2a				;FORTH_RSP_POP 
ae2a				;pop hl 
ae2a			 
ae2a				;ld hl,(cli_ret_sp) 
ae2a				;ld e, (hl) 
ae2a				;inc hl 
ae2a				;ld d, (hl) 
ae2a				;ex de,hl 
ae2a 22 61 e6			ld (os_tok_ptr), hl 
ae2d					if DEBUG_FORTH_WORDS 
ae2d						DMARK "LP<" 
ae2d f5				push af  
ae2e 3a 42 ae			ld a, (.dmark)  
ae31 32 7a ee			ld (debug_mark),a  
ae34 3a 43 ae			ld a, (.dmark+1)  
ae37 32 7b ee			ld (debug_mark+1),a  
ae3a 3a 44 ae			ld a, (.dmark+2)  
ae3d 32 7c ee			ld (debug_mark+2),a  
ae40 18 03			jr .pastdmark  
ae42 ..			.dmark: db "LP<"  
ae45 f1			.pastdmark: pop af  
ae46			endm  
# End of macro DMARK
ae46					CALLMONITOR 
ae46 cd 1d 93			call break_point_state  
ae49				endm  
# End of macro CALLMONITOR
ae49				endif 
ae49 c3 a4 9c			jp exec1 
ae4c			 
ae4c					 
ae4c			 
ae4c			 
ae4c					NEXTW 
ae4c c3 13 9c			jp macro_next 
ae4f				endm 
# End of macro NEXTW
ae4f			.I:  
ae4f			 
ae4f				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
ae4f 5e				db WORD_SYS_CORE+74             
ae50 7a ae			dw .DLOOP            
ae52 02				db 1 + 1 
ae53 .. 00			db "I",0              
ae55				endm 
# End of macro CWHEAD
ae55			; | I ( -- ) Current loop counter | DONE 
ae55					if DEBUG_FORTH_WORDS_KEY 
ae55						DMARK "I.." 
ae55 f5				push af  
ae56 3a 6a ae			ld a, (.dmark)  
ae59 32 7a ee			ld (debug_mark),a  
ae5c 3a 6b ae			ld a, (.dmark+1)  
ae5f 32 7b ee			ld (debug_mark+1),a  
ae62 3a 6c ae			ld a, (.dmark+2)  
ae65 32 7c ee			ld (debug_mark+2),a  
ae68 18 03			jr .pastdmark  
ae6a ..			.dmark: db "I.."  
ae6d f1			.pastdmark: pop af  
ae6e			endm  
# End of macro DMARK
ae6e						CALLMONITOR 
ae6e cd 1d 93			call break_point_state  
ae71				endm  
# End of macro CALLMONITOR
ae71					endif 
ae71			 
ae71 2a 85 e6				ld hl,(os_current_i) 
ae74 cd aa 98				call forth_push_numhl 
ae77			 
ae77					NEXTW 
ae77 c3 13 9c			jp macro_next 
ae7a				endm 
# End of macro NEXTW
ae7a			.DLOOP: 
ae7a				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
ae7a 5f				db WORD_SYS_CORE+75             
ae7b 5b af			dw .REPEAT            
ae7d 06				db 5 + 1 
ae7e .. 00			db "-LOOP",0              
ae84				endm 
# End of macro CWHEAD
ae84			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
ae84				; pop tos as current loop count to hl 
ae84					if DEBUG_FORTH_WORDS_KEY 
ae84						DMARK "-LP" 
ae84 f5				push af  
ae85 3a 99 ae			ld a, (.dmark)  
ae88 32 7a ee			ld (debug_mark),a  
ae8b 3a 9a ae			ld a, (.dmark+1)  
ae8e 32 7b ee			ld (debug_mark+1),a  
ae91 3a 9b ae			ld a, (.dmark+2)  
ae94 32 7c ee			ld (debug_mark+2),a  
ae97 18 03			jr .pastdmark  
ae99 ..			.dmark: db "-LP"  
ae9c f1			.pastdmark: pop af  
ae9d			endm  
# End of macro DMARK
ae9d						CALLMONITOR 
ae9d cd 1d 93			call break_point_state  
aea0				endm  
# End of macro CALLMONITOR
aea0					endif 
aea0			 
aea0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
aea0			 
aea0				FORTH_LOOP_TOS 
aea0 cd 05 9b			call macro_forth_loop_tos 
aea3				endm 
# End of macro FORTH_LOOP_TOS
aea3 e5				push hl 
aea4			 
aea4					if DEBUG_FORTH_WORDS 
aea4						DMARK "-LP" 
aea4 f5				push af  
aea5 3a b9 ae			ld a, (.dmark)  
aea8 32 7a ee			ld (debug_mark),a  
aeab 3a ba ae			ld a, (.dmark+1)  
aeae 32 7b ee			ld (debug_mark+1),a  
aeb1 3a bb ae			ld a, (.dmark+2)  
aeb4 32 7c ee			ld (debug_mark+2),a  
aeb7 18 03			jr .pastdmark  
aeb9 ..			.dmark: db "-LP"  
aebc f1			.pastdmark: pop af  
aebd			endm  
# End of macro DMARK
aebd						CALLMONITOR 
aebd cd 1d 93			call break_point_state  
aec0				endm  
# End of macro CALLMONITOR
aec0					endif 
aec0				; next item on the stack is the limit. get it 
aec0			 
aec0			 
aec0				FORTH_LOOP_POP 
aec0 cd 0f 9b			call macro_forth_loop_pop 
aec3				endm 
# End of macro FORTH_LOOP_POP
aec3			 
aec3				FORTH_LOOP_TOS 
aec3 cd 05 9b			call macro_forth_loop_tos 
aec6				endm 
# End of macro FORTH_LOOP_TOS
aec6			 
aec6 d1				pop de		 ; de = i, hl = limit 
aec7			 
aec7					if DEBUG_FORTH_WORDS 
aec7						DMARK "-L1" 
aec7 f5				push af  
aec8 3a dc ae			ld a, (.dmark)  
aecb 32 7a ee			ld (debug_mark),a  
aece 3a dd ae			ld a, (.dmark+1)  
aed1 32 7b ee			ld (debug_mark+1),a  
aed4 3a de ae			ld a, (.dmark+2)  
aed7 32 7c ee			ld (debug_mark+2),a  
aeda 18 03			jr .pastdmark  
aedc ..			.dmark: db "-L1"  
aedf f1			.pastdmark: pop af  
aee0			endm  
# End of macro DMARK
aee0						CALLMONITOR 
aee0 cd 1d 93			call break_point_state  
aee3				endm  
# End of macro CALLMONITOR
aee3					endif 
aee3			 
aee3				; go back to previous word 
aee3			 
aee3 d5				push de    ; save I for inc later 
aee4			 
aee4			 
aee4				; get limit 
aee4				;  is I at limit? 
aee4			 
aee4			 
aee4					if DEBUG_FORTH_WORDS 
aee4						DMARK "-L1" 
aee4 f5				push af  
aee5 3a f9 ae			ld a, (.dmark)  
aee8 32 7a ee			ld (debug_mark),a  
aeeb 3a fa ae			ld a, (.dmark+1)  
aeee 32 7b ee			ld (debug_mark+1),a  
aef1 3a fb ae			ld a, (.dmark+2)  
aef4 32 7c ee			ld (debug_mark+2),a  
aef7 18 03			jr .pastdmark  
aef9 ..			.dmark: db "-L1"  
aefc f1			.pastdmark: pop af  
aefd			endm  
# End of macro DMARK
aefd						CALLMONITOR 
aefd cd 1d 93			call break_point_state  
af00				endm  
# End of macro CALLMONITOR
af00					endif 
af00			 
af00 ed 52			sbc hl, de 
af02			 
af02			 
af02				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
af02			 
af02 20 26				jr nz, .mloopnotdone 
af04			 
af04 e1				pop hl   ; get rid of saved I 
af05				FORTH_LOOP_POP     ; get rid of limit 
af05 cd 0f 9b			call macro_forth_loop_pop 
af08				endm 
# End of macro FORTH_LOOP_POP
af08			 
af08				FORTH_RSP_POP     ; get rid of DO ptr 
af08 cd 72 98			call macro_forth_rsp_pop 
af0b				endm 
# End of macro FORTH_RSP_POP
af0b			 
af0b			if DEBUG_FORTH_WORDS 
af0b						DMARK "-L>" 
af0b f5				push af  
af0c 3a 20 af			ld a, (.dmark)  
af0f 32 7a ee			ld (debug_mark),a  
af12 3a 21 af			ld a, (.dmark+1)  
af15 32 7b ee			ld (debug_mark+1),a  
af18 3a 22 af			ld a, (.dmark+2)  
af1b 32 7c ee			ld (debug_mark+2),a  
af1e 18 03			jr .pastdmark  
af20 ..			.dmark: db "-L>"  
af23 f1			.pastdmark: pop af  
af24			endm  
# End of macro DMARK
af24				CALLMONITOR 
af24 cd 1d 93			call break_point_state  
af27				endm  
# End of macro CALLMONITOR
af27			endif 
af27			 
af27					NEXTW 
af27 c3 13 9c			jp macro_next 
af2a				endm 
# End of macro NEXTW
af2a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
af2a			 
af2a			.mloopnotdone: 
af2a			 
af2a e1				pop hl    ; get I 
af2b 2b				dec hl 
af2c			 
af2c			   	; save new I 
af2c			 
af2c			 
af2c					; set I counter 
af2c			 
af2c 22 85 e6				ld (os_current_i), hl 
af2f			 
af2f					 
af2f				FORTH_LOOP_NEXT 
af2f cd d2 9a			call macro_forth_loop_next 
af32				endm 
# End of macro FORTH_LOOP_NEXT
af32			 
af32			 
af32					if DEBUG_FORTH_WORDS 
af32 eb						ex de,hl 
af33					endif 
af33			 
af33			;	; get DO ptr 
af33			; 
af33				FORTH_RSP_TOS 
af33 cd 68 98			call macro_forth_rsp_tos 
af36				endm 
# End of macro FORTH_RSP_TOS
af36			 
af36				;push hl 
af36			 
af36				; not going to DO any more 
af36				; get rid of the RSP pointer as DO will add it back in 
af36				;FORTH_RSP_POP 
af36				;pop hl 
af36			 
af36			 
af36 22 61 e6			ld (os_tok_ptr), hl 
af39					if DEBUG_FORTH_WORDS 
af39						DMARK "-L<" 
af39 f5				push af  
af3a 3a 4e af			ld a, (.dmark)  
af3d 32 7a ee			ld (debug_mark),a  
af40 3a 4f af			ld a, (.dmark+1)  
af43 32 7b ee			ld (debug_mark+1),a  
af46 3a 50 af			ld a, (.dmark+2)  
af49 32 7c ee			ld (debug_mark+2),a  
af4c 18 03			jr .pastdmark  
af4e ..			.dmark: db "-L<"  
af51 f1			.pastdmark: pop af  
af52			endm  
# End of macro DMARK
af52					CALLMONITOR 
af52 cd 1d 93			call break_point_state  
af55				endm  
# End of macro CALLMONITOR
af55				endif 
af55 c3 a4 9c			jp exec1 
af58			 
af58					 
af58			 
af58			 
af58			 
af58				NEXTW 
af58 c3 13 9c			jp macro_next 
af5b				endm 
# End of macro NEXTW
af5b			 
af5b			 
af5b			 
af5b			 
af5b			.REPEAT: 
af5b				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
af5b 71				db WORD_SYS_CORE+93             
af5c ae af			dw .UNTIL            
af5e 06				db 5 + 1 
af5f .. 00			db "REPEAT",0              
af66				endm 
# End of macro CWHEAD
af66			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
af66			;  push pc to rsp stack past the REPEAT 
af66					if DEBUG_FORTH_WORDS_KEY 
af66						DMARK "REP" 
af66 f5				push af  
af67 3a 7b af			ld a, (.dmark)  
af6a 32 7a ee			ld (debug_mark),a  
af6d 3a 7c af			ld a, (.dmark+1)  
af70 32 7b ee			ld (debug_mark+1),a  
af73 3a 7d af			ld a, (.dmark+2)  
af76 32 7c ee			ld (debug_mark+2),a  
af79 18 03			jr .pastdmark  
af7b ..			.dmark: db "REP"  
af7e f1			.pastdmark: pop af  
af7f			endm  
# End of macro DMARK
af7f						CALLMONITOR 
af7f cd 1d 93			call break_point_state  
af82				endm  
# End of macro CALLMONITOR
af82					endif 
af82			 
af82 2a 61 e6				ld hl, (os_tok_ptr) 
af85 23					inc hl   ; R 
af86 23					inc hl  ; E 
af87 23					inc hl   ; P 
af88 23					inc hl   ; E 
af89 23					inc hl   ; A 
af8a 23					inc hl   ; T 
af8b 23					inc hl   ; zero 
af8c					FORTH_RSP_NEXT 
af8c cd 51 98			call macro_forth_rsp_next 
af8f				endm 
# End of macro FORTH_RSP_NEXT
af8f			 
af8f			 
af8f					if DEBUG_FORTH_WORDS 
af8f						DMARK "REP" 
af8f f5				push af  
af90 3a a4 af			ld a, (.dmark)  
af93 32 7a ee			ld (debug_mark),a  
af96 3a a5 af			ld a, (.dmark+1)  
af99 32 7b ee			ld (debug_mark+1),a  
af9c 3a a6 af			ld a, (.dmark+2)  
af9f 32 7c ee			ld (debug_mark+2),a  
afa2 18 03			jr .pastdmark  
afa4 ..			.dmark: db "REP"  
afa7 f1			.pastdmark: pop af  
afa8			endm  
# End of macro DMARK
afa8						;pop bc    ; TODO BUG ?????? what is this for???? 
afa8						CALLMONITOR 
afa8 cd 1d 93			call break_point_state  
afab				endm  
# End of macro CALLMONITOR
afab					endif 
afab			 
afab					NEXTW 
afab c3 13 9c			jp macro_next 
afae				endm 
# End of macro NEXTW
afae			;	       NEXTW 
afae			 
afae			.UNTIL: 
afae				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
afae 72				db WORD_SYS_CORE+94             
afaf 45 b0			dw .ENDFLOW            
afb1 06				db 5 + 1 
afb2 .. 00			db "UNTIL",0              
afb8				endm 
# End of macro CWHEAD
afb8			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
afb8			 
afb8				; pop tos as check 
afb8			 
afb8				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
afb8			 
afb8				FORTH_DSP_VALUEHL 
afb8 cd a1 9a			call macro_dsp_valuehl 
afbb				endm 
# End of macro FORTH_DSP_VALUEHL
afbb			 
afbb					if DEBUG_FORTH_WORDS_KEY 
afbb						DMARK "UNT" 
afbb f5				push af  
afbc 3a d0 af			ld a, (.dmark)  
afbf 32 7a ee			ld (debug_mark),a  
afc2 3a d1 af			ld a, (.dmark+1)  
afc5 32 7b ee			ld (debug_mark+1),a  
afc8 3a d2 af			ld a, (.dmark+2)  
afcb 32 7c ee			ld (debug_mark+2),a  
afce 18 03			jr .pastdmark  
afd0 ..			.dmark: db "UNT"  
afd3 f1			.pastdmark: pop af  
afd4			endm  
# End of macro DMARK
afd4						CALLMONITOR 
afd4 cd 1d 93			call break_point_state  
afd7				endm  
# End of macro CALLMONITOR
afd7					endif 
afd7			 
afd7			;	push hl 
afd7				FORTH_DSP_POP 
afd7 cd 59 9b			call macro_forth_dsp_pop 
afda				endm 
# End of macro FORTH_DSP_POP
afda			 
afda			;	pop hl 
afda			 
afda				; test if true 
afda			 
afda cd d3 8a			call ishlzero 
afdd			;	ld a,l 
afdd			;	add h 
afdd			; 
afdd			;	cp 0 
afdd			 
afdd 20 3e			jr nz, .untilnotdone 
afdf			 
afdf					if DEBUG_FORTH_WORDS 
afdf						DMARK "UNf" 
afdf f5				push af  
afe0 3a f4 af			ld a, (.dmark)  
afe3 32 7a ee			ld (debug_mark),a  
afe6 3a f5 af			ld a, (.dmark+1)  
afe9 32 7b ee			ld (debug_mark+1),a  
afec 3a f6 af			ld a, (.dmark+2)  
afef 32 7c ee			ld (debug_mark+2),a  
aff2 18 03			jr .pastdmark  
aff4 ..			.dmark: db "UNf"  
aff7 f1			.pastdmark: pop af  
aff8			endm  
# End of macro DMARK
aff8						CALLMONITOR 
aff8 cd 1d 93			call break_point_state  
affb				endm  
# End of macro CALLMONITOR
affb					endif 
affb			 
affb			 
affb			 
affb				FORTH_RSP_POP     ; get rid of DO ptr 
affb cd 72 98			call macro_forth_rsp_pop 
affe				endm 
# End of macro FORTH_RSP_POP
affe			 
affe			if DEBUG_FORTH_WORDS 
affe						DMARK "UN>" 
affe f5				push af  
afff 3a 13 b0			ld a, (.dmark)  
b002 32 7a ee			ld (debug_mark),a  
b005 3a 14 b0			ld a, (.dmark+1)  
b008 32 7b ee			ld (debug_mark+1),a  
b00b 3a 15 b0			ld a, (.dmark+2)  
b00e 32 7c ee			ld (debug_mark+2),a  
b011 18 03			jr .pastdmark  
b013 ..			.dmark: db "UN>"  
b016 f1			.pastdmark: pop af  
b017			endm  
# End of macro DMARK
b017				CALLMONITOR 
b017 cd 1d 93			call break_point_state  
b01a				endm  
# End of macro CALLMONITOR
b01a			endif 
b01a			 
b01a					NEXTW 
b01a c3 13 9c			jp macro_next 
b01d				endm 
# End of macro NEXTW
b01d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b01d			 
b01d			.untilnotdone: 
b01d			 
b01d			 
b01d			;	; get DO ptr 
b01d			; 
b01d				FORTH_RSP_TOS 
b01d cd 68 98			call macro_forth_rsp_tos 
b020				endm 
# End of macro FORTH_RSP_TOS
b020			 
b020				;push hl 
b020			 
b020				; not going to DO any more 
b020				; get rid of the RSP pointer as DO will add it back in 
b020				;FORTH_RSP_POP 
b020				;pop hl 
b020			 
b020			 
b020 22 61 e6			ld (os_tok_ptr), hl 
b023					if DEBUG_FORTH_WORDS 
b023						DMARK "UN<" 
b023 f5				push af  
b024 3a 38 b0			ld a, (.dmark)  
b027 32 7a ee			ld (debug_mark),a  
b02a 3a 39 b0			ld a, (.dmark+1)  
b02d 32 7b ee			ld (debug_mark+1),a  
b030 3a 3a b0			ld a, (.dmark+2)  
b033 32 7c ee			ld (debug_mark+2),a  
b036 18 03			jr .pastdmark  
b038 ..			.dmark: db "UN<"  
b03b f1			.pastdmark: pop af  
b03c			endm  
# End of macro DMARK
b03c					CALLMONITOR 
b03c cd 1d 93			call break_point_state  
b03f				endm  
# End of macro CALLMONITOR
b03f				endif 
b03f c3 a4 9c			jp exec1 
b042			 
b042					 
b042			 
b042			 
b042					NEXTW 
b042 c3 13 9c			jp macro_next 
b045				endm 
# End of macro NEXTW
b045			 
b045			 
b045			.ENDFLOW: 
b045			 
b045			; eof 
b045			 
# End of file forth_words_flow.asm
b045			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b045			include "forth_words_logic.asm" 
b045			 
b045			; | ## Logic Words 
b045			 
b045			.NOT: 
b045				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b045 2d				db WORD_SYS_CORE+25             
b046 8d b0			dw .IS            
b048 04				db 3 + 1 
b049 .. 00			db "NOT",0              
b04d				endm 
# End of macro CWHEAD
b04d			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b04d					if DEBUG_FORTH_WORDS_KEY 
b04d						DMARK "NOT" 
b04d f5				push af  
b04e 3a 62 b0			ld a, (.dmark)  
b051 32 7a ee			ld (debug_mark),a  
b054 3a 63 b0			ld a, (.dmark+1)  
b057 32 7b ee			ld (debug_mark+1),a  
b05a 3a 64 b0			ld a, (.dmark+2)  
b05d 32 7c ee			ld (debug_mark+2),a  
b060 18 03			jr .pastdmark  
b062 ..			.dmark: db "NOT"  
b065 f1			.pastdmark: pop af  
b066			endm  
# End of macro DMARK
b066						CALLMONITOR 
b066 cd 1d 93			call break_point_state  
b069				endm  
# End of macro CALLMONITOR
b069					endif 
b069					FORTH_DSP 
b069 cd 67 9a			call macro_forth_dsp 
b06c				endm 
# End of macro FORTH_DSP
b06c 7e					ld a,(hl)	; get type of value on TOS 
b06d fe 02				cp DS_TYPE_INUM  
b06f 28 03				jr z, .noti 
b071					NEXTW 
b071 c3 13 9c			jp macro_next 
b074				endm 
# End of macro NEXTW
b074			.noti:          FORTH_DSP_VALUEHL 
b074 cd a1 9a			call macro_dsp_valuehl 
b077				endm 
# End of macro FORTH_DSP_VALUEHL
b077			;		push hl 
b077					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b077 cd 59 9b			call macro_forth_dsp_pop 
b07a				endm 
# End of macro FORTH_DSP_POP
b07a			;		pop hl 
b07a 3e 00				ld a,0 
b07c bd					cp l 
b07d 28 04				jr z, .not2t 
b07f 2e 00				ld l, 0 
b081 18 02				jr .notip 
b083			 
b083 2e ff		.not2t:		ld l, 255 
b085			 
b085 26 00		.notip:		ld h, 0	 
b087			 
b087 cd aa 98				call forth_push_numhl 
b08a					NEXTW 
b08a c3 13 9c			jp macro_next 
b08d				endm 
# End of macro NEXTW
b08d			 
b08d			.IS: 
b08d				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b08d 2d				db WORD_SYS_CORE+25             
b08e b3 b0			dw .LZERO            
b090 03				db 2 + 1 
b091 .. 00			db "IS",0              
b094				endm 
# End of macro CWHEAD
b094			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b094					if DEBUG_FORTH_WORDS_KEY 
b094						DMARK "IS." 
b094 f5				push af  
b095 3a a9 b0			ld a, (.dmark)  
b098 32 7a ee			ld (debug_mark),a  
b09b 3a aa b0			ld a, (.dmark+1)  
b09e 32 7b ee			ld (debug_mark+1),a  
b0a1 3a ab b0			ld a, (.dmark+2)  
b0a4 32 7c ee			ld (debug_mark+2),a  
b0a7 18 03			jr .pastdmark  
b0a9 ..			.dmark: db "IS."  
b0ac f1			.pastdmark: pop af  
b0ad			endm  
# End of macro DMARK
b0ad						CALLMONITOR 
b0ad cd 1d 93			call break_point_state  
b0b0				endm  
# End of macro CALLMONITOR
b0b0					endif 
b0b0					NEXTW 
b0b0 c3 13 9c			jp macro_next 
b0b3				endm 
# End of macro NEXTW
b0b3			.LZERO: 
b0b3				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b0b3 2d				db WORD_SYS_CORE+25             
b0b4 bd b0			dw .TZERO            
b0b6 03				db 2 + 1 
b0b7 .. 00			db "0<",0              
b0ba				endm 
# End of macro CWHEAD
b0ba			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b0ba					NEXTW 
b0ba c3 13 9c			jp macro_next 
b0bd				endm 
# End of macro NEXTW
b0bd			.TZERO: 
b0bd				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b0bd 2e				db WORD_SYS_CORE+26             
b0be 04 b1			dw .LESS            
b0c0 03				db 2 + 1 
b0c1 .. 00			db "0=",0              
b0c4				endm 
# End of macro CWHEAD
b0c4			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b0c4				; TODO add floating point number detection 
b0c4					;v5 FORTH_DSP_VALUE 
b0c4					if DEBUG_FORTH_WORDS_KEY 
b0c4						DMARK "0=." 
b0c4 f5				push af  
b0c5 3a d9 b0			ld a, (.dmark)  
b0c8 32 7a ee			ld (debug_mark),a  
b0cb 3a da b0			ld a, (.dmark+1)  
b0ce 32 7b ee			ld (debug_mark+1),a  
b0d1 3a db b0			ld a, (.dmark+2)  
b0d4 32 7c ee			ld (debug_mark+2),a  
b0d7 18 03			jr .pastdmark  
b0d9 ..			.dmark: db "0=."  
b0dc f1			.pastdmark: pop af  
b0dd			endm  
# End of macro DMARK
b0dd						CALLMONITOR 
b0dd cd 1d 93			call break_point_state  
b0e0				endm  
# End of macro CALLMONITOR
b0e0					endif 
b0e0					FORTH_DSP 
b0e0 cd 67 9a			call macro_forth_dsp 
b0e3				endm 
# End of macro FORTH_DSP
b0e3 7e					ld a,(hl)	; get type of value on TOS 
b0e4 fe 02				cp DS_TYPE_INUM  
b0e6 28 00				jr z, .tz_inum 
b0e8			 
b0e8				if FORTH_ENABLE_FLOATMATH 
b0e8					jr .tz_done 
b0e8			 
b0e8				endif 
b0e8					 
b0e8			 
b0e8			.tz_inum: 
b0e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b0e8 cd a1 9a			call macro_dsp_valuehl 
b0eb				endm 
# End of macro FORTH_DSP_VALUEHL
b0eb			 
b0eb			;		push hl 
b0eb			 
b0eb					; destroy value TOS 
b0eb			 
b0eb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b0eb cd 59 9b			call macro_forth_dsp_pop 
b0ee				endm 
# End of macro FORTH_DSP_POP
b0ee			 
b0ee			;		pop hl 
b0ee			 
b0ee 3e 00				ld a,0 
b0f0			 
b0f0 bd					cp l 
b0f1 20 08				jr nz, .tz_notzero 
b0f3			 
b0f3 bc					cp h 
b0f4			 
b0f4 20 05				jr nz, .tz_notzero 
b0f6			 
b0f6			 
b0f6 21 01 00				ld hl, FORTH_TRUE 
b0f9 18 03				jr .tz_done 
b0fb			 
b0fb 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b0fe			 
b0fe					; push value back onto stack for another op etc 
b0fe			 
b0fe			.tz_done: 
b0fe cd aa 98				call forth_push_numhl 
b101			 
b101					NEXTW 
b101 c3 13 9c			jp macro_next 
b104				endm 
# End of macro NEXTW
b104			.LESS: 
b104				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b104 2f				db WORD_SYS_CORE+27             
b105 6d b1			dw .GT            
b107 02				db 1 + 1 
b108 .. 00			db "<",0              
b10a				endm 
# End of macro CWHEAD
b10a			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b10a				; TODO add floating point number detection 
b10a					if DEBUG_FORTH_WORDS_KEY 
b10a						DMARK "LES" 
b10a f5				push af  
b10b 3a 1f b1			ld a, (.dmark)  
b10e 32 7a ee			ld (debug_mark),a  
b111 3a 20 b1			ld a, (.dmark+1)  
b114 32 7b ee			ld (debug_mark+1),a  
b117 3a 21 b1			ld a, (.dmark+2)  
b11a 32 7c ee			ld (debug_mark+2),a  
b11d 18 03			jr .pastdmark  
b11f ..			.dmark: db "LES"  
b122 f1			.pastdmark: pop af  
b123			endm  
# End of macro DMARK
b123						CALLMONITOR 
b123 cd 1d 93			call break_point_state  
b126				endm  
# End of macro CALLMONITOR
b126					endif 
b126					FORTH_DSP 
b126 cd 67 9a			call macro_forth_dsp 
b129				endm 
# End of macro FORTH_DSP
b129					;v5 FORTH_DSP_VALUE 
b129 7e					ld a,(hl)	; get type of value on TOS 
b12a fe 02				cp DS_TYPE_INUM  
b12c 28 00				jr z, .less_inum 
b12e			 
b12e				if FORTH_ENABLE_FLOATMATH 
b12e					jr .less_done 
b12e			 
b12e				endif 
b12e					 
b12e			 
b12e			.less_inum: 
b12e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b12e cd a1 9a			call macro_dsp_valuehl 
b131				endm 
# End of macro FORTH_DSP_VALUEHL
b131			 
b131 e5					push hl  ; u2 
b132			 
b132					; destroy value TOS 
b132			 
b132					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b132 cd 59 9b			call macro_forth_dsp_pop 
b135				endm 
# End of macro FORTH_DSP_POP
b135			 
b135			 
b135					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b135 cd a1 9a			call macro_dsp_valuehl 
b138				endm 
# End of macro FORTH_DSP_VALUEHL
b138			 
b138 e5					push hl    ; u1 
b139			 
b139					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b139 cd 59 9b			call macro_forth_dsp_pop 
b13c				endm 
# End of macro FORTH_DSP_POP
b13c			 
b13c			 
b13c b7			 or a      ;clear carry flag 
b13d 01 00 00		 ld bc, FORTH_FALSE 
b140 e1			  pop hl    ; u1 
b141 d1			  pop de    ; u2 
b142 ed 52		  sbc hl,de 
b144 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b146			 
b146 01 01 00		 ld bc, FORTH_TRUE 
b149			.lscont:  
b149 c5					push bc 
b14a e1					pop hl 
b14b			 
b14b					if DEBUG_FORTH_WORDS 
b14b						DMARK "LT1" 
b14b f5				push af  
b14c 3a 60 b1			ld a, (.dmark)  
b14f 32 7a ee			ld (debug_mark),a  
b152 3a 61 b1			ld a, (.dmark+1)  
b155 32 7b ee			ld (debug_mark+1),a  
b158 3a 62 b1			ld a, (.dmark+2)  
b15b 32 7c ee			ld (debug_mark+2),a  
b15e 18 03			jr .pastdmark  
b160 ..			.dmark: db "LT1"  
b163 f1			.pastdmark: pop af  
b164			endm  
# End of macro DMARK
b164						CALLMONITOR 
b164 cd 1d 93			call break_point_state  
b167				endm  
# End of macro CALLMONITOR
b167					endif 
b167 cd aa 98				call forth_push_numhl 
b16a			 
b16a					NEXTW 
b16a c3 13 9c			jp macro_next 
b16d				endm 
# End of macro NEXTW
b16d			.GT: 
b16d				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b16d 30				db WORD_SYS_CORE+28             
b16e d6 b1			dw .EQUAL            
b170 02				db 1 + 1 
b171 .. 00			db ">",0              
b173				endm 
# End of macro CWHEAD
b173			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b173				; TODO add floating point number detection 
b173					if DEBUG_FORTH_WORDS_KEY 
b173						DMARK "GRT" 
b173 f5				push af  
b174 3a 88 b1			ld a, (.dmark)  
b177 32 7a ee			ld (debug_mark),a  
b17a 3a 89 b1			ld a, (.dmark+1)  
b17d 32 7b ee			ld (debug_mark+1),a  
b180 3a 8a b1			ld a, (.dmark+2)  
b183 32 7c ee			ld (debug_mark+2),a  
b186 18 03			jr .pastdmark  
b188 ..			.dmark: db "GRT"  
b18b f1			.pastdmark: pop af  
b18c			endm  
# End of macro DMARK
b18c						CALLMONITOR 
b18c cd 1d 93			call break_point_state  
b18f				endm  
# End of macro CALLMONITOR
b18f					endif 
b18f					FORTH_DSP 
b18f cd 67 9a			call macro_forth_dsp 
b192				endm 
# End of macro FORTH_DSP
b192					;FORTH_DSP_VALUE 
b192 7e					ld a,(hl)	; get type of value on TOS 
b193 fe 02				cp DS_TYPE_INUM  
b195 28 00				jr z, .gt_inum 
b197			 
b197				if FORTH_ENABLE_FLOATMATH 
b197					jr .gt_done 
b197			 
b197				endif 
b197					 
b197			 
b197			.gt_inum: 
b197					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b197 cd a1 9a			call macro_dsp_valuehl 
b19a				endm 
# End of macro FORTH_DSP_VALUEHL
b19a			 
b19a e5					push hl  ; u2 
b19b			 
b19b					; destroy value TOS 
b19b			 
b19b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b19b cd 59 9b			call macro_forth_dsp_pop 
b19e				endm 
# End of macro FORTH_DSP_POP
b19e			 
b19e			 
b19e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b19e cd a1 9a			call macro_dsp_valuehl 
b1a1				endm 
# End of macro FORTH_DSP_VALUEHL
b1a1			 
b1a1 e5					push hl    ; u1 
b1a2			 
b1a2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1a2 cd 59 9b			call macro_forth_dsp_pop 
b1a5				endm 
# End of macro FORTH_DSP_POP
b1a5			 
b1a5			 
b1a5 b7			 or a      ;clear carry flag 
b1a6 01 00 00		 ld bc, FORTH_FALSE 
b1a9 e1			  pop hl    ; u1 
b1aa d1			  pop de    ; u2 
b1ab ed 52		  sbc hl,de 
b1ad 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b1af			 
b1af 01 01 00		 ld bc, FORTH_TRUE 
b1b2			.gtcont:  
b1b2 c5					push bc 
b1b3 e1					pop hl 
b1b4			 
b1b4					if DEBUG_FORTH_WORDS 
b1b4						DMARK "GT1" 
b1b4 f5				push af  
b1b5 3a c9 b1			ld a, (.dmark)  
b1b8 32 7a ee			ld (debug_mark),a  
b1bb 3a ca b1			ld a, (.dmark+1)  
b1be 32 7b ee			ld (debug_mark+1),a  
b1c1 3a cb b1			ld a, (.dmark+2)  
b1c4 32 7c ee			ld (debug_mark+2),a  
b1c7 18 03			jr .pastdmark  
b1c9 ..			.dmark: db "GT1"  
b1cc f1			.pastdmark: pop af  
b1cd			endm  
# End of macro DMARK
b1cd						CALLMONITOR 
b1cd cd 1d 93			call break_point_state  
b1d0				endm  
# End of macro CALLMONITOR
b1d0					endif 
b1d0 cd aa 98				call forth_push_numhl 
b1d3			 
b1d3					NEXTW 
b1d3 c3 13 9c			jp macro_next 
b1d6				endm 
# End of macro NEXTW
b1d6			.EQUAL: 
b1d6				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b1d6 31				db WORD_SYS_CORE+29             
b1d7 41 b2			dw .ENDLOGIC            
b1d9 02				db 1 + 1 
b1da .. 00			db "=",0              
b1dc				endm 
# End of macro CWHEAD
b1dc			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b1dc				; TODO add floating point number detection 
b1dc					if DEBUG_FORTH_WORDS_KEY 
b1dc						DMARK "EQ." 
b1dc f5				push af  
b1dd 3a f1 b1			ld a, (.dmark)  
b1e0 32 7a ee			ld (debug_mark),a  
b1e3 3a f2 b1			ld a, (.dmark+1)  
b1e6 32 7b ee			ld (debug_mark+1),a  
b1e9 3a f3 b1			ld a, (.dmark+2)  
b1ec 32 7c ee			ld (debug_mark+2),a  
b1ef 18 03			jr .pastdmark  
b1f1 ..			.dmark: db "EQ."  
b1f4 f1			.pastdmark: pop af  
b1f5			endm  
# End of macro DMARK
b1f5						CALLMONITOR 
b1f5 cd 1d 93			call break_point_state  
b1f8				endm  
# End of macro CALLMONITOR
b1f8					endif 
b1f8					FORTH_DSP 
b1f8 cd 67 9a			call macro_forth_dsp 
b1fb				endm 
# End of macro FORTH_DSP
b1fb					;v5 FORTH_DSP_VALUE 
b1fb 7e					ld a,(hl)	; get type of value on TOS 
b1fc fe 02				cp DS_TYPE_INUM  
b1fe 28 00				jr z, .eq_inum 
b200			 
b200				if FORTH_ENABLE_FLOATMATH 
b200					jr .eq_done 
b200			 
b200				endif 
b200					 
b200			 
b200			.eq_inum: 
b200					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b200 cd a1 9a			call macro_dsp_valuehl 
b203				endm 
# End of macro FORTH_DSP_VALUEHL
b203			 
b203 e5					push hl 
b204			 
b204					; destroy value TOS 
b204			 
b204					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b204 cd 59 9b			call macro_forth_dsp_pop 
b207				endm 
# End of macro FORTH_DSP_POP
b207			 
b207			 
b207					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b207 cd a1 9a			call macro_dsp_valuehl 
b20a				endm 
# End of macro FORTH_DSP_VALUEHL
b20a			 
b20a					; one value on hl get other one back 
b20a			 
b20a e5					push hl 
b20b			 
b20b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b20b cd 59 9b			call macro_forth_dsp_pop 
b20e				endm 
# End of macro FORTH_DSP_POP
b20e			 
b20e 0e 00				ld c, FORTH_FALSE 
b210			 
b210 e1					pop hl 
b211 d1					pop de 
b212			 
b212 7b					ld a, e 
b213 bd					cp l 
b214			 
b214 20 06				jr nz, .eq_done 
b216			 
b216 7a					ld a, d 
b217 bc					cp h 
b218			 
b218 20 02				jr nz, .eq_done 
b21a			 
b21a 0e 01				ld c, FORTH_TRUE 
b21c					 
b21c			 
b21c			 
b21c			.eq_done: 
b21c			 
b21c					; TODO push value back onto stack for another op etc 
b21c			 
b21c 26 00				ld h, 0 
b21e 69					ld l, c 
b21f					if DEBUG_FORTH_WORDS 
b21f						DMARK "EQ1" 
b21f f5				push af  
b220 3a 34 b2			ld a, (.dmark)  
b223 32 7a ee			ld (debug_mark),a  
b226 3a 35 b2			ld a, (.dmark+1)  
b229 32 7b ee			ld (debug_mark+1),a  
b22c 3a 36 b2			ld a, (.dmark+2)  
b22f 32 7c ee			ld (debug_mark+2),a  
b232 18 03			jr .pastdmark  
b234 ..			.dmark: db "EQ1"  
b237 f1			.pastdmark: pop af  
b238			endm  
# End of macro DMARK
b238						CALLMONITOR 
b238 cd 1d 93			call break_point_state  
b23b				endm  
# End of macro CALLMONITOR
b23b					endif 
b23b cd aa 98				call forth_push_numhl 
b23e			 
b23e					NEXTW 
b23e c3 13 9c			jp macro_next 
b241				endm 
# End of macro NEXTW
b241			 
b241			 
b241			.ENDLOGIC: 
b241			; eof 
b241			 
b241			 
# End of file forth_words_logic.asm
b241			include "forth_words_maths.asm" 
b241			 
b241			; | ## Maths Words 
b241			 
b241			.PLUS:	 
b241				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b241 15				db WORD_SYS_CORE+1             
b242 83 b2			dw .NEG            
b244 02				db 1 + 1 
b245 .. 00			db "+",0              
b247				endm 
# End of macro CWHEAD
b247			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b247					if DEBUG_FORTH_WORDS_KEY 
b247						DMARK "PLU" 
b247 f5				push af  
b248 3a 5c b2			ld a, (.dmark)  
b24b 32 7a ee			ld (debug_mark),a  
b24e 3a 5d b2			ld a, (.dmark+1)  
b251 32 7b ee			ld (debug_mark+1),a  
b254 3a 5e b2			ld a, (.dmark+2)  
b257 32 7c ee			ld (debug_mark+2),a  
b25a 18 03			jr .pastdmark  
b25c ..			.dmark: db "PLU"  
b25f f1			.pastdmark: pop af  
b260			endm  
# End of macro DMARK
b260						CALLMONITOR 
b260 cd 1d 93			call break_point_state  
b263				endm  
# End of macro CALLMONITOR
b263					endif 
b263					; add top two values and push back result 
b263			 
b263					;for v5 FORTH_DSP_VALUE 
b263					FORTH_DSP 
b263 cd 67 9a			call macro_forth_dsp 
b266				endm 
# End of macro FORTH_DSP
b266 7e					ld a,(hl)	; get type of value on TOS 
b267 fe 02				cp DS_TYPE_INUM  
b269 28 03				jr z, .dot_inum 
b26b			 
b26b					NEXTW 
b26b c3 13 9c			jp macro_next 
b26e				endm 
# End of macro NEXTW
b26e			 
b26e			; float maths 
b26e			 
b26e				if FORTH_ENABLE_FLOATMATH 
b26e						inc hl      ; now at start of numeric as string 
b26e			 
b26e					if DEBUG_FORTH_MATHS 
b26e						DMARK "ADD" 
b26e				CALLMONITOR 
b26e					endif 
b26e			 
b26e					;ld ix, hl 
b26e					call CON 
b26e			 
b26e			 
b26e					push hl 
b26e					 
b26e					 
b26e			 
b26e						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b26e			 
b26e					; get next number 
b26e			 
b26e						FORTH_DSP_VALUE 
b26e			 
b26e						inc hl      ; now at start of numeric as string 
b26e			 
b26e					;ld ix, hl 
b26e					call CON 
b26e			 
b26e					push hl 
b26e			 
b26e			 
b26e						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b26e			 
b26e						; TODO do add 
b26e			 
b26e						call IADD 
b26e			 
b26e						; TODO get result back as ascii 
b26e			 
b26e						; TODO push result  
b26e			 
b26e			 
b26e			 
b26e						jr .dot_done 
b26e				endif 
b26e			 
b26e			.dot_inum: 
b26e			 
b26e			 
b26e					if DEBUG_FORTH_DOT 
b26e						DMARK "+IT" 
b26e				CALLMONITOR 
b26e					endif 
b26e			 
b26e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b26e cd a1 9a			call macro_dsp_valuehl 
b271				endm 
# End of macro FORTH_DSP_VALUEHL
b271			 
b271				; TODO add floating point number detection 
b271			 
b271 e5					push hl 
b272			 
b272					; destroy value TOS 
b272			 
b272					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b272 cd 59 9b			call macro_forth_dsp_pop 
b275				endm 
# End of macro FORTH_DSP_POP
b275			 
b275			 
b275					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b275 cd a1 9a			call macro_dsp_valuehl 
b278				endm 
# End of macro FORTH_DSP_VALUEHL
b278			 
b278					; one value on hl get other one back 
b278			 
b278 d1					pop de 
b279			 
b279					; do the add 
b279			 
b279 19					add hl,de 
b27a			 
b27a					; save it 
b27a			 
b27a			;		push hl	 
b27a			 
b27a					; 
b27a			 
b27a					; destroy value TOS 
b27a			 
b27a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b27a cd 59 9b			call macro_forth_dsp_pop 
b27d				endm 
# End of macro FORTH_DSP_POP
b27d			 
b27d					; TODO push value back onto stack for another op etc 
b27d			 
b27d			;		pop hl 
b27d			 
b27d			.dot_done: 
b27d cd aa 98				call forth_push_numhl 
b280			 
b280					NEXTW 
b280 c3 13 9c			jp macro_next 
b283				endm 
# End of macro NEXTW
b283			.NEG: 
b283			 
b283				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b283 17				db WORD_SYS_CORE+3             
b284 c6 b2			dw .DIV            
b286 02				db 1 + 1 
b287 .. 00			db "-",0              
b289				endm 
# End of macro CWHEAD
b289			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b289					if DEBUG_FORTH_WORDS_KEY 
b289						DMARK "SUB" 
b289 f5				push af  
b28a 3a 9e b2			ld a, (.dmark)  
b28d 32 7a ee			ld (debug_mark),a  
b290 3a 9f b2			ld a, (.dmark+1)  
b293 32 7b ee			ld (debug_mark+1),a  
b296 3a a0 b2			ld a, (.dmark+2)  
b299 32 7c ee			ld (debug_mark+2),a  
b29c 18 03			jr .pastdmark  
b29e ..			.dmark: db "SUB"  
b2a1 f1			.pastdmark: pop af  
b2a2			endm  
# End of macro DMARK
b2a2						CALLMONITOR 
b2a2 cd 1d 93			call break_point_state  
b2a5				endm  
# End of macro CALLMONITOR
b2a5					endif 
b2a5			 
b2a5			 
b2a5				; TODO add floating point number detection 
b2a5					; v5 FORTH_DSP_VALUE 
b2a5					FORTH_DSP 
b2a5 cd 67 9a			call macro_forth_dsp 
b2a8				endm 
# End of macro FORTH_DSP
b2a8 7e					ld a,(hl)	; get type of value on TOS 
b2a9 fe 02				cp DS_TYPE_INUM  
b2ab 28 03				jr z, .neg_inum 
b2ad			 
b2ad					NEXTW 
b2ad c3 13 9c			jp macro_next 
b2b0				endm 
# End of macro NEXTW
b2b0			 
b2b0			; float maths 
b2b0			 
b2b0				if FORTH_ENABLE_FLOATMATH 
b2b0					jr .neg_done 
b2b0			 
b2b0				endif 
b2b0					 
b2b0			 
b2b0			.neg_inum: 
b2b0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2b0 cd a1 9a			call macro_dsp_valuehl 
b2b3				endm 
# End of macro FORTH_DSP_VALUEHL
b2b3			 
b2b3 e5					push hl 
b2b4			 
b2b4					; destroy value TOS 
b2b4			 
b2b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2b4 cd 59 9b			call macro_forth_dsp_pop 
b2b7				endm 
# End of macro FORTH_DSP_POP
b2b7			 
b2b7			 
b2b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2b7 cd a1 9a			call macro_dsp_valuehl 
b2ba				endm 
# End of macro FORTH_DSP_VALUEHL
b2ba			 
b2ba					; one value on hl get other one back 
b2ba			 
b2ba d1					pop de 
b2bb			 
b2bb					; do the sub 
b2bb			;		ex de, hl 
b2bb			 
b2bb ed 52				sbc hl,de 
b2bd			 
b2bd					; save it 
b2bd			 
b2bd			;		push hl	 
b2bd			 
b2bd					; 
b2bd			 
b2bd					; destroy value TOS 
b2bd			 
b2bd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2bd cd 59 9b			call macro_forth_dsp_pop 
b2c0				endm 
# End of macro FORTH_DSP_POP
b2c0			 
b2c0					; TODO push value back onto stack for another op etc 
b2c0			 
b2c0			;		pop hl 
b2c0			 
b2c0 cd aa 98				call forth_push_numhl 
b2c3			.neg_done: 
b2c3			 
b2c3					NEXTW 
b2c3 c3 13 9c			jp macro_next 
b2c6				endm 
# End of macro NEXTW
b2c6			.DIV: 
b2c6				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b2c6 18				db WORD_SYS_CORE+4             
b2c7 13 b3			dw .MUL            
b2c9 02				db 1 + 1 
b2ca .. 00			db "/",0              
b2cc				endm 
# End of macro CWHEAD
b2cc			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b2cc					if DEBUG_FORTH_WORDS_KEY 
b2cc						DMARK "DIV" 
b2cc f5				push af  
b2cd 3a e1 b2			ld a, (.dmark)  
b2d0 32 7a ee			ld (debug_mark),a  
b2d3 3a e2 b2			ld a, (.dmark+1)  
b2d6 32 7b ee			ld (debug_mark+1),a  
b2d9 3a e3 b2			ld a, (.dmark+2)  
b2dc 32 7c ee			ld (debug_mark+2),a  
b2df 18 03			jr .pastdmark  
b2e1 ..			.dmark: db "DIV"  
b2e4 f1			.pastdmark: pop af  
b2e5			endm  
# End of macro DMARK
b2e5						CALLMONITOR 
b2e5 cd 1d 93			call break_point_state  
b2e8				endm  
# End of macro CALLMONITOR
b2e8					endif 
b2e8				; TODO add floating point number detection 
b2e8					; v5 FORTH_DSP_VALUE 
b2e8					FORTH_DSP 
b2e8 cd 67 9a			call macro_forth_dsp 
b2eb				endm 
# End of macro FORTH_DSP
b2eb 7e					ld a,(hl)	; get type of value on TOS 
b2ec fe 02				cp DS_TYPE_INUM  
b2ee 28 03				jr z, .div_inum 
b2f0			 
b2f0				if FORTH_ENABLE_FLOATMATH 
b2f0					jr .div_done 
b2f0			 
b2f0				endif 
b2f0					NEXTW 
b2f0 c3 13 9c			jp macro_next 
b2f3				endm 
# End of macro NEXTW
b2f3			.div_inum: 
b2f3			 
b2f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2f3 cd a1 9a			call macro_dsp_valuehl 
b2f6				endm 
# End of macro FORTH_DSP_VALUEHL
b2f6			 
b2f6 e5					push hl    ; to go to bc 
b2f7			 
b2f7					; destroy value TOS 
b2f7			 
b2f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2f7 cd 59 9b			call macro_forth_dsp_pop 
b2fa				endm 
# End of macro FORTH_DSP_POP
b2fa			 
b2fa			 
b2fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2fa cd a1 9a			call macro_dsp_valuehl 
b2fd				endm 
# End of macro FORTH_DSP_VALUEHL
b2fd			 
b2fd					; hl to go to de 
b2fd			 
b2fd e5					push hl 
b2fe			 
b2fe c1					pop bc 
b2ff d1					pop de		 
b300			 
b300			 
b300					if DEBUG_FORTH_MATHS 
b300						DMARK "DIV" 
b300				CALLMONITOR 
b300					endif 
b300					; one value on hl but move to a get other one back 
b300			 
b300			        
b300 cd 07 8a			call Div16 
b303			 
b303			;	push af	 
b303 e5				push hl 
b304 c5				push bc 
b305			 
b305					if DEBUG_FORTH_MATHS 
b305						DMARK "DI1" 
b305				CALLMONITOR 
b305					endif 
b305			 
b305					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b305 cd 59 9b			call macro_forth_dsp_pop 
b308				endm 
# End of macro FORTH_DSP_POP
b308			 
b308			 
b308			 
b308 e1					pop hl    ; result 
b309			 
b309 cd aa 98				call forth_push_numhl 
b30c			 
b30c e1					pop hl    ; reminder 
b30d			;		ld h,0 
b30d			;		ld l,d 
b30d			 
b30d cd aa 98				call forth_push_numhl 
b310			.div_done: 
b310					NEXTW 
b310 c3 13 9c			jp macro_next 
b313				endm 
# End of macro NEXTW
b313			.MUL: 
b313				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b313 19				db WORD_SYS_CORE+5             
b314 58 b3			dw .MIN            
b316 02				db 1 + 1 
b317 .. 00			db "*",0              
b319				endm 
# End of macro CWHEAD
b319			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b319				; TODO add floating point number detection 
b319					if DEBUG_FORTH_WORDS_KEY 
b319						DMARK "MUL" 
b319 f5				push af  
b31a 3a 2e b3			ld a, (.dmark)  
b31d 32 7a ee			ld (debug_mark),a  
b320 3a 2f b3			ld a, (.dmark+1)  
b323 32 7b ee			ld (debug_mark+1),a  
b326 3a 30 b3			ld a, (.dmark+2)  
b329 32 7c ee			ld (debug_mark+2),a  
b32c 18 03			jr .pastdmark  
b32e ..			.dmark: db "MUL"  
b331 f1			.pastdmark: pop af  
b332			endm  
# End of macro DMARK
b332						CALLMONITOR 
b332 cd 1d 93			call break_point_state  
b335				endm  
# End of macro CALLMONITOR
b335					endif 
b335					FORTH_DSP 
b335 cd 67 9a			call macro_forth_dsp 
b338				endm 
# End of macro FORTH_DSP
b338					; v5 FORTH_DSP_VALUE 
b338 7e					ld a,(hl)	; get type of value on TOS 
b339 fe 02				cp DS_TYPE_INUM  
b33b 28 03				jr z, .mul_inum 
b33d			 
b33d				if FORTH_ENABLE_FLOATMATH 
b33d					jr .mul_done 
b33d			 
b33d				endif 
b33d			 
b33d					NEXTW 
b33d c3 13 9c			jp macro_next 
b340				endm 
# End of macro NEXTW
b340			.mul_inum:	 
b340			 
b340					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b340 cd a1 9a			call macro_dsp_valuehl 
b343				endm 
# End of macro FORTH_DSP_VALUEHL
b343			 
b343 e5					push hl 
b344			 
b344					; destroy value TOS 
b344			 
b344					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b344 cd 59 9b			call macro_forth_dsp_pop 
b347				endm 
# End of macro FORTH_DSP_POP
b347			 
b347			 
b347					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b347 cd a1 9a			call macro_dsp_valuehl 
b34a				endm 
# End of macro FORTH_DSP_VALUEHL
b34a			 
b34a					; one value on hl but move to a get other one back 
b34a			 
b34a 7d					ld a, l 
b34b			 
b34b d1					pop de 
b34c			 
b34c					; do the mull 
b34c			;		ex de, hl 
b34c			 
b34c cd 2d 8a				call Mult16 
b34f					; save it 
b34f			 
b34f			;		push hl	 
b34f			 
b34f					; 
b34f			 
b34f					; destroy value TOS 
b34f			 
b34f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b34f cd 59 9b			call macro_forth_dsp_pop 
b352				endm 
# End of macro FORTH_DSP_POP
b352			 
b352					; TODO push value back onto stack for another op etc 
b352			 
b352			;		pop hl 
b352			 
b352 cd aa 98				call forth_push_numhl 
b355			 
b355			.mul_done: 
b355					NEXTW 
b355 c3 13 9c			jp macro_next 
b358				endm 
# End of macro NEXTW
b358			 
b358			 
b358			 
b358			 
b358			.MIN: 
b358				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b358 49				db WORD_SYS_CORE+53             
b359 d9 b3			dw .MAX            
b35b 04				db 3 + 1 
b35c .. 00			db "MIN",0              
b360				endm 
# End of macro CWHEAD
b360			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b360					if DEBUG_FORTH_WORDS_KEY 
b360						DMARK "MIN" 
b360 f5				push af  
b361 3a 75 b3			ld a, (.dmark)  
b364 32 7a ee			ld (debug_mark),a  
b367 3a 76 b3			ld a, (.dmark+1)  
b36a 32 7b ee			ld (debug_mark+1),a  
b36d 3a 77 b3			ld a, (.dmark+2)  
b370 32 7c ee			ld (debug_mark+2),a  
b373 18 03			jr .pastdmark  
b375 ..			.dmark: db "MIN"  
b378 f1			.pastdmark: pop af  
b379			endm  
# End of macro DMARK
b379						CALLMONITOR 
b379 cd 1d 93			call break_point_state  
b37c				endm  
# End of macro CALLMONITOR
b37c					endif 
b37c					; get u2 
b37c			 
b37c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b37c cd a1 9a			call macro_dsp_valuehl 
b37f				endm 
# End of macro FORTH_DSP_VALUEHL
b37f			 
b37f e5					push hl   ; u2 
b380			 
b380					; destroy value TOS 
b380			 
b380					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b380 cd 59 9b			call macro_forth_dsp_pop 
b383				endm 
# End of macro FORTH_DSP_POP
b383			 
b383					; get u1 
b383			 
b383					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b383 cd a1 9a			call macro_dsp_valuehl 
b386				endm 
# End of macro FORTH_DSP_VALUEHL
b386			 
b386 e5					push hl  ; u1 
b387			 
b387					; destroy value TOS 
b387			 
b387					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b387 cd 59 9b			call macro_forth_dsp_pop 
b38a				endm 
# End of macro FORTH_DSP_POP
b38a			 
b38a b7			 or a      ;clear carry flag 
b38b e1			  pop hl    ; u1 
b38c d1			  pop de    ; u2 
b38d e5				push hl   ; saved in case hl is lowest 
b38e ed 52		  sbc hl,de 
b390 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b392			 
b392 e1				pop hl 
b393					if DEBUG_FORTH_WORDS 
b393						DMARK "MIN" 
b393 f5				push af  
b394 3a a8 b3			ld a, (.dmark)  
b397 32 7a ee			ld (debug_mark),a  
b39a 3a a9 b3			ld a, (.dmark+1)  
b39d 32 7b ee			ld (debug_mark+1),a  
b3a0 3a aa b3			ld a, (.dmark+2)  
b3a3 32 7c ee			ld (debug_mark+2),a  
b3a6 18 03			jr .pastdmark  
b3a8 ..			.dmark: db "MIN"  
b3ab f1			.pastdmark: pop af  
b3ac			endm  
# End of macro DMARK
b3ac						CALLMONITOR 
b3ac cd 1d 93			call break_point_state  
b3af				endm  
# End of macro CALLMONITOR
b3af					endif 
b3af cd aa 98				call forth_push_numhl 
b3b2			 
b3b2				       NEXTW 
b3b2 c3 13 9c			jp macro_next 
b3b5				endm 
# End of macro NEXTW
b3b5			 
b3b5			.mincont:  
b3b5 c1				pop bc   ; tidy up 
b3b6 eb				ex de , hl  
b3b7					if DEBUG_FORTH_WORDS 
b3b7						DMARK "MI1" 
b3b7 f5				push af  
b3b8 3a cc b3			ld a, (.dmark)  
b3bb 32 7a ee			ld (debug_mark),a  
b3be 3a cd b3			ld a, (.dmark+1)  
b3c1 32 7b ee			ld (debug_mark+1),a  
b3c4 3a ce b3			ld a, (.dmark+2)  
b3c7 32 7c ee			ld (debug_mark+2),a  
b3ca 18 03			jr .pastdmark  
b3cc ..			.dmark: db "MI1"  
b3cf f1			.pastdmark: pop af  
b3d0			endm  
# End of macro DMARK
b3d0						CALLMONITOR 
b3d0 cd 1d 93			call break_point_state  
b3d3				endm  
# End of macro CALLMONITOR
b3d3					endif 
b3d3 cd aa 98				call forth_push_numhl 
b3d6			 
b3d6				       NEXTW 
b3d6 c3 13 9c			jp macro_next 
b3d9				endm 
# End of macro NEXTW
b3d9			.MAX: 
b3d9				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b3d9 4a				db WORD_SYS_CORE+54             
b3da 5a b4			dw .RND16            
b3dc 04				db 3 + 1 
b3dd .. 00			db "MAX",0              
b3e1				endm 
# End of macro CWHEAD
b3e1			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b3e1					if DEBUG_FORTH_WORDS_KEY 
b3e1						DMARK "MAX" 
b3e1 f5				push af  
b3e2 3a f6 b3			ld a, (.dmark)  
b3e5 32 7a ee			ld (debug_mark),a  
b3e8 3a f7 b3			ld a, (.dmark+1)  
b3eb 32 7b ee			ld (debug_mark+1),a  
b3ee 3a f8 b3			ld a, (.dmark+2)  
b3f1 32 7c ee			ld (debug_mark+2),a  
b3f4 18 03			jr .pastdmark  
b3f6 ..			.dmark: db "MAX"  
b3f9 f1			.pastdmark: pop af  
b3fa			endm  
# End of macro DMARK
b3fa						CALLMONITOR 
b3fa cd 1d 93			call break_point_state  
b3fd				endm  
# End of macro CALLMONITOR
b3fd					endif 
b3fd					; get u2 
b3fd			 
b3fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3fd cd a1 9a			call macro_dsp_valuehl 
b400				endm 
# End of macro FORTH_DSP_VALUEHL
b400			 
b400 e5					push hl   ; u2 
b401			 
b401					; destroy value TOS 
b401			 
b401					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b401 cd 59 9b			call macro_forth_dsp_pop 
b404				endm 
# End of macro FORTH_DSP_POP
b404			 
b404					; get u1 
b404			 
b404					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b404 cd a1 9a			call macro_dsp_valuehl 
b407				endm 
# End of macro FORTH_DSP_VALUEHL
b407			 
b407 e5					push hl  ; u1 
b408			 
b408					; destroy value TOS 
b408			 
b408					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b408 cd 59 9b			call macro_forth_dsp_pop 
b40b				endm 
# End of macro FORTH_DSP_POP
b40b			 
b40b b7			 or a      ;clear carry flag 
b40c e1			  pop hl    ; u1 
b40d d1			  pop de    ; u2 
b40e e5				push hl   ; saved in case hl is lowest 
b40f ed 52		  sbc hl,de 
b411 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b413			 
b413 e1				pop hl 
b414					if DEBUG_FORTH_WORDS 
b414						DMARK "MAX" 
b414 f5				push af  
b415 3a 29 b4			ld a, (.dmark)  
b418 32 7a ee			ld (debug_mark),a  
b41b 3a 2a b4			ld a, (.dmark+1)  
b41e 32 7b ee			ld (debug_mark+1),a  
b421 3a 2b b4			ld a, (.dmark+2)  
b424 32 7c ee			ld (debug_mark+2),a  
b427 18 03			jr .pastdmark  
b429 ..			.dmark: db "MAX"  
b42c f1			.pastdmark: pop af  
b42d			endm  
# End of macro DMARK
b42d						CALLMONITOR 
b42d cd 1d 93			call break_point_state  
b430				endm  
# End of macro CALLMONITOR
b430					endif 
b430 cd aa 98				call forth_push_numhl 
b433			 
b433				       NEXTW 
b433 c3 13 9c			jp macro_next 
b436				endm 
# End of macro NEXTW
b436			 
b436			.maxcont:  
b436 c1				pop bc   ; tidy up 
b437 eb				ex de , hl  
b438					if DEBUG_FORTH_WORDS 
b438						DMARK "MA1" 
b438 f5				push af  
b439 3a 4d b4			ld a, (.dmark)  
b43c 32 7a ee			ld (debug_mark),a  
b43f 3a 4e b4			ld a, (.dmark+1)  
b442 32 7b ee			ld (debug_mark+1),a  
b445 3a 4f b4			ld a, (.dmark+2)  
b448 32 7c ee			ld (debug_mark+2),a  
b44b 18 03			jr .pastdmark  
b44d ..			.dmark: db "MA1"  
b450 f1			.pastdmark: pop af  
b451			endm  
# End of macro DMARK
b451						CALLMONITOR 
b451 cd 1d 93			call break_point_state  
b454				endm  
# End of macro CALLMONITOR
b454					endif 
b454 cd aa 98				call forth_push_numhl 
b457				       NEXTW 
b457 c3 13 9c			jp macro_next 
b45a				endm 
# End of macro NEXTW
b45a			 
b45a			.RND16: 
b45a				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b45a 4e				db WORD_SYS_CORE+58             
b45b 89 b4			dw .RND8            
b45d 06				db 5 + 1 
b45e .. 00			db "RND16",0              
b464				endm 
# End of macro CWHEAD
b464			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b464					if DEBUG_FORTH_WORDS_KEY 
b464						DMARK "R16" 
b464 f5				push af  
b465 3a 79 b4			ld a, (.dmark)  
b468 32 7a ee			ld (debug_mark),a  
b46b 3a 7a b4			ld a, (.dmark+1)  
b46e 32 7b ee			ld (debug_mark+1),a  
b471 3a 7b b4			ld a, (.dmark+2)  
b474 32 7c ee			ld (debug_mark+2),a  
b477 18 03			jr .pastdmark  
b479 ..			.dmark: db "R16"  
b47c f1			.pastdmark: pop af  
b47d			endm  
# End of macro DMARK
b47d						CALLMONITOR 
b47d cd 1d 93			call break_point_state  
b480				endm  
# End of macro CALLMONITOR
b480					endif 
b480 cd d1 89				call prng16  
b483 cd aa 98				call forth_push_numhl 
b486				       NEXTW 
b486 c3 13 9c			jp macro_next 
b489				endm 
# End of macro NEXTW
b489			.RND8: 
b489				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b489 60				db WORD_SYS_CORE+76             
b48a be b4			dw .RND            
b48c 05				db 4 + 1 
b48d .. 00			db "RND8",0              
b492				endm 
# End of macro CWHEAD
b492			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b492					if DEBUG_FORTH_WORDS_KEY 
b492						DMARK "RN8" 
b492 f5				push af  
b493 3a a7 b4			ld a, (.dmark)  
b496 32 7a ee			ld (debug_mark),a  
b499 3a a8 b4			ld a, (.dmark+1)  
b49c 32 7b ee			ld (debug_mark+1),a  
b49f 3a a9 b4			ld a, (.dmark+2)  
b4a2 32 7c ee			ld (debug_mark+2),a  
b4a5 18 03			jr .pastdmark  
b4a7 ..			.dmark: db "RN8"  
b4aa f1			.pastdmark: pop af  
b4ab			endm  
# End of macro DMARK
b4ab						CALLMONITOR 
b4ab cd 1d 93			call break_point_state  
b4ae				endm  
# End of macro CALLMONITOR
b4ae					endif 
b4ae 2a bb eb				ld hl,(xrandc) 
b4b1 23					inc hl 
b4b2 cd eb 89				call xrnd 
b4b5 6f					ld l,a	 
b4b6 26 00				ld h,0 
b4b8 cd aa 98				call forth_push_numhl 
b4bb				       NEXTW 
b4bb c3 13 9c			jp macro_next 
b4be				endm 
# End of macro NEXTW
b4be			.RND: 
b4be				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b4be 60				db WORD_SYS_CORE+76             
b4bf c4 b5			dw .ENDMATHS            
b4c1 04				db 3 + 1 
b4c2 .. 00			db "RND",0              
b4c6				endm 
# End of macro CWHEAD
b4c6			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b4c6			 
b4c6					if DEBUG_FORTH_WORDS_KEY 
b4c6						DMARK "RND" 
b4c6 f5				push af  
b4c7 3a db b4			ld a, (.dmark)  
b4ca 32 7a ee			ld (debug_mark),a  
b4cd 3a dc b4			ld a, (.dmark+1)  
b4d0 32 7b ee			ld (debug_mark+1),a  
b4d3 3a dd b4			ld a, (.dmark+2)  
b4d6 32 7c ee			ld (debug_mark+2),a  
b4d9 18 03			jr .pastdmark  
b4db ..			.dmark: db "RND"  
b4de f1			.pastdmark: pop af  
b4df			endm  
# End of macro DMARK
b4df						CALLMONITOR 
b4df cd 1d 93			call break_point_state  
b4e2				endm  
# End of macro CALLMONITOR
b4e2					endif 
b4e2					 
b4e2					FORTH_DSP_VALUEHL    ; upper range 
b4e2 cd a1 9a			call macro_dsp_valuehl 
b4e5				endm 
# End of macro FORTH_DSP_VALUEHL
b4e5			 
b4e5 22 bf eb				ld (LFSRSeed), hl	 
b4e8			 
b4e8					if DEBUG_FORTH_WORDS 
b4e8						DMARK "RN1" 
b4e8 f5				push af  
b4e9 3a fd b4			ld a, (.dmark)  
b4ec 32 7a ee			ld (debug_mark),a  
b4ef 3a fe b4			ld a, (.dmark+1)  
b4f2 32 7b ee			ld (debug_mark+1),a  
b4f5 3a ff b4			ld a, (.dmark+2)  
b4f8 32 7c ee			ld (debug_mark+2),a  
b4fb 18 03			jr .pastdmark  
b4fd ..			.dmark: db "RN1"  
b500 f1			.pastdmark: pop af  
b501			endm  
# End of macro DMARK
b501						CALLMONITOR 
b501 cd 1d 93			call break_point_state  
b504				endm  
# End of macro CALLMONITOR
b504					endif 
b504					FORTH_DSP_POP 
b504 cd 59 9b			call macro_forth_dsp_pop 
b507				endm 
# End of macro FORTH_DSP_POP
b507			 
b507					FORTH_DSP_VALUEHL    ; low range 
b507 cd a1 9a			call macro_dsp_valuehl 
b50a				endm 
# End of macro FORTH_DSP_VALUEHL
b50a			 
b50a					if DEBUG_FORTH_WORDS 
b50a						DMARK "RN2" 
b50a f5				push af  
b50b 3a 1f b5			ld a, (.dmark)  
b50e 32 7a ee			ld (debug_mark),a  
b511 3a 20 b5			ld a, (.dmark+1)  
b514 32 7b ee			ld (debug_mark+1),a  
b517 3a 21 b5			ld a, (.dmark+2)  
b51a 32 7c ee			ld (debug_mark+2),a  
b51d 18 03			jr .pastdmark  
b51f ..			.dmark: db "RN2"  
b522 f1			.pastdmark: pop af  
b523			endm  
# End of macro DMARK
b523						CALLMONITOR 
b523 cd 1d 93			call break_point_state  
b526				endm  
# End of macro CALLMONITOR
b526					endif 
b526 22 c1 eb				ld (LFSRSeed+2), hl 
b529			 
b529					FORTH_DSP_POP 
b529 cd 59 9b			call macro_forth_dsp_pop 
b52c				endm 
# End of macro FORTH_DSP_POP
b52c			 
b52c e5					push hl 
b52d			 
b52d e1			.inrange:	pop hl 
b52e cd d1 89				call prng16  
b531					if DEBUG_FORTH_WORDS 
b531						DMARK "RN3" 
b531 f5				push af  
b532 3a 46 b5			ld a, (.dmark)  
b535 32 7a ee			ld (debug_mark),a  
b538 3a 47 b5			ld a, (.dmark+1)  
b53b 32 7b ee			ld (debug_mark+1),a  
b53e 3a 48 b5			ld a, (.dmark+2)  
b541 32 7c ee			ld (debug_mark+2),a  
b544 18 03			jr .pastdmark  
b546 ..			.dmark: db "RN3"  
b549 f1			.pastdmark: pop af  
b54a			endm  
# End of macro DMARK
b54a						CALLMONITOR 
b54a cd 1d 93			call break_point_state  
b54d				endm  
# End of macro CALLMONITOR
b54d					endif 
b54d					 
b54d					; if the range is 8bit knock out the high byte 
b54d			 
b54d ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
b551			 
b551 3e 00				ld a, 0 
b553 ba					cp d  
b554 20 1e				jr nz, .hirange 
b556 26 00				ld h, 0   ; knock it down to 8bit 
b558			 
b558					if DEBUG_FORTH_WORDS 
b558						DMARK "RNk" 
b558 f5				push af  
b559 3a 6d b5			ld a, (.dmark)  
b55c 32 7a ee			ld (debug_mark),a  
b55f 3a 6e b5			ld a, (.dmark+1)  
b562 32 7b ee			ld (debug_mark+1),a  
b565 3a 6f b5			ld a, (.dmark+2)  
b568 32 7c ee			ld (debug_mark+2),a  
b56b 18 03			jr .pastdmark  
b56d ..			.dmark: db "RNk"  
b570 f1			.pastdmark: pop af  
b571			endm  
# End of macro DMARK
b571						CALLMONITOR 
b571 cd 1d 93			call break_point_state  
b574				endm  
# End of macro CALLMONITOR
b574					endif 
b574			.hirange:   
b574 e5					push hl  
b575 b7					or a  
b576 ed 52		                sbc hl, de 
b578			 
b578					;call cmp16 
b578			 
b578 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b57a e1					pop hl 
b57b e5					push hl 
b57c			 
b57c					if DEBUG_FORTH_WORDS 
b57c						DMARK "RN4" 
b57c f5				push af  
b57d 3a 91 b5			ld a, (.dmark)  
b580 32 7a ee			ld (debug_mark),a  
b583 3a 92 b5			ld a, (.dmark+1)  
b586 32 7b ee			ld (debug_mark+1),a  
b589 3a 93 b5			ld a, (.dmark+2)  
b58c 32 7c ee			ld (debug_mark+2),a  
b58f 18 03			jr .pastdmark  
b591 ..			.dmark: db "RN4"  
b594 f1			.pastdmark: pop af  
b595			endm  
# End of macro DMARK
b595						CALLMONITOR 
b595 cd 1d 93			call break_point_state  
b598				endm  
# End of macro CALLMONITOR
b598					endif 
b598 ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
b59c					;call cmp16 
b59c				 
b59c b7					or a  
b59d ed 52		                sbc hl, de 
b59f 38 8c				jr c, .inrange 
b5a1			 
b5a1 e1					pop hl 
b5a2					 
b5a2					if DEBUG_FORTH_WORDS 
b5a2						DMARK "RNd" 
b5a2 f5				push af  
b5a3 3a b7 b5			ld a, (.dmark)  
b5a6 32 7a ee			ld (debug_mark),a  
b5a9 3a b8 b5			ld a, (.dmark+1)  
b5ac 32 7b ee			ld (debug_mark+1),a  
b5af 3a b9 b5			ld a, (.dmark+2)  
b5b2 32 7c ee			ld (debug_mark+2),a  
b5b5 18 03			jr .pastdmark  
b5b7 ..			.dmark: db "RNd"  
b5ba f1			.pastdmark: pop af  
b5bb			endm  
# End of macro DMARK
b5bb						CALLMONITOR 
b5bb cd 1d 93			call break_point_state  
b5be				endm  
# End of macro CALLMONITOR
b5be					endif 
b5be			 
b5be			 
b5be cd aa 98				call forth_push_numhl 
b5c1				       NEXTW 
b5c1 c3 13 9c			jp macro_next 
b5c4				endm 
# End of macro NEXTW
b5c4			 
b5c4			.ENDMATHS: 
b5c4			 
b5c4			; eof 
b5c4			 
# End of file forth_words_maths.asm
b5c4			include "forth_words_display.asm" 
b5c4			 
b5c4			; | ## Display Words 
b5c4			 
b5c4			.ATP: 
b5c4				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b5c4 62				db WORD_SYS_CORE+78             
b5c5 3b b6			dw .FB            
b5c7 04				db 3 + 1 
b5c8 .. 00			db "AT?",0              
b5cc				endm 
# End of macro CWHEAD
b5cc			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b5cc					if DEBUG_FORTH_WORDS_KEY 
b5cc						DMARK "AT?" 
b5cc f5				push af  
b5cd 3a e1 b5			ld a, (.dmark)  
b5d0 32 7a ee			ld (debug_mark),a  
b5d3 3a e2 b5			ld a, (.dmark+1)  
b5d6 32 7b ee			ld (debug_mark+1),a  
b5d9 3a e3 b5			ld a, (.dmark+2)  
b5dc 32 7c ee			ld (debug_mark+2),a  
b5df 18 03			jr .pastdmark  
b5e1 ..			.dmark: db "AT?"  
b5e4 f1			.pastdmark: pop af  
b5e5			endm  
# End of macro DMARK
b5e5						CALLMONITOR 
b5e5 cd 1d 93			call break_point_state  
b5e8				endm  
# End of macro CALLMONITOR
b5e8					endif 
b5e8 3a 49 eb				ld a, (f_cursor_ptr) 
b5eb			 
b5eb			if DEBUG_FORTH_WORDS 
b5eb				DMARK "AT?" 
b5eb f5				push af  
b5ec 3a 00 b6			ld a, (.dmark)  
b5ef 32 7a ee			ld (debug_mark),a  
b5f2 3a 01 b6			ld a, (.dmark+1)  
b5f5 32 7b ee			ld (debug_mark+1),a  
b5f8 3a 02 b6			ld a, (.dmark+2)  
b5fb 32 7c ee			ld (debug_mark+2),a  
b5fe 18 03			jr .pastdmark  
b600 ..			.dmark: db "AT?"  
b603 f1			.pastdmark: pop af  
b604			endm  
# End of macro DMARK
b604				CALLMONITOR 
b604 cd 1d 93			call break_point_state  
b607				endm  
# End of macro CALLMONITOR
b607			endif	 
b607					; count the number of rows 
b607			 
b607 06 00				ld b, 0 
b609 4f			.atpr:		ld c, a    ; save in case we go below zero 
b60a d6 28				sub display_cols 
b60c f2 12 b6				jp p, .atprunder 
b60f 04					inc b 
b610 18 f7				jr .atpr 
b612			.atprunder:	 
b612			if DEBUG_FORTH_WORDS 
b612				DMARK "A?2" 
b612 f5				push af  
b613 3a 27 b6			ld a, (.dmark)  
b616 32 7a ee			ld (debug_mark),a  
b619 3a 28 b6			ld a, (.dmark+1)  
b61c 32 7b ee			ld (debug_mark+1),a  
b61f 3a 29 b6			ld a, (.dmark+2)  
b622 32 7c ee			ld (debug_mark+2),a  
b625 18 03			jr .pastdmark  
b627 ..			.dmark: db "A?2"  
b62a f1			.pastdmark: pop af  
b62b			endm  
# End of macro DMARK
b62b				CALLMONITOR 
b62b cd 1d 93			call break_point_state  
b62e				endm  
# End of macro CALLMONITOR
b62e			endif	 
b62e 26 00				ld h, 0 
b630 69					ld l, c 
b631 cd aa 98				call forth_push_numhl 
b634 68					ld l, b  
b635 cd aa 98				call forth_push_numhl 
b638			 
b638			 
b638				NEXTW 
b638 c3 13 9c			jp macro_next 
b63b				endm 
# End of macro NEXTW
b63b			 
b63b			.FB: 
b63b				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b63b 1b				db WORD_SYS_CORE+7             
b63c 89 b6			dw .EMIT            
b63e 03				db 2 + 1 
b63f .. 00			db "FB",0              
b642				endm 
# End of macro CWHEAD
b642			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b642			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b642			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b642			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b642					if DEBUG_FORTH_WORDS_KEY 
b642						DMARK "FB." 
b642 f5				push af  
b643 3a 57 b6			ld a, (.dmark)  
b646 32 7a ee			ld (debug_mark),a  
b649 3a 58 b6			ld a, (.dmark+1)  
b64c 32 7b ee			ld (debug_mark+1),a  
b64f 3a 59 b6			ld a, (.dmark+2)  
b652 32 7c ee			ld (debug_mark+2),a  
b655 18 03			jr .pastdmark  
b657 ..			.dmark: db "FB."  
b65a f1			.pastdmark: pop af  
b65b			endm  
# End of macro DMARK
b65b						CALLMONITOR 
b65b cd 1d 93			call break_point_state  
b65e				endm  
# End of macro CALLMONITOR
b65e					endif 
b65e			 
b65e					FORTH_DSP_VALUEHL 
b65e cd a1 9a			call macro_dsp_valuehl 
b661				endm 
# End of macro FORTH_DSP_VALUEHL
b661			 
b661 7d					ld a, l 
b662 fe 01				cp 1 
b664 20 05				jr nz, .fbn1 
b666 21 1f ed				ld hl, display_fb1 
b669 18 15				jr .fbset 
b66b fe 02		.fbn1:		cp 2 
b66d 20 05				jr nz, .fbn2 
b66f 21 dd eb				ld hl, display_fb2 
b672 18 0c				jr .fbset 
b674 fe 03		.fbn2:		cp 3 
b676 20 05				jr nz, .fbn3 
b678 21 7e ec				ld hl, display_fb3 
b67b 18 03				jr .fbset 
b67d			.fbn3:		 ; if invalid number select first 
b67d 21 1f ed				ld hl, display_fb1 
b680 22 db eb		.fbset:		ld (display_fb_active), hl 
b683			 
b683					FORTH_DSP_POP 
b683 cd 59 9b			call macro_forth_dsp_pop 
b686				endm 
# End of macro FORTH_DSP_POP
b686			 
b686					NEXTW 
b686 c3 13 9c			jp macro_next 
b689				endm 
# End of macro NEXTW
b689			 
b689			 
b689			.EMIT: 
b689				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b689 1b				db WORD_SYS_CORE+7             
b68a da b6			dw .DOTH            
b68c 05				db 4 + 1 
b68d .. 00			db "EMIT",0              
b692				endm 
# End of macro CWHEAD
b692			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b692					; get value off TOS and display it 
b692			 
b692					if DEBUG_FORTH_WORDS_KEY 
b692						DMARK "EMT" 
b692 f5				push af  
b693 3a a7 b6			ld a, (.dmark)  
b696 32 7a ee			ld (debug_mark),a  
b699 3a a8 b6			ld a, (.dmark+1)  
b69c 32 7b ee			ld (debug_mark+1),a  
b69f 3a a9 b6			ld a, (.dmark+2)  
b6a2 32 7c ee			ld (debug_mark+2),a  
b6a5 18 03			jr .pastdmark  
b6a7 ..			.dmark: db "EMT"  
b6aa f1			.pastdmark: pop af  
b6ab			endm  
# End of macro DMARK
b6ab						CALLMONITOR 
b6ab cd 1d 93			call break_point_state  
b6ae				endm  
# End of macro CALLMONITOR
b6ae					endif 
b6ae			 
b6ae					FORTH_DSP_VALUEHL 
b6ae cd a1 9a			call macro_dsp_valuehl 
b6b1				endm 
# End of macro FORTH_DSP_VALUEHL
b6b1			 
b6b1 7d					ld a,l 
b6b2			 
b6b2					; TODO write to display 
b6b2			 
b6b2 32 5e e5				ld (os_input), a 
b6b5 3e 00				ld a, 0 
b6b7 32 5f e5				ld (os_input+1), a 
b6ba					 
b6ba 3a 49 eb				ld a, (f_cursor_ptr) 
b6bd 11 5e e5				ld de, os_input 
b6c0 cd 90 88				call str_at_display 
b6c3			 
b6c3			 
b6c3 3a 27 eb				ld a,(cli_autodisplay) 
b6c6 fe 00				cp 0 
b6c8 28 03				jr z, .enoupdate 
b6ca cd a0 88						call update_display 
b6cd					.enoupdate: 
b6cd			 
b6cd 3a 49 eb				ld a, (f_cursor_ptr) 
b6d0 3c					inc a 
b6d1 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
b6d4			 
b6d4			 
b6d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b6d4 cd 59 9b			call macro_forth_dsp_pop 
b6d7				endm 
# End of macro FORTH_DSP_POP
b6d7			  
b6d7			 
b6d7					NEXTW 
b6d7 c3 13 9c			jp macro_next 
b6da				endm 
# End of macro NEXTW
b6da			.DOTH: 
b6da				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b6da 1c				db WORD_SYS_CORE+8             
b6db 0a b7			dw .DOTF            
b6dd 03				db 2 + 1 
b6de .. 00			db ".-",0              
b6e1				endm 
# End of macro CWHEAD
b6e1			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b6e1					; get value off TOS and display it 
b6e1					if DEBUG_FORTH_WORDS_KEY 
b6e1						DMARK "DTD" 
b6e1 f5				push af  
b6e2 3a f6 b6			ld a, (.dmark)  
b6e5 32 7a ee			ld (debug_mark),a  
b6e8 3a f7 b6			ld a, (.dmark+1)  
b6eb 32 7b ee			ld (debug_mark+1),a  
b6ee 3a f8 b6			ld a, (.dmark+2)  
b6f1 32 7c ee			ld (debug_mark+2),a  
b6f4 18 03			jr .pastdmark  
b6f6 ..			.dmark: db "DTD"  
b6f9 f1			.pastdmark: pop af  
b6fa			endm  
# End of macro DMARK
b6fa						CALLMONITOR 
b6fa cd 1d 93			call break_point_state  
b6fd				endm  
# End of macro CALLMONITOR
b6fd					endif 
b6fd 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
b6ff 3e 00			ld a, 0 
b701 32 28 eb			ld (cli_mvdot), a 
b704 c3 61 b7			jp .dotgo 
b707				NEXTW 
b707 c3 13 9c			jp macro_next 
b70a				endm 
# End of macro NEXTW
b70a			.DOTF: 
b70a				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
b70a 1c				db WORD_SYS_CORE+8             
b70b 38 b7			dw .DOT            
b70d 03				db 2 + 1 
b70e .. 00			db ".>",0              
b711				endm 
# End of macro CWHEAD
b711			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
b711					; get value off TOS and display it 
b711			        ; TODO BUG adds extra spaces 
b711			        ; TODO BUG handle numerics? 
b711					if DEBUG_FORTH_WORDS_KEY 
b711						DMARK "DTC" 
b711 f5				push af  
b712 3a 26 b7			ld a, (.dmark)  
b715 32 7a ee			ld (debug_mark),a  
b718 3a 27 b7			ld a, (.dmark+1)  
b71b 32 7b ee			ld (debug_mark+1),a  
b71e 3a 28 b7			ld a, (.dmark+2)  
b721 32 7c ee			ld (debug_mark+2),a  
b724 18 03			jr .pastdmark  
b726 ..			.dmark: db "DTC"  
b729 f1			.pastdmark: pop af  
b72a			endm  
# End of macro DMARK
b72a						CALLMONITOR 
b72a cd 1d 93			call break_point_state  
b72d				endm  
# End of macro CALLMONITOR
b72d					endif 
b72d 3e 01			ld a, 1 
b72f 32 28 eb			ld (cli_mvdot), a 
b732 c3 61 b7			jp .dotgo 
b735				NEXTW 
b735 c3 13 9c			jp macro_next 
b738				endm 
# End of macro NEXTW
b738			 
b738			.DOT: 
b738				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
b738 1c				db WORD_SYS_CORE+8             
b739 c4 b7			dw .CLS            
b73b 02				db 1 + 1 
b73c .. 00			db ".",0              
b73e				endm 
# End of macro CWHEAD
b73e			        ; | . ( u -- ) Display TOS | DONE 
b73e					; get value off TOS and display it 
b73e			 
b73e					if DEBUG_FORTH_WORDS_KEY 
b73e						DMARK "DOT" 
b73e f5				push af  
b73f 3a 53 b7			ld a, (.dmark)  
b742 32 7a ee			ld (debug_mark),a  
b745 3a 54 b7			ld a, (.dmark+1)  
b748 32 7b ee			ld (debug_mark+1),a  
b74b 3a 55 b7			ld a, (.dmark+2)  
b74e 32 7c ee			ld (debug_mark+2),a  
b751 18 03			jr .pastdmark  
b753 ..			.dmark: db "DOT"  
b756 f1			.pastdmark: pop af  
b757			endm  
# End of macro DMARK
b757						CALLMONITOR 
b757 cd 1d 93			call break_point_state  
b75a				endm  
# End of macro CALLMONITOR
b75a					endif 
b75a 3e 00			ld a, 0 
b75c 32 28 eb			ld (cli_mvdot), a 
b75f 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
b761				 
b761			 
b761			.dotgo: 
b761			 
b761			; move up type to on stack for parserv5 
b761					FORTH_DSP 
b761 cd 67 9a			call macro_forth_dsp 
b764				endm 
# End of macro FORTH_DSP
b764				;FORTH_DSP_VALUE  
b764			 
b764			if DEBUG_FORTH_DOT 
b764				DMARK "DOT" 
b764				CALLMONITOR 
b764			endif	 
b764			;		.print: 
b764			 
b764 7e				ld a,(hl)  ; work out what type of value is on the TOS 
b765 23				inc hl   ; position to the actual value 
b766 fe 01			cp DS_TYPE_STR 
b768 20 06			jr nz, .dotnum1  
b76a			 
b76a			; display string 
b76a				FORTH_DSP_VALUE  
b76a cd 8a 9a			call macro_forth_dsp_value 
b76d				endm 
# End of macro FORTH_DSP_VALUE
b76d eb				ex de,hl 
b76e 18 11			jr .dotwrite 
b770			 
b770			.dotnum1: 
b770 fe 02			cp DS_TYPE_INUM 
b772 20 0c			jr nz, .dotflot 
b774			 
b774			 
b774			; display number 
b774			 
b774			;	push hl 
b774			;	call clear_display 
b774			;	pop hl 
b774			 
b774 5e				ld e, (hl) 
b775 23				inc hl 
b776 56				ld d, (hl) 
b777 21 60 e3			ld hl, scratch 
b77a			if DEBUG_FORTH_DOT 
b77a				DMARK "DT1" 
b77a				CALLMONITOR 
b77a			endif	 
b77a			 
b77a cd b7 8e			call uitoa_16 
b77d eb				ex de,hl 
b77e			 
b77e			if DEBUG_FORTH_DOT 
b77e				DMARK "DT2" 
b77e				CALLMONITOR 
b77e			endif	 
b77e			 
b77e			;	ld de, os_word_scratch 
b77e 18 01			jr .dotwrite 
b780			 
b780 00			.dotflot:   nop 
b781			; TODO print floating point number 
b781			 
b781			.dotwrite:		 
b781			 
b781					; if c is set then set all '-' to spaces 
b781					; need to also take into account .>  
b781			 
b781 3e 01				ld a, 1 
b783 b9					cp c 
b784 20 13				jr nz, .nodashswap 
b786			 
b786					; DE has the string to write, working with HL 
b786			 
b786 06 ff				ld b, 255 
b788 d5					push de 
b789 e1					pop hl 
b78a			 
b78a			if DEBUG_FORTH_DOT 
b78a				DMARK "DT-" 
b78a				CALLMONITOR 
b78a			endif	 
b78a 7e			.dashscan:	ld a, (hl) 
b78b fe 00				cp 0 
b78d 28 0a				jr z, .nodashswap 
b78f fe 2d				cp '-' 
b791 20 03				jr nz, .dashskip 
b793 3e 20				ld a, ' ' 
b795 77					ld (hl), a 
b796 23			.dashskip:	inc hl 
b797			if DEBUG_FORTH_DOT 
b797				DMARK "D-2" 
b797				CALLMONITOR 
b797			endif	 
b797 10 f1				djnz .dashscan 
b799			 
b799			if DEBUG_FORTH_DOT 
b799				DMARK "D-1" 
b799				CALLMONITOR 
b799			endif	 
b799			 
b799			.nodashswap: 
b799			 
b799 e5					push hl   ; save string start in case we need to advance print 
b79a			 
b79a 3a 49 eb				ld a, (f_cursor_ptr) 
b79d cd 90 88				call str_at_display 
b7a0 3a 27 eb				ld a,(cli_autodisplay) 
b7a3 fe 00				cp 0 
b7a5 28 03				jr z, .noupdate 
b7a7 cd a0 88						call update_display 
b7aa					.noupdate: 
b7aa			 
b7aa			 
b7aa					; see if we need to advance the print position 
b7aa			 
b7aa e1					pop hl   ; get back string 
b7ab			 
b7ab 3a 28 eb				ld a, (cli_mvdot) 
b7ae			if DEBUG_FORTH_DOT 
b7ae					ld e,a 
b7ae				DMARK "D>1" 
b7ae				CALLMONITOR 
b7ae			endif	 
b7ae fe 00				cp 0 
b7b0 28 0c				jr z, .noadv 
b7b2					; yes, lets advance the print position 
b7b2 3e 00				ld a, 0 
b7b4 cd 13 8f				call strlent 
b7b7 3a 49 eb				ld a, (f_cursor_ptr) 
b7ba 85					add a,l 
b7bb					;call addatohl 
b7bb					;ld a, l 
b7bb 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
b7be			 
b7be			if DEBUG_FORTH_DOT 
b7be				DMARK "D->" 
b7be				CALLMONITOR 
b7be			endif	 
b7be			 
b7be			.noadv:	 
b7be			 
b7be					if DEBUG_FORTH_DOT_WAIT 
b7be							call next_page_prompt 
b7be					endif	 
b7be			; TODO this pop off the stack causes a crash. i dont know why 
b7be			 
b7be			 
b7be			if DEBUG_FORTH_DOT 
b7be				DMARK "DTh" 
b7be				CALLMONITOR 
b7be			endif	 
b7be			 
b7be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7be cd 59 9b			call macro_forth_dsp_pop 
b7c1				endm 
# End of macro FORTH_DSP_POP
b7c1			 
b7c1			if DEBUG_FORTH_DOT 
b7c1				DMARK "DTi" 
b7c1				CALLMONITOR 
b7c1			endif	 
b7c1			 
b7c1			 
b7c1					NEXTW 
b7c1 c3 13 9c			jp macro_next 
b7c4				endm 
# End of macro NEXTW
b7c4			 
b7c4			.CLS: 
b7c4				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
b7c4 35				db WORD_SYS_CORE+33             
b7c5 f1 b7			dw .DRAW            
b7c7 04				db 3 + 1 
b7c8 .. 00			db "CLS",0              
b7cc				endm 
# End of macro CWHEAD
b7cc			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
b7cc					if DEBUG_FORTH_WORDS_KEY 
b7cc						DMARK "CLS" 
b7cc f5				push af  
b7cd 3a e1 b7			ld a, (.dmark)  
b7d0 32 7a ee			ld (debug_mark),a  
b7d3 3a e2 b7			ld a, (.dmark+1)  
b7d6 32 7b ee			ld (debug_mark+1),a  
b7d9 3a e3 b7			ld a, (.dmark+2)  
b7dc 32 7c ee			ld (debug_mark+2),a  
b7df 18 03			jr .pastdmark  
b7e1 ..			.dmark: db "CLS"  
b7e4 f1			.pastdmark: pop af  
b7e5			endm  
# End of macro DMARK
b7e5						CALLMONITOR 
b7e5 cd 1d 93			call break_point_state  
b7e8				endm  
# End of macro CALLMONITOR
b7e8					endif 
b7e8 cd 7d 88				call clear_display 
b7eb c3 ff b8				jp .home		; and home cursor 
b7ee					NEXTW 
b7ee c3 13 9c			jp macro_next 
b7f1				endm 
# End of macro NEXTW
b7f1			 
b7f1			.DRAW: 
b7f1				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
b7f1 36				db WORD_SYS_CORE+34             
b7f2 1c b8			dw .DUMP            
b7f4 05				db 4 + 1 
b7f5 .. 00			db "DRAW",0              
b7fa				endm 
# End of macro CWHEAD
b7fa			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
b7fa					if DEBUG_FORTH_WORDS_KEY 
b7fa						DMARK "DRW" 
b7fa f5				push af  
b7fb 3a 0f b8			ld a, (.dmark)  
b7fe 32 7a ee			ld (debug_mark),a  
b801 3a 10 b8			ld a, (.dmark+1)  
b804 32 7b ee			ld (debug_mark+1),a  
b807 3a 11 b8			ld a, (.dmark+2)  
b80a 32 7c ee			ld (debug_mark+2),a  
b80d 18 03			jr .pastdmark  
b80f ..			.dmark: db "DRW"  
b812 f1			.pastdmark: pop af  
b813			endm  
# End of macro DMARK
b813						CALLMONITOR 
b813 cd 1d 93			call break_point_state  
b816				endm  
# End of macro CALLMONITOR
b816					endif 
b816 cd a0 88				call update_display 
b819					NEXTW 
b819 c3 13 9c			jp macro_next 
b81c				endm 
# End of macro NEXTW
b81c			 
b81c			.DUMP: 
b81c				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
b81c 37				db WORD_SYS_CORE+35             
b81d 54 b8			dw .CDUMP            
b81f 05				db 4 + 1 
b820 .. 00			db "DUMP",0              
b825				endm 
# End of macro CWHEAD
b825			; | DUMP ( x -- ) With address x display dump   | DONE 
b825			; TODO pop address to use off of the stack 
b825					if DEBUG_FORTH_WORDS_KEY 
b825						DMARK "DUM" 
b825 f5				push af  
b826 3a 3a b8			ld a, (.dmark)  
b829 32 7a ee			ld (debug_mark),a  
b82c 3a 3b b8			ld a, (.dmark+1)  
b82f 32 7b ee			ld (debug_mark+1),a  
b832 3a 3c b8			ld a, (.dmark+2)  
b835 32 7c ee			ld (debug_mark+2),a  
b838 18 03			jr .pastdmark  
b83a ..			.dmark: db "DUM"  
b83d f1			.pastdmark: pop af  
b83e			endm  
# End of macro DMARK
b83e						CALLMONITOR 
b83e cd 1d 93			call break_point_state  
b841				endm  
# End of macro CALLMONITOR
b841					endif 
b841 cd 7d 88				call clear_display 
b844			 
b844					; get address 
b844			 
b844					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b844 cd a1 9a			call macro_dsp_valuehl 
b847				endm 
# End of macro FORTH_DSP_VALUEHL
b847				 
b847					; save it for cdump 
b847			 
b847 22 83 e6				ld (os_cur_ptr),hl 
b84a			 
b84a					; destroy value TOS 
b84a			 
b84a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b84a cd 59 9b			call macro_forth_dsp_pop 
b84d				endm 
# End of macro FORTH_DSP_POP
b84d			 
b84d cd 2a 97				call dumpcont	; skip old style of param parsing	 
b850 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
b851					NEXTW 
b851 c3 13 9c			jp macro_next 
b854				endm 
# End of macro NEXTW
b854			.CDUMP: 
b854				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
b854 38				db WORD_SYS_CORE+36             
b855 84 b8			dw .DAT            
b857 06				db 5 + 1 
b858 .. 00			db "CDUMP",0              
b85e				endm 
# End of macro CWHEAD
b85e			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
b85e					if DEBUG_FORTH_WORDS_KEY 
b85e						DMARK "CDP" 
b85e f5				push af  
b85f 3a 73 b8			ld a, (.dmark)  
b862 32 7a ee			ld (debug_mark),a  
b865 3a 74 b8			ld a, (.dmark+1)  
b868 32 7b ee			ld (debug_mark+1),a  
b86b 3a 75 b8			ld a, (.dmark+2)  
b86e 32 7c ee			ld (debug_mark+2),a  
b871 18 03			jr .pastdmark  
b873 ..			.dmark: db "CDP"  
b876 f1			.pastdmark: pop af  
b877			endm  
# End of macro DMARK
b877						CALLMONITOR 
b877 cd 1d 93			call break_point_state  
b87a				endm  
# End of macro CALLMONITOR
b87a					endif 
b87a cd 7d 88				call clear_display 
b87d cd 2a 97				call dumpcont	 
b880 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
b881					NEXTW 
b881 c3 13 9c			jp macro_next 
b884				endm 
# End of macro NEXTW
b884			 
b884			 
b884			 
b884			 
b884			.DAT: 
b884				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
b884 3d				db WORD_SYS_CORE+41             
b885 da b8			dw .HOME            
b887 03				db 2 + 1 
b888 .. 00			db "AT",0              
b88b				endm 
# End of macro CWHEAD
b88b			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
b88b					if DEBUG_FORTH_WORDS_KEY 
b88b						DMARK "AT." 
b88b f5				push af  
b88c 3a a0 b8			ld a, (.dmark)  
b88f 32 7a ee			ld (debug_mark),a  
b892 3a a1 b8			ld a, (.dmark+1)  
b895 32 7b ee			ld (debug_mark+1),a  
b898 3a a2 b8			ld a, (.dmark+2)  
b89b 32 7c ee			ld (debug_mark+2),a  
b89e 18 03			jr .pastdmark  
b8a0 ..			.dmark: db "AT."  
b8a3 f1			.pastdmark: pop af  
b8a4			endm  
# End of macro DMARK
b8a4						CALLMONITOR 
b8a4 cd 1d 93			call break_point_state  
b8a7				endm  
# End of macro CALLMONITOR
b8a7					endif 
b8a7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8a7 cd a1 9a			call macro_dsp_valuehl 
b8aa				endm 
# End of macro FORTH_DSP_VALUEHL
b8aa			 
b8aa			 
b8aa					; TODO save cursor row 
b8aa 7d					ld a,l 
b8ab fe 02				cp 2 
b8ad 20 04				jr nz, .crow3 
b8af 3e 28				ld a, display_row_2 
b8b1 18 12				jr .ccol1 
b8b3 fe 03		.crow3:		cp 3 
b8b5 20 04				jr nz, .crow4 
b8b7 3e 50				ld a, display_row_3 
b8b9 18 0a				jr .ccol1 
b8bb fe 04		.crow4:		cp 4 
b8bd 20 04				jr nz, .crow1 
b8bf 3e 78				ld a, display_row_4 
b8c1 18 02				jr .ccol1 
b8c3 3e 00		.crow1:		ld a,display_row_1 
b8c5 f5			.ccol1:		push af			; got row offset 
b8c6 6f					ld l,a 
b8c7 26 00				ld h,0 
b8c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8c9 cd 59 9b			call macro_forth_dsp_pop 
b8cc				endm 
# End of macro FORTH_DSP_POP
b8cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8cc cd a1 9a			call macro_dsp_valuehl 
b8cf				endm 
# End of macro FORTH_DSP_VALUEHL
b8cf					; TODO save cursor col 
b8cf f1					pop af 
b8d0 85					add l		; add col offset 
b8d1 32 49 eb				ld (f_cursor_ptr), a 
b8d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8d4 cd 59 9b			call macro_forth_dsp_pop 
b8d7				endm 
# End of macro FORTH_DSP_POP
b8d7			 
b8d7					; calculate  
b8d7			 
b8d7					NEXTW 
b8d7 c3 13 9c			jp macro_next 
b8da				endm 
# End of macro NEXTW
b8da			 
b8da			 
b8da			.HOME: 
b8da				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
b8da 41				db WORD_SYS_CORE+45             
b8db 07 b9			dw .SPACE            
b8dd 05				db 4 + 1 
b8de .. 00			db "HOME",0              
b8e3				endm 
# End of macro CWHEAD
b8e3			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
b8e3					if DEBUG_FORTH_WORDS_KEY 
b8e3						DMARK "HOM" 
b8e3 f5				push af  
b8e4 3a f8 b8			ld a, (.dmark)  
b8e7 32 7a ee			ld (debug_mark),a  
b8ea 3a f9 b8			ld a, (.dmark+1)  
b8ed 32 7b ee			ld (debug_mark+1),a  
b8f0 3a fa b8			ld a, (.dmark+2)  
b8f3 32 7c ee			ld (debug_mark+2),a  
b8f6 18 03			jr .pastdmark  
b8f8 ..			.dmark: db "HOM"  
b8fb f1			.pastdmark: pop af  
b8fc			endm  
# End of macro DMARK
b8fc						CALLMONITOR 
b8fc cd 1d 93			call break_point_state  
b8ff				endm  
# End of macro CALLMONITOR
b8ff					endif 
b8ff 3e 00		.home:		ld a, 0		; and home cursor 
b901 32 49 eb				ld (f_cursor_ptr), a 
b904					NEXTW 
b904 c3 13 9c			jp macro_next 
b907				endm 
# End of macro NEXTW
b907			 
b907			 
b907			.SPACE: 
b907				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
b907 46				db WORD_SYS_CORE+50             
b908 35 b9			dw .SPACES            
b90a 03				db 2 + 1 
b90b .. 00			db "BL",0              
b90e				endm 
# End of macro CWHEAD
b90e			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
b90e					if DEBUG_FORTH_WORDS_KEY 
b90e						DMARK "BL." 
b90e f5				push af  
b90f 3a 23 b9			ld a, (.dmark)  
b912 32 7a ee			ld (debug_mark),a  
b915 3a 24 b9			ld a, (.dmark+1)  
b918 32 7b ee			ld (debug_mark+1),a  
b91b 3a 25 b9			ld a, (.dmark+2)  
b91e 32 7c ee			ld (debug_mark+2),a  
b921 18 03			jr .pastdmark  
b923 ..			.dmark: db "BL."  
b926 f1			.pastdmark: pop af  
b927			endm  
# End of macro DMARK
b927						CALLMONITOR 
b927 cd 1d 93			call break_point_state  
b92a				endm  
# End of macro CALLMONITOR
b92a					endif 
b92a 21 33 b9				ld hl, .blstr 
b92d cd 18 99				call forth_push_str 
b930					 
b930				       NEXTW 
b930 c3 13 9c			jp macro_next 
b933				endm 
# End of macro NEXTW
b933			 
b933 .. 00		.blstr: db " ", 0 
b935			 
b935			.SPACES: 
b935				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
b935 47				db WORD_SYS_CORE+51             
b936 d0 b9			dw .SCROLL            
b938 07				db 6 + 1 
b939 .. 00			db "SPACES",0              
b940				endm 
# End of macro CWHEAD
b940			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
b940					if DEBUG_FORTH_WORDS_KEY 
b940						DMARK "SPS" 
b940 f5				push af  
b941 3a 55 b9			ld a, (.dmark)  
b944 32 7a ee			ld (debug_mark),a  
b947 3a 56 b9			ld a, (.dmark+1)  
b94a 32 7b ee			ld (debug_mark+1),a  
b94d 3a 57 b9			ld a, (.dmark+2)  
b950 32 7c ee			ld (debug_mark+2),a  
b953 18 03			jr .pastdmark  
b955 ..			.dmark: db "SPS"  
b958 f1			.pastdmark: pop af  
b959			endm  
# End of macro DMARK
b959						CALLMONITOR 
b959 cd 1d 93			call break_point_state  
b95c				endm  
# End of macro CALLMONITOR
b95c					endif 
b95c			 
b95c			 
b95c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b95c cd a1 9a			call macro_dsp_valuehl 
b95f				endm 
# End of macro FORTH_DSP_VALUEHL
b95f			 
b95f			;		push hl    ; u 
b95f					if DEBUG_FORTH_WORDS 
b95f						DMARK "SPA" 
b95f f5				push af  
b960 3a 74 b9			ld a, (.dmark)  
b963 32 7a ee			ld (debug_mark),a  
b966 3a 75 b9			ld a, (.dmark+1)  
b969 32 7b ee			ld (debug_mark+1),a  
b96c 3a 76 b9			ld a, (.dmark+2)  
b96f 32 7c ee			ld (debug_mark+2),a  
b972 18 03			jr .pastdmark  
b974 ..			.dmark: db "SPA"  
b977 f1			.pastdmark: pop af  
b978			endm  
# End of macro DMARK
b978						CALLMONITOR 
b978 cd 1d 93			call break_point_state  
b97b				endm  
# End of macro CALLMONITOR
b97b					endif 
b97b			 
b97b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b97b cd 59 9b			call macro_forth_dsp_pop 
b97e				endm 
# End of macro FORTH_DSP_POP
b97e			;		pop hl 
b97e 4d					ld c, l 
b97f 06 00				ld b, 0 
b981 21 60 e3				ld hl, scratch  
b984			 
b984					if DEBUG_FORTH_WORDS 
b984						DMARK "SP2" 
b984 f5				push af  
b985 3a 99 b9			ld a, (.dmark)  
b988 32 7a ee			ld (debug_mark),a  
b98b 3a 9a b9			ld a, (.dmark+1)  
b98e 32 7b ee			ld (debug_mark+1),a  
b991 3a 9b b9			ld a, (.dmark+2)  
b994 32 7c ee			ld (debug_mark+2),a  
b997 18 03			jr .pastdmark  
b999 ..			.dmark: db "SP2"  
b99c f1			.pastdmark: pop af  
b99d			endm  
# End of macro DMARK
b99d						CALLMONITOR 
b99d cd 1d 93			call break_point_state  
b9a0				endm  
# End of macro CALLMONITOR
b9a0					endif 
b9a0 3e 20				ld a, ' ' 
b9a2 c5			.spaces1:	push bc 
b9a3 77					ld (hl),a 
b9a4 23					inc hl 
b9a5 c1					pop bc 
b9a6 10 fa				djnz .spaces1 
b9a8 3e 00				ld a,0 
b9aa 77					ld (hl),a 
b9ab 21 60 e3				ld hl, scratch 
b9ae					if DEBUG_FORTH_WORDS 
b9ae						DMARK "SP3" 
b9ae f5				push af  
b9af 3a c3 b9			ld a, (.dmark)  
b9b2 32 7a ee			ld (debug_mark),a  
b9b5 3a c4 b9			ld a, (.dmark+1)  
b9b8 32 7b ee			ld (debug_mark+1),a  
b9bb 3a c5 b9			ld a, (.dmark+2)  
b9be 32 7c ee			ld (debug_mark+2),a  
b9c1 18 03			jr .pastdmark  
b9c3 ..			.dmark: db "SP3"  
b9c6 f1			.pastdmark: pop af  
b9c7			endm  
# End of macro DMARK
b9c7						CALLMONITOR 
b9c7 cd 1d 93			call break_point_state  
b9ca				endm  
# End of macro CALLMONITOR
b9ca					endif 
b9ca cd 13 9a				call forth_apush 
b9cd			 
b9cd				       NEXTW 
b9cd c3 13 9c			jp macro_next 
b9d0				endm 
# End of macro NEXTW
b9d0			 
b9d0			 
b9d0			 
b9d0			.SCROLL: 
b9d0				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
b9d0 53				db WORD_SYS_CORE+63             
b9d1 fd b9			dw .SCROLLD            
b9d3 07				db 6 + 1 
b9d4 .. 00			db "SCROLL",0              
b9db				endm 
# End of macro CWHEAD
b9db			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
b9db					if DEBUG_FORTH_WORDS_KEY 
b9db						DMARK "SCR" 
b9db f5				push af  
b9dc 3a f0 b9			ld a, (.dmark)  
b9df 32 7a ee			ld (debug_mark),a  
b9e2 3a f1 b9			ld a, (.dmark+1)  
b9e5 32 7b ee			ld (debug_mark+1),a  
b9e8 3a f2 b9			ld a, (.dmark+2)  
b9eb 32 7c ee			ld (debug_mark+2),a  
b9ee 18 03			jr .pastdmark  
b9f0 ..			.dmark: db "SCR"  
b9f3 f1			.pastdmark: pop af  
b9f4			endm  
# End of macro DMARK
b9f4						CALLMONITOR 
b9f4 cd 1d 93			call break_point_state  
b9f7				endm  
# End of macro CALLMONITOR
b9f7					endif 
b9f7			 
b9f7 cd 3f 88			call scroll_up 
b9fa			;	call update_display 
b9fa			 
b9fa					NEXTW 
b9fa c3 13 9c			jp macro_next 
b9fd				endm 
# End of macro NEXTW
b9fd			 
b9fd			 
b9fd			 
b9fd			;		; get dir 
b9fd			; 
b9fd			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9fd			; 
b9fd			;		push hl 
b9fd			; 
b9fd			;		; destroy value TOS 
b9fd			; 
b9fd			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9fd			; 
b9fd			;		; get count 
b9fd			; 
b9fd			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9fd			; 
b9fd			;		push hl 
b9fd			; 
b9fd			;		; destroy value TOS 
b9fd			; 
b9fd			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9fd			; 
b9fd			;		; one value on hl get other one back 
b9fd			; 
b9fd			;		pop bc    ; count 
b9fd			; 
b9fd			;		pop de   ; dir 
b9fd			; 
b9fd			; 
b9fd			;		ld b, c 
b9fd			; 
b9fd			;.scrolldir:     push bc 
b9fd			;		push de 
b9fd			; 
b9fd			;		ld a, 0 
b9fd			;		cp e 
b9fd			;		jr z, .scrollup  
b9fd			;		call scroll_down 
b9fd			;		jr .scrollnext 
b9fd			;.scrollup:	call scroll_up 
b9fd			; 
b9fd			;		 
b9fd			;.scrollnext: 
b9fd			;		pop de 
b9fd			;		pop bc 
b9fd			;		djnz .scrolldir 
b9fd			; 
b9fd			; 
b9fd			; 
b9fd			; 
b9fd			; 
b9fd			;		NEXTW 
b9fd			 
b9fd			.SCROLLD: 
b9fd				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
b9fd 53				db WORD_SYS_CORE+63             
b9fe 2b ba			dw .ATQ            
ba00 08				db 7 + 1 
ba01 .. 00			db "SCROLLD",0              
ba09				endm 
# End of macro CWHEAD
ba09			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
ba09					if DEBUG_FORTH_WORDS_KEY 
ba09						DMARK "SCD" 
ba09 f5				push af  
ba0a 3a 1e ba			ld a, (.dmark)  
ba0d 32 7a ee			ld (debug_mark),a  
ba10 3a 1f ba			ld a, (.dmark+1)  
ba13 32 7b ee			ld (debug_mark+1),a  
ba16 3a 20 ba			ld a, (.dmark+2)  
ba19 32 7c ee			ld (debug_mark+2),a  
ba1c 18 03			jr .pastdmark  
ba1e ..			.dmark: db "SCD"  
ba21 f1			.pastdmark: pop af  
ba22			endm  
# End of macro DMARK
ba22						CALLMONITOR 
ba22 cd 1d 93			call break_point_state  
ba25				endm  
# End of macro CALLMONITOR
ba25					endif 
ba25			 
ba25 cd 63 88			call scroll_down 
ba28			;	call update_display 
ba28			 
ba28					NEXTW 
ba28 c3 13 9c			jp macro_next 
ba2b				endm 
# End of macro NEXTW
ba2b			 
ba2b			 
ba2b			.ATQ: 
ba2b				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
ba2b 62				db WORD_SYS_CORE+78             
ba2c 89 ba			dw .AUTODSP            
ba2e 04				db 3 + 1 
ba2f .. 00			db "AT@",0              
ba33				endm 
# End of macro CWHEAD
ba33			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
ba33					if DEBUG_FORTH_WORDS_KEY 
ba33						DMARK "ATA" 
ba33 f5				push af  
ba34 3a 48 ba			ld a, (.dmark)  
ba37 32 7a ee			ld (debug_mark),a  
ba3a 3a 49 ba			ld a, (.dmark+1)  
ba3d 32 7b ee			ld (debug_mark+1),a  
ba40 3a 4a ba			ld a, (.dmark+2)  
ba43 32 7c ee			ld (debug_mark+2),a  
ba46 18 03			jr .pastdmark  
ba48 ..			.dmark: db "ATA"  
ba4b f1			.pastdmark: pop af  
ba4c			endm  
# End of macro DMARK
ba4c						CALLMONITOR 
ba4c cd 1d 93			call break_point_state  
ba4f				endm  
# End of macro CALLMONITOR
ba4f					endif 
ba4f			 
ba4f			 
ba4f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba4f cd a1 9a			call macro_dsp_valuehl 
ba52				endm 
# End of macro FORTH_DSP_VALUEHL
ba52			 
ba52					; TODO save cursor row 
ba52 7d					ld a,l 
ba53 fe 02				cp 2 
ba55 20 04				jr nz, .crow3aq 
ba57 3e 28				ld a, display_row_2 
ba59 18 12				jr .ccol1aq 
ba5b fe 03		.crow3aq:		cp 3 
ba5d 20 04				jr nz, .crow4aq 
ba5f 3e 50				ld a, display_row_3 
ba61 18 0a				jr .ccol1aq 
ba63 fe 04		.crow4aq:		cp 4 
ba65 20 04				jr nz, .crow1aq 
ba67 3e 78				ld a, display_row_4 
ba69 18 02				jr .ccol1aq 
ba6b 3e 00		.crow1aq:		ld a,display_row_1 
ba6d f5			.ccol1aq:		push af			; got row offset 
ba6e 6f					ld l,a 
ba6f 26 00				ld h,0 
ba71					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba71 cd 59 9b			call macro_forth_dsp_pop 
ba74				endm 
# End of macro FORTH_DSP_POP
ba74					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba74 cd a1 9a			call macro_dsp_valuehl 
ba77				endm 
# End of macro FORTH_DSP_VALUEHL
ba77					; TODO save cursor col 
ba77 f1					pop af 
ba78 85					add l		; add col offset 
ba79			 
ba79					; add current frame buffer address 
ba79 2a db eb				ld hl, (display_fb_active) 
ba7c cd aa 8a				call addatohl 
ba7f			 
ba7f			 
ba7f			 
ba7f			 
ba7f					; get char frame buffer location offset in hl 
ba7f			 
ba7f 7e					ld a,(hl) 
ba80 26 00				ld h, 0 
ba82 6f					ld l, a 
ba83			 
ba83 cd aa 98				call forth_push_numhl 
ba86			 
ba86			 
ba86					NEXTW 
ba86 c3 13 9c			jp macro_next 
ba89				endm 
# End of macro NEXTW
ba89			 
ba89			.AUTODSP: 
ba89				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
ba89 63				db WORD_SYS_CORE+79             
ba8a 9f ba			dw .MENU            
ba8c 05				db 4 + 1 
ba8d .. 00			db "ADSP",0              
ba92				endm 
# End of macro CWHEAD
ba92			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
ba92			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
ba92			 
ba92					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba92 cd a1 9a			call macro_dsp_valuehl 
ba95				endm 
# End of macro FORTH_DSP_VALUEHL
ba95			 
ba95			;		push hl 
ba95			 
ba95					; destroy value TOS 
ba95			 
ba95					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba95 cd 59 9b			call macro_forth_dsp_pop 
ba98				endm 
# End of macro FORTH_DSP_POP
ba98			 
ba98			;		pop hl 
ba98			 
ba98 7d					ld a,l 
ba99 32 27 eb				ld (cli_autodisplay), a 
ba9c				       NEXTW 
ba9c c3 13 9c			jp macro_next 
ba9f				endm 
# End of macro NEXTW
ba9f			 
ba9f			.MENU: 
ba9f				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
ba9f 70				db WORD_SYS_CORE+92             
baa0 48 bb			dw .ENDDISPLAY            
baa2 05				db 4 + 1 
baa3 .. 00			db "MENU",0              
baa8				endm 
# End of macro CWHEAD
baa8			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
baa8			 
baa8			;		; get number of items on the stack 
baa8			; 
baa8				 
baa8					FORTH_DSP_VALUEHL 
baa8 cd a1 9a			call macro_dsp_valuehl 
baab				endm 
# End of macro FORTH_DSP_VALUEHL
baab				 
baab					if DEBUG_FORTH_WORDS_KEY 
baab						DMARK "MNU" 
baab f5				push af  
baac 3a c0 ba			ld a, (.dmark)  
baaf 32 7a ee			ld (debug_mark),a  
bab2 3a c1 ba			ld a, (.dmark+1)  
bab5 32 7b ee			ld (debug_mark+1),a  
bab8 3a c2 ba			ld a, (.dmark+2)  
babb 32 7c ee			ld (debug_mark+2),a  
babe 18 03			jr .pastdmark  
bac0 ..			.dmark: db "MNU"  
bac3 f1			.pastdmark: pop af  
bac4			endm  
# End of macro DMARK
bac4						CALLMONITOR 
bac4 cd 1d 93			call break_point_state  
bac7				endm  
# End of macro CALLMONITOR
bac7					endif 
bac7			 
bac7 45					ld b, l	 
bac8 05					dec b 
bac9			 
bac9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bac9 cd 59 9b			call macro_forth_dsp_pop 
bacc				endm 
# End of macro FORTH_DSP_POP
bacc			 
bacc			 
bacc					; go directly through the stack to pluck out the string pointers and build an array 
bacc			 
bacc			;		FORTH_DSP 
bacc			 
bacc					; hl contains top most stack item 
bacc				 
bacc 11 60 e3				ld de, scratch 
bacf			 
bacf			.mbuild: 
bacf			 
bacf					FORTH_DSP_VALUEHL 
bacf cd a1 9a			call macro_dsp_valuehl 
bad2				endm 
# End of macro FORTH_DSP_VALUEHL
bad2			 
bad2					if DEBUG_FORTH_WORDS 
bad2						DMARK "MN3" 
bad2 f5				push af  
bad3 3a e7 ba			ld a, (.dmark)  
bad6 32 7a ee			ld (debug_mark),a  
bad9 3a e8 ba			ld a, (.dmark+1)  
badc 32 7b ee			ld (debug_mark+1),a  
badf 3a e9 ba			ld a, (.dmark+2)  
bae2 32 7c ee			ld (debug_mark+2),a  
bae5 18 03			jr .pastdmark  
bae7 ..			.dmark: db "MN3"  
baea f1			.pastdmark: pop af  
baeb			endm  
# End of macro DMARK
baeb						CALLMONITOR 
baeb cd 1d 93			call break_point_state  
baee				endm  
# End of macro CALLMONITOR
baee					endif 
baee eb					ex de, hl 
baef 73					ld (hl), e 
baf0 23					inc hl 
baf1 72					ld (hl), d 
baf2 23					inc hl 
baf3 eb					ex de, hl 
baf4			 
baf4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
baf4 cd 59 9b			call macro_forth_dsp_pop 
baf7				endm 
# End of macro FORTH_DSP_POP
baf7			 
baf7 10 d6				djnz .mbuild 
baf9			 
baf9					; done add term 
baf9			 
baf9 eb					ex de, hl 
bafa 36 00				ld (hl), 0 
bafc 23					inc hl 
bafd 36 00				ld (hl), 0 
baff			 
baff				 
baff					 
baff 21 60 e3				ld hl, scratch 
bb02			 
bb02					if DEBUG_FORTH_WORDS 
bb02						DMARK "MNx" 
bb02 f5				push af  
bb03 3a 17 bb			ld a, (.dmark)  
bb06 32 7a ee			ld (debug_mark),a  
bb09 3a 18 bb			ld a, (.dmark+1)  
bb0c 32 7b ee			ld (debug_mark+1),a  
bb0f 3a 19 bb			ld a, (.dmark+2)  
bb12 32 7c ee			ld (debug_mark+2),a  
bb15 18 03			jr .pastdmark  
bb17 ..			.dmark: db "MNx"  
bb1a f1			.pastdmark: pop af  
bb1b			endm  
# End of macro DMARK
bb1b						CALLMONITOR 
bb1b cd 1d 93			call break_point_state  
bb1e				endm  
# End of macro CALLMONITOR
bb1e					endif 
bb1e			 
bb1e			 
bb1e			 
bb1e 3e 00				ld a, 0 
bb20 cd ae 88				call menu 
bb23			 
bb23			 
bb23 6f					ld l, a 
bb24 26 00				ld h, 0 
bb26			 
bb26					if DEBUG_FORTH_WORDS 
bb26						DMARK "MNr" 
bb26 f5				push af  
bb27 3a 3b bb			ld a, (.dmark)  
bb2a 32 7a ee			ld (debug_mark),a  
bb2d 3a 3c bb			ld a, (.dmark+1)  
bb30 32 7b ee			ld (debug_mark+1),a  
bb33 3a 3d bb			ld a, (.dmark+2)  
bb36 32 7c ee			ld (debug_mark+2),a  
bb39 18 03			jr .pastdmark  
bb3b ..			.dmark: db "MNr"  
bb3e f1			.pastdmark: pop af  
bb3f			endm  
# End of macro DMARK
bb3f						CALLMONITOR 
bb3f cd 1d 93			call break_point_state  
bb42				endm  
# End of macro CALLMONITOR
bb42					endif 
bb42			 
bb42 cd aa 98				call forth_push_numhl 
bb45			 
bb45			 
bb45			 
bb45			 
bb45				       NEXTW 
bb45 c3 13 9c			jp macro_next 
bb48				endm 
# End of macro NEXTW
bb48			 
bb48			 
bb48			.ENDDISPLAY: 
bb48			 
bb48			; eof 
# End of file forth_words_display.asm
bb48			include "forth_words_str.asm" 
bb48			 
bb48			; | ## String Words 
bb48			 
bb48			.PTR:   
bb48			 
bb48				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
bb48 48				db WORD_SYS_CORE+52             
bb49 75 bb			dw .STYPE            
bb4b 04				db 3 + 1 
bb4c .. 00			db "PTR",0              
bb50				endm 
# End of macro CWHEAD
bb50			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
bb50			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
bb50			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
bb50			 
bb50					if DEBUG_FORTH_WORDS_KEY 
bb50						DMARK "PTR" 
bb50 f5				push af  
bb51 3a 65 bb			ld a, (.dmark)  
bb54 32 7a ee			ld (debug_mark),a  
bb57 3a 66 bb			ld a, (.dmark+1)  
bb5a 32 7b ee			ld (debug_mark+1),a  
bb5d 3a 67 bb			ld a, (.dmark+2)  
bb60 32 7c ee			ld (debug_mark+2),a  
bb63 18 03			jr .pastdmark  
bb65 ..			.dmark: db "PTR"  
bb68 f1			.pastdmark: pop af  
bb69			endm  
# End of macro DMARK
bb69						CALLMONITOR 
bb69 cd 1d 93			call break_point_state  
bb6c				endm  
# End of macro CALLMONITOR
bb6c					endif 
bb6c					FORTH_DSP_VALUEHL 
bb6c cd a1 9a			call macro_dsp_valuehl 
bb6f				endm 
# End of macro FORTH_DSP_VALUEHL
bb6f cd aa 98				call forth_push_numhl 
bb72			 
bb72			 
bb72					NEXTW 
bb72 c3 13 9c			jp macro_next 
bb75				endm 
# End of macro NEXTW
bb75			.STYPE: 
bb75				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
bb75 48				db WORD_SYS_CORE+52             
bb76 c4 bb			dw .UPPER            
bb78 06				db 5 + 1 
bb79 .. 00			db "STYPE",0              
bb7f				endm 
# End of macro CWHEAD
bb7f			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
bb7f					if DEBUG_FORTH_WORDS_KEY 
bb7f						DMARK "STY" 
bb7f f5				push af  
bb80 3a 94 bb			ld a, (.dmark)  
bb83 32 7a ee			ld (debug_mark),a  
bb86 3a 95 bb			ld a, (.dmark+1)  
bb89 32 7b ee			ld (debug_mark+1),a  
bb8c 3a 96 bb			ld a, (.dmark+2)  
bb8f 32 7c ee			ld (debug_mark+2),a  
bb92 18 03			jr .pastdmark  
bb94 ..			.dmark: db "STY"  
bb97 f1			.pastdmark: pop af  
bb98			endm  
# End of macro DMARK
bb98						CALLMONITOR 
bb98 cd 1d 93			call break_point_state  
bb9b				endm  
# End of macro CALLMONITOR
bb9b					endif 
bb9b					FORTH_DSP 
bb9b cd 67 9a			call macro_forth_dsp 
bb9e				endm 
# End of macro FORTH_DSP
bb9e					;v5 FORTH_DSP_VALUE 
bb9e			 
bb9e 7e					ld a, (hl) 
bb9f			 
bb9f f5					push af 
bba0			 
bba0			; Dont destroy TOS		FORTH_DSP_POP 
bba0			 
bba0 f1					pop af 
bba1			 
bba1 fe 01				cp DS_TYPE_STR 
bba3 28 09				jr z, .typestr 
bba5			 
bba5 fe 02				cp DS_TYPE_INUM 
bba7 28 0a				jr z, .typeinum 
bba9			 
bba9 21 c2 bb				ld hl, .tna 
bbac 18 0a				jr .tpush 
bbae			 
bbae 21 be bb		.typestr:	ld hl, .tstr 
bbb1 18 05				jr .tpush 
bbb3 21 c0 bb		.typeinum:	ld hl, .tinum 
bbb6 18 00				jr .tpush 
bbb8			 
bbb8			.tpush: 
bbb8			 
bbb8 cd 18 99				call forth_push_str 
bbbb			 
bbbb					NEXTW 
bbbb c3 13 9c			jp macro_next 
bbbe				endm 
# End of macro NEXTW
bbbe .. 00		.tstr:	db "s",0 
bbc0 .. 00		.tinum:  db "i",0 
bbc2 .. 00		.tna:   db "?", 0 
bbc4			 
bbc4			 
bbc4			.UPPER: 
bbc4				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
bbc4 48				db WORD_SYS_CORE+52             
bbc5 ff bb			dw .LOWER            
bbc7 06				db 5 + 1 
bbc8 .. 00			db "UPPER",0              
bbce				endm 
# End of macro CWHEAD
bbce			; | UPPER ( s -- s ) Upper case string s  | DONE 
bbce					if DEBUG_FORTH_WORDS_KEY 
bbce						DMARK "UPR" 
bbce f5				push af  
bbcf 3a e3 bb			ld a, (.dmark)  
bbd2 32 7a ee			ld (debug_mark),a  
bbd5 3a e4 bb			ld a, (.dmark+1)  
bbd8 32 7b ee			ld (debug_mark+1),a  
bbdb 3a e5 bb			ld a, (.dmark+2)  
bbde 32 7c ee			ld (debug_mark+2),a  
bbe1 18 03			jr .pastdmark  
bbe3 ..			.dmark: db "UPR"  
bbe6 f1			.pastdmark: pop af  
bbe7			endm  
# End of macro DMARK
bbe7						CALLMONITOR 
bbe7 cd 1d 93			call break_point_state  
bbea				endm  
# End of macro CALLMONITOR
bbea					endif 
bbea			 
bbea					FORTH_DSP 
bbea cd 67 9a			call macro_forth_dsp 
bbed				endm 
# End of macro FORTH_DSP
bbed					 
bbed			; TODO check is string type 
bbed			 
bbed					FORTH_DSP_VALUEHL 
bbed cd a1 9a			call macro_dsp_valuehl 
bbf0				endm 
# End of macro FORTH_DSP_VALUEHL
bbf0			; get pointer to string in hl 
bbf0			 
bbf0 7e			.toup:		ld a, (hl) 
bbf1 fe 00				cp 0 
bbf3 28 07				jr z, .toupdone 
bbf5			 
bbf5 cd 17 8e				call to_upper 
bbf8			 
bbf8 77					ld (hl), a 
bbf9 23					inc hl 
bbfa 18 f4				jr .toup 
bbfc			 
bbfc					 
bbfc			 
bbfc			 
bbfc			; for each char convert to upper 
bbfc					 
bbfc			.toupdone: 
bbfc			 
bbfc			 
bbfc					NEXTW 
bbfc c3 13 9c			jp macro_next 
bbff				endm 
# End of macro NEXTW
bbff			.LOWER: 
bbff				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
bbff 48				db WORD_SYS_CORE+52             
bc00 3a bc			dw .TCASE            
bc02 06				db 5 + 1 
bc03 .. 00			db "LOWER",0              
bc09				endm 
# End of macro CWHEAD
bc09			; | LOWER ( s -- s ) Lower case string s  | DONE 
bc09					if DEBUG_FORTH_WORDS_KEY 
bc09						DMARK "LWR" 
bc09 f5				push af  
bc0a 3a 1e bc			ld a, (.dmark)  
bc0d 32 7a ee			ld (debug_mark),a  
bc10 3a 1f bc			ld a, (.dmark+1)  
bc13 32 7b ee			ld (debug_mark+1),a  
bc16 3a 20 bc			ld a, (.dmark+2)  
bc19 32 7c ee			ld (debug_mark+2),a  
bc1c 18 03			jr .pastdmark  
bc1e ..			.dmark: db "LWR"  
bc21 f1			.pastdmark: pop af  
bc22			endm  
# End of macro DMARK
bc22						CALLMONITOR 
bc22 cd 1d 93			call break_point_state  
bc25				endm  
# End of macro CALLMONITOR
bc25					endif 
bc25			 
bc25					FORTH_DSP 
bc25 cd 67 9a			call macro_forth_dsp 
bc28				endm 
# End of macro FORTH_DSP
bc28					 
bc28			; TODO check is string type 
bc28			 
bc28					FORTH_DSP_VALUEHL 
bc28 cd a1 9a			call macro_dsp_valuehl 
bc2b				endm 
# End of macro FORTH_DSP_VALUEHL
bc2b			; get pointer to string in hl 
bc2b			 
bc2b 7e			.tolow:		ld a, (hl) 
bc2c fe 00				cp 0 
bc2e 28 07				jr z, .tolowdone 
bc30			 
bc30 cd 20 8e				call to_lower 
bc33			 
bc33 77					ld (hl), a 
bc34 23					inc hl 
bc35 18 f4				jr .tolow 
bc37			 
bc37					 
bc37			 
bc37			 
bc37			; for each char convert to low 
bc37					 
bc37			.tolowdone: 
bc37					NEXTW 
bc37 c3 13 9c			jp macro_next 
bc3a				endm 
# End of macro NEXTW
bc3a			.TCASE: 
bc3a				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
bc3a 48				db WORD_SYS_CORE+52             
bc3b 70 bd			dw .SUBSTR            
bc3d 06				db 5 + 1 
bc3e .. 00			db "TCASE",0              
bc44				endm 
# End of macro CWHEAD
bc44			; | TCASE ( s -- s ) Title case string s  | DONE 
bc44					if DEBUG_FORTH_WORDS_KEY 
bc44						DMARK "TCS" 
bc44 f5				push af  
bc45 3a 59 bc			ld a, (.dmark)  
bc48 32 7a ee			ld (debug_mark),a  
bc4b 3a 5a bc			ld a, (.dmark+1)  
bc4e 32 7b ee			ld (debug_mark+1),a  
bc51 3a 5b bc			ld a, (.dmark+2)  
bc54 32 7c ee			ld (debug_mark+2),a  
bc57 18 03			jr .pastdmark  
bc59 ..			.dmark: db "TCS"  
bc5c f1			.pastdmark: pop af  
bc5d			endm  
# End of macro DMARK
bc5d						CALLMONITOR 
bc5d cd 1d 93			call break_point_state  
bc60				endm  
# End of macro CALLMONITOR
bc60					endif 
bc60			 
bc60					FORTH_DSP 
bc60 cd 67 9a			call macro_forth_dsp 
bc63				endm 
# End of macro FORTH_DSP
bc63					 
bc63			; TODO check is string type 
bc63			 
bc63					FORTH_DSP_VALUEHL 
bc63 cd a1 9a			call macro_dsp_valuehl 
bc66				endm 
# End of macro FORTH_DSP_VALUEHL
bc66			; get pointer to string in hl 
bc66			 
bc66					if DEBUG_FORTH_WORDS 
bc66						DMARK "TC1" 
bc66 f5				push af  
bc67 3a 7b bc			ld a, (.dmark)  
bc6a 32 7a ee			ld (debug_mark),a  
bc6d 3a 7c bc			ld a, (.dmark+1)  
bc70 32 7b ee			ld (debug_mark+1),a  
bc73 3a 7d bc			ld a, (.dmark+2)  
bc76 32 7c ee			ld (debug_mark+2),a  
bc79 18 03			jr .pastdmark  
bc7b ..			.dmark: db "TC1"  
bc7e f1			.pastdmark: pop af  
bc7f			endm  
# End of macro DMARK
bc7f						CALLMONITOR 
bc7f cd 1d 93			call break_point_state  
bc82				endm  
# End of macro CALLMONITOR
bc82					endif 
bc82			 
bc82					; first time in turn to upper case first char 
bc82			 
bc82 7e					ld a, (hl) 
bc83 c3 0d bd				jp .totsiptou 
bc86			 
bc86			 
bc86 7e			.tot:		ld a, (hl) 
bc87 fe 00				cp 0 
bc89 ca 51 bd				jp z, .totdone 
bc8c			 
bc8c					if DEBUG_FORTH_WORDS 
bc8c						DMARK "TC2" 
bc8c f5				push af  
bc8d 3a a1 bc			ld a, (.dmark)  
bc90 32 7a ee			ld (debug_mark),a  
bc93 3a a2 bc			ld a, (.dmark+1)  
bc96 32 7b ee			ld (debug_mark+1),a  
bc99 3a a3 bc			ld a, (.dmark+2)  
bc9c 32 7c ee			ld (debug_mark+2),a  
bc9f 18 03			jr .pastdmark  
bca1 ..			.dmark: db "TC2"  
bca4 f1			.pastdmark: pop af  
bca5			endm  
# End of macro DMARK
bca5						CALLMONITOR 
bca5 cd 1d 93			call break_point_state  
bca8				endm  
# End of macro CALLMONITOR
bca8					endif 
bca8					; check to see if current char is a space 
bca8			 
bca8 fe 20				cp ' ' 
bcaa 28 21				jr z, .totsp 
bcac cd 20 8e				call to_lower 
bcaf					if DEBUG_FORTH_WORDS 
bcaf						DMARK "TC3" 
bcaf f5				push af  
bcb0 3a c4 bc			ld a, (.dmark)  
bcb3 32 7a ee			ld (debug_mark),a  
bcb6 3a c5 bc			ld a, (.dmark+1)  
bcb9 32 7b ee			ld (debug_mark+1),a  
bcbc 3a c6 bc			ld a, (.dmark+2)  
bcbf 32 7c ee			ld (debug_mark+2),a  
bcc2 18 03			jr .pastdmark  
bcc4 ..			.dmark: db "TC3"  
bcc7 f1			.pastdmark: pop af  
bcc8			endm  
# End of macro DMARK
bcc8						CALLMONITOR 
bcc8 cd 1d 93			call break_point_state  
bccb				endm  
# End of macro CALLMONITOR
bccb					endif 
bccb 18 63				jr .totnxt 
bccd			 
bccd			.totsp:         ; on a space, find next char which should be upper 
bccd			 
bccd					if DEBUG_FORTH_WORDS 
bccd						DMARK "TC4" 
bccd f5				push af  
bcce 3a e2 bc			ld a, (.dmark)  
bcd1 32 7a ee			ld (debug_mark),a  
bcd4 3a e3 bc			ld a, (.dmark+1)  
bcd7 32 7b ee			ld (debug_mark+1),a  
bcda 3a e4 bc			ld a, (.dmark+2)  
bcdd 32 7c ee			ld (debug_mark+2),a  
bce0 18 03			jr .pastdmark  
bce2 ..			.dmark: db "TC4"  
bce5 f1			.pastdmark: pop af  
bce6			endm  
# End of macro DMARK
bce6						CALLMONITOR 
bce6 cd 1d 93			call break_point_state  
bce9				endm  
# End of macro CALLMONITOR
bce9					endif 
bce9					;; 
bce9			 
bce9 fe 20				cp ' ' 
bceb 20 20				jr nz, .totsiptou 
bced 23					inc hl 
bcee 7e					ld a, (hl) 
bcef					if DEBUG_FORTH_WORDS 
bcef						DMARK "TC5" 
bcef f5				push af  
bcf0 3a 04 bd			ld a, (.dmark)  
bcf3 32 7a ee			ld (debug_mark),a  
bcf6 3a 05 bd			ld a, (.dmark+1)  
bcf9 32 7b ee			ld (debug_mark+1),a  
bcfc 3a 06 bd			ld a, (.dmark+2)  
bcff 32 7c ee			ld (debug_mark+2),a  
bd02 18 03			jr .pastdmark  
bd04 ..			.dmark: db "TC5"  
bd07 f1			.pastdmark: pop af  
bd08			endm  
# End of macro DMARK
bd08						CALLMONITOR 
bd08 cd 1d 93			call break_point_state  
bd0b				endm  
# End of macro CALLMONITOR
bd0b					endif 
bd0b 18 c0				jr .totsp 
bd0d fe 00		.totsiptou:    cp 0 
bd0f 28 40				jr z, .totdone 
bd11					; not space and not zero term so upper case it 
bd11 cd 17 8e				call to_upper 
bd14			 
bd14					if DEBUG_FORTH_WORDS 
bd14						DMARK "TC6" 
bd14 f5				push af  
bd15 3a 29 bd			ld a, (.dmark)  
bd18 32 7a ee			ld (debug_mark),a  
bd1b 3a 2a bd			ld a, (.dmark+1)  
bd1e 32 7b ee			ld (debug_mark+1),a  
bd21 3a 2b bd			ld a, (.dmark+2)  
bd24 32 7c ee			ld (debug_mark+2),a  
bd27 18 03			jr .pastdmark  
bd29 ..			.dmark: db "TC6"  
bd2c f1			.pastdmark: pop af  
bd2d			endm  
# End of macro DMARK
bd2d						CALLMONITOR 
bd2d cd 1d 93			call break_point_state  
bd30				endm  
# End of macro CALLMONITOR
bd30					endif 
bd30			 
bd30			 
bd30			.totnxt: 
bd30			 
bd30 77					ld (hl), a 
bd31 23					inc hl 
bd32					if DEBUG_FORTH_WORDS 
bd32						DMARK "TC7" 
bd32 f5				push af  
bd33 3a 47 bd			ld a, (.dmark)  
bd36 32 7a ee			ld (debug_mark),a  
bd39 3a 48 bd			ld a, (.dmark+1)  
bd3c 32 7b ee			ld (debug_mark+1),a  
bd3f 3a 49 bd			ld a, (.dmark+2)  
bd42 32 7c ee			ld (debug_mark+2),a  
bd45 18 03			jr .pastdmark  
bd47 ..			.dmark: db "TC7"  
bd4a f1			.pastdmark: pop af  
bd4b			endm  
# End of macro DMARK
bd4b						CALLMONITOR 
bd4b cd 1d 93			call break_point_state  
bd4e				endm  
# End of macro CALLMONITOR
bd4e					endif 
bd4e c3 86 bc				jp .tot 
bd51			 
bd51					 
bd51			 
bd51			 
bd51			; for each char convert to low 
bd51					 
bd51			.totdone: 
bd51					if DEBUG_FORTH_WORDS 
bd51						DMARK "TCd" 
bd51 f5				push af  
bd52 3a 66 bd			ld a, (.dmark)  
bd55 32 7a ee			ld (debug_mark),a  
bd58 3a 67 bd			ld a, (.dmark+1)  
bd5b 32 7b ee			ld (debug_mark+1),a  
bd5e 3a 68 bd			ld a, (.dmark+2)  
bd61 32 7c ee			ld (debug_mark+2),a  
bd64 18 03			jr .pastdmark  
bd66 ..			.dmark: db "TCd"  
bd69 f1			.pastdmark: pop af  
bd6a			endm  
# End of macro DMARK
bd6a						CALLMONITOR 
bd6a cd 1d 93			call break_point_state  
bd6d				endm  
# End of macro CALLMONITOR
bd6d					endif 
bd6d					NEXTW 
bd6d c3 13 9c			jp macro_next 
bd70				endm 
# End of macro NEXTW
bd70			 
bd70			.SUBSTR: 
bd70				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
bd70 48				db WORD_SYS_CORE+52             
bd71 ce bd			dw .LEFT            
bd73 07				db 6 + 1 
bd74 .. 00			db "SUBSTR",0              
bd7b				endm 
# End of macro CWHEAD
bd7b			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
bd7b			 
bd7b					if DEBUG_FORTH_WORDS_KEY 
bd7b						DMARK "SST" 
bd7b f5				push af  
bd7c 3a 90 bd			ld a, (.dmark)  
bd7f 32 7a ee			ld (debug_mark),a  
bd82 3a 91 bd			ld a, (.dmark+1)  
bd85 32 7b ee			ld (debug_mark+1),a  
bd88 3a 92 bd			ld a, (.dmark+2)  
bd8b 32 7c ee			ld (debug_mark+2),a  
bd8e 18 03			jr .pastdmark  
bd90 ..			.dmark: db "SST"  
bd93 f1			.pastdmark: pop af  
bd94			endm  
# End of macro DMARK
bd94						CALLMONITOR 
bd94 cd 1d 93			call break_point_state  
bd97				endm  
# End of macro CALLMONITOR
bd97					endif 
bd97			; TODO check string type 
bd97					FORTH_DSP_VALUEHL 
bd97 cd a1 9a			call macro_dsp_valuehl 
bd9a				endm 
# End of macro FORTH_DSP_VALUEHL
bd9a			 
bd9a e5					push hl      ; string length 
bd9b			 
bd9b					FORTH_DSP_POP 
bd9b cd 59 9b			call macro_forth_dsp_pop 
bd9e				endm 
# End of macro FORTH_DSP_POP
bd9e			 
bd9e					FORTH_DSP_VALUEHL 
bd9e cd a1 9a			call macro_dsp_valuehl 
bda1				endm 
# End of macro FORTH_DSP_VALUEHL
bda1			 
bda1 e5					push hl     ; start char 
bda2			 
bda2					FORTH_DSP_POP 
bda2 cd 59 9b			call macro_forth_dsp_pop 
bda5				endm 
# End of macro FORTH_DSP_POP
bda5			 
bda5			 
bda5					FORTH_DSP_VALUE 
bda5 cd 8a 9a			call macro_forth_dsp_value 
bda8				endm 
# End of macro FORTH_DSP_VALUE
bda8			 
bda8 d1					pop de    ; get start post offset 
bda9			 
bda9 19					add hl, de    ; starting offset 
bdaa			 
bdaa c1					pop bc 
bdab c5					push bc      ; grab size of string 
bdac			 
bdac e5					push hl    ; save string start  
bdad			 
bdad 26 00				ld h, 0 
bdaf 69					ld l, c 
bdb0 23					inc hl 
bdb1 23					inc hl 
bdb2			 
bdb2 cd 71 8f				call malloc 
bdb5				if DEBUG_FORTH_MALLOC_GUARD 
bdb5 cc fd c3				call z,malloc_error 
bdb8				endif 
bdb8			 
bdb8 eb					ex de, hl      ; save malloc area for string copy 
bdb9 e1					pop hl    ; get back source 
bdba c1					pop bc    ; get length of string back 
bdbb			 
bdbb d5					push de    ; save malloc area for after we push 
bdbc ed b0				ldir     ; copy substr 
bdbe			 
bdbe			 
bdbe eb					ex de, hl 
bdbf 3e 00				ld a, 0 
bdc1 77					ld (hl), a   ; term substr 
bdc2			 
bdc2					 
bdc2 e1					pop hl    ; get malloc so we can push it 
bdc3 e5					push hl   ; save so we can free it afterwards 
bdc4			 
bdc4 cd 18 99				call forth_push_str 
bdc7			 
bdc7 e1					pop hl 
bdc8 cd 3b 90				call free 
bdcb			 
bdcb					 
bdcb					 
bdcb			 
bdcb			 
bdcb					NEXTW 
bdcb c3 13 9c			jp macro_next 
bdce				endm 
# End of macro NEXTW
bdce			 
bdce			.LEFT: 
bdce				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
bdce 48				db WORD_SYS_CORE+52             
bdcf f6 bd			dw .RIGHT            
bdd1 05				db 4 + 1 
bdd2 .. 00			db "LEFT",0              
bdd7				endm 
# End of macro CWHEAD
bdd7			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
bdd7					if DEBUG_FORTH_WORDS_KEY 
bdd7						DMARK "LEF" 
bdd7 f5				push af  
bdd8 3a ec bd			ld a, (.dmark)  
bddb 32 7a ee			ld (debug_mark),a  
bdde 3a ed bd			ld a, (.dmark+1)  
bde1 32 7b ee			ld (debug_mark+1),a  
bde4 3a ee bd			ld a, (.dmark+2)  
bde7 32 7c ee			ld (debug_mark+2),a  
bdea 18 03			jr .pastdmark  
bdec ..			.dmark: db "LEF"  
bdef f1			.pastdmark: pop af  
bdf0			endm  
# End of macro DMARK
bdf0						CALLMONITOR 
bdf0 cd 1d 93			call break_point_state  
bdf3				endm  
# End of macro CALLMONITOR
bdf3					endif 
bdf3			 
bdf3					NEXTW 
bdf3 c3 13 9c			jp macro_next 
bdf6				endm 
# End of macro NEXTW
bdf6			.RIGHT: 
bdf6				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
bdf6 48				db WORD_SYS_CORE+52             
bdf7 1f be			dw .STR2NUM            
bdf9 06				db 5 + 1 
bdfa .. 00			db "RIGHT",0              
be00				endm 
# End of macro CWHEAD
be00			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
be00					if DEBUG_FORTH_WORDS_KEY 
be00						DMARK "RIG" 
be00 f5				push af  
be01 3a 15 be			ld a, (.dmark)  
be04 32 7a ee			ld (debug_mark),a  
be07 3a 16 be			ld a, (.dmark+1)  
be0a 32 7b ee			ld (debug_mark+1),a  
be0d 3a 17 be			ld a, (.dmark+2)  
be10 32 7c ee			ld (debug_mark+2),a  
be13 18 03			jr .pastdmark  
be15 ..			.dmark: db "RIG"  
be18 f1			.pastdmark: pop af  
be19			endm  
# End of macro DMARK
be19						CALLMONITOR 
be19 cd 1d 93			call break_point_state  
be1c				endm  
# End of macro CALLMONITOR
be1c					endif 
be1c			 
be1c					NEXTW 
be1c c3 13 9c			jp macro_next 
be1f				endm 
# End of macro NEXTW
be1f			 
be1f			 
be1f			.STR2NUM: 
be1f				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
be1f 48				db WORD_SYS_CORE+52             
be20 ab be			dw .NUM2STR            
be22 08				db 7 + 1 
be23 .. 00			db "STR2NUM",0              
be2b				endm 
# End of macro CWHEAD
be2b			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
be2b			 
be2b			 
be2b			; TODO STR type check to do 
be2b					if DEBUG_FORTH_WORDS_KEY 
be2b						DMARK "S2N" 
be2b f5				push af  
be2c 3a 40 be			ld a, (.dmark)  
be2f 32 7a ee			ld (debug_mark),a  
be32 3a 41 be			ld a, (.dmark+1)  
be35 32 7b ee			ld (debug_mark+1),a  
be38 3a 42 be			ld a, (.dmark+2)  
be3b 32 7c ee			ld (debug_mark+2),a  
be3e 18 03			jr .pastdmark  
be40 ..			.dmark: db "S2N"  
be43 f1			.pastdmark: pop af  
be44			endm  
# End of macro DMARK
be44						CALLMONITOR 
be44 cd 1d 93			call break_point_state  
be47				endm  
# End of macro CALLMONITOR
be47					endif 
be47			 
be47					;FORTH_DSP 
be47					FORTH_DSP_VALUE 
be47 cd 8a 9a			call macro_forth_dsp_value 
be4a				endm 
# End of macro FORTH_DSP_VALUE
be4a					;inc hl 
be4a			 
be4a eb					ex de, hl 
be4b					if DEBUG_FORTH_WORDS 
be4b						DMARK "S2a" 
be4b f5				push af  
be4c 3a 60 be			ld a, (.dmark)  
be4f 32 7a ee			ld (debug_mark),a  
be52 3a 61 be			ld a, (.dmark+1)  
be55 32 7b ee			ld (debug_mark+1),a  
be58 3a 62 be			ld a, (.dmark+2)  
be5b 32 7c ee			ld (debug_mark+2),a  
be5e 18 03			jr .pastdmark  
be60 ..			.dmark: db "S2a"  
be63 f1			.pastdmark: pop af  
be64			endm  
# End of macro DMARK
be64						CALLMONITOR 
be64 cd 1d 93			call break_point_state  
be67				endm  
# End of macro CALLMONITOR
be67					endif 
be67 cd 9f 8e				call string_to_uint16 
be6a			 
be6a					if DEBUG_FORTH_WORDS 
be6a						DMARK "S2b" 
be6a f5				push af  
be6b 3a 7f be			ld a, (.dmark)  
be6e 32 7a ee			ld (debug_mark),a  
be71 3a 80 be			ld a, (.dmark+1)  
be74 32 7b ee			ld (debug_mark+1),a  
be77 3a 81 be			ld a, (.dmark+2)  
be7a 32 7c ee			ld (debug_mark+2),a  
be7d 18 03			jr .pastdmark  
be7f ..			.dmark: db "S2b"  
be82 f1			.pastdmark: pop af  
be83			endm  
# End of macro DMARK
be83						CALLMONITOR 
be83 cd 1d 93			call break_point_state  
be86				endm  
# End of macro CALLMONITOR
be86					endif 
be86			;		push hl 
be86					FORTH_DSP_POP 
be86 cd 59 9b			call macro_forth_dsp_pop 
be89				endm 
# End of macro FORTH_DSP_POP
be89			;		pop hl 
be89					 
be89					if DEBUG_FORTH_WORDS 
be89						DMARK "S2b" 
be89 f5				push af  
be8a 3a 9e be			ld a, (.dmark)  
be8d 32 7a ee			ld (debug_mark),a  
be90 3a 9f be			ld a, (.dmark+1)  
be93 32 7b ee			ld (debug_mark+1),a  
be96 3a a0 be			ld a, (.dmark+2)  
be99 32 7c ee			ld (debug_mark+2),a  
be9c 18 03			jr .pastdmark  
be9e ..			.dmark: db "S2b"  
bea1 f1			.pastdmark: pop af  
bea2			endm  
# End of macro DMARK
bea2						CALLMONITOR 
bea2 cd 1d 93			call break_point_state  
bea5				endm  
# End of macro CALLMONITOR
bea5					endif 
bea5 cd aa 98				call forth_push_numhl	 
bea8			 
bea8				 
bea8				       NEXTW 
bea8 c3 13 9c			jp macro_next 
beab				endm 
# End of macro NEXTW
beab			.NUM2STR: 
beab				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
beab 48				db WORD_SYS_CORE+52             
beac ba be			dw .CONCAT            
beae 08				db 7 + 1 
beaf .. 00			db "NUM2STR",0              
beb7				endm 
# End of macro CWHEAD
beb7			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
beb7			 
beb7			;		; malloc a string to target 
beb7			;		ld hl, 10     ; TODO max string size should be fine 
beb7			;		call malloc 
beb7			;		push hl    ; save malloc location 
beb7			; 
beb7			; 
beb7			;; TODO check int type 
beb7			;		FORTH_DSP_VALUEHL 
beb7			;		ld a, l 
beb7			;		call DispAToASCII   
beb7			;;TODO need to chage above call to dump into string 
beb7			; 
beb7			; 
beb7			 
beb7				       NEXTW 
beb7 c3 13 9c			jp macro_next 
beba				endm 
# End of macro NEXTW
beba			 
beba			.CONCAT: 
beba				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
beba 48				db WORD_SYS_CORE+52             
bebb 6d bf			dw .FIND            
bebd 07				db 6 + 1 
bebe .. 00			db "CONCAT",0              
bec5				endm 
# End of macro CWHEAD
bec5			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
bec5			 
bec5			; TODO check string type 
bec5			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
bec5			 
bec5					if DEBUG_FORTH_WORDS_KEY 
bec5						DMARK "CON" 
bec5 f5				push af  
bec6 3a da be			ld a, (.dmark)  
bec9 32 7a ee			ld (debug_mark),a  
becc 3a db be			ld a, (.dmark+1)  
becf 32 7b ee			ld (debug_mark+1),a  
bed2 3a dc be			ld a, (.dmark+2)  
bed5 32 7c ee			ld (debug_mark+2),a  
bed8 18 03			jr .pastdmark  
beda ..			.dmark: db "CON"  
bedd f1			.pastdmark: pop af  
bede			endm  
# End of macro DMARK
bede						CALLMONITOR 
bede cd 1d 93			call break_point_state  
bee1				endm  
# End of macro CALLMONITOR
bee1					endif 
bee1			 
bee1			 
bee1					FORTH_DSP_VALUE 
bee1 cd 8a 9a			call macro_forth_dsp_value 
bee4				endm 
# End of macro FORTH_DSP_VALUE
bee4 e5					push hl   ; s2 
bee5			 
bee5					FORTH_DSP_POP 
bee5 cd 59 9b			call macro_forth_dsp_pop 
bee8				endm 
# End of macro FORTH_DSP_POP
bee8			 
bee8					FORTH_DSP_VALUE 
bee8 cd 8a 9a			call macro_forth_dsp_value 
beeb				endm 
# End of macro FORTH_DSP_VALUE
beeb			 
beeb e5					push hl   ; s1 
beec			 
beec					FORTH_DSP_POP 
beec cd 59 9b			call macro_forth_dsp_pop 
beef				endm 
# End of macro FORTH_DSP_POP
beef					 
beef			 
beef					; copy s1 
beef			 
beef				 
beef					; save ptr 
beef e1					pop hl  
bef0 e5					push hl 
bef1 3e 00				ld a, 0 
bef3 cd 13 8f				call strlent 
bef6					;inc hl    ; zer0 
bef6 06 00				ld b, 0 
bef8 4d					ld c, l 
bef9 e1					pop hl		 
befa 11 60 e3				ld de, scratch	 
befd					if DEBUG_FORTH_WORDS 
befd						DMARK "CO1" 
befd f5				push af  
befe 3a 12 bf			ld a, (.dmark)  
bf01 32 7a ee			ld (debug_mark),a  
bf04 3a 13 bf			ld a, (.dmark+1)  
bf07 32 7b ee			ld (debug_mark+1),a  
bf0a 3a 14 bf			ld a, (.dmark+2)  
bf0d 32 7c ee			ld (debug_mark+2),a  
bf10 18 03			jr .pastdmark  
bf12 ..			.dmark: db "CO1"  
bf15 f1			.pastdmark: pop af  
bf16			endm  
# End of macro DMARK
bf16						CALLMONITOR 
bf16 cd 1d 93			call break_point_state  
bf19				endm  
# End of macro CALLMONITOR
bf19					endif 
bf19 ed b0				ldir 
bf1b			 
bf1b e1					pop hl 
bf1c e5					push hl 
bf1d d5					push de 
bf1e			 
bf1e			 
bf1e 3e 00				ld a, 0 
bf20 cd 13 8f				call strlent 
bf23 23					inc hl    ; zer0 
bf24 23					inc hl 
bf25 06 00				ld b, 0 
bf27 4d					ld c, l 
bf28 d1					pop de 
bf29 e1					pop hl		 
bf2a					if DEBUG_FORTH_WORDS 
bf2a						DMARK "CO2" 
bf2a f5				push af  
bf2b 3a 3f bf			ld a, (.dmark)  
bf2e 32 7a ee			ld (debug_mark),a  
bf31 3a 40 bf			ld a, (.dmark+1)  
bf34 32 7b ee			ld (debug_mark+1),a  
bf37 3a 41 bf			ld a, (.dmark+2)  
bf3a 32 7c ee			ld (debug_mark+2),a  
bf3d 18 03			jr .pastdmark  
bf3f ..			.dmark: db "CO2"  
bf42 f1			.pastdmark: pop af  
bf43			endm  
# End of macro DMARK
bf43						CALLMONITOR 
bf43 cd 1d 93			call break_point_state  
bf46				endm  
# End of macro CALLMONITOR
bf46					endif 
bf46 ed b0				ldir 
bf48			 
bf48			 
bf48			 
bf48 21 60 e3				ld hl, scratch 
bf4b					if DEBUG_FORTH_WORDS 
bf4b						DMARK "CO5" 
bf4b f5				push af  
bf4c 3a 60 bf			ld a, (.dmark)  
bf4f 32 7a ee			ld (debug_mark),a  
bf52 3a 61 bf			ld a, (.dmark+1)  
bf55 32 7b ee			ld (debug_mark+1),a  
bf58 3a 62 bf			ld a, (.dmark+2)  
bf5b 32 7c ee			ld (debug_mark+2),a  
bf5e 18 03			jr .pastdmark  
bf60 ..			.dmark: db "CO5"  
bf63 f1			.pastdmark: pop af  
bf64			endm  
# End of macro DMARK
bf64						CALLMONITOR 
bf64 cd 1d 93			call break_point_state  
bf67				endm  
# End of macro CALLMONITOR
bf67					endif 
bf67			 
bf67 cd 18 99				call forth_push_str 
bf6a			 
bf6a			 
bf6a			 
bf6a			 
bf6a				       NEXTW 
bf6a c3 13 9c			jp macro_next 
bf6d				endm 
# End of macro NEXTW
bf6d			 
bf6d			 
bf6d			.FIND: 
bf6d				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
bf6d 4b				db WORD_SYS_CORE+55             
bf6e 2b c0			dw .LEN            
bf70 05				db 4 + 1 
bf71 .. 00			db "FIND",0              
bf76				endm 
# End of macro CWHEAD
bf76			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
bf76			 
bf76					if DEBUG_FORTH_WORDS_KEY 
bf76						DMARK "FND" 
bf76 f5				push af  
bf77 3a 8b bf			ld a, (.dmark)  
bf7a 32 7a ee			ld (debug_mark),a  
bf7d 3a 8c bf			ld a, (.dmark+1)  
bf80 32 7b ee			ld (debug_mark+1),a  
bf83 3a 8d bf			ld a, (.dmark+2)  
bf86 32 7c ee			ld (debug_mark+2),a  
bf89 18 03			jr .pastdmark  
bf8b ..			.dmark: db "FND"  
bf8e f1			.pastdmark: pop af  
bf8f			endm  
# End of macro DMARK
bf8f						CALLMONITOR 
bf8f cd 1d 93			call break_point_state  
bf92				endm  
# End of macro CALLMONITOR
bf92					endif 
bf92			 
bf92			; TODO check string type 
bf92					FORTH_DSP_VALUE 
bf92 cd 8a 9a			call macro_forth_dsp_value 
bf95				endm 
# End of macro FORTH_DSP_VALUE
bf95			 
bf95 e5					push hl    
bf96 7e					ld a,(hl)    ; char to find   
bf97			; TODO change char to substr 
bf97			 
bf97 f5					push af 
bf98					 
bf98			 
bf98			 
bf98					if DEBUG_FORTH_WORDS 
bf98						DMARK "FN1" 
bf98 f5				push af  
bf99 3a ad bf			ld a, (.dmark)  
bf9c 32 7a ee			ld (debug_mark),a  
bf9f 3a ae bf			ld a, (.dmark+1)  
bfa2 32 7b ee			ld (debug_mark+1),a  
bfa5 3a af bf			ld a, (.dmark+2)  
bfa8 32 7c ee			ld (debug_mark+2),a  
bfab 18 03			jr .pastdmark  
bfad ..			.dmark: db "FN1"  
bfb0 f1			.pastdmark: pop af  
bfb1			endm  
# End of macro DMARK
bfb1						CALLMONITOR 
bfb1 cd 1d 93			call break_point_state  
bfb4				endm  
# End of macro CALLMONITOR
bfb4					endif 
bfb4			 
bfb4					FORTH_DSP_POP 
bfb4 cd 59 9b			call macro_forth_dsp_pop 
bfb7				endm 
# End of macro FORTH_DSP_POP
bfb7			 
bfb7					; string to search 
bfb7			 
bfb7					FORTH_DSP_VALUE 
bfb7 cd 8a 9a			call macro_forth_dsp_value 
bfba				endm 
# End of macro FORTH_DSP_VALUE
bfba			 
bfba d1					pop de  ; d is char to find  
bfbb			 
bfbb					if DEBUG_FORTH_WORDS 
bfbb						DMARK "FN2" 
bfbb f5				push af  
bfbc 3a d0 bf			ld a, (.dmark)  
bfbf 32 7a ee			ld (debug_mark),a  
bfc2 3a d1 bf			ld a, (.dmark+1)  
bfc5 32 7b ee			ld (debug_mark+1),a  
bfc8 3a d2 bf			ld a, (.dmark+2)  
bfcb 32 7c ee			ld (debug_mark+2),a  
bfce 18 03			jr .pastdmark  
bfd0 ..			.dmark: db "FN2"  
bfd3 f1			.pastdmark: pop af  
bfd4			endm  
# End of macro DMARK
bfd4						CALLMONITOR 
bfd4 cd 1d 93			call break_point_state  
bfd7				endm  
# End of macro CALLMONITOR
bfd7					endif 
bfd7					 
bfd7 01 00 00				ld bc, 0 
bfda 7e			.findchar:      ld a,(hl) 
bfdb fe 00				cp 0   		 
bfdd 28 27				jr z, .finddone     
bfdf ba					cp d 
bfe0 28 20				jr z, .foundchar 
bfe2 03					inc bc 
bfe3 23					inc hl 
bfe4					if DEBUG_FORTH_WORDS 
bfe4						DMARK "FN3" 
bfe4 f5				push af  
bfe5 3a f9 bf			ld a, (.dmark)  
bfe8 32 7a ee			ld (debug_mark),a  
bfeb 3a fa bf			ld a, (.dmark+1)  
bfee 32 7b ee			ld (debug_mark+1),a  
bff1 3a fb bf			ld a, (.dmark+2)  
bff4 32 7c ee			ld (debug_mark+2),a  
bff7 18 03			jr .pastdmark  
bff9 ..			.dmark: db "FN3"  
bffc f1			.pastdmark: pop af  
bffd			endm  
# End of macro DMARK
bffd						CALLMONITOR 
bffd cd 1d 93			call break_point_state  
c000				endm  
# End of macro CALLMONITOR
c000					endif 
c000 18 d8				jr .findchar 
c002			 
c002			 
c002 c5			.foundchar:	push bc 
c003 e1					pop hl 
c004 18 03				jr .findexit 
c006			 
c006			 
c006							 
c006			 
c006			.finddone:     ; got to end of string with no find 
c006 21 00 00				ld hl, 0 
c009			.findexit: 
c009			 
c009					if DEBUG_FORTH_WORDS 
c009						DMARK "FNd" 
c009 f5				push af  
c00a 3a 1e c0			ld a, (.dmark)  
c00d 32 7a ee			ld (debug_mark),a  
c010 3a 1f c0			ld a, (.dmark+1)  
c013 32 7b ee			ld (debug_mark+1),a  
c016 3a 20 c0			ld a, (.dmark+2)  
c019 32 7c ee			ld (debug_mark+2),a  
c01c 18 03			jr .pastdmark  
c01e ..			.dmark: db "FNd"  
c021 f1			.pastdmark: pop af  
c022			endm  
# End of macro DMARK
c022						CALLMONITOR 
c022 cd 1d 93			call break_point_state  
c025				endm  
# End of macro CALLMONITOR
c025					endif 
c025 cd aa 98			call forth_push_numhl 
c028			 
c028				       NEXTW 
c028 c3 13 9c			jp macro_next 
c02b				endm 
# End of macro NEXTW
c02b			 
c02b			.LEN: 
c02b				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
c02b 4c				db WORD_SYS_CORE+56             
c02c 60 c0			dw .CHAR            
c02e 06				db 5 + 1 
c02f .. 00			db "COUNT",0              
c035				endm 
# End of macro CWHEAD
c035			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
c035			 
c035					if DEBUG_FORTH_WORDS_KEY 
c035						DMARK "CNT" 
c035 f5				push af  
c036 3a 4a c0			ld a, (.dmark)  
c039 32 7a ee			ld (debug_mark),a  
c03c 3a 4b c0			ld a, (.dmark+1)  
c03f 32 7b ee			ld (debug_mark+1),a  
c042 3a 4c c0			ld a, (.dmark+2)  
c045 32 7c ee			ld (debug_mark+2),a  
c048 18 03			jr .pastdmark  
c04a ..			.dmark: db "CNT"  
c04d f1			.pastdmark: pop af  
c04e			endm  
# End of macro DMARK
c04e						CALLMONITOR 
c04e cd 1d 93			call break_point_state  
c051				endm  
# End of macro CALLMONITOR
c051					endif 
c051			; TODO check string type 
c051					FORTH_DSP 
c051 cd 67 9a			call macro_forth_dsp 
c054				endm 
# End of macro FORTH_DSP
c054					;v5FORTH_DSP_VALUE 
c054			 
c054 23					inc hl 
c055			 
c055 3e 00				ld a, 0 
c057 cd 13 8f				call strlent 
c05a			 
c05a cd aa 98				call forth_push_numhl 
c05d			 
c05d			 
c05d			 
c05d				       NEXTW 
c05d c3 13 9c			jp macro_next 
c060				endm 
# End of macro NEXTW
c060			.CHAR: 
c060				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
c060 4d				db WORD_SYS_CORE+57             
c061 96 c0			dw .ENDSTR            
c063 05				db 4 + 1 
c064 .. 00			db "CHAR",0              
c069				endm 
# End of macro CWHEAD
c069			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c069					if DEBUG_FORTH_WORDS_KEY 
c069						DMARK "CHR" 
c069 f5				push af  
c06a 3a 7e c0			ld a, (.dmark)  
c06d 32 7a ee			ld (debug_mark),a  
c070 3a 7f c0			ld a, (.dmark+1)  
c073 32 7b ee			ld (debug_mark+1),a  
c076 3a 80 c0			ld a, (.dmark+2)  
c079 32 7c ee			ld (debug_mark+2),a  
c07c 18 03			jr .pastdmark  
c07e ..			.dmark: db "CHR"  
c081 f1			.pastdmark: pop af  
c082			endm  
# End of macro DMARK
c082						CALLMONITOR 
c082 cd 1d 93			call break_point_state  
c085				endm  
# End of macro CALLMONITOR
c085					endif 
c085					FORTH_DSP 
c085 cd 67 9a			call macro_forth_dsp 
c088				endm 
# End of macro FORTH_DSP
c088					;v5 FORTH_DSP_VALUE 
c088 23					inc hl      ; now at start of numeric as string 
c089			 
c089			;		push hl 
c089			 
c089					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c089 cd 59 9b			call macro_forth_dsp_pop 
c08c				endm 
# End of macro FORTH_DSP_POP
c08c			 
c08c			;		pop hl 
c08c			 
c08c					; push the content of a onto the stack as a value 
c08c			 
c08c 7e					ld a,(hl)   ; get char 
c08d 26 00				ld h,0 
c08f 6f					ld l,a 
c090 cd aa 98				call forth_push_numhl 
c093			 
c093				       NEXTW 
c093 c3 13 9c			jp macro_next 
c096				endm 
# End of macro NEXTW
c096			 
c096			 
c096			 
c096			 
c096			.ENDSTR: 
c096			; eof 
c096			 
# End of file forth_words_str.asm
c096			include "forth_words_key.asm" 
c096			 
c096			; | ## Keyboard Words 
c096			 
c096			.KEY: 
c096				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c096 3e				db WORD_SYS_CORE+42             
c097 c6 c0			dw .WAITK            
c099 04				db 3 + 1 
c09a .. 00			db "KEY",0              
c09e				endm 
# End of macro CWHEAD
c09e			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c09e			 
c09e					if DEBUG_FORTH_WORDS_KEY 
c09e						DMARK "KEY" 
c09e f5				push af  
c09f 3a b3 c0			ld a, (.dmark)  
c0a2 32 7a ee			ld (debug_mark),a  
c0a5 3a b4 c0			ld a, (.dmark+1)  
c0a8 32 7b ee			ld (debug_mark+1),a  
c0ab 3a b5 c0			ld a, (.dmark+2)  
c0ae 32 7c ee			ld (debug_mark+2),a  
c0b1 18 03			jr .pastdmark  
c0b3 ..			.dmark: db "KEY"  
c0b6 f1			.pastdmark: pop af  
c0b7			endm  
# End of macro DMARK
c0b7						CALLMONITOR 
c0b7 cd 1d 93			call break_point_state  
c0ba				endm  
# End of macro CALLMONITOR
c0ba					endif 
c0ba			; TODO currently waits 
c0ba cd 39 d7				call cin 
c0bd					;call cin_wait 
c0bd 6f					ld l, a 
c0be 26 00				ld h, 0 
c0c0 cd aa 98				call forth_push_numhl 
c0c3					NEXTW 
c0c3 c3 13 9c			jp macro_next 
c0c6				endm 
# End of macro NEXTW
c0c6			.WAITK: 
c0c6				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c0c6 3f				db WORD_SYS_CORE+43             
c0c7 f8 c0			dw .ACCEPT            
c0c9 06				db 5 + 1 
c0ca .. 00			db "WAITK",0              
c0d0				endm 
# End of macro CWHEAD
c0d0			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c0d0					if DEBUG_FORTH_WORDS_KEY 
c0d0						DMARK "WAI" 
c0d0 f5				push af  
c0d1 3a e5 c0			ld a, (.dmark)  
c0d4 32 7a ee			ld (debug_mark),a  
c0d7 3a e6 c0			ld a, (.dmark+1)  
c0da 32 7b ee			ld (debug_mark+1),a  
c0dd 3a e7 c0			ld a, (.dmark+2)  
c0e0 32 7c ee			ld (debug_mark+2),a  
c0e3 18 03			jr .pastdmark  
c0e5 ..			.dmark: db "WAI"  
c0e8 f1			.pastdmark: pop af  
c0e9			endm  
# End of macro DMARK
c0e9						CALLMONITOR 
c0e9 cd 1d 93			call break_point_state  
c0ec				endm  
# End of macro CALLMONITOR
c0ec					endif 
c0ec cd 33 d7				call cin_wait 
c0ef 6f					ld l, a 
c0f0 26 00				ld h, 0 
c0f2 cd aa 98				call forth_push_numhl 
c0f5					NEXTW 
c0f5 c3 13 9c			jp macro_next 
c0f8				endm 
# End of macro NEXTW
c0f8			.ACCEPT: 
c0f8				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c0f8 40				db WORD_SYS_CORE+44             
c0f9 56 c1			dw .EDIT            
c0fb 07				db 6 + 1 
c0fc .. 00			db "ACCEPT",0              
c103				endm 
# End of macro CWHEAD
c103			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c103					; TODO crashes on push 
c103					if DEBUG_FORTH_WORDS_KEY 
c103						DMARK "ACC" 
c103 f5				push af  
c104 3a 18 c1			ld a, (.dmark)  
c107 32 7a ee			ld (debug_mark),a  
c10a 3a 19 c1			ld a, (.dmark+1)  
c10d 32 7b ee			ld (debug_mark+1),a  
c110 3a 1a c1			ld a, (.dmark+2)  
c113 32 7c ee			ld (debug_mark+2),a  
c116 18 03			jr .pastdmark  
c118 ..			.dmark: db "ACC"  
c11b f1			.pastdmark: pop af  
c11c			endm  
# End of macro DMARK
c11c						CALLMONITOR 
c11c cd 1d 93			call break_point_state  
c11f				endm  
# End of macro CALLMONITOR
c11f					endif 
c11f 21 5e e5				ld hl, os_input 
c122 3e 00				ld a, 0 
c124 77					ld (hl),a 
c125 3a 49 eb				ld a,(f_cursor_ptr) 
c128 16 64				ld d, 100 
c12a 0e 00				ld c, 0 
c12c 1e 28				ld e, 40 
c12e cd d7 8a				call input_str 
c131					; TODO perhaps do a type check and wrap in quotes if not a number 
c131 21 5e e5				ld hl, os_input 
c134					if DEBUG_FORTH_WORDS 
c134						DMARK "AC1" 
c134 f5				push af  
c135 3a 49 c1			ld a, (.dmark)  
c138 32 7a ee			ld (debug_mark),a  
c13b 3a 4a c1			ld a, (.dmark+1)  
c13e 32 7b ee			ld (debug_mark+1),a  
c141 3a 4b c1			ld a, (.dmark+2)  
c144 32 7c ee			ld (debug_mark+2),a  
c147 18 03			jr .pastdmark  
c149 ..			.dmark: db "AC1"  
c14c f1			.pastdmark: pop af  
c14d			endm  
# End of macro DMARK
c14d						CALLMONITOR 
c14d cd 1d 93			call break_point_state  
c150				endm  
# End of macro CALLMONITOR
c150					endif 
c150 cd 18 99				call forth_push_str 
c153					NEXTW 
c153 c3 13 9c			jp macro_next 
c156				endm 
# End of macro NEXTW
c156			 
c156			.EDIT: 
c156				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
c156 40				db WORD_SYS_CORE+44             
c157 f8 c1			dw .ENDKEY            
c159 05				db 4 + 1 
c15a .. 00			db "EDIT",0              
c15f				endm 
# End of macro CWHEAD
c15f			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c15f			 
c15f					; TODO does not copy from stack 
c15f					if DEBUG_FORTH_WORDS_KEY 
c15f						DMARK "EDT" 
c15f f5				push af  
c160 3a 74 c1			ld a, (.dmark)  
c163 32 7a ee			ld (debug_mark),a  
c166 3a 75 c1			ld a, (.dmark+1)  
c169 32 7b ee			ld (debug_mark+1),a  
c16c 3a 76 c1			ld a, (.dmark+2)  
c16f 32 7c ee			ld (debug_mark+2),a  
c172 18 03			jr .pastdmark  
c174 ..			.dmark: db "EDT"  
c177 f1			.pastdmark: pop af  
c178			endm  
# End of macro DMARK
c178						CALLMONITOR 
c178 cd 1d 93			call break_point_state  
c17b				endm  
# End of macro CALLMONITOR
c17b					endif 
c17b			 
c17b					;FORTH_DSP 
c17b					FORTH_DSP_VALUEHL 
c17b cd a1 9a			call macro_dsp_valuehl 
c17e				endm 
# End of macro FORTH_DSP_VALUEHL
c17e			;		inc hl    ; TODO do type check 
c17e			 
c17e			;		call get_word_hl 
c17e e5					push hl 
c17f					if DEBUG_FORTH_WORDS 
c17f						DMARK "EDp" 
c17f f5				push af  
c180 3a 94 c1			ld a, (.dmark)  
c183 32 7a ee			ld (debug_mark),a  
c186 3a 95 c1			ld a, (.dmark+1)  
c189 32 7b ee			ld (debug_mark+1),a  
c18c 3a 96 c1			ld a, (.dmark+2)  
c18f 32 7c ee			ld (debug_mark+2),a  
c192 18 03			jr .pastdmark  
c194 ..			.dmark: db "EDp"  
c197 f1			.pastdmark: pop af  
c198			endm  
# End of macro DMARK
c198						CALLMONITOR 
c198 cd 1d 93			call break_point_state  
c19b				endm  
# End of macro CALLMONITOR
c19b					endif 
c19b				;	ld a, 0 
c19b cd 08 8f				call strlenz 
c19e 23					inc hl 
c19f			 
c19f 06 00				ld b, 0 
c1a1 4d					ld c, l 
c1a2			 
c1a2 e1					pop hl 
c1a3 11 5e e5				ld de, os_input 
c1a6					if DEBUG_FORTH_WORDS_KEY 
c1a6						DMARK "EDc" 
c1a6 f5				push af  
c1a7 3a bb c1			ld a, (.dmark)  
c1aa 32 7a ee			ld (debug_mark),a  
c1ad 3a bc c1			ld a, (.dmark+1)  
c1b0 32 7b ee			ld (debug_mark+1),a  
c1b3 3a bd c1			ld a, (.dmark+2)  
c1b6 32 7c ee			ld (debug_mark+2),a  
c1b9 18 03			jr .pastdmark  
c1bb ..			.dmark: db "EDc"  
c1be f1			.pastdmark: pop af  
c1bf			endm  
# End of macro DMARK
c1bf						CALLMONITOR 
c1bf cd 1d 93			call break_point_state  
c1c2				endm  
# End of macro CALLMONITOR
c1c2					endif 
c1c2 ed b0				ldir 
c1c4			 
c1c4			 
c1c4 21 5e e5				ld hl, os_input 
c1c7					;ld a, 0 
c1c7					;ld (hl),a 
c1c7 3a 49 eb				ld a,(f_cursor_ptr) 
c1ca 16 64				ld d, 100 
c1cc 0e 00				ld c, 0 
c1ce 1e 28				ld e, 40 
c1d0 cd d7 8a				call input_str 
c1d3					; TODO perhaps do a type check and wrap in quotes if not a number 
c1d3 21 5e e5				ld hl, os_input 
c1d6					if DEBUG_FORTH_WORDS 
c1d6						DMARK "ED1" 
c1d6 f5				push af  
c1d7 3a eb c1			ld a, (.dmark)  
c1da 32 7a ee			ld (debug_mark),a  
c1dd 3a ec c1			ld a, (.dmark+1)  
c1e0 32 7b ee			ld (debug_mark+1),a  
c1e3 3a ed c1			ld a, (.dmark+2)  
c1e6 32 7c ee			ld (debug_mark+2),a  
c1e9 18 03			jr .pastdmark  
c1eb ..			.dmark: db "ED1"  
c1ee f1			.pastdmark: pop af  
c1ef			endm  
# End of macro DMARK
c1ef						CALLMONITOR 
c1ef cd 1d 93			call break_point_state  
c1f2				endm  
# End of macro CALLMONITOR
c1f2					endif 
c1f2 cd 18 99				call forth_push_str 
c1f5					NEXTW 
c1f5 c3 13 9c			jp macro_next 
c1f8				endm 
# End of macro NEXTW
c1f8			 
c1f8			 
c1f8			 
c1f8			.ENDKEY: 
c1f8			; eof 
c1f8			 
# End of file forth_words_key.asm
c1f8			 
c1f8			if STORAGE_SE 
c1f8			   	include "forth_words_storage.asm" 
c1f8			endif 
c1f8				include "forth_words_device.asm" 
c1f8			; Device related words 
c1f8			 
c1f8			; | ## Device Words 
c1f8			 
c1f8			if SOUND_ENABLE 
c1f8			.NOTE: 
c1f8				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c1f8			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c1f8					if DEBUG_FORTH_WORDS_KEY 
c1f8						DMARK "NTE" 
c1f8						CALLMONITOR 
c1f8					endif 
c1f8			 
c1f8				 
c1f8			 
c1f8					NEXTW 
c1f8			.AFTERSOUND: 
c1f8			endif 
c1f8			 
c1f8			 
c1f8			USE_GPIO: equ 0 
c1f8			 
c1f8			if USE_GPIO 
c1f8			.GP1: 
c1f8				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c1f8			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c1f8					NEXTW 
c1f8			.GP2: 
c1f8				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c1f8			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c1f8			 
c1f8					NEXTW 
c1f8			 
c1f8			.GP3: 
c1f8				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c1f8			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c1f8			 
c1f8					NEXTW 
c1f8			 
c1f8			.GP4: 
c1f8				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c1f8			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c1f8			 
c1f8					NEXTW 
c1f8			.SIN: 
c1f8			 
c1f8			 
c1f8			endif 
c1f8			 
c1f8			 
c1f8				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c1f8 33				db WORD_SYS_CORE+31             
c1f9 2d c2			dw .SOUT            
c1fb 03				db 2 + 1 
c1fc .. 00			db "IN",0              
c1ff				endm 
# End of macro CWHEAD
c1ff			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c1ff					if DEBUG_FORTH_WORDS_KEY 
c1ff						DMARK "IN." 
c1ff f5				push af  
c200 3a 14 c2			ld a, (.dmark)  
c203 32 7a ee			ld (debug_mark),a  
c206 3a 15 c2			ld a, (.dmark+1)  
c209 32 7b ee			ld (debug_mark+1),a  
c20c 3a 16 c2			ld a, (.dmark+2)  
c20f 32 7c ee			ld (debug_mark+2),a  
c212 18 03			jr .pastdmark  
c214 ..			.dmark: db "IN."  
c217 f1			.pastdmark: pop af  
c218			endm  
# End of macro DMARK
c218						CALLMONITOR 
c218 cd 1d 93			call break_point_state  
c21b				endm  
# End of macro CALLMONITOR
c21b					endif 
c21b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c21b cd a1 9a			call macro_dsp_valuehl 
c21e				endm 
# End of macro FORTH_DSP_VALUEHL
c21e			 
c21e e5					push hl 
c21f			 
c21f					; destroy value TOS 
c21f			 
c21f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c21f cd 59 9b			call macro_forth_dsp_pop 
c222				endm 
# End of macro FORTH_DSP_POP
c222			 
c222					; one value on hl get other one back 
c222			 
c222 c1					pop bc 
c223			 
c223					; do the sub 
c223			;		ex de, hl 
c223			 
c223 ed 68				in l,(c) 
c225			 
c225					; save it 
c225			 
c225 26 00				ld h,0 
c227			 
c227					; TODO push value back onto stack for another op etc 
c227			 
c227 cd aa 98				call forth_push_numhl 
c22a					NEXTW 
c22a c3 13 9c			jp macro_next 
c22d				endm 
# End of macro NEXTW
c22d			.SOUT: 
c22d				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c22d 34				db WORD_SYS_CORE+32             
c22e 80 c2			dw .SPIO            
c230 04				db 3 + 1 
c231 .. 00			db "OUT",0              
c235				endm 
# End of macro CWHEAD
c235			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c235					if DEBUG_FORTH_WORDS_KEY 
c235						DMARK "OUT" 
c235 f5				push af  
c236 3a 4a c2			ld a, (.dmark)  
c239 32 7a ee			ld (debug_mark),a  
c23c 3a 4b c2			ld a, (.dmark+1)  
c23f 32 7b ee			ld (debug_mark+1),a  
c242 3a 4c c2			ld a, (.dmark+2)  
c245 32 7c ee			ld (debug_mark+2),a  
c248 18 03			jr .pastdmark  
c24a ..			.dmark: db "OUT"  
c24d f1			.pastdmark: pop af  
c24e			endm  
# End of macro DMARK
c24e						CALLMONITOR 
c24e cd 1d 93			call break_point_state  
c251				endm  
# End of macro CALLMONITOR
c251					endif 
c251			 
c251					; get port 
c251			 
c251					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c251 cd a1 9a			call macro_dsp_valuehl 
c254				endm 
# End of macro FORTH_DSP_VALUEHL
c254			 
c254 e5					push hl 
c255			 
c255					; destroy value TOS 
c255			 
c255					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c255 cd 59 9b			call macro_forth_dsp_pop 
c258				endm 
# End of macro FORTH_DSP_POP
c258			 
c258					; get byte to send 
c258			 
c258					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c258 cd a1 9a			call macro_dsp_valuehl 
c25b				endm 
# End of macro FORTH_DSP_VALUEHL
c25b			 
c25b			;		push hl 
c25b			 
c25b					; destroy value TOS 
c25b			 
c25b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c25b cd 59 9b			call macro_forth_dsp_pop 
c25e				endm 
# End of macro FORTH_DSP_POP
c25e			 
c25e					; one value on hl get other one back 
c25e			 
c25e			;		pop hl 
c25e			 
c25e c1					pop bc 
c25f			 
c25f					if DEBUG_FORTH_WORDS 
c25f						DMARK "OUT" 
c25f f5				push af  
c260 3a 74 c2			ld a, (.dmark)  
c263 32 7a ee			ld (debug_mark),a  
c266 3a 75 c2			ld a, (.dmark+1)  
c269 32 7b ee			ld (debug_mark+1),a  
c26c 3a 76 c2			ld a, (.dmark+2)  
c26f 32 7c ee			ld (debug_mark+2),a  
c272 18 03			jr .pastdmark  
c274 ..			.dmark: db "OUT"  
c277 f1			.pastdmark: pop af  
c278			endm  
# End of macro DMARK
c278						CALLMONITOR 
c278 cd 1d 93			call break_point_state  
c27b				endm  
# End of macro CALLMONITOR
c27b					endif 
c27b			 
c27b ed 69				out (c), l 
c27d			 
c27d					NEXTW 
c27d c3 13 9c			jp macro_next 
c280				endm 
# End of macro NEXTW
c280			 
c280			 
c280			.SPIO: 
c280			 
c280			if STORAGE_SE 
c280				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c280			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c280			 
c280					call spi_ce_low 
c280			    NEXTW 
c280			 
c280			.SPICEH: 
c280				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c280			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c280			 
c280					call spi_ce_high 
c280			    NEXTW 
c280			 
c280			 
c280			.SPIOb: 
c280			 
c280				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c280			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c280			 
c280					; get port 
c280			 
c280			 
c280					; get byte to send 
c280			 
c280					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c280			 
c280			;		push hl    ; u1  
c280			 
c280					; destroy value TOS 
c280			 
c280					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c280			 
c280					; one value on hl get other one back 
c280			 
c280			;		pop hl   ; u2 - addr 
c280			 
c280					; TODO Send SPI byte 
c280			 
c280					ld a, l 
c280					call spi_send_byte 
c280			 
c280					NEXTW 
c280			 
c280			.SPII: 
c280				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c280			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c280			 
c280					; TODO Get SPI byte 
c280			 
c280					call spi_read_byte 
c280			 
c280					ld h, 0 
c280					ld l, a 
c280					call forth_push_numhl 
c280			 
c280					NEXTW 
c280			 
c280			 
c280			 
c280			.SESEL: 
c280				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c280			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c280					if DEBUG_FORTH_WORDS_KEY 
c280						DMARK "BNK" 
c280						CALLMONITOR 
c280					endif 
c280			 
c280					ld a, 255 
c280					ld (spi_cartdev), a 
c280			 
c280					; get bank 
c280			 
c280					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c280			 
c280			;		push hl 
c280			 
c280					; destroy value TOS 
c280			 
c280					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c280			 
c280					; one value on hl get other one back 
c280			 
c280			;		pop hl 
c280			 
c280			 
c280					ld c, SPI_CE_HIGH 
c280					ld b, '0'    ; human readable bank number 
c280			 
c280					ld a, l 
c280			 
c280					if DEBUG_FORTH_WORDS 
c280						DMARK "BNK" 
c280						CALLMONITOR 
c280					endif 
c280			 
c280					; active low 
c280			 
c280					cp 0 
c280					jr z, .bset 
c280					cp 1 
c280					jr nz, .b2 
c280					res 0, c 
c280					ld b, '1'    ; human readable bank number 
c280			.b2:		cp 2 
c280					jr nz, .b3 
c280					res 1, c 
c280					ld b, '2'    ; human readable bank number 
c280			.b3:		cp 3 
c280					jr nz, .b4 
c280					res 2, c 
c280					ld b, '3'    ; human readable bank number 
c280			.b4:		cp 4 
c280					jr nz, .b5 
c280					res 3, c 
c280					ld b, '4'    ; human readable bank number 
c280			.b5:		cp 5 
c280					jr nz, .bset 
c280					res 4, c 
c280					ld b, '5'    ; human readable bank number 
c280			 
c280			.bset: 
c280					ld a, c 
c280					ld (spi_device),a 
c280					ld a, b 
c280					ld (spi_device_id),a 
c280					if DEBUG_FORTH_WORDS 
c280						DMARK "BN2" 
c280						CALLMONITOR 
c280					endif 
c280			 
c280					NEXTW 
c280			 
c280			.CARTDEV: 
c280				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c280			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c280					if DEBUG_FORTH_WORDS_KEY 
c280						DMARK "CDV" 
c280						CALLMONITOR 
c280					endif 
c280			 
c280					; disable se storage bank selection 
c280			 
c280					ld a, SPI_CE_HIGH		; ce high 
c280					ld (spi_device), a 
c280			 
c280					; get bank 
c280			 
c280					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c280			 
c280			;		push hl 
c280			 
c280					; destroy value TOS 
c280			 
c280					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c280			 
c280					; one value on hl get other one back 
c280			 
c280			;		pop hl 
c280			 
c280					; active low 
c280			 
c280					ld c, 255 
c280			 
c280					ld a, l 
c280					if DEBUG_FORTH_WORDS 
c280						DMARK "CDV" 
c280						CALLMONITOR 
c280					endif 
c280					cp 0 
c280					jr z, .cset 
c280					cp 1 
c280					jr nz, .c2 
c280					res 0, c 
c280			.c2:		cp 2 
c280					jr nz, .c3 
c280					res 1, c 
c280			.c3:		cp 3 
c280					jr nz, .c4 
c280					res 2, c 
c280			.c4:		cp 4 
c280					jr nz, .c5 
c280					res 3, c 
c280			.c5:		cp 5 
c280					jr nz, .c6 
c280					res 4, c 
c280			.c6:		cp 6 
c280					jr nz, .c7 
c280					res 5, c 
c280			.c7:		cp 7 
c280					jr nz, .c8 
c280					res 6, c 
c280			.c8:		cp 8 
c280					jr nz, .cset 
c280					res 7, c 
c280			.cset:		ld a, c 
c280					ld (spi_cartdev),a 
c280			 
c280					if DEBUG_FORTH_WORDS 
c280						DMARK "CD2" 
c280						CALLMONITOR 
c280					endif 
c280					NEXTW 
c280			endif 
c280			 
c280			.ENDDEVICE: 
c280			; eof 
c280			 
# End of file forth_words_device.asm
c280			 
c280			; var handler 
c280			 
c280			 
c280			.VARS: 
c280				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
c280 78				db WORD_SYS_CORE+100             
c281 98 c2			dw .V0Q            
c283 04				db 3 + 1 
c284 .. 00			db "V0!",0              
c288				endm 
# End of macro CWHEAD
c288			;| V0! ( u1 -- )  Store value to v0  | DONE 
c288			 
c288					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c288 cd a1 9a			call macro_dsp_valuehl 
c28b				endm 
# End of macro FORTH_DSP_VALUEHL
c28b			 
c28b 11 13 eb				ld de, cli_var_array 
c28e			 
c28e eb					ex de, hl 
c28f 73					ld (hl), e 
c290 23					inc hl 
c291 72					ld (hl), d 
c292			 
c292					; destroy value TOS 
c292			 
c292					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c292 cd 59 9b			call macro_forth_dsp_pop 
c295				endm 
# End of macro FORTH_DSP_POP
c295			 
c295				       NEXTW 
c295 c3 13 9c			jp macro_next 
c298				endm 
# End of macro NEXTW
c298			.V0Q: 
c298				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c298 79				db WORD_SYS_CORE+101             
c299 a9 c2			dw .V1S            
c29b 04				db 3 + 1 
c29c .. 00			db "V0@",0              
c2a0				endm 
# End of macro CWHEAD
c2a0			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c2a0 2a 13 eb				ld hl, (cli_var_array) 
c2a3 cd aa 98				call forth_push_numhl 
c2a6			 
c2a6				       NEXTW 
c2a6 c3 13 9c			jp macro_next 
c2a9				endm 
# End of macro NEXTW
c2a9			.V1S: 
c2a9				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c2a9 7a				db WORD_SYS_CORE+102             
c2aa c1 c2			dw .V1Q            
c2ac 04				db 3 + 1 
c2ad .. 00			db "V1!",0              
c2b1				endm 
# End of macro CWHEAD
c2b1			;| V1! ( u1 -- )  Store value to v1 | DONE 
c2b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2b1 cd a1 9a			call macro_dsp_valuehl 
c2b4				endm 
# End of macro FORTH_DSP_VALUEHL
c2b4			 
c2b4 11 15 eb				ld de, cli_var_array+2 
c2b7				 
c2b7 eb					ex de, hl 
c2b8 73					ld (hl), e 
c2b9 23					inc hl 
c2ba 72					ld (hl), d 
c2bb			 
c2bb					; destroy value TOS 
c2bb			 
c2bb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2bb cd 59 9b			call macro_forth_dsp_pop 
c2be				endm 
# End of macro FORTH_DSP_POP
c2be				       NEXTW 
c2be c3 13 9c			jp macro_next 
c2c1				endm 
# End of macro NEXTW
c2c1			.V1Q: 
c2c1				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c2c1 7b				db WORD_SYS_CORE+103             
c2c2 d2 c2			dw .V2S            
c2c4 04				db 3 + 1 
c2c5 .. 00			db "V1@",0              
c2c9				endm 
# End of macro CWHEAD
c2c9			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c2c9 2a 15 eb				ld hl, (cli_var_array+2) 
c2cc cd aa 98				call forth_push_numhl 
c2cf				       NEXTW 
c2cf c3 13 9c			jp macro_next 
c2d2				endm 
# End of macro NEXTW
c2d2			.V2S: 
c2d2				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c2d2 7c				db WORD_SYS_CORE+104             
c2d3 ea c2			dw .V2Q            
c2d5 04				db 3 + 1 
c2d6 .. 00			db "V2!",0              
c2da				endm 
# End of macro CWHEAD
c2da			;| V2! ( u1 -- )  Store value to v2 | DONE 
c2da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2da cd a1 9a			call macro_dsp_valuehl 
c2dd				endm 
# End of macro FORTH_DSP_VALUEHL
c2dd			 
c2dd 11 17 eb				ld de, cli_var_array+4 
c2e0				 
c2e0 eb					ex de, hl 
c2e1 73					ld (hl), e 
c2e2 23					inc hl 
c2e3 72					ld (hl), d 
c2e4			 
c2e4					; destroy value TOS 
c2e4			 
c2e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2e4 cd 59 9b			call macro_forth_dsp_pop 
c2e7				endm 
# End of macro FORTH_DSP_POP
c2e7				       NEXTW 
c2e7 c3 13 9c			jp macro_next 
c2ea				endm 
# End of macro NEXTW
c2ea			.V2Q: 
c2ea				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c2ea 7d				db WORD_SYS_CORE+105             
c2eb fb c2			dw .V3S            
c2ed 04				db 3 + 1 
c2ee .. 00			db "V2@",0              
c2f2				endm 
# End of macro CWHEAD
c2f2			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c2f2 2a 17 eb				ld hl, (cli_var_array+4) 
c2f5 cd aa 98				call forth_push_numhl 
c2f8				       NEXTW 
c2f8 c3 13 9c			jp macro_next 
c2fb				endm 
# End of macro NEXTW
c2fb			.V3S: 
c2fb				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c2fb 7c				db WORD_SYS_CORE+104             
c2fc 13 c3			dw .V3Q            
c2fe 04				db 3 + 1 
c2ff .. 00			db "V3!",0              
c303				endm 
# End of macro CWHEAD
c303			;| V3! ( u1 -- )  Store value to v3 | DONE 
c303					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c303 cd a1 9a			call macro_dsp_valuehl 
c306				endm 
# End of macro FORTH_DSP_VALUEHL
c306			 
c306 11 19 eb				ld de, cli_var_array+6 
c309				 
c309 eb					ex de, hl 
c30a 73					ld (hl), e 
c30b 23					inc hl 
c30c 72					ld (hl), d 
c30d			 
c30d					; destroy value TOS 
c30d			 
c30d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c30d cd 59 9b			call macro_forth_dsp_pop 
c310				endm 
# End of macro FORTH_DSP_POP
c310				       NEXTW 
c310 c3 13 9c			jp macro_next 
c313				endm 
# End of macro NEXTW
c313			.V3Q: 
c313				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c313 7d				db WORD_SYS_CORE+105             
c314 24 c3			dw .END            
c316 04				db 3 + 1 
c317 .. 00			db "V3@",0              
c31b				endm 
# End of macro CWHEAD
c31b			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c31b 2a 19 eb				ld hl, (cli_var_array+6) 
c31e cd aa 98				call forth_push_numhl 
c321				       NEXTW 
c321 c3 13 9c			jp macro_next 
c324				endm 
# End of macro NEXTW
c324			 
c324			 
c324			 
c324			 
c324			 
c324			; end of dict marker 
c324			 
c324 00			.END:    db WORD_SYS_END 
c325 00 00			dw 0 
c327 00				db 0 
c328			 
c328			; use to jp here for user dict words to save on macro expansion  
c328			 
c328			user_dict_next: 
c328				NEXTW 
c328 c3 13 9c			jp macro_next 
c32b				endm 
# End of macro NEXTW
c32b			 
c32b			 
c32b			user_exec: 
c32b				;    ld hl, <word code> 
c32b				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c32b				;    call forthexec 
c32b				;    jp user_dict_next   (NEXT) 
c32b			        ;    <word code bytes> 
c32b eb				ex de, hl 
c32c 2a 61 e6			ld hl,(os_tok_ptr) 
c32f				 
c32f				FORTH_RSP_NEXT 
c32f cd 51 98			call macro_forth_rsp_next 
c332				endm 
# End of macro FORTH_RSP_NEXT
c332			 
c332			if DEBUG_FORTH_UWORD 
c332						DMARK "UEX" 
c332 f5				push af  
c333 3a 47 c3			ld a, (.dmark)  
c336 32 7a ee			ld (debug_mark),a  
c339 3a 48 c3			ld a, (.dmark+1)  
c33c 32 7b ee			ld (debug_mark+1),a  
c33f 3a 49 c3			ld a, (.dmark+2)  
c342 32 7c ee			ld (debug_mark+2),a  
c345 18 03			jr .pastdmark  
c347 ..			.dmark: db "UEX"  
c34a f1			.pastdmark: pop af  
c34b			endm  
# End of macro DMARK
c34b				CALLMONITOR 
c34b cd 1d 93			call break_point_state  
c34e				endm  
# End of macro CALLMONITOR
c34e			endif 
c34e			 
c34e			 
c34e			 
c34e eb				ex de, hl 
c34f 22 61 e6			ld (os_tok_ptr), hl 
c352				 
c352				; Don't use next - Skips the first word in uword. 
c352			 
c352 c3 a4 9c			jp exec1 
c355			;	NEXT 
c355			 
c355			 
c355			; eof 
# End of file forth_wordsv4.asm
c355			endif 
c355			;;;;;;;;;;;;;; Debug code 
c355			 
c355			 
c355			;if DEBUG_FORTH_PARSE 
c355 .. 00		.nowordfound: db "No match",0 
c35e .. 00		.compword:	db "Comparing word ",0 
c36e .. 00		.nextwordat:	db "Next word at",0 
c37b .. 00		.charmatch:	db "Char match",0 
c386			;endif 
c386			if DEBUG_FORTH_JP 
c386			.foundword:	db "Word match. Exec..",0 
c386			endif 
c386			;if DEBUG_FORTH_PUSH 
c386 .. 00		.enddict:	db "Dict end. Push.",0 
c396 .. 00		.push_str:	db "Pushing string",0 
c3a5 .. 00		.push_num:	db "Pushing number",0 
c3b4 .. 00		.data_sp:	db "SP:",0 
c3b8 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c3ca .. 00		.wordinde:	db "Word in DE (3/0):",0 
c3dc .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c3ee			;endif 
c3ee			;if DEBUG_FORTH_MALLOC 
c3ee .. 00		.push_malloc:	db "Malloc address",0 
c3fd			;endif 
c3fd			 
c3fd			 
c3fd			 
c3fd			; display malloc address and current data stack pointer  
c3fd			 
c3fd			malloc_error: 
c3fd d5				push de 
c3fe f5				push af 
c3ff e5				push hl 
c400 cd 7d 88			call clear_display 
c403 11 25 c4			ld de, .mallocerr 
c406 3e 00			ld a,0 
c408			;	ld de,os_word_scratch 
c408 cd 90 88			call str_at_display 
c40b 3e 11			ld a, display_row_1+17 
c40d 11 7a ee			ld de, debug_mark 
c410 cd 90 88			call str_at_display 
c413 cd a0 88			call update_display 
c416				;call break_point_state 
c416 cd 33 d7			call cin_wait 
c419			 
c419 3e 20			ld a, ' ' 
c41b 32 51 e3			ld (os_view_disable), a 
c41e e1				pop hl 
c41f f1				pop af 
c420 d1				pop de	 
c421				CALLMONITOR 
c421 cd 1d 93			call break_point_state  
c424				endm  
# End of macro CALLMONITOR
c424 c9				ret 
c425			 
c425 .. 00		.mallocerr: 	db "Malloc Error",0 
c432			;if DEBUG_FORTH_PUSH 
c432			display_data_sp: 
c432 f5				push af 
c433			 
c433				; see if disabled 
c433			 
c433 3a 51 e3			ld a, (os_view_disable) 
c436 fe 2a			cp '*' 
c438 28 67			jr z, .skipdsp 
c43a			 
c43a e5				push hl 
c43b e5				push hl 
c43c e5			push hl 
c43d cd 7d 88			call clear_display 
c440 e1			pop hl 
c441 7c				ld a,h 
c442 21 65 e6			ld hl, os_word_scratch 
c445 cd ab 8d			call hexout 
c448 e1				pop hl 
c449 7d				ld a,l 
c44a 21 67 e6			ld hl, os_word_scratch+2 
c44d cd ab 8d			call hexout 
c450 21 69 e6			ld hl, os_word_scratch+4 
c453 3e 00			ld a,0 
c455 77				ld (hl),a 
c456 11 65 e6			ld de,os_word_scratch 
c459 3e 28				ld a, display_row_2 
c45b cd 90 88				call str_at_display 
c45e 11 b8 c3			ld de, .wordinhl 
c461 3e 00			ld a, display_row_1 
c463			 
c463 cd 90 88				call str_at_display 
c466 11 7a ee			ld de, debug_mark 
c469 3e 11			ld a, display_row_1+17 
c46b			 
c46b cd 90 88				call str_at_display 
c46e			 
c46e				; display current data stack pointer 
c46e 11 b4 c3			ld de,.data_sp 
c471 3e 30				ld a, display_row_2 + 8 
c473 cd 90 88				call str_at_display 
c476			 
c476 2a 0d eb			ld hl,(cli_data_sp) 
c479 e5				push hl 
c47a 7c				ld a,h 
c47b 21 65 e6			ld hl, os_word_scratch 
c47e cd ab 8d			call hexout 
c481 e1				pop hl 
c482 7d				ld a,l 
c483 21 67 e6			ld hl, os_word_scratch+2 
c486 cd ab 8d			call hexout 
c489 21 69 e6			ld hl, os_word_scratch+4 
c48c 3e 00			ld a,0 
c48e 77				ld (hl),a 
c48f 11 65 e6			ld de,os_word_scratch 
c492 3e 33				ld a, display_row_2 + 11 
c494 cd 90 88				call str_at_display 
c497			 
c497			 
c497 cd a0 88			call update_display 
c49a cd fd 87			call delay1s 
c49d cd fd 87			call delay1s 
c4a0 e1				pop hl 
c4a1			.skipdsp: 
c4a1 f1				pop af 
c4a2 c9				ret 
c4a3			 
c4a3			display_data_malloc: 
c4a3			 
c4a3 f5				push af 
c4a4 e5				push hl 
c4a5 e5				push hl 
c4a6 e5			push hl 
c4a7 cd 7d 88			call clear_display 
c4aa e1			pop hl 
c4ab 7c				ld a,h 
c4ac 21 65 e6			ld hl, os_word_scratch 
c4af cd ab 8d			call hexout 
c4b2 e1				pop hl 
c4b3 7d				ld a,l 
c4b4 21 67 e6			ld hl, os_word_scratch+2 
c4b7 cd ab 8d			call hexout 
c4ba 21 69 e6			ld hl, os_word_scratch+4 
c4bd 3e 00			ld a,0 
c4bf 77				ld (hl),a 
c4c0 11 65 e6			ld de,os_word_scratch 
c4c3 3e 28				ld a, display_row_2 
c4c5 cd 90 88				call str_at_display 
c4c8 11 ee c3			ld de, .push_malloc 
c4cb 3e 00			ld a, display_row_1 
c4cd			 
c4cd cd 90 88				call str_at_display 
c4d0			 
c4d0				; display current data stack pointer 
c4d0 11 b4 c3			ld de,.data_sp 
c4d3 3e 30				ld a, display_row_2 + 8 
c4d5 cd 90 88				call str_at_display 
c4d8			 
c4d8 2a 0d eb			ld hl,(cli_data_sp) 
c4db e5				push hl 
c4dc 7c				ld a,h 
c4dd 21 65 e6			ld hl, os_word_scratch 
c4e0 cd ab 8d			call hexout 
c4e3 e1				pop hl 
c4e4 7d				ld a,l 
c4e5 21 67 e6			ld hl, os_word_scratch+2 
c4e8 cd ab 8d			call hexout 
c4eb 21 69 e6			ld hl, os_word_scratch+4 
c4ee 3e 00			ld a,0 
c4f0 77				ld (hl),a 
c4f1 11 65 e6			ld de,os_word_scratch 
c4f4 3e 33				ld a, display_row_2 + 11 
c4f6 cd 90 88				call str_at_display 
c4f9			 
c4f9 cd a0 88			call update_display 
c4fc cd fd 87			call delay1s 
c4ff cd fd 87			call delay1s 
c502 e1				pop hl 
c503 f1				pop af 
c504 c9				ret 
c505			;endif 
c505			 
c505			include "forth_autostart.asm" 
c505			; list of commands to perform at system start up 
c505			 
c505			startcmds: 
c505			;	dw test11 
c505			;	dw test12 
c505			;	dw test13 
c505			;	dw test14 
c505			;	dw test15 
c505			;	dw test16 
c505			;	dw test17 
c505			;	dw ifthtest1 
c505			;	dw ifthtest2 
c505			;	dw ifthtest3 
c505			;	dw mmtest1 
c505			;	dw mmtest2 
c505			;	dw mmtest3 
c505			;	dw mmtest4 
c505			;	dw mmtest5 
c505			;	dw mmtest6 
c505			;	dw iftest1 
c505			;	dw iftest2 
c505			;	dw iftest3 
c505			;	dw looptest1 
c505			;	dw looptest2 
c505			;	dw test1 
c505			;	dw test2 
c505			;	dw test3 
c505			;	dw test4 
c505			;	dw game2r 
c505			;	dw game2b1 
c505			;	dw game2b2 
c505			 
c505				; start up words that are actually useful 
c505			 
c505 63 c5			dw clrstack 
c507 96 c5			dw type 
c509 57 c7			dw stest 
c50b ba c5			dw strncpy 
c50d f8 c6			dw list 
c50f 1b c6			dw start1 
c511 2d c6			dw start2 
c513			;	dw start3 
c513 40 c6			dw start3b 
c515 98 c6			dw start3c 
c517			 
c517				; (unit) testing words 
c517			 
c517 ce c7			dw mtesta 
c519 83 c8			dw mtestb 
c51b 26 c9			dw mtestc 
c51d db c9			dw mtestd 
c51f 7f ca			dw mteste 
c521			 
c521				; demo/game words 
c521			 
c521 8b d1		        dw game3w 
c523 b9 d1		        dw game3p 
c525 d7 d1		        dw game3sc 
c527 08 d2		        dw game3vsi 
c529 34 d2		        dw game3vs 
c52b				 
c52b 7e cf			dw game2b 
c52d ec cf			dw game2bf 
c52f 36 d0			dw game2mba 
c531 cc d0			dw game2mbas 
c533 0e d1			dw game2mb 
c535			 
c535 3f cc			dw game1 
c537 50 cc			dw game1a 
c539 b2 cc			dw game1b 
c53b e7 cc			dw game1c 
c53d 1d cd			dw game1d 
c53f 4e cd			dw game1s 
c541 62 cd			dw game1t 
c543 77 cd			dw game1f 
c545 ab cd			dw game1z 
c547 ef cd			dw game1zz 
c549			 
c549 35 cb			dw test5 
c54b 6d cb			dw test6 
c54d a5 cb			dw test7 
c54f b9 cb			dw test8 
c551 e5 cb			dw test9 
c553 fb cb			dw test10 
c555				 
c555 c6 ce		        dw ssv5 
c557 aa ce		        dw ssv4 
c559 8e ce		        dw ssv3 
c55b 58 ce		        dw ssv2 
c55d df ce		        dw ssv1 
c55f 27 cf		        dw ssv1cpm 
c561			;	dw keyup 
c561			;	dw keydown 
c561			;	dw keyleft 
c561			;	dw keyright 
c561			;	dw 	keyf1 
c561			;	dw keyf2 
c561			;	dw keyf3 
c561			;	dw keyf4 
c561			;	dw keyf5 
c561			;	dw keyf6 
c561			;	dw keyf7 
c561			;	dw keyf8 
c561			;	dw keyf9 
c561			;	dw keyf10 
c561			;	dw keyf11 
c561			;	dw keyf12 
c561			;	dw keytab 
c561			;	dw keycr 
c561			;	dw keyhome 
c561			;	dw keyend 
c561			;	dw keybs 
c561 00 00			db 0, 0	 
c563			 
c563			 
c563			; clear stack  
c563			 
c563 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
c596			 
c596			; type ( addr count - ) 
c596 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
c5ba			 
c5ba			; some direct memory words 
c5ba			; strncpy ( len t f -- t ) 
c5ba			 
c5ba .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
c61b			 
c61b .. 00		start1:     	db ": bpon $0000 bp ;",0 
c62d .. 00		start2:     	db ": bpoff $0001 bp ;",0 
c640			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
c640 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
c698 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
c6f8			 
c6f8			 
c6f8			; a handy word to list items on the stack 
c6f8			 
c6f8 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
c757			 
c757			 
c757			; test stack  
c757			; rnd8 stest 
c757			 
c757 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
c7ce			 
c7ce			; random malloc and free cycles 
c7ce			 
c7ce .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c883			 
c883			; fixed malloc and free cycles 
c883			 
c883 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c926			 
c926			; fixed double string push and drop cycle  
c926			 
c926 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
c9db			 
c9db			; consistent fixed string push and drop cycle  
c9db			 
c9db .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
ca7f			 
ca7f .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cb35			 
cb35			;test1:		db ": aa 1 2 3 ;", 0 
cb35			;test2:     	db "111 aa 888 999",0 
cb35			;test3:     	db ": bb 77 ;",0 
cb35			;test4:     	db "$02 $01 do i . loop bb",0 
cb35			 
cb35 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
cb6d .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
cba5 .. 00		test7:     	db ": box hline vline ;",0 
cbb9 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
cbe5 .. 00		test9:     	db ": sw $01 adsp world ;",0 
cbfb .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
cc20 .. 00		test11:     	db "hello create .",0 
cc2f .. 00		test12:     	db "hello2 create .",0 
cc3f			 
cc3f			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
cc3f			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
cc3f			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
cc3f			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
cc3f			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
cc3f			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
cc3f			 
cc3f			;iftest1:     	db "$0001 IF cls .",0 
cc3f			;iftest2:     	db "$0000 IF cls .",0 
cc3f			;iftest3:     	db "$0002 $0003 - IF cls .",0 
cc3f			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
cc3f			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
cc3f			 
cc3f			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cc3f			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cc3f			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cc3f			 
cc3f			 
cc3f			 
cc3f			; a small guess the number game 
cc3f			 
cc3f .. 00		game1:          db ": gsn rnd8 v1! ;",0 
cc50 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
ccb2			 
ccb2 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
cce7 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
cd1d .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
cd4e .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
cd62 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
cd77 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
cdab .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
cdef			 
cdef			; Using 'ga' save a high score across multiple runs using external storage 
cdef			 
cdef .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
ce58			 
ce58			 
ce58			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
ce58			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
ce58			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
ce58			 
ce58			; simple screen saver to test code memory reuse to destruction 
ce58			 
ce58 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
ce8e .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
ceaa .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
cec6 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
cedf .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
cf27 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
cf7e			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
cf7e			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
cf7e			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
cf7e			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
cf7e			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
cf7e			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
cf7e			 
cf7e			 
cf7e			 
cf7e			; minesweeper/battleship finding game 
cf7e			; draws a game board of random ship/mine positions 
cf7e			; user enters coords to see if it hits on 
cf7e			; game ends when all are hit 
cf7e			; when hit or miss says how many may be in the area 
cf7e			 
cf7e			; setup the game board and then hide it 
cf7e .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
cfec .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d036			; prompt for where to target 
d036 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d0cc .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d0f1			; TODO see if the entered coords hits or misses pushes char hit of miss 
d0f1 .. 00		game2mbht:      db ": mbckht nop ;",0 
d100 .. 00		game2mbms:      db ": mbcms nop ;",0 
d10e			; TODO how many might be near by 
d10e .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d18b			 
d18b			; Game 3 
d18b			 
d18b			; Vert scroller ski game - avoid the trees! 
d18b			 
d18b			; v0 score (ie turns) 
d18b			; v1 player pos 
d18b			; v2 left wall 
d18b			; v3 right wall 
d18b			 
d18b			; Draw side walls randomly 
d18b			 
d18b .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d1b9			 
d1b9			; Draw player 
d1b9 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d1d7			 
d1d7			; TODO Get Key 
d1d7			 
d1d7			; TODO Move left right 
d1d7			 
d1d7			; scroll and move walls a bit 
d1d7			 
d1d7 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d208			 
d208			; main game loop 
d208			 
d208 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d234 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d273			 
d273			; key board defs 
d273			 
d273 .. 00		keyup:       db ": keyup $05 ;",0 
d281 .. 00		keydown:       db ": keydown $0a ;",0 
d291 .. 00		keyleft:       db ": keyleft $0b ;",0 
d2a1 .. 00		keyright:       db ": keyright $0c ;",0 
d2b2 .. 00		keyf1:       db ": keyf1 $10 ;",0 
d2c0 .. 00		keyf2:       db ": keyf2 $11 ;",0 
d2ce .. 00		keyf3:       db ": keyf3 $12 ;",0 
d2dc .. 00		keyf4:       db ": keyf4 $13 ;",0 
d2ea .. 00		keyf5:       db ": keyf5 $14 ;",0 
d2f8 .. 00		keyf6:       db ": keyf6 $15 ;",0 
d306 .. 00		keyf7:       db ": keyf7 $16 ;",0 
d314 .. 00		keyf8:       db ": keyf8 $17 ;",0 
d322 .. 00		keyf9:       db ": keyf9 $18 ;",0 
d330 .. 00		keyf10:       db ": keyf10 $19 ;",0 
d33f .. 00		keyf11:       db ": keyf11 $1a ;",0 
d34e .. 00		keyf12:       db ": keyf12 $1b ;",0 
d35d			 
d35d .. 00		keytab:       db ": keytab $09 ;",0 
d36c .. 00		keycr:       db ": keycr $0d ;",0 
d37a .. 00		keyhome:       db ": keyhome $0e ;",0 
d38a .. 00		keyend:       db ": keyend $0f ;",0 
d399 .. 00		keybs:       db ": keybs $08 ;",0 
d3a7			 
d3a7			   
d3a7			 
d3a7			 
d3a7			 
d3a7			; eof 
# End of file forth_autostart.asm
d3a7			 
d3a7 .. 00		sprompt1: db "Startup load...",0 
d3b7 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
d3cd			 
d3cd			 
d3cd			 
d3cd			 
d3cd			forth_startup: 
d3cd 21 05 c5			ld hl, startcmds 
d3d0 3e 00			ld a, 0 
d3d2 32 86 e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
d3d5			 
d3d5 e5			.start1:	push hl 
d3d6 cd 7d 88			call clear_display 
d3d9 11 a7 d3			ld de, sprompt1 
d3dc 3e 00		        ld a, display_row_1 
d3de cd 90 88			call str_at_display 
d3e1 11 b7 d3			ld de, sprompt2 
d3e4 3e 28		        ld a, display_row_2 
d3e6 cd 90 88			call str_at_display 
d3e9 e1				pop hl 
d3ea e5				push hl 
d3eb 5e				ld e,(hl) 
d3ec 23				inc hl 
d3ed 56				ld d,(hl) 
d3ee 3e 50		        ld a, display_row_3 
d3f0 cd 90 88			call str_at_display 
d3f3 cd a0 88			call update_display 
d3f6			 
d3f6			 
d3f6 3a 86 e7			ld a, (os_last_cmd) 
d3f9 fe 00			cp 0 
d3fb 28 05			jr z, .startprompt 
d3fd cd f1 87			call delay250ms 
d400 18 24			jr .startdo 
d402				 
d402				 
d402			 
d402			.startprompt: 
d402			 
d402 3e 9f			ld a,display_row_4 + display_cols - 1 
d404 11 20 98		        ld de, endprg 
d407 cd 90 88			call str_at_display 
d40a cd a0 88			call update_display 
d40d cd fd 87			call delay1s 
d410 cd 33 d7			call cin_wait 
d413						 
d413 fe 2a			cp '*' 
d415 28 5e			jr z, .startupend1 
d417 fe 23			cp '#' 
d419 20 07			jr nz, .startno 
d41b 3e 01			ld a, 1 
d41d 32 86 e7			ld (os_last_cmd),a 
d420 18 04			jr .startdo 
d422 fe 31		.startno:	cp '1' 
d424 28 3a			jr z,.startnxt  
d426			 
d426				; exec startup line 
d426			.startdo:	 
d426 e1				pop hl 
d427 e5				push hl 
d428				 
d428 5e				ld e,(hl) 
d429 23				inc hl 
d42a 56				ld d,(hl) 
d42b eb				ex de,hl 
d42c			 
d42c e5				push hl 
d42d			 
d42d 3e 00			ld a, 0 
d42f				;ld a, FORTH_END_BUFFER 
d42f cd 13 8f			call strlent 
d432 23				inc hl   ; include zero term to copy 
d433 06 00			ld b,0 
d435 4d				ld c,l 
d436 e1				pop hl 
d437 11 60 e3			ld de, scratch 
d43a ed b0			ldir 
d43c			 
d43c			 
d43c 21 60 e3			ld hl, scratch 
d43f cd 61 9c			call forthparse 
d442 cd a1 9c			call forthexec 
d445 cd b8 9b			call forthexec_cleanup 
d448			 
d448 3e 78			ld a, display_row_4 
d44a 11 c4 95			ld de, endprog 
d44d			 
d44d cd a0 88			call update_display		 
d450			 
d450 3a 86 e7			ld a, (os_last_cmd) 
d453 fe 00			cp 0 
d455 20 09			jr nz, .startnxt 
d457 cd 22 98			call next_page_prompt 
d45a cd 7d 88		        call clear_display 
d45d cd a0 88			call update_display		 
d460			 
d460				; move onto next startup line? 
d460			.startnxt: 
d460			 
d460 cd f1 87			call delay250ms 
d463 e1				pop hl 
d464			 
d464 23				inc hl 
d465 23				inc hl 
d466			 
d466 e5				push hl 
d467 5e				ld e, (hl) 
d468 23				inc hl 
d469 56				ld d, (hl) 
d46a e1				pop hl 
d46b				; TODO replace 0 test 
d46b			 
d46b eb				ex de, hl 
d46c cd d3 8a			call ishlzero 
d46f			;	ld a,e 
d46f			;	add d 
d46f			;	cp 0    ; any left to do? 
d46f eb				ex de, hl 
d470 c2 d5 d3			jp nz, .start1 
d473 18 01			jr .startupend 
d475			 
d475 e1			.startupend1: pop hl 
d476			.startupend: 
d476			 
d476 cd 7d 88			call clear_display 
d479 cd a0 88			call update_display 
d47c c9				ret 
d47d			 
d47d			 
d47d			; stack over and underflow checks 
d47d			 
d47d			; init the words to detect the under/overflow 
d47d			 
d47d			chk_stk_init: 
d47d				; a vague random number to check so we dont get any "lucky" hits 
d47d 3e 2d			ld a, 45 
d47f 6f				ld l, a 
d480 00				nop 
d481 3e 17			ld a, 23 
d483 67				ld h, a 
d484			 
d484 22 47 e3			ld (chk_word), hl     ; the word we need to check against 
d487			 
d487			;	ld (chk_stund), hl	; stack points.... 
d487 22 00 ef			ld (chk_stovr), hl 
d48a 22 0b eb			ld (chk_ret_und), hl 
d48d 22 c9 ea			ld (chk_ret_ovr), hl 
d490 22 c7 e9			ld (chk_loop_ovr), hl 
d493 22 c5 e8			ld (chk_data_ovr), hl 
d496 c9				ret 
d497				 
d497			check_stacks: 
d497				; check all stack words 
d497			 
d497 e5				push hl 
d498 d5				push de 
d499			 
d499			;	ld de,(chk_word) 
d499			;	ld hl, (chk_stund)	; stack points.... 
d499			;	if DEBUG_STK_FAULT 
d499			;		DMARK "FAa" 
d499			;		CALLMONITOR 
d499			;	endif 
d499			;	call cmp16 
d499			;	jp z, .chk_faulta 
d499			; 
d499			;	ld de, sfaultsu 
d499			;	jp .chk_fault 
d499			 
d499 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d49c ed 5b 47 e3		ld de,(chk_word) 
d4a0				if DEBUG_STK_FAULT 
d4a0					DMARK "FAb" 
d4a0					CALLMONITOR 
d4a0				endif 
d4a0 cd c8 8a			call cmp16 
d4a3 28 06			jr z, .chk_fault1 
d4a5 11 46 d5			ld de, sfaultso 
d4a8 c3 fa d4			jp .chk_fault 
d4ab			.chk_fault1:  
d4ab 2a 0b eb			ld hl, (chk_ret_und) 
d4ae ed 5b 47 e3		ld de,(chk_word) 
d4b2				if DEBUG_STK_FAULT 
d4b2					DMARK "FAU" 
d4b2					CALLMONITOR 
d4b2				endif 
d4b2 cd c8 8a			call cmp16 
d4b5 ca be d4			jp z, .chk_fault2 
d4b8 11 56 d5			ld de, sfaultru 
d4bb c3 fa d4			jp .chk_fault 
d4be			.chk_fault2:  
d4be 2a c9 ea			ld hl, (chk_ret_ovr) 
d4c1 ed 5b 47 e3		ld de,(chk_word) 
d4c5				if DEBUG_STK_FAULT 
d4c5					DMARK "FA1" 
d4c5					CALLMONITOR 
d4c5				endif 
d4c5 cd c8 8a			call cmp16 
d4c8 ca d1 d4			jp z, .chk_fault3 
d4cb 11 64 d5			ld de, sfaultro 
d4ce c3 fa d4			jp .chk_fault 
d4d1			.chk_fault3:  
d4d1 2a c7 e9			ld hl, (chk_loop_ovr) 
d4d4 ed 5b 47 e3		ld de,(chk_word) 
d4d8				if DEBUG_STK_FAULT 
d4d8					DMARK "FA2" 
d4d8					CALLMONITOR 
d4d8				endif 
d4d8 cd c8 8a			call cmp16 
d4db ca e4 d4			jp z, .chk_fault4 
d4de 11 7e d5			ld de, sfaultlo 
d4e1 c3 fa d4			jp .chk_fault 
d4e4			.chk_fault4:  
d4e4 2a c5 e8			ld hl, (chk_data_ovr) 
d4e7 ed 5b 47 e3		ld de,(chk_word) 
d4eb				if DEBUG_STK_FAULT 
d4eb					DMARK "FA3" 
d4eb					CALLMONITOR 
d4eb				endif 
d4eb cd c8 8a			call cmp16 
d4ee ca f7 d4			jp z, .chk_fault5 
d4f1 11 98 d5			ld de, sfaultdo 
d4f4 c3 fa d4			jp .chk_fault 
d4f7			 
d4f7			 
d4f7			.chk_fault5:  
d4f7 d1				pop de 
d4f8 e1				pop hl 
d4f9			 
d4f9 c9				ret 
d4fa			 
d4fa cd 7d 88		.chk_fault: 	call clear_display 
d4fd 3e 28				ld a, display_row_2 
d4ff cd 90 88				call str_at_display 
d502 11 28 d5				   ld de, .stackfault 
d505 3e 00				ld a, display_row_1 
d507 cd 90 88				call str_at_display 
d50a 11 7a ee				    ld de, debug_mark 
d50d 3e 11				ld a, display_row_1+17 
d50f cd 90 88				call str_at_display 
d512 cd a0 88				call update_display 
d515			 
d515				; prompt before entering montior for investigating issue 
d515			 
d515 3e 78			ld a, display_row_4 
d517 11 c4 95			ld de, endprog 
d51a			 
d51a cd a0 88			call update_display		 
d51d			 
d51d cd 22 98			call next_page_prompt 
d520			 
d520 d1				pop de 
d521 e1				pop hl 
d522 cd 18 96				call monitor 
d525 c3 12 95				jp warmstart 
d528					;jp 0 
d528					;halt 
d528			 
d528			 
d528			 
d528 .. 00		.stackfault: 	db "Stack fault:",0 
d535			 
d535 .. 00		sfaultsu: 	db	"Stack under flow",0 
d546 .. 00		sfaultso: 	db	"Stack over flow",0 
d556 .. 00		sfaultru:	db "RTS underflow",0 
d564 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
d57e .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
d598 .. 00		sfaultdo:	db "DTS overflow", 0 
d5a5			 
d5a5			 
d5a5			fault_dsp_under: 
d5a5 11 b7 d5			ld de, .dsp_under 
d5a8 c3 67 d6			jp .show_fault 
d5ab			 
d5ab			fault_rsp_under: 
d5ab 11 c5 d5			ld de, .rsp_under 
d5ae c3 67 d6			jp .show_fault 
d5b1			fault_loop_under: 
d5b1 11 d3 d5			ld de, .loop_under 
d5b4 c3 67 d6			jp .show_fault 
d5b7			 
d5b7 .. 00		.dsp_under: db "DSP Underflow",0 
d5c5 .. 00		.rsp_under: db "RSP Underflow",0 
d5d3 .. 00		.loop_under: db "LOOP Underflow",0 
d5e2			 
d5e2			 
d5e2 d5			type_faultn: 	push de 
d5e3 e5					push hl 
d5e4 cd 7d 88				call clear_display 
d5e7 11 0e d6				   ld de, .typefaultn 
d5ea 3e 00				ld a, display_row_1 
d5ec cd 90 88				call str_at_display 
d5ef 11 7a ee				    ld de, debug_mark 
d5f2 3e 11				ld a, display_row_1+17 
d5f4 cd 90 88				call str_at_display 
d5f7 cd a0 88				call update_display 
d5fa			 
d5fa				; prompt before entering montior for investigating issue 
d5fa			 
d5fa 3e 78			ld a, display_row_4 
d5fc 11 c4 95			ld de, endprog 
d5ff			 
d5ff cd a0 88			call update_display		 
d602			 
d602 cd 22 98			call next_page_prompt 
d605			 
d605 e5					push hl 
d606 d5					push de 
d607 cd 18 96				call monitor 
d60a c3 12 95				jp warmstart 
d60d 76					halt 
d60e			 
d60e			 
d60e .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
d625			 
d625 d5			type_faults: 	push de 
d626 e5					push hl 
d627 cd 7d 88				call clear_display 
d62a 11 50 d6				   ld de, .typefaults 
d62d 3e 00				ld a, display_row_1 
d62f cd 90 88				call str_at_display 
d632 11 7a ee				    ld de, debug_mark 
d635 3e 11				ld a, display_row_1+17 
d637 cd 90 88				call str_at_display 
d63a cd a0 88				call update_display 
d63d			 
d63d				; prompt before entering montior for investigating issue 
d63d			 
d63d 3e 78			ld a, display_row_4 
d63f 11 c4 95			ld de, endprog 
d642			 
d642 cd a0 88			call update_display		 
d645			 
d645 cd 22 98			call next_page_prompt 
d648			 
d648 e1					pop hl 
d649 d1					pop de 
d64a cd 18 96				call monitor 
d64d c3 12 95				jp warmstart 
d650			 
d650			 
d650 .. 00		.typefaults: db "STR Type Expected TOS!",0 
d667			 
d667			.show_fault: 	 
d667 d5					push de 
d668 cd 7d 88				call clear_display 
d66b d1					pop de 
d66c 3e 00				ld a, display_row_1 
d66e cd 90 88				call str_at_display 
d671 11 7a ee				    ld de, debug_mark 
d674 3e 11				ld a, display_row_1+17 
d676 cd 90 88				call str_at_display 
d679 cd a0 88				call update_display 
d67c			 
d67c				; prompt before entering montior for investigating issue 
d67c			 
d67c 3e 78			ld a, display_row_4 
d67e 11 c4 95			ld de, endprog 
d681			 
d681 cd a0 88			call update_display		 
d684			 
d684 cd 22 98			call next_page_prompt 
d687			 
d687 e1					pop hl 
d688 d1					pop de 
d689 cd 18 96				call monitor 
d68c			; do a dump to cli and not warmstart so we preserve all of the uwords.  
d68c			; TODO Make optional fault restart to cli or warm boot? 
d68c					;jp warmstart 
d68c c3 6a 95				jp cli 
d68f 76					halt 
d690			 
d690			; handle the auto run of code from files in storage 
d690			 
d690			 
d690			if STORAGE_SE 
d690			 
d690			sprompt3: db "Loading from start-up file?:",0 
d690			sprompt4: db "(Y=Any key/N=No)",0 
d690			 
d690			 
d690			forth_autoload: 
d690			 
d690				; load block 0 of store 1 
d690				 
d690				ld a, $fe      ; bit 0 clear 
d690				ld (spi_device), a 
d690			 
d690				call storage_get_block_0 
d690			 
d690				ld a, (store_page+STORE_0_AUTOFILE) 
d690			 
d690				cp 0 
d690				ret z     ; auto start not enabled 
d690			 
d690				call clear_display 
d690			 
d690				; set bank 
d690			 
d690					ld a, (store_page+STORE_0_BANKRUN) 
d690					ld (spi_device), a 
d690			 
d690				; get file id to load from and get the file name to display 
d690			 
d690					ld a, (store_page+STORE_0_FILERUN) 
d690			 
d690					ld l, 0 
d690					ld h, a 
d690					ld de, store_page 
d690			 
d690					if DEBUG_FORTH_WORDS 
d690						DMARK "ASp" 
d690						CALLMONITOR 
d690					endif 
d690					call storage_read 
d690			 
d690					if DEBUG_FORTH_WORDS 
d690						DMARK "ASr" 
d690						CALLMONITOR 
d690					endif 
d690			 
d690					call ishlzero 
d690					ret z             ; file not found 
d690			 
d690					ld a, display_row_2 + 10 
d690					ld de, store_page+3 
d690					call str_at_display 
d690				 
d690			; 
d690			 
d690				ld a, display_row_1+5 
d690				ld de, sprompt3 
d690				call str_at_display 
d690				ld a, display_row_3+15 
d690				ld de, sprompt4 
d690				call str_at_display 
d690			 
d690				call update_display 
d690			 
d690				call cin_wait 
d690				cp 'n' 
d690				ret z 
d690				cp 'N' 
d690				ret z 
d690			 
d690				call delay1s 
d690			 
d690				ld a, (store_page+2) 
d690				ld (store_openmaxext), a    ; save count of ext 
d690				ld a, 1  
d690				ld (store_openext), a    ; save count of ext 
d690			 
d690			.autof:  
d690				ld l , a 
d690				 
d690				ld a, (store_page) 
d690				ld h, a	 
d690				ld de, store_page 
d690					if DEBUG_FORTH_WORDS 
d690						DMARK "ASl" 
d690						CALLMONITOR 
d690					endif 
d690					call storage_read 
d690				call ishlzero 
d690				ret z 
d690			;	jr z, .autoend 
d690			 
d690					if DEBUG_FORTH_WORDS 
d690						DMARK "ASc" 
d690						CALLMONITOR 
d690					endif 
d690				ld de, store_page+2 
d690				ld a, display_row_4 
d690				call str_at_display 
d690			 
d690				call update_display 
d690				call delay250ms 
d690			 
d690			 
d690			 
d690				ld hl, store_page+2 
d690				call forthparse 
d690				call forthexec 
d690				call forthexec_cleanup 
d690			 
d690				 
d690				ld a, (store_openext) 
d690				inc a 
d690				ld (store_openext), a    ; save count of ext 
d690			 
d690				jr .autof 
d690			;.autofdone: 
d690			; 
d690			;		if DEBUG_FORTH_WORDS 
d690			;			DMARK "ASx" 
d690			;			CALLMONITOR 
d690			;		endif 
d690			;;	call clear_display 
d690			;	ret 
d690			 
d690			 
d690			 
d690			endif 
d690			 
d690			 
d690			; eof 
# End of file forth_kernel.asm
d690			;include "nascombasic.asm" 
d690			 
d690			 
d690			; find out where the code ends if loaded into RAM (for SC114) 
d690			;endofcode:  
d690			;	nop 
d690			 
d690			 
d690			; eof 
d690			 
# End of file main.asm
d690			;include "firmware_lcd_4x40.asm" 
d690			;;include "firmware_lcd_4x20.asm" 
d690			include "firmware_serial_display.asm" 
d690			 
d690			; Serial display interface for SC114 
d690			 
d690			 
d690			display_row_1: equ 0 
d690			display_row_2: equ display_row_1+display_cols 
d690			display_row_3: equ display_row_2 + display_cols 
d690			display_row_4: equ display_row_3 + display_cols 
d690			 
d690			kLCDWidth:  EQU display_cols             ;Width in characters 
d690			kLCD_Line1: EQU 0x00  
d690			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
d690			; E1 
d690			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
d690			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
d690			 
d690			lcd_init: 
d690				; no init as handled by the SCM bios 
d690 c9				ret 
d691			 
d691			 
d691			; low level functions for direct screen writes 
d691			 
d691			; output char at pos? 
d691			fLCD_Str: 
d691			        ;out (SC114_SIO_1_OUT),a 
d691 c5				push bc 
d692 0e 02			ld c, $02 
d694 f7				rst $30 
d695 c1				pop bc 
d696 c9				ret 
d697			 
d697			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
d697			fLCD_Pos: 
d697				; use ASCII escape to position 
d697			        ;out (SC114_SIO_1_OUT),a 
d697 c5				push bc 
d698 0e 02			ld c, $02 
d69a f7				rst $30 
d69b c1				pop bc 
d69c			 
d69c c9				ret 
d69d			 
d69d			; output char at pos 
d69d			fLCD_Data: 
d69d			      ;  out (SC114_SIO_1_OUT),a 
d69d c5				push bc 
d69e 0e 02			ld c, $02 
d6a0 f7				rst $30 
d6a1 c1				pop bc 
d6a2			 
d6a2 c9				ret 
d6a3			 
d6a3			; ascii cls  
d6a3			 
d6a3 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
d6a7			 
d6a7			; write the frame buffer given in hl to hardware  
d6a7			write_display: 
d6a7			 
d6a7			API: equ 0 
d6a7			 
d6a7			if API 
d6a7				push bc 
d6a7				ld b, 4 
d6a7			 
d6a7			        ld (display_write_tmp), hl 	  
d6a7			 
d6a7				; clear and home cursor 
d6a7			 
d6a7				ld c, 6 
d6a7				ld de, .cls 
d6a7				rst $30 
d6a7			 
d6a7			 
d6a7			.writeln: 
d6a7			 
d6a7				ld de, (display_write_tmp) 
d6a7				ld c, 6 
d6a7				rst $30 
d6a7				ld c, 7 
d6a7				rst $30 
d6a7			 
d6a7				ld hl, (display_write_tmp) 
d6a7				ld de, display_cols 
d6a7				add hl,de 
d6a7				ld (display_write_tmp),hl 
d6a7			 
d6a7				djnz  .writeln 
d6a7			 
d6a7				pop bc 
d6a7			 
d6a7			 
d6a7				ret 
d6a7			endif 
d6a7 e5				push hl 
d6a8 c5				push bc 
d6a9 d5				push de 
d6aa			 
d6aa			;	ld c, 2 
d6aa			;	;ld de, .cls 
d6aa			;	ld a, 27 
d6aa			;	rst $30 
d6aa			;	ld c, 2 
d6aa			;	;ld de, .cls 
d6aa			;	ld a, '[' 
d6aa			;	rst $30 
d6aa			; 
d6aa			;	ld c, 2 
d6aa			;	;ld de, .cls 
d6aa			;	ld a, 'H' 
d6aa			;	rst $30 
d6aa			; 
d6aa			 
d6aa 0e 02			ld c, 2 
d6ac				;ld de, .cls 
d6ac 3e 1b			ld a, 27 
d6ae f7				rst $30 
d6af			 
d6af			 
d6af 0e 02			ld c, 2 
d6b1				;ld de, .cls 
d6b1 3e 5b			ld a, '[' 
d6b3 f7				rst $30 
d6b4 0e 02			ld c, 2 
d6b6				;ld de, .cls 
d6b6 3e 32			ld a, '2' 
d6b8 f7				rst $30 
d6b9 0e 02			ld c, 2 
d6bb				;ld de, .cls 
d6bb 3e 4a			ld a, 'J' 
d6bd f7				rst $30 
d6be d1				pop de 
d6bf c1				pop bc 
d6c0 e1				pop hl 
d6c1			 
d6c1			 
d6c1 22 d8 eb		        ld (display_write_tmp), hl 	  
d6c4 3e 00			ld a, kLCD_Line1 
d6c6			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d6c6 06 28			ld b, display_cols 
d6c8 ed 5b d8 eb		ld de, (display_write_tmp) 
d6cc cd 2a d7			call write_len_string 
d6cf				 
d6cf			 
d6cf e5			push hl 
d6d0 d5			push de 
d6d1 c5			push bc 
d6d2 0e 07			ld c, 7 
d6d4 f7				rst $30 
d6d5 c1			pop bc 
d6d6 d1			pop de 
d6d7 e1			pop hl 
d6d8			 
d6d8				 
d6d8 2a d8 eb			ld hl, (display_write_tmp) 
d6db 11 28 00			ld de, display_cols 
d6de 19				add hl,de 
d6df 22 d8 eb			ld (display_write_tmp),hl 
d6e2			 
d6e2				 
d6e2 3e 28			ld a, kLCD_Line2 
d6e4			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d6e4 06 28			ld b, display_cols 
d6e6 ed 5b d8 eb		ld de, (display_write_tmp) 
d6ea cd 2a d7			call write_len_string 
d6ed				 
d6ed 2a d8 eb			ld hl, (display_write_tmp) 
d6f0 11 28 00			ld de, display_cols 
d6f3 19				add hl,de 
d6f4 22 d8 eb			ld (display_write_tmp),hl 
d6f7			 
d6f7 e5			push hl 
d6f8 d5			push de 
d6f9 c5			push bc 
d6fa 0e 07			ld c, 7 
d6fc f7				rst $30 
d6fd c1			pop bc 
d6fe d1			pop de 
d6ff e1			pop hl 
d700			 
d700				 
d700 3e 50			ld a, kLCD_Line3 
d702			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
d702 06 28			ld b, display_cols 
d704 ed 5b d8 eb		ld de, (display_write_tmp) 
d708 cd 2a d7			call write_len_string 
d70b				 
d70b 2a d8 eb			ld hl, (display_write_tmp) 
d70e 11 28 00			ld de, display_cols 
d711 19				add hl,de 
d712 22 d8 eb			ld (display_write_tmp),hl 
d715			 
d715 e5			push hl 
d716 d5			push de 
d717 c5			push bc 
d718 0e 07			ld c, 7 
d71a f7				rst $30 
d71b c1			pop bc 
d71c d1			pop de 
d71d e1			pop hl 
d71e			 
d71e				 
d71e 3e 78			ld a, kLCD_Line4 
d720			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
d720 06 28			ld b, display_cols 
d722 ed 5b d8 eb		ld de, (display_write_tmp) 
d726 cd 2a d7			call write_len_string 
d729 c9					ret 
d72a			 
d72a			 
d72a				; write out a fixed length string given in b from de 
d72a			 
d72a 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
d72b cd 9d d6		            CALL fLCD_Data      ;Write character to display 
d72e 13				inc de 
d72f 10 f9			djnz write_len_string 
d731 c9				ret 
d732			 
d732			 
d732			; eof 
# End of file firmware_serial_display.asm
d732			;include "firmware_key_5x10.asm" 
d732			;;include "firmware_key_4x10.asm" 
d732			include "firmware_key_serial.asm" 
d732			; Serial keyboard interface for SC114 
d732			 
d732			key_init: 
d732				; no init as handled by the SCM bios 
d732 c9				ret 
d733			 
d733			 
d733			cin_wait: 
d733			;	ld a, 0 
d733			;	ret 
d733			 
d733				;in a,(SC114_SIO_1_IN) 
d733			        ; Use SCM API to get from whatever console device we are using 
d733 c5				push bc 
d734 0e 01			ld c, $01 
d736 f7				rst $30 
d737 c1				pop bc 
d738 c9				ret 
d739			 
d739			cin: 
d739			 
d739			 
d739 c5				push bc 
d73a			 
d73a				; any key waiting to process? 
d73a 0e 03			ld c, $03 
d73c f7				rst $30 
d73d 28 05			jr z, .cin_skip 
d73f			 
d73f				; yep, get it 
d73f			 
d73f 0e 01			ld c, $01 
d741 f7				rst $30 
d742 c1				pop bc 
d743 c9				ret 
d744			.cin_skip: 
d744 3e 00			ld a, 0 
d746 c1				pop bc 
d747 c9				ret 
d748			 
d748			 
d748			 
d748			 
# End of file firmware_key_serial.asm
d748			endofcode:  
d748			baseram:  
d748 00				nop 
d749			 
d749			heap_start: equ baseram+15  ; Starting address of heap 
d749			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
d749			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
d749			;VDU:  EQU     endofcode           ; BASIC Work space 
d749			; eof 
d749			 
# End of file os_mega_sc114.asm
d749
