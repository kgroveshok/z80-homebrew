# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 e7 16			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 ..			buildtime: db   "Build: " 
010a					include "romtimestamp.asm" 
010a ..			db '2025-09-06 16:19' 
# End of file romtimestamp.asm
011a 00				   db 0 
011b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
011f			 
011f			 
011f			 
011f			;        nop  
011f			;        nop 
011f			;;	org 05h		; null out bdos call 
011f			; 
011f			;        nop  
011f			;        nop  
011f			;        nop 
011f			;;	org 08h 
011f			;;; 
011f			;;	jp cin		; rst 8 - char in 
011f			;;; 
011f			; 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;	org 010h 
011f			;; 
011f			;	jp cout		; rest 010h  - char out 
011f			;; 
011f			;	org 01bh   
011f			; 
011f			;	;jp  		; rst 01bh   - write string to display 
011f			;	jp str_at_display 
011f			; 
011f			; 
011f			;	org 020h 
011f			; 
011f			;	; jp		 ; rst 020h - read char at screen location 
011f			; 
011f			;	org 028h 
011f			 
011f				; jp		 ; rst 028h  - storage i/o 
011f			 
011f			; 	org 030h 
011f			;	jp break_point_state 
011f			  
011f			; $30  
011f			; org 038h 
011f			; $38 
011f			 
011f			; TODO any more important entry points to add to jump table for easier coding use? 
011f			 
011f			if BASE_KEV = 1  
011f			 
011f				; need to be at $66 for nmi support 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255 
011f				jp nmi 
011f			endif 
011f			 
011f			include "firmware.asm" 
011f			  
011f			; main constants (used here and in firmware)  
011f			  
011f			; TODO have page 0 of storage as bios  
011f			  
011f			Device_A: equ 0h  
011f			Device_B: equ 040h          ; Sound  
011f			  
011f			if BASE_KEV  
011f			Device_C: equ 080h          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			if BASE_SC114  
011f			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			if BASE_CPM  
011f			; TODO fixup for CPM  
011f			Device_C: equ 080h          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			Device_D: equ 0c0h             ; Keyboard and LCD  
011f			  
011f			; Odd specific debug points for testing hardware dev  
011f			  
011f			;if DEBUG_LEVEL0  
011f			;	include "debug_level0.asm"  
011f			;endif  
011f			;if DEBUG_LEVEL1  
011f			;	include "debug_level1.asm"  
011f			;endif  
011f			;if DEBUG_LEVEL2  
011f			;	include "debug_level2.asm"  
011f			;endif  
011f			  
011f			  
011f			CALLMONITOR: macro  
011f			;	call break_point_state  
011f			; now use the break point debug vector  
011f				call debug_vector  
011f				endm  
011f			  
011f			MALLOC_1: equ 1        ; from dk88   
011f			MALLOC_2: equ 0           ; broke  
011f			MALLOC_3: equ 0           ; really broke  
011f			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011f			  
011f			if BASE_KEV   
011f			;stacksize: equ 256  
011f			; each stack entry is three bytes (type + word)  
011f			stacksize: equ 3*150  
011f			  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 512  
011f			endif  
011f			if BASE_SC114  
011f			;tos:	equ 0f000h  
011f			stacksize: equ 256  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 256  
011f			endif  
011f			  
011f			if BASE_CPM  
011f			;tos:	equ 0f000h  
011f			stacksize: equ 256  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 256  
011f			endif  
011f			  
011f			;if STORAGE_SE == 0  
011f			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011f			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011f			;endif  
011f			  
011f			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011f			  
011f			STORE_0_AUTORUN: equ $20  
011f			  
011f			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011f			  
011f			STORE_0_AUTOFILE: equ $21  
011f			STORE_0_BANKRUN: equ $23  
011f			STORE_0_FILERUN: equ $24  
011f			  
011f			; Block 0 offsets for settings  
011f			  
011f			; if set then skip prompt for start up and accept all  
011f			  
011f			STORE_0_QUICKSTART: equ $25  
011f			  
011f			; Blocks where directory table is held  
011f			  
011f			; Reducing the number of entries increases the max file size  
011f			  
011f			;STORE_DIR_START: equ 1  
011f			;STORE_DIR_END: equ 33  
011f			  
011f			; Blocks from where file data is stored  
011f			  
011f			;STORE_DATA_START: equ STORE_DIR_END + 1  
011f			  
011f			; Block indicators (<32 are data files)  
011f			  
011f			;STORE_BLOCK_CFG: equ $8f       ; config block  
011f			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011f			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011f			;STORE_BLOCK_FREE: equ $85       ; data block free  
011f			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011f			  
011f			  
011f			  
011f			; Directory entry flags  
011f			  
011f			;STORE_DIR_FREE: equ 0  
011f			;STORE_DIR_FILE:  equ 1  
011f			  
011f			; Structure offsets to directory entries  
011f			;STORE_DE_FLAG: equ 0  
011f			;STORE_DE_MAXEXT: equ 1  
011f			;STORE_DE_FILENAME: equ 2  
011f			  
011f			; Structure offsets to block 0  
011f			  
011f			;STORE_BK0_ISFOR: equ 1  
011f			;STORE_BK0_LABEL: equ 3  
011f			  
011f			; memory allocation   
011f			  
011f			chk_stund: equ tos+2           ; underflow check word  
011f			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011f			  
011f			; keyscan table needs rows x cols buffer  
011f			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011f			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011f			  
011f			keyscan_table_row1: equ chk_stovr -key_cols-1  
011f			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011f			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011f			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011f			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011f			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011f			keyscan_scancol: equ keyscan_table-key_cols  
011f			;keyscan_table_len: equ key_rows*key_cols  
011f			;keybufptr: equ keyscan_table - 2  
011f			;keysymbol: equ keybufptr - 1  
011f			key_held: equ keyscan_scancol-1	; currently held  
011f			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011f			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011f			key_fa: equ key_repeat_ct -1 ;  
011f			key_fb: equ key_fa -1 ;  
011f			key_fc: equ key_fb -1 ;  
011f			key_fd: equ key_fc -1 ;  
011f			key_face_held: equ key_fd - 1   
011f			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011f			  
011f			hardware_config: equ key_face_held - 10  
011f			  
011f			; hardware config switches  
011f			; TODO add bitmasks on includes for hardware  
011f			; high byte for expansion ids  
011f			;     0000 0000  no card inserted  
011f			;     0000 0001  storage card inserted  
011f			;     0000 0010  spi sd card active  
011f			  
011f			;       
011f			; low byte:  
011f			;     0000 0001   4x4 keypad  
011f			;     0000 0010   full keyboard  
011f			;     0000 0011   spi/ext keyboard  
011f			;     0000 0100   20x4 lcd  
011f			;     0000 1000   40x4 lcd  
011f			;     0000 1100   spi/ext display  
011f			;     0001 0000   ide interface available  
011f			  
011f			hardware_word: equ hardware_config - 2  
011f			  
011f			; debug marker - optional display of debug point on the debug screens  
011f			  
011f			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011f			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011f			parse_vector:  equ debug_vector - 3 ; vector to the parser vector  
011f			  
011f			debug_umark: equ parse_vector - 6  ; current user mark  
011f			debug_mark: equ debug_umark - 4    ; internal word debug points  
011f			  
011f			; input_str vars  
011f			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011f			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011f			input_size: equ input_start -1  ; number of chars  
011f			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011f			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011f			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011f			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011f			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011f			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011f			input_len: equ input_cur_onoff - 5 ; length of current input  
011f			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011f			  
011f			; cursor blink rate  
011f			CUR_BLINK_RATE: equ $09  
011f			;CUR_BLINK_RATE: equ 15  
011f			  
011f			key_actual_pressed: equ input_cursor - 1   
011f			key_symbol: equ key_actual_pressed - 1   
011f			key_shift: equ key_symbol - 1   
011f			  
011f			; Display allocation  
011f			  
011f			;display_rows: equ 4     ; move out to mini and mega files  
011f			;display_cols: equ 20  
011f			  
011f			display_fb_len: equ display_rows*display_cols  
011f			  
011f			; primary frame buffer     
011f			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011f			; working frame buffers  
011f			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011f			display_fb3: equ  display_fb1-display_fb_len - 1  
011f			display_fb2: equ  display_fb3-display_fb_len - 1  
011f			;  
011f			; pointer to active frame buffer  
011f			display_fb_active: equ display_fb2 - 2  
011f			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011f			display_write_tmp: equ display_lcde1e2 - 2  
011f			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011f			  
011f			;  
011f			  
011f			;; can load into de directory  
011f			cursor_col: equ display_active-1  
011f			cursor_row: equ cursor_col-1  
011f			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011f			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011f			  
011f			; maths vars  
011f			  
011f			LFSRSeed: equ cursor_shape -20   
011f			randData: equ LFSRSeed - 2  
011f			xrandc: equ randData - 2  
011f			stackstore: equ xrandc - 2  
011f			seed1: equ  stackstore -2   
011f			seed2: equ seed1 - 2  
011f			  
011f			; cf storage vars  
011f			  
011f			iErrorNum:  equ seed2-1         ;Error number  
011f			iErrorReg:  equ iErrorNum -1              ;Error register  
011f			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011f			  
011f			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011f			  
011f			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011f			  
011f			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011f			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011f			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011f			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011f			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011f			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011f			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011f			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011f			store_tmpid: equ store_tmp3 - 1		; page temp id  
011f			store_tmpext: equ store_tmpid - 1		; file extent temp  
011f			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011f			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011f			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011f			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011f			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011f			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011f			;  
011f			; spi vars  
011f			  
011f			  
011f			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011f			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011f			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011f			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011f			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011f			spi_device_id: equ spi_device - 1    ; human readable bank number  
011f			  
011f			;;;;; forth cli params  
011f			  
011f			; TODO use a different frame buffer for forth???  
011f			  
011f			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011f			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011f			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011f			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011f			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011f			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011f			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011f			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011f			  
011f			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011f			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011f			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011f			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011f			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011f			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011f			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011f			  
011f			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011f			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011f			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011f			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011f			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011f			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011f			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011f			  
011f			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011f			  
011f			; os/forth token vars  
011f			  
011f			os_last_cmd: equ os_var_array-255  
011f			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011f			os_current_i: equ os_cli_cmd-2  
011f			os_cur_ptr: equ os_current_i-2  
011f			os_word_scratch: equ os_cur_ptr-30  
011f			os_tok_len: equ os_word_scratch - 2  
011f			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011f			os_tok_malloc: equ os_tok_ptr - 2  
011f			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011f			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011f			execscratch: equ os_input-255        ; exec cmd eval buffer  
011f			scratch: equ execscratch-255  
011f			  
011f			os_stack_1: equ scratch - 3       ; stack holding area 1  
011f			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
011f			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
011f			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
011f			  
011f			  
011f			; temp locations for new word processing to save on adding more   
011f			  
011f			os_new_malloc: equ os_stack_4-2  
011f			os_new_parse_len: equ os_new_malloc - 2  
011f			os_new_word_len: equ os_new_parse_len - 2  
011f			os_new_work_ptr: equ os_new_word_len - 2  
011f			os_new_src_ptr: equ os_new_work_ptr - 2  
011f			os_new_exec: equ os_new_src_ptr - 2  
011f			os_new_exec_ptr: equ os_new_exec - 2  
011f			  
011f			; resume memory alloocations....  
011f			  
011f			;os_view_disable: equ os_new_exec_ptr - 1  
011f			os_view_af: equ os_new_exec_ptr - 2  
011f			os_view_hl: equ os_view_af -2  
011f			os_view_de: equ os_view_hl - 2  
011f			os_view_bc: equ os_view_de - 2  
011f			  
011f			; stack checksum word  
011f			if DEBUG_STACK_IMB  
011f				curframe: equ  os_view_de - 5  
011f				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011f				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011f			else  
011f				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011f			endif  
011f			  
011f			; with data stack could see memory filled with junk. need some memory management   
011f			; malloc and free entry points added  
011f			  
011f			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011f			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011f			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			;heap_end: equ free_list-1  ; Starting address of heap  
011f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			  
011f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			heap_end: equ chk_word-1  ; Starting address of heap  
011f			  
011f			  
011f			;if BASE_KEV   
011f			;heap_start: equ 0800eh  ; Starting address of heap  
011f			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011f			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011f			;endif  
011f			  
011f			;if BASE_SC114  
011f			;heap_start: equ baseram+15  ; Starting address of heap  
011f			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011f			;endif  
011f			  
011f			  
011f			;;;;  
011f			  
011f			  
011f			; change below to point to last memory alloc above  
011f			topusermem:  equ   heap_start  
011f			  
011f			;if BASE_KEV   
011f			;baseusermem: equ 08000h  
011f			;endif  
011f			  
011f			;if BASE_SC114  
011f			;;aseusermem:     equ    12  
011f			;baseusermem:     equ    prompt  
011f			;;baseusermem:     equ    endofcode  
011f			;endif  
011f			  
011f			  
011f			; **********************************************************************  
011f			; **  Constants  
011f			; **********************************************************************  
011f			  
011f			; Constants used by this code module  
011f			kDataReg:   EQU Device_D           ;PIO port A data register  
011f			kContReg:   EQU Device_D+2           ;PIO port A control register  
011f			  
011f			  
011f			portbdata:  equ Device_D+1    ; port b data  
011f			portbctl:   equ Device_D+3    ; port b control  
011f			  
011f			  
011f			;KEY_SHIFT:   equ 5  
011f			;KEY_SYMBOLSHIFT:  equ 6  
011f			  
011f			KEY_SHIFTLOCK: equ 4  
011f			  
011f			  
011f			KEY_UP: equ 5  
011f			KEY_NEXTWORD: equ 6  
011f			KEY_PREVWORD: equ 7  
011f			KEY_BS: equ 8  
011f			KEY_TAB:  equ 9  
011f			KEY_DOWN: equ 10  
011f			KEY_LEFT: equ 11  
011f			KEY_RIGHT: equ 12  
011f			KEY_CR:   equ 13  
011f			KEY_HOME: equ 14  
011f			KEY_END: equ 15  
011f			  
011f			KEY_F1: equ 16  
011f			KEY_F2: equ 17  
011f			KEY_F3: equ 18  
011f			KEY_F4: equ 19  
011f			  
011f			KEY_F5: equ 20  
011f			KEY_F6: equ 21  
011f			KEY_F7: equ 22  
011f			KEY_F8: equ 23  
011f			  
011f			KEY_F9: equ 24  
011f			KEY_F10: equ 25  
011f			KEY_F11: equ 26  
011f			KEY_F12: equ 27  
011f			  
011f			;if DEBUG_KEY  
011f			;	KEY_MATRIX_NO_PRESS: equ '.'  
011f			;	KEY_SHIFT:   equ '.'  
011f			;	KEY_SYMBOLSHIFT:  equ '.'  
011f			;else  
011f				KEY_SHIFT:   equ '~'  
011f				KEY_SYMBOLSHIFT:  equ '~'  
011f				KEY_MATRIX_NO_PRESS: equ '~'  
011f			;endi  
011f			  
011f			  
011f			  
011f			  
011f			; Macro to make adding debug marks easier  
011f			  
011f			DMARK: macro str  
011f				push af  
011f				ld a, (.dmark)  
011f				ld (debug_mark),a  
011f				ld a, (.dmark+1)  
011f				ld (debug_mark+1),a  
011f				ld a, (.dmark+2)  
011f				ld (debug_mark+2),a  
011f				jr .pastdmark  
011f			.dmark: db str  
011f			.pastdmark: pop af  
011f			  
011f			endm  
011f			  
011f			  
011f			; macro to detect for stack imbalances  
011f			  
011f			include "stackimbal.asm"  
011f			; Macro and code to detect stock imbalances 
011f			 
011f			SPPUSH: equ 0 
011f			 
011f			; Add a stack frame which can be checked before return 
011f			 
011f			STACKFRAME: macro onoff frame1 frame2 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						; save current SP 
011f						exx 
011f			 
011f						ld de, frame1 
011f						ld a, d 
011f						ld hl, curframe 
011f						call hexout 
011f						ld a, e 
011f						ld hl, curframe+2 
011f						call hexout 
011f			  
011f						ld hl, frame1 
011f						push hl 
011f						ld hl, frame2 
011f						push hl 
011f						exx 
011f					endif 
011f					 
011f				endif 
011f			endm 
011f			 
011f			STACKFRAMECHK: macro onoff frame1 frame2 
011f			 
011f					 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						exx 
011f						; check stack frame SP 
011f			 
011f						ld hl, frame2 
011f						pop de   ; frame2 
011f			 
011f						call cmp16 
011f						jr nz, .spnosame 
011f						 
011f			 
011f						ld hl, frame1 
011f						pop de   ; frame1 
011f			 
011f						call cmp16 
011f						jr z, .spfrsame 
011f			 
011f						.spnosame: call showsperror 
011f			 
011f						.spfrsame: nop 
011f			 
011f						exx 
011f					endif 
011f					 
011f				endif 
011f			 
011f			 
011f			endm 
011f			 
011f			 
011f			; for a sub routine, wrap SP collection and comparisons 
011f			 
011f			; Usage: 
011f			; 
011f			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011f			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011f			 
011f			SAVESP: macro onoff storeword 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						; save current SP 
011f			 
011f						ld (store_sp+(storeword*4)), sp 
011f			 
011f					endif 
011f					 
011f				endif 
011f			 
011f			endm 
011f			 
011f			CHECKSP: macro onoff storeword 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f			 
011f						; save SP after last save 
011f				 
011f						ld (store_sp+(storeword*4)+2), sp 
011f			 
011f						push hl 
011f						ld hl, store_sp+(storeword*4) 
011f						call check_stack_sp  
011f						pop hl 
011f			 
011f			 
011f					endif 
011f					 
011f				endif 
011f			 
011f			endm 
011f			 
011f			if DEBUG_STACK_IMB 
011f			 
011f			check_stack_sp: 
011f					push de 
011f			 
011f					ld e, (hl) 
011f					inc hl 
011f					ld d, (hl) 
011f					inc hl 
011f			 
011f					push de 
011f			 
011f			 
011f					ld e, (hl) 
011f					inc hl 
011f					ld d, (hl) 
011f					inc hl 
011f			 
011f					pop hl 
011f			 
011f			 
011f					; check to see if the same 
011f			 
011f					call cmp16 
011f					jr z, .spsame 
011f			 
011f					; not same 
011f			 
011f					call showsperror 
011f			.spsame: 
011f			 
011f					pop de 
011f			 
011f					ret 
011f			 
011f			.sperr:  db "Stack imbalance",0 
011f			 
011f			 
011f			showsperror: 
011f			 
011f			 
011f				push hl 
011f				push af 
011f				push de 
011f				call clear_display 
011f				ld de, .sperr 
011f				ld a,0 
011f			;	ld de,os_word_scratch 
011f				call str_at_display 
011f				ld a, display_row_1+17 
011f				ld de, debug_mark 
011f				call str_at_display 
011f				ld a, 0 
011f				ld (curframe+4),a 
011f				ld hl, curframe 
011f				ld de, os_word_scratch 
011f				ld a, display_row_4 
011f				call str_at_display 
011f				call update_display 
011f				;call break_point_state 
011f				call cin_wait 
011f			 
011f			;	ld a, ' ' 
011f			;	ld (os_view_disable), a 
011f				call bp_on 
011f				pop de	 
011f				pop af 
011f				pop hl 
011f				CALLMONITOR 
011f				ret 
011f			 
011f			endif 
011f			 
011f			 
011f			 
011f			; eof 
# End of file stackimbal.asm
011f			  
011f			;TODO macro to calc col and row offset into screen  
011f			  
011f			  
011f			  
011f			hardware_init:  
011f			  
011f				  
011f			  
011f					;ld a, 0  
011f					;ld (hardware_diag), a  
011f			  
011f					; clear all the buffers  
011f			  
011f 21 07 ed				ld hl, display_fb1  
0122 22 c3 eb				ld (display_fb_active), hl  
0125			  
0125 cd c8 0b				call clear_display  
0128			  
0128 21 c5 eb				ld hl, display_fb2  
012b 22 c3 eb				ld (display_fb_active), hl  
012e			  
012e cd c8 0b				call clear_display  
0131			  
0131					; init primary frame buffer area  
0131 21 a8 ed				ld hl, display_fb0  
0134 22 c3 eb				ld (display_fb_active), hl  
0137			  
0137 cd c8 0b				call clear_display  
013a			  
013a			  
013a cd 43 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013d			  
013d cd 31 65			call key_init  
0140 cd ad 01			call storage_init  
0143			  
0143				; setup malloc functions  
0143			  
0143				if MALLOC_1  
0143 cd ac 11				call  heap_init  
0146				endif  
0146				if MALLOC_4  
0146					call  heap_init  
0146				endif  
0146			  
0146				; init sound hardware if present  
0146			  
0146				if SOUND_ENABLE  
0146					call sound_init  
0146				endif  
0146			  
0146				; lcd test sequence  
0146					  
0146 cd eb 0b			call update_display  
0149 cd 00 0b			call delay1s  
014c 3e 2b			ld a,'+'  
014e cd cd 0b			call fill_display  
0151 cd eb 0b			call update_display  
0154 cd 00 0b			call delay1s  
0157 3e 2a			ld a,'*'  
0159 cd cd 0b			call fill_display  
015c cd eb 0b			call update_display  
015f cd 00 0b			call delay1s  
0162 3e 2d			ld a,'-'  
0164 cd cd 0b			call fill_display  
0167 cd eb 0b			call update_display  
016a cd 00 0b			call delay1s  
016d			  
016d			; boot splash screen  
016d			if display_cols == 20	  
016d			        ld a, display_row_1    
016d			else  
016d 3e 0a		        ld a, display_row_1 +10   
016f			endif  
016f 11 54 16			ld de, prom_bootmsg  
0172 cd db 0b			call str_at_display  
0175 cd eb 0b			call update_display  
0178			  
0178			  
0178 cd 00 0b			call delay1s  
017b cd 00 0b			call delay1s  
017e			if display_cols == 20	  
017e			            LD   A, display_row_3+2  
017e			else  
017e 3e 5c		            LD   A, display_row_3+12  
0180			endif  
0180 11 69 16			ld de, prom_bootmsg1  
0183 cd db 0b			call str_at_display  
0186			; display debug level  
0186 3e 78		            LD   A, display_row_4  
0188 11 1b 01			ld de, debuglevel  
018b cd db 0b			call str_at_display  
018e			  
018e cd eb 0b			call update_display  
0191 cd 00 0b			call delay1s  
0194 cd 00 0b			call delay1s  
0197			  
0197			;	ld a, display_row_4+3  
0197			;	ld de, bootmsg2  
0197			;	call str_at_display  
0197			;	call update_display  
0197			;	call delay1s  
0197			;	call delay1s  
0197			  
0197			; debug mark setup  
0197			  
0197 3e 5f		ld a, '_'  
0199 32 62 ee		ld (debug_mark),a  
019c 32 63 ee		ld (debug_mark+1),a  
019f 32 64 ee		ld (debug_mark+2),a  
01a2 3e 00		ld a,0  
01a4 32 65 ee		ld (debug_mark+3),a  
01a7 32 66 ee		ld (debug_umark),a  
01aa			  
01aa c9					ret  
01ab			  
01ab			  
01ab			;bootmsg2:	db "Firmware v0.1",0  
01ab			  
01ab			; a 4x20 lcd  
01ab			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ab			  
01ab			;if display_cols == 20  
01ab			;	include "firmware_lcd_4x20.asm"  
01ab			;endif  
01ab			  
01ab			;if display_cols == 40  
01ab			;	include "firmware_lcd_4x40.asm"  
01ab			;endif  
01ab			  
01ab			;  
01ab			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ab			; TODO abstract the bit bang video out interface for dual display  
01ab			; TODO wire video out to tx pin on rc2014 bus  
01ab			  
01ab			; must supply cin, and cin_wait for low level hardware abstraction   
01ab			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ab			; test scancode  
01ab			  
01ab			;;;;;  
01ab			;;;  
01ab			; Moved out to mini and maxi versions  
01ab			;  
01ab			; include "firmware_key_4x4.asm"  
01ab			; using existing 4 wire x 4 resistor array for input  
01ab			;include "firmware_key_4x10.asm"  
01ab			; need to mod the board for 5 rows due to resistor array  
01ab			;include "firmware_key_5x10.asm"  
01ab			  
01ab			; storage hardware interface  
01ab			  
01ab			; use microchip serial eeprom for storage  
01ab			  
01ab			  
01ab			if STORAGE_SE  
01ab				include "firmware_spi.asm"  
01ab				include "firmware_seeprom.asm"  
01ab			else  
01ab			   ; create some stubs for the labels  
01ab c9			se_readbyte: ret  
01ac c9			se_writebyte: ret  
01ad c9			storage_init: ret  
01ae			  
01ae			endif  
01ae			  
01ae			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01ae			;include "firmware_cf.asm"  
01ae			  
01ae			; load up high level storage hardward abstractions  
01ae			include "firmware_storage.asm"  
01ae			 
01ae			; persisent storage hardware abstraction layer  
01ae			 
01ae			 
01ae			 
01ae			; Block 0 on storage is a config state 
01ae			 
01ae			 
01ae			 
01ae			; TODO add read phy block and write phy block functions 
01ae			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01ae			 
01ae			; Abstraction layer  
01ae			 
01ae			; Logocial block size is same size as physical size - using tape concept 
01ae			 
01ae			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01ae			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01ae			 
01ae			 
01ae			 
01ae			; Filesystem layout (Logical layout) 
01ae			; 
01ae			; Block 0 - Bank config  
01ae			; 
01ae			;      Byte - 0 file id counter 
01ae			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01ae			;      Byte - 3-20 zero terminated bank label 
01ae			; 
01ae			; Block 1 > File storage 
01ae			; 
01ae			;      Byte 0 file id    - block 0 file details 
01ae			;      Byte 1 block id - block 0 is file  
01ae			;            Byte 2-15 - File name 
01ae			; 
01ae			;       - to end of block data 
01ae			; 
01ae			 
01ae			; Get ID for the file named in pointer held HL 
01ae			; Returns ID in HL = 255 if no file found 
01ae			 
01ae			storage_getid: 
01ae			 
01ae 22 6a ea			ld (store_tmp1), hl 
01b1			 
01b1				if DEBUG_STORESE 
01b1					DMARK "SGI" 
01b1 f5				push af  
01b2 3a c6 01			ld a, (.dmark)  
01b5 32 62 ee			ld (debug_mark),a  
01b8 3a c7 01			ld a, (.dmark+1)  
01bb 32 63 ee			ld (debug_mark+1),a  
01be 3a c8 01			ld a, (.dmark+2)  
01c1 32 64 ee			ld (debug_mark+2),a  
01c4 18 03			jr .pastdmark  
01c6 ..			.dmark: db "SGI"  
01c9 f1			.pastdmark: pop af  
01ca			endm  
# End of macro DMARK
01ca					CALLMONITOR 
01ca cd 6f ee			call debug_vector  
01cd				endm  
# End of macro CALLMONITOR
01cd				endif 
01cd				; get block 0 and set counter for number of files to scan 
01cd			 
01cd cd 38 03			call storage_get_block_0 
01d0			 
01d0 3a 71 ea			ld a, (store_page) 
01d3 47				ld b, a 
01d4			 
01d4				; get extent 0 of each file id 
01d4			 
01d4				if DEBUG_STORESE 
01d4					DMARK "SGc" 
01d4 f5				push af  
01d5 3a e9 01			ld a, (.dmark)  
01d8 32 62 ee			ld (debug_mark),a  
01db 3a ea 01			ld a, (.dmark+1)  
01de 32 63 ee			ld (debug_mark+1),a  
01e1 3a eb 01			ld a, (.dmark+2)  
01e4 32 64 ee			ld (debug_mark+2),a  
01e7 18 03			jr .pastdmark  
01e9 ..			.dmark: db "SGc"  
01ec f1			.pastdmark: pop af  
01ed			endm  
# End of macro DMARK
01ed					CALLMONITOR 
01ed cd 6f ee			call debug_vector  
01f0				endm  
# End of macro CALLMONITOR
01f0				endif 
01f0 60			.getloop:	ld h, b 
01f1 2e 00				ld l, 0 
01f3 c5					push bc 
01f4			 
01f4 11 71 ea				ld de, store_page 
01f7				if DEBUG_STORESE 
01f7					DMARK "SGr" 
01f7 f5				push af  
01f8 3a 0c 02			ld a, (.dmark)  
01fb 32 62 ee			ld (debug_mark),a  
01fe 3a 0d 02			ld a, (.dmark+1)  
0201 32 63 ee			ld (debug_mark+1),a  
0204 3a 0e 02			ld a, (.dmark+2)  
0207 32 64 ee			ld (debug_mark+2),a  
020a 18 03			jr .pastdmark  
020c ..			.dmark: db "SGr"  
020f f1			.pastdmark: pop af  
0210			endm  
# End of macro DMARK
0210					CALLMONITOR 
0210 cd 6f ee			call debug_vector  
0213				endm  
# End of macro CALLMONITOR
0213				endif 
0213 cd e0 07				call storage_read 
0216 cd 1e 0e				call ishlzero 
0219 28 2d				jr z, .gap 
021b					 
021b					; have a file name read. Is it one we want. 
021b			 
021b 2a 6a ea				ld hl, (store_tmp1) 
021e 11 74 ea				ld de, store_page+3   ; file name 
0221			 
0221				if DEBUG_STORESE 
0221					DMARK "SGc" 
0221 f5				push af  
0222 3a 36 02			ld a, (.dmark)  
0225 32 62 ee			ld (debug_mark),a  
0228 3a 37 02			ld a, (.dmark+1)  
022b 32 63 ee			ld (debug_mark+1),a  
022e 3a 38 02			ld a, (.dmark+2)  
0231 32 64 ee			ld (debug_mark+2),a  
0234 18 03			jr .pastdmark  
0236 ..			.dmark: db "SGc"  
0239 f1			.pastdmark: pop af  
023a			endm  
# End of macro DMARK
023a					CALLMONITOR 
023a cd 6f ee			call debug_vector  
023d				endm  
# End of macro CALLMONITOR
023d				endif 
023d cd 93 11				call strcmp 
0240 20 06				jr nz, .gap   ; not this one 
0242			 
0242 c1				        pop bc 
0243			 
0243 26 00				ld h, 0 
0245 68					ld l, b 
0246 18 22				jr .getdone 
0248						 
0248			 
0248			 
0248			 
0248			.gap: 
0248				if DEBUG_STORESE 
0248					DMARK "SGg" 
0248 f5				push af  
0249 3a 5d 02			ld a, (.dmark)  
024c 32 62 ee			ld (debug_mark),a  
024f 3a 5e 02			ld a, (.dmark+1)  
0252 32 63 ee			ld (debug_mark+1),a  
0255 3a 5f 02			ld a, (.dmark+2)  
0258 32 64 ee			ld (debug_mark+2),a  
025b 18 03			jr .pastdmark  
025d ..			.dmark: db "SGg"  
0260 f1			.pastdmark: pop af  
0261			endm  
# End of macro DMARK
0261					CALLMONITOR 
0261 cd 6f ee			call debug_vector  
0264				endm  
# End of macro CALLMONITOR
0264				endif 
0264			 
0264 c1					pop bc 
0265 10 89				djnz .getloop 
0267 21 ff 00				ld hl, 255 
026a			.getdone: 
026a			 
026a				if DEBUG_STORESE 
026a					DMARK "SGe" 
026a f5				push af  
026b 3a 7f 02			ld a, (.dmark)  
026e 32 62 ee			ld (debug_mark),a  
0271 3a 80 02			ld a, (.dmark+1)  
0274 32 63 ee			ld (debug_mark+1),a  
0277 3a 81 02			ld a, (.dmark+2)  
027a 32 64 ee			ld (debug_mark+2),a  
027d 18 03			jr .pastdmark  
027f ..			.dmark: db "SGe"  
0282 f1			.pastdmark: pop af  
0283			endm  
# End of macro DMARK
0283					CALLMONITOR 
0283 cd 6f ee			call debug_vector  
0286				endm  
# End of macro CALLMONITOR
0286				endif 
0286			 
0286 c9				ret 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			; Read Block 
0287			; ---------- 
0287			; 
0287			; With current bank 
0287			;  
0287			; Get block number to read 
0287			; Load physical blocks starting at start block into buffer 
0287			 
0287			; de points to buffer to use 
0287			; hl holds logical block number  
0287			 
0287			storage_read_block: 
0287			 
0287				; TODO bank selection 
0287			 
0287				; for each of the physical blocks read it into the buffer 
0287 06 40			ld b, STORE_BLOCK_PHY 
0289			 
0289				if DEBUG_STORESE 
0289 d5					push de 
028a				endif 
028a				 
028a			.rl1:    
028a			 
028a				; read physical block at hl into de 
028a			        ; increment hl and de to next read position on exit 
028a			 
028a e5				push hl 
028b d5				push de	 
028c c5				push bc 
028d			;	if DEBUG_STORESE 
028d			;		push af 
028d			;		ld a, 'R' 
028d			;		ld (debug_mark),a 
028d			;		pop af 
028d			;		CALLMONITOR 
028d			;	endif 
028d cd ab 01			call se_readbyte 
0290			;	if DEBUG_STORESE 
0290			;		ld a,(spi_portbyte) 
0290			;		ld l, a 
0290			;		push af 
0290			;		ld a, '1' 
0290			;		ld (debug_mark),a 
0290			;		pop af 
0290			;		CALLMONITOR 
0290			;	endif 
0290 c1				pop bc 
0291 d1				pop de 
0292 e1				pop hl 
0293 12				ld (de),a 
0294 23				inc hl 
0295 13				inc de 
0296			 
0296			;	if DEBUG_STORESE 
0296			;		push af 
0296			;		ld a, 'r' 
0296			;		ld (debug_mark),a 
0296			;		pop af 
0296			;		CALLMONITOR 
0296			;	endif 
0296			 
0296 10 f2			djnz .rl1 
0298			 
0298				if DEBUG_STORESE 
0298					DMARK "SRB" 
0298 f5				push af  
0299 3a ad 02			ld a, (.dmark)  
029c 32 62 ee			ld (debug_mark),a  
029f 3a ae 02			ld a, (.dmark+1)  
02a2 32 63 ee			ld (debug_mark+1),a  
02a5 3a af 02			ld a, (.dmark+2)  
02a8 32 64 ee			ld (debug_mark+2),a  
02ab 18 03			jr .pastdmark  
02ad ..			.dmark: db "SRB"  
02b0 f1			.pastdmark: pop af  
02b1			endm  
# End of macro DMARK
02b1 d1					pop de 
02b2			; 
02b2			;		push af 
02b2			;		ld a, 'R' 
02b2			;		ld (debug_mark),a 
02b2			;		pop af 
02b2					CALLMONITOR 
02b2 cd 6f ee			call debug_vector  
02b5				endm  
# End of macro CALLMONITOR
02b5				endif 
02b5 c9				ret	 
02b6				 
02b6			 
02b6			; File Size 
02b6			; --------- 
02b6			; 
02b6			;   hl file id 
02b6			; 
02b6			;  returns in hl the number of blocks 
02b6			 
02b6			storage_file_size: 
02b6 5d				ld e, l 
02b7 16 00			ld d, 0 
02b9 21 40 00			ld hl, STORE_BLOCK_PHY 
02bc					if DEBUG_FORTH_WORDS 
02bc						DMARK "SIZ" 
02bc f5				push af  
02bd 3a d1 02			ld a, (.dmark)  
02c0 32 62 ee			ld (debug_mark),a  
02c3 3a d2 02			ld a, (.dmark+1)  
02c6 32 63 ee			ld (debug_mark+1),a  
02c9 3a d3 02			ld a, (.dmark+2)  
02cc 32 64 ee			ld (debug_mark+2),a  
02cf 18 03			jr .pastdmark  
02d1 ..			.dmark: db "SIZ"  
02d4 f1			.pastdmark: pop af  
02d5			endm  
# End of macro DMARK
02d5						CALLMONITOR 
02d5 cd 6f ee			call debug_vector  
02d8				endm  
# End of macro CALLMONITOR
02d8					endif 
02d8 cd ba 05			call storage_findnextid 
02db			 
02db cd 1e 0e			call ishlzero 
02de			;	ld a, l 
02de			;	add h 
02de			;	cp 0 
02de c8				ret z			; block not found so EOF 
02df			 
02df 11 71 ea			ld de, store_page 
02e2 cd 87 02			call storage_read_block 
02e5			 
02e5 3a 73 ea			ld a, (store_page+2)	 ; get extent count 
02e8 6f				ld l, a 
02e9 26 00			ld h, 0 
02eb c9			 	ret 
02ec			 
02ec			 
02ec			; Write Block 
02ec			; ----------- 
02ec			; 
02ec			; With current bank 
02ec			;  
02ec			; Get block number to write 
02ec			; Write physical blocks starting at start block from buffer 
02ec			  
02ec			storage_write_block: 
02ec				; TODO bank selection 
02ec			 
02ec				; for each of the physical blocks read it into the buffer 
02ec 06 40			ld b, STORE_BLOCK_PHY 
02ee			 
02ee				if DEBUG_STORESE 
02ee					DMARK "SWB" 
02ee f5				push af  
02ef 3a 03 03			ld a, (.dmark)  
02f2 32 62 ee			ld (debug_mark),a  
02f5 3a 04 03			ld a, (.dmark+1)  
02f8 32 63 ee			ld (debug_mark+1),a  
02fb 3a 05 03			ld a, (.dmark+2)  
02fe 32 64 ee			ld (debug_mark+2),a  
0301 18 03			jr .pastdmark  
0303 ..			.dmark: db "SWB"  
0306 f1			.pastdmark: pop af  
0307			endm  
# End of macro DMARK
0307			 
0307					;push af 
0307					;ld a, 'W' 
0307					;ld (debug_mark),a 
0307					;pop af 
0307					CALLMONITOR 
0307 cd 6f ee			call debug_vector  
030a				endm  
# End of macro CALLMONITOR
030a				endif 
030a			 
030a			; might not be working 
030a			;	call se_writepage 
030a			 
030a			;	ret 
030a			; 
030a			 
030a			 
030a			 
030a			.wl1:    
030a			 
030a				; read physical block at hl into de 
030a			        ; increment hl and de to next read position on exit 
030a			 
030a e5				push hl 
030b d5				push de	 
030c c5				push bc 
030d 1a				ld a,(de) 
030e				;if DEBUG_STORESE 
030e			;		push af 
030e			;		ld a, 'W' 
030e			;		ld (debug_mark),a 
030e			;		pop af 
030e			;		CALLMONITOR 
030e			;	endif 
030e cd ac 01			call se_writebyte 
0311			;	call delay250ms 
0311 00				nop 
0312 00				nop 
0313 00				nop 
0314			;	if DEBUG_STORESE 
0314			;		push af 
0314			;		ld a, 'w' 
0314			;		ld (debug_mark),a 
0314			;		pop af 
0314			;		CALLMONITOR 
0314			;	endif 
0314 c1				pop bc 
0315 d1				pop de 
0316 e1				pop hl 
0317 23				inc hl 
0318 13				inc de 
0319			 
0319			 
0319 10 ef			djnz .wl1 
031b			 
031b				if DEBUG_STORESE 
031b					DMARK "SW2" 
031b f5				push af  
031c 3a 30 03			ld a, (.dmark)  
031f 32 62 ee			ld (debug_mark),a  
0322 3a 31 03			ld a, (.dmark+1)  
0325 32 63 ee			ld (debug_mark+1),a  
0328 3a 32 03			ld a, (.dmark+2)  
032b 32 64 ee			ld (debug_mark+2),a  
032e 18 03			jr .pastdmark  
0330 ..			.dmark: db "SW2"  
0333 f1			.pastdmark: pop af  
0334			endm  
# End of macro DMARK
0334			 
0334					;push af 
0334					;ld a, 'W' 
0334					;ld (debug_mark),a 
0334					;pop af 
0334					CALLMONITOR 
0334 cd 6f ee			call debug_vector  
0337				endm  
# End of macro CALLMONITOR
0337				endif 
0337 c9				ret	 
0338			 
0338			; Init bank 
0338			; --------- 
0338			; 
0338			; With current bank 
0338			; 
0338			; Setup block 0 config 
0338			;     Set 0 file id counter 
0338			;     Set formatted byte pattern 
0338			;     Zero out bank label 
0338			;      
0338			; For every logical block write 0-1 byte as null 
0338			 
0338			storage_get_block_0: 
0338			 
0338				; TODO check presence 
0338			 
0338				; get block 0 config 
0338			 
0338 21 00 00			ld hl, 0 
033b 11 71 ea			ld de, store_page 
033e cd 87 02			call storage_read_block 
0341			 
0341				if DEBUG_STORESE 
0341					DMARK "SB0" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 62 ee			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 63 ee			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 64 ee			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SB0"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a 11 71 ea				ld de, store_page 
035d			;		push af 
035d			;		ld a, 'i' 
035d			;		ld (debug_mark),a 
035d			;		pop af 
035d					CALLMONITOR 
035d cd 6f ee			call debug_vector  
0360				endm  
# End of macro CALLMONITOR
0360				endif 
0360			 
0360				; is this area formatted? 
0360			 
0360			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0360 2a 72 ea			ld hl, (store_page+1) 
0363 3e 80			ld a,0x80 
0365 bd				cp l 
0366 20 22			jr nz, .ininotformatted 
0368				; do a double check 
0368 3e 27			ld a, 0x27 
036a bc				cp h 
036b 20 1d			jr nz, .ininotformatted 
036d			 
036d				; formatted then 
036d			 
036d				if DEBUG_STORESE 
036d					DMARK "SB1" 
036d f5				push af  
036e 3a 82 03			ld a, (.dmark)  
0371 32 62 ee			ld (debug_mark),a  
0374 3a 83 03			ld a, (.dmark+1)  
0377 32 63 ee			ld (debug_mark+1),a  
037a 3a 84 03			ld a, (.dmark+2)  
037d 32 64 ee			ld (debug_mark+2),a  
0380 18 03			jr .pastdmark  
0382 ..			.dmark: db "SB1"  
0385 f1			.pastdmark: pop af  
0386			endm  
# End of macro DMARK
0386					;push af 
0386					;ld a, 'I' 
0386					;ld (debug_mark),a 
0386					;pop af 
0386					CALLMONITOR 
0386 cd 6f ee			call debug_vector  
0389				endm  
# End of macro CALLMONITOR
0389				endif 
0389 c9				ret 
038a			 
038a			.ininotformatted: 
038a				; bank not formatted so poke various bits to make sure 
038a			 
038a				if DEBUG_STORESE 
038a					DMARK "SB2" 
038a f5				push af  
038b 3a 9f 03			ld a, (.dmark)  
038e 32 62 ee			ld (debug_mark),a  
0391 3a a0 03			ld a, (.dmark+1)  
0394 32 63 ee			ld (debug_mark+1),a  
0397 3a a1 03			ld a, (.dmark+2)  
039a 32 64 ee			ld (debug_mark+2),a  
039d 18 03			jr .pastdmark  
039f ..			.dmark: db "SB2"  
03a2 f1			.pastdmark: pop af  
03a3			endm  
# End of macro DMARK
03a3					;push af 
03a3					;ld a, 'f' 
03a3					;ld (debug_mark),a 
03a3					;pop af 
03a3					CALLMONITOR 
03a3 cd 6f ee			call debug_vector  
03a6				endm  
# End of macro CALLMONITOR
03a6				endif 
03a6			 
03a6 cd c3 0a			call storage_clear_page 
03a9			 
03a9 21 71 ea			ld hl, store_page 
03ac 3e 00			ld a, 0 
03ae				 
03ae 77				ld (hl),a   ; reset file counter 
03af			 
03af 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03b2 22 72 ea		 	ld (store_page+1), hl	 
03b5			 
03b5				; set default label 
03b5			 
03b5 21 51 04			ld hl, .defaultbanklabl 
03b8 11 74 ea		 	ld de, store_page+3 
03bb 01 0f 00			ld bc, 15 
03be ed b0			ldir 
03c0			 
03c0				; Append the current bank id 
03c0 21 7d ea			ld hl, store_page+3+9 
03c3 3a 56 ea			ld a, (spi_device_id) 
03c6 77				ld (hl), a 
03c7			 
03c7				; save default page 0 
03c7			 
03c7 21 00 00			ld hl, 0 
03ca 11 71 ea			ld de, store_page 
03cd				if DEBUG_STORESE 
03cd					DMARK "SB3" 
03cd f5				push af  
03ce 3a e2 03			ld a, (.dmark)  
03d1 32 62 ee			ld (debug_mark),a  
03d4 3a e3 03			ld a, (.dmark+1)  
03d7 32 63 ee			ld (debug_mark+1),a  
03da 3a e4 03			ld a, (.dmark+2)  
03dd 32 64 ee			ld (debug_mark+2),a  
03e0 18 03			jr .pastdmark  
03e2 ..			.dmark: db "SB3"  
03e5 f1			.pastdmark: pop af  
03e6			endm  
# End of macro DMARK
03e6			;		push af 
03e6			;		ld a, 'F' 
03e6			;		ld (debug_mark),a 
03e6			;		pop af 
03e6					CALLMONITOR 
03e6 cd 6f ee			call debug_vector  
03e9				endm  
# End of macro CALLMONITOR
03e9				endif 
03e9 cd ec 02			call storage_write_block 
03ec				if DEBUG_STORESE 
03ec					DMARK "SB4" 
03ec f5				push af  
03ed 3a 01 04			ld a, (.dmark)  
03f0 32 62 ee			ld (debug_mark),a  
03f3 3a 02 04			ld a, (.dmark+1)  
03f6 32 63 ee			ld (debug_mark+1),a  
03f9 3a 03 04			ld a, (.dmark+2)  
03fc 32 64 ee			ld (debug_mark+2),a  
03ff 18 03			jr .pastdmark  
0401 ..			.dmark: db "SB4"  
0404 f1			.pastdmark: pop af  
0405			endm  
# End of macro DMARK
0405			;		push af 
0405			;		ld a, '>' 
0405			;		ld (debug_mark),a 
0405			;		pop af 
0405					CALLMONITOR 
0405 cd 6f ee			call debug_vector  
0408				endm  
# End of macro CALLMONITOR
0408				endif 
0408			 
0408 00				nop 
0409 00				nop 
040a 00				nop 
040b			 
040b				; now set 0 in every page to mark as a free block 
040b			 
040b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
040d 21 40 00			ld hl, STORE_BLOCK_PHY 
0410			 
0410 3e 00		.setmark1:   	ld a,0 
0412 e5					push hl 
0413 c5					push bc 
0414 cd ac 01				call se_writebyte 
0417 3e 0a			ld a, 10 
0419 cd e5 0a			call aDelayInMS 
041c 23				inc hl 
041d cd ac 01				call se_writebyte 
0420 3e 0a			ld a, 10 
0422 cd e5 0a			call aDelayInMS 
0425 2b				dec hl 
0426 c1					pop bc 
0427 e1					pop hl 
0428 3e 40				ld a, STORE_BLOCK_PHY 
042a cd f5 0d				call addatohl 
042d 10 e1				djnz .setmark1 
042f			 
042f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0431 3e 00		.setmark2:   	ld a,0 
0433 e5					push hl 
0434 c5					push bc 
0435 cd ac 01				call se_writebyte 
0438 3e 0a			ld a, 10 
043a cd e5 0a			call aDelayInMS 
043d 23				inc hl 
043e cd ac 01				call se_writebyte 
0441 3e 0a			ld a, 10 
0443 cd e5 0a			call aDelayInMS 
0446 2b				dec hl 
0447 c1					pop bc 
0448 e1					pop hl 
0449 3e 40				ld a, STORE_BLOCK_PHY 
044b cd f5 0d				call addatohl 
044e 10 e1				djnz .setmark2 
0450			 
0450					 
0450			 
0450			 
0450 c9				ret 
0451			 
0451			 
0451			 
0451			 
0451 .. 00		.defaultbanklabl:   db "BankLabel_",0 
045c			 
045c			 
045c			 
045c			; Label Bank 
045c			; ---------- 
045c			; 
045c			; With current bank 
045c			; Read block 0 
045c			; Set label 
045c			; Write block 0 
045c			 
045c			; label str pointer in hl 
045c			 
045c			storage_label:     
045c			 
045c				if DEBUG_STORESE 
045c					DMARK "LBL" 
045c f5				push af  
045d 3a 71 04			ld a, (.dmark)  
0460 32 62 ee			ld (debug_mark),a  
0463 3a 72 04			ld a, (.dmark+1)  
0466 32 63 ee			ld (debug_mark+1),a  
0469 3a 73 04			ld a, (.dmark+2)  
046c 32 64 ee			ld (debug_mark+2),a  
046f 18 03			jr .pastdmark  
0471 ..			.dmark: db "LBL"  
0474 f1			.pastdmark: pop af  
0475			endm  
# End of macro DMARK
0475					CALLMONITOR 
0475 cd 6f ee			call debug_vector  
0478				endm  
# End of macro CALLMONITOR
0478				endif 
0478			 
0478 e5				push hl 
0479			 
0479 cd 38 03			call storage_get_block_0 
047c			 
047c				; set default label 
047c			 
047c e1				pop hl 
047d			 
047d 11 74 ea		 	ld de, store_page+3 
0480 01 0f 00			ld bc, 15 
0483				if DEBUG_STORESE 
0483					DMARK "LB3" 
0483 f5				push af  
0484 3a 98 04			ld a, (.dmark)  
0487 32 62 ee			ld (debug_mark),a  
048a 3a 99 04			ld a, (.dmark+1)  
048d 32 63 ee			ld (debug_mark+1),a  
0490 3a 9a 04			ld a, (.dmark+2)  
0493 32 64 ee			ld (debug_mark+2),a  
0496 18 03			jr .pastdmark  
0498 ..			.dmark: db "LB3"  
049b f1			.pastdmark: pop af  
049c			endm  
# End of macro DMARK
049c					CALLMONITOR 
049c cd 6f ee			call debug_vector  
049f				endm  
# End of macro CALLMONITOR
049f				endif 
049f ed b0			ldir 
04a1				; save default page 0 
04a1			 
04a1 21 00 00			ld hl, 0 
04a4 11 71 ea			ld de, store_page 
04a7				if DEBUG_STORESE 
04a7					DMARK "LBW" 
04a7 f5				push af  
04a8 3a bc 04			ld a, (.dmark)  
04ab 32 62 ee			ld (debug_mark),a  
04ae 3a bd 04			ld a, (.dmark+1)  
04b1 32 63 ee			ld (debug_mark+1),a  
04b4 3a be 04			ld a, (.dmark+2)  
04b7 32 64 ee			ld (debug_mark+2),a  
04ba 18 03			jr .pastdmark  
04bc ..			.dmark: db "LBW"  
04bf f1			.pastdmark: pop af  
04c0			endm  
# End of macro DMARK
04c0					CALLMONITOR 
04c0 cd 6f ee			call debug_vector  
04c3				endm  
# End of macro CALLMONITOR
04c3				endif 
04c3 cd ec 02			call storage_write_block 
04c6			 
04c6 c9				ret 
04c7			 
04c7			 
04c7			 
04c7			; Read Block 0 - Config 
04c7			; --------------------- 
04c7			; 
04c7			; With current bank 
04c7			; Call presence test 
04c7			;    If not present format/init bank  
04c7			; Read block 0  
04c7			;  
04c7			 
04c7			 
04c7			; Dir 
04c7			; --- 
04c7			; 
04c7			; With current bank 
04c7			; Load Block 0 Config 
04c7			; Get max file id number 
04c7			; For each logical block 
04c7			;    Read block read byte 2 
04c7			;      if first block of file 
04c7			;         Display file name 
04c7			;         Display type flags for file 
04c7			;        
04c7			 
04c7			; moving to words as this requires stack control 
04c7			 
04c7			 
04c7			; Delete File 
04c7			; ----------- 
04c7			; 
04c7			; With current bank 
04c7			; 
04c7			; Load Block 0 Config 
04c7			; Get max file id number 
04c7			; For each logical block 
04c7			;    Read block file id 
04c7			;      If first block of file and dont have file id 
04c7			;         if file to delete 
04c7			;         Save file id 
04c7			;         Null file id 
04c7			;         Write this block back 
04c7			;      If file id is one saved 
04c7			;         Null file id 
04c7			;         Write this block back 
04c7			 
04c7			 
04c7			.se_done: 
04c7 e1				pop hl 
04c8 c9				ret 
04c9			 
04c9			storage_erase: 
04c9			 
04c9				; hl contains the file id 
04c9			 
04c9 5d				ld e, l 
04ca 16 00			ld d, 0 
04cc 21 40 00			ld hl, STORE_BLOCK_PHY 
04cf					if DEBUG_FORTH_WORDS 
04cf						DMARK "ERA" 
04cf f5				push af  
04d0 3a e4 04			ld a, (.dmark)  
04d3 32 62 ee			ld (debug_mark),a  
04d6 3a e5 04			ld a, (.dmark+1)  
04d9 32 63 ee			ld (debug_mark+1),a  
04dc 3a e6 04			ld a, (.dmark+2)  
04df 32 64 ee			ld (debug_mark+2),a  
04e2 18 03			jr .pastdmark  
04e4 ..			.dmark: db "ERA"  
04e7 f1			.pastdmark: pop af  
04e8			endm  
# End of macro DMARK
04e8						CALLMONITOR 
04e8 cd 6f ee			call debug_vector  
04eb				endm  
# End of macro CALLMONITOR
04eb					endif 
04eb cd ba 05			call storage_findnextid 
04ee cd 1e 0e			call ishlzero 
04f1 c8				ret z 
04f2			 
04f2 e5				push hl 
04f3			 
04f3				; TODO check file not found 
04f3			 
04f3 11 71 ea			ld de, store_page 
04f6 cd 87 02			call storage_read_block 
04f9			 
04f9 cd 1e 0e			call ishlzero 
04fc ca c7 04			jp z,.se_done 
04ff			 
04ff					if DEBUG_FORTH_WORDS 
04ff						DMARK "ER1" 
04ff f5				push af  
0500 3a 14 05			ld a, (.dmark)  
0503 32 62 ee			ld (debug_mark),a  
0506 3a 15 05			ld a, (.dmark+1)  
0509 32 63 ee			ld (debug_mark+1),a  
050c 3a 16 05			ld a, (.dmark+2)  
050f 32 64 ee			ld (debug_mark+2),a  
0512 18 03			jr .pastdmark  
0514 ..			.dmark: db "ER1"  
0517 f1			.pastdmark: pop af  
0518			endm  
# End of macro DMARK
0518						CALLMONITOR 
0518 cd 6f ee			call debug_vector  
051b				endm  
# End of macro CALLMONITOR
051b					endif 
051b 3a 71 ea			ld a, (store_page)	; get file id 
051e 32 65 ea			ld (store_tmpid), a 
0521			 
0521 3a 73 ea			ld a, (store_page+2)    ; get count of extends 
0524 32 64 ea			ld (store_tmpext), a 
0527			 
0527				; wipe file header 
0527			 
0527 e1				pop hl 
0528 3e 00			ld a, 0 
052a 32 71 ea			ld (store_page), a 
052d 32 72 ea			ld (store_page+1),a 
0530 11 71 ea			ld de, store_page 
0533					if DEBUG_FORTH_WORDS 
0533						DMARK "ER2" 
0533 f5				push af  
0534 3a 48 05			ld a, (.dmark)  
0537 32 62 ee			ld (debug_mark),a  
053a 3a 49 05			ld a, (.dmark+1)  
053d 32 63 ee			ld (debug_mark+1),a  
0540 3a 4a 05			ld a, (.dmark+2)  
0543 32 64 ee			ld (debug_mark+2),a  
0546 18 03			jr .pastdmark  
0548 ..			.dmark: db "ER2"  
054b f1			.pastdmark: pop af  
054c			endm  
# End of macro DMARK
054c						CALLMONITOR 
054c cd 6f ee			call debug_vector  
054f				endm  
# End of macro CALLMONITOR
054f					endif 
054f cd ec 02			call storage_write_block 
0552			 
0552			 
0552				; wipe file extents 
0552			 
0552 3a 64 ea			ld a, (store_tmpext) 
0555 47				ld b, a 
0556			 
0556			.eraext:	  
0556 c5				push bc 
0557			 
0557 21 40 00			ld hl, STORE_BLOCK_PHY 
055a 3a 65 ea			ld a,(store_tmpid) 
055d 5f				ld e, a 
055e 50				ld d, b	 
055f					if DEBUG_FORTH_WORDS 
055f						DMARK "ER3" 
055f f5				push af  
0560 3a 74 05			ld a, (.dmark)  
0563 32 62 ee			ld (debug_mark),a  
0566 3a 75 05			ld a, (.dmark+1)  
0569 32 63 ee			ld (debug_mark+1),a  
056c 3a 76 05			ld a, (.dmark+2)  
056f 32 64 ee			ld (debug_mark+2),a  
0572 18 03			jr .pastdmark  
0574 ..			.dmark: db "ER3"  
0577 f1			.pastdmark: pop af  
0578			endm  
# End of macro DMARK
0578						CALLMONITOR 
0578 cd 6f ee			call debug_vector  
057b				endm  
# End of macro CALLMONITOR
057b					endif 
057b cd ba 05			call storage_findnextid 
057e cd 1e 0e			call ishlzero 
0581 ca c7 04			jp z,.se_done 
0584			 
0584 e5				push hl 
0585 11 71 ea			ld de, store_page 
0588 cd 87 02			call storage_read_block 
058b			 
058b				; free block	 
058b			 
058b 3e 00			ld a, 0 
058d 32 71 ea			ld (store_page), a 
0590 32 72 ea			ld (store_page+1),a 
0593 11 71 ea			ld de, store_page 
0596 e1				pop hl 
0597					if DEBUG_FORTH_WORDS 
0597						DMARK "ER4" 
0597 f5				push af  
0598 3a ac 05			ld a, (.dmark)  
059b 32 62 ee			ld (debug_mark),a  
059e 3a ad 05			ld a, (.dmark+1)  
05a1 32 63 ee			ld (debug_mark+1),a  
05a4 3a ae 05			ld a, (.dmark+2)  
05a7 32 64 ee			ld (debug_mark+2),a  
05aa 18 03			jr .pastdmark  
05ac ..			.dmark: db "ER4"  
05af f1			.pastdmark: pop af  
05b0			endm  
# End of macro DMARK
05b0						CALLMONITOR 
05b0 cd 6f ee			call debug_vector  
05b3				endm  
# End of macro CALLMONITOR
05b3					endif 
05b3 cd ec 02			call storage_write_block 
05b6			 
05b6 c1				pop bc 
05b7 10 9d			djnz .eraext 
05b9			 
05b9 c9				ret 
05ba			 
05ba			 
05ba			; Find Free Block 
05ba			; --------------- 
05ba			; 
05ba			; With current bank 
05ba			;  
05ba			; From given starting logical block 
05ba			;    Read block  
05ba			;    If no file id 
05ba			;         Return block id 
05ba			 
05ba			 
05ba			; hl starting page number 
05ba			; hl contains free page number or zero if no pages free 
05ba			; e contains the file id to locate 
05ba			; d contains the block number 
05ba			 
05ba			; TODO change to find file id and use zero for free block 
05ba			 
05ba			storage_findnextid: 
05ba			 
05ba				; now locate first 0 page to mark as a free block 
05ba			 
05ba 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05bc			;	ld hl, STORE_BLOCK_PHY 
05bc			 
05bc					if DEBUG_FORTH_WORDS 
05bc					DMARK "FNI" 
05bc f5				push af  
05bd 3a d1 05			ld a, (.dmark)  
05c0 32 62 ee			ld (debug_mark),a  
05c3 3a d2 05			ld a, (.dmark+1)  
05c6 32 63 ee			ld (debug_mark+1),a  
05c9 3a d3 05			ld a, (.dmark+2)  
05cc 32 64 ee			ld (debug_mark+2),a  
05cf 18 03			jr .pastdmark  
05d1 ..			.dmark: db "FNI"  
05d4 f1			.pastdmark: pop af  
05d5			endm  
# End of macro DMARK
05d5						CALLMONITOR 
05d5 cd 6f ee			call debug_vector  
05d8				endm  
# End of macro CALLMONITOR
05d8					endif 
05d8			.ff1:   	 
05d8 e5					push hl 
05d9 c5					push bc 
05da d5					push de 
05db cd ab 01				call se_readbyte 
05de 5f					ld e,a 
05df 23					inc hl 
05e0 cd ab 01				call se_readbyte 
05e3 57					ld d, a 
05e4 e1					pop hl 
05e5 e5					push hl 
05e6 cd 13 0e				call cmp16 
05e9 28 49				jr z, .fffound 
05eb			 
05eb d1					pop de 
05ec c1					pop bc 
05ed e1					pop hl 
05ee			 
05ee					; is found? 
05ee					;cp e 
05ee					;ret z 
05ee			 
05ee 3e 40				ld a, STORE_BLOCK_PHY 
05f0 cd f5 0d				call addatohl 
05f3 10 e3				djnz .ff1 
05f5			 
05f5 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05f7			.ff2:   	 
05f7			 
05f7 e5					push hl 
05f8 c5					push bc 
05f9 d5					push de 
05fa cd ab 01				call se_readbyte 
05fd 5f					ld e,a 
05fe 23					inc hl 
05ff cd ab 01				call se_readbyte 
0602 57					ld d, a 
0603			 
0603 e1					pop hl 
0604 e5					push hl 
0605 cd 13 0e				call cmp16 
0608 28 2a				jr z, .fffound 
060a			 
060a d1					pop de 
060b c1					pop bc 
060c e1					pop hl 
060d					; is found? 
060d					;cp e 
060d					;ret z 
060d			 
060d 3e 40				ld a, STORE_BLOCK_PHY 
060f cd f5 0d				call addatohl 
0612 10 e3				djnz .ff2 
0614			 
0614			 
0614					if DEBUG_FORTH_WORDS 
0614					DMARK "FN-" 
0614 f5				push af  
0615 3a 29 06			ld a, (.dmark)  
0618 32 62 ee			ld (debug_mark),a  
061b 3a 2a 06			ld a, (.dmark+1)  
061e 32 63 ee			ld (debug_mark+1),a  
0621 3a 2b 06			ld a, (.dmark+2)  
0624 32 64 ee			ld (debug_mark+2),a  
0627 18 03			jr .pastdmark  
0629 ..			.dmark: db "FN-"  
062c f1			.pastdmark: pop af  
062d			endm  
# End of macro DMARK
062d					;	push af 
062d					;	ld a, 'n' 
062d					;	ld (debug_mark),a 
062d					;	pop af 
062d						CALLMONITOR 
062d cd 6f ee			call debug_vector  
0630				endm  
# End of macro CALLMONITOR
0630					endif 
0630				; no free marks! 
0630 21 00 00				ld hl, 0 
0633 c9				ret 
0634			.fffound: 
0634				 
0634			 
0634 d1					pop de 
0635 c1					pop bc 
0636 e1					pop hl 
0637					if DEBUG_FORTH_WORDS 
0637					DMARK "FNF" 
0637 f5				push af  
0638 3a 4c 06			ld a, (.dmark)  
063b 32 62 ee			ld (debug_mark),a  
063e 3a 4d 06			ld a, (.dmark+1)  
0641 32 63 ee			ld (debug_mark+1),a  
0644 3a 4e 06			ld a, (.dmark+2)  
0647 32 64 ee			ld (debug_mark+2),a  
064a 18 03			jr .pastdmark  
064c ..			.dmark: db "FNF"  
064f f1			.pastdmark: pop af  
0650			endm  
# End of macro DMARK
0650					;	push af 
0650					;	ld a, 'n' 
0650					;	ld (debug_mark),a 
0650					;	pop af 
0650						CALLMONITOR 
0650 cd 6f ee			call debug_vector  
0653				endm  
# End of macro CALLMONITOR
0653					endif 
0653 c9				ret 
0654			 
0654			 
0654			 
0654			; Free Space 
0654			; ---------- 
0654			; 
0654			; With current bank 
0654			; 
0654			; Set block count to zero 
0654			; Starting with first logical block 
0654			;      Find free block  
0654			;      If block id given, increment block count 
0654			; 
0654			;  
0654			 
0654			 
0654			; hl contains count of free blocks 
0654			 
0654			storage_freeblocks: 
0654			 
0654				; now locate first 0 page to mark as a free block 
0654			 
0654 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0656 21 40 00			ld hl, STORE_BLOCK_PHY 
0659 11 00 00			ld de, 0 
065c			 
065c			.fb1:   	 
065c e5					push hl 
065d c5					push bc 
065e d5					push de 
065f cd ab 01				call se_readbyte 
0662 d1					pop de 
0663 c1					pop bc 
0664 e1					pop hl 
0665			 
0665					; is free? 
0665 fe 00				cp 0 
0667 20 01				jr nz, .ff1cont 
0669 13					inc de 
066a			 
066a			.ff1cont: 
066a			 
066a			 
066a 3e 40				ld a, STORE_BLOCK_PHY 
066c cd f5 0d				call addatohl 
066f 10 eb				djnz .fb1 
0671			 
0671 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0673			.fb2:   	 
0673 e5					push hl 
0674 c5					push bc 
0675 d5					push de 
0676 cd ab 01				call se_readbyte 
0679 d1					pop de 
067a c1					pop bc 
067b e1					pop hl 
067c			 
067c					; is free? 
067c fe 00				cp 0 
067e 20 01				jr nz, .ff2cont 
0680 13					inc de 
0681			 
0681			.ff2cont: 
0681			 
0681 3e 40				ld a, STORE_BLOCK_PHY 
0683 cd f5 0d				call addatohl 
0686 10 eb				djnz .fb2 
0688			 
0688 eb				ex de, hl 
0689 c9				ret 
068a			 
068a			; Get File ID 
068a			; ----------- 
068a			; 
068a			; With current bank 
068a			;  
068a			; Load Block 0 Config 
068a			; Get max file id number 
068a			; For each logical block 
068a			;    Read block file id 
068a			;      If first block of file and dont have file id 
068a			;         if file get id and exit 
068a			 
068a			 
068a			 
068a			 
068a			; Create File 
068a			; ----------- 
068a			; 
068a			; With current bank  
068a			; Load Block 0 Config 
068a			; Get max file id number 
068a			; Increment file id number 
068a			; Save Config 
068a			; Find free block 
068a			; Set buffer with file name and file id 
068a			; Write buffer to free block  
068a			 
068a			 
068a			; hl point to file name 
068a			; hl returns file id 
068a			 
068a			; file format: 
068a			; byte 0 - file id 
068a			; byte 1 - extent number 
068a			; byte 2-> data 
068a			 
068a			; format for extent number 0: 
068a			; 
068a			; byte 0 - file id 
068a			; byte 1 - extent 0 
068a			; byte 2 - extent count 
068a			; byte 3 -> file name and meta data 
068a			 
068a			 
068a			storage_create: 
068a				if DEBUG_STORESE 
068a					DMARK "SCR" 
068a f5				push af  
068b 3a 9f 06			ld a, (.dmark)  
068e 32 62 ee			ld (debug_mark),a  
0691 3a a0 06			ld a, (.dmark+1)  
0694 32 63 ee			ld (debug_mark+1),a  
0697 3a a1 06			ld a, (.dmark+2)  
069a 32 64 ee			ld (debug_mark+2),a  
069d 18 03			jr .pastdmark  
069f ..			.dmark: db "SCR"  
06a2 f1			.pastdmark: pop af  
06a3			endm  
# End of macro DMARK
06a3					CALLMONITOR 
06a3 cd 6f ee			call debug_vector  
06a6				endm  
# End of macro CALLMONITOR
06a6				endif 
06a6			 
06a6 e5				push hl		; save file name pointer 
06a7			 
06a7 cd 38 03			call storage_get_block_0 
06aa			 
06aa 3a 71 ea			ld a,(store_page)	; get current file id 
06ad 3c				inc a 
06ae 32 71 ea			ld (store_page),a 
06b1				 
06b1 32 65 ea			ld (store_tmpid),a			; save id 
06b4			 
06b4 21 00 00			ld hl, 0 
06b7 11 71 ea			ld de, store_page 
06ba				if DEBUG_STORESE 
06ba					DMARK "SCw" 
06ba f5				push af  
06bb 3a cf 06			ld a, (.dmark)  
06be 32 62 ee			ld (debug_mark),a  
06c1 3a d0 06			ld a, (.dmark+1)  
06c4 32 63 ee			ld (debug_mark+1),a  
06c7 3a d1 06			ld a, (.dmark+2)  
06ca 32 64 ee			ld (debug_mark+2),a  
06cd 18 03			jr .pastdmark  
06cf ..			.dmark: db "SCw"  
06d2 f1			.pastdmark: pop af  
06d3			endm  
# End of macro DMARK
06d3					CALLMONITOR 
06d3 cd 6f ee			call debug_vector  
06d6				endm  
# End of macro CALLMONITOR
06d6				endif 
06d6 cd ec 02			call storage_write_block	 ; save update 
06d9			 
06d9				if DEBUG_STORESE 
06d9 11 71 ea				ld de, store_page 
06dc					DMARK "SCC" 
06dc f5				push af  
06dd 3a f1 06			ld a, (.dmark)  
06e0 32 62 ee			ld (debug_mark),a  
06e3 3a f2 06			ld a, (.dmark+1)  
06e6 32 63 ee			ld (debug_mark+1),a  
06e9 3a f3 06			ld a, (.dmark+2)  
06ec 32 64 ee			ld (debug_mark+2),a  
06ef 18 03			jr .pastdmark  
06f1 ..			.dmark: db "SCC"  
06f4 f1			.pastdmark: pop af  
06f5			endm  
# End of macro DMARK
06f5					CALLMONITOR 
06f5 cd 6f ee			call debug_vector  
06f8				endm  
# End of macro CALLMONITOR
06f8				endif 
06f8				;  
06f8				 
06f8 21 40 00			ld hl, STORE_BLOCK_PHY 
06fb 11 00 00			ld de, 0 
06fe cd ba 05			call storage_findnextid 
0701			 
0701 22 5c ea			ld (store_tmppageid), hl    ; save page to use  
0704			 
0704				; TODO detect 0 = no spare blocks 
0704			 
0704				; hl now contains the free page to use for the file header page 
0704			 
0704				if DEBUG_STORESE 
0704				DMARK "SCF" 
0704 f5				push af  
0705 3a 19 07			ld a, (.dmark)  
0708 32 62 ee			ld (debug_mark),a  
070b 3a 1a 07			ld a, (.dmark+1)  
070e 32 63 ee			ld (debug_mark+1),a  
0711 3a 1b 07			ld a, (.dmark+2)  
0714 32 64 ee			ld (debug_mark+2),a  
0717 18 03			jr .pastdmark  
0719 ..			.dmark: db "SCF"  
071c f1			.pastdmark: pop af  
071d			endm  
# End of macro DMARK
071d					CALLMONITOR 
071d cd 6f ee			call debug_vector  
0720				endm  
# End of macro CALLMONITOR
0720				endif 
0720			 
0720 22 5c ea			ld (store_tmppageid), hl 
0723				 
0723 3a 65 ea			ld a,(store_tmpid)    ; get file id 
0726			;	ld a, (store_filecache)			; save to cache 
0726			 
0726 32 71 ea			ld (store_page),a    ; set page id 
0729 3e 00			ld a, 0			 ; extent 0 is file header 
072b 32 72 ea			ld (store_page+1), a   ; set file extent 
072e			 
072e 32 73 ea			ld (store_page+2), a   ; extent count for the file 
0731			 
0731			;	inc hl 		; init block 0 of file 
0731			;	inc hl   		; skip file and extent id 
0731			 ;       ld a, 0 
0731			;	ld (hl),a 
0731			;	ld a, (store_filecache+1)  	; save to cache 
0731			 
0731			;	inc hl    ; file name 
0731				 
0731				 
0731 11 74 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0734				if DEBUG_STORESE 
0734					DMARK "SCc" 
0734 f5				push af  
0735 3a 49 07			ld a, (.dmark)  
0738 32 62 ee			ld (debug_mark),a  
073b 3a 4a 07			ld a, (.dmark+1)  
073e 32 63 ee			ld (debug_mark+1),a  
0741 3a 4b 07			ld a, (.dmark+2)  
0744 32 64 ee			ld (debug_mark+2),a  
0747 18 03			jr .pastdmark  
0749 ..			.dmark: db "SCc"  
074c f1			.pastdmark: pop af  
074d			endm  
# End of macro DMARK
074d					CALLMONITOR 
074d cd 6f ee			call debug_vector  
0750				endm  
# End of macro CALLMONITOR
0750				endif 
0750 e1				pop hl    ; get zero term string 
0751 e5				push hl 
0752 3e 00			ld a, 0 
0754 cd 66 11			call strlent 
0757 23				inc hl   ; cover zero term 
0758 06 00			ld b,0 
075a 4d				ld c,l 
075b e1				pop hl 
075c				;ex de, hl 
075c				if DEBUG_STORESE 
075c					DMARK "SCa" 
075c f5				push af  
075d 3a 71 07			ld a, (.dmark)  
0760 32 62 ee			ld (debug_mark),a  
0763 3a 72 07			ld a, (.dmark+1)  
0766 32 63 ee			ld (debug_mark+1),a  
0769 3a 73 07			ld a, (.dmark+2)  
076c 32 64 ee			ld (debug_mark+2),a  
076f 18 03			jr .pastdmark  
0771 ..			.dmark: db "SCa"  
0774 f1			.pastdmark: pop af  
0775			endm  
# End of macro DMARK
0775					;push af 
0775					;ld a, 'a' 
0775					;ld (debug_mark),a 
0775					;pop af 
0775					CALLMONITOR 
0775 cd 6f ee			call debug_vector  
0778				endm  
# End of macro CALLMONITOR
0778				endif 
0778 ed b0			ldir    ; copy zero term string 
077a				if DEBUG_STORESE 
077a					DMARK "SCA" 
077a f5				push af  
077b 3a 8f 07			ld a, (.dmark)  
077e 32 62 ee			ld (debug_mark),a  
0781 3a 90 07			ld a, (.dmark+1)  
0784 32 63 ee			ld (debug_mark+1),a  
0787 3a 91 07			ld a, (.dmark+2)  
078a 32 64 ee			ld (debug_mark+2),a  
078d 18 03			jr .pastdmark  
078f ..			.dmark: db "SCA"  
0792 f1			.pastdmark: pop af  
0793			endm  
# End of macro DMARK
0793					CALLMONITOR 
0793 cd 6f ee			call debug_vector  
0796				endm  
# End of macro CALLMONITOR
0796				endif 
0796			 
0796				; write file header page 
0796			 
0796 2a 5c ea			ld hl,(store_tmppageid) 
0799 11 71 ea			ld de, store_page 
079c				if DEBUG_STORESE 
079c					DMARK "SCb" 
079c f5				push af  
079d 3a b1 07			ld a, (.dmark)  
07a0 32 62 ee			ld (debug_mark),a  
07a3 3a b2 07			ld a, (.dmark+1)  
07a6 32 63 ee			ld (debug_mark+1),a  
07a9 3a b3 07			ld a, (.dmark+2)  
07ac 32 64 ee			ld (debug_mark+2),a  
07af 18 03			jr .pastdmark  
07b1 ..			.dmark: db "SCb"  
07b4 f1			.pastdmark: pop af  
07b5			endm  
# End of macro DMARK
07b5					;push af 
07b5					;ld a, 'b' 
07b5					;ld (debug_mark),a 
07b5					;pop af 
07b5					CALLMONITOR 
07b5 cd 6f ee			call debug_vector  
07b8				endm  
# End of macro CALLMONITOR
07b8				endif 
07b8 cd ec 02			call storage_write_block 
07bb			 
07bb 3a 65 ea			ld a, (store_tmpid) 
07be 6f				ld l, a 
07bf 26 00			ld h,0 
07c1				if DEBUG_STORESE 
07c1					DMARK "SCz" 
07c1 f5				push af  
07c2 3a d6 07			ld a, (.dmark)  
07c5 32 62 ee			ld (debug_mark),a  
07c8 3a d7 07			ld a, (.dmark+1)  
07cb 32 63 ee			ld (debug_mark+1),a  
07ce 3a d8 07			ld a, (.dmark+2)  
07d1 32 64 ee			ld (debug_mark+2),a  
07d4 18 03			jr .pastdmark  
07d6 ..			.dmark: db "SCz"  
07d9 f1			.pastdmark: pop af  
07da			endm  
# End of macro DMARK
07da					CALLMONITOR 
07da cd 6f ee			call debug_vector  
07dd				endm  
# End of macro CALLMONITOR
07dd				endif 
07dd c9				ret 
07de				 
07de			 
07de			 
07de			; 
07de			; Read File 
07de			; 
07de			; h - file id to locate 
07de			; l - extent to locate 
07de			; de - pointer to string to read into 
07de			; 
07de			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07de			 
07de			.sr_fail: 
07de d1				pop de 
07df c9				ret 
07e0			 
07e0			storage_read: 
07e0			 
07e0			 
07e0 d5				push de 
07e1			 
07e1			; TODO BUG the above push is it popped before the RET Z? 
07e1			 
07e1			; TODO how to handle multiple part blocks 
07e1			 
07e1				; locate file extent to read 
07e1			 
07e1 5c				ld e, h 
07e2 55				ld d, l 
07e3			 
07e3			.srext: 
07e3 22 6f ea			ld (store_readptr), hl     ; save the current extent to load 
07e6 ed 53 6d ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07ea			 
07ea 21 40 00			ld hl, STORE_BLOCK_PHY 
07ed				if DEBUG_STORESE 
07ed					DMARK "sre" 
07ed f5				push af  
07ee 3a 02 08			ld a, (.dmark)  
07f1 32 62 ee			ld (debug_mark),a  
07f4 3a 03 08			ld a, (.dmark+1)  
07f7 32 63 ee			ld (debug_mark+1),a  
07fa 3a 04 08			ld a, (.dmark+2)  
07fd 32 64 ee			ld (debug_mark+2),a  
0800 18 03			jr .pastdmark  
0802 ..			.dmark: db "sre"  
0805 f1			.pastdmark: pop af  
0806			endm  
# End of macro DMARK
0806					CALLMONITOR 
0806 cd 6f ee			call debug_vector  
0809				endm  
# End of macro CALLMONITOR
0809				endif 
0809 cd ba 05			call storage_findnextid 
080c			 
080c				if DEBUG_STORESE 
080c					DMARK "srf" 
080c f5				push af  
080d 3a 21 08			ld a, (.dmark)  
0810 32 62 ee			ld (debug_mark),a  
0813 3a 22 08			ld a, (.dmark+1)  
0816 32 63 ee			ld (debug_mark+1),a  
0819 3a 23 08			ld a, (.dmark+2)  
081c 32 64 ee			ld (debug_mark+2),a  
081f 18 03			jr .pastdmark  
0821 ..			.dmark: db "srf"  
0824 f1			.pastdmark: pop af  
0825			endm  
# End of macro DMARK
0825					CALLMONITOR 
0825 cd 6f ee			call debug_vector  
0828				endm  
# End of macro CALLMONITOR
0828				endif 
0828 cd 1e 0e			call ishlzero 
082b			;	ld a, l 
082b			;	add h 
082b			;	cp 0 
082b 28 b1			jr z,.sr_fail			; block not found so EOF 
082d			 
082d				; save current address for use by higher level words etc 
082d			 
082d 22 62 ea			ld (store_openaddr),hl 
0830			 
0830			 
0830				; hl contains page number to load 
0830 d1				pop de   ; get storage 
0831 ed 53 6d ea		ld (store_readbuf), de     ; current buffer to load in to 
0835 d5				push de 
0836				if DEBUG_STORESE 
0836					DMARK "srg" 
0836 f5				push af  
0837 3a 4b 08			ld a, (.dmark)  
083a 32 62 ee			ld (debug_mark),a  
083d 3a 4c 08			ld a, (.dmark+1)  
0840 32 63 ee			ld (debug_mark+1),a  
0843 3a 4d 08			ld a, (.dmark+2)  
0846 32 64 ee			ld (debug_mark+2),a  
0849 18 03			jr .pastdmark  
084b ..			.dmark: db "srg"  
084e f1			.pastdmark: pop af  
084f			endm  
# End of macro DMARK
084f					CALLMONITOR 
084f cd 6f ee			call debug_vector  
0852				endm  
# End of macro CALLMONITOR
0852				endif 
0852 cd 87 02			call storage_read_block 
0855			 
0855				; if this a continuation read??? 
0855			 
0855 2a 6d ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0858			 
0858 3e 3f			ld a, STORE_BLOCK_PHY-1 
085a cd f5 0d			call addatohl 
085d 7e				ld a,(hl) 
085e fe 00			cp 0 
0860 28 02			jr z, .markiscont 
0862 3e ff			ld a, 255 
0864			 
0864			.markiscont: 
0864 32 64 ea			ld (store_readcont), a 
0867			 
0867				if DEBUG_STORESE 
0867					DMARK "srC" 
0867 f5				push af  
0868 3a 7c 08			ld a, (.dmark)  
086b 32 62 ee			ld (debug_mark),a  
086e 3a 7d 08			ld a, (.dmark+1)  
0871 32 63 ee			ld (debug_mark+1),a  
0874 3a 7e 08			ld a, (.dmark+2)  
0877 32 64 ee			ld (debug_mark+2),a  
087a 18 03			jr .pastdmark  
087c ..			.dmark: db "srC"  
087f f1			.pastdmark: pop af  
0880			endm  
# End of macro DMARK
0880					CALLMONITOR 
0880 cd 6f ee			call debug_vector  
0883				endm  
# End of macro CALLMONITOR
0883				endif 
0883				; only short reads enabled 
0883			 
0883 3a 6c ea			ld a, (store_longread) 
0886 fe 00			cp 0 
0888 ca 55 09			jp z, .readdone 
088b			 
088b			; TODO if block has no zeros then need to read next block  
088b			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
088b			; check last byte of physical block. 
088b			; if not zero then the next block needs to be loaded 
088b			 
088b			 
088b 2a 6d ea			ld hl, (store_readbuf)     ; current buffer to load in to 
088e			 
088e 3e 3f			ld a, STORE_BLOCK_PHY-1 
0890 cd f5 0d			call addatohl 
0893				;dec hl 
0893 7e				ld a,(hl) 
0894				if DEBUG_STORESE 
0894					DMARK "sr?" 
0894 f5				push af  
0895 3a a9 08			ld a, (.dmark)  
0898 32 62 ee			ld (debug_mark),a  
089b 3a aa 08			ld a, (.dmark+1)  
089e 32 63 ee			ld (debug_mark+1),a  
08a1 3a ab 08			ld a, (.dmark+2)  
08a4 32 64 ee			ld (debug_mark+2),a  
08a7 18 03			jr .pastdmark  
08a9 ..			.dmark: db "sr?"  
08ac f1			.pastdmark: pop af  
08ad			endm  
# End of macro DMARK
08ad					CALLMONITOR 
08ad cd 6f ee			call debug_vector  
08b0				endm  
# End of macro CALLMONITOR
08b0				endif 
08b0 fe 00			cp 0 
08b2 ca 55 09			jp z, .readdone 
08b5			 
08b5				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08b5			 
08b5 23				inc hl 
08b6			 
08b6 22 6d ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08b9			 
08b9 ed 5b 6f ea		ld de, (store_readptr)     ; save the current extent to load 
08bd			 
08bd eb				ex de, hl 
08be			 
08be				; next ext 
08be			 
08be 23				inc hl 
08bf 22 6f ea			ld  (store_readptr), hl     ; save the current extent to load 
08c2			 
08c2				if DEBUG_STORESE 
08c2					DMARK "sF2" 
08c2 f5				push af  
08c3 3a d7 08			ld a, (.dmark)  
08c6 32 62 ee			ld (debug_mark),a  
08c9 3a d8 08			ld a, (.dmark+1)  
08cc 32 63 ee			ld (debug_mark+1),a  
08cf 3a d9 08			ld a, (.dmark+2)  
08d2 32 64 ee			ld (debug_mark+2),a  
08d5 18 03			jr .pastdmark  
08d7 ..			.dmark: db "sF2"  
08da f1			.pastdmark: pop af  
08db			endm  
# End of macro DMARK
08db					CALLMONITOR 
08db cd 6f ee			call debug_vector  
08de				endm  
# End of macro CALLMONITOR
08de				endif 
08de			 
08de				; get and load block 
08de			 
08de cd ba 05			call storage_findnextid 
08e1			 
08e1				if DEBUG_STORESE 
08e1					DMARK "sf2" 
08e1 f5				push af  
08e2 3a f6 08			ld a, (.dmark)  
08e5 32 62 ee			ld (debug_mark),a  
08e8 3a f7 08			ld a, (.dmark+1)  
08eb 32 63 ee			ld (debug_mark+1),a  
08ee 3a f8 08			ld a, (.dmark+2)  
08f1 32 64 ee			ld (debug_mark+2),a  
08f4 18 03			jr .pastdmark  
08f6 ..			.dmark: db "sf2"  
08f9 f1			.pastdmark: pop af  
08fa			endm  
# End of macro DMARK
08fa					CALLMONITOR 
08fa cd 6f ee			call debug_vector  
08fd				endm  
# End of macro CALLMONITOR
08fd				endif 
08fd cd 1e 0e			call ishlzero 
0900			;	ld a, l 
0900			;	add h 
0900			;	cp 0 
0900 ca de 07			jp z,.sr_fail			; block not found so EOF 
0903				 
0903				; save current address for use by higher level words etc 
0903			 
0903 22 62 ea			ld (store_openaddr),hl 
0906			 
0906 cd 87 02			call storage_read_block 
0909			 
0909				; on a continuation block, we now have the file id and ext in the middle of the block 
0909				; we need to pull everything back  
0909			 
0909 ed 5b 6d ea		ld de, (store_readbuf)     ; current buffer to nudge into 
090d 2a 6d ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0910 23				inc hl 
0911 23				inc hl     ; skip id and ext 
0912 01 40 00			ld bc, STORE_BLOCK_PHY 
0915				if DEBUG_STORESE 
0915					DMARK "SR<" 
0915 f5				push af  
0916 3a 2a 09			ld a, (.dmark)  
0919 32 62 ee			ld (debug_mark),a  
091c 3a 2b 09			ld a, (.dmark+1)  
091f 32 63 ee			ld (debug_mark+1),a  
0922 3a 2c 09			ld a, (.dmark+2)  
0925 32 64 ee			ld (debug_mark+2),a  
0928 18 03			jr .pastdmark  
092a ..			.dmark: db "SR<"  
092d f1			.pastdmark: pop af  
092e			endm  
# End of macro DMARK
092e					CALLMONITOR 
092e cd 6f ee			call debug_vector  
0931				endm  
# End of macro CALLMONITOR
0931				endif 
0931 ed b0			ldir     ; copy data 
0933			 
0933				; move the pointer back and pretend we have a full buffer for next recheck 
0933			 
0933 1b				dec de 
0934 1b				dec de 
0935			 
0935			; TODO do pop below now short circuit loop????? 
0935 c1				pop bc     ; get rid of spare de on stack 
0936				if DEBUG_STORESE 
0936					DMARK "SR>" 
0936 f5				push af  
0937 3a 4b 09			ld a, (.dmark)  
093a 32 62 ee			ld (debug_mark),a  
093d 3a 4c 09			ld a, (.dmark+1)  
0940 32 63 ee			ld (debug_mark+1),a  
0943 3a 4d 09			ld a, (.dmark+2)  
0946 32 64 ee			ld (debug_mark+2),a  
0949 18 03			jr .pastdmark  
094b ..			.dmark: db "SR>"  
094e f1			.pastdmark: pop af  
094f			endm  
# End of macro DMARK
094f					CALLMONITOR 
094f cd 6f ee			call debug_vector  
0952				endm  
# End of macro CALLMONITOR
0952				endif 
0952 c3 e3 07			jp .srext 
0955			 
0955			 
0955			 
0955			 
0955			 
0955			.readdone:		 
0955 e1				pop hl 		 ; return start of data to show as not EOF 
0956 23				inc hl   ; past file id 
0957 23				inc hl   ; past ext 
0958				if DEBUG_STORESE 
0958					DMARK "SRe" 
0958 f5				push af  
0959 3a 6d 09			ld a, (.dmark)  
095c 32 62 ee			ld (debug_mark),a  
095f 3a 6e 09			ld a, (.dmark+1)  
0962 32 63 ee			ld (debug_mark+1),a  
0965 3a 6f 09			ld a, (.dmark+2)  
0968 32 64 ee			ld (debug_mark+2),a  
096b 18 03			jr .pastdmark  
096d ..			.dmark: db "SRe"  
0970 f1			.pastdmark: pop af  
0971			endm  
# End of macro DMARK
0971					CALLMONITOR 
0971 cd 6f ee			call debug_vector  
0974				endm  
# End of macro CALLMONITOR
0974				endif 
0974 c9					ret 
0975			 
0975			 
0975			 
0975			; 
0975			; Append File 
0975			; 
0975			; hl - file id to locate 
0975			; de - pointer to (multi block) string to write 
0975			 
0975			.sa_notfound: 
0975 d1				pop de 
0976 c9				ret 
0977			 
0977			 
0977			storage_append: 
0977				; hl -  file id to append to 
0977				; de - string to append 
0977			 
0977 d5				push de 
0978				 
0978				if DEBUG_STORESE 
0978					DMARK "AP1" 
0978 f5				push af  
0979 3a 8d 09			ld a, (.dmark)  
097c 32 62 ee			ld (debug_mark),a  
097f 3a 8e 09			ld a, (.dmark+1)  
0982 32 63 ee			ld (debug_mark+1),a  
0985 3a 8f 09			ld a, (.dmark+2)  
0988 32 64 ee			ld (debug_mark+2),a  
098b 18 03			jr .pastdmark  
098d ..			.dmark: db "AP1"  
0990 f1			.pastdmark: pop af  
0991			endm  
# End of macro DMARK
0991					CALLMONITOR 
0991 cd 6f ee			call debug_vector  
0994				endm  
# End of macro CALLMONITOR
0994				endif 
0994			 
0994 7d				ld a, l 
0995 32 65 ea			ld (store_tmpid), a 
0998			 
0998				; get file header  
0998			 
0998 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
099a 3a 65 ea			ld a, (store_tmpid) 
099d 5f				ld e, a 
099e			 
099e 21 40 00				ld hl, STORE_BLOCK_PHY 
09a1 cd ba 05				call storage_findnextid 
09a4			 
09a4 cd 1e 0e			call ishlzero 
09a7 28 cc			jr z, .sa_notfound 
09a9			 
09a9 22 5c ea			ld (store_tmppageid), hl 
09ac			 
09ac				; TODO handle file id not found 
09ac			 
09ac				if DEBUG_STORESE 
09ac					DMARK "AP2" 
09ac f5				push af  
09ad 3a c1 09			ld a, (.dmark)  
09b0 32 62 ee			ld (debug_mark),a  
09b3 3a c2 09			ld a, (.dmark+1)  
09b6 32 63 ee			ld (debug_mark+1),a  
09b9 3a c3 09			ld a, (.dmark+2)  
09bc 32 64 ee			ld (debug_mark+2),a  
09bf 18 03			jr .pastdmark  
09c1 ..			.dmark: db "AP2"  
09c4 f1			.pastdmark: pop af  
09c5			endm  
# End of macro DMARK
09c5					CALLMONITOR 
09c5 cd 6f ee			call debug_vector  
09c8				endm  
# End of macro CALLMONITOR
09c8				endif 
09c8			 
09c8				; update file extent count 
09c8			 
09c8 11 71 ea			ld de, store_page 
09cb			 
09cb cd 87 02			call storage_read_block 
09ce			 
09ce				if DEBUG_STORESE 
09ce					DMARK "AP3" 
09ce f5				push af  
09cf 3a e3 09			ld a, (.dmark)  
09d2 32 62 ee			ld (debug_mark),a  
09d5 3a e4 09			ld a, (.dmark+1)  
09d8 32 63 ee			ld (debug_mark+1),a  
09db 3a e5 09			ld a, (.dmark+2)  
09de 32 64 ee			ld (debug_mark+2),a  
09e1 18 03			jr .pastdmark  
09e3 ..			.dmark: db "AP3"  
09e6 f1			.pastdmark: pop af  
09e7			endm  
# End of macro DMARK
09e7					CALLMONITOR 
09e7 cd 6f ee			call debug_vector  
09ea				endm  
# End of macro CALLMONITOR
09ea				endif 
09ea			;	ld (store_tmppageid), hl 
09ea			 
09ea 3a 73 ea			ld a, (store_page+2) 
09ed 3c				inc a 
09ee 32 73 ea			ld (store_page+2), a 
09f1 32 64 ea			ld (store_tmpext), a 
09f4				 
09f4				if DEBUG_STORESE 
09f4					DMARK "AP3" 
09f4 f5				push af  
09f5 3a 09 0a			ld a, (.dmark)  
09f8 32 62 ee			ld (debug_mark),a  
09fb 3a 0a 0a			ld a, (.dmark+1)  
09fe 32 63 ee			ld (debug_mark+1),a  
0a01 3a 0b 0a			ld a, (.dmark+2)  
0a04 32 64 ee			ld (debug_mark+2),a  
0a07 18 03			jr .pastdmark  
0a09 ..			.dmark: db "AP3"  
0a0c f1			.pastdmark: pop af  
0a0d			endm  
# End of macro DMARK
0a0d					CALLMONITOR 
0a0d cd 6f ee			call debug_vector  
0a10				endm  
# End of macro CALLMONITOR
0a10				endif 
0a10 2a 5c ea			ld hl, (store_tmppageid) 
0a13 11 71 ea			ld de, store_page 
0a16 cd ec 02			call storage_write_block 
0a19			 
0a19				; find free block 
0a19			 
0a19 11 00 00			ld de, 0			 ; file extent to locate 
0a1c			 
0a1c 21 40 00				ld hl, STORE_BLOCK_PHY 
0a1f cd ba 05				call storage_findnextid 
0a22 cd 1e 0e			call ishlzero 
0a25 ca 75 09			jp z, .sa_notfound 
0a28			 
0a28					; TODO handle no space left 
0a28					 
0a28 22 5c ea				ld (store_tmppageid), hl 
0a2b			 
0a2b				if DEBUG_STORESE 
0a2b					DMARK "AP4" 
0a2b f5				push af  
0a2c 3a 40 0a			ld a, (.dmark)  
0a2f 32 62 ee			ld (debug_mark),a  
0a32 3a 41 0a			ld a, (.dmark+1)  
0a35 32 63 ee			ld (debug_mark+1),a  
0a38 3a 42 0a			ld a, (.dmark+2)  
0a3b 32 64 ee			ld (debug_mark+2),a  
0a3e 18 03			jr .pastdmark  
0a40 ..			.dmark: db "AP4"  
0a43 f1			.pastdmark: pop af  
0a44			endm  
# End of macro DMARK
0a44					CALLMONITOR 
0a44 cd 6f ee			call debug_vector  
0a47				endm  
# End of macro CALLMONITOR
0a47				endif 
0a47					; init the buffer with zeros so we can id if the buffer is full or not 
0a47			 
0a47 e5					push hl 
0a48 c5					push bc 
0a49			 
0a49 21 71 ea				ld hl, store_page 
0a4c 06 40				ld b, STORE_BLOCK_PHY 
0a4e 3e 00				ld a, 0 
0a50 77			.zeroblock:	ld (hl), a 
0a51 23					inc hl 
0a52 10 fc				djnz .zeroblock 
0a54			 
0a54 c1					pop bc 
0a55 e1					pop hl 
0a56			 
0a56					; construct block 
0a56			 
0a56 3a 65 ea				ld a, (store_tmpid) 
0a59 32 71 ea				ld (store_page), a   ; file id 
0a5c 3a 64 ea				ld a, (store_tmpext)   ; extent for this block 
0a5f 32 72 ea				ld (store_page+1), a 
0a62			 
0a62 e1					pop hl    ; get string to write 
0a63 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a65 11 73 ea				ld de, store_page+2 
0a68			 
0a68				if DEBUG_STORESE 
0a68					DMARK "AP5" 
0a68 f5				push af  
0a69 3a 7d 0a			ld a, (.dmark)  
0a6c 32 62 ee			ld (debug_mark),a  
0a6f 3a 7e 0a			ld a, (.dmark+1)  
0a72 32 63 ee			ld (debug_mark+1),a  
0a75 3a 7f 0a			ld a, (.dmark+2)  
0a78 32 64 ee			ld (debug_mark+2),a  
0a7b 18 03			jr .pastdmark  
0a7d ..			.dmark: db "AP5"  
0a80 f1			.pastdmark: pop af  
0a81			endm  
# End of macro DMARK
0a81					CALLMONITOR 
0a81 cd 6f ee			call debug_vector  
0a84				endm  
# End of macro CALLMONITOR
0a84				endif 
0a84			 
0a84			 
0a84			 
0a84					; fill buffer with data until end of string or full block 
0a84			 
0a84 7e			.appd:		ld a, (hl) 
0a85 12					ld (de), a 
0a86 fe 00				cp 0 
0a88 28 04				jr z, .appdone 
0a8a 23					inc hl 
0a8b 13					inc de 
0a8c 10 f6				djnz .appd 
0a8e			 
0a8e e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a8f f5					push af   		; save last byte dumped 
0a90			 
0a90			 
0a90 2a 5c ea			ld hl, (store_tmppageid) 
0a93 11 71 ea			ld de, store_page 
0a96				if DEBUG_STORESE 
0a96					DMARK "AP6" 
0a96 f5				push af  
0a97 3a ab 0a			ld a, (.dmark)  
0a9a 32 62 ee			ld (debug_mark),a  
0a9d 3a ac 0a			ld a, (.dmark+1)  
0aa0 32 63 ee			ld (debug_mark+1),a  
0aa3 3a ad 0a			ld a, (.dmark+2)  
0aa6 32 64 ee			ld (debug_mark+2),a  
0aa9 18 03			jr .pastdmark  
0aab ..			.dmark: db "AP6"  
0aae f1			.pastdmark: pop af  
0aaf			endm  
# End of macro DMARK
0aaf					CALLMONITOR 
0aaf cd 6f ee			call debug_vector  
0ab2				endm  
# End of macro CALLMONITOR
0ab2				endif 
0ab2 cd ec 02				call storage_write_block 
0ab5			 
0ab5			 
0ab5				; was that a full block of data written? 
0ab5				; any more to write out? 
0ab5			 
0ab5				; if yes then set vars and jump to start of function again 
0ab5			 
0ab5 f1					pop af 
0ab6 d1					pop de 
0ab7			 
0ab7 fe 00				cp 0		 ; no, string was fully written 
0ab9 c8					ret z 
0aba			 
0aba					; setup vars for next cycle 
0aba			 
0aba 3a 65 ea				ld a, (store_tmpid) 
0abd 6f					ld l, a 
0abe 26 00				ld h, 0 
0ac0			 
0ac0 c3 77 09			 	jp storage_append	 ; yes, need to write out some more 
0ac3			 
0ac3			 
0ac3			 
0ac3			 
0ac3			 
0ac3			 
0ac3			 
0ac3			if DEBUG_STORECF 
0ac3			storageput:	 
0ac3					ret 
0ac3			storageread: 
0ac3					ld hl, store_page 
0ac3					ld b, 200 
0ac3					ld a,0 
0ac3			.src:		ld (hl),a 
0ac3					inc hl 
0ac3					djnz .src 
0ac3					 
0ac3			 
0ac3					ld de, 0 
0ac3					ld bc, 1 
0ac3					ld hl, store_page 
0ac3					call cfRead 
0ac3			 
0ac3				call cfGetError 
0ac3				ld hl,scratch 
0ac3				call hexout 
0ac3				ld hl, scratch+2 
0ac3				ld a, 0 
0ac3				ld (hl),a 
0ac3				ld de, scratch 
0ac3				ld a,display_row_1 
0ac3				call str_at_display 
0ac3				call update_display 
0ac3			 
0ac3					ld hl, store_page 
0ac3					ld (os_cur_ptr),hl 
0ac3			 
0ac3					ret 
0ac3			endif 
0ac3			 
0ac3			 
0ac3			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ac3			 
0ac3			storage_clear_page: 
0ac3 e5				push hl 
0ac4 d5				push de 
0ac5 c5				push bc 
0ac6 21 71 ea			ld hl, store_page 
0ac9 3e 00			ld a, 0 
0acb 77				ld (hl), a 
0acc			 
0acc 11 72 ea			ld de, store_page+1 
0acf 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ad2			 
0ad2 ed b0			ldir 
0ad4				 
0ad4 c1				pop bc 
0ad5 d1				pop de 
0ad6 e1				pop hl 
0ad7 c9				ret 
0ad8			 
0ad8			; eof 
# End of file firmware_storage.asm
0ad8			  
0ad8			; support routines for above hardware abstraction layer  
0ad8			  
0ad8			include "firmware_general.asm"        ; general support functions  
0ad8			 
0ad8			; word look up 
0ad8			 
0ad8			; in 
0ad8			; a is the index 
0ad8			; hl is pointer start of array 
0ad8			; 
0ad8			; returns 
0ad8			; hl to the word 
0ad8			; 
0ad8			 
0ad8			table_lookup:  
0ad8 d5					push de 
0ad9 eb					ex de, hl 
0ada			 
0ada 6f					ld l, a 
0adb 26 00				ld h, 0 
0add 29					add hl, hl 
0ade 19					add hl, de 
0adf 7e					ld a, (hl) 
0ae0 23					inc hl 
0ae1 66					ld h,(hl) 
0ae2 6f					ld l, a 
0ae3			 
0ae3 d1					pop de 
0ae4 c9					ret 
0ae5			 
0ae5			; Delay loops 
0ae5			 
0ae5			 
0ae5			 
0ae5			aDelayInMS: 
0ae5 c5				push bc 
0ae6 47				ld b,a 
0ae7			msdelay: 
0ae7 c5				push bc 
0ae8				 
0ae8			 
0ae8 01 41 00			ld bc,041h 
0aeb cd 03 0b			call delayloop 
0aee c1				pop bc 
0aef 05				dec b 
0af0 20 f5			jr nz,msdelay 
0af2			 
0af2			;if CPU_CLOCK_8MHZ 
0af2			;msdelay8: 
0af2			;	push bc 
0af2			;	 
0af2			; 
0af2			;	ld bc,041h 
0af2			;	call delayloop 
0af2			;	pop bc 
0af2			;	dec b 
0af2			;	jr nz,msdelay8 
0af2			;endif 
0af2			 
0af2			 
0af2 c1				pop bc 
0af3 c9				ret 
0af4			 
0af4			 
0af4			delay250ms: 
0af4				;push de 
0af4 01 00 40			ld bc, 04000h 
0af7 c3 03 0b			jp delayloop 
0afa			delay500ms: 
0afa				;push de 
0afa 01 00 80			ld bc, 08000h 
0afd c3 03 0b			jp delayloop 
0b00			delay1s: 
0b00				;push bc 
0b00			   ; Clobbers A, d and e 
0b00 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0b03			delayloop: 
0b03 c5			    push bc 
0b04			 
0b04			if BASE_CPM 
0b04 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0b07			.cpmloop: 
0b07 c5				push bc 
0b08			 
0b08			endif 
0b08			 
0b08			 
0b08			 
0b08			delayloopi: 
0b08			;	push bc 
0b08			;.dl: 
0b08 cb 47		    bit     0,a    	; 8 
0b0a cb 47		    bit     0,a    	; 8 
0b0c cb 47		    bit     0,a    	; 8 
0b0e e6 ff		    and     255  	; 7 
0b10 0b			    dec     bc      	; 6 
0b11 79			    ld      a,c     	; 4 
0b12 b0			    or      b     	; 4 
0b13 c2 08 0b		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b16			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b16				;pop de 
0b16			;pop bc 
0b16			 
0b16			if BASE_CPM 
0b16 c1				pop bc 
0b17				 
0b17 0b			    dec     bc      	; 6 
0b18 79			    ld      a,c     	; 4 
0b19 b0			    or      b     	; 4 
0b1a c2 07 0b		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b1d				 
0b1d			 
0b1d			endif 
0b1d			;if CPU_CLOCK_8MHZ 
0b1d			;    pop bc 
0b1d			;    push bc 
0b1d			;.dl8: 
0b1d			;    bit     0,a    	; 8 
0b1d			;    bit     0,a    	; 8 
0b1d			;    bit     0,a    	; 8 
0b1d			;    and     255  	; 7 
0b1d			;    dec     bc      	; 6 
0b1d			;    ld      a,c     	; 4 
0b1d			;    or      b     	; 4 
0b1d			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b1d			;endif 
0b1d			 
0b1d			;if CPU_CLOCK_10MHZ 
0b1d			;    pop bc 
0b1d			;    push bc 
0b1d			;.dl8: 
0b1d			;    bit     0,a    	; 8 
0b1d			;    bit     0,a    	; 8 
0b1d			;    bit     0,a    	; 8 
0b1d			;    and     255  	; 7 
0b1d			;    dec     bc      	; 6 
0b1d			;    ld      a,c     	; 4 
0b1d			;    or      b     	; 4 
0b1d			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b1d			;endif 
0b1d c1			    pop bc 
0b1e			 
0b1e c9				ret 
0b1f			 
0b1f			 
0b1f			 
0b1f			; eof 
# End of file firmware_general.asm
0b1f			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b1f			; display routines that use the physical hardware abstraction layer 
0b1f			 
0b1f			 
0b1f			; Display an activity indicator 
0b1f			; Each call returns the new char pointed to in hl 
0b1f			 
0b1f			active: 
0b1f 3a bd eb			ld a, (display_active) 
0b22 fe 06			cp 6 
0b24			 
0b24 20 02			jr nz, .sne 
0b26				; gone past the last one reset sequence 
0b26 3e ff			ld a, 255 
0b28			 
0b28			.sne:   
0b28				; get the next char in seq 
0b28 3c				inc a 
0b29 32 bd eb			ld (display_active), a 
0b2c			 
0b2c				; look up the string in the table 
0b2c 21 43 0b			ld hl, actseq 
0b2f cb 27			sla a 
0b31 cd f5 0d			call addatohl 
0b34 cd 72 1e			call loadwordinhl 
0b37			 
0b37				; forth will write the to string when pushing so move from rom to ram 
0b37			 
0b37 11 be eb			ld de, display_active+1 
0b3a 01 02 00			ld bc, 2 
0b3d ed b0			ldir 
0b3f			 
0b3f 21 be eb			ld hl, display_active+1 
0b42 c9				ret 
0b43				 
0b43				 
0b43			 
0b43			 
0b43			;db "|/-\|-\" 
0b43			 
0b43			actseq: 
0b43			 
0b43 51 0b		dw spin0 
0b45 53 0b		dw spin1 
0b47 55 0b		dw spin2 
0b49 57 0b		dw spin3 
0b4b 55 0b		dw spin2 
0b4d 53 0b		dw spin1 
0b4f 51 0b		dw spin0 
0b51			 
0b51 .. 00		spin0: db " ", 0 
0b53 .. 00		spin1: db "-", 0 
0b55 .. 00		spin2: db "+", 0 
0b57 .. 00		spin3: db "#", 0 
0b59			 
0b59			 
0b59			; information window 
0b59			 
0b59			; pass hl with 1st string to display 
0b59			; pass de with 2nd string to display 
0b59			 
0b59			info_panel: 
0b59 e5				push hl 
0b5a			 
0b5a 2a c3 eb			ld hl, (display_fb_active) 
0b5d e5				push hl    ; future de destination 
0b5e 21 a8 ed				ld hl, display_fb0 
0b61 22 c3 eb				ld (display_fb_active), hl 
0b64			 
0b64			;	call clear_display 
0b64			 
0b64				if BASE_CPM 
0b64 3e 2e			ld a, '.' 
0b66				else 
0b66				ld a, 165 
0b66				endif 
0b66 cd cd 0b			call fill_display 
0b69			 
0b69			 
0b69 3e 55			ld a, display_row_3 + 5 
0b6b cd db 0b			call str_at_display 
0b6e			 
0b6e e1				pop hl 
0b6f d1				pop de 
0b70			 
0b70 e5				push hl 
0b71			 
0b71			 
0b71 3e 2d			ld a, display_row_2 + 5 
0b73 cd db 0b			call str_at_display 
0b76			 
0b76			 
0b76 cd eb 0b			call update_display 
0b79 cd 78 1a			call next_page_prompt 
0b7c cd c8 0b			call clear_display 
0b7f			 
0b7f				 
0b7f 21 07 ed				ld hl, display_fb1 
0b82 22 c3 eb				ld (display_fb_active), hl 
0b85 cd eb 0b			call update_display 
0b88			 
0b88 e1				pop hl 
0b89			 
0b89 c9				ret 
0b8a			 
0b8a			 
0b8a			 
0b8a			 
0b8a			; TODO windowing? 
0b8a			 
0b8a			; TODO scroll line up 
0b8a			 
0b8a			scroll_up: 
0b8a			 
0b8a e5				push hl 
0b8b d5				push de 
0b8c c5				push bc 
0b8d			 
0b8d				; get frame buffer  
0b8d			 
0b8d 2a c3 eb			ld hl, (display_fb_active) 
0b90 e5				push hl    ; future de destination 
0b91			 
0b91 11 28 00			ld  de, display_cols 
0b94 19				add hl, de 
0b95			 
0b95 d1				pop de 
0b96			 
0b96				;ex de, hl 
0b96 01 9f 00			ld bc, display_fb_len -1  
0b99			;if DEBUG_FORTH_WORDS 
0b99			;	DMARK "SCL" 
0b99			;	CALLMONITOR 
0b99			;endif	 
0b99 ed b0			ldir 
0b9b			 
0b9b				; wipe bottom row 
0b9b			 
0b9b			 
0b9b 2a c3 eb			ld hl, (display_fb_active) 
0b9e 11 a0 00			ld de, display_cols*display_rows 
0ba1 19				add hl, de 
0ba2 06 28			ld b, display_cols 
0ba4 3e 20			ld a, ' ' 
0ba6			.scwipe: 
0ba6 77				ld (hl), a 
0ba7 2b				dec hl 
0ba8 10 fc			djnz .scwipe 
0baa			 
0baa				;pop hl 
0baa			 
0baa c1				pop bc 
0bab d1				pop de 
0bac e1				pop hl 
0bad			 
0bad c9				ret 
0bae			 
0bae			 
0bae			;scroll_upo: 
0bae			;	ld de, display_row_1 
0bae			 ;	ld hl, display_row_2 
0bae			;	ld bc, display_cols 
0bae			;	ldir 
0bae			;	ld de, display_row_2 
0bae			 ;	ld hl, display_row_3 
0bae			;	ld bc, display_cols 
0bae			;	ldir 
0bae			;	ld de, display_row_3 
0bae			 ;	ld hl, display_row_4 
0bae			;	ld bc, display_cols 
0bae			;	ldir 
0bae			 
0bae			; TODO clear row 4 
0bae			 
0bae			;	ret 
0bae			 
0bae				 
0bae			scroll_down: 
0bae			 
0bae e5				push hl 
0baf d5				push de 
0bb0 c5				push bc 
0bb1			 
0bb1				; get frame buffer  
0bb1			 
0bb1 2a c3 eb			ld hl, (display_fb_active) 
0bb4			 
0bb4 11 9f 00			ld de, display_fb_len - 1 
0bb7 19				add hl, de 
0bb8			 
0bb8 e5			push hl    ; future de destination 
0bb9			 
0bb9 11 28 00			ld  de, display_cols 
0bbc ed 52			sbc hl, de 
0bbe			 
0bbe			 
0bbe d1				pop de 
0bbf			 
0bbf			;	ex de, hl 
0bbf 01 9f 00			ld bc, display_fb_len -1  
0bc2			 
0bc2			 
0bc2				 
0bc2			 
0bc2 ed b0			ldir 
0bc4			 
0bc4				; wipe bottom row 
0bc4			 
0bc4			 
0bc4			;	ld hl, (display_fb_active) 
0bc4			;;	ld de, display_cols*display_rows 
0bc4			;;	add hl, de 
0bc4			;	ld b, display_cols 
0bc4			;	ld a, ' ' 
0bc4			;.scwiped: 
0bc4			;	ld (hl), a 
0bc4			;	dec hl 
0bc4			;	djnz .scwiped 
0bc4			 
0bc4				;pop hl 
0bc4			 
0bc4 c1				pop bc 
0bc5 d1				pop de 
0bc6 e1				pop hl 
0bc7			 
0bc7 c9				ret 
0bc8			;scroll_down: 
0bc8			;	ld de, display_row_4 
0bc8			;	ld hl, display_row_3 
0bc8			;	ld bc, display_cols 
0bc8			;	ldir 
0bc8			;	ld de, display_row_3 
0bc8			; 	ld hl, display_row_2 
0bc8			;	ld bc, display_cols 
0bc8			;	ldir 
0bc8			;	ld de, display_row_2 
0bc8			;	ld hl, display_row_1 
0bc8			;	ld bc, display_cols 
0bc8			;	ldir 
0bc8			;;; TODO clear row 1 
0bc8			;	ret 
0bc8			 
0bc8			 
0bc8			 
0bc8			 
0bc8			 
0bc8			; clear active frame buffer 
0bc8			 
0bc8			clear_display: 
0bc8 3e 20			ld a, ' ' 
0bca c3 cd 0b			jp fill_display 
0bcd			 
0bcd			; fill active frame buffer with a char in A 
0bcd			 
0bcd			fill_display: 
0bcd 06 a0			ld b,display_fb_len 
0bcf 2a c3 eb			ld hl, (display_fb_active) 
0bd2 77			.fd1:	ld (hl),a 
0bd3 23				inc hl 
0bd4 10 fc			djnz .fd1 
0bd6 23				inc hl 
0bd7 3e 00			ld a,0 
0bd9 77				ld (hl),a 
0bda			 
0bda			 
0bda c9				ret 
0bdb			; Write string (DE) at pos (A) to active frame buffer 
0bdb			 
0bdb 2a c3 eb		str_at_display:    ld hl,(display_fb_active) 
0bde 06 00					ld b,0 
0be0 4f					ld c,a 
0be1 09					add hl,bc 
0be2 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0be3 b7			            OR   A              ;Null terminator? 
0be4 c8			            RET  Z              ;Yes, so finished 
0be5 77					ld (hl),a 
0be6 23				inc hl 
0be7 13			            INC  DE             ;Point to next character 
0be8 18 f8		            JR   .sad1     ;Repeat 
0bea c9					ret 
0beb			 
0beb			; using current frame buffer write to physical display 
0beb			 
0beb			update_display: 
0beb e5				push hl 
0bec 2a c3 eb			ld hl, (display_fb_active) 
0bef cd 80 64			call write_display 
0bf2 e1				pop hl 
0bf3 c9				ret 
0bf4			 
0bf4			; TODO scrolling 
0bf4			 
0bf4			 
0bf4			; move cursor right one char 
0bf4			cursor_right: 
0bf4			 
0bf4				; TODO shift right 
0bf4				; TODO if beyond max col 
0bf4				; TODO       cursor_next_line 
0bf4			 
0bf4 c9				ret 
0bf5			 
0bf5			 
0bf5			cursor_next_line: 
0bf5				; TODO first char 
0bf5				; TODO line down 
0bf5				; TODO if past last row 
0bf5				; TODO    scroll up 
0bf5			 
0bf5 c9				ret 
0bf6			 
0bf6			cursor_left: 
0bf6				; TODO shift left 
0bf6				; TODO if beyond left  
0bf6				; TODO     cursor prev line 
0bf6				 
0bf6 c9				ret 
0bf7			 
0bf7			cursor_prev_line: 
0bf7				; TODO last char 
0bf7				; TODO line up 
0bf7				; TODO if past first row 
0bf7				; TODO   scroll down 
0bf7			 
0bf7 c9				ret 
0bf8			 
0bf8			 
0bf8			cout: 
0bf8				; A - char 
0bf8 c9				ret 
0bf9			 
0bf9			 
0bf9			; Display a menu and allow item selection (optional toggle items) 
0bf9			; 
0bf9			; format: 
0bf9			; hl pointer to word array with zero term for items 
0bf9			; e.g.    db item1 
0bf9			;         db .... 
0bf9			;         db 0 
0bf9			; 
0bf9			; a = starting menu item  
0bf9			; 
0bf9			; de = pointer item toggle array   (todo) 
0bf9			; 
0bf9			; returns item selected in a 1-... 
0bf9			; returns 0 if back button pressed 
0bf9			; 
0bf9			; NOTE: Uses system frame buffer to display 
0bf9			; 
0bf9			; LEFT, Q = go back 
0bf9			; RIGHT, SPACE, CR = select 
0bf9			; UP, A - Up 
0bf9			; DOWN, Z - Down 
0bf9			 
0bf9			 
0bf9			 
0bf9			 
0bf9			 
0bf9			menu: 
0bf9			 
0bf9					; keep array pointer 
0bf9			 
0bf9 22 6a ea				ld (store_tmp1), hl 
0bfc 32 68 ea				ld (store_tmp2), a 
0bff			 
0bff					; check for key bounce 
0bff			 
0bff			if BASE_KEV 
0bff			 
0bff			.mbounce:	call cin 
0bff					cp 0 
0bff					jr nz, .mbounce 
0bff			endif 
0bff					; for ease use ex 
0bff			 
0bff					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bff 21 a8 ed				ld hl, display_fb0 
0c02 22 c3 eb				ld (display_fb_active), hl 
0c05			 
0c05 cd c8 0b		.mloop:		call clear_display 
0c08 cd eb 0b				call update_display 
0c0b			 
0c0b					; draw selection id '>' at 1 
0c0b			 
0c0b					; init start of list display 
0c0b			 
0c0b 3e 05				ld a, 5 
0c0d 32 66 ea				ld (store_tmp3), a   ; display row count 
0c10 3a 68 ea				ld a,( store_tmp2) 
0c13 32 69 ea				ld (store_tmp2+1), a   ; display item count 
0c16			 
0c16					 
0c16			.mitem:	 
0c16			 
0c16			 
0c16 3a 69 ea				ld a,(store_tmp2+1) 
0c19 6f					ld l, a 
0c1a 26 00				ld h, 0 
0c1c 29					add hl, hl 
0c1d ed 5b 6a ea			ld de, (store_tmp1) 
0c21 19					add hl, de 
0c22 7e					ld a, (hl) 
0c23 23					inc hl 
0c24 66					ld h,(hl) 
0c25 6f					ld l, a 
0c26			 
0c26 cd 1e 0e				call ishlzero 
0c29 28 1a				jr z, .mdone 
0c2b			 
0c2b eb					ex de, hl 
0c2c 3a 66 ea				ld a, (store_tmp3) 
0c2f cd db 0b				call str_at_display 
0c32					 
0c32			 
0c32					; next item 
0c32 3a 69 ea				ld a, (store_tmp2+1) 
0c35 3c					inc a 
0c36 32 69 ea				ld (store_tmp2+1), a   ; display item count 
0c39			 
0c39			 		; next row 
0c39			 
0c39 3a 66 ea				ld a, (store_tmp3) 
0c3c c6 28				add display_cols 
0c3e 32 66 ea				ld (store_tmp3), a 
0c41			 
0c41					; at end of screen? 
0c41			 
0c41 fe 10				cp display_rows*4 
0c43 20 d1				jr nz, .mitem 
0c45			 
0c45			 
0c45			.mdone: 
0c45 cd 1e 0e				call ishlzero 
0c48 28 08				jr z, .nodn 
0c4a			 
0c4a 3e 78				ld a, display_row_4 
0c4c 11 cb 0c				ld de, .mdown 
0c4f cd db 0b				call str_at_display 
0c52			 
0c52					; draw options to fill the screens with active item on line 1 
0c52					; if current option is 2 or more then display ^ in top 
0c52			 
0c52 3a 68 ea		.nodn:		ld a, (store_tmp2) 
0c55 fe 00				cp 0 
0c57 28 08				jr z, .noup 
0c59			 
0c59 3e 00				ld a, 0 
0c5b 11 c9 0c				ld de, .mup 
0c5e cd db 0b				call str_at_display 
0c61			 
0c61 3e 02		.noup:		ld a, 2 
0c63 11 c7 0c				ld de, .msel 
0c66 cd db 0b				call str_at_display 
0c69			 
0c69					; if current option + 1 is not null then display V in bottom 
0c69					; get key 
0c69 cd eb 0b				call update_display 
0c6c			 
0c6c			 
0c6c					; handle key 
0c6c			 
0c6c cd 32 65				call cin_wait 
0c6f			 
0c6f fe 05				cp KEY_UP 
0c71 28 2b				jr z, .mgoup 
0c73 fe 61				cp 'a' 
0c75 28 27				jr z, .mgoup 
0c77 fe 0a				cp KEY_DOWN 
0c79 28 32				jr z, .mgod 
0c7b fe 7a				cp 'z' 
0c7d 28 2e				jr z, .mgod 
0c7f fe 20				cp ' ' 
0c81 28 34				jr z, .goend 
0c83 fe 0c				cp KEY_RIGHT 
0c85 28 30				jr z, .goend 
0c87 fe 0d				cp KEY_CR 
0c89 28 2c				jr z, .goend 
0c8b fe 71				cp 'q' 
0c8d 28 0b				jr z, .goback 
0c8f			 
0c8f fe 0b				cp KEY_LEFT 
0c91 28 07				jr z, .goback 
0c93 fe 08				cp KEY_BS 
0c95 28 03				jr z, .goback 
0c97 c3 05 0c				jp .mloop 
0c9a			 
0c9a			.goback: 
0c9a 3e 00			ld a, 0 
0c9c 18 1d			jr .goend2 
0c9e			 
0c9e				; move up one 
0c9e			.mgoup: 
0c9e 3a 68 ea				ld a, (store_tmp2) 
0ca1 fe 00				cp 0 
0ca3 ca 05 0c				jp z, .mloop 
0ca6 3d					dec a 
0ca7 32 68 ea				ld (store_tmp2), a 
0caa c3 05 0c				jp .mloop 
0cad			 
0cad				; move down one 
0cad			.mgod: 
0cad 3a 68 ea				ld a, (store_tmp2) 
0cb0 3c					inc a 
0cb1 32 68 ea				ld (store_tmp2), a 
0cb4 c3 05 0c				jp .mloop 
0cb7			 
0cb7			 
0cb7			.goend: 
0cb7					; get selected item number 
0cb7			 
0cb7 3a 68 ea				ld a, (store_tmp2) 
0cba 3c					inc a 
0cbb			 
0cbb			.goend2: 
0cbb f5					push af 
0cbc			 
0cbc					; restore active fb 
0cbc					; TODO BUG assumes fb1 
0cbc			 
0cbc 21 07 ed				ld hl, display_fb1 
0cbf 22 c3 eb				ld (display_fb_active), hl 
0cc2			 
0cc2					; restore main regs 
0cc2			 
0cc2			 
0cc2 cd eb 0b				call update_display 
0cc5			 
0cc5 f1					pop af 
0cc6			 
0cc6 c9				ret 
0cc7			 
0cc7 .. 00		.msel:   db ">",0 
0cc9 .. 00		.mup:   db "^",0 
0ccb .. 00		.mdown:   db "v",0 
0ccd			 
0ccd			 
0ccd			; eof 
0ccd			 
# End of file firmware_display.asm
0ccd			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ccd			; random number generators 
0ccd			 
0ccd			 
0ccd			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ccd			 
0ccd			 
0ccd			;-----> Generate a random number 
0ccd			; output a=answer 0<=a<=255 
0ccd			; all registers are preserved except: af 
0ccd			random: 
0ccd e5			        push    hl 
0cce d5			        push    de 
0ccf 2a a2 eb		        ld      hl,(randData) 
0cd2 ed 5f		        ld      a,r 
0cd4 57			        ld      d,a 
0cd5 5e			        ld      e,(hl) 
0cd6 19			        add     hl,de 
0cd7 85			        add     a,l 
0cd8 ac			        xor     h 
0cd9 22 a2 eb		        ld      (randData),hl 
0cdc d1			        pop     de 
0cdd e1			        pop     hl 
0cde c9			        ret 
0cdf			 
0cdf			 
0cdf			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cdf			 
0cdf			 
0cdf			 
0cdf			;------LFSR------ 
0cdf			;James Montelongo 
0cdf			;optimized by Spencer Putt 
0cdf			;out: 
0cdf			; a = 8 bit random number 
0cdf			RandLFSR: 
0cdf 21 a8 eb		        ld hl,LFSRSeed+4 
0ce2 5e			        ld e,(hl) 
0ce3 23			        inc hl 
0ce4 56			        ld d,(hl) 
0ce5 23			        inc hl 
0ce6 4e			        ld c,(hl) 
0ce7 23			        inc hl 
0ce8 7e			        ld a,(hl) 
0ce9 47			        ld b,a 
0cea cb 13		        rl e  
0cec cb 12			rl d 
0cee cb 11		        rl c  
0cf0 17				rla 
0cf1 cb 13		        rl e  
0cf3 cb 12			rl d 
0cf5 cb 11		        rl c  
0cf7 17				rla 
0cf8 cb 13		        rl e  
0cfa cb 12			rl d 
0cfc cb 11		        rl c  
0cfe 17				rla 
0cff 67			        ld h,a 
0d00 cb 13		        rl e  
0d02 cb 12			rl d 
0d04 cb 11		        rl c  
0d06 17				rla 
0d07 a8			        xor b 
0d08 cb 13		        rl e  
0d0a cb 12			rl d 
0d0c ac			        xor h 
0d0d a9			        xor c 
0d0e aa			        xor d 
0d0f 21 aa eb		        ld hl,LFSRSeed+6 
0d12 11 ab eb		        ld de,LFSRSeed+7 
0d15 01 07 00		        ld bc,7 
0d18 ed b8		        lddr 
0d1a 12			        ld (de),a 
0d1b c9			        ret 
0d1c			 
0d1c			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d1c			 
0d1c			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d1c			 
0d1c			 
0d1c			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d1c			 
0d1c			prng16: 
0d1c			;Inputs: 
0d1c			;   (seed1) contains a 16-bit seed value 
0d1c			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d1c			;Outputs: 
0d1c			;   HL is the result 
0d1c			;   BC is the result of the LCG, so not that great of quality 
0d1c			;   DE is preserved 
0d1c			;Destroys: 
0d1c			;   AF 
0d1c			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d1c			;160cc 
0d1c			;26 bytes 
0d1c 2a 9c eb		    ld hl,(seed1) 
0d1f 44			    ld b,h 
0d20 4d			    ld c,l 
0d21 29			    add hl,hl 
0d22 29			    add hl,hl 
0d23 2c			    inc l 
0d24 09			    add hl,bc 
0d25 22 9c eb		    ld (seed1),hl 
0d28 2a 9a eb		    ld hl,(seed2) 
0d2b 29			    add hl,hl 
0d2c 9f			    sbc a,a 
0d2d e6 2d		    and %00101101 
0d2f ad			    xor l 
0d30 6f			    ld l,a 
0d31 22 9a eb		    ld (seed2),hl 
0d34 09			    add hl,bc 
0d35 c9			    ret 
0d36			 
0d36			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d36			 
0d36			rand32: 
0d36			;Inputs: 
0d36			;   (seed1_0) holds the lower 16 bits of the first seed 
0d36			;   (seed1_1) holds the upper 16 bits of the first seed 
0d36			;   (seed2_0) holds the lower 16 bits of the second seed 
0d36			;   (seed2_1) holds the upper 16 bits of the second seed 
0d36			;   **NOTE: seed2 must be non-zero 
0d36			;Outputs: 
0d36			;   HL is the result 
0d36			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d36			;Destroys: 
0d36			;   AF 
0d36			;Tested and passes all CAcert tests 
0d36			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d36			;it has a period of 18,446,744,069,414,584,320 
0d36			;roughly 18.4 quintillion. 
0d36			;LFSR taps: 0,2,6,7  = 11000101 
0d36			;291cc 
0d36			;seed1_0=$+1 
0d36			;    ld hl,12345 
0d36			;seed1_1=$+1 
0d36			;    ld de,6789 
0d36			;    ld b,h 
0d36			;    ld c,l 
0d36			;    add hl,hl \ rl e \ rl d 
0d36			;    add hl,hl \ rl e \ rl d 
0d36			;    inc l 
0d36			;    add hl,bc 
0d36			;    ld (seed1_0),hl 
0d36			;    ld hl,(seed1_1) 
0d36			;    adc hl,de 
0d36			;    ld (seed1_1),hl 
0d36			;    ex de,hl 
0d36			;seed2_0=$+1 
0d36			;    ld hl,9876 
0d36			;seed2_1=$+1 
0d36			;    ld bc,54321 
0d36			;    add hl,hl \ rl c \ rl b 
0d36			;    ld (seed2_1),bc 
0d36			;    sbc a,a 
0d36			;    and %11000101 
0d36			;    xor l 
0d36			;    ld l,a 
0d36			;    ld (seed2_0),hl 
0d36			;    ex de,hl 
0d36			;    add hl,bc 
0d36			;    ret 
0d36			; 
0d36			 
0d36			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d36			; 20 bytes, 86 cycles (excluding ret) 
0d36			 
0d36			; returns   hl = pseudorandom number 
0d36			; corrupts   a 
0d36			 
0d36			; generates 16-bit pseudorandom numbers with a period of 65535 
0d36			; using the xorshift method: 
0d36			 
0d36			; hl ^= hl << 7 
0d36			; hl ^= hl >> 9 
0d36			; hl ^= hl << 8 
0d36			 
0d36			; some alternative shift triplets which also perform well are: 
0d36			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d36			 
0d36			;  org 32768 
0d36			 
0d36			xrnd: 
0d36 2a a0 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d39 3e 00		  ld a,0 
0d3b bd			  cp l 
0d3c 20 02		  jr nz, .xrnd1 
0d3e 2e 01		  ld l, 1 
0d40			.xrnd1: 
0d40			 
0d40 7c			  ld a,h 
0d41 1f			  rra 
0d42 7d			  ld a,l 
0d43 1f			  rra 
0d44 ac			  xor h 
0d45 67			  ld h,a 
0d46 7d			  ld a,l 
0d47 1f			  rra 
0d48 7c			  ld a,h 
0d49 1f			  rra 
0d4a ad			  xor l 
0d4b 6f			  ld l,a 
0d4c ac			  xor h 
0d4d 67			  ld h,a 
0d4e			 
0d4e 22 a0 eb		  ld (xrandc),hl 
0d51			 
0d51 c9			  ret 
0d52			;  
0d52			 
0d52			 
0d52			;;;; int maths 
0d52			 
0d52			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d52			; Divide 16-bit values (with 16-bit result) 
0d52			; In: Divide BC by divider DE 
0d52			; Out: BC = result, HL = rest 
0d52			; 
0d52			Div16: 
0d52 21 00 00		    ld hl,0 
0d55 78			    ld a,b 
0d56 06 08		    ld b,8 
0d58			Div16_Loop1: 
0d58 17			    rla 
0d59 ed 6a		    adc hl,hl 
0d5b ed 52		    sbc hl,de 
0d5d 30 01		    jr nc,Div16_NoAdd1 
0d5f 19			    add hl,de 
0d60			Div16_NoAdd1: 
0d60 10 f6		    djnz Div16_Loop1 
0d62 17			    rla 
0d63 2f			    cpl 
0d64 47			    ld b,a 
0d65 79			    ld a,c 
0d66 48			    ld c,b 
0d67 06 08		    ld b,8 
0d69			Div16_Loop2: 
0d69 17			    rla 
0d6a ed 6a		    adc hl,hl 
0d6c ed 52		    sbc hl,de 
0d6e 30 01		    jr nc,Div16_NoAdd2 
0d70 19			    add hl,de 
0d71			Div16_NoAdd2: 
0d71 10 f6		    djnz Div16_Loop2 
0d73 17			    rla 
0d74 2f			    cpl 
0d75 41			    ld b,c 
0d76 4f			    ld c,a 
0d77 c9			ret 
0d78			 
0d78			 
0d78			;http://z80-heaven.wikidot.com/math 
0d78			; 
0d78			;Inputs: 
0d78			;     DE and A are factors 
0d78			;Outputs: 
0d78			;     A is not changed 
0d78			;     B is 0 
0d78			;     C is not changed 
0d78			;     DE is not changed 
0d78			;     HL is the product 
0d78			;Time: 
0d78			;     342+6x 
0d78			; 
0d78			Mult16: 
0d78			 
0d78 06 08		     ld b,8          ;7           7 
0d7a 21 00 00		     ld hl,0         ;10         10 
0d7d 29			       add hl,hl     ;11*8       88 
0d7e 07			       rlca          ;4*8        32 
0d7f 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d81 19			         add hl,de   ;--         -- 
0d82 10 f9		       djnz $-5      ;13*7+8     99 
0d84 c9			ret 
0d85			 
0d85			; 
0d85			; Square root of 16-bit value 
0d85			; In:  HL = value 
0d85			; Out:  D = result (rounded down) 
0d85			; 
0d85			;Sqr16: 
0d85			;    ld de,#0040 
0d85			;    ld a,l 
0d85			;    ld l,h 
0d85			;    ld h,d 
0d85			;    or a 
0d85			;    ld b,8 
0d85			;Sqr16_Loop: 
0d85			;    sbc hl,de 
0d85			;    jr nc,Sqr16_Skip 
0d85			;    add hl,de 
0d85			;Sqr16_Skip: 
0d85			;    ccf 
0d85			;    rl d 
0d85			;    add a,a 
0d85			;    adc hl,hl 
0d85			;    add a,a 
0d85			;    adc hl,hl 
0d85			;    djnz Sqr16_Loop 
0d85			;    ret 
0d85			; 
0d85			; 
0d85			; Divide 8-bit values 
0d85			; In: Divide E by divider C 
0d85			; Out: A = result, B = rest 
0d85			; 
0d85			Div8: 
0d85 af			    xor a 
0d86 06 08		    ld b,8 
0d88			Div8_Loop: 
0d88 cb 13		    rl e 
0d8a 17			    rla 
0d8b 91			    sub c 
0d8c 30 01		    jr nc,Div8_NoAdd 
0d8e 81			    add a,c 
0d8f			Div8_NoAdd: 
0d8f 10 f7		    djnz Div8_Loop 
0d91 47			    ld b,a 
0d92 7b			    ld a,e 
0d93 17			    rla 
0d94 2f			    cpl 
0d95 c9			    ret 
0d96			 
0d96			; 
0d96			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d96			; In: Multiply A with DE 
0d96			; Out: HL = result 
0d96			; 
0d96			Mult12U: 
0d96 2e 00		    ld l,0 
0d98 87			    add a,a 
0d99 30 01		    jr nc,Mult12U_NoAdd0 
0d9b 19			    add hl,de 
0d9c			Mult12U_NoAdd0: 
0d9c 29			    add hl,hl 
0d9d 87			    add a,a 
0d9e 30 01		    jr nc,Mult12U_NoAdd1 
0da0 19			    add hl,de 
0da1			Mult12U_NoAdd1: 
0da1 29			    add hl,hl 
0da2 87			    add a,a 
0da3 30 01		    jr nc,Mult12U_NoAdd2 
0da5 19			    add hl,de 
0da6			Mult12U_NoAdd2: 
0da6 29			    add hl,hl 
0da7 87			    add a,a 
0da8 30 01		    jr nc,Mult12U_NoAdd3 
0daa 19			    add hl,de 
0dab			Mult12U_NoAdd3: 
0dab 29			    add hl,hl 
0dac 87			    add a,a 
0dad 30 01		    jr nc,Mult12U_NoAdd4 
0daf 19			    add hl,de 
0db0			Mult12U_NoAdd4: 
0db0 29			    add hl,hl 
0db1 87			    add a,a 
0db2 30 01		    jr nc,Mult12U_NoAdd5 
0db4 19			    add hl,de 
0db5			Mult12U_NoAdd5: 
0db5 29			    add hl,hl 
0db6 87			    add a,a 
0db7 30 01		    jr nc,Mult12U_NoAdd6 
0db9 19			    add hl,de 
0dba			Mult12U_NoAdd6: 
0dba 29			    add hl,hl 
0dbb 87			    add a,a 
0dbc d0			    ret nc 
0dbd 19			    add hl,de 
0dbe c9			    ret 
0dbf			 
0dbf			; 
0dbf			; Multiply 8-bit value with a 16-bit value (right rotating) 
0dbf			; In: Multiply A with DE 
0dbf			;      Put lowest value in A for most efficient calculation 
0dbf			; Out: HL = result 
0dbf			; 
0dbf			Mult12R: 
0dbf 21 00 00		    ld hl,0 
0dc2			Mult12R_Loop: 
0dc2 cb 3f		    srl a 
0dc4 30 01		    jr nc,Mult12R_NoAdd 
0dc6 19			    add hl,de 
0dc7			Mult12R_NoAdd: 
0dc7 cb 23		    sla e 
0dc9 cb 12		    rl d 
0dcb b7			    or a 
0dcc c2 c2 0d		    jp nz,Mult12R_Loop 
0dcf c9			    ret 
0dd0			 
0dd0			; 
0dd0			; Multiply 16-bit values (with 32-bit result) 
0dd0			; In: Multiply BC with DE 
0dd0			; Out: BCHL = result 
0dd0			; 
0dd0			Mult32: 
0dd0 79			    ld a,c 
0dd1 48			    ld c,b 
0dd2 21 00 00		    ld hl,0 
0dd5 06 10		    ld b,16 
0dd7			Mult32_Loop: 
0dd7 29			    add hl,hl 
0dd8 17			    rla 
0dd9 cb 11		    rl c 
0ddb 30 07		    jr nc,Mult32_NoAdd 
0ddd 19			    add hl,de 
0dde ce 00		    adc a,0 
0de0 d2 e4 0d		    jp nc,Mult32_NoAdd 
0de3 0c			    inc c 
0de4			Mult32_NoAdd: 
0de4 10 f1		    djnz Mult32_Loop 
0de6 41			    ld b,c 
0de7 4f			    ld c,a 
0de8 c9			    ret 
0de9			 
0de9			 
0de9			 
0de9			; 
0de9			; Multiply 8-bit values 
0de9			; In:  Multiply H with E 
0de9			; Out: HL = result 
0de9			; 
0de9			Mult8: 
0de9 16 00		    ld d,0 
0deb 6a			    ld l,d 
0dec 06 08		    ld b,8 
0dee			Mult8_Loop: 
0dee 29			    add hl,hl 
0def 30 01		    jr nc,Mult8_NoAdd 
0df1 19			    add hl,de 
0df2			Mult8_NoAdd: 
0df2 10 fa		    djnz Mult8_Loop 
0df4 c9			    ret 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			;;http://z80-heaven.wikidot.com/math 
0df5			;;This divides DE by BC, storing the result in DE, remainder in HL 
0df5			; 
0df5			;DE_Div_BC:          ;1281-2x, x is at most 16 
0df5			;     ld a,16        ;7 
0df5			;     ld hl,0        ;10 
0df5			;     jp $+5         ;10 
0df5			;.DivLoop: 
0df5			;       add hl,bc    ;-- 
0df5			;       dec a        ;64 
0df5			;       jr z,.DivLoopEnd        ;86 
0df5			; 
0df5			;       sla e        ;128 
0df5			;       rl d         ;128 
0df5			;       adc hl,hl    ;240 
0df5			;       sbc hl,bc    ;240 
0df5			;       jr nc,.DivLoop ;23|21 
0df5			;       inc e        ;-- 
0df5			;       jp .DivLoop+1 
0df5			; 
0df5			;.DivLoopEnd: 
0df5			 
0df5			;HL_Div_C: 
0df5			;Inputs: 
0df5			;     HL is the numerator 
0df5			;     C is the denominator 
0df5			;Outputs: 
0df5			;     A is the remainder 
0df5			;     B is 0 
0df5			;     C is not changed 
0df5			;     DE is not changed 
0df5			;     HL is the quotient 
0df5			; 
0df5			;       ld b,16 
0df5			;       xor a 
0df5			;         add hl,hl 
0df5			;         rla 
0df5			;         cp c 
0df5			;         jr c,$+4 
0df5			;           inc l 
0df5			;           sub c 
0df5			;         djnz $-7 
0df5			 
0df5			; https://plutiedev.com/z80-add-8bit-to-16bit 
0df5			 
0df5			addatohl: 
0df5 85			    add   a, l    ; A = A+L 
0df6 6f			    ld    l, a    ; L = A+L 
0df7 8c			    adc   a, h    ; A = A+L+H+carry 
0df8 95			    sub   l       ; A = H+carry 
0df9 67			    ld    h, a    ; H = H+carry 
0dfa c9			ret 
0dfb			 
0dfb			addatode: 
0dfb 83			    add   a, e    ; A = A+L 
0dfc 5f			    ld    e, a    ; L = A+L 
0dfd 8a			    adc   a, d    ; A = A+L+H+carry 
0dfe 93			    sub   e       ; A = H+carry 
0dff 57			    ld    d, a    ; H = H+carry 
0e00 c9			ret 
0e01			 
0e01			 
0e01			addatobc: 
0e01 81			    add   a, c    ; A = A+L 
0e02 4f			    ld    c, a    ; L = A+L 
0e03 88			    adc   a, b    ; A = A+L+H+carry 
0e04 91			    sub   c       ; A = H+carry 
0e05 47			    ld    b, a    ; H = H+carry 
0e06 c9			ret 
0e07			 
0e07			subafromhl: 
0e07			   ; If A=0 do nothing 
0e07			    ; Otherwise flip A's sign. Since 
0e07			    ; the upper byte becomes -1, also 
0e07			    ; substract 1 from H. 
0e07 ed 44		    neg 
0e09 ca 12 0e		    jp    z, Skip 
0e0c 25			    dec   h 
0e0d			     
0e0d			    ; Now add the low byte as usual 
0e0d			    ; Two's complement takes care of 
0e0d			    ; ensuring the result is correct 
0e0d 85			    add   a, l 
0e0e 6f			    ld    l, a 
0e0f 8c			    adc   a, h 
0e10 95			    sub   l 
0e11 67			    ld    h, a 
0e12			Skip: 
0e12 c9				ret 
0e13			 
0e13			 
0e13			; compare hl and de 
0e13			; returns:  
0e13			; if hl = de, z=1, s=0, c0=0 
0e13			; if hl > de, z=0, s=0, c=0 
0e13			; if hl < de, z=0, s=1, c=1 
0e13			cmp16:	 
0e13 b7				or a 
0e14 ed 52			sbc hl,de 
0e16 e0				ret po 
0e17 7c				ld a,h 
0e18 1f				rra 
0e19 ee 40			xor 01000000B 
0e1b 37				scf 
0e1c 8f				adc a,a 
0e1d c9				ret 
0e1e			 
0e1e			 
0e1e			; test if hl contains zero   - A is destroyed 
0e1e			 
0e1e			ishlzero:    
0e1e b7				or a     ; reset flags 
0e1f 7c				ld a, h 
0e20 b5				or l        	 
0e21			 
0e21 c9				ret 
0e22			 
0e22			 
0e22			 
0e22			 
0e22			if FORTH_ENABLE_FLOATMATH 
0e22			;include "float/bbcmath.z80" 
0e22			include "float/lpfpcalc.asm" 
0e22			endif 
0e22			 
0e22			 
0e22			; eof 
0e22			 
# End of file firmware_maths.asm
0e22			include "firmware_strings.asm"   ; string handling  
0e22			 
0e22			 
0e22			; TODO string len 
0e22			; input text string, end on cr with zero term 
0e22			; a offset into frame buffer to start prompt 
0e22			; d is max length 
0e22			; e is display size TODO 
0e22			; c is current cursor position 
0e22			; hl is ptr to where string will be stored and edited directly 
0e22			 
0e22			 
0e22			; TODO check limit of buffer for new inserts 
0e22			; TODO check insert does not push beyond buffer 
0e22			; TODO scroll in a limited display area 
0e22			; TODO scroll whole screen on page wrap 
0e22			 
0e22			 
0e22			; TODO use LCD cursor? 
0e22			 
0e22			EDIT_V1: equ 0 
0e22			EDIT_V2: equ 1 
0e22			 
0e22			 
0e22			 
0e22			if EDIT_V2 
0e22			input_str: 
0e22			 
0e22 32 5b ee			    	ld (input_at_pos),a      ; save display position to start 
0e25			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0e25 22 5e ee				ld (input_start), hl     ; save ptr to buffer 
0e28			;		ld a, c 
0e28			;		call addatohl 
0e28			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
0e28 7a					ld a,d 
0e29 32 5d ee			        ld (input_size), a       ; save length of input area 
0e2c 79					ld a, c 
0e2d 32 4c ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
0e30 7b					ld a,e 
0e31 32 5c ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e34			 
0e34			 
0e34					; add a trailing space to make screen refresh nicer 
0e34			 
0e34					;ld hl, (input_start) 
0e34					;push hl 
0e34					;ld a, 0 
0e34					;call strlent 
0e34					;ld a, l 
0e34					;pop hl 
0e34					;call addatohl 
0e34					;dec hl 
0e34					;ld a, ' ' 
0e34					;ld (hl), a 
0e34					;inc hl 
0e34					;ld (hl), a 
0e34					;inc hl 
0e34					;ld a, 0 
0e34					;ld (hl), a 
0e34			 
0e34			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e34					; init cursor shape if not set by the cin routines 
0e34 21 b8 eb				ld hl, cursor_shape 
0e37			if BASE_KEV 
0e37					ld a, 255 
0e37			else 
0e37 3e 23				ld a, '#' 
0e39			endif 
0e39 77					ld (hl), a 
0e3a 23					inc hl 
0e3b 3e 00				ld a, 0 
0e3d 77					ld (hl), a 
0e3e			 
0e3e 3e 09				ld a, CUR_BLINK_RATE 
0e40 32 57 ee				ld (input_cur_flash), a 
0e43 3e 01				ld a, 1 
0e45 32 56 ee				ld (input_cur_onoff),a 
0e48			.inmain:	 
0e48			 
0e48 cd 70 0f				call input_disp_ref 
0e4b			 
0e4b					; save current length of string 
0e4b			 
0e4b 2a 5e ee				ld hl, (input_start) 
0e4e 3e 00				ld a, 0 
0e50 cd 66 11				call strlent 
0e53 7d					ld a,l 
0e54 32 51 ee				ld (input_len), a 
0e57			 
0e57					;call input_disp_oncur 
0e57			 
0e57					; display current state of input buffer 
0e57			 
0e57					; clean any backspace chars 
0e57			 
0e57 3e 20				ld a, " " 
0e59 32 b8 e2				ld (scratch),a 
0e5c 3e 00				ld a, 0 
0e5e 32 b9 e2				ld (scratch+1),a 
0e61 3a 5b ee				ld a,(input_at_pos) 
0e64 85					add l 
0e65 11 b8 e2				ld de, scratch 
0e68 cd db 0b				call str_at_display 
0e6b			 
0e6b					; pause 1ms 
0e6b			 
0e6b 3e 01				ld a, 1 
0e6d cd e5 0a				call aDelayInMS 
0e70			 
0e70			; display cursor if visible on this cycle 
0e70			 
0e70					; dec flash counter 
0e70 3a 57 ee				ld a, (input_cur_flash) 
0e73 3d					dec a 
0e74 32 57 ee				ld (input_cur_flash), a 
0e77 fe 00				cp 0 
0e79 20 0d				jr nz, .inochgstate 
0e7b			 
0e7b			 
0e7b					; reset on change of state 
0e7b 3e 09				ld a, CUR_BLINK_RATE 
0e7d 32 57 ee				ld (input_cur_flash), a 
0e80			 
0e80					; change state 
0e80 3a 56 ee				ld a,(input_cur_onoff) 
0e83 ed 44				neg 
0e85 32 56 ee				ld (input_cur_onoff),a 
0e88			 
0e88			 
0e88			 
0e88			 
0e88					; TODO is cursor visible? 
0e88					; TODO if so then over write the char at curspos pos with the cursor shape 
0e88			 
0e88								 
0e88			 
0e88			.inochgstate: 
0e88 3a 56 ee				ld a,(input_cur_onoff) 
0e8b fe ff				cp 255 
0e8d 28 0e				jr z, .skipcursor 
0e8f 3a 5b ee				ld a, (input_at_pos) 
0e92 47					ld b, a 
0e93 3a 4c ee				ld a, (input_cursor) 
0e96 80					add b 
0e97 11 b8 eb				ld de, cursor_shape 
0e9a					 
0e9a cd db 0b				call str_at_display 
0e9d			 
0e9d			.skipcursor: 
0e9d				if DEBUG_INPUTV2 
0e9d			 
0e9d					ld a,(input_at_pos) 
0e9d					ld hl, LFSRSeed 
0e9d					call hexout 
0e9d					ld a, (input_cursor) 
0e9d					ld hl, LFSRSeed+2 
0e9d					call hexout 
0e9d					ld a,(input_size) 
0e9d					ld hl, LFSRSeed+4 
0e9d					call hexout 
0e9d			 
0e9d					ld a,(input_cur_onoff) 
0e9d					ld hl, LFSRSeed+6 
0e9d					call hexout 
0e9d			 
0e9d					ld a,(input_cur_flash) 
0e9d					ld hl, LFSRSeed+8 
0e9d					call hexout 
0e9d			 
0e9d					ld a,(input_len) 
0e9d					ld hl, LFSRSeed+10 
0e9d					call hexout 
0e9d					ld hl, LFSRSeed+12 
0e9d					ld a, 0 
0e9d					ld (hl),a 
0e9d					ld a, display_row_4 
0e9d					ld de, LFSRSeed 
0e9d					call str_at_display 
0e9d				endif 
0e9d cd eb 0b				call update_display 
0ea0			 
0ea0					; TODO keyboard processing 
0ea0			 
0ea0			if BASE_CPM 
0ea0 cd 32 65				call cin_wait 
0ea3			else 
0ea3					call cin    ; _wait 
0ea3			endif 
0ea3 fe 00				cp 0 
0ea5 ca 48 0e				jp z, .inmain 
0ea8			 
0ea8 fe 0b				cp KEY_LEFT    ; cursor left 
0eaa ca 62 0f				jp z, input_left 
0ead				 
0ead fe 0c				cp KEY_RIGHT      ; cursor right 
0eaf ca 69 0f				jp z, input_right 
0eb2			 
0eb2 fe 0d				cp KEY_CR 
0eb4 c8					ret z 
0eb5			 
0eb5 fe 08				cp KEY_BS 
0eb7 ca d7 0f				jp z, input_delchar 
0eba			 
0eba fe 06				cp KEY_NEXTWORD 
0ebc ca e3 0e				jp z, input_nxtword 
0ebf			 
0ebf fe 07				cp KEY_PREVWORD 
0ec1 ca 0a 0f				jp z, input_prvword 
0ec4			 
0ec4 fe 0e				cp KEY_HOME    ; jump to start of line 
0ec6 20 08				jr nz, .ikh 
0ec8 3e 00				ld a, 0 
0eca 32 4c ee				ld (input_cursor), a 
0ecd ca 48 0e				jp z, .inmain 
0ed0			.ikh: 
0ed0			 
0ed0 fe 0f				cp KEY_END     ; jump to end of line 
0ed2 20 09				jr nz, .ike 
0ed4 3a 51 ee				ld a, (input_len) 
0ed7 32 4c ee				ld (input_cursor),a 
0eda ca 48 0e				jp z, .inmain 
0edd			.ike: 
0edd fe 05			        cp KEY_UP      ; recall last command 
0edf c8					ret z 
0ee0			;jr nz, .irec 
0ee0			; TODO next word 
0ee0			; TODO prev word 
0ee0			;  
0ee0			; 
0ee0			;	ld hl, scratch 
0ee0			;	ld de, os_last_cmd 
0ee0			;	call strcpy 
0ee0			;		jp  .inmain 
0ee0			.irec: 
0ee0			;		jr .instr1 
0ee0			 
0ee0			 
0ee0			 
0ee0					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
0ee0			 
0ee0			; TODO return if any special keys are given 
0ee0			;		ld l, a 
0ee0			;		ld a, 28 ; KEY_F12   ; 27 
0ee0			;		sub l 
0ee0			;		ret m 
0ee0			;		ld a, l 
0ee0					; if no special key then insert as a char 
0ee0			 
0ee0 c3 a9 0f				jp input_inschr 
0ee3			 
0ee3				 
0ee3			input_nxtword: 
0ee3				; jump to start next word after the cursor 
0ee3			 
0ee3			.insknwn:	 
0ee3 cd 9f 0f				call input_curptr	 
0ee6 7e					ld a,(hl)	 
0ee7 fe 00				cp 0 
0ee9 ca 48 0e				jp z, .inmain    ; end of string 
0eec			 
0eec			; if we are on a word, then move off of it 
0eec			 
0eec fe 20				cp ' ' 
0eee 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
0ef0 21 4c ee				ld hl, input_cursor 
0ef3 34					inc (hl) 
0ef4 18 ed				jr .insknwn 
0ef6			 
0ef6			.inspace: 
0ef6			 
0ef6 cd 9f 0f				call input_curptr	 
0ef9 7e					ld a,(hl)	 
0efa fe 00				cp 0 
0efc ca 48 0e				jp z, .inmain    ; end of string 
0eff			 
0eff			; if we are on a word, then move off of it 
0eff			 
0eff fe 20				cp ' ' 
0f01 c2 48 0e				jp nz, .inmain     ; we are on non space so at next word 
0f04 21 4c ee				ld hl, input_cursor 
0f07 34					inc (hl) 
0f08 18 ec				jr .inspace 
0f0a			 
0f0a			 
0f0a			 
0f0a			 
0f0a			input_prvword: 
0f0a				; jump to the start of previous word before the cursor 
0f0a			 
0f0a			; where are we to start with currently? 
0f0a			 
0f0a cd 9f 0f				call input_curptr	 
0f0d 7e					ld a, (hl) 
0f0e fe 20				cp ' ' 
0f10 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
0f12			 
0f12			 
0f12			 
0f12			.inskpwn:	 
0f12 3a 4c ee				ld a,(input_cursor) 
0f15 fe 00				cp 0 
0f17 ca 48 0e				jp z, .inmain    ; start of string 
0f1a			 
0f1a			;if we are on a word, then move off of it 
0f1a			 
0f1a cd 9f 0f				call input_curptr	 
0f1d 7e					ld a, (hl) 
0f1e fe 20				cp ' ' 
0f20 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
0f22					;jp z, .inmain    ; start of string 
0f22 21 4c ee				ld hl, input_cursor 
0f25 35					dec (hl) 
0f26 18 ea				jr .inskpwn 
0f28			.iwstart: 
0f28 21 4c ee				ld hl, input_cursor 
0f2b 34					inc (hl) 
0f2c c3 48 0e				jp .inmain 
0f2f					 
0f2f			 
0f2f			.inspacep: 
0f2f			 
0f2f					;jp .inmain    ; start of string 
0f2f			 
0f2f			 
0f2f			 
0f2f 3a 4c ee				ld a,(input_cursor) 
0f32 fe 00				cp 0 
0f34 ca 48 0e				jp z, .inmain    ; start of string 
0f37			 
0f37			; if we are on a word, then move off of it 
0f37			 
0f37 cd 9f 0f				call input_curptr	 
0f3a 7e					ld a, (hl) 
0f3b fe 20				cp ' ' 
0f3d c2 46 0f				jp nz, .incharp     ; we are on non space so at end of prev word 
0f40 21 4c ee				ld hl, input_cursor 
0f43 35					dec (hl) 
0f44 18 e9				jr .inspacep 
0f46			 
0f46			 
0f46			.incharp:	 
0f46					; eat the word to get to the start 
0f46 3a 4c ee				ld a,(input_cursor) 
0f49 fe 00				cp 0 
0f4b ca 48 0e				jp z, .inmain    ; start of string 
0f4e			 
0f4e			; if we are on a word, then move off of it 
0f4e			 
0f4e cd 9f 0f				call input_curptr	 
0f51 7e					ld a, (hl) 
0f52 fe 20				cp ' ' 
0f54 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
0f56 21 4c ee				ld hl, input_cursor 
0f59 35					dec (hl) 
0f5a 18 ea				jr .incharp 
0f5c			.ipwordst: 
0f5c					; at space before the prev word so reposition over it 
0f5c 21 4c ee				ld hl, input_cursor 
0f5f 34					inc (hl) 
0f60 18 b0				jr .inskpwn 
0f62					 
0f62			 
0f62			 
0f62			input_left: 
0f62				; move cursor left 
0f62 21 4c ee			ld hl, input_cursor 
0f65 35				dec (hl) 
0f66			;	cp 0 
0f66			;	jp z, .inmain    ; ignore left as at the start of the string 
0f66 c3 48 0e			jp .inmain 
0f69			 
0f69			input_right: 
0f69				; move cursor right 
0f69				 
0f69				;ld a, (input_size) 
0f69				;ld b, a 
0f69 21 4c ee			ld hl, input_cursor 
0f6c 34				inc (hl) 
0f6d				;dec b 
0f6d				;cp 0 
0f6d				;jp z, .inmain   ; ignore as at end of the string buffer 
0f6d				;ld a, b 
0f6d				;inc a 
0f6d				;ld (input_cursor), a 
0f6d c3 48 0e			jp .inmain 
0f70			 
0f70			 
0f70			 
0f70			input_disp_ref: 
0f70				; display the text from start of buffer (ie full refresh) 
0f70 3a 5b ee			ld a, (input_at_pos) 
0f73 2a 5e ee			ld hl,(input_start) 
0f76 eb				ex de, hl 
0f77 cd db 0b			call str_at_display  
0f7a c9				ret 
0f7b			input_disp_oncur: 
0f7b				; display the text from cursor position to end of buffer 
0f7b				; TODO position start of string at cursor position on screen 
0f7b				; TODO draw from that point on 
0f7b 3a 4c ee			ld a, (input_cursor) 
0f7e 47				ld b, a 
0f7f 3a 5b ee			ld a, (input_at_pos) 
0f82 80				add b 
0f83 48				ld c, b     ; save a 
0f84 78				ld a, b     ; inc string start for cursor 
0f85 2a 5e ee			ld hl,(input_start) 
0f88 cd f5 0d			call addatohl 
0f8b eb				ex de, hl 
0f8c 79				ld a, c 
0f8d cd db 0b			call str_at_display  
0f90 c9				ret 
0f91			 
0f91			input_nxtw: 
0f91				; Find next word 
0f91 c9				ret 
0f92			 
0f92			input_prvw: 
0f92				; Find previous word 
0f92 c9				ret 
0f93			 
0f93			input_lenrem:   
0f93				; Calculate the length of string remaining from current cursor 
0f93				; position to end of buffer (exc null term) 
0f93				 
0f93 3a 4c ee			ld a, (input_cursor) 
0f96 4f				ld c, a 
0f97 3a 5d ee			ld a, (input_size) 
0f9a 91				sub c 
0f9b 06 00			ld b, 0 
0f9d 0d				dec c 
0f9e c9				ret	 
0f9f			 
0f9f			input_curptr: 
0f9f				; calc address of the character under the cursor 
0f9f				 
0f9f 2a 5e ee			ld hl, (input_start) 
0fa2 3a 4c ee			ld a, (input_cursor) 
0fa5 cd f5 0d			call addatohl 
0fa8 c9				ret 
0fa9			 
0fa9			input_inschr: 
0fa9				; Insert char at cursor position 
0fa9 f5				push af   ; save char 
0faa				;call input_lenrem    ; get bc length of remaining string 
0faa			 
0faa				 
0faa cd 9f 0f			call input_curptr 
0fad			;	ld hl, (input_start) 
0fad			;	ld a, (input_cursor) 
0fad			;	call addatohl 
0fad				;push hl   ; save to come back to 
0fad			 
0fad				; shift everything up one to end of buffer 
0fad			 
0fad				;push hl 
0fad				;dec de 
0fad				;inc de 
0fad			;	ldir 
0fad				 
0fad				;pop hl 
0fad			 
0fad				; are we adding to the end of line? 
0fad			 
0fad 3a 4c ee			ld a, (input_cursor) 
0fb0 47				ld b, a 
0fb1 3a 51 ee			ld a, (input_len) 
0fb4 b8				cp b 
0fb5 20 09			jr nz, .insmid   ; no, insert in middle of text 
0fb7			 
0fb7				; tack on the end of the line 
0fb7 f1				pop af 
0fb8 77				ld (hl), a   ; save new char 
0fb9 23				inc hl 
0fba 3e 00			ld a, 0 
0fbc 77				ld (hl), a 
0fbd c3 69 0f			jp input_right 
0fc0				 
0fc0			.insmid: 
0fc0				; hl has insertion point so move everything up one to allow for insertion 
0fc0				;call input_shiftright 
0fc0 f1				pop af 
0fc1			 
0fc1			.shufinsmid: 
0fc1 47				ld b, a     ; b contains new char, c prev char at this position  
0fc2 7e				ld a, (hl) 
0fc3			 
0fc3 fe 00			cp 0    ; at end of string need to then dump new char and add term 
0fc5 28 07			jr z, .endinsmid 
0fc7 4f				ld c, a 
0fc8 78				ld a, b 
0fc9 77				ld (hl), a 
0fca 23				inc hl 
0fcb 79				ld a, c 
0fcc 18 f3			jr .shufinsmid 
0fce				 
0fce			 
0fce			 
0fce			 
0fce			.endinsmid: 
0fce 78				ld a, b 
0fcf 77				ld (hl), a 
0fd0 23				inc hl 
0fd1 3e 00			ld a, 0 
0fd3 77				ld (hl), a 
0fd4			 
0fd4			 
0fd4			;	ld (hl), a   ; save new char 
0fd4			 
0fd4 c3 69 0f			jp input_right 
0fd7			 
0fd7			;input_shiftright: 
0fd7			;	; shift text right at cursor, hl has shift start 
0fd7			;	push hl 
0fd7			;	push de 
0fd7			;	push bc 
0fd7			; 
0fd7			; 
0fd7			;	; move to end of string past zero term 
0fd7			;	ld hl,(input_start) 
0fd7			;	ld a, (input_len) 
0fd7			;	call addatohl 
0fd7			;	inc hl 
0fd7			;;	inc hl 
0fd7			;;	inc hl 
0fd7			;	ld a, 0 
0fd7			;	ld (hl), a 
0fd7			;;	dec hl 
0fd7			;	 
0fd7			;;	ld (hl), a 
0fd7			;;	dec hl 
0fd7			; 
0fd7			;	push hl 
0fd7			;	pop de 
0fd7			;	inc de 
0fd7			;	 
0fd7			; 
0fd7			;;	ld hl,(input_start) 
0fd7			;;	ld a, (input_cursor) 
0fd7			;;	call addatohl 
0fd7			; 
0fd7			; 
0fd7			;	; calc how many bytes from cursor pos to end of string we need to shift 
0fd7			;	call input_lenrem    ; get bc length of remaining string 
0fd7			;	;ld a, (input_cursor) 
0fd7			;	;ld c, a 
0fd7			;	ld a, (input_len) 
0fd7			;	cp 2 
0fd7			;	jr z, .iskipzero	 
0fd7			;	;sub c 
0fd7			;	;inc a 
0fd7			;	;ld c, a 
0fd7			;	;ld b, 0 
0fd7			;	inc c 
0fd7			;	inc c 
0fd7			;	; move data 
0fd7			;	lddr 
0fd7			;.iskipzero: 
0fd7			; 
0fd7			;	pop bc 
0fd7			;	pop de 
0fd7			;	pop hl 
0fd7			;	ret	 
0fd7			 
0fd7			input_delchar: 
0fd7				; Delete char at cursor position 
0fd7 cd 93 0f			call input_lenrem    ; get bc length of remaining string 
0fda 2a 5e ee			ld hl, (input_start) 
0fdd 3a 4c ee			ld a, (input_cursor) 
0fe0 cd f5 0d			call addatohl 
0fe3			 
0fe3 e5				push hl 
0fe4 d1				pop de 
0fe5 1b				dec de 
0fe6			 
0fe6			.dl:	 
0fe6 ed a0			ldi  
0fe8 7e				ld a, (hl) 
0fe9 fe 00			cp 0 
0feb 28 02			jr z, .dldone 
0fed 18 f7			jr .dl 
0fef			.dldone: 
0fef ed a0			ldi 
0ff1			 
0ff1 c3 62 0f			jp input_left 
0ff4			 
0ff4			 
0ff4			endif 
0ff4			 
0ff4			 
0ff4			 
0ff4			if EDIT_V1 
0ff4			input_str: 
0ff4			 
0ff4				    	ld (input_at_pos),a      ; save display position to start 
0ff4					add c 
0ff4					ld (input_at_cursor),a	; save draw pos of cursor 
0ff4					ld (input_start), hl     ; save ptr to buffer 
0ff4					ld a, c 
0ff4					call addatohl 
0ff4					ld (input_ptr), hl     ; save ptr to point under the cursor 
0ff4					ld a,d 
0ff4				        ld (input_size), a       ; save length of input area 
0ff4					ld a, c 
0ff4					ld (input_cursor),a      ; init cursor start position  
0ff4					ld a,e 
0ff4				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0ff4					 
0ff4					 
0ff4			 
0ff4			;		ld a,(input_ptr) 
0ff4			;		ld (input_under_cursor),a 	; save what is under the cursor 
0ff4			 
0ff4			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0ff4					; init cursor shape if not set by the cin routines 
0ff4					ld hl, cursor_shape 
0ff4			if BASE_KEV 
0ff4					ld a, 255 
0ff4			else 
0ff4					ld a, '#' 
0ff4			endif 
0ff4					ld (hl), a 
0ff4					inc hl 
0ff4					ld a, 0 
0ff4					ld (hl), a 
0ff4			 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4					ld a, 1 
0ff4					ld (input_cur_onoff),a 
0ff4			 
0ff4			;	if DEBUG_INPUT 
0ff4			;		push af 
0ff4			;		ld a, 'I' 
0ff4			;		ld (debug_mark),a 
0ff4			;		pop af 
0ff4			;		CALLMONITOR 
0ff4			;	endif 
0ff4			.is1:		; main entry loop 
0ff4			 
0ff4			 
0ff4			 
0ff4					; pause 1ms 
0ff4			 
0ff4					ld a, 1 
0ff4					call aDelayInMS 
0ff4			 
0ff4					; dec flash counter 
0ff4					ld a, (input_cur_flash) 
0ff4					dec a 
0ff4					ld (input_cur_flash), a 
0ff4					cp 0 
0ff4					jr nz, .nochgstate 
0ff4			 
0ff4			 
0ff4					; change state 
0ff4					ld a,(input_cur_onoff) 
0ff4					neg 
0ff4					ld (input_cur_onoff),a 
0ff4			 
0ff4			 
0ff4					; reset on change of state 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4			 
0ff4			.nochgstate: 
0ff4					 
0ff4					 
0ff4			 
0ff4					; display cursor  
0ff4			 
0ff4			;		ld hl, (input_start) 
0ff4			;		ld a, (input_cursor) 
0ff4			;		call addatohl 
0ff4			 
0ff4					; get char under cursor and replace with cursor 
0ff4			ld hl, (input_ptr) 
0ff4			;		ld a, (hl) 
0ff4			;		ld (input_under_cursor),a 
0ff4			;		ld a, '_' 
0ff4			;		ld (hl), a 
0ff4			 
0ff4					; display string 
0ff4			 
0ff4					ld de, (input_start) 
0ff4					ld a, (input_at_pos) 
0ff4					call str_at_display 
0ff4			;	        call update_display 
0ff4			 
0ff4					; find place to put the cursor 
0ff4			;		add h 
0ff4			;		ld l, display_row_1 
0ff4			;		sub l 
0ff4			; (input_at_pos) 
0ff4					;ld c, a 
0ff4			;		ld a, (input_cursor) 
0ff4			;		ld l, (input_at_pos) 
0ff4			;		;ld b, h 
0ff4			;		add l 
0ff4			;		ld (input_at_cursor),a 
0ff4					;ld l,h 
0ff4			 
0ff4			;		ld h, 0 
0ff4			;		ld l,(input_at_pos) 
0ff4			;		ld a, (input_cursor) 
0ff4			;		call addatohl 
0ff4			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0ff4			;		call subafromhl 
0ff4			;		ld a,l 
0ff4			;		ld (input_at_cursor), a 
0ff4			 
0ff4				if DEBUG_INPUT 
0ff4					ld a, (hardware_diag) 
0ff4					cp 0 
0ff4					jr z, .skip_input_diag 
0ff4			 
0ff4					ld a,(input_at_pos) 
0ff4					ld hl, LFSRSeed 
0ff4					call hexout 
0ff4					ld a, (input_cursor) 
0ff4					ld hl, LFSRSeed+2 
0ff4					call hexout 
0ff4					ld a,(input_at_cursor) 
0ff4					ld hl, LFSRSeed+4 
0ff4					call hexout 
0ff4			 
0ff4					ld a,(input_cur_onoff) 
0ff4					ld hl, LFSRSeed+6 
0ff4					call hexout 
0ff4			 
0ff4					ld a,(input_cur_flash) 
0ff4					ld hl, LFSRSeed+8 
0ff4					call hexout 
0ff4			 
0ff4					ld a,(input_len) 
0ff4					ld hl, LFSRSeed+10 
0ff4					call hexout 
0ff4					ld hl, LFSRSeed+12 
0ff4					ld a, 0 
0ff4					ld (hl),a 
0ff4					ld a, display_row_4 
0ff4					ld de, LFSRSeed 
0ff4					call str_at_display 
0ff4					.skip_input_diag: 
0ff4				endif 
0ff4			 
0ff4					; decide on if we are showing the cursor this time round 
0ff4			 
0ff4					ld a, (input_cur_onoff) 
0ff4					cp 255 
0ff4					jr z, .skipcur 
0ff4			 
0ff4			 
0ff4					ld a,(input_at_cursor) 
0ff4					ld de, cursor_shape 
0ff4					call str_at_display 
0ff4			 
0ff4					; save length of current input string 
0ff4					ld hl, (input_start) 
0ff4					ld a, 0 
0ff4					call strlent 
0ff4					ld a,l 
0ff4					ld (input_len),a 
0ff4			 
0ff4			.skipcur: 
0ff4			 
0ff4				        call update_display 
0ff4					 
0ff4			 
0ff4			 
0ff4					; wait 
0ff4				 
0ff4					; TODO loop without wait to flash the cursor and char under cursor	 
0ff4					call cin    ; _wait 
0ff4			 
0ff4					cp 0 
0ff4					jp z, .is1 
0ff4			 
0ff4					; get ptr to char to input into 
0ff4			 
0ff4					ld c,a 
0ff4					ld hl, (input_start) 
0ff4					ld a, (input_cursor) 
0ff4					call addatohl 
0ff4					ld (input_ptr), hl 
0ff4					ld a,c 
0ff4			 
0ff4					; replace char under cursor 
0ff4			 
0ff4			;		ld hl, (input_ptr) 
0ff4			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ff4			;		ld (hl), a 
0ff4			 
0ff4			;	if DEBUG_INPUT 
0ff4			;		push af 
0ff4			;		ld a, 'i' 
0ff4			;		ld (debug_mark),a 
0ff4			;		pop af 
0ff4			;		CALLMONITOR 
0ff4			;	endif 
0ff4					cp KEY_HOME 
0ff4					jr nz, .iske 
0ff4			 
0ff4					ld a, (input_at_pos) 
0ff4					ld (input_at_cursor),a 
0ff4					ld a, 0 
0ff4					ld (input_cursor), a 
0ff4					jp .is1 
0ff4					 
0ff4			.iske:		cp KEY_END 
0ff4					jr nz, .isknw 
0ff4					jp .is1 
0ff4			 
0ff4			.isknw:		cp KEY_NEXTWORD 
0ff4					jr nz, .iskpw 
0ff4			 
0ff4			.isknwm:	ld hl, (input_ptr) 
0ff4					ld a,(hl)	 
0ff4					cp 0 
0ff4					jp z, .is1    ; end of string 
0ff4					cp ' ' 
0ff4					jp z, .is1    ; end of word 
0ff4					inc hl 
0ff4					ld (input_ptr), hl 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld (input_at_cursor), a 
0ff4					jr .isknwm 
0ff4			 
0ff4			.iskpw:		cp KEY_PREVWORD 
0ff4					jr nz, .iskl 
0ff4			.iskpwm:	 
0ff4					ld hl, (input_ptr) 
0ff4					ld a,(hl)	 
0ff4					cp 0  
0ff4					jp z, .is1    ; end of string 
0ff4					cp ' ' 
0ff4					jp z, .is1    ; end of word 
0ff4					dec hl 
0ff4					ld (input_ptr), hl 
0ff4					ld a, (input_at_cursor) 
0ff4					dec a 
0ff4					ld (input_at_cursor), a 
0ff4					jr .iskpwm 
0ff4			 
0ff4			 
0ff4			.iskl:		cp KEY_LEFT 
0ff4					jr nz, .isk1 
0ff4			 
0ff4					ld a, (input_cursor) 
0ff4			 
0ff4					cp 0 
0ff4					jp z, .is1 		; at start of line to ignore  
0ff4			 
0ff4					dec  a 		; TODO check underflow 
0ff4					ld (input_cursor), a 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					dec hl 
0ff4					ld (input_ptr), hl 
0ff4					 
0ff4					ld a, (input_at_cursor) 
0ff4					dec a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					ld a, 1		; show cursor moving 
0ff4					ld (input_cur_onoff),a 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.isk1:		cp KEY_RIGHT 
0ff4					jr nz, .isk2 
0ff4			 
0ff4					ld a,(input_len)		; TODO BUG why cant i load e direct? 
0ff4					ld e,a 
0ff4					ld a, (input_cursor) 
0ff4					cp e 
0ff4					jp z, .is1		; at the end of string so dont go right 
0ff4			 
0ff4					inc  a 		; TODO check overflow 
0ff4					ld (input_cursor), a 
0ff4			 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					inc hl 
0ff4					ld (input_ptr), hl 
0ff4			 
0ff4					ld a, 1		; show cursor moving 
0ff4					ld (input_cur_onoff),a 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.isk2:		cp KEY_UP 
0ff4			 
0ff4					jr nz, .isk3 
0ff4			 
0ff4					; swap last command with the current on 
0ff4			 
0ff4					; move cursor to start of string 
0ff4					ld hl, (input_start) 
0ff4					ld (input_ptr), hl 
0ff4			 
0ff4					ld a, (input_at_pos) 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					ld a, 0 
0ff4					ld (input_cursor), a 
0ff4					 
0ff4					; swap input and last command buffers 
0ff4			 
0ff4					ld hl, os_cli_cmd 
0ff4					ld de, os_last_cmd 
0ff4					ld b, 255 
0ff4			.swap1:		ld a, (hl) 
0ff4					ld c,a 
0ff4					ld a, (de) 
0ff4					ld (hl), a 
0ff4					ld a,c 
0ff4					ld (de),a 
0ff4					inc hl 
0ff4					inc de 
0ff4					djnz .swap1 
0ff4			 
0ff4			 
0ff4			 
0ff4			 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.isk3:		cp KEY_BS 
0ff4					jr nz, .isk4 
0ff4			 
0ff4					ld a, (input_cursor) 
0ff4			 
0ff4					cp 0 
0ff4					jp z, .is1 		; at start of line to ignore  
0ff4			 
0ff4					dec  a 		; TODO check underflow 
0ff4					ld (input_cursor), a 
0ff4			 
0ff4					; hl is source 
0ff4					; de needs to be source - 1 
0ff4			 
0ff4			;		ld a, 0 
0ff4			;		dec hl 
0ff4			;		ld (hl), a 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					dec hl 
0ff4					ld (input_ptr), hl 
0ff4			 
0ff4					; shift all data 
0ff4			 
0ff4					push hl 
0ff4					inc hl 
0ff4					pop de 
0ff4					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0ff4					ld c,a 
0ff4					ld b,0 
0ff4					ldir  
0ff4			 
0ff4			 
0ff4			 
0ff4			 
0ff4					ld a, (input_at_cursor) 
0ff4					dec a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4			 
0ff4					ld a, 1		; show cursor moving 
0ff4					ld (input_cur_onoff),a 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4			 
0ff4					; remove char 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld de,.iblank 
0ff4					call str_at_display 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.isk4:		cp KEY_CR 
0ff4					jr z, .endinput 
0ff4			 
0ff4					; else add the key press to the end 
0ff4			 
0ff4					ld c, a			; save key pressed 
0ff4			 
0ff4					ld a,(hl)		; get what is currently under char 
0ff4			 
0ff4					cp 0			; we are at the end of the string 
0ff4					jr nz, .onchar 
0ff4					 
0ff4					; add a char to the end of the string 
0ff4				 
0ff4					ld (hl),c 
0ff4					inc hl 
0ff4			;		ld a,' ' 
0ff4			;		ld (hl),a 
0ff4			;		inc hl 
0ff4					ld a,0 
0ff4					ld (hl),a 
0ff4					dec hl 
0ff4			 
0ff4					ld a, (input_cursor) 
0ff4					inc a				; TODO check max string length and scroll  
0ff4					ld (input_cursor), a		; inc cursor pos 
0ff4							 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					inc hl 
0ff4					ld (input_ptr), hl 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					inc hl 
0ff4					ld (input_ptr), hl 
0ff4			;	if DEBUG_INPUT 
0ff4			;		push af 
0ff4			;		ld a, '+' 
0ff4			;		ld (debug_mark),a 
0ff4			;		pop af 
0ff4			;		CALLMONITOR 
0ff4			;	endif 
0ff4					ld a, 1		; show cursor moving 
0ff4					ld (input_cur_onoff),a 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4					jp .is1 
0ff4					 
0ff4			 
0ff4			 
0ff4					; if on a char then insert 
0ff4			.onchar: 
0ff4			 
0ff4					; TODO over flow check: make sure insert does not blow out buffer 
0ff4			 
0ff4					; need to do some maths to use lddr 
0ff4			 
0ff4					push hl   ; save char pos 
0ff4					push bc 
0ff4			 
0ff4					ld hl, (input_start) 
0ff4					ld a, (input_len) 
0ff4					call addatohl  		; end of string 
0ff4					inc hl 
0ff4					inc hl		; past zero term 
0ff4					push hl 
0ff4					inc hl 
0ff4					push hl  
0ff4			 
0ff4								; start and end of lddr set, now how much to move? 
0ff4			 
0ff4							 
0ff4					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0ff4					ld b,a 
0ff4					ld a,(input_len) 
0ff4					ld e,a 
0ff4					sub b 
0ff4					inc a		;?? 
0ff4					inc a		;?? 
0ff4					inc a		;?? 
0ff4			 
0ff4					ld b,0 
0ff4					ld c,a 
0ff4			 
0ff4				if DEBUG_INPUT 
0ff4					push af 
0ff4					ld a, 'i' 
0ff4					ld (debug_mark),a 
0ff4					pop af 
0ff4			;		CALLMONITOR 
0ff4				endif 
0ff4					pop de 
0ff4					pop hl 
0ff4				if DEBUG_INPUT 
0ff4					push af 
0ff4					ld a, 'I' 
0ff4					ld (debug_mark),a 
0ff4					pop af 
0ff4			;		CALLMONITOR 
0ff4				endif 
0ff4					lddr 
0ff4				 
0ff4			 
0ff4			 
0ff4					; TODO have a key for insert/overwrite mode???? 
0ff4					pop bc 
0ff4					pop hl 
0ff4					ld (hl), c		; otherwise overwrite current char 
0ff4					 
0ff4			 
0ff4			 
0ff4			 
0ff4					ld a, (input_cursor) 
0ff4					inc  a 		; TODO check overflow 
0ff4					ld (input_cursor), a 
0ff4			 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.endinput:	; TODO look for end of string 
0ff4			 
0ff4					; add trailing space for end of token 
0ff4			 
0ff4					ld hl, (input_start) 
0ff4					ld a,(input_len) 
0ff4					call addatohl 
0ff4					ld a, ' ' 
0ff4					ld (hl),a 
0ff4					; TODO eof of parse marker 
0ff4			 
0ff4					inc hl 
0ff4					ld a, 0 
0ff4					ld (hl),a 
0ff4			 
0ff4			 
0ff4					ret 
0ff4			 
0ff4			.iblank: db " ",0 
0ff4			 
0ff4			 
0ff4			input_str_prev:	ld (input_at_pos), a 
0ff4					ld (input_start), hl 
0ff4					ld a,1			; add cursor 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a,0 
0ff4					ld (hl),a 
0ff4					ld (input_ptr), hl 
0ff4					ld a,d 
0ff4					ld (input_size), a 
0ff4					ld a,0 
0ff4					ld (input_cursor),a 
0ff4			.instr1:	 
0ff4			 
0ff4					; TODO do block cursor 
0ff4					; TODO switch cursor depending on the modifer key 
0ff4			 
0ff4					; update cursor shape change on key hold 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					dec hl 
0ff4					ld a,(cursor_shape) 
0ff4					ld (hl), a 
0ff4			 
0ff4					; display entered text 
0ff4					ld a,(input_at_pos) 
0ff4			            	CALL fLCD_Pos       ;Position cursor to location in A 
0ff4			            	LD   de, (input_start) 
0ff4			            	CALL fLCD_Str       ;Display string pointed to by DE 
0ff4			 
0ff4					call cin 
0ff4					cp 0 
0ff4					jr z, .instr1 
0ff4			 
0ff4					; proecess keyboard controls first 
0ff4			 
0ff4					ld hl,(input_ptr) 
0ff4			 
0ff4					cp KEY_CR	 ; pressing enter ends input 
0ff4					jr z, .instrcr 
0ff4			 
0ff4					cp KEY_BS 	; back space 
0ff4					jr nz, .instr2 
0ff4					; process back space 
0ff4			 
0ff4					; TODO stop back space if at start of string 
0ff4					dec hl 
0ff4					dec hl ; to over write cursor 
0ff4					ld a,(cursor_shape) 
0ff4					;ld a,0 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a," " 
0ff4					ld (hl),a 
0ff4					ld (input_ptr),hl 
0ff4					 
0ff4			 
0ff4					jr .instr1 
0ff4			 
0ff4			.instr2:	cp KEY_LEFT    ; cursor left 
0ff4					jr nz, .instr3 
0ff4					dec hl 
0ff4					ld (input_ptr),hl 
0ff4					jr .instr1 
0ff4				 
0ff4			.instr3:	cp KEY_RIGHT      ; cursor right 
0ff4					jr nz, .instr4 
0ff4					inc hl 
0ff4					ld (input_ptr),hl 
0ff4					jr .instr1 
0ff4			 
0ff4			.instr4:	cp KEY_HOME    ; jump to start of line 
0ff4					jr nz, .instr5 
0ff4					dec hl 
0ff4					ld (input_ptr),hl 
0ff4					jr .instr1 
0ff4			 
0ff4			.instr5:	cp KEY_END     ; jump to end of line 
0ff4					jr nz, .instr6 
0ff4					dec hl 
0ff4					ld (input_ptr),hl 
0ff4					jr .instr1 
0ff4			.instr6:        cp KEY_UP      ; recall last command 
0ff4					jr nz, .instrnew 
0ff4			 
0ff4				ld hl, scratch 
0ff4				ld de, os_last_cmd 
0ff4				call strcpy 
0ff4					jr .instr1 
0ff4			 
0ff4			 
0ff4			.instrnew:	; no special key pressed to see if we have room to store it 
0ff4			 
0ff4					; TODO do string size test 
0ff4			 
0ff4					dec hl ; to over write cursor 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a,(cursor_shape) 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a,0 
0ff4					ld (hl),a 
0ff4			 
0ff4					ld (input_ptr),hl 
0ff4					 
0ff4					jr .instr1 
0ff4			.instrcr:	dec hl		; remove cursor 
0ff4					ld a,' '	; TODO add a trailing space for safety 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a,0 
0ff4					ld (hl),a 
0ff4			 
0ff4			 
0ff4					; if at end of line scroll up    
0ff4					; TODO detecting only end of line 4 for scroll up  
0ff4			 
0ff4					;ld   
0ff4			 
0ff4					ret 
0ff4			 
0ff4			 
0ff4			endif 
0ff4			; strcpy hl = dest, de source 
0ff4			 
0ff4 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ff5 b7			            OR   A              ;Null terminator? 
0ff6 c8			            RET  Z              ;Yes, so finished 
0ff7 1a					ld a,(de) 
0ff8 77					ld (hl),a 
0ff9 13			            INC  DE             ;Point to next character 
0ffa 23					inc hl 
0ffb 18 f7		            JR   strcpy       ;Repeat 
0ffd c9					ret 
0ffe			 
0ffe			 
0ffe			; TODO string_at  
0ffe			; pass string which starts with lcd offset address and then null term string 
0ffe			 
0ffe			; TODO string to dec 
0ffe			; TODO string to hex 
0ffe			; TODO byte to string hex 
0ffe			; TODO byte to string dec 
0ffe			 
0ffe			 
0ffe			 
0ffe			; from z80uartmonitor 
0ffe			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ffe			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0ffe			; pass hl for where to put the text 
0ffe			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ffe c5			hexout:	PUSH BC 
0fff f5					PUSH AF 
1000 47					LD B, A 
1001					; Upper nybble 
1001 cb 3f				SRL A 
1003 cb 3f				SRL A 
1005 cb 3f				SRL A 
1007 cb 3f				SRL A 
1009 cd 19 10				CALL tohex 
100c 77					ld (hl),a 
100d 23					inc hl	 
100e					 
100e					; Lower nybble 
100e 78					LD A, B 
100f e6 0f				AND 0FH 
1011 cd 19 10				CALL tohex 
1014 77					ld (hl),a 
1015 23					inc hl	 
1016					 
1016 f1					POP AF 
1017 c1					POP BC 
1018 c9					RET 
1019					 
1019			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1019			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1019			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1019			tohex: 
1019 e5					PUSH HL 
101a d5					PUSH DE 
101b 16 00				LD D, 0 
101d 5f					LD E, A 
101e 21 26 10				LD HL, .DATA 
1021 19					ADD HL, DE 
1022 7e					LD A, (HL) 
1023 d1					POP DE 
1024 e1					POP HL 
1025 c9					RET 
1026			 
1026			.DATA: 
1026 30					DEFB	30h	; 0 
1027 31					DEFB	31h	; 1 
1028 32					DEFB	32h	; 2 
1029 33					DEFB	33h	; 3 
102a 34					DEFB	34h	; 4 
102b 35					DEFB	35h	; 5 
102c 36					DEFB	36h	; 6 
102d 37					DEFB	37h	; 7 
102e 38					DEFB	38h	; 8 
102f 39					DEFB	39h	; 9 
1030 41					DEFB	41h	; A 
1031 42					DEFB	42h	; B 
1032 43					DEFB	43h	; C 
1033 44					DEFB	44h	; D 
1034 45					DEFB	45h	; E 
1035 46					DEFB	46h	; F 
1036			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1036			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1036			;;    subtract $30, if result > 9 then subtract $7 more 
1036			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1036			atohex: 
1036 d6 30				SUB $30 
1038 fe 0a				CP 10 
103a f8					RET M		; If result negative it was 0-9 so we're done 
103b d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
103d c9					RET		 
103e			 
103e			 
103e			 
103e			 
103e			; Get 2 ASCII characters as hex byte from pointer in hl 
103e			 
103e			BYTERD: 
103e 16 00			LD	D,00h		;Set up 
1040 cd 48 10			CALL	HEXCON		;Get byte and convert to hex 
1043 87				ADD	A,A		;First nibble so 
1044 87				ADD	A,A		;multiply by 16 
1045 87				ADD	A,A		; 
1046 87				ADD	A,A		; 
1047 57				LD	D,A		;Save hi nibble in D 
1048			HEXCON: 
1048 7e				ld a, (hl)		;Get next chr 
1049 23				inc hl 
104a d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
104c fe 0a			CP	00Ah		;Is it 0-9 ? 
104e 38 02			JR	C,NALPHA	;If so miss next bit 
1050 d6 07			SUB	007h		;Else convert alpha 
1052			NALPHA: 
1052 b2				OR	D		;Add hi nibble back 
1053 c9				RET			; 
1054			 
1054			 
1054			; 
1054			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1054			; Since the routines get_byte and therefore get_nibble are called, only valid 
1054			; characters (0-9a-f) are accepted. 
1054			; 
1054			;get_word        push    af 
1054			;                call    get_byte        ; Get the upper byte 
1054			;                ld      h, a 
1054			;                call    get_byte        ; Get the lower byte 
1054			;                ld      l, a 
1054			;                pop     af 
1054			;                ret 
1054			; 
1054			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1054			; the routine get_nibble is used only valid characters are accepted - the  
1054			; input routine only accepts characters 0-9a-f. 
1054			; 
1054 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1055 7e					ld a,(hl) 
1056 23					inc hl 
1057 cd 7c 10		                call    nibble2val      ; Get upper nibble 
105a cb 07		                rlc     a 
105c cb 07		                rlc     a 
105e cb 07		                rlc     a 
1060 cb 07		                rlc     a 
1062 47			                ld      b, a            ; Save upper four bits 
1063 7e					ld a,(hl) 
1064 cd 7c 10		                call    nibble2val      ; Get lower nibble 
1067 b0			                or      b               ; Combine both nibbles 
1068 c1			                pop     bc              ; Restore B (and C) 
1069 c9			                ret 
106a			; 
106a			; Get a hexadecimal digit from the serial line. This routine blocks until 
106a			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
106a			; to the serial line interface. The lower 4 bits of A contain the value of  
106a			; that particular digit. 
106a			; 
106a			;get_nibble      ld a,(hl)           ; Read a character 
106a			;                call    to_upper        ; Convert to upper case 
106a			;                call    is_hex          ; Was it a hex digit? 
106a			;                jr      nc, get_nibble  ; No, get another character 
106a			 ;               call    nibble2val      ; Convert nibble to value 
106a			 ;               call    print_nibble 
106a			 ;               ret 
106a			; 
106a			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
106a			; A valid hexadecimal digit is denoted by a set C flag. 
106a			; 
106a			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
106a			;                ret     nc              ; Yes 
106a			;                cp      '0'             ; Less than '0'? 
106a			;                jr      nc, is_hex_1    ; No, continue 
106a			;                ccf                     ; Complement carry (i.e. clear it) 
106a			;                ret 
106a			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
106a			;                ret     c               ; Yes 
106a			;                cp      'A'             ; Less than 'A'? 
106a			;                jr      nc, is_hex_2    ; No, continue 
106a			;                ccf                     ; Yes - clear carry and return 
106a			;                ret 
106a			;is_hex_2        scf                     ; Set carry 
106a			;                ret 
106a			; 
106a			; Convert a single character contained in A to upper case: 
106a			; 
106a fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
106c d8			                ret     c 
106d fe 7b		                cp      'z' + 1         ; > 'z'? 
106f d0			                ret     nc              ; Nothing to do, either 
1070 e6 5f		                and     $5f             ; Convert to upper case 
1072 c9			                ret 
1073			 
1073			 
1073			to_lower: 
1073			 
1073			   ; if char is in [A-Z] make it lower case 
1073			 
1073			   ; enter : a = char 
1073			   ; exit  : a = lower case char 
1073			   ; uses  : af 
1073			 
1073 fe 41		   cp 'A' 
1075 d8			   ret c 
1076			    
1076 fe 5b		   cp 'Z'+1 
1078 d0			   ret nc 
1079			    
1079 f6 20		   or $20 
107b c9			   ret 
107c			 
107c			; 
107c			; Expects a hexadecimal digit (upper case!) in A and returns the 
107c			; corresponding value in A. 
107c			; 
107c fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
107e 38 02		                jr      c, nibble2val_1 ; Yes 
1080 d6 07		                sub     7               ; Adjust for A-F 
1082 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1084 e6 0f		                and     $f              ; Only return lower 4 bits 
1086 c9			                ret 
1087			; 
1087			; Print_nibble prints a single hex nibble which is contained in the lower  
1087			; four bits of A: 
1087			; 
1087			;print_nibble    push    af              ; We won't destroy the contents of A 
1087			;                and     $f              ; Just in case... 
1087			;                add     a, '0'             ; If we have a digit we are done here. 
1087			;                cp      '9' + 1         ; Is the result > 9? 
1087			;                jr      c, print_nibble_1 
1087			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1087			;print_nibble_1  call    putc            ; Print the nibble and 
1087			;                pop     af              ; restore the original value of A 
1087			;                ret 
1087			;; 
1087			;; Send a CR/LF pair: 
1087			; 
1087			;crlf            push    af 
1087			;                ld      a, cr 
1087			;                call    putc 
1087			;                ld      a, lf 
1087			;                call    putc 
1087			;                pop     af 
1087			;                ret 
1087			; 
1087			; Print_word prints the four hex digits of a word to the serial line. The  
1087			; word is expected to be in HL. 
1087			; 
1087			;print_word      push    hl 
1087			;                push    af 
1087			;                ld      a, h 
1087			;                call    print_byte 
1087			;                ld      a, l 
1087			;                call    print_byte 
1087			;                pop     af 
1087			;                pop     hl 
1087			;                ret 
1087			; 
1087			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1087			; The byte to be printed is expected to be in A. 
1087			; 
1087			;print_byte      push    af              ; Save the contents of the registers 
1087			;                push    bc 
1087			;                ld      b, a 
1087			;                rrca 
1087			;                rrca 
1087			;                rrca 
1087			;                rrca 
1087			;                call    print_nibble    ; Print high nibble 
1087			;                ld      a, b 
1087			;                call    print_nibble    ; Print low nibble 
1087			;                pop     bc              ; Restore original register contents 
1087			;                pop     af 
1087			;                ret 
1087			 
1087			 
1087			 
1087			 
1087			 
1087			fourehexhl:  
1087 7e				ld a,(hl) 
1088 cd 36 10			call atohex 
108b cb 3f				SRL A 
108d cb 3f				SRL A 
108f cb 3f				SRL A 
1091 cb 3f				SRL A 
1093 47				ld b, a 
1094 23				inc hl 
1095 7e				ld a,(hl) 
1096 23				inc hl 
1097 cd 36 10			call atohex 
109a 80				add b 
109b 57				ld d,a 
109c 7e				ld a,(hl) 
109d cd 36 10			call atohex 
10a0 cb 3f				SRL A 
10a2 cb 3f				SRL A 
10a4 cb 3f				SRL A 
10a6 cb 3f				SRL A 
10a8 47				ld b, a 
10a9 23				inc hl 
10aa 7e				ld a,(hl) 
10ab 23				inc hl 
10ac cd 36 10			call atohex 
10af 80				add b 
10b0 5f				ld e, a 
10b1 d5				push de 
10b2 e1				pop hl 
10b3 c9				ret 
10b4			 
10b4			; pass hl. returns z set if the byte at hl is a digit 
10b4			;isdigithl:  
10b4			;	push bc 
10b4			;	ld a,(hl) 
10b4			;	cp ':' 
10b4			;	jr nc, .isdf 		; > 
10b4			;	cp '0' 
10b4			;	jr c, .isdf		; < 
10b4			; 
10b4			;	; TODO find a better way to set z 
10b4			; 
10b4			;	ld b,a 
10b4			;	cp b 
10b4			;	pop bc 
10b4			;	ret 
10b4			; 
10b4			;.isdf:	; not digit so clear z 
10b4			; 
10b4			;	; TODO find a better way to unset z 
10b4			; 
10b4			;	ld b,a 
10b4			;	inc b 
10b4			;	cp b 
10b4			; 
10b4			;	pop bc 
10b4			;	ret 
10b4				 
10b4				 
10b4			 
10b4			 
10b4			; pass hl as the four byte address to load 
10b4			 
10b4			get_word_hl:  
10b4 e5				push hl 
10b5 cd 54 10			call get_byte 
10b8				 
10b8 47				ld b, a 
10b9			 
10b9 e1				pop hl 
10ba 23				inc hl 
10bb 23				inc hl 
10bc			 
10bc			; TODO not able to handle a-f  
10bc 7e				ld a,(hl) 
10bd			;	;cp ':' 
10bd			;	cp 'g' 
10bd			;	jr nc, .single_byte_hl 		; > 
10bd			;	cp 'G' 
10bd			;	jr nc, .single_byte_hl 		; > 
10bd			;	cp '0' 
10bd			;	jr c, .single_byte_hl		; < 
10bd			 
10bd				;call isdigithl 
10bd fe 00			cp 0 
10bf 28 06			jr z, .single_byte_hl 
10c1			 
10c1			.getwhln:   ; hex word so get next byte 
10c1			 
10c1 cd 54 10			call get_byte 
10c4 6f				ld l, a 
10c5 60				ld h,b 
10c6 c9				ret 
10c7 68			.single_byte_hl:   ld l,b 
10c8 26 00				ld h,0 
10ca c9					ret 
10cb			 
10cb			 
10cb			 
10cb			 
10cb 21 db 17			ld hl,asc+1 
10ce			;	ld a, (hl) 
10ce			;	call nibble2val 
10ce cd 54 10			call get_byte 
10d1			 
10d1			;	call fourehexhl 
10d1 32 ec e2			ld (scratch+52),a 
10d4				 
10d4 21 ea e2			ld hl,scratch+50 
10d7 22 db e5			ld (os_cur_ptr),hl 
10da			 
10da c9				ret 
10db			 
10db			 
10db			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10db			 
10db			; Decimal Unsigned Version 
10db			 
10db			;Number in a to decimal ASCII 
10db			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10db			;Example: display a=56 as "056" 
10db			;input: a = number 
10db			;Output: a=0,value of a in the screen 
10db			;destroys af,bc (don't know about hl and de) 
10db			DispAToASCII: 
10db 0e 9c			ld	c,-100 
10dd cd e7 10			call	.Na1 
10e0 0e f6			ld	c,-10 
10e2 cd e7 10			call	.Na1 
10e5 0e ff			ld	c,-1 
10e7 06 2f		.Na1:	ld	b,'0'-1 
10e9 04			.Na2:	inc	b 
10ea 81				add	a,c 
10eb 38 fc			jr	c,.Na2 
10ed 91				sub	c		;works as add 100/10/1 
10ee f5				push af		;safer than ld c,a 
10ef 78				ld	a,b		;char is in b 
10f0			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10f0 f1				pop af		;safer than ld a,c 
10f1 c9				ret 
10f2			 
10f2			; Decimal Signed Version 
10f2			 
10f2			; DispA 
10f2			; -------------------------------------------------------------- 
10f2			; Converts a signed integer value to a zero-terminated ASCII 
10f2			; string representative of that value (using radix 10). 
10f2			; -------------------------------------------------------------- 
10f2			; INPUTS: 
10f2			;     HL     Value to convert (two's complement integer). 
10f2			;     DE     Base address of string destination. (pointer). 
10f2			; -------------------------------------------------------------- 
10f2			; OUTPUTS: 
10f2			;     None 
10f2			; -------------------------------------------------------------- 
10f2			; REGISTERS/MEMORY DESTROYED 
10f2			; AF HL 
10f2			; -------------------------------------------------------------- 
10f2			 
10f2			;DispHLToASCII: 
10f2			;   push    de 
10f2			;   push    bc 
10f2			; 
10f2			;; Detect sign of HL. 
10f2			;    bit    7, h 
10f2			;    jr     z, ._DoConvert 
10f2			; 
10f2			;; HL is negative. Output '-' to string and negate HL. 
10f2			;    ld     a, '-' 
10f2			;    ld     (de), a 
10f2			;    inc    de 
10f2			; 
10f2			;; Negate HL (using two's complement) 
10f2			;    xor    a 
10f2			;    sub    l 
10f2			;    ld     l, a 
10f2			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10f2			;    sbc    a, h 
10f2			;    ld     h, a 
10f2			; 
10f2			;; Convert HL to digit characters 
10f2			;._DoConvert: 
10f2			;    ld     b, 0     ; B will count character length of number 
10f2			;-   ld     a, 10 
10f2			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10f2			;    push   af 
10f2			;    inc    b 
10f2			;    ld     a, h 
10f2			;    or     l 
10f2			;    jr     nz, - 
10f2			; 
10f2			;; Retrieve digits from stack 
10f2			;-   pop    af 
10f2			;    or     $30 
10f2			;    ld     (de), a 
10f2			;    inc    de 
10f2			;    djnz   - 
10f2			; 
10f2			;; Terminate string with NULL 
10f2			;    xor    a 
10f2			;    ld     (de), a 
10f2			; 
10f2			;    pop    bc 
10f2			;    pop    de 
10f2			;    ret 
10f2			 
10f2			;Comments 
10f2			; 
10f2			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10f2			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10f2			;    Note that the output string will not be fixed-width. 
10f2			; 
10f2			;Example Usage 
10f2			; 
10f2			;    ld    hl, -1004 
10f2			;    ld    de, OP1 
10f2			;    call  DispA 
10f2			;    ld    hl, OP1 
10f2			;    syscall  PutS 
10f2			 
10f2			 
10f2			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10f2			 
10f2			 
10f2			;Converts an ASCII string to an unsigned 16-bit integer 
10f2			;Quits when it reaches a non-decimal digit 
10f2			 
10f2			string_to_uint16: 
10f2			atoui_16: 
10f2			;Input: 
10f2			;     DE points to the string 
10f2			;Outputs: 
10f2			;     HL is the result 
10f2			;     A is the 8-bit value of the number 
10f2			;     DE points to the byte after the number 
10f2			;Destroys: 
10f2			;     BC 
10f2			;       if the string is non-empty, BC is HL/10 
10f2			;Size:  24 bytes 
10f2			;Speed: 42+d(104+{0,9}) 
10f2			;       d is the number of digits in the number 
10f2			;       max is 640 cycles for a 5 digit number 
10f2			;Assuming no leading zeros: 
10f2			;1 digit:  146cc 
10f2			;2 digit:  250cc 
10f2			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10f2			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10f2			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10f2			;avg: 544.81158447265625cc (544+13297/16384) 
10f2			;=============================================================== 
10f2 21 00 00		  ld hl,0 
10f5			.u16a: 
10f5 1a			  ld a,(de) 
10f6 d6 30		  sub 30h 
10f8 fe 0a		  cp 10 
10fa d0			  ret nc 
10fb 13			  inc de 
10fc 44			  ld b,h 
10fd 4d			  ld c,l 
10fe 29			  add hl,hl 
10ff 29			  add hl,hl 
1100 09			  add hl,bc 
1101 29			  add hl,hl 
1102 85			  add a,l 
1103 6f			  ld l,a 
1104 30 ef		  jr nc,.u16a 
1106 24			  inc h 
1107 c3 f5 10		  jp .u16a 
110a			 
110a			 
110a			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
110a			 
110a			;written by Zeda 
110a			;Converts a 16-bit unsigned integer to an ASCII string. 
110a			 
110a			uitoa_16: 
110a			;Input: 
110a			;   DE is the number to convert 
110a			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
110a			;Output: 
110a			;   HL points to the null-terminated ASCII string 
110a			;      NOTE: This isn't necessarily the same as the input HL. 
110a d5			  push de 
110b c5			  push bc 
110c f5			  push af 
110d eb			  ex de,hl 
110e			 
110e 01 f0 d8		  ld bc,-10000 
1111 3e 2f		  ld a,'0'-1 
1113 3c			  inc a 
1114 09			  add hl,bc  
1115 38 fc		   jr c,$-2 
1117 12			  ld (de),a 
1118 13			  inc de 
1119			 
1119 01 e8 03		  ld bc,1000 
111c 3e 3a		  ld a,'9'+1 
111e 3d			  dec a  
111f 09			  add hl,bc  
1120 30 fc		   jr nc,$-2 
1122 12			  ld (de),a 
1123 13			  inc de 
1124			 
1124 01 9c ff		  ld bc,-100 
1127 3e 2f		  ld a,'0'-1 
1129 3c			  inc a  
112a 09			  add hl,bc  
112b 38 fc		   jr c,$-2 
112d 12			  ld (de),a 
112e 13			  inc de 
112f			 
112f 7d			  ld a,l 
1130 26 3a		  ld h,'9'+1 
1132 25			  dec h  
1133 c6 0a		  add a,10  
1135 30 fb		   jr nc,$-3 
1137 c6 30		  add a,'0' 
1139 eb			  ex de,hl 
113a 72			  ld (hl),d 
113b 23			  inc hl 
113c 77			  ld (hl),a 
113d 23			  inc hl 
113e 36 00		  ld (hl),0 
1140			 
1140			;Now strip the leading zeros 
1140 0e fa		  ld c,-6 
1142 09			  add hl,bc 
1143 3e 30		  ld a,'0' 
1145 23			  inc hl  
1146 be			  cp (hl)  
1147 28 fc		  jr z,$-2 
1149			 
1149			;Make sure that the string is non-empty! 
1149 7e			  ld a,(hl) 
114a b7			  or a 
114b 20 01		  jr nz,.atoub 
114d 2b			  dec hl 
114e			.atoub: 
114e			 
114e f1			  pop af 
114f c1			  pop bc 
1150 d1			  pop de 
1151 c9			  ret 
1152			 
1152			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1152			 
1152			toUpper: 
1152			;A is the char. 
1152			;If A is a lowercase letter, this sets it to the matching uppercase 
1152			;18cc or 30cc or 41cc 
1152			;avg: 26.75cc 
1152 fe 61		  cp 'a' 
1154 d8			  ret c 
1155 fe 7b		  cp 'z'+1 
1157 d0			  ret nc 
1158 d6 20		  sub 'a'-'A' 
115a c9			  ret 
115b			 
115b			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
115b			 
115b			; String Length 
115b			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
115b			 
115b			; Get the length of the null-terminated string starting at $8000 hl 
115b			;    LD     HL, $8000 
115b			 
115b			strlenz: 
115b			 
115b af			    XOR    A               ; Zero is the value we are looking for. 
115c 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
115d 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
115e			                           ; 65, 536 bytes (the entire addressable memory space). 
115e ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1160			 
1160			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1160 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1161 6f			    LD     L, A             ; number of bytes 
1162 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1164 2b			    DEC    HL              ; Compensate for null. 
1165 c9				ret 
1166			 
1166			; Get the length of the A terminated string starting at $8000 hl 
1166			;    LD     HL, $8000 
1166			 
1166			strlent: 
1166			 
1166			                  ; A is the value we are looking for. 
1166 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1168 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
116a			                           ; 65, 536 bytes (the entire addressable memory space). 
116a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
116c			 
116c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
116c 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
116e 2e 00		    LD     L, 0             ; number of bytes 
1170 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1172 2b			    DEC    HL              ; Compensate for null. 
1173 c9				ret 
1174			 
1174			 
1174			;Comparing Strings 
1174			 
1174			;IN    HL     Address of string1. 
1174			;      DE     Address of string2. 
1174			 
1174			; doc given but wrong??? 
1174			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1174			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1174			; tested 
1174			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1174			 
1174			strcmp_old: 
1174 e5			    PUSH   HL 
1175 d5			    PUSH   DE 
1176			 
1176 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1177 be			    CP     (HL)            ; (want to minimize work). 
1178 38 01		    JR     C, Str1IsBigger 
117a 7e			    LD     A, (HL) 
117b			 
117b			Str1IsBigger: 
117b 4f			    LD     C, A             ; Put length in BC 
117c 06 00		    LD     B, 0 
117e 13			    INC    DE              ; Increment pointers to meat of string. 
117f 23			    INC    HL 
1180			 
1180			CmpLoop: 
1180 1a			    LD     A, (DE)          ; Compare bytes. 
1181 ed a1		    CPI 
1183 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1185 13			    INC    DE              ; Update pointer. 
1186 ea 80 11		    JP     PE, CmpLoop 
1189			 
1189 d1			    POP    DE 
118a e1			    POP    HL 
118b 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
118c be			    CP     (HL) 
118d c9			    RET 
118e			 
118e			NoMatch: 
118e 2b			    DEC    HL 
118f be			    CP     (HL)            ; Compare again to affect carry. 
1190 d1			    POP    DE 
1191 e1			    POP    HL 
1192 c9			    RET 
1193			 
1193			;; test strmp 
1193			; 
1193			;ld de, .str1 
1193			;ld hl, .str2 
1193			;call strcmp 
1193			;jr z, .z1 
1193			;;this 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "NZ1" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;.z1: 
1193			; 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "ZZ1" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			; 
1193			;ld de, .str1 
1193			;ld hl, .str1 
1193			;call strcmp 
1193			;jr z, .z2 
1193			;;this 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "NZ2" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;.z2: 
1193			; 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "ZZ2" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			; 
1193			;ld de, .str1 
1193			;ld hl, .str2 
1193			;call strcmp 
1193			;jr c, .c1 
1193			; 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "Nc1" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;.c1: 
1193			;;this 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "cc1" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			; 
1193			;ld de, .str1 
1193			;ld hl, .str1 
1193			;call strcmp 
1193			;jr c, .c2 
1193			;;this 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "Nc2" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;.c2: 
1193			; 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "cc2" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;	NEXTW 
1193			;.str1:   db "string1",0 
1193			;.str2:   db "string2",0 
1193			 
1193			; only care about direct match or not 
1193			; hl and de strings 
1193			; zero set if the same 
1193			 
1193			strcmp: 
1193 1a				ld a, (de) 
1194 be				cp (hl) 
1195 28 02			jr z, .ssame 
1197 b7				or a 
1198 c9				ret 
1199			 
1199			.ssame:  
1199 fe 00			cp 0 
119b c8				ret z 
119c			 
119c 23				inc hl 
119d 13				inc de 
119e 18 f3			jr strcmp 
11a0				 
11a0				 
11a0			 
11a0			;Copyright (c) 2014, Luke Maurits 
11a0			;All rights reserved. 
11a0			; 
11a0			;Redistribution and use in source and binary forms, with or without 
11a0			;modification, are permitted provided that the following conditions are met: 
11a0			; 
11a0			;* Redistributions of source code must retain the above copyright notice, this 
11a0			;  list of conditions and the following disclaimer. 
11a0			; 
11a0			;* Redistributions in binary form must reproduce the above copyright notice, 
11a0			;  this list of conditions and the following disclaimer in the documentation 
11a0			;  and/or other materials provided with the distribution. 
11a0			; 
11a0			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
11a0			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
11a0			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
11a0			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
11a0			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
11a0			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
11a0			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
11a0			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
11a0			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
11a0			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
11a0			 
11a0			; https://github.com/lmaurits/lm512/blob/master/string.z80 
11a0			 
11a0			StrictStrCmp: 
11a0				; Load next chars of each string 
11a0 1a				ld a, (de) 
11a1 47				ld b, a 
11a2 7e				ld a, (hl) 
11a3				; Compare 
11a3 b8				cp b 
11a4				; Return non-zero if chars don't match 
11a4 c0				ret nz 
11a5				; Check for end of both strings 
11a5 fe 00			cp "\0" 
11a7				; Return if strings have ended 
11a7 c8				ret z 
11a8				; Otherwise, advance to next chars 
11a8 23				inc hl 
11a9 13				inc de 
11aa 18 f4			jr StrictStrCmp 
11ac			 
11ac			;end 
11ac			; eof 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			 
# End of file firmware_strings.asm
11ac			include "firmware_memory.asm"   ; malloc and free  
11ac			 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			.mallocsize: db "Wants malloc >256",0 
11ac			.mallocasize: db "MALLOC gives >256",0 
11ac			.malloczero: db "MALLOC gives zero",0 
11ac			 
11ac			malloc_guard_zerolen: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac				ld de, 0 
11ac			        call cmp16 
11ac				jr nz, .lowalloz 
11ac			 
11ac				push hl 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .malloczero 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				call bp_on 
11ac			;	ld a, 0 
11ac			;	ld (os_view_disable), a 
11ac			 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				 
11ac			 
11ac				CALLMONITOR 
11ac			.lowalloz: 
11ac			 
11ac			 
11ac				pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			 
11ac			malloc_guard_entry: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac			 	or a      ;clear carry flag 
11ac				push hl 
11ac				ld de, 255 
11ac				sbc hl, de 
11ac				jr c, .lowalloc 
11ac			 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .mallocsize 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac			;	ld a, 0 
11ac			;	ld (os_view_disable), a 
11ac				call bp_on 
11ac			 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				 
11ac			 
11ac				CALLMONITOR 
11ac				jr .lowdone 
11ac			.lowalloc: 
11ac			 
11ac			 
11ac				pop hl 
11ac			.lowdone:	pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			 
11ac			malloc_guard_exit: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac			 	or a      ;clear carry flag 
11ac				push hl 
11ac				ld de, 255 
11ac				sbc hl, de 
11ac				jr c, .lowallocx 
11ac			 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .mallocasize 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac			;	ld a, 0 
11ac			;	ld (os_view_disable), a 
11ac				call bp_on 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				CALLMONITOR 
11ac				jr .lowdonex 
11ac			.lowallocx: 
11ac			 
11ac				pop hl 
11ac			.lowdonex:	pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			endif 
11ac			 
11ac			if MALLOC_2 
11ac			; Z80 Malloc and Free Functions 
11ac			 
11ac			; Malloc Function: 
11ac			; Input: 
11ac			;   HL: Size of block to allocate 
11ac			; Output: 
11ac			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ac			 
11ac			malloc: 
11ac				 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			call malloc_guard_entry 
11ac			endif 
11ac			 
11ac			 
11ac			 
11ac			 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "mal" 
11ac						CALLMONITOR 
11ac					endif 
11ac			    push af            ; Save AF register 
11ac			    ld a, l            ; Load low byte of size into A 
11ac			    or h               ; Check if size is zero 
11ac			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11ac			 
11ac			    ; Allocate memory 
11ac			    ld hl, (heap_start) ; Load start of heap into HL 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma1" 
11ac						CALLMONITOR 
11ac					endif 
11ac			    call malloc_internal ; Call internal malloc function 
11ac			    pop af             ; Restore AF register 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret                ; Return 
11ac			 
11ac			; Free Function: 
11ac			; Input: 
11ac			;   HL: Pointer to memory block to free 
11ac			; Output: 
11ac			;   None 
11ac			 
11ac			free: 
11ac			    push af            ; Save AF register 
11ac			    ld a, l            ; Load low byte of pointer into A 
11ac			    or h               ; Check if pointer is NULL 
11ac			    jp z, free_exit    ; If pointer is NULL, exit 
11ac			 
11ac			    ; Free memory 
11ac			    ld hl, (heap_start) ; Load start of heap into HL 
11ac			    call free_internal  ; Call internal free function 
11ac			    pop af             ; Restore AF register 
11ac			    ret                ; Return 
11ac			 
11ac			; Internal Malloc Function: 
11ac			; Input: 
11ac			;   HL: Size of block to allocate 
11ac			; Output: 
11ac			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ac			 
11ac			malloc_internal: 
11ac			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11ac			    add hl, bc         ; Add management overhead to requested size 
11ac			    ex de, hl          ; Save total size in DE, and keep it in HL 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma2" 
11ac						CALLMONITOR 
11ac					endif 
11ac			 
11ac			    ; Search for free memory block 
11ac			    ld de, (heap_end)  ; Load end of heap into DE 
11ac			    ld bc, 0           ; Initialize counter 
11ac			 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma2" 
11ac						CALLMONITOR 
11ac					endif 
11ac			malloc_search_loop: 
11ac			    ; Check if current block is free 
11ac			    ld a, (hl)         ; Load current block's status (free or used) 
11ac			    cp 0               ; Compare with zero (free) 
11ac			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11ac			 
11ac			    ; Check if current block is large enough 
11ac			    ld a, (hl+1)       ; Load high byte of block size 
11ac			    cp l               ; Compare with low byte of requested size 
11ac			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11ac			 
11ac			    ld a, (hl+2)       ; Load low byte of block size 
11ac			    cp h               ; Compare with high byte of requested size 
11ac			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11ac			 
11ac			    ; Mark block as used 
11ac			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11ac			 
11ac			    ; Calculate remaining space in block 
11ac			    ld bc, 0           ; Clear BC 
11ac			    add hl, bc         ; Increment HL to point to start of data block 
11ac			    add hl, de         ; HL = HL + DE (total size) 
11ac			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11ac			    add hl, bc         ; Add management overhead to start of data block 
11ac			 
11ac			    ; Save pointer to allocated block in HL 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma5" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			 
11ac			malloc_skip_block_check: 
11ac			    ; Move to the next block 
11ac			    ld bc, 3           ; Size of management overhead 
11ac			    add hl, bc         ; Move to the next block 
11ac			    inc de             ; Increment counter 
11ac			 
11ac			    ; Check if we have reached the end of heap 
11ac			    ld a, e            ; Load low byte of heap end address 
11ac			    cp (hl)            ; Compare with low byte of current address 
11ac			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11ac			    ld a, d            ; Load high byte of heap end address 
11ac			    cp 0               ; Check if it's zero (end of memory) 
11ac			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11ac			 
11ac			    ; If we reached here, allocation failed 
11ac			    xor a              ; Set result to NULL 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma6" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			malloc_exit: 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma7" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			 
11ac			; Internal Free Function: 
11ac			; Input: 
11ac			;   HL: Pointer to memory block to free 
11ac			; Output: 
11ac			;   None 
11ac			 
11ac			free_internal: 
11ac			    ld de, (heap_start) ; Load start of heap into DE 
11ac			    ld bc, 0            ; Initialize counter 
11ac			 
11ac			free_search_loop: 
11ac			    ; Check if current block contains the pointer 
11ac			    ld a, l             ; Load low byte of pointer 
11ac			    cp (hl+1)           ; Compare with high byte of current block's address 
11ac			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ac			    ld a, h             ; Load high byte of pointer 
11ac			    cp (hl+2)           ; Compare with low byte of current block's address 
11ac			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ac			 
11ac			    ; Mark block as free 
11ac			    ld (hl), 0          ; Set status byte to indicate free block 
11ac			    ret                 ; Return 
11ac			 
11ac			free_skip_block_check: 
11ac			    ; Move to the next block 
11ac			    ld bc, 3            ; Size of management overhead 
11ac			    add hl, bc          ; Move to the next block 
11ac			    inc de              ; Increment counter 
11ac			 
11ac			    ; Check if we have reached the end of heap 
11ac			    ld a, e             ; Load low byte of heap end address 
11ac			    cp (hl)             ; Compare with low byte of current address 
11ac			    jr nz, free_search_loop  ; If not equal, continue searching 
11ac			    ld a, d             ; Load high byte of heap end address 
11ac			    cp 0                ; Check if it's zero (end of memory) 
11ac			    jr nz, free_search_loop  ; If not zero, continue searching 
11ac			 
11ac			    ; If we reached here, pointer is not found in heap 
11ac			    ret 
11ac			 
11ac			free_exit: 
11ac			    ret                 ; Return 
11ac			 
11ac			; Define heap start and end addresses 
11ac			;heap_start:    .dw 0xC000   ; Start of heap 
11ac			;heap_end:      .dw 0xE000   ; End of heap 
11ac			 
11ac			endif 
11ac			 
11ac			 
11ac			if MALLOC_1 
11ac			 
11ac			 
11ac			 
11ac			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11ac			 
11ac			;moved to firmware.asm 
11ac			;heap_start        .equ  0x9000      ; Starting address of heap 
11ac			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11ac			 
11ac			;      .org 0 
11ac			;      jp    main 
11ac			 
11ac			 
11ac			;      .org  0x100 
11ac			;main: 
11ac			;      ld    HL, 0x8100 
11ac			;      ld    SP, HL 
11ac			; 
11ac			;      call  heap_init 
11ac			; 
11ac			;      ; Make some allocations 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9004 
11ac			; 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9014 
11ac			; 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9024 
11ac			; 
11ac			;      ; Free some allocations 
11ac			;      ld    HL, 0x9014 
11ac			;      call  free 
11ac			; 
11ac			;      ld    HL, 0x9004 
11ac			;      call  free 
11ac			; 
11ac			;      ld    HL, 0x9024 
11ac			;      call  free 
11ac			; 
11ac			; 
11ac			;      halt 
11ac			 
11ac			 
11ac			;------------------------------------------------------------------------------ 
11ac			;     heap_init                                                               : 
11ac			;                                                                             : 
11ac			; Description                                                                 : 
11ac			;     Initialise the heap and make it ready for malloc and free operations.   : 
11ac			;                                                                             : 
11ac			;     The heap is maintained as a linked list, starting with an initial       : 
11ac			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11ac			;     the first free block in the heap. Each block then points to the next    : 
11ac			;     free block within the heap, and the free list ends at the first block   : 
11ac			;     with a null pointer to the next free block.                             : 
11ac			;                                                                             : 
11ac			; Parameters                                                                  : 
11ac			;     Inputs are compile-time only. Two defines which specify the starting    : 
11ac			;     address of the heap and its size are required, along with a memory      : 
11ac			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11ac			;     principally stores a pointer to the first free block in the heap.       : 
11ac			;                                                                             : 
11ac			; Returns                                                                     : 
11ac			;     Nothing                                                                 : 
11ac			;------------------------------------------------------------------------------ 
11ac			heap_init: 
11ac e5			      push  HL 
11ad			 
11ad			      ; Initialise free list struct 
11ad 21 62 65		      ld    HL, heap_start 
11b0 22 5d 65		      ld    (free_list), HL 
11b3 21 00 00		      ld    HL, 0 
11b6 22 5f 65		      ld    (free_list+2), HL 
11b9			 
11b9			      ; Insert first free block at bottom of heap, consumes entire heap 
11b9 21 8f e2		      ld    HL, heap_start+heap_size-4 
11bc 22 62 65		      ld    (heap_start), HL        ; Next block (end of free list) 
11bf 21 2d 7d		      ld    HL, heap_size-4 
11c2 22 64 65		      ld    (heap_start+2), HL      ; Block size 
11c5			 
11c5			      ; Insert end of free list block at top of heap - two null words will 
11c5			      ; terminate the free list 
11c5 21 00 00		      ld    HL, 0 
11c8 22 91 e2		      ld    (heap_start+heap_size-2), HL 
11cb 22 8f e2		      ld    (heap_start+heap_size-4), HL 
11ce			 
11ce e1			      pop   HL 
11cf			 
11cf c9			      ret 
11d0			 
11d0			 
11d0			;------------------------------------------------------------------------------ 
11d0			;     malloc                                                                  : 
11d0			;                                                                             : 
11d0			; Description                                                                 : 
11d0			;     Allocates the wanted space from the heap and returns the address of the : 
11d0			;     first useable byte of the allocation.                                   : 
11d0			;                                                                             : 
11d0			;     Allocations can happen in one of two ways:                              : 
11d0			;                                                                             : 
11d0			;     1. A free block may be found which is the exact size wanted. In this    : 
11d0			;        case the block is removed from the free list and retuedn to the      : 
11d0			;        caller.                                                              : 
11d0			;     2. A free block may be found which is larger than the size wanted. In   : 
11d0			;        this case, the larger block is split into two. The first portion of  : 
11d0			;        this block will become the requested space by the malloc call and    : 
11d0			;        is returned to the caller. The second portion becomes a new free     : 
11d0			;        block, and the free list is adjusted to maintain continuity via this : 
11d0			;        newly created block.                                                 : 
11d0			;                                                                             : 
11d0			;     malloc does not set any initial value in the allocated space, the       : 
11d0			;     caller is required to do this as required.                              : 
11d0			;                                                                             : 
11d0			;     This implementation of malloc uses the stack exclusively, and is        : 
11d0			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11d0			;     advisable to disable interrupts before calling malloc, and recommended  : 
11d0			;     to avoid the use of malloc inside ISRs in general.                      : 
11d0			;                                                                             : 
11d0			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11d0			;                                                                             : 
11d0			; Parameters                                                                  : 
11d0			;     HL  Number of bytes wanted                                              : 
11d0			;                                                                             : 
11d0			; Returns                                                                     : 
11d0			;     HL  Address of the first useable byte of the allocation                 : 
11d0			;                                                                             : 
11d0			; Flags                                                                       : 
11d0			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11d0			;                                                                             : 
11d0			; Stack frame                                                                 : 
11d0			;       |             |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     BC      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     DE      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     IX      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |  prev_free  |                                                       : 
11d0			;   +4  +-------------+                                                       : 
11d0			;       |  this_free  |                                                       : 
11d0			;   +2  +-------------+                                                       : 
11d0			;       |  next_free  |                                                       : 
11d0			;   +0  +-------------+                                                       : 
11d0			;       |             |                                                       : 
11d0			;                                                                             : 
11d0			;------------------------------------------------------------------------------ 
11d0			 
11d0			 
11d0			;malloc: 
11d0			; 
11d0			;	SAVESP ON 1 
11d0			; 
11d0			;	call malloc_code 
11d0			; 
11d0			;	CHECKSP ON 1 
11d0			;	ret 
11d0			 
11d0			 
11d0			malloc: 
11d0 c5			      push  BC 
11d1 d5			      push  DE 
11d2 dd e5		      push  IX 
11d4			if DEBUG_FORTH_MALLOC_HIGH 
11d4			call malloc_guard_entry 
11d4			endif 
11d4			 
11d4					if DEBUG_FORTH_MALLOC 
11d4						DMARK "mal" 
11d4						CALLMONITOR 
11d4					endif 
11d4 7c			      ld    A, H                    ; Exit if no space requested 
11d5 b5			      or    L 
11d6 ca 95 12		      jp    Z, malloc_early_exit 
11d9			 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			; 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			 
11d9			 
11d9			 
11d9			 
11d9					if DEBUG_FORTH_MALLOC 
11d9						DMARK "maA" 
11d9						CALLMONITOR 
11d9					endif 
11d9			      ; Set up stack frame 
11d9 eb			      ex    DE, HL 
11da 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11dd 39			      add   HL, SP 
11de f9			      ld    SP, HL 
11df dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11e3 dd 39		      add   IX, SP 
11e5			 
11e5			      ; Setup initial state 
11e5 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e8 19			      add   HL, DE 
11e9			 
11e9 44			      ld    B, H                    ; Move want to BC 
11ea 4d			      ld    C, L 
11eb			 
11eb 21 5d 65		      ld    HL, free_list           ; Store prev_free ptr to stack 
11ee dd 75 04		      ld    (IX+4), L 
11f1 dd 74 05		      ld    (IX+5), H 
11f4			 
11f4 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f5 23			      inc   HL 
11f6 56			      ld    D, (HL) 
11f7 dd 73 02		      ld    (IX+2), E 
11fa dd 72 03		      ld    (IX+3), D 
11fd eb			      ex    DE, HL                  ; this_free ptr into HL 
11fe			 
11fe					if DEBUG_FORTH_MALLOC 
11fe						DMARK "maB" 
11fe						CALLMONITOR 
11fe					endif 
11fe			      ; Loop through free block list to find some space 
11fe			malloc_find_space: 
11fe 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11ff 23			      inc   HL 
1200 56			      ld    D, (HL) 
1201			 
1201 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1202 b3			      or    E 
1203 ca 8f 12		      jp    Z, malloc_no_space 
1206			 
1206 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1209 dd 72 01		      ld    (IX+1), D 
120c			 
120c			      ; Does this block have enough space to make the allocation? 
120c 23			      inc   HL                      ; Load free block size into DE 
120d 5e			      ld    E, (HL) 
120e 23			      inc   HL 
120f 56			      ld    D, (HL) 
1210			 
1210 eb			      ex    DE, HL                  ; Check size of block against want 
1211 b7			      or    A                       ; Ensure carry flag clear 
1212 ed 42		      sbc   HL, BC 
1214 e5			      push  HL                      ; Store the result for later (new block size) 
1215			 
1215 ca 64 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1218 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
121a			 
121a			      ; this_free block is not big enough, setup ptrs to test next free block 
121a e1			      pop   HL                      ; Discard previous result 
121b			 
121b dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
121e dd 66 03		      ld    H, (IX+3) 
1221 dd 75 04		      ld    (IX+4), L 
1224 dd 74 05		      ld    (IX+5), H 
1227			 
1227 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
122a dd 66 01		      ld    H, (IX+1) 
122d dd 75 02		      ld    (IX+2), L 
1230 dd 74 03		      ld    (IX+3), H 
1233			 
1233					if DEBUG_FORTH_MALLOC 
1233						DMARK "MA>" 
1233						CALLMONITOR 
1233					endif 
1233 18 c9		      jr    malloc_find_space 
1235			 
1235			      ; split a bigger block into two - requested size and remaining size 
1235			malloc_alloc_split: 
1235					if DEBUG_FORTH_MALLOC 
1235						DMARK "MAs" 
1235						CALLMONITOR 
1235					endif 
1235 eb			      ex    DE, HL                  ; Calculate address of new free block 
1236 2b			      dec   HL 
1237 2b			      dec   HL 
1238 2b			      dec   HL 
1239 09			      add   HL, BC 
123a			 
123a			      ; Create a new block and point it at next_free 
123a dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
123d dd 56 01		      ld    D, (IX+1) 
1240			 
1240 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1241 23			      inc   HL 
1242 72			      ld    (HL), D 
1243			 
1243 d1			      pop   DE                      ; Store size of new block into new block 
1244 23			      inc   HL 
1245 73			      ld    (HL), E 
1246 23			      inc   HL 
1247 72			      ld    (HL), D 
1248			 
1248			      ; Update this_free ptr to point to new block 
1248 2b			      dec   HL 
1249 2b			      dec   HL 
124a 2b			      dec   HL 
124b			 
124b dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
124e dd 56 03		      ld    D, (IX+3) 
1251			 
1251 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1254 dd 74 03		      ld    (IX+3), H 
1257			 
1257			      ; Modify this_free block to be allocation 
1257 eb			      ex    DE, HL 
1258 af			      xor   A                       ; Null the next block ptr of allocated block 
1259 77			      ld    (HL), A 
125a 23			      inc   HL 
125b 77			      ld    (HL), A 
125c			 
125c 23			      inc   HL                      ; Store want size into allocated block 
125d 71			      ld    (HL), C 
125e 23			      inc   HL 
125f 70			      ld    (HL), B 
1260 23			      inc   HL 
1261 e5			      push  HL                      ; Address of allocation to return 
1262			 
1262 18 19		      jr    malloc_update_links 
1264			 
1264			malloc_alloc_fit: 
1264 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1265			 
1265					if DEBUG_FORTH_MALLOC 
1265						DMARK "MAf" 
1265						CALLMONITOR 
1265					endif 
1265			      ; Modify this_free block to be allocation 
1265 eb			      ex    DE, HL 
1266 2b			      dec   HL 
1267 2b			      dec   HL 
1268 2b			      dec   HL 
1269			 
1269 af			      xor   A                       ; Null the next block ptr of allocated block 
126a 77			      ld    (HL), A 
126b 23			      inc   HL 
126c 77			      ld    (HL), A 
126d			 
126d 23			      inc   HL                      ; Store address of allocation to return 
126e 23			      inc   HL 
126f 23			      inc   HL 
1270 e5			      push  HL 
1271			 
1271			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1271 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1274 dd 66 01		      ld    H, (IX+1) 
1277			 
1277 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
127a dd 74 03		      ld    (IX+3), H 
127d			 
127d			 
127d			malloc_update_links: 
127d			      ; Update prev_free ptr to point to this_free 
127d dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1280 dd 66 05		      ld    H, (IX+5) 
1283			 
1283 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1286 dd 56 03		      ld    D, (IX+3) 
1289			 
1289 73			      ld    (HL), E                 ; this_free ptr into prev_free 
128a 23			      inc   HL 
128b 72			      ld    (HL), D 
128c			 
128c					if DEBUG_FORTH_MALLOC 
128c						DMARK "Mul" 
128c						CALLMONITOR 
128c					endif 
128c			      ; Clear the Z flag to indicate successful allocation 
128c 7a			      ld    A, D 
128d b3			      or    E 
128e			 
128e d1			      pop   DE                      ; Address of allocation 
128f					if DEBUG_FORTH_MALLOC 
128f						DMARK "MAu" 
128f						CALLMONITOR 
128f					endif 
128f			 
128f			malloc_no_space: 
128f 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1292 39			      add   HL, SP 
1293 f9			      ld    SP, HL 
1294			 
1294 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "MAN" 
1295						CALLMONITOR 
1295					endif 
1295			 
1295			malloc_early_exit: 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "MAx" 
1295						CALLMONITOR 
1295					endif 
1295 dd e1		      pop   IX 
1297 d1			      pop   DE 
1298 c1			      pop   BC 
1299			 
1299			if DEBUG_FORTH_MALLOC_HIGH 
1299			call malloc_guard_exit 
1299			call malloc_guard_zerolen 
1299			endif 
1299 c9			      ret 
129a			 
129a			 
129a			;------------------------------------------------------------------------------ 
129a			;     free                                                                    : 
129a			;                                                                             : 
129a			; Description                                                                 : 
129a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
129a			;     returned by malloc, otherwise the behaviour is undefined.               : 
129a			;                                                                             : 
129a			;     Where possible, directly adjacent free blocks will be merged together   : 
129a			;     into larger blocks to help ensure that the heap does not become         : 
129a			;     excessively fragmented.                                                 : 
129a			;                                                                             : 
129a			;     free does not clear or set any other value into the freed space, and    : 
129a			;     therefore its contents may be visible through subsequent malloc's. The  : 
129a			;     caller should clear the freed space as required.                        : 
129a			;                                                                             : 
129a			;     This implementation of free uses the stack exclusively, and is          : 
129a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
129a			;     advisable to disable interrupts before calling free, and recommended    : 
129a			;     to avoid the use of free inside ISRs in general.                        : 
129a			;                                                                             : 
129a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
129a			;                                                                             : 
129a			; Parameters                                                                  : 
129a			;     HL  Pointer to address of first byte of allocation to be freed          : 
129a			;                                                                             : 
129a			; Returns                                                                     : 
129a			;     Nothing                                                                 : 
129a			;                                                                             : 
129a			; Stack frame                                                                 : 
129a			;       |             |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     BC      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     DE      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     IX      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |  prev_free  |                                                       : 
129a			;   +2  +-------------+                                                       : 
129a			;       |  next_free  |                                                       : 
129a			;   +0  +-------------+                                                       : 
129a			;       |             |                                                       : 
129a			;                                                                             : 
129a			;------------------------------------------------------------------------------ 
129a			free: 
129a c5			      push  BC 
129b d5			      push  DE 
129c dd e5		      push  IX 
129e			 
129e 7c			      ld    A, H                    ; Exit if ptr is null 
129f b5			      or    L 
12a0 ca 64 13		      jp    Z, free_early_exit 
12a3			 
12a3			      ; Set up stack frame 
12a3 eb			      ex    DE, HL 
12a4 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12a7 39			      add   HL, SP 
12a8 f9			      ld    SP, HL 
12a9 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12ad dd 39		      add   IX, SP 
12af			 
12af			      ; The address in HL points to the start of the useable allocated space, 
12af			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12af			      ; address of the block itself. 
12af eb			      ex    DE, HL 
12b0 11 fc ff		      ld    DE, -4 
12b3 19			      add   HL, DE 
12b4			 
12b4			      ; An allocated block must have a null next block pointer in it 
12b4 7e			      ld    A, (HL) 
12b5 23			      inc   HL 
12b6 b6			      or    (HL) 
12b7 c2 5f 13		      jp    NZ, free_done 
12ba			 
12ba 2b			      dec   HL 
12bb			 
12bb 44			      ld    B, H                    ; Copy HL to BC 
12bc 4d			      ld    C, L 
12bd			 
12bd			      ; Loop through the free list to find the first block with an address 
12bd			      ; higher than the block being freed 
12bd 21 5d 65		      ld    HL, free_list 
12c0			 
12c0			free_find_higher_block: 
12c0 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12c1 23			      inc   HL 
12c2 56			      ld    D, (HL) 
12c3 2b			      dec   HL 
12c4			 
12c4 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12c7 dd 72 01		      ld    (IX+1), D 
12ca dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12cd dd 74 03		      ld    (IX+3), H 
12d0			 
12d0 78			      ld    A, B                    ; Check if DE is greater than BC 
12d1 ba			      cp    D                       ; Compare MSB first 
12d2 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12d4 30 04		      jr    NC, free_find_higher_block_skip 
12d6 79			      ld    A, C 
12d7 bb			      cp    E                       ; Then compare LSB 
12d8 38 08		      jr    C, free_found_higher_block 
12da			 
12da			free_find_higher_block_skip: 
12da 7a			      ld    A, D                    ; Reached the end of the free list? 
12db b3			      or    E 
12dc ca 5f 13		      jp    Z, free_done 
12df			 
12df eb			      ex    DE, HL 
12e0			 
12e0 18 de		      jr    free_find_higher_block 
12e2			 
12e2			free_found_higher_block: 
12e2			      ; Insert freed block between prev and next free blocks 
12e2 71			      ld    (HL), C                 ; Point prev free block to freed block 
12e3 23			      inc   HL 
12e4 70			      ld    (HL), B 
12e5			 
12e5 60			      ld    H, B                    ; Point freed block at next free block 
12e6 69			      ld    L, C 
12e7 73			      ld    (HL), E 
12e8 23			      inc   HL 
12e9 72			      ld    (HL), D 
12ea			 
12ea			      ; Check if the freed block is adjacent to the next free block 
12ea 23			      inc   HL                      ; Load size of freed block into HL 
12eb 5e			      ld    E, (HL) 
12ec 23			      inc   HL 
12ed 56			      ld    D, (HL) 
12ee eb			      ex    DE, HL 
12ef			 
12ef 09			      add   HL, BC                  ; Add addr of freed block and its size 
12f0			 
12f0 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12f3 dd 56 01		      ld    D, (IX+1) 
12f6			 
12f6 b7			      or    A                       ; Clear the carry flag 
12f7 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f9 20 22		      jr    NZ, free_check_adjacent_to_prev 
12fb			 
12fb			      ; Freed block is adjacent to next, merge into one bigger block 
12fb eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12fc 5e			      ld    E, (HL) 
12fd 23			      inc   HL 
12fe 56			      ld    D, (HL) 
12ff e5			      push  HL                      ; Save ptr to next block for later 
1300			 
1300 60			      ld    H, B                    ; Store ptr from next block into freed block 
1301 69			      ld    L, C 
1302 73			      ld    (HL), E 
1303 23			      inc   HL 
1304 72			      ld    (HL), D 
1305			 
1305 e1			      pop   HL                      ; Restore ptr to next block 
1306 23			      inc   HL                      ; Load size of next block into DE 
1307 5e			      ld    E, (HL) 
1308 23			      inc   HL 
1309 56			      ld    D, (HL) 
130a d5			      push  DE                      ; Save next block size for later 
130b			 
130b 60			      ld    H, B                    ; Load size of freed block into HL 
130c 69			      ld    L, C 
130d 23			      inc   HL 
130e 23			      inc   HL 
130f 5e			      ld    E, (HL) 
1310 23			      inc   HL 
1311 56			      ld    D, (HL) 
1312 eb			      ex    DE, HL 
1313			 
1313 d1			      pop   DE                      ; Restore size of next block 
1314 19			      add   HL, DE                  ; Add sizes of both blocks 
1315 eb			      ex    DE, HL 
1316			 
1316 60			      ld    H, B                    ; Store new bigger size into freed block 
1317 69			      ld    L, C 
1318 23			      inc   HL 
1319 23			      inc   HL 
131a 73			      ld    (HL), E 
131b 23			      inc   HL 
131c 72			      ld    (HL), D 
131d			 
131d			free_check_adjacent_to_prev: 
131d			      ; Check if the freed block is adjacent to the prev free block 
131d dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1320 dd 66 03		      ld    H, (IX+3) 
1323			 
1323 23			      inc   HL                      ; Size of prev free block into DE 
1324 23			      inc   HL 
1325 5e			      ld    E, (HL) 
1326 23			      inc   HL 
1327 56			      ld    D, (HL) 
1328 2b			      dec   HL 
1329 2b			      dec   HL 
132a 2b			      dec   HL 
132b			 
132b 19			      add   HL, DE                  ; Add prev block addr and size 
132c			 
132c b7			      or    A                       ; Clear the carry flag 
132d ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132f 20 2e		      jr    NZ, free_done 
1331			 
1331			      ; Freed block is adjacent to prev, merge into one bigger block 
1331 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1332 69			      ld    L, C 
1333 5e			      ld    E, (HL) 
1334 23			      inc   HL 
1335 56			      ld    D, (HL) 
1336 e5			      push  HL                      ; Save freed block ptr for later 
1337			 
1337 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
133a dd 66 03		      ld    H, (IX+3) 
133d 73			      ld    (HL), E 
133e 23			      inc   HL 
133f 72			      ld    (HL), D 
1340			 
1340 e1			      pop   HL                      ; Restore freed block ptr 
1341 23			      inc   HL                      ; Load size of freed block into DE 
1342 5e			      ld    E, (HL) 
1343 23			      inc   HL 
1344 56			      ld    D, (HL) 
1345 d5			      push  DE                      ; Save freed block size for later 
1346			 
1346 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1349 dd 66 03		      ld    H, (IX+3) 
134c 23			      inc   HL 
134d 23			      inc   HL 
134e 5e			      ld    E, (HL) 
134f 23			      inc   HL 
1350 56			      ld    D, (HL) 
1351			 
1351 e1			      pop   HL                      ; Add sizes of both blocks 
1352 19			      add   HL, DE 
1353 eb			      ex    DE, HL 
1354			 
1354 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1357 dd 66 03		      ld    H, (IX+3) 
135a 23			      inc   HL 
135b 23			      inc   HL 
135c 73			      ld    (HL), E 
135d 23			      inc   HL 
135e 72			      ld    (HL), D 
135f			 
135f			free_done: 
135f 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1362 39			      add   HL, SP 
1363 f9			      ld    SP, HL 
1364			 
1364			free_early_exit: 
1364 dd e1		      pop   IX 
1366 d1			      pop   DE 
1367 c1			      pop   BC 
1368			 
1368 c9			      ret 
1369			 
1369			; moved to firmware.asm 
1369			; 
1369			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1369			;                  .dw   0 
1369			 
1369			 
1369			endif 
1369			 
1369			 
1369			if MALLOC_3 
1369			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1369			;heap_start        .equ  0x9000      ; Starting address of heap 
1369			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1369			; 
1369			 ;     .org 0 
1369			  ;    jp    main 
1369			; 
1369			; 
1369			 ;     .org  0x100 
1369			;main: 
1369			 ;     ld    HL, 0x8100 
1369			  ;    ld    SP, HL 
1369			; 
1369			;      call  heap_init 
1369			 
1369			      ; Make some allocations 
1369			;      ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9004 
1369			; 
1369			 ;     ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9014 
1369			 
1369			;      ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9024 
1369			 
1369			      ; Free some allocations 
1369			;      ld    HL, 0x9014 
1369			;      call  free 
1369			 
1369			;      ld    HL, 0x9004 
1369			;      call  free 
1369			; 
1369			;      ld    HL, 0x9024 
1369			;      call  free 
1369			 
1369			 
1369			 ;     halt 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     heap_init                                                               : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Initialise the heap and make it ready for malloc and free operations.   : 
1369			;                                                                             : 
1369			;     The heap is maintained as a linked list, starting with an initial       : 
1369			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1369			;     the first free block in the heap. Each block then points to the next    : 
1369			;     free block within the heap, and the free list ends at the first block   : 
1369			;     with a null pointer to the next free block.                             : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     Inputs are compile-time only. Two defines which specify the starting    : 
1369			;     address of the heap and its size are required, along with a memory      : 
1369			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1369			;     principally stores a pointer to the first free block in the heap.       : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     Nothing                                                                 : 
1369			;------------------------------------------------------------------------------ 
1369			heap_init: 
1369			      push  HL 
1369			 
1369			      ; Initialise free list struct 
1369			      ld    HL, heap_start 
1369			      ld    (free_list), HL 
1369			      ld    HL, 0 
1369			      ld    (free_list+2), HL 
1369			 
1369			      ; Insert first free block at bottom of heap, consumes entire heap 
1369			      ld    HL, heap_start+heap_size-4 
1369			      ld    (heap_start), HL        ; Next block (end of free list) 
1369			      ld    HL, heap_size-4 
1369			      ld    (heap_start+2), HL      ; Block size 
1369			 
1369			      ; Insert end of free list block at top of heap - two null words will 
1369			      ; terminate the free list 
1369			      ld    HL, 0 
1369			      ld    (heap_start+heap_size-2), HL 
1369			      ld    (heap_start+heap_size-4), HL 
1369			 
1369			      pop   HL 
1369			 
1369			      ret 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     malloc                                                                  : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Allocates the wanted space from the heap and returns the address of the : 
1369			;     first useable byte of the allocation.                                   : 
1369			;                                                                             : 
1369			;     Allocations can happen in one of two ways:                              : 
1369			;                                                                             : 
1369			;     1. A free block may be found which is the exact size wanted. In this    : 
1369			;        case the block is removed from the free list and retuedn to the      : 
1369			;        caller.                                                              : 
1369			;     2. A free block may be found which is larger than the size wanted. In   : 
1369			;        this case, the larger block is split into two. The first portion of  : 
1369			;        this block will become the requested space by the malloc call and    : 
1369			;        is returned to the caller. The second portion becomes a new free     : 
1369			;        block, and the free list is adjusted to maintain continuity via this : 
1369			;        newly created block.                                                 : 
1369			;                                                                             : 
1369			;     malloc does not set any initial value in the allocated space, the       : 
1369			;     caller is required to do this as required.                              : 
1369			;                                                                             : 
1369			;     This implementation of malloc uses the stack exclusively, and is        : 
1369			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1369			;     advisable to disable interrupts before calling malloc, and recommended  : 
1369			;     to avoid the use of malloc inside ISRs in general.                      : 
1369			;                                                                             : 
1369			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     HL  Number of bytes wanted                                              : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     HL  Address of the first useable byte of the allocation                 : 
1369			;                                                                             : 
1369			; Flags                                                                       : 
1369			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1369			;                                                                             : 
1369			; Stack frame                                                                 : 
1369			;       |             |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     BC      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     DE      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     IX      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |  prev_free  |                                                       : 
1369			;   +4  +-------------+                                                       : 
1369			;       |  this_free  |                                                       : 
1369			;   +2  +-------------+                                                       : 
1369			;       |  next_free  |                                                       : 
1369			;   +0  +-------------+                                                       : 
1369			;       |             |                                                       : 
1369			;                                                                             : 
1369			;------------------------------------------------------------------------------ 
1369			malloc: 
1369			      push  BC 
1369			      push  DE 
1369			      push  IX 
1369			 
1369			      ld    A, H                    ; Exit if no space requested 
1369			      or    L 
1369			      jp    Z, malloc_early_exit 
1369			 
1369			      ; Set up stack frame 
1369			      ex    DE, HL 
1369			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			      ld    IX, 0                   ; Use IX as a frame pointer 
1369			      add   IX, SP 
1369			 
1369			      ; Setup initial state 
1369			      ld    HL, 4                   ; want must also include space used by block struct 
1369			      add   HL, DE 
1369			 
1369			      ld    B, H                    ; Move want to BC 
1369			      ld    C, L 
1369			 
1369			      ld    HL, free_list           ; Store prev_free ptr to stack 
1369			      ld    (IX+4), L 
1369			      ld    (IX+5), H 
1369			 
1369			      ld    E, (HL)                 ; Store this_free ptr to stack 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ld    (IX+2), E 
1369			      ld    (IX+3), D 
1369			      ex    DE, HL                  ; this_free ptr into HL 
1369			 
1369			      ; Loop through free block list to find some space 
1369			malloc_find_space: 
1369			      ld    E, (HL)                 ; Load next_free ptr into DE 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1369			      or    E 
1369			      jp    Z, malloc_no_space 
1369			 
1369			      ld    (IX+0), E               ; Store next_free ptr to stack 
1369			      ld    (IX+1), D 
1369			 
1369			      ; Does this block have enough space to make the allocation? 
1369			      inc   HL                      ; Load free block size into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      ex    DE, HL                  ; Check size of block against want 
1369			      or    A                       ; Ensure carry flag clear 
1369			      sbc   HL, BC 
1369			      push  HL                      ; Store the result for later (new block size) 
1369			 
1369			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1369			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1369			 
1369			      ; this_free block is not big enough, setup ptrs to test next free block 
1369			      pop   HL                      ; Discard previous result 
1369			 
1369			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1369			      ld    H, (IX+3) 
1369			      ld    (IX+4), L 
1369			      ld    (IX+5), H 
1369			 
1369			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1369			      ld    H, (IX+1) 
1369			      ld    (IX+2), L 
1369			      ld    (IX+3), H 
1369			 
1369			      jr    malloc_find_space 
1369			 
1369			      ; split a bigger block into two - requested size and remaining size 
1369			malloc_alloc_split: 
1369			      ex    DE, HL                  ; Calculate address of new free block 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			      add   HL, BC 
1369			 
1369			      ; Create a new block and point it at next_free 
1369			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1369			      ld    D, (IX+1) 
1369			 
1369			      ld    (HL), E                 ; Store next_free ptr into new block 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   DE                      ; Store size of new block into new block 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Update this_free ptr to point to new block 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1369			      ld    D, (IX+3) 
1369			 
1369			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1369			      ld    (IX+3), H 
1369			 
1369			      ; Modify this_free block to be allocation 
1369			      ex    DE, HL 
1369			      xor   A                       ; Null the next block ptr of allocated block 
1369			      ld    (HL), A 
1369			      inc   HL 
1369			      ld    (HL), A 
1369			 
1369			      inc   HL                      ; Store want size into allocated block 
1369			      ld    (HL), C 
1369			      inc   HL 
1369			      ld    (HL), B 
1369			      inc   HL 
1369			      push  HL                      ; Address of allocation to return 
1369			 
1369			      jr    malloc_update_links 
1369			 
1369			malloc_alloc_fit: 
1369			      pop   HL                      ; Dont need new block size, want is exact fit 
1369			 
1369			      ; Modify this_free block to be allocation 
1369			      ex    DE, HL 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      xor   A                       ; Null the next block ptr of allocated block 
1369			      ld    (HL), A 
1369			      inc   HL 
1369			      ld    (HL), A 
1369			 
1369			      inc   HL                      ; Store address of allocation to return 
1369			      inc   HL 
1369			      inc   HL 
1369			      push  HL 
1369			 
1369			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1369			      ld    L, (IX+0)               ; next_free to HL 
1369			      ld    H, (IX+1) 
1369			 
1369			      ld    (IX+2), L               ; HL to this_free 
1369			      ld    (IX+3), H 
1369			 
1369			 
1369			malloc_update_links: 
1369			      ; Update prev_free ptr to point to this_free 
1369			      ld    L, (IX+4)               ; prev_free ptr to HL 
1369			      ld    H, (IX+5) 
1369			 
1369			      ld    E, (IX+2)               ; this_free ptr to DE 
1369			      ld    D, (IX+3) 
1369			 
1369			      ld    (HL), E                 ; this_free ptr into prev_free 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Clear the Z flag to indicate successful allocation 
1369			      ld    A, D 
1369			      or    E 
1369			 
1369			      pop   DE                      ; Address of allocation 
1369			 
1369			malloc_no_space: 
1369			      ld    HL, 6                   ; Clean up stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			 
1369			      ex    DE, HL                  ; Alloc addr into HL for return 
1369			 
1369			malloc_early_exit: 
1369			      pop   IX 
1369			      pop   DE 
1369			      pop   BC 
1369			 
1369			      ret 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     free                                                                    : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1369			;     returned by malloc, otherwise the behaviour is undefined.               : 
1369			;                                                                             : 
1369			;     Where possible, directly adjacent free blocks will be merged together   : 
1369			;     into larger blocks to help ensure that the heap does not become         : 
1369			;     excessively fragmented.                                                 : 
1369			;                                                                             : 
1369			;     free does not clear or set any other value into the freed space, and    : 
1369			;     therefore its contents may be visible through subsequent malloc's. The  : 
1369			;     caller should clear the freed space as required.                        : 
1369			;                                                                             : 
1369			;     This implementation of free uses the stack exclusively, and is          : 
1369			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1369			;     advisable to disable interrupts before calling free, and recommended    : 
1369			;     to avoid the use of free inside ISRs in general.                        : 
1369			;                                                                             : 
1369			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     HL  Pointer to address of first byte of allocation to be freed          : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     Nothing                                                                 : 
1369			;                                                                             : 
1369			; Stack frame                                                                 : 
1369			;       |             |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     BC      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     DE      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     IX      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |  prev_free  |                                                       : 
1369			;   +2  +-------------+                                                       : 
1369			;       |  next_free  |                                                       : 
1369			;   +0  +-------------+                                                       : 
1369			;       |             |                                                       : 
1369			;                                                                             : 
1369			;------------------------------------------------------------------------------ 
1369			free: 
1369			      push  BC 
1369			      push  DE 
1369			      push  IX 
1369			 
1369			      ld    A, H                    ; Exit if ptr is null 
1369			      or    L 
1369			      jp    Z, free_early_exit 
1369			 
1369			      ; Set up stack frame 
1369			      ex    DE, HL 
1369			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			      ld    IX, 0                   ; Use IX as a frame pointer 
1369			      add   IX, SP 
1369			 
1369			      ; The address in HL points to the start of the useable allocated space, 
1369			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1369			      ; address of the block itself. 
1369			      ex    DE, HL 
1369			      ld    DE, -4 
1369			      add   HL, DE 
1369			 
1369			      ; An allocated block must have a null next block pointer in it 
1369			      ld    A, (HL) 
1369			      inc   HL 
1369			      or    (HL) 
1369			      jp    NZ, free_done 
1369			 
1369			      dec   HL 
1369			 
1369			      ld    B, H                    ; Copy HL to BC 
1369			      ld    C, L 
1369			 
1369			      ; Loop through the free list to find the first block with an address 
1369			      ; higher than the block being freed 
1369			      ld    HL, free_list 
1369			 
1369			free_find_higher_block: 
1369			      ld    E, (HL)                 ; Load next ptr from free block 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      dec   HL 
1369			 
1369			      ld    (IX+0), E               ; Save ptr to next free block 
1369			      ld    (IX+1), D 
1369			      ld    (IX+2), L               ; Save ptr to prev free block 
1369			      ld    (IX+3), H 
1369			 
1369			      ld    A, B                    ; Check if DE is greater than BC 
1369			      cp    D                       ; Compare MSB first 
1369			      jr    Z, $+4                  ; MSB the same, compare LSB 
1369			      jr    NC, free_find_higher_block_skip 
1369			      ld    A, C 
1369			      cp    E                       ; Then compare LSB 
1369			      jr    C, free_found_higher_block 
1369			 
1369			free_find_higher_block_skip: 
1369			      ld    A, D                    ; Reached the end of the free list? 
1369			      or    E 
1369			      jp    Z, free_done 
1369			 
1369			      ex    DE, HL 
1369			 
1369			      jr    free_find_higher_block 
1369			 
1369			free_found_higher_block: 
1369			      ; Insert freed block between prev and next free blocks 
1369			      ld    (HL), C                 ; Point prev free block to freed block 
1369			      inc   HL 
1369			      ld    (HL), B 
1369			 
1369			      ld    H, B                    ; Point freed block at next free block 
1369			      ld    L, C 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Check if the freed block is adjacent to the next free block 
1369			      inc   HL                      ; Load size of freed block into HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ex    DE, HL 
1369			 
1369			      add   HL, BC                  ; Add addr of freed block and its size 
1369			 
1369			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1369			      ld    D, (IX+1) 
1369			 
1369			      or    A                       ; Clear the carry flag 
1369			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1369			      jr    NZ, free_check_adjacent_to_prev 
1369			 
1369			      ; Freed block is adjacent to next, merge into one bigger block 
1369			      ex    DE, HL                  ; Load next ptr from next block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  HL                      ; Save ptr to next block for later 
1369			 
1369			      ld    H, B                    ; Store ptr from next block into freed block 
1369			      ld    L, C 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   HL                      ; Restore ptr to next block 
1369			      inc   HL                      ; Load size of next block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  DE                      ; Save next block size for later 
1369			 
1369			      ld    H, B                    ; Load size of freed block into HL 
1369			      ld    L, C 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ex    DE, HL 
1369			 
1369			      pop   DE                      ; Restore size of next block 
1369			      add   HL, DE                  ; Add sizes of both blocks 
1369			      ex    DE, HL 
1369			 
1369			      ld    H, B                    ; Store new bigger size into freed block 
1369			      ld    L, C 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			free_check_adjacent_to_prev: 
1369			      ; Check if the freed block is adjacent to the prev free block 
1369			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1369			      ld    H, (IX+3) 
1369			 
1369			      inc   HL                      ; Size of prev free block into DE 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      add   HL, DE                  ; Add prev block addr and size 
1369			 
1369			      or    A                       ; Clear the carry flag 
1369			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1369			      jr    NZ, free_done 
1369			 
1369			      ; Freed block is adjacent to prev, merge into one bigger block 
1369			      ld    H, B                    ; Load next ptr from freed block into DE 
1369			      ld    L, C 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  HL                      ; Save freed block ptr for later 
1369			 
1369			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1369			      ld    H, (IX+3) 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   HL                      ; Restore freed block ptr 
1369			      inc   HL                      ; Load size of freed block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  DE                      ; Save freed block size for later 
1369			 
1369			      ld    L, (IX+2)               ; Load size of prev block into DE 
1369			      ld    H, (IX+3) 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      pop   HL                      ; Add sizes of both blocks 
1369			      add   HL, DE 
1369			      ex    DE, HL 
1369			 
1369			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1369			      ld    H, (IX+3) 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			free_done: 
1369			      ld    HL, 4                   ; Clean up stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			 
1369			free_early_exit: 
1369			      pop   IX 
1369			      pop   DE 
1369			      pop   BC 
1369			 
1369			      ret 
1369			 
1369			 
1369			;      .org 0x8000 
1369			; 
1369			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1369			 ;                 .dw   0 
1369			 
1369			endif 
1369			 
1369			 
1369			if MALLOC_4 
1369			 
1369			; My memory allocation code. Very very simple.... 
1369			; allocate space under 250 chars 
1369			 
1369			heap_init: 
1369				; init start of heap as zero 
1369				;  
1369			 
1369				ld hl, heap_start 
1369				ld a, 0 
1369				ld (hl), a      ; empty block 
1369				inc hl 
1369				ld a, 0 
1369				ld (hl), a      ; length of block 
1369				; write end of list 
1369				inc hl 
1369				ld a,(hl) 
1369				inc hl 
1369				ld a,(hl) 
1369				 
1369			 
1369				; init some malloc vars 
1369			 
1369				ld hl, 0 
1369				ld (free_list), hl       ; store last malloc location 
1369			 
1369				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1369				ld a, 0 
1369				ld (hl), a 
1369			 
1369			 
1369				ld hl, heap_start 
1369				;  
1369				  
1369				ret 
1369			 
1369			 
1369			;    free block marker 
1369			;    requested size  
1369			;    pointer to next block 
1369			;    .... 
1369			;    next block marker 
1369			 
1369			 
1369			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1369			; 
1369			 
1369			 
1369			malloc:  
1369				push de 
1369				push bc 
1369				push af 
1369			 
1369				; hl space required 
1369				 
1369				ld c, l    ; hold space   (TODO only a max of 255) 
1369			 
1369			;	inc c     ; TODO BUG need to fix memory leak on push str 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			 
1369			 
1369			 
1369				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1369			 
1369				ld a, (free_list+3) 
1369				cp 0 
1369				jr z, .contheap 
1369			 
1369				ld hl, (free_list)     ; get last alloc 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mrs" 
1369						CALLMONITOR 
1369					endif 
1369				jr .startalloc 
1369			 
1369			.contheap: 
1369				ld hl, heap_start 
1369			 
1369			.startalloc: 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mym" 
1369						CALLMONITOR 
1369					endif 
1369			.findblock: 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mmf" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369				ld a,(hl)  
1369				; if byte is zero then clear to use 
1369			 
1369				cp 0 
1369				jr z, .foundemptyblock 
1369			 
1369				; if byte is not clear 
1369				;     then byte is offset to next block 
1369			 
1369				inc hl 
1369				ld a, (hl) ; get size 
1369			.nextblock:	inc hl 
1369					ld e, (hl) 
1369					inc hl 
1369					ld d, (hl) 
1369					ex de, hl 
1369			;	inc hl  ; move past the store space 
1369			;	inc hl  ; move past zero index  
1369			 
1369				; TODO detect no more space 
1369			 
1369				push hl 
1369				ld de, heap_end 
1369				call cmp16 
1369				pop hl 
1369				jr nc, .nospace 
1369			 
1369				jr .findblock 
1369			 
1369			.nospace: ld hl, 0 
1369				jp .exit 
1369			 
1369			 
1369			.foundemptyblock:	 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mme" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			; TODO has block enough space if reusing??? 
1369			 
1369				;  
1369			 
1369			; see if this block has been previously used 
1369				inc hl 
1369				ld a, (hl) 
1369				dec hl 
1369				cp 0 
1369				jr z, .newblock 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "meR" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			; no reusing previously allocated block 
1369			 
1369			; is it smaller than previously used? 
1369				 
1369				inc hl    ; move to size 
1369				ld a, c 
1369				sub (hl)        ; we want c < (hl) 
1369				dec hl    ; move back to marker 
1369			        jr z, .findblock 
1369			 
1369				; update with the new size which should be lower 
1369			 
1369			        ;inc  hl   ; negate next move. move back to size  
1369			 
1369			.newblock: 
1369				; need to be at marker here 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "meN" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			 
1369				ld a, c 
1369			 
1369				ld (free_list+3), a	 ; flag resume from last malloc  
1369				ld (free_list), hl    ; save out last location 
1369			 
1369			 
1369				;inc a     ; space for length byte 
1369				ld (hl), a     ; save block in use marker 
1369			 
1369				inc hl   ; move to space marker 
1369				ld (hl), a    ; save new space 
1369			 
1369				inc hl   ; move to start of allocated area 
1369				 
1369			;	push hl     ; save where we are - 1  
1369			 
1369			;	inc hl  ; move past zero index  
1369				; skip space to set down new marker 
1369			 
1369				; provide some extra space for now 
1369			 
1369				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1369				inc a 
1369				inc a 
1369			 
1369				push hl   ; save where we are in the node block 
1369			 
1369				call addatohl 
1369			 
1369				; write linked list point 
1369			 
1369				pop de     ; get our node position 
1369				ex de, hl 
1369			 
1369				ld (hl), e 
1369				inc hl 
1369				ld (hl), d 
1369			 
1369				inc hl 
1369			 
1369				; now at start of allocated data so save pointer 
1369			 
1369				push hl 
1369			 
1369				; jump to position of next node and setup empty header in DE 
1369			 
1369				ex de, hl 
1369			 
1369			;	inc hl ; move past end of block 
1369			 
1369				ld a, 0 
1369				ld (hl), a   ; empty marker 
1369				inc hl 
1369				ld (hl), a   ; size 
1369				inc hl  
1369				ld (hl), a   ; ptr 
1369				inc hl 
1369				ld (hl), a   ; ptr 
1369			 
1369			 
1369				pop hl 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mmr" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			.exit: 
1369				pop af 
1369				pop bc 
1369				pop de  
1369				ret 
1369			 
1369			 
1369			 
1369			 
1369			free:  
1369				push hl 
1369				push af 
1369				; get address in hl 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "fre" 
1369						CALLMONITOR 
1369					endif 
1369				; data is at hl - move to block count 
1369				dec hl 
1369				dec hl    ; get past pointer 
1369				dec hl 
1369			 
1369				ld a, (hl)    ; need this for a validation check 
1369			 
1369				dec hl    ; move to block marker 
1369			 
1369				; now check that the block count and block marker are the same  
1369			        ; this checks that we are on a malloc node and not random memory 
1369			        ; OK a faint chance this could be a problem but rare - famous last words! 
1369			 
1369				ld c, a 
1369				ld a, (hl)    
1369			 
1369				cp c 
1369				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1369			 
1369				; yes good chance we are on a malloc node 
1369			 
1369				ld a, 0      
1369				ld (hl), a   ; mark as free 
1369			 
1369				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1369			 
1369			.freeignore:  
1369			 
1369				pop af 
1369				pop hl 
1369			 
1369				ret 
1369			 
1369			 
1369			 
1369			endif 
1369			 
1369			; eof 
# End of file firmware_memory.asm
1369			  
1369			; device C  
1369			; Now handled by SPI  
1369			;if SOUND_ENABLE  
1369			;	include "firmware_sound.asm"  
1369			;endif  
1369			  
1369			include "firmware_diags.asm"  
1369			; Hardware diags menu 
1369			 
1369			 
1369			config: 
1369			 
1369 3e 00			ld a, 0 
136b 21 8a 13			ld hl, .configmn 
136e cd f9 0b			call menu 
1371			 
1371 fe 00			cp 0 
1373 c8				ret z 
1374			 
1374			;	cp 1 
1374			;	call z, .savetostore 
1374			 
1374 fe 01			cp 1 
1376			if STARTUP_V1 
1376 cc 9e 13			call z, .selautoload 
1379			endif 
1379			 
1379			if STARTUP_V2 
1379				call z, .enautoload 
1379			endif 
1379 fe 02			cp 2 
137b cc 94 13			call z, .disautoload 
137e			;	cp 3 
137e			;	call z, .selbank 
137e fe 03			cp 3 
1380 cc bc 13			call z, .debug_tog 
1383 fe 04			cp 4 
1385 cc 8b 14			call z, .bpsgo 
1388			;	cp 5 
1388			;	call z, hardware_diags 
1388			if STARTUP_V2 
1388				cp 5 
1388				call z, create_startup 
1388			endif 
1388 18 df			jr config 
138a			 
138a			.configmn: 
138a			;	dw prom_c3 
138a 79 16			dw prom_c2 
138c 8e 16			dw prom_c2a 
138e			;	dw prom_c2b 
138e			;	dw prom_c4 
138e ad 16			dw prom_m4 
1390 c8 16			dw prom_m4b 
1392			;	dw prom_c1 
1392			if STARTUP_V2 
1392				dw prom_c9 
1392			endif 
1392 00 00			dw 0 
1394				 
1394			 
1394			if STARTUP_V2 
1394			.enautoload: 
1394				if STORAGE_SE 
1394				ld a, $fe      ; bit 0 clear 
1394				ld (spi_device), a 
1394			 
1394				call storage_get_block_0 
1394			 
1394				ld a, 1 
1394				ld (store_page+STORE_0_AUTOFILE), a 
1394			 
1394					ld hl, 0 
1394					ld de, store_page 
1394				call storage_write_block	 ; save update 
1394				else 
1394			 
1394				ld hl, prom_notav 
1394				ld de, prom_empty 
1394				call info_panel 
1394				endif 
1394			 
1394			 
1394				ret 
1394			endif 
1394			 
1394			.disautoload: 
1394				if STORAGE_SE 
1394				ld a, $fe      ; bit 0 clear 
1394				ld (spi_device), a 
1394			 
1394				call storage_get_block_0 
1394			 
1394				ld a, 0 
1394				ld (store_page+STORE_0_AUTOFILE), a 
1394			 
1394					ld hl, 0 
1394					ld de, store_page 
1394				call storage_write_block	 ; save update 
1394				else 
1394			 
1394 21 d0 16			ld hl, prom_notav 
1397 11 e6 16			ld de, prom_empty 
139a cd 59 0b			call info_panel 
139d				endif 
139d			 
139d			 
139d c9				ret 
139e			 
139e			if STARTUP_V1 
139e			 
139e			; Select auto start 
139e			 
139e			.selautoload: 
139e			 
139e				 
139e				if STORAGE_SE 
139e			 
139e					call config_dir 
139e				        ld hl, scratch 
139e					ld a, 0 
139e					call menu 
139e			 
139e					cp 0 
139e					ret z 
139e			 
139e					dec a 
139e			 
139e			 
139e					; locate menu option 
139e			 
139e					ld hl, scratch 
139e					call table_lookup 
139e			 
139e					if DEBUG_FORTH_WORDS 
139e						DMARK "ALl" 
139e						CALLMONITOR 
139e					endif 
139e					; with the pointer to the menu it, the byte following the zero term is the file id 
139e			 
139e					ld a, 0 
139e					ld bc, 50   ; max of bytes to look at 
139e					cpir  
139e			 
139e					if DEBUG_FORTH_WORDS 
139e						DMARK "ALb" 
139e						CALLMONITOR 
139e					endif 
139e					;inc hl 
139e			 
139e					ld a, (hl)   ; file id 
139e					 
139e				        ; save bank and file ids 
139e			 
139e					push af 
139e			 
139e			; TODO need to save to block 0 on bank 1	 
139e			 
139e					call storage_get_block_0 
139e			 
139e					if DEBUG_FORTH_WORDS 
139e						DMARK "AL0" 
139e						CALLMONITOR 
139e					endif 
139e					pop af 
139e			 
139e					ld (store_page+STORE_0_FILERUN),a 
139e					 
139e					; save bank id 
139e			 
139e					ld a,(spi_device) 
139e					ld (store_page+STORE_0_BANKRUN),a 
139e			 
139e					; enable auto run of store file 
139e			 
139e					ld a, 1 
139e					ld (store_page+STORE_0_AUTOFILE),a 
139e			 
139e					; save buffer 
139e			 
139e					ld hl, 0 
139e					ld de, store_page 
139e					if DEBUG_FORTH_WORDS 
139e						DMARK "ALw" 
139e						CALLMONITOR 
139e					endif 
139e				call storage_write_block	 ; save update 
139e			  
139e			 
139e			 
139e			 
139e					ld hl, scratch 
139e					call config_fdir 
139e			 
139e				else 
139e			 
139e 21 d0 16			ld hl, prom_notav 
13a1 11 e6 16			ld de, prom_empty 
13a4 cd 59 0b			call info_panel 
13a7			 
13a7				endif 
13a7 c9				ret 
13a8			endif 
13a8			 
13a8			 
13a8			; Select storage bank 
13a8			 
13a8			.selbank: 
13a8			 
13a8			;	if STORAGE_SE 
13a8			;	else 
13a8			 
13a8 21 d0 16			ld hl, prom_notav 
13ab 11 e6 16			ld de, prom_empty 
13ae cd 59 0b			call info_panel 
13b1			;	endif 
13b1				 
13b1 c9				ret 
13b2			 
13b2			if STORAGE_SE 
13b2			 
13b2			.config_ldir:   
13b2				; Load storage bank labels into menu array 
13b2			 
13b2				 
13b2			 
13b2			 
13b2				ret 
13b2			 
13b2			 
13b2			endif 
13b2			 
13b2			 
13b2			; Save user words to storage 
13b2			 
13b2			.savetostore: 
13b2			 
13b2			;	if STORAGE_SE 
13b2			; 
13b2			;		call config_dir 
13b2			;	        ld hl, scratch 
13b2			;		ld a, 0 
13b2			;		call menu 
13b2			;		 
13b2			;		ld hl, scratch 
13b2			;		call config_fdir 
13b2			; 
13b2			;	else 
13b2			 
13b2 21 d0 16			ld hl, prom_notav 
13b5 11 e6 16			ld de, prom_empty 
13b8 cd 59 0b			call info_panel 
13bb			 
13bb			;	endif 
13bb			 
13bb c9				ret 
13bc			 
13bc			if STARTUP_V2 
13bc			 
13bc			create_startup: 
13bc			 
13bc				ld a, 0 
13bc				ld hl, .crstart 
13bc				call menu 
13bc			 
13bc				cp 0 
13bc				ret z 
13bc			 
13bc				cp 1 
13bc				call z, .genlsword 
13bc				cp 2 
13bc				call z, .genedword 
13bc			 
13bc				cp 3 
13bc				call z, .gendemword 
13bc			 
13bc				cp 4 
13bc				call z, .genutlword 
13bc				cp 5 
13bc				call z, .genspiword 
13bc				cp 6 
13bc				call z, .genkeyword 
13bc				cp 7 
13bc				call z, .gensoundword 
13bc				cp 8 
13bc				call z, .genhwword 
13bc				jr create_startup 
13bc			 
13bc			.genhwword: 
13bc				ld hl, crs_hw 
13bc				ld de, .hwworddef 
13bc				call .genfile 
13bc				ret 
13bc			.gensoundword: 
13bc				ld hl, crs_sound 
13bc				ld de, .soundworddef 
13bc				call .genfile 
13bc				ret 
13bc			.genlsword: 
13bc				ld hl, crs_s1 
13bc				ld de, .lsworddef 
13bc				call .genfile 
13bc				ret 
13bc			 
13bc			.genedword: 
13bc				ld de, .edworddef 
13bc				ld hl, crs_s2 
13bc				call .genfile 
13bc				ret 
13bc			 
13bc			.gendemword: 
13bc				ld de, .demoworddef 
13bc				ld hl, crs_s3 
13bc				call .genfile 
13bc				ret 
13bc			 
13bc			.genutlword: 
13bc				ld hl, crs_s4 
13bc				ld de, .utilwordef 
13bc				call .genfile 
13bc				ret 
13bc			.genspiword: 
13bc				ld hl, crs_s5 
13bc				ld de, .spiworddef 
13bc				call .genfile 
13bc				ret 
13bc			.genkeyword: 
13bc				ld hl, crs_s6 
13bc				ld de, .keyworddef 
13bc				call .genfile 
13bc				ret 
13bc			 
13bc			; hl - points to file name 
13bc			; de - points to strings to add to file 
13bc			 
13bc			.genfile: 
13bc				push hl 
13bc				push de 
13bc			 
13bc				call clear_display 
13bc				ld a, display_row_1 
13bc				ld de, .genfiletxt 
13bc				call str_at_display 
13bc				call update_display 
13bc			 
13bc				pop de 
13bc				pop hl 
13bc			 
13bc			 
13bc				push de 
13bc				call storage_create 
13bc				; id in hl 
13bc				pop de   ; table of strings to add 
13bc			 
13bc			.genloop: 
13bc			 
13bc				push hl ; save id for next time around 
13bc				push de ; save de for next time around 
13bc			 
13bc				ex de, hl 
13bc				call loadwordinhl 
13bc				ex de, hl 
13bc			 
13bc				; need hl to be the id 
13bc				; need de to be the string ptr 
13bc				 
13bc				call storage_append 
13bc			 
13bc				pop de 
13bc				pop hl 
13bc			 
13bc				inc de 
13bc				inc de 
13bc			 
13bc				ld a,(de) 
13bc				cp 0 
13bc				jr nz, .genloop 
13bc				inc de 
13bc				ld a, (de) 
13bc				dec de 
13bc				cp 0 
13bc				jr nz, .genloop	 
13bc			 
13bc				ret 
13bc			 
13bc			.genfiletxt:  db "Creating file...",0 
13bc			 
13bc			.hwworddef: 
13bc				dw test5 
13bc				dw test6 
13bc				dw test7 
13bc				dw test8 
13bc				dw test9 
13bc				dw test10 
13bc				dw 0 
13bc			 
13bc			.soundworddef: 
13bc				dw sound1 
13bc				dw sound2 
13bc				dw sound3 
13bc				dw sound4 
13bc				dw sound5 
13bc				dw sound6 
13bc				dw sound7 
13bc				dw sound8 
13bc				dw sound9 
13bc				dw 0 
13bc			 
13bc			.utilwordef: 
13bc				dw strncpy 
13bc				dw type 
13bc				dw tuck 
13bc				dw clrstack 
13bc				dw longread 
13bc				dw start1 
13bc				dw start2 
13bc			; duplicated 
13bc			;	dw start3b 
13bc			;	dw start3c 
13bc				dw list 
13bc				dw 0 
13bc			 
13bc			.lsworddef: 
13bc				dw start3b 
13bc				dw 0 
13bc			 
13bc			.edworddef: 
13bc				dw edit1 
13bc				dw edit2 
13bc				dw edit3 
13bc				dw 0 
13bc			 
13bc			.demoworddef: 
13bc				dw game1 
13bc				dw game1a 
13bc				dw game1b 
13bc				dw game1c 
13bc				dw game1d 
13bc				dw game1s 
13bc				dw game1t 
13bc				dw game1f 
13bc				dw game1z 
13bc				dw game1zz 
13bc				dw ssv2 
13bc				dw ssv3 
13bc				dw ssv4 
13bc				dw ssv5 
13bc				dw ssv1 
13bc				dw ssv1cpm	 
13bc			;	dw game2b 
13bc			;	dw game2bf 
13bc			;	dw game2mba 
13bc			;	dw game2mbas	 
13bc			;	dw game2mbht 
13bc			;	dw game2mbms 
13bc			;	dw game2mb 
13bc			;	dw game3w 
13bc			;	dw game3p 
13bc			;	dw game3sc 
13bc			;	dw game3vsi 
13bc			;	dw game3vs 
13bc				dw 0 
13bc			 
13bc			 
13bc			.spiworddef: 
13bc			 
13bc			    dw spi1 
13bc			    dw spi2 
13bc			    dw spi2b 
13bc			    dw spi3 
13bc			    dw spi4 
13bc			    dw spi5 
13bc			;    dw spi6 
13bc			;    dw spi7 
13bc			 
13bc			;    dw spi8 
13bc			;    dw spi9 
13bc			;    dw spi10 
13bc			    dw 0 
13bc			 
13bc			.keyworddef: 
13bc			 
13bc				dw keyup 
13bc				dw keydown 
13bc				dw keyleft 
13bc				dw keyright 
13bc				dw 	keyf1 
13bc				dw keyf2 
13bc				dw keyf3 
13bc				dw keyf4 
13bc				dw keyf5 
13bc				dw keyf6 
13bc				dw keyf7 
13bc				dw keyf8 
13bc				dw keyf9 
13bc				dw keyf10 
13bc				dw keyf11 
13bc				dw keyf12 
13bc				dw keytab 
13bc				dw keycr 
13bc				dw keyhome 
13bc				dw keyend 
13bc				dw keybs 
13bc				dw 0 
13bc			 
13bc			.crstart: 
13bc				dw crs_s1 
13bc				dw crs_s2 
13bc				dw crs_s3 
13bc				dw crs_s4 
13bc				dw crs_s5 
13bc				dw crs_s6 
13bc				dw crs_sound 
13bc				dw crs_hw 
13bc				dw 0 
13bc			 
13bc			endif 
13bc			 
13bc			 
13bc			if STORAGE_SE 
13bc			 
13bc			config_fdir: 
13bc				; using the scratch dir go through and release the memory allocated for each string 
13bc				 
13bc				ld hl, scratch 
13bc			.cfdir:	ld e,(hl) 
13bc				inc hl 
13bc				ld d,(hl) 
13bc				inc hl 
13bc			 
13bc				ex de, hl 
13bc				call ishlzero 
13bc				ret z     ; return on null pointer 
13bc				call free 
13bc				ex de, hl 
13bc				jr .cfdir 
13bc			 
13bc			 
13bc				ret 
13bc			 
13bc			 
13bc			config_dir: 
13bc			 
13bc				; for the config menus that need to build a directory of storage call this routine 
13bc				; it will construct a menu in scratch to pass to menu 
13bc			 
13bc				; open storage device 
13bc			 
13bc				; execute DIR to build a list of files and their ids into scratch in menu format 
13bc				; once the menu has finished then will need to call config_fdir to release the strings 
13bc				 
13bc				; c = number items 
13bc			 
13bc				 
13bc				call storage_get_block_0 
13bc			 
13bc				ld hl, store_page     ; get current id count 
13bc				ld b, (hl) 
13bc				ld c, 0    ; count of files   
13bc			 
13bc			 
13bc				ld hl, scratch 
13bc				ld (store_tmp2), hl    ; location to poke strings 
13bc			 
13bc				; check for empty drive 
13bc			 
13bc				ld a, 0 
13bc				cp b 
13bc				jp z, .dirdone 
13bc			 
13bc				 
13bc					if DEBUG_FORTH_WORDS 
13bc						DMARK "Cdc" 
13bc						CALLMONITOR 
13bc					endif 
13bc			 
13bc			 
13bc			.diritem:	 
13bc				push bc 
13bc				; for each of the current ids do a search for them and if found push to stack 
13bc			 
13bc					ld hl, STORE_BLOCK_PHY 
13bc					ld d, 0		 ; look for extent 0 of block id as this contains file name 
13bc					ld e,b 
13bc			 
13bc					call storage_findnextid 
13bc			 
13bc			 
13bc					; if found hl will be non zero 
13bc			 
13bc					call ishlzero 
13bc					jr z, .dirnotfound 
13bc			 
13bc					; increase count 
13bc			 
13bc					pop bc	 
13bc					inc c 
13bc					push bc 
13bc					 
13bc			 
13bc					; get file header and push the file name 
13bc			 
13bc					ld de, store_page 
13bc					call storage_read_block 
13bc			 
13bc					; push file id to stack 
13bc				 
13bc					ld a, (store_page) 
13bc					ld h, 0 
13bc					ld l, a 
13bc			 
13bc					;call forth_push_numhl 
13bc					; TODO store id 
13bc			 
13bc					push hl 
13bc			 
13bc					; push extent count to stack  
13bc				 
13bc					ld hl, store_page+3 
13bc			 
13bc					; get file name length 
13bc			 
13bc					call strlenz   
13bc			 
13bc					inc hl   ; cover zero term 
13bc					inc hl  ; stick the id at the end of the area 
13bc			 
13bc					push hl 
13bc					pop bc    ; move length to bc 
13bc			 
13bc					call malloc 
13bc			 
13bc					; TODO save malloc area to scratch 
13bc			 
13bc					ex de, hl 
13bc					ld hl, (store_tmp2) 
13bc					ld (hl), e 
13bc					inc hl 
13bc					ld (hl), d 
13bc					inc hl 
13bc					ld (store_tmp2), hl 
13bc			 
13bc					 
13bc			 
13bc					;pop hl   ; get source 
13bc			;		ex de, hl    ; swap aronund	 
13bc			 
13bc					ld hl, store_page+3 
13bc					if DEBUG_FORTH_WORDS 
13bc						DMARK "CFd" 
13bc						CALLMONITOR 
13bc					endif 
13bc					ldir 
13bc			 
13bc					; de is past string, move back one and store id 
13bc					 
13bc					dec de 
13bc			 
13bc					; store file id 
13bc			 
13bc					pop hl 
13bc					ex de,hl 
13bc					ld (hl), e 
13bc			 
13bc					if DEBUG_FORTH_WORDS 
13bc						DMARK "Cdi" 
13bc						CALLMONITOR 
13bc					endif 
13bc					 
13bc			.dirnotfound: 
13bc					pop bc     
13bc					djnz .diritem 
13bc				 
13bc			.dirdone:	 
13bc			 
13bc					ld a, 0 
13bc					ld hl, (store_tmp2) 
13bc					ld (hl), a 
13bc					inc hl 
13bc					ld (hl), a 
13bc					inc hl 
13bc					; push a count of the dir items found 
13bc			 
13bc			;		ld h, 0 
13bc			;		ld l, c 
13bc			 
13bc				ret 
13bc			 
13bc			endif 
13bc			 
13bc			 
13bc			; Settings 
13bc			; Run  
13bc			 
13bc			 
13bc			 
13bc			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
13bc			;;hd_menu2:   db "        2: Editor",0   
13bc			;hd_menu2:   db "        2: Editor       6: Menu",0   
13bc			;hd_menu3:   db "        3: Storage",0 
13bc			;hd_menu4:   db "0=quit  4: Debug",0 
13bc			;hd_don:     db "ON",0 
13bc			;hd_doff:     db "OFF",0 
13bc			; 
13bc			; 
13bc			; 
13bc			;hardware_diags_old:       
13bc			; 
13bc			;.diagmenu: 
13bc			;	call clear_display 
13bc			;	ld a, display_row_1 
13bc			;	ld de, hd_menu1 
13bc			;	call str_at_display 
13bc			; 
13bc			;	ld a, display_row_2 
13bc			;	ld de, hd_menu2 
13bc			;	call str_at_display 
13bc			; 
13bc			;	ld a, display_row_3 
13bc			;	ld de, hd_menu3 
13bc			;	call str_at_display 
13bc			; 
13bc			;	ld a,  display_row_4 
13bc			;	ld de, hd_menu4 
13bc			;	call str_at_display 
13bc			; 
13bc			;	; display debug state 
13bc			; 
13bc			;	ld de, hd_don 
13bc			;	ld a, (os_view_disable) 
13bc			;	cp 0 
13bc			;	jr z, .distog 
13bc			;	ld de, hd_doff 
13bc			;.distog: ld a, display_row_4+17 
13bc			;	call str_at_display 
13bc			; 
13bc			;	call update_display 
13bc			; 
13bc			;	call cin_wait 
13bc			; 
13bc			; 
13bc			; 
13bc			;	cp '4' 
13bc			;	jr nz, .diagn1 
13bc			; 
13bc			;	; debug toggle 
13bc			; 
13bc			;	ld a, (os_view_disable) 
13bc			;	ld b, '*' 
13bc			;	cp 0 
13bc			;	jr z, .debtog 
13bc			;	ld b, 0 
13bc			;.debtog:	 
13bc			;	ld a,b 
13bc			;	ld (os_view_disable),a 
13bc			; 
13bc			;.diagn1: cp '0' 
13bc			;	 ret z 
13bc			; 
13bc			;;	cp '1' 
13bc			;;       jp z, matrix	 
13bc			;;   TODO keyboard matrix test 
13bc			; 
13bc			;	cp '2' 
13bc			;	jp z, .diagedit 
13bc			; 
13bc			;;	cp '6' 
13bc			;;	jp z, .menutest 
13bc			;;if ENABLE_BASIC 
13bc			;;	cp '6' 
13bc			;;	jp z, basic 
13bc			;;endif 
13bc			 ; 
13bc			;	jp .diagmenu 
13bc			; 
13bc			; 
13bc			;	ret 
13bc			 
13bc			 
13bc			.debug_tog: 
13bc 21 e5 13			ld hl, .menudebug 
13bf				 
13bf			;	ld a, (os_view_disable) 
13bf			;	cp '*' 
13bf 3a 6f ee			ld a,(debug_vector) 
13c2 fe c9			cp $C9   ; RET 
13c4 20 04			jr nz,.tdon  
13c6 3e 01			ld a, 1 
13c8 18 02			jr .tog1 
13ca 3e 00		.tdon: ld a, 0 
13cc			 
13cc			.tog1: 
13cc cd f9 0b			call menu 
13cf fe 00			cp 0 
13d1 c8				ret z 
13d2 fe 01			cp 1    ; disable debug 
13d4 28 04			jr z, .dtog0 
13d6 3e 2a			ld a, '*' 
13d8 18 05			jr .dtogset 
13da			.dtog0:  
13da				;ld a, 0 
13da cd 79 14			call bp_on 
13dd 18 dd			jr .debug_tog 
13df			.dtogset:  
13df				; ld (os_view_disable), a 
13df cd 85 14			call bp_off 
13e2 c3 bc 13			jp .debug_tog 
13e5			 
13e5			 
13e5			.menudebug: 
13e5 eb 13				dw .m6 
13e7 f4 13				dw .m7 
13e9 00 00				dw 0 
13eb .. 00		.m6:   db "Debug ON",0 
13f4 .. 00		.m7:   db "Debug OFF",0 
13fe			;hardware_diags:       
13fe			 
13fe			ENABLE_HDIAGS: equ 0 
13fe			 
13fe			if ENABLE_HDIAGS 
13fe			.diagm: 
13fe				ld hl, .menuitems 
13fe				ld a, 0 
13fe				call menu 
13fe			 
13fe			         cp 0 
13fe				 ret z 
13fe			 
13fe				cp 2 
13fe				jp z, .diagedit 
13fe			 
13fe			;	cp '6' 
13fe			;	jp z, .menutest 
13fe			;if ENABLE_BASIC 
13fe			;	cp '6' 
13fe			;	jp z, basic 
13fe			;endif 
13fe			  
13fe				jp .diagm 
13fe			 
13fe				 
13fe			.menuitems:   	dw .m1 
13fe					dw .m2 
13fe					dw .m3 
13fe					dw .m5 
13fe					dw .m5a 
13fe					dw .m5b 
13fe					dw 0 
13fe			 
13fe			 
13fe			.m1:   db "Key Matrix",0 
13fe			.m2:   db "Editor",0 
13fe			.m3:   db "Storage",0 
13fe			.m5:   db "Sound",0 
13fe			.m5a:  db "RAM Test",0 
13fe			.m5b:  db "LCD Test",0 
13fe			 
13fe			 
13fe			; debug editor 
13fe			 
13fe			.diagedit: 
13fe			 
13fe				ld hl, scratch 
13fe			;	ld bc, 250 
13fe			;	ldir 
13fe				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
13fe				ld a, 0 
13fe				ld (hl), a 
13fe				inc hl 
13fe				ld (hl), a 
13fe				inc hl 
13fe				ld (hl), a 
13fe			 
13fe			        call clear_display 
13fe				call update_display 
13fe				;ld a, 1 
13fe				;ld (hardware_diag), a 
13fe			.diloop: 
13fe				ld a, display_row_1 
13fe				ld c, 0 
13fe				ld d, 255    ; TODO fix input_str to actually take note of max string input length 
13fe				ld e, 40 
13fe			 
13fe				ld hl, scratch	 
13fe				call input_str 
13fe			 
13fe				ld a, display_row_2 
13fe				ld de, scratch 
13fe				call str_at_display 
13fe				call update_display 
13fe			 
13fe				jp .diloop 
13fe			endif 
13fe			 
13fe			; pass word in hl 
13fe			; a has display location 
13fe			display_word_at: 
13fe f5				push af 
13ff e5				push hl 
1400 7c				ld a,h 
1401 21 bd e5			ld hl, os_word_scratch 
1404 cd fe 0f			call hexout 
1407 e1				pop hl 
1408 7d				ld a,l 
1409 21 bf e5			ld hl, os_word_scratch+2 
140c cd fe 0f			call hexout 
140f 21 c1 e5			ld hl, os_word_scratch+4 
1412 3e 00			ld a,0 
1414 77				ld (hl),a 
1415 11 bd e5			ld de,os_word_scratch 
1418 f1				pop af 
1419 cd db 0b				call str_at_display 
141c c9				ret 
141d			 
141d			display_ptr_state: 
141d			 
141d				; to restore afterwards 
141d			 
141d d5				push de 
141e c5				push bc 
141f e5				push hl 
1420 f5				push af 
1421			 
1421				; for use in here 
1421			 
1421			;	push bc 
1421			;	push de 
1421			;	push hl 
1421			;	push af 
1421			 
1421 cd c8 0b			call clear_display 
1424			 
1424 11 fc 15			ld de, .ptrstate 
1427 3e 00			ld a, display_row_1 
1429 cd db 0b			call str_at_display 
142c			 
142c				; display debug step 
142c			 
142c			 
142c 11 62 ee			ld de, debug_mark 
142f 3e 26			ld a, display_row_1+display_cols-2 
1431 cd db 0b			call str_at_display 
1434			 
1434				; display a 
1434 11 06 16			ld de, .ptrcliptr 
1437 3e 28			ld a, display_row_2 
1439 cd db 0b			call str_at_display 
143c			 
143c f1				pop af 
143d 2a 37 ea			ld hl,(cli_ptr) 
1440 3e 30			ld a, display_row_2+8 
1442 cd fe 13			call display_word_at 
1445			 
1445			 
1445				; display hl 
1445			 
1445			 
1445 11 0e 16			ld de, .ptrclioptr 
1448 3e 32			ld a, display_row_2+10 
144a cd db 0b			call str_at_display 
144d			; 
144d			;	pop hl 
144d 3e 35			ld a, display_row_2+13 
144f 2a 35 ea			ld hl,(cli_origptr) 
1452 cd fe 13			call display_word_at 
1455			; 
1455			;	 
1455			;	; display de 
1455			 
1455			;	ld de, .regstatede 
1455			;	ld a, display_row_3 
1455			;	call str_at_display 
1455			 
1455			;	pop de 
1455			;	ld h,d 
1455			;	ld l, e 
1455			;	ld a, display_row_3+3 
1455			;	call display_word_at 
1455			 
1455			 
1455				; display bc 
1455			 
1455			;	ld de, .regstatebc 
1455			;	ld a, display_row_3+10 
1455			;	call str_at_display 
1455			 
1455			;	pop bc 
1455			;	ld h,b 
1455			;	ld l, c 
1455			;	ld a, display_row_3+13 
1455			;	call display_word_at 
1455			 
1455			 
1455				; display dsp 
1455			 
1455			;	ld de, .regstatedsp 
1455			;	ld a, display_row_4 
1455			;	call str_at_display 
1455			 
1455				 
1455			;	ld hl,(cli_data_sp) 
1455			;	ld a, display_row_4+4 
1455			;	call display_word_at 
1455			 
1455				; display rsp 
1455			 
1455 11 3d 16			ld de, .regstatersp 
1458 3e 82			ld a, display_row_4+10 
145a cd db 0b			call str_at_display 
145d			 
145d				 
145d 2a e9 e9			ld hl,(cli_ret_sp) 
1460 3e 86			ld a, display_row_4+14 
1462 cd fe 13			call display_word_at 
1465			 
1465 cd eb 0b			call update_display 
1468			 
1468 cd 00 0b			call delay1s 
146b cd 00 0b			call delay1s 
146e cd 00 0b			call delay1s 
1471			 
1471			 
1471 cd 78 1a			call next_page_prompt 
1474			 
1474				; restore  
1474			 
1474 f1				pop af 
1475 e1				pop hl 
1476 c1				pop bc 
1477 d1				pop de 
1478 c9				ret 
1479			 
1479			; Update the break point vector so that the user can hook a new routine 
1479			 
1479			bp_on: 
1479 3e c3			ld a, $c3    ; JP 
147b 32 6f ee			ld (debug_vector), a 
147e 21 8b 14			ld hl, break_point_state 
1481 22 70 ee			ld (debug_vector+1), hl 
1484 c9				ret 
1485			 
1485			bp_off: 
1485 3e c9			ld a, $c9    ; RET 
1487 32 6f ee			ld (debug_vector), a 
148a c9				ret 
148b			 
148b			 
148b			break_point_state: 
148b			;	push af 
148b			; 
148b			;	; see if disabled 
148b			; 
148b			;	ld a, (os_view_disable) 
148b			;	cp '*' 
148b			;	jr nz, .bpsgo 
148b			;	pop af 
148b			;	ret 
148b			 
148b			.bpsgo: 
148b			;	pop af 
148b f5				push af 
148c 22 9a e2			ld (os_view_hl), hl 
148f ed 53 98 e2		ld (os_view_de), de 
1493 ed 43 96 e2		ld (os_view_bc), bc 
1497 e5				push hl 
1498 6f				ld l, a 
1499 26 00			ld h, 0 
149b 22 9c e2			ld (os_view_af),hl 
149e			 
149e 21 a8 ed				ld hl, display_fb0 
14a1 22 c3 eb				ld (display_fb_active), hl 
14a4 e1				pop hl	 
14a5			 
14a5 3e 31			ld a, '1' 
14a7 fe 2a		.bps1:  cp '*' 
14a9 cc 85 14			call z, bp_off 
14ac			;	jr nz, .bps1b 
14ac			;	ld (os_view_disable),a 
14ac fe 31		.bps1b:  cp '1' 
14ae 20 14			jr nz, .bps2 
14b0			 
14b0				; display reg 
14b0			 
14b0				 
14b0			 
14b0 3a 9c e2			ld a, (os_view_af) 
14b3 2a 9a e2			ld hl, (os_view_hl) 
14b6 ed 5b 98 e2		ld de, (os_view_de) 
14ba ed 4b 96 e2		ld bc, (os_view_bc) 
14be cd 58 15			call display_reg_state 
14c1 c3 44 15			jp .bpschk 
14c4			 
14c4 fe 32		.bps2:  cp '2' 
14c6 20 08			jr nz, .bps3 
14c8				 
14c8				; display hl 
14c8 2a 9a e2			ld hl, (os_view_hl) 
14cb cd 42 16			call display_dump_at_hl 
14ce			 
14ce 18 74			jr .bpschk 
14d0			 
14d0 fe 33		.bps3:  cp '3' 
14d2 20 08			jr nz, .bps4 
14d4			 
14d4			        ; display de 
14d4 2a 98 e2			ld hl, (os_view_de) 
14d7 cd 42 16			call display_dump_at_hl 
14da			 
14da 18 68			jr .bpschk 
14dc fe 34		.bps4:  cp '4' 
14de 20 08			jr nz, .bps5 
14e0			 
14e0			        ; display bc 
14e0 2a 96 e2			ld hl, (os_view_bc) 
14e3 cd 42 16			call display_dump_at_hl 
14e6			 
14e6 18 5c			jr .bpschk 
14e8 fe 35		.bps5:  cp '5' 
14ea 20 08		        jr nz, .bps7 
14ec			 
14ec				; display cur ptr 
14ec 2a 37 ea			ld hl, (cli_ptr) 
14ef cd 42 16			call display_dump_at_hl 
14f2			 
14f2 18 50			jr .bpschk 
14f4 fe 36		.bps7:  cp '6' 
14f6 20 08			jr nz, .bps8b 
14f8				 
14f8				; display cur orig ptr 
14f8 2a 35 ea			ld hl, (cli_origptr) 
14fb cd 42 16			call display_dump_at_hl 
14fe 18 44			jr .bpschk 
1500 fe 37		.bps8b:  cp '7' 
1502 20 08			jr nz, .bps9 
1504				 
1504				; display dsp 
1504 2a e5 e9			ld hl, (cli_data_sp) 
1507 cd 42 16			call display_dump_at_hl 
150a			 
150a 18 38			jr .bpschk 
150c fe 39		.bps9:  cp '9' 
150e 20 05			jr nz, .bps8c 
1510				 
1510				; display SP 
1510			;	ld hl, sp 
1510 cd 42 16			call display_dump_at_hl 
1513			 
1513 18 2f			jr .bpschk 
1515 fe 38		.bps8c:  cp '8' 
1517 20 08			jr nz, .bps8d 
1519				 
1519				; display rsp 
1519 2a e9 e9			ld hl, (cli_ret_sp) 
151c cd 42 16			call display_dump_at_hl 
151f			 
151f 18 23			jr .bpschk 
1521 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1523 20 05			jr nz, .bps8 
1525 cd 32 18			call monitor 
1528			 
1528 18 1a			jr .bpschk 
152a fe 30		.bps8:  cp '0' 
152c 20 16			jr nz, .bpschk 
152e			 
152e 21 07 ed				ld hl, display_fb1 
1531 22 c3 eb				ld (display_fb_active), hl 
1534 cd eb 0b				call update_display 
1537			 
1537				;ld a, (os_view_af) 
1537 2a 9a e2			ld hl, (os_view_hl) 
153a ed 5b 98 e2		ld de, (os_view_de) 
153e ed 4b 96 e2		ld bc, (os_view_bc) 
1542 f1				pop af 
1543 c9				ret 
1544			 
1544			.bpschk:   
1544 cd 00 0b			call delay1s 
1547 3e 9f		ld a,display_row_4 + display_cols - 1 
1549 11 76 1a		        ld de, endprg 
154c cd db 0b			call str_at_display 
154f cd eb 0b			call update_display 
1552 cd 32 65			call cin_wait 
1555			 
1555 c3 a7 14			jp .bps1 
1558			 
1558			 
1558			display_reg_state: 
1558			 
1558				; to restore afterwards 
1558			 
1558 d5				push de 
1559 c5				push bc 
155a e5				push hl 
155b f5				push af 
155c			 
155c				; for use in here 
155c			 
155c c5				push bc 
155d d5				push de 
155e e5				push hl 
155f f5				push af 
1560			 
1560 cd c8 0b			call clear_display 
1563			 
1563 11 18 16			ld de, .regstate 
1566 3e 00			ld a, display_row_1 
1568 cd db 0b			call str_at_display 
156b			 
156b				; display debug step 
156b			 
156b			 
156b 11 62 ee			ld de, debug_mark 
156e 3e 25			ld a, display_row_1+display_cols-3 
1570 cd db 0b			call str_at_display 
1573			 
1573				; display a 
1573 11 34 16			ld de, .regstatea 
1576 3e 28			ld a, display_row_2 
1578 cd db 0b			call str_at_display 
157b			 
157b e1				pop hl 
157c			;	ld h,0 
157c			;	ld l, a 
157c 3e 2b			ld a, display_row_2+3 
157e cd fe 13			call display_word_at 
1581			 
1581			 
1581				; display hl 
1581			 
1581			 
1581 11 28 16			ld de, .regstatehl 
1584 3e 32			ld a, display_row_2+10 
1586 cd db 0b			call str_at_display 
1589			 
1589 e1				pop hl 
158a 3e 35			ld a, display_row_2+13 
158c cd fe 13			call display_word_at 
158f			 
158f				 
158f				; display de 
158f			 
158f 11 2c 16			ld de, .regstatede 
1592 3e 50			ld a, display_row_3 
1594 cd db 0b			call str_at_display 
1597			 
1597 e1				pop hl 
1598			;	ld h,d 
1598			;	ld l, e 
1598 3e 53			ld a, display_row_3+3 
159a cd fe 13			call display_word_at 
159d			 
159d			 
159d				; display bc 
159d			 
159d 11 30 16			ld de, .regstatebc 
15a0 3e 5a			ld a, display_row_3+10 
15a2 cd db 0b			call str_at_display 
15a5			 
15a5 e1				pop hl 
15a6			;	ld h,b 
15a6			;	ld l, c 
15a6 3e 5d			ld a, display_row_3+13 
15a8 cd fe 13			call display_word_at 
15ab			 
15ab			 
15ab				; display dsp 
15ab			 
15ab 11 38 16			ld de, .regstatedsp 
15ae 3e 78			ld a, display_row_4 
15b0 cd db 0b			call str_at_display 
15b3			 
15b3				 
15b3 2a e5 e9			ld hl,(cli_data_sp) 
15b6 3e 7c			ld a, display_row_4+4 
15b8 cd fe 13			call display_word_at 
15bb			 
15bb				; display rsp 
15bb			 
15bb 11 3d 16			ld de, .regstatersp 
15be 3e 82			ld a, display_row_4+10 
15c0 cd db 0b			call str_at_display 
15c3			 
15c3				 
15c3 2a e9 e9			ld hl,(cli_ret_sp) 
15c6 3e 86			ld a, display_row_4+14 
15c8 cd fe 13			call display_word_at 
15cb			 
15cb cd eb 0b			call update_display 
15ce			 
15ce			;	call delay1s 
15ce			;	call delay1s 
15ce			;	call delay1s 
15ce			 
15ce			 
15ce			;	call next_page_prompt 
15ce			 
15ce				; restore  
15ce			 
15ce f1				pop af 
15cf e1				pop hl 
15d0 c1				pop bc 
15d1 d1				pop de 
15d2 c9				ret 
15d3			 
15d3 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
15e7 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
15fc .. 00		.ptrstate:	db "Ptr State",0 
1606 .. 00		.ptrcliptr:     db "cli_ptr",0 
160e .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1618 .. 00		.regstate:	db "Reg State (1/0)",0 
1628 .. 00		.regstatehl:	db "HL:",0 
162c .. 00		.regstatede:	db "DE:",0 
1630 .. 00		.regstatebc:	db "BC:",0 
1634 .. 00		.regstatea:	db "A :",0 
1638 .. 00		.regstatedsp:	db "DSP:",0 
163d .. 00		.regstatersp:	db "RSP:",0 
1642			 
1642			display_dump_at_hl: 
1642 e5				push hl 
1643 d5				push de 
1644 c5				push bc 
1645 f5				push af 
1646			 
1646 22 db e5			ld (os_cur_ptr),hl	 
1649 cd c8 0b			call clear_display 
164c cd 80 19			call dumpcont 
164f			;	call delay1s 
164f			;	call next_page_prompt 
164f			 
164f			 
164f f1				pop af 
1650 c1				pop bc 
1651 d1				pop de 
1652 e1				pop hl 
1653 c9				ret 
1654			 
1654			;if ENABLE_BASIC 
1654			;	include "nascombasic.asm" 
1654			;	basic: 
1654			;	include "forth/FORTH.ASM" 
1654			;endif 
1654			 
1654			; eof 
1654			 
1654			 
# End of file firmware_diags.asm
1654			  
1654			include "firmware_prompts.asm"  
1654			; Prompts  
1654			 
1654			; boot messages 
1654			 
1654 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1669 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1679			 
1679			 
1679			; config menus 
1679			 
1679			;prom_c3: db "Add Dictionary To File",0 
1679			 
1679			if STARTUP_V1 
1679 .. 00		prom_c2: db "Select Autoload File",0 
168e .. 00		prom_c2a: db "Disable Autoload File", 0 
16a4			endif 
16a4			 
16a4			if STARTUP_V2 
16a4			prom_c2: db "Enable Autoload Files",0 
16a4			prom_c2a: db "Disable Autoload Files", 0 
16a4			 
16a4			crs_s1: db "*ls-word", 0 
16a4			crs_s2: db "*ed-word", 0 
16a4			crs_s3: db "*Demo-Games", 0 
16a4			crs_s4: db "*Utils", 0 
16a4			crs_s5: db "*SPI-Util", 0 
16a4			crs_s6: db "*Key-Constants", 0 
16a4			crs_sound: db "*Sound-Util", 0 
16a4			crs_hw: db "*Hello-World",0 
16a4			 
16a4			 
16a4			 
16a4			endif 
16a4			;prom_c2b: db "Select Storage Bank",0 
16a4 .. 00		prom_c4: db "Settings",0 
16ad .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
16c8 .. 00		prom_m4b:   db "Monitor",0 
16d0			;prom_c1: db "Hardware Diags",0 
16d0			 
16d0			 
16d0			if STARTUP_V2 
16d0			prom_c9: db "Create Startup Files",0 
16d0			endif 
16d0			 
16d0 .. 00		prom_notav:    db "Feature not available",0 
16e6 .. 00		prom_empty:    db "",0 
16e7			 
16e7			; eof 
16e7			 
# End of file firmware_prompts.asm
16e7			  
16e7			; eof  
16e7			  
# End of file firmware.asm
16e7			 
16e7			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
16e7			;if BASE_KEV  
16e7			;baseram: equ 08000h 
16e7			;endif 
16e7			 
16e7			;if BASE_SC114 
16e7			;baseram:     equ    endofcode 
16e7			;endif 
16e7			 
16e7			 
16e7			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
16e7			 
16e7			; start system 
16e7			 
16e7			coldstart: 
16e7				; set sp 
16e7				; di/ei 
16e7			 
16e7 f3				di 
16e8 31 00 f0			ld sp, tos 
16eb cd 30 64			call init_nmi 
16ee			;	ei 
16ee			 
16ee				; init spinner 
16ee 3e 00			ld a,0 
16f0 32 bd eb			ld (display_active), a 
16f3			 
16f3				; disable breakpoint by default 
16f3			 
16f3				;ld a,'*' 
16f3			;	ld a,' ' 
16f3			;	ld (os_view_disable),a 
16f3			 
16f3				; set break point vector as new break point on or off 
16f3 cd 85 14			call bp_off 
16f6			 
16f6			 
16f6				; default the parse vector to just a RET 
16f6 3e c9			ld a, $c9 
16f8 32 6c ee			ld (parse_vector), a 
16fb			 
16fb				; init hardware 
16fb			 
16fb				; init keyboard and screen hardware 
16fb			 
16fb cd 1f 01			call hardware_init 
16fe			 
16fe			 
16fe cd 00 0b			call delay1s 
1701 3e 58			ld a, display_row_3+8 
1703 11 03 01			ld de, buildtime 
1706 cd db 0b			call str_at_display 
1709 cd eb 0b			call update_display 
170c			 
170c cd 00 0b			call delay1s 
170f cd 00 0b			call delay1s 
1712 cd 00 0b			call delay1s 
1715			 
1715				; detect if any keys are held down to enable breakpoints at start up 
1715			 
1715 cd 3a 65			call cin  
1718 fe 00			cp 0 
171a 28 03			jr z, .nokeys 
171c			 
171c				;call hardware_diags 
171c cd 69 13			call config 
171f			 
171f			;	ld de, .bpen 
171f			;	ld a, display_row_4 
171f			;	call str_at_display 
171f			;	call update_display 
171f			; 
171f			;	ld a,0 
171f			;	ld (os_view_disable),a 
171f			; 
171f			;.bpwait: 
171f			;	call cin 
171f			;	cp 0 
171f			;	jr z, .bpwait 
171f			;	jr .nokeys 
171f			; 
171f			; 
171f			;.bpen:  db "Break points enabled!",0 
171f			 
171f			 
171f			 
171f			 
171f			 
171f			 
171f			.nokeys: 
171f			 
171f			 
171f				 
171f			 
171f			;jp  testkey 
171f			 
171f			;call storage_get_block_0 
171f			; 
171f			;ld hl, 0 
171f			;ld de, store_page 
171f			;call storage_read_block 
171f			 
171f				 
171f			;ld hl, 10 
171f			;ld de, store_page 
171f			;call storage_read_block 
171f			 
171f			 
171f			 
171f			 
171f			 
171f			;stop:	nop 
171f			;	jp stop 
171f			 
171f			 
171f			 
171f			main: 
171f cd c8 0b			call clear_display 
1722 cd eb 0b			call update_display 
1725			 
1725			 
1725			 
1725			;	call testlcd 
1725			 
1725			 
1725			 
1725 cd c0 1e			call forth_init 
1728			 
1728			 
1728			warmstart: 
1728 cd 96 1e			call forth_warmstart 
172b			 
172b				; run startup word load 
172b			        ; TODO prevent this running at warmstart after crash  
172b			 
172b				if STARTUP_ENABLE 
172b			 
172b					if STARTUP_V1 
172b			 
172b						if STORAGE_SE 
172b							call forth_autoload 
172b						endif 
172b cd 80 63					call forth_startup 
172e					endif 
172e			 
172e					if STARTUP_V2 
172e			 
172e						if STORAGE_SE 
172e							call forth_autoload 
172e						else 
172e							call forth_startup 
172e						endif 
172e			 
172e			 
172e					endif 
172e			 
172e				endif 
172e			 
172e			warmstart_afterauto: 
172e			 
172e				; show free memory after boot 
172e 11 cd 17			ld de, freeram 
1731 3e 00			ld a, display_row_1 
1733 cd db 0b			call str_at_display 
1736			 
1736				; get current heap start after loading any uwords 
1736			 
1736				;ld de, (os_last_new_uword) 
1736				;ex de, hl 
1736			 
1736			; Or use heap_size word???? 
1736				;ld hl, heap_end 
1736				;ld hl, heap_size 
1736				;ld de, topusermem 
1736				;ld de, heap_start 
1736 ed 5b 5d 65			ld de, (free_list )      
173a 21 93 e2				ld hl, heap_end 
173d ed 52			sbc hl, de 
173f				;push hl 
173f				;ld a,h	         	 
173f				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
173f				;call hexout 
173f			   	;pop hl 
173f			; 
173f			;	ld a,l 
173f			;	ld hl, os_word_scratch+2 
173f			;	call hexout 
173f			;	ld hl, os_word_scratch+4 
173f			;	ld a, 0 
173f			;	ld (hl),a 
173f eb				ex de, hl 
1740 21 bd e5			ld hl, os_word_scratch 
1743 cd 0a 11			call uitoa_16 
1746			 
1746			 
1746 11 bd e5			ld de, os_word_scratch 
1749 3e 0d			ld a, display_row_1 + 13 
174b cd db 0b			call str_at_display 
174e cd eb 0b			call update_display 
1751			 
1751			 
1751				;call demo 
1751			 
1751			 
1751				; init scratch input area for cli commands 
1751			 
1751 21 df e5			ld hl, os_cli_cmd 
1754 3e 00			ld a,0 
1756 77				ld (hl),a 
1757 23				inc hl 
1758 77				ld (hl),a 
1759			 
1759 3e 00			ld a,0 
175b 32 de e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
175e			 
175e 32 db e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1761 32 dc e5			ld (os_cur_ptr+1),a	 
1764			 
1764 32 bd e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1767 32 be e5			ld (os_word_scratch+1),a	 
176a				 
176a			 
176a				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
176a 21 df e5			ld hl, os_cli_cmd 
176d			 
176d 3e 00			ld a, 0		 ; init cli input 
176f 77				ld (hl), a 
1770 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1772			cli: 
1772				; show cli prompt 
1772				;push af 
1772				;ld a, 0 
1772				;ld de, prompt 
1772				;call str_at_display 
1772			 
1772				;call update_display 
1772				;pop af 
1772				;inc a 
1772				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1772			 
1772			.lastrecall: 
1772			 
1772 0e 00			ld c, 0 
1774 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1776 1e 28			ld e, 40 
1778			 
1778 21 df e5			ld hl, os_cli_cmd 
177b			 
177b				STACKFRAME OFF $fefe $9f9f 
177b				if DEBUG_STACK_IMB 
177b					if OFF 
177b						exx 
177b						ld de, $fefe 
177b						ld a, d 
177b						ld hl, curframe 
177b						call hexout 
177b						ld a, e 
177b						ld hl, curframe+2 
177b						call hexout 
177b						ld hl, $fefe 
177b						push hl 
177b						ld hl, $9f9f 
177b						push hl 
177b						exx 
177b					endif 
177b				endif 
177b			endm 
# End of macro STACKFRAME
177b			 
177b cd 22 0e			call input_str 
177e			 
177e				STACKFRAMECHK OFF $fefe $9f9f 
177e				if DEBUG_STACK_IMB 
177e					if OFF 
177e						exx 
177e						ld hl, $9f9f 
177e						pop de   ; $9f9f 
177e						call cmp16 
177e						jr nz, .spnosame 
177e						ld hl, $fefe 
177e						pop de   ; $fefe 
177e						call cmp16 
177e						jr z, .spfrsame 
177e						.spnosame: call showsperror 
177e						.spfrsame: nop 
177e						exx 
177e					endif 
177e				endif 
177e			endm 
# End of macro STACKFRAMECHK
177e			 
177e			 
177e				; check to see if last line recall has been requested 
177e			 
177e			if EDIT_V2 
177e fe 05			cp KEY_UP 
1780 20 0f			jr nz, .noexecline 
1782			 
1782 11 df e5			ld de, os_cli_cmd 
1785 21 de e6			ld hl, os_last_cmd 
1788 01 ff 00			ld bc, 255 
178b ed b0			ldir 
178d 3e 00			ld a, 0 
178f 18 e1			jr .lastrecall 
1791			endif 
1791			 
1791			.noexecline: 
1791				; no so exec the line		 
1791			 
1791				; copy input to last command 
1791			 
1791 21 df e5			ld hl, os_cli_cmd 
1794 11 de e6			ld de, os_last_cmd 
1797 01 ff 00			ld bc, 255 
179a ed b0			ldir 
179c			 
179c				; wipe current buffer 
179c			 
179c			;	ld a, 0 
179c			;	ld hl, os_cli_cmd 
179c			;	ld de, os_cli_cmd+1 
179c			;	ld bc, 254 
179c			;	ldir 
179c				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
179c			;	call strcpy 
179c			;	ld a, 0 
179c			;	ld (hl), a 
179c			;	inc hl 
179c			;	ld (hl), a 
179c			;	inc hl 
179c			;	ld (hl), a 
179c			 
179c				; switch frame buffer to program  
179c			 
179c 21 07 ed				ld hl, display_fb1 
179f 22 c3 eb				ld (display_fb_active), hl 
17a2			 
17a2			;	nop 
17a2				STACKFRAME ON $fbfe $8f9f 
17a2				if DEBUG_STACK_IMB 
17a2					if ON 
17a2						exx 
17a2						ld de, $fbfe 
17a2						ld a, d 
17a2						ld hl, curframe 
17a2						call hexout 
17a2						ld a, e 
17a2						ld hl, curframe+2 
17a2						call hexout 
17a2						ld hl, $fbfe 
17a2						push hl 
17a2						ld hl, $8f9f 
17a2						push hl 
17a2						exx 
17a2					endif 
17a2				endif 
17a2			endm 
# End of macro STACKFRAME
17a2				; first time into the parser so pass over the current scratch pad 
17a2 21 df e5			ld hl,os_cli_cmd 
17a5				; tokenise the entered statement(s) in HL 
17a5 cd 3a 1f			call forthparse 
17a8			        ; exec forth statements in top of return stack 
17a8 cd 76 1f			call forthexec 
17ab				;call forthexec_cleanup 
17ab			;	call parsenext 
17ab			 
17ab				STACKFRAMECHK ON $fbfe $8f9f 
17ab				if DEBUG_STACK_IMB 
17ab					if ON 
17ab						exx 
17ab						ld hl, $8f9f 
17ab						pop de   ; $8f9f 
17ab						call cmp16 
17ab						jr nz, .spnosame 
17ab						ld hl, $fbfe 
17ab						pop de   ; $fbfe 
17ab						call cmp16 
17ab						jr z, .spfrsame 
17ab						.spnosame: call showsperror 
17ab						.spfrsame: nop 
17ab						exx 
17ab					endif 
17ab				endif 
17ab			endm 
# End of macro STACKFRAMECHK
17ab				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
17ab			 
17ab 3e 78			ld a, display_row_4 
17ad 11 de 17			ld de, endprog 
17b0			 
17b0 cd eb 0b			call update_display		 
17b3			 
17b3 cd 78 1a			call next_page_prompt 
17b6			 
17b6				; switch frame buffer to cli 
17b6			 
17b6 21 a8 ed				ld hl, display_fb0 
17b9 22 c3 eb				ld (display_fb_active), hl 
17bc			 
17bc			 
17bc cd c8 0b		        call clear_display 
17bf cd eb 0b			call update_display		 
17c2			 
17c2 21 df e5			ld hl, os_cli_cmd 
17c5			 
17c5 3e 00			ld a, 0		 ; init cli input 
17c7 77				ld (hl), a 
17c8			 
17c8				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
17c8			 
17c8				; now on last line 
17c8			 
17c8				; TODO scroll screen up 
17c8			 
17c8				; TODO instead just clear screen and place at top of screen 
17c8			 
17c8			;	ld a, 0 
17c8			;	ld (f_cursor_ptr),a 
17c8			 
17c8				;call clear_display 
17c8				;call update_display 
17c8			 
17c8				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17c8 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17ca c3 72 17			jp cli 
17cd			 
17cd .. 00		freeram: db "Free bytes: ",0 
17da ..			asc: db "1A2F" 
17de .. 00		endprog: db "End prog...",0 
17ea			 
17ea			testenter2:   
17ea 21 ea e2			ld hl,scratch+50 
17ed 22 db e5			ld (os_cur_ptr),hl 
17f0 c3 72 17			jp cli 
17f3			 
17f3			testenter:  
17f3			 
17f3 21 da 17			ld hl,asc 
17f6			;	ld a,(hl) 
17f6			;	call nibble2val 
17f6 cd 54 10			call get_byte 
17f9			 
17f9			 
17f9			;	ld a,(hl) 
17f9			;	call atohex 
17f9			 
17f9			;	call fourehexhl 
17f9 32 ea e2			ld (scratch+50),a 
17fc			 
17fc			 
17fc			 
17fc 21 dc 17			ld hl,asc+2 
17ff			;	ld a, (hl) 
17ff			;	call nibble2val 
17ff cd 54 10			call get_byte 
1802			 
1802			;	call fourehexhl 
1802 32 ec e2			ld (scratch+52),a 
1805				 
1805 21 ea e2			ld hl,scratch+50 
1808 22 db e5			ld (os_cur_ptr),hl 
180b c3 72 17			jp cli 
180e			 
180e			enter:	 
180e 3a bc e2			ld a,(scratch+4) 
1811 fe 00			cp 0 
1813 28 0c			jr z, .entercont 
1815				; no, not a null term line so has an address to work out.... 
1815			 
1815 21 ba e2			ld hl,scratch+2 
1818 cd b4 10			call get_word_hl 
181b			 
181b 22 db e5			ld (os_cur_ptr),hl	 
181e c3 72 17			jp cli 
1821			 
1821			 
1821			.entercont:  
1821			 
1821 21 ba e2			ld hl, scratch+2 
1824 cd 54 10			call get_byte 
1827			 
1827 2a db e5		   	ld hl,(os_cur_ptr) 
182a 77					ld (hl),a 
182b 23					inc hl 
182c 22 db e5				ld (os_cur_ptr),hl 
182f				 
182f			; get byte  
182f			 
182f			 
182f c3 72 17			jp cli 
1832			 
1832			 
1832			; basic monitor support 
1832			 
1832			monitor: 
1832				;  
1832 cd c8 0b			call clear_display 
1835 3e 00			ld a, 0 
1837 11 8b 18			ld de, .monprompt 
183a cd db 0b			call str_at_display 
183d cd eb 0b			call update_display 
1840			 
1840				; get a monitor command 
1840			 
1840 0e 00			ld c, 0     ; entry at top left 
1842 16 64			ld d, 100   ; max buffer size 
1844 1e 0f			ld e, 15    ; input scroll area 
1846 3e 00			ld a, 0     ; init string 
1848 21 b6 e4			ld hl, os_input 
184b 77				ld (hl), a 
184c 23				inc hl 
184d 77				ld (hl), a 
184e 21 b6 e4			ld hl, os_input 
1851 3e 01			ld a, 1     ; init string 
1853 cd 22 0e			call input_str 
1856			 
1856 cd c8 0b		        call clear_display 
1859 cd eb 0b			call update_display		 
185c			 
185c 3a b6 e4			ld a, (os_input) 
185f cd 52 11			call toUpper 
1862 fe 48		        cp 'H' 
1864 ca ff 18		        jp z, .monhelp 
1867 fe 44			cp 'D'		; dump 
1869 ca 32 19			jp z, .mondump	 
186c fe 43			cp 'C'		; dump 
186e ca 4c 19			jp z, .moncdump	 
1871 fe 4d			cp 'M'		; dump 
1873 ca 8d 18			jp z, .moneditstart 
1876 fe 55			cp 'U'		; dump 
1878 ca 99 18			jp z, .monedit	 
187b fe 47			cp 'G'		; dump 
187d ca 28 19			jp z, .monjump 
1880 fe 42			cp 'B'		; forth breakpoint 
1882 cc 8b 14			call z, break_point_state 
1885 fe 51			cp 'Q'		; dump 
1887 c8				ret z	 
1888			 
1888			 
1888				; TODO "S" to access symbol by name and not need the address 
1888				; TODO "F" to find a string in memory 
1888			 
1888 c3 32 18			jp monitor 
188b			 
188b .. 00		.monprompt: db ">", 0 
188d			 
188d			.moneditstart: 
188d				; get starting address 
188d			 
188d 21 b8 e4			ld hl,os_input+2 
1890 cd b4 10			call get_word_hl 
1893			 
1893 22 db e5			ld (os_cur_ptr),hl	 
1896			 
1896 c3 32 18			jp monitor 
1899			 
1899			.monedit: 
1899				; get byte to load 
1899			 
1899 21 b8 e4			ld hl,os_input+2 
189c cd 54 10			call get_byte 
189f			 
189f				; get address to update 
189f 2a db e5			ld hl, (os_cur_ptr) 
18a2			 
18a2				; update byte 
18a2			 
18a2 77				ld (hl), a 
18a3			 
18a3				; move to next address and save it 
18a3			 
18a3 23				inc hl 
18a4 22 db e5			ld (os_cur_ptr),hl	 
18a7			 
18a7 c3 32 18			jp monitor 
18aa			 
18aa			 
18aa .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
18be .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
18da .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
18f8 .. 00		.monhelptext4:  db "Q-Quit",0 
18ff			        
18ff			.monhelp: 
18ff 3e 00			ld a, display_row_1 
1901 11 aa 18		        ld de, .monhelptext1 
1904			 
1904 cd db 0b			call str_at_display 
1907 3e 28			ld a, display_row_2 
1909 11 be 18		        ld de, .monhelptext2 
190c					 
190c cd db 0b			call str_at_display 
190f 3e 50			ld a, display_row_3 
1911 11 da 18		        ld de, .monhelptext3 
1914					 
1914 cd db 0b			call str_at_display 
1917 3e 78			ld a, display_row_4 
1919 11 f8 18		        ld de, .monhelptext4 
191c cd db 0b			call str_at_display 
191f			 
191f cd eb 0b			call update_display		 
1922			 
1922 cd 78 1a			call next_page_prompt 
1925 c3 32 18			jp monitor 
1928			 
1928			.monjump:    
1928 21 b8 e4			ld hl,os_input+2 
192b cd b4 10			call get_word_hl 
192e			 
192e e9				jp (hl) 
192f c3 32 18			jp monitor 
1932			 
1932			.mondump:    
1932 21 b8 e4			ld hl,os_input+2 
1935 cd b4 10			call get_word_hl 
1938			 
1938 22 db e5			ld (os_cur_ptr),hl	 
193b cd 80 19			call dumpcont 
193e 3e 78			ld a, display_row_4 
1940 11 de 17			ld de, endprog 
1943			 
1943 cd eb 0b			call update_display		 
1946			 
1946 cd 78 1a			call next_page_prompt 
1949 c3 32 18			jp monitor 
194c			.moncdump: 
194c cd 80 19			call dumpcont 
194f 3e 78			ld a, display_row_4 
1951 11 de 17			ld de, endprog 
1954			 
1954 cd eb 0b			call update_display		 
1957			 
1957 cd 78 1a			call next_page_prompt 
195a c3 32 18			jp monitor 
195d			 
195d			 
195d			; TODO symbol access  
195d			 
195d			.symbols:     ;; A list of symbols that can be called up  
195d a8 ed			dw display_fb0 
195f .. 00			db "fb0",0  
1963 71 ea		     	dw store_page 
1965 .. 00			db "store_page",0 
1970			 
1970			 
1970			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1970			 
1970 3a b9 e2			ld a,(scratch+1) 
1973 fe 00			cp 0 
1975 28 09			jr z, dumpcont 
1977			 
1977				; no, not a null term line so has an address to work out.... 
1977			 
1977 21 ba e2			ld hl,scratch+2 
197a cd b4 10			call get_word_hl 
197d			 
197d 22 db e5			ld (os_cur_ptr),hl	 
1980			 
1980			 
1980			 
1980			dumpcont: 
1980			 
1980				; dump bytes at ptr 
1980			 
1980			 
1980 3e 00			ld a, display_row_1 
1982 2a c3 eb			ld hl, (display_fb_active) 
1985 cd f5 0d			call addatohl 
1988 cd b0 19			call .dumpbyterow 
198b			 
198b 3e 28			ld a, display_row_2 
198d 2a c3 eb			ld hl, (display_fb_active) 
1990 cd f5 0d			call addatohl 
1993 cd b0 19			call .dumpbyterow 
1996			 
1996			 
1996 3e 50			ld a, display_row_3 
1998 2a c3 eb			ld hl, (display_fb_active) 
199b cd f5 0d			call addatohl 
199e cd b0 19			call .dumpbyterow 
19a1			 
19a1 3e 78			ld a, display_row_4 
19a3 2a c3 eb			ld hl, (display_fb_active) 
19a6 cd f5 0d			call addatohl 
19a9 cd b0 19			call .dumpbyterow 
19ac			 
19ac cd eb 0b			call update_display 
19af			;		jp cli 
19af c9				ret 
19b0			 
19b0			.dumpbyterow: 
19b0			 
19b0				;push af 
19b0			 
19b0 e5				push hl 
19b1			 
19b1				; calc where to poke the ascii 
19b1			if display_cols == 20 
19b1				ld a, 16 
19b1			else 
19b1 3e 1f			ld a, 31 
19b3			endif 
19b3			 
19b3 cd f5 0d			call addatohl 
19b6 22 bd e5			ld (os_word_scratch),hl  		; save pos for later 
19b9			 
19b9			 
19b9			; display decoding address 
19b9 2a db e5		   	ld hl,(os_cur_ptr) 
19bc			 
19bc 7c				ld a,h 
19bd e1				pop hl 
19be e5				push hl 
19bf			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
19bf cd fe 0f			call hexout 
19c2 2a db e5		   	ld hl,(os_cur_ptr) 
19c5			 
19c5 7d				ld a,l 
19c6 e1				pop hl 
19c7 23				inc hl 
19c8 23				inc hl 
19c9 e5				push hl 
19ca			;	ld hl, os_word_scratch+2 
19ca cd fe 0f			call hexout 
19cd e1				pop hl 
19ce 23				inc hl 
19cf 23				inc hl 
19d0				;ld hl, os_word_scratch+4 
19d0 3e 3a			ld a, ':' 
19d2 77				ld (hl),a 
19d3 23				inc hl 
19d4				;ld a, 0 
19d4				;ld (hl),a 
19d4				;ld de, os_word_scratch 
19d4				;pop af 
19d4				;push af 
19d4			;		ld a, display_row_2 
19d4			;		call str_at_display 
19d4			;		call update_display 
19d4			 
19d4			 
19d4			;pop af 
19d4			;	add 5 
19d4			 
19d4			if display_cols == 20 
19d4				ld b, 4 
19d4			else 
19d4 06 08			ld b, 8 
19d6			endif	 
19d6			 
19d6			.dumpbyte: 
19d6 c5				push bc 
19d7 e5				push hl 
19d8			 
19d8			 
19d8 2a db e5		   	ld hl,(os_cur_ptr) 
19db 7e					ld a,(hl) 
19dc			 
19dc					; poke the ascii to display 
19dc 2a bd e5				ld hl,(os_word_scratch) 
19df 77					ld (hl),a 
19e0 23					inc hl 
19e1 22 bd e5				ld (os_word_scratch),hl 
19e4			 
19e4					 
19e4			 
19e4			 
19e4 e1					pop hl 
19e5 e5					push hl 
19e6			 
19e6 cd fe 0f				call hexout 
19e9			 
19e9					 
19e9 2a db e5		   	ld hl,(os_cur_ptr) 
19ec 23				inc hl 
19ed 22 db e5		   	ld (os_cur_ptr),hl 
19f0			 
19f0 e1					pop hl 
19f1 23					inc hl 
19f2 23					inc hl 
19f3 23					inc hl 
19f4			 
19f4			 
19f4			 
19f4					;ld a,0 
19f4					;ld (os_word_scratch+2),a 
19f4					;pop af 
19f4					;push af 
19f4			 
19f4					;ld de, os_word_scratch 
19f4					;call str_at_display 
19f4			;		call update_display 
19f4			;		pop af 
19f4 c1					pop bc 
19f5 c6 03				add 3 
19f7 10 dd			djnz .dumpbyte 
19f9			 
19f9				 
19f9			 
19f9 c9				ret 
19fa			 
19fa			jump:	 
19fa			 
19fa 21 ba e2			ld hl,scratch+2 
19fd cd b4 10			call get_word_hl 
1a00				;ld hl,(scratch+2) 
1a00				;call fourehexhl 
1a00			 
1a00 22 db e5			ld (os_cur_ptr),hl	 
1a03			 
1a03 e9				jp (hl) 
1a04			 
1a04			 
1a04			 
1a04			; TODO implement a basic monitor mode to start with 
1a04			 
1a04			 
1a04			 
1a04			 
1a04			 
1a04			 
1a04			 
1a04			 
1a04			 
1a04			; testing and demo code during development 
1a04			 
1a04			 
1a04 .. 00		str1: db "Enter some text...",0 
1a17 .. 00		clear: db "                    ",0 
1a2c			 
1a2c			demo: 
1a2c			 
1a2c			 
1a2c			 
1a2c			;	call update_display 
1a2c			 
1a2c				; init scratch input area for testing 
1a2c 21 b8 e2			ld hl, scratch	 
1a2f 3e 00			ld a,0 
1a31 77				ld (hl),a 
1a32			 
1a32			 
1a32 3e 28		            LD   A, display_row_2 
1a34			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a34 11 04 1a		            LD   DE, str1 
1a37 cd db 0b			call str_at_display 
1a3a			 
1a3a			;            CALL fLCD_Str       ;Display string pointed to by DE 
1a3a			cloop:	 
1a3a 3e 50		            LD   A, display_row_3 
1a3c			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a3c 11 17 1a		            LD   DE, clear 
1a3f			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1a3f cd db 0b				call str_at_display 
1a42 3e 78			ld a, display_row_4 
1a44 11 74 1a			ld de, prompt 
1a47			 
1a47 cd db 0b				call str_at_display 
1a4a cd eb 0b			call update_display 
1a4d			 
1a4d 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1a4f 16 0a			ld d, 10 
1a51 21 b8 e2			ld hl, scratch	 
1a54 cd 22 0e			call input_str 
1a57			 
1a57			;	call clear_display 
1a57			;'	call update_display 
1a57			 
1a57 3e 00		            LD   A, display_row_1 
1a59			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a59 11 17 1a		            LD   DE, clear 
1a5c cd db 0b				call str_at_display 
1a5f			;            CALL fLCD_Str       ;Display string pointed to by DE 
1a5f 3e 00		            LD   A, display_row_1 
1a61			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a61 11 b8 e2		            LD   DE, scratch 
1a64			;            CALL fLCD_Str       ;Display string pointed to by DE 
1a64 cd db 0b				call str_at_display 
1a67 cd eb 0b			call update_display 
1a6a			 
1a6a 3e 00				ld a,0 
1a6c 21 b8 e2			ld hl, scratch 
1a6f 77				ld (hl),a 
1a70			 
1a70 00				nop 
1a71 c3 3a 1a			jp cloop 
1a74			 
1a74			 
1a74			 
1a74			; OS Prompt 
1a74			 
1a74 .. 00		prompt: db ">",0 
1a76 .. 00		endprg: db "?",0 
1a78			 
1a78			 
1a78			; handy next page prompt 
1a78			next_page_prompt: 
1a78 e5				push hl 
1a79 d5				push de 
1a7a f5				push af 
1a7b c5				push bc 
1a7c			 
1a7c 3e 9f			ld a,display_row_4 + display_cols - 1 
1a7e 11 76 1a		        ld de, endprg 
1a81 cd db 0b			call str_at_display 
1a84 cd eb 0b			call update_display 
1a87 cd 32 65			call cin_wait 
1a8a c1				pop bc 
1a8b f1				pop af 
1a8c d1				pop de 
1a8d e1				pop hl 
1a8e			 
1a8e			 
1a8e c9				ret 
1a8f			 
1a8f			 
1a8f			; forth parser 
1a8f			 
1a8f			; My forth kernel 
1a8f			include "forth_kernel.asm" 
1a8f			; 
1a8f			; kernel to the forth OS 
1a8f			 
1a8f			DS_TYPE_STR: equ 1     ; string type 
1a8f			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1a8f			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1a8f			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1a8f			 
1a8f			FORTH_PARSEV1: equ 0 
1a8f			FORTH_PARSEV2: equ 0 
1a8f			FORTH_PARSEV3: equ 0 
1a8f			FORTH_PARSEV4: equ 0 
1a8f			FORTH_PARSEV5: equ 0 
1a8f			FORTH_PARSEV6: equ 1 
1a8f			 
1a8f			;if FORTH_PARSEV5 
1a8f			;	FORTH_END_BUFFER: equ 0 
1a8f			;else 
1a8f			FORTH_END_BUFFER: equ 127 
1a8f			;endif 
1a8f			 
1a8f			FORTH_TRUE: equ 1 
1a8f			FORTH_FALSE: equ 0 
1a8f			 
1a8f			if FORTH_PARSEV4 
1a8f			include "forth_stackops.asm" 
1a8f			endif 
1a8f			 
1a8f			if FORTH_PARSEV5 
1a8f			include "forth_stackopsv5.asm" 
1a8f			endif 
1a8f			 
1a8f			if FORTH_PARSEV6 
1a8f			include "forth_stackopsv5.asm" 
1a8f			 
1a8f			; Stack operations for v5 parser on wards 
1a8f			; * DATA stack 
1a8f			; * LOOP stack 
1a8f			; * RETURN stack 
1a8f			 
1a8f			 
1a8f			 
1a8f			FORTH_CHK_DSP_UNDER: macro 
1a8f				push hl 
1a8f				push de 
1a8f				ld hl,(cli_data_sp) 
1a8f				ld de, cli_data_stack 
1a8f				call cmp16 
1a8f				jp c, fault_dsp_under 
1a8f				pop de 
1a8f				pop hl 
1a8f				endm 
1a8f			 
1a8f			 
1a8f			FORTH_CHK_RSP_UNDER: macro 
1a8f				push hl 
1a8f				push de 
1a8f				ld hl,(cli_ret_sp) 
1a8f				ld de, cli_ret_stack 
1a8f				call cmp16 
1a8f				jp c, fault_rsp_under 
1a8f				pop de 
1a8f				pop hl 
1a8f				endm 
1a8f			 
1a8f			FORTH_CHK_LOOP_UNDER: macro 
1a8f				push hl 
1a8f				push de 
1a8f				ld hl,(cli_loop_sp) 
1a8f				ld de, cli_loop_stack 
1a8f				call cmp16 
1a8f				jp c, fault_loop_under 
1a8f				pop de 
1a8f				pop hl 
1a8f				endm 
1a8f			 
1a8f			FORTH_ERR_TOS_NOTSTR: macro 
1a8f				; TOSO might need more for checks when used 
1a8f				push af 
1a8f				ld a,(hl) 
1a8f				cp DS_TYPE_STR 
1a8f				jp nz, type_faultn   
1a8f				pop af 
1a8f				endm 
1a8f			 
1a8f			FORTH_ERR_TOS_NOTNUM: macro 
1a8f				push af 
1a8f				ld a,(hl) 
1a8f				cp DS_TYPE_INUM 
1a8f				jp nz, type_faultn   
1a8f				pop af 
1a8f				endm 
1a8f			 
1a8f			 
1a8f			; increase data stack pointer and save hl to it 
1a8f				 
1a8f			FORTH_DSP_NEXT: macro 
1a8f				call macro_forth_dsp_next 
1a8f				endm 
1a8f			 
1a8f			 
1a8f			macro_forth_dsp_next: 
1a8f				if DEBUG_FORTH_STACK_GUARD 
1a8f cd 58 61				call check_stacks 
1a92				endif 
1a92 e5				push hl 
1a93 d5				push de 
1a94 eb				ex de,hl 
1a95 2a e5 e9			ld hl,(cli_data_sp) 
1a98 23				inc hl 
1a99 23				inc hl 
1a9a			 
1a9a			; PARSEV5 
1a9a 23				inc hl 
1a9b 22 e5 e9			ld (cli_data_sp),hl 
1a9e 73				ld (hl), e 
1a9f 23				inc hl 
1aa0 72				ld (hl), d 
1aa1 d1				pop de 
1aa2 e1				pop hl 
1aa3				if DEBUG_FORTH_STACK_GUARD 
1aa3 cd 58 61				call check_stacks 
1aa6				endif 
1aa6 c9				ret 
1aa7			 
1aa7			 
1aa7			; increase ret stack pointer and save hl to it 
1aa7				 
1aa7			FORTH_RSP_NEXT: macro 
1aa7				call macro_forth_rsp_next 
1aa7				endm 
1aa7			 
1aa7			macro_forth_rsp_next: 
1aa7				if DEBUG_FORTH_STACK_GUARD 
1aa7 cd 58 61				call check_stacks 
1aaa				endif 
1aaa e5				push hl 
1aab d5				push de 
1aac eb				ex de,hl 
1aad 2a e9 e9			ld hl,(cli_ret_sp) 
1ab0 23				inc hl 
1ab1 23				inc hl 
1ab2 22 e9 e9			ld (cli_ret_sp),hl 
1ab5 73				ld (hl), e 
1ab6 23				inc hl 
1ab7 72				ld (hl), d 
1ab8 d1				pop de 
1ab9 e1				pop hl 
1aba				if DEBUG_FORTH_STACK_GUARD 
1aba cd 58 61				call check_stacks 
1abd				endif 
1abd c9				ret 
1abe			 
1abe			; get current ret stack pointer and save to hl  
1abe				 
1abe			FORTH_RSP_TOS: macro 
1abe				call macro_forth_rsp_tos 
1abe				endm 
1abe			 
1abe			macro_forth_rsp_tos: 
1abe				;push de 
1abe 2a e9 e9			ld hl,(cli_ret_sp) 
1ac1 cd f9 1a			call loadhlptrtohl 
1ac4				;ld e, (hl) 
1ac4				;inc hl 
1ac4				;ld d, (hl) 
1ac4				;ex de, hl 
1ac4					if DEBUG_FORTH_WORDS 
1ac4			;			DMARK "RST" 
1ac4						CALLMONITOR 
1ac4 cd 6f ee			call debug_vector  
1ac7				endm  
# End of macro CALLMONITOR
1ac7					endif 
1ac7				;pop de 
1ac7 c9				ret 
1ac8			 
1ac8			; pop ret stack pointer 
1ac8				 
1ac8			FORTH_RSP_POP: macro 
1ac8				call macro_forth_rsp_pop 
1ac8				endm 
1ac8			 
1ac8			 
1ac8			macro_forth_rsp_pop: 
1ac8				if DEBUG_FORTH_STACK_GUARD 
1ac8			;		DMARK "RPP" 
1ac8 cd 58 61				call check_stacks 
1acb					FORTH_CHK_RSP_UNDER 
1acb e5				push hl 
1acc d5				push de 
1acd 2a e9 e9			ld hl,(cli_ret_sp) 
1ad0 11 a3 e9			ld de, cli_ret_stack 
1ad3 cd 13 0e			call cmp16 
1ad6 da 6f 62			jp c, fault_rsp_under 
1ad9 d1				pop de 
1ada e1				pop hl 
1adb				endm 
# End of macro FORTH_CHK_RSP_UNDER
1adb				endif 
1adb e5				push hl 
1adc 2a e9 e9			ld hl,(cli_ret_sp) 
1adf			 
1adf			 
1adf				if FORTH_ENABLE_FREE 
1adf			 
1adf					; get pointer 
1adf			 
1adf					push de 
1adf					push hl 
1adf			 
1adf					ld e, (hl) 
1adf					inc hl 
1adf					ld d, (hl) 
1adf			 
1adf					ex de, hl 
1adf					call free 
1adf			 
1adf					pop hl 
1adf					pop de 
1adf			 
1adf			 
1adf				endif 
1adf			 
1adf			 
1adf 2b				dec hl 
1ae0 2b				dec hl 
1ae1 22 e9 e9			ld (cli_ret_sp), hl 
1ae4				; do stack underflow checks 
1ae4 e1				pop hl 
1ae5				if DEBUG_FORTH_STACK_GUARD 
1ae5 cd 58 61				call check_stacks 
1ae8					FORTH_CHK_RSP_UNDER 
1ae8 e5				push hl 
1ae9 d5				push de 
1aea 2a e9 e9			ld hl,(cli_ret_sp) 
1aed 11 a3 e9			ld de, cli_ret_stack 
1af0 cd 13 0e			call cmp16 
1af3 da 6f 62			jp c, fault_rsp_under 
1af6 d1				pop de 
1af7 e1				pop hl 
1af8				endm 
# End of macro FORTH_CHK_RSP_UNDER
1af8				endif 
1af8 c9				ret 
1af9			 
1af9			 
1af9			 
1af9			; routine to load word pointed to by hl into hl 
1af9			 
1af9			loadhlptrtohl: 
1af9			 
1af9 d5				push de 
1afa 5e				ld e, (hl) 
1afb 23				inc hl 
1afc 56				ld d, (hl) 
1afd eb				ex de, hl 
1afe d1				pop de 
1aff			 
1aff c9				ret 
1b00			 
1b00			 
1b00			 
1b00			 
1b00			 
1b00			; push a number held in HL onto the data stack 
1b00			; entry point for pushing a value when already in hl used in function above 
1b00			 
1b00			forth_push_numhl: 
1b00			 
1b00 e5				push hl    ; save value to push 
1b01			 
1b01			if DEBUG_FORTH_PUSH 
1b01				; see if disabled 
1b01			 
1b01			 
1b01 f5				push af 
1b02 3a 6f ee			ld a,(debug_vector) 
1b05 fe c9			cp $c9   ; ret 
1b07			;	ld a, (os_view_disable) 
1b07			;	cp '*' 
1b07 28 34			jr z, .pskip2 
1b09 e5				push hl 
1b0a e5			push hl 
1b0b cd c8 0b			call clear_display 
1b0e e1			pop hl 
1b0f 7c				ld a,h 
1b10 21 bd e5			ld hl, os_word_scratch 
1b13 cd fe 0f			call hexout 
1b16 e1				pop hl 
1b17 7d				ld a,l 
1b18 21 bf e5			ld hl, os_word_scratch+2 
1b1b cd fe 0f			call hexout 
1b1e			 
1b1e 21 c1 e5			ld hl, os_word_scratch+4 
1b21 3e 00			ld a,0 
1b23 77				ld (hl),a 
1b24 11 bd e5			ld de,os_word_scratch 
1b27 3e 28				ld a, display_row_2 
1b29 cd db 0b				call str_at_display 
1b2c 11 51 53			ld de, .push_num 
1b2f 3e 00			ld a, display_row_1 
1b31			 
1b31 cd db 0b				call str_at_display 
1b34			 
1b34			 
1b34 cd eb 0b			call update_display 
1b37 cd 00 0b			call delay1s 
1b3a cd 00 0b			call delay1s 
1b3d			.pskip2:  
1b3d			 
1b3d f1				pop af 
1b3e			endif	 
1b3e			 
1b3e			 
1b3e				FORTH_DSP_NEXT 
1b3e cd 8f 1a			call macro_forth_dsp_next 
1b41				endm 
# End of macro FORTH_DSP_NEXT
1b41			 
1b41 2a e5 e9			ld hl, (cli_data_sp) 
1b44			 
1b44				; save item type 
1b44 3e 02			ld a,  DS_TYPE_INUM 
1b46 77				ld (hl), a 
1b47 23				inc hl 
1b48			 
1b48				; get word off stack 
1b48 d1				pop de 
1b49 7b				ld a,e 
1b4a 77				ld (hl), a 
1b4b 23				inc hl 
1b4c 7a				ld a,d 
1b4d 77				ld (hl), a 
1b4e			 
1b4e			if DEBUG_FORTH_PUSH 
1b4e 2b				dec hl 
1b4f 2b				dec hl 
1b50 2b				dec hl 
1b51						DMARK "PH5" 
1b51 f5				push af  
1b52 3a 66 1b			ld a, (.dmark)  
1b55 32 62 ee			ld (debug_mark),a  
1b58 3a 67 1b			ld a, (.dmark+1)  
1b5b 32 63 ee			ld (debug_mark+1),a  
1b5e 3a 68 1b			ld a, (.dmark+2)  
1b61 32 64 ee			ld (debug_mark+2),a  
1b64 18 03			jr .pastdmark  
1b66 ..			.dmark: db "PH5"  
1b69 f1			.pastdmark: pop af  
1b6a			endm  
# End of macro DMARK
1b6a				CALLMONITOR 
1b6a cd 6f ee			call debug_vector  
1b6d				endm  
# End of macro CALLMONITOR
1b6d			endif	 
1b6d			 
1b6d c9				ret 
1b6e			 
1b6e			 
1b6e			; Push a string to stack pointed to by hl 
1b6e			 
1b6e			forth_push_str: 
1b6e			 
1b6e			if DEBUG_FORTH_PUSH 
1b6e						DMARK "PSQ" 
1b6e f5				push af  
1b6f 3a 83 1b			ld a, (.dmark)  
1b72 32 62 ee			ld (debug_mark),a  
1b75 3a 84 1b			ld a, (.dmark+1)  
1b78 32 63 ee			ld (debug_mark+1),a  
1b7b 3a 85 1b			ld a, (.dmark+2)  
1b7e 32 64 ee			ld (debug_mark+2),a  
1b81 18 03			jr .pastdmark  
1b83 ..			.dmark: db "PSQ"  
1b86 f1			.pastdmark: pop af  
1b87			endm  
# End of macro DMARK
1b87				CALLMONITOR 
1b87 cd 6f ee			call debug_vector  
1b8a				endm  
# End of macro CALLMONITOR
1b8a			endif	 
1b8a			 
1b8a			 
1b8a			    
1b8a e5				push hl 
1b8b e5				push hl 
1b8c			 
1b8c			;	ld a, 0   ; find end of string 
1b8c cd 5b 11			call strlenz 
1b8f			if DEBUG_FORTH_PUSH 
1b8f						DMARK "PQ2" 
1b8f f5				push af  
1b90 3a a4 1b			ld a, (.dmark)  
1b93 32 62 ee			ld (debug_mark),a  
1b96 3a a5 1b			ld a, (.dmark+1)  
1b99 32 63 ee			ld (debug_mark+1),a  
1b9c 3a a6 1b			ld a, (.dmark+2)  
1b9f 32 64 ee			ld (debug_mark+2),a  
1ba2 18 03			jr .pastdmark  
1ba4 ..			.dmark: db "PQ2"  
1ba7 f1			.pastdmark: pop af  
1ba8			endm  
# End of macro DMARK
1ba8				CALLMONITOR 
1ba8 cd 6f ee			call debug_vector  
1bab				endm  
# End of macro CALLMONITOR
1bab			endif	 
1bab eb				ex de, hl 
1bac e1				pop hl   ; get ptr to start of string 
1bad			if DEBUG_FORTH_PUSH 
1bad						DMARK "PQ3" 
1bad f5				push af  
1bae 3a c2 1b			ld a, (.dmark)  
1bb1 32 62 ee			ld (debug_mark),a  
1bb4 3a c3 1b			ld a, (.dmark+1)  
1bb7 32 63 ee			ld (debug_mark+1),a  
1bba 3a c4 1b			ld a, (.dmark+2)  
1bbd 32 64 ee			ld (debug_mark+2),a  
1bc0 18 03			jr .pastdmark  
1bc2 ..			.dmark: db "PQ3"  
1bc5 f1			.pastdmark: pop af  
1bc6			endm  
# End of macro DMARK
1bc6				CALLMONITOR 
1bc6 cd 6f ee			call debug_vector  
1bc9				endm  
# End of macro CALLMONITOR
1bc9			endif	 
1bc9 19				add hl,de 
1bca			if DEBUG_FORTH_PUSH 
1bca						DMARK "PQE" 
1bca f5				push af  
1bcb 3a df 1b			ld a, (.dmark)  
1bce 32 62 ee			ld (debug_mark),a  
1bd1 3a e0 1b			ld a, (.dmark+1)  
1bd4 32 63 ee			ld (debug_mark+1),a  
1bd7 3a e1 1b			ld a, (.dmark+2)  
1bda 32 64 ee			ld (debug_mark+2),a  
1bdd 18 03			jr .pastdmark  
1bdf ..			.dmark: db "PQE"  
1be2 f1			.pastdmark: pop af  
1be3			endm  
# End of macro DMARK
1be3				CALLMONITOR 
1be3 cd 6f ee			call debug_vector  
1be6				endm  
# End of macro CALLMONITOR
1be6			endif	 
1be6			 
1be6 2b				dec hl    ; see if there is an optional trailing double quote 
1be7 7e				ld a,(hl) 
1be8 fe 22			cp '"' 
1bea 20 03			jr nz, .strnoq 
1bec 3e 00			ld a, 0      ; get rid of double quote 
1bee 77				ld (hl), a 
1bef 23			.strnoq: inc hl 
1bf0			 
1bf0 3e 00			ld a, 0 
1bf2 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1bf3			 
1bf3 13				inc de ; add one for the type string 
1bf4 13				inc de ; add one for null term??? 
1bf5			 
1bf5				; tos is get string pointer again 
1bf5				; de contains space to allocate 
1bf5				 
1bf5 d5				push de 
1bf6			 
1bf6 eb				ex de, hl 
1bf7			 
1bf7				;push af 
1bf7			 
1bf7			if DEBUG_FORTH_PUSH 
1bf7						DMARK "PHm" 
1bf7 f5				push af  
1bf8 3a 0c 1c			ld a, (.dmark)  
1bfb 32 62 ee			ld (debug_mark),a  
1bfe 3a 0d 1c			ld a, (.dmark+1)  
1c01 32 63 ee			ld (debug_mark+1),a  
1c04 3a 0e 1c			ld a, (.dmark+2)  
1c07 32 64 ee			ld (debug_mark+2),a  
1c0a 18 03			jr .pastdmark  
1c0c ..			.dmark: db "PHm"  
1c0f f1			.pastdmark: pop af  
1c10			endm  
# End of macro DMARK
1c10				CALLMONITOR 
1c10 cd 6f ee			call debug_vector  
1c13				endm  
# End of macro CALLMONITOR
1c13			endif	 
1c13 cd d0 11			call malloc	; on ret hl now contains allocated memory 
1c16				if DEBUG_FORTH_MALLOC_GUARD 
1c16 cc a9 53				call z,malloc_error 
1c19				endif 
1c19			 
1c19				 
1c19 c1				pop bc    ; get length 
1c1a d1				pop de   ;  get string start    
1c1b			 
1c1b				; hl has destination from malloc 
1c1b			 
1c1b eb				ex de, hl    ; prep for ldir 
1c1c			 
1c1c d5				push de   ; save malloc area for DSP later 
1c1d				;push hl   ; save malloc area for DSP later 
1c1d			 
1c1d			if DEBUG_FORTH_PUSH 
1c1d						DMARK "PHc" 
1c1d f5				push af  
1c1e 3a 32 1c			ld a, (.dmark)  
1c21 32 62 ee			ld (debug_mark),a  
1c24 3a 33 1c			ld a, (.dmark+1)  
1c27 32 63 ee			ld (debug_mark+1),a  
1c2a 3a 34 1c			ld a, (.dmark+2)  
1c2d 32 64 ee			ld (debug_mark+2),a  
1c30 18 03			jr .pastdmark  
1c32 ..			.dmark: db "PHc"  
1c35 f1			.pastdmark: pop af  
1c36			endm  
# End of macro DMARK
1c36				CALLMONITOR 
1c36 cd 6f ee			call debug_vector  
1c39				endm  
# End of macro CALLMONITOR
1c39			endif	 
1c39			 
1c39			 
1c39 ed b0			ldir 
1c3b			 
1c3b			 
1c3b				; push malloc to data stack     macro?????  
1c3b			 
1c3b				FORTH_DSP_NEXT 
1c3b cd 8f 1a			call macro_forth_dsp_next 
1c3e				endm 
# End of macro FORTH_DSP_NEXT
1c3e			 
1c3e				; save value and type 
1c3e			 
1c3e 2a e5 e9			ld hl, (cli_data_sp) 
1c41			 
1c41				; save item type 
1c41 3e 01			ld a,  DS_TYPE_STR 
1c43 77				ld (hl), a 
1c44 23				inc hl 
1c45			 
1c45				; get malloc word off stack 
1c45 d1				pop de 
1c46 73				ld (hl), e 
1c47 23				inc hl 
1c48 72				ld (hl), d 
1c49			 
1c49			 
1c49			 
1c49			if DEBUG_FORTH_PUSH 
1c49 2a e5 e9			ld hl, (cli_data_sp) 
1c4c						DMARK "PHS" 
1c4c f5				push af  
1c4d 3a 61 1c			ld a, (.dmark)  
1c50 32 62 ee			ld (debug_mark),a  
1c53 3a 62 1c			ld a, (.dmark+1)  
1c56 32 63 ee			ld (debug_mark+1),a  
1c59 3a 63 1c			ld a, (.dmark+2)  
1c5c 32 64 ee			ld (debug_mark+2),a  
1c5f 18 03			jr .pastdmark  
1c61 ..			.dmark: db "PHS"  
1c64 f1			.pastdmark: pop af  
1c65			endm  
# End of macro DMARK
1c65				CALLMONITOR 
1c65 cd 6f ee			call debug_vector  
1c68				endm  
# End of macro CALLMONITOR
1c68			;	ex de,hl 
1c68			endif	 
1c68				; in case of spaces, skip the ptr past the copied string 
1c68				;pop af 
1c68				;ld (cli_origptr),hl 
1c68			 
1c68 c9				ret 
1c69			 
1c69			 
1c69			 
1c69			; TODO ascii push input onto stack given hl to start of input 
1c69			 
1c69			; identify type 
1c69			; if starts with a " then a string 
1c69			; otherwise it is a number 
1c69			;  
1c69			; if a string 
1c69			;     scan for ending " to get length of string to malloc for + 1 
1c69			;     malloc 
1c69			;     put pointer to string on stack first byte flags as string 
1c69			; 
1c69			; else a number 
1c69			;    look for number format identifier 
1c69			;    $xx hex 
1c69			;    %xxxxx bin 
1c69			;    xxxxx decimal 
1c69			;    convert number to 16bit word.  
1c69			;    malloc word + 1 with flag to identiy as num 
1c69			;    put pointer to number on stack 
1c69			;   
1c69			;  
1c69			  
1c69			forth_apush: 
1c69				; kernel push 
1c69			 
1c69			if DEBUG_FORTH_PUSH 
1c69						DMARK "PSH" 
1c69 f5				push af  
1c6a 3a 7e 1c			ld a, (.dmark)  
1c6d 32 62 ee			ld (debug_mark),a  
1c70 3a 7f 1c			ld a, (.dmark+1)  
1c73 32 63 ee			ld (debug_mark+1),a  
1c76 3a 80 1c			ld a, (.dmark+2)  
1c79 32 64 ee			ld (debug_mark+2),a  
1c7c 18 03			jr .pastdmark  
1c7e ..			.dmark: db "PSH"  
1c81 f1			.pastdmark: pop af  
1c82			endm  
# End of macro DMARK
1c82				CALLMONITOR 
1c82 cd 6f ee			call debug_vector  
1c85				endm  
# End of macro CALLMONITOR
1c85			endif	 
1c85				; identify input type 
1c85			 
1c85 7e				ld a,(hl) 
1c86			 
1c86 fe 23			cp '#' 
1c88 ca c2 1c			jp z, .fapdec 
1c8b			 
1c8b			 
1c8b fe 22			cp '"' 
1c8d 28 0a			jr z, .fapstr 
1c8f fe 24			cp '$' 
1c91 ca b9 1c			jp z, .faphex 
1c94 fe 25			cp '%' 
1c96 ca a1 1c			jp z, .fapbin 
1c99			;	cp 'b' 
1c99			;	jp z, .fabin 
1c99				; else decimal 
1c99			 
1c99				; TODO do decimal conversion 
1c99				; decimal is stored as a 16bit word 
1c99			 
1c99				; by default everything is a string if type is not detected 
1c99			.fapstr: ; 
1c99 fe 22			cp '"' 
1c9b 20 01			jr nz, .strnoqu 
1c9d 23				inc hl 
1c9e			.strnoqu: 
1c9e c3 6e 1b			jp forth_push_str 
1ca1			 
1ca1			 
1ca1			 
1ca1			.fapbin:    ; push a binary string.  
1ca1 11 00 00			ld de, 0   ; hold a 16bit value 
1ca4			 
1ca4 23			.fapbinshift:	inc hl  
1ca5 7e				ld a,(hl) 
1ca6 fe 00			cp 0     ; done scanning  
1ca8 28 0b			jr z, .fapbdone  	; got it in HL so push  
1caa			 
1caa				; left shift de 
1caa eb				ex de, hl	 
1cab 29				add hl, hl 
1cac			 
1cac				; is 1 
1cac fe 31			cp '1' 
1cae 20 02			jr nz, .binzero 
1cb0 cb 4d			bit 1, l 
1cb2			.binzero: 
1cb2 eb				ex de, hl	 ; save current de 
1cb3 18 ef			jr .fapbinshift 
1cb5			 
1cb5			.fapbdone: 
1cb5 eb				ex de, hl 
1cb6 c3 00 1b			jp forth_push_numhl 
1cb9			 
1cb9			 
1cb9			.faphex:   ; hex is always stored as a 16bit word 
1cb9				; skip number prefix 
1cb9 23				inc hl 
1cba				; turn ascii into number 
1cba cd b4 10			call get_word_hl	; ret 16bit word in hl 
1cbd			 
1cbd c3 00 1b			jp forth_push_numhl 
1cc0			 
1cc0 00				 nop 
1cc1			 
1cc1			.fabin:   ; TODO bin conversion 
1cc1			 
1cc1			 
1cc1 c9				ret 
1cc2			.fapdec:	 
1cc2				; string to dec conversion 
1cc2 23				inc hl 
1cc3 eb				ex de, hl 
1cc4 cd f2 10			call string_to_uint16 
1cc7 c3 00 1b			jp forth_push_numhl 
1cca c9				ret 
1ccb				 
1ccb			;atoui_16: 
1ccb			 
1ccb			; get either a string ptr or a 16bit word from the data stack 
1ccb			 
1ccb			FORTH_DSP: macro 
1ccb				call macro_forth_dsp 
1ccb				endm 
1ccb			 
1ccb			macro_forth_dsp: 
1ccb				; data stack pointer points to current word on tos 
1ccb			 
1ccb 2a e5 e9			ld hl,(cli_data_sp) 
1cce			 
1cce				if DEBUG_FORTH_PUSH 
1cce						DMARK "DSP" 
1cce f5				push af  
1ccf 3a e3 1c			ld a, (.dmark)  
1cd2 32 62 ee			ld (debug_mark),a  
1cd5 3a e4 1c			ld a, (.dmark+1)  
1cd8 32 63 ee			ld (debug_mark+1),a  
1cdb 3a e5 1c			ld a, (.dmark+2)  
1cde 32 64 ee			ld (debug_mark+2),a  
1ce1 18 03			jr .pastdmark  
1ce3 ..			.dmark: db "DSP"  
1ce6 f1			.pastdmark: pop af  
1ce7			endm  
# End of macro DMARK
1ce7			 
1ce7 cd dc 53				call display_data_sp 
1cea				;call break_point_state 
1cea				;rst 030h 
1cea				CALLMONITOR 
1cea cd 6f ee			call debug_vector  
1ced				endm  
# End of macro CALLMONITOR
1ced				endif 
1ced			 
1ced c9				ret 
1cee			 
1cee			; return hl to start of value on stack 
1cee			 
1cee			FORTH_DSP_VALUE: macro 
1cee				call macro_forth_dsp_value 
1cee				endm 
1cee			 
1cee			macro_forth_dsp_value: 
1cee			 
1cee				FORTH_DSP 
1cee cd cb 1c			call macro_forth_dsp 
1cf1				endm 
# End of macro FORTH_DSP
1cf1			 
1cf1 d5				push de 
1cf2			 
1cf2 23				inc hl ; skip type 
1cf3			 
1cf3 5e				ld e, (hl) 
1cf4 23				inc hl 
1cf5 56				ld d, (hl) 
1cf6 eb				ex de,hl  
1cf7			 
1cf7 d1				pop de 
1cf8			 
1cf8 c9				ret 
1cf9			 
1cf9			; return hl to start of value to second item on stack 
1cf9			 
1cf9			FORTH_DSP_VALUEM1: macro 
1cf9				call macro_forth_dsp_value_m1 
1cf9				endm 
1cf9			 
1cf9			macro_forth_dsp_value_m1: 
1cf9			 
1cf9				FORTH_DSP 
1cf9 cd cb 1c			call macro_forth_dsp 
1cfc				endm 
# End of macro FORTH_DSP
1cfc			 
1cfc 2b				dec hl 
1cfd 2b				dec hl 
1cfe			;	dec hl 
1cfe			 
1cfe d5				push de 
1cff			 
1cff 5e				ld e, (hl) 
1d00 23				inc hl 
1d01 56				ld d, (hl) 
1d02 eb				ex de,hl  
1d03			 
1d03 d1				pop de 
1d04			 
1d04 c9				ret 
1d05			 
1d05				 
1d05			 
1d05			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1d05			 
1d05			FORTH_DSP_POP: macro 
1d05				call macro_forth_dsp_pop 
1d05				endm 
1d05			 
1d05			 
1d05			; get the tos data type 
1d05			 
1d05			FORTH_DSP_TYPE:   macro 
1d05			 
1d05				;FORTH_DSP_VALUE 
1d05				FORTH_DSP 
1d05				 
1d05				; hl points to value 
1d05				; check type 
1d05			 
1d05				ld a,(hl) 
1d05			 
1d05				endm 
1d05			 
1d05			; load the tos value into hl 
1d05			 
1d05			 
1d05			FORTH_DSP_VALUEHL:  macro 
1d05				call macro_dsp_valuehl 
1d05				endm 
1d05			 
1d05			 
1d05			 
1d05			macro_dsp_valuehl: 
1d05				FORTH_DSP_VALUE 
1d05 cd ee 1c			call macro_forth_dsp_value 
1d08				endm 
# End of macro FORTH_DSP_VALUE
1d08			 
1d08				;FORTH_ERR_TOS_NOTNUM 
1d08			 
1d08				;inc hl   ; skip type id 
1d08			 
1d08			;	push de 
1d08			; 
1d08			;	ld e, (hl) 
1d08			;	inc hl 
1d08			;	ld d, (hl) 
1d08			;	ex de,hl  
1d08			 
1d08			;	pop de 
1d08			 
1d08				if DEBUG_FORTH_PUSH 
1d08						DMARK "DVL" 
1d08 f5				push af  
1d09 3a 1d 1d			ld a, (.dmark)  
1d0c 32 62 ee			ld (debug_mark),a  
1d0f 3a 1e 1d			ld a, (.dmark+1)  
1d12 32 63 ee			ld (debug_mark+1),a  
1d15 3a 1f 1d			ld a, (.dmark+2)  
1d18 32 64 ee			ld (debug_mark+2),a  
1d1b 18 03			jr .pastdmark  
1d1d ..			.dmark: db "DVL"  
1d20 f1			.pastdmark: pop af  
1d21			endm  
# End of macro DMARK
1d21				CALLMONITOR 
1d21 cd 6f ee			call debug_vector  
1d24				endm  
# End of macro CALLMONITOR
1d24				endif 
1d24 c9				ret 
1d25			 
1d25			forth_apushstrhl:      
1d25				; push of string requires use of cli_origptr 
1d25				; bodge use 
1d25			 
1d25				; get current cli_origptr, save, update with temp pointer  
1d25 ed 5b 35 ea		ld de, (cli_origptr) 
1d29 22 35 ea			ld (cli_origptr), hl 
1d2c d5				push de 
1d2d cd 69 1c			call forth_apush 
1d30 d1				pop de 
1d31 ed 53 35 ea		ld (cli_origptr), de 
1d35 c9			        ret	 
1d36			 
1d36			 
1d36			; increase loop stack pointer and save hl to it 
1d36				 
1d36			FORTH_LOOP_NEXT: macro 
1d36				call macro_forth_loop_next 
1d36				;nop 
1d36				endm 
1d36			 
1d36			macro_forth_loop_next: 
1d36				if DEBUG_FORTH_STACK_GUARD 
1d36 cd 58 61				call check_stacks 
1d39				endif 
1d39 e5				push hl 
1d3a d5				push de 
1d3b eb				ex de,hl 
1d3c 2a e7 e9			ld hl,(cli_loop_sp) 
1d3f 23				inc hl 
1d40 23				inc hl 
1d41					if DEBUG_FORTH_WORDS 
1d41						DMARK "LNX" 
1d41 f5				push af  
1d42 3a 56 1d			ld a, (.dmark)  
1d45 32 62 ee			ld (debug_mark),a  
1d48 3a 57 1d			ld a, (.dmark+1)  
1d4b 32 63 ee			ld (debug_mark+1),a  
1d4e 3a 58 1d			ld a, (.dmark+2)  
1d51 32 64 ee			ld (debug_mark+2),a  
1d54 18 03			jr .pastdmark  
1d56 ..			.dmark: db "LNX"  
1d59 f1			.pastdmark: pop af  
1d5a			endm  
# End of macro DMARK
1d5a						CALLMONITOR 
1d5a cd 6f ee			call debug_vector  
1d5d				endm  
# End of macro CALLMONITOR
1d5d					endif 
1d5d 22 e7 e9			ld (cli_loop_sp),hl 
1d60 73				ld (hl), e 
1d61 23				inc hl 
1d62 72				ld (hl), d 
1d63 d1				pop de    ; been reversed so save a swap on restore 
1d64 e1				pop hl 
1d65				if DEBUG_FORTH_STACK_GUARD 
1d65 cd 58 61				call check_stacks 
1d68				endif 
1d68 c9				ret 
1d69			 
1d69			; get current ret stack pointer and save to hl  
1d69				 
1d69			FORTH_LOOP_TOS: macro 
1d69				call macro_forth_loop_tos 
1d69				endm 
1d69			 
1d69			macro_forth_loop_tos: 
1d69 d5				push de 
1d6a 2a e7 e9			ld hl,(cli_loop_sp) 
1d6d 5e				ld e, (hl) 
1d6e 23				inc hl 
1d6f 56				ld d, (hl) 
1d70 eb				ex de, hl 
1d71 d1				pop de 
1d72 c9				ret 
1d73			 
1d73			; pop loop stack pointer 
1d73				 
1d73			FORTH_LOOP_POP: macro 
1d73				call macro_forth_loop_pop 
1d73				endm 
1d73			 
1d73			 
1d73			macro_forth_loop_pop: 
1d73				if DEBUG_FORTH_STACK_GUARD 
1d73					DMARK "LPP" 
1d73 f5				push af  
1d74 3a 88 1d			ld a, (.dmark)  
1d77 32 62 ee			ld (debug_mark),a  
1d7a 3a 89 1d			ld a, (.dmark+1)  
1d7d 32 63 ee			ld (debug_mark+1),a  
1d80 3a 8a 1d			ld a, (.dmark+2)  
1d83 32 64 ee			ld (debug_mark+2),a  
1d86 18 03			jr .pastdmark  
1d88 ..			.dmark: db "LPP"  
1d8b f1			.pastdmark: pop af  
1d8c			endm  
# End of macro DMARK
1d8c cd 58 61				call check_stacks 
1d8f					FORTH_CHK_LOOP_UNDER 
1d8f e5				push hl 
1d90 d5				push de 
1d91 2a e7 e9			ld hl,(cli_loop_sp) 
1d94 11 21 e9			ld de, cli_loop_stack 
1d97 cd 13 0e			call cmp16 
1d9a da 75 62			jp c, fault_loop_under 
1d9d d1				pop de 
1d9e e1				pop hl 
1d9f				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1d9f				endif 
1d9f e5				push hl 
1da0 2a e7 e9			ld hl,(cli_loop_sp) 
1da3 2b				dec hl 
1da4 2b				dec hl 
1da5 22 e7 e9			ld (cli_loop_sp), hl 
1da8				; TODO do stack underflow checks 
1da8 e1				pop hl 
1da9				if DEBUG_FORTH_STACK_GUARD 
1da9 cd 58 61				call check_stacks 
1dac					FORTH_CHK_LOOP_UNDER 
1dac e5				push hl 
1dad d5				push de 
1dae 2a e7 e9			ld hl,(cli_loop_sp) 
1db1 11 21 e9			ld de, cli_loop_stack 
1db4 cd 13 0e			call cmp16 
1db7 da 75 62			jp c, fault_loop_under 
1dba d1				pop de 
1dbb e1				pop hl 
1dbc				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1dbc				endif 
1dbc c9				ret 
1dbd			 
1dbd			macro_forth_dsp_pop: 
1dbd			 
1dbd e5				push hl 
1dbe			 
1dbe				; release malloc data 
1dbe			 
1dbe				if DEBUG_FORTH_STACK_GUARD 
1dbe cd 58 61				call check_stacks 
1dc1					FORTH_CHK_DSP_UNDER 
1dc1 e5				push hl 
1dc2 d5				push de 
1dc3 2a e5 e9			ld hl,(cli_data_sp) 
1dc6 11 1f e8			ld de, cli_data_stack 
1dc9 cd 13 0e			call cmp16 
1dcc da 69 62			jp c, fault_dsp_under 
1dcf d1				pop de 
1dd0 e1				pop hl 
1dd1				endm 
# End of macro FORTH_CHK_DSP_UNDER
1dd1				endif 
1dd1				;ld hl,(cli_data_sp) 
1dd1			if DEBUG_FORTH_DOT 
1dd1				DMARK "DPP" 
1dd1 f5				push af  
1dd2 3a e6 1d			ld a, (.dmark)  
1dd5 32 62 ee			ld (debug_mark),a  
1dd8 3a e7 1d			ld a, (.dmark+1)  
1ddb 32 63 ee			ld (debug_mark+1),a  
1dde 3a e8 1d			ld a, (.dmark+2)  
1de1 32 64 ee			ld (debug_mark+2),a  
1de4 18 03			jr .pastdmark  
1de6 ..			.dmark: db "DPP"  
1de9 f1			.pastdmark: pop af  
1dea			endm  
# End of macro DMARK
1dea				CALLMONITOR 
1dea cd 6f ee			call debug_vector  
1ded				endm  
# End of macro CALLMONITOR
1ded			endif	 
1ded			 
1ded			 
1ded			if FORTH_ENABLE_DSPPOPFREE 
1ded			 
1ded				FORTH_DSP 
1ded cd cb 1c			call macro_forth_dsp 
1df0				endm 
# End of macro FORTH_DSP
1df0			 
1df0 7e				ld a, (hl) 
1df1 fe 01			cp DS_TYPE_STR 
1df3 20 22			jr nz, .skippopfree 
1df5			 
1df5				FORTH_DSP_VALUEHL 
1df5 cd 05 1d			call macro_dsp_valuehl 
1df8				endm 
# End of macro FORTH_DSP_VALUEHL
1df8			;	nop 
1df8			if DEBUG_FORTH_DOT 
1df8				DMARK "DPf" 
1df8 f5				push af  
1df9 3a 0d 1e			ld a, (.dmark)  
1dfc 32 62 ee			ld (debug_mark),a  
1dff 3a 0e 1e			ld a, (.dmark+1)  
1e02 32 63 ee			ld (debug_mark+1),a  
1e05 3a 0f 1e			ld a, (.dmark+2)  
1e08 32 64 ee			ld (debug_mark+2),a  
1e0b 18 03			jr .pastdmark  
1e0d ..			.dmark: db "DPf"  
1e10 f1			.pastdmark: pop af  
1e11			endm  
# End of macro DMARK
1e11				CALLMONITOR 
1e11 cd 6f ee			call debug_vector  
1e14				endm  
# End of macro CALLMONITOR
1e14			endif	 
1e14 cd 9a 12			call free 
1e17			.skippopfree: 
1e17				 
1e17			 
1e17			endif 
1e17			 
1e17			if DEBUG_FORTH_DOT_KEY 
1e17				DMARK "DP2" 
1e17				CALLMONITOR 
1e17			endif	 
1e17			 
1e17				; move pointer down 
1e17			 
1e17 2a e5 e9			ld hl,(cli_data_sp) 
1e1a 2b				dec hl 
1e1b 2b				dec hl 
1e1c			; PARSEV5 
1e1c 2b				dec hl 
1e1d 22 e5 e9			ld (cli_data_sp), hl 
1e20			 
1e20				if DEBUG_FORTH_STACK_GUARD 
1e20 cd 58 61				call check_stacks 
1e23					FORTH_CHK_DSP_UNDER 
1e23 e5				push hl 
1e24 d5				push de 
1e25 2a e5 e9			ld hl,(cli_data_sp) 
1e28 11 1f e8			ld de, cli_data_stack 
1e2b cd 13 0e			call cmp16 
1e2e da 69 62			jp c, fault_dsp_under 
1e31 d1				pop de 
1e32 e1				pop hl 
1e33				endm 
# End of macro FORTH_CHK_DSP_UNDER
1e33				endif 
1e33			 
1e33 e1				pop hl 
1e34			 
1e34 c9				ret 
1e35			 
1e35			getwordathl: 
1e35				; hl points to an address 
1e35				; load hl with the word at that address 
1e35			 
1e35 d5				push de 
1e36			 
1e36 5e				ld e, (hl) 
1e37 23				inc hl 
1e38 56				ld d, (hl) 
1e39 eb				ex de, hl 
1e3a			 
1e3a d1				pop de 
1e3b c9				ret 
1e3c			 
1e3c			 
1e3c			; functions to manuplite stack pointers 
1e3c			 
1e3c			; generate fragment to set hl to be pointer to a stack item 
1e3c			 
1e3c			FORTH_DSP_PTR: macro  x 
1e3c				ld hl,(cli_data_sp) 
1e3c				ld de, x * 3 
1e3c				sbc hl, de 
1e3c				endm 
1e3c			 
1e3c			 
1e3c			 
1e3c			; copy point in hl to stack tmp storage slots 1-4 
1e3c			hltostack1: 
1e3c 11 b5 e2			ld de, os_stack_1  
1e3f c3 6a 1e			jp hltostackmv 
1e42			 
1e42			hltostack2:  
1e42 11 b2 e2			ld de, os_stack_2 
1e45 c3 6a 1e			jp hltostackmv 
1e48			 
1e48			hltostack3:  
1e48 11 af e2			ld de, os_stack_3 
1e4b c3 6a 1e			jp hltostackmv 
1e4e			 
1e4e			hltostack4:  
1e4e 11 ac e2			ld de, os_stack_4  
1e51 c3 6a 1e			jp hltostackmv 
1e54			 
1e54			; copy to point in hl from stack tmp storage slots 1-4 
1e54			hlfromstack1: 
1e54 11 b5 e2			ld de, os_stack_1 
1e57 c3 69 1e			jp hlfromsttackmv 
1e5a			 
1e5a			hlfromstack2:  
1e5a 11 b2 e2			ld de, os_stack_2 
1e5d c3 69 1e			jp hlfromsttackmv 
1e60			 
1e60			hlfromstack3:  
1e60 11 af e2			ld de, os_stack_3 
1e63 c3 69 1e			jp hlfromsttackmv 
1e66			 
1e66			hlfromstack4:  
1e66 11 ac e2			ld de, os_stack_4 
1e69			 
1e69			hlfromsttackmv: 
1e69 eb				ex de, hl 
1e6a			 
1e6a			hltostackmv: 
1e6a			 
1e6a				; do stack move 
1e6a c5				push bc 
1e6b 01 03 00			ld bc, 3 
1e6e ed b0			ldir  
1e70 c1				pop bc	 
1e71 c9				ret 
1e72			 
1e72			; eof 
1e72			 
# End of file forth_stackopsv5.asm
1e72			endif 
1e72			loadwordinhl:	 
1e72			 
1e72 d5				push de 
1e73			 
1e73 5e				ld e, (hl) 
1e74 23				inc hl 
1e75 56				ld d, (hl) 
1e76 eb				ex de,hl  
1e77			 
1e77 d1				pop de 
1e78			 
1e78 c9				ret 
1e79			 
1e79			user_word_eol:  
1e79				; hl contains the pointer to where to create a linked list item from the end 
1e79				; of the user dict to continue on at the system word dict 
1e79				 
1e79				; poke the stub of the word list linked list to repoint to rom words 
1e79			 
1e79				; stub format 
1e79				; db   word id 
1e79				; dw    link to next word 
1e79			        ; db char length of token 
1e79				; db string + 0 term 
1e79				; db exec code....  
1e79			 
1e79 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1e7b 77				ld (hl), a		; word id 
1e7c 23				inc hl 
1e7d			 
1e7d 11 34 20			ld de, sysdict 
1e80 73				ld (hl), e		; next word link ie system dict 
1e81 23				inc hl 
1e82 72				ld (hl), d		; next word link ie system dict 
1e83 23				inc hl	 
1e84			 
1e84			;	ld (hl), sysdict		; next word link ie system dict 
1e84			;	inc hl 
1e84			;	inc hl 
1e84			 
1e84			;	inc hl 
1e84			;	inc hl 
1e84			 
1e84 3e 02			ld a, 2			; word length is 0 
1e86 77				ld (hl), a	 
1e87 23				inc hl 
1e88			 
1e88 3e 7e			ld a, '~'			; word length is 0 
1e8a 77				ld (hl), a	 
1e8b 23				inc hl 
1e8c 3e 00			ld a, 0			; save empty word 
1e8e 77				ld (hl), a 
1e8f			 
1e8f c9				ret 
1e90			 
1e90				 
1e90			 
1e90			forthexec_cleanup: 
1e90				FORTH_RSP_POP 
1e90 cd c8 1a			call macro_forth_rsp_pop 
1e93				endm 
# End of macro FORTH_RSP_POP
1e93 c9				ret 
1e94			 
1e94			forth_call_hl: 
1e94				; taking hl 
1e94 e5				push hl 
1e95 c9				ret 
1e96			 
1e96			; this is called to reset Forth system but keep existing uwords etc 
1e96			 
1e96			forth_warmstart: 
1e96				; setup stack over/under flow checks 
1e96				if DEBUG_FORTH_STACK_GUARD 
1e96 cd 3e 61				call chk_stk_init 
1e99				endif 
1e99			 
1e99				; init stack pointers  - * these stacks go upwards *  
1e99 21 a3 e9			ld hl, cli_ret_stack 
1e9c 22 e9 e9			ld (cli_ret_sp), hl	 
1e9f				; set bottom of stack 
1e9f 3e 00			ld a,0 
1ea1 77				ld (hl),a 
1ea2 23				inc hl 
1ea3 77				ld (hl),a 
1ea4			 
1ea4 21 1f e8			ld hl, cli_data_stack 
1ea7 22 e5 e9			ld (cli_data_sp), hl	 
1eaa				; set bottom of stack 
1eaa 3e 00			ld a,0 
1eac 77				ld (hl),a 
1ead 23				inc hl 
1eae 77				ld (hl),a 
1eaf			 
1eaf 21 21 e9			ld hl, cli_loop_stack 
1eb2 22 e7 e9			ld (cli_loop_sp), hl	 
1eb5				; set bottom of stack 
1eb5 3e 00			ld a,0 
1eb7 77				ld (hl),a 
1eb8 23				inc hl 
1eb9 77				ld (hl),a 
1eba			 
1eba				; init extent of current open file 
1eba			 
1eba 3e 00			ld a, 0 
1ebc 32 61 ea			ld (store_openext), a 
1ebf			 
1ebf c9				ret 
1ec0			 
1ec0			 
1ec0			 
1ec0			; Cold Start - this is called to setup the whole Forth system 
1ec0			 
1ec0			forth_init: 
1ec0			 
1ec0				; setup stack over/under flow checks 
1ec0			 
1ec0			;	if DEBUG_FORTH_STACK_GUARD 
1ec0			;		call chk_stk_init 
1ec0			;	endif 
1ec0			 
1ec0				; enable auto display updates (slow.....) 
1ec0			 
1ec0 3e 01			ld a, 1 
1ec2 32 33 ea			ld (cli_autodisplay), a 
1ec5			 
1ec5				; if storage is in use disable long reads for now 
1ec5 3e 00			ld a, 0 
1ec7 32 6c ea			ld (store_longread), a 
1eca			 
1eca			 
1eca				; show start up screen 
1eca			 
1eca cd c8 0b			call clear_display 
1ecd			 
1ecd 3e 00			ld a,0 
1ecf 32 55 ea			ld (f_cursor_ptr), a 
1ed2			 
1ed2				; set start of word list in start of ram - for use when creating user words 
1ed2			 
1ed2 21 53 65			ld hl, baseram 
1ed5 22 b5 e5			ld (os_last_new_uword), hl 
1ed8 cd 79 1e			call user_word_eol 
1edb				 
1edb			;		call display_data_sp 
1edb			;		call next_page_prompt 
1edb			 
1edb			 
1edb			 
1edb			 
1edb c9				ret 
1edc			 
1edc .. 00		.bootforth: db " Forth Kernel Init ",0 
1ef0			 
1ef0			; TODO push to stack 
1ef0			 
1ef0			;  
1ef0			 
1ef0			if FORTH_PARSEV2 
1ef0			 
1ef0			 
1ef0				include "forth_parserv2.asm" 
1ef0			 
1ef0			endif 
1ef0			 
1ef0			 
1ef0			; parse cli version 1 
1ef0			 
1ef0			if FORTH_PARSEV1 
1ef0			 
1ef0			 
1ef0			 
1ef0			      include "forth_parserv1.asm" 
1ef0			endif 
1ef0				 
1ef0			if FORTH_PARSEV3 
1ef0			      include "forth_parserv3.asm" 
1ef0				include "forth_wordsv3.asm" 
1ef0			endif 
1ef0			 
1ef0			if FORTH_PARSEV4 
1ef0			      include "forth_parserv4.asm" 
1ef0				include "forth_wordsv4.asm" 
1ef0			endif 
1ef0			 
1ef0			if FORTH_PARSEV5 
1ef0			      include "forth_parserv5.asm" 
1ef0				include "forth_wordsv4.asm" 
1ef0			endif 
1ef0			 
1ef0			if FORTH_PARSEV6 
1ef0			      include "forth_parserv6.asm" 
1ef0			 
1ef0			 
1ef0			; A better parser without using malloc and string copies all over the place.  
1ef0			; Exec in situ should be faster 
1ef0			 
1ef0			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1ef0			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1ef0			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1ef0			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1ef0			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1ef0			WORD_SYS_END: equ 0   ; Opcode for all user words 
1ef0			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1ef0			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1ef0			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1ef0			 
1ef0			; Core word preamble macro 
1ef0			 
1ef0			CWHEAD:   macro nxtword opcode lit len opflags 
1ef0				db WORD_SYS_CORE+opcode             
1ef0				; internal op code number 
1ef0				dw nxtword            
1ef0				; link to next dict word block 
1ef0				db len + 1 
1ef0				; literal length of dict word inc zero term 
1ef0				db lit,0              
1ef0				; literal dict word 
1ef0			        ; TODO db opflags        
1ef0				endm 
1ef0			 
1ef0			 
1ef0			NEXTW: macro  
1ef0				call parse_vector 
1ef0				jp macro_next 
1ef0				endm 
1ef0			 
1ef0			macro_next: 
1ef0			if DEBUG_FORTH_PARSE_EXEC 
1ef0				DMARK "NXT" 
1ef0				CALLMONITOR 
1ef0			endif	 
1ef0			;	inc hl  ; skip token null term  
1ef0 ed 4b 37 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1ef4 ed 5b 35 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1ef8 2a b9 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1efb			if DEBUG_FORTH_PARSE_EXEC 
1efb				DMARK "}AA" 
1efb				CALLMONITOR 
1efb			endif	 
1efb c3 ea 1f			jp execnext 
1efe				;jp exec1 
1efe			       
1efe			 
1efe			 
1efe			; Another go at the parser to compile  
1efe			 
1efe			 
1efe			; TODO rework parser to change all of the string words to byte tokens 
1efe			; TODO do a search for  
1efe			 
1efe			; TODO first run normal parser to zero term sections 
1efe			; TODO for each word do a token look up to get the op code 
1efe			; TODO need some means to flag to the exec that this is a byte code form    
1efe			 
1efe			 
1efe			forthcompile: 
1efe			 
1efe			; 
1efe			; line parse: 
1efe			;       parse raw input buffer 
1efe			;       tokenise the words 
1efe			;       malloc new copy (for looping etc) 
1efe			;       copy to malloc + current pc in line to start of string and add line term 
1efe			;       save on new rsp 
1efe			; 
1efe			 
1efe			; hl to point to the line to tokenise 
1efe			 
1efe			;	push hl 
1efe 22 b9 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1f01			 
1f01			;	ld a,0		; string term on input 
1f01			;	call strlent 
1f01			 
1f01			;	ld (os_tok_len), hl	 ; save string length 
1f01			 
1f01			;if DEBUG_FORTH_TOK 
1f01			;	ex de,hl		 
1f01			;endif 
1f01			 
1f01			;	pop hl 		; get back string pointer 
1f01			 
1f01			if DEBUG_FORTH_TOK 
1f01						DMARK "TOc" 
1f01				CALLMONITOR 
1f01			endif 
1f01 7e			.cptoken2:    ld a,(hl) 
1f02 23				inc hl 
1f03 fe 7f			cp FORTH_END_BUFFER 
1f05 28 29			jr z, .cptokendone2 
1f07 fe 00			cp 0 
1f09 28 25			jr z, .cptokendone2 
1f0b fe 22			cp '"' 
1f0d 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1f0f fe 20			cp ' ' 
1f11 20 ee			jr nz,  .cptoken2 
1f13			 
1f13			; TODO consume comments held between ( and ) 
1f13			 
1f13				; we have a space so change to zero term for dict match later 
1f13 2b				dec hl 
1f14 3e 00			ld a,0 
1f16 77				ld (hl), a 
1f17 23				inc hl 
1f18 18 e7			jr .cptoken2 
1f1a				 
1f1a			 
1f1a			.cptokenstr2: 
1f1a				; skip all white space until either eol (because forgot to term) or end double quote 
1f1a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f1a				;inc hl ; skip current double quote 
1f1a 7e				ld a,(hl) 
1f1b 23				inc hl 
1f1c fe 22			cp '"' 
1f1e 28 e1			jr z, .cptoken2 
1f20 fe 7f			cp FORTH_END_BUFFER 
1f22 28 0c			jr z, .cptokendone2 
1f24 fe 00			cp 0 
1f26 28 08			jr z, .cptokendone2 
1f28 fe 20			cp ' ' 
1f2a 28 02			jr z, .cptmp2 
1f2c 18 ec			jr .cptokenstr2 
1f2e			 
1f2e			.cptmp2:	; we have a space so change to zero term for dict match later 
1f2e				;dec hl 
1f2e				;ld a,"-"	; TODO remove this when working 
1f2e				;ld (hl), a 
1f2e				;inc hl 
1f2e 18 ea			jr .cptokenstr2 
1f30			 
1f30			.cptokendone2: 
1f30				;inc hl 
1f30 3e 7f			ld a, FORTH_END_BUFFER 
1f32 77				ld (hl),a 
1f33			;	inc hl 
1f33			;	ld a, '!' 
1f33			;	ld (hl),a 
1f33			 
1f33 2a b9 e5			ld hl,(os_tok_ptr) 
1f36			         
1f36			if DEBUG_FORTH_TOK 
1f36						DMARK "Tc1" 
1f36				CALLMONITOR 
1f36			endif 
1f36			 
1f36				; push exec string to top of return stack 
1f36				FORTH_RSP_NEXT 
1f36 cd a7 1a			call macro_forth_rsp_next 
1f39				endm 
# End of macro FORTH_RSP_NEXT
1f39 c9				ret 
1f3a			 
1f3a			; Another go at the parser need to simplify the process 
1f3a			 
1f3a			forthparse: 
1f3a			 
1f3a			; 
1f3a			; line parse: 
1f3a			;       parse raw input buffer 
1f3a			;       tokenise the words 
1f3a			;       malloc new copy (for looping etc) 
1f3a			;       copy to malloc + current pc in line to start of string and add line term 
1f3a			;       save on new rsp 
1f3a			; 
1f3a			 
1f3a			; hl to point to the line to tokenise 
1f3a			 
1f3a			;	push hl 
1f3a 22 b9 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1f3d			 
1f3d			;	ld a,0		; string term on input 
1f3d			;	call strlent 
1f3d			 
1f3d			;	ld (os_tok_len), hl	 ; save string length 
1f3d			 
1f3d			;if DEBUG_FORTH_TOK 
1f3d			;	ex de,hl		 
1f3d			;endif 
1f3d			 
1f3d			;	pop hl 		; get back string pointer 
1f3d			 
1f3d			if DEBUG_FORTH_TOK 
1f3d						DMARK "TOK" 
1f3d				CALLMONITOR 
1f3d			endif 
1f3d 7e			.ptoken2:    ld a,(hl) 
1f3e 23				inc hl 
1f3f fe 7f			cp FORTH_END_BUFFER 
1f41 28 29			jr z, .ptokendone2 
1f43 fe 00			cp 0 
1f45 28 25			jr z, .ptokendone2 
1f47 fe 22			cp '"' 
1f49 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1f4b fe 20			cp ' ' 
1f4d 20 ee			jr nz,  .ptoken2 
1f4f			 
1f4f			; TODO consume comments held between ( and ) 
1f4f			 
1f4f				; we have a space so change to zero term for dict match later 
1f4f 2b				dec hl 
1f50 3e 00			ld a,0 
1f52 77				ld (hl), a 
1f53 23				inc hl 
1f54 18 e7			jr .ptoken2 
1f56				 
1f56			 
1f56			.ptokenstr2: 
1f56				; skip all white space until either eol (because forgot to term) or end double quote 
1f56			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f56				;inc hl ; skip current double quote 
1f56 7e				ld a,(hl) 
1f57 23				inc hl 
1f58 fe 22			cp '"' 
1f5a 28 e1			jr z, .ptoken2 
1f5c fe 7f			cp FORTH_END_BUFFER 
1f5e 28 0c			jr z, .ptokendone2 
1f60 fe 00			cp 0 
1f62 28 08			jr z, .ptokendone2 
1f64 fe 20			cp ' ' 
1f66 28 02			jr z, .ptmp2 
1f68 18 ec			jr .ptokenstr2 
1f6a			 
1f6a			.ptmp2:	; we have a space so change to zero term for dict match later 
1f6a				;dec hl 
1f6a				;ld a,"-"	; TODO remove this when working 
1f6a				;ld (hl), a 
1f6a				;inc hl 
1f6a 18 ea			jr .ptokenstr2 
1f6c			 
1f6c			.ptokendone2: 
1f6c				;inc hl 
1f6c 3e 7f			ld a, FORTH_END_BUFFER 
1f6e 77				ld (hl),a 
1f6f			;	inc hl 
1f6f			;	ld a, '!' 
1f6f			;	ld (hl),a 
1f6f			 
1f6f 2a b9 e5			ld hl,(os_tok_ptr) 
1f72			         
1f72			if DEBUG_FORTH_TOK 
1f72						DMARK "TK1" 
1f72				CALLMONITOR 
1f72			endif 
1f72			 
1f72				; push exec string to top of return stack 
1f72				FORTH_RSP_NEXT 
1f72 cd a7 1a			call macro_forth_rsp_next 
1f75				endm 
# End of macro FORTH_RSP_NEXT
1f75 c9				ret 
1f76			 
1f76			; 
1f76			;	; malloc size + buffer pointer + if is loop flag 
1f76			;	ld hl,(os_tok_len) 		 ; get string length 
1f76			; 
1f76			;	ld a,l 
1f76			; 
1f76			;	cp 0			; we dont want to use a null string 
1f76			;	ret z 
1f76			; 
1f76			;;	add 3    ; prefix malloc with buffer for current word ptr 
1f76			; 
1f76			;	add 5     ; TODO when certain not over writing memory remove 
1f76			; 
1f76			;		 
1f76			; 
1f76			;if DEBUG_FORTH_TOK 
1f76			;			DMARK "TKE" 
1f76			;	CALLMONITOR 
1f76			;endif 
1f76			; 
1f76			;	ld l,a 
1f76			;	ld h,0 
1f76			;;	push hl   ; save required space for the copy later 
1f76			;	call malloc 
1f76			;if DEBUG_FORTH_TOK 
1f76			;			DMARK "TKM" 
1f76			;	CALLMONITOR 
1f76			;endif 
1f76			;	if DEBUG_FORTH_MALLOC_GUARD 
1f76			;		push af 
1f76			;		call ishlzero 
1f76			;;		ld a, l 
1f76			;;		add h 
1f76			;;		cp 0 
1f76			;		pop af 
1f76			;		 
1f76			;		call z,malloc_error 
1f76			;	endif 
1f76			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1f76			; 
1f76			; 
1f76			;if DEBUG_FORTH_TOK 
1f76			;			DMARK "TKR" 
1f76			;	CALLMONITOR 
1f76			;endif 
1f76			; 
1f76			;	FORTH_RSP_NEXT 
1f76			; 
1f76			;	;inc hl	 ; go past current buffer pointer 
1f76			;	;inc hl 
1f76			;	;inc hl   ; and past if loop flag 
1f76			;		; TODO Need to set flag  
1f76			; 
1f76			;	 
1f76			;	 
1f76			;	ex de,hl	; malloc is dest 
1f76			;	ld hl, (os_tok_len) 
1f76			;;	pop bc 
1f76			;	ld c, l                
1f76			;	ld b,0 
1f76			;	ld hl, (os_tok_ptr) 
1f76			; 
1f76			;if DEBUG_FORTH_TOK 
1f76			;			DMARK "TKT" 
1f76			;	CALLMONITOR 
1f76			;endif 
1f76			; 
1f76			;	; do str cpy 
1f76			; 
1f76			;	ldir      ; copy byte in hl to de 
1f76			; 
1f76			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1f76			; 
1f76			;if DEBUG_FORTH_TOK 
1f76			; 
1f76			;			DMARK "TKY" 
1f76			;	CALLMONITOR 
1f76			;endif 
1f76			;	;ld a,0 
1f76			;	;ld a,FORTH_END_BUFFER 
1f76			;	ex de, hl 
1f76			;	;dec hl			 ; go back over the space delim at the end of word 
1f76			;	;ld (hl),a 
1f76			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1f76			;	ld a,FORTH_END_BUFFER 
1f76			;	ld (hl),a 
1f76			;	inc hl 
1f76			;	ld a,FORTH_END_BUFFER 
1f76			;	ld (hl),a 
1f76			; 
1f76			;	; init the malloc area data 
1f76			;	; set pc for in current area 
1f76			;	;ld hl, (os_tok_malloc) 
1f76			;	;inc hl 
1f76			;	;inc hl 
1f76			;	;inc hl 
1f76			;	;ex de,hl 
1f76			;	;ld hl, (os_tok_malloc) 
1f76			;	;ld (hl),e 
1f76			;	;inc hl 
1f76			;	;ld (hl),d 
1f76			; 
1f76			; 
1f76			;	ld hl,(os_tok_malloc) 
1f76			;if DEBUG_FORTH_PARSE_KEY 
1f76			;			DMARK "TKU" 
1f76			;	CALLMONITOR 
1f76			;endif 
1f76			; 
1f76			;	ret 
1f76			 
1f76			forthexec: 
1f76			 
1f76			; line exec: 
1f76			; forth parser 
1f76			 
1f76			; 
1f76			;       get current exec line on rsp 
1f76			 
1f76				FORTH_RSP_TOS 
1f76 cd be 1a			call macro_forth_rsp_tos 
1f79				endm 
# End of macro FORTH_RSP_TOS
1f79			 
1f79			;       restore current pc - hl points to malloc of data 
1f79			 
1f79				;ld e, (hl) 
1f79				;inc hl 
1f79				;ld d, (hl) 
1f79				;ex de,hl 
1f79			 
1f79			 
1f79			exec1: 
1f79 22 b9 e5			ld (os_tok_ptr), hl                 ; here move out of repeated saving in this tight loop 
1f7c			 
1f7c				; copy our PC to working vars  
1f7c 22 37 ea			ld (cli_ptr), hl                    ; here 
1f7f 22 35 ea			ld (cli_origptr), hl                ; here 
1f82			 
1f82 7e				ld a,(hl)                           ; here make hl be the ram ptr 
1f83 fe 7f			cp FORTH_END_BUFFER 
1f85 c8				ret z 
1f86			 
1f86				; skip any nulls 
1f86			 
1f86 fe 00			cp 0 
1f88 20 03			jr nz, .execword 
1f8a 23				inc hl 
1f8b 18 ec			jr exec1 
1f8d			 
1f8d			 
1f8d			.execword: 
1f8d			 
1f8d			 
1f8d			 
1f8d			if DEBUG_FORTH_PARSE_EXEC 
1f8d						DMARK "KYQ" 
1f8d				CALLMONITOR 
1f8d			endif 
1f8d			;       while at start of word: 
1f8d			; get start of dict (in user area first) 
1f8d			 
1f8d 21 53 65		ld hl, baseram 
1f90			;ld hl, sysdict 
1f90 22 39 ea		ld (cli_nextword),hl                            ; here do we need to do this? 
1f93			;           match word at pc 
1f93			;           exec word 
1f93			;           or push to dsp 
1f93			;           forward to next token 
1f93			;           if line term pop rsp and exit 
1f93			;        
1f93			 
1f93			if DEBUG_FORTH_PARSE_EXEC 
1f93						DMARK "KYq" 
1f93				CALLMONITOR 
1f93			endif 
1f93			 
1f93			; 
1f93			; word comp 
1f93			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1f93			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1f93			;    move to start of word  
1f93			;    compare word to cli_token 
1f93			 
1f93			.execpnword:	; HL at start of a word in the dictionary to check 
1f93			 
1f93 2a 39 ea			ld hl,(cli_nextword)                  ; here remove the need to store???? 
1f96			 
1f96 cd 2d 20			call forth_tok_next 
1f99			; tok next end here 
1f99 22 39 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
1f9c eb				ex de, hl 
1f9d			 
1f9d			 
1f9d				; save the pointer of the current token - 1 to check against 
1f9d				 
1f9d 22 3d ea			ld (cli_token), hl   
1fa0				; TODO maybe remove below save if no debug 
1fa0				; save token string ptr for any debug later 
1fa0 23				inc hl  
1fa1 22 3f ea			ld (cli_origtoken), hl 
1fa4 2b				dec hl 
1fa5				; save pointer to the start of the next dictionay word 
1fa5 7e				ld a,(hl)   ; get string length 
1fa6 47				ld b,a 
1fa7			.execpnwordinc:  
1fa7 23				inc hl 
1fa8 10 fd			djnz .execpnwordinc 
1faa 22 3b ea			ld (cli_execword), hl      ; save start of this words code 
1fad			 
1fad				; now check the word token against the string being parsed 
1fad			 
1fad 2a 3d ea			ld hl,(cli_token) 
1fb0 23				inc hl     ; skip string length (use zero term instead to end) 
1fb1				;ld (cli_token), hl 
1fb1			 
1fb1			.execpnchar:    ; compare char between token and string to parse 
1fb1			 
1fb1			 
1fb1				;ld hl, (cli_token)     ; the dict word  
1fb1 ed 5b 37 ea		ld de, (cli_ptr)     ; cli to parse 
1fb5			 
1fb5			 
1fb5			.execpncharl:    ; compare char between token and string to parse (loop) 
1fb5			 
1fb5 1a				ld a,(de) 
1fb6 cd 52 11			call toUpper 		; make sure the input string matches case 
1fb9 be				cp (hl) 
1fba			 
1fba c2 d3 1f			jp nz, .execpnskipword	 ; no match so move to next word 
1fbd				 
1fbd			;    if same 
1fbd			;       scan for string terms 0 for token and 32 for input 
1fbd 46				ld b,(hl) 
1fbe 80				add b			 
1fbf 23				inc hl 
1fc0 13				inc de 
1fc1 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1fc3							; TODO need to make sure last word in zero term string is accounted for 
1fc3 20 f0			jr nz, .execpncharl 		 ; not at end of strings yet 
1fc5			 
1fc5			 
1fc5				; at end of both strings so both are exact match 
1fc5			 
1fc5			;       skip ptr for next word 
1fc5			 
1fc5 2a 37 ea			ld hl,(cli_ptr) 	; at input string term 
1fc8 23				inc hl			 ; at next char 
1fc9 22 37 ea			ld (cli_ptr), hl     ; save for next round of the parser 
1fcc 22 35 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1fcf				 
1fcf				 
1fcf			 
1fcf			 
1fcf			 
1fcf			;       exec code block 
1fcf			if DEBUG_FORTH_JP 
1fcf				call clear_display 
1fcf				call update_display 
1fcf				call delay1s 
1fcf				ld hl, (cli_execword)     ; save for next check if no match on this word 
1fcf				ld a,h 
1fcf				ld hl, os_word_scratch 
1fcf				call hexout 
1fcf				ld hl, (cli_execword)     ; save for next check if no match on this word 
1fcf				ld a,l 
1fcf				ld hl, os_word_scratch+2 
1fcf				call hexout 
1fcf				ld hl, os_word_scratch+4 
1fcf				ld a,0 
1fcf				ld (hl),a 
1fcf				ld de,os_word_scratch 
1fcf				call str_at_display 
1fcf					ld a, display_row_2 
1fcf					call str_at_display 
1fcf				ld de, (cli_origtoken) 
1fcf				ld a, display_row_1+10 
1fcf					call str_at_display 
1fcf			 
1fcf				ld a,display_row_1 
1fcf				ld de, .foundword 
1fcf				ld a, display_row_3 
1fcf				call str_at_display 
1fcf				call update_display 
1fcf				call delay1s 
1fcf				call delay1s 
1fcf				call delay1s 
1fcf			endif 
1fcf			 
1fcf			if DEBUG_FORTH_PARSE_EXEC 
1fcf						DMARK "KYj" 
1fcf			endif 
1fcf				; TODO save the word pointer in this exec 
1fcf			 
1fcf 2a 3b ea			ld hl,(cli_execword) 
1fd2 e9				jp (hl) 
1fd3			 
1fd3			 
1fd3			;    if not same 
1fd3			;	scan for zero term 
1fd3			;	get ptr for next word 
1fd3			;	goto word comp 
1fd3			 
1fd3			.execpnskipword:	; get pointer to next word 
1fd3 2a 39 ea			ld hl,(cli_nextword) 
1fd6			 
1fd6 7e				ld a,(hl) 
1fd7 fe 00			cp WORD_SYS_END 
1fd9			;	cp 0 
1fd9 28 09			jr z, .execendofdict			 ; at end of words 
1fdb			 
1fdb			if DEBUG_FORTH_PARSE_EXEC 
1fdb						DMARK "KY4" 
1fdb			endif 
1fdb			if DEBUG_FORTH_PARSE_EXEC 
1fdb			 
1fdb				; see if disabled 
1fdb			 
1fdb			;	ld a, (os_view_disable) 
1fdb			;	cp '*' 
1fdb				ld a,(debug_vector) 
1fdb				cp $c9   ; RET 
1fdb				jr z, .noskip 
1fdb			 
1fdb			 
1fdb				ld de, .nowordfound 
1fdb				ld a, display_row_3 
1fdb				call str_at_display 
1fdb				call update_display 
1fdb				ld a, 100 
1fdb				call aDelayInMS 
1fdb				 
1fdb				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1fdb					call delay250ms 
1fdb				endif 
1fdb			.noskip:  
1fdb			 
1fdb			endif	 
1fdb			 
1fdb 2a 35 ea			ld hl,(cli_origptr) 
1fde 22 37 ea			ld (cli_ptr),hl 
1fe1			 
1fe1			if DEBUG_FORTH_PARSE_EXEC 
1fe1						DMARK "KY5" 
1fe1			endif 
1fe1 c3 93 1f			jp .execpnword			; else go to next word 
1fe4			 
1fe4			.execendofdict:  
1fe4			 
1fe4			if DEBUG_FORTH_PARSE_EXEC 
1fe4						DMARK "KYe" 
1fe4			endif 
1fe4			if DEBUG_FORTH_PARSE_EXEC 
1fe4				; see if disabled 
1fe4			 
1fe4			;	ld a, (os_view_disable) 
1fe4			;	cp '*' 
1fe4				ld a,(debug_vector) 
1fe4				cp $c9   ; ret 
1fe4				jr z, .ispskip 
1fe4			 
1fe4				call clear_display 
1fe4				call update_display 
1fe4				call delay1s 
1fe4				ld de, (cli_origptr) 
1fe4				ld a, display_row_1 
1fe4				call str_at_display 
1fe4				 
1fe4				ld de, .enddict 
1fe4				ld a, display_row_3 
1fe4				call str_at_display 
1fe4				call update_display 
1fe4				ld a, 100 
1fe4				call aDelayInMS 
1fe4				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1fe4				call delay1s 
1fe4				call delay1s 
1fe4				call delay1s 
1fe4				endif 
1fe4			.ispskip:  
1fe4				 
1fe4			endif	 
1fe4			 
1fe4			 
1fe4			 
1fe4				; if the word is not a keyword then must be a literal so push it to stack 
1fe4			 
1fe4			; push token to stack to end of word 
1fe4			 
1fe4				STACKFRAME ON $1efe $2f9f 
1fe4				if DEBUG_STACK_IMB 
1fe4					if ON 
1fe4						exx 
1fe4						ld de, $1efe 
1fe4						ld a, d 
1fe4						ld hl, curframe 
1fe4						call hexout 
1fe4						ld a, e 
1fe4						ld hl, curframe+2 
1fe4						call hexout 
1fe4						ld hl, $1efe 
1fe4						push hl 
1fe4						ld hl, $2f9f 
1fe4						push hl 
1fe4						exx 
1fe4					endif 
1fe4				endif 
1fe4			endm 
# End of macro STACKFRAME
1fe4			 
1fe4 2a b9 e5		ld hl,(os_tok_ptr) 
1fe7 cd 69 1c		call forth_apush 
1fea			 
1fea				STACKFRAMECHK ON $1efe $2f9f 
1fea				if DEBUG_STACK_IMB 
1fea					if ON 
1fea						exx 
1fea						ld hl, $2f9f 
1fea						pop de   ; $2f9f 
1fea						call cmp16 
1fea						jr nz, .spnosame 
1fea						ld hl, $1efe 
1fea						pop de   ; $1efe 
1fea						call cmp16 
1fea						jr z, .spfrsame 
1fea						.spnosame: call showsperror 
1fea						.spfrsame: nop 
1fea						exx 
1fea					endif 
1fea				endif 
1fea			endm 
# End of macro STACKFRAMECHK
1fea			 
1fea			execnext: 
1fea			 
1fea			if DEBUG_FORTH_PARSE_EXEC 
1fea						DMARK "KY>" 
1fea			endif 
1fea			; move past token to next word 
1fea			 
1fea 2a b9 e5		ld hl, (os_tok_ptr) 
1fed 3e 00		ld a, 0 
1fef 01 ff 00		ld bc, 255     ; input buffer size 
1ff2 ed b1		cpir 
1ff4			 
1ff4			if DEBUG_FORTH_PARSE_EXEC 
1ff4						DMARK "KY!" 
1ff4				CALLMONITOR 
1ff4			endif	 
1ff4			; TODO this might place hl on the null, so will need to forward on??? 
1ff4			;inc hl   ; see if this gets onto the next item 
1ff4			 
1ff4			 
1ff4			; TODO pass a pointer to the buffer to push 
1ff4			; TODO call function to push 
1ff4			 
1ff4			; look for end of input 
1ff4			 
1ff4			;inc hl 
1ff4			;ld a,(hl) 
1ff4			;cp FORTH_END_BUFFER 
1ff4			;ret z 
1ff4			 
1ff4			 
1ff4 c3 79 1f		jp exec1 
1ff7			 
1ff7			 
1ff7			 
1ff7			 
1ff7			 
1ff7			 
1ff7			 
1ff7			 
1ff7			 
1ff7			findnexttok: 
1ff7			 
1ff7				; hl is pointer to move 
1ff7				; de is the token to locate 
1ff7			 
1ff7					if DEBUG_FORTH 
1ff7						DMARK "NTK" 
1ff7						CALLMONITOR 
1ff7					endif 
1ff7 d5				push de 
1ff8			 
1ff8			.fnt1:	 
1ff8				; find first char of token to locate 
1ff8			 
1ff8 1a				ld a, (de) 
1ff9 4f				ld c,a 
1ffa 7e				ld a,(hl) 
1ffb cd 52 11			call toUpper 
1ffe					if DEBUG_FORTH 
1ffe						DMARK "NT1" 
1ffe						CALLMONITOR 
1ffe					endif 
1ffe b9				cp c 
1fff			 
1fff 28 03			jr z, .fnt2cmpmorefirst	 
2001			 
2001				; first char not found move to next char 
2001			 
2001 23				inc hl 
2002 18 f4			jr .fnt1 
2004			 
2004			.fnt2cmpmorefirst:	 
2004				; first char of token found.  
2004			 
2004 e5				push hl     ; save start of token just in case it is the right one 
2005 d9				exx 
2006 e1				pop hl        ; save it to hl' 
2007 d9				exx 
2008			 
2008			 
2008			.fnt2cmpmore:	 
2008				; compare the rest 
2008				 
2008 23				inc hl 
2009 13				inc de 
200a				 
200a 1a				ld a, (de) 
200b 4f				ld c,a 
200c 7e				ld a,(hl) 
200d cd 52 11			call toUpper 
2010			 
2010					if DEBUG_FORTH 
2010						DMARK "NT2" 
2010						CALLMONITOR 
2010					endif 
2010				; c has the token to find char 
2010				; a has the mem to scan char 
2010			 
2010 b9				cp c 
2011 28 04			jr z,.fntmatch1 
2013			 
2013				; they are not the same 
2013			 
2013					if DEBUG_FORTH 
2013						DMARK "NT3" 
2013						CALLMONITOR 
2013					endif 
2013 d1				pop de	; reset de token to look for 
2014 d5				push de 
2015 18 e1			jr .fnt1 
2017				 
2017			.fntmatch1: 
2017			 
2017				; is the same char a null which means we might have a full hit? 
2017					if DEBUG_FORTH 
2017						DMARK "NT4" 
2017						CALLMONITOR 
2017					endif 
2017			 
2017 fe 00			cp 0 
2019 28 0b			jr z, .fntmatchyes 
201b			 
201b				; are we at the end of the token to find? 
201b			 
201b					if DEBUG_FORTH 
201b						DMARK "NT5" 
201b						CALLMONITOR 
201b					endif 
201b 3e 00			ld a, 0 
201d b9				cp c 
201e			 
201e c2 08 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2021			 
2021					if DEBUG_FORTH 
2021						DMARK "NT6" 
2021						CALLMONITOR 
2021					endif 
2021				; token to find is exhusted but no match to stream 
2021			 
2021				; restore tok pointer and continue on 
2021 d1				pop de 
2022 d5				push de 
2023 c3 f8 1f			jp .fnt1 
2026			 
2026			 
2026			.fntmatchyes: 
2026			 
2026				; hl now contains the end of the found token 
2026			 
2026				; get rid of saved token pointer to find 
2026			 
2026 d1				pop de 
2027			 
2027					if DEBUG_FORTH 
2027						DMARK "NT9" 
2027						CALLMONITOR 
2027					endif 
2027			 
2027				; hl will be on the null term so forward on 
2027			 
2027				; get back the saved start of the token 
2027			 
2027 d9				exx 
2028 e5				push hl     ; save start of token just in case it is the right one 
2029 d9				exx 
202a e1				pop hl        ; save it to hl 
202b			 
202b c9				ret 
202c			 
202c			 
202c			; LIST needs to find a specific token   
202c			; FORGET needs to find a spefici token 
202c			 
202c			; SAVE needs to find all tokens by flag 
202c			; WORDS just needs to scan through all  by flag 
202c			; UWORDS needs to scan through all by flag 
202c			 
202c			 
202c			; given hl as pointer to start of dict look up string 
202c			; return hl as pointer to start of word block 
202c			; or 0 if not found 
202c			 
202c			forth_find_tok: 
202c c9				ret 
202d			 
202d			; given hl as pointer to dict structure 
202d			; move to the next dict block structure 
202d			 
202d			forth_tok_next: 
202d				; hl now points to the address of the next word pointer  
202d				; TODO skip compiled symbol for now 
202d			;	push de 
202d 23				inc hl 
202e 5e				ld e, (hl) 
202f 23				inc hl 
2030 56				ld d, (hl) 
2031 23				inc hl 
2032			 
2032 eb				ex de,hl 
2033			if DEBUG_FORTH_PARSE_NEXTWORD 
2033				push bc 
2033				ld bc, (cli_nextword) 
2033						DMARK "NXW" 
2033				CALLMONITOR 
2033				pop bc 
2033			endif 
2033			;	pop de	 
2033 c9				ret 
2034			 
2034			 
2034			 
2034			; eof 
# End of file forth_parserv6.asm
2034				include "forth_wordsv4.asm" 
2034			 
2034			; the core word dictionary v4 
2034			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2034			 
2034			; this is a linked list for each of the system words used 
2034			; user defined words will follow the same format but will be in ram 
2034			 
2034			 
2034			; 
2034			; 
2034			; define linked list: 
2034			; 
2034			; 1. compiled byte op code 
2034			; 2. len of text word 
2034			; 3. text word 
2034			; 4. ptr to next dictionary word 
2034			; 5. asm, calls etc for the word 
2034			; 
2034			;  if 1 == 0 then last word in dict  
2034			;   
2034			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2034			;  
2034			;  
2034			; create basic standard set of words 
2034			; 
2034			;  
2034			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2034			; 2DUP 2DROP 2SWAP  
2034			; @ C@ - get byte  
2034			; ! C! - store byte 
2034			; 0< true if less than zero 
2034			; 0= true if zero 
2034			; < >  
2034			; = true if same 
2034			; variables 
2034			 
2034			 
2034			; Hardware specific words I may need 
2034			; 
2034			; IN OUT  
2034			; calls to key util functions 
2034			; calls to hardward abstraction stuff 
2034			; easy control of frame buffers and lcd i/o 
2034			; keyboard  
2034			 
2034			 
2034			;DICT: macro 
2034			; op_code, len, word, next 
2034			;    word: 
2034			;    db op_code 
2034			;    ds word zero term 
2034			;    dw next 
2034			;    endm 
2034			 
2034			 
2034			 
2034			 
2034			; op code 1 is a flag for user define words which are to be handled differently 
2034			 
2034			 
2034			; 
2034			; 
2034			;    TODO on entry to a word this should be the expected environment 
2034			;    hl - tos value if number then held, if string this is the ptr 
2034			;    de -  
2034			 
2034			 
2034			; opcode ranges 
2034			; 0 - end of word dict 
2034			; 255 - user define words 
2034			 
2034			sysdict: 
2034			include "forth_opcodes.asm" 
2034			; op codes for forth keywords 
2034			 
2034			; Changing use of opcodes to flag is the word exists in compiled form or not.  
2034			; This provides a means to compile uwords if required for higher performance 
2034			; by avoiding the use of the keyword parser and just jumping directly to the code 
2034			; Actually there is already a flag for if the code exists as binary thinking about it... 
2034			 
2034			 
2034			 
2034			 
2034			 
2034			; free to use code 0  
2034				OPCODE_HEAP: equ  1 
2034				OPCODE_EXEC: equ 2 
2034				OPCODE_DUP: equ 3 
2034				OPCODE_SWAP: equ 4 
2034				OPCODE_COLN: equ 5 
2034				OPCODE_SCOLN: equ 6 
2034				OPCODE_DROP: equ 7 
2034				OPCODE_DUP2: equ 8 
2034				OPCODE_DROP2: equ 9 
2034				OPCODE_SWAP2: equ 10 
2034				OPCODE_AT: equ 11 
2034				OPCODE_CAT: equ 12 
2034				OPCODE_BANG: equ 13 
2034				OPCODE_CBANG: equ 14 
2034				OPCODE_SCALL: equ 15 
2034				OPCODE_DEPTH: equ 16 
2034				OPCODE_OVER: equ 17 
2034				OPCODE_PAUSE: equ 18 
2034				OPCODE_PAUSES: equ 19 
2034				OPCODE_ROT: equ 20 
2034			;free to reuse	OPCODE_WORDS: equ 21 
2034			        OPCODE_NOT: equ 21 
2034				OPCODE_UWORDS: equ 22 
2034				OPCODE_BP: equ 23 
2034				OPCODE_MONITOR: equ 24  
2034				OPCODE_MALLOC: equ 25 
2034				OPCODE_FREE: equ 26 
2034				OPCODE_LIST: equ 27 
2034				OPCODE_FORGET: equ 28 
2034				OPCODE_NOP: equ 29 
2034				OPCODE_COMO: equ 30 
2034				OPCODE_COMC: equ 31 
2034			;free to reuse	OPCODE_ENDCORE: equ 32 
2034				OPCODE_AFTERSOUND: equ 33 
2034				OPCODE_GP2: equ 34 
2034				OPCODE_GP3: equ 35 
2034				OPCODE_GP4: equ 36 
2034				OPCODE_SIN: equ 37 
2034				OPCODE_SOUT: equ 38 
2034				OPCODE_SPIO: equ 39 
2034				OPCODE_SPICEH: equ 40 
2034				OPCODE_SPIOb: equ 41 
2034				OPCODE_SPII: equ 42 
2034				OPCODE_SESEL: equ 43 
2034				OPCODE_CARTDEV: equ 44 
2034			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2034				OPCODE_FB: equ 46 
2034				OPCODE_EMIT: equ 47 
2034				OPCODE_DOTH: equ 48 
2034				OPCODE_DOTF: equ 49 
2034				OPCODE_DOT: equ 50 
2034				OPCODE_CLS: equ 51 
2034				OPCODE_DRAW: equ 52 
2034				OPCODE_DUMP: equ 53 
2034				OPCODE_CDUMP: equ 54 
2034				OPCODE_DAT: equ 55 
2034				OPCODE_HOME: equ 56 
2034				OPCODE_SPACE: equ 57 
2034				OPCODE_SPACES: equ 58 
2034				OPCODE_SCROLL: equ 59 
2034				OPCODE_ATQ: equ 60 
2034				OPCODE_AUTODSP: equ 61 
2034				OPCODE_MENU: equ 62 
2034			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2034				OPCODE_THEN: equ 64 
2034				OPCODE_ELSE: equ 65 
2034				OPCODE_DO: equ 66 
2034				OPCODE_LOOP: equ 67 
2034				OPCODE_I: equ 68 
2034				OPCODE_DLOOP: equ 69  
2034				OPCODE_REPEAT: equ 70  
2034				OPCODE_UNTIL: equ 71 
2034				OPCODE_ENDFLOW: equ 72 
2034				OPCODE_WAITK: equ 73 
2034				OPCODE_ACCEPT: equ 74 
2034				OPCODE_EDIT: equ 75 
2034			;free to reuse	OPCODE_ENDKEY: equ 76 
2034				OPCODE_LZERO: equ 77 
2034				OPCODE_TZERO: equ 78 
2034				OPCODE_LESS: equ 79 
2034				OPCODE_GT: equ 80 
2034				OPCODE_EQUAL: equ 81  
2034			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2034				OPCODE_NEG: equ 83 
2034				OPCODE_DIV: equ 84 
2034				OPCODE_MUL: equ 85 
2034				OPCODE_MIN: equ 86 
2034				OPCODE_MAX: equ 87 
2034				OPCODE_RND16: equ 88 
2034				OPCODE_RND8: equ 89 
2034				OPCODE_RND: equ 90 
2034			;free to reuse	OPCODE_ENDMATHS: equ 91  
2034				OPCODE_BYNAME: equ 92 
2034				OPCODE_DIR: equ 93 
2034				OPCODE_SAVE: equ 94 
2034				OPCODE_LOAD: equ 95 
2034				OPCODE_BSAVE: equ 96 
2034				OPCODE_BLOAD: equ 97 
2034				OPCODE_SEO: equ 98  
2034				OPCODE_SEI: equ 99 
2034				OPCODE_SFREE: equ 100 
2034				OPCODE_SIZE: equ 101 
2034				OPCODE_CREATE: equ 102 
2034				OPCODE_APPEND: equ 103 
2034				OPCODE_SDEL: equ 104 
2034				OPCODE_OPEN: equ 105 
2034				OPCODE_READ: equ 106 
2034				OPCODE_EOF: equ 106 
2034				OPCODE_FORMAT: equ 107 
2034				OPCODE_LABEL: equ 108 
2034				OPCODE_LABELS: equ 109 
2034			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2034				OPCODE_UPPER: equ 111 
2034				OPCODE_LOWER: equ 112 
2034				OPCODE_SUBSTR: equ 113 
2034				OPCODE_LEFT: equ 114 
2034				OPCODE_RIGHT: equ 115 
2034				OPCODE_STR2NUM: equ 116 
2034				OPCODE_NUM2STR: equ 117 
2034				OPCODE_CONCAT: equ 118 
2034				OPCODE_FIND: equ 119 
2034				OPCODE_LEN: equ 120 
2034				OPCODE_CHAR: equ 121 
2034			; free to reuse	OPCODE_STRLEN: equ 122 
2034			; free to reuse	OPCODE_ENDSTR: equ 123 
2034				OPCODE_V0S: equ 124 
2034				OPCODE_V0Q: equ 125 
2034				OPCODE_V1S: equ 126 
2034				OPCODE_V1Q: equ 127 
2034				OPCODE_V2S: equ 128 
2034				OPCODE_V2Q: equ 129 
2034				OPCODE_V3S: equ 130 
2034				OPCODE_V3Q: equ 131 
2034			;free to reuse	OPCODE_END: equ 132 
2034				OPCODE_ZDUP: equ 133 
2034			 
2034			; eof 
# End of file forth_opcodes.asm
2034			 
2034			include "forth_words_core.asm" 
2034			 
2034			; | ## Core Words 
2034			 
2034			;if MALLOC_4 
2034			 
2034			.HEAP: 
2034			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2034 15				db WORD_SYS_CORE+OPCODE_HEAP             
2035 76 20			dw .EXEC            
2037 05				db 4 + 1 
2038 .. 00			db "HEAP",0              
203d				endm 
# End of macro CWHEAD
203d			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
203d			; | | u1 - Current number of bytes in the heap 
203d			; | | u2 - Remaining bytes left on the heap 
203d			; | |  
203d			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
203d			 
203d			 
203d				if DEBUG_FORTH_WORDS_KEY 
203d					DMARK "HEP" 
203d f5				push af  
203e 3a 52 20			ld a, (.dmark)  
2041 32 62 ee			ld (debug_mark),a  
2044 3a 53 20			ld a, (.dmark+1)  
2047 32 63 ee			ld (debug_mark+1),a  
204a 3a 54 20			ld a, (.dmark+2)  
204d 32 64 ee			ld (debug_mark+2),a  
2050 18 03			jr .pastdmark  
2052 ..			.dmark: db "HEP"  
2055 f1			.pastdmark: pop af  
2056			endm  
# End of macro DMARK
2056					CALLMONITOR 
2056 cd 6f ee			call debug_vector  
2059				endm  
# End of macro CALLMONITOR
2059				endif 
2059 2a 5d 65			ld hl, (free_list )      
205c 11 62 65			ld de, heap_start 
205f			 
205f ed 52			sbc hl, de  
2061			 
2061 cd 00 1b			call forth_push_numhl 
2064			 
2064			 
2064 ed 5b 5d 65		ld de, (free_list )      
2068 21 93 e2			ld hl, heap_end 
206b			 
206b ed 52			sbc hl, de 
206d			 
206d cd 00 1b			call forth_push_numhl 
2070				 
2070			 
2070				 
2070			 
2070			 
2070			 
2070				NEXTW 
2070 cd 6c ee			call parse_vector 
2073 c3 f0 1e			jp macro_next 
2076				endm 
# End of macro NEXTW
2076			;endif 
2076			 
2076			.EXEC: 
2076			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2076			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2076			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2076			;; > > 
2076			;; > >   
2076			;	STACKFRAME OFF $5efe $5f9f 
2076			; 
2076			;		if DEBUG_FORTH_WORDS_KEY 
2076			;			DMARK "EXE" 
2076			;			CALLMONITOR 
2076			;		endif 
2076			; 
2076			;	FORTH_DSP_VALUEHL 
2076			; 
2076			;	FORTH_DSP_POP 
2076			; 
2076			;		if DEBUG_FORTH_WORDS 
2076			;			DMARK "EX1" 
2076			;			CALLMONITOR 
2076			;		endif 
2076			;;	ld e,(hl) 
2076			;;	inc hl 
2076			;;	ld d,(hl) 
2076			;;	ex de,hl 
2076			; 
2076			;;		if DEBUG_FORTH_WORDS 
2076			;;			DMARK "EX2" 
2076			;;			CALLMONITOR 
2076			;;		endif 
2076			;	push hl 
2076			; 
2076			;	;ld a, 0 
2076			;	;ld a, FORTH_END_BUFFER 
2076			;	call strlenz 
2076			;	inc hl   ; include zero term to copy 
2076			;	inc hl   ; include term 
2076			;	inc hl   ; include term 
2076			;	ld b,0 
2076			;	ld c,l 
2076			;	pop hl 
2076			;	ld de, execscratch 
2076			;		if DEBUG_FORTH_WORDS 
2076			;			DMARK "EX3" 
2076			;			CALLMONITOR 
2076			;		endif 
2076			;	ldir 
2076			; 
2076			; 
2076			;	ld hl, execscratch 
2076			; 
2076			;		if DEBUG_FORTH_WORDS 
2076			;			DMARK "EXe" 
2076			;			CALLMONITOR 
2076			;		endif 
2076			; 
2076			;	call forthparse 
2076			;	call forthexec 
2076			;;	call forthexec_cleanup 
2076			;;	call forthparse 
2076			;;	call forthexec 
2076			; 
2076			;	STACKFRAMECHK OFF $5efe $5f9f 
2076			; 
2076			;	; an immediate word so no need to process any more words 
2076			;	ret 
2076			;	NEXTW 
2076			 
2076			; dead code - old version  
2076			;	FORTH_RSP_NEXT 
2076			 
2076			;  
2076			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2076			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2076			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2076			;	push hl 
2076			;	push de 
2076			;	push bc 
2076			; 
2076			; 
2076			;		if DEBUG_FORTH_WORDS_KEY 
2076			;			DMARK "EXR" 
2076			;			CALLMONITOR 
2076			;		endif 
2076			; 
2076			; 
2076			; 
2076			;	;v5 FORTH_DSP_VALUE 
2076			;	FORTH_DSP_VALUEHL 
2076			; 
2076			;	; TODO do string type checks 
2076			; 
2076			;;v5	inc hl   ; skip type 
2076			; 
2076			;	push hl  ; source code  
2076			;		if DEBUG_FORTH_WORDS 
2076			;			DMARK "EX1" 
2076			;			CALLMONITOR 
2076			;		endif 
2076			;	ld a, 0 
2076			;	call strlent 
2076			; 
2076			;	inc hl 
2076			;	inc hl 
2076			;	inc hl 
2076			;	inc hl 
2076			; 
2076			;	push hl    ; size 
2076			; 
2076			;		if DEBUG_FORTH_WORDS 
2076			;			DMARK "EX2" 
2076			;			CALLMONITOR 
2076			;		endif 
2076			;	call malloc 
2076			; 
2076			;	ex de, hl    ; de now contains malloc area 
2076			;	pop bc   	; get byte count 
2076			;	pop hl      ; get string to copy 
2076			; 
2076			;	push de     ; save malloc for free later 
2076			; 
2076			;		if DEBUG_FORTH_WORDS 
2076			;			DMARK "EX3" 
2076			;			CALLMONITOR 
2076			;		endif 
2076			;	ldir       ; duplicate string 
2076			; 
2076			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2076			;	 
2076			;	; TODO fix the parse would be better than this...  
2076			;	ex de, hl 
2076			;	dec hl 
2076			;	ld a, 0 
2076			;	ld (hl), a 
2076			;	dec hl 
2076			;	ld a, ' ' 
2076			;	ld (hl), a 
2076			;	dec hl 
2076			;	ld (hl), a 
2076			; 
2076			;	dec hl 
2076			;	ld (hl), a 
2076			; 
2076			; 
2076			;	FORTH_DSP_POP  
2076			; 
2076			;	pop hl     
2076			;	push hl    ; save malloc area 
2076			; 
2076			;		if DEBUG_FORTH_WORDS 
2076			;			DMARK "EX4" 
2076			;			CALLMONITOR 
2076			;		endif 
2076			; 
2076			;	call forthparse 
2076			;	call forthexec 
2076			;	 
2076			;	pop hl 
2076			;	if DEBUG_FORTH_WORDS 
2076			;		DMARK "EX5" 
2076			;		CALLMONITOR 
2076			;	endif 
2076			; 
2076			;	if FORTH_ENABLE_FREE 
2076			;	call free 
2076			;	endif 
2076			; 
2076			;	if DEBUG_FORTH_WORDS 
2076			;		DMARK "EX6" 
2076			;		CALLMONITOR 
2076			;	endif 
2076			; 
2076			;	pop bc 
2076			;	pop de 
2076			;	pop hl 
2076			;;	FORTH_RSP_POP	  
2076			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2076			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2076			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2076			; 
2076			;	if DEBUG_FORTH_WORDS 
2076			;		DMARK "EX7" 
2076			;		CALLMONITOR 
2076			;	endif 
2076			;	NEXTW 
2076			 
2076			;.STKEXEC: 
2076			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2076			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2076			; 
2076			; 
2076			;		if DEBUG_FORTH_WORDS_KEY 
2076			;			DMARK "STX" 
2076			;			CALLMONITOR 
2076			;		endif 
2076			; 
2076			;	FORTH_DSP_VALUEHL 
2076			; 
2076			;	ld (store_tmp1), hl    ; count 
2076			; 
2076			;	FORTH_DSP_POP 
2076			;.stkexec1: 
2076			;	ld hl, (store_tmp1)   ; count 
2076			;	ld a, 0 
2076			;	cp l 
2076			;	ret z 
2076			; 
2076			;	dec hl 
2076			;	ld (store_tmp1), hl    ; count 
2076			;	 
2076			;	FORTH_DSP_VALUEHL 
2076			;	push hl 
2076			;	 
2076			;		if DEBUG_FORTH_WORDS 
2076			;			DMARK "EXp" 
2076			;			CALLMONITOR 
2076			;		endif 
2076			;	FORTH_DSP_POP 
2076			; 
2076			;	call strlenz 
2076			;	inc hl   ; include zero term to copy 
2076			;	inc hl   ; include zero term to copy 
2076			;	inc hl   ; include zero term to copy 
2076			;	ld b,0 
2076			;	ld c,l 
2076			;	pop hl 
2076			;	ld de, execscratch 
2076			;		if DEBUG_FORTH_WORDS 
2076			;			DMARK "EX3" 
2076			;			CALLMONITOR 
2076			;		endif 
2076			;	ldir 
2076			; 
2076			; 
2076			;	ld hl, execscratch 
2076			; 
2076			;		if DEBUG_FORTH_WORDS 
2076			;			DMARK "EXP" 
2076			;			CALLMONITOR 
2076			;		endif 
2076			; 
2076			;	call forthparse 
2076			;	ld hl, execscratch 
2076			;		if DEBUG_FORTH_WORDS 
2076			;			DMARK "EXx" 
2076			;			CALLMONITOR 
2076			;		endif 
2076			;	call forthexec 
2076			; 
2076			;	jp .stkexec1 
2076			; 
2076			;	ret 
2076			 
2076			 
2076			.DUP: 
2076			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2076 17				db WORD_SYS_CORE+OPCODE_DUP             
2077 f2 20			dw .ZDUP            
2079 04				db 3 + 1 
207a .. 00			db "DUP",0              
207e				endm 
# End of macro CWHEAD
207e			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
207e			 
207e				if DEBUG_FORTH_WORDS_KEY 
207e					DMARK "DUP" 
207e f5				push af  
207f 3a 93 20			ld a, (.dmark)  
2082 32 62 ee			ld (debug_mark),a  
2085 3a 94 20			ld a, (.dmark+1)  
2088 32 63 ee			ld (debug_mark+1),a  
208b 3a 95 20			ld a, (.dmark+2)  
208e 32 64 ee			ld (debug_mark+2),a  
2091 18 03			jr .pastdmark  
2093 ..			.dmark: db "DUP"  
2096 f1			.pastdmark: pop af  
2097			endm  
# End of macro DMARK
2097					CALLMONITOR 
2097 cd 6f ee			call debug_vector  
209a				endm  
# End of macro CALLMONITOR
209a				endif 
209a			 
209a				FORTH_DSP 
209a cd cb 1c			call macro_forth_dsp 
209d				endm 
# End of macro FORTH_DSP
209d			 
209d 7e				ld a, (HL) 
209e fe 01			cp DS_TYPE_STR 
20a0 20 28			jr nz, .dupinum 
20a2			 
20a2				; push another string 
20a2			 
20a2				FORTH_DSP_VALUEHL     		 
20a2 cd 05 1d			call macro_dsp_valuehl 
20a5				endm 
# End of macro FORTH_DSP_VALUEHL
20a5			 
20a5			if DEBUG_FORTH_WORDS 
20a5				DMARK "DUs" 
20a5 f5				push af  
20a6 3a ba 20			ld a, (.dmark)  
20a9 32 62 ee			ld (debug_mark),a  
20ac 3a bb 20			ld a, (.dmark+1)  
20af 32 63 ee			ld (debug_mark+1),a  
20b2 3a bc 20			ld a, (.dmark+2)  
20b5 32 64 ee			ld (debug_mark+2),a  
20b8 18 03			jr .pastdmark  
20ba ..			.dmark: db "DUs"  
20bd f1			.pastdmark: pop af  
20be			endm  
# End of macro DMARK
20be				CALLMONITOR 
20be cd 6f ee			call debug_vector  
20c1				endm  
# End of macro CALLMONITOR
20c1			endif 
20c1 cd 6e 1b			call forth_push_str 
20c4			 
20c4				NEXTW 
20c4 cd 6c ee			call parse_vector 
20c7 c3 f0 1e			jp macro_next 
20ca				endm 
# End of macro NEXTW
20ca			 
20ca			 
20ca			.dupinum: 
20ca				 
20ca			 
20ca			 
20ca				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
20ca cd 05 1d			call macro_dsp_valuehl 
20cd				endm 
# End of macro FORTH_DSP_VALUEHL
20cd			 
20cd			; TODO add floating point number detection 
20cd			 
20cd			if DEBUG_FORTH_WORDS 
20cd				DMARK "DUi" 
20cd f5				push af  
20ce 3a e2 20			ld a, (.dmark)  
20d1 32 62 ee			ld (debug_mark),a  
20d4 3a e3 20			ld a, (.dmark+1)  
20d7 32 63 ee			ld (debug_mark+1),a  
20da 3a e4 20			ld a, (.dmark+2)  
20dd 32 64 ee			ld (debug_mark+2),a  
20e0 18 03			jr .pastdmark  
20e2 ..			.dmark: db "DUi"  
20e5 f1			.pastdmark: pop af  
20e6			endm  
# End of macro DMARK
20e6				CALLMONITOR 
20e6 cd 6f ee			call debug_vector  
20e9				endm  
# End of macro CALLMONITOR
20e9			endif 
20e9			 
20e9 cd 00 1b			call forth_push_numhl 
20ec				NEXTW 
20ec cd 6c ee			call parse_vector 
20ef c3 f0 1e			jp macro_next 
20f2				endm 
# End of macro NEXTW
20f2			.ZDUP: 
20f2			CWHEAD .DMRK OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
20f2 99				db WORD_SYS_CORE+OPCODE_ZDUP             
20f3 2d 21			dw .DMRK            
20f5 05				db 4 + 1 
20f6 .. 00			db "?DUP",0              
20fb				endm 
# End of macro CWHEAD
20fb			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
20fb			 
20fb				if DEBUG_FORTH_WORDS_KEY 
20fb					DMARK "qDU" 
20fb f5				push af  
20fc 3a 10 21			ld a, (.dmark)  
20ff 32 62 ee			ld (debug_mark),a  
2102 3a 11 21			ld a, (.dmark+1)  
2105 32 63 ee			ld (debug_mark+1),a  
2108 3a 12 21			ld a, (.dmark+2)  
210b 32 64 ee			ld (debug_mark+2),a  
210e 18 03			jr .pastdmark  
2110 ..			.dmark: db "qDU"  
2113 f1			.pastdmark: pop af  
2114			endm  
# End of macro DMARK
2114					CALLMONITOR 
2114 cd 6f ee			call debug_vector  
2117				endm  
# End of macro CALLMONITOR
2117				endif 
2117				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2117 cd 05 1d			call macro_dsp_valuehl 
211a				endm 
# End of macro FORTH_DSP_VALUEHL
211a			 
211a e5				push hl 
211b			 
211b				; is it a zero? 
211b			 
211b 3e 00			ld a, 0 
211d 84				add h 
211e 85				add l 
211f			 
211f e1				pop hl 
2120			 
2120 fe 00			cp 0 
2122 28 03			jr z, .dup2orig 
2124			 
2124			 
2124 cd 00 1b			call forth_push_numhl 
2127			 
2127			 
2127			; TODO add floating point number detection 
2127			 
2127			.dup2orig: 
2127			 
2127				NEXTW 
2127 cd 6c ee			call parse_vector 
212a c3 f0 1e			jp macro_next 
212d				endm 
# End of macro NEXTW
212d			.DMRK: 
212d			CWHEAD .LSHIFT OPCODE_ZDUP "DMARK" 5 WORD_FLAG_CODE 
212d 99				db WORD_SYS_CORE+OPCODE_ZDUP             
212e 6d 21			dw .LSHIFT            
2130 06				db 5 + 1 
2131 .. 00			db "DMARK",0              
2137				endm 
# End of macro CWHEAD
2137			; | DMARK ( s --  )  Set the debug marker id to first three chars of s | DONE 
2137			; | | Most useful for tracing your code for errors as you can set various markers to display when MONITOR is called 
2137				if DEBUG_FORTH_WORDS_KEY 
2137					DMARK "DMK" 
2137 f5				push af  
2138 3a 4c 21			ld a, (.dmark)  
213b 32 62 ee			ld (debug_mark),a  
213e 3a 4d 21			ld a, (.dmark+1)  
2141 32 63 ee			ld (debug_mark+1),a  
2144 3a 4e 21			ld a, (.dmark+2)  
2147 32 64 ee			ld (debug_mark+2),a  
214a 18 03			jr .pastdmark  
214c ..			.dmark: db "DMK"  
214f f1			.pastdmark: pop af  
2150			endm  
# End of macro DMARK
2150					CALLMONITOR 
2150 cd 6f ee			call debug_vector  
2153				endm  
# End of macro CALLMONITOR
2153				endif 
2153				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2153 cd 05 1d			call macro_dsp_valuehl 
2156				endm 
# End of macro FORTH_DSP_VALUEHL
2156			 
2156 7e				ld a, (hl) 
2157 32 62 ee			ld (debug_mark),a 
215a 23				inc hl 
215b 7e				ld a, (hl) 
215c 32 63 ee			ld (debug_mark+1),a 
215f 23				inc hl 
2160 7e				ld a, (hl) 
2161 32 64 ee			ld (debug_mark+2),a 
2164			 
2164			 
2164				FORTH_DSP_POP 
2164 cd bd 1d			call macro_forth_dsp_pop 
2167				endm 
# End of macro FORTH_DSP_POP
2167				NEXTW 
2167 cd 6c ee			call parse_vector 
216a c3 f0 1e			jp macro_next 
216d				endm 
# End of macro NEXTW
216d			.LSHIFT: 
216d			CWHEAD .RSHIFT OPCODE_ZDUP "LSHIFT" 6 WORD_FLAG_CODE 
216d 99				db WORD_SYS_CORE+OPCODE_ZDUP             
216e a4 21			dw .RSHIFT            
2170 07				db 6 + 1 
2171 .. 00			db "LSHIFT",0              
2178				endm 
# End of macro CWHEAD
2178			; | LSHIFT ( w -- w )    16 bit left shift | DONE 
2178				if DEBUG_FORTH_WORDS_KEY 
2178					DMARK "LSH" 
2178 f5				push af  
2179 3a 8d 21			ld a, (.dmark)  
217c 32 62 ee			ld (debug_mark),a  
217f 3a 8e 21			ld a, (.dmark+1)  
2182 32 63 ee			ld (debug_mark+1),a  
2185 3a 8f 21			ld a, (.dmark+2)  
2188 32 64 ee			ld (debug_mark+2),a  
218b 18 03			jr .pastdmark  
218d ..			.dmark: db "LSH"  
2190 f1			.pastdmark: pop af  
2191			endm  
# End of macro DMARK
2191					CALLMONITOR 
2191 cd 6f ee			call debug_vector  
2194				endm  
# End of macro CALLMONITOR
2194				endif 
2194				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2194 cd 05 1d			call macro_dsp_valuehl 
2197				endm 
# End of macro FORTH_DSP_VALUEHL
2197				FORTH_DSP_POP 
2197 cd bd 1d			call macro_forth_dsp_pop 
219a				endm 
# End of macro FORTH_DSP_POP
219a			 
219a 29				add hl, hl 
219b cd 00 1b			call forth_push_numhl 
219e				NEXTW 
219e cd 6c ee			call parse_vector 
21a1 c3 f0 1e			jp macro_next 
21a4				endm 
# End of macro NEXTW
21a4			.RSHIFT: 
21a4			CWHEAD .SWAP OPCODE_ZDUP "RSHIFT" 6 WORD_FLAG_CODE 
21a4 99				db WORD_SYS_CORE+OPCODE_ZDUP             
21a5 de 21			dw .SWAP            
21a7 07				db 6 + 1 
21a8 .. 00			db "RSHIFT",0              
21af				endm 
# End of macro CWHEAD
21af			; | RSHIFT ( w -- w )    16 bit right shift | DONE 
21af				if DEBUG_FORTH_WORDS_KEY 
21af					DMARK "RSH" 
21af f5				push af  
21b0 3a c4 21			ld a, (.dmark)  
21b3 32 62 ee			ld (debug_mark),a  
21b6 3a c5 21			ld a, (.dmark+1)  
21b9 32 63 ee			ld (debug_mark+1),a  
21bc 3a c6 21			ld a, (.dmark+2)  
21bf 32 64 ee			ld (debug_mark+2),a  
21c2 18 03			jr .pastdmark  
21c4 ..			.dmark: db "RSH"  
21c7 f1			.pastdmark: pop af  
21c8			endm  
# End of macro DMARK
21c8					CALLMONITOR 
21c8 cd 6f ee			call debug_vector  
21cb				endm  
# End of macro CALLMONITOR
21cb				endif 
21cb				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21cb cd 05 1d			call macro_dsp_valuehl 
21ce				endm 
# End of macro FORTH_DSP_VALUEHL
21ce				FORTH_DSP_POP 
21ce cd bd 1d			call macro_forth_dsp_pop 
21d1				endm 
# End of macro FORTH_DSP_POP
21d1 cb 3c			srl h 
21d3 cb 1d			rr l 
21d5 cd 00 1b			call forth_push_numhl 
21d8				NEXTW 
21d8 cd 6c ee			call parse_vector 
21db c3 f0 1e			jp macro_next 
21de				endm 
# End of macro NEXTW
21de			.SWAP: 
21de			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
21de 18				db WORD_SYS_CORE+OPCODE_SWAP             
21df 35 22			dw .COLN            
21e1 05				db 4 + 1 
21e2 .. 00			db "SWAP",0              
21e7				endm 
# End of macro CWHEAD
21e7			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
21e7				if DEBUG_FORTH_WORDS_KEY 
21e7					DMARK "SWP" 
21e7 f5				push af  
21e8 3a fc 21			ld a, (.dmark)  
21eb 32 62 ee			ld (debug_mark),a  
21ee 3a fd 21			ld a, (.dmark+1)  
21f1 32 63 ee			ld (debug_mark+1),a  
21f4 3a fe 21			ld a, (.dmark+2)  
21f7 32 64 ee			ld (debug_mark+2),a  
21fa 18 03			jr .pastdmark  
21fc ..			.dmark: db "SWP"  
21ff f1			.pastdmark: pop af  
2200			endm  
# End of macro DMARK
2200					CALLMONITOR 
2200 cd 6f ee			call debug_vector  
2203				endm  
# End of macro CALLMONITOR
2203				endif 
2203			 
2203			; DONE Use os stack swap memory 
2203			 
2203				FORTH_DSP_PTR 0     ; TOS 
2203 2a e5 e9			ld hl,(cli_data_sp) 
2206 11 00 00			ld de, 0 * 3 
2209 ed 52			sbc hl, de 
220b				endm 
# End of macro FORTH_DSP_PTR
220b cd 3c 1e			call hltostack1 
220e			  
220e				FORTH_DSP_PTR 1     ; TOS 
220e 2a e5 e9			ld hl,(cli_data_sp) 
2211 11 03 00			ld de, 1 * 3 
2214 ed 52			sbc hl, de 
2216				endm 
# End of macro FORTH_DSP_PTR
2216 cd 42 1e			call hltostack2 
2219			 
2219				FORTH_DSP_PTR 0     ; TOS 
2219 2a e5 e9			ld hl,(cli_data_sp) 
221c 11 00 00			ld de, 0 * 3 
221f ed 52			sbc hl, de 
2221				endm 
# End of macro FORTH_DSP_PTR
2221 cd 5a 1e			call hlfromstack2 
2224			 
2224				FORTH_DSP_PTR 1     ; TOS 
2224 2a e5 e9			ld hl,(cli_data_sp) 
2227 11 03 00			ld de, 1 * 3 
222a ed 52			sbc hl, de 
222c				endm 
# End of macro FORTH_DSP_PTR
222c cd 54 1e			call hlfromstack1 
222f			;	FORTH_DSP_VALUEHL 
222f			;	push hl     ; w2 
222f			; 
222f			;	FORTH_DSP_POP 
222f			; 
222f			;	FORTH_DSP_VALUEHL 
222f			; 
222f			;	FORTH_DSP_POP 
222f			; 
222f			;	pop de     ; w2	, hl = w1 
222f			; 
222f			;	ex de, hl 
222f			;	push de 
222f			; 
222f			;	call forth_push_numhl 
222f			; 
222f			;	pop hl 
222f			; 
222f			;	call forth_push_numhl 
222f				 
222f			 
222f				NEXTW 
222f cd 6c ee			call parse_vector 
2232 c3 f0 1e			jp macro_next 
2235				endm 
# End of macro NEXTW
2235			.COLN: 
2235			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2235 19				db WORD_SYS_CORE+OPCODE_COLN             
2236 c1 23			dw .SCOLN            
2238 02				db 1 + 1 
2239 .. 00			db ":",0              
223b				endm 
# End of macro CWHEAD
223b			; | : ( -- )         Create new word | DONE 
223b			 
223b				if DEBUG_FORTH_WORDS_KEY 
223b					DMARK "CLN" 
223b f5				push af  
223c 3a 50 22			ld a, (.dmark)  
223f 32 62 ee			ld (debug_mark),a  
2242 3a 51 22			ld a, (.dmark+1)  
2245 32 63 ee			ld (debug_mark+1),a  
2248 3a 52 22			ld a, (.dmark+2)  
224b 32 64 ee			ld (debug_mark+2),a  
224e 18 03			jr .pastdmark  
2250 ..			.dmark: db "CLN"  
2253 f1			.pastdmark: pop af  
2254			endm  
# End of macro DMARK
2254					CALLMONITOR 
2254 cd 6f ee			call debug_vector  
2257				endm  
# End of macro CALLMONITOR
2257				endif 
2257			STACKFRAME OFF $8efe $989f 
2257				if DEBUG_STACK_IMB 
2257					if OFF 
2257						exx 
2257						ld de, $8efe 
2257						ld a, d 
2257						ld hl, curframe 
2257						call hexout 
2257						ld a, e 
2257						ld hl, curframe+2 
2257						call hexout 
2257						ld hl, $8efe 
2257						push hl 
2257						ld hl, $989f 
2257						push hl 
2257						exx 
2257					endif 
2257				endif 
2257			endm 
# End of macro STACKFRAME
2257			; get parser buffer length  of new word 
2257			 
2257			 
2257			 
2257				; move tok past this to start of name defintition 
2257				; TODO get word to define 
2257				; TODO Move past word token 
2257				; TODO get length of string up to the ';' 
2257			 
2257 2a b9 e5		ld hl, (os_tok_ptr) 
225a 23			inc hl 
225b 23			inc hl 
225c			 
225c 3e 3b		ld a, ';' 
225e cd 66 11		call strlent 
2261			 
2261 7d			ld a,l 
2262 32 a8 e2		ld (os_new_parse_len), a 
2265			 
2265			 
2265			if DEBUG_FORTH_UWORD 
2265 ed 5b b9 e5	ld de, (os_tok_ptr) 
2269					DMARK ":01" 
2269 f5				push af  
226a 3a 7e 22			ld a, (.dmark)  
226d 32 62 ee			ld (debug_mark),a  
2270 3a 7f 22			ld a, (.dmark+1)  
2273 32 63 ee			ld (debug_mark+1),a  
2276 3a 80 22			ld a, (.dmark+2)  
2279 32 64 ee			ld (debug_mark+2),a  
227c 18 03			jr .pastdmark  
227e ..			.dmark: db ":01"  
2281 f1			.pastdmark: pop af  
2282			endm  
# End of macro DMARK
2282			CALLMONITOR 
2282 cd 6f ee			call debug_vector  
2285				endm  
# End of macro CALLMONITOR
2285			endif 
2285			 
2285			; 
2285			;  new word memory layout: 
2285			;  
2285			;    : adg 6666 ;  
2285			; 
2285			;    db   1     ; user defined word  
2285 23			inc hl    
2286			;    dw   sysdict 
2286 23			inc hl 
2287 23			inc hl 
2288			;    db <word len>+1 (for null) 
2288 23			inc hl 
2289			;    db .... <word> 
2289			; 
2289			 
2289 23			inc hl    ; some extras for the word preamble before the above 
228a 23			inc hl 
228b 23			inc hl 
228c 23			inc hl 
228d 23			inc hl 
228e 23			inc hl 
228f 23			inc hl  
2290 23			inc hl 
2291 23			inc hl 
2292 23			inc hl 
2293 23			inc hl 
2294 23			inc hl 
2295 23			inc hl 
2296 23			inc hl     ; TODO how many do we really need?     maybe only 6 
2297			;       exec word buffer 
2297			;	<ptr word>   
2297 23			inc hl 
2298 23			inc hl 
2299			;       <word list><null term> 7F final term 
2299			 
2299			 
2299			if DEBUG_FORTH_UWORD 
2299					DMARK ":02" 
2299 f5				push af  
229a 3a ae 22			ld a, (.dmark)  
229d 32 62 ee			ld (debug_mark),a  
22a0 3a af 22			ld a, (.dmark+1)  
22a3 32 63 ee			ld (debug_mark+1),a  
22a6 3a b0 22			ld a, (.dmark+2)  
22a9 32 64 ee			ld (debug_mark+2),a  
22ac 18 03			jr .pastdmark  
22ae ..			.dmark: db ":02"  
22b1 f1			.pastdmark: pop af  
22b2			endm  
# End of macro DMARK
22b2			CALLMONITOR 
22b2 cd 6f ee			call debug_vector  
22b5				endm  
# End of macro CALLMONITOR
22b5			endif 
22b5			 
22b5			 
22b5				; malloc the size 
22b5			 
22b5 cd d0 11			call malloc 
22b8 22 aa e2			ld (os_new_malloc), hl     ; save malloc start 
22bb			 
22bb			;    db   1     ; user defined word  
22bb 3e 01			ld a, WORD_SYS_UWORD  
22bd 77				ld (hl), a 
22be			 
22be 23			inc hl    
22bf			;    dw   sysdict 
22bf 11 34 20		ld de, sysdict       ; continue on with the scan to the system dict 
22c2 73			ld (hl), e 
22c3 23			inc hl 
22c4 72			ld (hl), d 
22c5 23			inc hl 
22c6			 
22c6			 
22c6			;    Setup dict word 
22c6			 
22c6 23			inc hl 
22c7 22 a4 e2		ld (os_new_work_ptr), hl     ; save start of dict word  
22ca			 
22ca			; 1. get length of dict word 
22ca			 
22ca			 
22ca 2a b9 e5		ld hl, (os_tok_ptr) 
22cd 23			inc hl 
22ce 23			inc hl    ; position to start of dict word 
22cf 3e 00		ld a, 0 
22d1 cd 66 11		call strlent 
22d4			 
22d4			 
22d4 23			inc hl    ; to include null??? 
22d5			 
22d5			; write length of dict word 
22d5			 
22d5 ed 5b a4 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
22d9 1b			dec de 
22da eb			ex de, hl 
22db 73			ld (hl), e 
22dc eb			ex de, hl 
22dd			 
22dd			 
22dd			 
22dd			; copy  
22dd 4d			ld c, l 
22de 06 00		ld b, 0 
22e0 ed 5b a4 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
22e4 2a b9 e5		ld hl, (os_tok_ptr) 
22e7 23			inc hl 
22e8 23			inc hl    ; position to start of dict word 
22e9			 
22e9			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
22e9			 
22e9			; TODO need to convert word to upper case 
22e9			 
22e9			ucasetok:	 
22e9 7e			ld a,(hl) 
22ea cd 52 11		call toUpper 
22ed 77			ld (hl),a 
22ee ed a0		ldi 
22f0 f2 e9 22		jp p, ucasetok 
22f3			 
22f3			 
22f3			 
22f3			; de now points to start of where the word body code should be placed 
22f3 ed 53 a4 e2	ld (os_new_work_ptr), de 
22f7			; hl now points to the words to throw at forthexec which needs to be copied 
22f7 22 a2 e2		ld (os_new_src_ptr), hl 
22fa			 
22fa			; TODO add 'call to forthexec' 
22fa			 
22fa			if DEBUG_FORTH_UWORD 
22fa c5			push bc 
22fb ed 4b aa e2	ld bc, (os_new_malloc) 
22ff					DMARK ":0x" 
22ff f5				push af  
2300 3a 14 23			ld a, (.dmark)  
2303 32 62 ee			ld (debug_mark),a  
2306 3a 15 23			ld a, (.dmark+1)  
2309 32 63 ee			ld (debug_mark+1),a  
230c 3a 16 23			ld a, (.dmark+2)  
230f 32 64 ee			ld (debug_mark+2),a  
2312 18 03			jr .pastdmark  
2314 ..			.dmark: db ":0x"  
2317 f1			.pastdmark: pop af  
2318			endm  
# End of macro DMARK
2318			CALLMONITOR 
2318 cd 6f ee			call debug_vector  
231b				endm  
# End of macro CALLMONITOR
231b c1			pop bc 
231c			endif 
231c			 
231c			 
231c			; create word preamble which should be: 
231c			 
231c			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
231c			 
231c			;    ld hl, <word code> 
231c			;    jp user_exec 
231c			;    <word code bytes> 
231c			 
231c			 
231c			;	inc de     ; TODO ??? or are we already past the word's null 
231c eb			ex de, hl 
231d			 
231d 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
231f			 
231f 23			inc hl 
2320 22 9e e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2323 23			inc hl 
2324			 
2324 23			inc hl 
2325 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2327			 
2327 01 d7 52		ld bc, user_exec 
232a 23			inc hl 
232b 71			ld (hl), c     ; poke address of user_exec 
232c 23			inc hl 
232d 70			ld (hl), b     
232e			; 
232e			;	inc hl 
232e			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
232e			; 
232e			; 
232e			;	ld bc, macro_forth_rsp_next 
232e			;	inc hl 
232e			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
232e			;	inc hl 
232e			;	ld (hl), b     
232e			; 
232e			;	inc hl 
232e			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
232e			; 
232e			; 
232e			;	inc hl 
232e			;	ld bc, forthexec 
232e			;	ld (hl), c     ; poke address of forthexec 
232e			;	inc hl 
232e			;	ld (hl), b      
232e			; 
232e			;	inc hl 
232e			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
232e			; 
232e			;	ld bc, user_dict_next 
232e			;	inc hl 
232e			;	ld (hl), c     ; poke address of forthexec 
232e			;	inc hl 
232e			;	ld (hl), b      
232e			 
232e			; hl is now where we need to copy the word byte data to save this 
232e			 
232e 23			inc hl 
232f 22 a0 e2		ld (os_new_exec), hl 
2332			 
2332			; copy definition 
2332			 
2332 eb			ex de, hl 
2333			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2333			;	inc de    ; skip the PC for this parse 
2333 3a a8 e2		ld a, (os_new_parse_len) 
2336 4f			ld c, a 
2337 06 00		ld b, 0 
2339 ed b0		ldir		 ; copy defintion 
233b			 
233b			 
233b			; poke the address of where the new word bytes live for forthexec 
233b			 
233b 2a 9e e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
233e			 
233e ed 5b a0 e2	ld de, (os_new_exec)      
2342			 
2342 73			ld (hl), e 
2343 23			inc hl 
2344 72			ld (hl), d 
2345			 
2345				; TODO copy last user dict word next link to this word 
2345				; TODO update last user dict word to point to this word 
2345			; 
2345			; hl f923 de 812a ; bc 811a 
2345			 
2345			if DEBUG_FORTH_UWORD 
2345 c5			push bc 
2346 ed 4b aa e2	ld bc, (os_new_malloc) 
234a					DMARK ":0A" 
234a f5				push af  
234b 3a 5f 23			ld a, (.dmark)  
234e 32 62 ee			ld (debug_mark),a  
2351 3a 60 23			ld a, (.dmark+1)  
2354 32 63 ee			ld (debug_mark+1),a  
2357 3a 61 23			ld a, (.dmark+2)  
235a 32 64 ee			ld (debug_mark+2),a  
235d 18 03			jr .pastdmark  
235f ..			.dmark: db ":0A"  
2362 f1			.pastdmark: pop af  
2363			endm  
# End of macro DMARK
2363			CALLMONITOR 
2363 cd 6f ee			call debug_vector  
2366				endm  
# End of macro CALLMONITOR
2366 c1			pop bc 
2367			endif 
2367			if DEBUG_FORTH_UWORD 
2367 c5			push bc 
2368 ed 4b aa e2	ld bc, (os_new_malloc) 
236c 03			inc bc 
236d 03			inc bc 
236e 03			inc bc 
236f 03			inc bc 
2370 03			inc bc 
2371 03			inc bc 
2372 03			inc bc 
2373 03			inc bc 
2374			 
2374					DMARK ":0B" 
2374 f5				push af  
2375 3a 89 23			ld a, (.dmark)  
2378 32 62 ee			ld (debug_mark),a  
237b 3a 8a 23			ld a, (.dmark+1)  
237e 32 63 ee			ld (debug_mark+1),a  
2381 3a 8b 23			ld a, (.dmark+2)  
2384 32 64 ee			ld (debug_mark+2),a  
2387 18 03			jr .pastdmark  
2389 ..			.dmark: db ":0B"  
238c f1			.pastdmark: pop af  
238d			endm  
# End of macro DMARK
238d			CALLMONITOR 
238d cd 6f ee			call debug_vector  
2390				endm  
# End of macro CALLMONITOR
2390 c1			pop bc 
2391			endif 
2391			 
2391			; update word dict linked list for new word 
2391			 
2391			 
2391 2a b5 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2394 23			inc hl     ; move to next work linked list ptr 
2395			 
2395 ed 5b aa e2	ld de, (os_new_malloc)		 ; new next word 
2399 73			ld (hl), e 
239a 23			inc hl 
239b 72			ld (hl), d 
239c			 
239c			if DEBUG_FORTH_UWORD 
239c ed 4b b5 e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
23a0			endif 
23a0			 
23a0 ed 53 b5 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
23a4			 
23a4			 
23a4			if DEBUG_FORTH_UWORD 
23a4					DMARK ":0+" 
23a4 f5				push af  
23a5 3a b9 23			ld a, (.dmark)  
23a8 32 62 ee			ld (debug_mark),a  
23ab 3a ba 23			ld a, (.dmark+1)  
23ae 32 63 ee			ld (debug_mark+1),a  
23b1 3a bb 23			ld a, (.dmark+2)  
23b4 32 64 ee			ld (debug_mark+2),a  
23b7 18 03			jr .pastdmark  
23b9 ..			.dmark: db ":0+"  
23bc f1			.pastdmark: pop af  
23bd			endm  
# End of macro DMARK
23bd			CALLMONITOR 
23bd cd 6f ee			call debug_vector  
23c0				endm  
# End of macro CALLMONITOR
23c0			endif 
23c0			 
23c0			STACKFRAMECHK OFF $8efe $989f 
23c0				if DEBUG_STACK_IMB 
23c0					if OFF 
23c0						exx 
23c0						ld hl, $989f 
23c0						pop de   ; $989f 
23c0						call cmp16 
23c0						jr nz, .spnosame 
23c0						ld hl, $8efe 
23c0						pop de   ; $8efe 
23c0						call cmp16 
23c0						jr z, .spfrsame 
23c0						.spnosame: call showsperror 
23c0						.spfrsame: nop 
23c0						exx 
23c0					endif 
23c0				endif 
23c0			endm 
# End of macro STACKFRAMECHK
23c0			 
23c0 c9			ret    ; dont process any remaining parser tokens as they form new word 
23c1			 
23c1			 
23c1			 
23c1			 
23c1			;		NEXT 
23c1			.SCOLN: 
23c1			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
23c1 06			db OPCODE_SCOLN 
23c2 10 24		dw .DROP 
23c4 02			db 2 
23c5 .. 00		db ";",0           
23c7			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
23c7				if DEBUG_FORTH_WORDS_KEY 
23c7					DMARK "SCN" 
23c7 f5				push af  
23c8 3a dc 23			ld a, (.dmark)  
23cb 32 62 ee			ld (debug_mark),a  
23ce 3a dd 23			ld a, (.dmark+1)  
23d1 32 63 ee			ld (debug_mark+1),a  
23d4 3a de 23			ld a, (.dmark+2)  
23d7 32 64 ee			ld (debug_mark+2),a  
23da 18 03			jr .pastdmark  
23dc ..			.dmark: db "SCN"  
23df f1			.pastdmark: pop af  
23e0			endm  
# End of macro DMARK
23e0					CALLMONITOR 
23e0 cd 6f ee			call debug_vector  
23e3				endm  
# End of macro CALLMONITOR
23e3				endif 
23e3				FORTH_RSP_TOS 
23e3 cd be 1a			call macro_forth_rsp_tos 
23e6				endm 
# End of macro FORTH_RSP_TOS
23e6 e5				push hl 
23e7				FORTH_RSP_POP 
23e7 cd c8 1a			call macro_forth_rsp_pop 
23ea				endm 
# End of macro FORTH_RSP_POP
23ea e1				pop hl 
23eb			;		ex de,hl 
23eb 22 b9 e5			ld (os_tok_ptr),hl 
23ee			 
23ee			if DEBUG_FORTH_UWORD 
23ee					DMARK "SCL" 
23ee f5				push af  
23ef 3a 03 24			ld a, (.dmark)  
23f2 32 62 ee			ld (debug_mark),a  
23f5 3a 04 24			ld a, (.dmark+1)  
23f8 32 63 ee			ld (debug_mark+1),a  
23fb 3a 05 24			ld a, (.dmark+2)  
23fe 32 64 ee			ld (debug_mark+2),a  
2401 18 03			jr .pastdmark  
2403 ..			.dmark: db "SCL"  
2406 f1			.pastdmark: pop af  
2407			endm  
# End of macro DMARK
2407			CALLMONITOR 
2407 cd 6f ee			call debug_vector  
240a				endm  
# End of macro CALLMONITOR
240a			endif 
240a				NEXTW 
240a cd 6c ee			call parse_vector 
240d c3 f0 1e			jp macro_next 
2410				endm 
# End of macro NEXTW
2410			 
2410			.DROP: 
2410			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2410 1b				db WORD_SYS_CORE+OPCODE_DROP             
2411 3e 24			dw .DUP2            
2413 05				db 4 + 1 
2414 .. 00			db "DROP",0              
2419				endm 
# End of macro CWHEAD
2419			; | DROP ( w -- )   drop the TOS item   | DONE 
2419				if DEBUG_FORTH_WORDS_KEY 
2419					DMARK "DRP" 
2419 f5				push af  
241a 3a 2e 24			ld a, (.dmark)  
241d 32 62 ee			ld (debug_mark),a  
2420 3a 2f 24			ld a, (.dmark+1)  
2423 32 63 ee			ld (debug_mark+1),a  
2426 3a 30 24			ld a, (.dmark+2)  
2429 32 64 ee			ld (debug_mark+2),a  
242c 18 03			jr .pastdmark  
242e ..			.dmark: db "DRP"  
2431 f1			.pastdmark: pop af  
2432			endm  
# End of macro DMARK
2432					CALLMONITOR 
2432 cd 6f ee			call debug_vector  
2435				endm  
# End of macro CALLMONITOR
2435				endif 
2435				FORTH_DSP_POP 
2435 cd bd 1d			call macro_forth_dsp_pop 
2438				endm 
# End of macro FORTH_DSP_POP
2438				NEXTW 
2438 cd 6c ee			call parse_vector 
243b c3 f0 1e			jp macro_next 
243e				endm 
# End of macro NEXTW
243e			.DUP2: 
243e			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
243e 1c				db WORD_SYS_CORE+OPCODE_DUP2             
243f 86 24			dw .DROP2            
2441 05				db 4 + 1 
2442 .. 00			db "2DUP",0              
2447				endm 
# End of macro CWHEAD
2447			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
2447				if DEBUG_FORTH_WORDS_KEY 
2447					DMARK "2DU" 
2447 f5				push af  
2448 3a 5c 24			ld a, (.dmark)  
244b 32 62 ee			ld (debug_mark),a  
244e 3a 5d 24			ld a, (.dmark+1)  
2451 32 63 ee			ld (debug_mark+1),a  
2454 3a 5e 24			ld a, (.dmark+2)  
2457 32 64 ee			ld (debug_mark+2),a  
245a 18 03			jr .pastdmark  
245c ..			.dmark: db "2DU"  
245f f1			.pastdmark: pop af  
2460			endm  
# End of macro DMARK
2460					CALLMONITOR 
2460 cd 6f ee			call debug_vector  
2463				endm  
# End of macro CALLMONITOR
2463				endif 
2463				FORTH_DSP_VALUEHL 
2463 cd 05 1d			call macro_dsp_valuehl 
2466				endm 
# End of macro FORTH_DSP_VALUEHL
2466 e5				push hl      ; 2 
2467			 
2467				FORTH_DSP_POP 
2467 cd bd 1d			call macro_forth_dsp_pop 
246a				endm 
# End of macro FORTH_DSP_POP
246a				 
246a				FORTH_DSP_VALUEHL 
246a cd 05 1d			call macro_dsp_valuehl 
246d				endm 
# End of macro FORTH_DSP_VALUEHL
246d			;		push hl      ; 1 
246d			 
246d				FORTH_DSP_POP 
246d cd bd 1d			call macro_forth_dsp_pop 
2470				endm 
# End of macro FORTH_DSP_POP
2470			 
2470			;		pop hl       ; 1 
2470 d1				pop de       ; 2 
2471			 
2471 cd 00 1b			call forth_push_numhl 
2474 eb				ex de, hl 
2475 cd 00 1b			call forth_push_numhl 
2478			 
2478				 
2478 eb				ex de, hl 
2479			 
2479 cd 00 1b			call forth_push_numhl 
247c eb				ex de, hl 
247d cd 00 1b			call forth_push_numhl 
2480			 
2480			 
2480				NEXTW 
2480 cd 6c ee			call parse_vector 
2483 c3 f0 1e			jp macro_next 
2486				endm 
# End of macro NEXTW
2486			.DROP2: 
2486			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2486 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2487 b8 24			dw .PICK            
2489 06				db 5 + 1 
248a .. 00			db "2DROP",0              
2490				endm 
# End of macro CWHEAD
2490			; | 2DROP ( w w -- )    Double drop | DONE 
2490				if DEBUG_FORTH_WORDS_KEY 
2490					DMARK "2DR" 
2490 f5				push af  
2491 3a a5 24			ld a, (.dmark)  
2494 32 62 ee			ld (debug_mark),a  
2497 3a a6 24			ld a, (.dmark+1)  
249a 32 63 ee			ld (debug_mark+1),a  
249d 3a a7 24			ld a, (.dmark+2)  
24a0 32 64 ee			ld (debug_mark+2),a  
24a3 18 03			jr .pastdmark  
24a5 ..			.dmark: db "2DR"  
24a8 f1			.pastdmark: pop af  
24a9			endm  
# End of macro DMARK
24a9					CALLMONITOR 
24a9 cd 6f ee			call debug_vector  
24ac				endm  
# End of macro CALLMONITOR
24ac				endif 
24ac				FORTH_DSP_POP 
24ac cd bd 1d			call macro_forth_dsp_pop 
24af				endm 
# End of macro FORTH_DSP_POP
24af				FORTH_DSP_POP 
24af cd bd 1d			call macro_forth_dsp_pop 
24b2				endm 
# End of macro FORTH_DSP_POP
24b2				NEXTW 
24b2 cd 6c ee			call parse_vector 
24b5 c3 f0 1e			jp macro_next 
24b8				endm 
# End of macro NEXTW
24b8			.PICK: 
24b8			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
24b8 77				db WORD_SYS_CORE+99             
24b9 55 25			dw .SWAP2            
24bb 05				db 4 + 1 
24bc .. 00			db "PICK",0              
24c1				endm 
# End of macro CWHEAD
24c1			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | DONE 
24c1			; | | >[!NOTE] 
24c1			; | | > If the chosen item is a string the pointer is pushed to TOS. The string is not safely duplicated. 
24c1				if DEBUG_FORTH_WORDS_KEY 
24c1					DMARK "PIK" 
24c1 f5				push af  
24c2 3a d6 24			ld a, (.dmark)  
24c5 32 62 ee			ld (debug_mark),a  
24c8 3a d7 24			ld a, (.dmark+1)  
24cb 32 63 ee			ld (debug_mark+1),a  
24ce 3a d8 24			ld a, (.dmark+2)  
24d1 32 64 ee			ld (debug_mark+2),a  
24d4 18 03			jr .pastdmark  
24d6 ..			.dmark: db "PIK"  
24d9 f1			.pastdmark: pop af  
24da			endm  
# End of macro DMARK
24da					CALLMONITOR 
24da cd 6f ee			call debug_vector  
24dd				endm  
# End of macro CALLMONITOR
24dd				endif 
24dd			 
24dd				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24dd cd 05 1d			call macro_dsp_valuehl 
24e0				endm 
# End of macro FORTH_DSP_VALUEHL
24e0				 
24e0				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24e0 cd bd 1d			call macro_forth_dsp_pop 
24e3				endm 
# End of macro FORTH_DSP_POP
24e3			 
24e3				; init from TOS 
24e3 e5				push hl 
24e4				FORTH_DSP 
24e4 cd cb 1c			call macro_forth_dsp 
24e7				endm 
# End of macro FORTH_DSP
24e7			;	ld hl, cli_data_sp 
24e7				if DEBUG_FORTH_WORDS 
24e7					DMARK "PK1" 
24e7 f5				push af  
24e8 3a fc 24			ld a, (.dmark)  
24eb 32 62 ee			ld (debug_mark),a  
24ee 3a fd 24			ld a, (.dmark+1)  
24f1 32 63 ee			ld (debug_mark+1),a  
24f4 3a fe 24			ld a, (.dmark+2)  
24f7 32 64 ee			ld (debug_mark+2),a  
24fa 18 03			jr .pastdmark  
24fc ..			.dmark: db "PK1"  
24ff f1			.pastdmark: pop af  
2500			endm  
# End of macro DMARK
2500					CALLMONITOR 
2500 cd 6f ee			call debug_vector  
2503				endm  
# End of macro CALLMONITOR
2503				endif 
2503 c1				pop bc 
2504 41				ld b,c 
2505 3e 00			ld a, 0 
2507 b8				cp b 
2508 28 21			jr z, .pdone	 
250a			.pkl: 
250a 2b				dec hl 
250b 2b				dec hl 
250c 2b				dec hl 
250d			 
250d				if DEBUG_FORTH_WORDS 
250d					DMARK "PKl" 
250d f5				push af  
250e 3a 22 25			ld a, (.dmark)  
2511 32 62 ee			ld (debug_mark),a  
2514 3a 23 25			ld a, (.dmark+1)  
2517 32 63 ee			ld (debug_mark+1),a  
251a 3a 24 25			ld a, (.dmark+2)  
251d 32 64 ee			ld (debug_mark+2),a  
2520 18 03			jr .pastdmark  
2522 ..			.dmark: db "PKl"  
2525 f1			.pastdmark: pop af  
2526			endm  
# End of macro DMARK
2526					CALLMONITOR 
2526 cd 6f ee			call debug_vector  
2529				endm  
# End of macro CALLMONITOR
2529				endif 
2529 10 df			djnz .pkl 
252b			.pdone: 
252b				 
252b				; TODO do type check with correct push 
252b			 
252b 23				inc hl 
252c				;call loadwordinhl 
252c 5e				ld e, (hl) 
252d 23				inc hl 
252e 56				ld d, (hl) 
252f eb				ex de,hl 
2530				if DEBUG_FORTH_WORDS 
2530					DMARK "PKp" 
2530 f5				push af  
2531 3a 45 25			ld a, (.dmark)  
2534 32 62 ee			ld (debug_mark),a  
2537 3a 46 25			ld a, (.dmark+1)  
253a 32 63 ee			ld (debug_mark+1),a  
253d 3a 47 25			ld a, (.dmark+2)  
2540 32 64 ee			ld (debug_mark+2),a  
2543 18 03			jr .pastdmark  
2545 ..			.dmark: db "PKp"  
2548 f1			.pastdmark: pop af  
2549			endm  
# End of macro DMARK
2549					CALLMONITOR 
2549 cd 6f ee			call debug_vector  
254c				endm  
# End of macro CALLMONITOR
254c				endif 
254c cd 00 1b			call forth_push_numhl 
254f			 
254f				NEXTW 
254f cd 6c ee			call parse_vector 
2552 c3 f0 1e			jp macro_next 
2555				endm 
# End of macro NEXTW
2555			.SWAP2: 
2555			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2555 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2556 d9 25			dw .AT            
2558 06				db 5 + 1 
2559 .. 00			db "2SWAP",0              
255f				endm 
# End of macro CWHEAD
255f			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
255f				if DEBUG_FORTH_WORDS_KEY 
255f					DMARK "2SW" 
255f f5				push af  
2560 3a 74 25			ld a, (.dmark)  
2563 32 62 ee			ld (debug_mark),a  
2566 3a 75 25			ld a, (.dmark+1)  
2569 32 63 ee			ld (debug_mark+1),a  
256c 3a 76 25			ld a, (.dmark+2)  
256f 32 64 ee			ld (debug_mark+2),a  
2572 18 03			jr .pastdmark  
2574 ..			.dmark: db "2SW"  
2577 f1			.pastdmark: pop af  
2578			endm  
# End of macro DMARK
2578					CALLMONITOR 
2578 cd 6f ee			call debug_vector  
257b				endm  
# End of macro CALLMONITOR
257b				endif 
257b			; TODO Use os stack swap memory 
257b			 
257b				FORTH_DSP_PTR 0     ; TOS    w4 
257b 2a e5 e9			ld hl,(cli_data_sp) 
257e 11 00 00			ld de, 0 * 3 
2581 ed 52			sbc hl, de 
2583				endm 
# End of macro FORTH_DSP_PTR
2583 cd 3c 1e			call hltostack1 
2586			  
2586				FORTH_DSP_PTR 1     ; TOS    w3 
2586 2a e5 e9			ld hl,(cli_data_sp) 
2589 11 03 00			ld de, 1 * 3 
258c ed 52			sbc hl, de 
258e				endm 
# End of macro FORTH_DSP_PTR
258e cd 42 1e			call hltostack2 
2591			 
2591			 
2591			 
2591				FORTH_DSP_PTR 2     ; TOS    w2 
2591 2a e5 e9			ld hl,(cli_data_sp) 
2594 11 06 00			ld de, 2 * 3 
2597 ed 52			sbc hl, de 
2599				endm 
# End of macro FORTH_DSP_PTR
2599 cd 48 1e			call hltostack3 
259c			 
259c				FORTH_DSP_PTR 3     ; TOS   w1 
259c 2a e5 e9			ld hl,(cli_data_sp) 
259f 11 09 00			ld de, 3 * 3 
25a2 ed 52			sbc hl, de 
25a4				endm 
# End of macro FORTH_DSP_PTR
25a4 cd 4e 1e			call hltostack4 
25a7			 
25a7			 
25a7			 
25a7			 
25a7				FORTH_DSP_PTR 0     ; TOS 
25a7 2a e5 e9			ld hl,(cli_data_sp) 
25aa 11 00 00			ld de, 0 * 3 
25ad ed 52			sbc hl, de 
25af				endm 
# End of macro FORTH_DSP_PTR
25af cd 60 1e			call hlfromstack3 
25b2			 
25b2				FORTH_DSP_PTR 1     ; TOS 
25b2 2a e5 e9			ld hl,(cli_data_sp) 
25b5 11 03 00			ld de, 1 * 3 
25b8 ed 52			sbc hl, de 
25ba				endm 
# End of macro FORTH_DSP_PTR
25ba cd 66 1e			call hlfromstack4 
25bd			 
25bd			 
25bd			 
25bd				FORTH_DSP_PTR 2     ; TOS 
25bd 2a e5 e9			ld hl,(cli_data_sp) 
25c0 11 06 00			ld de, 2 * 3 
25c3 ed 52			sbc hl, de 
25c5				endm 
# End of macro FORTH_DSP_PTR
25c5 cd 54 1e			call hlfromstack1 
25c8			 
25c8				FORTH_DSP_PTR 3     ; TOS 
25c8 2a e5 e9			ld hl,(cli_data_sp) 
25cb 11 09 00			ld de, 3 * 3 
25ce ed 52			sbc hl, de 
25d0				endm 
# End of macro FORTH_DSP_PTR
25d0 cd 5a 1e			call hlfromstack2 
25d3			 
25d3				NEXTW 
25d3 cd 6c ee			call parse_vector 
25d6 c3 f0 1e			jp macro_next 
25d9				endm 
# End of macro NEXTW
25d9			.AT: 
25d9			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
25d9 1f				db WORD_SYS_CORE+OPCODE_AT             
25da 0e 26			dw .CAT            
25dc 02				db 1 + 1 
25dd .. 00			db "@",0              
25df				endm 
# End of macro CWHEAD
25df			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
25df			 
25df				if DEBUG_FORTH_WORDS_KEY 
25df					DMARK "AT." 
25df f5				push af  
25e0 3a f4 25			ld a, (.dmark)  
25e3 32 62 ee			ld (debug_mark),a  
25e6 3a f5 25			ld a, (.dmark+1)  
25e9 32 63 ee			ld (debug_mark+1),a  
25ec 3a f6 25			ld a, (.dmark+2)  
25ef 32 64 ee			ld (debug_mark+2),a  
25f2 18 03			jr .pastdmark  
25f4 ..			.dmark: db "AT."  
25f7 f1			.pastdmark: pop af  
25f8			endm  
# End of macro DMARK
25f8					CALLMONITOR 
25f8 cd 6f ee			call debug_vector  
25fb				endm  
# End of macro CALLMONITOR
25fb				endif 
25fb			.getbyteat:	 
25fb				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25fb cd 05 1d			call macro_dsp_valuehl 
25fe				endm 
# End of macro FORTH_DSP_VALUEHL
25fe				 
25fe			;		push hl 
25fe			 
25fe				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25fe cd bd 1d			call macro_forth_dsp_pop 
2601				endm 
# End of macro FORTH_DSP_POP
2601			 
2601			;		pop hl 
2601			 
2601 7e				ld a, (hl) 
2602			 
2602 6f				ld l, a 
2603 26 00			ld h, 0 
2605 cd 00 1b			call forth_push_numhl 
2608			 
2608				NEXTW 
2608 cd 6c ee			call parse_vector 
260b c3 f0 1e			jp macro_next 
260e				endm 
# End of macro NEXTW
260e			.CAT: 
260e			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
260e 20				db WORD_SYS_CORE+OPCODE_CAT             
260f 3a 26			dw .BANG            
2611 03				db 2 + 1 
2612 .. 00			db "C@",0              
2615				endm 
# End of macro CWHEAD
2615			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2615				if DEBUG_FORTH_WORDS_KEY 
2615					DMARK "CAA" 
2615 f5				push af  
2616 3a 2a 26			ld a, (.dmark)  
2619 32 62 ee			ld (debug_mark),a  
261c 3a 2b 26			ld a, (.dmark+1)  
261f 32 63 ee			ld (debug_mark+1),a  
2622 3a 2c 26			ld a, (.dmark+2)  
2625 32 64 ee			ld (debug_mark+2),a  
2628 18 03			jr .pastdmark  
262a ..			.dmark: db "CAA"  
262d f1			.pastdmark: pop af  
262e			endm  
# End of macro DMARK
262e					CALLMONITOR 
262e cd 6f ee			call debug_vector  
2631				endm  
# End of macro CALLMONITOR
2631				endif 
2631 c3 fb 25			jp .getbyteat 
2634				NEXTW 
2634 cd 6c ee			call parse_vector 
2637 c3 f0 1e			jp macro_next 
263a				endm 
# End of macro NEXTW
263a			.BANG: 
263a			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
263a 21				db WORD_SYS_CORE+OPCODE_BANG             
263b 73 26			dw .CBANG            
263d 02				db 1 + 1 
263e .. 00			db "!",0              
2640				endm 
# End of macro CWHEAD
2640			; | ! ( x w -- ) Store x at address w      | DONE 
2640				if DEBUG_FORTH_WORDS_KEY 
2640					DMARK "BNG" 
2640 f5				push af  
2641 3a 55 26			ld a, (.dmark)  
2644 32 62 ee			ld (debug_mark),a  
2647 3a 56 26			ld a, (.dmark+1)  
264a 32 63 ee			ld (debug_mark+1),a  
264d 3a 57 26			ld a, (.dmark+2)  
2650 32 64 ee			ld (debug_mark+2),a  
2653 18 03			jr .pastdmark  
2655 ..			.dmark: db "BNG"  
2658 f1			.pastdmark: pop af  
2659			endm  
# End of macro DMARK
2659					CALLMONITOR 
2659 cd 6f ee			call debug_vector  
265c				endm  
# End of macro CALLMONITOR
265c				endif 
265c			 
265c			.storebyteat:		 
265c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
265c cd 05 1d			call macro_dsp_valuehl 
265f				endm 
# End of macro FORTH_DSP_VALUEHL
265f				 
265f e5				push hl 
2660			 
2660				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2660 cd bd 1d			call macro_forth_dsp_pop 
2663				endm 
# End of macro FORTH_DSP_POP
2663			 
2663				; get byte to poke 
2663			 
2663				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2663 cd 05 1d			call macro_dsp_valuehl 
2666				endm 
# End of macro FORTH_DSP_VALUEHL
2666 e5				push hl 
2667			 
2667			 
2667				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2667 cd bd 1d			call macro_forth_dsp_pop 
266a				endm 
# End of macro FORTH_DSP_POP
266a			 
266a			 
266a d1				pop de 
266b e1				pop hl 
266c			 
266c 73				ld (hl),e 
266d			 
266d			 
266d				NEXTW 
266d cd 6c ee			call parse_vector 
2670 c3 f0 1e			jp macro_next 
2673				endm 
# End of macro NEXTW
2673			.CBANG: 
2673			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2673 22				db WORD_SYS_CORE+OPCODE_CBANG             
2674 9f 26			dw .SCALL            
2676 03				db 2 + 1 
2677 .. 00			db "C!",0              
267a				endm 
# End of macro CWHEAD
267a			; | C!  ( x w -- ) Store x at address w  | DONE 
267a				if DEBUG_FORTH_WORDS_KEY 
267a					DMARK "CBA" 
267a f5				push af  
267b 3a 8f 26			ld a, (.dmark)  
267e 32 62 ee			ld (debug_mark),a  
2681 3a 90 26			ld a, (.dmark+1)  
2684 32 63 ee			ld (debug_mark+1),a  
2687 3a 91 26			ld a, (.dmark+2)  
268a 32 64 ee			ld (debug_mark+2),a  
268d 18 03			jr .pastdmark  
268f ..			.dmark: db "CBA"  
2692 f1			.pastdmark: pop af  
2693			endm  
# End of macro DMARK
2693					CALLMONITOR 
2693 cd 6f ee			call debug_vector  
2696				endm  
# End of macro CALLMONITOR
2696				endif 
2696 c3 5c 26			jp .storebyteat 
2699				NEXTW 
2699 cd 6c ee			call parse_vector 
269c c3 f0 1e			jp macro_next 
269f				endm 
# End of macro NEXTW
269f			.SCALL: 
269f			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
269f 23				db WORD_SYS_CORE+OPCODE_SCALL             
26a0 d6 26			dw .DEPTH            
26a2 05				db 4 + 1 
26a3 .. 00			db "CALL",0              
26a8				endm 
# End of macro CWHEAD
26a8			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
26a8				if DEBUG_FORTH_WORDS_KEY 
26a8					DMARK "CLL" 
26a8 f5				push af  
26a9 3a bd 26			ld a, (.dmark)  
26ac 32 62 ee			ld (debug_mark),a  
26af 3a be 26			ld a, (.dmark+1)  
26b2 32 63 ee			ld (debug_mark+1),a  
26b5 3a bf 26			ld a, (.dmark+2)  
26b8 32 64 ee			ld (debug_mark+2),a  
26bb 18 03			jr .pastdmark  
26bd ..			.dmark: db "CLL"  
26c0 f1			.pastdmark: pop af  
26c1			endm  
# End of macro DMARK
26c1					CALLMONITOR 
26c1 cd 6f ee			call debug_vector  
26c4				endm  
# End of macro CALLMONITOR
26c4				endif 
26c4			 
26c4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26c4 cd 05 1d			call macro_dsp_valuehl 
26c7				endm 
# End of macro FORTH_DSP_VALUEHL
26c7			 
26c7			;		push hl 
26c7			 
26c7				; destroy value TOS 
26c7			 
26c7				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26c7 cd bd 1d			call macro_forth_dsp_pop 
26ca				endm 
# End of macro FORTH_DSP_POP
26ca			 
26ca					 
26ca			;		pop hl 
26ca			 
26ca				; how to do a call with hl???? save SP? 
26ca cd 94 1e			call forth_call_hl 
26cd			 
26cd			 
26cd				; TODO push value back onto stack for another op etc 
26cd			 
26cd cd 00 1b			call forth_push_numhl 
26d0				NEXTW 
26d0 cd 6c ee			call parse_vector 
26d3 c3 f0 1e			jp macro_next 
26d6				endm 
# End of macro NEXTW
26d6			.DEPTH: 
26d6			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
26d6 24				db WORD_SYS_CORE+OPCODE_DEPTH             
26d7 16 27			dw .OVER            
26d9 06				db 5 + 1 
26da .. 00			db "DEPTH",0              
26e0				endm 
# End of macro CWHEAD
26e0			; | DEPTH ( -- u ) Push count of stack | DONE 
26e0				; take current TOS and remove from base value div by two to get count 
26e0				if DEBUG_FORTH_WORDS_KEY 
26e0					DMARK "DEP" 
26e0 f5				push af  
26e1 3a f5 26			ld a, (.dmark)  
26e4 32 62 ee			ld (debug_mark),a  
26e7 3a f6 26			ld a, (.dmark+1)  
26ea 32 63 ee			ld (debug_mark+1),a  
26ed 3a f7 26			ld a, (.dmark+2)  
26f0 32 64 ee			ld (debug_mark+2),a  
26f3 18 03			jr .pastdmark  
26f5 ..			.dmark: db "DEP"  
26f8 f1			.pastdmark: pop af  
26f9			endm  
# End of macro DMARK
26f9					CALLMONITOR 
26f9 cd 6f ee			call debug_vector  
26fc				endm  
# End of macro CALLMONITOR
26fc				endif 
26fc			 
26fc			 
26fc 2a e5 e9		ld hl, (cli_data_sp) 
26ff 11 1f e8		ld de, cli_data_stack 
2702 ed 52		sbc hl,de 
2704			 
2704			; div by size of stack item 
2704			 
2704 5d			ld e,l 
2705 0e 03		ld c, 3 
2707 cd 85 0d		call Div8 
270a			 
270a 6f			ld l,a 
270b 26 00		ld h,0 
270d			 
270d			;srl h 
270d			;rr l 
270d			 
270d cd 00 1b			call forth_push_numhl 
2710				NEXTW 
2710 cd 6c ee			call parse_vector 
2713 c3 f0 1e			jp macro_next 
2716				endm 
# End of macro NEXTW
2716			.OVER: 
2716			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2716 42				db WORD_SYS_CORE+46             
2717 66 27			dw .PAUSE            
2719 05				db 4 + 1 
271a .. 00			db "OVER",0              
271f				endm 
# End of macro CWHEAD
271f			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
271f			; | | If the copied item is a string it is properly duplicated allowing for a safe release after use.  
271f				if DEBUG_FORTH_WORDS_KEY 
271f					DMARK "OVR" 
271f f5				push af  
2720 3a 34 27			ld a, (.dmark)  
2723 32 62 ee			ld (debug_mark),a  
2726 3a 35 27			ld a, (.dmark+1)  
2729 32 63 ee			ld (debug_mark+1),a  
272c 3a 36 27			ld a, (.dmark+2)  
272f 32 64 ee			ld (debug_mark+2),a  
2732 18 03			jr .pastdmark  
2734 ..			.dmark: db "OVR"  
2737 f1			.pastdmark: pop af  
2738			endm  
# End of macro DMARK
2738					CALLMONITOR 
2738 cd 6f ee			call debug_vector  
273b				endm  
# End of macro CALLMONITOR
273b				endif 
273b			 
273b			; TODO Use os stack swap memory 
273b			 
273b				; work out what type we are looking at 
273b			 
273b				FORTH_DSP_PTR 1 
273b 2a e5 e9			ld hl,(cli_data_sp) 
273e 11 03 00			ld de, 1 * 3 
2741 ed 52			sbc hl, de 
2743				endm 
# End of macro FORTH_DSP_PTR
2743			 
2743 7e				ld a, (hl) 
2744				 
2744 f5				push af 
2745				; whatever the type lets get the pointer or word 
2745 23				inc hl 
2746			;; 
2746			 
2746				; type check now to decide on how to push  
2746			 
2746 cd 72 1e			call loadwordinhl 
2749 f1				pop af 
274a fe 01			cp DS_TYPE_STR 
274c 28 09			jr z, .ovstr 
274e			 
274e				; we have a numeric so load the word and push 
274e			;	ld e, (hl) 
274e			;	inc hl 
274e			;	ld d, (hl) 
274e			;	ex de, hl 
274e cd 00 1b			call forth_push_numhl 
2751				NEXTW 
2751 cd 6c ee			call parse_vector 
2754 c3 f0 1e			jp macro_next 
2757				endm 
# End of macro NEXTW
2757			 
2757			.ovstr: 
2757				; ok, a string so get the pointer and push as a string 
2757			 
2757			;	call loadwordinhl 
2757 cd 6e 1b			call forth_push_str 
275a				NEXTW 
275a cd 6c ee			call parse_vector 
275d c3 f0 1e			jp macro_next 
2760				endm 
# End of macro NEXTW
2760			 
2760			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2760			;	push hl    ; n2 
2760			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2760			; 
2760			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2760			;	push hl    ; n1 
2760			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2760			; 
2760			;	pop de     ; n1 
2760			;	pop hl     ; n2 
2760			; 
2760			;	push de 
2760			;	push hl 
2760			;	push de 
2760			 
2760				; push back  
2760			 
2760			;	pop hl 
2760			;	call forth_push_numhl 
2760			;	pop hl 
2760			;	call forth_push_numhl 
2760			;	pop hl 
2760			;	call forth_push_numhl 
2760				NEXTW 
2760 cd 6c ee			call parse_vector 
2763 c3 f0 1e			jp macro_next 
2766				endm 
# End of macro NEXTW
2766			 
2766			.PAUSE: 
2766			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2766 43				db WORD_SYS_CORE+47             
2767 9e 27			dw .PAUSES            
2769 08				db 7 + 1 
276a .. 00			db "PAUSEMS",0              
2772				endm 
# End of macro CWHEAD
2772			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2772				if DEBUG_FORTH_WORDS_KEY 
2772					DMARK "PMS" 
2772 f5				push af  
2773 3a 87 27			ld a, (.dmark)  
2776 32 62 ee			ld (debug_mark),a  
2779 3a 88 27			ld a, (.dmark+1)  
277c 32 63 ee			ld (debug_mark+1),a  
277f 3a 89 27			ld a, (.dmark+2)  
2782 32 64 ee			ld (debug_mark+2),a  
2785 18 03			jr .pastdmark  
2787 ..			.dmark: db "PMS"  
278a f1			.pastdmark: pop af  
278b			endm  
# End of macro DMARK
278b					CALLMONITOR 
278b cd 6f ee			call debug_vector  
278e				endm  
# End of macro CALLMONITOR
278e				endif 
278e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
278e cd 05 1d			call macro_dsp_valuehl 
2791				endm 
# End of macro FORTH_DSP_VALUEHL
2791			;		push hl    ; n2 
2791				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2791 cd bd 1d			call macro_forth_dsp_pop 
2794				endm 
# End of macro FORTH_DSP_POP
2794			;		pop hl 
2794			 
2794 7d				ld a, l 
2795 cd e5 0a			call aDelayInMS 
2798			       NEXTW 
2798 cd 6c ee			call parse_vector 
279b c3 f0 1e			jp macro_next 
279e				endm 
# End of macro NEXTW
279e			.PAUSES:  
279e			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
279e 44				db WORD_SYS_CORE+48             
279f 10 28			dw .ROT            
27a1 06				db 5 + 1 
27a2 .. 00			db "PAUSE",0              
27a8				endm 
# End of macro CWHEAD
27a8			; | PAUSE ( n -- )  Pause for n seconds | DONE 
27a8				if DEBUG_FORTH_WORDS_KEY 
27a8					DMARK "PAU" 
27a8 f5				push af  
27a9 3a bd 27			ld a, (.dmark)  
27ac 32 62 ee			ld (debug_mark),a  
27af 3a be 27			ld a, (.dmark+1)  
27b2 32 63 ee			ld (debug_mark+1),a  
27b5 3a bf 27			ld a, (.dmark+2)  
27b8 32 64 ee			ld (debug_mark+2),a  
27bb 18 03			jr .pastdmark  
27bd ..			.dmark: db "PAU"  
27c0 f1			.pastdmark: pop af  
27c1			endm  
# End of macro DMARK
27c1					CALLMONITOR 
27c1 cd 6f ee			call debug_vector  
27c4				endm  
# End of macro CALLMONITOR
27c4				endif 
27c4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27c4 cd 05 1d			call macro_dsp_valuehl 
27c7				endm 
# End of macro FORTH_DSP_VALUEHL
27c7			;		push hl    ; n2 
27c7				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27c7 cd bd 1d			call macro_forth_dsp_pop 
27ca				endm 
# End of macro FORTH_DSP_POP
27ca			;		pop hl 
27ca 45				ld b, l 
27cb				if DEBUG_FORTH_WORDS 
27cb					DMARK "PAU" 
27cb f5				push af  
27cc 3a e0 27			ld a, (.dmark)  
27cf 32 62 ee			ld (debug_mark),a  
27d2 3a e1 27			ld a, (.dmark+1)  
27d5 32 63 ee			ld (debug_mark+1),a  
27d8 3a e2 27			ld a, (.dmark+2)  
27db 32 64 ee			ld (debug_mark+2),a  
27de 18 03			jr .pastdmark  
27e0 ..			.dmark: db "PAU"  
27e3 f1			.pastdmark: pop af  
27e4			endm  
# End of macro DMARK
27e4					CALLMONITOR 
27e4 cd 6f ee			call debug_vector  
27e7				endm  
# End of macro CALLMONITOR
27e7				endif 
27e7 c5			.pauses1:	push bc 
27e8 cd 00 0b			call delay1s 
27eb c1				pop bc 
27ec				if DEBUG_FORTH_WORDS 
27ec					DMARK "PA1" 
27ec f5				push af  
27ed 3a 01 28			ld a, (.dmark)  
27f0 32 62 ee			ld (debug_mark),a  
27f3 3a 02 28			ld a, (.dmark+1)  
27f6 32 63 ee			ld (debug_mark+1),a  
27f9 3a 03 28			ld a, (.dmark+2)  
27fc 32 64 ee			ld (debug_mark+2),a  
27ff 18 03			jr .pastdmark  
2801 ..			.dmark: db "PA1"  
2804 f1			.pastdmark: pop af  
2805			endm  
# End of macro DMARK
2805					CALLMONITOR 
2805 cd 6f ee			call debug_vector  
2808				endm  
# End of macro CALLMONITOR
2808				endif 
2808 10 dd			djnz .pauses1 
280a			 
280a			       NEXTW 
280a cd 6c ee			call parse_vector 
280d c3 f0 1e			jp macro_next 
2810				endm 
# End of macro NEXTW
2810			.ROT: 
2810			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2810 45				db WORD_SYS_CORE+49             
2811 7c 28			dw .UWORDS            
2813 04				db 3 + 1 
2814 .. 00			db "ROT",0              
2818				endm 
# End of macro CWHEAD
2818			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2818				if DEBUG_FORTH_WORDS_KEY 
2818					DMARK "ROT" 
2818 f5				push af  
2819 3a 2d 28			ld a, (.dmark)  
281c 32 62 ee			ld (debug_mark),a  
281f 3a 2e 28			ld a, (.dmark+1)  
2822 32 63 ee			ld (debug_mark+1),a  
2825 3a 2f 28			ld a, (.dmark+2)  
2828 32 64 ee			ld (debug_mark+2),a  
282b 18 03			jr .pastdmark  
282d ..			.dmark: db "ROT"  
2830 f1			.pastdmark: pop af  
2831			endm  
# End of macro DMARK
2831					CALLMONITOR 
2831 cd 6f ee			call debug_vector  
2834				endm  
# End of macro CALLMONITOR
2834				endif 
2834			 
2834			; DONE Use os stack swap memory 
2834			 
2834				FORTH_DSP_PTR 0     ; u3 
2834 2a e5 e9			ld hl,(cli_data_sp) 
2837 11 00 00			ld de, 0 * 3 
283a ed 52			sbc hl, de 
283c				endm 
# End of macro FORTH_DSP_PTR
283c cd 3c 1e			call hltostack1     
283f			  
283f				FORTH_DSP_PTR 1     ; u2 
283f 2a e5 e9			ld hl,(cli_data_sp) 
2842 11 03 00			ld de, 1 * 3 
2845 ed 52			sbc hl, de 
2847				endm 
# End of macro FORTH_DSP_PTR
2847 cd 42 1e			call hltostack2      
284a			 
284a				FORTH_DSP_PTR 2     ; u1 
284a 2a e5 e9			ld hl,(cli_data_sp) 
284d 11 06 00			ld de, 2 * 3 
2850 ed 52			sbc hl, de 
2852				endm 
# End of macro FORTH_DSP_PTR
2852 cd 48 1e			call hltostack3 
2855			 
2855			 
2855				FORTH_DSP_PTR 0     ;  
2855 2a e5 e9			ld hl,(cli_data_sp) 
2858 11 00 00			ld de, 0 * 3 
285b ed 52			sbc hl, de 
285d				endm 
# End of macro FORTH_DSP_PTR
285d cd 60 1e			call hlfromstack3 
2860			 
2860				FORTH_DSP_PTR 1     ; TOS 
2860 2a e5 e9			ld hl,(cli_data_sp) 
2863 11 03 00			ld de, 1 * 3 
2866 ed 52			sbc hl, de 
2868				endm 
# End of macro FORTH_DSP_PTR
2868 cd 54 1e			call hlfromstack1 
286b			 
286b				FORTH_DSP_PTR 2     ; TOS 
286b 2a e5 e9			ld hl,(cli_data_sp) 
286e 11 06 00			ld de, 2 * 3 
2871 ed 52			sbc hl, de 
2873				endm 
# End of macro FORTH_DSP_PTR
2873 cd 5a 1e			call hlfromstack2 
2876			 
2876			 
2876			;	FORTH_DSP_VALUEHL 
2876			;	push hl    ; u3  
2876			; 
2876			;	FORTH_DSP_POP 
2876			; 
2876			;	FORTH_DSP_VALUEHL 
2876			;	push hl     ; u2 
2876			; 
2876			;	FORTH_DSP_POP 
2876			; 
2876			;	FORTH_DSP_VALUEHL 
2876			;	push hl     ; u1 
2876			; 
2876			;	FORTH_DSP_POP 
2876			; 
2876			;	pop bc      ; u1 
2876			;	pop hl      ; u2 
2876			;	pop de      ; u3 
2876			; 
2876			; 
2876			;	push bc 
2876			;	push de 
2876			;	push hl 
2876			; 
2876			; 
2876			;	pop hl 
2876			;	call forth_push_numhl 
2876			; 
2876			;	pop hl 
2876			;	call forth_push_numhl 
2876			; 
2876			;	pop hl 
2876			;	call forth_push_numhl 
2876				 
2876			 
2876			 
2876			 
2876			 
2876			 
2876			       NEXTW 
2876 cd 6c ee			call parse_vector 
2879 c3 f0 1e			jp macro_next 
287c				endm 
# End of macro NEXTW
287c			 
287c			.UWORDS: 
287c			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
287c 50				db WORD_SYS_CORE+60             
287d 41 29			dw .BP            
287f 07				db 6 + 1 
2880 .. 00			db "UWORDS",0              
2887				endm 
# End of macro CWHEAD
2887			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2887			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2887			; | | Following the count are the individual words. 
2887			; | | 
2887			; | | e.g. UWORDS 
2887			; | | BOX DIRLIST 2 
2887			; | |  
2887			; | | Can be used to save the words to storage via: 
2887			; | | UWORDS $01 DO $01 APPEND LOOP 
2887			if DEBUG_FORTH_WORDS_KEY 
2887				DMARK "UWR" 
2887 f5				push af  
2888 3a 9c 28			ld a, (.dmark)  
288b 32 62 ee			ld (debug_mark),a  
288e 3a 9d 28			ld a, (.dmark+1)  
2891 32 63 ee			ld (debug_mark+1),a  
2894 3a 9e 28			ld a, (.dmark+2)  
2897 32 64 ee			ld (debug_mark+2),a  
289a 18 03			jr .pastdmark  
289c ..			.dmark: db "UWR"  
289f f1			.pastdmark: pop af  
28a0			endm  
# End of macro DMARK
28a0				CALLMONITOR 
28a0 cd 6f ee			call debug_vector  
28a3				endm  
# End of macro CALLMONITOR
28a3			endif 
28a3 21 53 65			ld hl, baseram 
28a6				;ld hl, baseusermem 
28a6 01 00 00			ld bc, 0    ; start a counter 
28a9			 
28a9			; skip dict stub 
28a9			 
28a9 cd 2d 20			call forth_tok_next 
28ac			 
28ac			 
28ac			; while we have words to look for 
28ac			 
28ac 7e			.douscan:	ld a, (hl)      
28ad			if DEBUG_FORTH_WORDS 
28ad				DMARK "UWs" 
28ad f5				push af  
28ae 3a c2 28			ld a, (.dmark)  
28b1 32 62 ee			ld (debug_mark),a  
28b4 3a c3 28			ld a, (.dmark+1)  
28b7 32 63 ee			ld (debug_mark+1),a  
28ba 3a c4 28			ld a, (.dmark+2)  
28bd 32 64 ee			ld (debug_mark+2),a  
28c0 18 03			jr .pastdmark  
28c2 ..			.dmark: db "UWs"  
28c5 f1			.pastdmark: pop af  
28c6			endm  
# End of macro DMARK
28c6				CALLMONITOR 
28c6 cd 6f ee			call debug_vector  
28c9				endm  
# End of macro CALLMONITOR
28c9			endif 
28c9 fe 00			cp WORD_SYS_END 
28cb 28 4d			jr z, .udone 
28cd fe 01			cp WORD_SYS_UWORD 
28cf 20 44			jr nz, .nuword 
28d1			 
28d1			if DEBUG_FORTH_WORDS 
28d1				DMARK "UWu" 
28d1 f5				push af  
28d2 3a e6 28			ld a, (.dmark)  
28d5 32 62 ee			ld (debug_mark),a  
28d8 3a e7 28			ld a, (.dmark+1)  
28db 32 63 ee			ld (debug_mark+1),a  
28de 3a e8 28			ld a, (.dmark+2)  
28e1 32 64 ee			ld (debug_mark+2),a  
28e4 18 03			jr .pastdmark  
28e6 ..			.dmark: db "UWu"  
28e9 f1			.pastdmark: pop af  
28ea			endm  
# End of macro DMARK
28ea				CALLMONITOR 
28ea cd 6f ee			call debug_vector  
28ed				endm  
# End of macro CALLMONITOR
28ed			endif 
28ed				; we have a uword so push its name to the stack 
28ed			 
28ed e5				push hl  ; save so we can move to next dict block 
28ee			 
28ee				; skip opcode 
28ee 23				inc hl  
28ef				; skip next ptr 
28ef 23				inc hl  
28f0 23				inc hl 
28f1				; skip len 
28f1 23				inc hl 
28f2			if DEBUG_FORTH_WORDS 
28f2				DMARK "UWt" 
28f2 f5				push af  
28f3 3a 07 29			ld a, (.dmark)  
28f6 32 62 ee			ld (debug_mark),a  
28f9 3a 08 29			ld a, (.dmark+1)  
28fc 32 63 ee			ld (debug_mark+1),a  
28ff 3a 09 29			ld a, (.dmark+2)  
2902 32 64 ee			ld (debug_mark+2),a  
2905 18 03			jr .pastdmark  
2907 ..			.dmark: db "UWt"  
290a f1			.pastdmark: pop af  
290b			endm  
# End of macro DMARK
290b				CALLMONITOR 
290b cd 6f ee			call debug_vector  
290e				endm  
# End of macro CALLMONITOR
290e			endif 
290e 03				inc bc 
290f			 
290f c5				push bc 
2910 cd 6e 1b			call forth_push_str 
2913 c1				pop bc 
2914			 
2914 e1				pop hl 	 
2915			 
2915 cd 2d 20		.nuword:	call forth_tok_next 
2918 18 92			jr .douscan  
291a			 
291a			.udone:		 ; push count of uwords found 
291a c5				push bc 
291b e1				pop hl 
291c			 
291c			if DEBUG_FORTH_WORDS 
291c				DMARK "UWc" 
291c f5				push af  
291d 3a 31 29			ld a, (.dmark)  
2920 32 62 ee			ld (debug_mark),a  
2923 3a 32 29			ld a, (.dmark+1)  
2926 32 63 ee			ld (debug_mark+1),a  
2929 3a 33 29			ld a, (.dmark+2)  
292c 32 64 ee			ld (debug_mark+2),a  
292f 18 03			jr .pastdmark  
2931 ..			.dmark: db "UWc"  
2934 f1			.pastdmark: pop af  
2935			endm  
# End of macro DMARK
2935				CALLMONITOR 
2935 cd 6f ee			call debug_vector  
2938				endm  
# End of macro CALLMONITOR
2938			endif 
2938 cd 00 1b			call forth_push_numhl 
293b			 
293b			 
293b			       NEXTW 
293b cd 6c ee			call parse_vector 
293e c3 f0 1e			jp macro_next 
2941				endm 
# End of macro NEXTW
2941			 
2941			.BP: 
2941			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2941 54				db WORD_SYS_CORE+64             
2942 81 29			dw .MONITOR            
2944 03				db 2 + 1 
2945 .. 00			db "BP",0              
2948				endm 
# End of macro CWHEAD
2948			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2948			; | | $00 Will enable the break points within specific code paths 
2948			; | | $01 Will disable break points 
2948			; | |  
2948			; | | By default break points are off. Either the above can be used to enable them 
2948			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2948			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2948			; | | can disable break points. Exiting will then continue boot process. 
2948				; get byte count 
2948				if DEBUG_FORTH_WORDS_KEY 
2948					DMARK "BP." 
2948 f5				push af  
2949 3a 5d 29			ld a, (.dmark)  
294c 32 62 ee			ld (debug_mark),a  
294f 3a 5e 29			ld a, (.dmark+1)  
2952 32 63 ee			ld (debug_mark+1),a  
2955 3a 5f 29			ld a, (.dmark+2)  
2958 32 64 ee			ld (debug_mark+2),a  
295b 18 03			jr .pastdmark  
295d ..			.dmark: db "BP."  
2960 f1			.pastdmark: pop af  
2961			endm  
# End of macro DMARK
2961					CALLMONITOR 
2961 cd 6f ee			call debug_vector  
2964				endm  
# End of macro CALLMONITOR
2964				endif 
2964			 
2964				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2964 cd 05 1d			call macro_dsp_valuehl 
2967				endm 
# End of macro FORTH_DSP_VALUEHL
2967			 
2967			;		push hl 
2967			 
2967				; destroy value TOS 
2967			 
2967				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2967 cd bd 1d			call macro_forth_dsp_pop 
296a				endm 
# End of macro FORTH_DSP_POP
296a			 
296a			;		pop hl 
296a			 
296a 3e 00			ld a,0 
296c bd				cp l 
296d 28 09			jr z, .bpset 
296f			;		ld a, '*' 
296f cd 85 14			call bp_off 
2972				NEXTW 
2972 cd 6c ee			call parse_vector 
2975 c3 f0 1e			jp macro_next 
2978				endm 
# End of macro NEXTW
2978			 
2978			.bpset:	 
2978				;	ld (os_view_disable), a 
2978 cd 79 14			call bp_on 
297b			 
297b			 
297b				NEXTW 
297b cd 6c ee			call parse_vector 
297e c3 f0 1e			jp macro_next 
2981				endm 
# End of macro NEXTW
2981			 
2981			 
2981			.MONITOR: 
2981			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2981 55				db WORD_SYS_CORE+65             
2982 b5 29			dw .MALLOC            
2984 08				db 7 + 1 
2985 .. 00			db "MONITOR",0              
298d				endm 
# End of macro CWHEAD
298d			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
298d			; | | At start the current various registers will be displayed with contents. 
298d			; | | Top right corner will show the most recent debug marker seen. 
298d			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
298d			; | | and the return stack pointer (RSP). 
298d			; | | Pressing: 
298d			; | |    1 - Initial screen 
298d			; | |    2 - Display a data dump of HL 
298d			; | |    3 - Display a data dump of DE 
298d			; | |    4 - Display a data dump of BC 
298d			; | |    5 - Display a data dump of HL 
298d			; | |    6 - Display a data dump of DSP 
298d			; | |    7 - Display a data dump of RSP 
298d			; | |    8 - Display a data dump of what is at DSP 
298d			; | |    9 - Display a data dump of what is at RSP 
298d			; | |    0 - Exit monitor and continue running. This will also enable break points 
298d			; | |    * - Disable break points 
298d			; | |    # - Enter traditional monitor mode 
298d			; | | 
298d			; | | Monitor Mode 
298d			; | | ------------ 
298d			; | | A prompt of '>' will be shown for various commands: 
298d			; | |    D xxxx - Display a data dump starting from hex address xxxx 
298d			; | |    C - Continue display a data dump from the last set address 
298d			; | |    M xxxx - Set start of memory edit at address xx 
298d			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
298d			; | |    G xxxx - Exec code at specific address 
298d			; | |    Q - Return to previous 
298d				if DEBUG_FORTH_WORDS_KEY 
298d					DMARK "MON" 
298d f5				push af  
298e 3a a2 29			ld a, (.dmark)  
2991 32 62 ee			ld (debug_mark),a  
2994 3a a3 29			ld a, (.dmark+1)  
2997 32 63 ee			ld (debug_mark+1),a  
299a 3a a4 29			ld a, (.dmark+2)  
299d 32 64 ee			ld (debug_mark+2),a  
29a0 18 03			jr .pastdmark  
29a2 ..			.dmark: db "MON"  
29a5 f1			.pastdmark: pop af  
29a6			endm  
# End of macro DMARK
29a6					CALLMONITOR 
29a6 cd 6f ee			call debug_vector  
29a9				endm  
# End of macro CALLMONITOR
29a9				endif 
29a9			;		ld a, 0 
29a9			;		ld (os_view_disable), a 
29a9 cd 79 14			call bp_on 
29ac			 
29ac				CALLMONITOR 
29ac cd 6f ee			call debug_vector  
29af				endm  
# End of macro CALLMONITOR
29af			 
29af			;	call monitor 
29af			 
29af				NEXTW 
29af cd 6c ee			call parse_vector 
29b2 c3 f0 1e			jp macro_next 
29b5				endm 
# End of macro NEXTW
29b5			 
29b5			 
29b5			.MALLOC: 
29b5			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
29b5 56				db WORD_SYS_CORE+66             
29b6 de 29			dw .MALLOC2            
29b8 06				db 5 + 1 
29b9 .. 00			db "ALLOT",0              
29bf				endm 
# End of macro CWHEAD
29bf			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
29bf				if DEBUG_FORTH_WORDS_KEY 
29bf					DMARK "ALL" 
29bf f5				push af  
29c0 3a d4 29			ld a, (.dmark)  
29c3 32 62 ee			ld (debug_mark),a  
29c6 3a d5 29			ld a, (.dmark+1)  
29c9 32 63 ee			ld (debug_mark+1),a  
29cc 3a d6 29			ld a, (.dmark+2)  
29cf 32 64 ee			ld (debug_mark+2),a  
29d2 18 03			jr .pastdmark  
29d4 ..			.dmark: db "ALL"  
29d7 f1			.pastdmark: pop af  
29d8			endm  
# End of macro DMARK
29d8					CALLMONITOR 
29d8 cd 6f ee			call debug_vector  
29db				endm  
# End of macro CALLMONITOR
29db				endif 
29db c3 05 2a			jp .mallocc 
29de			.MALLOC2: 
29de			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
29de 56				db WORD_SYS_CORE+66             
29df 1f 2a			dw .FREE            
29e1 07				db 6 + 1 
29e2 .. 00			db "MALLOC",0              
29e9				endm 
# End of macro CWHEAD
29e9			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
29e9				; get byte count 
29e9				if DEBUG_FORTH_WORDS_KEY 
29e9					DMARK "MAL" 
29e9 f5				push af  
29ea 3a fe 29			ld a, (.dmark)  
29ed 32 62 ee			ld (debug_mark),a  
29f0 3a ff 29			ld a, (.dmark+1)  
29f3 32 63 ee			ld (debug_mark+1),a  
29f6 3a 00 2a			ld a, (.dmark+2)  
29f9 32 64 ee			ld (debug_mark+2),a  
29fc 18 03			jr .pastdmark  
29fe ..			.dmark: db "MAL"  
2a01 f1			.pastdmark: pop af  
2a02			endm  
# End of macro DMARK
2a02					CALLMONITOR 
2a02 cd 6f ee			call debug_vector  
2a05				endm  
# End of macro CALLMONITOR
2a05				endif 
2a05			.mallocc: 
2a05				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a05 cd 05 1d			call macro_dsp_valuehl 
2a08				endm 
# End of macro FORTH_DSP_VALUEHL
2a08			 
2a08			;		push hl 
2a08			 
2a08				; destroy value TOS 
2a08			 
2a08				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a08 cd bd 1d			call macro_forth_dsp_pop 
2a0b				endm 
# End of macro FORTH_DSP_POP
2a0b			 
2a0b			;		pop hl 
2a0b cd d0 11			call malloc 
2a0e			if DEBUG_FORTH_MALLOC_GUARD 
2a0e f5				push af 
2a0f cd 1e 0e			call ishlzero 
2a12			;		ld a, l 
2a12			;		add h 
2a12			;		cp 0 
2a12 f1				pop af 
2a13				 
2a13 cc a9 53			call z,malloc_error 
2a16			endif 
2a16			 
2a16 cd 00 1b			call forth_push_numhl 
2a19				NEXTW 
2a19 cd 6c ee			call parse_vector 
2a1c c3 f0 1e			jp macro_next 
2a1f				endm 
# End of macro NEXTW
2a1f			 
2a1f			.FREE: 
2a1f			CWHEAD .UPTR 67 "FREE" 4 WORD_FLAG_CODE 
2a1f 57				db WORD_SYS_CORE+67             
2a20 53 2a			dw .UPTR            
2a22 05				db 4 + 1 
2a23 .. 00			db "FREE",0              
2a28				endm 
# End of macro CWHEAD
2a28			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2a28				if DEBUG_FORTH_WORDS_KEY 
2a28					DMARK "FRE" 
2a28 f5				push af  
2a29 3a 3d 2a			ld a, (.dmark)  
2a2c 32 62 ee			ld (debug_mark),a  
2a2f 3a 3e 2a			ld a, (.dmark+1)  
2a32 32 63 ee			ld (debug_mark+1),a  
2a35 3a 3f 2a			ld a, (.dmark+2)  
2a38 32 64 ee			ld (debug_mark+2),a  
2a3b 18 03			jr .pastdmark  
2a3d ..			.dmark: db "FRE"  
2a40 f1			.pastdmark: pop af  
2a41			endm  
# End of macro DMARK
2a41					CALLMONITOR 
2a41 cd 6f ee			call debug_vector  
2a44				endm  
# End of macro CALLMONITOR
2a44				endif 
2a44				; get address 
2a44			 
2a44				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a44 cd 05 1d			call macro_dsp_valuehl 
2a47				endm 
# End of macro FORTH_DSP_VALUEHL
2a47			 
2a47			;		push hl 
2a47			 
2a47				; destroy value TOS 
2a47			 
2a47				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a47 cd bd 1d			call macro_forth_dsp_pop 
2a4a				endm 
# End of macro FORTH_DSP_POP
2a4a			 
2a4a			;		pop hl 
2a4a			if FORTH_ENABLE_MALLOCFREE 
2a4a cd 9a 12			call free 
2a4d			endif 
2a4d				NEXTW 
2a4d cd 6c ee			call parse_vector 
2a50 c3 f0 1e			jp macro_next 
2a53				endm 
# End of macro NEXTW
2a53			.UPTR: 
2a53			CWHEAD .LIST 67 "UPTR" 4 WORD_FLAG_CODE 
2a53 57				db WORD_SYS_CORE+67             
2a54 59 2b			dw .LIST            
2a56 05				db 4 + 1 
2a57 .. 00			db "UPTR",0              
2a5c				endm 
# End of macro CWHEAD
2a5c			; | UPTR ( s -- u ) Push the address of the exec code for the quoted used word s  | TODO 
2a5c				if DEBUG_FORTH_WORDS_KEY 
2a5c					DMARK "UPT" 
2a5c f5				push af  
2a5d 3a 71 2a			ld a, (.dmark)  
2a60 32 62 ee			ld (debug_mark),a  
2a63 3a 72 2a			ld a, (.dmark+1)  
2a66 32 63 ee			ld (debug_mark+1),a  
2a69 3a 73 2a			ld a, (.dmark+2)  
2a6c 32 64 ee			ld (debug_mark+2),a  
2a6f 18 03			jr .pastdmark  
2a71 ..			.dmark: db "UPT"  
2a74 f1			.pastdmark: pop af  
2a75			endm  
# End of macro DMARK
2a75					CALLMONITOR 
2a75 cd 6f ee			call debug_vector  
2a78				endm  
# End of macro CALLMONITOR
2a78				endif 
2a78				FORTH_DSP_VALUEHL 
2a78 cd 05 1d			call macro_dsp_valuehl 
2a7b				endm 
# End of macro FORTH_DSP_VALUEHL
2a7b			 
2a7b e5				push hl 
2a7c				FORTH_DSP_POP 
2a7c cd bd 1d			call macro_forth_dsp_pop 
2a7f				endm 
# End of macro FORTH_DSP_POP
2a7f c1				pop bc 
2a80			 
2a80			 
2a80				; Get ptr to the word we need to look up 
2a80			 
2a80			;		FORTH_DSP_VALUEHL 
2a80				;v5 FORTH_DSP_VALUE 
2a80			; TODO type check 
2a80			;		inc hl    ; Skip type check  
2a80			;		push hl 
2a80			;		ex de, hl    ; put into DE 
2a80			 
2a80			 
2a80 21 53 65			ld hl, baseram 
2a83				;ld hl, baseusermem 
2a83			 
2a83 e5			push hl   ; sacreifical push 
2a84			 
2a84			.uldouscanm: 
2a84 e1			pop hl 
2a85			.uldouscan: 
2a85			if DEBUG_FORTH_WORDS 
2a85				DMARK "LSs" 
2a85 f5				push af  
2a86 3a 9a 2a			ld a, (.dmark)  
2a89 32 62 ee			ld (debug_mark),a  
2a8c 3a 9b 2a			ld a, (.dmark+1)  
2a8f 32 63 ee			ld (debug_mark+1),a  
2a92 3a 9c 2a			ld a, (.dmark+2)  
2a95 32 64 ee			ld (debug_mark+2),a  
2a98 18 03			jr .pastdmark  
2a9a ..			.dmark: db "LSs"  
2a9d f1			.pastdmark: pop af  
2a9e			endm  
# End of macro DMARK
2a9e				CALLMONITOR 
2a9e cd 6f ee			call debug_vector  
2aa1				endm  
# End of macro CALLMONITOR
2aa1			endif 
2aa1			; skip dict stub 
2aa1 cd 2d 20			call forth_tok_next 
2aa4			 
2aa4			 
2aa4			; while we have words to look for 
2aa4			 
2aa4 7e			ld a, (hl)      
2aa5			if DEBUG_FORTH_WORDS 
2aa5				DMARK "LSk" 
2aa5 f5				push af  
2aa6 3a ba 2a			ld a, (.dmark)  
2aa9 32 62 ee			ld (debug_mark),a  
2aac 3a bb 2a			ld a, (.dmark+1)  
2aaf 32 63 ee			ld (debug_mark+1),a  
2ab2 3a bc 2a			ld a, (.dmark+2)  
2ab5 32 64 ee			ld (debug_mark+2),a  
2ab8 18 03			jr .pastdmark  
2aba ..			.dmark: db "LSk"  
2abd f1			.pastdmark: pop af  
2abe			endm  
# End of macro DMARK
2abe				CALLMONITOR 
2abe cd 6f ee			call debug_vector  
2ac1				endm  
# End of macro CALLMONITOR
2ac1			endif 
2ac1				;cp WORD_SYS_END 
2ac1				;jp z, .lunotfound 
2ac1			 
2ac1					; if we hit non uwords then gone too far 
2ac1 fe 01				cp WORD_SYS_UWORD 
2ac3 c2 50 2b				jp nz, .ulunotfound 
2ac6			 
2ac6				if DEBUG_FORTH_WORDS 
2ac6					DMARK "LSu" 
2ac6 f5				push af  
2ac7 3a db 2a			ld a, (.dmark)  
2aca 32 62 ee			ld (debug_mark),a  
2acd 3a dc 2a			ld a, (.dmark+1)  
2ad0 32 63 ee			ld (debug_mark+1),a  
2ad3 3a dd 2a			ld a, (.dmark+2)  
2ad6 32 64 ee			ld (debug_mark+2),a  
2ad9 18 03			jr .pastdmark  
2adb ..			.dmark: db "LSu"  
2ade f1			.pastdmark: pop af  
2adf			endm  
# End of macro DMARK
2adf					CALLMONITOR 
2adf cd 6f ee			call debug_vector  
2ae2				endm  
# End of macro CALLMONITOR
2ae2				endif 
2ae2			 
2ae2					; found a uword but is it the one we want... 
2ae2			 
2ae2 c5					push bc     ; uword to find is on bc 
2ae3 d1					pop de 
2ae4			 
2ae4 e5					push hl  ; to save the ptr 
2ae5			 
2ae5					; skip opcode 
2ae5 23					inc hl  
2ae6					; skip next ptr 
2ae6 23					inc hl  
2ae7 23					inc hl 
2ae8					; skip len 
2ae8 23					inc hl 
2ae9			 
2ae9				if DEBUG_FORTH_WORDS 
2ae9					DMARK "LSc" 
2ae9 f5				push af  
2aea 3a fe 2a			ld a, (.dmark)  
2aed 32 62 ee			ld (debug_mark),a  
2af0 3a ff 2a			ld a, (.dmark+1)  
2af3 32 63 ee			ld (debug_mark+1),a  
2af6 3a 00 2b			ld a, (.dmark+2)  
2af9 32 64 ee			ld (debug_mark+2),a  
2afc 18 03			jr .pastdmark  
2afe ..			.dmark: db "LSc"  
2b01 f1			.pastdmark: pop af  
2b02			endm  
# End of macro DMARK
2b02					CALLMONITOR 
2b02 cd 6f ee			call debug_vector  
2b05				endm  
# End of macro CALLMONITOR
2b05				endif 
2b05			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2b05			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2b05			; Nope that has gone the other way. It needs to be exact not on first zero 
2b05			;		call strcmp 
2b05 c5					push bc 
2b06 cd a0 11				call StrictStrCmp 
2b09 c1					pop bc 
2b0a c2 84 2a				jp nz, .uldouscanm 
2b0d				 
2b0d			 
2b0d			 
2b0d					; we have a uword so push its name to the stack 
2b0d			 
2b0d			;	   	push hl  ; save so we can move to next dict block 
2b0d e1			pop hl 
2b0e			 
2b0e				if DEBUG_FORTH_WORDS 
2b0e					DMARK "LSm" 
2b0e f5				push af  
2b0f 3a 23 2b			ld a, (.dmark)  
2b12 32 62 ee			ld (debug_mark),a  
2b15 3a 24 2b			ld a, (.dmark+1)  
2b18 32 63 ee			ld (debug_mark+1),a  
2b1b 3a 25 2b			ld a, (.dmark+2)  
2b1e 32 64 ee			ld (debug_mark+2),a  
2b21 18 03			jr .pastdmark  
2b23 ..			.dmark: db "LSm"  
2b26 f1			.pastdmark: pop af  
2b27			endm  
# End of macro DMARK
2b27					CALLMONITOR 
2b27 cd 6f ee			call debug_vector  
2b2a				endm  
# End of macro CALLMONITOR
2b2a				endif 
2b2a			 
2b2a					; skip opcode 
2b2a 23					inc hl  
2b2b					; skip next ptr 
2b2b 23					inc hl  
2b2c 23					inc hl 
2b2d					; skip len 
2b2d 7e					ld a, (hl)   ; save length to add 
2b2e				if DEBUG_FORTH_WORDS 
2b2e					DMARK "LS2" 
2b2e f5				push af  
2b2f 3a 43 2b			ld a, (.dmark)  
2b32 32 62 ee			ld (debug_mark),a  
2b35 3a 44 2b			ld a, (.dmark+1)  
2b38 32 63 ee			ld (debug_mark+1),a  
2b3b 3a 45 2b			ld a, (.dmark+2)  
2b3e 32 64 ee			ld (debug_mark+2),a  
2b41 18 03			jr .pastdmark  
2b43 ..			.dmark: db "LS2"  
2b46 f1			.pastdmark: pop af  
2b47			endm  
# End of macro DMARK
2b47					CALLMONITOR 
2b47 cd 6f ee			call debug_vector  
2b4a				endm  
# End of macro CALLMONITOR
2b4a				endif 
2b4a			 
2b4a				; skip zero term and other uword defs to position right at the exec code 
2b4a 06 04			ld b, 4 
2b4c 80				add a,b 
2b4d			 
2b4d cd f5 0d			call addatohl 
2b50					; save this location 
2b50				 
2b50			.ulunotfound: 
2b50 cd 00 1b			call forth_push_numhl 
2b53						 
2b53				NEXTW 
2b53 cd 6c ee			call parse_vector 
2b56 c3 f0 1e			jp macro_next 
2b59				endm 
# End of macro NEXTW
2b59			.LIST: 
2b59			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2b59 5c				db WORD_SYS_CORE+72             
2b5a 5e 2d			dw .FORGET            
2b5c 05				db 4 + 1 
2b5d .. 00			db "LIST",0              
2b62				endm 
# End of macro CWHEAD
2b62			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2b62			; | | The quoted word must be in upper case. 
2b62			if DEBUG_FORTH_WORDS_KEY 
2b62				DMARK "LST" 
2b62 f5				push af  
2b63 3a 77 2b			ld a, (.dmark)  
2b66 32 62 ee			ld (debug_mark),a  
2b69 3a 78 2b			ld a, (.dmark+1)  
2b6c 32 63 ee			ld (debug_mark+1),a  
2b6f 3a 79 2b			ld a, (.dmark+2)  
2b72 32 64 ee			ld (debug_mark+2),a  
2b75 18 03			jr .pastdmark  
2b77 ..			.dmark: db "LST"  
2b7a f1			.pastdmark: pop af  
2b7b			endm  
# End of macro DMARK
2b7b				CALLMONITOR 
2b7b cd 6f ee			call debug_vector  
2b7e				endm  
# End of macro CALLMONITOR
2b7e			endif 
2b7e			 
2b7e				FORTH_DSP_VALUEHL 
2b7e cd 05 1d			call macro_dsp_valuehl 
2b81				endm 
# End of macro FORTH_DSP_VALUEHL
2b81			 
2b81 e5				push hl 
2b82				FORTH_DSP_POP 
2b82 cd bd 1d			call macro_forth_dsp_pop 
2b85				endm 
# End of macro FORTH_DSP_POP
2b85 c1				pop bc 
2b86			 
2b86			; Start format of scratch string 
2b86			 
2b86 21 b8 e2			ld hl, scratch 
2b89			 
2b89 3e 3a			ld a, ':' 
2b8b 77				ld (hl),a 
2b8c 23				inc hl 
2b8d 3e 20			ld a, ' ' 
2b8f 77				ld (hl), a 
2b90			 
2b90				; Get ptr to the word we need to look up 
2b90			 
2b90			;		FORTH_DSP_VALUEHL 
2b90				;v5 FORTH_DSP_VALUE 
2b90			; TODO type check 
2b90			;		inc hl    ; Skip type check  
2b90			;		push hl 
2b90			;		ex de, hl    ; put into DE 
2b90			 
2b90			 
2b90 21 53 65			ld hl, baseram 
2b93				;ld hl, baseusermem 
2b93			 
2b93 e5			push hl   ; sacreifical push 
2b94			 
2b94			.ldouscanm: 
2b94 e1			pop hl 
2b95			.ldouscan: 
2b95			if DEBUG_FORTH_WORDS 
2b95				DMARK "LSs" 
2b95 f5				push af  
2b96 3a aa 2b			ld a, (.dmark)  
2b99 32 62 ee			ld (debug_mark),a  
2b9c 3a ab 2b			ld a, (.dmark+1)  
2b9f 32 63 ee			ld (debug_mark+1),a  
2ba2 3a ac 2b			ld a, (.dmark+2)  
2ba5 32 64 ee			ld (debug_mark+2),a  
2ba8 18 03			jr .pastdmark  
2baa ..			.dmark: db "LSs"  
2bad f1			.pastdmark: pop af  
2bae			endm  
# End of macro DMARK
2bae				CALLMONITOR 
2bae cd 6f ee			call debug_vector  
2bb1				endm  
# End of macro CALLMONITOR
2bb1			endif 
2bb1			; skip dict stub 
2bb1 cd 2d 20			call forth_tok_next 
2bb4			 
2bb4			 
2bb4			; while we have words to look for 
2bb4			 
2bb4 7e			ld a, (hl)      
2bb5			if DEBUG_FORTH_WORDS 
2bb5				DMARK "LSk" 
2bb5 f5				push af  
2bb6 3a ca 2b			ld a, (.dmark)  
2bb9 32 62 ee			ld (debug_mark),a  
2bbc 3a cb 2b			ld a, (.dmark+1)  
2bbf 32 63 ee			ld (debug_mark+1),a  
2bc2 3a cc 2b			ld a, (.dmark+2)  
2bc5 32 64 ee			ld (debug_mark+2),a  
2bc8 18 03			jr .pastdmark  
2bca ..			.dmark: db "LSk"  
2bcd f1			.pastdmark: pop af  
2bce			endm  
# End of macro DMARK
2bce				CALLMONITOR 
2bce cd 6f ee			call debug_vector  
2bd1				endm  
# End of macro CALLMONITOR
2bd1			endif 
2bd1				;cp WORD_SYS_END 
2bd1				;jp z, .lunotfound 
2bd1			 
2bd1					; if we hit non uwords then gone too far 
2bd1 fe 01				cp WORD_SYS_UWORD 
2bd3 c2 11 2d				jp nz, .lunotfound 
2bd6			 
2bd6				if DEBUG_FORTH_WORDS 
2bd6					DMARK "LSu" 
2bd6 f5				push af  
2bd7 3a eb 2b			ld a, (.dmark)  
2bda 32 62 ee			ld (debug_mark),a  
2bdd 3a ec 2b			ld a, (.dmark+1)  
2be0 32 63 ee			ld (debug_mark+1),a  
2be3 3a ed 2b			ld a, (.dmark+2)  
2be6 32 64 ee			ld (debug_mark+2),a  
2be9 18 03			jr .pastdmark  
2beb ..			.dmark: db "LSu"  
2bee f1			.pastdmark: pop af  
2bef			endm  
# End of macro DMARK
2bef					CALLMONITOR 
2bef cd 6f ee			call debug_vector  
2bf2				endm  
# End of macro CALLMONITOR
2bf2				endif 
2bf2			 
2bf2					; found a uword but is it the one we want... 
2bf2			 
2bf2 c5					push bc     ; uword to find is on bc 
2bf3 d1					pop de 
2bf4			 
2bf4 e5					push hl  ; to save the ptr 
2bf5			 
2bf5					; skip opcode 
2bf5 23					inc hl  
2bf6					; skip next ptr 
2bf6 23					inc hl  
2bf7 23					inc hl 
2bf8					; skip len 
2bf8 23					inc hl 
2bf9			 
2bf9				if DEBUG_FORTH_WORDS 
2bf9					DMARK "LSc" 
2bf9 f5				push af  
2bfa 3a 0e 2c			ld a, (.dmark)  
2bfd 32 62 ee			ld (debug_mark),a  
2c00 3a 0f 2c			ld a, (.dmark+1)  
2c03 32 63 ee			ld (debug_mark+1),a  
2c06 3a 10 2c			ld a, (.dmark+2)  
2c09 32 64 ee			ld (debug_mark+2),a  
2c0c 18 03			jr .pastdmark  
2c0e ..			.dmark: db "LSc"  
2c11 f1			.pastdmark: pop af  
2c12			endm  
# End of macro DMARK
2c12					CALLMONITOR 
2c12 cd 6f ee			call debug_vector  
2c15				endm  
# End of macro CALLMONITOR
2c15				endif 
2c15			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2c15			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2c15			; Nope that has gone the other way. It needs to be exact not on first zero 
2c15			;		call strcmp 
2c15 c5					push bc 
2c16 cd a0 11				call StrictStrCmp 
2c19 c1					pop bc 
2c1a c2 94 2b				jp nz, .ldouscanm 
2c1d				 
2c1d			 
2c1d			 
2c1d					; we have a uword so push its name to the stack 
2c1d			 
2c1d			;	   	push hl  ; save so we can move to next dict block 
2c1d e1			pop hl 
2c1e			 
2c1e				if DEBUG_FORTH_WORDS 
2c1e					DMARK "LSm" 
2c1e f5				push af  
2c1f 3a 33 2c			ld a, (.dmark)  
2c22 32 62 ee			ld (debug_mark),a  
2c25 3a 34 2c			ld a, (.dmark+1)  
2c28 32 63 ee			ld (debug_mark+1),a  
2c2b 3a 35 2c			ld a, (.dmark+2)  
2c2e 32 64 ee			ld (debug_mark+2),a  
2c31 18 03			jr .pastdmark  
2c33 ..			.dmark: db "LSm"  
2c36 f1			.pastdmark: pop af  
2c37			endm  
# End of macro DMARK
2c37					CALLMONITOR 
2c37 cd 6f ee			call debug_vector  
2c3a				endm  
# End of macro CALLMONITOR
2c3a				endif 
2c3a			 
2c3a					; skip opcode 
2c3a 23					inc hl  
2c3b					; skip next ptr 
2c3b 23					inc hl  
2c3c 23					inc hl 
2c3d					; skip len 
2c3d 7e					ld a, (hl)   ; save length to add 
2c3e				if DEBUG_FORTH_WORDS 
2c3e					DMARK "LS2" 
2c3e f5				push af  
2c3f 3a 53 2c			ld a, (.dmark)  
2c42 32 62 ee			ld (debug_mark),a  
2c45 3a 54 2c			ld a, (.dmark+1)  
2c48 32 63 ee			ld (debug_mark+1),a  
2c4b 3a 55 2c			ld a, (.dmark+2)  
2c4e 32 64 ee			ld (debug_mark+2),a  
2c51 18 03			jr .pastdmark  
2c53 ..			.dmark: db "LS2"  
2c56 f1			.pastdmark: pop af  
2c57			endm  
# End of macro DMARK
2c57					CALLMONITOR 
2c57 cd 6f ee			call debug_vector  
2c5a				endm  
# End of macro CALLMONITOR
2c5a				endif 
2c5a			 
2c5a					; save this location 
2c5a				 
2c5a e5					push hl 
2c5b			 
2c5b 23					inc hl 
2c5c 11 ba e2				ld de, scratch+2 
2c5f 4f					ld c, a 
2c60 06 00				ld b, 0 
2c62			 
2c62				if DEBUG_FORTH_WORDS 
2c62					DMARK "LSn" 
2c62 f5				push af  
2c63 3a 77 2c			ld a, (.dmark)  
2c66 32 62 ee			ld (debug_mark),a  
2c69 3a 78 2c			ld a, (.dmark+1)  
2c6c 32 63 ee			ld (debug_mark+1),a  
2c6f 3a 79 2c			ld a, (.dmark+2)  
2c72 32 64 ee			ld (debug_mark+2),a  
2c75 18 03			jr .pastdmark  
2c77 ..			.dmark: db "LSn"  
2c7a f1			.pastdmark: pop af  
2c7b			endm  
# End of macro DMARK
2c7b					CALLMONITOR 
2c7b cd 6f ee			call debug_vector  
2c7e				endm  
# End of macro CALLMONITOR
2c7e				endif 
2c7e			 
2c7e					; copy uword name to scratch 
2c7e			 
2c7e			;		ldir 
2c7e			.licplw:	; copy uword name to scratch converting to lower case as we go 
2c7e ed a0				ldi 
2c80 1b					dec de 
2c81 1a					ld a, (de) 
2c82 cd 73 10				call to_lower 
2c85 12					ld (de),a 
2c86 13					inc de 
2c87 3e 00				ld a, 0 
2c89 b9					cp c 
2c8a 20 f2				jr nz, .licplw 
2c8c			 
2c8c			 
2c8c			 
2c8c 1b					dec de 
2c8d 3e 20				ld a, ' '    ; change null to space 
2c8f 12					ld (de), a 
2c90			 
2c90 13					inc de 
2c91			 
2c91 d5					push de 
2c92 c1					pop bc     ; move scratch pointer to end of word name and save it 
2c93			 
2c93 e1					pop hl 
2c94 7e					ld a, (hl) 
2c95					;inc hl 
2c95					; skip word string 
2c95 cd f5 0d				call addatohl 
2c98			 
2c98 23					inc hl 
2c99			 
2c99				if DEBUG_FORTH_WORDS 
2c99					DMARK "LS3" 
2c99 f5				push af  
2c9a 3a ae 2c			ld a, (.dmark)  
2c9d 32 62 ee			ld (debug_mark),a  
2ca0 3a af 2c			ld a, (.dmark+1)  
2ca3 32 63 ee			ld (debug_mark+1),a  
2ca6 3a b0 2c			ld a, (.dmark+2)  
2ca9 32 64 ee			ld (debug_mark+2),a  
2cac 18 03			jr .pastdmark  
2cae ..			.dmark: db "LS3"  
2cb1 f1			.pastdmark: pop af  
2cb2			endm  
# End of macro DMARK
2cb2					CALLMONITOR 
2cb2 cd 6f ee			call debug_vector  
2cb5				endm  
# End of macro CALLMONITOR
2cb5				endif 
2cb5					; should now be at the start of the machine code to setup the eval of the uword 
2cb5					; now locate the ptr to the string defintion 
2cb5			 
2cb5					; skip ld hl, 
2cb5					; then load the ptr 
2cb5			; TODO use get from hl ptr 
2cb5 23					inc hl 
2cb6 5e					ld e, (hl) 
2cb7 23					inc hl 
2cb8 56					ld d, (hl) 
2cb9 eb					ex de, hl 
2cba			 
2cba			 
2cba				if DEBUG_FORTH_WORDS 
2cba					DMARK "LSt" 
2cba f5				push af  
2cbb 3a cf 2c			ld a, (.dmark)  
2cbe 32 62 ee			ld (debug_mark),a  
2cc1 3a d0 2c			ld a, (.dmark+1)  
2cc4 32 63 ee			ld (debug_mark+1),a  
2cc7 3a d1 2c			ld a, (.dmark+2)  
2cca 32 64 ee			ld (debug_mark+2),a  
2ccd 18 03			jr .pastdmark  
2ccf ..			.dmark: db "LSt"  
2cd2 f1			.pastdmark: pop af  
2cd3			endm  
# End of macro DMARK
2cd3					CALLMONITOR 
2cd3 cd 6f ee			call debug_vector  
2cd6				endm  
# End of macro CALLMONITOR
2cd6				endif 
2cd6			 
2cd6			; cant push right now due to tokenised strings  
2cd6			 
2cd6			; get the destination of where to copy this definition to. 
2cd6			 
2cd6 c5					push bc 
2cd7 d1					pop de 
2cd8			 
2cd8 7e			.listl:         ld a,(hl) 
2cd9 fe 00				cp 0 
2cdb 28 09				jr z, .lreplsp     ; replace zero with space 
2cdd					;cp FORTH_END_BUFFER 
2cdd fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2cdf 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2ce1				 
2ce1					; just copy this char as is then 
2ce1			 
2ce1 12					ld (de), a 
2ce2			 
2ce2 23			.listnxt:	inc hl 
2ce3 13					inc de 
2ce4 18 f2				jr .listl 
2ce6			 
2ce6 3e 20		.lreplsp:	ld a,' ' 
2ce8 12					ld (de), a 
2ce9 18 f7				jr .listnxt 
2ceb			 
2ceb			; close up uword def 
2ceb			 
2ceb			.listdone: 
2ceb 12					ld (de), a 
2cec 13					inc de 
2ced 3e 00				ld a, 0 
2cef 12					ld (de), a 
2cf0			 
2cf0			; now have def so clean up and push to stack 
2cf0			 
2cf0 21 b8 e2				ld hl, scratch 
2cf3				if DEBUG_FORTH_WORDS 
2cf3					DMARK "Ltp" 
2cf3 f5				push af  
2cf4 3a 08 2d			ld a, (.dmark)  
2cf7 32 62 ee			ld (debug_mark),a  
2cfa 3a 09 2d			ld a, (.dmark+1)  
2cfd 32 63 ee			ld (debug_mark+1),a  
2d00 3a 0a 2d			ld a, (.dmark+2)  
2d03 32 64 ee			ld (debug_mark+2),a  
2d06 18 03			jr .pastdmark  
2d08 ..			.dmark: db "Ltp"  
2d0b f1			.pastdmark: pop af  
2d0c			endm  
# End of macro DMARK
2d0c					CALLMONITOR 
2d0c cd 6f ee			call debug_vector  
2d0f				endm  
# End of macro CALLMONITOR
2d0f				endif 
2d0f			 
2d0f 18 22			jr .listpush 
2d11			 
2d11			;.lnuword:	pop hl 
2d11			;		call forth_tok_next 
2d11			;		jp .ldouscan  
2d11			 
2d11			.lunotfound:		  
2d11			 
2d11				if DEBUG_FORTH_WORDS 
2d11					DMARK "LSn" 
2d11 f5				push af  
2d12 3a 26 2d			ld a, (.dmark)  
2d15 32 62 ee			ld (debug_mark),a  
2d18 3a 27 2d			ld a, (.dmark+1)  
2d1b 32 63 ee			ld (debug_mark+1),a  
2d1e 3a 28 2d			ld a, (.dmark+2)  
2d21 32 64 ee			ld (debug_mark+2),a  
2d24 18 03			jr .pastdmark  
2d26 ..			.dmark: db "LSn"  
2d29 f1			.pastdmark: pop af  
2d2a			endm  
# End of macro DMARK
2d2a					CALLMONITOR 
2d2a cd 6f ee			call debug_vector  
2d2d				endm  
# End of macro CALLMONITOR
2d2d				endif 
2d2d			 
2d2d					 
2d2d			;		FORTH_DSP_POP 
2d2d			;		ld hl, .luno 
2d2d			 
2d2d					NEXTW			 
2d2d cd 6c ee			call parse_vector 
2d30 c3 f0 1e			jp macro_next 
2d33				endm 
# End of macro NEXTW
2d33			 
2d33			.listpush: 
2d33				if DEBUG_FORTH_WORDS 
2d33					DMARK "LS>" 
2d33 f5				push af  
2d34 3a 48 2d			ld a, (.dmark)  
2d37 32 62 ee			ld (debug_mark),a  
2d3a 3a 49 2d			ld a, (.dmark+1)  
2d3d 32 63 ee			ld (debug_mark+1),a  
2d40 3a 4a 2d			ld a, (.dmark+2)  
2d43 32 64 ee			ld (debug_mark+2),a  
2d46 18 03			jr .pastdmark  
2d48 ..			.dmark: db "LS>"  
2d4b f1			.pastdmark: pop af  
2d4c			endm  
# End of macro DMARK
2d4c					CALLMONITOR 
2d4c cd 6f ee			call debug_vector  
2d4f				endm  
# End of macro CALLMONITOR
2d4f				endif 
2d4f cd 6e 1b				call forth_push_str 
2d52			 
2d52			 
2d52			 
2d52					NEXTW 
2d52 cd 6c ee			call parse_vector 
2d55 c3 f0 1e			jp macro_next 
2d58				endm 
# End of macro NEXTW
2d58			 
2d58			;.luno:    db "Word not found",0 
2d58			 
2d58			 
2d58			 
2d58			 
2d58			 
2d58			;		push hl   ; save pointer to start of uword def string 
2d58			; 
2d58			;; look for FORTH_EOL_LINE 
2d58			;		ld a, FORTH_END_BUFFER 
2d58			;		call strlent 
2d58			; 
2d58			;		inc hl		 ; space for coln def 
2d58			;		inc hl 
2d58			;		inc hl          ; space for terms 
2d58			;		inc hl 
2d58			; 
2d58			;		ld a, 20   ; TODO get actual length 
2d58			;		call addatohl    ; include a random amount of room for the uword name 
2d58			; 
2d58			;		 
2d58			;	if DEBUG_FORTH_WORDS 
2d58			;		DMARK "Lt1" 
2d58			;		CALLMONITOR 
2d58			;	endif 
2d58			;		 
2d58			; 
2d58			;; malloc space for the string because we cant change it 
2d58			; 
2d58			;		call malloc 
2d58			;	if DEBUG_FORTH_MALLOC_GUARD 
2d58			;		push af 
2d58			;		call ishlzero 
2d58			;		pop af 
2d58			;		 
2d58			;		call z,malloc_error 
2d58			;	endif 
2d58			; 
2d58			;	if DEBUG_FORTH_WORDS 
2d58			;		DMARK "Lt2" 
2d58			;		CALLMONITOR 
2d58			;	endif 
2d58			;		pop de 
2d58			;		push hl    ; push the malloc to release later 
2d58			;		push hl   ;  push back a copy for the later stack push 
2d58			;		 
2d58			;; copy the string swapping out the zero terms for spaces 
2d58			; 
2d58			;		; de has our source 
2d58			;		; hl has our dest 
2d58			; 
2d58			;; add the coln def 
2d58			; 
2d58			;		ld a, ':' 
2d58			;		ld (hl), a 
2d58			;		inc hl 
2d58			;		ld a, ' ' 
2d58			;		ld (hl), a 
2d58			;		inc hl 
2d58			; 
2d58			;; add the uname word 
2d58			;		push de   ; save our string for now 
2d58			;		ex de, hl 
2d58			; 
2d58			;		FORTH_DSP_VALUE 
2d58			;		;v5 FORTH_DSP_VALUE 
2d58			; 
2d58			;		inc hl   ; skip type but we know by now this is OK 
2d58			; 
2d58			;.luword:	ld a,(hl) 
2d58			;		cp 0 
2d58			;		jr z, .luword2 
2d58			;		ld (de), a 
2d58			;		inc de 
2d58			;		inc hl 
2d58			;		jr .luword 
2d58			; 
2d58			;.luword2:	ld a, ' ' 
2d58			;		ld (de), a 
2d58			;;		inc hl 
2d58			;;		inc de 
2d58			;;		ld (de), a 
2d58			;;		inc hl 
2d58			;		inc de 
2d58			; 
2d58			;		ex de, hl 
2d58			;		pop de 
2d58			;		 
2d58			;		 
2d58			; 
2d58			;; detoken that string and copy it 
2d58			; 
2d58			;	if DEBUG_FORTH_WORDS 
2d58			;		DMARK "Lt2" 
2d58			;		CALLMONITOR 
2d58			;	endif 
2d58			;.ldetok:	ld a, (de) 
2d58			;		cp FORTH_END_BUFFER 
2d58			;		jr z, .ldetokend 
2d58			;		; swap out any zero term for space 
2d58			;		cp 0 
2d58			;		jr nz, .ldetoknext 
2d58			;		ld a, ' ' 
2d58			; 
2d58			;	if DEBUG_FORTH_WORDS 
2d58			;		DMARK "LtS" 
2d58			;		CALLMONITOR 
2d58			;	endif 
2d58			;.ldetoknext:	ld (hl), a 
2d58			;		inc de 
2d58			;		inc hl 
2d58			;		jr .ldetok 
2d58			; 
2d58			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2d58			;		ld (hl), a  
2d58			; 
2d58			;; free that temp malloc 
2d58			; 
2d58			;		pop hl    
2d58			; 
2d58			;	if DEBUG_FORTH_WORDS 
2d58			;		DMARK "Lt4" 
2d58			;		CALLMONITOR 
2d58			;	endif 
2d58			;		call forth_apushstrhl 
2d58			; 
2d58			;		; get rid of temp malloc area 
2d58			; 
2d58			;		pop hl 
2d58			;		call free 
2d58			; 
2d58			;		jr .ludone 
2d58			; 
2d58			;.lnuword:	pop hl 
2d58			;		call forth_tok_next 
2d58			;		jp .ldouscan  
2d58			; 
2d58			;.ludone:		 pop hl 
2d58			; 
2d58					NEXTW 
2d58 cd 6c ee			call parse_vector 
2d5b c3 f0 1e			jp macro_next 
2d5e				endm 
# End of macro NEXTW
2d5e			 
2d5e			.FORGET: 
2d5e				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2d5e 5d				db WORD_SYS_CORE+73             
2d5f da 2d			dw .NOP            
2d61 07				db 6 + 1 
2d62 .. 00			db "FORGET",0              
2d69				endm 
# End of macro CWHEAD
2d69			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2d69			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2d69			; | |  
2d69			; | | e.g. "MORE" forget 
2d69					if DEBUG_FORTH_WORDS_KEY 
2d69						DMARK "FRG" 
2d69 f5				push af  
2d6a 3a 7e 2d			ld a, (.dmark)  
2d6d 32 62 ee			ld (debug_mark),a  
2d70 3a 7f 2d			ld a, (.dmark+1)  
2d73 32 63 ee			ld (debug_mark+1),a  
2d76 3a 80 2d			ld a, (.dmark+2)  
2d79 32 64 ee			ld (debug_mark+2),a  
2d7c 18 03			jr .pastdmark  
2d7e ..			.dmark: db "FRG"  
2d81 f1			.pastdmark: pop af  
2d82			endm  
# End of macro DMARK
2d82						CALLMONITOR 
2d82 cd 6f ee			call debug_vector  
2d85				endm  
# End of macro CALLMONITOR
2d85					endif 
2d85			 
2d85				; find uword 
2d85			        ; update start of word with "_" 
2d85				; replace uword with deleted flag 
2d85			 
2d85			 
2d85			;	if DEBUG_FORTH_WORDS 
2d85			;		DMARK "FOG" 
2d85			;		CALLMONITOR 
2d85			;	endif 
2d85			 
2d85			 
2d85					; Get ptr to the word we need to look up 
2d85			 
2d85					FORTH_DSP_VALUEHL 
2d85 cd 05 1d			call macro_dsp_valuehl 
2d88				endm 
# End of macro FORTH_DSP_VALUEHL
2d88					;v5 FORTH_DSP_VALUE 
2d88				; TODO type check 
2d88			;		inc hl    ; Skip type check  
2d88 e5					push hl 
2d89 c1					pop bc 
2d8a			;		ex de, hl    ; put into DE 
2d8a			 
2d8a			 
2d8a 21 53 65				ld hl, baseram 
2d8d					;ld hl, baseusermem 
2d8d			 
2d8d				; skip dict stub 
2d8d			;	call forth_tok_next 
2d8d e5			push hl   ; sacreifical push 
2d8e			 
2d8e			.fldouscanm: 
2d8e e1				pop hl 
2d8f			.fldouscan: 
2d8f			;	if DEBUG_FORTH_WORDS 
2d8f			;		DMARK "LSs" 
2d8f			;		CALLMONITOR 
2d8f			;	endif 
2d8f				; skip dict stub 
2d8f cd 2d 20				call forth_tok_next 
2d92			 
2d92			 
2d92			; while we have words to look for 
2d92			 
2d92 7e				ld a, (hl)      
2d93			;	if DEBUG_FORTH_WORDS 
2d93			;		DMARK "LSk" 
2d93			;		CALLMONITOR 
2d93			;	endif 
2d93 fe 00				cp WORD_SYS_END 
2d95 ca d1 2d				jp z, .flunotfound 
2d98 fe 01				cp WORD_SYS_UWORD 
2d9a c2 8f 2d				jp nz, .fldouscan 
2d9d			 
2d9d			;	if DEBUG_FORTH_WORDS 
2d9d			;		DMARK "LSu" 
2d9d			;		CALLMONITOR 
2d9d			;	endif 
2d9d			 
2d9d					; found a uword but is it the one we want... 
2d9d			 
2d9d c5					push bc     ; uword to find is on bc 
2d9e d1					pop de 
2d9f			 
2d9f e5					push hl  ; to save the ptr 
2da0			 
2da0					; skip opcode 
2da0 23					inc hl  
2da1					; skip next ptr 
2da1 23					inc hl  
2da2 23					inc hl 
2da3					; skip len 
2da3 23					inc hl 
2da4			 
2da4			;	if DEBUG_FORTH_WORDS 
2da4			;		DMARK "LSc" 
2da4			;		CALLMONITOR 
2da4			;	endif 
2da4 cd 93 11				call strcmp 
2da7 c2 8e 2d				jp nz, .fldouscanm 
2daa			; 
2daa			; 
2daa			;; while we have words to look for 
2daa			; 
2daa			;.fdouscan:	ld a, (hl)      
2daa			;	if DEBUG_FORTH_WORDS 
2daa			;		DMARK "LSs" 
2daa			;		CALLMONITOR 
2daa			;	endif 
2daa			;		cp WORD_SYS_END 
2daa			;		jp z, .fudone 
2daa			;		cp WORD_SYS_UWORD 
2daa			;		jp nz, .fnuword 
2daa			; 
2daa			;	if DEBUG_FORTH_WORDS 
2daa			;		DMARK "FGu" 
2daa			;		CALLMONITOR 
2daa			;	endif 
2daa			; 
2daa			;		; found a uword but is it the one we want... 
2daa			; 
2daa			; 
2daa			;	        pop de   ; get back the dsp name 
2daa			;		push de 
2daa			; 
2daa			;		push hl  ; to save the ptr 
2daa			; 
2daa			;		; skip opcode 
2daa			;		inc hl  
2daa			;		; skip next ptr 
2daa			;		inc hl  
2daa			;		inc hl 
2daa			;		; skip len 
2daa			;		inc hl 
2daa			; 
2daa			;	if DEBUG_FORTH_WORDS 
2daa			;		DMARK "FGc" 
2daa			;		CALLMONITOR 
2daa			;	endif 
2daa			;		call strcmp 
2daa			;		jp nz, .fnuword 
2daa			 
2daa			 
2daa e1			pop hl 
2dab			 
2dab				 
2dab				if DEBUG_FORTH_WORDS 
2dab					DMARK "FGm" 
2dab f5				push af  
2dac 3a c0 2d			ld a, (.dmark)  
2daf 32 62 ee			ld (debug_mark),a  
2db2 3a c1 2d			ld a, (.dmark+1)  
2db5 32 63 ee			ld (debug_mark+1),a  
2db8 3a c2 2d			ld a, (.dmark+2)  
2dbb 32 64 ee			ld (debug_mark+2),a  
2dbe 18 03			jr .pastdmark  
2dc0 ..			.dmark: db "FGm"  
2dc3 f1			.pastdmark: pop af  
2dc4			endm  
# End of macro DMARK
2dc4					CALLMONITOR 
2dc4 cd 6f ee			call debug_vector  
2dc7				endm  
# End of macro CALLMONITOR
2dc7				endif 
2dc7			 
2dc7			 
2dc7			 
2dc7					; we have a uword so push its name to the stack 
2dc7			 
2dc7			;	   	push hl  ; save so we can move to next dict block 
2dc7			;pop hl 
2dc7			 
2dc7					; update opcode to deleted 
2dc7 3e 03				ld a, WORD_SYS_DELETED 
2dc9 77					ld (hl), a 
2dca			 
2dca 23					inc hl  
2dcb					; skip next ptr 
2dcb 23					inc hl  
2dcc 23					inc hl 
2dcd					; skip len 
2dcd 23					inc hl 
2dce			 
2dce					; TODO change parser to skip deleted words but for now mark it out 
2dce 3e 5f				ld a, "_" 
2dd0 77					ld  (hl),a 
2dd1			 
2dd1			;		jr .fudone 
2dd1			; 
2dd1			;.fnuword:	pop hl 
2dd1			;		call forth_tok_next 
2dd1			;		jp .fdouscan  
2dd1			 
2dd1			.flunotfound:		  
2dd1			 
2dd1			 
2dd1					 
2dd1					FORTH_DSP_POP 
2dd1 cd bd 1d			call macro_forth_dsp_pop 
2dd4				endm 
# End of macro FORTH_DSP_POP
2dd4			;		ld hl, .luno 
2dd4			;.fudone:		 pop hl 
2dd4					NEXTW 
2dd4 cd 6c ee			call parse_vector 
2dd7 c3 f0 1e			jp macro_next 
2dda				endm 
# End of macro NEXTW
2dda			.NOP: 
2dda				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2dda 61				db WORD_SYS_CORE+77             
2ddb 04 2e			dw .COMO            
2ddd 04				db 3 + 1 
2dde .. 00			db "NOP",0              
2de2				endm 
# End of macro CWHEAD
2de2			; | NOP (  --  ) Do nothing | DONE 
2de2					if DEBUG_FORTH_WORDS_KEY 
2de2						DMARK "NOP" 
2de2 f5				push af  
2de3 3a f7 2d			ld a, (.dmark)  
2de6 32 62 ee			ld (debug_mark),a  
2de9 3a f8 2d			ld a, (.dmark+1)  
2dec 32 63 ee			ld (debug_mark+1),a  
2def 3a f9 2d			ld a, (.dmark+2)  
2df2 32 64 ee			ld (debug_mark+2),a  
2df5 18 03			jr .pastdmark  
2df7 ..			.dmark: db "NOP"  
2dfa f1			.pastdmark: pop af  
2dfb			endm  
# End of macro DMARK
2dfb						CALLMONITOR 
2dfb cd 6f ee			call debug_vector  
2dfe				endm  
# End of macro CALLMONITOR
2dfe					endif 
2dfe				       NEXTW 
2dfe cd 6c ee			call parse_vector 
2e01 c3 f0 1e			jp macro_next 
2e04				endm 
# End of macro NEXTW
2e04			.COMO: 
2e04				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2e04 6e				db WORD_SYS_CORE+90             
2e05 59 2e			dw .COMC            
2e07 02				db 1 + 1 
2e08 .. 00			db "(",0              
2e0a				endm 
# End of macro CWHEAD
2e0a			; | ( ( -- )  Start of comment | DONE 
2e0a			 
2e0a			 
2e0a 2a b9 e5				ld hl, ( os_tok_ptr) 
2e0d 11 51 2e			ld de, .closepar 
2e10					 
2e10					if DEBUG_FORTH_WORDS 
2e10						DMARK ").." 
2e10 f5				push af  
2e11 3a 25 2e			ld a, (.dmark)  
2e14 32 62 ee			ld (debug_mark),a  
2e17 3a 26 2e			ld a, (.dmark+1)  
2e1a 32 63 ee			ld (debug_mark+1),a  
2e1d 3a 27 2e			ld a, (.dmark+2)  
2e20 32 64 ee			ld (debug_mark+2),a  
2e23 18 03			jr .pastdmark  
2e25 ..			.dmark: db ").."  
2e28 f1			.pastdmark: pop af  
2e29			endm  
# End of macro DMARK
2e29						CALLMONITOR 
2e29 cd 6f ee			call debug_vector  
2e2c				endm  
# End of macro CALLMONITOR
2e2c					endif 
2e2c cd f7 1f			call findnexttok  
2e2f			 
2e2f					if DEBUG_FORTH_WORDS 
2e2f						DMARK "IF5" 
2e2f f5				push af  
2e30 3a 44 2e			ld a, (.dmark)  
2e33 32 62 ee			ld (debug_mark),a  
2e36 3a 45 2e			ld a, (.dmark+1)  
2e39 32 63 ee			ld (debug_mark+1),a  
2e3c 3a 46 2e			ld a, (.dmark+2)  
2e3f 32 64 ee			ld (debug_mark+2),a  
2e42 18 03			jr .pastdmark  
2e44 ..			.dmark: db "IF5"  
2e47 f1			.pastdmark: pop af  
2e48			endm  
# End of macro DMARK
2e48						CALLMONITOR 
2e48 cd 6f ee			call debug_vector  
2e4b				endm  
# End of macro CALLMONITOR
2e4b					endif 
2e4b				; replace below with ) exec using tok_ptr 
2e4b 22 b9 e5			ld (os_tok_ptr), hl 
2e4e c3 79 1f			jp exec1 
2e51			 
2e51 .. 00			.closepar:   db ")",0 
2e53			 
2e53				       NEXTW 
2e53 cd 6c ee			call parse_vector 
2e56 c3 f0 1e			jp macro_next 
2e59				endm 
# End of macro NEXTW
2e59			.COMC: 
2e59				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2e59 6f				db WORD_SYS_CORE+91             
2e5a 65 2e			dw .SCRATCH            
2e5c 02				db 1 + 1 
2e5d .. 00			db ")",0              
2e5f				endm 
# End of macro CWHEAD
2e5f			; | ) ( -- )  End of comment |  DONE  
2e5f				       NEXTW 
2e5f cd 6c ee			call parse_vector 
2e62 c3 f0 1e			jp macro_next 
2e65				endm 
# End of macro NEXTW
2e65			 
2e65			.SCRATCH: 
2e65				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2e65 6f				db WORD_SYS_CORE+91             
2e66 a3 2e			dw .INC            
2e68 08				db 7 + 1 
2e69 .. 00			db "SCRATCH",0              
2e71				endm 
# End of macro CWHEAD
2e71			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2e71			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2e71			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2e71			; | |  
2e71			; | | e.g.    : score $00 scratch ; 
2e71			; | |  
2e71			; | | $00 score ! 
2e71			; | | $01 score +! 
2e71			; | |  
2e71			; | | e.g.   : varword $0a scratch ;  
2e71			; | | 
2e71			; | | $8000 varword ! 
2e71					if DEBUG_FORTH_WORDS_KEY 
2e71						DMARK "SCR" 
2e71 f5				push af  
2e72 3a 86 2e			ld a, (.dmark)  
2e75 32 62 ee			ld (debug_mark),a  
2e78 3a 87 2e			ld a, (.dmark+1)  
2e7b 32 63 ee			ld (debug_mark+1),a  
2e7e 3a 88 2e			ld a, (.dmark+2)  
2e81 32 64 ee			ld (debug_mark+2),a  
2e84 18 03			jr .pastdmark  
2e86 ..			.dmark: db "SCR"  
2e89 f1			.pastdmark: pop af  
2e8a			endm  
# End of macro DMARK
2e8a						CALLMONITOR 
2e8a cd 6f ee			call debug_vector  
2e8d				endm  
# End of macro CALLMONITOR
2e8d					endif 
2e8d			 
2e8d					FORTH_DSP_VALUEHL 
2e8d cd 05 1d			call macro_dsp_valuehl 
2e90				endm 
# End of macro FORTH_DSP_VALUEHL
2e90				 
2e90					FORTH_DSP_POP 
2e90 cd bd 1d			call macro_forth_dsp_pop 
2e93				endm 
# End of macro FORTH_DSP_POP
2e93			 
2e93 7d					ld a, l 
2e94 21 dd e7				ld hl, os_var_array 
2e97 cd f5 0d				call addatohl 
2e9a			 
2e9a cd 00 1b				call forth_push_numhl 
2e9d			 
2e9d				       NEXTW 
2e9d cd 6c ee			call parse_vector 
2ea0 c3 f0 1e			jp macro_next 
2ea3				endm 
# End of macro NEXTW
2ea3			 
2ea3			.INC: 
2ea3				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2ea3 6f				db WORD_SYS_CORE+91             
2ea4 fc 2e			dw .DEC            
2ea6 03				db 2 + 1 
2ea7 .. 00			db "+!",0              
2eaa				endm 
# End of macro CWHEAD
2eaa			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2eaa					if DEBUG_FORTH_WORDS_KEY 
2eaa						DMARK "+s_" 
2eaa f5				push af  
2eab 3a bf 2e			ld a, (.dmark)  
2eae 32 62 ee			ld (debug_mark),a  
2eb1 3a c0 2e			ld a, (.dmark+1)  
2eb4 32 63 ee			ld (debug_mark+1),a  
2eb7 3a c1 2e			ld a, (.dmark+2)  
2eba 32 64 ee			ld (debug_mark+2),a  
2ebd 18 03			jr .pastdmark  
2ebf ..			.dmark: db "+s_"  
2ec2 f1			.pastdmark: pop af  
2ec3			endm  
# End of macro DMARK
2ec3						CALLMONITOR 
2ec3 cd 6f ee			call debug_vector  
2ec6				endm  
# End of macro CALLMONITOR
2ec6					endif 
2ec6			 
2ec6					FORTH_DSP_VALUEHL 
2ec6 cd 05 1d			call macro_dsp_valuehl 
2ec9				endm 
# End of macro FORTH_DSP_VALUEHL
2ec9			 
2ec9 e5					push hl   ; save address 
2eca			 
2eca					FORTH_DSP_POP 
2eca cd bd 1d			call macro_forth_dsp_pop 
2ecd				endm 
# End of macro FORTH_DSP_POP
2ecd			 
2ecd					FORTH_DSP_VALUEHL 
2ecd cd 05 1d			call macro_dsp_valuehl 
2ed0				endm 
# End of macro FORTH_DSP_VALUEHL
2ed0			 
2ed0 e5					push hl 
2ed1					FORTH_DSP_POP 
2ed1 cd bd 1d			call macro_forth_dsp_pop 
2ed4				endm 
# End of macro FORTH_DSP_POP
2ed4 e1					pop hl 
2ed5			 
2ed5					; hl contains value to add to byte at a 
2ed5				 
2ed5 eb					ex de, hl 
2ed6			 
2ed6 e1					pop hl 
2ed7			 
2ed7					if DEBUG_FORTH_WORDS 
2ed7						DMARK "INC" 
2ed7 f5				push af  
2ed8 3a ec 2e			ld a, (.dmark)  
2edb 32 62 ee			ld (debug_mark),a  
2ede 3a ed 2e			ld a, (.dmark+1)  
2ee1 32 63 ee			ld (debug_mark+1),a  
2ee4 3a ee 2e			ld a, (.dmark+2)  
2ee7 32 64 ee			ld (debug_mark+2),a  
2eea 18 03			jr .pastdmark  
2eec ..			.dmark: db "INC"  
2eef f1			.pastdmark: pop af  
2ef0			endm  
# End of macro DMARK
2ef0						CALLMONITOR 
2ef0 cd 6f ee			call debug_vector  
2ef3				endm  
# End of macro CALLMONITOR
2ef3					endif 
2ef3			 
2ef3 7e					ld a,(hl) 
2ef4 83					add e 
2ef5 77					ld (hl),a 
2ef6			 
2ef6			 
2ef6			 
2ef6				       NEXTW 
2ef6 cd 6c ee			call parse_vector 
2ef9 c3 f0 1e			jp macro_next 
2efc				endm 
# End of macro NEXTW
2efc			 
2efc			.DEC: 
2efc				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2efc 6f				db WORD_SYS_CORE+91             
2efd 53 2f			dw .INC2            
2eff 03				db 2 + 1 
2f00 .. 00			db "-!",0              
2f03				endm 
# End of macro CWHEAD
2f03			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2f03					if DEBUG_FORTH_WORDS_KEY 
2f03						DMARK "-s_" 
2f03 f5				push af  
2f04 3a 18 2f			ld a, (.dmark)  
2f07 32 62 ee			ld (debug_mark),a  
2f0a 3a 19 2f			ld a, (.dmark+1)  
2f0d 32 63 ee			ld (debug_mark+1),a  
2f10 3a 1a 2f			ld a, (.dmark+2)  
2f13 32 64 ee			ld (debug_mark+2),a  
2f16 18 03			jr .pastdmark  
2f18 ..			.dmark: db "-s_"  
2f1b f1			.pastdmark: pop af  
2f1c			endm  
# End of macro DMARK
2f1c						CALLMONITOR 
2f1c cd 6f ee			call debug_vector  
2f1f				endm  
# End of macro CALLMONITOR
2f1f					endif 
2f1f			 
2f1f					FORTH_DSP_VALUEHL 
2f1f cd 05 1d			call macro_dsp_valuehl 
2f22				endm 
# End of macro FORTH_DSP_VALUEHL
2f22			 
2f22 e5					push hl   ; save address 
2f23			 
2f23					FORTH_DSP_POP 
2f23 cd bd 1d			call macro_forth_dsp_pop 
2f26				endm 
# End of macro FORTH_DSP_POP
2f26			 
2f26					FORTH_DSP_VALUEHL 
2f26 cd 05 1d			call macro_dsp_valuehl 
2f29				endm 
# End of macro FORTH_DSP_VALUEHL
2f29			 
2f29					; hl contains value to add to byte at a 
2f29				 
2f29 eb					ex de, hl 
2f2a			 
2f2a e1					pop hl 
2f2b			 
2f2b					if DEBUG_FORTH_WORDS 
2f2b						DMARK "DEC" 
2f2b f5				push af  
2f2c 3a 40 2f			ld a, (.dmark)  
2f2f 32 62 ee			ld (debug_mark),a  
2f32 3a 41 2f			ld a, (.dmark+1)  
2f35 32 63 ee			ld (debug_mark+1),a  
2f38 3a 42 2f			ld a, (.dmark+2)  
2f3b 32 64 ee			ld (debug_mark+2),a  
2f3e 18 03			jr .pastdmark  
2f40 ..			.dmark: db "DEC"  
2f43 f1			.pastdmark: pop af  
2f44			endm  
# End of macro DMARK
2f44						CALLMONITOR 
2f44 cd 6f ee			call debug_vector  
2f47				endm  
# End of macro CALLMONITOR
2f47					endif 
2f47			 
2f47 7e					ld a,(hl) 
2f48 93					sub e 
2f49 77					ld (hl),a 
2f4a			 
2f4a			 
2f4a					FORTH_DSP_POP 
2f4a cd bd 1d			call macro_forth_dsp_pop 
2f4d				endm 
# End of macro FORTH_DSP_POP
2f4d			 
2f4d				       NEXTW 
2f4d cd 6c ee			call parse_vector 
2f50 c3 f0 1e			jp macro_next 
2f53				endm 
# End of macro NEXTW
2f53			 
2f53			.INC2: 
2f53				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2f53 6f				db WORD_SYS_CORE+91             
2f54 03 30			dw .DEC2            
2f56 04				db 3 + 1 
2f57 .. 00			db "+2!",0              
2f5b				endm 
# End of macro CWHEAD
2f5b			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2f5b			 
2f5b					if DEBUG_FORTH_WORDS_KEY 
2f5b						DMARK "+2s" 
2f5b f5				push af  
2f5c 3a 70 2f			ld a, (.dmark)  
2f5f 32 62 ee			ld (debug_mark),a  
2f62 3a 71 2f			ld a, (.dmark+1)  
2f65 32 63 ee			ld (debug_mark+1),a  
2f68 3a 72 2f			ld a, (.dmark+2)  
2f6b 32 64 ee			ld (debug_mark+2),a  
2f6e 18 03			jr .pastdmark  
2f70 ..			.dmark: db "+2s"  
2f73 f1			.pastdmark: pop af  
2f74			endm  
# End of macro DMARK
2f74						CALLMONITOR 
2f74 cd 6f ee			call debug_vector  
2f77				endm  
# End of macro CALLMONITOR
2f77					endif 
2f77			 
2f77					; Address 
2f77			 
2f77					FORTH_DSP_VALUEHL 
2f77 cd 05 1d			call macro_dsp_valuehl 
2f7a				endm 
# End of macro FORTH_DSP_VALUEHL
2f7a			 
2f7a e5					push hl    ; save address 
2f7b			 
2f7b					; load content into de 
2f7b			 
2f7b 5e					ld e,(hl) 
2f7c 23					inc hl 
2f7d 56					ld d, (hl) 
2f7e			 
2f7e					if DEBUG_FORTH_WORDS 
2f7e						DMARK "+2a" 
2f7e f5				push af  
2f7f 3a 93 2f			ld a, (.dmark)  
2f82 32 62 ee			ld (debug_mark),a  
2f85 3a 94 2f			ld a, (.dmark+1)  
2f88 32 63 ee			ld (debug_mark+1),a  
2f8b 3a 95 2f			ld a, (.dmark+2)  
2f8e 32 64 ee			ld (debug_mark+2),a  
2f91 18 03			jr .pastdmark  
2f93 ..			.dmark: db "+2a"  
2f96 f1			.pastdmark: pop af  
2f97			endm  
# End of macro DMARK
2f97						CALLMONITOR 
2f97 cd 6f ee			call debug_vector  
2f9a				endm  
# End of macro CALLMONITOR
2f9a					endif 
2f9a			 
2f9a					FORTH_DSP_POP 
2f9a cd bd 1d			call macro_forth_dsp_pop 
2f9d				endm 
# End of macro FORTH_DSP_POP
2f9d			 
2f9d					; Get value to add 
2f9d			 
2f9d					FORTH_DSP_VALUE 
2f9d cd ee 1c			call macro_forth_dsp_value 
2fa0				endm 
# End of macro FORTH_DSP_VALUE
2fa0			 
2fa0					if DEBUG_FORTH_WORDS 
2fa0						DMARK "+2v" 
2fa0 f5				push af  
2fa1 3a b5 2f			ld a, (.dmark)  
2fa4 32 62 ee			ld (debug_mark),a  
2fa7 3a b6 2f			ld a, (.dmark+1)  
2faa 32 63 ee			ld (debug_mark+1),a  
2fad 3a b7 2f			ld a, (.dmark+2)  
2fb0 32 64 ee			ld (debug_mark+2),a  
2fb3 18 03			jr .pastdmark  
2fb5 ..			.dmark: db "+2v"  
2fb8 f1			.pastdmark: pop af  
2fb9			endm  
# End of macro DMARK
2fb9						CALLMONITOR 
2fb9 cd 6f ee			call debug_vector  
2fbc				endm  
# End of macro CALLMONITOR
2fbc					endif 
2fbc			 
2fbc 19					add hl, de 
2fbd			 
2fbd					if DEBUG_FORTH_WORDS 
2fbd						DMARK "+2+" 
2fbd f5				push af  
2fbe 3a d2 2f			ld a, (.dmark)  
2fc1 32 62 ee			ld (debug_mark),a  
2fc4 3a d3 2f			ld a, (.dmark+1)  
2fc7 32 63 ee			ld (debug_mark+1),a  
2fca 3a d4 2f			ld a, (.dmark+2)  
2fcd 32 64 ee			ld (debug_mark+2),a  
2fd0 18 03			jr .pastdmark  
2fd2 ..			.dmark: db "+2+"  
2fd5 f1			.pastdmark: pop af  
2fd6			endm  
# End of macro DMARK
2fd6						CALLMONITOR 
2fd6 cd 6f ee			call debug_vector  
2fd9				endm  
# End of macro CALLMONITOR
2fd9					endif 
2fd9			 
2fd9					; move result to de 
2fd9			 
2fd9 eb					ex de, hl 
2fda			 
2fda					; Address 
2fda			 
2fda e1					pop hl 
2fdb			 
2fdb					; save it back 
2fdb			 
2fdb 73					ld (hl), e 
2fdc 23					inc hl 
2fdd 72					ld (hl), d 
2fde			 
2fde					if DEBUG_FORTH_WORDS 
2fde						DMARK "+2e" 
2fde f5				push af  
2fdf 3a f3 2f			ld a, (.dmark)  
2fe2 32 62 ee			ld (debug_mark),a  
2fe5 3a f4 2f			ld a, (.dmark+1)  
2fe8 32 63 ee			ld (debug_mark+1),a  
2feb 3a f5 2f			ld a, (.dmark+2)  
2fee 32 64 ee			ld (debug_mark+2),a  
2ff1 18 03			jr .pastdmark  
2ff3 ..			.dmark: db "+2e"  
2ff6 f1			.pastdmark: pop af  
2ff7			endm  
# End of macro DMARK
2ff7						CALLMONITOR 
2ff7 cd 6f ee			call debug_vector  
2ffa				endm  
# End of macro CALLMONITOR
2ffa					endif 
2ffa			 
2ffa			 
2ffa			 
2ffa					FORTH_DSP_POP 
2ffa cd bd 1d			call macro_forth_dsp_pop 
2ffd				endm 
# End of macro FORTH_DSP_POP
2ffd			 
2ffd			 
2ffd				       NEXTW 
2ffd cd 6c ee			call parse_vector 
3000 c3 f0 1e			jp macro_next 
3003				endm 
# End of macro NEXTW
3003			 
3003			.DEC2: 
3003				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
3003 6f				db WORD_SYS_CORE+91             
3004 b5 30			dw .GET2            
3006 04				db 3 + 1 
3007 .. 00			db "-2!",0              
300b				endm 
# End of macro CWHEAD
300b			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
300b			 
300b			 
300b					if DEBUG_FORTH_WORDS_KEY 
300b						DMARK "-2s" 
300b f5				push af  
300c 3a 20 30			ld a, (.dmark)  
300f 32 62 ee			ld (debug_mark),a  
3012 3a 21 30			ld a, (.dmark+1)  
3015 32 63 ee			ld (debug_mark+1),a  
3018 3a 22 30			ld a, (.dmark+2)  
301b 32 64 ee			ld (debug_mark+2),a  
301e 18 03			jr .pastdmark  
3020 ..			.dmark: db "-2s"  
3023 f1			.pastdmark: pop af  
3024			endm  
# End of macro DMARK
3024						CALLMONITOR 
3024 cd 6f ee			call debug_vector  
3027				endm  
# End of macro CALLMONITOR
3027					endif 
3027			 
3027					; Address 
3027			 
3027					FORTH_DSP_VALUEHL 
3027 cd 05 1d			call macro_dsp_valuehl 
302a				endm 
# End of macro FORTH_DSP_VALUEHL
302a			 
302a e5					push hl    ; save address 
302b			 
302b					; load content into de 
302b			 
302b 5e					ld e,(hl) 
302c 23					inc hl 
302d 56					ld d, (hl) 
302e			 
302e					if DEBUG_FORTH_WORDS 
302e						DMARK "-2a" 
302e f5				push af  
302f 3a 43 30			ld a, (.dmark)  
3032 32 62 ee			ld (debug_mark),a  
3035 3a 44 30			ld a, (.dmark+1)  
3038 32 63 ee			ld (debug_mark+1),a  
303b 3a 45 30			ld a, (.dmark+2)  
303e 32 64 ee			ld (debug_mark+2),a  
3041 18 03			jr .pastdmark  
3043 ..			.dmark: db "-2a"  
3046 f1			.pastdmark: pop af  
3047			endm  
# End of macro DMARK
3047						CALLMONITOR 
3047 cd 6f ee			call debug_vector  
304a				endm  
# End of macro CALLMONITOR
304a					endif 
304a			 
304a					FORTH_DSP_POP 
304a cd bd 1d			call macro_forth_dsp_pop 
304d				endm 
# End of macro FORTH_DSP_POP
304d			 
304d					; Get value to remove 
304d			 
304d					FORTH_DSP_VALUE 
304d cd ee 1c			call macro_forth_dsp_value 
3050				endm 
# End of macro FORTH_DSP_VALUE
3050			 
3050					if DEBUG_FORTH_WORDS 
3050						DMARK "-2v" 
3050 f5				push af  
3051 3a 65 30			ld a, (.dmark)  
3054 32 62 ee			ld (debug_mark),a  
3057 3a 66 30			ld a, (.dmark+1)  
305a 32 63 ee			ld (debug_mark+1),a  
305d 3a 67 30			ld a, (.dmark+2)  
3060 32 64 ee			ld (debug_mark+2),a  
3063 18 03			jr .pastdmark  
3065 ..			.dmark: db "-2v"  
3068 f1			.pastdmark: pop af  
3069			endm  
# End of macro DMARK
3069						CALLMONITOR 
3069 cd 6f ee			call debug_vector  
306c				endm  
# End of macro CALLMONITOR
306c					endif 
306c			 
306c eb					ex de, hl 
306d ed 52				sbc hl, de 
306f			 
306f					if DEBUG_FORTH_WORDS 
306f						DMARK "-2d" 
306f f5				push af  
3070 3a 84 30			ld a, (.dmark)  
3073 32 62 ee			ld (debug_mark),a  
3076 3a 85 30			ld a, (.dmark+1)  
3079 32 63 ee			ld (debug_mark+1),a  
307c 3a 86 30			ld a, (.dmark+2)  
307f 32 64 ee			ld (debug_mark+2),a  
3082 18 03			jr .pastdmark  
3084 ..			.dmark: db "-2d"  
3087 f1			.pastdmark: pop af  
3088			endm  
# End of macro DMARK
3088						CALLMONITOR 
3088 cd 6f ee			call debug_vector  
308b				endm  
# End of macro CALLMONITOR
308b					endif 
308b			 
308b					; move result to de 
308b			 
308b eb					ex de, hl 
308c			 
308c					; Address 
308c			 
308c e1					pop hl 
308d			 
308d					; save it back 
308d			 
308d 73					ld (hl), e 
308e 23					inc hl 
308f 72					ld (hl), d 
3090			 
3090					if DEBUG_FORTH_WORDS 
3090						DMARK "-2e" 
3090 f5				push af  
3091 3a a5 30			ld a, (.dmark)  
3094 32 62 ee			ld (debug_mark),a  
3097 3a a6 30			ld a, (.dmark+1)  
309a 32 63 ee			ld (debug_mark+1),a  
309d 3a a7 30			ld a, (.dmark+2)  
30a0 32 64 ee			ld (debug_mark+2),a  
30a3 18 03			jr .pastdmark  
30a5 ..			.dmark: db "-2e"  
30a8 f1			.pastdmark: pop af  
30a9			endm  
# End of macro DMARK
30a9						CALLMONITOR 
30a9 cd 6f ee			call debug_vector  
30ac				endm  
# End of macro CALLMONITOR
30ac					endif 
30ac			 
30ac			 
30ac					FORTH_DSP_POP 
30ac cd bd 1d			call macro_forth_dsp_pop 
30af				endm 
# End of macro FORTH_DSP_POP
30af			 
30af			 
30af			 
30af				       NEXTW 
30af cd 6c ee			call parse_vector 
30b2 c3 f0 1e			jp macro_next 
30b5				endm 
# End of macro NEXTW
30b5			.GET2: 
30b5				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
30b5 6f				db WORD_SYS_CORE+91             
30b6 ed 30			dw .BANG2            
30b8 03				db 2 + 1 
30b9 .. 00			db "2@",0              
30bc				endm 
# End of macro CWHEAD
30bc			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
30bc					if DEBUG_FORTH_WORDS_KEY 
30bc						DMARK "2A_" 
30bc f5				push af  
30bd 3a d1 30			ld a, (.dmark)  
30c0 32 62 ee			ld (debug_mark),a  
30c3 3a d2 30			ld a, (.dmark+1)  
30c6 32 63 ee			ld (debug_mark+1),a  
30c9 3a d3 30			ld a, (.dmark+2)  
30cc 32 64 ee			ld (debug_mark+2),a  
30cf 18 03			jr .pastdmark  
30d1 ..			.dmark: db "2A_"  
30d4 f1			.pastdmark: pop af  
30d5			endm  
# End of macro DMARK
30d5						CALLMONITOR 
30d5 cd 6f ee			call debug_vector  
30d8				endm  
# End of macro CALLMONITOR
30d8					endif 
30d8			 
30d8					FORTH_DSP_VALUEHL 
30d8 cd 05 1d			call macro_dsp_valuehl 
30db				endm 
# End of macro FORTH_DSP_VALUEHL
30db			 
30db e5					push hl   ; save address 
30dc			 
30dc					FORTH_DSP_POP 
30dc cd bd 1d			call macro_forth_dsp_pop 
30df				endm 
# End of macro FORTH_DSP_POP
30df			 
30df e1					pop hl 
30e0			 
30e0 5e					ld e, (hl) 
30e1 23					inc hl 
30e2 56					ld d, (hl) 
30e3			 
30e3 eb					ex de, hl 
30e4			 
30e4 cd 00 1b				call forth_push_numhl 
30e7			 
30e7				       NEXTW 
30e7 cd 6c ee			call parse_vector 
30ea c3 f0 1e			jp macro_next 
30ed				endm 
# End of macro NEXTW
30ed			.BANG2: 
30ed				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
30ed 6f				db WORD_SYS_CORE+91             
30ee 28 31			dw .CONFIG            
30f0 03				db 2 + 1 
30f1 .. 00			db "2!",0              
30f4				endm 
# End of macro CWHEAD
30f4			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
30f4					if DEBUG_FORTH_WORDS_KEY 
30f4						DMARK "2S_" 
30f4 f5				push af  
30f5 3a 09 31			ld a, (.dmark)  
30f8 32 62 ee			ld (debug_mark),a  
30fb 3a 0a 31			ld a, (.dmark+1)  
30fe 32 63 ee			ld (debug_mark+1),a  
3101 3a 0b 31			ld a, (.dmark+2)  
3104 32 64 ee			ld (debug_mark+2),a  
3107 18 03			jr .pastdmark  
3109 ..			.dmark: db "2S_"  
310c f1			.pastdmark: pop af  
310d			endm  
# End of macro DMARK
310d						CALLMONITOR 
310d cd 6f ee			call debug_vector  
3110				endm  
# End of macro CALLMONITOR
3110					endif 
3110			 
3110					FORTH_DSP_VALUEHL 
3110 cd 05 1d			call macro_dsp_valuehl 
3113				endm 
# End of macro FORTH_DSP_VALUEHL
3113			 
3113 e5					push hl   ; save address 
3114			 
3114			 
3114					FORTH_DSP_POP 
3114 cd bd 1d			call macro_forth_dsp_pop 
3117				endm 
# End of macro FORTH_DSP_POP
3117			 
3117					 
3117					FORTH_DSP_VALUEHL 
3117 cd 05 1d			call macro_dsp_valuehl 
311a				endm 
# End of macro FORTH_DSP_VALUEHL
311a			 
311a					FORTH_DSP_POP 
311a cd bd 1d			call macro_forth_dsp_pop 
311d				endm 
# End of macro FORTH_DSP_POP
311d			 
311d eb					ex de, hl    ; value now in de 
311e			 
311e e1					pop hl 
311f			 
311f 73					ld (hl), e 
3120			 
3120 23					inc hl 
3121			 
3121 72					ld (hl), d 
3122			 
3122			 
3122				       NEXTW 
3122 cd 6c ee			call parse_vector 
3125 c3 f0 1e			jp macro_next 
3128				endm 
# End of macro NEXTW
3128			.CONFIG: 
3128				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
3128 6f				db WORD_SYS_CORE+91             
3129 3c 31			dw .ADTOS            
312b 07				db 6 + 1 
312c .. 00			db "CONFIG",0              
3133				endm 
# End of macro CWHEAD
3133			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3133			 
3133 cd 69 13				call config 
3136					NEXTW 
3136 cd 6c ee			call parse_vector 
3139 c3 f0 1e			jp macro_next 
313c				endm 
# End of macro NEXTW
313c			 
313c			.ADTOS: 
313c				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
313c 6f				db WORD_SYS_CORE+91             
313d 55 31			dw .SBTOS            
313f 03				db 2 + 1 
3140 .. 00			db "1+",0              
3143				endm 
# End of macro CWHEAD
3143			; | 1+ ( u -- u )  Increment value on TOS | DONE 
3143			 
3143					FORTH_DSP_VALUEHL 
3143 cd 05 1d			call macro_dsp_valuehl 
3146				endm 
# End of macro FORTH_DSP_VALUEHL
3146 e5					push hl 
3147			 
3147					FORTH_DSP_POP 
3147 cd bd 1d			call macro_forth_dsp_pop 
314a				endm 
# End of macro FORTH_DSP_POP
314a e1					pop hl 
314b			 
314b 23					inc hl 
314c cd 00 1b				call forth_push_numhl 
314f					 
314f					NEXTW 
314f cd 6c ee			call parse_vector 
3152 c3 f0 1e			jp macro_next 
3155				endm 
# End of macro NEXTW
3155			.SBTOS: 
3155				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
3155 6f				db WORD_SYS_CORE+91             
3156 6e 31			dw .ADSTORE            
3158 03				db 2 + 1 
3159 .. 00			db "1-",0              
315c				endm 
# End of macro CWHEAD
315c			; | 1- ( u -- u )  Decrement value on TOS | DONE 
315c			 
315c					FORTH_DSP_VALUEHL 
315c cd 05 1d			call macro_dsp_valuehl 
315f				endm 
# End of macro FORTH_DSP_VALUEHL
315f e5					push hl 
3160			 
3160					FORTH_DSP_POP 
3160 cd bd 1d			call macro_forth_dsp_pop 
3163				endm 
# End of macro FORTH_DSP_POP
3163 e1					pop hl 
3164			 
3164 2b					dec hl 
3165 cd 00 1b				call forth_push_numhl 
3168					 
3168					NEXTW 
3168 cd 6c ee			call parse_vector 
316b c3 f0 1e			jp macro_next 
316e				endm 
# End of macro NEXTW
316e			.ADSTORE: 
316e				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
316e 6f				db WORD_SYS_CORE+91             
316f 87 31			dw .ADWSTORE            
3171 04				db 3 + 1 
3172 .. 00			db "1+!",0              
3176				endm 
# End of macro CWHEAD
3176			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
3176			 
3176					FORTH_DSP_VALUEHL 
3176 cd 05 1d			call macro_dsp_valuehl 
3179				endm 
# End of macro FORTH_DSP_VALUEHL
3179 e5					push hl 
317a			 
317a					FORTH_DSP_POP 
317a cd bd 1d			call macro_forth_dsp_pop 
317d				endm 
# End of macro FORTH_DSP_POP
317d e1					pop hl 
317e			 
317e 7e					ld a, (hl) 
317f 3c					inc a 
3180 77					ld (hl), a 
3181					 
3181					NEXTW 
3181 cd 6c ee			call parse_vector 
3184 c3 f0 1e			jp macro_next 
3187				endm 
# End of macro NEXTW
3187			.ADWSTORE: 
3187				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
3187 6f				db WORD_SYS_CORE+91             
3188 a8 31			dw .SBSTORE            
318a 05				db 4 + 1 
318b .. 00			db "1+2!",0              
3190				endm 
# End of macro CWHEAD
3190			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
3190			 
3190					FORTH_DSP_VALUEHL 
3190 cd 05 1d			call macro_dsp_valuehl 
3193				endm 
# End of macro FORTH_DSP_VALUEHL
3193 e5					push hl 
3194			 
3194					FORTH_DSP_POP 
3194 cd bd 1d			call macro_forth_dsp_pop 
3197				endm 
# End of macro FORTH_DSP_POP
3197 e1					pop hl 
3198			 
3198 e5					push hl 
3199			 
3199 cd 72 1e				call loadwordinhl 
319c 23					inc hl 
319d			 
319d d1					pop de 
319e eb					ex de, hl 
319f 73					ld (hl), e 
31a0 23					inc hl 
31a1 72					ld (hl), d 
31a2					 
31a2					NEXTW 
31a2 cd 6c ee			call parse_vector 
31a5 c3 f0 1e			jp macro_next 
31a8				endm 
# End of macro NEXTW
31a8			.SBSTORE: 
31a8				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
31a8 6f				db WORD_SYS_CORE+91             
31a9 c1 31			dw .SBWSTORE            
31ab 04				db 3 + 1 
31ac .. 00			db "1-!",0              
31b0				endm 
# End of macro CWHEAD
31b0			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
31b0			 
31b0					FORTH_DSP_VALUEHL 
31b0 cd 05 1d			call macro_dsp_valuehl 
31b3				endm 
# End of macro FORTH_DSP_VALUEHL
31b3 e5					push hl 
31b4			 
31b4					FORTH_DSP_POP 
31b4 cd bd 1d			call macro_forth_dsp_pop 
31b7				endm 
# End of macro FORTH_DSP_POP
31b7 e1					pop hl 
31b8			 
31b8 7e					ld a, (hl) 
31b9 3d					dec a 
31ba 77					ld (hl), a 
31bb					 
31bb					NEXTW 
31bb cd 6c ee			call parse_vector 
31be c3 f0 1e			jp macro_next 
31c1				endm 
# End of macro NEXTW
31c1			.SBWSTORE: 
31c1				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
31c1 6f				db WORD_SYS_CORE+91             
31c2 e2 31			dw .ENDCORE            
31c4 05				db 4 + 1 
31c5 .. 00			db "1-2!",0              
31ca				endm 
# End of macro CWHEAD
31ca			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
31ca			 
31ca					FORTH_DSP_VALUEHL 
31ca cd 05 1d			call macro_dsp_valuehl 
31cd				endm 
# End of macro FORTH_DSP_VALUEHL
31cd e5					push hl 
31ce			 
31ce					FORTH_DSP_POP 
31ce cd bd 1d			call macro_forth_dsp_pop 
31d1				endm 
# End of macro FORTH_DSP_POP
31d1 e1					pop hl 
31d2			 
31d2 e5					push hl 
31d3			 
31d3 cd 72 1e				call loadwordinhl 
31d6 2b					dec hl 
31d7			 
31d7 d1					pop de 
31d8 eb					ex de, hl 
31d9 73					ld (hl), e 
31da 23					inc hl 
31db 72					ld (hl), d 
31dc					 
31dc					NEXTW 
31dc cd 6c ee			call parse_vector 
31df c3 f0 1e			jp macro_next 
31e2				endm 
# End of macro NEXTW
31e2			.ENDCORE: 
31e2			 
31e2			; eof 
31e2			 
31e2			 
# End of file forth_words_core.asm
31e2			include "forth_words_flow.asm" 
31e2			 
31e2			; | ## Program Flow Words 
31e2			 
31e2			.IF: 
31e2				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
31e2 1e				db WORD_SYS_CORE+10             
31e3 dd 32			dw .THEN            
31e5 03				db 2 + 1 
31e6 .. 00			db "IF",0              
31e9				endm 
# End of macro CWHEAD
31e9			; | IF ( w -- f ) If TOS is true exec code following up to THEN  | DONE 
31e9			; | | Note: currently not supporting ELSE or nested IF 
31e9			; 
31e9					if DEBUG_FORTH_WORDS_KEY 
31e9						DMARK "IF." 
31e9 f5				push af  
31ea 3a fe 31			ld a, (.dmark)  
31ed 32 62 ee			ld (debug_mark),a  
31f0 3a ff 31			ld a, (.dmark+1)  
31f3 32 63 ee			ld (debug_mark+1),a  
31f6 3a 00 32			ld a, (.dmark+2)  
31f9 32 64 ee			ld (debug_mark+2),a  
31fc 18 03			jr .pastdmark  
31fe ..			.dmark: db "IF."  
3201 f1			.pastdmark: pop af  
3202			endm  
# End of macro DMARK
3202						CALLMONITOR 
3202 cd 6f ee			call debug_vector  
3205				endm  
# End of macro CALLMONITOR
3205					endif 
3205			; eval TOS 
3205			 
3205				FORTH_DSP_VALUEHL 
3205 cd 05 1d			call macro_dsp_valuehl 
3208				endm 
# End of macro FORTH_DSP_VALUEHL
3208			 
3208			;	push hl 
3208				FORTH_DSP_POP 
3208 cd bd 1d			call macro_forth_dsp_pop 
320b				endm 
# End of macro FORTH_DSP_POP
320b			;	pop hl 
320b			 
320b					if DEBUG_FORTH_WORDS 
320b						DMARK "IF1" 
320b f5				push af  
320c 3a 20 32			ld a, (.dmark)  
320f 32 62 ee			ld (debug_mark),a  
3212 3a 21 32			ld a, (.dmark+1)  
3215 32 63 ee			ld (debug_mark+1),a  
3218 3a 22 32			ld a, (.dmark+2)  
321b 32 64 ee			ld (debug_mark+2),a  
321e 18 03			jr .pastdmark  
3220 ..			.dmark: db "IF1"  
3223 f1			.pastdmark: pop af  
3224			endm  
# End of macro DMARK
3224						CALLMONITOR 
3224 cd 6f ee			call debug_vector  
3227				endm  
# End of macro CALLMONITOR
3227					endif 
3227 b7				or a        ; clear carry flag 
3228 11 00 00			ld de, 0 
322b eb				ex de,hl 
322c ed 52			sbc hl, de 
322e c2 bb 32			jp nz, .iftrue 
3231			 
3231					if DEBUG_FORTH_WORDS 
3231						DMARK "IF2" 
3231 f5				push af  
3232 3a 46 32			ld a, (.dmark)  
3235 32 62 ee			ld (debug_mark),a  
3238 3a 47 32			ld a, (.dmark+1)  
323b 32 63 ee			ld (debug_mark+1),a  
323e 3a 48 32			ld a, (.dmark+2)  
3241 32 64 ee			ld (debug_mark+2),a  
3244 18 03			jr .pastdmark  
3246 ..			.dmark: db "IF2"  
3249 f1			.pastdmark: pop af  
324a			endm  
# End of macro DMARK
324a						CALLMONITOR 
324a cd 6f ee			call debug_vector  
324d				endm  
# End of macro CALLMONITOR
324d					endif 
324d			 
324d			; if not true then skip to THEN 
324d			 
324d				; TODO get tok_ptr 
324d				; TODO consume toks until we get to THEN 
324d			 
324d 2a b9 e5			ld hl, (os_tok_ptr) 
3250					if DEBUG_FORTH_WORDS 
3250						DMARK "IF3" 
3250 f5				push af  
3251 3a 65 32			ld a, (.dmark)  
3254 32 62 ee			ld (debug_mark),a  
3257 3a 66 32			ld a, (.dmark+1)  
325a 32 63 ee			ld (debug_mark+1),a  
325d 3a 67 32			ld a, (.dmark+2)  
3260 32 64 ee			ld (debug_mark+2),a  
3263 18 03			jr .pastdmark  
3265 ..			.dmark: db "IF3"  
3268 f1			.pastdmark: pop af  
3269			endm  
# End of macro DMARK
3269						CALLMONITOR 
3269 cd 6f ee			call debug_vector  
326c				endm  
# End of macro CALLMONITOR
326c						 
326c					endif 
326c 11 b6 32			ld de, .ifthen 
326f					if DEBUG_FORTH_WORDS 
326f						DMARK "IF4" 
326f f5				push af  
3270 3a 84 32			ld a, (.dmark)  
3273 32 62 ee			ld (debug_mark),a  
3276 3a 85 32			ld a, (.dmark+1)  
3279 32 63 ee			ld (debug_mark+1),a  
327c 3a 86 32			ld a, (.dmark+2)  
327f 32 64 ee			ld (debug_mark+2),a  
3282 18 03			jr .pastdmark  
3284 ..			.dmark: db "IF4"  
3287 f1			.pastdmark: pop af  
3288			endm  
# End of macro DMARK
3288						CALLMONITOR 
3288 cd 6f ee			call debug_vector  
328b				endm  
# End of macro CALLMONITOR
328b					endif 
328b cd f7 1f			call findnexttok  
328e			 
328e					if DEBUG_FORTH_WORDS 
328e						DMARK "IF5" 
328e f5				push af  
328f 3a a3 32			ld a, (.dmark)  
3292 32 62 ee			ld (debug_mark),a  
3295 3a a4 32			ld a, (.dmark+1)  
3298 32 63 ee			ld (debug_mark+1),a  
329b 3a a5 32			ld a, (.dmark+2)  
329e 32 64 ee			ld (debug_mark+2),a  
32a1 18 03			jr .pastdmark  
32a3 ..			.dmark: db "IF5"  
32a6 f1			.pastdmark: pop af  
32a7			endm  
# End of macro DMARK
32a7						CALLMONITOR 
32a7 cd 6f ee			call debug_vector  
32aa				endm  
# End of macro CALLMONITOR
32aa					endif 
32aa				; TODO replace below with ; exec using tok_ptr 
32aa 22 b9 e5			ld (os_tok_ptr), hl 
32ad c3 79 1f			jp exec1 
32b0				NEXTW 
32b0 cd 6c ee			call parse_vector 
32b3 c3 f0 1e			jp macro_next 
32b6				endm 
# End of macro NEXTW
32b6			 
32b6 .. 00		.ifthen:  db "THEN",0 
32bb			 
32bb			.iftrue:		 
32bb				; Exec next words normally 
32bb			 
32bb				; if true then exec following IF as normal 
32bb					if DEBUG_FORTH_WORDS 
32bb						DMARK "IFT" 
32bb f5				push af  
32bc 3a d0 32			ld a, (.dmark)  
32bf 32 62 ee			ld (debug_mark),a  
32c2 3a d1 32			ld a, (.dmark+1)  
32c5 32 63 ee			ld (debug_mark+1),a  
32c8 3a d2 32			ld a, (.dmark+2)  
32cb 32 64 ee			ld (debug_mark+2),a  
32ce 18 03			jr .pastdmark  
32d0 ..			.dmark: db "IFT"  
32d3 f1			.pastdmark: pop af  
32d4			endm  
# End of macro DMARK
32d4						CALLMONITOR 
32d4 cd 6f ee			call debug_vector  
32d7				endm  
# End of macro CALLMONITOR
32d7					endif 
32d7			 
32d7					NEXTW 
32d7 cd 6c ee			call parse_vector 
32da c3 f0 1e			jp macro_next 
32dd				endm 
# End of macro NEXTW
32dd			.THEN: 
32dd				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
32dd 1f				db WORD_SYS_CORE+11             
32de 08 33			dw .ELSE            
32e0 05				db 4 + 1 
32e1 .. 00			db "THEN",0              
32e6				endm 
# End of macro CWHEAD
32e6			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
32e6					if DEBUG_FORTH_WORDS_KEY 
32e6						DMARK "THN" 
32e6 f5				push af  
32e7 3a fb 32			ld a, (.dmark)  
32ea 32 62 ee			ld (debug_mark),a  
32ed 3a fc 32			ld a, (.dmark+1)  
32f0 32 63 ee			ld (debug_mark+1),a  
32f3 3a fd 32			ld a, (.dmark+2)  
32f6 32 64 ee			ld (debug_mark+2),a  
32f9 18 03			jr .pastdmark  
32fb ..			.dmark: db "THN"  
32fe f1			.pastdmark: pop af  
32ff			endm  
# End of macro DMARK
32ff						CALLMONITOR 
32ff cd 6f ee			call debug_vector  
3302				endm  
# End of macro CALLMONITOR
3302					endif 
3302					NEXTW 
3302 cd 6c ee			call parse_vector 
3305 c3 f0 1e			jp macro_next 
3308				endm 
# End of macro NEXTW
3308			.ELSE: 
3308				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3308 20				db WORD_SYS_CORE+12             
3309 33 33			dw .DO            
330b 03				db 2 + 1 
330c .. 00			db "ELSE",0              
3311				endm 
# End of macro CWHEAD
3311			; | ELSE ( -- ) Not supported - does nothing | TODO 
3311			 
3311					if DEBUG_FORTH_WORDS_KEY 
3311						DMARK "ELS" 
3311 f5				push af  
3312 3a 26 33			ld a, (.dmark)  
3315 32 62 ee			ld (debug_mark),a  
3318 3a 27 33			ld a, (.dmark+1)  
331b 32 63 ee			ld (debug_mark+1),a  
331e 3a 28 33			ld a, (.dmark+2)  
3321 32 64 ee			ld (debug_mark+2),a  
3324 18 03			jr .pastdmark  
3326 ..			.dmark: db "ELS"  
3329 f1			.pastdmark: pop af  
332a			endm  
# End of macro DMARK
332a						CALLMONITOR 
332a cd 6f ee			call debug_vector  
332d				endm  
# End of macro CALLMONITOR
332d					endif 
332d			 
332d			 
332d					NEXTW 
332d cd 6c ee			call parse_vector 
3330 c3 f0 1e			jp macro_next 
3333				endm 
# End of macro NEXTW
3333			.DO: 
3333				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3333 21				db WORD_SYS_CORE+13             
3334 5d 34			dw .LOOP            
3336 03				db 2 + 1 
3337 .. 00			db "DO",0              
333a				endm 
# End of macro CWHEAD
333a			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
333a			 
333a					if DEBUG_FORTH_WORDS_KEY 
333a						DMARK "DO." 
333a f5				push af  
333b 3a 4f 33			ld a, (.dmark)  
333e 32 62 ee			ld (debug_mark),a  
3341 3a 50 33			ld a, (.dmark+1)  
3344 32 63 ee			ld (debug_mark+1),a  
3347 3a 51 33			ld a, (.dmark+2)  
334a 32 64 ee			ld (debug_mark+2),a  
334d 18 03			jr .pastdmark  
334f ..			.dmark: db "DO."  
3352 f1			.pastdmark: pop af  
3353			endm  
# End of macro DMARK
3353						CALLMONITOR 
3353 cd 6f ee			call debug_vector  
3356				endm  
# End of macro CALLMONITOR
3356					endif 
3356			;  push pc to rsp stack past the DO 
3356			 
3356 2a b9 e5				ld hl, (os_tok_ptr) 
3359 23					inc hl   ; D 
335a 23					inc hl  ; O 
335b 23					inc hl   ; null 
335c					if DEBUG_FORTH_WORDS 
335c						DMARK "DO2" 
335c f5				push af  
335d 3a 71 33			ld a, (.dmark)  
3360 32 62 ee			ld (debug_mark),a  
3363 3a 72 33			ld a, (.dmark+1)  
3366 32 63 ee			ld (debug_mark+1),a  
3369 3a 73 33			ld a, (.dmark+2)  
336c 32 64 ee			ld (debug_mark+2),a  
336f 18 03			jr .pastdmark  
3371 ..			.dmark: db "DO2"  
3374 f1			.pastdmark: pop af  
3375			endm  
# End of macro DMARK
3375						CALLMONITOR 
3375 cd 6f ee			call debug_vector  
3378				endm  
# End of macro CALLMONITOR
3378					endif 
3378					FORTH_RSP_NEXT 
3378 cd a7 1a			call macro_forth_rsp_next 
337b				endm 
# End of macro FORTH_RSP_NEXT
337b					if DEBUG_FORTH_WORDS 
337b						DMARK "DO3" 
337b f5				push af  
337c 3a 90 33			ld a, (.dmark)  
337f 32 62 ee			ld (debug_mark),a  
3382 3a 91 33			ld a, (.dmark+1)  
3385 32 63 ee			ld (debug_mark+1),a  
3388 3a 92 33			ld a, (.dmark+2)  
338b 32 64 ee			ld (debug_mark+2),a  
338e 18 03			jr .pastdmark  
3390 ..			.dmark: db "DO3"  
3393 f1			.pastdmark: pop af  
3394			endm  
# End of macro DMARK
3394						CALLMONITOR 
3394 cd 6f ee			call debug_vector  
3397				endm  
# End of macro CALLMONITOR
3397					endif 
3397			 
3397					;if DEBUG_FORTH_WORDS 
3397				;		push hl 
3397			;		endif  
3397			 
3397			; get counters from data stack 
3397			 
3397			 
3397					FORTH_DSP_VALUEHL 
3397 cd 05 1d			call macro_dsp_valuehl 
339a				endm 
# End of macro FORTH_DSP_VALUEHL
339a e5					push hl		 ; hl now has starting counter which needs to be tos 
339b			 
339b					if DEBUG_FORTH_WORDS 
339b						DMARK "DO4" 
339b f5				push af  
339c 3a b0 33			ld a, (.dmark)  
339f 32 62 ee			ld (debug_mark),a  
33a2 3a b1 33			ld a, (.dmark+1)  
33a5 32 63 ee			ld (debug_mark+1),a  
33a8 3a b2 33			ld a, (.dmark+2)  
33ab 32 64 ee			ld (debug_mark+2),a  
33ae 18 03			jr .pastdmark  
33b0 ..			.dmark: db "DO4"  
33b3 f1			.pastdmark: pop af  
33b4			endm  
# End of macro DMARK
33b4						CALLMONITOR 
33b4 cd 6f ee			call debug_vector  
33b7				endm  
# End of macro CALLMONITOR
33b7					endif 
33b7					FORTH_DSP_POP 
33b7 cd bd 1d			call macro_forth_dsp_pop 
33ba				endm 
# End of macro FORTH_DSP_POP
33ba			 
33ba					if DEBUG_FORTH_WORDS 
33ba						DMARK "DO5" 
33ba f5				push af  
33bb 3a cf 33			ld a, (.dmark)  
33be 32 62 ee			ld (debug_mark),a  
33c1 3a d0 33			ld a, (.dmark+1)  
33c4 32 63 ee			ld (debug_mark+1),a  
33c7 3a d1 33			ld a, (.dmark+2)  
33ca 32 64 ee			ld (debug_mark+2),a  
33cd 18 03			jr .pastdmark  
33cf ..			.dmark: db "DO5"  
33d2 f1			.pastdmark: pop af  
33d3			endm  
# End of macro DMARK
33d3						CALLMONITOR 
33d3 cd 6f ee			call debug_vector  
33d6				endm  
# End of macro CALLMONITOR
33d6					endif 
33d6			 
33d6					FORTH_DSP_VALUEHL 
33d6 cd 05 1d			call macro_dsp_valuehl 
33d9				endm 
# End of macro FORTH_DSP_VALUEHL
33d9			;		push hl		 ; hl now has starting limit counter 
33d9			 
33d9					if DEBUG_FORTH_WORDS 
33d9						DMARK "DO6" 
33d9 f5				push af  
33da 3a ee 33			ld a, (.dmark)  
33dd 32 62 ee			ld (debug_mark),a  
33e0 3a ef 33			ld a, (.dmark+1)  
33e3 32 63 ee			ld (debug_mark+1),a  
33e6 3a f0 33			ld a, (.dmark+2)  
33e9 32 64 ee			ld (debug_mark+2),a  
33ec 18 03			jr .pastdmark  
33ee ..			.dmark: db "DO6"  
33f1 f1			.pastdmark: pop af  
33f2			endm  
# End of macro DMARK
33f2						CALLMONITOR 
33f2 cd 6f ee			call debug_vector  
33f5				endm  
# End of macro CALLMONITOR
33f5					endif 
33f5					FORTH_DSP_POP 
33f5 cd bd 1d			call macro_forth_dsp_pop 
33f8				endm 
# End of macro FORTH_DSP_POP
33f8			 
33f8			; put counters on the loop stack 
33f8			 
33f8			;		pop hl			 ; limit counter 
33f8 d1					pop de			; start counter 
33f9			 
33f9					; push limit counter 
33f9			 
33f9					if DEBUG_FORTH_WORDS 
33f9						DMARK "DO7" 
33f9 f5				push af  
33fa 3a 0e 34			ld a, (.dmark)  
33fd 32 62 ee			ld (debug_mark),a  
3400 3a 0f 34			ld a, (.dmark+1)  
3403 32 63 ee			ld (debug_mark+1),a  
3406 3a 10 34			ld a, (.dmark+2)  
3409 32 64 ee			ld (debug_mark+2),a  
340c 18 03			jr .pastdmark  
340e ..			.dmark: db "DO7"  
3411 f1			.pastdmark: pop af  
3412			endm  
# End of macro DMARK
3412						CALLMONITOR 
3412 cd 6f ee			call debug_vector  
3415				endm  
# End of macro CALLMONITOR
3415					endif 
3415					FORTH_LOOP_NEXT 
3415 cd 36 1d			call macro_forth_loop_next 
3418				endm 
# End of macro FORTH_LOOP_NEXT
3418			 
3418					; push start counter 
3418			 
3418 eb					ex de, hl 
3419					if DEBUG_FORTH_WORDS 
3419						DMARK "DO7" 
3419 f5				push af  
341a 3a 2e 34			ld a, (.dmark)  
341d 32 62 ee			ld (debug_mark),a  
3420 3a 2f 34			ld a, (.dmark+1)  
3423 32 63 ee			ld (debug_mark+1),a  
3426 3a 30 34			ld a, (.dmark+2)  
3429 32 64 ee			ld (debug_mark+2),a  
342c 18 03			jr .pastdmark  
342e ..			.dmark: db "DO7"  
3431 f1			.pastdmark: pop af  
3432			endm  
# End of macro DMARK
3432						CALLMONITOR 
3432 cd 6f ee			call debug_vector  
3435				endm  
# End of macro CALLMONITOR
3435					endif 
3435					FORTH_LOOP_NEXT 
3435 cd 36 1d			call macro_forth_loop_next 
3438				endm 
# End of macro FORTH_LOOP_NEXT
3438			 
3438			 
3438					; init first round of I counter 
3438			 
3438 22 dd e5				ld (os_current_i), hl 
343b			 
343b					if DEBUG_FORTH_WORDS 
343b						DMARK "DO8" 
343b f5				push af  
343c 3a 50 34			ld a, (.dmark)  
343f 32 62 ee			ld (debug_mark),a  
3442 3a 51 34			ld a, (.dmark+1)  
3445 32 63 ee			ld (debug_mark+1),a  
3448 3a 52 34			ld a, (.dmark+2)  
344b 32 64 ee			ld (debug_mark+2),a  
344e 18 03			jr .pastdmark  
3450 ..			.dmark: db "DO8"  
3453 f1			.pastdmark: pop af  
3454			endm  
# End of macro DMARK
3454						CALLMONITOR 
3454 cd 6f ee			call debug_vector  
3457				endm  
# End of macro CALLMONITOR
3457					endif 
3457			 
3457					NEXTW 
3457 cd 6c ee			call parse_vector 
345a c3 f0 1e			jp macro_next 
345d				endm 
# End of macro NEXTW
345d			.LOOP: 
345d				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
345d 22				db WORD_SYS_CORE+14             
345e 7b 35			dw .I            
3460 05				db 4 + 1 
3461 .. 00			db "LOOP",0              
3466				endm 
# End of macro CWHEAD
3466			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3466			 
3466				; pop tos as current loop count to hl 
3466			 
3466				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3466			 
3466				FORTH_LOOP_TOS 
3466 cd 69 1d			call macro_forth_loop_tos 
3469				endm 
# End of macro FORTH_LOOP_TOS
3469 e5				push hl 
346a			 
346a					if DEBUG_FORTH_WORDS_KEY 
346a						DMARK "LOP" 
346a f5				push af  
346b 3a 7f 34			ld a, (.dmark)  
346e 32 62 ee			ld (debug_mark),a  
3471 3a 80 34			ld a, (.dmark+1)  
3474 32 63 ee			ld (debug_mark+1),a  
3477 3a 81 34			ld a, (.dmark+2)  
347a 32 64 ee			ld (debug_mark+2),a  
347d 18 03			jr .pastdmark  
347f ..			.dmark: db "LOP"  
3482 f1			.pastdmark: pop af  
3483			endm  
# End of macro DMARK
3483						CALLMONITOR 
3483 cd 6f ee			call debug_vector  
3486				endm  
# End of macro CALLMONITOR
3486					endif 
3486				; next item on the stack is the limit. get it 
3486			 
3486			 
3486				FORTH_LOOP_POP 
3486 cd 73 1d			call macro_forth_loop_pop 
3489				endm 
# End of macro FORTH_LOOP_POP
3489			 
3489				FORTH_LOOP_TOS 
3489 cd 69 1d			call macro_forth_loop_tos 
348c				endm 
# End of macro FORTH_LOOP_TOS
348c			 
348c d1				pop de		 ; de = i, hl = limit 
348d			 
348d					if DEBUG_FORTH_WORDS 
348d						DMARK "LP1" 
348d f5				push af  
348e 3a a2 34			ld a, (.dmark)  
3491 32 62 ee			ld (debug_mark),a  
3494 3a a3 34			ld a, (.dmark+1)  
3497 32 63 ee			ld (debug_mark+1),a  
349a 3a a4 34			ld a, (.dmark+2)  
349d 32 64 ee			ld (debug_mark+2),a  
34a0 18 03			jr .pastdmark  
34a2 ..			.dmark: db "LP1"  
34a5 f1			.pastdmark: pop af  
34a6			endm  
# End of macro DMARK
34a6						CALLMONITOR 
34a6 cd 6f ee			call debug_vector  
34a9				endm  
# End of macro CALLMONITOR
34a9					endif 
34a9			 
34a9				; go back to previous word 
34a9			 
34a9 d5				push de    ; save I for inc later 
34aa			 
34aa			 
34aa				; get limit 
34aa				;  is I at limit? 
34aa			 
34aa			 
34aa					if DEBUG_FORTH_WORDS 
34aa						DMARK "LP1" 
34aa f5				push af  
34ab 3a bf 34			ld a, (.dmark)  
34ae 32 62 ee			ld (debug_mark),a  
34b1 3a c0 34			ld a, (.dmark+1)  
34b4 32 63 ee			ld (debug_mark+1),a  
34b7 3a c1 34			ld a, (.dmark+2)  
34ba 32 64 ee			ld (debug_mark+2),a  
34bd 18 03			jr .pastdmark  
34bf ..			.dmark: db "LP1"  
34c2 f1			.pastdmark: pop af  
34c3			endm  
# End of macro DMARK
34c3						CALLMONITOR 
34c3 cd 6f ee			call debug_vector  
34c6				endm  
# End of macro CALLMONITOR
34c6					endif 
34c6			 
34c6 ed 52			sbc hl, de 
34c8			 
34c8			 
34c8				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
34c8			 
34c8 20 29				jr nz, .loopnotdone 
34ca			 
34ca e1				pop hl   ; get rid of saved I 
34cb				FORTH_LOOP_POP     ; get rid of limit 
34cb cd 73 1d			call macro_forth_loop_pop 
34ce				endm 
# End of macro FORTH_LOOP_POP
34ce			 
34ce				FORTH_RSP_POP     ; get rid of DO ptr 
34ce cd c8 1a			call macro_forth_rsp_pop 
34d1				endm 
# End of macro FORTH_RSP_POP
34d1			 
34d1			if DEBUG_FORTH_WORDS 
34d1						DMARK "LP>" 
34d1 f5				push af  
34d2 3a e6 34			ld a, (.dmark)  
34d5 32 62 ee			ld (debug_mark),a  
34d8 3a e7 34			ld a, (.dmark+1)  
34db 32 63 ee			ld (debug_mark+1),a  
34de 3a e8 34			ld a, (.dmark+2)  
34e1 32 64 ee			ld (debug_mark+2),a  
34e4 18 03			jr .pastdmark  
34e6 ..			.dmark: db "LP>"  
34e9 f1			.pastdmark: pop af  
34ea			endm  
# End of macro DMARK
34ea				CALLMONITOR 
34ea cd 6f ee			call debug_vector  
34ed				endm  
# End of macro CALLMONITOR
34ed			endif 
34ed			 
34ed					NEXTW 
34ed cd 6c ee			call parse_vector 
34f0 c3 f0 1e			jp macro_next 
34f3				endm 
# End of macro NEXTW
34f3				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34f3			 
34f3			.loopnotdone: 
34f3			 
34f3 e1				pop hl    ; get I 
34f4 23				inc hl 
34f5			 
34f5			   	; save new I 
34f5			 
34f5			 
34f5					; set I counter 
34f5			 
34f5 22 dd e5				ld (os_current_i), hl 
34f8			 
34f8					if DEBUG_FORTH_WORDS 
34f8						DMARK "LPN" 
34f8 f5				push af  
34f9 3a 0d 35			ld a, (.dmark)  
34fc 32 62 ee			ld (debug_mark),a  
34ff 3a 0e 35			ld a, (.dmark+1)  
3502 32 63 ee			ld (debug_mark+1),a  
3505 3a 0f 35			ld a, (.dmark+2)  
3508 32 64 ee			ld (debug_mark+2),a  
350b 18 03			jr .pastdmark  
350d ..			.dmark: db "LPN"  
3510 f1			.pastdmark: pop af  
3511			endm  
# End of macro DMARK
3511					CALLMONITOR 
3511 cd 6f ee			call debug_vector  
3514				endm  
# End of macro CALLMONITOR
3514					endif 
3514					 
3514				FORTH_LOOP_NEXT 
3514 cd 36 1d			call macro_forth_loop_next 
3517				endm 
# End of macro FORTH_LOOP_NEXT
3517			 
3517			 
3517					if DEBUG_FORTH_WORDS 
3517 eb						ex de,hl 
3518					endif 
3518			 
3518			;	; get DO ptr 
3518			; 
3518					if DEBUG_FORTH_WORDS 
3518						DMARK "LP7" 
3518 f5				push af  
3519 3a 2d 35			ld a, (.dmark)  
351c 32 62 ee			ld (debug_mark),a  
351f 3a 2e 35			ld a, (.dmark+1)  
3522 32 63 ee			ld (debug_mark+1),a  
3525 3a 2f 35			ld a, (.dmark+2)  
3528 32 64 ee			ld (debug_mark+2),a  
352b 18 03			jr .pastdmark  
352d ..			.dmark: db "LP7"  
3530 f1			.pastdmark: pop af  
3531			endm  
# End of macro DMARK
3531					CALLMONITOR 
3531 cd 6f ee			call debug_vector  
3534				endm  
# End of macro CALLMONITOR
3534					endif 
3534				FORTH_RSP_TOS 
3534 cd be 1a			call macro_forth_rsp_tos 
3537				endm 
# End of macro FORTH_RSP_TOS
3537			 
3537					if DEBUG_FORTH_WORDS 
3537						DMARK "LP8" 
3537 f5				push af  
3538 3a 4c 35			ld a, (.dmark)  
353b 32 62 ee			ld (debug_mark),a  
353e 3a 4d 35			ld a, (.dmark+1)  
3541 32 63 ee			ld (debug_mark+1),a  
3544 3a 4e 35			ld a, (.dmark+2)  
3547 32 64 ee			ld (debug_mark+2),a  
354a 18 03			jr .pastdmark  
354c ..			.dmark: db "LP8"  
354f f1			.pastdmark: pop af  
3550			endm  
# End of macro DMARK
3550					CALLMONITOR 
3550 cd 6f ee			call debug_vector  
3553				endm  
# End of macro CALLMONITOR
3553					endif 
3553				;push hl 
3553			 
3553				; not going to DO any more 
3553				; get rid of the RSP pointer as DO will add it back in 
3553				;FORTH_RSP_POP 
3553				;pop hl 
3553			 
3553				;ld hl,(cli_ret_sp) 
3553				;ld e, (hl) 
3553				;inc hl 
3553				;ld d, (hl) 
3553				;ex de,hl 
3553 22 b9 e5			ld (os_tok_ptr), hl 
3556					if DEBUG_FORTH_WORDS 
3556						DMARK "LP<" 
3556 f5				push af  
3557 3a 6b 35			ld a, (.dmark)  
355a 32 62 ee			ld (debug_mark),a  
355d 3a 6c 35			ld a, (.dmark+1)  
3560 32 63 ee			ld (debug_mark+1),a  
3563 3a 6d 35			ld a, (.dmark+2)  
3566 32 64 ee			ld (debug_mark+2),a  
3569 18 03			jr .pastdmark  
356b ..			.dmark: db "LP<"  
356e f1			.pastdmark: pop af  
356f			endm  
# End of macro DMARK
356f					CALLMONITOR 
356f cd 6f ee			call debug_vector  
3572				endm  
# End of macro CALLMONITOR
3572				endif 
3572 c3 79 1f			jp exec1 
3575			 
3575					 
3575			 
3575			 
3575					NEXTW 
3575 cd 6c ee			call parse_vector 
3578 c3 f0 1e			jp macro_next 
357b				endm 
# End of macro NEXTW
357b			.I:  
357b			 
357b				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
357b 5e				db WORD_SYS_CORE+74             
357c a9 35			dw .DLOOP            
357e 02				db 1 + 1 
357f .. 00			db "I",0              
3581				endm 
# End of macro CWHEAD
3581			; | I ( -- ) Current loop counter | DONE 
3581					if DEBUG_FORTH_WORDS_KEY 
3581						DMARK "I.." 
3581 f5				push af  
3582 3a 96 35			ld a, (.dmark)  
3585 32 62 ee			ld (debug_mark),a  
3588 3a 97 35			ld a, (.dmark+1)  
358b 32 63 ee			ld (debug_mark+1),a  
358e 3a 98 35			ld a, (.dmark+2)  
3591 32 64 ee			ld (debug_mark+2),a  
3594 18 03			jr .pastdmark  
3596 ..			.dmark: db "I.."  
3599 f1			.pastdmark: pop af  
359a			endm  
# End of macro DMARK
359a						CALLMONITOR 
359a cd 6f ee			call debug_vector  
359d				endm  
# End of macro CALLMONITOR
359d					endif 
359d			 
359d 2a dd e5				ld hl,(os_current_i) 
35a0 cd 00 1b				call forth_push_numhl 
35a3			 
35a3					NEXTW 
35a3 cd 6c ee			call parse_vector 
35a6 c3 f0 1e			jp macro_next 
35a9				endm 
# End of macro NEXTW
35a9			.DLOOP: 
35a9				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
35a9 5f				db WORD_SYS_CORE+75             
35aa 90 36			dw .REPEAT            
35ac 06				db 5 + 1 
35ad .. 00			db "-LOOP",0              
35b3				endm 
# End of macro CWHEAD
35b3			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
35b3				; pop tos as current loop count to hl 
35b3					if DEBUG_FORTH_WORDS_KEY 
35b3						DMARK "-LP" 
35b3 f5				push af  
35b4 3a c8 35			ld a, (.dmark)  
35b7 32 62 ee			ld (debug_mark),a  
35ba 3a c9 35			ld a, (.dmark+1)  
35bd 32 63 ee			ld (debug_mark+1),a  
35c0 3a ca 35			ld a, (.dmark+2)  
35c3 32 64 ee			ld (debug_mark+2),a  
35c6 18 03			jr .pastdmark  
35c8 ..			.dmark: db "-LP"  
35cb f1			.pastdmark: pop af  
35cc			endm  
# End of macro DMARK
35cc						CALLMONITOR 
35cc cd 6f ee			call debug_vector  
35cf				endm  
# End of macro CALLMONITOR
35cf					endif 
35cf			 
35cf				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
35cf			 
35cf				FORTH_LOOP_TOS 
35cf cd 69 1d			call macro_forth_loop_tos 
35d2				endm 
# End of macro FORTH_LOOP_TOS
35d2 e5				push hl 
35d3			 
35d3					if DEBUG_FORTH_WORDS 
35d3						DMARK "-LP" 
35d3 f5				push af  
35d4 3a e8 35			ld a, (.dmark)  
35d7 32 62 ee			ld (debug_mark),a  
35da 3a e9 35			ld a, (.dmark+1)  
35dd 32 63 ee			ld (debug_mark+1),a  
35e0 3a ea 35			ld a, (.dmark+2)  
35e3 32 64 ee			ld (debug_mark+2),a  
35e6 18 03			jr .pastdmark  
35e8 ..			.dmark: db "-LP"  
35eb f1			.pastdmark: pop af  
35ec			endm  
# End of macro DMARK
35ec						CALLMONITOR 
35ec cd 6f ee			call debug_vector  
35ef				endm  
# End of macro CALLMONITOR
35ef					endif 
35ef				; next item on the stack is the limit. get it 
35ef			 
35ef			 
35ef				FORTH_LOOP_POP 
35ef cd 73 1d			call macro_forth_loop_pop 
35f2				endm 
# End of macro FORTH_LOOP_POP
35f2			 
35f2				FORTH_LOOP_TOS 
35f2 cd 69 1d			call macro_forth_loop_tos 
35f5				endm 
# End of macro FORTH_LOOP_TOS
35f5			 
35f5 d1				pop de		 ; de = i, hl = limit 
35f6			 
35f6					if DEBUG_FORTH_WORDS 
35f6						DMARK "-L1" 
35f6 f5				push af  
35f7 3a 0b 36			ld a, (.dmark)  
35fa 32 62 ee			ld (debug_mark),a  
35fd 3a 0c 36			ld a, (.dmark+1)  
3600 32 63 ee			ld (debug_mark+1),a  
3603 3a 0d 36			ld a, (.dmark+2)  
3606 32 64 ee			ld (debug_mark+2),a  
3609 18 03			jr .pastdmark  
360b ..			.dmark: db "-L1"  
360e f1			.pastdmark: pop af  
360f			endm  
# End of macro DMARK
360f						CALLMONITOR 
360f cd 6f ee			call debug_vector  
3612				endm  
# End of macro CALLMONITOR
3612					endif 
3612			 
3612				; go back to previous word 
3612			 
3612 d5				push de    ; save I for inc later 
3613			 
3613			 
3613				; get limit 
3613				;  is I at limit? 
3613			 
3613			 
3613					if DEBUG_FORTH_WORDS 
3613						DMARK "-L1" 
3613 f5				push af  
3614 3a 28 36			ld a, (.dmark)  
3617 32 62 ee			ld (debug_mark),a  
361a 3a 29 36			ld a, (.dmark+1)  
361d 32 63 ee			ld (debug_mark+1),a  
3620 3a 2a 36			ld a, (.dmark+2)  
3623 32 64 ee			ld (debug_mark+2),a  
3626 18 03			jr .pastdmark  
3628 ..			.dmark: db "-L1"  
362b f1			.pastdmark: pop af  
362c			endm  
# End of macro DMARK
362c						CALLMONITOR 
362c cd 6f ee			call debug_vector  
362f				endm  
# End of macro CALLMONITOR
362f					endif 
362f			 
362f ed 52			sbc hl, de 
3631			 
3631			 
3631				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3631			 
3631 20 29				jr nz, .mloopnotdone 
3633			 
3633 e1				pop hl   ; get rid of saved I 
3634				FORTH_LOOP_POP     ; get rid of limit 
3634 cd 73 1d			call macro_forth_loop_pop 
3637				endm 
# End of macro FORTH_LOOP_POP
3637			 
3637				FORTH_RSP_POP     ; get rid of DO ptr 
3637 cd c8 1a			call macro_forth_rsp_pop 
363a				endm 
# End of macro FORTH_RSP_POP
363a			 
363a			if DEBUG_FORTH_WORDS 
363a						DMARK "-L>" 
363a f5				push af  
363b 3a 4f 36			ld a, (.dmark)  
363e 32 62 ee			ld (debug_mark),a  
3641 3a 50 36			ld a, (.dmark+1)  
3644 32 63 ee			ld (debug_mark+1),a  
3647 3a 51 36			ld a, (.dmark+2)  
364a 32 64 ee			ld (debug_mark+2),a  
364d 18 03			jr .pastdmark  
364f ..			.dmark: db "-L>"  
3652 f1			.pastdmark: pop af  
3653			endm  
# End of macro DMARK
3653				CALLMONITOR 
3653 cd 6f ee			call debug_vector  
3656				endm  
# End of macro CALLMONITOR
3656			endif 
3656			 
3656					NEXTW 
3656 cd 6c ee			call parse_vector 
3659 c3 f0 1e			jp macro_next 
365c				endm 
# End of macro NEXTW
365c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
365c			 
365c			.mloopnotdone: 
365c			 
365c e1				pop hl    ; get I 
365d 2b				dec hl 
365e			 
365e			   	; save new I 
365e			 
365e			 
365e					; set I counter 
365e			 
365e 22 dd e5				ld (os_current_i), hl 
3661			 
3661					 
3661				FORTH_LOOP_NEXT 
3661 cd 36 1d			call macro_forth_loop_next 
3664				endm 
# End of macro FORTH_LOOP_NEXT
3664			 
3664			 
3664					if DEBUG_FORTH_WORDS 
3664 eb						ex de,hl 
3665					endif 
3665			 
3665			;	; get DO ptr 
3665			; 
3665				FORTH_RSP_TOS 
3665 cd be 1a			call macro_forth_rsp_tos 
3668				endm 
# End of macro FORTH_RSP_TOS
3668			 
3668				;push hl 
3668			 
3668				; not going to DO any more 
3668				; get rid of the RSP pointer as DO will add it back in 
3668				;FORTH_RSP_POP 
3668				;pop hl 
3668			 
3668			 
3668 22 b9 e5			ld (os_tok_ptr), hl 
366b					if DEBUG_FORTH_WORDS 
366b						DMARK "-L<" 
366b f5				push af  
366c 3a 80 36			ld a, (.dmark)  
366f 32 62 ee			ld (debug_mark),a  
3672 3a 81 36			ld a, (.dmark+1)  
3675 32 63 ee			ld (debug_mark+1),a  
3678 3a 82 36			ld a, (.dmark+2)  
367b 32 64 ee			ld (debug_mark+2),a  
367e 18 03			jr .pastdmark  
3680 ..			.dmark: db "-L<"  
3683 f1			.pastdmark: pop af  
3684			endm  
# End of macro DMARK
3684					CALLMONITOR 
3684 cd 6f ee			call debug_vector  
3687				endm  
# End of macro CALLMONITOR
3687				endif 
3687 c3 79 1f			jp exec1 
368a			 
368a					 
368a			 
368a			 
368a			 
368a				NEXTW 
368a cd 6c ee			call parse_vector 
368d c3 f0 1e			jp macro_next 
3690				endm 
# End of macro NEXTW
3690			 
3690			 
3690			 
3690			 
3690			.REPEAT: 
3690				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3690 71				db WORD_SYS_CORE+93             
3691 e6 36			dw .UNTIL            
3693 06				db 5 + 1 
3694 .. 00			db "REPEAT",0              
369b				endm 
# End of macro CWHEAD
369b			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
369b			;  push pc to rsp stack past the REPEAT 
369b					if DEBUG_FORTH_WORDS_KEY 
369b						DMARK "REP" 
369b f5				push af  
369c 3a b0 36			ld a, (.dmark)  
369f 32 62 ee			ld (debug_mark),a  
36a2 3a b1 36			ld a, (.dmark+1)  
36a5 32 63 ee			ld (debug_mark+1),a  
36a8 3a b2 36			ld a, (.dmark+2)  
36ab 32 64 ee			ld (debug_mark+2),a  
36ae 18 03			jr .pastdmark  
36b0 ..			.dmark: db "REP"  
36b3 f1			.pastdmark: pop af  
36b4			endm  
# End of macro DMARK
36b4						CALLMONITOR 
36b4 cd 6f ee			call debug_vector  
36b7				endm  
# End of macro CALLMONITOR
36b7					endif 
36b7			 
36b7 2a b9 e5				ld hl, (os_tok_ptr) 
36ba 23					inc hl   ; R 
36bb 23					inc hl  ; E 
36bc 23					inc hl   ; P 
36bd 23					inc hl   ; E 
36be 23					inc hl   ; A 
36bf 23					inc hl   ; T 
36c0 23					inc hl   ; zero 
36c1					FORTH_RSP_NEXT 
36c1 cd a7 1a			call macro_forth_rsp_next 
36c4				endm 
# End of macro FORTH_RSP_NEXT
36c4			 
36c4			 
36c4					if DEBUG_FORTH_WORDS 
36c4						DMARK "REP" 
36c4 f5				push af  
36c5 3a d9 36			ld a, (.dmark)  
36c8 32 62 ee			ld (debug_mark),a  
36cb 3a da 36			ld a, (.dmark+1)  
36ce 32 63 ee			ld (debug_mark+1),a  
36d1 3a db 36			ld a, (.dmark+2)  
36d4 32 64 ee			ld (debug_mark+2),a  
36d7 18 03			jr .pastdmark  
36d9 ..			.dmark: db "REP"  
36dc f1			.pastdmark: pop af  
36dd			endm  
# End of macro DMARK
36dd						;pop bc    ; TODO BUG ?????? what is this for???? 
36dd						CALLMONITOR 
36dd cd 6f ee			call debug_vector  
36e0				endm  
# End of macro CALLMONITOR
36e0					endif 
36e0			 
36e0					NEXTW 
36e0 cd 6c ee			call parse_vector 
36e3 c3 f0 1e			jp macro_next 
36e6				endm 
# End of macro NEXTW
36e6			;	       NEXTW 
36e6			 
36e6			.UNTIL: 
36e6				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
36e6 72				db WORD_SYS_CORE+94             
36e7 83 37			dw .ENDFLOW            
36e9 06				db 5 + 1 
36ea .. 00			db "UNTIL",0              
36f0				endm 
# End of macro CWHEAD
36f0			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
36f0			 
36f0				; pop tos as check 
36f0			 
36f0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
36f0			 
36f0				FORTH_DSP_VALUEHL 
36f0 cd 05 1d			call macro_dsp_valuehl 
36f3				endm 
# End of macro FORTH_DSP_VALUEHL
36f3			 
36f3					if DEBUG_FORTH_WORDS_KEY 
36f3						DMARK "UNT" 
36f3 f5				push af  
36f4 3a 08 37			ld a, (.dmark)  
36f7 32 62 ee			ld (debug_mark),a  
36fa 3a 09 37			ld a, (.dmark+1)  
36fd 32 63 ee			ld (debug_mark+1),a  
3700 3a 0a 37			ld a, (.dmark+2)  
3703 32 64 ee			ld (debug_mark+2),a  
3706 18 03			jr .pastdmark  
3708 ..			.dmark: db "UNT"  
370b f1			.pastdmark: pop af  
370c			endm  
# End of macro DMARK
370c						CALLMONITOR 
370c cd 6f ee			call debug_vector  
370f				endm  
# End of macro CALLMONITOR
370f					endif 
370f			 
370f			;	push hl 
370f				FORTH_DSP_POP 
370f cd bd 1d			call macro_forth_dsp_pop 
3712				endm 
# End of macro FORTH_DSP_POP
3712			 
3712			;	pop hl 
3712			 
3712				; test if true 
3712			 
3712 cd 1e 0e			call ishlzero 
3715			;	ld a,l 
3715			;	add h 
3715			; 
3715			;	cp 0 
3715			 
3715 20 41			jr nz, .untilnotdone 
3717			 
3717					if DEBUG_FORTH_WORDS 
3717						DMARK "UNf" 
3717 f5				push af  
3718 3a 2c 37			ld a, (.dmark)  
371b 32 62 ee			ld (debug_mark),a  
371e 3a 2d 37			ld a, (.dmark+1)  
3721 32 63 ee			ld (debug_mark+1),a  
3724 3a 2e 37			ld a, (.dmark+2)  
3727 32 64 ee			ld (debug_mark+2),a  
372a 18 03			jr .pastdmark  
372c ..			.dmark: db "UNf"  
372f f1			.pastdmark: pop af  
3730			endm  
# End of macro DMARK
3730						CALLMONITOR 
3730 cd 6f ee			call debug_vector  
3733				endm  
# End of macro CALLMONITOR
3733					endif 
3733			 
3733			 
3733			 
3733				FORTH_RSP_POP     ; get rid of DO ptr 
3733 cd c8 1a			call macro_forth_rsp_pop 
3736				endm 
# End of macro FORTH_RSP_POP
3736			 
3736			if DEBUG_FORTH_WORDS 
3736						DMARK "UN>" 
3736 f5				push af  
3737 3a 4b 37			ld a, (.dmark)  
373a 32 62 ee			ld (debug_mark),a  
373d 3a 4c 37			ld a, (.dmark+1)  
3740 32 63 ee			ld (debug_mark+1),a  
3743 3a 4d 37			ld a, (.dmark+2)  
3746 32 64 ee			ld (debug_mark+2),a  
3749 18 03			jr .pastdmark  
374b ..			.dmark: db "UN>"  
374e f1			.pastdmark: pop af  
374f			endm  
# End of macro DMARK
374f				CALLMONITOR 
374f cd 6f ee			call debug_vector  
3752				endm  
# End of macro CALLMONITOR
3752			endif 
3752			 
3752					NEXTW 
3752 cd 6c ee			call parse_vector 
3755 c3 f0 1e			jp macro_next 
3758				endm 
# End of macro NEXTW
3758				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3758			 
3758			.untilnotdone: 
3758			 
3758			 
3758			;	; get DO ptr 
3758			; 
3758				FORTH_RSP_TOS 
3758 cd be 1a			call macro_forth_rsp_tos 
375b				endm 
# End of macro FORTH_RSP_TOS
375b			 
375b				;push hl 
375b			 
375b				; not going to DO any more 
375b				; get rid of the RSP pointer as DO will add it back in 
375b				;FORTH_RSP_POP 
375b				;pop hl 
375b			 
375b			 
375b 22 b9 e5			ld (os_tok_ptr), hl 
375e					if DEBUG_FORTH_WORDS 
375e						DMARK "UN<" 
375e f5				push af  
375f 3a 73 37			ld a, (.dmark)  
3762 32 62 ee			ld (debug_mark),a  
3765 3a 74 37			ld a, (.dmark+1)  
3768 32 63 ee			ld (debug_mark+1),a  
376b 3a 75 37			ld a, (.dmark+2)  
376e 32 64 ee			ld (debug_mark+2),a  
3771 18 03			jr .pastdmark  
3773 ..			.dmark: db "UN<"  
3776 f1			.pastdmark: pop af  
3777			endm  
# End of macro DMARK
3777					CALLMONITOR 
3777 cd 6f ee			call debug_vector  
377a				endm  
# End of macro CALLMONITOR
377a				endif 
377a c3 79 1f			jp exec1 
377d			 
377d					 
377d			 
377d			 
377d					NEXTW 
377d cd 6c ee			call parse_vector 
3780 c3 f0 1e			jp macro_next 
3783				endm 
# End of macro NEXTW
3783			 
3783			 
3783			.ENDFLOW: 
3783			 
3783			; eof 
3783			 
# End of file forth_words_flow.asm
3783			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3783			include "forth_words_logic.asm" 
3783			 
3783			; | ## Logic Words 
3783			 
3783			.NOT: 
3783				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3783 2d				db WORD_SYS_CORE+25             
3784 d1 37			dw .IS            
3786 04				db 3 + 1 
3787 .. 00			db "NOT",0              
378b				endm 
# End of macro CWHEAD
378b			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
378b					if DEBUG_FORTH_WORDS_KEY 
378b						DMARK "NOT" 
378b f5				push af  
378c 3a a0 37			ld a, (.dmark)  
378f 32 62 ee			ld (debug_mark),a  
3792 3a a1 37			ld a, (.dmark+1)  
3795 32 63 ee			ld (debug_mark+1),a  
3798 3a a2 37			ld a, (.dmark+2)  
379b 32 64 ee			ld (debug_mark+2),a  
379e 18 03			jr .pastdmark  
37a0 ..			.dmark: db "NOT"  
37a3 f1			.pastdmark: pop af  
37a4			endm  
# End of macro DMARK
37a4						CALLMONITOR 
37a4 cd 6f ee			call debug_vector  
37a7				endm  
# End of macro CALLMONITOR
37a7					endif 
37a7					FORTH_DSP 
37a7 cd cb 1c			call macro_forth_dsp 
37aa				endm 
# End of macro FORTH_DSP
37aa 7e					ld a,(hl)	; get type of value on TOS 
37ab fe 02				cp DS_TYPE_INUM  
37ad 28 06				jr z, .noti 
37af					NEXTW 
37af cd 6c ee			call parse_vector 
37b2 c3 f0 1e			jp macro_next 
37b5				endm 
# End of macro NEXTW
37b5			.noti:          FORTH_DSP_VALUEHL 
37b5 cd 05 1d			call macro_dsp_valuehl 
37b8				endm 
# End of macro FORTH_DSP_VALUEHL
37b8			;		push hl 
37b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37b8 cd bd 1d			call macro_forth_dsp_pop 
37bb				endm 
# End of macro FORTH_DSP_POP
37bb			;		pop hl 
37bb 3e 00				ld a,0 
37bd bd					cp l 
37be 28 04				jr z, .not2t 
37c0 2e 00				ld l, 0 
37c2 18 02				jr .notip 
37c4			 
37c4 2e ff		.not2t:		ld l, 255 
37c6			 
37c6 26 00		.notip:		ld h, 0	 
37c8			 
37c8 cd 00 1b				call forth_push_numhl 
37cb					NEXTW 
37cb cd 6c ee			call parse_vector 
37ce c3 f0 1e			jp macro_next 
37d1				endm 
# End of macro NEXTW
37d1			 
37d1			.IS: 
37d1				CWHEAD .LZERO 25 "COMPARE" 7 WORD_FLAG_CODE 
37d1 2d				db WORD_SYS_CORE+25             
37d2 15 38			dw .LZERO            
37d4 08				db 7 + 1 
37d5 .. 00			db "COMPARE",0              
37dd				endm 
# End of macro CWHEAD
37dd			; | COMPARE ( s1 s2  -- f ) Push true if string s1 is the same as s2 | DONE 
37dd					if DEBUG_FORTH_WORDS_KEY 
37dd						DMARK "CMP" 
37dd f5				push af  
37de 3a f2 37			ld a, (.dmark)  
37e1 32 62 ee			ld (debug_mark),a  
37e4 3a f3 37			ld a, (.dmark+1)  
37e7 32 63 ee			ld (debug_mark+1),a  
37ea 3a f4 37			ld a, (.dmark+2)  
37ed 32 64 ee			ld (debug_mark+2),a  
37f0 18 03			jr .pastdmark  
37f2 ..			.dmark: db "CMP"  
37f5 f1			.pastdmark: pop af  
37f6			endm  
# End of macro DMARK
37f6						CALLMONITOR 
37f6 cd 6f ee			call debug_vector  
37f9				endm  
# End of macro CALLMONITOR
37f9					endif 
37f9			 
37f9					FORTH_DSP_VALUEHL 
37f9 cd 05 1d			call macro_dsp_valuehl 
37fc				endm 
# End of macro FORTH_DSP_VALUEHL
37fc			 
37fc e5					push hl 
37fd			 
37fd					FORTH_DSP_VALUEM1 
37fd cd f9 1c			call macro_forth_dsp_value_m1 
3800				endm 
# End of macro FORTH_DSP_VALUEM1
3800			 
3800 d1					pop de 
3801			 
3801					; got pointers to both. Now check. 
3801			 
3801 cd 93 11				call strcmp 
3804				 
3804 26 00				ld h, 0 
3806 2e 00				ld l, 0 
3808 20 02				jr nz, .compnsame 
380a 2e 01				ld l, 1	 
380c			.compnsame: 
380c cd 00 1b				call forth_push_numhl 
380f			 
380f					NEXTW 
380f cd 6c ee			call parse_vector 
3812 c3 f0 1e			jp macro_next 
3815				endm 
# End of macro NEXTW
3815			.LZERO: 
3815				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3815 2d				db WORD_SYS_CORE+25             
3816 22 38			dw .TZERO            
3818 03				db 2 + 1 
3819 .. 00			db "0<",0              
381c				endm 
# End of macro CWHEAD
381c			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
381c					NEXTW 
381c cd 6c ee			call parse_vector 
381f c3 f0 1e			jp macro_next 
3822				endm 
# End of macro NEXTW
3822			.TZERO: 
3822				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3822 2e				db WORD_SYS_CORE+26             
3823 6c 38			dw .LESS            
3825 03				db 2 + 1 
3826 .. 00			db "0=",0              
3829				endm 
# End of macro CWHEAD
3829			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3829				; TODO add floating point number detection 
3829					;v5 FORTH_DSP_VALUE 
3829					if DEBUG_FORTH_WORDS_KEY 
3829						DMARK "0=." 
3829 f5				push af  
382a 3a 3e 38			ld a, (.dmark)  
382d 32 62 ee			ld (debug_mark),a  
3830 3a 3f 38			ld a, (.dmark+1)  
3833 32 63 ee			ld (debug_mark+1),a  
3836 3a 40 38			ld a, (.dmark+2)  
3839 32 64 ee			ld (debug_mark+2),a  
383c 18 03			jr .pastdmark  
383e ..			.dmark: db "0=."  
3841 f1			.pastdmark: pop af  
3842			endm  
# End of macro DMARK
3842						CALLMONITOR 
3842 cd 6f ee			call debug_vector  
3845				endm  
# End of macro CALLMONITOR
3845					endif 
3845					FORTH_DSP 
3845 cd cb 1c			call macro_forth_dsp 
3848				endm 
# End of macro FORTH_DSP
3848 7e					ld a,(hl)	; get type of value on TOS 
3849 fe 02				cp DS_TYPE_INUM  
384b 28 00				jr z, .tz_inum 
384d			 
384d				if FORTH_ENABLE_FLOATMATH 
384d					jr .tz_done 
384d			 
384d				endif 
384d					 
384d			 
384d			.tz_inum: 
384d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
384d cd 05 1d			call macro_dsp_valuehl 
3850				endm 
# End of macro FORTH_DSP_VALUEHL
3850			 
3850			;		push hl 
3850			 
3850					; destroy value TOS 
3850			 
3850					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3850 cd bd 1d			call macro_forth_dsp_pop 
3853				endm 
# End of macro FORTH_DSP_POP
3853			 
3853			;		pop hl 
3853			 
3853 3e 00				ld a,0 
3855			 
3855 bd					cp l 
3856 20 08				jr nz, .tz_notzero 
3858			 
3858 bc					cp h 
3859			 
3859 20 05				jr nz, .tz_notzero 
385b			 
385b			 
385b 21 01 00				ld hl, FORTH_TRUE 
385e 18 03				jr .tz_done 
3860			 
3860 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3863			 
3863					; push value back onto stack for another op etc 
3863			 
3863			.tz_done: 
3863 cd 00 1b				call forth_push_numhl 
3866			 
3866					NEXTW 
3866 cd 6c ee			call parse_vector 
3869 c3 f0 1e			jp macro_next 
386c				endm 
# End of macro NEXTW
386c			.LESS: 
386c				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
386c 2f				db WORD_SYS_CORE+27             
386d d8 38			dw .GT            
386f 02				db 1 + 1 
3870 .. 00			db "<",0              
3872				endm 
# End of macro CWHEAD
3872			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3872				; TODO add floating point number detection 
3872					if DEBUG_FORTH_WORDS_KEY 
3872						DMARK "LES" 
3872 f5				push af  
3873 3a 87 38			ld a, (.dmark)  
3876 32 62 ee			ld (debug_mark),a  
3879 3a 88 38			ld a, (.dmark+1)  
387c 32 63 ee			ld (debug_mark+1),a  
387f 3a 89 38			ld a, (.dmark+2)  
3882 32 64 ee			ld (debug_mark+2),a  
3885 18 03			jr .pastdmark  
3887 ..			.dmark: db "LES"  
388a f1			.pastdmark: pop af  
388b			endm  
# End of macro DMARK
388b						CALLMONITOR 
388b cd 6f ee			call debug_vector  
388e				endm  
# End of macro CALLMONITOR
388e					endif 
388e					FORTH_DSP 
388e cd cb 1c			call macro_forth_dsp 
3891				endm 
# End of macro FORTH_DSP
3891					;v5 FORTH_DSP_VALUE 
3891 7e					ld a,(hl)	; get type of value on TOS 
3892 fe 02				cp DS_TYPE_INUM  
3894 28 00				jr z, .less_inum 
3896			 
3896				if FORTH_ENABLE_FLOATMATH 
3896					jr .less_done 
3896			 
3896				endif 
3896					 
3896			 
3896			.less_inum: 
3896					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3896 cd 05 1d			call macro_dsp_valuehl 
3899				endm 
# End of macro FORTH_DSP_VALUEHL
3899			 
3899 e5					push hl  ; u2 
389a			 
389a					; destroy value TOS 
389a			 
389a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
389a cd bd 1d			call macro_forth_dsp_pop 
389d				endm 
# End of macro FORTH_DSP_POP
389d			 
389d			 
389d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
389d cd 05 1d			call macro_dsp_valuehl 
38a0				endm 
# End of macro FORTH_DSP_VALUEHL
38a0			 
38a0 e5					push hl    ; u1 
38a1			 
38a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38a1 cd bd 1d			call macro_forth_dsp_pop 
38a4				endm 
# End of macro FORTH_DSP_POP
38a4			 
38a4			 
38a4 b7			 or a      ;clear carry flag 
38a5 01 00 00		 ld bc, FORTH_FALSE 
38a8 e1			  pop hl    ; u1 
38a9 d1			  pop de    ; u2 
38aa ed 52		  sbc hl,de 
38ac 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
38ae			 
38ae 01 01 00		 ld bc, FORTH_TRUE 
38b1			.lscont:  
38b1 c5					push bc 
38b2 e1					pop hl 
38b3			 
38b3					if DEBUG_FORTH_WORDS 
38b3						DMARK "LT1" 
38b3 f5				push af  
38b4 3a c8 38			ld a, (.dmark)  
38b7 32 62 ee			ld (debug_mark),a  
38ba 3a c9 38			ld a, (.dmark+1)  
38bd 32 63 ee			ld (debug_mark+1),a  
38c0 3a ca 38			ld a, (.dmark+2)  
38c3 32 64 ee			ld (debug_mark+2),a  
38c6 18 03			jr .pastdmark  
38c8 ..			.dmark: db "LT1"  
38cb f1			.pastdmark: pop af  
38cc			endm  
# End of macro DMARK
38cc						CALLMONITOR 
38cc cd 6f ee			call debug_vector  
38cf				endm  
# End of macro CALLMONITOR
38cf					endif 
38cf cd 00 1b				call forth_push_numhl 
38d2			 
38d2					NEXTW 
38d2 cd 6c ee			call parse_vector 
38d5 c3 f0 1e			jp macro_next 
38d8				endm 
# End of macro NEXTW
38d8			.GT: 
38d8				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
38d8 30				db WORD_SYS_CORE+28             
38d9 44 39			dw .EQUAL            
38db 02				db 1 + 1 
38dc .. 00			db ">",0              
38de				endm 
# End of macro CWHEAD
38de			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
38de				; TODO add floating point number detection 
38de					if DEBUG_FORTH_WORDS_KEY 
38de						DMARK "GRT" 
38de f5				push af  
38df 3a f3 38			ld a, (.dmark)  
38e2 32 62 ee			ld (debug_mark),a  
38e5 3a f4 38			ld a, (.dmark+1)  
38e8 32 63 ee			ld (debug_mark+1),a  
38eb 3a f5 38			ld a, (.dmark+2)  
38ee 32 64 ee			ld (debug_mark+2),a  
38f1 18 03			jr .pastdmark  
38f3 ..			.dmark: db "GRT"  
38f6 f1			.pastdmark: pop af  
38f7			endm  
# End of macro DMARK
38f7						CALLMONITOR 
38f7 cd 6f ee			call debug_vector  
38fa				endm  
# End of macro CALLMONITOR
38fa					endif 
38fa					FORTH_DSP 
38fa cd cb 1c			call macro_forth_dsp 
38fd				endm 
# End of macro FORTH_DSP
38fd					;FORTH_DSP_VALUE 
38fd 7e					ld a,(hl)	; get type of value on TOS 
38fe fe 02				cp DS_TYPE_INUM  
3900 28 00				jr z, .gt_inum 
3902			 
3902				if FORTH_ENABLE_FLOATMATH 
3902					jr .gt_done 
3902			 
3902				endif 
3902					 
3902			 
3902			.gt_inum: 
3902					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3902 cd 05 1d			call macro_dsp_valuehl 
3905				endm 
# End of macro FORTH_DSP_VALUEHL
3905			 
3905 e5					push hl  ; u2 
3906			 
3906					; destroy value TOS 
3906			 
3906					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3906 cd bd 1d			call macro_forth_dsp_pop 
3909				endm 
# End of macro FORTH_DSP_POP
3909			 
3909			 
3909					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3909 cd 05 1d			call macro_dsp_valuehl 
390c				endm 
# End of macro FORTH_DSP_VALUEHL
390c			 
390c e5					push hl    ; u1 
390d			 
390d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
390d cd bd 1d			call macro_forth_dsp_pop 
3910				endm 
# End of macro FORTH_DSP_POP
3910			 
3910			 
3910 b7			 or a      ;clear carry flag 
3911 01 00 00		 ld bc, FORTH_FALSE 
3914 e1			  pop hl    ; u1 
3915 d1			  pop de    ; u2 
3916 ed 52		  sbc hl,de 
3918 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
391a			 
391a 01 01 00		 ld bc, FORTH_TRUE 
391d			.gtcont:  
391d c5					push bc 
391e e1					pop hl 
391f			 
391f					if DEBUG_FORTH_WORDS 
391f						DMARK "GT1" 
391f f5				push af  
3920 3a 34 39			ld a, (.dmark)  
3923 32 62 ee			ld (debug_mark),a  
3926 3a 35 39			ld a, (.dmark+1)  
3929 32 63 ee			ld (debug_mark+1),a  
392c 3a 36 39			ld a, (.dmark+2)  
392f 32 64 ee			ld (debug_mark+2),a  
3932 18 03			jr .pastdmark  
3934 ..			.dmark: db "GT1"  
3937 f1			.pastdmark: pop af  
3938			endm  
# End of macro DMARK
3938						CALLMONITOR 
3938 cd 6f ee			call debug_vector  
393b				endm  
# End of macro CALLMONITOR
393b					endif 
393b cd 00 1b				call forth_push_numhl 
393e			 
393e					NEXTW 
393e cd 6c ee			call parse_vector 
3941 c3 f0 1e			jp macro_next 
3944				endm 
# End of macro NEXTW
3944			.EQUAL: 
3944				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3944 31				db WORD_SYS_CORE+29             
3945 b2 39			dw .ENDLOGIC            
3947 02				db 1 + 1 
3948 .. 00			db "=",0              
394a				endm 
# End of macro CWHEAD
394a			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
394a				; TODO add floating point number detection 
394a					if DEBUG_FORTH_WORDS_KEY 
394a						DMARK "EQ." 
394a f5				push af  
394b 3a 5f 39			ld a, (.dmark)  
394e 32 62 ee			ld (debug_mark),a  
3951 3a 60 39			ld a, (.dmark+1)  
3954 32 63 ee			ld (debug_mark+1),a  
3957 3a 61 39			ld a, (.dmark+2)  
395a 32 64 ee			ld (debug_mark+2),a  
395d 18 03			jr .pastdmark  
395f ..			.dmark: db "EQ."  
3962 f1			.pastdmark: pop af  
3963			endm  
# End of macro DMARK
3963						CALLMONITOR 
3963 cd 6f ee			call debug_vector  
3966				endm  
# End of macro CALLMONITOR
3966					endif 
3966					FORTH_DSP 
3966 cd cb 1c			call macro_forth_dsp 
3969				endm 
# End of macro FORTH_DSP
3969					;v5 FORTH_DSP_VALUE 
3969 7e					ld a,(hl)	; get type of value on TOS 
396a fe 02				cp DS_TYPE_INUM  
396c 28 00				jr z, .eq_inum 
396e			 
396e				if FORTH_ENABLE_FLOATMATH 
396e					jr .eq_done 
396e			 
396e				endif 
396e					 
396e			 
396e			.eq_inum: 
396e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
396e cd 05 1d			call macro_dsp_valuehl 
3971				endm 
# End of macro FORTH_DSP_VALUEHL
3971			 
3971 e5					push hl 
3972			 
3972					; destroy value TOS 
3972			 
3972					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3972 cd bd 1d			call macro_forth_dsp_pop 
3975				endm 
# End of macro FORTH_DSP_POP
3975			 
3975			 
3975					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3975 cd 05 1d			call macro_dsp_valuehl 
3978				endm 
# End of macro FORTH_DSP_VALUEHL
3978			 
3978					; one value on hl get other one back 
3978			 
3978 e5					push hl 
3979			 
3979					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3979 cd bd 1d			call macro_forth_dsp_pop 
397c				endm 
# End of macro FORTH_DSP_POP
397c			 
397c 0e 00				ld c, FORTH_FALSE 
397e			 
397e e1					pop hl 
397f d1					pop de 
3980			 
3980 7b					ld a, e 
3981 bd					cp l 
3982			 
3982 20 06				jr nz, .eq_done 
3984			 
3984 7a					ld a, d 
3985 bc					cp h 
3986			 
3986 20 02				jr nz, .eq_done 
3988			 
3988 0e 01				ld c, FORTH_TRUE 
398a					 
398a			 
398a			 
398a			.eq_done: 
398a			 
398a					; TODO push value back onto stack for another op etc 
398a			 
398a 26 00				ld h, 0 
398c 69					ld l, c 
398d					if DEBUG_FORTH_WORDS 
398d						DMARK "EQ1" 
398d f5				push af  
398e 3a a2 39			ld a, (.dmark)  
3991 32 62 ee			ld (debug_mark),a  
3994 3a a3 39			ld a, (.dmark+1)  
3997 32 63 ee			ld (debug_mark+1),a  
399a 3a a4 39			ld a, (.dmark+2)  
399d 32 64 ee			ld (debug_mark+2),a  
39a0 18 03			jr .pastdmark  
39a2 ..			.dmark: db "EQ1"  
39a5 f1			.pastdmark: pop af  
39a6			endm  
# End of macro DMARK
39a6						CALLMONITOR 
39a6 cd 6f ee			call debug_vector  
39a9				endm  
# End of macro CALLMONITOR
39a9					endif 
39a9 cd 00 1b				call forth_push_numhl 
39ac			 
39ac					NEXTW 
39ac cd 6c ee			call parse_vector 
39af c3 f0 1e			jp macro_next 
39b2				endm 
# End of macro NEXTW
39b2			 
39b2			 
39b2			.ENDLOGIC: 
39b2			; eof 
39b2			 
39b2			 
# End of file forth_words_logic.asm
39b2			include "forth_words_maths.asm" 
39b2			 
39b2			; | ## Maths Words 
39b2			 
39b2			.PLUS:	 
39b2				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
39b2 15				db WORD_SYS_CORE+1             
39b3 16 3a			dw .NEG            
39b5 02				db 1 + 1 
39b6 .. 00			db "+",0              
39b8				endm 
# End of macro CWHEAD
39b8			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
39b8					if DEBUG_FORTH_WORDS_KEY 
39b8						DMARK "PLU" 
39b8 f5				push af  
39b9 3a cd 39			ld a, (.dmark)  
39bc 32 62 ee			ld (debug_mark),a  
39bf 3a ce 39			ld a, (.dmark+1)  
39c2 32 63 ee			ld (debug_mark+1),a  
39c5 3a cf 39			ld a, (.dmark+2)  
39c8 32 64 ee			ld (debug_mark+2),a  
39cb 18 03			jr .pastdmark  
39cd ..			.dmark: db "PLU"  
39d0 f1			.pastdmark: pop af  
39d1			endm  
# End of macro DMARK
39d1						CALLMONITOR 
39d1 cd 6f ee			call debug_vector  
39d4				endm  
# End of macro CALLMONITOR
39d4					endif 
39d4					; add top two values and push back result 
39d4			 
39d4					;for v5 FORTH_DSP_VALUE 
39d4					FORTH_DSP 
39d4 cd cb 1c			call macro_forth_dsp 
39d7				endm 
# End of macro FORTH_DSP
39d7 7e					ld a,(hl)	; get type of value on TOS 
39d8 fe 02				cp DS_TYPE_INUM  
39da 28 06				jr z, .dot_inum 
39dc			 
39dc					NEXTW 
39dc cd 6c ee			call parse_vector 
39df c3 f0 1e			jp macro_next 
39e2				endm 
# End of macro NEXTW
39e2			 
39e2			; float maths 
39e2			 
39e2				if FORTH_ENABLE_FLOATMATH 
39e2						inc hl      ; now at start of numeric as string 
39e2			 
39e2					if DEBUG_FORTH_MATHS 
39e2						DMARK "ADD" 
39e2				CALLMONITOR 
39e2					endif 
39e2			 
39e2					;ld ix, hl 
39e2					call CON 
39e2			 
39e2			 
39e2					push hl 
39e2					 
39e2					 
39e2			 
39e2						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
39e2			 
39e2					; get next number 
39e2			 
39e2						FORTH_DSP_VALUE 
39e2			 
39e2						inc hl      ; now at start of numeric as string 
39e2			 
39e2					;ld ix, hl 
39e2					call CON 
39e2			 
39e2					push hl 
39e2			 
39e2			 
39e2						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39e2			 
39e2						; TODO do add 
39e2			 
39e2						call IADD 
39e2			 
39e2						; TODO get result back as ascii 
39e2			 
39e2						; TODO push result  
39e2			 
39e2			 
39e2			 
39e2						jr .dot_done 
39e2				endif 
39e2			 
39e2			.dot_inum: 
39e2			 
39e2			 
39e2					if DEBUG_FORTH_DOT 
39e2						DMARK "+IT" 
39e2 f5				push af  
39e3 3a f7 39			ld a, (.dmark)  
39e6 32 62 ee			ld (debug_mark),a  
39e9 3a f8 39			ld a, (.dmark+1)  
39ec 32 63 ee			ld (debug_mark+1),a  
39ef 3a f9 39			ld a, (.dmark+2)  
39f2 32 64 ee			ld (debug_mark+2),a  
39f5 18 03			jr .pastdmark  
39f7 ..			.dmark: db "+IT"  
39fa f1			.pastdmark: pop af  
39fb			endm  
# End of macro DMARK
39fb				CALLMONITOR 
39fb cd 6f ee			call debug_vector  
39fe				endm  
# End of macro CALLMONITOR
39fe					endif 
39fe			 
39fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39fe cd 05 1d			call macro_dsp_valuehl 
3a01				endm 
# End of macro FORTH_DSP_VALUEHL
3a01			 
3a01				; TODO add floating point number detection 
3a01			 
3a01 e5					push hl 
3a02			 
3a02					; destroy value TOS 
3a02			 
3a02					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a02 cd bd 1d			call macro_forth_dsp_pop 
3a05				endm 
# End of macro FORTH_DSP_POP
3a05			 
3a05			 
3a05					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a05 cd 05 1d			call macro_dsp_valuehl 
3a08				endm 
# End of macro FORTH_DSP_VALUEHL
3a08			 
3a08					; one value on hl get other one back 
3a08			 
3a08 d1					pop de 
3a09			 
3a09					; do the add 
3a09			 
3a09 19					add hl,de 
3a0a			 
3a0a					; save it 
3a0a			 
3a0a			;		push hl	 
3a0a			 
3a0a					; 
3a0a			 
3a0a					; destroy value TOS 
3a0a			 
3a0a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a0a cd bd 1d			call macro_forth_dsp_pop 
3a0d				endm 
# End of macro FORTH_DSP_POP
3a0d			 
3a0d					; TODO push value back onto stack for another op etc 
3a0d			 
3a0d			;		pop hl 
3a0d			 
3a0d			.dot_done: 
3a0d cd 00 1b				call forth_push_numhl 
3a10			 
3a10					NEXTW 
3a10 cd 6c ee			call parse_vector 
3a13 c3 f0 1e			jp macro_next 
3a16				endm 
# End of macro NEXTW
3a16			.NEG: 
3a16			 
3a16				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3a16 17				db WORD_SYS_CORE+3             
3a17 5f 3a			dw .DIV            
3a19 02				db 1 + 1 
3a1a .. 00			db "-",0              
3a1c				endm 
# End of macro CWHEAD
3a1c			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3a1c					if DEBUG_FORTH_WORDS_KEY 
3a1c						DMARK "SUB" 
3a1c f5				push af  
3a1d 3a 31 3a			ld a, (.dmark)  
3a20 32 62 ee			ld (debug_mark),a  
3a23 3a 32 3a			ld a, (.dmark+1)  
3a26 32 63 ee			ld (debug_mark+1),a  
3a29 3a 33 3a			ld a, (.dmark+2)  
3a2c 32 64 ee			ld (debug_mark+2),a  
3a2f 18 03			jr .pastdmark  
3a31 ..			.dmark: db "SUB"  
3a34 f1			.pastdmark: pop af  
3a35			endm  
# End of macro DMARK
3a35						CALLMONITOR 
3a35 cd 6f ee			call debug_vector  
3a38				endm  
# End of macro CALLMONITOR
3a38					endif 
3a38			 
3a38			 
3a38				; TODO add floating point number detection 
3a38					; v5 FORTH_DSP_VALUE 
3a38					FORTH_DSP 
3a38 cd cb 1c			call macro_forth_dsp 
3a3b				endm 
# End of macro FORTH_DSP
3a3b 7e					ld a,(hl)	; get type of value on TOS 
3a3c fe 02				cp DS_TYPE_INUM  
3a3e 28 06				jr z, .neg_inum 
3a40			 
3a40					NEXTW 
3a40 cd 6c ee			call parse_vector 
3a43 c3 f0 1e			jp macro_next 
3a46				endm 
# End of macro NEXTW
3a46			 
3a46			; float maths 
3a46			 
3a46				if FORTH_ENABLE_FLOATMATH 
3a46					jr .neg_done 
3a46			 
3a46				endif 
3a46					 
3a46			 
3a46			.neg_inum: 
3a46					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a46 cd 05 1d			call macro_dsp_valuehl 
3a49				endm 
# End of macro FORTH_DSP_VALUEHL
3a49			 
3a49 e5					push hl 
3a4a			 
3a4a					; destroy value TOS 
3a4a			 
3a4a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a4a cd bd 1d			call macro_forth_dsp_pop 
3a4d				endm 
# End of macro FORTH_DSP_POP
3a4d			 
3a4d			 
3a4d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a4d cd 05 1d			call macro_dsp_valuehl 
3a50				endm 
# End of macro FORTH_DSP_VALUEHL
3a50			 
3a50					; one value on hl get other one back 
3a50			 
3a50 d1					pop de 
3a51			 
3a51					; do the sub 
3a51			;		ex de, hl 
3a51			 
3a51 ed 52				sbc hl,de 
3a53			 
3a53					; save it 
3a53			 
3a53			;		push hl	 
3a53			 
3a53					; 
3a53			 
3a53					; destroy value TOS 
3a53			 
3a53					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a53 cd bd 1d			call macro_forth_dsp_pop 
3a56				endm 
# End of macro FORTH_DSP_POP
3a56			 
3a56					; TODO push value back onto stack for another op etc 
3a56			 
3a56			;		pop hl 
3a56			 
3a56 cd 00 1b				call forth_push_numhl 
3a59			.neg_done: 
3a59			 
3a59					NEXTW 
3a59 cd 6c ee			call parse_vector 
3a5c c3 f0 1e			jp macro_next 
3a5f				endm 
# End of macro NEXTW
3a5f			.DIV: 
3a5f				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3a5f 18				db WORD_SYS_CORE+4             
3a60 b2 3a			dw .MUL            
3a62 02				db 1 + 1 
3a63 .. 00			db "/",0              
3a65				endm 
# End of macro CWHEAD
3a65			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3a65					if DEBUG_FORTH_WORDS_KEY 
3a65						DMARK "DIV" 
3a65 f5				push af  
3a66 3a 7a 3a			ld a, (.dmark)  
3a69 32 62 ee			ld (debug_mark),a  
3a6c 3a 7b 3a			ld a, (.dmark+1)  
3a6f 32 63 ee			ld (debug_mark+1),a  
3a72 3a 7c 3a			ld a, (.dmark+2)  
3a75 32 64 ee			ld (debug_mark+2),a  
3a78 18 03			jr .pastdmark  
3a7a ..			.dmark: db "DIV"  
3a7d f1			.pastdmark: pop af  
3a7e			endm  
# End of macro DMARK
3a7e						CALLMONITOR 
3a7e cd 6f ee			call debug_vector  
3a81				endm  
# End of macro CALLMONITOR
3a81					endif 
3a81				; TODO add floating point number detection 
3a81					; v5 FORTH_DSP_VALUE 
3a81					FORTH_DSP 
3a81 cd cb 1c			call macro_forth_dsp 
3a84				endm 
# End of macro FORTH_DSP
3a84 7e					ld a,(hl)	; get type of value on TOS 
3a85 fe 02				cp DS_TYPE_INUM  
3a87 28 06				jr z, .div_inum 
3a89			 
3a89				if FORTH_ENABLE_FLOATMATH 
3a89					jr .div_done 
3a89			 
3a89				endif 
3a89					NEXTW 
3a89 cd 6c ee			call parse_vector 
3a8c c3 f0 1e			jp macro_next 
3a8f				endm 
# End of macro NEXTW
3a8f			.div_inum: 
3a8f			 
3a8f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a8f cd 05 1d			call macro_dsp_valuehl 
3a92				endm 
# End of macro FORTH_DSP_VALUEHL
3a92			 
3a92 e5					push hl    ; to go to bc 
3a93			 
3a93					; destroy value TOS 
3a93			 
3a93					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a93 cd bd 1d			call macro_forth_dsp_pop 
3a96				endm 
# End of macro FORTH_DSP_POP
3a96			 
3a96			 
3a96					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a96 cd 05 1d			call macro_dsp_valuehl 
3a99				endm 
# End of macro FORTH_DSP_VALUEHL
3a99			 
3a99					; hl to go to de 
3a99			 
3a99 e5					push hl 
3a9a			 
3a9a c1					pop bc 
3a9b d1					pop de		 
3a9c			 
3a9c			 
3a9c					if DEBUG_FORTH_MATHS 
3a9c						DMARK "DIV" 
3a9c				CALLMONITOR 
3a9c					endif 
3a9c					; one value on hl but move to a get other one back 
3a9c			 
3a9c			        
3a9c cd 52 0d			call Div16 
3a9f			 
3a9f			;	push af	 
3a9f e5				push hl 
3aa0 c5				push bc 
3aa1			 
3aa1					if DEBUG_FORTH_MATHS 
3aa1						DMARK "DI1" 
3aa1				CALLMONITOR 
3aa1					endif 
3aa1			 
3aa1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aa1 cd bd 1d			call macro_forth_dsp_pop 
3aa4				endm 
# End of macro FORTH_DSP_POP
3aa4			 
3aa4			 
3aa4			 
3aa4 e1					pop hl    ; result 
3aa5			 
3aa5 cd 00 1b				call forth_push_numhl 
3aa8			 
3aa8 e1					pop hl    ; reminder 
3aa9			;		ld h,0 
3aa9			;		ld l,d 
3aa9			 
3aa9 cd 00 1b				call forth_push_numhl 
3aac			.div_done: 
3aac					NEXTW 
3aac cd 6c ee			call parse_vector 
3aaf c3 f0 1e			jp macro_next 
3ab2				endm 
# End of macro NEXTW
3ab2			.MUL: 
3ab2				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3ab2 19				db WORD_SYS_CORE+5             
3ab3 fd 3a			dw .MIN            
3ab5 02				db 1 + 1 
3ab6 .. 00			db "*",0              
3ab8				endm 
# End of macro CWHEAD
3ab8			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3ab8				; TODO add floating point number detection 
3ab8					if DEBUG_FORTH_WORDS_KEY 
3ab8						DMARK "MUL" 
3ab8 f5				push af  
3ab9 3a cd 3a			ld a, (.dmark)  
3abc 32 62 ee			ld (debug_mark),a  
3abf 3a ce 3a			ld a, (.dmark+1)  
3ac2 32 63 ee			ld (debug_mark+1),a  
3ac5 3a cf 3a			ld a, (.dmark+2)  
3ac8 32 64 ee			ld (debug_mark+2),a  
3acb 18 03			jr .pastdmark  
3acd ..			.dmark: db "MUL"  
3ad0 f1			.pastdmark: pop af  
3ad1			endm  
# End of macro DMARK
3ad1						CALLMONITOR 
3ad1 cd 6f ee			call debug_vector  
3ad4				endm  
# End of macro CALLMONITOR
3ad4					endif 
3ad4					FORTH_DSP 
3ad4 cd cb 1c			call macro_forth_dsp 
3ad7				endm 
# End of macro FORTH_DSP
3ad7					; v5 FORTH_DSP_VALUE 
3ad7 7e					ld a,(hl)	; get type of value on TOS 
3ad8 fe 02				cp DS_TYPE_INUM  
3ada 28 06				jr z, .mul_inum 
3adc			 
3adc				if FORTH_ENABLE_FLOATMATH 
3adc					jr .mul_done 
3adc			 
3adc				endif 
3adc			 
3adc					NEXTW 
3adc cd 6c ee			call parse_vector 
3adf c3 f0 1e			jp macro_next 
3ae2				endm 
# End of macro NEXTW
3ae2			.mul_inum:	 
3ae2			 
3ae2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ae2 cd 05 1d			call macro_dsp_valuehl 
3ae5				endm 
# End of macro FORTH_DSP_VALUEHL
3ae5			 
3ae5 e5					push hl 
3ae6			 
3ae6					; destroy value TOS 
3ae6			 
3ae6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ae6 cd bd 1d			call macro_forth_dsp_pop 
3ae9				endm 
# End of macro FORTH_DSP_POP
3ae9			 
3ae9			 
3ae9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ae9 cd 05 1d			call macro_dsp_valuehl 
3aec				endm 
# End of macro FORTH_DSP_VALUEHL
3aec			 
3aec					; one value on hl but move to a get other one back 
3aec			 
3aec 7d					ld a, l 
3aed			 
3aed d1					pop de 
3aee			 
3aee					; do the mull 
3aee			;		ex de, hl 
3aee			 
3aee cd 78 0d				call Mult16 
3af1					; save it 
3af1			 
3af1			;		push hl	 
3af1			 
3af1					; 
3af1			 
3af1					; destroy value TOS 
3af1			 
3af1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3af1 cd bd 1d			call macro_forth_dsp_pop 
3af4				endm 
# End of macro FORTH_DSP_POP
3af4			 
3af4					; TODO push value back onto stack for another op etc 
3af4			 
3af4			;		pop hl 
3af4			 
3af4 cd 00 1b				call forth_push_numhl 
3af7			 
3af7			.mul_done: 
3af7					NEXTW 
3af7 cd 6c ee			call parse_vector 
3afa c3 f0 1e			jp macro_next 
3afd				endm 
# End of macro NEXTW
3afd			 
3afd			 
3afd			 
3afd			 
3afd			.MIN: 
3afd				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3afd 49				db WORD_SYS_CORE+53             
3afe 84 3b			dw .MAX            
3b00 04				db 3 + 1 
3b01 .. 00			db "MIN",0              
3b05				endm 
# End of macro CWHEAD
3b05			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3b05					if DEBUG_FORTH_WORDS_KEY 
3b05						DMARK "MIN" 
3b05 f5				push af  
3b06 3a 1a 3b			ld a, (.dmark)  
3b09 32 62 ee			ld (debug_mark),a  
3b0c 3a 1b 3b			ld a, (.dmark+1)  
3b0f 32 63 ee			ld (debug_mark+1),a  
3b12 3a 1c 3b			ld a, (.dmark+2)  
3b15 32 64 ee			ld (debug_mark+2),a  
3b18 18 03			jr .pastdmark  
3b1a ..			.dmark: db "MIN"  
3b1d f1			.pastdmark: pop af  
3b1e			endm  
# End of macro DMARK
3b1e						CALLMONITOR 
3b1e cd 6f ee			call debug_vector  
3b21				endm  
# End of macro CALLMONITOR
3b21					endif 
3b21					; get u2 
3b21			 
3b21					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b21 cd 05 1d			call macro_dsp_valuehl 
3b24				endm 
# End of macro FORTH_DSP_VALUEHL
3b24			 
3b24 e5					push hl   ; u2 
3b25			 
3b25					; destroy value TOS 
3b25			 
3b25					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b25 cd bd 1d			call macro_forth_dsp_pop 
3b28				endm 
# End of macro FORTH_DSP_POP
3b28			 
3b28					; get u1 
3b28			 
3b28					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b28 cd 05 1d			call macro_dsp_valuehl 
3b2b				endm 
# End of macro FORTH_DSP_VALUEHL
3b2b			 
3b2b e5					push hl  ; u1 
3b2c			 
3b2c					; destroy value TOS 
3b2c			 
3b2c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b2c cd bd 1d			call macro_forth_dsp_pop 
3b2f				endm 
# End of macro FORTH_DSP_POP
3b2f			 
3b2f b7			 or a      ;clear carry flag 
3b30 e1			  pop hl    ; u1 
3b31 d1			  pop de    ; u2 
3b32 e5				push hl   ; saved in case hl is lowest 
3b33 ed 52		  sbc hl,de 
3b35 30 26		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3b37			 
3b37 e1				pop hl 
3b38					if DEBUG_FORTH_WORDS 
3b38						DMARK "MIN" 
3b38 f5				push af  
3b39 3a 4d 3b			ld a, (.dmark)  
3b3c 32 62 ee			ld (debug_mark),a  
3b3f 3a 4e 3b			ld a, (.dmark+1)  
3b42 32 63 ee			ld (debug_mark+1),a  
3b45 3a 4f 3b			ld a, (.dmark+2)  
3b48 32 64 ee			ld (debug_mark+2),a  
3b4b 18 03			jr .pastdmark  
3b4d ..			.dmark: db "MIN"  
3b50 f1			.pastdmark: pop af  
3b51			endm  
# End of macro DMARK
3b51						CALLMONITOR 
3b51 cd 6f ee			call debug_vector  
3b54				endm  
# End of macro CALLMONITOR
3b54					endif 
3b54 cd 00 1b				call forth_push_numhl 
3b57			 
3b57				       NEXTW 
3b57 cd 6c ee			call parse_vector 
3b5a c3 f0 1e			jp macro_next 
3b5d				endm 
# End of macro NEXTW
3b5d			 
3b5d			.mincont:  
3b5d c1				pop bc   ; tidy up 
3b5e eb				ex de , hl  
3b5f					if DEBUG_FORTH_WORDS 
3b5f						DMARK "MI1" 
3b5f f5				push af  
3b60 3a 74 3b			ld a, (.dmark)  
3b63 32 62 ee			ld (debug_mark),a  
3b66 3a 75 3b			ld a, (.dmark+1)  
3b69 32 63 ee			ld (debug_mark+1),a  
3b6c 3a 76 3b			ld a, (.dmark+2)  
3b6f 32 64 ee			ld (debug_mark+2),a  
3b72 18 03			jr .pastdmark  
3b74 ..			.dmark: db "MI1"  
3b77 f1			.pastdmark: pop af  
3b78			endm  
# End of macro DMARK
3b78						CALLMONITOR 
3b78 cd 6f ee			call debug_vector  
3b7b				endm  
# End of macro CALLMONITOR
3b7b					endif 
3b7b cd 00 1b				call forth_push_numhl 
3b7e			 
3b7e				       NEXTW 
3b7e cd 6c ee			call parse_vector 
3b81 c3 f0 1e			jp macro_next 
3b84				endm 
# End of macro NEXTW
3b84			.MAX: 
3b84				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3b84 4a				db WORD_SYS_CORE+54             
3b85 0b 3c			dw .RND16            
3b87 04				db 3 + 1 
3b88 .. 00			db "MAX",0              
3b8c				endm 
# End of macro CWHEAD
3b8c			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3b8c					if DEBUG_FORTH_WORDS_KEY 
3b8c						DMARK "MAX" 
3b8c f5				push af  
3b8d 3a a1 3b			ld a, (.dmark)  
3b90 32 62 ee			ld (debug_mark),a  
3b93 3a a2 3b			ld a, (.dmark+1)  
3b96 32 63 ee			ld (debug_mark+1),a  
3b99 3a a3 3b			ld a, (.dmark+2)  
3b9c 32 64 ee			ld (debug_mark+2),a  
3b9f 18 03			jr .pastdmark  
3ba1 ..			.dmark: db "MAX"  
3ba4 f1			.pastdmark: pop af  
3ba5			endm  
# End of macro DMARK
3ba5						CALLMONITOR 
3ba5 cd 6f ee			call debug_vector  
3ba8				endm  
# End of macro CALLMONITOR
3ba8					endif 
3ba8					; get u2 
3ba8			 
3ba8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ba8 cd 05 1d			call macro_dsp_valuehl 
3bab				endm 
# End of macro FORTH_DSP_VALUEHL
3bab			 
3bab e5					push hl   ; u2 
3bac			 
3bac					; destroy value TOS 
3bac			 
3bac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bac cd bd 1d			call macro_forth_dsp_pop 
3baf				endm 
# End of macro FORTH_DSP_POP
3baf			 
3baf					; get u1 
3baf			 
3baf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3baf cd 05 1d			call macro_dsp_valuehl 
3bb2				endm 
# End of macro FORTH_DSP_VALUEHL
3bb2			 
3bb2 e5					push hl  ; u1 
3bb3			 
3bb3					; destroy value TOS 
3bb3			 
3bb3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bb3 cd bd 1d			call macro_forth_dsp_pop 
3bb6				endm 
# End of macro FORTH_DSP_POP
3bb6			 
3bb6 b7			 or a      ;clear carry flag 
3bb7 e1			  pop hl    ; u1 
3bb8 d1			  pop de    ; u2 
3bb9 e5				push hl   ; saved in case hl is lowest 
3bba ed 52		  sbc hl,de 
3bbc 38 26		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3bbe			 
3bbe e1				pop hl 
3bbf					if DEBUG_FORTH_WORDS 
3bbf						DMARK "MAX" 
3bbf f5				push af  
3bc0 3a d4 3b			ld a, (.dmark)  
3bc3 32 62 ee			ld (debug_mark),a  
3bc6 3a d5 3b			ld a, (.dmark+1)  
3bc9 32 63 ee			ld (debug_mark+1),a  
3bcc 3a d6 3b			ld a, (.dmark+2)  
3bcf 32 64 ee			ld (debug_mark+2),a  
3bd2 18 03			jr .pastdmark  
3bd4 ..			.dmark: db "MAX"  
3bd7 f1			.pastdmark: pop af  
3bd8			endm  
# End of macro DMARK
3bd8						CALLMONITOR 
3bd8 cd 6f ee			call debug_vector  
3bdb				endm  
# End of macro CALLMONITOR
3bdb					endif 
3bdb cd 00 1b				call forth_push_numhl 
3bde			 
3bde				       NEXTW 
3bde cd 6c ee			call parse_vector 
3be1 c3 f0 1e			jp macro_next 
3be4				endm 
# End of macro NEXTW
3be4			 
3be4			.maxcont:  
3be4 c1				pop bc   ; tidy up 
3be5 eb				ex de , hl  
3be6					if DEBUG_FORTH_WORDS 
3be6						DMARK "MA1" 
3be6 f5				push af  
3be7 3a fb 3b			ld a, (.dmark)  
3bea 32 62 ee			ld (debug_mark),a  
3bed 3a fc 3b			ld a, (.dmark+1)  
3bf0 32 63 ee			ld (debug_mark+1),a  
3bf3 3a fd 3b			ld a, (.dmark+2)  
3bf6 32 64 ee			ld (debug_mark+2),a  
3bf9 18 03			jr .pastdmark  
3bfb ..			.dmark: db "MA1"  
3bfe f1			.pastdmark: pop af  
3bff			endm  
# End of macro DMARK
3bff						CALLMONITOR 
3bff cd 6f ee			call debug_vector  
3c02				endm  
# End of macro CALLMONITOR
3c02					endif 
3c02 cd 00 1b				call forth_push_numhl 
3c05				       NEXTW 
3c05 cd 6c ee			call parse_vector 
3c08 c3 f0 1e			jp macro_next 
3c0b				endm 
# End of macro NEXTW
3c0b			 
3c0b			.RND16: 
3c0b				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3c0b 4e				db WORD_SYS_CORE+58             
3c0c 3d 3c			dw .RND8            
3c0e 06				db 5 + 1 
3c0f .. 00			db "RND16",0              
3c15				endm 
# End of macro CWHEAD
3c15			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3c15					if DEBUG_FORTH_WORDS_KEY 
3c15						DMARK "R16" 
3c15 f5				push af  
3c16 3a 2a 3c			ld a, (.dmark)  
3c19 32 62 ee			ld (debug_mark),a  
3c1c 3a 2b 3c			ld a, (.dmark+1)  
3c1f 32 63 ee			ld (debug_mark+1),a  
3c22 3a 2c 3c			ld a, (.dmark+2)  
3c25 32 64 ee			ld (debug_mark+2),a  
3c28 18 03			jr .pastdmark  
3c2a ..			.dmark: db "R16"  
3c2d f1			.pastdmark: pop af  
3c2e			endm  
# End of macro DMARK
3c2e						CALLMONITOR 
3c2e cd 6f ee			call debug_vector  
3c31				endm  
# End of macro CALLMONITOR
3c31					endif 
3c31 cd 1c 0d				call prng16  
3c34 cd 00 1b				call forth_push_numhl 
3c37				       NEXTW 
3c37 cd 6c ee			call parse_vector 
3c3a c3 f0 1e			jp macro_next 
3c3d				endm 
# End of macro NEXTW
3c3d			.RND8: 
3c3d				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3c3d 60				db WORD_SYS_CORE+76             
3c3e 75 3c			dw .RND            
3c40 05				db 4 + 1 
3c41 .. 00			db "RND8",0              
3c46				endm 
# End of macro CWHEAD
3c46			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3c46					if DEBUG_FORTH_WORDS_KEY 
3c46						DMARK "RN8" 
3c46 f5				push af  
3c47 3a 5b 3c			ld a, (.dmark)  
3c4a 32 62 ee			ld (debug_mark),a  
3c4d 3a 5c 3c			ld a, (.dmark+1)  
3c50 32 63 ee			ld (debug_mark+1),a  
3c53 3a 5d 3c			ld a, (.dmark+2)  
3c56 32 64 ee			ld (debug_mark+2),a  
3c59 18 03			jr .pastdmark  
3c5b ..			.dmark: db "RN8"  
3c5e f1			.pastdmark: pop af  
3c5f			endm  
# End of macro DMARK
3c5f						CALLMONITOR 
3c5f cd 6f ee			call debug_vector  
3c62				endm  
# End of macro CALLMONITOR
3c62					endif 
3c62 2a a0 eb				ld hl,(xrandc) 
3c65 23					inc hl 
3c66 cd 36 0d				call xrnd 
3c69 6f					ld l,a	 
3c6a 26 00				ld h,0 
3c6c cd 00 1b				call forth_push_numhl 
3c6f				       NEXTW 
3c6f cd 6c ee			call parse_vector 
3c72 c3 f0 1e			jp macro_next 
3c75				endm 
# End of macro NEXTW
3c75			.RND: 
3c75				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3c75 60				db WORD_SYS_CORE+76             
3c76 7e 3d			dw .ENDMATHS            
3c78 04				db 3 + 1 
3c79 .. 00			db "RND",0              
3c7d				endm 
# End of macro CWHEAD
3c7d			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3c7d			 
3c7d					if DEBUG_FORTH_WORDS_KEY 
3c7d						DMARK "RND" 
3c7d f5				push af  
3c7e 3a 92 3c			ld a, (.dmark)  
3c81 32 62 ee			ld (debug_mark),a  
3c84 3a 93 3c			ld a, (.dmark+1)  
3c87 32 63 ee			ld (debug_mark+1),a  
3c8a 3a 94 3c			ld a, (.dmark+2)  
3c8d 32 64 ee			ld (debug_mark+2),a  
3c90 18 03			jr .pastdmark  
3c92 ..			.dmark: db "RND"  
3c95 f1			.pastdmark: pop af  
3c96			endm  
# End of macro DMARK
3c96						CALLMONITOR 
3c96 cd 6f ee			call debug_vector  
3c99				endm  
# End of macro CALLMONITOR
3c99					endif 
3c99					 
3c99					FORTH_DSP_VALUEHL    ; upper range 
3c99 cd 05 1d			call macro_dsp_valuehl 
3c9c				endm 
# End of macro FORTH_DSP_VALUEHL
3c9c			 
3c9c 22 a4 eb				ld (LFSRSeed), hl	 
3c9f			 
3c9f					if DEBUG_FORTH_WORDS 
3c9f						DMARK "RN1" 
3c9f f5				push af  
3ca0 3a b4 3c			ld a, (.dmark)  
3ca3 32 62 ee			ld (debug_mark),a  
3ca6 3a b5 3c			ld a, (.dmark+1)  
3ca9 32 63 ee			ld (debug_mark+1),a  
3cac 3a b6 3c			ld a, (.dmark+2)  
3caf 32 64 ee			ld (debug_mark+2),a  
3cb2 18 03			jr .pastdmark  
3cb4 ..			.dmark: db "RN1"  
3cb7 f1			.pastdmark: pop af  
3cb8			endm  
# End of macro DMARK
3cb8						CALLMONITOR 
3cb8 cd 6f ee			call debug_vector  
3cbb				endm  
# End of macro CALLMONITOR
3cbb					endif 
3cbb					FORTH_DSP_POP 
3cbb cd bd 1d			call macro_forth_dsp_pop 
3cbe				endm 
# End of macro FORTH_DSP_POP
3cbe			 
3cbe					FORTH_DSP_VALUEHL    ; low range 
3cbe cd 05 1d			call macro_dsp_valuehl 
3cc1				endm 
# End of macro FORTH_DSP_VALUEHL
3cc1			 
3cc1					if DEBUG_FORTH_WORDS 
3cc1						DMARK "RN2" 
3cc1 f5				push af  
3cc2 3a d6 3c			ld a, (.dmark)  
3cc5 32 62 ee			ld (debug_mark),a  
3cc8 3a d7 3c			ld a, (.dmark+1)  
3ccb 32 63 ee			ld (debug_mark+1),a  
3cce 3a d8 3c			ld a, (.dmark+2)  
3cd1 32 64 ee			ld (debug_mark+2),a  
3cd4 18 03			jr .pastdmark  
3cd6 ..			.dmark: db "RN2"  
3cd9 f1			.pastdmark: pop af  
3cda			endm  
# End of macro DMARK
3cda						CALLMONITOR 
3cda cd 6f ee			call debug_vector  
3cdd				endm  
# End of macro CALLMONITOR
3cdd					endif 
3cdd 22 a6 eb				ld (LFSRSeed+2), hl 
3ce0			 
3ce0					FORTH_DSP_POP 
3ce0 cd bd 1d			call macro_forth_dsp_pop 
3ce3				endm 
# End of macro FORTH_DSP_POP
3ce3			 
3ce3 e5					push hl 
3ce4			 
3ce4 e1			.inrange:	pop hl 
3ce5 cd 1c 0d				call prng16  
3ce8					if DEBUG_FORTH_WORDS 
3ce8						DMARK "RN3" 
3ce8 f5				push af  
3ce9 3a fd 3c			ld a, (.dmark)  
3cec 32 62 ee			ld (debug_mark),a  
3cef 3a fe 3c			ld a, (.dmark+1)  
3cf2 32 63 ee			ld (debug_mark+1),a  
3cf5 3a ff 3c			ld a, (.dmark+2)  
3cf8 32 64 ee			ld (debug_mark+2),a  
3cfb 18 03			jr .pastdmark  
3cfd ..			.dmark: db "RN3"  
3d00 f1			.pastdmark: pop af  
3d01			endm  
# End of macro DMARK
3d01						CALLMONITOR 
3d01 cd 6f ee			call debug_vector  
3d04				endm  
# End of macro CALLMONITOR
3d04					endif 
3d04					 
3d04					; if the range is 8bit knock out the high byte 
3d04			 
3d04 ed 5b a4 eb			ld de, (LFSRSeed)     ; check high level 
3d08			 
3d08 3e 00				ld a, 0 
3d0a ba					cp d  
3d0b 20 1e				jr nz, .hirange 
3d0d 26 00				ld h, 0   ; knock it down to 8bit 
3d0f			 
3d0f					if DEBUG_FORTH_WORDS 
3d0f						DMARK "RNk" 
3d0f f5				push af  
3d10 3a 24 3d			ld a, (.dmark)  
3d13 32 62 ee			ld (debug_mark),a  
3d16 3a 25 3d			ld a, (.dmark+1)  
3d19 32 63 ee			ld (debug_mark+1),a  
3d1c 3a 26 3d			ld a, (.dmark+2)  
3d1f 32 64 ee			ld (debug_mark+2),a  
3d22 18 03			jr .pastdmark  
3d24 ..			.dmark: db "RNk"  
3d27 f1			.pastdmark: pop af  
3d28			endm  
# End of macro DMARK
3d28						CALLMONITOR 
3d28 cd 6f ee			call debug_vector  
3d2b				endm  
# End of macro CALLMONITOR
3d2b					endif 
3d2b			.hirange:   
3d2b e5					push hl  
3d2c b7					or a  
3d2d ed 52		                sbc hl, de 
3d2f			 
3d2f					;call cmp16 
3d2f			 
3d2f 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3d31 e1					pop hl 
3d32 e5					push hl 
3d33			 
3d33					if DEBUG_FORTH_WORDS 
3d33						DMARK "RN4" 
3d33 f5				push af  
3d34 3a 48 3d			ld a, (.dmark)  
3d37 32 62 ee			ld (debug_mark),a  
3d3a 3a 49 3d			ld a, (.dmark+1)  
3d3d 32 63 ee			ld (debug_mark+1),a  
3d40 3a 4a 3d			ld a, (.dmark+2)  
3d43 32 64 ee			ld (debug_mark+2),a  
3d46 18 03			jr .pastdmark  
3d48 ..			.dmark: db "RN4"  
3d4b f1			.pastdmark: pop af  
3d4c			endm  
# End of macro DMARK
3d4c						CALLMONITOR 
3d4c cd 6f ee			call debug_vector  
3d4f				endm  
# End of macro CALLMONITOR
3d4f					endif 
3d4f ed 5b a6 eb			ld de, (LFSRSeed+2)   ; check low range 
3d53					;call cmp16 
3d53				 
3d53 b7					or a  
3d54 ed 52		                sbc hl, de 
3d56 38 8c				jr c, .inrange 
3d58			 
3d58 e1					pop hl 
3d59					 
3d59					if DEBUG_FORTH_WORDS 
3d59						DMARK "RNd" 
3d59 f5				push af  
3d5a 3a 6e 3d			ld a, (.dmark)  
3d5d 32 62 ee			ld (debug_mark),a  
3d60 3a 6f 3d			ld a, (.dmark+1)  
3d63 32 63 ee			ld (debug_mark+1),a  
3d66 3a 70 3d			ld a, (.dmark+2)  
3d69 32 64 ee			ld (debug_mark+2),a  
3d6c 18 03			jr .pastdmark  
3d6e ..			.dmark: db "RNd"  
3d71 f1			.pastdmark: pop af  
3d72			endm  
# End of macro DMARK
3d72						CALLMONITOR 
3d72 cd 6f ee			call debug_vector  
3d75				endm  
# End of macro CALLMONITOR
3d75					endif 
3d75			 
3d75			 
3d75 cd 00 1b				call forth_push_numhl 
3d78				       NEXTW 
3d78 cd 6c ee			call parse_vector 
3d7b c3 f0 1e			jp macro_next 
3d7e				endm 
# End of macro NEXTW
3d7e			 
3d7e			.ENDMATHS: 
3d7e			 
3d7e			; eof 
3d7e			 
# End of file forth_words_maths.asm
3d7e			include "forth_words_display.asm" 
3d7e			 
3d7e			; | ## Display Words 
3d7e			 
3d7e			.ACT: 
3d7e			 
3d7e				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3d7e 62				db WORD_SYS_CORE+78             
3d7f cd 3d			dw .INFO            
3d81 07				db 6 + 1 
3d82 .. 00			db "ACTIVE",0              
3d89				endm 
# End of macro CWHEAD
3d89			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3d89			;  
3d89			; | | To display a pulsing activity indicator in a processing loop do this... 
3d89			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3d89			 
3d89					if DEBUG_FORTH_WORDS_KEY 
3d89						DMARK "ACT" 
3d89 f5				push af  
3d8a 3a 9e 3d			ld a, (.dmark)  
3d8d 32 62 ee			ld (debug_mark),a  
3d90 3a 9f 3d			ld a, (.dmark+1)  
3d93 32 63 ee			ld (debug_mark+1),a  
3d96 3a a0 3d			ld a, (.dmark+2)  
3d99 32 64 ee			ld (debug_mark+2),a  
3d9c 18 03			jr .pastdmark  
3d9e ..			.dmark: db "ACT"  
3da1 f1			.pastdmark: pop af  
3da2			endm  
# End of macro DMARK
3da2						CALLMONITOR 
3da2 cd 6f ee			call debug_vector  
3da5				endm  
# End of macro CALLMONITOR
3da5					endif 
3da5 cd 1f 0b				call active 
3da8					if DEBUG_FORTH_WORDS 
3da8						DMARK "ACp" 
3da8 f5				push af  
3da9 3a bd 3d			ld a, (.dmark)  
3dac 32 62 ee			ld (debug_mark),a  
3daf 3a be 3d			ld a, (.dmark+1)  
3db2 32 63 ee			ld (debug_mark+1),a  
3db5 3a bf 3d			ld a, (.dmark+2)  
3db8 32 64 ee			ld (debug_mark+2),a  
3dbb 18 03			jr .pastdmark  
3dbd ..			.dmark: db "ACp"  
3dc0 f1			.pastdmark: pop af  
3dc1			endm  
# End of macro DMARK
3dc1						CALLMONITOR 
3dc1 cd 6f ee			call debug_vector  
3dc4				endm  
# End of macro CALLMONITOR
3dc4					endif 
3dc4 cd 6e 1b				call forth_push_str 
3dc7			 
3dc7					NEXTW 
3dc7 cd 6c ee			call parse_vector 
3dca c3 f0 1e			jp macro_next 
3dcd				endm 
# End of macro NEXTW
3dcd			.INFO: 
3dcd			 
3dcd				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3dcd 62				db WORD_SYS_CORE+78             
3dce ed 3d			dw .ATP            
3dd0 05				db 4 + 1 
3dd1 .. 00			db "INFO",0              
3dd6				endm 
# End of macro CWHEAD
3dd6			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3dd6					FORTH_DSP_VALUEHL 
3dd6 cd 05 1d			call macro_dsp_valuehl 
3dd9				endm 
# End of macro FORTH_DSP_VALUEHL
3dd9			 
3dd9					FORTH_DSP_POP 
3dd9 cd bd 1d			call macro_forth_dsp_pop 
3ddc				endm 
# End of macro FORTH_DSP_POP
3ddc			 
3ddc e5					push hl 
3ddd			 
3ddd					FORTH_DSP_VALUEHL 
3ddd cd 05 1d			call macro_dsp_valuehl 
3de0				endm 
# End of macro FORTH_DSP_VALUEHL
3de0			 
3de0					FORTH_DSP_POP 
3de0 cd bd 1d			call macro_forth_dsp_pop 
3de3				endm 
# End of macro FORTH_DSP_POP
3de3			 
3de3 d1					pop de 
3de4			 
3de4 cd 59 0b				call info_panel 
3de7			 
3de7			 
3de7					NEXTW 
3de7 cd 6c ee			call parse_vector 
3dea c3 f0 1e			jp macro_next 
3ded				endm 
# End of macro NEXTW
3ded			.ATP: 
3ded				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3ded 62				db WORD_SYS_CORE+78             
3dee 67 3e			dw .FB            
3df0 04				db 3 + 1 
3df1 .. 00			db "AT?",0              
3df5				endm 
# End of macro CWHEAD
3df5			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3df5					if DEBUG_FORTH_WORDS_KEY 
3df5						DMARK "AT?" 
3df5 f5				push af  
3df6 3a 0a 3e			ld a, (.dmark)  
3df9 32 62 ee			ld (debug_mark),a  
3dfc 3a 0b 3e			ld a, (.dmark+1)  
3dff 32 63 ee			ld (debug_mark+1),a  
3e02 3a 0c 3e			ld a, (.dmark+2)  
3e05 32 64 ee			ld (debug_mark+2),a  
3e08 18 03			jr .pastdmark  
3e0a ..			.dmark: db "AT?"  
3e0d f1			.pastdmark: pop af  
3e0e			endm  
# End of macro DMARK
3e0e						CALLMONITOR 
3e0e cd 6f ee			call debug_vector  
3e11				endm  
# End of macro CALLMONITOR
3e11					endif 
3e11 3a 55 ea				ld a, (f_cursor_ptr) 
3e14			 
3e14			if DEBUG_FORTH_WORDS 
3e14				DMARK "AT?" 
3e14 f5				push af  
3e15 3a 29 3e			ld a, (.dmark)  
3e18 32 62 ee			ld (debug_mark),a  
3e1b 3a 2a 3e			ld a, (.dmark+1)  
3e1e 32 63 ee			ld (debug_mark+1),a  
3e21 3a 2b 3e			ld a, (.dmark+2)  
3e24 32 64 ee			ld (debug_mark+2),a  
3e27 18 03			jr .pastdmark  
3e29 ..			.dmark: db "AT?"  
3e2c f1			.pastdmark: pop af  
3e2d			endm  
# End of macro DMARK
3e2d				CALLMONITOR 
3e2d cd 6f ee			call debug_vector  
3e30				endm  
# End of macro CALLMONITOR
3e30			endif	 
3e30					; count the number of rows 
3e30			 
3e30 06 00				ld b, 0 
3e32 4f			.atpr:		ld c, a    ; save in case we go below zero 
3e33 d6 28				sub display_cols 
3e35 f2 3b 3e				jp p, .atprunder 
3e38 04					inc b 
3e39 18 f7				jr .atpr 
3e3b			.atprunder:	 
3e3b			if DEBUG_FORTH_WORDS 
3e3b				DMARK "A?2" 
3e3b f5				push af  
3e3c 3a 50 3e			ld a, (.dmark)  
3e3f 32 62 ee			ld (debug_mark),a  
3e42 3a 51 3e			ld a, (.dmark+1)  
3e45 32 63 ee			ld (debug_mark+1),a  
3e48 3a 52 3e			ld a, (.dmark+2)  
3e4b 32 64 ee			ld (debug_mark+2),a  
3e4e 18 03			jr .pastdmark  
3e50 ..			.dmark: db "A?2"  
3e53 f1			.pastdmark: pop af  
3e54			endm  
# End of macro DMARK
3e54				CALLMONITOR 
3e54 cd 6f ee			call debug_vector  
3e57				endm  
# End of macro CALLMONITOR
3e57			endif	 
3e57 26 00				ld h, 0 
3e59 69					ld l, c 
3e5a cd 00 1b				call forth_push_numhl 
3e5d 68					ld l, b  
3e5e cd 00 1b				call forth_push_numhl 
3e61			 
3e61			 
3e61				NEXTW 
3e61 cd 6c ee			call parse_vector 
3e64 c3 f0 1e			jp macro_next 
3e67				endm 
# End of macro NEXTW
3e67			 
3e67			.FB: 
3e67				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3e67 1b				db WORD_SYS_CORE+7             
3e68 b8 3e			dw .EMIT            
3e6a 03				db 2 + 1 
3e6b .. 00			db "FB",0              
3e6e				endm 
# End of macro CWHEAD
3e6e			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3e6e			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3e6e			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3e6e			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3e6e					if DEBUG_FORTH_WORDS_KEY 
3e6e						DMARK "FB." 
3e6e f5				push af  
3e6f 3a 83 3e			ld a, (.dmark)  
3e72 32 62 ee			ld (debug_mark),a  
3e75 3a 84 3e			ld a, (.dmark+1)  
3e78 32 63 ee			ld (debug_mark+1),a  
3e7b 3a 85 3e			ld a, (.dmark+2)  
3e7e 32 64 ee			ld (debug_mark+2),a  
3e81 18 03			jr .pastdmark  
3e83 ..			.dmark: db "FB."  
3e86 f1			.pastdmark: pop af  
3e87			endm  
# End of macro DMARK
3e87						CALLMONITOR 
3e87 cd 6f ee			call debug_vector  
3e8a				endm  
# End of macro CALLMONITOR
3e8a					endif 
3e8a			 
3e8a					FORTH_DSP_VALUEHL 
3e8a cd 05 1d			call macro_dsp_valuehl 
3e8d				endm 
# End of macro FORTH_DSP_VALUEHL
3e8d			 
3e8d 7d					ld a, l 
3e8e fe 01				cp 1 
3e90 20 05				jr nz, .fbn1 
3e92 21 07 ed				ld hl, display_fb1 
3e95 18 15				jr .fbset 
3e97 fe 02		.fbn1:		cp 2 
3e99 20 05				jr nz, .fbn2 
3e9b 21 c5 eb				ld hl, display_fb2 
3e9e 18 0c				jr .fbset 
3ea0 fe 03		.fbn2:		cp 3 
3ea2 20 05				jr nz, .fbn3 
3ea4 21 66 ec				ld hl, display_fb3 
3ea7 18 03				jr .fbset 
3ea9			.fbn3:		 ; if invalid number select first 
3ea9 21 07 ed				ld hl, display_fb1 
3eac 22 c3 eb		.fbset:		ld (display_fb_active), hl 
3eaf			 
3eaf					FORTH_DSP_POP 
3eaf cd bd 1d			call macro_forth_dsp_pop 
3eb2				endm 
# End of macro FORTH_DSP_POP
3eb2			 
3eb2					NEXTW 
3eb2 cd 6c ee			call parse_vector 
3eb5 c3 f0 1e			jp macro_next 
3eb8				endm 
# End of macro NEXTW
3eb8			 
3eb8			 
3eb8			.EMIT: 
3eb8				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3eb8 1b				db WORD_SYS_CORE+7             
3eb9 0c 3f			dw .DOTH            
3ebb 05				db 4 + 1 
3ebc .. 00			db "EMIT",0              
3ec1				endm 
# End of macro CWHEAD
3ec1			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3ec1					; get value off TOS and display it 
3ec1			 
3ec1					if DEBUG_FORTH_WORDS_KEY 
3ec1						DMARK "EMT" 
3ec1 f5				push af  
3ec2 3a d6 3e			ld a, (.dmark)  
3ec5 32 62 ee			ld (debug_mark),a  
3ec8 3a d7 3e			ld a, (.dmark+1)  
3ecb 32 63 ee			ld (debug_mark+1),a  
3ece 3a d8 3e			ld a, (.dmark+2)  
3ed1 32 64 ee			ld (debug_mark+2),a  
3ed4 18 03			jr .pastdmark  
3ed6 ..			.dmark: db "EMT"  
3ed9 f1			.pastdmark: pop af  
3eda			endm  
# End of macro DMARK
3eda						CALLMONITOR 
3eda cd 6f ee			call debug_vector  
3edd				endm  
# End of macro CALLMONITOR
3edd					endif 
3edd			 
3edd					FORTH_DSP_VALUEHL 
3edd cd 05 1d			call macro_dsp_valuehl 
3ee0				endm 
# End of macro FORTH_DSP_VALUEHL
3ee0			 
3ee0 7d					ld a,l 
3ee1			 
3ee1					; TODO write to display 
3ee1			 
3ee1 32 b6 e4				ld (os_input), a 
3ee4 3e 00				ld a, 0 
3ee6 32 b7 e4				ld (os_input+1), a 
3ee9					 
3ee9 3a 55 ea				ld a, (f_cursor_ptr) 
3eec 11 b6 e4				ld de, os_input 
3eef cd db 0b				call str_at_display 
3ef2			 
3ef2			 
3ef2 3a 33 ea				ld a,(cli_autodisplay) 
3ef5 fe 00				cp 0 
3ef7 28 03				jr z, .enoupdate 
3ef9 cd eb 0b						call update_display 
3efc					.enoupdate: 
3efc			 
3efc 3a 55 ea				ld a, (f_cursor_ptr) 
3eff 3c					inc a 
3f00 32 55 ea				ld (f_cursor_ptr), a   ; save new pos 
3f03			 
3f03			 
3f03					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f03 cd bd 1d			call macro_forth_dsp_pop 
3f06				endm 
# End of macro FORTH_DSP_POP
3f06			  
3f06			 
3f06					NEXTW 
3f06 cd 6c ee			call parse_vector 
3f09 c3 f0 1e			jp macro_next 
3f0c				endm 
# End of macro NEXTW
3f0c			.DOTH: 
3f0c				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3f0c 1c				db WORD_SYS_CORE+8             
3f0d 3f 3f			dw .DOTF            
3f0f 03				db 2 + 1 
3f10 .. 00			db ".-",0              
3f13				endm 
# End of macro CWHEAD
3f13			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3f13					; get value off TOS and display it 
3f13					if DEBUG_FORTH_WORDS_KEY 
3f13						DMARK "DTD" 
3f13 f5				push af  
3f14 3a 28 3f			ld a, (.dmark)  
3f17 32 62 ee			ld (debug_mark),a  
3f1a 3a 29 3f			ld a, (.dmark+1)  
3f1d 32 63 ee			ld (debug_mark+1),a  
3f20 3a 2a 3f			ld a, (.dmark+2)  
3f23 32 64 ee			ld (debug_mark+2),a  
3f26 18 03			jr .pastdmark  
3f28 ..			.dmark: db "DTD"  
3f2b f1			.pastdmark: pop af  
3f2c			endm  
# End of macro DMARK
3f2c						CALLMONITOR 
3f2c cd 6f ee			call debug_vector  
3f2f				endm  
# End of macro CALLMONITOR
3f2f					endif 
3f2f 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3f31 3e 00			ld a, 0 
3f33 32 34 ea			ld (cli_mvdot), a 
3f36 c3 99 3f			jp .dotgo 
3f39				NEXTW 
3f39 cd 6c ee			call parse_vector 
3f3c c3 f0 1e			jp macro_next 
3f3f				endm 
# End of macro NEXTW
3f3f			.DOTF: 
3f3f				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3f3f 1c				db WORD_SYS_CORE+8             
3f40 70 3f			dw .DOT            
3f42 03				db 2 + 1 
3f43 .. 00			db ".>",0              
3f46				endm 
# End of macro CWHEAD
3f46			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
3f46					; get value off TOS and display it 
3f46			        ; TODO BUG adds extra spaces 
3f46			        ; TODO BUG handle numerics? 
3f46					if DEBUG_FORTH_WORDS_KEY 
3f46						DMARK "DTC" 
3f46 f5				push af  
3f47 3a 5b 3f			ld a, (.dmark)  
3f4a 32 62 ee			ld (debug_mark),a  
3f4d 3a 5c 3f			ld a, (.dmark+1)  
3f50 32 63 ee			ld (debug_mark+1),a  
3f53 3a 5d 3f			ld a, (.dmark+2)  
3f56 32 64 ee			ld (debug_mark+2),a  
3f59 18 03			jr .pastdmark  
3f5b ..			.dmark: db "DTC"  
3f5e f1			.pastdmark: pop af  
3f5f			endm  
# End of macro DMARK
3f5f						CALLMONITOR 
3f5f cd 6f ee			call debug_vector  
3f62				endm  
# End of macro CALLMONITOR
3f62					endif 
3f62 3e 01			ld a, 1 
3f64 32 34 ea			ld (cli_mvdot), a 
3f67 c3 99 3f			jp .dotgo 
3f6a				NEXTW 
3f6a cd 6c ee			call parse_vector 
3f6d c3 f0 1e			jp macro_next 
3f70				endm 
# End of macro NEXTW
3f70			 
3f70			.DOT: 
3f70				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3f70 1c				db WORD_SYS_CORE+8             
3f71 4f 41			dw .CLS            
3f73 02				db 1 + 1 
3f74 .. 00			db ".",0              
3f76				endm 
# End of macro CWHEAD
3f76			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
3f76					; get value off TOS and display it 
3f76			 
3f76					if DEBUG_FORTH_WORDS_KEY 
3f76						DMARK "DOT" 
3f76 f5				push af  
3f77 3a 8b 3f			ld a, (.dmark)  
3f7a 32 62 ee			ld (debug_mark),a  
3f7d 3a 8c 3f			ld a, (.dmark+1)  
3f80 32 63 ee			ld (debug_mark+1),a  
3f83 3a 8d 3f			ld a, (.dmark+2)  
3f86 32 64 ee			ld (debug_mark+2),a  
3f89 18 03			jr .pastdmark  
3f8b ..			.dmark: db "DOT"  
3f8e f1			.pastdmark: pop af  
3f8f			endm  
# End of macro DMARK
3f8f						CALLMONITOR 
3f8f cd 6f ee			call debug_vector  
3f92				endm  
# End of macro CALLMONITOR
3f92					endif 
3f92 3e 00			ld a, 0 
3f94 32 34 ea			ld (cli_mvdot), a 
3f97 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3f99				 
3f99			 
3f99			.dotgo: 
3f99			 
3f99			; move up type to on stack for parserv5 
3f99					FORTH_DSP 
3f99 cd cb 1c			call macro_forth_dsp 
3f9c				endm 
# End of macro FORTH_DSP
3f9c				;FORTH_DSP_VALUE  
3f9c			 
3f9c			if DEBUG_FORTH_DOT 
3f9c				DMARK "DOT" 
3f9c f5				push af  
3f9d 3a b1 3f			ld a, (.dmark)  
3fa0 32 62 ee			ld (debug_mark),a  
3fa3 3a b2 3f			ld a, (.dmark+1)  
3fa6 32 63 ee			ld (debug_mark+1),a  
3fa9 3a b3 3f			ld a, (.dmark+2)  
3fac 32 64 ee			ld (debug_mark+2),a  
3faf 18 03			jr .pastdmark  
3fb1 ..			.dmark: db "DOT"  
3fb4 f1			.pastdmark: pop af  
3fb5			endm  
# End of macro DMARK
3fb5				CALLMONITOR 
3fb5 cd 6f ee			call debug_vector  
3fb8				endm  
# End of macro CALLMONITOR
3fb8			endif	 
3fb8			;		.print: 
3fb8			 
3fb8 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3fb9 23				inc hl   ; position to the actual value 
3fba fe 01			cp DS_TYPE_STR 
3fbc 20 06			jr nz, .dotnum1  
3fbe			 
3fbe			; display string 
3fbe				FORTH_DSP_VALUE  
3fbe cd ee 1c			call macro_forth_dsp_value 
3fc1				endm 
# End of macro FORTH_DSP_VALUE
3fc1 eb				ex de,hl 
3fc2 18 49			jr .dotwrite 
3fc4			 
3fc4			.dotnum1: 
3fc4 fe 02			cp DS_TYPE_INUM 
3fc6 20 44			jr nz, .dotflot 
3fc8			 
3fc8			 
3fc8			; display number 
3fc8			 
3fc8			;	push hl 
3fc8			;	call clear_display 
3fc8			;	pop hl 
3fc8			 
3fc8 5e				ld e, (hl) 
3fc9 23				inc hl 
3fca 56				ld d, (hl) 
3fcb 21 b8 e2			ld hl, scratch 
3fce			if DEBUG_FORTH_DOT 
3fce				DMARK "DT1" 
3fce f5				push af  
3fcf 3a e3 3f			ld a, (.dmark)  
3fd2 32 62 ee			ld (debug_mark),a  
3fd5 3a e4 3f			ld a, (.dmark+1)  
3fd8 32 63 ee			ld (debug_mark+1),a  
3fdb 3a e5 3f			ld a, (.dmark+2)  
3fde 32 64 ee			ld (debug_mark+2),a  
3fe1 18 03			jr .pastdmark  
3fe3 ..			.dmark: db "DT1"  
3fe6 f1			.pastdmark: pop af  
3fe7			endm  
# End of macro DMARK
3fe7				CALLMONITOR 
3fe7 cd 6f ee			call debug_vector  
3fea				endm  
# End of macro CALLMONITOR
3fea			endif	 
3fea			 
3fea cd 0a 11			call uitoa_16 
3fed eb				ex de,hl 
3fee			 
3fee			if DEBUG_FORTH_DOT 
3fee				DMARK "DT2" 
3fee f5				push af  
3fef 3a 03 40			ld a, (.dmark)  
3ff2 32 62 ee			ld (debug_mark),a  
3ff5 3a 04 40			ld a, (.dmark+1)  
3ff8 32 63 ee			ld (debug_mark+1),a  
3ffb 3a 05 40			ld a, (.dmark+2)  
3ffe 32 64 ee			ld (debug_mark+2),a  
4001 18 03			jr .pastdmark  
4003 ..			.dmark: db "DT2"  
4006 f1			.pastdmark: pop af  
4007			endm  
# End of macro DMARK
4007				CALLMONITOR 
4007 cd 6f ee			call debug_vector  
400a				endm  
# End of macro CALLMONITOR
400a			endif	 
400a			 
400a			;	ld de, os_word_scratch 
400a 18 01			jr .dotwrite 
400c			 
400c 00			.dotflot:   nop 
400d			; TODO print floating point number 
400d			 
400d			.dotwrite:		 
400d			 
400d					; if c is set then set all '-' to spaces 
400d					; need to also take into account .>  
400d			 
400d 3e 01				ld a, 1 
400f b9					cp c 
4010 20 67				jr nz, .nodashswap 
4012			 
4012					; DE has the string to write, working with HL 
4012			 
4012 06 ff				ld b, 255 
4014 d5					push de 
4015 e1					pop hl 
4016			 
4016			if DEBUG_FORTH_DOT 
4016				DMARK "DT-" 
4016 f5				push af  
4017 3a 2b 40			ld a, (.dmark)  
401a 32 62 ee			ld (debug_mark),a  
401d 3a 2c 40			ld a, (.dmark+1)  
4020 32 63 ee			ld (debug_mark+1),a  
4023 3a 2d 40			ld a, (.dmark+2)  
4026 32 64 ee			ld (debug_mark+2),a  
4029 18 03			jr .pastdmark  
402b ..			.dmark: db "DT-"  
402e f1			.pastdmark: pop af  
402f			endm  
# End of macro DMARK
402f				CALLMONITOR 
402f cd 6f ee			call debug_vector  
4032				endm  
# End of macro CALLMONITOR
4032			endif	 
4032 7e			.dashscan:	ld a, (hl) 
4033 fe 00				cp 0 
4035 28 42				jr z, .nodashswap 
4037 fe 2d				cp '-' 
4039 20 03				jr nz, .dashskip 
403b 3e 20				ld a, ' ' 
403d 77					ld (hl), a 
403e 23			.dashskip:	inc hl 
403f			if DEBUG_FORTH_DOT 
403f				DMARK "D-2" 
403f f5				push af  
4040 3a 54 40			ld a, (.dmark)  
4043 32 62 ee			ld (debug_mark),a  
4046 3a 55 40			ld a, (.dmark+1)  
4049 32 63 ee			ld (debug_mark+1),a  
404c 3a 56 40			ld a, (.dmark+2)  
404f 32 64 ee			ld (debug_mark+2),a  
4052 18 03			jr .pastdmark  
4054 ..			.dmark: db "D-2"  
4057 f1			.pastdmark: pop af  
4058			endm  
# End of macro DMARK
4058				CALLMONITOR 
4058 cd 6f ee			call debug_vector  
405b				endm  
# End of macro CALLMONITOR
405b			endif	 
405b 10 d5				djnz .dashscan 
405d			 
405d			if DEBUG_FORTH_DOT 
405d				DMARK "D-1" 
405d f5				push af  
405e 3a 72 40			ld a, (.dmark)  
4061 32 62 ee			ld (debug_mark),a  
4064 3a 73 40			ld a, (.dmark+1)  
4067 32 63 ee			ld (debug_mark+1),a  
406a 3a 74 40			ld a, (.dmark+2)  
406d 32 64 ee			ld (debug_mark+2),a  
4070 18 03			jr .pastdmark  
4072 ..			.dmark: db "D-1"  
4075 f1			.pastdmark: pop af  
4076			endm  
# End of macro DMARK
4076				CALLMONITOR 
4076 cd 6f ee			call debug_vector  
4079				endm  
# End of macro CALLMONITOR
4079			endif	 
4079			 
4079			.nodashswap: 
4079			 
4079			if DEBUG_FORTH_DOT 
4079				DMARK "D-o" 
4079 f5				push af  
407a 3a 8e 40			ld a, (.dmark)  
407d 32 62 ee			ld (debug_mark),a  
4080 3a 8f 40			ld a, (.dmark+1)  
4083 32 63 ee			ld (debug_mark+1),a  
4086 3a 90 40			ld a, (.dmark+2)  
4089 32 64 ee			ld (debug_mark+2),a  
408c 18 03			jr .pastdmark  
408e ..			.dmark: db "D-o"  
4091 f1			.pastdmark: pop af  
4092			endm  
# End of macro DMARK
4092				CALLMONITOR 
4092 cd 6f ee			call debug_vector  
4095				endm  
# End of macro CALLMONITOR
4095			endif	 
4095			 
4095 d5					push de   ; save string start in case we need to advance print 
4096			 
4096 3a 55 ea				ld a, (f_cursor_ptr) 
4099 cd db 0b				call str_at_display 
409c 3a 33 ea				ld a,(cli_autodisplay) 
409f fe 00				cp 0 
40a1 28 03				jr z, .noupdate 
40a3 cd eb 0b						call update_display 
40a6					.noupdate: 
40a6			 
40a6			 
40a6					; see if we need to advance the print position 
40a6			 
40a6 e1					pop hl   ; get back string 
40a7			;		ex de,hl 
40a7			 
40a7 3a 34 ea				ld a, (cli_mvdot) 
40aa			if DEBUG_FORTH_DOT 
40aa			;		ld e,a 
40aa				DMARK "D>1" 
40aa f5				push af  
40ab 3a bf 40			ld a, (.dmark)  
40ae 32 62 ee			ld (debug_mark),a  
40b1 3a c0 40			ld a, (.dmark+1)  
40b4 32 63 ee			ld (debug_mark+1),a  
40b7 3a c1 40			ld a, (.dmark+2)  
40ba 32 64 ee			ld (debug_mark+2),a  
40bd 18 03			jr .pastdmark  
40bf ..			.dmark: db "D>1"  
40c2 f1			.pastdmark: pop af  
40c3			endm  
# End of macro DMARK
40c3				CALLMONITOR 
40c3 cd 6f ee			call debug_vector  
40c6				endm  
# End of macro CALLMONITOR
40c6			endif	 
40c6 fe 00				cp 0 
40c8 28 44				jr z, .noadv 
40ca					; yes, lets advance the print position 
40ca 3e 00				ld a, 0 
40cc cd 66 11				call strlent 
40cf			if DEBUG_FORTH_DOT 
40cf				DMARK "D-?" 
40cf f5				push af  
40d0 3a e4 40			ld a, (.dmark)  
40d3 32 62 ee			ld (debug_mark),a  
40d6 3a e5 40			ld a, (.dmark+1)  
40d9 32 63 ee			ld (debug_mark+1),a  
40dc 3a e6 40			ld a, (.dmark+2)  
40df 32 64 ee			ld (debug_mark+2),a  
40e2 18 03			jr .pastdmark  
40e4 ..			.dmark: db "D-?"  
40e7 f1			.pastdmark: pop af  
40e8			endm  
# End of macro DMARK
40e8				CALLMONITOR 
40e8 cd 6f ee			call debug_vector  
40eb				endm  
# End of macro CALLMONITOR
40eb			endif	 
40eb 3a 55 ea				ld a, (f_cursor_ptr) 
40ee 85					add a,l 
40ef					;call addatohl 
40ef					;ld a, l 
40ef 32 55 ea				ld (f_cursor_ptr), a   ; save new pos 
40f2			 
40f2			if DEBUG_FORTH_DOT 
40f2				DMARK "D->" 
40f2 f5				push af  
40f3 3a 07 41			ld a, (.dmark)  
40f6 32 62 ee			ld (debug_mark),a  
40f9 3a 08 41			ld a, (.dmark+1)  
40fc 32 63 ee			ld (debug_mark+1),a  
40ff 3a 09 41			ld a, (.dmark+2)  
4102 32 64 ee			ld (debug_mark+2),a  
4105 18 03			jr .pastdmark  
4107 ..			.dmark: db "D->"  
410a f1			.pastdmark: pop af  
410b			endm  
# End of macro DMARK
410b				CALLMONITOR 
410b cd 6f ee			call debug_vector  
410e				endm  
# End of macro CALLMONITOR
410e			endif	 
410e			 
410e			.noadv:	 
410e			 
410e					if DEBUG_FORTH_DOT_WAIT 
410e							call next_page_prompt 
410e					endif	 
410e			; TODO this pop off the stack causes a crash. i dont know why 
410e			 
410e			 
410e			if DEBUG_FORTH_DOT 
410e				DMARK "DTh" 
410e f5				push af  
410f 3a 23 41			ld a, (.dmark)  
4112 32 62 ee			ld (debug_mark),a  
4115 3a 24 41			ld a, (.dmark+1)  
4118 32 63 ee			ld (debug_mark+1),a  
411b 3a 25 41			ld a, (.dmark+2)  
411e 32 64 ee			ld (debug_mark+2),a  
4121 18 03			jr .pastdmark  
4123 ..			.dmark: db "DTh"  
4126 f1			.pastdmark: pop af  
4127			endm  
# End of macro DMARK
4127				CALLMONITOR 
4127 cd 6f ee			call debug_vector  
412a				endm  
# End of macro CALLMONITOR
412a			endif	 
412a			 
412a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
412a cd bd 1d			call macro_forth_dsp_pop 
412d				endm 
# End of macro FORTH_DSP_POP
412d			 
412d			if DEBUG_FORTH_DOT 
412d				DMARK "DTi" 
412d f5				push af  
412e 3a 42 41			ld a, (.dmark)  
4131 32 62 ee			ld (debug_mark),a  
4134 3a 43 41			ld a, (.dmark+1)  
4137 32 63 ee			ld (debug_mark+1),a  
413a 3a 44 41			ld a, (.dmark+2)  
413d 32 64 ee			ld (debug_mark+2),a  
4140 18 03			jr .pastdmark  
4142 ..			.dmark: db "DTi"  
4145 f1			.pastdmark: pop af  
4146			endm  
# End of macro DMARK
4146				CALLMONITOR 
4146 cd 6f ee			call debug_vector  
4149				endm  
# End of macro CALLMONITOR
4149			endif	 
4149			 
4149			 
4149					NEXTW 
4149 cd 6c ee			call parse_vector 
414c c3 f0 1e			jp macro_next 
414f				endm 
# End of macro NEXTW
414f			 
414f			.CLS: 
414f				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
414f 35				db WORD_SYS_CORE+33             
4150 7f 41			dw .DRAW            
4152 04				db 3 + 1 
4153 .. 00			db "CLS",0              
4157				endm 
# End of macro CWHEAD
4157			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4157					if DEBUG_FORTH_WORDS_KEY 
4157						DMARK "CLS" 
4157 f5				push af  
4158 3a 6c 41			ld a, (.dmark)  
415b 32 62 ee			ld (debug_mark),a  
415e 3a 6d 41			ld a, (.dmark+1)  
4161 32 63 ee			ld (debug_mark+1),a  
4164 3a 6e 41			ld a, (.dmark+2)  
4167 32 64 ee			ld (debug_mark+2),a  
416a 18 03			jr .pastdmark  
416c ..			.dmark: db "CLS"  
416f f1			.pastdmark: pop af  
4170			endm  
# End of macro DMARK
4170						CALLMONITOR 
4170 cd 6f ee			call debug_vector  
4173				endm  
# End of macro CALLMONITOR
4173					endif 
4173 cd c8 0b				call clear_display 
4176 c3 99 42				jp .home		; and home cursor 
4179					NEXTW 
4179 cd 6c ee			call parse_vector 
417c c3 f0 1e			jp macro_next 
417f				endm 
# End of macro NEXTW
417f			 
417f			.DRAW: 
417f				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
417f 36				db WORD_SYS_CORE+34             
4180 ad 41			dw .DUMP            
4182 05				db 4 + 1 
4183 .. 00			db "DRAW",0              
4188				endm 
# End of macro CWHEAD
4188			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
4188					if DEBUG_FORTH_WORDS_KEY 
4188						DMARK "DRW" 
4188 f5				push af  
4189 3a 9d 41			ld a, (.dmark)  
418c 32 62 ee			ld (debug_mark),a  
418f 3a 9e 41			ld a, (.dmark+1)  
4192 32 63 ee			ld (debug_mark+1),a  
4195 3a 9f 41			ld a, (.dmark+2)  
4198 32 64 ee			ld (debug_mark+2),a  
419b 18 03			jr .pastdmark  
419d ..			.dmark: db "DRW"  
41a0 f1			.pastdmark: pop af  
41a1			endm  
# End of macro DMARK
41a1						CALLMONITOR 
41a1 cd 6f ee			call debug_vector  
41a4				endm  
# End of macro CALLMONITOR
41a4					endif 
41a4 cd eb 0b				call update_display 
41a7					NEXTW 
41a7 cd 6c ee			call parse_vector 
41aa c3 f0 1e			jp macro_next 
41ad				endm 
# End of macro NEXTW
41ad			 
41ad			.DUMP: 
41ad				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
41ad 37				db WORD_SYS_CORE+35             
41ae e8 41			dw .CDUMP            
41b0 05				db 4 + 1 
41b1 .. 00			db "DUMP",0              
41b6				endm 
# End of macro CWHEAD
41b6			; | DUMP ( x -- ) With address x display dump   | DONE 
41b6			; TODO pop address to use off of the stack 
41b6					if DEBUG_FORTH_WORDS_KEY 
41b6						DMARK "DUM" 
41b6 f5				push af  
41b7 3a cb 41			ld a, (.dmark)  
41ba 32 62 ee			ld (debug_mark),a  
41bd 3a cc 41			ld a, (.dmark+1)  
41c0 32 63 ee			ld (debug_mark+1),a  
41c3 3a cd 41			ld a, (.dmark+2)  
41c6 32 64 ee			ld (debug_mark+2),a  
41c9 18 03			jr .pastdmark  
41cb ..			.dmark: db "DUM"  
41ce f1			.pastdmark: pop af  
41cf			endm  
# End of macro DMARK
41cf						CALLMONITOR 
41cf cd 6f ee			call debug_vector  
41d2				endm  
# End of macro CALLMONITOR
41d2					endif 
41d2 cd c8 0b				call clear_display 
41d5			 
41d5					; get address 
41d5			 
41d5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
41d5 cd 05 1d			call macro_dsp_valuehl 
41d8				endm 
# End of macro FORTH_DSP_VALUEHL
41d8				 
41d8					; save it for cdump 
41d8			 
41d8 22 db e5				ld (os_cur_ptr),hl 
41db			 
41db					; destroy value TOS 
41db			 
41db					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
41db cd bd 1d			call macro_forth_dsp_pop 
41de				endm 
# End of macro FORTH_DSP_POP
41de			 
41de cd 80 19				call dumpcont	; skip old style of param parsing	 
41e1 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
41e2					NEXTW 
41e2 cd 6c ee			call parse_vector 
41e5 c3 f0 1e			jp macro_next 
41e8				endm 
# End of macro NEXTW
41e8			.CDUMP: 
41e8				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
41e8 38				db WORD_SYS_CORE+36             
41e9 1b 42			dw .DAT            
41eb 06				db 5 + 1 
41ec .. 00			db "CDUMP",0              
41f2				endm 
# End of macro CWHEAD
41f2			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
41f2					if DEBUG_FORTH_WORDS_KEY 
41f2						DMARK "CDP" 
41f2 f5				push af  
41f3 3a 07 42			ld a, (.dmark)  
41f6 32 62 ee			ld (debug_mark),a  
41f9 3a 08 42			ld a, (.dmark+1)  
41fc 32 63 ee			ld (debug_mark+1),a  
41ff 3a 09 42			ld a, (.dmark+2)  
4202 32 64 ee			ld (debug_mark+2),a  
4205 18 03			jr .pastdmark  
4207 ..			.dmark: db "CDP"  
420a f1			.pastdmark: pop af  
420b			endm  
# End of macro DMARK
420b						CALLMONITOR 
420b cd 6f ee			call debug_vector  
420e				endm  
# End of macro CALLMONITOR
420e					endif 
420e cd c8 0b				call clear_display 
4211 cd 80 19				call dumpcont	 
4214 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4215					NEXTW 
4215 cd 6c ee			call parse_vector 
4218 c3 f0 1e			jp macro_next 
421b				endm 
# End of macro NEXTW
421b			 
421b			 
421b			 
421b			 
421b			.DAT: 
421b				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
421b 3d				db WORD_SYS_CORE+41             
421c 74 42			dw .HOME            
421e 03				db 2 + 1 
421f .. 00			db "AT",0              
4222				endm 
# End of macro CWHEAD
4222			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
4222					if DEBUG_FORTH_WORDS_KEY 
4222						DMARK "AT." 
4222 f5				push af  
4223 3a 37 42			ld a, (.dmark)  
4226 32 62 ee			ld (debug_mark),a  
4229 3a 38 42			ld a, (.dmark+1)  
422c 32 63 ee			ld (debug_mark+1),a  
422f 3a 39 42			ld a, (.dmark+2)  
4232 32 64 ee			ld (debug_mark+2),a  
4235 18 03			jr .pastdmark  
4237 ..			.dmark: db "AT."  
423a f1			.pastdmark: pop af  
423b			endm  
# End of macro DMARK
423b						CALLMONITOR 
423b cd 6f ee			call debug_vector  
423e				endm  
# End of macro CALLMONITOR
423e					endif 
423e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
423e cd 05 1d			call macro_dsp_valuehl 
4241				endm 
# End of macro FORTH_DSP_VALUEHL
4241			 
4241			 
4241					; TODO save cursor row 
4241 7d					ld a,l 
4242 fe 02				cp 2 
4244 20 04				jr nz, .crow3 
4246 3e 28				ld a, display_row_2 
4248 18 12				jr .ccol1 
424a fe 03		.crow3:		cp 3 
424c 20 04				jr nz, .crow4 
424e 3e 50				ld a, display_row_3 
4250 18 0a				jr .ccol1 
4252 fe 04		.crow4:		cp 4 
4254 20 04				jr nz, .crow1 
4256 3e 78				ld a, display_row_4 
4258 18 02				jr .ccol1 
425a 3e 00		.crow1:		ld a,display_row_1 
425c f5			.ccol1:		push af			; got row offset 
425d 6f					ld l,a 
425e 26 00				ld h,0 
4260					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4260 cd bd 1d			call macro_forth_dsp_pop 
4263				endm 
# End of macro FORTH_DSP_POP
4263					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4263 cd 05 1d			call macro_dsp_valuehl 
4266				endm 
# End of macro FORTH_DSP_VALUEHL
4266					; TODO save cursor col 
4266 f1					pop af 
4267 85					add l		; add col offset 
4268 32 55 ea				ld (f_cursor_ptr), a 
426b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
426b cd bd 1d			call macro_forth_dsp_pop 
426e				endm 
# End of macro FORTH_DSP_POP
426e			 
426e					; calculate  
426e			 
426e					NEXTW 
426e cd 6c ee			call parse_vector 
4271 c3 f0 1e			jp macro_next 
4274				endm 
# End of macro NEXTW
4274			 
4274			 
4274			.HOME: 
4274				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
4274 41				db WORD_SYS_CORE+45             
4275 a4 42			dw .CR            
4277 05				db 4 + 1 
4278 .. 00			db "HOME",0              
427d				endm 
# End of macro CWHEAD
427d			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
427d					if DEBUG_FORTH_WORDS_KEY 
427d						DMARK "HOM" 
427d f5				push af  
427e 3a 92 42			ld a, (.dmark)  
4281 32 62 ee			ld (debug_mark),a  
4284 3a 93 42			ld a, (.dmark+1)  
4287 32 63 ee			ld (debug_mark+1),a  
428a 3a 94 42			ld a, (.dmark+2)  
428d 32 64 ee			ld (debug_mark+2),a  
4290 18 03			jr .pastdmark  
4292 ..			.dmark: db "HOM"  
4295 f1			.pastdmark: pop af  
4296			endm  
# End of macro DMARK
4296						CALLMONITOR 
4296 cd 6f ee			call debug_vector  
4299				endm  
# End of macro CALLMONITOR
4299					endif 
4299 3e 00		.home:		ld a, 0		; and home cursor 
429b 32 55 ea				ld (f_cursor_ptr), a 
429e					NEXTW 
429e cd 6c ee			call parse_vector 
42a1 c3 f0 1e			jp macro_next 
42a4				endm 
# End of macro NEXTW
42a4			 
42a4			 
42a4			.CR: 
42a4				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
42a4 46				db WORD_SYS_CORE+50             
42a5 e2 42			dw .SPACE            
42a7 03				db 2 + 1 
42a8 .. 00			db "CR",0              
42ab				endm 
# End of macro CWHEAD
42ab			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
42ab					if DEBUG_FORTH_WORDS_KEY 
42ab						DMARK "CR." 
42ab f5				push af  
42ac 3a c0 42			ld a, (.dmark)  
42af 32 62 ee			ld (debug_mark),a  
42b2 3a c1 42			ld a, (.dmark+1)  
42b5 32 63 ee			ld (debug_mark+1),a  
42b8 3a c2 42			ld a, (.dmark+2)  
42bb 32 64 ee			ld (debug_mark+2),a  
42be 18 03			jr .pastdmark  
42c0 ..			.dmark: db "CR."  
42c3 f1			.pastdmark: pop af  
42c4			endm  
# End of macro DMARK
42c4						CALLMONITOR 
42c4 cd 6f ee			call debug_vector  
42c7				endm  
# End of macro CALLMONITOR
42c7					endif 
42c7 3e 0d				ld a, 13 
42c9 32 b8 e2				ld (scratch),a 
42cc 3e 0a				ld a, 10 
42ce 32 b9 e2				ld (scratch+1),a 
42d1 3e 00				ld a, 0 
42d3 32 ba e2				ld (scratch+2),a 
42d6 21 b8 e2				ld hl, scratch 
42d9 cd 6e 1b				call forth_push_str 
42dc					 
42dc				       NEXTW 
42dc cd 6c ee			call parse_vector 
42df c3 f0 1e			jp macro_next 
42e2				endm 
# End of macro NEXTW
42e2			.SPACE: 
42e2				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
42e2 46				db WORD_SYS_CORE+50             
42e3 1b 43			dw .SPACES            
42e5 03				db 2 + 1 
42e6 .. 00			db "BL",0              
42e9				endm 
# End of macro CWHEAD
42e9			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
42e9					if DEBUG_FORTH_WORDS_KEY 
42e9						DMARK "BL." 
42e9 f5				push af  
42ea 3a fe 42			ld a, (.dmark)  
42ed 32 62 ee			ld (debug_mark),a  
42f0 3a ff 42			ld a, (.dmark+1)  
42f3 32 63 ee			ld (debug_mark+1),a  
42f6 3a 00 43			ld a, (.dmark+2)  
42f9 32 64 ee			ld (debug_mark+2),a  
42fc 18 03			jr .pastdmark  
42fe ..			.dmark: db "BL."  
4301 f1			.pastdmark: pop af  
4302			endm  
# End of macro DMARK
4302						CALLMONITOR 
4302 cd 6f ee			call debug_vector  
4305				endm  
# End of macro CALLMONITOR
4305					endif 
4305 3e 20				ld a, " " 
4307 32 b8 e2				ld (scratch),a 
430a 3e 00				ld a, 0 
430c 32 b9 e2				ld (scratch+1),a 
430f 21 b8 e2				ld hl, scratch 
4312 cd 6e 1b				call forth_push_str 
4315					 
4315				       NEXTW 
4315 cd 6c ee			call parse_vector 
4318 c3 f0 1e			jp macro_next 
431b				endm 
# End of macro NEXTW
431b			 
431b			;.blstr: db " ", 0 
431b			 
431b			.SPACES: 
431b				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
431b 47				db WORD_SYS_CORE+51             
431c b9 43			dw .SCROLL            
431e 07				db 6 + 1 
431f .. 00			db "SPACES",0              
4326				endm 
# End of macro CWHEAD
4326			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
4326					if DEBUG_FORTH_WORDS_KEY 
4326						DMARK "SPS" 
4326 f5				push af  
4327 3a 3b 43			ld a, (.dmark)  
432a 32 62 ee			ld (debug_mark),a  
432d 3a 3c 43			ld a, (.dmark+1)  
4330 32 63 ee			ld (debug_mark+1),a  
4333 3a 3d 43			ld a, (.dmark+2)  
4336 32 64 ee			ld (debug_mark+2),a  
4339 18 03			jr .pastdmark  
433b ..			.dmark: db "SPS"  
433e f1			.pastdmark: pop af  
433f			endm  
# End of macro DMARK
433f						CALLMONITOR 
433f cd 6f ee			call debug_vector  
4342				endm  
# End of macro CALLMONITOR
4342					endif 
4342			 
4342			 
4342					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4342 cd 05 1d			call macro_dsp_valuehl 
4345				endm 
# End of macro FORTH_DSP_VALUEHL
4345			 
4345 e5					push hl    ; u 
4346					if DEBUG_FORTH_WORDS 
4346						DMARK "SPA" 
4346 f5				push af  
4347 3a 5b 43			ld a, (.dmark)  
434a 32 62 ee			ld (debug_mark),a  
434d 3a 5c 43			ld a, (.dmark+1)  
4350 32 63 ee			ld (debug_mark+1),a  
4353 3a 5d 43			ld a, (.dmark+2)  
4356 32 64 ee			ld (debug_mark+2),a  
4359 18 03			jr .pastdmark  
435b ..			.dmark: db "SPA"  
435e f1			.pastdmark: pop af  
435f			endm  
# End of macro DMARK
435f						CALLMONITOR 
435f cd 6f ee			call debug_vector  
4362				endm  
# End of macro CALLMONITOR
4362					endif 
4362			 
4362					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4362 cd bd 1d			call macro_forth_dsp_pop 
4365				endm 
# End of macro FORTH_DSP_POP
4365 e1					pop hl 
4366 0e 00				ld c, 0 
4368 45					ld b, l 
4369 21 b8 e2				ld hl, scratch  
436c			 
436c					if DEBUG_FORTH_WORDS 
436c						DMARK "SP2" 
436c f5				push af  
436d 3a 81 43			ld a, (.dmark)  
4370 32 62 ee			ld (debug_mark),a  
4373 3a 82 43			ld a, (.dmark+1)  
4376 32 63 ee			ld (debug_mark+1),a  
4379 3a 83 43			ld a, (.dmark+2)  
437c 32 64 ee			ld (debug_mark+2),a  
437f 18 03			jr .pastdmark  
4381 ..			.dmark: db "SP2"  
4384 f1			.pastdmark: pop af  
4385			endm  
# End of macro DMARK
4385						CALLMONITOR 
4385 cd 6f ee			call debug_vector  
4388				endm  
# End of macro CALLMONITOR
4388					endif 
4388 3e 20				ld a, ' ' 
438a			.spaces1:	 
438a 77					ld (hl),a 
438b 23					inc hl 
438c					 
438c 10 fc				djnz .spaces1 
438e 3e 00				ld a,0 
4390 77					ld (hl),a 
4391 21 b8 e2				ld hl, scratch 
4394					if DEBUG_FORTH_WORDS 
4394						DMARK "SP3" 
4394 f5				push af  
4395 3a a9 43			ld a, (.dmark)  
4398 32 62 ee			ld (debug_mark),a  
439b 3a aa 43			ld a, (.dmark+1)  
439e 32 63 ee			ld (debug_mark+1),a  
43a1 3a ab 43			ld a, (.dmark+2)  
43a4 32 64 ee			ld (debug_mark+2),a  
43a7 18 03			jr .pastdmark  
43a9 ..			.dmark: db "SP3"  
43ac f1			.pastdmark: pop af  
43ad			endm  
# End of macro DMARK
43ad						CALLMONITOR 
43ad cd 6f ee			call debug_vector  
43b0				endm  
# End of macro CALLMONITOR
43b0					endif 
43b0 cd 6e 1b				call forth_push_str 
43b3			 
43b3				       NEXTW 
43b3 cd 6c ee			call parse_vector 
43b6 c3 f0 1e			jp macro_next 
43b9				endm 
# End of macro NEXTW
43b9			 
43b9			 
43b9			 
43b9			.SCROLL: 
43b9				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
43b9 53				db WORD_SYS_CORE+63             
43ba e9 43			dw .SCROLLD            
43bc 07				db 6 + 1 
43bd .. 00			db "SCROLL",0              
43c4				endm 
# End of macro CWHEAD
43c4			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
43c4					if DEBUG_FORTH_WORDS_KEY 
43c4						DMARK "SCR" 
43c4 f5				push af  
43c5 3a d9 43			ld a, (.dmark)  
43c8 32 62 ee			ld (debug_mark),a  
43cb 3a da 43			ld a, (.dmark+1)  
43ce 32 63 ee			ld (debug_mark+1),a  
43d1 3a db 43			ld a, (.dmark+2)  
43d4 32 64 ee			ld (debug_mark+2),a  
43d7 18 03			jr .pastdmark  
43d9 ..			.dmark: db "SCR"  
43dc f1			.pastdmark: pop af  
43dd			endm  
# End of macro DMARK
43dd						CALLMONITOR 
43dd cd 6f ee			call debug_vector  
43e0				endm  
# End of macro CALLMONITOR
43e0					endif 
43e0			 
43e0 cd 8a 0b			call scroll_up 
43e3			;	call update_display 
43e3			 
43e3					NEXTW 
43e3 cd 6c ee			call parse_vector 
43e6 c3 f0 1e			jp macro_next 
43e9				endm 
# End of macro NEXTW
43e9			 
43e9			 
43e9			 
43e9			;		; get dir 
43e9			; 
43e9			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43e9			; 
43e9			;		push hl 
43e9			; 
43e9			;		; destroy value TOS 
43e9			; 
43e9			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43e9			; 
43e9			;		; get count 
43e9			; 
43e9			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43e9			; 
43e9			;		push hl 
43e9			; 
43e9			;		; destroy value TOS 
43e9			; 
43e9			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43e9			; 
43e9			;		; one value on hl get other one back 
43e9			; 
43e9			;		pop bc    ; count 
43e9			; 
43e9			;		pop de   ; dir 
43e9			; 
43e9			; 
43e9			;		ld b, c 
43e9			; 
43e9			;.scrolldir:     push bc 
43e9			;		push de 
43e9			; 
43e9			;		ld a, 0 
43e9			;		cp e 
43e9			;		jr z, .scrollup  
43e9			;		call scroll_down 
43e9			;		jr .scrollnext 
43e9			;.scrollup:	call scroll_up 
43e9			; 
43e9			;		 
43e9			;.scrollnext: 
43e9			;		pop de 
43e9			;		pop bc 
43e9			;		djnz .scrolldir 
43e9			; 
43e9			; 
43e9			; 
43e9			; 
43e9			; 
43e9			;		NEXTW 
43e9			 
43e9			.SCROLLD: 
43e9				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
43e9 53				db WORD_SYS_CORE+63             
43ea 1a 44			dw .ATQ            
43ec 08				db 7 + 1 
43ed .. 00			db "SCROLLD",0              
43f5				endm 
# End of macro CWHEAD
43f5			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
43f5					if DEBUG_FORTH_WORDS_KEY 
43f5						DMARK "SCD" 
43f5 f5				push af  
43f6 3a 0a 44			ld a, (.dmark)  
43f9 32 62 ee			ld (debug_mark),a  
43fc 3a 0b 44			ld a, (.dmark+1)  
43ff 32 63 ee			ld (debug_mark+1),a  
4402 3a 0c 44			ld a, (.dmark+2)  
4405 32 64 ee			ld (debug_mark+2),a  
4408 18 03			jr .pastdmark  
440a ..			.dmark: db "SCD"  
440d f1			.pastdmark: pop af  
440e			endm  
# End of macro DMARK
440e						CALLMONITOR 
440e cd 6f ee			call debug_vector  
4411				endm  
# End of macro CALLMONITOR
4411					endif 
4411			 
4411 cd ae 0b			call scroll_down 
4414			;	call update_display 
4414			 
4414					NEXTW 
4414 cd 6c ee			call parse_vector 
4417 c3 f0 1e			jp macro_next 
441a				endm 
# End of macro NEXTW
441a			 
441a			 
441a			.ATQ: 
441a				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
441a 62				db WORD_SYS_CORE+78             
441b 7b 44			dw .AUTODSP            
441d 04				db 3 + 1 
441e .. 00			db "AT@",0              
4422				endm 
# End of macro CWHEAD
4422			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
4422					if DEBUG_FORTH_WORDS_KEY 
4422						DMARK "ATA" 
4422 f5				push af  
4423 3a 37 44			ld a, (.dmark)  
4426 32 62 ee			ld (debug_mark),a  
4429 3a 38 44			ld a, (.dmark+1)  
442c 32 63 ee			ld (debug_mark+1),a  
442f 3a 39 44			ld a, (.dmark+2)  
4432 32 64 ee			ld (debug_mark+2),a  
4435 18 03			jr .pastdmark  
4437 ..			.dmark: db "ATA"  
443a f1			.pastdmark: pop af  
443b			endm  
# End of macro DMARK
443b						CALLMONITOR 
443b cd 6f ee			call debug_vector  
443e				endm  
# End of macro CALLMONITOR
443e					endif 
443e			 
443e			 
443e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
443e cd 05 1d			call macro_dsp_valuehl 
4441				endm 
# End of macro FORTH_DSP_VALUEHL
4441			 
4441					; TODO save cursor row 
4441 7d					ld a,l 
4442 fe 02				cp 2 
4444 20 04				jr nz, .crow3aq 
4446 3e 28				ld a, display_row_2 
4448 18 12				jr .ccol1aq 
444a fe 03		.crow3aq:		cp 3 
444c 20 04				jr nz, .crow4aq 
444e 3e 50				ld a, display_row_3 
4450 18 0a				jr .ccol1aq 
4452 fe 04		.crow4aq:		cp 4 
4454 20 04				jr nz, .crow1aq 
4456 3e 78				ld a, display_row_4 
4458 18 02				jr .ccol1aq 
445a 3e 00		.crow1aq:		ld a,display_row_1 
445c f5			.ccol1aq:		push af			; got row offset 
445d 6f					ld l,a 
445e 26 00				ld h,0 
4460					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4460 cd bd 1d			call macro_forth_dsp_pop 
4463				endm 
# End of macro FORTH_DSP_POP
4463					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4463 cd 05 1d			call macro_dsp_valuehl 
4466				endm 
# End of macro FORTH_DSP_VALUEHL
4466					; TODO save cursor col 
4466 f1					pop af 
4467 85					add l		; add col offset 
4468			 
4468					; add current frame buffer address 
4468 2a c3 eb				ld hl, (display_fb_active) 
446b cd f5 0d				call addatohl 
446e			 
446e			 
446e			 
446e			 
446e					; get char frame buffer location offset in hl 
446e			 
446e 7e					ld a,(hl) 
446f 26 00				ld h, 0 
4471 6f					ld l, a 
4472			 
4472 cd 00 1b				call forth_push_numhl 
4475			 
4475			 
4475					NEXTW 
4475 cd 6c ee			call parse_vector 
4478 c3 f0 1e			jp macro_next 
447b				endm 
# End of macro NEXTW
447b			 
447b			.AUTODSP: 
447b				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
447b 63				db WORD_SYS_CORE+79             
447c 94 44			dw .MENU            
447e 05				db 4 + 1 
447f .. 00			db "ADSP",0              
4484				endm 
# End of macro CWHEAD
4484			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4484			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4484			 
4484					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4484 cd 05 1d			call macro_dsp_valuehl 
4487				endm 
# End of macro FORTH_DSP_VALUEHL
4487			 
4487			;		push hl 
4487			 
4487					; destroy value TOS 
4487			 
4487					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4487 cd bd 1d			call macro_forth_dsp_pop 
448a				endm 
# End of macro FORTH_DSP_POP
448a			 
448a			;		pop hl 
448a			 
448a 7d					ld a,l 
448b 32 33 ea				ld (cli_autodisplay), a 
448e				       NEXTW 
448e cd 6c ee			call parse_vector 
4491 c3 f0 1e			jp macro_next 
4494				endm 
# End of macro NEXTW
4494			 
4494			.MENU: 
4494				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4494 70				db WORD_SYS_CORE+92             
4495 40 45			dw .ENDDISPLAY            
4497 05				db 4 + 1 
4498 .. 00			db "MENU",0              
449d				endm 
# End of macro CWHEAD
449d			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
449d			 
449d			;		; get number of items on the stack 
449d			; 
449d				 
449d					FORTH_DSP_VALUEHL 
449d cd 05 1d			call macro_dsp_valuehl 
44a0				endm 
# End of macro FORTH_DSP_VALUEHL
44a0				 
44a0					if DEBUG_FORTH_WORDS_KEY 
44a0						DMARK "MNU" 
44a0 f5				push af  
44a1 3a b5 44			ld a, (.dmark)  
44a4 32 62 ee			ld (debug_mark),a  
44a7 3a b6 44			ld a, (.dmark+1)  
44aa 32 63 ee			ld (debug_mark+1),a  
44ad 3a b7 44			ld a, (.dmark+2)  
44b0 32 64 ee			ld (debug_mark+2),a  
44b3 18 03			jr .pastdmark  
44b5 ..			.dmark: db "MNU"  
44b8 f1			.pastdmark: pop af  
44b9			endm  
# End of macro DMARK
44b9						CALLMONITOR 
44b9 cd 6f ee			call debug_vector  
44bc				endm  
# End of macro CALLMONITOR
44bc					endif 
44bc			 
44bc 45					ld b, l	 
44bd 05					dec b 
44be			 
44be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44be cd bd 1d			call macro_forth_dsp_pop 
44c1				endm 
# End of macro FORTH_DSP_POP
44c1			 
44c1			 
44c1					; go directly through the stack to pluck out the string pointers and build an array 
44c1			 
44c1			;		FORTH_DSP 
44c1			 
44c1					; hl contains top most stack item 
44c1				 
44c1 11 b8 e2				ld de, scratch 
44c4			 
44c4			.mbuild: 
44c4			 
44c4					FORTH_DSP_VALUEHL 
44c4 cd 05 1d			call macro_dsp_valuehl 
44c7				endm 
# End of macro FORTH_DSP_VALUEHL
44c7			 
44c7					if DEBUG_FORTH_WORDS 
44c7						DMARK "MN3" 
44c7 f5				push af  
44c8 3a dc 44			ld a, (.dmark)  
44cb 32 62 ee			ld (debug_mark),a  
44ce 3a dd 44			ld a, (.dmark+1)  
44d1 32 63 ee			ld (debug_mark+1),a  
44d4 3a de 44			ld a, (.dmark+2)  
44d7 32 64 ee			ld (debug_mark+2),a  
44da 18 03			jr .pastdmark  
44dc ..			.dmark: db "MN3"  
44df f1			.pastdmark: pop af  
44e0			endm  
# End of macro DMARK
44e0						CALLMONITOR 
44e0 cd 6f ee			call debug_vector  
44e3				endm  
# End of macro CALLMONITOR
44e3					endif 
44e3 eb					ex de, hl 
44e4 73					ld (hl), e 
44e5 23					inc hl 
44e6 72					ld (hl), d 
44e7 23					inc hl 
44e8 eb					ex de, hl 
44e9			 
44e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44e9 cd bd 1d			call macro_forth_dsp_pop 
44ec				endm 
# End of macro FORTH_DSP_POP
44ec			 
44ec 10 d6				djnz .mbuild 
44ee			 
44ee					; done add term 
44ee			 
44ee eb					ex de, hl 
44ef 36 00				ld (hl), 0 
44f1 23					inc hl 
44f2 36 00				ld (hl), 0 
44f4			 
44f4				 
44f4					 
44f4 21 b8 e2				ld hl, scratch 
44f7			 
44f7					if DEBUG_FORTH_WORDS 
44f7						DMARK "MNx" 
44f7 f5				push af  
44f8 3a 0c 45			ld a, (.dmark)  
44fb 32 62 ee			ld (debug_mark),a  
44fe 3a 0d 45			ld a, (.dmark+1)  
4501 32 63 ee			ld (debug_mark+1),a  
4504 3a 0e 45			ld a, (.dmark+2)  
4507 32 64 ee			ld (debug_mark+2),a  
450a 18 03			jr .pastdmark  
450c ..			.dmark: db "MNx"  
450f f1			.pastdmark: pop af  
4510			endm  
# End of macro DMARK
4510						CALLMONITOR 
4510 cd 6f ee			call debug_vector  
4513				endm  
# End of macro CALLMONITOR
4513					endif 
4513			 
4513			 
4513			 
4513 3e 00				ld a, 0 
4515 cd f9 0b				call menu 
4518			 
4518			 
4518 6f					ld l, a 
4519 26 00				ld h, 0 
451b			 
451b					if DEBUG_FORTH_WORDS 
451b						DMARK "MNr" 
451b f5				push af  
451c 3a 30 45			ld a, (.dmark)  
451f 32 62 ee			ld (debug_mark),a  
4522 3a 31 45			ld a, (.dmark+1)  
4525 32 63 ee			ld (debug_mark+1),a  
4528 3a 32 45			ld a, (.dmark+2)  
452b 32 64 ee			ld (debug_mark+2),a  
452e 18 03			jr .pastdmark  
4530 ..			.dmark: db "MNr"  
4533 f1			.pastdmark: pop af  
4534			endm  
# End of macro DMARK
4534						CALLMONITOR 
4534 cd 6f ee			call debug_vector  
4537				endm  
# End of macro CALLMONITOR
4537					endif 
4537			 
4537 cd 00 1b				call forth_push_numhl 
453a			 
453a			 
453a			 
453a			 
453a				       NEXTW 
453a cd 6c ee			call parse_vector 
453d c3 f0 1e			jp macro_next 
4540				endm 
# End of macro NEXTW
4540			 
4540			 
4540			.ENDDISPLAY: 
4540			 
4540			; eof 
# End of file forth_words_display.asm
4540			include "forth_words_str.asm" 
4540			 
4540			; | ## String Words 
4540			 
4540			.SPLIT:   
4540			 
4540				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
4540 48				db WORD_SYS_CORE+52             
4541 38 46			dw .PTR            
4543 06				db 5 + 1 
4544 .. 00			db "SPLIT",0              
454a				endm 
# End of macro CWHEAD
454a			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | DONE 
454a					if DEBUG_FORTH_WORDS_KEY 
454a						DMARK "SPT" 
454a f5				push af  
454b 3a 5f 45			ld a, (.dmark)  
454e 32 62 ee			ld (debug_mark),a  
4551 3a 60 45			ld a, (.dmark+1)  
4554 32 63 ee			ld (debug_mark+1),a  
4557 3a 61 45			ld a, (.dmark+2)  
455a 32 64 ee			ld (debug_mark+2),a  
455d 18 03			jr .pastdmark  
455f ..			.dmark: db "SPT"  
4562 f1			.pastdmark: pop af  
4563			endm  
# End of macro DMARK
4563						CALLMONITOR 
4563 cd 6f ee			call debug_vector  
4566				endm  
# End of macro CALLMONITOR
4566					endif 
4566			 
4566					; get delim 
4566					FORTH_DSP_VALUEHL 
4566 cd 05 1d			call macro_dsp_valuehl 
4569				endm 
# End of macro FORTH_DSP_VALUEHL
4569			 
4569					FORTH_DSP_POP 
4569 cd bd 1d			call macro_forth_dsp_pop 
456c				endm 
# End of macro FORTH_DSP_POP
456c					 
456c			 
456c 45					ld b, l    ; move delim to b 
456d 0e 01				ld c, 1   ; count of poritions 
456f			 
456f c5					push bc 
4570			 
4570					if DEBUG_FORTH_WORDS 
4570						DMARK "SPa" 
4570 f5				push af  
4571 3a 85 45			ld a, (.dmark)  
4574 32 62 ee			ld (debug_mark),a  
4577 3a 86 45			ld a, (.dmark+1)  
457a 32 63 ee			ld (debug_mark+1),a  
457d 3a 87 45			ld a, (.dmark+2)  
4580 32 64 ee			ld (debug_mark+2),a  
4583 18 03			jr .pastdmark  
4585 ..			.dmark: db "SPa"  
4588 f1			.pastdmark: pop af  
4589			endm  
# End of macro DMARK
4589						CALLMONITOR 
4589 cd 6f ee			call debug_vector  
458c				endm  
# End of macro CALLMONITOR
458c					endif 
458c					; get pointer to string to chop up 
458c					FORTH_DSP_VALUEHL 
458c cd 05 1d			call macro_dsp_valuehl 
458f				endm 
# End of macro FORTH_DSP_VALUEHL
458f			 
458f			;		push hl 
458f 11 b8 e2				ld de, scratch 
4592			.spllop: 
4592 c1					pop bc 
4593 c5					push bc 
4594			;		pop hl 
4594					if DEBUG_FORTH_WORDS 
4594						DMARK "SPl" 
4594 f5				push af  
4595 3a a9 45			ld a, (.dmark)  
4598 32 62 ee			ld (debug_mark),a  
459b 3a aa 45			ld a, (.dmark+1)  
459e 32 63 ee			ld (debug_mark+1),a  
45a1 3a ab 45			ld a, (.dmark+2)  
45a4 32 64 ee			ld (debug_mark+2),a  
45a7 18 03			jr .pastdmark  
45a9 ..			.dmark: db "SPl"  
45ac f1			.pastdmark: pop af  
45ad			endm  
# End of macro DMARK
45ad						CALLMONITOR 
45ad cd 6f ee			call debug_vector  
45b0				endm  
# End of macro CALLMONITOR
45b0					endif 
45b0 7e					ld a, (hl) 
45b1 b8					cp b 
45b2 28 08				jr z, .splnxt 
45b4 fe 00				cp 0 
45b6 28 34				jr z, .splend 
45b8 ed a0				ldi 
45ba 18 d6				jr .spllop 
45bc			 
45bc					; hit dlim 
45bc			 
45bc			.splnxt: 
45bc					if DEBUG_FORTH_WORDS 
45bc						DMARK "SPx" 
45bc f5				push af  
45bd 3a d1 45			ld a, (.dmark)  
45c0 32 62 ee			ld (debug_mark),a  
45c3 3a d2 45			ld a, (.dmark+1)  
45c6 32 63 ee			ld (debug_mark+1),a  
45c9 3a d3 45			ld a, (.dmark+2)  
45cc 32 64 ee			ld (debug_mark+2),a  
45cf 18 03			jr .pastdmark  
45d1 ..			.dmark: db "SPx"  
45d4 f1			.pastdmark: pop af  
45d5			endm  
# End of macro DMARK
45d5						CALLMONITOR 
45d5 cd 6f ee			call debug_vector  
45d8				endm  
# End of macro CALLMONITOR
45d8					endif 
45d8 3e 00				ld a, 0 
45da 12					ld (de), a 
45db					;ex de, hl 
45db e5					push hl 
45dc 21 b8 e2				ld hl, scratch 
45df cd 6e 1b				call forth_push_str 
45e2 e1					pop hl 
45e3					;ex de, hl 
45e3 23					inc hl 
45e4 c1					pop bc 
45e5 0c					inc c 
45e6 c5					push bc 
45e7 11 b8 e2				ld de, scratch 
45ea 18 a6				jr .spllop 
45ec			 
45ec			.splend:		 
45ec					if DEBUG_FORTH_WORDS 
45ec						DMARK "SPe" 
45ec f5				push af  
45ed 3a 01 46			ld a, (.dmark)  
45f0 32 62 ee			ld (debug_mark),a  
45f3 3a 02 46			ld a, (.dmark+1)  
45f6 32 63 ee			ld (debug_mark+1),a  
45f9 3a 03 46			ld a, (.dmark+2)  
45fc 32 64 ee			ld (debug_mark+2),a  
45ff 18 03			jr .pastdmark  
4601 ..			.dmark: db "SPe"  
4604 f1			.pastdmark: pop af  
4605			endm  
# End of macro DMARK
4605						CALLMONITOR 
4605 cd 6f ee			call debug_vector  
4608				endm  
# End of macro CALLMONITOR
4608					endif 
4608 12					ld (de), a 
4609 eb					ex de, hl 
460a			;		push hl 
460a 21 b8 e2				ld hl, scratch 
460d cd 6e 1b				call forth_push_str 
4610					 
4610					if DEBUG_FORTH_WORDS 
4610						DMARK "SPc" 
4610 f5				push af  
4611 3a 25 46			ld a, (.dmark)  
4614 32 62 ee			ld (debug_mark),a  
4617 3a 26 46			ld a, (.dmark+1)  
461a 32 63 ee			ld (debug_mark+1),a  
461d 3a 27 46			ld a, (.dmark+2)  
4620 32 64 ee			ld (debug_mark+2),a  
4623 18 03			jr .pastdmark  
4625 ..			.dmark: db "SPc"  
4628 f1			.pastdmark: pop af  
4629			endm  
# End of macro DMARK
4629						CALLMONITOR 
4629 cd 6f ee			call debug_vector  
462c				endm  
# End of macro CALLMONITOR
462c					endif 
462c			 
462c e1					pop hl    ; get counter from bc which has been push 
462d 26 00				ld h, 0 
462f			;		ld l, c 
462f cd 00 1b				call forth_push_numhl 
4632			 
4632			 
4632				NEXTW 
4632 cd 6c ee			call parse_vector 
4635 c3 f0 1e			jp macro_next 
4638				endm 
# End of macro NEXTW
4638			.PTR:   
4638			 
4638				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4638 48				db WORD_SYS_CORE+52             
4639 68 46			dw .STYPE            
463b 04				db 3 + 1 
463c .. 00			db "PTR",0              
4640				endm 
# End of macro CWHEAD
4640			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4640			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4640			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4640			 
4640					if DEBUG_FORTH_WORDS_KEY 
4640						DMARK "PTR" 
4640 f5				push af  
4641 3a 55 46			ld a, (.dmark)  
4644 32 62 ee			ld (debug_mark),a  
4647 3a 56 46			ld a, (.dmark+1)  
464a 32 63 ee			ld (debug_mark+1),a  
464d 3a 57 46			ld a, (.dmark+2)  
4650 32 64 ee			ld (debug_mark+2),a  
4653 18 03			jr .pastdmark  
4655 ..			.dmark: db "PTR"  
4658 f1			.pastdmark: pop af  
4659			endm  
# End of macro DMARK
4659						CALLMONITOR 
4659 cd 6f ee			call debug_vector  
465c				endm  
# End of macro CALLMONITOR
465c					endif 
465c					FORTH_DSP_VALUEHL 
465c cd 05 1d			call macro_dsp_valuehl 
465f				endm 
# End of macro FORTH_DSP_VALUEHL
465f cd 00 1b				call forth_push_numhl 
4662			 
4662			 
4662					NEXTW 
4662 cd 6c ee			call parse_vector 
4665 c3 f0 1e			jp macro_next 
4668				endm 
# End of macro NEXTW
4668			.STYPE: 
4668				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4668 48				db WORD_SYS_CORE+52             
4669 ba 46			dw .UPPER            
466b 06				db 5 + 1 
466c .. 00			db "STYPE",0              
4672				endm 
# End of macro CWHEAD
4672			; | STYPE ( u -- u type ) Push type of value on TOS  | DONE 
4672			; | | 's' string or 'i' integer 
4672					if DEBUG_FORTH_WORDS_KEY 
4672						DMARK "STY" 
4672 f5				push af  
4673 3a 87 46			ld a, (.dmark)  
4676 32 62 ee			ld (debug_mark),a  
4679 3a 88 46			ld a, (.dmark+1)  
467c 32 63 ee			ld (debug_mark+1),a  
467f 3a 89 46			ld a, (.dmark+2)  
4682 32 64 ee			ld (debug_mark+2),a  
4685 18 03			jr .pastdmark  
4687 ..			.dmark: db "STY"  
468a f1			.pastdmark: pop af  
468b			endm  
# End of macro DMARK
468b						CALLMONITOR 
468b cd 6f ee			call debug_vector  
468e				endm  
# End of macro CALLMONITOR
468e					endif 
468e					FORTH_DSP 
468e cd cb 1c			call macro_forth_dsp 
4691				endm 
# End of macro FORTH_DSP
4691					;v5 FORTH_DSP_VALUE 
4691			 
4691 7e					ld a, (hl) 
4692			 
4692 f5					push af 
4693			 
4693			; Dont destroy TOS		FORTH_DSP_POP 
4693			 
4693 f1					pop af 
4694			 
4694 fe 01				cp DS_TYPE_STR 
4696 28 09				jr z, .typestr 
4698			 
4698 fe 02				cp DS_TYPE_INUM 
469a 28 0a				jr z, .typeinum 
469c			 
469c 21 b8 46				ld hl, .tna 
469f 18 0a				jr .tpush 
46a1			 
46a1 21 b4 46		.typestr:	ld hl, .tstr 
46a4 18 05				jr .tpush 
46a6 21 b6 46		.typeinum:	ld hl, .tinum 
46a9 18 00				jr .tpush 
46ab			 
46ab			.tpush: 
46ab			 
46ab cd 6e 1b				call forth_push_str 
46ae			 
46ae					NEXTW 
46ae cd 6c ee			call parse_vector 
46b1 c3 f0 1e			jp macro_next 
46b4				endm 
# End of macro NEXTW
46b4 .. 00		.tstr:	db "s",0 
46b6 .. 00		.tinum:  db "i",0 
46b8 .. 00		.tna:   db "?", 0 
46ba			 
46ba			 
46ba			.UPPER: 
46ba				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
46ba 48				db WORD_SYS_CORE+52             
46bb f8 46			dw .LOWER            
46bd 06				db 5 + 1 
46be .. 00			db "UPPER",0              
46c4				endm 
# End of macro CWHEAD
46c4			; | UPPER ( s -- s ) Upper case string s  | DONE 
46c4					if DEBUG_FORTH_WORDS_KEY 
46c4						DMARK "UPR" 
46c4 f5				push af  
46c5 3a d9 46			ld a, (.dmark)  
46c8 32 62 ee			ld (debug_mark),a  
46cb 3a da 46			ld a, (.dmark+1)  
46ce 32 63 ee			ld (debug_mark+1),a  
46d1 3a db 46			ld a, (.dmark+2)  
46d4 32 64 ee			ld (debug_mark+2),a  
46d7 18 03			jr .pastdmark  
46d9 ..			.dmark: db "UPR"  
46dc f1			.pastdmark: pop af  
46dd			endm  
# End of macro DMARK
46dd						CALLMONITOR 
46dd cd 6f ee			call debug_vector  
46e0				endm  
# End of macro CALLMONITOR
46e0					endif 
46e0			 
46e0					FORTH_DSP 
46e0 cd cb 1c			call macro_forth_dsp 
46e3				endm 
# End of macro FORTH_DSP
46e3					 
46e3			; TODO check is string type 
46e3			 
46e3					FORTH_DSP_VALUEHL 
46e3 cd 05 1d			call macro_dsp_valuehl 
46e6				endm 
# End of macro FORTH_DSP_VALUEHL
46e6			; get pointer to string in hl 
46e6			 
46e6 7e			.toup:		ld a, (hl) 
46e7 fe 00				cp 0 
46e9 28 07				jr z, .toupdone 
46eb			 
46eb cd 6a 10				call to_upper 
46ee			 
46ee 77					ld (hl), a 
46ef 23					inc hl 
46f0 18 f4				jr .toup 
46f2			 
46f2					 
46f2			 
46f2			 
46f2			; for each char convert to upper 
46f2					 
46f2			.toupdone: 
46f2			 
46f2			 
46f2					NEXTW 
46f2 cd 6c ee			call parse_vector 
46f5 c3 f0 1e			jp macro_next 
46f8				endm 
# End of macro NEXTW
46f8			.LOWER: 
46f8				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
46f8 48				db WORD_SYS_CORE+52             
46f9 36 47			dw .TCASE            
46fb 06				db 5 + 1 
46fc .. 00			db "LOWER",0              
4702				endm 
# End of macro CWHEAD
4702			; | LOWER ( s -- s ) Lower case string s  | DONE 
4702					if DEBUG_FORTH_WORDS_KEY 
4702						DMARK "LWR" 
4702 f5				push af  
4703 3a 17 47			ld a, (.dmark)  
4706 32 62 ee			ld (debug_mark),a  
4709 3a 18 47			ld a, (.dmark+1)  
470c 32 63 ee			ld (debug_mark+1),a  
470f 3a 19 47			ld a, (.dmark+2)  
4712 32 64 ee			ld (debug_mark+2),a  
4715 18 03			jr .pastdmark  
4717 ..			.dmark: db "LWR"  
471a f1			.pastdmark: pop af  
471b			endm  
# End of macro DMARK
471b						CALLMONITOR 
471b cd 6f ee			call debug_vector  
471e				endm  
# End of macro CALLMONITOR
471e					endif 
471e			 
471e					FORTH_DSP 
471e cd cb 1c			call macro_forth_dsp 
4721				endm 
# End of macro FORTH_DSP
4721					 
4721			; TODO check is string type 
4721			 
4721					FORTH_DSP_VALUEHL 
4721 cd 05 1d			call macro_dsp_valuehl 
4724				endm 
# End of macro FORTH_DSP_VALUEHL
4724			; get pointer to string in hl 
4724			 
4724 7e			.tolow:		ld a, (hl) 
4725 fe 00				cp 0 
4727 28 07				jr z, .tolowdone 
4729			 
4729 cd 73 10				call to_lower 
472c			 
472c 77					ld (hl), a 
472d 23					inc hl 
472e 18 f4				jr .tolow 
4730			 
4730					 
4730			 
4730			 
4730			; for each char convert to low 
4730					 
4730			.tolowdone: 
4730					NEXTW 
4730 cd 6c ee			call parse_vector 
4733 c3 f0 1e			jp macro_next 
4736				endm 
# End of macro NEXTW
4736			.TCASE: 
4736				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4736 48				db WORD_SYS_CORE+52             
4737 6f 48			dw .SUBSTR            
4739 06				db 5 + 1 
473a .. 00			db "TCASE",0              
4740				endm 
# End of macro CWHEAD
4740			; | TCASE ( s -- s ) Title case string s  | DONE 
4740					if DEBUG_FORTH_WORDS_KEY 
4740						DMARK "TCS" 
4740 f5				push af  
4741 3a 55 47			ld a, (.dmark)  
4744 32 62 ee			ld (debug_mark),a  
4747 3a 56 47			ld a, (.dmark+1)  
474a 32 63 ee			ld (debug_mark+1),a  
474d 3a 57 47			ld a, (.dmark+2)  
4750 32 64 ee			ld (debug_mark+2),a  
4753 18 03			jr .pastdmark  
4755 ..			.dmark: db "TCS"  
4758 f1			.pastdmark: pop af  
4759			endm  
# End of macro DMARK
4759						CALLMONITOR 
4759 cd 6f ee			call debug_vector  
475c				endm  
# End of macro CALLMONITOR
475c					endif 
475c			 
475c					FORTH_DSP 
475c cd cb 1c			call macro_forth_dsp 
475f				endm 
# End of macro FORTH_DSP
475f					 
475f			; TODO check is string type 
475f			 
475f					FORTH_DSP_VALUEHL 
475f cd 05 1d			call macro_dsp_valuehl 
4762				endm 
# End of macro FORTH_DSP_VALUEHL
4762			; get pointer to string in hl 
4762			 
4762					if DEBUG_FORTH_WORDS 
4762						DMARK "TC1" 
4762 f5				push af  
4763 3a 77 47			ld a, (.dmark)  
4766 32 62 ee			ld (debug_mark),a  
4769 3a 78 47			ld a, (.dmark+1)  
476c 32 63 ee			ld (debug_mark+1),a  
476f 3a 79 47			ld a, (.dmark+2)  
4772 32 64 ee			ld (debug_mark+2),a  
4775 18 03			jr .pastdmark  
4777 ..			.dmark: db "TC1"  
477a f1			.pastdmark: pop af  
477b			endm  
# End of macro DMARK
477b						CALLMONITOR 
477b cd 6f ee			call debug_vector  
477e				endm  
# End of macro CALLMONITOR
477e					endif 
477e			 
477e					; first time in turn to upper case first char 
477e			 
477e 7e					ld a, (hl) 
477f c3 09 48				jp .totsiptou 
4782			 
4782			 
4782 7e			.tot:		ld a, (hl) 
4783 fe 00				cp 0 
4785 ca 4d 48				jp z, .totdone 
4788			 
4788					if DEBUG_FORTH_WORDS 
4788						DMARK "TC2" 
4788 f5				push af  
4789 3a 9d 47			ld a, (.dmark)  
478c 32 62 ee			ld (debug_mark),a  
478f 3a 9e 47			ld a, (.dmark+1)  
4792 32 63 ee			ld (debug_mark+1),a  
4795 3a 9f 47			ld a, (.dmark+2)  
4798 32 64 ee			ld (debug_mark+2),a  
479b 18 03			jr .pastdmark  
479d ..			.dmark: db "TC2"  
47a0 f1			.pastdmark: pop af  
47a1			endm  
# End of macro DMARK
47a1						CALLMONITOR 
47a1 cd 6f ee			call debug_vector  
47a4				endm  
# End of macro CALLMONITOR
47a4					endif 
47a4					; check to see if current char is a space 
47a4			 
47a4 fe 20				cp ' ' 
47a6 28 21				jr z, .totsp 
47a8 cd 73 10				call to_lower 
47ab					if DEBUG_FORTH_WORDS 
47ab						DMARK "TC3" 
47ab f5				push af  
47ac 3a c0 47			ld a, (.dmark)  
47af 32 62 ee			ld (debug_mark),a  
47b2 3a c1 47			ld a, (.dmark+1)  
47b5 32 63 ee			ld (debug_mark+1),a  
47b8 3a c2 47			ld a, (.dmark+2)  
47bb 32 64 ee			ld (debug_mark+2),a  
47be 18 03			jr .pastdmark  
47c0 ..			.dmark: db "TC3"  
47c3 f1			.pastdmark: pop af  
47c4			endm  
# End of macro DMARK
47c4						CALLMONITOR 
47c4 cd 6f ee			call debug_vector  
47c7				endm  
# End of macro CALLMONITOR
47c7					endif 
47c7 18 63				jr .totnxt 
47c9			 
47c9			.totsp:         ; on a space, find next char which should be upper 
47c9			 
47c9					if DEBUG_FORTH_WORDS 
47c9						DMARK "TC4" 
47c9 f5				push af  
47ca 3a de 47			ld a, (.dmark)  
47cd 32 62 ee			ld (debug_mark),a  
47d0 3a df 47			ld a, (.dmark+1)  
47d3 32 63 ee			ld (debug_mark+1),a  
47d6 3a e0 47			ld a, (.dmark+2)  
47d9 32 64 ee			ld (debug_mark+2),a  
47dc 18 03			jr .pastdmark  
47de ..			.dmark: db "TC4"  
47e1 f1			.pastdmark: pop af  
47e2			endm  
# End of macro DMARK
47e2						CALLMONITOR 
47e2 cd 6f ee			call debug_vector  
47e5				endm  
# End of macro CALLMONITOR
47e5					endif 
47e5					;; 
47e5			 
47e5 fe 20				cp ' ' 
47e7 20 20				jr nz, .totsiptou 
47e9 23					inc hl 
47ea 7e					ld a, (hl) 
47eb					if DEBUG_FORTH_WORDS 
47eb						DMARK "TC5" 
47eb f5				push af  
47ec 3a 00 48			ld a, (.dmark)  
47ef 32 62 ee			ld (debug_mark),a  
47f2 3a 01 48			ld a, (.dmark+1)  
47f5 32 63 ee			ld (debug_mark+1),a  
47f8 3a 02 48			ld a, (.dmark+2)  
47fb 32 64 ee			ld (debug_mark+2),a  
47fe 18 03			jr .pastdmark  
4800 ..			.dmark: db "TC5"  
4803 f1			.pastdmark: pop af  
4804			endm  
# End of macro DMARK
4804						CALLMONITOR 
4804 cd 6f ee			call debug_vector  
4807				endm  
# End of macro CALLMONITOR
4807					endif 
4807 18 c0				jr .totsp 
4809 fe 00		.totsiptou:    cp 0 
480b 28 40				jr z, .totdone 
480d					; not space and not zero term so upper case it 
480d cd 6a 10				call to_upper 
4810			 
4810					if DEBUG_FORTH_WORDS 
4810						DMARK "TC6" 
4810 f5				push af  
4811 3a 25 48			ld a, (.dmark)  
4814 32 62 ee			ld (debug_mark),a  
4817 3a 26 48			ld a, (.dmark+1)  
481a 32 63 ee			ld (debug_mark+1),a  
481d 3a 27 48			ld a, (.dmark+2)  
4820 32 64 ee			ld (debug_mark+2),a  
4823 18 03			jr .pastdmark  
4825 ..			.dmark: db "TC6"  
4828 f1			.pastdmark: pop af  
4829			endm  
# End of macro DMARK
4829						CALLMONITOR 
4829 cd 6f ee			call debug_vector  
482c				endm  
# End of macro CALLMONITOR
482c					endif 
482c			 
482c			 
482c			.totnxt: 
482c			 
482c 77					ld (hl), a 
482d 23					inc hl 
482e					if DEBUG_FORTH_WORDS 
482e						DMARK "TC7" 
482e f5				push af  
482f 3a 43 48			ld a, (.dmark)  
4832 32 62 ee			ld (debug_mark),a  
4835 3a 44 48			ld a, (.dmark+1)  
4838 32 63 ee			ld (debug_mark+1),a  
483b 3a 45 48			ld a, (.dmark+2)  
483e 32 64 ee			ld (debug_mark+2),a  
4841 18 03			jr .pastdmark  
4843 ..			.dmark: db "TC7"  
4846 f1			.pastdmark: pop af  
4847			endm  
# End of macro DMARK
4847						CALLMONITOR 
4847 cd 6f ee			call debug_vector  
484a				endm  
# End of macro CALLMONITOR
484a					endif 
484a c3 82 47				jp .tot 
484d			 
484d					 
484d			 
484d			 
484d			; for each char convert to low 
484d					 
484d			.totdone: 
484d					if DEBUG_FORTH_WORDS 
484d						DMARK "TCd" 
484d f5				push af  
484e 3a 62 48			ld a, (.dmark)  
4851 32 62 ee			ld (debug_mark),a  
4854 3a 63 48			ld a, (.dmark+1)  
4857 32 63 ee			ld (debug_mark+1),a  
485a 3a 64 48			ld a, (.dmark+2)  
485d 32 64 ee			ld (debug_mark+2),a  
4860 18 03			jr .pastdmark  
4862 ..			.dmark: db "TCd"  
4865 f1			.pastdmark: pop af  
4866			endm  
# End of macro DMARK
4866						CALLMONITOR 
4866 cd 6f ee			call debug_vector  
4869				endm  
# End of macro CALLMONITOR
4869					endif 
4869					NEXTW 
4869 cd 6c ee			call parse_vector 
486c c3 f0 1e			jp macro_next 
486f				endm 
# End of macro NEXTW
486f			 
486f			.SUBSTR: 
486f				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
486f 48				db WORD_SYS_CORE+52             
4870 d0 48			dw .LEFT            
4872 07				db 6 + 1 
4873 .. 00			db "SUBSTR",0              
487a				endm 
# End of macro CWHEAD
487a			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
487a			 
487a					if DEBUG_FORTH_WORDS_KEY 
487a						DMARK "SST" 
487a f5				push af  
487b 3a 8f 48			ld a, (.dmark)  
487e 32 62 ee			ld (debug_mark),a  
4881 3a 90 48			ld a, (.dmark+1)  
4884 32 63 ee			ld (debug_mark+1),a  
4887 3a 91 48			ld a, (.dmark+2)  
488a 32 64 ee			ld (debug_mark+2),a  
488d 18 03			jr .pastdmark  
488f ..			.dmark: db "SST"  
4892 f1			.pastdmark: pop af  
4893			endm  
# End of macro DMARK
4893						CALLMONITOR 
4893 cd 6f ee			call debug_vector  
4896				endm  
# End of macro CALLMONITOR
4896					endif 
4896			; TODO check string type 
4896					FORTH_DSP_VALUEHL 
4896 cd 05 1d			call macro_dsp_valuehl 
4899				endm 
# End of macro FORTH_DSP_VALUEHL
4899			 
4899 e5					push hl      ; string length 
489a			 
489a					FORTH_DSP_POP 
489a cd bd 1d			call macro_forth_dsp_pop 
489d				endm 
# End of macro FORTH_DSP_POP
489d			 
489d					FORTH_DSP_VALUEHL 
489d cd 05 1d			call macro_dsp_valuehl 
48a0				endm 
# End of macro FORTH_DSP_VALUEHL
48a0			 
48a0 e5					push hl     ; start char 
48a1			 
48a1					FORTH_DSP_POP 
48a1 cd bd 1d			call macro_forth_dsp_pop 
48a4				endm 
# End of macro FORTH_DSP_POP
48a4			 
48a4			 
48a4					FORTH_DSP_VALUE 
48a4 cd ee 1c			call macro_forth_dsp_value 
48a7				endm 
# End of macro FORTH_DSP_VALUE
48a7			 
48a7 d1					pop de    ; get start post offset 
48a8			 
48a8 19					add hl, de    ; starting offset 
48a9			 
48a9 c1					pop bc 
48aa c5					push bc      ; grab size of string 
48ab			 
48ab e5					push hl    ; save string start  
48ac			 
48ac 26 00				ld h, 0 
48ae 69					ld l, c 
48af 23					inc hl 
48b0 23					inc hl 
48b1			 
48b1 cd d0 11				call malloc 
48b4				if DEBUG_FORTH_MALLOC_GUARD 
48b4 cc a9 53				call z,malloc_error 
48b7				endif 
48b7			 
48b7 eb					ex de, hl      ; save malloc area for string copy 
48b8 e1					pop hl    ; get back source 
48b9 c1					pop bc    ; get length of string back 
48ba			 
48ba d5					push de    ; save malloc area for after we push 
48bb ed b0				ldir     ; copy substr 
48bd			 
48bd			 
48bd eb					ex de, hl 
48be 3e 00				ld a, 0 
48c0 77					ld (hl), a   ; term substr 
48c1			 
48c1					 
48c1 e1					pop hl    ; get malloc so we can push it 
48c2 e5					push hl   ; save so we can free it afterwards 
48c3			 
48c3 cd 6e 1b				call forth_push_str 
48c6			 
48c6 e1					pop hl 
48c7 cd 9a 12				call free 
48ca			 
48ca					 
48ca					 
48ca			 
48ca			 
48ca					NEXTW 
48ca cd 6c ee			call parse_vector 
48cd c3 f0 1e			jp macro_next 
48d0				endm 
# End of macro NEXTW
48d0			 
48d0			.LEFT: 
48d0				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
48d0 48				db WORD_SYS_CORE+52             
48d1 14 49			dw .RIGHT            
48d3 05				db 4 + 1 
48d4 .. 00			db "LEFT",0              
48d9				endm 
# End of macro CWHEAD
48d9			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | DONE 
48d9					if DEBUG_FORTH_WORDS_KEY 
48d9						DMARK "LEF" 
48d9 f5				push af  
48da 3a ee 48			ld a, (.dmark)  
48dd 32 62 ee			ld (debug_mark),a  
48e0 3a ef 48			ld a, (.dmark+1)  
48e3 32 63 ee			ld (debug_mark+1),a  
48e6 3a f0 48			ld a, (.dmark+2)  
48e9 32 64 ee			ld (debug_mark+2),a  
48ec 18 03			jr .pastdmark  
48ee ..			.dmark: db "LEF"  
48f1 f1			.pastdmark: pop af  
48f2			endm  
# End of macro DMARK
48f2						CALLMONITOR 
48f2 cd 6f ee			call debug_vector  
48f5				endm  
# End of macro CALLMONITOR
48f5					endif 
48f5			 
48f5					 
48f5			; TODO check string type 
48f5					FORTH_DSP_VALUEHL 
48f5 cd 05 1d			call macro_dsp_valuehl 
48f8				endm 
# End of macro FORTH_DSP_VALUEHL
48f8			 
48f8 e5					push hl      ; string length 
48f9			 
48f9					FORTH_DSP_POP 
48f9 cd bd 1d			call macro_forth_dsp_pop 
48fc				endm 
# End of macro FORTH_DSP_POP
48fc			 
48fc					FORTH_DSP_VALUEHL 
48fc cd 05 1d			call macro_dsp_valuehl 
48ff				endm 
# End of macro FORTH_DSP_VALUEHL
48ff			 
48ff c1					pop bc 
4900			 
4900 11 b8 e2				ld de, scratch 
4903 ed b0				ldir 
4905 3e 00				ld a, 0 
4907 12					ld (de), a 
4908					 
4908 21 b8 e2				ld hl, scratch 
490b cd 6e 1b				call forth_push_str 
490e			 
490e					NEXTW 
490e cd 6c ee			call parse_vector 
4911 c3 f0 1e			jp macro_next 
4914				endm 
# End of macro NEXTW
4914			.RIGHT: 
4914				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4914 48				db WORD_SYS_CORE+52             
4915 d5 49			dw .STR2NUM            
4917 06				db 5 + 1 
4918 .. 00			db "RIGHT",0              
491e				endm 
# End of macro CWHEAD
491e			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | DONE 
491e					if DEBUG_FORTH_WORDS_KEY 
491e						DMARK "RIG" 
491e f5				push af  
491f 3a 33 49			ld a, (.dmark)  
4922 32 62 ee			ld (debug_mark),a  
4925 3a 34 49			ld a, (.dmark+1)  
4928 32 63 ee			ld (debug_mark+1),a  
492b 3a 35 49			ld a, (.dmark+2)  
492e 32 64 ee			ld (debug_mark+2),a  
4931 18 03			jr .pastdmark  
4933 ..			.dmark: db "RIG"  
4936 f1			.pastdmark: pop af  
4937			endm  
# End of macro DMARK
4937						CALLMONITOR 
4937 cd 6f ee			call debug_vector  
493a				endm  
# End of macro CALLMONITOR
493a					endif 
493a			 
493a			; TODO check string type 
493a					FORTH_DSP_VALUEHL 
493a cd 05 1d			call macro_dsp_valuehl 
493d				endm 
# End of macro FORTH_DSP_VALUEHL
493d			 
493d e5					push hl      ; string length 
493e			 
493e					FORTH_DSP_POP 
493e cd bd 1d			call macro_forth_dsp_pop 
4941				endm 
# End of macro FORTH_DSP_POP
4941			 
4941					FORTH_DSP_VALUEHL 
4941 cd 05 1d			call macro_dsp_valuehl 
4944				endm 
# End of macro FORTH_DSP_VALUEHL
4944			 
4944					if DEBUG_FORTH_WORDS 
4944						DMARK "RI1" 
4944 f5				push af  
4945 3a 59 49			ld a, (.dmark)  
4948 32 62 ee			ld (debug_mark),a  
494b 3a 5a 49			ld a, (.dmark+1)  
494e 32 63 ee			ld (debug_mark+1),a  
4951 3a 5b 49			ld a, (.dmark+2)  
4954 32 64 ee			ld (debug_mark+2),a  
4957 18 03			jr .pastdmark  
4959 ..			.dmark: db "RI1"  
495c f1			.pastdmark: pop af  
495d			endm  
# End of macro DMARK
495d						CALLMONITOR 
495d cd 6f ee			call debug_vector  
4960				endm  
# End of macro CALLMONITOR
4960					endif 
4960					; from the pointer to string get to the end of string 
4960			 
4960 01 ff 00				ld bc, 255 
4963 3e 00				ld a, 0 
4965 ed b1				cpir 
4967 2b					dec hl 
4968			 
4968					;  
4968			 
4968					if DEBUG_FORTH_WORDS 
4968						DMARK "RI2" 
4968 f5				push af  
4969 3a 7d 49			ld a, (.dmark)  
496c 32 62 ee			ld (debug_mark),a  
496f 3a 7e 49			ld a, (.dmark+1)  
4972 32 63 ee			ld (debug_mark+1),a  
4975 3a 7f 49			ld a, (.dmark+2)  
4978 32 64 ee			ld (debug_mark+2),a  
497b 18 03			jr .pastdmark  
497d ..			.dmark: db "RI2"  
4980 f1			.pastdmark: pop af  
4981			endm  
# End of macro DMARK
4981						CALLMONITOR 
4981 cd 6f ee			call debug_vector  
4984				endm  
# End of macro CALLMONITOR
4984					endif 
4984			 
4984 c1					pop bc    ;  length of string to copy 
4985			 
4985 79					ld a, c 
4986 eb					ex de, hl 
4987 21 b8 e2				ld hl, scratch  
498a cd f5 0d				call addatohl 
498d			 
498d eb					ex de, hl 
498e			 
498e					if DEBUG_FORTH_WORDS 
498e						DMARK "RI3" 
498e f5				push af  
498f 3a a3 49			ld a, (.dmark)  
4992 32 62 ee			ld (debug_mark),a  
4995 3a a4 49			ld a, (.dmark+1)  
4998 32 63 ee			ld (debug_mark+1),a  
499b 3a a5 49			ld a, (.dmark+2)  
499e 32 64 ee			ld (debug_mark+2),a  
49a1 18 03			jr .pastdmark  
49a3 ..			.dmark: db "RI3"  
49a6 f1			.pastdmark: pop af  
49a7			endm  
# End of macro DMARK
49a7						CALLMONITOR 
49a7 cd 6f ee			call debug_vector  
49aa				endm  
# End of macro CALLMONITOR
49aa					endif 
49aa			 
49aa 03					inc bc 
49ab ed b8				lddr 
49ad					 
49ad 21 b8 e2				ld hl, scratch 
49b0					if DEBUG_FORTH_WORDS 
49b0						DMARK "RI4" 
49b0 f5				push af  
49b1 3a c5 49			ld a, (.dmark)  
49b4 32 62 ee			ld (debug_mark),a  
49b7 3a c6 49			ld a, (.dmark+1)  
49ba 32 63 ee			ld (debug_mark+1),a  
49bd 3a c7 49			ld a, (.dmark+2)  
49c0 32 64 ee			ld (debug_mark+2),a  
49c3 18 03			jr .pastdmark  
49c5 ..			.dmark: db "RI4"  
49c8 f1			.pastdmark: pop af  
49c9			endm  
# End of macro DMARK
49c9						CALLMONITOR 
49c9 cd 6f ee			call debug_vector  
49cc				endm  
# End of macro CALLMONITOR
49cc					endif 
49cc cd 6e 1b				call forth_push_str 
49cf			 
49cf			 
49cf					NEXTW 
49cf cd 6c ee			call parse_vector 
49d2 c3 f0 1e			jp macro_next 
49d5				endm 
# End of macro NEXTW
49d5			 
49d5			 
49d5			.STR2NUM: 
49d5				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
49d5 48				db WORD_SYS_CORE+52             
49d6 64 4a			dw .NUM2STR            
49d8 08				db 7 + 1 
49d9 .. 00			db "STR2NUM",0              
49e1				endm 
# End of macro CWHEAD
49e1			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
49e1			 
49e1			 
49e1			; TODO STR type check to do 
49e1					if DEBUG_FORTH_WORDS_KEY 
49e1						DMARK "S2N" 
49e1 f5				push af  
49e2 3a f6 49			ld a, (.dmark)  
49e5 32 62 ee			ld (debug_mark),a  
49e8 3a f7 49			ld a, (.dmark+1)  
49eb 32 63 ee			ld (debug_mark+1),a  
49ee 3a f8 49			ld a, (.dmark+2)  
49f1 32 64 ee			ld (debug_mark+2),a  
49f4 18 03			jr .pastdmark  
49f6 ..			.dmark: db "S2N"  
49f9 f1			.pastdmark: pop af  
49fa			endm  
# End of macro DMARK
49fa						CALLMONITOR 
49fa cd 6f ee			call debug_vector  
49fd				endm  
# End of macro CALLMONITOR
49fd					endif 
49fd			 
49fd					;FORTH_DSP 
49fd					FORTH_DSP_VALUE 
49fd cd ee 1c			call macro_forth_dsp_value 
4a00				endm 
# End of macro FORTH_DSP_VALUE
4a00					;inc hl 
4a00			 
4a00 eb					ex de, hl 
4a01					if DEBUG_FORTH_WORDS 
4a01						DMARK "S2a" 
4a01 f5				push af  
4a02 3a 16 4a			ld a, (.dmark)  
4a05 32 62 ee			ld (debug_mark),a  
4a08 3a 17 4a			ld a, (.dmark+1)  
4a0b 32 63 ee			ld (debug_mark+1),a  
4a0e 3a 18 4a			ld a, (.dmark+2)  
4a11 32 64 ee			ld (debug_mark+2),a  
4a14 18 03			jr .pastdmark  
4a16 ..			.dmark: db "S2a"  
4a19 f1			.pastdmark: pop af  
4a1a			endm  
# End of macro DMARK
4a1a						CALLMONITOR 
4a1a cd 6f ee			call debug_vector  
4a1d				endm  
# End of macro CALLMONITOR
4a1d					endif 
4a1d cd f2 10				call string_to_uint16 
4a20			 
4a20					if DEBUG_FORTH_WORDS 
4a20						DMARK "S2b" 
4a20 f5				push af  
4a21 3a 35 4a			ld a, (.dmark)  
4a24 32 62 ee			ld (debug_mark),a  
4a27 3a 36 4a			ld a, (.dmark+1)  
4a2a 32 63 ee			ld (debug_mark+1),a  
4a2d 3a 37 4a			ld a, (.dmark+2)  
4a30 32 64 ee			ld (debug_mark+2),a  
4a33 18 03			jr .pastdmark  
4a35 ..			.dmark: db "S2b"  
4a38 f1			.pastdmark: pop af  
4a39			endm  
# End of macro DMARK
4a39						CALLMONITOR 
4a39 cd 6f ee			call debug_vector  
4a3c				endm  
# End of macro CALLMONITOR
4a3c					endif 
4a3c			;		push hl 
4a3c					FORTH_DSP_POP 
4a3c cd bd 1d			call macro_forth_dsp_pop 
4a3f				endm 
# End of macro FORTH_DSP_POP
4a3f			;		pop hl 
4a3f					 
4a3f					if DEBUG_FORTH_WORDS 
4a3f						DMARK "S2b" 
4a3f f5				push af  
4a40 3a 54 4a			ld a, (.dmark)  
4a43 32 62 ee			ld (debug_mark),a  
4a46 3a 55 4a			ld a, (.dmark+1)  
4a49 32 63 ee			ld (debug_mark+1),a  
4a4c 3a 56 4a			ld a, (.dmark+2)  
4a4f 32 64 ee			ld (debug_mark+2),a  
4a52 18 03			jr .pastdmark  
4a54 ..			.dmark: db "S2b"  
4a57 f1			.pastdmark: pop af  
4a58			endm  
# End of macro DMARK
4a58						CALLMONITOR 
4a58 cd 6f ee			call debug_vector  
4a5b				endm  
# End of macro CALLMONITOR
4a5b					endif 
4a5b cd 00 1b				call forth_push_numhl	 
4a5e			 
4a5e				 
4a5e				       NEXTW 
4a5e cd 6c ee			call parse_vector 
4a61 c3 f0 1e			jp macro_next 
4a64				endm 
# End of macro NEXTW
4a64			.NUM2STR: 
4a64				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4a64 48				db WORD_SYS_CORE+52             
4a65 f9 4a			dw .CONCAT            
4a67 08				db 7 + 1 
4a68 .. 00			db "NUM2STR",0              
4a70				endm 
# End of macro CWHEAD
4a70			; | NUM2STR ( n -- s ) Convert a number on TOS to zero padded string | DONE 
4a70			 
4a70			;		; malloc a string to target 
4a70			;		ld hl, 10     ; TODO max string size should be fine 
4a70			;		call malloc 
4a70			;		push hl    ; save malloc location 
4a70			; 
4a70			; 
4a70			;; TODO check int type 
4a70					if DEBUG_FORTH_WORDS_KEY 
4a70						DMARK "N2S" 
4a70 f5				push af  
4a71 3a 85 4a			ld a, (.dmark)  
4a74 32 62 ee			ld (debug_mark),a  
4a77 3a 86 4a			ld a, (.dmark+1)  
4a7a 32 63 ee			ld (debug_mark+1),a  
4a7d 3a 87 4a			ld a, (.dmark+2)  
4a80 32 64 ee			ld (debug_mark+2),a  
4a83 18 03			jr .pastdmark  
4a85 ..			.dmark: db "N2S"  
4a88 f1			.pastdmark: pop af  
4a89			endm  
# End of macro DMARK
4a89						CALLMONITOR 
4a89 cd 6f ee			call debug_vector  
4a8c				endm  
# End of macro CALLMONITOR
4a8c					endif 
4a8c			 
4a8c					FORTH_DSP_VALUEHL 
4a8c cd 05 1d			call macro_dsp_valuehl 
4a8f				endm 
# End of macro FORTH_DSP_VALUEHL
4a8f			 
4a8f					if DEBUG_FORTH_WORDS 
4a8f						DMARK "NS1" 
4a8f f5				push af  
4a90 3a a4 4a			ld a, (.dmark)  
4a93 32 62 ee			ld (debug_mark),a  
4a96 3a a5 4a			ld a, (.dmark+1)  
4a99 32 63 ee			ld (debug_mark+1),a  
4a9c 3a a6 4a			ld a, (.dmark+2)  
4a9f 32 64 ee			ld (debug_mark+2),a  
4aa2 18 03			jr .pastdmark  
4aa4 ..			.dmark: db "NS1"  
4aa7 f1			.pastdmark: pop af  
4aa8			endm  
# End of macro DMARK
4aa8						CALLMONITOR 
4aa8 cd 6f ee			call debug_vector  
4aab				endm  
# End of macro CALLMONITOR
4aab					endif 
4aab					FORTH_DSP_POP 
4aab cd bd 1d			call macro_forth_dsp_pop 
4aae				endm 
# End of macro FORTH_DSP_POP
4aae			 
4aae eb					ex de, hl 
4aaf 21 b8 e2				ld hl, scratch 
4ab2					if DEBUG_FORTH_WORDS 
4ab2						DMARK "NS2" 
4ab2 f5				push af  
4ab3 3a c7 4a			ld a, (.dmark)  
4ab6 32 62 ee			ld (debug_mark),a  
4ab9 3a c8 4a			ld a, (.dmark+1)  
4abc 32 63 ee			ld (debug_mark+1),a  
4abf 3a c9 4a			ld a, (.dmark+2)  
4ac2 32 64 ee			ld (debug_mark+2),a  
4ac5 18 03			jr .pastdmark  
4ac7 ..			.dmark: db "NS2"  
4aca f1			.pastdmark: pop af  
4acb			endm  
# End of macro DMARK
4acb						CALLMONITOR 
4acb cd 6f ee			call debug_vector  
4ace				endm  
# End of macro CALLMONITOR
4ace					endif 
4ace cd 0a 11				call uitoa_16 
4ad1 21 b8 e2				ld hl, scratch 
4ad4					if DEBUG_FORTH_WORDS 
4ad4						DMARK "NS3" 
4ad4 f5				push af  
4ad5 3a e9 4a			ld a, (.dmark)  
4ad8 32 62 ee			ld (debug_mark),a  
4adb 3a ea 4a			ld a, (.dmark+1)  
4ade 32 63 ee			ld (debug_mark+1),a  
4ae1 3a eb 4a			ld a, (.dmark+2)  
4ae4 32 64 ee			ld (debug_mark+2),a  
4ae7 18 03			jr .pastdmark  
4ae9 ..			.dmark: db "NS3"  
4aec f1			.pastdmark: pop af  
4aed			endm  
# End of macro DMARK
4aed						CALLMONITOR 
4aed cd 6f ee			call debug_vector  
4af0				endm  
# End of macro CALLMONITOR
4af0					endif 
4af0 cd 6e 1b				call forth_push_str 
4af3			;		ld a, l 
4af3			;		call DispAToASCII   
4af3			;;TODO need to chage above call to dump into string 
4af3			; 
4af3			; 
4af3			 
4af3				       NEXTW 
4af3 cd 6c ee			call parse_vector 
4af6 c3 f0 1e			jp macro_next 
4af9				endm 
# End of macro NEXTW
4af9			 
4af9			.CONCAT: 
4af9				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4af9 48				db WORD_SYS_CORE+52             
4afa af 4b			dw .FIND            
4afc 07				db 6 + 1 
4afd .. 00			db "CONCAT",0              
4b04				endm 
# End of macro CWHEAD
4b04			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4b04			 
4b04			; TODO check string type 
4b04			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4b04			 
4b04					if DEBUG_FORTH_WORDS_KEY 
4b04						DMARK "CON" 
4b04 f5				push af  
4b05 3a 19 4b			ld a, (.dmark)  
4b08 32 62 ee			ld (debug_mark),a  
4b0b 3a 1a 4b			ld a, (.dmark+1)  
4b0e 32 63 ee			ld (debug_mark+1),a  
4b11 3a 1b 4b			ld a, (.dmark+2)  
4b14 32 64 ee			ld (debug_mark+2),a  
4b17 18 03			jr .pastdmark  
4b19 ..			.dmark: db "CON"  
4b1c f1			.pastdmark: pop af  
4b1d			endm  
# End of macro DMARK
4b1d						CALLMONITOR 
4b1d cd 6f ee			call debug_vector  
4b20				endm  
# End of macro CALLMONITOR
4b20					endif 
4b20			 
4b20			 
4b20					FORTH_DSP_VALUE 
4b20 cd ee 1c			call macro_forth_dsp_value 
4b23				endm 
# End of macro FORTH_DSP_VALUE
4b23 e5					push hl   ; s2 
4b24			 
4b24					FORTH_DSP_POP 
4b24 cd bd 1d			call macro_forth_dsp_pop 
4b27				endm 
# End of macro FORTH_DSP_POP
4b27			 
4b27					FORTH_DSP_VALUE 
4b27 cd ee 1c			call macro_forth_dsp_value 
4b2a				endm 
# End of macro FORTH_DSP_VALUE
4b2a			 
4b2a e5					push hl   ; s1 
4b2b			 
4b2b					FORTH_DSP_POP 
4b2b cd bd 1d			call macro_forth_dsp_pop 
4b2e				endm 
# End of macro FORTH_DSP_POP
4b2e					 
4b2e			 
4b2e					; copy s1 
4b2e			 
4b2e				 
4b2e					; save ptr 
4b2e e1					pop hl  
4b2f e5					push hl 
4b30 3e 00				ld a, 0 
4b32 cd 66 11				call strlent 
4b35					;inc hl    ; zer0 
4b35 06 00				ld b, 0 
4b37 4d					ld c, l 
4b38 e1					pop hl		 
4b39 11 b8 e2				ld de, scratch	 
4b3c					if DEBUG_FORTH_WORDS 
4b3c						DMARK "CO1" 
4b3c f5				push af  
4b3d 3a 51 4b			ld a, (.dmark)  
4b40 32 62 ee			ld (debug_mark),a  
4b43 3a 52 4b			ld a, (.dmark+1)  
4b46 32 63 ee			ld (debug_mark+1),a  
4b49 3a 53 4b			ld a, (.dmark+2)  
4b4c 32 64 ee			ld (debug_mark+2),a  
4b4f 18 03			jr .pastdmark  
4b51 ..			.dmark: db "CO1"  
4b54 f1			.pastdmark: pop af  
4b55			endm  
# End of macro DMARK
4b55						CALLMONITOR 
4b55 cd 6f ee			call debug_vector  
4b58				endm  
# End of macro CALLMONITOR
4b58					endif 
4b58 ed b0				ldir 
4b5a			 
4b5a e1					pop hl 
4b5b e5					push hl 
4b5c d5					push de 
4b5d			 
4b5d			 
4b5d 3e 00				ld a, 0 
4b5f cd 66 11				call strlent 
4b62 23					inc hl    ; zer0 
4b63 23					inc hl 
4b64 06 00				ld b, 0 
4b66 4d					ld c, l 
4b67 d1					pop de 
4b68 e1					pop hl		 
4b69					if DEBUG_FORTH_WORDS 
4b69						DMARK "CO2" 
4b69 f5				push af  
4b6a 3a 7e 4b			ld a, (.dmark)  
4b6d 32 62 ee			ld (debug_mark),a  
4b70 3a 7f 4b			ld a, (.dmark+1)  
4b73 32 63 ee			ld (debug_mark+1),a  
4b76 3a 80 4b			ld a, (.dmark+2)  
4b79 32 64 ee			ld (debug_mark+2),a  
4b7c 18 03			jr .pastdmark  
4b7e ..			.dmark: db "CO2"  
4b81 f1			.pastdmark: pop af  
4b82			endm  
# End of macro DMARK
4b82						CALLMONITOR 
4b82 cd 6f ee			call debug_vector  
4b85				endm  
# End of macro CALLMONITOR
4b85					endif 
4b85 ed b0				ldir 
4b87			 
4b87			 
4b87			 
4b87 21 b8 e2				ld hl, scratch 
4b8a					if DEBUG_FORTH_WORDS 
4b8a						DMARK "CO5" 
4b8a f5				push af  
4b8b 3a 9f 4b			ld a, (.dmark)  
4b8e 32 62 ee			ld (debug_mark),a  
4b91 3a a0 4b			ld a, (.dmark+1)  
4b94 32 63 ee			ld (debug_mark+1),a  
4b97 3a a1 4b			ld a, (.dmark+2)  
4b9a 32 64 ee			ld (debug_mark+2),a  
4b9d 18 03			jr .pastdmark  
4b9f ..			.dmark: db "CO5"  
4ba2 f1			.pastdmark: pop af  
4ba3			endm  
# End of macro DMARK
4ba3						CALLMONITOR 
4ba3 cd 6f ee			call debug_vector  
4ba6				endm  
# End of macro CALLMONITOR
4ba6					endif 
4ba6			 
4ba6 cd 6e 1b				call forth_push_str 
4ba9			 
4ba9			 
4ba9			 
4ba9			 
4ba9				       NEXTW 
4ba9 cd 6c ee			call parse_vector 
4bac c3 f0 1e			jp macro_next 
4baf				endm 
# End of macro NEXTW
4baf			 
4baf			 
4baf			.FIND: 
4baf				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4baf 4b				db WORD_SYS_CORE+55             
4bb0 70 4c			dw .LEN            
4bb2 05				db 4 + 1 
4bb3 .. 00			db "FIND",0              
4bb8				endm 
# End of macro CWHEAD
4bb8			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4bb8			 
4bb8					if DEBUG_FORTH_WORDS_KEY 
4bb8						DMARK "FND" 
4bb8 f5				push af  
4bb9 3a cd 4b			ld a, (.dmark)  
4bbc 32 62 ee			ld (debug_mark),a  
4bbf 3a ce 4b			ld a, (.dmark+1)  
4bc2 32 63 ee			ld (debug_mark+1),a  
4bc5 3a cf 4b			ld a, (.dmark+2)  
4bc8 32 64 ee			ld (debug_mark+2),a  
4bcb 18 03			jr .pastdmark  
4bcd ..			.dmark: db "FND"  
4bd0 f1			.pastdmark: pop af  
4bd1			endm  
# End of macro DMARK
4bd1						CALLMONITOR 
4bd1 cd 6f ee			call debug_vector  
4bd4				endm  
# End of macro CALLMONITOR
4bd4					endif 
4bd4			 
4bd4			; TODO check string type 
4bd4					FORTH_DSP_VALUE 
4bd4 cd ee 1c			call macro_forth_dsp_value 
4bd7				endm 
# End of macro FORTH_DSP_VALUE
4bd7			 
4bd7 e5					push hl    
4bd8 7e					ld a,(hl)    ; char to find   
4bd9			; TODO change char to substr 
4bd9			 
4bd9 f5					push af 
4bda					 
4bda			 
4bda			 
4bda					if DEBUG_FORTH_WORDS 
4bda						DMARK "FN1" 
4bda f5				push af  
4bdb 3a ef 4b			ld a, (.dmark)  
4bde 32 62 ee			ld (debug_mark),a  
4be1 3a f0 4b			ld a, (.dmark+1)  
4be4 32 63 ee			ld (debug_mark+1),a  
4be7 3a f1 4b			ld a, (.dmark+2)  
4bea 32 64 ee			ld (debug_mark+2),a  
4bed 18 03			jr .pastdmark  
4bef ..			.dmark: db "FN1"  
4bf2 f1			.pastdmark: pop af  
4bf3			endm  
# End of macro DMARK
4bf3						CALLMONITOR 
4bf3 cd 6f ee			call debug_vector  
4bf6				endm  
# End of macro CALLMONITOR
4bf6					endif 
4bf6			 
4bf6					FORTH_DSP_POP 
4bf6 cd bd 1d			call macro_forth_dsp_pop 
4bf9				endm 
# End of macro FORTH_DSP_POP
4bf9			 
4bf9					; string to search 
4bf9			 
4bf9					FORTH_DSP_VALUE 
4bf9 cd ee 1c			call macro_forth_dsp_value 
4bfc				endm 
# End of macro FORTH_DSP_VALUE
4bfc			 
4bfc d1					pop de  ; d is char to find  
4bfd			 
4bfd					if DEBUG_FORTH_WORDS 
4bfd						DMARK "FN2" 
4bfd f5				push af  
4bfe 3a 12 4c			ld a, (.dmark)  
4c01 32 62 ee			ld (debug_mark),a  
4c04 3a 13 4c			ld a, (.dmark+1)  
4c07 32 63 ee			ld (debug_mark+1),a  
4c0a 3a 14 4c			ld a, (.dmark+2)  
4c0d 32 64 ee			ld (debug_mark+2),a  
4c10 18 03			jr .pastdmark  
4c12 ..			.dmark: db "FN2"  
4c15 f1			.pastdmark: pop af  
4c16			endm  
# End of macro DMARK
4c16						CALLMONITOR 
4c16 cd 6f ee			call debug_vector  
4c19				endm  
# End of macro CALLMONITOR
4c19					endif 
4c19					 
4c19 01 00 00				ld bc, 0 
4c1c 7e			.findchar:      ld a,(hl) 
4c1d fe 00				cp 0   		 
4c1f 28 27				jr z, .finddone     
4c21 ba					cp d 
4c22 28 20				jr z, .foundchar 
4c24 03					inc bc 
4c25 23					inc hl 
4c26					if DEBUG_FORTH_WORDS 
4c26						DMARK "FN3" 
4c26 f5				push af  
4c27 3a 3b 4c			ld a, (.dmark)  
4c2a 32 62 ee			ld (debug_mark),a  
4c2d 3a 3c 4c			ld a, (.dmark+1)  
4c30 32 63 ee			ld (debug_mark+1),a  
4c33 3a 3d 4c			ld a, (.dmark+2)  
4c36 32 64 ee			ld (debug_mark+2),a  
4c39 18 03			jr .pastdmark  
4c3b ..			.dmark: db "FN3"  
4c3e f1			.pastdmark: pop af  
4c3f			endm  
# End of macro DMARK
4c3f						CALLMONITOR 
4c3f cd 6f ee			call debug_vector  
4c42				endm  
# End of macro CALLMONITOR
4c42					endif 
4c42 18 d8				jr .findchar 
4c44			 
4c44			 
4c44 c5			.foundchar:	push bc 
4c45 e1					pop hl 
4c46 18 03				jr .findexit 
4c48			 
4c48			 
4c48							 
4c48			 
4c48			.finddone:     ; got to end of string with no find 
4c48 21 00 00				ld hl, 0 
4c4b			.findexit: 
4c4b			 
4c4b					if DEBUG_FORTH_WORDS 
4c4b						DMARK "FNd" 
4c4b f5				push af  
4c4c 3a 60 4c			ld a, (.dmark)  
4c4f 32 62 ee			ld (debug_mark),a  
4c52 3a 61 4c			ld a, (.dmark+1)  
4c55 32 63 ee			ld (debug_mark+1),a  
4c58 3a 62 4c			ld a, (.dmark+2)  
4c5b 32 64 ee			ld (debug_mark+2),a  
4c5e 18 03			jr .pastdmark  
4c60 ..			.dmark: db "FNd"  
4c63 f1			.pastdmark: pop af  
4c64			endm  
# End of macro DMARK
4c64						CALLMONITOR 
4c64 cd 6f ee			call debug_vector  
4c67				endm  
# End of macro CALLMONITOR
4c67					endif 
4c67 cd 00 1b			call forth_push_numhl 
4c6a			 
4c6a				       NEXTW 
4c6a cd 6c ee			call parse_vector 
4c6d c3 f0 1e			jp macro_next 
4c70				endm 
# End of macro NEXTW
4c70			 
4c70			.LEN: 
4c70				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4c70 4c				db WORD_SYS_CORE+56             
4c71 dd 4c			dw .ASC            
4c73 06				db 5 + 1 
4c74 .. 00			db "COUNT",0              
4c7a				endm 
# End of macro CWHEAD
4c7a			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4c7a			 
4c7a					if DEBUG_FORTH_WORDS_KEY 
4c7a						DMARK "CNT" 
4c7a f5				push af  
4c7b 3a 8f 4c			ld a, (.dmark)  
4c7e 32 62 ee			ld (debug_mark),a  
4c81 3a 90 4c			ld a, (.dmark+1)  
4c84 32 63 ee			ld (debug_mark+1),a  
4c87 3a 91 4c			ld a, (.dmark+2)  
4c8a 32 64 ee			ld (debug_mark+2),a  
4c8d 18 03			jr .pastdmark  
4c8f ..			.dmark: db "CNT"  
4c92 f1			.pastdmark: pop af  
4c93			endm  
# End of macro DMARK
4c93						CALLMONITOR 
4c93 cd 6f ee			call debug_vector  
4c96				endm  
# End of macro CALLMONITOR
4c96					endif 
4c96			; TODO check string type 
4c96					FORTH_DSP_VALUE 
4c96 cd ee 1c			call macro_forth_dsp_value 
4c99				endm 
# End of macro FORTH_DSP_VALUE
4c99			 
4c99			 
4c99					if DEBUG_FORTH_WORDS 
4c99						DMARK "CN?" 
4c99 f5				push af  
4c9a 3a ae 4c			ld a, (.dmark)  
4c9d 32 62 ee			ld (debug_mark),a  
4ca0 3a af 4c			ld a, (.dmark+1)  
4ca3 32 63 ee			ld (debug_mark+1),a  
4ca6 3a b0 4c			ld a, (.dmark+2)  
4ca9 32 64 ee			ld (debug_mark+2),a  
4cac 18 03			jr .pastdmark  
4cae ..			.dmark: db "CN?"  
4cb1 f1			.pastdmark: pop af  
4cb2			endm  
# End of macro DMARK
4cb2						CALLMONITOR 
4cb2 cd 6f ee			call debug_vector  
4cb5				endm  
# End of macro CALLMONITOR
4cb5					endif 
4cb5 cd 5b 11				call strlenz 
4cb8					if DEBUG_FORTH_WORDS 
4cb8						DMARK "CNl" 
4cb8 f5				push af  
4cb9 3a cd 4c			ld a, (.dmark)  
4cbc 32 62 ee			ld (debug_mark),a  
4cbf 3a ce 4c			ld a, (.dmark+1)  
4cc2 32 63 ee			ld (debug_mark+1),a  
4cc5 3a cf 4c			ld a, (.dmark+2)  
4cc8 32 64 ee			ld (debug_mark+2),a  
4ccb 18 03			jr .pastdmark  
4ccd ..			.dmark: db "CNl"  
4cd0 f1			.pastdmark: pop af  
4cd1			endm  
# End of macro DMARK
4cd1						CALLMONITOR 
4cd1 cd 6f ee			call debug_vector  
4cd4				endm  
# End of macro CALLMONITOR
4cd4					endif 
4cd4			 
4cd4 cd 00 1b				call forth_push_numhl 
4cd7			 
4cd7			 
4cd7			 
4cd7				       NEXTW 
4cd7 cd 6c ee			call parse_vector 
4cda c3 f0 1e			jp macro_next 
4cdd				endm 
# End of macro NEXTW
4cdd			.ASC: 
4cdd				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4cdd 4d				db WORD_SYS_CORE+57             
4cde 4e 4d			dw .CHR            
4ce0 04				db 3 + 1 
4ce1 .. 00			db "ASC",0              
4ce5				endm 
# End of macro CWHEAD
4ce5			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4ce5					if DEBUG_FORTH_WORDS_KEY 
4ce5						DMARK "ASC" 
4ce5 f5				push af  
4ce6 3a fa 4c			ld a, (.dmark)  
4ce9 32 62 ee			ld (debug_mark),a  
4cec 3a fb 4c			ld a, (.dmark+1)  
4cef 32 63 ee			ld (debug_mark+1),a  
4cf2 3a fc 4c			ld a, (.dmark+2)  
4cf5 32 64 ee			ld (debug_mark+2),a  
4cf8 18 03			jr .pastdmark  
4cfa ..			.dmark: db "ASC"  
4cfd f1			.pastdmark: pop af  
4cfe			endm  
# End of macro DMARK
4cfe						CALLMONITOR 
4cfe cd 6f ee			call debug_vector  
4d01				endm  
# End of macro CALLMONITOR
4d01					endif 
4d01					FORTH_DSP_VALUE 
4d01 cd ee 1c			call macro_forth_dsp_value 
4d04				endm 
# End of macro FORTH_DSP_VALUE
4d04					;v5 FORTH_DSP_VALUE 
4d04			;		inc hl      ; now at start of numeric as string 
4d04			 
4d04 e5					push hl 
4d05			 
4d05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d05 cd bd 1d			call macro_forth_dsp_pop 
4d08				endm 
# End of macro FORTH_DSP_POP
4d08			 
4d08 e1					pop hl 
4d09			 
4d09					if DEBUG_FORTH_WORDS 
4d09						DMARK "AS1" 
4d09 f5				push af  
4d0a 3a 1e 4d			ld a, (.dmark)  
4d0d 32 62 ee			ld (debug_mark),a  
4d10 3a 1f 4d			ld a, (.dmark+1)  
4d13 32 63 ee			ld (debug_mark+1),a  
4d16 3a 20 4d			ld a, (.dmark+2)  
4d19 32 64 ee			ld (debug_mark+2),a  
4d1c 18 03			jr .pastdmark  
4d1e ..			.dmark: db "AS1"  
4d21 f1			.pastdmark: pop af  
4d22			endm  
# End of macro DMARK
4d22						CALLMONITOR 
4d22 cd 6f ee			call debug_vector  
4d25				endm  
# End of macro CALLMONITOR
4d25					endif 
4d25					; push the content of a onto the stack as a value 
4d25			 
4d25 7e					ld a,(hl)   ; get char 
4d26 26 00				ld h,0 
4d28 6f					ld l,a 
4d29					if DEBUG_FORTH_WORDS 
4d29						DMARK "AS2" 
4d29 f5				push af  
4d2a 3a 3e 4d			ld a, (.dmark)  
4d2d 32 62 ee			ld (debug_mark),a  
4d30 3a 3f 4d			ld a, (.dmark+1)  
4d33 32 63 ee			ld (debug_mark+1),a  
4d36 3a 40 4d			ld a, (.dmark+2)  
4d39 32 64 ee			ld (debug_mark+2),a  
4d3c 18 03			jr .pastdmark  
4d3e ..			.dmark: db "AS2"  
4d41 f1			.pastdmark: pop af  
4d42			endm  
# End of macro DMARK
4d42						CALLMONITOR 
4d42 cd 6f ee			call debug_vector  
4d45				endm  
# End of macro CALLMONITOR
4d45					endif 
4d45 cd 00 1b				call forth_push_numhl 
4d48			 
4d48				       NEXTW 
4d48 cd 6c ee			call parse_vector 
4d4b c3 f0 1e			jp macro_next 
4d4e				endm 
# End of macro NEXTW
4d4e			 
4d4e			.CHR: 
4d4e				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4d4e 4d				db WORD_SYS_CORE+57             
4d4f 8d 4d			dw .ENDSTR            
4d51 04				db 3 + 1 
4d52 .. 00			db "CHR",0              
4d56				endm 
# End of macro CWHEAD
4d56			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4d56					if DEBUG_FORTH_WORDS_KEY 
4d56						DMARK "CHR" 
4d56 f5				push af  
4d57 3a 6b 4d			ld a, (.dmark)  
4d5a 32 62 ee			ld (debug_mark),a  
4d5d 3a 6c 4d			ld a, (.dmark+1)  
4d60 32 63 ee			ld (debug_mark+1),a  
4d63 3a 6d 4d			ld a, (.dmark+2)  
4d66 32 64 ee			ld (debug_mark+2),a  
4d69 18 03			jr .pastdmark  
4d6b ..			.dmark: db "CHR"  
4d6e f1			.pastdmark: pop af  
4d6f			endm  
# End of macro DMARK
4d6f						CALLMONITOR 
4d6f cd 6f ee			call debug_vector  
4d72				endm  
# End of macro CALLMONITOR
4d72					endif 
4d72					FORTH_DSP_VALUEHL 
4d72 cd 05 1d			call macro_dsp_valuehl 
4d75				endm 
# End of macro FORTH_DSP_VALUEHL
4d75			 
4d75					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d75 cd bd 1d			call macro_forth_dsp_pop 
4d78				endm 
# End of macro FORTH_DSP_POP
4d78			 
4d78					; save asci byte as a zero term string and push string 
4d78			 
4d78 7d					ld a,l 
4d79 32 b8 e2				ld (scratch), a 
4d7c			 
4d7c 3e 00				ld a, 0 
4d7e 32 b9 e2				ld (scratch+1), a 
4d81			 
4d81 21 b8 e2				ld hl, scratch 
4d84 cd 6e 1b				call forth_push_str 
4d87			 
4d87			 
4d87				       NEXTW 
4d87 cd 6c ee			call parse_vector 
4d8a c3 f0 1e			jp macro_next 
4d8d				endm 
# End of macro NEXTW
4d8d			 
4d8d			 
4d8d			 
4d8d			 
4d8d			.ENDSTR: 
4d8d			; eof 
4d8d			 
# End of file forth_words_str.asm
4d8d			include "forth_words_key.asm" 
4d8d			 
4d8d			; | ## Keyboard Words 
4d8d			 
4d8d			.KEY: 
4d8d				CWHEAD .KEYDB 42 "KEY" 3 WORD_FLAG_CODE 
4d8d 3e				db WORD_SYS_CORE+42             
4d8e c0 4d			dw .KEYDB            
4d90 04				db 3 + 1 
4d91 .. 00			db "KEY",0              
4d95				endm 
# End of macro CWHEAD
4d95			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
4d95			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4d95			; | | Can use something like this to process: 
4d95			; | | > repeat active . key ?dup if emit then #1 until  
4d95			 
4d95					if DEBUG_FORTH_WORDS_KEY 
4d95						DMARK "KEY" 
4d95 f5				push af  
4d96 3a aa 4d			ld a, (.dmark)  
4d99 32 62 ee			ld (debug_mark),a  
4d9c 3a ab 4d			ld a, (.dmark+1)  
4d9f 32 63 ee			ld (debug_mark+1),a  
4da2 3a ac 4d			ld a, (.dmark+2)  
4da5 32 64 ee			ld (debug_mark+2),a  
4da8 18 03			jr .pastdmark  
4daa ..			.dmark: db "KEY"  
4dad f1			.pastdmark: pop af  
4dae			endm  
# End of macro DMARK
4dae						CALLMONITOR 
4dae cd 6f ee			call debug_vector  
4db1				endm  
# End of macro CALLMONITOR
4db1					endif 
4db1			; TODO currently waits 
4db1 cd 3a 65				call cinndb 
4db4					;call cin_wait 
4db4 6f					ld l, a 
4db5 26 00				ld h, 0 
4db7 cd 00 1b				call forth_push_numhl 
4dba					NEXTW 
4dba cd 6c ee			call parse_vector 
4dbd c3 f0 1e			jp macro_next 
4dc0				endm 
# End of macro NEXTW
4dc0			.KEYDB: 
4dc0				CWHEAD .WAITK 42 "KEYDB" 5 WORD_FLAG_CODE 
4dc0 3e				db WORD_SYS_CORE+42             
4dc1 f5 4d			dw .WAITK            
4dc3 06				db 5 + 1 
4dc4 .. 00			db "KEYDB",0              
4dca				endm 
# End of macro CWHEAD
4dca			; | KEYDB ( -- u ) A non-blocking read of keypress with key release debounce | DONE 
4dca			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4dca			; | | Can use something like this to process: 
4dca			; | | > repeat active . key ?dup if emit then #1 until  
4dca			 
4dca					if DEBUG_FORTH_WORDS_KEY 
4dca						DMARK "KEB" 
4dca f5				push af  
4dcb 3a df 4d			ld a, (.dmark)  
4dce 32 62 ee			ld (debug_mark),a  
4dd1 3a e0 4d			ld a, (.dmark+1)  
4dd4 32 63 ee			ld (debug_mark+1),a  
4dd7 3a e1 4d			ld a, (.dmark+2)  
4dda 32 64 ee			ld (debug_mark+2),a  
4ddd 18 03			jr .pastdmark  
4ddf ..			.dmark: db "KEB"  
4de2 f1			.pastdmark: pop af  
4de3			endm  
# End of macro DMARK
4de3						CALLMONITOR 
4de3 cd 6f ee			call debug_vector  
4de6				endm  
# End of macro CALLMONITOR
4de6					endif 
4de6			; TODO currently waits 
4de6 cd 3a 65				call cin 
4de9					;call cin_wait 
4de9 6f					ld l, a 
4dea 26 00				ld h, 0 
4dec cd 00 1b				call forth_push_numhl 
4def					NEXTW 
4def cd 6c ee			call parse_vector 
4df2 c3 f0 1e			jp macro_next 
4df5				endm 
# End of macro NEXTW
4df5			.WAITK: 
4df5				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4df5 3f				db WORD_SYS_CORE+43             
4df6 2a 4e			dw .ACCEPT            
4df8 06				db 5 + 1 
4df9 .. 00			db "WAITK",0              
4dff				endm 
# End of macro CWHEAD
4dff			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4dff					if DEBUG_FORTH_WORDS_KEY 
4dff						DMARK "WAI" 
4dff f5				push af  
4e00 3a 14 4e			ld a, (.dmark)  
4e03 32 62 ee			ld (debug_mark),a  
4e06 3a 15 4e			ld a, (.dmark+1)  
4e09 32 63 ee			ld (debug_mark+1),a  
4e0c 3a 16 4e			ld a, (.dmark+2)  
4e0f 32 64 ee			ld (debug_mark+2),a  
4e12 18 03			jr .pastdmark  
4e14 ..			.dmark: db "WAI"  
4e17 f1			.pastdmark: pop af  
4e18			endm  
# End of macro DMARK
4e18						CALLMONITOR 
4e18 cd 6f ee			call debug_vector  
4e1b				endm  
# End of macro CALLMONITOR
4e1b					endif 
4e1b cd 32 65				call cin_wait 
4e1e 6f					ld l, a 
4e1f 26 00				ld h, 0 
4e21 cd 00 1b				call forth_push_numhl 
4e24					NEXTW 
4e24 cd 6c ee			call parse_vector 
4e27 c3 f0 1e			jp macro_next 
4e2a				endm 
# End of macro NEXTW
4e2a			.ACCEPT: 
4e2a				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4e2a 40				db WORD_SYS_CORE+44             
4e2b 8b 4e			dw .EDIT            
4e2d 07				db 6 + 1 
4e2e .. 00			db "ACCEPT",0              
4e35				endm 
# End of macro CWHEAD
4e35			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4e35					; TODO crashes on push 
4e35					if DEBUG_FORTH_WORDS_KEY 
4e35						DMARK "ACC" 
4e35 f5				push af  
4e36 3a 4a 4e			ld a, (.dmark)  
4e39 32 62 ee			ld (debug_mark),a  
4e3c 3a 4b 4e			ld a, (.dmark+1)  
4e3f 32 63 ee			ld (debug_mark+1),a  
4e42 3a 4c 4e			ld a, (.dmark+2)  
4e45 32 64 ee			ld (debug_mark+2),a  
4e48 18 03			jr .pastdmark  
4e4a ..			.dmark: db "ACC"  
4e4d f1			.pastdmark: pop af  
4e4e			endm  
# End of macro DMARK
4e4e						CALLMONITOR 
4e4e cd 6f ee			call debug_vector  
4e51				endm  
# End of macro CALLMONITOR
4e51					endif 
4e51 21 b6 e4				ld hl, os_input 
4e54 3e 00				ld a, 0 
4e56 77					ld (hl),a 
4e57 3a 55 ea				ld a,(f_cursor_ptr) 
4e5a 16 64				ld d, 100 
4e5c 0e 00				ld c, 0 
4e5e 1e 28				ld e, 40 
4e60 cd 22 0e				call input_str 
4e63					; TODO perhaps do a type check and wrap in quotes if not a number 
4e63 21 b6 e4				ld hl, os_input 
4e66					if DEBUG_FORTH_WORDS 
4e66						DMARK "AC1" 
4e66 f5				push af  
4e67 3a 7b 4e			ld a, (.dmark)  
4e6a 32 62 ee			ld (debug_mark),a  
4e6d 3a 7c 4e			ld a, (.dmark+1)  
4e70 32 63 ee			ld (debug_mark+1),a  
4e73 3a 7d 4e			ld a, (.dmark+2)  
4e76 32 64 ee			ld (debug_mark+2),a  
4e79 18 03			jr .pastdmark  
4e7b ..			.dmark: db "AC1"  
4e7e f1			.pastdmark: pop af  
4e7f			endm  
# End of macro DMARK
4e7f						CALLMONITOR 
4e7f cd 6f ee			call debug_vector  
4e82				endm  
# End of macro CALLMONITOR
4e82					endif 
4e82 cd 6e 1b				call forth_push_str 
4e85					NEXTW 
4e85 cd 6c ee			call parse_vector 
4e88 c3 f0 1e			jp macro_next 
4e8b				endm 
# End of macro NEXTW
4e8b			 
4e8b			.EDIT: 
4e8b				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4e8b 40				db WORD_SYS_CORE+44             
4e8c 30 4f			dw .DEDIT            
4e8e 05				db 4 + 1 
4e8f .. 00			db "EDIT",0              
4e94				endm 
# End of macro CWHEAD
4e94			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4e94			 
4e94					; TODO does not copy from stack 
4e94					if DEBUG_FORTH_WORDS_KEY 
4e94						DMARK "EDT" 
4e94 f5				push af  
4e95 3a a9 4e			ld a, (.dmark)  
4e98 32 62 ee			ld (debug_mark),a  
4e9b 3a aa 4e			ld a, (.dmark+1)  
4e9e 32 63 ee			ld (debug_mark+1),a  
4ea1 3a ab 4e			ld a, (.dmark+2)  
4ea4 32 64 ee			ld (debug_mark+2),a  
4ea7 18 03			jr .pastdmark  
4ea9 ..			.dmark: db "EDT"  
4eac f1			.pastdmark: pop af  
4ead			endm  
# End of macro DMARK
4ead						CALLMONITOR 
4ead cd 6f ee			call debug_vector  
4eb0				endm  
# End of macro CALLMONITOR
4eb0					endif 
4eb0			 
4eb0					;FORTH_DSP 
4eb0					FORTH_DSP_VALUEHL 
4eb0 cd 05 1d			call macro_dsp_valuehl 
4eb3				endm 
# End of macro FORTH_DSP_VALUEHL
4eb3			;		inc hl    ; TODO do type check 
4eb3			 
4eb3			;		call get_word_hl 
4eb3 e5					push hl 
4eb4					if DEBUG_FORTH_WORDS 
4eb4						DMARK "EDp" 
4eb4 f5				push af  
4eb5 3a c9 4e			ld a, (.dmark)  
4eb8 32 62 ee			ld (debug_mark),a  
4ebb 3a ca 4e			ld a, (.dmark+1)  
4ebe 32 63 ee			ld (debug_mark+1),a  
4ec1 3a cb 4e			ld a, (.dmark+2)  
4ec4 32 64 ee			ld (debug_mark+2),a  
4ec7 18 03			jr .pastdmark  
4ec9 ..			.dmark: db "EDp"  
4ecc f1			.pastdmark: pop af  
4ecd			endm  
# End of macro DMARK
4ecd						CALLMONITOR 
4ecd cd 6f ee			call debug_vector  
4ed0				endm  
# End of macro CALLMONITOR
4ed0					endif 
4ed0				;	ld a, 0 
4ed0 cd 5b 11				call strlenz 
4ed3 23					inc hl 
4ed4			 
4ed4 06 00				ld b, 0 
4ed6 4d					ld c, l 
4ed7			 
4ed7 e1					pop hl 
4ed8 11 b6 e4				ld de, os_input 
4edb					if DEBUG_FORTH_WORDS_KEY 
4edb						DMARK "EDc" 
4edb f5				push af  
4edc 3a f0 4e			ld a, (.dmark)  
4edf 32 62 ee			ld (debug_mark),a  
4ee2 3a f1 4e			ld a, (.dmark+1)  
4ee5 32 63 ee			ld (debug_mark+1),a  
4ee8 3a f2 4e			ld a, (.dmark+2)  
4eeb 32 64 ee			ld (debug_mark+2),a  
4eee 18 03			jr .pastdmark  
4ef0 ..			.dmark: db "EDc"  
4ef3 f1			.pastdmark: pop af  
4ef4			endm  
# End of macro DMARK
4ef4						CALLMONITOR 
4ef4 cd 6f ee			call debug_vector  
4ef7				endm  
# End of macro CALLMONITOR
4ef7					endif 
4ef7 ed b0				ldir 
4ef9			 
4ef9			 
4ef9 21 b6 e4				ld hl, os_input 
4efc					;ld a, 0 
4efc					;ld (hl),a 
4efc 3a 55 ea				ld a,(f_cursor_ptr) 
4eff 16 64				ld d, 100 
4f01 0e 00				ld c, 0 
4f03 1e 28				ld e, 40 
4f05 cd 22 0e				call input_str 
4f08					; TODO perhaps do a type check and wrap in quotes if not a number 
4f08 21 b6 e4				ld hl, os_input 
4f0b					if DEBUG_FORTH_WORDS 
4f0b						DMARK "ED1" 
4f0b f5				push af  
4f0c 3a 20 4f			ld a, (.dmark)  
4f0f 32 62 ee			ld (debug_mark),a  
4f12 3a 21 4f			ld a, (.dmark+1)  
4f15 32 63 ee			ld (debug_mark+1),a  
4f18 3a 22 4f			ld a, (.dmark+2)  
4f1b 32 64 ee			ld (debug_mark+2),a  
4f1e 18 03			jr .pastdmark  
4f20 ..			.dmark: db "ED1"  
4f23 f1			.pastdmark: pop af  
4f24			endm  
# End of macro DMARK
4f24						CALLMONITOR 
4f24 cd 6f ee			call debug_vector  
4f27				endm  
# End of macro CALLMONITOR
4f27					endif 
4f27 cd 6e 1b				call forth_push_str 
4f2a					NEXTW 
4f2a cd 6c ee			call parse_vector 
4f2d c3 f0 1e			jp macro_next 
4f30				endm 
# End of macro NEXTW
4f30			 
4f30			.DEDIT: 
4f30				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4f30 40				db WORD_SYS_CORE+44             
4f31 95 4f			dw .ENDKEY            
4f33 06				db 5 + 1 
4f34 .. 00			db "DEDIT",0              
4f3a				endm 
# End of macro CWHEAD
4f3a			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
4f3a			 
4f3a					; TODO does not copy from stack 
4f3a					if DEBUG_FORTH_WORDS_KEY 
4f3a						DMARK "DED" 
4f3a f5				push af  
4f3b 3a 4f 4f			ld a, (.dmark)  
4f3e 32 62 ee			ld (debug_mark),a  
4f41 3a 50 4f			ld a, (.dmark+1)  
4f44 32 63 ee			ld (debug_mark+1),a  
4f47 3a 51 4f			ld a, (.dmark+2)  
4f4a 32 64 ee			ld (debug_mark+2),a  
4f4d 18 03			jr .pastdmark  
4f4f ..			.dmark: db "DED"  
4f52 f1			.pastdmark: pop af  
4f53			endm  
# End of macro DMARK
4f53						CALLMONITOR 
4f53 cd 6f ee			call debug_vector  
4f56				endm  
# End of macro CALLMONITOR
4f56					endif 
4f56			 
4f56					;FORTH_DSP 
4f56					FORTH_DSP_VALUEHL 
4f56 cd 05 1d			call macro_dsp_valuehl 
4f59				endm 
# End of macro FORTH_DSP_VALUEHL
4f59			;		inc hl    ; TODO do type check 
4f59			 
4f59			;		call get_word_hl 
4f59 e5					push hl 
4f5a e5					push hl 
4f5b					FORTH_DSP_POP 
4f5b cd bd 1d			call macro_forth_dsp_pop 
4f5e				endm 
# End of macro FORTH_DSP_POP
4f5e e1					pop hl 
4f5f					if DEBUG_FORTH_WORDS 
4f5f						DMARK "EDp" 
4f5f f5				push af  
4f60 3a 74 4f			ld a, (.dmark)  
4f63 32 62 ee			ld (debug_mark),a  
4f66 3a 75 4f			ld a, (.dmark+1)  
4f69 32 63 ee			ld (debug_mark+1),a  
4f6c 3a 76 4f			ld a, (.dmark+2)  
4f6f 32 64 ee			ld (debug_mark+2),a  
4f72 18 03			jr .pastdmark  
4f74 ..			.dmark: db "EDp"  
4f77 f1			.pastdmark: pop af  
4f78			endm  
# End of macro DMARK
4f78						CALLMONITOR 
4f78 cd 6f ee			call debug_vector  
4f7b				endm  
# End of macro CALLMONITOR
4f7b					endif 
4f7b				;	ld a, 0 
4f7b cd 5b 11				call strlenz 
4f7e 23					inc hl 
4f7f			 
4f7f 06 00				ld b, 0 
4f81 4d					ld c, l 
4f82			 
4f82 e1					pop hl 
4f83			 
4f83					;ld a, 0 
4f83					;ld (hl),a 
4f83 3a 55 ea				ld a,(f_cursor_ptr) 
4f86 16 64				ld d, 100 
4f88 0e 00				ld c, 0 
4f8a 1e 28				ld e, 40 
4f8c cd 22 0e				call input_str 
4f8f					; TODO perhaps do a type check and wrap in quotes if not a number 
4f8f					NEXTW 
4f8f cd 6c ee			call parse_vector 
4f92 c3 f0 1e			jp macro_next 
4f95				endm 
# End of macro NEXTW
4f95			 
4f95			 
4f95			.ENDKEY: 
4f95			; eof 
4f95			 
# End of file forth_words_key.asm
4f95			include "forth_words_const.asm" 
4f95			 
4f95			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4f95			 
4f95			 
4f95			.SPITIME: 
4f95				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4f95 77				db WORD_SYS_CORE+99             
4f96 ad 4f			dw .VA            
4f98 08				db 7 + 1 
4f99 .. 00			db "SPITIME",0              
4fa1				endm 
# End of macro CWHEAD
4fa1			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
4fa1			; 
4fa1			; | | If using BANK devices then leave as is. 
4fa1			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
4fa1			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
4fa1			 
4fa1 21 5b ea				ld hl, spi_clktime  
4fa4 cd 00 1b				call forth_push_numhl 
4fa7			 
4fa7					NEXTW 
4fa7 cd 6c ee			call parse_vector 
4faa c3 f0 1e			jp macro_next 
4fad				endm 
# End of macro NEXTW
4fad			 
4fad			 
4fad			.VA: 
4fad				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4fad 77				db WORD_SYS_CORE+99             
4fae c0 4f			dw .SYMBOL            
4fb0 03				db 2 + 1 
4fb1 .. 00			db "VA",0              
4fb4				endm 
# End of macro CWHEAD
4fb4			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
4fb4 21 1f ea				ld hl, cli_var_array 
4fb7 cd 00 1b				call forth_push_numhl 
4fba			 
4fba					NEXTW 
4fba cd 6c ee			call parse_vector 
4fbd c3 f0 1e			jp macro_next 
4fc0				endm 
# End of macro NEXTW
4fc0			 
4fc0			.SYMBOL: 
4fc0				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4fc0 77				db WORD_SYS_CORE+99             
4fc1 cf 50			dw .ENDCONST            
4fc3 07				db 6 + 1 
4fc4 .. 00			db "SYMBOL",0              
4fcb				endm 
# End of macro CWHEAD
4fcb			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4fcb			; | 
4fcb			; | | The value is the number reference and the final address is pushed to stack 
4fcb			 
4fcb			; | | ``` 
4fcb			; | | dw sym_table 
4fcb			; | | dw nmi_vector 
4fcb			; | | dw cli_autodisplay 
4fcb			; | | dw cli_data_sp 
4fcb			; | | dw cli_data_stack 
4fcb			; | | dw cli_loop_sp 
4fcb			; | | dw cli_loop_stack 
4fcb			; | | dw cli_var_array 
4fcb			; | | dw cursor_col 
4fcb			; | | dw cursor_ptr 
4fcb			; | | ; 10 
4fcb			; | | dw cursor_row 
4fcb			; | | dw debug_mark 
4fcb			; | | dw display_fb0 
4fcb			; | | dw display_fb1 
4fcb			; | | dw display_fb2 
4fcb			; | | dw display_fb3 
4fcb			; | | dw display_fb_active 
4fcb			; | | dw execscratch 
4fcb			; | | dw f_cursor_ptr 
4fcb			; | | dw hardware_word 
4fcb			; | | ;20 
4fcb			; | | dw input_at_cursor 
4fcb			; | | dw input_at_pos 
4fcb			; | | dw input_cur_flash 
4fcb			; | | dw input_cur_onoff 
4fcb			; | | dw input_cursor 
4fcb			; | | dw input_display_size 
4fcb			; | | dw input_len 
4fcb			; | | dw input_ptr 
4fcb			; | | dw input_size 
4fcb			; | | dw input_start 
4fcb			; | | ; 30 
4fcb			; | | dw input_str 
4fcb			; | | dw input_under_cursor 
4fcb			; | | dw os_cli_cmd 
4fcb			; | | dw os_cur_ptr 
4fcb			; | | dw os_current_i 
4fcb			; | | dw os_input 
4fcb			; | | dw os_last_cmd 
4fcb			; | | dw os_last_new_uword 
4fcb			; | | dw debug_vector 
4fcb			; | | dw os_view_hl 
4fcb			; | | ;40 
4fcb			; | | dw os_word_scratch 
4fcb			; | | dw portbctl 
4fcb			; | | dw portbdata 
4fcb			; | | dw spi_cartdev 
4fcb			; | | dw spi_cartdev2 
4fcb			; | | dw spi_clktime 
4fcb			; | | dw spi_device 
4fcb			; | | dw spi_device_id 
4fcb			; | | dw spi_portbyte 
4fcb			; | | dw stackstore 
4fcb			; | | ; 50 
4fcb			; | | if STORAGE_SE 
4fcb			; | | dw storage_actl 
4fcb			; | | dw storage_adata 
4fcb			; | | else 
4fcb			; | | dw 0 
4fcb			; | | dw 0 
4fcb			; | | endif 
4fcb			; | | dw storage_append 
4fcb			; | | if STORAGE_SE 
4fcb			; | | dw storage_bctl 
4fcb			; | | else 
4fcb			; | | dw 0 
4fcb			; | | endif 
4fcb			; | | dw store_bank_active 
4fcb			; | | dw store_filecache 
4fcb			; | | dw store_longread 
4fcb			; | | dw store_openaddr 
4fcb			; | | dw store_openext 
4fcb			; | | dw store_openmaxext 
4fcb			; | | ; 60 
4fcb			; | | dw store_page 
4fcb			; | | dw store_readbuf 
4fcb			; | | dw store_readcont 
4fcb			; | | dw store_readptr 
4fcb			; | | dw store_tmpext 
4fcb			; | | dw store_tmpid 
4fcb			; | | dw store_tmppageid 
4fcb			; | | dw malloc 
4fcb			; | | dw free 
4fcb			; | | dw cin 
4fcb			; | | ; 70 
4fcb			; | | dw cin_wait 
4fcb			; | | dw forth_push_numhl 
4fcb			; | | dw forth_push_str 
4fcb			; | | dw parse_vector 
4fcb			; | | ``` 
4fcb			 
4fcb					if DEBUG_FORTH_WORDS_KEY 
4fcb						DMARK "SYM" 
4fcb f5				push af  
4fcc 3a e0 4f			ld a, (.dmark)  
4fcf 32 62 ee			ld (debug_mark),a  
4fd2 3a e1 4f			ld a, (.dmark+1)  
4fd5 32 63 ee			ld (debug_mark+1),a  
4fd8 3a e2 4f			ld a, (.dmark+2)  
4fdb 32 64 ee			ld (debug_mark+2),a  
4fde 18 03			jr .pastdmark  
4fe0 ..			.dmark: db "SYM"  
4fe3 f1			.pastdmark: pop af  
4fe4			endm  
# End of macro DMARK
4fe4						CALLMONITOR 
4fe4 cd 6f ee			call debug_vector  
4fe7				endm  
# End of macro CALLMONITOR
4fe7					endif 
4fe7			 
4fe7					FORTH_DSP_VALUEHL 
4fe7 cd 05 1d			call macro_dsp_valuehl 
4fea				endm 
# End of macro FORTH_DSP_VALUEHL
4fea			 
4fea 7d					ld a, l     
4feb			 
4feb			 
4feb					if DEBUG_FORTH_WORDS 
4feb						DMARK "SY1" 
4feb f5				push af  
4fec 3a 00 50			ld a, (.dmark)  
4fef 32 62 ee			ld (debug_mark),a  
4ff2 3a 01 50			ld a, (.dmark+1)  
4ff5 32 63 ee			ld (debug_mark+1),a  
4ff8 3a 02 50			ld a, (.dmark+2)  
4ffb 32 64 ee			ld (debug_mark+2),a  
4ffe 18 03			jr .pastdmark  
5000 ..			.dmark: db "SY1"  
5003 f1			.pastdmark: pop af  
5004			endm  
# End of macro DMARK
5004						CALLMONITOR 
5004 cd 6f ee			call debug_vector  
5007				endm  
# End of macro CALLMONITOR
5007					endif 
5007					 
5007 f5					push af	 
5008					FORTH_DSP_POP 
5008 cd bd 1d			call macro_forth_dsp_pop 
500b				endm 
# End of macro FORTH_DSP_POP
500b f1					pop af 
500c			 
500c cb 27				sla a  
500e				 
500e					 
500e					if DEBUG_FORTH_WORDS 
500e						DMARK "SY" 
500e f5				push af  
500f 3a 23 50			ld a, (.dmark)  
5012 32 62 ee			ld (debug_mark),a  
5015 3a 24 50			ld a, (.dmark+1)  
5018 32 63 ee			ld (debug_mark+1),a  
501b 3a 25 50			ld a, (.dmark+2)  
501e 32 64 ee			ld (debug_mark+2),a  
5021 18 02			jr .pastdmark  
5023 ..			.dmark: db "SY"  
5025 f1			.pastdmark: pop af  
5026			endm  
# End of macro DMARK
5026						CALLMONITOR 
5026 cd 6f ee			call debug_vector  
5029				endm  
# End of macro CALLMONITOR
5029					endif 
5029			 
5029 21 3b 50				ld hl, sym_table 
502c cd f5 0d				call addatohl 
502f cd 72 1e				call loadwordinhl 
5032 cd 00 1b				call forth_push_numhl 
5035			 
5035			 
5035				       NEXTW 
5035 cd 6c ee			call parse_vector 
5038 c3 f0 1e			jp macro_next 
503b				endm 
# End of macro NEXTW
503b			 
503b			sym_table: 
503b			 
503b			; 0 
503b 3b 50		dw sym_table 
503d 72 ee		dw nmi_vector 
503f 33 ea		dw cli_autodisplay 
5041 e5 e9		dw cli_data_sp 
5043 1f e8		dw cli_data_stack 
5045 e7 e9		dw cli_loop_sp 
5047 21 e9		dw cli_loop_stack 
5049 1f ea		dw cli_var_array 
504b bc eb		dw cursor_col 
504d ba eb		dw cursor_ptr 
504f			; 10 
504f bb eb		dw cursor_row 
5051 62 ee		dw debug_mark 
5053 a8 ed		dw display_fb0 
5055 07 ed		dw display_fb1 
5057 c5 eb		dw display_fb2 
5059 66 ec		dw display_fb3 
505b c3 eb		dw display_fb_active 
505d b7 e3		dw execscratch 
505f 55 ea		dw f_cursor_ptr 
5061 75 ee		dw hardware_word 
5063			;20 
5063 59 ee		dw input_at_cursor 
5065 5b ee		dw input_at_pos 
5067 57 ee		dw input_cur_flash 
5069 56 ee		dw input_cur_onoff 
506b 4c ee		dw input_cursor 
506d 5c ee		dw input_display_size 
506f 51 ee		dw input_len 
5071 60 ee		dw input_ptr 
5073 5d ee		dw input_size 
5075 5e ee		dw input_start 
5077			; 30 
5077 22 0e		dw input_str 
5079 5a ee		dw input_under_cursor 
507b df e5		dw os_cli_cmd 
507d db e5		dw os_cur_ptr 
507f dd e5		dw os_current_i 
5081 b6 e4		dw os_input 
5083 de e6		dw os_last_cmd 
5085 b5 e5		dw os_last_new_uword 
5087 6f ee		dw debug_vector 
5089 9a e2		dw os_view_hl 
508b			;40 
508b bd e5		dw os_word_scratch 
508d c3 00		dw portbctl 
508f c1 00		dw portbdata 
5091 5a ea		dw spi_cartdev 
5093 59 ea		dw spi_cartdev2 
5095 5b ea		dw spi_clktime 
5097 57 ea		dw spi_device 
5099 56 ea		dw spi_device_id 
509b 58 ea		dw spi_portbyte 
509d 9e eb		dw stackstore 
509f			; 50 
509f			if STORAGE_SE 
509f			dw storage_actl 
509f			dw storage_adata 
509f			else 
509f 00 00		dw 0 
50a1 00 00		dw 0 
50a3			endif 
50a3 77 09		dw storage_append 
50a5			if STORAGE_SE 
50a5			dw storage_bctl 
50a5			else 
50a5 00 00		dw 0 
50a7			endif 
50a7 8a eb		dw store_bank_active 
50a9 5e ea		dw store_filecache 
50ab 6c ea		dw store_longread 
50ad 62 ea		dw store_openaddr 
50af 61 ea		dw store_openext 
50b1 60 ea		dw store_openmaxext 
50b3			; 60 
50b3 71 ea		dw store_page 
50b5 6d ea		dw store_readbuf 
50b7 64 ea		dw store_readcont 
50b9 6f ea		dw store_readptr 
50bb 64 ea		dw store_tmpext 
50bd 65 ea		dw store_tmpid 
50bf 5c ea		dw store_tmppageid 
50c1 d0 11		dw malloc 
50c3 9a 12		dw free 
50c5 3a 65		dw cin 
50c7			; 70 
50c7 32 65		dw cin_wait 
50c9 00 1b		dw forth_push_numhl 
50cb 6e 1b		dw forth_push_str 
50cd 6c ee		dw parse_vector 
50cf			 
50cf			.ENDCONST: 
50cf			 
50cf			; eof 
50cf			 
50cf			 
# End of file forth_words_const.asm
50cf			 
50cf			if STORAGE_SE 
50cf			   	include "forth_words_storage.asm" 
50cf			endif 
50cf				include "forth_words_device.asm" 
50cf			; Device related words 
50cf			 
50cf			; | ## Device Words 
50cf			 
50cf			;if SOUND_ENABLE 
50cf			;.NOTE: 
50cf			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
50cf			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
50cf			;		if DEBUG_FORTH_WORDS_KEY 
50cf			;			DMARK "NTE" 
50cf			;			CALLMONITOR 
50cf			;		endif 
50cf			; 
50cf			;	 
50cf			; 
50cf			;		NEXTW 
50cf			;.AFTERSOUND: 
50cf			;endif 
50cf			 
50cf			 
50cf			USE_GPIO: equ 0 
50cf			 
50cf			if USE_GPIO 
50cf			.GP1: 
50cf				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
50cf			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
50cf					NEXTW 
50cf			.GP2: 
50cf				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
50cf			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
50cf			 
50cf					NEXTW 
50cf			 
50cf			.GP3: 
50cf				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
50cf			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
50cf			 
50cf					NEXTW 
50cf			 
50cf			.GP4: 
50cf				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
50cf			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
50cf			 
50cf					NEXTW 
50cf			.SIN: 
50cf			 
50cf			 
50cf			endif 
50cf			 
50cf			 
50cf				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
50cf 33				db WORD_SYS_CORE+31             
50d0 07 51			dw .SOUT            
50d2 03				db 2 + 1 
50d3 .. 00			db "IN",0              
50d6				endm 
# End of macro CWHEAD
50d6			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
50d6					if DEBUG_FORTH_WORDS_KEY 
50d6						DMARK "IN." 
50d6 f5				push af  
50d7 3a eb 50			ld a, (.dmark)  
50da 32 62 ee			ld (debug_mark),a  
50dd 3a ec 50			ld a, (.dmark+1)  
50e0 32 63 ee			ld (debug_mark+1),a  
50e3 3a ed 50			ld a, (.dmark+2)  
50e6 32 64 ee			ld (debug_mark+2),a  
50e9 18 03			jr .pastdmark  
50eb ..			.dmark: db "IN."  
50ee f1			.pastdmark: pop af  
50ef			endm  
# End of macro DMARK
50ef						CALLMONITOR 
50ef cd 6f ee			call debug_vector  
50f2				endm  
# End of macro CALLMONITOR
50f2					endif 
50f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50f2 cd 05 1d			call macro_dsp_valuehl 
50f5				endm 
# End of macro FORTH_DSP_VALUEHL
50f5			 
50f5 e5					push hl 
50f6			 
50f6					; destroy value TOS 
50f6			 
50f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50f6 cd bd 1d			call macro_forth_dsp_pop 
50f9				endm 
# End of macro FORTH_DSP_POP
50f9			 
50f9					; one value on hl get other one back 
50f9			 
50f9 c1					pop bc 
50fa			 
50fa					; do the sub 
50fa			;		ex de, hl 
50fa			 
50fa ed 68				in l,(c) 
50fc			 
50fc					; save it 
50fc			 
50fc 26 00				ld h,0 
50fe			 
50fe					; TODO push value back onto stack for another op etc 
50fe			 
50fe cd 00 1b				call forth_push_numhl 
5101					NEXTW 
5101 cd 6c ee			call parse_vector 
5104 c3 f0 1e			jp macro_next 
5107				endm 
# End of macro NEXTW
5107			.SOUT: 
5107				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5107 34				db WORD_SYS_CORE+32             
5108 5d 51			dw .SPIO            
510a 04				db 3 + 1 
510b .. 00			db "OUT",0              
510f				endm 
# End of macro CWHEAD
510f			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
510f					if DEBUG_FORTH_WORDS_KEY 
510f						DMARK "OUT" 
510f f5				push af  
5110 3a 24 51			ld a, (.dmark)  
5113 32 62 ee			ld (debug_mark),a  
5116 3a 25 51			ld a, (.dmark+1)  
5119 32 63 ee			ld (debug_mark+1),a  
511c 3a 26 51			ld a, (.dmark+2)  
511f 32 64 ee			ld (debug_mark+2),a  
5122 18 03			jr .pastdmark  
5124 ..			.dmark: db "OUT"  
5127 f1			.pastdmark: pop af  
5128			endm  
# End of macro DMARK
5128						CALLMONITOR 
5128 cd 6f ee			call debug_vector  
512b				endm  
# End of macro CALLMONITOR
512b					endif 
512b			 
512b					; get port 
512b			 
512b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
512b cd 05 1d			call macro_dsp_valuehl 
512e				endm 
# End of macro FORTH_DSP_VALUEHL
512e			 
512e e5					push hl 
512f			 
512f					; destroy value TOS 
512f			 
512f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
512f cd bd 1d			call macro_forth_dsp_pop 
5132				endm 
# End of macro FORTH_DSP_POP
5132			 
5132					; get byte to send 
5132			 
5132					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5132 cd 05 1d			call macro_dsp_valuehl 
5135				endm 
# End of macro FORTH_DSP_VALUEHL
5135			 
5135			;		push hl 
5135			 
5135					; destroy value TOS 
5135			 
5135					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5135 cd bd 1d			call macro_forth_dsp_pop 
5138				endm 
# End of macro FORTH_DSP_POP
5138			 
5138					; one value on hl get other one back 
5138			 
5138			;		pop hl 
5138			 
5138 c1					pop bc 
5139			 
5139					if DEBUG_FORTH_WORDS 
5139						DMARK "OUT" 
5139 f5				push af  
513a 3a 4e 51			ld a, (.dmark)  
513d 32 62 ee			ld (debug_mark),a  
5140 3a 4f 51			ld a, (.dmark+1)  
5143 32 63 ee			ld (debug_mark+1),a  
5146 3a 50 51			ld a, (.dmark+2)  
5149 32 64 ee			ld (debug_mark+2),a  
514c 18 03			jr .pastdmark  
514e ..			.dmark: db "OUT"  
5151 f1			.pastdmark: pop af  
5152			endm  
# End of macro DMARK
5152						CALLMONITOR 
5152 cd 6f ee			call debug_vector  
5155				endm  
# End of macro CALLMONITOR
5155					endif 
5155			 
5155 ed 69				out (c), l 
5157			 
5157					NEXTW 
5157 cd 6c ee			call parse_vector 
515a c3 f0 1e			jp macro_next 
515d				endm 
# End of macro NEXTW
515d			 
515d			 
515d			.SPIO: 
515d			 
515d			if STORAGE_SE 
515d				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
515d			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
515d			 
515d					call spi_ce_low 
515d			    NEXTW 
515d			 
515d			.SPICEH: 
515d				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
515d			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
515d			 
515d					call spi_ce_high 
515d			    NEXTW 
515d			 
515d			 
515d			.SPIOb: 
515d			 
515d				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
515d			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
515d			 
515d					if DEBUG_FORTH_WORDS_KEY 
515d						DMARK "SPo" 
515d						CALLMONITOR 
515d					endif 
515d					; get port 
515d			 
515d			 
515d					; get byte to send 
515d			 
515d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
515d			 
515d			;		push hl    ; u1  
515d			 
515d					; destroy value TOS 
515d			 
515d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
515d			 
515d					; one value on hl get other one back 
515d			 
515d			;		pop hl   ; u2 - addr 
515d			 
515d					; TODO Send SPI byte 
515d			 
515d			;		push hl 
515d			;		call spi_ce_low 
515d			;		pop hl 
515d					ld a, l 
515d					call spi_send_byte 
515d			;		call spi_ce_high 
515d			 
515d					NEXTW 
515d			 
515d			.SPII: 
515d				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
515d			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
515d					if DEBUG_FORTH_WORDS_KEY 
515d						DMARK "SPi" 
515d						CALLMONITOR 
515d					endif 
515d			 
515d					; TODO Get SPI byte 
515d			 
515d					call spi_read_byte 
515d			 
515d					if DEBUG_FORTH_WORDS 
515d						DMARK "Si2" 
515d						CALLMONITOR 
515d					endif 
515d					ld h, 0 
515d					ld l, a 
515d					if DEBUG_FORTH_WORDS 
515d						DMARK "Si3" 
515d						CALLMONITOR 
515d					endif 
515d					call forth_push_numhl 
515d			 
515d					NEXTW 
515d			 
515d			 
515d			 
515d			.SESEL: 
515d				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
515d			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
515d					if DEBUG_FORTH_WORDS_KEY 
515d						DMARK "BNK" 
515d						CALLMONITOR 
515d					endif 
515d			 
515d					ld a, 255 
515d					ld (spi_cartdev), a 
515d			 
515d					; get bank 
515d			 
515d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
515d			 
515d			;		push hl 
515d			 
515d					; destroy value TOS 
515d			 
515d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
515d			 
515d					; one value on hl get other one back 
515d			 
515d			;		pop hl 
515d			 
515d			 
515d					ld c, SPI_CE_HIGH 
515d					ld b, '0'    ; human readable bank number 
515d			 
515d					ld a, l 
515d			 
515d					if DEBUG_FORTH_WORDS 
515d						DMARK "BNK" 
515d						CALLMONITOR 
515d					endif 
515d			 
515d					; active low 
515d			 
515d					cp 0 
515d					jr z, .bset 
515d					cp 1 
515d					jr nz, .b2 
515d					res 0, c 
515d					ld b, '1'    ; human readable bank number 
515d			.b2:		cp 2 
515d					jr nz, .b3 
515d					res 1, c 
515d					ld b, '2'    ; human readable bank number 
515d			.b3:		cp 3 
515d					jr nz, .b4 
515d					res 2, c 
515d					ld b, '3'    ; human readable bank number 
515d			.b4:		cp 4 
515d					jr nz, .b5 
515d					res 3, c 
515d					ld b, '4'    ; human readable bank number 
515d			.b5:		cp 5 
515d					jr nz, .bset 
515d					res 4, c 
515d					ld b, '5'    ; human readable bank number 
515d			 
515d			.bset: 
515d					ld a, c 
515d					ld (spi_device),a 
515d					ld a, b 
515d					ld (spi_device_id),a 
515d					if DEBUG_FORTH_WORDS 
515d						DMARK "BN2" 
515d						CALLMONITOR 
515d					endif 
515d			 
515d					; set default SPI clk pulse time as disabled for BANK use 
515d			 
515d					ld a, 0 
515d					ld (spi_clktime), a 
515d			 
515d					NEXTW 
515d			 
515d			.CARTDEV: 
515d				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
515d			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
515d					if DEBUG_FORTH_WORDS_KEY 
515d						DMARK "CDV" 
515d						CALLMONITOR 
515d					endif 
515d			 
515d					; disable se storage bank selection 
515d			 
515d					ld a, SPI_CE_HIGH		; ce high 
515d					ld (spi_device), a 
515d			 
515d					; get bank 
515d			 
515d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
515d			 
515d			;		push hl 
515d			 
515d					; destroy value TOS 
515d			 
515d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
515d			 
515d					; one value on hl get other one back 
515d			 
515d			;		pop hl 
515d			 
515d					; active low 
515d			 
515d					ld c, 255 
515d			 
515d					ld a, l 
515d					if DEBUG_FORTH_WORDS 
515d						DMARK "CDV" 
515d						CALLMONITOR 
515d					endif 
515d					cp 0 
515d					jr z, .cset 
515d					cp 1 
515d					jr nz, .c2 
515d					res 0, c 
515d			.c2:		cp 2 
515d					jr nz, .c3 
515d					res 1, c 
515d			.c3:		cp 3 
515d					jr nz, .c4 
515d					res 2, c 
515d			.c4:		cp 4 
515d					jr nz, .c5 
515d					res 3, c 
515d			.c5:		cp 5 
515d					jr nz, .c6 
515d					res 4, c 
515d			.c6:		cp 6 
515d					jr nz, .c7 
515d					res 5, c 
515d			.c7:		cp 7 
515d					jr nz, .c8 
515d					res 6, c 
515d			.c8:		cp 8 
515d					jr nz, .cset 
515d					res 7, c 
515d			.cset:		ld a, c 
515d					ld (spi_cartdev),a 
515d			 
515d					if DEBUG_FORTH_WORDS 
515d						DMARK "CD2" 
515d						CALLMONITOR 
515d					endif 
515d			 
515d					; set default SPI clk pulse time as 10ms for CARTDEV use 
515d			 
515d					ld a, $0a 
515d					ld (spi_clktime), a 
515d					NEXTW 
515d			endif 
515d			 
515d			.ENDDEVICE: 
515d			; eof 
515d			 
# End of file forth_words_device.asm
515d			 
515d			; var handler 
515d			 
515d			 
515d			.VARS: 
515d				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
515d 77				db WORD_SYS_CORE+99             
515e 11 52			dw .V0            
5160 04				db 3 + 1 
5161 .. 00			db "VAR",0              
5165				endm 
# End of macro CWHEAD
5165			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5165			;| 
5165			;| The variable name should consist of a single letter. e.g. "a" 
5165			;! If a full string is passed then only the first char is looked at 
5165			;| Any other char could exceed bounds checks!  
5165			 
5165					if DEBUG_FORTH_WORDS_KEY 
5165						DMARK "VAR" 
5165 f5				push af  
5166 3a 7a 51			ld a, (.dmark)  
5169 32 62 ee			ld (debug_mark),a  
516c 3a 7b 51			ld a, (.dmark+1)  
516f 32 63 ee			ld (debug_mark+1),a  
5172 3a 7c 51			ld a, (.dmark+2)  
5175 32 64 ee			ld (debug_mark+2),a  
5178 18 03			jr .pastdmark  
517a ..			.dmark: db "VAR"  
517d f1			.pastdmark: pop af  
517e			endm  
# End of macro DMARK
517e						CALLMONITOR 
517e cd 6f ee			call debug_vector  
5181				endm  
# End of macro CALLMONITOR
5181					endif 
5181			 
5181					FORTH_DSP_VALUEHL 
5181 cd 05 1d			call macro_dsp_valuehl 
5184				endm 
# End of macro FORTH_DSP_VALUEHL
5184			 
5184 7e					ld a, (hl)    ; get first char on of the string 
5185			 
5185			 
5185					if DEBUG_FORTH_WORDS 
5185						DMARK "VR1" 
5185 f5				push af  
5186 3a 9a 51			ld a, (.dmark)  
5189 32 62 ee			ld (debug_mark),a  
518c 3a 9b 51			ld a, (.dmark+1)  
518f 32 63 ee			ld (debug_mark+1),a  
5192 3a 9c 51			ld a, (.dmark+2)  
5195 32 64 ee			ld (debug_mark+2),a  
5198 18 03			jr .pastdmark  
519a ..			.dmark: db "VR1"  
519d f1			.pastdmark: pop af  
519e			endm  
# End of macro DMARK
519e						CALLMONITOR 
519e cd 6f ee			call debug_vector  
51a1				endm  
# End of macro CALLMONITOR
51a1					endif 
51a1					 
51a1 f5					push af	 
51a2					FORTH_DSP_POP 
51a2 cd bd 1d			call macro_forth_dsp_pop 
51a5				endm 
# End of macro FORTH_DSP_POP
51a5 f1					pop af 
51a6			 
51a6					; convert to upper 
51a6			 
51a6 cd 6a 10				call to_upper 
51a9					if DEBUG_FORTH_WORDS 
51a9						DMARK "Vaa" 
51a9 f5				push af  
51aa 3a be 51			ld a, (.dmark)  
51ad 32 62 ee			ld (debug_mark),a  
51b0 3a bf 51			ld a, (.dmark+1)  
51b3 32 63 ee			ld (debug_mark+1),a  
51b6 3a c0 51			ld a, (.dmark+2)  
51b9 32 64 ee			ld (debug_mark+2),a  
51bc 18 03			jr .pastdmark  
51be ..			.dmark: db "Vaa"  
51c1 f1			.pastdmark: pop af  
51c2			endm  
# End of macro DMARK
51c2						CALLMONITOR 
51c2 cd 6f ee			call debug_vector  
51c5				endm  
# End of macro CALLMONITOR
51c5					endif 
51c5 06 41				ld b, 'A' 
51c7 90					sub b			; set offset 
51c8					if DEBUG_FORTH_WORDS 
51c8						DMARK "Vbb" 
51c8 f5				push af  
51c9 3a dd 51			ld a, (.dmark)  
51cc 32 62 ee			ld (debug_mark),a  
51cf 3a de 51			ld a, (.dmark+1)  
51d2 32 63 ee			ld (debug_mark+1),a  
51d5 3a df 51			ld a, (.dmark+2)  
51d8 32 64 ee			ld (debug_mark+2),a  
51db 18 03			jr .pastdmark  
51dd ..			.dmark: db "Vbb"  
51e0 f1			.pastdmark: pop af  
51e1			endm  
# End of macro DMARK
51e1						CALLMONITOR 
51e1 cd 6f ee			call debug_vector  
51e4				endm  
# End of macro CALLMONITOR
51e4					endif 
51e4 cb 27				sla a  
51e6				 
51e6					 
51e6					if DEBUG_FORTH_WORDS 
51e6						DMARK "VR2" 
51e6 f5				push af  
51e7 3a fb 51			ld a, (.dmark)  
51ea 32 62 ee			ld (debug_mark),a  
51ed 3a fc 51			ld a, (.dmark+1)  
51f0 32 63 ee			ld (debug_mark+1),a  
51f3 3a fd 51			ld a, (.dmark+2)  
51f6 32 64 ee			ld (debug_mark+2),a  
51f9 18 03			jr .pastdmark  
51fb ..			.dmark: db "VR2"  
51fe f1			.pastdmark: pop af  
51ff			endm  
# End of macro DMARK
51ff						CALLMONITOR 
51ff cd 6f ee			call debug_vector  
5202				endm  
# End of macro CALLMONITOR
5202					endif 
5202			 
5202 21 eb e9				ld hl, cli_var_array2 
5205 cd f5 0d				call addatohl 
5208 cd 00 1b				call forth_push_numhl 
520b			 
520b			 
520b				       NEXTW 
520b cd 6c ee			call parse_vector 
520e c3 f0 1e			jp macro_next 
5211				endm 
# End of macro NEXTW
5211			.V0: 
5211				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5211 78				db WORD_SYS_CORE+100             
5212 2c 52			dw .V0Q            
5214 04				db 3 + 1 
5215 .. 00			db "V0!",0              
5219				endm 
# End of macro CWHEAD
5219			;| V0! ( u1 -- )  Store value to v0  | DONE 
5219			 
5219					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5219 cd 05 1d			call macro_dsp_valuehl 
521c				endm 
# End of macro FORTH_DSP_VALUEHL
521c			 
521c 11 1f ea				ld de, cli_var_array 
521f			 
521f eb					ex de, hl 
5220 73					ld (hl), e 
5221 23					inc hl 
5222 72					ld (hl), d 
5223			 
5223					; destroy value TOS 
5223			 
5223					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5223 cd bd 1d			call macro_forth_dsp_pop 
5226				endm 
# End of macro FORTH_DSP_POP
5226			 
5226				       NEXTW 
5226 cd 6c ee			call parse_vector 
5229 c3 f0 1e			jp macro_next 
522c				endm 
# End of macro NEXTW
522c			.V0Q: 
522c				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
522c 79				db WORD_SYS_CORE+101             
522d 40 52			dw .V1S            
522f 04				db 3 + 1 
5230 .. 00			db "V0@",0              
5234				endm 
# End of macro CWHEAD
5234			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5234 2a 1f ea				ld hl, (cli_var_array) 
5237 cd 00 1b				call forth_push_numhl 
523a			 
523a				       NEXTW 
523a cd 6c ee			call parse_vector 
523d c3 f0 1e			jp macro_next 
5240				endm 
# End of macro NEXTW
5240			.V1S: 
5240				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5240 7a				db WORD_SYS_CORE+102             
5241 5b 52			dw .V1Q            
5243 04				db 3 + 1 
5244 .. 00			db "V1!",0              
5248				endm 
# End of macro CWHEAD
5248			;| V1! ( u1 -- )  Store value to v1 | DONE 
5248					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5248 cd 05 1d			call macro_dsp_valuehl 
524b				endm 
# End of macro FORTH_DSP_VALUEHL
524b			 
524b 11 21 ea				ld de, cli_var_array+2 
524e				 
524e eb					ex de, hl 
524f 73					ld (hl), e 
5250 23					inc hl 
5251 72					ld (hl), d 
5252			 
5252					; destroy value TOS 
5252			 
5252					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5252 cd bd 1d			call macro_forth_dsp_pop 
5255				endm 
# End of macro FORTH_DSP_POP
5255				       NEXTW 
5255 cd 6c ee			call parse_vector 
5258 c3 f0 1e			jp macro_next 
525b				endm 
# End of macro NEXTW
525b			.V1Q: 
525b				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
525b 7b				db WORD_SYS_CORE+103             
525c 6f 52			dw .V2S            
525e 04				db 3 + 1 
525f .. 00			db "V1@",0              
5263				endm 
# End of macro CWHEAD
5263			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5263 2a 21 ea				ld hl, (cli_var_array+2) 
5266 cd 00 1b				call forth_push_numhl 
5269				       NEXTW 
5269 cd 6c ee			call parse_vector 
526c c3 f0 1e			jp macro_next 
526f				endm 
# End of macro NEXTW
526f			.V2S: 
526f				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
526f 7c				db WORD_SYS_CORE+104             
5270 8a 52			dw .V2Q            
5272 04				db 3 + 1 
5273 .. 00			db "V2!",0              
5277				endm 
# End of macro CWHEAD
5277			;| V2! ( u1 -- )  Store value to v2 | DONE 
5277					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5277 cd 05 1d			call macro_dsp_valuehl 
527a				endm 
# End of macro FORTH_DSP_VALUEHL
527a			 
527a 11 23 ea				ld de, cli_var_array+4 
527d				 
527d eb					ex de, hl 
527e 73					ld (hl), e 
527f 23					inc hl 
5280 72					ld (hl), d 
5281			 
5281					; destroy value TOS 
5281			 
5281					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5281 cd bd 1d			call macro_forth_dsp_pop 
5284				endm 
# End of macro FORTH_DSP_POP
5284				       NEXTW 
5284 cd 6c ee			call parse_vector 
5287 c3 f0 1e			jp macro_next 
528a				endm 
# End of macro NEXTW
528a			.V2Q: 
528a				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
528a 7d				db WORD_SYS_CORE+105             
528b 9e 52			dw .V3S            
528d 04				db 3 + 1 
528e .. 00			db "V2@",0              
5292				endm 
# End of macro CWHEAD
5292			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5292 2a 23 ea				ld hl, (cli_var_array+4) 
5295 cd 00 1b				call forth_push_numhl 
5298				       NEXTW 
5298 cd 6c ee			call parse_vector 
529b c3 f0 1e			jp macro_next 
529e				endm 
# End of macro NEXTW
529e			.V3S: 
529e				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
529e 7c				db WORD_SYS_CORE+104             
529f b9 52			dw .V3Q            
52a1 04				db 3 + 1 
52a2 .. 00			db "V3!",0              
52a6				endm 
# End of macro CWHEAD
52a6			;| V3! ( u1 -- )  Store value to v3 | DONE 
52a6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52a6 cd 05 1d			call macro_dsp_valuehl 
52a9				endm 
# End of macro FORTH_DSP_VALUEHL
52a9			 
52a9 11 25 ea				ld de, cli_var_array+6 
52ac				 
52ac eb					ex de, hl 
52ad 73					ld (hl), e 
52ae 23					inc hl 
52af 72					ld (hl), d 
52b0			 
52b0					; destroy value TOS 
52b0			 
52b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52b0 cd bd 1d			call macro_forth_dsp_pop 
52b3				endm 
# End of macro FORTH_DSP_POP
52b3				       NEXTW 
52b3 cd 6c ee			call parse_vector 
52b6 c3 f0 1e			jp macro_next 
52b9				endm 
# End of macro NEXTW
52b9			.V3Q: 
52b9				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
52b9 7d				db WORD_SYS_CORE+105             
52ba cd 52			dw .END            
52bc 04				db 3 + 1 
52bd .. 00			db "V3@",0              
52c1				endm 
# End of macro CWHEAD
52c1			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
52c1 2a 25 ea				ld hl, (cli_var_array+6) 
52c4 cd 00 1b				call forth_push_numhl 
52c7				       NEXTW 
52c7 cd 6c ee			call parse_vector 
52ca c3 f0 1e			jp macro_next 
52cd				endm 
# End of macro NEXTW
52cd			 
52cd			 
52cd			 
52cd			 
52cd			 
52cd			; end of dict marker 
52cd			 
52cd 00			.END:    db WORD_SYS_END 
52ce 00 00			dw 0 
52d0 00				db 0 
52d1			 
52d1			; use to jp here for user dict words to save on macro expansion  
52d1			 
52d1			user_dict_next: 
52d1				NEXTW 
52d1 cd 6c ee			call parse_vector 
52d4 c3 f0 1e			jp macro_next 
52d7				endm 
# End of macro NEXTW
52d7			 
52d7			 
52d7			user_exec: 
52d7				;    ld hl, <word code> 
52d7				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
52d7				;    call forthexec 
52d7				;    jp user_dict_next   (NEXT) 
52d7			        ;    <word code bytes> 
52d7 eb				ex de, hl 
52d8 2a b9 e5			ld hl,(os_tok_ptr) 
52db				 
52db				FORTH_RSP_NEXT 
52db cd a7 1a			call macro_forth_rsp_next 
52de				endm 
# End of macro FORTH_RSP_NEXT
52de			 
52de			if DEBUG_FORTH_UWORD 
52de						DMARK "UEX" 
52de f5				push af  
52df 3a f3 52			ld a, (.dmark)  
52e2 32 62 ee			ld (debug_mark),a  
52e5 3a f4 52			ld a, (.dmark+1)  
52e8 32 63 ee			ld (debug_mark+1),a  
52eb 3a f5 52			ld a, (.dmark+2)  
52ee 32 64 ee			ld (debug_mark+2),a  
52f1 18 03			jr .pastdmark  
52f3 ..			.dmark: db "UEX"  
52f6 f1			.pastdmark: pop af  
52f7			endm  
# End of macro DMARK
52f7				CALLMONITOR 
52f7 cd 6f ee			call debug_vector  
52fa				endm  
# End of macro CALLMONITOR
52fa			endif 
52fa			 
52fa			 
52fa			 
52fa eb				ex de, hl 
52fb 22 b9 e5			ld (os_tok_ptr), hl 
52fe				 
52fe				; Don't use next - Skips the first word in uword. 
52fe			 
52fe c3 79 1f			jp exec1 
5301			;	NEXT 
5301			 
5301			 
5301			; eof 
# End of file forth_wordsv4.asm
5301			endif 
5301			;;;;;;;;;;;;;; Debug code 
5301			 
5301			 
5301			;if DEBUG_FORTH_PARSE 
5301 .. 00		.nowordfound: db "No match",0 
530a .. 00		.compword:	db "Comparing word ",0 
531a .. 00		.nextwordat:	db "Next word at",0 
5327 .. 00		.charmatch:	db "Char match",0 
5332			;endif 
5332			if DEBUG_FORTH_JP 
5332			.foundword:	db "Word match. Exec..",0 
5332			endif 
5332			;if DEBUG_FORTH_PUSH 
5332 .. 00		.enddict:	db "Dict end. Push.",0 
5342 .. 00		.push_str:	db "Pushing string",0 
5351 .. 00		.push_num:	db "Pushing number",0 
5360 .. 00		.data_sp:	db "SP:",0 
5364 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5376 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5388 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
539a			;endif 
539a			;if DEBUG_FORTH_MALLOC 
539a .. 00		.push_malloc:	db "Malloc address",0 
53a9			;endif 
53a9			 
53a9			 
53a9			 
53a9			; display malloc address and current data stack pointer  
53a9			 
53a9			malloc_error: 
53a9 d5				push de 
53aa f5				push af 
53ab e5				push hl 
53ac cd c8 0b			call clear_display 
53af 11 cf 53			ld de, .mallocerr 
53b2 3e 00			ld a,0 
53b4			;	ld de,os_word_scratch 
53b4 cd db 0b			call str_at_display 
53b7 3e 11			ld a, display_row_1+17 
53b9 11 62 ee			ld de, debug_mark 
53bc cd db 0b			call str_at_display 
53bf cd eb 0b			call update_display 
53c2				;call break_point_state 
53c2 cd 32 65			call cin_wait 
53c5			 
53c5			;	ld a, ' ' 
53c5			;	ld (os_view_disable), a 
53c5 cd 79 14			call bp_on 
53c8 e1				pop hl 
53c9 f1				pop af 
53ca d1				pop de	 
53cb				CALLMONITOR 
53cb cd 6f ee			call debug_vector  
53ce				endm  
# End of macro CALLMONITOR
53ce c9				ret 
53cf			 
53cf .. 00		.mallocerr: 	db "Malloc Error",0 
53dc			;if DEBUG_FORTH_PUSH 
53dc			display_data_sp: 
53dc f5				push af 
53dd			 
53dd				; see if disabled 
53dd			 
53dd			 
53dd 3a 6f ee			ld a, (debug_vector) 
53e0 fe c9			cp $C9  ; RET 
53e2				;ld a, (os_view_disable) 
53e2				;cp '*' 
53e2 28 67			jr z, .skipdsp 
53e4			 
53e4 e5				push hl 
53e5 e5				push hl 
53e6 e5			push hl 
53e7 cd c8 0b			call clear_display 
53ea e1			pop hl 
53eb 7c				ld a,h 
53ec 21 bd e5			ld hl, os_word_scratch 
53ef cd fe 0f			call hexout 
53f2 e1				pop hl 
53f3 7d				ld a,l 
53f4 21 bf e5			ld hl, os_word_scratch+2 
53f7 cd fe 0f			call hexout 
53fa 21 c1 e5			ld hl, os_word_scratch+4 
53fd 3e 00			ld a,0 
53ff 77				ld (hl),a 
5400 11 bd e5			ld de,os_word_scratch 
5403 3e 28				ld a, display_row_2 
5405 cd db 0b				call str_at_display 
5408 11 64 53			ld de, .wordinhl 
540b 3e 00			ld a, display_row_1 
540d			 
540d cd db 0b				call str_at_display 
5410 11 62 ee			ld de, debug_mark 
5413 3e 11			ld a, display_row_1+17 
5415			 
5415 cd db 0b				call str_at_display 
5418			 
5418				; display current data stack pointer 
5418 11 60 53			ld de,.data_sp 
541b 3e 30				ld a, display_row_2 + 8 
541d cd db 0b				call str_at_display 
5420			 
5420 2a e5 e9			ld hl,(cli_data_sp) 
5423 e5				push hl 
5424 7c				ld a,h 
5425 21 bd e5			ld hl, os_word_scratch 
5428 cd fe 0f			call hexout 
542b e1				pop hl 
542c 7d				ld a,l 
542d 21 bf e5			ld hl, os_word_scratch+2 
5430 cd fe 0f			call hexout 
5433 21 c1 e5			ld hl, os_word_scratch+4 
5436 3e 00			ld a,0 
5438 77				ld (hl),a 
5439 11 bd e5			ld de,os_word_scratch 
543c 3e 33				ld a, display_row_2 + 11 
543e cd db 0b				call str_at_display 
5441			 
5441			 
5441 cd eb 0b			call update_display 
5444 cd 00 0b			call delay1s 
5447 cd 00 0b			call delay1s 
544a e1				pop hl 
544b			.skipdsp: 
544b f1				pop af 
544c c9				ret 
544d			 
544d			display_data_malloc: 
544d			 
544d f5				push af 
544e e5				push hl 
544f e5				push hl 
5450 e5			push hl 
5451 cd c8 0b			call clear_display 
5454 e1			pop hl 
5455 7c				ld a,h 
5456 21 bd e5			ld hl, os_word_scratch 
5459 cd fe 0f			call hexout 
545c e1				pop hl 
545d 7d				ld a,l 
545e 21 bf e5			ld hl, os_word_scratch+2 
5461 cd fe 0f			call hexout 
5464 21 c1 e5			ld hl, os_word_scratch+4 
5467 3e 00			ld a,0 
5469 77				ld (hl),a 
546a 11 bd e5			ld de,os_word_scratch 
546d 3e 28				ld a, display_row_2 
546f cd db 0b				call str_at_display 
5472 11 9a 53			ld de, .push_malloc 
5475 3e 00			ld a, display_row_1 
5477			 
5477 cd db 0b				call str_at_display 
547a			 
547a				; display current data stack pointer 
547a 11 60 53			ld de,.data_sp 
547d 3e 30				ld a, display_row_2 + 8 
547f cd db 0b				call str_at_display 
5482			 
5482 2a e5 e9			ld hl,(cli_data_sp) 
5485 e5				push hl 
5486 7c				ld a,h 
5487 21 bd e5			ld hl, os_word_scratch 
548a cd fe 0f			call hexout 
548d e1				pop hl 
548e 7d				ld a,l 
548f 21 bf e5			ld hl, os_word_scratch+2 
5492 cd fe 0f			call hexout 
5495 21 c1 e5			ld hl, os_word_scratch+4 
5498 3e 00			ld a,0 
549a 77				ld (hl),a 
549b 11 bd e5			ld de,os_word_scratch 
549e 3e 33				ld a, display_row_2 + 11 
54a0 cd db 0b				call str_at_display 
54a3			 
54a3 cd eb 0b			call update_display 
54a6 cd 00 0b			call delay1s 
54a9 cd 00 0b			call delay1s 
54ac e1				pop hl 
54ad f1				pop af 
54ae c9				ret 
54af			;endif 
54af			 
54af			include "forth_autostart.asm" 
54af			; list of commands to perform at system start up 
54af			 
54af			startcmds: 
54af			;	dw test11 
54af			;	dw test12 
54af			;	dw test13 
54af			;	dw test14 
54af			;	dw test15 
54af			;	dw test16 
54af			;	dw test17 
54af			;	dw ifthtest1 
54af			;	dw ifthtest2 
54af			;	dw ifthtest3 
54af			;	dw mmtest1 
54af			;	dw mmtest2 
54af			;	dw mmtest3 
54af			;	dw mmtest4 
54af			;	dw mmtest5 
54af			;	dw mmtest6 
54af			;	dw iftest1 
54af			;	dw iftest2 
54af			;	dw iftest3 
54af			;	dw looptest1 
54af			;	dw looptest2 
54af			;	dw test1 
54af			;	dw test2 
54af			;	dw test3 
54af			;	dw test4 
54af			;	dw game2r 
54af			;	dw game2b1 
54af			;	dw game2b2 
54af			 
54af				; start up words that are actually useful 
54af			 
54af			;    dw spi1 
54af			;    dw spi2 
54af			;    dw spi3 
54af			;    dw spi4 
54af			;    dw spi5 
54af			;    dw spi6 
54af			;    dw spi7 
54af			; 
54af			;    dw spi8 
54af			;    dw spi9 
54af			;    dw spi10 
54af			 
54af			; file editor 
54af			;	dw edit1 
54af			;	dw edit2 
54af			;	dw edit3 
54af			 
54af			;	dw longread 
54af d1 58			dw clrstack 
54b1 05 59			dw type 
54b3			;	dw stest 
54b3 2a 59			dw strncpy 
54b5 9a 5a			dw list 
54b7 8b 59			dw start1 
54b9 9b 59			dw start2 
54bb			;	dw start3 
54bb			;	dw start3b 
54bb			;	dw start3c 
54bb			 
54bb				; (unit) testing words 
54bb			 
54bb			;	dw mtesta 
54bb			;	dw mtestb 
54bb			;	dw mtestc 
54bb			;	dw mtestd 
54bb			;	dw mteste 
54bb			 
54bb				; demo/game words 
54bb			 
54bb			;        dw game3w 
54bb			;        dw game3p 
54bb			;        dw game3sc 
54bb			;        dw game3vsi 
54bb			;        dw game3vs 
54bb				 
54bb			;	dw game2b 
54bb			;	dw game2bf 
54bb			;	dw game2mba 
54bb			;	dw game2mbas 
54bb			;	dw game2mb 
54bb			 
54bb cb 5c			dw game1 
54bd dc 5c			dw game1a 
54bf 3e 5d			dw game1b 
54c1 73 5d			dw game1c 
54c3 a9 5d			dw game1d 
54c5 da 5d			dw game1s 
54c7 ee 5d			dw game1t 
54c9 03 5e			dw game1f 
54cb 37 5e			dw game1z 
54cd 7b 5e			dw game1zz 
54cf			 
54cf 04 5b			dw test5 
54d1 3c 5b			dw test6 
54d3 74 5b			dw test7 
54d5 88 5b			dw test8 
54d7 b4 5b			dw test9 
54d9 ca 5b			dw test10 
54db				 
54db 52 5f		        dw ssv5 
54dd 36 5f		        dw ssv4 
54df 1a 5f		        dw ssv3 
54e1 e4 5e		        dw ssv2 
54e3 6b 5f		        dw ssv1 
54e5 b3 5f		        dw ssv1cpm 
54e7			;	dw keyup 
54e7			;	dw keydown 
54e7			;	dw keyleft 
54e7			;	dw keyright 
54e7			;	dw 	keyf1 
54e7			;	dw keyf2 
54e7			;	dw keyf3 
54e7			;	dw keyf4 
54e7			;	dw keyf5 
54e7			;	dw keyf6 
54e7			;	dw keyf7 
54e7			;	dw keyf8 
54e7			;	dw keyf9 
54e7			;	dw keyf10 
54e7			;	dw keyf11 
54e7			;	dw keyf12 
54e7			;	dw keytab 
54e7			;	dw keycr 
54e7			;	dw keyhome 
54e7			;	dw keyend 
54e7			;	dw keybs 
54e7 00 00			db 0, 0	 
54e9			 
54e9			 
54e9			; File Editor 
54e9			 
54e9			; ( id - ) use 'e' to edit the displayed line 
54e9 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
550a .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
553f			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
553f .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5577			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5577			 
5577			; SPI Net support words 
5577			 
5577			; v0! = node to send to 
5577			; ( str count - ) 
5577 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
55d0			 
55d0			; spiputc ( char node - ) 
55d0 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
5604			; spiputc ( u node - ) 
5604 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
5632			 
5632			; spigetc ( - n ) 
5632 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
565b			 
565b			; getnode ( - n ) 
565b .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
5688			 
5688			; ( str node - )  
5688 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
56ee			; store string ( str i - ) 
56ee			 
56ee			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
56ee .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
5743			 
5743			; get string ( addr i -  )    TO FIX 
5743			 
5743 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
579b			 
579b			 
579b			; NETCHAT (TODO) 
579b			; Program to allow two nodes to chat with eachother 
579b			; 
579b			; v0 - target node 
579b			;  
579b			; accept input at 0,0 
579b			; if input is string send spitype to target node 
579b			; starting at row 2,0 , while spigetchr is not zero ->  
579b			; 
579b			; 
579b			; TODO add paging of get request 
579b			 
579b			; ( node - ) 
579b .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
57ba .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5812 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
588a			 
588a			 
588a			; Long read of currently open file 
588a .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
58d1			 
58d1			; clear stack  
58d1			 
58d1 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
5905			 
5905			; type ( addr count - ) 
5905 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
592a			 
592a			; some direct memory words 
592a			; strncpy ( len t f -- t ) 
592a			 
592a .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
598b			 
598b .. 00		start1:     	db ": bpon $00 bp ;",0 
599b .. 00		start2:     	db ": bpoff $01 bp ;",0 
59ac .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
5a27 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5a87			 
5a87 .. 00		tuck:         db ": tuck swap over ;", 0 
5a9a			 
5a9a			; a handy word to list items on the stack 
5a9a			 
5a9a .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5b04			 
5b04			 
5b04			; test stack  
5b04			; rnd8 stest 
5b04			 
5b04			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5b04			 
5b04			; random malloc and free cycles 
5b04			 
5b04			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5b04			 
5b04			; fixed malloc and free cycles 
5b04			 
5b04			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5b04			 
5b04			; fixed double string push and drop cycle  
5b04			 
5b04			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5b04			 
5b04			; consistent fixed string push and drop cycle  
5b04			 
5b04			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5b04			 
5b04			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5b04			 
5b04			;test1:		db ": aa 1 2 3 ;", 0 
5b04			;test2:     	db "111 aa 888 999",0 
5b04			;test3:     	db ": bb 77 ;",0 
5b04			;test4:     	db "$02 $01 do i . loop bb",0 
5b04			 
5b04 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5b3c .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5b74 .. 00		test7:     	db ": box hline vline ;",0 
5b88 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5bb4 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5bca .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5bef			;test11:     	db "hello create .",0 
5bef			;test12:     	db "hello2 create .",0 
5bef			 
5bef			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5bef			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5bef			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5bef			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5bef			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5bef			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5bef			 
5bef			;iftest1:     	db "$0001 IF cls .",0 
5bef			;iftest2:     	db "$0000 IF cls .",0 
5bef			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5bef			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5bef			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5bef			 
5bef			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5bef			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5bef			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5bef			 
5bef			 
5bef .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
5c13 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
5c43 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
5c68 .. 00		sound4: db ": cha $00 ; ",0 
5c75 .. 00		sound5: db ": chb $20 ; ",0 
5c82 .. 00		sound6: db ": chc $40 ; ",0 
5c8f .. 00		sound7: db ": chd $60 ; ",0 
5c9c .. 00		sound8: db ": cnote $80 + + note ; ", 0 
5cb4 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
5ccb			 
5ccb			 
5ccb			 
5ccb			 
5ccb			; a small guess the number game 
5ccb			 
5ccb .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5cdc .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5d3e			 
5d3e .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5d73 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5da9 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5dda .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5dee .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5e03 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5e37 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5e7b			 
5e7b			; Using 'ga' save a high score across multiple runs using external storage 
5e7b			 
5e7b .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5ee4			 
5ee4			 
5ee4			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5ee4			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5ee4			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5ee4			 
5ee4			; simple screen saver to test code memory reuse to destruction 
5ee4			 
5ee4 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5f1a .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5f36 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5f52 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5f6b .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5fb3 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
600a			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
600a			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
600a			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
600a			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
600a			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
600a			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
600a			 
600a			 
600a			 
600a			; minesweeper/battleship finding game 
600a			; draws a game board of random ship/mine positions 
600a			; user enters coords to see if it hits on 
600a			; game ends when all are hit 
600a			; when hit or miss says how many may be in the area 
600a			 
600a			; setup the game board and then hide it 
600a			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
600a			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
600a			;; prompt for where to target 
600a			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
600a			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
600a			;; TODO see if the entered coords hits or misses pushes char hit of miss 
600a			;game2mbht:      db ": mbckht nop ;",0 
600a			;game2mbms:      db ": mbcms nop ;",0 
600a			; TODO how many might be near by 
600a			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
600a			 
600a			; Game 3 
600a			 
600a			; Vert scroller ski game - avoid the trees! 
600a			 
600a			; v0 score (ie turns) 
600a			; v1 player pos 
600a			; v2 left wall 
600a			; v3 right wall 
600a			 
600a			; Draw side walls randomly 
600a			 
600a			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
600a			 
600a			; Draw player 
600a			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
600a			 
600a			; TODO Get Key 
600a			 
600a			; TODO Move left right 
600a			 
600a			; scroll and move walls a bit 
600a			 
600a			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
600a			 
600a			; main game loop 
600a			 
600a			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
600a			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
600a			 
600a			; key board defs 
600a			 
600a .. 00		keyup:       db ": keyup $05 ;",0 
6018 .. 00		keydown:       db ": keydown $0a ;",0 
6028 .. 00		keyleft:       db ": keyleft $0b ;",0 
6038 .. 00		keyright:       db ": keyright $0c ;",0 
6049 .. 00		keyf1:       db ": keyf1 $10 ;",0 
6057 .. 00		keyf2:       db ": keyf2 $11 ;",0 
6065 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6073 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6081 .. 00		keyf5:       db ": keyf5 $14 ;",0 
608f .. 00		keyf6:       db ": keyf6 $15 ;",0 
609d .. 00		keyf7:       db ": keyf7 $16 ;",0 
60ab .. 00		keyf8:       db ": keyf8 $17 ;",0 
60b9 .. 00		keyf9:       db ": keyf9 $18 ;",0 
60c7 .. 00		keyf10:       db ": keyf10 $19 ;",0 
60d6 .. 00		keyf11:       db ": keyf11 $1a ;",0 
60e5 .. 00		keyf12:       db ": keyf12 $1b ;",0 
60f4			 
60f4 .. 00		keytab:       db ": keytab $09 ;",0 
6103 .. 00		keycr:       db ": keycr $0d ;",0 
6111 .. 00		keyhome:       db ": keyhome $0e ;",0 
6121 .. 00		keyend:       db ": keyend $0f ;",0 
6130 .. 00		keybs:       db ": keybs $08 ;",0 
613e			 
613e			   
613e			 
613e			 
613e			 
613e			; eof 
# End of file forth_autostart.asm
613e			 
613e			 
613e			 
613e			; stack over and underflow checks 
613e			 
613e			; init the words to detect the under/overflow 
613e			 
613e			chk_stk_init: 
613e				; a vague random number to check so we dont get any "lucky" hits 
613e 3e 2d			ld a, 45 
6140 6f				ld l, a 
6141 00				nop 
6142 3e 17			ld a, 23 
6144 67				ld h, a 
6145			 
6145 22 94 e2			ld (chk_word), hl     ; the word we need to check against 
6148			 
6148			;	ld (chk_stund), hl	; stack points.... 
6148 22 00 ef			ld (chk_stovr), hl 
614b 22 e3 e9			ld (chk_ret_und), hl 
614e 22 a1 e9			ld (chk_ret_ovr), hl 
6151 22 1f e9			ld (chk_loop_ovr), hl 
6154 22 1d e8			ld (chk_data_ovr), hl 
6157 c9				ret 
6158				 
6158			check_stacks: 
6158				; check all stack words 
6158			 
6158 e5				push hl 
6159 d5				push de 
615a			 
615a			;	ld de,(chk_word) 
615a			;	ld hl, (chk_stund)	; stack points.... 
615a			;	if DEBUG_STK_FAULT 
615a			;		DMARK "FAa" 
615a			;		CALLMONITOR 
615a			;	endif 
615a			;	call cmp16 
615a			;	jp z, .chk_faulta 
615a			; 
615a			;	ld de, sfaultsu 
615a			;	jp .chk_fault 
615a			 
615a 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
615d ed 5b 94 e2		ld de,(chk_word) 
6161				if DEBUG_STK_FAULT 
6161					DMARK "FAb" 
6161					CALLMONITOR 
6161				endif 
6161 cd 13 0e			call cmp16 
6164 28 06			jr z, .chk_fault1 
6166 11 0a 62			ld de, sfaultso 
6169 c3 bb 61			jp .chk_fault 
616c			.chk_fault1:  
616c 2a e3 e9			ld hl, (chk_ret_und) 
616f ed 5b 94 e2		ld de,(chk_word) 
6173				if DEBUG_STK_FAULT 
6173					DMARK "FAU" 
6173					CALLMONITOR 
6173				endif 
6173 cd 13 0e			call cmp16 
6176 ca 7f 61			jp z, .chk_fault2 
6179 11 1a 62			ld de, sfaultru 
617c c3 bb 61			jp .chk_fault 
617f			.chk_fault2:  
617f 2a a1 e9			ld hl, (chk_ret_ovr) 
6182 ed 5b 94 e2		ld de,(chk_word) 
6186				if DEBUG_STK_FAULT 
6186					DMARK "FA1" 
6186					CALLMONITOR 
6186				endif 
6186 cd 13 0e			call cmp16 
6189 ca 92 61			jp z, .chk_fault3 
618c 11 28 62			ld de, sfaultro 
618f c3 bb 61			jp .chk_fault 
6192			.chk_fault3:  
6192 2a 1f e9			ld hl, (chk_loop_ovr) 
6195 ed 5b 94 e2		ld de,(chk_word) 
6199				if DEBUG_STK_FAULT 
6199					DMARK "FA2" 
6199					CALLMONITOR 
6199				endif 
6199 cd 13 0e			call cmp16 
619c ca a5 61			jp z, .chk_fault4 
619f 11 42 62			ld de, sfaultlo 
61a2 c3 bb 61			jp .chk_fault 
61a5			.chk_fault4:  
61a5 2a 1d e8			ld hl, (chk_data_ovr) 
61a8 ed 5b 94 e2		ld de,(chk_word) 
61ac				if DEBUG_STK_FAULT 
61ac					DMARK "FA3" 
61ac					CALLMONITOR 
61ac				endif 
61ac cd 13 0e			call cmp16 
61af ca b8 61			jp z, .chk_fault5 
61b2 11 5c 62			ld de, sfaultdo 
61b5 c3 bb 61			jp .chk_fault 
61b8			 
61b8			 
61b8			.chk_fault5:  
61b8 d1				pop de 
61b9 e1				pop hl 
61ba			 
61ba c9				ret 
61bb			 
61bb cd c8 0b		.chk_fault: 	call clear_display 
61be 3e 28				ld a, display_row_2 
61c0 cd db 0b				call str_at_display 
61c3 11 ec 61				   ld de, .stackfault 
61c6 3e 00				ld a, display_row_1 
61c8 cd db 0b				call str_at_display 
61cb 11 62 ee				    ld de, debug_mark 
61ce 3e 11				ld a, display_row_1+17 
61d0 cd db 0b				call str_at_display 
61d3 cd eb 0b				call update_display 
61d6			 
61d6				; prompt before entering montior for investigating issue 
61d6			 
61d6 3e 78			ld a, display_row_4 
61d8 11 de 17			ld de, endprog 
61db			 
61db cd eb 0b			call update_display		 
61de			 
61de cd 78 1a			call next_page_prompt 
61e1			 
61e1 d1				pop de 
61e2 e1				pop hl 
61e3 cd 32 18				call monitor 
61e6 cd 96 1e				call forth_warmstart 
61e9 c3 2e 17				jp warmstart_afterauto 
61ec					;jp 0 
61ec					;halt 
61ec			 
61ec			 
61ec			 
61ec .. 00		.stackfault: 	db "Stack fault:",0 
61f9			 
61f9 .. 00		sfaultsu: 	db	"Stack under flow",0 
620a .. 00		sfaultso: 	db	"Stack over flow",0 
621a .. 00		sfaultru:	db "RTS underflow",0 
6228 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6242 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
625c .. 00		sfaultdo:	db "DTS overflow", 0 
6269			 
6269			 
6269			fault_dsp_under: 
6269 11 7b 62			ld de, .dsp_under 
626c c3 31 63			jp .show_fault 
626f			 
626f			fault_rsp_under: 
626f 11 89 62			ld de, .rsp_under 
6272 c3 31 63			jp .show_fault 
6275			fault_loop_under: 
6275 11 97 62			ld de, .loop_under 
6278 c3 31 63			jp .show_fault 
627b			 
627b .. 00		.dsp_under: db "DSP Underflow",0 
6289 .. 00		.rsp_under: db "RSP Underflow",0 
6297 .. 00		.loop_under: db "LOOP Underflow",0 
62a6			 
62a6			 
62a6 d5			type_faultn: 	push de 
62a7 e5					push hl 
62a8 cd c8 0b				call clear_display 
62ab 11 d5 62				   ld de, .typefaultn 
62ae 3e 00				ld a, display_row_1 
62b0 cd db 0b				call str_at_display 
62b3 11 62 ee				    ld de, debug_mark 
62b6 3e 11				ld a, display_row_1+17 
62b8 cd db 0b				call str_at_display 
62bb cd eb 0b				call update_display 
62be			 
62be				; prompt before entering montior for investigating issue 
62be			 
62be 3e 78			ld a, display_row_4 
62c0 11 de 17			ld de, endprog 
62c3			 
62c3 cd eb 0b			call update_display		 
62c6			 
62c6 cd 78 1a			call next_page_prompt 
62c9			 
62c9 e5					push hl 
62ca d5					push de 
62cb cd 32 18				call monitor 
62ce cd 96 1e				call forth_warmstart 
62d1 c3 2e 17				jp warmstart_afterauto 
62d4 76					halt 
62d5			 
62d5			 
62d5 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
62ec			 
62ec d5			type_faults: 	push de 
62ed e5					push hl 
62ee cd c8 0b				call clear_display 
62f1 11 1a 63				   ld de, .typefaults 
62f4 3e 00				ld a, display_row_1 
62f6 cd db 0b				call str_at_display 
62f9 11 62 ee				    ld de, debug_mark 
62fc 3e 11				ld a, display_row_1+17 
62fe cd db 0b				call str_at_display 
6301 cd eb 0b				call update_display 
6304			 
6304				; prompt before entering montior for investigating issue 
6304			 
6304 3e 78			ld a, display_row_4 
6306 11 de 17			ld de, endprog 
6309			 
6309 cd eb 0b			call update_display		 
630c			 
630c cd 78 1a			call next_page_prompt 
630f			 
630f e1					pop hl 
6310 d1					pop de 
6311 cd 32 18				call monitor 
6314 cd 96 1e				call forth_warmstart 
6317 c3 2e 17				jp warmstart_afterauto 
631a			 
631a			 
631a .. 00		.typefaults: db "STR Type Expected TOS!",0 
6331			 
6331			.show_fault: 	 
6331 d5					push de 
6332 cd c8 0b				call clear_display 
6335 d1					pop de 
6336 3e 00				ld a, display_row_1 
6338 cd db 0b				call str_at_display 
633b 11 62 ee				    ld de, debug_mark 
633e 3e 11				ld a, display_row_1+17 
6340 cd db 0b				call str_at_display 
6343 cd eb 0b				call update_display 
6346			 
6346				; prompt before entering montior for investigating issue 
6346			 
6346 3e 78			ld a, display_row_4 
6348 11 de 17			ld de, endprog 
634b			 
634b cd eb 0b			call update_display		 
634e			 
634e cd 78 1a			call next_page_prompt 
6351			 
6351 e1					pop hl 
6352 d1					pop de 
6353 cd 32 18				call monitor 
6356			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6356			; TODO Make optional fault restart to cli or warm boot? 
6356					;jp warmstart 
6356 c3 72 17				jp cli 
6359 76					halt 
635a			 
635a			 
635a			; handle the auto run of code from files in storage 
635a			 
635a			 
635a			include "forth_startup.asm" 
635a			; Which startup method to use? 
635a			; 
635a			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
635a			; followed by loading of a list of scripts in eeprom 
635a			 
635a			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
635a			; from eeprom 
635a			 
635a			; Select with define in main stubs 
635a			 
635a			if STARTUP_V1 
635a				include "forth_startupv1.asm" 
635a			; Startup script loading version 1 
635a			 
635a			; If SE storage is available first stage is to use the selected file 
635a			; then go through the eeprom list 
635a			 
635a .. 00		sprompt1: db "Startup load...",0 
636a .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6380			 
6380			 
6380			 
6380			 
6380			forth_startup: 
6380 21 af 54			ld hl, startcmds 
6383 3e 00			ld a, 0 
6385 32 de e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6388			 
6388 e5			.start1:	push hl 
6389 cd c8 0b			call clear_display 
638c 11 5a 63			ld de, sprompt1 
638f 3e 00		        ld a, display_row_1 
6391 cd db 0b			call str_at_display 
6394 11 6a 63			ld de, sprompt2 
6397 3e 28		        ld a, display_row_2 
6399 cd db 0b			call str_at_display 
639c e1				pop hl 
639d e5				push hl 
639e 5e				ld e,(hl) 
639f 23				inc hl 
63a0 56				ld d,(hl) 
63a1 3e 50		        ld a, display_row_3 
63a3 cd db 0b			call str_at_display 
63a6 cd eb 0b			call update_display 
63a9			 
63a9			 
63a9 3a de e6			ld a, (os_last_cmd) 
63ac fe 00			cp 0 
63ae 28 05			jr z, .startprompt 
63b0 cd f4 0a			call delay250ms 
63b3 18 24			jr .startdo 
63b5				 
63b5				 
63b5			 
63b5			.startprompt: 
63b5			 
63b5 3e 9f			ld a,display_row_4 + display_cols - 1 
63b7 11 76 1a		        ld de, endprg 
63ba cd db 0b			call str_at_display 
63bd cd eb 0b			call update_display 
63c0 cd 00 0b			call delay1s 
63c3 cd 32 65			call cin_wait 
63c6						 
63c6 fe 2a			cp '*' 
63c8 28 5e			jr z, .startupend1 
63ca fe 23			cp '#' 
63cc 20 07			jr nz, .startno 
63ce 3e 01			ld a, 1 
63d0 32 de e6			ld (os_last_cmd),a 
63d3 18 04			jr .startdo 
63d5 fe 31		.startno:	cp '1' 
63d7 28 3a			jr z,.startnxt  
63d9			 
63d9				; exec startup line 
63d9			.startdo:	 
63d9 e1				pop hl 
63da e5				push hl 
63db				 
63db 5e				ld e,(hl) 
63dc 23				inc hl 
63dd 56				ld d,(hl) 
63de eb				ex de,hl 
63df			 
63df e5				push hl 
63e0			 
63e0 3e 00			ld a, 0 
63e2				;ld a, FORTH_END_BUFFER 
63e2 cd 66 11			call strlent 
63e5 23				inc hl   ; include zero term to copy 
63e6 06 00			ld b,0 
63e8 4d				ld c,l 
63e9 e1				pop hl 
63ea 11 b8 e2			ld de, scratch 
63ed ed b0			ldir 
63ef			 
63ef			 
63ef 21 b8 e2			ld hl, scratch 
63f2 cd 3a 1f			call forthparse 
63f5 cd 76 1f			call forthexec 
63f8 cd 90 1e			call forthexec_cleanup 
63fb			 
63fb 3e 78			ld a, display_row_4 
63fd 11 de 17			ld de, endprog 
6400			 
6400 cd eb 0b			call update_display		 
6403			 
6403 3a de e6			ld a, (os_last_cmd) 
6406 fe 00			cp 0 
6408 20 09			jr nz, .startnxt 
640a cd 78 1a			call next_page_prompt 
640d cd c8 0b		        call clear_display 
6410 cd eb 0b			call update_display		 
6413			 
6413				; move onto next startup line? 
6413			.startnxt: 
6413			 
6413 cd f4 0a			call delay250ms 
6416 e1				pop hl 
6417			 
6417 23				inc hl 
6418 23				inc hl 
6419			 
6419 e5				push hl 
641a 5e				ld e, (hl) 
641b 23				inc hl 
641c 56				ld d, (hl) 
641d e1				pop hl 
641e				; TODO replace 0 test 
641e			 
641e eb				ex de, hl 
641f cd 1e 0e			call ishlzero 
6422			;	ld a,e 
6422			;	add d 
6422			;	cp 0    ; any left to do? 
6422 eb				ex de, hl 
6423 c2 88 63			jp nz, .start1 
6426 18 01			jr .startupend 
6428			 
6428 e1			.startupend1: pop hl 
6429			.startupend: 
6429			 
6429 cd c8 0b			call clear_display 
642c cd eb 0b			call update_display 
642f c9				ret 
6430			if STORAGE_SE 
6430			 
6430			sprompt3: db "Loading from start-up file?:",0 
6430			sprompt4: db "(Y=Any key/N=No)",0 
6430			 
6430			 
6430			forth_autoload: 
6430			 
6430				; load block 0 of store 1 
6430				 
6430				ld a, $fe      ; bit 0 clear 
6430				ld (spi_device), a 
6430			 
6430				call storage_get_block_0 
6430			 
6430				ld a, (store_page+STORE_0_AUTOFILE) 
6430			 
6430				cp 0 
6430				ret z     ; auto start not enabled 
6430			 
6430				call clear_display 
6430			 
6430				; set bank 
6430			 
6430					ld a, (store_page+STORE_0_BANKRUN) 
6430					ld (spi_device), a 
6430			 
6430				; get file id to load from and get the file name to display 
6430			 
6430					ld a, (store_page+STORE_0_FILERUN) 
6430			 
6430					ld l, 0 
6430					ld h, a 
6430					ld de, store_page 
6430			 
6430					if DEBUG_FORTH_WORDS 
6430						DMARK "ASp" 
6430						CALLMONITOR 
6430					endif 
6430					call storage_read 
6430			 
6430					if DEBUG_FORTH_WORDS 
6430						DMARK "ASr" 
6430						CALLMONITOR 
6430					endif 
6430			 
6430					call ishlzero 
6430					ret z             ; file not found 
6430			 
6430					ld a, display_row_2 + 10 
6430					ld de, store_page+3 
6430					call str_at_display 
6430				 
6430			; 
6430			 
6430				ld a, display_row_1+5 
6430				ld de, sprompt3 
6430				call str_at_display 
6430				ld a, display_row_3+15 
6430				ld de, sprompt4 
6430				call str_at_display 
6430			 
6430				call update_display 
6430			 
6430				call cin_wait 
6430				cp 'n' 
6430				ret z 
6430				cp 'N' 
6430				ret z 
6430			 
6430				call delay1s 
6430			 
6430				ld a, (store_page+2) 
6430				ld (store_openmaxext), a    ; save count of ext 
6430				ld a, 1  
6430				ld (store_openext), a    ; save count of ext 
6430			 
6430			.autof:  
6430				ld l , a 
6430				 
6430				ld a, (store_page) 
6430				ld h, a	 
6430				ld de, store_page 
6430					if DEBUG_FORTH_WORDS 
6430						DMARK "ASl" 
6430						CALLMONITOR 
6430					endif 
6430					call storage_read 
6430				call ishlzero 
6430				ret z 
6430			;	jr z, .autoend 
6430			 
6430					if DEBUG_FORTH_WORDS 
6430						DMARK "ASc" 
6430						CALLMONITOR 
6430					endif 
6430				ld de, store_page+2 
6430				ld a, display_row_4 
6430				call str_at_display 
6430			 
6430				call update_display 
6430				call delay250ms 
6430			 
6430			 
6430			 
6430				ld hl, store_page+2 
6430				call forthparse 
6430				call forthexec 
6430				call forthexec_cleanup 
6430			 
6430				 
6430				ld a, (store_openext) 
6430				inc a 
6430				ld (store_openext), a    ; save count of ext 
6430			 
6430				jr .autof 
6430			;.autofdone: 
6430			; 
6430			;		if DEBUG_FORTH_WORDS 
6430			;			DMARK "ASx" 
6430			;			CALLMONITOR 
6430			;		endif 
6430			;;	call clear_display 
6430			;	ret 
6430			 
6430			 
6430			 
6430			endif 
# End of file forth_startupv1.asm
6430			endif 
6430			if STARTUP_V2 
6430				include "forth_startupv2.asm" 
6430			endif 
6430			 
# End of file forth_startup.asm
6430			 
6430			; eof 
# End of file forth_kernel.asm
6430			;include "nascombasic.asm" 
6430			 
6430			 
6430			; find out where the code ends if loaded into RAM (for SC114) 
6430			;endofcode:  
6430			;	nop 
6430			 
6430			 
6430			; jump to nmi vector 
6430			 
6430			init_nmi: 
6430 3e c9			ld a, $c9   ; RET 
6432 32 72 ee			ld (nmi_vector), a 
6435 c9				ret 
6436			nmi: 
6436 e5				push hl 
6437 d5				push de 
6438 c5				push bc 
6439 f5				push af 
643a cd 72 ee			call nmi_vector 
643d f5				push af 
643e c5				push bc 
643f d5				push de 
6440 e5				push hl 
6441 ed 4d			reti 
6443			 
6443			 
6443			; eof 
6443			 
# End of file main.asm
6443			;include "firmware_lcd_4x40.asm" 
6443			;;include "firmware_lcd_4x20.asm" 
6443			include "firmware_cpm_display.asm" 
6443			 
6443			; Serial display interface for SC114 
6443			 
6443			 
6443			display_row_1: equ 0 
6443			display_row_2: equ display_row_1+display_cols 
6443			display_row_3: equ display_row_2 + display_cols 
6443			display_row_4: equ display_row_3 + display_cols 
6443			 
6443			kLCDWidth:  EQU display_cols             ;Width in characters 
6443			kLCD_Line1: EQU 0x00  
6443			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
6443			; E1 
6443			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
6443			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
6443			 
6443			lcd_init: 
6443				; no init as handled by the SCM bios 
6443 c9				ret 
6444			 
6444			 
6444			; low level functions for direct screen writes 
6444			 
6444			; output char at pos? 
6444			fLCD_Str: 
6444			        ;out (SC114_SIO_1_OUT),a 
6444 c5				push bc 
6445 d5				push de 
6446 5f				ld e, a 
6447			; TODO Replace with CP/M BIOS call 
6447 0e 02			ld c, $02 
6449 cd 05 00			call 5 
644c d1				pop de 
644d c1				pop bc 
644e c9				ret 
644f			 
644f			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
644f			fLCD_Pos: 
644f				; use ASCII escape to position 
644f			        ;out (SC114_SIO_1_OUT),a 
644f c5				push bc 
6450 d5				push de 
6451 5f				ld e, a 
6452 0e 02			ld c, $02 
6454			; TODO Replace with CP/M BIOS call 
6454 cd 05 00			call 5 
6457 d1				pop de 
6458 c1				pop bc 
6459			 
6459 c9				ret 
645a			 
645a			; output char at pos 
645a			fLCD_Data: 
645a			      ;  out (SC114_SIO_1_OUT),a 
645a c5				push bc 
645b d5				push de 
645c 0e 02			ld c, $02 
645e 5f				ld e, a 
645f			; TODO Replace with CP/M BIOS call 
645f cd 05 00			call 5 
6462 d1				pop de 
6463 c1				pop bc 
6464			 
6464 c9				ret 
6465			 
6465			; ascii cls  
6465			 
6465 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
6469			 
6469 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
6480			;.clscpm: db 3, $3c,"$" 
6480			 
6480			; write the frame buffer given in hl to hardware  
6480			write_display: 
6480			 
6480			API: equ 0 
6480			 
6480			if API 
6480				push bc 
6480				ld b, 4 
6480			 
6480			        ld (display_write_tmp), hl 	  
6480			 
6480				; clear and home cursor 
6480			 
6480				ld c, 9 
6480				ld de, .cls 
6480			; TODO Replace with CP/M BIOS call 
6480				call 5 
6480			 
6480			 
6480			.writeln: 
6480			 
6480				ld de, (display_write_tmp) 
6480				ld c, 6 
6480			; TODO Replace with CP/M BIOS call 
6480				rst $30 
6480				ld c, 7 
6480				rst $30 
6480			 
6480				ld hl, (display_write_tmp) 
6480				ld de, display_cols 
6480				add hl,de 
6480				ld (display_write_tmp),hl 
6480			 
6480				djnz  .writeln 
6480			 
6480				pop bc 
6480			 
6480			 
6480				ret 
6480			endif 
6480 e5				push hl 
6481 c5				push bc 
6482 d5				push de 
6483			 
6483			;	ld c, 2 
6483			;	;ld de, .cls 
6483			;	ld a, 27 
6483			;	rst $30 
6483			;	ld c, 2 
6483			;	;ld de, .cls 
6483			;	ld a, '[' 
6483			;	rst $30 
6483			; 
6483			;	ld c, 2 
6483			;	;ld de, .cls 
6483			;	ld a, 'H' 
6483			;	rst $30 
6483			; 
6483			 
6483			 
6483			; lots of CR/LF 
6483			;	ld c, 9 
6483			;	ld de, .clscpm 
6483			;	call 5 
6483			 
6483			; xterm cls 
6483 0e 02			ld c, 2 
6485 1e 1b			ld e, 27 
6487 cd 05 00			call 5 
648a			; cls causes too much flicker 
648a			;	ld c, 2 
648a			;	ld e, 'c' 
648a			;	call 5 
648a			 
648a			; use xterm home instead 
648a 0e 02			ld c, 2 
648c 1e 5b			ld e, '[' 
648e cd 05 00			call 5 
6491 0e 02			ld c, 2 
6493 1e 48			ld e, 'H' 
6495 cd 05 00			call 5 
6498			LLL: equ 0 
6498			 
6498			if LLL 
6498			 
6498				ld c, 2 
6498				;ld de, .cls 
6498				ld e, 27 
6498			; TODO Replace with CP/M BIOS call 
6498				call 5 
6498			 
6498			 
6498				ld c, 2 
6498				;ld de, .cls 
6498				ld e, '[' 
6498			; TODO Replace with CP/M BIOS call 
6498				call 5 
6498				ld c, 2 
6498				;ld de, .cls 
6498				ld e, '2' 
6498			; TODO Replace with CP/M BIOS call 
6498				call 5 
6498				ld c, 2 
6498				;ld de, .cls 
6498				ld e, 'J' 
6498			; TODO Replace with CP/M BIOS call 
6498				call 5 
6498			 
6498			endif 
6498			 
6498 d1				pop de 
6499 c1				pop bc 
649a e1				pop hl 
649b			 
649b			 
649b 22 c0 eb		        ld (display_write_tmp), hl 	  
649e 3e 00			ld a, kLCD_Line1 
64a0			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
64a0 06 28			ld b, display_cols 
64a2 ed 5b c0 eb		ld de, (display_write_tmp) 
64a6 cd 29 65			call write_len_string 
64a9				 
64a9			 
64a9 e5			push hl 
64aa d5			push de 
64ab c5			push bc 
64ac 0e 02			ld c, 2 
64ae 1e 0a			ld e, 10 
64b0 cd 05 00			call 5 
64b3 0e 02			ld c, 2 
64b5 1e 0d			ld e, 13 
64b7 cd 05 00			call 5 
64ba			; TODO Replace with CP/M BIOS call 
64ba				;rst $30 
64ba c1			pop bc 
64bb d1			pop de 
64bc e1			pop hl 
64bd			 
64bd				 
64bd 2a c0 eb			ld hl, (display_write_tmp) 
64c0 11 28 00			ld de, display_cols 
64c3 19				add hl,de 
64c4 22 c0 eb			ld (display_write_tmp),hl 
64c7			 
64c7				 
64c7 3e 28			ld a, kLCD_Line2 
64c9			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
64c9 06 28			ld b, display_cols 
64cb ed 5b c0 eb		ld de, (display_write_tmp) 
64cf cd 29 65			call write_len_string 
64d2				 
64d2 2a c0 eb			ld hl, (display_write_tmp) 
64d5 11 28 00			ld de, display_cols 
64d8 19				add hl,de 
64d9 22 c0 eb			ld (display_write_tmp),hl 
64dc			 
64dc e5			push hl 
64dd d5			push de 
64de c5			push bc 
64df 0e 07			ld c, 7 
64e1			; TODO Replace with CP/M BIOS call 
64e1				;rst $30 
64e1 0e 02			ld c, 2 
64e3 1e 0a			ld e, 10 
64e5 cd 05 00			call 5 
64e8 0e 02			ld c, 2 
64ea 1e 0d			ld e, 13 
64ec cd 05 00			call 5 
64ef c1			pop bc 
64f0 d1			pop de 
64f1 e1			pop hl 
64f2			 
64f2				 
64f2 3e 50			ld a, kLCD_Line3 
64f4			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
64f4 06 28			ld b, display_cols 
64f6 ed 5b c0 eb		ld de, (display_write_tmp) 
64fa cd 29 65			call write_len_string 
64fd				 
64fd 2a c0 eb			ld hl, (display_write_tmp) 
6500 11 28 00			ld de, display_cols 
6503 19				add hl,de 
6504 22 c0 eb			ld (display_write_tmp),hl 
6507			 
6507 e5			push hl 
6508 d5			push de 
6509 c5			push bc 
650a 0e 07			ld c, 7 
650c			; TODO Replace with CP/M BIOS call 
650c				;rst $30 
650c 0e 02			ld c, 2 
650e 1e 0a			ld e, 10 
6510 cd 05 00			call 5 
6513 0e 02			ld c, 2 
6515 1e 0d			ld e, 13 
6517 cd 05 00			call 5 
651a c1			pop bc 
651b d1			pop de 
651c e1			pop hl 
651d			 
651d				 
651d 3e 78			ld a, kLCD_Line4 
651f			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
651f 06 28			ld b, display_cols 
6521 ed 5b c0 eb		ld de, (display_write_tmp) 
6525 cd 29 65			call write_len_string 
6528 c9					ret 
6529			 
6529			 
6529				; write out a fixed length string given in b from de 
6529			 
6529 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
652a cd 5a 64		            CALL fLCD_Data      ;Write character to display 
652d 13				inc de 
652e 10 f9			djnz write_len_string 
6530 c9				ret 
6531			 
6531			 
6531			; eof 
# End of file firmware_cpm_display.asm
6531			;include "firmware_key_5x10.asm" 
6531			;;include "firmware_key_4x10.asm" 
6531			include "firmware_key_cpm.asm" 
6531			; Serial keyboard interface for SC114 
6531			 
6531			 
6531			key_init: 
6531				; no init as handled by the SCM bios 
6531 c9				ret 
6532			 
6532			 
6532			cin_wait: 
6532			;	ld a, 0 
6532			;	ret 
6532			 
6532				;in a,(SC114_SIO_1_IN) 
6532			        ; Use SCM API to get from whatever console device we are using 
6532			 
6532			; TODO Replace with CP/M BIOS call 
6532 c5				push bc 
6533 0e 01			ld c, $01 
6535 cd 05 00			call 5 
6538 c1				pop bc 
6539 c9				ret 
653a			 
653a			cinndb:  
653a			cin: 
653a			 
653a			 
653a c5				push bc 
653b			 
653b				; any key waiting to process? 
653b			; TODO Replace with CP/M BIOS call 
653b 0e 06			ld c, $06 
653d cd 05 00			call 5 
6540 28 0d			jr z, .cin_skip 
6542			 
6542				; yep, get it 
6542			 
6542 0e 01			ld c, $01 
6544			; TODO Replace with CP/M BIOS call 
6544 cd 05 00			call 5 
6547			 
6547 fe 7f			cp $7f     ; back space 
6549 20 02			jr nz, .skipbs 
654b 3e 08			ld a, KEY_BS 
654d			.skipbs: 
654d			 
654d c1				pop bc 
654e c9				ret 
654f			.cin_skip: 
654f 3e 00			ld a, 0 
6551 c1				pop bc 
6552 c9				ret 
6553			 
6553			 
6553			 
6553			 
# End of file firmware_key_cpm.asm
6553			endofcode:  
6553			baseram:  
6553 00				nop 
6554			 
6554			heap_start: equ baseram+15  ; Starting address of heap 
6554			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
6554			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
6554			;VDU:  EQU     endofcode           ; BASIC Work space 
6554			; eof 
6554			 
# End of file os_mega_cpm.asm
6554
