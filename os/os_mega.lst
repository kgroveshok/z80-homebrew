# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 2f 1c			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-08-11 12:33' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
001f			 
001f			 
001f			 
001f			;        nop  
001f			;        nop 
001f			;;	org 05h		; null out bdos call 
001f			; 
001f			;        nop  
001f			;        nop  
001f			;        nop 
001f			;;	org 08h 
001f			;;; 
001f			;;	jp cin		; rst 8 - char in 
001f			;;; 
001f			; 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;	org 010h 
001f			;; 
001f			;	jp cout		; rest 010h  - char out 
001f			;; 
001f			;	org 01bh   
001f			; 
001f			;	;jp  		; rst 01bh   - write string to display 
001f			;	jp str_at_display 
001f			; 
001f			; 
001f			;	org 020h 
001f			; 
001f			;	; jp		 ; rst 020h - read char at screen location 
001f			; 
001f			;	org 028h 
001f			 
001f				; jp		 ; rst 028h  - storage i/o 
001f			 
001f			; 	org 030h 
001f			;	jp break_point_state 
001f			  
001f			; $30  
001f			; org 038h 
001f			; $38 
001f			 
001f			; TODO any more important entry points to add to jump table for easier coding use? 
001f			 
001f			if BASE_KEV = 1  
001f			 
001f				; need to be at $66 for nmi support 
001f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0025 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0031 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0037 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0043 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0049 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0055 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0061 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0067 00 ff			db 0,255 
0069 c3 4c 6f			jp nmi 
006c			endif 
006c			 
006c			include "firmware.asm" 
006c			  
006c			; main constants (used here and in firmware)  
006c			  
006c			; TODO have page 0 of storage as bios  
006c			  
006c			Device_A: equ 0h  
006c			Device_B: equ 040h          ; Sound  
006c			  
006c			if BASE_KEV  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_SC114  
006c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			; TODO fixup for CPM  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			Device_D: equ 0c0h             ; Keyboard and LCD  
006c			  
006c			; Odd specific debug points for testing hardware dev  
006c			  
006c			;if DEBUG_LEVEL0  
006c			;	include "debug_level0.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL1  
006c			;	include "debug_level1.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL2  
006c			;	include "debug_level2.asm"  
006c			;endif  
006c			  
006c			  
006c			CALLMONITOR: macro  
006c			;	call break_point_state  
006c			; now use the break point debug vector  
006c				call debug_vector  
006c				endm  
006c			  
006c			MALLOC_1: equ 1        ; from dk88   
006c			MALLOC_2: equ 0           ; broke  
006c			MALLOC_3: equ 0           ; really broke  
006c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
006c			  
006c			if BASE_KEV   
006c			;stacksize: equ 256  
006c			; each stack entry is three bytes (type + word)  
006c			stacksize: equ 3*150  
006c			  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 512  
006c			endif  
006c			if BASE_SC114  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			;if STORAGE_SE == 0  
006c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
006c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
006c			;endif  
006c			  
006c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
006c			  
006c			STORE_0_AUTORUN: equ $20  
006c			  
006c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
006c			  
006c			STORE_0_AUTOFILE: equ $21  
006c			STORE_0_BANKRUN: equ $23  
006c			STORE_0_FILERUN: equ $24  
006c			  
006c			; Block 0 offsets for settings  
006c			  
006c			; if set then skip prompt for start up and accept all  
006c			  
006c			STORE_0_QUICKSTART: equ $25  
006c			  
006c			; Blocks where directory table is held  
006c			  
006c			; Reducing the number of entries increases the max file size  
006c			  
006c			;STORE_DIR_START: equ 1  
006c			;STORE_DIR_END: equ 33  
006c			  
006c			; Blocks from where file data is stored  
006c			  
006c			;STORE_DATA_START: equ STORE_DIR_END + 1  
006c			  
006c			; Block indicators (<32 are data files)  
006c			  
006c			;STORE_BLOCK_CFG: equ $8f       ; config block  
006c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
006c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
006c			;STORE_BLOCK_FREE: equ $85       ; data block free  
006c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
006c			  
006c			  
006c			  
006c			; Directory entry flags  
006c			  
006c			;STORE_DIR_FREE: equ 0  
006c			;STORE_DIR_FILE:  equ 1  
006c			  
006c			; Structure offsets to directory entries  
006c			;STORE_DE_FLAG: equ 0  
006c			;STORE_DE_MAXEXT: equ 1  
006c			;STORE_DE_FILENAME: equ 2  
006c			  
006c			; Structure offsets to block 0  
006c			  
006c			;STORE_BK0_ISFOR: equ 1  
006c			;STORE_BK0_LABEL: equ 3  
006c			  
006c			; memory allocation   
006c			  
006c			chk_stund: equ tos+2           ; underflow check word  
006c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
006c			  
006c			; keyscan table needs rows x cols buffer  
006c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
006c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
006c			  
006c			keyscan_table_row1: equ chk_stovr -key_cols-1  
006c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
006c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
006c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
006c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
006c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
006c			keyscan_scancol: equ keyscan_table-key_cols  
006c			;keyscan_table_len: equ key_rows*key_cols  
006c			;keybufptr: equ keyscan_table - 2  
006c			;keysymbol: equ keybufptr - 1  
006c			key_held: equ keyscan_scancol-1	; currently held  
006c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
006c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
006c			key_fa: equ key_repeat_ct -1 ;  
006c			key_fb: equ key_fa -1 ;  
006c			key_fc: equ key_fb -1 ;  
006c			key_fd: equ key_fc -1 ;  
006c			key_face_held: equ key_fd - 1   
006c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
006c			  
006c			hardware_config: equ key_face_held - 10  
006c			  
006c			; hardware config switches  
006c			; TODO add bitmasks on includes for hardware  
006c			; high byte for expansion ids  
006c			;     0000 0000  no card inserted  
006c			;     0000 0001  storage card inserted  
006c			;     0000 0010  spi sd card active  
006c			  
006c			;       
006c			; low byte:  
006c			;     0000 0001   4x4 keypad  
006c			;     0000 0010   full keyboard  
006c			;     0000 0011   spi/ext keyboard  
006c			;     0000 0100   20x4 lcd  
006c			;     0000 1000   40x4 lcd  
006c			;     0000 1100   spi/ext display  
006c			;     0001 0000   ide interface available  
006c			  
006c			hardware_word: equ hardware_config - 2  
006c			  
006c			; debug marker - optional display of debug point on the debug screens  
006c			  
006c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
006c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
006c			  
006c			debug_mark: equ debug_vector - 4  
006c			  
006c			; input_str vars  
006c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
006c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
006c			input_size: equ input_start -1  ; number of chars  
006c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
006c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
006c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
006c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
006c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
006c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
006c			input_len: equ input_cur_onoff - 5 ; length of current input  
006c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
006c			  
006c			; cursor blink rate  
006c			CUR_BLINK_RATE: equ $09  
006c			;CUR_BLINK_RATE: equ 15  
006c			  
006c			key_actual_pressed: equ input_cursor - 1   
006c			key_symbol: equ key_actual_pressed - 1   
006c			key_shift: equ key_symbol - 1   
006c			  
006c			; Display allocation  
006c			  
006c			;display_rows: equ 4     ; move out to mini and mega files  
006c			;display_cols: equ 20  
006c			  
006c			display_fb_len: equ display_rows*display_cols  
006c			  
006c			; primary frame buffer     
006c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
006c			; working frame buffers  
006c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
006c			display_fb3: equ  display_fb1-display_fb_len - 1  
006c			display_fb2: equ  display_fb3-display_fb_len - 1  
006c			;  
006c			; pointer to active frame buffer  
006c			display_fb_active: equ display_fb2 - 2  
006c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
006c			display_write_tmp: equ display_lcde1e2 - 2  
006c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
006c			  
006c			;  
006c			  
006c			;; can load into de directory  
006c			cursor_col: equ display_active-1  
006c			cursor_row: equ cursor_col-1  
006c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
006c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
006c			  
006c			; maths vars  
006c			  
006c			LFSRSeed: equ cursor_shape -20   
006c			randData: equ LFSRSeed - 2  
006c			xrandc: equ randData - 2  
006c			stackstore: equ xrandc - 2  
006c			seed1: equ  stackstore -2   
006c			seed2: equ seed1 - 2  
006c			  
006c			; cf storage vars  
006c			  
006c			iErrorNum:  equ seed2-1         ;Error number  
006c			iErrorReg:  equ iErrorNum -1              ;Error register  
006c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
006c			  
006c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
006c			  
006c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
006c			  
006c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
006c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
006c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
006c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
006c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
006c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
006c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
006c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
006c			store_tmpid: equ store_tmp3 - 1		; page temp id  
006c			store_tmpext: equ store_tmpid - 1		; file extent temp  
006c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
006c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
006c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
006c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
006c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
006c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
006c			;  
006c			; spi vars  
006c			  
006c			  
006c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
006c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
006c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
006c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
006c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
006c			spi_device_id: equ spi_device - 1    ; human readable bank number  
006c			  
006c			;;;;; forth cli params  
006c			  
006c			; TODO use a different frame buffer for forth???  
006c			  
006c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
006c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
006c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
006c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
006c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
006c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
006c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
006c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
006c			  
006c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
006c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
006c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
006c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
006c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
006c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
006c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
006c			  
006c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
006c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
006c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
006c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
006c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
006c			  
006c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
006c			  
006c			; os/forth token vars  
006c			  
006c			os_last_cmd: equ os_var_array-255  
006c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
006c			os_current_i: equ os_cli_cmd-2  
006c			os_cur_ptr: equ os_current_i-2  
006c			os_word_scratch: equ os_cur_ptr-30  
006c			os_tok_len: equ os_word_scratch - 2  
006c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
006c			os_tok_malloc: equ os_tok_ptr - 2  
006c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
006c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
006c			execscratch: equ os_input-255        ; exec cmd eval buffer  
006c			scratch: equ execscratch-255  
006c			  
006c			os_stack_1: equ scratch - 3       ; stack holding area 1  
006c			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
006c			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
006c			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
006c			  
006c			  
006c			; temp locations for new word processing to save on adding more   
006c			  
006c			os_new_malloc: equ os_stack_4-2  
006c			os_new_parse_len: equ os_new_malloc - 2  
006c			os_new_word_len: equ os_new_parse_len - 2  
006c			os_new_work_ptr: equ os_new_word_len - 2  
006c			os_new_src_ptr: equ os_new_work_ptr - 2  
006c			os_new_exec: equ os_new_src_ptr - 2  
006c			os_new_exec_ptr: equ os_new_exec - 2  
006c			  
006c			; resume memory alloocations....  
006c			  
006c			;os_view_disable: equ os_new_exec_ptr - 1  
006c			os_view_af: equ os_new_exec_ptr - 2  
006c			os_view_hl: equ os_view_af -2  
006c			os_view_de: equ os_view_hl - 2  
006c			os_view_bc: equ os_view_de - 2  
006c			  
006c			; stack checksum word  
006c			if DEBUG_STACK_IMB  
006c				curframe: equ  os_view_de - 5  
006c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
006c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			else  
006c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			endif  
006c			  
006c			; with data stack could see memory filled with junk. need some memory management   
006c			; malloc and free entry points added  
006c			  
006c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
006c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			;heap_end: equ free_list-1  ; Starting address of heap  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			heap_end: equ chk_word-1  ; Starting address of heap  
006c			  
006c			  
006c			;if BASE_KEV   
006c			;heap_start: equ 0800eh  ; Starting address of heap  
006c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;heap_start: equ baseram+15  ; Starting address of heap  
006c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;endif  
006c			  
006c			  
006c			;;;;  
006c			  
006c			  
006c			; change below to point to last memory alloc above  
006c			topusermem:  equ   heap_start  
006c			  
006c			;if BASE_KEV   
006c			;baseusermem: equ 08000h  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;;aseusermem:     equ    12  
006c			;baseusermem:     equ    prompt  
006c			;;baseusermem:     equ    endofcode  
006c			;endif  
006c			  
006c			  
006c			; **********************************************************************  
006c			; **  Constants  
006c			; **********************************************************************  
006c			  
006c			; Constants used by this code module  
006c			kDataReg:   EQU Device_D           ;PIO port A data register  
006c			kContReg:   EQU Device_D+2           ;PIO port A control register  
006c			  
006c			  
006c			portbdata:  equ Device_D+1    ; port b data  
006c			portbctl:   equ Device_D+3    ; port b control  
006c			  
006c			  
006c			;KEY_SHIFT:   equ 5  
006c			;KEY_SYMBOLSHIFT:  equ 6  
006c			  
006c			KEY_SHIFTLOCK: equ 4  
006c			  
006c			  
006c			KEY_UP: equ 5  
006c			KEY_NEXTWORD: equ 6  
006c			KEY_PREVWORD: equ 7  
006c			KEY_BS: equ 8  
006c			KEY_TAB:  equ 9  
006c			KEY_DOWN: equ 10  
006c			KEY_LEFT: equ 11  
006c			KEY_RIGHT: equ 12  
006c			KEY_CR:   equ 13  
006c			KEY_HOME: equ 14  
006c			KEY_END: equ 15  
006c			  
006c			KEY_F1: equ 16  
006c			KEY_F2: equ 17  
006c			KEY_F3: equ 18  
006c			KEY_F4: equ 19  
006c			  
006c			KEY_F5: equ 20  
006c			KEY_F6: equ 21  
006c			KEY_F7: equ 22  
006c			KEY_F8: equ 23  
006c			  
006c			KEY_F9: equ 24  
006c			KEY_F10: equ 25  
006c			KEY_F11: equ 26  
006c			KEY_F12: equ 27  
006c			  
006c			;if DEBUG_KEY  
006c			;	KEY_MATRIX_NO_PRESS: equ '.'  
006c			;	KEY_SHIFT:   equ '.'  
006c			;	KEY_SYMBOLSHIFT:  equ '.'  
006c			;else  
006c				KEY_SHIFT:   equ '~'  
006c				KEY_SYMBOLSHIFT:  equ '~'  
006c				KEY_MATRIX_NO_PRESS: equ '~'  
006c			;endi  
006c			  
006c			  
006c			  
006c			  
006c			; Macro to make adding debug marks easier  
006c			  
006c			DMARK: macro str  
006c				push af  
006c				ld a, (.dmark)  
006c				ld (debug_mark),a  
006c				ld a, (.dmark+1)  
006c				ld (debug_mark+1),a  
006c				ld a, (.dmark+2)  
006c				ld (debug_mark+2),a  
006c				jr .pastdmark  
006c			.dmark: db str  
006c			.pastdmark: pop af  
006c			  
006c			endm  
006c			  
006c			  
006c			; macro to detect for stack imbalances  
006c			  
006c			include "stackimbal.asm"  
006c			; Macro and code to detect stock imbalances 
006c			 
006c			SPPUSH: equ 0 
006c			 
006c			; Add a stack frame which can be checked before return 
006c			 
006c			STACKFRAME: macro onoff frame1 frame2 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c						exx 
006c			 
006c						ld de, frame1 
006c						ld a, d 
006c						ld hl, curframe 
006c						call hexout 
006c						ld a, e 
006c						ld hl, curframe+2 
006c						call hexout 
006c			  
006c						ld hl, frame1 
006c						push hl 
006c						ld hl, frame2 
006c						push hl 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			endm 
006c			 
006c			STACKFRAMECHK: macro onoff frame1 frame2 
006c			 
006c					 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						exx 
006c						; check stack frame SP 
006c			 
006c						ld hl, frame2 
006c						pop de   ; frame2 
006c			 
006c						call cmp16 
006c						jr nz, .spnosame 
006c						 
006c			 
006c						ld hl, frame1 
006c						pop de   ; frame1 
006c			 
006c						call cmp16 
006c						jr z, .spfrsame 
006c			 
006c						.spnosame: call showsperror 
006c			 
006c						.spfrsame: nop 
006c			 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			 
006c			 
006c			endm 
006c			 
006c			 
006c			; for a sub routine, wrap SP collection and comparisons 
006c			 
006c			; Usage: 
006c			; 
006c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
006c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
006c			 
006c			SAVESP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c			 
006c						ld (store_sp+(storeword*4)), sp 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			CHECKSP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c			 
006c						; save SP after last save 
006c				 
006c						ld (store_sp+(storeword*4)+2), sp 
006c			 
006c						push hl 
006c						ld hl, store_sp+(storeword*4) 
006c						call check_stack_sp  
006c						pop hl 
006c			 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			if DEBUG_STACK_IMB 
006c			 
006c			check_stack_sp: 
006c					push de 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					push de 
006c			 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					pop hl 
006c			 
006c			 
006c					; check to see if the same 
006c			 
006c					call cmp16 
006c					jr z, .spsame 
006c			 
006c					; not same 
006c			 
006c					call showsperror 
006c			.spsame: 
006c			 
006c					pop de 
006c			 
006c					ret 
006c			 
006c			.sperr:  db "Stack imbalance",0 
006c			 
006c			 
006c			showsperror: 
006c			 
006c			 
006c				push hl 
006c				push af 
006c				push de 
006c				call clear_display 
006c				ld de, .sperr 
006c				ld a,0 
006c			;	ld de,os_word_scratch 
006c				call str_at_display 
006c				ld a, display_row_1+17 
006c				ld de, debug_mark 
006c				call str_at_display 
006c				ld a, 0 
006c				ld (curframe+4),a 
006c				ld hl, curframe 
006c				ld de, os_word_scratch 
006c				ld a, display_row_4 
006c				call str_at_display 
006c				call update_display 
006c				;call break_point_state 
006c				call cin_wait 
006c			 
006c			;	ld a, ' ' 
006c			;	ld (os_view_disable), a 
006c				call bp_on 
006c				pop de	 
006c				pop af 
006c				pop hl 
006c				CALLMONITOR 
006c				ret 
006c			 
006c			endif 
006c			 
006c			 
006c			 
006c			; eof 
# End of file stackimbal.asm
006c			  
006c			;TODO macro to calc col and row offset into screen  
006c			  
006c			  
006c			  
006c			hardware_init:  
006c			  
006c				  
006c			  
006c					;ld a, 0  
006c					;ld (hardware_diag), a  
006c			  
006c					; clear all the buffers  
006c			  
006c 21 4b fc				ld hl, display_fb1  
006f 22 07 fb				ld (display_fb_active), hl  
0072			  
0072 cd a7 0d				call clear_display  
0075			  
0075 21 09 fb				ld hl, display_fb2  
0078 22 07 fb				ld (display_fb_active), hl  
007b			  
007b cd a7 0d				call clear_display  
007e			  
007e					; init primary frame buffer area  
007e 21 ec fc				ld hl, display_fb0  
0081 22 07 fb				ld (display_fb_active), hl  
0084			  
0084 cd a7 0d				call clear_display  
0087			  
0087			  
0087 cd 59 6f				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
008a			  
008a cd f0 71			call key_init  
008d cd 53 02			call storage_init  
0090			  
0090				; setup malloc functions  
0090			  
0090				if MALLOC_1  
0090 cd 92 13				call  heap_init  
0093				endif  
0093				if MALLOC_4  
0093					call  heap_init  
0093				endif  
0093			  
0093				; init sound hardware if present  
0093			  
0093				if SOUND_ENABLE  
0093					call sound_init  
0093				endif  
0093			  
0093				; lcd test sequence  
0093					  
0093 cd ca 0d			call update_display  
0096 cd ea 0c			call delay1s  
0099 3e 2b			ld a,'+'  
009b cd ac 0d			call fill_display  
009e cd ca 0d			call update_display  
00a1 cd ea 0c			call delay1s  
00a4 3e 2a			ld a,'*'  
00a6 cd ac 0d			call fill_display  
00a9 cd ca 0d			call update_display  
00ac cd ea 0c			call delay1s  
00af 3e 2d			ld a,'-'  
00b1 cd ac 0d			call fill_display  
00b4 cd ca 0d			call update_display  
00b7 cd ea 0c			call delay1s  
00ba			  
00ba			; boot splash screen  
00ba			if display_cols == 20	  
00ba			        ld a, display_row_1    
00ba			else  
00ba 3e 0a		        ld a, display_row_1 +10   
00bc			endif  
00bc 11 1f 1b			ld de, prom_bootmsg  
00bf cd ba 0d			call str_at_display  
00c2 cd ca 0d			call update_display  
00c5			  
00c5			  
00c5 cd ea 0c			call delay1s  
00c8 cd ea 0c			call delay1s  
00cb			if display_cols == 20	  
00cb			            LD   A, display_row_3+2  
00cb			else  
00cb 3e 5c		            LD   A, display_row_3+12  
00cd			endif  
00cd 11 34 1b			ld de, prom_bootmsg1  
00d0 cd ba 0d			call str_at_display  
00d3			; display debug level  
00d3 3e 78		            LD   A, display_row_4  
00d5 11 1b 00			ld de, debuglevel  
00d8 cd ba 0d			call str_at_display  
00db			  
00db cd ca 0d			call update_display  
00de cd ea 0c			call delay1s  
00e1 cd ea 0c			call delay1s  
00e4			  
00e4			;	ld a, display_row_4+3  
00e4			;	ld de, bootmsg2  
00e4			;	call str_at_display  
00e4			;	call update_display  
00e4			;	call delay1s  
00e4			;	call delay1s  
00e4			  
00e4			; debug mark setup  
00e4			  
00e4 3e 5f		ld a, '_'  
00e6 32 a6 fd		ld (debug_mark),a  
00e9 32 a7 fd		ld (debug_mark+1),a  
00ec 32 a8 fd		ld (debug_mark+2),a  
00ef 3e 00		ld a,0  
00f1 32 a9 fd		ld (debug_mark+3),a  
00f4			  
00f4 c9					ret  
00f5			  
00f5			  
00f5			;bootmsg2:	db "Firmware v0.1",0  
00f5			  
00f5			; a 4x20 lcd  
00f5			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00f5			  
00f5			;if display_cols == 20  
00f5			;	include "firmware_lcd_4x20.asm"  
00f5			;endif  
00f5			  
00f5			;if display_cols == 40  
00f5			;	include "firmware_lcd_4x40.asm"  
00f5			;endif  
00f5			  
00f5			;  
00f5			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00f5			; TODO abstract the bit bang video out interface for dual display  
00f5			; TODO wire video out to tx pin on rc2014 bus  
00f5			  
00f5			; must supply cin, and cin_wait for low level hardware abstraction   
00f5			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00f5			; test scancode  
00f5			  
00f5			;;;;;  
00f5			;;;  
00f5			; Moved out to mini and maxi versions  
00f5			;  
00f5			; include "firmware_key_4x4.asm"  
00f5			; using existing 4 wire x 4 resistor array for input  
00f5			;include "firmware_key_4x10.asm"  
00f5			; need to mod the board for 5 rows due to resistor array  
00f5			;include "firmware_key_5x10.asm"  
00f5			  
00f5			; storage hardware interface  
00f5			  
00f5			; use microchip serial eeprom for storage  
00f5			  
00f5			  
00f5			if STORAGE_SE  
00f5				include "firmware_spi.asm"  
00f5			; my spi protocol (used by storage) 
00f5			 
00f5			; SPI pins 
00f5			 
00f5			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00f5			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00f5			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00f5			 
00f5			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00f5			; chip pin 4 gnd 
00f5			 
00f5			 
00f5			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00f5			SPI_CE1: equ 1      ;    port a1 pin 14  
00f5			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00f5			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00f5			SPI_CE4: equ 4      ; port a4     pin 10 
00f5			 
00f5			; active low AND masks 
00f5			 
00f5			;SPI_CE0_MASK: equ    255-1 
00f5			;SPI_CE1_MASK: equ   255-2 
00f5			;SPI_CE2_MASK: equ   255-4 
00f5			;SPI_CE3_MASK: equ   255-8 
00f5			;SPI_CE4_MASK: equ   255-16 
00f5			SPI_CE_HIGH:  equ 255 
00f5			 
00f5			 
00f5			 
00f5			;  Perform SCLK wait pulse 
00f5			 
00f5			spi_clk: 
00f5 f5				push af 
00f6 3a 9f f9			ld a, (spi_clktime) 
00f9 fe 00			cp 0 
00fb 28 03			jr z, .scskip 
00fd cd cf 0c			call aDelayInMS 
0100			.scskip: 
0100 f1				pop af 
0101 c9				ret 
0102			 
0102			 
0102			 
0102			; TODO store port id for spi device ie dev c 
0102			; TODO store pin for SO 
0102			; TODO store pin for SI 
0102			; TODO store pin for SCLK 
0102			 
0102			; 
0102			 
0102			; ensure that spi bus is in a stable state with default pins  
0102			 
0102			se_stable_spi:   
0102			 
0102				 ; set DI high, CE high , SCLK low 
0102				;ld a, SPI_DI | SPI_CE0 
0102 3e 07			ld a, SPI_DI  
0104 cd 0e 02			call spi_ce_high 
0107 d3 80			 out (storage_adata),a 
0109 32 9c f9			ld (spi_portbyte),a 
010c			 
010c				if DEBUG_SPI 
010c					push hl 
010c					ld l, a 
010c					DMARK "SPI" 
010c					CALLMONITOR 
010c					pop hl 
010c				endif 
010c c9				ret 
010d			 
010d			; byte to send in a 
010d			 
010d			spi_send_byte: 
010d				; save byte to send for bit mask shift out 
010d 4f			        ld c,a 
010e 3a 9c f9			ld a,(spi_portbyte) 
0111				  
0111				; clock out	each bit of the byte msb first 
0111			 
0111 06 08			ld b, 8 
0113			.ssb1: 
0113				; clear so bit  
0113 cb bf			res SPI_DI, a 
0115 cb 11			rl c 
0117				; if bit 7 is set then carry is set 
0117 30 02			jr nc, .ssb2 
0119 cb ff			set SPI_DI,a 
011b			.ssb2:  ; output bit to ensure it is stable 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e				; clock bit high 
011e cb ef			set SPI_SCLK,a 
0120 d3 80			out (storage_adata),a 
0122 00				nop 
0123 cd f5 00			call spi_clk 
0126				; then low 
0126 cb af			res SPI_SCLK,a 
0128 d3 80			out (storage_adata),a 
012a 00				nop 
012b cd f5 00			call spi_clk 
012e 10 e3			djnz .ssb1 
0130			 
0130 32 9c f9			ld (spi_portbyte),a 
0133 c9				ret 
0134			 
0134			; TODO low level get byte into A on spi 
0134			 
0134			spi_read_byte:  
0134			 
0134				; save byte to send for bit mask shift out 
0134 0e 00		    ld c,0 
0136 3a 9c f9			ld a,(spi_portbyte) 
0139				  
0139				; clock out	each bit of the byte msb first 
0139			 
0139			 
0139				; clock bit high 
0139 cb ef			set SPI_SCLK,a 
013b d3 80			out (storage_adata),a 
013d 00				nop 
013e cd f5 00			call spi_clk 
0141			 
0141			    ; read DO  
0141			 
0141 cb f9		    set 7,c 
0143 db 80			in a,(storage_adata) 
0145 cb 77		    bit SPI_DO,a 
0147 20 02		    jr nz, .b7 
0149 cb b9		    res 7,c 
014b			.b7: 
014b				; then low 
014b cb af			res SPI_SCLK,a 
014d d3 80			out (storage_adata),a 
014f 00				nop 
0150 cd f5 00			call spi_clk 
0153			     
0153			 
0153				; clock bit high 
0153 cb ef			set SPI_SCLK,a 
0155 d3 80			out (storage_adata),a 
0157 00				nop 
0158 cd f5 00			call spi_clk 
015b			 
015b			    ; read DO  
015b			 
015b cb f1		    set 6,c 
015d db 80			in a,(storage_adata) 
015f cb 77		    bit SPI_DO,a 
0161 20 02		    jr nz, .b6 
0163 cb b1		    res 6,c 
0165			.b6: 
0165				; then low 
0165 cb af			res SPI_SCLK,a 
0167 d3 80			out (storage_adata),a 
0169 00				nop 
016a cd f5 00			call spi_clk 
016d			 
016d				; clock bit high 
016d cb ef			set SPI_SCLK,a 
016f d3 80			out (storage_adata),a 
0171 00				nop 
0172 cd f5 00			call spi_clk 
0175			 
0175			 
0175			    ; read DO  
0175			 
0175 cb e9		    set 5,c 
0177 db 80			in a,(storage_adata) 
0179 cb 77		    bit SPI_DO,a 
017b 20 02		    jr nz, .b5 
017d cb a9		    res 5,c 
017f			.b5: 
017f				; then low 
017f cb af			res SPI_SCLK,a 
0181 d3 80			out (storage_adata),a 
0183 00				nop 
0184 cd f5 00			call spi_clk 
0187				; clock bit high 
0187 cb ef			set SPI_SCLK,a 
0189 d3 80			out (storage_adata),a 
018b 00				nop 
018c cd f5 00			call spi_clk 
018f			 
018f			    ; read DO  
018f			 
018f cb e1		    set 4,c 
0191 db 80			in a,(storage_adata) 
0193 cb 77		    bit SPI_DO,a 
0195 20 02		    jr nz, .b4 
0197 cb a1		    res 4,c 
0199			.b4: 
0199				; then low 
0199 cb af			res SPI_SCLK,a 
019b d3 80			out (storage_adata),a 
019d 00				nop 
019e cd f5 00			call spi_clk 
01a1				; clock bit high 
01a1 cb ef			set SPI_SCLK,a 
01a3 d3 80			out (storage_adata),a 
01a5 00				nop 
01a6 cd f5 00			call spi_clk 
01a9			 
01a9			    ; read DO  
01a9			 
01a9 cb d9		    set 3,c 
01ab db 80			in a,(storage_adata) 
01ad cb 77		    bit SPI_DO,a 
01af 20 02		    jr nz, .b3 
01b1 cb 99		    res 3,c 
01b3			.b3: 
01b3				; then low 
01b3 cb af			res SPI_SCLK,a 
01b5 d3 80			out (storage_adata),a 
01b7 00				nop 
01b8 cd f5 00			call spi_clk 
01bb				; clock bit high 
01bb cb ef			set SPI_SCLK,a 
01bd d3 80			out (storage_adata),a 
01bf 00				nop 
01c0 cd f5 00			call spi_clk 
01c3			 
01c3			    ; read DO  
01c3			 
01c3 cb d1		    set 2,c 
01c5 db 80			in a,(storage_adata) 
01c7 cb 77		    bit SPI_DO,a 
01c9 20 02		    jr nz, .b2 
01cb cb 91		    res 2,c 
01cd			.b2: 
01cd				; then low 
01cd cb af			res SPI_SCLK,a 
01cf d3 80			out (storage_adata),a 
01d1 00				nop 
01d2 cd f5 00			call spi_clk 
01d5				; clock bit high 
01d5 cb ef			set SPI_SCLK,a 
01d7 d3 80			out (storage_adata),a 
01d9 00				nop 
01da cd f5 00			call spi_clk 
01dd			 
01dd			    ; read DO  
01dd			 
01dd cb c9		    set 1,c 
01df db 80			in a,(storage_adata) 
01e1 cb 77		    bit SPI_DO,a 
01e3 20 02		    jr nz, .b1 
01e5 cb 89		    res 1,c 
01e7			.b1: 
01e7				; then low 
01e7 cb af			res SPI_SCLK,a 
01e9 d3 80			out (storage_adata),a 
01eb 00				nop 
01ec cd f5 00			call spi_clk 
01ef				; clock bit high 
01ef cb ef			set SPI_SCLK,a 
01f1 d3 80			out (storage_adata),a 
01f3 00				nop 
01f4 cd f5 00			call spi_clk 
01f7			 
01f7			    ; read DO  
01f7			 
01f7 cb c1		    set 0,c 
01f9 db 80			in a,(storage_adata) 
01fb cb 77		    bit SPI_DO,a 
01fd 20 02		    jr nz, .b0 
01ff cb 81		    res 0,c 
0201			.b0: 
0201				; then low 
0201 cb af			res SPI_SCLK,a 
0203 d3 80			out (storage_adata),a 
0205 00				nop 
0206 cd f5 00			call spi_clk 
0209			 
0209			 
0209 32 9c f9			ld (spi_portbyte),a 
020c			 
020c			    ; return byte 
020c 79			    ld a,c 
020d			 
020d			 
020d c9				ret 
020e			 
020e			 
020e			 
020e			spi_ce_high: 
020e			 
020e				if DEBUG_SPI_HARD_CE0 
020e			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
020e					ret 
020e			 
020e				endif 
020e			 
020e			 
020e f5				push af 
020f			 
020f				; send direct ce to port b 
020f 3e ff			ld a, 255 
0211 d3 81			out (storage_bdata), a 
0213			 
0213 f1				pop af 
0214			 
0214				; for port a that shares with spi lines AND the mask 
0214			  
0214				if DEBUG_SPI 
0214					push hl 
0214					ld h, a 
0214				endif 
0214			;	ld c, SPI_CE_HIGH 
0214			;	and c 
0214 cb c7			set SPI_CE0, a 
0216 cb cf			set SPI_CE1, a 
0218 cb d7			set SPI_CE2, a 
021a cb df			set SPI_CE3, a 
021c cb e7			set SPI_CE4, a 
021e			 
021e				if DEBUG_SPI 
021e					ld l, a 
021e					DMARK "CEh" 
021e					CALLMONITOR 
021e					pop hl 
021e				endif 
021e c9				ret 
021f			 
021f			 
021f			spi_ce_low: 
021f			 
021f				if DEBUG_SPI_HARD_CE0 
021f			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
021f					ret 
021f			 
021f				endif 
021f			 
021f c5				push bc 
0220 f5				push af 
0221			 
0221				; send direct ce to port b 
0221 3a 9e f9			ld a, (spi_cartdev) 
0224 d3 81			out (storage_bdata), a 
0226			 
0226			 
0226			 
0226				; for port a that shares with spi lines AND the mask 
0226			 
0226 3a 9b f9			ld a, (spi_device)  
0229 4f				ld c, a 
022a			 
022a f1				pop af 
022b			 
022b				; detect CEx 
022b			 
022b				if DEBUG_SPI 
022b					push hl 
022b					ld h, a 
022b				endif 
022b			 
022b cb 41			bit SPI_CE0, c 
022d 20 04			jr nz, .cel1 
022f cb 87			res SPI_CE0, a 
0231 18 1e			jr .celn 
0233			.cel1: 
0233 cb 49			bit SPI_CE1, c 
0235 20 04			jr nz, .cel2 
0237 cb 8f			res SPI_CE1, a 
0239 18 16			jr .celn 
023b			.cel2: 
023b cb 51			bit SPI_CE2, c 
023d 20 04			jr nz, .cel3 
023f cb 97			res SPI_CE2, a 
0241 18 0e			jr .celn 
0243			.cel3: 
0243 cb 59			bit SPI_CE3, c 
0245 20 04			jr nz, .cel4 
0247 cb 9f			res SPI_CE3, a 
0249 18 06			jr .celn 
024b			.cel4: 
024b cb 61			bit SPI_CE4, c 
024d 20 02			jr nz, .celn 
024f cb a7			res SPI_CE4, a 
0251			.celn: 
0251			 
0251			 
0251			 
0251			;	add c 
0251			 
0251				if DEBUG_SPI 
0251					ld l, a 
0251					DMARK "CEl" 
0251					CALLMONITOR 
0251					pop hl 
0251				endif 
0251 c1				pop bc 
0252 c9				ret 
0253			 
0253			 
0253			 
0253			; eof 
0253			 
0253			 
0253			 
0253			 
0253			 
# End of file firmware_spi.asm
0253				include "firmware_seeprom.asm"  
0253			; 
0253			; persisent storage interface via microchip serial eeprom 
0253			 
0253			; port a pio 2 
0253			; pa 7 - si 
0253			; pa 6 - sclk  
0253			; pa 5 - so 
0253			; pa 4 - cs 
0253			; pa 3 - cs 
0253			; pa 2 - cs 
0253			; pa 1 - cs 
0253			; pa 0 - cs 
0253			; 
0253			; TODO get block 
0253			; TODO save block 
0253			; TODO load file 
0253			; TODO save file 
0253			; TODO get dir  
0253			 
0253			;  
0253			storage_adata: equ Device_C    ; device c port a - onboard storage 
0253			storage_actl: equ Device_C+2     ; device c port a 
0253			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0253			storage_bctl: equ Device_C+3     ; device c port b 
0253			 
0253			 
0253			; TODO move these to hardware driver file 
0253			 
0253			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0253			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0253			; storage bank file system format 
0253			; 
0253			; first page of bank: 
0253			; 	addr 0 - status check 
0253			;       addr 1 - write protect flag 
0253			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0253			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0253			;         TODO see if scanning whole of for available next file id is fast enough 
0253			;	addr 4 > zero term string of bank label 
0253			; 
0253			;        
0253			;  
0253			; first page of any file: 
0253			;      byte 0 - file id  
0253			;      byte 1-17 - fixed file name  
0253			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0253			; 
0253			; other pages of any file: 
0253			;      byte 0 - file id 
0253			;      byte 1> - file data 
0253			; 
0253			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0253			;  
0253			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0253			 
0253			 
0253			;storage_so_bit: 5 
0253			;storage_si_bit: 7 
0253			;storage_sclk_bit: 6 
0253			  
0253			 
0253			; init storage pio 
0253			 
0253			storage_init: 
0253			 
0253			 
0253					; set default SPI clk pulse time as disabled 
0253			 
0253 3e 00				ld a, 0 
0255 32 9f f9				ld (spi_clktime), a 
0258			 
0258					; init hardware 
0258			 
0258 3e cf		            LD   A, 11001111b 
025a d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
025c 3e 00		            LD   A, 00000000b 
025e cb f7			set SPI_DO,a 
0260			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0260 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0262			 
0262 3e cf		            LD   A, 11001111b 
0264 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0266 3e 00		            LD   A, 00000000b 
0268 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
026a			 
026a				; set all external spi devices off  
026a 3e ff			ld a, 255 
026c 32 9b f9			ld (spi_device), a 
026f 32 9e f9			ld (spi_cartdev), a 
0272			 
0272					; ensure the spi bus is in a default stable state 
0272 cd 02 01				call se_stable_spi 
0275			 
0275			; TODO scan spi bus and gather which storage banks are present 
0275			 
0275			; populate store_bank_active  
0275			; for each ce line activate and attempt to write first byte of bank and read back 
0275			; if zero is returned then bank is empty 
0275			;   
0275			; 
0275			 
0275					; init file extent cache to save on slow reads 
0275			 
0275			;	ld hl, store_filecache 
0275			;	ld de, 0 
0275			;	ld hl,(de)	 
0275			 
0275			 
0275 c9			    ret 
0276			 
0276			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0276			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0276			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0276			 
0276			; INSTRUCTION SET 
0276			; READ 0000 0011 Read data from memory array beginning at selected address 
0276			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0276			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0276			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0276			; RDSR 0000 0101 Read STATUS register 
0276			; WRSR 0000 0001 Write STATUS register 
0276			; PE 0100 0010 Page Erase – erase one page in memory array 
0276			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0276			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0276			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0276			 
0276			; TODO send byte steam for page without setting the address for every single byte 
0276			; TODO read byte  
0276			 
0276			; byte in a 
0276			; address in hl  
0276			se_writebyte: 
0276			        
0276			    ;   ld c, a 
0276 f5			        push af 
0277 e5			        push hl 
0278			 
0278			    ; initi write mode 
0278			    ; 
0278			    ;CS low 
0278			 
0278 3a 9c f9		       ld a,(spi_portbyte) 
027b cd 1f 02			call spi_ce_low 
027e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
027e d3 80		       out (storage_adata),a 
0280 32 9c f9		       ld (spi_portbyte), a 
0283			 
0283			    ;clock out wren instruction 
0283			 
0283 3e 06		    ld a, store_wren_ins 
0285 cd 0d 01		    call spi_send_byte  
0288			 
0288			    ;cs high to enable write latch 
0288			 
0288 3a 9c f9		       ld a,(spi_portbyte) 
028b cd 0e 02			call spi_ce_high 
028e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
028e d3 80		       out (storage_adata),a 
0290 32 9c f9		       ld (spi_portbyte), a 
0293			 
0293 00				nop 
0294			    ; 
0294			    ; intial write data 
0294			    ; 
0294			    ; cs low 
0294			     
0294 3a 9c f9		       ld a,(spi_portbyte) 
0297 cd 1f 02			call spi_ce_low 
029a			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
029a d3 80		       out (storage_adata),a 
029c 32 9c f9		       ld (spi_portbyte), a 
029f			 
029f			    ; clock out write instruction 
029f			     
029f 3e 02		    ld a, store_write_ins  
02a1 cd 0d 01		    call spi_send_byte  
02a4			 
02a4			    ; clock out address (depending on address size) 
02a4			     
02a4 e1			    pop hl 
02a5 7c			    ld a,h    ; address out msb first 
02a6 cd 0d 01		    call spi_send_byte  
02a9 7d			    ld a,l 
02aa cd 0d 01		    call spi_send_byte  
02ad			 
02ad			    ; clock out byte(s) for page 
02ad			 
02ad f1			    pop af 
02ae cd 0d 01		    call spi_send_byte  
02b1			 
02b1			    ; end write with ce high 
02b1 3a 9c f9		       ld a,(spi_portbyte) 
02b4			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b4 cd 0e 02			call spi_ce_high 
02b7 d3 80		       out (storage_adata),a 
02b9 32 9c f9		       ld (spi_portbyte), a 
02bc			 
02bc				; pause for internal write cycle 
02bc 3e 0a			ld a, 10 
02be cd cf 0c			call aDelayInMS 
02c1 c9			    ret 
02c2			 
02c2			; buffer to write in de 
02c2			; address in hl  
02c2			se_writepage: 
02c2			        
02c2			    ;   ld c, a 
02c2 d5				push de 
02c3 e5			        push hl 
02c4			 
02c4			    ; initi write mode 
02c4			    ; 
02c4			    ;CS low 
02c4			 
02c4 3a 9c f9		       ld a,(spi_portbyte) 
02c7 cd 1f 02			call spi_ce_low 
02ca			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02ca d3 80		       out (storage_adata),a 
02cc 32 9c f9		       ld (spi_portbyte), a 
02cf			 
02cf			    ;clock out wren instruction 
02cf			 
02cf 3e 06		    ld a, store_wren_ins 
02d1 cd 0d 01		    call spi_send_byte  
02d4			 
02d4			    ;cs high to enable write latch 
02d4			 
02d4 3a 9c f9		       ld a,(spi_portbyte) 
02d7 cd 0e 02			call spi_ce_high 
02da			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02da d3 80		       out (storage_adata),a 
02dc 32 9c f9		       ld (spi_portbyte), a 
02df			 
02df 00				nop 
02e0			    ; 
02e0			    ; intial write data 
02e0			    ; 
02e0			    ; cs low 
02e0			     
02e0 3a 9c f9		       ld a,(spi_portbyte) 
02e3			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02e3 cd 1f 02			call spi_ce_low 
02e6 d3 80		       out (storage_adata),a 
02e8 32 9c f9		       ld (spi_portbyte), a 
02eb			 
02eb			    ; clock out write instruction 
02eb			     
02eb 3e 02		    ld a, store_write_ins  
02ed cd 0d 01		    call spi_send_byte  
02f0			 
02f0			    ; clock out address (depending on address size) 
02f0			     
02f0 e1			    pop hl 
02f1 7c			    ld a,h    ; address out msb first 
02f2 cd 0d 01		    call spi_send_byte  
02f5 7d			    ld a,l 
02f6 cd 0d 01		    call spi_send_byte  
02f9			 
02f9			    ; clock out byte(s) for page 
02f9			 
02f9 e1				pop hl 
02fa 06 40			ld b, STORE_BLOCK_PHY 
02fc			.bytewrite: 
02fc			 
02fc 7e				ld a,(hl) 
02fd e5			    push hl 
02fe c5				push bc 
02ff cd 0d 01		    call spi_send_byte  
0302 c1				pop bc 
0303 e1				pop hl 
0304			 
0304			    ; end write with ce high 
0304 3a 9c f9		       ld a,(spi_portbyte) 
0307 cd 0e 02			call spi_ce_high 
030a			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
030a d3 80		       out (storage_adata),a 
030c 32 9c f9		       ld (spi_portbyte), a 
030f			 
030f 23				inc hl 
0310 10 ea			djnz .bytewrite 
0312			 
0312				; pause for internal write cycle 
0312 3e 64			ld a, 100 
0314 cd cf 0c			call aDelayInMS 
0317 c9			    ret 
0318			; returns byte in a 
0318			; address in hl  
0318			se_readbyte: 
0318 d5				push de 
0319 c5				push bc 
031a			 
031a			    ;   ld c, a 
031a e5			        push hl 
031b			 
031b			    ; initi write mode 
031b			    ; 
031b			    ;CS low 
031b			 
031b 3a 9c f9		       ld a,(spi_portbyte) 
031e cd 1f 02			call spi_ce_low 
0321			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0321 d3 80		       out (storage_adata),a 
0323 32 9c f9		       ld (spi_portbyte), a 
0326			 
0326			    ;clock out wren instruction 
0326			 
0326 3e 03		    ld a, store_read_ins 
0328 cd 0d 01		    call spi_send_byte  
032b			 
032b			 
032b			    ; clock out address (depending on address size) 
032b			     
032b e1			    pop hl 
032c 7c			    ld a,h    ; address out msb first 
032d cd 0d 01		    call spi_send_byte  
0330 7d			    ld a,l 
0331 cd 0d 01		    call spi_send_byte  
0334			 
0334			    ; clock in byte(s) for page 
0334			 
0334 cd 34 01		    call spi_read_byte  
0337 f5				push af 
0338			 
0338			    ; end write with ce high 
0338 3a 9c f9		       ld a,(spi_portbyte) 
033b			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
033b cd 0e 02			call spi_ce_high 
033e d3 80		       out (storage_adata),a 
0340 32 9c f9		       ld (spi_portbyte), a 
0343			 
0343 f1				pop af 
0344			 
0344 c1				pop bc 
0345 d1				pop de 
0346			 
0346 c9			    ret 
0347			 
0347			if DEBUG_STORESE 
0347			 
0347			storageput:  
0347			 
0347			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
0347			 
0347 21 fe f0			ld hl,scratch+2 
034a cd 9a 12			call get_word_hl 
034d			 
034d				; stuff it here for the moment as it will be overwritten later anyway 
034d			 
034d 22 1f f4			ld (os_cur_ptr),hl	 
0350			 
0350			 
0350			; get pointer to start of string 
0350			 
0350 21 03 f1			ld hl, scratch+7 
0353			 
0353			; loop writing char of string to eeprom 
0353			 
0353 7e			.writestr:	ld a,(hl) 
0354 fe 00				cp 0 
0356 28 12				jr z, .wsdone		; done writing 
0358 e5					push hl 
0359 2a 1f f4				ld hl,(os_cur_ptr) 
035c cd 76 02				call se_writebyte 
035f			 
035f 2a 1f f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0362 23					inc hl 
0363 22 1f f4				ld (os_cur_ptr),hl 
0366			 
0366					; restore string pointer and get next char 
0366			 
0366 e1					pop hl 
0367 23					inc hl 
0368 18 e9				jr .writestr 
036a			 
036a			 
036a			 
036a			.wsdone: 
036a			 
036a			 
036a			; when done load first page into a buffer  
036a			 
036a 21 00 80				ld hl,08000h		; start in ram 
036d 22 1f f4				ld (os_cur_ptr),hl 
0370 21 00 00				ld hl, 0		 ; start of page 
0373 22 24 f1				ld (scratch+40),hl	; hang on to it 
0376			 
0376 06 80				ld b, 128		; actually get more then one page 
0378 c5			.wsload:	push bc 
0379 2a 24 f1				ld hl,(scratch+40) 
037c e5					push hl 
037d cd 18 03				call se_readbyte 
0380			 
0380					; a now as the byte 
0380			 
0380 2a 1f f4				ld hl,(os_cur_ptr) 
0383 77					ld (hl),a 
0384					; inc next buffer area 
0384 23					inc hl 
0385 22 1f f4				ld (os_cur_ptr),hl 
0388			 
0388					; get eeprom position, inc and save for next round 
0388 e1					pop hl		 
0389 23					inc hl 
038a 22 24 f1				ld (scratch+40),hl 
038d c1					pop bc 
038e 10 e8				djnz .wsload 
0390			 
0390			; set 'd' pointer to start of buffer 
0390			 
0390 21 00 80				ld hl,08000h 
0393 22 1f f4				ld (os_cur_ptr),hl 
0396			 
0396			 
0396 c9			ret 
0397			 
0397			 
0397 c9			storageread: ret 
0398			 
0398			 
0398			 
0398			 
0398			 
0398			 
0398			endif 
0398			 
0398			 
0398			 
# End of file firmware_seeprom.asm
0398			else  
0398			   ; create some stubs for the labels  
0398			se_readbyte: ret  
0398			se_writebyte: ret  
0398			storage_init: ret  
0398			  
0398			endif  
0398			  
0398			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0398			;include "firmware_cf.asm"  
0398			  
0398			; load up high level storage hardward abstractions  
0398			include "firmware_storage.asm"  
0398			 
0398			; persisent storage hardware abstraction layer  
0398			 
0398			 
0398			 
0398			; Block 0 on storage is a config state 
0398			 
0398			 
0398			 
0398			; TODO add read phy block and write phy block functions 
0398			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0398			 
0398			; Abstraction layer  
0398			 
0398			; Logocial block size is same size as physical size - using tape concept 
0398			 
0398			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0398			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0398			 
0398			 
0398			 
0398			; Filesystem layout (Logical layout) 
0398			; 
0398			; Block 0 - Bank config  
0398			; 
0398			;      Byte - 0 file id counter 
0398			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0398			;      Byte - 3-20 zero terminated bank label 
0398			; 
0398			; Block 1 > File storage 
0398			; 
0398			;      Byte 0 file id    - block 0 file details 
0398			;      Byte 1 block id - block 0 is file  
0398			;            Byte 2-15 - File name 
0398			; 
0398			;       - to end of block data 
0398			; 
0398			 
0398			; Get ID for the file named in pointer held HL 
0398			; Returns ID in HL = 255 if no file found 
0398			 
0398			storage_getid: 
0398			 
0398 22 ae f9			ld (store_tmp1), hl 
039b			 
039b				if DEBUG_STORESE 
039b					DMARK "SGI" 
039b f5				push af  
039c 3a b0 03			ld a, (.dmark)  
039f 32 a6 fd			ld (debug_mark),a  
03a2 3a b1 03			ld a, (.dmark+1)  
03a5 32 a7 fd			ld (debug_mark+1),a  
03a8 3a b2 03			ld a, (.dmark+2)  
03ab 32 a8 fd			ld (debug_mark+2),a  
03ae 18 03			jr .pastdmark  
03b0 ..			.dmark: db "SGI"  
03b3 f1			.pastdmark: pop af  
03b4			endm  
# End of macro DMARK
03b4					CALLMONITOR 
03b4 cd aa fd			call debug_vector  
03b7				endm  
# End of macro CALLMONITOR
03b7				endif 
03b7				; get block 0 and set counter for number of files to scan 
03b7			 
03b7 cd 22 05			call storage_get_block_0 
03ba			 
03ba 3a b5 f9			ld a, (store_page) 
03bd 47				ld b, a 
03be			 
03be				; get extent 0 of each file id 
03be			 
03be				if DEBUG_STORESE 
03be					DMARK "SGc" 
03be f5				push af  
03bf 3a d3 03			ld a, (.dmark)  
03c2 32 a6 fd			ld (debug_mark),a  
03c5 3a d4 03			ld a, (.dmark+1)  
03c8 32 a7 fd			ld (debug_mark+1),a  
03cb 3a d5 03			ld a, (.dmark+2)  
03ce 32 a8 fd			ld (debug_mark+2),a  
03d1 18 03			jr .pastdmark  
03d3 ..			.dmark: db "SGc"  
03d6 f1			.pastdmark: pop af  
03d7			endm  
# End of macro DMARK
03d7					CALLMONITOR 
03d7 cd aa fd			call debug_vector  
03da				endm  
# End of macro CALLMONITOR
03da				endif 
03da 60			.getloop:	ld h, b 
03db 2e 00				ld l, 0 
03dd c5					push bc 
03de			 
03de 11 b5 f9				ld de, store_page 
03e1				if DEBUG_STORESE 
03e1					DMARK "SGr" 
03e1 f5				push af  
03e2 3a f6 03			ld a, (.dmark)  
03e5 32 a6 fd			ld (debug_mark),a  
03e8 3a f7 03			ld a, (.dmark+1)  
03eb 32 a7 fd			ld (debug_mark+1),a  
03ee 3a f8 03			ld a, (.dmark+2)  
03f1 32 a8 fd			ld (debug_mark+2),a  
03f4 18 03			jr .pastdmark  
03f6 ..			.dmark: db "SGr"  
03f9 f1			.pastdmark: pop af  
03fa			endm  
# End of macro DMARK
03fa					CALLMONITOR 
03fa cd aa fd			call debug_vector  
03fd				endm  
# End of macro CALLMONITOR
03fd				endif 
03fd cd ca 09				call storage_read 
0400 cd 04 10				call ishlzero 
0403 28 2d				jr z, .gap 
0405					 
0405					; have a file name read. Is it one we want. 
0405			 
0405 2a ae f9				ld hl, (store_tmp1) 
0408 11 b8 f9				ld de, store_page+3   ; file name 
040b			 
040b				if DEBUG_STORESE 
040b					DMARK "SGc" 
040b f5				push af  
040c 3a 20 04			ld a, (.dmark)  
040f 32 a6 fd			ld (debug_mark),a  
0412 3a 21 04			ld a, (.dmark+1)  
0415 32 a7 fd			ld (debug_mark+1),a  
0418 3a 22 04			ld a, (.dmark+2)  
041b 32 a8 fd			ld (debug_mark+2),a  
041e 18 03			jr .pastdmark  
0420 ..			.dmark: db "SGc"  
0423 f1			.pastdmark: pop af  
0424			endm  
# End of macro DMARK
0424					CALLMONITOR 
0424 cd aa fd			call debug_vector  
0427				endm  
# End of macro CALLMONITOR
0427				endif 
0427 cd 79 13				call strcmp 
042a 20 06				jr nz, .gap   ; not this one 
042c			 
042c c1				        pop bc 
042d			 
042d 26 00				ld h, 0 
042f 68					ld l, b 
0430 18 22				jr .getdone 
0432						 
0432			 
0432			 
0432			 
0432			.gap: 
0432				if DEBUG_STORESE 
0432					DMARK "SGg" 
0432 f5				push af  
0433 3a 47 04			ld a, (.dmark)  
0436 32 a6 fd			ld (debug_mark),a  
0439 3a 48 04			ld a, (.dmark+1)  
043c 32 a7 fd			ld (debug_mark+1),a  
043f 3a 49 04			ld a, (.dmark+2)  
0442 32 a8 fd			ld (debug_mark+2),a  
0445 18 03			jr .pastdmark  
0447 ..			.dmark: db "SGg"  
044a f1			.pastdmark: pop af  
044b			endm  
# End of macro DMARK
044b					CALLMONITOR 
044b cd aa fd			call debug_vector  
044e				endm  
# End of macro CALLMONITOR
044e				endif 
044e			 
044e c1					pop bc 
044f 10 89				djnz .getloop 
0451 21 ff 00				ld hl, 255 
0454			.getdone: 
0454			 
0454				if DEBUG_STORESE 
0454					DMARK "SGe" 
0454 f5				push af  
0455 3a 69 04			ld a, (.dmark)  
0458 32 a6 fd			ld (debug_mark),a  
045b 3a 6a 04			ld a, (.dmark+1)  
045e 32 a7 fd			ld (debug_mark+1),a  
0461 3a 6b 04			ld a, (.dmark+2)  
0464 32 a8 fd			ld (debug_mark+2),a  
0467 18 03			jr .pastdmark  
0469 ..			.dmark: db "SGe"  
046c f1			.pastdmark: pop af  
046d			endm  
# End of macro DMARK
046d					CALLMONITOR 
046d cd aa fd			call debug_vector  
0470				endm  
# End of macro CALLMONITOR
0470				endif 
0470			 
0470 c9				ret 
0471			 
0471			 
0471			 
0471			 
0471			 
0471			 
0471			 
0471			 
0471			; Read Block 
0471			; ---------- 
0471			; 
0471			; With current bank 
0471			;  
0471			; Get block number to read 
0471			; Load physical blocks starting at start block into buffer 
0471			 
0471			; de points to buffer to use 
0471			; hl holds logical block number  
0471			 
0471			storage_read_block: 
0471			 
0471				; TODO bank selection 
0471			 
0471				; for each of the physical blocks read it into the buffer 
0471 06 40			ld b, STORE_BLOCK_PHY 
0473			 
0473				if DEBUG_STORESE 
0473 d5					push de 
0474				endif 
0474				 
0474			.rl1:    
0474			 
0474				; read physical block at hl into de 
0474			        ; increment hl and de to next read position on exit 
0474			 
0474 e5				push hl 
0475 d5				push de	 
0476 c5				push bc 
0477			;	if DEBUG_STORESE 
0477			;		push af 
0477			;		ld a, 'R' 
0477			;		ld (debug_mark),a 
0477			;		pop af 
0477			;		CALLMONITOR 
0477			;	endif 
0477 cd 18 03			call se_readbyte 
047a			;	if DEBUG_STORESE 
047a			;		ld a,(spi_portbyte) 
047a			;		ld l, a 
047a			;		push af 
047a			;		ld a, '1' 
047a			;		ld (debug_mark),a 
047a			;		pop af 
047a			;		CALLMONITOR 
047a			;	endif 
047a c1				pop bc 
047b d1				pop de 
047c e1				pop hl 
047d 12				ld (de),a 
047e 23				inc hl 
047f 13				inc de 
0480			 
0480			;	if DEBUG_STORESE 
0480			;		push af 
0480			;		ld a, 'r' 
0480			;		ld (debug_mark),a 
0480			;		pop af 
0480			;		CALLMONITOR 
0480			;	endif 
0480			 
0480 10 f2			djnz .rl1 
0482			 
0482				if DEBUG_STORESE 
0482					DMARK "SRB" 
0482 f5				push af  
0483 3a 97 04			ld a, (.dmark)  
0486 32 a6 fd			ld (debug_mark),a  
0489 3a 98 04			ld a, (.dmark+1)  
048c 32 a7 fd			ld (debug_mark+1),a  
048f 3a 99 04			ld a, (.dmark+2)  
0492 32 a8 fd			ld (debug_mark+2),a  
0495 18 03			jr .pastdmark  
0497 ..			.dmark: db "SRB"  
049a f1			.pastdmark: pop af  
049b			endm  
# End of macro DMARK
049b d1					pop de 
049c			; 
049c			;		push af 
049c			;		ld a, 'R' 
049c			;		ld (debug_mark),a 
049c			;		pop af 
049c					CALLMONITOR 
049c cd aa fd			call debug_vector  
049f				endm  
# End of macro CALLMONITOR
049f				endif 
049f c9				ret	 
04a0				 
04a0			 
04a0			; File Size 
04a0			; --------- 
04a0			; 
04a0			;   hl file id 
04a0			; 
04a0			;  returns in hl the number of blocks 
04a0			 
04a0			storage_file_size: 
04a0 5d				ld e, l 
04a1 16 00			ld d, 0 
04a3 21 40 00			ld hl, STORE_BLOCK_PHY 
04a6					if DEBUG_FORTH_WORDS 
04a6						DMARK "SIZ" 
04a6 f5				push af  
04a7 3a bb 04			ld a, (.dmark)  
04aa 32 a6 fd			ld (debug_mark),a  
04ad 3a bc 04			ld a, (.dmark+1)  
04b0 32 a7 fd			ld (debug_mark+1),a  
04b3 3a bd 04			ld a, (.dmark+2)  
04b6 32 a8 fd			ld (debug_mark+2),a  
04b9 18 03			jr .pastdmark  
04bb ..			.dmark: db "SIZ"  
04be f1			.pastdmark: pop af  
04bf			endm  
# End of macro DMARK
04bf						CALLMONITOR 
04bf cd aa fd			call debug_vector  
04c2				endm  
# End of macro CALLMONITOR
04c2					endif 
04c2 cd a4 07			call storage_findnextid 
04c5			 
04c5 cd 04 10			call ishlzero 
04c8			;	ld a, l 
04c8			;	add h 
04c8			;	cp 0 
04c8 c8				ret z			; block not found so EOF 
04c9			 
04c9 11 b5 f9			ld de, store_page 
04cc cd 71 04			call storage_read_block 
04cf			 
04cf 3a b7 f9			ld a, (store_page+2)	 ; get extent count 
04d2 6f				ld l, a 
04d3 26 00			ld h, 0 
04d5 c9			 	ret 
04d6			 
04d6			 
04d6			; Write Block 
04d6			; ----------- 
04d6			; 
04d6			; With current bank 
04d6			;  
04d6			; Get block number to write 
04d6			; Write physical blocks starting at start block from buffer 
04d6			  
04d6			storage_write_block: 
04d6				; TODO bank selection 
04d6			 
04d6				; for each of the physical blocks read it into the buffer 
04d6 06 40			ld b, STORE_BLOCK_PHY 
04d8			 
04d8				if DEBUG_STORESE 
04d8					DMARK "SWB" 
04d8 f5				push af  
04d9 3a ed 04			ld a, (.dmark)  
04dc 32 a6 fd			ld (debug_mark),a  
04df 3a ee 04			ld a, (.dmark+1)  
04e2 32 a7 fd			ld (debug_mark+1),a  
04e5 3a ef 04			ld a, (.dmark+2)  
04e8 32 a8 fd			ld (debug_mark+2),a  
04eb 18 03			jr .pastdmark  
04ed ..			.dmark: db "SWB"  
04f0 f1			.pastdmark: pop af  
04f1			endm  
# End of macro DMARK
04f1			 
04f1					;push af 
04f1					;ld a, 'W' 
04f1					;ld (debug_mark),a 
04f1					;pop af 
04f1					CALLMONITOR 
04f1 cd aa fd			call debug_vector  
04f4				endm  
# End of macro CALLMONITOR
04f4				endif 
04f4			 
04f4			; might not be working 
04f4			;	call se_writepage 
04f4			 
04f4			;	ret 
04f4			; 
04f4			 
04f4			 
04f4			 
04f4			.wl1:    
04f4			 
04f4				; read physical block at hl into de 
04f4			        ; increment hl and de to next read position on exit 
04f4			 
04f4 e5				push hl 
04f5 d5				push de	 
04f6 c5				push bc 
04f7 1a				ld a,(de) 
04f8				;if DEBUG_STORESE 
04f8			;		push af 
04f8			;		ld a, 'W' 
04f8			;		ld (debug_mark),a 
04f8			;		pop af 
04f8			;		CALLMONITOR 
04f8			;	endif 
04f8 cd 76 02			call se_writebyte 
04fb			;	call delay250ms 
04fb 00				nop 
04fc 00				nop 
04fd 00				nop 
04fe			;	if DEBUG_STORESE 
04fe			;		push af 
04fe			;		ld a, 'w' 
04fe			;		ld (debug_mark),a 
04fe			;		pop af 
04fe			;		CALLMONITOR 
04fe			;	endif 
04fe c1				pop bc 
04ff d1				pop de 
0500 e1				pop hl 
0501 23				inc hl 
0502 13				inc de 
0503			 
0503			 
0503 10 ef			djnz .wl1 
0505			 
0505				if DEBUG_STORESE 
0505					DMARK "SW2" 
0505 f5				push af  
0506 3a 1a 05			ld a, (.dmark)  
0509 32 a6 fd			ld (debug_mark),a  
050c 3a 1b 05			ld a, (.dmark+1)  
050f 32 a7 fd			ld (debug_mark+1),a  
0512 3a 1c 05			ld a, (.dmark+2)  
0515 32 a8 fd			ld (debug_mark+2),a  
0518 18 03			jr .pastdmark  
051a ..			.dmark: db "SW2"  
051d f1			.pastdmark: pop af  
051e			endm  
# End of macro DMARK
051e			 
051e					;push af 
051e					;ld a, 'W' 
051e					;ld (debug_mark),a 
051e					;pop af 
051e					CALLMONITOR 
051e cd aa fd			call debug_vector  
0521				endm  
# End of macro CALLMONITOR
0521				endif 
0521 c9				ret	 
0522			 
0522			; Init bank 
0522			; --------- 
0522			; 
0522			; With current bank 
0522			; 
0522			; Setup block 0 config 
0522			;     Set 0 file id counter 
0522			;     Set formatted byte pattern 
0522			;     Zero out bank label 
0522			;      
0522			; For every logical block write 0-1 byte as null 
0522			 
0522			storage_get_block_0: 
0522			 
0522				; TODO check presence 
0522			 
0522				; get block 0 config 
0522			 
0522 21 00 00			ld hl, 0 
0525 11 b5 f9			ld de, store_page 
0528 cd 71 04			call storage_read_block 
052b			 
052b				if DEBUG_STORESE 
052b					DMARK "SB0" 
052b f5				push af  
052c 3a 40 05			ld a, (.dmark)  
052f 32 a6 fd			ld (debug_mark),a  
0532 3a 41 05			ld a, (.dmark+1)  
0535 32 a7 fd			ld (debug_mark+1),a  
0538 3a 42 05			ld a, (.dmark+2)  
053b 32 a8 fd			ld (debug_mark+2),a  
053e 18 03			jr .pastdmark  
0540 ..			.dmark: db "SB0"  
0543 f1			.pastdmark: pop af  
0544			endm  
# End of macro DMARK
0544 11 b5 f9				ld de, store_page 
0547			;		push af 
0547			;		ld a, 'i' 
0547			;		ld (debug_mark),a 
0547			;		pop af 
0547					CALLMONITOR 
0547 cd aa fd			call debug_vector  
054a				endm  
# End of macro CALLMONITOR
054a				endif 
054a			 
054a				; is this area formatted? 
054a			 
054a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
054a 2a b6 f9			ld hl, (store_page+1) 
054d 3e 80			ld a,0x80 
054f bd				cp l 
0550 20 22			jr nz, .ininotformatted 
0552				; do a double check 
0552 3e 27			ld a, 0x27 
0554 bc				cp h 
0555 20 1d			jr nz, .ininotformatted 
0557			 
0557				; formatted then 
0557			 
0557				if DEBUG_STORESE 
0557					DMARK "SB1" 
0557 f5				push af  
0558 3a 6c 05			ld a, (.dmark)  
055b 32 a6 fd			ld (debug_mark),a  
055e 3a 6d 05			ld a, (.dmark+1)  
0561 32 a7 fd			ld (debug_mark+1),a  
0564 3a 6e 05			ld a, (.dmark+2)  
0567 32 a8 fd			ld (debug_mark+2),a  
056a 18 03			jr .pastdmark  
056c ..			.dmark: db "SB1"  
056f f1			.pastdmark: pop af  
0570			endm  
# End of macro DMARK
0570					;push af 
0570					;ld a, 'I' 
0570					;ld (debug_mark),a 
0570					;pop af 
0570					CALLMONITOR 
0570 cd aa fd			call debug_vector  
0573				endm  
# End of macro CALLMONITOR
0573				endif 
0573 c9				ret 
0574			 
0574			.ininotformatted: 
0574				; bank not formatted so poke various bits to make sure 
0574			 
0574				if DEBUG_STORESE 
0574					DMARK "SB2" 
0574 f5				push af  
0575 3a 89 05			ld a, (.dmark)  
0578 32 a6 fd			ld (debug_mark),a  
057b 3a 8a 05			ld a, (.dmark+1)  
057e 32 a7 fd			ld (debug_mark+1),a  
0581 3a 8b 05			ld a, (.dmark+2)  
0584 32 a8 fd			ld (debug_mark+2),a  
0587 18 03			jr .pastdmark  
0589 ..			.dmark: db "SB2"  
058c f1			.pastdmark: pop af  
058d			endm  
# End of macro DMARK
058d					;push af 
058d					;ld a, 'f' 
058d					;ld (debug_mark),a 
058d					;pop af 
058d					CALLMONITOR 
058d cd aa fd			call debug_vector  
0590				endm  
# End of macro CALLMONITOR
0590				endif 
0590			 
0590 cd ad 0c			call storage_clear_page 
0593			 
0593 21 b5 f9			ld hl, store_page 
0596 3e 00			ld a, 0 
0598				 
0598 77				ld (hl),a   ; reset file counter 
0599			 
0599 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
059c 22 b6 f9		 	ld (store_page+1), hl	 
059f			 
059f				; set default label 
059f			 
059f 21 3b 06			ld hl, .defaultbanklabl 
05a2 11 b8 f9		 	ld de, store_page+3 
05a5 01 0f 00			ld bc, 15 
05a8 ed b0			ldir 
05aa			 
05aa				; Append the current bank id 
05aa 21 c1 f9			ld hl, store_page+3+9 
05ad 3a 9a f9			ld a, (spi_device_id) 
05b0 77				ld (hl), a 
05b1			 
05b1				; save default page 0 
05b1			 
05b1 21 00 00			ld hl, 0 
05b4 11 b5 f9			ld de, store_page 
05b7				if DEBUG_STORESE 
05b7					DMARK "SB3" 
05b7 f5				push af  
05b8 3a cc 05			ld a, (.dmark)  
05bb 32 a6 fd			ld (debug_mark),a  
05be 3a cd 05			ld a, (.dmark+1)  
05c1 32 a7 fd			ld (debug_mark+1),a  
05c4 3a ce 05			ld a, (.dmark+2)  
05c7 32 a8 fd			ld (debug_mark+2),a  
05ca 18 03			jr .pastdmark  
05cc ..			.dmark: db "SB3"  
05cf f1			.pastdmark: pop af  
05d0			endm  
# End of macro DMARK
05d0			;		push af 
05d0			;		ld a, 'F' 
05d0			;		ld (debug_mark),a 
05d0			;		pop af 
05d0					CALLMONITOR 
05d0 cd aa fd			call debug_vector  
05d3				endm  
# End of macro CALLMONITOR
05d3				endif 
05d3 cd d6 04			call storage_write_block 
05d6				if DEBUG_STORESE 
05d6					DMARK "SB4" 
05d6 f5				push af  
05d7 3a eb 05			ld a, (.dmark)  
05da 32 a6 fd			ld (debug_mark),a  
05dd 3a ec 05			ld a, (.dmark+1)  
05e0 32 a7 fd			ld (debug_mark+1),a  
05e3 3a ed 05			ld a, (.dmark+2)  
05e6 32 a8 fd			ld (debug_mark+2),a  
05e9 18 03			jr .pastdmark  
05eb ..			.dmark: db "SB4"  
05ee f1			.pastdmark: pop af  
05ef			endm  
# End of macro DMARK
05ef			;		push af 
05ef			;		ld a, '>' 
05ef			;		ld (debug_mark),a 
05ef			;		pop af 
05ef					CALLMONITOR 
05ef cd aa fd			call debug_vector  
05f2				endm  
# End of macro CALLMONITOR
05f2				endif 
05f2			 
05f2 00				nop 
05f3 00				nop 
05f4 00				nop 
05f5			 
05f5				; now set 0 in every page to mark as a free block 
05f5			 
05f5 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05f7 21 40 00			ld hl, STORE_BLOCK_PHY 
05fa			 
05fa 3e 00		.setmark1:   	ld a,0 
05fc e5					push hl 
05fd c5					push bc 
05fe cd 76 02				call se_writebyte 
0601 3e 0a			ld a, 10 
0603 cd cf 0c			call aDelayInMS 
0606 23				inc hl 
0607 cd 76 02				call se_writebyte 
060a 3e 0a			ld a, 10 
060c cd cf 0c			call aDelayInMS 
060f 2b				dec hl 
0610 c1					pop bc 
0611 e1					pop hl 
0612 3e 40				ld a, STORE_BLOCK_PHY 
0614 cd db 0f				call addatohl 
0617 10 e1				djnz .setmark1 
0619			 
0619 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
061b 3e 00		.setmark2:   	ld a,0 
061d e5					push hl 
061e c5					push bc 
061f cd 76 02				call se_writebyte 
0622 3e 0a			ld a, 10 
0624 cd cf 0c			call aDelayInMS 
0627 23				inc hl 
0628 cd 76 02				call se_writebyte 
062b 3e 0a			ld a, 10 
062d cd cf 0c			call aDelayInMS 
0630 2b				dec hl 
0631 c1					pop bc 
0632 e1					pop hl 
0633 3e 40				ld a, STORE_BLOCK_PHY 
0635 cd db 0f				call addatohl 
0638 10 e1				djnz .setmark2 
063a			 
063a					 
063a			 
063a			 
063a c9				ret 
063b			 
063b			 
063b			 
063b			 
063b .. 00		.defaultbanklabl:   db "BankLabel_",0 
0646			 
0646			 
0646			 
0646			; Label Bank 
0646			; ---------- 
0646			; 
0646			; With current bank 
0646			; Read block 0 
0646			; Set label 
0646			; Write block 0 
0646			 
0646			; label str pointer in hl 
0646			 
0646			storage_label:     
0646			 
0646				if DEBUG_STORESE 
0646					DMARK "LBL" 
0646 f5				push af  
0647 3a 5b 06			ld a, (.dmark)  
064a 32 a6 fd			ld (debug_mark),a  
064d 3a 5c 06			ld a, (.dmark+1)  
0650 32 a7 fd			ld (debug_mark+1),a  
0653 3a 5d 06			ld a, (.dmark+2)  
0656 32 a8 fd			ld (debug_mark+2),a  
0659 18 03			jr .pastdmark  
065b ..			.dmark: db "LBL"  
065e f1			.pastdmark: pop af  
065f			endm  
# End of macro DMARK
065f					CALLMONITOR 
065f cd aa fd			call debug_vector  
0662				endm  
# End of macro CALLMONITOR
0662				endif 
0662			 
0662 e5				push hl 
0663			 
0663 cd 22 05			call storage_get_block_0 
0666			 
0666				; set default label 
0666			 
0666 e1				pop hl 
0667			 
0667 11 b8 f9		 	ld de, store_page+3 
066a 01 0f 00			ld bc, 15 
066d				if DEBUG_STORESE 
066d					DMARK "LB3" 
066d f5				push af  
066e 3a 82 06			ld a, (.dmark)  
0671 32 a6 fd			ld (debug_mark),a  
0674 3a 83 06			ld a, (.dmark+1)  
0677 32 a7 fd			ld (debug_mark+1),a  
067a 3a 84 06			ld a, (.dmark+2)  
067d 32 a8 fd			ld (debug_mark+2),a  
0680 18 03			jr .pastdmark  
0682 ..			.dmark: db "LB3"  
0685 f1			.pastdmark: pop af  
0686			endm  
# End of macro DMARK
0686					CALLMONITOR 
0686 cd aa fd			call debug_vector  
0689				endm  
# End of macro CALLMONITOR
0689				endif 
0689 ed b0			ldir 
068b				; save default page 0 
068b			 
068b 21 00 00			ld hl, 0 
068e 11 b5 f9			ld de, store_page 
0691				if DEBUG_STORESE 
0691					DMARK "LBW" 
0691 f5				push af  
0692 3a a6 06			ld a, (.dmark)  
0695 32 a6 fd			ld (debug_mark),a  
0698 3a a7 06			ld a, (.dmark+1)  
069b 32 a7 fd			ld (debug_mark+1),a  
069e 3a a8 06			ld a, (.dmark+2)  
06a1 32 a8 fd			ld (debug_mark+2),a  
06a4 18 03			jr .pastdmark  
06a6 ..			.dmark: db "LBW"  
06a9 f1			.pastdmark: pop af  
06aa			endm  
# End of macro DMARK
06aa					CALLMONITOR 
06aa cd aa fd			call debug_vector  
06ad				endm  
# End of macro CALLMONITOR
06ad				endif 
06ad cd d6 04			call storage_write_block 
06b0			 
06b0 c9				ret 
06b1			 
06b1			 
06b1			 
06b1			; Read Block 0 - Config 
06b1			; --------------------- 
06b1			; 
06b1			; With current bank 
06b1			; Call presence test 
06b1			;    If not present format/init bank  
06b1			; Read block 0  
06b1			;  
06b1			 
06b1			 
06b1			; Dir 
06b1			; --- 
06b1			; 
06b1			; With current bank 
06b1			; Load Block 0 Config 
06b1			; Get max file id number 
06b1			; For each logical block 
06b1			;    Read block read byte 2 
06b1			;      if first block of file 
06b1			;         Display file name 
06b1			;         Display type flags for file 
06b1			;        
06b1			 
06b1			; moving to words as this requires stack control 
06b1			 
06b1			 
06b1			; Delete File 
06b1			; ----------- 
06b1			; 
06b1			; With current bank 
06b1			; 
06b1			; Load Block 0 Config 
06b1			; Get max file id number 
06b1			; For each logical block 
06b1			;    Read block file id 
06b1			;      If first block of file and dont have file id 
06b1			;         if file to delete 
06b1			;         Save file id 
06b1			;         Null file id 
06b1			;         Write this block back 
06b1			;      If file id is one saved 
06b1			;         Null file id 
06b1			;         Write this block back 
06b1			 
06b1			 
06b1			.se_done: 
06b1 e1				pop hl 
06b2 c9				ret 
06b3			 
06b3			storage_erase: 
06b3			 
06b3				; hl contains the file id 
06b3			 
06b3 5d				ld e, l 
06b4 16 00			ld d, 0 
06b6 21 40 00			ld hl, STORE_BLOCK_PHY 
06b9					if DEBUG_FORTH_WORDS 
06b9						DMARK "ERA" 
06b9 f5				push af  
06ba 3a ce 06			ld a, (.dmark)  
06bd 32 a6 fd			ld (debug_mark),a  
06c0 3a cf 06			ld a, (.dmark+1)  
06c3 32 a7 fd			ld (debug_mark+1),a  
06c6 3a d0 06			ld a, (.dmark+2)  
06c9 32 a8 fd			ld (debug_mark+2),a  
06cc 18 03			jr .pastdmark  
06ce ..			.dmark: db "ERA"  
06d1 f1			.pastdmark: pop af  
06d2			endm  
# End of macro DMARK
06d2						CALLMONITOR 
06d2 cd aa fd			call debug_vector  
06d5				endm  
# End of macro CALLMONITOR
06d5					endif 
06d5 cd a4 07			call storage_findnextid 
06d8 cd 04 10			call ishlzero 
06db c8				ret z 
06dc			 
06dc e5				push hl 
06dd			 
06dd				; TODO check file not found 
06dd			 
06dd 11 b5 f9			ld de, store_page 
06e0 cd 71 04			call storage_read_block 
06e3			 
06e3 cd 04 10			call ishlzero 
06e6 ca b1 06			jp z,.se_done 
06e9			 
06e9					if DEBUG_FORTH_WORDS 
06e9						DMARK "ER1" 
06e9 f5				push af  
06ea 3a fe 06			ld a, (.dmark)  
06ed 32 a6 fd			ld (debug_mark),a  
06f0 3a ff 06			ld a, (.dmark+1)  
06f3 32 a7 fd			ld (debug_mark+1),a  
06f6 3a 00 07			ld a, (.dmark+2)  
06f9 32 a8 fd			ld (debug_mark+2),a  
06fc 18 03			jr .pastdmark  
06fe ..			.dmark: db "ER1"  
0701 f1			.pastdmark: pop af  
0702			endm  
# End of macro DMARK
0702						CALLMONITOR 
0702 cd aa fd			call debug_vector  
0705				endm  
# End of macro CALLMONITOR
0705					endif 
0705 3a b5 f9			ld a, (store_page)	; get file id 
0708 32 a9 f9			ld (store_tmpid), a 
070b			 
070b 3a b7 f9			ld a, (store_page+2)    ; get count of extends 
070e 32 a8 f9			ld (store_tmpext), a 
0711			 
0711				; wipe file header 
0711			 
0711 e1				pop hl 
0712 3e 00			ld a, 0 
0714 32 b5 f9			ld (store_page), a 
0717 32 b6 f9			ld (store_page+1),a 
071a 11 b5 f9			ld de, store_page 
071d					if DEBUG_FORTH_WORDS 
071d						DMARK "ER2" 
071d f5				push af  
071e 3a 32 07			ld a, (.dmark)  
0721 32 a6 fd			ld (debug_mark),a  
0724 3a 33 07			ld a, (.dmark+1)  
0727 32 a7 fd			ld (debug_mark+1),a  
072a 3a 34 07			ld a, (.dmark+2)  
072d 32 a8 fd			ld (debug_mark+2),a  
0730 18 03			jr .pastdmark  
0732 ..			.dmark: db "ER2"  
0735 f1			.pastdmark: pop af  
0736			endm  
# End of macro DMARK
0736						CALLMONITOR 
0736 cd aa fd			call debug_vector  
0739				endm  
# End of macro CALLMONITOR
0739					endif 
0739 cd d6 04			call storage_write_block 
073c			 
073c			 
073c				; wipe file extents 
073c			 
073c 3a a8 f9			ld a, (store_tmpext) 
073f 47				ld b, a 
0740			 
0740			.eraext:	  
0740 c5				push bc 
0741			 
0741 21 40 00			ld hl, STORE_BLOCK_PHY 
0744 3a a9 f9			ld a,(store_tmpid) 
0747 5f				ld e, a 
0748 50				ld d, b	 
0749					if DEBUG_FORTH_WORDS 
0749						DMARK "ER3" 
0749 f5				push af  
074a 3a 5e 07			ld a, (.dmark)  
074d 32 a6 fd			ld (debug_mark),a  
0750 3a 5f 07			ld a, (.dmark+1)  
0753 32 a7 fd			ld (debug_mark+1),a  
0756 3a 60 07			ld a, (.dmark+2)  
0759 32 a8 fd			ld (debug_mark+2),a  
075c 18 03			jr .pastdmark  
075e ..			.dmark: db "ER3"  
0761 f1			.pastdmark: pop af  
0762			endm  
# End of macro DMARK
0762						CALLMONITOR 
0762 cd aa fd			call debug_vector  
0765				endm  
# End of macro CALLMONITOR
0765					endif 
0765 cd a4 07			call storage_findnextid 
0768 cd 04 10			call ishlzero 
076b ca b1 06			jp z,.se_done 
076e			 
076e e5				push hl 
076f 11 b5 f9			ld de, store_page 
0772 cd 71 04			call storage_read_block 
0775			 
0775				; free block	 
0775			 
0775 3e 00			ld a, 0 
0777 32 b5 f9			ld (store_page), a 
077a 32 b6 f9			ld (store_page+1),a 
077d 11 b5 f9			ld de, store_page 
0780 e1				pop hl 
0781					if DEBUG_FORTH_WORDS 
0781						DMARK "ER4" 
0781 f5				push af  
0782 3a 96 07			ld a, (.dmark)  
0785 32 a6 fd			ld (debug_mark),a  
0788 3a 97 07			ld a, (.dmark+1)  
078b 32 a7 fd			ld (debug_mark+1),a  
078e 3a 98 07			ld a, (.dmark+2)  
0791 32 a8 fd			ld (debug_mark+2),a  
0794 18 03			jr .pastdmark  
0796 ..			.dmark: db "ER4"  
0799 f1			.pastdmark: pop af  
079a			endm  
# End of macro DMARK
079a						CALLMONITOR 
079a cd aa fd			call debug_vector  
079d				endm  
# End of macro CALLMONITOR
079d					endif 
079d cd d6 04			call storage_write_block 
07a0			 
07a0 c1				pop bc 
07a1 10 9d			djnz .eraext 
07a3			 
07a3 c9				ret 
07a4			 
07a4			 
07a4			; Find Free Block 
07a4			; --------------- 
07a4			; 
07a4			; With current bank 
07a4			;  
07a4			; From given starting logical block 
07a4			;    Read block  
07a4			;    If no file id 
07a4			;         Return block id 
07a4			 
07a4			 
07a4			; hl starting page number 
07a4			; hl contains free page number or zero if no pages free 
07a4			; e contains the file id to locate 
07a4			; d contains the block number 
07a4			 
07a4			; TODO change to find file id and use zero for free block 
07a4			 
07a4			storage_findnextid: 
07a4			 
07a4				; now locate first 0 page to mark as a free block 
07a4			 
07a4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07a6			;	ld hl, STORE_BLOCK_PHY 
07a6			 
07a6					if DEBUG_FORTH_WORDS 
07a6					DMARK "FNI" 
07a6 f5				push af  
07a7 3a bb 07			ld a, (.dmark)  
07aa 32 a6 fd			ld (debug_mark),a  
07ad 3a bc 07			ld a, (.dmark+1)  
07b0 32 a7 fd			ld (debug_mark+1),a  
07b3 3a bd 07			ld a, (.dmark+2)  
07b6 32 a8 fd			ld (debug_mark+2),a  
07b9 18 03			jr .pastdmark  
07bb ..			.dmark: db "FNI"  
07be f1			.pastdmark: pop af  
07bf			endm  
# End of macro DMARK
07bf						CALLMONITOR 
07bf cd aa fd			call debug_vector  
07c2				endm  
# End of macro CALLMONITOR
07c2					endif 
07c2			.ff1:   	 
07c2 e5					push hl 
07c3 c5					push bc 
07c4 d5					push de 
07c5 cd 18 03				call se_readbyte 
07c8 5f					ld e,a 
07c9 23					inc hl 
07ca cd 18 03				call se_readbyte 
07cd 57					ld d, a 
07ce e1					pop hl 
07cf e5					push hl 
07d0 cd f9 0f				call cmp16 
07d3 28 49				jr z, .fffound 
07d5			 
07d5 d1					pop de 
07d6 c1					pop bc 
07d7 e1					pop hl 
07d8			 
07d8					; is found? 
07d8					;cp e 
07d8					;ret z 
07d8			 
07d8 3e 40				ld a, STORE_BLOCK_PHY 
07da cd db 0f				call addatohl 
07dd 10 e3				djnz .ff1 
07df			 
07df 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07e1			.ff2:   	 
07e1			 
07e1 e5					push hl 
07e2 c5					push bc 
07e3 d5					push de 
07e4 cd 18 03				call se_readbyte 
07e7 5f					ld e,a 
07e8 23					inc hl 
07e9 cd 18 03				call se_readbyte 
07ec 57					ld d, a 
07ed			 
07ed e1					pop hl 
07ee e5					push hl 
07ef cd f9 0f				call cmp16 
07f2 28 2a				jr z, .fffound 
07f4			 
07f4 d1					pop de 
07f5 c1					pop bc 
07f6 e1					pop hl 
07f7					; is found? 
07f7					;cp e 
07f7					;ret z 
07f7			 
07f7 3e 40				ld a, STORE_BLOCK_PHY 
07f9 cd db 0f				call addatohl 
07fc 10 e3				djnz .ff2 
07fe			 
07fe			 
07fe					if DEBUG_FORTH_WORDS 
07fe					DMARK "FN-" 
07fe f5				push af  
07ff 3a 13 08			ld a, (.dmark)  
0802 32 a6 fd			ld (debug_mark),a  
0805 3a 14 08			ld a, (.dmark+1)  
0808 32 a7 fd			ld (debug_mark+1),a  
080b 3a 15 08			ld a, (.dmark+2)  
080e 32 a8 fd			ld (debug_mark+2),a  
0811 18 03			jr .pastdmark  
0813 ..			.dmark: db "FN-"  
0816 f1			.pastdmark: pop af  
0817			endm  
# End of macro DMARK
0817					;	push af 
0817					;	ld a, 'n' 
0817					;	ld (debug_mark),a 
0817					;	pop af 
0817						CALLMONITOR 
0817 cd aa fd			call debug_vector  
081a				endm  
# End of macro CALLMONITOR
081a					endif 
081a				; no free marks! 
081a 21 00 00				ld hl, 0 
081d c9				ret 
081e			.fffound: 
081e				 
081e			 
081e d1					pop de 
081f c1					pop bc 
0820 e1					pop hl 
0821					if DEBUG_FORTH_WORDS 
0821					DMARK "FNF" 
0821 f5				push af  
0822 3a 36 08			ld a, (.dmark)  
0825 32 a6 fd			ld (debug_mark),a  
0828 3a 37 08			ld a, (.dmark+1)  
082b 32 a7 fd			ld (debug_mark+1),a  
082e 3a 38 08			ld a, (.dmark+2)  
0831 32 a8 fd			ld (debug_mark+2),a  
0834 18 03			jr .pastdmark  
0836 ..			.dmark: db "FNF"  
0839 f1			.pastdmark: pop af  
083a			endm  
# End of macro DMARK
083a					;	push af 
083a					;	ld a, 'n' 
083a					;	ld (debug_mark),a 
083a					;	pop af 
083a						CALLMONITOR 
083a cd aa fd			call debug_vector  
083d				endm  
# End of macro CALLMONITOR
083d					endif 
083d c9				ret 
083e			 
083e			 
083e			 
083e			; Free Space 
083e			; ---------- 
083e			; 
083e			; With current bank 
083e			; 
083e			; Set block count to zero 
083e			; Starting with first logical block 
083e			;      Find free block  
083e			;      If block id given, increment block count 
083e			; 
083e			;  
083e			 
083e			 
083e			; hl contains count of free blocks 
083e			 
083e			storage_freeblocks: 
083e			 
083e				; now locate first 0 page to mark as a free block 
083e			 
083e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0840 21 40 00			ld hl, STORE_BLOCK_PHY 
0843 11 00 00			ld de, 0 
0846			 
0846			.fb1:   	 
0846 e5					push hl 
0847 c5					push bc 
0848 d5					push de 
0849 cd 18 03				call se_readbyte 
084c d1					pop de 
084d c1					pop bc 
084e e1					pop hl 
084f			 
084f					; is free? 
084f fe 00				cp 0 
0851 20 01				jr nz, .ff1cont 
0853 13					inc de 
0854			 
0854			.ff1cont: 
0854			 
0854			 
0854 3e 40				ld a, STORE_BLOCK_PHY 
0856 cd db 0f				call addatohl 
0859 10 eb				djnz .fb1 
085b			 
085b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
085d			.fb2:   	 
085d e5					push hl 
085e c5					push bc 
085f d5					push de 
0860 cd 18 03				call se_readbyte 
0863 d1					pop de 
0864 c1					pop bc 
0865 e1					pop hl 
0866			 
0866					; is free? 
0866 fe 00				cp 0 
0868 20 01				jr nz, .ff2cont 
086a 13					inc de 
086b			 
086b			.ff2cont: 
086b			 
086b 3e 40				ld a, STORE_BLOCK_PHY 
086d cd db 0f				call addatohl 
0870 10 eb				djnz .fb2 
0872			 
0872 eb				ex de, hl 
0873 c9				ret 
0874			 
0874			; Get File ID 
0874			; ----------- 
0874			; 
0874			; With current bank 
0874			;  
0874			; Load Block 0 Config 
0874			; Get max file id number 
0874			; For each logical block 
0874			;    Read block file id 
0874			;      If first block of file and dont have file id 
0874			;         if file get id and exit 
0874			 
0874			 
0874			 
0874			 
0874			; Create File 
0874			; ----------- 
0874			; 
0874			; With current bank  
0874			; Load Block 0 Config 
0874			; Get max file id number 
0874			; Increment file id number 
0874			; Save Config 
0874			; Find free block 
0874			; Set buffer with file name and file id 
0874			; Write buffer to free block  
0874			 
0874			 
0874			; hl point to file name 
0874			; hl returns file id 
0874			 
0874			; file format: 
0874			; byte 0 - file id 
0874			; byte 1 - extent number 
0874			; byte 2-> data 
0874			 
0874			; format for extent number 0: 
0874			; 
0874			; byte 0 - file id 
0874			; byte 1 - extent 0 
0874			; byte 2 - extent count 
0874			; byte 3 -> file name and meta data 
0874			 
0874			 
0874			storage_create: 
0874				if DEBUG_STORESE 
0874					DMARK "SCR" 
0874 f5				push af  
0875 3a 89 08			ld a, (.dmark)  
0878 32 a6 fd			ld (debug_mark),a  
087b 3a 8a 08			ld a, (.dmark+1)  
087e 32 a7 fd			ld (debug_mark+1),a  
0881 3a 8b 08			ld a, (.dmark+2)  
0884 32 a8 fd			ld (debug_mark+2),a  
0887 18 03			jr .pastdmark  
0889 ..			.dmark: db "SCR"  
088c f1			.pastdmark: pop af  
088d			endm  
# End of macro DMARK
088d					CALLMONITOR 
088d cd aa fd			call debug_vector  
0890				endm  
# End of macro CALLMONITOR
0890				endif 
0890			 
0890 e5				push hl		; save file name pointer 
0891			 
0891 cd 22 05			call storage_get_block_0 
0894			 
0894 3a b5 f9			ld a,(store_page)	; get current file id 
0897 3c				inc a 
0898 32 b5 f9			ld (store_page),a 
089b				 
089b 32 a9 f9			ld (store_tmpid),a			; save id 
089e			 
089e 21 00 00			ld hl, 0 
08a1 11 b5 f9			ld de, store_page 
08a4				if DEBUG_STORESE 
08a4					DMARK "SCw" 
08a4 f5				push af  
08a5 3a b9 08			ld a, (.dmark)  
08a8 32 a6 fd			ld (debug_mark),a  
08ab 3a ba 08			ld a, (.dmark+1)  
08ae 32 a7 fd			ld (debug_mark+1),a  
08b1 3a bb 08			ld a, (.dmark+2)  
08b4 32 a8 fd			ld (debug_mark+2),a  
08b7 18 03			jr .pastdmark  
08b9 ..			.dmark: db "SCw"  
08bc f1			.pastdmark: pop af  
08bd			endm  
# End of macro DMARK
08bd					CALLMONITOR 
08bd cd aa fd			call debug_vector  
08c0				endm  
# End of macro CALLMONITOR
08c0				endif 
08c0 cd d6 04			call storage_write_block	 ; save update 
08c3			 
08c3				if DEBUG_STORESE 
08c3 11 b5 f9				ld de, store_page 
08c6					DMARK "SCC" 
08c6 f5				push af  
08c7 3a db 08			ld a, (.dmark)  
08ca 32 a6 fd			ld (debug_mark),a  
08cd 3a dc 08			ld a, (.dmark+1)  
08d0 32 a7 fd			ld (debug_mark+1),a  
08d3 3a dd 08			ld a, (.dmark+2)  
08d6 32 a8 fd			ld (debug_mark+2),a  
08d9 18 03			jr .pastdmark  
08db ..			.dmark: db "SCC"  
08de f1			.pastdmark: pop af  
08df			endm  
# End of macro DMARK
08df					CALLMONITOR 
08df cd aa fd			call debug_vector  
08e2				endm  
# End of macro CALLMONITOR
08e2				endif 
08e2				;  
08e2				 
08e2 21 40 00			ld hl, STORE_BLOCK_PHY 
08e5 11 00 00			ld de, 0 
08e8 cd a4 07			call storage_findnextid 
08eb			 
08eb 22 a0 f9			ld (store_tmppageid), hl    ; save page to use  
08ee			 
08ee				; TODO detect 0 = no spare blocks 
08ee			 
08ee				; hl now contains the free page to use for the file header page 
08ee			 
08ee				if DEBUG_STORESE 
08ee				DMARK "SCF" 
08ee f5				push af  
08ef 3a 03 09			ld a, (.dmark)  
08f2 32 a6 fd			ld (debug_mark),a  
08f5 3a 04 09			ld a, (.dmark+1)  
08f8 32 a7 fd			ld (debug_mark+1),a  
08fb 3a 05 09			ld a, (.dmark+2)  
08fe 32 a8 fd			ld (debug_mark+2),a  
0901 18 03			jr .pastdmark  
0903 ..			.dmark: db "SCF"  
0906 f1			.pastdmark: pop af  
0907			endm  
# End of macro DMARK
0907					CALLMONITOR 
0907 cd aa fd			call debug_vector  
090a				endm  
# End of macro CALLMONITOR
090a				endif 
090a			 
090a 22 a0 f9			ld (store_tmppageid), hl 
090d				 
090d 3a a9 f9			ld a,(store_tmpid)    ; get file id 
0910			;	ld a, (store_filecache)			; save to cache 
0910			 
0910 32 b5 f9			ld (store_page),a    ; set page id 
0913 3e 00			ld a, 0			 ; extent 0 is file header 
0915 32 b6 f9			ld (store_page+1), a   ; set file extent 
0918			 
0918 32 b7 f9			ld (store_page+2), a   ; extent count for the file 
091b			 
091b			;	inc hl 		; init block 0 of file 
091b			;	inc hl   		; skip file and extent id 
091b			 ;       ld a, 0 
091b			;	ld (hl),a 
091b			;	ld a, (store_filecache+1)  	; save to cache 
091b			 
091b			;	inc hl    ; file name 
091b				 
091b				 
091b 11 b8 f9			ld de, store_page+3    ; get buffer for term string to use as file name 
091e				if DEBUG_STORESE 
091e					DMARK "SCc" 
091e f5				push af  
091f 3a 33 09			ld a, (.dmark)  
0922 32 a6 fd			ld (debug_mark),a  
0925 3a 34 09			ld a, (.dmark+1)  
0928 32 a7 fd			ld (debug_mark+1),a  
092b 3a 35 09			ld a, (.dmark+2)  
092e 32 a8 fd			ld (debug_mark+2),a  
0931 18 03			jr .pastdmark  
0933 ..			.dmark: db "SCc"  
0936 f1			.pastdmark: pop af  
0937			endm  
# End of macro DMARK
0937					CALLMONITOR 
0937 cd aa fd			call debug_vector  
093a				endm  
# End of macro CALLMONITOR
093a				endif 
093a e1				pop hl    ; get zero term string 
093b e5				push hl 
093c 3e 00			ld a, 0 
093e cd 4c 13			call strlent 
0941 23				inc hl   ; cover zero term 
0942 06 00			ld b,0 
0944 4d				ld c,l 
0945 e1				pop hl 
0946				;ex de, hl 
0946				if DEBUG_STORESE 
0946					DMARK "SCa" 
0946 f5				push af  
0947 3a 5b 09			ld a, (.dmark)  
094a 32 a6 fd			ld (debug_mark),a  
094d 3a 5c 09			ld a, (.dmark+1)  
0950 32 a7 fd			ld (debug_mark+1),a  
0953 3a 5d 09			ld a, (.dmark+2)  
0956 32 a8 fd			ld (debug_mark+2),a  
0959 18 03			jr .pastdmark  
095b ..			.dmark: db "SCa"  
095e f1			.pastdmark: pop af  
095f			endm  
# End of macro DMARK
095f					;push af 
095f					;ld a, 'a' 
095f					;ld (debug_mark),a 
095f					;pop af 
095f					CALLMONITOR 
095f cd aa fd			call debug_vector  
0962				endm  
# End of macro CALLMONITOR
0962				endif 
0962 ed b0			ldir    ; copy zero term string 
0964				if DEBUG_STORESE 
0964					DMARK "SCA" 
0964 f5				push af  
0965 3a 79 09			ld a, (.dmark)  
0968 32 a6 fd			ld (debug_mark),a  
096b 3a 7a 09			ld a, (.dmark+1)  
096e 32 a7 fd			ld (debug_mark+1),a  
0971 3a 7b 09			ld a, (.dmark+2)  
0974 32 a8 fd			ld (debug_mark+2),a  
0977 18 03			jr .pastdmark  
0979 ..			.dmark: db "SCA"  
097c f1			.pastdmark: pop af  
097d			endm  
# End of macro DMARK
097d					CALLMONITOR 
097d cd aa fd			call debug_vector  
0980				endm  
# End of macro CALLMONITOR
0980				endif 
0980			 
0980				; write file header page 
0980			 
0980 2a a0 f9			ld hl,(store_tmppageid) 
0983 11 b5 f9			ld de, store_page 
0986				if DEBUG_STORESE 
0986					DMARK "SCb" 
0986 f5				push af  
0987 3a 9b 09			ld a, (.dmark)  
098a 32 a6 fd			ld (debug_mark),a  
098d 3a 9c 09			ld a, (.dmark+1)  
0990 32 a7 fd			ld (debug_mark+1),a  
0993 3a 9d 09			ld a, (.dmark+2)  
0996 32 a8 fd			ld (debug_mark+2),a  
0999 18 03			jr .pastdmark  
099b ..			.dmark: db "SCb"  
099e f1			.pastdmark: pop af  
099f			endm  
# End of macro DMARK
099f					;push af 
099f					;ld a, 'b' 
099f					;ld (debug_mark),a 
099f					;pop af 
099f					CALLMONITOR 
099f cd aa fd			call debug_vector  
09a2				endm  
# End of macro CALLMONITOR
09a2				endif 
09a2 cd d6 04			call storage_write_block 
09a5			 
09a5 3a a9 f9			ld a, (store_tmpid) 
09a8 6f				ld l, a 
09a9 26 00			ld h,0 
09ab				if DEBUG_STORESE 
09ab					DMARK "SCz" 
09ab f5				push af  
09ac 3a c0 09			ld a, (.dmark)  
09af 32 a6 fd			ld (debug_mark),a  
09b2 3a c1 09			ld a, (.dmark+1)  
09b5 32 a7 fd			ld (debug_mark+1),a  
09b8 3a c2 09			ld a, (.dmark+2)  
09bb 32 a8 fd			ld (debug_mark+2),a  
09be 18 03			jr .pastdmark  
09c0 ..			.dmark: db "SCz"  
09c3 f1			.pastdmark: pop af  
09c4			endm  
# End of macro DMARK
09c4					CALLMONITOR 
09c4 cd aa fd			call debug_vector  
09c7				endm  
# End of macro CALLMONITOR
09c7				endif 
09c7 c9				ret 
09c8				 
09c8			 
09c8			 
09c8			; 
09c8			; Read File 
09c8			; 
09c8			; h - file id to locate 
09c8			; l - extent to locate 
09c8			; de - pointer to string to read into 
09c8			; 
09c8			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09c8			 
09c8			.sr_fail: 
09c8 d1				pop de 
09c9 c9				ret 
09ca			 
09ca			storage_read: 
09ca			 
09ca			 
09ca d5				push de 
09cb			 
09cb			; TODO BUG the above push is it popped before the RET Z? 
09cb			 
09cb			; TODO how to handle multiple part blocks 
09cb			 
09cb				; locate file extent to read 
09cb			 
09cb 5c				ld e, h 
09cc 55				ld d, l 
09cd			 
09cd			.srext: 
09cd 22 b3 f9			ld (store_readptr), hl     ; save the current extent to load 
09d0 ed 53 b1 f9		ld (store_readbuf), de     ; save the current buffer to load in to 
09d4			 
09d4 21 40 00			ld hl, STORE_BLOCK_PHY 
09d7				if DEBUG_STORESE 
09d7					DMARK "sre" 
09d7 f5				push af  
09d8 3a ec 09			ld a, (.dmark)  
09db 32 a6 fd			ld (debug_mark),a  
09de 3a ed 09			ld a, (.dmark+1)  
09e1 32 a7 fd			ld (debug_mark+1),a  
09e4 3a ee 09			ld a, (.dmark+2)  
09e7 32 a8 fd			ld (debug_mark+2),a  
09ea 18 03			jr .pastdmark  
09ec ..			.dmark: db "sre"  
09ef f1			.pastdmark: pop af  
09f0			endm  
# End of macro DMARK
09f0					CALLMONITOR 
09f0 cd aa fd			call debug_vector  
09f3				endm  
# End of macro CALLMONITOR
09f3				endif 
09f3 cd a4 07			call storage_findnextid 
09f6			 
09f6				if DEBUG_STORESE 
09f6					DMARK "srf" 
09f6 f5				push af  
09f7 3a 0b 0a			ld a, (.dmark)  
09fa 32 a6 fd			ld (debug_mark),a  
09fd 3a 0c 0a			ld a, (.dmark+1)  
0a00 32 a7 fd			ld (debug_mark+1),a  
0a03 3a 0d 0a			ld a, (.dmark+2)  
0a06 32 a8 fd			ld (debug_mark+2),a  
0a09 18 03			jr .pastdmark  
0a0b ..			.dmark: db "srf"  
0a0e f1			.pastdmark: pop af  
0a0f			endm  
# End of macro DMARK
0a0f					CALLMONITOR 
0a0f cd aa fd			call debug_vector  
0a12				endm  
# End of macro CALLMONITOR
0a12				endif 
0a12 cd 04 10			call ishlzero 
0a15			;	ld a, l 
0a15			;	add h 
0a15			;	cp 0 
0a15 28 b1			jr z,.sr_fail			; block not found so EOF 
0a17			 
0a17				; save current address for use by higher level words etc 
0a17			 
0a17 22 a6 f9			ld (store_openaddr),hl 
0a1a			 
0a1a			 
0a1a				; hl contains page number to load 
0a1a d1				pop de   ; get storage 
0a1b ed 53 b1 f9		ld (store_readbuf), de     ; current buffer to load in to 
0a1f d5				push de 
0a20				if DEBUG_STORESE 
0a20					DMARK "srg" 
0a20 f5				push af  
0a21 3a 35 0a			ld a, (.dmark)  
0a24 32 a6 fd			ld (debug_mark),a  
0a27 3a 36 0a			ld a, (.dmark+1)  
0a2a 32 a7 fd			ld (debug_mark+1),a  
0a2d 3a 37 0a			ld a, (.dmark+2)  
0a30 32 a8 fd			ld (debug_mark+2),a  
0a33 18 03			jr .pastdmark  
0a35 ..			.dmark: db "srg"  
0a38 f1			.pastdmark: pop af  
0a39			endm  
# End of macro DMARK
0a39					CALLMONITOR 
0a39 cd aa fd			call debug_vector  
0a3c				endm  
# End of macro CALLMONITOR
0a3c				endif 
0a3c cd 71 04			call storage_read_block 
0a3f			 
0a3f				; if this a continuation read??? 
0a3f			 
0a3f 2a b1 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a42			 
0a42 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a44 cd db 0f			call addatohl 
0a47 7e				ld a,(hl) 
0a48 fe 00			cp 0 
0a4a 28 02			jr z, .markiscont 
0a4c 3e ff			ld a, 255 
0a4e			 
0a4e			.markiscont: 
0a4e 32 a8 f9			ld (store_readcont), a 
0a51			 
0a51				if DEBUG_STORESE 
0a51					DMARK "srC" 
0a51 f5				push af  
0a52 3a 66 0a			ld a, (.dmark)  
0a55 32 a6 fd			ld (debug_mark),a  
0a58 3a 67 0a			ld a, (.dmark+1)  
0a5b 32 a7 fd			ld (debug_mark+1),a  
0a5e 3a 68 0a			ld a, (.dmark+2)  
0a61 32 a8 fd			ld (debug_mark+2),a  
0a64 18 03			jr .pastdmark  
0a66 ..			.dmark: db "srC"  
0a69 f1			.pastdmark: pop af  
0a6a			endm  
# End of macro DMARK
0a6a					CALLMONITOR 
0a6a cd aa fd			call debug_vector  
0a6d				endm  
# End of macro CALLMONITOR
0a6d				endif 
0a6d				; only short reads enabled 
0a6d			 
0a6d 3a b0 f9			ld a, (store_longread) 
0a70 fe 00			cp 0 
0a72 ca 3f 0b			jp z, .readdone 
0a75			 
0a75			; TODO if block has no zeros then need to read next block  
0a75			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a75			; check last byte of physical block. 
0a75			; if not zero then the next block needs to be loaded 
0a75			 
0a75			 
0a75 2a b1 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a78			 
0a78 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a7a cd db 0f			call addatohl 
0a7d				;dec hl 
0a7d 7e				ld a,(hl) 
0a7e				if DEBUG_STORESE 
0a7e					DMARK "sr?" 
0a7e f5				push af  
0a7f 3a 93 0a			ld a, (.dmark)  
0a82 32 a6 fd			ld (debug_mark),a  
0a85 3a 94 0a			ld a, (.dmark+1)  
0a88 32 a7 fd			ld (debug_mark+1),a  
0a8b 3a 95 0a			ld a, (.dmark+2)  
0a8e 32 a8 fd			ld (debug_mark+2),a  
0a91 18 03			jr .pastdmark  
0a93 ..			.dmark: db "sr?"  
0a96 f1			.pastdmark: pop af  
0a97			endm  
# End of macro DMARK
0a97					CALLMONITOR 
0a97 cd aa fd			call debug_vector  
0a9a				endm  
# End of macro CALLMONITOR
0a9a				endif 
0a9a fe 00			cp 0 
0a9c ca 3f 0b			jp z, .readdone 
0a9f			 
0a9f				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a9f			 
0a9f 23				inc hl 
0aa0			 
0aa0 22 b1 f9			ld (store_readbuf), hl     ; save the current buffer to load in to 
0aa3			 
0aa3 ed 5b b3 f9		ld de, (store_readptr)     ; save the current extent to load 
0aa7			 
0aa7 eb				ex de, hl 
0aa8			 
0aa8				; next ext 
0aa8			 
0aa8 23				inc hl 
0aa9 22 b3 f9			ld  (store_readptr), hl     ; save the current extent to load 
0aac			 
0aac				if DEBUG_STORESE 
0aac					DMARK "sF2" 
0aac f5				push af  
0aad 3a c1 0a			ld a, (.dmark)  
0ab0 32 a6 fd			ld (debug_mark),a  
0ab3 3a c2 0a			ld a, (.dmark+1)  
0ab6 32 a7 fd			ld (debug_mark+1),a  
0ab9 3a c3 0a			ld a, (.dmark+2)  
0abc 32 a8 fd			ld (debug_mark+2),a  
0abf 18 03			jr .pastdmark  
0ac1 ..			.dmark: db "sF2"  
0ac4 f1			.pastdmark: pop af  
0ac5			endm  
# End of macro DMARK
0ac5					CALLMONITOR 
0ac5 cd aa fd			call debug_vector  
0ac8				endm  
# End of macro CALLMONITOR
0ac8				endif 
0ac8			 
0ac8				; get and load block 
0ac8			 
0ac8 cd a4 07			call storage_findnextid 
0acb			 
0acb				if DEBUG_STORESE 
0acb					DMARK "sf2" 
0acb f5				push af  
0acc 3a e0 0a			ld a, (.dmark)  
0acf 32 a6 fd			ld (debug_mark),a  
0ad2 3a e1 0a			ld a, (.dmark+1)  
0ad5 32 a7 fd			ld (debug_mark+1),a  
0ad8 3a e2 0a			ld a, (.dmark+2)  
0adb 32 a8 fd			ld (debug_mark+2),a  
0ade 18 03			jr .pastdmark  
0ae0 ..			.dmark: db "sf2"  
0ae3 f1			.pastdmark: pop af  
0ae4			endm  
# End of macro DMARK
0ae4					CALLMONITOR 
0ae4 cd aa fd			call debug_vector  
0ae7				endm  
# End of macro CALLMONITOR
0ae7				endif 
0ae7 cd 04 10			call ishlzero 
0aea			;	ld a, l 
0aea			;	add h 
0aea			;	cp 0 
0aea ca c8 09			jp z,.sr_fail			; block not found so EOF 
0aed				 
0aed				; save current address for use by higher level words etc 
0aed			 
0aed 22 a6 f9			ld (store_openaddr),hl 
0af0			 
0af0 cd 71 04			call storage_read_block 
0af3			 
0af3				; on a continuation block, we now have the file id and ext in the middle of the block 
0af3				; we need to pull everything back  
0af3			 
0af3 ed 5b b1 f9		ld de, (store_readbuf)     ; current buffer to nudge into 
0af7 2a b1 f9			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0afa 23				inc hl 
0afb 23				inc hl     ; skip id and ext 
0afc 01 40 00			ld bc, STORE_BLOCK_PHY 
0aff				if DEBUG_STORESE 
0aff					DMARK "SR<" 
0aff f5				push af  
0b00 3a 14 0b			ld a, (.dmark)  
0b03 32 a6 fd			ld (debug_mark),a  
0b06 3a 15 0b			ld a, (.dmark+1)  
0b09 32 a7 fd			ld (debug_mark+1),a  
0b0c 3a 16 0b			ld a, (.dmark+2)  
0b0f 32 a8 fd			ld (debug_mark+2),a  
0b12 18 03			jr .pastdmark  
0b14 ..			.dmark: db "SR<"  
0b17 f1			.pastdmark: pop af  
0b18			endm  
# End of macro DMARK
0b18					CALLMONITOR 
0b18 cd aa fd			call debug_vector  
0b1b				endm  
# End of macro CALLMONITOR
0b1b				endif 
0b1b ed b0			ldir     ; copy data 
0b1d			 
0b1d				; move the pointer back and pretend we have a full buffer for next recheck 
0b1d			 
0b1d 1b				dec de 
0b1e 1b				dec de 
0b1f			 
0b1f			; TODO do pop below now short circuit loop????? 
0b1f c1				pop bc     ; get rid of spare de on stack 
0b20				if DEBUG_STORESE 
0b20					DMARK "SR>" 
0b20 f5				push af  
0b21 3a 35 0b			ld a, (.dmark)  
0b24 32 a6 fd			ld (debug_mark),a  
0b27 3a 36 0b			ld a, (.dmark+1)  
0b2a 32 a7 fd			ld (debug_mark+1),a  
0b2d 3a 37 0b			ld a, (.dmark+2)  
0b30 32 a8 fd			ld (debug_mark+2),a  
0b33 18 03			jr .pastdmark  
0b35 ..			.dmark: db "SR>"  
0b38 f1			.pastdmark: pop af  
0b39			endm  
# End of macro DMARK
0b39					CALLMONITOR 
0b39 cd aa fd			call debug_vector  
0b3c				endm  
# End of macro CALLMONITOR
0b3c				endif 
0b3c c3 cd 09			jp .srext 
0b3f			 
0b3f			 
0b3f			 
0b3f			 
0b3f			 
0b3f			.readdone:		 
0b3f e1				pop hl 		 ; return start of data to show as not EOF 
0b40 23				inc hl   ; past file id 
0b41 23				inc hl   ; past ext 
0b42				if DEBUG_STORESE 
0b42					DMARK "SRe" 
0b42 f5				push af  
0b43 3a 57 0b			ld a, (.dmark)  
0b46 32 a6 fd			ld (debug_mark),a  
0b49 3a 58 0b			ld a, (.dmark+1)  
0b4c 32 a7 fd			ld (debug_mark+1),a  
0b4f 3a 59 0b			ld a, (.dmark+2)  
0b52 32 a8 fd			ld (debug_mark+2),a  
0b55 18 03			jr .pastdmark  
0b57 ..			.dmark: db "SRe"  
0b5a f1			.pastdmark: pop af  
0b5b			endm  
# End of macro DMARK
0b5b					CALLMONITOR 
0b5b cd aa fd			call debug_vector  
0b5e				endm  
# End of macro CALLMONITOR
0b5e				endif 
0b5e c9					ret 
0b5f			 
0b5f			 
0b5f			 
0b5f			; 
0b5f			; Append File 
0b5f			; 
0b5f			; hl - file id to locate 
0b5f			; de - pointer to (multi block) string to write 
0b5f			 
0b5f			.sa_notfound: 
0b5f d1				pop de 
0b60 c9				ret 
0b61			 
0b61			 
0b61			storage_append: 
0b61				; hl -  file id to append to 
0b61				; de - string to append 
0b61			 
0b61 d5				push de 
0b62				 
0b62				if DEBUG_STORESE 
0b62					DMARK "AP1" 
0b62 f5				push af  
0b63 3a 77 0b			ld a, (.dmark)  
0b66 32 a6 fd			ld (debug_mark),a  
0b69 3a 78 0b			ld a, (.dmark+1)  
0b6c 32 a7 fd			ld (debug_mark+1),a  
0b6f 3a 79 0b			ld a, (.dmark+2)  
0b72 32 a8 fd			ld (debug_mark+2),a  
0b75 18 03			jr .pastdmark  
0b77 ..			.dmark: db "AP1"  
0b7a f1			.pastdmark: pop af  
0b7b			endm  
# End of macro DMARK
0b7b					CALLMONITOR 
0b7b cd aa fd			call debug_vector  
0b7e				endm  
# End of macro CALLMONITOR
0b7e				endif 
0b7e			 
0b7e 7d				ld a, l 
0b7f 32 a9 f9			ld (store_tmpid), a 
0b82			 
0b82				; get file header  
0b82			 
0b82 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b84 3a a9 f9			ld a, (store_tmpid) 
0b87 5f				ld e, a 
0b88			 
0b88 21 40 00				ld hl, STORE_BLOCK_PHY 
0b8b cd a4 07				call storage_findnextid 
0b8e			 
0b8e cd 04 10			call ishlzero 
0b91 28 cc			jr z, .sa_notfound 
0b93			 
0b93 22 a0 f9			ld (store_tmppageid), hl 
0b96			 
0b96				; TODO handle file id not found 
0b96			 
0b96				if DEBUG_STORESE 
0b96					DMARK "AP2" 
0b96 f5				push af  
0b97 3a ab 0b			ld a, (.dmark)  
0b9a 32 a6 fd			ld (debug_mark),a  
0b9d 3a ac 0b			ld a, (.dmark+1)  
0ba0 32 a7 fd			ld (debug_mark+1),a  
0ba3 3a ad 0b			ld a, (.dmark+2)  
0ba6 32 a8 fd			ld (debug_mark+2),a  
0ba9 18 03			jr .pastdmark  
0bab ..			.dmark: db "AP2"  
0bae f1			.pastdmark: pop af  
0baf			endm  
# End of macro DMARK
0baf					CALLMONITOR 
0baf cd aa fd			call debug_vector  
0bb2				endm  
# End of macro CALLMONITOR
0bb2				endif 
0bb2			 
0bb2				; update file extent count 
0bb2			 
0bb2 11 b5 f9			ld de, store_page 
0bb5			 
0bb5 cd 71 04			call storage_read_block 
0bb8			 
0bb8				if DEBUG_STORESE 
0bb8					DMARK "AP3" 
0bb8 f5				push af  
0bb9 3a cd 0b			ld a, (.dmark)  
0bbc 32 a6 fd			ld (debug_mark),a  
0bbf 3a ce 0b			ld a, (.dmark+1)  
0bc2 32 a7 fd			ld (debug_mark+1),a  
0bc5 3a cf 0b			ld a, (.dmark+2)  
0bc8 32 a8 fd			ld (debug_mark+2),a  
0bcb 18 03			jr .pastdmark  
0bcd ..			.dmark: db "AP3"  
0bd0 f1			.pastdmark: pop af  
0bd1			endm  
# End of macro DMARK
0bd1					CALLMONITOR 
0bd1 cd aa fd			call debug_vector  
0bd4				endm  
# End of macro CALLMONITOR
0bd4				endif 
0bd4			;	ld (store_tmppageid), hl 
0bd4			 
0bd4 3a b7 f9			ld a, (store_page+2) 
0bd7 3c				inc a 
0bd8 32 b7 f9			ld (store_page+2), a 
0bdb 32 a8 f9			ld (store_tmpext), a 
0bde				 
0bde				if DEBUG_STORESE 
0bde					DMARK "AP3" 
0bde f5				push af  
0bdf 3a f3 0b			ld a, (.dmark)  
0be2 32 a6 fd			ld (debug_mark),a  
0be5 3a f4 0b			ld a, (.dmark+1)  
0be8 32 a7 fd			ld (debug_mark+1),a  
0beb 3a f5 0b			ld a, (.dmark+2)  
0bee 32 a8 fd			ld (debug_mark+2),a  
0bf1 18 03			jr .pastdmark  
0bf3 ..			.dmark: db "AP3"  
0bf6 f1			.pastdmark: pop af  
0bf7			endm  
# End of macro DMARK
0bf7					CALLMONITOR 
0bf7 cd aa fd			call debug_vector  
0bfa				endm  
# End of macro CALLMONITOR
0bfa				endif 
0bfa 2a a0 f9			ld hl, (store_tmppageid) 
0bfd 11 b5 f9			ld de, store_page 
0c00 cd d6 04			call storage_write_block 
0c03			 
0c03				; find free block 
0c03			 
0c03 11 00 00			ld de, 0			 ; file extent to locate 
0c06			 
0c06 21 40 00				ld hl, STORE_BLOCK_PHY 
0c09 cd a4 07				call storage_findnextid 
0c0c cd 04 10			call ishlzero 
0c0f ca 5f 0b			jp z, .sa_notfound 
0c12			 
0c12					; TODO handle no space left 
0c12					 
0c12 22 a0 f9				ld (store_tmppageid), hl 
0c15			 
0c15				if DEBUG_STORESE 
0c15					DMARK "AP4" 
0c15 f5				push af  
0c16 3a 2a 0c			ld a, (.dmark)  
0c19 32 a6 fd			ld (debug_mark),a  
0c1c 3a 2b 0c			ld a, (.dmark+1)  
0c1f 32 a7 fd			ld (debug_mark+1),a  
0c22 3a 2c 0c			ld a, (.dmark+2)  
0c25 32 a8 fd			ld (debug_mark+2),a  
0c28 18 03			jr .pastdmark  
0c2a ..			.dmark: db "AP4"  
0c2d f1			.pastdmark: pop af  
0c2e			endm  
# End of macro DMARK
0c2e					CALLMONITOR 
0c2e cd aa fd			call debug_vector  
0c31				endm  
# End of macro CALLMONITOR
0c31				endif 
0c31					; init the buffer with zeros so we can id if the buffer is full or not 
0c31			 
0c31 e5					push hl 
0c32 c5					push bc 
0c33			 
0c33 21 b5 f9				ld hl, store_page 
0c36 06 40				ld b, STORE_BLOCK_PHY 
0c38 3e 00				ld a, 0 
0c3a 77			.zeroblock:	ld (hl), a 
0c3b 23					inc hl 
0c3c 10 fc				djnz .zeroblock 
0c3e			 
0c3e c1					pop bc 
0c3f e1					pop hl 
0c40			 
0c40					; construct block 
0c40			 
0c40 3a a9 f9				ld a, (store_tmpid) 
0c43 32 b5 f9				ld (store_page), a   ; file id 
0c46 3a a8 f9				ld a, (store_tmpext)   ; extent for this block 
0c49 32 b6 f9				ld (store_page+1), a 
0c4c			 
0c4c e1					pop hl    ; get string to write 
0c4d 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c4f 11 b7 f9				ld de, store_page+2 
0c52			 
0c52				if DEBUG_STORESE 
0c52					DMARK "AP5" 
0c52 f5				push af  
0c53 3a 67 0c			ld a, (.dmark)  
0c56 32 a6 fd			ld (debug_mark),a  
0c59 3a 68 0c			ld a, (.dmark+1)  
0c5c 32 a7 fd			ld (debug_mark+1),a  
0c5f 3a 69 0c			ld a, (.dmark+2)  
0c62 32 a8 fd			ld (debug_mark+2),a  
0c65 18 03			jr .pastdmark  
0c67 ..			.dmark: db "AP5"  
0c6a f1			.pastdmark: pop af  
0c6b			endm  
# End of macro DMARK
0c6b					CALLMONITOR 
0c6b cd aa fd			call debug_vector  
0c6e				endm  
# End of macro CALLMONITOR
0c6e				endif 
0c6e			 
0c6e			 
0c6e			 
0c6e					; fill buffer with data until end of string or full block 
0c6e			 
0c6e 7e			.appd:		ld a, (hl) 
0c6f 12					ld (de), a 
0c70 fe 00				cp 0 
0c72 28 04				jr z, .appdone 
0c74 23					inc hl 
0c75 13					inc de 
0c76 10 f6				djnz .appd 
0c78			 
0c78 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c79 f5					push af   		; save last byte dumped 
0c7a			 
0c7a			 
0c7a 2a a0 f9			ld hl, (store_tmppageid) 
0c7d 11 b5 f9			ld de, store_page 
0c80				if DEBUG_STORESE 
0c80					DMARK "AP6" 
0c80 f5				push af  
0c81 3a 95 0c			ld a, (.dmark)  
0c84 32 a6 fd			ld (debug_mark),a  
0c87 3a 96 0c			ld a, (.dmark+1)  
0c8a 32 a7 fd			ld (debug_mark+1),a  
0c8d 3a 97 0c			ld a, (.dmark+2)  
0c90 32 a8 fd			ld (debug_mark+2),a  
0c93 18 03			jr .pastdmark  
0c95 ..			.dmark: db "AP6"  
0c98 f1			.pastdmark: pop af  
0c99			endm  
# End of macro DMARK
0c99					CALLMONITOR 
0c99 cd aa fd			call debug_vector  
0c9c				endm  
# End of macro CALLMONITOR
0c9c				endif 
0c9c cd d6 04				call storage_write_block 
0c9f			 
0c9f			 
0c9f				; was that a full block of data written? 
0c9f				; any more to write out? 
0c9f			 
0c9f				; if yes then set vars and jump to start of function again 
0c9f			 
0c9f f1					pop af 
0ca0 d1					pop de 
0ca1			 
0ca1 fe 00				cp 0		 ; no, string was fully written 
0ca3 c8					ret z 
0ca4			 
0ca4					; setup vars for next cycle 
0ca4			 
0ca4 3a a9 f9				ld a, (store_tmpid) 
0ca7 6f					ld l, a 
0ca8 26 00				ld h, 0 
0caa			 
0caa c3 61 0b			 	jp storage_append	 ; yes, need to write out some more 
0cad			 
0cad			 
0cad			 
0cad			 
0cad			 
0cad			 
0cad			 
0cad			if DEBUG_STORECF 
0cad			storageput:	 
0cad					ret 
0cad			storageread: 
0cad					ld hl, store_page 
0cad					ld b, 200 
0cad					ld a,0 
0cad			.src:		ld (hl),a 
0cad					inc hl 
0cad					djnz .src 
0cad					 
0cad			 
0cad					ld de, 0 
0cad					ld bc, 1 
0cad					ld hl, store_page 
0cad					call cfRead 
0cad			 
0cad				call cfGetError 
0cad				ld hl,scratch 
0cad				call hexout 
0cad				ld hl, scratch+2 
0cad				ld a, 0 
0cad				ld (hl),a 
0cad				ld de, scratch 
0cad				ld a,display_row_1 
0cad				call str_at_display 
0cad				call update_display 
0cad			 
0cad					ld hl, store_page 
0cad					ld (os_cur_ptr),hl 
0cad			 
0cad					ret 
0cad			endif 
0cad			 
0cad			 
0cad			; Clear out the main buffer store (used to remove junk before writing a new block) 
0cad			 
0cad			storage_clear_page: 
0cad e5				push hl 
0cae d5				push de 
0caf c5				push bc 
0cb0 21 b5 f9			ld hl, store_page 
0cb3 3e 00			ld a, 0 
0cb5 77				ld (hl), a 
0cb6			 
0cb6 11 b6 f9			ld de, store_page+1 
0cb9 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cbc			 
0cbc ed b0			ldir 
0cbe				 
0cbe c1				pop bc 
0cbf d1				pop de 
0cc0 e1				pop hl 
0cc1 c9				ret 
0cc2			 
0cc2			; eof 
# End of file firmware_storage.asm
0cc2			  
0cc2			; support routines for above hardware abstraction layer  
0cc2			  
0cc2			include "firmware_general.asm"        ; general support functions  
0cc2			 
0cc2			; word look up 
0cc2			 
0cc2			; in 
0cc2			; a is the index 
0cc2			; hl is pointer start of array 
0cc2			; 
0cc2			; returns 
0cc2			; hl to the word 
0cc2			; 
0cc2			 
0cc2			table_lookup:  
0cc2 d5					push de 
0cc3 eb					ex de, hl 
0cc4			 
0cc4 6f					ld l, a 
0cc5 26 00				ld h, 0 
0cc7 29					add hl, hl 
0cc8 19					add hl, de 
0cc9 7e					ld a, (hl) 
0cca 23					inc hl 
0ccb 66					ld h,(hl) 
0ccc 6f					ld l, a 
0ccd			 
0ccd d1					pop de 
0cce c9					ret 
0ccf			 
0ccf			; Delay loops 
0ccf			 
0ccf			 
0ccf			 
0ccf			aDelayInMS: 
0ccf c5				push bc 
0cd0 47				ld b,a 
0cd1			msdelay: 
0cd1 c5				push bc 
0cd2				 
0cd2			 
0cd2 01 41 00			ld bc,041h 
0cd5 cd ed 0c			call delayloop 
0cd8 c1				pop bc 
0cd9 05				dec b 
0cda 20 f5			jr nz,msdelay 
0cdc			 
0cdc			;if CPU_CLOCK_8MHZ 
0cdc			;msdelay8: 
0cdc			;	push bc 
0cdc			;	 
0cdc			; 
0cdc			;	ld bc,041h 
0cdc			;	call delayloop 
0cdc			;	pop bc 
0cdc			;	dec b 
0cdc			;	jr nz,msdelay8 
0cdc			;endif 
0cdc			 
0cdc			 
0cdc c1				pop bc 
0cdd c9				ret 
0cde			 
0cde			 
0cde			delay250ms: 
0cde				;push de 
0cde 01 00 40			ld bc, 04000h 
0ce1 c3 ed 0c			jp delayloop 
0ce4			delay500ms: 
0ce4				;push de 
0ce4 01 00 80			ld bc, 08000h 
0ce7 c3 ed 0c			jp delayloop 
0cea			delay1s: 
0cea				;push bc 
0cea			   ; Clobbers A, d and e 
0cea 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0ced			delayloop: 
0ced c5			    push bc 
0cee			 
0cee			if BASE_CPM 
0cee				ld bc, CPM_DELAY_TUNE 
0cee			.cpmloop: 
0cee				push bc 
0cee			 
0cee			endif 
0cee			 
0cee			 
0cee			 
0cee			delayloopi: 
0cee			;	push bc 
0cee			;.dl: 
0cee cb 47		    bit     0,a    	; 8 
0cf0 cb 47		    bit     0,a    	; 8 
0cf2 cb 47		    bit     0,a    	; 8 
0cf4 e6 ff		    and     255  	; 7 
0cf6 0b			    dec     bc      	; 6 
0cf7 79			    ld      a,c     	; 4 
0cf8 b0			    or      b     	; 4 
0cf9 c2 ee 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cfc			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cfc				;pop de 
0cfc			;pop bc 
0cfc			 
0cfc			if BASE_CPM 
0cfc				pop bc 
0cfc				 
0cfc			    dec     bc      	; 6 
0cfc			    ld      a,c     	; 4 
0cfc			    or      b     	; 4 
0cfc			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cfc				 
0cfc			 
0cfc			endif 
0cfc			;if CPU_CLOCK_8MHZ 
0cfc			;    pop bc 
0cfc			;    push bc 
0cfc			;.dl8: 
0cfc			;    bit     0,a    	; 8 
0cfc			;    bit     0,a    	; 8 
0cfc			;    bit     0,a    	; 8 
0cfc			;    and     255  	; 7 
0cfc			;    dec     bc      	; 6 
0cfc			;    ld      a,c     	; 4 
0cfc			;    or      b     	; 4 
0cfc			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cfc			;endif 
0cfc			 
0cfc			;if CPU_CLOCK_10MHZ 
0cfc			;    pop bc 
0cfc			;    push bc 
0cfc			;.dl8: 
0cfc			;    bit     0,a    	; 8 
0cfc			;    bit     0,a    	; 8 
0cfc			;    bit     0,a    	; 8 
0cfc			;    and     255  	; 7 
0cfc			;    dec     bc      	; 6 
0cfc			;    ld      a,c     	; 4 
0cfc			;    or      b     	; 4 
0cfc			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cfc			;endif 
0cfc c1			    pop bc 
0cfd			 
0cfd c9				ret 
0cfe			 
0cfe			 
0cfe			 
0cfe			; eof 
# End of file firmware_general.asm
0cfe			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0cfe			; display routines that use the physical hardware abstraction layer 
0cfe			 
0cfe			 
0cfe			; Display an activity indicator 
0cfe			; Each call returns the new char pointed to in hl 
0cfe			 
0cfe			active: 
0cfe 3a 01 fb			ld a, (display_active) 
0d01 fe 06			cp 6 
0d03			 
0d03 20 02			jr nz, .sne 
0d05				; gone past the last one reset sequence 
0d05 3e ff			ld a, 255 
0d07			 
0d07			.sne:   
0d07				; get the next char in seq 
0d07 3c				inc a 
0d08 32 01 fb			ld (display_active), a 
0d0b			 
0d0b				; look up the string in the table 
0d0b 21 22 0d			ld hl, actseq 
0d0e cb 27			sla a 
0d10 cd db 0f			call addatohl 
0d13 cd 6c 23			call loadwordinhl 
0d16			 
0d16				; forth will write the to string when pushing so move from rom to ram 
0d16			 
0d16 11 02 fb			ld de, display_active+1 
0d19 01 02 00			ld bc, 2 
0d1c ed b0			ldir 
0d1e			 
0d1e 21 02 fb			ld hl, display_active+1 
0d21 c9				ret 
0d22				 
0d22				 
0d22			 
0d22			 
0d22			;db "|/-\|-\" 
0d22			 
0d22			actseq: 
0d22			 
0d22 30 0d		dw spin0 
0d24 32 0d		dw spin1 
0d26 34 0d		dw spin2 
0d28 36 0d		dw spin3 
0d2a 34 0d		dw spin2 
0d2c 32 0d		dw spin1 
0d2e 30 0d		dw spin0 
0d30			 
0d30 .. 00		spin0: db " ", 0 
0d32 .. 00		spin1: db "-", 0 
0d34 .. 00		spin2: db "+", 0 
0d36 .. 00		spin3: db "#", 0 
0d38			 
0d38			 
0d38			; information window 
0d38			 
0d38			; pass hl with 1st string to display 
0d38			; pass de with 2nd string to display 
0d38			 
0d38			info_panel: 
0d38 e5				push hl 
0d39			 
0d39 2a 07 fb			ld hl, (display_fb_active) 
0d3c e5				push hl    ; future de destination 
0d3d 21 ec fc				ld hl, display_fb0 
0d40 22 07 fb				ld (display_fb_active), hl 
0d43			 
0d43			;	call clear_display 
0d43			 
0d43				if BASE_CPM 
0d43				ld a, '.' 
0d43				else 
0d43 3e a5			ld a, 165 
0d45				endif 
0d45 cd ac 0d			call fill_display 
0d48			 
0d48			 
0d48 3e 55			ld a, display_row_3 + 5 
0d4a cd ba 0d			call str_at_display 
0d4d			 
0d4d e1				pop hl 
0d4e d1				pop de 
0d4f			 
0d4f e5				push hl 
0d50			 
0d50			 
0d50 3e 2d			ld a, display_row_2 + 5 
0d52 cd ba 0d			call str_at_display 
0d55			 
0d55			 
0d55 cd ca 0d			call update_display 
0d58 cd a7 1f			call next_page_prompt 
0d5b cd a7 0d			call clear_display 
0d5e			 
0d5e				 
0d5e 21 4b fc				ld hl, display_fb1 
0d61 22 07 fb				ld (display_fb_active), hl 
0d64 cd ca 0d			call update_display 
0d67			 
0d67 e1				pop hl 
0d68			 
0d68 c9				ret 
0d69			 
0d69			 
0d69			 
0d69			 
0d69			; TODO windowing? 
0d69			 
0d69			; TODO scroll line up 
0d69			 
0d69			scroll_up: 
0d69			 
0d69 e5				push hl 
0d6a d5				push de 
0d6b c5				push bc 
0d6c			 
0d6c				; get frame buffer  
0d6c			 
0d6c 2a 07 fb			ld hl, (display_fb_active) 
0d6f e5				push hl    ; future de destination 
0d70			 
0d70 11 28 00			ld  de, display_cols 
0d73 19				add hl, de 
0d74			 
0d74 d1				pop de 
0d75			 
0d75				;ex de, hl 
0d75 01 9f 00			ld bc, display_fb_len -1  
0d78			;if DEBUG_FORTH_WORDS 
0d78			;	DMARK "SCL" 
0d78			;	CALLMONITOR 
0d78			;endif	 
0d78 ed b0			ldir 
0d7a			 
0d7a				; wipe bottom row 
0d7a			 
0d7a			 
0d7a 2a 07 fb			ld hl, (display_fb_active) 
0d7d 11 a0 00			ld de, display_cols*display_rows 
0d80 19				add hl, de 
0d81 06 28			ld b, display_cols 
0d83 3e 20			ld a, ' ' 
0d85			.scwipe: 
0d85 77				ld (hl), a 
0d86 2b				dec hl 
0d87 10 fc			djnz .scwipe 
0d89			 
0d89				;pop hl 
0d89			 
0d89 c1				pop bc 
0d8a d1				pop de 
0d8b e1				pop hl 
0d8c			 
0d8c c9				ret 
0d8d			 
0d8d			 
0d8d			;scroll_upo: 
0d8d			;	ld de, display_row_1 
0d8d			 ;	ld hl, display_row_2 
0d8d			;	ld bc, display_cols 
0d8d			;	ldir 
0d8d			;	ld de, display_row_2 
0d8d			 ;	ld hl, display_row_3 
0d8d			;	ld bc, display_cols 
0d8d			;	ldir 
0d8d			;	ld de, display_row_3 
0d8d			 ;	ld hl, display_row_4 
0d8d			;	ld bc, display_cols 
0d8d			;	ldir 
0d8d			 
0d8d			; TODO clear row 4 
0d8d			 
0d8d			;	ret 
0d8d			 
0d8d				 
0d8d			scroll_down: 
0d8d			 
0d8d e5				push hl 
0d8e d5				push de 
0d8f c5				push bc 
0d90			 
0d90				; get frame buffer  
0d90			 
0d90 2a 07 fb			ld hl, (display_fb_active) 
0d93			 
0d93 11 9f 00			ld de, display_fb_len - 1 
0d96 19				add hl, de 
0d97			 
0d97 e5			push hl    ; future de destination 
0d98			 
0d98 11 28 00			ld  de, display_cols 
0d9b ed 52			sbc hl, de 
0d9d			 
0d9d			 
0d9d d1				pop de 
0d9e			 
0d9e			;	ex de, hl 
0d9e 01 9f 00			ld bc, display_fb_len -1  
0da1			 
0da1			 
0da1				 
0da1			 
0da1 ed b0			ldir 
0da3			 
0da3				; wipe bottom row 
0da3			 
0da3			 
0da3			;	ld hl, (display_fb_active) 
0da3			;;	ld de, display_cols*display_rows 
0da3			;;	add hl, de 
0da3			;	ld b, display_cols 
0da3			;	ld a, ' ' 
0da3			;.scwiped: 
0da3			;	ld (hl), a 
0da3			;	dec hl 
0da3			;	djnz .scwiped 
0da3			 
0da3				;pop hl 
0da3			 
0da3 c1				pop bc 
0da4 d1				pop de 
0da5 e1				pop hl 
0da6			 
0da6 c9				ret 
0da7			;scroll_down: 
0da7			;	ld de, display_row_4 
0da7			;	ld hl, display_row_3 
0da7			;	ld bc, display_cols 
0da7			;	ldir 
0da7			;	ld de, display_row_3 
0da7			; 	ld hl, display_row_2 
0da7			;	ld bc, display_cols 
0da7			;	ldir 
0da7			;	ld de, display_row_2 
0da7			;	ld hl, display_row_1 
0da7			;	ld bc, display_cols 
0da7			;	ldir 
0da7			;;; TODO clear row 1 
0da7			;	ret 
0da7			 
0da7			 
0da7			 
0da7			 
0da7			 
0da7			; clear active frame buffer 
0da7			 
0da7			clear_display: 
0da7 3e 20			ld a, ' ' 
0da9 c3 ac 0d			jp fill_display 
0dac			 
0dac			; fill active frame buffer with a char in A 
0dac			 
0dac			fill_display: 
0dac 06 a0			ld b,display_fb_len 
0dae 2a 07 fb			ld hl, (display_fb_active) 
0db1 77			.fd1:	ld (hl),a 
0db2 23				inc hl 
0db3 10 fc			djnz .fd1 
0db5 23				inc hl 
0db6 3e 00			ld a,0 
0db8 77				ld (hl),a 
0db9			 
0db9			 
0db9 c9				ret 
0dba			; Write string (DE) at pos (A) to active frame buffer 
0dba			 
0dba 2a 07 fb		str_at_display:    ld hl,(display_fb_active) 
0dbd 06 00					ld b,0 
0dbf 4f					ld c,a 
0dc0 09					add hl,bc 
0dc1 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0dc2 b7			            OR   A              ;Null terminator? 
0dc3 c8			            RET  Z              ;Yes, so finished 
0dc4 77					ld (hl),a 
0dc5 23				inc hl 
0dc6 13			            INC  DE             ;Point to next character 
0dc7 18 f8		            JR   .sad1     ;Repeat 
0dc9 c9					ret 
0dca			 
0dca			; using current frame buffer write to physical display 
0dca			 
0dca			update_display: 
0dca e5				push hl 
0dcb 2a 07 fb			ld hl, (display_fb_active) 
0dce cd 85 6f			call write_display 
0dd1 e1				pop hl 
0dd2 c9				ret 
0dd3			 
0dd3			; TODO scrolling 
0dd3			 
0dd3			 
0dd3			; move cursor right one char 
0dd3			cursor_right: 
0dd3			 
0dd3				; TODO shift right 
0dd3				; TODO if beyond max col 
0dd3				; TODO       cursor_next_line 
0dd3			 
0dd3 c9				ret 
0dd4			 
0dd4			 
0dd4			cursor_next_line: 
0dd4				; TODO first char 
0dd4				; TODO line down 
0dd4				; TODO if past last row 
0dd4				; TODO    scroll up 
0dd4			 
0dd4 c9				ret 
0dd5			 
0dd5			cursor_left: 
0dd5				; TODO shift left 
0dd5				; TODO if beyond left  
0dd5				; TODO     cursor prev line 
0dd5				 
0dd5 c9				ret 
0dd6			 
0dd6			cursor_prev_line: 
0dd6				; TODO last char 
0dd6				; TODO line up 
0dd6				; TODO if past first row 
0dd6				; TODO   scroll down 
0dd6			 
0dd6 c9				ret 
0dd7			 
0dd7			 
0dd7			cout: 
0dd7				; A - char 
0dd7 c9				ret 
0dd8			 
0dd8			 
0dd8			; Display a menu and allow item selection (optional toggle items) 
0dd8			; 
0dd8			; format: 
0dd8			; hl pointer to word array with zero term for items 
0dd8			; e.g.    db item1 
0dd8			;         db .... 
0dd8			;         db 0 
0dd8			; 
0dd8			; a = starting menu item  
0dd8			; 
0dd8			; de = pointer item toggle array   (todo) 
0dd8			; 
0dd8			; returns item selected in a 1-... 
0dd8			; returns 0 if back button pressed 
0dd8			; 
0dd8			; NOTE: Uses system frame buffer to display 
0dd8			; 
0dd8			; LEFT, Q = go back 
0dd8			; RIGHT, SPACE, CR = select 
0dd8			; UP, A - Up 
0dd8			; DOWN, Z - Down 
0dd8			 
0dd8			 
0dd8			 
0dd8			 
0dd8			 
0dd8			menu: 
0dd8			 
0dd8					; keep array pointer 
0dd8			 
0dd8 22 ae f9				ld (store_tmp1), hl 
0ddb 32 ac f9				ld (store_tmp2), a 
0dde			 
0dde					; check for key bounce 
0dde			 
0dde			if BASE_KEV 
0dde			 
0dde cd d0 72		.mbounce:	call cin 
0de1 fe 00				cp 0 
0de3 20 f9				jr nz, .mbounce 
0de5			endif 
0de5					; for ease use ex 
0de5			 
0de5					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0de5 21 ec fc				ld hl, display_fb0 
0de8 22 07 fb				ld (display_fb_active), hl 
0deb			 
0deb cd a7 0d		.mloop:		call clear_display 
0dee cd ca 0d				call update_display 
0df1			 
0df1					; draw selection id '>' at 1 
0df1			 
0df1					; init start of list display 
0df1			 
0df1 3e 05				ld a, 5 
0df3 32 aa f9				ld (store_tmp3), a   ; display row count 
0df6 3a ac f9				ld a,( store_tmp2) 
0df9 32 ad f9				ld (store_tmp2+1), a   ; display item count 
0dfc			 
0dfc					 
0dfc			.mitem:	 
0dfc			 
0dfc			 
0dfc 3a ad f9				ld a,(store_tmp2+1) 
0dff 6f					ld l, a 
0e00 26 00				ld h, 0 
0e02 29					add hl, hl 
0e03 ed 5b ae f9			ld de, (store_tmp1) 
0e07 19					add hl, de 
0e08 7e					ld a, (hl) 
0e09 23					inc hl 
0e0a 66					ld h,(hl) 
0e0b 6f					ld l, a 
0e0c			 
0e0c cd 04 10				call ishlzero 
0e0f 28 1a				jr z, .mdone 
0e11			 
0e11 eb					ex de, hl 
0e12 3a aa f9				ld a, (store_tmp3) 
0e15 cd ba 0d				call str_at_display 
0e18					 
0e18			 
0e18					; next item 
0e18 3a ad f9				ld a, (store_tmp2+1) 
0e1b 3c					inc a 
0e1c 32 ad f9				ld (store_tmp2+1), a   ; display item count 
0e1f			 
0e1f			 		; next row 
0e1f			 
0e1f 3a aa f9				ld a, (store_tmp3) 
0e22 c6 28				add display_cols 
0e24 32 aa f9				ld (store_tmp3), a 
0e27			 
0e27					; at end of screen? 
0e27			 
0e27 fe 10				cp display_rows*4 
0e29 20 d1				jr nz, .mitem 
0e2b			 
0e2b			 
0e2b			.mdone: 
0e2b cd 04 10				call ishlzero 
0e2e 28 08				jr z, .nodn 
0e30			 
0e30 3e 78				ld a, display_row_4 
0e32 11 b1 0e				ld de, .mdown 
0e35 cd ba 0d				call str_at_display 
0e38			 
0e38					; draw options to fill the screens with active item on line 1 
0e38					; if current option is 2 or more then display ^ in top 
0e38			 
0e38 3a ac f9		.nodn:		ld a, (store_tmp2) 
0e3b fe 00				cp 0 
0e3d 28 08				jr z, .noup 
0e3f			 
0e3f 3e 00				ld a, 0 
0e41 11 af 0e				ld de, .mup 
0e44 cd ba 0d				call str_at_display 
0e47			 
0e47 3e 02		.noup:		ld a, 2 
0e49 11 ad 0e				ld de, .msel 
0e4c cd ba 0d				call str_at_display 
0e4f			 
0e4f					; if current option + 1 is not null then display V in bottom 
0e4f					; get key 
0e4f cd ca 0d				call update_display 
0e52			 
0e52			 
0e52					; handle key 
0e52			 
0e52 cd bf 72				call cin_wait 
0e55			 
0e55 fe 05				cp KEY_UP 
0e57 28 2b				jr z, .mgoup 
0e59 fe 61				cp 'a' 
0e5b 28 27				jr z, .mgoup 
0e5d fe 0a				cp KEY_DOWN 
0e5f 28 32				jr z, .mgod 
0e61 fe 7a				cp 'z' 
0e63 28 2e				jr z, .mgod 
0e65 fe 20				cp ' ' 
0e67 28 34				jr z, .goend 
0e69 fe 0c				cp KEY_RIGHT 
0e6b 28 30				jr z, .goend 
0e6d fe 0d				cp KEY_CR 
0e6f 28 2c				jr z, .goend 
0e71 fe 71				cp 'q' 
0e73 28 0b				jr z, .goback 
0e75			 
0e75 fe 0b				cp KEY_LEFT 
0e77 28 07				jr z, .goback 
0e79 fe 08				cp KEY_BS 
0e7b 28 03				jr z, .goback 
0e7d c3 eb 0d				jp .mloop 
0e80			 
0e80			.goback: 
0e80 3e 00			ld a, 0 
0e82 18 1d			jr .goend2 
0e84			 
0e84				; move up one 
0e84			.mgoup: 
0e84 3a ac f9				ld a, (store_tmp2) 
0e87 fe 00				cp 0 
0e89 ca eb 0d				jp z, .mloop 
0e8c 3d					dec a 
0e8d 32 ac f9				ld (store_tmp2), a 
0e90 c3 eb 0d				jp .mloop 
0e93			 
0e93				; move down one 
0e93			.mgod: 
0e93 3a ac f9				ld a, (store_tmp2) 
0e96 3c					inc a 
0e97 32 ac f9				ld (store_tmp2), a 
0e9a c3 eb 0d				jp .mloop 
0e9d			 
0e9d			 
0e9d			.goend: 
0e9d					; get selected item number 
0e9d			 
0e9d 3a ac f9				ld a, (store_tmp2) 
0ea0 3c					inc a 
0ea1			 
0ea1			.goend2: 
0ea1 f5					push af 
0ea2			 
0ea2					; restore active fb 
0ea2					; TODO BUG assumes fb1 
0ea2			 
0ea2 21 4b fc				ld hl, display_fb1 
0ea5 22 07 fb				ld (display_fb_active), hl 
0ea8			 
0ea8					; restore main regs 
0ea8			 
0ea8			 
0ea8 cd ca 0d				call update_display 
0eab			 
0eab f1					pop af 
0eac			 
0eac c9				ret 
0ead			 
0ead .. 00		.msel:   db ">",0 
0eaf .. 00		.mup:   db "^",0 
0eb1 .. 00		.mdown:   db "v",0 
0eb3			 
0eb3			 
0eb3			; eof 
0eb3			 
# End of file firmware_display.asm
0eb3			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0eb3			; random number generators 
0eb3			 
0eb3			 
0eb3			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0eb3			 
0eb3			 
0eb3			;-----> Generate a random number 
0eb3			; output a=answer 0<=a<=255 
0eb3			; all registers are preserved except: af 
0eb3			random: 
0eb3 e5			        push    hl 
0eb4 d5			        push    de 
0eb5 2a e6 fa		        ld      hl,(randData) 
0eb8 ed 5f		        ld      a,r 
0eba 57			        ld      d,a 
0ebb 5e			        ld      e,(hl) 
0ebc 19			        add     hl,de 
0ebd 85			        add     a,l 
0ebe ac			        xor     h 
0ebf 22 e6 fa		        ld      (randData),hl 
0ec2 d1			        pop     de 
0ec3 e1			        pop     hl 
0ec4 c9			        ret 
0ec5			 
0ec5			 
0ec5			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0ec5			 
0ec5			 
0ec5			 
0ec5			;------LFSR------ 
0ec5			;James Montelongo 
0ec5			;optimized by Spencer Putt 
0ec5			;out: 
0ec5			; a = 8 bit random number 
0ec5			RandLFSR: 
0ec5 21 ec fa		        ld hl,LFSRSeed+4 
0ec8 5e			        ld e,(hl) 
0ec9 23			        inc hl 
0eca 56			        ld d,(hl) 
0ecb 23			        inc hl 
0ecc 4e			        ld c,(hl) 
0ecd 23			        inc hl 
0ece 7e			        ld a,(hl) 
0ecf 47			        ld b,a 
0ed0 cb 13		        rl e  
0ed2 cb 12			rl d 
0ed4 cb 11		        rl c  
0ed6 17				rla 
0ed7 cb 13		        rl e  
0ed9 cb 12			rl d 
0edb cb 11		        rl c  
0edd 17				rla 
0ede cb 13		        rl e  
0ee0 cb 12			rl d 
0ee2 cb 11		        rl c  
0ee4 17				rla 
0ee5 67			        ld h,a 
0ee6 cb 13		        rl e  
0ee8 cb 12			rl d 
0eea cb 11		        rl c  
0eec 17				rla 
0eed a8			        xor b 
0eee cb 13		        rl e  
0ef0 cb 12			rl d 
0ef2 ac			        xor h 
0ef3 a9			        xor c 
0ef4 aa			        xor d 
0ef5 21 ee fa		        ld hl,LFSRSeed+6 
0ef8 11 ef fa		        ld de,LFSRSeed+7 
0efb 01 07 00		        ld bc,7 
0efe ed b8		        lddr 
0f00 12			        ld (de),a 
0f01 c9			        ret 
0f02			 
0f02			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0f02			 
0f02			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0f02			 
0f02			 
0f02			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0f02			 
0f02			prng16: 
0f02			;Inputs: 
0f02			;   (seed1) contains a 16-bit seed value 
0f02			;   (seed2) contains a NON-ZERO 16-bit seed value 
0f02			;Outputs: 
0f02			;   HL is the result 
0f02			;   BC is the result of the LCG, so not that great of quality 
0f02			;   DE is preserved 
0f02			;Destroys: 
0f02			;   AF 
0f02			;cycle: 4,294,901,760 (almost 4.3 billion) 
0f02			;160cc 
0f02			;26 bytes 
0f02 2a e0 fa		    ld hl,(seed1) 
0f05 44			    ld b,h 
0f06 4d			    ld c,l 
0f07 29			    add hl,hl 
0f08 29			    add hl,hl 
0f09 2c			    inc l 
0f0a 09			    add hl,bc 
0f0b 22 e0 fa		    ld (seed1),hl 
0f0e 2a de fa		    ld hl,(seed2) 
0f11 29			    add hl,hl 
0f12 9f			    sbc a,a 
0f13 e6 2d		    and %00101101 
0f15 ad			    xor l 
0f16 6f			    ld l,a 
0f17 22 de fa		    ld (seed2),hl 
0f1a 09			    add hl,bc 
0f1b c9			    ret 
0f1c			 
0f1c			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f1c			 
0f1c			rand32: 
0f1c			;Inputs: 
0f1c			;   (seed1_0) holds the lower 16 bits of the first seed 
0f1c			;   (seed1_1) holds the upper 16 bits of the first seed 
0f1c			;   (seed2_0) holds the lower 16 bits of the second seed 
0f1c			;   (seed2_1) holds the upper 16 bits of the second seed 
0f1c			;   **NOTE: seed2 must be non-zero 
0f1c			;Outputs: 
0f1c			;   HL is the result 
0f1c			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f1c			;Destroys: 
0f1c			;   AF 
0f1c			;Tested and passes all CAcert tests 
0f1c			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f1c			;it has a period of 18,446,744,069,414,584,320 
0f1c			;roughly 18.4 quintillion. 
0f1c			;LFSR taps: 0,2,6,7  = 11000101 
0f1c			;291cc 
0f1c			;seed1_0=$+1 
0f1c			;    ld hl,12345 
0f1c			;seed1_1=$+1 
0f1c			;    ld de,6789 
0f1c			;    ld b,h 
0f1c			;    ld c,l 
0f1c			;    add hl,hl \ rl e \ rl d 
0f1c			;    add hl,hl \ rl e \ rl d 
0f1c			;    inc l 
0f1c			;    add hl,bc 
0f1c			;    ld (seed1_0),hl 
0f1c			;    ld hl,(seed1_1) 
0f1c			;    adc hl,de 
0f1c			;    ld (seed1_1),hl 
0f1c			;    ex de,hl 
0f1c			;seed2_0=$+1 
0f1c			;    ld hl,9876 
0f1c			;seed2_1=$+1 
0f1c			;    ld bc,54321 
0f1c			;    add hl,hl \ rl c \ rl b 
0f1c			;    ld (seed2_1),bc 
0f1c			;    sbc a,a 
0f1c			;    and %11000101 
0f1c			;    xor l 
0f1c			;    ld l,a 
0f1c			;    ld (seed2_0),hl 
0f1c			;    ex de,hl 
0f1c			;    add hl,bc 
0f1c			;    ret 
0f1c			; 
0f1c			 
0f1c			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f1c			; 20 bytes, 86 cycles (excluding ret) 
0f1c			 
0f1c			; returns   hl = pseudorandom number 
0f1c			; corrupts   a 
0f1c			 
0f1c			; generates 16-bit pseudorandom numbers with a period of 65535 
0f1c			; using the xorshift method: 
0f1c			 
0f1c			; hl ^= hl << 7 
0f1c			; hl ^= hl >> 9 
0f1c			; hl ^= hl << 8 
0f1c			 
0f1c			; some alternative shift triplets which also perform well are: 
0f1c			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f1c			 
0f1c			;  org 32768 
0f1c			 
0f1c			xrnd: 
0f1c 2a e4 fa		  ld hl,(xrandc)       ; seed must not be 0 
0f1f 3e 00		  ld a,0 
0f21 bd			  cp l 
0f22 20 02		  jr nz, .xrnd1 
0f24 2e 01		  ld l, 1 
0f26			.xrnd1: 
0f26			 
0f26 7c			  ld a,h 
0f27 1f			  rra 
0f28 7d			  ld a,l 
0f29 1f			  rra 
0f2a ac			  xor h 
0f2b 67			  ld h,a 
0f2c 7d			  ld a,l 
0f2d 1f			  rra 
0f2e 7c			  ld a,h 
0f2f 1f			  rra 
0f30 ad			  xor l 
0f31 6f			  ld l,a 
0f32 ac			  xor h 
0f33 67			  ld h,a 
0f34			 
0f34 22 e4 fa		  ld (xrandc),hl 
0f37			 
0f37 c9			  ret 
0f38			;  
0f38			 
0f38			 
0f38			;;;; int maths 
0f38			 
0f38			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f38			; Divide 16-bit values (with 16-bit result) 
0f38			; In: Divide BC by divider DE 
0f38			; Out: BC = result, HL = rest 
0f38			; 
0f38			Div16: 
0f38 21 00 00		    ld hl,0 
0f3b 78			    ld a,b 
0f3c 06 08		    ld b,8 
0f3e			Div16_Loop1: 
0f3e 17			    rla 
0f3f ed 6a		    adc hl,hl 
0f41 ed 52		    sbc hl,de 
0f43 30 01		    jr nc,Div16_NoAdd1 
0f45 19			    add hl,de 
0f46			Div16_NoAdd1: 
0f46 10 f6		    djnz Div16_Loop1 
0f48 17			    rla 
0f49 2f			    cpl 
0f4a 47			    ld b,a 
0f4b 79			    ld a,c 
0f4c 48			    ld c,b 
0f4d 06 08		    ld b,8 
0f4f			Div16_Loop2: 
0f4f 17			    rla 
0f50 ed 6a		    adc hl,hl 
0f52 ed 52		    sbc hl,de 
0f54 30 01		    jr nc,Div16_NoAdd2 
0f56 19			    add hl,de 
0f57			Div16_NoAdd2: 
0f57 10 f6		    djnz Div16_Loop2 
0f59 17			    rla 
0f5a 2f			    cpl 
0f5b 41			    ld b,c 
0f5c 4f			    ld c,a 
0f5d c9			ret 
0f5e			 
0f5e			 
0f5e			;http://z80-heaven.wikidot.com/math 
0f5e			; 
0f5e			;Inputs: 
0f5e			;     DE and A are factors 
0f5e			;Outputs: 
0f5e			;     A is not changed 
0f5e			;     B is 0 
0f5e			;     C is not changed 
0f5e			;     DE is not changed 
0f5e			;     HL is the product 
0f5e			;Time: 
0f5e			;     342+6x 
0f5e			; 
0f5e			Mult16: 
0f5e			 
0f5e 06 08		     ld b,8          ;7           7 
0f60 21 00 00		     ld hl,0         ;10         10 
0f63 29			       add hl,hl     ;11*8       88 
0f64 07			       rlca          ;4*8        32 
0f65 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f67 19			         add hl,de   ;--         -- 
0f68 10 f9		       djnz $-5      ;13*7+8     99 
0f6a c9			ret 
0f6b			 
0f6b			; 
0f6b			; Square root of 16-bit value 
0f6b			; In:  HL = value 
0f6b			; Out:  D = result (rounded down) 
0f6b			; 
0f6b			;Sqr16: 
0f6b			;    ld de,#0040 
0f6b			;    ld a,l 
0f6b			;    ld l,h 
0f6b			;    ld h,d 
0f6b			;    or a 
0f6b			;    ld b,8 
0f6b			;Sqr16_Loop: 
0f6b			;    sbc hl,de 
0f6b			;    jr nc,Sqr16_Skip 
0f6b			;    add hl,de 
0f6b			;Sqr16_Skip: 
0f6b			;    ccf 
0f6b			;    rl d 
0f6b			;    add a,a 
0f6b			;    adc hl,hl 
0f6b			;    add a,a 
0f6b			;    adc hl,hl 
0f6b			;    djnz Sqr16_Loop 
0f6b			;    ret 
0f6b			; 
0f6b			; 
0f6b			; Divide 8-bit values 
0f6b			; In: Divide E by divider C 
0f6b			; Out: A = result, B = rest 
0f6b			; 
0f6b			Div8: 
0f6b af			    xor a 
0f6c 06 08		    ld b,8 
0f6e			Div8_Loop: 
0f6e cb 13		    rl e 
0f70 17			    rla 
0f71 91			    sub c 
0f72 30 01		    jr nc,Div8_NoAdd 
0f74 81			    add a,c 
0f75			Div8_NoAdd: 
0f75 10 f7		    djnz Div8_Loop 
0f77 47			    ld b,a 
0f78 7b			    ld a,e 
0f79 17			    rla 
0f7a 2f			    cpl 
0f7b c9			    ret 
0f7c			 
0f7c			; 
0f7c			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f7c			; In: Multiply A with DE 
0f7c			; Out: HL = result 
0f7c			; 
0f7c			Mult12U: 
0f7c 2e 00		    ld l,0 
0f7e 87			    add a,a 
0f7f 30 01		    jr nc,Mult12U_NoAdd0 
0f81 19			    add hl,de 
0f82			Mult12U_NoAdd0: 
0f82 29			    add hl,hl 
0f83 87			    add a,a 
0f84 30 01		    jr nc,Mult12U_NoAdd1 
0f86 19			    add hl,de 
0f87			Mult12U_NoAdd1: 
0f87 29			    add hl,hl 
0f88 87			    add a,a 
0f89 30 01		    jr nc,Mult12U_NoAdd2 
0f8b 19			    add hl,de 
0f8c			Mult12U_NoAdd2: 
0f8c 29			    add hl,hl 
0f8d 87			    add a,a 
0f8e 30 01		    jr nc,Mult12U_NoAdd3 
0f90 19			    add hl,de 
0f91			Mult12U_NoAdd3: 
0f91 29			    add hl,hl 
0f92 87			    add a,a 
0f93 30 01		    jr nc,Mult12U_NoAdd4 
0f95 19			    add hl,de 
0f96			Mult12U_NoAdd4: 
0f96 29			    add hl,hl 
0f97 87			    add a,a 
0f98 30 01		    jr nc,Mult12U_NoAdd5 
0f9a 19			    add hl,de 
0f9b			Mult12U_NoAdd5: 
0f9b 29			    add hl,hl 
0f9c 87			    add a,a 
0f9d 30 01		    jr nc,Mult12U_NoAdd6 
0f9f 19			    add hl,de 
0fa0			Mult12U_NoAdd6: 
0fa0 29			    add hl,hl 
0fa1 87			    add a,a 
0fa2 d0			    ret nc 
0fa3 19			    add hl,de 
0fa4 c9			    ret 
0fa5			 
0fa5			; 
0fa5			; Multiply 8-bit value with a 16-bit value (right rotating) 
0fa5			; In: Multiply A with DE 
0fa5			;      Put lowest value in A for most efficient calculation 
0fa5			; Out: HL = result 
0fa5			; 
0fa5			Mult12R: 
0fa5 21 00 00		    ld hl,0 
0fa8			Mult12R_Loop: 
0fa8 cb 3f		    srl a 
0faa 30 01		    jr nc,Mult12R_NoAdd 
0fac 19			    add hl,de 
0fad			Mult12R_NoAdd: 
0fad cb 23		    sla e 
0faf cb 12		    rl d 
0fb1 b7			    or a 
0fb2 c2 a8 0f		    jp nz,Mult12R_Loop 
0fb5 c9			    ret 
0fb6			 
0fb6			; 
0fb6			; Multiply 16-bit values (with 32-bit result) 
0fb6			; In: Multiply BC with DE 
0fb6			; Out: BCHL = result 
0fb6			; 
0fb6			Mult32: 
0fb6 79			    ld a,c 
0fb7 48			    ld c,b 
0fb8 21 00 00		    ld hl,0 
0fbb 06 10		    ld b,16 
0fbd			Mult32_Loop: 
0fbd 29			    add hl,hl 
0fbe 17			    rla 
0fbf cb 11		    rl c 
0fc1 30 07		    jr nc,Mult32_NoAdd 
0fc3 19			    add hl,de 
0fc4 ce 00		    adc a,0 
0fc6 d2 ca 0f		    jp nc,Mult32_NoAdd 
0fc9 0c			    inc c 
0fca			Mult32_NoAdd: 
0fca 10 f1		    djnz Mult32_Loop 
0fcc 41			    ld b,c 
0fcd 4f			    ld c,a 
0fce c9			    ret 
0fcf			 
0fcf			 
0fcf			 
0fcf			; 
0fcf			; Multiply 8-bit values 
0fcf			; In:  Multiply H with E 
0fcf			; Out: HL = result 
0fcf			; 
0fcf			Mult8: 
0fcf 16 00		    ld d,0 
0fd1 6a			    ld l,d 
0fd2 06 08		    ld b,8 
0fd4			Mult8_Loop: 
0fd4 29			    add hl,hl 
0fd5 30 01		    jr nc,Mult8_NoAdd 
0fd7 19			    add hl,de 
0fd8			Mult8_NoAdd: 
0fd8 10 fa		    djnz Mult8_Loop 
0fda c9			    ret 
0fdb			 
0fdb			 
0fdb			 
0fdb			 
0fdb			 
0fdb			 
0fdb			 
0fdb			 
0fdb			;;http://z80-heaven.wikidot.com/math 
0fdb			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fdb			; 
0fdb			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fdb			;     ld a,16        ;7 
0fdb			;     ld hl,0        ;10 
0fdb			;     jp $+5         ;10 
0fdb			;.DivLoop: 
0fdb			;       add hl,bc    ;-- 
0fdb			;       dec a        ;64 
0fdb			;       jr z,.DivLoopEnd        ;86 
0fdb			; 
0fdb			;       sla e        ;128 
0fdb			;       rl d         ;128 
0fdb			;       adc hl,hl    ;240 
0fdb			;       sbc hl,bc    ;240 
0fdb			;       jr nc,.DivLoop ;23|21 
0fdb			;       inc e        ;-- 
0fdb			;       jp .DivLoop+1 
0fdb			; 
0fdb			;.DivLoopEnd: 
0fdb			 
0fdb			;HL_Div_C: 
0fdb			;Inputs: 
0fdb			;     HL is the numerator 
0fdb			;     C is the denominator 
0fdb			;Outputs: 
0fdb			;     A is the remainder 
0fdb			;     B is 0 
0fdb			;     C is not changed 
0fdb			;     DE is not changed 
0fdb			;     HL is the quotient 
0fdb			; 
0fdb			;       ld b,16 
0fdb			;       xor a 
0fdb			;         add hl,hl 
0fdb			;         rla 
0fdb			;         cp c 
0fdb			;         jr c,$+4 
0fdb			;           inc l 
0fdb			;           sub c 
0fdb			;         djnz $-7 
0fdb			 
0fdb			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fdb			 
0fdb			addatohl: 
0fdb 85			    add   a, l    ; A = A+L 
0fdc 6f			    ld    l, a    ; L = A+L 
0fdd 8c			    adc   a, h    ; A = A+L+H+carry 
0fde 95			    sub   l       ; A = H+carry 
0fdf 67			    ld    h, a    ; H = H+carry 
0fe0 c9			ret 
0fe1			 
0fe1			addatode: 
0fe1 83			    add   a, e    ; A = A+L 
0fe2 5f			    ld    e, a    ; L = A+L 
0fe3 8a			    adc   a, d    ; A = A+L+H+carry 
0fe4 93			    sub   e       ; A = H+carry 
0fe5 57			    ld    d, a    ; H = H+carry 
0fe6 c9			ret 
0fe7			 
0fe7			 
0fe7			addatobc: 
0fe7 81			    add   a, c    ; A = A+L 
0fe8 4f			    ld    c, a    ; L = A+L 
0fe9 88			    adc   a, b    ; A = A+L+H+carry 
0fea 91			    sub   c       ; A = H+carry 
0feb 47			    ld    b, a    ; H = H+carry 
0fec c9			ret 
0fed			 
0fed			subafromhl: 
0fed			   ; If A=0 do nothing 
0fed			    ; Otherwise flip A's sign. Since 
0fed			    ; the upper byte becomes -1, also 
0fed			    ; substract 1 from H. 
0fed ed 44		    neg 
0fef ca f8 0f		    jp    z, Skip 
0ff2 25			    dec   h 
0ff3			     
0ff3			    ; Now add the low byte as usual 
0ff3			    ; Two's complement takes care of 
0ff3			    ; ensuring the result is correct 
0ff3 85			    add   a, l 
0ff4 6f			    ld    l, a 
0ff5 8c			    adc   a, h 
0ff6 95			    sub   l 
0ff7 67			    ld    h, a 
0ff8			Skip: 
0ff8 c9				ret 
0ff9			 
0ff9			 
0ff9			; compare hl and de 
0ff9			; returns:  
0ff9			; if hl = de, z=1, s=0, c0=0 
0ff9			; if hl > de, z=0, s=0, c=0 
0ff9			; if hl < de, z=0, s=1, c=1 
0ff9			cmp16:	 
0ff9 b7				or a 
0ffa ed 52			sbc hl,de 
0ffc e0				ret po 
0ffd 7c				ld a,h 
0ffe 1f				rra 
0fff ee 40			xor 01000000B 
1001 37				scf 
1002 8f				adc a,a 
1003 c9				ret 
1004			 
1004			 
1004			; test if hl contains zero   - A is destroyed 
1004			 
1004			ishlzero:    
1004 b7				or a     ; reset flags 
1005 7c				ld a, h 
1006 b5				or l        	 
1007			 
1007 c9				ret 
1008			 
1008			 
1008			 
1008			 
1008			if FORTH_ENABLE_FLOATMATH 
1008			;include "float/bbcmath.z80" 
1008			include "float/lpfpcalc.asm" 
1008			endif 
1008			 
1008			 
1008			; eof 
1008			 
# End of file firmware_maths.asm
1008			include "firmware_strings.asm"   ; string handling  
1008			 
1008			 
1008			; TODO string len 
1008			; input text string, end on cr with zero term 
1008			; a offset into frame buffer to start prompt 
1008			; d is max length 
1008			; e is display size TODO 
1008			; c is current cursor position 
1008			; hl is ptr to where string will be stored and edited directly 
1008			 
1008			 
1008			; TODO check limit of buffer for new inserts 
1008			; TODO check insert does not push beyond buffer 
1008			; TODO scroll in a limited display area 
1008			; TODO scroll whole screen on page wrap 
1008			 
1008			 
1008			; TODO use LCD cursor? 
1008			 
1008			EDIT_V1: equ 0 
1008			EDIT_V2: equ 1 
1008			 
1008			 
1008			 
1008			if EDIT_V2 
1008			input_str: 
1008			 
1008 32 9f fd			    	ld (input_at_pos),a      ; save display position to start 
100b			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
100b 22 a2 fd				ld (input_start), hl     ; save ptr to buffer 
100e			;		ld a, c 
100e			;		call addatohl 
100e			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
100e 7a					ld a,d 
100f 32 a1 fd			        ld (input_size), a       ; save length of input area 
1012 79					ld a, c 
1013 32 90 fd				ld (input_cursor),a      ; init cursor start position relative to start of string 
1016 7b					ld a,e 
1017 32 a0 fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
101a			 
101a			 
101a					; add a trailing space to make screen refresh nicer 
101a			 
101a					;ld hl, (input_start) 
101a					;push hl 
101a					;ld a, 0 
101a					;call strlent 
101a					;ld a, l 
101a					;pop hl 
101a					;call addatohl 
101a					;dec hl 
101a					;ld a, ' ' 
101a					;ld (hl), a 
101a					;inc hl 
101a					;ld (hl), a 
101a					;inc hl 
101a					;ld a, 0 
101a					;ld (hl), a 
101a			 
101a			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
101a					; init cursor shape if not set by the cin routines 
101a 21 fc fa				ld hl, cursor_shape 
101d			if BASE_KEV 
101d 3e ff				ld a, 255 
101f			else 
101f					ld a, '#' 
101f			endif 
101f 77					ld (hl), a 
1020 23					inc hl 
1021 3e 00				ld a, 0 
1023 77					ld (hl), a 
1024			 
1024 3e 09				ld a, CUR_BLINK_RATE 
1026 32 9b fd				ld (input_cur_flash), a 
1029 3e 01				ld a, 1 
102b 32 9a fd				ld (input_cur_onoff),a 
102e			.inmain:	 
102e			 
102e cd 56 11				call input_disp_ref 
1031			 
1031					; save current length of string 
1031			 
1031 2a a2 fd				ld hl, (input_start) 
1034 3e 00				ld a, 0 
1036 cd 4c 13				call strlent 
1039 7d					ld a,l 
103a 32 95 fd				ld (input_len), a 
103d			 
103d					;call input_disp_oncur 
103d			 
103d					; display current state of input buffer 
103d			 
103d					; clean any backspace chars 
103d			 
103d 3e 20				ld a, " " 
103f 32 fc f0				ld (scratch),a 
1042 3e 00				ld a, 0 
1044 32 fd f0				ld (scratch+1),a 
1047 3a 9f fd				ld a,(input_at_pos) 
104a 85					add l 
104b 11 fc f0				ld de, scratch 
104e cd ba 0d				call str_at_display 
1051			 
1051					; pause 1ms 
1051			 
1051 3e 01				ld a, 1 
1053 cd cf 0c				call aDelayInMS 
1056			 
1056			; display cursor if visible on this cycle 
1056			 
1056					; dec flash counter 
1056 3a 9b fd				ld a, (input_cur_flash) 
1059 3d					dec a 
105a 32 9b fd				ld (input_cur_flash), a 
105d fe 00				cp 0 
105f 20 0d				jr nz, .inochgstate 
1061			 
1061			 
1061					; reset on change of state 
1061 3e 09				ld a, CUR_BLINK_RATE 
1063 32 9b fd				ld (input_cur_flash), a 
1066			 
1066					; change state 
1066 3a 9a fd				ld a,(input_cur_onoff) 
1069 ed 44				neg 
106b 32 9a fd				ld (input_cur_onoff),a 
106e			 
106e			 
106e			 
106e			 
106e					; TODO is cursor visible? 
106e					; TODO if so then over write the char at curspos pos with the cursor shape 
106e			 
106e								 
106e			 
106e			.inochgstate: 
106e 3a 9a fd				ld a,(input_cur_onoff) 
1071 fe ff				cp 255 
1073 28 0e				jr z, .skipcursor 
1075 3a 9f fd				ld a, (input_at_pos) 
1078 47					ld b, a 
1079 3a 90 fd				ld a, (input_cursor) 
107c 80					add b 
107d 11 fc fa				ld de, cursor_shape 
1080					 
1080 cd ba 0d				call str_at_display 
1083			 
1083			.skipcursor: 
1083				if DEBUG_INPUTV2 
1083			 
1083					ld a,(input_at_pos) 
1083					ld hl, LFSRSeed 
1083					call hexout 
1083					ld a, (input_cursor) 
1083					ld hl, LFSRSeed+2 
1083					call hexout 
1083					ld a,(input_size) 
1083					ld hl, LFSRSeed+4 
1083					call hexout 
1083			 
1083					ld a,(input_cur_onoff) 
1083					ld hl, LFSRSeed+6 
1083					call hexout 
1083			 
1083					ld a,(input_cur_flash) 
1083					ld hl, LFSRSeed+8 
1083					call hexout 
1083			 
1083					ld a,(input_len) 
1083					ld hl, LFSRSeed+10 
1083					call hexout 
1083					ld hl, LFSRSeed+12 
1083					ld a, 0 
1083					ld (hl),a 
1083					ld a, display_row_4 
1083					ld de, LFSRSeed 
1083					call str_at_display 
1083				endif 
1083 cd ca 0d				call update_display 
1086			 
1086					; TODO keyboard processing 
1086			 
1086			if BASE_CPM 
1086					call cin_wait 
1086			else 
1086 cd d0 72				call cin    ; _wait 
1089			endif 
1089 fe 00				cp 0 
108b ca 2e 10				jp z, .inmain 
108e			 
108e fe 0b				cp KEY_LEFT    ; cursor left 
1090 ca 48 11				jp z, input_left 
1093				 
1093 fe 0c				cp KEY_RIGHT      ; cursor right 
1095 ca 4f 11				jp z, input_right 
1098			 
1098 fe 0d				cp KEY_CR 
109a c8					ret z 
109b			 
109b fe 08				cp KEY_BS 
109d ca bd 11				jp z, input_delchar 
10a0			 
10a0 fe 06				cp KEY_NEXTWORD 
10a2 ca c9 10				jp z, input_nxtword 
10a5			 
10a5 fe 07				cp KEY_PREVWORD 
10a7 ca f0 10				jp z, input_prvword 
10aa			 
10aa fe 0e				cp KEY_HOME    ; jump to start of line 
10ac 20 08				jr nz, .ikh 
10ae 3e 00				ld a, 0 
10b0 32 90 fd				ld (input_cursor), a 
10b3 ca 2e 10				jp z, .inmain 
10b6			.ikh: 
10b6			 
10b6 fe 0f				cp KEY_END     ; jump to end of line 
10b8 20 09				jr nz, .ike 
10ba 3a 95 fd				ld a, (input_len) 
10bd 32 90 fd				ld (input_cursor),a 
10c0 ca 2e 10				jp z, .inmain 
10c3			.ike: 
10c3 fe 05			        cp KEY_UP      ; recall last command 
10c5 c8					ret z 
10c6			;jr nz, .irec 
10c6			; TODO next word 
10c6			; TODO prev word 
10c6			;  
10c6			; 
10c6			;	ld hl, scratch 
10c6			;	ld de, os_last_cmd 
10c6			;	call strcpy 
10c6			;		jp  .inmain 
10c6			.irec: 
10c6			;		jr .instr1 
10c6			 
10c6			 
10c6			 
10c6					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
10c6			 
10c6			; TODO return if any special keys are given 
10c6			;		ld l, a 
10c6			;		ld a, 28 ; KEY_F12   ; 27 
10c6			;		sub l 
10c6			;		ret m 
10c6			;		ld a, l 
10c6					; if no special key then insert as a char 
10c6			 
10c6 c3 8f 11				jp input_inschr 
10c9			 
10c9				 
10c9			input_nxtword: 
10c9				; jump to start next word after the cursor 
10c9			 
10c9			.insknwn:	 
10c9 cd 85 11				call input_curptr	 
10cc 7e					ld a,(hl)	 
10cd fe 00				cp 0 
10cf ca 2e 10				jp z, .inmain    ; end of string 
10d2			 
10d2			; if we are on a word, then move off of it 
10d2			 
10d2 fe 20				cp ' ' 
10d4 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
10d6 21 90 fd				ld hl, input_cursor 
10d9 34					inc (hl) 
10da 18 ed				jr .insknwn 
10dc			 
10dc			.inspace: 
10dc			 
10dc cd 85 11				call input_curptr	 
10df 7e					ld a,(hl)	 
10e0 fe 00				cp 0 
10e2 ca 2e 10				jp z, .inmain    ; end of string 
10e5			 
10e5			; if we are on a word, then move off of it 
10e5			 
10e5 fe 20				cp ' ' 
10e7 c2 2e 10				jp nz, .inmain     ; we are on non space so at next word 
10ea 21 90 fd				ld hl, input_cursor 
10ed 34					inc (hl) 
10ee 18 ec				jr .inspace 
10f0			 
10f0			 
10f0			 
10f0			 
10f0			input_prvword: 
10f0				; jump to the start of previous word before the cursor 
10f0			 
10f0			; where are we to start with currently? 
10f0			 
10f0 cd 85 11				call input_curptr	 
10f3 7e					ld a, (hl) 
10f4 fe 20				cp ' ' 
10f6 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
10f8			 
10f8			 
10f8			 
10f8			.inskpwn:	 
10f8 3a 90 fd				ld a,(input_cursor) 
10fb fe 00				cp 0 
10fd ca 2e 10				jp z, .inmain    ; start of string 
1100			 
1100			;if we are on a word, then move off of it 
1100			 
1100 cd 85 11				call input_curptr	 
1103 7e					ld a, (hl) 
1104 fe 20				cp ' ' 
1106 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
1108					;jp z, .inmain    ; start of string 
1108 21 90 fd				ld hl, input_cursor 
110b 35					dec (hl) 
110c 18 ea				jr .inskpwn 
110e			.iwstart: 
110e 21 90 fd				ld hl, input_cursor 
1111 34					inc (hl) 
1112 c3 2e 10				jp .inmain 
1115					 
1115			 
1115			.inspacep: 
1115			 
1115					;jp .inmain    ; start of string 
1115			 
1115			 
1115			 
1115 3a 90 fd				ld a,(input_cursor) 
1118 fe 00				cp 0 
111a ca 2e 10				jp z, .inmain    ; start of string 
111d			 
111d			; if we are on a word, then move off of it 
111d			 
111d cd 85 11				call input_curptr	 
1120 7e					ld a, (hl) 
1121 fe 20				cp ' ' 
1123 c2 2c 11				jp nz, .incharp     ; we are on non space so at end of prev word 
1126 21 90 fd				ld hl, input_cursor 
1129 35					dec (hl) 
112a 18 e9				jr .inspacep 
112c			 
112c			 
112c			.incharp:	 
112c					; eat the word to get to the start 
112c 3a 90 fd				ld a,(input_cursor) 
112f fe 00				cp 0 
1131 ca 2e 10				jp z, .inmain    ; start of string 
1134			 
1134			; if we are on a word, then move off of it 
1134			 
1134 cd 85 11				call input_curptr	 
1137 7e					ld a, (hl) 
1138 fe 20				cp ' ' 
113a 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
113c 21 90 fd				ld hl, input_cursor 
113f 35					dec (hl) 
1140 18 ea				jr .incharp 
1142			.ipwordst: 
1142					; at space before the prev word so reposition over it 
1142 21 90 fd				ld hl, input_cursor 
1145 34					inc (hl) 
1146 18 b0				jr .inskpwn 
1148					 
1148			 
1148			 
1148			input_left: 
1148				; move cursor left 
1148 21 90 fd			ld hl, input_cursor 
114b 35				dec (hl) 
114c			;	cp 0 
114c			;	jp z, .inmain    ; ignore left as at the start of the string 
114c c3 2e 10			jp .inmain 
114f			 
114f			input_right: 
114f				; move cursor right 
114f				 
114f				;ld a, (input_size) 
114f				;ld b, a 
114f 21 90 fd			ld hl, input_cursor 
1152 34				inc (hl) 
1153				;dec b 
1153				;cp 0 
1153				;jp z, .inmain   ; ignore as at end of the string buffer 
1153				;ld a, b 
1153				;inc a 
1153				;ld (input_cursor), a 
1153 c3 2e 10			jp .inmain 
1156			 
1156			 
1156			 
1156			input_disp_ref: 
1156				; display the text from start of buffer (ie full refresh) 
1156 3a 9f fd			ld a, (input_at_pos) 
1159 2a a2 fd			ld hl,(input_start) 
115c eb				ex de, hl 
115d cd ba 0d			call str_at_display  
1160 c9				ret 
1161			input_disp_oncur: 
1161				; display the text from cursor position to end of buffer 
1161				; TODO position start of string at cursor position on screen 
1161				; TODO draw from that point on 
1161 3a 90 fd			ld a, (input_cursor) 
1164 47				ld b, a 
1165 3a 9f fd			ld a, (input_at_pos) 
1168 80				add b 
1169 48				ld c, b     ; save a 
116a 78				ld a, b     ; inc string start for cursor 
116b 2a a2 fd			ld hl,(input_start) 
116e cd db 0f			call addatohl 
1171 eb				ex de, hl 
1172 79				ld a, c 
1173 cd ba 0d			call str_at_display  
1176 c9				ret 
1177			 
1177			input_nxtw: 
1177				; Find next word 
1177 c9				ret 
1178			 
1178			input_prvw: 
1178				; Find previous word 
1178 c9				ret 
1179			 
1179			input_lenrem:   
1179				; Calculate the length of string remaining from current cursor 
1179				; position to end of buffer (exc null term) 
1179				 
1179 3a 90 fd			ld a, (input_cursor) 
117c 4f				ld c, a 
117d 3a a1 fd			ld a, (input_size) 
1180 91				sub c 
1181 06 00			ld b, 0 
1183 0d				dec c 
1184 c9				ret	 
1185			 
1185			input_curptr: 
1185				; calc address of the character under the cursor 
1185				 
1185 2a a2 fd			ld hl, (input_start) 
1188 3a 90 fd			ld a, (input_cursor) 
118b cd db 0f			call addatohl 
118e c9				ret 
118f			 
118f			input_inschr: 
118f				; Insert char at cursor position 
118f f5				push af   ; save char 
1190				;call input_lenrem    ; get bc length of remaining string 
1190			 
1190				 
1190 cd 85 11			call input_curptr 
1193			;	ld hl, (input_start) 
1193			;	ld a, (input_cursor) 
1193			;	call addatohl 
1193				;push hl   ; save to come back to 
1193			 
1193				; shift everything up one to end of buffer 
1193			 
1193				;push hl 
1193				;dec de 
1193				;inc de 
1193			;	ldir 
1193				 
1193				;pop hl 
1193			 
1193				; are we adding to the end of line? 
1193			 
1193 3a 90 fd			ld a, (input_cursor) 
1196 47				ld b, a 
1197 3a 95 fd			ld a, (input_len) 
119a b8				cp b 
119b 20 09			jr nz, .insmid   ; no, insert in middle of text 
119d			 
119d				; tack on the end of the line 
119d f1				pop af 
119e 77				ld (hl), a   ; save new char 
119f 23				inc hl 
11a0 3e 00			ld a, 0 
11a2 77				ld (hl), a 
11a3 c3 4f 11			jp input_right 
11a6				 
11a6			.insmid: 
11a6				; hl has insertion point so move everything up one to allow for insertion 
11a6				;call input_shiftright 
11a6 f1				pop af 
11a7			 
11a7			.shufinsmid: 
11a7 47				ld b, a     ; b contains new char, c prev char at this position  
11a8 7e				ld a, (hl) 
11a9			 
11a9 fe 00			cp 0    ; at end of string need to then dump new char and add term 
11ab 28 07			jr z, .endinsmid 
11ad 4f				ld c, a 
11ae 78				ld a, b 
11af 77				ld (hl), a 
11b0 23				inc hl 
11b1 79				ld a, c 
11b2 18 f3			jr .shufinsmid 
11b4				 
11b4			 
11b4			 
11b4			 
11b4			.endinsmid: 
11b4 78				ld a, b 
11b5 77				ld (hl), a 
11b6 23				inc hl 
11b7 3e 00			ld a, 0 
11b9 77				ld (hl), a 
11ba			 
11ba			 
11ba			;	ld (hl), a   ; save new char 
11ba			 
11ba c3 4f 11			jp input_right 
11bd			 
11bd			;input_shiftright: 
11bd			;	; shift text right at cursor, hl has shift start 
11bd			;	push hl 
11bd			;	push de 
11bd			;	push bc 
11bd			; 
11bd			; 
11bd			;	; move to end of string past zero term 
11bd			;	ld hl,(input_start) 
11bd			;	ld a, (input_len) 
11bd			;	call addatohl 
11bd			;	inc hl 
11bd			;;	inc hl 
11bd			;;	inc hl 
11bd			;	ld a, 0 
11bd			;	ld (hl), a 
11bd			;;	dec hl 
11bd			;	 
11bd			;;	ld (hl), a 
11bd			;;	dec hl 
11bd			; 
11bd			;	push hl 
11bd			;	pop de 
11bd			;	inc de 
11bd			;	 
11bd			; 
11bd			;;	ld hl,(input_start) 
11bd			;;	ld a, (input_cursor) 
11bd			;;	call addatohl 
11bd			; 
11bd			; 
11bd			;	; calc how many bytes from cursor pos to end of string we need to shift 
11bd			;	call input_lenrem    ; get bc length of remaining string 
11bd			;	;ld a, (input_cursor) 
11bd			;	;ld c, a 
11bd			;	ld a, (input_len) 
11bd			;	cp 2 
11bd			;	jr z, .iskipzero	 
11bd			;	;sub c 
11bd			;	;inc a 
11bd			;	;ld c, a 
11bd			;	;ld b, 0 
11bd			;	inc c 
11bd			;	inc c 
11bd			;	; move data 
11bd			;	lddr 
11bd			;.iskipzero: 
11bd			; 
11bd			;	pop bc 
11bd			;	pop de 
11bd			;	pop hl 
11bd			;	ret	 
11bd			 
11bd			input_delchar: 
11bd				; Delete char at cursor position 
11bd cd 79 11			call input_lenrem    ; get bc length of remaining string 
11c0 2a a2 fd			ld hl, (input_start) 
11c3 3a 90 fd			ld a, (input_cursor) 
11c6 cd db 0f			call addatohl 
11c9			 
11c9 e5				push hl 
11ca d1				pop de 
11cb 1b				dec de 
11cc			 
11cc			.dl:	 
11cc ed a0			ldi  
11ce 7e				ld a, (hl) 
11cf fe 00			cp 0 
11d1 28 02			jr z, .dldone 
11d3 18 f7			jr .dl 
11d5			.dldone: 
11d5 ed a0			ldi 
11d7			 
11d7 c3 48 11			jp input_left 
11da			 
11da			 
11da			endif 
11da			 
11da			 
11da			 
11da			if EDIT_V1 
11da			input_str: 
11da			 
11da				    	ld (input_at_pos),a      ; save display position to start 
11da					add c 
11da					ld (input_at_cursor),a	; save draw pos of cursor 
11da					ld (input_start), hl     ; save ptr to buffer 
11da					ld a, c 
11da					call addatohl 
11da					ld (input_ptr), hl     ; save ptr to point under the cursor 
11da					ld a,d 
11da				        ld (input_size), a       ; save length of input area 
11da					ld a, c 
11da					ld (input_cursor),a      ; init cursor start position  
11da					ld a,e 
11da				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
11da					 
11da					 
11da			 
11da			;		ld a,(input_ptr) 
11da			;		ld (input_under_cursor),a 	; save what is under the cursor 
11da			 
11da			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
11da					; init cursor shape if not set by the cin routines 
11da					ld hl, cursor_shape 
11da			if BASE_KEV 
11da					ld a, 255 
11da			else 
11da					ld a, '#' 
11da			endif 
11da					ld (hl), a 
11da					inc hl 
11da					ld a, 0 
11da					ld (hl), a 
11da			 
11da					ld a, CUR_BLINK_RATE 
11da					ld (input_cur_flash), a 
11da					ld a, 1 
11da					ld (input_cur_onoff),a 
11da			 
11da			;	if DEBUG_INPUT 
11da			;		push af 
11da			;		ld a, 'I' 
11da			;		ld (debug_mark),a 
11da			;		pop af 
11da			;		CALLMONITOR 
11da			;	endif 
11da			.is1:		; main entry loop 
11da			 
11da			 
11da			 
11da					; pause 1ms 
11da			 
11da					ld a, 1 
11da					call aDelayInMS 
11da			 
11da					; dec flash counter 
11da					ld a, (input_cur_flash) 
11da					dec a 
11da					ld (input_cur_flash), a 
11da					cp 0 
11da					jr nz, .nochgstate 
11da			 
11da			 
11da					; change state 
11da					ld a,(input_cur_onoff) 
11da					neg 
11da					ld (input_cur_onoff),a 
11da			 
11da			 
11da					; reset on change of state 
11da					ld a, CUR_BLINK_RATE 
11da					ld (input_cur_flash), a 
11da			 
11da			.nochgstate: 
11da					 
11da					 
11da			 
11da					; display cursor  
11da			 
11da			;		ld hl, (input_start) 
11da			;		ld a, (input_cursor) 
11da			;		call addatohl 
11da			 
11da					; get char under cursor and replace with cursor 
11da			ld hl, (input_ptr) 
11da			;		ld a, (hl) 
11da			;		ld (input_under_cursor),a 
11da			;		ld a, '_' 
11da			;		ld (hl), a 
11da			 
11da					; display string 
11da			 
11da					ld de, (input_start) 
11da					ld a, (input_at_pos) 
11da					call str_at_display 
11da			;	        call update_display 
11da			 
11da					; find place to put the cursor 
11da			;		add h 
11da			;		ld l, display_row_1 
11da			;		sub l 
11da			; (input_at_pos) 
11da					;ld c, a 
11da			;		ld a, (input_cursor) 
11da			;		ld l, (input_at_pos) 
11da			;		;ld b, h 
11da			;		add l 
11da			;		ld (input_at_cursor),a 
11da					;ld l,h 
11da			 
11da			;		ld h, 0 
11da			;		ld l,(input_at_pos) 
11da			;		ld a, (input_cursor) 
11da			;		call addatohl 
11da			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
11da			;		call subafromhl 
11da			;		ld a,l 
11da			;		ld (input_at_cursor), a 
11da			 
11da				if DEBUG_INPUT 
11da					ld a, (hardware_diag) 
11da					cp 0 
11da					jr z, .skip_input_diag 
11da			 
11da					ld a,(input_at_pos) 
11da					ld hl, LFSRSeed 
11da					call hexout 
11da					ld a, (input_cursor) 
11da					ld hl, LFSRSeed+2 
11da					call hexout 
11da					ld a,(input_at_cursor) 
11da					ld hl, LFSRSeed+4 
11da					call hexout 
11da			 
11da					ld a,(input_cur_onoff) 
11da					ld hl, LFSRSeed+6 
11da					call hexout 
11da			 
11da					ld a,(input_cur_flash) 
11da					ld hl, LFSRSeed+8 
11da					call hexout 
11da			 
11da					ld a,(input_len) 
11da					ld hl, LFSRSeed+10 
11da					call hexout 
11da					ld hl, LFSRSeed+12 
11da					ld a, 0 
11da					ld (hl),a 
11da					ld a, display_row_4 
11da					ld de, LFSRSeed 
11da					call str_at_display 
11da					.skip_input_diag: 
11da				endif 
11da			 
11da					; decide on if we are showing the cursor this time round 
11da			 
11da					ld a, (input_cur_onoff) 
11da					cp 255 
11da					jr z, .skipcur 
11da			 
11da			 
11da					ld a,(input_at_cursor) 
11da					ld de, cursor_shape 
11da					call str_at_display 
11da			 
11da					; save length of current input string 
11da					ld hl, (input_start) 
11da					ld a, 0 
11da					call strlent 
11da					ld a,l 
11da					ld (input_len),a 
11da			 
11da			.skipcur: 
11da			 
11da				        call update_display 
11da					 
11da			 
11da			 
11da					; wait 
11da				 
11da					; TODO loop without wait to flash the cursor and char under cursor	 
11da					call cin    ; _wait 
11da			 
11da					cp 0 
11da					jp z, .is1 
11da			 
11da					; get ptr to char to input into 
11da			 
11da					ld c,a 
11da					ld hl, (input_start) 
11da					ld a, (input_cursor) 
11da					call addatohl 
11da					ld (input_ptr), hl 
11da					ld a,c 
11da			 
11da					; replace char under cursor 
11da			 
11da			;		ld hl, (input_ptr) 
11da			;		ld a, (input_under_cursor) 	; get what is under the cursor 
11da			;		ld (hl), a 
11da			 
11da			;	if DEBUG_INPUT 
11da			;		push af 
11da			;		ld a, 'i' 
11da			;		ld (debug_mark),a 
11da			;		pop af 
11da			;		CALLMONITOR 
11da			;	endif 
11da					cp KEY_HOME 
11da					jr nz, .iske 
11da			 
11da					ld a, (input_at_pos) 
11da					ld (input_at_cursor),a 
11da					ld a, 0 
11da					ld (input_cursor), a 
11da					jp .is1 
11da					 
11da			.iske:		cp KEY_END 
11da					jr nz, .isknw 
11da					jp .is1 
11da			 
11da			.isknw:		cp KEY_NEXTWORD 
11da					jr nz, .iskpw 
11da			 
11da			.isknwm:	ld hl, (input_ptr) 
11da					ld a,(hl)	 
11da					cp 0 
11da					jp z, .is1    ; end of string 
11da					cp ' ' 
11da					jp z, .is1    ; end of word 
11da					inc hl 
11da					ld (input_ptr), hl 
11da					ld a, (input_at_cursor) 
11da					inc a 
11da					ld (input_at_cursor), a 
11da					jr .isknwm 
11da			 
11da			.iskpw:		cp KEY_PREVWORD 
11da					jr nz, .iskl 
11da			.iskpwm:	 
11da					ld hl, (input_ptr) 
11da					ld a,(hl)	 
11da					cp 0  
11da					jp z, .is1    ; end of string 
11da					cp ' ' 
11da					jp z, .is1    ; end of word 
11da					dec hl 
11da					ld (input_ptr), hl 
11da					ld a, (input_at_cursor) 
11da					dec a 
11da					ld (input_at_cursor), a 
11da					jr .iskpwm 
11da			 
11da			 
11da			.iskl:		cp KEY_LEFT 
11da					jr nz, .isk1 
11da			 
11da					ld a, (input_cursor) 
11da			 
11da					cp 0 
11da					jp z, .is1 		; at start of line to ignore  
11da			 
11da					dec  a 		; TODO check underflow 
11da					ld (input_cursor), a 
11da			 
11da					ld hl, (input_ptr) 
11da					dec hl 
11da					ld (input_ptr), hl 
11da					 
11da					ld a, (input_at_cursor) 
11da					dec a 
11da					ld (input_at_cursor), a 
11da			 
11da					ld a, 1		; show cursor moving 
11da					ld (input_cur_onoff),a 
11da					ld a, CUR_BLINK_RATE 
11da					ld (input_cur_flash), a 
11da			 
11da					jp .is1 
11da			 
11da			.isk1:		cp KEY_RIGHT 
11da					jr nz, .isk2 
11da			 
11da					ld a,(input_len)		; TODO BUG why cant i load e direct? 
11da					ld e,a 
11da					ld a, (input_cursor) 
11da					cp e 
11da					jp z, .is1		; at the end of string so dont go right 
11da			 
11da					inc  a 		; TODO check overflow 
11da					ld (input_cursor), a 
11da			 
11da					ld a, (input_at_cursor) 
11da					inc a 
11da					ld (input_at_cursor), a 
11da			 
11da					ld hl, (input_ptr) 
11da					inc hl 
11da					ld (input_ptr), hl 
11da			 
11da					ld a, 1		; show cursor moving 
11da					ld (input_cur_onoff),a 
11da					ld a, CUR_BLINK_RATE 
11da					ld (input_cur_flash), a 
11da			 
11da					jp .is1 
11da			 
11da			.isk2:		cp KEY_UP 
11da			 
11da					jr nz, .isk3 
11da			 
11da					; swap last command with the current on 
11da			 
11da					; move cursor to start of string 
11da					ld hl, (input_start) 
11da					ld (input_ptr), hl 
11da			 
11da					ld a, (input_at_pos) 
11da					ld (input_at_cursor), a 
11da			 
11da					ld a, 0 
11da					ld (input_cursor), a 
11da					 
11da					; swap input and last command buffers 
11da			 
11da					ld hl, os_cli_cmd 
11da					ld de, os_last_cmd 
11da					ld b, 255 
11da			.swap1:		ld a, (hl) 
11da					ld c,a 
11da					ld a, (de) 
11da					ld (hl), a 
11da					ld a,c 
11da					ld (de),a 
11da					inc hl 
11da					inc de 
11da					djnz .swap1 
11da			 
11da			 
11da			 
11da			 
11da			 
11da					jp .is1 
11da			 
11da			.isk3:		cp KEY_BS 
11da					jr nz, .isk4 
11da			 
11da					ld a, (input_cursor) 
11da			 
11da					cp 0 
11da					jp z, .is1 		; at start of line to ignore  
11da			 
11da					dec  a 		; TODO check underflow 
11da					ld (input_cursor), a 
11da			 
11da					; hl is source 
11da					; de needs to be source - 1 
11da			 
11da			;		ld a, 0 
11da			;		dec hl 
11da			;		ld (hl), a 
11da			 
11da					ld hl, (input_ptr) 
11da					dec hl 
11da					ld (input_ptr), hl 
11da			 
11da					; shift all data 
11da			 
11da					push hl 
11da					inc hl 
11da					pop de 
11da					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
11da					ld c,a 
11da					ld b,0 
11da					ldir  
11da			 
11da			 
11da			 
11da			 
11da					ld a, (input_at_cursor) 
11da					dec a 
11da					ld (input_at_cursor), a 
11da			 
11da			 
11da					ld a, 1		; show cursor moving 
11da					ld (input_cur_onoff),a 
11da					ld a, CUR_BLINK_RATE 
11da					ld (input_cur_flash), a 
11da			 
11da					; remove char 
11da					ld a, (input_at_cursor) 
11da					inc a 
11da					ld de,.iblank 
11da					call str_at_display 
11da			 
11da					jp .is1 
11da			 
11da			.isk4:		cp KEY_CR 
11da					jr z, .endinput 
11da			 
11da					; else add the key press to the end 
11da			 
11da					ld c, a			; save key pressed 
11da			 
11da					ld a,(hl)		; get what is currently under char 
11da			 
11da					cp 0			; we are at the end of the string 
11da					jr nz, .onchar 
11da					 
11da					; add a char to the end of the string 
11da				 
11da					ld (hl),c 
11da					inc hl 
11da			;		ld a,' ' 
11da			;		ld (hl),a 
11da			;		inc hl 
11da					ld a,0 
11da					ld (hl),a 
11da					dec hl 
11da			 
11da					ld a, (input_cursor) 
11da					inc a				; TODO check max string length and scroll  
11da					ld (input_cursor), a		; inc cursor pos 
11da							 
11da					ld a, (input_at_cursor) 
11da					inc a 
11da					ld (input_at_cursor), a 
11da			 
11da					ld hl, (input_ptr) 
11da					inc hl 
11da					ld (input_ptr), hl 
11da			 
11da					ld hl, (input_ptr) 
11da					inc hl 
11da					ld (input_ptr), hl 
11da			;	if DEBUG_INPUT 
11da			;		push af 
11da			;		ld a, '+' 
11da			;		ld (debug_mark),a 
11da			;		pop af 
11da			;		CALLMONITOR 
11da			;	endif 
11da					ld a, 1		; show cursor moving 
11da					ld (input_cur_onoff),a 
11da					ld a, CUR_BLINK_RATE 
11da					ld (input_cur_flash), a 
11da					jp .is1 
11da					 
11da			 
11da			 
11da					; if on a char then insert 
11da			.onchar: 
11da			 
11da					; TODO over flow check: make sure insert does not blow out buffer 
11da			 
11da					; need to do some maths to use lddr 
11da			 
11da					push hl   ; save char pos 
11da					push bc 
11da			 
11da					ld hl, (input_start) 
11da					ld a, (input_len) 
11da					call addatohl  		; end of string 
11da					inc hl 
11da					inc hl		; past zero term 
11da					push hl 
11da					inc hl 
11da					push hl  
11da			 
11da								; start and end of lddr set, now how much to move? 
11da			 
11da							 
11da					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11da					ld b,a 
11da					ld a,(input_len) 
11da					ld e,a 
11da					sub b 
11da					inc a		;?? 
11da					inc a		;?? 
11da					inc a		;?? 
11da			 
11da					ld b,0 
11da					ld c,a 
11da			 
11da				if DEBUG_INPUT 
11da					push af 
11da					ld a, 'i' 
11da					ld (debug_mark),a 
11da					pop af 
11da			;		CALLMONITOR 
11da				endif 
11da					pop de 
11da					pop hl 
11da				if DEBUG_INPUT 
11da					push af 
11da					ld a, 'I' 
11da					ld (debug_mark),a 
11da					pop af 
11da			;		CALLMONITOR 
11da				endif 
11da					lddr 
11da				 
11da			 
11da			 
11da					; TODO have a key for insert/overwrite mode???? 
11da					pop bc 
11da					pop hl 
11da					ld (hl), c		; otherwise overwrite current char 
11da					 
11da			 
11da			 
11da			 
11da					ld a, (input_cursor) 
11da					inc  a 		; TODO check overflow 
11da					ld (input_cursor), a 
11da			 
11da					ld a, (input_at_cursor) 
11da					inc a 
11da					ld (input_at_cursor), a 
11da			 
11da					jp .is1 
11da			 
11da			.endinput:	; TODO look for end of string 
11da			 
11da					; add trailing space for end of token 
11da			 
11da					ld hl, (input_start) 
11da					ld a,(input_len) 
11da					call addatohl 
11da					ld a, ' ' 
11da					ld (hl),a 
11da					; TODO eof of parse marker 
11da			 
11da					inc hl 
11da					ld a, 0 
11da					ld (hl),a 
11da			 
11da			 
11da					ret 
11da			 
11da			.iblank: db " ",0 
11da			 
11da			 
11da			input_str_prev:	ld (input_at_pos), a 
11da					ld (input_start), hl 
11da					ld a,1			; add cursor 
11da					ld (hl),a 
11da					inc hl 
11da					ld a,0 
11da					ld (hl),a 
11da					ld (input_ptr), hl 
11da					ld a,d 
11da					ld (input_size), a 
11da					ld a,0 
11da					ld (input_cursor),a 
11da			.instr1:	 
11da			 
11da					; TODO do block cursor 
11da					; TODO switch cursor depending on the modifer key 
11da			 
11da					; update cursor shape change on key hold 
11da			 
11da					ld hl, (input_ptr) 
11da					dec hl 
11da					ld a,(cursor_shape) 
11da					ld (hl), a 
11da			 
11da					; display entered text 
11da					ld a,(input_at_pos) 
11da			            	CALL fLCD_Pos       ;Position cursor to location in A 
11da			            	LD   de, (input_start) 
11da			            	CALL fLCD_Str       ;Display string pointed to by DE 
11da			 
11da					call cin 
11da					cp 0 
11da					jr z, .instr1 
11da			 
11da					; proecess keyboard controls first 
11da			 
11da					ld hl,(input_ptr) 
11da			 
11da					cp KEY_CR	 ; pressing enter ends input 
11da					jr z, .instrcr 
11da			 
11da					cp KEY_BS 	; back space 
11da					jr nz, .instr2 
11da					; process back space 
11da			 
11da					; TODO stop back space if at start of string 
11da					dec hl 
11da					dec hl ; to over write cursor 
11da					ld a,(cursor_shape) 
11da					;ld a,0 
11da					ld (hl),a 
11da					inc hl 
11da					ld a," " 
11da					ld (hl),a 
11da					ld (input_ptr),hl 
11da					 
11da			 
11da					jr .instr1 
11da			 
11da			.instr2:	cp KEY_LEFT    ; cursor left 
11da					jr nz, .instr3 
11da					dec hl 
11da					ld (input_ptr),hl 
11da					jr .instr1 
11da				 
11da			.instr3:	cp KEY_RIGHT      ; cursor right 
11da					jr nz, .instr4 
11da					inc hl 
11da					ld (input_ptr),hl 
11da					jr .instr1 
11da			 
11da			.instr4:	cp KEY_HOME    ; jump to start of line 
11da					jr nz, .instr5 
11da					dec hl 
11da					ld (input_ptr),hl 
11da					jr .instr1 
11da			 
11da			.instr5:	cp KEY_END     ; jump to end of line 
11da					jr nz, .instr6 
11da					dec hl 
11da					ld (input_ptr),hl 
11da					jr .instr1 
11da			.instr6:        cp KEY_UP      ; recall last command 
11da					jr nz, .instrnew 
11da			 
11da				ld hl, scratch 
11da				ld de, os_last_cmd 
11da				call strcpy 
11da					jr .instr1 
11da			 
11da			 
11da			.instrnew:	; no special key pressed to see if we have room to store it 
11da			 
11da					; TODO do string size test 
11da			 
11da					dec hl ; to over write cursor 
11da					ld (hl),a 
11da					inc hl 
11da					ld a,(cursor_shape) 
11da					ld (hl),a 
11da					inc hl 
11da					ld a,0 
11da					ld (hl),a 
11da			 
11da					ld (input_ptr),hl 
11da					 
11da					jr .instr1 
11da			.instrcr:	dec hl		; remove cursor 
11da					ld a,' '	; TODO add a trailing space for safety 
11da					ld (hl),a 
11da					inc hl 
11da					ld a,0 
11da					ld (hl),a 
11da			 
11da			 
11da					; if at end of line scroll up    
11da					; TODO detecting only end of line 4 for scroll up  
11da			 
11da					;ld   
11da			 
11da					ret 
11da			 
11da			 
11da			endif 
11da			; strcpy hl = dest, de source 
11da			 
11da 1a			strcpy:   LD   A, (DE)        ;Get character from string 
11db b7			            OR   A              ;Null terminator? 
11dc c8			            RET  Z              ;Yes, so finished 
11dd 1a					ld a,(de) 
11de 77					ld (hl),a 
11df 13			            INC  DE             ;Point to next character 
11e0 23					inc hl 
11e1 18 f7		            JR   strcpy       ;Repeat 
11e3 c9					ret 
11e4			 
11e4			 
11e4			; TODO string_at  
11e4			; pass string which starts with lcd offset address and then null term string 
11e4			 
11e4			; TODO string to dec 
11e4			; TODO string to hex 
11e4			; TODO byte to string hex 
11e4			; TODO byte to string dec 
11e4			 
11e4			 
11e4			 
11e4			; from z80uartmonitor 
11e4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e4			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
11e4			; pass hl for where to put the text 
11e4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e4 c5			hexout:	PUSH BC 
11e5 f5					PUSH AF 
11e6 47					LD B, A 
11e7					; Upper nybble 
11e7 cb 3f				SRL A 
11e9 cb 3f				SRL A 
11eb cb 3f				SRL A 
11ed cb 3f				SRL A 
11ef cd ff 11				CALL tohex 
11f2 77					ld (hl),a 
11f3 23					inc hl	 
11f4					 
11f4					; Lower nybble 
11f4 78					LD A, B 
11f5 e6 0f				AND 0FH 
11f7 cd ff 11				CALL tohex 
11fa 77					ld (hl),a 
11fb 23					inc hl	 
11fc					 
11fc f1					POP AF 
11fd c1					POP BC 
11fe c9					RET 
11ff					 
11ff			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11ff			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
11ff			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11ff			tohex: 
11ff e5					PUSH HL 
1200 d5					PUSH DE 
1201 16 00				LD D, 0 
1203 5f					LD E, A 
1204 21 0c 12				LD HL, .DATA 
1207 19					ADD HL, DE 
1208 7e					LD A, (HL) 
1209 d1					POP DE 
120a e1					POP HL 
120b c9					RET 
120c			 
120c			.DATA: 
120c 30					DEFB	30h	; 0 
120d 31					DEFB	31h	; 1 
120e 32					DEFB	32h	; 2 
120f 33					DEFB	33h	; 3 
1210 34					DEFB	34h	; 4 
1211 35					DEFB	35h	; 5 
1212 36					DEFB	36h	; 6 
1213 37					DEFB	37h	; 7 
1214 38					DEFB	38h	; 8 
1215 39					DEFB	39h	; 9 
1216 41					DEFB	41h	; A 
1217 42					DEFB	42h	; B 
1218 43					DEFB	43h	; C 
1219 44					DEFB	44h	; D 
121a 45					DEFB	45h	; E 
121b 46					DEFB	46h	; F 
121c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
121c			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
121c			;;    subtract $30, if result > 9 then subtract $7 more 
121c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
121c			atohex: 
121c d6 30				SUB $30 
121e fe 0a				CP 10 
1220 f8					RET M		; If result negative it was 0-9 so we're done 
1221 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1223 c9					RET		 
1224			 
1224			 
1224			 
1224			 
1224			; Get 2 ASCII characters as hex byte from pointer in hl 
1224			 
1224			BYTERD: 
1224 16 00			LD	D,00h		;Set up 
1226 cd 2e 12			CALL	HEXCON		;Get byte and convert to hex 
1229 87				ADD	A,A		;First nibble so 
122a 87				ADD	A,A		;multiply by 16 
122b 87				ADD	A,A		; 
122c 87				ADD	A,A		; 
122d 57				LD	D,A		;Save hi nibble in D 
122e			HEXCON: 
122e 7e				ld a, (hl)		;Get next chr 
122f 23				inc hl 
1230 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1232 fe 0a			CP	00Ah		;Is it 0-9 ? 
1234 38 02			JR	C,NALPHA	;If so miss next bit 
1236 d6 07			SUB	007h		;Else convert alpha 
1238			NALPHA: 
1238 b2				OR	D		;Add hi nibble back 
1239 c9				RET			; 
123a			 
123a			 
123a			; 
123a			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
123a			; Since the routines get_byte and therefore get_nibble are called, only valid 
123a			; characters (0-9a-f) are accepted. 
123a			; 
123a			;get_word        push    af 
123a			;                call    get_byte        ; Get the upper byte 
123a			;                ld      h, a 
123a			;                call    get_byte        ; Get the lower byte 
123a			;                ld      l, a 
123a			;                pop     af 
123a			;                ret 
123a			; 
123a			; Get a byte in hexadecimal notation. The result is returned in A. Since 
123a			; the routine get_nibble is used only valid characters are accepted - the  
123a			; input routine only accepts characters 0-9a-f. 
123a			; 
123a c5			get_byte:        push    bc              ; Save contents of B (and C) 
123b 7e					ld a,(hl) 
123c 23					inc hl 
123d cd 62 12		                call    nibble2val      ; Get upper nibble 
1240 cb 07		                rlc     a 
1242 cb 07		                rlc     a 
1244 cb 07		                rlc     a 
1246 cb 07		                rlc     a 
1248 47			                ld      b, a            ; Save upper four bits 
1249 7e					ld a,(hl) 
124a cd 62 12		                call    nibble2val      ; Get lower nibble 
124d b0			                or      b               ; Combine both nibbles 
124e c1			                pop     bc              ; Restore B (and C) 
124f c9			                ret 
1250			; 
1250			; Get a hexadecimal digit from the serial line. This routine blocks until 
1250			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1250			; to the serial line interface. The lower 4 bits of A contain the value of  
1250			; that particular digit. 
1250			; 
1250			;get_nibble      ld a,(hl)           ; Read a character 
1250			;                call    to_upper        ; Convert to upper case 
1250			;                call    is_hex          ; Was it a hex digit? 
1250			;                jr      nc, get_nibble  ; No, get another character 
1250			 ;               call    nibble2val      ; Convert nibble to value 
1250			 ;               call    print_nibble 
1250			 ;               ret 
1250			; 
1250			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1250			; A valid hexadecimal digit is denoted by a set C flag. 
1250			; 
1250			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1250			;                ret     nc              ; Yes 
1250			;                cp      '0'             ; Less than '0'? 
1250			;                jr      nc, is_hex_1    ; No, continue 
1250			;                ccf                     ; Complement carry (i.e. clear it) 
1250			;                ret 
1250			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1250			;                ret     c               ; Yes 
1250			;                cp      'A'             ; Less than 'A'? 
1250			;                jr      nc, is_hex_2    ; No, continue 
1250			;                ccf                     ; Yes - clear carry and return 
1250			;                ret 
1250			;is_hex_2        scf                     ; Set carry 
1250			;                ret 
1250			; 
1250			; Convert a single character contained in A to upper case: 
1250			; 
1250 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1252 d8			                ret     c 
1253 fe 7b		                cp      'z' + 1         ; > 'z'? 
1255 d0			                ret     nc              ; Nothing to do, either 
1256 e6 5f		                and     $5f             ; Convert to upper case 
1258 c9			                ret 
1259			 
1259			 
1259			to_lower: 
1259			 
1259			   ; if char is in [A-Z] make it lower case 
1259			 
1259			   ; enter : a = char 
1259			   ; exit  : a = lower case char 
1259			   ; uses  : af 
1259			 
1259 fe 41		   cp 'A' 
125b d8			   ret c 
125c			    
125c fe 5b		   cp 'Z'+1 
125e d0			   ret nc 
125f			    
125f f6 20		   or $20 
1261 c9			   ret 
1262			 
1262			; 
1262			; Expects a hexadecimal digit (upper case!) in A and returns the 
1262			; corresponding value in A. 
1262			; 
1262 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1264 38 02		                jr      c, nibble2val_1 ; Yes 
1266 d6 07		                sub     7               ; Adjust for A-F 
1268 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
126a e6 0f		                and     $f              ; Only return lower 4 bits 
126c c9			                ret 
126d			; 
126d			; Print_nibble prints a single hex nibble which is contained in the lower  
126d			; four bits of A: 
126d			; 
126d			;print_nibble    push    af              ; We won't destroy the contents of A 
126d			;                and     $f              ; Just in case... 
126d			;                add     a, '0'             ; If we have a digit we are done here. 
126d			;                cp      '9' + 1         ; Is the result > 9? 
126d			;                jr      c, print_nibble_1 
126d			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
126d			;print_nibble_1  call    putc            ; Print the nibble and 
126d			;                pop     af              ; restore the original value of A 
126d			;                ret 
126d			;; 
126d			;; Send a CR/LF pair: 
126d			; 
126d			;crlf            push    af 
126d			;                ld      a, cr 
126d			;                call    putc 
126d			;                ld      a, lf 
126d			;                call    putc 
126d			;                pop     af 
126d			;                ret 
126d			; 
126d			; Print_word prints the four hex digits of a word to the serial line. The  
126d			; word is expected to be in HL. 
126d			; 
126d			;print_word      push    hl 
126d			;                push    af 
126d			;                ld      a, h 
126d			;                call    print_byte 
126d			;                ld      a, l 
126d			;                call    print_byte 
126d			;                pop     af 
126d			;                pop     hl 
126d			;                ret 
126d			; 
126d			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
126d			; The byte to be printed is expected to be in A. 
126d			; 
126d			;print_byte      push    af              ; Save the contents of the registers 
126d			;                push    bc 
126d			;                ld      b, a 
126d			;                rrca 
126d			;                rrca 
126d			;                rrca 
126d			;                rrca 
126d			;                call    print_nibble    ; Print high nibble 
126d			;                ld      a, b 
126d			;                call    print_nibble    ; Print low nibble 
126d			;                pop     bc              ; Restore original register contents 
126d			;                pop     af 
126d			;                ret 
126d			 
126d			 
126d			 
126d			 
126d			 
126d			fourehexhl:  
126d 7e				ld a,(hl) 
126e cd 1c 12			call atohex 
1271 cb 3f				SRL A 
1273 cb 3f				SRL A 
1275 cb 3f				SRL A 
1277 cb 3f				SRL A 
1279 47				ld b, a 
127a 23				inc hl 
127b 7e				ld a,(hl) 
127c 23				inc hl 
127d cd 1c 12			call atohex 
1280 80				add b 
1281 57				ld d,a 
1282 7e				ld a,(hl) 
1283 cd 1c 12			call atohex 
1286 cb 3f				SRL A 
1288 cb 3f				SRL A 
128a cb 3f				SRL A 
128c cb 3f				SRL A 
128e 47				ld b, a 
128f 23				inc hl 
1290 7e				ld a,(hl) 
1291 23				inc hl 
1292 cd 1c 12			call atohex 
1295 80				add b 
1296 5f				ld e, a 
1297 d5				push de 
1298 e1				pop hl 
1299 c9				ret 
129a			 
129a			; pass hl. returns z set if the byte at hl is a digit 
129a			;isdigithl:  
129a			;	push bc 
129a			;	ld a,(hl) 
129a			;	cp ':' 
129a			;	jr nc, .isdf 		; > 
129a			;	cp '0' 
129a			;	jr c, .isdf		; < 
129a			; 
129a			;	; TODO find a better way to set z 
129a			; 
129a			;	ld b,a 
129a			;	cp b 
129a			;	pop bc 
129a			;	ret 
129a			; 
129a			;.isdf:	; not digit so clear z 
129a			; 
129a			;	; TODO find a better way to unset z 
129a			; 
129a			;	ld b,a 
129a			;	inc b 
129a			;	cp b 
129a			; 
129a			;	pop bc 
129a			;	ret 
129a				 
129a				 
129a			 
129a			 
129a			; pass hl as the four byte address to load 
129a			 
129a			get_word_hl:  
129a e5				push hl 
129b cd 3a 12			call get_byte 
129e				 
129e 47				ld b, a 
129f			 
129f e1				pop hl 
12a0 23				inc hl 
12a1 23				inc hl 
12a2			 
12a2			; TODO not able to handle a-f  
12a2 7e				ld a,(hl) 
12a3			;	;cp ':' 
12a3			;	cp 'g' 
12a3			;	jr nc, .single_byte_hl 		; > 
12a3			;	cp 'G' 
12a3			;	jr nc, .single_byte_hl 		; > 
12a3			;	cp '0' 
12a3			;	jr c, .single_byte_hl		; < 
12a3			 
12a3				;call isdigithl 
12a3 fe 00			cp 0 
12a5 28 06			jr z, .single_byte_hl 
12a7			 
12a7			.getwhln:   ; hex word so get next byte 
12a7			 
12a7 cd 3a 12			call get_byte 
12aa 6f				ld l, a 
12ab 60				ld h,b 
12ac c9				ret 
12ad 68			.single_byte_hl:   ld l,b 
12ae 26 00				ld h,0 
12b0 c9					ret 
12b1			 
12b1			 
12b1			 
12b1			 
12b1 21 1e 1d			ld hl,asc+1 
12b4			;	ld a, (hl) 
12b4			;	call nibble2val 
12b4 cd 3a 12			call get_byte 
12b7			 
12b7			;	call fourehexhl 
12b7 32 30 f1			ld (scratch+52),a 
12ba				 
12ba 21 2e f1			ld hl,scratch+50 
12bd 22 1f f4			ld (os_cur_ptr),hl 
12c0			 
12c0 c9				ret 
12c1			 
12c1			 
12c1			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
12c1			 
12c1			; Decimal Unsigned Version 
12c1			 
12c1			;Number in a to decimal ASCII 
12c1			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
12c1			;Example: display a=56 as "056" 
12c1			;input: a = number 
12c1			;Output: a=0,value of a in the screen 
12c1			;destroys af,bc (don't know about hl and de) 
12c1			DispAToASCII: 
12c1 0e 9c			ld	c,-100 
12c3 cd cd 12			call	.Na1 
12c6 0e f6			ld	c,-10 
12c8 cd cd 12			call	.Na1 
12cb 0e ff			ld	c,-1 
12cd 06 2f		.Na1:	ld	b,'0'-1 
12cf 04			.Na2:	inc	b 
12d0 81				add	a,c 
12d1 38 fc			jr	c,.Na2 
12d3 91				sub	c		;works as add 100/10/1 
12d4 f5				push af		;safer than ld c,a 
12d5 78				ld	a,b		;char is in b 
12d6			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
12d6 f1				pop af		;safer than ld a,c 
12d7 c9				ret 
12d8			 
12d8			; Decimal Signed Version 
12d8			 
12d8			; DispA 
12d8			; -------------------------------------------------------------- 
12d8			; Converts a signed integer value to a zero-terminated ASCII 
12d8			; string representative of that value (using radix 10). 
12d8			; -------------------------------------------------------------- 
12d8			; INPUTS: 
12d8			;     HL     Value to convert (two's complement integer). 
12d8			;     DE     Base address of string destination. (pointer). 
12d8			; -------------------------------------------------------------- 
12d8			; OUTPUTS: 
12d8			;     None 
12d8			; -------------------------------------------------------------- 
12d8			; REGISTERS/MEMORY DESTROYED 
12d8			; AF HL 
12d8			; -------------------------------------------------------------- 
12d8			 
12d8			;DispHLToASCII: 
12d8			;   push    de 
12d8			;   push    bc 
12d8			; 
12d8			;; Detect sign of HL. 
12d8			;    bit    7, h 
12d8			;    jr     z, ._DoConvert 
12d8			; 
12d8			;; HL is negative. Output '-' to string and negate HL. 
12d8			;    ld     a, '-' 
12d8			;    ld     (de), a 
12d8			;    inc    de 
12d8			; 
12d8			;; Negate HL (using two's complement) 
12d8			;    xor    a 
12d8			;    sub    l 
12d8			;    ld     l, a 
12d8			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
12d8			;    sbc    a, h 
12d8			;    ld     h, a 
12d8			; 
12d8			;; Convert HL to digit characters 
12d8			;._DoConvert: 
12d8			;    ld     b, 0     ; B will count character length of number 
12d8			;-   ld     a, 10 
12d8			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
12d8			;    push   af 
12d8			;    inc    b 
12d8			;    ld     a, h 
12d8			;    or     l 
12d8			;    jr     nz, - 
12d8			; 
12d8			;; Retrieve digits from stack 
12d8			;-   pop    af 
12d8			;    or     $30 
12d8			;    ld     (de), a 
12d8			;    inc    de 
12d8			;    djnz   - 
12d8			; 
12d8			;; Terminate string with NULL 
12d8			;    xor    a 
12d8			;    ld     (de), a 
12d8			; 
12d8			;    pop    bc 
12d8			;    pop    de 
12d8			;    ret 
12d8			 
12d8			;Comments 
12d8			; 
12d8			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
12d8			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
12d8			;    Note that the output string will not be fixed-width. 
12d8			; 
12d8			;Example Usage 
12d8			; 
12d8			;    ld    hl, -1004 
12d8			;    ld    de, OP1 
12d8			;    call  DispA 
12d8			;    ld    hl, OP1 
12d8			;    syscall  PutS 
12d8			 
12d8			 
12d8			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12d8			 
12d8			 
12d8			;Converts an ASCII string to an unsigned 16-bit integer 
12d8			;Quits when it reaches a non-decimal digit 
12d8			 
12d8			string_to_uint16: 
12d8			atoui_16: 
12d8			;Input: 
12d8			;     DE points to the string 
12d8			;Outputs: 
12d8			;     HL is the result 
12d8			;     A is the 8-bit value of the number 
12d8			;     DE points to the byte after the number 
12d8			;Destroys: 
12d8			;     BC 
12d8			;       if the string is non-empty, BC is HL/10 
12d8			;Size:  24 bytes 
12d8			;Speed: 42+d(104+{0,9}) 
12d8			;       d is the number of digits in the number 
12d8			;       max is 640 cycles for a 5 digit number 
12d8			;Assuming no leading zeros: 
12d8			;1 digit:  146cc 
12d8			;2 digit:  250cc 
12d8			;3 digit:  354cc or 363cc (avg: 354.126cc) 
12d8			;4 digit:  458cc or 467cc (avg: 458.27cc) 
12d8			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
12d8			;avg: 544.81158447265625cc (544+13297/16384) 
12d8			;=============================================================== 
12d8 21 00 00		  ld hl,0 
12db			.u16a: 
12db 1a			  ld a,(de) 
12dc d6 30		  sub 30h 
12de fe 0a		  cp 10 
12e0 d0			  ret nc 
12e1 13			  inc de 
12e2 44			  ld b,h 
12e3 4d			  ld c,l 
12e4 29			  add hl,hl 
12e5 29			  add hl,hl 
12e6 09			  add hl,bc 
12e7 29			  add hl,hl 
12e8 85			  add a,l 
12e9 6f			  ld l,a 
12ea 30 ef		  jr nc,.u16a 
12ec 24			  inc h 
12ed c3 db 12		  jp .u16a 
12f0			 
12f0			 
12f0			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12f0			 
12f0			;written by Zeda 
12f0			;Converts a 16-bit unsigned integer to an ASCII string. 
12f0			 
12f0			uitoa_16: 
12f0			;Input: 
12f0			;   DE is the number to convert 
12f0			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
12f0			;Output: 
12f0			;   HL points to the null-terminated ASCII string 
12f0			;      NOTE: This isn't necessarily the same as the input HL. 
12f0 d5			  push de 
12f1 c5			  push bc 
12f2 f5			  push af 
12f3 eb			  ex de,hl 
12f4			 
12f4 01 f0 d8		  ld bc,-10000 
12f7 3e 2f		  ld a,'0'-1 
12f9 3c			  inc a 
12fa 09			  add hl,bc  
12fb 38 fc		   jr c,$-2 
12fd 12			  ld (de),a 
12fe 13			  inc de 
12ff			 
12ff 01 e8 03		  ld bc,1000 
1302 3e 3a		  ld a,'9'+1 
1304 3d			  dec a  
1305 09			  add hl,bc  
1306 30 fc		   jr nc,$-2 
1308 12			  ld (de),a 
1309 13			  inc de 
130a			 
130a 01 9c ff		  ld bc,-100 
130d 3e 2f		  ld a,'0'-1 
130f 3c			  inc a  
1310 09			  add hl,bc  
1311 38 fc		   jr c,$-2 
1313 12			  ld (de),a 
1314 13			  inc de 
1315			 
1315 7d			  ld a,l 
1316 26 3a		  ld h,'9'+1 
1318 25			  dec h  
1319 c6 0a		  add a,10  
131b 30 fb		   jr nc,$-3 
131d c6 30		  add a,'0' 
131f eb			  ex de,hl 
1320 72			  ld (hl),d 
1321 23			  inc hl 
1322 77			  ld (hl),a 
1323 23			  inc hl 
1324 36 00		  ld (hl),0 
1326			 
1326			;Now strip the leading zeros 
1326 0e fa		  ld c,-6 
1328 09			  add hl,bc 
1329 3e 30		  ld a,'0' 
132b 23			  inc hl  
132c be			  cp (hl)  
132d 28 fc		  jr z,$-2 
132f			 
132f			;Make sure that the string is non-empty! 
132f 7e			  ld a,(hl) 
1330 b7			  or a 
1331 20 01		  jr nz,.atoub 
1333 2b			  dec hl 
1334			.atoub: 
1334			 
1334 f1			  pop af 
1335 c1			  pop bc 
1336 d1			  pop de 
1337 c9			  ret 
1338			 
1338			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1338			 
1338			toUpper: 
1338			;A is the char. 
1338			;If A is a lowercase letter, this sets it to the matching uppercase 
1338			;18cc or 30cc or 41cc 
1338			;avg: 26.75cc 
1338 fe 61		  cp 'a' 
133a d8			  ret c 
133b fe 7b		  cp 'z'+1 
133d d0			  ret nc 
133e d6 20		  sub 'a'-'A' 
1340 c9			  ret 
1341			 
1341			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1341			 
1341			; String Length 
1341			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1341			 
1341			; Get the length of the null-terminated string starting at $8000 hl 
1341			;    LD     HL, $8000 
1341			 
1341			strlenz: 
1341			 
1341 af			    XOR    A               ; Zero is the value we are looking for. 
1342 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1343 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1344			                           ; 65, 536 bytes (the entire addressable memory space). 
1344 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1346			 
1346			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1346 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1347 6f			    LD     L, A             ; number of bytes 
1348 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
134a 2b			    DEC    HL              ; Compensate for null. 
134b c9				ret 
134c			 
134c			; Get the length of the A terminated string starting at $8000 hl 
134c			;    LD     HL, $8000 
134c			 
134c			strlent: 
134c			 
134c			                  ; A is the value we are looking for. 
134c 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
134e 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1350			                           ; 65, 536 bytes (the entire addressable memory space). 
1350 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1352			 
1352			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1352 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1354 2e 00		    LD     L, 0             ; number of bytes 
1356 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1358 2b			    DEC    HL              ; Compensate for null. 
1359 c9				ret 
135a			 
135a			 
135a			;Comparing Strings 
135a			 
135a			;IN    HL     Address of string1. 
135a			;      DE     Address of string2. 
135a			 
135a			; doc given but wrong??? 
135a			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
135a			;      carry  Set if string1 > string2, reset if string1 <= string2. 
135a			; tested 
135a			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
135a			 
135a			strcmp_old: 
135a e5			    PUSH   HL 
135b d5			    PUSH   DE 
135c			 
135c 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
135d be			    CP     (HL)            ; (want to minimize work). 
135e 38 01		    JR     C, Str1IsBigger 
1360 7e			    LD     A, (HL) 
1361			 
1361			Str1IsBigger: 
1361 4f			    LD     C, A             ; Put length in BC 
1362 06 00		    LD     B, 0 
1364 13			    INC    DE              ; Increment pointers to meat of string. 
1365 23			    INC    HL 
1366			 
1366			CmpLoop: 
1366 1a			    LD     A, (DE)          ; Compare bytes. 
1367 ed a1		    CPI 
1369 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
136b 13			    INC    DE              ; Update pointer. 
136c ea 66 13		    JP     PE, CmpLoop 
136f			 
136f d1			    POP    DE 
1370 e1			    POP    HL 
1371 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1372 be			    CP     (HL) 
1373 c9			    RET 
1374			 
1374			NoMatch: 
1374 2b			    DEC    HL 
1375 be			    CP     (HL)            ; Compare again to affect carry. 
1376 d1			    POP    DE 
1377 e1			    POP    HL 
1378 c9			    RET 
1379			 
1379			;; test strmp 
1379			; 
1379			;ld de, .str1 
1379			;ld hl, .str2 
1379			;call strcmp 
1379			;jr z, .z1 
1379			;;this 
1379			;	if DEBUG_FORTH_WORDS 
1379			;		DMARK "NZ1" 
1379			;		CALLMONITOR 
1379			;	endif 
1379			;.z1: 
1379			; 
1379			;	if DEBUG_FORTH_WORDS 
1379			;		DMARK "ZZ1" 
1379			;		CALLMONITOR 
1379			;	endif 
1379			; 
1379			;ld de, .str1 
1379			;ld hl, .str1 
1379			;call strcmp 
1379			;jr z, .z2 
1379			;;this 
1379			;	if DEBUG_FORTH_WORDS 
1379			;		DMARK "NZ2" 
1379			;		CALLMONITOR 
1379			;	endif 
1379			;.z2: 
1379			; 
1379			;	if DEBUG_FORTH_WORDS 
1379			;		DMARK "ZZ2" 
1379			;		CALLMONITOR 
1379			;	endif 
1379			; 
1379			;ld de, .str1 
1379			;ld hl, .str2 
1379			;call strcmp 
1379			;jr c, .c1 
1379			; 
1379			;	if DEBUG_FORTH_WORDS 
1379			;		DMARK "Nc1" 
1379			;		CALLMONITOR 
1379			;	endif 
1379			;.c1: 
1379			;;this 
1379			;	if DEBUG_FORTH_WORDS 
1379			;		DMARK "cc1" 
1379			;		CALLMONITOR 
1379			;	endif 
1379			; 
1379			;ld de, .str1 
1379			;ld hl, .str1 
1379			;call strcmp 
1379			;jr c, .c2 
1379			;;this 
1379			;	if DEBUG_FORTH_WORDS 
1379			;		DMARK "Nc2" 
1379			;		CALLMONITOR 
1379			;	endif 
1379			;.c2: 
1379			; 
1379			;	if DEBUG_FORTH_WORDS 
1379			;		DMARK "cc2" 
1379			;		CALLMONITOR 
1379			;	endif 
1379			;	NEXTW 
1379			;.str1:   db "string1",0 
1379			;.str2:   db "string2",0 
1379			 
1379			; only care about direct match or not 
1379			; hl and de strings 
1379			; zero set if the same 
1379			 
1379			strcmp: 
1379 1a				ld a, (de) 
137a be				cp (hl) 
137b 28 02			jr z, .ssame 
137d b7				or a 
137e c9				ret 
137f			 
137f			.ssame:  
137f fe 00			cp 0 
1381 c8				ret z 
1382			 
1382 23				inc hl 
1383 13				inc de 
1384 18 f3			jr strcmp 
1386				 
1386				 
1386			 
1386			;Copyright (c) 2014, Luke Maurits 
1386			;All rights reserved. 
1386			; 
1386			;Redistribution and use in source and binary forms, with or without 
1386			;modification, are permitted provided that the following conditions are met: 
1386			; 
1386			;* Redistributions of source code must retain the above copyright notice, this 
1386			;  list of conditions and the following disclaimer. 
1386			; 
1386			;* Redistributions in binary form must reproduce the above copyright notice, 
1386			;  this list of conditions and the following disclaimer in the documentation 
1386			;  and/or other materials provided with the distribution. 
1386			; 
1386			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
1386			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
1386			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
1386			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
1386			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
1386			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
1386			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
1386			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
1386			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
1386			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
1386			 
1386			; https://github.com/lmaurits/lm512/blob/master/string.z80 
1386			 
1386			StrictStrCmp: 
1386				; Load next chars of each string 
1386 1a				ld a, (de) 
1387 47				ld b, a 
1388 7e				ld a, (hl) 
1389				; Compare 
1389 b8				cp b 
138a				; Return non-zero if chars don't match 
138a c0				ret nz 
138b				; Check for end of both strings 
138b fe 00			cp "\0" 
138d				; Return if strings have ended 
138d c8				ret z 
138e				; Otherwise, advance to next chars 
138e 23				inc hl 
138f 13				inc de 
1390 18 f4			jr StrictStrCmp 
1392			 
1392			;end 
1392			; eof 
1392			 
1392			 
1392			 
1392			 
1392			 
1392			 
# End of file firmware_strings.asm
1392			include "firmware_memory.asm"   ; malloc and free  
1392			 
1392			if DEBUG_FORTH_MALLOC_HIGH 
1392			.mallocsize: db "Wants malloc >256",0 
1392			.mallocasize: db "MALLOC gives >256",0 
1392			.malloczero: db "MALLOC gives zero",0 
1392			 
1392			malloc_guard_zerolen: 
1392				push hl 
1392				push de 
1392				push af 
1392			 
1392				ld de, 0 
1392			        call cmp16 
1392				jr nz, .lowalloz 
1392			 
1392				push hl 
1392				push de 
1392					ld hl, display_fb0 
1392					ld (display_fb_active), hl 
1392				call clear_display 
1392				ld a, 0 
1392				ld de, .malloczero 
1392				call str_at_display 
1392				call update_display 
1392				call delay1s 
1392				call delay1s 
1392				call bp_on 
1392			;	ld a, 0 
1392			;	ld (os_view_disable), a 
1392			 
1392				pop de 
1392				pop hl 
1392			 
1392				 
1392			 
1392				CALLMONITOR 
1392			.lowalloz: 
1392			 
1392			 
1392				pop af 
1392				pop de 
1392				pop hl 
1392			ret 
1392			 
1392			malloc_guard_entry: 
1392				push hl 
1392				push de 
1392				push af 
1392			 
1392			 	or a      ;clear carry flag 
1392				push hl 
1392				ld de, 255 
1392				sbc hl, de 
1392				jr c, .lowalloc 
1392			 
1392				push de 
1392					ld hl, display_fb0 
1392					ld (display_fb_active), hl 
1392				call clear_display 
1392				ld a, 0 
1392				ld de, .mallocsize 
1392				call str_at_display 
1392				call update_display 
1392				call delay1s 
1392				call delay1s 
1392			;	ld a, 0 
1392			;	ld (os_view_disable), a 
1392				call bp_on 
1392			 
1392				pop de 
1392				pop hl 
1392			 
1392				 
1392			 
1392				CALLMONITOR 
1392				jr .lowdone 
1392			.lowalloc: 
1392			 
1392			 
1392				pop hl 
1392			.lowdone:	pop af 
1392				pop de 
1392				pop hl 
1392			ret 
1392			 
1392			malloc_guard_exit: 
1392				push hl 
1392				push de 
1392				push af 
1392			 
1392			 	or a      ;clear carry flag 
1392				push hl 
1392				ld de, 255 
1392				sbc hl, de 
1392				jr c, .lowallocx 
1392			 
1392				push de 
1392					ld hl, display_fb0 
1392					ld (display_fb_active), hl 
1392				call clear_display 
1392				ld a, 0 
1392				ld de, .mallocasize 
1392				call str_at_display 
1392				call update_display 
1392				call delay1s 
1392				call delay1s 
1392			;	ld a, 0 
1392			;	ld (os_view_disable), a 
1392				call bp_on 
1392				pop de 
1392				pop hl 
1392			 
1392				CALLMONITOR 
1392				jr .lowdonex 
1392			.lowallocx: 
1392			 
1392				pop hl 
1392			.lowdonex:	pop af 
1392				pop de 
1392				pop hl 
1392			ret 
1392			endif 
1392			 
1392			if MALLOC_2 
1392			; Z80 Malloc and Free Functions 
1392			 
1392			; Malloc Function: 
1392			; Input: 
1392			;   HL: Size of block to allocate 
1392			; Output: 
1392			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1392			 
1392			malloc: 
1392				 
1392			if DEBUG_FORTH_MALLOC_HIGH 
1392			call malloc_guard_entry 
1392			endif 
1392			 
1392			 
1392			 
1392			 
1392					if DEBUG_FORTH_MALLOC 
1392						DMARK "mal" 
1392						CALLMONITOR 
1392					endif 
1392			    push af            ; Save AF register 
1392			    ld a, l            ; Load low byte of size into A 
1392			    or h               ; Check if size is zero 
1392			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1392			 
1392			    ; Allocate memory 
1392			    ld hl, (heap_start) ; Load start of heap into HL 
1392					if DEBUG_FORTH_MALLOC 
1392						DMARK "ma1" 
1392						CALLMONITOR 
1392					endif 
1392			    call malloc_internal ; Call internal malloc function 
1392			    pop af             ; Restore AF register 
1392			if DEBUG_FORTH_MALLOC_HIGH 
1392			call malloc_guard_exit 
1392			call malloc_guard_zerolen 
1392			endif 
1392			    ret                ; Return 
1392			 
1392			; Free Function: 
1392			; Input: 
1392			;   HL: Pointer to memory block to free 
1392			; Output: 
1392			;   None 
1392			 
1392			free: 
1392			    push af            ; Save AF register 
1392			    ld a, l            ; Load low byte of pointer into A 
1392			    or h               ; Check if pointer is NULL 
1392			    jp z, free_exit    ; If pointer is NULL, exit 
1392			 
1392			    ; Free memory 
1392			    ld hl, (heap_start) ; Load start of heap into HL 
1392			    call free_internal  ; Call internal free function 
1392			    pop af             ; Restore AF register 
1392			    ret                ; Return 
1392			 
1392			; Internal Malloc Function: 
1392			; Input: 
1392			;   HL: Size of block to allocate 
1392			; Output: 
1392			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1392			 
1392			malloc_internal: 
1392			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1392			    add hl, bc         ; Add management overhead to requested size 
1392			    ex de, hl          ; Save total size in DE, and keep it in HL 
1392					if DEBUG_FORTH_MALLOC 
1392						DMARK "ma2" 
1392						CALLMONITOR 
1392					endif 
1392			 
1392			    ; Search for free memory block 
1392			    ld de, (heap_end)  ; Load end of heap into DE 
1392			    ld bc, 0           ; Initialize counter 
1392			 
1392					if DEBUG_FORTH_MALLOC 
1392						DMARK "ma2" 
1392						CALLMONITOR 
1392					endif 
1392			malloc_search_loop: 
1392			    ; Check if current block is free 
1392			    ld a, (hl)         ; Load current block's status (free or used) 
1392			    cp 0               ; Compare with zero (free) 
1392			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1392			 
1392			    ; Check if current block is large enough 
1392			    ld a, (hl+1)       ; Load high byte of block size 
1392			    cp l               ; Compare with low byte of requested size 
1392			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1392			 
1392			    ld a, (hl+2)       ; Load low byte of block size 
1392			    cp h               ; Compare with high byte of requested size 
1392			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1392			 
1392			    ; Mark block as used 
1392			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1392			 
1392			    ; Calculate remaining space in block 
1392			    ld bc, 0           ; Clear BC 
1392			    add hl, bc         ; Increment HL to point to start of data block 
1392			    add hl, de         ; HL = HL + DE (total size) 
1392			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1392			    add hl, bc         ; Add management overhead to start of data block 
1392			 
1392			    ; Save pointer to allocated block in HL 
1392			if DEBUG_FORTH_MALLOC_HIGH 
1392						DMARK "ma5" 
1392			call malloc_guard_exit 
1392			call malloc_guard_zerolen 
1392			endif 
1392			    ret 
1392			 
1392			malloc_skip_block_check: 
1392			    ; Move to the next block 
1392			    ld bc, 3           ; Size of management overhead 
1392			    add hl, bc         ; Move to the next block 
1392			    inc de             ; Increment counter 
1392			 
1392			    ; Check if we have reached the end of heap 
1392			    ld a, e            ; Load low byte of heap end address 
1392			    cp (hl)            ; Compare with low byte of current address 
1392			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1392			    ld a, d            ; Load high byte of heap end address 
1392			    cp 0               ; Check if it's zero (end of memory) 
1392			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1392			 
1392			    ; If we reached here, allocation failed 
1392			    xor a              ; Set result to NULL 
1392			if DEBUG_FORTH_MALLOC_HIGH 
1392						DMARK "ma6" 
1392			call malloc_guard_exit 
1392			call malloc_guard_zerolen 
1392			endif 
1392			    ret 
1392			malloc_exit: 
1392			if DEBUG_FORTH_MALLOC_HIGH 
1392						DMARK "ma7" 
1392			call malloc_guard_exit 
1392			call malloc_guard_zerolen 
1392			endif 
1392			    ret 
1392			 
1392			; Internal Free Function: 
1392			; Input: 
1392			;   HL: Pointer to memory block to free 
1392			; Output: 
1392			;   None 
1392			 
1392			free_internal: 
1392			    ld de, (heap_start) ; Load start of heap into DE 
1392			    ld bc, 0            ; Initialize counter 
1392			 
1392			free_search_loop: 
1392			    ; Check if current block contains the pointer 
1392			    ld a, l             ; Load low byte of pointer 
1392			    cp (hl+1)           ; Compare with high byte of current block's address 
1392			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1392			    ld a, h             ; Load high byte of pointer 
1392			    cp (hl+2)           ; Compare with low byte of current block's address 
1392			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1392			 
1392			    ; Mark block as free 
1392			    ld (hl), 0          ; Set status byte to indicate free block 
1392			    ret                 ; Return 
1392			 
1392			free_skip_block_check: 
1392			    ; Move to the next block 
1392			    ld bc, 3            ; Size of management overhead 
1392			    add hl, bc          ; Move to the next block 
1392			    inc de              ; Increment counter 
1392			 
1392			    ; Check if we have reached the end of heap 
1392			    ld a, e             ; Load low byte of heap end address 
1392			    cp (hl)             ; Compare with low byte of current address 
1392			    jr nz, free_search_loop  ; If not equal, continue searching 
1392			    ld a, d             ; Load high byte of heap end address 
1392			    cp 0                ; Check if it's zero (end of memory) 
1392			    jr nz, free_search_loop  ; If not zero, continue searching 
1392			 
1392			    ; If we reached here, pointer is not found in heap 
1392			    ret 
1392			 
1392			free_exit: 
1392			    ret                 ; Return 
1392			 
1392			; Define heap start and end addresses 
1392			;heap_start:    .dw 0xC000   ; Start of heap 
1392			;heap_end:      .dw 0xE000   ; End of heap 
1392			 
1392			endif 
1392			 
1392			 
1392			if MALLOC_1 
1392			 
1392			 
1392			 
1392			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1392			 
1392			;moved to firmware.asm 
1392			;heap_start        .equ  0x9000      ; Starting address of heap 
1392			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1392			 
1392			;      .org 0 
1392			;      jp    main 
1392			 
1392			 
1392			;      .org  0x100 
1392			;main: 
1392			;      ld    HL, 0x8100 
1392			;      ld    SP, HL 
1392			; 
1392			;      call  heap_init 
1392			; 
1392			;      ; Make some allocations 
1392			;      ld    HL, 12 
1392			;      call  malloc            ; Allocates 0x9004 
1392			; 
1392			;      ld    HL, 12 
1392			;      call  malloc            ; Allocates 0x9014 
1392			; 
1392			;      ld    HL, 12 
1392			;      call  malloc            ; Allocates 0x9024 
1392			; 
1392			;      ; Free some allocations 
1392			;      ld    HL, 0x9014 
1392			;      call  free 
1392			; 
1392			;      ld    HL, 0x9004 
1392			;      call  free 
1392			; 
1392			;      ld    HL, 0x9024 
1392			;      call  free 
1392			; 
1392			; 
1392			;      halt 
1392			 
1392			 
1392			;------------------------------------------------------------------------------ 
1392			;     heap_init                                                               : 
1392			;                                                                             : 
1392			; Description                                                                 : 
1392			;     Initialise the heap and make it ready for malloc and free operations.   : 
1392			;                                                                             : 
1392			;     The heap is maintained as a linked list, starting with an initial       : 
1392			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1392			;     the first free block in the heap. Each block then points to the next    : 
1392			;     free block within the heap, and the free list ends at the first block   : 
1392			;     with a null pointer to the next free block.                             : 
1392			;                                                                             : 
1392			; Parameters                                                                  : 
1392			;     Inputs are compile-time only. Two defines which specify the starting    : 
1392			;     address of the heap and its size are required, along with a memory      : 
1392			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1392			;     principally stores a pointer to the first free block in the heap.       : 
1392			;                                                                             : 
1392			; Returns                                                                     : 
1392			;     Nothing                                                                 : 
1392			;------------------------------------------------------------------------------ 
1392			heap_init: 
1392 e5			      push  HL 
1393			 
1393			      ; Initialise free list struct 
1393 21 0e 80		      ld    HL, heap_start 
1396 22 0a 80		      ld    (free_list), HL 
1399 21 00 00		      ld    HL, 0 
139c 22 0c 80		      ld    (free_list+2), HL 
139f			 
139f			      ; Insert first free block at bottom of heap, consumes entire heap 
139f 21 d3 f0		      ld    HL, heap_start+heap_size-4 
13a2 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
13a5 21 c5 70		      ld    HL, heap_size-4 
13a8 22 10 80		      ld    (heap_start+2), HL      ; Block size 
13ab			 
13ab			      ; Insert end of free list block at top of heap - two null words will 
13ab			      ; terminate the free list 
13ab 21 00 00		      ld    HL, 0 
13ae 22 d5 f0		      ld    (heap_start+heap_size-2), HL 
13b1 22 d3 f0		      ld    (heap_start+heap_size-4), HL 
13b4			 
13b4 e1			      pop   HL 
13b5			 
13b5 c9			      ret 
13b6			 
13b6			 
13b6			;------------------------------------------------------------------------------ 
13b6			;     malloc                                                                  : 
13b6			;                                                                             : 
13b6			; Description                                                                 : 
13b6			;     Allocates the wanted space from the heap and returns the address of the : 
13b6			;     first useable byte of the allocation.                                   : 
13b6			;                                                                             : 
13b6			;     Allocations can happen in one of two ways:                              : 
13b6			;                                                                             : 
13b6			;     1. A free block may be found which is the exact size wanted. In this    : 
13b6			;        case the block is removed from the free list and retuedn to the      : 
13b6			;        caller.                                                              : 
13b6			;     2. A free block may be found which is larger than the size wanted. In   : 
13b6			;        this case, the larger block is split into two. The first portion of  : 
13b6			;        this block will become the requested space by the malloc call and    : 
13b6			;        is returned to the caller. The second portion becomes a new free     : 
13b6			;        block, and the free list is adjusted to maintain continuity via this : 
13b6			;        newly created block.                                                 : 
13b6			;                                                                             : 
13b6			;     malloc does not set any initial value in the allocated space, the       : 
13b6			;     caller is required to do this as required.                              : 
13b6			;                                                                             : 
13b6			;     This implementation of malloc uses the stack exclusively, and is        : 
13b6			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13b6			;     advisable to disable interrupts before calling malloc, and recommended  : 
13b6			;     to avoid the use of malloc inside ISRs in general.                      : 
13b6			;                                                                             : 
13b6			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13b6			;                                                                             : 
13b6			; Parameters                                                                  : 
13b6			;     HL  Number of bytes wanted                                              : 
13b6			;                                                                             : 
13b6			; Returns                                                                     : 
13b6			;     HL  Address of the first useable byte of the allocation                 : 
13b6			;                                                                             : 
13b6			; Flags                                                                       : 
13b6			;     Z   Set if the allocation did not succeed, clear otherwise              : 
13b6			;                                                                             : 
13b6			; Stack frame                                                                 : 
13b6			;       |             |                                                       : 
13b6			;       +-------------+                                                       : 
13b6			;       |     BC      |                                                       : 
13b6			;       +-------------+                                                       : 
13b6			;       |     DE      |                                                       : 
13b6			;       +-------------+                                                       : 
13b6			;       |     IX      |                                                       : 
13b6			;       +-------------+                                                       : 
13b6			;       |  prev_free  |                                                       : 
13b6			;   +4  +-------------+                                                       : 
13b6			;       |  this_free  |                                                       : 
13b6			;   +2  +-------------+                                                       : 
13b6			;       |  next_free  |                                                       : 
13b6			;   +0  +-------------+                                                       : 
13b6			;       |             |                                                       : 
13b6			;                                                                             : 
13b6			;------------------------------------------------------------------------------ 
13b6			 
13b6			 
13b6			;malloc: 
13b6			; 
13b6			;	SAVESP ON 1 
13b6			; 
13b6			;	call malloc_code 
13b6			; 
13b6			;	CHECKSP ON 1 
13b6			;	ret 
13b6			 
13b6			 
13b6			malloc: 
13b6 c5			      push  BC 
13b7 d5			      push  DE 
13b8 dd e5		      push  IX 
13ba			if DEBUG_FORTH_MALLOC_HIGH 
13ba			call malloc_guard_entry 
13ba			endif 
13ba			 
13ba					if DEBUG_FORTH_MALLOC 
13ba						DMARK "mal" 
13ba						CALLMONITOR 
13ba					endif 
13ba 7c			      ld    A, H                    ; Exit if no space requested 
13bb b5			      or    L 
13bc ca 7b 14		      jp    Z, malloc_early_exit 
13bf			 
13bf			;inc hl 
13bf			;inc hl 
13bf			;inc hl 
13bf			; 
13bf			;inc hl 
13bf			;inc hl 
13bf			;inc hl 
13bf			;inc hl 
13bf			;inc hl 
13bf			;inc hl 
13bf			;inc hl 
13bf			;inc hl 
13bf			;inc hl 
13bf			 
13bf			 
13bf			 
13bf			 
13bf					if DEBUG_FORTH_MALLOC 
13bf						DMARK "maA" 
13bf						CALLMONITOR 
13bf					endif 
13bf			      ; Set up stack frame 
13bf eb			      ex    DE, HL 
13c0 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
13c3 39			      add   HL, SP 
13c4 f9			      ld    SP, HL 
13c5 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
13c9 dd 39		      add   IX, SP 
13cb			 
13cb			      ; Setup initial state 
13cb 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
13ce 19			      add   HL, DE 
13cf			 
13cf 44			      ld    B, H                    ; Move want to BC 
13d0 4d			      ld    C, L 
13d1			 
13d1 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
13d4 dd 75 04		      ld    (IX+4), L 
13d7 dd 74 05		      ld    (IX+5), H 
13da			 
13da 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
13db 23			      inc   HL 
13dc 56			      ld    D, (HL) 
13dd dd 73 02		      ld    (IX+2), E 
13e0 dd 72 03		      ld    (IX+3), D 
13e3 eb			      ex    DE, HL                  ; this_free ptr into HL 
13e4			 
13e4					if DEBUG_FORTH_MALLOC 
13e4						DMARK "maB" 
13e4						CALLMONITOR 
13e4					endif 
13e4			      ; Loop through free block list to find some space 
13e4			malloc_find_space: 
13e4 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13e5 23			      inc   HL 
13e6 56			      ld    D, (HL) 
13e7			 
13e7 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13e8 b3			      or    E 
13e9 ca 75 14		      jp    Z, malloc_no_space 
13ec			 
13ec dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
13ef dd 72 01		      ld    (IX+1), D 
13f2			 
13f2			      ; Does this block have enough space to make the allocation? 
13f2 23			      inc   HL                      ; Load free block size into DE 
13f3 5e			      ld    E, (HL) 
13f4 23			      inc   HL 
13f5 56			      ld    D, (HL) 
13f6			 
13f6 eb			      ex    DE, HL                  ; Check size of block against want 
13f7 b7			      or    A                       ; Ensure carry flag clear 
13f8 ed 42		      sbc   HL, BC 
13fa e5			      push  HL                      ; Store the result for later (new block size) 
13fb			 
13fb ca 4a 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
13fe 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1400			 
1400			      ; this_free block is not big enough, setup ptrs to test next free block 
1400 e1			      pop   HL                      ; Discard previous result 
1401			 
1401 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1404 dd 66 03		      ld    H, (IX+3) 
1407 dd 75 04		      ld    (IX+4), L 
140a dd 74 05		      ld    (IX+5), H 
140d			 
140d dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1410 dd 66 01		      ld    H, (IX+1) 
1413 dd 75 02		      ld    (IX+2), L 
1416 dd 74 03		      ld    (IX+3), H 
1419			 
1419					if DEBUG_FORTH_MALLOC 
1419						DMARK "MA>" 
1419						CALLMONITOR 
1419					endif 
1419 18 c9		      jr    malloc_find_space 
141b			 
141b			      ; split a bigger block into two - requested size and remaining size 
141b			malloc_alloc_split: 
141b					if DEBUG_FORTH_MALLOC 
141b						DMARK "MAs" 
141b						CALLMONITOR 
141b					endif 
141b eb			      ex    DE, HL                  ; Calculate address of new free block 
141c 2b			      dec   HL 
141d 2b			      dec   HL 
141e 2b			      dec   HL 
141f 09			      add   HL, BC 
1420			 
1420			      ; Create a new block and point it at next_free 
1420 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1423 dd 56 01		      ld    D, (IX+1) 
1426			 
1426 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1427 23			      inc   HL 
1428 72			      ld    (HL), D 
1429			 
1429 d1			      pop   DE                      ; Store size of new block into new block 
142a 23			      inc   HL 
142b 73			      ld    (HL), E 
142c 23			      inc   HL 
142d 72			      ld    (HL), D 
142e			 
142e			      ; Update this_free ptr to point to new block 
142e 2b			      dec   HL 
142f 2b			      dec   HL 
1430 2b			      dec   HL 
1431			 
1431 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1434 dd 56 03		      ld    D, (IX+3) 
1437			 
1437 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
143a dd 74 03		      ld    (IX+3), H 
143d			 
143d			      ; Modify this_free block to be allocation 
143d eb			      ex    DE, HL 
143e af			      xor   A                       ; Null the next block ptr of allocated block 
143f 77			      ld    (HL), A 
1440 23			      inc   HL 
1441 77			      ld    (HL), A 
1442			 
1442 23			      inc   HL                      ; Store want size into allocated block 
1443 71			      ld    (HL), C 
1444 23			      inc   HL 
1445 70			      ld    (HL), B 
1446 23			      inc   HL 
1447 e5			      push  HL                      ; Address of allocation to return 
1448			 
1448 18 19		      jr    malloc_update_links 
144a			 
144a			malloc_alloc_fit: 
144a e1			      pop   HL                      ; Dont need new block size, want is exact fit 
144b			 
144b					if DEBUG_FORTH_MALLOC 
144b						DMARK "MAf" 
144b						CALLMONITOR 
144b					endif 
144b			      ; Modify this_free block to be allocation 
144b eb			      ex    DE, HL 
144c 2b			      dec   HL 
144d 2b			      dec   HL 
144e 2b			      dec   HL 
144f			 
144f af			      xor   A                       ; Null the next block ptr of allocated block 
1450 77			      ld    (HL), A 
1451 23			      inc   HL 
1452 77			      ld    (HL), A 
1453			 
1453 23			      inc   HL                      ; Store address of allocation to return 
1454 23			      inc   HL 
1455 23			      inc   HL 
1456 e5			      push  HL 
1457			 
1457			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1457 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
145a dd 66 01		      ld    H, (IX+1) 
145d			 
145d dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1460 dd 74 03		      ld    (IX+3), H 
1463			 
1463			 
1463			malloc_update_links: 
1463			      ; Update prev_free ptr to point to this_free 
1463 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1466 dd 66 05		      ld    H, (IX+5) 
1469			 
1469 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
146c dd 56 03		      ld    D, (IX+3) 
146f			 
146f 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1470 23			      inc   HL 
1471 72			      ld    (HL), D 
1472			 
1472					if DEBUG_FORTH_MALLOC 
1472						DMARK "Mul" 
1472						CALLMONITOR 
1472					endif 
1472			      ; Clear the Z flag to indicate successful allocation 
1472 7a			      ld    A, D 
1473 b3			      or    E 
1474			 
1474 d1			      pop   DE                      ; Address of allocation 
1475					if DEBUG_FORTH_MALLOC 
1475						DMARK "MAu" 
1475						CALLMONITOR 
1475					endif 
1475			 
1475			malloc_no_space: 
1475 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1478 39			      add   HL, SP 
1479 f9			      ld    SP, HL 
147a			 
147a eb			      ex    DE, HL                  ; Alloc addr into HL for return 
147b					if DEBUG_FORTH_MALLOC 
147b						DMARK "MAN" 
147b						CALLMONITOR 
147b					endif 
147b			 
147b			malloc_early_exit: 
147b					if DEBUG_FORTH_MALLOC 
147b						DMARK "MAx" 
147b						CALLMONITOR 
147b					endif 
147b dd e1		      pop   IX 
147d d1			      pop   DE 
147e c1			      pop   BC 
147f			 
147f			if DEBUG_FORTH_MALLOC_HIGH 
147f			call malloc_guard_exit 
147f			call malloc_guard_zerolen 
147f			endif 
147f c9			      ret 
1480			 
1480			 
1480			;------------------------------------------------------------------------------ 
1480			;     free                                                                    : 
1480			;                                                                             : 
1480			; Description                                                                 : 
1480			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1480			;     returned by malloc, otherwise the behaviour is undefined.               : 
1480			;                                                                             : 
1480			;     Where possible, directly adjacent free blocks will be merged together   : 
1480			;     into larger blocks to help ensure that the heap does not become         : 
1480			;     excessively fragmented.                                                 : 
1480			;                                                                             : 
1480			;     free does not clear or set any other value into the freed space, and    : 
1480			;     therefore its contents may be visible through subsequent malloc's. The  : 
1480			;     caller should clear the freed space as required.                        : 
1480			;                                                                             : 
1480			;     This implementation of free uses the stack exclusively, and is          : 
1480			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1480			;     advisable to disable interrupts before calling free, and recommended    : 
1480			;     to avoid the use of free inside ISRs in general.                        : 
1480			;                                                                             : 
1480			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1480			;                                                                             : 
1480			; Parameters                                                                  : 
1480			;     HL  Pointer to address of first byte of allocation to be freed          : 
1480			;                                                                             : 
1480			; Returns                                                                     : 
1480			;     Nothing                                                                 : 
1480			;                                                                             : 
1480			; Stack frame                                                                 : 
1480			;       |             |                                                       : 
1480			;       +-------------+                                                       : 
1480			;       |     BC      |                                                       : 
1480			;       +-------------+                                                       : 
1480			;       |     DE      |                                                       : 
1480			;       +-------------+                                                       : 
1480			;       |     IX      |                                                       : 
1480			;       +-------------+                                                       : 
1480			;       |  prev_free  |                                                       : 
1480			;   +2  +-------------+                                                       : 
1480			;       |  next_free  |                                                       : 
1480			;   +0  +-------------+                                                       : 
1480			;       |             |                                                       : 
1480			;                                                                             : 
1480			;------------------------------------------------------------------------------ 
1480			free: 
1480 c5			      push  BC 
1481 d5			      push  DE 
1482 dd e5		      push  IX 
1484			 
1484 7c			      ld    A, H                    ; Exit if ptr is null 
1485 b5			      or    L 
1486 ca 4a 15		      jp    Z, free_early_exit 
1489			 
1489			      ; Set up stack frame 
1489 eb			      ex    DE, HL 
148a 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
148d 39			      add   HL, SP 
148e f9			      ld    SP, HL 
148f dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1493 dd 39		      add   IX, SP 
1495			 
1495			      ; The address in HL points to the start of the useable allocated space, 
1495			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1495			      ; address of the block itself. 
1495 eb			      ex    DE, HL 
1496 11 fc ff		      ld    DE, -4 
1499 19			      add   HL, DE 
149a			 
149a			      ; An allocated block must have a null next block pointer in it 
149a 7e			      ld    A, (HL) 
149b 23			      inc   HL 
149c b6			      or    (HL) 
149d c2 45 15		      jp    NZ, free_done 
14a0			 
14a0 2b			      dec   HL 
14a1			 
14a1 44			      ld    B, H                    ; Copy HL to BC 
14a2 4d			      ld    C, L 
14a3			 
14a3			      ; Loop through the free list to find the first block with an address 
14a3			      ; higher than the block being freed 
14a3 21 0a 80		      ld    HL, free_list 
14a6			 
14a6			free_find_higher_block: 
14a6 5e			      ld    E, (HL)                 ; Load next ptr from free block 
14a7 23			      inc   HL 
14a8 56			      ld    D, (HL) 
14a9 2b			      dec   HL 
14aa			 
14aa dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
14ad dd 72 01		      ld    (IX+1), D 
14b0 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
14b3 dd 74 03		      ld    (IX+3), H 
14b6			 
14b6 78			      ld    A, B                    ; Check if DE is greater than BC 
14b7 ba			      cp    D                       ; Compare MSB first 
14b8 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
14ba 30 04		      jr    NC, free_find_higher_block_skip 
14bc 79			      ld    A, C 
14bd bb			      cp    E                       ; Then compare LSB 
14be 38 08		      jr    C, free_found_higher_block 
14c0			 
14c0			free_find_higher_block_skip: 
14c0 7a			      ld    A, D                    ; Reached the end of the free list? 
14c1 b3			      or    E 
14c2 ca 45 15		      jp    Z, free_done 
14c5			 
14c5 eb			      ex    DE, HL 
14c6			 
14c6 18 de		      jr    free_find_higher_block 
14c8			 
14c8			free_found_higher_block: 
14c8			      ; Insert freed block between prev and next free blocks 
14c8 71			      ld    (HL), C                 ; Point prev free block to freed block 
14c9 23			      inc   HL 
14ca 70			      ld    (HL), B 
14cb			 
14cb 60			      ld    H, B                    ; Point freed block at next free block 
14cc 69			      ld    L, C 
14cd 73			      ld    (HL), E 
14ce 23			      inc   HL 
14cf 72			      ld    (HL), D 
14d0			 
14d0			      ; Check if the freed block is adjacent to the next free block 
14d0 23			      inc   HL                      ; Load size of freed block into HL 
14d1 5e			      ld    E, (HL) 
14d2 23			      inc   HL 
14d3 56			      ld    D, (HL) 
14d4 eb			      ex    DE, HL 
14d5			 
14d5 09			      add   HL, BC                  ; Add addr of freed block and its size 
14d6			 
14d6 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
14d9 dd 56 01		      ld    D, (IX+1) 
14dc			 
14dc b7			      or    A                       ; Clear the carry flag 
14dd ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14df 20 22		      jr    NZ, free_check_adjacent_to_prev 
14e1			 
14e1			      ; Freed block is adjacent to next, merge into one bigger block 
14e1 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14e2 5e			      ld    E, (HL) 
14e3 23			      inc   HL 
14e4 56			      ld    D, (HL) 
14e5 e5			      push  HL                      ; Save ptr to next block for later 
14e6			 
14e6 60			      ld    H, B                    ; Store ptr from next block into freed block 
14e7 69			      ld    L, C 
14e8 73			      ld    (HL), E 
14e9 23			      inc   HL 
14ea 72			      ld    (HL), D 
14eb			 
14eb e1			      pop   HL                      ; Restore ptr to next block 
14ec 23			      inc   HL                      ; Load size of next block into DE 
14ed 5e			      ld    E, (HL) 
14ee 23			      inc   HL 
14ef 56			      ld    D, (HL) 
14f0 d5			      push  DE                      ; Save next block size for later 
14f1			 
14f1 60			      ld    H, B                    ; Load size of freed block into HL 
14f2 69			      ld    L, C 
14f3 23			      inc   HL 
14f4 23			      inc   HL 
14f5 5e			      ld    E, (HL) 
14f6 23			      inc   HL 
14f7 56			      ld    D, (HL) 
14f8 eb			      ex    DE, HL 
14f9			 
14f9 d1			      pop   DE                      ; Restore size of next block 
14fa 19			      add   HL, DE                  ; Add sizes of both blocks 
14fb eb			      ex    DE, HL 
14fc			 
14fc 60			      ld    H, B                    ; Store new bigger size into freed block 
14fd 69			      ld    L, C 
14fe 23			      inc   HL 
14ff 23			      inc   HL 
1500 73			      ld    (HL), E 
1501 23			      inc   HL 
1502 72			      ld    (HL), D 
1503			 
1503			free_check_adjacent_to_prev: 
1503			      ; Check if the freed block is adjacent to the prev free block 
1503 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1506 dd 66 03		      ld    H, (IX+3) 
1509			 
1509 23			      inc   HL                      ; Size of prev free block into DE 
150a 23			      inc   HL 
150b 5e			      ld    E, (HL) 
150c 23			      inc   HL 
150d 56			      ld    D, (HL) 
150e 2b			      dec   HL 
150f 2b			      dec   HL 
1510 2b			      dec   HL 
1511			 
1511 19			      add   HL, DE                  ; Add prev block addr and size 
1512			 
1512 b7			      or    A                       ; Clear the carry flag 
1513 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1515 20 2e		      jr    NZ, free_done 
1517			 
1517			      ; Freed block is adjacent to prev, merge into one bigger block 
1517 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1518 69			      ld    L, C 
1519 5e			      ld    E, (HL) 
151a 23			      inc   HL 
151b 56			      ld    D, (HL) 
151c e5			      push  HL                      ; Save freed block ptr for later 
151d			 
151d dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1520 dd 66 03		      ld    H, (IX+3) 
1523 73			      ld    (HL), E 
1524 23			      inc   HL 
1525 72			      ld    (HL), D 
1526			 
1526 e1			      pop   HL                      ; Restore freed block ptr 
1527 23			      inc   HL                      ; Load size of freed block into DE 
1528 5e			      ld    E, (HL) 
1529 23			      inc   HL 
152a 56			      ld    D, (HL) 
152b d5			      push  DE                      ; Save freed block size for later 
152c			 
152c dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
152f dd 66 03		      ld    H, (IX+3) 
1532 23			      inc   HL 
1533 23			      inc   HL 
1534 5e			      ld    E, (HL) 
1535 23			      inc   HL 
1536 56			      ld    D, (HL) 
1537			 
1537 e1			      pop   HL                      ; Add sizes of both blocks 
1538 19			      add   HL, DE 
1539 eb			      ex    DE, HL 
153a			 
153a dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
153d dd 66 03		      ld    H, (IX+3) 
1540 23			      inc   HL 
1541 23			      inc   HL 
1542 73			      ld    (HL), E 
1543 23			      inc   HL 
1544 72			      ld    (HL), D 
1545			 
1545			free_done: 
1545 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1548 39			      add   HL, SP 
1549 f9			      ld    SP, HL 
154a			 
154a			free_early_exit: 
154a dd e1		      pop   IX 
154c d1			      pop   DE 
154d c1			      pop   BC 
154e			 
154e c9			      ret 
154f			 
154f			; moved to firmware.asm 
154f			; 
154f			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
154f			;                  .dw   0 
154f			 
154f			 
154f			endif 
154f			 
154f			 
154f			if MALLOC_3 
154f			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
154f			;heap_start        .equ  0x9000      ; Starting address of heap 
154f			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
154f			; 
154f			 ;     .org 0 
154f			  ;    jp    main 
154f			; 
154f			; 
154f			 ;     .org  0x100 
154f			;main: 
154f			 ;     ld    HL, 0x8100 
154f			  ;    ld    SP, HL 
154f			; 
154f			;      call  heap_init 
154f			 
154f			      ; Make some allocations 
154f			;      ld    HL, 12 
154f			;      call  malloc            ; Allocates 0x9004 
154f			; 
154f			 ;     ld    HL, 12 
154f			;      call  malloc            ; Allocates 0x9014 
154f			 
154f			;      ld    HL, 12 
154f			;      call  malloc            ; Allocates 0x9024 
154f			 
154f			      ; Free some allocations 
154f			;      ld    HL, 0x9014 
154f			;      call  free 
154f			 
154f			;      ld    HL, 0x9004 
154f			;      call  free 
154f			; 
154f			;      ld    HL, 0x9024 
154f			;      call  free 
154f			 
154f			 
154f			 ;     halt 
154f			 
154f			 
154f			;------------------------------------------------------------------------------ 
154f			;     heap_init                                                               : 
154f			;                                                                             : 
154f			; Description                                                                 : 
154f			;     Initialise the heap and make it ready for malloc and free operations.   : 
154f			;                                                                             : 
154f			;     The heap is maintained as a linked list, starting with an initial       : 
154f			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
154f			;     the first free block in the heap. Each block then points to the next    : 
154f			;     free block within the heap, and the free list ends at the first block   : 
154f			;     with a null pointer to the next free block.                             : 
154f			;                                                                             : 
154f			; Parameters                                                                  : 
154f			;     Inputs are compile-time only. Two defines which specify the starting    : 
154f			;     address of the heap and its size are required, along with a memory      : 
154f			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
154f			;     principally stores a pointer to the first free block in the heap.       : 
154f			;                                                                             : 
154f			; Returns                                                                     : 
154f			;     Nothing                                                                 : 
154f			;------------------------------------------------------------------------------ 
154f			heap_init: 
154f			      push  HL 
154f			 
154f			      ; Initialise free list struct 
154f			      ld    HL, heap_start 
154f			      ld    (free_list), HL 
154f			      ld    HL, 0 
154f			      ld    (free_list+2), HL 
154f			 
154f			      ; Insert first free block at bottom of heap, consumes entire heap 
154f			      ld    HL, heap_start+heap_size-4 
154f			      ld    (heap_start), HL        ; Next block (end of free list) 
154f			      ld    HL, heap_size-4 
154f			      ld    (heap_start+2), HL      ; Block size 
154f			 
154f			      ; Insert end of free list block at top of heap - two null words will 
154f			      ; terminate the free list 
154f			      ld    HL, 0 
154f			      ld    (heap_start+heap_size-2), HL 
154f			      ld    (heap_start+heap_size-4), HL 
154f			 
154f			      pop   HL 
154f			 
154f			      ret 
154f			 
154f			 
154f			;------------------------------------------------------------------------------ 
154f			;     malloc                                                                  : 
154f			;                                                                             : 
154f			; Description                                                                 : 
154f			;     Allocates the wanted space from the heap and returns the address of the : 
154f			;     first useable byte of the allocation.                                   : 
154f			;                                                                             : 
154f			;     Allocations can happen in one of two ways:                              : 
154f			;                                                                             : 
154f			;     1. A free block may be found which is the exact size wanted. In this    : 
154f			;        case the block is removed from the free list and retuedn to the      : 
154f			;        caller.                                                              : 
154f			;     2. A free block may be found which is larger than the size wanted. In   : 
154f			;        this case, the larger block is split into two. The first portion of  : 
154f			;        this block will become the requested space by the malloc call and    : 
154f			;        is returned to the caller. The second portion becomes a new free     : 
154f			;        block, and the free list is adjusted to maintain continuity via this : 
154f			;        newly created block.                                                 : 
154f			;                                                                             : 
154f			;     malloc does not set any initial value in the allocated space, the       : 
154f			;     caller is required to do this as required.                              : 
154f			;                                                                             : 
154f			;     This implementation of malloc uses the stack exclusively, and is        : 
154f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
154f			;     advisable to disable interrupts before calling malloc, and recommended  : 
154f			;     to avoid the use of malloc inside ISRs in general.                      : 
154f			;                                                                             : 
154f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
154f			;                                                                             : 
154f			; Parameters                                                                  : 
154f			;     HL  Number of bytes wanted                                              : 
154f			;                                                                             : 
154f			; Returns                                                                     : 
154f			;     HL  Address of the first useable byte of the allocation                 : 
154f			;                                                                             : 
154f			; Flags                                                                       : 
154f			;     Z   Set if the allocation did not succeed, clear otherwise              : 
154f			;                                                                             : 
154f			; Stack frame                                                                 : 
154f			;       |             |                                                       : 
154f			;       +-------------+                                                       : 
154f			;       |     BC      |                                                       : 
154f			;       +-------------+                                                       : 
154f			;       |     DE      |                                                       : 
154f			;       +-------------+                                                       : 
154f			;       |     IX      |                                                       : 
154f			;       +-------------+                                                       : 
154f			;       |  prev_free  |                                                       : 
154f			;   +4  +-------------+                                                       : 
154f			;       |  this_free  |                                                       : 
154f			;   +2  +-------------+                                                       : 
154f			;       |  next_free  |                                                       : 
154f			;   +0  +-------------+                                                       : 
154f			;       |             |                                                       : 
154f			;                                                                             : 
154f			;------------------------------------------------------------------------------ 
154f			malloc: 
154f			      push  BC 
154f			      push  DE 
154f			      push  IX 
154f			 
154f			      ld    A, H                    ; Exit if no space requested 
154f			      or    L 
154f			      jp    Z, malloc_early_exit 
154f			 
154f			      ; Set up stack frame 
154f			      ex    DE, HL 
154f			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
154f			      add   HL, SP 
154f			      ld    SP, HL 
154f			      ld    IX, 0                   ; Use IX as a frame pointer 
154f			      add   IX, SP 
154f			 
154f			      ; Setup initial state 
154f			      ld    HL, 4                   ; want must also include space used by block struct 
154f			      add   HL, DE 
154f			 
154f			      ld    B, H                    ; Move want to BC 
154f			      ld    C, L 
154f			 
154f			      ld    HL, free_list           ; Store prev_free ptr to stack 
154f			      ld    (IX+4), L 
154f			      ld    (IX+5), H 
154f			 
154f			      ld    E, (HL)                 ; Store this_free ptr to stack 
154f			      inc   HL 
154f			      ld    D, (HL) 
154f			      ld    (IX+2), E 
154f			      ld    (IX+3), D 
154f			      ex    DE, HL                  ; this_free ptr into HL 
154f			 
154f			      ; Loop through free block list to find some space 
154f			malloc_find_space: 
154f			      ld    E, (HL)                 ; Load next_free ptr into DE 
154f			      inc   HL 
154f			      ld    D, (HL) 
154f			 
154f			      ld    A, D                    ; Check for null next_free ptr - end of free list 
154f			      or    E 
154f			      jp    Z, malloc_no_space 
154f			 
154f			      ld    (IX+0), E               ; Store next_free ptr to stack 
154f			      ld    (IX+1), D 
154f			 
154f			      ; Does this block have enough space to make the allocation? 
154f			      inc   HL                      ; Load free block size into DE 
154f			      ld    E, (HL) 
154f			      inc   HL 
154f			      ld    D, (HL) 
154f			 
154f			      ex    DE, HL                  ; Check size of block against want 
154f			      or    A                       ; Ensure carry flag clear 
154f			      sbc   HL, BC 
154f			      push  HL                      ; Store the result for later (new block size) 
154f			 
154f			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
154f			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
154f			 
154f			      ; this_free block is not big enough, setup ptrs to test next free block 
154f			      pop   HL                      ; Discard previous result 
154f			 
154f			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
154f			      ld    H, (IX+3) 
154f			      ld    (IX+4), L 
154f			      ld    (IX+5), H 
154f			 
154f			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
154f			      ld    H, (IX+1) 
154f			      ld    (IX+2), L 
154f			      ld    (IX+3), H 
154f			 
154f			      jr    malloc_find_space 
154f			 
154f			      ; split a bigger block into two - requested size and remaining size 
154f			malloc_alloc_split: 
154f			      ex    DE, HL                  ; Calculate address of new free block 
154f			      dec   HL 
154f			      dec   HL 
154f			      dec   HL 
154f			      add   HL, BC 
154f			 
154f			      ; Create a new block and point it at next_free 
154f			      ld    E, (IX+0)               ; Load next_free ptr into DE 
154f			      ld    D, (IX+1) 
154f			 
154f			      ld    (HL), E                 ; Store next_free ptr into new block 
154f			      inc   HL 
154f			      ld    (HL), D 
154f			 
154f			      pop   DE                      ; Store size of new block into new block 
154f			      inc   HL 
154f			      ld    (HL), E 
154f			      inc   HL 
154f			      ld    (HL), D 
154f			 
154f			      ; Update this_free ptr to point to new block 
154f			      dec   HL 
154f			      dec   HL 
154f			      dec   HL 
154f			 
154f			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
154f			      ld    D, (IX+3) 
154f			 
154f			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
154f			      ld    (IX+3), H 
154f			 
154f			      ; Modify this_free block to be allocation 
154f			      ex    DE, HL 
154f			      xor   A                       ; Null the next block ptr of allocated block 
154f			      ld    (HL), A 
154f			      inc   HL 
154f			      ld    (HL), A 
154f			 
154f			      inc   HL                      ; Store want size into allocated block 
154f			      ld    (HL), C 
154f			      inc   HL 
154f			      ld    (HL), B 
154f			      inc   HL 
154f			      push  HL                      ; Address of allocation to return 
154f			 
154f			      jr    malloc_update_links 
154f			 
154f			malloc_alloc_fit: 
154f			      pop   HL                      ; Dont need new block size, want is exact fit 
154f			 
154f			      ; Modify this_free block to be allocation 
154f			      ex    DE, HL 
154f			      dec   HL 
154f			      dec   HL 
154f			      dec   HL 
154f			 
154f			      xor   A                       ; Null the next block ptr of allocated block 
154f			      ld    (HL), A 
154f			      inc   HL 
154f			      ld    (HL), A 
154f			 
154f			      inc   HL                      ; Store address of allocation to return 
154f			      inc   HL 
154f			      inc   HL 
154f			      push  HL 
154f			 
154f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
154f			      ld    L, (IX+0)               ; next_free to HL 
154f			      ld    H, (IX+1) 
154f			 
154f			      ld    (IX+2), L               ; HL to this_free 
154f			      ld    (IX+3), H 
154f			 
154f			 
154f			malloc_update_links: 
154f			      ; Update prev_free ptr to point to this_free 
154f			      ld    L, (IX+4)               ; prev_free ptr to HL 
154f			      ld    H, (IX+5) 
154f			 
154f			      ld    E, (IX+2)               ; this_free ptr to DE 
154f			      ld    D, (IX+3) 
154f			 
154f			      ld    (HL), E                 ; this_free ptr into prev_free 
154f			      inc   HL 
154f			      ld    (HL), D 
154f			 
154f			      ; Clear the Z flag to indicate successful allocation 
154f			      ld    A, D 
154f			      or    E 
154f			 
154f			      pop   DE                      ; Address of allocation 
154f			 
154f			malloc_no_space: 
154f			      ld    HL, 6                   ; Clean up stack frame 
154f			      add   HL, SP 
154f			      ld    SP, HL 
154f			 
154f			      ex    DE, HL                  ; Alloc addr into HL for return 
154f			 
154f			malloc_early_exit: 
154f			      pop   IX 
154f			      pop   DE 
154f			      pop   BC 
154f			 
154f			      ret 
154f			 
154f			 
154f			;------------------------------------------------------------------------------ 
154f			;     free                                                                    : 
154f			;                                                                             : 
154f			; Description                                                                 : 
154f			;     Return the space pointed to by HL to the heap. HL must be an address as : 
154f			;     returned by malloc, otherwise the behaviour is undefined.               : 
154f			;                                                                             : 
154f			;     Where possible, directly adjacent free blocks will be merged together   : 
154f			;     into larger blocks to help ensure that the heap does not become         : 
154f			;     excessively fragmented.                                                 : 
154f			;                                                                             : 
154f			;     free does not clear or set any other value into the freed space, and    : 
154f			;     therefore its contents may be visible through subsequent malloc's. The  : 
154f			;     caller should clear the freed space as required.                        : 
154f			;                                                                             : 
154f			;     This implementation of free uses the stack exclusively, and is          : 
154f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
154f			;     advisable to disable interrupts before calling free, and recommended    : 
154f			;     to avoid the use of free inside ISRs in general.                        : 
154f			;                                                                             : 
154f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
154f			;                                                                             : 
154f			; Parameters                                                                  : 
154f			;     HL  Pointer to address of first byte of allocation to be freed          : 
154f			;                                                                             : 
154f			; Returns                                                                     : 
154f			;     Nothing                                                                 : 
154f			;                                                                             : 
154f			; Stack frame                                                                 : 
154f			;       |             |                                                       : 
154f			;       +-------------+                                                       : 
154f			;       |     BC      |                                                       : 
154f			;       +-------------+                                                       : 
154f			;       |     DE      |                                                       : 
154f			;       +-------------+                                                       : 
154f			;       |     IX      |                                                       : 
154f			;       +-------------+                                                       : 
154f			;       |  prev_free  |                                                       : 
154f			;   +2  +-------------+                                                       : 
154f			;       |  next_free  |                                                       : 
154f			;   +0  +-------------+                                                       : 
154f			;       |             |                                                       : 
154f			;                                                                             : 
154f			;------------------------------------------------------------------------------ 
154f			free: 
154f			      push  BC 
154f			      push  DE 
154f			      push  IX 
154f			 
154f			      ld    A, H                    ; Exit if ptr is null 
154f			      or    L 
154f			      jp    Z, free_early_exit 
154f			 
154f			      ; Set up stack frame 
154f			      ex    DE, HL 
154f			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
154f			      add   HL, SP 
154f			      ld    SP, HL 
154f			      ld    IX, 0                   ; Use IX as a frame pointer 
154f			      add   IX, SP 
154f			 
154f			      ; The address in HL points to the start of the useable allocated space, 
154f			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
154f			      ; address of the block itself. 
154f			      ex    DE, HL 
154f			      ld    DE, -4 
154f			      add   HL, DE 
154f			 
154f			      ; An allocated block must have a null next block pointer in it 
154f			      ld    A, (HL) 
154f			      inc   HL 
154f			      or    (HL) 
154f			      jp    NZ, free_done 
154f			 
154f			      dec   HL 
154f			 
154f			      ld    B, H                    ; Copy HL to BC 
154f			      ld    C, L 
154f			 
154f			      ; Loop through the free list to find the first block with an address 
154f			      ; higher than the block being freed 
154f			      ld    HL, free_list 
154f			 
154f			free_find_higher_block: 
154f			      ld    E, (HL)                 ; Load next ptr from free block 
154f			      inc   HL 
154f			      ld    D, (HL) 
154f			      dec   HL 
154f			 
154f			      ld    (IX+0), E               ; Save ptr to next free block 
154f			      ld    (IX+1), D 
154f			      ld    (IX+2), L               ; Save ptr to prev free block 
154f			      ld    (IX+3), H 
154f			 
154f			      ld    A, B                    ; Check if DE is greater than BC 
154f			      cp    D                       ; Compare MSB first 
154f			      jr    Z, $+4                  ; MSB the same, compare LSB 
154f			      jr    NC, free_find_higher_block_skip 
154f			      ld    A, C 
154f			      cp    E                       ; Then compare LSB 
154f			      jr    C, free_found_higher_block 
154f			 
154f			free_find_higher_block_skip: 
154f			      ld    A, D                    ; Reached the end of the free list? 
154f			      or    E 
154f			      jp    Z, free_done 
154f			 
154f			      ex    DE, HL 
154f			 
154f			      jr    free_find_higher_block 
154f			 
154f			free_found_higher_block: 
154f			      ; Insert freed block between prev and next free blocks 
154f			      ld    (HL), C                 ; Point prev free block to freed block 
154f			      inc   HL 
154f			      ld    (HL), B 
154f			 
154f			      ld    H, B                    ; Point freed block at next free block 
154f			      ld    L, C 
154f			      ld    (HL), E 
154f			      inc   HL 
154f			      ld    (HL), D 
154f			 
154f			      ; Check if the freed block is adjacent to the next free block 
154f			      inc   HL                      ; Load size of freed block into HL 
154f			      ld    E, (HL) 
154f			      inc   HL 
154f			      ld    D, (HL) 
154f			      ex    DE, HL 
154f			 
154f			      add   HL, BC                  ; Add addr of freed block and its size 
154f			 
154f			      ld    E, (IX+0)               ; Load addr of next free block into DE 
154f			      ld    D, (IX+1) 
154f			 
154f			      or    A                       ; Clear the carry flag 
154f			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
154f			      jr    NZ, free_check_adjacent_to_prev 
154f			 
154f			      ; Freed block is adjacent to next, merge into one bigger block 
154f			      ex    DE, HL                  ; Load next ptr from next block into DE 
154f			      ld    E, (HL) 
154f			      inc   HL 
154f			      ld    D, (HL) 
154f			      push  HL                      ; Save ptr to next block for later 
154f			 
154f			      ld    H, B                    ; Store ptr from next block into freed block 
154f			      ld    L, C 
154f			      ld    (HL), E 
154f			      inc   HL 
154f			      ld    (HL), D 
154f			 
154f			      pop   HL                      ; Restore ptr to next block 
154f			      inc   HL                      ; Load size of next block into DE 
154f			      ld    E, (HL) 
154f			      inc   HL 
154f			      ld    D, (HL) 
154f			      push  DE                      ; Save next block size for later 
154f			 
154f			      ld    H, B                    ; Load size of freed block into HL 
154f			      ld    L, C 
154f			      inc   HL 
154f			      inc   HL 
154f			      ld    E, (HL) 
154f			      inc   HL 
154f			      ld    D, (HL) 
154f			      ex    DE, HL 
154f			 
154f			      pop   DE                      ; Restore size of next block 
154f			      add   HL, DE                  ; Add sizes of both blocks 
154f			      ex    DE, HL 
154f			 
154f			      ld    H, B                    ; Store new bigger size into freed block 
154f			      ld    L, C 
154f			      inc   HL 
154f			      inc   HL 
154f			      ld    (HL), E 
154f			      inc   HL 
154f			      ld    (HL), D 
154f			 
154f			free_check_adjacent_to_prev: 
154f			      ; Check if the freed block is adjacent to the prev free block 
154f			      ld    L, (IX+2)               ; Prev free block ptr into HL 
154f			      ld    H, (IX+3) 
154f			 
154f			      inc   HL                      ; Size of prev free block into DE 
154f			      inc   HL 
154f			      ld    E, (HL) 
154f			      inc   HL 
154f			      ld    D, (HL) 
154f			      dec   HL 
154f			      dec   HL 
154f			      dec   HL 
154f			 
154f			      add   HL, DE                  ; Add prev block addr and size 
154f			 
154f			      or    A                       ; Clear the carry flag 
154f			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
154f			      jr    NZ, free_done 
154f			 
154f			      ; Freed block is adjacent to prev, merge into one bigger block 
154f			      ld    H, B                    ; Load next ptr from freed block into DE 
154f			      ld    L, C 
154f			      ld    E, (HL) 
154f			      inc   HL 
154f			      ld    D, (HL) 
154f			      push  HL                      ; Save freed block ptr for later 
154f			 
154f			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
154f			      ld    H, (IX+3) 
154f			      ld    (HL), E 
154f			      inc   HL 
154f			      ld    (HL), D 
154f			 
154f			      pop   HL                      ; Restore freed block ptr 
154f			      inc   HL                      ; Load size of freed block into DE 
154f			      ld    E, (HL) 
154f			      inc   HL 
154f			      ld    D, (HL) 
154f			      push  DE                      ; Save freed block size for later 
154f			 
154f			      ld    L, (IX+2)               ; Load size of prev block into DE 
154f			      ld    H, (IX+3) 
154f			      inc   HL 
154f			      inc   HL 
154f			      ld    E, (HL) 
154f			      inc   HL 
154f			      ld    D, (HL) 
154f			 
154f			      pop   HL                      ; Add sizes of both blocks 
154f			      add   HL, DE 
154f			      ex    DE, HL 
154f			 
154f			      ld    L, (IX+2)               ; Store new bigger size into prev block 
154f			      ld    H, (IX+3) 
154f			      inc   HL 
154f			      inc   HL 
154f			      ld    (HL), E 
154f			      inc   HL 
154f			      ld    (HL), D 
154f			 
154f			free_done: 
154f			      ld    HL, 4                   ; Clean up stack frame 
154f			      add   HL, SP 
154f			      ld    SP, HL 
154f			 
154f			free_early_exit: 
154f			      pop   IX 
154f			      pop   DE 
154f			      pop   BC 
154f			 
154f			      ret 
154f			 
154f			 
154f			;      .org 0x8000 
154f			; 
154f			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
154f			 ;                 .dw   0 
154f			 
154f			endif 
154f			 
154f			 
154f			if MALLOC_4 
154f			 
154f			; My memory allocation code. Very very simple.... 
154f			; allocate space under 250 chars 
154f			 
154f			heap_init: 
154f				; init start of heap as zero 
154f				;  
154f			 
154f				ld hl, heap_start 
154f				ld a, 0 
154f				ld (hl), a      ; empty block 
154f				inc hl 
154f				ld a, 0 
154f				ld (hl), a      ; length of block 
154f				; write end of list 
154f				inc hl 
154f				ld a,(hl) 
154f				inc hl 
154f				ld a,(hl) 
154f				 
154f			 
154f				; init some malloc vars 
154f			 
154f				ld hl, 0 
154f				ld (free_list), hl       ; store last malloc location 
154f			 
154f				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
154f				ld a, 0 
154f				ld (hl), a 
154f			 
154f			 
154f				ld hl, heap_start 
154f				;  
154f				  
154f				ret 
154f			 
154f			 
154f			;    free block marker 
154f			;    requested size  
154f			;    pointer to next block 
154f			;    .... 
154f			;    next block marker 
154f			 
154f			 
154f			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
154f			; 
154f			 
154f			 
154f			malloc:  
154f				push de 
154f				push bc 
154f				push af 
154f			 
154f				; hl space required 
154f				 
154f				ld c, l    ; hold space   (TODO only a max of 255) 
154f			 
154f			;	inc c     ; TODO BUG need to fix memory leak on push str 
154f			;	inc c 
154f			;	inc c 
154f			;	inc c 
154f			;	inc c 
154f			;	inc c 
154f			;	inc c 
154f			 
154f			 
154f			 
154f				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
154f			 
154f				ld a, (free_list+3) 
154f				cp 0 
154f				jr z, .contheap 
154f			 
154f				ld hl, (free_list)     ; get last alloc 
154f					if DEBUG_FORTH_MALLOC_INT 
154f						DMARK "mrs" 
154f						CALLMONITOR 
154f					endif 
154f				jr .startalloc 
154f			 
154f			.contheap: 
154f				ld hl, heap_start 
154f			 
154f			.startalloc: 
154f			 
154f					if DEBUG_FORTH_MALLOC_INT 
154f						DMARK "mym" 
154f						CALLMONITOR 
154f					endif 
154f			.findblock: 
154f					if DEBUG_FORTH_MALLOC_INT 
154f						DMARK "mmf" 
154f						CALLMONITOR 
154f					endif 
154f			 
154f				ld a,(hl)  
154f				; if byte is zero then clear to use 
154f			 
154f				cp 0 
154f				jr z, .foundemptyblock 
154f			 
154f				; if byte is not clear 
154f				;     then byte is offset to next block 
154f			 
154f				inc hl 
154f				ld a, (hl) ; get size 
154f			.nextblock:	inc hl 
154f					ld e, (hl) 
154f					inc hl 
154f					ld d, (hl) 
154f					ex de, hl 
154f			;	inc hl  ; move past the store space 
154f			;	inc hl  ; move past zero index  
154f			 
154f				; TODO detect no more space 
154f			 
154f				push hl 
154f				ld de, heap_end 
154f				call cmp16 
154f				pop hl 
154f				jr nc, .nospace 
154f			 
154f				jr .findblock 
154f			 
154f			.nospace: ld hl, 0 
154f				jp .exit 
154f			 
154f			 
154f			.foundemptyblock:	 
154f					if DEBUG_FORTH_MALLOC_INT 
154f						DMARK "mme" 
154f						CALLMONITOR 
154f					endif 
154f			 
154f			; TODO has block enough space if reusing??? 
154f			 
154f				;  
154f			 
154f			; see if this block has been previously used 
154f				inc hl 
154f				ld a, (hl) 
154f				dec hl 
154f				cp 0 
154f				jr z, .newblock 
154f			 
154f					if DEBUG_FORTH_MALLOC_INT 
154f						DMARK "meR" 
154f						CALLMONITOR 
154f					endif 
154f			 
154f			; no reusing previously allocated block 
154f			 
154f			; is it smaller than previously used? 
154f				 
154f				inc hl    ; move to size 
154f				ld a, c 
154f				sub (hl)        ; we want c < (hl) 
154f				dec hl    ; move back to marker 
154f			        jr z, .findblock 
154f			 
154f				; update with the new size which should be lower 
154f			 
154f			        ;inc  hl   ; negate next move. move back to size  
154f			 
154f			.newblock: 
154f				; need to be at marker here 
154f			 
154f					if DEBUG_FORTH_MALLOC_INT 
154f						DMARK "meN" 
154f						CALLMONITOR 
154f					endif 
154f			 
154f			 
154f				ld a, c 
154f			 
154f				ld (free_list+3), a	 ; flag resume from last malloc  
154f				ld (free_list), hl    ; save out last location 
154f			 
154f			 
154f				;inc a     ; space for length byte 
154f				ld (hl), a     ; save block in use marker 
154f			 
154f				inc hl   ; move to space marker 
154f				ld (hl), a    ; save new space 
154f			 
154f				inc hl   ; move to start of allocated area 
154f				 
154f			;	push hl     ; save where we are - 1  
154f			 
154f			;	inc hl  ; move past zero index  
154f				; skip space to set down new marker 
154f			 
154f				; provide some extra space for now 
154f			 
154f				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
154f				inc a 
154f				inc a 
154f			 
154f				push hl   ; save where we are in the node block 
154f			 
154f				call addatohl 
154f			 
154f				; write linked list point 
154f			 
154f				pop de     ; get our node position 
154f				ex de, hl 
154f			 
154f				ld (hl), e 
154f				inc hl 
154f				ld (hl), d 
154f			 
154f				inc hl 
154f			 
154f				; now at start of allocated data so save pointer 
154f			 
154f				push hl 
154f			 
154f				; jump to position of next node and setup empty header in DE 
154f			 
154f				ex de, hl 
154f			 
154f			;	inc hl ; move past end of block 
154f			 
154f				ld a, 0 
154f				ld (hl), a   ; empty marker 
154f				inc hl 
154f				ld (hl), a   ; size 
154f				inc hl  
154f				ld (hl), a   ; ptr 
154f				inc hl 
154f				ld (hl), a   ; ptr 
154f			 
154f			 
154f				pop hl 
154f			 
154f					if DEBUG_FORTH_MALLOC_INT 
154f						DMARK "mmr" 
154f						CALLMONITOR 
154f					endif 
154f			 
154f			.exit: 
154f				pop af 
154f				pop bc 
154f				pop de  
154f				ret 
154f			 
154f			 
154f			 
154f			 
154f			free:  
154f				push hl 
154f				push af 
154f				; get address in hl 
154f			 
154f					if DEBUG_FORTH_MALLOC_INT 
154f						DMARK "fre" 
154f						CALLMONITOR 
154f					endif 
154f				; data is at hl - move to block count 
154f				dec hl 
154f				dec hl    ; get past pointer 
154f				dec hl 
154f			 
154f				ld a, (hl)    ; need this for a validation check 
154f			 
154f				dec hl    ; move to block marker 
154f			 
154f				; now check that the block count and block marker are the same  
154f			        ; this checks that we are on a malloc node and not random memory 
154f			        ; OK a faint chance this could be a problem but rare - famous last words! 
154f			 
154f				ld c, a 
154f				ld a, (hl)    
154f			 
154f				cp c 
154f				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
154f			 
154f				; yes good chance we are on a malloc node 
154f			 
154f				ld a, 0      
154f				ld (hl), a   ; mark as free 
154f			 
154f				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
154f			 
154f			.freeignore:  
154f			 
154f				pop af 
154f				pop hl 
154f			 
154f				ret 
154f			 
154f			 
154f			 
154f			endif 
154f			 
154f			; eof 
# End of file firmware_memory.asm
154f			  
154f			; device C  
154f			; Now handled by SPI  
154f			;if SOUND_ENABLE  
154f			;	include "firmware_sound.asm"  
154f			;endif  
154f			  
154f			include "firmware_diags.asm"  
154f			; Hardware diags menu 
154f			 
154f			 
154f			config: 
154f			 
154f 3e 00			ld a, 0 
1551 21 7a 15			ld hl, .configmn 
1554 cd d8 0d			call menu 
1557			 
1557 fe 00			cp 0 
1559 c8				ret z 
155a			 
155a			;	cp 1 
155a			;	call z, .savetostore 
155a			 
155a fe 01			cp 1 
155c			if STARTUP_V1 
155c				call z, .selautoload 
155c			endif 
155c			 
155c			if STARTUP_V2 
155c cc 88 15			call z, .enautoload 
155f			endif 
155f fe 02			cp 2 
1561 cc 9f 15			call z, .disautoload 
1564			;	cp 3 
1564			;	call z, .selbank 
1564 fe 03			cp 3 
1566 cc 08 18			call z, .debug_tog 
1569 fe 04			cp 4 
156b cc 56 19			call z, .bpsgo 
156e fe 05			cp 5 
1570 cc 31 18			call z, hardware_diags 
1573			if STARTUP_V2 
1573 fe 06			cp 6 
1575 cc cb 15			call z, create_startup 
1578			endif 
1578 18 d5			jr config 
157a			 
157a			.configmn: 
157a			;	dw prom_c3 
157a 44 1b			dw prom_c2 
157c 5a 1b			dw prom_c2a 
157e			;	dw prom_c2b 
157e			;	dw prom_c4 
157e d1 1b			dw prom_m4 
1580 ec 1b			dw prom_m4b 
1582 f4 1b			dw prom_c1 
1584			if STARTUP_V2 
1584 03 1c			dw prom_c9 
1586			endif 
1586 00 00			dw 0 
1588				 
1588			 
1588			if STARTUP_V2 
1588			.enautoload: 
1588				if STORAGE_SE 
1588 3e fe			ld a, $fe      ; bit 0 clear 
158a 32 9b f9			ld (spi_device), a 
158d			 
158d cd 22 05			call storage_get_block_0 
1590			 
1590 3e 01			ld a, 1 
1592 32 d6 f9			ld (store_page+STORE_0_AUTOFILE), a 
1595			 
1595 21 00 00				ld hl, 0 
1598 11 b5 f9				ld de, store_page 
159b cd d6 04			call storage_write_block	 ; save update 
159e				else 
159e			 
159e				ld hl, prom_notav 
159e				ld de, prom_empty 
159e				call info_panel 
159e				endif 
159e			 
159e			 
159e c9				ret 
159f			endif 
159f			 
159f			.disautoload: 
159f				if STORAGE_SE 
159f 3e fe			ld a, $fe      ; bit 0 clear 
15a1 32 9b f9			ld (spi_device), a 
15a4			 
15a4 cd 22 05			call storage_get_block_0 
15a7			 
15a7 3e 00			ld a, 0 
15a9 32 d6 f9			ld (store_page+STORE_0_AUTOFILE), a 
15ac			 
15ac 21 00 00				ld hl, 0 
15af 11 b5 f9				ld de, store_page 
15b2 cd d6 04			call storage_write_block	 ; save update 
15b5				else 
15b5			 
15b5				ld hl, prom_notav 
15b5				ld de, prom_empty 
15b5				call info_panel 
15b5				endif 
15b5			 
15b5			 
15b5 c9				ret 
15b6			 
15b6			if STARTUP_V1 
15b6			 
15b6			; Select auto start 
15b6			 
15b6			.selautoload: 
15b6			 
15b6				 
15b6				if STORAGE_SE 
15b6			 
15b6					call config_dir 
15b6				        ld hl, scratch 
15b6					ld a, 0 
15b6					call menu 
15b6			 
15b6					cp 0 
15b6					ret z 
15b6			 
15b6					dec a 
15b6			 
15b6			 
15b6					; locate menu option 
15b6			 
15b6					ld hl, scratch 
15b6					call table_lookup 
15b6			 
15b6					if DEBUG_FORTH_WORDS 
15b6						DMARK "ALl" 
15b6						CALLMONITOR 
15b6					endif 
15b6					; with the pointer to the menu it, the byte following the zero term is the file id 
15b6			 
15b6					ld a, 0 
15b6					ld bc, 50   ; max of bytes to look at 
15b6					cpir  
15b6			 
15b6					if DEBUG_FORTH_WORDS 
15b6						DMARK "ALb" 
15b6						CALLMONITOR 
15b6					endif 
15b6					;inc hl 
15b6			 
15b6					ld a, (hl)   ; file id 
15b6					 
15b6				        ; save bank and file ids 
15b6			 
15b6					push af 
15b6			 
15b6			; TODO need to save to block 0 on bank 1	 
15b6			 
15b6					call storage_get_block_0 
15b6			 
15b6					if DEBUG_FORTH_WORDS 
15b6						DMARK "AL0" 
15b6						CALLMONITOR 
15b6					endif 
15b6					pop af 
15b6			 
15b6					ld (store_page+STORE_0_FILERUN),a 
15b6					 
15b6					; save bank id 
15b6			 
15b6					ld a,(spi_device) 
15b6					ld (store_page+STORE_0_BANKRUN),a 
15b6			 
15b6					; enable auto run of store file 
15b6			 
15b6					ld a, 1 
15b6					ld (store_page+STORE_0_AUTOFILE),a 
15b6			 
15b6					; save buffer 
15b6			 
15b6					ld hl, 0 
15b6					ld de, store_page 
15b6					if DEBUG_FORTH_WORDS 
15b6						DMARK "ALw" 
15b6						CALLMONITOR 
15b6					endif 
15b6				call storage_write_block	 ; save update 
15b6			  
15b6			 
15b6			 
15b6			 
15b6					ld hl, scratch 
15b6					call config_fdir 
15b6			 
15b6				else 
15b6			 
15b6				ld hl, prom_notav 
15b6				ld de, prom_empty 
15b6				call info_panel 
15b6			 
15b6				endif 
15b6				ret 
15b6			endif 
15b6			 
15b6			 
15b6			; Select storage bank 
15b6			 
15b6			.selbank: 
15b6			 
15b6			;	if STORAGE_SE 
15b6			;	else 
15b6			 
15b6 21 18 1c			ld hl, prom_notav 
15b9 11 2e 1c			ld de, prom_empty 
15bc cd 38 0d			call info_panel 
15bf			;	endif 
15bf				 
15bf c9				ret 
15c0			 
15c0			if STORAGE_SE 
15c0			 
15c0			.config_ldir:   
15c0				; Load storage bank labels into menu array 
15c0			 
15c0				 
15c0			 
15c0			 
15c0 c9				ret 
15c1			 
15c1			 
15c1			endif 
15c1			 
15c1			 
15c1			; Save user words to storage 
15c1			 
15c1			.savetostore: 
15c1			 
15c1			;	if STORAGE_SE 
15c1			; 
15c1			;		call config_dir 
15c1			;	        ld hl, scratch 
15c1			;		ld a, 0 
15c1			;		call menu 
15c1			;		 
15c1			;		ld hl, scratch 
15c1			;		call config_fdir 
15c1			; 
15c1			;	else 
15c1			 
15c1 21 18 1c			ld hl, prom_notav 
15c4 11 2e 1c			ld de, prom_empty 
15c7 cd 38 0d			call info_panel 
15ca			 
15ca			;	endif 
15ca			 
15ca c9				ret 
15cb			 
15cb			if STARTUP_V2 
15cb			 
15cb			create_startup: 
15cb			 
15cb 3e 00			ld a, 0 
15cd 21 2d 17			ld hl, .crstart 
15d0 cd d8 0d			call menu 
15d3			 
15d3 fe 00			cp 0 
15d5 c8				ret z 
15d6			 
15d6 fe 01			cp 1 
15d8 cc 14 16			call z, .genlsword 
15db fe 02			cp 2 
15dd cc 1e 16			call z, .genedword 
15e0			 
15e0 fe 03			cp 3 
15e2 cc 28 16			call z, .gendemword 
15e5			 
15e5 fe 04			cp 4 
15e7 cc 32 16			call z, .genutlword 
15ea fe 05			cp 5 
15ec cc 3c 16			call z, .genspiword 
15ef fe 06			cp 6 
15f1 cc 46 16			call z, .genkeyword 
15f4 fe 07			cp 7 
15f6 cc 0a 16			call z, .gensoundword 
15f9 fe 07			cp 7 
15fb cc 00 16			call z, .genhwword 
15fe 18 cb			jr create_startup 
1600			 
1600			.genhwword: 
1600 21 bb 1b			ld hl, crs_hw 
1603 11 93 16			ld de, .hwworddef 
1606 cd 50 16			call .genfile 
1609 c9				ret 
160a			.gensoundword: 
160a 21 af 1b			ld hl, crs_sound 
160d 11 a1 16			ld de, .soundworddef 
1610 cd 50 16			call .genfile 
1613 c9				ret 
1614			.genlsword: 
1614 21 71 1b			ld hl, crs_s1 
1617 11 c5 16			ld de, .lsworddef 
161a cd 50 16			call .genfile 
161d c9				ret 
161e			 
161e			.genedword: 
161e 11 c9 16			ld de, .edworddef 
1621 21 7a 1b			ld hl, crs_s2 
1624 cd 50 16			call .genfile 
1627 c9				ret 
1628			 
1628			.gendemword: 
1628 11 d1 16			ld de, .demoworddef 
162b 21 83 1b			ld hl, crs_s3 
162e cd 50 16			call .genfile 
1631 c9				ret 
1632			 
1632			.genutlword: 
1632 21 8f 1b			ld hl, crs_s4 
1635 11 b5 16			ld de, .utilwordef 
1638 cd 50 16			call .genfile 
163b c9				ret 
163c			.genspiword: 
163c 21 96 1b			ld hl, crs_s5 
163f 11 f3 16			ld de, .spiworddef 
1642 cd 50 16			call .genfile 
1645 c9				ret 
1646			.genkeyword: 
1646 21 a0 1b			ld hl, crs_s6 
1649 11 01 17			ld de, .keyworddef 
164c cd 50 16			call .genfile 
164f c9				ret 
1650			 
1650			; hl - points to file name 
1650			; de - points to strings to add to file 
1650			 
1650			.genfile: 
1650 e5				push hl 
1651 d5				push de 
1652			 
1652 cd a7 0d			call clear_display 
1655 3e 00			ld a, display_row_1 
1657 11 82 16			ld de, .genfiletxt 
165a cd ba 0d			call str_at_display 
165d cd ca 0d			call update_display 
1660			 
1660 d1				pop de 
1661 e1				pop hl 
1662			 
1662			 
1662 d5				push de 
1663 cd 74 08			call storage_create 
1666				; id in hl 
1666 d1				pop de   ; table of strings to add 
1667			 
1667			.genloop: 
1667			 
1667 e5				push hl ; save id for next time around 
1668 d5				push de ; save de for next time around 
1669			 
1669 eb				ex de, hl 
166a cd 6c 23			call loadwordinhl 
166d eb				ex de, hl 
166e			 
166e				; need hl to be the id 
166e				; need de to be the string ptr 
166e				 
166e cd 61 0b			call storage_append 
1671			 
1671 d1				pop de 
1672 e1				pop hl 
1673			 
1673 13				inc de 
1674 13				inc de 
1675			 
1675 1a				ld a,(de) 
1676 fe 00			cp 0 
1678 20 ed			jr nz, .genloop 
167a 13				inc de 
167b 1a				ld a, (de) 
167c 1b				dec de 
167d fe 00			cp 0 
167f 20 e6			jr nz, .genloop	 
1681			 
1681 c9				ret 
1682			 
1682 .. 00		.genfiletxt:  db "Creating file...",0 
1693			 
1693			.hwworddef: 
1693 0f 65			dw test5 
1695 47 65			dw test6 
1697 7f 65			dw test7 
1699 93 65			dw test8 
169b bf 65			dw test9 
169d d5 65			dw test10 
169f 00 00			dw 0 
16a1			 
16a1			.soundworddef: 
16a1 fa 65			dw sound1 
16a3 1e 66			dw sound2 
16a5 4e 66			dw sound3 
16a7 73 66			dw sound4 
16a9 80 66			dw sound5 
16ab 8d 66			dw sound6 
16ad 9a 66			dw sound7 
16af a7 66			dw sound8 
16b1 bf 66			dw sound9 
16b3 00 00			dw 0 
16b5			 
16b5			.utilwordef: 
16b5 48 63			dw strncpy 
16b7 23 63			dw type 
16b9 ef 62			dw clrstack 
16bb a8 62			dw longread 
16bd a9 63			dw start1 
16bf b9 63			dw start2 
16c1			; duplicated 
16c1			;	dw start3b 
16c1			;	dw start3c 
16c1 a5 64			dw list 
16c3 00 00			dw 0 
16c5			 
16c5			.lsworddef: 
16c5 ca 63			dw start3b 
16c7 00 00			dw 0 
16c9			 
16c9			.edworddef: 
16c9 07 5f			dw edit1 
16cb 28 5f			dw edit2 
16cd 5d 5f			dw edit3 
16cf 00 00			dw 0 
16d1			 
16d1			.demoworddef: 
16d1 d6 66			dw game1 
16d3 e7 66			dw game1a 
16d5 49 67			dw game1b 
16d7 7e 67			dw game1c 
16d9 b4 67			dw game1d 
16db e5 67			dw game1s 
16dd f9 67			dw game1t 
16df 0e 68			dw game1f 
16e1 42 68			dw game1z 
16e3 86 68			dw game1zz 
16e5 ef 68			dw ssv2 
16e7 25 69			dw ssv3 
16e9 41 69			dw ssv4 
16eb 5d 69			dw ssv5 
16ed 76 69			dw ssv1 
16ef be 69			dw ssv1cpm	 
16f1			;	dw game2b 
16f1			;	dw game2bf 
16f1			;	dw game2mba 
16f1			;	dw game2mbas	 
16f1			;	dw game2mbht 
16f1			;	dw game2mbms 
16f1			;	dw game2mb 
16f1			;	dw game3w 
16f1			;	dw game3p 
16f1			;	dw game3sc 
16f1			;	dw game3vsi 
16f1			;	dw game3vs 
16f1 00 00			dw 0 
16f3			 
16f3			 
16f3			.spiworddef: 
16f3			 
16f3 95 5f		    dw spi1 
16f5 ee 5f		    dw spi2 
16f7 22 60		    dw spi2b 
16f9 a6 60		    dw spi3 
16fb 50 60		    dw spi4 
16fd 79 60		    dw spi5 
16ff			;    dw spi6 
16ff			;    dw spi7 
16ff			 
16ff			;    dw spi8 
16ff			;    dw spi9 
16ff			;    dw spi10 
16ff 00 00		    dw 0 
1701			 
1701			.keyworddef: 
1701			 
1701 15 6a			dw keyup 
1703 23 6a			dw keydown 
1705 33 6a			dw keyleft 
1707 43 6a			dw keyright 
1709 54 6a			dw 	keyf1 
170b 62 6a			dw keyf2 
170d 70 6a			dw keyf3 
170f 7e 6a			dw keyf4 
1711 8c 6a			dw keyf5 
1713 9a 6a			dw keyf6 
1715 a8 6a			dw keyf7 
1717 b6 6a			dw keyf8 
1719 c4 6a			dw keyf9 
171b d2 6a			dw keyf10 
171d e1 6a			dw keyf11 
171f f0 6a			dw keyf12 
1721 ff 6a			dw keytab 
1723 0e 6b			dw keycr 
1725 1c 6b			dw keyhome 
1727 2c 6b			dw keyend 
1729 3b 6b			dw keybs 
172b 00 00			dw 0 
172d			 
172d			.crstart: 
172d 71 1b			dw crs_s1 
172f 7a 1b			dw crs_s2 
1731 83 1b			dw crs_s3 
1733 8f 1b			dw crs_s4 
1735 96 1b			dw crs_s5 
1737 a0 1b			dw crs_s6 
1739 af 1b			dw crs_sound 
173b bb 1b			dw crs_hw 
173d 00 00			dw 0 
173f			 
173f			endif 
173f			 
173f			 
173f			if STORAGE_SE 
173f			 
173f			config_fdir: 
173f				; using the scratch dir go through and release the memory allocated for each string 
173f				 
173f 21 fc f0			ld hl, scratch 
1742 5e			.cfdir:	ld e,(hl) 
1743 23				inc hl 
1744 56				ld d,(hl) 
1745 23				inc hl 
1746			 
1746 eb				ex de, hl 
1747 cd 04 10			call ishlzero 
174a c8				ret z     ; return on null pointer 
174b cd 80 14			call free 
174e eb				ex de, hl 
174f 18 f1			jr .cfdir 
1751			 
1751			 
1751 c9				ret 
1752			 
1752			 
1752			config_dir: 
1752			 
1752				; for the config menus that need to build a directory of storage call this routine 
1752				; it will construct a menu in scratch to pass to menu 
1752			 
1752				; open storage device 
1752			 
1752				; execute DIR to build a list of files and their ids into scratch in menu format 
1752				; once the menu has finished then will need to call config_fdir to release the strings 
1752				 
1752				; c = number items 
1752			 
1752				 
1752 cd 22 05			call storage_get_block_0 
1755			 
1755 21 b5 f9			ld hl, store_page     ; get current id count 
1758 46				ld b, (hl) 
1759 0e 00			ld c, 0    ; count of files   
175b			 
175b			 
175b 21 fc f0			ld hl, scratch 
175e 22 ac f9			ld (store_tmp2), hl    ; location to poke strings 
1761			 
1761				; check for empty drive 
1761			 
1761 3e 00			ld a, 0 
1763 b8				cp b 
1764 ca fe 17			jp z, .dirdone 
1767			 
1767				 
1767					if DEBUG_FORTH_WORDS 
1767						DMARK "Cdc" 
1767 f5				push af  
1768 3a 7c 17			ld a, (.dmark)  
176b 32 a6 fd			ld (debug_mark),a  
176e 3a 7d 17			ld a, (.dmark+1)  
1771 32 a7 fd			ld (debug_mark+1),a  
1774 3a 7e 17			ld a, (.dmark+2)  
1777 32 a8 fd			ld (debug_mark+2),a  
177a 18 03			jr .pastdmark  
177c ..			.dmark: db "Cdc"  
177f f1			.pastdmark: pop af  
1780			endm  
# End of macro DMARK
1780						CALLMONITOR 
1780 cd aa fd			call debug_vector  
1783				endm  
# End of macro CALLMONITOR
1783					endif 
1783			 
1783			 
1783			.diritem:	 
1783 c5				push bc 
1784				; for each of the current ids do a search for them and if found push to stack 
1784			 
1784 21 40 00				ld hl, STORE_BLOCK_PHY 
1787 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
1789 58					ld e,b 
178a			 
178a cd a4 07				call storage_findnextid 
178d			 
178d			 
178d					; if found hl will be non zero 
178d			 
178d cd 04 10				call ishlzero 
1790 28 69				jr z, .dirnotfound 
1792			 
1792					; increase count 
1792			 
1792 c1					pop bc	 
1793 0c					inc c 
1794 c5					push bc 
1795					 
1795			 
1795					; get file header and push the file name 
1795			 
1795 11 b5 f9				ld de, store_page 
1798 cd 71 04				call storage_read_block 
179b			 
179b					; push file id to stack 
179b				 
179b 3a b5 f9				ld a, (store_page) 
179e 26 00				ld h, 0 
17a0 6f					ld l, a 
17a1			 
17a1					;call forth_push_numhl 
17a1					; TODO store id 
17a1			 
17a1 e5					push hl 
17a2			 
17a2					; push extent count to stack  
17a2				 
17a2 21 b8 f9				ld hl, store_page+3 
17a5			 
17a5					; get file name length 
17a5			 
17a5 cd 41 13				call strlenz   
17a8			 
17a8 23					inc hl   ; cover zero term 
17a9 23					inc hl  ; stick the id at the end of the area 
17aa			 
17aa e5					push hl 
17ab c1					pop bc    ; move length to bc 
17ac			 
17ac cd b6 13				call malloc 
17af			 
17af					; TODO save malloc area to scratch 
17af			 
17af eb					ex de, hl 
17b0 2a ac f9				ld hl, (store_tmp2) 
17b3 73					ld (hl), e 
17b4 23					inc hl 
17b5 72					ld (hl), d 
17b6 23					inc hl 
17b7 22 ac f9				ld (store_tmp2), hl 
17ba			 
17ba					 
17ba			 
17ba					;pop hl   ; get source 
17ba			;		ex de, hl    ; swap aronund	 
17ba			 
17ba 21 b8 f9				ld hl, store_page+3 
17bd					if DEBUG_FORTH_WORDS 
17bd						DMARK "CFd" 
17bd f5				push af  
17be 3a d2 17			ld a, (.dmark)  
17c1 32 a6 fd			ld (debug_mark),a  
17c4 3a d3 17			ld a, (.dmark+1)  
17c7 32 a7 fd			ld (debug_mark+1),a  
17ca 3a d4 17			ld a, (.dmark+2)  
17cd 32 a8 fd			ld (debug_mark+2),a  
17d0 18 03			jr .pastdmark  
17d2 ..			.dmark: db "CFd"  
17d5 f1			.pastdmark: pop af  
17d6			endm  
# End of macro DMARK
17d6						CALLMONITOR 
17d6 cd aa fd			call debug_vector  
17d9				endm  
# End of macro CALLMONITOR
17d9					endif 
17d9 ed b0				ldir 
17db			 
17db					; de is past string, move back one and store id 
17db					 
17db 1b					dec de 
17dc			 
17dc					; store file id 
17dc			 
17dc e1					pop hl 
17dd eb					ex de,hl 
17de 73					ld (hl), e 
17df			 
17df					if DEBUG_FORTH_WORDS 
17df						DMARK "Cdi" 
17df f5				push af  
17e0 3a f4 17			ld a, (.dmark)  
17e3 32 a6 fd			ld (debug_mark),a  
17e6 3a f5 17			ld a, (.dmark+1)  
17e9 32 a7 fd			ld (debug_mark+1),a  
17ec 3a f6 17			ld a, (.dmark+2)  
17ef 32 a8 fd			ld (debug_mark+2),a  
17f2 18 03			jr .pastdmark  
17f4 ..			.dmark: db "Cdi"  
17f7 f1			.pastdmark: pop af  
17f8			endm  
# End of macro DMARK
17f8						CALLMONITOR 
17f8 cd aa fd			call debug_vector  
17fb				endm  
# End of macro CALLMONITOR
17fb					endif 
17fb					 
17fb			.dirnotfound: 
17fb c1					pop bc     
17fc 10 85				djnz .diritem 
17fe				 
17fe			.dirdone:	 
17fe			 
17fe 3e 00				ld a, 0 
1800 2a ac f9				ld hl, (store_tmp2) 
1803 77					ld (hl), a 
1804 23					inc hl 
1805 77					ld (hl), a 
1806 23					inc hl 
1807					; push a count of the dir items found 
1807			 
1807			;		ld h, 0 
1807			;		ld l, c 
1807			 
1807 c9				ret 
1808			 
1808			endif 
1808			 
1808			 
1808			; Settings 
1808			; Run  
1808			 
1808			 
1808			 
1808			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1808			;;hd_menu2:   db "        2: Editor",0   
1808			;hd_menu2:   db "        2: Editor       6: Menu",0   
1808			;hd_menu3:   db "        3: Storage",0 
1808			;hd_menu4:   db "0=quit  4: Debug",0 
1808			;hd_don:     db "ON",0 
1808			;hd_doff:     db "OFF",0 
1808			; 
1808			; 
1808			; 
1808			;hardware_diags_old:       
1808			; 
1808			;.diagmenu: 
1808			;	call clear_display 
1808			;	ld a, display_row_1 
1808			;	ld de, hd_menu1 
1808			;	call str_at_display 
1808			; 
1808			;	ld a, display_row_2 
1808			;	ld de, hd_menu2 
1808			;	call str_at_display 
1808			; 
1808			;	ld a, display_row_3 
1808			;	ld de, hd_menu3 
1808			;	call str_at_display 
1808			; 
1808			;	ld a,  display_row_4 
1808			;	ld de, hd_menu4 
1808			;	call str_at_display 
1808			; 
1808			;	; display debug state 
1808			; 
1808			;	ld de, hd_don 
1808			;	ld a, (os_view_disable) 
1808			;	cp 0 
1808			;	jr z, .distog 
1808			;	ld de, hd_doff 
1808			;.distog: ld a, display_row_4+17 
1808			;	call str_at_display 
1808			; 
1808			;	call update_display 
1808			; 
1808			;	call cin_wait 
1808			; 
1808			; 
1808			; 
1808			;	cp '4' 
1808			;	jr nz, .diagn1 
1808			; 
1808			;	; debug toggle 
1808			; 
1808			;	ld a, (os_view_disable) 
1808			;	ld b, '*' 
1808			;	cp 0 
1808			;	jr z, .debtog 
1808			;	ld b, 0 
1808			;.debtog:	 
1808			;	ld a,b 
1808			;	ld (os_view_disable),a 
1808			; 
1808			;.diagn1: cp '0' 
1808			;	 ret z 
1808			; 
1808			;;	cp '1' 
1808			;;       jp z, matrix	 
1808			;;   TODO keyboard matrix test 
1808			; 
1808			;	cp '2' 
1808			;	jp z, .diagedit 
1808			; 
1808			;;	cp '6' 
1808			;;	jp z, .menutest 
1808			;;if ENABLE_BASIC 
1808			;;	cp '6' 
1808			;;	jp z, basic 
1808			;;endif 
1808			 ; 
1808			;	jp .diagmenu 
1808			; 
1808			; 
1808			;	ret 
1808			 
1808			 
1808			.debug_tog: 
1808 21 52 18			ld hl, .menudebug 
180b				 
180b			;	ld a, (os_view_disable) 
180b			;	cp '*' 
180b 3a aa fd			ld a,(debug_vector) 
180e fe c9			cp $C9   ; RET 
1810 20 04			jr nz,.tdon  
1812 3e 01			ld a, 1 
1814 18 02			jr .tog1 
1816 3e 00		.tdon: ld a, 0 
1818			 
1818			.tog1: 
1818 cd d8 0d			call menu 
181b fe 00			cp 0 
181d c8				ret z 
181e fe 01			cp 1    ; disable debug 
1820 28 04			jr z, .dtog0 
1822 3e 2a			ld a, '*' 
1824 18 05			jr .dtogset 
1826			.dtog0:  
1826				;ld a, 0 
1826 cd 44 19			call bp_on 
1829 18 dd			jr .debug_tog 
182b			.dtogset:  
182b				; ld (os_view_disable), a 
182b cd 50 19			call bp_off 
182e c3 08 18			jp .debug_tog 
1831			 
1831			 
1831			hardware_diags:       
1831			 
1831			.diagm: 
1831 21 44 18			ld hl, .menuitems 
1834 3e 00			ld a, 0 
1836 cd d8 0d			call menu 
1839			 
1839 fe 00		         cp 0 
183b c8				 ret z 
183c			 
183c fe 02			cp 2 
183e ca 9d 18			jp z, .diagedit 
1841			 
1841			;	cp '6' 
1841			;	jp z, .menutest 
1841			;if ENABLE_BASIC 
1841			;	cp '6' 
1841			;	jp z, basic 
1841			;endif 
1841			  
1841 c3 31 18			jp .diagm 
1844			 
1844				 
1844 58 18		.menuitems:   	dw .m1 
1846 63 18				dw .m2 
1848 6a 18				dw .m3 
184a 72 18				dw .m5 
184c 78 18				dw .m5a 
184e 81 18				dw .m5b 
1850 00 00				dw 0 
1852			 
1852			.menudebug: 
1852 8a 18				dw .m6 
1854 93 18				dw .m7 
1856 00 00				dw 0 
1858			 
1858 .. 00		.m1:   db "Key Matrix",0 
1863 .. 00		.m2:   db "Editor",0 
186a .. 00		.m3:   db "Storage",0 
1872 .. 00		.m5:   db "Sound",0 
1878 .. 00		.m5a:  db "RAM Test",0 
1881 .. 00		.m5b:  db "LCD Test",0 
188a			 
188a .. 00		.m6:   db "Debug ON",0 
1893 .. 00		.m7:   db "Debug OFF",0 
189d			 
189d			; debug editor 
189d			 
189d			.diagedit: 
189d			 
189d 21 fc f0			ld hl, scratch 
18a0			;	ld bc, 250 
18a0			;	ldir 
18a0				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18a0 3e 00			ld a, 0 
18a2 77				ld (hl), a 
18a3 23				inc hl 
18a4 77				ld (hl), a 
18a5 23				inc hl 
18a6 77				ld (hl), a 
18a7			 
18a7 cd a7 0d		        call clear_display 
18aa cd ca 0d			call update_display 
18ad				;ld a, 1 
18ad				;ld (hardware_diag), a 
18ad			.diloop: 
18ad 3e 00			ld a, display_row_1 
18af 0e 00			ld c, 0 
18b1 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18b3 1e 28			ld e, 40 
18b5			 
18b5 21 fc f0			ld hl, scratch	 
18b8 cd 08 10			call input_str 
18bb			 
18bb 3e 28			ld a, display_row_2 
18bd 11 fc f0			ld de, scratch 
18c0 cd ba 0d			call str_at_display 
18c3 cd ca 0d			call update_display 
18c6			 
18c6 c3 ad 18			jp .diloop 
18c9			 
18c9			 
18c9			; pass word in hl 
18c9			; a has display location 
18c9			display_word_at: 
18c9 f5				push af 
18ca e5				push hl 
18cb 7c				ld a,h 
18cc 21 01 f4			ld hl, os_word_scratch 
18cf cd e4 11			call hexout 
18d2 e1				pop hl 
18d3 7d				ld a,l 
18d4 21 03 f4			ld hl, os_word_scratch+2 
18d7 cd e4 11			call hexout 
18da 21 05 f4			ld hl, os_word_scratch+4 
18dd 3e 00			ld a,0 
18df 77				ld (hl),a 
18e0 11 01 f4			ld de,os_word_scratch 
18e3 f1				pop af 
18e4 cd ba 0d				call str_at_display 
18e7 c9				ret 
18e8			 
18e8			display_ptr_state: 
18e8			 
18e8				; to restore afterwards 
18e8			 
18e8 d5				push de 
18e9 c5				push bc 
18ea e5				push hl 
18eb f5				push af 
18ec			 
18ec				; for use in here 
18ec			 
18ec			;	push bc 
18ec			;	push de 
18ec			;	push hl 
18ec			;	push af 
18ec			 
18ec cd a7 0d			call clear_display 
18ef			 
18ef 11 c7 1a			ld de, .ptrstate 
18f2 3e 00			ld a, display_row_1 
18f4 cd ba 0d			call str_at_display 
18f7			 
18f7				; display debug step 
18f7			 
18f7			 
18f7 11 a6 fd			ld de, debug_mark 
18fa 3e 26			ld a, display_row_1+display_cols-2 
18fc cd ba 0d			call str_at_display 
18ff			 
18ff				; display a 
18ff 11 d1 1a			ld de, .ptrcliptr 
1902 3e 28			ld a, display_row_2 
1904 cd ba 0d			call str_at_display 
1907			 
1907 f1				pop af 
1908 2a 7b f9			ld hl,(cli_ptr) 
190b 3e 30			ld a, display_row_2+8 
190d cd c9 18			call display_word_at 
1910			 
1910			 
1910				; display hl 
1910			 
1910			 
1910 11 d9 1a			ld de, .ptrclioptr 
1913 3e 32			ld a, display_row_2+10 
1915 cd ba 0d			call str_at_display 
1918			; 
1918			;	pop hl 
1918 3e 35			ld a, display_row_2+13 
191a 2a 79 f9			ld hl,(cli_origptr) 
191d cd c9 18			call display_word_at 
1920			; 
1920			;	 
1920			;	; display de 
1920			 
1920			;	ld de, .regstatede 
1920			;	ld a, display_row_3 
1920			;	call str_at_display 
1920			 
1920			;	pop de 
1920			;	ld h,d 
1920			;	ld l, e 
1920			;	ld a, display_row_3+3 
1920			;	call display_word_at 
1920			 
1920			 
1920				; display bc 
1920			 
1920			;	ld de, .regstatebc 
1920			;	ld a, display_row_3+10 
1920			;	call str_at_display 
1920			 
1920			;	pop bc 
1920			;	ld h,b 
1920			;	ld l, c 
1920			;	ld a, display_row_3+13 
1920			;	call display_word_at 
1920			 
1920			 
1920				; display dsp 
1920			 
1920			;	ld de, .regstatedsp 
1920			;	ld a, display_row_4 
1920			;	call str_at_display 
1920			 
1920				 
1920			;	ld hl,(cli_data_sp) 
1920			;	ld a, display_row_4+4 
1920			;	call display_word_at 
1920			 
1920				; display rsp 
1920			 
1920 11 08 1b			ld de, .regstatersp 
1923 3e 82			ld a, display_row_4+10 
1925 cd ba 0d			call str_at_display 
1928			 
1928				 
1928 2a 2d f9			ld hl,(cli_ret_sp) 
192b 3e 86			ld a, display_row_4+14 
192d cd c9 18			call display_word_at 
1930			 
1930 cd ca 0d			call update_display 
1933			 
1933 cd ea 0c			call delay1s 
1936 cd ea 0c			call delay1s 
1939 cd ea 0c			call delay1s 
193c			 
193c			 
193c cd a7 1f			call next_page_prompt 
193f			 
193f				; restore  
193f			 
193f f1				pop af 
1940 e1				pop hl 
1941 c1				pop bc 
1942 d1				pop de 
1943 c9				ret 
1944			 
1944			; Update the break point vector so that the user can hook a new routine 
1944			 
1944			bp_on: 
1944 3e c3			ld a, $c3    ; JP 
1946 32 aa fd			ld (debug_vector), a 
1949 21 56 19			ld hl, break_point_state 
194c 22 ab fd			ld (debug_vector+1), hl 
194f c9				ret 
1950			 
1950			bp_off: 
1950 3e c9			ld a, $c9    ; RET 
1952 32 aa fd			ld (debug_vector), a 
1955 c9				ret 
1956			 
1956			 
1956			break_point_state: 
1956			;	push af 
1956			; 
1956			;	; see if disabled 
1956			; 
1956			;	ld a, (os_view_disable) 
1956			;	cp '*' 
1956			;	jr nz, .bpsgo 
1956			;	pop af 
1956			;	ret 
1956			 
1956			.bpsgo: 
1956			;	pop af 
1956 f5				push af 
1957 22 de f0			ld (os_view_hl), hl 
195a ed 53 dc f0		ld (os_view_de), de 
195e ed 43 da f0		ld (os_view_bc), bc 
1962 e5				push hl 
1963 6f				ld l, a 
1964 26 00			ld h, 0 
1966 22 e0 f0			ld (os_view_af),hl 
1969			 
1969 21 ec fc				ld hl, display_fb0 
196c 22 07 fb				ld (display_fb_active), hl 
196f e1				pop hl	 
1970			 
1970 3e 31			ld a, '1' 
1972 fe 2a		.bps1:  cp '*' 
1974 cc 50 19			call z, bp_off 
1977			;	jr nz, .bps1b 
1977			;	ld (os_view_disable),a 
1977 fe 31		.bps1b:  cp '1' 
1979 20 14			jr nz, .bps2 
197b			 
197b				; display reg 
197b			 
197b				 
197b			 
197b 3a e0 f0			ld a, (os_view_af) 
197e 2a de f0			ld hl, (os_view_hl) 
1981 ed 5b dc f0		ld de, (os_view_de) 
1985 ed 4b da f0		ld bc, (os_view_bc) 
1989 cd 23 1a			call display_reg_state 
198c c3 0f 1a			jp .bpschk 
198f			 
198f fe 32		.bps2:  cp '2' 
1991 20 08			jr nz, .bps3 
1993				 
1993				; display hl 
1993 2a de f0			ld hl, (os_view_hl) 
1996 cd 0d 1b			call display_dump_at_hl 
1999			 
1999 18 74			jr .bpschk 
199b			 
199b fe 33		.bps3:  cp '3' 
199d 20 08			jr nz, .bps4 
199f			 
199f			        ; display de 
199f 2a dc f0			ld hl, (os_view_de) 
19a2 cd 0d 1b			call display_dump_at_hl 
19a5			 
19a5 18 68			jr .bpschk 
19a7 fe 34		.bps4:  cp '4' 
19a9 20 08			jr nz, .bps5 
19ab			 
19ab			        ; display bc 
19ab 2a da f0			ld hl, (os_view_bc) 
19ae cd 0d 1b			call display_dump_at_hl 
19b1			 
19b1 18 5c			jr .bpschk 
19b3 fe 35		.bps5:  cp '5' 
19b5 20 08		        jr nz, .bps7 
19b7			 
19b7				; display cur ptr 
19b7 2a 7b f9			ld hl, (cli_ptr) 
19ba cd 0d 1b			call display_dump_at_hl 
19bd			 
19bd 18 50			jr .bpschk 
19bf fe 36		.bps7:  cp '6' 
19c1 20 08			jr nz, .bps8b 
19c3				 
19c3				; display cur orig ptr 
19c3 2a 79 f9			ld hl, (cli_origptr) 
19c6 cd 0d 1b			call display_dump_at_hl 
19c9 18 44			jr .bpschk 
19cb fe 37		.bps8b:  cp '7' 
19cd 20 08			jr nz, .bps9 
19cf				 
19cf				; display dsp 
19cf 2a 29 f9			ld hl, (cli_data_sp) 
19d2 cd 0d 1b			call display_dump_at_hl 
19d5			 
19d5 18 38			jr .bpschk 
19d7 fe 39		.bps9:  cp '9' 
19d9 20 05			jr nz, .bps8c 
19db				 
19db				; display SP 
19db			;	ld hl, sp 
19db cd 0d 1b			call display_dump_at_hl 
19de			 
19de 18 2f			jr .bpschk 
19e0 fe 38		.bps8c:  cp '8' 
19e2 20 08			jr nz, .bps8d 
19e4				 
19e4				; display rsp 
19e4 2a 2d f9			ld hl, (cli_ret_sp) 
19e7 cd 0d 1b			call display_dump_at_hl 
19ea			 
19ea 18 23			jr .bpschk 
19ec fe 23		.bps8d:  cp '#'     ; access monitor sub system 
19ee 20 05			jr nz, .bps8 
19f0 cd 75 1d			call monitor 
19f3			 
19f3 18 1a			jr .bpschk 
19f5 fe 30		.bps8:  cp '0' 
19f7 20 16			jr nz, .bpschk 
19f9			 
19f9 21 4b fc				ld hl, display_fb1 
19fc 22 07 fb				ld (display_fb_active), hl 
19ff cd ca 0d				call update_display 
1a02			 
1a02				;ld a, (os_view_af) 
1a02 2a de f0			ld hl, (os_view_hl) 
1a05 ed 5b dc f0		ld de, (os_view_de) 
1a09 ed 4b da f0		ld bc, (os_view_bc) 
1a0d f1				pop af 
1a0e c9				ret 
1a0f			 
1a0f			.bpschk:   
1a0f cd ea 0c			call delay1s 
1a12 3e 9f		ld a,display_row_4 + display_cols - 1 
1a14 11 a5 1f		        ld de, endprg 
1a17 cd ba 0d			call str_at_display 
1a1a cd ca 0d			call update_display 
1a1d cd bf 72			call cin_wait 
1a20			 
1a20 c3 72 19			jp .bps1 
1a23			 
1a23			 
1a23			display_reg_state: 
1a23			 
1a23				; to restore afterwards 
1a23			 
1a23 d5				push de 
1a24 c5				push bc 
1a25 e5				push hl 
1a26 f5				push af 
1a27			 
1a27				; for use in here 
1a27			 
1a27 c5				push bc 
1a28 d5				push de 
1a29 e5				push hl 
1a2a f5				push af 
1a2b			 
1a2b cd a7 0d			call clear_display 
1a2e			 
1a2e 11 e3 1a			ld de, .regstate 
1a31 3e 00			ld a, display_row_1 
1a33 cd ba 0d			call str_at_display 
1a36			 
1a36				; display debug step 
1a36			 
1a36			 
1a36 11 a6 fd			ld de, debug_mark 
1a39 3e 25			ld a, display_row_1+display_cols-3 
1a3b cd ba 0d			call str_at_display 
1a3e			 
1a3e				; display a 
1a3e 11 ff 1a			ld de, .regstatea 
1a41 3e 28			ld a, display_row_2 
1a43 cd ba 0d			call str_at_display 
1a46			 
1a46 e1				pop hl 
1a47			;	ld h,0 
1a47			;	ld l, a 
1a47 3e 2b			ld a, display_row_2+3 
1a49 cd c9 18			call display_word_at 
1a4c			 
1a4c			 
1a4c				; display hl 
1a4c			 
1a4c			 
1a4c 11 f3 1a			ld de, .regstatehl 
1a4f 3e 32			ld a, display_row_2+10 
1a51 cd ba 0d			call str_at_display 
1a54			 
1a54 e1				pop hl 
1a55 3e 35			ld a, display_row_2+13 
1a57 cd c9 18			call display_word_at 
1a5a			 
1a5a				 
1a5a				; display de 
1a5a			 
1a5a 11 f7 1a			ld de, .regstatede 
1a5d 3e 50			ld a, display_row_3 
1a5f cd ba 0d			call str_at_display 
1a62			 
1a62 e1				pop hl 
1a63			;	ld h,d 
1a63			;	ld l, e 
1a63 3e 53			ld a, display_row_3+3 
1a65 cd c9 18			call display_word_at 
1a68			 
1a68			 
1a68				; display bc 
1a68			 
1a68 11 fb 1a			ld de, .regstatebc 
1a6b 3e 5a			ld a, display_row_3+10 
1a6d cd ba 0d			call str_at_display 
1a70			 
1a70 e1				pop hl 
1a71			;	ld h,b 
1a71			;	ld l, c 
1a71 3e 5d			ld a, display_row_3+13 
1a73 cd c9 18			call display_word_at 
1a76			 
1a76			 
1a76				; display dsp 
1a76			 
1a76 11 03 1b			ld de, .regstatedsp 
1a79 3e 78			ld a, display_row_4 
1a7b cd ba 0d			call str_at_display 
1a7e			 
1a7e				 
1a7e 2a 29 f9			ld hl,(cli_data_sp) 
1a81 3e 7c			ld a, display_row_4+4 
1a83 cd c9 18			call display_word_at 
1a86			 
1a86				; display rsp 
1a86			 
1a86 11 08 1b			ld de, .regstatersp 
1a89 3e 82			ld a, display_row_4+10 
1a8b cd ba 0d			call str_at_display 
1a8e			 
1a8e				 
1a8e 2a 2d f9			ld hl,(cli_ret_sp) 
1a91 3e 86			ld a, display_row_4+14 
1a93 cd c9 18			call display_word_at 
1a96			 
1a96 cd ca 0d			call update_display 
1a99			 
1a99			;	call delay1s 
1a99			;	call delay1s 
1a99			;	call delay1s 
1a99			 
1a99			 
1a99			;	call next_page_prompt 
1a99			 
1a99				; restore  
1a99			 
1a99 f1				pop af 
1a9a e1				pop hl 
1a9b c1				pop bc 
1a9c d1				pop de 
1a9d c9				ret 
1a9e			 
1a9e .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1ab2 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1ac7 .. 00		.ptrstate:	db "Ptr State",0 
1ad1 .. 00		.ptrcliptr:     db "cli_ptr",0 
1ad9 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1ae3 .. 00		.regstate:	db "Reg State (1/0)",0 
1af3 .. 00		.regstatehl:	db "HL:",0 
1af7 .. 00		.regstatede:	db "DE:",0 
1afb .. 00		.regstatebc:	db "BC:",0 
1aff .. 00		.regstatea:	db "A :",0 
1b03 .. 00		.regstatedsp:	db "DSP:",0 
1b08 .. 00		.regstatersp:	db "RSP:",0 
1b0d			 
1b0d			display_dump_at_hl: 
1b0d e5				push hl 
1b0e d5				push de 
1b0f c5				push bc 
1b10 f5				push af 
1b11			 
1b11 22 1f f4			ld (os_cur_ptr),hl	 
1b14 cd a7 0d			call clear_display 
1b17 cd af 1e			call dumpcont 
1b1a			;	call delay1s 
1b1a			;	call next_page_prompt 
1b1a			 
1b1a			 
1b1a f1				pop af 
1b1b c1				pop bc 
1b1c d1				pop de 
1b1d e1				pop hl 
1b1e c9				ret 
1b1f			 
1b1f			;if ENABLE_BASIC 
1b1f			;	include "nascombasic.asm" 
1b1f			;	basic: 
1b1f			;	include "forth/FORTH.ASM" 
1b1f			;endif 
1b1f			 
1b1f			; eof 
1b1f			 
1b1f			 
# End of file firmware_diags.asm
1b1f			  
1b1f			include "firmware_prompts.asm"  
1b1f			; Prompts  
1b1f			 
1b1f			; boot messages 
1b1f			 
1b1f .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1b34 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1b44			 
1b44			 
1b44			; config menus 
1b44			 
1b44			;prom_c3: db "Add Dictionary To File",0 
1b44			 
1b44			if STARTUP_V1 
1b44			prom_c2: db "Select Autoload File",0 
1b44			prom_c2a: db "Disable Autoload File", 0 
1b44			endif 
1b44			 
1b44			if STARTUP_V2 
1b44 .. 00		prom_c2: db "Enable Autoload Files",0 
1b5a .. 00		prom_c2a: db "Disable Autoload Files", 0 
1b71			 
1b71 .. 00		crs_s1: db "*ls-word", 0 
1b7a .. 00		crs_s2: db "*ed-word", 0 
1b83 .. 00		crs_s3: db "*Demo-Games", 0 
1b8f .. 00		crs_s4: db "*Utils", 0 
1b96 .. 00		crs_s5: db "*SPI-Util", 0 
1ba0 .. 00		crs_s6: db "*Key-Constants", 0 
1baf .. 00		crs_sound: db "*Sound-Util", 0 
1bbb .. 00		crs_hw: db "*Hello-World",0 
1bc8			 
1bc8			 
1bc8			 
1bc8			endif 
1bc8			;prom_c2b: db "Select Storage Bank",0 
1bc8 .. 00		prom_c4: db "Settings",0 
1bd1 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1bec .. 00		prom_m4b:   db "Monitor",0 
1bf4 .. 00		prom_c1: db "Hardware Diags",0 
1c03			 
1c03			 
1c03			if STARTUP_V2 
1c03 .. 00		prom_c9: db "Create Startup Files",0 
1c18			endif 
1c18			 
1c18 .. 00		prom_notav:    db "Feature not available",0 
1c2e .. 00		prom_empty:    db "",0 
1c2f			 
1c2f			; eof 
1c2f			 
# End of file firmware_prompts.asm
1c2f			  
1c2f			  
1c2f			; eof  
1c2f			  
# End of file firmware.asm
1c2f			 
1c2f			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1c2f			;if BASE_KEV  
1c2f			;baseram: equ 08000h 
1c2f			;endif 
1c2f			 
1c2f			;if BASE_SC114 
1c2f			;baseram:     equ    endofcode 
1c2f			;endif 
1c2f			 
1c2f			 
1c2f			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1c2f			 
1c2f			; start system 
1c2f			 
1c2f			coldstart: 
1c2f				; set sp 
1c2f				; di/ei 
1c2f			 
1c2f f3				di 
1c30 31 fd ff			ld sp, tos 
1c33 cd 46 6f			call init_nmi 
1c36			;	ei 
1c36			 
1c36				; init spinner 
1c36 3e 00			ld a,0 
1c38 32 01 fb			ld (display_active), a 
1c3b			 
1c3b				; disable breakpoint by default 
1c3b			 
1c3b				;ld a,'*' 
1c3b			;	ld a,' ' 
1c3b			;	ld (os_view_disable),a 
1c3b			 
1c3b				; set break point vector as new break point on or off 
1c3b cd 50 19			call bp_off 
1c3e			 
1c3e				; init hardware 
1c3e			 
1c3e				; init keyboard and screen hardware 
1c3e			 
1c3e cd 6c 00			call hardware_init 
1c41			 
1c41			 
1c41 cd ea 0c			call delay1s 
1c44 3e 58			ld a, display_row_3+8 
1c46 11 03 00			ld de, buildtime 
1c49 cd ba 0d			call str_at_display 
1c4c cd ca 0d			call update_display 
1c4f			 
1c4f cd ea 0c			call delay1s 
1c52 cd ea 0c			call delay1s 
1c55 cd ea 0c			call delay1s 
1c58			 
1c58				; detect if any keys are held down to enable breakpoints at start up 
1c58			 
1c58 cd d0 72			call cin  
1c5b fe 00			cp 0 
1c5d 28 03			jr z, .nokeys 
1c5f			 
1c5f				;call hardware_diags 
1c5f cd 4f 15			call config 
1c62			 
1c62			;	ld de, .bpen 
1c62			;	ld a, display_row_4 
1c62			;	call str_at_display 
1c62			;	call update_display 
1c62			; 
1c62			;	ld a,0 
1c62			;	ld (os_view_disable),a 
1c62			; 
1c62			;.bpwait: 
1c62			;	call cin 
1c62			;	cp 0 
1c62			;	jr z, .bpwait 
1c62			;	jr .nokeys 
1c62			; 
1c62			; 
1c62			;.bpen:  db "Break points enabled!",0 
1c62			 
1c62			 
1c62			 
1c62			 
1c62			 
1c62			 
1c62			.nokeys: 
1c62			 
1c62			 
1c62				 
1c62			 
1c62			;jp  testkey 
1c62			 
1c62			;call storage_get_block_0 
1c62			; 
1c62			;ld hl, 0 
1c62			;ld de, store_page 
1c62			;call storage_read_block 
1c62			 
1c62				 
1c62			;ld hl, 10 
1c62			;ld de, store_page 
1c62			;call storage_read_block 
1c62			 
1c62			 
1c62			 
1c62			 
1c62			 
1c62			;stop:	nop 
1c62			;	jp stop 
1c62			 
1c62			 
1c62			 
1c62			main: 
1c62 cd a7 0d			call clear_display 
1c65 cd ca 0d			call update_display 
1c68			 
1c68			 
1c68			 
1c68			;	call testlcd 
1c68			 
1c68			 
1c68			 
1c68 cd ba 23			call forth_init 
1c6b			 
1c6b			 
1c6b			warmstart: 
1c6b cd 90 23			call forth_warmstart 
1c6e			 
1c6e				; run startup word load 
1c6e			        ; TODO prevent this running at warmstart after crash  
1c6e			 
1c6e				if STARTUP_ENABLE 
1c6e			 
1c6e					if STARTUP_V1 
1c6e			 
1c6e						if STORAGE_SE 
1c6e							call forth_autoload 
1c6e						endif 
1c6e						call forth_startup 
1c6e					endif 
1c6e			 
1c6e					if STARTUP_V2 
1c6e			 
1c6e						if STORAGE_SE 
1c6e cd 74 6d						call forth_autoload 
1c71						else 
1c71							call forth_startup 
1c71						endif 
1c71			 
1c71			 
1c71					endif 
1c71			 
1c71				endif 
1c71			 
1c71			warmstart_afterauto: 
1c71			 
1c71				; show free memory after boot 
1c71 11 10 1d			ld de, freeram 
1c74 3e 00			ld a, display_row_1 
1c76 cd ba 0d			call str_at_display 
1c79			 
1c79				; get current heap start after loading any uwords 
1c79			 
1c79				;ld de, (os_last_new_uword) 
1c79				;ex de, hl 
1c79			 
1c79			; Or use heap_size word???? 
1c79				;ld hl, heap_end 
1c79				;ld hl, heap_size 
1c79				;ld de, topusermem 
1c79				;ld de, heap_start 
1c79 ed 5b 0a 80			ld de, (free_list )      
1c7d 21 d7 f0				ld hl, heap_end 
1c80 ed 52			sbc hl, de 
1c82				;push hl 
1c82				;ld a,h	         	 
1c82				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1c82				;call hexout 
1c82			   	;pop hl 
1c82			; 
1c82			;	ld a,l 
1c82			;	ld hl, os_word_scratch+2 
1c82			;	call hexout 
1c82			;	ld hl, os_word_scratch+4 
1c82			;	ld a, 0 
1c82			;	ld (hl),a 
1c82 eb				ex de, hl 
1c83 21 01 f4			ld hl, os_word_scratch 
1c86 cd f0 12			call uitoa_16 
1c89			 
1c89			 
1c89 11 01 f4			ld de, os_word_scratch 
1c8c 3e 0d			ld a, display_row_1 + 13 
1c8e cd ba 0d			call str_at_display 
1c91 cd ca 0d			call update_display 
1c94			 
1c94			 
1c94				;call demo 
1c94			 
1c94			 
1c94				; init scratch input area for cli commands 
1c94			 
1c94 21 23 f4			ld hl, os_cli_cmd 
1c97 3e 00			ld a,0 
1c99 77				ld (hl),a 
1c9a 23				inc hl 
1c9b 77				ld (hl),a 
1c9c			 
1c9c 3e 00			ld a,0 
1c9e 32 22 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1ca1			 
1ca1 32 1f f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1ca4 32 20 f4			ld (os_cur_ptr+1),a	 
1ca7			 
1ca7 32 01 f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1caa 32 02 f4			ld (os_word_scratch+1),a	 
1cad				 
1cad			 
1cad				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cad 21 23 f4			ld hl, os_cli_cmd 
1cb0			 
1cb0 3e 00			ld a, 0		 ; init cli input 
1cb2 77				ld (hl), a 
1cb3 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cb5			cli: 
1cb5				; show cli prompt 
1cb5				;push af 
1cb5				;ld a, 0 
1cb5				;ld de, prompt 
1cb5				;call str_at_display 
1cb5			 
1cb5				;call update_display 
1cb5				;pop af 
1cb5				;inc a 
1cb5				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1cb5			 
1cb5			.lastrecall: 
1cb5			 
1cb5 0e 00			ld c, 0 
1cb7 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1cb9 1e 28			ld e, 40 
1cbb			 
1cbb 21 23 f4			ld hl, os_cli_cmd 
1cbe			 
1cbe				STACKFRAME OFF $fefe $9f9f 
1cbe				if DEBUG_STACK_IMB 
1cbe					if OFF 
1cbe						exx 
1cbe						ld de, $fefe 
1cbe						ld a, d 
1cbe						ld hl, curframe 
1cbe						call hexout 
1cbe						ld a, e 
1cbe						ld hl, curframe+2 
1cbe						call hexout 
1cbe						ld hl, $fefe 
1cbe						push hl 
1cbe						ld hl, $9f9f 
1cbe						push hl 
1cbe						exx 
1cbe					endif 
1cbe				endif 
1cbe			endm 
# End of macro STACKFRAME
1cbe			 
1cbe cd 08 10			call input_str 
1cc1			 
1cc1				STACKFRAMECHK OFF $fefe $9f9f 
1cc1				if DEBUG_STACK_IMB 
1cc1					if OFF 
1cc1						exx 
1cc1						ld hl, $9f9f 
1cc1						pop de   ; $9f9f 
1cc1						call cmp16 
1cc1						jr nz, .spnosame 
1cc1						ld hl, $fefe 
1cc1						pop de   ; $fefe 
1cc1						call cmp16 
1cc1						jr z, .spfrsame 
1cc1						.spnosame: call showsperror 
1cc1						.spfrsame: nop 
1cc1						exx 
1cc1					endif 
1cc1				endif 
1cc1			endm 
# End of macro STACKFRAMECHK
1cc1			 
1cc1			 
1cc1				; check to see if last line recall has been requested 
1cc1			 
1cc1			if EDIT_V2 
1cc1 fe 05			cp KEY_UP 
1cc3 20 0f			jr nz, .noexecline 
1cc5			 
1cc5 11 23 f4			ld de, os_cli_cmd 
1cc8 21 22 f5			ld hl, os_last_cmd 
1ccb 01 ff 00			ld bc, 255 
1cce ed b0			ldir 
1cd0 3e 00			ld a, 0 
1cd2 18 e1			jr .lastrecall 
1cd4			endif 
1cd4			 
1cd4			.noexecline: 
1cd4				; no so exec the line		 
1cd4			 
1cd4				; copy input to last command 
1cd4			 
1cd4 21 23 f4			ld hl, os_cli_cmd 
1cd7 11 22 f5			ld de, os_last_cmd 
1cda 01 ff 00			ld bc, 255 
1cdd ed b0			ldir 
1cdf			 
1cdf				; wipe current buffer 
1cdf			 
1cdf			;	ld a, 0 
1cdf			;	ld hl, os_cli_cmd 
1cdf			;	ld de, os_cli_cmd+1 
1cdf			;	ld bc, 254 
1cdf			;	ldir 
1cdf				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1cdf			;	call strcpy 
1cdf			;	ld a, 0 
1cdf			;	ld (hl), a 
1cdf			;	inc hl 
1cdf			;	ld (hl), a 
1cdf			;	inc hl 
1cdf			;	ld (hl), a 
1cdf			 
1cdf				; switch frame buffer to program  
1cdf			 
1cdf 21 4b fc				ld hl, display_fb1 
1ce2 22 07 fb				ld (display_fb_active), hl 
1ce5			 
1ce5			;	nop 
1ce5				STACKFRAME ON $fbfe $8f9f 
1ce5				if DEBUG_STACK_IMB 
1ce5					if ON 
1ce5						exx 
1ce5						ld de, $fbfe 
1ce5						ld a, d 
1ce5						ld hl, curframe 
1ce5						call hexout 
1ce5						ld a, e 
1ce5						ld hl, curframe+2 
1ce5						call hexout 
1ce5						ld hl, $fbfe 
1ce5						push hl 
1ce5						ld hl, $8f9f 
1ce5						push hl 
1ce5						exx 
1ce5					endif 
1ce5				endif 
1ce5			endm 
# End of macro STACKFRAME
1ce5				; first time into the parser so pass over the current scratch pad 
1ce5 21 23 f4			ld hl,os_cli_cmd 
1ce8				; tokenise the entered statement(s) in HL 
1ce8 cd 38 24			call forthparse 
1ceb			        ; exec forth statements in top of return stack 
1ceb cd 78 24			call forthexec 
1cee				;call forthexec_cleanup 
1cee			;	call parsenext 
1cee			 
1cee				STACKFRAMECHK ON $fbfe $8f9f 
1cee				if DEBUG_STACK_IMB 
1cee					if ON 
1cee						exx 
1cee						ld hl, $8f9f 
1cee						pop de   ; $8f9f 
1cee						call cmp16 
1cee						jr nz, .spnosame 
1cee						ld hl, $fbfe 
1cee						pop de   ; $fbfe 
1cee						call cmp16 
1cee						jr z, .spfrsame 
1cee						.spnosame: call showsperror 
1cee						.spfrsame: nop 
1cee						exx 
1cee					endif 
1cee				endif 
1cee			endm 
# End of macro STACKFRAMECHK
1cee				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1cee			 
1cee 3e 78			ld a, display_row_4 
1cf0 11 21 1d			ld de, endprog 
1cf3			 
1cf3 cd ca 0d			call update_display		 
1cf6			 
1cf6 cd a7 1f			call next_page_prompt 
1cf9			 
1cf9				; switch frame buffer to cli 
1cf9			 
1cf9 21 ec fc				ld hl, display_fb0 
1cfc 22 07 fb				ld (display_fb_active), hl 
1cff			 
1cff			 
1cff cd a7 0d		        call clear_display 
1d02 cd ca 0d			call update_display		 
1d05			 
1d05 21 23 f4			ld hl, os_cli_cmd 
1d08			 
1d08 3e 00			ld a, 0		 ; init cli input 
1d0a 77				ld (hl), a 
1d0b			 
1d0b				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1d0b			 
1d0b				; now on last line 
1d0b			 
1d0b				; TODO scroll screen up 
1d0b			 
1d0b				; TODO instead just clear screen and place at top of screen 
1d0b			 
1d0b			;	ld a, 0 
1d0b			;	ld (f_cursor_ptr),a 
1d0b			 
1d0b				;call clear_display 
1d0b				;call update_display 
1d0b			 
1d0b				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d0b 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d0d c3 b5 1c			jp cli 
1d10			 
1d10 .. 00		freeram: db "Free bytes: ",0 
1d1d ..			asc: db "1A2F" 
1d21 .. 00		endprog: db "End prog...",0 
1d2d			 
1d2d			testenter2:   
1d2d 21 2e f1			ld hl,scratch+50 
1d30 22 1f f4			ld (os_cur_ptr),hl 
1d33 c3 b5 1c			jp cli 
1d36			 
1d36			testenter:  
1d36			 
1d36 21 1d 1d			ld hl,asc 
1d39			;	ld a,(hl) 
1d39			;	call nibble2val 
1d39 cd 3a 12			call get_byte 
1d3c			 
1d3c			 
1d3c			;	ld a,(hl) 
1d3c			;	call atohex 
1d3c			 
1d3c			;	call fourehexhl 
1d3c 32 2e f1			ld (scratch+50),a 
1d3f			 
1d3f			 
1d3f			 
1d3f 21 1f 1d			ld hl,asc+2 
1d42			;	ld a, (hl) 
1d42			;	call nibble2val 
1d42 cd 3a 12			call get_byte 
1d45			 
1d45			;	call fourehexhl 
1d45 32 30 f1			ld (scratch+52),a 
1d48				 
1d48 21 2e f1			ld hl,scratch+50 
1d4b 22 1f f4			ld (os_cur_ptr),hl 
1d4e c3 b5 1c			jp cli 
1d51			 
1d51			enter:	 
1d51 3a 00 f1			ld a,(scratch+4) 
1d54 fe 00			cp 0 
1d56 28 0c			jr z, .entercont 
1d58				; no, not a null term line so has an address to work out.... 
1d58			 
1d58 21 fe f0			ld hl,scratch+2 
1d5b cd 9a 12			call get_word_hl 
1d5e			 
1d5e 22 1f f4			ld (os_cur_ptr),hl	 
1d61 c3 b5 1c			jp cli 
1d64			 
1d64			 
1d64			.entercont:  
1d64			 
1d64 21 fe f0			ld hl, scratch+2 
1d67 cd 3a 12			call get_byte 
1d6a			 
1d6a 2a 1f f4		   	ld hl,(os_cur_ptr) 
1d6d 77					ld (hl),a 
1d6e 23					inc hl 
1d6f 22 1f f4				ld (os_cur_ptr),hl 
1d72				 
1d72			; get byte  
1d72			 
1d72			 
1d72 c3 b5 1c			jp cli 
1d75			 
1d75			 
1d75			; basic monitor support 
1d75			 
1d75			monitor: 
1d75				;  
1d75 cd a7 0d			call clear_display 
1d78 3e 00			ld a, 0 
1d7a 11 c9 1d			ld de, .monprompt 
1d7d cd ba 0d			call str_at_display 
1d80 cd ca 0d			call update_display 
1d83			 
1d83				; get a monitor command 
1d83			 
1d83 0e 00			ld c, 0     ; entry at top left 
1d85 16 64			ld d, 100   ; max buffer size 
1d87 1e 0f			ld e, 15    ; input scroll area 
1d89 3e 00			ld a, 0     ; init string 
1d8b 21 fa f2			ld hl, os_input 
1d8e 77				ld (hl), a 
1d8f 23				inc hl 
1d90 77				ld (hl), a 
1d91 21 fa f2			ld hl, os_input 
1d94 3e 01			ld a, 1     ; init string 
1d96 cd 08 10			call input_str 
1d99			 
1d99 cd a7 0d		        call clear_display 
1d9c cd ca 0d			call update_display		 
1d9f			 
1d9f 3a fa f2			ld a, (os_input) 
1da2 cd 38 13			call toUpper 
1da5 fe 48		        cp 'H' 
1da7 ca 2e 1e		        jp z, .monhelp 
1daa fe 44			cp 'D'		; dump 
1dac ca 61 1e			jp z, .mondump	 
1daf fe 43			cp 'C'		; dump 
1db1 ca 7b 1e			jp z, .moncdump	 
1db4 fe 4d			cp 'M'		; dump 
1db6 ca cb 1d			jp z, .moneditstart 
1db9 fe 55			cp 'U'		; dump 
1dbb ca d7 1d			jp z, .monedit	 
1dbe fe 47			cp 'G'		; dump 
1dc0 ca 57 1e			jp z, .monjump 
1dc3 fe 51			cp 'Q'		; dump 
1dc5 c8				ret z	 
1dc6			 
1dc6			 
1dc6				; TODO "S" to access symbol by name and not need the address 
1dc6				; TODO "F" to find a string in memory 
1dc6			 
1dc6 c3 75 1d			jp monitor 
1dc9			 
1dc9 .. 00		.monprompt: db ">", 0 
1dcb			 
1dcb			.moneditstart: 
1dcb				; get starting address 
1dcb			 
1dcb 21 fc f2			ld hl,os_input+2 
1dce cd 9a 12			call get_word_hl 
1dd1			 
1dd1 22 1f f4			ld (os_cur_ptr),hl	 
1dd4			 
1dd4 c3 75 1d			jp monitor 
1dd7			 
1dd7			.monedit: 
1dd7				; get byte to load 
1dd7			 
1dd7 21 fc f2			ld hl,os_input+2 
1dda cd 3a 12			call get_byte 
1ddd			 
1ddd				; get address to update 
1ddd 2a 1f f4			ld hl, (os_cur_ptr) 
1de0			 
1de0				; update byte 
1de0			 
1de0 77				ld (hl), a 
1de1			 
1de1				; move to next address and save it 
1de1			 
1de1 23				inc hl 
1de2 22 1f f4			ld (os_cur_ptr),hl	 
1de5			 
1de5 c3 75 1d			jp monitor 
1de8			 
1de8			 
1de8 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1dfc .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1e18 .. 00		.monhelptext3:  db "G-Call address",0 
1e27 .. 00		.monhelptext4:  db "Q-Quit",0 
1e2e			        
1e2e			.monhelp: 
1e2e 3e 00			ld a, display_row_1 
1e30 11 e8 1d		        ld de, .monhelptext1 
1e33			 
1e33 cd ba 0d			call str_at_display 
1e36 3e 28			ld a, display_row_2 
1e38 11 fc 1d		        ld de, .monhelptext2 
1e3b					 
1e3b cd ba 0d			call str_at_display 
1e3e 3e 50			ld a, display_row_3 
1e40 11 18 1e		        ld de, .monhelptext3 
1e43					 
1e43 cd ba 0d			call str_at_display 
1e46 3e 78			ld a, display_row_4 
1e48 11 27 1e		        ld de, .monhelptext4 
1e4b cd ba 0d			call str_at_display 
1e4e			 
1e4e cd ca 0d			call update_display		 
1e51			 
1e51 cd a7 1f			call next_page_prompt 
1e54 c3 75 1d			jp monitor 
1e57			 
1e57			.monjump:    
1e57 21 fc f2			ld hl,os_input+2 
1e5a cd 9a 12			call get_word_hl 
1e5d			 
1e5d e9				jp (hl) 
1e5e c3 75 1d			jp monitor 
1e61			 
1e61			.mondump:    
1e61 21 fc f2			ld hl,os_input+2 
1e64 cd 9a 12			call get_word_hl 
1e67			 
1e67 22 1f f4			ld (os_cur_ptr),hl	 
1e6a cd af 1e			call dumpcont 
1e6d 3e 78			ld a, display_row_4 
1e6f 11 21 1d			ld de, endprog 
1e72			 
1e72 cd ca 0d			call update_display		 
1e75			 
1e75 cd a7 1f			call next_page_prompt 
1e78 c3 75 1d			jp monitor 
1e7b			.moncdump: 
1e7b cd af 1e			call dumpcont 
1e7e 3e 78			ld a, display_row_4 
1e80 11 21 1d			ld de, endprog 
1e83			 
1e83 cd ca 0d			call update_display		 
1e86			 
1e86 cd a7 1f			call next_page_prompt 
1e89 c3 75 1d			jp monitor 
1e8c			 
1e8c			 
1e8c			; TODO symbol access  
1e8c			 
1e8c			.symbols:     ;; A list of symbols that can be called up  
1e8c ec fc			dw display_fb0 
1e8e .. 00			db "fb0",0  
1e92 b5 f9		     	dw store_page 
1e94 .. 00			db "store_page",0 
1e9f			 
1e9f			 
1e9f			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1e9f			 
1e9f 3a fd f0			ld a,(scratch+1) 
1ea2 fe 00			cp 0 
1ea4 28 09			jr z, dumpcont 
1ea6			 
1ea6				; no, not a null term line so has an address to work out.... 
1ea6			 
1ea6 21 fe f0			ld hl,scratch+2 
1ea9 cd 9a 12			call get_word_hl 
1eac			 
1eac 22 1f f4			ld (os_cur_ptr),hl	 
1eaf			 
1eaf			 
1eaf			 
1eaf			dumpcont: 
1eaf			 
1eaf				; dump bytes at ptr 
1eaf			 
1eaf			 
1eaf 3e 00			ld a, display_row_1 
1eb1 2a 07 fb			ld hl, (display_fb_active) 
1eb4 cd db 0f			call addatohl 
1eb7 cd df 1e			call .dumpbyterow 
1eba			 
1eba 3e 28			ld a, display_row_2 
1ebc 2a 07 fb			ld hl, (display_fb_active) 
1ebf cd db 0f			call addatohl 
1ec2 cd df 1e			call .dumpbyterow 
1ec5			 
1ec5			 
1ec5 3e 50			ld a, display_row_3 
1ec7 2a 07 fb			ld hl, (display_fb_active) 
1eca cd db 0f			call addatohl 
1ecd cd df 1e			call .dumpbyterow 
1ed0			 
1ed0 3e 78			ld a, display_row_4 
1ed2 2a 07 fb			ld hl, (display_fb_active) 
1ed5 cd db 0f			call addatohl 
1ed8 cd df 1e			call .dumpbyterow 
1edb			 
1edb cd ca 0d			call update_display 
1ede			;		jp cli 
1ede c9				ret 
1edf			 
1edf			.dumpbyterow: 
1edf			 
1edf				;push af 
1edf			 
1edf e5				push hl 
1ee0			 
1ee0				; calc where to poke the ascii 
1ee0			if display_cols == 20 
1ee0				ld a, 16 
1ee0			else 
1ee0 3e 1f			ld a, 31 
1ee2			endif 
1ee2			 
1ee2 cd db 0f			call addatohl 
1ee5 22 01 f4			ld (os_word_scratch),hl  		; save pos for later 
1ee8			 
1ee8			 
1ee8			; display decoding address 
1ee8 2a 1f f4		   	ld hl,(os_cur_ptr) 
1eeb			 
1eeb 7c				ld a,h 
1eec e1				pop hl 
1eed e5				push hl 
1eee			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1eee cd e4 11			call hexout 
1ef1 2a 1f f4		   	ld hl,(os_cur_ptr) 
1ef4			 
1ef4 7d				ld a,l 
1ef5 e1				pop hl 
1ef6 23				inc hl 
1ef7 23				inc hl 
1ef8 e5				push hl 
1ef9			;	ld hl, os_word_scratch+2 
1ef9 cd e4 11			call hexout 
1efc e1				pop hl 
1efd 23				inc hl 
1efe 23				inc hl 
1eff				;ld hl, os_word_scratch+4 
1eff 3e 3a			ld a, ':' 
1f01 77				ld (hl),a 
1f02 23				inc hl 
1f03				;ld a, 0 
1f03				;ld (hl),a 
1f03				;ld de, os_word_scratch 
1f03				;pop af 
1f03				;push af 
1f03			;		ld a, display_row_2 
1f03			;		call str_at_display 
1f03			;		call update_display 
1f03			 
1f03			 
1f03			;pop af 
1f03			;	add 5 
1f03			 
1f03			if display_cols == 20 
1f03				ld b, 4 
1f03			else 
1f03 06 08			ld b, 8 
1f05			endif	 
1f05			 
1f05			.dumpbyte: 
1f05 c5				push bc 
1f06 e5				push hl 
1f07			 
1f07			 
1f07 2a 1f f4		   	ld hl,(os_cur_ptr) 
1f0a 7e					ld a,(hl) 
1f0b			 
1f0b					; poke the ascii to display 
1f0b 2a 01 f4				ld hl,(os_word_scratch) 
1f0e 77					ld (hl),a 
1f0f 23					inc hl 
1f10 22 01 f4				ld (os_word_scratch),hl 
1f13			 
1f13					 
1f13			 
1f13			 
1f13 e1					pop hl 
1f14 e5					push hl 
1f15			 
1f15 cd e4 11				call hexout 
1f18			 
1f18					 
1f18 2a 1f f4		   	ld hl,(os_cur_ptr) 
1f1b 23				inc hl 
1f1c 22 1f f4		   	ld (os_cur_ptr),hl 
1f1f			 
1f1f e1					pop hl 
1f20 23					inc hl 
1f21 23					inc hl 
1f22 23					inc hl 
1f23			 
1f23			 
1f23			 
1f23					;ld a,0 
1f23					;ld (os_word_scratch+2),a 
1f23					;pop af 
1f23					;push af 
1f23			 
1f23					;ld de, os_word_scratch 
1f23					;call str_at_display 
1f23			;		call update_display 
1f23			;		pop af 
1f23 c1					pop bc 
1f24 c6 03				add 3 
1f26 10 dd			djnz .dumpbyte 
1f28			 
1f28				 
1f28			 
1f28 c9				ret 
1f29			 
1f29			jump:	 
1f29			 
1f29 21 fe f0			ld hl,scratch+2 
1f2c cd 9a 12			call get_word_hl 
1f2f				;ld hl,(scratch+2) 
1f2f				;call fourehexhl 
1f2f			 
1f2f 22 1f f4			ld (os_cur_ptr),hl	 
1f32			 
1f32 e9				jp (hl) 
1f33			 
1f33			 
1f33			 
1f33			; TODO implement a basic monitor mode to start with 
1f33			 
1f33			 
1f33			 
1f33			 
1f33			 
1f33			 
1f33			 
1f33			 
1f33			 
1f33			; testing and demo code during development 
1f33			 
1f33			 
1f33 .. 00		str1: db "Enter some text...",0 
1f46 .. 00		clear: db "                    ",0 
1f5b			 
1f5b			demo: 
1f5b			 
1f5b			 
1f5b			 
1f5b			;	call update_display 
1f5b			 
1f5b				; init scratch input area for testing 
1f5b 21 fc f0			ld hl, scratch	 
1f5e 3e 00			ld a,0 
1f60 77				ld (hl),a 
1f61			 
1f61			 
1f61 3e 28		            LD   A, display_row_2 
1f63			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f63 11 33 1f		            LD   DE, str1 
1f66 cd ba 0d			call str_at_display 
1f69			 
1f69			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f69			cloop:	 
1f69 3e 50		            LD   A, display_row_3 
1f6b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f6b 11 46 1f		            LD   DE, clear 
1f6e			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1f6e cd ba 0d				call str_at_display 
1f71 3e 78			ld a, display_row_4 
1f73 11 a3 1f			ld de, prompt 
1f76			 
1f76 cd ba 0d				call str_at_display 
1f79 cd ca 0d			call update_display 
1f7c			 
1f7c 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1f7e 16 0a			ld d, 10 
1f80 21 fc f0			ld hl, scratch	 
1f83 cd 08 10			call input_str 
1f86			 
1f86			;	call clear_display 
1f86			;'	call update_display 
1f86			 
1f86 3e 00		            LD   A, display_row_1 
1f88			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f88 11 46 1f		            LD   DE, clear 
1f8b cd ba 0d				call str_at_display 
1f8e			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f8e 3e 00		            LD   A, display_row_1 
1f90			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f90 11 fc f0		            LD   DE, scratch 
1f93			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f93 cd ba 0d				call str_at_display 
1f96 cd ca 0d			call update_display 
1f99			 
1f99 3e 00				ld a,0 
1f9b 21 fc f0			ld hl, scratch 
1f9e 77				ld (hl),a 
1f9f			 
1f9f 00				nop 
1fa0 c3 69 1f			jp cloop 
1fa3			 
1fa3			 
1fa3			 
1fa3			; OS Prompt 
1fa3			 
1fa3 .. 00		prompt: db ">",0 
1fa5 .. 00		endprg: db "?",0 
1fa7			 
1fa7			 
1fa7			; handy next page prompt 
1fa7			next_page_prompt: 
1fa7 e5				push hl 
1fa8 d5				push de 
1fa9 f5				push af 
1faa c5				push bc 
1fab			 
1fab 3e 9f			ld a,display_row_4 + display_cols - 1 
1fad 11 a5 1f		        ld de, endprg 
1fb0 cd ba 0d			call str_at_display 
1fb3 cd ca 0d			call update_display 
1fb6 cd bf 72			call cin_wait 
1fb9 c1				pop bc 
1fba f1				pop af 
1fbb d1				pop de 
1fbc e1				pop hl 
1fbd			 
1fbd			 
1fbd c9				ret 
1fbe			 
1fbe			 
1fbe			; forth parser 
1fbe			 
1fbe			; My forth kernel 
1fbe			include "forth_kernel.asm" 
1fbe			; 
1fbe			; kernel to the forth OS 
1fbe			 
1fbe			DS_TYPE_STR: equ 1     ; string type 
1fbe			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1fbe			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1fbe			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1fbe			 
1fbe			FORTH_PARSEV1: equ 0 
1fbe			FORTH_PARSEV2: equ 0 
1fbe			FORTH_PARSEV3: equ 0 
1fbe			FORTH_PARSEV4: equ 0 
1fbe			FORTH_PARSEV5: equ 1 
1fbe			 
1fbe			;if FORTH_PARSEV5 
1fbe			;	FORTH_END_BUFFER: equ 0 
1fbe			;else 
1fbe			FORTH_END_BUFFER: equ 127 
1fbe			;endif 
1fbe			 
1fbe			FORTH_TRUE: equ 1 
1fbe			FORTH_FALSE: equ 0 
1fbe			 
1fbe			if FORTH_PARSEV4 
1fbe			include "forth_stackops.asm" 
1fbe			endif 
1fbe			 
1fbe			if FORTH_PARSEV5 
1fbe			include "forth_stackopsv5.asm" 
1fbe			 
1fbe			; Stack operations for v5 parser on wards 
1fbe			; * DATA stack 
1fbe			; * LOOP stack 
1fbe			; * RETURN stack 
1fbe			 
1fbe			 
1fbe			 
1fbe			FORTH_CHK_DSP_UNDER: macro 
1fbe				push hl 
1fbe				push de 
1fbe				ld hl,(cli_data_sp) 
1fbe				ld de, cli_data_stack 
1fbe				call cmp16 
1fbe				jp c, fault_dsp_under 
1fbe				pop de 
1fbe				pop hl 
1fbe				endm 
1fbe			 
1fbe			 
1fbe			FORTH_CHK_RSP_UNDER: macro 
1fbe				push hl 
1fbe				push de 
1fbe				ld hl,(cli_ret_sp) 
1fbe				ld de, cli_ret_stack 
1fbe				call cmp16 
1fbe				jp c, fault_rsp_under 
1fbe				pop de 
1fbe				pop hl 
1fbe				endm 
1fbe			 
1fbe			FORTH_CHK_LOOP_UNDER: macro 
1fbe				push hl 
1fbe				push de 
1fbe				ld hl,(cli_loop_sp) 
1fbe				ld de, cli_loop_stack 
1fbe				call cmp16 
1fbe				jp c, fault_loop_under 
1fbe				pop de 
1fbe				pop hl 
1fbe				endm 
1fbe			 
1fbe			FORTH_ERR_TOS_NOTSTR: macro 
1fbe				; TOSO might need more for checks when used 
1fbe				push af 
1fbe				ld a,(hl) 
1fbe				cp DS_TYPE_STR 
1fbe				jp nz, type_faultn   
1fbe				pop af 
1fbe				endm 
1fbe			 
1fbe			FORTH_ERR_TOS_NOTNUM: macro 
1fbe				push af 
1fbe				ld a,(hl) 
1fbe				cp DS_TYPE_INUM 
1fbe				jp nz, type_faultn   
1fbe				pop af 
1fbe				endm 
1fbe			 
1fbe			 
1fbe			; increase data stack pointer and save hl to it 
1fbe				 
1fbe			FORTH_DSP_NEXT: macro 
1fbe				call macro_forth_dsp_next 
1fbe				endm 
1fbe			 
1fbe			 
1fbe			macro_forth_dsp_next: 
1fbe				if DEBUG_FORTH_STACK_GUARD 
1fbe cd 63 6b				call check_stacks 
1fc1				endif 
1fc1 e5				push hl 
1fc2 d5				push de 
1fc3 eb				ex de,hl 
1fc4 2a 29 f9			ld hl,(cli_data_sp) 
1fc7 23				inc hl 
1fc8 23				inc hl 
1fc9			 
1fc9			; PARSEV5 
1fc9 23				inc hl 
1fca 22 29 f9			ld (cli_data_sp),hl 
1fcd 73				ld (hl), e 
1fce 23				inc hl 
1fcf 72				ld (hl), d 
1fd0 d1				pop de 
1fd1 e1				pop hl 
1fd2				if DEBUG_FORTH_STACK_GUARD 
1fd2 cd 63 6b				call check_stacks 
1fd5				endif 
1fd5 c9				ret 
1fd6			 
1fd6			 
1fd6			; increase ret stack pointer and save hl to it 
1fd6				 
1fd6			FORTH_RSP_NEXT: macro 
1fd6				call macro_forth_rsp_next 
1fd6				endm 
1fd6			 
1fd6			macro_forth_rsp_next: 
1fd6				if DEBUG_FORTH_STACK_GUARD 
1fd6 cd 63 6b				call check_stacks 
1fd9				endif 
1fd9 e5				push hl 
1fda d5				push de 
1fdb eb				ex de,hl 
1fdc 2a 2d f9			ld hl,(cli_ret_sp) 
1fdf 23				inc hl 
1fe0 23				inc hl 
1fe1 22 2d f9			ld (cli_ret_sp),hl 
1fe4 73				ld (hl), e 
1fe5 23				inc hl 
1fe6 72				ld (hl), d 
1fe7 d1				pop de 
1fe8 e1				pop hl 
1fe9				if DEBUG_FORTH_STACK_GUARD 
1fe9 cd 63 6b				call check_stacks 
1fec				endif 
1fec c9				ret 
1fed			 
1fed			; get current ret stack pointer and save to hl  
1fed				 
1fed			FORTH_RSP_TOS: macro 
1fed				call macro_forth_rsp_tos 
1fed				endm 
1fed			 
1fed			macro_forth_rsp_tos: 
1fed				;push de 
1fed 2a 2d f9			ld hl,(cli_ret_sp) 
1ff0 cd 28 20			call loadhlptrtohl 
1ff3				;ld e, (hl) 
1ff3				;inc hl 
1ff3				;ld d, (hl) 
1ff3				;ex de, hl 
1ff3					if DEBUG_FORTH_WORDS 
1ff3			;			DMARK "RST" 
1ff3						CALLMONITOR 
1ff3 cd aa fd			call debug_vector  
1ff6				endm  
# End of macro CALLMONITOR
1ff6					endif 
1ff6				;pop de 
1ff6 c9				ret 
1ff7			 
1ff7			; pop ret stack pointer 
1ff7				 
1ff7			FORTH_RSP_POP: macro 
1ff7				call macro_forth_rsp_pop 
1ff7				endm 
1ff7			 
1ff7			 
1ff7			macro_forth_rsp_pop: 
1ff7				if DEBUG_FORTH_STACK_GUARD 
1ff7			;		DMARK "RPP" 
1ff7 cd 63 6b				call check_stacks 
1ffa					FORTH_CHK_RSP_UNDER 
1ffa e5				push hl 
1ffb d5				push de 
1ffc 2a 2d f9			ld hl,(cli_ret_sp) 
1fff 11 e7 f8			ld de, cli_ret_stack 
2002 cd f9 0f			call cmp16 
2005 da 7a 6c			jp c, fault_rsp_under 
2008 d1				pop de 
2009 e1				pop hl 
200a				endm 
# End of macro FORTH_CHK_RSP_UNDER
200a				endif 
200a e5				push hl 
200b 2a 2d f9			ld hl,(cli_ret_sp) 
200e			 
200e			 
200e				if FORTH_ENABLE_FREE 
200e			 
200e					; get pointer 
200e			 
200e					push de 
200e					push hl 
200e			 
200e					ld e, (hl) 
200e					inc hl 
200e					ld d, (hl) 
200e			 
200e					ex de, hl 
200e					call free 
200e			 
200e					pop hl 
200e					pop de 
200e			 
200e			 
200e				endif 
200e			 
200e			 
200e 2b				dec hl 
200f 2b				dec hl 
2010 22 2d f9			ld (cli_ret_sp), hl 
2013				; do stack underflow checks 
2013 e1				pop hl 
2014				if DEBUG_FORTH_STACK_GUARD 
2014 cd 63 6b				call check_stacks 
2017					FORTH_CHK_RSP_UNDER 
2017 e5				push hl 
2018 d5				push de 
2019 2a 2d f9			ld hl,(cli_ret_sp) 
201c 11 e7 f8			ld de, cli_ret_stack 
201f cd f9 0f			call cmp16 
2022 da 7a 6c			jp c, fault_rsp_under 
2025 d1				pop de 
2026 e1				pop hl 
2027				endm 
# End of macro FORTH_CHK_RSP_UNDER
2027				endif 
2027 c9				ret 
2028			 
2028			 
2028			 
2028			; routine to load word pointed to by hl into hl 
2028			 
2028			loadhlptrtohl: 
2028			 
2028 d5				push de 
2029 5e				ld e, (hl) 
202a 23				inc hl 
202b 56				ld d, (hl) 
202c eb				ex de, hl 
202d d1				pop de 
202e			 
202e c9				ret 
202f			 
202f			 
202f			 
202f			 
202f			 
202f			; push a number held in HL onto the data stack 
202f			; entry point for pushing a value when already in hl used in function above 
202f			 
202f			forth_push_numhl: 
202f			 
202f e5				push hl    ; save value to push 
2030			 
2030			if DEBUG_FORTH_PUSH 
2030				; see if disabled 
2030			 
2030			 
2030 f5				push af 
2031 3a aa fd			ld a,(debug_vector) 
2034 fe c9			cp $c9   ; ret 
2036			;	ld a, (os_view_disable) 
2036			;	cp '*' 
2036 28 34			jr z, .pskip2 
2038 e5				push hl 
2039 e5			push hl 
203a cd a7 0d			call clear_display 
203d e1			pop hl 
203e 7c				ld a,h 
203f 21 01 f4			ld hl, os_word_scratch 
2042 cd e4 11			call hexout 
2045 e1				pop hl 
2046 7d				ld a,l 
2047 21 03 f4			ld hl, os_word_scratch+2 
204a cd e4 11			call hexout 
204d			 
204d 21 05 f4			ld hl, os_word_scratch+4 
2050 3e 00			ld a,0 
2052 77				ld (hl),a 
2053 11 01 f4			ld de,os_word_scratch 
2056 3e 28				ld a, display_row_2 
2058 cd ba 0d				call str_at_display 
205b 11 71 5d			ld de, .push_num 
205e 3e 00			ld a, display_row_1 
2060			 
2060 cd ba 0d				call str_at_display 
2063			 
2063			 
2063 cd ca 0d			call update_display 
2066 cd ea 0c			call delay1s 
2069 cd ea 0c			call delay1s 
206c			.pskip2:  
206c			 
206c f1				pop af 
206d			endif	 
206d			 
206d			 
206d				FORTH_DSP_NEXT 
206d cd be 1f			call macro_forth_dsp_next 
2070				endm 
# End of macro FORTH_DSP_NEXT
2070			 
2070 2a 29 f9			ld hl, (cli_data_sp) 
2073			 
2073				; save item type 
2073 3e 02			ld a,  DS_TYPE_INUM 
2075 77				ld (hl), a 
2076 23				inc hl 
2077			 
2077				; get word off stack 
2077 d1				pop de 
2078 7b				ld a,e 
2079 77				ld (hl), a 
207a 23				inc hl 
207b 7a				ld a,d 
207c 77				ld (hl), a 
207d			 
207d			if DEBUG_FORTH_PUSH 
207d 2b				dec hl 
207e 2b				dec hl 
207f 2b				dec hl 
2080						DMARK "PH5" 
2080 f5				push af  
2081 3a 95 20			ld a, (.dmark)  
2084 32 a6 fd			ld (debug_mark),a  
2087 3a 96 20			ld a, (.dmark+1)  
208a 32 a7 fd			ld (debug_mark+1),a  
208d 3a 97 20			ld a, (.dmark+2)  
2090 32 a8 fd			ld (debug_mark+2),a  
2093 18 03			jr .pastdmark  
2095 ..			.dmark: db "PH5"  
2098 f1			.pastdmark: pop af  
2099			endm  
# End of macro DMARK
2099				CALLMONITOR 
2099 cd aa fd			call debug_vector  
209c				endm  
# End of macro CALLMONITOR
209c			endif	 
209c			 
209c c9				ret 
209d			 
209d			 
209d			; Push a string to stack pointed to by hl 
209d			 
209d			forth_push_str: 
209d			 
209d			if DEBUG_FORTH_PUSH 
209d						DMARK "PSQ" 
209d f5				push af  
209e 3a b2 20			ld a, (.dmark)  
20a1 32 a6 fd			ld (debug_mark),a  
20a4 3a b3 20			ld a, (.dmark+1)  
20a7 32 a7 fd			ld (debug_mark+1),a  
20aa 3a b4 20			ld a, (.dmark+2)  
20ad 32 a8 fd			ld (debug_mark+2),a  
20b0 18 03			jr .pastdmark  
20b2 ..			.dmark: db "PSQ"  
20b5 f1			.pastdmark: pop af  
20b6			endm  
# End of macro DMARK
20b6				CALLMONITOR 
20b6 cd aa fd			call debug_vector  
20b9				endm  
# End of macro CALLMONITOR
20b9			endif	 
20b9			 
20b9			 
20b9			    
20b9 e5				push hl 
20ba e5				push hl 
20bb			 
20bb			;	ld a, 0   ; find end of string 
20bb cd 41 13			call strlenz 
20be			if DEBUG_FORTH_PUSH 
20be						DMARK "PQ2" 
20be f5				push af  
20bf 3a d3 20			ld a, (.dmark)  
20c2 32 a6 fd			ld (debug_mark),a  
20c5 3a d4 20			ld a, (.dmark+1)  
20c8 32 a7 fd			ld (debug_mark+1),a  
20cb 3a d5 20			ld a, (.dmark+2)  
20ce 32 a8 fd			ld (debug_mark+2),a  
20d1 18 03			jr .pastdmark  
20d3 ..			.dmark: db "PQ2"  
20d6 f1			.pastdmark: pop af  
20d7			endm  
# End of macro DMARK
20d7				CALLMONITOR 
20d7 cd aa fd			call debug_vector  
20da				endm  
# End of macro CALLMONITOR
20da			endif	 
20da eb				ex de, hl 
20db e1				pop hl   ; get ptr to start of string 
20dc			if DEBUG_FORTH_PUSH 
20dc						DMARK "PQ3" 
20dc f5				push af  
20dd 3a f1 20			ld a, (.dmark)  
20e0 32 a6 fd			ld (debug_mark),a  
20e3 3a f2 20			ld a, (.dmark+1)  
20e6 32 a7 fd			ld (debug_mark+1),a  
20e9 3a f3 20			ld a, (.dmark+2)  
20ec 32 a8 fd			ld (debug_mark+2),a  
20ef 18 03			jr .pastdmark  
20f1 ..			.dmark: db "PQ3"  
20f4 f1			.pastdmark: pop af  
20f5			endm  
# End of macro DMARK
20f5				CALLMONITOR 
20f5 cd aa fd			call debug_vector  
20f8				endm  
# End of macro CALLMONITOR
20f8			endif	 
20f8 19				add hl,de 
20f9			if DEBUG_FORTH_PUSH 
20f9						DMARK "PQE" 
20f9 f5				push af  
20fa 3a 0e 21			ld a, (.dmark)  
20fd 32 a6 fd			ld (debug_mark),a  
2100 3a 0f 21			ld a, (.dmark+1)  
2103 32 a7 fd			ld (debug_mark+1),a  
2106 3a 10 21			ld a, (.dmark+2)  
2109 32 a8 fd			ld (debug_mark+2),a  
210c 18 03			jr .pastdmark  
210e ..			.dmark: db "PQE"  
2111 f1			.pastdmark: pop af  
2112			endm  
# End of macro DMARK
2112				CALLMONITOR 
2112 cd aa fd			call debug_vector  
2115				endm  
# End of macro CALLMONITOR
2115			endif	 
2115			 
2115 2b				dec hl    ; see if there is an optional trailing double quote 
2116 7e				ld a,(hl) 
2117 fe 22			cp '"' 
2119 20 03			jr nz, .strnoq 
211b 3e 00			ld a, 0      ; get rid of double quote 
211d 77				ld (hl), a 
211e 23			.strnoq: inc hl 
211f			 
211f 3e 00			ld a, 0 
2121 77				ld (hl), a     ; add null term and get rid of trailing double quote 
2122			 
2122 13				inc de ; add one for the type string 
2123 13				inc de ; add one for null term??? 
2124			 
2124				; tos is get string pointer again 
2124				; de contains space to allocate 
2124				 
2124 d5				push de 
2125			 
2125 eb				ex de, hl 
2126			 
2126				;push af 
2126			 
2126			if DEBUG_FORTH_PUSH 
2126						DMARK "PHm" 
2126 f5				push af  
2127 3a 3b 21			ld a, (.dmark)  
212a 32 a6 fd			ld (debug_mark),a  
212d 3a 3c 21			ld a, (.dmark+1)  
2130 32 a7 fd			ld (debug_mark+1),a  
2133 3a 3d 21			ld a, (.dmark+2)  
2136 32 a8 fd			ld (debug_mark+2),a  
2139 18 03			jr .pastdmark  
213b ..			.dmark: db "PHm"  
213e f1			.pastdmark: pop af  
213f			endm  
# End of macro DMARK
213f				CALLMONITOR 
213f cd aa fd			call debug_vector  
2142				endm  
# End of macro CALLMONITOR
2142			endif	 
2142 cd b6 13			call malloc	; on ret hl now contains allocated memory 
2145				if DEBUG_FORTH_MALLOC_GUARD 
2145 cc c9 5d				call z,malloc_error 
2148				endif 
2148			 
2148				 
2148 c1				pop bc    ; get length 
2149 d1				pop de   ;  get string start    
214a			 
214a				; hl has destination from malloc 
214a			 
214a eb				ex de, hl    ; prep for ldir 
214b			 
214b d5				push de   ; save malloc area for DSP later 
214c				;push hl   ; save malloc area for DSP later 
214c			 
214c			if DEBUG_FORTH_PUSH 
214c						DMARK "PHc" 
214c f5				push af  
214d 3a 61 21			ld a, (.dmark)  
2150 32 a6 fd			ld (debug_mark),a  
2153 3a 62 21			ld a, (.dmark+1)  
2156 32 a7 fd			ld (debug_mark+1),a  
2159 3a 63 21			ld a, (.dmark+2)  
215c 32 a8 fd			ld (debug_mark+2),a  
215f 18 03			jr .pastdmark  
2161 ..			.dmark: db "PHc"  
2164 f1			.pastdmark: pop af  
2165			endm  
# End of macro DMARK
2165				CALLMONITOR 
2165 cd aa fd			call debug_vector  
2168				endm  
# End of macro CALLMONITOR
2168			endif	 
2168			 
2168			 
2168 ed b0			ldir 
216a			 
216a			 
216a				; push malloc to data stack     macro?????  
216a			 
216a				FORTH_DSP_NEXT 
216a cd be 1f			call macro_forth_dsp_next 
216d				endm 
# End of macro FORTH_DSP_NEXT
216d			 
216d				; save value and type 
216d			 
216d 2a 29 f9			ld hl, (cli_data_sp) 
2170			 
2170				; save item type 
2170 3e 01			ld a,  DS_TYPE_STR 
2172 77				ld (hl), a 
2173 23				inc hl 
2174			 
2174				; get malloc word off stack 
2174 d1				pop de 
2175 73				ld (hl), e 
2176 23				inc hl 
2177 72				ld (hl), d 
2178			 
2178			 
2178			 
2178			if DEBUG_FORTH_PUSH 
2178 2a 29 f9			ld hl, (cli_data_sp) 
217b						DMARK "PHS" 
217b f5				push af  
217c 3a 90 21			ld a, (.dmark)  
217f 32 a6 fd			ld (debug_mark),a  
2182 3a 91 21			ld a, (.dmark+1)  
2185 32 a7 fd			ld (debug_mark+1),a  
2188 3a 92 21			ld a, (.dmark+2)  
218b 32 a8 fd			ld (debug_mark+2),a  
218e 18 03			jr .pastdmark  
2190 ..			.dmark: db "PHS"  
2193 f1			.pastdmark: pop af  
2194			endm  
# End of macro DMARK
2194				CALLMONITOR 
2194 cd aa fd			call debug_vector  
2197				endm  
# End of macro CALLMONITOR
2197			;	ex de,hl 
2197			endif	 
2197				; in case of spaces, skip the ptr past the copied string 
2197				;pop af 
2197				;ld (cli_origptr),hl 
2197			 
2197 c9				ret 
2198			 
2198			 
2198			 
2198			; TODO ascii push input onto stack given hl to start of input 
2198			 
2198			; identify type 
2198			; if starts with a " then a string 
2198			; otherwise it is a number 
2198			;  
2198			; if a string 
2198			;     scan for ending " to get length of string to malloc for + 1 
2198			;     malloc 
2198			;     put pointer to string on stack first byte flags as string 
2198			; 
2198			; else a number 
2198			;    look for number format identifier 
2198			;    $xx hex 
2198			;    %xxxxx bin 
2198			;    xxxxx decimal 
2198			;    convert number to 16bit word.  
2198			;    malloc word + 1 with flag to identiy as num 
2198			;    put pointer to number on stack 
2198			;   
2198			;  
2198			  
2198			forth_apush: 
2198				; kernel push 
2198			 
2198			if DEBUG_FORTH_PUSH 
2198						DMARK "PSH" 
2198 f5				push af  
2199 3a ad 21			ld a, (.dmark)  
219c 32 a6 fd			ld (debug_mark),a  
219f 3a ae 21			ld a, (.dmark+1)  
21a2 32 a7 fd			ld (debug_mark+1),a  
21a5 3a af 21			ld a, (.dmark+2)  
21a8 32 a8 fd			ld (debug_mark+2),a  
21ab 18 03			jr .pastdmark  
21ad ..			.dmark: db "PSH"  
21b0 f1			.pastdmark: pop af  
21b1			endm  
# End of macro DMARK
21b1				CALLMONITOR 
21b1 cd aa fd			call debug_vector  
21b4				endm  
# End of macro CALLMONITOR
21b4			endif	 
21b4				; identify input type 
21b4			 
21b4 7e				ld a,(hl) 
21b5			 
21b5 fe 23			cp '#' 
21b7 ca f1 21			jp z, .fapdec 
21ba			 
21ba			 
21ba fe 22			cp '"' 
21bc 28 0a			jr z, .fapstr 
21be fe 24			cp '$' 
21c0 ca e8 21			jp z, .faphex 
21c3 fe 25			cp '%' 
21c5 ca d0 21			jp z, .fapbin 
21c8			;	cp 'b' 
21c8			;	jp z, .fabin 
21c8				; else decimal 
21c8			 
21c8				; TODO do decimal conversion 
21c8				; decimal is stored as a 16bit word 
21c8			 
21c8				; by default everything is a string if type is not detected 
21c8			.fapstr: ; 
21c8 fe 22			cp '"' 
21ca 20 01			jr nz, .strnoqu 
21cc 23				inc hl 
21cd			.strnoqu: 
21cd c3 9d 20			jp forth_push_str 
21d0			 
21d0			 
21d0			 
21d0			.fapbin:    ; push a binary string.  
21d0 11 00 00			ld de, 0   ; hold a 16bit value 
21d3			 
21d3 23			.fapbinshift:	inc hl  
21d4 7e				ld a,(hl) 
21d5 fe 00			cp 0     ; done scanning  
21d7 28 0b			jr z, .fapbdone  	; got it in HL so push  
21d9			 
21d9				; left shift de 
21d9 eb				ex de, hl	 
21da 29				add hl, hl 
21db			 
21db				; is 1 
21db fe 31			cp '1' 
21dd 20 02			jr nz, .binzero 
21df cb 4d			bit 1, l 
21e1			.binzero: 
21e1 eb				ex de, hl	 ; save current de 
21e2 18 ef			jr .fapbinshift 
21e4			 
21e4			.fapbdone: 
21e4 eb				ex de, hl 
21e5 c3 2f 20			jp forth_push_numhl 
21e8			 
21e8			 
21e8			.faphex:   ; hex is always stored as a 16bit word 
21e8				; skip number prefix 
21e8 23				inc hl 
21e9				; turn ascii into number 
21e9 cd 9a 12			call get_word_hl	; ret 16bit word in hl 
21ec			 
21ec c3 2f 20			jp forth_push_numhl 
21ef			 
21ef 00				 nop 
21f0			 
21f0			.fabin:   ; TODO bin conversion 
21f0			 
21f0			 
21f0 c9				ret 
21f1			.fapdec:	 
21f1				; string to dec conversion 
21f1 23				inc hl 
21f2 eb				ex de, hl 
21f3 cd d8 12			call string_to_uint16 
21f6 c3 2f 20			jp forth_push_numhl 
21f9 c9				ret 
21fa				 
21fa			;atoui_16: 
21fa			 
21fa			; get either a string ptr or a 16bit word from the data stack 
21fa			 
21fa			FORTH_DSP: macro 
21fa				call macro_forth_dsp 
21fa				endm 
21fa			 
21fa			macro_forth_dsp: 
21fa				; data stack pointer points to current word on tos 
21fa			 
21fa 2a 29 f9			ld hl,(cli_data_sp) 
21fd			 
21fd				if DEBUG_FORTH_PUSH 
21fd						DMARK "DSP" 
21fd f5				push af  
21fe 3a 12 22			ld a, (.dmark)  
2201 32 a6 fd			ld (debug_mark),a  
2204 3a 13 22			ld a, (.dmark+1)  
2207 32 a7 fd			ld (debug_mark+1),a  
220a 3a 14 22			ld a, (.dmark+2)  
220d 32 a8 fd			ld (debug_mark+2),a  
2210 18 03			jr .pastdmark  
2212 ..			.dmark: db "DSP"  
2215 f1			.pastdmark: pop af  
2216			endm  
# End of macro DMARK
2216			 
2216 cd fc 5d				call display_data_sp 
2219				;call break_point_state 
2219				;rst 030h 
2219				CALLMONITOR 
2219 cd aa fd			call debug_vector  
221c				endm  
# End of macro CALLMONITOR
221c				endif 
221c			 
221c c9				ret 
221d			 
221d			; return hl to start of value on stack 
221d			 
221d			FORTH_DSP_VALUE: macro 
221d				call macro_forth_dsp_value 
221d				endm 
221d			 
221d			macro_forth_dsp_value: 
221d			 
221d				FORTH_DSP 
221d cd fa 21			call macro_forth_dsp 
2220				endm 
# End of macro FORTH_DSP
2220			 
2220 d5				push de 
2221			 
2221 23				inc hl ; skip type 
2222			 
2222 5e				ld e, (hl) 
2223 23				inc hl 
2224 56				ld d, (hl) 
2225 eb				ex de,hl  
2226			 
2226 d1				pop de 
2227			 
2227 c9				ret 
2228			 
2228			; return hl to start of value to second item on stack 
2228			 
2228			FORTH_DSP_VALUEM1: macro 
2228				call macro_forth_dsp_value_m1 
2228				endm 
2228			 
2228			macro_forth_dsp_value_m1: 
2228			 
2228				FORTH_DSP 
2228 cd fa 21			call macro_forth_dsp 
222b				endm 
# End of macro FORTH_DSP
222b			 
222b 2b				dec hl 
222c 2b				dec hl 
222d			;	dec hl 
222d			 
222d d5				push de 
222e			 
222e 5e				ld e, (hl) 
222f 23				inc hl 
2230 56				ld d, (hl) 
2231 eb				ex de,hl  
2232			 
2232 d1				pop de 
2233			 
2233 c9				ret 
2234			 
2234				 
2234			 
2234			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
2234			 
2234			FORTH_DSP_POP: macro 
2234				call macro_forth_dsp_pop 
2234				endm 
2234			 
2234			 
2234			; get the tos data type 
2234			 
2234			FORTH_DSP_TYPE:   macro 
2234			 
2234				;FORTH_DSP_VALUE 
2234				FORTH_DSP 
2234				 
2234				; hl points to value 
2234				; check type 
2234			 
2234				ld a,(hl) 
2234			 
2234				endm 
2234			 
2234			; load the tos value into hl 
2234			 
2234			 
2234			FORTH_DSP_VALUEHL:  macro 
2234				call macro_dsp_valuehl 
2234				endm 
2234			 
2234			 
2234			 
2234			macro_dsp_valuehl: 
2234				FORTH_DSP_VALUE 
2234 cd 1d 22			call macro_forth_dsp_value 
2237				endm 
# End of macro FORTH_DSP_VALUE
2237			 
2237				;FORTH_ERR_TOS_NOTNUM 
2237			 
2237				;inc hl   ; skip type id 
2237			 
2237			;	push de 
2237			; 
2237			;	ld e, (hl) 
2237			;	inc hl 
2237			;	ld d, (hl) 
2237			;	ex de,hl  
2237			 
2237			;	pop de 
2237			 
2237				if DEBUG_FORTH_PUSH 
2237						DMARK "DVL" 
2237 f5				push af  
2238 3a 4c 22			ld a, (.dmark)  
223b 32 a6 fd			ld (debug_mark),a  
223e 3a 4d 22			ld a, (.dmark+1)  
2241 32 a7 fd			ld (debug_mark+1),a  
2244 3a 4e 22			ld a, (.dmark+2)  
2247 32 a8 fd			ld (debug_mark+2),a  
224a 18 03			jr .pastdmark  
224c ..			.dmark: db "DVL"  
224f f1			.pastdmark: pop af  
2250			endm  
# End of macro DMARK
2250				CALLMONITOR 
2250 cd aa fd			call debug_vector  
2253				endm  
# End of macro CALLMONITOR
2253				endif 
2253 c9				ret 
2254			 
2254			forth_apushstrhl:      
2254				; push of string requires use of cli_origptr 
2254				; bodge use 
2254			 
2254				; get current cli_origptr, save, update with temp pointer  
2254 ed 5b 79 f9		ld de, (cli_origptr) 
2258 22 79 f9			ld (cli_origptr), hl 
225b d5				push de 
225c cd 98 21			call forth_apush 
225f d1				pop de 
2260 ed 53 79 f9		ld (cli_origptr), de 
2264 c9			        ret	 
2265			 
2265			 
2265			; increase loop stack pointer and save hl to it 
2265				 
2265			FORTH_LOOP_NEXT: macro 
2265				call macro_forth_loop_next 
2265				;nop 
2265				endm 
2265			 
2265			macro_forth_loop_next: 
2265				if DEBUG_FORTH_STACK_GUARD 
2265 cd 63 6b				call check_stacks 
2268				endif 
2268 e5				push hl 
2269 d5				push de 
226a eb				ex de,hl 
226b 2a 2b f9			ld hl,(cli_loop_sp) 
226e 23				inc hl 
226f 23				inc hl 
2270					if DEBUG_FORTH_WORDS 
2270						DMARK "LNX" 
2270 f5				push af  
2271 3a 85 22			ld a, (.dmark)  
2274 32 a6 fd			ld (debug_mark),a  
2277 3a 86 22			ld a, (.dmark+1)  
227a 32 a7 fd			ld (debug_mark+1),a  
227d 3a 87 22			ld a, (.dmark+2)  
2280 32 a8 fd			ld (debug_mark+2),a  
2283 18 03			jr .pastdmark  
2285 ..			.dmark: db "LNX"  
2288 f1			.pastdmark: pop af  
2289			endm  
# End of macro DMARK
2289						CALLMONITOR 
2289 cd aa fd			call debug_vector  
228c				endm  
# End of macro CALLMONITOR
228c					endif 
228c 22 2b f9			ld (cli_loop_sp),hl 
228f 73				ld (hl), e 
2290 23				inc hl 
2291 72				ld (hl), d 
2292 d1				pop de    ; been reversed so save a swap on restore 
2293 e1				pop hl 
2294				if DEBUG_FORTH_STACK_GUARD 
2294 cd 63 6b				call check_stacks 
2297				endif 
2297 c9				ret 
2298			 
2298			; get current ret stack pointer and save to hl  
2298				 
2298			FORTH_LOOP_TOS: macro 
2298				call macro_forth_loop_tos 
2298				endm 
2298			 
2298			macro_forth_loop_tos: 
2298 d5				push de 
2299 2a 2b f9			ld hl,(cli_loop_sp) 
229c 5e				ld e, (hl) 
229d 23				inc hl 
229e 56				ld d, (hl) 
229f eb				ex de, hl 
22a0 d1				pop de 
22a1 c9				ret 
22a2			 
22a2			; pop loop stack pointer 
22a2				 
22a2			FORTH_LOOP_POP: macro 
22a2				call macro_forth_loop_pop 
22a2				endm 
22a2			 
22a2			 
22a2			macro_forth_loop_pop: 
22a2				if DEBUG_FORTH_STACK_GUARD 
22a2					DMARK "LPP" 
22a2 f5				push af  
22a3 3a b7 22			ld a, (.dmark)  
22a6 32 a6 fd			ld (debug_mark),a  
22a9 3a b8 22			ld a, (.dmark+1)  
22ac 32 a7 fd			ld (debug_mark+1),a  
22af 3a b9 22			ld a, (.dmark+2)  
22b2 32 a8 fd			ld (debug_mark+2),a  
22b5 18 03			jr .pastdmark  
22b7 ..			.dmark: db "LPP"  
22ba f1			.pastdmark: pop af  
22bb			endm  
# End of macro DMARK
22bb cd 63 6b				call check_stacks 
22be					FORTH_CHK_LOOP_UNDER 
22be e5				push hl 
22bf d5				push de 
22c0 2a 2b f9			ld hl,(cli_loop_sp) 
22c3 11 65 f8			ld de, cli_loop_stack 
22c6 cd f9 0f			call cmp16 
22c9 da 80 6c			jp c, fault_loop_under 
22cc d1				pop de 
22cd e1				pop hl 
22ce				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22ce				endif 
22ce e5				push hl 
22cf 2a 2b f9			ld hl,(cli_loop_sp) 
22d2 2b				dec hl 
22d3 2b				dec hl 
22d4 22 2b f9			ld (cli_loop_sp), hl 
22d7				; TODO do stack underflow checks 
22d7 e1				pop hl 
22d8				if DEBUG_FORTH_STACK_GUARD 
22d8 cd 63 6b				call check_stacks 
22db					FORTH_CHK_LOOP_UNDER 
22db e5				push hl 
22dc d5				push de 
22dd 2a 2b f9			ld hl,(cli_loop_sp) 
22e0 11 65 f8			ld de, cli_loop_stack 
22e3 cd f9 0f			call cmp16 
22e6 da 80 6c			jp c, fault_loop_under 
22e9 d1				pop de 
22ea e1				pop hl 
22eb				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22eb				endif 
22eb c9				ret 
22ec			 
22ec			macro_forth_dsp_pop: 
22ec			 
22ec e5				push hl 
22ed			 
22ed				; release malloc data 
22ed			 
22ed				if DEBUG_FORTH_STACK_GUARD 
22ed cd 63 6b				call check_stacks 
22f0					FORTH_CHK_DSP_UNDER 
22f0 e5				push hl 
22f1 d5				push de 
22f2 2a 29 f9			ld hl,(cli_data_sp) 
22f5 11 63 f6			ld de, cli_data_stack 
22f8 cd f9 0f			call cmp16 
22fb da 74 6c			jp c, fault_dsp_under 
22fe d1				pop de 
22ff e1				pop hl 
2300				endm 
# End of macro FORTH_CHK_DSP_UNDER
2300				endif 
2300				;ld hl,(cli_data_sp) 
2300			if DEBUG_FORTH_DOT 
2300				DMARK "DPP" 
2300 f5				push af  
2301 3a 15 23			ld a, (.dmark)  
2304 32 a6 fd			ld (debug_mark),a  
2307 3a 16 23			ld a, (.dmark+1)  
230a 32 a7 fd			ld (debug_mark+1),a  
230d 3a 17 23			ld a, (.dmark+2)  
2310 32 a8 fd			ld (debug_mark+2),a  
2313 18 03			jr .pastdmark  
2315 ..			.dmark: db "DPP"  
2318 f1			.pastdmark: pop af  
2319			endm  
# End of macro DMARK
2319				CALLMONITOR 
2319 cd aa fd			call debug_vector  
231c				endm  
# End of macro CALLMONITOR
231c			endif	 
231c			 
231c			 
231c			if FORTH_ENABLE_DSPPOPFREE 
231c			 
231c				FORTH_DSP 
231c cd fa 21			call macro_forth_dsp 
231f				endm 
# End of macro FORTH_DSP
231f			 
231f 7e				ld a, (hl) 
2320 fe 01			cp DS_TYPE_STR 
2322 20 23			jr nz, .skippopfree 
2324			 
2324				FORTH_DSP_VALUEHL 
2324 cd 34 22			call macro_dsp_valuehl 
2327				endm 
# End of macro FORTH_DSP_VALUEHL
2327 00				nop 
2328			if DEBUG_FORTH_DOT 
2328				DMARK "DPf" 
2328 f5				push af  
2329 3a 3d 23			ld a, (.dmark)  
232c 32 a6 fd			ld (debug_mark),a  
232f 3a 3e 23			ld a, (.dmark+1)  
2332 32 a7 fd			ld (debug_mark+1),a  
2335 3a 3f 23			ld a, (.dmark+2)  
2338 32 a8 fd			ld (debug_mark+2),a  
233b 18 03			jr .pastdmark  
233d ..			.dmark: db "DPf"  
2340 f1			.pastdmark: pop af  
2341			endm  
# End of macro DMARK
2341				CALLMONITOR 
2341 cd aa fd			call debug_vector  
2344				endm  
# End of macro CALLMONITOR
2344			endif	 
2344 cd 80 14			call free 
2347			.skippopfree: 
2347				 
2347			 
2347			endif 
2347			 
2347			if DEBUG_FORTH_DOT_KEY 
2347				DMARK "DP2" 
2347				CALLMONITOR 
2347			endif	 
2347			 
2347				; move pointer down 
2347			 
2347 2a 29 f9			ld hl,(cli_data_sp) 
234a 2b				dec hl 
234b 2b				dec hl 
234c			; PARSEV5 
234c 2b				dec hl 
234d 22 29 f9			ld (cli_data_sp), hl 
2350			 
2350				if DEBUG_FORTH_STACK_GUARD 
2350 cd 63 6b				call check_stacks 
2353					FORTH_CHK_DSP_UNDER 
2353 e5				push hl 
2354 d5				push de 
2355 2a 29 f9			ld hl,(cli_data_sp) 
2358 11 63 f6			ld de, cli_data_stack 
235b cd f9 0f			call cmp16 
235e da 74 6c			jp c, fault_dsp_under 
2361 d1				pop de 
2362 e1				pop hl 
2363				endm 
# End of macro FORTH_CHK_DSP_UNDER
2363				endif 
2363			 
2363 e1				pop hl 
2364			 
2364 c9				ret 
2365			 
2365			getwordathl: 
2365				; hl points to an address 
2365				; load hl with the word at that address 
2365			 
2365 d5				push de 
2366			 
2366 5e				ld e, (hl) 
2367 23				inc hl 
2368 56				ld d, (hl) 
2369 eb				ex de, hl 
236a			 
236a d1				pop de 
236b c9				ret 
236c			 
236c			 
236c			 
236c			 
236c			 
236c			; eof 
236c			 
# End of file forth_stackopsv5.asm
236c			endif 
236c			 
236c			loadwordinhl:	 
236c			 
236c d5				push de 
236d			 
236d 5e				ld e, (hl) 
236e 23				inc hl 
236f 56				ld d, (hl) 
2370 eb				ex de,hl  
2371			 
2371 d1				pop de 
2372			 
2372 c9				ret 
2373			 
2373			user_word_eol:  
2373				; hl contains the pointer to where to create a linked list item from the end 
2373				; of the user dict to continue on at the system word dict 
2373				 
2373				; poke the stub of the word list linked list to repoint to rom words 
2373			 
2373				; stub format 
2373				; db   word id 
2373				; dw    link to next word 
2373			        ; db char length of token 
2373				; db string + 0 term 
2373				; db exec code....  
2373			 
2373 3e 00			ld a, WORD_SYS_ROOT     ; root word 
2375 77				ld (hl), a		; word id 
2376 23				inc hl 
2377			 
2377 11 42 25			ld de, sysdict 
237a 73				ld (hl), e		; next word link ie system dict 
237b 23				inc hl 
237c 72				ld (hl), d		; next word link ie system dict 
237d 23				inc hl	 
237e			 
237e			;	ld (hl), sysdict		; next word link ie system dict 
237e			;	inc hl 
237e			;	inc hl 
237e			 
237e			;	inc hl 
237e			;	inc hl 
237e			 
237e 3e 02			ld a, 2			; word length is 0 
2380 77				ld (hl), a	 
2381 23				inc hl 
2382			 
2382 3e 7e			ld a, '~'			; word length is 0 
2384 77				ld (hl), a	 
2385 23				inc hl 
2386 3e 00			ld a, 0			; save empty word 
2388 77				ld (hl), a 
2389			 
2389 c9				ret 
238a			 
238a				 
238a			 
238a			forthexec_cleanup: 
238a				FORTH_RSP_POP 
238a cd f7 1f			call macro_forth_rsp_pop 
238d				endm 
# End of macro FORTH_RSP_POP
238d c9				ret 
238e			 
238e			forth_call_hl: 
238e				; taking hl 
238e e5				push hl 
238f c9				ret 
2390			 
2390			; this is called to reset Forth system but keep existing uwords etc 
2390			 
2390			forth_warmstart: 
2390				; setup stack over/under flow checks 
2390				if DEBUG_FORTH_STACK_GUARD 
2390 cd 49 6b				call chk_stk_init 
2393				endif 
2393			 
2393				; init stack pointers  - * these stacks go upwards *  
2393 21 e7 f8			ld hl, cli_ret_stack 
2396 22 2d f9			ld (cli_ret_sp), hl	 
2399				; set bottom of stack 
2399 3e 00			ld a,0 
239b 77				ld (hl),a 
239c 23				inc hl 
239d 77				ld (hl),a 
239e			 
239e 21 63 f6			ld hl, cli_data_stack 
23a1 22 29 f9			ld (cli_data_sp), hl	 
23a4				; set bottom of stack 
23a4 3e 00			ld a,0 
23a6 77				ld (hl),a 
23a7 23				inc hl 
23a8 77				ld (hl),a 
23a9			 
23a9 21 65 f8			ld hl, cli_loop_stack 
23ac 22 2b f9			ld (cli_loop_sp), hl	 
23af				; set bottom of stack 
23af 3e 00			ld a,0 
23b1 77				ld (hl),a 
23b2 23				inc hl 
23b3 77				ld (hl),a 
23b4			 
23b4				; init extent of current open file 
23b4			 
23b4 3e 00			ld a, 0 
23b6 32 a5 f9			ld (store_openext), a 
23b9			 
23b9 c9				ret 
23ba			 
23ba			 
23ba			 
23ba			; Cold Start - this is called to setup the whole Forth system 
23ba			 
23ba			forth_init: 
23ba			 
23ba				; setup stack over/under flow checks 
23ba			 
23ba			;	if DEBUG_FORTH_STACK_GUARD 
23ba			;		call chk_stk_init 
23ba			;	endif 
23ba			 
23ba				; enable auto display updates (slow.....) 
23ba			 
23ba 3e 01			ld a, 1 
23bc 32 77 f9			ld (cli_autodisplay), a 
23bf			 
23bf				; if storage is in use disable long reads for now 
23bf 3e 00			ld a, 0 
23c1 32 b0 f9			ld (store_longread), a 
23c4			 
23c4			 
23c4				; show start up screen 
23c4			 
23c4 cd a7 0d			call clear_display 
23c7			 
23c7 3e 00			ld a,0 
23c9 32 99 f9			ld (f_cursor_ptr), a 
23cc			 
23cc				; set start of word list in start of ram - for use when creating user words 
23cc			 
23cc 21 00 80			ld hl, baseram 
23cf 22 f9 f3			ld (os_last_new_uword), hl 
23d2 cd 73 23			call user_word_eol 
23d5				 
23d5			;		call display_data_sp 
23d5			;		call next_page_prompt 
23d5			 
23d5			 
23d5			 
23d5			 
23d5 c9				ret 
23d6			 
23d6 .. 00		.bootforth: db " Forth Kernel Init ",0 
23ea			 
23ea			; TODO push to stack 
23ea			 
23ea			;  
23ea			 
23ea			if FORTH_PARSEV2 
23ea			 
23ea			 
23ea				include "forth_parserv2.asm" 
23ea			 
23ea			endif 
23ea			 
23ea			 
23ea			; parse cli version 1 
23ea			 
23ea			if FORTH_PARSEV1 
23ea			 
23ea			 
23ea			 
23ea			      include "forth_parserv1.asm" 
23ea			endif 
23ea				 
23ea			if FORTH_PARSEV3 
23ea			 
23ea			 
23ea			 
23ea			      include "forth_parserv3.asm" 
23ea				include "forth_wordsv3.asm" 
23ea			endif 
23ea			 
23ea			if FORTH_PARSEV4 
23ea			 
23ea			 
23ea			 
23ea			      include "forth_parserv4.asm" 
23ea				include "forth_wordsv4.asm" 
23ea			endif 
23ea			 
23ea			if FORTH_PARSEV5 
23ea			 
23ea			 
23ea			 
23ea			      include "forth_parserv5.asm" 
23ea			 
23ea			 
23ea			; A better parser without using malloc and string copies all over the place.  
23ea			; Exec in situ should be faster 
23ea			 
23ea			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
23ea			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
23ea			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
23ea			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
23ea			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
23ea			WORD_SYS_END: equ 0   ; Opcode for all user words 
23ea			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
23ea			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
23ea			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
23ea			 
23ea			; Core word preamble macro 
23ea			 
23ea			CWHEAD:   macro nxtword opcode lit len opflags 
23ea				db WORD_SYS_CORE+opcode             
23ea				; internal op code number 
23ea				dw nxtword            
23ea				; link to next dict word block 
23ea				db len + 1 
23ea				; literal length of dict word inc zero term 
23ea				db lit,0              
23ea				; literal dict word 
23ea			        ; TODO db opflags        
23ea				endm 
23ea			 
23ea			 
23ea			NEXTW: macro  
23ea				jp macro_next 
23ea				endm 
23ea			 
23ea			macro_next: 
23ea			if DEBUG_FORTH_PARSE_KEY 
23ea				DMARK "NXT" 
23ea				CALLMONITOR 
23ea			endif	 
23ea			;	inc hl  ; skip token null term  
23ea ed 4b 7b f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
23ee ed 5b 79 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
23f2 2a fd f3			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
23f5			if DEBUG_FORTH_PARSE_KEY 
23f5				DMARK "}AA" 
23f5				CALLMONITOR 
23f5			endif	 
23f5 c3 f8 24			jp execnext 
23f8				;jp exec1 
23f8			       
23f8			 
23f8			 
23f8			; Another go at the parser to compile  
23f8			 
23f8			 
23f8			; TODO rework parser to change all of the string words to byte tokens 
23f8			; TODO do a search for  
23f8			 
23f8			; TODO first run normal parser to zero term sections 
23f8			; TODO for each word do a token look up to get the op code 
23f8			; TODO need some means to flag to the exec that this is a byte code form    
23f8			 
23f8			 
23f8			forthcompile: 
23f8			 
23f8			; 
23f8			; line parse: 
23f8			;       parse raw input buffer 
23f8			;       tokenise the words 
23f8			;       malloc new copy (for looping etc) 
23f8			;       copy to malloc + current pc in line to start of string and add line term 
23f8			;       save on new rsp 
23f8			; 
23f8			 
23f8			; hl to point to the line to tokenise 
23f8			 
23f8			;	push hl 
23f8 22 fd f3			ld (os_tok_ptr), hl  ; save ptr to string 
23fb			 
23fb			;	ld a,0		; string term on input 
23fb			;	call strlent 
23fb			 
23fb			;	ld (os_tok_len), hl	 ; save string length 
23fb			 
23fb			;if DEBUG_FORTH_TOK 
23fb			;	ex de,hl		 
23fb			;endif 
23fb			 
23fb			;	pop hl 		; get back string pointer 
23fb			 
23fb			if DEBUG_FORTH_TOK 
23fb						DMARK "TOc" 
23fb				CALLMONITOR 
23fb			endif 
23fb 7e			.cptoken2:    ld a,(hl) 
23fc 23				inc hl 
23fd fe 7f			cp FORTH_END_BUFFER 
23ff 28 29			jr z, .cptokendone2 
2401 fe 00			cp 0 
2403 28 25			jr z, .cptokendone2 
2405 fe 22			cp '"' 
2407 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2409 fe 20			cp ' ' 
240b 20 ee			jr nz,  .cptoken2 
240d			 
240d			; TODO consume comments held between ( and ) 
240d			 
240d				; we have a space so change to zero term for dict match later 
240d 2b				dec hl 
240e 3e 00			ld a,0 
2410 77				ld (hl), a 
2411 23				inc hl 
2412 18 e7			jr .cptoken2 
2414				 
2414			 
2414			.cptokenstr2: 
2414				; skip all white space until either eol (because forgot to term) or end double quote 
2414			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2414				;inc hl ; skip current double quote 
2414 7e				ld a,(hl) 
2415 23				inc hl 
2416 fe 22			cp '"' 
2418 28 e1			jr z, .cptoken2 
241a fe 7f			cp FORTH_END_BUFFER 
241c 28 0c			jr z, .cptokendone2 
241e fe 00			cp 0 
2420 28 08			jr z, .cptokendone2 
2422 fe 20			cp ' ' 
2424 28 02			jr z, .cptmp2 
2426 18 ec			jr .cptokenstr2 
2428			 
2428			.cptmp2:	; we have a space so change to zero term for dict match later 
2428				;dec hl 
2428				;ld a,"-"	; TODO remove this when working 
2428				;ld (hl), a 
2428				;inc hl 
2428 18 ea			jr .cptokenstr2 
242a			 
242a			.cptokendone2: 
242a				;inc hl 
242a 3e 7f			ld a, FORTH_END_BUFFER 
242c 77				ld (hl),a 
242d 23				inc hl 
242e 3e 21			ld a, '!' 
2430 77				ld (hl),a 
2431			 
2431 2a fd f3			ld hl,(os_tok_ptr) 
2434			         
2434			if DEBUG_FORTH_TOK 
2434						DMARK "Tc1" 
2434				CALLMONITOR 
2434			endif 
2434			 
2434				; push exec string to top of return stack 
2434				FORTH_RSP_NEXT 
2434 cd d6 1f			call macro_forth_rsp_next 
2437				endm 
# End of macro FORTH_RSP_NEXT
2437 c9				ret 
2438			 
2438			; Another go at the parser need to simplify the process 
2438			 
2438			forthparse: 
2438			 
2438			; 
2438			; line parse: 
2438			;       parse raw input buffer 
2438			;       tokenise the words 
2438			;       malloc new copy (for looping etc) 
2438			;       copy to malloc + current pc in line to start of string and add line term 
2438			;       save on new rsp 
2438			; 
2438			 
2438			; hl to point to the line to tokenise 
2438			 
2438			;	push hl 
2438 22 fd f3			ld (os_tok_ptr), hl  ; save ptr to string 
243b			 
243b			;	ld a,0		; string term on input 
243b			;	call strlent 
243b			 
243b			;	ld (os_tok_len), hl	 ; save string length 
243b			 
243b			;if DEBUG_FORTH_TOK 
243b			;	ex de,hl		 
243b			;endif 
243b			 
243b			;	pop hl 		; get back string pointer 
243b			 
243b			if DEBUG_FORTH_TOK 
243b						DMARK "TOK" 
243b				CALLMONITOR 
243b			endif 
243b 7e			.ptoken2:    ld a,(hl) 
243c 23				inc hl 
243d fe 7f			cp FORTH_END_BUFFER 
243f 28 29			jr z, .ptokendone2 
2441 fe 00			cp 0 
2443 28 25			jr z, .ptokendone2 
2445 fe 22			cp '"' 
2447 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2449 fe 20			cp ' ' 
244b 20 ee			jr nz,  .ptoken2 
244d			 
244d			; TODO consume comments held between ( and ) 
244d			 
244d				; we have a space so change to zero term for dict match later 
244d 2b				dec hl 
244e 3e 00			ld a,0 
2450 77				ld (hl), a 
2451 23				inc hl 
2452 18 e7			jr .ptoken2 
2454				 
2454			 
2454			.ptokenstr2: 
2454				; skip all white space until either eol (because forgot to term) or end double quote 
2454			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2454				;inc hl ; skip current double quote 
2454 7e				ld a,(hl) 
2455 23				inc hl 
2456 fe 22			cp '"' 
2458 28 e1			jr z, .ptoken2 
245a fe 7f			cp FORTH_END_BUFFER 
245c 28 0c			jr z, .ptokendone2 
245e fe 00			cp 0 
2460 28 08			jr z, .ptokendone2 
2462 fe 20			cp ' ' 
2464 28 02			jr z, .ptmp2 
2466 18 ec			jr .ptokenstr2 
2468			 
2468			.ptmp2:	; we have a space so change to zero term for dict match later 
2468				;dec hl 
2468				;ld a,"-"	; TODO remove this when working 
2468				;ld (hl), a 
2468				;inc hl 
2468 18 ea			jr .ptokenstr2 
246a			 
246a			.ptokendone2: 
246a				;inc hl 
246a 3e 7f			ld a, FORTH_END_BUFFER 
246c 77				ld (hl),a 
246d 23				inc hl 
246e 3e 21			ld a, '!' 
2470 77				ld (hl),a 
2471			 
2471 2a fd f3			ld hl,(os_tok_ptr) 
2474			         
2474			if DEBUG_FORTH_TOK 
2474						DMARK "TK1" 
2474				CALLMONITOR 
2474			endif 
2474			 
2474				; push exec string to top of return stack 
2474				FORTH_RSP_NEXT 
2474 cd d6 1f			call macro_forth_rsp_next 
2477				endm 
# End of macro FORTH_RSP_NEXT
2477 c9				ret 
2478			 
2478			; 
2478			;	; malloc size + buffer pointer + if is loop flag 
2478			;	ld hl,(os_tok_len) 		 ; get string length 
2478			; 
2478			;	ld a,l 
2478			; 
2478			;	cp 0			; we dont want to use a null string 
2478			;	ret z 
2478			; 
2478			;;	add 3    ; prefix malloc with buffer for current word ptr 
2478			; 
2478			;	add 5     ; TODO when certain not over writing memory remove 
2478			; 
2478			;		 
2478			; 
2478			;if DEBUG_FORTH_TOK 
2478			;			DMARK "TKE" 
2478			;	CALLMONITOR 
2478			;endif 
2478			; 
2478			;	ld l,a 
2478			;	ld h,0 
2478			;;	push hl   ; save required space for the copy later 
2478			;	call malloc 
2478			;if DEBUG_FORTH_TOK 
2478			;			DMARK "TKM" 
2478			;	CALLMONITOR 
2478			;endif 
2478			;	if DEBUG_FORTH_MALLOC_GUARD 
2478			;		push af 
2478			;		call ishlzero 
2478			;;		ld a, l 
2478			;;		add h 
2478			;;		cp 0 
2478			;		pop af 
2478			;		 
2478			;		call z,malloc_error 
2478			;	endif 
2478			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2478			; 
2478			; 
2478			;if DEBUG_FORTH_TOK 
2478			;			DMARK "TKR" 
2478			;	CALLMONITOR 
2478			;endif 
2478			; 
2478			;	FORTH_RSP_NEXT 
2478			; 
2478			;	;inc hl	 ; go past current buffer pointer 
2478			;	;inc hl 
2478			;	;inc hl   ; and past if loop flag 
2478			;		; TODO Need to set flag  
2478			; 
2478			;	 
2478			;	 
2478			;	ex de,hl	; malloc is dest 
2478			;	ld hl, (os_tok_len) 
2478			;;	pop bc 
2478			;	ld c, l                
2478			;	ld b,0 
2478			;	ld hl, (os_tok_ptr) 
2478			; 
2478			;if DEBUG_FORTH_TOK 
2478			;			DMARK "TKT" 
2478			;	CALLMONITOR 
2478			;endif 
2478			; 
2478			;	; do str cpy 
2478			; 
2478			;	ldir      ; copy byte in hl to de 
2478			; 
2478			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2478			; 
2478			;if DEBUG_FORTH_TOK 
2478			; 
2478			;			DMARK "TKY" 
2478			;	CALLMONITOR 
2478			;endif 
2478			;	;ld a,0 
2478			;	;ld a,FORTH_END_BUFFER 
2478			;	ex de, hl 
2478			;	;dec hl			 ; go back over the space delim at the end of word 
2478			;	;ld (hl),a 
2478			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2478			;	ld a,FORTH_END_BUFFER 
2478			;	ld (hl),a 
2478			;	inc hl 
2478			;	ld a,FORTH_END_BUFFER 
2478			;	ld (hl),a 
2478			; 
2478			;	; init the malloc area data 
2478			;	; set pc for in current area 
2478			;	;ld hl, (os_tok_malloc) 
2478			;	;inc hl 
2478			;	;inc hl 
2478			;	;inc hl 
2478			;	;ex de,hl 
2478			;	;ld hl, (os_tok_malloc) 
2478			;	;ld (hl),e 
2478			;	;inc hl 
2478			;	;ld (hl),d 
2478			; 
2478			; 
2478			;	ld hl,(os_tok_malloc) 
2478			;if DEBUG_FORTH_PARSE_KEY 
2478			;			DMARK "TKU" 
2478			;	CALLMONITOR 
2478			;endif 
2478			; 
2478			;	ret 
2478			 
2478			forthexec: 
2478			 
2478			; line exec: 
2478			; forth parser 
2478			 
2478			; 
2478			;       get current exec line on rsp 
2478			 
2478				FORTH_RSP_TOS 
2478 cd ed 1f			call macro_forth_rsp_tos 
247b				endm 
# End of macro FORTH_RSP_TOS
247b			 
247b			;       restore current pc - hl points to malloc of data 
247b			 
247b				;ld e, (hl) 
247b				;inc hl 
247b				;ld d, (hl) 
247b				;ex de,hl 
247b			 
247b			 
247b			exec1: 
247b 22 fd f3			ld (os_tok_ptr), hl 
247e			 
247e				; copy our PC to working vars  
247e 22 7b f9			ld (cli_ptr), hl 
2481 22 79 f9			ld (cli_origptr), hl 
2484			 
2484 7e				ld a,(hl) 
2485 fe 7f			cp FORTH_END_BUFFER 
2487 c8				ret z 
2488			 
2488				; skip any nulls 
2488			 
2488 fe 00			cp 0 
248a 20 03			jr nz, .execword 
248c 23				inc hl 
248d 18 ec			jr exec1 
248f			 
248f			 
248f			.execword: 
248f			 
248f			 
248f			 
248f			if DEBUG_FORTH_PARSE_KEY 
248f						DMARK "KYQ" 
248f				CALLMONITOR 
248f			endif 
248f			;       while at start of word: 
248f			; get start of dict (in user area first) 
248f			 
248f 21 00 80		ld hl, baseram 
2492			;ld hl, sysdict 
2492 22 7d f9		ld (cli_nextword),hl 
2495			;           match word at pc 
2495			;           exec word 
2495			;           or push to dsp 
2495			;           forward to next token 
2495			;           if line term pop rsp and exit 
2495			;        
2495			 
2495			if DEBUG_FORTH_PARSE_KEY 
2495						DMARK "KYq" 
2495				CALLMONITOR 
2495			endif 
2495			 
2495			; 
2495			; word comp 
2495			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2495			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2495			;    move to start of word  
2495			;    compare word to cli_token 
2495			 
2495			.execpnword:	; HL at start of a word in the dictionary to check 
2495			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2495			;	ld (cli_ptr), hl 
2495			 
2495 2a 7d f9			ld hl,(cli_nextword) 
2498			 
2498 cd 3b 25			call forth_tok_next 
249b			; tok next start here 
249b			;	; TODO skip compiled symbol for now 
249b			;	inc hl 
249b			; 
249b			;	; save pointer to next word 
249b			; 
249b			;	; hl now points to the address of the next word pointer  
249b			;	ld e, (hl) 
249b			;	inc hl 
249b			;	ld d, (hl) 
249b			;	inc l 
249b			; 
249b			;	ex de,hl 
249b			;if DEBUG_FORTH_PARSE_NEXTWORD 
249b			;	push bc 
249b			;	ld bc, (cli_nextword) 
249b			;			DMARK "NXW" 
249b			;	CALLMONITOR 
249b			;	pop bc 
249b			;endif 
249b			; tok next end here 
249b 22 7d f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
249e eb				ex de, hl 
249f			 
249f			 
249f				; save the pointer of the current token - 1 to check against 
249f				 
249f 22 81 f9			ld (cli_token), hl   
24a2				; TODO maybe remove below save if no debug 
24a2				; save token string ptr for any debug later 
24a2 23				inc hl  
24a3 22 83 f9			ld (cli_origtoken), hl 
24a6 2b				dec hl 
24a7				; save pointer to the start of the next dictionay word 
24a7 7e				ld a,(hl)   ; get string length 
24a8 47				ld b,a 
24a9			.execpnwordinc:  
24a9 23				inc hl 
24aa 10 fd			djnz .execpnwordinc 
24ac 22 7f f9			ld (cli_execword), hl      ; save start of this words code 
24af			 
24af				; now check the word token against the string being parsed 
24af			 
24af 2a 81 f9			ld hl,(cli_token) 
24b2 23				inc hl     ; skip string length (use zero term instead to end) 
24b3 22 81 f9			ld (cli_token), hl 
24b6			 
24b6			if DEBUG_FORTH_PARSE_KEY 
24b6						DMARK "KY2" 
24b6			endif 
24b6			if DEBUG_FORTH_PARSE_EXEC 
24b6				; see if disabled 
24b6			 
24b6			;	ld a, (os_view_disable) 
24b6			;	cp '*' 
24b6				ld a, (debug_vector) 
24b6				cp $c9   ; RET  
24b6				jr z, .skip 
24b6			 
24b6				push hl 
24b6				push hl 
24b6				call clear_display 
24b6				ld de, .compword 
24b6				ld a, display_row_1 
24b6				call str_at_display 
24b6				pop de 
24b6				ld a, display_row_2 
24b6				call str_at_display 
24b6				ld hl,(cli_ptr) 
24b6				ld a,(hl) 
24b6			        ld hl, os_word_scratch 
24b6				ld (hl),a 
24b6				ld a,0 
24b6				inc hl 
24b6				ld (hl),a 	 
24b6				ld de, os_word_scratch 
24b6				ld a, display_row_2+10 
24b6				call str_at_display 
24b6				call update_display 
24b6				ld a, 100 
24b6				call aDelayInMS 
24b6				if DEBUG_FORTH_PARSE_EXEC_SLOW 
24b6				call delay250ms 
24b6				endif 
24b6				pop hl 
24b6			.skip:  
24b6			endif	 
24b6			.execpnchar:    ; compare char between token and string to parse 
24b6			 
24b6			if DEBUG_FORTH_PARSE_KEY 
24b6						DMARK "Ky3" 
24b6			endif 
24b6			if DEBUG_FORTH_PARSE_EXEC 
24b6				; see if disabled 
24b6			 
24b6			;	ld a, (os_view_disable) 
24b6			;	cp '*' 
24b6				ld a, (debug_vector) 
24b6				cp $C9  ; RET 
24b6				jr z, .skip2 
24b6			 
24b6			;	call clear_display 
24b6			ld hl,(cli_token) 
24b6			ld a,(hl) 
24b6			ld (os_word_scratch),a 
24b6				ld hl,(cli_ptr) 
24b6			ld a,(hl) 
24b6				ld (os_word_scratch+1),a 
24b6				ld a,0 
24b6				ld (os_word_scratch+2),a 
24b6				ld de,os_word_scratch 
24b6				ld a,display_row_4 
24b6				call str_at_display 
24b6				call update_display 
24b6			.skip2:  
24b6			endif 
24b6 2a 81 f9			ld hl,(cli_token) 
24b9 7e				ld a, (hl)	 ; char in word token 
24ba 23				inc hl 		; move to next char 
24bb 22 81 f9			ld (cli_token), hl ; and save it 
24be 47				ld b,a 
24bf			 
24bf 2a 7b f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
24c2 7e				ld a,(hl) 
24c3 23				inc hl 
24c4 22 7b f9			ld (cli_ptr), hl		; move to next char 
24c7 cd 38 13			call toUpper 		; make sure the input string matches case 
24ca			 
24ca			if DEBUG_FORTH_PARSE 
24ca			endif 
24ca			 
24ca				; input stream end of token is a space so get rid of it 
24ca			 
24ca			;	cp ' ' 
24ca			;	jr nz, .pnskipspace 
24ca			; 
24ca			;	ld a, 0		; make same term as word token term 
24ca			; 
24ca			;.pnskipspace: 
24ca			 
24ca			if DEBUG_FORTH_PARSE_KEY 
24ca						DMARK "KY7" 
24ca			endif 
24ca b8				cp b 
24cb c2 e1 24			jp nz, .execpnskipword	 ; no match so move to next word 
24ce				 
24ce			;    if same 
24ce			;       scan for string terms 0 for token and 32 for input 
24ce			 
24ce				 
24ce			if DEBUG_FORTH_PARSE_KEY 
24ce						DMARK "KY8" 
24ce			endif 
24ce			 
24ce 80				add b			 
24cf fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
24d1							; TODO need to make sure last word in zero term string is accounted for 
24d1 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
24d3			 
24d3			 
24d3				; at end of both strings so both are exact match 
24d3			 
24d3			;       skip ptr for next word 
24d3			 
24d3 2a 7b f9			ld hl,(cli_ptr) 	; at input string term 
24d6 23				inc hl			 ; at next char 
24d7 22 7b f9			ld (cli_ptr), hl     ; save for next round of the parser 
24da 22 79 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
24dd				 
24dd				 
24dd			if DEBUG_FORTH_PARSE_KEY 
24dd						DMARK "KY3" 
24dd			endif 
24dd			 
24dd			 
24dd			 
24dd			;       exec code block 
24dd			if DEBUG_FORTH_JP 
24dd				call clear_display 
24dd				call update_display 
24dd				call delay1s 
24dd				ld hl, (cli_execword)     ; save for next check if no match on this word 
24dd				ld a,h 
24dd				ld hl, os_word_scratch 
24dd				call hexout 
24dd				ld hl, (cli_execword)     ; save for next check if no match on this word 
24dd				ld a,l 
24dd				ld hl, os_word_scratch+2 
24dd				call hexout 
24dd				ld hl, os_word_scratch+4 
24dd				ld a,0 
24dd				ld (hl),a 
24dd				ld de,os_word_scratch 
24dd				call str_at_display 
24dd					ld a, display_row_2 
24dd					call str_at_display 
24dd				ld de, (cli_origtoken) 
24dd				ld a, display_row_1+10 
24dd					call str_at_display 
24dd			 
24dd				ld a,display_row_1 
24dd				ld de, .foundword 
24dd				ld a, display_row_3 
24dd				call str_at_display 
24dd				call update_display 
24dd				call delay1s 
24dd				call delay1s 
24dd				call delay1s 
24dd			endif 
24dd			 
24dd			if DEBUG_FORTH_PARSE_KEY 
24dd						DMARK "KYj" 
24dd			endif 
24dd				; TODO save the word pointer in this exec 
24dd			 
24dd 2a 7f f9			ld hl,(cli_execword) 
24e0 e9				jp (hl) 
24e1			 
24e1			 
24e1			;    if not same 
24e1			;	scan for zero term 
24e1			;	get ptr for next word 
24e1			;	goto word comp 
24e1			 
24e1			.execpnskipword:	; get pointer to next word 
24e1 2a 7d f9			ld hl,(cli_nextword) 
24e4			 
24e4 7e				ld a,(hl) 
24e5 fe 00			cp WORD_SYS_END 
24e7			;	cp 0 
24e7 28 09			jr z, .execendofdict			 ; at end of words 
24e9			 
24e9			if DEBUG_FORTH_PARSE_KEY 
24e9						DMARK "KY4" 
24e9			endif 
24e9			if DEBUG_FORTH_PARSE_EXEC 
24e9			 
24e9				; see if disabled 
24e9			 
24e9			;	ld a, (os_view_disable) 
24e9			;	cp '*' 
24e9				ld a,(debug_vector) 
24e9				cp $c9   ; RET 
24e9				jr z, .noskip 
24e9			 
24e9			 
24e9				ld de, .nowordfound 
24e9				ld a, display_row_3 
24e9				call str_at_display 
24e9				call update_display 
24e9				ld a, 100 
24e9				call aDelayInMS 
24e9				 
24e9				if DEBUG_FORTH_PARSE_EXEC_SLOW 
24e9					call delay250ms 
24e9				endif 
24e9			.noskip:  
24e9			 
24e9			endif	 
24e9			 
24e9 2a 79 f9			ld hl,(cli_origptr) 
24ec 22 7b f9			ld (cli_ptr),hl 
24ef			 
24ef			if DEBUG_FORTH_PARSE_KEY 
24ef						DMARK "KY5" 
24ef			endif 
24ef c3 95 24			jp .execpnword			; else go to next word 
24f2			 
24f2			.execendofdict:  
24f2			 
24f2			if DEBUG_FORTH_PARSE_KEY 
24f2						DMARK "KYe" 
24f2			endif 
24f2			if DEBUG_FORTH_PARSE_EXEC 
24f2				; see if disabled 
24f2			 
24f2			;	ld a, (os_view_disable) 
24f2			;	cp '*' 
24f2				ld a,(debug_vector) 
24f2				cp $c9   ; ret 
24f2				jr z, .ispskip 
24f2			 
24f2				call clear_display 
24f2				call update_display 
24f2				call delay1s 
24f2				ld de, (cli_origptr) 
24f2				ld a, display_row_1 
24f2				call str_at_display 
24f2				 
24f2				ld de, .enddict 
24f2				ld a, display_row_3 
24f2				call str_at_display 
24f2				call update_display 
24f2				ld a, 100 
24f2				call aDelayInMS 
24f2				if DEBUG_FORTH_PARSE_EXEC_SLOW 
24f2				call delay1s 
24f2				call delay1s 
24f2				call delay1s 
24f2				endif 
24f2			.ispskip:  
24f2				 
24f2			endif	 
24f2			 
24f2			 
24f2			 
24f2				; if the word is not a keyword then must be a literal so push it to stack 
24f2			 
24f2			; push token to stack to end of word 
24f2			 
24f2				STACKFRAME ON $1efe $2f9f 
24f2				if DEBUG_STACK_IMB 
24f2					if ON 
24f2						exx 
24f2						ld de, $1efe 
24f2						ld a, d 
24f2						ld hl, curframe 
24f2						call hexout 
24f2						ld a, e 
24f2						ld hl, curframe+2 
24f2						call hexout 
24f2						ld hl, $1efe 
24f2						push hl 
24f2						ld hl, $2f9f 
24f2						push hl 
24f2						exx 
24f2					endif 
24f2				endif 
24f2			endm 
# End of macro STACKFRAME
24f2			 
24f2 2a fd f3		ld hl,(os_tok_ptr) 
24f5 cd 98 21		call forth_apush 
24f8			 
24f8				STACKFRAMECHK ON $1efe $2f9f 
24f8				if DEBUG_STACK_IMB 
24f8					if ON 
24f8						exx 
24f8						ld hl, $2f9f 
24f8						pop de   ; $2f9f 
24f8						call cmp16 
24f8						jr nz, .spnosame 
24f8						ld hl, $1efe 
24f8						pop de   ; $1efe 
24f8						call cmp16 
24f8						jr z, .spfrsame 
24f8						.spnosame: call showsperror 
24f8						.spfrsame: nop 
24f8						exx 
24f8					endif 
24f8				endif 
24f8			endm 
# End of macro STACKFRAMECHK
24f8			 
24f8			execnext: 
24f8			 
24f8			if DEBUG_FORTH_PARSE_KEY 
24f8						DMARK "KY>" 
24f8			endif 
24f8			; move past token to next word 
24f8			 
24f8 2a fd f3		ld hl, (os_tok_ptr) 
24fb 3e 00		ld a, 0 
24fd 01 ff 00		ld bc, 255     ; input buffer size 
2500 ed b1		cpir 
2502			 
2502			if DEBUG_FORTH_PARSE_KEY 
2502						DMARK "KY!" 
2502				CALLMONITOR 
2502			endif	 
2502			; TODO this might place hl on the null, so will need to forward on??? 
2502			;inc hl   ; see if this gets onto the next item 
2502			 
2502			 
2502			; TODO pass a pointer to the buffer to push 
2502			; TODO call function to push 
2502			 
2502			; look for end of input 
2502			 
2502			;inc hl 
2502			;ld a,(hl) 
2502			;cp FORTH_END_BUFFER 
2502			;ret z 
2502			 
2502			 
2502 c3 7b 24		jp exec1 
2505			 
2505			 
2505			 
2505			 
2505			 
2505			 
2505			 
2505			 
2505			 
2505			findnexttok: 
2505			 
2505				; hl is pointer to move 
2505				; de is the token to locate 
2505			 
2505					if DEBUG_FORTH 
2505						DMARK "NTK" 
2505						CALLMONITOR 
2505					endif 
2505 d5				push de 
2506			 
2506			.fnt1:	 
2506				; find first char of token to locate 
2506			 
2506 1a				ld a, (de) 
2507 4f				ld c,a 
2508 7e				ld a,(hl) 
2509 cd 38 13			call toUpper 
250c					if DEBUG_FORTH 
250c						DMARK "NT1" 
250c						CALLMONITOR 
250c					endif 
250c b9				cp c 
250d			 
250d 28 03			jr z, .fnt2cmpmorefirst	 
250f			 
250f				; first char not found move to next char 
250f			 
250f 23				inc hl 
2510 18 f4			jr .fnt1 
2512			 
2512			.fnt2cmpmorefirst:	 
2512				; first char of token found.  
2512			 
2512 e5				push hl     ; save start of token just in case it is the right one 
2513 d9				exx 
2514 e1				pop hl        ; save it to hl' 
2515 d9				exx 
2516			 
2516			 
2516			.fnt2cmpmore:	 
2516				; compare the rest 
2516				 
2516 23				inc hl 
2517 13				inc de 
2518				 
2518 1a				ld a, (de) 
2519 4f				ld c,a 
251a 7e				ld a,(hl) 
251b cd 38 13			call toUpper 
251e			 
251e					if DEBUG_FORTH 
251e						DMARK "NT2" 
251e						CALLMONITOR 
251e					endif 
251e				; c has the token to find char 
251e				; a has the mem to scan char 
251e			 
251e b9				cp c 
251f 28 04			jr z,.fntmatch1 
2521			 
2521				; they are not the same 
2521			 
2521					if DEBUG_FORTH 
2521						DMARK "NT3" 
2521						CALLMONITOR 
2521					endif 
2521 d1				pop de	; reset de token to look for 
2522 d5				push de 
2523 18 e1			jr .fnt1 
2525				 
2525			.fntmatch1: 
2525			 
2525				; is the same char a null which means we might have a full hit? 
2525					if DEBUG_FORTH 
2525						DMARK "NT4" 
2525						CALLMONITOR 
2525					endif 
2525			 
2525 fe 00			cp 0 
2527 28 0b			jr z, .fntmatchyes 
2529			 
2529				; are we at the end of the token to find? 
2529			 
2529					if DEBUG_FORTH 
2529						DMARK "NT5" 
2529						CALLMONITOR 
2529					endif 
2529 3e 00			ld a, 0 
252b b9				cp c 
252c			 
252c c2 16 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
252f			 
252f					if DEBUG_FORTH 
252f						DMARK "NT6" 
252f						CALLMONITOR 
252f					endif 
252f				; token to find is exhusted but no match to stream 
252f			 
252f				; restore tok pointer and continue on 
252f d1				pop de 
2530 d5				push de 
2531 c3 06 25			jp .fnt1 
2534			 
2534			 
2534			.fntmatchyes: 
2534			 
2534				; hl now contains the end of the found token 
2534			 
2534				; get rid of saved token pointer to find 
2534			 
2534 d1				pop de 
2535			 
2535					if DEBUG_FORTH 
2535						DMARK "NT9" 
2535						CALLMONITOR 
2535					endif 
2535			 
2535				; hl will be on the null term so forward on 
2535			 
2535				; get back the saved start of the token 
2535			 
2535 d9				exx 
2536 e5				push hl     ; save start of token just in case it is the right one 
2537 d9				exx 
2538 e1				pop hl        ; save it to hl 
2539			 
2539 c9				ret 
253a			 
253a			 
253a			; LIST needs to find a specific token   
253a			; FORGET needs to find a spefici token 
253a			 
253a			; SAVE needs to find all tokens by flag 
253a			; WORDS just needs to scan through all  by flag 
253a			; UWORDS needs to scan through all by flag 
253a			 
253a			 
253a			; given hl as pointer to start of dict look up string 
253a			; return hl as pointer to start of word block 
253a			; or 0 if not found 
253a			 
253a			forth_find_tok: 
253a c9				ret 
253b			 
253b			; given hl as pointer to dict structure 
253b			; move to the next dict block structure 
253b			 
253b			forth_tok_next: 
253b				; hl now points to the address of the next word pointer  
253b				; TODO skip compiled symbol for now 
253b			;	push de 
253b 23				inc hl 
253c 5e				ld e, (hl) 
253d 23				inc hl 
253e 56				ld d, (hl) 
253f 23				inc hl 
2540			 
2540 eb				ex de,hl 
2541			if DEBUG_FORTH_PARSE_NEXTWORD 
2541				push bc 
2541				ld bc, (cli_nextword) 
2541						DMARK "NXW" 
2541				CALLMONITOR 
2541				pop bc 
2541			endif 
2541			;	pop de	 
2541 c9				ret 
2542			 
2542			 
2542			 
2542			; eof 
# End of file forth_parserv5.asm
2542				include "forth_wordsv4.asm" 
2542			 
2542			; the core word dictionary v4 
2542			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2542			 
2542			; this is a linked list for each of the system words used 
2542			; user defined words will follow the same format but will be in ram 
2542			 
2542			 
2542			; 
2542			; 
2542			; define linked list: 
2542			; 
2542			; 1. compiled byte op code 
2542			; 2. len of text word 
2542			; 3. text word 
2542			; 4. ptr to next dictionary word 
2542			; 5. asm, calls etc for the word 
2542			; 
2542			;  if 1 == 0 then last word in dict  
2542			;   
2542			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2542			;  
2542			;  
2542			; create basic standard set of words 
2542			; 
2542			;  
2542			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2542			; 2DUP 2DROP 2SWAP  
2542			; @ C@ - get byte  
2542			; ! C! - store byte 
2542			; 0< true if less than zero 
2542			; 0= true if zero 
2542			; < >  
2542			; = true if same 
2542			; variables 
2542			 
2542			 
2542			; Hardware specific words I may need 
2542			; 
2542			; IN OUT  
2542			; calls to key util functions 
2542			; calls to hardward abstraction stuff 
2542			; easy control of frame buffers and lcd i/o 
2542			; keyboard  
2542			 
2542			 
2542			;DICT: macro 
2542			; op_code, len, word, next 
2542			;    word: 
2542			;    db op_code 
2542			;    ds word zero term 
2542			;    dw next 
2542			;    endm 
2542			 
2542			 
2542			 
2542			 
2542			; op code 1 is a flag for user define words which are to be handled differently 
2542			 
2542			 
2542			; 
2542			; 
2542			;    TODO on entry to a word this should be the expected environment 
2542			;    hl - tos value if number then held, if string this is the ptr 
2542			;    de -  
2542			 
2542			 
2542			; opcode ranges 
2542			; 0 - end of word dict 
2542			; 255 - user define words 
2542			 
2542			sysdict: 
2542			include "forth_opcodes.asm" 
2542			; op codes for forth keywords 
2542			; free to use code 0  
2542				OPCODE_HEAP: equ  1 
2542				OPCODE_EXEC: equ 2 
2542				OPCODE_DUP: equ 3 
2542				OPCODE_SWAP: equ 4 
2542				OPCODE_COLN: equ 5 
2542				OPCODE_SCOLN: equ 6 
2542				OPCODE_DROP: equ 7 
2542				OPCODE_DUP2: equ 8 
2542				OPCODE_DROP2: equ 9 
2542				OPCODE_SWAP2: equ 10 
2542				OPCODE_AT: equ 11 
2542				OPCODE_CAT: equ 12 
2542				OPCODE_BANG: equ 13 
2542				OPCODE_CBANG: equ 14 
2542				OPCODE_SCALL: equ 15 
2542				OPCODE_DEPTH: equ 16 
2542				OPCODE_OVER: equ 17 
2542				OPCODE_PAUSE: equ 18 
2542				OPCODE_PAUSES: equ 19 
2542				OPCODE_ROT: equ 20 
2542			;free to reuse	OPCODE_WORDS: equ 21 
2542			        OPCODE_NOT: equ 21 
2542				OPCODE_UWORDS: equ 22 
2542				OPCODE_BP: equ 23 
2542				OPCODE_MONITOR: equ 24  
2542				OPCODE_MALLOC: equ 25 
2542				OPCODE_FREE: equ 26 
2542				OPCODE_LIST: equ 27 
2542				OPCODE_FORGET: equ 28 
2542				OPCODE_NOP: equ 29 
2542				OPCODE_COMO: equ 30 
2542				OPCODE_COMC: equ 31 
2542			;free to reuse	OPCODE_ENDCORE: equ 32 
2542				OPCODE_AFTERSOUND: equ 33 
2542				OPCODE_GP2: equ 34 
2542				OPCODE_GP3: equ 35 
2542				OPCODE_GP4: equ 36 
2542				OPCODE_SIN: equ 37 
2542				OPCODE_SOUT: equ 38 
2542				OPCODE_SPIO: equ 39 
2542				OPCODE_SPICEH: equ 40 
2542				OPCODE_SPIOb: equ 41 
2542				OPCODE_SPII: equ 42 
2542				OPCODE_SESEL: equ 43 
2542				OPCODE_CARTDEV: equ 44 
2542			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2542				OPCODE_FB: equ 46 
2542				OPCODE_EMIT: equ 47 
2542				OPCODE_DOTH: equ 48 
2542				OPCODE_DOTF: equ 49 
2542				OPCODE_DOT: equ 50 
2542				OPCODE_CLS: equ 51 
2542				OPCODE_DRAW: equ 52 
2542				OPCODE_DUMP: equ 53 
2542				OPCODE_CDUMP: equ 54 
2542				OPCODE_DAT: equ 55 
2542				OPCODE_HOME: equ 56 
2542				OPCODE_SPACE: equ 57 
2542				OPCODE_SPACES: equ 58 
2542				OPCODE_SCROLL: equ 59 
2542				OPCODE_ATQ: equ 60 
2542				OPCODE_AUTODSP: equ 61 
2542				OPCODE_MENU: equ 62 
2542			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2542				OPCODE_THEN: equ 64 
2542				OPCODE_ELSE: equ 65 
2542				OPCODE_DO: equ 66 
2542				OPCODE_LOOP: equ 67 
2542				OPCODE_I: equ 68 
2542				OPCODE_DLOOP: equ 69  
2542				OPCODE_REPEAT: equ 70  
2542				OPCODE_UNTIL: equ 71 
2542				OPCODE_ENDFLOW: equ 72 
2542				OPCODE_WAITK: equ 73 
2542				OPCODE_ACCEPT: equ 74 
2542				OPCODE_EDIT: equ 75 
2542			;free to reuse	OPCODE_ENDKEY: equ 76 
2542				OPCODE_LZERO: equ 77 
2542				OPCODE_TZERO: equ 78 
2542				OPCODE_LESS: equ 79 
2542				OPCODE_GT: equ 80 
2542				OPCODE_EQUAL: equ 81  
2542			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2542				OPCODE_NEG: equ 83 
2542				OPCODE_DIV: equ 84 
2542				OPCODE_MUL: equ 85 
2542				OPCODE_MIN: equ 86 
2542				OPCODE_MAX: equ 87 
2542				OPCODE_RND16: equ 88 
2542				OPCODE_RND8: equ 89 
2542				OPCODE_RND: equ 90 
2542			;free to reuse	OPCODE_ENDMATHS: equ 91  
2542				OPCODE_BYNAME: equ 92 
2542				OPCODE_DIR: equ 93 
2542				OPCODE_SAVE: equ 94 
2542				OPCODE_LOAD: equ 95 
2542				OPCODE_BSAVE: equ 96 
2542				OPCODE_BLOAD: equ 97 
2542				OPCODE_SEO: equ 98  
2542				OPCODE_SEI: equ 99 
2542				OPCODE_SFREE: equ 100 
2542				OPCODE_SIZE: equ 101 
2542				OPCODE_CREATE: equ 102 
2542				OPCODE_APPEND: equ 103 
2542				OPCODE_SDEL: equ 104 
2542				OPCODE_OPEN: equ 105 
2542				OPCODE_READ: equ 106 
2542				OPCODE_EOF: equ 106 
2542				OPCODE_FORMAT: equ 107 
2542				OPCODE_LABEL: equ 108 
2542				OPCODE_LABELS: equ 109 
2542			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2542				OPCODE_UPPER: equ 111 
2542				OPCODE_LOWER: equ 112 
2542				OPCODE_SUBSTR: equ 113 
2542				OPCODE_LEFT: equ 114 
2542				OPCODE_RIGHT: equ 115 
2542				OPCODE_STR2NUM: equ 116 
2542				OPCODE_NUM2STR: equ 117 
2542				OPCODE_CONCAT: equ 118 
2542				OPCODE_FIND: equ 119 
2542				OPCODE_LEN: equ 120 
2542				OPCODE_CHAR: equ 121 
2542			; free to reuse	OPCODE_STRLEN: equ 122 
2542			; free to reuse	OPCODE_ENDSTR: equ 123 
2542				OPCODE_V0S: equ 124 
2542				OPCODE_V0Q: equ 125 
2542				OPCODE_V1S: equ 126 
2542				OPCODE_V1Q: equ 127 
2542				OPCODE_V2S: equ 128 
2542				OPCODE_V2Q: equ 129 
2542				OPCODE_V3S: equ 130 
2542				OPCODE_V3Q: equ 131 
2542			;free to reuse	OPCODE_END: equ 132 
2542				OPCODE_ZDUP: equ 133 
2542			 
2542			; eof 
# End of file forth_opcodes.asm
2542			 
2542			include "forth_words_core.asm" 
2542			 
2542			; | ## Core Words 
2542			 
2542			;if MALLOC_4 
2542			 
2542			.HEAP: 
2542			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2542 15				db WORD_SYS_CORE+OPCODE_HEAP             
2543 81 25			dw .EXEC            
2545 05				db 4 + 1 
2546 .. 00			db "HEAP",0              
254b				endm 
# End of macro CWHEAD
254b			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
254b			; | | u1 - Current number of bytes in the heap 
254b			; | | u2 - Remaining bytes left on the heap 
254b			; | |  
254b			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
254b			 
254b			 
254b				if DEBUG_FORTH_WORDS_KEY 
254b					DMARK "HEP" 
254b f5				push af  
254c 3a 60 25			ld a, (.dmark)  
254f 32 a6 fd			ld (debug_mark),a  
2552 3a 61 25			ld a, (.dmark+1)  
2555 32 a7 fd			ld (debug_mark+1),a  
2558 3a 62 25			ld a, (.dmark+2)  
255b 32 a8 fd			ld (debug_mark+2),a  
255e 18 03			jr .pastdmark  
2560 ..			.dmark: db "HEP"  
2563 f1			.pastdmark: pop af  
2564			endm  
# End of macro DMARK
2564					CALLMONITOR 
2564 cd aa fd			call debug_vector  
2567				endm  
# End of macro CALLMONITOR
2567				endif 
2567 2a 0a 80			ld hl, (free_list )      
256a 11 0e 80			ld de, heap_start 
256d			 
256d ed 52			sbc hl, de  
256f			 
256f cd 2f 20			call forth_push_numhl 
2572			 
2572			 
2572 ed 5b 0a 80		ld de, (free_list )      
2576 21 d7 f0			ld hl, heap_end 
2579			 
2579 ed 52			sbc hl, de 
257b			 
257b cd 2f 20			call forth_push_numhl 
257e				 
257e			 
257e				 
257e			 
257e			 
257e			 
257e				NEXTW 
257e c3 ea 23			jp macro_next 
2581				endm 
# End of macro NEXTW
2581			;endif 
2581			 
2581			.EXEC: 
2581			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2581			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2581			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2581			;; > > 
2581			;; > >   
2581			;	STACKFRAME OFF $5efe $5f9f 
2581			; 
2581			;		if DEBUG_FORTH_WORDS_KEY 
2581			;			DMARK "EXE" 
2581			;			CALLMONITOR 
2581			;		endif 
2581			; 
2581			;	FORTH_DSP_VALUEHL 
2581			; 
2581			;	FORTH_DSP_POP 
2581			; 
2581			;		if DEBUG_FORTH_WORDS 
2581			;			DMARK "EX1" 
2581			;			CALLMONITOR 
2581			;		endif 
2581			;;	ld e,(hl) 
2581			;;	inc hl 
2581			;;	ld d,(hl) 
2581			;;	ex de,hl 
2581			; 
2581			;;		if DEBUG_FORTH_WORDS 
2581			;;			DMARK "EX2" 
2581			;;			CALLMONITOR 
2581			;;		endif 
2581			;	push hl 
2581			; 
2581			;	;ld a, 0 
2581			;	;ld a, FORTH_END_BUFFER 
2581			;	call strlenz 
2581			;	inc hl   ; include zero term to copy 
2581			;	inc hl   ; include term 
2581			;	inc hl   ; include term 
2581			;	ld b,0 
2581			;	ld c,l 
2581			;	pop hl 
2581			;	ld de, execscratch 
2581			;		if DEBUG_FORTH_WORDS 
2581			;			DMARK "EX3" 
2581			;			CALLMONITOR 
2581			;		endif 
2581			;	ldir 
2581			; 
2581			; 
2581			;	ld hl, execscratch 
2581			; 
2581			;		if DEBUG_FORTH_WORDS 
2581			;			DMARK "EXe" 
2581			;			CALLMONITOR 
2581			;		endif 
2581			; 
2581			;	call forthparse 
2581			;	call forthexec 
2581			;;	call forthexec_cleanup 
2581			;;	call forthparse 
2581			;;	call forthexec 
2581			; 
2581			;	STACKFRAMECHK OFF $5efe $5f9f 
2581			; 
2581			;	; an immediate word so no need to process any more words 
2581			;	ret 
2581			;	NEXTW 
2581			 
2581			; dead code - old version  
2581			;	FORTH_RSP_NEXT 
2581			 
2581			;  
2581			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2581			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2581			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2581			;	push hl 
2581			;	push de 
2581			;	push bc 
2581			; 
2581			; 
2581			;		if DEBUG_FORTH_WORDS_KEY 
2581			;			DMARK "EXR" 
2581			;			CALLMONITOR 
2581			;		endif 
2581			; 
2581			; 
2581			; 
2581			;	;v5 FORTH_DSP_VALUE 
2581			;	FORTH_DSP_VALUEHL 
2581			; 
2581			;	; TODO do string type checks 
2581			; 
2581			;;v5	inc hl   ; skip type 
2581			; 
2581			;	push hl  ; source code  
2581			;		if DEBUG_FORTH_WORDS 
2581			;			DMARK "EX1" 
2581			;			CALLMONITOR 
2581			;		endif 
2581			;	ld a, 0 
2581			;	call strlent 
2581			; 
2581			;	inc hl 
2581			;	inc hl 
2581			;	inc hl 
2581			;	inc hl 
2581			; 
2581			;	push hl    ; size 
2581			; 
2581			;		if DEBUG_FORTH_WORDS 
2581			;			DMARK "EX2" 
2581			;			CALLMONITOR 
2581			;		endif 
2581			;	call malloc 
2581			; 
2581			;	ex de, hl    ; de now contains malloc area 
2581			;	pop bc   	; get byte count 
2581			;	pop hl      ; get string to copy 
2581			; 
2581			;	push de     ; save malloc for free later 
2581			; 
2581			;		if DEBUG_FORTH_WORDS 
2581			;			DMARK "EX3" 
2581			;			CALLMONITOR 
2581			;		endif 
2581			;	ldir       ; duplicate string 
2581			; 
2581			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2581			;	 
2581			;	; TODO fix the parse would be better than this...  
2581			;	ex de, hl 
2581			;	dec hl 
2581			;	ld a, 0 
2581			;	ld (hl), a 
2581			;	dec hl 
2581			;	ld a, ' ' 
2581			;	ld (hl), a 
2581			;	dec hl 
2581			;	ld (hl), a 
2581			; 
2581			;	dec hl 
2581			;	ld (hl), a 
2581			; 
2581			; 
2581			;	FORTH_DSP_POP  
2581			; 
2581			;	pop hl     
2581			;	push hl    ; save malloc area 
2581			; 
2581			;		if DEBUG_FORTH_WORDS 
2581			;			DMARK "EX4" 
2581			;			CALLMONITOR 
2581			;		endif 
2581			; 
2581			;	call forthparse 
2581			;	call forthexec 
2581			;	 
2581			;	pop hl 
2581			;	if DEBUG_FORTH_WORDS 
2581			;		DMARK "EX5" 
2581			;		CALLMONITOR 
2581			;	endif 
2581			; 
2581			;	if FORTH_ENABLE_FREE 
2581			;	call free 
2581			;	endif 
2581			; 
2581			;	if DEBUG_FORTH_WORDS 
2581			;		DMARK "EX6" 
2581			;		CALLMONITOR 
2581			;	endif 
2581			; 
2581			;	pop bc 
2581			;	pop de 
2581			;	pop hl 
2581			;;	FORTH_RSP_POP	  
2581			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2581			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2581			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2581			; 
2581			;	if DEBUG_FORTH_WORDS 
2581			;		DMARK "EX7" 
2581			;		CALLMONITOR 
2581			;	endif 
2581			;	NEXTW 
2581			 
2581			;.STKEXEC: 
2581			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2581			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2581			; 
2581			; 
2581			;		if DEBUG_FORTH_WORDS_KEY 
2581			;			DMARK "STX" 
2581			;			CALLMONITOR 
2581			;		endif 
2581			; 
2581			;	FORTH_DSP_VALUEHL 
2581			; 
2581			;	ld (store_tmp1), hl    ; count 
2581			; 
2581			;	FORTH_DSP_POP 
2581			;.stkexec1: 
2581			;	ld hl, (store_tmp1)   ; count 
2581			;	ld a, 0 
2581			;	cp l 
2581			;	ret z 
2581			; 
2581			;	dec hl 
2581			;	ld (store_tmp1), hl    ; count 
2581			;	 
2581			;	FORTH_DSP_VALUEHL 
2581			;	push hl 
2581			;	 
2581			;		if DEBUG_FORTH_WORDS 
2581			;			DMARK "EXp" 
2581			;			CALLMONITOR 
2581			;		endif 
2581			;	FORTH_DSP_POP 
2581			; 
2581			;	call strlenz 
2581			;	inc hl   ; include zero term to copy 
2581			;	inc hl   ; include zero term to copy 
2581			;	inc hl   ; include zero term to copy 
2581			;	ld b,0 
2581			;	ld c,l 
2581			;	pop hl 
2581			;	ld de, execscratch 
2581			;		if DEBUG_FORTH_WORDS 
2581			;			DMARK "EX3" 
2581			;			CALLMONITOR 
2581			;		endif 
2581			;	ldir 
2581			; 
2581			; 
2581			;	ld hl, execscratch 
2581			; 
2581			;		if DEBUG_FORTH_WORDS 
2581			;			DMARK "EXP" 
2581			;			CALLMONITOR 
2581			;		endif 
2581			; 
2581			;	call forthparse 
2581			;	ld hl, execscratch 
2581			;		if DEBUG_FORTH_WORDS 
2581			;			DMARK "EXx" 
2581			;			CALLMONITOR 
2581			;		endif 
2581			;	call forthexec 
2581			; 
2581			;	jp .stkexec1 
2581			; 
2581			;	ret 
2581			 
2581			 
2581			.DUP: 
2581			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2581 17				db WORD_SYS_CORE+OPCODE_DUP             
2582 f7 25			dw .ZDUP            
2584 04				db 3 + 1 
2585 .. 00			db "DUP",0              
2589				endm 
# End of macro CWHEAD
2589			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2589			 
2589				if DEBUG_FORTH_WORDS_KEY 
2589					DMARK "DUP" 
2589 f5				push af  
258a 3a 9e 25			ld a, (.dmark)  
258d 32 a6 fd			ld (debug_mark),a  
2590 3a 9f 25			ld a, (.dmark+1)  
2593 32 a7 fd			ld (debug_mark+1),a  
2596 3a a0 25			ld a, (.dmark+2)  
2599 32 a8 fd			ld (debug_mark+2),a  
259c 18 03			jr .pastdmark  
259e ..			.dmark: db "DUP"  
25a1 f1			.pastdmark: pop af  
25a2			endm  
# End of macro DMARK
25a2					CALLMONITOR 
25a2 cd aa fd			call debug_vector  
25a5				endm  
# End of macro CALLMONITOR
25a5				endif 
25a5			 
25a5				FORTH_DSP 
25a5 cd fa 21			call macro_forth_dsp 
25a8				endm 
# End of macro FORTH_DSP
25a8			 
25a8 7e				ld a, (HL) 
25a9 fe 01			cp DS_TYPE_STR 
25ab 20 25			jr nz, .dupinum 
25ad			 
25ad				; push another string 
25ad			 
25ad				FORTH_DSP_VALUEHL     		 
25ad cd 34 22			call macro_dsp_valuehl 
25b0				endm 
# End of macro FORTH_DSP_VALUEHL
25b0			 
25b0			if DEBUG_FORTH_WORDS 
25b0				DMARK "DUs" 
25b0 f5				push af  
25b1 3a c5 25			ld a, (.dmark)  
25b4 32 a6 fd			ld (debug_mark),a  
25b7 3a c6 25			ld a, (.dmark+1)  
25ba 32 a7 fd			ld (debug_mark+1),a  
25bd 3a c7 25			ld a, (.dmark+2)  
25c0 32 a8 fd			ld (debug_mark+2),a  
25c3 18 03			jr .pastdmark  
25c5 ..			.dmark: db "DUs"  
25c8 f1			.pastdmark: pop af  
25c9			endm  
# End of macro DMARK
25c9				CALLMONITOR 
25c9 cd aa fd			call debug_vector  
25cc				endm  
# End of macro CALLMONITOR
25cc			endif 
25cc cd 9d 20			call forth_push_str 
25cf			 
25cf				NEXTW 
25cf c3 ea 23			jp macro_next 
25d2				endm 
# End of macro NEXTW
25d2			 
25d2			 
25d2			.dupinum: 
25d2				 
25d2			 
25d2			 
25d2				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25d2 cd 34 22			call macro_dsp_valuehl 
25d5				endm 
# End of macro FORTH_DSP_VALUEHL
25d5			 
25d5			; TODO add floating point number detection 
25d5			 
25d5			if DEBUG_FORTH_WORDS 
25d5				DMARK "DUi" 
25d5 f5				push af  
25d6 3a ea 25			ld a, (.dmark)  
25d9 32 a6 fd			ld (debug_mark),a  
25dc 3a eb 25			ld a, (.dmark+1)  
25df 32 a7 fd			ld (debug_mark+1),a  
25e2 3a ec 25			ld a, (.dmark+2)  
25e5 32 a8 fd			ld (debug_mark+2),a  
25e8 18 03			jr .pastdmark  
25ea ..			.dmark: db "DUi"  
25ed f1			.pastdmark: pop af  
25ee			endm  
# End of macro DMARK
25ee				CALLMONITOR 
25ee cd aa fd			call debug_vector  
25f1				endm  
# End of macro CALLMONITOR
25f1			endif 
25f1			 
25f1 cd 2f 20			call forth_push_numhl 
25f4				NEXTW 
25f4 c3 ea 23			jp macro_next 
25f7				endm 
# End of macro NEXTW
25f7			.ZDUP: 
25f7			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
25f7 99				db WORD_SYS_CORE+OPCODE_ZDUP             
25f8 2f 26			dw .SWAP            
25fa 05				db 4 + 1 
25fb .. 00			db "?DUP",0              
2600				endm 
# End of macro CWHEAD
2600			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2600			 
2600				if DEBUG_FORTH_WORDS_KEY 
2600					DMARK "qDU" 
2600 f5				push af  
2601 3a 15 26			ld a, (.dmark)  
2604 32 a6 fd			ld (debug_mark),a  
2607 3a 16 26			ld a, (.dmark+1)  
260a 32 a7 fd			ld (debug_mark+1),a  
260d 3a 17 26			ld a, (.dmark+2)  
2610 32 a8 fd			ld (debug_mark+2),a  
2613 18 03			jr .pastdmark  
2615 ..			.dmark: db "qDU"  
2618 f1			.pastdmark: pop af  
2619			endm  
# End of macro DMARK
2619					CALLMONITOR 
2619 cd aa fd			call debug_vector  
261c				endm  
# End of macro CALLMONITOR
261c				endif 
261c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
261c cd 34 22			call macro_dsp_valuehl 
261f				endm 
# End of macro FORTH_DSP_VALUEHL
261f			 
261f e5				push hl 
2620			 
2620				; is it a zero? 
2620			 
2620 3e 00			ld a, 0 
2622 84				add h 
2623 85				add l 
2624			 
2624 e1				pop hl 
2625			 
2625 fe 00			cp 0 
2627 28 03			jr z, .dup2orig 
2629			 
2629			 
2629 cd 2f 20			call forth_push_numhl 
262c			 
262c			 
262c			; TODO add floating point number detection 
262c			 
262c			.dup2orig: 
262c			 
262c				NEXTW 
262c c3 ea 23			jp macro_next 
262f				endm 
# End of macro NEXTW
262f			.SWAP: 
262f			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
262f 18				db WORD_SYS_CORE+OPCODE_SWAP             
2630 6e 26			dw .COLN            
2632 05				db 4 + 1 
2633 .. 00			db "SWAP",0              
2638				endm 
# End of macro CWHEAD
2638			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2638				if DEBUG_FORTH_WORDS_KEY 
2638					DMARK "SWP" 
2638 f5				push af  
2639 3a 4d 26			ld a, (.dmark)  
263c 32 a6 fd			ld (debug_mark),a  
263f 3a 4e 26			ld a, (.dmark+1)  
2642 32 a7 fd			ld (debug_mark+1),a  
2645 3a 4f 26			ld a, (.dmark+2)  
2648 32 a8 fd			ld (debug_mark+2),a  
264b 18 03			jr .pastdmark  
264d ..			.dmark: db "SWP"  
2650 f1			.pastdmark: pop af  
2651			endm  
# End of macro DMARK
2651					CALLMONITOR 
2651 cd aa fd			call debug_vector  
2654				endm  
# End of macro CALLMONITOR
2654				endif 
2654			 
2654			; TODO Use os stack swap memory 
2654				FORTH_DSP_VALUEHL 
2654 cd 34 22			call macro_dsp_valuehl 
2657				endm 
# End of macro FORTH_DSP_VALUEHL
2657 e5				push hl     ; w2 
2658			 
2658				FORTH_DSP_POP 
2658 cd ec 22			call macro_forth_dsp_pop 
265b				endm 
# End of macro FORTH_DSP_POP
265b			 
265b				FORTH_DSP_VALUEHL 
265b cd 34 22			call macro_dsp_valuehl 
265e				endm 
# End of macro FORTH_DSP_VALUEHL
265e			 
265e				FORTH_DSP_POP 
265e cd ec 22			call macro_forth_dsp_pop 
2661				endm 
# End of macro FORTH_DSP_POP
2661			 
2661 d1				pop de     ; w2	, hl = w1 
2662			 
2662 eb				ex de, hl 
2663 d5				push de 
2664			 
2664 cd 2f 20			call forth_push_numhl 
2667			 
2667 e1				pop hl 
2668			 
2668 cd 2f 20			call forth_push_numhl 
266b				 
266b			 
266b				NEXTW 
266b c3 ea 23			jp macro_next 
266e				endm 
# End of macro NEXTW
266e			.COLN: 
266e			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
266e 19				db WORD_SYS_CORE+OPCODE_COLN             
266f fa 27			dw .SCOLN            
2671 02				db 1 + 1 
2672 .. 00			db ":",0              
2674				endm 
# End of macro CWHEAD
2674			; | : ( -- )         Create new word | DONE 
2674			 
2674				if DEBUG_FORTH_WORDS_KEY 
2674					DMARK "CLN" 
2674 f5				push af  
2675 3a 89 26			ld a, (.dmark)  
2678 32 a6 fd			ld (debug_mark),a  
267b 3a 8a 26			ld a, (.dmark+1)  
267e 32 a7 fd			ld (debug_mark+1),a  
2681 3a 8b 26			ld a, (.dmark+2)  
2684 32 a8 fd			ld (debug_mark+2),a  
2687 18 03			jr .pastdmark  
2689 ..			.dmark: db "CLN"  
268c f1			.pastdmark: pop af  
268d			endm  
# End of macro DMARK
268d					CALLMONITOR 
268d cd aa fd			call debug_vector  
2690				endm  
# End of macro CALLMONITOR
2690				endif 
2690			STACKFRAME OFF $8efe $989f 
2690				if DEBUG_STACK_IMB 
2690					if OFF 
2690						exx 
2690						ld de, $8efe 
2690						ld a, d 
2690						ld hl, curframe 
2690						call hexout 
2690						ld a, e 
2690						ld hl, curframe+2 
2690						call hexout 
2690						ld hl, $8efe 
2690						push hl 
2690						ld hl, $989f 
2690						push hl 
2690						exx 
2690					endif 
2690				endif 
2690			endm 
# End of macro STACKFRAME
2690			; get parser buffer length  of new word 
2690			 
2690			 
2690			 
2690				; move tok past this to start of name defintition 
2690				; TODO get word to define 
2690				; TODO Move past word token 
2690				; TODO get length of string up to the ';' 
2690			 
2690 2a fd f3		ld hl, (os_tok_ptr) 
2693 23			inc hl 
2694 23			inc hl 
2695			 
2695 3e 3b		ld a, ';' 
2697 cd 4c 13		call strlent 
269a			 
269a 7d			ld a,l 
269b 32 ec f0		ld (os_new_parse_len), a 
269e			 
269e			 
269e			if DEBUG_FORTH_UWORD 
269e ed 5b fd f3	ld de, (os_tok_ptr) 
26a2					DMARK ":01" 
26a2 f5				push af  
26a3 3a b7 26			ld a, (.dmark)  
26a6 32 a6 fd			ld (debug_mark),a  
26a9 3a b8 26			ld a, (.dmark+1)  
26ac 32 a7 fd			ld (debug_mark+1),a  
26af 3a b9 26			ld a, (.dmark+2)  
26b2 32 a8 fd			ld (debug_mark+2),a  
26b5 18 03			jr .pastdmark  
26b7 ..			.dmark: db ":01"  
26ba f1			.pastdmark: pop af  
26bb			endm  
# End of macro DMARK
26bb			CALLMONITOR 
26bb cd aa fd			call debug_vector  
26be				endm  
# End of macro CALLMONITOR
26be			endif 
26be			 
26be			; 
26be			;  new word memory layout: 
26be			;  
26be			;    : adg 6666 ;  
26be			; 
26be			;    db   1     ; user defined word  
26be 23			inc hl    
26bf			;    dw   sysdict 
26bf 23			inc hl 
26c0 23			inc hl 
26c1			;    db <word len>+1 (for null) 
26c1 23			inc hl 
26c2			;    db .... <word> 
26c2			; 
26c2			 
26c2 23			inc hl    ; some extras for the word preamble before the above 
26c3 23			inc hl 
26c4 23			inc hl 
26c5 23			inc hl 
26c6 23			inc hl 
26c7 23			inc hl 
26c8 23			inc hl  
26c9 23			inc hl 
26ca 23			inc hl 
26cb 23			inc hl 
26cc 23			inc hl 
26cd 23			inc hl 
26ce 23			inc hl 
26cf 23			inc hl     ; TODO how many do we really need?     maybe only 6 
26d0			;       exec word buffer 
26d0			;	<ptr word>   
26d0 23			inc hl 
26d1 23			inc hl 
26d2			;       <word list><null term> 7F final term 
26d2			 
26d2			 
26d2			if DEBUG_FORTH_UWORD 
26d2					DMARK ":02" 
26d2 f5				push af  
26d3 3a e7 26			ld a, (.dmark)  
26d6 32 a6 fd			ld (debug_mark),a  
26d9 3a e8 26			ld a, (.dmark+1)  
26dc 32 a7 fd			ld (debug_mark+1),a  
26df 3a e9 26			ld a, (.dmark+2)  
26e2 32 a8 fd			ld (debug_mark+2),a  
26e5 18 03			jr .pastdmark  
26e7 ..			.dmark: db ":02"  
26ea f1			.pastdmark: pop af  
26eb			endm  
# End of macro DMARK
26eb			CALLMONITOR 
26eb cd aa fd			call debug_vector  
26ee				endm  
# End of macro CALLMONITOR
26ee			endif 
26ee			 
26ee			 
26ee				; malloc the size 
26ee			 
26ee cd b6 13			call malloc 
26f1 22 ee f0			ld (os_new_malloc), hl     ; save malloc start 
26f4			 
26f4			;    db   1     ; user defined word  
26f4 3e 01			ld a, WORD_SYS_UWORD  
26f6 77				ld (hl), a 
26f7			 
26f7 23			inc hl    
26f8			;    dw   sysdict 
26f8 11 42 25		ld de, sysdict       ; continue on with the scan to the system dict 
26fb 73			ld (hl), e 
26fc 23			inc hl 
26fd 72			ld (hl), d 
26fe 23			inc hl 
26ff			 
26ff			 
26ff			;    Setup dict word 
26ff			 
26ff 23			inc hl 
2700 22 e8 f0		ld (os_new_work_ptr), hl     ; save start of dict word  
2703			 
2703			; 1. get length of dict word 
2703			 
2703			 
2703 2a fd f3		ld hl, (os_tok_ptr) 
2706 23			inc hl 
2707 23			inc hl    ; position to start of dict word 
2708 3e 00		ld a, 0 
270a cd 4c 13		call strlent 
270d			 
270d			 
270d 23			inc hl    ; to include null??? 
270e			 
270e			; write length of dict word 
270e			 
270e ed 5b e8 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2712 1b			dec de 
2713 eb			ex de, hl 
2714 73			ld (hl), e 
2715 eb			ex de, hl 
2716			 
2716			 
2716			 
2716			; copy  
2716 4d			ld c, l 
2717 06 00		ld b, 0 
2719 ed 5b e8 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
271d 2a fd f3		ld hl, (os_tok_ptr) 
2720 23			inc hl 
2721 23			inc hl    ; position to start of dict word 
2722			 
2722			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2722			 
2722			; TODO need to convert word to upper case 
2722			 
2722			ucasetok:	 
2722 7e			ld a,(hl) 
2723 cd 38 13		call toUpper 
2726 77			ld (hl),a 
2727 ed a0		ldi 
2729 f2 22 27		jp p, ucasetok 
272c			 
272c			 
272c			 
272c			; de now points to start of where the word body code should be placed 
272c ed 53 e8 f0	ld (os_new_work_ptr), de 
2730			; hl now points to the words to throw at forthexec which needs to be copied 
2730 22 e6 f0		ld (os_new_src_ptr), hl 
2733			 
2733			; TODO add 'call to forthexec' 
2733			 
2733			if DEBUG_FORTH_UWORD 
2733 c5			push bc 
2734 ed 4b ee f0	ld bc, (os_new_malloc) 
2738					DMARK ":0x" 
2738 f5				push af  
2739 3a 4d 27			ld a, (.dmark)  
273c 32 a6 fd			ld (debug_mark),a  
273f 3a 4e 27			ld a, (.dmark+1)  
2742 32 a7 fd			ld (debug_mark+1),a  
2745 3a 4f 27			ld a, (.dmark+2)  
2748 32 a8 fd			ld (debug_mark+2),a  
274b 18 03			jr .pastdmark  
274d ..			.dmark: db ":0x"  
2750 f1			.pastdmark: pop af  
2751			endm  
# End of macro DMARK
2751			CALLMONITOR 
2751 cd aa fd			call debug_vector  
2754				endm  
# End of macro CALLMONITOR
2754 c1			pop bc 
2755			endif 
2755			 
2755			 
2755			; create word preamble which should be: 
2755			 
2755			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2755			 
2755			;    ld hl, <word code> 
2755			;    jp user_exec 
2755			;    <word code bytes> 
2755			 
2755			 
2755			;	inc de     ; TODO ??? or are we already past the word's null 
2755 eb			ex de, hl 
2756			 
2756 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2758			 
2758 23			inc hl 
2759 22 e2 f0		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
275c 23			inc hl 
275d			 
275d 23			inc hl 
275e 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2760			 
2760 01 f7 5c		ld bc, user_exec 
2763 23			inc hl 
2764 71			ld (hl), c     ; poke address of user_exec 
2765 23			inc hl 
2766 70			ld (hl), b     
2767			; 
2767			;	inc hl 
2767			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2767			; 
2767			; 
2767			;	ld bc, macro_forth_rsp_next 
2767			;	inc hl 
2767			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2767			;	inc hl 
2767			;	ld (hl), b     
2767			; 
2767			;	inc hl 
2767			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2767			; 
2767			; 
2767			;	inc hl 
2767			;	ld bc, forthexec 
2767			;	ld (hl), c     ; poke address of forthexec 
2767			;	inc hl 
2767			;	ld (hl), b      
2767			; 
2767			;	inc hl 
2767			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2767			; 
2767			;	ld bc, user_dict_next 
2767			;	inc hl 
2767			;	ld (hl), c     ; poke address of forthexec 
2767			;	inc hl 
2767			;	ld (hl), b      
2767			 
2767			; hl is now where we need to copy the word byte data to save this 
2767			 
2767 23			inc hl 
2768 22 e4 f0		ld (os_new_exec), hl 
276b			 
276b			; copy definition 
276b			 
276b eb			ex de, hl 
276c			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
276c			;	inc de    ; skip the PC for this parse 
276c 3a ec f0		ld a, (os_new_parse_len) 
276f 4f			ld c, a 
2770 06 00		ld b, 0 
2772 ed b0		ldir		 ; copy defintion 
2774			 
2774			 
2774			; poke the address of where the new word bytes live for forthexec 
2774			 
2774 2a e2 f0		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2777			 
2777 ed 5b e4 f0	ld de, (os_new_exec)      
277b			 
277b 73			ld (hl), e 
277c 23			inc hl 
277d 72			ld (hl), d 
277e			 
277e				; TODO copy last user dict word next link to this word 
277e				; TODO update last user dict word to point to this word 
277e			; 
277e			; hl f923 de 812a ; bc 811a 
277e			 
277e			if DEBUG_FORTH_UWORD 
277e c5			push bc 
277f ed 4b ee f0	ld bc, (os_new_malloc) 
2783					DMARK ":0A" 
2783 f5				push af  
2784 3a 98 27			ld a, (.dmark)  
2787 32 a6 fd			ld (debug_mark),a  
278a 3a 99 27			ld a, (.dmark+1)  
278d 32 a7 fd			ld (debug_mark+1),a  
2790 3a 9a 27			ld a, (.dmark+2)  
2793 32 a8 fd			ld (debug_mark+2),a  
2796 18 03			jr .pastdmark  
2798 ..			.dmark: db ":0A"  
279b f1			.pastdmark: pop af  
279c			endm  
# End of macro DMARK
279c			CALLMONITOR 
279c cd aa fd			call debug_vector  
279f				endm  
# End of macro CALLMONITOR
279f c1			pop bc 
27a0			endif 
27a0			if DEBUG_FORTH_UWORD 
27a0 c5			push bc 
27a1 ed 4b ee f0	ld bc, (os_new_malloc) 
27a5 03			inc bc 
27a6 03			inc bc 
27a7 03			inc bc 
27a8 03			inc bc 
27a9 03			inc bc 
27aa 03			inc bc 
27ab 03			inc bc 
27ac 03			inc bc 
27ad			 
27ad					DMARK ":0B" 
27ad f5				push af  
27ae 3a c2 27			ld a, (.dmark)  
27b1 32 a6 fd			ld (debug_mark),a  
27b4 3a c3 27			ld a, (.dmark+1)  
27b7 32 a7 fd			ld (debug_mark+1),a  
27ba 3a c4 27			ld a, (.dmark+2)  
27bd 32 a8 fd			ld (debug_mark+2),a  
27c0 18 03			jr .pastdmark  
27c2 ..			.dmark: db ":0B"  
27c5 f1			.pastdmark: pop af  
27c6			endm  
# End of macro DMARK
27c6			CALLMONITOR 
27c6 cd aa fd			call debug_vector  
27c9				endm  
# End of macro CALLMONITOR
27c9 c1			pop bc 
27ca			endif 
27ca			 
27ca			; update word dict linked list for new word 
27ca			 
27ca			 
27ca 2a f9 f3		ld hl, (os_last_new_uword)		; get the start of the last added uword 
27cd 23			inc hl     ; move to next work linked list ptr 
27ce			 
27ce ed 5b ee f0	ld de, (os_new_malloc)		 ; new next word 
27d2 73			ld (hl), e 
27d3 23			inc hl 
27d4 72			ld (hl), d 
27d5			 
27d5			if DEBUG_FORTH_UWORD 
27d5 ed 4b f9 f3	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
27d9			endif 
27d9			 
27d9 ed 53 f9 f3	ld (os_last_new_uword), de      ; update last new uword ptr 
27dd			 
27dd			 
27dd			if DEBUG_FORTH_UWORD 
27dd					DMARK ":0+" 
27dd f5				push af  
27de 3a f2 27			ld a, (.dmark)  
27e1 32 a6 fd			ld (debug_mark),a  
27e4 3a f3 27			ld a, (.dmark+1)  
27e7 32 a7 fd			ld (debug_mark+1),a  
27ea 3a f4 27			ld a, (.dmark+2)  
27ed 32 a8 fd			ld (debug_mark+2),a  
27f0 18 03			jr .pastdmark  
27f2 ..			.dmark: db ":0+"  
27f5 f1			.pastdmark: pop af  
27f6			endm  
# End of macro DMARK
27f6			CALLMONITOR 
27f6 cd aa fd			call debug_vector  
27f9				endm  
# End of macro CALLMONITOR
27f9			endif 
27f9			 
27f9			STACKFRAMECHK OFF $8efe $989f 
27f9				if DEBUG_STACK_IMB 
27f9					if OFF 
27f9						exx 
27f9						ld hl, $989f 
27f9						pop de   ; $989f 
27f9						call cmp16 
27f9						jr nz, .spnosame 
27f9						ld hl, $8efe 
27f9						pop de   ; $8efe 
27f9						call cmp16 
27f9						jr z, .spfrsame 
27f9						.spnosame: call showsperror 
27f9						.spfrsame: nop 
27f9						exx 
27f9					endif 
27f9				endif 
27f9			endm 
# End of macro STACKFRAMECHK
27f9			 
27f9 c9			ret    ; dont process any remaining parser tokens as they form new word 
27fa			 
27fa			 
27fa			 
27fa			 
27fa			;		NEXT 
27fa			.SCOLN: 
27fa			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
27fa 06			db OPCODE_SCOLN 
27fb 46 28		dw .DROP 
27fd 02			db 2 
27fe .. 00		db ";",0           
2800			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2800				if DEBUG_FORTH_WORDS_KEY 
2800					DMARK "SCN" 
2800 f5				push af  
2801 3a 15 28			ld a, (.dmark)  
2804 32 a6 fd			ld (debug_mark),a  
2807 3a 16 28			ld a, (.dmark+1)  
280a 32 a7 fd			ld (debug_mark+1),a  
280d 3a 17 28			ld a, (.dmark+2)  
2810 32 a8 fd			ld (debug_mark+2),a  
2813 18 03			jr .pastdmark  
2815 ..			.dmark: db "SCN"  
2818 f1			.pastdmark: pop af  
2819			endm  
# End of macro DMARK
2819					CALLMONITOR 
2819 cd aa fd			call debug_vector  
281c				endm  
# End of macro CALLMONITOR
281c				endif 
281c				FORTH_RSP_TOS 
281c cd ed 1f			call macro_forth_rsp_tos 
281f				endm 
# End of macro FORTH_RSP_TOS
281f e5				push hl 
2820				FORTH_RSP_POP 
2820 cd f7 1f			call macro_forth_rsp_pop 
2823				endm 
# End of macro FORTH_RSP_POP
2823 e1				pop hl 
2824			;		ex de,hl 
2824 22 fd f3			ld (os_tok_ptr),hl 
2827			 
2827			if DEBUG_FORTH_UWORD 
2827					DMARK "SCL" 
2827 f5				push af  
2828 3a 3c 28			ld a, (.dmark)  
282b 32 a6 fd			ld (debug_mark),a  
282e 3a 3d 28			ld a, (.dmark+1)  
2831 32 a7 fd			ld (debug_mark+1),a  
2834 3a 3e 28			ld a, (.dmark+2)  
2837 32 a8 fd			ld (debug_mark+2),a  
283a 18 03			jr .pastdmark  
283c ..			.dmark: db "SCL"  
283f f1			.pastdmark: pop af  
2840			endm  
# End of macro DMARK
2840			CALLMONITOR 
2840 cd aa fd			call debug_vector  
2843				endm  
# End of macro CALLMONITOR
2843			endif 
2843				NEXTW 
2843 c3 ea 23			jp macro_next 
2846				endm 
# End of macro NEXTW
2846			 
2846			.DROP: 
2846			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2846 1b				db WORD_SYS_CORE+OPCODE_DROP             
2847 71 28			dw .DUP2            
2849 05				db 4 + 1 
284a .. 00			db "DROP",0              
284f				endm 
# End of macro CWHEAD
284f			; | DROP ( w -- )   drop the TOS item   | DONE 
284f				if DEBUG_FORTH_WORDS_KEY 
284f					DMARK "DRP" 
284f f5				push af  
2850 3a 64 28			ld a, (.dmark)  
2853 32 a6 fd			ld (debug_mark),a  
2856 3a 65 28			ld a, (.dmark+1)  
2859 32 a7 fd			ld (debug_mark+1),a  
285c 3a 66 28			ld a, (.dmark+2)  
285f 32 a8 fd			ld (debug_mark+2),a  
2862 18 03			jr .pastdmark  
2864 ..			.dmark: db "DRP"  
2867 f1			.pastdmark: pop af  
2868			endm  
# End of macro DMARK
2868					CALLMONITOR 
2868 cd aa fd			call debug_vector  
286b				endm  
# End of macro CALLMONITOR
286b				endif 
286b				FORTH_DSP_POP 
286b cd ec 22			call macro_forth_dsp_pop 
286e				endm 
# End of macro FORTH_DSP_POP
286e				NEXTW 
286e c3 ea 23			jp macro_next 
2871				endm 
# End of macro NEXTW
2871			.DUP2: 
2871			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2871 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2872 b6 28			dw .DROP2            
2874 05				db 4 + 1 
2875 .. 00			db "2DUP",0              
287a				endm 
# End of macro CWHEAD
287a			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
287a				if DEBUG_FORTH_WORDS_KEY 
287a					DMARK "2DU" 
287a f5				push af  
287b 3a 8f 28			ld a, (.dmark)  
287e 32 a6 fd			ld (debug_mark),a  
2881 3a 90 28			ld a, (.dmark+1)  
2884 32 a7 fd			ld (debug_mark+1),a  
2887 3a 91 28			ld a, (.dmark+2)  
288a 32 a8 fd			ld (debug_mark+2),a  
288d 18 03			jr .pastdmark  
288f ..			.dmark: db "2DU"  
2892 f1			.pastdmark: pop af  
2893			endm  
# End of macro DMARK
2893					CALLMONITOR 
2893 cd aa fd			call debug_vector  
2896				endm  
# End of macro CALLMONITOR
2896				endif 
2896				FORTH_DSP_VALUEHL 
2896 cd 34 22			call macro_dsp_valuehl 
2899				endm 
# End of macro FORTH_DSP_VALUEHL
2899 e5				push hl      ; 2 
289a			 
289a				FORTH_DSP_POP 
289a cd ec 22			call macro_forth_dsp_pop 
289d				endm 
# End of macro FORTH_DSP_POP
289d				 
289d				FORTH_DSP_VALUEHL 
289d cd 34 22			call macro_dsp_valuehl 
28a0				endm 
# End of macro FORTH_DSP_VALUEHL
28a0			;		push hl      ; 1 
28a0			 
28a0				FORTH_DSP_POP 
28a0 cd ec 22			call macro_forth_dsp_pop 
28a3				endm 
# End of macro FORTH_DSP_POP
28a3			 
28a3			;		pop hl       ; 1 
28a3 d1				pop de       ; 2 
28a4			 
28a4 cd 2f 20			call forth_push_numhl 
28a7 eb				ex de, hl 
28a8 cd 2f 20			call forth_push_numhl 
28ab			 
28ab				 
28ab eb				ex de, hl 
28ac			 
28ac cd 2f 20			call forth_push_numhl 
28af eb				ex de, hl 
28b0 cd 2f 20			call forth_push_numhl 
28b3			 
28b3			 
28b3				NEXTW 
28b3 c3 ea 23			jp macro_next 
28b6				endm 
# End of macro NEXTW
28b6			.DROP2: 
28b6			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
28b6 1d				db WORD_SYS_CORE+OPCODE_DROP2             
28b7 e5 28			dw .SWAP2            
28b9 06				db 5 + 1 
28ba .. 00			db "2DROP",0              
28c0				endm 
# End of macro CWHEAD
28c0			; | 2DROP ( w w -- )    Double drop | DONE 
28c0				if DEBUG_FORTH_WORDS_KEY 
28c0					DMARK "2DR" 
28c0 f5				push af  
28c1 3a d5 28			ld a, (.dmark)  
28c4 32 a6 fd			ld (debug_mark),a  
28c7 3a d6 28			ld a, (.dmark+1)  
28ca 32 a7 fd			ld (debug_mark+1),a  
28cd 3a d7 28			ld a, (.dmark+2)  
28d0 32 a8 fd			ld (debug_mark+2),a  
28d3 18 03			jr .pastdmark  
28d5 ..			.dmark: db "2DR"  
28d8 f1			.pastdmark: pop af  
28d9			endm  
# End of macro DMARK
28d9					CALLMONITOR 
28d9 cd aa fd			call debug_vector  
28dc				endm  
# End of macro CALLMONITOR
28dc				endif 
28dc				FORTH_DSP_POP 
28dc cd ec 22			call macro_forth_dsp_pop 
28df				endm 
# End of macro FORTH_DSP_POP
28df				FORTH_DSP_POP 
28df cd ec 22			call macro_forth_dsp_pop 
28e2				endm 
# End of macro FORTH_DSP_POP
28e2				NEXTW 
28e2 c3 ea 23			jp macro_next 
28e5				endm 
# End of macro NEXTW
28e5			.SWAP2: 
28e5			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
28e5 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
28e6 0e 29			dw .AT            
28e8 06				db 5 + 1 
28e9 .. 00			db "2SWAP",0              
28ef				endm 
# End of macro CWHEAD
28ef			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
28ef				if DEBUG_FORTH_WORDS_KEY 
28ef					DMARK "2SW" 
28ef f5				push af  
28f0 3a 04 29			ld a, (.dmark)  
28f3 32 a6 fd			ld (debug_mark),a  
28f6 3a 05 29			ld a, (.dmark+1)  
28f9 32 a7 fd			ld (debug_mark+1),a  
28fc 3a 06 29			ld a, (.dmark+2)  
28ff 32 a8 fd			ld (debug_mark+2),a  
2902 18 03			jr .pastdmark  
2904 ..			.dmark: db "2SW"  
2907 f1			.pastdmark: pop af  
2908			endm  
# End of macro DMARK
2908					CALLMONITOR 
2908 cd aa fd			call debug_vector  
290b				endm  
# End of macro CALLMONITOR
290b				endif 
290b			; TODO Use os stack swap memory 
290b				NEXTW 
290b c3 ea 23			jp macro_next 
290e				endm 
# End of macro NEXTW
290e			.AT: 
290e			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
290e 1f				db WORD_SYS_CORE+OPCODE_AT             
290f 40 29			dw .CAT            
2911 02				db 1 + 1 
2912 .. 00			db "@",0              
2914				endm 
# End of macro CWHEAD
2914			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2914			 
2914				if DEBUG_FORTH_WORDS_KEY 
2914					DMARK "AT." 
2914 f5				push af  
2915 3a 29 29			ld a, (.dmark)  
2918 32 a6 fd			ld (debug_mark),a  
291b 3a 2a 29			ld a, (.dmark+1)  
291e 32 a7 fd			ld (debug_mark+1),a  
2921 3a 2b 29			ld a, (.dmark+2)  
2924 32 a8 fd			ld (debug_mark+2),a  
2927 18 03			jr .pastdmark  
2929 ..			.dmark: db "AT."  
292c f1			.pastdmark: pop af  
292d			endm  
# End of macro DMARK
292d					CALLMONITOR 
292d cd aa fd			call debug_vector  
2930				endm  
# End of macro CALLMONITOR
2930				endif 
2930			.getbyteat:	 
2930				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2930 cd 34 22			call macro_dsp_valuehl 
2933				endm 
# End of macro FORTH_DSP_VALUEHL
2933				 
2933			;		push hl 
2933			 
2933				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2933 cd ec 22			call macro_forth_dsp_pop 
2936				endm 
# End of macro FORTH_DSP_POP
2936			 
2936			;		pop hl 
2936			 
2936 7e				ld a, (hl) 
2937			 
2937 6f				ld l, a 
2938 26 00			ld h, 0 
293a cd 2f 20			call forth_push_numhl 
293d			 
293d				NEXTW 
293d c3 ea 23			jp macro_next 
2940				endm 
# End of macro NEXTW
2940			.CAT: 
2940			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2940 20				db WORD_SYS_CORE+OPCODE_CAT             
2941 69 29			dw .BANG            
2943 03				db 2 + 1 
2944 .. 00			db "C@",0              
2947				endm 
# End of macro CWHEAD
2947			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2947				if DEBUG_FORTH_WORDS_KEY 
2947					DMARK "CAA" 
2947 f5				push af  
2948 3a 5c 29			ld a, (.dmark)  
294b 32 a6 fd			ld (debug_mark),a  
294e 3a 5d 29			ld a, (.dmark+1)  
2951 32 a7 fd			ld (debug_mark+1),a  
2954 3a 5e 29			ld a, (.dmark+2)  
2957 32 a8 fd			ld (debug_mark+2),a  
295a 18 03			jr .pastdmark  
295c ..			.dmark: db "CAA"  
295f f1			.pastdmark: pop af  
2960			endm  
# End of macro DMARK
2960					CALLMONITOR 
2960 cd aa fd			call debug_vector  
2963				endm  
# End of macro CALLMONITOR
2963				endif 
2963 c3 30 29			jp .getbyteat 
2966				NEXTW 
2966 c3 ea 23			jp macro_next 
2969				endm 
# End of macro NEXTW
2969			.BANG: 
2969			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2969 21				db WORD_SYS_CORE+OPCODE_BANG             
296a 9f 29			dw .CBANG            
296c 02				db 1 + 1 
296d .. 00			db "!",0              
296f				endm 
# End of macro CWHEAD
296f			; | ! ( x w -- ) Store x at address w      | DONE 
296f				if DEBUG_FORTH_WORDS_KEY 
296f					DMARK "BNG" 
296f f5				push af  
2970 3a 84 29			ld a, (.dmark)  
2973 32 a6 fd			ld (debug_mark),a  
2976 3a 85 29			ld a, (.dmark+1)  
2979 32 a7 fd			ld (debug_mark+1),a  
297c 3a 86 29			ld a, (.dmark+2)  
297f 32 a8 fd			ld (debug_mark+2),a  
2982 18 03			jr .pastdmark  
2984 ..			.dmark: db "BNG"  
2987 f1			.pastdmark: pop af  
2988			endm  
# End of macro DMARK
2988					CALLMONITOR 
2988 cd aa fd			call debug_vector  
298b				endm  
# End of macro CALLMONITOR
298b				endif 
298b			 
298b			.storebyteat:		 
298b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
298b cd 34 22			call macro_dsp_valuehl 
298e				endm 
# End of macro FORTH_DSP_VALUEHL
298e				 
298e e5				push hl 
298f			 
298f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
298f cd ec 22			call macro_forth_dsp_pop 
2992				endm 
# End of macro FORTH_DSP_POP
2992			 
2992				; get byte to poke 
2992			 
2992				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2992 cd 34 22			call macro_dsp_valuehl 
2995				endm 
# End of macro FORTH_DSP_VALUEHL
2995 e5				push hl 
2996			 
2996			 
2996				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2996 cd ec 22			call macro_forth_dsp_pop 
2999				endm 
# End of macro FORTH_DSP_POP
2999			 
2999			 
2999 d1				pop de 
299a e1				pop hl 
299b			 
299b 73				ld (hl),e 
299c			 
299c			 
299c				NEXTW 
299c c3 ea 23			jp macro_next 
299f				endm 
# End of macro NEXTW
299f			.CBANG: 
299f			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
299f 22				db WORD_SYS_CORE+OPCODE_CBANG             
29a0 c8 29			dw .SCALL            
29a2 03				db 2 + 1 
29a3 .. 00			db "C!",0              
29a6				endm 
# End of macro CWHEAD
29a6			; | C!  ( x w -- ) Store x at address w  | DONE 
29a6				if DEBUG_FORTH_WORDS_KEY 
29a6					DMARK "CBA" 
29a6 f5				push af  
29a7 3a bb 29			ld a, (.dmark)  
29aa 32 a6 fd			ld (debug_mark),a  
29ad 3a bc 29			ld a, (.dmark+1)  
29b0 32 a7 fd			ld (debug_mark+1),a  
29b3 3a bd 29			ld a, (.dmark+2)  
29b6 32 a8 fd			ld (debug_mark+2),a  
29b9 18 03			jr .pastdmark  
29bb ..			.dmark: db "CBA"  
29be f1			.pastdmark: pop af  
29bf			endm  
# End of macro DMARK
29bf					CALLMONITOR 
29bf cd aa fd			call debug_vector  
29c2				endm  
# End of macro CALLMONITOR
29c2				endif 
29c2 c3 8b 29			jp .storebyteat 
29c5				NEXTW 
29c5 c3 ea 23			jp macro_next 
29c8				endm 
# End of macro NEXTW
29c8			.SCALL: 
29c8			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
29c8 23				db WORD_SYS_CORE+OPCODE_SCALL             
29c9 fc 29			dw .DEPTH            
29cb 05				db 4 + 1 
29cc .. 00			db "CALL",0              
29d1				endm 
# End of macro CWHEAD
29d1			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
29d1				if DEBUG_FORTH_WORDS_KEY 
29d1					DMARK "CLL" 
29d1 f5				push af  
29d2 3a e6 29			ld a, (.dmark)  
29d5 32 a6 fd			ld (debug_mark),a  
29d8 3a e7 29			ld a, (.dmark+1)  
29db 32 a7 fd			ld (debug_mark+1),a  
29de 3a e8 29			ld a, (.dmark+2)  
29e1 32 a8 fd			ld (debug_mark+2),a  
29e4 18 03			jr .pastdmark  
29e6 ..			.dmark: db "CLL"  
29e9 f1			.pastdmark: pop af  
29ea			endm  
# End of macro DMARK
29ea					CALLMONITOR 
29ea cd aa fd			call debug_vector  
29ed				endm  
# End of macro CALLMONITOR
29ed				endif 
29ed			 
29ed				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29ed cd 34 22			call macro_dsp_valuehl 
29f0				endm 
# End of macro FORTH_DSP_VALUEHL
29f0			 
29f0			;		push hl 
29f0			 
29f0				; destroy value TOS 
29f0			 
29f0				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29f0 cd ec 22			call macro_forth_dsp_pop 
29f3				endm 
# End of macro FORTH_DSP_POP
29f3			 
29f3					 
29f3			;		pop hl 
29f3			 
29f3				; how to do a call with hl???? save SP? 
29f3 cd 8e 23			call forth_call_hl 
29f6			 
29f6			 
29f6				; TODO push value back onto stack for another op etc 
29f6			 
29f6 cd 2f 20			call forth_push_numhl 
29f9				NEXTW 
29f9 c3 ea 23			jp macro_next 
29fc				endm 
# End of macro NEXTW
29fc			.DEPTH: 
29fc			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
29fc 24				db WORD_SYS_CORE+OPCODE_DEPTH             
29fd 39 2a			dw .OVER            
29ff 06				db 5 + 1 
2a00 .. 00			db "DEPTH",0              
2a06				endm 
# End of macro CWHEAD
2a06			; | DEPTH ( -- u ) Push count of stack | DONE 
2a06				; take current TOS and remove from base value div by two to get count 
2a06				if DEBUG_FORTH_WORDS_KEY 
2a06					DMARK "DEP" 
2a06 f5				push af  
2a07 3a 1b 2a			ld a, (.dmark)  
2a0a 32 a6 fd			ld (debug_mark),a  
2a0d 3a 1c 2a			ld a, (.dmark+1)  
2a10 32 a7 fd			ld (debug_mark+1),a  
2a13 3a 1d 2a			ld a, (.dmark+2)  
2a16 32 a8 fd			ld (debug_mark+2),a  
2a19 18 03			jr .pastdmark  
2a1b ..			.dmark: db "DEP"  
2a1e f1			.pastdmark: pop af  
2a1f			endm  
# End of macro DMARK
2a1f					CALLMONITOR 
2a1f cd aa fd			call debug_vector  
2a22				endm  
# End of macro CALLMONITOR
2a22				endif 
2a22			 
2a22			 
2a22 2a 29 f9		ld hl, (cli_data_sp) 
2a25 11 63 f6		ld de, cli_data_stack 
2a28 ed 52		sbc hl,de 
2a2a			 
2a2a			; div by size of stack item 
2a2a			 
2a2a 5d			ld e,l 
2a2b 0e 03		ld c, 3 
2a2d cd 6b 0f		call Div8 
2a30			 
2a30 6f			ld l,a 
2a31 26 00		ld h,0 
2a33			 
2a33			;srl h 
2a33			;rr l 
2a33			 
2a33 cd 2f 20			call forth_push_numhl 
2a36				NEXTW 
2a36 c3 ea 23			jp macro_next 
2a39				endm 
# End of macro NEXTW
2a39			.OVER: 
2a39			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2a39 42				db WORD_SYS_CORE+46             
2a3a 80 2a			dw .PAUSE            
2a3c 05				db 4 + 1 
2a3d .. 00			db "OVER",0              
2a42				endm 
# End of macro CWHEAD
2a42			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2a42				if DEBUG_FORTH_WORDS_KEY 
2a42					DMARK "OVR" 
2a42 f5				push af  
2a43 3a 57 2a			ld a, (.dmark)  
2a46 32 a6 fd			ld (debug_mark),a  
2a49 3a 58 2a			ld a, (.dmark+1)  
2a4c 32 a7 fd			ld (debug_mark+1),a  
2a4f 3a 59 2a			ld a, (.dmark+2)  
2a52 32 a8 fd			ld (debug_mark+2),a  
2a55 18 03			jr .pastdmark  
2a57 ..			.dmark: db "OVR"  
2a5a f1			.pastdmark: pop af  
2a5b			endm  
# End of macro DMARK
2a5b					CALLMONITOR 
2a5b cd aa fd			call debug_vector  
2a5e				endm  
# End of macro CALLMONITOR
2a5e				endif 
2a5e			 
2a5e			; TODO Use os stack swap memory 
2a5e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a5e cd 34 22			call macro_dsp_valuehl 
2a61				endm 
# End of macro FORTH_DSP_VALUEHL
2a61 e5				push hl    ; n2 
2a62				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a62 cd ec 22			call macro_forth_dsp_pop 
2a65				endm 
# End of macro FORTH_DSP_POP
2a65			 
2a65				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a65 cd 34 22			call macro_dsp_valuehl 
2a68				endm 
# End of macro FORTH_DSP_VALUEHL
2a68 e5				push hl    ; n1 
2a69				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a69 cd ec 22			call macro_forth_dsp_pop 
2a6c				endm 
# End of macro FORTH_DSP_POP
2a6c			 
2a6c d1				pop de     ; n1 
2a6d e1				pop hl     ; n2 
2a6e			 
2a6e d5				push de 
2a6f e5				push hl 
2a70 d5				push de 
2a71			 
2a71				; push back  
2a71			 
2a71 e1				pop hl 
2a72 cd 2f 20			call forth_push_numhl 
2a75 e1				pop hl 
2a76 cd 2f 20			call forth_push_numhl 
2a79 e1				pop hl 
2a7a cd 2f 20			call forth_push_numhl 
2a7d				NEXTW 
2a7d c3 ea 23			jp macro_next 
2a80				endm 
# End of macro NEXTW
2a80			 
2a80			.PAUSE: 
2a80			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2a80 43				db WORD_SYS_CORE+47             
2a81 b5 2a			dw .PAUSES            
2a83 08				db 7 + 1 
2a84 .. 00			db "PAUSEMS",0              
2a8c				endm 
# End of macro CWHEAD
2a8c			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2a8c				if DEBUG_FORTH_WORDS_KEY 
2a8c					DMARK "PMS" 
2a8c f5				push af  
2a8d 3a a1 2a			ld a, (.dmark)  
2a90 32 a6 fd			ld (debug_mark),a  
2a93 3a a2 2a			ld a, (.dmark+1)  
2a96 32 a7 fd			ld (debug_mark+1),a  
2a99 3a a3 2a			ld a, (.dmark+2)  
2a9c 32 a8 fd			ld (debug_mark+2),a  
2a9f 18 03			jr .pastdmark  
2aa1 ..			.dmark: db "PMS"  
2aa4 f1			.pastdmark: pop af  
2aa5			endm  
# End of macro DMARK
2aa5					CALLMONITOR 
2aa5 cd aa fd			call debug_vector  
2aa8				endm  
# End of macro CALLMONITOR
2aa8				endif 
2aa8				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2aa8 cd 34 22			call macro_dsp_valuehl 
2aab				endm 
# End of macro FORTH_DSP_VALUEHL
2aab			;		push hl    ; n2 
2aab				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2aab cd ec 22			call macro_forth_dsp_pop 
2aae				endm 
# End of macro FORTH_DSP_POP
2aae			;		pop hl 
2aae			 
2aae 7d				ld a, l 
2aaf cd cf 0c			call aDelayInMS 
2ab2			       NEXTW 
2ab2 c3 ea 23			jp macro_next 
2ab5				endm 
# End of macro NEXTW
2ab5			.PAUSES:  
2ab5			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2ab5 44				db WORD_SYS_CORE+48             
2ab6 24 2b			dw .ROT            
2ab8 06				db 5 + 1 
2ab9 .. 00			db "PAUSE",0              
2abf				endm 
# End of macro CWHEAD
2abf			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2abf				if DEBUG_FORTH_WORDS_KEY 
2abf					DMARK "PAU" 
2abf f5				push af  
2ac0 3a d4 2a			ld a, (.dmark)  
2ac3 32 a6 fd			ld (debug_mark),a  
2ac6 3a d5 2a			ld a, (.dmark+1)  
2ac9 32 a7 fd			ld (debug_mark+1),a  
2acc 3a d6 2a			ld a, (.dmark+2)  
2acf 32 a8 fd			ld (debug_mark+2),a  
2ad2 18 03			jr .pastdmark  
2ad4 ..			.dmark: db "PAU"  
2ad7 f1			.pastdmark: pop af  
2ad8			endm  
# End of macro DMARK
2ad8					CALLMONITOR 
2ad8 cd aa fd			call debug_vector  
2adb				endm  
# End of macro CALLMONITOR
2adb				endif 
2adb				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2adb cd 34 22			call macro_dsp_valuehl 
2ade				endm 
# End of macro FORTH_DSP_VALUEHL
2ade			;		push hl    ; n2 
2ade				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ade cd ec 22			call macro_forth_dsp_pop 
2ae1				endm 
# End of macro FORTH_DSP_POP
2ae1			;		pop hl 
2ae1 45				ld b, l 
2ae2				if DEBUG_FORTH_WORDS 
2ae2					DMARK "PAU" 
2ae2 f5				push af  
2ae3 3a f7 2a			ld a, (.dmark)  
2ae6 32 a6 fd			ld (debug_mark),a  
2ae9 3a f8 2a			ld a, (.dmark+1)  
2aec 32 a7 fd			ld (debug_mark+1),a  
2aef 3a f9 2a			ld a, (.dmark+2)  
2af2 32 a8 fd			ld (debug_mark+2),a  
2af5 18 03			jr .pastdmark  
2af7 ..			.dmark: db "PAU"  
2afa f1			.pastdmark: pop af  
2afb			endm  
# End of macro DMARK
2afb					CALLMONITOR 
2afb cd aa fd			call debug_vector  
2afe				endm  
# End of macro CALLMONITOR
2afe				endif 
2afe c5			.pauses1:	push bc 
2aff cd ea 0c			call delay1s 
2b02 c1				pop bc 
2b03				if DEBUG_FORTH_WORDS 
2b03					DMARK "PA1" 
2b03 f5				push af  
2b04 3a 18 2b			ld a, (.dmark)  
2b07 32 a6 fd			ld (debug_mark),a  
2b0a 3a 19 2b			ld a, (.dmark+1)  
2b0d 32 a7 fd			ld (debug_mark+1),a  
2b10 3a 1a 2b			ld a, (.dmark+2)  
2b13 32 a8 fd			ld (debug_mark+2),a  
2b16 18 03			jr .pastdmark  
2b18 ..			.dmark: db "PA1"  
2b1b f1			.pastdmark: pop af  
2b1c			endm  
# End of macro DMARK
2b1c					CALLMONITOR 
2b1c cd aa fd			call debug_vector  
2b1f				endm  
# End of macro CALLMONITOR
2b1f				endif 
2b1f 10 dd			djnz .pauses1 
2b21			 
2b21			       NEXTW 
2b21 c3 ea 23			jp macro_next 
2b24				endm 
# End of macro NEXTW
2b24			.ROT: 
2b24			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2b24 45				db WORD_SYS_CORE+49             
2b25 72 2b			dw .UWORDS            
2b27 04				db 3 + 1 
2b28 .. 00			db "ROT",0              
2b2c				endm 
# End of macro CWHEAD
2b2c			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2b2c				if DEBUG_FORTH_WORDS_KEY 
2b2c					DMARK "ROT" 
2b2c f5				push af  
2b2d 3a 41 2b			ld a, (.dmark)  
2b30 32 a6 fd			ld (debug_mark),a  
2b33 3a 42 2b			ld a, (.dmark+1)  
2b36 32 a7 fd			ld (debug_mark+1),a  
2b39 3a 43 2b			ld a, (.dmark+2)  
2b3c 32 a8 fd			ld (debug_mark+2),a  
2b3f 18 03			jr .pastdmark  
2b41 ..			.dmark: db "ROT"  
2b44 f1			.pastdmark: pop af  
2b45			endm  
# End of macro DMARK
2b45					CALLMONITOR 
2b45 cd aa fd			call debug_vector  
2b48				endm  
# End of macro CALLMONITOR
2b48				endif 
2b48			 
2b48			; TODO Use os stack swap memory 
2b48				FORTH_DSP_VALUEHL 
2b48 cd 34 22			call macro_dsp_valuehl 
2b4b				endm 
# End of macro FORTH_DSP_VALUEHL
2b4b e5				push hl    ; u3  
2b4c			 
2b4c				FORTH_DSP_POP 
2b4c cd ec 22			call macro_forth_dsp_pop 
2b4f				endm 
# End of macro FORTH_DSP_POP
2b4f			 
2b4f				FORTH_DSP_VALUEHL 
2b4f cd 34 22			call macro_dsp_valuehl 
2b52				endm 
# End of macro FORTH_DSP_VALUEHL
2b52 e5				push hl     ; u2 
2b53			 
2b53				FORTH_DSP_POP 
2b53 cd ec 22			call macro_forth_dsp_pop 
2b56				endm 
# End of macro FORTH_DSP_POP
2b56			 
2b56				FORTH_DSP_VALUEHL 
2b56 cd 34 22			call macro_dsp_valuehl 
2b59				endm 
# End of macro FORTH_DSP_VALUEHL
2b59 e5				push hl     ; u1 
2b5a			 
2b5a				FORTH_DSP_POP 
2b5a cd ec 22			call macro_forth_dsp_pop 
2b5d				endm 
# End of macro FORTH_DSP_POP
2b5d			 
2b5d c1				pop bc      ; u1 
2b5e e1				pop hl      ; u2 
2b5f d1				pop de      ; u3 
2b60			 
2b60			 
2b60 c5				push bc 
2b61 d5				push de 
2b62 e5				push hl 
2b63			 
2b63			 
2b63 e1				pop hl 
2b64 cd 2f 20			call forth_push_numhl 
2b67			 
2b67 e1				pop hl 
2b68 cd 2f 20			call forth_push_numhl 
2b6b			 
2b6b e1				pop hl 
2b6c cd 2f 20			call forth_push_numhl 
2b6f				 
2b6f			 
2b6f			 
2b6f			 
2b6f			 
2b6f			 
2b6f			       NEXTW 
2b6f c3 ea 23			jp macro_next 
2b72				endm 
# End of macro NEXTW
2b72			 
2b72			.UWORDS: 
2b72			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2b72 50				db WORD_SYS_CORE+60             
2b73 34 2c			dw .BP            
2b75 07				db 6 + 1 
2b76 .. 00			db "UWORDS",0              
2b7d				endm 
# End of macro CWHEAD
2b7d			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2b7d			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2b7d			; | | Following the count are the individual words. 
2b7d			; | | 
2b7d			; | | e.g. UWORDS 
2b7d			; | | BOX DIRLIST 2 
2b7d			; | |  
2b7d			; | | Can be used to save the words to storage via: 
2b7d			; | | UWORDS $01 DO $01 APPEND LOOP 
2b7d			if DEBUG_FORTH_WORDS_KEY 
2b7d				DMARK "UWR" 
2b7d f5				push af  
2b7e 3a 92 2b			ld a, (.dmark)  
2b81 32 a6 fd			ld (debug_mark),a  
2b84 3a 93 2b			ld a, (.dmark+1)  
2b87 32 a7 fd			ld (debug_mark+1),a  
2b8a 3a 94 2b			ld a, (.dmark+2)  
2b8d 32 a8 fd			ld (debug_mark+2),a  
2b90 18 03			jr .pastdmark  
2b92 ..			.dmark: db "UWR"  
2b95 f1			.pastdmark: pop af  
2b96			endm  
# End of macro DMARK
2b96				CALLMONITOR 
2b96 cd aa fd			call debug_vector  
2b99				endm  
# End of macro CALLMONITOR
2b99			endif 
2b99 21 00 80			ld hl, baseram 
2b9c				;ld hl, baseusermem 
2b9c 01 00 00			ld bc, 0    ; start a counter 
2b9f			 
2b9f			; skip dict stub 
2b9f			 
2b9f cd 3b 25			call forth_tok_next 
2ba2			 
2ba2			 
2ba2			; while we have words to look for 
2ba2			 
2ba2 7e			.douscan:	ld a, (hl)      
2ba3			if DEBUG_FORTH_WORDS 
2ba3				DMARK "UWs" 
2ba3 f5				push af  
2ba4 3a b8 2b			ld a, (.dmark)  
2ba7 32 a6 fd			ld (debug_mark),a  
2baa 3a b9 2b			ld a, (.dmark+1)  
2bad 32 a7 fd			ld (debug_mark+1),a  
2bb0 3a ba 2b			ld a, (.dmark+2)  
2bb3 32 a8 fd			ld (debug_mark+2),a  
2bb6 18 03			jr .pastdmark  
2bb8 ..			.dmark: db "UWs"  
2bbb f1			.pastdmark: pop af  
2bbc			endm  
# End of macro DMARK
2bbc				CALLMONITOR 
2bbc cd aa fd			call debug_vector  
2bbf				endm  
# End of macro CALLMONITOR
2bbf			endif 
2bbf fe 00			cp WORD_SYS_END 
2bc1 28 4d			jr z, .udone 
2bc3 fe 01			cp WORD_SYS_UWORD 
2bc5 20 44			jr nz, .nuword 
2bc7			 
2bc7			if DEBUG_FORTH_WORDS 
2bc7				DMARK "UWu" 
2bc7 f5				push af  
2bc8 3a dc 2b			ld a, (.dmark)  
2bcb 32 a6 fd			ld (debug_mark),a  
2bce 3a dd 2b			ld a, (.dmark+1)  
2bd1 32 a7 fd			ld (debug_mark+1),a  
2bd4 3a de 2b			ld a, (.dmark+2)  
2bd7 32 a8 fd			ld (debug_mark+2),a  
2bda 18 03			jr .pastdmark  
2bdc ..			.dmark: db "UWu"  
2bdf f1			.pastdmark: pop af  
2be0			endm  
# End of macro DMARK
2be0				CALLMONITOR 
2be0 cd aa fd			call debug_vector  
2be3				endm  
# End of macro CALLMONITOR
2be3			endif 
2be3				; we have a uword so push its name to the stack 
2be3			 
2be3 e5				push hl  ; save so we can move to next dict block 
2be4			 
2be4				; skip opcode 
2be4 23				inc hl  
2be5				; skip next ptr 
2be5 23				inc hl  
2be6 23				inc hl 
2be7				; skip len 
2be7 23				inc hl 
2be8			if DEBUG_FORTH_WORDS 
2be8				DMARK "UWt" 
2be8 f5				push af  
2be9 3a fd 2b			ld a, (.dmark)  
2bec 32 a6 fd			ld (debug_mark),a  
2bef 3a fe 2b			ld a, (.dmark+1)  
2bf2 32 a7 fd			ld (debug_mark+1),a  
2bf5 3a ff 2b			ld a, (.dmark+2)  
2bf8 32 a8 fd			ld (debug_mark+2),a  
2bfb 18 03			jr .pastdmark  
2bfd ..			.dmark: db "UWt"  
2c00 f1			.pastdmark: pop af  
2c01			endm  
# End of macro DMARK
2c01				CALLMONITOR 
2c01 cd aa fd			call debug_vector  
2c04				endm  
# End of macro CALLMONITOR
2c04			endif 
2c04 03				inc bc 
2c05			 
2c05 c5				push bc 
2c06 cd 9d 20			call forth_push_str 
2c09 c1				pop bc 
2c0a			 
2c0a e1				pop hl 	 
2c0b			 
2c0b cd 3b 25		.nuword:	call forth_tok_next 
2c0e 18 92			jr .douscan  
2c10			 
2c10			.udone:		 ; push count of uwords found 
2c10 c5				push bc 
2c11 e1				pop hl 
2c12			 
2c12			if DEBUG_FORTH_WORDS 
2c12				DMARK "UWc" 
2c12 f5				push af  
2c13 3a 27 2c			ld a, (.dmark)  
2c16 32 a6 fd			ld (debug_mark),a  
2c19 3a 28 2c			ld a, (.dmark+1)  
2c1c 32 a7 fd			ld (debug_mark+1),a  
2c1f 3a 29 2c			ld a, (.dmark+2)  
2c22 32 a8 fd			ld (debug_mark+2),a  
2c25 18 03			jr .pastdmark  
2c27 ..			.dmark: db "UWc"  
2c2a f1			.pastdmark: pop af  
2c2b			endm  
# End of macro DMARK
2c2b				CALLMONITOR 
2c2b cd aa fd			call debug_vector  
2c2e				endm  
# End of macro CALLMONITOR
2c2e			endif 
2c2e cd 2f 20			call forth_push_numhl 
2c31			 
2c31			 
2c31			       NEXTW 
2c31 c3 ea 23			jp macro_next 
2c34				endm 
# End of macro NEXTW
2c34			 
2c34			.BP: 
2c34			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2c34 54				db WORD_SYS_CORE+64             
2c35 6e 2c			dw .MONITOR            
2c37 03				db 2 + 1 
2c38 .. 00			db "BP",0              
2c3b				endm 
# End of macro CWHEAD
2c3b			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2c3b			; | | $00 Will enable the break points within specific code paths 
2c3b			; | | $01 Will disable break points 
2c3b			; | |  
2c3b			; | | By default break points are off. Either the above can be used to enable them 
2c3b			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2c3b			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2c3b			; | | can disable break points. Exiting will then continue boot process. 
2c3b				; get byte count 
2c3b				if DEBUG_FORTH_WORDS_KEY 
2c3b					DMARK "BP." 
2c3b f5				push af  
2c3c 3a 50 2c			ld a, (.dmark)  
2c3f 32 a6 fd			ld (debug_mark),a  
2c42 3a 51 2c			ld a, (.dmark+1)  
2c45 32 a7 fd			ld (debug_mark+1),a  
2c48 3a 52 2c			ld a, (.dmark+2)  
2c4b 32 a8 fd			ld (debug_mark+2),a  
2c4e 18 03			jr .pastdmark  
2c50 ..			.dmark: db "BP."  
2c53 f1			.pastdmark: pop af  
2c54			endm  
# End of macro DMARK
2c54					CALLMONITOR 
2c54 cd aa fd			call debug_vector  
2c57				endm  
# End of macro CALLMONITOR
2c57				endif 
2c57			 
2c57				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c57 cd 34 22			call macro_dsp_valuehl 
2c5a				endm 
# End of macro FORTH_DSP_VALUEHL
2c5a			 
2c5a			;		push hl 
2c5a			 
2c5a				; destroy value TOS 
2c5a			 
2c5a				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c5a cd ec 22			call macro_forth_dsp_pop 
2c5d				endm 
# End of macro FORTH_DSP_POP
2c5d			 
2c5d			;		pop hl 
2c5d			 
2c5d 3e 00			ld a,0 
2c5f bd				cp l 
2c60 28 06			jr z, .bpset 
2c62			;		ld a, '*' 
2c62 cd 50 19			call bp_off 
2c65				NEXTW 
2c65 c3 ea 23			jp macro_next 
2c68				endm 
# End of macro NEXTW
2c68			 
2c68			.bpset:	 
2c68				;	ld (os_view_disable), a 
2c68 cd 44 19			call bp_on 
2c6b			 
2c6b			 
2c6b				NEXTW 
2c6b c3 ea 23			jp macro_next 
2c6e				endm 
# End of macro NEXTW
2c6e			 
2c6e			 
2c6e			.MONITOR: 
2c6e			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2c6e 55				db WORD_SYS_CORE+65             
2c6f 9f 2c			dw .MALLOC            
2c71 08				db 7 + 1 
2c72 .. 00			db "MONITOR",0              
2c7a				endm 
# End of macro CWHEAD
2c7a			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2c7a			; | | At start the current various registers will be displayed with contents. 
2c7a			; | | Top right corner will show the most recent debug marker seen. 
2c7a			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2c7a			; | | and the return stack pointer (RSP). 
2c7a			; | | Pressing: 
2c7a			; | |    1 - Initial screen 
2c7a			; | |    2 - Display a data dump of HL 
2c7a			; | |    3 - Display a data dump of DE 
2c7a			; | |    4 - Display a data dump of BC 
2c7a			; | |    5 - Display a data dump of HL 
2c7a			; | |    6 - Display a data dump of DSP 
2c7a			; | |    7 - Display a data dump of RSP 
2c7a			; | |    8 - Display a data dump of what is at DSP 
2c7a			; | |    9 - Display a data dump of what is at RSP 
2c7a			; | |    0 - Exit monitor and continue running. This will also enable break points 
2c7a			; | |    * - Disable break points 
2c7a			; | |    # - Enter traditional monitor mode 
2c7a			; | | 
2c7a			; | | Monitor Mode 
2c7a			; | | ------------ 
2c7a			; | | A prompt of '>' will be shown for various commands: 
2c7a			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2c7a			; | |    C - Continue display a data dump from the last set address 
2c7a			; | |    M xxxx - Set start of memory edit at address xx 
2c7a			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2c7a			; | |    G xxxx - Exec code at specific address 
2c7a			; | |    Q - Return to previous 
2c7a				if DEBUG_FORTH_WORDS_KEY 
2c7a					DMARK "MON" 
2c7a f5				push af  
2c7b 3a 8f 2c			ld a, (.dmark)  
2c7e 32 a6 fd			ld (debug_mark),a  
2c81 3a 90 2c			ld a, (.dmark+1)  
2c84 32 a7 fd			ld (debug_mark+1),a  
2c87 3a 91 2c			ld a, (.dmark+2)  
2c8a 32 a8 fd			ld (debug_mark+2),a  
2c8d 18 03			jr .pastdmark  
2c8f ..			.dmark: db "MON"  
2c92 f1			.pastdmark: pop af  
2c93			endm  
# End of macro DMARK
2c93					CALLMONITOR 
2c93 cd aa fd			call debug_vector  
2c96				endm  
# End of macro CALLMONITOR
2c96				endif 
2c96			;		ld a, 0 
2c96			;		ld (os_view_disable), a 
2c96 cd 44 19			call bp_on 
2c99			 
2c99				CALLMONITOR 
2c99 cd aa fd			call debug_vector  
2c9c				endm  
# End of macro CALLMONITOR
2c9c			 
2c9c			;	call monitor 
2c9c			 
2c9c				NEXTW 
2c9c c3 ea 23			jp macro_next 
2c9f				endm 
# End of macro NEXTW
2c9f			 
2c9f			 
2c9f			.MALLOC: 
2c9f			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2c9f 56				db WORD_SYS_CORE+66             
2ca0 c8 2c			dw .MALLOC2            
2ca2 06				db 5 + 1 
2ca3 .. 00			db "ALLOT",0              
2ca9				endm 
# End of macro CWHEAD
2ca9			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2ca9				if DEBUG_FORTH_WORDS_KEY 
2ca9					DMARK "ALL" 
2ca9 f5				push af  
2caa 3a be 2c			ld a, (.dmark)  
2cad 32 a6 fd			ld (debug_mark),a  
2cb0 3a bf 2c			ld a, (.dmark+1)  
2cb3 32 a7 fd			ld (debug_mark+1),a  
2cb6 3a c0 2c			ld a, (.dmark+2)  
2cb9 32 a8 fd			ld (debug_mark+2),a  
2cbc 18 03			jr .pastdmark  
2cbe ..			.dmark: db "ALL"  
2cc1 f1			.pastdmark: pop af  
2cc2			endm  
# End of macro DMARK
2cc2					CALLMONITOR 
2cc2 cd aa fd			call debug_vector  
2cc5				endm  
# End of macro CALLMONITOR
2cc5				endif 
2cc5 c3 ef 2c			jp .mallocc 
2cc8			.MALLOC2: 
2cc8			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2cc8 56				db WORD_SYS_CORE+66             
2cc9 06 2d			dw .FREE            
2ccb 07				db 6 + 1 
2ccc .. 00			db "MALLOC",0              
2cd3				endm 
# End of macro CWHEAD
2cd3			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2cd3				; get byte count 
2cd3				if DEBUG_FORTH_WORDS_KEY 
2cd3					DMARK "MAL" 
2cd3 f5				push af  
2cd4 3a e8 2c			ld a, (.dmark)  
2cd7 32 a6 fd			ld (debug_mark),a  
2cda 3a e9 2c			ld a, (.dmark+1)  
2cdd 32 a7 fd			ld (debug_mark+1),a  
2ce0 3a ea 2c			ld a, (.dmark+2)  
2ce3 32 a8 fd			ld (debug_mark+2),a  
2ce6 18 03			jr .pastdmark  
2ce8 ..			.dmark: db "MAL"  
2ceb f1			.pastdmark: pop af  
2cec			endm  
# End of macro DMARK
2cec					CALLMONITOR 
2cec cd aa fd			call debug_vector  
2cef				endm  
# End of macro CALLMONITOR
2cef				endif 
2cef			.mallocc: 
2cef				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2cef cd 34 22			call macro_dsp_valuehl 
2cf2				endm 
# End of macro FORTH_DSP_VALUEHL
2cf2			 
2cf2			;		push hl 
2cf2			 
2cf2				; destroy value TOS 
2cf2			 
2cf2				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2cf2 cd ec 22			call macro_forth_dsp_pop 
2cf5				endm 
# End of macro FORTH_DSP_POP
2cf5			 
2cf5			;		pop hl 
2cf5 cd b6 13			call malloc 
2cf8			if DEBUG_FORTH_MALLOC_GUARD 
2cf8 f5				push af 
2cf9 cd 04 10			call ishlzero 
2cfc			;		ld a, l 
2cfc			;		add h 
2cfc			;		cp 0 
2cfc f1				pop af 
2cfd				 
2cfd cc c9 5d			call z,malloc_error 
2d00			endif 
2d00			 
2d00 cd 2f 20			call forth_push_numhl 
2d03				NEXTW 
2d03 c3 ea 23			jp macro_next 
2d06				endm 
# End of macro NEXTW
2d06			 
2d06			.FREE: 
2d06			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2d06 57				db WORD_SYS_CORE+67             
2d07 37 2d			dw .LIST            
2d09 05				db 4 + 1 
2d0a .. 00			db "FREE",0              
2d0f				endm 
# End of macro CWHEAD
2d0f			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2d0f				if DEBUG_FORTH_WORDS_KEY 
2d0f					DMARK "FRE" 
2d0f f5				push af  
2d10 3a 24 2d			ld a, (.dmark)  
2d13 32 a6 fd			ld (debug_mark),a  
2d16 3a 25 2d			ld a, (.dmark+1)  
2d19 32 a7 fd			ld (debug_mark+1),a  
2d1c 3a 26 2d			ld a, (.dmark+2)  
2d1f 32 a8 fd			ld (debug_mark+2),a  
2d22 18 03			jr .pastdmark  
2d24 ..			.dmark: db "FRE"  
2d27 f1			.pastdmark: pop af  
2d28			endm  
# End of macro DMARK
2d28					CALLMONITOR 
2d28 cd aa fd			call debug_vector  
2d2b				endm  
# End of macro CALLMONITOR
2d2b				endif 
2d2b				; get address 
2d2b			 
2d2b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d2b cd 34 22			call macro_dsp_valuehl 
2d2e				endm 
# End of macro FORTH_DSP_VALUEHL
2d2e			 
2d2e			;		push hl 
2d2e			 
2d2e				; destroy value TOS 
2d2e			 
2d2e				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d2e cd ec 22			call macro_forth_dsp_pop 
2d31				endm 
# End of macro FORTH_DSP_POP
2d31			 
2d31			;		pop hl 
2d31			if FORTH_ENABLE_MALLOCFREE 
2d31 cd 80 14			call free 
2d34			endif 
2d34				NEXTW 
2d34 c3 ea 23			jp macro_next 
2d37				endm 
# End of macro NEXTW
2d37			.LIST: 
2d37			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2d37 5c				db WORD_SYS_CORE+72             
2d38 33 2f			dw .FORGET            
2d3a 05				db 4 + 1 
2d3b .. 00			db "LIST",0              
2d40				endm 
# End of macro CWHEAD
2d40			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2d40			; | | The quoted word must be in upper case. 
2d40			if DEBUG_FORTH_WORDS_KEY 
2d40				DMARK "LST" 
2d40 f5				push af  
2d41 3a 55 2d			ld a, (.dmark)  
2d44 32 a6 fd			ld (debug_mark),a  
2d47 3a 56 2d			ld a, (.dmark+1)  
2d4a 32 a7 fd			ld (debug_mark+1),a  
2d4d 3a 57 2d			ld a, (.dmark+2)  
2d50 32 a8 fd			ld (debug_mark+2),a  
2d53 18 03			jr .pastdmark  
2d55 ..			.dmark: db "LST"  
2d58 f1			.pastdmark: pop af  
2d59			endm  
# End of macro DMARK
2d59				CALLMONITOR 
2d59 cd aa fd			call debug_vector  
2d5c				endm  
# End of macro CALLMONITOR
2d5c			endif 
2d5c			 
2d5c				FORTH_DSP_VALUEHL 
2d5c cd 34 22			call macro_dsp_valuehl 
2d5f				endm 
# End of macro FORTH_DSP_VALUEHL
2d5f			 
2d5f e5				push hl 
2d60				FORTH_DSP_POP 
2d60 cd ec 22			call macro_forth_dsp_pop 
2d63				endm 
# End of macro FORTH_DSP_POP
2d63 c1				pop bc 
2d64			 
2d64			; Start format of scratch string 
2d64			 
2d64 21 fc f0			ld hl, scratch 
2d67			 
2d67 3e 3a			ld a, ':' 
2d69 77				ld (hl),a 
2d6a 23				inc hl 
2d6b 3e 20			ld a, ' ' 
2d6d 77				ld (hl), a 
2d6e			 
2d6e				; Get ptr to the word we need to look up 
2d6e			 
2d6e			;		FORTH_DSP_VALUEHL 
2d6e				;v5 FORTH_DSP_VALUE 
2d6e			; TODO type check 
2d6e			;		inc hl    ; Skip type check  
2d6e			;		push hl 
2d6e			;		ex de, hl    ; put into DE 
2d6e			 
2d6e			 
2d6e 21 00 80			ld hl, baseram 
2d71				;ld hl, baseusermem 
2d71			 
2d71 e5			push hl   ; sacreifical push 
2d72			 
2d72			.ldouscanm: 
2d72 e1			pop hl 
2d73			.ldouscan: 
2d73			if DEBUG_FORTH_WORDS 
2d73				DMARK "LSs" 
2d73 f5				push af  
2d74 3a 88 2d			ld a, (.dmark)  
2d77 32 a6 fd			ld (debug_mark),a  
2d7a 3a 89 2d			ld a, (.dmark+1)  
2d7d 32 a7 fd			ld (debug_mark+1),a  
2d80 3a 8a 2d			ld a, (.dmark+2)  
2d83 32 a8 fd			ld (debug_mark+2),a  
2d86 18 03			jr .pastdmark  
2d88 ..			.dmark: db "LSs"  
2d8b f1			.pastdmark: pop af  
2d8c			endm  
# End of macro DMARK
2d8c				CALLMONITOR 
2d8c cd aa fd			call debug_vector  
2d8f				endm  
# End of macro CALLMONITOR
2d8f			endif 
2d8f			; skip dict stub 
2d8f cd 3b 25			call forth_tok_next 
2d92			 
2d92			 
2d92			; while we have words to look for 
2d92			 
2d92 7e			ld a, (hl)      
2d93			if DEBUG_FORTH_WORDS 
2d93				DMARK "LSk" 
2d93 f5				push af  
2d94 3a a8 2d			ld a, (.dmark)  
2d97 32 a6 fd			ld (debug_mark),a  
2d9a 3a a9 2d			ld a, (.dmark+1)  
2d9d 32 a7 fd			ld (debug_mark+1),a  
2da0 3a aa 2d			ld a, (.dmark+2)  
2da3 32 a8 fd			ld (debug_mark+2),a  
2da6 18 03			jr .pastdmark  
2da8 ..			.dmark: db "LSk"  
2dab f1			.pastdmark: pop af  
2dac			endm  
# End of macro DMARK
2dac				CALLMONITOR 
2dac cd aa fd			call debug_vector  
2daf				endm  
# End of macro CALLMONITOR
2daf			endif 
2daf				;cp WORD_SYS_END 
2daf				;jp z, .lunotfound 
2daf			 
2daf					; if we hit non uwords then gone too far 
2daf fe 01				cp WORD_SYS_UWORD 
2db1 c2 ef 2e				jp nz, .lunotfound 
2db4			 
2db4				if DEBUG_FORTH_WORDS 
2db4					DMARK "LSu" 
2db4 f5				push af  
2db5 3a c9 2d			ld a, (.dmark)  
2db8 32 a6 fd			ld (debug_mark),a  
2dbb 3a ca 2d			ld a, (.dmark+1)  
2dbe 32 a7 fd			ld (debug_mark+1),a  
2dc1 3a cb 2d			ld a, (.dmark+2)  
2dc4 32 a8 fd			ld (debug_mark+2),a  
2dc7 18 03			jr .pastdmark  
2dc9 ..			.dmark: db "LSu"  
2dcc f1			.pastdmark: pop af  
2dcd			endm  
# End of macro DMARK
2dcd					CALLMONITOR 
2dcd cd aa fd			call debug_vector  
2dd0				endm  
# End of macro CALLMONITOR
2dd0				endif 
2dd0			 
2dd0					; found a uword but is it the one we want... 
2dd0			 
2dd0 c5					push bc     ; uword to find is on bc 
2dd1 d1					pop de 
2dd2			 
2dd2 e5					push hl  ; to save the ptr 
2dd3			 
2dd3					; skip opcode 
2dd3 23					inc hl  
2dd4					; skip next ptr 
2dd4 23					inc hl  
2dd5 23					inc hl 
2dd6					; skip len 
2dd6 23					inc hl 
2dd7			 
2dd7				if DEBUG_FORTH_WORDS 
2dd7					DMARK "LSc" 
2dd7 f5				push af  
2dd8 3a ec 2d			ld a, (.dmark)  
2ddb 32 a6 fd			ld (debug_mark),a  
2dde 3a ed 2d			ld a, (.dmark+1)  
2de1 32 a7 fd			ld (debug_mark+1),a  
2de4 3a ee 2d			ld a, (.dmark+2)  
2de7 32 a8 fd			ld (debug_mark+2),a  
2dea 18 03			jr .pastdmark  
2dec ..			.dmark: db "LSc"  
2def f1			.pastdmark: pop af  
2df0			endm  
# End of macro DMARK
2df0					CALLMONITOR 
2df0 cd aa fd			call debug_vector  
2df3				endm  
# End of macro CALLMONITOR
2df3				endif 
2df3			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2df3			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2df3			; Nope that has gone the other way. It needs to be exact not on first zero 
2df3			;		call strcmp 
2df3 c5					push bc 
2df4 cd 86 13				call StrictStrCmp 
2df7 c1					pop bc 
2df8 c2 72 2d				jp nz, .ldouscanm 
2dfb				 
2dfb			 
2dfb			 
2dfb					; we have a uword so push its name to the stack 
2dfb			 
2dfb			;	   	push hl  ; save so we can move to next dict block 
2dfb e1			pop hl 
2dfc			 
2dfc				if DEBUG_FORTH_WORDS 
2dfc					DMARK "LSm" 
2dfc f5				push af  
2dfd 3a 11 2e			ld a, (.dmark)  
2e00 32 a6 fd			ld (debug_mark),a  
2e03 3a 12 2e			ld a, (.dmark+1)  
2e06 32 a7 fd			ld (debug_mark+1),a  
2e09 3a 13 2e			ld a, (.dmark+2)  
2e0c 32 a8 fd			ld (debug_mark+2),a  
2e0f 18 03			jr .pastdmark  
2e11 ..			.dmark: db "LSm"  
2e14 f1			.pastdmark: pop af  
2e15			endm  
# End of macro DMARK
2e15					CALLMONITOR 
2e15 cd aa fd			call debug_vector  
2e18				endm  
# End of macro CALLMONITOR
2e18				endif 
2e18			 
2e18					; skip opcode 
2e18 23					inc hl  
2e19					; skip next ptr 
2e19 23					inc hl  
2e1a 23					inc hl 
2e1b					; skip len 
2e1b 7e					ld a, (hl)   ; save length to add 
2e1c				if DEBUG_FORTH_WORDS 
2e1c					DMARK "LS2" 
2e1c f5				push af  
2e1d 3a 31 2e			ld a, (.dmark)  
2e20 32 a6 fd			ld (debug_mark),a  
2e23 3a 32 2e			ld a, (.dmark+1)  
2e26 32 a7 fd			ld (debug_mark+1),a  
2e29 3a 33 2e			ld a, (.dmark+2)  
2e2c 32 a8 fd			ld (debug_mark+2),a  
2e2f 18 03			jr .pastdmark  
2e31 ..			.dmark: db "LS2"  
2e34 f1			.pastdmark: pop af  
2e35			endm  
# End of macro DMARK
2e35					CALLMONITOR 
2e35 cd aa fd			call debug_vector  
2e38				endm  
# End of macro CALLMONITOR
2e38				endif 
2e38			 
2e38					; save this location 
2e38				 
2e38 e5					push hl 
2e39			 
2e39 23					inc hl 
2e3a 11 fe f0				ld de, scratch+2 
2e3d 4f					ld c, a 
2e3e 06 00				ld b, 0 
2e40			 
2e40				if DEBUG_FORTH_WORDS 
2e40					DMARK "LSn" 
2e40 f5				push af  
2e41 3a 55 2e			ld a, (.dmark)  
2e44 32 a6 fd			ld (debug_mark),a  
2e47 3a 56 2e			ld a, (.dmark+1)  
2e4a 32 a7 fd			ld (debug_mark+1),a  
2e4d 3a 57 2e			ld a, (.dmark+2)  
2e50 32 a8 fd			ld (debug_mark+2),a  
2e53 18 03			jr .pastdmark  
2e55 ..			.dmark: db "LSn"  
2e58 f1			.pastdmark: pop af  
2e59			endm  
# End of macro DMARK
2e59					CALLMONITOR 
2e59 cd aa fd			call debug_vector  
2e5c				endm  
# End of macro CALLMONITOR
2e5c				endif 
2e5c			 
2e5c					; copy uword name to scratch 
2e5c			 
2e5c			;		ldir 
2e5c			.licplw:	; copy uword name to scratch converting to lower case as we go 
2e5c ed a0				ldi 
2e5e 1b					dec de 
2e5f 1a					ld a, (de) 
2e60 cd 59 12				call to_lower 
2e63 12					ld (de),a 
2e64 13					inc de 
2e65 3e 00				ld a, 0 
2e67 b9					cp c 
2e68 20 f2				jr nz, .licplw 
2e6a			 
2e6a			 
2e6a			 
2e6a 1b					dec de 
2e6b 3e 20				ld a, ' '    ; change null to space 
2e6d 12					ld (de), a 
2e6e			 
2e6e 13					inc de 
2e6f			 
2e6f d5					push de 
2e70 c1					pop bc     ; move scratch pointer to end of word name and save it 
2e71			 
2e71 e1					pop hl 
2e72 7e					ld a, (hl) 
2e73					;inc hl 
2e73					; skip word string 
2e73 cd db 0f				call addatohl 
2e76			 
2e76 23					inc hl 
2e77			 
2e77				if DEBUG_FORTH_WORDS 
2e77					DMARK "LS3" 
2e77 f5				push af  
2e78 3a 8c 2e			ld a, (.dmark)  
2e7b 32 a6 fd			ld (debug_mark),a  
2e7e 3a 8d 2e			ld a, (.dmark+1)  
2e81 32 a7 fd			ld (debug_mark+1),a  
2e84 3a 8e 2e			ld a, (.dmark+2)  
2e87 32 a8 fd			ld (debug_mark+2),a  
2e8a 18 03			jr .pastdmark  
2e8c ..			.dmark: db "LS3"  
2e8f f1			.pastdmark: pop af  
2e90			endm  
# End of macro DMARK
2e90					CALLMONITOR 
2e90 cd aa fd			call debug_vector  
2e93				endm  
# End of macro CALLMONITOR
2e93				endif 
2e93					; should now be at the start of the machine code to setup the eval of the uword 
2e93					; now locate the ptr to the string defintion 
2e93			 
2e93					; skip ld hl, 
2e93					; then load the ptr 
2e93			; TODO use get from hl ptr 
2e93 23					inc hl 
2e94 5e					ld e, (hl) 
2e95 23					inc hl 
2e96 56					ld d, (hl) 
2e97 eb					ex de, hl 
2e98			 
2e98			 
2e98				if DEBUG_FORTH_WORDS 
2e98					DMARK "LSt" 
2e98 f5				push af  
2e99 3a ad 2e			ld a, (.dmark)  
2e9c 32 a6 fd			ld (debug_mark),a  
2e9f 3a ae 2e			ld a, (.dmark+1)  
2ea2 32 a7 fd			ld (debug_mark+1),a  
2ea5 3a af 2e			ld a, (.dmark+2)  
2ea8 32 a8 fd			ld (debug_mark+2),a  
2eab 18 03			jr .pastdmark  
2ead ..			.dmark: db "LSt"  
2eb0 f1			.pastdmark: pop af  
2eb1			endm  
# End of macro DMARK
2eb1					CALLMONITOR 
2eb1 cd aa fd			call debug_vector  
2eb4				endm  
# End of macro CALLMONITOR
2eb4				endif 
2eb4			 
2eb4			; cant push right now due to tokenised strings  
2eb4			 
2eb4			; get the destination of where to copy this definition to. 
2eb4			 
2eb4 c5					push bc 
2eb5 d1					pop de 
2eb6			 
2eb6 7e			.listl:         ld a,(hl) 
2eb7 fe 00				cp 0 
2eb9 28 09				jr z, .lreplsp     ; replace zero with space 
2ebb					;cp FORTH_END_BUFFER 
2ebb fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2ebd 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2ebf				 
2ebf					; just copy this char as is then 
2ebf			 
2ebf 12					ld (de), a 
2ec0			 
2ec0 23			.listnxt:	inc hl 
2ec1 13					inc de 
2ec2 18 f2				jr .listl 
2ec4			 
2ec4 3e 20		.lreplsp:	ld a,' ' 
2ec6 12					ld (de), a 
2ec7 18 f7				jr .listnxt 
2ec9			 
2ec9			; close up uword def 
2ec9			 
2ec9			.listdone: 
2ec9 12					ld (de), a 
2eca 13					inc de 
2ecb 3e 00				ld a, 0 
2ecd 12					ld (de), a 
2ece			 
2ece			; now have def so clean up and push to stack 
2ece			 
2ece 21 fc f0				ld hl, scratch 
2ed1				if DEBUG_FORTH_WORDS 
2ed1					DMARK "Ltp" 
2ed1 f5				push af  
2ed2 3a e6 2e			ld a, (.dmark)  
2ed5 32 a6 fd			ld (debug_mark),a  
2ed8 3a e7 2e			ld a, (.dmark+1)  
2edb 32 a7 fd			ld (debug_mark+1),a  
2ede 3a e8 2e			ld a, (.dmark+2)  
2ee1 32 a8 fd			ld (debug_mark+2),a  
2ee4 18 03			jr .pastdmark  
2ee6 ..			.dmark: db "Ltp"  
2ee9 f1			.pastdmark: pop af  
2eea			endm  
# End of macro DMARK
2eea					CALLMONITOR 
2eea cd aa fd			call debug_vector  
2eed				endm  
# End of macro CALLMONITOR
2eed				endif 
2eed			 
2eed 18 1f			jr .listpush 
2eef			 
2eef			;.lnuword:	pop hl 
2eef			;		call forth_tok_next 
2eef			;		jp .ldouscan  
2eef			 
2eef			.lunotfound:		  
2eef			 
2eef				if DEBUG_FORTH_WORDS 
2eef					DMARK "LSn" 
2eef f5				push af  
2ef0 3a 04 2f			ld a, (.dmark)  
2ef3 32 a6 fd			ld (debug_mark),a  
2ef6 3a 05 2f			ld a, (.dmark+1)  
2ef9 32 a7 fd			ld (debug_mark+1),a  
2efc 3a 06 2f			ld a, (.dmark+2)  
2eff 32 a8 fd			ld (debug_mark+2),a  
2f02 18 03			jr .pastdmark  
2f04 ..			.dmark: db "LSn"  
2f07 f1			.pastdmark: pop af  
2f08			endm  
# End of macro DMARK
2f08					CALLMONITOR 
2f08 cd aa fd			call debug_vector  
2f0b				endm  
# End of macro CALLMONITOR
2f0b				endif 
2f0b			 
2f0b					 
2f0b			;		FORTH_DSP_POP 
2f0b			;		ld hl, .luno 
2f0b			 
2f0b					NEXTW			 
2f0b c3 ea 23			jp macro_next 
2f0e				endm 
# End of macro NEXTW
2f0e			 
2f0e			.listpush: 
2f0e				if DEBUG_FORTH_WORDS 
2f0e					DMARK "LS>" 
2f0e f5				push af  
2f0f 3a 23 2f			ld a, (.dmark)  
2f12 32 a6 fd			ld (debug_mark),a  
2f15 3a 24 2f			ld a, (.dmark+1)  
2f18 32 a7 fd			ld (debug_mark+1),a  
2f1b 3a 25 2f			ld a, (.dmark+2)  
2f1e 32 a8 fd			ld (debug_mark+2),a  
2f21 18 03			jr .pastdmark  
2f23 ..			.dmark: db "LS>"  
2f26 f1			.pastdmark: pop af  
2f27			endm  
# End of macro DMARK
2f27					CALLMONITOR 
2f27 cd aa fd			call debug_vector  
2f2a				endm  
# End of macro CALLMONITOR
2f2a				endif 
2f2a cd 9d 20				call forth_push_str 
2f2d			 
2f2d			 
2f2d			 
2f2d					NEXTW 
2f2d c3 ea 23			jp macro_next 
2f30				endm 
# End of macro NEXTW
2f30			 
2f30			;.luno:    db "Word not found",0 
2f30			 
2f30			 
2f30			 
2f30			 
2f30			 
2f30			;		push hl   ; save pointer to start of uword def string 
2f30			; 
2f30			;; look for FORTH_EOL_LINE 
2f30			;		ld a, FORTH_END_BUFFER 
2f30			;		call strlent 
2f30			; 
2f30			;		inc hl		 ; space for coln def 
2f30			;		inc hl 
2f30			;		inc hl          ; space for terms 
2f30			;		inc hl 
2f30			; 
2f30			;		ld a, 20   ; TODO get actual length 
2f30			;		call addatohl    ; include a random amount of room for the uword name 
2f30			; 
2f30			;		 
2f30			;	if DEBUG_FORTH_WORDS 
2f30			;		DMARK "Lt1" 
2f30			;		CALLMONITOR 
2f30			;	endif 
2f30			;		 
2f30			; 
2f30			;; malloc space for the string because we cant change it 
2f30			; 
2f30			;		call malloc 
2f30			;	if DEBUG_FORTH_MALLOC_GUARD 
2f30			;		push af 
2f30			;		call ishlzero 
2f30			;		pop af 
2f30			;		 
2f30			;		call z,malloc_error 
2f30			;	endif 
2f30			; 
2f30			;	if DEBUG_FORTH_WORDS 
2f30			;		DMARK "Lt2" 
2f30			;		CALLMONITOR 
2f30			;	endif 
2f30			;		pop de 
2f30			;		push hl    ; push the malloc to release later 
2f30			;		push hl   ;  push back a copy for the later stack push 
2f30			;		 
2f30			;; copy the string swapping out the zero terms for spaces 
2f30			; 
2f30			;		; de has our source 
2f30			;		; hl has our dest 
2f30			; 
2f30			;; add the coln def 
2f30			; 
2f30			;		ld a, ':' 
2f30			;		ld (hl), a 
2f30			;		inc hl 
2f30			;		ld a, ' ' 
2f30			;		ld (hl), a 
2f30			;		inc hl 
2f30			; 
2f30			;; add the uname word 
2f30			;		push de   ; save our string for now 
2f30			;		ex de, hl 
2f30			; 
2f30			;		FORTH_DSP_VALUE 
2f30			;		;v5 FORTH_DSP_VALUE 
2f30			; 
2f30			;		inc hl   ; skip type but we know by now this is OK 
2f30			; 
2f30			;.luword:	ld a,(hl) 
2f30			;		cp 0 
2f30			;		jr z, .luword2 
2f30			;		ld (de), a 
2f30			;		inc de 
2f30			;		inc hl 
2f30			;		jr .luword 
2f30			; 
2f30			;.luword2:	ld a, ' ' 
2f30			;		ld (de), a 
2f30			;;		inc hl 
2f30			;;		inc de 
2f30			;;		ld (de), a 
2f30			;;		inc hl 
2f30			;		inc de 
2f30			; 
2f30			;		ex de, hl 
2f30			;		pop de 
2f30			;		 
2f30			;		 
2f30			; 
2f30			;; detoken that string and copy it 
2f30			; 
2f30			;	if DEBUG_FORTH_WORDS 
2f30			;		DMARK "Lt2" 
2f30			;		CALLMONITOR 
2f30			;	endif 
2f30			;.ldetok:	ld a, (de) 
2f30			;		cp FORTH_END_BUFFER 
2f30			;		jr z, .ldetokend 
2f30			;		; swap out any zero term for space 
2f30			;		cp 0 
2f30			;		jr nz, .ldetoknext 
2f30			;		ld a, ' ' 
2f30			; 
2f30			;	if DEBUG_FORTH_WORDS 
2f30			;		DMARK "LtS" 
2f30			;		CALLMONITOR 
2f30			;	endif 
2f30			;.ldetoknext:	ld (hl), a 
2f30			;		inc de 
2f30			;		inc hl 
2f30			;		jr .ldetok 
2f30			; 
2f30			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2f30			;		ld (hl), a  
2f30			; 
2f30			;; free that temp malloc 
2f30			; 
2f30			;		pop hl    
2f30			; 
2f30			;	if DEBUG_FORTH_WORDS 
2f30			;		DMARK "Lt4" 
2f30			;		CALLMONITOR 
2f30			;	endif 
2f30			;		call forth_apushstrhl 
2f30			; 
2f30			;		; get rid of temp malloc area 
2f30			; 
2f30			;		pop hl 
2f30			;		call free 
2f30			; 
2f30			;		jr .ludone 
2f30			; 
2f30			;.lnuword:	pop hl 
2f30			;		call forth_tok_next 
2f30			;		jp .ldouscan  
2f30			; 
2f30			;.ludone:		 pop hl 
2f30			; 
2f30					NEXTW 
2f30 c3 ea 23			jp macro_next 
2f33				endm 
# End of macro NEXTW
2f33			 
2f33			.FORGET: 
2f33				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2f33 5d				db WORD_SYS_CORE+73             
2f34 ac 2f			dw .NOP            
2f36 07				db 6 + 1 
2f37 .. 00			db "FORGET",0              
2f3e				endm 
# End of macro CWHEAD
2f3e			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2f3e			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2f3e			; | |  
2f3e			; | | e.g. "MORE" forget 
2f3e					if DEBUG_FORTH_WORDS_KEY 
2f3e						DMARK "FRG" 
2f3e f5				push af  
2f3f 3a 53 2f			ld a, (.dmark)  
2f42 32 a6 fd			ld (debug_mark),a  
2f45 3a 54 2f			ld a, (.dmark+1)  
2f48 32 a7 fd			ld (debug_mark+1),a  
2f4b 3a 55 2f			ld a, (.dmark+2)  
2f4e 32 a8 fd			ld (debug_mark+2),a  
2f51 18 03			jr .pastdmark  
2f53 ..			.dmark: db "FRG"  
2f56 f1			.pastdmark: pop af  
2f57			endm  
# End of macro DMARK
2f57						CALLMONITOR 
2f57 cd aa fd			call debug_vector  
2f5a				endm  
# End of macro CALLMONITOR
2f5a					endif 
2f5a			 
2f5a				; find uword 
2f5a			        ; update start of word with "_" 
2f5a				; replace uword with deleted flag 
2f5a			 
2f5a			 
2f5a			;	if DEBUG_FORTH_WORDS 
2f5a			;		DMARK "FOG" 
2f5a			;		CALLMONITOR 
2f5a			;	endif 
2f5a			 
2f5a			 
2f5a					; Get ptr to the word we need to look up 
2f5a			 
2f5a					FORTH_DSP_VALUEHL 
2f5a cd 34 22			call macro_dsp_valuehl 
2f5d				endm 
# End of macro FORTH_DSP_VALUEHL
2f5d					;v5 FORTH_DSP_VALUE 
2f5d				; TODO type check 
2f5d			;		inc hl    ; Skip type check  
2f5d e5					push hl 
2f5e c1					pop bc 
2f5f			;		ex de, hl    ; put into DE 
2f5f			 
2f5f			 
2f5f 21 00 80				ld hl, baseram 
2f62					;ld hl, baseusermem 
2f62			 
2f62				; skip dict stub 
2f62			;	call forth_tok_next 
2f62 e5			push hl   ; sacreifical push 
2f63			 
2f63			.fldouscanm: 
2f63 e1				pop hl 
2f64			.fldouscan: 
2f64			;	if DEBUG_FORTH_WORDS 
2f64			;		DMARK "LSs" 
2f64			;		CALLMONITOR 
2f64			;	endif 
2f64				; skip dict stub 
2f64 cd 3b 25				call forth_tok_next 
2f67			 
2f67			 
2f67			; while we have words to look for 
2f67			 
2f67 7e				ld a, (hl)      
2f68			;	if DEBUG_FORTH_WORDS 
2f68			;		DMARK "LSk" 
2f68			;		CALLMONITOR 
2f68			;	endif 
2f68 fe 00				cp WORD_SYS_END 
2f6a ca a6 2f				jp z, .flunotfound 
2f6d fe 01				cp WORD_SYS_UWORD 
2f6f c2 64 2f				jp nz, .fldouscan 
2f72			 
2f72			;	if DEBUG_FORTH_WORDS 
2f72			;		DMARK "LSu" 
2f72			;		CALLMONITOR 
2f72			;	endif 
2f72			 
2f72					; found a uword but is it the one we want... 
2f72			 
2f72 c5					push bc     ; uword to find is on bc 
2f73 d1					pop de 
2f74			 
2f74 e5					push hl  ; to save the ptr 
2f75			 
2f75					; skip opcode 
2f75 23					inc hl  
2f76					; skip next ptr 
2f76 23					inc hl  
2f77 23					inc hl 
2f78					; skip len 
2f78 23					inc hl 
2f79			 
2f79			;	if DEBUG_FORTH_WORDS 
2f79			;		DMARK "LSc" 
2f79			;		CALLMONITOR 
2f79			;	endif 
2f79 cd 79 13				call strcmp 
2f7c c2 63 2f				jp nz, .fldouscanm 
2f7f			; 
2f7f			; 
2f7f			;; while we have words to look for 
2f7f			; 
2f7f			;.fdouscan:	ld a, (hl)      
2f7f			;	if DEBUG_FORTH_WORDS 
2f7f			;		DMARK "LSs" 
2f7f			;		CALLMONITOR 
2f7f			;	endif 
2f7f			;		cp WORD_SYS_END 
2f7f			;		jp z, .fudone 
2f7f			;		cp WORD_SYS_UWORD 
2f7f			;		jp nz, .fnuword 
2f7f			; 
2f7f			;	if DEBUG_FORTH_WORDS 
2f7f			;		DMARK "FGu" 
2f7f			;		CALLMONITOR 
2f7f			;	endif 
2f7f			; 
2f7f			;		; found a uword but is it the one we want... 
2f7f			; 
2f7f			; 
2f7f			;	        pop de   ; get back the dsp name 
2f7f			;		push de 
2f7f			; 
2f7f			;		push hl  ; to save the ptr 
2f7f			; 
2f7f			;		; skip opcode 
2f7f			;		inc hl  
2f7f			;		; skip next ptr 
2f7f			;		inc hl  
2f7f			;		inc hl 
2f7f			;		; skip len 
2f7f			;		inc hl 
2f7f			; 
2f7f			;	if DEBUG_FORTH_WORDS 
2f7f			;		DMARK "FGc" 
2f7f			;		CALLMONITOR 
2f7f			;	endif 
2f7f			;		call strcmp 
2f7f			;		jp nz, .fnuword 
2f7f			 
2f7f			 
2f7f e1			pop hl 
2f80			 
2f80				 
2f80				if DEBUG_FORTH_WORDS 
2f80					DMARK "FGm" 
2f80 f5				push af  
2f81 3a 95 2f			ld a, (.dmark)  
2f84 32 a6 fd			ld (debug_mark),a  
2f87 3a 96 2f			ld a, (.dmark+1)  
2f8a 32 a7 fd			ld (debug_mark+1),a  
2f8d 3a 97 2f			ld a, (.dmark+2)  
2f90 32 a8 fd			ld (debug_mark+2),a  
2f93 18 03			jr .pastdmark  
2f95 ..			.dmark: db "FGm"  
2f98 f1			.pastdmark: pop af  
2f99			endm  
# End of macro DMARK
2f99					CALLMONITOR 
2f99 cd aa fd			call debug_vector  
2f9c				endm  
# End of macro CALLMONITOR
2f9c				endif 
2f9c			 
2f9c			 
2f9c			 
2f9c					; we have a uword so push its name to the stack 
2f9c			 
2f9c			;	   	push hl  ; save so we can move to next dict block 
2f9c			;pop hl 
2f9c			 
2f9c					; update opcode to deleted 
2f9c 3e 03				ld a, WORD_SYS_DELETED 
2f9e 77					ld (hl), a 
2f9f			 
2f9f 23					inc hl  
2fa0					; skip next ptr 
2fa0 23					inc hl  
2fa1 23					inc hl 
2fa2					; skip len 
2fa2 23					inc hl 
2fa3			 
2fa3					; TODO change parser to skip deleted words but for now mark it out 
2fa3 3e 5f				ld a, "_" 
2fa5 77					ld  (hl),a 
2fa6			 
2fa6			;		jr .fudone 
2fa6			; 
2fa6			;.fnuword:	pop hl 
2fa6			;		call forth_tok_next 
2fa6			;		jp .fdouscan  
2fa6			 
2fa6			.flunotfound:		  
2fa6			 
2fa6			 
2fa6					 
2fa6					FORTH_DSP_POP 
2fa6 cd ec 22			call macro_forth_dsp_pop 
2fa9				endm 
# End of macro FORTH_DSP_POP
2fa9			;		ld hl, .luno 
2fa9			;.fudone:		 pop hl 
2fa9					NEXTW 
2fa9 c3 ea 23			jp macro_next 
2fac				endm 
# End of macro NEXTW
2fac			.NOP: 
2fac				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2fac 61				db WORD_SYS_CORE+77             
2fad d3 2f			dw .COMO            
2faf 04				db 3 + 1 
2fb0 .. 00			db "NOP",0              
2fb4				endm 
# End of macro CWHEAD
2fb4			; | NOP (  --  ) Do nothing | DONE 
2fb4					if DEBUG_FORTH_WORDS_KEY 
2fb4						DMARK "NOP" 
2fb4 f5				push af  
2fb5 3a c9 2f			ld a, (.dmark)  
2fb8 32 a6 fd			ld (debug_mark),a  
2fbb 3a ca 2f			ld a, (.dmark+1)  
2fbe 32 a7 fd			ld (debug_mark+1),a  
2fc1 3a cb 2f			ld a, (.dmark+2)  
2fc4 32 a8 fd			ld (debug_mark+2),a  
2fc7 18 03			jr .pastdmark  
2fc9 ..			.dmark: db "NOP"  
2fcc f1			.pastdmark: pop af  
2fcd			endm  
# End of macro DMARK
2fcd						CALLMONITOR 
2fcd cd aa fd			call debug_vector  
2fd0				endm  
# End of macro CALLMONITOR
2fd0					endif 
2fd0				       NEXTW 
2fd0 c3 ea 23			jp macro_next 
2fd3				endm 
# End of macro NEXTW
2fd3			.COMO: 
2fd3				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2fd3 6e				db WORD_SYS_CORE+90             
2fd4 25 30			dw .COMC            
2fd6 02				db 1 + 1 
2fd7 .. 00			db "(",0              
2fd9				endm 
# End of macro CWHEAD
2fd9			; | ( ( -- )  Start of comment | DONE 
2fd9			 
2fd9			 
2fd9 2a fd f3				ld hl, ( os_tok_ptr) 
2fdc 11 20 30			ld de, .closepar 
2fdf					 
2fdf					if DEBUG_FORTH_WORDS 
2fdf						DMARK ").." 
2fdf f5				push af  
2fe0 3a f4 2f			ld a, (.dmark)  
2fe3 32 a6 fd			ld (debug_mark),a  
2fe6 3a f5 2f			ld a, (.dmark+1)  
2fe9 32 a7 fd			ld (debug_mark+1),a  
2fec 3a f6 2f			ld a, (.dmark+2)  
2fef 32 a8 fd			ld (debug_mark+2),a  
2ff2 18 03			jr .pastdmark  
2ff4 ..			.dmark: db ").."  
2ff7 f1			.pastdmark: pop af  
2ff8			endm  
# End of macro DMARK
2ff8						CALLMONITOR 
2ff8 cd aa fd			call debug_vector  
2ffb				endm  
# End of macro CALLMONITOR
2ffb					endif 
2ffb cd 05 25			call findnexttok  
2ffe			 
2ffe					if DEBUG_FORTH_WORDS 
2ffe						DMARK "IF5" 
2ffe f5				push af  
2fff 3a 13 30			ld a, (.dmark)  
3002 32 a6 fd			ld (debug_mark),a  
3005 3a 14 30			ld a, (.dmark+1)  
3008 32 a7 fd			ld (debug_mark+1),a  
300b 3a 15 30			ld a, (.dmark+2)  
300e 32 a8 fd			ld (debug_mark+2),a  
3011 18 03			jr .pastdmark  
3013 ..			.dmark: db "IF5"  
3016 f1			.pastdmark: pop af  
3017			endm  
# End of macro DMARK
3017						CALLMONITOR 
3017 cd aa fd			call debug_vector  
301a				endm  
# End of macro CALLMONITOR
301a					endif 
301a				; replace below with ) exec using tok_ptr 
301a 22 fd f3			ld (os_tok_ptr), hl 
301d c3 7b 24			jp exec1 
3020			 
3020 .. 00			.closepar:   db ")",0 
3022			 
3022				       NEXTW 
3022 c3 ea 23			jp macro_next 
3025				endm 
# End of macro NEXTW
3025			.COMC: 
3025				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
3025 6f				db WORD_SYS_CORE+91             
3026 2e 30			dw .SCRATCH            
3028 02				db 1 + 1 
3029 .. 00			db ")",0              
302b				endm 
# End of macro CWHEAD
302b			; | ) ( -- )  End of comment |  DONE  
302b				       NEXTW 
302b c3 ea 23			jp macro_next 
302e				endm 
# End of macro NEXTW
302e			 
302e			.SCRATCH: 
302e				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
302e 6f				db WORD_SYS_CORE+91             
302f 69 30			dw .INC            
3031 08				db 7 + 1 
3032 .. 00			db "SCRATCH",0              
303a				endm 
# End of macro CWHEAD
303a			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
303a			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
303a			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
303a			; | |  
303a			; | | e.g.    : score $00 scratch ; 
303a			; | |  
303a			; | | $00 score ! 
303a			; | | $01 score +! 
303a			; | |  
303a			; | | e.g.   : varword $0a scratch ;  
303a			; | | 
303a			; | | $8000 varword ! 
303a					if DEBUG_FORTH_WORDS_KEY 
303a						DMARK "SCR" 
303a f5				push af  
303b 3a 4f 30			ld a, (.dmark)  
303e 32 a6 fd			ld (debug_mark),a  
3041 3a 50 30			ld a, (.dmark+1)  
3044 32 a7 fd			ld (debug_mark+1),a  
3047 3a 51 30			ld a, (.dmark+2)  
304a 32 a8 fd			ld (debug_mark+2),a  
304d 18 03			jr .pastdmark  
304f ..			.dmark: db "SCR"  
3052 f1			.pastdmark: pop af  
3053			endm  
# End of macro DMARK
3053						CALLMONITOR 
3053 cd aa fd			call debug_vector  
3056				endm  
# End of macro CALLMONITOR
3056					endif 
3056			 
3056					FORTH_DSP_VALUEHL 
3056 cd 34 22			call macro_dsp_valuehl 
3059				endm 
# End of macro FORTH_DSP_VALUEHL
3059				 
3059					FORTH_DSP_POP 
3059 cd ec 22			call macro_forth_dsp_pop 
305c				endm 
# End of macro FORTH_DSP_POP
305c			 
305c 7d					ld a, l 
305d 21 21 f6				ld hl, os_var_array 
3060 cd db 0f				call addatohl 
3063			 
3063 cd 2f 20				call forth_push_numhl 
3066			 
3066				       NEXTW 
3066 c3 ea 23			jp macro_next 
3069				endm 
# End of macro NEXTW
3069			 
3069			.INC: 
3069				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3069 6f				db WORD_SYS_CORE+91             
306a bf 30			dw .DEC            
306c 03				db 2 + 1 
306d .. 00			db "+!",0              
3070				endm 
# End of macro CWHEAD
3070			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
3070					if DEBUG_FORTH_WORDS_KEY 
3070						DMARK "+s_" 
3070 f5				push af  
3071 3a 85 30			ld a, (.dmark)  
3074 32 a6 fd			ld (debug_mark),a  
3077 3a 86 30			ld a, (.dmark+1)  
307a 32 a7 fd			ld (debug_mark+1),a  
307d 3a 87 30			ld a, (.dmark+2)  
3080 32 a8 fd			ld (debug_mark+2),a  
3083 18 03			jr .pastdmark  
3085 ..			.dmark: db "+s_"  
3088 f1			.pastdmark: pop af  
3089			endm  
# End of macro DMARK
3089						CALLMONITOR 
3089 cd aa fd			call debug_vector  
308c				endm  
# End of macro CALLMONITOR
308c					endif 
308c			 
308c					FORTH_DSP_VALUEHL 
308c cd 34 22			call macro_dsp_valuehl 
308f				endm 
# End of macro FORTH_DSP_VALUEHL
308f			 
308f e5					push hl   ; save address 
3090			 
3090					FORTH_DSP_POP 
3090 cd ec 22			call macro_forth_dsp_pop 
3093				endm 
# End of macro FORTH_DSP_POP
3093			 
3093					FORTH_DSP_VALUEHL 
3093 cd 34 22			call macro_dsp_valuehl 
3096				endm 
# End of macro FORTH_DSP_VALUEHL
3096			 
3096 e5					push hl 
3097					FORTH_DSP_POP 
3097 cd ec 22			call macro_forth_dsp_pop 
309a				endm 
# End of macro FORTH_DSP_POP
309a e1					pop hl 
309b			 
309b					; hl contains value to add to byte at a 
309b				 
309b eb					ex de, hl 
309c			 
309c e1					pop hl 
309d			 
309d					if DEBUG_FORTH_WORDS 
309d						DMARK "INC" 
309d f5				push af  
309e 3a b2 30			ld a, (.dmark)  
30a1 32 a6 fd			ld (debug_mark),a  
30a4 3a b3 30			ld a, (.dmark+1)  
30a7 32 a7 fd			ld (debug_mark+1),a  
30aa 3a b4 30			ld a, (.dmark+2)  
30ad 32 a8 fd			ld (debug_mark+2),a  
30b0 18 03			jr .pastdmark  
30b2 ..			.dmark: db "INC"  
30b5 f1			.pastdmark: pop af  
30b6			endm  
# End of macro DMARK
30b6						CALLMONITOR 
30b6 cd aa fd			call debug_vector  
30b9				endm  
# End of macro CALLMONITOR
30b9					endif 
30b9			 
30b9 7e					ld a,(hl) 
30ba 83					add e 
30bb 77					ld (hl),a 
30bc			 
30bc			 
30bc			 
30bc				       NEXTW 
30bc c3 ea 23			jp macro_next 
30bf				endm 
# End of macro NEXTW
30bf			 
30bf			.DEC: 
30bf				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
30bf 6f				db WORD_SYS_CORE+91             
30c0 13 31			dw .INC2            
30c2 03				db 2 + 1 
30c3 .. 00			db "-!",0              
30c6				endm 
# End of macro CWHEAD
30c6			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
30c6					if DEBUG_FORTH_WORDS_KEY 
30c6						DMARK "-s_" 
30c6 f5				push af  
30c7 3a db 30			ld a, (.dmark)  
30ca 32 a6 fd			ld (debug_mark),a  
30cd 3a dc 30			ld a, (.dmark+1)  
30d0 32 a7 fd			ld (debug_mark+1),a  
30d3 3a dd 30			ld a, (.dmark+2)  
30d6 32 a8 fd			ld (debug_mark+2),a  
30d9 18 03			jr .pastdmark  
30db ..			.dmark: db "-s_"  
30de f1			.pastdmark: pop af  
30df			endm  
# End of macro DMARK
30df						CALLMONITOR 
30df cd aa fd			call debug_vector  
30e2				endm  
# End of macro CALLMONITOR
30e2					endif 
30e2			 
30e2					FORTH_DSP_VALUEHL 
30e2 cd 34 22			call macro_dsp_valuehl 
30e5				endm 
# End of macro FORTH_DSP_VALUEHL
30e5			 
30e5 e5					push hl   ; save address 
30e6			 
30e6					FORTH_DSP_POP 
30e6 cd ec 22			call macro_forth_dsp_pop 
30e9				endm 
# End of macro FORTH_DSP_POP
30e9			 
30e9					FORTH_DSP_VALUEHL 
30e9 cd 34 22			call macro_dsp_valuehl 
30ec				endm 
# End of macro FORTH_DSP_VALUEHL
30ec			 
30ec					; hl contains value to add to byte at a 
30ec				 
30ec eb					ex de, hl 
30ed			 
30ed e1					pop hl 
30ee			 
30ee					if DEBUG_FORTH_WORDS 
30ee						DMARK "DEC" 
30ee f5				push af  
30ef 3a 03 31			ld a, (.dmark)  
30f2 32 a6 fd			ld (debug_mark),a  
30f5 3a 04 31			ld a, (.dmark+1)  
30f8 32 a7 fd			ld (debug_mark+1),a  
30fb 3a 05 31			ld a, (.dmark+2)  
30fe 32 a8 fd			ld (debug_mark+2),a  
3101 18 03			jr .pastdmark  
3103 ..			.dmark: db "DEC"  
3106 f1			.pastdmark: pop af  
3107			endm  
# End of macro DMARK
3107						CALLMONITOR 
3107 cd aa fd			call debug_vector  
310a				endm  
# End of macro CALLMONITOR
310a					endif 
310a			 
310a 7e					ld a,(hl) 
310b 93					sub e 
310c 77					ld (hl),a 
310d			 
310d			 
310d					FORTH_DSP_POP 
310d cd ec 22			call macro_forth_dsp_pop 
3110				endm 
# End of macro FORTH_DSP_POP
3110			 
3110				       NEXTW 
3110 c3 ea 23			jp macro_next 
3113				endm 
# End of macro NEXTW
3113			 
3113			.INC2: 
3113				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
3113 6f				db WORD_SYS_CORE+91             
3114 c0 31			dw .DEC2            
3116 04				db 3 + 1 
3117 .. 00			db "+2!",0              
311b				endm 
# End of macro CWHEAD
311b			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
311b			 
311b					if DEBUG_FORTH_WORDS_KEY 
311b						DMARK "+2s" 
311b f5				push af  
311c 3a 30 31			ld a, (.dmark)  
311f 32 a6 fd			ld (debug_mark),a  
3122 3a 31 31			ld a, (.dmark+1)  
3125 32 a7 fd			ld (debug_mark+1),a  
3128 3a 32 31			ld a, (.dmark+2)  
312b 32 a8 fd			ld (debug_mark+2),a  
312e 18 03			jr .pastdmark  
3130 ..			.dmark: db "+2s"  
3133 f1			.pastdmark: pop af  
3134			endm  
# End of macro DMARK
3134						CALLMONITOR 
3134 cd aa fd			call debug_vector  
3137				endm  
# End of macro CALLMONITOR
3137					endif 
3137			 
3137					; Address 
3137			 
3137					FORTH_DSP_VALUEHL 
3137 cd 34 22			call macro_dsp_valuehl 
313a				endm 
# End of macro FORTH_DSP_VALUEHL
313a			 
313a e5					push hl    ; save address 
313b			 
313b					; load content into de 
313b			 
313b 5e					ld e,(hl) 
313c 23					inc hl 
313d 56					ld d, (hl) 
313e			 
313e					if DEBUG_FORTH_WORDS 
313e						DMARK "+2a" 
313e f5				push af  
313f 3a 53 31			ld a, (.dmark)  
3142 32 a6 fd			ld (debug_mark),a  
3145 3a 54 31			ld a, (.dmark+1)  
3148 32 a7 fd			ld (debug_mark+1),a  
314b 3a 55 31			ld a, (.dmark+2)  
314e 32 a8 fd			ld (debug_mark+2),a  
3151 18 03			jr .pastdmark  
3153 ..			.dmark: db "+2a"  
3156 f1			.pastdmark: pop af  
3157			endm  
# End of macro DMARK
3157						CALLMONITOR 
3157 cd aa fd			call debug_vector  
315a				endm  
# End of macro CALLMONITOR
315a					endif 
315a			 
315a					FORTH_DSP_POP 
315a cd ec 22			call macro_forth_dsp_pop 
315d				endm 
# End of macro FORTH_DSP_POP
315d			 
315d					; Get value to add 
315d			 
315d					FORTH_DSP_VALUE 
315d cd 1d 22			call macro_forth_dsp_value 
3160				endm 
# End of macro FORTH_DSP_VALUE
3160			 
3160					if DEBUG_FORTH_WORDS 
3160						DMARK "+2v" 
3160 f5				push af  
3161 3a 75 31			ld a, (.dmark)  
3164 32 a6 fd			ld (debug_mark),a  
3167 3a 76 31			ld a, (.dmark+1)  
316a 32 a7 fd			ld (debug_mark+1),a  
316d 3a 77 31			ld a, (.dmark+2)  
3170 32 a8 fd			ld (debug_mark+2),a  
3173 18 03			jr .pastdmark  
3175 ..			.dmark: db "+2v"  
3178 f1			.pastdmark: pop af  
3179			endm  
# End of macro DMARK
3179						CALLMONITOR 
3179 cd aa fd			call debug_vector  
317c				endm  
# End of macro CALLMONITOR
317c					endif 
317c			 
317c 19					add hl, de 
317d			 
317d					if DEBUG_FORTH_WORDS 
317d						DMARK "+2+" 
317d f5				push af  
317e 3a 92 31			ld a, (.dmark)  
3181 32 a6 fd			ld (debug_mark),a  
3184 3a 93 31			ld a, (.dmark+1)  
3187 32 a7 fd			ld (debug_mark+1),a  
318a 3a 94 31			ld a, (.dmark+2)  
318d 32 a8 fd			ld (debug_mark+2),a  
3190 18 03			jr .pastdmark  
3192 ..			.dmark: db "+2+"  
3195 f1			.pastdmark: pop af  
3196			endm  
# End of macro DMARK
3196						CALLMONITOR 
3196 cd aa fd			call debug_vector  
3199				endm  
# End of macro CALLMONITOR
3199					endif 
3199			 
3199					; move result to de 
3199			 
3199 eb					ex de, hl 
319a			 
319a					; Address 
319a			 
319a e1					pop hl 
319b			 
319b					; save it back 
319b			 
319b 73					ld (hl), e 
319c 23					inc hl 
319d 72					ld (hl), d 
319e			 
319e					if DEBUG_FORTH_WORDS 
319e						DMARK "+2e" 
319e f5				push af  
319f 3a b3 31			ld a, (.dmark)  
31a2 32 a6 fd			ld (debug_mark),a  
31a5 3a b4 31			ld a, (.dmark+1)  
31a8 32 a7 fd			ld (debug_mark+1),a  
31ab 3a b5 31			ld a, (.dmark+2)  
31ae 32 a8 fd			ld (debug_mark+2),a  
31b1 18 03			jr .pastdmark  
31b3 ..			.dmark: db "+2e"  
31b6 f1			.pastdmark: pop af  
31b7			endm  
# End of macro DMARK
31b7						CALLMONITOR 
31b7 cd aa fd			call debug_vector  
31ba				endm  
# End of macro CALLMONITOR
31ba					endif 
31ba			 
31ba			 
31ba			 
31ba					FORTH_DSP_POP 
31ba cd ec 22			call macro_forth_dsp_pop 
31bd				endm 
# End of macro FORTH_DSP_POP
31bd			 
31bd			 
31bd				       NEXTW 
31bd c3 ea 23			jp macro_next 
31c0				endm 
# End of macro NEXTW
31c0			 
31c0			.DEC2: 
31c0				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
31c0 6f				db WORD_SYS_CORE+91             
31c1 6f 32			dw .GET2            
31c3 04				db 3 + 1 
31c4 .. 00			db "-2!",0              
31c8				endm 
# End of macro CWHEAD
31c8			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
31c8			 
31c8			 
31c8					if DEBUG_FORTH_WORDS_KEY 
31c8						DMARK "-2s" 
31c8 f5				push af  
31c9 3a dd 31			ld a, (.dmark)  
31cc 32 a6 fd			ld (debug_mark),a  
31cf 3a de 31			ld a, (.dmark+1)  
31d2 32 a7 fd			ld (debug_mark+1),a  
31d5 3a df 31			ld a, (.dmark+2)  
31d8 32 a8 fd			ld (debug_mark+2),a  
31db 18 03			jr .pastdmark  
31dd ..			.dmark: db "-2s"  
31e0 f1			.pastdmark: pop af  
31e1			endm  
# End of macro DMARK
31e1						CALLMONITOR 
31e1 cd aa fd			call debug_vector  
31e4				endm  
# End of macro CALLMONITOR
31e4					endif 
31e4			 
31e4					; Address 
31e4			 
31e4					FORTH_DSP_VALUEHL 
31e4 cd 34 22			call macro_dsp_valuehl 
31e7				endm 
# End of macro FORTH_DSP_VALUEHL
31e7			 
31e7 e5					push hl    ; save address 
31e8			 
31e8					; load content into de 
31e8			 
31e8 5e					ld e,(hl) 
31e9 23					inc hl 
31ea 56					ld d, (hl) 
31eb			 
31eb					if DEBUG_FORTH_WORDS 
31eb						DMARK "-2a" 
31eb f5				push af  
31ec 3a 00 32			ld a, (.dmark)  
31ef 32 a6 fd			ld (debug_mark),a  
31f2 3a 01 32			ld a, (.dmark+1)  
31f5 32 a7 fd			ld (debug_mark+1),a  
31f8 3a 02 32			ld a, (.dmark+2)  
31fb 32 a8 fd			ld (debug_mark+2),a  
31fe 18 03			jr .pastdmark  
3200 ..			.dmark: db "-2a"  
3203 f1			.pastdmark: pop af  
3204			endm  
# End of macro DMARK
3204						CALLMONITOR 
3204 cd aa fd			call debug_vector  
3207				endm  
# End of macro CALLMONITOR
3207					endif 
3207			 
3207					FORTH_DSP_POP 
3207 cd ec 22			call macro_forth_dsp_pop 
320a				endm 
# End of macro FORTH_DSP_POP
320a			 
320a					; Get value to remove 
320a			 
320a					FORTH_DSP_VALUE 
320a cd 1d 22			call macro_forth_dsp_value 
320d				endm 
# End of macro FORTH_DSP_VALUE
320d			 
320d					if DEBUG_FORTH_WORDS 
320d						DMARK "-2v" 
320d f5				push af  
320e 3a 22 32			ld a, (.dmark)  
3211 32 a6 fd			ld (debug_mark),a  
3214 3a 23 32			ld a, (.dmark+1)  
3217 32 a7 fd			ld (debug_mark+1),a  
321a 3a 24 32			ld a, (.dmark+2)  
321d 32 a8 fd			ld (debug_mark+2),a  
3220 18 03			jr .pastdmark  
3222 ..			.dmark: db "-2v"  
3225 f1			.pastdmark: pop af  
3226			endm  
# End of macro DMARK
3226						CALLMONITOR 
3226 cd aa fd			call debug_vector  
3229				endm  
# End of macro CALLMONITOR
3229					endif 
3229			 
3229 eb					ex de, hl 
322a ed 52				sbc hl, de 
322c			 
322c					if DEBUG_FORTH_WORDS 
322c						DMARK "-2d" 
322c f5				push af  
322d 3a 41 32			ld a, (.dmark)  
3230 32 a6 fd			ld (debug_mark),a  
3233 3a 42 32			ld a, (.dmark+1)  
3236 32 a7 fd			ld (debug_mark+1),a  
3239 3a 43 32			ld a, (.dmark+2)  
323c 32 a8 fd			ld (debug_mark+2),a  
323f 18 03			jr .pastdmark  
3241 ..			.dmark: db "-2d"  
3244 f1			.pastdmark: pop af  
3245			endm  
# End of macro DMARK
3245						CALLMONITOR 
3245 cd aa fd			call debug_vector  
3248				endm  
# End of macro CALLMONITOR
3248					endif 
3248			 
3248					; move result to de 
3248			 
3248 eb					ex de, hl 
3249			 
3249					; Address 
3249			 
3249 e1					pop hl 
324a			 
324a					; save it back 
324a			 
324a 73					ld (hl), e 
324b 23					inc hl 
324c 72					ld (hl), d 
324d			 
324d					if DEBUG_FORTH_WORDS 
324d						DMARK "-2e" 
324d f5				push af  
324e 3a 62 32			ld a, (.dmark)  
3251 32 a6 fd			ld (debug_mark),a  
3254 3a 63 32			ld a, (.dmark+1)  
3257 32 a7 fd			ld (debug_mark+1),a  
325a 3a 64 32			ld a, (.dmark+2)  
325d 32 a8 fd			ld (debug_mark+2),a  
3260 18 03			jr .pastdmark  
3262 ..			.dmark: db "-2e"  
3265 f1			.pastdmark: pop af  
3266			endm  
# End of macro DMARK
3266						CALLMONITOR 
3266 cd aa fd			call debug_vector  
3269				endm  
# End of macro CALLMONITOR
3269					endif 
3269			 
3269			 
3269					FORTH_DSP_POP 
3269 cd ec 22			call macro_forth_dsp_pop 
326c				endm 
# End of macro FORTH_DSP_POP
326c			 
326c			 
326c			 
326c				       NEXTW 
326c c3 ea 23			jp macro_next 
326f				endm 
# End of macro NEXTW
326f			.GET2: 
326f				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
326f 6f				db WORD_SYS_CORE+91             
3270 a4 32			dw .BANG2            
3272 03				db 2 + 1 
3273 .. 00			db "2@",0              
3276				endm 
# End of macro CWHEAD
3276			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3276					if DEBUG_FORTH_WORDS_KEY 
3276						DMARK "2A_" 
3276 f5				push af  
3277 3a 8b 32			ld a, (.dmark)  
327a 32 a6 fd			ld (debug_mark),a  
327d 3a 8c 32			ld a, (.dmark+1)  
3280 32 a7 fd			ld (debug_mark+1),a  
3283 3a 8d 32			ld a, (.dmark+2)  
3286 32 a8 fd			ld (debug_mark+2),a  
3289 18 03			jr .pastdmark  
328b ..			.dmark: db "2A_"  
328e f1			.pastdmark: pop af  
328f			endm  
# End of macro DMARK
328f						CALLMONITOR 
328f cd aa fd			call debug_vector  
3292				endm  
# End of macro CALLMONITOR
3292					endif 
3292			 
3292					FORTH_DSP_VALUEHL 
3292 cd 34 22			call macro_dsp_valuehl 
3295				endm 
# End of macro FORTH_DSP_VALUEHL
3295			 
3295 e5					push hl   ; save address 
3296			 
3296					FORTH_DSP_POP 
3296 cd ec 22			call macro_forth_dsp_pop 
3299				endm 
# End of macro FORTH_DSP_POP
3299			 
3299 e1					pop hl 
329a			 
329a 5e					ld e, (hl) 
329b 23					inc hl 
329c 56					ld d, (hl) 
329d			 
329d eb					ex de, hl 
329e			 
329e cd 2f 20				call forth_push_numhl 
32a1			 
32a1				       NEXTW 
32a1 c3 ea 23			jp macro_next 
32a4				endm 
# End of macro NEXTW
32a4			.BANG2: 
32a4				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
32a4 6f				db WORD_SYS_CORE+91             
32a5 dc 32			dw .CONFIG            
32a7 03				db 2 + 1 
32a8 .. 00			db "2!",0              
32ab				endm 
# End of macro CWHEAD
32ab			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
32ab					if DEBUG_FORTH_WORDS_KEY 
32ab						DMARK "2S_" 
32ab f5				push af  
32ac 3a c0 32			ld a, (.dmark)  
32af 32 a6 fd			ld (debug_mark),a  
32b2 3a c1 32			ld a, (.dmark+1)  
32b5 32 a7 fd			ld (debug_mark+1),a  
32b8 3a c2 32			ld a, (.dmark+2)  
32bb 32 a8 fd			ld (debug_mark+2),a  
32be 18 03			jr .pastdmark  
32c0 ..			.dmark: db "2S_"  
32c3 f1			.pastdmark: pop af  
32c4			endm  
# End of macro DMARK
32c4						CALLMONITOR 
32c4 cd aa fd			call debug_vector  
32c7				endm  
# End of macro CALLMONITOR
32c7					endif 
32c7			 
32c7					FORTH_DSP_VALUEHL 
32c7 cd 34 22			call macro_dsp_valuehl 
32ca				endm 
# End of macro FORTH_DSP_VALUEHL
32ca			 
32ca e5					push hl   ; save address 
32cb			 
32cb			 
32cb					FORTH_DSP_POP 
32cb cd ec 22			call macro_forth_dsp_pop 
32ce				endm 
# End of macro FORTH_DSP_POP
32ce			 
32ce					 
32ce					FORTH_DSP_VALUEHL 
32ce cd 34 22			call macro_dsp_valuehl 
32d1				endm 
# End of macro FORTH_DSP_VALUEHL
32d1			 
32d1					FORTH_DSP_POP 
32d1 cd ec 22			call macro_forth_dsp_pop 
32d4				endm 
# End of macro FORTH_DSP_POP
32d4			 
32d4 eb					ex de, hl    ; value now in de 
32d5			 
32d5 e1					pop hl 
32d6			 
32d6 73					ld (hl), e 
32d7			 
32d7 23					inc hl 
32d8			 
32d8 72					ld (hl), d 
32d9			 
32d9			 
32d9				       NEXTW 
32d9 c3 ea 23			jp macro_next 
32dc				endm 
# End of macro NEXTW
32dc			.CONFIG: 
32dc				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
32dc 6f				db WORD_SYS_CORE+91             
32dd ed 32			dw .ADTOS            
32df 07				db 6 + 1 
32e0 .. 00			db "CONFIG",0              
32e7				endm 
# End of macro CWHEAD
32e7			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
32e7			 
32e7 cd 4f 15				call config 
32ea					NEXTW 
32ea c3 ea 23			jp macro_next 
32ed				endm 
# End of macro NEXTW
32ed			 
32ed			.ADTOS: 
32ed				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
32ed 6f				db WORD_SYS_CORE+91             
32ee 03 33			dw .SBTOS            
32f0 03				db 2 + 1 
32f1 .. 00			db "1+",0              
32f4				endm 
# End of macro CWHEAD
32f4			; | 1+ ( u -- u )  Increment value on TOS | DONE 
32f4			 
32f4					FORTH_DSP_VALUEHL 
32f4 cd 34 22			call macro_dsp_valuehl 
32f7				endm 
# End of macro FORTH_DSP_VALUEHL
32f7 e5					push hl 
32f8			 
32f8					FORTH_DSP_POP 
32f8 cd ec 22			call macro_forth_dsp_pop 
32fb				endm 
# End of macro FORTH_DSP_POP
32fb e1					pop hl 
32fc			 
32fc 23					inc hl 
32fd cd 2f 20				call forth_push_numhl 
3300					 
3300					NEXTW 
3300 c3 ea 23			jp macro_next 
3303				endm 
# End of macro NEXTW
3303			.SBTOS: 
3303				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
3303 6f				db WORD_SYS_CORE+91             
3304 19 33			dw .ADSTORE            
3306 03				db 2 + 1 
3307 .. 00			db "1-",0              
330a				endm 
# End of macro CWHEAD
330a			; | 1- ( u -- u )  Decrement value on TOS | DONE 
330a			 
330a					FORTH_DSP_VALUEHL 
330a cd 34 22			call macro_dsp_valuehl 
330d				endm 
# End of macro FORTH_DSP_VALUEHL
330d e5					push hl 
330e			 
330e					FORTH_DSP_POP 
330e cd ec 22			call macro_forth_dsp_pop 
3311				endm 
# End of macro FORTH_DSP_POP
3311 e1					pop hl 
3312			 
3312 2b					dec hl 
3313 cd 2f 20				call forth_push_numhl 
3316					 
3316					NEXTW 
3316 c3 ea 23			jp macro_next 
3319				endm 
# End of macro NEXTW
3319			.ADSTORE: 
3319				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
3319 6f				db WORD_SYS_CORE+91             
331a 2f 33			dw .ADWSTORE            
331c 04				db 3 + 1 
331d .. 00			db "1+!",0              
3321				endm 
# End of macro CWHEAD
3321			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
3321			 
3321					FORTH_DSP_VALUEHL 
3321 cd 34 22			call macro_dsp_valuehl 
3324				endm 
# End of macro FORTH_DSP_VALUEHL
3324 e5					push hl 
3325			 
3325					FORTH_DSP_POP 
3325 cd ec 22			call macro_forth_dsp_pop 
3328				endm 
# End of macro FORTH_DSP_POP
3328 e1					pop hl 
3329			 
3329 7e					ld a, (hl) 
332a 3c					inc a 
332b 77					ld (hl), a 
332c					 
332c					NEXTW 
332c c3 ea 23			jp macro_next 
332f				endm 
# End of macro NEXTW
332f			.ADWSTORE: 
332f				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
332f 6f				db WORD_SYS_CORE+91             
3330 4d 33			dw .SBSTORE            
3332 05				db 4 + 1 
3333 .. 00			db "1+2!",0              
3338				endm 
# End of macro CWHEAD
3338			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
3338			 
3338					FORTH_DSP_VALUEHL 
3338 cd 34 22			call macro_dsp_valuehl 
333b				endm 
# End of macro FORTH_DSP_VALUEHL
333b e5					push hl 
333c			 
333c					FORTH_DSP_POP 
333c cd ec 22			call macro_forth_dsp_pop 
333f				endm 
# End of macro FORTH_DSP_POP
333f e1					pop hl 
3340			 
3340 e5					push hl 
3341			 
3341 cd 6c 23				call loadwordinhl 
3344 23					inc hl 
3345			 
3345 d1					pop de 
3346 eb					ex de, hl 
3347 73					ld (hl), e 
3348 23					inc hl 
3349 72					ld (hl), d 
334a					 
334a					NEXTW 
334a c3 ea 23			jp macro_next 
334d				endm 
# End of macro NEXTW
334d			.SBSTORE: 
334d				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
334d 6f				db WORD_SYS_CORE+91             
334e 63 33			dw .SBWSTORE            
3350 04				db 3 + 1 
3351 .. 00			db "1-!",0              
3355				endm 
# End of macro CWHEAD
3355			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
3355			 
3355					FORTH_DSP_VALUEHL 
3355 cd 34 22			call macro_dsp_valuehl 
3358				endm 
# End of macro FORTH_DSP_VALUEHL
3358 e5					push hl 
3359			 
3359					FORTH_DSP_POP 
3359 cd ec 22			call macro_forth_dsp_pop 
335c				endm 
# End of macro FORTH_DSP_POP
335c e1					pop hl 
335d			 
335d 7e					ld a, (hl) 
335e 3d					dec a 
335f 77					ld (hl), a 
3360					 
3360					NEXTW 
3360 c3 ea 23			jp macro_next 
3363				endm 
# End of macro NEXTW
3363			.SBWSTORE: 
3363				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
3363 6f				db WORD_SYS_CORE+91             
3364 81 33			dw .ENDCORE            
3366 05				db 4 + 1 
3367 .. 00			db "1-2!",0              
336c				endm 
# End of macro CWHEAD
336c			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
336c			 
336c					FORTH_DSP_VALUEHL 
336c cd 34 22			call macro_dsp_valuehl 
336f				endm 
# End of macro FORTH_DSP_VALUEHL
336f e5					push hl 
3370			 
3370					FORTH_DSP_POP 
3370 cd ec 22			call macro_forth_dsp_pop 
3373				endm 
# End of macro FORTH_DSP_POP
3373 e1					pop hl 
3374			 
3374 e5					push hl 
3375			 
3375 cd 6c 23				call loadwordinhl 
3378 2b					dec hl 
3379			 
3379 d1					pop de 
337a eb					ex de, hl 
337b 73					ld (hl), e 
337c 23					inc hl 
337d 72					ld (hl), d 
337e					 
337e					NEXTW 
337e c3 ea 23			jp macro_next 
3381				endm 
# End of macro NEXTW
3381			.ENDCORE: 
3381			 
3381			; eof 
3381			 
3381			 
# End of file forth_words_core.asm
3381			include "forth_words_flow.asm" 
3381			 
3381			; | ## Program Flow Words 
3381			 
3381			.IF: 
3381				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3381 1e				db WORD_SYS_CORE+10             
3382 76 34			dw .THEN            
3384 03				db 2 + 1 
3385 .. 00			db "IF",0              
3388				endm 
# End of macro CWHEAD
3388			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3388			; 
3388					if DEBUG_FORTH_WORDS_KEY 
3388						DMARK "IF." 
3388 f5				push af  
3389 3a 9d 33			ld a, (.dmark)  
338c 32 a6 fd			ld (debug_mark),a  
338f 3a 9e 33			ld a, (.dmark+1)  
3392 32 a7 fd			ld (debug_mark+1),a  
3395 3a 9f 33			ld a, (.dmark+2)  
3398 32 a8 fd			ld (debug_mark+2),a  
339b 18 03			jr .pastdmark  
339d ..			.dmark: db "IF."  
33a0 f1			.pastdmark: pop af  
33a1			endm  
# End of macro DMARK
33a1						CALLMONITOR 
33a1 cd aa fd			call debug_vector  
33a4				endm  
# End of macro CALLMONITOR
33a4					endif 
33a4			; eval TOS 
33a4			 
33a4				FORTH_DSP_VALUEHL 
33a4 cd 34 22			call macro_dsp_valuehl 
33a7				endm 
# End of macro FORTH_DSP_VALUEHL
33a7			 
33a7			;	push hl 
33a7				FORTH_DSP_POP 
33a7 cd ec 22			call macro_forth_dsp_pop 
33aa				endm 
# End of macro FORTH_DSP_POP
33aa			;	pop hl 
33aa			 
33aa					if DEBUG_FORTH_WORDS 
33aa						DMARK "IF1" 
33aa f5				push af  
33ab 3a bf 33			ld a, (.dmark)  
33ae 32 a6 fd			ld (debug_mark),a  
33b1 3a c0 33			ld a, (.dmark+1)  
33b4 32 a7 fd			ld (debug_mark+1),a  
33b7 3a c1 33			ld a, (.dmark+2)  
33ba 32 a8 fd			ld (debug_mark+2),a  
33bd 18 03			jr .pastdmark  
33bf ..			.dmark: db "IF1"  
33c2 f1			.pastdmark: pop af  
33c3			endm  
# End of macro DMARK
33c3						CALLMONITOR 
33c3 cd aa fd			call debug_vector  
33c6				endm  
# End of macro CALLMONITOR
33c6					endif 
33c6 b7				or a        ; clear carry flag 
33c7 11 00 00			ld de, 0 
33ca eb				ex de,hl 
33cb ed 52			sbc hl, de 
33cd c2 57 34			jp nz, .iftrue 
33d0			 
33d0					if DEBUG_FORTH_WORDS 
33d0						DMARK "IF2" 
33d0 f5				push af  
33d1 3a e5 33			ld a, (.dmark)  
33d4 32 a6 fd			ld (debug_mark),a  
33d7 3a e6 33			ld a, (.dmark+1)  
33da 32 a7 fd			ld (debug_mark+1),a  
33dd 3a e7 33			ld a, (.dmark+2)  
33e0 32 a8 fd			ld (debug_mark+2),a  
33e3 18 03			jr .pastdmark  
33e5 ..			.dmark: db "IF2"  
33e8 f1			.pastdmark: pop af  
33e9			endm  
# End of macro DMARK
33e9						CALLMONITOR 
33e9 cd aa fd			call debug_vector  
33ec				endm  
# End of macro CALLMONITOR
33ec					endif 
33ec			 
33ec			; if not true then skip to THEN 
33ec			 
33ec				; TODO get tok_ptr 
33ec				; TODO consume toks until we get to THEN 
33ec			 
33ec 2a fd f3			ld hl, (os_tok_ptr) 
33ef					if DEBUG_FORTH_WORDS 
33ef						DMARK "IF3" 
33ef f5				push af  
33f0 3a 04 34			ld a, (.dmark)  
33f3 32 a6 fd			ld (debug_mark),a  
33f6 3a 05 34			ld a, (.dmark+1)  
33f9 32 a7 fd			ld (debug_mark+1),a  
33fc 3a 06 34			ld a, (.dmark+2)  
33ff 32 a8 fd			ld (debug_mark+2),a  
3402 18 03			jr .pastdmark  
3404 ..			.dmark: db "IF3"  
3407 f1			.pastdmark: pop af  
3408			endm  
# End of macro DMARK
3408						CALLMONITOR 
3408 cd aa fd			call debug_vector  
340b				endm  
# End of macro CALLMONITOR
340b						 
340b					endif 
340b 11 52 34			ld de, .ifthen 
340e					if DEBUG_FORTH_WORDS 
340e						DMARK "IF4" 
340e f5				push af  
340f 3a 23 34			ld a, (.dmark)  
3412 32 a6 fd			ld (debug_mark),a  
3415 3a 24 34			ld a, (.dmark+1)  
3418 32 a7 fd			ld (debug_mark+1),a  
341b 3a 25 34			ld a, (.dmark+2)  
341e 32 a8 fd			ld (debug_mark+2),a  
3421 18 03			jr .pastdmark  
3423 ..			.dmark: db "IF4"  
3426 f1			.pastdmark: pop af  
3427			endm  
# End of macro DMARK
3427						CALLMONITOR 
3427 cd aa fd			call debug_vector  
342a				endm  
# End of macro CALLMONITOR
342a					endif 
342a cd 05 25			call findnexttok  
342d			 
342d					if DEBUG_FORTH_WORDS 
342d						DMARK "IF5" 
342d f5				push af  
342e 3a 42 34			ld a, (.dmark)  
3431 32 a6 fd			ld (debug_mark),a  
3434 3a 43 34			ld a, (.dmark+1)  
3437 32 a7 fd			ld (debug_mark+1),a  
343a 3a 44 34			ld a, (.dmark+2)  
343d 32 a8 fd			ld (debug_mark+2),a  
3440 18 03			jr .pastdmark  
3442 ..			.dmark: db "IF5"  
3445 f1			.pastdmark: pop af  
3446			endm  
# End of macro DMARK
3446						CALLMONITOR 
3446 cd aa fd			call debug_vector  
3449				endm  
# End of macro CALLMONITOR
3449					endif 
3449				; TODO replace below with ; exec using tok_ptr 
3449 22 fd f3			ld (os_tok_ptr), hl 
344c c3 7b 24			jp exec1 
344f				NEXTW 
344f c3 ea 23			jp macro_next 
3452				endm 
# End of macro NEXTW
3452			 
3452 .. 00		.ifthen:  db "THEN",0 
3457			 
3457			.iftrue:		 
3457				; Exec next words normally 
3457			 
3457				; if true then exec following IF as normal 
3457					if DEBUG_FORTH_WORDS 
3457						DMARK "IFT" 
3457 f5				push af  
3458 3a 6c 34			ld a, (.dmark)  
345b 32 a6 fd			ld (debug_mark),a  
345e 3a 6d 34			ld a, (.dmark+1)  
3461 32 a7 fd			ld (debug_mark+1),a  
3464 3a 6e 34			ld a, (.dmark+2)  
3467 32 a8 fd			ld (debug_mark+2),a  
346a 18 03			jr .pastdmark  
346c ..			.dmark: db "IFT"  
346f f1			.pastdmark: pop af  
3470			endm  
# End of macro DMARK
3470						CALLMONITOR 
3470 cd aa fd			call debug_vector  
3473				endm  
# End of macro CALLMONITOR
3473					endif 
3473			 
3473					NEXTW 
3473 c3 ea 23			jp macro_next 
3476				endm 
# End of macro NEXTW
3476			.THEN: 
3476				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3476 1f				db WORD_SYS_CORE+11             
3477 9e 34			dw .ELSE            
3479 05				db 4 + 1 
347a .. 00			db "THEN",0              
347f				endm 
# End of macro CWHEAD
347f			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
347f					if DEBUG_FORTH_WORDS_KEY 
347f						DMARK "THN" 
347f f5				push af  
3480 3a 94 34			ld a, (.dmark)  
3483 32 a6 fd			ld (debug_mark),a  
3486 3a 95 34			ld a, (.dmark+1)  
3489 32 a7 fd			ld (debug_mark+1),a  
348c 3a 96 34			ld a, (.dmark+2)  
348f 32 a8 fd			ld (debug_mark+2),a  
3492 18 03			jr .pastdmark  
3494 ..			.dmark: db "THN"  
3497 f1			.pastdmark: pop af  
3498			endm  
# End of macro DMARK
3498						CALLMONITOR 
3498 cd aa fd			call debug_vector  
349b				endm  
# End of macro CALLMONITOR
349b					endif 
349b					NEXTW 
349b c3 ea 23			jp macro_next 
349e				endm 
# End of macro NEXTW
349e			.ELSE: 
349e				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
349e 20				db WORD_SYS_CORE+12             
349f c6 34			dw .DO            
34a1 03				db 2 + 1 
34a2 .. 00			db "ELSE",0              
34a7				endm 
# End of macro CWHEAD
34a7			; | ELSE ( -- ) Not supported - does nothing | TODO 
34a7			 
34a7					if DEBUG_FORTH_WORDS_KEY 
34a7						DMARK "ELS" 
34a7 f5				push af  
34a8 3a bc 34			ld a, (.dmark)  
34ab 32 a6 fd			ld (debug_mark),a  
34ae 3a bd 34			ld a, (.dmark+1)  
34b1 32 a7 fd			ld (debug_mark+1),a  
34b4 3a be 34			ld a, (.dmark+2)  
34b7 32 a8 fd			ld (debug_mark+2),a  
34ba 18 03			jr .pastdmark  
34bc ..			.dmark: db "ELS"  
34bf f1			.pastdmark: pop af  
34c0			endm  
# End of macro DMARK
34c0						CALLMONITOR 
34c0 cd aa fd			call debug_vector  
34c3				endm  
# End of macro CALLMONITOR
34c3					endif 
34c3			 
34c3			 
34c3					NEXTW 
34c3 c3 ea 23			jp macro_next 
34c6				endm 
# End of macro NEXTW
34c6			.DO: 
34c6				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
34c6 21				db WORD_SYS_CORE+13             
34c7 ed 35			dw .LOOP            
34c9 03				db 2 + 1 
34ca .. 00			db "DO",0              
34cd				endm 
# End of macro CWHEAD
34cd			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
34cd			 
34cd					if DEBUG_FORTH_WORDS_KEY 
34cd						DMARK "DO." 
34cd f5				push af  
34ce 3a e2 34			ld a, (.dmark)  
34d1 32 a6 fd			ld (debug_mark),a  
34d4 3a e3 34			ld a, (.dmark+1)  
34d7 32 a7 fd			ld (debug_mark+1),a  
34da 3a e4 34			ld a, (.dmark+2)  
34dd 32 a8 fd			ld (debug_mark+2),a  
34e0 18 03			jr .pastdmark  
34e2 ..			.dmark: db "DO."  
34e5 f1			.pastdmark: pop af  
34e6			endm  
# End of macro DMARK
34e6						CALLMONITOR 
34e6 cd aa fd			call debug_vector  
34e9				endm  
# End of macro CALLMONITOR
34e9					endif 
34e9			;  push pc to rsp stack past the DO 
34e9			 
34e9 2a fd f3				ld hl, (os_tok_ptr) 
34ec 23					inc hl   ; D 
34ed 23					inc hl  ; O 
34ee 23					inc hl   ; null 
34ef					if DEBUG_FORTH_WORDS 
34ef						DMARK "DO2" 
34ef f5				push af  
34f0 3a 04 35			ld a, (.dmark)  
34f3 32 a6 fd			ld (debug_mark),a  
34f6 3a 05 35			ld a, (.dmark+1)  
34f9 32 a7 fd			ld (debug_mark+1),a  
34fc 3a 06 35			ld a, (.dmark+2)  
34ff 32 a8 fd			ld (debug_mark+2),a  
3502 18 03			jr .pastdmark  
3504 ..			.dmark: db "DO2"  
3507 f1			.pastdmark: pop af  
3508			endm  
# End of macro DMARK
3508						CALLMONITOR 
3508 cd aa fd			call debug_vector  
350b				endm  
# End of macro CALLMONITOR
350b					endif 
350b					FORTH_RSP_NEXT 
350b cd d6 1f			call macro_forth_rsp_next 
350e				endm 
# End of macro FORTH_RSP_NEXT
350e					if DEBUG_FORTH_WORDS 
350e						DMARK "DO3" 
350e f5				push af  
350f 3a 23 35			ld a, (.dmark)  
3512 32 a6 fd			ld (debug_mark),a  
3515 3a 24 35			ld a, (.dmark+1)  
3518 32 a7 fd			ld (debug_mark+1),a  
351b 3a 25 35			ld a, (.dmark+2)  
351e 32 a8 fd			ld (debug_mark+2),a  
3521 18 03			jr .pastdmark  
3523 ..			.dmark: db "DO3"  
3526 f1			.pastdmark: pop af  
3527			endm  
# End of macro DMARK
3527						CALLMONITOR 
3527 cd aa fd			call debug_vector  
352a				endm  
# End of macro CALLMONITOR
352a					endif 
352a			 
352a					;if DEBUG_FORTH_WORDS 
352a				;		push hl 
352a			;		endif  
352a			 
352a			; get counters from data stack 
352a			 
352a			 
352a					FORTH_DSP_VALUEHL 
352a cd 34 22			call macro_dsp_valuehl 
352d				endm 
# End of macro FORTH_DSP_VALUEHL
352d e5					push hl		 ; hl now has starting counter which needs to be tos 
352e			 
352e					if DEBUG_FORTH_WORDS 
352e						DMARK "DO4" 
352e f5				push af  
352f 3a 43 35			ld a, (.dmark)  
3532 32 a6 fd			ld (debug_mark),a  
3535 3a 44 35			ld a, (.dmark+1)  
3538 32 a7 fd			ld (debug_mark+1),a  
353b 3a 45 35			ld a, (.dmark+2)  
353e 32 a8 fd			ld (debug_mark+2),a  
3541 18 03			jr .pastdmark  
3543 ..			.dmark: db "DO4"  
3546 f1			.pastdmark: pop af  
3547			endm  
# End of macro DMARK
3547						CALLMONITOR 
3547 cd aa fd			call debug_vector  
354a				endm  
# End of macro CALLMONITOR
354a					endif 
354a					FORTH_DSP_POP 
354a cd ec 22			call macro_forth_dsp_pop 
354d				endm 
# End of macro FORTH_DSP_POP
354d			 
354d					if DEBUG_FORTH_WORDS 
354d						DMARK "DO5" 
354d f5				push af  
354e 3a 62 35			ld a, (.dmark)  
3551 32 a6 fd			ld (debug_mark),a  
3554 3a 63 35			ld a, (.dmark+1)  
3557 32 a7 fd			ld (debug_mark+1),a  
355a 3a 64 35			ld a, (.dmark+2)  
355d 32 a8 fd			ld (debug_mark+2),a  
3560 18 03			jr .pastdmark  
3562 ..			.dmark: db "DO5"  
3565 f1			.pastdmark: pop af  
3566			endm  
# End of macro DMARK
3566						CALLMONITOR 
3566 cd aa fd			call debug_vector  
3569				endm  
# End of macro CALLMONITOR
3569					endif 
3569			 
3569					FORTH_DSP_VALUEHL 
3569 cd 34 22			call macro_dsp_valuehl 
356c				endm 
# End of macro FORTH_DSP_VALUEHL
356c			;		push hl		 ; hl now has starting limit counter 
356c			 
356c					if DEBUG_FORTH_WORDS 
356c						DMARK "DO6" 
356c f5				push af  
356d 3a 81 35			ld a, (.dmark)  
3570 32 a6 fd			ld (debug_mark),a  
3573 3a 82 35			ld a, (.dmark+1)  
3576 32 a7 fd			ld (debug_mark+1),a  
3579 3a 83 35			ld a, (.dmark+2)  
357c 32 a8 fd			ld (debug_mark+2),a  
357f 18 03			jr .pastdmark  
3581 ..			.dmark: db "DO6"  
3584 f1			.pastdmark: pop af  
3585			endm  
# End of macro DMARK
3585						CALLMONITOR 
3585 cd aa fd			call debug_vector  
3588				endm  
# End of macro CALLMONITOR
3588					endif 
3588					FORTH_DSP_POP 
3588 cd ec 22			call macro_forth_dsp_pop 
358b				endm 
# End of macro FORTH_DSP_POP
358b			 
358b			; put counters on the loop stack 
358b			 
358b			;		pop hl			 ; limit counter 
358b d1					pop de			; start counter 
358c			 
358c					; push limit counter 
358c			 
358c					if DEBUG_FORTH_WORDS 
358c						DMARK "DO7" 
358c f5				push af  
358d 3a a1 35			ld a, (.dmark)  
3590 32 a6 fd			ld (debug_mark),a  
3593 3a a2 35			ld a, (.dmark+1)  
3596 32 a7 fd			ld (debug_mark+1),a  
3599 3a a3 35			ld a, (.dmark+2)  
359c 32 a8 fd			ld (debug_mark+2),a  
359f 18 03			jr .pastdmark  
35a1 ..			.dmark: db "DO7"  
35a4 f1			.pastdmark: pop af  
35a5			endm  
# End of macro DMARK
35a5						CALLMONITOR 
35a5 cd aa fd			call debug_vector  
35a8				endm  
# End of macro CALLMONITOR
35a8					endif 
35a8					FORTH_LOOP_NEXT 
35a8 cd 65 22			call macro_forth_loop_next 
35ab				endm 
# End of macro FORTH_LOOP_NEXT
35ab			 
35ab					; push start counter 
35ab			 
35ab eb					ex de, hl 
35ac					if DEBUG_FORTH_WORDS 
35ac						DMARK "DO7" 
35ac f5				push af  
35ad 3a c1 35			ld a, (.dmark)  
35b0 32 a6 fd			ld (debug_mark),a  
35b3 3a c2 35			ld a, (.dmark+1)  
35b6 32 a7 fd			ld (debug_mark+1),a  
35b9 3a c3 35			ld a, (.dmark+2)  
35bc 32 a8 fd			ld (debug_mark+2),a  
35bf 18 03			jr .pastdmark  
35c1 ..			.dmark: db "DO7"  
35c4 f1			.pastdmark: pop af  
35c5			endm  
# End of macro DMARK
35c5						CALLMONITOR 
35c5 cd aa fd			call debug_vector  
35c8				endm  
# End of macro CALLMONITOR
35c8					endif 
35c8					FORTH_LOOP_NEXT 
35c8 cd 65 22			call macro_forth_loop_next 
35cb				endm 
# End of macro FORTH_LOOP_NEXT
35cb			 
35cb			 
35cb					; init first round of I counter 
35cb			 
35cb 22 21 f4				ld (os_current_i), hl 
35ce			 
35ce					if DEBUG_FORTH_WORDS 
35ce						DMARK "DO8" 
35ce f5				push af  
35cf 3a e3 35			ld a, (.dmark)  
35d2 32 a6 fd			ld (debug_mark),a  
35d5 3a e4 35			ld a, (.dmark+1)  
35d8 32 a7 fd			ld (debug_mark+1),a  
35db 3a e5 35			ld a, (.dmark+2)  
35de 32 a8 fd			ld (debug_mark+2),a  
35e1 18 03			jr .pastdmark  
35e3 ..			.dmark: db "DO8"  
35e6 f1			.pastdmark: pop af  
35e7			endm  
# End of macro DMARK
35e7						CALLMONITOR 
35e7 cd aa fd			call debug_vector  
35ea				endm  
# End of macro CALLMONITOR
35ea					endif 
35ea			 
35ea					NEXTW 
35ea c3 ea 23			jp macro_next 
35ed				endm 
# End of macro NEXTW
35ed			.LOOP: 
35ed				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
35ed 22				db WORD_SYS_CORE+14             
35ee 05 37			dw .I            
35f0 05				db 4 + 1 
35f1 .. 00			db "LOOP",0              
35f6				endm 
# End of macro CWHEAD
35f6			; | LOOP ( -- ) Increment and test loop counter  | DONE 
35f6			 
35f6				; pop tos as current loop count to hl 
35f6			 
35f6				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
35f6			 
35f6				FORTH_LOOP_TOS 
35f6 cd 98 22			call macro_forth_loop_tos 
35f9				endm 
# End of macro FORTH_LOOP_TOS
35f9 e5				push hl 
35fa			 
35fa					if DEBUG_FORTH_WORDS_KEY 
35fa						DMARK "LOP" 
35fa f5				push af  
35fb 3a 0f 36			ld a, (.dmark)  
35fe 32 a6 fd			ld (debug_mark),a  
3601 3a 10 36			ld a, (.dmark+1)  
3604 32 a7 fd			ld (debug_mark+1),a  
3607 3a 11 36			ld a, (.dmark+2)  
360a 32 a8 fd			ld (debug_mark+2),a  
360d 18 03			jr .pastdmark  
360f ..			.dmark: db "LOP"  
3612 f1			.pastdmark: pop af  
3613			endm  
# End of macro DMARK
3613						CALLMONITOR 
3613 cd aa fd			call debug_vector  
3616				endm  
# End of macro CALLMONITOR
3616					endif 
3616				; next item on the stack is the limit. get it 
3616			 
3616			 
3616				FORTH_LOOP_POP 
3616 cd a2 22			call macro_forth_loop_pop 
3619				endm 
# End of macro FORTH_LOOP_POP
3619			 
3619				FORTH_LOOP_TOS 
3619 cd 98 22			call macro_forth_loop_tos 
361c				endm 
# End of macro FORTH_LOOP_TOS
361c			 
361c d1				pop de		 ; de = i, hl = limit 
361d			 
361d					if DEBUG_FORTH_WORDS 
361d						DMARK "LP1" 
361d f5				push af  
361e 3a 32 36			ld a, (.dmark)  
3621 32 a6 fd			ld (debug_mark),a  
3624 3a 33 36			ld a, (.dmark+1)  
3627 32 a7 fd			ld (debug_mark+1),a  
362a 3a 34 36			ld a, (.dmark+2)  
362d 32 a8 fd			ld (debug_mark+2),a  
3630 18 03			jr .pastdmark  
3632 ..			.dmark: db "LP1"  
3635 f1			.pastdmark: pop af  
3636			endm  
# End of macro DMARK
3636						CALLMONITOR 
3636 cd aa fd			call debug_vector  
3639				endm  
# End of macro CALLMONITOR
3639					endif 
3639			 
3639				; go back to previous word 
3639			 
3639 d5				push de    ; save I for inc later 
363a			 
363a			 
363a				; get limit 
363a				;  is I at limit? 
363a			 
363a			 
363a					if DEBUG_FORTH_WORDS 
363a						DMARK "LP1" 
363a f5				push af  
363b 3a 4f 36			ld a, (.dmark)  
363e 32 a6 fd			ld (debug_mark),a  
3641 3a 50 36			ld a, (.dmark+1)  
3644 32 a7 fd			ld (debug_mark+1),a  
3647 3a 51 36			ld a, (.dmark+2)  
364a 32 a8 fd			ld (debug_mark+2),a  
364d 18 03			jr .pastdmark  
364f ..			.dmark: db "LP1"  
3652 f1			.pastdmark: pop af  
3653			endm  
# End of macro DMARK
3653						CALLMONITOR 
3653 cd aa fd			call debug_vector  
3656				endm  
# End of macro CALLMONITOR
3656					endif 
3656			 
3656 ed 52			sbc hl, de 
3658			 
3658			 
3658				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3658			 
3658 20 26				jr nz, .loopnotdone 
365a			 
365a e1				pop hl   ; get rid of saved I 
365b				FORTH_LOOP_POP     ; get rid of limit 
365b cd a2 22			call macro_forth_loop_pop 
365e				endm 
# End of macro FORTH_LOOP_POP
365e			 
365e				FORTH_RSP_POP     ; get rid of DO ptr 
365e cd f7 1f			call macro_forth_rsp_pop 
3661				endm 
# End of macro FORTH_RSP_POP
3661			 
3661			if DEBUG_FORTH_WORDS 
3661						DMARK "LP>" 
3661 f5				push af  
3662 3a 76 36			ld a, (.dmark)  
3665 32 a6 fd			ld (debug_mark),a  
3668 3a 77 36			ld a, (.dmark+1)  
366b 32 a7 fd			ld (debug_mark+1),a  
366e 3a 78 36			ld a, (.dmark+2)  
3671 32 a8 fd			ld (debug_mark+2),a  
3674 18 03			jr .pastdmark  
3676 ..			.dmark: db "LP>"  
3679 f1			.pastdmark: pop af  
367a			endm  
# End of macro DMARK
367a				CALLMONITOR 
367a cd aa fd			call debug_vector  
367d				endm  
# End of macro CALLMONITOR
367d			endif 
367d			 
367d					NEXTW 
367d c3 ea 23			jp macro_next 
3680				endm 
# End of macro NEXTW
3680				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3680			 
3680			.loopnotdone: 
3680			 
3680 e1				pop hl    ; get I 
3681 23				inc hl 
3682			 
3682			   	; save new I 
3682			 
3682			 
3682					; set I counter 
3682			 
3682 22 21 f4				ld (os_current_i), hl 
3685			 
3685					if DEBUG_FORTH_WORDS 
3685						DMARK "LPN" 
3685 f5				push af  
3686 3a 9a 36			ld a, (.dmark)  
3689 32 a6 fd			ld (debug_mark),a  
368c 3a 9b 36			ld a, (.dmark+1)  
368f 32 a7 fd			ld (debug_mark+1),a  
3692 3a 9c 36			ld a, (.dmark+2)  
3695 32 a8 fd			ld (debug_mark+2),a  
3698 18 03			jr .pastdmark  
369a ..			.dmark: db "LPN"  
369d f1			.pastdmark: pop af  
369e			endm  
# End of macro DMARK
369e					CALLMONITOR 
369e cd aa fd			call debug_vector  
36a1				endm  
# End of macro CALLMONITOR
36a1					endif 
36a1					 
36a1				FORTH_LOOP_NEXT 
36a1 cd 65 22			call macro_forth_loop_next 
36a4				endm 
# End of macro FORTH_LOOP_NEXT
36a4			 
36a4			 
36a4					if DEBUG_FORTH_WORDS 
36a4 eb						ex de,hl 
36a5					endif 
36a5			 
36a5			;	; get DO ptr 
36a5			; 
36a5					if DEBUG_FORTH_WORDS 
36a5						DMARK "LP7" 
36a5 f5				push af  
36a6 3a ba 36			ld a, (.dmark)  
36a9 32 a6 fd			ld (debug_mark),a  
36ac 3a bb 36			ld a, (.dmark+1)  
36af 32 a7 fd			ld (debug_mark+1),a  
36b2 3a bc 36			ld a, (.dmark+2)  
36b5 32 a8 fd			ld (debug_mark+2),a  
36b8 18 03			jr .pastdmark  
36ba ..			.dmark: db "LP7"  
36bd f1			.pastdmark: pop af  
36be			endm  
# End of macro DMARK
36be					CALLMONITOR 
36be cd aa fd			call debug_vector  
36c1				endm  
# End of macro CALLMONITOR
36c1					endif 
36c1				FORTH_RSP_TOS 
36c1 cd ed 1f			call macro_forth_rsp_tos 
36c4				endm 
# End of macro FORTH_RSP_TOS
36c4			 
36c4					if DEBUG_FORTH_WORDS 
36c4						DMARK "LP8" 
36c4 f5				push af  
36c5 3a d9 36			ld a, (.dmark)  
36c8 32 a6 fd			ld (debug_mark),a  
36cb 3a da 36			ld a, (.dmark+1)  
36ce 32 a7 fd			ld (debug_mark+1),a  
36d1 3a db 36			ld a, (.dmark+2)  
36d4 32 a8 fd			ld (debug_mark+2),a  
36d7 18 03			jr .pastdmark  
36d9 ..			.dmark: db "LP8"  
36dc f1			.pastdmark: pop af  
36dd			endm  
# End of macro DMARK
36dd					CALLMONITOR 
36dd cd aa fd			call debug_vector  
36e0				endm  
# End of macro CALLMONITOR
36e0					endif 
36e0				;push hl 
36e0			 
36e0				; not going to DO any more 
36e0				; get rid of the RSP pointer as DO will add it back in 
36e0				;FORTH_RSP_POP 
36e0				;pop hl 
36e0			 
36e0				;ld hl,(cli_ret_sp) 
36e0				;ld e, (hl) 
36e0				;inc hl 
36e0				;ld d, (hl) 
36e0				;ex de,hl 
36e0 22 fd f3			ld (os_tok_ptr), hl 
36e3					if DEBUG_FORTH_WORDS 
36e3						DMARK "LP<" 
36e3 f5				push af  
36e4 3a f8 36			ld a, (.dmark)  
36e7 32 a6 fd			ld (debug_mark),a  
36ea 3a f9 36			ld a, (.dmark+1)  
36ed 32 a7 fd			ld (debug_mark+1),a  
36f0 3a fa 36			ld a, (.dmark+2)  
36f3 32 a8 fd			ld (debug_mark+2),a  
36f6 18 03			jr .pastdmark  
36f8 ..			.dmark: db "LP<"  
36fb f1			.pastdmark: pop af  
36fc			endm  
# End of macro DMARK
36fc					CALLMONITOR 
36fc cd aa fd			call debug_vector  
36ff				endm  
# End of macro CALLMONITOR
36ff				endif 
36ff c3 7b 24			jp exec1 
3702			 
3702					 
3702			 
3702			 
3702					NEXTW 
3702 c3 ea 23			jp macro_next 
3705				endm 
# End of macro NEXTW
3705			.I:  
3705			 
3705				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3705 5e				db WORD_SYS_CORE+74             
3706 30 37			dw .DLOOP            
3708 02				db 1 + 1 
3709 .. 00			db "I",0              
370b				endm 
# End of macro CWHEAD
370b			; | I ( -- ) Current loop counter | DONE 
370b					if DEBUG_FORTH_WORDS_KEY 
370b						DMARK "I.." 
370b f5				push af  
370c 3a 20 37			ld a, (.dmark)  
370f 32 a6 fd			ld (debug_mark),a  
3712 3a 21 37			ld a, (.dmark+1)  
3715 32 a7 fd			ld (debug_mark+1),a  
3718 3a 22 37			ld a, (.dmark+2)  
371b 32 a8 fd			ld (debug_mark+2),a  
371e 18 03			jr .pastdmark  
3720 ..			.dmark: db "I.."  
3723 f1			.pastdmark: pop af  
3724			endm  
# End of macro DMARK
3724						CALLMONITOR 
3724 cd aa fd			call debug_vector  
3727				endm  
# End of macro CALLMONITOR
3727					endif 
3727			 
3727 2a 21 f4				ld hl,(os_current_i) 
372a cd 2f 20				call forth_push_numhl 
372d			 
372d					NEXTW 
372d c3 ea 23			jp macro_next 
3730				endm 
# End of macro NEXTW
3730			.DLOOP: 
3730				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3730 5f				db WORD_SYS_CORE+75             
3731 11 38			dw .REPEAT            
3733 06				db 5 + 1 
3734 .. 00			db "-LOOP",0              
373a				endm 
# End of macro CWHEAD
373a			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
373a				; pop tos as current loop count to hl 
373a					if DEBUG_FORTH_WORDS_KEY 
373a						DMARK "-LP" 
373a f5				push af  
373b 3a 4f 37			ld a, (.dmark)  
373e 32 a6 fd			ld (debug_mark),a  
3741 3a 50 37			ld a, (.dmark+1)  
3744 32 a7 fd			ld (debug_mark+1),a  
3747 3a 51 37			ld a, (.dmark+2)  
374a 32 a8 fd			ld (debug_mark+2),a  
374d 18 03			jr .pastdmark  
374f ..			.dmark: db "-LP"  
3752 f1			.pastdmark: pop af  
3753			endm  
# End of macro DMARK
3753						CALLMONITOR 
3753 cd aa fd			call debug_vector  
3756				endm  
# End of macro CALLMONITOR
3756					endif 
3756			 
3756				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3756			 
3756				FORTH_LOOP_TOS 
3756 cd 98 22			call macro_forth_loop_tos 
3759				endm 
# End of macro FORTH_LOOP_TOS
3759 e5				push hl 
375a			 
375a					if DEBUG_FORTH_WORDS 
375a						DMARK "-LP" 
375a f5				push af  
375b 3a 6f 37			ld a, (.dmark)  
375e 32 a6 fd			ld (debug_mark),a  
3761 3a 70 37			ld a, (.dmark+1)  
3764 32 a7 fd			ld (debug_mark+1),a  
3767 3a 71 37			ld a, (.dmark+2)  
376a 32 a8 fd			ld (debug_mark+2),a  
376d 18 03			jr .pastdmark  
376f ..			.dmark: db "-LP"  
3772 f1			.pastdmark: pop af  
3773			endm  
# End of macro DMARK
3773						CALLMONITOR 
3773 cd aa fd			call debug_vector  
3776				endm  
# End of macro CALLMONITOR
3776					endif 
3776				; next item on the stack is the limit. get it 
3776			 
3776			 
3776				FORTH_LOOP_POP 
3776 cd a2 22			call macro_forth_loop_pop 
3779				endm 
# End of macro FORTH_LOOP_POP
3779			 
3779				FORTH_LOOP_TOS 
3779 cd 98 22			call macro_forth_loop_tos 
377c				endm 
# End of macro FORTH_LOOP_TOS
377c			 
377c d1				pop de		 ; de = i, hl = limit 
377d			 
377d					if DEBUG_FORTH_WORDS 
377d						DMARK "-L1" 
377d f5				push af  
377e 3a 92 37			ld a, (.dmark)  
3781 32 a6 fd			ld (debug_mark),a  
3784 3a 93 37			ld a, (.dmark+1)  
3787 32 a7 fd			ld (debug_mark+1),a  
378a 3a 94 37			ld a, (.dmark+2)  
378d 32 a8 fd			ld (debug_mark+2),a  
3790 18 03			jr .pastdmark  
3792 ..			.dmark: db "-L1"  
3795 f1			.pastdmark: pop af  
3796			endm  
# End of macro DMARK
3796						CALLMONITOR 
3796 cd aa fd			call debug_vector  
3799				endm  
# End of macro CALLMONITOR
3799					endif 
3799			 
3799				; go back to previous word 
3799			 
3799 d5				push de    ; save I for inc later 
379a			 
379a			 
379a				; get limit 
379a				;  is I at limit? 
379a			 
379a			 
379a					if DEBUG_FORTH_WORDS 
379a						DMARK "-L1" 
379a f5				push af  
379b 3a af 37			ld a, (.dmark)  
379e 32 a6 fd			ld (debug_mark),a  
37a1 3a b0 37			ld a, (.dmark+1)  
37a4 32 a7 fd			ld (debug_mark+1),a  
37a7 3a b1 37			ld a, (.dmark+2)  
37aa 32 a8 fd			ld (debug_mark+2),a  
37ad 18 03			jr .pastdmark  
37af ..			.dmark: db "-L1"  
37b2 f1			.pastdmark: pop af  
37b3			endm  
# End of macro DMARK
37b3						CALLMONITOR 
37b3 cd aa fd			call debug_vector  
37b6				endm  
# End of macro CALLMONITOR
37b6					endif 
37b6			 
37b6 ed 52			sbc hl, de 
37b8			 
37b8			 
37b8				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
37b8			 
37b8 20 26				jr nz, .mloopnotdone 
37ba			 
37ba e1				pop hl   ; get rid of saved I 
37bb				FORTH_LOOP_POP     ; get rid of limit 
37bb cd a2 22			call macro_forth_loop_pop 
37be				endm 
# End of macro FORTH_LOOP_POP
37be			 
37be				FORTH_RSP_POP     ; get rid of DO ptr 
37be cd f7 1f			call macro_forth_rsp_pop 
37c1				endm 
# End of macro FORTH_RSP_POP
37c1			 
37c1			if DEBUG_FORTH_WORDS 
37c1						DMARK "-L>" 
37c1 f5				push af  
37c2 3a d6 37			ld a, (.dmark)  
37c5 32 a6 fd			ld (debug_mark),a  
37c8 3a d7 37			ld a, (.dmark+1)  
37cb 32 a7 fd			ld (debug_mark+1),a  
37ce 3a d8 37			ld a, (.dmark+2)  
37d1 32 a8 fd			ld (debug_mark+2),a  
37d4 18 03			jr .pastdmark  
37d6 ..			.dmark: db "-L>"  
37d9 f1			.pastdmark: pop af  
37da			endm  
# End of macro DMARK
37da				CALLMONITOR 
37da cd aa fd			call debug_vector  
37dd				endm  
# End of macro CALLMONITOR
37dd			endif 
37dd			 
37dd					NEXTW 
37dd c3 ea 23			jp macro_next 
37e0				endm 
# End of macro NEXTW
37e0				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
37e0			 
37e0			.mloopnotdone: 
37e0			 
37e0 e1				pop hl    ; get I 
37e1 2b				dec hl 
37e2			 
37e2			   	; save new I 
37e2			 
37e2			 
37e2					; set I counter 
37e2			 
37e2 22 21 f4				ld (os_current_i), hl 
37e5			 
37e5					 
37e5				FORTH_LOOP_NEXT 
37e5 cd 65 22			call macro_forth_loop_next 
37e8				endm 
# End of macro FORTH_LOOP_NEXT
37e8			 
37e8			 
37e8					if DEBUG_FORTH_WORDS 
37e8 eb						ex de,hl 
37e9					endif 
37e9			 
37e9			;	; get DO ptr 
37e9			; 
37e9				FORTH_RSP_TOS 
37e9 cd ed 1f			call macro_forth_rsp_tos 
37ec				endm 
# End of macro FORTH_RSP_TOS
37ec			 
37ec				;push hl 
37ec			 
37ec				; not going to DO any more 
37ec				; get rid of the RSP pointer as DO will add it back in 
37ec				;FORTH_RSP_POP 
37ec				;pop hl 
37ec			 
37ec			 
37ec 22 fd f3			ld (os_tok_ptr), hl 
37ef					if DEBUG_FORTH_WORDS 
37ef						DMARK "-L<" 
37ef f5				push af  
37f0 3a 04 38			ld a, (.dmark)  
37f3 32 a6 fd			ld (debug_mark),a  
37f6 3a 05 38			ld a, (.dmark+1)  
37f9 32 a7 fd			ld (debug_mark+1),a  
37fc 3a 06 38			ld a, (.dmark+2)  
37ff 32 a8 fd			ld (debug_mark+2),a  
3802 18 03			jr .pastdmark  
3804 ..			.dmark: db "-L<"  
3807 f1			.pastdmark: pop af  
3808			endm  
# End of macro DMARK
3808					CALLMONITOR 
3808 cd aa fd			call debug_vector  
380b				endm  
# End of macro CALLMONITOR
380b				endif 
380b c3 7b 24			jp exec1 
380e			 
380e					 
380e			 
380e			 
380e			 
380e				NEXTW 
380e c3 ea 23			jp macro_next 
3811				endm 
# End of macro NEXTW
3811			 
3811			 
3811			 
3811			 
3811			.REPEAT: 
3811				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3811 71				db WORD_SYS_CORE+93             
3812 64 38			dw .UNTIL            
3814 06				db 5 + 1 
3815 .. 00			db "REPEAT",0              
381c				endm 
# End of macro CWHEAD
381c			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
381c			;  push pc to rsp stack past the REPEAT 
381c					if DEBUG_FORTH_WORDS_KEY 
381c						DMARK "REP" 
381c f5				push af  
381d 3a 31 38			ld a, (.dmark)  
3820 32 a6 fd			ld (debug_mark),a  
3823 3a 32 38			ld a, (.dmark+1)  
3826 32 a7 fd			ld (debug_mark+1),a  
3829 3a 33 38			ld a, (.dmark+2)  
382c 32 a8 fd			ld (debug_mark+2),a  
382f 18 03			jr .pastdmark  
3831 ..			.dmark: db "REP"  
3834 f1			.pastdmark: pop af  
3835			endm  
# End of macro DMARK
3835						CALLMONITOR 
3835 cd aa fd			call debug_vector  
3838				endm  
# End of macro CALLMONITOR
3838					endif 
3838			 
3838 2a fd f3				ld hl, (os_tok_ptr) 
383b 23					inc hl   ; R 
383c 23					inc hl  ; E 
383d 23					inc hl   ; P 
383e 23					inc hl   ; E 
383f 23					inc hl   ; A 
3840 23					inc hl   ; T 
3841 23					inc hl   ; zero 
3842					FORTH_RSP_NEXT 
3842 cd d6 1f			call macro_forth_rsp_next 
3845				endm 
# End of macro FORTH_RSP_NEXT
3845			 
3845			 
3845					if DEBUG_FORTH_WORDS 
3845						DMARK "REP" 
3845 f5				push af  
3846 3a 5a 38			ld a, (.dmark)  
3849 32 a6 fd			ld (debug_mark),a  
384c 3a 5b 38			ld a, (.dmark+1)  
384f 32 a7 fd			ld (debug_mark+1),a  
3852 3a 5c 38			ld a, (.dmark+2)  
3855 32 a8 fd			ld (debug_mark+2),a  
3858 18 03			jr .pastdmark  
385a ..			.dmark: db "REP"  
385d f1			.pastdmark: pop af  
385e			endm  
# End of macro DMARK
385e						;pop bc    ; TODO BUG ?????? what is this for???? 
385e						CALLMONITOR 
385e cd aa fd			call debug_vector  
3861				endm  
# End of macro CALLMONITOR
3861					endif 
3861			 
3861					NEXTW 
3861 c3 ea 23			jp macro_next 
3864				endm 
# End of macro NEXTW
3864			;	       NEXTW 
3864			 
3864			.UNTIL: 
3864				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3864 72				db WORD_SYS_CORE+94             
3865 fb 38			dw .ENDFLOW            
3867 06				db 5 + 1 
3868 .. 00			db "UNTIL",0              
386e				endm 
# End of macro CWHEAD
386e			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
386e			 
386e				; pop tos as check 
386e			 
386e				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
386e			 
386e				FORTH_DSP_VALUEHL 
386e cd 34 22			call macro_dsp_valuehl 
3871				endm 
# End of macro FORTH_DSP_VALUEHL
3871			 
3871					if DEBUG_FORTH_WORDS_KEY 
3871						DMARK "UNT" 
3871 f5				push af  
3872 3a 86 38			ld a, (.dmark)  
3875 32 a6 fd			ld (debug_mark),a  
3878 3a 87 38			ld a, (.dmark+1)  
387b 32 a7 fd			ld (debug_mark+1),a  
387e 3a 88 38			ld a, (.dmark+2)  
3881 32 a8 fd			ld (debug_mark+2),a  
3884 18 03			jr .pastdmark  
3886 ..			.dmark: db "UNT"  
3889 f1			.pastdmark: pop af  
388a			endm  
# End of macro DMARK
388a						CALLMONITOR 
388a cd aa fd			call debug_vector  
388d				endm  
# End of macro CALLMONITOR
388d					endif 
388d			 
388d			;	push hl 
388d				FORTH_DSP_POP 
388d cd ec 22			call macro_forth_dsp_pop 
3890				endm 
# End of macro FORTH_DSP_POP
3890			 
3890			;	pop hl 
3890			 
3890				; test if true 
3890			 
3890 cd 04 10			call ishlzero 
3893			;	ld a,l 
3893			;	add h 
3893			; 
3893			;	cp 0 
3893			 
3893 20 3e			jr nz, .untilnotdone 
3895			 
3895					if DEBUG_FORTH_WORDS 
3895						DMARK "UNf" 
3895 f5				push af  
3896 3a aa 38			ld a, (.dmark)  
3899 32 a6 fd			ld (debug_mark),a  
389c 3a ab 38			ld a, (.dmark+1)  
389f 32 a7 fd			ld (debug_mark+1),a  
38a2 3a ac 38			ld a, (.dmark+2)  
38a5 32 a8 fd			ld (debug_mark+2),a  
38a8 18 03			jr .pastdmark  
38aa ..			.dmark: db "UNf"  
38ad f1			.pastdmark: pop af  
38ae			endm  
# End of macro DMARK
38ae						CALLMONITOR 
38ae cd aa fd			call debug_vector  
38b1				endm  
# End of macro CALLMONITOR
38b1					endif 
38b1			 
38b1			 
38b1			 
38b1				FORTH_RSP_POP     ; get rid of DO ptr 
38b1 cd f7 1f			call macro_forth_rsp_pop 
38b4				endm 
# End of macro FORTH_RSP_POP
38b4			 
38b4			if DEBUG_FORTH_WORDS 
38b4						DMARK "UN>" 
38b4 f5				push af  
38b5 3a c9 38			ld a, (.dmark)  
38b8 32 a6 fd			ld (debug_mark),a  
38bb 3a ca 38			ld a, (.dmark+1)  
38be 32 a7 fd			ld (debug_mark+1),a  
38c1 3a cb 38			ld a, (.dmark+2)  
38c4 32 a8 fd			ld (debug_mark+2),a  
38c7 18 03			jr .pastdmark  
38c9 ..			.dmark: db "UN>"  
38cc f1			.pastdmark: pop af  
38cd			endm  
# End of macro DMARK
38cd				CALLMONITOR 
38cd cd aa fd			call debug_vector  
38d0				endm  
# End of macro CALLMONITOR
38d0			endif 
38d0			 
38d0					NEXTW 
38d0 c3 ea 23			jp macro_next 
38d3				endm 
# End of macro NEXTW
38d3				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
38d3			 
38d3			.untilnotdone: 
38d3			 
38d3			 
38d3			;	; get DO ptr 
38d3			; 
38d3				FORTH_RSP_TOS 
38d3 cd ed 1f			call macro_forth_rsp_tos 
38d6				endm 
# End of macro FORTH_RSP_TOS
38d6			 
38d6				;push hl 
38d6			 
38d6				; not going to DO any more 
38d6				; get rid of the RSP pointer as DO will add it back in 
38d6				;FORTH_RSP_POP 
38d6				;pop hl 
38d6			 
38d6			 
38d6 22 fd f3			ld (os_tok_ptr), hl 
38d9					if DEBUG_FORTH_WORDS 
38d9						DMARK "UN<" 
38d9 f5				push af  
38da 3a ee 38			ld a, (.dmark)  
38dd 32 a6 fd			ld (debug_mark),a  
38e0 3a ef 38			ld a, (.dmark+1)  
38e3 32 a7 fd			ld (debug_mark+1),a  
38e6 3a f0 38			ld a, (.dmark+2)  
38e9 32 a8 fd			ld (debug_mark+2),a  
38ec 18 03			jr .pastdmark  
38ee ..			.dmark: db "UN<"  
38f1 f1			.pastdmark: pop af  
38f2			endm  
# End of macro DMARK
38f2					CALLMONITOR 
38f2 cd aa fd			call debug_vector  
38f5				endm  
# End of macro CALLMONITOR
38f5				endif 
38f5 c3 7b 24			jp exec1 
38f8			 
38f8					 
38f8			 
38f8			 
38f8					NEXTW 
38f8 c3 ea 23			jp macro_next 
38fb				endm 
# End of macro NEXTW
38fb			 
38fb			 
38fb			.ENDFLOW: 
38fb			 
38fb			; eof 
38fb			 
# End of file forth_words_flow.asm
38fb			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
38fb			include "forth_words_logic.asm" 
38fb			 
38fb			; | ## Logic Words 
38fb			 
38fb			.NOT: 
38fb				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
38fb 2d				db WORD_SYS_CORE+25             
38fc 43 39			dw .IS            
38fe 04				db 3 + 1 
38ff .. 00			db "NOT",0              
3903				endm 
# End of macro CWHEAD
3903			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3903					if DEBUG_FORTH_WORDS_KEY 
3903						DMARK "NOT" 
3903 f5				push af  
3904 3a 18 39			ld a, (.dmark)  
3907 32 a6 fd			ld (debug_mark),a  
390a 3a 19 39			ld a, (.dmark+1)  
390d 32 a7 fd			ld (debug_mark+1),a  
3910 3a 1a 39			ld a, (.dmark+2)  
3913 32 a8 fd			ld (debug_mark+2),a  
3916 18 03			jr .pastdmark  
3918 ..			.dmark: db "NOT"  
391b f1			.pastdmark: pop af  
391c			endm  
# End of macro DMARK
391c						CALLMONITOR 
391c cd aa fd			call debug_vector  
391f				endm  
# End of macro CALLMONITOR
391f					endif 
391f					FORTH_DSP 
391f cd fa 21			call macro_forth_dsp 
3922				endm 
# End of macro FORTH_DSP
3922 7e					ld a,(hl)	; get type of value on TOS 
3923 fe 02				cp DS_TYPE_INUM  
3925 28 03				jr z, .noti 
3927					NEXTW 
3927 c3 ea 23			jp macro_next 
392a				endm 
# End of macro NEXTW
392a			.noti:          FORTH_DSP_VALUEHL 
392a cd 34 22			call macro_dsp_valuehl 
392d				endm 
# End of macro FORTH_DSP_VALUEHL
392d			;		push hl 
392d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
392d cd ec 22			call macro_forth_dsp_pop 
3930				endm 
# End of macro FORTH_DSP_POP
3930			;		pop hl 
3930 3e 00				ld a,0 
3932 bd					cp l 
3933 28 04				jr z, .not2t 
3935 2e 00				ld l, 0 
3937 18 02				jr .notip 
3939			 
3939 2e ff		.not2t:		ld l, 255 
393b			 
393b 26 00		.notip:		ld h, 0	 
393d			 
393d cd 2f 20				call forth_push_numhl 
3940					NEXTW 
3940 c3 ea 23			jp macro_next 
3943				endm 
# End of macro NEXTW
3943			 
3943			.IS: 
3943				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3943 2d				db WORD_SYS_CORE+25             
3944 69 39			dw .LZERO            
3946 03				db 2 + 1 
3947 .. 00			db "IS",0              
394a				endm 
# End of macro CWHEAD
394a			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
394a					if DEBUG_FORTH_WORDS_KEY 
394a						DMARK "IS." 
394a f5				push af  
394b 3a 5f 39			ld a, (.dmark)  
394e 32 a6 fd			ld (debug_mark),a  
3951 3a 60 39			ld a, (.dmark+1)  
3954 32 a7 fd			ld (debug_mark+1),a  
3957 3a 61 39			ld a, (.dmark+2)  
395a 32 a8 fd			ld (debug_mark+2),a  
395d 18 03			jr .pastdmark  
395f ..			.dmark: db "IS."  
3962 f1			.pastdmark: pop af  
3963			endm  
# End of macro DMARK
3963						CALLMONITOR 
3963 cd aa fd			call debug_vector  
3966				endm  
# End of macro CALLMONITOR
3966					endif 
3966					NEXTW 
3966 c3 ea 23			jp macro_next 
3969				endm 
# End of macro NEXTW
3969			.LZERO: 
3969				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3969 2d				db WORD_SYS_CORE+25             
396a 73 39			dw .TZERO            
396c 03				db 2 + 1 
396d .. 00			db "0<",0              
3970				endm 
# End of macro CWHEAD
3970			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3970					NEXTW 
3970 c3 ea 23			jp macro_next 
3973				endm 
# End of macro NEXTW
3973			.TZERO: 
3973				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3973 2e				db WORD_SYS_CORE+26             
3974 ba 39			dw .LESS            
3976 03				db 2 + 1 
3977 .. 00			db "0=",0              
397a				endm 
# End of macro CWHEAD
397a			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
397a				; TODO add floating point number detection 
397a					;v5 FORTH_DSP_VALUE 
397a					if DEBUG_FORTH_WORDS_KEY 
397a						DMARK "0=." 
397a f5				push af  
397b 3a 8f 39			ld a, (.dmark)  
397e 32 a6 fd			ld (debug_mark),a  
3981 3a 90 39			ld a, (.dmark+1)  
3984 32 a7 fd			ld (debug_mark+1),a  
3987 3a 91 39			ld a, (.dmark+2)  
398a 32 a8 fd			ld (debug_mark+2),a  
398d 18 03			jr .pastdmark  
398f ..			.dmark: db "0=."  
3992 f1			.pastdmark: pop af  
3993			endm  
# End of macro DMARK
3993						CALLMONITOR 
3993 cd aa fd			call debug_vector  
3996				endm  
# End of macro CALLMONITOR
3996					endif 
3996					FORTH_DSP 
3996 cd fa 21			call macro_forth_dsp 
3999				endm 
# End of macro FORTH_DSP
3999 7e					ld a,(hl)	; get type of value on TOS 
399a fe 02				cp DS_TYPE_INUM  
399c 28 00				jr z, .tz_inum 
399e			 
399e				if FORTH_ENABLE_FLOATMATH 
399e					jr .tz_done 
399e			 
399e				endif 
399e					 
399e			 
399e			.tz_inum: 
399e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
399e cd 34 22			call macro_dsp_valuehl 
39a1				endm 
# End of macro FORTH_DSP_VALUEHL
39a1			 
39a1			;		push hl 
39a1			 
39a1					; destroy value TOS 
39a1			 
39a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39a1 cd ec 22			call macro_forth_dsp_pop 
39a4				endm 
# End of macro FORTH_DSP_POP
39a4			 
39a4			;		pop hl 
39a4			 
39a4 3e 00				ld a,0 
39a6			 
39a6 bd					cp l 
39a7 20 08				jr nz, .tz_notzero 
39a9			 
39a9 bc					cp h 
39aa			 
39aa 20 05				jr nz, .tz_notzero 
39ac			 
39ac			 
39ac 21 01 00				ld hl, FORTH_TRUE 
39af 18 03				jr .tz_done 
39b1			 
39b1 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
39b4			 
39b4					; push value back onto stack for another op etc 
39b4			 
39b4			.tz_done: 
39b4 cd 2f 20				call forth_push_numhl 
39b7			 
39b7					NEXTW 
39b7 c3 ea 23			jp macro_next 
39ba				endm 
# End of macro NEXTW
39ba			.LESS: 
39ba				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
39ba 2f				db WORD_SYS_CORE+27             
39bb 23 3a			dw .GT            
39bd 02				db 1 + 1 
39be .. 00			db "<",0              
39c0				endm 
# End of macro CWHEAD
39c0			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
39c0				; TODO add floating point number detection 
39c0					if DEBUG_FORTH_WORDS_KEY 
39c0						DMARK "LES" 
39c0 f5				push af  
39c1 3a d5 39			ld a, (.dmark)  
39c4 32 a6 fd			ld (debug_mark),a  
39c7 3a d6 39			ld a, (.dmark+1)  
39ca 32 a7 fd			ld (debug_mark+1),a  
39cd 3a d7 39			ld a, (.dmark+2)  
39d0 32 a8 fd			ld (debug_mark+2),a  
39d3 18 03			jr .pastdmark  
39d5 ..			.dmark: db "LES"  
39d8 f1			.pastdmark: pop af  
39d9			endm  
# End of macro DMARK
39d9						CALLMONITOR 
39d9 cd aa fd			call debug_vector  
39dc				endm  
# End of macro CALLMONITOR
39dc					endif 
39dc					FORTH_DSP 
39dc cd fa 21			call macro_forth_dsp 
39df				endm 
# End of macro FORTH_DSP
39df					;v5 FORTH_DSP_VALUE 
39df 7e					ld a,(hl)	; get type of value on TOS 
39e0 fe 02				cp DS_TYPE_INUM  
39e2 28 00				jr z, .less_inum 
39e4			 
39e4				if FORTH_ENABLE_FLOATMATH 
39e4					jr .less_done 
39e4			 
39e4				endif 
39e4					 
39e4			 
39e4			.less_inum: 
39e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39e4 cd 34 22			call macro_dsp_valuehl 
39e7				endm 
# End of macro FORTH_DSP_VALUEHL
39e7			 
39e7 e5					push hl  ; u2 
39e8			 
39e8					; destroy value TOS 
39e8			 
39e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39e8 cd ec 22			call macro_forth_dsp_pop 
39eb				endm 
# End of macro FORTH_DSP_POP
39eb			 
39eb			 
39eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39eb cd 34 22			call macro_dsp_valuehl 
39ee				endm 
# End of macro FORTH_DSP_VALUEHL
39ee			 
39ee e5					push hl    ; u1 
39ef			 
39ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39ef cd ec 22			call macro_forth_dsp_pop 
39f2				endm 
# End of macro FORTH_DSP_POP
39f2			 
39f2			 
39f2 b7			 or a      ;clear carry flag 
39f3 01 00 00		 ld bc, FORTH_FALSE 
39f6 e1			  pop hl    ; u1 
39f7 d1			  pop de    ; u2 
39f8 ed 52		  sbc hl,de 
39fa 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
39fc			 
39fc 01 01 00		 ld bc, FORTH_TRUE 
39ff			.lscont:  
39ff c5					push bc 
3a00 e1					pop hl 
3a01			 
3a01					if DEBUG_FORTH_WORDS 
3a01						DMARK "LT1" 
3a01 f5				push af  
3a02 3a 16 3a			ld a, (.dmark)  
3a05 32 a6 fd			ld (debug_mark),a  
3a08 3a 17 3a			ld a, (.dmark+1)  
3a0b 32 a7 fd			ld (debug_mark+1),a  
3a0e 3a 18 3a			ld a, (.dmark+2)  
3a11 32 a8 fd			ld (debug_mark+2),a  
3a14 18 03			jr .pastdmark  
3a16 ..			.dmark: db "LT1"  
3a19 f1			.pastdmark: pop af  
3a1a			endm  
# End of macro DMARK
3a1a						CALLMONITOR 
3a1a cd aa fd			call debug_vector  
3a1d				endm  
# End of macro CALLMONITOR
3a1d					endif 
3a1d cd 2f 20				call forth_push_numhl 
3a20			 
3a20					NEXTW 
3a20 c3 ea 23			jp macro_next 
3a23				endm 
# End of macro NEXTW
3a23			.GT: 
3a23				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3a23 30				db WORD_SYS_CORE+28             
3a24 8c 3a			dw .EQUAL            
3a26 02				db 1 + 1 
3a27 .. 00			db ">",0              
3a29				endm 
# End of macro CWHEAD
3a29			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3a29				; TODO add floating point number detection 
3a29					if DEBUG_FORTH_WORDS_KEY 
3a29						DMARK "GRT" 
3a29 f5				push af  
3a2a 3a 3e 3a			ld a, (.dmark)  
3a2d 32 a6 fd			ld (debug_mark),a  
3a30 3a 3f 3a			ld a, (.dmark+1)  
3a33 32 a7 fd			ld (debug_mark+1),a  
3a36 3a 40 3a			ld a, (.dmark+2)  
3a39 32 a8 fd			ld (debug_mark+2),a  
3a3c 18 03			jr .pastdmark  
3a3e ..			.dmark: db "GRT"  
3a41 f1			.pastdmark: pop af  
3a42			endm  
# End of macro DMARK
3a42						CALLMONITOR 
3a42 cd aa fd			call debug_vector  
3a45				endm  
# End of macro CALLMONITOR
3a45					endif 
3a45					FORTH_DSP 
3a45 cd fa 21			call macro_forth_dsp 
3a48				endm 
# End of macro FORTH_DSP
3a48					;FORTH_DSP_VALUE 
3a48 7e					ld a,(hl)	; get type of value on TOS 
3a49 fe 02				cp DS_TYPE_INUM  
3a4b 28 00				jr z, .gt_inum 
3a4d			 
3a4d				if FORTH_ENABLE_FLOATMATH 
3a4d					jr .gt_done 
3a4d			 
3a4d				endif 
3a4d					 
3a4d			 
3a4d			.gt_inum: 
3a4d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a4d cd 34 22			call macro_dsp_valuehl 
3a50				endm 
# End of macro FORTH_DSP_VALUEHL
3a50			 
3a50 e5					push hl  ; u2 
3a51			 
3a51					; destroy value TOS 
3a51			 
3a51					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a51 cd ec 22			call macro_forth_dsp_pop 
3a54				endm 
# End of macro FORTH_DSP_POP
3a54			 
3a54			 
3a54					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a54 cd 34 22			call macro_dsp_valuehl 
3a57				endm 
# End of macro FORTH_DSP_VALUEHL
3a57			 
3a57 e5					push hl    ; u1 
3a58			 
3a58					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a58 cd ec 22			call macro_forth_dsp_pop 
3a5b				endm 
# End of macro FORTH_DSP_POP
3a5b			 
3a5b			 
3a5b b7			 or a      ;clear carry flag 
3a5c 01 00 00		 ld bc, FORTH_FALSE 
3a5f e1			  pop hl    ; u1 
3a60 d1			  pop de    ; u2 
3a61 ed 52		  sbc hl,de 
3a63 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3a65			 
3a65 01 01 00		 ld bc, FORTH_TRUE 
3a68			.gtcont:  
3a68 c5					push bc 
3a69 e1					pop hl 
3a6a			 
3a6a					if DEBUG_FORTH_WORDS 
3a6a						DMARK "GT1" 
3a6a f5				push af  
3a6b 3a 7f 3a			ld a, (.dmark)  
3a6e 32 a6 fd			ld (debug_mark),a  
3a71 3a 80 3a			ld a, (.dmark+1)  
3a74 32 a7 fd			ld (debug_mark+1),a  
3a77 3a 81 3a			ld a, (.dmark+2)  
3a7a 32 a8 fd			ld (debug_mark+2),a  
3a7d 18 03			jr .pastdmark  
3a7f ..			.dmark: db "GT1"  
3a82 f1			.pastdmark: pop af  
3a83			endm  
# End of macro DMARK
3a83						CALLMONITOR 
3a83 cd aa fd			call debug_vector  
3a86				endm  
# End of macro CALLMONITOR
3a86					endif 
3a86 cd 2f 20				call forth_push_numhl 
3a89			 
3a89					NEXTW 
3a89 c3 ea 23			jp macro_next 
3a8c				endm 
# End of macro NEXTW
3a8c			.EQUAL: 
3a8c				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3a8c 31				db WORD_SYS_CORE+29             
3a8d f7 3a			dw .ENDLOGIC            
3a8f 02				db 1 + 1 
3a90 .. 00			db "=",0              
3a92				endm 
# End of macro CWHEAD
3a92			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3a92				; TODO add floating point number detection 
3a92					if DEBUG_FORTH_WORDS_KEY 
3a92						DMARK "EQ." 
3a92 f5				push af  
3a93 3a a7 3a			ld a, (.dmark)  
3a96 32 a6 fd			ld (debug_mark),a  
3a99 3a a8 3a			ld a, (.dmark+1)  
3a9c 32 a7 fd			ld (debug_mark+1),a  
3a9f 3a a9 3a			ld a, (.dmark+2)  
3aa2 32 a8 fd			ld (debug_mark+2),a  
3aa5 18 03			jr .pastdmark  
3aa7 ..			.dmark: db "EQ."  
3aaa f1			.pastdmark: pop af  
3aab			endm  
# End of macro DMARK
3aab						CALLMONITOR 
3aab cd aa fd			call debug_vector  
3aae				endm  
# End of macro CALLMONITOR
3aae					endif 
3aae					FORTH_DSP 
3aae cd fa 21			call macro_forth_dsp 
3ab1				endm 
# End of macro FORTH_DSP
3ab1					;v5 FORTH_DSP_VALUE 
3ab1 7e					ld a,(hl)	; get type of value on TOS 
3ab2 fe 02				cp DS_TYPE_INUM  
3ab4 28 00				jr z, .eq_inum 
3ab6			 
3ab6				if FORTH_ENABLE_FLOATMATH 
3ab6					jr .eq_done 
3ab6			 
3ab6				endif 
3ab6					 
3ab6			 
3ab6			.eq_inum: 
3ab6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ab6 cd 34 22			call macro_dsp_valuehl 
3ab9				endm 
# End of macro FORTH_DSP_VALUEHL
3ab9			 
3ab9 e5					push hl 
3aba			 
3aba					; destroy value TOS 
3aba			 
3aba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aba cd ec 22			call macro_forth_dsp_pop 
3abd				endm 
# End of macro FORTH_DSP_POP
3abd			 
3abd			 
3abd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3abd cd 34 22			call macro_dsp_valuehl 
3ac0				endm 
# End of macro FORTH_DSP_VALUEHL
3ac0			 
3ac0					; one value on hl get other one back 
3ac0			 
3ac0 e5					push hl 
3ac1			 
3ac1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ac1 cd ec 22			call macro_forth_dsp_pop 
3ac4				endm 
# End of macro FORTH_DSP_POP
3ac4			 
3ac4 0e 00				ld c, FORTH_FALSE 
3ac6			 
3ac6 e1					pop hl 
3ac7 d1					pop de 
3ac8			 
3ac8 7b					ld a, e 
3ac9 bd					cp l 
3aca			 
3aca 20 06				jr nz, .eq_done 
3acc			 
3acc 7a					ld a, d 
3acd bc					cp h 
3ace			 
3ace 20 02				jr nz, .eq_done 
3ad0			 
3ad0 0e 01				ld c, FORTH_TRUE 
3ad2					 
3ad2			 
3ad2			 
3ad2			.eq_done: 
3ad2			 
3ad2					; TODO push value back onto stack for another op etc 
3ad2			 
3ad2 26 00				ld h, 0 
3ad4 69					ld l, c 
3ad5					if DEBUG_FORTH_WORDS 
3ad5						DMARK "EQ1" 
3ad5 f5				push af  
3ad6 3a ea 3a			ld a, (.dmark)  
3ad9 32 a6 fd			ld (debug_mark),a  
3adc 3a eb 3a			ld a, (.dmark+1)  
3adf 32 a7 fd			ld (debug_mark+1),a  
3ae2 3a ec 3a			ld a, (.dmark+2)  
3ae5 32 a8 fd			ld (debug_mark+2),a  
3ae8 18 03			jr .pastdmark  
3aea ..			.dmark: db "EQ1"  
3aed f1			.pastdmark: pop af  
3aee			endm  
# End of macro DMARK
3aee						CALLMONITOR 
3aee cd aa fd			call debug_vector  
3af1				endm  
# End of macro CALLMONITOR
3af1					endif 
3af1 cd 2f 20				call forth_push_numhl 
3af4			 
3af4					NEXTW 
3af4 c3 ea 23			jp macro_next 
3af7				endm 
# End of macro NEXTW
3af7			 
3af7			 
3af7			.ENDLOGIC: 
3af7			; eof 
3af7			 
3af7			 
# End of file forth_words_logic.asm
3af7			include "forth_words_maths.asm" 
3af7			 
3af7			; | ## Maths Words 
3af7			 
3af7			.PLUS:	 
3af7				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3af7 15				db WORD_SYS_CORE+1             
3af8 55 3b			dw .NEG            
3afa 02				db 1 + 1 
3afb .. 00			db "+",0              
3afd				endm 
# End of macro CWHEAD
3afd			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3afd					if DEBUG_FORTH_WORDS_KEY 
3afd						DMARK "PLU" 
3afd f5				push af  
3afe 3a 12 3b			ld a, (.dmark)  
3b01 32 a6 fd			ld (debug_mark),a  
3b04 3a 13 3b			ld a, (.dmark+1)  
3b07 32 a7 fd			ld (debug_mark+1),a  
3b0a 3a 14 3b			ld a, (.dmark+2)  
3b0d 32 a8 fd			ld (debug_mark+2),a  
3b10 18 03			jr .pastdmark  
3b12 ..			.dmark: db "PLU"  
3b15 f1			.pastdmark: pop af  
3b16			endm  
# End of macro DMARK
3b16						CALLMONITOR 
3b16 cd aa fd			call debug_vector  
3b19				endm  
# End of macro CALLMONITOR
3b19					endif 
3b19					; add top two values and push back result 
3b19			 
3b19					;for v5 FORTH_DSP_VALUE 
3b19					FORTH_DSP 
3b19 cd fa 21			call macro_forth_dsp 
3b1c				endm 
# End of macro FORTH_DSP
3b1c 7e					ld a,(hl)	; get type of value on TOS 
3b1d fe 02				cp DS_TYPE_INUM  
3b1f 28 03				jr z, .dot_inum 
3b21			 
3b21					NEXTW 
3b21 c3 ea 23			jp macro_next 
3b24				endm 
# End of macro NEXTW
3b24			 
3b24			; float maths 
3b24			 
3b24				if FORTH_ENABLE_FLOATMATH 
3b24						inc hl      ; now at start of numeric as string 
3b24			 
3b24					if DEBUG_FORTH_MATHS 
3b24						DMARK "ADD" 
3b24				CALLMONITOR 
3b24					endif 
3b24			 
3b24					;ld ix, hl 
3b24					call CON 
3b24			 
3b24			 
3b24					push hl 
3b24					 
3b24					 
3b24			 
3b24						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3b24			 
3b24					; get next number 
3b24			 
3b24						FORTH_DSP_VALUE 
3b24			 
3b24						inc hl      ; now at start of numeric as string 
3b24			 
3b24					;ld ix, hl 
3b24					call CON 
3b24			 
3b24					push hl 
3b24			 
3b24			 
3b24						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b24			 
3b24						; TODO do add 
3b24			 
3b24						call IADD 
3b24			 
3b24						; TODO get result back as ascii 
3b24			 
3b24						; TODO push result  
3b24			 
3b24			 
3b24			 
3b24						jr .dot_done 
3b24				endif 
3b24			 
3b24			.dot_inum: 
3b24			 
3b24			 
3b24					if DEBUG_FORTH_DOT 
3b24						DMARK "+IT" 
3b24 f5				push af  
3b25 3a 39 3b			ld a, (.dmark)  
3b28 32 a6 fd			ld (debug_mark),a  
3b2b 3a 3a 3b			ld a, (.dmark+1)  
3b2e 32 a7 fd			ld (debug_mark+1),a  
3b31 3a 3b 3b			ld a, (.dmark+2)  
3b34 32 a8 fd			ld (debug_mark+2),a  
3b37 18 03			jr .pastdmark  
3b39 ..			.dmark: db "+IT"  
3b3c f1			.pastdmark: pop af  
3b3d			endm  
# End of macro DMARK
3b3d				CALLMONITOR 
3b3d cd aa fd			call debug_vector  
3b40				endm  
# End of macro CALLMONITOR
3b40					endif 
3b40			 
3b40					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b40 cd 34 22			call macro_dsp_valuehl 
3b43				endm 
# End of macro FORTH_DSP_VALUEHL
3b43			 
3b43				; TODO add floating point number detection 
3b43			 
3b43 e5					push hl 
3b44			 
3b44					; destroy value TOS 
3b44			 
3b44					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b44 cd ec 22			call macro_forth_dsp_pop 
3b47				endm 
# End of macro FORTH_DSP_POP
3b47			 
3b47			 
3b47					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b47 cd 34 22			call macro_dsp_valuehl 
3b4a				endm 
# End of macro FORTH_DSP_VALUEHL
3b4a			 
3b4a					; one value on hl get other one back 
3b4a			 
3b4a d1					pop de 
3b4b			 
3b4b					; do the add 
3b4b			 
3b4b 19					add hl,de 
3b4c			 
3b4c					; save it 
3b4c			 
3b4c			;		push hl	 
3b4c			 
3b4c					; 
3b4c			 
3b4c					; destroy value TOS 
3b4c			 
3b4c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b4c cd ec 22			call macro_forth_dsp_pop 
3b4f				endm 
# End of macro FORTH_DSP_POP
3b4f			 
3b4f					; TODO push value back onto stack for another op etc 
3b4f			 
3b4f			;		pop hl 
3b4f			 
3b4f			.dot_done: 
3b4f cd 2f 20				call forth_push_numhl 
3b52			 
3b52					NEXTW 
3b52 c3 ea 23			jp macro_next 
3b55				endm 
# End of macro NEXTW
3b55			.NEG: 
3b55			 
3b55				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3b55 17				db WORD_SYS_CORE+3             
3b56 98 3b			dw .DIV            
3b58 02				db 1 + 1 
3b59 .. 00			db "-",0              
3b5b				endm 
# End of macro CWHEAD
3b5b			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3b5b					if DEBUG_FORTH_WORDS_KEY 
3b5b						DMARK "SUB" 
3b5b f5				push af  
3b5c 3a 70 3b			ld a, (.dmark)  
3b5f 32 a6 fd			ld (debug_mark),a  
3b62 3a 71 3b			ld a, (.dmark+1)  
3b65 32 a7 fd			ld (debug_mark+1),a  
3b68 3a 72 3b			ld a, (.dmark+2)  
3b6b 32 a8 fd			ld (debug_mark+2),a  
3b6e 18 03			jr .pastdmark  
3b70 ..			.dmark: db "SUB"  
3b73 f1			.pastdmark: pop af  
3b74			endm  
# End of macro DMARK
3b74						CALLMONITOR 
3b74 cd aa fd			call debug_vector  
3b77				endm  
# End of macro CALLMONITOR
3b77					endif 
3b77			 
3b77			 
3b77				; TODO add floating point number detection 
3b77					; v5 FORTH_DSP_VALUE 
3b77					FORTH_DSP 
3b77 cd fa 21			call macro_forth_dsp 
3b7a				endm 
# End of macro FORTH_DSP
3b7a 7e					ld a,(hl)	; get type of value on TOS 
3b7b fe 02				cp DS_TYPE_INUM  
3b7d 28 03				jr z, .neg_inum 
3b7f			 
3b7f					NEXTW 
3b7f c3 ea 23			jp macro_next 
3b82				endm 
# End of macro NEXTW
3b82			 
3b82			; float maths 
3b82			 
3b82				if FORTH_ENABLE_FLOATMATH 
3b82					jr .neg_done 
3b82			 
3b82				endif 
3b82					 
3b82			 
3b82			.neg_inum: 
3b82					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b82 cd 34 22			call macro_dsp_valuehl 
3b85				endm 
# End of macro FORTH_DSP_VALUEHL
3b85			 
3b85 e5					push hl 
3b86			 
3b86					; destroy value TOS 
3b86			 
3b86					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b86 cd ec 22			call macro_forth_dsp_pop 
3b89				endm 
# End of macro FORTH_DSP_POP
3b89			 
3b89			 
3b89					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b89 cd 34 22			call macro_dsp_valuehl 
3b8c				endm 
# End of macro FORTH_DSP_VALUEHL
3b8c			 
3b8c					; one value on hl get other one back 
3b8c			 
3b8c d1					pop de 
3b8d			 
3b8d					; do the sub 
3b8d			;		ex de, hl 
3b8d			 
3b8d ed 52				sbc hl,de 
3b8f			 
3b8f					; save it 
3b8f			 
3b8f			;		push hl	 
3b8f			 
3b8f					; 
3b8f			 
3b8f					; destroy value TOS 
3b8f			 
3b8f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b8f cd ec 22			call macro_forth_dsp_pop 
3b92				endm 
# End of macro FORTH_DSP_POP
3b92			 
3b92					; TODO push value back onto stack for another op etc 
3b92			 
3b92			;		pop hl 
3b92			 
3b92 cd 2f 20				call forth_push_numhl 
3b95			.neg_done: 
3b95			 
3b95					NEXTW 
3b95 c3 ea 23			jp macro_next 
3b98				endm 
# End of macro NEXTW
3b98			.DIV: 
3b98				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3b98 18				db WORD_SYS_CORE+4             
3b99 e5 3b			dw .MUL            
3b9b 02				db 1 + 1 
3b9c .. 00			db "/",0              
3b9e				endm 
# End of macro CWHEAD
3b9e			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3b9e					if DEBUG_FORTH_WORDS_KEY 
3b9e						DMARK "DIV" 
3b9e f5				push af  
3b9f 3a b3 3b			ld a, (.dmark)  
3ba2 32 a6 fd			ld (debug_mark),a  
3ba5 3a b4 3b			ld a, (.dmark+1)  
3ba8 32 a7 fd			ld (debug_mark+1),a  
3bab 3a b5 3b			ld a, (.dmark+2)  
3bae 32 a8 fd			ld (debug_mark+2),a  
3bb1 18 03			jr .pastdmark  
3bb3 ..			.dmark: db "DIV"  
3bb6 f1			.pastdmark: pop af  
3bb7			endm  
# End of macro DMARK
3bb7						CALLMONITOR 
3bb7 cd aa fd			call debug_vector  
3bba				endm  
# End of macro CALLMONITOR
3bba					endif 
3bba				; TODO add floating point number detection 
3bba					; v5 FORTH_DSP_VALUE 
3bba					FORTH_DSP 
3bba cd fa 21			call macro_forth_dsp 
3bbd				endm 
# End of macro FORTH_DSP
3bbd 7e					ld a,(hl)	; get type of value on TOS 
3bbe fe 02				cp DS_TYPE_INUM  
3bc0 28 03				jr z, .div_inum 
3bc2			 
3bc2				if FORTH_ENABLE_FLOATMATH 
3bc2					jr .div_done 
3bc2			 
3bc2				endif 
3bc2					NEXTW 
3bc2 c3 ea 23			jp macro_next 
3bc5				endm 
# End of macro NEXTW
3bc5			.div_inum: 
3bc5			 
3bc5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bc5 cd 34 22			call macro_dsp_valuehl 
3bc8				endm 
# End of macro FORTH_DSP_VALUEHL
3bc8			 
3bc8 e5					push hl    ; to go to bc 
3bc9			 
3bc9					; destroy value TOS 
3bc9			 
3bc9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bc9 cd ec 22			call macro_forth_dsp_pop 
3bcc				endm 
# End of macro FORTH_DSP_POP
3bcc			 
3bcc			 
3bcc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bcc cd 34 22			call macro_dsp_valuehl 
3bcf				endm 
# End of macro FORTH_DSP_VALUEHL
3bcf			 
3bcf					; hl to go to de 
3bcf			 
3bcf e5					push hl 
3bd0			 
3bd0 c1					pop bc 
3bd1 d1					pop de		 
3bd2			 
3bd2			 
3bd2					if DEBUG_FORTH_MATHS 
3bd2						DMARK "DIV" 
3bd2				CALLMONITOR 
3bd2					endif 
3bd2					; one value on hl but move to a get other one back 
3bd2			 
3bd2			        
3bd2 cd 38 0f			call Div16 
3bd5			 
3bd5			;	push af	 
3bd5 e5				push hl 
3bd6 c5				push bc 
3bd7			 
3bd7					if DEBUG_FORTH_MATHS 
3bd7						DMARK "DI1" 
3bd7				CALLMONITOR 
3bd7					endif 
3bd7			 
3bd7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bd7 cd ec 22			call macro_forth_dsp_pop 
3bda				endm 
# End of macro FORTH_DSP_POP
3bda			 
3bda			 
3bda			 
3bda e1					pop hl    ; result 
3bdb			 
3bdb cd 2f 20				call forth_push_numhl 
3bde			 
3bde e1					pop hl    ; reminder 
3bdf			;		ld h,0 
3bdf			;		ld l,d 
3bdf			 
3bdf cd 2f 20				call forth_push_numhl 
3be2			.div_done: 
3be2					NEXTW 
3be2 c3 ea 23			jp macro_next 
3be5				endm 
# End of macro NEXTW
3be5			.MUL: 
3be5				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3be5 19				db WORD_SYS_CORE+5             
3be6 2a 3c			dw .MIN            
3be8 02				db 1 + 1 
3be9 .. 00			db "*",0              
3beb				endm 
# End of macro CWHEAD
3beb			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3beb				; TODO add floating point number detection 
3beb					if DEBUG_FORTH_WORDS_KEY 
3beb						DMARK "MUL" 
3beb f5				push af  
3bec 3a 00 3c			ld a, (.dmark)  
3bef 32 a6 fd			ld (debug_mark),a  
3bf2 3a 01 3c			ld a, (.dmark+1)  
3bf5 32 a7 fd			ld (debug_mark+1),a  
3bf8 3a 02 3c			ld a, (.dmark+2)  
3bfb 32 a8 fd			ld (debug_mark+2),a  
3bfe 18 03			jr .pastdmark  
3c00 ..			.dmark: db "MUL"  
3c03 f1			.pastdmark: pop af  
3c04			endm  
# End of macro DMARK
3c04						CALLMONITOR 
3c04 cd aa fd			call debug_vector  
3c07				endm  
# End of macro CALLMONITOR
3c07					endif 
3c07					FORTH_DSP 
3c07 cd fa 21			call macro_forth_dsp 
3c0a				endm 
# End of macro FORTH_DSP
3c0a					; v5 FORTH_DSP_VALUE 
3c0a 7e					ld a,(hl)	; get type of value on TOS 
3c0b fe 02				cp DS_TYPE_INUM  
3c0d 28 03				jr z, .mul_inum 
3c0f			 
3c0f				if FORTH_ENABLE_FLOATMATH 
3c0f					jr .mul_done 
3c0f			 
3c0f				endif 
3c0f			 
3c0f					NEXTW 
3c0f c3 ea 23			jp macro_next 
3c12				endm 
# End of macro NEXTW
3c12			.mul_inum:	 
3c12			 
3c12					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c12 cd 34 22			call macro_dsp_valuehl 
3c15				endm 
# End of macro FORTH_DSP_VALUEHL
3c15			 
3c15 e5					push hl 
3c16			 
3c16					; destroy value TOS 
3c16			 
3c16					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c16 cd ec 22			call macro_forth_dsp_pop 
3c19				endm 
# End of macro FORTH_DSP_POP
3c19			 
3c19			 
3c19					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c19 cd 34 22			call macro_dsp_valuehl 
3c1c				endm 
# End of macro FORTH_DSP_VALUEHL
3c1c			 
3c1c					; one value on hl but move to a get other one back 
3c1c			 
3c1c 7d					ld a, l 
3c1d			 
3c1d d1					pop de 
3c1e			 
3c1e					; do the mull 
3c1e			;		ex de, hl 
3c1e			 
3c1e cd 5e 0f				call Mult16 
3c21					; save it 
3c21			 
3c21			;		push hl	 
3c21			 
3c21					; 
3c21			 
3c21					; destroy value TOS 
3c21			 
3c21					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c21 cd ec 22			call macro_forth_dsp_pop 
3c24				endm 
# End of macro FORTH_DSP_POP
3c24			 
3c24					; TODO push value back onto stack for another op etc 
3c24			 
3c24			;		pop hl 
3c24			 
3c24 cd 2f 20				call forth_push_numhl 
3c27			 
3c27			.mul_done: 
3c27					NEXTW 
3c27 c3 ea 23			jp macro_next 
3c2a				endm 
# End of macro NEXTW
3c2a			 
3c2a			 
3c2a			 
3c2a			 
3c2a			.MIN: 
3c2a				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3c2a 49				db WORD_SYS_CORE+53             
3c2b ab 3c			dw .MAX            
3c2d 04				db 3 + 1 
3c2e .. 00			db "MIN",0              
3c32				endm 
# End of macro CWHEAD
3c32			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3c32					if DEBUG_FORTH_WORDS_KEY 
3c32						DMARK "MIN" 
3c32 f5				push af  
3c33 3a 47 3c			ld a, (.dmark)  
3c36 32 a6 fd			ld (debug_mark),a  
3c39 3a 48 3c			ld a, (.dmark+1)  
3c3c 32 a7 fd			ld (debug_mark+1),a  
3c3f 3a 49 3c			ld a, (.dmark+2)  
3c42 32 a8 fd			ld (debug_mark+2),a  
3c45 18 03			jr .pastdmark  
3c47 ..			.dmark: db "MIN"  
3c4a f1			.pastdmark: pop af  
3c4b			endm  
# End of macro DMARK
3c4b						CALLMONITOR 
3c4b cd aa fd			call debug_vector  
3c4e				endm  
# End of macro CALLMONITOR
3c4e					endif 
3c4e					; get u2 
3c4e			 
3c4e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c4e cd 34 22			call macro_dsp_valuehl 
3c51				endm 
# End of macro FORTH_DSP_VALUEHL
3c51			 
3c51 e5					push hl   ; u2 
3c52			 
3c52					; destroy value TOS 
3c52			 
3c52					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c52 cd ec 22			call macro_forth_dsp_pop 
3c55				endm 
# End of macro FORTH_DSP_POP
3c55			 
3c55					; get u1 
3c55			 
3c55					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c55 cd 34 22			call macro_dsp_valuehl 
3c58				endm 
# End of macro FORTH_DSP_VALUEHL
3c58			 
3c58 e5					push hl  ; u1 
3c59			 
3c59					; destroy value TOS 
3c59			 
3c59					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c59 cd ec 22			call macro_forth_dsp_pop 
3c5c				endm 
# End of macro FORTH_DSP_POP
3c5c			 
3c5c b7			 or a      ;clear carry flag 
3c5d e1			  pop hl    ; u1 
3c5e d1			  pop de    ; u2 
3c5f e5				push hl   ; saved in case hl is lowest 
3c60 ed 52		  sbc hl,de 
3c62 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3c64			 
3c64 e1				pop hl 
3c65					if DEBUG_FORTH_WORDS 
3c65						DMARK "MIN" 
3c65 f5				push af  
3c66 3a 7a 3c			ld a, (.dmark)  
3c69 32 a6 fd			ld (debug_mark),a  
3c6c 3a 7b 3c			ld a, (.dmark+1)  
3c6f 32 a7 fd			ld (debug_mark+1),a  
3c72 3a 7c 3c			ld a, (.dmark+2)  
3c75 32 a8 fd			ld (debug_mark+2),a  
3c78 18 03			jr .pastdmark  
3c7a ..			.dmark: db "MIN"  
3c7d f1			.pastdmark: pop af  
3c7e			endm  
# End of macro DMARK
3c7e						CALLMONITOR 
3c7e cd aa fd			call debug_vector  
3c81				endm  
# End of macro CALLMONITOR
3c81					endif 
3c81 cd 2f 20				call forth_push_numhl 
3c84			 
3c84				       NEXTW 
3c84 c3 ea 23			jp macro_next 
3c87				endm 
# End of macro NEXTW
3c87			 
3c87			.mincont:  
3c87 c1				pop bc   ; tidy up 
3c88 eb				ex de , hl  
3c89					if DEBUG_FORTH_WORDS 
3c89						DMARK "MI1" 
3c89 f5				push af  
3c8a 3a 9e 3c			ld a, (.dmark)  
3c8d 32 a6 fd			ld (debug_mark),a  
3c90 3a 9f 3c			ld a, (.dmark+1)  
3c93 32 a7 fd			ld (debug_mark+1),a  
3c96 3a a0 3c			ld a, (.dmark+2)  
3c99 32 a8 fd			ld (debug_mark+2),a  
3c9c 18 03			jr .pastdmark  
3c9e ..			.dmark: db "MI1"  
3ca1 f1			.pastdmark: pop af  
3ca2			endm  
# End of macro DMARK
3ca2						CALLMONITOR 
3ca2 cd aa fd			call debug_vector  
3ca5				endm  
# End of macro CALLMONITOR
3ca5					endif 
3ca5 cd 2f 20				call forth_push_numhl 
3ca8			 
3ca8				       NEXTW 
3ca8 c3 ea 23			jp macro_next 
3cab				endm 
# End of macro NEXTW
3cab			.MAX: 
3cab				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3cab 4a				db WORD_SYS_CORE+54             
3cac 2c 3d			dw .RND16            
3cae 04				db 3 + 1 
3caf .. 00			db "MAX",0              
3cb3				endm 
# End of macro CWHEAD
3cb3			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3cb3					if DEBUG_FORTH_WORDS_KEY 
3cb3						DMARK "MAX" 
3cb3 f5				push af  
3cb4 3a c8 3c			ld a, (.dmark)  
3cb7 32 a6 fd			ld (debug_mark),a  
3cba 3a c9 3c			ld a, (.dmark+1)  
3cbd 32 a7 fd			ld (debug_mark+1),a  
3cc0 3a ca 3c			ld a, (.dmark+2)  
3cc3 32 a8 fd			ld (debug_mark+2),a  
3cc6 18 03			jr .pastdmark  
3cc8 ..			.dmark: db "MAX"  
3ccb f1			.pastdmark: pop af  
3ccc			endm  
# End of macro DMARK
3ccc						CALLMONITOR 
3ccc cd aa fd			call debug_vector  
3ccf				endm  
# End of macro CALLMONITOR
3ccf					endif 
3ccf					; get u2 
3ccf			 
3ccf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ccf cd 34 22			call macro_dsp_valuehl 
3cd2				endm 
# End of macro FORTH_DSP_VALUEHL
3cd2			 
3cd2 e5					push hl   ; u2 
3cd3			 
3cd3					; destroy value TOS 
3cd3			 
3cd3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cd3 cd ec 22			call macro_forth_dsp_pop 
3cd6				endm 
# End of macro FORTH_DSP_POP
3cd6			 
3cd6					; get u1 
3cd6			 
3cd6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cd6 cd 34 22			call macro_dsp_valuehl 
3cd9				endm 
# End of macro FORTH_DSP_VALUEHL
3cd9			 
3cd9 e5					push hl  ; u1 
3cda			 
3cda					; destroy value TOS 
3cda			 
3cda					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cda cd ec 22			call macro_forth_dsp_pop 
3cdd				endm 
# End of macro FORTH_DSP_POP
3cdd			 
3cdd b7			 or a      ;clear carry flag 
3cde e1			  pop hl    ; u1 
3cdf d1			  pop de    ; u2 
3ce0 e5				push hl   ; saved in case hl is lowest 
3ce1 ed 52		  sbc hl,de 
3ce3 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3ce5			 
3ce5 e1				pop hl 
3ce6					if DEBUG_FORTH_WORDS 
3ce6						DMARK "MAX" 
3ce6 f5				push af  
3ce7 3a fb 3c			ld a, (.dmark)  
3cea 32 a6 fd			ld (debug_mark),a  
3ced 3a fc 3c			ld a, (.dmark+1)  
3cf0 32 a7 fd			ld (debug_mark+1),a  
3cf3 3a fd 3c			ld a, (.dmark+2)  
3cf6 32 a8 fd			ld (debug_mark+2),a  
3cf9 18 03			jr .pastdmark  
3cfb ..			.dmark: db "MAX"  
3cfe f1			.pastdmark: pop af  
3cff			endm  
# End of macro DMARK
3cff						CALLMONITOR 
3cff cd aa fd			call debug_vector  
3d02				endm  
# End of macro CALLMONITOR
3d02					endif 
3d02 cd 2f 20				call forth_push_numhl 
3d05			 
3d05				       NEXTW 
3d05 c3 ea 23			jp macro_next 
3d08				endm 
# End of macro NEXTW
3d08			 
3d08			.maxcont:  
3d08 c1				pop bc   ; tidy up 
3d09 eb				ex de , hl  
3d0a					if DEBUG_FORTH_WORDS 
3d0a						DMARK "MA1" 
3d0a f5				push af  
3d0b 3a 1f 3d			ld a, (.dmark)  
3d0e 32 a6 fd			ld (debug_mark),a  
3d11 3a 20 3d			ld a, (.dmark+1)  
3d14 32 a7 fd			ld (debug_mark+1),a  
3d17 3a 21 3d			ld a, (.dmark+2)  
3d1a 32 a8 fd			ld (debug_mark+2),a  
3d1d 18 03			jr .pastdmark  
3d1f ..			.dmark: db "MA1"  
3d22 f1			.pastdmark: pop af  
3d23			endm  
# End of macro DMARK
3d23						CALLMONITOR 
3d23 cd aa fd			call debug_vector  
3d26				endm  
# End of macro CALLMONITOR
3d26					endif 
3d26 cd 2f 20				call forth_push_numhl 
3d29				       NEXTW 
3d29 c3 ea 23			jp macro_next 
3d2c				endm 
# End of macro NEXTW
3d2c			 
3d2c			.RND16: 
3d2c				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3d2c 4e				db WORD_SYS_CORE+58             
3d2d 5b 3d			dw .RND8            
3d2f 06				db 5 + 1 
3d30 .. 00			db "RND16",0              
3d36				endm 
# End of macro CWHEAD
3d36			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3d36					if DEBUG_FORTH_WORDS_KEY 
3d36						DMARK "R16" 
3d36 f5				push af  
3d37 3a 4b 3d			ld a, (.dmark)  
3d3a 32 a6 fd			ld (debug_mark),a  
3d3d 3a 4c 3d			ld a, (.dmark+1)  
3d40 32 a7 fd			ld (debug_mark+1),a  
3d43 3a 4d 3d			ld a, (.dmark+2)  
3d46 32 a8 fd			ld (debug_mark+2),a  
3d49 18 03			jr .pastdmark  
3d4b ..			.dmark: db "R16"  
3d4e f1			.pastdmark: pop af  
3d4f			endm  
# End of macro DMARK
3d4f						CALLMONITOR 
3d4f cd aa fd			call debug_vector  
3d52				endm  
# End of macro CALLMONITOR
3d52					endif 
3d52 cd 02 0f				call prng16  
3d55 cd 2f 20				call forth_push_numhl 
3d58				       NEXTW 
3d58 c3 ea 23			jp macro_next 
3d5b				endm 
# End of macro NEXTW
3d5b			.RND8: 
3d5b				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3d5b 60				db WORD_SYS_CORE+76             
3d5c 90 3d			dw .RND            
3d5e 05				db 4 + 1 
3d5f .. 00			db "RND8",0              
3d64				endm 
# End of macro CWHEAD
3d64			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3d64					if DEBUG_FORTH_WORDS_KEY 
3d64						DMARK "RN8" 
3d64 f5				push af  
3d65 3a 79 3d			ld a, (.dmark)  
3d68 32 a6 fd			ld (debug_mark),a  
3d6b 3a 7a 3d			ld a, (.dmark+1)  
3d6e 32 a7 fd			ld (debug_mark+1),a  
3d71 3a 7b 3d			ld a, (.dmark+2)  
3d74 32 a8 fd			ld (debug_mark+2),a  
3d77 18 03			jr .pastdmark  
3d79 ..			.dmark: db "RN8"  
3d7c f1			.pastdmark: pop af  
3d7d			endm  
# End of macro DMARK
3d7d						CALLMONITOR 
3d7d cd aa fd			call debug_vector  
3d80				endm  
# End of macro CALLMONITOR
3d80					endif 
3d80 2a e4 fa				ld hl,(xrandc) 
3d83 23					inc hl 
3d84 cd 1c 0f				call xrnd 
3d87 6f					ld l,a	 
3d88 26 00				ld h,0 
3d8a cd 2f 20				call forth_push_numhl 
3d8d				       NEXTW 
3d8d c3 ea 23			jp macro_next 
3d90				endm 
# End of macro NEXTW
3d90			.RND: 
3d90				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3d90 60				db WORD_SYS_CORE+76             
3d91 96 3e			dw .ENDMATHS            
3d93 04				db 3 + 1 
3d94 .. 00			db "RND",0              
3d98				endm 
# End of macro CWHEAD
3d98			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3d98			 
3d98					if DEBUG_FORTH_WORDS_KEY 
3d98						DMARK "RND" 
3d98 f5				push af  
3d99 3a ad 3d			ld a, (.dmark)  
3d9c 32 a6 fd			ld (debug_mark),a  
3d9f 3a ae 3d			ld a, (.dmark+1)  
3da2 32 a7 fd			ld (debug_mark+1),a  
3da5 3a af 3d			ld a, (.dmark+2)  
3da8 32 a8 fd			ld (debug_mark+2),a  
3dab 18 03			jr .pastdmark  
3dad ..			.dmark: db "RND"  
3db0 f1			.pastdmark: pop af  
3db1			endm  
# End of macro DMARK
3db1						CALLMONITOR 
3db1 cd aa fd			call debug_vector  
3db4				endm  
# End of macro CALLMONITOR
3db4					endif 
3db4					 
3db4					FORTH_DSP_VALUEHL    ; upper range 
3db4 cd 34 22			call macro_dsp_valuehl 
3db7				endm 
# End of macro FORTH_DSP_VALUEHL
3db7			 
3db7 22 e8 fa				ld (LFSRSeed), hl	 
3dba			 
3dba					if DEBUG_FORTH_WORDS 
3dba						DMARK "RN1" 
3dba f5				push af  
3dbb 3a cf 3d			ld a, (.dmark)  
3dbe 32 a6 fd			ld (debug_mark),a  
3dc1 3a d0 3d			ld a, (.dmark+1)  
3dc4 32 a7 fd			ld (debug_mark+1),a  
3dc7 3a d1 3d			ld a, (.dmark+2)  
3dca 32 a8 fd			ld (debug_mark+2),a  
3dcd 18 03			jr .pastdmark  
3dcf ..			.dmark: db "RN1"  
3dd2 f1			.pastdmark: pop af  
3dd3			endm  
# End of macro DMARK
3dd3						CALLMONITOR 
3dd3 cd aa fd			call debug_vector  
3dd6				endm  
# End of macro CALLMONITOR
3dd6					endif 
3dd6					FORTH_DSP_POP 
3dd6 cd ec 22			call macro_forth_dsp_pop 
3dd9				endm 
# End of macro FORTH_DSP_POP
3dd9			 
3dd9					FORTH_DSP_VALUEHL    ; low range 
3dd9 cd 34 22			call macro_dsp_valuehl 
3ddc				endm 
# End of macro FORTH_DSP_VALUEHL
3ddc			 
3ddc					if DEBUG_FORTH_WORDS 
3ddc						DMARK "RN2" 
3ddc f5				push af  
3ddd 3a f1 3d			ld a, (.dmark)  
3de0 32 a6 fd			ld (debug_mark),a  
3de3 3a f2 3d			ld a, (.dmark+1)  
3de6 32 a7 fd			ld (debug_mark+1),a  
3de9 3a f3 3d			ld a, (.dmark+2)  
3dec 32 a8 fd			ld (debug_mark+2),a  
3def 18 03			jr .pastdmark  
3df1 ..			.dmark: db "RN2"  
3df4 f1			.pastdmark: pop af  
3df5			endm  
# End of macro DMARK
3df5						CALLMONITOR 
3df5 cd aa fd			call debug_vector  
3df8				endm  
# End of macro CALLMONITOR
3df8					endif 
3df8 22 ea fa				ld (LFSRSeed+2), hl 
3dfb			 
3dfb					FORTH_DSP_POP 
3dfb cd ec 22			call macro_forth_dsp_pop 
3dfe				endm 
# End of macro FORTH_DSP_POP
3dfe			 
3dfe e5					push hl 
3dff			 
3dff e1			.inrange:	pop hl 
3e00 cd 02 0f				call prng16  
3e03					if DEBUG_FORTH_WORDS 
3e03						DMARK "RN3" 
3e03 f5				push af  
3e04 3a 18 3e			ld a, (.dmark)  
3e07 32 a6 fd			ld (debug_mark),a  
3e0a 3a 19 3e			ld a, (.dmark+1)  
3e0d 32 a7 fd			ld (debug_mark+1),a  
3e10 3a 1a 3e			ld a, (.dmark+2)  
3e13 32 a8 fd			ld (debug_mark+2),a  
3e16 18 03			jr .pastdmark  
3e18 ..			.dmark: db "RN3"  
3e1b f1			.pastdmark: pop af  
3e1c			endm  
# End of macro DMARK
3e1c						CALLMONITOR 
3e1c cd aa fd			call debug_vector  
3e1f				endm  
# End of macro CALLMONITOR
3e1f					endif 
3e1f					 
3e1f					; if the range is 8bit knock out the high byte 
3e1f			 
3e1f ed 5b e8 fa			ld de, (LFSRSeed)     ; check high level 
3e23			 
3e23 3e 00				ld a, 0 
3e25 ba					cp d  
3e26 20 1e				jr nz, .hirange 
3e28 26 00				ld h, 0   ; knock it down to 8bit 
3e2a			 
3e2a					if DEBUG_FORTH_WORDS 
3e2a						DMARK "RNk" 
3e2a f5				push af  
3e2b 3a 3f 3e			ld a, (.dmark)  
3e2e 32 a6 fd			ld (debug_mark),a  
3e31 3a 40 3e			ld a, (.dmark+1)  
3e34 32 a7 fd			ld (debug_mark+1),a  
3e37 3a 41 3e			ld a, (.dmark+2)  
3e3a 32 a8 fd			ld (debug_mark+2),a  
3e3d 18 03			jr .pastdmark  
3e3f ..			.dmark: db "RNk"  
3e42 f1			.pastdmark: pop af  
3e43			endm  
# End of macro DMARK
3e43						CALLMONITOR 
3e43 cd aa fd			call debug_vector  
3e46				endm  
# End of macro CALLMONITOR
3e46					endif 
3e46			.hirange:   
3e46 e5					push hl  
3e47 b7					or a  
3e48 ed 52		                sbc hl, de 
3e4a			 
3e4a					;call cmp16 
3e4a			 
3e4a 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3e4c e1					pop hl 
3e4d e5					push hl 
3e4e			 
3e4e					if DEBUG_FORTH_WORDS 
3e4e						DMARK "RN4" 
3e4e f5				push af  
3e4f 3a 63 3e			ld a, (.dmark)  
3e52 32 a6 fd			ld (debug_mark),a  
3e55 3a 64 3e			ld a, (.dmark+1)  
3e58 32 a7 fd			ld (debug_mark+1),a  
3e5b 3a 65 3e			ld a, (.dmark+2)  
3e5e 32 a8 fd			ld (debug_mark+2),a  
3e61 18 03			jr .pastdmark  
3e63 ..			.dmark: db "RN4"  
3e66 f1			.pastdmark: pop af  
3e67			endm  
# End of macro DMARK
3e67						CALLMONITOR 
3e67 cd aa fd			call debug_vector  
3e6a				endm  
# End of macro CALLMONITOR
3e6a					endif 
3e6a ed 5b ea fa			ld de, (LFSRSeed+2)   ; check low range 
3e6e					;call cmp16 
3e6e				 
3e6e b7					or a  
3e6f ed 52		                sbc hl, de 
3e71 38 8c				jr c, .inrange 
3e73			 
3e73 e1					pop hl 
3e74					 
3e74					if DEBUG_FORTH_WORDS 
3e74						DMARK "RNd" 
3e74 f5				push af  
3e75 3a 89 3e			ld a, (.dmark)  
3e78 32 a6 fd			ld (debug_mark),a  
3e7b 3a 8a 3e			ld a, (.dmark+1)  
3e7e 32 a7 fd			ld (debug_mark+1),a  
3e81 3a 8b 3e			ld a, (.dmark+2)  
3e84 32 a8 fd			ld (debug_mark+2),a  
3e87 18 03			jr .pastdmark  
3e89 ..			.dmark: db "RNd"  
3e8c f1			.pastdmark: pop af  
3e8d			endm  
# End of macro DMARK
3e8d						CALLMONITOR 
3e8d cd aa fd			call debug_vector  
3e90				endm  
# End of macro CALLMONITOR
3e90					endif 
3e90			 
3e90			 
3e90 cd 2f 20				call forth_push_numhl 
3e93				       NEXTW 
3e93 c3 ea 23			jp macro_next 
3e96				endm 
# End of macro NEXTW
3e96			 
3e96			.ENDMATHS: 
3e96			 
3e96			; eof 
3e96			 
# End of file forth_words_maths.asm
3e96			include "forth_words_display.asm" 
3e96			 
3e96			; | ## Display Words 
3e96			 
3e96			.ACT: 
3e96			 
3e96				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3e96 62				db WORD_SYS_CORE+78             
3e97 e2 3e			dw .INFO            
3e99 07				db 6 + 1 
3e9a .. 00			db "ACTIVE",0              
3ea1				endm 
# End of macro CWHEAD
3ea1			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3ea1			;  
3ea1			; | | To display a pulsing activity indicator in a processing loop do this... 
3ea1			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3ea1			 
3ea1					if DEBUG_FORTH_WORDS_KEY 
3ea1						DMARK "ACT" 
3ea1 f5				push af  
3ea2 3a b6 3e			ld a, (.dmark)  
3ea5 32 a6 fd			ld (debug_mark),a  
3ea8 3a b7 3e			ld a, (.dmark+1)  
3eab 32 a7 fd			ld (debug_mark+1),a  
3eae 3a b8 3e			ld a, (.dmark+2)  
3eb1 32 a8 fd			ld (debug_mark+2),a  
3eb4 18 03			jr .pastdmark  
3eb6 ..			.dmark: db "ACT"  
3eb9 f1			.pastdmark: pop af  
3eba			endm  
# End of macro DMARK
3eba						CALLMONITOR 
3eba cd aa fd			call debug_vector  
3ebd				endm  
# End of macro CALLMONITOR
3ebd					endif 
3ebd cd fe 0c				call active 
3ec0					if DEBUG_FORTH_WORDS 
3ec0						DMARK "ACp" 
3ec0 f5				push af  
3ec1 3a d5 3e			ld a, (.dmark)  
3ec4 32 a6 fd			ld (debug_mark),a  
3ec7 3a d6 3e			ld a, (.dmark+1)  
3eca 32 a7 fd			ld (debug_mark+1),a  
3ecd 3a d7 3e			ld a, (.dmark+2)  
3ed0 32 a8 fd			ld (debug_mark+2),a  
3ed3 18 03			jr .pastdmark  
3ed5 ..			.dmark: db "ACp"  
3ed8 f1			.pastdmark: pop af  
3ed9			endm  
# End of macro DMARK
3ed9						CALLMONITOR 
3ed9 cd aa fd			call debug_vector  
3edc				endm  
# End of macro CALLMONITOR
3edc					endif 
3edc cd 9d 20				call forth_push_str 
3edf			 
3edf					NEXTW 
3edf c3 ea 23			jp macro_next 
3ee2				endm 
# End of macro NEXTW
3ee2			.INFO: 
3ee2			 
3ee2				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3ee2 62				db WORD_SYS_CORE+78             
3ee3 ff 3e			dw .ATP            
3ee5 05				db 4 + 1 
3ee6 .. 00			db "INFO",0              
3eeb				endm 
# End of macro CWHEAD
3eeb			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3eeb					FORTH_DSP_VALUEHL 
3eeb cd 34 22			call macro_dsp_valuehl 
3eee				endm 
# End of macro FORTH_DSP_VALUEHL
3eee			 
3eee					FORTH_DSP_POP 
3eee cd ec 22			call macro_forth_dsp_pop 
3ef1				endm 
# End of macro FORTH_DSP_POP
3ef1			 
3ef1 e5					push hl 
3ef2			 
3ef2					FORTH_DSP_VALUEHL 
3ef2 cd 34 22			call macro_dsp_valuehl 
3ef5				endm 
# End of macro FORTH_DSP_VALUEHL
3ef5			 
3ef5					FORTH_DSP_POP 
3ef5 cd ec 22			call macro_forth_dsp_pop 
3ef8				endm 
# End of macro FORTH_DSP_POP
3ef8			 
3ef8 d1					pop de 
3ef9			 
3ef9 cd 38 0d				call info_panel 
3efc			 
3efc			 
3efc					NEXTW 
3efc c3 ea 23			jp macro_next 
3eff				endm 
# End of macro NEXTW
3eff			.ATP: 
3eff				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3eff 62				db WORD_SYS_CORE+78             
3f00 76 3f			dw .FB            
3f02 04				db 3 + 1 
3f03 .. 00			db "AT?",0              
3f07				endm 
# End of macro CWHEAD
3f07			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3f07					if DEBUG_FORTH_WORDS_KEY 
3f07						DMARK "AT?" 
3f07 f5				push af  
3f08 3a 1c 3f			ld a, (.dmark)  
3f0b 32 a6 fd			ld (debug_mark),a  
3f0e 3a 1d 3f			ld a, (.dmark+1)  
3f11 32 a7 fd			ld (debug_mark+1),a  
3f14 3a 1e 3f			ld a, (.dmark+2)  
3f17 32 a8 fd			ld (debug_mark+2),a  
3f1a 18 03			jr .pastdmark  
3f1c ..			.dmark: db "AT?"  
3f1f f1			.pastdmark: pop af  
3f20			endm  
# End of macro DMARK
3f20						CALLMONITOR 
3f20 cd aa fd			call debug_vector  
3f23				endm  
# End of macro CALLMONITOR
3f23					endif 
3f23 3a 99 f9				ld a, (f_cursor_ptr) 
3f26			 
3f26			if DEBUG_FORTH_WORDS 
3f26				DMARK "AT?" 
3f26 f5				push af  
3f27 3a 3b 3f			ld a, (.dmark)  
3f2a 32 a6 fd			ld (debug_mark),a  
3f2d 3a 3c 3f			ld a, (.dmark+1)  
3f30 32 a7 fd			ld (debug_mark+1),a  
3f33 3a 3d 3f			ld a, (.dmark+2)  
3f36 32 a8 fd			ld (debug_mark+2),a  
3f39 18 03			jr .pastdmark  
3f3b ..			.dmark: db "AT?"  
3f3e f1			.pastdmark: pop af  
3f3f			endm  
# End of macro DMARK
3f3f				CALLMONITOR 
3f3f cd aa fd			call debug_vector  
3f42				endm  
# End of macro CALLMONITOR
3f42			endif	 
3f42					; count the number of rows 
3f42			 
3f42 06 00				ld b, 0 
3f44 4f			.atpr:		ld c, a    ; save in case we go below zero 
3f45 d6 28				sub display_cols 
3f47 f2 4d 3f				jp p, .atprunder 
3f4a 04					inc b 
3f4b 18 f7				jr .atpr 
3f4d			.atprunder:	 
3f4d			if DEBUG_FORTH_WORDS 
3f4d				DMARK "A?2" 
3f4d f5				push af  
3f4e 3a 62 3f			ld a, (.dmark)  
3f51 32 a6 fd			ld (debug_mark),a  
3f54 3a 63 3f			ld a, (.dmark+1)  
3f57 32 a7 fd			ld (debug_mark+1),a  
3f5a 3a 64 3f			ld a, (.dmark+2)  
3f5d 32 a8 fd			ld (debug_mark+2),a  
3f60 18 03			jr .pastdmark  
3f62 ..			.dmark: db "A?2"  
3f65 f1			.pastdmark: pop af  
3f66			endm  
# End of macro DMARK
3f66				CALLMONITOR 
3f66 cd aa fd			call debug_vector  
3f69				endm  
# End of macro CALLMONITOR
3f69			endif	 
3f69 26 00				ld h, 0 
3f6b 69					ld l, c 
3f6c cd 2f 20				call forth_push_numhl 
3f6f 68					ld l, b  
3f70 cd 2f 20				call forth_push_numhl 
3f73			 
3f73			 
3f73				NEXTW 
3f73 c3 ea 23			jp macro_next 
3f76				endm 
# End of macro NEXTW
3f76			 
3f76			.FB: 
3f76				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3f76 1b				db WORD_SYS_CORE+7             
3f77 c4 3f			dw .EMIT            
3f79 03				db 2 + 1 
3f7a .. 00			db "FB",0              
3f7d				endm 
# End of macro CWHEAD
3f7d			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3f7d			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3f7d			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3f7d			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3f7d					if DEBUG_FORTH_WORDS_KEY 
3f7d						DMARK "FB." 
3f7d f5				push af  
3f7e 3a 92 3f			ld a, (.dmark)  
3f81 32 a6 fd			ld (debug_mark),a  
3f84 3a 93 3f			ld a, (.dmark+1)  
3f87 32 a7 fd			ld (debug_mark+1),a  
3f8a 3a 94 3f			ld a, (.dmark+2)  
3f8d 32 a8 fd			ld (debug_mark+2),a  
3f90 18 03			jr .pastdmark  
3f92 ..			.dmark: db "FB."  
3f95 f1			.pastdmark: pop af  
3f96			endm  
# End of macro DMARK
3f96						CALLMONITOR 
3f96 cd aa fd			call debug_vector  
3f99				endm  
# End of macro CALLMONITOR
3f99					endif 
3f99			 
3f99					FORTH_DSP_VALUEHL 
3f99 cd 34 22			call macro_dsp_valuehl 
3f9c				endm 
# End of macro FORTH_DSP_VALUEHL
3f9c			 
3f9c 7d					ld a, l 
3f9d fe 01				cp 1 
3f9f 20 05				jr nz, .fbn1 
3fa1 21 4b fc				ld hl, display_fb1 
3fa4 18 15				jr .fbset 
3fa6 fe 02		.fbn1:		cp 2 
3fa8 20 05				jr nz, .fbn2 
3faa 21 09 fb				ld hl, display_fb2 
3fad 18 0c				jr .fbset 
3faf fe 03		.fbn2:		cp 3 
3fb1 20 05				jr nz, .fbn3 
3fb3 21 aa fb				ld hl, display_fb3 
3fb6 18 03				jr .fbset 
3fb8			.fbn3:		 ; if invalid number select first 
3fb8 21 4b fc				ld hl, display_fb1 
3fbb 22 07 fb		.fbset:		ld (display_fb_active), hl 
3fbe			 
3fbe					FORTH_DSP_POP 
3fbe cd ec 22			call macro_forth_dsp_pop 
3fc1				endm 
# End of macro FORTH_DSP_POP
3fc1			 
3fc1					NEXTW 
3fc1 c3 ea 23			jp macro_next 
3fc4				endm 
# End of macro NEXTW
3fc4			 
3fc4			 
3fc4			.EMIT: 
3fc4				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3fc4 1b				db WORD_SYS_CORE+7             
3fc5 15 40			dw .DOTH            
3fc7 05				db 4 + 1 
3fc8 .. 00			db "EMIT",0              
3fcd				endm 
# End of macro CWHEAD
3fcd			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3fcd					; get value off TOS and display it 
3fcd			 
3fcd					if DEBUG_FORTH_WORDS_KEY 
3fcd						DMARK "EMT" 
3fcd f5				push af  
3fce 3a e2 3f			ld a, (.dmark)  
3fd1 32 a6 fd			ld (debug_mark),a  
3fd4 3a e3 3f			ld a, (.dmark+1)  
3fd7 32 a7 fd			ld (debug_mark+1),a  
3fda 3a e4 3f			ld a, (.dmark+2)  
3fdd 32 a8 fd			ld (debug_mark+2),a  
3fe0 18 03			jr .pastdmark  
3fe2 ..			.dmark: db "EMT"  
3fe5 f1			.pastdmark: pop af  
3fe6			endm  
# End of macro DMARK
3fe6						CALLMONITOR 
3fe6 cd aa fd			call debug_vector  
3fe9				endm  
# End of macro CALLMONITOR
3fe9					endif 
3fe9			 
3fe9					FORTH_DSP_VALUEHL 
3fe9 cd 34 22			call macro_dsp_valuehl 
3fec				endm 
# End of macro FORTH_DSP_VALUEHL
3fec			 
3fec 7d					ld a,l 
3fed			 
3fed					; TODO write to display 
3fed			 
3fed 32 fa f2				ld (os_input), a 
3ff0 3e 00				ld a, 0 
3ff2 32 fb f2				ld (os_input+1), a 
3ff5					 
3ff5 3a 99 f9				ld a, (f_cursor_ptr) 
3ff8 11 fa f2				ld de, os_input 
3ffb cd ba 0d				call str_at_display 
3ffe			 
3ffe			 
3ffe 3a 77 f9				ld a,(cli_autodisplay) 
4001 fe 00				cp 0 
4003 28 03				jr z, .enoupdate 
4005 cd ca 0d						call update_display 
4008					.enoupdate: 
4008			 
4008 3a 99 f9				ld a, (f_cursor_ptr) 
400b 3c					inc a 
400c 32 99 f9				ld (f_cursor_ptr), a   ; save new pos 
400f			 
400f			 
400f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
400f cd ec 22			call macro_forth_dsp_pop 
4012				endm 
# End of macro FORTH_DSP_POP
4012			  
4012			 
4012					NEXTW 
4012 c3 ea 23			jp macro_next 
4015				endm 
# End of macro NEXTW
4015			.DOTH: 
4015				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
4015 1c				db WORD_SYS_CORE+8             
4016 45 40			dw .DOTF            
4018 03				db 2 + 1 
4019 .. 00			db ".-",0              
401c				endm 
# End of macro CWHEAD
401c			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
401c					; get value off TOS and display it 
401c					if DEBUG_FORTH_WORDS_KEY 
401c						DMARK "DTD" 
401c f5				push af  
401d 3a 31 40			ld a, (.dmark)  
4020 32 a6 fd			ld (debug_mark),a  
4023 3a 32 40			ld a, (.dmark+1)  
4026 32 a7 fd			ld (debug_mark+1),a  
4029 3a 33 40			ld a, (.dmark+2)  
402c 32 a8 fd			ld (debug_mark+2),a  
402f 18 03			jr .pastdmark  
4031 ..			.dmark: db "DTD"  
4034 f1			.pastdmark: pop af  
4035			endm  
# End of macro DMARK
4035						CALLMONITOR 
4035 cd aa fd			call debug_vector  
4038				endm  
# End of macro CALLMONITOR
4038					endif 
4038 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
403a 3e 00			ld a, 0 
403c 32 78 f9			ld (cli_mvdot), a 
403f c3 9c 40			jp .dotgo 
4042				NEXTW 
4042 c3 ea 23			jp macro_next 
4045				endm 
# End of macro NEXTW
4045			.DOTF: 
4045				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
4045 1c				db WORD_SYS_CORE+8             
4046 73 40			dw .DOT            
4048 03				db 2 + 1 
4049 .. 00			db ".>",0              
404c				endm 
# End of macro CWHEAD
404c			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
404c					; get value off TOS and display it 
404c			        ; TODO BUG adds extra spaces 
404c			        ; TODO BUG handle numerics? 
404c					if DEBUG_FORTH_WORDS_KEY 
404c						DMARK "DTC" 
404c f5				push af  
404d 3a 61 40			ld a, (.dmark)  
4050 32 a6 fd			ld (debug_mark),a  
4053 3a 62 40			ld a, (.dmark+1)  
4056 32 a7 fd			ld (debug_mark+1),a  
4059 3a 63 40			ld a, (.dmark+2)  
405c 32 a8 fd			ld (debug_mark+2),a  
405f 18 03			jr .pastdmark  
4061 ..			.dmark: db "DTC"  
4064 f1			.pastdmark: pop af  
4065			endm  
# End of macro DMARK
4065						CALLMONITOR 
4065 cd aa fd			call debug_vector  
4068				endm  
# End of macro CALLMONITOR
4068					endif 
4068 3e 01			ld a, 1 
406a 32 78 f9			ld (cli_mvdot), a 
406d c3 9c 40			jp .dotgo 
4070				NEXTW 
4070 c3 ea 23			jp macro_next 
4073				endm 
# End of macro NEXTW
4073			 
4073			.DOT: 
4073				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
4073 1c				db WORD_SYS_CORE+8             
4074 4f 42			dw .CLS            
4076 02				db 1 + 1 
4077 .. 00			db ".",0              
4079				endm 
# End of macro CWHEAD
4079			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
4079					; get value off TOS and display it 
4079			 
4079					if DEBUG_FORTH_WORDS_KEY 
4079						DMARK "DOT" 
4079 f5				push af  
407a 3a 8e 40			ld a, (.dmark)  
407d 32 a6 fd			ld (debug_mark),a  
4080 3a 8f 40			ld a, (.dmark+1)  
4083 32 a7 fd			ld (debug_mark+1),a  
4086 3a 90 40			ld a, (.dmark+2)  
4089 32 a8 fd			ld (debug_mark+2),a  
408c 18 03			jr .pastdmark  
408e ..			.dmark: db "DOT"  
4091 f1			.pastdmark: pop af  
4092			endm  
# End of macro DMARK
4092						CALLMONITOR 
4092 cd aa fd			call debug_vector  
4095				endm  
# End of macro CALLMONITOR
4095					endif 
4095 3e 00			ld a, 0 
4097 32 78 f9			ld (cli_mvdot), a 
409a 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
409c				 
409c			 
409c			.dotgo: 
409c			 
409c			; move up type to on stack for parserv5 
409c					FORTH_DSP 
409c cd fa 21			call macro_forth_dsp 
409f				endm 
# End of macro FORTH_DSP
409f				;FORTH_DSP_VALUE  
409f			 
409f			if DEBUG_FORTH_DOT 
409f				DMARK "DOT" 
409f f5				push af  
40a0 3a b4 40			ld a, (.dmark)  
40a3 32 a6 fd			ld (debug_mark),a  
40a6 3a b5 40			ld a, (.dmark+1)  
40a9 32 a7 fd			ld (debug_mark+1),a  
40ac 3a b6 40			ld a, (.dmark+2)  
40af 32 a8 fd			ld (debug_mark+2),a  
40b2 18 03			jr .pastdmark  
40b4 ..			.dmark: db "DOT"  
40b7 f1			.pastdmark: pop af  
40b8			endm  
# End of macro DMARK
40b8				CALLMONITOR 
40b8 cd aa fd			call debug_vector  
40bb				endm  
# End of macro CALLMONITOR
40bb			endif	 
40bb			;		.print: 
40bb			 
40bb 7e				ld a,(hl)  ; work out what type of value is on the TOS 
40bc 23				inc hl   ; position to the actual value 
40bd fe 01			cp DS_TYPE_STR 
40bf 20 06			jr nz, .dotnum1  
40c1			 
40c1			; display string 
40c1				FORTH_DSP_VALUE  
40c1 cd 1d 22			call macro_forth_dsp_value 
40c4				endm 
# End of macro FORTH_DSP_VALUE
40c4 eb				ex de,hl 
40c5 18 49			jr .dotwrite 
40c7			 
40c7			.dotnum1: 
40c7 fe 02			cp DS_TYPE_INUM 
40c9 20 44			jr nz, .dotflot 
40cb			 
40cb			 
40cb			; display number 
40cb			 
40cb			;	push hl 
40cb			;	call clear_display 
40cb			;	pop hl 
40cb			 
40cb 5e				ld e, (hl) 
40cc 23				inc hl 
40cd 56				ld d, (hl) 
40ce 21 fc f0			ld hl, scratch 
40d1			if DEBUG_FORTH_DOT 
40d1				DMARK "DT1" 
40d1 f5				push af  
40d2 3a e6 40			ld a, (.dmark)  
40d5 32 a6 fd			ld (debug_mark),a  
40d8 3a e7 40			ld a, (.dmark+1)  
40db 32 a7 fd			ld (debug_mark+1),a  
40de 3a e8 40			ld a, (.dmark+2)  
40e1 32 a8 fd			ld (debug_mark+2),a  
40e4 18 03			jr .pastdmark  
40e6 ..			.dmark: db "DT1"  
40e9 f1			.pastdmark: pop af  
40ea			endm  
# End of macro DMARK
40ea				CALLMONITOR 
40ea cd aa fd			call debug_vector  
40ed				endm  
# End of macro CALLMONITOR
40ed			endif	 
40ed			 
40ed cd f0 12			call uitoa_16 
40f0 eb				ex de,hl 
40f1			 
40f1			if DEBUG_FORTH_DOT 
40f1				DMARK "DT2" 
40f1 f5				push af  
40f2 3a 06 41			ld a, (.dmark)  
40f5 32 a6 fd			ld (debug_mark),a  
40f8 3a 07 41			ld a, (.dmark+1)  
40fb 32 a7 fd			ld (debug_mark+1),a  
40fe 3a 08 41			ld a, (.dmark+2)  
4101 32 a8 fd			ld (debug_mark+2),a  
4104 18 03			jr .pastdmark  
4106 ..			.dmark: db "DT2"  
4109 f1			.pastdmark: pop af  
410a			endm  
# End of macro DMARK
410a				CALLMONITOR 
410a cd aa fd			call debug_vector  
410d				endm  
# End of macro CALLMONITOR
410d			endif	 
410d			 
410d			;	ld de, os_word_scratch 
410d 18 01			jr .dotwrite 
410f			 
410f 00			.dotflot:   nop 
4110			; TODO print floating point number 
4110			 
4110			.dotwrite:		 
4110			 
4110					; if c is set then set all '-' to spaces 
4110					; need to also take into account .>  
4110			 
4110 3e 01				ld a, 1 
4112 b9					cp c 
4113 20 67				jr nz, .nodashswap 
4115			 
4115					; DE has the string to write, working with HL 
4115			 
4115 06 ff				ld b, 255 
4117 d5					push de 
4118 e1					pop hl 
4119			 
4119			if DEBUG_FORTH_DOT 
4119				DMARK "DT-" 
4119 f5				push af  
411a 3a 2e 41			ld a, (.dmark)  
411d 32 a6 fd			ld (debug_mark),a  
4120 3a 2f 41			ld a, (.dmark+1)  
4123 32 a7 fd			ld (debug_mark+1),a  
4126 3a 30 41			ld a, (.dmark+2)  
4129 32 a8 fd			ld (debug_mark+2),a  
412c 18 03			jr .pastdmark  
412e ..			.dmark: db "DT-"  
4131 f1			.pastdmark: pop af  
4132			endm  
# End of macro DMARK
4132				CALLMONITOR 
4132 cd aa fd			call debug_vector  
4135				endm  
# End of macro CALLMONITOR
4135			endif	 
4135 7e			.dashscan:	ld a, (hl) 
4136 fe 00				cp 0 
4138 28 42				jr z, .nodashswap 
413a fe 2d				cp '-' 
413c 20 03				jr nz, .dashskip 
413e 3e 20				ld a, ' ' 
4140 77					ld (hl), a 
4141 23			.dashskip:	inc hl 
4142			if DEBUG_FORTH_DOT 
4142				DMARK "D-2" 
4142 f5				push af  
4143 3a 57 41			ld a, (.dmark)  
4146 32 a6 fd			ld (debug_mark),a  
4149 3a 58 41			ld a, (.dmark+1)  
414c 32 a7 fd			ld (debug_mark+1),a  
414f 3a 59 41			ld a, (.dmark+2)  
4152 32 a8 fd			ld (debug_mark+2),a  
4155 18 03			jr .pastdmark  
4157 ..			.dmark: db "D-2"  
415a f1			.pastdmark: pop af  
415b			endm  
# End of macro DMARK
415b				CALLMONITOR 
415b cd aa fd			call debug_vector  
415e				endm  
# End of macro CALLMONITOR
415e			endif	 
415e 10 d5				djnz .dashscan 
4160			 
4160			if DEBUG_FORTH_DOT 
4160				DMARK "D-1" 
4160 f5				push af  
4161 3a 75 41			ld a, (.dmark)  
4164 32 a6 fd			ld (debug_mark),a  
4167 3a 76 41			ld a, (.dmark+1)  
416a 32 a7 fd			ld (debug_mark+1),a  
416d 3a 77 41			ld a, (.dmark+2)  
4170 32 a8 fd			ld (debug_mark+2),a  
4173 18 03			jr .pastdmark  
4175 ..			.dmark: db "D-1"  
4178 f1			.pastdmark: pop af  
4179			endm  
# End of macro DMARK
4179				CALLMONITOR 
4179 cd aa fd			call debug_vector  
417c				endm  
# End of macro CALLMONITOR
417c			endif	 
417c			 
417c			.nodashswap: 
417c			 
417c			if DEBUG_FORTH_DOT 
417c				DMARK "D-o" 
417c f5				push af  
417d 3a 91 41			ld a, (.dmark)  
4180 32 a6 fd			ld (debug_mark),a  
4183 3a 92 41			ld a, (.dmark+1)  
4186 32 a7 fd			ld (debug_mark+1),a  
4189 3a 93 41			ld a, (.dmark+2)  
418c 32 a8 fd			ld (debug_mark+2),a  
418f 18 03			jr .pastdmark  
4191 ..			.dmark: db "D-o"  
4194 f1			.pastdmark: pop af  
4195			endm  
# End of macro DMARK
4195				CALLMONITOR 
4195 cd aa fd			call debug_vector  
4198				endm  
# End of macro CALLMONITOR
4198			endif	 
4198			 
4198 d5					push de   ; save string start in case we need to advance print 
4199			 
4199 3a 99 f9				ld a, (f_cursor_ptr) 
419c cd ba 0d				call str_at_display 
419f 3a 77 f9				ld a,(cli_autodisplay) 
41a2 fe 00				cp 0 
41a4 28 03				jr z, .noupdate 
41a6 cd ca 0d						call update_display 
41a9					.noupdate: 
41a9			 
41a9			 
41a9					; see if we need to advance the print position 
41a9			 
41a9 e1					pop hl   ; get back string 
41aa			;		ex de,hl 
41aa			 
41aa 3a 78 f9				ld a, (cli_mvdot) 
41ad			if DEBUG_FORTH_DOT 
41ad			;		ld e,a 
41ad				DMARK "D>1" 
41ad f5				push af  
41ae 3a c2 41			ld a, (.dmark)  
41b1 32 a6 fd			ld (debug_mark),a  
41b4 3a c3 41			ld a, (.dmark+1)  
41b7 32 a7 fd			ld (debug_mark+1),a  
41ba 3a c4 41			ld a, (.dmark+2)  
41bd 32 a8 fd			ld (debug_mark+2),a  
41c0 18 03			jr .pastdmark  
41c2 ..			.dmark: db "D>1"  
41c5 f1			.pastdmark: pop af  
41c6			endm  
# End of macro DMARK
41c6				CALLMONITOR 
41c6 cd aa fd			call debug_vector  
41c9				endm  
# End of macro CALLMONITOR
41c9			endif	 
41c9 fe 00				cp 0 
41cb 28 44				jr z, .noadv 
41cd					; yes, lets advance the print position 
41cd 3e 00				ld a, 0 
41cf cd 4c 13				call strlent 
41d2			if DEBUG_FORTH_DOT 
41d2				DMARK "D-?" 
41d2 f5				push af  
41d3 3a e7 41			ld a, (.dmark)  
41d6 32 a6 fd			ld (debug_mark),a  
41d9 3a e8 41			ld a, (.dmark+1)  
41dc 32 a7 fd			ld (debug_mark+1),a  
41df 3a e9 41			ld a, (.dmark+2)  
41e2 32 a8 fd			ld (debug_mark+2),a  
41e5 18 03			jr .pastdmark  
41e7 ..			.dmark: db "D-?"  
41ea f1			.pastdmark: pop af  
41eb			endm  
# End of macro DMARK
41eb				CALLMONITOR 
41eb cd aa fd			call debug_vector  
41ee				endm  
# End of macro CALLMONITOR
41ee			endif	 
41ee 3a 99 f9				ld a, (f_cursor_ptr) 
41f1 85					add a,l 
41f2					;call addatohl 
41f2					;ld a, l 
41f2 32 99 f9				ld (f_cursor_ptr), a   ; save new pos 
41f5			 
41f5			if DEBUG_FORTH_DOT 
41f5				DMARK "D->" 
41f5 f5				push af  
41f6 3a 0a 42			ld a, (.dmark)  
41f9 32 a6 fd			ld (debug_mark),a  
41fc 3a 0b 42			ld a, (.dmark+1)  
41ff 32 a7 fd			ld (debug_mark+1),a  
4202 3a 0c 42			ld a, (.dmark+2)  
4205 32 a8 fd			ld (debug_mark+2),a  
4208 18 03			jr .pastdmark  
420a ..			.dmark: db "D->"  
420d f1			.pastdmark: pop af  
420e			endm  
# End of macro DMARK
420e				CALLMONITOR 
420e cd aa fd			call debug_vector  
4211				endm  
# End of macro CALLMONITOR
4211			endif	 
4211			 
4211			.noadv:	 
4211			 
4211					if DEBUG_FORTH_DOT_WAIT 
4211							call next_page_prompt 
4211					endif	 
4211			; TODO this pop off the stack causes a crash. i dont know why 
4211			 
4211			 
4211			if DEBUG_FORTH_DOT 
4211				DMARK "DTh" 
4211 f5				push af  
4212 3a 26 42			ld a, (.dmark)  
4215 32 a6 fd			ld (debug_mark),a  
4218 3a 27 42			ld a, (.dmark+1)  
421b 32 a7 fd			ld (debug_mark+1),a  
421e 3a 28 42			ld a, (.dmark+2)  
4221 32 a8 fd			ld (debug_mark+2),a  
4224 18 03			jr .pastdmark  
4226 ..			.dmark: db "DTh"  
4229 f1			.pastdmark: pop af  
422a			endm  
# End of macro DMARK
422a				CALLMONITOR 
422a cd aa fd			call debug_vector  
422d				endm  
# End of macro CALLMONITOR
422d			endif	 
422d			 
422d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
422d cd ec 22			call macro_forth_dsp_pop 
4230				endm 
# End of macro FORTH_DSP_POP
4230			 
4230			if DEBUG_FORTH_DOT 
4230				DMARK "DTi" 
4230 f5				push af  
4231 3a 45 42			ld a, (.dmark)  
4234 32 a6 fd			ld (debug_mark),a  
4237 3a 46 42			ld a, (.dmark+1)  
423a 32 a7 fd			ld (debug_mark+1),a  
423d 3a 47 42			ld a, (.dmark+2)  
4240 32 a8 fd			ld (debug_mark+2),a  
4243 18 03			jr .pastdmark  
4245 ..			.dmark: db "DTi"  
4248 f1			.pastdmark: pop af  
4249			endm  
# End of macro DMARK
4249				CALLMONITOR 
4249 cd aa fd			call debug_vector  
424c				endm  
# End of macro CALLMONITOR
424c			endif	 
424c			 
424c			 
424c					NEXTW 
424c c3 ea 23			jp macro_next 
424f				endm 
# End of macro NEXTW
424f			 
424f			.CLS: 
424f				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
424f 35				db WORD_SYS_CORE+33             
4250 7c 42			dw .DRAW            
4252 04				db 3 + 1 
4253 .. 00			db "CLS",0              
4257				endm 
# End of macro CWHEAD
4257			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4257					if DEBUG_FORTH_WORDS_KEY 
4257						DMARK "CLS" 
4257 f5				push af  
4258 3a 6c 42			ld a, (.dmark)  
425b 32 a6 fd			ld (debug_mark),a  
425e 3a 6d 42			ld a, (.dmark+1)  
4261 32 a7 fd			ld (debug_mark+1),a  
4264 3a 6e 42			ld a, (.dmark+2)  
4267 32 a8 fd			ld (debug_mark+2),a  
426a 18 03			jr .pastdmark  
426c ..			.dmark: db "CLS"  
426f f1			.pastdmark: pop af  
4270			endm  
# End of macro DMARK
4270						CALLMONITOR 
4270 cd aa fd			call debug_vector  
4273				endm  
# End of macro CALLMONITOR
4273					endif 
4273 cd a7 0d				call clear_display 
4276 c3 8a 43				jp .home		; and home cursor 
4279					NEXTW 
4279 c3 ea 23			jp macro_next 
427c				endm 
# End of macro NEXTW
427c			 
427c			.DRAW: 
427c				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
427c 36				db WORD_SYS_CORE+34             
427d a7 42			dw .DUMP            
427f 05				db 4 + 1 
4280 .. 00			db "DRAW",0              
4285				endm 
# End of macro CWHEAD
4285			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
4285					if DEBUG_FORTH_WORDS_KEY 
4285						DMARK "DRW" 
4285 f5				push af  
4286 3a 9a 42			ld a, (.dmark)  
4289 32 a6 fd			ld (debug_mark),a  
428c 3a 9b 42			ld a, (.dmark+1)  
428f 32 a7 fd			ld (debug_mark+1),a  
4292 3a 9c 42			ld a, (.dmark+2)  
4295 32 a8 fd			ld (debug_mark+2),a  
4298 18 03			jr .pastdmark  
429a ..			.dmark: db "DRW"  
429d f1			.pastdmark: pop af  
429e			endm  
# End of macro DMARK
429e						CALLMONITOR 
429e cd aa fd			call debug_vector  
42a1				endm  
# End of macro CALLMONITOR
42a1					endif 
42a1 cd ca 0d				call update_display 
42a4					NEXTW 
42a4 c3 ea 23			jp macro_next 
42a7				endm 
# End of macro NEXTW
42a7			 
42a7			.DUMP: 
42a7				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
42a7 37				db WORD_SYS_CORE+35             
42a8 df 42			dw .CDUMP            
42aa 05				db 4 + 1 
42ab .. 00			db "DUMP",0              
42b0				endm 
# End of macro CWHEAD
42b0			; | DUMP ( x -- ) With address x display dump   | DONE 
42b0			; TODO pop address to use off of the stack 
42b0					if DEBUG_FORTH_WORDS_KEY 
42b0						DMARK "DUM" 
42b0 f5				push af  
42b1 3a c5 42			ld a, (.dmark)  
42b4 32 a6 fd			ld (debug_mark),a  
42b7 3a c6 42			ld a, (.dmark+1)  
42ba 32 a7 fd			ld (debug_mark+1),a  
42bd 3a c7 42			ld a, (.dmark+2)  
42c0 32 a8 fd			ld (debug_mark+2),a  
42c3 18 03			jr .pastdmark  
42c5 ..			.dmark: db "DUM"  
42c8 f1			.pastdmark: pop af  
42c9			endm  
# End of macro DMARK
42c9						CALLMONITOR 
42c9 cd aa fd			call debug_vector  
42cc				endm  
# End of macro CALLMONITOR
42cc					endif 
42cc cd a7 0d				call clear_display 
42cf			 
42cf					; get address 
42cf			 
42cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42cf cd 34 22			call macro_dsp_valuehl 
42d2				endm 
# End of macro FORTH_DSP_VALUEHL
42d2				 
42d2					; save it for cdump 
42d2			 
42d2 22 1f f4				ld (os_cur_ptr),hl 
42d5			 
42d5					; destroy value TOS 
42d5			 
42d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42d5 cd ec 22			call macro_forth_dsp_pop 
42d8				endm 
# End of macro FORTH_DSP_POP
42d8			 
42d8 cd af 1e				call dumpcont	; skip old style of param parsing	 
42db c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
42dc					NEXTW 
42dc c3 ea 23			jp macro_next 
42df				endm 
# End of macro NEXTW
42df			.CDUMP: 
42df				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
42df 38				db WORD_SYS_CORE+36             
42e0 0f 43			dw .DAT            
42e2 06				db 5 + 1 
42e3 .. 00			db "CDUMP",0              
42e9				endm 
# End of macro CWHEAD
42e9			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
42e9					if DEBUG_FORTH_WORDS_KEY 
42e9						DMARK "CDP" 
42e9 f5				push af  
42ea 3a fe 42			ld a, (.dmark)  
42ed 32 a6 fd			ld (debug_mark),a  
42f0 3a ff 42			ld a, (.dmark+1)  
42f3 32 a7 fd			ld (debug_mark+1),a  
42f6 3a 00 43			ld a, (.dmark+2)  
42f9 32 a8 fd			ld (debug_mark+2),a  
42fc 18 03			jr .pastdmark  
42fe ..			.dmark: db "CDP"  
4301 f1			.pastdmark: pop af  
4302			endm  
# End of macro DMARK
4302						CALLMONITOR 
4302 cd aa fd			call debug_vector  
4305				endm  
# End of macro CALLMONITOR
4305					endif 
4305 cd a7 0d				call clear_display 
4308 cd af 1e				call dumpcont	 
430b c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
430c					NEXTW 
430c c3 ea 23			jp macro_next 
430f				endm 
# End of macro NEXTW
430f			 
430f			 
430f			 
430f			 
430f			.DAT: 
430f				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
430f 3d				db WORD_SYS_CORE+41             
4310 65 43			dw .HOME            
4312 03				db 2 + 1 
4313 .. 00			db "AT",0              
4316				endm 
# End of macro CWHEAD
4316			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
4316					if DEBUG_FORTH_WORDS_KEY 
4316						DMARK "AT." 
4316 f5				push af  
4317 3a 2b 43			ld a, (.dmark)  
431a 32 a6 fd			ld (debug_mark),a  
431d 3a 2c 43			ld a, (.dmark+1)  
4320 32 a7 fd			ld (debug_mark+1),a  
4323 3a 2d 43			ld a, (.dmark+2)  
4326 32 a8 fd			ld (debug_mark+2),a  
4329 18 03			jr .pastdmark  
432b ..			.dmark: db "AT."  
432e f1			.pastdmark: pop af  
432f			endm  
# End of macro DMARK
432f						CALLMONITOR 
432f cd aa fd			call debug_vector  
4332				endm  
# End of macro CALLMONITOR
4332					endif 
4332					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4332 cd 34 22			call macro_dsp_valuehl 
4335				endm 
# End of macro FORTH_DSP_VALUEHL
4335			 
4335			 
4335					; TODO save cursor row 
4335 7d					ld a,l 
4336 fe 02				cp 2 
4338 20 04				jr nz, .crow3 
433a 3e 28				ld a, display_row_2 
433c 18 12				jr .ccol1 
433e fe 03		.crow3:		cp 3 
4340 20 04				jr nz, .crow4 
4342 3e 50				ld a, display_row_3 
4344 18 0a				jr .ccol1 
4346 fe 04		.crow4:		cp 4 
4348 20 04				jr nz, .crow1 
434a 3e 78				ld a, display_row_4 
434c 18 02				jr .ccol1 
434e 3e 00		.crow1:		ld a,display_row_1 
4350 f5			.ccol1:		push af			; got row offset 
4351 6f					ld l,a 
4352 26 00				ld h,0 
4354					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4354 cd ec 22			call macro_forth_dsp_pop 
4357				endm 
# End of macro FORTH_DSP_POP
4357					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4357 cd 34 22			call macro_dsp_valuehl 
435a				endm 
# End of macro FORTH_DSP_VALUEHL
435a					; TODO save cursor col 
435a f1					pop af 
435b 85					add l		; add col offset 
435c 32 99 f9				ld (f_cursor_ptr), a 
435f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
435f cd ec 22			call macro_forth_dsp_pop 
4362				endm 
# End of macro FORTH_DSP_POP
4362			 
4362					; calculate  
4362			 
4362					NEXTW 
4362 c3 ea 23			jp macro_next 
4365				endm 
# End of macro NEXTW
4365			 
4365			 
4365			.HOME: 
4365				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
4365 41				db WORD_SYS_CORE+45             
4366 92 43			dw .CR            
4368 05				db 4 + 1 
4369 .. 00			db "HOME",0              
436e				endm 
# End of macro CWHEAD
436e			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
436e					if DEBUG_FORTH_WORDS_KEY 
436e						DMARK "HOM" 
436e f5				push af  
436f 3a 83 43			ld a, (.dmark)  
4372 32 a6 fd			ld (debug_mark),a  
4375 3a 84 43			ld a, (.dmark+1)  
4378 32 a7 fd			ld (debug_mark+1),a  
437b 3a 85 43			ld a, (.dmark+2)  
437e 32 a8 fd			ld (debug_mark+2),a  
4381 18 03			jr .pastdmark  
4383 ..			.dmark: db "HOM"  
4386 f1			.pastdmark: pop af  
4387			endm  
# End of macro DMARK
4387						CALLMONITOR 
4387 cd aa fd			call debug_vector  
438a				endm  
# End of macro CALLMONITOR
438a					endif 
438a 3e 00		.home:		ld a, 0		; and home cursor 
438c 32 99 f9				ld (f_cursor_ptr), a 
438f					NEXTW 
438f c3 ea 23			jp macro_next 
4392				endm 
# End of macro NEXTW
4392			 
4392			 
4392			.CR: 
4392				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
4392 46				db WORD_SYS_CORE+50             
4393 cd 43			dw .SPACE            
4395 03				db 2 + 1 
4396 .. 00			db "CR",0              
4399				endm 
# End of macro CWHEAD
4399			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
4399					if DEBUG_FORTH_WORDS_KEY 
4399						DMARK "CR." 
4399 f5				push af  
439a 3a ae 43			ld a, (.dmark)  
439d 32 a6 fd			ld (debug_mark),a  
43a0 3a af 43			ld a, (.dmark+1)  
43a3 32 a7 fd			ld (debug_mark+1),a  
43a6 3a b0 43			ld a, (.dmark+2)  
43a9 32 a8 fd			ld (debug_mark+2),a  
43ac 18 03			jr .pastdmark  
43ae ..			.dmark: db "CR."  
43b1 f1			.pastdmark: pop af  
43b2			endm  
# End of macro DMARK
43b2						CALLMONITOR 
43b2 cd aa fd			call debug_vector  
43b5				endm  
# End of macro CALLMONITOR
43b5					endif 
43b5 3e 0d				ld a, 13 
43b7 32 fc f0				ld (scratch),a 
43ba 3e 0a				ld a, 10 
43bc 32 fd f0				ld (scratch+1),a 
43bf 3e 00				ld a, 0 
43c1 32 fe f0				ld (scratch+2),a 
43c4 21 fc f0				ld hl, scratch 
43c7 cd 9d 20				call forth_push_str 
43ca					 
43ca				       NEXTW 
43ca c3 ea 23			jp macro_next 
43cd				endm 
# End of macro NEXTW
43cd			.SPACE: 
43cd				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
43cd 46				db WORD_SYS_CORE+50             
43ce 03 44			dw .SPACES            
43d0 03				db 2 + 1 
43d1 .. 00			db "BL",0              
43d4				endm 
# End of macro CWHEAD
43d4			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
43d4					if DEBUG_FORTH_WORDS_KEY 
43d4						DMARK "BL." 
43d4 f5				push af  
43d5 3a e9 43			ld a, (.dmark)  
43d8 32 a6 fd			ld (debug_mark),a  
43db 3a ea 43			ld a, (.dmark+1)  
43de 32 a7 fd			ld (debug_mark+1),a  
43e1 3a eb 43			ld a, (.dmark+2)  
43e4 32 a8 fd			ld (debug_mark+2),a  
43e7 18 03			jr .pastdmark  
43e9 ..			.dmark: db "BL."  
43ec f1			.pastdmark: pop af  
43ed			endm  
# End of macro DMARK
43ed						CALLMONITOR 
43ed cd aa fd			call debug_vector  
43f0				endm  
# End of macro CALLMONITOR
43f0					endif 
43f0 3e 20				ld a, " " 
43f2 32 fc f0				ld (scratch),a 
43f5 3e 00				ld a, 0 
43f7 32 fd f0				ld (scratch+1),a 
43fa 21 fc f0				ld hl, scratch 
43fd cd 9d 20				call forth_push_str 
4400					 
4400				       NEXTW 
4400 c3 ea 23			jp macro_next 
4403				endm 
# End of macro NEXTW
4403			 
4403			;.blstr: db " ", 0 
4403			 
4403			.SPACES: 
4403				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
4403 47				db WORD_SYS_CORE+51             
4404 9e 44			dw .SCROLL            
4406 07				db 6 + 1 
4407 .. 00			db "SPACES",0              
440e				endm 
# End of macro CWHEAD
440e			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
440e					if DEBUG_FORTH_WORDS_KEY 
440e						DMARK "SPS" 
440e f5				push af  
440f 3a 23 44			ld a, (.dmark)  
4412 32 a6 fd			ld (debug_mark),a  
4415 3a 24 44			ld a, (.dmark+1)  
4418 32 a7 fd			ld (debug_mark+1),a  
441b 3a 25 44			ld a, (.dmark+2)  
441e 32 a8 fd			ld (debug_mark+2),a  
4421 18 03			jr .pastdmark  
4423 ..			.dmark: db "SPS"  
4426 f1			.pastdmark: pop af  
4427			endm  
# End of macro DMARK
4427						CALLMONITOR 
4427 cd aa fd			call debug_vector  
442a				endm  
# End of macro CALLMONITOR
442a					endif 
442a			 
442a			 
442a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
442a cd 34 22			call macro_dsp_valuehl 
442d				endm 
# End of macro FORTH_DSP_VALUEHL
442d			 
442d e5					push hl    ; u 
442e					if DEBUG_FORTH_WORDS 
442e						DMARK "SPA" 
442e f5				push af  
442f 3a 43 44			ld a, (.dmark)  
4432 32 a6 fd			ld (debug_mark),a  
4435 3a 44 44			ld a, (.dmark+1)  
4438 32 a7 fd			ld (debug_mark+1),a  
443b 3a 45 44			ld a, (.dmark+2)  
443e 32 a8 fd			ld (debug_mark+2),a  
4441 18 03			jr .pastdmark  
4443 ..			.dmark: db "SPA"  
4446 f1			.pastdmark: pop af  
4447			endm  
# End of macro DMARK
4447						CALLMONITOR 
4447 cd aa fd			call debug_vector  
444a				endm  
# End of macro CALLMONITOR
444a					endif 
444a			 
444a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
444a cd ec 22			call macro_forth_dsp_pop 
444d				endm 
# End of macro FORTH_DSP_POP
444d e1					pop hl 
444e 0e 00				ld c, 0 
4450 45					ld b, l 
4451 21 fc f0				ld hl, scratch  
4454			 
4454					if DEBUG_FORTH_WORDS 
4454						DMARK "SP2" 
4454 f5				push af  
4455 3a 69 44			ld a, (.dmark)  
4458 32 a6 fd			ld (debug_mark),a  
445b 3a 6a 44			ld a, (.dmark+1)  
445e 32 a7 fd			ld (debug_mark+1),a  
4461 3a 6b 44			ld a, (.dmark+2)  
4464 32 a8 fd			ld (debug_mark+2),a  
4467 18 03			jr .pastdmark  
4469 ..			.dmark: db "SP2"  
446c f1			.pastdmark: pop af  
446d			endm  
# End of macro DMARK
446d						CALLMONITOR 
446d cd aa fd			call debug_vector  
4470				endm  
# End of macro CALLMONITOR
4470					endif 
4470 3e 20				ld a, ' ' 
4472			.spaces1:	 
4472 77					ld (hl),a 
4473 23					inc hl 
4474					 
4474 10 fc				djnz .spaces1 
4476 3e 00				ld a,0 
4478 77					ld (hl),a 
4479 21 fc f0				ld hl, scratch 
447c					if DEBUG_FORTH_WORDS 
447c						DMARK "SP3" 
447c f5				push af  
447d 3a 91 44			ld a, (.dmark)  
4480 32 a6 fd			ld (debug_mark),a  
4483 3a 92 44			ld a, (.dmark+1)  
4486 32 a7 fd			ld (debug_mark+1),a  
4489 3a 93 44			ld a, (.dmark+2)  
448c 32 a8 fd			ld (debug_mark+2),a  
448f 18 03			jr .pastdmark  
4491 ..			.dmark: db "SP3"  
4494 f1			.pastdmark: pop af  
4495			endm  
# End of macro DMARK
4495						CALLMONITOR 
4495 cd aa fd			call debug_vector  
4498				endm  
# End of macro CALLMONITOR
4498					endif 
4498 cd 9d 20				call forth_push_str 
449b			 
449b				       NEXTW 
449b c3 ea 23			jp macro_next 
449e				endm 
# End of macro NEXTW
449e			 
449e			 
449e			 
449e			.SCROLL: 
449e				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
449e 53				db WORD_SYS_CORE+63             
449f cb 44			dw .SCROLLD            
44a1 07				db 6 + 1 
44a2 .. 00			db "SCROLL",0              
44a9				endm 
# End of macro CWHEAD
44a9			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
44a9					if DEBUG_FORTH_WORDS_KEY 
44a9						DMARK "SCR" 
44a9 f5				push af  
44aa 3a be 44			ld a, (.dmark)  
44ad 32 a6 fd			ld (debug_mark),a  
44b0 3a bf 44			ld a, (.dmark+1)  
44b3 32 a7 fd			ld (debug_mark+1),a  
44b6 3a c0 44			ld a, (.dmark+2)  
44b9 32 a8 fd			ld (debug_mark+2),a  
44bc 18 03			jr .pastdmark  
44be ..			.dmark: db "SCR"  
44c1 f1			.pastdmark: pop af  
44c2			endm  
# End of macro DMARK
44c2						CALLMONITOR 
44c2 cd aa fd			call debug_vector  
44c5				endm  
# End of macro CALLMONITOR
44c5					endif 
44c5			 
44c5 cd 69 0d			call scroll_up 
44c8			;	call update_display 
44c8			 
44c8					NEXTW 
44c8 c3 ea 23			jp macro_next 
44cb				endm 
# End of macro NEXTW
44cb			 
44cb			 
44cb			 
44cb			;		; get dir 
44cb			; 
44cb			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44cb			; 
44cb			;		push hl 
44cb			; 
44cb			;		; destroy value TOS 
44cb			; 
44cb			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44cb			; 
44cb			;		; get count 
44cb			; 
44cb			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44cb			; 
44cb			;		push hl 
44cb			; 
44cb			;		; destroy value TOS 
44cb			; 
44cb			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44cb			; 
44cb			;		; one value on hl get other one back 
44cb			; 
44cb			;		pop bc    ; count 
44cb			; 
44cb			;		pop de   ; dir 
44cb			; 
44cb			; 
44cb			;		ld b, c 
44cb			; 
44cb			;.scrolldir:     push bc 
44cb			;		push de 
44cb			; 
44cb			;		ld a, 0 
44cb			;		cp e 
44cb			;		jr z, .scrollup  
44cb			;		call scroll_down 
44cb			;		jr .scrollnext 
44cb			;.scrollup:	call scroll_up 
44cb			; 
44cb			;		 
44cb			;.scrollnext: 
44cb			;		pop de 
44cb			;		pop bc 
44cb			;		djnz .scrolldir 
44cb			; 
44cb			; 
44cb			; 
44cb			; 
44cb			; 
44cb			;		NEXTW 
44cb			 
44cb			.SCROLLD: 
44cb				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
44cb 53				db WORD_SYS_CORE+63             
44cc f9 44			dw .ATQ            
44ce 08				db 7 + 1 
44cf .. 00			db "SCROLLD",0              
44d7				endm 
# End of macro CWHEAD
44d7			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
44d7					if DEBUG_FORTH_WORDS_KEY 
44d7						DMARK "SCD" 
44d7 f5				push af  
44d8 3a ec 44			ld a, (.dmark)  
44db 32 a6 fd			ld (debug_mark),a  
44de 3a ed 44			ld a, (.dmark+1)  
44e1 32 a7 fd			ld (debug_mark+1),a  
44e4 3a ee 44			ld a, (.dmark+2)  
44e7 32 a8 fd			ld (debug_mark+2),a  
44ea 18 03			jr .pastdmark  
44ec ..			.dmark: db "SCD"  
44ef f1			.pastdmark: pop af  
44f0			endm  
# End of macro DMARK
44f0						CALLMONITOR 
44f0 cd aa fd			call debug_vector  
44f3				endm  
# End of macro CALLMONITOR
44f3					endif 
44f3			 
44f3 cd 8d 0d			call scroll_down 
44f6			;	call update_display 
44f6			 
44f6					NEXTW 
44f6 c3 ea 23			jp macro_next 
44f9				endm 
# End of macro NEXTW
44f9			 
44f9			 
44f9			.ATQ: 
44f9				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
44f9 62				db WORD_SYS_CORE+78             
44fa 57 45			dw .AUTODSP            
44fc 04				db 3 + 1 
44fd .. 00			db "AT@",0              
4501				endm 
# End of macro CWHEAD
4501			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
4501					if DEBUG_FORTH_WORDS_KEY 
4501						DMARK "ATA" 
4501 f5				push af  
4502 3a 16 45			ld a, (.dmark)  
4505 32 a6 fd			ld (debug_mark),a  
4508 3a 17 45			ld a, (.dmark+1)  
450b 32 a7 fd			ld (debug_mark+1),a  
450e 3a 18 45			ld a, (.dmark+2)  
4511 32 a8 fd			ld (debug_mark+2),a  
4514 18 03			jr .pastdmark  
4516 ..			.dmark: db "ATA"  
4519 f1			.pastdmark: pop af  
451a			endm  
# End of macro DMARK
451a						CALLMONITOR 
451a cd aa fd			call debug_vector  
451d				endm  
# End of macro CALLMONITOR
451d					endif 
451d			 
451d			 
451d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
451d cd 34 22			call macro_dsp_valuehl 
4520				endm 
# End of macro FORTH_DSP_VALUEHL
4520			 
4520					; TODO save cursor row 
4520 7d					ld a,l 
4521 fe 02				cp 2 
4523 20 04				jr nz, .crow3aq 
4525 3e 28				ld a, display_row_2 
4527 18 12				jr .ccol1aq 
4529 fe 03		.crow3aq:		cp 3 
452b 20 04				jr nz, .crow4aq 
452d 3e 50				ld a, display_row_3 
452f 18 0a				jr .ccol1aq 
4531 fe 04		.crow4aq:		cp 4 
4533 20 04				jr nz, .crow1aq 
4535 3e 78				ld a, display_row_4 
4537 18 02				jr .ccol1aq 
4539 3e 00		.crow1aq:		ld a,display_row_1 
453b f5			.ccol1aq:		push af			; got row offset 
453c 6f					ld l,a 
453d 26 00				ld h,0 
453f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
453f cd ec 22			call macro_forth_dsp_pop 
4542				endm 
# End of macro FORTH_DSP_POP
4542					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4542 cd 34 22			call macro_dsp_valuehl 
4545				endm 
# End of macro FORTH_DSP_VALUEHL
4545					; TODO save cursor col 
4545 f1					pop af 
4546 85					add l		; add col offset 
4547			 
4547					; add current frame buffer address 
4547 2a 07 fb				ld hl, (display_fb_active) 
454a cd db 0f				call addatohl 
454d			 
454d			 
454d			 
454d			 
454d					; get char frame buffer location offset in hl 
454d			 
454d 7e					ld a,(hl) 
454e 26 00				ld h, 0 
4550 6f					ld l, a 
4551			 
4551 cd 2f 20				call forth_push_numhl 
4554			 
4554			 
4554					NEXTW 
4554 c3 ea 23			jp macro_next 
4557				endm 
# End of macro NEXTW
4557			 
4557			.AUTODSP: 
4557				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4557 63				db WORD_SYS_CORE+79             
4558 6d 45			dw .MENU            
455a 05				db 4 + 1 
455b .. 00			db "ADSP",0              
4560				endm 
# End of macro CWHEAD
4560			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4560			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4560			 
4560					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4560 cd 34 22			call macro_dsp_valuehl 
4563				endm 
# End of macro FORTH_DSP_VALUEHL
4563			 
4563			;		push hl 
4563			 
4563					; destroy value TOS 
4563			 
4563					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4563 cd ec 22			call macro_forth_dsp_pop 
4566				endm 
# End of macro FORTH_DSP_POP
4566			 
4566			;		pop hl 
4566			 
4566 7d					ld a,l 
4567 32 77 f9				ld (cli_autodisplay), a 
456a				       NEXTW 
456a c3 ea 23			jp macro_next 
456d				endm 
# End of macro NEXTW
456d			 
456d			.MENU: 
456d				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
456d 70				db WORD_SYS_CORE+92             
456e 16 46			dw .ENDDISPLAY            
4570 05				db 4 + 1 
4571 .. 00			db "MENU",0              
4576				endm 
# End of macro CWHEAD
4576			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
4576			 
4576			;		; get number of items on the stack 
4576			; 
4576				 
4576					FORTH_DSP_VALUEHL 
4576 cd 34 22			call macro_dsp_valuehl 
4579				endm 
# End of macro FORTH_DSP_VALUEHL
4579				 
4579					if DEBUG_FORTH_WORDS_KEY 
4579						DMARK "MNU" 
4579 f5				push af  
457a 3a 8e 45			ld a, (.dmark)  
457d 32 a6 fd			ld (debug_mark),a  
4580 3a 8f 45			ld a, (.dmark+1)  
4583 32 a7 fd			ld (debug_mark+1),a  
4586 3a 90 45			ld a, (.dmark+2)  
4589 32 a8 fd			ld (debug_mark+2),a  
458c 18 03			jr .pastdmark  
458e ..			.dmark: db "MNU"  
4591 f1			.pastdmark: pop af  
4592			endm  
# End of macro DMARK
4592						CALLMONITOR 
4592 cd aa fd			call debug_vector  
4595				endm  
# End of macro CALLMONITOR
4595					endif 
4595			 
4595 45					ld b, l	 
4596 05					dec b 
4597			 
4597					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4597 cd ec 22			call macro_forth_dsp_pop 
459a				endm 
# End of macro FORTH_DSP_POP
459a			 
459a			 
459a					; go directly through the stack to pluck out the string pointers and build an array 
459a			 
459a			;		FORTH_DSP 
459a			 
459a					; hl contains top most stack item 
459a				 
459a 11 fc f0				ld de, scratch 
459d			 
459d			.mbuild: 
459d			 
459d					FORTH_DSP_VALUEHL 
459d cd 34 22			call macro_dsp_valuehl 
45a0				endm 
# End of macro FORTH_DSP_VALUEHL
45a0			 
45a0					if DEBUG_FORTH_WORDS 
45a0						DMARK "MN3" 
45a0 f5				push af  
45a1 3a b5 45			ld a, (.dmark)  
45a4 32 a6 fd			ld (debug_mark),a  
45a7 3a b6 45			ld a, (.dmark+1)  
45aa 32 a7 fd			ld (debug_mark+1),a  
45ad 3a b7 45			ld a, (.dmark+2)  
45b0 32 a8 fd			ld (debug_mark+2),a  
45b3 18 03			jr .pastdmark  
45b5 ..			.dmark: db "MN3"  
45b8 f1			.pastdmark: pop af  
45b9			endm  
# End of macro DMARK
45b9						CALLMONITOR 
45b9 cd aa fd			call debug_vector  
45bc				endm  
# End of macro CALLMONITOR
45bc					endif 
45bc eb					ex de, hl 
45bd 73					ld (hl), e 
45be 23					inc hl 
45bf 72					ld (hl), d 
45c0 23					inc hl 
45c1 eb					ex de, hl 
45c2			 
45c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45c2 cd ec 22			call macro_forth_dsp_pop 
45c5				endm 
# End of macro FORTH_DSP_POP
45c5			 
45c5 10 d6				djnz .mbuild 
45c7			 
45c7					; done add term 
45c7			 
45c7 eb					ex de, hl 
45c8 36 00				ld (hl), 0 
45ca 23					inc hl 
45cb 36 00				ld (hl), 0 
45cd			 
45cd				 
45cd					 
45cd 21 fc f0				ld hl, scratch 
45d0			 
45d0					if DEBUG_FORTH_WORDS 
45d0						DMARK "MNx" 
45d0 f5				push af  
45d1 3a e5 45			ld a, (.dmark)  
45d4 32 a6 fd			ld (debug_mark),a  
45d7 3a e6 45			ld a, (.dmark+1)  
45da 32 a7 fd			ld (debug_mark+1),a  
45dd 3a e7 45			ld a, (.dmark+2)  
45e0 32 a8 fd			ld (debug_mark+2),a  
45e3 18 03			jr .pastdmark  
45e5 ..			.dmark: db "MNx"  
45e8 f1			.pastdmark: pop af  
45e9			endm  
# End of macro DMARK
45e9						CALLMONITOR 
45e9 cd aa fd			call debug_vector  
45ec				endm  
# End of macro CALLMONITOR
45ec					endif 
45ec			 
45ec			 
45ec			 
45ec 3e 00				ld a, 0 
45ee cd d8 0d				call menu 
45f1			 
45f1			 
45f1 6f					ld l, a 
45f2 26 00				ld h, 0 
45f4			 
45f4					if DEBUG_FORTH_WORDS 
45f4						DMARK "MNr" 
45f4 f5				push af  
45f5 3a 09 46			ld a, (.dmark)  
45f8 32 a6 fd			ld (debug_mark),a  
45fb 3a 0a 46			ld a, (.dmark+1)  
45fe 32 a7 fd			ld (debug_mark+1),a  
4601 3a 0b 46			ld a, (.dmark+2)  
4604 32 a8 fd			ld (debug_mark+2),a  
4607 18 03			jr .pastdmark  
4609 ..			.dmark: db "MNr"  
460c f1			.pastdmark: pop af  
460d			endm  
# End of macro DMARK
460d						CALLMONITOR 
460d cd aa fd			call debug_vector  
4610				endm  
# End of macro CALLMONITOR
4610					endif 
4610			 
4610 cd 2f 20				call forth_push_numhl 
4613			 
4613			 
4613			 
4613			 
4613				       NEXTW 
4613 c3 ea 23			jp macro_next 
4616				endm 
# End of macro NEXTW
4616			 
4616			 
4616			.ENDDISPLAY: 
4616			 
4616			; eof 
# End of file forth_words_display.asm
4616			include "forth_words_str.asm" 
4616			 
4616			; | ## String Words 
4616			 
4616			.PTR:   
4616			 
4616				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4616 48				db WORD_SYS_CORE+52             
4617 43 46			dw .STYPE            
4619 04				db 3 + 1 
461a .. 00			db "PTR",0              
461e				endm 
# End of macro CWHEAD
461e			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
461e			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
461e			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
461e			 
461e					if DEBUG_FORTH_WORDS_KEY 
461e						DMARK "PTR" 
461e f5				push af  
461f 3a 33 46			ld a, (.dmark)  
4622 32 a6 fd			ld (debug_mark),a  
4625 3a 34 46			ld a, (.dmark+1)  
4628 32 a7 fd			ld (debug_mark+1),a  
462b 3a 35 46			ld a, (.dmark+2)  
462e 32 a8 fd			ld (debug_mark+2),a  
4631 18 03			jr .pastdmark  
4633 ..			.dmark: db "PTR"  
4636 f1			.pastdmark: pop af  
4637			endm  
# End of macro DMARK
4637						CALLMONITOR 
4637 cd aa fd			call debug_vector  
463a				endm  
# End of macro CALLMONITOR
463a					endif 
463a					FORTH_DSP_VALUEHL 
463a cd 34 22			call macro_dsp_valuehl 
463d				endm 
# End of macro FORTH_DSP_VALUEHL
463d cd 2f 20				call forth_push_numhl 
4640			 
4640			 
4640					NEXTW 
4640 c3 ea 23			jp macro_next 
4643				endm 
# End of macro NEXTW
4643			.STYPE: 
4643				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4643 48				db WORD_SYS_CORE+52             
4644 92 46			dw .UPPER            
4646 06				db 5 + 1 
4647 .. 00			db "STYPE",0              
464d				endm 
# End of macro CWHEAD
464d			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
464d					if DEBUG_FORTH_WORDS_KEY 
464d						DMARK "STY" 
464d f5				push af  
464e 3a 62 46			ld a, (.dmark)  
4651 32 a6 fd			ld (debug_mark),a  
4654 3a 63 46			ld a, (.dmark+1)  
4657 32 a7 fd			ld (debug_mark+1),a  
465a 3a 64 46			ld a, (.dmark+2)  
465d 32 a8 fd			ld (debug_mark+2),a  
4660 18 03			jr .pastdmark  
4662 ..			.dmark: db "STY"  
4665 f1			.pastdmark: pop af  
4666			endm  
# End of macro DMARK
4666						CALLMONITOR 
4666 cd aa fd			call debug_vector  
4669				endm  
# End of macro CALLMONITOR
4669					endif 
4669					FORTH_DSP 
4669 cd fa 21			call macro_forth_dsp 
466c				endm 
# End of macro FORTH_DSP
466c					;v5 FORTH_DSP_VALUE 
466c			 
466c 7e					ld a, (hl) 
466d			 
466d f5					push af 
466e			 
466e			; Dont destroy TOS		FORTH_DSP_POP 
466e			 
466e f1					pop af 
466f			 
466f fe 01				cp DS_TYPE_STR 
4671 28 09				jr z, .typestr 
4673			 
4673 fe 02				cp DS_TYPE_INUM 
4675 28 0a				jr z, .typeinum 
4677			 
4677 21 90 46				ld hl, .tna 
467a 18 0a				jr .tpush 
467c			 
467c 21 8c 46		.typestr:	ld hl, .tstr 
467f 18 05				jr .tpush 
4681 21 8e 46		.typeinum:	ld hl, .tinum 
4684 18 00				jr .tpush 
4686			 
4686			.tpush: 
4686			 
4686 cd 9d 20				call forth_push_str 
4689			 
4689					NEXTW 
4689 c3 ea 23			jp macro_next 
468c				endm 
# End of macro NEXTW
468c .. 00		.tstr:	db "s",0 
468e .. 00		.tinum:  db "i",0 
4690 .. 00		.tna:   db "?", 0 
4692			 
4692			 
4692			.UPPER: 
4692				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4692 48				db WORD_SYS_CORE+52             
4693 cd 46			dw .LOWER            
4695 06				db 5 + 1 
4696 .. 00			db "UPPER",0              
469c				endm 
# End of macro CWHEAD
469c			; | UPPER ( s -- s ) Upper case string s  | DONE 
469c					if DEBUG_FORTH_WORDS_KEY 
469c						DMARK "UPR" 
469c f5				push af  
469d 3a b1 46			ld a, (.dmark)  
46a0 32 a6 fd			ld (debug_mark),a  
46a3 3a b2 46			ld a, (.dmark+1)  
46a6 32 a7 fd			ld (debug_mark+1),a  
46a9 3a b3 46			ld a, (.dmark+2)  
46ac 32 a8 fd			ld (debug_mark+2),a  
46af 18 03			jr .pastdmark  
46b1 ..			.dmark: db "UPR"  
46b4 f1			.pastdmark: pop af  
46b5			endm  
# End of macro DMARK
46b5						CALLMONITOR 
46b5 cd aa fd			call debug_vector  
46b8				endm  
# End of macro CALLMONITOR
46b8					endif 
46b8			 
46b8					FORTH_DSP 
46b8 cd fa 21			call macro_forth_dsp 
46bb				endm 
# End of macro FORTH_DSP
46bb					 
46bb			; TODO check is string type 
46bb			 
46bb					FORTH_DSP_VALUEHL 
46bb cd 34 22			call macro_dsp_valuehl 
46be				endm 
# End of macro FORTH_DSP_VALUEHL
46be			; get pointer to string in hl 
46be			 
46be 7e			.toup:		ld a, (hl) 
46bf fe 00				cp 0 
46c1 28 07				jr z, .toupdone 
46c3			 
46c3 cd 50 12				call to_upper 
46c6			 
46c6 77					ld (hl), a 
46c7 23					inc hl 
46c8 18 f4				jr .toup 
46ca			 
46ca					 
46ca			 
46ca			 
46ca			; for each char convert to upper 
46ca					 
46ca			.toupdone: 
46ca			 
46ca			 
46ca					NEXTW 
46ca c3 ea 23			jp macro_next 
46cd				endm 
# End of macro NEXTW
46cd			.LOWER: 
46cd				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
46cd 48				db WORD_SYS_CORE+52             
46ce 08 47			dw .TCASE            
46d0 06				db 5 + 1 
46d1 .. 00			db "LOWER",0              
46d7				endm 
# End of macro CWHEAD
46d7			; | LOWER ( s -- s ) Lower case string s  | DONE 
46d7					if DEBUG_FORTH_WORDS_KEY 
46d7						DMARK "LWR" 
46d7 f5				push af  
46d8 3a ec 46			ld a, (.dmark)  
46db 32 a6 fd			ld (debug_mark),a  
46de 3a ed 46			ld a, (.dmark+1)  
46e1 32 a7 fd			ld (debug_mark+1),a  
46e4 3a ee 46			ld a, (.dmark+2)  
46e7 32 a8 fd			ld (debug_mark+2),a  
46ea 18 03			jr .pastdmark  
46ec ..			.dmark: db "LWR"  
46ef f1			.pastdmark: pop af  
46f0			endm  
# End of macro DMARK
46f0						CALLMONITOR 
46f0 cd aa fd			call debug_vector  
46f3				endm  
# End of macro CALLMONITOR
46f3					endif 
46f3			 
46f3					FORTH_DSP 
46f3 cd fa 21			call macro_forth_dsp 
46f6				endm 
# End of macro FORTH_DSP
46f6					 
46f6			; TODO check is string type 
46f6			 
46f6					FORTH_DSP_VALUEHL 
46f6 cd 34 22			call macro_dsp_valuehl 
46f9				endm 
# End of macro FORTH_DSP_VALUEHL
46f9			; get pointer to string in hl 
46f9			 
46f9 7e			.tolow:		ld a, (hl) 
46fa fe 00				cp 0 
46fc 28 07				jr z, .tolowdone 
46fe			 
46fe cd 59 12				call to_lower 
4701			 
4701 77					ld (hl), a 
4702 23					inc hl 
4703 18 f4				jr .tolow 
4705			 
4705					 
4705			 
4705			 
4705			; for each char convert to low 
4705					 
4705			.tolowdone: 
4705					NEXTW 
4705 c3 ea 23			jp macro_next 
4708				endm 
# End of macro NEXTW
4708			.TCASE: 
4708				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4708 48				db WORD_SYS_CORE+52             
4709 3e 48			dw .SUBSTR            
470b 06				db 5 + 1 
470c .. 00			db "TCASE",0              
4712				endm 
# End of macro CWHEAD
4712			; | TCASE ( s -- s ) Title case string s  | DONE 
4712					if DEBUG_FORTH_WORDS_KEY 
4712						DMARK "TCS" 
4712 f5				push af  
4713 3a 27 47			ld a, (.dmark)  
4716 32 a6 fd			ld (debug_mark),a  
4719 3a 28 47			ld a, (.dmark+1)  
471c 32 a7 fd			ld (debug_mark+1),a  
471f 3a 29 47			ld a, (.dmark+2)  
4722 32 a8 fd			ld (debug_mark+2),a  
4725 18 03			jr .pastdmark  
4727 ..			.dmark: db "TCS"  
472a f1			.pastdmark: pop af  
472b			endm  
# End of macro DMARK
472b						CALLMONITOR 
472b cd aa fd			call debug_vector  
472e				endm  
# End of macro CALLMONITOR
472e					endif 
472e			 
472e					FORTH_DSP 
472e cd fa 21			call macro_forth_dsp 
4731				endm 
# End of macro FORTH_DSP
4731					 
4731			; TODO check is string type 
4731			 
4731					FORTH_DSP_VALUEHL 
4731 cd 34 22			call macro_dsp_valuehl 
4734				endm 
# End of macro FORTH_DSP_VALUEHL
4734			; get pointer to string in hl 
4734			 
4734					if DEBUG_FORTH_WORDS 
4734						DMARK "TC1" 
4734 f5				push af  
4735 3a 49 47			ld a, (.dmark)  
4738 32 a6 fd			ld (debug_mark),a  
473b 3a 4a 47			ld a, (.dmark+1)  
473e 32 a7 fd			ld (debug_mark+1),a  
4741 3a 4b 47			ld a, (.dmark+2)  
4744 32 a8 fd			ld (debug_mark+2),a  
4747 18 03			jr .pastdmark  
4749 ..			.dmark: db "TC1"  
474c f1			.pastdmark: pop af  
474d			endm  
# End of macro DMARK
474d						CALLMONITOR 
474d cd aa fd			call debug_vector  
4750				endm  
# End of macro CALLMONITOR
4750					endif 
4750			 
4750					; first time in turn to upper case first char 
4750			 
4750 7e					ld a, (hl) 
4751 c3 db 47				jp .totsiptou 
4754			 
4754			 
4754 7e			.tot:		ld a, (hl) 
4755 fe 00				cp 0 
4757 ca 1f 48				jp z, .totdone 
475a			 
475a					if DEBUG_FORTH_WORDS 
475a						DMARK "TC2" 
475a f5				push af  
475b 3a 6f 47			ld a, (.dmark)  
475e 32 a6 fd			ld (debug_mark),a  
4761 3a 70 47			ld a, (.dmark+1)  
4764 32 a7 fd			ld (debug_mark+1),a  
4767 3a 71 47			ld a, (.dmark+2)  
476a 32 a8 fd			ld (debug_mark+2),a  
476d 18 03			jr .pastdmark  
476f ..			.dmark: db "TC2"  
4772 f1			.pastdmark: pop af  
4773			endm  
# End of macro DMARK
4773						CALLMONITOR 
4773 cd aa fd			call debug_vector  
4776				endm  
# End of macro CALLMONITOR
4776					endif 
4776					; check to see if current char is a space 
4776			 
4776 fe 20				cp ' ' 
4778 28 21				jr z, .totsp 
477a cd 59 12				call to_lower 
477d					if DEBUG_FORTH_WORDS 
477d						DMARK "TC3" 
477d f5				push af  
477e 3a 92 47			ld a, (.dmark)  
4781 32 a6 fd			ld (debug_mark),a  
4784 3a 93 47			ld a, (.dmark+1)  
4787 32 a7 fd			ld (debug_mark+1),a  
478a 3a 94 47			ld a, (.dmark+2)  
478d 32 a8 fd			ld (debug_mark+2),a  
4790 18 03			jr .pastdmark  
4792 ..			.dmark: db "TC3"  
4795 f1			.pastdmark: pop af  
4796			endm  
# End of macro DMARK
4796						CALLMONITOR 
4796 cd aa fd			call debug_vector  
4799				endm  
# End of macro CALLMONITOR
4799					endif 
4799 18 63				jr .totnxt 
479b			 
479b			.totsp:         ; on a space, find next char which should be upper 
479b			 
479b					if DEBUG_FORTH_WORDS 
479b						DMARK "TC4" 
479b f5				push af  
479c 3a b0 47			ld a, (.dmark)  
479f 32 a6 fd			ld (debug_mark),a  
47a2 3a b1 47			ld a, (.dmark+1)  
47a5 32 a7 fd			ld (debug_mark+1),a  
47a8 3a b2 47			ld a, (.dmark+2)  
47ab 32 a8 fd			ld (debug_mark+2),a  
47ae 18 03			jr .pastdmark  
47b0 ..			.dmark: db "TC4"  
47b3 f1			.pastdmark: pop af  
47b4			endm  
# End of macro DMARK
47b4						CALLMONITOR 
47b4 cd aa fd			call debug_vector  
47b7				endm  
# End of macro CALLMONITOR
47b7					endif 
47b7					;; 
47b7			 
47b7 fe 20				cp ' ' 
47b9 20 20				jr nz, .totsiptou 
47bb 23					inc hl 
47bc 7e					ld a, (hl) 
47bd					if DEBUG_FORTH_WORDS 
47bd						DMARK "TC5" 
47bd f5				push af  
47be 3a d2 47			ld a, (.dmark)  
47c1 32 a6 fd			ld (debug_mark),a  
47c4 3a d3 47			ld a, (.dmark+1)  
47c7 32 a7 fd			ld (debug_mark+1),a  
47ca 3a d4 47			ld a, (.dmark+2)  
47cd 32 a8 fd			ld (debug_mark+2),a  
47d0 18 03			jr .pastdmark  
47d2 ..			.dmark: db "TC5"  
47d5 f1			.pastdmark: pop af  
47d6			endm  
# End of macro DMARK
47d6						CALLMONITOR 
47d6 cd aa fd			call debug_vector  
47d9				endm  
# End of macro CALLMONITOR
47d9					endif 
47d9 18 c0				jr .totsp 
47db fe 00		.totsiptou:    cp 0 
47dd 28 40				jr z, .totdone 
47df					; not space and not zero term so upper case it 
47df cd 50 12				call to_upper 
47e2			 
47e2					if DEBUG_FORTH_WORDS 
47e2						DMARK "TC6" 
47e2 f5				push af  
47e3 3a f7 47			ld a, (.dmark)  
47e6 32 a6 fd			ld (debug_mark),a  
47e9 3a f8 47			ld a, (.dmark+1)  
47ec 32 a7 fd			ld (debug_mark+1),a  
47ef 3a f9 47			ld a, (.dmark+2)  
47f2 32 a8 fd			ld (debug_mark+2),a  
47f5 18 03			jr .pastdmark  
47f7 ..			.dmark: db "TC6"  
47fa f1			.pastdmark: pop af  
47fb			endm  
# End of macro DMARK
47fb						CALLMONITOR 
47fb cd aa fd			call debug_vector  
47fe				endm  
# End of macro CALLMONITOR
47fe					endif 
47fe			 
47fe			 
47fe			.totnxt: 
47fe			 
47fe 77					ld (hl), a 
47ff 23					inc hl 
4800					if DEBUG_FORTH_WORDS 
4800						DMARK "TC7" 
4800 f5				push af  
4801 3a 15 48			ld a, (.dmark)  
4804 32 a6 fd			ld (debug_mark),a  
4807 3a 16 48			ld a, (.dmark+1)  
480a 32 a7 fd			ld (debug_mark+1),a  
480d 3a 17 48			ld a, (.dmark+2)  
4810 32 a8 fd			ld (debug_mark+2),a  
4813 18 03			jr .pastdmark  
4815 ..			.dmark: db "TC7"  
4818 f1			.pastdmark: pop af  
4819			endm  
# End of macro DMARK
4819						CALLMONITOR 
4819 cd aa fd			call debug_vector  
481c				endm  
# End of macro CALLMONITOR
481c					endif 
481c c3 54 47				jp .tot 
481f			 
481f					 
481f			 
481f			 
481f			; for each char convert to low 
481f					 
481f			.totdone: 
481f					if DEBUG_FORTH_WORDS 
481f						DMARK "TCd" 
481f f5				push af  
4820 3a 34 48			ld a, (.dmark)  
4823 32 a6 fd			ld (debug_mark),a  
4826 3a 35 48			ld a, (.dmark+1)  
4829 32 a7 fd			ld (debug_mark+1),a  
482c 3a 36 48			ld a, (.dmark+2)  
482f 32 a8 fd			ld (debug_mark+2),a  
4832 18 03			jr .pastdmark  
4834 ..			.dmark: db "TCd"  
4837 f1			.pastdmark: pop af  
4838			endm  
# End of macro DMARK
4838						CALLMONITOR 
4838 cd aa fd			call debug_vector  
483b				endm  
# End of macro CALLMONITOR
483b					endif 
483b					NEXTW 
483b c3 ea 23			jp macro_next 
483e				endm 
# End of macro NEXTW
483e			 
483e			.SUBSTR: 
483e				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
483e 48				db WORD_SYS_CORE+52             
483f 9c 48			dw .LEFT            
4841 07				db 6 + 1 
4842 .. 00			db "SUBSTR",0              
4849				endm 
# End of macro CWHEAD
4849			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4849			 
4849					if DEBUG_FORTH_WORDS_KEY 
4849						DMARK "SST" 
4849 f5				push af  
484a 3a 5e 48			ld a, (.dmark)  
484d 32 a6 fd			ld (debug_mark),a  
4850 3a 5f 48			ld a, (.dmark+1)  
4853 32 a7 fd			ld (debug_mark+1),a  
4856 3a 60 48			ld a, (.dmark+2)  
4859 32 a8 fd			ld (debug_mark+2),a  
485c 18 03			jr .pastdmark  
485e ..			.dmark: db "SST"  
4861 f1			.pastdmark: pop af  
4862			endm  
# End of macro DMARK
4862						CALLMONITOR 
4862 cd aa fd			call debug_vector  
4865				endm  
# End of macro CALLMONITOR
4865					endif 
4865			; TODO check string type 
4865					FORTH_DSP_VALUEHL 
4865 cd 34 22			call macro_dsp_valuehl 
4868				endm 
# End of macro FORTH_DSP_VALUEHL
4868			 
4868 e5					push hl      ; string length 
4869			 
4869					FORTH_DSP_POP 
4869 cd ec 22			call macro_forth_dsp_pop 
486c				endm 
# End of macro FORTH_DSP_POP
486c			 
486c					FORTH_DSP_VALUEHL 
486c cd 34 22			call macro_dsp_valuehl 
486f				endm 
# End of macro FORTH_DSP_VALUEHL
486f			 
486f e5					push hl     ; start char 
4870			 
4870					FORTH_DSP_POP 
4870 cd ec 22			call macro_forth_dsp_pop 
4873				endm 
# End of macro FORTH_DSP_POP
4873			 
4873			 
4873					FORTH_DSP_VALUE 
4873 cd 1d 22			call macro_forth_dsp_value 
4876				endm 
# End of macro FORTH_DSP_VALUE
4876			 
4876 d1					pop de    ; get start post offset 
4877			 
4877 19					add hl, de    ; starting offset 
4878			 
4878 c1					pop bc 
4879 c5					push bc      ; grab size of string 
487a			 
487a e5					push hl    ; save string start  
487b			 
487b 26 00				ld h, 0 
487d 69					ld l, c 
487e 23					inc hl 
487f 23					inc hl 
4880			 
4880 cd b6 13				call malloc 
4883				if DEBUG_FORTH_MALLOC_GUARD 
4883 cc c9 5d				call z,malloc_error 
4886				endif 
4886			 
4886 eb					ex de, hl      ; save malloc area for string copy 
4887 e1					pop hl    ; get back source 
4888 c1					pop bc    ; get length of string back 
4889			 
4889 d5					push de    ; save malloc area for after we push 
488a ed b0				ldir     ; copy substr 
488c			 
488c			 
488c eb					ex de, hl 
488d 3e 00				ld a, 0 
488f 77					ld (hl), a   ; term substr 
4890			 
4890					 
4890 e1					pop hl    ; get malloc so we can push it 
4891 e5					push hl   ; save so we can free it afterwards 
4892			 
4892 cd 9d 20				call forth_push_str 
4895			 
4895 e1					pop hl 
4896 cd 80 14				call free 
4899			 
4899					 
4899					 
4899			 
4899			 
4899					NEXTW 
4899 c3 ea 23			jp macro_next 
489c				endm 
# End of macro NEXTW
489c			 
489c			.LEFT: 
489c				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
489c 48				db WORD_SYS_CORE+52             
489d c4 48			dw .RIGHT            
489f 05				db 4 + 1 
48a0 .. 00			db "LEFT",0              
48a5				endm 
# End of macro CWHEAD
48a5			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
48a5					if DEBUG_FORTH_WORDS_KEY 
48a5						DMARK "LEF" 
48a5 f5				push af  
48a6 3a ba 48			ld a, (.dmark)  
48a9 32 a6 fd			ld (debug_mark),a  
48ac 3a bb 48			ld a, (.dmark+1)  
48af 32 a7 fd			ld (debug_mark+1),a  
48b2 3a bc 48			ld a, (.dmark+2)  
48b5 32 a8 fd			ld (debug_mark+2),a  
48b8 18 03			jr .pastdmark  
48ba ..			.dmark: db "LEF"  
48bd f1			.pastdmark: pop af  
48be			endm  
# End of macro DMARK
48be						CALLMONITOR 
48be cd aa fd			call debug_vector  
48c1				endm  
# End of macro CALLMONITOR
48c1					endif 
48c1			 
48c1					NEXTW 
48c1 c3 ea 23			jp macro_next 
48c4				endm 
# End of macro NEXTW
48c4			.RIGHT: 
48c4				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
48c4 48				db WORD_SYS_CORE+52             
48c5 ed 48			dw .STR2NUM            
48c7 06				db 5 + 1 
48c8 .. 00			db "RIGHT",0              
48ce				endm 
# End of macro CWHEAD
48ce			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
48ce					if DEBUG_FORTH_WORDS_KEY 
48ce						DMARK "RIG" 
48ce f5				push af  
48cf 3a e3 48			ld a, (.dmark)  
48d2 32 a6 fd			ld (debug_mark),a  
48d5 3a e4 48			ld a, (.dmark+1)  
48d8 32 a7 fd			ld (debug_mark+1),a  
48db 3a e5 48			ld a, (.dmark+2)  
48de 32 a8 fd			ld (debug_mark+2),a  
48e1 18 03			jr .pastdmark  
48e3 ..			.dmark: db "RIG"  
48e6 f1			.pastdmark: pop af  
48e7			endm  
# End of macro DMARK
48e7						CALLMONITOR 
48e7 cd aa fd			call debug_vector  
48ea				endm  
# End of macro CALLMONITOR
48ea					endif 
48ea			 
48ea					NEXTW 
48ea c3 ea 23			jp macro_next 
48ed				endm 
# End of macro NEXTW
48ed			 
48ed			 
48ed			.STR2NUM: 
48ed				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
48ed 48				db WORD_SYS_CORE+52             
48ee 79 49			dw .NUM2STR            
48f0 08				db 7 + 1 
48f1 .. 00			db "STR2NUM",0              
48f9				endm 
# End of macro CWHEAD
48f9			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
48f9			 
48f9			 
48f9			; TODO STR type check to do 
48f9					if DEBUG_FORTH_WORDS_KEY 
48f9						DMARK "S2N" 
48f9 f5				push af  
48fa 3a 0e 49			ld a, (.dmark)  
48fd 32 a6 fd			ld (debug_mark),a  
4900 3a 0f 49			ld a, (.dmark+1)  
4903 32 a7 fd			ld (debug_mark+1),a  
4906 3a 10 49			ld a, (.dmark+2)  
4909 32 a8 fd			ld (debug_mark+2),a  
490c 18 03			jr .pastdmark  
490e ..			.dmark: db "S2N"  
4911 f1			.pastdmark: pop af  
4912			endm  
# End of macro DMARK
4912						CALLMONITOR 
4912 cd aa fd			call debug_vector  
4915				endm  
# End of macro CALLMONITOR
4915					endif 
4915			 
4915					;FORTH_DSP 
4915					FORTH_DSP_VALUE 
4915 cd 1d 22			call macro_forth_dsp_value 
4918				endm 
# End of macro FORTH_DSP_VALUE
4918					;inc hl 
4918			 
4918 eb					ex de, hl 
4919					if DEBUG_FORTH_WORDS 
4919						DMARK "S2a" 
4919 f5				push af  
491a 3a 2e 49			ld a, (.dmark)  
491d 32 a6 fd			ld (debug_mark),a  
4920 3a 2f 49			ld a, (.dmark+1)  
4923 32 a7 fd			ld (debug_mark+1),a  
4926 3a 30 49			ld a, (.dmark+2)  
4929 32 a8 fd			ld (debug_mark+2),a  
492c 18 03			jr .pastdmark  
492e ..			.dmark: db "S2a"  
4931 f1			.pastdmark: pop af  
4932			endm  
# End of macro DMARK
4932						CALLMONITOR 
4932 cd aa fd			call debug_vector  
4935				endm  
# End of macro CALLMONITOR
4935					endif 
4935 cd d8 12				call string_to_uint16 
4938			 
4938					if DEBUG_FORTH_WORDS 
4938						DMARK "S2b" 
4938 f5				push af  
4939 3a 4d 49			ld a, (.dmark)  
493c 32 a6 fd			ld (debug_mark),a  
493f 3a 4e 49			ld a, (.dmark+1)  
4942 32 a7 fd			ld (debug_mark+1),a  
4945 3a 4f 49			ld a, (.dmark+2)  
4948 32 a8 fd			ld (debug_mark+2),a  
494b 18 03			jr .pastdmark  
494d ..			.dmark: db "S2b"  
4950 f1			.pastdmark: pop af  
4951			endm  
# End of macro DMARK
4951						CALLMONITOR 
4951 cd aa fd			call debug_vector  
4954				endm  
# End of macro CALLMONITOR
4954					endif 
4954			;		push hl 
4954					FORTH_DSP_POP 
4954 cd ec 22			call macro_forth_dsp_pop 
4957				endm 
# End of macro FORTH_DSP_POP
4957			;		pop hl 
4957					 
4957					if DEBUG_FORTH_WORDS 
4957						DMARK "S2b" 
4957 f5				push af  
4958 3a 6c 49			ld a, (.dmark)  
495b 32 a6 fd			ld (debug_mark),a  
495e 3a 6d 49			ld a, (.dmark+1)  
4961 32 a7 fd			ld (debug_mark+1),a  
4964 3a 6e 49			ld a, (.dmark+2)  
4967 32 a8 fd			ld (debug_mark+2),a  
496a 18 03			jr .pastdmark  
496c ..			.dmark: db "S2b"  
496f f1			.pastdmark: pop af  
4970			endm  
# End of macro DMARK
4970						CALLMONITOR 
4970 cd aa fd			call debug_vector  
4973				endm  
# End of macro CALLMONITOR
4973					endif 
4973 cd 2f 20				call forth_push_numhl	 
4976			 
4976				 
4976				       NEXTW 
4976 c3 ea 23			jp macro_next 
4979				endm 
# End of macro NEXTW
4979			.NUM2STR: 
4979				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4979 48				db WORD_SYS_CORE+52             
497a 88 49			dw .CONCAT            
497c 08				db 7 + 1 
497d .. 00			db "NUM2STR",0              
4985				endm 
# End of macro CWHEAD
4985			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
4985			 
4985			;		; malloc a string to target 
4985			;		ld hl, 10     ; TODO max string size should be fine 
4985			;		call malloc 
4985			;		push hl    ; save malloc location 
4985			; 
4985			; 
4985			;; TODO check int type 
4985			;		FORTH_DSP_VALUEHL 
4985			;		ld a, l 
4985			;		call DispAToASCII   
4985			;;TODO need to chage above call to dump into string 
4985			; 
4985			; 
4985			 
4985				       NEXTW 
4985 c3 ea 23			jp macro_next 
4988				endm 
# End of macro NEXTW
4988			 
4988			.CONCAT: 
4988				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4988 48				db WORD_SYS_CORE+52             
4989 3b 4a			dw .FIND            
498b 07				db 6 + 1 
498c .. 00			db "CONCAT",0              
4993				endm 
# End of macro CWHEAD
4993			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4993			 
4993			; TODO check string type 
4993			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4993			 
4993					if DEBUG_FORTH_WORDS_KEY 
4993						DMARK "CON" 
4993 f5				push af  
4994 3a a8 49			ld a, (.dmark)  
4997 32 a6 fd			ld (debug_mark),a  
499a 3a a9 49			ld a, (.dmark+1)  
499d 32 a7 fd			ld (debug_mark+1),a  
49a0 3a aa 49			ld a, (.dmark+2)  
49a3 32 a8 fd			ld (debug_mark+2),a  
49a6 18 03			jr .pastdmark  
49a8 ..			.dmark: db "CON"  
49ab f1			.pastdmark: pop af  
49ac			endm  
# End of macro DMARK
49ac						CALLMONITOR 
49ac cd aa fd			call debug_vector  
49af				endm  
# End of macro CALLMONITOR
49af					endif 
49af			 
49af			 
49af					FORTH_DSP_VALUE 
49af cd 1d 22			call macro_forth_dsp_value 
49b2				endm 
# End of macro FORTH_DSP_VALUE
49b2 e5					push hl   ; s2 
49b3			 
49b3					FORTH_DSP_POP 
49b3 cd ec 22			call macro_forth_dsp_pop 
49b6				endm 
# End of macro FORTH_DSP_POP
49b6			 
49b6					FORTH_DSP_VALUE 
49b6 cd 1d 22			call macro_forth_dsp_value 
49b9				endm 
# End of macro FORTH_DSP_VALUE
49b9			 
49b9 e5					push hl   ; s1 
49ba			 
49ba					FORTH_DSP_POP 
49ba cd ec 22			call macro_forth_dsp_pop 
49bd				endm 
# End of macro FORTH_DSP_POP
49bd					 
49bd			 
49bd					; copy s1 
49bd			 
49bd				 
49bd					; save ptr 
49bd e1					pop hl  
49be e5					push hl 
49bf 3e 00				ld a, 0 
49c1 cd 4c 13				call strlent 
49c4					;inc hl    ; zer0 
49c4 06 00				ld b, 0 
49c6 4d					ld c, l 
49c7 e1					pop hl		 
49c8 11 fc f0				ld de, scratch	 
49cb					if DEBUG_FORTH_WORDS 
49cb						DMARK "CO1" 
49cb f5				push af  
49cc 3a e0 49			ld a, (.dmark)  
49cf 32 a6 fd			ld (debug_mark),a  
49d2 3a e1 49			ld a, (.dmark+1)  
49d5 32 a7 fd			ld (debug_mark+1),a  
49d8 3a e2 49			ld a, (.dmark+2)  
49db 32 a8 fd			ld (debug_mark+2),a  
49de 18 03			jr .pastdmark  
49e0 ..			.dmark: db "CO1"  
49e3 f1			.pastdmark: pop af  
49e4			endm  
# End of macro DMARK
49e4						CALLMONITOR 
49e4 cd aa fd			call debug_vector  
49e7				endm  
# End of macro CALLMONITOR
49e7					endif 
49e7 ed b0				ldir 
49e9			 
49e9 e1					pop hl 
49ea e5					push hl 
49eb d5					push de 
49ec			 
49ec			 
49ec 3e 00				ld a, 0 
49ee cd 4c 13				call strlent 
49f1 23					inc hl    ; zer0 
49f2 23					inc hl 
49f3 06 00				ld b, 0 
49f5 4d					ld c, l 
49f6 d1					pop de 
49f7 e1					pop hl		 
49f8					if DEBUG_FORTH_WORDS 
49f8						DMARK "CO2" 
49f8 f5				push af  
49f9 3a 0d 4a			ld a, (.dmark)  
49fc 32 a6 fd			ld (debug_mark),a  
49ff 3a 0e 4a			ld a, (.dmark+1)  
4a02 32 a7 fd			ld (debug_mark+1),a  
4a05 3a 0f 4a			ld a, (.dmark+2)  
4a08 32 a8 fd			ld (debug_mark+2),a  
4a0b 18 03			jr .pastdmark  
4a0d ..			.dmark: db "CO2"  
4a10 f1			.pastdmark: pop af  
4a11			endm  
# End of macro DMARK
4a11						CALLMONITOR 
4a11 cd aa fd			call debug_vector  
4a14				endm  
# End of macro CALLMONITOR
4a14					endif 
4a14 ed b0				ldir 
4a16			 
4a16			 
4a16			 
4a16 21 fc f0				ld hl, scratch 
4a19					if DEBUG_FORTH_WORDS 
4a19						DMARK "CO5" 
4a19 f5				push af  
4a1a 3a 2e 4a			ld a, (.dmark)  
4a1d 32 a6 fd			ld (debug_mark),a  
4a20 3a 2f 4a			ld a, (.dmark+1)  
4a23 32 a7 fd			ld (debug_mark+1),a  
4a26 3a 30 4a			ld a, (.dmark+2)  
4a29 32 a8 fd			ld (debug_mark+2),a  
4a2c 18 03			jr .pastdmark  
4a2e ..			.dmark: db "CO5"  
4a31 f1			.pastdmark: pop af  
4a32			endm  
# End of macro DMARK
4a32						CALLMONITOR 
4a32 cd aa fd			call debug_vector  
4a35				endm  
# End of macro CALLMONITOR
4a35					endif 
4a35			 
4a35 cd 9d 20				call forth_push_str 
4a38			 
4a38			 
4a38			 
4a38			 
4a38				       NEXTW 
4a38 c3 ea 23			jp macro_next 
4a3b				endm 
# End of macro NEXTW
4a3b			 
4a3b			 
4a3b			.FIND: 
4a3b				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4a3b 4b				db WORD_SYS_CORE+55             
4a3c f9 4a			dw .LEN            
4a3e 05				db 4 + 1 
4a3f .. 00			db "FIND",0              
4a44				endm 
# End of macro CWHEAD
4a44			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4a44			 
4a44					if DEBUG_FORTH_WORDS_KEY 
4a44						DMARK "FND" 
4a44 f5				push af  
4a45 3a 59 4a			ld a, (.dmark)  
4a48 32 a6 fd			ld (debug_mark),a  
4a4b 3a 5a 4a			ld a, (.dmark+1)  
4a4e 32 a7 fd			ld (debug_mark+1),a  
4a51 3a 5b 4a			ld a, (.dmark+2)  
4a54 32 a8 fd			ld (debug_mark+2),a  
4a57 18 03			jr .pastdmark  
4a59 ..			.dmark: db "FND"  
4a5c f1			.pastdmark: pop af  
4a5d			endm  
# End of macro DMARK
4a5d						CALLMONITOR 
4a5d cd aa fd			call debug_vector  
4a60				endm  
# End of macro CALLMONITOR
4a60					endif 
4a60			 
4a60			; TODO check string type 
4a60					FORTH_DSP_VALUE 
4a60 cd 1d 22			call macro_forth_dsp_value 
4a63				endm 
# End of macro FORTH_DSP_VALUE
4a63			 
4a63 e5					push hl    
4a64 7e					ld a,(hl)    ; char to find   
4a65			; TODO change char to substr 
4a65			 
4a65 f5					push af 
4a66					 
4a66			 
4a66			 
4a66					if DEBUG_FORTH_WORDS 
4a66						DMARK "FN1" 
4a66 f5				push af  
4a67 3a 7b 4a			ld a, (.dmark)  
4a6a 32 a6 fd			ld (debug_mark),a  
4a6d 3a 7c 4a			ld a, (.dmark+1)  
4a70 32 a7 fd			ld (debug_mark+1),a  
4a73 3a 7d 4a			ld a, (.dmark+2)  
4a76 32 a8 fd			ld (debug_mark+2),a  
4a79 18 03			jr .pastdmark  
4a7b ..			.dmark: db "FN1"  
4a7e f1			.pastdmark: pop af  
4a7f			endm  
# End of macro DMARK
4a7f						CALLMONITOR 
4a7f cd aa fd			call debug_vector  
4a82				endm  
# End of macro CALLMONITOR
4a82					endif 
4a82			 
4a82					FORTH_DSP_POP 
4a82 cd ec 22			call macro_forth_dsp_pop 
4a85				endm 
# End of macro FORTH_DSP_POP
4a85			 
4a85					; string to search 
4a85			 
4a85					FORTH_DSP_VALUE 
4a85 cd 1d 22			call macro_forth_dsp_value 
4a88				endm 
# End of macro FORTH_DSP_VALUE
4a88			 
4a88 d1					pop de  ; d is char to find  
4a89			 
4a89					if DEBUG_FORTH_WORDS 
4a89						DMARK "FN2" 
4a89 f5				push af  
4a8a 3a 9e 4a			ld a, (.dmark)  
4a8d 32 a6 fd			ld (debug_mark),a  
4a90 3a 9f 4a			ld a, (.dmark+1)  
4a93 32 a7 fd			ld (debug_mark+1),a  
4a96 3a a0 4a			ld a, (.dmark+2)  
4a99 32 a8 fd			ld (debug_mark+2),a  
4a9c 18 03			jr .pastdmark  
4a9e ..			.dmark: db "FN2"  
4aa1 f1			.pastdmark: pop af  
4aa2			endm  
# End of macro DMARK
4aa2						CALLMONITOR 
4aa2 cd aa fd			call debug_vector  
4aa5				endm  
# End of macro CALLMONITOR
4aa5					endif 
4aa5					 
4aa5 01 00 00				ld bc, 0 
4aa8 7e			.findchar:      ld a,(hl) 
4aa9 fe 00				cp 0   		 
4aab 28 27				jr z, .finddone     
4aad ba					cp d 
4aae 28 20				jr z, .foundchar 
4ab0 03					inc bc 
4ab1 23					inc hl 
4ab2					if DEBUG_FORTH_WORDS 
4ab2						DMARK "FN3" 
4ab2 f5				push af  
4ab3 3a c7 4a			ld a, (.dmark)  
4ab6 32 a6 fd			ld (debug_mark),a  
4ab9 3a c8 4a			ld a, (.dmark+1)  
4abc 32 a7 fd			ld (debug_mark+1),a  
4abf 3a c9 4a			ld a, (.dmark+2)  
4ac2 32 a8 fd			ld (debug_mark+2),a  
4ac5 18 03			jr .pastdmark  
4ac7 ..			.dmark: db "FN3"  
4aca f1			.pastdmark: pop af  
4acb			endm  
# End of macro DMARK
4acb						CALLMONITOR 
4acb cd aa fd			call debug_vector  
4ace				endm  
# End of macro CALLMONITOR
4ace					endif 
4ace 18 d8				jr .findchar 
4ad0			 
4ad0			 
4ad0 c5			.foundchar:	push bc 
4ad1 e1					pop hl 
4ad2 18 03				jr .findexit 
4ad4			 
4ad4			 
4ad4							 
4ad4			 
4ad4			.finddone:     ; got to end of string with no find 
4ad4 21 00 00				ld hl, 0 
4ad7			.findexit: 
4ad7			 
4ad7					if DEBUG_FORTH_WORDS 
4ad7						DMARK "FNd" 
4ad7 f5				push af  
4ad8 3a ec 4a			ld a, (.dmark)  
4adb 32 a6 fd			ld (debug_mark),a  
4ade 3a ed 4a			ld a, (.dmark+1)  
4ae1 32 a7 fd			ld (debug_mark+1),a  
4ae4 3a ee 4a			ld a, (.dmark+2)  
4ae7 32 a8 fd			ld (debug_mark+2),a  
4aea 18 03			jr .pastdmark  
4aec ..			.dmark: db "FNd"  
4aef f1			.pastdmark: pop af  
4af0			endm  
# End of macro DMARK
4af0						CALLMONITOR 
4af0 cd aa fd			call debug_vector  
4af3				endm  
# End of macro CALLMONITOR
4af3					endif 
4af3 cd 2f 20			call forth_push_numhl 
4af6			 
4af6				       NEXTW 
4af6 c3 ea 23			jp macro_next 
4af9				endm 
# End of macro NEXTW
4af9			 
4af9			.LEN: 
4af9				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4af9 4c				db WORD_SYS_CORE+56             
4afa 63 4b			dw .ASC            
4afc 06				db 5 + 1 
4afd .. 00			db "COUNT",0              
4b03				endm 
# End of macro CWHEAD
4b03			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4b03			 
4b03					if DEBUG_FORTH_WORDS_KEY 
4b03						DMARK "CNT" 
4b03 f5				push af  
4b04 3a 18 4b			ld a, (.dmark)  
4b07 32 a6 fd			ld (debug_mark),a  
4b0a 3a 19 4b			ld a, (.dmark+1)  
4b0d 32 a7 fd			ld (debug_mark+1),a  
4b10 3a 1a 4b			ld a, (.dmark+2)  
4b13 32 a8 fd			ld (debug_mark+2),a  
4b16 18 03			jr .pastdmark  
4b18 ..			.dmark: db "CNT"  
4b1b f1			.pastdmark: pop af  
4b1c			endm  
# End of macro DMARK
4b1c						CALLMONITOR 
4b1c cd aa fd			call debug_vector  
4b1f				endm  
# End of macro CALLMONITOR
4b1f					endif 
4b1f			; TODO check string type 
4b1f					FORTH_DSP_VALUE 
4b1f cd 1d 22			call macro_forth_dsp_value 
4b22				endm 
# End of macro FORTH_DSP_VALUE
4b22			 
4b22			 
4b22					if DEBUG_FORTH_WORDS 
4b22						DMARK "CN?" 
4b22 f5				push af  
4b23 3a 37 4b			ld a, (.dmark)  
4b26 32 a6 fd			ld (debug_mark),a  
4b29 3a 38 4b			ld a, (.dmark+1)  
4b2c 32 a7 fd			ld (debug_mark+1),a  
4b2f 3a 39 4b			ld a, (.dmark+2)  
4b32 32 a8 fd			ld (debug_mark+2),a  
4b35 18 03			jr .pastdmark  
4b37 ..			.dmark: db "CN?"  
4b3a f1			.pastdmark: pop af  
4b3b			endm  
# End of macro DMARK
4b3b						CALLMONITOR 
4b3b cd aa fd			call debug_vector  
4b3e				endm  
# End of macro CALLMONITOR
4b3e					endif 
4b3e cd 41 13				call strlenz 
4b41					if DEBUG_FORTH_WORDS 
4b41						DMARK "CNl" 
4b41 f5				push af  
4b42 3a 56 4b			ld a, (.dmark)  
4b45 32 a6 fd			ld (debug_mark),a  
4b48 3a 57 4b			ld a, (.dmark+1)  
4b4b 32 a7 fd			ld (debug_mark+1),a  
4b4e 3a 58 4b			ld a, (.dmark+2)  
4b51 32 a8 fd			ld (debug_mark+2),a  
4b54 18 03			jr .pastdmark  
4b56 ..			.dmark: db "CNl"  
4b59 f1			.pastdmark: pop af  
4b5a			endm  
# End of macro DMARK
4b5a						CALLMONITOR 
4b5a cd aa fd			call debug_vector  
4b5d				endm  
# End of macro CALLMONITOR
4b5d					endif 
4b5d			 
4b5d cd 2f 20				call forth_push_numhl 
4b60			 
4b60			 
4b60			 
4b60				       NEXTW 
4b60 c3 ea 23			jp macro_next 
4b63				endm 
# End of macro NEXTW
4b63			.ASC: 
4b63				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4b63 4d				db WORD_SYS_CORE+57             
4b64 d1 4b			dw .CHR            
4b66 04				db 3 + 1 
4b67 .. 00			db "ASC",0              
4b6b				endm 
# End of macro CWHEAD
4b6b			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4b6b					if DEBUG_FORTH_WORDS_KEY 
4b6b						DMARK "ASC" 
4b6b f5				push af  
4b6c 3a 80 4b			ld a, (.dmark)  
4b6f 32 a6 fd			ld (debug_mark),a  
4b72 3a 81 4b			ld a, (.dmark+1)  
4b75 32 a7 fd			ld (debug_mark+1),a  
4b78 3a 82 4b			ld a, (.dmark+2)  
4b7b 32 a8 fd			ld (debug_mark+2),a  
4b7e 18 03			jr .pastdmark  
4b80 ..			.dmark: db "ASC"  
4b83 f1			.pastdmark: pop af  
4b84			endm  
# End of macro DMARK
4b84						CALLMONITOR 
4b84 cd aa fd			call debug_vector  
4b87				endm  
# End of macro CALLMONITOR
4b87					endif 
4b87					FORTH_DSP_VALUE 
4b87 cd 1d 22			call macro_forth_dsp_value 
4b8a				endm 
# End of macro FORTH_DSP_VALUE
4b8a					;v5 FORTH_DSP_VALUE 
4b8a			;		inc hl      ; now at start of numeric as string 
4b8a			 
4b8a e5					push hl 
4b8b			 
4b8b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b8b cd ec 22			call macro_forth_dsp_pop 
4b8e				endm 
# End of macro FORTH_DSP_POP
4b8e			 
4b8e e1					pop hl 
4b8f			 
4b8f					if DEBUG_FORTH_WORDS 
4b8f						DMARK "AS1" 
4b8f f5				push af  
4b90 3a a4 4b			ld a, (.dmark)  
4b93 32 a6 fd			ld (debug_mark),a  
4b96 3a a5 4b			ld a, (.dmark+1)  
4b99 32 a7 fd			ld (debug_mark+1),a  
4b9c 3a a6 4b			ld a, (.dmark+2)  
4b9f 32 a8 fd			ld (debug_mark+2),a  
4ba2 18 03			jr .pastdmark  
4ba4 ..			.dmark: db "AS1"  
4ba7 f1			.pastdmark: pop af  
4ba8			endm  
# End of macro DMARK
4ba8						CALLMONITOR 
4ba8 cd aa fd			call debug_vector  
4bab				endm  
# End of macro CALLMONITOR
4bab					endif 
4bab					; push the content of a onto the stack as a value 
4bab			 
4bab 7e					ld a,(hl)   ; get char 
4bac 26 00				ld h,0 
4bae 6f					ld l,a 
4baf					if DEBUG_FORTH_WORDS 
4baf						DMARK "AS2" 
4baf f5				push af  
4bb0 3a c4 4b			ld a, (.dmark)  
4bb3 32 a6 fd			ld (debug_mark),a  
4bb6 3a c5 4b			ld a, (.dmark+1)  
4bb9 32 a7 fd			ld (debug_mark+1),a  
4bbc 3a c6 4b			ld a, (.dmark+2)  
4bbf 32 a8 fd			ld (debug_mark+2),a  
4bc2 18 03			jr .pastdmark  
4bc4 ..			.dmark: db "AS2"  
4bc7 f1			.pastdmark: pop af  
4bc8			endm  
# End of macro DMARK
4bc8						CALLMONITOR 
4bc8 cd aa fd			call debug_vector  
4bcb				endm  
# End of macro CALLMONITOR
4bcb					endif 
4bcb cd 2f 20				call forth_push_numhl 
4bce			 
4bce				       NEXTW 
4bce c3 ea 23			jp macro_next 
4bd1				endm 
# End of macro NEXTW
4bd1			 
4bd1			.CHR: 
4bd1				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4bd1 4d				db WORD_SYS_CORE+57             
4bd2 0d 4c			dw .ENDSTR            
4bd4 04				db 3 + 1 
4bd5 .. 00			db "CHR",0              
4bd9				endm 
# End of macro CWHEAD
4bd9			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4bd9					if DEBUG_FORTH_WORDS_KEY 
4bd9						DMARK "CHR" 
4bd9 f5				push af  
4bda 3a ee 4b			ld a, (.dmark)  
4bdd 32 a6 fd			ld (debug_mark),a  
4be0 3a ef 4b			ld a, (.dmark+1)  
4be3 32 a7 fd			ld (debug_mark+1),a  
4be6 3a f0 4b			ld a, (.dmark+2)  
4be9 32 a8 fd			ld (debug_mark+2),a  
4bec 18 03			jr .pastdmark  
4bee ..			.dmark: db "CHR"  
4bf1 f1			.pastdmark: pop af  
4bf2			endm  
# End of macro DMARK
4bf2						CALLMONITOR 
4bf2 cd aa fd			call debug_vector  
4bf5				endm  
# End of macro CALLMONITOR
4bf5					endif 
4bf5					FORTH_DSP_VALUEHL 
4bf5 cd 34 22			call macro_dsp_valuehl 
4bf8				endm 
# End of macro FORTH_DSP_VALUEHL
4bf8			 
4bf8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bf8 cd ec 22			call macro_forth_dsp_pop 
4bfb				endm 
# End of macro FORTH_DSP_POP
4bfb			 
4bfb					; save asci byte as a zero term string and push string 
4bfb			 
4bfb 7d					ld a,l 
4bfc 32 fc f0				ld (scratch), a 
4bff			 
4bff 3e 00				ld a, 0 
4c01 32 fd f0				ld (scratch+1), a 
4c04			 
4c04 21 fc f0				ld hl, scratch 
4c07 cd 9d 20				call forth_push_str 
4c0a			 
4c0a			 
4c0a				       NEXTW 
4c0a c3 ea 23			jp macro_next 
4c0d				endm 
# End of macro NEXTW
4c0d			 
4c0d			 
4c0d			 
4c0d			 
4c0d			.ENDSTR: 
4c0d			; eof 
4c0d			 
# End of file forth_words_str.asm
4c0d			include "forth_words_key.asm" 
4c0d			 
4c0d			; | ## Keyboard Words 
4c0d			 
4c0d			.KEY: 
4c0d				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4c0d 3e				db WORD_SYS_CORE+42             
4c0e 3d 4c			dw .WAITK            
4c10 04				db 3 + 1 
4c11 .. 00			db "KEY",0              
4c15				endm 
# End of macro CWHEAD
4c15			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
4c15			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4c15			; | | Can use something like this to process: 
4c15			; | | > repeat active . key ?dup if emit then #1 until  
4c15			 
4c15					if DEBUG_FORTH_WORDS_KEY 
4c15						DMARK "KEY" 
4c15 f5				push af  
4c16 3a 2a 4c			ld a, (.dmark)  
4c19 32 a6 fd			ld (debug_mark),a  
4c1c 3a 2b 4c			ld a, (.dmark+1)  
4c1f 32 a7 fd			ld (debug_mark+1),a  
4c22 3a 2c 4c			ld a, (.dmark+2)  
4c25 32 a8 fd			ld (debug_mark+2),a  
4c28 18 03			jr .pastdmark  
4c2a ..			.dmark: db "KEY"  
4c2d f1			.pastdmark: pop af  
4c2e			endm  
# End of macro DMARK
4c2e						CALLMONITOR 
4c2e cd aa fd			call debug_vector  
4c31				endm  
# End of macro CALLMONITOR
4c31					endif 
4c31			; TODO currently waits 
4c31 cd d0 72				call cin 
4c34					;call cin_wait 
4c34 6f					ld l, a 
4c35 26 00				ld h, 0 
4c37 cd 2f 20				call forth_push_numhl 
4c3a					NEXTW 
4c3a c3 ea 23			jp macro_next 
4c3d				endm 
# End of macro NEXTW
4c3d			.WAITK: 
4c3d				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4c3d 3f				db WORD_SYS_CORE+43             
4c3e 6f 4c			dw .ACCEPT            
4c40 06				db 5 + 1 
4c41 .. 00			db "WAITK",0              
4c47				endm 
# End of macro CWHEAD
4c47			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4c47					if DEBUG_FORTH_WORDS_KEY 
4c47						DMARK "WAI" 
4c47 f5				push af  
4c48 3a 5c 4c			ld a, (.dmark)  
4c4b 32 a6 fd			ld (debug_mark),a  
4c4e 3a 5d 4c			ld a, (.dmark+1)  
4c51 32 a7 fd			ld (debug_mark+1),a  
4c54 3a 5e 4c			ld a, (.dmark+2)  
4c57 32 a8 fd			ld (debug_mark+2),a  
4c5a 18 03			jr .pastdmark  
4c5c ..			.dmark: db "WAI"  
4c5f f1			.pastdmark: pop af  
4c60			endm  
# End of macro DMARK
4c60						CALLMONITOR 
4c60 cd aa fd			call debug_vector  
4c63				endm  
# End of macro CALLMONITOR
4c63					endif 
4c63 cd bf 72				call cin_wait 
4c66 6f					ld l, a 
4c67 26 00				ld h, 0 
4c69 cd 2f 20				call forth_push_numhl 
4c6c					NEXTW 
4c6c c3 ea 23			jp macro_next 
4c6f				endm 
# End of macro NEXTW
4c6f			.ACCEPT: 
4c6f				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4c6f 40				db WORD_SYS_CORE+44             
4c70 cd 4c			dw .EDIT            
4c72 07				db 6 + 1 
4c73 .. 00			db "ACCEPT",0              
4c7a				endm 
# End of macro CWHEAD
4c7a			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4c7a					; TODO crashes on push 
4c7a					if DEBUG_FORTH_WORDS_KEY 
4c7a						DMARK "ACC" 
4c7a f5				push af  
4c7b 3a 8f 4c			ld a, (.dmark)  
4c7e 32 a6 fd			ld (debug_mark),a  
4c81 3a 90 4c			ld a, (.dmark+1)  
4c84 32 a7 fd			ld (debug_mark+1),a  
4c87 3a 91 4c			ld a, (.dmark+2)  
4c8a 32 a8 fd			ld (debug_mark+2),a  
4c8d 18 03			jr .pastdmark  
4c8f ..			.dmark: db "ACC"  
4c92 f1			.pastdmark: pop af  
4c93			endm  
# End of macro DMARK
4c93						CALLMONITOR 
4c93 cd aa fd			call debug_vector  
4c96				endm  
# End of macro CALLMONITOR
4c96					endif 
4c96 21 fa f2				ld hl, os_input 
4c99 3e 00				ld a, 0 
4c9b 77					ld (hl),a 
4c9c 3a 99 f9				ld a,(f_cursor_ptr) 
4c9f 16 64				ld d, 100 
4ca1 0e 00				ld c, 0 
4ca3 1e 28				ld e, 40 
4ca5 cd 08 10				call input_str 
4ca8					; TODO perhaps do a type check and wrap in quotes if not a number 
4ca8 21 fa f2				ld hl, os_input 
4cab					if DEBUG_FORTH_WORDS 
4cab						DMARK "AC1" 
4cab f5				push af  
4cac 3a c0 4c			ld a, (.dmark)  
4caf 32 a6 fd			ld (debug_mark),a  
4cb2 3a c1 4c			ld a, (.dmark+1)  
4cb5 32 a7 fd			ld (debug_mark+1),a  
4cb8 3a c2 4c			ld a, (.dmark+2)  
4cbb 32 a8 fd			ld (debug_mark+2),a  
4cbe 18 03			jr .pastdmark  
4cc0 ..			.dmark: db "AC1"  
4cc3 f1			.pastdmark: pop af  
4cc4			endm  
# End of macro DMARK
4cc4						CALLMONITOR 
4cc4 cd aa fd			call debug_vector  
4cc7				endm  
# End of macro CALLMONITOR
4cc7					endif 
4cc7 cd 9d 20				call forth_push_str 
4cca					NEXTW 
4cca c3 ea 23			jp macro_next 
4ccd				endm 
# End of macro NEXTW
4ccd			 
4ccd			.EDIT: 
4ccd				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4ccd 40				db WORD_SYS_CORE+44             
4cce 6f 4d			dw .DEDIT            
4cd0 05				db 4 + 1 
4cd1 .. 00			db "EDIT",0              
4cd6				endm 
# End of macro CWHEAD
4cd6			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4cd6			 
4cd6					; TODO does not copy from stack 
4cd6					if DEBUG_FORTH_WORDS_KEY 
4cd6						DMARK "EDT" 
4cd6 f5				push af  
4cd7 3a eb 4c			ld a, (.dmark)  
4cda 32 a6 fd			ld (debug_mark),a  
4cdd 3a ec 4c			ld a, (.dmark+1)  
4ce0 32 a7 fd			ld (debug_mark+1),a  
4ce3 3a ed 4c			ld a, (.dmark+2)  
4ce6 32 a8 fd			ld (debug_mark+2),a  
4ce9 18 03			jr .pastdmark  
4ceb ..			.dmark: db "EDT"  
4cee f1			.pastdmark: pop af  
4cef			endm  
# End of macro DMARK
4cef						CALLMONITOR 
4cef cd aa fd			call debug_vector  
4cf2				endm  
# End of macro CALLMONITOR
4cf2					endif 
4cf2			 
4cf2					;FORTH_DSP 
4cf2					FORTH_DSP_VALUEHL 
4cf2 cd 34 22			call macro_dsp_valuehl 
4cf5				endm 
# End of macro FORTH_DSP_VALUEHL
4cf5			;		inc hl    ; TODO do type check 
4cf5			 
4cf5			;		call get_word_hl 
4cf5 e5					push hl 
4cf6					if DEBUG_FORTH_WORDS 
4cf6						DMARK "EDp" 
4cf6 f5				push af  
4cf7 3a 0b 4d			ld a, (.dmark)  
4cfa 32 a6 fd			ld (debug_mark),a  
4cfd 3a 0c 4d			ld a, (.dmark+1)  
4d00 32 a7 fd			ld (debug_mark+1),a  
4d03 3a 0d 4d			ld a, (.dmark+2)  
4d06 32 a8 fd			ld (debug_mark+2),a  
4d09 18 03			jr .pastdmark  
4d0b ..			.dmark: db "EDp"  
4d0e f1			.pastdmark: pop af  
4d0f			endm  
# End of macro DMARK
4d0f						CALLMONITOR 
4d0f cd aa fd			call debug_vector  
4d12				endm  
# End of macro CALLMONITOR
4d12					endif 
4d12				;	ld a, 0 
4d12 cd 41 13				call strlenz 
4d15 23					inc hl 
4d16			 
4d16 06 00				ld b, 0 
4d18 4d					ld c, l 
4d19			 
4d19 e1					pop hl 
4d1a 11 fa f2				ld de, os_input 
4d1d					if DEBUG_FORTH_WORDS_KEY 
4d1d						DMARK "EDc" 
4d1d f5				push af  
4d1e 3a 32 4d			ld a, (.dmark)  
4d21 32 a6 fd			ld (debug_mark),a  
4d24 3a 33 4d			ld a, (.dmark+1)  
4d27 32 a7 fd			ld (debug_mark+1),a  
4d2a 3a 34 4d			ld a, (.dmark+2)  
4d2d 32 a8 fd			ld (debug_mark+2),a  
4d30 18 03			jr .pastdmark  
4d32 ..			.dmark: db "EDc"  
4d35 f1			.pastdmark: pop af  
4d36			endm  
# End of macro DMARK
4d36						CALLMONITOR 
4d36 cd aa fd			call debug_vector  
4d39				endm  
# End of macro CALLMONITOR
4d39					endif 
4d39 ed b0				ldir 
4d3b			 
4d3b			 
4d3b 21 fa f2				ld hl, os_input 
4d3e					;ld a, 0 
4d3e					;ld (hl),a 
4d3e 3a 99 f9				ld a,(f_cursor_ptr) 
4d41 16 64				ld d, 100 
4d43 0e 00				ld c, 0 
4d45 1e 28				ld e, 40 
4d47 cd 08 10				call input_str 
4d4a					; TODO perhaps do a type check and wrap in quotes if not a number 
4d4a 21 fa f2				ld hl, os_input 
4d4d					if DEBUG_FORTH_WORDS 
4d4d						DMARK "ED1" 
4d4d f5				push af  
4d4e 3a 62 4d			ld a, (.dmark)  
4d51 32 a6 fd			ld (debug_mark),a  
4d54 3a 63 4d			ld a, (.dmark+1)  
4d57 32 a7 fd			ld (debug_mark+1),a  
4d5a 3a 64 4d			ld a, (.dmark+2)  
4d5d 32 a8 fd			ld (debug_mark+2),a  
4d60 18 03			jr .pastdmark  
4d62 ..			.dmark: db "ED1"  
4d65 f1			.pastdmark: pop af  
4d66			endm  
# End of macro DMARK
4d66						CALLMONITOR 
4d66 cd aa fd			call debug_vector  
4d69				endm  
# End of macro CALLMONITOR
4d69					endif 
4d69 cd 9d 20				call forth_push_str 
4d6c					NEXTW 
4d6c c3 ea 23			jp macro_next 
4d6f				endm 
# End of macro NEXTW
4d6f			 
4d6f			.DEDIT: 
4d6f				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4d6f 40				db WORD_SYS_CORE+44             
4d70 d1 4d			dw .ENDKEY            
4d72 06				db 5 + 1 
4d73 .. 00			db "DEDIT",0              
4d79				endm 
# End of macro CWHEAD
4d79			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4d79			 
4d79					; TODO does not copy from stack 
4d79					if DEBUG_FORTH_WORDS_KEY 
4d79						DMARK "DED" 
4d79 f5				push af  
4d7a 3a 8e 4d			ld a, (.dmark)  
4d7d 32 a6 fd			ld (debug_mark),a  
4d80 3a 8f 4d			ld a, (.dmark+1)  
4d83 32 a7 fd			ld (debug_mark+1),a  
4d86 3a 90 4d			ld a, (.dmark+2)  
4d89 32 a8 fd			ld (debug_mark+2),a  
4d8c 18 03			jr .pastdmark  
4d8e ..			.dmark: db "DED"  
4d91 f1			.pastdmark: pop af  
4d92			endm  
# End of macro DMARK
4d92						CALLMONITOR 
4d92 cd aa fd			call debug_vector  
4d95				endm  
# End of macro CALLMONITOR
4d95					endif 
4d95			 
4d95					;FORTH_DSP 
4d95					FORTH_DSP_VALUEHL 
4d95 cd 34 22			call macro_dsp_valuehl 
4d98				endm 
# End of macro FORTH_DSP_VALUEHL
4d98			;		inc hl    ; TODO do type check 
4d98			 
4d98			;		call get_word_hl 
4d98 e5					push hl 
4d99 e5					push hl 
4d9a					FORTH_DSP_POP 
4d9a cd ec 22			call macro_forth_dsp_pop 
4d9d				endm 
# End of macro FORTH_DSP_POP
4d9d e1					pop hl 
4d9e					if DEBUG_FORTH_WORDS 
4d9e						DMARK "EDp" 
4d9e f5				push af  
4d9f 3a b3 4d			ld a, (.dmark)  
4da2 32 a6 fd			ld (debug_mark),a  
4da5 3a b4 4d			ld a, (.dmark+1)  
4da8 32 a7 fd			ld (debug_mark+1),a  
4dab 3a b5 4d			ld a, (.dmark+2)  
4dae 32 a8 fd			ld (debug_mark+2),a  
4db1 18 03			jr .pastdmark  
4db3 ..			.dmark: db "EDp"  
4db6 f1			.pastdmark: pop af  
4db7			endm  
# End of macro DMARK
4db7						CALLMONITOR 
4db7 cd aa fd			call debug_vector  
4dba				endm  
# End of macro CALLMONITOR
4dba					endif 
4dba				;	ld a, 0 
4dba cd 41 13				call strlenz 
4dbd 23					inc hl 
4dbe			 
4dbe 06 00				ld b, 0 
4dc0 4d					ld c, l 
4dc1			 
4dc1 e1					pop hl 
4dc2			 
4dc2					;ld a, 0 
4dc2					;ld (hl),a 
4dc2 3a 99 f9				ld a,(f_cursor_ptr) 
4dc5 16 64				ld d, 100 
4dc7 0e 00				ld c, 0 
4dc9 1e 28				ld e, 40 
4dcb cd 08 10				call input_str 
4dce					; TODO perhaps do a type check and wrap in quotes if not a number 
4dce					NEXTW 
4dce c3 ea 23			jp macro_next 
4dd1				endm 
# End of macro NEXTW
4dd1			 
4dd1			 
4dd1			.ENDKEY: 
4dd1			; eof 
4dd1			 
# End of file forth_words_key.asm
4dd1			include "forth_words_const.asm" 
4dd1			 
4dd1			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4dd1			 
4dd1			 
4dd1			.SPITIME: 
4dd1				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4dd1 77				db WORD_SYS_CORE+99             
4dd2 e6 4d			dw .VA            
4dd4 08				db 7 + 1 
4dd5 .. 00			db "SPITIME",0              
4ddd				endm 
# End of macro CWHEAD
4ddd			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
4ddd			; 
4ddd			; | | If using BANK devices then leave as is. 
4ddd			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
4ddd			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
4ddd			 
4ddd 21 9f f9				ld hl, spi_clktime  
4de0 cd 2f 20				call forth_push_numhl 
4de3			 
4de3					NEXTW 
4de3 c3 ea 23			jp macro_next 
4de6				endm 
# End of macro NEXTW
4de6			 
4de6			 
4de6			.VA: 
4de6				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4de6 77				db WORD_SYS_CORE+99             
4de7 f6 4d			dw .SYMBOL            
4de9 03				db 2 + 1 
4dea .. 00			db "VA",0              
4ded				endm 
# End of macro CWHEAD
4ded			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
4ded 21 63 f9				ld hl, cli_var_array 
4df0 cd 2f 20				call forth_push_numhl 
4df3			 
4df3					NEXTW 
4df3 c3 ea 23			jp macro_next 
4df6				endm 
# End of macro NEXTW
4df6			 
4df6			.SYMBOL: 
4df6				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4df6 77				db WORD_SYS_CORE+99             
4df7 00 4f			dw .ENDCONST            
4df9 07				db 6 + 1 
4dfa .. 00			db "SYMBOL",0              
4e01				endm 
# End of macro CWHEAD
4e01			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4e01			; | 
4e01			; | | The value is the number reference and the final address is pushed to stack 
4e01			 
4e01			; | | ``` 
4e01			; | | dw sym_table 
4e01			; | | dw nmi_vector 
4e01			; | | dw cli_autodisplay 
4e01			; | | dw cli_data_sp 
4e01			; | | dw cli_data_stack 
4e01			; | | dw cli_loop_sp 
4e01			; | | dw cli_loop_stack 
4e01			; | | dw cli_var_array 
4e01			; | | dw cursor_col 
4e01			; | | dw cursor_ptr 
4e01			; | | ; 10 
4e01			; | | dw cursor_row 
4e01			; | | dw debug_mark 
4e01			; | | dw display_fb0 
4e01			; | | dw display_fb1 
4e01			; | | dw display_fb2 
4e01			; | | dw display_fb3 
4e01			; | | dw display_fb_active 
4e01			; | | dw execscratch 
4e01			; | | dw f_cursor_ptr 
4e01			; | | dw hardware_word 
4e01			; | | ;20 
4e01			; | | dw input_at_cursor 
4e01			; | | dw input_at_pos 
4e01			; | | dw input_cur_flash 
4e01			; | | dw input_cur_onoff 
4e01			; | | dw input_cursor 
4e01			; | | dw input_display_size 
4e01			; | | dw input_len 
4e01			; | | dw input_ptr 
4e01			; | | dw input_size 
4e01			; | | dw input_start 
4e01			; | | ; 30 
4e01			; | | dw input_str 
4e01			; | | dw input_under_cursor 
4e01			; | | dw os_cli_cmd 
4e01			; | | dw os_cur_ptr 
4e01			; | | dw os_current_i 
4e01			; | | dw os_input 
4e01			; | | dw os_last_cmd 
4e01			; | | dw os_last_new_uword 
4e01			; | | dw debug_vector 
4e01			; | | dw os_view_hl 
4e01			; | | ;40 
4e01			; | | dw os_word_scratch 
4e01			; | | dw portbctl 
4e01			; | | dw portbdata 
4e01			; | | dw spi_cartdev 
4e01			; | | dw spi_cartdev2 
4e01			; | | dw spi_clktime 
4e01			; | | dw spi_device 
4e01			; | | dw spi_device_id 
4e01			; | | dw spi_portbyte 
4e01			; | | dw stackstore 
4e01			; | | ; 50 
4e01			; | | if STORAGE_SE 
4e01			; | | dw storage_actl 
4e01			; | | dw storage_adata 
4e01			; | | else 
4e01			; | | dw 0 
4e01			; | | dw 0 
4e01			; | | endif 
4e01			; | | dw storage_append 
4e01			; | | if STORAGE_SE 
4e01			; | | dw storage_bctl 
4e01			; | | else 
4e01			; | | dw 0 
4e01			; | | endif 
4e01			; | | dw store_bank_active 
4e01			; | | dw store_filecache 
4e01			; | | dw store_longread 
4e01			; | | dw store_openaddr 
4e01			; | | dw store_openext 
4e01			; | | dw store_openmaxext 
4e01			; | | ; 60 
4e01			; | | dw store_page 
4e01			; | | dw store_readbuf 
4e01			; | | dw store_readcont 
4e01			; | | dw store_readptr 
4e01			; | | dw store_tmpext 
4e01			; | | dw store_tmpid 
4e01			; | | dw store_tmppageid 
4e01			; | | dw malloc 
4e01			; | | dw free 
4e01			; | | dw cin 
4e01			; | | ; 70 
4e01			; | | dw cin_wait 
4e01			; | | dw forth_push_numhl 
4e01			; | | dw forth_push_str 
4e01			; | | ``` 
4e01			 
4e01					if DEBUG_FORTH_WORDS_KEY 
4e01						DMARK "SYM" 
4e01 f5				push af  
4e02 3a 16 4e			ld a, (.dmark)  
4e05 32 a6 fd			ld (debug_mark),a  
4e08 3a 17 4e			ld a, (.dmark+1)  
4e0b 32 a7 fd			ld (debug_mark+1),a  
4e0e 3a 18 4e			ld a, (.dmark+2)  
4e11 32 a8 fd			ld (debug_mark+2),a  
4e14 18 03			jr .pastdmark  
4e16 ..			.dmark: db "SYM"  
4e19 f1			.pastdmark: pop af  
4e1a			endm  
# End of macro DMARK
4e1a						CALLMONITOR 
4e1a cd aa fd			call debug_vector  
4e1d				endm  
# End of macro CALLMONITOR
4e1d					endif 
4e1d			 
4e1d					FORTH_DSP_VALUEHL 
4e1d cd 34 22			call macro_dsp_valuehl 
4e20				endm 
# End of macro FORTH_DSP_VALUEHL
4e20			 
4e20 7d					ld a, l     
4e21			 
4e21			 
4e21					if DEBUG_FORTH_WORDS 
4e21						DMARK "SY1" 
4e21 f5				push af  
4e22 3a 36 4e			ld a, (.dmark)  
4e25 32 a6 fd			ld (debug_mark),a  
4e28 3a 37 4e			ld a, (.dmark+1)  
4e2b 32 a7 fd			ld (debug_mark+1),a  
4e2e 3a 38 4e			ld a, (.dmark+2)  
4e31 32 a8 fd			ld (debug_mark+2),a  
4e34 18 03			jr .pastdmark  
4e36 ..			.dmark: db "SY1"  
4e39 f1			.pastdmark: pop af  
4e3a			endm  
# End of macro DMARK
4e3a						CALLMONITOR 
4e3a cd aa fd			call debug_vector  
4e3d				endm  
# End of macro CALLMONITOR
4e3d					endif 
4e3d					 
4e3d f5					push af	 
4e3e					FORTH_DSP_POP 
4e3e cd ec 22			call macro_forth_dsp_pop 
4e41				endm 
# End of macro FORTH_DSP_POP
4e41 f1					pop af 
4e42			 
4e42 cb 27				sla a  
4e44				 
4e44					 
4e44					if DEBUG_FORTH_WORDS 
4e44						DMARK "SY" 
4e44 f5				push af  
4e45 3a 59 4e			ld a, (.dmark)  
4e48 32 a6 fd			ld (debug_mark),a  
4e4b 3a 5a 4e			ld a, (.dmark+1)  
4e4e 32 a7 fd			ld (debug_mark+1),a  
4e51 3a 5b 4e			ld a, (.dmark+2)  
4e54 32 a8 fd			ld (debug_mark+2),a  
4e57 18 02			jr .pastdmark  
4e59 ..			.dmark: db "SY"  
4e5b f1			.pastdmark: pop af  
4e5c			endm  
# End of macro DMARK
4e5c						CALLMONITOR 
4e5c cd aa fd			call debug_vector  
4e5f				endm  
# End of macro CALLMONITOR
4e5f					endif 
4e5f			 
4e5f 21 6e 4e				ld hl, sym_table 
4e62 cd db 0f				call addatohl 
4e65 cd 6c 23				call loadwordinhl 
4e68 cd 2f 20				call forth_push_numhl 
4e6b			 
4e6b			 
4e6b				       NEXTW 
4e6b c3 ea 23			jp macro_next 
4e6e				endm 
# End of macro NEXTW
4e6e			 
4e6e			sym_table: 
4e6e			 
4e6e			; 0 
4e6e 6e 4e		dw sym_table 
4e70 ad fd		dw nmi_vector 
4e72 77 f9		dw cli_autodisplay 
4e74 29 f9		dw cli_data_sp 
4e76 63 f6		dw cli_data_stack 
4e78 2b f9		dw cli_loop_sp 
4e7a 65 f8		dw cli_loop_stack 
4e7c 63 f9		dw cli_var_array 
4e7e 00 fb		dw cursor_col 
4e80 fe fa		dw cursor_ptr 
4e82			; 10 
4e82 ff fa		dw cursor_row 
4e84 a6 fd		dw debug_mark 
4e86 ec fc		dw display_fb0 
4e88 4b fc		dw display_fb1 
4e8a 09 fb		dw display_fb2 
4e8c aa fb		dw display_fb3 
4e8e 07 fb		dw display_fb_active 
4e90 fb f1		dw execscratch 
4e92 99 f9		dw f_cursor_ptr 
4e94 b0 fd		dw hardware_word 
4e96			;20 
4e96 9d fd		dw input_at_cursor 
4e98 9f fd		dw input_at_pos 
4e9a 9b fd		dw input_cur_flash 
4e9c 9a fd		dw input_cur_onoff 
4e9e 90 fd		dw input_cursor 
4ea0 a0 fd		dw input_display_size 
4ea2 95 fd		dw input_len 
4ea4 a4 fd		dw input_ptr 
4ea6 a1 fd		dw input_size 
4ea8 a2 fd		dw input_start 
4eaa			; 30 
4eaa 08 10		dw input_str 
4eac 9e fd		dw input_under_cursor 
4eae 23 f4		dw os_cli_cmd 
4eb0 1f f4		dw os_cur_ptr 
4eb2 21 f4		dw os_current_i 
4eb4 fa f2		dw os_input 
4eb6 22 f5		dw os_last_cmd 
4eb8 f9 f3		dw os_last_new_uword 
4eba aa fd		dw debug_vector 
4ebc de f0		dw os_view_hl 
4ebe			;40 
4ebe 01 f4		dw os_word_scratch 
4ec0 c3 00		dw portbctl 
4ec2 c1 00		dw portbdata 
4ec4 9e f9		dw spi_cartdev 
4ec6 9d f9		dw spi_cartdev2 
4ec8 9f f9		dw spi_clktime 
4eca 9b f9		dw spi_device 
4ecc 9a f9		dw spi_device_id 
4ece 9c f9		dw spi_portbyte 
4ed0 e2 fa		dw stackstore 
4ed2			; 50 
4ed2			if STORAGE_SE 
4ed2 82 00		dw storage_actl 
4ed4 80 00		dw storage_adata 
4ed6			else 
4ed6			dw 0 
4ed6			dw 0 
4ed6			endif 
4ed6 61 0b		dw storage_append 
4ed8			if STORAGE_SE 
4ed8 83 00		dw storage_bctl 
4eda			else 
4eda			dw 0 
4eda			endif 
4eda ce fa		dw store_bank_active 
4edc a2 f9		dw store_filecache 
4ede b0 f9		dw store_longread 
4ee0 a6 f9		dw store_openaddr 
4ee2 a5 f9		dw store_openext 
4ee4 a4 f9		dw store_openmaxext 
4ee6			; 60 
4ee6 b5 f9		dw store_page 
4ee8 b1 f9		dw store_readbuf 
4eea a8 f9		dw store_readcont 
4eec b3 f9		dw store_readptr 
4eee a8 f9		dw store_tmpext 
4ef0 a9 f9		dw store_tmpid 
4ef2 a0 f9		dw store_tmppageid 
4ef4 b6 13		dw malloc 
4ef6 80 14		dw free 
4ef8 d0 72		dw cin 
4efa			; 70 
4efa bf 72		dw cin_wait 
4efc 2f 20		dw forth_push_numhl 
4efe 9d 20		dw forth_push_str 
4f00			 
4f00			 
4f00			.ENDCONST: 
4f00			 
4f00			; eof 
4f00			 
4f00			 
# End of file forth_words_const.asm
4f00			 
4f00			if STORAGE_SE 
4f00			   	include "forth_words_storage.asm" 
4f00			 
4f00			; | ## Fixed Storage Words 
4f00			 
4f00			.RENAME: 
4f00			  
4f00				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4f00 3a				db WORD_SYS_CORE+38             
4f01 f6 4f			dw .RECORD            
4f03 07				db 6 + 1 
4f04 .. 00			db "RENAME",0              
4f0b				endm 
# End of macro CWHEAD
4f0b			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4f0b			; | | > [!NOTE] 
4f0b			; | | > Compatible with PicoSPINet  
4f0b					if DEBUG_FORTH_WORDS_KEY 
4f0b						DMARK "REN" 
4f0b f5				push af  
4f0c 3a 20 4f			ld a, (.dmark)  
4f0f 32 a6 fd			ld (debug_mark),a  
4f12 3a 21 4f			ld a, (.dmark+1)  
4f15 32 a7 fd			ld (debug_mark+1),a  
4f18 3a 22 4f			ld a, (.dmark+2)  
4f1b 32 a8 fd			ld (debug_mark+2),a  
4f1e 18 03			jr .pastdmark  
4f20 ..			.dmark: db "REN"  
4f23 f1			.pastdmark: pop af  
4f24			endm  
# End of macro DMARK
4f24						CALLMONITOR 
4f24 cd aa fd			call debug_vector  
4f27				endm  
# End of macro CALLMONITOR
4f27					endif 
4f27			 
4f27			 
4f27					; preserve some internal vars used by other file handing routines 
4f27			 
4f27 2a a6 f9				ld hl, (store_openaddr) 
4f2a e5					push hl 
4f2b 3a a8 f9				ld a, (store_readcont) 
4f2e f5					push af 
4f2f			 
4f2f					FORTH_DSP_VALUEHL 
4f2f cd 34 22			call macro_dsp_valuehl 
4f32				endm 
# End of macro FORTH_DSP_VALUEHL
4f32			 
4f32					; move ext and id around for the file header 
4f32			 
4f32 65					ld h, l 
4f33 2e 00				ld l, 0 
4f35			 
4f35 e5					push hl    ; id 
4f36			 
4f36					FORTH_DSP_POP 
4f36 cd ec 22			call macro_forth_dsp_pop 
4f39				endm 
# End of macro FORTH_DSP_POP
4f39			 
4f39					; Locate the file header 
4f39			 
4f39 e1					pop hl 
4f3a e5					push hl 
4f3b 11 b5 f9				ld de, store_page      ; get block zero of file 
4f3e					if DEBUG_FORTH_WORDS 
4f3e						DMARK "REr" 
4f3e f5				push af  
4f3f 3a 53 4f			ld a, (.dmark)  
4f42 32 a6 fd			ld (debug_mark),a  
4f45 3a 54 4f			ld a, (.dmark+1)  
4f48 32 a7 fd			ld (debug_mark+1),a  
4f4b 3a 55 4f			ld a, (.dmark+2)  
4f4e 32 a8 fd			ld (debug_mark+2),a  
4f51 18 03			jr .pastdmark  
4f53 ..			.dmark: db "REr"  
4f56 f1			.pastdmark: pop af  
4f57			endm  
# End of macro DMARK
4f57						CALLMONITOR 
4f57 cd aa fd			call debug_vector  
4f5a				endm  
# End of macro CALLMONITOR
4f5a					endif 
4f5a cd ca 09				call storage_read 
4f5d			 
4f5d cd 04 10			call ishlzero 
4f60 20 05			jr nz, .rnfound 
4f62			 
4f62				; file does not exist so indicate with 255 extents in use 
4f62			 
4f62 3e ff			ld a, 255 
4f64 e1				pop hl ; clear dup hl 
4f65 18 7b			jr .skiprneof 
4f67			 
4f67			 
4f67			.rnfound: 
4f67					; file found so rename 
4f67			 
4f67					FORTH_DSP_VALUEHL 
4f67 cd 34 22			call macro_dsp_valuehl 
4f6a				endm 
# End of macro FORTH_DSP_VALUEHL
4f6a			 
4f6a e5				push hl 
4f6b 3e 00			ld a, 0 
4f6d cd 4c 13			call strlent 
4f70 23				inc hl   ; cover zero term 
4f71 06 00			ld b,0 
4f73 4d				ld c,l 
4f74 e1				pop hl 
4f75 11 b8 f9				ld de, store_page + 3 
4f78 ed b0				ldir 
4f7a			 
4f7a 11 b5 f9				ld de, store_page 
4f7d					if DEBUG_FORTH_WORDS 
4f7d						DMARK "RER" 
4f7d f5				push af  
4f7e 3a 92 4f			ld a, (.dmark)  
4f81 32 a6 fd			ld (debug_mark),a  
4f84 3a 93 4f			ld a, (.dmark+1)  
4f87 32 a7 fd			ld (debug_mark+1),a  
4f8a 3a 94 4f			ld a, (.dmark+2)  
4f8d 32 a8 fd			ld (debug_mark+2),a  
4f90 18 03			jr .pastdmark  
4f92 ..			.dmark: db "RER"  
4f95 f1			.pastdmark: pop af  
4f96			endm  
# End of macro DMARK
4f96						CALLMONITOR 
4f96 cd aa fd			call debug_vector  
4f99				endm  
# End of macro CALLMONITOR
4f99					endif 
4f99			 
4f99 e1					pop hl    ; get orig file id and mangle it for find id 
4f9a 55					ld d, l 
4f9b 5c					ld e, h 
4f9c			 
4f9c 21 00 00				ld hl, 0 
4f9f					if DEBUG_FORTH_WORDS 
4f9f						DMARK "REf" 
4f9f f5				push af  
4fa0 3a b4 4f			ld a, (.dmark)  
4fa3 32 a6 fd			ld (debug_mark),a  
4fa6 3a b5 4f			ld a, (.dmark+1)  
4fa9 32 a7 fd			ld (debug_mark+1),a  
4fac 3a b6 4f			ld a, (.dmark+2)  
4faf 32 a8 fd			ld (debug_mark+2),a  
4fb2 18 03			jr .pastdmark  
4fb4 ..			.dmark: db "REf"  
4fb7 f1			.pastdmark: pop af  
4fb8			endm  
# End of macro DMARK
4fb8						CALLMONITOR 
4fb8 cd aa fd			call debug_vector  
4fbb				endm  
# End of macro CALLMONITOR
4fbb					endif 
4fbb cd a4 07				call storage_findnextid 
4fbe 11 b5 f9				ld de, store_page 
4fc1					if DEBUG_FORTH_WORDS 
4fc1						DMARK "REw" 
4fc1 f5				push af  
4fc2 3a d6 4f			ld a, (.dmark)  
4fc5 32 a6 fd			ld (debug_mark),a  
4fc8 3a d7 4f			ld a, (.dmark+1)  
4fcb 32 a7 fd			ld (debug_mark+1),a  
4fce 3a d8 4f			ld a, (.dmark+2)  
4fd1 32 a8 fd			ld (debug_mark+2),a  
4fd4 18 03			jr .pastdmark  
4fd6 ..			.dmark: db "REw"  
4fd9 f1			.pastdmark: pop af  
4fda			endm  
# End of macro DMARK
4fda						CALLMONITOR 
4fda cd aa fd			call debug_vector  
4fdd				endm  
# End of macro CALLMONITOR
4fdd					endif 
4fdd cd d6 04				call storage_write_block 
4fe0			 
4fe0 3e 00				ld a, 0 
4fe2			.skiprneof: 
4fe2					; drop file name 
4fe2					FORTH_DSP_POP 
4fe2 cd ec 22			call macro_forth_dsp_pop 
4fe5				endm 
# End of macro FORTH_DSP_POP
4fe5			 
4fe5 6f					ld l, a 
4fe6 26 00				ld h, 0 
4fe8 cd 2f 20				call forth_push_numhl 
4feb			 
4feb			 
4feb f1					pop af 
4fec 32 a8 f9				ld (store_readcont),a 
4fef e1					pop hl 
4ff0 22 a6 f9				ld (store_openaddr), hl 
4ff3						 
4ff3				NEXTW 
4ff3 c3 ea 23			jp macro_next 
4ff6				endm 
# End of macro NEXTW
4ff6			.RECORD: 
4ff6			  
4ff6				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4ff6 3a				db WORD_SYS_CORE+38             
4ff7 9a 50			dw .BREAD            
4ff9 07				db 6 + 1 
4ffa .. 00			db "RECORD",0              
5001				endm 
# End of macro CWHEAD
5001			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
5001			; | | > [!NOTE] 
5001			; | | > Compatible with PicoSPINet  
5001			 
5001					if DEBUG_FORTH_WORDS_KEY 
5001						DMARK "REC" 
5001 f5				push af  
5002 3a 16 50			ld a, (.dmark)  
5005 32 a6 fd			ld (debug_mark),a  
5008 3a 17 50			ld a, (.dmark+1)  
500b 32 a7 fd			ld (debug_mark+1),a  
500e 3a 18 50			ld a, (.dmark+2)  
5011 32 a8 fd			ld (debug_mark+2),a  
5014 18 03			jr .pastdmark  
5016 ..			.dmark: db "REC"  
5019 f1			.pastdmark: pop af  
501a			endm  
# End of macro DMARK
501a						CALLMONITOR 
501a cd aa fd			call debug_vector  
501d				endm  
# End of macro CALLMONITOR
501d					endif 
501d			 
501d					FORTH_DSP_VALUEHL 
501d cd 34 22			call macro_dsp_valuehl 
5020				endm 
# End of macro FORTH_DSP_VALUEHL
5020			 
5020 e5					push hl    ; id 
5021			 
5021					FORTH_DSP_POP 
5021 cd ec 22			call macro_forth_dsp_pop 
5024				endm 
# End of macro FORTH_DSP_POP
5024			 
5024					FORTH_DSP_VALUEHL 
5024 cd 34 22			call macro_dsp_valuehl 
5027				endm 
# End of macro FORTH_DSP_VALUEHL
5027			 
5027					FORTH_DSP_POP 
5027 cd ec 22			call macro_forth_dsp_pop 
502a				endm 
# End of macro FORTH_DSP_POP
502a			 
502a d1					pop de     ; get file id 
502b			 
502b					; e = file id 
502b					; l = file extent 
502b			 
502b			 
502b					; construct request to access file extent 
502b			 
502b			;		ld a, e 
502b 63					ld h, e 
502c					 
502c					 
502c					 
502c			 
502c					; e has id 
502c			 
502c 11 b5 f9			ld de, store_page 
502f					if DEBUG_FORTH_WORDS 
502f						DMARK "REr" 
502f f5				push af  
5030 3a 44 50			ld a, (.dmark)  
5033 32 a6 fd			ld (debug_mark),a  
5036 3a 45 50			ld a, (.dmark+1)  
5039 32 a7 fd			ld (debug_mark+1),a  
503c 3a 46 50			ld a, (.dmark+2)  
503f 32 a8 fd			ld (debug_mark+2),a  
5042 18 03			jr .pastdmark  
5044 ..			.dmark: db "REr"  
5047 f1			.pastdmark: pop af  
5048			endm  
# End of macro DMARK
5048						CALLMONITOR 
5048 cd aa fd			call debug_vector  
504b				endm  
# End of macro CALLMONITOR
504b					endif 
504b cd ca 09				call storage_read 
504e cd 04 10			call ishlzero 
5051 28 22			jr z, .recnotfound 
5053			 
5053			 
5053					if DEBUG_FORTH_WORDS 
5053						DMARK "REe" 
5053 f5				push af  
5054 3a 68 50			ld a, (.dmark)  
5057 32 a6 fd			ld (debug_mark),a  
505a 3a 69 50			ld a, (.dmark+1)  
505d 32 a7 fd			ld (debug_mark+1),a  
5060 3a 6a 50			ld a, (.dmark+2)  
5063 32 a8 fd			ld (debug_mark+2),a  
5066 18 03			jr .pastdmark  
5068 ..			.dmark: db "REe"  
506b f1			.pastdmark: pop af  
506c			endm  
# End of macro DMARK
506c						CALLMONITOR 
506c cd aa fd			call debug_vector  
506f				endm  
# End of macro CALLMONITOR
506f					endif 
506f cd 9d 20			call forth_push_str 
5072			 
5072					NEXTW 
5072 c3 ea 23			jp macro_next 
5075				endm 
# End of macro NEXTW
5075			 
5075			.recnotfound: 
5075					if DEBUG_FORTH_WORDS 
5075						DMARK "REf" 
5075 f5				push af  
5076 3a 8a 50			ld a, (.dmark)  
5079 32 a6 fd			ld (debug_mark),a  
507c 3a 8b 50			ld a, (.dmark+1)  
507f 32 a7 fd			ld (debug_mark+1),a  
5082 3a 8c 50			ld a, (.dmark+2)  
5085 32 a8 fd			ld (debug_mark+2),a  
5088 18 03			jr .pastdmark  
508a ..			.dmark: db "REf"  
508d f1			.pastdmark: pop af  
508e			endm  
# End of macro DMARK
508e						CALLMONITOR 
508e cd aa fd			call debug_vector  
5091				endm  
# End of macro CALLMONITOR
5091					endif 
5091 21 ff 00			ld hl, 255 
5094 cd 2f 20			call forth_push_numhl 
5097				NEXTW 
5097 c3 ea 23			jp macro_next 
509a				endm 
# End of macro NEXTW
509a			 
509a			 
509a			.BREAD: 
509a			  
509a				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
509a 3a				db WORD_SYS_CORE+38             
509b 1d 51			dw .BWRITE            
509d 06				db 5 + 1 
509e .. 00			db "BREAD",0              
50a4				endm 
# End of macro CWHEAD
50a4			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
50a4			; | | > [!NOTE] 
50a4			; | | > Compatible with PicoSPINet  
50a4				 
50a4					if DEBUG_FORTH_WORDS_KEY 
50a4						DMARK "BRD" 
50a4 f5				push af  
50a5 3a b9 50			ld a, (.dmark)  
50a8 32 a6 fd			ld (debug_mark),a  
50ab 3a ba 50			ld a, (.dmark+1)  
50ae 32 a7 fd			ld (debug_mark+1),a  
50b1 3a bb 50			ld a, (.dmark+2)  
50b4 32 a8 fd			ld (debug_mark+2),a  
50b7 18 03			jr .pastdmark  
50b9 ..			.dmark: db "BRD"  
50bc f1			.pastdmark: pop af  
50bd			endm  
# End of macro DMARK
50bd						CALLMONITOR 
50bd cd aa fd			call debug_vector  
50c0				endm  
# End of macro CALLMONITOR
50c0					endif 
50c0			 
50c0				FORTH_DSP_VALUEHL 
50c0 cd 34 22			call macro_dsp_valuehl 
50c3				endm 
# End of macro FORTH_DSP_VALUEHL
50c3			 
50c3				FORTH_DSP_POP 
50c3 cd ec 22			call macro_forth_dsp_pop 
50c6				endm 
# End of macro FORTH_DSP_POP
50c6			 
50c6				; calc block address 
50c6			 
50c6 eb				ex de, hl 
50c7 3e 40			ld a, STORE_BLOCK_PHY 
50c9 cd 5e 0f			call Mult16 
50cc			 
50cc			 
50cc 11 b5 f9			ld de, store_page 
50cf			 
50cf					if DEBUG_FORTH_WORDS 
50cf						DMARK "BR1" 
50cf f5				push af  
50d0 3a e4 50			ld a, (.dmark)  
50d3 32 a6 fd			ld (debug_mark),a  
50d6 3a e5 50			ld a, (.dmark+1)  
50d9 32 a7 fd			ld (debug_mark+1),a  
50dc 3a e6 50			ld a, (.dmark+2)  
50df 32 a8 fd			ld (debug_mark+2),a  
50e2 18 03			jr .pastdmark  
50e4 ..			.dmark: db "BR1"  
50e7 f1			.pastdmark: pop af  
50e8			endm  
# End of macro DMARK
50e8						CALLMONITOR 
50e8 cd aa fd			call debug_vector  
50eb				endm  
# End of macro CALLMONITOR
50eb					endif 
50eb			 
50eb cd 71 04			call storage_read_block 
50ee			 
50ee cd 04 10			call ishlzero 
50f1 20 05			jr nz, .brfound 
50f3			 
50f3 cd 2f 20			call forth_push_numhl 
50f6 18 22			jr .brdone 
50f8			 
50f8			 
50f8			.brfound: 
50f8 21 b7 f9		        ld hl, store_page+2 
50fb			 
50fb					if DEBUG_FORTH_WORDS 
50fb						DMARK "BR2" 
50fb f5				push af  
50fc 3a 10 51			ld a, (.dmark)  
50ff 32 a6 fd			ld (debug_mark),a  
5102 3a 11 51			ld a, (.dmark+1)  
5105 32 a7 fd			ld (debug_mark+1),a  
5108 3a 12 51			ld a, (.dmark+2)  
510b 32 a8 fd			ld (debug_mark+2),a  
510e 18 03			jr .pastdmark  
5110 ..			.dmark: db "BR2"  
5113 f1			.pastdmark: pop af  
5114			endm  
# End of macro DMARK
5114						CALLMONITOR 
5114 cd aa fd			call debug_vector  
5117				endm  
# End of macro CALLMONITOR
5117					endif 
5117			 
5117 cd 9d 20			call forth_push_str 
511a			 
511a			 
511a			.brdone: 
511a			 
511a					NEXTW 
511a c3 ea 23			jp macro_next 
511d				endm 
# End of macro NEXTW
511d			.BWRITE: 
511d				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
511d 3a				db WORD_SYS_CORE+38             
511e b2 51			dw .BUPD            
5120 07				db 6 + 1 
5121 .. 00			db "BWRITE",0              
5128				endm 
# End of macro CWHEAD
5128			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
5128			; | | > [!NOTE] 
5128			; | | > Compatible with PicoSPINet  
5128			 
5128					if DEBUG_FORTH_WORDS_KEY 
5128						DMARK "BWR" 
5128 f5				push af  
5129 3a 3d 51			ld a, (.dmark)  
512c 32 a6 fd			ld (debug_mark),a  
512f 3a 3e 51			ld a, (.dmark+1)  
5132 32 a7 fd			ld (debug_mark+1),a  
5135 3a 3f 51			ld a, (.dmark+2)  
5138 32 a8 fd			ld (debug_mark+2),a  
513b 18 03			jr .pastdmark  
513d ..			.dmark: db "BWR"  
5140 f1			.pastdmark: pop af  
5141			endm  
# End of macro DMARK
5141						CALLMONITOR 
5141 cd aa fd			call debug_vector  
5144				endm  
# End of macro CALLMONITOR
5144					endif 
5144			 
5144				FORTH_DSP_VALUEHL 
5144 cd 34 22			call macro_dsp_valuehl 
5147				endm 
# End of macro FORTH_DSP_VALUEHL
5147			 
5147				; calc block address 
5147			 
5147 eb				ex de, hl 
5148 3e 40			ld a, STORE_BLOCK_PHY 
514a cd 5e 0f			call Mult16 
514d			 
514d e5				push hl         ; address 
514e			 
514e				FORTH_DSP_POP 
514e cd ec 22			call macro_forth_dsp_pop 
5151				endm 
# End of macro FORTH_DSP_POP
5151			 
5151				FORTH_DSP_VALUEHL 
5151 cd 34 22			call macro_dsp_valuehl 
5154				endm 
# End of macro FORTH_DSP_VALUEHL
5154			 
5154				FORTH_DSP_POP 
5154 cd ec 22			call macro_forth_dsp_pop 
5157				endm 
# End of macro FORTH_DSP_POP
5157			 
5157 cd ad 0c			call storage_clear_page 
515a			 
515a				; copy string to store page 
515a			 
515a e5				push hl     ; save string address 
515b			 
515b 3e 00			ld a, 0 
515d cd 4c 13			call strlent 
5160			 
5160 23				inc hl 
5161			 
5161 4d				ld c, l 
5162 06 00			ld b, 0 
5164			 
5164 e1				pop hl 
5165 11 b7 f9			ld de, store_page + 2 
5168					if DEBUG_FORTH_WORDS 
5168						DMARK "BW1" 
5168 f5				push af  
5169 3a 7d 51			ld a, (.dmark)  
516c 32 a6 fd			ld (debug_mark),a  
516f 3a 7e 51			ld a, (.dmark+1)  
5172 32 a7 fd			ld (debug_mark+1),a  
5175 3a 7f 51			ld a, (.dmark+2)  
5178 32 a8 fd			ld (debug_mark+2),a  
517b 18 03			jr .pastdmark  
517d ..			.dmark: db "BW1"  
5180 f1			.pastdmark: pop af  
5181			endm  
# End of macro DMARK
5181						CALLMONITOR 
5181 cd aa fd			call debug_vector  
5184				endm  
# End of macro CALLMONITOR
5184					endif 
5184 ed b0			ldir 
5186			 
5186			 
5186				; poke the start of the block with flags to prevent high level file ops hitting the block 
5186			 
5186 21 ff ff			ld hl, $ffff 
5189			 
5189 22 b5 f9			ld (store_page), hl	 
518c				 
518c e1				pop hl    ; get address 
518d 11 b5 f9			ld de, store_page 
5190			 
5190					if DEBUG_FORTH_WORDS 
5190						DMARK "BW2" 
5190 f5				push af  
5191 3a a5 51			ld a, (.dmark)  
5194 32 a6 fd			ld (debug_mark),a  
5197 3a a6 51			ld a, (.dmark+1)  
519a 32 a7 fd			ld (debug_mark+1),a  
519d 3a a7 51			ld a, (.dmark+2)  
51a0 32 a8 fd			ld (debug_mark+2),a  
51a3 18 03			jr .pastdmark  
51a5 ..			.dmark: db "BW2"  
51a8 f1			.pastdmark: pop af  
51a9			endm  
# End of macro DMARK
51a9						CALLMONITOR 
51a9 cd aa fd			call debug_vector  
51ac				endm  
# End of macro CALLMONITOR
51ac					endif 
51ac			 
51ac cd d6 04			call storage_write_block 
51af			 
51af					NEXTW 
51af c3 ea 23			jp macro_next 
51b2				endm 
# End of macro NEXTW
51b2			 
51b2			.BUPD: 
51b2				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
51b2 3a				db WORD_SYS_CORE+38             
51b3 08 52			dw .BYID            
51b5 05				db 4 + 1 
51b6 .. 00			db "BUPD",0              
51bb				endm 
# End of macro CWHEAD
51bb			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
51bb			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
51bb			; | | or completely different file system structure. 
51bb			; | | > [!NOTE] 
51bb			; | | > Compatible with PicoSPINet  
51bb			 
51bb					if DEBUG_FORTH_WORDS_KEY 
51bb						DMARK "BUD" 
51bb f5				push af  
51bc 3a d0 51			ld a, (.dmark)  
51bf 32 a6 fd			ld (debug_mark),a  
51c2 3a d1 51			ld a, (.dmark+1)  
51c5 32 a7 fd			ld (debug_mark+1),a  
51c8 3a d2 51			ld a, (.dmark+2)  
51cb 32 a8 fd			ld (debug_mark+2),a  
51ce 18 03			jr .pastdmark  
51d0 ..			.dmark: db "BUD"  
51d3 f1			.pastdmark: pop af  
51d4			endm  
# End of macro DMARK
51d4						CALLMONITOR 
51d4 cd aa fd			call debug_vector  
51d7				endm  
# End of macro CALLMONITOR
51d7					endif 
51d7			 
51d7				FORTH_DSP_VALUEHL 
51d7 cd 34 22			call macro_dsp_valuehl 
51da				endm 
# End of macro FORTH_DSP_VALUEHL
51da			 
51da				; calc block address 
51da			 
51da eb				ex de, hl 
51db 3e 40			ld a, STORE_BLOCK_PHY 
51dd cd 5e 0f			call Mult16 
51e0			 
51e0				FORTH_DSP_POP 
51e0 cd ec 22			call macro_forth_dsp_pop 
51e3				endm 
# End of macro FORTH_DSP_POP
51e3			 
51e3			 
51e3 11 b5 f9			ld de, store_page 
51e6			 
51e6					if DEBUG_FORTH_WORDS 
51e6						DMARK "BUe" 
51e6 f5				push af  
51e7 3a fb 51			ld a, (.dmark)  
51ea 32 a6 fd			ld (debug_mark),a  
51ed 3a fc 51			ld a, (.dmark+1)  
51f0 32 a7 fd			ld (debug_mark+1),a  
51f3 3a fd 51			ld a, (.dmark+2)  
51f6 32 a8 fd			ld (debug_mark+2),a  
51f9 18 03			jr .pastdmark  
51fb ..			.dmark: db "BUe"  
51fe f1			.pastdmark: pop af  
51ff			endm  
# End of macro DMARK
51ff						CALLMONITOR 
51ff cd aa fd			call debug_vector  
5202				endm  
# End of macro CALLMONITOR
5202					endif 
5202			 
5202 cd d6 04			call storage_write_block 
5205			 
5205					NEXTW 
5205 c3 ea 23			jp macro_next 
5208				endm 
# End of macro NEXTW
5208			 
5208			.BYID: 
5208			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
5208			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
5208			; 
5208			;		 
5208			;		if DEBUG_FORTH_WORDS_KEY 
5208			;			DMARK "BYID" 
5208			;			CALLMONITOR 
5208			;		endif 
5208			; 
5208			;		; get direct address 
5208			; 
5208			;		FORTH_DSP_VALUEHL 
5208			; 
5208			;		FORTH_DSP_POP 
5208			; 
5208			;	; calc block address 
5208			; 
5208			;	ex de, hl 
5208			;	ld a, STORE_BLOCK_PHY 
5208			;	call Mult16 
5208			;	;	do BREAD with number as param 
5208			;	; push the file name	 
5208			;	ld de, store_page 
5208			;	call storage_read_block 
5208			 ;       ld hl, store_page+2 
5208			; 
5208			; 
5208			;		NEXTW 
5208			;.BYNAME: 
5208				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
5208 3a				db WORD_SYS_CORE+38             
5209 21 52			dw .DIR            
520b 06				db 5 + 1 
520c .. 00			db "GETID",0              
5212				endm 
# End of macro CWHEAD
5212			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
5212			; | | > [!NOTE] 
5212			; | | > Compatible with PicoSPINet  
5212			 
5212					; get pointer to file name to seek 
5212			 
5212					FORTH_DSP_VALUEHL 
5212 cd 34 22			call macro_dsp_valuehl 
5215				endm 
# End of macro FORTH_DSP_VALUEHL
5215			 
5215			 
5215 cd 98 03				call storage_getid  
5218			 
5218					FORTH_DSP_POP 
5218 cd ec 22			call macro_forth_dsp_pop 
521b				endm 
# End of macro FORTH_DSP_POP
521b			 
521b cd 2f 20				call forth_push_numhl 
521e			 
521e					NEXTW 
521e c3 ea 23			jp macro_next 
5221				endm 
# End of macro NEXTW
5221			; 
5221			.DIR: 
5221				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
5221 3a				db WORD_SYS_CORE+38             
5222 25 53			dw .SAVE            
5224 04				db 3 + 1 
5225 .. 00			db "DIR",0              
5229				endm 
# End of macro CWHEAD
5229			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
5229			; | | > [!NOTE] 
5229			; | | > Compatible with PicoSPINet  
5229			 
5229					if DEBUG_FORTH_WORDS_KEY 
5229						DMARK "DIR" 
5229 f5				push af  
522a 3a 3e 52			ld a, (.dmark)  
522d 32 a6 fd			ld (debug_mark),a  
5230 3a 3f 52			ld a, (.dmark+1)  
5233 32 a7 fd			ld (debug_mark+1),a  
5236 3a 40 52			ld a, (.dmark+2)  
5239 32 a8 fd			ld (debug_mark+2),a  
523c 18 03			jr .pastdmark  
523e ..			.dmark: db "DIR"  
5241 f1			.pastdmark: pop af  
5242			endm  
# End of macro DMARK
5242						CALLMONITOR 
5242 cd aa fd			call debug_vector  
5245				endm  
# End of macro CALLMONITOR
5245					endif 
5245 cd 22 05			call storage_get_block_0 
5248			 
5248 21 b5 f9			ld hl, store_page     ; get current id count 
524b 46				ld b, (hl) 
524c 0e 00			ld c, 0    ; count of files   
524e					if DEBUG_FORTH_WORDS 
524e						DMARK "DI1" 
524e f5				push af  
524f 3a 63 52			ld a, (.dmark)  
5252 32 a6 fd			ld (debug_mark),a  
5255 3a 64 52			ld a, (.dmark+1)  
5258 32 a7 fd			ld (debug_mark+1),a  
525b 3a 65 52			ld a, (.dmark+2)  
525e 32 a8 fd			ld (debug_mark+2),a  
5261 18 03			jr .pastdmark  
5263 ..			.dmark: db "DI1"  
5266 f1			.pastdmark: pop af  
5267			endm  
# End of macro DMARK
5267						CALLMONITOR 
5267 cd aa fd			call debug_vector  
526a				endm  
# End of macro CALLMONITOR
526a					endif 
526a			 
526a				; check for empty drive 
526a			 
526a 3e 00			ld a, 0 
526c b8				cp b 
526d ca db 52			jp z, .dirdone 
5270			 
5270				; for each of the current ids do a search for them and if found push to stack 
5270			 
5270 c5			.diritem:	push bc 
5271 21 40 00				ld hl, STORE_BLOCK_PHY 
5274 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
5276 58					ld e,b 
5277			 
5277			;		if DEBUG_FORTH_WORDS 
5277			;			DMARK "DI2" 
5277			;			CALLMONITOR 
5277			;		endif 
5277			 
5277 cd a4 07				call storage_findnextid 
527a			 
527a			;		if DEBUG_FORTH_WORDS 
527a			;			DMARK "DI3" 
527a			;			CALLMONITOR 
527a			;		endif 
527a			 
527a					; if found hl will be non zero 
527a			 
527a cd 04 10				call ishlzero 
527d			;		ld a, l 
527d			;		add h 
527d			; 
527d			;		cp 0 
527d 28 59				jr z, .dirnotfound 
527f			 
527f					; increase count 
527f			 
527f c1					pop bc	 
5280 0c					inc c 
5281 c5					push bc 
5282					 
5282			 
5282					; get file header and push the file name 
5282			 
5282 11 b5 f9				ld de, store_page 
5285 cd 71 04				call storage_read_block 
5288			 
5288					; push file id to stack 
5288				 
5288 3a b5 f9				ld a, (store_page) 
528b 26 00				ld h, 0 
528d 6f					ld l, a 
528e cd 2f 20				call forth_push_numhl 
5291			 
5291					; push extent count to stack  
5291				 
5291 3a b7 f9				ld a, (store_page+2) 
5294 26 00				ld h, 0 
5296 6f					ld l, a 
5297 cd 2f 20				call forth_push_numhl 
529a			 
529a					; push file name 
529a			 
529a 21 b8 f9				ld hl, store_page+3 
529d					if DEBUG_FORTH_WORDS 
529d						DMARK "DI5" 
529d f5				push af  
529e 3a b2 52			ld a, (.dmark)  
52a1 32 a6 fd			ld (debug_mark),a  
52a4 3a b3 52			ld a, (.dmark+1)  
52a7 32 a7 fd			ld (debug_mark+1),a  
52aa 3a b4 52			ld a, (.dmark+2)  
52ad 32 a8 fd			ld (debug_mark+2),a  
52b0 18 03			jr .pastdmark  
52b2 ..			.dmark: db "DI5"  
52b5 f1			.pastdmark: pop af  
52b6			endm  
# End of macro DMARK
52b6						CALLMONITOR 
52b6 cd aa fd			call debug_vector  
52b9				endm  
# End of macro CALLMONITOR
52b9					endif 
52b9 cd 9d 20				call forth_push_str 
52bc					if DEBUG_FORTH_WORDS 
52bc						DMARK "DI6" 
52bc f5				push af  
52bd 3a d1 52			ld a, (.dmark)  
52c0 32 a6 fd			ld (debug_mark),a  
52c3 3a d2 52			ld a, (.dmark+1)  
52c6 32 a7 fd			ld (debug_mark+1),a  
52c9 3a d3 52			ld a, (.dmark+2)  
52cc 32 a8 fd			ld (debug_mark+2),a  
52cf 18 03			jr .pastdmark  
52d1 ..			.dmark: db "DI6"  
52d4 f1			.pastdmark: pop af  
52d5			endm  
# End of macro DMARK
52d5						CALLMONITOR 
52d5 cd aa fd			call debug_vector  
52d8				endm  
# End of macro CALLMONITOR
52d8					endif 
52d8			.dirnotfound: 
52d8 c1					pop bc     
52d9 10 95				djnz .diritem 
52db				 
52db			.dirdone:	 
52db					if DEBUG_FORTH_WORDS 
52db						DMARK "DI7" 
52db f5				push af  
52dc 3a f0 52			ld a, (.dmark)  
52df 32 a6 fd			ld (debug_mark),a  
52e2 3a f1 52			ld a, (.dmark+1)  
52e5 32 a7 fd			ld (debug_mark+1),a  
52e8 3a f2 52			ld a, (.dmark+2)  
52eb 32 a8 fd			ld (debug_mark+2),a  
52ee 18 03			jr .pastdmark  
52f0 ..			.dmark: db "DI7"  
52f3 f1			.pastdmark: pop af  
52f4			endm  
# End of macro DMARK
52f4						CALLMONITOR 
52f4 cd aa fd			call debug_vector  
52f7				endm  
# End of macro CALLMONITOR
52f7					endif 
52f7			 
52f7					; push a count of the dir items found 
52f7			 
52f7 26 00				ld h, 0 
52f9 69					ld l, c 
52fa cd 2f 20				call forth_push_numhl 
52fd			 
52fd					; push the bank label 
52fd			 
52fd cd 22 05				call storage_get_block_0 
5300			 
5300				 
5300 21 b8 f9		 		ld hl, store_page+3 
5303			 
5303					if DEBUG_FORTH_WORDS 
5303						DMARK "DI8" 
5303 f5				push af  
5304 3a 18 53			ld a, (.dmark)  
5307 32 a6 fd			ld (debug_mark),a  
530a 3a 19 53			ld a, (.dmark+1)  
530d 32 a7 fd			ld (debug_mark+1),a  
5310 3a 1a 53			ld a, (.dmark+2)  
5313 32 a8 fd			ld (debug_mark+2),a  
5316 18 03			jr .pastdmark  
5318 ..			.dmark: db "DI8"  
531b f1			.pastdmark: pop af  
531c			endm  
# End of macro DMARK
531c						CALLMONITOR 
531c cd aa fd			call debug_vector  
531f				endm  
# End of macro CALLMONITOR
531f					endif 
531f cd 9d 20				call forth_push_str 
5322			 
5322			 
5322				 
5322					NEXTW 
5322 c3 ea 23			jp macro_next 
5325				endm 
# End of macro NEXTW
5325			.SAVE: 
5325			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
5325			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
5325			;		NEXTW 
5325			;.LOAD: 
5325			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
5325			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
5325			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
5325			;; > > The LOAD command can not be used in any user words or compound lines. 
5325			; 
5325			;		; store_openext use it. If zero it is EOF 
5325			; 
5325			;		; read block from current stream id 
5325			;		; if the block does not contain zero term keep reading blocks until zero found 
5325			;		; push the block to stack 
5325			;		; save the block id to stream 
5325			; 
5325			; 
5325			;		FORTH_DSP_VALUEHL 
5325			; 
5325			;;		push hl 
5325			; 
5325			;	if DEBUG_STORESE 
5325			;		DMARK "LOA" 
5325			;		CALLMONITOR 
5325			;	endif 
5325			;		FORTH_DSP_POP 
5325			; 
5325			;;		pop hl 
5325			; 
5325			;		ld h, l 
5325			;		ld l, 0 
5325			; 
5325			;		push hl     ; stack holds current file id and extent to work with 
5325			; 
5325			; 
5325			;		ld de, store_page      ; get block zero of file 
5325			;	if DEBUG_STORESE 
5325			;		DMARK "LO0" 
5325			;		CALLMONITOR 
5325			;	endif 
5325			;		call storage_read 
5325			; 
5325			;		ld a, (store_page+2)    ; max extents for this file 
5325			;		ld  (store_openmaxext),a   ; get our limit 
5325			; 
5325			;	if DEBUG_STORESE 
5325			;		DMARK "LOE" 
5325			;		CALLMONITOR 
5325			;	endif 
5325			; 
5325			;; TODO dont know why max extents are not present 
5325			;;		cp 0 
5325			;;		jp z, .loadeof     ; dont read past eof 
5325			; 
5325			;;		ld a, 1   ; start from the head of the file 
5325			; 
5325			;.loadline:	pop hl 
5325			;		inc hl 
5325			;		ld  a, (store_openmaxext)   ; get our limit 
5325			;	if DEBUG_STORESE 
5325			;		DMARK "LOx" 
5325			;		CALLMONITOR 
5325			;	endif 
5325			;		inc a 
5325			;		cp l 
5325			;		jp z, .loadeof 
5325			;		push hl    ; save current extent 
5325			; 
5325			;		ld de, store_page 
5325			; 
5325			;	if DEBUG_STORESE 
5325			;		DMARK "LO1" 
5325			;		CALLMONITOR 
5325			;	endif 
5325			;		call storage_read 
5325			; 
5325			;	if DEBUG_STORESE 
5325			;		DMARK "LO2" 
5325			;		CALLMONITOR 
5325			;	endif 
5325			;	call ishlzero 
5325			;	ld a, l 
5325			;	add h 
5325			;	cp 0 
5325			;	jr z, .loadeof 
5325			; 
5325			;	; not eof so hl should point to data to exec 
5325			; 
5325			;	; will need to add the FORTH_END_BUFFER flag 
5325			 ; 
5325			;	ld hl, store_page+2 
5325			;	ld bc, 255 
5325			;	ld a, 0 
5325			;	cpir 
5325			;	if DEBUG_STORESE 
5325			;		DMARK "LOt" 
5325			;		CALLMONITOR 
5325			;	endif 
5325			;	dec hl 
5325			;	ld a, ' ' 
5325			;	ld (hl), a 
5325			;	inc hl 
5325			;	ld (hl), a 
5325			;	inc hl 
5325			;	ld (hl), a 
5325			;	inc hl 
5325			;	ld a, FORTH_END_BUFFER 
5325			;	ld (hl), a 
5325			; 
5325			;	; TODO handle more than a single block read 
5325			; 
5325			; 
5325			;	ld hl, store_page+2 
5325			; 
5325			;	ld (os_tok_ptr), hl 
5325			; 
5325			;	if DEBUG_STORESE 
5325			;		DMARK "LO3" 
5325			;		CALLMONITOR 
5325			;	endif 
5325			; 
5325			;	call forthparse 
5325			;	call forthexec 
5325			;	call forthexec_cleanup 
5325			; 
5325			;	; go to next extent 
5325			; 
5325			;	; get next block  or mark as eof 
5325			;	jp .loadline 
5325			; 
5325			; 
5325			; 
5325			;	       NEXTW 
5325			;.loadeof:	ld a, 0 
5325			;		ld (store_openext), a 
5325			; 
5325			;	if DEBUG_STORESE 
5325			;		DMARK "LOF" 
5325			;		CALLMONITOR 
5325			;	endif 
5325			;		ret 
5325			;		;NEXTW 
5325			;.BSAVE:   
5325			; 
5325			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
5325			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
5325			;		NEXTW 
5325			;.BLOAD: 
5325			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
5325			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
5325			;		NEXTW 
5325			;;;; counter gap 
5325			 
5325			 
5325			.SEO: 
5325				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
5325 64				db WORD_SYS_CORE+80             
5326 44 53			dw .SEI            
5328 04				db 3 + 1 
5329 .. 00			db "SEO",0              
532d				endm 
# End of macro CWHEAD
532d			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
532d			 
532d					; get port 
532d			 
532d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
532d cd 34 22			call macro_dsp_valuehl 
5330				endm 
# End of macro FORTH_DSP_VALUEHL
5330			 
5330 e5					push hl    ; u2 - byte 
5331			 
5331					; destroy value TOS 
5331			 
5331					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5331 cd ec 22			call macro_forth_dsp_pop 
5334				endm 
# End of macro FORTH_DSP_POP
5334			 
5334					; get byte to send 
5334			 
5334					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5334 cd 34 22			call macro_dsp_valuehl 
5337				endm 
# End of macro FORTH_DSP_VALUEHL
5337			 
5337 e5					push hl    ; u1 - addr 
5338			 
5338					; destroy value TOS 
5338			 
5338					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5338 cd ec 22			call macro_forth_dsp_pop 
533b				endm 
# End of macro FORTH_DSP_POP
533b			 
533b					; one value on hl get other one back 
533b			 
533b d1					pop de   ; u1 - byte 
533c			 
533c e1					pop hl   ; u2 - addr 
533d			 
533d					; TODO Send SPI byte 
533d			 
533d			 
533d 7b					ld a, e 
533e cd 76 02				call se_writebyte 
5341			 
5341					 
5341			 
5341					NEXTW 
5341 c3 ea 23			jp macro_next 
5344				endm 
# End of macro NEXTW
5344			 
5344			.SEI: 
5344				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
5344 65				db WORD_SYS_CORE+81             
5345 5e 53			dw .SFREE            
5347 04				db 3 + 1 
5348 .. 00			db "SEI",0              
534c				endm 
# End of macro CWHEAD
534c			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
534c			 
534c					; get port 
534c			 
534c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
534c cd 34 22			call macro_dsp_valuehl 
534f				endm 
# End of macro FORTH_DSP_VALUEHL
534f			 
534f			;		push hl 
534f			 
534f					; destroy value TOS 
534f			 
534f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
534f cd ec 22			call macro_forth_dsp_pop 
5352				endm 
# End of macro FORTH_DSP_POP
5352			 
5352					; one value on hl get other one back 
5352			 
5352			;		pop hl 
5352			 
5352			 
5352					; TODO Get SPI byte 
5352			 
5352 cd 18 03				call se_readbyte 
5355			 
5355 26 00				ld h, 0 
5357 6f					ld l, a 
5358 cd 2f 20				call forth_push_numhl 
535b			 
535b					NEXTW 
535b c3 ea 23			jp macro_next 
535e				endm 
# End of macro NEXTW
535e			 
535e			.SFREE: 
535e				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
535e 67				db WORD_SYS_CORE+83             
535f 8d 53			dw .SIZE            
5361 06				db 5 + 1 
5362 .. 00			db "FFREE",0              
5368				endm 
# End of macro CWHEAD
5368			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
5368			; | | > [!NOTE] 
5368			; | | > Compatible with PicoSPINet  
5368					if DEBUG_FORTH_WORDS_KEY 
5368						DMARK "FFR" 
5368 f5				push af  
5369 3a 7d 53			ld a, (.dmark)  
536c 32 a6 fd			ld (debug_mark),a  
536f 3a 7e 53			ld a, (.dmark+1)  
5372 32 a7 fd			ld (debug_mark+1),a  
5375 3a 7f 53			ld a, (.dmark+2)  
5378 32 a8 fd			ld (debug_mark+2),a  
537b 18 03			jr .pastdmark  
537d ..			.dmark: db "FFR"  
5380 f1			.pastdmark: pop af  
5381			endm  
# End of macro DMARK
5381						CALLMONITOR 
5381 cd aa fd			call debug_vector  
5384				endm  
# End of macro CALLMONITOR
5384					endif 
5384			 
5384 cd 3e 08				call storage_freeblocks 
5387			 
5387 cd 2f 20				call forth_push_numhl 
538a			 
538a				       NEXTW 
538a c3 ea 23			jp macro_next 
538d				endm 
# End of macro NEXTW
538d			.SIZE: 
538d				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
538d 67				db WORD_SYS_CORE+83             
538e c1 53			dw .CREATE            
5390 05				db 4 + 1 
5391 .. 00			db "SIZE",0              
5396				endm 
# End of macro CWHEAD
5396			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
5396			; | | > [!NOTE] 
5396			; | | > Compatible with PicoSPINet  
5396					if DEBUG_FORTH_WORDS_KEY 
5396						DMARK "SIZ" 
5396 f5				push af  
5397 3a ab 53			ld a, (.dmark)  
539a 32 a6 fd			ld (debug_mark),a  
539d 3a ac 53			ld a, (.dmark+1)  
53a0 32 a7 fd			ld (debug_mark+1),a  
53a3 3a ad 53			ld a, (.dmark+2)  
53a6 32 a8 fd			ld (debug_mark+2),a  
53a9 18 03			jr .pastdmark  
53ab ..			.dmark: db "SIZ"  
53ae f1			.pastdmark: pop af  
53af			endm  
# End of macro DMARK
53af						CALLMONITOR 
53af cd aa fd			call debug_vector  
53b2				endm  
# End of macro CALLMONITOR
53b2					endif 
53b2			 
53b2					FORTH_DSP_VALUEHL 
53b2 cd 34 22			call macro_dsp_valuehl 
53b5				endm 
# End of macro FORTH_DSP_VALUEHL
53b5			;		push hl 
53b5					FORTH_DSP_POP 
53b5 cd ec 22			call macro_forth_dsp_pop 
53b8				endm 
# End of macro FORTH_DSP_POP
53b8			;		pop hl 
53b8 cd a0 04				call storage_file_size 
53bb			 
53bb cd 2f 20				call forth_push_numhl 
53be			  
53be			 
53be				       NEXTW 
53be c3 ea 23			jp macro_next 
53c1				endm 
# End of macro NEXTW
53c1			 
53c1			.CREATE: 
53c1				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
53c1 68				db WORD_SYS_CORE+84             
53c2 2f 54			dw .APPEND            
53c4 07				db 6 + 1 
53c5 .. 00			db "CREATE",0              
53cc				endm 
# End of macro CWHEAD
53cc			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
53cc			; | | e.g.  
53cc			; | | TestProgram CREATE 
53cc			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
53cc			; | |  
53cc			; | | Max file IDs are 255. 
53cc			; | |  
53cc			; | | > [!NOTE] 
53cc			; | | > Compatible with PicoSPINet  
53cc					 
53cc					if DEBUG_FORTH_WORDS_KEY 
53cc						DMARK "CRT" 
53cc f5				push af  
53cd 3a e1 53			ld a, (.dmark)  
53d0 32 a6 fd			ld (debug_mark),a  
53d3 3a e2 53			ld a, (.dmark+1)  
53d6 32 a7 fd			ld (debug_mark+1),a  
53d9 3a e3 53			ld a, (.dmark+2)  
53dc 32 a8 fd			ld (debug_mark+2),a  
53df 18 03			jr .pastdmark  
53e1 ..			.dmark: db "CRT"  
53e4 f1			.pastdmark: pop af  
53e5			endm  
# End of macro DMARK
53e5						CALLMONITOR 
53e5 cd aa fd			call debug_vector  
53e8				endm  
# End of macro CALLMONITOR
53e8					endif 
53e8			;		call storage_get_block_0 
53e8			 
53e8					; TODO pop hl 
53e8			 
53e8					;v5 FORTH_DSP_VALUE 
53e8					FORTH_DSP_VALUE 
53e8 cd 1d 22			call macro_forth_dsp_value 
53eb				endm 
# End of macro FORTH_DSP_VALUE
53eb			 
53eb				if DEBUG_STORESE 
53eb					DMARK "CR1" 
53eb f5				push af  
53ec 3a 00 54			ld a, (.dmark)  
53ef 32 a6 fd			ld (debug_mark),a  
53f2 3a 01 54			ld a, (.dmark+1)  
53f5 32 a7 fd			ld (debug_mark+1),a  
53f8 3a 02 54			ld a, (.dmark+2)  
53fb 32 a8 fd			ld (debug_mark+2),a  
53fe 18 03			jr .pastdmark  
5400 ..			.dmark: db "CR1"  
5403 f1			.pastdmark: pop af  
5404			endm  
# End of macro DMARK
5404					CALLMONITOR 
5404 cd aa fd			call debug_vector  
5407				endm  
# End of macro CALLMONITOR
5407				endif 
5407			;		push hl 
5407			;		FORTH_DSP_POP 
5407			;		pop hl 
5407			 
5407			;		inc hl   ; move past the type marker 
5407			 
5407 cd 74 08				call storage_create 
540a			 
540a				if DEBUG_STORESE 
540a					DMARK "CT1" 
540a f5				push af  
540b 3a 1f 54			ld a, (.dmark)  
540e 32 a6 fd			ld (debug_mark),a  
5411 3a 20 54			ld a, (.dmark+1)  
5414 32 a7 fd			ld (debug_mark+1),a  
5417 3a 21 54			ld a, (.dmark+2)  
541a 32 a8 fd			ld (debug_mark+2),a  
541d 18 03			jr .pastdmark  
541f ..			.dmark: db "CT1"  
5422 f1			.pastdmark: pop af  
5423			endm  
# End of macro DMARK
5423					CALLMONITOR 
5423 cd aa fd			call debug_vector  
5426				endm  
# End of macro CALLMONITOR
5426				endif 
5426			;		push hl 
5426					FORTH_DSP_POP 
5426 cd ec 22			call macro_forth_dsp_pop 
5429				endm 
# End of macro FORTH_DSP_POP
5429			;		pop hl 
5429					; push file id to stack 
5429 cd 2f 20				call forth_push_numhl 
542c			 
542c			 
542c			 
542c				       NEXTW 
542c c3 ea 23			jp macro_next 
542f				endm 
# End of macro NEXTW
542f			 
542f			.APPEND: 
542f				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
542f 69				db WORD_SYS_CORE+85             
5430 c0 54			dw .SDEL            
5432 07				db 6 + 1 
5433 .. 00			db "APPEND",0              
543a				endm 
# End of macro CWHEAD
543a			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
543a			; | | e.g. 
543a			; | | Test CREATE      -> $01 
543a			; | | "A string to add to file" $01 APPEND 
543a			; | |  
543a			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
543a			; | | > [!NOTE] 
543a			; | | > Compatible with PicoSPINet  
543a					if DEBUG_FORTH_WORDS_KEY 
543a						DMARK "APP" 
543a f5				push af  
543b 3a 4f 54			ld a, (.dmark)  
543e 32 a6 fd			ld (debug_mark),a  
5441 3a 50 54			ld a, (.dmark+1)  
5444 32 a7 fd			ld (debug_mark+1),a  
5447 3a 51 54			ld a, (.dmark+2)  
544a 32 a8 fd			ld (debug_mark+2),a  
544d 18 03			jr .pastdmark  
544f ..			.dmark: db "APP"  
5452 f1			.pastdmark: pop af  
5453			endm  
# End of macro DMARK
5453						CALLMONITOR 
5453 cd aa fd			call debug_vector  
5456				endm  
# End of macro CALLMONITOR
5456					endif 
5456			 
5456					FORTH_DSP_VALUEHL 
5456 cd 34 22			call macro_dsp_valuehl 
5459				endm 
# End of macro FORTH_DSP_VALUEHL
5459 e5					push hl 	; save file id 
545a			 
545a				if DEBUG_STORESE 
545a					DMARK "AP1" 
545a f5				push af  
545b 3a 6f 54			ld a, (.dmark)  
545e 32 a6 fd			ld (debug_mark),a  
5461 3a 70 54			ld a, (.dmark+1)  
5464 32 a7 fd			ld (debug_mark+1),a  
5467 3a 71 54			ld a, (.dmark+2)  
546a 32 a8 fd			ld (debug_mark+2),a  
546d 18 03			jr .pastdmark  
546f ..			.dmark: db "AP1"  
5472 f1			.pastdmark: pop af  
5473			endm  
# End of macro DMARK
5473					CALLMONITOR 
5473 cd aa fd			call debug_vector  
5476				endm  
# End of macro CALLMONITOR
5476				endif 
5476					FORTH_DSP_POP 
5476 cd ec 22			call macro_forth_dsp_pop 
5479				endm 
# End of macro FORTH_DSP_POP
5479			 
5479					FORTH_DSP_VALUEHL 
5479 cd 34 22			call macro_dsp_valuehl 
547c				endm 
# End of macro FORTH_DSP_VALUEHL
547c					;v5 FORTH_DSP_VALUE 
547c e5					push hl 	; save ptr to string to save 
547d			 
547d				if DEBUG_STORESE 
547d					DMARK "AP1" 
547d f5				push af  
547e 3a 92 54			ld a, (.dmark)  
5481 32 a6 fd			ld (debug_mark),a  
5484 3a 93 54			ld a, (.dmark+1)  
5487 32 a7 fd			ld (debug_mark+1),a  
548a 3a 94 54			ld a, (.dmark+2)  
548d 32 a8 fd			ld (debug_mark+2),a  
5490 18 03			jr .pastdmark  
5492 ..			.dmark: db "AP1"  
5495 f1			.pastdmark: pop af  
5496			endm  
# End of macro DMARK
5496					CALLMONITOR 
5496 cd aa fd			call debug_vector  
5499				endm  
# End of macro CALLMONITOR
5499				endif 
5499					FORTH_DSP_POP 
5499 cd ec 22			call macro_forth_dsp_pop 
549c				endm 
# End of macro FORTH_DSP_POP
549c			 
549c d1					pop de 
549d e1					pop hl 
549e				if DEBUG_STORESE 
549e					DMARK "AP2" 
549e f5				push af  
549f 3a b3 54			ld a, (.dmark)  
54a2 32 a6 fd			ld (debug_mark),a  
54a5 3a b4 54			ld a, (.dmark+1)  
54a8 32 a7 fd			ld (debug_mark+1),a  
54ab 3a b5 54			ld a, (.dmark+2)  
54ae 32 a8 fd			ld (debug_mark+2),a  
54b1 18 03			jr .pastdmark  
54b3 ..			.dmark: db "AP2"  
54b6 f1			.pastdmark: pop af  
54b7			endm  
# End of macro DMARK
54b7					CALLMONITOR 
54b7 cd aa fd			call debug_vector  
54ba				endm  
# End of macro CALLMONITOR
54ba				endif 
54ba					;inc de ; skip var type indicator 
54ba			 
54ba					; TODO how to append numerics???? 
54ba			 
54ba cd 61 0b				call storage_append		 
54bd			 
54bd				       NEXTW 
54bd c3 ea 23			jp macro_next 
54c0				endm 
# End of macro NEXTW
54c0			.SDEL: 
54c0				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
54c0 6a				db WORD_SYS_CORE+86             
54c1 0c 55			dw .OPEN            
54c3 05				db 4 + 1 
54c4 .. 00			db "ERA",0              
54c8				endm 
# End of macro CWHEAD
54c8			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
54c8			; | | > [!NOTE] 
54c8			; | | > Compatible with PicoSPINet  
54c8					FORTH_DSP_VALUEHL 
54c8 cd 34 22			call macro_dsp_valuehl 
54cb				endm 
# End of macro FORTH_DSP_VALUEHL
54cb			;		push hl 	; save file id 
54cb			 
54cb					if DEBUG_FORTH_WORDS_KEY 
54cb						DMARK "ERA" 
54cb f5				push af  
54cc 3a e0 54			ld a, (.dmark)  
54cf 32 a6 fd			ld (debug_mark),a  
54d2 3a e1 54			ld a, (.dmark+1)  
54d5 32 a7 fd			ld (debug_mark+1),a  
54d8 3a e2 54			ld a, (.dmark+2)  
54db 32 a8 fd			ld (debug_mark+2),a  
54de 18 03			jr .pastdmark  
54e0 ..			.dmark: db "ERA"  
54e3 f1			.pastdmark: pop af  
54e4			endm  
# End of macro DMARK
54e4						CALLMONITOR 
54e4 cd aa fd			call debug_vector  
54e7				endm  
# End of macro CALLMONITOR
54e7					endif 
54e7				if DEBUG_STORESE 
54e7					DMARK "ER1" 
54e7 f5				push af  
54e8 3a fc 54			ld a, (.dmark)  
54eb 32 a6 fd			ld (debug_mark),a  
54ee 3a fd 54			ld a, (.dmark+1)  
54f1 32 a7 fd			ld (debug_mark+1),a  
54f4 3a fe 54			ld a, (.dmark+2)  
54f7 32 a8 fd			ld (debug_mark+2),a  
54fa 18 03			jr .pastdmark  
54fc ..			.dmark: db "ER1"  
54ff f1			.pastdmark: pop af  
5500			endm  
# End of macro DMARK
5500					CALLMONITOR 
5500 cd aa fd			call debug_vector  
5503				endm  
# End of macro CALLMONITOR
5503				endif 
5503					FORTH_DSP_POP 
5503 cd ec 22			call macro_forth_dsp_pop 
5506				endm 
# End of macro FORTH_DSP_POP
5506			 
5506			;		pop hl 
5506			 
5506 cd b3 06				call storage_erase 
5509				       NEXTW 
5509 c3 ea 23			jp macro_next 
550c				endm 
# End of macro NEXTW
550c			 
550c			.OPEN: 
550c				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
550c 6b				db WORD_SYS_CORE+87             
550d a0 55			dw .READ            
550f 05				db 4 + 1 
5510 .. 00			db "OPEN",0              
5515				endm 
# End of macro CWHEAD
5515			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
5515			; | | e.g. 
5515			; | | $01 OPEN $01 DO $01 READ . LOOP 
5515			; | | 
5515			; | | Will return with 255 blocks if the file does not exist 
5515			; | | > [!NOTE] 
5515			; | | > Compatible with PicoSPINet  
5515			 
5515					if DEBUG_FORTH_WORDS_KEY 
5515						DMARK "OPN" 
5515 f5				push af  
5516 3a 2a 55			ld a, (.dmark)  
5519 32 a6 fd			ld (debug_mark),a  
551c 3a 2b 55			ld a, (.dmark+1)  
551f 32 a7 fd			ld (debug_mark+1),a  
5522 3a 2c 55			ld a, (.dmark+2)  
5525 32 a8 fd			ld (debug_mark+2),a  
5528 18 03			jr .pastdmark  
552a ..			.dmark: db "OPN"  
552d f1			.pastdmark: pop af  
552e			endm  
# End of macro DMARK
552e						CALLMONITOR 
552e cd aa fd			call debug_vector  
5531				endm  
# End of macro CALLMONITOR
5531					endif 
5531					; TODO handle multiple file opens 
5531			 
5531 3e 01			       	ld a, 1 
5533 32 a5 f9				ld (store_openext), a 
5536			 
5536					; get max extents for this file 
5536				 
5536								 
5536					FORTH_DSP_VALUEHL 
5536 cd 34 22			call macro_dsp_valuehl 
5539				endm 
# End of macro FORTH_DSP_VALUEHL
5539			 
5539 65					ld h, l 
553a 2e 00				ld l, 0 
553c			 
553c					; store file id 
553c			 
553c 7c					ld a, h 
553d 32 a2 f9				ld (store_filecache), a 
5540			 
5540				if DEBUG_STORESE 
5540					DMARK "OPN" 
5540 f5				push af  
5541 3a 55 55			ld a, (.dmark)  
5544 32 a6 fd			ld (debug_mark),a  
5547 3a 56 55			ld a, (.dmark+1)  
554a 32 a7 fd			ld (debug_mark+1),a  
554d 3a 57 55			ld a, (.dmark+2)  
5550 32 a8 fd			ld (debug_mark+2),a  
5553 18 03			jr .pastdmark  
5555 ..			.dmark: db "OPN"  
5558 f1			.pastdmark: pop af  
5559			endm  
# End of macro DMARK
5559					CALLMONITOR 
5559 cd aa fd			call debug_vector  
555c				endm  
# End of macro CALLMONITOR
555c				endif 
555c			;		push hl 
555c					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
555c cd ec 22			call macro_forth_dsp_pop 
555f				endm 
# End of macro FORTH_DSP_POP
555f			;		pop hl 
555f						 
555f 11 b5 f9				ld de, store_page      ; get block zero of file 
5562 cd ca 09				call storage_read 
5565 cd 04 10			call ishlzero 
5568 20 04			jr nz, .opfound 
556a			 
556a				; file does not exist so indicate with 255 extents in use 
556a			 
556a 3e ff			ld a, 255 
556c 18 29			jr .skipopeneof 
556e			 
556e			 
556e			.opfound: 
556e			 
556e			 
556e 3a b7 f9				ld a, (store_page+2)    ; max extents for this file 
5571 32 a4 f9				ld  (store_openmaxext), a   ; get our limit and push 
5574					 
5574				if DEBUG_STORESE 
5574					DMARK "OPx" 
5574 f5				push af  
5575 3a 89 55			ld a, (.dmark)  
5578 32 a6 fd			ld (debug_mark),a  
557b 3a 8a 55			ld a, (.dmark+1)  
557e 32 a7 fd			ld (debug_mark+1),a  
5581 3a 8b 55			ld a, (.dmark+2)  
5584 32 a8 fd			ld (debug_mark+2),a  
5587 18 03			jr .pastdmark  
5589 ..			.dmark: db "OPx"  
558c f1			.pastdmark: pop af  
558d			endm  
# End of macro DMARK
558d					CALLMONITOR 
558d cd aa fd			call debug_vector  
5590				endm  
# End of macro CALLMONITOR
5590				endif 
5590 fe 00				cp 0 
5592 20 03				jr nz, .skipopeneof 
5594					; have opened an empty file 
5594					 
5594 32 a5 f9				ld (store_openext), a 
5597			 
5597			.skipopeneof: 
5597			 
5597 6f					ld l, a 
5598 26 00				ld h, 0 
559a cd 2f 20				call forth_push_numhl 
559d			 
559d			 
559d				       NEXTW 
559d c3 ea 23			jp macro_next 
55a0				endm 
# End of macro NEXTW
55a0			.READ: 
55a0				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
55a0 6c				db WORD_SYS_CORE+88             
55a1 ca 56			dw .EOF            
55a3 05				db 4 + 1 
55a4 .. 00			db "READ",0              
55a9				endm 
# End of macro CWHEAD
55a9			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
55a9			; | | e.g. 
55a9			; | | $01 OPEN $01 DO READ . LOOP 
55a9			; | | 
55a9			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
55a9			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
55a9			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
55a9			; | | two bytes contain the file id and extent. 
55a9			; | |  
55a9			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
55a9			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
55a9			; | | > [!NOTE] 
55a9			; | | > Compatible with PicoSPINet  
55a9			 
55a9					if DEBUG_FORTH_WORDS_KEY 
55a9						DMARK "REA" 
55a9 f5				push af  
55aa 3a be 55			ld a, (.dmark)  
55ad 32 a6 fd			ld (debug_mark),a  
55b0 3a bf 55			ld a, (.dmark+1)  
55b3 32 a7 fd			ld (debug_mark+1),a  
55b6 3a c0 55			ld a, (.dmark+2)  
55b9 32 a8 fd			ld (debug_mark+2),a  
55bc 18 03			jr .pastdmark  
55be ..			.dmark: db "REA"  
55c1 f1			.pastdmark: pop af  
55c2			endm  
# End of macro DMARK
55c2						CALLMONITOR 
55c2 cd aa fd			call debug_vector  
55c5				endm  
# End of macro CALLMONITOR
55c5					endif 
55c5					; store_openext use it. If zero it is EOF 
55c5			 
55c5					; read block from current stream id 
55c5					; if the block does not contain zero term keep reading blocks until zero found 
55c5					; push the block to stack 
55c5					; save the block id to stream 
55c5			 
55c5			 
55c5 cd f7 56				call .testeof 
55c8 3e 01				ld a, 1 
55ca bd					cp l 
55cb ca a6 56				jp z, .ateof 
55ce			 
55ce			 
55ce			;		FORTH_DSP_VALUEHL 
55ce			 
55ce			;		push hl 
55ce			 
55ce			;	if DEBUG_STORESE 
55ce			;		DMARK "REA" 
55ce			;		CALLMONITOR 
55ce			;	endif 
55ce			;		FORTH_DSP_POP 
55ce			 
55ce			;		pop hl 
55ce				 
55ce 3a a2 f9				ld a, (store_filecache) 
55d1 67					ld h,a 
55d2			 
55d2 3a a5 f9				ld a, (store_openext) 
55d5 6f					ld l, a 
55d6					 
55d6 fe 00				cp 0 
55d8 ca a6 56				jp z, .ateof     ; dont read past eof 
55db			 
55db cd ad 0c				call storage_clear_page 
55de			 
55de 11 b5 f9				ld de, store_page 
55e1				if DEBUG_STORESE 
55e1					DMARK "RE1" 
55e1 f5				push af  
55e2 3a f6 55			ld a, (.dmark)  
55e5 32 a6 fd			ld (debug_mark),a  
55e8 3a f7 55			ld a, (.dmark+1)  
55eb 32 a7 fd			ld (debug_mark+1),a  
55ee 3a f8 55			ld a, (.dmark+2)  
55f1 32 a8 fd			ld (debug_mark+2),a  
55f4 18 03			jr .pastdmark  
55f6 ..			.dmark: db "RE1"  
55f9 f1			.pastdmark: pop af  
55fa			endm  
# End of macro DMARK
55fa					CALLMONITOR 
55fa cd aa fd			call debug_vector  
55fd				endm  
# End of macro CALLMONITOR
55fd				endif 
55fd cd ca 09				call storage_read 
5600			 
5600				if DEBUG_STORESE 
5600					DMARK "RE2" 
5600 f5				push af  
5601 3a 15 56			ld a, (.dmark)  
5604 32 a6 fd			ld (debug_mark),a  
5607 3a 16 56			ld a, (.dmark+1)  
560a 32 a7 fd			ld (debug_mark+1),a  
560d 3a 17 56			ld a, (.dmark+2)  
5610 32 a8 fd			ld (debug_mark+2),a  
5613 18 03			jr .pastdmark  
5615 ..			.dmark: db "RE2"  
5618 f1			.pastdmark: pop af  
5619			endm  
# End of macro DMARK
5619					CALLMONITOR 
5619 cd aa fd			call debug_vector  
561c				endm  
# End of macro CALLMONITOR
561c				endif 
561c cd 04 10			call ishlzero 
561f			;	ld a, l 
561f			;	add h 
561f			;	cp 0 
561f ca a6 56			jp z, .readeof 
5622			 
5622				; not eof so hl should point to data to push to stack 
5622			 
5622				if DEBUG_STORESE 
5622					DMARK "RE3" 
5622 f5				push af  
5623 3a 37 56			ld a, (.dmark)  
5626 32 a6 fd			ld (debug_mark),a  
5629 3a 38 56			ld a, (.dmark+1)  
562c 32 a7 fd			ld (debug_mark+1),a  
562f 3a 39 56			ld a, (.dmark+2)  
5632 32 a8 fd			ld (debug_mark+2),a  
5635 18 03			jr .pastdmark  
5637 ..			.dmark: db "RE3"  
563a f1			.pastdmark: pop af  
563b			endm  
# End of macro DMARK
563b					CALLMONITOR 
563b cd aa fd			call debug_vector  
563e				endm  
# End of macro CALLMONITOR
563e				endif 
563e cd 9d 20			call forth_push_str 
5641			 
5641				if DEBUG_STORESE 
5641					DMARK "RE4" 
5641 f5				push af  
5642 3a 56 56			ld a, (.dmark)  
5645 32 a6 fd			ld (debug_mark),a  
5648 3a 57 56			ld a, (.dmark+1)  
564b 32 a7 fd			ld (debug_mark+1),a  
564e 3a 58 56			ld a, (.dmark+2)  
5651 32 a8 fd			ld (debug_mark+2),a  
5654 18 03			jr .pastdmark  
5656 ..			.dmark: db "RE4"  
5659 f1			.pastdmark: pop af  
565a			endm  
# End of macro DMARK
565a					CALLMONITOR 
565a cd aa fd			call debug_vector  
565d				endm  
# End of macro CALLMONITOR
565d				endif 
565d				; get next block  or mark as eof 
565d			 
565d 3a a4 f9			ld a, (store_openmaxext)   ; get our limit 
5660 4f				ld c, a	 
5661 3a a5 f9			ld a, (store_openext) 
5664			 
5664				if DEBUG_STORESE 
5664					DMARK "RE5" 
5664 f5				push af  
5665 3a 79 56			ld a, (.dmark)  
5668 32 a6 fd			ld (debug_mark),a  
566b 3a 7a 56			ld a, (.dmark+1)  
566e 32 a7 fd			ld (debug_mark+1),a  
5671 3a 7b 56			ld a, (.dmark+2)  
5674 32 a8 fd			ld (debug_mark+2),a  
5677 18 03			jr .pastdmark  
5679 ..			.dmark: db "RE5"  
567c f1			.pastdmark: pop af  
567d			endm  
# End of macro DMARK
567d					CALLMONITOR 
567d cd aa fd			call debug_vector  
5680				endm  
# End of macro CALLMONITOR
5680				endif 
5680 b9				cp c 
5681 28 23			jr z, .readeof     ; at last extent 
5683			 
5683 3c					inc a 
5684 32 a5 f9				ld (store_openext), a 
5687			 
5687				if DEBUG_STORESE 
5687					DMARK "RE6" 
5687 f5				push af  
5688 3a 9c 56			ld a, (.dmark)  
568b 32 a6 fd			ld (debug_mark),a  
568e 3a 9d 56			ld a, (.dmark+1)  
5691 32 a7 fd			ld (debug_mark+1),a  
5694 3a 9e 56			ld a, (.dmark+2)  
5697 32 a8 fd			ld (debug_mark+2),a  
569a 18 03			jr .pastdmark  
569c ..			.dmark: db "RE6"  
569f f1			.pastdmark: pop af  
56a0			endm  
# End of macro DMARK
56a0					CALLMONITOR 
56a0 cd aa fd			call debug_vector  
56a3				endm  
# End of macro CALLMONITOR
56a3				endif 
56a3			 
56a3			 
56a3				       NEXTW 
56a3 c3 ea 23			jp macro_next 
56a6				endm 
# End of macro NEXTW
56a6			.ateof: 
56a6				;	ld hl, .showeof 
56a6				;	call forth_push_str 
56a6 3e 00		.readeof:	ld a, 0 
56a8 32 a5 f9				ld (store_openext), a 
56ab			 
56ab					 
56ab				if DEBUG_STORESE 
56ab					DMARK "REF" 
56ab f5				push af  
56ac 3a c0 56			ld a, (.dmark)  
56af 32 a6 fd			ld (debug_mark),a  
56b2 3a c1 56			ld a, (.dmark+1)  
56b5 32 a7 fd			ld (debug_mark+1),a  
56b8 3a c2 56			ld a, (.dmark+2)  
56bb 32 a8 fd			ld (debug_mark+2),a  
56be 18 03			jr .pastdmark  
56c0 ..			.dmark: db "REF"  
56c3 f1			.pastdmark: pop af  
56c4			endm  
# End of macro DMARK
56c4					CALLMONITOR 
56c4 cd aa fd			call debug_vector  
56c7				endm  
# End of macro CALLMONITOR
56c7				endif 
56c7				       NEXTW 
56c7 c3 ea 23			jp macro_next 
56ca				endm 
# End of macro NEXTW
56ca			 
56ca			;.showeof:   db "eof", 0 
56ca			 
56ca			 
56ca			.EOF: 
56ca				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
56ca 6d				db WORD_SYS_CORE+89             
56cb 0c 57			dw .FORMAT            
56cd 04				db 3 + 1 
56ce .. 00			db "EOF",0              
56d2				endm 
# End of macro CWHEAD
56d2			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
56d2			; | | e.g. 
56d2			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
56d2			; | | > [!NOTE] 
56d2			; | | > Compatible with PicoSPINet  
56d2					; TODO if current block id for stream is zero then push true else false 
56d2			 
56d2					if DEBUG_FORTH_WORDS_KEY 
56d2						DMARK "EOF" 
56d2 f5				push af  
56d3 3a e7 56			ld a, (.dmark)  
56d6 32 a6 fd			ld (debug_mark),a  
56d9 3a e8 56			ld a, (.dmark+1)  
56dc 32 a7 fd			ld (debug_mark+1),a  
56df 3a e9 56			ld a, (.dmark+2)  
56e2 32 a8 fd			ld (debug_mark+2),a  
56e5 18 03			jr .pastdmark  
56e7 ..			.dmark: db "EOF"  
56ea f1			.pastdmark: pop af  
56eb			endm  
# End of macro DMARK
56eb						CALLMONITOR 
56eb cd aa fd			call debug_vector  
56ee				endm  
# End of macro CALLMONITOR
56ee					endif 
56ee			 
56ee					; TODO handlue multiple file streams 
56ee			 
56ee			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
56ee cd f7 56				call .testeof 
56f1 cd 2f 20				call forth_push_numhl 
56f4			 
56f4			 
56f4				       NEXTW 
56f4 c3 ea 23			jp macro_next 
56f7				endm 
# End of macro NEXTW
56f7			 
56f7			.testeof: 
56f7 2e 01				ld l, 1 
56f9 3a a4 f9				ld a, (store_openmaxext) 
56fc fe 00				cp 0 
56fe 28 09				jr  z, .eofdone   ; empty file 
5700 3a a5 f9				ld a, (store_openext) 
5703 fe 00				cp 0 
5705 28 02				jr  z, .eofdone 
5707 2e 00				ld l, 0 
5709 26 00		.eofdone:	ld h, 0 
570b c9					ret 
570c			 
570c			 
570c			 
570c			 
570c			.FORMAT: 
570c				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
570c 6d				db WORD_SYS_CORE+89             
570d 5d 57			dw .LABEL            
570f 07				db 6 + 1 
5710 .. 00			db "FORMAT",0              
5717				endm 
# End of macro CWHEAD
5717			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5717			; | | > [!NOTE] 
5717			; | | > Compatible with PicoSPINet  
5717					; TODO if current block id for stream is zero then push true else false 
5717				 
5717				if DEBUG_STORESE 
5717					DMARK "FOR" 
5717 f5				push af  
5718 3a 2c 57			ld a, (.dmark)  
571b 32 a6 fd			ld (debug_mark),a  
571e 3a 2d 57			ld a, (.dmark+1)  
5721 32 a7 fd			ld (debug_mark+1),a  
5724 3a 2e 57			ld a, (.dmark+2)  
5727 32 a8 fd			ld (debug_mark+2),a  
572a 18 03			jr .pastdmark  
572c ..			.dmark: db "FOR"  
572f f1			.pastdmark: pop af  
5730			endm  
# End of macro DMARK
5730					CALLMONITOR 
5730 cd aa fd			call debug_vector  
5733				endm  
# End of macro CALLMONITOR
5733				endif 
5733					; Wipes the bank check flags to cause a reformat on next block 0 read 
5733			 
5733 21 01 00				ld hl, 1 
5736 3e 00				ld a, 0 
5738 cd 76 02				call se_writebyte 
573b			 
573b				if DEBUG_STORESE 
573b					DMARK "FO0" 
573b f5				push af  
573c 3a 50 57			ld a, (.dmark)  
573f 32 a6 fd			ld (debug_mark),a  
5742 3a 51 57			ld a, (.dmark+1)  
5745 32 a7 fd			ld (debug_mark+1),a  
5748 3a 52 57			ld a, (.dmark+2)  
574b 32 a8 fd			ld (debug_mark+2),a  
574e 18 03			jr .pastdmark  
5750 ..			.dmark: db "FO0"  
5753 f1			.pastdmark: pop af  
5754			endm  
# End of macro DMARK
5754					CALLMONITOR 
5754 cd aa fd			call debug_vector  
5757				endm  
# End of macro CALLMONITOR
5757				endif 
5757					; force bank init 
5757			 
5757 cd 22 05				call storage_get_block_0 
575a					 
575a				       NEXTW 
575a c3 ea 23			jp macro_next 
575d				endm 
# End of macro NEXTW
575d			.LABEL: 
575d				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
575d 6d				db WORD_SYS_CORE+89             
575e ab 57			dw .STOREPAGE            
5760 06				db 5 + 1 
5761 .. 00			db "LABEL",0              
5767				endm 
# End of macro CWHEAD
5767			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5767			; | | > [!NOTE] 
5767			; | | > Compatible with PicoSPINet  
5767					; TODO test to see if bank is selected 
5767				 
5767					if DEBUG_FORTH_WORDS_KEY 
5767						DMARK "LBL" 
5767 f5				push af  
5768 3a 7c 57			ld a, (.dmark)  
576b 32 a6 fd			ld (debug_mark),a  
576e 3a 7d 57			ld a, (.dmark+1)  
5771 32 a7 fd			ld (debug_mark+1),a  
5774 3a 7e 57			ld a, (.dmark+2)  
5777 32 a8 fd			ld (debug_mark+2),a  
577a 18 03			jr .pastdmark  
577c ..			.dmark: db "LBL"  
577f f1			.pastdmark: pop af  
5780			endm  
# End of macro DMARK
5780						CALLMONITOR 
5780 cd aa fd			call debug_vector  
5783				endm  
# End of macro CALLMONITOR
5783					endif 
5783			;	if DEBUG_STORESE 
5783			;		DMARK "LBL" 
5783			;		CALLMONITOR 
5783			;	endif 
5783					FORTH_DSP_VALUEHL 
5783 cd 34 22			call macro_dsp_valuehl 
5786				endm 
# End of macro FORTH_DSP_VALUEHL
5786					;v5FORTH_DSP_VALUE 
5786					 
5786			;		push hl 
5786					FORTH_DSP_POP 
5786 cd ec 22			call macro_forth_dsp_pop 
5789				endm 
# End of macro FORTH_DSP_POP
5789			;		pop hl 
5789			 
5789			;v5		inc hl   ; move past the type marker 
5789			 
5789				if DEBUG_STORESE 
5789					DMARK "LBl" 
5789 f5				push af  
578a 3a 9e 57			ld a, (.dmark)  
578d 32 a6 fd			ld (debug_mark),a  
5790 3a 9f 57			ld a, (.dmark+1)  
5793 32 a7 fd			ld (debug_mark+1),a  
5796 3a a0 57			ld a, (.dmark+2)  
5799 32 a8 fd			ld (debug_mark+2),a  
579c 18 03			jr .pastdmark  
579e ..			.dmark: db "LBl"  
57a1 f1			.pastdmark: pop af  
57a2			endm  
# End of macro DMARK
57a2					CALLMONITOR 
57a2 cd aa fd			call debug_vector  
57a5				endm  
# End of macro CALLMONITOR
57a5				endif 
57a5 cd 46 06				call storage_label 
57a8			 
57a8				       NEXTW 
57a8 c3 ea 23			jp macro_next 
57ab				endm 
# End of macro NEXTW
57ab			.STOREPAGE: 
57ab				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
57ab 6d				db WORD_SYS_CORE+89             
57ac de 57			dw .LABELS            
57ae 0a				db 9 + 1 
57af .. 00			db "STOREPAGE",0              
57b9				endm 
# End of macro CWHEAD
57b9			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
57b9			; | | > [!NOTE] 
57b9			; | | > Compatible with PicoSPINet  
57b9					; TODO test to see if bank is selected 
57b9				 
57b9					if DEBUG_FORTH_WORDS_KEY 
57b9						DMARK "STP" 
57b9 f5				push af  
57ba 3a ce 57			ld a, (.dmark)  
57bd 32 a6 fd			ld (debug_mark),a  
57c0 3a cf 57			ld a, (.dmark+1)  
57c3 32 a7 fd			ld (debug_mark+1),a  
57c6 3a d0 57			ld a, (.dmark+2)  
57c9 32 a8 fd			ld (debug_mark+2),a  
57cc 18 03			jr .pastdmark  
57ce ..			.dmark: db "STP"  
57d1 f1			.pastdmark: pop af  
57d2			endm  
# End of macro DMARK
57d2						CALLMONITOR 
57d2 cd aa fd			call debug_vector  
57d5				endm  
# End of macro CALLMONITOR
57d5					endif 
57d5			;	if DEBUG_STORESE 
57d5			;		DMARK "STP" 
57d5			;		CALLMONITOR 
57d5			;	endif 
57d5			 
57d5 21 b5 f9			ld hl, store_page 
57d8 cd 2f 20			call forth_push_numhl 
57db			 
57db			 
57db				       NEXTW 
57db c3 ea 23			jp macro_next 
57de				endm 
# End of macro NEXTW
57de			.LABELS: 
57de				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
57de 6d				db WORD_SYS_CORE+89             
57df 68 58			dw .SCONST1            
57e1 07				db 6 + 1 
57e2 .. 00			db "LABELS",0              
57e9				endm 
# End of macro CWHEAD
57e9			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | DONE 
57e9			; | | > [!CAUTION] 
57e9			; | | > *NOT* Compatible with PicoSPINet  
57e9					;  
57e9			 
57e9					; save the current device selected to restore afterwards 
57e9				 
57e9 3a 9b f9				ld a, (spi_device) 
57ec f5					push af 
57ed			 
57ed			 
57ed					; run through each of the banks 
57ed			 
57ed 21 01 00				ld hl, 1 
57f0 cd 2f 20				call forth_push_numhl 
57f3 3e ff				ld a, SPI_CE_HIGH 
57f5 cb 87				res SPI_CE0, a 
57f7 32 9b f9				ld (spi_device), a 
57fa cd 22 05				call storage_get_block_0 
57fd 21 b8 f9				ld hl, store_page+3 
5800 cd 9d 20				call forth_push_str 
5803			 
5803					 
5803 21 02 00				ld hl, 2 
5806 cd 2f 20				call forth_push_numhl 
5809 3e ff				ld a, SPI_CE_HIGH 
580b cb 8f				res SPI_CE1, a 
580d 32 9b f9				ld (spi_device), a 
5810 cd 22 05				call storage_get_block_0 
5813 21 b8 f9				ld hl, store_page+3 
5816 cd 9d 20				call forth_push_str 
5819			 
5819					 
5819 21 03 00				ld hl, 3 
581c cd 2f 20				call forth_push_numhl 
581f 3e ff				ld a, SPI_CE_HIGH 
5821 cb 97				res SPI_CE2, a 
5823 32 9b f9				ld (spi_device), a 
5826 cd 22 05				call storage_get_block_0 
5829 21 b8 f9				ld hl, store_page+3 
582c cd 9d 20				call forth_push_str 
582f			 
582f			 
582f 21 04 00				ld hl, 4 
5832 cd 2f 20				call forth_push_numhl 
5835 3e ff				ld a, SPI_CE_HIGH 
5837 cb 9f				res SPI_CE3, a 
5839 32 9b f9				ld (spi_device), a 
583c cd 22 05				call storage_get_block_0 
583f 21 b8 f9				ld hl, store_page+3 
5842 cd 9d 20				call forth_push_str 
5845			 
5845					 
5845			 
5845 21 05 00				ld hl, 5 
5848 cd 2f 20				call forth_push_numhl 
584b 3e ff				ld a, SPI_CE_HIGH 
584d cb a7				res SPI_CE4, a 
584f 32 9b f9				ld (spi_device), a 
5852 cd 22 05				call storage_get_block_0 
5855 21 b8 f9				ld hl, store_page+3 
5858 cd 9d 20				call forth_push_str 
585b			 
585b					 
585b					; push fixed count of storage devices (on board) for now 
585b			 
585b 21 05 00				ld hl, 5 
585e cd 2f 20				call forth_push_numhl 
5861			 
5861					; restore selected device  
5861				 
5861 f1					pop af 
5862 32 9b f9				ld (spi_device), a 
5865			 
5865				       NEXTW 
5865 c3 ea 23			jp macro_next 
5868				endm 
# End of macro NEXTW
5868			 
5868			.SCONST1: 
5868				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5868 6d				db WORD_SYS_CORE+89             
5869 7f 58			dw .SCONST2            
586b 07				db 6 + 1 
586c .. 00			db "FILEID",0              
5873				endm 
# End of macro CWHEAD
5873			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5873			; | | > [!NOTE] 
5873			; | | > Compatible with PicoSPINet  
5873 3a a2 f9				ld a, (store_filecache) 
5876 26 00				ld h, 0 
5878 6f					ld l, a 
5879 cd 2f 20				call forth_push_numhl 
587c					NEXTW 
587c c3 ea 23			jp macro_next 
587f				endm 
# End of macro NEXTW
587f			.SCONST2: 
587f				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
587f 6d				db WORD_SYS_CORE+89             
5880 97 58			dw .SCONST3            
5882 08				db 7 + 1 
5883 .. 00			db "FILEEXT",0              
588b				endm 
# End of macro CWHEAD
588b			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
588b			; | | > [!NOTE] 
588b			; | | > Compatible with PicoSPINet  
588b 3a a5 f9				ld a, (store_openext) 
588e 26 00				ld h, 0 
5890 6f					ld l, a 
5891 cd 2f 20				call forth_push_numhl 
5894					NEXTW 
5894 c3 ea 23			jp macro_next 
5897				endm 
# End of macro NEXTW
5897			.SCONST3: 
5897				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5897 6d				db WORD_SYS_CORE+89             
5898 af 58			dw .SCONST4            
589a 08				db 7 + 1 
589b .. 00			db "FILEMAX",0              
58a3				endm 
# End of macro CWHEAD
58a3			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
58a3			; | | > [!NOTE] 
58a3			; | | > Compatible with PicoSPINet  
58a3 3a a4 f9				ld a, (store_openmaxext) 
58a6 26 00				ld h, 0 
58a8 6f					ld l, a 
58a9 cd 2f 20				call forth_push_numhl 
58ac					NEXTW 
58ac c3 ea 23			jp macro_next 
58af				endm 
# End of macro NEXTW
58af			.SCONST4: 
58af				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
58af 6d				db WORD_SYS_CORE+89             
58b0 c5 58			dw .SCONST5            
58b2 09				db 8 + 1 
58b3 .. 00			db "FILEADDR",0              
58bc				endm 
# End of macro CWHEAD
58bc			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currently open file to stack | DONE 
58bc			; | | > [!NOTE] 
58bc			; | | > Compatible with PicoSPINet  
58bc 2a a6 f9				ld hl, (store_openaddr) 
58bf cd 2f 20				call forth_push_numhl 
58c2					NEXTW 
58c2 c3 ea 23			jp macro_next 
58c5				endm 
# End of macro NEXTW
58c5			.SCONST5: 
58c5				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
58c5 6d				db WORD_SYS_CORE+89             
58c6 e6 58			dw .SCONST6            
58c8 09				db 8 + 1 
58c9 .. 00			db "FILEPAGE",0              
58d2				endm 
# End of macro CWHEAD
58d2			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
58d2			; | | > [!NOTE] 
58d2			; | | > Compatible with PicoSPINet  
58d2 2a a6 f9				ld hl, (store_openaddr) 
58d5 e5					push hl 
58d6 c1					pop bc 
58d7 16 00				ld d, 0 
58d9 1e 40				ld e, STORE_BLOCK_PHY 
58db cd 38 0f				call Div16 
58de c5					push bc 
58df e1					pop hl 
58e0 cd 2f 20				call forth_push_numhl 
58e3					NEXTW 
58e3 c3 ea 23			jp macro_next 
58e6				endm 
# End of macro NEXTW
58e6			.SCONST6: 
58e6				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
58e6 6d				db WORD_SYS_CORE+89             
58e7 ff 58			dw .ENDSTORAGE            
58e9 09				db 8 + 1 
58ea .. 00			db "READCONT",0              
58f3				endm 
# End of macro CWHEAD
58f3			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
58f3			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
58f3			; | | a further read should, if applicable, be CONCAT to the previous read. 
58f3			; | | > [!NOTE] 
58f3			; | | > Compatible with PicoSPINet  
58f3 3a a8 f9				ld a, (store_readcont) 
58f6 26 00				ld h, 0 
58f8 6f					ld l, a 
58f9 cd 2f 20				call forth_push_numhl 
58fc					NEXTW 
58fc c3 ea 23			jp macro_next 
58ff				endm 
# End of macro NEXTW
58ff			.ENDSTORAGE: 
58ff			; eof 
# End of file forth_words_storage.asm
58ff			endif 
58ff				include "forth_words_device.asm" 
58ff			; Device related words 
58ff			 
58ff			; | ## Device Words 
58ff			 
58ff			;if SOUND_ENABLE 
58ff			;.NOTE: 
58ff			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
58ff			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
58ff			;		if DEBUG_FORTH_WORDS_KEY 
58ff			;			DMARK "NTE" 
58ff			;			CALLMONITOR 
58ff			;		endif 
58ff			; 
58ff			;	 
58ff			; 
58ff			;		NEXTW 
58ff			;.AFTERSOUND: 
58ff			;endif 
58ff			 
58ff			 
58ff			USE_GPIO: equ 0 
58ff			 
58ff			if USE_GPIO 
58ff			.GP1: 
58ff				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
58ff			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
58ff					NEXTW 
58ff			.GP2: 
58ff				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
58ff			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
58ff			 
58ff					NEXTW 
58ff			 
58ff			.GP3: 
58ff				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
58ff			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
58ff			 
58ff					NEXTW 
58ff			 
58ff			.GP4: 
58ff				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
58ff			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
58ff			 
58ff					NEXTW 
58ff			.SIN: 
58ff			 
58ff			 
58ff			endif 
58ff			 
58ff			 
58ff				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
58ff 33				db WORD_SYS_CORE+31             
5900 34 59			dw .SOUT            
5902 03				db 2 + 1 
5903 .. 00			db "IN",0              
5906				endm 
# End of macro CWHEAD
5906			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5906					if DEBUG_FORTH_WORDS_KEY 
5906						DMARK "IN." 
5906 f5				push af  
5907 3a 1b 59			ld a, (.dmark)  
590a 32 a6 fd			ld (debug_mark),a  
590d 3a 1c 59			ld a, (.dmark+1)  
5910 32 a7 fd			ld (debug_mark+1),a  
5913 3a 1d 59			ld a, (.dmark+2)  
5916 32 a8 fd			ld (debug_mark+2),a  
5919 18 03			jr .pastdmark  
591b ..			.dmark: db "IN."  
591e f1			.pastdmark: pop af  
591f			endm  
# End of macro DMARK
591f						CALLMONITOR 
591f cd aa fd			call debug_vector  
5922				endm  
# End of macro CALLMONITOR
5922					endif 
5922					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5922 cd 34 22			call macro_dsp_valuehl 
5925				endm 
# End of macro FORTH_DSP_VALUEHL
5925			 
5925 e5					push hl 
5926			 
5926					; destroy value TOS 
5926			 
5926					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5926 cd ec 22			call macro_forth_dsp_pop 
5929				endm 
# End of macro FORTH_DSP_POP
5929			 
5929					; one value on hl get other one back 
5929			 
5929 c1					pop bc 
592a			 
592a					; do the sub 
592a			;		ex de, hl 
592a			 
592a ed 68				in l,(c) 
592c			 
592c					; save it 
592c			 
592c 26 00				ld h,0 
592e			 
592e					; TODO push value back onto stack for another op etc 
592e			 
592e cd 2f 20				call forth_push_numhl 
5931					NEXTW 
5931 c3 ea 23			jp macro_next 
5934				endm 
# End of macro NEXTW
5934			.SOUT: 
5934				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5934 34				db WORD_SYS_CORE+32             
5935 87 59			dw .SPIO            
5937 04				db 3 + 1 
5938 .. 00			db "OUT",0              
593c				endm 
# End of macro CWHEAD
593c			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
593c					if DEBUG_FORTH_WORDS_KEY 
593c						DMARK "OUT" 
593c f5				push af  
593d 3a 51 59			ld a, (.dmark)  
5940 32 a6 fd			ld (debug_mark),a  
5943 3a 52 59			ld a, (.dmark+1)  
5946 32 a7 fd			ld (debug_mark+1),a  
5949 3a 53 59			ld a, (.dmark+2)  
594c 32 a8 fd			ld (debug_mark+2),a  
594f 18 03			jr .pastdmark  
5951 ..			.dmark: db "OUT"  
5954 f1			.pastdmark: pop af  
5955			endm  
# End of macro DMARK
5955						CALLMONITOR 
5955 cd aa fd			call debug_vector  
5958				endm  
# End of macro CALLMONITOR
5958					endif 
5958			 
5958					; get port 
5958			 
5958					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5958 cd 34 22			call macro_dsp_valuehl 
595b				endm 
# End of macro FORTH_DSP_VALUEHL
595b			 
595b e5					push hl 
595c			 
595c					; destroy value TOS 
595c			 
595c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
595c cd ec 22			call macro_forth_dsp_pop 
595f				endm 
# End of macro FORTH_DSP_POP
595f			 
595f					; get byte to send 
595f			 
595f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
595f cd 34 22			call macro_dsp_valuehl 
5962				endm 
# End of macro FORTH_DSP_VALUEHL
5962			 
5962			;		push hl 
5962			 
5962					; destroy value TOS 
5962			 
5962					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5962 cd ec 22			call macro_forth_dsp_pop 
5965				endm 
# End of macro FORTH_DSP_POP
5965			 
5965					; one value on hl get other one back 
5965			 
5965			;		pop hl 
5965			 
5965 c1					pop bc 
5966			 
5966					if DEBUG_FORTH_WORDS 
5966						DMARK "OUT" 
5966 f5				push af  
5967 3a 7b 59			ld a, (.dmark)  
596a 32 a6 fd			ld (debug_mark),a  
596d 3a 7c 59			ld a, (.dmark+1)  
5970 32 a7 fd			ld (debug_mark+1),a  
5973 3a 7d 59			ld a, (.dmark+2)  
5976 32 a8 fd			ld (debug_mark+2),a  
5979 18 03			jr .pastdmark  
597b ..			.dmark: db "OUT"  
597e f1			.pastdmark: pop af  
597f			endm  
# End of macro DMARK
597f						CALLMONITOR 
597f cd aa fd			call debug_vector  
5982				endm  
# End of macro CALLMONITOR
5982					endif 
5982			 
5982 ed 69				out (c), l 
5984			 
5984					NEXTW 
5984 c3 ea 23			jp macro_next 
5987				endm 
# End of macro NEXTW
5987			 
5987			 
5987			.SPIO: 
5987			 
5987			if STORAGE_SE 
5987				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5987 51				db WORD_SYS_CORE+61             
5988 98 59			dw .SPICEH            
598a 07				db 6 + 1 
598b .. 00			db "SPICEL",0              
5992				endm 
# End of macro CWHEAD
5992			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5992			 
5992 cd 1f 02				call spi_ce_low 
5995			    NEXTW 
5995 c3 ea 23			jp macro_next 
5998				endm 
# End of macro NEXTW
5998			 
5998			.SPICEH: 
5998				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5998 51				db WORD_SYS_CORE+61             
5999 a9 59			dw .SPIOb            
599b 07				db 6 + 1 
599c .. 00			db "SPICEH",0              
59a3				endm 
# End of macro CWHEAD
59a3			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
59a3			 
59a3 cd 0e 02				call spi_ce_high 
59a6			    NEXTW 
59a6 c3 ea 23			jp macro_next 
59a9				endm 
# End of macro NEXTW
59a9			 
59a9			 
59a9			.SPIOb: 
59a9			 
59a9				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
59a9 51				db WORD_SYS_CORE+61             
59aa db 59			dw .SPII            
59ac 05				db 4 + 1 
59ad .. 00			db "SPIO",0              
59b2				endm 
# End of macro CWHEAD
59b2			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
59b2			 
59b2					if DEBUG_FORTH_WORDS_KEY 
59b2						DMARK "SPo" 
59b2 f5				push af  
59b3 3a c7 59			ld a, (.dmark)  
59b6 32 a6 fd			ld (debug_mark),a  
59b9 3a c8 59			ld a, (.dmark+1)  
59bc 32 a7 fd			ld (debug_mark+1),a  
59bf 3a c9 59			ld a, (.dmark+2)  
59c2 32 a8 fd			ld (debug_mark+2),a  
59c5 18 03			jr .pastdmark  
59c7 ..			.dmark: db "SPo"  
59ca f1			.pastdmark: pop af  
59cb			endm  
# End of macro DMARK
59cb						CALLMONITOR 
59cb cd aa fd			call debug_vector  
59ce				endm  
# End of macro CALLMONITOR
59ce					endif 
59ce					; get port 
59ce			 
59ce			 
59ce					; get byte to send 
59ce			 
59ce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59ce cd 34 22			call macro_dsp_valuehl 
59d1				endm 
# End of macro FORTH_DSP_VALUEHL
59d1			 
59d1			;		push hl    ; u1  
59d1			 
59d1					; destroy value TOS 
59d1			 
59d1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59d1 cd ec 22			call macro_forth_dsp_pop 
59d4				endm 
# End of macro FORTH_DSP_POP
59d4			 
59d4					; one value on hl get other one back 
59d4			 
59d4			;		pop hl   ; u2 - addr 
59d4			 
59d4					; TODO Send SPI byte 
59d4			 
59d4			;		push hl 
59d4			;		call spi_ce_low 
59d4			;		pop hl 
59d4 7d					ld a, l 
59d5 cd 0d 01				call spi_send_byte 
59d8			;		call spi_ce_high 
59d8			 
59d8					NEXTW 
59d8 c3 ea 23			jp macro_next 
59db				endm 
# End of macro NEXTW
59db			 
59db			.SPII: 
59db				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
59db 52				db WORD_SYS_CORE+62             
59dc 44 5a			dw .SESEL            
59de 06				db 5 + 1 
59df .. 00			db "SPII",0              
59e4				endm 
# End of macro CWHEAD
59e4			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
59e4					if DEBUG_FORTH_WORDS_KEY 
59e4						DMARK "SPi" 
59e4 f5				push af  
59e5 3a f9 59			ld a, (.dmark)  
59e8 32 a6 fd			ld (debug_mark),a  
59eb 3a fa 59			ld a, (.dmark+1)  
59ee 32 a7 fd			ld (debug_mark+1),a  
59f1 3a fb 59			ld a, (.dmark+2)  
59f4 32 a8 fd			ld (debug_mark+2),a  
59f7 18 03			jr .pastdmark  
59f9 ..			.dmark: db "SPi"  
59fc f1			.pastdmark: pop af  
59fd			endm  
# End of macro DMARK
59fd						CALLMONITOR 
59fd cd aa fd			call debug_vector  
5a00				endm  
# End of macro CALLMONITOR
5a00					endif 
5a00			 
5a00					; TODO Get SPI byte 
5a00			 
5a00 cd 34 01				call spi_read_byte 
5a03			 
5a03					if DEBUG_FORTH_WORDS 
5a03						DMARK "Si2" 
5a03 f5				push af  
5a04 3a 18 5a			ld a, (.dmark)  
5a07 32 a6 fd			ld (debug_mark),a  
5a0a 3a 19 5a			ld a, (.dmark+1)  
5a0d 32 a7 fd			ld (debug_mark+1),a  
5a10 3a 1a 5a			ld a, (.dmark+2)  
5a13 32 a8 fd			ld (debug_mark+2),a  
5a16 18 03			jr .pastdmark  
5a18 ..			.dmark: db "Si2"  
5a1b f1			.pastdmark: pop af  
5a1c			endm  
# End of macro DMARK
5a1c						CALLMONITOR 
5a1c cd aa fd			call debug_vector  
5a1f				endm  
# End of macro CALLMONITOR
5a1f					endif 
5a1f 26 00				ld h, 0 
5a21 6f					ld l, a 
5a22					if DEBUG_FORTH_WORDS 
5a22						DMARK "Si3" 
5a22 f5				push af  
5a23 3a 37 5a			ld a, (.dmark)  
5a26 32 a6 fd			ld (debug_mark),a  
5a29 3a 38 5a			ld a, (.dmark+1)  
5a2c 32 a7 fd			ld (debug_mark+1),a  
5a2f 3a 39 5a			ld a, (.dmark+2)  
5a32 32 a8 fd			ld (debug_mark+2),a  
5a35 18 03			jr .pastdmark  
5a37 ..			.dmark: db "Si3"  
5a3a f1			.pastdmark: pop af  
5a3b			endm  
# End of macro DMARK
5a3b						CALLMONITOR 
5a3b cd aa fd			call debug_vector  
5a3e				endm  
# End of macro CALLMONITOR
5a3e					endif 
5a3e cd 2f 20				call forth_push_numhl 
5a41			 
5a41					NEXTW 
5a41 c3 ea 23			jp macro_next 
5a44				endm 
# End of macro NEXTW
5a44			 
5a44			 
5a44			 
5a44			.SESEL: 
5a44				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5a44 66				db WORD_SYS_CORE+82             
5a45 ed 5a			dw .CARTDEV            
5a47 05				db 4 + 1 
5a48 .. 00			db "BANK",0              
5a4d				endm 
# End of macro CWHEAD
5a4d			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5a4d					if DEBUG_FORTH_WORDS_KEY 
5a4d						DMARK "BNK" 
5a4d f5				push af  
5a4e 3a 62 5a			ld a, (.dmark)  
5a51 32 a6 fd			ld (debug_mark),a  
5a54 3a 63 5a			ld a, (.dmark+1)  
5a57 32 a7 fd			ld (debug_mark+1),a  
5a5a 3a 64 5a			ld a, (.dmark+2)  
5a5d 32 a8 fd			ld (debug_mark+2),a  
5a60 18 03			jr .pastdmark  
5a62 ..			.dmark: db "BNK"  
5a65 f1			.pastdmark: pop af  
5a66			endm  
# End of macro DMARK
5a66						CALLMONITOR 
5a66 cd aa fd			call debug_vector  
5a69				endm  
# End of macro CALLMONITOR
5a69					endif 
5a69			 
5a69 3e ff				ld a, 255 
5a6b 32 9e f9				ld (spi_cartdev), a 
5a6e			 
5a6e					; get bank 
5a6e			 
5a6e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a6e cd 34 22			call macro_dsp_valuehl 
5a71				endm 
# End of macro FORTH_DSP_VALUEHL
5a71			 
5a71			;		push hl 
5a71			 
5a71					; destroy value TOS 
5a71			 
5a71					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a71 cd ec 22			call macro_forth_dsp_pop 
5a74				endm 
# End of macro FORTH_DSP_POP
5a74			 
5a74					; one value on hl get other one back 
5a74			 
5a74			;		pop hl 
5a74			 
5a74			 
5a74 0e ff				ld c, SPI_CE_HIGH 
5a76 06 30				ld b, '0'    ; human readable bank number 
5a78			 
5a78 7d					ld a, l 
5a79			 
5a79					if DEBUG_FORTH_WORDS 
5a79						DMARK "BNK" 
5a79 f5				push af  
5a7a 3a 8e 5a			ld a, (.dmark)  
5a7d 32 a6 fd			ld (debug_mark),a  
5a80 3a 8f 5a			ld a, (.dmark+1)  
5a83 32 a7 fd			ld (debug_mark+1),a  
5a86 3a 90 5a			ld a, (.dmark+2)  
5a89 32 a8 fd			ld (debug_mark+2),a  
5a8c 18 03			jr .pastdmark  
5a8e ..			.dmark: db "BNK"  
5a91 f1			.pastdmark: pop af  
5a92			endm  
# End of macro DMARK
5a92						CALLMONITOR 
5a92 cd aa fd			call debug_vector  
5a95				endm  
# End of macro CALLMONITOR
5a95					endif 
5a95			 
5a95					; active low 
5a95			 
5a95 fe 00				cp 0 
5a97 28 28				jr z, .bset 
5a99 fe 01				cp 1 
5a9b 20 04				jr nz, .b2 
5a9d cb 81				res 0, c 
5a9f 06 31				ld b, '1'    ; human readable bank number 
5aa1 fe 02		.b2:		cp 2 
5aa3 20 04				jr nz, .b3 
5aa5 cb 89				res 1, c 
5aa7 06 32				ld b, '2'    ; human readable bank number 
5aa9 fe 03		.b3:		cp 3 
5aab 20 04				jr nz, .b4 
5aad cb 91				res 2, c 
5aaf 06 33				ld b, '3'    ; human readable bank number 
5ab1 fe 04		.b4:		cp 4 
5ab3 20 04				jr nz, .b5 
5ab5 cb 99				res 3, c 
5ab7 06 34				ld b, '4'    ; human readable bank number 
5ab9 fe 05		.b5:		cp 5 
5abb 20 04				jr nz, .bset 
5abd cb a1				res 4, c 
5abf 06 35				ld b, '5'    ; human readable bank number 
5ac1			 
5ac1			.bset: 
5ac1 79					ld a, c 
5ac2 32 9b f9				ld (spi_device),a 
5ac5 78					ld a, b 
5ac6 32 9a f9				ld (spi_device_id),a 
5ac9					if DEBUG_FORTH_WORDS 
5ac9						DMARK "BN2" 
5ac9 f5				push af  
5aca 3a de 5a			ld a, (.dmark)  
5acd 32 a6 fd			ld (debug_mark),a  
5ad0 3a df 5a			ld a, (.dmark+1)  
5ad3 32 a7 fd			ld (debug_mark+1),a  
5ad6 3a e0 5a			ld a, (.dmark+2)  
5ad9 32 a8 fd			ld (debug_mark+2),a  
5adc 18 03			jr .pastdmark  
5ade ..			.dmark: db "BN2"  
5ae1 f1			.pastdmark: pop af  
5ae2			endm  
# End of macro DMARK
5ae2						CALLMONITOR 
5ae2 cd aa fd			call debug_vector  
5ae5				endm  
# End of macro CALLMONITOR
5ae5					endif 
5ae5			 
5ae5					; set default SPI clk pulse time as disabled for BANK use 
5ae5			 
5ae5 3e 00				ld a, 0 
5ae7 32 9f f9				ld (spi_clktime), a 
5aea			 
5aea					NEXTW 
5aea c3 ea 23			jp macro_next 
5aed				endm 
# End of macro NEXTW
5aed			 
5aed			.CARTDEV: 
5aed				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5aed 66				db WORD_SYS_CORE+82             
5aee 9b 5b			dw .ENDDEVICE            
5af0 08				db 7 + 1 
5af1 .. 00			db "CARTDEV",0              
5af9				endm 
# End of macro CWHEAD
5af9			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5af9					if DEBUG_FORTH_WORDS_KEY 
5af9						DMARK "CDV" 
5af9 f5				push af  
5afa 3a 0e 5b			ld a, (.dmark)  
5afd 32 a6 fd			ld (debug_mark),a  
5b00 3a 0f 5b			ld a, (.dmark+1)  
5b03 32 a7 fd			ld (debug_mark+1),a  
5b06 3a 10 5b			ld a, (.dmark+2)  
5b09 32 a8 fd			ld (debug_mark+2),a  
5b0c 18 03			jr .pastdmark  
5b0e ..			.dmark: db "CDV"  
5b11 f1			.pastdmark: pop af  
5b12			endm  
# End of macro DMARK
5b12						CALLMONITOR 
5b12 cd aa fd			call debug_vector  
5b15				endm  
# End of macro CALLMONITOR
5b15					endif 
5b15			 
5b15					; disable se storage bank selection 
5b15			 
5b15 3e ff				ld a, SPI_CE_HIGH		; ce high 
5b17 32 9b f9				ld (spi_device), a 
5b1a			 
5b1a					; get bank 
5b1a			 
5b1a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b1a cd 34 22			call macro_dsp_valuehl 
5b1d				endm 
# End of macro FORTH_DSP_VALUEHL
5b1d			 
5b1d			;		push hl 
5b1d			 
5b1d					; destroy value TOS 
5b1d			 
5b1d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b1d cd ec 22			call macro_forth_dsp_pop 
5b20				endm 
# End of macro FORTH_DSP_POP
5b20			 
5b20					; one value on hl get other one back 
5b20			 
5b20			;		pop hl 
5b20			 
5b20					; active low 
5b20			 
5b20 0e ff				ld c, 255 
5b22			 
5b22 7d					ld a, l 
5b23					if DEBUG_FORTH_WORDS 
5b23						DMARK "CDV" 
5b23 f5				push af  
5b24 3a 38 5b			ld a, (.dmark)  
5b27 32 a6 fd			ld (debug_mark),a  
5b2a 3a 39 5b			ld a, (.dmark+1)  
5b2d 32 a7 fd			ld (debug_mark+1),a  
5b30 3a 3a 5b			ld a, (.dmark+2)  
5b33 32 a8 fd			ld (debug_mark+2),a  
5b36 18 03			jr .pastdmark  
5b38 ..			.dmark: db "CDV"  
5b3b f1			.pastdmark: pop af  
5b3c			endm  
# End of macro DMARK
5b3c						CALLMONITOR 
5b3c cd aa fd			call debug_vector  
5b3f				endm  
# End of macro CALLMONITOR
5b3f					endif 
5b3f fe 00				cp 0 
5b41 28 30				jr z, .cset 
5b43 fe 01				cp 1 
5b45 20 02				jr nz, .c2 
5b47 cb 81				res 0, c 
5b49 fe 02		.c2:		cp 2 
5b4b 20 02				jr nz, .c3 
5b4d cb 89				res 1, c 
5b4f fe 03		.c3:		cp 3 
5b51 20 02				jr nz, .c4 
5b53 cb 91				res 2, c 
5b55 fe 04		.c4:		cp 4 
5b57 20 02				jr nz, .c5 
5b59 cb 99				res 3, c 
5b5b fe 05		.c5:		cp 5 
5b5d 20 02				jr nz, .c6 
5b5f cb a1				res 4, c 
5b61 fe 06		.c6:		cp 6 
5b63 20 02				jr nz, .c7 
5b65 cb a9				res 5, c 
5b67 fe 07		.c7:		cp 7 
5b69 20 02				jr nz, .c8 
5b6b cb b1				res 6, c 
5b6d fe 08		.c8:		cp 8 
5b6f 20 02				jr nz, .cset 
5b71 cb b9				res 7, c 
5b73 79			.cset:		ld a, c 
5b74 32 9e f9				ld (spi_cartdev),a 
5b77			 
5b77					if DEBUG_FORTH_WORDS 
5b77						DMARK "CD2" 
5b77 f5				push af  
5b78 3a 8c 5b			ld a, (.dmark)  
5b7b 32 a6 fd			ld (debug_mark),a  
5b7e 3a 8d 5b			ld a, (.dmark+1)  
5b81 32 a7 fd			ld (debug_mark+1),a  
5b84 3a 8e 5b			ld a, (.dmark+2)  
5b87 32 a8 fd			ld (debug_mark+2),a  
5b8a 18 03			jr .pastdmark  
5b8c ..			.dmark: db "CD2"  
5b8f f1			.pastdmark: pop af  
5b90			endm  
# End of macro DMARK
5b90						CALLMONITOR 
5b90 cd aa fd			call debug_vector  
5b93				endm  
# End of macro CALLMONITOR
5b93					endif 
5b93			 
5b93					; set default SPI clk pulse time as 10ms for CARTDEV use 
5b93			 
5b93 3e 0a				ld a, $0a 
5b95 32 9f f9				ld (spi_clktime), a 
5b98					NEXTW 
5b98 c3 ea 23			jp macro_next 
5b9b				endm 
# End of macro NEXTW
5b9b			endif 
5b9b			 
5b9b			.ENDDEVICE: 
5b9b			; eof 
5b9b			 
# End of file forth_words_device.asm
5b9b			 
5b9b			; var handler 
5b9b			 
5b9b			 
5b9b			.VARS: 
5b9b				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5b9b 77				db WORD_SYS_CORE+99             
5b9c 4c 5c			dw .V0            
5b9e 04				db 3 + 1 
5b9f .. 00			db "VAR",0              
5ba3				endm 
# End of macro CWHEAD
5ba3			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5ba3			;| 
5ba3			;| The variable name should consist of a single letter. e.g. "a" 
5ba3			;! If a full string is passed then only the first char is looked at 
5ba3			;| Any other char could exceed bounds checks!  
5ba3			 
5ba3					if DEBUG_FORTH_WORDS_KEY 
5ba3						DMARK "VAR" 
5ba3 f5				push af  
5ba4 3a b8 5b			ld a, (.dmark)  
5ba7 32 a6 fd			ld (debug_mark),a  
5baa 3a b9 5b			ld a, (.dmark+1)  
5bad 32 a7 fd			ld (debug_mark+1),a  
5bb0 3a ba 5b			ld a, (.dmark+2)  
5bb3 32 a8 fd			ld (debug_mark+2),a  
5bb6 18 03			jr .pastdmark  
5bb8 ..			.dmark: db "VAR"  
5bbb f1			.pastdmark: pop af  
5bbc			endm  
# End of macro DMARK
5bbc						CALLMONITOR 
5bbc cd aa fd			call debug_vector  
5bbf				endm  
# End of macro CALLMONITOR
5bbf					endif 
5bbf			 
5bbf					FORTH_DSP_VALUEHL 
5bbf cd 34 22			call macro_dsp_valuehl 
5bc2				endm 
# End of macro FORTH_DSP_VALUEHL
5bc2			 
5bc2 7e					ld a, (hl)    ; get first char on of the string 
5bc3			 
5bc3			 
5bc3					if DEBUG_FORTH_WORDS 
5bc3						DMARK "VR1" 
5bc3 f5				push af  
5bc4 3a d8 5b			ld a, (.dmark)  
5bc7 32 a6 fd			ld (debug_mark),a  
5bca 3a d9 5b			ld a, (.dmark+1)  
5bcd 32 a7 fd			ld (debug_mark+1),a  
5bd0 3a da 5b			ld a, (.dmark+2)  
5bd3 32 a8 fd			ld (debug_mark+2),a  
5bd6 18 03			jr .pastdmark  
5bd8 ..			.dmark: db "VR1"  
5bdb f1			.pastdmark: pop af  
5bdc			endm  
# End of macro DMARK
5bdc						CALLMONITOR 
5bdc cd aa fd			call debug_vector  
5bdf				endm  
# End of macro CALLMONITOR
5bdf					endif 
5bdf					 
5bdf f5					push af	 
5be0					FORTH_DSP_POP 
5be0 cd ec 22			call macro_forth_dsp_pop 
5be3				endm 
# End of macro FORTH_DSP_POP
5be3 f1					pop af 
5be4			 
5be4					; convert to upper 
5be4			 
5be4 cd 50 12				call to_upper 
5be7					if DEBUG_FORTH_WORDS 
5be7						DMARK "Vaa" 
5be7 f5				push af  
5be8 3a fc 5b			ld a, (.dmark)  
5beb 32 a6 fd			ld (debug_mark),a  
5bee 3a fd 5b			ld a, (.dmark+1)  
5bf1 32 a7 fd			ld (debug_mark+1),a  
5bf4 3a fe 5b			ld a, (.dmark+2)  
5bf7 32 a8 fd			ld (debug_mark+2),a  
5bfa 18 03			jr .pastdmark  
5bfc ..			.dmark: db "Vaa"  
5bff f1			.pastdmark: pop af  
5c00			endm  
# End of macro DMARK
5c00						CALLMONITOR 
5c00 cd aa fd			call debug_vector  
5c03				endm  
# End of macro CALLMONITOR
5c03					endif 
5c03 06 41				ld b, 'A' 
5c05 90					sub b			; set offset 
5c06					if DEBUG_FORTH_WORDS 
5c06						DMARK "Vbb" 
5c06 f5				push af  
5c07 3a 1b 5c			ld a, (.dmark)  
5c0a 32 a6 fd			ld (debug_mark),a  
5c0d 3a 1c 5c			ld a, (.dmark+1)  
5c10 32 a7 fd			ld (debug_mark+1),a  
5c13 3a 1d 5c			ld a, (.dmark+2)  
5c16 32 a8 fd			ld (debug_mark+2),a  
5c19 18 03			jr .pastdmark  
5c1b ..			.dmark: db "Vbb"  
5c1e f1			.pastdmark: pop af  
5c1f			endm  
# End of macro DMARK
5c1f						CALLMONITOR 
5c1f cd aa fd			call debug_vector  
5c22				endm  
# End of macro CALLMONITOR
5c22					endif 
5c22 cb 27				sla a  
5c24				 
5c24					 
5c24					if DEBUG_FORTH_WORDS 
5c24						DMARK "VR2" 
5c24 f5				push af  
5c25 3a 39 5c			ld a, (.dmark)  
5c28 32 a6 fd			ld (debug_mark),a  
5c2b 3a 3a 5c			ld a, (.dmark+1)  
5c2e 32 a7 fd			ld (debug_mark+1),a  
5c31 3a 3b 5c			ld a, (.dmark+2)  
5c34 32 a8 fd			ld (debug_mark+2),a  
5c37 18 03			jr .pastdmark  
5c39 ..			.dmark: db "VR2"  
5c3c f1			.pastdmark: pop af  
5c3d			endm  
# End of macro DMARK
5c3d						CALLMONITOR 
5c3d cd aa fd			call debug_vector  
5c40				endm  
# End of macro CALLMONITOR
5c40					endif 
5c40			 
5c40 21 2f f9				ld hl, cli_var_array2 
5c43 cd db 0f				call addatohl 
5c46 cd 2f 20				call forth_push_numhl 
5c49			 
5c49			 
5c49				       NEXTW 
5c49 c3 ea 23			jp macro_next 
5c4c				endm 
# End of macro NEXTW
5c4c			.V0: 
5c4c				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5c4c 78				db WORD_SYS_CORE+100             
5c4d 64 5c			dw .V0Q            
5c4f 04				db 3 + 1 
5c50 .. 00			db "V0!",0              
5c54				endm 
# End of macro CWHEAD
5c54			;| V0! ( u1 -- )  Store value to v0  | DONE 
5c54			 
5c54					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c54 cd 34 22			call macro_dsp_valuehl 
5c57				endm 
# End of macro FORTH_DSP_VALUEHL
5c57			 
5c57 11 63 f9				ld de, cli_var_array 
5c5a			 
5c5a eb					ex de, hl 
5c5b 73					ld (hl), e 
5c5c 23					inc hl 
5c5d 72					ld (hl), d 
5c5e			 
5c5e					; destroy value TOS 
5c5e			 
5c5e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c5e cd ec 22			call macro_forth_dsp_pop 
5c61				endm 
# End of macro FORTH_DSP_POP
5c61			 
5c61				       NEXTW 
5c61 c3 ea 23			jp macro_next 
5c64				endm 
# End of macro NEXTW
5c64			.V0Q: 
5c64				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5c64 79				db WORD_SYS_CORE+101             
5c65 75 5c			dw .V1S            
5c67 04				db 3 + 1 
5c68 .. 00			db "V0@",0              
5c6c				endm 
# End of macro CWHEAD
5c6c			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5c6c 2a 63 f9				ld hl, (cli_var_array) 
5c6f cd 2f 20				call forth_push_numhl 
5c72			 
5c72				       NEXTW 
5c72 c3 ea 23			jp macro_next 
5c75				endm 
# End of macro NEXTW
5c75			.V1S: 
5c75				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5c75 7a				db WORD_SYS_CORE+102             
5c76 8d 5c			dw .V1Q            
5c78 04				db 3 + 1 
5c79 .. 00			db "V1!",0              
5c7d				endm 
# End of macro CWHEAD
5c7d			;| V1! ( u1 -- )  Store value to v1 | DONE 
5c7d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c7d cd 34 22			call macro_dsp_valuehl 
5c80				endm 
# End of macro FORTH_DSP_VALUEHL
5c80			 
5c80 11 65 f9				ld de, cli_var_array+2 
5c83				 
5c83 eb					ex de, hl 
5c84 73					ld (hl), e 
5c85 23					inc hl 
5c86 72					ld (hl), d 
5c87			 
5c87					; destroy value TOS 
5c87			 
5c87					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c87 cd ec 22			call macro_forth_dsp_pop 
5c8a				endm 
# End of macro FORTH_DSP_POP
5c8a				       NEXTW 
5c8a c3 ea 23			jp macro_next 
5c8d				endm 
# End of macro NEXTW
5c8d			.V1Q: 
5c8d				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5c8d 7b				db WORD_SYS_CORE+103             
5c8e 9e 5c			dw .V2S            
5c90 04				db 3 + 1 
5c91 .. 00			db "V1@",0              
5c95				endm 
# End of macro CWHEAD
5c95			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5c95 2a 65 f9				ld hl, (cli_var_array+2) 
5c98 cd 2f 20				call forth_push_numhl 
5c9b				       NEXTW 
5c9b c3 ea 23			jp macro_next 
5c9e				endm 
# End of macro NEXTW
5c9e			.V2S: 
5c9e				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5c9e 7c				db WORD_SYS_CORE+104             
5c9f b6 5c			dw .V2Q            
5ca1 04				db 3 + 1 
5ca2 .. 00			db "V2!",0              
5ca6				endm 
# End of macro CWHEAD
5ca6			;| V2! ( u1 -- )  Store value to v2 | DONE 
5ca6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ca6 cd 34 22			call macro_dsp_valuehl 
5ca9				endm 
# End of macro FORTH_DSP_VALUEHL
5ca9			 
5ca9 11 67 f9				ld de, cli_var_array+4 
5cac				 
5cac eb					ex de, hl 
5cad 73					ld (hl), e 
5cae 23					inc hl 
5caf 72					ld (hl), d 
5cb0			 
5cb0					; destroy value TOS 
5cb0			 
5cb0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cb0 cd ec 22			call macro_forth_dsp_pop 
5cb3				endm 
# End of macro FORTH_DSP_POP
5cb3				       NEXTW 
5cb3 c3 ea 23			jp macro_next 
5cb6				endm 
# End of macro NEXTW
5cb6			.V2Q: 
5cb6				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5cb6 7d				db WORD_SYS_CORE+105             
5cb7 c7 5c			dw .V3S            
5cb9 04				db 3 + 1 
5cba .. 00			db "V2@",0              
5cbe				endm 
# End of macro CWHEAD
5cbe			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5cbe 2a 67 f9				ld hl, (cli_var_array+4) 
5cc1 cd 2f 20				call forth_push_numhl 
5cc4				       NEXTW 
5cc4 c3 ea 23			jp macro_next 
5cc7				endm 
# End of macro NEXTW
5cc7			.V3S: 
5cc7				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5cc7 7c				db WORD_SYS_CORE+104             
5cc8 df 5c			dw .V3Q            
5cca 04				db 3 + 1 
5ccb .. 00			db "V3!",0              
5ccf				endm 
# End of macro CWHEAD
5ccf			;| V3! ( u1 -- )  Store value to v3 | DONE 
5ccf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ccf cd 34 22			call macro_dsp_valuehl 
5cd2				endm 
# End of macro FORTH_DSP_VALUEHL
5cd2			 
5cd2 11 69 f9				ld de, cli_var_array+6 
5cd5				 
5cd5 eb					ex de, hl 
5cd6 73					ld (hl), e 
5cd7 23					inc hl 
5cd8 72					ld (hl), d 
5cd9			 
5cd9					; destroy value TOS 
5cd9			 
5cd9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cd9 cd ec 22			call macro_forth_dsp_pop 
5cdc				endm 
# End of macro FORTH_DSP_POP
5cdc				       NEXTW 
5cdc c3 ea 23			jp macro_next 
5cdf				endm 
# End of macro NEXTW
5cdf			.V3Q: 
5cdf				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5cdf 7d				db WORD_SYS_CORE+105             
5ce0 f0 5c			dw .END            
5ce2 04				db 3 + 1 
5ce3 .. 00			db "V3@",0              
5ce7				endm 
# End of macro CWHEAD
5ce7			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5ce7 2a 69 f9				ld hl, (cli_var_array+6) 
5cea cd 2f 20				call forth_push_numhl 
5ced				       NEXTW 
5ced c3 ea 23			jp macro_next 
5cf0				endm 
# End of macro NEXTW
5cf0			 
5cf0			 
5cf0			 
5cf0			 
5cf0			 
5cf0			; end of dict marker 
5cf0			 
5cf0 00			.END:    db WORD_SYS_END 
5cf1 00 00			dw 0 
5cf3 00				db 0 
5cf4			 
5cf4			; use to jp here for user dict words to save on macro expansion  
5cf4			 
5cf4			user_dict_next: 
5cf4				NEXTW 
5cf4 c3 ea 23			jp macro_next 
5cf7				endm 
# End of macro NEXTW
5cf7			 
5cf7			 
5cf7			user_exec: 
5cf7				;    ld hl, <word code> 
5cf7				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5cf7				;    call forthexec 
5cf7				;    jp user_dict_next   (NEXT) 
5cf7			        ;    <word code bytes> 
5cf7 eb				ex de, hl 
5cf8 2a fd f3			ld hl,(os_tok_ptr) 
5cfb				 
5cfb				FORTH_RSP_NEXT 
5cfb cd d6 1f			call macro_forth_rsp_next 
5cfe				endm 
# End of macro FORTH_RSP_NEXT
5cfe			 
5cfe			if DEBUG_FORTH_UWORD 
5cfe						DMARK "UEX" 
5cfe f5				push af  
5cff 3a 13 5d			ld a, (.dmark)  
5d02 32 a6 fd			ld (debug_mark),a  
5d05 3a 14 5d			ld a, (.dmark+1)  
5d08 32 a7 fd			ld (debug_mark+1),a  
5d0b 3a 15 5d			ld a, (.dmark+2)  
5d0e 32 a8 fd			ld (debug_mark+2),a  
5d11 18 03			jr .pastdmark  
5d13 ..			.dmark: db "UEX"  
5d16 f1			.pastdmark: pop af  
5d17			endm  
# End of macro DMARK
5d17				CALLMONITOR 
5d17 cd aa fd			call debug_vector  
5d1a				endm  
# End of macro CALLMONITOR
5d1a			endif 
5d1a			 
5d1a			 
5d1a			 
5d1a eb				ex de, hl 
5d1b 22 fd f3			ld (os_tok_ptr), hl 
5d1e				 
5d1e				; Don't use next - Skips the first word in uword. 
5d1e			 
5d1e c3 7b 24			jp exec1 
5d21			;	NEXT 
5d21			 
5d21			 
5d21			; eof 
# End of file forth_wordsv4.asm
5d21			endif 
5d21			;;;;;;;;;;;;;; Debug code 
5d21			 
5d21			 
5d21			;if DEBUG_FORTH_PARSE 
5d21 .. 00		.nowordfound: db "No match",0 
5d2a .. 00		.compword:	db "Comparing word ",0 
5d3a .. 00		.nextwordat:	db "Next word at",0 
5d47 .. 00		.charmatch:	db "Char match",0 
5d52			;endif 
5d52			if DEBUG_FORTH_JP 
5d52			.foundword:	db "Word match. Exec..",0 
5d52			endif 
5d52			;if DEBUG_FORTH_PUSH 
5d52 .. 00		.enddict:	db "Dict end. Push.",0 
5d62 .. 00		.push_str:	db "Pushing string",0 
5d71 .. 00		.push_num:	db "Pushing number",0 
5d80 .. 00		.data_sp:	db "SP:",0 
5d84 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5d96 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5da8 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5dba			;endif 
5dba			;if DEBUG_FORTH_MALLOC 
5dba .. 00		.push_malloc:	db "Malloc address",0 
5dc9			;endif 
5dc9			 
5dc9			 
5dc9			 
5dc9			; display malloc address and current data stack pointer  
5dc9			 
5dc9			malloc_error: 
5dc9 d5				push de 
5dca f5				push af 
5dcb e5				push hl 
5dcc cd a7 0d			call clear_display 
5dcf 11 ef 5d			ld de, .mallocerr 
5dd2 3e 00			ld a,0 
5dd4			;	ld de,os_word_scratch 
5dd4 cd ba 0d			call str_at_display 
5dd7 3e 11			ld a, display_row_1+17 
5dd9 11 a6 fd			ld de, debug_mark 
5ddc cd ba 0d			call str_at_display 
5ddf cd ca 0d			call update_display 
5de2				;call break_point_state 
5de2 cd bf 72			call cin_wait 
5de5			 
5de5			;	ld a, ' ' 
5de5			;	ld (os_view_disable), a 
5de5 cd 44 19			call bp_on 
5de8 e1				pop hl 
5de9 f1				pop af 
5dea d1				pop de	 
5deb				CALLMONITOR 
5deb cd aa fd			call debug_vector  
5dee				endm  
# End of macro CALLMONITOR
5dee c9				ret 
5def			 
5def .. 00		.mallocerr: 	db "Malloc Error",0 
5dfc			;if DEBUG_FORTH_PUSH 
5dfc			display_data_sp: 
5dfc f5				push af 
5dfd			 
5dfd				; see if disabled 
5dfd			 
5dfd			 
5dfd 3a aa fd			ld a, (debug_vector) 
5e00 fe c9			cp $C9  ; RET 
5e02				;ld a, (os_view_disable) 
5e02				;cp '*' 
5e02 28 67			jr z, .skipdsp 
5e04			 
5e04 e5				push hl 
5e05 e5				push hl 
5e06 e5			push hl 
5e07 cd a7 0d			call clear_display 
5e0a e1			pop hl 
5e0b 7c				ld a,h 
5e0c 21 01 f4			ld hl, os_word_scratch 
5e0f cd e4 11			call hexout 
5e12 e1				pop hl 
5e13 7d				ld a,l 
5e14 21 03 f4			ld hl, os_word_scratch+2 
5e17 cd e4 11			call hexout 
5e1a 21 05 f4			ld hl, os_word_scratch+4 
5e1d 3e 00			ld a,0 
5e1f 77				ld (hl),a 
5e20 11 01 f4			ld de,os_word_scratch 
5e23 3e 28				ld a, display_row_2 
5e25 cd ba 0d				call str_at_display 
5e28 11 84 5d			ld de, .wordinhl 
5e2b 3e 00			ld a, display_row_1 
5e2d			 
5e2d cd ba 0d				call str_at_display 
5e30 11 a6 fd			ld de, debug_mark 
5e33 3e 11			ld a, display_row_1+17 
5e35			 
5e35 cd ba 0d				call str_at_display 
5e38			 
5e38				; display current data stack pointer 
5e38 11 80 5d			ld de,.data_sp 
5e3b 3e 30				ld a, display_row_2 + 8 
5e3d cd ba 0d				call str_at_display 
5e40			 
5e40 2a 29 f9			ld hl,(cli_data_sp) 
5e43 e5				push hl 
5e44 7c				ld a,h 
5e45 21 01 f4			ld hl, os_word_scratch 
5e48 cd e4 11			call hexout 
5e4b e1				pop hl 
5e4c 7d				ld a,l 
5e4d 21 03 f4			ld hl, os_word_scratch+2 
5e50 cd e4 11			call hexout 
5e53 21 05 f4			ld hl, os_word_scratch+4 
5e56 3e 00			ld a,0 
5e58 77				ld (hl),a 
5e59 11 01 f4			ld de,os_word_scratch 
5e5c 3e 33				ld a, display_row_2 + 11 
5e5e cd ba 0d				call str_at_display 
5e61			 
5e61			 
5e61 cd ca 0d			call update_display 
5e64 cd ea 0c			call delay1s 
5e67 cd ea 0c			call delay1s 
5e6a e1				pop hl 
5e6b			.skipdsp: 
5e6b f1				pop af 
5e6c c9				ret 
5e6d			 
5e6d			display_data_malloc: 
5e6d			 
5e6d f5				push af 
5e6e e5				push hl 
5e6f e5				push hl 
5e70 e5			push hl 
5e71 cd a7 0d			call clear_display 
5e74 e1			pop hl 
5e75 7c				ld a,h 
5e76 21 01 f4			ld hl, os_word_scratch 
5e79 cd e4 11			call hexout 
5e7c e1				pop hl 
5e7d 7d				ld a,l 
5e7e 21 03 f4			ld hl, os_word_scratch+2 
5e81 cd e4 11			call hexout 
5e84 21 05 f4			ld hl, os_word_scratch+4 
5e87 3e 00			ld a,0 
5e89 77				ld (hl),a 
5e8a 11 01 f4			ld de,os_word_scratch 
5e8d 3e 28				ld a, display_row_2 
5e8f cd ba 0d				call str_at_display 
5e92 11 ba 5d			ld de, .push_malloc 
5e95 3e 00			ld a, display_row_1 
5e97			 
5e97 cd ba 0d				call str_at_display 
5e9a			 
5e9a				; display current data stack pointer 
5e9a 11 80 5d			ld de,.data_sp 
5e9d 3e 30				ld a, display_row_2 + 8 
5e9f cd ba 0d				call str_at_display 
5ea2			 
5ea2 2a 29 f9			ld hl,(cli_data_sp) 
5ea5 e5				push hl 
5ea6 7c				ld a,h 
5ea7 21 01 f4			ld hl, os_word_scratch 
5eaa cd e4 11			call hexout 
5ead e1				pop hl 
5eae 7d				ld a,l 
5eaf 21 03 f4			ld hl, os_word_scratch+2 
5eb2 cd e4 11			call hexout 
5eb5 21 05 f4			ld hl, os_word_scratch+4 
5eb8 3e 00			ld a,0 
5eba 77				ld (hl),a 
5ebb 11 01 f4			ld de,os_word_scratch 
5ebe 3e 33				ld a, display_row_2 + 11 
5ec0 cd ba 0d				call str_at_display 
5ec3			 
5ec3 cd ca 0d			call update_display 
5ec6 cd ea 0c			call delay1s 
5ec9 cd ea 0c			call delay1s 
5ecc e1				pop hl 
5ecd f1				pop af 
5ece c9				ret 
5ecf			;endif 
5ecf			 
5ecf			include "forth_autostart.asm" 
5ecf			; list of commands to perform at system start up 
5ecf			 
5ecf			startcmds: 
5ecf			;	dw test11 
5ecf			;	dw test12 
5ecf			;	dw test13 
5ecf			;	dw test14 
5ecf			;	dw test15 
5ecf			;	dw test16 
5ecf			;	dw test17 
5ecf			;	dw ifthtest1 
5ecf			;	dw ifthtest2 
5ecf			;	dw ifthtest3 
5ecf			;	dw mmtest1 
5ecf			;	dw mmtest2 
5ecf			;	dw mmtest3 
5ecf			;	dw mmtest4 
5ecf			;	dw mmtest5 
5ecf			;	dw mmtest6 
5ecf			;	dw iftest1 
5ecf			;	dw iftest2 
5ecf			;	dw iftest3 
5ecf			;	dw looptest1 
5ecf			;	dw looptest2 
5ecf			;	dw test1 
5ecf			;	dw test2 
5ecf			;	dw test3 
5ecf			;	dw test4 
5ecf			;	dw game2r 
5ecf			;	dw game2b1 
5ecf			;	dw game2b2 
5ecf			 
5ecf				; start up words that are actually useful 
5ecf			 
5ecf			;    dw spi1 
5ecf			;    dw spi2 
5ecf			;    dw spi3 
5ecf			;    dw spi4 
5ecf			;    dw spi5 
5ecf			;    dw spi6 
5ecf			;    dw spi7 
5ecf			; 
5ecf			;    dw spi8 
5ecf			;    dw spi9 
5ecf			;    dw spi10 
5ecf			 
5ecf			; file editor 
5ecf			;	dw edit1 
5ecf			;	dw edit2 
5ecf			;	dw edit3 
5ecf			 
5ecf			;	dw longread 
5ecf ef 62			dw clrstack 
5ed1 23 63			dw type 
5ed3			;	dw stest 
5ed3 48 63			dw strncpy 
5ed5			;	dw list 
5ed5 a9 63			dw start1 
5ed7 b9 63			dw start2 
5ed9			;	dw start3 
5ed9			;	dw start3b 
5ed9			;	dw start3c 
5ed9			 
5ed9				; (unit) testing words 
5ed9			 
5ed9			;	dw mtesta 
5ed9			;	dw mtestb 
5ed9			;	dw mtestc 
5ed9			;	dw mtestd 
5ed9			;	dw mteste 
5ed9			 
5ed9				; demo/game words 
5ed9			 
5ed9			;        dw game3w 
5ed9			;        dw game3p 
5ed9			;        dw game3sc 
5ed9			;        dw game3vsi 
5ed9			;        dw game3vs 
5ed9				 
5ed9			;	dw game2b 
5ed9			;	dw game2bf 
5ed9			;	dw game2mba 
5ed9			;	dw game2mbas 
5ed9			;	dw game2mb 
5ed9			 
5ed9 d6 66			dw game1 
5edb e7 66			dw game1a 
5edd 49 67			dw game1b 
5edf 7e 67			dw game1c 
5ee1 b4 67			dw game1d 
5ee3 e5 67			dw game1s 
5ee5 f9 67			dw game1t 
5ee7 0e 68			dw game1f 
5ee9 42 68			dw game1z 
5eeb 86 68			dw game1zz 
5eed			 
5eed 0f 65			dw test5 
5eef 47 65			dw test6 
5ef1 7f 65			dw test7 
5ef3 93 65			dw test8 
5ef5 bf 65			dw test9 
5ef7 d5 65			dw test10 
5ef9				 
5ef9 5d 69		        dw ssv5 
5efb 41 69		        dw ssv4 
5efd 25 69		        dw ssv3 
5eff ef 68		        dw ssv2 
5f01 76 69		        dw ssv1 
5f03 be 69		        dw ssv1cpm 
5f05			;	dw keyup 
5f05			;	dw keydown 
5f05			;	dw keyleft 
5f05			;	dw keyright 
5f05			;	dw 	keyf1 
5f05			;	dw keyf2 
5f05			;	dw keyf3 
5f05			;	dw keyf4 
5f05			;	dw keyf5 
5f05			;	dw keyf6 
5f05			;	dw keyf7 
5f05			;	dw keyf8 
5f05			;	dw keyf9 
5f05			;	dw keyf10 
5f05			;	dw keyf11 
5f05			;	dw keyf12 
5f05			;	dw keytab 
5f05			;	dw keycr 
5f05			;	dw keyhome 
5f05			;	dw keyend 
5f05			;	dw keybs 
5f05 00 00			db 0, 0	 
5f07			 
5f07			 
5f07			; File Editor 
5f07			 
5f07			; ( id - ) use 'e' to edit the displayed line 
5f07 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5f28 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5f5d			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5f5d .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5f95			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5f95			 
5f95			; SPI Net support words 
5f95			 
5f95			; v0! = node to send to 
5f95			; ( str count - ) 
5f95 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
5fee			 
5fee			; spiputc ( char node - ) 
5fee .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
6022			; spiputc ( u node - ) 
6022 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
6050			 
6050			; spigetc ( - n ) 
6050 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
6079			 
6079			; getnode ( - n ) 
6079 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
60a6			 
60a6			; ( str node - )  
60a6 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
610c			; store string ( str i - ) 
610c			 
610c			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
610c .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
6161			 
6161			; get string ( addr i -  )    TO FIX 
6161			 
6161 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
61b9			 
61b9			 
61b9			; NETCHAT (TODO) 
61b9			; Program to allow two nodes to chat with eachother 
61b9			; 
61b9			; v0 - target node 
61b9			;  
61b9			; accept input at 0,0 
61b9			; if input is string send spitype to target node 
61b9			; starting at row 2,0 , while spigetchr is not zero ->  
61b9			; 
61b9			; 
61b9			; TODO add paging of get request 
61b9			 
61b9			; ( node - ) 
61b9 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
61d8 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
6230 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
62a8			 
62a8			 
62a8			; Long read of currently open file 
62a8 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
62ef			 
62ef			; clear stack  
62ef			 
62ef .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
6323			 
6323			; type ( addr count - ) 
6323 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
6348			 
6348			; some direct memory words 
6348			; strncpy ( len t f -- t ) 
6348			 
6348 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
63a9			 
63a9 .. 00		start1:     	db ": bpon $00 bp ;",0 
63b9 .. 00		start2:     	db ": bpoff $01 bp ;",0 
63ca .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
6445 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
64a5			 
64a5			 
64a5			; a handy word to list items on the stack 
64a5			 
64a5 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
650f			 
650f			 
650f			; test stack  
650f			; rnd8 stest 
650f			 
650f			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
650f			 
650f			; random malloc and free cycles 
650f			 
650f			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
650f			 
650f			; fixed malloc and free cycles 
650f			 
650f			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
650f			 
650f			; fixed double string push and drop cycle  
650f			 
650f			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
650f			 
650f			; consistent fixed string push and drop cycle  
650f			 
650f			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
650f			 
650f			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
650f			 
650f			;test1:		db ": aa 1 2 3 ;", 0 
650f			;test2:     	db "111 aa 888 999",0 
650f			;test3:     	db ": bb 77 ;",0 
650f			;test4:     	db "$02 $01 do i . loop bb",0 
650f			 
650f .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6547 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
657f .. 00		test7:     	db ": box hline vline ;",0 
6593 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
65bf .. 00		test9:     	db ": sw $01 adsp world ;",0 
65d5 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
65fa			;test11:     	db "hello create .",0 
65fa			;test12:     	db "hello2 create .",0 
65fa			 
65fa			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
65fa			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
65fa			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
65fa			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
65fa			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
65fa			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
65fa			 
65fa			;iftest1:     	db "$0001 IF cls .",0 
65fa			;iftest2:     	db "$0000 IF cls .",0 
65fa			;iftest3:     	db "$0002 $0003 - IF cls .",0 
65fa			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
65fa			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
65fa			 
65fa			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
65fa			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
65fa			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
65fa			 
65fa			 
65fa .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
661e .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
664e .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
6673 .. 00		sound4: db ": cha $00 ; ",0 
6680 .. 00		sound5: db ": chb $20 ; ",0 
668d .. 00		sound6: db ": chc $40 ; ",0 
669a .. 00		sound7: db ": chd $60 ; ",0 
66a7 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
66bf .. 00		sound9: db ": cvol $90 + + note ; ", 0 
66d6			 
66d6			 
66d6			 
66d6			 
66d6			; a small guess the number game 
66d6			 
66d6 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
66e7 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6749			 
6749 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
677e .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
67b4 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
67e5 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
67f9 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
680e .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6842 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6886			 
6886			; Using 'ga' save a high score across multiple runs using external storage 
6886			 
6886 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
68ef			 
68ef			 
68ef			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
68ef			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
68ef			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
68ef			 
68ef			; simple screen saver to test code memory reuse to destruction 
68ef			 
68ef .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6925 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6941 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
695d .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6976 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
69be .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6a15			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6a15			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6a15			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6a15			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6a15			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6a15			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6a15			 
6a15			 
6a15			 
6a15			; minesweeper/battleship finding game 
6a15			; draws a game board of random ship/mine positions 
6a15			; user enters coords to see if it hits on 
6a15			; game ends when all are hit 
6a15			; when hit or miss says how many may be in the area 
6a15			 
6a15			; setup the game board and then hide it 
6a15			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6a15			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6a15			;; prompt for where to target 
6a15			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6a15			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6a15			;; TODO see if the entered coords hits or misses pushes char hit of miss 
6a15			;game2mbht:      db ": mbckht nop ;",0 
6a15			;game2mbms:      db ": mbcms nop ;",0 
6a15			; TODO how many might be near by 
6a15			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6a15			 
6a15			; Game 3 
6a15			 
6a15			; Vert scroller ski game - avoid the trees! 
6a15			 
6a15			; v0 score (ie turns) 
6a15			; v1 player pos 
6a15			; v2 left wall 
6a15			; v3 right wall 
6a15			 
6a15			; Draw side walls randomly 
6a15			 
6a15			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6a15			 
6a15			; Draw player 
6a15			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6a15			 
6a15			; TODO Get Key 
6a15			 
6a15			; TODO Move left right 
6a15			 
6a15			; scroll and move walls a bit 
6a15			 
6a15			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6a15			 
6a15			; main game loop 
6a15			 
6a15			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6a15			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6a15			 
6a15			; key board defs 
6a15			 
6a15 .. 00		keyup:       db ": keyup $05 ;",0 
6a23 .. 00		keydown:       db ": keydown $0a ;",0 
6a33 .. 00		keyleft:       db ": keyleft $0b ;",0 
6a43 .. 00		keyright:       db ": keyright $0c ;",0 
6a54 .. 00		keyf1:       db ": keyf1 $10 ;",0 
6a62 .. 00		keyf2:       db ": keyf2 $11 ;",0 
6a70 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6a7e .. 00		keyf4:       db ": keyf4 $13 ;",0 
6a8c .. 00		keyf5:       db ": keyf5 $14 ;",0 
6a9a .. 00		keyf6:       db ": keyf6 $15 ;",0 
6aa8 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6ab6 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6ac4 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6ad2 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6ae1 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6af0 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6aff			 
6aff .. 00		keytab:       db ": keytab $09 ;",0 
6b0e .. 00		keycr:       db ": keycr $0d ;",0 
6b1c .. 00		keyhome:       db ": keyhome $0e ;",0 
6b2c .. 00		keyend:       db ": keyend $0f ;",0 
6b3b .. 00		keybs:       db ": keybs $08 ;",0 
6b49			 
6b49			   
6b49			 
6b49			 
6b49			 
6b49			; eof 
# End of file forth_autostart.asm
6b49			 
6b49			 
6b49			 
6b49			; stack over and underflow checks 
6b49			 
6b49			; init the words to detect the under/overflow 
6b49			 
6b49			chk_stk_init: 
6b49				; a vague random number to check so we dont get any "lucky" hits 
6b49 3e 2d			ld a, 45 
6b4b 6f				ld l, a 
6b4c 00				nop 
6b4d 3e 17			ld a, 23 
6b4f 67				ld h, a 
6b50			 
6b50 22 d8 f0			ld (chk_word), hl     ; the word we need to check against 
6b53			 
6b53			;	ld (chk_stund), hl	; stack points.... 
6b53 22 3b fe			ld (chk_stovr), hl 
6b56 22 27 f9			ld (chk_ret_und), hl 
6b59 22 e5 f8			ld (chk_ret_ovr), hl 
6b5c 22 63 f8			ld (chk_loop_ovr), hl 
6b5f 22 61 f6			ld (chk_data_ovr), hl 
6b62 c9				ret 
6b63				 
6b63			check_stacks: 
6b63				; check all stack words 
6b63			 
6b63 e5				push hl 
6b64 d5				push de 
6b65			 
6b65			;	ld de,(chk_word) 
6b65			;	ld hl, (chk_stund)	; stack points.... 
6b65			;	if DEBUG_STK_FAULT 
6b65			;		DMARK "FAa" 
6b65			;		CALLMONITOR 
6b65			;	endif 
6b65			;	call cmp16 
6b65			;	jp z, .chk_faulta 
6b65			; 
6b65			;	ld de, sfaultsu 
6b65			;	jp .chk_fault 
6b65			 
6b65 2a 3b fe		.chk_faulta: ld hl, (chk_stovr) 
6b68 ed 5b d8 f0		ld de,(chk_word) 
6b6c				if DEBUG_STK_FAULT 
6b6c					DMARK "FAb" 
6b6c					CALLMONITOR 
6b6c				endif 
6b6c cd f9 0f			call cmp16 
6b6f 28 06			jr z, .chk_fault1 
6b71 11 15 6c			ld de, sfaultso 
6b74 c3 c6 6b			jp .chk_fault 
6b77			.chk_fault1:  
6b77 2a 27 f9			ld hl, (chk_ret_und) 
6b7a ed 5b d8 f0		ld de,(chk_word) 
6b7e				if DEBUG_STK_FAULT 
6b7e					DMARK "FAU" 
6b7e					CALLMONITOR 
6b7e				endif 
6b7e cd f9 0f			call cmp16 
6b81 ca 8a 6b			jp z, .chk_fault2 
6b84 11 25 6c			ld de, sfaultru 
6b87 c3 c6 6b			jp .chk_fault 
6b8a			.chk_fault2:  
6b8a 2a e5 f8			ld hl, (chk_ret_ovr) 
6b8d ed 5b d8 f0		ld de,(chk_word) 
6b91				if DEBUG_STK_FAULT 
6b91					DMARK "FA1" 
6b91					CALLMONITOR 
6b91				endif 
6b91 cd f9 0f			call cmp16 
6b94 ca 9d 6b			jp z, .chk_fault3 
6b97 11 33 6c			ld de, sfaultro 
6b9a c3 c6 6b			jp .chk_fault 
6b9d			.chk_fault3:  
6b9d 2a 63 f8			ld hl, (chk_loop_ovr) 
6ba0 ed 5b d8 f0		ld de,(chk_word) 
6ba4				if DEBUG_STK_FAULT 
6ba4					DMARK "FA2" 
6ba4					CALLMONITOR 
6ba4				endif 
6ba4 cd f9 0f			call cmp16 
6ba7 ca b0 6b			jp z, .chk_fault4 
6baa 11 4d 6c			ld de, sfaultlo 
6bad c3 c6 6b			jp .chk_fault 
6bb0			.chk_fault4:  
6bb0 2a 61 f6			ld hl, (chk_data_ovr) 
6bb3 ed 5b d8 f0		ld de,(chk_word) 
6bb7				if DEBUG_STK_FAULT 
6bb7					DMARK "FA3" 
6bb7					CALLMONITOR 
6bb7				endif 
6bb7 cd f9 0f			call cmp16 
6bba ca c3 6b			jp z, .chk_fault5 
6bbd 11 67 6c			ld de, sfaultdo 
6bc0 c3 c6 6b			jp .chk_fault 
6bc3			 
6bc3			 
6bc3			.chk_fault5:  
6bc3 d1				pop de 
6bc4 e1				pop hl 
6bc5			 
6bc5 c9				ret 
6bc6			 
6bc6 cd a7 0d		.chk_fault: 	call clear_display 
6bc9 3e 28				ld a, display_row_2 
6bcb cd ba 0d				call str_at_display 
6bce 11 f7 6b				   ld de, .stackfault 
6bd1 3e 00				ld a, display_row_1 
6bd3 cd ba 0d				call str_at_display 
6bd6 11 a6 fd				    ld de, debug_mark 
6bd9 3e 11				ld a, display_row_1+17 
6bdb cd ba 0d				call str_at_display 
6bde cd ca 0d				call update_display 
6be1			 
6be1				; prompt before entering montior for investigating issue 
6be1			 
6be1 3e 78			ld a, display_row_4 
6be3 11 21 1d			ld de, endprog 
6be6			 
6be6 cd ca 0d			call update_display		 
6be9			 
6be9 cd a7 1f			call next_page_prompt 
6bec			 
6bec d1				pop de 
6bed e1				pop hl 
6bee cd 75 1d				call monitor 
6bf1 cd 90 23				call forth_warmstart 
6bf4 c3 71 1c				jp warmstart_afterauto 
6bf7					;jp 0 
6bf7					;halt 
6bf7			 
6bf7			 
6bf7			 
6bf7 .. 00		.stackfault: 	db "Stack fault:",0 
6c04			 
6c04 .. 00		sfaultsu: 	db	"Stack under flow",0 
6c15 .. 00		sfaultso: 	db	"Stack over flow",0 
6c25 .. 00		sfaultru:	db "RTS underflow",0 
6c33 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6c4d .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6c67 .. 00		sfaultdo:	db "DTS overflow", 0 
6c74			 
6c74			 
6c74			fault_dsp_under: 
6c74 11 86 6c			ld de, .dsp_under 
6c77 c3 3c 6d			jp .show_fault 
6c7a			 
6c7a			fault_rsp_under: 
6c7a 11 94 6c			ld de, .rsp_under 
6c7d c3 3c 6d			jp .show_fault 
6c80			fault_loop_under: 
6c80 11 a2 6c			ld de, .loop_under 
6c83 c3 3c 6d			jp .show_fault 
6c86			 
6c86 .. 00		.dsp_under: db "DSP Underflow",0 
6c94 .. 00		.rsp_under: db "RSP Underflow",0 
6ca2 .. 00		.loop_under: db "LOOP Underflow",0 
6cb1			 
6cb1			 
6cb1 d5			type_faultn: 	push de 
6cb2 e5					push hl 
6cb3 cd a7 0d				call clear_display 
6cb6 11 e0 6c				   ld de, .typefaultn 
6cb9 3e 00				ld a, display_row_1 
6cbb cd ba 0d				call str_at_display 
6cbe 11 a6 fd				    ld de, debug_mark 
6cc1 3e 11				ld a, display_row_1+17 
6cc3 cd ba 0d				call str_at_display 
6cc6 cd ca 0d				call update_display 
6cc9			 
6cc9				; prompt before entering montior for investigating issue 
6cc9			 
6cc9 3e 78			ld a, display_row_4 
6ccb 11 21 1d			ld de, endprog 
6cce			 
6cce cd ca 0d			call update_display		 
6cd1			 
6cd1 cd a7 1f			call next_page_prompt 
6cd4			 
6cd4 e5					push hl 
6cd5 d5					push de 
6cd6 cd 75 1d				call monitor 
6cd9 cd 90 23				call forth_warmstart 
6cdc c3 71 1c				jp warmstart_afterauto 
6cdf 76					halt 
6ce0			 
6ce0			 
6ce0 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6cf7			 
6cf7 d5			type_faults: 	push de 
6cf8 e5					push hl 
6cf9 cd a7 0d				call clear_display 
6cfc 11 25 6d				   ld de, .typefaults 
6cff 3e 00				ld a, display_row_1 
6d01 cd ba 0d				call str_at_display 
6d04 11 a6 fd				    ld de, debug_mark 
6d07 3e 11				ld a, display_row_1+17 
6d09 cd ba 0d				call str_at_display 
6d0c cd ca 0d				call update_display 
6d0f			 
6d0f				; prompt before entering montior for investigating issue 
6d0f			 
6d0f 3e 78			ld a, display_row_4 
6d11 11 21 1d			ld de, endprog 
6d14			 
6d14 cd ca 0d			call update_display		 
6d17			 
6d17 cd a7 1f			call next_page_prompt 
6d1a			 
6d1a e1					pop hl 
6d1b d1					pop de 
6d1c cd 75 1d				call monitor 
6d1f cd 90 23				call forth_warmstart 
6d22 c3 71 1c				jp warmstart_afterauto 
6d25			 
6d25			 
6d25 .. 00		.typefaults: db "STR Type Expected TOS!",0 
6d3c			 
6d3c			.show_fault: 	 
6d3c d5					push de 
6d3d cd a7 0d				call clear_display 
6d40 d1					pop de 
6d41 3e 00				ld a, display_row_1 
6d43 cd ba 0d				call str_at_display 
6d46 11 a6 fd				    ld de, debug_mark 
6d49 3e 11				ld a, display_row_1+17 
6d4b cd ba 0d				call str_at_display 
6d4e cd ca 0d				call update_display 
6d51			 
6d51				; prompt before entering montior for investigating issue 
6d51			 
6d51 3e 78			ld a, display_row_4 
6d53 11 21 1d			ld de, endprog 
6d56			 
6d56 cd ca 0d			call update_display		 
6d59			 
6d59 cd a7 1f			call next_page_prompt 
6d5c			 
6d5c e1					pop hl 
6d5d d1					pop de 
6d5e cd 75 1d				call monitor 
6d61			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6d61			; TODO Make optional fault restart to cli or warm boot? 
6d61					;jp warmstart 
6d61 c3 b5 1c				jp cli 
6d64 76					halt 
6d65			 
6d65			; handle the auto run of code from files in storage 
6d65			 
6d65			 
6d65			include "forth_startup.asm" 
6d65			; Which startup method to use? 
6d65			; 
6d65			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
6d65			; followed by loading of a list of scripts in eeprom 
6d65			 
6d65			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
6d65			; from eeprom 
6d65			 
6d65			; Select with define in main stubs 
6d65			 
6d65			if STARTUP_V1 
6d65				include "forth_startupv1.asm" 
6d65			endif 
6d65			if STARTUP_V2 
6d65				include "forth_startupv2.asm" 
6d65			; Version 2 of the startup  
6d65			;  
6d65			; Auto load any files in bank 1 that start with a '*' 
6d65			; If no se storage then revert to using eprom 
6d65			 
6d65			 
6d65			if STORAGE_SE = 0 
6d65			 
6d65			sprompt1: db "Startup load...",0 
6d65			sprompt2: db "Run? 1=No *=End #=All",0 
6d65			 
6d65			 
6d65			 
6d65			 
6d65			forth_startup: 
6d65				ld hl, startcmds 
6d65				ld a, 0 
6d65				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6d65			 
6d65			.start1:	push hl 
6d65				call clear_display 
6d65				ld de, sprompt1 
6d65			        ld a, display_row_1 
6d65				call str_at_display 
6d65				ld de, sprompt2 
6d65			        ld a, display_row_2 
6d65				call str_at_display 
6d65				pop hl 
6d65				push hl 
6d65				ld e,(hl) 
6d65				inc hl 
6d65				ld d,(hl) 
6d65			        ld a, display_row_3 
6d65				call str_at_display 
6d65				call update_display 
6d65			 
6d65			 
6d65				ld a, (os_last_cmd) 
6d65				cp 0 
6d65				jr z, .startprompt 
6d65				call delay250ms 
6d65				jr .startdo 
6d65				 
6d65				 
6d65			 
6d65			.startprompt: 
6d65			 
6d65				ld a,display_row_4 + display_cols - 1 
6d65			        ld de, endprg 
6d65				call str_at_display 
6d65				call update_display 
6d65				call delay1s 
6d65				call cin_wait 
6d65						 
6d65				cp '*' 
6d65				jr z, .startupend1 
6d65				cp '#' 
6d65				jr nz, .startno 
6d65				ld a, 1 
6d65				ld (os_last_cmd),a 
6d65				jr .startdo 
6d65			.startno:	cp '1' 
6d65				jr z,.startnxt  
6d65			 
6d65				; exec startup line 
6d65			.startdo:	 
6d65				pop hl 
6d65				push hl 
6d65				 
6d65				ld e,(hl) 
6d65				inc hl 
6d65				ld d,(hl) 
6d65				ex de,hl 
6d65			 
6d65				push hl 
6d65			 
6d65				ld a, 0 
6d65				;ld a, FORTH_END_BUFFER 
6d65				call strlent 
6d65				inc hl   ; include zero term to copy 
6d65				ld b,0 
6d65				ld c,l 
6d65				pop hl 
6d65				ld de, scratch 
6d65				ldir 
6d65			 
6d65			 
6d65				ld hl, scratch 
6d65				call forthparse 
6d65				call forthexec 
6d65				call forthexec_cleanup 
6d65			 
6d65				ld a, display_row_4 
6d65				ld de, endprog 
6d65			 
6d65				call update_display		 
6d65			 
6d65				ld a, (os_last_cmd) 
6d65				cp 0 
6d65				jr nz, .startnxt 
6d65				call next_page_prompt 
6d65			        call clear_display 
6d65				call update_display		 
6d65			 
6d65				; move onto next startup line? 
6d65			.startnxt: 
6d65			 
6d65				call delay250ms 
6d65				pop hl 
6d65			 
6d65				inc hl 
6d65				inc hl 
6d65			 
6d65				push hl 
6d65				ld e, (hl) 
6d65				inc hl 
6d65				ld d, (hl) 
6d65				pop hl 
6d65				; TODO replace 0 test 
6d65			 
6d65				ex de, hl 
6d65				call ishlzero 
6d65			;	ld a,e 
6d65			;	add d 
6d65			;	cp 0    ; any left to do? 
6d65				ex de, hl 
6d65				jp nz, .start1 
6d65				jr .startupend 
6d65			 
6d65			.startupend1: pop hl 
6d65			.startupend: 
6d65			 
6d65				call clear_display 
6d65				call update_display 
6d65				ret 
6d65			endif 
6d65			 
6d65			 
6d65			if STORAGE_SE 
6d65			 
6d65			;sprompt3: db "Loading from start-up file:",0 
6d65 .. 00		sprompt3: db "  Searching...",0 
6d74			;sprompt4: db "(Any key to stop)",0 
6d74			 
6d74			 
6d74			forth_autoload: 
6d74			 
6d74				; load block 0 of store 1 
6d74				 
6d74 3e fe			ld a, $fe      ; bit 0 clear 
6d76 32 9b f9			ld (spi_device), a 
6d79			 
6d79 cd 22 05			call storage_get_block_0 
6d7c			 
6d7c 3a d6 f9			ld a, (store_page+STORE_0_AUTOFILE) 
6d7f			 
6d7f fe 00			cp 0 
6d81 c8				ret z     ; auto start not enabled 
6d82			 
6d82 cd a7 0d			call clear_display 
6d85			 
6d85				; set bank 
6d85			 
6d85 3a d8 f9				ld a, (store_page+STORE_0_BANKRUN) 
6d88 32 9b f9				ld (spi_device), a 
6d8b			 
6d8b			 
6d8b				; generate a directory of bank 1 and search for flagged files 
6d8b			 
6d8b					if DEBUG_FORTH_WORDS_KEY 
6d8b						DMARK "DIR" 
6d8b f5				push af  
6d8c 3a a0 6d			ld a, (.dmark)  
6d8f 32 a6 fd			ld (debug_mark),a  
6d92 3a a1 6d			ld a, (.dmark+1)  
6d95 32 a7 fd			ld (debug_mark+1),a  
6d98 3a a2 6d			ld a, (.dmark+2)  
6d9b 32 a8 fd			ld (debug_mark+2),a  
6d9e 18 03			jr .pastdmark  
6da0 ..			.dmark: db "DIR"  
6da3 f1			.pastdmark: pop af  
6da4			endm  
# End of macro DMARK
6da4						CALLMONITOR 
6da4 cd aa fd			call debug_vector  
6da7				endm  
# End of macro CALLMONITOR
6da7					endif 
6da7			 
6da7 cd 22 05			call storage_get_block_0 
6daa			 
6daa 21 b5 f9			ld hl, store_page     ; get current id count 
6dad 46				ld b, (hl) 
6dae 0e 00			ld c, 0    ; count of files   
6db0					if DEBUG_FORTH_WORDS 
6db0						DMARK "DI1" 
6db0 f5				push af  
6db1 3a c5 6d			ld a, (.dmark)  
6db4 32 a6 fd			ld (debug_mark),a  
6db7 3a c6 6d			ld a, (.dmark+1)  
6dba 32 a7 fd			ld (debug_mark+1),a  
6dbd 3a c7 6d			ld a, (.dmark+2)  
6dc0 32 a8 fd			ld (debug_mark+2),a  
6dc3 18 03			jr .pastdmark  
6dc5 ..			.dmark: db "DI1"  
6dc8 f1			.pastdmark: pop af  
6dc9			endm  
# End of macro DMARK
6dc9						CALLMONITOR 
6dc9 cd aa fd			call debug_vector  
6dcc				endm  
# End of macro CALLMONITOR
6dcc					endif 
6dcc			 
6dcc				; check for empty drive 
6dcc			 
6dcc 3e 00			ld a, 0 
6dce b8				cp b 
6dcf ca 1c 6e			jp z, .dirdone 
6dd2			 
6dd2				; for each of the current ids do a search for them and if found push to stack 
6dd2			 
6dd2 c5			.diritem:	push bc 
6dd3 21 40 00				ld hl, STORE_BLOCK_PHY 
6dd6 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
6dd8 58					ld e,b 
6dd9			 
6dd9 d5					push de 
6dda e5					push hl 
6ddb cd a7 0d			call clear_display 
6dde 3e 32			ld a, display_row_2 + 10 
6de0 11 65 6d			ld de, sprompt3 
6de3 cd ba 0d			call str_at_display 
6de6 cd fe 0c			call active 
6de9 eb				ex de, hl 
6dea 3e 2f			ld a, display_row_2 + 7 
6dec cd ba 0d			call str_at_display 
6def cd ca 0d			call update_display 
6df2 e1				pop hl 
6df3 d1				pop de 
6df4			 
6df4			;		if DEBUG_FORTH_WORDS 
6df4			;			DMARK "DI2" 
6df4			;			CALLMONITOR 
6df4			;		endif 
6df4			 
6df4 cd a4 07				call storage_findnextid 
6df7			 
6df7			;		if DEBUG_FORTH_WORDS 
6df7			;			DMARK "DI3" 
6df7			;			CALLMONITOR 
6df7			;		endif 
6df7			 
6df7					; if found hl will be non zero 
6df7			 
6df7 cd 04 10				call ishlzero 
6dfa			;		ld a, l 
6dfa			;		add h 
6dfa			; 
6dfa			;		cp 0 
6dfa 28 1d				jr z, .dirnotfound 
6dfc			 
6dfc					; increase count 
6dfc			 
6dfc c1					pop bc	 
6dfd 0c					inc c 
6dfe c5					push bc 
6dff					 
6dff			 
6dff					; get file header and push the file name 
6dff			 
6dff 11 b5 f9				ld de, store_page 
6e02 cd 71 04				call storage_read_block 
6e05			 
6e05					; push file id to stack 
6e05				 
6e05			 
6e05					; is this a file we want to run? 
6e05			 
6e05 21 b8 f9				ld hl, store_page+3 
6e08 7e					ld a,(hl) 
6e09 fe 2a				cp '*' 
6e0b 20 0c				jr nz,  .dirnotfound 
6e0d					 
6e0d			 
6e0d			 
6e0d 3a b5 f9				ld a, (store_page) 
6e10 d5					push de 
6e11 e5					push hl 
6e12 c5					push bc 
6e13 cd 3f 6e				call .autorunf 
6e16 c1					pop bc 
6e17 e1					pop hl 
6e18 d1					pop de 
6e19			 
6e19			 
6e19			 
6e19				; save this extent 
6e19			 
6e19					; push file name 
6e19			;display file name to run 
6e19			 
6e19			;		ld hl, store_page+3 
6e19			;		if DEBUG_FORTH_WORDS 
6e19			;			DMARK "DI5" 
6e19			;			CALLMONITOR 
6e19			;		endif 
6e19			; 
6e19			;		 
6e19			; 
6e19			;		call forth_push_str 
6e19			;		if DEBUG_FORTH_WORDS 
6e19			;			DMARK "DI6" 
6e19			;			CALLMONITOR 
6e19			;		endif 
6e19			.dirnotfound: 
6e19 c1					pop bc     
6e1a 10 b6				djnz .diritem 
6e1c				 
6e1c			.dirdone:	 
6e1c					if DEBUG_FORTH_WORDS 
6e1c						DMARK "DI7" 
6e1c f5				push af  
6e1d 3a 31 6e			ld a, (.dmark)  
6e20 32 a6 fd			ld (debug_mark),a  
6e23 3a 32 6e			ld a, (.dmark+1)  
6e26 32 a7 fd			ld (debug_mark+1),a  
6e29 3a 33 6e			ld a, (.dmark+2)  
6e2c 32 a8 fd			ld (debug_mark+2),a  
6e2f 18 03			jr .pastdmark  
6e31 ..			.dmark: db "DI7"  
6e34 f1			.pastdmark: pop af  
6e35			endm  
# End of macro DMARK
6e35						CALLMONITOR 
6e35 cd aa fd			call debug_vector  
6e38				endm  
# End of macro CALLMONITOR
6e38					endif 
6e38			 
6e38 cd a7 0d				call clear_display 
6e3b cd ca 0d				call update_display 
6e3e			 
6e3e c9					ret 
6e3f			 
6e3f			 
6e3f			 
6e3f			 
6e3f			 
6e3f			.autorunf: 
6e3f			 
6e3f			 
6e3f				; get file id to load from and get the file name to display 
6e3f			 
6e3f			;		ld a, (store_page+STORE_0_FILERUN) 
6e3f			 
6e3f 2e 00				ld l, 0 
6e41 67					ld h, a 
6e42 11 b5 f9				ld de, store_page 
6e45			 
6e45					if DEBUG_FORTH_WORDS 
6e45						DMARK "ASp" 
6e45 f5				push af  
6e46 3a 5a 6e			ld a, (.dmark)  
6e49 32 a6 fd			ld (debug_mark),a  
6e4c 3a 5b 6e			ld a, (.dmark+1)  
6e4f 32 a7 fd			ld (debug_mark+1),a  
6e52 3a 5c 6e			ld a, (.dmark+2)  
6e55 32 a8 fd			ld (debug_mark+2),a  
6e58 18 03			jr .pastdmark  
6e5a ..			.dmark: db "ASp"  
6e5d f1			.pastdmark: pop af  
6e5e			endm  
# End of macro DMARK
6e5e						CALLMONITOR 
6e5e cd aa fd			call debug_vector  
6e61				endm  
# End of macro CALLMONITOR
6e61					endif 
6e61 cd ca 09				call storage_read 
6e64			 
6e64					if DEBUG_FORTH_WORDS 
6e64						DMARK "ASr" 
6e64 f5				push af  
6e65 3a 79 6e			ld a, (.dmark)  
6e68 32 a6 fd			ld (debug_mark),a  
6e6b 3a 7a 6e			ld a, (.dmark+1)  
6e6e 32 a7 fd			ld (debug_mark+1),a  
6e71 3a 7b 6e			ld a, (.dmark+2)  
6e74 32 a8 fd			ld (debug_mark+2),a  
6e77 18 03			jr .pastdmark  
6e79 ..			.dmark: db "ASr"  
6e7c f1			.pastdmark: pop af  
6e7d			endm  
# End of macro DMARK
6e7d						CALLMONITOR 
6e7d cd aa fd			call debug_vector  
6e80				endm  
# End of macro CALLMONITOR
6e80					endif 
6e80			 
6e80 cd 04 10				call ishlzero 
6e83 c8					ret z             ; file not found 
6e84			 
6e84					; display file name we are loading 
6e84			 
6e84 cd a7 0d				call clear_display 
6e87			 
6e87 3e 32				ld a, display_row_2 + 10 
6e89 11 b8 f9				ld de, store_page+3 
6e8c cd ba 0d				call str_at_display 
6e8f				 
6e8f			; 
6e8f			 
6e8f			;	ld a, display_row_1+5 
6e8f			;	ld de, sprompt3 
6e8f			;	call str_at_display 
6e8f			;	ld a, display_row_2+7 
6e8f			;	call active 
6e8f			;	ex de, hl 
6e8f			;;	ld de, sprompt4 
6e8f			;	call str_at_display 
6e8f			; 
6e8f cd ca 0d			call update_display 
6e92			 
6e92			;	call cin_wait 
6e92			;	cp 'n' 
6e92			;	ret z 
6e92			;	cp 'N' 
6e92			;	ret z 
6e92			 
6e92			;	call delay1s 
6e92			 
6e92 3a b7 f9			ld a, (store_page+2) 
6e95 32 a4 f9			ld (store_openmaxext), a    ; save count of ext 
6e98 3e 01			ld a, 1  
6e9a 32 a5 f9			ld (store_openext), a    ; save count of ext 
6e9d			 
6e9d			.autof: 
6e9d				; begin to read a line from file 
6e9d			 
6e9d 21 23 f4			ld hl, os_cli_cmd 
6ea0 22 21 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
6ea3			  
6ea3			.readext: 
6ea3 3a a5 f9			ld a, (store_openext) 
6ea6 6f				ld l , a 
6ea7				 
6ea7 3a b5 f9			ld a, (store_page) 
6eaa 67				ld h, a	 
6eab 11 b5 f9			ld de, store_page 
6eae					if DEBUG_FORTH_WORDS 
6eae						DMARK "ASl" 
6eae f5				push af  
6eaf 3a c3 6e			ld a, (.dmark)  
6eb2 32 a6 fd			ld (debug_mark),a  
6eb5 3a c4 6e			ld a, (.dmark+1)  
6eb8 32 a7 fd			ld (debug_mark+1),a  
6ebb 3a c5 6e			ld a, (.dmark+2)  
6ebe 32 a8 fd			ld (debug_mark+2),a  
6ec1 18 03			jr .pastdmark  
6ec3 ..			.dmark: db "ASl"  
6ec6 f1			.pastdmark: pop af  
6ec7			endm  
# End of macro DMARK
6ec7						CALLMONITOR 
6ec7 cd aa fd			call debug_vector  
6eca				endm  
# End of macro CALLMONITOR
6eca					endif 
6eca cd ca 09				call storage_read 
6ecd cd 04 10			call ishlzero 
6ed0 c8				ret z 
6ed1			 
6ed1			; TODO copy to exec buffer 
6ed1			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
6ed1			 
6ed1				; copy the record buffer to the cli buffer 
6ed1			 
6ed1 ed 5b 21 f6		ld de, (os_var_array) 
6ed5 21 b7 f9			ld hl, store_page+2 
6ed8			;	ex de, hl 
6ed8 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
6edb ed b0			ldir 
6edd ed 53 21 f6		ld (os_var_array), de 
6ee1				 
6ee1 3a a5 f9			ld a, (store_openext) 
6ee4 3c				inc a 
6ee5 32 a5 f9			ld (store_openext), a    ; save count of ext 
6ee8			 
6ee8			 
6ee8			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
6ee8				 
6ee8 3a a8 f9			ld a, (store_readcont) 
6eeb fe 00			cp 0 
6eed 20 b4			jr nz, .readext 
6eef			 
6eef			;	jr z, .autoend 
6eef			 
6eef					if DEBUG_FORTH_WORDS 
6eef						DMARK "ASc" 
6eef f5				push af  
6ef0 3a 04 6f			ld a, (.dmark)  
6ef3 32 a6 fd			ld (debug_mark),a  
6ef6 3a 05 6f			ld a, (.dmark+1)  
6ef9 32 a7 fd			ld (debug_mark+1),a  
6efc 3a 06 6f			ld a, (.dmark+2)  
6eff 32 a8 fd			ld (debug_mark+2),a  
6f02 18 03			jr .pastdmark  
6f04 ..			.dmark: db "ASc"  
6f07 f1			.pastdmark: pop af  
6f08			endm  
# End of macro DMARK
6f08						CALLMONITOR 
6f08 cd aa fd			call debug_vector  
6f0b				endm  
# End of macro CALLMONITOR
6f0b					endif 
6f0b e5				push hl	 
6f0c d5				push de 
6f0d cd fe 0c			call active 
6f10 eb				ex de, hl 
6f11 3e 2f			ld a, display_row_2 + 7 
6f13 cd ba 0d			call str_at_display 
6f16			 
6f16 cd ca 0d			call update_display 
6f19 d1				pop de  
6f1a e1				pop hl 
6f1b			;	call delay250ms 
6f1b			 
6f1b			 
6f1b			 
6f1b			 
6f1b			.autoexec: 
6f1b			 
6f1b			 
6f1b 21 23 f4			ld hl, os_cli_cmd 
6f1e					if DEBUG_FORTH_WORDS 
6f1e						DMARK "ASx" 
6f1e f5				push af  
6f1f 3a 33 6f			ld a, (.dmark)  
6f22 32 a6 fd			ld (debug_mark),a  
6f25 3a 34 6f			ld a, (.dmark+1)  
6f28 32 a7 fd			ld (debug_mark+1),a  
6f2b 3a 35 6f			ld a, (.dmark+2)  
6f2e 32 a8 fd			ld (debug_mark+2),a  
6f31 18 03			jr .pastdmark  
6f33 ..			.dmark: db "ASx"  
6f36 f1			.pastdmark: pop af  
6f37			endm  
# End of macro DMARK
6f37						CALLMONITOR 
6f37 cd aa fd			call debug_vector  
6f3a				endm  
# End of macro CALLMONITOR
6f3a					endif 
6f3a cd 38 24			call forthparse 
6f3d cd 78 24			call forthexec 
6f40 cd 8a 23			call forthexec_cleanup 
6f43			 
6f43			 
6f43			 
6f43 c3 9d 6e			jp .autof 
6f46			;.autofdone: 
6f46			; 
6f46			;		if DEBUG_FORTH_WORDS 
6f46			;			DMARK "ASx" 
6f46			;			CALLMONITOR 
6f46			;		endif 
6f46			;;	call clear_display 
6f46			;	ret 
6f46			 
6f46			 
6f46			 
6f46			endif 
# End of file forth_startupv2.asm
6f46			endif 
6f46			 
# End of file forth_startup.asm
6f46			 
6f46			; eof 
# End of file forth_kernel.asm
6f46			;include "nascombasic.asm" 
6f46			 
6f46			 
6f46			; find out where the code ends if loaded into RAM (for SC114) 
6f46			;endofcode:  
6f46			;	nop 
6f46			 
6f46			 
6f46			; jump to nmi vector 
6f46			 
6f46			init_nmi: 
6f46 3e c9			ld a, $c9   ; RET 
6f48 32 ad fd			ld (nmi_vector), a 
6f4b c9				ret 
6f4c			nmi: 
6f4c e5				push hl 
6f4d d5				push de 
6f4e c5				push bc 
6f4f f5				push af 
6f50 cd ad fd			call nmi_vector 
6f53 f5				push af 
6f54 c5				push bc 
6f55 d5				push de 
6f56 e5				push hl 
6f57 ed 4d			reti 
6f59			 
6f59			 
6f59			; eof 
6f59			 
# End of file main.asm
6f59			include "firmware_lcd_4x40.asm" 
6f59			; **********************************************************************  
6f59			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6f59			; **********************************************************************  
6f59			;  
6f59			; **  Written as a Small Computer Monitor App  
6f59			; **  www.scc.me.uk  
6f59			;  
6f59			; History  
6f59			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6f59			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6f59			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6f59			;  
6f59			; **********************************************************************  
6f59			;  
6f59			; This program is an example of one of the methods of interfacing an   
6f59			; alphanumeric LCD module.   
6f59			;  
6f59			; In this example the display is connected to either a Z80 PIO or a   
6f59			; simple 8-bit output port.   
6f59			;  
6f59			; This interfacing method uses 4-bit data mode and uses time delays  
6f59			; rather than polling the display's ready status. As a result the   
6f59			; interface only requires 6 simple output lines:  
6f59			;   Output bit 0 = not used  
6f59			;   Output bit 1 = not used  
6f59			;   Output bit 2 = RS         High = data, Low = instruction  
6f59			;   Output bit 3 = E          Active high  
6f59			;   Output bit 4 = DB4  
6f59			;   Output bit 5 = DB5  
6f59			;   Output bit 6 = DB6  
6f59			;   Output bit 7 = DB7  
6f59			; Display's R/W is connected to 0v so it is always in write mode  
6f59			;  
6f59			; This set up should work with any system supporting the RC2014 bus  
6f59			  
6f59			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6f59			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6f59			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6f59			;  
6f59			; **********************************************************************  
6f59			  
6f59			; Additonal for 4x40. E1 and E2 instead of just E   
6f59			; TODO swipe vidout signal on port a to activate E2  
6f59			  
6f59			; **********************************************************************  
6f59			; **  Constants  
6f59			; **********************************************************************  
6f59			; LCD constants required by LCD support module  
6f59			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6f59			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6f59			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
6f59			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
6f59			; TODO Decide which E is being set  
6f59			kLCDWidth:  EQU display_cols             ;Width in characters  
6f59			  
6f59			; **********************************************************************  
6f59			; **  Code library usage  
6f59			; **********************************************************************  
6f59			  
6f59			; send character to current cursor position  
6f59			; wraps and/or scrolls screen automatically  
6f59			  
6f59			  
6f59			  
6f59			lcd_init:  
6f59			  
6f59			; SCMonAPI functions used  
6f59			  
6f59			; Alphanumeric LCD functions used  
6f59			; no need to specify specific functions for this module  
6f59			  
6f59 3e cf		            LD   A, 11001111b  
6f5b d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6f5d 3e 00		            LD   A, 00000000b  
6f5f d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6f61			  
6f61			; Initialise alphanumeric LCD module  
6f61 3e 00				ld a, 0  
6f63 32 06 fb				ld (display_lcde1e2), a  
6f66 cd e7 6f		            CALL fLCD_Init      ;Initialise LCD module  
6f69 3e 01				ld a, 1  
6f6b 32 06 fb				ld (display_lcde1e2), a  
6f6e cd e7 6f		            CALL fLCD_Init      ;Initialise LCD module  
6f71			  
6f71 c9				ret  
6f72			  
6f72			;  
6f72			;;  
6f72			; lcd functions  
6f72			;  
6f72			;  
6f72			  
6f72			; what is at cursor position   
6f72			  
6f72			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6f72			;		call curptr  
6f72			;		ret  
6f72			  
6f72			  
6f72			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6f72			  
6f72			curptr:  
6f72 c5				push bc  
6f73 21 ec fc			ld hl, display_fb0  
6f76			cpr:	  
6f76				; loop for cursor whole row  
6f76 0e 28			ld c, display_cols  
6f78 23			cpr1:	inc hl  
6f79 0d				dec c  
6f7a 20 fc			jr nz, cpr1  
6f7c 05				dec b  
6f7d 20 f7			jr nz, cpr  
6f7f			  
6f7f				; add col	  
6f7f			  
6f7f 23			cpr2:	inc hl  
6f80 1d				dec e  
6f81 20 fc			jr nz, cpr2  
6f83			  
6f83 c1				pop bc  
6f84 c9				ret  
6f85				  
6f85			  
6f85			  
6f85			  
6f85			  
6f85			; write the frame buffer given in hl to hardware   
6f85 22 04 fb		write_display: ld (display_write_tmp), hl 	   
6f88 3e 00			ld a, kLCD_Line1  
6f8a cd 94 70		            CALL fLCD_Pos       ;Position cursor to location in A  
6f8d 06 28			ld b, display_cols  
6f8f ed 5b 04 fb		ld de, (display_write_tmp)  
6f93 cd df 6f			call write_len_string  
6f96				  
6f96				  
6f96 2a 04 fb			ld hl, (display_write_tmp)  
6f99 11 28 00			ld de, display_cols  
6f9c 19				add hl,de  
6f9d 22 04 fb			ld (display_write_tmp),hl  
6fa0			  
6fa0				  
6fa0 3e 28			ld a, kLCD_Line2  
6fa2 cd 94 70		            CALL fLCD_Pos       ;Position cursor to location in A  
6fa5 06 28			ld b, display_cols  
6fa7 ed 5b 04 fb		ld de, (display_write_tmp)  
6fab cd df 6f			call write_len_string  
6fae				  
6fae 2a 04 fb			ld hl, (display_write_tmp)  
6fb1 11 28 00			ld de, display_cols  
6fb4 19				add hl,de  
6fb5 22 04 fb			ld (display_write_tmp),hl  
6fb8			  
6fb8				  
6fb8 3e 50			ld a, kLCD_Line3  
6fba cd 94 70		            CALL fLCD_Pos       ;Position cursor to location in A  
6fbd 06 28			ld b, display_cols  
6fbf ed 5b 04 fb		ld de, (display_write_tmp)  
6fc3 cd df 6f			call write_len_string  
6fc6				  
6fc6 2a 04 fb			ld hl, (display_write_tmp)  
6fc9 11 28 00			ld de, display_cols  
6fcc 19				add hl,de  
6fcd 22 04 fb			ld (display_write_tmp),hl  
6fd0			  
6fd0				  
6fd0 3e 78			ld a, kLCD_Line4  
6fd2 cd 94 70		            CALL fLCD_Pos       ;Position cursor to location in A  
6fd5 06 28			ld b, display_cols  
6fd7 ed 5b 04 fb		ld de, (display_write_tmp)  
6fdb cd df 6f			call write_len_string  
6fde c9					ret  
6fdf				  
6fdf				; write out a fixed length string given in b from de  
6fdf			  
6fdf 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6fe0 cd 4c 70		            CALL fLCD_Data      ;Write character to display  
6fe3 13				inc de  
6fe4 10 f9			djnz write_len_string  
6fe6 c9				ret  
6fe7			  
6fe7			; Some other things to do  
6fe7			;            LD   A, kLCD_Clear ;Display clear  
6fe7			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6fe7			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6fe7			;            LD   A, kLCD_On     ;Display on with no cursor  
6fe7			;            ;LD   A, kLCD_Off   ;Display off  
6fe7			;            CALL fLCD_Inst      ;Send instruction to display  
6fe7			;  
6fe7			;  
6fe7			;            halt  
6fe7			;  
6fe7			;  
6fe7			;MsgHello:   DB  "Hello World!",0  
6fe7			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6fe7			  
6fe7			; Custom characters 5 pixels wide by 8 pixels high  
6fe7			; Up to 8 custom characters can be defined  
6fe7			;BitMaps:      
6fe7			;; Character 0x00 = Battery icon  
6fe7			;            DB  01110b  
6fe7			;            DB  11011b  
6fe7			;            DB  10001b  
6fe7			;            DB  10001b  
6fe7			;            DB  11111b  
6fe7			;            DB  11111b  
6fe7			;            DB  11111b  
6fe7			;            DB  11111b  
6fe7			;; Character 0x01 = Bluetooth icon  
6fe7			;            DB  01100b  
6fe7			;            DB  01010b  
6fe7			;            DB  11100b  
6fe7			;            DB  01000b  
6fe7			;            DB  11100b  
6fe7			;            DB  01010b  
6fe7			;            DB  01100b  
6fe7			;            DB  00000b  
6fe7			;  
6fe7			  
6fe7			  
6fe7			; **********************************************************************  
6fe7			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6fe7			; **********************************************************************  
6fe7			;  
6fe7			; **  Written as a Small Computer Monitor App   
6fe7			; **  Version 0.1 SCC 2018-05-16  
6fe7			; **  www.scc.me.uk  
6fe7			;  
6fe7			; **********************************************************************  
6fe7			;  
6fe7			; This module provides support for alphanumeric LCD modules using with  
6fe7			; *  HD44780 (or compatible) controller  
6fe7			; *  5 x 7 pixel fonts  
6fe7			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6fe7			; *  Interface via six digital outputs to the display (see below)  
6fe7			;  
6fe7			; LCD module pinout:  
6fe7			;   1  Vss   0v supply  
6fe7			;   2  Vdd   5v supply  
6fe7			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6fe7			;   4  RS    High = data, Low = instruction  
6fe7			;   5  R/W   High = Read, Low = Write  
6fe7			;   6  E     Enable signal (active high)  
6fe7			;   7  DB0   Data bit 0  
6fe7			;   8  DB1   Data bit 1  
6fe7			;   9  DB2   Data bit 2  
6fe7			;  10  DB3   Data bit 3  
6fe7			;  11  DB4   Data bit 4  
6fe7			;  12  DB5   Data bit 5  
6fe7			;  13  DB6   Data bit 6  
6fe7			;  14  DB7   Data bit 7  
6fe7			;  15  A     Backlight anode (+)  
6fe7			;  16  K     Backlight cathode (-)  
6fe7			;  
6fe7			; This interfacing method uses 4-bit data mode and uses time delays  
6fe7			; rather than polling the display's ready status. As a result the   
6fe7			; interface only requires 6 simple output lines:  
6fe7			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6fe7			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6fe7			;   LCD DB4 = Microcomputer output port bit 4  
6fe7			;   LCD DB5 = Microcomputer output port bit 5  
6fe7			;   LCD DB6 = Microcomputer output port bit 6  
6fe7			;   LCD DB7 = Microcomputer output port bit 7  
6fe7			; Display's R/W is connected to 0v so it is always in write mode  
6fe7			; All 6 connections must be on the same port address <kLCDPrt>  
6fe7			; This method also allows a decent length of cable from micro to LCD  
6fe7			;  
6fe7			; **********************************************************************  
6fe7			;  
6fe7			; To include the code for any given function provided by this module,   
6fe7			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6fe7			; the parent source file.  
6fe7			; For example:  #REQUIRES   uHexPrefix  
6fe7			;  
6fe7			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6fe7			; in the parent source file.  
6fe7			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6fe7			;  
6fe7			; These are the function names provided by this module:  
6fe7			; fLCD_Init                     ;Initialise LCD  
6fe7			; fLCD_Inst                     ;Send instruction to LCD  
6fe7			; fLCD_Data                     ;Send data byte to LCD  
6fe7			; fLCD_Pos                      ;Position cursor  
6fe7			; fLCD_Str                      ;Display string  
6fe7			; fLCD_Def                      ;Define custom character  
6fe7			;  
6fe7			; **********************************************************************  
6fe7			;  
6fe7			; Requires SCMonAPI.asm to also be included in the project  
6fe7			;  
6fe7			  
6fe7			  
6fe7			; **********************************************************************  
6fe7			; **  Constants  
6fe7			; **********************************************************************  
6fe7			  
6fe7			; Constants that must be defined externally  
6fe7			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6fe7			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6fe7			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6fe7			;kLCDWidth: EQU 20             ;Width in characters  
6fe7			  
6fe7			; general line offsets in any frame buffer  
6fe7			  
6fe7			  
6fe7			display_row_1: equ 0  
6fe7			display_row_2: equ display_row_1+display_cols  
6fe7			display_row_3: equ display_row_2 + display_cols  
6fe7			display_row_4: equ display_row_3 + display_cols  
6fe7			;display_row_4_eol:   
6fe7			  
6fe7			  
6fe7			; Cursor position values for the start of each line  
6fe7			  
6fe7			; E  
6fe7			kLCD_Line1: EQU 0x00   
6fe7			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
6fe7			; E1  
6fe7			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
6fe7			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
6fe7			  
6fe7			; Instructions to send as A register to fLCD_Inst  
6fe7			kLCD_Clear: EQU 00000001b     ;LCD clear  
6fe7			kLCD_Off:   EQU 00001000b     ;LCD off  
6fe7			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6fe7			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6fe7			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6fe7			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6fe7			  
6fe7			; Constants used by this code module  
6fe7			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6fe7			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6fe7			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6fe7			  
6fe7			  
6fe7			  
6fe7			; **********************************************************************  
6fe7			; **  LCD support functions  
6fe7			; **********************************************************************  
6fe7			  
6fe7			; Initialise alphanumeric LCD module  
6fe7			; LCD control register codes:  
6fe7			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6fe7			;   N    0 = 1-line mode       1 = 2-line mode  
6fe7			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6fe7			;   D    0 = Display off       1 = Display on  
6fe7			;   C    0 = Cursor off        1 = Cursor on  
6fe7			;   B    0 = Blinking off      1 = Blinking on  
6fe7			;   ID   0 = Decrement mode    1 = Increment mode  
6fe7			;   SH   0 = Entire shift off  1 = Entire shift on  
6fe7 3e 28		fLCD_Init:  LD   A, 40  
6fe9 cd 0e 71		            CALL LCDDelay       ;Delay 40ms after power up  
6fec			; For reliable reset set 8-bit mode - 3 times  
6fec cd de 70		            CALL WrFn8bit       ;Function = 8-bit mode  
6fef cd de 70		            CALL WrFn8bit       ;Function = 8-bit mode  
6ff2 cd de 70		            CALL WrFn8bit       ;Function = 8-bit mode  
6ff5			; Set 4-bit mode  
6ff5 cd da 70		            CALL WrFn4bit       ;Function = 4-bit mode  
6ff8 cd 0c 71		            CALL LCDDelay1      ;Delay 37 us or more  
6ffb			; Function set  
6ffb 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6ffd cd 10 70		            CALL fLCD_Inst      ;2 line, display on  
7000			; Display On/Off control  
7000 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
7002 cd 10 70		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
7005			; Display Clear  
7005 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
7007 cd 10 70		            CALL fLCD_Inst      ;Clear display  
700a			; Entry mode  
700a 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
700c cd 10 70		            CALL fLCD_Inst      ;Increment mode, shift off  
700f			; Display module now initialised  
700f c9			            RET  
7010			; ok to here  
7010			  
7010			; Write instruction to LCD  
7010			;   On entry: A = Instruction byte to be written  
7010			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7010 f5			fLCD_Inst:  PUSH AF  
7011 f5			            PUSH AF  
7012 cd 24 70		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
7015 f1			            POP  AF  
7016 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7017 17			            RLA  
7018 17			            RLA  
7019 17			            RLA  
701a cd 24 70		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
701d 3e 02		            LD   A, 2  
701f cd 0e 71		            CALL LCDDelay       ;Delay 2 ms to complete   
7022 f1			            POP  AF  
7023 c9			            RET  
7024			Wr4bits:   
7024 f5					push af  
7025 3a 06 fb				ld a, (display_lcde1e2)  
7028 fe 00				cp 0     ; e  
702a 20 10				jr nz, .wea2	  
702c f1					pop af  
702d e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
702f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7031 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
7033 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
7035 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7037 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
7039 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
703b c9			            RET  
703c f1			.wea2:		pop af  
703d e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
703f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7041 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
7043 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
7045 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7047 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
7049 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
704b c9			            RET  
704c			  
704c			  
704c			; Write data to LCD  
704c			;   On entry: A = Data byte to be written  
704c			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
704c f5			fLCD_Data:  PUSH AF  
704d f5			            PUSH AF  
704e cd 60 70		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7051 f1			            POP  AF  
7052 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7053 17			            RLA  
7054 17			            RLA  
7055 17			            RLA  
7056 cd 60 70		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
7059 3e 96		            LD   A, 150  
705b 3d			Wait:      DEC  A              ;Wait a while to allow data   
705c 20 fd		            JR   NZ, Wait      ;  write to complete  
705e f1			            POP  AF  
705f c9			            RET  
7060			Wr4bitsa:     
7060 f5					push af  
7061 3a 06 fb				ld a, (display_lcde1e2)  
7064 fe 00				cp 0     ; e1  
7066 20 16				jr nz, .we2	  
7068 f1					pop af  
7069 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
706b cb d7		            SET  kLCDBitRS, A  
706d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
706f cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
7071 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
7073 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7075 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
7077 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7079 cb 97		            RES  kLCDBitRS, A  
707b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
707d c9			            RET  
707e f1			.we2:		pop af  
707f e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7081 cb d7		            SET  kLCDBitRS, A  
7083 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7085 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
7087 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
7089 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
708b cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
708d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
708f cb 97		            RES  kLCDBitRS, A  
7091 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7093 c9			            RET  
7094			  
7094			  
7094			; Position cursor to specified location  
7094			;   On entry: A = Cursor position  
7094			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7094 f5			fLCD_Pos:   PUSH AF  
7095					; at this point set the E1 or E2 flag depending on position  
7095			  
7095 c5					push bc  
7096			;		push af  
7096 06 00				ld b, 0  
7098 4f					ld c, a  
7099 3e 4f				ld a, kLCD_Line3-1  
709b b7			 		or a      ;clear carry flag  
709c 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
709d 38 04				jr c, .pe1  
709f			  
709f					; E selection  
709f cb 80				res 0, b         ; bit 0 unset e  
70a1			;		pop af    ; before line 3 so recover orig pos  
70a1			;		ld c, a    ; save for poking back  
70a1 18 06				jr .peset	          
70a3			.pe1:          	; E2 selection  
70a3 cb c0				set 0, b         ; bit 0 set e1  
70a5 79					ld a, c  
70a6 de 4f				sbc a, kLCD_Line3-1  
70a8 4f					ld c, a	         ; save caculated offset  
70a9			;		pop af     ; bin this original value now we have calculated form  
70a9			  
70a9			.peset:		; set bit  
70a9 78					ld a, b  
70aa 32 06 fb				ld (display_lcde1e2), a 	  
70ad 79					ld a, c  
70ae c1					pop bc  
70af			  
70af f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
70b1 cd 10 70		            CALL fLCD_Inst      ;Write instruction to LCD  
70b4 f1			            POP  AF  
70b5 c9			            RET  
70b6			  
70b6			  
70b6			; Output text string to LCD  
70b6			;   On entry: DE = Pointer to null terminated text string  
70b6			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
70b6 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
70b7 b7			            OR   A              ;Null terminator?  
70b8 c8			            RET  Z              ;Yes, so finished  
70b9 cd 4c 70		            CALL fLCD_Data      ;Write character to display  
70bc 13			            INC  DE             ;Point to next character  
70bd 18 f7		            JR   fLCD_Str       ;Repeat  
70bf c9					ret  
70c0			  
70c0			; Define custom character  
70c0			;   On entry: A = Character number (0 to 7)  
70c0			;             DE = Pointer to character bitmap data  
70c0			;   On exit:  A = Next character number  
70c0			;             DE = Next location following bitmap  
70c0			;             BC HL IX IY I AF' BC' DE' HL' preserved  
70c0			; Character is   
70c0 c5			fLCD_Def:   PUSH BC  
70c1 f5			            PUSH AF  
70c2 07			            RLCA                ;Calculate location  
70c3 07			            RLCA                ;  for bitmap data  
70c4 07			            RLCA                ;  = 8 x CharacterNumber  
70c5 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
70c7 cd 10 70		            CALL fLCD_Inst      ;Write instruction to LCD  
70ca 06 00		            LD   B, 0  
70cc 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
70cd cd 4c 70		            CALL fLCD_Data      ;Write byte to display  
70d0 13			            INC  DE             ;Point to next byte  
70d1 04			            INC  B              ;Count bytes  
70d2 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
70d4 28 f6		            JR   Z, Loop       ;No, so repeat  
70d6 f1			            POP  AF  
70d7 3c			            INC  A              ;Increment character number  
70d8 c1			            POP  BC  
70d9 c9			            RET  
70da			  
70da			  
70da			; **********************************************************************  
70da			; **  Private functions  
70da			; **********************************************************************  
70da			  
70da			; Write function to LCD  
70da			;   On entry: A = Function byte to be written  
70da			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
70da 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
70dc 18 02		            JR   WrFunc  
70de 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
70e0 f5			WrFunc:     PUSH AF  
70e1 f5					push af  
70e2 3a 06 fb				ld a, (display_lcde1e2)  
70e5 fe 00				cp 0     ; e1  
70e7 20 0f				jr nz, .wfea2	  
70e9 f1					pop af  
70ea d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70ec cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
70ee cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
70f0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
70f2 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
70f4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70f6 18 0d			jr .wfskip  
70f8 f1			.wfea2:		pop af  
70f9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
70fb cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
70fd cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
70ff d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7101 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7103 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7105 3e 05		.wfskip:            LD  A, 5  
7107 cd 0e 71		            CALL LCDDelay       ;Delay 5 ms to complete  
710a f1			            POP  AF  
710b c9			            RET  
710c			  
710c			  
710c			; Delay in milliseconds  
710c			;   On entry: A = Number of milliseconds delay  
710c			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
710c 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
710e d5			LCDDelay:   PUSH DE  
710f 5f			            LD   E, A           ;Delay by 'A' ms  
7110 16 00		            LD   D, 0  
7112 cd cf 0c		            CALL aDelayInMS  
7115 d1			            POP  DE  
7116 c9			            RET  
7117			  
7117			  
7117			testlcd:  
7117 3e 00			ld a, kLCD_Line1  
7119 cd 94 70			call fLCD_Pos  
711c 06 28			ld b, 40  
711e 11 4c 71			ld de, .ttext1  
7121 cd df 6f			call write_len_string  
7124			  
7124 3e 28			ld a, kLCD_Line2  
7126 cd 94 70			call fLCD_Pos  
7129 06 28			ld b, 40  
712b 11 75 71			ld de, .ttext2  
712e cd df 6f			call write_len_string  
7131 3e 50			ld a, kLCD_Line3  
7133 cd 94 70			call fLCD_Pos  
7136 06 28			ld b, 40  
7138 11 9e 71			ld de, .ttext3  
713b cd df 6f			call write_len_string  
713e 3e 78			ld a, kLCD_Line4  
7140 cd 94 70			call fLCD_Pos  
7143 06 28			ld b, 40  
7145 11 c7 71			ld de, .ttext4  
7148 cd df 6f			call write_len_string  
714b			  
714b 76				halt  
714c			  
714c			  
714c .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
7175 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
719e .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
71c7 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
71f0			   
71f0			  
71f0			  
71f0			; eof  
71f0			  
# End of file firmware_lcd_4x40.asm
71f0			;include "firmware_lcd_4x20.asm" 
71f0			include "firmware_key_5x10.asm" 
71f0			; 5 x 10 decade counter scanner  
71f0			  
71f0			  
71f0			; TODO do cursor shape change for shift keys  
71f0			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
71f0			  
71f0			  
71f0			; bit mask for each scan column and row for teing the matrix  
71f0			  
71f0			  
71f0			key_init:  
71f0			  
71f0			; SCMonAPI functions used  
71f0			  
71f0			; Alphanumeric LCD functions used  
71f0			; no need to specify specific functions for this module  
71f0			  
71f0			  
71f0 3e cf		            LD   A, 11001111b  
71f2 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
71f4			;            LD   A, 00000000b  
71f4 3e 1f		            LD   A, 00011111b  
71f6 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
71f8			  
71f8			  
71f8				; TODO Configure cursor shapes  
71f8			  
71f8				; Load cursor shapes   
71f8 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
71fa 11 0a 72		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
71fd 06 02		            LD   B, 2           ;Number of characters to define  
71ff cd c0 70		.DefLoop:   CALL fLCD_Def       ;Define custom character  
7202 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
7204			  
7204 3e 01				ld a, 1  
7206 32 fc fa			ld (cursor_shape),a  
7209 c9				ret  
720a			  
720a			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
720a			; Up to 8 custom characters can be defined  
720a			.cursor_shapes:      
720a			;; Character 0x00 = Normal  
720a 1f			            DB  11111b  
720b 1f			            DB  11111b  
720c 1f			            DB  11111b  
720d 1f			            DB  11111b  
720e 1f			            DB  11111b  
720f 1f			            DB  11111b  
7210 1f			            DB  11111b  
7211 1f			            DB  11111b  
7212			;; Character 0x01 = Modifier  
7212 1f			            DB  11111b  
7213 1b			            DB  11011b  
7214 1b			            DB  11011b  
7215 1b			            DB  11011b  
7216 1b			            DB  11011b  
7217 1f			            DB  11111b  
7218 1b			            DB  11011b  
7219 1f			            DB  11111b  
721a			  
721a			  
721a			  
721a			  
721a			; Display custom character 0  
721a			;            LD   A, kLCD_Line1+14  
721a			;            CALL fLCD_Pos       ;Position cursor to location in A  
721a			;            LD   A, 0  
721a			;            CALL fLCD_Data      ;Write character in A at cursor  
721a			  
721a			; Display custom character 1  
721a			;            LD   A, kLCD_Line2+14  
721a			;            CALL fLCD_Pos      ;Position cursor to location in A  
721a			;            LD   A, 1  
721a			;            CALL fLCD_Data     ;Write character in A at cursor  
721a			  
721a			; keyboard scanning   
721a			  
721a			; character in from keyboard  
721a			  
721a			; mapping for the pcb layout  
721a			  
721a			.matrix_to_char:  
721a .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
7225 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
7230 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
723b 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7246 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7251			.matrix_to_shift:  
7251			  
7251 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
725c .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
7267 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7272 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
727d .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
7288			  
7288			.matrix_to_symbolshift:  
7288			  
7288 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7293 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
729e 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
72a9			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
72a9 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
72b4 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
72bf			  
72bf			  
72bf			  
72bf			; mapping for a simple straight through breadboard layout  
72bf			  
72bf			;.matrix_to_char:  
72bf			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
72bf			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
72bf			;		db "asdfghjkl",KEY_CR,0  
72bf			;		db "qwertyuiop",0  
72bf			;		 db "1234567890",0  
72bf			;.matrix_to_shift:  
72bf			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
72bf			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
72bf			;		db "ASDFGHJKL",KEY_CR,0  
72bf			;		db "QWERTYUIOP",0  
72bf			;		 db "!",'"',"#$%^&*()",0  
72bf			;.matrix_to_symbolshift:  
72bf			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
72bf			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
72bf			;		db "_?*fghjk=",KEY_CR,0  
72bf			;		db "-/+*[]{}@#",0  
72bf			;		 db "1234567890",0  
72bf			  
72bf			;.matrix_to_char: db "D#0*C987B654A321"  
72bf			  
72bf			  
72bf				  
72bf			  
72bf			; add cin and cin_wait  
72bf			  
72bf cd d0 72		cin_wait: 	call cin  
72c2						if DEBUG_KEYCINWAIT  
72c2							push af  
72c2							  
72c2							ld hl,key_repeat_ct  
72c2							ld (hl),a  
72c2							inc hl  
72c2							call hexout  
72c2							ld hl,key_repeat_ct+3  
72c2							ld a,0  
72c2							ld (hl),a  
72c2			  
72c2							    LD   A, kLCD_Line1+11  
72c2							    CALL fLCD_Pos       ;Position cursor to location in A  
72c2							    LD   DE, key_repeat_ct  
72c2							    ;LD   DE, MsgHello  
72c2							    CALL fLCD_Str       ;Display string pointed to by DE  
72c2			  
72c2			  
72c2			  
72c2							pop af  
72c2						endif  
72c2 fe 00			cp 0  
72c4 28 f9			jr z, cin_wait   ; block until key press  
72c6			  
72c6							if DEBUG_KEYCINWAIT  
72c6								push af  
72c6			  
72c6								ld a, 'A'	  
72c6								ld hl,key_repeat_ct  
72c6								ld (hl),a  
72c6								inc hl  
72c6								ld a,0  
72c6								ld (hl),a  
72c6			  
72c6								    LD   A, kLCD_Line2+11  
72c6								    CALL fLCD_Pos       ;Position cursor to location in A  
72c6								    LD   DE, key_repeat_ct  
72c6								    ;LD   DE, MsgHello  
72c6								    CALL fLCD_Str       ;Display string pointed to by DE  
72c6			  
72c6							call delay500ms  
72c6			  
72c6								pop af  
72c6							endif  
72c6 f5				push af   ; save key pressed  
72c7			  
72c7			.cin_wait1:	  
72c7							if DEBUG_KEYCINWAIT  
72c7								push af  
72c7			  
72c7								ld a, 'b'	  
72c7								ld hl,key_repeat_ct  
72c7								ld (hl),a  
72c7								inc hl  
72c7								ld a,0  
72c7								ld (hl),a  
72c7			  
72c7								    LD   A, kLCD_Line2+11  
72c7								    CALL fLCD_Pos       ;Position cursor to location in A  
72c7								    LD   DE, key_repeat_ct  
72c7								    ;LD   DE, MsgHello  
72c7								    CALL fLCD_Str       ;Display string pointed to by DE  
72c7			  
72c7			  
72c7							call delay500ms  
72c7			  
72c7								pop af  
72c7							endif  
72c7			  
72c7 cd d0 72		call cin  
72ca fe 00			cp 0  
72cc 20 f9			jr nz, .cin_wait1  	; wait for key release  
72ce			if DEBUG_KEYCINWAIT  
72ce				push af  
72ce			  
72ce				ld a, '3'	  
72ce				ld hl,key_repeat_ct  
72ce				ld (hl),a  
72ce				inc hl  
72ce				ld a,0  
72ce				ld (hl),a  
72ce			  
72ce			            LD   A, kLCD_Line2+11  
72ce			            CALL fLCD_Pos       ;Position cursor to location in A  
72ce			            LD   DE, key_repeat_ct  
72ce			            ;LD   DE, MsgHello  
72ce			            CALL fLCD_Str       ;Display string pointed to by DE  
72ce			  
72ce			  
72ce			call delay500ms  
72ce			  
72ce				pop af  
72ce			endif  
72ce			  
72ce f1				pop af   ; get key  
72cf c9				ret  
72d0			  
72d0			  
72d0 cd e4 72		cin: 	call .mtoc  
72d3			  
72d3			if DEBUG_KEYCIN  
72d3				push af  
72d3				  
72d3				ld hl,key_repeat_ct  
72d3				ld (hl),a  
72d3				inc hl  
72d3				call hexout  
72d3				ld hl,key_repeat_ct+3  
72d3				ld a,0  
72d3				ld (hl),a  
72d3			  
72d3			            LD   A, kLCD_Line3+15  
72d3			            CALL fLCD_Pos       ;Position cursor to location in A  
72d3			            LD   DE, key_repeat_ct  
72d3			            ;LD   DE, MsgHello  
72d3			            CALL fLCD_Str       ;Display string pointed to by DE  
72d3			  
72d3			  
72d3			call delay500ms  
72d3			  
72d3				pop af  
72d3			endif  
72d3			  
72d3			  
72d3				; no key held  
72d3 fe 00			cp 0  
72d5 c8				ret z  
72d6			  
72d6			if DEBUG_KEYCIN  
72d6				push af  
72d6			  
72d6				ld a, '1'	  
72d6				ld hl,key_repeat_ct  
72d6				ld (hl),a  
72d6				inc hl  
72d6				ld a,0  
72d6				ld (hl),a  
72d6			  
72d6			            LD   A, kLCD_Line4+15  
72d6			            CALL fLCD_Pos       ;Position cursor to location in A  
72d6			            LD   DE, key_repeat_ct  
72d6			            ;LD   DE, MsgHello  
72d6			            CALL fLCD_Str       ;Display string pointed to by DE  
72d6			  
72d6			  
72d6			call delay500ms  
72d6			  
72d6				pop af  
72d6			endif  
72d6			  
72d6				; stop key bounce  
72d6			  
72d6 32 c6 fd			ld (key_held),a		 ; save it  
72d9 47				ld b, a  
72da			  
72da c5			.cina1:	push bc  
72db			if DEBUG_KEYCIN  
72db				push af  
72db			  
72db				ld hl,key_repeat_ct  
72db				inc hl  
72db				call hexout  
72db				ld hl,key_repeat_ct+3  
72db				ld a,0  
72db				ld (hl),a  
72db				ld hl,key_repeat_ct  
72db				ld a, '2'	  
72db				ld (hl),a  
72db			  
72db			            LD   A, kLCD_Line4+15  
72db			            CALL fLCD_Pos       ;Position cursor to location in A  
72db			            LD   DE, key_repeat_ct  
72db			            ;LD   DE, MsgHello  
72db			            CALL fLCD_Str       ;Display string pointed to by DE  
72db			  
72db				pop af  
72db			endif  
72db cd e4 72			call .mtoc  
72de c1				pop bc  
72df b8				cp b  
72e0 28 f8			jr z, .cina1  
72e2 78				ld a,b		  
72e3			if DEBUG_KEYCIN  
72e3				push af  
72e3			  
72e3				ld hl,key_repeat_ct  
72e3				inc hl  
72e3				call hexout  
72e3				ld hl,key_repeat_ct+3  
72e3				ld a,0  
72e3				ld (hl),a  
72e3				ld hl,key_repeat_ct  
72e3				ld a, '3'	  
72e3				ld (hl),a  
72e3			  
72e3			            LD   A, kLCD_Line4+15  
72e3			            CALL fLCD_Pos       ;Position cursor to location in A  
72e3			            LD   DE, key_repeat_ct  
72e3			            ;LD   DE, MsgHello  
72e3			            CALL fLCD_Str       ;Display string pointed to by DE  
72e3			  
72e3				pop af  
72e3			endif  
72e3 c9				ret  
72e4			  
72e4			; detect keyboard modifier key press and apply new overlay to the face key held  
72e4			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
72e4			  
72e4			;.cin_map_modifier:   
72e4			;	ld a, (hl)  
72e4			;	and 255  
72e4			;	ret NZ		; modifier key not flagged  
72e4			;  
72e4			;	; get key face  
72e4			;  
72e4			;	ld b,(key_face_held)  
72e4			;  
72e4			;	ld b, key_cols * key_rows  
72e4			;  
72e4			;	push de  
72e4			;	pop hl  
72e4			;  
72e4			;.mmod1: ld a,(hl)   ; get map test  
72e4			;	cp b  
72e4			;	jr z, .mmod2  
72e4			;  
72e4			;  
72e4			;  
72e4			;.mmod2: inc hl    ;   
72e4			;  
72e4			;	  
72e4			;  
72e4			;	  
72e4			;  
72e4			;	ld hl,key_actual_pressed  
72e4			;	ld (hl),a,  
72e4			;	ret  
72e4			  
72e4			; map matrix key held to char on face of key  
72e4			  
72e4			.mtoc:  
72e4			  
72e4			; test decade counter strobes  
72e4			  
72e4			;.decadetest1:  
72e4			  
72e4			; reset counter  
72e4			;ld a, 128  
72e4			;out (portbdata),a  
72e4			  
72e4			  
72e4			;ld b, 5  
72e4			;.dec1:  
72e4			;ld a, 0  
72e4			;out (portbdata),a  
72e4			;call delay1s  
72e4			  
72e4			;ld a, 32  
72e4			;out (portbdata),a  
72e4			;call delay1s  
72e4			;call delay1s  
72e4			;call delay1s  
72e4			;  
72e4			;ld a, 64+32  
72e4			;out (portbdata),a  
72e4			;call delay1s  
72e4			;;djnz .dec1  
72e4			;  
72e4			;jp .decadetest1  
72e4			  
72e4			  
72e4			  
72e4			  
72e4			  
72e4			  
72e4			  
72e4			  
72e4			  
72e4			  
72e4				; scan keyboard matrix and generate raw scan map  
72e4 cd 77 73			call matrix  
72e7			  
72e7				; reuse c bit 0 left modifer button - ie shift  
72e7			        ; reuse c bit 1 for right modifer button - ie symbol shift  
72e7				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
72e7			  
72e7 0e 00			ld c, 0  
72e9			  
72e9				; TODO set flags for modifer key presses   
72e9				; TODO do a search for modifer key...  
72e9			  
72e9				;ld hl,keyscan_table_row4  
72e9 21 25 fe			ld hl,keyscan_table_row2  
72ec			  
72ec 7e				ld a, (hl)  
72ed fe 23			cp '#'  
72ef 20 07			jr nz, .nextmodcheck  
72f1 cb c1			set 0, c  
72f3 21 51 72			ld hl, .matrix_to_shift  
72f6 18 21			jr .dokeymap  
72f8				; TODO for now igonre  
72f8			.nextmodcheck:  
72f8 21 1a fe			ld hl,keyscan_table_row3  
72fb			  
72fb 7e				ld a, (hl)  
72fc fe 23			cp '#'  
72fe 20 07			jr nz, .nextmodcheck2  
7300 cb c9			set 1, c   
7302 21 88 72			ld hl, .matrix_to_symbolshift  
7305 18 12			jr .dokeymap  
7307			.nextmodcheck2:  
7307 21 2e fe			ld hl,keyscan_table_row2+9    ; right shift  
730a			  
730a 7e				ld a, (hl)  
730b fe 23			cp '#'  
730d 20 07			jr nz, .donemodcheck  
730f cb c9			set 1, c   
7311 21 51 72			ld hl, .matrix_to_shift  
7314 18 03			jr .dokeymap  
7316			  
7316				; no modifer found so just map to normal keys  
7316				; get mtoc map matrix to respective keys  
7316			;	ld hl, .matrix_to_char  
7316			;	ld hl, .matrix_to_char  
7316			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7316			;	ld a, KEY_SHIFT  
7316			;	call findchar  
7316			;  
7316			;	; got offset to key modifer in b  
7316			;  
7316			;	ld hl,keyscan_table_row5  
7316			;  
7316			;	ld a,b  
7316			;	call addatohl  
7316			;	ld a,(hl)  
7316			;  
7316			;	cp '#'  
7316			;	jr nz, .nextmodcheck  
7316			;	set 0, c  
7316			;	ld hl, .matrix_to_char  
7316			;	jr .dokeymap  
7316			;	; TODO for now igonre  
7316			;.nextmodcheck:  
7316			;	ld hl, .matrix_to_symbolshift  
7316			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7316			;	ld a, KEY_SYMBOLSHIFT  
7316			;	call findchar  
7316			;  
7316			;  
7316			;	; got offset to key modifer in b  
7316			;  
7316			;	ld hl,keyscan_table_row5  
7316			;  
7316			;	ld a,b  
7316			;	call addatohl  
7316			;	ld a,(hl)  
7316			;  
7316			;	cp '#'  
7316			;	jr nz, .donemodcheck  
7316			;	set 1, c   
7316			;	ld hl, .matrix_to_symbolshift  
7316			;	jr .dokeymap  
7316			  
7316			  
7316			  
7316			.donemodcheck:  
7316				; no modifer found so just map to normal keys  
7316				; get mtoc map matrix to respective keys  
7316 21 1a 72			ld hl, .matrix_to_char  
7319			  
7319			.dokeymap:  
7319				;ld (key_fa), c   
7319 cd 32 73			call .mapkeys  
731c			  
731c			  
731c			if DEBUG_KEY  
731c			  
731c			; Display text on first line  
731c			            LD   A, kLCD_Line1  
731c			            CALL fLCD_Pos       ;Position cursor to location in A  
731c			            LD   DE, keyscan_table_row1  
731c			            ;LD   DE, MsgHello  
731c			            CALL fLCD_Str       ;Display string pointed to by DE  
731c			  
731c			; Display text on second line  
731c			            LD   A, kLCD_Line2  
731c			            CALL fLCD_Pos       ;Position cursor to location in A  
731c			            LD   DE, keyscan_table_row2  
731c			            CALL fLCD_Str       ;Display string pointed to by DE  
731c			            LD   A, kLCD_Line3  
731c			            CALL fLCD_Pos       ;Position cursor to location in A  
731c			            LD   DE, keyscan_table_row3  
731c			            CALL fLCD_Str       ;Display string pointed to by DE  
731c			            LD   A, kLCD_Line4  
731c			            CALL fLCD_Pos       ;Position cursor to location in A  
731c			            LD   DE, keyscan_table_row4  
731c			            CALL fLCD_Str       ;Display string pointed to by DE  
731c			            LD   A, kLCD_Line1+10  
731c			            CALL fLCD_Pos       ;Position cursor to location in A  
731c			            LD   DE, keyscan_table_row5  
731c			            CALL fLCD_Str       ;Display string pointed to by DE  
731c			  
731c				;call delay250ms  
731c			endif  
731c			;	jp testkey  
731c			  
731c			; get first char reported  
731c			  
731c 21 04 fe			ld hl,keyscan_table_row5  
731f			  
731f				;ld b, 46   ; 30 keys to remap + 8 nulls   
731f 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7321			.findkey:  
7321 7e				ld a,(hl)  
7322 fe 00			cp 0  
7324 28 04			jr z, .nextkey  
7326 fe 7e			cp KEY_MATRIX_NO_PRESS  
7328 20 06			jr nz, .foundkey  
732a			.nextkey:  
732a 23				inc hl  
732b 10 f4			djnz .findkey  
732d 3e 00			ld a,0  
732f c9				ret  
7330			.foundkey:  
7330 7e				ld a,(hl)  
7331 c9				ret  
7332				  
7332			  
7332			; convert the raw key map given hl for destination key  
7332			.mapkeys:  
7332 11 04 fe			ld de,keyscan_table_row5  
7335			  
7335 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7337			.remap:  
7337 1a				ld a,(de)  
7338 fe 23			cp '#'  
733a 20 02			jr nz, .remapnext  
733c				;CALLMONITOR  
733c 7e				ld a,(hl)  
733d 12				ld (de),a  
733e			  
733e			  
733e			  
733e			.remapnext:  
733e 23				inc hl  
733f 13				inc de  
7340 10 f5			djnz .remap  
7342				  
7342 c9				ret  
7343			  
7343			  
7343			  
7343			.mtocold2:  
7343			  
7343			;	; flag if key D is held down and remove from reporting  
7343			;	ld bc, .key_map_fd    
7343			;	ld hl, keyscan_table  
7343			;	ld de, key_fd  
7343			;	call .key_shift_hold  
7343			;	cp 255  
7343			;	jr z, .cinmap  
7343			;	; flag if key C is held down and remove from reporting  
7343			;	ld bc, .key_map_fc    
7343			;	ld hl, keyscan_table+key_cols  
7343			;	ld de, key_fc  
7343			;	call .key_shift_hold  
7343			;	cp 255  
7343			;	jr z, .cinmap  
7343			;	; flag if key B is held down and remove from reporting  
7343			;	ld bc, .key_map_fb    
7343			;	ld hl, keyscan_table+(key_cols*2)  
7343			;	ld de, key_fb  
7343			;	call .key_shift_hold  
7343			;	cp 255  
7343			;	jr z, .cinmap  
7343			;	; flag if key A is held down and remove from reporting  
7343			;	ld bc, .key_map_fa    
7343			;	ld hl, keyscan_table+(key_cols*3)  
7343			;	ld de, key_fa  
7343			;	call .key_shift_hold  
7343			;	cp 255  
7343			;	jr z, .cinmap  
7343			  
7343 11 1a 72			ld de, .matrix_to_char  
7346			  
7346			  
7346			.cinmap1:   
7346				if DEBUG_KEY  
7346			            LD   A, kLCD_Line4  
7346			            CALL fLCD_Pos       ;Position cursor to location in A  
7346					push de  
7346			            LD   DE, keyscan_table  
7346			            CALL fLCD_Str       ;Display string pointed to by DE  
7346					pop de  
7346				endif  
7346			  
7346				; scan key matrix table for any held key  
7346			  
7346				; de holds either the default matrix or one selected above  
7346			  
7346 21 d1 fd			ld hl, keyscan_table  
7349 06 32			ld b,key_cols*key_rows  
734b			  
734b 7e			.cin11:	ld a,(hl)  
734c fe 23			cp '#'  
734e 28 08			jr z, .cinhit1  
7350 23				inc hl  
7351 13				inc de  
7352 05				dec b  
7353 20 f6			jr nz, .cin11  
7355				; no key found held  
7355 3e 00			ld a,0  
7357 c9				ret  
7358 d5			.cinhit1: push de  
7359 e1				pop hl  
735a 7e				ld a,(hl)  
735b c9				ret  
735c			  
735c			; flag a control key is held   
735c			; hl is key pin, de is flag indicator  
735c			  
735c			.key_shift_hold1:  
735c c5				push bc  
735d 3e 01			ld a, 1  
735f 32 fc fa			ld (cursor_shape),a  
7362 06 00			ld b, 0  
7364 7e				ld a, (hl)  
7365 fe 2e			cp '.'  
7367 28 0a			jr z, .key_shift11  
7369 06 ff			ld b, 255  
736b 3e 2b			ld a, '+'    ; hide key from later scans  
736d 77				ld (hl),a  
736e 3e 02			ld a, 2  
7370 32 fc fa			ld (cursor_shape),a  
7373			.key_shift11:  
7373				; write flag indicator  
7373 78				ld a,b  
7374 12				ld (de),a  
7375			  
7375 d1				pop de    ; de now holds the key map ptr  
7376 c9				ret  
7377			  
7377				  
7377			  
7377			; scans keyboard matrix and flags key press in memory array	  
7377				  
7377			matrix:  
7377				;call matrix  
7377				; TODO optimise the code....  
7377			  
7377			  
7377			;ld hl, keyscan_table_row1  
7377			;ld de, keyscan_table_row1+1  
7377			;ld bc,46  
7377			;ld a,KEY_MATRIX_NO_PRESS  
7377			;ldir  
7377			  
7377			  
7377			  
7377			; reset counter  
7377 3e 80		ld a, 128  
7379 d3 c1		out (portbdata),a  
737b			  
737b 06 0a		ld b, 10  
737d 0e 00		ld c, 0       ; current clock toggle  
737f			  
737f			.colscan:  
737f			  
737f			; set current column  
737f			; disable clock enable and set clock low  
737f			  
737f			;ld a, 0  
737f			;out (portbdata),a  
737f			  
737f			; For each column scan for switches  
737f			  
737f c5			push bc  
7380 21 c7 fd		ld hl, keyscan_scancol  
7383 cd 8c 74		call .rowscan  
7386 c1			pop bc  
7387			  
7387			  
7387			; get back current column  
7387			  
7387			; translate the row scan  
7387			  
7387			;   
7387			; row 1  
7387			  
7387 78			ld a,b  
7388			  
7388 21 3a fe		LD   hl, keyscan_table_row1+10  
738b			  
738b cd ed 0f		call subafromhl  
738e			;call addatohl  
738e			  
738e 11 c7 fd		ld de, keyscan_scancol  
7391			  
7391 1a			ld a,(de)  
7392 77			ld (hl),a  
7393			  
7393			  
7393			  
7393			  
7393			; row 2  
7393			  
7393 78			ld a,b  
7394			  
7394 21 2f fe		LD   hl, keyscan_table_row2+10  
7397			  
7397			;call addatohl  
7397 cd ed 0f		call subafromhl  
739a			  
739a			  
739a 11 c8 fd		ld de, keyscan_scancol+1  
739d			  
739d 1a			ld a,(de)  
739e 77			ld (hl),a  
739f			  
739f			  
739f			; row 3  
739f			  
739f 78			ld a,b  
73a0			  
73a0 21 24 fe		LD   hl, keyscan_table_row3+10  
73a3			  
73a3			;call addatohl  
73a3 cd ed 0f		call subafromhl  
73a6			  
73a6 11 c9 fd		ld de, keyscan_scancol+2  
73a9			  
73a9 1a			ld a,(de)  
73aa 77			ld (hl),a  
73ab			  
73ab			  
73ab			  
73ab			; row 4  
73ab			  
73ab 78			ld a,b  
73ac			  
73ac 21 19 fe		LD   hl, keyscan_table_row4+10  
73af			  
73af			;call addatohl  
73af cd ed 0f		call subafromhl  
73b2			  
73b2 11 ca fd		ld de, keyscan_scancol+3  
73b5			  
73b5 1a			ld a,(de)  
73b6 77			ld (hl),a  
73b7			  
73b7			; row 5  
73b7			  
73b7 78			ld a,b  
73b8			  
73b8 21 0e fe		LD   hl, keyscan_table_row5+10  
73bb			  
73bb			;call addatohl  
73bb cd ed 0f		call subafromhl  
73be			  
73be 11 cb fd		ld de, keyscan_scancol+4  
73c1			  
73c1 1a			ld a,(de)  
73c2 77			ld (hl),a  
73c3			  
73c3			; handshake next column  
73c3			  
73c3			  
73c3 3e 40		ld a, 64  
73c5 d3 c1		out (portbdata),a  
73c7			  
73c7 3e 00		ld a, 0  
73c9 d3 c1		out (portbdata),a  
73cb			  
73cb			; toggle clk and move to next column  
73cb			;ld a, 64  
73cb			;cp c  
73cb			;  
73cb			;jr z, .coltoglow  
73cb			;ld c, a  
73cb			;jr .coltog  
73cb			;.coltoglow:  
73cb			;ld c, 0  
73cb			;.coltog:  
73cb			;ld a, c  
73cb			;out (portbdata),a  
73cb			  
73cb 10 b2		djnz .colscan  
73cd			  
73cd 3e 0a		ld a,10  
73cf 21 30 fe		LD   hl, keyscan_table_row1  
73d2 cd db 0f		call addatohl  
73d5 3e 00		ld a, 0  
73d7 77			ld (hl), a  
73d8			  
73d8			  
73d8 3e 0a		ld a,10  
73da 21 25 fe		LD   hl, keyscan_table_row2  
73dd cd db 0f		call addatohl  
73e0 3e 00		ld a, 0  
73e2 77			ld (hl), a  
73e3			  
73e3 3e 0a		ld a,10  
73e5 21 1a fe		LD   hl, keyscan_table_row3  
73e8 cd db 0f		call addatohl  
73eb 3e 00		ld a, 0  
73ed 77			ld (hl), a  
73ee			  
73ee 3e 0a		ld a,10  
73f0 21 0f fe		LD   hl, keyscan_table_row4  
73f3 cd db 0f		call addatohl  
73f6 3e 00		ld a, 0  
73f8 77			ld (hl), a  
73f9			  
73f9 3e 0a		ld a,10  
73fb 21 04 fe		LD   hl, keyscan_table_row5  
73fe cd db 0f		call addatohl  
7401 3e 00		ld a, 0  
7403 77			ld (hl), a  
7404			  
7404			if DEBUG_KEY_MATRIX  
7404			  
7404			; Display text on first line  
7404			            LD   A, kLCD_Line1  
7404			            CALL fLCD_Pos       ;Position cursor to location in A  
7404			            LD   DE, keyscan_table_row1  
7404			            ;LD   DE, MsgHello  
7404			            CALL fLCD_Str       ;Display string pointed to by DE  
7404			  
7404			; Display text on second line  
7404			            LD   A, kLCD_Line2  
7404			            CALL fLCD_Pos       ;Position cursor to location in A  
7404			            LD   DE, keyscan_table_row2  
7404			            CALL fLCD_Str       ;Display string pointed to by DE  
7404			            LD   A, kLCD_Line3  
7404			            CALL fLCD_Pos       ;Position cursor to location in A  
7404			            LD   DE, keyscan_table_row3  
7404			            CALL fLCD_Str       ;Display string pointed to by DE  
7404			            LD   A, kLCD_Line4  
7404			            CALL fLCD_Pos       ;Position cursor to location in A  
7404			            LD   DE, keyscan_table_row4  
7404			            CALL fLCD_Str       ;Display string pointed to by DE  
7404			            LD   A, kLCD_Line4+10  
7404			            CALL fLCD_Pos       ;Position cursor to location in A  
7404			            LD   DE, keyscan_table_row5  
7404			            CALL fLCD_Str       ;Display string pointed to by DE  
7404			  
7404			;call delay250ms  
7404				jp matrix  
7404			endif  
7404 c9			ret  
7405			  
7405			; using decade counter....  
7405			  
7405			  
7405			; TODO reset decade counter to start of scan  
7405			  
7405			; reset 15  
7405			; clock 14  
7405			; ce 13  
7405			  
7405			; 1 - q5  
7405			; 2 - q1  
7405			; 3 - q0  
7405			; 4 - q2  
7405			; 5 - q6  
7405			; 6 - q7  
7405			; 7 - q3  
7405			; 8 - vss  
7405			; 9 - q8  
7405			; 10 - q4  
7405			; 11 - q9  
7405			; 12 - cout  
7405			; 16 - vdd  
7405			  
7405			; clock      ce       reset     output  
7405			; 0          x        0         n  
7405			; x          1        0         n  
7405			; x          x        1         q0  
7405			; rising     0        0         n+1  
7405			; falling    x        0         n  
7405			; x          rising   0         n  
7405			; 1          falling  0         x+1  
7405			;  
7405			; x = dont care, if n < 5 carry = 1 otherwise 0  
7405			  
7405			;   
7405			; reset   
7405			; 13=0, 14=0, 15=1 .. 15=0  
7405			;  
7405			; handshake line  
7405			; 14=1.... read line 14=0  
7405			  
7405			  
7405			  
7405			  
7405			  
7405			; TODO hand shake clock for next column scan  
7405			; TODO detect each row  
7405			  
7405			  
7405			  
7405			  
7405			; reset 128  
7405			; clock 64  
7405			; ce 32  
7405			  
7405			  
7405			.cyclestart:  
7405			  
7405			; reset counter  
7405 3e 80		ld a, 128  
7407 d3 c1		out (portbdata),a  
7409			  
7409			; loop leds  
7409 06 0a		ld b,10  
740b			  
740b			.cycle1:  
740b c5			push bc  
740c 3e 00		ld a, 0  
740e d3 c1		out (portbdata),a  
7410 cd de 0c		call delay250ms  
7413			  
7413 3e 40		ld a, 64  
7415 d3 c1		out (portbdata),a  
7417 cd de 0c		call delay250ms  
741a			  
741a 3e 00		ld a, 0  
741c d3 c1		out (portbdata),a  
741e cd de 0c		call delay250ms  
7421			  
7421 c1			pop bc  
7422 10 e7		djnz .cycle1  
7424			  
7424			  
7424 18 df		jr .cyclestart  
7426			  
7426			  
7426			  
7426			  
7426			  
7426			  
7426			  
7426			  
7426			  
7426			; map matrix key held to char on face of key  
7426			  
7426			;.mtocold:  
7426			;  
7426			;  
7426			;; reset counter  
7426			;ld a, 128  
7426			;out (portbdata),a  
7426			;  
7426			;  
7426			;; scan keyboard row 1  
7426			;ld a, 0  
7426			;out (portbdata),a  
7426			;;ld a, 64  
7426			;;out (portbdata),a  
7426			;  
7426			;  
7426			;	ld a, 128  
7426			;	ld hl, keyscan_table  
7426			;	call .rowscan  
7426			;  
7426			;;ld a, 0  
7426			;;out (portbdata),a  
7426			;ld a, 64  
7426			;out (portbdata),a  
7426			;  
7426			;	ld a, 64  
7426			;	ld hl, keyscan_table+key_cols  
7426			;	call .rowscan  
7426			;  
7426			;ld a, 0  
7426			;out (portbdata),a  
7426			;;ld a, 64  
7426			;;out (portbdata),a  
7426			;	ld a, 32  
7426			;	ld hl, keyscan_table+(key_cols*2)  
7426			;	call .rowscan  
7426			;  
7426			;  
7426			;;ld a, 0  
7426			;;out (portbdata),a  
7426			;ld a, 64  
7426			;out (portbdata),a  
7426			;  
7426			;	ld a, 16  
7426			;	ld hl, keyscan_table+(key_cols*3)  
7426			;	call .rowscan  
7426			;  
7426			;  
7426			;	; flag if key D is held down and remove from reporting  
7426			;	ld bc, .key_map_fd    
7426			;	ld hl, keyscan_table  
7426			;	ld de, key_fd  
7426			;	call .key_shift_hold  
7426			;	cp 255  
7426			;	jr z, .cinmap  
7426			;	; flag if key C is held down and remove from reporting  
7426			;	ld bc, .key_map_fc    
7426			;	ld hl, keyscan_table+key_cols  
7426			;	ld de, key_fc  
7426			;	call .key_shift_hold  
7426			;	cp 255  
7426			;	jr z, .cinmap  
7426			;	; flag if key B is held down and remove from reporting  
7426			;	ld bc, .key_map_fb    
7426			;	ld hl, keyscan_table+(key_cols*2)  
7426			;	ld de, key_fb  
7426			;	call .key_shift_hold  
7426			;	cp 255  
7426			;	jr z, .cinmap  
7426			;	; flag if key A is held down and remove from reporting  
7426			;	ld bc, .key_map_fa    
7426			;	ld hl, keyscan_table+(key_cols*3)  
7426			;	ld de, key_fa  
7426			;	call .key_shift_hold  
7426			;	cp 255  
7426			;	jr z, .cinmap  
7426			;  
7426			;	ld de, .matrix_to_char  
7426			;  
7426			;  
7426			;.cinmap:   
7426			;	if DEBUG_KEY  
7426			;            LD   A, kLCD_Line4  
7426			;            CALL fLCD_Pos       ;Position cursor to location in A  
7426			;		push de  
7426			;            LD   DE, keyscan_table  
7426			;            CALL fLCD_Str       ;Display string pointed to by DE  
7426			;		pop de  
7426			;	endif  
7426			  
7426				; scan key matrix table for any held key  
7426			  
7426				; de holds either the default matrix or one selected above  
7426			  
7426			;	ld hl, keyscan_table  
7426			;	ld b,key_cols*key_rows  
7426			;  
7426			;.cin1:	ld a,(hl)  
7426			;	cp '#'  
7426			;	jr z, .cinhit  
7426			;	inc hl  
7426			;	inc de  
7426			;	dec b  
7426			;	jr nz, .cin1  
7426			;	; no key found held  
7426			;	ld a,0  
7426			;	ret  
7426			;.cinhit: push de  
7426			;	pop hl  
7426			;	ld a,(hl)  
7426			;	ret  
7426			  
7426			; flag a control key is held   
7426			; hl is key pin, de is flag indicator  
7426			  
7426			;.key_shift_hold:  
7426			;	push bc  
7426			;	ld a, 1  
7426			;	ld (cursor_shape),a  
7426			;	ld b, 0  
7426			;	ld a, (hl)  
7426			;	cp '.'  
7426			;	jr z, .key_shift1  
7426			;	ld b, 255  
7426			;	ld a, '+'    ; hide key from later scans  
7426			;	ld (hl),a  
7426			;	ld a, 2  
7426			;	ld (cursor_shape),a  
7426			;.key_shift1:  
7426			;	; write flag indicator  
7426			;	ld a,b  
7426			;	ld (de),a  
7426			;  
7426			;	pop de    ; de now holds the key map ptr  
7426			;	ret  
7426			  
7426				  
7426				  
7426			  
7426			  
7426			  
7426			  
7426			  
7426			  
7426			  
7426			  
7426			  
7426			  
7426			  
7426			;	push hl  
7426			;	push de  
7426			;	push bc  
7426			;	call keyscan  
7426			;	; map key matrix to ascii value of key face  
7426			;  
7426			;	ld hl, key_face_map  
7426			;	ld de, keyscan_table  
7426			;  
7426			;	; get how many keys to look at  
7426			;	ld b, keyscan_table_len  
7426			;	  
7426			;  
7426			;	; at this stage fall out on first key hit  
7426			;	; TODO handle multiple key press  
7426			;  
7426			;map1:	ld a,(hl)  
7426			;	cp '#'  
7426			;	jr z, keyhit  
7426			;	inc hl  
7426			;	inc de  
7426			;	dec b  
7426			;	jr nz, map1  
7426			;nohit:	ld a, 0  
7426			;	jr keydone  
7426			;keyhit: push de  
7426			;	pop hl  
7426			;	ld a,(hl)  
7426			;keydone:  
7426			;	push bc  
7426			;	push de  
7426			; 	push hl  
7426			;	ret   
7426			;  
7426			  
7426			  
7426			  
7426			  
7426			; scan physical key matrix  
7426			  
7426			  
7426			;keyscan:  
7426			;  
7426			;; for each key_row use keyscanr bit mask for out  
7426			;; then read in for keyscanc bitmask  
7426			;; save result of row scan to keyscantable  
7426			;  
7426			;; scan keyboard row 1  
7426			;  
7426			;	ld b, key_rows  
7426			;	ld hl, key_scanr  
7426			;	ld de, keyscan_table  
7426			;  
7426			;rowloop:  
7426			;  
7426			;	ld a,(hl)		; out bit mask to energise keyboard row  
7426			;	call rowscan  
7426			;	inc hl  
7426			;	dec b  
7426			;	jr nz, rowloop  
7426			;  
7426			;	ret  
7426			;  
7426			;  
7426			;; pass a out bitmask, b row number  
7426			;arowscan:   
7426			;	push bc  
7426			;  
7426			;	ld d, b  
7426			;  
7426			;	; calculate buffer location for this row  
7426			;  
7426			;	ld hl, keyscan_table	  
7426			;kbufr:  ld e, key_cols  
7426			;kbufc:	inc hl  
7426			;	dec e  
7426			;	jr nz, kbufc  
7426			;	dec d  
7426			;	jr nz, kbufr  
7426			;  
7426			;	; energise row and read columns  
7426			;  
7426			;	out (portbdata),a  
7426			;	in a,(portbdata)  
7426			;	ld c,a  
7426			;  
7426			;  
7426			;	; save buffer loc  
7426			;  
7426			;	ld (keybufptr), hl  
7426			;  
7426			;	ld hl, key_scanc  
7426			;	ld d, key_cols  
7426			;  
7426			;	; for each column check each bit mask  
7426			;  
7426			;colloop:  
7426			;	  
7426			;  
7426			;	; reset flags for the row   
7426			;  
7426			;	ld b,'.'  
7426			;	and (hl)  
7426			;	jr z, maskskip  
7426			;	ld b,'#'  
7426			;maskskip:  
7426			;	; save  key state  
7426			;	push hl  
7426			;	ld hl, (keybufptr)  
7426			;	ld (hl), b  
7426			;	inc hl  
7426			;	ld (keybufptr), hl  
7426			;  
7426			;	; move to next bit mask  
7426			;	pop hl  
7426			;	inc hl  
7426			;  
7426			;	dec d  
7426			;	jr nz, colloop  
7426			;  
7426			;	ret  
7426			;  
7426			;  
7426			;;  
7426			; lcd functions  
7426			;  
7426			;  
7426			  
7426			;if DEBUG_KEY_MATRIX  
7426			  
7426			; test function to display hardware view of matrix state  
7426			  
7426			matrixold:  
7426			  
7426			  
7426			  
7426			; reset counter  
7426 3e 80		ld a, 128  
7428 d3 c1		out (portbdata),a  
742a			; scan keyboard row 1  
742a 3e 00		ld a, 0  
742c d3 c1		out (portbdata),a  
742e			;ld a, 64  
742e			;out (portbdata),a  
742e 3e 80			ld a, 128  
7430 21 30 fe			ld hl, keyscan_table_row1  
7433 cd 8c 74			call .rowscan  
7436			  
7436			;ld a, 0  
7436			;out (portbdata),a  
7436 3e 40		ld a, 64  
7438 d3 c1		out (portbdata),a  
743a 3e 40			ld a, 64  
743c 21 25 fe			ld hl, keyscan_table_row2  
743f cd 8c 74			call .rowscan  
7442			  
7442 3e 00		ld a, 0  
7444 d3 c1		out (portbdata),a  
7446			;ld a, 64  
7446			;out (portbdata),a  
7446 3e 20			ld a, 32  
7448 21 1a fe			ld hl, keyscan_table_row3  
744b cd 8c 74			call .rowscan  
744e			  
744e			;ld a, 0  
744e			;out (portbdata),a  
744e 3e 40		ld a, 64  
7450 d3 c1		out (portbdata),a  
7452 3e 10			ld a, 16  
7454 21 0f fe			ld hl, keyscan_table_row4  
7457 cd 8c 74			call .rowscan  
745a			  
745a			; Display text on first line  
745a 3e 00		            LD   A, kLCD_Line1  
745c cd 94 70		            CALL fLCD_Pos       ;Position cursor to location in A  
745f 11 30 fe		            LD   DE, keyscan_table_row1  
7462			            ;LD   DE, MsgHello  
7462 cd b6 70		            CALL fLCD_Str       ;Display string pointed to by DE  
7465			  
7465			; Display text on second line  
7465 3e 28		            LD   A, kLCD_Line2  
7467 cd 94 70		            CALL fLCD_Pos       ;Position cursor to location in A  
746a 11 25 fe		            LD   DE, keyscan_table_row2  
746d cd b6 70		            CALL fLCD_Str       ;Display string pointed to by DE  
7470 3e 50		            LD   A, kLCD_Line3  
7472 cd 94 70		            CALL fLCD_Pos       ;Position cursor to location in A  
7475 11 1a fe		            LD   DE, keyscan_table_row3  
7478 cd b6 70		            CALL fLCD_Str       ;Display string pointed to by DE  
747b 3e 78		            LD   A, kLCD_Line4  
747d cd 94 70		            CALL fLCD_Pos       ;Position cursor to location in A  
7480 11 0f fe		            LD   DE, keyscan_table_row4  
7483 cd b6 70		            CALL fLCD_Str       ;Display string pointed to by DE  
7486			  
7486 cd de 0c			call delay250ms  
7489 c3 77 73			jp matrix  
748c			  
748c			; pass de as row display flags  
748c			.rowscan:   
748c			;	out (portbdata),a  
748c db c1			in a,(portbdata)  
748e 4f				ld c,a  
748f				; reset flags for the row   
748f 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7491 e6 01			and 1  
7493 28 02			jr z, .p1on  
7495 06 23			ld b,'#'  
7497			.p1on:  
7497 70				ld (hl), b  
7498 23				inc hl  
7499			  
7499 06 7e			ld b,KEY_MATRIX_NO_PRESS  
749b 79				ld a,c  
749c e6 02			and 2  
749e			;	bit 0,a  
749e 28 02			jr z, .p2on  
74a0 06 23			ld b,'#'  
74a2			.p2on:  
74a2 70				ld (hl), b  
74a3 23				inc hl  
74a4			;  
74a4 06 7e			ld b,KEY_MATRIX_NO_PRESS  
74a6 79				ld a,c  
74a7 e6 04			and 4  
74a9			;;	bit 0,a  
74a9 28 02			jr z, .p3on  
74ab 06 23			ld b,'#'  
74ad			.p3on:  
74ad 70				ld (hl), b  
74ae 23				inc hl  
74af			;;  
74af 06 7e			ld b,KEY_MATRIX_NO_PRESS  
74b1			;;	bit 0,a  
74b1 79				ld a,c  
74b2 e6 08			and 8  
74b4 28 02			jr z, .p4on  
74b6 06 23			ld b,'#'  
74b8			.p4on:  
74b8 70				ld (hl), b  
74b9 23				inc hl  
74ba			  
74ba 06 7e			ld b,KEY_MATRIX_NO_PRESS  
74bc			;;	bit 0,a  
74bc 79				ld a,c  
74bd e6 10			and 16  
74bf 28 02			jr z, .p5on  
74c1 06 23			ld b,'#'  
74c3			.p5on:  
74c3 70				ld (hl), b  
74c4 23				inc hl  
74c5			; zero term  
74c5 06 00			ld b,0  
74c7 70				ld (hl), b  
74c8			  
74c8 c9			.rscandone: ret  
74c9			  
74c9			;addatohl:  
74c9			;  
74c9			 ;add   a, l    ; A = A+L  
74c9			  ;  ld    l, a    ; L = A+L  
74c9			   ; adc   a, h    ; A = A+L+H+carry  
74c9			   ; sub   l       ; A = H+carry  
74c9			   ; ld    h, a    ; H = H+carry  
74c9			  
74c9			;ret  
74c9			; eof  
# End of file firmware_key_5x10.asm
74c9			;include "firmware_key_4x10.asm" 
74c9			 
74c9			heap_size:    equ heap_end - heap_start 
74c9			;eof 
# End of file os_mega.asm
74c9
