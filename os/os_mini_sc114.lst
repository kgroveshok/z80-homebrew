# File os_mini_sc114.asm
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			 
0000			 
0000			tos:	equ 0f000h 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			SC103_PIO: equ 068h 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 04 95			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			;        nop  
8003			;        nop 
8003			;;	org 05h		; null out bdos call 
8003			; 
8003			;        nop  
8003			;        nop  
8003			;        nop 
8003			;;	org 08h 
8003			;;; 
8003			;;	jp cin		; rst 8 - char in 
8003			;;; 
8003			; 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;	org 010h 
8003			;; 
8003			;	jp cout		; rest 010h  - char out 
8003			;; 
8003			;	org 01bh   
8003			; 
8003			;	;jp  		; rst 01bh   - write string to display 
8003			;	jp str_at_display 
8003			; 
8003			; 
8003			;	org 020h 
8003			; 
8003			;	; jp		 ; rst 020h - read char at screen location 
8003			; 
8003			;	org 028h 
8003			 
8003				; jp		 ; rst 028h  - storage i/o 
8003			 
8003			; 	org 030h 
8003			;	jp break_point_state 
8003			  
8003			; $30  
8003			; org 038h 
8003			; $38 
8003			 
8003			; TODO any more important entry points to add to jump table for easier coding use? 
8003			 
8003			 
8003			include "firmware.asm" 
8003			  
8003			; main constants (used here and in firmware)  
8003			  
8003			; TODO have page 0 of storage as bios  
8003			  
8003			Device_A: equ 0h  
8003			Device_B: equ 040h          ; Sound  
8003			  
8003			if BASE_KEV  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_SC114  
8003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			; TODO fixup for CPM  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			Device_D: equ 0c0h             ; Keyboard and LCD  
8003			  
8003			; Odd specific debug points for testing hardware dev  
8003			  
8003			DEBUG_SOUND: equ 1  
8003			DEBUG_STK_FAULT: equ 0  
8003			DEBUG_INPUT: equ 0     ; Debug input entry code  
8003			DEBUG_KEYCINWAIT: equ 0  
8003			DEBUG_KEYCIN: equ 0  
8003			DEBUG_KEY: equ 0  
8003			DEBUG_KEY_MATRIX: equ 0  
8003			DEBUG_STORECF: equ 0  
8003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
8003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
8003			DEBUG_SPI: equ 0    ; low level spi tests  
8003			  
8003			; Enable many break points  
8003			  
8003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
8003			DEBUG_FORTH_JP: equ 0    ; 4  
8003			DEBUG_FORTH_MALLOC: equ 0  
8003			DEBUG_FORTH_MALLOC_INT: equ 0  
8003			DEBUG_FORTH_DOT: equ 0  
8003			DEBUG_FORTH_DOT_WAIT: equ 0  
8003			DEBUG_FORTH_MATHS: equ 0  
8003			DEBUG_FORTH_TOK: equ 0    ; 4  
8003			DEBUG_FORTH_PARSE: equ 0    ; 3  
8003			DEBUG_FORTH: equ 0  ;2  
8003			DEBUG_FORTH_WORDS: equ 1   ; 1  
8003			DEBUG_FORTH_PUSH: equ 1   ; 1  
8003			DEBUG_FORTH_UWORD: equ 1   ; 1  
8003			  
8003			; Enable key point breakpoints  
8003			  
8003			DEBUG_FORTH_DOT_KEY: equ 0  
8003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
8003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
8003			  
8003			; Debug stack imbalances  
8003			  
8003			ON: equ 1  
8003			OFF: equ 0  
8003			  
8003			DEBUG_STACK_IMB: equ 0  
8003			STACK_IMB_STORE: equ 20  
8003			  
8003			; House keeping and protections  
8003			  
8003			DEBUG_FORTH_STACK_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
8003			FORTH_ENABLE_FREE: equ 0  
8003			FORTH_ENABLE_MALLOCFREE: equ 1  
8003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
8003			FORTH_ENABLE_FLOATMATH: equ 0  
8003			  
8003			  
8003			CALLMONITOR: macro  
8003				call break_point_state  
8003				endm  
8003			  
8003			MALLOC_1: equ 1        ; from dk88   
8003			MALLOC_2: equ 0           ; broke  
8003			MALLOC_3: equ 0           ; really broke  
8003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
8003			  
8003			if BASE_KEV   
8003			stacksize: equ 512*2  
8003			  
8003			STACK_RET_SIZE: equ 128  
8003			STACK_LOOP_SIZE: equ 512  
8003			STACK_DATA_SIZE: equ 512  
8003			endif  
8003			if BASE_SC114  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			;if STORAGE_SE == 0  
8003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
8003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
8003			;endif  
8003			  
8003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
8003			  
8003			STORE_0_AUTOFILE: equ $21  
8003			STORE_0_BANKRUN: equ $23  
8003			STORE_0_FILERUN: equ $24  
8003			  
8003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
8003			  
8003			STORE_0_AUTORUN: equ $20  
8003			  
8003			; Blocks where directory table is held  
8003			  
8003			; Reducing the number of entries increases the max file size  
8003			  
8003			;STORE_DIR_START: equ 1  
8003			;STORE_DIR_END: equ 33  
8003			  
8003			; Blocks from where file data is stored  
8003			  
8003			;STORE_DATA_START: equ STORE_DIR_END + 1  
8003			  
8003			; Block indicators (<32 are data files)  
8003			  
8003			;STORE_BLOCK_CFG: equ $8f       ; config block  
8003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
8003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
8003			;STORE_BLOCK_FREE: equ $85       ; data block free  
8003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
8003			  
8003			  
8003			  
8003			; Directory entry flags  
8003			  
8003			;STORE_DIR_FREE: equ 0  
8003			;STORE_DIR_FILE:  equ 1  
8003			  
8003			; Structure offsets to directory entries  
8003			;STORE_DE_FLAG: equ 0  
8003			;STORE_DE_MAXEXT: equ 1  
8003			;STORE_DE_FILENAME: equ 2  
8003			  
8003			; Structure offsets to block 0  
8003			  
8003			;STORE_BK0_ISFOR: equ 1  
8003			;STORE_BK0_LABEL: equ 3  
8003			  
8003			; memory allocation   
8003			  
8003			chk_stund: equ tos+2           ; underflow check word  
8003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
8003			  
8003			; keyscan table needs rows x cols buffer  
8003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
8003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
8003			  
8003			keyscan_table_row1: equ chk_stovr -key_cols-1  
8003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
8003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
8003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
8003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
8003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
8003			keyscan_scancol: equ keyscan_table-key_cols  
8003			;keyscan_table_len: equ key_rows*key_cols  
8003			;keybufptr: equ keyscan_table - 2  
8003			;keysymbol: equ keybufptr - 1  
8003			key_held: equ keyscan_scancol-1	; currently held  
8003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
8003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
8003			key_fa: equ key_repeat_ct -1 ;  
8003			key_fb: equ key_fa -1 ;  
8003			key_fc: equ key_fb -1 ;  
8003			key_fd: equ key_fc -1 ;  
8003			key_face_held: equ key_fd - 1   
8003			  
8003			; flag for enabling/disabling various hardware diags   
8003			  
8003			hardware_diag: equ key_face_held - 1  
8003			  
8003			; hardware config switches  
8003			; TODO add bitmasks on includes for hardware  
8003			; high byte for expansion ids  
8003			;     0000 0000  no card inserted  
8003			;     0000 0001  storage card inserted  
8003			;     0000 0010  spi sd card active  
8003			  
8003			;       
8003			; low byte:  
8003			;     0000 0001   4x4 keypad  
8003			;     0000 0010   full keyboard  
8003			;     0000 0011   spi/ext keyboard  
8003			;     0000 0100   20x4 lcd  
8003			;     0000 1000   40x4 lcd  
8003			;     0000 1100   spi/ext display  
8003			;     0001 0000   ide interface available  
8003			  
8003			hardware_word: equ hardware_diag - 2  
8003			  
8003			; debug marker - optional display of debug point on the debug screens  
8003			  
8003			debug_mark: equ hardware_word - 4  
8003			  
8003			; input_str vars  
8003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
8003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
8003			input_size: equ input_start -1  ; number of chars  
8003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
8003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
8003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
8003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
8003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
8003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
8003			input_len: equ input_cur_onoff - 5 ; length of current input  
8003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
8003			  
8003			CUR_BLINK_RATE: equ 15  
8003			  
8003			key_actual_pressed: equ input_cursor - 1   
8003			key_symbol: equ key_actual_pressed - 1   
8003			key_shift: equ key_symbol - 1   
8003			  
8003			; Display allocation  
8003			  
8003			;display_rows: equ 4     ; move out to mini and mega files  
8003			;display_cols: equ 20  
8003			  
8003			display_fb_len: equ display_rows*display_cols  
8003			  
8003			; primary frame buffer     
8003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
8003			; working frame buffers  
8003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
8003			display_fb3: equ  display_fb1-display_fb_len - 1  
8003			display_fb2: equ  display_fb3-display_fb_len - 1  
8003			;  
8003			; pointer to active frame buffer  
8003			display_fb_active: equ display_fb2 - 2  
8003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
8003			display_write_tmp: equ display_lcde1e2 - 2  
8003			  
8003			  
8003			;  
8003			  
8003			;; can load into de directory  
8003			cursor_col: equ display_write_tmp-1  
8003			cursor_row: equ cursor_col-1  
8003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
8003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
8003			  
8003			; maths vars  
8003			  
8003			LFSRSeed: equ cursor_shape -20   
8003			randData: equ LFSRSeed - 2  
8003			xrandc: equ randData - 2  
8003			stackstore: equ xrandc - 2  
8003			seed1: equ  stackstore -2   
8003			seed2: equ seed1 - 2  
8003			  
8003			; cf storage vars  
8003			  
8003			iErrorNum:  equ seed2-1         ;Error number  
8003			iErrorReg:  equ iErrorNum -1              ;Error register  
8003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
8003			  
8003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
8003			  
8003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
8003			  
8003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
8003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
8003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
8003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
8003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
8003			store_tmpid: equ store_tmp3 - 1		; page temp id  
8003			store_tmpext: equ store_tmpid - 1		; file extent temp  
8003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
8003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
8003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
8003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
8003			;  
8003			; spi vars  
8003			  
8003			  
8003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
8003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
8003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
8003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
8003			spi_device_id: equ spi_device - 1    ; human readable bank number  
8003			  
8003			;;;;; forth cli params  
8003			  
8003			; TODO use a different frame buffer for forth???  
8003			  
8003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
8003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
8003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
8003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
8003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
8003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
8003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
8003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
8003			  
8003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
8003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
8003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
8003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
8003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
8003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
8003			  
8003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
8003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
8003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
8003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
8003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
8003			  
8003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
8003			  
8003			; os/forth token vars  
8003			  
8003			os_last_cmd: equ os_var_array-255  
8003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
8003			os_current_i: equ os_cli_cmd-2  
8003			os_cur_ptr: equ os_current_i-2  
8003			os_word_scratch: equ os_cur_ptr-30  
8003			os_tok_len: equ os_word_scratch - 2  
8003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
8003			os_tok_malloc: equ os_tok_ptr - 2  
8003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
8003			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
8003			execscratch: equ os_input-255        ; exec cmd eval buffer  
8003			scratch: equ execscratch-255  
8003			  
8003			  
8003			; temp locations for new word processing to save on adding more   
8003			  
8003			os_new_malloc: equ scratch-2  
8003			os_new_parse_len: equ os_new_malloc - 2  
8003			os_new_word_len: equ os_new_parse_len - 2  
8003			os_new_work_ptr: equ os_new_word_len - 2  
8003			os_new_src_ptr: equ os_new_work_ptr - 2  
8003			os_new_exec: equ os_new_src_ptr - 2  
8003			os_new_exec_ptr: equ os_new_exec - 2  
8003			  
8003			; resume memory alloocations....  
8003			  
8003			os_view_disable: equ os_new_exec_ptr - 1  
8003			os_view_af: equ os_view_disable - 2  
8003			os_view_hl: equ os_view_af -2  
8003			os_view_de: equ os_view_hl - 2  
8003			os_view_bc: equ os_view_de - 2  
8003			  
8003			; stack checksum word  
8003			if DEBUG_STACK_IMB  
8003				curframe: equ  os_view_de - 5  
8003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
8003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			else  
8003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			endif  
8003			  
8003			; with data stack could see memory filled with junk. need some memory management   
8003			; malloc and free entry points added  
8003			  
8003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
8003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			;heap_end: equ free_list-1  ; Starting address of heap  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			heap_end: equ chk_word-1  ; Starting address of heap  
8003			  
8003			  
8003			;if BASE_KEV   
8003			;heap_start: equ 0800eh  ; Starting address of heap  
8003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;heap_start: equ baseram+15  ; Starting address of heap  
8003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;endif  
8003			  
8003			  
8003			;;;;  
8003			  
8003			  
8003			; change below to point to last memory alloc above  
8003			topusermem:  equ   heap_start  
8003			  
8003			;if BASE_KEV   
8003			;baseusermem: equ 08000h  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;;aseusermem:     equ    12  
8003			;baseusermem:     equ    prompt  
8003			;;baseusermem:     equ    endofcode  
8003			;endif  
8003			  
8003			  
8003			; **********************************************************************  
8003			; **  Constants  
8003			; **********************************************************************  
8003			  
8003			; Constants used by this code module  
8003			kDataReg:   EQU Device_D           ;PIO port A data register  
8003			kContReg:   EQU Device_D+2           ;PIO port A control register  
8003			  
8003			  
8003			portbdata:  equ Device_D+1    ; port b data  
8003			portbctl:   equ Device_D+3    ; port b control  
8003			  
8003			  
8003			;KEY_SHIFT:   equ 5  
8003			;KEY_SYMBOLSHIFT:  equ 6  
8003			  
8003			KEY_SHIFTLOCK: equ 4  
8003			  
8003			  
8003			KEY_UP: equ 5  
8003			KEY_NEXTWORD: equ 6  
8003			KEY_PREVWORD: equ 7  
8003			KEY_BS: equ 8  
8003			KEY_TAB:  equ 9  
8003			KEY_DOWN: equ 10  
8003			KEY_LEFT: equ 11  
8003			KEY_RIGHT: equ 12  
8003			KEY_CR:   equ 13  
8003			KEY_HOME: equ 14  
8003			KEY_END: equ 15  
8003			  
8003			KEY_F1: equ 16  
8003			KEY_F2: equ 17  
8003			KEY_F3: equ 18  
8003			KEY_F4: equ 19  
8003			  
8003			KEY_F5: equ 20  
8003			KEY_F6: equ 21  
8003			KEY_F7: equ 22  
8003			KEY_F8: equ 23  
8003			  
8003			KEY_F9: equ 24  
8003			KEY_F10: equ 25  
8003			KEY_F11: equ 26  
8003			KEY_F12: equ 27  
8003			  
8003			;if DEBUG_KEY  
8003			;	KEY_MATRIX_NO_PRESS: equ '.'  
8003			;	KEY_SHIFT:   equ '.'  
8003			;	KEY_SYMBOLSHIFT:  equ '.'  
8003			;else  
8003				KEY_SHIFT:   equ '~'  
8003				KEY_SYMBOLSHIFT:  equ '~'  
8003				KEY_MATRIX_NO_PRESS: equ '~'  
8003			;endi  
8003			  
8003			  
8003			  
8003			  
8003			; Macro to make adding debug marks easier  
8003			  
8003			DMARK: macro str  
8003				push af  
8003				ld a, (.dmark)  
8003				ld (debug_mark),a  
8003				ld a, (.dmark+1)  
8003				ld (debug_mark+1),a  
8003				ld a, (.dmark+2)  
8003				ld (debug_mark+2),a  
8003				jr .pastdmark  
8003			.dmark: db str  
8003			.pastdmark: pop af  
8003			  
8003			endm  
8003			  
8003			  
8003			; macro to detect for stack imbalances  
8003			  
8003			include "stackimbal.asm"  
8003			; Macro and code to detect stock imbalances 
8003			 
8003			SPPUSH: equ 0 
8003			 
8003			; Add a stack frame which can be checked before return 
8003			 
8003			STACKFRAME: macro onoff frame1 frame2 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003						exx 
8003			 
8003						ld de, frame1 
8003						ld a, d 
8003						ld hl, curframe 
8003						call hexout 
8003						ld a, e 
8003						ld hl, curframe+2 
8003						call hexout 
8003			  
8003						ld hl, frame1 
8003						push hl 
8003						ld hl, frame2 
8003						push hl 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			endm 
8003			 
8003			STACKFRAMECHK: macro onoff frame1 frame2 
8003			 
8003					 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						exx 
8003						; check stack frame SP 
8003			 
8003						ld hl, frame2 
8003						pop de   ; frame2 
8003			 
8003						call cmp16 
8003						jr nz, .spnosame 
8003						 
8003			 
8003						ld hl, frame1 
8003						pop de   ; frame1 
8003			 
8003						call cmp16 
8003						jr z, .spfrsame 
8003			 
8003						.spnosame: call showsperror 
8003			 
8003						.spfrsame: nop 
8003			 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			 
8003			 
8003			endm 
8003			 
8003			 
8003			; for a sub routine, wrap SP collection and comparisons 
8003			 
8003			; Usage: 
8003			; 
8003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
8003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
8003			 
8003			SAVESP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003			 
8003						ld (store_sp+(storeword*4)), sp 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			CHECKSP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003			 
8003						; save SP after last save 
8003				 
8003						ld (store_sp+(storeword*4)+2), sp 
8003			 
8003						push hl 
8003						ld hl, store_sp+(storeword*4) 
8003						call check_stack_sp  
8003						pop hl 
8003			 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			if DEBUG_STACK_IMB 
8003			 
8003			check_stack_sp: 
8003					push de 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					push de 
8003			 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					pop hl 
8003			 
8003			 
8003					; check to see if the same 
8003			 
8003					call cmp16 
8003					jr z, .spsame 
8003			 
8003					; not same 
8003			 
8003					call showsperror 
8003			.spsame: 
8003			 
8003					pop de 
8003			 
8003					ret 
8003			 
8003			.sperr:  db "Stack imbalance",0 
8003			 
8003			 
8003			showsperror: 
8003			 
8003			 
8003				push hl 
8003				push af 
8003				push de 
8003				call clear_display 
8003				ld de, .sperr 
8003				ld a,0 
8003			;	ld de,os_word_scratch 
8003				call str_at_display 
8003				ld a, display_row_1+17 
8003				ld de, debug_mark 
8003				call str_at_display 
8003				ld a, 0 
8003				ld (curframe+4),a 
8003				ld hl, curframe 
8003				ld de, os_word_scratch 
8003				ld a, display_row_4 
8003				call str_at_display 
8003				call update_display 
8003				;call break_point_state 
8003				call cin_wait 
8003			 
8003				ld a, ' ' 
8003				ld (os_view_disable), a 
8003				pop de	 
8003				pop af 
8003				pop hl 
8003				CALLMONITOR 
8003				ret 
8003			 
8003			endif 
8003			 
8003			 
8003			 
8003			; eof 
# End of file stackimbal.asm
8003			  
8003			;TODO macro to calc col and row offset into screen  
8003			  
8003			  
8003			  
8003			hardware_init:  
8003			  
8003 3e 00				ld a, 0  
8005 32 c6 ee				ld (hardware_diag), a  
8008			  
8008					; clear all the buffers  
8008			  
8008 21 05 ee				ld hl, display_fb1  
800b 22 61 ed				ld (display_fb_active), hl  
800e			  
800e cd 8e 88				call clear_display  
8011			  
8011 21 63 ed				ld hl, display_fb2  
8014 22 61 ed				ld (display_fb_active), hl  
8017			  
8017 cd 8e 88				call clear_display  
801a			  
801a					; init primary frame buffer area  
801a 21 56 ee				ld hl, display_fb0  
801d 22 61 ed				ld (display_fb_active), hl  
8020			  
8020 cd 8e 88				call clear_display  
8023			  
8023			  
8023 cd cc d6				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8026			  
8026 cd 6e d7			call key_init  
8029 cd b0 80			call storage_init  
802c			  
802c				; setup malloc functions  
802c			  
802c				if MALLOC_1  
802c cd 5e 8f				call  heap_init  
802f				endif  
802f				if MALLOC_4  
802f					call  heap_init  
802f				endif  
802f			  
802f				; init sound hardware if present  
802f			  
802f				if SOUND_ENABLE  
802f					call sound_init  
802f				endif  
802f			  
802f				; lcd test sequence  
802f					  
802f cd b1 88			call update_display  
8032 cd 0e 88			call delay1s  
8035 3e 2b			ld a,'+'  
8037 cd 93 88			call fill_display  
803a cd b1 88			call update_display  
803d cd 0e 88			call delay1s  
8040 3e 2a			ld a,'*'  
8042 cd 93 88			call fill_display  
8045 cd b1 88			call update_display  
8048 cd 0e 88			call delay1s  
804b 3e 2d			ld a,'-'  
804d cd 93 88			call fill_display  
8050 cd b1 88			call update_display  
8053 cd 0e 88			call delay1s  
8056			  
8056			; boot splash screen  
8056			if display_cols == 20	  
8056 3e 00		        ld a, display_row_1    
8058			else  
8058			        ld a, display_row_1 +10   
8058			endif  
8058 11 89 80			ld de, bootmsg  
805b cd a1 88			call str_at_display  
805e cd b1 88			call update_display  
8061			  
8061			  
8061 cd 0e 88			call delay1s  
8064 cd 0e 88			call delay1s  
8067			if display_cols == 20	  
8067 3e 2a		            LD   A, display_row_3+2  
8069			else  
8069			            LD   A, display_row_3+12  
8069			endif  
8069 11 9e 80			ld de, bootmsg1  
806c cd a1 88			call str_at_display  
806f cd b1 88			call update_display  
8072 cd 0e 88			call delay1s  
8075 cd 0e 88			call delay1s  
8078			  
8078			;	ld a, display_row_4+3  
8078			;	ld de, bootmsg2  
8078			;	call str_at_display  
8078			;	call update_display  
8078			;	call delay1s  
8078			;	call delay1s  
8078			  
8078			; debug mark setup  
8078			  
8078 3e 5f		ld a, '_'  
807a 32 c0 ee		ld (debug_mark),a  
807d 32 c1 ee		ld (debug_mark+1),a  
8080 32 c2 ee		ld (debug_mark+2),a  
8083 3e 00		ld a,0  
8085 32 c3 ee		ld (debug_mark+3),a  
8088			  
8088 c9					ret  
8089			  
8089			  
8089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
809e .. 00		bootmsg1:	db "by Kevin Groves",0  
80ae			;bootmsg2:	db "Firmware v0.1",0  
80ae			  
80ae			; a 4x20 lcd  
80ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80ae			  
80ae			;if display_cols == 20  
80ae			;	include "firmware_lcd_4x20.asm"  
80ae			;endif  
80ae			  
80ae			;if display_cols == 40  
80ae			;	include "firmware_lcd_4x40.asm"  
80ae			;endif  
80ae			  
80ae			;  
80ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80ae			; TODO abstract the bit bang video out interface for dual display  
80ae			; TODO wire video out to tx pin on rc2014 bus  
80ae			  
80ae			; must supply cin, and cin_wait for low level hardware abstraction   
80ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80ae			; test scancode  
80ae			  
80ae			;;;;;  
80ae			;;;  
80ae			; Moved out to mini and maxi versions  
80ae			;  
80ae			; include "firmware_key_4x4.asm"  
80ae			; using existing 4 wire x 4 resistor array for input  
80ae			;include "firmware_key_4x10.asm"  
80ae			; need to mod the board for 5 rows due to resistor array  
80ae			;include "firmware_key_5x10.asm"  
80ae			  
80ae			; storage hardware interface  
80ae			  
80ae			; use microchip serial eeprom for storage  
80ae			  
80ae			  
80ae			if STORAGE_SE  
80ae				include "firmware_spi.asm"  
80ae				include "firmware_seeprom.asm"  
80ae			else  
80ae			   ; create some stubs for the labels  
80ae c9			se_readbyte: ret  
80af c9			se_writebyte: ret  
80b0 c9			storage_init: ret  
80b1			  
80b1			endif  
80b1			  
80b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80b1			;include "firmware_cf.asm"  
80b1			  
80b1			; load up high level storage hardward abstractions  
80b1			include "firmware_storage.asm"  
80b1			 
80b1			; persisent storage hardware abstraction layer  
80b1			 
80b1			 
80b1			 
80b1			; Block 0 on storage is a config state 
80b1			 
80b1			 
80b1			 
80b1			; TODO add read phy block and write phy block functions 
80b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80b1			 
80b1			; Abstraction layer  
80b1			 
80b1			; Logocial block size is same size as physical size - using tape concept 
80b1			 
80b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80b1			 
80b1			 
80b1			 
80b1			; Filesystem layout (Logical layout) 
80b1			; 
80b1			; Block 0 - Bank config  
80b1			; 
80b1			;      Byte - 0 file id counter 
80b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80b1			;      Byte - 3-20 zero terminated bank label 
80b1			; 
80b1			; Block 1 > File storage 
80b1			; 
80b1			;      Byte 0 file id    - block 0 file details 
80b1			;      Byte 1 block id - block 0 is file  
80b1			;            Byte 2-15 - File name 
80b1			; 
80b1			;       - to end of block data 
80b1			; 
80b1			 
80b1			 
80b1			; Read Block 
80b1			; ---------- 
80b1			; 
80b1			; With current bank 
80b1			;  
80b1			; Get block number to read 
80b1			; Load physical blocks starting at start block into buffer 
80b1			 
80b1			; de points to buffer to use 
80b1			; hl holds logical block number  
80b1			 
80b1			storage_read_block: 
80b1			 
80b1				; TODO bank selection 
80b1			 
80b1				; for each of the physical blocks read it into the buffer 
80b1 06 40			ld b, STORE_BLOCK_PHY 
80b3			 
80b3				if DEBUG_STORESE 
80b3 d5					push de 
80b4				endif 
80b4				 
80b4			.rl1:    
80b4			 
80b4				; read physical block at hl into de 
80b4			        ; increment hl and de to next read position on exit 
80b4			 
80b4 e5				push hl 
80b5 d5				push de	 
80b6 c5				push bc 
80b7			;	if DEBUG_STORESE 
80b7			;		push af 
80b7			;		ld a, 'R' 
80b7			;		ld (debug_mark),a 
80b7			;		pop af 
80b7			;		CALLMONITOR 
80b7			;	endif 
80b7 cd ae 80			call se_readbyte 
80ba			;	if DEBUG_STORESE 
80ba			;		ld a,(spi_portbyte) 
80ba			;		ld l, a 
80ba			;		push af 
80ba			;		ld a, '1' 
80ba			;		ld (debug_mark),a 
80ba			;		pop af 
80ba			;		CALLMONITOR 
80ba			;	endif 
80ba c1				pop bc 
80bb d1				pop de 
80bc e1				pop hl 
80bd 12				ld (de),a 
80be 23				inc hl 
80bf 13				inc de 
80c0			 
80c0			;	if DEBUG_STORESE 
80c0			;		push af 
80c0			;		ld a, 'r' 
80c0			;		ld (debug_mark),a 
80c0			;		pop af 
80c0			;		CALLMONITOR 
80c0			;	endif 
80c0			 
80c0 10 f2			djnz .rl1 
80c2			 
80c2				if DEBUG_STORESE 
80c2					DMARK "SRB" 
80c2 f5				push af  
80c3 3a d7 80			ld a, (.dmark)  
80c6 32 c0 ee			ld (debug_mark),a  
80c9 3a d8 80			ld a, (.dmark+1)  
80cc 32 c1 ee			ld (debug_mark+1),a  
80cf 3a d9 80			ld a, (.dmark+2)  
80d2 32 c2 ee			ld (debug_mark+2),a  
80d5 18 03			jr .pastdmark  
80d7 ..			.dmark: db "SRB"  
80da f1			.pastdmark: pop af  
80db			endm  
# End of macro DMARK
80db d1					pop de 
80dc			; 
80dc			;		push af 
80dc			;		ld a, 'R' 
80dc			;		ld (debug_mark),a 
80dc			;		pop af 
80dc					CALLMONITOR 
80dc cd 2e 93			call break_point_state  
80df				endm  
# End of macro CALLMONITOR
80df				endif 
80df c9				ret	 
80e0				 
80e0			 
80e0			; File Size 
80e0			; --------- 
80e0			; 
80e0			;   hl file id 
80e0			; 
80e0			;  returns in hl the number of blocks 
80e0			 
80e0			storage_file_size: 
80e0 5d				ld e, l 
80e1 16 00			ld d, 0 
80e3 21 40 00			ld hl, STORE_BLOCK_PHY 
80e6					if DEBUG_FORTH_WORDS 
80e6						DMARK "SIZ" 
80e6 f5				push af  
80e7 3a fb 80			ld a, (.dmark)  
80ea 32 c0 ee			ld (debug_mark),a  
80ed 3a fc 80			ld a, (.dmark+1)  
80f0 32 c1 ee			ld (debug_mark+1),a  
80f3 3a fd 80			ld a, (.dmark+2)  
80f6 32 c2 ee			ld (debug_mark+2),a  
80f9 18 03			jr .pastdmark  
80fb ..			.dmark: db "SIZ"  
80fe f1			.pastdmark: pop af  
80ff			endm  
# End of macro DMARK
80ff						CALLMONITOR 
80ff cd 2e 93			call break_point_state  
8102				endm  
# End of macro CALLMONITOR
8102					endif 
8102 cd d6 83			call storage_findnextid 
8105			 
8105 cd e4 8a			call ishlzero 
8108			;	ld a, l 
8108			;	add h 
8108			;	cp 0 
8108 c8				ret z			; block not found so EOF 
8109			 
8109 11 eb ec			ld de, store_page 
810c cd b1 80			call storage_read_block 
810f			 
810f 3a ed ec			ld a, (store_page+2)	 ; get extent count 
8112 6f				ld l, a 
8113 26 00			ld h, 0 
8115 c9			 	ret 
8116			 
8116			 
8116			; Write Block 
8116			; ----------- 
8116			; 
8116			; With current bank 
8116			;  
8116			; Get block number to write 
8116			; Write physical blocks starting at start block from buffer 
8116			  
8116			storage_write_block: 
8116				; TODO bank selection 
8116			 
8116				; for each of the physical blocks read it into the buffer 
8116 06 40			ld b, STORE_BLOCK_PHY 
8118			 
8118				if DEBUG_STORESE 
8118					DMARK "SWB" 
8118 f5				push af  
8119 3a 2d 81			ld a, (.dmark)  
811c 32 c0 ee			ld (debug_mark),a  
811f 3a 2e 81			ld a, (.dmark+1)  
8122 32 c1 ee			ld (debug_mark+1),a  
8125 3a 2f 81			ld a, (.dmark+2)  
8128 32 c2 ee			ld (debug_mark+2),a  
812b 18 03			jr .pastdmark  
812d ..			.dmark: db "SWB"  
8130 f1			.pastdmark: pop af  
8131			endm  
# End of macro DMARK
8131			 
8131					;push af 
8131					;ld a, 'W' 
8131					;ld (debug_mark),a 
8131					;pop af 
8131					CALLMONITOR 
8131 cd 2e 93			call break_point_state  
8134				endm  
# End of macro CALLMONITOR
8134				endif 
8134			 
8134			; might not be working 
8134			;	call se_writepage 
8134			 
8134			;	ret 
8134			; 
8134			 
8134			 
8134			 
8134			.wl1:    
8134			 
8134				; read physical block at hl into de 
8134			        ; increment hl and de to next read position on exit 
8134			 
8134 e5				push hl 
8135 d5				push de	 
8136 c5				push bc 
8137 1a				ld a,(de) 
8138				;if DEBUG_STORESE 
8138			;		push af 
8138			;		ld a, 'W' 
8138			;		ld (debug_mark),a 
8138			;		pop af 
8138			;		CALLMONITOR 
8138			;	endif 
8138 cd af 80			call se_writebyte 
813b			;	call delay250ms 
813b 00				nop 
813c 00				nop 
813d 00				nop 
813e			;	if DEBUG_STORESE 
813e			;		push af 
813e			;		ld a, 'w' 
813e			;		ld (debug_mark),a 
813e			;		pop af 
813e			;		CALLMONITOR 
813e			;	endif 
813e c1				pop bc 
813f d1				pop de 
8140 e1				pop hl 
8141 23				inc hl 
8142 13				inc de 
8143			 
8143			 
8143 10 ef			djnz .wl1 
8145			 
8145				if DEBUG_STORESE 
8145					DMARK "SW2" 
8145 f5				push af  
8146 3a 5a 81			ld a, (.dmark)  
8149 32 c0 ee			ld (debug_mark),a  
814c 3a 5b 81			ld a, (.dmark+1)  
814f 32 c1 ee			ld (debug_mark+1),a  
8152 3a 5c 81			ld a, (.dmark+2)  
8155 32 c2 ee			ld (debug_mark+2),a  
8158 18 03			jr .pastdmark  
815a ..			.dmark: db "SW2"  
815d f1			.pastdmark: pop af  
815e			endm  
# End of macro DMARK
815e			 
815e					;push af 
815e					;ld a, 'W' 
815e					;ld (debug_mark),a 
815e					;pop af 
815e					CALLMONITOR 
815e cd 2e 93			call break_point_state  
8161				endm  
# End of macro CALLMONITOR
8161				endif 
8161 c9				ret	 
8162			 
8162			; Init bank 
8162			; --------- 
8162			; 
8162			; With current bank 
8162			; 
8162			; Setup block 0 config 
8162			;     Set 0 file id counter 
8162			;     Set formatted byte pattern 
8162			;     Zero out bank label 
8162			;      
8162			; For every logical block write 0-1 byte as null 
8162			 
8162			storage_get_block_0: 
8162			 
8162				; TODO check presence 
8162			 
8162				; get block 0 config 
8162			 
8162 21 00 00			ld hl, 0 
8165 11 eb ec			ld de, store_page 
8168 cd b1 80			call storage_read_block 
816b			 
816b				if DEBUG_STORESE 
816b					DMARK "SB0" 
816b f5				push af  
816c 3a 80 81			ld a, (.dmark)  
816f 32 c0 ee			ld (debug_mark),a  
8172 3a 81 81			ld a, (.dmark+1)  
8175 32 c1 ee			ld (debug_mark+1),a  
8178 3a 82 81			ld a, (.dmark+2)  
817b 32 c2 ee			ld (debug_mark+2),a  
817e 18 03			jr .pastdmark  
8180 ..			.dmark: db "SB0"  
8183 f1			.pastdmark: pop af  
8184			endm  
# End of macro DMARK
8184 11 eb ec				ld de, store_page 
8187			;		push af 
8187			;		ld a, 'i' 
8187			;		ld (debug_mark),a 
8187			;		pop af 
8187					CALLMONITOR 
8187 cd 2e 93			call break_point_state  
818a				endm  
# End of macro CALLMONITOR
818a				endif 
818a			 
818a				; is this area formatted? 
818a			 
818a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
818a 2a ec ec			ld hl, (store_page+1) 
818d 3e 80			ld a,0x80 
818f bd				cp l 
8190 20 22			jr nz, .ininotformatted 
8192				; do a double check 
8192 3e 27			ld a, 0x27 
8194 bc				cp h 
8195 20 1d			jr nz, .ininotformatted 
8197			 
8197				; formatted then 
8197			 
8197				if DEBUG_STORESE 
8197					DMARK "SB1" 
8197 f5				push af  
8198 3a ac 81			ld a, (.dmark)  
819b 32 c0 ee			ld (debug_mark),a  
819e 3a ad 81			ld a, (.dmark+1)  
81a1 32 c1 ee			ld (debug_mark+1),a  
81a4 3a ae 81			ld a, (.dmark+2)  
81a7 32 c2 ee			ld (debug_mark+2),a  
81aa 18 03			jr .pastdmark  
81ac ..			.dmark: db "SB1"  
81af f1			.pastdmark: pop af  
81b0			endm  
# End of macro DMARK
81b0					;push af 
81b0					;ld a, 'I' 
81b0					;ld (debug_mark),a 
81b0					;pop af 
81b0					CALLMONITOR 
81b0 cd 2e 93			call break_point_state  
81b3				endm  
# End of macro CALLMONITOR
81b3				endif 
81b3 c9				ret 
81b4			 
81b4			.ininotformatted: 
81b4				; bank not formatted so poke various bits to make sure 
81b4			 
81b4				if DEBUG_STORESE 
81b4					DMARK "SB2" 
81b4 f5				push af  
81b5 3a c9 81			ld a, (.dmark)  
81b8 32 c0 ee			ld (debug_mark),a  
81bb 3a ca 81			ld a, (.dmark+1)  
81be 32 c1 ee			ld (debug_mark+1),a  
81c1 3a cb 81			ld a, (.dmark+2)  
81c4 32 c2 ee			ld (debug_mark+2),a  
81c7 18 03			jr .pastdmark  
81c9 ..			.dmark: db "SB2"  
81cc f1			.pastdmark: pop af  
81cd			endm  
# End of macro DMARK
81cd					;push af 
81cd					;ld a, 'f' 
81cd					;ld (debug_mark),a 
81cd					;pop af 
81cd					CALLMONITOR 
81cd cd 2e 93			call break_point_state  
81d0				endm  
# End of macro CALLMONITOR
81d0				endif 
81d0			 
81d0 cd d1 87			call storage_clear_page 
81d3			 
81d3 21 eb ec			ld hl, store_page 
81d6 3e 00			ld a, 0 
81d8				 
81d8 77				ld (hl),a   ; reset file counter 
81d9			 
81d9 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
81dc 22 ec ec		 	ld (store_page+1), hl	 
81df			 
81df				; set default label 
81df			 
81df 21 7b 82			ld hl, .defaultbanklabl 
81e2 11 ee ec		 	ld de, store_page+3 
81e5 01 0f 00			ld bc, 15 
81e8 ed b0			ldir 
81ea			 
81ea				; Append the current bank id 
81ea 21 f7 ec			ld hl, store_page+3+9 
81ed 3a d0 ec			ld a, (spi_device_id) 
81f0 77				ld (hl), a 
81f1			 
81f1				; save default page 0 
81f1			 
81f1 21 00 00			ld hl, 0 
81f4 11 eb ec			ld de, store_page 
81f7				if DEBUG_STORESE 
81f7					DMARK "SB3" 
81f7 f5				push af  
81f8 3a 0c 82			ld a, (.dmark)  
81fb 32 c0 ee			ld (debug_mark),a  
81fe 3a 0d 82			ld a, (.dmark+1)  
8201 32 c1 ee			ld (debug_mark+1),a  
8204 3a 0e 82			ld a, (.dmark+2)  
8207 32 c2 ee			ld (debug_mark+2),a  
820a 18 03			jr .pastdmark  
820c ..			.dmark: db "SB3"  
820f f1			.pastdmark: pop af  
8210			endm  
# End of macro DMARK
8210			;		push af 
8210			;		ld a, 'F' 
8210			;		ld (debug_mark),a 
8210			;		pop af 
8210					CALLMONITOR 
8210 cd 2e 93			call break_point_state  
8213				endm  
# End of macro CALLMONITOR
8213				endif 
8213 cd 16 81			call storage_write_block 
8216				if DEBUG_STORESE 
8216					DMARK "SB4" 
8216 f5				push af  
8217 3a 2b 82			ld a, (.dmark)  
821a 32 c0 ee			ld (debug_mark),a  
821d 3a 2c 82			ld a, (.dmark+1)  
8220 32 c1 ee			ld (debug_mark+1),a  
8223 3a 2d 82			ld a, (.dmark+2)  
8226 32 c2 ee			ld (debug_mark+2),a  
8229 18 03			jr .pastdmark  
822b ..			.dmark: db "SB4"  
822e f1			.pastdmark: pop af  
822f			endm  
# End of macro DMARK
822f			;		push af 
822f			;		ld a, '>' 
822f			;		ld (debug_mark),a 
822f			;		pop af 
822f					CALLMONITOR 
822f cd 2e 93			call break_point_state  
8232				endm  
# End of macro CALLMONITOR
8232				endif 
8232			 
8232 00				nop 
8233 00				nop 
8234 00				nop 
8235			 
8235				; now set 0 in every page to mark as a free block 
8235			 
8235 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8237 21 40 00			ld hl, STORE_BLOCK_PHY 
823a			 
823a 3e 00		.setmark1:   	ld a,0 
823c e5					push hl 
823d c5					push bc 
823e cd af 80				call se_writebyte 
8241 3e 0a			ld a, 10 
8243 cd f3 87			call aDelayInMS 
8246 23				inc hl 
8247 cd af 80				call se_writebyte 
824a 3e 0a			ld a, 10 
824c cd f3 87			call aDelayInMS 
824f 2b				dec hl 
8250 c1					pop bc 
8251 e1					pop hl 
8252 3e 40				ld a, STORE_BLOCK_PHY 
8254 cd bb 8a				call addatohl 
8257 10 e1				djnz .setmark1 
8259			 
8259 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
825b 3e 00		.setmark2:   	ld a,0 
825d e5					push hl 
825e c5					push bc 
825f cd af 80				call se_writebyte 
8262 3e 0a			ld a, 10 
8264 cd f3 87			call aDelayInMS 
8267 23				inc hl 
8268 cd af 80				call se_writebyte 
826b 3e 0a			ld a, 10 
826d cd f3 87			call aDelayInMS 
8270 2b				dec hl 
8271 c1					pop bc 
8272 e1					pop hl 
8273 3e 40				ld a, STORE_BLOCK_PHY 
8275 cd bb 8a				call addatohl 
8278 10 e1				djnz .setmark2 
827a			 
827a					 
827a			 
827a			 
827a c9				ret 
827b			 
827b			 
827b			 
827b			 
827b .. 00		.defaultbanklabl:   db "BankLabel_",0 
8286			 
8286			 
8286			 
8286			; Label Bank 
8286			; ---------- 
8286			; 
8286			; With current bank 
8286			; Read block 0 
8286			; Set label 
8286			; Write block 0 
8286			 
8286			; label str pointer in hl 
8286			 
8286			storage_label:     
8286			 
8286				if DEBUG_STORESE 
8286					DMARK "LBL" 
8286 f5				push af  
8287 3a 9b 82			ld a, (.dmark)  
828a 32 c0 ee			ld (debug_mark),a  
828d 3a 9c 82			ld a, (.dmark+1)  
8290 32 c1 ee			ld (debug_mark+1),a  
8293 3a 9d 82			ld a, (.dmark+2)  
8296 32 c2 ee			ld (debug_mark+2),a  
8299 18 03			jr .pastdmark  
829b ..			.dmark: db "LBL"  
829e f1			.pastdmark: pop af  
829f			endm  
# End of macro DMARK
829f					CALLMONITOR 
829f cd 2e 93			call break_point_state  
82a2				endm  
# End of macro CALLMONITOR
82a2				endif 
82a2			 
82a2 e5				push hl 
82a3			 
82a3 cd 62 81			call storage_get_block_0 
82a6			 
82a6				; set default label 
82a6			 
82a6 e1				pop hl 
82a7			 
82a7 11 ee ec		 	ld de, store_page+3 
82aa 01 0f 00			ld bc, 15 
82ad				if DEBUG_STORESE 
82ad					DMARK "LB3" 
82ad f5				push af  
82ae 3a c2 82			ld a, (.dmark)  
82b1 32 c0 ee			ld (debug_mark),a  
82b4 3a c3 82			ld a, (.dmark+1)  
82b7 32 c1 ee			ld (debug_mark+1),a  
82ba 3a c4 82			ld a, (.dmark+2)  
82bd 32 c2 ee			ld (debug_mark+2),a  
82c0 18 03			jr .pastdmark  
82c2 ..			.dmark: db "LB3"  
82c5 f1			.pastdmark: pop af  
82c6			endm  
# End of macro DMARK
82c6					CALLMONITOR 
82c6 cd 2e 93			call break_point_state  
82c9				endm  
# End of macro CALLMONITOR
82c9				endif 
82c9 ed b0			ldir 
82cb				; save default page 0 
82cb			 
82cb 21 00 00			ld hl, 0 
82ce 11 eb ec			ld de, store_page 
82d1				if DEBUG_STORESE 
82d1					DMARK "LBW" 
82d1 f5				push af  
82d2 3a e6 82			ld a, (.dmark)  
82d5 32 c0 ee			ld (debug_mark),a  
82d8 3a e7 82			ld a, (.dmark+1)  
82db 32 c1 ee			ld (debug_mark+1),a  
82de 3a e8 82			ld a, (.dmark+2)  
82e1 32 c2 ee			ld (debug_mark+2),a  
82e4 18 03			jr .pastdmark  
82e6 ..			.dmark: db "LBW"  
82e9 f1			.pastdmark: pop af  
82ea			endm  
# End of macro DMARK
82ea					CALLMONITOR 
82ea cd 2e 93			call break_point_state  
82ed				endm  
# End of macro CALLMONITOR
82ed				endif 
82ed cd 16 81			call storage_write_block 
82f0			 
82f0 c9				ret 
82f1			 
82f1			 
82f1			 
82f1			; Read Block 0 - Config 
82f1			; --------------------- 
82f1			; 
82f1			; With current bank 
82f1			; Call presence test 
82f1			;    If not present format/init bank  
82f1			; Read block 0  
82f1			;  
82f1			 
82f1			 
82f1			; Dir 
82f1			; --- 
82f1			; 
82f1			; With current bank 
82f1			; Load Block 0 Config 
82f1			; Get max file id number 
82f1			; For each logical block 
82f1			;    Read block read byte 2 
82f1			;      if first block of file 
82f1			;         Display file name 
82f1			;         Display type flags for file 
82f1			;        
82f1			 
82f1			; moving to words as this requires stack control 
82f1			 
82f1			 
82f1			; Delete File 
82f1			; ----------- 
82f1			; 
82f1			; With current bank 
82f1			; 
82f1			; Load Block 0 Config 
82f1			; Get max file id number 
82f1			; For each logical block 
82f1			;    Read block file id 
82f1			;      If first block of file and dont have file id 
82f1			;         if file to delete 
82f1			;         Save file id 
82f1			;         Null file id 
82f1			;         Write this block back 
82f1			;      If file id is one saved 
82f1			;         Null file id 
82f1			;         Write this block back 
82f1			 
82f1			storage_erase: 
82f1			 
82f1				; hl contains the file id 
82f1			 
82f1 5d				ld e, l 
82f2 16 00			ld d, 0 
82f4 21 40 00			ld hl, STORE_BLOCK_PHY 
82f7					if DEBUG_FORTH_WORDS 
82f7						DMARK "ERA" 
82f7 f5				push af  
82f8 3a 0c 83			ld a, (.dmark)  
82fb 32 c0 ee			ld (debug_mark),a  
82fe 3a 0d 83			ld a, (.dmark+1)  
8301 32 c1 ee			ld (debug_mark+1),a  
8304 3a 0e 83			ld a, (.dmark+2)  
8307 32 c2 ee			ld (debug_mark+2),a  
830a 18 03			jr .pastdmark  
830c ..			.dmark: db "ERA"  
830f f1			.pastdmark: pop af  
8310			endm  
# End of macro DMARK
8310						CALLMONITOR 
8310 cd 2e 93			call break_point_state  
8313				endm  
# End of macro CALLMONITOR
8313					endif 
8313 cd d6 83			call storage_findnextid 
8316 cd e4 8a			call ishlzero 
8319 c8				ret z 
831a			 
831a e5				push hl 
831b			 
831b				; TODO check file not found 
831b			 
831b 11 eb ec			ld de, store_page 
831e cd b1 80			call storage_read_block 
8321			 
8321					if DEBUG_FORTH_WORDS 
8321						DMARK "ER1" 
8321 f5				push af  
8322 3a 36 83			ld a, (.dmark)  
8325 32 c0 ee			ld (debug_mark),a  
8328 3a 37 83			ld a, (.dmark+1)  
832b 32 c1 ee			ld (debug_mark+1),a  
832e 3a 38 83			ld a, (.dmark+2)  
8331 32 c2 ee			ld (debug_mark+2),a  
8334 18 03			jr .pastdmark  
8336 ..			.dmark: db "ER1"  
8339 f1			.pastdmark: pop af  
833a			endm  
# End of macro DMARK
833a						CALLMONITOR 
833a cd 2e 93			call break_point_state  
833d				endm  
# End of macro CALLMONITOR
833d					endif 
833d 3a eb ec			ld a, (store_page)	; get file id 
8340 32 e4 ec			ld (store_tmpid), a 
8343			 
8343 3a ed ec			ld a, (store_page+2)    ; get count of extends 
8346 32 e3 ec			ld (store_tmpext), a 
8349			 
8349				; wipe file header 
8349			 
8349 e1				pop hl 
834a 3e 00			ld a, 0 
834c 32 eb ec			ld (store_page), a 
834f 32 ec ec			ld (store_page+1),a 
8352 11 eb ec			ld de, store_page 
8355					if DEBUG_FORTH_WORDS 
8355						DMARK "ER2" 
8355 f5				push af  
8356 3a 6a 83			ld a, (.dmark)  
8359 32 c0 ee			ld (debug_mark),a  
835c 3a 6b 83			ld a, (.dmark+1)  
835f 32 c1 ee			ld (debug_mark+1),a  
8362 3a 6c 83			ld a, (.dmark+2)  
8365 32 c2 ee			ld (debug_mark+2),a  
8368 18 03			jr .pastdmark  
836a ..			.dmark: db "ER2"  
836d f1			.pastdmark: pop af  
836e			endm  
# End of macro DMARK
836e						CALLMONITOR 
836e cd 2e 93			call break_point_state  
8371				endm  
# End of macro CALLMONITOR
8371					endif 
8371 cd 16 81			call storage_write_block 
8374			 
8374			 
8374				; wipe file extents 
8374			 
8374 3a e3 ec			ld a, (store_tmpext) 
8377 47				ld b, a 
8378			 
8378			.eraext:	  
8378 c5				push bc 
8379			 
8379 21 40 00			ld hl, STORE_BLOCK_PHY 
837c 3a e4 ec			ld a,(store_tmpid) 
837f 5f				ld e, a 
8380 50				ld d, b	 
8381					if DEBUG_FORTH_WORDS 
8381						DMARK "ER3" 
8381 f5				push af  
8382 3a 96 83			ld a, (.dmark)  
8385 32 c0 ee			ld (debug_mark),a  
8388 3a 97 83			ld a, (.dmark+1)  
838b 32 c1 ee			ld (debug_mark+1),a  
838e 3a 98 83			ld a, (.dmark+2)  
8391 32 c2 ee			ld (debug_mark+2),a  
8394 18 03			jr .pastdmark  
8396 ..			.dmark: db "ER3"  
8399 f1			.pastdmark: pop af  
839a			endm  
# End of macro DMARK
839a						CALLMONITOR 
839a cd 2e 93			call break_point_state  
839d				endm  
# End of macro CALLMONITOR
839d					endif 
839d cd d6 83			call storage_findnextid 
83a0			 
83a0 e5				push hl 
83a1 11 eb ec			ld de, store_page 
83a4 cd b1 80			call storage_read_block 
83a7			 
83a7				; free block	 
83a7			 
83a7 3e 00			ld a, 0 
83a9 32 eb ec			ld (store_page), a 
83ac 32 ec ec			ld (store_page+1),a 
83af 11 eb ec			ld de, store_page 
83b2 e1				pop hl 
83b3					if DEBUG_FORTH_WORDS 
83b3						DMARK "ER4" 
83b3 f5				push af  
83b4 3a c8 83			ld a, (.dmark)  
83b7 32 c0 ee			ld (debug_mark),a  
83ba 3a c9 83			ld a, (.dmark+1)  
83bd 32 c1 ee			ld (debug_mark+1),a  
83c0 3a ca 83			ld a, (.dmark+2)  
83c3 32 c2 ee			ld (debug_mark+2),a  
83c6 18 03			jr .pastdmark  
83c8 ..			.dmark: db "ER4"  
83cb f1			.pastdmark: pop af  
83cc			endm  
# End of macro DMARK
83cc						CALLMONITOR 
83cc cd 2e 93			call break_point_state  
83cf				endm  
# End of macro CALLMONITOR
83cf					endif 
83cf cd 16 81			call storage_write_block 
83d2			 
83d2 c1				pop bc 
83d3 10 a3			djnz .eraext 
83d5			 
83d5 c9				ret 
83d6			 
83d6			 
83d6			; Find Free Block 
83d6			; --------------- 
83d6			; 
83d6			; With current bank 
83d6			;  
83d6			; From given starting logical block 
83d6			;    Read block  
83d6			;    If no file id 
83d6			;         Return block id 
83d6			 
83d6			 
83d6			; hl starting page number 
83d6			; hl contains free page number or zero if no pages free 
83d6			; e contains the file id to locate 
83d6			; d contains the block number 
83d6			 
83d6			; TODO change to find file id and use zero for free block 
83d6			 
83d6			storage_findnextid: 
83d6			 
83d6				; now locate first 0 page to mark as a free block 
83d6			 
83d6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
83d8			;	ld hl, STORE_BLOCK_PHY 
83d8			 
83d8					if DEBUG_FORTH_WORDS 
83d8					DMARK "FNI" 
83d8 f5				push af  
83d9 3a ed 83			ld a, (.dmark)  
83dc 32 c0 ee			ld (debug_mark),a  
83df 3a ee 83			ld a, (.dmark+1)  
83e2 32 c1 ee			ld (debug_mark+1),a  
83e5 3a ef 83			ld a, (.dmark+2)  
83e8 32 c2 ee			ld (debug_mark+2),a  
83eb 18 03			jr .pastdmark  
83ed ..			.dmark: db "FNI"  
83f0 f1			.pastdmark: pop af  
83f1			endm  
# End of macro DMARK
83f1						CALLMONITOR 
83f1 cd 2e 93			call break_point_state  
83f4				endm  
# End of macro CALLMONITOR
83f4					endif 
83f4			.ff1:   	 
83f4 e5					push hl 
83f5 c5					push bc 
83f6 d5					push de 
83f7 cd ae 80				call se_readbyte 
83fa 5f					ld e,a 
83fb 23					inc hl 
83fc cd ae 80				call se_readbyte 
83ff 57					ld d, a 
8400 e1					pop hl 
8401 e5					push hl 
8402 cd d9 8a				call cmp16 
8405 28 49				jr z, .fffound 
8407			 
8407 d1					pop de 
8408 c1					pop bc 
8409 e1					pop hl 
840a			 
840a					; is found? 
840a					;cp e 
840a					;ret z 
840a			 
840a 3e 40				ld a, STORE_BLOCK_PHY 
840c cd bb 8a				call addatohl 
840f 10 e3				djnz .ff1 
8411			 
8411 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8413			.ff2:   	 
8413			 
8413 e5					push hl 
8414 c5					push bc 
8415 d5					push de 
8416 cd ae 80				call se_readbyte 
8419 5f					ld e,a 
841a 23					inc hl 
841b cd ae 80				call se_readbyte 
841e 57					ld d, a 
841f			 
841f e1					pop hl 
8420 e5					push hl 
8421 cd d9 8a				call cmp16 
8424 28 2a				jr z, .fffound 
8426			 
8426 d1					pop de 
8427 c1					pop bc 
8428 e1					pop hl 
8429					; is found? 
8429					;cp e 
8429					;ret z 
8429			 
8429 3e 40				ld a, STORE_BLOCK_PHY 
842b cd bb 8a				call addatohl 
842e 10 e3				djnz .ff2 
8430			 
8430			 
8430					if DEBUG_FORTH_WORDS 
8430					DMARK "FN-" 
8430 f5				push af  
8431 3a 45 84			ld a, (.dmark)  
8434 32 c0 ee			ld (debug_mark),a  
8437 3a 46 84			ld a, (.dmark+1)  
843a 32 c1 ee			ld (debug_mark+1),a  
843d 3a 47 84			ld a, (.dmark+2)  
8440 32 c2 ee			ld (debug_mark+2),a  
8443 18 03			jr .pastdmark  
8445 ..			.dmark: db "FN-"  
8448 f1			.pastdmark: pop af  
8449			endm  
# End of macro DMARK
8449					;	push af 
8449					;	ld a, 'n' 
8449					;	ld (debug_mark),a 
8449					;	pop af 
8449						CALLMONITOR 
8449 cd 2e 93			call break_point_state  
844c				endm  
# End of macro CALLMONITOR
844c					endif 
844c				; no free marks! 
844c 21 00 00				ld hl, 0 
844f c9				ret 
8450			.fffound: 
8450				 
8450			 
8450 d1					pop de 
8451 c1					pop bc 
8452 e1					pop hl 
8453					if DEBUG_FORTH_WORDS 
8453					DMARK "FNF" 
8453 f5				push af  
8454 3a 68 84			ld a, (.dmark)  
8457 32 c0 ee			ld (debug_mark),a  
845a 3a 69 84			ld a, (.dmark+1)  
845d 32 c1 ee			ld (debug_mark+1),a  
8460 3a 6a 84			ld a, (.dmark+2)  
8463 32 c2 ee			ld (debug_mark+2),a  
8466 18 03			jr .pastdmark  
8468 ..			.dmark: db "FNF"  
846b f1			.pastdmark: pop af  
846c			endm  
# End of macro DMARK
846c					;	push af 
846c					;	ld a, 'n' 
846c					;	ld (debug_mark),a 
846c					;	pop af 
846c						CALLMONITOR 
846c cd 2e 93			call break_point_state  
846f				endm  
# End of macro CALLMONITOR
846f					endif 
846f c9				ret 
8470			 
8470			 
8470			 
8470			; Free Space 
8470			; ---------- 
8470			; 
8470			; With current bank 
8470			; 
8470			; Set block count to zero 
8470			; Starting with first logical block 
8470			;      Find free block  
8470			;      If block id given, increment block count 
8470			; 
8470			;  
8470			 
8470			 
8470			; hl contains count of free blocks 
8470			 
8470			storage_freeblocks: 
8470			 
8470				; now locate first 0 page to mark as a free block 
8470			 
8470 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8472 21 40 00			ld hl, STORE_BLOCK_PHY 
8475 11 00 00			ld de, 0 
8478			 
8478			.fb1:   	 
8478 e5					push hl 
8479 c5					push bc 
847a d5					push de 
847b cd ae 80				call se_readbyte 
847e d1					pop de 
847f c1					pop bc 
8480 e1					pop hl 
8481			 
8481					; is free? 
8481 fe 00				cp 0 
8483 20 01				jr nz, .ff1cont 
8485 13					inc de 
8486			 
8486			.ff1cont: 
8486			 
8486			 
8486 3e 40				ld a, STORE_BLOCK_PHY 
8488 cd bb 8a				call addatohl 
848b 10 eb				djnz .fb1 
848d			 
848d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
848f			.fb2:   	 
848f e5					push hl 
8490 c5					push bc 
8491 d5					push de 
8492 cd ae 80				call se_readbyte 
8495 d1					pop de 
8496 c1					pop bc 
8497 e1					pop hl 
8498			 
8498					; is free? 
8498 fe 00				cp 0 
849a 20 01				jr nz, .ff2cont 
849c 13					inc de 
849d			 
849d			.ff2cont: 
849d			 
849d 3e 40				ld a, STORE_BLOCK_PHY 
849f cd bb 8a				call addatohl 
84a2 10 eb				djnz .fb2 
84a4			 
84a4 eb				ex de, hl 
84a5 c9				ret 
84a6			 
84a6			; Get File ID 
84a6			; ----------- 
84a6			; 
84a6			; With current bank 
84a6			;  
84a6			; Load Block 0 Config 
84a6			; Get max file id number 
84a6			; For each logical block 
84a6			;    Read block file id 
84a6			;      If first block of file and dont have file id 
84a6			;         if file get id and exit 
84a6			 
84a6			 
84a6			 
84a6			 
84a6			; Create File 
84a6			; ----------- 
84a6			; 
84a6			; With current bank  
84a6			; Load Block 0 Config 
84a6			; Get max file id number 
84a6			; Increment file id number 
84a6			; Save Config 
84a6			; Find free block 
84a6			; Set buffer with file name and file id 
84a6			; Write buffer to free block  
84a6			 
84a6			 
84a6			; hl point to file name 
84a6			; hl returns file id 
84a6			 
84a6			; file format: 
84a6			; byte 0 - file id 
84a6			; byte 1 - extent number 
84a6			; byte 2-> data 
84a6			 
84a6			; format for extent number 0: 
84a6			; 
84a6			; byte 0 - file id 
84a6			; byte 1 - extent 0 
84a6			; byte 2 - extent count 
84a6			; byte 3 -> file name and meta data 
84a6			 
84a6			 
84a6			storage_create: 
84a6				if DEBUG_STORESE 
84a6					DMARK "SCR" 
84a6 f5				push af  
84a7 3a bb 84			ld a, (.dmark)  
84aa 32 c0 ee			ld (debug_mark),a  
84ad 3a bc 84			ld a, (.dmark+1)  
84b0 32 c1 ee			ld (debug_mark+1),a  
84b3 3a bd 84			ld a, (.dmark+2)  
84b6 32 c2 ee			ld (debug_mark+2),a  
84b9 18 03			jr .pastdmark  
84bb ..			.dmark: db "SCR"  
84be f1			.pastdmark: pop af  
84bf			endm  
# End of macro DMARK
84bf					CALLMONITOR 
84bf cd 2e 93			call break_point_state  
84c2				endm  
# End of macro CALLMONITOR
84c2				endif 
84c2			 
84c2 e5				push hl		; save file name pointer 
84c3			 
84c3 cd 62 81			call storage_get_block_0 
84c6			 
84c6 3a eb ec			ld a,(store_page)	; get current file id 
84c9 3c				inc a 
84ca 32 eb ec			ld (store_page),a 
84cd				 
84cd 32 e4 ec			ld (store_tmpid),a			; save id 
84d0			 
84d0 21 00 00			ld hl, 0 
84d3 11 eb ec			ld de, store_page 
84d6				if DEBUG_STORESE 
84d6					DMARK "SCw" 
84d6 f5				push af  
84d7 3a eb 84			ld a, (.dmark)  
84da 32 c0 ee			ld (debug_mark),a  
84dd 3a ec 84			ld a, (.dmark+1)  
84e0 32 c1 ee			ld (debug_mark+1),a  
84e3 3a ed 84			ld a, (.dmark+2)  
84e6 32 c2 ee			ld (debug_mark+2),a  
84e9 18 03			jr .pastdmark  
84eb ..			.dmark: db "SCw"  
84ee f1			.pastdmark: pop af  
84ef			endm  
# End of macro DMARK
84ef					CALLMONITOR 
84ef cd 2e 93			call break_point_state  
84f2				endm  
# End of macro CALLMONITOR
84f2				endif 
84f2 cd 16 81			call storage_write_block	 ; save update 
84f5			 
84f5				if DEBUG_STORESE 
84f5 11 eb ec				ld de, store_page 
84f8					DMARK "SCC" 
84f8 f5				push af  
84f9 3a 0d 85			ld a, (.dmark)  
84fc 32 c0 ee			ld (debug_mark),a  
84ff 3a 0e 85			ld a, (.dmark+1)  
8502 32 c1 ee			ld (debug_mark+1),a  
8505 3a 0f 85			ld a, (.dmark+2)  
8508 32 c2 ee			ld (debug_mark+2),a  
850b 18 03			jr .pastdmark  
850d ..			.dmark: db "SCC"  
8510 f1			.pastdmark: pop af  
8511			endm  
# End of macro DMARK
8511					CALLMONITOR 
8511 cd 2e 93			call break_point_state  
8514				endm  
# End of macro CALLMONITOR
8514				endif 
8514				;  
8514				 
8514 21 40 00			ld hl, STORE_BLOCK_PHY 
8517 11 00 00			ld de, 0 
851a cd d6 83			call storage_findnextid 
851d			 
851d 22 d5 ec			ld (store_tmppageid), hl    ; save page to use  
8520			 
8520				; TODO detect 0 = no spare blocks 
8520			 
8520				; hl now contains the free page to use for the file header page 
8520			 
8520				if DEBUG_STORESE 
8520				DMARK "SCF" 
8520 f5				push af  
8521 3a 35 85			ld a, (.dmark)  
8524 32 c0 ee			ld (debug_mark),a  
8527 3a 36 85			ld a, (.dmark+1)  
852a 32 c1 ee			ld (debug_mark+1),a  
852d 3a 37 85			ld a, (.dmark+2)  
8530 32 c2 ee			ld (debug_mark+2),a  
8533 18 03			jr .pastdmark  
8535 ..			.dmark: db "SCF"  
8538 f1			.pastdmark: pop af  
8539			endm  
# End of macro DMARK
8539					CALLMONITOR 
8539 cd 2e 93			call break_point_state  
853c				endm  
# End of macro CALLMONITOR
853c				endif 
853c			 
853c 22 d5 ec			ld (store_tmppageid), hl 
853f				 
853f 3a e4 ec			ld a,(store_tmpid)    ; get file id 
8542			;	ld a, (store_filecache)			; save to cache 
8542			 
8542 32 eb ec			ld (store_page),a    ; set page id 
8545 3e 00			ld a, 0			 ; extent 0 is file header 
8547 32 ec ec			ld (store_page+1), a   ; set file extent 
854a			 
854a 32 ed ec			ld (store_page+2), a   ; extent count for the file 
854d			 
854d			;	inc hl 		; init block 0 of file 
854d			;	inc hl   		; skip file and extent id 
854d			 ;       ld a, 0 
854d			;	ld (hl),a 
854d			;	ld a, (store_filecache+1)  	; save to cache 
854d			 
854d			;	inc hl    ; file name 
854d				 
854d				 
854d 11 ee ec			ld de, store_page+3    ; get buffer for term string to use as file name 
8550				if DEBUG_STORESE 
8550					DMARK "SCc" 
8550 f5				push af  
8551 3a 65 85			ld a, (.dmark)  
8554 32 c0 ee			ld (debug_mark),a  
8557 3a 66 85			ld a, (.dmark+1)  
855a 32 c1 ee			ld (debug_mark+1),a  
855d 3a 67 85			ld a, (.dmark+2)  
8560 32 c2 ee			ld (debug_mark+2),a  
8563 18 03			jr .pastdmark  
8565 ..			.dmark: db "SCc"  
8568 f1			.pastdmark: pop af  
8569			endm  
# End of macro DMARK
8569					CALLMONITOR 
8569 cd 2e 93			call break_point_state  
856c				endm  
# End of macro CALLMONITOR
856c				endif 
856c e1				pop hl    ; get zero term string 
856d e5				push hl 
856e 3e 00			ld a, 0 
8570 cd 24 8f			call strlent 
8573 23				inc hl   ; cover zero term 
8574 06 00			ld b,0 
8576 4d				ld c,l 
8577 e1				pop hl 
8578				;ex de, hl 
8578				if DEBUG_STORESE 
8578					DMARK "SCa" 
8578 f5				push af  
8579 3a 8d 85			ld a, (.dmark)  
857c 32 c0 ee			ld (debug_mark),a  
857f 3a 8e 85			ld a, (.dmark+1)  
8582 32 c1 ee			ld (debug_mark+1),a  
8585 3a 8f 85			ld a, (.dmark+2)  
8588 32 c2 ee			ld (debug_mark+2),a  
858b 18 03			jr .pastdmark  
858d ..			.dmark: db "SCa"  
8590 f1			.pastdmark: pop af  
8591			endm  
# End of macro DMARK
8591					;push af 
8591					;ld a, 'a' 
8591					;ld (debug_mark),a 
8591					;pop af 
8591					CALLMONITOR 
8591 cd 2e 93			call break_point_state  
8594				endm  
# End of macro CALLMONITOR
8594				endif 
8594 ed b0			ldir    ; copy zero term string 
8596				if DEBUG_STORESE 
8596					DMARK "SCA" 
8596 f5				push af  
8597 3a ab 85			ld a, (.dmark)  
859a 32 c0 ee			ld (debug_mark),a  
859d 3a ac 85			ld a, (.dmark+1)  
85a0 32 c1 ee			ld (debug_mark+1),a  
85a3 3a ad 85			ld a, (.dmark+2)  
85a6 32 c2 ee			ld (debug_mark+2),a  
85a9 18 03			jr .pastdmark  
85ab ..			.dmark: db "SCA"  
85ae f1			.pastdmark: pop af  
85af			endm  
# End of macro DMARK
85af					CALLMONITOR 
85af cd 2e 93			call break_point_state  
85b2				endm  
# End of macro CALLMONITOR
85b2				endif 
85b2			 
85b2				; write file header page 
85b2			 
85b2 2a d5 ec			ld hl,(store_tmppageid) 
85b5 11 eb ec			ld de, store_page 
85b8				if DEBUG_STORESE 
85b8					DMARK "SCb" 
85b8 f5				push af  
85b9 3a cd 85			ld a, (.dmark)  
85bc 32 c0 ee			ld (debug_mark),a  
85bf 3a ce 85			ld a, (.dmark+1)  
85c2 32 c1 ee			ld (debug_mark+1),a  
85c5 3a cf 85			ld a, (.dmark+2)  
85c8 32 c2 ee			ld (debug_mark+2),a  
85cb 18 03			jr .pastdmark  
85cd ..			.dmark: db "SCb"  
85d0 f1			.pastdmark: pop af  
85d1			endm  
# End of macro DMARK
85d1					;push af 
85d1					;ld a, 'b' 
85d1					;ld (debug_mark),a 
85d1					;pop af 
85d1					CALLMONITOR 
85d1 cd 2e 93			call break_point_state  
85d4				endm  
# End of macro CALLMONITOR
85d4				endif 
85d4 cd 16 81			call storage_write_block 
85d7			 
85d7 3a e4 ec			ld a, (store_tmpid) 
85da 6f				ld l, a 
85db 26 00			ld h,0 
85dd				if DEBUG_STORESE 
85dd					DMARK "SCz" 
85dd f5				push af  
85de 3a f2 85			ld a, (.dmark)  
85e1 32 c0 ee			ld (debug_mark),a  
85e4 3a f3 85			ld a, (.dmark+1)  
85e7 32 c1 ee			ld (debug_mark+1),a  
85ea 3a f4 85			ld a, (.dmark+2)  
85ed 32 c2 ee			ld (debug_mark+2),a  
85f0 18 03			jr .pastdmark  
85f2 ..			.dmark: db "SCz"  
85f5 f1			.pastdmark: pop af  
85f6			endm  
# End of macro DMARK
85f6					CALLMONITOR 
85f6 cd 2e 93			call break_point_state  
85f9				endm  
# End of macro CALLMONITOR
85f9				endif 
85f9 c9				ret 
85fa				 
85fa			 
85fa			 
85fa			; 
85fa			; Read File 
85fa			; 
85fa			; h - file id to locate 
85fa			; l - extent to locate 
85fa			; de - pointer to string to read into 
85fa			; 
85fa			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
85fa			 
85fa			.sr_fail: 
85fa d1				pop de 
85fb c9				ret 
85fc			 
85fc			storage_read: 
85fc d5				push de 
85fd			 
85fd			; TODO BUG the above push is it popped before the RET Z? 
85fd			 
85fd			; TODO how to handle multiple part blocks 
85fd			 
85fd				; locate file extent to read 
85fd			 
85fd 5c				ld e, h 
85fe 55				ld d, l 
85ff 21 40 00			ld hl, STORE_BLOCK_PHY 
8602				if DEBUG_STORESE 
8602					DMARK "SRE" 
8602 f5				push af  
8603 3a 17 86			ld a, (.dmark)  
8606 32 c0 ee			ld (debug_mark),a  
8609 3a 18 86			ld a, (.dmark+1)  
860c 32 c1 ee			ld (debug_mark+1),a  
860f 3a 19 86			ld a, (.dmark+2)  
8612 32 c2 ee			ld (debug_mark+2),a  
8615 18 03			jr .pastdmark  
8617 ..			.dmark: db "SRE"  
861a f1			.pastdmark: pop af  
861b			endm  
# End of macro DMARK
861b					CALLMONITOR 
861b cd 2e 93			call break_point_state  
861e				endm  
# End of macro CALLMONITOR
861e				endif 
861e cd d6 83			call storage_findnextid 
8621			 
8621				if DEBUG_STORESE 
8621					DMARK "SRf" 
8621 f5				push af  
8622 3a 36 86			ld a, (.dmark)  
8625 32 c0 ee			ld (debug_mark),a  
8628 3a 37 86			ld a, (.dmark+1)  
862b 32 c1 ee			ld (debug_mark+1),a  
862e 3a 38 86			ld a, (.dmark+2)  
8631 32 c2 ee			ld (debug_mark+2),a  
8634 18 03			jr .pastdmark  
8636 ..			.dmark: db "SRf"  
8639 f1			.pastdmark: pop af  
863a			endm  
# End of macro DMARK
863a					CALLMONITOR 
863a cd 2e 93			call break_point_state  
863d				endm  
# End of macro CALLMONITOR
863d				endif 
863d cd e4 8a			call ishlzero 
8640			;	ld a, l 
8640			;	add h 
8640			;	cp 0 
8640 28 b8			jr z,.sr_fail			; block not found so EOF 
8642			 
8642				; hl contains page number to load 
8642 d1				pop de   ; get storage 
8643 d5				push de 
8644				if DEBUG_STORESE 
8644					DMARK "SRg" 
8644 f5				push af  
8645 3a 59 86			ld a, (.dmark)  
8648 32 c0 ee			ld (debug_mark),a  
864b 3a 5a 86			ld a, (.dmark+1)  
864e 32 c1 ee			ld (debug_mark+1),a  
8651 3a 5b 86			ld a, (.dmark+2)  
8654 32 c2 ee			ld (debug_mark+2),a  
8657 18 03			jr .pastdmark  
8659 ..			.dmark: db "SRg"  
865c f1			.pastdmark: pop af  
865d			endm  
# End of macro DMARK
865d					CALLMONITOR 
865d cd 2e 93			call break_point_state  
8660				endm  
# End of macro CALLMONITOR
8660				endif 
8660 cd b1 80			call storage_read_block 
8663			 
8663			 
8663			; TODO if block has no zeros then need to read next block  
8663			 
8663			 
8663					 
8663 e1				pop hl 		 ; return start of data to show as not EOF 
8664 23				inc hl   ; past file id 
8665 23				inc hl   ; past ext 
8666				if DEBUG_STORESE 
8666					DMARK "SRe" 
8666 f5				push af  
8667 3a 7b 86			ld a, (.dmark)  
866a 32 c0 ee			ld (debug_mark),a  
866d 3a 7c 86			ld a, (.dmark+1)  
8670 32 c1 ee			ld (debug_mark+1),a  
8673 3a 7d 86			ld a, (.dmark+2)  
8676 32 c2 ee			ld (debug_mark+2),a  
8679 18 03			jr .pastdmark  
867b ..			.dmark: db "SRe"  
867e f1			.pastdmark: pop af  
867f			endm  
# End of macro DMARK
867f					CALLMONITOR 
867f cd 2e 93			call break_point_state  
8682				endm  
# End of macro CALLMONITOR
8682				endif 
8682 c9					ret 
8683			 
8683			 
8683			 
8683			; 
8683			; Append File 
8683			; 
8683			; hl - file id to locate 
8683			; de - pointer to (multi block) string to write 
8683			 
8683			.sa_notfound: 
8683 d1				pop de 
8684 c9				ret 
8685			 
8685			 
8685			storage_append: 
8685				; hl -  file id to append to 
8685				; de - string to append 
8685			 
8685 d5				push de 
8686				 
8686				if DEBUG_STORESE 
8686					DMARK "AP1" 
8686 f5				push af  
8687 3a 9b 86			ld a, (.dmark)  
868a 32 c0 ee			ld (debug_mark),a  
868d 3a 9c 86			ld a, (.dmark+1)  
8690 32 c1 ee			ld (debug_mark+1),a  
8693 3a 9d 86			ld a, (.dmark+2)  
8696 32 c2 ee			ld (debug_mark+2),a  
8699 18 03			jr .pastdmark  
869b ..			.dmark: db "AP1"  
869e f1			.pastdmark: pop af  
869f			endm  
# End of macro DMARK
869f					CALLMONITOR 
869f cd 2e 93			call break_point_state  
86a2				endm  
# End of macro CALLMONITOR
86a2				endif 
86a2			 
86a2 7d				ld a, l 
86a3 32 e4 ec			ld (store_tmpid), a 
86a6			 
86a6				; get file header  
86a6			 
86a6 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
86a8 3a e4 ec			ld a, (store_tmpid) 
86ab 5f				ld e, a 
86ac			 
86ac 21 40 00				ld hl, STORE_BLOCK_PHY 
86af cd d6 83				call storage_findnextid 
86b2			 
86b2 cd e4 8a			call ishlzero 
86b5 28 cc			jr z, .sa_notfound 
86b7			 
86b7 22 d5 ec			ld (store_tmppageid), hl 
86ba			 
86ba				; TODO handle file id not found 
86ba			 
86ba				if DEBUG_STORESE 
86ba					DMARK "AP2" 
86ba f5				push af  
86bb 3a cf 86			ld a, (.dmark)  
86be 32 c0 ee			ld (debug_mark),a  
86c1 3a d0 86			ld a, (.dmark+1)  
86c4 32 c1 ee			ld (debug_mark+1),a  
86c7 3a d1 86			ld a, (.dmark+2)  
86ca 32 c2 ee			ld (debug_mark+2),a  
86cd 18 03			jr .pastdmark  
86cf ..			.dmark: db "AP2"  
86d2 f1			.pastdmark: pop af  
86d3			endm  
# End of macro DMARK
86d3					CALLMONITOR 
86d3 cd 2e 93			call break_point_state  
86d6				endm  
# End of macro CALLMONITOR
86d6				endif 
86d6			 
86d6				; update file extent count 
86d6			 
86d6 11 eb ec			ld de, store_page 
86d9			 
86d9 cd b1 80			call storage_read_block 
86dc			 
86dc				if DEBUG_STORESE 
86dc					DMARK "AP3" 
86dc f5				push af  
86dd 3a f1 86			ld a, (.dmark)  
86e0 32 c0 ee			ld (debug_mark),a  
86e3 3a f2 86			ld a, (.dmark+1)  
86e6 32 c1 ee			ld (debug_mark+1),a  
86e9 3a f3 86			ld a, (.dmark+2)  
86ec 32 c2 ee			ld (debug_mark+2),a  
86ef 18 03			jr .pastdmark  
86f1 ..			.dmark: db "AP3"  
86f4 f1			.pastdmark: pop af  
86f5			endm  
# End of macro DMARK
86f5					CALLMONITOR 
86f5 cd 2e 93			call break_point_state  
86f8				endm  
# End of macro CALLMONITOR
86f8				endif 
86f8			;	ld (store_tmppageid), hl 
86f8			 
86f8 3a ed ec			ld a, (store_page+2) 
86fb 3c				inc a 
86fc 32 ed ec			ld (store_page+2), a 
86ff 32 e3 ec			ld (store_tmpext), a 
8702				 
8702				if DEBUG_STORESE 
8702					DMARK "AP3" 
8702 f5				push af  
8703 3a 17 87			ld a, (.dmark)  
8706 32 c0 ee			ld (debug_mark),a  
8709 3a 18 87			ld a, (.dmark+1)  
870c 32 c1 ee			ld (debug_mark+1),a  
870f 3a 19 87			ld a, (.dmark+2)  
8712 32 c2 ee			ld (debug_mark+2),a  
8715 18 03			jr .pastdmark  
8717 ..			.dmark: db "AP3"  
871a f1			.pastdmark: pop af  
871b			endm  
# End of macro DMARK
871b					CALLMONITOR 
871b cd 2e 93			call break_point_state  
871e				endm  
# End of macro CALLMONITOR
871e				endif 
871e 2a d5 ec			ld hl, (store_tmppageid) 
8721 11 eb ec			ld de, store_page 
8724 cd 16 81			call storage_write_block 
8727			 
8727				; find free block 
8727			 
8727 11 00 00			ld de, 0			 ; file extent to locate 
872a			 
872a 21 40 00				ld hl, STORE_BLOCK_PHY 
872d cd d6 83				call storage_findnextid 
8730 cd e4 8a			call ishlzero 
8733 ca 83 86			jp z, .sa_notfound 
8736			 
8736					; TODO handle no space left 
8736					 
8736 22 d5 ec				ld (store_tmppageid), hl 
8739			 
8739				if DEBUG_STORESE 
8739					DMARK "AP4" 
8739 f5				push af  
873a 3a 4e 87			ld a, (.dmark)  
873d 32 c0 ee			ld (debug_mark),a  
8740 3a 4f 87			ld a, (.dmark+1)  
8743 32 c1 ee			ld (debug_mark+1),a  
8746 3a 50 87			ld a, (.dmark+2)  
8749 32 c2 ee			ld (debug_mark+2),a  
874c 18 03			jr .pastdmark  
874e ..			.dmark: db "AP4"  
8751 f1			.pastdmark: pop af  
8752			endm  
# End of macro DMARK
8752					CALLMONITOR 
8752 cd 2e 93			call break_point_state  
8755				endm  
# End of macro CALLMONITOR
8755				endif 
8755					; init the buffer with zeros so we can id if the buffer is full or not 
8755			 
8755 e5					push hl 
8756 c5					push bc 
8757			 
8757 21 eb ec				ld hl, store_page 
875a 06 40				ld b, STORE_BLOCK_PHY 
875c 3e 00				ld a, 0 
875e 77			.zeroblock:	ld (hl), a 
875f 23					inc hl 
8760 10 fc				djnz .zeroblock 
8762			 
8762 c1					pop bc 
8763 e1					pop hl 
8764			 
8764					; construct block 
8764			 
8764 3a e4 ec				ld a, (store_tmpid) 
8767 32 eb ec				ld (store_page), a   ; file id 
876a 3a e3 ec				ld a, (store_tmpext)   ; extent for this block 
876d 32 ec ec				ld (store_page+1), a 
8770			 
8770 e1					pop hl    ; get string to write 
8771 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8773 11 ed ec				ld de, store_page+2 
8776			 
8776				if DEBUG_STORESE 
8776					DMARK "AP5" 
8776 f5				push af  
8777 3a 8b 87			ld a, (.dmark)  
877a 32 c0 ee			ld (debug_mark),a  
877d 3a 8c 87			ld a, (.dmark+1)  
8780 32 c1 ee			ld (debug_mark+1),a  
8783 3a 8d 87			ld a, (.dmark+2)  
8786 32 c2 ee			ld (debug_mark+2),a  
8789 18 03			jr .pastdmark  
878b ..			.dmark: db "AP5"  
878e f1			.pastdmark: pop af  
878f			endm  
# End of macro DMARK
878f					CALLMONITOR 
878f cd 2e 93			call break_point_state  
8792				endm  
# End of macro CALLMONITOR
8792				endif 
8792			 
8792			 
8792			 
8792					; fill buffer with data until end of string or full block 
8792			 
8792 7e			.appd:		ld a, (hl) 
8793 12					ld (de), a 
8794 fe 00				cp 0 
8796 28 04				jr z, .appdone 
8798 23					inc hl 
8799 13					inc de 
879a 10 f6				djnz .appd 
879c			 
879c e5			.appdone:	push hl		 	; save current source in case we need to go around again 
879d f5					push af   		; save last byte dumped 
879e			 
879e			 
879e 2a d5 ec			ld hl, (store_tmppageid) 
87a1 11 eb ec			ld de, store_page 
87a4				if DEBUG_STORESE 
87a4					DMARK "AP6" 
87a4 f5				push af  
87a5 3a b9 87			ld a, (.dmark)  
87a8 32 c0 ee			ld (debug_mark),a  
87ab 3a ba 87			ld a, (.dmark+1)  
87ae 32 c1 ee			ld (debug_mark+1),a  
87b1 3a bb 87			ld a, (.dmark+2)  
87b4 32 c2 ee			ld (debug_mark+2),a  
87b7 18 03			jr .pastdmark  
87b9 ..			.dmark: db "AP6"  
87bc f1			.pastdmark: pop af  
87bd			endm  
# End of macro DMARK
87bd					CALLMONITOR 
87bd cd 2e 93			call break_point_state  
87c0				endm  
# End of macro CALLMONITOR
87c0				endif 
87c0 cd 16 81				call storage_write_block 
87c3			 
87c3			 
87c3				; was that a full block of data written? 
87c3				; any more to write out? 
87c3			 
87c3				; if yes then set vars and jump to start of function again 
87c3			 
87c3 f1					pop af 
87c4 d1					pop de 
87c5			 
87c5 fe 00				cp 0		 ; no, string was fully written 
87c7 c8					ret z 
87c8			 
87c8					; setup vars for next cycle 
87c8			 
87c8 3a e4 ec				ld a, (store_tmpid) 
87cb 6f					ld l, a 
87cc 26 00				ld h, 0 
87ce			 
87ce c3 85 86			 	jp storage_append	 ; yes, need to write out some more 
87d1			 
87d1			 
87d1			 
87d1			 
87d1			 
87d1			 
87d1			 
87d1			if DEBUG_STORECF 
87d1			storageput:	 
87d1					ret 
87d1			storageread: 
87d1					ld hl, store_page 
87d1					ld b, 200 
87d1					ld a,0 
87d1			.src:		ld (hl),a 
87d1					inc hl 
87d1					djnz .src 
87d1					 
87d1			 
87d1					ld de, 0 
87d1					ld bc, 1 
87d1					ld hl, store_page 
87d1					call cfRead 
87d1			 
87d1				call cfGetError 
87d1				ld hl,scratch 
87d1				call hexout 
87d1				ld hl, scratch+2 
87d1				ld a, 0 
87d1				ld (hl),a 
87d1				ld de, scratch 
87d1				ld a,display_row_1 
87d1				call str_at_display 
87d1				call update_display 
87d1			 
87d1					ld hl, store_page 
87d1					ld (os_cur_ptr),hl 
87d1			 
87d1					ret 
87d1			endif 
87d1			 
87d1			 
87d1			; Clear out the main buffer store (used to remove junk before writing a new block) 
87d1			 
87d1			storage_clear_page: 
87d1 e5				push hl 
87d2 d5				push de 
87d3 c5				push bc 
87d4 21 eb ec			ld hl, store_page 
87d7 3e 00			ld a, 0 
87d9 77				ld (hl), a 
87da			 
87da 11 ec ec			ld de, store_page+1 
87dd 01 40 00			ld bc, STORE_BLOCK_PHY 
87e0			 
87e0 ed b0			ldir 
87e2				 
87e2 c1				pop bc 
87e3 d1				pop de 
87e4 e1				pop hl 
87e5 c9				ret 
87e6			 
87e6			; eof 
# End of file firmware_storage.asm
87e6			  
87e6			; support routines for above hardware abstraction layer  
87e6			  
87e6			include "firmware_general.asm"        ; general support functions  
87e6			 
87e6			; word look up 
87e6			 
87e6			; in 
87e6			; a is the index 
87e6			; hl is pointer start of array 
87e6			; 
87e6			; returns 
87e6			; hl to the word 
87e6			; 
87e6			 
87e6			table_lookup:  
87e6 d5					push de 
87e7 eb					ex de, hl 
87e8			 
87e8 6f					ld l, a 
87e9 26 00				ld h, 0 
87eb 29					add hl, hl 
87ec 19					add hl, de 
87ed 7e					ld a, (hl) 
87ee 23					inc hl 
87ef 66					ld h,(hl) 
87f0 6f					ld l, a 
87f1			 
87f1 d1					pop de 
87f2 c9					ret 
87f3			 
87f3			; Delay loops 
87f3			 
87f3			 
87f3			 
87f3			aDelayInMS: 
87f3 c5				push bc 
87f4 47				ld b,a 
87f5			msdelay: 
87f5 c5				push bc 
87f6				 
87f6			 
87f6 01 41 00			ld bc,041h 
87f9 cd 11 88			call delayloop 
87fc c1				pop bc 
87fd 05				dec b 
87fe 20 f5			jr nz,msdelay 
8800			 
8800			;if CPU_CLOCK_8MHZ 
8800			;msdelay8: 
8800			;	push bc 
8800			;	 
8800			; 
8800			;	ld bc,041h 
8800			;	call delayloop 
8800			;	pop bc 
8800			;	dec b 
8800			;	jr nz,msdelay8 
8800			;endif 
8800			 
8800			 
8800 c1				pop bc 
8801 c9				ret 
8802			 
8802			 
8802			delay250ms: 
8802				;push de 
8802 01 00 40			ld bc, 04000h 
8805 c3 11 88			jp delayloop 
8808			delay500ms: 
8808				;push de 
8808 01 00 80			ld bc, 08000h 
880b c3 11 88			jp delayloop 
880e			delay1s: 
880e				;push bc 
880e			   ; Clobbers A, d and e 
880e 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
8811			delayloop: 
8811 c5			    push bc 
8812			 
8812			if BASE_CPM 
8812				ld bc, CPM_DELAY_TUNE 
8812			.cpmloop: 
8812				push bc 
8812			 
8812			endif 
8812			 
8812			 
8812			 
8812			delayloopi: 
8812			;	push bc 
8812			;.dl: 
8812 cb 47		    bit     0,a    	; 8 
8814 cb 47		    bit     0,a    	; 8 
8816 cb 47		    bit     0,a    	; 8 
8818 e6 ff		    and     255  	; 7 
881a 0b			    dec     bc      	; 6 
881b 79			    ld      a,c     	; 4 
881c b0			    or      b     	; 4 
881d c2 12 88		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8820			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8820				;pop de 
8820			;pop bc 
8820			 
8820			if BASE_CPM 
8820				pop bc 
8820				 
8820			    dec     bc      	; 6 
8820			    ld      a,c     	; 4 
8820			    or      b     	; 4 
8820			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8820				 
8820			 
8820			endif 
8820			;if CPU_CLOCK_8MHZ 
8820			;    pop bc 
8820			;    push bc 
8820			;.dl8: 
8820			;    bit     0,a    	; 8 
8820			;    bit     0,a    	; 8 
8820			;    bit     0,a    	; 8 
8820			;    and     255  	; 7 
8820			;    dec     bc      	; 6 
8820			;    ld      a,c     	; 4 
8820			;    or      b     	; 4 
8820			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8820			;endif 
8820			 
8820			;if CPU_CLOCK_10MHZ 
8820			;    pop bc 
8820			;    push bc 
8820			;.dl8: 
8820			;    bit     0,a    	; 8 
8820			;    bit     0,a    	; 8 
8820			;    bit     0,a    	; 8 
8820			;    and     255  	; 7 
8820			;    dec     bc      	; 6 
8820			;    ld      a,c     	; 4 
8820			;    or      b     	; 4 
8820			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8820			;endif 
8820 c1			    pop bc 
8821			 
8821 c9				ret 
8822			 
8822			 
8822			 
8822			; eof 
# End of file firmware_general.asm
8822			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8822			; display routines that use the physical hardware abstraction layer 
8822			 
8822			 
8822			; information window 
8822			 
8822			; pass hl with 1st string to display 
8822			; pass de with 2nd string to display 
8822			 
8822			info_panel: 
8822 e5				push hl 
8823			 
8823 2a 61 ed			ld hl, (display_fb_active) 
8826 e5				push hl    ; future de destination 
8827 21 56 ee				ld hl, display_fb0 
882a 22 61 ed				ld (display_fb_active), hl 
882d			 
882d cd 8e 88			call clear_display 
8830			 
8830			 
8830 3e 2d			ld a, display_row_3 + 5 
8832 cd a1 88			call str_at_display 
8835			 
8835 e1				pop hl 
8836 d1				pop de 
8837			 
8837 e5				push hl 
8838			 
8838			 
8838 3e 19			ld a, display_row_2 + 5 
883a cd a1 88			call str_at_display 
883d			 
883d			 
883d cd b1 88			call update_display 
8840 cd 33 98			call next_page_prompt 
8843 cd 8e 88			call clear_display 
8846			 
8846				 
8846 21 05 ee				ld hl, display_fb1 
8849 22 61 ed				ld (display_fb_active), hl 
884c cd b1 88			call update_display 
884f			 
884f			 
884f c9				ret 
8850			 
8850			 
8850			 
8850			 
8850			; TODO windowing? 
8850			 
8850			; TODO scroll line up 
8850			 
8850			scroll_up: 
8850			 
8850 e5				push hl 
8851 d5				push de 
8852 c5				push bc 
8853			 
8853				; get frame buffer  
8853			 
8853 2a 61 ed			ld hl, (display_fb_active) 
8856 e5				push hl    ; future de destination 
8857			 
8857 11 14 00			ld  de, display_cols 
885a 19				add hl, de 
885b			 
885b d1				pop de 
885c			 
885c				;ex de, hl 
885c 01 4f 00			ld bc, display_fb_len -1  
885f			;if DEBUG_FORTH_WORDS 
885f			;	DMARK "SCL" 
885f			;	CALLMONITOR 
885f			;endif	 
885f ed b0			ldir 
8861			 
8861				; wipe bottom row 
8861			 
8861			 
8861 2a 61 ed			ld hl, (display_fb_active) 
8864 11 50 00			ld de, display_cols*display_rows 
8867 19				add hl, de 
8868 06 14			ld b, display_cols 
886a 3e 20			ld a, ' ' 
886c			.scwipe: 
886c 77				ld (hl), a 
886d 2b				dec hl 
886e 10 fc			djnz .scwipe 
8870			 
8870				;pop hl 
8870			 
8870 c1				pop bc 
8871 d1				pop de 
8872 e1				pop hl 
8873			 
8873 c9				ret 
8874			 
8874			 
8874			;scroll_upo: 
8874			;	ld de, display_row_1 
8874			 ;	ld hl, display_row_2 
8874			;	ld bc, display_cols 
8874			;	ldir 
8874			;	ld de, display_row_2 
8874			 ;	ld hl, display_row_3 
8874			;	ld bc, display_cols 
8874			;	ldir 
8874			;	ld de, display_row_3 
8874			 ;	ld hl, display_row_4 
8874			;	ld bc, display_cols 
8874			;	ldir 
8874			 
8874			; TODO clear row 4 
8874			 
8874			;	ret 
8874			 
8874				 
8874			scroll_down: 
8874			 
8874 e5				push hl 
8875 d5				push de 
8876 c5				push bc 
8877			 
8877				; get frame buffer  
8877			 
8877 2a 61 ed			ld hl, (display_fb_active) 
887a			 
887a 11 4f 00			ld de, display_fb_len - 1 
887d 19				add hl, de 
887e			 
887e e5			push hl    ; future de destination 
887f			 
887f 11 14 00			ld  de, display_cols 
8882 ed 52			sbc hl, de 
8884			 
8884			 
8884 d1				pop de 
8885			 
8885			;	ex de, hl 
8885 01 4f 00			ld bc, display_fb_len -1  
8888			 
8888			 
8888				 
8888			 
8888 ed b0			ldir 
888a			 
888a				; wipe bottom row 
888a			 
888a			 
888a			;	ld hl, (display_fb_active) 
888a			;;	ld de, display_cols*display_rows 
888a			;;	add hl, de 
888a			;	ld b, display_cols 
888a			;	ld a, ' ' 
888a			;.scwiped: 
888a			;	ld (hl), a 
888a			;	dec hl 
888a			;	djnz .scwiped 
888a			 
888a				;pop hl 
888a			 
888a c1				pop bc 
888b d1				pop de 
888c e1				pop hl 
888d			 
888d c9				ret 
888e			;scroll_down: 
888e			;	ld de, display_row_4 
888e			;	ld hl, display_row_3 
888e			;	ld bc, display_cols 
888e			;	ldir 
888e			;	ld de, display_row_3 
888e			; 	ld hl, display_row_2 
888e			;	ld bc, display_cols 
888e			;	ldir 
888e			;	ld de, display_row_2 
888e			;	ld hl, display_row_1 
888e			;	ld bc, display_cols 
888e			;	ldir 
888e			;;; TODO clear row 1 
888e			;	ret 
888e			 
888e			 
888e			 
888e			 
888e			 
888e			; clear active frame buffer 
888e			 
888e			clear_display: 
888e 3e 20			ld a, ' ' 
8890 c3 93 88			jp fill_display 
8893			 
8893			; fill active frame buffer with a char in A 
8893			 
8893			fill_display: 
8893 06 50			ld b,display_fb_len 
8895 2a 61 ed			ld hl, (display_fb_active) 
8898 77			.fd1:	ld (hl),a 
8899 23				inc hl 
889a 10 fc			djnz .fd1 
889c 23				inc hl 
889d 3e 00			ld a,0 
889f 77				ld (hl),a 
88a0			 
88a0			 
88a0 c9				ret 
88a1			; Write string (DE) at pos (A) to active frame buffer 
88a1			 
88a1 2a 61 ed		str_at_display:    ld hl,(display_fb_active) 
88a4 06 00					ld b,0 
88a6 4f					ld c,a 
88a7 09					add hl,bc 
88a8 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
88a9 b7			            OR   A              ;Null terminator? 
88aa c8			            RET  Z              ;Yes, so finished 
88ab 77					ld (hl),a 
88ac 23				inc hl 
88ad 13			            INC  DE             ;Point to next character 
88ae 18 f8		            JR   .sad1     ;Repeat 
88b0 c9					ret 
88b1			 
88b1			; using current frame buffer write to physical display 
88b1			 
88b1			update_display: 
88b1 e5				push hl 
88b2 2a 61 ed			ld hl, (display_fb_active) 
88b5 cd e3 d6			call write_display 
88b8 e1				pop hl 
88b9 c9				ret 
88ba			 
88ba			; TODO scrolling 
88ba			 
88ba			 
88ba			; move cursor right one char 
88ba			cursor_right: 
88ba			 
88ba				; TODO shift right 
88ba				; TODO if beyond max col 
88ba				; TODO       cursor_next_line 
88ba			 
88ba c9				ret 
88bb			 
88bb			 
88bb			cursor_next_line: 
88bb				; TODO first char 
88bb				; TODO line down 
88bb				; TODO if past last row 
88bb				; TODO    scroll up 
88bb			 
88bb c9				ret 
88bc			 
88bc			cursor_left: 
88bc				; TODO shift left 
88bc				; TODO if beyond left  
88bc				; TODO     cursor prev line 
88bc				 
88bc c9				ret 
88bd			 
88bd			cursor_prev_line: 
88bd				; TODO last char 
88bd				; TODO line up 
88bd				; TODO if past first row 
88bd				; TODO   scroll down 
88bd			 
88bd c9				ret 
88be			 
88be			 
88be			cout: 
88be				; A - char 
88be c9				ret 
88bf			 
88bf			 
88bf			; Display a menu and allow item selection (optional toggle items) 
88bf			; 
88bf			; format: 
88bf			; hl pointer to word array with zero term for items 
88bf			; e.g.    db item1 
88bf			;         db .... 
88bf			;         db 0 
88bf			; 
88bf			; a = starting menu item  
88bf			; 
88bf			; de = pointer item toggle array   (todo) 
88bf			; 
88bf			; returns item selected in a 1-... 
88bf			; returns 0 if back button pressed 
88bf			; 
88bf			; NOTE: Uses system frame buffer to display 
88bf			; 
88bf			; LEFT, Q = go back 
88bf			; RIGHT, SPACE, CR = select 
88bf			; UP, A - Up 
88bf			; DOWN, Z - Down 
88bf			 
88bf			 
88bf			 
88bf			 
88bf			 
88bf			menu: 
88bf			 
88bf					; keep array pointer 
88bf			 
88bf 22 e9 ec				ld (store_tmp1), hl 
88c2 32 e7 ec				ld (store_tmp2), a 
88c5			 
88c5					; check for key bounce 
88c5			 
88c5			if BASE_KEV 
88c5			 
88c5			.mbounce:	call cin 
88c5					cp 0 
88c5					jr nz, .mbounce 
88c5			endif 
88c5					; for ease use ex 
88c5			 
88c5					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
88c5 21 56 ee				ld hl, display_fb0 
88c8 22 61 ed				ld (display_fb_active), hl 
88cb			 
88cb cd 8e 88		.mloop:		call clear_display 
88ce cd b1 88				call update_display 
88d1			 
88d1					; draw selection id '>' at 1 
88d1			 
88d1					; init start of list display 
88d1			 
88d1 3e 05				ld a, 5 
88d3 32 e5 ec				ld (store_tmp3), a   ; display row count 
88d6 3a e7 ec				ld a,( store_tmp2) 
88d9 32 e8 ec				ld (store_tmp2+1), a   ; display item count 
88dc			 
88dc					 
88dc			.mitem:	 
88dc			 
88dc			 
88dc 3a e8 ec				ld a,(store_tmp2+1) 
88df 6f					ld l, a 
88e0 26 00				ld h, 0 
88e2 29					add hl, hl 
88e3 ed 5b e9 ec			ld de, (store_tmp1) 
88e7 19					add hl, de 
88e8 7e					ld a, (hl) 
88e9 23					inc hl 
88ea 66					ld h,(hl) 
88eb 6f					ld l, a 
88ec			 
88ec cd e4 8a				call ishlzero 
88ef 28 1a				jr z, .mdone 
88f1			 
88f1 eb					ex de, hl 
88f2 3a e5 ec				ld a, (store_tmp3) 
88f5 cd a1 88				call str_at_display 
88f8					 
88f8			 
88f8					; next item 
88f8 3a e8 ec				ld a, (store_tmp2+1) 
88fb 3c					inc a 
88fc 32 e8 ec				ld (store_tmp2+1), a   ; display item count 
88ff			 
88ff			 		; next row 
88ff			 
88ff 3a e5 ec				ld a, (store_tmp3) 
8902 c6 14				add display_cols 
8904 32 e5 ec				ld (store_tmp3), a 
8907			 
8907					; at end of screen? 
8907			 
8907 fe 10				cp display_rows*4 
8909 20 d1				jr nz, .mitem 
890b			 
890b			 
890b			.mdone: 
890b cd e4 8a				call ishlzero 
890e 28 08				jr z, .nodn 
8910			 
8910 3e 3c				ld a, display_row_4 
8912 11 91 89				ld de, .mdown 
8915 cd a1 88				call str_at_display 
8918			 
8918					; draw options to fill the screens with active item on line 1 
8918					; if current option is 2 or more then display ^ in top 
8918			 
8918 3a e7 ec		.nodn:		ld a, (store_tmp2) 
891b fe 00				cp 0 
891d 28 08				jr z, .noup 
891f			 
891f 3e 00				ld a, 0 
8921 11 8f 89				ld de, .mup 
8924 cd a1 88				call str_at_display 
8927			 
8927 3e 02		.noup:		ld a, 2 
8929 11 8d 89				ld de, .msel 
892c cd a1 88				call str_at_display 
892f			 
892f					; if current option + 1 is not null then display V in bottom 
892f					; get key 
892f cd b1 88				call update_display 
8932			 
8932			 
8932					; handle key 
8932			 
8932 cd 6f d7				call cin_wait 
8935			 
8935 fe 05				cp KEY_UP 
8937 28 2b				jr z, .mgoup 
8939 fe 61				cp 'a' 
893b 28 27				jr z, .mgoup 
893d fe 0a				cp KEY_DOWN 
893f 28 32				jr z, .mgod 
8941 fe 7a				cp 'z' 
8943 28 2e				jr z, .mgod 
8945 fe 20				cp ' ' 
8947 28 34				jr z, .goend 
8949 fe 0c				cp KEY_RIGHT 
894b 28 30				jr z, .goend 
894d fe 0d				cp KEY_CR 
894f 28 2c				jr z, .goend 
8951 fe 71				cp 'q' 
8953 28 0b				jr z, .goback 
8955			 
8955 fe 0b				cp KEY_LEFT 
8957 28 07				jr z, .goback 
8959 fe 08				cp KEY_BS 
895b 28 03				jr z, .goback 
895d c3 cb 88				jp .mloop 
8960			 
8960			.goback: 
8960 3e 00			ld a, 0 
8962 18 1d			jr .goend2 
8964			 
8964				; move up one 
8964			.mgoup: 
8964 3a e7 ec				ld a, (store_tmp2) 
8967 fe 00				cp 0 
8969 ca cb 88				jp z, .mloop 
896c 3d					dec a 
896d 32 e7 ec				ld (store_tmp2), a 
8970 c3 cb 88				jp .mloop 
8973			 
8973				; move down one 
8973			.mgod: 
8973 3a e7 ec				ld a, (store_tmp2) 
8976 3c					inc a 
8977 32 e7 ec				ld (store_tmp2), a 
897a c3 cb 88				jp .mloop 
897d			 
897d			 
897d			.goend: 
897d					; get selected item number 
897d			 
897d 3a e7 ec				ld a, (store_tmp2) 
8980 3c					inc a 
8981			 
8981			.goend2: 
8981 f5					push af 
8982			 
8982					; restore active fb 
8982					; TODO BUG assumes fb1 
8982			 
8982 21 05 ee				ld hl, display_fb1 
8985 22 61 ed				ld (display_fb_active), hl 
8988			 
8988					; restore main regs 
8988			 
8988			 
8988 cd b1 88				call update_display 
898b			 
898b f1					pop af 
898c			 
898c c9				ret 
898d			 
898d .. 00		.msel:   db ">",0 
898f .. 00		.mup:   db "^",0 
8991 .. 00		.mdown:   db "v",0 
8993			 
8993			 
8993			; eof 
8993			 
# End of file firmware_display.asm
8993			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8993			; random number generators 
8993			 
8993			 
8993			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8993			 
8993			 
8993			;-----> Generate a random number 
8993			; output a=answer 0<=a<=255 
8993			; all registers are preserved except: af 
8993			random: 
8993 e5			        push    hl 
8994 d5			        push    de 
8995 2a 43 ed		        ld      hl,(randData) 
8998 ed 5f		        ld      a,r 
899a 57			        ld      d,a 
899b 5e			        ld      e,(hl) 
899c 19			        add     hl,de 
899d 85			        add     a,l 
899e ac			        xor     h 
899f 22 43 ed		        ld      (randData),hl 
89a2 d1			        pop     de 
89a3 e1			        pop     hl 
89a4 c9			        ret 
89a5			 
89a5			 
89a5			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
89a5			 
89a5			 
89a5			 
89a5			;------LFSR------ 
89a5			;James Montelongo 
89a5			;optimized by Spencer Putt 
89a5			;out: 
89a5			; a = 8 bit random number 
89a5			RandLFSR: 
89a5 21 49 ed		        ld hl,LFSRSeed+4 
89a8 5e			        ld e,(hl) 
89a9 23			        inc hl 
89aa 56			        ld d,(hl) 
89ab 23			        inc hl 
89ac 4e			        ld c,(hl) 
89ad 23			        inc hl 
89ae 7e			        ld a,(hl) 
89af 47			        ld b,a 
89b0 cb 13		        rl e  
89b2 cb 12			rl d 
89b4 cb 11		        rl c  
89b6 17				rla 
89b7 cb 13		        rl e  
89b9 cb 12			rl d 
89bb cb 11		        rl c  
89bd 17				rla 
89be cb 13		        rl e  
89c0 cb 12			rl d 
89c2 cb 11		        rl c  
89c4 17				rla 
89c5 67			        ld h,a 
89c6 cb 13		        rl e  
89c8 cb 12			rl d 
89ca cb 11		        rl c  
89cc 17				rla 
89cd a8			        xor b 
89ce cb 13		        rl e  
89d0 cb 12			rl d 
89d2 ac			        xor h 
89d3 a9			        xor c 
89d4 aa			        xor d 
89d5 21 4b ed		        ld hl,LFSRSeed+6 
89d8 11 4c ed		        ld de,LFSRSeed+7 
89db 01 07 00		        ld bc,7 
89de ed b8		        lddr 
89e0 12			        ld (de),a 
89e1 c9			        ret 
89e2			 
89e2			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
89e2			 
89e2			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
89e2			 
89e2			 
89e2			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
89e2			 
89e2			prng16: 
89e2			;Inputs: 
89e2			;   (seed1) contains a 16-bit seed value 
89e2			;   (seed2) contains a NON-ZERO 16-bit seed value 
89e2			;Outputs: 
89e2			;   HL is the result 
89e2			;   BC is the result of the LCG, so not that great of quality 
89e2			;   DE is preserved 
89e2			;Destroys: 
89e2			;   AF 
89e2			;cycle: 4,294,901,760 (almost 4.3 billion) 
89e2			;160cc 
89e2			;26 bytes 
89e2 2a 3d ed		    ld hl,(seed1) 
89e5 44			    ld b,h 
89e6 4d			    ld c,l 
89e7 29			    add hl,hl 
89e8 29			    add hl,hl 
89e9 2c			    inc l 
89ea 09			    add hl,bc 
89eb 22 3d ed		    ld (seed1),hl 
89ee 2a 3b ed		    ld hl,(seed2) 
89f1 29			    add hl,hl 
89f2 9f			    sbc a,a 
89f3 e6 2d		    and %00101101 
89f5 ad			    xor l 
89f6 6f			    ld l,a 
89f7 22 3b ed		    ld (seed2),hl 
89fa 09			    add hl,bc 
89fb c9			    ret 
89fc			 
89fc			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
89fc			 
89fc			rand32: 
89fc			;Inputs: 
89fc			;   (seed1_0) holds the lower 16 bits of the first seed 
89fc			;   (seed1_1) holds the upper 16 bits of the first seed 
89fc			;   (seed2_0) holds the lower 16 bits of the second seed 
89fc			;   (seed2_1) holds the upper 16 bits of the second seed 
89fc			;   **NOTE: seed2 must be non-zero 
89fc			;Outputs: 
89fc			;   HL is the result 
89fc			;   BC,DE can be used as lower quality values, but are not independent of HL. 
89fc			;Destroys: 
89fc			;   AF 
89fc			;Tested and passes all CAcert tests 
89fc			;Uses a very simple 32-bit LCG and 32-bit LFSR 
89fc			;it has a period of 18,446,744,069,414,584,320 
89fc			;roughly 18.4 quintillion. 
89fc			;LFSR taps: 0,2,6,7  = 11000101 
89fc			;291cc 
89fc			;seed1_0=$+1 
89fc			;    ld hl,12345 
89fc			;seed1_1=$+1 
89fc			;    ld de,6789 
89fc			;    ld b,h 
89fc			;    ld c,l 
89fc			;    add hl,hl \ rl e \ rl d 
89fc			;    add hl,hl \ rl e \ rl d 
89fc			;    inc l 
89fc			;    add hl,bc 
89fc			;    ld (seed1_0),hl 
89fc			;    ld hl,(seed1_1) 
89fc			;    adc hl,de 
89fc			;    ld (seed1_1),hl 
89fc			;    ex de,hl 
89fc			;seed2_0=$+1 
89fc			;    ld hl,9876 
89fc			;seed2_1=$+1 
89fc			;    ld bc,54321 
89fc			;    add hl,hl \ rl c \ rl b 
89fc			;    ld (seed2_1),bc 
89fc			;    sbc a,a 
89fc			;    and %11000101 
89fc			;    xor l 
89fc			;    ld l,a 
89fc			;    ld (seed2_0),hl 
89fc			;    ex de,hl 
89fc			;    add hl,bc 
89fc			;    ret 
89fc			; 
89fc			 
89fc			; 16-bit xorshift pseudorandom number generator by John Metcalf 
89fc			; 20 bytes, 86 cycles (excluding ret) 
89fc			 
89fc			; returns   hl = pseudorandom number 
89fc			; corrupts   a 
89fc			 
89fc			; generates 16-bit pseudorandom numbers with a period of 65535 
89fc			; using the xorshift method: 
89fc			 
89fc			; hl ^= hl << 7 
89fc			; hl ^= hl >> 9 
89fc			; hl ^= hl << 8 
89fc			 
89fc			; some alternative shift triplets which also perform well are: 
89fc			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
89fc			 
89fc			;  org 32768 
89fc			 
89fc			xrnd: 
89fc 2a 41 ed		  ld hl,(xrandc)       ; seed must not be 0 
89ff 3e 00		  ld a,0 
8a01 bd			  cp l 
8a02 20 02		  jr nz, .xrnd1 
8a04 2e 01		  ld l, 1 
8a06			.xrnd1: 
8a06			 
8a06 7c			  ld a,h 
8a07 1f			  rra 
8a08 7d			  ld a,l 
8a09 1f			  rra 
8a0a ac			  xor h 
8a0b 67			  ld h,a 
8a0c 7d			  ld a,l 
8a0d 1f			  rra 
8a0e 7c			  ld a,h 
8a0f 1f			  rra 
8a10 ad			  xor l 
8a11 6f			  ld l,a 
8a12 ac			  xor h 
8a13 67			  ld h,a 
8a14			 
8a14 22 41 ed		  ld (xrandc),hl 
8a17			 
8a17 c9			  ret 
8a18			;  
8a18			 
8a18			 
8a18			;;;; int maths 
8a18			 
8a18			; https://map.grauw.nl/articles/mult_div_shifts.php 
8a18			; Divide 16-bit values (with 16-bit result) 
8a18			; In: Divide BC by divider DE 
8a18			; Out: BC = result, HL = rest 
8a18			; 
8a18			Div16: 
8a18 21 00 00		    ld hl,0 
8a1b 78			    ld a,b 
8a1c 06 08		    ld b,8 
8a1e			Div16_Loop1: 
8a1e 17			    rla 
8a1f ed 6a		    adc hl,hl 
8a21 ed 52		    sbc hl,de 
8a23 30 01		    jr nc,Div16_NoAdd1 
8a25 19			    add hl,de 
8a26			Div16_NoAdd1: 
8a26 10 f6		    djnz Div16_Loop1 
8a28 17			    rla 
8a29 2f			    cpl 
8a2a 47			    ld b,a 
8a2b 79			    ld a,c 
8a2c 48			    ld c,b 
8a2d 06 08		    ld b,8 
8a2f			Div16_Loop2: 
8a2f 17			    rla 
8a30 ed 6a		    adc hl,hl 
8a32 ed 52		    sbc hl,de 
8a34 30 01		    jr nc,Div16_NoAdd2 
8a36 19			    add hl,de 
8a37			Div16_NoAdd2: 
8a37 10 f6		    djnz Div16_Loop2 
8a39 17			    rla 
8a3a 2f			    cpl 
8a3b 41			    ld b,c 
8a3c 4f			    ld c,a 
8a3d c9			ret 
8a3e			 
8a3e			 
8a3e			;http://z80-heaven.wikidot.com/math 
8a3e			; 
8a3e			;Inputs: 
8a3e			;     DE and A are factors 
8a3e			;Outputs: 
8a3e			;     A is not changed 
8a3e			;     B is 0 
8a3e			;     C is not changed 
8a3e			;     DE is not changed 
8a3e			;     HL is the product 
8a3e			;Time: 
8a3e			;     342+6x 
8a3e			; 
8a3e			Mult16: 
8a3e			 
8a3e 06 08		     ld b,8          ;7           7 
8a40 21 00 00		     ld hl,0         ;10         10 
8a43 29			       add hl,hl     ;11*8       88 
8a44 07			       rlca          ;4*8        32 
8a45 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8a47 19			         add hl,de   ;--         -- 
8a48 10 f9		       djnz $-5      ;13*7+8     99 
8a4a c9			ret 
8a4b			 
8a4b			; 
8a4b			; Square root of 16-bit value 
8a4b			; In:  HL = value 
8a4b			; Out:  D = result (rounded down) 
8a4b			; 
8a4b			;Sqr16: 
8a4b			;    ld de,#0040 
8a4b			;    ld a,l 
8a4b			;    ld l,h 
8a4b			;    ld h,d 
8a4b			;    or a 
8a4b			;    ld b,8 
8a4b			;Sqr16_Loop: 
8a4b			;    sbc hl,de 
8a4b			;    jr nc,Sqr16_Skip 
8a4b			;    add hl,de 
8a4b			;Sqr16_Skip: 
8a4b			;    ccf 
8a4b			;    rl d 
8a4b			;    add a,a 
8a4b			;    adc hl,hl 
8a4b			;    add a,a 
8a4b			;    adc hl,hl 
8a4b			;    djnz Sqr16_Loop 
8a4b			;    ret 
8a4b			; 
8a4b			; 
8a4b			; Divide 8-bit values 
8a4b			; In: Divide E by divider C 
8a4b			; Out: A = result, B = rest 
8a4b			; 
8a4b			Div8: 
8a4b af			    xor a 
8a4c 06 08		    ld b,8 
8a4e			Div8_Loop: 
8a4e cb 13		    rl e 
8a50 17			    rla 
8a51 91			    sub c 
8a52 30 01		    jr nc,Div8_NoAdd 
8a54 81			    add a,c 
8a55			Div8_NoAdd: 
8a55 10 f7		    djnz Div8_Loop 
8a57 47			    ld b,a 
8a58 7b			    ld a,e 
8a59 17			    rla 
8a5a 2f			    cpl 
8a5b c9			    ret 
8a5c			 
8a5c			; 
8a5c			; Multiply 8-bit value with a 16-bit value (unrolled) 
8a5c			; In: Multiply A with DE 
8a5c			; Out: HL = result 
8a5c			; 
8a5c			Mult12U: 
8a5c 2e 00		    ld l,0 
8a5e 87			    add a,a 
8a5f 30 01		    jr nc,Mult12U_NoAdd0 
8a61 19			    add hl,de 
8a62			Mult12U_NoAdd0: 
8a62 29			    add hl,hl 
8a63 87			    add a,a 
8a64 30 01		    jr nc,Mult12U_NoAdd1 
8a66 19			    add hl,de 
8a67			Mult12U_NoAdd1: 
8a67 29			    add hl,hl 
8a68 87			    add a,a 
8a69 30 01		    jr nc,Mult12U_NoAdd2 
8a6b 19			    add hl,de 
8a6c			Mult12U_NoAdd2: 
8a6c 29			    add hl,hl 
8a6d 87			    add a,a 
8a6e 30 01		    jr nc,Mult12U_NoAdd3 
8a70 19			    add hl,de 
8a71			Mult12U_NoAdd3: 
8a71 29			    add hl,hl 
8a72 87			    add a,a 
8a73 30 01		    jr nc,Mult12U_NoAdd4 
8a75 19			    add hl,de 
8a76			Mult12U_NoAdd4: 
8a76 29			    add hl,hl 
8a77 87			    add a,a 
8a78 30 01		    jr nc,Mult12U_NoAdd5 
8a7a 19			    add hl,de 
8a7b			Mult12U_NoAdd5: 
8a7b 29			    add hl,hl 
8a7c 87			    add a,a 
8a7d 30 01		    jr nc,Mult12U_NoAdd6 
8a7f 19			    add hl,de 
8a80			Mult12U_NoAdd6: 
8a80 29			    add hl,hl 
8a81 87			    add a,a 
8a82 d0			    ret nc 
8a83 19			    add hl,de 
8a84 c9			    ret 
8a85			 
8a85			; 
8a85			; Multiply 8-bit value with a 16-bit value (right rotating) 
8a85			; In: Multiply A with DE 
8a85			;      Put lowest value in A for most efficient calculation 
8a85			; Out: HL = result 
8a85			; 
8a85			Mult12R: 
8a85 21 00 00		    ld hl,0 
8a88			Mult12R_Loop: 
8a88 cb 3f		    srl a 
8a8a 30 01		    jr nc,Mult12R_NoAdd 
8a8c 19			    add hl,de 
8a8d			Mult12R_NoAdd: 
8a8d cb 23		    sla e 
8a8f cb 12		    rl d 
8a91 b7			    or a 
8a92 c2 88 8a		    jp nz,Mult12R_Loop 
8a95 c9			    ret 
8a96			 
8a96			; 
8a96			; Multiply 16-bit values (with 32-bit result) 
8a96			; In: Multiply BC with DE 
8a96			; Out: BCHL = result 
8a96			; 
8a96			Mult32: 
8a96 79			    ld a,c 
8a97 48			    ld c,b 
8a98 21 00 00		    ld hl,0 
8a9b 06 10		    ld b,16 
8a9d			Mult32_Loop: 
8a9d 29			    add hl,hl 
8a9e 17			    rla 
8a9f cb 11		    rl c 
8aa1 30 07		    jr nc,Mult32_NoAdd 
8aa3 19			    add hl,de 
8aa4 ce 00		    adc a,0 
8aa6 d2 aa 8a		    jp nc,Mult32_NoAdd 
8aa9 0c			    inc c 
8aaa			Mult32_NoAdd: 
8aaa 10 f1		    djnz Mult32_Loop 
8aac 41			    ld b,c 
8aad 4f			    ld c,a 
8aae c9			    ret 
8aaf			 
8aaf			 
8aaf			 
8aaf			; 
8aaf			; Multiply 8-bit values 
8aaf			; In:  Multiply H with E 
8aaf			; Out: HL = result 
8aaf			; 
8aaf			Mult8: 
8aaf 16 00		    ld d,0 
8ab1 6a			    ld l,d 
8ab2 06 08		    ld b,8 
8ab4			Mult8_Loop: 
8ab4 29			    add hl,hl 
8ab5 30 01		    jr nc,Mult8_NoAdd 
8ab7 19			    add hl,de 
8ab8			Mult8_NoAdd: 
8ab8 10 fa		    djnz Mult8_Loop 
8aba c9			    ret 
8abb			 
8abb			 
8abb			 
8abb			 
8abb			 
8abb			 
8abb			 
8abb			 
8abb			;;http://z80-heaven.wikidot.com/math 
8abb			;;This divides DE by BC, storing the result in DE, remainder in HL 
8abb			; 
8abb			;DE_Div_BC:          ;1281-2x, x is at most 16 
8abb			;     ld a,16        ;7 
8abb			;     ld hl,0        ;10 
8abb			;     jp $+5         ;10 
8abb			;.DivLoop: 
8abb			;       add hl,bc    ;-- 
8abb			;       dec a        ;64 
8abb			;       jr z,.DivLoopEnd        ;86 
8abb			; 
8abb			;       sla e        ;128 
8abb			;       rl d         ;128 
8abb			;       adc hl,hl    ;240 
8abb			;       sbc hl,bc    ;240 
8abb			;       jr nc,.DivLoop ;23|21 
8abb			;       inc e        ;-- 
8abb			;       jp .DivLoop+1 
8abb			; 
8abb			;.DivLoopEnd: 
8abb			 
8abb			;HL_Div_C: 
8abb			;Inputs: 
8abb			;     HL is the numerator 
8abb			;     C is the denominator 
8abb			;Outputs: 
8abb			;     A is the remainder 
8abb			;     B is 0 
8abb			;     C is not changed 
8abb			;     DE is not changed 
8abb			;     HL is the quotient 
8abb			; 
8abb			;       ld b,16 
8abb			;       xor a 
8abb			;         add hl,hl 
8abb			;         rla 
8abb			;         cp c 
8abb			;         jr c,$+4 
8abb			;           inc l 
8abb			;           sub c 
8abb			;         djnz $-7 
8abb			 
8abb			; https://plutiedev.com/z80-add-8bit-to-16bit 
8abb			 
8abb			addatohl: 
8abb 85			    add   a, l    ; A = A+L 
8abc 6f			    ld    l, a    ; L = A+L 
8abd 8c			    adc   a, h    ; A = A+L+H+carry 
8abe 95			    sub   l       ; A = H+carry 
8abf 67			    ld    h, a    ; H = H+carry 
8ac0 c9			ret 
8ac1			 
8ac1			addatode: 
8ac1 83			    add   a, e    ; A = A+L 
8ac2 5f			    ld    e, a    ; L = A+L 
8ac3 8a			    adc   a, d    ; A = A+L+H+carry 
8ac4 93			    sub   e       ; A = H+carry 
8ac5 57			    ld    d, a    ; H = H+carry 
8ac6 c9			ret 
8ac7			 
8ac7			 
8ac7			addatobc: 
8ac7 81			    add   a, c    ; A = A+L 
8ac8 4f			    ld    c, a    ; L = A+L 
8ac9 88			    adc   a, b    ; A = A+L+H+carry 
8aca 91			    sub   c       ; A = H+carry 
8acb 47			    ld    b, a    ; H = H+carry 
8acc c9			ret 
8acd			 
8acd			subafromhl: 
8acd			   ; If A=0 do nothing 
8acd			    ; Otherwise flip A's sign. Since 
8acd			    ; the upper byte becomes -1, also 
8acd			    ; substract 1 from H. 
8acd ed 44		    neg 
8acf ca d8 8a		    jp    z, Skip 
8ad2 25			    dec   h 
8ad3			     
8ad3			    ; Now add the low byte as usual 
8ad3			    ; Two's complement takes care of 
8ad3			    ; ensuring the result is correct 
8ad3 85			    add   a, l 
8ad4 6f			    ld    l, a 
8ad5 8c			    adc   a, h 
8ad6 95			    sub   l 
8ad7 67			    ld    h, a 
8ad8			Skip: 
8ad8 c9				ret 
8ad9			 
8ad9			 
8ad9			; compare hl and de 
8ad9			; returns:  
8ad9			; if hl = de, z=1, s=0, c0=0 
8ad9			; if hl > de, z=0, s=0, c=0 
8ad9			; if hl < de, z=0, s=1, c=1 
8ad9			cmp16:	 
8ad9 b7				or a 
8ada ed 52			sbc hl,de 
8adc e0				ret po 
8add 7c				ld a,h 
8ade 1f				rra 
8adf ee 40			xor 01000000B 
8ae1 37				scf 
8ae2 8f				adc a,a 
8ae3 c9				ret 
8ae4			 
8ae4			 
8ae4			; test if hl contains zero   - A is destroyed 
8ae4			 
8ae4			ishlzero:    
8ae4 b7				or a     ; reset flags 
8ae5 7c				ld a, h 
8ae6 b5				or l        	 
8ae7			 
8ae7 c9				ret 
8ae8			 
8ae8			 
8ae8			 
8ae8			 
8ae8			if FORTH_ENABLE_FLOATMATH 
8ae8			;include "float/bbcmath.z80" 
8ae8			include "float/lpfpcalc.asm" 
8ae8			endif 
8ae8			 
8ae8			 
8ae8			; eof 
8ae8			 
# End of file firmware_maths.asm
8ae8			include "firmware_strings.asm"   ; string handling  
8ae8			 
8ae8			 
8ae8			; TODO string len 
8ae8			; input text string, end on cr with zero term 
8ae8			; a offset into frame buffer to start prompt 
8ae8			; d is max length 
8ae8			; e is display size TODO 
8ae8			; c is current cursor position 
8ae8			; hl is ptr to where string will be stored 
8ae8			 
8ae8			 
8ae8			; TODO check limit of buffer for new inserts 
8ae8			; TODO check insert does not push beyond buffer 
8ae8			; TODO scroll in a limited display area 
8ae8			; TODO scroll whole screen on page wrap 
8ae8			 
8ae8			 
8ae8			; TODO handle KEY_PREVWORD 
8ae8			; TODO handle KEY_NEXTWORD 
8ae8			; TODO handle KEY_HOME 
8ae8			; TODO handle KEY_END 
8ae8			; TODO use LCD cursor? 
8ae8			 
8ae8 32 b9 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8aeb 81					add c 
8aec 32 b7 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8aef 22 bc ee				ld (input_start), hl     ; save ptr to buffer 
8af2 79					ld a, c 
8af3 cd bb 8a				call addatohl 
8af6 22 be ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8af9 7a					ld a,d 
8afa 32 bb ee			        ld (input_size), a       ; save length of input area 
8afd 79					ld a, c 
8afe 32 aa ee				ld (input_cursor),a      ; init cursor start position  
8b01 7b					ld a,e 
8b02 32 ba ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8b05					 
8b05					 
8b05			 
8b05			;		ld a,(input_ptr) 
8b05			;		ld (input_under_cursor),a 	; save what is under the cursor 
8b05			 
8b05			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8b05					; init cursor shape if not set by the cin routines 
8b05 21 59 ed				ld hl, cursor_shape 
8b08 3e ff				ld a, 255 
8b0a 77					ld (hl), a 
8b0b 23					inc hl 
8b0c 3e 00				ld a, 0 
8b0e 77					ld (hl), a 
8b0f			 
8b0f 3e 0f				ld a, CUR_BLINK_RATE 
8b11 32 b5 ee				ld (input_cur_flash), a 
8b14 3e 01				ld a, 1 
8b16 32 b4 ee				ld (input_cur_onoff),a 
8b19			 
8b19			;	if DEBUG_INPUT 
8b19			;		push af 
8b19			;		ld a, 'I' 
8b19			;		ld (debug_mark),a 
8b19			;		pop af 
8b19			;		CALLMONITOR 
8b19			;	endif 
8b19			.is1:		; main entry loop 
8b19			 
8b19			 
8b19			 
8b19					; pause 1ms 
8b19			 
8b19 3e 01				ld a, 1 
8b1b cd f3 87				call aDelayInMS 
8b1e			 
8b1e					; dec flash counter 
8b1e 3a b5 ee				ld a, (input_cur_flash) 
8b21 3d					dec a 
8b22 32 b5 ee				ld (input_cur_flash), a 
8b25 fe 00				cp 0 
8b27 20 0d				jr nz, .nochgstate 
8b29			 
8b29			 
8b29					; change state 
8b29 3a b4 ee				ld a,(input_cur_onoff) 
8b2c ed 44				neg 
8b2e 32 b4 ee				ld (input_cur_onoff),a 
8b31			 
8b31			 
8b31					; reset on change of state 
8b31 3e 0f				ld a, CUR_BLINK_RATE 
8b33 32 b5 ee				ld (input_cur_flash), a 
8b36			 
8b36			.nochgstate: 
8b36					 
8b36					 
8b36			 
8b36					; display cursor  
8b36			 
8b36			;		ld hl, (input_start) 
8b36			;		ld a, (input_cursor) 
8b36			;		call addatohl 
8b36			 
8b36					; get char under cursor and replace with cursor 
8b36 2a be ee		ld hl, (input_ptr) 
8b39			;		ld a, (hl) 
8b39			;		ld (input_under_cursor),a 
8b39			;		ld a, '_' 
8b39			;		ld (hl), a 
8b39			 
8b39					; display string 
8b39			 
8b39 ed 5b bc ee			ld de, (input_start) 
8b3d 3a b9 ee				ld a, (input_at_pos) 
8b40 cd a1 88				call str_at_display 
8b43			;	        call update_display 
8b43			 
8b43					; find place to put the cursor 
8b43			;		add h 
8b43			;		ld l, display_row_1 
8b43			;		sub l 
8b43			; (input_at_pos) 
8b43					;ld c, a 
8b43			;		ld a, (input_cursor) 
8b43			;		ld l, (input_at_pos) 
8b43			;		;ld b, h 
8b43			;		add l 
8b43			;		ld (input_at_cursor),a 
8b43					;ld l,h 
8b43			 
8b43			;		ld h, 0 
8b43			;		ld l,(input_at_pos) 
8b43			;		ld a, (input_cursor) 
8b43			;		call addatohl 
8b43			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8b43			;		call subafromhl 
8b43			;		ld a,l 
8b43			;		ld (input_at_cursor), a 
8b43			 
8b43				if DEBUG_INPUT 
8b43					ld a, (hardware_diag) 
8b43					cp 0 
8b43					jr z, .skip_input_diag 
8b43			 
8b43					ld a,(input_at_pos) 
8b43					ld hl, LFSRSeed 
8b43					call hexout 
8b43					ld a, (input_cursor) 
8b43					ld hl, LFSRSeed+2 
8b43					call hexout 
8b43					ld a,(input_at_cursor) 
8b43					ld hl, LFSRSeed+4 
8b43					call hexout 
8b43			 
8b43					ld a,(input_cur_onoff) 
8b43					ld hl, LFSRSeed+6 
8b43					call hexout 
8b43			 
8b43					ld a,(input_cur_flash) 
8b43					ld hl, LFSRSeed+8 
8b43					call hexout 
8b43			 
8b43					ld a,(input_len) 
8b43					ld hl, LFSRSeed+10 
8b43					call hexout 
8b43					ld hl, LFSRSeed+12 
8b43					ld a, 0 
8b43					ld (hl),a 
8b43					ld a, display_row_4 
8b43					ld de, LFSRSeed 
8b43					call str_at_display 
8b43					.skip_input_diag: 
8b43				endif 
8b43			 
8b43					; decide on if we are showing the cursor this time round 
8b43			 
8b43 3a b4 ee				ld a, (input_cur_onoff) 
8b46 fe ff				cp 255 
8b48 28 13				jr z, .skipcur 
8b4a			 
8b4a			 
8b4a 3a b7 ee				ld a,(input_at_cursor) 
8b4d 11 59 ed				ld de, cursor_shape 
8b50 cd a1 88				call str_at_display 
8b53			 
8b53					; save length of current input string 
8b53 2a bc ee				ld hl, (input_start) 
8b56 cd 19 8f				call strlenz 
8b59 7d					ld a,l 
8b5a 32 af ee				ld (input_len),a 
8b5d			 
8b5d			.skipcur: 
8b5d			 
8b5d cd b1 88			        call update_display 
8b60					 
8b60			 
8b60			 
8b60					; wait 
8b60				 
8b60					; TODO loop without wait to flash the cursor and char under cursor	 
8b60 cd 75 d7				call cin    ; _wait 
8b63			 
8b63 fe 00				cp 0 
8b65 ca 19 8b				jp z, .is1 
8b68			 
8b68					; get ptr to char to input into 
8b68			 
8b68 4f					ld c,a 
8b69 2a bc ee				ld hl, (input_start) 
8b6c 3a aa ee				ld a, (input_cursor) 
8b6f cd bb 8a				call addatohl 
8b72 22 be ee				ld (input_ptr), hl 
8b75 79					ld a,c 
8b76			 
8b76					; replace char under cursor 
8b76			 
8b76			;		ld hl, (input_ptr) 
8b76			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8b76			;		ld (hl), a 
8b76			 
8b76			;	if DEBUG_INPUT 
8b76			;		push af 
8b76			;		ld a, 'i' 
8b76			;		ld (debug_mark),a 
8b76			;		pop af 
8b76			;		CALLMONITOR 
8b76			;	endif 
8b76 fe 0e				cp KEY_HOME 
8b78 20 0e				jr nz, .iske 
8b7a			 
8b7a 3a b9 ee				ld a, (input_at_pos) 
8b7d 32 b7 ee				ld (input_at_cursor),a 
8b80 3e 00				ld a, 0 
8b82 32 aa ee				ld (input_cursor), a 
8b85 c3 19 8b				jp .is1 
8b88					 
8b88 fe 0f		.iske:		cp KEY_END 
8b8a 20 03				jr nz, .isknw 
8b8c c3 19 8b				jp .is1 
8b8f			 
8b8f fe 06		.isknw:		cp KEY_NEXTWORD 
8b91 20 1b				jr nz, .iskpw 
8b93			 
8b93 2a be ee		.isknwm:	ld hl, (input_ptr) 
8b96 7e					ld a,(hl)	 
8b97 fe 00				cp 0 
8b99 ca 19 8b				jp z, .is1    ; end of string 
8b9c fe 20				cp ' ' 
8b9e ca 19 8b				jp z, .is1    ; end of word 
8ba1 23					inc hl 
8ba2 22 be ee				ld (input_ptr), hl 
8ba5 3a b7 ee				ld a, (input_at_cursor) 
8ba8 3c					inc a 
8ba9 32 b7 ee				ld (input_at_cursor), a 
8bac 18 e5				jr .isknwm 
8bae			 
8bae fe 07		.iskpw:		cp KEY_PREVWORD 
8bb0 20 1b				jr nz, .iskl 
8bb2			.iskpwm:	 
8bb2 2a be ee				ld hl, (input_ptr) 
8bb5 7e					ld a,(hl)	 
8bb6 fe 00				cp 0  
8bb8 ca 19 8b				jp z, .is1    ; end of string 
8bbb fe 20				cp ' ' 
8bbd ca 19 8b				jp z, .is1    ; end of word 
8bc0 2b					dec hl 
8bc1 22 be ee				ld (input_ptr), hl 
8bc4 3a b7 ee				ld a, (input_at_cursor) 
8bc7 3d					dec a 
8bc8 32 b7 ee				ld (input_at_cursor), a 
8bcb 18 e5				jr .iskpwm 
8bcd			 
8bcd			 
8bcd fe 0b		.iskl:		cp KEY_LEFT 
8bcf 20 27				jr nz, .isk1 
8bd1			 
8bd1 3a aa ee				ld a, (input_cursor) 
8bd4			 
8bd4 fe 00				cp 0 
8bd6 ca 19 8b				jp z, .is1 		; at start of line to ignore  
8bd9			 
8bd9 3d					dec  a 		; TODO check underflow 
8bda 32 aa ee				ld (input_cursor), a 
8bdd			 
8bdd 2a be ee				ld hl, (input_ptr) 
8be0 2b					dec hl 
8be1 22 be ee				ld (input_ptr), hl 
8be4					 
8be4 3a b7 ee				ld a, (input_at_cursor) 
8be7 3d					dec a 
8be8 32 b7 ee				ld (input_at_cursor), a 
8beb			 
8beb 3e 01				ld a, 1		; show cursor moving 
8bed 32 b4 ee				ld (input_cur_onoff),a 
8bf0 3e 0f				ld a, CUR_BLINK_RATE 
8bf2 32 b5 ee				ld (input_cur_flash), a 
8bf5			 
8bf5 c3 19 8b				jp .is1 
8bf8			 
8bf8 fe 0c		.isk1:		cp KEY_RIGHT 
8bfa 20 2a				jr nz, .isk2 
8bfc			 
8bfc 3a af ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8bff 5f					ld e,a 
8c00 3a aa ee				ld a, (input_cursor) 
8c03 bb					cp e 
8c04 ca 19 8b				jp z, .is1		; at the end of string so dont go right 
8c07			 
8c07 3c					inc  a 		; TODO check overflow 
8c08 32 aa ee				ld (input_cursor), a 
8c0b			 
8c0b 3a b7 ee				ld a, (input_at_cursor) 
8c0e 3c					inc a 
8c0f 32 b7 ee				ld (input_at_cursor), a 
8c12			 
8c12 2a be ee				ld hl, (input_ptr) 
8c15 23					inc hl 
8c16 22 be ee				ld (input_ptr), hl 
8c19			 
8c19 3e 01				ld a, 1		; show cursor moving 
8c1b 32 b4 ee				ld (input_cur_onoff),a 
8c1e 3e 0f				ld a, CUR_BLINK_RATE 
8c20 32 b5 ee				ld (input_cur_flash), a 
8c23			 
8c23 c3 19 8b				jp .is1 
8c26			 
8c26 fe 05		.isk2:		cp KEY_UP 
8c28			 
8c28 20 26				jr nz, .isk3 
8c2a			 
8c2a					; swap last command with the current on 
8c2a			 
8c2a					; move cursor to start of string 
8c2a 2a bc ee				ld hl, (input_start) 
8c2d 22 be ee				ld (input_ptr), hl 
8c30			 
8c30 3a b9 ee				ld a, (input_at_pos) 
8c33 32 b7 ee				ld (input_at_cursor), a 
8c36			 
8c36 3e 00				ld a, 0 
8c38 32 aa ee				ld (input_cursor), a 
8c3b					 
8c3b					; swap input and last command buffers 
8c3b			 
8c3b 21 0d e8				ld hl, os_cli_cmd 
8c3e 11 0c e9				ld de, os_last_cmd 
8c41 06 ff				ld b, 255 
8c43 7e			.swap1:		ld a, (hl) 
8c44 4f					ld c,a 
8c45 1a					ld a, (de) 
8c46 77					ld (hl), a 
8c47 79					ld a,c 
8c48 12					ld (de),a 
8c49 23					inc hl 
8c4a 13					inc de 
8c4b 10 f6				djnz .swap1 
8c4d			 
8c4d			 
8c4d			 
8c4d			 
8c4d			 
8c4d c3 19 8b				jp .is1 
8c50			 
8c50 fe 08		.isk3:		cp KEY_BS 
8c52 20 3c				jr nz, .isk4 
8c54			 
8c54 3a aa ee				ld a, (input_cursor) 
8c57			 
8c57 fe 00				cp 0 
8c59 ca 19 8b				jp z, .is1 		; at start of line to ignore  
8c5c			 
8c5c 3d					dec  a 		; TODO check underflow 
8c5d 32 aa ee				ld (input_cursor), a 
8c60			 
8c60					; hl is source 
8c60					; de needs to be source - 1 
8c60			 
8c60			;		ld a, 0 
8c60			;		dec hl 
8c60			;		ld (hl), a 
8c60			 
8c60 2a be ee				ld hl, (input_ptr) 
8c63 2b					dec hl 
8c64 22 be ee				ld (input_ptr), hl 
8c67			 
8c67					; shift all data 
8c67			 
8c67 e5					push hl 
8c68 23					inc hl 
8c69 d1					pop de 
8c6a 3a af ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8c6d 4f					ld c,a 
8c6e 06 00				ld b,0 
8c70 ed b0				ldir  
8c72			 
8c72			 
8c72			 
8c72			 
8c72 3a b7 ee				ld a, (input_at_cursor) 
8c75 3d					dec a 
8c76 32 b7 ee				ld (input_at_cursor), a 
8c79			 
8c79			 
8c79 3e 01				ld a, 1		; show cursor moving 
8c7b 32 b4 ee				ld (input_cur_onoff),a 
8c7e 3e 0f				ld a, CUR_BLINK_RATE 
8c80 32 b5 ee				ld (input_cur_flash), a 
8c83			 
8c83					; remove char 
8c83 3a b7 ee				ld a, (input_at_cursor) 
8c86 3c					inc a 
8c87 11 11 8d				ld de,.iblank 
8c8a cd a1 88				call str_at_display 
8c8d			 
8c8d c3 19 8b				jp .is1 
8c90			 
8c90 fe 0d		.isk4:		cp KEY_CR 
8c92 28 6c				jr z, .endinput 
8c94			 
8c94					; else add the key press to the end 
8c94			 
8c94 4f					ld c, a			; save key pressed 
8c95			 
8c95 7e					ld a,(hl)		; get what is currently under char 
8c96			 
8c96 fe 00				cp 0			; we are at the end of the string 
8c98 20 2f				jr nz, .onchar 
8c9a					 
8c9a					; add a char to the end of the string 
8c9a				 
8c9a 71					ld (hl),c 
8c9b 23					inc hl 
8c9c			;		ld a,' ' 
8c9c			;		ld (hl),a 
8c9c			;		inc hl 
8c9c 3e 00				ld a,0 
8c9e 77					ld (hl),a 
8c9f 2b					dec hl 
8ca0			 
8ca0 3a aa ee				ld a, (input_cursor) 
8ca3 3c					inc a				; TODO check max string length and scroll  
8ca4 32 aa ee				ld (input_cursor), a		; inc cursor pos 
8ca7							 
8ca7 3a b7 ee				ld a, (input_at_cursor) 
8caa 3c					inc a 
8cab 32 b7 ee				ld (input_at_cursor), a 
8cae			 
8cae 2a be ee				ld hl, (input_ptr) 
8cb1 23					inc hl 
8cb2 22 be ee				ld (input_ptr), hl 
8cb5			 
8cb5 2a be ee				ld hl, (input_ptr) 
8cb8 23					inc hl 
8cb9 22 be ee				ld (input_ptr), hl 
8cbc			;	if DEBUG_INPUT 
8cbc			;		push af 
8cbc			;		ld a, '+' 
8cbc			;		ld (debug_mark),a 
8cbc			;		pop af 
8cbc			;		CALLMONITOR 
8cbc			;	endif 
8cbc 3e 01				ld a, 1		; show cursor moving 
8cbe 32 b4 ee				ld (input_cur_onoff),a 
8cc1 3e 0f				ld a, CUR_BLINK_RATE 
8cc3 32 b5 ee				ld (input_cur_flash), a 
8cc6 c3 19 8b				jp .is1 
8cc9					 
8cc9			 
8cc9			 
8cc9					; if on a char then insert 
8cc9			.onchar: 
8cc9			 
8cc9					; TODO over flow check: make sure insert does not blow out buffer 
8cc9			 
8cc9					; need to do some maths to use lddr 
8cc9			 
8cc9 e5					push hl   ; save char pos 
8cca c5					push bc 
8ccb			 
8ccb 2a bc ee				ld hl, (input_start) 
8cce 3a af ee				ld a, (input_len) 
8cd1 cd bb 8a				call addatohl  		; end of string 
8cd4 23					inc hl 
8cd5 23					inc hl		; past zero term 
8cd6 e5					push hl 
8cd7 23					inc hl 
8cd8 e5					push hl  
8cd9			 
8cd9								; start and end of lddr set, now how much to move? 
8cd9			 
8cd9							 
8cd9 3a aa ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8cdc 47					ld b,a 
8cdd 3a af ee				ld a,(input_len) 
8ce0 5f					ld e,a 
8ce1 90					sub b 
8ce2 3c					inc a		;?? 
8ce3 3c					inc a		;?? 
8ce4 3c					inc a		;?? 
8ce5			 
8ce5 06 00				ld b,0 
8ce7 4f					ld c,a 
8ce8			 
8ce8				if DEBUG_INPUT 
8ce8					push af 
8ce8					ld a, 'i' 
8ce8					ld (debug_mark),a 
8ce8					pop af 
8ce8			;		CALLMONITOR 
8ce8				endif 
8ce8 d1					pop de 
8ce9 e1					pop hl 
8cea				if DEBUG_INPUT 
8cea					push af 
8cea					ld a, 'I' 
8cea					ld (debug_mark),a 
8cea					pop af 
8cea			;		CALLMONITOR 
8cea				endif 
8cea ed b8				lddr 
8cec				 
8cec			 
8cec			 
8cec					; TODO have a key for insert/overwrite mode???? 
8cec c1					pop bc 
8ced e1					pop hl 
8cee 71					ld (hl), c		; otherwise overwrite current char 
8cef					 
8cef			 
8cef			 
8cef			 
8cef 3a aa ee				ld a, (input_cursor) 
8cf2 3c					inc  a 		; TODO check overflow 
8cf3 32 aa ee				ld (input_cursor), a 
8cf6			 
8cf6 3a b7 ee				ld a, (input_at_cursor) 
8cf9 3c					inc a 
8cfa 32 b7 ee				ld (input_at_cursor), a 
8cfd			 
8cfd c3 19 8b				jp .is1 
8d00			 
8d00			.endinput:	; TODO look for end of string 
8d00			 
8d00					; add trailing space for end of token 
8d00			 
8d00 2a bc ee				ld hl, (input_start) 
8d03 3a af ee				ld a,(input_len) 
8d06 cd bb 8a				call addatohl 
8d09 3e 20				ld a, ' ' 
8d0b 77					ld (hl),a 
8d0c					; TODO eof of parse marker 
8d0c			 
8d0c 23					inc hl 
8d0d 3e 00				ld a, 0 
8d0f 77					ld (hl),a 
8d10			 
8d10			 
8d10 c9					ret 
8d11			 
8d11 .. 00		.iblank: db " ",0 
8d13			 
8d13			 
8d13 32 b9 ee		input_str_prev:	ld (input_at_pos), a 
8d16 22 bc ee				ld (input_start), hl 
8d19 3e 01				ld a,1			; add cursor 
8d1b 77					ld (hl),a 
8d1c 23					inc hl 
8d1d 3e 00				ld a,0 
8d1f 77					ld (hl),a 
8d20 22 be ee				ld (input_ptr), hl 
8d23 7a					ld a,d 
8d24 32 bb ee				ld (input_size), a 
8d27 3e 00				ld a,0 
8d29 32 aa ee				ld (input_cursor),a 
8d2c			.instr1:	 
8d2c			 
8d2c					; TODO do block cursor 
8d2c					; TODO switch cursor depending on the modifer key 
8d2c			 
8d2c					; update cursor shape change on key hold 
8d2c			 
8d2c 2a be ee				ld hl, (input_ptr) 
8d2f 2b					dec hl 
8d30 3a 59 ed				ld a,(cursor_shape) 
8d33 77					ld (hl), a 
8d34			 
8d34					; display entered text 
8d34 3a b9 ee				ld a,(input_at_pos) 
8d37 cd d3 d6		            	CALL fLCD_Pos       ;Position cursor to location in A 
8d3a ed 5b bc ee	            	LD   de, (input_start) 
8d3e cd cd d6		            	CALL fLCD_Str       ;Display string pointed to by DE 
8d41			 
8d41 cd 75 d7				call cin 
8d44 fe 00				cp 0 
8d46 28 e4				jr z, .instr1 
8d48			 
8d48					; proecess keyboard controls first 
8d48			 
8d48 2a be ee				ld hl,(input_ptr) 
8d4b			 
8d4b fe 0d				cp KEY_CR	 ; pressing enter ends input 
8d4d 28 5a				jr z, .instrcr 
8d4f			 
8d4f fe 08				cp KEY_BS 	; back space 
8d51 20 0f				jr nz, .instr2 
8d53					; process back space 
8d53			 
8d53					; TODO stop back space if at start of string 
8d53 2b					dec hl 
8d54 2b					dec hl ; to over write cursor 
8d55 3a 59 ed				ld a,(cursor_shape) 
8d58					;ld a,0 
8d58 77					ld (hl),a 
8d59 23					inc hl 
8d5a 3e 20				ld a," " 
8d5c 77					ld (hl),a 
8d5d 22 be ee				ld (input_ptr),hl 
8d60					 
8d60			 
8d60 18 ca				jr .instr1 
8d62			 
8d62 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8d64 20 06				jr nz, .instr3 
8d66 2b					dec hl 
8d67 22 be ee				ld (input_ptr),hl 
8d6a 18 c0				jr .instr1 
8d6c				 
8d6c fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8d6e 20 06				jr nz, .instr4 
8d70 23					inc hl 
8d71 22 be ee				ld (input_ptr),hl 
8d74 18 b6				jr .instr1 
8d76			 
8d76 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8d78 20 06				jr nz, .instr5 
8d7a 2b					dec hl 
8d7b 22 be ee				ld (input_ptr),hl 
8d7e 18 ac				jr .instr1 
8d80			 
8d80 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8d82 20 06				jr nz, .instr6 
8d84 2b					dec hl 
8d85 22 be ee				ld (input_ptr),hl 
8d88 18 a2				jr .instr1 
8d8a fe 05		.instr6:        cp KEY_UP      ; recall last command 
8d8c 20 0b				jr nz, .instrnew 
8d8e			 
8d8e 21 e6 e4			ld hl, scratch 
8d91 11 0c e9			ld de, os_last_cmd 
8d94 cd b2 8d			call strcpy 
8d97 18 93				jr .instr1 
8d99			 
8d99			 
8d99			.instrnew:	; no special key pressed to see if we have room to store it 
8d99			 
8d99					; TODO do string size test 
8d99			 
8d99 2b					dec hl ; to over write cursor 
8d9a 77					ld (hl),a 
8d9b 23					inc hl 
8d9c 3a 59 ed				ld a,(cursor_shape) 
8d9f 77					ld (hl),a 
8da0 23					inc hl 
8da1 3e 00				ld a,0 
8da3 77					ld (hl),a 
8da4			 
8da4 22 be ee				ld (input_ptr),hl 
8da7					 
8da7 18 83				jr .instr1 
8da9 2b			.instrcr:	dec hl		; remove cursor 
8daa 3e 20				ld a,' '	; TODO add a trailing space for safety 
8dac 77					ld (hl),a 
8dad 23					inc hl 
8dae 3e 00				ld a,0 
8db0 77					ld (hl),a 
8db1			 
8db1			 
8db1					; if at end of line scroll up    
8db1					; TODO detecting only end of line 4 for scroll up  
8db1			 
8db1					;ld   
8db1			 
8db1 c9					ret 
8db2			 
8db2			 
8db2			; strcpy hl = dest, de source 
8db2			 
8db2 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8db3 b7			            OR   A              ;Null terminator? 
8db4 c8			            RET  Z              ;Yes, so finished 
8db5 1a					ld a,(de) 
8db6 77					ld (hl),a 
8db7 13			            INC  DE             ;Point to next character 
8db8 23					inc hl 
8db9 18 f7		            JR   strcpy       ;Repeat 
8dbb c9					ret 
8dbc			 
8dbc			 
8dbc			; TODO string_at  
8dbc			; pass string which starts with lcd offset address and then null term string 
8dbc			 
8dbc			; TODO string to dec 
8dbc			; TODO string to hex 
8dbc			; TODO byte to string hex 
8dbc			; TODO byte to string dec 
8dbc			 
8dbc			 
8dbc			 
8dbc			; from z80uartmonitor 
8dbc			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dbc			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8dbc			; pass hl for where to put the text 
8dbc			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dbc c5			hexout:	PUSH BC 
8dbd f5					PUSH AF 
8dbe 47					LD B, A 
8dbf					; Upper nybble 
8dbf cb 3f				SRL A 
8dc1 cb 3f				SRL A 
8dc3 cb 3f				SRL A 
8dc5 cb 3f				SRL A 
8dc7 cd d7 8d				CALL tohex 
8dca 77					ld (hl),a 
8dcb 23					inc hl	 
8dcc					 
8dcc					; Lower nybble 
8dcc 78					LD A, B 
8dcd e6 0f				AND 0FH 
8dcf cd d7 8d				CALL tohex 
8dd2 77					ld (hl),a 
8dd3 23					inc hl	 
8dd4					 
8dd4 f1					POP AF 
8dd5 c1					POP BC 
8dd6 c9					RET 
8dd7					 
8dd7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dd7			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8dd7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dd7			tohex: 
8dd7 e5					PUSH HL 
8dd8 d5					PUSH DE 
8dd9 16 00				LD D, 0 
8ddb 5f					LD E, A 
8ddc 21 e4 8d				LD HL, .DATA 
8ddf 19					ADD HL, DE 
8de0 7e					LD A, (HL) 
8de1 d1					POP DE 
8de2 e1					POP HL 
8de3 c9					RET 
8de4			 
8de4			.DATA: 
8de4 30					DEFB	30h	; 0 
8de5 31					DEFB	31h	; 1 
8de6 32					DEFB	32h	; 2 
8de7 33					DEFB	33h	; 3 
8de8 34					DEFB	34h	; 4 
8de9 35					DEFB	35h	; 5 
8dea 36					DEFB	36h	; 6 
8deb 37					DEFB	37h	; 7 
8dec 38					DEFB	38h	; 8 
8ded 39					DEFB	39h	; 9 
8dee 41					DEFB	41h	; A 
8def 42					DEFB	42h	; B 
8df0 43					DEFB	43h	; C 
8df1 44					DEFB	44h	; D 
8df2 45					DEFB	45h	; E 
8df3 46					DEFB	46h	; F 
8df4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8df4			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8df4			;;    subtract $30, if result > 9 then subtract $7 more 
8df4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8df4			atohex: 
8df4 d6 30				SUB $30 
8df6 fe 0a				CP 10 
8df8 f8					RET M		; If result negative it was 0-9 so we're done 
8df9 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8dfb c9					RET		 
8dfc			 
8dfc			 
8dfc			 
8dfc			 
8dfc			; Get 2 ASCII characters as hex byte from pointer in hl 
8dfc			 
8dfc			BYTERD: 
8dfc 16 00			LD	D,00h		;Set up 
8dfe cd 06 8e			CALL	HEXCON		;Get byte and convert to hex 
8e01 87				ADD	A,A		;First nibble so 
8e02 87				ADD	A,A		;multiply by 16 
8e03 87				ADD	A,A		; 
8e04 87				ADD	A,A		; 
8e05 57				LD	D,A		;Save hi nibble in D 
8e06			HEXCON: 
8e06 7e				ld a, (hl)		;Get next chr 
8e07 23				inc hl 
8e08 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8e0a fe 0a			CP	00Ah		;Is it 0-9 ? 
8e0c 38 02			JR	C,NALPHA	;If so miss next bit 
8e0e d6 07			SUB	007h		;Else convert alpha 
8e10			NALPHA: 
8e10 b2				OR	D		;Add hi nibble back 
8e11 c9				RET			; 
8e12			 
8e12			 
8e12			; 
8e12			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8e12			; Since the routines get_byte and therefore get_nibble are called, only valid 
8e12			; characters (0-9a-f) are accepted. 
8e12			; 
8e12			;get_word        push    af 
8e12			;                call    get_byte        ; Get the upper byte 
8e12			;                ld      h, a 
8e12			;                call    get_byte        ; Get the lower byte 
8e12			;                ld      l, a 
8e12			;                pop     af 
8e12			;                ret 
8e12			; 
8e12			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8e12			; the routine get_nibble is used only valid characters are accepted - the  
8e12			; input routine only accepts characters 0-9a-f. 
8e12			; 
8e12 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8e13 7e					ld a,(hl) 
8e14 23					inc hl 
8e15 cd 3a 8e		                call    nibble2val      ; Get upper nibble 
8e18 cb 07		                rlc     a 
8e1a cb 07		                rlc     a 
8e1c cb 07		                rlc     a 
8e1e cb 07		                rlc     a 
8e20 47			                ld      b, a            ; Save upper four bits 
8e21 7e					ld a,(hl) 
8e22 cd 3a 8e		                call    nibble2val      ; Get lower nibble 
8e25 b0			                or      b               ; Combine both nibbles 
8e26 c1			                pop     bc              ; Restore B (and C) 
8e27 c9			                ret 
8e28			; 
8e28			; Get a hexadecimal digit from the serial line. This routine blocks until 
8e28			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8e28			; to the serial line interface. The lower 4 bits of A contain the value of  
8e28			; that particular digit. 
8e28			; 
8e28			;get_nibble      ld a,(hl)           ; Read a character 
8e28			;                call    to_upper        ; Convert to upper case 
8e28			;                call    is_hex          ; Was it a hex digit? 
8e28			;                jr      nc, get_nibble  ; No, get another character 
8e28			 ;               call    nibble2val      ; Convert nibble to value 
8e28			 ;               call    print_nibble 
8e28			 ;               ret 
8e28			; 
8e28			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8e28			; A valid hexadecimal digit is denoted by a set C flag. 
8e28			; 
8e28			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8e28			;                ret     nc              ; Yes 
8e28			;                cp      '0'             ; Less than '0'? 
8e28			;                jr      nc, is_hex_1    ; No, continue 
8e28			;                ccf                     ; Complement carry (i.e. clear it) 
8e28			;                ret 
8e28			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8e28			;                ret     c               ; Yes 
8e28			;                cp      'A'             ; Less than 'A'? 
8e28			;                jr      nc, is_hex_2    ; No, continue 
8e28			;                ccf                     ; Yes - clear carry and return 
8e28			;                ret 
8e28			;is_hex_2        scf                     ; Set carry 
8e28			;                ret 
8e28			; 
8e28			; Convert a single character contained in A to upper case: 
8e28			; 
8e28 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8e2a d8			                ret     c 
8e2b fe 7b		                cp      'z' + 1         ; > 'z'? 
8e2d d0			                ret     nc              ; Nothing to do, either 
8e2e e6 5f		                and     $5f             ; Convert to upper case 
8e30 c9			                ret 
8e31			 
8e31			 
8e31			to_lower: 
8e31			 
8e31			   ; if char is in [A-Z] make it lower case 
8e31			 
8e31			   ; enter : a = char 
8e31			   ; exit  : a = lower case char 
8e31			   ; uses  : af 
8e31			 
8e31 fe 41		   cp 'A' 
8e33 d8			   ret c 
8e34			    
8e34 fe 5b		   cp 'Z'+1 
8e36 d0			   ret nc 
8e37			    
8e37 f6 20		   or $20 
8e39 c9			   ret 
8e3a			 
8e3a			; 
8e3a			; Expects a hexadecimal digit (upper case!) in A and returns the 
8e3a			; corresponding value in A. 
8e3a			; 
8e3a fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8e3c 38 02		                jr      c, nibble2val_1 ; Yes 
8e3e d6 07		                sub     7               ; Adjust for A-F 
8e40 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8e42 e6 0f		                and     $f              ; Only return lower 4 bits 
8e44 c9			                ret 
8e45			; 
8e45			; Print_nibble prints a single hex nibble which is contained in the lower  
8e45			; four bits of A: 
8e45			; 
8e45			;print_nibble    push    af              ; We won't destroy the contents of A 
8e45			;                and     $f              ; Just in case... 
8e45			;                add     a, '0'             ; If we have a digit we are done here. 
8e45			;                cp      '9' + 1         ; Is the result > 9? 
8e45			;                jr      c, print_nibble_1 
8e45			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8e45			;print_nibble_1  call    putc            ; Print the nibble and 
8e45			;                pop     af              ; restore the original value of A 
8e45			;                ret 
8e45			;; 
8e45			;; Send a CR/LF pair: 
8e45			; 
8e45			;crlf            push    af 
8e45			;                ld      a, cr 
8e45			;                call    putc 
8e45			;                ld      a, lf 
8e45			;                call    putc 
8e45			;                pop     af 
8e45			;                ret 
8e45			; 
8e45			; Print_word prints the four hex digits of a word to the serial line. The  
8e45			; word is expected to be in HL. 
8e45			; 
8e45			;print_word      push    hl 
8e45			;                push    af 
8e45			;                ld      a, h 
8e45			;                call    print_byte 
8e45			;                ld      a, l 
8e45			;                call    print_byte 
8e45			;                pop     af 
8e45			;                pop     hl 
8e45			;                ret 
8e45			; 
8e45			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8e45			; The byte to be printed is expected to be in A. 
8e45			; 
8e45			;print_byte      push    af              ; Save the contents of the registers 
8e45			;                push    bc 
8e45			;                ld      b, a 
8e45			;                rrca 
8e45			;                rrca 
8e45			;                rrca 
8e45			;                rrca 
8e45			;                call    print_nibble    ; Print high nibble 
8e45			;                ld      a, b 
8e45			;                call    print_nibble    ; Print low nibble 
8e45			;                pop     bc              ; Restore original register contents 
8e45			;                pop     af 
8e45			;                ret 
8e45			 
8e45			 
8e45			 
8e45			 
8e45			 
8e45			fourehexhl:  
8e45 7e				ld a,(hl) 
8e46 cd f4 8d			call atohex 
8e49 cb 3f				SRL A 
8e4b cb 3f				SRL A 
8e4d cb 3f				SRL A 
8e4f cb 3f				SRL A 
8e51 47				ld b, a 
8e52 23				inc hl 
8e53 7e				ld a,(hl) 
8e54 23				inc hl 
8e55 cd f4 8d			call atohex 
8e58 80				add b 
8e59 57				ld d,a 
8e5a 7e				ld a,(hl) 
8e5b cd f4 8d			call atohex 
8e5e cb 3f				SRL A 
8e60 cb 3f				SRL A 
8e62 cb 3f				SRL A 
8e64 cb 3f				SRL A 
8e66 47				ld b, a 
8e67 23				inc hl 
8e68 7e				ld a,(hl) 
8e69 23				inc hl 
8e6a cd f4 8d			call atohex 
8e6d 80				add b 
8e6e 5f				ld e, a 
8e6f d5				push de 
8e70 e1				pop hl 
8e71 c9				ret 
8e72			 
8e72			; pass hl. returns z set if the byte at hl is a digit 
8e72			;isdigithl:  
8e72			;	push bc 
8e72			;	ld a,(hl) 
8e72			;	cp ':' 
8e72			;	jr nc, .isdf 		; > 
8e72			;	cp '0' 
8e72			;	jr c, .isdf		; < 
8e72			; 
8e72			;	; TODO find a better way to set z 
8e72			; 
8e72			;	ld b,a 
8e72			;	cp b 
8e72			;	pop bc 
8e72			;	ret 
8e72			; 
8e72			;.isdf:	; not digit so clear z 
8e72			; 
8e72			;	; TODO find a better way to unset z 
8e72			; 
8e72			;	ld b,a 
8e72			;	inc b 
8e72			;	cp b 
8e72			; 
8e72			;	pop bc 
8e72			;	ret 
8e72				 
8e72				 
8e72			 
8e72			 
8e72			; pass hl as the four byte address to load 
8e72			 
8e72			get_word_hl:  
8e72 e5				push hl 
8e73 cd 12 8e			call get_byte 
8e76				 
8e76 47				ld b, a 
8e77			 
8e77 e1				pop hl 
8e78 23				inc hl 
8e79 23				inc hl 
8e7a			 
8e7a			; TODO not able to handle a-f  
8e7a 7e				ld a,(hl) 
8e7b			;	;cp ':' 
8e7b			;	cp 'g' 
8e7b			;	jr nc, .single_byte_hl 		; > 
8e7b			;	cp 'G' 
8e7b			;	jr nc, .single_byte_hl 		; > 
8e7b			;	cp '0' 
8e7b			;	jr c, .single_byte_hl		; < 
8e7b			 
8e7b				;call isdigithl 
8e7b fe 00			cp 0 
8e7d 28 06			jr z, .single_byte_hl 
8e7f			 
8e7f			.getwhln:   ; hex word so get next byte 
8e7f			 
8e7f cd 12 8e			call get_byte 
8e82 6f				ld l, a 
8e83 60				ld h,b 
8e84 c9				ret 
8e85 68			.single_byte_hl:   ld l,b 
8e86 26 00				ld h,0 
8e88 c9					ret 
8e89			 
8e89			 
8e89			 
8e89			 
8e89 21 d2 95			ld hl,asc+1 
8e8c			;	ld a, (hl) 
8e8c			;	call nibble2val 
8e8c cd 12 8e			call get_byte 
8e8f			 
8e8f			;	call fourehexhl 
8e8f 32 1a e5			ld (scratch+52),a 
8e92				 
8e92 21 18 e5			ld hl,scratch+50 
8e95 22 09 e8			ld (os_cur_ptr),hl 
8e98			 
8e98 c9				ret 
8e99			 
8e99			 
8e99			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8e99			 
8e99			; Decimal Unsigned Version 
8e99			 
8e99			;Number in a to decimal ASCII 
8e99			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8e99			;Example: display a=56 as "056" 
8e99			;input: a = number 
8e99			;Output: a=0,value of a in the screen 
8e99			;destroys af,bc (don't know about hl and de) 
8e99			DispAToASCII: 
8e99 0e 9c			ld	c,-100 
8e9b cd a5 8e			call	.Na1 
8e9e 0e f6			ld	c,-10 
8ea0 cd a5 8e			call	.Na1 
8ea3 0e ff			ld	c,-1 
8ea5 06 2f		.Na1:	ld	b,'0'-1 
8ea7 04			.Na2:	inc	b 
8ea8 81				add	a,c 
8ea9 38 fc			jr	c,.Na2 
8eab 91				sub	c		;works as add 100/10/1 
8eac f5				push af		;safer than ld c,a 
8ead 78				ld	a,b		;char is in b 
8eae			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8eae f1				pop af		;safer than ld a,c 
8eaf c9				ret 
8eb0			 
8eb0			; Decimal Signed Version 
8eb0			 
8eb0			; DispA 
8eb0			; -------------------------------------------------------------- 
8eb0			; Converts a signed integer value to a zero-terminated ASCII 
8eb0			; string representative of that value (using radix 10). 
8eb0			; -------------------------------------------------------------- 
8eb0			; INPUTS: 
8eb0			;     HL     Value to convert (two's complement integer). 
8eb0			;     DE     Base address of string destination. (pointer). 
8eb0			; -------------------------------------------------------------- 
8eb0			; OUTPUTS: 
8eb0			;     None 
8eb0			; -------------------------------------------------------------- 
8eb0			; REGISTERS/MEMORY DESTROYED 
8eb0			; AF HL 
8eb0			; -------------------------------------------------------------- 
8eb0			 
8eb0			;DispHLToASCII: 
8eb0			;   push    de 
8eb0			;   push    bc 
8eb0			; 
8eb0			;; Detect sign of HL. 
8eb0			;    bit    7, h 
8eb0			;    jr     z, ._DoConvert 
8eb0			; 
8eb0			;; HL is negative. Output '-' to string and negate HL. 
8eb0			;    ld     a, '-' 
8eb0			;    ld     (de), a 
8eb0			;    inc    de 
8eb0			; 
8eb0			;; Negate HL (using two's complement) 
8eb0			;    xor    a 
8eb0			;    sub    l 
8eb0			;    ld     l, a 
8eb0			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8eb0			;    sbc    a, h 
8eb0			;    ld     h, a 
8eb0			; 
8eb0			;; Convert HL to digit characters 
8eb0			;._DoConvert: 
8eb0			;    ld     b, 0     ; B will count character length of number 
8eb0			;-   ld     a, 10 
8eb0			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8eb0			;    push   af 
8eb0			;    inc    b 
8eb0			;    ld     a, h 
8eb0			;    or     l 
8eb0			;    jr     nz, - 
8eb0			; 
8eb0			;; Retrieve digits from stack 
8eb0			;-   pop    af 
8eb0			;    or     $30 
8eb0			;    ld     (de), a 
8eb0			;    inc    de 
8eb0			;    djnz   - 
8eb0			; 
8eb0			;; Terminate string with NULL 
8eb0			;    xor    a 
8eb0			;    ld     (de), a 
8eb0			; 
8eb0			;    pop    bc 
8eb0			;    pop    de 
8eb0			;    ret 
8eb0			 
8eb0			;Comments 
8eb0			; 
8eb0			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8eb0			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8eb0			;    Note that the output string will not be fixed-width. 
8eb0			; 
8eb0			;Example Usage 
8eb0			; 
8eb0			;    ld    hl, -1004 
8eb0			;    ld    de, OP1 
8eb0			;    call  DispA 
8eb0			;    ld    hl, OP1 
8eb0			;    syscall  PutS 
8eb0			 
8eb0			 
8eb0			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8eb0			 
8eb0			 
8eb0			;Converts an ASCII string to an unsigned 16-bit integer 
8eb0			;Quits when it reaches a non-decimal digit 
8eb0			 
8eb0			string_to_uint16: 
8eb0			atoui_16: 
8eb0			;Input: 
8eb0			;     DE points to the string 
8eb0			;Outputs: 
8eb0			;     HL is the result 
8eb0			;     A is the 8-bit value of the number 
8eb0			;     DE points to the byte after the number 
8eb0			;Destroys: 
8eb0			;     BC 
8eb0			;       if the string is non-empty, BC is HL/10 
8eb0			;Size:  24 bytes 
8eb0			;Speed: 42+d(104+{0,9}) 
8eb0			;       d is the number of digits in the number 
8eb0			;       max is 640 cycles for a 5 digit number 
8eb0			;Assuming no leading zeros: 
8eb0			;1 digit:  146cc 
8eb0			;2 digit:  250cc 
8eb0			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8eb0			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8eb0			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8eb0			;avg: 544.81158447265625cc (544+13297/16384) 
8eb0			;=============================================================== 
8eb0 21 00 00		  ld hl,0 
8eb3			.u16a: 
8eb3 1a			  ld a,(de) 
8eb4 d6 30		  sub 30h 
8eb6 fe 0a		  cp 10 
8eb8 d0			  ret nc 
8eb9 13			  inc de 
8eba 44			  ld b,h 
8ebb 4d			  ld c,l 
8ebc 29			  add hl,hl 
8ebd 29			  add hl,hl 
8ebe 09			  add hl,bc 
8ebf 29			  add hl,hl 
8ec0 85			  add a,l 
8ec1 6f			  ld l,a 
8ec2 30 ef		  jr nc,.u16a 
8ec4 24			  inc h 
8ec5 c3 b3 8e		  jp .u16a 
8ec8			 
8ec8			 
8ec8			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8ec8			 
8ec8			;written by Zeda 
8ec8			;Converts a 16-bit unsigned integer to an ASCII string. 
8ec8			 
8ec8			uitoa_16: 
8ec8			;Input: 
8ec8			;   DE is the number to convert 
8ec8			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8ec8			;Output: 
8ec8			;   HL points to the null-terminated ASCII string 
8ec8			;      NOTE: This isn't necessarily the same as the input HL. 
8ec8 d5			  push de 
8ec9 c5			  push bc 
8eca f5			  push af 
8ecb eb			  ex de,hl 
8ecc			 
8ecc 01 f0 d8		  ld bc,-10000 
8ecf 3e 2f		  ld a,'0'-1 
8ed1 3c			  inc a 
8ed2 09			  add hl,bc  
8ed3 38 fc		   jr c,$-2 
8ed5 12			  ld (de),a 
8ed6 13			  inc de 
8ed7			 
8ed7 01 e8 03		  ld bc,1000 
8eda 3e 3a		  ld a,'9'+1 
8edc 3d			  dec a  
8edd 09			  add hl,bc  
8ede 30 fc		   jr nc,$-2 
8ee0 12			  ld (de),a 
8ee1 13			  inc de 
8ee2			 
8ee2 01 9c ff		  ld bc,-100 
8ee5 3e 2f		  ld a,'0'-1 
8ee7 3c			  inc a  
8ee8 09			  add hl,bc  
8ee9 38 fc		   jr c,$-2 
8eeb 12			  ld (de),a 
8eec 13			  inc de 
8eed			 
8eed 7d			  ld a,l 
8eee 26 3a		  ld h,'9'+1 
8ef0 25			  dec h  
8ef1 c6 0a		  add a,10  
8ef3 30 fb		   jr nc,$-3 
8ef5 c6 30		  add a,'0' 
8ef7 eb			  ex de,hl 
8ef8 72			  ld (hl),d 
8ef9 23			  inc hl 
8efa 77			  ld (hl),a 
8efb 23			  inc hl 
8efc 36 00		  ld (hl),0 
8efe			 
8efe			;Now strip the leading zeros 
8efe 0e fa		  ld c,-6 
8f00 09			  add hl,bc 
8f01 3e 30		  ld a,'0' 
8f03 23			  inc hl  
8f04 be			  cp (hl)  
8f05 28 fc		  jr z,$-2 
8f07			 
8f07			;Make sure that the string is non-empty! 
8f07 7e			  ld a,(hl) 
8f08 b7			  or a 
8f09 20 01		  jr nz,.atoub 
8f0b 2b			  dec hl 
8f0c			.atoub: 
8f0c			 
8f0c f1			  pop af 
8f0d c1			  pop bc 
8f0e d1			  pop de 
8f0f c9			  ret 
8f10			 
8f10			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
8f10			 
8f10			toUpper: 
8f10			;A is the char. 
8f10			;If A is a lowercase letter, this sets it to the matching uppercase 
8f10			;18cc or 30cc or 41cc 
8f10			;avg: 26.75cc 
8f10 fe 61		  cp 'a' 
8f12 d8			  ret c 
8f13 fe 7b		  cp 'z'+1 
8f15 d0			  ret nc 
8f16 d6 20		  sub 'a'-'A' 
8f18 c9			  ret 
8f19			 
8f19			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
8f19			 
8f19			; String Length 
8f19			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
8f19			 
8f19			; Get the length of the null-terminated string starting at $8000 hl 
8f19			;    LD     HL, $8000 
8f19			 
8f19			strlenz: 
8f19			 
8f19 af			    XOR    A               ; Zero is the value we are looking for. 
8f1a 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
8f1b 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
8f1c			                           ; 65, 536 bytes (the entire addressable memory space). 
8f1c ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8f1e			 
8f1e			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8f1e 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
8f1f 6f			    LD     L, A             ; number of bytes 
8f20 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8f22 2b			    DEC    HL              ; Compensate for null. 
8f23 c9				ret 
8f24			 
8f24			; Get the length of the A terminated string starting at $8000 hl 
8f24			;    LD     HL, $8000 
8f24			 
8f24			strlent: 
8f24			 
8f24			                  ; A is the value we are looking for. 
8f24 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
8f26 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
8f28			                           ; 65, 536 bytes (the entire addressable memory space). 
8f28 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8f2a			 
8f2a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8f2a 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
8f2c 2e 00		    LD     L, 0             ; number of bytes 
8f2e ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8f30 2b			    DEC    HL              ; Compensate for null. 
8f31 c9				ret 
8f32			 
8f32			 
8f32			;Comparing Strings 
8f32			 
8f32			;IN    HL     Address of string1. 
8f32			;      DE     Address of string2. 
8f32			 
8f32			; doc given but wrong??? 
8f32			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
8f32			;      carry  Set if string1 > string2, reset if string1 <= string2. 
8f32			; tested 
8f32			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
8f32			 
8f32			strcmp_old: 
8f32 e5			    PUSH   HL 
8f33 d5			    PUSH   DE 
8f34			 
8f34 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
8f35 be			    CP     (HL)            ; (want to minimize work). 
8f36 38 01		    JR     C, Str1IsBigger 
8f38 7e			    LD     A, (HL) 
8f39			 
8f39			Str1IsBigger: 
8f39 4f			    LD     C, A             ; Put length in BC 
8f3a 06 00		    LD     B, 0 
8f3c 13			    INC    DE              ; Increment pointers to meat of string. 
8f3d 23			    INC    HL 
8f3e			 
8f3e			CmpLoop: 
8f3e 1a			    LD     A, (DE)          ; Compare bytes. 
8f3f ed a1		    CPI 
8f41 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
8f43 13			    INC    DE              ; Update pointer. 
8f44 ea 3e 8f		    JP     PE, CmpLoop 
8f47			 
8f47 d1			    POP    DE 
8f48 e1			    POP    HL 
8f49 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
8f4a be			    CP     (HL) 
8f4b c9			    RET 
8f4c			 
8f4c			NoMatch: 
8f4c 2b			    DEC    HL 
8f4d be			    CP     (HL)            ; Compare again to affect carry. 
8f4e d1			    POP    DE 
8f4f e1			    POP    HL 
8f50 c9			    RET 
8f51			 
8f51			;; test strmp 
8f51			; 
8f51			;ld de, .str1 
8f51			;ld hl, .str2 
8f51			;call strcmp 
8f51			;jr z, .z1 
8f51			;;this 
8f51			;	if DEBUG_FORTH_WORDS 
8f51			;		DMARK "NZ1" 
8f51			;		CALLMONITOR 
8f51			;	endif 
8f51			;.z1: 
8f51			; 
8f51			;	if DEBUG_FORTH_WORDS 
8f51			;		DMARK "ZZ1" 
8f51			;		CALLMONITOR 
8f51			;	endif 
8f51			; 
8f51			;ld de, .str1 
8f51			;ld hl, .str1 
8f51			;call strcmp 
8f51			;jr z, .z2 
8f51			;;this 
8f51			;	if DEBUG_FORTH_WORDS 
8f51			;		DMARK "NZ2" 
8f51			;		CALLMONITOR 
8f51			;	endif 
8f51			;.z2: 
8f51			; 
8f51			;	if DEBUG_FORTH_WORDS 
8f51			;		DMARK "ZZ2" 
8f51			;		CALLMONITOR 
8f51			;	endif 
8f51			; 
8f51			;ld de, .str1 
8f51			;ld hl, .str2 
8f51			;call strcmp 
8f51			;jr c, .c1 
8f51			; 
8f51			;	if DEBUG_FORTH_WORDS 
8f51			;		DMARK "Nc1" 
8f51			;		CALLMONITOR 
8f51			;	endif 
8f51			;.c1: 
8f51			;;this 
8f51			;	if DEBUG_FORTH_WORDS 
8f51			;		DMARK "cc1" 
8f51			;		CALLMONITOR 
8f51			;	endif 
8f51			; 
8f51			;ld de, .str1 
8f51			;ld hl, .str1 
8f51			;call strcmp 
8f51			;jr c, .c2 
8f51			;;this 
8f51			;	if DEBUG_FORTH_WORDS 
8f51			;		DMARK "Nc2" 
8f51			;		CALLMONITOR 
8f51			;	endif 
8f51			;.c2: 
8f51			; 
8f51			;	if DEBUG_FORTH_WORDS 
8f51			;		DMARK "cc2" 
8f51			;		CALLMONITOR 
8f51			;	endif 
8f51			;	NEXTW 
8f51			;.str1:   db "string1",0 
8f51			;.str2:   db "string2",0 
8f51			 
8f51			; only care about direct match or not 
8f51			; hl and de strings 
8f51			; zero set if the same 
8f51			 
8f51			strcmp: 
8f51 1a				ld a, (de) 
8f52 be				cp (hl) 
8f53 28 02			jr z, .ssame 
8f55 b7				or a 
8f56 c9				ret 
8f57			 
8f57			.ssame:  
8f57 fe 00			cp 0 
8f59 c8				ret z 
8f5a			 
8f5a 23				inc hl 
8f5b 13				inc de 
8f5c 18 f3			jr strcmp 
8f5e				 
8f5e				 
8f5e			 
8f5e			 
8f5e			 
8f5e			 
8f5e			; eof 
8f5e			 
8f5e			 
8f5e			 
8f5e			 
8f5e			 
8f5e			 
# End of file firmware_strings.asm
8f5e			include "firmware_memory.asm"   ; malloc and free  
8f5e			 
8f5e			if DEBUG_FORTH_MALLOC_HIGH 
8f5e			.mallocsize: db "Wants malloc >256",0 
8f5e			.mallocasize: db "MALLOC gives >256",0 
8f5e			.malloczero: db "MALLOC gives zero",0 
8f5e			 
8f5e			malloc_guard_zerolen: 
8f5e				push hl 
8f5e				push de 
8f5e				push af 
8f5e			 
8f5e				ld de, 0 
8f5e			        call cmp16 
8f5e				jr nz, .lowalloz 
8f5e			 
8f5e				push hl 
8f5e				push de 
8f5e					ld hl, display_fb0 
8f5e					ld (display_fb_active), hl 
8f5e				call clear_display 
8f5e				ld a, 0 
8f5e				ld de, .malloczero 
8f5e				call str_at_display 
8f5e				call update_display 
8f5e				call delay1s 
8f5e				call delay1s 
8f5e				ld a, 0 
8f5e				ld (os_view_disable), a 
8f5e			 
8f5e				pop de 
8f5e				pop hl 
8f5e			 
8f5e				 
8f5e			 
8f5e				CALLMONITOR 
8f5e			.lowalloz: 
8f5e			 
8f5e			 
8f5e				pop af 
8f5e				pop de 
8f5e				pop hl 
8f5e			ret 
8f5e			 
8f5e			malloc_guard_entry: 
8f5e				push hl 
8f5e				push de 
8f5e				push af 
8f5e			 
8f5e			 	or a      ;clear carry flag 
8f5e				push hl 
8f5e				ld de, 255 
8f5e				sbc hl, de 
8f5e				jr c, .lowalloc 
8f5e			 
8f5e				push de 
8f5e					ld hl, display_fb0 
8f5e					ld (display_fb_active), hl 
8f5e				call clear_display 
8f5e				ld a, 0 
8f5e				ld de, .mallocsize 
8f5e				call str_at_display 
8f5e				call update_display 
8f5e				call delay1s 
8f5e				call delay1s 
8f5e				ld a, 0 
8f5e				ld (os_view_disable), a 
8f5e			 
8f5e				pop de 
8f5e				pop hl 
8f5e			 
8f5e				 
8f5e			 
8f5e				CALLMONITOR 
8f5e				jr .lowdone 
8f5e			.lowalloc: 
8f5e			 
8f5e			 
8f5e				pop hl 
8f5e			.lowdone:	pop af 
8f5e				pop de 
8f5e				pop hl 
8f5e			ret 
8f5e			 
8f5e			malloc_guard_exit: 
8f5e				push hl 
8f5e				push de 
8f5e				push af 
8f5e			 
8f5e			 	or a      ;clear carry flag 
8f5e				push hl 
8f5e				ld de, 255 
8f5e				sbc hl, de 
8f5e				jr c, .lowallocx 
8f5e			 
8f5e				push de 
8f5e					ld hl, display_fb0 
8f5e					ld (display_fb_active), hl 
8f5e				call clear_display 
8f5e				ld a, 0 
8f5e				ld de, .mallocasize 
8f5e				call str_at_display 
8f5e				call update_display 
8f5e				call delay1s 
8f5e				call delay1s 
8f5e				ld a, 0 
8f5e				ld (os_view_disable), a 
8f5e				pop de 
8f5e				pop hl 
8f5e			 
8f5e				CALLMONITOR 
8f5e				jr .lowdonex 
8f5e			.lowallocx: 
8f5e			 
8f5e				pop hl 
8f5e			.lowdonex:	pop af 
8f5e				pop de 
8f5e				pop hl 
8f5e			ret 
8f5e			endif 
8f5e			 
8f5e			if MALLOC_2 
8f5e			; Z80 Malloc and Free Functions 
8f5e			 
8f5e			; Malloc Function: 
8f5e			; Input: 
8f5e			;   HL: Size of block to allocate 
8f5e			; Output: 
8f5e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f5e			 
8f5e			malloc: 
8f5e				 
8f5e			if DEBUG_FORTH_MALLOC_HIGH 
8f5e			call malloc_guard_entry 
8f5e			endif 
8f5e			 
8f5e			 
8f5e			 
8f5e			 
8f5e					if DEBUG_FORTH_MALLOC 
8f5e						DMARK "mal" 
8f5e						CALLMONITOR 
8f5e					endif 
8f5e			    push af            ; Save AF register 
8f5e			    ld a, l            ; Load low byte of size into A 
8f5e			    or h               ; Check if size is zero 
8f5e			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
8f5e			 
8f5e			    ; Allocate memory 
8f5e			    ld hl, (heap_start) ; Load start of heap into HL 
8f5e					if DEBUG_FORTH_MALLOC 
8f5e						DMARK "ma1" 
8f5e						CALLMONITOR 
8f5e					endif 
8f5e			    call malloc_internal ; Call internal malloc function 
8f5e			    pop af             ; Restore AF register 
8f5e			if DEBUG_FORTH_MALLOC_HIGH 
8f5e			call malloc_guard_exit 
8f5e			call malloc_guard_zerolen 
8f5e			endif 
8f5e			    ret                ; Return 
8f5e			 
8f5e			; Free Function: 
8f5e			; Input: 
8f5e			;   HL: Pointer to memory block to free 
8f5e			; Output: 
8f5e			;   None 
8f5e			 
8f5e			free: 
8f5e			    push af            ; Save AF register 
8f5e			    ld a, l            ; Load low byte of pointer into A 
8f5e			    or h               ; Check if pointer is NULL 
8f5e			    jp z, free_exit    ; If pointer is NULL, exit 
8f5e			 
8f5e			    ; Free memory 
8f5e			    ld hl, (heap_start) ; Load start of heap into HL 
8f5e			    call free_internal  ; Call internal free function 
8f5e			    pop af             ; Restore AF register 
8f5e			    ret                ; Return 
8f5e			 
8f5e			; Internal Malloc Function: 
8f5e			; Input: 
8f5e			;   HL: Size of block to allocate 
8f5e			; Output: 
8f5e			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f5e			 
8f5e			malloc_internal: 
8f5e			    ld bc, 2           ; Number of bytes to allocate for management overhead 
8f5e			    add hl, bc         ; Add management overhead to requested size 
8f5e			    ex de, hl          ; Save total size in DE, and keep it in HL 
8f5e					if DEBUG_FORTH_MALLOC 
8f5e						DMARK "ma2" 
8f5e						CALLMONITOR 
8f5e					endif 
8f5e			 
8f5e			    ; Search for free memory block 
8f5e			    ld de, (heap_end)  ; Load end of heap into DE 
8f5e			    ld bc, 0           ; Initialize counter 
8f5e			 
8f5e					if DEBUG_FORTH_MALLOC 
8f5e						DMARK "ma2" 
8f5e						CALLMONITOR 
8f5e					endif 
8f5e			malloc_search_loop: 
8f5e			    ; Check if current block is free 
8f5e			    ld a, (hl)         ; Load current block's status (free or used) 
8f5e			    cp 0               ; Compare with zero (free) 
8f5e			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
8f5e			 
8f5e			    ; Check if current block is large enough 
8f5e			    ld a, (hl+1)       ; Load high byte of block size 
8f5e			    cp l               ; Compare with low byte of requested size 
8f5e			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
8f5e			 
8f5e			    ld a, (hl+2)       ; Load low byte of block size 
8f5e			    cp h               ; Compare with high byte of requested size 
8f5e			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
8f5e			 
8f5e			    ; Mark block as used 
8f5e			    ld (hl), 0xFF      ; Set status byte to indicate used block 
8f5e			 
8f5e			    ; Calculate remaining space in block 
8f5e			    ld bc, 0           ; Clear BC 
8f5e			    add hl, bc         ; Increment HL to point to start of data block 
8f5e			    add hl, de         ; HL = HL + DE (total size) 
8f5e			    ld bc, 1           ; Number of bytes to allocate for management overhead 
8f5e			    add hl, bc         ; Add management overhead to start of data block 
8f5e			 
8f5e			    ; Save pointer to allocated block in HL 
8f5e			if DEBUG_FORTH_MALLOC_HIGH 
8f5e						DMARK "ma5" 
8f5e			call malloc_guard_exit 
8f5e			call malloc_guard_zerolen 
8f5e			endif 
8f5e			    ret 
8f5e			 
8f5e			malloc_skip_block_check: 
8f5e			    ; Move to the next block 
8f5e			    ld bc, 3           ; Size of management overhead 
8f5e			    add hl, bc         ; Move to the next block 
8f5e			    inc de             ; Increment counter 
8f5e			 
8f5e			    ; Check if we have reached the end of heap 
8f5e			    ld a, e            ; Load low byte of heap end address 
8f5e			    cp (hl)            ; Compare with low byte of current address 
8f5e			    jr nz, malloc_search_loop  ; If not equal, continue searching 
8f5e			    ld a, d            ; Load high byte of heap end address 
8f5e			    cp 0               ; Check if it's zero (end of memory) 
8f5e			    jr nz, malloc_search_loop  ; If not zero, continue searching 
8f5e			 
8f5e			    ; If we reached here, allocation failed 
8f5e			    xor a              ; Set result to NULL 
8f5e			if DEBUG_FORTH_MALLOC_HIGH 
8f5e						DMARK "ma6" 
8f5e			call malloc_guard_exit 
8f5e			call malloc_guard_zerolen 
8f5e			endif 
8f5e			    ret 
8f5e			malloc_exit: 
8f5e			if DEBUG_FORTH_MALLOC_HIGH 
8f5e						DMARK "ma7" 
8f5e			call malloc_guard_exit 
8f5e			call malloc_guard_zerolen 
8f5e			endif 
8f5e			    ret 
8f5e			 
8f5e			; Internal Free Function: 
8f5e			; Input: 
8f5e			;   HL: Pointer to memory block to free 
8f5e			; Output: 
8f5e			;   None 
8f5e			 
8f5e			free_internal: 
8f5e			    ld de, (heap_start) ; Load start of heap into DE 
8f5e			    ld bc, 0            ; Initialize counter 
8f5e			 
8f5e			free_search_loop: 
8f5e			    ; Check if current block contains the pointer 
8f5e			    ld a, l             ; Load low byte of pointer 
8f5e			    cp (hl+1)           ; Compare with high byte of current block's address 
8f5e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f5e			    ld a, h             ; Load high byte of pointer 
8f5e			    cp (hl+2)           ; Compare with low byte of current block's address 
8f5e			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f5e			 
8f5e			    ; Mark block as free 
8f5e			    ld (hl), 0          ; Set status byte to indicate free block 
8f5e			    ret                 ; Return 
8f5e			 
8f5e			free_skip_block_check: 
8f5e			    ; Move to the next block 
8f5e			    ld bc, 3            ; Size of management overhead 
8f5e			    add hl, bc          ; Move to the next block 
8f5e			    inc de              ; Increment counter 
8f5e			 
8f5e			    ; Check if we have reached the end of heap 
8f5e			    ld a, e             ; Load low byte of heap end address 
8f5e			    cp (hl)             ; Compare with low byte of current address 
8f5e			    jr nz, free_search_loop  ; If not equal, continue searching 
8f5e			    ld a, d             ; Load high byte of heap end address 
8f5e			    cp 0                ; Check if it's zero (end of memory) 
8f5e			    jr nz, free_search_loop  ; If not zero, continue searching 
8f5e			 
8f5e			    ; If we reached here, pointer is not found in heap 
8f5e			    ret 
8f5e			 
8f5e			free_exit: 
8f5e			    ret                 ; Return 
8f5e			 
8f5e			; Define heap start and end addresses 
8f5e			;heap_start:    .dw 0xC000   ; Start of heap 
8f5e			;heap_end:      .dw 0xE000   ; End of heap 
8f5e			 
8f5e			endif 
8f5e			 
8f5e			 
8f5e			if MALLOC_1 
8f5e			 
8f5e			 
8f5e			 
8f5e			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
8f5e			 
8f5e			;moved to firmware.asm 
8f5e			;heap_start        .equ  0x9000      ; Starting address of heap 
8f5e			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
8f5e			 
8f5e			;      .org 0 
8f5e			;      jp    main 
8f5e			 
8f5e			 
8f5e			;      .org  0x100 
8f5e			;main: 
8f5e			;      ld    HL, 0x8100 
8f5e			;      ld    SP, HL 
8f5e			; 
8f5e			;      call  heap_init 
8f5e			; 
8f5e			;      ; Make some allocations 
8f5e			;      ld    HL, 12 
8f5e			;      call  malloc            ; Allocates 0x9004 
8f5e			; 
8f5e			;      ld    HL, 12 
8f5e			;      call  malloc            ; Allocates 0x9014 
8f5e			; 
8f5e			;      ld    HL, 12 
8f5e			;      call  malloc            ; Allocates 0x9024 
8f5e			; 
8f5e			;      ; Free some allocations 
8f5e			;      ld    HL, 0x9014 
8f5e			;      call  free 
8f5e			; 
8f5e			;      ld    HL, 0x9004 
8f5e			;      call  free 
8f5e			; 
8f5e			;      ld    HL, 0x9024 
8f5e			;      call  free 
8f5e			; 
8f5e			; 
8f5e			;      halt 
8f5e			 
8f5e			 
8f5e			;------------------------------------------------------------------------------ 
8f5e			;     heap_init                                                               : 
8f5e			;                                                                             : 
8f5e			; Description                                                                 : 
8f5e			;     Initialise the heap and make it ready for malloc and free operations.   : 
8f5e			;                                                                             : 
8f5e			;     The heap is maintained as a linked list, starting with an initial       : 
8f5e			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
8f5e			;     the first free block in the heap. Each block then points to the next    : 
8f5e			;     free block within the heap, and the free list ends at the first block   : 
8f5e			;     with a null pointer to the next free block.                             : 
8f5e			;                                                                             : 
8f5e			; Parameters                                                                  : 
8f5e			;     Inputs are compile-time only. Two defines which specify the starting    : 
8f5e			;     address of the heap and its size are required, along with a memory      : 
8f5e			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
8f5e			;     principally stores a pointer to the first free block in the heap.       : 
8f5e			;                                                                             : 
8f5e			; Returns                                                                     : 
8f5e			;     Nothing                                                                 : 
8f5e			;------------------------------------------------------------------------------ 
8f5e			heap_init: 
8f5e e5			      push  HL 
8f5f			 
8f5f			      ; Initialise free list struct 
8f5f 21 93 d7		      ld    HL, heap_start 
8f62 22 8e d7		      ld    (free_list), HL 
8f65 21 00 00		      ld    HL, 0 
8f68 22 90 d7		      ld    (free_list+2), HL 
8f6b			 
8f6b			      ; Insert first free block at bottom of heap, consumes entire heap 
8f6b 21 c8 e4		      ld    HL, heap_start+heap_size-4 
8f6e 22 93 d7		      ld    (heap_start), HL        ; Next block (end of free list) 
8f71 21 35 0d		      ld    HL, heap_size-4 
8f74 22 95 d7		      ld    (heap_start+2), HL      ; Block size 
8f77			 
8f77			      ; Insert end of free list block at top of heap - two null words will 
8f77			      ; terminate the free list 
8f77 21 00 00		      ld    HL, 0 
8f7a 22 ca e4		      ld    (heap_start+heap_size-2), HL 
8f7d 22 c8 e4		      ld    (heap_start+heap_size-4), HL 
8f80			 
8f80 e1			      pop   HL 
8f81			 
8f81 c9			      ret 
8f82			 
8f82			 
8f82			;------------------------------------------------------------------------------ 
8f82			;     malloc                                                                  : 
8f82			;                                                                             : 
8f82			; Description                                                                 : 
8f82			;     Allocates the wanted space from the heap and returns the address of the : 
8f82			;     first useable byte of the allocation.                                   : 
8f82			;                                                                             : 
8f82			;     Allocations can happen in one of two ways:                              : 
8f82			;                                                                             : 
8f82			;     1. A free block may be found which is the exact size wanted. In this    : 
8f82			;        case the block is removed from the free list and retuedn to the      : 
8f82			;        caller.                                                              : 
8f82			;     2. A free block may be found which is larger than the size wanted. In   : 
8f82			;        this case, the larger block is split into two. The first portion of  : 
8f82			;        this block will become the requested space by the malloc call and    : 
8f82			;        is returned to the caller. The second portion becomes a new free     : 
8f82			;        block, and the free list is adjusted to maintain continuity via this : 
8f82			;        newly created block.                                                 : 
8f82			;                                                                             : 
8f82			;     malloc does not set any initial value in the allocated space, the       : 
8f82			;     caller is required to do this as required.                              : 
8f82			;                                                                             : 
8f82			;     This implementation of malloc uses the stack exclusively, and is        : 
8f82			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8f82			;     advisable to disable interrupts before calling malloc, and recommended  : 
8f82			;     to avoid the use of malloc inside ISRs in general.                      : 
8f82			;                                                                             : 
8f82			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8f82			;                                                                             : 
8f82			; Parameters                                                                  : 
8f82			;     HL  Number of bytes wanted                                              : 
8f82			;                                                                             : 
8f82			; Returns                                                                     : 
8f82			;     HL  Address of the first useable byte of the allocation                 : 
8f82			;                                                                             : 
8f82			; Flags                                                                       : 
8f82			;     Z   Set if the allocation did not succeed, clear otherwise              : 
8f82			;                                                                             : 
8f82			; Stack frame                                                                 : 
8f82			;       |             |                                                       : 
8f82			;       +-------------+                                                       : 
8f82			;       |     BC      |                                                       : 
8f82			;       +-------------+                                                       : 
8f82			;       |     DE      |                                                       : 
8f82			;       +-------------+                                                       : 
8f82			;       |     IX      |                                                       : 
8f82			;       +-------------+                                                       : 
8f82			;       |  prev_free  |                                                       : 
8f82			;   +4  +-------------+                                                       : 
8f82			;       |  this_free  |                                                       : 
8f82			;   +2  +-------------+                                                       : 
8f82			;       |  next_free  |                                                       : 
8f82			;   +0  +-------------+                                                       : 
8f82			;       |             |                                                       : 
8f82			;                                                                             : 
8f82			;------------------------------------------------------------------------------ 
8f82			 
8f82			 
8f82			;malloc: 
8f82			; 
8f82			;	SAVESP ON 1 
8f82			; 
8f82			;	call malloc_code 
8f82			; 
8f82			;	CHECKSP ON 1 
8f82			;	ret 
8f82			 
8f82			 
8f82			malloc: 
8f82 c5			      push  BC 
8f83 d5			      push  DE 
8f84 dd e5		      push  IX 
8f86			if DEBUG_FORTH_MALLOC_HIGH 
8f86			call malloc_guard_entry 
8f86			endif 
8f86			 
8f86					if DEBUG_FORTH_MALLOC 
8f86						DMARK "mal" 
8f86						CALLMONITOR 
8f86					endif 
8f86 7c			      ld    A, H                    ; Exit if no space requested 
8f87 b5			      or    L 
8f88 ca 47 90		      jp    Z, malloc_early_exit 
8f8b			 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			; 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			;inc hl 
8f8b			 
8f8b			 
8f8b			 
8f8b			 
8f8b					if DEBUG_FORTH_MALLOC 
8f8b						DMARK "maA" 
8f8b						CALLMONITOR 
8f8b					endif 
8f8b			      ; Set up stack frame 
8f8b eb			      ex    DE, HL 
8f8c 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
8f8f 39			      add   HL, SP 
8f90 f9			      ld    SP, HL 
8f91 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
8f95 dd 39		      add   IX, SP 
8f97			 
8f97			      ; Setup initial state 
8f97 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
8f9a 19			      add   HL, DE 
8f9b			 
8f9b 44			      ld    B, H                    ; Move want to BC 
8f9c 4d			      ld    C, L 
8f9d			 
8f9d 21 8e d7		      ld    HL, free_list           ; Store prev_free ptr to stack 
8fa0 dd 75 04		      ld    (IX+4), L 
8fa3 dd 74 05		      ld    (IX+5), H 
8fa6			 
8fa6 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
8fa7 23			      inc   HL 
8fa8 56			      ld    D, (HL) 
8fa9 dd 73 02		      ld    (IX+2), E 
8fac dd 72 03		      ld    (IX+3), D 
8faf eb			      ex    DE, HL                  ; this_free ptr into HL 
8fb0			 
8fb0					if DEBUG_FORTH_MALLOC 
8fb0						DMARK "maB" 
8fb0						CALLMONITOR 
8fb0					endif 
8fb0			      ; Loop through free block list to find some space 
8fb0			malloc_find_space: 
8fb0 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
8fb1 23			      inc   HL 
8fb2 56			      ld    D, (HL) 
8fb3			 
8fb3 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
8fb4 b3			      or    E 
8fb5 ca 41 90		      jp    Z, malloc_no_space 
8fb8			 
8fb8 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
8fbb dd 72 01		      ld    (IX+1), D 
8fbe			 
8fbe			      ; Does this block have enough space to make the allocation? 
8fbe 23			      inc   HL                      ; Load free block size into DE 
8fbf 5e			      ld    E, (HL) 
8fc0 23			      inc   HL 
8fc1 56			      ld    D, (HL) 
8fc2			 
8fc2 eb			      ex    DE, HL                  ; Check size of block against want 
8fc3 b7			      or    A                       ; Ensure carry flag clear 
8fc4 ed 42		      sbc   HL, BC 
8fc6 e5			      push  HL                      ; Store the result for later (new block size) 
8fc7			 
8fc7 ca 16 90		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
8fca 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
8fcc			 
8fcc			      ; this_free block is not big enough, setup ptrs to test next free block 
8fcc e1			      pop   HL                      ; Discard previous result 
8fcd			 
8fcd dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
8fd0 dd 66 03		      ld    H, (IX+3) 
8fd3 dd 75 04		      ld    (IX+4), L 
8fd6 dd 74 05		      ld    (IX+5), H 
8fd9			 
8fd9 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
8fdc dd 66 01		      ld    H, (IX+1) 
8fdf dd 75 02		      ld    (IX+2), L 
8fe2 dd 74 03		      ld    (IX+3), H 
8fe5			 
8fe5					if DEBUG_FORTH_MALLOC 
8fe5						DMARK "MA>" 
8fe5						CALLMONITOR 
8fe5					endif 
8fe5 18 c9		      jr    malloc_find_space 
8fe7			 
8fe7			      ; split a bigger block into two - requested size and remaining size 
8fe7			malloc_alloc_split: 
8fe7					if DEBUG_FORTH_MALLOC 
8fe7						DMARK "MAs" 
8fe7						CALLMONITOR 
8fe7					endif 
8fe7 eb			      ex    DE, HL                  ; Calculate address of new free block 
8fe8 2b			      dec   HL 
8fe9 2b			      dec   HL 
8fea 2b			      dec   HL 
8feb 09			      add   HL, BC 
8fec			 
8fec			      ; Create a new block and point it at next_free 
8fec dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
8fef dd 56 01		      ld    D, (IX+1) 
8ff2			 
8ff2 73			      ld    (HL), E                 ; Store next_free ptr into new block 
8ff3 23			      inc   HL 
8ff4 72			      ld    (HL), D 
8ff5			 
8ff5 d1			      pop   DE                      ; Store size of new block into new block 
8ff6 23			      inc   HL 
8ff7 73			      ld    (HL), E 
8ff8 23			      inc   HL 
8ff9 72			      ld    (HL), D 
8ffa			 
8ffa			      ; Update this_free ptr to point to new block 
8ffa 2b			      dec   HL 
8ffb 2b			      dec   HL 
8ffc 2b			      dec   HL 
8ffd			 
8ffd dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9000 dd 56 03		      ld    D, (IX+3) 
9003			 
9003 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9006 dd 74 03		      ld    (IX+3), H 
9009			 
9009			      ; Modify this_free block to be allocation 
9009 eb			      ex    DE, HL 
900a af			      xor   A                       ; Null the next block ptr of allocated block 
900b 77			      ld    (HL), A 
900c 23			      inc   HL 
900d 77			      ld    (HL), A 
900e			 
900e 23			      inc   HL                      ; Store want size into allocated block 
900f 71			      ld    (HL), C 
9010 23			      inc   HL 
9011 70			      ld    (HL), B 
9012 23			      inc   HL 
9013 e5			      push  HL                      ; Address of allocation to return 
9014			 
9014 18 19		      jr    malloc_update_links 
9016			 
9016			malloc_alloc_fit: 
9016 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
9017			 
9017					if DEBUG_FORTH_MALLOC 
9017						DMARK "MAf" 
9017						CALLMONITOR 
9017					endif 
9017			      ; Modify this_free block to be allocation 
9017 eb			      ex    DE, HL 
9018 2b			      dec   HL 
9019 2b			      dec   HL 
901a 2b			      dec   HL 
901b			 
901b af			      xor   A                       ; Null the next block ptr of allocated block 
901c 77			      ld    (HL), A 
901d 23			      inc   HL 
901e 77			      ld    (HL), A 
901f			 
901f 23			      inc   HL                      ; Store address of allocation to return 
9020 23			      inc   HL 
9021 23			      inc   HL 
9022 e5			      push  HL 
9023			 
9023			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9023 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9026 dd 66 01		      ld    H, (IX+1) 
9029			 
9029 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
902c dd 74 03		      ld    (IX+3), H 
902f			 
902f			 
902f			malloc_update_links: 
902f			      ; Update prev_free ptr to point to this_free 
902f dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9032 dd 66 05		      ld    H, (IX+5) 
9035			 
9035 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9038 dd 56 03		      ld    D, (IX+3) 
903b			 
903b 73			      ld    (HL), E                 ; this_free ptr into prev_free 
903c 23			      inc   HL 
903d 72			      ld    (HL), D 
903e			 
903e					if DEBUG_FORTH_MALLOC 
903e						DMARK "Mul" 
903e						CALLMONITOR 
903e					endif 
903e			      ; Clear the Z flag to indicate successful allocation 
903e 7a			      ld    A, D 
903f b3			      or    E 
9040			 
9040 d1			      pop   DE                      ; Address of allocation 
9041					if DEBUG_FORTH_MALLOC 
9041						DMARK "MAu" 
9041						CALLMONITOR 
9041					endif 
9041			 
9041			malloc_no_space: 
9041 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9044 39			      add   HL, SP 
9045 f9			      ld    SP, HL 
9046			 
9046 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9047					if DEBUG_FORTH_MALLOC 
9047						DMARK "MAN" 
9047						CALLMONITOR 
9047					endif 
9047			 
9047			malloc_early_exit: 
9047					if DEBUG_FORTH_MALLOC 
9047						DMARK "MAx" 
9047						CALLMONITOR 
9047					endif 
9047 dd e1		      pop   IX 
9049 d1			      pop   DE 
904a c1			      pop   BC 
904b			 
904b			if DEBUG_FORTH_MALLOC_HIGH 
904b			call malloc_guard_exit 
904b			call malloc_guard_zerolen 
904b			endif 
904b c9			      ret 
904c			 
904c			 
904c			;------------------------------------------------------------------------------ 
904c			;     free                                                                    : 
904c			;                                                                             : 
904c			; Description                                                                 : 
904c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
904c			;     returned by malloc, otherwise the behaviour is undefined.               : 
904c			;                                                                             : 
904c			;     Where possible, directly adjacent free blocks will be merged together   : 
904c			;     into larger blocks to help ensure that the heap does not become         : 
904c			;     excessively fragmented.                                                 : 
904c			;                                                                             : 
904c			;     free does not clear or set any other value into the freed space, and    : 
904c			;     therefore its contents may be visible through subsequent malloc's. The  : 
904c			;     caller should clear the freed space as required.                        : 
904c			;                                                                             : 
904c			;     This implementation of free uses the stack exclusively, and is          : 
904c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
904c			;     advisable to disable interrupts before calling free, and recommended    : 
904c			;     to avoid the use of free inside ISRs in general.                        : 
904c			;                                                                             : 
904c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
904c			;                                                                             : 
904c			; Parameters                                                                  : 
904c			;     HL  Pointer to address of first byte of allocation to be freed          : 
904c			;                                                                             : 
904c			; Returns                                                                     : 
904c			;     Nothing                                                                 : 
904c			;                                                                             : 
904c			; Stack frame                                                                 : 
904c			;       |             |                                                       : 
904c			;       +-------------+                                                       : 
904c			;       |     BC      |                                                       : 
904c			;       +-------------+                                                       : 
904c			;       |     DE      |                                                       : 
904c			;       +-------------+                                                       : 
904c			;       |     IX      |                                                       : 
904c			;       +-------------+                                                       : 
904c			;       |  prev_free  |                                                       : 
904c			;   +2  +-------------+                                                       : 
904c			;       |  next_free  |                                                       : 
904c			;   +0  +-------------+                                                       : 
904c			;       |             |                                                       : 
904c			;                                                                             : 
904c			;------------------------------------------------------------------------------ 
904c			free: 
904c c5			      push  BC 
904d d5			      push  DE 
904e dd e5		      push  IX 
9050			 
9050 7c			      ld    A, H                    ; Exit if ptr is null 
9051 b5			      or    L 
9052 ca 16 91		      jp    Z, free_early_exit 
9055			 
9055			      ; Set up stack frame 
9055 eb			      ex    DE, HL 
9056 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
9059 39			      add   HL, SP 
905a f9			      ld    SP, HL 
905b dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
905f dd 39		      add   IX, SP 
9061			 
9061			      ; The address in HL points to the start of the useable allocated space, 
9061			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9061			      ; address of the block itself. 
9061 eb			      ex    DE, HL 
9062 11 fc ff		      ld    DE, -4 
9065 19			      add   HL, DE 
9066			 
9066			      ; An allocated block must have a null next block pointer in it 
9066 7e			      ld    A, (HL) 
9067 23			      inc   HL 
9068 b6			      or    (HL) 
9069 c2 11 91		      jp    NZ, free_done 
906c			 
906c 2b			      dec   HL 
906d			 
906d 44			      ld    B, H                    ; Copy HL to BC 
906e 4d			      ld    C, L 
906f			 
906f			      ; Loop through the free list to find the first block with an address 
906f			      ; higher than the block being freed 
906f 21 8e d7		      ld    HL, free_list 
9072			 
9072			free_find_higher_block: 
9072 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9073 23			      inc   HL 
9074 56			      ld    D, (HL) 
9075 2b			      dec   HL 
9076			 
9076 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
9079 dd 72 01		      ld    (IX+1), D 
907c dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
907f dd 74 03		      ld    (IX+3), H 
9082			 
9082 78			      ld    A, B                    ; Check if DE is greater than BC 
9083 ba			      cp    D                       ; Compare MSB first 
9084 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
9086 30 04		      jr    NC, free_find_higher_block_skip 
9088 79			      ld    A, C 
9089 bb			      cp    E                       ; Then compare LSB 
908a 38 08		      jr    C, free_found_higher_block 
908c			 
908c			free_find_higher_block_skip: 
908c 7a			      ld    A, D                    ; Reached the end of the free list? 
908d b3			      or    E 
908e ca 11 91		      jp    Z, free_done 
9091			 
9091 eb			      ex    DE, HL 
9092			 
9092 18 de		      jr    free_find_higher_block 
9094			 
9094			free_found_higher_block: 
9094			      ; Insert freed block between prev and next free blocks 
9094 71			      ld    (HL), C                 ; Point prev free block to freed block 
9095 23			      inc   HL 
9096 70			      ld    (HL), B 
9097			 
9097 60			      ld    H, B                    ; Point freed block at next free block 
9098 69			      ld    L, C 
9099 73			      ld    (HL), E 
909a 23			      inc   HL 
909b 72			      ld    (HL), D 
909c			 
909c			      ; Check if the freed block is adjacent to the next free block 
909c 23			      inc   HL                      ; Load size of freed block into HL 
909d 5e			      ld    E, (HL) 
909e 23			      inc   HL 
909f 56			      ld    D, (HL) 
90a0 eb			      ex    DE, HL 
90a1			 
90a1 09			      add   HL, BC                  ; Add addr of freed block and its size 
90a2			 
90a2 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
90a5 dd 56 01		      ld    D, (IX+1) 
90a8			 
90a8 b7			      or    A                       ; Clear the carry flag 
90a9 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
90ab 20 22		      jr    NZ, free_check_adjacent_to_prev 
90ad			 
90ad			      ; Freed block is adjacent to next, merge into one bigger block 
90ad eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
90ae 5e			      ld    E, (HL) 
90af 23			      inc   HL 
90b0 56			      ld    D, (HL) 
90b1 e5			      push  HL                      ; Save ptr to next block for later 
90b2			 
90b2 60			      ld    H, B                    ; Store ptr from next block into freed block 
90b3 69			      ld    L, C 
90b4 73			      ld    (HL), E 
90b5 23			      inc   HL 
90b6 72			      ld    (HL), D 
90b7			 
90b7 e1			      pop   HL                      ; Restore ptr to next block 
90b8 23			      inc   HL                      ; Load size of next block into DE 
90b9 5e			      ld    E, (HL) 
90ba 23			      inc   HL 
90bb 56			      ld    D, (HL) 
90bc d5			      push  DE                      ; Save next block size for later 
90bd			 
90bd 60			      ld    H, B                    ; Load size of freed block into HL 
90be 69			      ld    L, C 
90bf 23			      inc   HL 
90c0 23			      inc   HL 
90c1 5e			      ld    E, (HL) 
90c2 23			      inc   HL 
90c3 56			      ld    D, (HL) 
90c4 eb			      ex    DE, HL 
90c5			 
90c5 d1			      pop   DE                      ; Restore size of next block 
90c6 19			      add   HL, DE                  ; Add sizes of both blocks 
90c7 eb			      ex    DE, HL 
90c8			 
90c8 60			      ld    H, B                    ; Store new bigger size into freed block 
90c9 69			      ld    L, C 
90ca 23			      inc   HL 
90cb 23			      inc   HL 
90cc 73			      ld    (HL), E 
90cd 23			      inc   HL 
90ce 72			      ld    (HL), D 
90cf			 
90cf			free_check_adjacent_to_prev: 
90cf			      ; Check if the freed block is adjacent to the prev free block 
90cf dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
90d2 dd 66 03		      ld    H, (IX+3) 
90d5			 
90d5 23			      inc   HL                      ; Size of prev free block into DE 
90d6 23			      inc   HL 
90d7 5e			      ld    E, (HL) 
90d8 23			      inc   HL 
90d9 56			      ld    D, (HL) 
90da 2b			      dec   HL 
90db 2b			      dec   HL 
90dc 2b			      dec   HL 
90dd			 
90dd 19			      add   HL, DE                  ; Add prev block addr and size 
90de			 
90de b7			      or    A                       ; Clear the carry flag 
90df ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
90e1 20 2e		      jr    NZ, free_done 
90e3			 
90e3			      ; Freed block is adjacent to prev, merge into one bigger block 
90e3 60			      ld    H, B                    ; Load next ptr from freed block into DE 
90e4 69			      ld    L, C 
90e5 5e			      ld    E, (HL) 
90e6 23			      inc   HL 
90e7 56			      ld    D, (HL) 
90e8 e5			      push  HL                      ; Save freed block ptr for later 
90e9			 
90e9 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
90ec dd 66 03		      ld    H, (IX+3) 
90ef 73			      ld    (HL), E 
90f0 23			      inc   HL 
90f1 72			      ld    (HL), D 
90f2			 
90f2 e1			      pop   HL                      ; Restore freed block ptr 
90f3 23			      inc   HL                      ; Load size of freed block into DE 
90f4 5e			      ld    E, (HL) 
90f5 23			      inc   HL 
90f6 56			      ld    D, (HL) 
90f7 d5			      push  DE                      ; Save freed block size for later 
90f8			 
90f8 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
90fb dd 66 03		      ld    H, (IX+3) 
90fe 23			      inc   HL 
90ff 23			      inc   HL 
9100 5e			      ld    E, (HL) 
9101 23			      inc   HL 
9102 56			      ld    D, (HL) 
9103			 
9103 e1			      pop   HL                      ; Add sizes of both blocks 
9104 19			      add   HL, DE 
9105 eb			      ex    DE, HL 
9106			 
9106 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
9109 dd 66 03		      ld    H, (IX+3) 
910c 23			      inc   HL 
910d 23			      inc   HL 
910e 73			      ld    (HL), E 
910f 23			      inc   HL 
9110 72			      ld    (HL), D 
9111			 
9111			free_done: 
9111 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9114 39			      add   HL, SP 
9115 f9			      ld    SP, HL 
9116			 
9116			free_early_exit: 
9116 dd e1		      pop   IX 
9118 d1			      pop   DE 
9119 c1			      pop   BC 
911a			 
911a c9			      ret 
911b			 
911b			; moved to firmware.asm 
911b			; 
911b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
911b			;                  .dw   0 
911b			 
911b			 
911b			endif 
911b			 
911b			 
911b			if MALLOC_3 
911b			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
911b			;heap_start        .equ  0x9000      ; Starting address of heap 
911b			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
911b			; 
911b			 ;     .org 0 
911b			  ;    jp    main 
911b			; 
911b			; 
911b			 ;     .org  0x100 
911b			;main: 
911b			 ;     ld    HL, 0x8100 
911b			  ;    ld    SP, HL 
911b			; 
911b			;      call  heap_init 
911b			 
911b			      ; Make some allocations 
911b			;      ld    HL, 12 
911b			;      call  malloc            ; Allocates 0x9004 
911b			; 
911b			 ;     ld    HL, 12 
911b			;      call  malloc            ; Allocates 0x9014 
911b			 
911b			;      ld    HL, 12 
911b			;      call  malloc            ; Allocates 0x9024 
911b			 
911b			      ; Free some allocations 
911b			;      ld    HL, 0x9014 
911b			;      call  free 
911b			 
911b			;      ld    HL, 0x9004 
911b			;      call  free 
911b			; 
911b			;      ld    HL, 0x9024 
911b			;      call  free 
911b			 
911b			 
911b			 ;     halt 
911b			 
911b			 
911b			;------------------------------------------------------------------------------ 
911b			;     heap_init                                                               : 
911b			;                                                                             : 
911b			; Description                                                                 : 
911b			;     Initialise the heap and make it ready for malloc and free operations.   : 
911b			;                                                                             : 
911b			;     The heap is maintained as a linked list, starting with an initial       : 
911b			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
911b			;     the first free block in the heap. Each block then points to the next    : 
911b			;     free block within the heap, and the free list ends at the first block   : 
911b			;     with a null pointer to the next free block.                             : 
911b			;                                                                             : 
911b			; Parameters                                                                  : 
911b			;     Inputs are compile-time only. Two defines which specify the starting    : 
911b			;     address of the heap and its size are required, along with a memory      : 
911b			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
911b			;     principally stores a pointer to the first free block in the heap.       : 
911b			;                                                                             : 
911b			; Returns                                                                     : 
911b			;     Nothing                                                                 : 
911b			;------------------------------------------------------------------------------ 
911b			heap_init: 
911b			      push  HL 
911b			 
911b			      ; Initialise free list struct 
911b			      ld    HL, heap_start 
911b			      ld    (free_list), HL 
911b			      ld    HL, 0 
911b			      ld    (free_list+2), HL 
911b			 
911b			      ; Insert first free block at bottom of heap, consumes entire heap 
911b			      ld    HL, heap_start+heap_size-4 
911b			      ld    (heap_start), HL        ; Next block (end of free list) 
911b			      ld    HL, heap_size-4 
911b			      ld    (heap_start+2), HL      ; Block size 
911b			 
911b			      ; Insert end of free list block at top of heap - two null words will 
911b			      ; terminate the free list 
911b			      ld    HL, 0 
911b			      ld    (heap_start+heap_size-2), HL 
911b			      ld    (heap_start+heap_size-4), HL 
911b			 
911b			      pop   HL 
911b			 
911b			      ret 
911b			 
911b			 
911b			;------------------------------------------------------------------------------ 
911b			;     malloc                                                                  : 
911b			;                                                                             : 
911b			; Description                                                                 : 
911b			;     Allocates the wanted space from the heap and returns the address of the : 
911b			;     first useable byte of the allocation.                                   : 
911b			;                                                                             : 
911b			;     Allocations can happen in one of two ways:                              : 
911b			;                                                                             : 
911b			;     1. A free block may be found which is the exact size wanted. In this    : 
911b			;        case the block is removed from the free list and retuedn to the      : 
911b			;        caller.                                                              : 
911b			;     2. A free block may be found which is larger than the size wanted. In   : 
911b			;        this case, the larger block is split into two. The first portion of  : 
911b			;        this block will become the requested space by the malloc call and    : 
911b			;        is returned to the caller. The second portion becomes a new free     : 
911b			;        block, and the free list is adjusted to maintain continuity via this : 
911b			;        newly created block.                                                 : 
911b			;                                                                             : 
911b			;     malloc does not set any initial value in the allocated space, the       : 
911b			;     caller is required to do this as required.                              : 
911b			;                                                                             : 
911b			;     This implementation of malloc uses the stack exclusively, and is        : 
911b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
911b			;     advisable to disable interrupts before calling malloc, and recommended  : 
911b			;     to avoid the use of malloc inside ISRs in general.                      : 
911b			;                                                                             : 
911b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
911b			;                                                                             : 
911b			; Parameters                                                                  : 
911b			;     HL  Number of bytes wanted                                              : 
911b			;                                                                             : 
911b			; Returns                                                                     : 
911b			;     HL  Address of the first useable byte of the allocation                 : 
911b			;                                                                             : 
911b			; Flags                                                                       : 
911b			;     Z   Set if the allocation did not succeed, clear otherwise              : 
911b			;                                                                             : 
911b			; Stack frame                                                                 : 
911b			;       |             |                                                       : 
911b			;       +-------------+                                                       : 
911b			;       |     BC      |                                                       : 
911b			;       +-------------+                                                       : 
911b			;       |     DE      |                                                       : 
911b			;       +-------------+                                                       : 
911b			;       |     IX      |                                                       : 
911b			;       +-------------+                                                       : 
911b			;       |  prev_free  |                                                       : 
911b			;   +4  +-------------+                                                       : 
911b			;       |  this_free  |                                                       : 
911b			;   +2  +-------------+                                                       : 
911b			;       |  next_free  |                                                       : 
911b			;   +0  +-------------+                                                       : 
911b			;       |             |                                                       : 
911b			;                                                                             : 
911b			;------------------------------------------------------------------------------ 
911b			malloc: 
911b			      push  BC 
911b			      push  DE 
911b			      push  IX 
911b			 
911b			      ld    A, H                    ; Exit if no space requested 
911b			      or    L 
911b			      jp    Z, malloc_early_exit 
911b			 
911b			      ; Set up stack frame 
911b			      ex    DE, HL 
911b			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
911b			      add   HL, SP 
911b			      ld    SP, HL 
911b			      ld    IX, 0                   ; Use IX as a frame pointer 
911b			      add   IX, SP 
911b			 
911b			      ; Setup initial state 
911b			      ld    HL, 4                   ; want must also include space used by block struct 
911b			      add   HL, DE 
911b			 
911b			      ld    B, H                    ; Move want to BC 
911b			      ld    C, L 
911b			 
911b			      ld    HL, free_list           ; Store prev_free ptr to stack 
911b			      ld    (IX+4), L 
911b			      ld    (IX+5), H 
911b			 
911b			      ld    E, (HL)                 ; Store this_free ptr to stack 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			      ld    (IX+2), E 
911b			      ld    (IX+3), D 
911b			      ex    DE, HL                  ; this_free ptr into HL 
911b			 
911b			      ; Loop through free block list to find some space 
911b			malloc_find_space: 
911b			      ld    E, (HL)                 ; Load next_free ptr into DE 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			 
911b			      ld    A, D                    ; Check for null next_free ptr - end of free list 
911b			      or    E 
911b			      jp    Z, malloc_no_space 
911b			 
911b			      ld    (IX+0), E               ; Store next_free ptr to stack 
911b			      ld    (IX+1), D 
911b			 
911b			      ; Does this block have enough space to make the allocation? 
911b			      inc   HL                      ; Load free block size into DE 
911b			      ld    E, (HL) 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			 
911b			      ex    DE, HL                  ; Check size of block against want 
911b			      or    A                       ; Ensure carry flag clear 
911b			      sbc   HL, BC 
911b			      push  HL                      ; Store the result for later (new block size) 
911b			 
911b			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
911b			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
911b			 
911b			      ; this_free block is not big enough, setup ptrs to test next free block 
911b			      pop   HL                      ; Discard previous result 
911b			 
911b			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
911b			      ld    H, (IX+3) 
911b			      ld    (IX+4), L 
911b			      ld    (IX+5), H 
911b			 
911b			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
911b			      ld    H, (IX+1) 
911b			      ld    (IX+2), L 
911b			      ld    (IX+3), H 
911b			 
911b			      jr    malloc_find_space 
911b			 
911b			      ; split a bigger block into two - requested size and remaining size 
911b			malloc_alloc_split: 
911b			      ex    DE, HL                  ; Calculate address of new free block 
911b			      dec   HL 
911b			      dec   HL 
911b			      dec   HL 
911b			      add   HL, BC 
911b			 
911b			      ; Create a new block and point it at next_free 
911b			      ld    E, (IX+0)               ; Load next_free ptr into DE 
911b			      ld    D, (IX+1) 
911b			 
911b			      ld    (HL), E                 ; Store next_free ptr into new block 
911b			      inc   HL 
911b			      ld    (HL), D 
911b			 
911b			      pop   DE                      ; Store size of new block into new block 
911b			      inc   HL 
911b			      ld    (HL), E 
911b			      inc   HL 
911b			      ld    (HL), D 
911b			 
911b			      ; Update this_free ptr to point to new block 
911b			      dec   HL 
911b			      dec   HL 
911b			      dec   HL 
911b			 
911b			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
911b			      ld    D, (IX+3) 
911b			 
911b			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
911b			      ld    (IX+3), H 
911b			 
911b			      ; Modify this_free block to be allocation 
911b			      ex    DE, HL 
911b			      xor   A                       ; Null the next block ptr of allocated block 
911b			      ld    (HL), A 
911b			      inc   HL 
911b			      ld    (HL), A 
911b			 
911b			      inc   HL                      ; Store want size into allocated block 
911b			      ld    (HL), C 
911b			      inc   HL 
911b			      ld    (HL), B 
911b			      inc   HL 
911b			      push  HL                      ; Address of allocation to return 
911b			 
911b			      jr    malloc_update_links 
911b			 
911b			malloc_alloc_fit: 
911b			      pop   HL                      ; Dont need new block size, want is exact fit 
911b			 
911b			      ; Modify this_free block to be allocation 
911b			      ex    DE, HL 
911b			      dec   HL 
911b			      dec   HL 
911b			      dec   HL 
911b			 
911b			      xor   A                       ; Null the next block ptr of allocated block 
911b			      ld    (HL), A 
911b			      inc   HL 
911b			      ld    (HL), A 
911b			 
911b			      inc   HL                      ; Store address of allocation to return 
911b			      inc   HL 
911b			      inc   HL 
911b			      push  HL 
911b			 
911b			      ; Copy next_free ptr to this_free, remove allocated block from free list 
911b			      ld    L, (IX+0)               ; next_free to HL 
911b			      ld    H, (IX+1) 
911b			 
911b			      ld    (IX+2), L               ; HL to this_free 
911b			      ld    (IX+3), H 
911b			 
911b			 
911b			malloc_update_links: 
911b			      ; Update prev_free ptr to point to this_free 
911b			      ld    L, (IX+4)               ; prev_free ptr to HL 
911b			      ld    H, (IX+5) 
911b			 
911b			      ld    E, (IX+2)               ; this_free ptr to DE 
911b			      ld    D, (IX+3) 
911b			 
911b			      ld    (HL), E                 ; this_free ptr into prev_free 
911b			      inc   HL 
911b			      ld    (HL), D 
911b			 
911b			      ; Clear the Z flag to indicate successful allocation 
911b			      ld    A, D 
911b			      or    E 
911b			 
911b			      pop   DE                      ; Address of allocation 
911b			 
911b			malloc_no_space: 
911b			      ld    HL, 6                   ; Clean up stack frame 
911b			      add   HL, SP 
911b			      ld    SP, HL 
911b			 
911b			      ex    DE, HL                  ; Alloc addr into HL for return 
911b			 
911b			malloc_early_exit: 
911b			      pop   IX 
911b			      pop   DE 
911b			      pop   BC 
911b			 
911b			      ret 
911b			 
911b			 
911b			;------------------------------------------------------------------------------ 
911b			;     free                                                                    : 
911b			;                                                                             : 
911b			; Description                                                                 : 
911b			;     Return the space pointed to by HL to the heap. HL must be an address as : 
911b			;     returned by malloc, otherwise the behaviour is undefined.               : 
911b			;                                                                             : 
911b			;     Where possible, directly adjacent free blocks will be merged together   : 
911b			;     into larger blocks to help ensure that the heap does not become         : 
911b			;     excessively fragmented.                                                 : 
911b			;                                                                             : 
911b			;     free does not clear or set any other value into the freed space, and    : 
911b			;     therefore its contents may be visible through subsequent malloc's. The  : 
911b			;     caller should clear the freed space as required.                        : 
911b			;                                                                             : 
911b			;     This implementation of free uses the stack exclusively, and is          : 
911b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
911b			;     advisable to disable interrupts before calling free, and recommended    : 
911b			;     to avoid the use of free inside ISRs in general.                        : 
911b			;                                                                             : 
911b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
911b			;                                                                             : 
911b			; Parameters                                                                  : 
911b			;     HL  Pointer to address of first byte of allocation to be freed          : 
911b			;                                                                             : 
911b			; Returns                                                                     : 
911b			;     Nothing                                                                 : 
911b			;                                                                             : 
911b			; Stack frame                                                                 : 
911b			;       |             |                                                       : 
911b			;       +-------------+                                                       : 
911b			;       |     BC      |                                                       : 
911b			;       +-------------+                                                       : 
911b			;       |     DE      |                                                       : 
911b			;       +-------------+                                                       : 
911b			;       |     IX      |                                                       : 
911b			;       +-------------+                                                       : 
911b			;       |  prev_free  |                                                       : 
911b			;   +2  +-------------+                                                       : 
911b			;       |  next_free  |                                                       : 
911b			;   +0  +-------------+                                                       : 
911b			;       |             |                                                       : 
911b			;                                                                             : 
911b			;------------------------------------------------------------------------------ 
911b			free: 
911b			      push  BC 
911b			      push  DE 
911b			      push  IX 
911b			 
911b			      ld    A, H                    ; Exit if ptr is null 
911b			      or    L 
911b			      jp    Z, free_early_exit 
911b			 
911b			      ; Set up stack frame 
911b			      ex    DE, HL 
911b			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
911b			      add   HL, SP 
911b			      ld    SP, HL 
911b			      ld    IX, 0                   ; Use IX as a frame pointer 
911b			      add   IX, SP 
911b			 
911b			      ; The address in HL points to the start of the useable allocated space, 
911b			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
911b			      ; address of the block itself. 
911b			      ex    DE, HL 
911b			      ld    DE, -4 
911b			      add   HL, DE 
911b			 
911b			      ; An allocated block must have a null next block pointer in it 
911b			      ld    A, (HL) 
911b			      inc   HL 
911b			      or    (HL) 
911b			      jp    NZ, free_done 
911b			 
911b			      dec   HL 
911b			 
911b			      ld    B, H                    ; Copy HL to BC 
911b			      ld    C, L 
911b			 
911b			      ; Loop through the free list to find the first block with an address 
911b			      ; higher than the block being freed 
911b			      ld    HL, free_list 
911b			 
911b			free_find_higher_block: 
911b			      ld    E, (HL)                 ; Load next ptr from free block 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			      dec   HL 
911b			 
911b			      ld    (IX+0), E               ; Save ptr to next free block 
911b			      ld    (IX+1), D 
911b			      ld    (IX+2), L               ; Save ptr to prev free block 
911b			      ld    (IX+3), H 
911b			 
911b			      ld    A, B                    ; Check if DE is greater than BC 
911b			      cp    D                       ; Compare MSB first 
911b			      jr    Z, $+4                  ; MSB the same, compare LSB 
911b			      jr    NC, free_find_higher_block_skip 
911b			      ld    A, C 
911b			      cp    E                       ; Then compare LSB 
911b			      jr    C, free_found_higher_block 
911b			 
911b			free_find_higher_block_skip: 
911b			      ld    A, D                    ; Reached the end of the free list? 
911b			      or    E 
911b			      jp    Z, free_done 
911b			 
911b			      ex    DE, HL 
911b			 
911b			      jr    free_find_higher_block 
911b			 
911b			free_found_higher_block: 
911b			      ; Insert freed block between prev and next free blocks 
911b			      ld    (HL), C                 ; Point prev free block to freed block 
911b			      inc   HL 
911b			      ld    (HL), B 
911b			 
911b			      ld    H, B                    ; Point freed block at next free block 
911b			      ld    L, C 
911b			      ld    (HL), E 
911b			      inc   HL 
911b			      ld    (HL), D 
911b			 
911b			      ; Check if the freed block is adjacent to the next free block 
911b			      inc   HL                      ; Load size of freed block into HL 
911b			      ld    E, (HL) 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			      ex    DE, HL 
911b			 
911b			      add   HL, BC                  ; Add addr of freed block and its size 
911b			 
911b			      ld    E, (IX+0)               ; Load addr of next free block into DE 
911b			      ld    D, (IX+1) 
911b			 
911b			      or    A                       ; Clear the carry flag 
911b			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
911b			      jr    NZ, free_check_adjacent_to_prev 
911b			 
911b			      ; Freed block is adjacent to next, merge into one bigger block 
911b			      ex    DE, HL                  ; Load next ptr from next block into DE 
911b			      ld    E, (HL) 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			      push  HL                      ; Save ptr to next block for later 
911b			 
911b			      ld    H, B                    ; Store ptr from next block into freed block 
911b			      ld    L, C 
911b			      ld    (HL), E 
911b			      inc   HL 
911b			      ld    (HL), D 
911b			 
911b			      pop   HL                      ; Restore ptr to next block 
911b			      inc   HL                      ; Load size of next block into DE 
911b			      ld    E, (HL) 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			      push  DE                      ; Save next block size for later 
911b			 
911b			      ld    H, B                    ; Load size of freed block into HL 
911b			      ld    L, C 
911b			      inc   HL 
911b			      inc   HL 
911b			      ld    E, (HL) 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			      ex    DE, HL 
911b			 
911b			      pop   DE                      ; Restore size of next block 
911b			      add   HL, DE                  ; Add sizes of both blocks 
911b			      ex    DE, HL 
911b			 
911b			      ld    H, B                    ; Store new bigger size into freed block 
911b			      ld    L, C 
911b			      inc   HL 
911b			      inc   HL 
911b			      ld    (HL), E 
911b			      inc   HL 
911b			      ld    (HL), D 
911b			 
911b			free_check_adjacent_to_prev: 
911b			      ; Check if the freed block is adjacent to the prev free block 
911b			      ld    L, (IX+2)               ; Prev free block ptr into HL 
911b			      ld    H, (IX+3) 
911b			 
911b			      inc   HL                      ; Size of prev free block into DE 
911b			      inc   HL 
911b			      ld    E, (HL) 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			      dec   HL 
911b			      dec   HL 
911b			      dec   HL 
911b			 
911b			      add   HL, DE                  ; Add prev block addr and size 
911b			 
911b			      or    A                       ; Clear the carry flag 
911b			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
911b			      jr    NZ, free_done 
911b			 
911b			      ; Freed block is adjacent to prev, merge into one bigger block 
911b			      ld    H, B                    ; Load next ptr from freed block into DE 
911b			      ld    L, C 
911b			      ld    E, (HL) 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			      push  HL                      ; Save freed block ptr for later 
911b			 
911b			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
911b			      ld    H, (IX+3) 
911b			      ld    (HL), E 
911b			      inc   HL 
911b			      ld    (HL), D 
911b			 
911b			      pop   HL                      ; Restore freed block ptr 
911b			      inc   HL                      ; Load size of freed block into DE 
911b			      ld    E, (HL) 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			      push  DE                      ; Save freed block size for later 
911b			 
911b			      ld    L, (IX+2)               ; Load size of prev block into DE 
911b			      ld    H, (IX+3) 
911b			      inc   HL 
911b			      inc   HL 
911b			      ld    E, (HL) 
911b			      inc   HL 
911b			      ld    D, (HL) 
911b			 
911b			      pop   HL                      ; Add sizes of both blocks 
911b			      add   HL, DE 
911b			      ex    DE, HL 
911b			 
911b			      ld    L, (IX+2)               ; Store new bigger size into prev block 
911b			      ld    H, (IX+3) 
911b			      inc   HL 
911b			      inc   HL 
911b			      ld    (HL), E 
911b			      inc   HL 
911b			      ld    (HL), D 
911b			 
911b			free_done: 
911b			      ld    HL, 4                   ; Clean up stack frame 
911b			      add   HL, SP 
911b			      ld    SP, HL 
911b			 
911b			free_early_exit: 
911b			      pop   IX 
911b			      pop   DE 
911b			      pop   BC 
911b			 
911b			      ret 
911b			 
911b			 
911b			;      .org 0x8000 
911b			; 
911b			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
911b			 ;                 .dw   0 
911b			 
911b			endif 
911b			 
911b			 
911b			if MALLOC_4 
911b			 
911b			; My memory allocation code. Very very simple.... 
911b			; allocate space under 250 chars 
911b			 
911b			heap_init: 
911b				; init start of heap as zero 
911b				;  
911b			 
911b				ld hl, heap_start 
911b				ld a, 0 
911b				ld (hl), a      ; empty block 
911b				inc hl 
911b				ld a, 0 
911b				ld (hl), a      ; length of block 
911b				; write end of list 
911b				inc hl 
911b				ld a,(hl) 
911b				inc hl 
911b				ld a,(hl) 
911b				 
911b			 
911b				; init some malloc vars 
911b			 
911b				ld hl, 0 
911b				ld (free_list), hl       ; store last malloc location 
911b			 
911b				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
911b				ld a, 0 
911b				ld (hl), a 
911b			 
911b			 
911b				ld hl, heap_start 
911b				;  
911b				  
911b				ret 
911b			 
911b			 
911b			;    free block marker 
911b			;    requested size  
911b			;    pointer to next block 
911b			;    .... 
911b			;    next block marker 
911b			 
911b			 
911b			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
911b			; 
911b			 
911b			 
911b			malloc:  
911b				push de 
911b				push bc 
911b				push af 
911b			 
911b				; hl space required 
911b				 
911b				ld c, l    ; hold space   (TODO only a max of 255) 
911b			 
911b			;	inc c     ; TODO BUG need to fix memory leak on push str 
911b			;	inc c 
911b			;	inc c 
911b			;	inc c 
911b			;	inc c 
911b			;	inc c 
911b			;	inc c 
911b			 
911b			 
911b			 
911b				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
911b			 
911b				ld a, (free_list+3) 
911b				cp 0 
911b				jr z, .contheap 
911b			 
911b				ld hl, (free_list)     ; get last alloc 
911b					if DEBUG_FORTH_MALLOC_INT 
911b						DMARK "mrs" 
911b						CALLMONITOR 
911b					endif 
911b				jr .startalloc 
911b			 
911b			.contheap: 
911b				ld hl, heap_start 
911b			 
911b			.startalloc: 
911b			 
911b					if DEBUG_FORTH_MALLOC_INT 
911b						DMARK "mym" 
911b						CALLMONITOR 
911b					endif 
911b			.findblock: 
911b					if DEBUG_FORTH_MALLOC_INT 
911b						DMARK "mmf" 
911b						CALLMONITOR 
911b					endif 
911b			 
911b				ld a,(hl)  
911b				; if byte is zero then clear to use 
911b			 
911b				cp 0 
911b				jr z, .foundemptyblock 
911b			 
911b				; if byte is not clear 
911b				;     then byte is offset to next block 
911b			 
911b				inc hl 
911b				ld a, (hl) ; get size 
911b			.nextblock:	inc hl 
911b					ld e, (hl) 
911b					inc hl 
911b					ld d, (hl) 
911b					ex de, hl 
911b			;	inc hl  ; move past the store space 
911b			;	inc hl  ; move past zero index  
911b			 
911b				; TODO detect no more space 
911b			 
911b				push hl 
911b				ld de, heap_end 
911b				call cmp16 
911b				pop hl 
911b				jr nc, .nospace 
911b			 
911b				jr .findblock 
911b			 
911b			.nospace: ld hl, 0 
911b				jp .exit 
911b			 
911b			 
911b			.foundemptyblock:	 
911b					if DEBUG_FORTH_MALLOC_INT 
911b						DMARK "mme" 
911b						CALLMONITOR 
911b					endif 
911b			 
911b			; TODO has block enough space if reusing??? 
911b			 
911b				;  
911b			 
911b			; see if this block has been previously used 
911b				inc hl 
911b				ld a, (hl) 
911b				dec hl 
911b				cp 0 
911b				jr z, .newblock 
911b			 
911b					if DEBUG_FORTH_MALLOC_INT 
911b						DMARK "meR" 
911b						CALLMONITOR 
911b					endif 
911b			 
911b			; no reusing previously allocated block 
911b			 
911b			; is it smaller than previously used? 
911b				 
911b				inc hl    ; move to size 
911b				ld a, c 
911b				sub (hl)        ; we want c < (hl) 
911b				dec hl    ; move back to marker 
911b			        jr z, .findblock 
911b			 
911b				; update with the new size which should be lower 
911b			 
911b			        ;inc  hl   ; negate next move. move back to size  
911b			 
911b			.newblock: 
911b				; need to be at marker here 
911b			 
911b					if DEBUG_FORTH_MALLOC_INT 
911b						DMARK "meN" 
911b						CALLMONITOR 
911b					endif 
911b			 
911b			 
911b				ld a, c 
911b			 
911b				ld (free_list+3), a	 ; flag resume from last malloc  
911b				ld (free_list), hl    ; save out last location 
911b			 
911b			 
911b				;inc a     ; space for length byte 
911b				ld (hl), a     ; save block in use marker 
911b			 
911b				inc hl   ; move to space marker 
911b				ld (hl), a    ; save new space 
911b			 
911b				inc hl   ; move to start of allocated area 
911b				 
911b			;	push hl     ; save where we are - 1  
911b			 
911b			;	inc hl  ; move past zero index  
911b				; skip space to set down new marker 
911b			 
911b				; provide some extra space for now 
911b			 
911b				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
911b				inc a 
911b				inc a 
911b			 
911b				push hl   ; save where we are in the node block 
911b			 
911b				call addatohl 
911b			 
911b				; write linked list point 
911b			 
911b				pop de     ; get our node position 
911b				ex de, hl 
911b			 
911b				ld (hl), e 
911b				inc hl 
911b				ld (hl), d 
911b			 
911b				inc hl 
911b			 
911b				; now at start of allocated data so save pointer 
911b			 
911b				push hl 
911b			 
911b				; jump to position of next node and setup empty header in DE 
911b			 
911b				ex de, hl 
911b			 
911b			;	inc hl ; move past end of block 
911b			 
911b				ld a, 0 
911b				ld (hl), a   ; empty marker 
911b				inc hl 
911b				ld (hl), a   ; size 
911b				inc hl  
911b				ld (hl), a   ; ptr 
911b				inc hl 
911b				ld (hl), a   ; ptr 
911b			 
911b			 
911b				pop hl 
911b			 
911b					if DEBUG_FORTH_MALLOC_INT 
911b						DMARK "mmr" 
911b						CALLMONITOR 
911b					endif 
911b			 
911b			.exit: 
911b				pop af 
911b				pop bc 
911b				pop de  
911b				ret 
911b			 
911b			 
911b			 
911b			 
911b			free:  
911b				push hl 
911b				push af 
911b				; get address in hl 
911b			 
911b					if DEBUG_FORTH_MALLOC_INT 
911b						DMARK "fre" 
911b						CALLMONITOR 
911b					endif 
911b				; data is at hl - move to block count 
911b				dec hl 
911b				dec hl    ; get past pointer 
911b				dec hl 
911b			 
911b				ld a, (hl)    ; need this for a validation check 
911b			 
911b				dec hl    ; move to block marker 
911b			 
911b				; now check that the block count and block marker are the same  
911b			        ; this checks that we are on a malloc node and not random memory 
911b			        ; OK a faint chance this could be a problem but rare - famous last words! 
911b			 
911b				ld c, a 
911b				ld a, (hl)    
911b			 
911b				cp c 
911b				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
911b			 
911b				; yes good chance we are on a malloc node 
911b			 
911b				ld a, 0      
911b				ld (hl), a   ; mark as free 
911b			 
911b				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
911b			 
911b			.freeignore:  
911b			 
911b				pop af 
911b				pop hl 
911b			 
911b				ret 
911b			 
911b			 
911b			 
911b			endif 
911b			 
911b			; eof 
# End of file firmware_memory.asm
911b			  
911b			; device C  
911b			if SOUND_ENABLE  
911b				include "firmware_sound.asm"  
911b			endif  
911b			  
911b			include "firmware_diags.asm"  
911b			; Hardware diags menu 
911b			 
911b			 
911b			config: 
911b			 
911b 3e 00			ld a, 0 
911d 21 4b 91			ld hl, .configmn 
9120 cd bf 88			call menu 
9123			 
9123 fe 00			cp 0 
9125 c8				ret z 
9126			 
9126 fe 01			cp 1 
9128 cc ef 91			call z, .savetostore 
912b			 
912b fe 02			cp 2 
912d cc ed 91			call z, .selautoload 
9130 fe 03			cp 3 
9132 cc ec 91			call z, .disautoload 
9135 fe 04			cp 4 
9137 cc ee 91			call z, .selbank 
913a fe 05			cp 5 
913c cc f0 91			call z, .debug_tog 
913f fe 06			cp 6 
9141 cc 38 93			call z, .bpsgo 
9144 fe 07			cp 7 
9146 cc 16 92			call z, hardware_diags 
9149			 
9149 18 d0			jr config 
914b			 
914b			.configmn: 
914b 5b 91			dw .c3 
914d 72 91			dw .c2 
914f 87 91			dw .c2a 
9151 9d 91			dw .c2b 
9153			;	dw .c4 
9153 ba 91			dw .m4 
9155 d5 91			dw .m4b 
9157 dd 91			dw .c1 
9159 00 00			dw 0 
915b				 
915b			 
915b .. 00		.c3: db "Add Dictionary To File",0 
9172 .. 00		.c2: db "Select Autoload File",0 
9187 .. 00		.c2a: db "Disable Autoload File", 0 
919d .. 00		.c2b: db "Select Storage Bank",0 
91b1 .. 00		.c4: db "Settings",0 
91ba .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
91d5 .. 00		.m4b:   db "Monitor",0 
91dd .. 00		.c1: db "Hardware Diags",0 
91ec			 
91ec			 
91ec			.disautoload: 
91ec				if STORAGE_SE 
91ec				ld a, $fe      ; bit 0 clear 
91ec				ld (spi_device), a 
91ec			 
91ec				call storage_get_block_0 
91ec			 
91ec				ld a, 0 
91ec				ld (store_page+STORE_0_AUTOFILE), a 
91ec			 
91ec					ld hl, 0 
91ec					ld de, store_page 
91ec				call storage_write_block	 ; save update 
91ec				endif 
91ec			 
91ec			 
91ec c9				ret 
91ed			 
91ed			 
91ed			 
91ed			; Select auto start 
91ed			 
91ed			.selautoload: 
91ed			 
91ed				 
91ed				if STORAGE_SE 
91ed			 
91ed					call config_dir 
91ed				        ld hl, scratch 
91ed					ld a, 0 
91ed					call menu 
91ed			 
91ed					cp 0 
91ed					ret z 
91ed			 
91ed					dec a 
91ed			 
91ed			 
91ed					; locate menu option 
91ed			 
91ed					ld hl, scratch 
91ed					call table_lookup 
91ed			 
91ed					if DEBUG_FORTH_WORDS 
91ed						DMARK "ALl" 
91ed						CALLMONITOR 
91ed					endif 
91ed					; with the pointer to the menu it, the byte following the zero term is the file id 
91ed			 
91ed					ld a, 0 
91ed					ld bc, 50   ; max of bytes to look at 
91ed					cpir  
91ed			 
91ed					if DEBUG_FORTH_WORDS 
91ed						DMARK "ALb" 
91ed						CALLMONITOR 
91ed					endif 
91ed					;inc hl 
91ed			 
91ed					ld a, (hl)   ; file id 
91ed					 
91ed				        ; save bank and file ids 
91ed			 
91ed					push af 
91ed			 
91ed			; TODO need to save to block 0 on bank 1	 
91ed			 
91ed					call storage_get_block_0 
91ed			 
91ed					if DEBUG_FORTH_WORDS 
91ed						DMARK "AL0" 
91ed						CALLMONITOR 
91ed					endif 
91ed					pop af 
91ed			 
91ed					ld (store_page+STORE_0_FILERUN),a 
91ed					 
91ed					; save bank id 
91ed			 
91ed					ld a,(spi_device) 
91ed					ld (store_page+STORE_0_BANKRUN),a 
91ed			 
91ed					; enable auto run of store file 
91ed			 
91ed					ld a, 1 
91ed					ld (store_page+STORE_0_AUTOFILE),a 
91ed			 
91ed					; save buffer 
91ed			 
91ed					ld hl, 0 
91ed					ld de, store_page 
91ed					if DEBUG_FORTH_WORDS 
91ed						DMARK "ALw" 
91ed						CALLMONITOR 
91ed					endif 
91ed				call storage_write_block	 ; save update 
91ed			  
91ed			 
91ed			 
91ed			 
91ed					ld hl, scratch 
91ed					call config_fdir 
91ed			 
91ed			 
91ed				endif 
91ed c9				ret 
91ee			 
91ee			 
91ee			 
91ee			; Select storage bank 
91ee			 
91ee			.selbank: 
91ee			 
91ee				if STORAGE_SE 
91ee				endif 
91ee				 
91ee c9				ret 
91ef			 
91ef			if STORAGE_SE 
91ef			 
91ef			.config_ldir:   
91ef				; Load storage bank labels into menu array 
91ef			 
91ef				 
91ef			 
91ef			 
91ef				ret 
91ef			 
91ef			 
91ef			endif 
91ef			 
91ef			 
91ef			; Save user words to storage 
91ef			 
91ef			.savetostore: 
91ef			 
91ef				if STORAGE_SE 
91ef			 
91ef					call config_dir 
91ef				        ld hl, scratch 
91ef					ld a, 0 
91ef					call menu 
91ef					 
91ef					ld hl, scratch 
91ef					call config_fdir 
91ef			 
91ef			 
91ef				endif 
91ef			 
91ef c9				ret 
91f0			 
91f0			 
91f0			 
91f0			if STORAGE_SE 
91f0			 
91f0			config_fdir: 
91f0				; using the scratch dir go through and release the memory allocated for each string 
91f0				 
91f0				ld hl, scratch 
91f0			.cfdir:	ld e,(hl) 
91f0				inc hl 
91f0				ld d,(hl) 
91f0				inc hl 
91f0			 
91f0				ex de, hl 
91f0				call ishlzero 
91f0				ret z     ; return on null pointer 
91f0				call free 
91f0				ex de, hl 
91f0				jr .cfdir 
91f0			 
91f0			 
91f0				ret 
91f0			 
91f0			 
91f0			config_dir: 
91f0			 
91f0				; for the config menus that need to build a directory of storage call this routine 
91f0				; it will construct a menu in scratch to pass to menu 
91f0			 
91f0				; open storage device 
91f0			 
91f0				; execute DIR to build a list of files and their ids into scratch in menu format 
91f0				; once the menu has finished then will need to call config_fdir to release the strings 
91f0				 
91f0				; c = number items 
91f0			 
91f0				 
91f0				call storage_get_block_0 
91f0			 
91f0				ld hl, store_page     ; get current id count 
91f0				ld b, (hl) 
91f0				ld c, 0    ; count of files   
91f0			 
91f0			 
91f0				ld hl, scratch 
91f0				ld (store_tmp2), hl    ; location to poke strings 
91f0			 
91f0				; check for empty drive 
91f0			 
91f0				ld a, 0 
91f0				cp b 
91f0				jp z, .dirdone 
91f0			 
91f0				 
91f0					if DEBUG_FORTH_WORDS 
91f0						DMARK "Cdc" 
91f0						CALLMONITOR 
91f0					endif 
91f0			 
91f0			 
91f0			.diritem:	 
91f0				push bc 
91f0				; for each of the current ids do a search for them and if found push to stack 
91f0			 
91f0					ld hl, STORE_BLOCK_PHY 
91f0					ld d, 0		 ; look for extent 0 of block id as this contains file name 
91f0					ld e,b 
91f0			 
91f0					call storage_findnextid 
91f0			 
91f0			 
91f0					; if found hl will be non zero 
91f0			 
91f0					call ishlzero 
91f0					jr z, .dirnotfound 
91f0			 
91f0					; increase count 
91f0			 
91f0					pop bc	 
91f0					inc c 
91f0					push bc 
91f0					 
91f0			 
91f0					; get file header and push the file name 
91f0			 
91f0					ld de, store_page 
91f0					call storage_read_block 
91f0			 
91f0					; push file id to stack 
91f0				 
91f0					ld a, (store_page) 
91f0					ld h, 0 
91f0					ld l, a 
91f0			 
91f0					;call forth_push_numhl 
91f0					; TODO store id 
91f0			 
91f0					push hl 
91f0			 
91f0					; push extent count to stack  
91f0				 
91f0					ld hl, store_page+3 
91f0			 
91f0					; get file name length 
91f0			 
91f0					call strlenz   
91f0			 
91f0					inc hl   ; cover zero term 
91f0					inc hl  ; stick the id at the end of the area 
91f0			 
91f0					push hl 
91f0					pop bc    ; move length to bc 
91f0			 
91f0					call malloc 
91f0			 
91f0					; TODO save malloc area to scratch 
91f0			 
91f0					ex de, hl 
91f0					ld hl, (store_tmp2) 
91f0					ld (hl), e 
91f0					inc hl 
91f0					ld (hl), d 
91f0					inc hl 
91f0					ld (store_tmp2), hl 
91f0			 
91f0					 
91f0			 
91f0					;pop hl   ; get source 
91f0			;		ex de, hl    ; swap aronund	 
91f0			 
91f0					ld hl, store_page+3 
91f0					if DEBUG_FORTH_WORDS 
91f0						DMARK "CFd" 
91f0						CALLMONITOR 
91f0					endif 
91f0					ldir 
91f0			 
91f0					; de is past string, move back one and store id 
91f0					 
91f0					dec de 
91f0			 
91f0					; store file id 
91f0			 
91f0					pop hl 
91f0					ex de,hl 
91f0					ld (hl), e 
91f0			 
91f0					if DEBUG_FORTH_WORDS 
91f0						DMARK "Cdi" 
91f0						CALLMONITOR 
91f0					endif 
91f0					 
91f0			.dirnotfound: 
91f0					pop bc     
91f0					djnz .diritem 
91f0				 
91f0			.dirdone:	 
91f0			 
91f0					ld a, 0 
91f0					ld hl, (store_tmp2) 
91f0					ld (hl), a 
91f0					inc hl 
91f0					ld (hl), a 
91f0					inc hl 
91f0					; push a count of the dir items found 
91f0			 
91f0			;		ld h, 0 
91f0			;		ld l, c 
91f0			 
91f0				ret 
91f0			 
91f0			endif 
91f0			 
91f0			 
91f0			; Settings 
91f0			; Run  
91f0			 
91f0			 
91f0			 
91f0			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
91f0			;;hd_menu2:   db "        2: Editor",0   
91f0			;hd_menu2:   db "        2: Editor       6: Menu",0   
91f0			;hd_menu3:   db "        3: Storage",0 
91f0			;hd_menu4:   db "0=quit  4: Debug",0 
91f0			;hd_don:     db "ON",0 
91f0			;hd_doff:     db "OFF",0 
91f0			; 
91f0			; 
91f0			; 
91f0			;hardware_diags_old:       
91f0			; 
91f0			;.diagmenu: 
91f0			;	call clear_display 
91f0			;	ld a, display_row_1 
91f0			;	ld de, hd_menu1 
91f0			;	call str_at_display 
91f0			; 
91f0			;	ld a, display_row_2 
91f0			;	ld de, hd_menu2 
91f0			;	call str_at_display 
91f0			; 
91f0			;	ld a, display_row_3 
91f0			;	ld de, hd_menu3 
91f0			;	call str_at_display 
91f0			; 
91f0			;	ld a,  display_row_4 
91f0			;	ld de, hd_menu4 
91f0			;	call str_at_display 
91f0			; 
91f0			;	; display debug state 
91f0			; 
91f0			;	ld de, hd_don 
91f0			;	ld a, (os_view_disable) 
91f0			;	cp 0 
91f0			;	jr z, .distog 
91f0			;	ld de, hd_doff 
91f0			;.distog: ld a, display_row_4+17 
91f0			;	call str_at_display 
91f0			; 
91f0			;	call update_display 
91f0			; 
91f0			;	call cin_wait 
91f0			; 
91f0			; 
91f0			; 
91f0			;	cp '4' 
91f0			;	jr nz, .diagn1 
91f0			; 
91f0			;	; debug toggle 
91f0			; 
91f0			;	ld a, (os_view_disable) 
91f0			;	ld b, '*' 
91f0			;	cp 0 
91f0			;	jr z, .debtog 
91f0			;	ld b, 0 
91f0			;.debtog:	 
91f0			;	ld a,b 
91f0			;	ld (os_view_disable),a 
91f0			; 
91f0			;.diagn1: cp '0' 
91f0			;	 ret z 
91f0			; 
91f0			;;	cp '1' 
91f0			;;       jp z, matrix	 
91f0			;;   TODO keyboard matrix test 
91f0			; 
91f0			;	cp '2' 
91f0			;	jp z, .diagedit 
91f0			; 
91f0			;;	cp '6' 
91f0			;;	jp z, .menutest 
91f0			;;if ENABLE_BASIC 
91f0			;;	cp '6' 
91f0			;;	jp z, basic 
91f0			;;endif 
91f0			 ; 
91f0			;	jp .diagmenu 
91f0			; 
91f0			; 
91f0			;	ret 
91f0			 
91f0			 
91f0			.debug_tog: 
91f0 21 37 92			ld hl, .menudebug 
91f3				 
91f3 3a d7 e4			ld a, (os_view_disable) 
91f6 fe 2a			cp '*' 
91f8 20 04			jr nz,.tdon  
91fa 3e 01			ld a, 1 
91fc 18 02			jr .tog1 
91fe 3e 00		.tdon: ld a, 0 
9200			 
9200			.tog1: 
9200 cd bf 88			call menu 
9203 fe 00			cp 0 
9205 c8				ret z 
9206 fe 01			cp 1    ; disable debug 
9208 28 04			jr z, .dtog0 
920a 3e 2a			ld a, '*' 
920c 18 02			jr .dtogset 
920e 3e 00		.dtog0: ld a, 0 
9210 32 d7 e4		.dtogset:  ld (os_view_disable), a 
9213 c3 f0 91			jp .debug_tog 
9216			 
9216			 
9216			hardware_diags:       
9216			 
9216			.diagm: 
9216 21 29 92			ld hl, .menuitems 
9219 3e 00			ld a, 0 
921b cd bf 88			call menu 
921e			 
921e fe 00		         cp 0 
9220 c8				 ret z 
9221			 
9221 fe 02			cp 2 
9223 ca 82 92			jp z, .diagedit 
9226			 
9226			;	cp '6' 
9226			;	jp z, .menutest 
9226			;if ENABLE_BASIC 
9226			;	cp '6' 
9226			;	jp z, basic 
9226			;endif 
9226			  
9226 c3 16 92			jp .diagm 
9229			 
9229				 
9229 3d 92		.menuitems:   	dw .m1 
922b 48 92				dw .m2 
922d 4f 92				dw .m3 
922f 57 92				dw .m5 
9231 5d 92				dw .m5a 
9233 66 92				dw .m5b 
9235 00 00				dw 0 
9237			 
9237			.menudebug: 
9237 6f 92				dw .m6 
9239 78 92				dw .m7 
923b 00 00				dw 0 
923d			 
923d .. 00		.m1:   db "Key Matrix",0 
9248 .. 00		.m2:   db "Editor",0 
924f .. 00		.m3:   db "Storage",0 
9257 .. 00		.m5:   db "Sound",0 
925d .. 00		.m5a:  db "RAM Test",0 
9266 .. 00		.m5b:  db "LCD Test",0 
926f			 
926f .. 00		.m6:   db "Debug ON",0 
9278 .. 00		.m7:   db "Debug OFF",0 
9282			 
9282			; debug editor 
9282			 
9282			.diagedit: 
9282			 
9282 21 e6 e4			ld hl, scratch 
9285			;	ld bc, 250 
9285			;	ldir 
9285				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9285 3e 00			ld a, 0 
9287 77				ld (hl), a 
9288 23				inc hl 
9289 77				ld (hl), a 
928a 23				inc hl 
928b 77				ld (hl), a 
928c			 
928c cd 8e 88		        call clear_display 
928f cd b1 88			call update_display 
9292 3e 01			ld a, 1 
9294 32 c6 ee			ld (hardware_diag), a 
9297			.diloop: 
9297 3e 00			ld a, display_row_1 
9299 0e 00			ld c, 0 
929b 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
929d 1e 28			ld e, 40 
929f			 
929f 21 e6 e4			ld hl, scratch	 
92a2 cd e8 8a			call input_str 
92a5			 
92a5 3e 14			ld a, display_row_2 
92a7 11 e6 e4			ld de, scratch 
92aa cd a1 88			call str_at_display 
92ad cd b1 88			call update_display 
92b0			 
92b0 c3 97 92			jp .diloop 
92b3			 
92b3			 
92b3			; pass word in hl 
92b3			; a has display location 
92b3			display_word_at: 
92b3 f5				push af 
92b4 e5				push hl 
92b5 7c				ld a,h 
92b6 21 eb e7			ld hl, os_word_scratch 
92b9 cd bc 8d			call hexout 
92bc e1				pop hl 
92bd 7d				ld a,l 
92be 21 ed e7			ld hl, os_word_scratch+2 
92c1 cd bc 8d			call hexout 
92c4 21 ef e7			ld hl, os_word_scratch+4 
92c7 3e 00			ld a,0 
92c9 77				ld (hl),a 
92ca 11 eb e7			ld de,os_word_scratch 
92cd f1				pop af 
92ce cd a1 88				call str_at_display 
92d1 c9				ret 
92d2			 
92d2			display_ptr_state: 
92d2			 
92d2				; to restore afterwards 
92d2			 
92d2 d5				push de 
92d3 c5				push bc 
92d4 e5				push hl 
92d5 f5				push af 
92d6			 
92d6				; for use in here 
92d6			 
92d6			;	push bc 
92d6			;	push de 
92d6			;	push hl 
92d6			;	push af 
92d6			 
92d6 cd 8e 88			call clear_display 
92d9			 
92d9 11 ac 94			ld de, .ptrstate 
92dc 3e 00			ld a, display_row_1 
92de cd a1 88			call str_at_display 
92e1			 
92e1				; display debug step 
92e1			 
92e1			 
92e1 11 c0 ee			ld de, debug_mark 
92e4 3e 12			ld a, display_row_1+display_cols-2 
92e6 cd a1 88			call str_at_display 
92e9			 
92e9				; display a 
92e9 11 b6 94			ld de, .ptrcliptr 
92ec 3e 14			ld a, display_row_2 
92ee cd a1 88			call str_at_display 
92f1			 
92f1 f1				pop af 
92f2 2a b1 ec			ld hl,(cli_ptr) 
92f5 3e 1c			ld a, display_row_2+8 
92f7 cd b3 92			call display_word_at 
92fa			 
92fa			 
92fa				; display hl 
92fa			 
92fa			 
92fa 11 be 94			ld de, .ptrclioptr 
92fd 3e 1e			ld a, display_row_2+10 
92ff cd a1 88			call str_at_display 
9302			; 
9302			;	pop hl 
9302 3e 21			ld a, display_row_2+13 
9304 2a af ec			ld hl,(cli_origptr) 
9307 cd b3 92			call display_word_at 
930a			; 
930a			;	 
930a			;	; display de 
930a			 
930a			;	ld de, .regstatede 
930a			;	ld a, display_row_3 
930a			;	call str_at_display 
930a			 
930a			;	pop de 
930a			;	ld h,d 
930a			;	ld l, e 
930a			;	ld a, display_row_3+3 
930a			;	call display_word_at 
930a			 
930a			 
930a				; display bc 
930a			 
930a			;	ld de, .regstatebc 
930a			;	ld a, display_row_3+10 
930a			;	call str_at_display 
930a			 
930a			;	pop bc 
930a			;	ld h,b 
930a			;	ld l, c 
930a			;	ld a, display_row_3+13 
930a			;	call display_word_at 
930a			 
930a			 
930a				; display dsp 
930a			 
930a			;	ld de, .regstatedsp 
930a			;	ld a, display_row_4 
930a			;	call str_at_display 
930a			 
930a				 
930a			;	ld hl,(cli_data_sp) 
930a			;	ld a, display_row_4+4 
930a			;	call display_word_at 
930a			 
930a				; display rsp 
930a			 
930a 11 ed 94			ld de, .regstatersp 
930d 3e 46			ld a, display_row_4+10 
930f cd a1 88			call str_at_display 
9312			 
9312				 
9312 2a 97 ec			ld hl,(cli_ret_sp) 
9315 3e 4a			ld a, display_row_4+14 
9317 cd b3 92			call display_word_at 
931a			 
931a cd b1 88			call update_display 
931d			 
931d cd 0e 88			call delay1s 
9320 cd 0e 88			call delay1s 
9323 cd 0e 88			call delay1s 
9326			 
9326			 
9326 cd 33 98			call next_page_prompt 
9329			 
9329				; restore  
9329			 
9329 f1				pop af 
932a e1				pop hl 
932b c1				pop bc 
932c d1				pop de 
932d c9				ret 
932e			 
932e			break_point_state: 
932e f5				push af 
932f			 
932f				; see if disabled 
932f			 
932f 3a d7 e4			ld a, (os_view_disable) 
9332 fe 2a			cp '*' 
9334 20 02			jr nz, .bpsgo 
9336 f1				pop af 
9337 c9				ret 
9338			 
9338			.bpsgo: 
9338 f1				pop af 
9339 f5				push af 
933a 22 d3 e4			ld (os_view_hl), hl 
933d ed 53 d1 e4		ld (os_view_de), de 
9341 ed 43 cf e4		ld (os_view_bc), bc 
9345 e5				push hl 
9346 6f				ld l, a 
9347 26 00			ld h, 0 
9349 22 d5 e4			ld (os_view_af),hl 
934c			 
934c 21 56 ee				ld hl, display_fb0 
934f 22 61 ed				ld (display_fb_active), hl 
9352 e1				pop hl	 
9353			 
9353 3e 31			ld a, '1' 
9355 fe 2a		.bps1:  cp '*' 
9357 20 03			jr nz, .bps1b 
9359 32 d7 e4			ld (os_view_disable),a 
935c fe 31		.bps1b:  cp '1' 
935e 20 14			jr nz, .bps2 
9360			 
9360				; display reg 
9360			 
9360				 
9360			 
9360 3a d5 e4			ld a, (os_view_af) 
9363 2a d3 e4			ld hl, (os_view_hl) 
9366 ed 5b d1 e4		ld de, (os_view_de) 
936a ed 4b cf e4		ld bc, (os_view_bc) 
936e cd 08 94			call display_reg_state 
9371 c3 f4 93			jp .bpschk 
9374			 
9374 fe 32		.bps2:  cp '2' 
9376 20 08			jr nz, .bps3 
9378				 
9378				; display hl 
9378 2a d3 e4			ld hl, (os_view_hl) 
937b cd f2 94			call display_dump_at_hl 
937e			 
937e 18 74			jr .bpschk 
9380			 
9380 fe 33		.bps3:  cp '3' 
9382 20 08			jr nz, .bps4 
9384			 
9384			        ; display de 
9384 2a d1 e4			ld hl, (os_view_de) 
9387 cd f2 94			call display_dump_at_hl 
938a			 
938a 18 68			jr .bpschk 
938c fe 34		.bps4:  cp '4' 
938e 20 08			jr nz, .bps5 
9390			 
9390			        ; display bc 
9390 2a cf e4			ld hl, (os_view_bc) 
9393 cd f2 94			call display_dump_at_hl 
9396			 
9396 18 5c			jr .bpschk 
9398 fe 35		.bps5:  cp '5' 
939a 20 08		        jr nz, .bps7 
939c			 
939c				; display cur ptr 
939c 2a b1 ec			ld hl, (cli_ptr) 
939f cd f2 94			call display_dump_at_hl 
93a2			 
93a2 18 50			jr .bpschk 
93a4 fe 36		.bps7:  cp '6' 
93a6 20 08			jr nz, .bps8b 
93a8				 
93a8				; display cur orig ptr 
93a8 2a af ec			ld hl, (cli_origptr) 
93ab cd f2 94			call display_dump_at_hl 
93ae 18 44			jr .bpschk 
93b0 fe 37		.bps8b:  cp '7' 
93b2 20 08			jr nz, .bps9 
93b4				 
93b4				; display dsp 
93b4 2a 93 ec			ld hl, (cli_data_sp) 
93b7 cd f2 94			call display_dump_at_hl 
93ba			 
93ba 18 38			jr .bpschk 
93bc fe 39		.bps9:  cp '9' 
93be 20 05			jr nz, .bps8c 
93c0				 
93c0				; display SP 
93c0			;	ld hl, sp 
93c0 cd f2 94			call display_dump_at_hl 
93c3			 
93c3 18 2f			jr .bpschk 
93c5 fe 38		.bps8c:  cp '8' 
93c7 20 08			jr nz, .bps8d 
93c9				 
93c9				; display rsp 
93c9 2a 97 ec			ld hl, (cli_ret_sp) 
93cc cd f2 94			call display_dump_at_hl 
93cf			 
93cf 18 23			jr .bpschk 
93d1 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
93d3 20 05			jr nz, .bps8 
93d5 cd 29 96			call monitor 
93d8			 
93d8 18 1a			jr .bpschk 
93da fe 30		.bps8:  cp '0' 
93dc 20 16			jr nz, .bpschk 
93de			 
93de 21 05 ee				ld hl, display_fb1 
93e1 22 61 ed				ld (display_fb_active), hl 
93e4 cd b1 88				call update_display 
93e7			 
93e7				;ld a, (os_view_af) 
93e7 2a d3 e4			ld hl, (os_view_hl) 
93ea ed 5b d1 e4		ld de, (os_view_de) 
93ee ed 4b cf e4		ld bc, (os_view_bc) 
93f2 f1				pop af 
93f3 c9				ret 
93f4			 
93f4			.bpschk:   
93f4 cd 0e 88			call delay1s 
93f7 3e 4f		ld a,display_row_4 + display_cols - 1 
93f9 11 31 98		        ld de, endprg 
93fc cd a1 88			call str_at_display 
93ff cd b1 88			call update_display 
9402 cd 6f d7			call cin_wait 
9405			 
9405 c3 55 93			jp .bps1 
9408			 
9408			 
9408			display_reg_state: 
9408			 
9408				; to restore afterwards 
9408			 
9408 d5				push de 
9409 c5				push bc 
940a e5				push hl 
940b f5				push af 
940c			 
940c				; for use in here 
940c			 
940c c5				push bc 
940d d5				push de 
940e e5				push hl 
940f f5				push af 
9410			 
9410 cd 8e 88			call clear_display 
9413			 
9413 11 c8 94			ld de, .regstate 
9416 3e 00			ld a, display_row_1 
9418 cd a1 88			call str_at_display 
941b			 
941b				; display debug step 
941b			 
941b			 
941b 11 c0 ee			ld de, debug_mark 
941e 3e 11			ld a, display_row_1+display_cols-3 
9420 cd a1 88			call str_at_display 
9423			 
9423				; display a 
9423 11 e4 94			ld de, .regstatea 
9426 3e 14			ld a, display_row_2 
9428 cd a1 88			call str_at_display 
942b			 
942b e1				pop hl 
942c			;	ld h,0 
942c			;	ld l, a 
942c 3e 17			ld a, display_row_2+3 
942e cd b3 92			call display_word_at 
9431			 
9431			 
9431				; display hl 
9431			 
9431			 
9431 11 d8 94			ld de, .regstatehl 
9434 3e 1e			ld a, display_row_2+10 
9436 cd a1 88			call str_at_display 
9439			 
9439 e1				pop hl 
943a 3e 21			ld a, display_row_2+13 
943c cd b3 92			call display_word_at 
943f			 
943f				 
943f				; display de 
943f			 
943f 11 dc 94			ld de, .regstatede 
9442 3e 28			ld a, display_row_3 
9444 cd a1 88			call str_at_display 
9447			 
9447 e1				pop hl 
9448			;	ld h,d 
9448			;	ld l, e 
9448 3e 2b			ld a, display_row_3+3 
944a cd b3 92			call display_word_at 
944d			 
944d			 
944d				; display bc 
944d			 
944d 11 e0 94			ld de, .regstatebc 
9450 3e 32			ld a, display_row_3+10 
9452 cd a1 88			call str_at_display 
9455			 
9455 e1				pop hl 
9456			;	ld h,b 
9456			;	ld l, c 
9456 3e 35			ld a, display_row_3+13 
9458 cd b3 92			call display_word_at 
945b			 
945b			 
945b				; display dsp 
945b			 
945b 11 e8 94			ld de, .regstatedsp 
945e 3e 3c			ld a, display_row_4 
9460 cd a1 88			call str_at_display 
9463			 
9463				 
9463 2a 93 ec			ld hl,(cli_data_sp) 
9466 3e 40			ld a, display_row_4+4 
9468 cd b3 92			call display_word_at 
946b			 
946b				; display rsp 
946b			 
946b 11 ed 94			ld de, .regstatersp 
946e 3e 46			ld a, display_row_4+10 
9470 cd a1 88			call str_at_display 
9473			 
9473				 
9473 2a 97 ec			ld hl,(cli_ret_sp) 
9476 3e 4a			ld a, display_row_4+14 
9478 cd b3 92			call display_word_at 
947b			 
947b cd b1 88			call update_display 
947e			 
947e			;	call delay1s 
947e			;	call delay1s 
947e			;	call delay1s 
947e			 
947e			 
947e			;	call next_page_prompt 
947e			 
947e				; restore  
947e			 
947e f1				pop af 
947f e1				pop hl 
9480 c1				pop bc 
9481 d1				pop de 
9482 c9				ret 
9483			 
9483 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
9497 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
94ac .. 00		.ptrstate:	db "Ptr State",0 
94b6 .. 00		.ptrcliptr:     db "cli_ptr",0 
94be .. 00		.ptrclioptr:     db "cli_o_ptr",0 
94c8 .. 00		.regstate:	db "Reg State (1/0)",0 
94d8 .. 00		.regstatehl:	db "HL:",0 
94dc .. 00		.regstatede:	db "DE:",0 
94e0 .. 00		.regstatebc:	db "BC:",0 
94e4 .. 00		.regstatea:	db "A :",0 
94e8 .. 00		.regstatedsp:	db "DSP:",0 
94ed .. 00		.regstatersp:	db "RSP:",0 
94f2			 
94f2			display_dump_at_hl: 
94f2 e5				push hl 
94f3 d5				push de 
94f4 c5				push bc 
94f5 f5				push af 
94f6			 
94f6 22 09 e8			ld (os_cur_ptr),hl	 
94f9 cd 8e 88			call clear_display 
94fc cd 3b 97			call dumpcont 
94ff			;	call delay1s 
94ff			;	call next_page_prompt 
94ff			 
94ff			 
94ff f1				pop af 
9500 c1				pop bc 
9501 d1				pop de 
9502 e1				pop hl 
9503 c9				ret 
9504			 
9504			;if ENABLE_BASIC 
9504			;	include "nascombasic.asm" 
9504			;	basic: 
9504			;	include "forth/FORTH.ASM" 
9504			;endif 
9504			 
9504			; eof 
9504			 
9504			 
# End of file firmware_diags.asm
9504			  
9504			  
9504			  
9504			  
9504			; eof  
9504			  
# End of file firmware.asm
9504			 
9504			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9504			;if BASE_KEV  
9504			;baseram: equ 08000h 
9504			;endif 
9504			 
9504			;if BASE_SC114 
9504			;baseram:     equ    endofcode 
9504			;endif 
9504			 
9504			 
9504			; start system 
9504			 
9504			coldstart: 
9504				; set sp 
9504				; di/ei 
9504			 
9504 f3				di 
9505 31 00 f0			ld sp, tos 
9508			;	ei 
9508			 
9508			 
9508				; disable breakpoint by default 
9508			 
9508 3e 2a			ld a,'*' 
950a 32 d7 e4			ld (os_view_disable),a 
950d			 
950d				; init hardware 
950d			 
950d				; init keyboard and screen hardware 
950d			 
950d cd 03 80			call hardware_init 
9510			 
9510			 
9510				; detect if any keys are held down to enable breakpoints at start up 
9510			 
9510 cd 75 d7			call cin  
9513 fe 00			cp 0 
9515 28 03			jr z, .nokeys 
9517			 
9517				;call hardware_diags 
9517 cd 1b 91			call config 
951a			 
951a			;	ld de, .bpen 
951a			;	ld a, display_row_4 
951a			;	call str_at_display 
951a			;	call update_display 
951a			; 
951a			;	ld a,0 
951a			;	ld (os_view_disable),a 
951a			; 
951a			;.bpwait: 
951a			;	call cin 
951a			;	cp 0 
951a			;	jr z, .bpwait 
951a			;	jr .nokeys 
951a			; 
951a			; 
951a			;.bpen:  db "Break points enabled!",0 
951a			 
951a			 
951a			 
951a			 
951a			 
951a			 
951a			.nokeys: 
951a			 
951a			 
951a				 
951a			 
951a			;jp  testkey 
951a			 
951a			;call storage_get_block_0 
951a			; 
951a			;ld hl, 0 
951a			;ld de, store_page 
951a			;call storage_read_block 
951a			 
951a				 
951a			;ld hl, 10 
951a			;ld de, store_page 
951a			;call storage_read_block 
951a			 
951a			 
951a			 
951a			 
951a			 
951a			;stop:	nop 
951a			;	jp stop 
951a			 
951a			 
951a			 
951a			main: 
951a cd 8e 88			call clear_display 
951d cd b1 88			call update_display 
9520			 
9520			 
9520			 
9520			;	call testlcd 
9520			 
9520			 
9520			 
9520 cd f9 9b			call forth_init 
9523			 
9523			 
9523			warmstart: 
9523 cd cf 9b			call forth_warmstart 
9526			 
9526				; run startup word load 
9526			        ; TODO prevent this running at warmstart after crash  
9526			 
9526				if STARTUP_ENABLE 
9526					if STORAGE_SE 
9526						call forth_autoload 
9526					endif 
9526 cd 09 d4				call forth_startup 
9529			 
9529			 
9529				endif 
9529			 
9529				; show free memory after boot 
9529 11 c3 95			ld de, freeram 
952c 3e 00			ld a, display_row_1 
952e cd a1 88			call str_at_display 
9531			 
9531			; Or use heap_size word???? 
9531 21 cc e4			ld hl, heap_end 
9534 11 93 d7			ld de, heap_start 
9537 ed 52			sbc hl, de 
9539 e5				push hl 
953a 7c				ld a,h	         	 
953b 21 eb e7			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
953e cd bc 8d			call hexout 
9541 e1			   	pop hl 
9542			 
9542 7d				ld a,l 
9543 21 ed e7			ld hl, os_word_scratch+2 
9546 cd bc 8d			call hexout 
9549 21 ef e7			ld hl, os_word_scratch+4 
954c 3e 00			ld a, 0 
954e 77				ld (hl),a 
954f 11 eb e7			ld de, os_word_scratch 
9552 3e 0d			ld a, display_row_1 + 13 
9554 cd a1 88			call str_at_display 
9557 cd b1 88			call update_display 
955a			 
955a			 
955a				;call demo 
955a			 
955a			 
955a				; init scratch input area for cli commands 
955a			 
955a 21 0d e8			ld hl, os_cli_cmd 
955d 3e 00			ld a,0 
955f 77				ld (hl),a 
9560 23				inc hl 
9561 77				ld (hl),a 
9562			 
9562 3e 00			ld a,0 
9564 32 0c e9			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
9567			 
9567 32 09 e8			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
956a 32 0a e8			ld (os_cur_ptr+1),a	 
956d			 
956d 32 eb e7			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
9570 32 ec e7			ld (os_word_scratch+1),a	 
9573				 
9573			 
9573				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9573 21 0d e8			ld hl, os_cli_cmd 
9576			 
9576 3e 00			ld a, 0		 ; init cli input 
9578 77				ld (hl), a 
9579 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
957b			cli: 
957b				; show cli prompt 
957b				;push af 
957b				;ld a, 0 
957b				;ld de, prompt 
957b				;call str_at_display 
957b			 
957b				;call update_display 
957b				;pop af 
957b				;inc a 
957b				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
957b 0e 00			ld c, 0 
957d 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
957f 1e 28			ld e, 40 
9581			 
9581 21 0d e8			ld hl, os_cli_cmd 
9584			 
9584				STACKFRAME OFF $fefe $9f9f 
9584				if DEBUG_STACK_IMB 
9584					if OFF 
9584						exx 
9584						ld de, $fefe 
9584						ld a, d 
9584						ld hl, curframe 
9584						call hexout 
9584						ld a, e 
9584						ld hl, curframe+2 
9584						call hexout 
9584						ld hl, $fefe 
9584						push hl 
9584						ld hl, $9f9f 
9584						push hl 
9584						exx 
9584					endif 
9584				endif 
9584			endm 
# End of macro STACKFRAME
9584			 
9584 cd e8 8a			call input_str 
9587			 
9587				STACKFRAMECHK OFF $fefe $9f9f 
9587				if DEBUG_STACK_IMB 
9587					if OFF 
9587						exx 
9587						ld hl, $9f9f 
9587						pop de   ; $9f9f 
9587						call cmp16 
9587						jr nz, .spnosame 
9587						ld hl, $fefe 
9587						pop de   ; $fefe 
9587						call cmp16 
9587						jr z, .spfrsame 
9587						.spnosame: call showsperror 
9587						.spfrsame: nop 
9587						exx 
9587					endif 
9587				endif 
9587			endm 
# End of macro STACKFRAMECHK
9587			 
9587				; copy input to last command 
9587			 
9587 21 0d e8			ld hl, os_cli_cmd 
958a 11 0c e9			ld de, os_last_cmd 
958d 01 ff 00			ld bc, 255 
9590 ed b0			ldir 
9592			 
9592				; wipe current buffer 
9592			 
9592			;	ld a, 0 
9592			;	ld hl, os_cli_cmd 
9592			;	ld de, os_cli_cmd+1 
9592			;	ld bc, 254 
9592			;	ldir 
9592				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
9592			;	call strcpy 
9592			;	ld a, 0 
9592			;	ld (hl), a 
9592			;	inc hl 
9592			;	ld (hl), a 
9592			;	inc hl 
9592			;	ld (hl), a 
9592			 
9592				; switch frame buffer to program  
9592			 
9592 21 05 ee				ld hl, display_fb1 
9595 22 61 ed				ld (display_fb_active), hl 
9598			 
9598			;	nop 
9598				STACKFRAME ON $fbfe $8f9f 
9598				if DEBUG_STACK_IMB 
9598					if ON 
9598						exx 
9598						ld de, $fbfe 
9598						ld a, d 
9598						ld hl, curframe 
9598						call hexout 
9598						ld a, e 
9598						ld hl, curframe+2 
9598						call hexout 
9598						ld hl, $fbfe 
9598						push hl 
9598						ld hl, $8f9f 
9598						push hl 
9598						exx 
9598					endif 
9598				endif 
9598			endm 
# End of macro STACKFRAME
9598				; first time into the parser so pass over the current scratch pad 
9598 21 0d e8			ld hl,os_cli_cmd 
959b				; tokenise the entered statement(s) in HL 
959b cd 72 9c			call forthparse 
959e			        ; exec forth statements in top of return stack 
959e cd b2 9c			call forthexec 
95a1				;call forthexec_cleanup 
95a1			;	call parsenext 
95a1			 
95a1				STACKFRAMECHK ON $fbfe $8f9f 
95a1				if DEBUG_STACK_IMB 
95a1					if ON 
95a1						exx 
95a1						ld hl, $8f9f 
95a1						pop de   ; $8f9f 
95a1						call cmp16 
95a1						jr nz, .spnosame 
95a1						ld hl, $fbfe 
95a1						pop de   ; $fbfe 
95a1						call cmp16 
95a1						jr z, .spfrsame 
95a1						.spnosame: call showsperror 
95a1						.spfrsame: nop 
95a1						exx 
95a1					endif 
95a1				endif 
95a1			endm 
# End of macro STACKFRAMECHK
95a1				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
95a1			 
95a1 3e 3c			ld a, display_row_4 
95a3 11 d5 95			ld de, endprog 
95a6			 
95a6 cd b1 88			call update_display		 
95a9			 
95a9 cd 33 98			call next_page_prompt 
95ac			 
95ac				; switch frame buffer to cli 
95ac			 
95ac 21 56 ee				ld hl, display_fb0 
95af 22 61 ed				ld (display_fb_active), hl 
95b2			 
95b2			 
95b2 cd 8e 88		        call clear_display 
95b5 cd b1 88			call update_display		 
95b8			 
95b8 21 0d e8			ld hl, os_cli_cmd 
95bb			 
95bb 3e 00			ld a, 0		 ; init cli input 
95bd 77				ld (hl), a 
95be			 
95be				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
95be			 
95be				; now on last line 
95be			 
95be				; TODO scroll screen up 
95be			 
95be				; TODO instead just clear screen and place at top of screen 
95be			 
95be			;	ld a, 0 
95be			;	ld (f_cursor_ptr),a 
95be			 
95be				;call clear_display 
95be				;call update_display 
95be			 
95be				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
95be 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
95c0 c3 7b 95			jp cli 
95c3			 
95c3 .. 00		freeram: db "Free bytes: $",0 
95d1 ..			asc: db "1A2F" 
95d5 .. 00		endprog: db "End prog...",0 
95e1			 
95e1			testenter2:   
95e1 21 18 e5			ld hl,scratch+50 
95e4 22 09 e8			ld (os_cur_ptr),hl 
95e7 c3 7b 95			jp cli 
95ea			 
95ea			testenter:  
95ea			 
95ea 21 d1 95			ld hl,asc 
95ed			;	ld a,(hl) 
95ed			;	call nibble2val 
95ed cd 12 8e			call get_byte 
95f0			 
95f0			 
95f0			;	ld a,(hl) 
95f0			;	call atohex 
95f0			 
95f0			;	call fourehexhl 
95f0 32 18 e5			ld (scratch+50),a 
95f3			 
95f3			 
95f3			 
95f3 21 d3 95			ld hl,asc+2 
95f6			;	ld a, (hl) 
95f6			;	call nibble2val 
95f6 cd 12 8e			call get_byte 
95f9			 
95f9			;	call fourehexhl 
95f9 32 1a e5			ld (scratch+52),a 
95fc				 
95fc 21 18 e5			ld hl,scratch+50 
95ff 22 09 e8			ld (os_cur_ptr),hl 
9602 c3 7b 95			jp cli 
9605			 
9605			enter:	 
9605 3a ea e4			ld a,(scratch+4) 
9608 fe 00			cp 0 
960a 28 0c			jr z, .entercont 
960c				; no, not a null term line so has an address to work out.... 
960c			 
960c 21 e8 e4			ld hl,scratch+2 
960f cd 72 8e			call get_word_hl 
9612			 
9612 22 09 e8			ld (os_cur_ptr),hl	 
9615 c3 7b 95			jp cli 
9618			 
9618			 
9618			.entercont:  
9618			 
9618 21 e8 e4			ld hl, scratch+2 
961b cd 12 8e			call get_byte 
961e			 
961e 2a 09 e8		   	ld hl,(os_cur_ptr) 
9621 77					ld (hl),a 
9622 23					inc hl 
9623 22 09 e8				ld (os_cur_ptr),hl 
9626				 
9626			; get byte  
9626			 
9626			 
9626 c3 7b 95			jp cli 
9629			 
9629			 
9629			; basic monitor support 
9629			 
9629			monitor: 
9629				;  
9629 cd 8e 88			call clear_display 
962c 3e 00			ld a, 0 
962e 11 76 96			ld de, .monprompt 
9631 cd a1 88			call str_at_display 
9634 cd b1 88			call update_display 
9637			 
9637				; get a monitor command 
9637			 
9637 0e 00			ld c, 0     ; entry at top left 
9639 16 64			ld d, 100   ; max buffer size 
963b 1e 0f			ld e, 15    ; input scroll area 
963d 3e 00			ld a, 0     ; init string 
963f 21 e4 e6			ld hl, os_input 
9642 77				ld (hl), a 
9643 23				inc hl 
9644 77				ld (hl), a 
9645 21 e4 e6			ld hl, os_input 
9648 3e 01			ld a, 1     ; init string 
964a cd e8 8a			call input_str 
964d			 
964d cd 8e 88		        call clear_display 
9650 cd b1 88			call update_display		 
9653			 
9653 3a e4 e6			ld a, (os_input) 
9656 cd 10 8f			call toUpper 
9659 fe 48		        cp 'H' 
965b 28 6f		        jr z, .monhelp 
965d fe 44			cp 'D'		; dump 
965f ca ed 96			jp z, .mondump	 
9662 fe 43			cp 'C'		; dump 
9664 ca 07 97			jp z, .moncdump	 
9667 fe 4d			cp 'M'		; dump 
9669 ca 78 96			jp z, .moneditstart 
966c fe 55			cp 'U'		; dump 
966e 28 14			jr z, .monedit	 
9670 fe 51			cp 'Q'		; dump 
9672 c8				ret z	 
9673			 
9673			 
9673				; TODO "S" to access symbol by name and not need the address 
9673				; TODO "F" to find a string in memory 
9673			 
9673 c3 29 96			jp monitor 
9676			 
9676 .. 00		.monprompt: db ">", 0 
9678			 
9678			.moneditstart: 
9678				; get starting address 
9678			 
9678 21 e6 e6			ld hl,os_input+2 
967b cd 72 8e			call get_word_hl 
967e			 
967e 22 09 e8			ld (os_cur_ptr),hl	 
9681			 
9681 c3 29 96			jp monitor 
9684			 
9684			.monedit: 
9684				; get byte to load 
9684			 
9684 21 e6 e6			ld hl,os_input+2 
9687 cd 12 8e			call get_byte 
968a			 
968a				; get address to update 
968a 2a 09 e8			ld hl, (os_cur_ptr) 
968d			 
968d				; update byte 
968d			 
968d 77				ld (hl), a 
968e			 
968e				; move to next address and save it 
968e			 
968e 23				inc hl 
968f 22 09 e8			ld (os_cur_ptr),hl	 
9692			 
9692 c3 29 96			jp monitor 
9695			 
9695			 
9695 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
96a9 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
96c5 .. 00		.monhelptext3:  db "Q-Quit",0 
96cc			        
96cc			.monhelp: 
96cc 3e 00			ld a, display_row_1 
96ce 11 95 96		        ld de, .monhelptext1 
96d1			 
96d1 cd a1 88			call str_at_display 
96d4 3e 14			ld a, display_row_2 
96d6 11 a9 96		        ld de, .monhelptext2 
96d9					 
96d9 cd a1 88			call str_at_display 
96dc 3e 28			ld a, display_row_3 
96de 11 c5 96		        ld de, .monhelptext3 
96e1					 
96e1 cd a1 88			call str_at_display 
96e4 cd b1 88			call update_display		 
96e7			 
96e7 cd 33 98			call next_page_prompt 
96ea c3 29 96			jp monitor 
96ed			 
96ed			.mondump:    
96ed 21 e6 e6			ld hl,os_input+2 
96f0 cd 72 8e			call get_word_hl 
96f3			 
96f3 22 09 e8			ld (os_cur_ptr),hl	 
96f6 cd 3b 97			call dumpcont 
96f9 3e 3c			ld a, display_row_4 
96fb 11 d5 95			ld de, endprog 
96fe			 
96fe cd b1 88			call update_display		 
9701			 
9701 cd 33 98			call next_page_prompt 
9704 c3 29 96			jp monitor 
9707			.moncdump: 
9707 cd 3b 97			call dumpcont 
970a 3e 3c			ld a, display_row_4 
970c 11 d5 95			ld de, endprog 
970f			 
970f cd b1 88			call update_display		 
9712			 
9712 cd 33 98			call next_page_prompt 
9715 c3 29 96			jp monitor 
9718			 
9718			 
9718			; TODO symbol access  
9718			 
9718			.symbols:     ;; A list of symbols that can be called up  
9718 56 ee			dw display_fb0 
971a .. 00			db "fb0",0  
971e eb ec		     	dw store_page 
9720 .. 00			db "store_page",0 
972b			 
972b			 
972b			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
972b			 
972b 3a e7 e4			ld a,(scratch+1) 
972e fe 00			cp 0 
9730 28 09			jr z, dumpcont 
9732			 
9732				; no, not a null term line so has an address to work out.... 
9732			 
9732 21 e8 e4			ld hl,scratch+2 
9735 cd 72 8e			call get_word_hl 
9738			 
9738 22 09 e8			ld (os_cur_ptr),hl	 
973b			 
973b			 
973b			 
973b			dumpcont: 
973b			 
973b				; dump bytes at ptr 
973b			 
973b			 
973b 3e 00			ld a, display_row_1 
973d 2a 61 ed			ld hl, (display_fb_active) 
9740 cd bb 8a			call addatohl 
9743 cd 6b 97			call .dumpbyterow 
9746			 
9746 3e 14			ld a, display_row_2 
9748 2a 61 ed			ld hl, (display_fb_active) 
974b cd bb 8a			call addatohl 
974e cd 6b 97			call .dumpbyterow 
9751			 
9751			 
9751 3e 28			ld a, display_row_3 
9753 2a 61 ed			ld hl, (display_fb_active) 
9756 cd bb 8a			call addatohl 
9759 cd 6b 97			call .dumpbyterow 
975c			 
975c 3e 3c			ld a, display_row_4 
975e 2a 61 ed			ld hl, (display_fb_active) 
9761 cd bb 8a			call addatohl 
9764 cd 6b 97			call .dumpbyterow 
9767			 
9767 cd b1 88			call update_display 
976a			;		jp cli 
976a c9				ret 
976b			 
976b			.dumpbyterow: 
976b			 
976b				;push af 
976b			 
976b e5				push hl 
976c			 
976c				; calc where to poke the ascii 
976c			if display_cols == 20 
976c 3e 10			ld a, 16 
976e			else 
976e				ld a, 31 
976e			endif 
976e			 
976e cd bb 8a			call addatohl 
9771 22 eb e7			ld (os_word_scratch),hl  		; save pos for later 
9774			 
9774			 
9774			; display decoding address 
9774 2a 09 e8		   	ld hl,(os_cur_ptr) 
9777			 
9777 7c				ld a,h 
9778 e1				pop hl 
9779 e5				push hl 
977a			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
977a cd bc 8d			call hexout 
977d 2a 09 e8		   	ld hl,(os_cur_ptr) 
9780			 
9780 7d				ld a,l 
9781 e1				pop hl 
9782 23				inc hl 
9783 23				inc hl 
9784 e5				push hl 
9785			;	ld hl, os_word_scratch+2 
9785 cd bc 8d			call hexout 
9788 e1				pop hl 
9789 23				inc hl 
978a 23				inc hl 
978b				;ld hl, os_word_scratch+4 
978b 3e 3a			ld a, ':' 
978d 77				ld (hl),a 
978e 23				inc hl 
978f				;ld a, 0 
978f				;ld (hl),a 
978f				;ld de, os_word_scratch 
978f				;pop af 
978f				;push af 
978f			;		ld a, display_row_2 
978f			;		call str_at_display 
978f			;		call update_display 
978f			 
978f			 
978f			;pop af 
978f			;	add 5 
978f			 
978f			if display_cols == 20 
978f 06 04			ld b, 4 
9791			else 
9791				ld b, 8 
9791			endif	 
9791			 
9791			.dumpbyte: 
9791 c5				push bc 
9792 e5				push hl 
9793			 
9793			 
9793 2a 09 e8		   	ld hl,(os_cur_ptr) 
9796 7e					ld a,(hl) 
9797			 
9797					; poke the ascii to display 
9797 2a eb e7				ld hl,(os_word_scratch) 
979a 77					ld (hl),a 
979b 23					inc hl 
979c 22 eb e7				ld (os_word_scratch),hl 
979f			 
979f					 
979f			 
979f			 
979f e1					pop hl 
97a0 e5					push hl 
97a1			 
97a1 cd bc 8d				call hexout 
97a4			 
97a4					 
97a4 2a 09 e8		   	ld hl,(os_cur_ptr) 
97a7 23				inc hl 
97a8 22 09 e8		   	ld (os_cur_ptr),hl 
97ab			 
97ab e1					pop hl 
97ac 23					inc hl 
97ad 23					inc hl 
97ae 23					inc hl 
97af			 
97af			 
97af			 
97af					;ld a,0 
97af					;ld (os_word_scratch+2),a 
97af					;pop af 
97af					;push af 
97af			 
97af					;ld de, os_word_scratch 
97af					;call str_at_display 
97af			;		call update_display 
97af			;		pop af 
97af c1					pop bc 
97b0 c6 03				add 3 
97b2 10 dd			djnz .dumpbyte 
97b4			 
97b4				 
97b4			 
97b4 c9				ret 
97b5			 
97b5			jump:	 
97b5			 
97b5 21 e8 e4			ld hl,scratch+2 
97b8 cd 72 8e			call get_word_hl 
97bb				;ld hl,(scratch+2) 
97bb				;call fourehexhl 
97bb			 
97bb 22 09 e8			ld (os_cur_ptr),hl	 
97be			 
97be e9				jp (hl) 
97bf			 
97bf			 
97bf			 
97bf			; TODO implement a basic monitor mode to start with 
97bf			 
97bf			 
97bf			 
97bf			 
97bf			 
97bf			 
97bf			 
97bf			 
97bf			 
97bf			; testing and demo code during development 
97bf			 
97bf			 
97bf .. 00		str1: db "Enter some text...",0 
97d2 .. 00		clear: db "                    ",0 
97e7			 
97e7			demo: 
97e7			 
97e7			 
97e7			 
97e7			;	call update_display 
97e7			 
97e7				; init scratch input area for testing 
97e7 21 e6 e4			ld hl, scratch	 
97ea 3e 00			ld a,0 
97ec 77				ld (hl),a 
97ed			 
97ed			 
97ed 3e 14		            LD   A, display_row_2 
97ef			;            CALL fLCD_Pos       ;Position cursor to location in A 
97ef 11 bf 97		            LD   DE, str1 
97f2 cd a1 88			call str_at_display 
97f5			 
97f5			;            CALL fLCD_Str       ;Display string pointed to by DE 
97f5			cloop:	 
97f5 3e 28		            LD   A, display_row_3 
97f7			;            CALL fLCD_Pos       ;Position cursor to location in A 
97f7 11 d2 97		            LD   DE, clear 
97fa			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
97fa cd a1 88				call str_at_display 
97fd 3e 3c			ld a, display_row_4 
97ff 11 2f 98			ld de, prompt 
9802			 
9802 cd a1 88				call str_at_display 
9805 cd b1 88			call update_display 
9808			 
9808 3e 3d			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
980a 16 0a			ld d, 10 
980c 21 e6 e4			ld hl, scratch	 
980f cd e8 8a			call input_str 
9812			 
9812			;	call clear_display 
9812			;'	call update_display 
9812			 
9812 3e 00		            LD   A, display_row_1 
9814			;            CALL fLCD_Pos       ;Position cursor to location in A 
9814 11 d2 97		            LD   DE, clear 
9817 cd a1 88				call str_at_display 
981a			;            CALL fLCD_Str       ;Display string pointed to by DE 
981a 3e 00		            LD   A, display_row_1 
981c			;            CALL fLCD_Pos       ;Position cursor to location in A 
981c 11 e6 e4		            LD   DE, scratch 
981f			;            CALL fLCD_Str       ;Display string pointed to by DE 
981f cd a1 88				call str_at_display 
9822 cd b1 88			call update_display 
9825			 
9825 3e 00				ld a,0 
9827 21 e6 e4			ld hl, scratch 
982a 77				ld (hl),a 
982b			 
982b 00				nop 
982c c3 f5 97			jp cloop 
982f			 
982f			 
982f			 
982f			; OS Prompt 
982f			 
982f .. 00		prompt: db ">",0 
9831 .. 00		endprg: db "?",0 
9833			 
9833			 
9833			; handy next page prompt 
9833			next_page_prompt: 
9833 e5				push hl 
9834 d5				push de 
9835 f5				push af 
9836 c5				push bc 
9837			 
9837 3e 4f			ld a,display_row_4 + display_cols - 1 
9839 11 31 98		        ld de, endprg 
983c cd a1 88			call str_at_display 
983f cd b1 88			call update_display 
9842 cd 6f d7			call cin_wait 
9845 c1				pop bc 
9846 f1				pop af 
9847 d1				pop de 
9848 e1				pop hl 
9849			 
9849			 
9849 c9				ret 
984a			 
984a			 
984a			; forth parser 
984a			 
984a			; My forth kernel 
984a			include "forth_kernel.asm" 
984a			; 
984a			; kernel to the forth OS 
984a			 
984a			DS_TYPE_STR: equ 1     ; string type 
984a			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
984a			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
984a			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
984a			 
984a			FORTH_PARSEV1: equ 0 
984a			FORTH_PARSEV2: equ 0 
984a			FORTH_PARSEV3: equ 0 
984a			FORTH_PARSEV4: equ 0 
984a			FORTH_PARSEV5: equ 1 
984a			 
984a			;if FORTH_PARSEV5 
984a			;	FORTH_END_BUFFER: equ 0 
984a			;else 
984a			FORTH_END_BUFFER: equ 127 
984a			;endif 
984a			 
984a			FORTH_TRUE: equ 1 
984a			FORTH_FALSE: equ 0 
984a			 
984a			if FORTH_PARSEV4 
984a			include "forth_stackops.asm" 
984a			endif 
984a			 
984a			if FORTH_PARSEV5 
984a			include "forth_stackopsv5.asm" 
984a			 
984a			; Stack operations for v5 parser on wards 
984a			; * DATA stack 
984a			; * LOOP stack 
984a			; * RETURN stack 
984a			 
984a			 
984a			 
984a			FORTH_CHK_DSP_UNDER: macro 
984a				push hl 
984a				push de 
984a				ld hl,(cli_data_sp) 
984a				ld de, cli_data_stack 
984a				call cmp16 
984a				jp c, fault_dsp_under 
984a				pop de 
984a				pop hl 
984a				endm 
984a			 
984a			 
984a			FORTH_CHK_RSP_UNDER: macro 
984a				push hl 
984a				push de 
984a				ld hl,(cli_ret_sp) 
984a				ld de, cli_ret_stack 
984a				call cmp16 
984a				jp c, fault_rsp_under 
984a				pop de 
984a				pop hl 
984a				endm 
984a			 
984a			FORTH_CHK_LOOP_UNDER: macro 
984a				push hl 
984a				push de 
984a				ld hl,(cli_loop_sp) 
984a				ld de, cli_loop_stack 
984a				call cmp16 
984a				jp c, fault_loop_under 
984a				pop de 
984a				pop hl 
984a				endm 
984a			 
984a			FORTH_ERR_TOS_NOTSTR: macro 
984a				; TOSO might need more for checks when used 
984a				push af 
984a				ld a,(hl) 
984a				cp DS_TYPE_STR 
984a				jp nz, type_faultn   
984a				pop af 
984a				endm 
984a			 
984a			FORTH_ERR_TOS_NOTNUM: macro 
984a				push af 
984a				ld a,(hl) 
984a				cp DS_TYPE_INUM 
984a				jp nz, type_faultn   
984a				pop af 
984a				endm 
984a			 
984a			 
984a			; increase data stack pointer and save hl to it 
984a				 
984a			FORTH_DSP_NEXT: macro 
984a				call macro_forth_dsp_next 
984a				endm 
984a			 
984a			 
984a			macro_forth_dsp_next: 
984a				if DEBUG_FORTH_STACK_GUARD 
984a cd d3 d4				call check_stacks 
984d				endif 
984d e5				push hl 
984e d5				push de 
984f eb				ex de,hl 
9850 2a 93 ec			ld hl,(cli_data_sp) 
9853 23				inc hl 
9854 23				inc hl 
9855			 
9855			; PARSEV5 
9855 23				inc hl 
9856 22 93 ec			ld (cli_data_sp),hl 
9859 73				ld (hl), e 
985a 23				inc hl 
985b 72				ld (hl), d 
985c d1				pop de 
985d e1				pop hl 
985e				if DEBUG_FORTH_STACK_GUARD 
985e cd d3 d4				call check_stacks 
9861				endif 
9861 c9				ret 
9862			 
9862			 
9862			; increase ret stack pointer and save hl to it 
9862				 
9862			FORTH_RSP_NEXT: macro 
9862				call macro_forth_rsp_next 
9862				endm 
9862			 
9862			macro_forth_rsp_next: 
9862				if DEBUG_FORTH_STACK_GUARD 
9862 cd d3 d4				call check_stacks 
9865				endif 
9865 e5				push hl 
9866 d5				push de 
9867 eb				ex de,hl 
9868 2a 97 ec			ld hl,(cli_ret_sp) 
986b 23				inc hl 
986c 23				inc hl 
986d 22 97 ec			ld (cli_ret_sp),hl 
9870 73				ld (hl), e 
9871 23				inc hl 
9872 72				ld (hl), d 
9873 d1				pop de 
9874 e1				pop hl 
9875				if DEBUG_FORTH_STACK_GUARD 
9875 cd d3 d4				call check_stacks 
9878				endif 
9878 c9				ret 
9879			 
9879			; get current ret stack pointer and save to hl  
9879				 
9879			FORTH_RSP_TOS: macro 
9879				call macro_forth_rsp_tos 
9879				endm 
9879			 
9879			macro_forth_rsp_tos: 
9879				;push de 
9879 2a 97 ec			ld hl,(cli_ret_sp) 
987c cd b4 98			call loadhlptrtohl 
987f				;ld e, (hl) 
987f				;inc hl 
987f				;ld d, (hl) 
987f				;ex de, hl 
987f					if DEBUG_FORTH_WORDS 
987f			;			DMARK "RST" 
987f						CALLMONITOR 
987f cd 2e 93			call break_point_state  
9882				endm  
# End of macro CALLMONITOR
9882					endif 
9882				;pop de 
9882 c9				ret 
9883			 
9883			; pop ret stack pointer 
9883				 
9883			FORTH_RSP_POP: macro 
9883				call macro_forth_rsp_pop 
9883				endm 
9883			 
9883			 
9883			macro_forth_rsp_pop: 
9883				if DEBUG_FORTH_STACK_GUARD 
9883			;		DMARK "RPP" 
9883 cd d3 d4				call check_stacks 
9886					FORTH_CHK_RSP_UNDER 
9886 e5				push hl 
9887 d5				push de 
9888 2a 97 ec			ld hl,(cli_ret_sp) 
988b 11 51 ec			ld de, cli_ret_stack 
988e cd d9 8a			call cmp16 
9891 da e7 d5			jp c, fault_rsp_under 
9894 d1				pop de 
9895 e1				pop hl 
9896				endm 
# End of macro FORTH_CHK_RSP_UNDER
9896				endif 
9896 e5				push hl 
9897 2a 97 ec			ld hl,(cli_ret_sp) 
989a			 
989a			 
989a				if FORTH_ENABLE_FREE 
989a			 
989a					; get pointer 
989a			 
989a					push de 
989a					push hl 
989a			 
989a					ld e, (hl) 
989a					inc hl 
989a					ld d, (hl) 
989a			 
989a					ex de, hl 
989a					call free 
989a			 
989a					pop hl 
989a					pop de 
989a			 
989a			 
989a				endif 
989a			 
989a			 
989a 2b				dec hl 
989b 2b				dec hl 
989c 22 97 ec			ld (cli_ret_sp), hl 
989f				; do stack underflow checks 
989f e1				pop hl 
98a0				if DEBUG_FORTH_STACK_GUARD 
98a0 cd d3 d4				call check_stacks 
98a3					FORTH_CHK_RSP_UNDER 
98a3 e5				push hl 
98a4 d5				push de 
98a5 2a 97 ec			ld hl,(cli_ret_sp) 
98a8 11 51 ec			ld de, cli_ret_stack 
98ab cd d9 8a			call cmp16 
98ae da e7 d5			jp c, fault_rsp_under 
98b1 d1				pop de 
98b2 e1				pop hl 
98b3				endm 
# End of macro FORTH_CHK_RSP_UNDER
98b3				endif 
98b3 c9				ret 
98b4			 
98b4			 
98b4			 
98b4			; routine to load word pointed to by hl into hl 
98b4			 
98b4			loadhlptrtohl: 
98b4			 
98b4 d5				push de 
98b5 5e				ld e, (hl) 
98b6 23				inc hl 
98b7 56				ld d, (hl) 
98b8 eb				ex de, hl 
98b9 d1				pop de 
98ba			 
98ba c9				ret 
98bb			 
98bb			 
98bb			 
98bb			 
98bb			 
98bb			; push a number held in HL onto the data stack 
98bb			; entry point for pushing a value when already in hl used in function above 
98bb			 
98bb			forth_push_numhl: 
98bb			 
98bb e5				push hl    ; save value to push 
98bc			 
98bc			if DEBUG_FORTH_PUSH 
98bc				; see if disabled 
98bc			 
98bc			 
98bc f5				push af 
98bd 3a d7 e4			ld a, (os_view_disable) 
98c0 fe 2a			cp '*' 
98c2 28 34			jr z, .pskip2 
98c4 e5				push hl 
98c5 e5			push hl 
98c6 cd 8e 88			call clear_display 
98c9 e1			pop hl 
98ca 7c				ld a,h 
98cb 21 eb e7			ld hl, os_word_scratch 
98ce cd bc 8d			call hexout 
98d1 e1				pop hl 
98d2 7d				ld a,l 
98d3 21 ed e7			ld hl, os_word_scratch+2 
98d6 cd bc 8d			call hexout 
98d9			 
98d9 21 ef e7			ld hl, os_word_scratch+4 
98dc 3e 00			ld a,0 
98de 77				ld (hl),a 
98df 11 eb e7			ld de,os_word_scratch 
98e2 3e 14				ld a, display_row_2 
98e4 cd a1 88				call str_at_display 
98e7 11 e1 c3			ld de, .push_num 
98ea 3e 00			ld a, display_row_1 
98ec			 
98ec cd a1 88				call str_at_display 
98ef			 
98ef			 
98ef cd b1 88			call update_display 
98f2 cd 0e 88			call delay1s 
98f5 cd 0e 88			call delay1s 
98f8			.pskip2:  
98f8			 
98f8 f1				pop af 
98f9			endif	 
98f9			 
98f9			 
98f9				FORTH_DSP_NEXT 
98f9 cd 4a 98			call macro_forth_dsp_next 
98fc				endm 
# End of macro FORTH_DSP_NEXT
98fc			 
98fc 2a 93 ec			ld hl, (cli_data_sp) 
98ff			 
98ff				; save item type 
98ff 3e 02			ld a,  DS_TYPE_INUM 
9901 77				ld (hl), a 
9902 23				inc hl 
9903			 
9903				; get word off stack 
9903 d1				pop de 
9904 7b				ld a,e 
9905 77				ld (hl), a 
9906 23				inc hl 
9907 7a				ld a,d 
9908 77				ld (hl), a 
9909			 
9909			if DEBUG_FORTH_PUSH 
9909 2b				dec hl 
990a 2b				dec hl 
990b 2b				dec hl 
990c						DMARK "PH5" 
990c f5				push af  
990d 3a 21 99			ld a, (.dmark)  
9910 32 c0 ee			ld (debug_mark),a  
9913 3a 22 99			ld a, (.dmark+1)  
9916 32 c1 ee			ld (debug_mark+1),a  
9919 3a 23 99			ld a, (.dmark+2)  
991c 32 c2 ee			ld (debug_mark+2),a  
991f 18 03			jr .pastdmark  
9921 ..			.dmark: db "PH5"  
9924 f1			.pastdmark: pop af  
9925			endm  
# End of macro DMARK
9925				CALLMONITOR 
9925 cd 2e 93			call break_point_state  
9928				endm  
# End of macro CALLMONITOR
9928			endif	 
9928			 
9928 c9				ret 
9929			 
9929			 
9929			; Push a string to stack pointed to by hl 
9929			 
9929			forth_push_str: 
9929			 
9929			if DEBUG_FORTH_PUSH 
9929						DMARK "PSQ" 
9929 f5				push af  
992a 3a 3e 99			ld a, (.dmark)  
992d 32 c0 ee			ld (debug_mark),a  
9930 3a 3f 99			ld a, (.dmark+1)  
9933 32 c1 ee			ld (debug_mark+1),a  
9936 3a 40 99			ld a, (.dmark+2)  
9939 32 c2 ee			ld (debug_mark+2),a  
993c 18 03			jr .pastdmark  
993e ..			.dmark: db "PSQ"  
9941 f1			.pastdmark: pop af  
9942			endm  
# End of macro DMARK
9942				CALLMONITOR 
9942 cd 2e 93			call break_point_state  
9945				endm  
# End of macro CALLMONITOR
9945			endif	 
9945			    
9945 e5				push hl 
9946 e5				push hl 
9947			 
9947			;	ld a, 0   ; find end of string 
9947 cd 19 8f			call strlenz 
994a			if DEBUG_FORTH_PUSH 
994a						DMARK "PQ2" 
994a f5				push af  
994b 3a 5f 99			ld a, (.dmark)  
994e 32 c0 ee			ld (debug_mark),a  
9951 3a 60 99			ld a, (.dmark+1)  
9954 32 c1 ee			ld (debug_mark+1),a  
9957 3a 61 99			ld a, (.dmark+2)  
995a 32 c2 ee			ld (debug_mark+2),a  
995d 18 03			jr .pastdmark  
995f ..			.dmark: db "PQ2"  
9962 f1			.pastdmark: pop af  
9963			endm  
# End of macro DMARK
9963				CALLMONITOR 
9963 cd 2e 93			call break_point_state  
9966				endm  
# End of macro CALLMONITOR
9966			endif	 
9966 eb				ex de, hl 
9967 e1				pop hl   ; get ptr to start of string 
9968			if DEBUG_FORTH_PUSH 
9968						DMARK "PQ3" 
9968 f5				push af  
9969 3a 7d 99			ld a, (.dmark)  
996c 32 c0 ee			ld (debug_mark),a  
996f 3a 7e 99			ld a, (.dmark+1)  
9972 32 c1 ee			ld (debug_mark+1),a  
9975 3a 7f 99			ld a, (.dmark+2)  
9978 32 c2 ee			ld (debug_mark+2),a  
997b 18 03			jr .pastdmark  
997d ..			.dmark: db "PQ3"  
9980 f1			.pastdmark: pop af  
9981			endm  
# End of macro DMARK
9981				CALLMONITOR 
9981 cd 2e 93			call break_point_state  
9984				endm  
# End of macro CALLMONITOR
9984			endif	 
9984 19				add hl,de 
9985			if DEBUG_FORTH_PUSH 
9985						DMARK "PQE" 
9985 f5				push af  
9986 3a 9a 99			ld a, (.dmark)  
9989 32 c0 ee			ld (debug_mark),a  
998c 3a 9b 99			ld a, (.dmark+1)  
998f 32 c1 ee			ld (debug_mark+1),a  
9992 3a 9c 99			ld a, (.dmark+2)  
9995 32 c2 ee			ld (debug_mark+2),a  
9998 18 03			jr .pastdmark  
999a ..			.dmark: db "PQE"  
999d f1			.pastdmark: pop af  
999e			endm  
# End of macro DMARK
999e				CALLMONITOR 
999e cd 2e 93			call break_point_state  
99a1				endm  
# End of macro CALLMONITOR
99a1			endif	 
99a1			 
99a1 2b				dec hl    ; see if there is an optional trailing double quote 
99a2 7e				ld a,(hl) 
99a3 fe 22			cp '"' 
99a5 20 03			jr nz, .strnoq 
99a7 3e 00			ld a, 0      ; get rid of double quote 
99a9 77				ld (hl), a 
99aa 23			.strnoq: inc hl 
99ab			 
99ab 3e 00			ld a, 0 
99ad 77				ld (hl), a     ; add null term and get rid of trailing double quote 
99ae			 
99ae 13				inc de ; add one for the type string 
99af 13				inc de ; add one for null term??? 
99b0			 
99b0				; tos is get string pointer again 
99b0				; de contains space to allocate 
99b0				 
99b0 d5				push de 
99b1			 
99b1 eb				ex de, hl 
99b2			 
99b2				;push af 
99b2			 
99b2			if DEBUG_FORTH_PUSH 
99b2						DMARK "PHm" 
99b2 f5				push af  
99b3 3a c7 99			ld a, (.dmark)  
99b6 32 c0 ee			ld (debug_mark),a  
99b9 3a c8 99			ld a, (.dmark+1)  
99bc 32 c1 ee			ld (debug_mark+1),a  
99bf 3a c9 99			ld a, (.dmark+2)  
99c2 32 c2 ee			ld (debug_mark+2),a  
99c5 18 03			jr .pastdmark  
99c7 ..			.dmark: db "PHm"  
99ca f1			.pastdmark: pop af  
99cb			endm  
# End of macro DMARK
99cb				CALLMONITOR 
99cb cd 2e 93			call break_point_state  
99ce				endm  
# End of macro CALLMONITOR
99ce			endif	 
99ce cd 82 8f			call malloc	; on ret hl now contains allocated memory 
99d1				if DEBUG_FORTH_MALLOC_GUARD 
99d1 cc 39 c4				call z,malloc_error 
99d4				endif 
99d4			 
99d4				 
99d4 c1				pop bc    ; get length 
99d5 d1				pop de   ;  get string start    
99d6			 
99d6				; hl has destination from malloc 
99d6			 
99d6 eb				ex de, hl    ; prep for ldir 
99d7			 
99d7 d5				push de   ; save malloc area for DSP later 
99d8				;push hl   ; save malloc area for DSP later 
99d8			 
99d8			if DEBUG_FORTH_PUSH 
99d8						DMARK "PHc" 
99d8 f5				push af  
99d9 3a ed 99			ld a, (.dmark)  
99dc 32 c0 ee			ld (debug_mark),a  
99df 3a ee 99			ld a, (.dmark+1)  
99e2 32 c1 ee			ld (debug_mark+1),a  
99e5 3a ef 99			ld a, (.dmark+2)  
99e8 32 c2 ee			ld (debug_mark+2),a  
99eb 18 03			jr .pastdmark  
99ed ..			.dmark: db "PHc"  
99f0 f1			.pastdmark: pop af  
99f1			endm  
# End of macro DMARK
99f1				CALLMONITOR 
99f1 cd 2e 93			call break_point_state  
99f4				endm  
# End of macro CALLMONITOR
99f4			endif	 
99f4			 
99f4			 
99f4 ed b0			ldir 
99f6			 
99f6			 
99f6				; push malloc to data stack     macro?????  
99f6			 
99f6				FORTH_DSP_NEXT 
99f6 cd 4a 98			call macro_forth_dsp_next 
99f9				endm 
# End of macro FORTH_DSP_NEXT
99f9			 
99f9				; save value and type 
99f9			 
99f9 2a 93 ec			ld hl, (cli_data_sp) 
99fc			 
99fc				; save item type 
99fc 3e 01			ld a,  DS_TYPE_STR 
99fe 77				ld (hl), a 
99ff 23				inc hl 
9a00			 
9a00				; get malloc word off stack 
9a00 d1				pop de 
9a01 73				ld (hl), e 
9a02 23				inc hl 
9a03 72				ld (hl), d 
9a04			 
9a04			 
9a04			 
9a04			if DEBUG_FORTH_PUSH 
9a04 2a 93 ec			ld hl, (cli_data_sp) 
9a07						DMARK "PHS" 
9a07 f5				push af  
9a08 3a 1c 9a			ld a, (.dmark)  
9a0b 32 c0 ee			ld (debug_mark),a  
9a0e 3a 1d 9a			ld a, (.dmark+1)  
9a11 32 c1 ee			ld (debug_mark+1),a  
9a14 3a 1e 9a			ld a, (.dmark+2)  
9a17 32 c2 ee			ld (debug_mark+2),a  
9a1a 18 03			jr .pastdmark  
9a1c ..			.dmark: db "PHS"  
9a1f f1			.pastdmark: pop af  
9a20			endm  
# End of macro DMARK
9a20				CALLMONITOR 
9a20 cd 2e 93			call break_point_state  
9a23				endm  
# End of macro CALLMONITOR
9a23			;	ex de,hl 
9a23			endif	 
9a23				; in case of spaces, skip the ptr past the copied string 
9a23				;pop af 
9a23				;ld (cli_origptr),hl 
9a23			 
9a23 c9				ret 
9a24			 
9a24			 
9a24			 
9a24			; TODO ascii push input onto stack given hl to start of input 
9a24			 
9a24			; identify type 
9a24			; if starts with a " then a string 
9a24			; otherwise it is a number 
9a24			;  
9a24			; if a string 
9a24			;     scan for ending " to get length of string to malloc for + 1 
9a24			;     malloc 
9a24			;     put pointer to string on stack first byte flags as string 
9a24			; 
9a24			; else a number 
9a24			;    look for number format identifier 
9a24			;    $xx hex 
9a24			;    %xxxxx bin 
9a24			;    xxxxx decimal 
9a24			;    convert number to 16bit word.  
9a24			;    malloc word + 1 with flag to identiy as num 
9a24			;    put pointer to number on stack 
9a24			;   
9a24			;  
9a24			  
9a24			forth_apush: 
9a24				; kernel push 
9a24			 
9a24			if DEBUG_FORTH_PUSH 
9a24						DMARK "PSH" 
9a24 f5				push af  
9a25 3a 39 9a			ld a, (.dmark)  
9a28 32 c0 ee			ld (debug_mark),a  
9a2b 3a 3a 9a			ld a, (.dmark+1)  
9a2e 32 c1 ee			ld (debug_mark+1),a  
9a31 3a 3b 9a			ld a, (.dmark+2)  
9a34 32 c2 ee			ld (debug_mark+2),a  
9a37 18 03			jr .pastdmark  
9a39 ..			.dmark: db "PSH"  
9a3c f1			.pastdmark: pop af  
9a3d			endm  
# End of macro DMARK
9a3d				CALLMONITOR 
9a3d cd 2e 93			call break_point_state  
9a40				endm  
# End of macro CALLMONITOR
9a40			endif	 
9a40				; identify input type 
9a40			 
9a40 7e				ld a,(hl) 
9a41 fe 22			cp '"' 
9a43 28 0a			jr z, .fapstr 
9a45 fe 24			cp '$' 
9a47 ca 6f 9a			jp z, .faphex 
9a4a fe 25			cp '%' 
9a4c ca 57 9a			jp z, .fapbin 
9a4f			;	cp 'b' 
9a4f			;	jp z, .fabin 
9a4f				; else decimal 
9a4f			 
9a4f				; TODO do decimal conversion 
9a4f				; decimal is stored as a 16bit word 
9a4f			 
9a4f				; by default everything is a string if type is not detected 
9a4f			.fapstr: ; 
9a4f fe 22			cp '"' 
9a51 20 01			jr nz, .strnoqu 
9a53 23				inc hl 
9a54			.strnoqu: 
9a54 c3 29 99			jp forth_push_str 
9a57			 
9a57			 
9a57			 
9a57			.fapbin:    ; push a binary string.  
9a57 11 00 00			ld de, 0   ; hold a 16bit value 
9a5a			 
9a5a 23			.fapbinshift:	inc hl  
9a5b 7e				ld a,(hl) 
9a5c fe 00			cp 0     ; done scanning  
9a5e 28 0b			jr z, .fapbdone  	; got it in HL so push  
9a60			 
9a60				; left shift de 
9a60 eb				ex de, hl	 
9a61 29				add hl, hl 
9a62			 
9a62				; is 1 
9a62 fe 31			cp '1' 
9a64 20 02			jr nz, .binzero 
9a66 cb 4d			bit 1, l 
9a68			.binzero: 
9a68 eb				ex de, hl	 ; save current de 
9a69 18 ef			jr .fapbinshift 
9a6b			 
9a6b			.fapbdone: 
9a6b eb				ex de, hl 
9a6c c3 bb 98			jp forth_push_numhl 
9a6f			 
9a6f			 
9a6f			.faphex:   ; hex is always stored as a 16bit word 
9a6f				; skip number prefix 
9a6f 23				inc hl 
9a70				; turn ascii into number 
9a70 cd 72 8e			call get_word_hl	; ret 16bit word in hl 
9a73			 
9a73 c3 bb 98			jp forth_push_numhl 
9a76			 
9a76 00				 nop 
9a77			 
9a77			.fabin:   ; TODO bin conversion 
9a77			 
9a77			 
9a77 c9				ret 
9a78			 
9a78			 
9a78			; get either a string ptr or a 16bit word from the data stack 
9a78			 
9a78			FORTH_DSP: macro 
9a78				call macro_forth_dsp 
9a78				endm 
9a78			 
9a78			macro_forth_dsp: 
9a78				; data stack pointer points to current word on tos 
9a78			 
9a78 2a 93 ec			ld hl,(cli_data_sp) 
9a7b			 
9a7b				if DEBUG_FORTH_PUSH 
9a7b						DMARK "DSP" 
9a7b f5				push af  
9a7c 3a 90 9a			ld a, (.dmark)  
9a7f 32 c0 ee			ld (debug_mark),a  
9a82 3a 91 9a			ld a, (.dmark+1)  
9a85 32 c1 ee			ld (debug_mark+1),a  
9a88 3a 92 9a			ld a, (.dmark+2)  
9a8b 32 c2 ee			ld (debug_mark+2),a  
9a8e 18 03			jr .pastdmark  
9a90 ..			.dmark: db "DSP"  
9a93 f1			.pastdmark: pop af  
9a94			endm  
# End of macro DMARK
9a94			 
9a94 cd 6e c4				call display_data_sp 
9a97				;call break_point_state 
9a97				;rst 030h 
9a97				CALLMONITOR 
9a97 cd 2e 93			call break_point_state  
9a9a				endm  
# End of macro CALLMONITOR
9a9a				endif 
9a9a			 
9a9a c9				ret 
9a9b			 
9a9b			; return hl to start of value on stack 
9a9b			 
9a9b			FORTH_DSP_VALUE: macro 
9a9b				call macro_forth_dsp_value 
9a9b				endm 
9a9b			 
9a9b			macro_forth_dsp_value: 
9a9b			 
9a9b				FORTH_DSP 
9a9b cd 78 9a			call macro_forth_dsp 
9a9e				endm 
# End of macro FORTH_DSP
9a9e			 
9a9e d5				push de 
9a9f			 
9a9f 23				inc hl ; skip type 
9aa0			 
9aa0 5e				ld e, (hl) 
9aa1 23				inc hl 
9aa2 56				ld d, (hl) 
9aa3 eb				ex de,hl  
9aa4			 
9aa4 d1				pop de 
9aa5			 
9aa5 c9				ret 
9aa6			 
9aa6			; return hl to start of value to second item on stack 
9aa6			 
9aa6			FORTH_DSP_VALUEM1: macro 
9aa6				call macro_forth_dsp_value_m1 
9aa6				endm 
9aa6			 
9aa6			macro_forth_dsp_value_m1: 
9aa6			 
9aa6				FORTH_DSP 
9aa6 cd 78 9a			call macro_forth_dsp 
9aa9				endm 
# End of macro FORTH_DSP
9aa9			 
9aa9 2b				dec hl 
9aaa 2b				dec hl 
9aab			;	dec hl 
9aab			 
9aab d5				push de 
9aac			 
9aac 5e				ld e, (hl) 
9aad 23				inc hl 
9aae 56				ld d, (hl) 
9aaf eb				ex de,hl  
9ab0			 
9ab0 d1				pop de 
9ab1			 
9ab1 c9				ret 
9ab2			 
9ab2				 
9ab2			 
9ab2			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9ab2			 
9ab2			FORTH_DSP_POP: macro 
9ab2				call macro_forth_dsp_pop 
9ab2				endm 
9ab2			 
9ab2			 
9ab2			; get the tos data type 
9ab2			 
9ab2			FORTH_DSP_TYPE:   macro 
9ab2			 
9ab2				;FORTH_DSP_VALUE 
9ab2				FORTH_DSP 
9ab2				 
9ab2				; hl points to value 
9ab2				; check type 
9ab2			 
9ab2				ld a,(hl) 
9ab2			 
9ab2				endm 
9ab2			 
9ab2			; load the tos value into hl 
9ab2			 
9ab2			 
9ab2			FORTH_DSP_VALUEHL:  macro 
9ab2				call macro_dsp_valuehl 
9ab2				endm 
9ab2			 
9ab2			 
9ab2			 
9ab2			macro_dsp_valuehl: 
9ab2				FORTH_DSP_VALUE 
9ab2 cd 9b 9a			call macro_forth_dsp_value 
9ab5				endm 
# End of macro FORTH_DSP_VALUE
9ab5			 
9ab5				;FORTH_ERR_TOS_NOTNUM 
9ab5			 
9ab5				;inc hl   ; skip type id 
9ab5			 
9ab5			;	push de 
9ab5			; 
9ab5			;	ld e, (hl) 
9ab5			;	inc hl 
9ab5			;	ld d, (hl) 
9ab5			;	ex de,hl  
9ab5			 
9ab5			;	pop de 
9ab5			 
9ab5				if DEBUG_FORTH_PUSH 
9ab5						DMARK "DVL" 
9ab5 f5				push af  
9ab6 3a ca 9a			ld a, (.dmark)  
9ab9 32 c0 ee			ld (debug_mark),a  
9abc 3a cb 9a			ld a, (.dmark+1)  
9abf 32 c1 ee			ld (debug_mark+1),a  
9ac2 3a cc 9a			ld a, (.dmark+2)  
9ac5 32 c2 ee			ld (debug_mark+2),a  
9ac8 18 03			jr .pastdmark  
9aca ..			.dmark: db "DVL"  
9acd f1			.pastdmark: pop af  
9ace			endm  
# End of macro DMARK
9ace				CALLMONITOR 
9ace cd 2e 93			call break_point_state  
9ad1				endm  
# End of macro CALLMONITOR
9ad1				endif 
9ad1 c9				ret 
9ad2			 
9ad2			forth_apushstrhl:      
9ad2				; push of string requires use of cli_origptr 
9ad2				; bodge use 
9ad2			 
9ad2				; get current cli_origptr, save, update with temp pointer  
9ad2 ed 5b af ec		ld de, (cli_origptr) 
9ad6 22 af ec			ld (cli_origptr), hl 
9ad9 d5				push de 
9ada cd 24 9a			call forth_apush 
9add d1				pop de 
9ade ed 53 af ec		ld (cli_origptr), de 
9ae2 c9			        ret	 
9ae3			 
9ae3			 
9ae3			; increase loop stack pointer and save hl to it 
9ae3				 
9ae3			FORTH_LOOP_NEXT: macro 
9ae3				call macro_forth_loop_next 
9ae3				;nop 
9ae3				endm 
9ae3			 
9ae3			macro_forth_loop_next: 
9ae3				if DEBUG_FORTH_STACK_GUARD 
9ae3 cd d3 d4				call check_stacks 
9ae6				endif 
9ae6 e5				push hl 
9ae7 d5				push de 
9ae8 eb				ex de,hl 
9ae9 2a 95 ec			ld hl,(cli_loop_sp) 
9aec 23				inc hl 
9aed 23				inc hl 
9aee					if DEBUG_FORTH_WORDS 
9aee						DMARK "LNX" 
9aee f5				push af  
9aef 3a 03 9b			ld a, (.dmark)  
9af2 32 c0 ee			ld (debug_mark),a  
9af5 3a 04 9b			ld a, (.dmark+1)  
9af8 32 c1 ee			ld (debug_mark+1),a  
9afb 3a 05 9b			ld a, (.dmark+2)  
9afe 32 c2 ee			ld (debug_mark+2),a  
9b01 18 03			jr .pastdmark  
9b03 ..			.dmark: db "LNX"  
9b06 f1			.pastdmark: pop af  
9b07			endm  
# End of macro DMARK
9b07						CALLMONITOR 
9b07 cd 2e 93			call break_point_state  
9b0a				endm  
# End of macro CALLMONITOR
9b0a					endif 
9b0a 22 95 ec			ld (cli_loop_sp),hl 
9b0d 73				ld (hl), e 
9b0e 23				inc hl 
9b0f 72				ld (hl), d 
9b10 d1				pop de    ; been reversed so save a swap on restore 
9b11 e1				pop hl 
9b12				if DEBUG_FORTH_STACK_GUARD 
9b12 cd d3 d4				call check_stacks 
9b15				endif 
9b15 c9				ret 
9b16			 
9b16			; get current ret stack pointer and save to hl  
9b16				 
9b16			FORTH_LOOP_TOS: macro 
9b16				call macro_forth_loop_tos 
9b16				endm 
9b16			 
9b16			macro_forth_loop_tos: 
9b16 d5				push de 
9b17 2a 95 ec			ld hl,(cli_loop_sp) 
9b1a 5e				ld e, (hl) 
9b1b 23				inc hl 
9b1c 56				ld d, (hl) 
9b1d eb				ex de, hl 
9b1e d1				pop de 
9b1f c9				ret 
9b20			 
9b20			; pop loop stack pointer 
9b20				 
9b20			FORTH_LOOP_POP: macro 
9b20				call macro_forth_loop_pop 
9b20				endm 
9b20			 
9b20			 
9b20			macro_forth_loop_pop: 
9b20				if DEBUG_FORTH_STACK_GUARD 
9b20					DMARK "LPP" 
9b20 f5				push af  
9b21 3a 35 9b			ld a, (.dmark)  
9b24 32 c0 ee			ld (debug_mark),a  
9b27 3a 36 9b			ld a, (.dmark+1)  
9b2a 32 c1 ee			ld (debug_mark+1),a  
9b2d 3a 37 9b			ld a, (.dmark+2)  
9b30 32 c2 ee			ld (debug_mark+2),a  
9b33 18 03			jr .pastdmark  
9b35 ..			.dmark: db "LPP"  
9b38 f1			.pastdmark: pop af  
9b39			endm  
# End of macro DMARK
9b39 cd d3 d4				call check_stacks 
9b3c					FORTH_CHK_LOOP_UNDER 
9b3c e5				push hl 
9b3d d5				push de 
9b3e 2a 95 ec			ld hl,(cli_loop_sp) 
9b41 11 4f eb			ld de, cli_loop_stack 
9b44 cd d9 8a			call cmp16 
9b47 da ed d5			jp c, fault_loop_under 
9b4a d1				pop de 
9b4b e1				pop hl 
9b4c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9b4c				endif 
9b4c e5				push hl 
9b4d 2a 95 ec			ld hl,(cli_loop_sp) 
9b50 2b				dec hl 
9b51 2b				dec hl 
9b52 22 95 ec			ld (cli_loop_sp), hl 
9b55				; TODO do stack underflow checks 
9b55 e1				pop hl 
9b56				if DEBUG_FORTH_STACK_GUARD 
9b56 cd d3 d4				call check_stacks 
9b59					FORTH_CHK_LOOP_UNDER 
9b59 e5				push hl 
9b5a d5				push de 
9b5b 2a 95 ec			ld hl,(cli_loop_sp) 
9b5e 11 4f eb			ld de, cli_loop_stack 
9b61 cd d9 8a			call cmp16 
9b64 da ed d5			jp c, fault_loop_under 
9b67 d1				pop de 
9b68 e1				pop hl 
9b69				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9b69				endif 
9b69 c9				ret 
9b6a			 
9b6a			macro_forth_dsp_pop: 
9b6a			 
9b6a e5				push hl 
9b6b			 
9b6b				; release malloc data 
9b6b			 
9b6b				if DEBUG_FORTH_STACK_GUARD 
9b6b cd d3 d4				call check_stacks 
9b6e					FORTH_CHK_DSP_UNDER 
9b6e e5				push hl 
9b6f d5				push de 
9b70 2a 93 ec			ld hl,(cli_data_sp) 
9b73 11 4d ea			ld de, cli_data_stack 
9b76 cd d9 8a			call cmp16 
9b79 da e1 d5			jp c, fault_dsp_under 
9b7c d1				pop de 
9b7d e1				pop hl 
9b7e				endm 
# End of macro FORTH_CHK_DSP_UNDER
9b7e				endif 
9b7e				;ld hl,(cli_data_sp) 
9b7e			if DEBUG_FORTH_DOT 
9b7e				DMARK "DPP" 
9b7e				CALLMONITOR 
9b7e			endif	 
9b7e			 
9b7e			 
9b7e			if FORTH_ENABLE_DSPPOPFREE 
9b7e			 
9b7e				FORTH_DSP 
9b7e cd 78 9a			call macro_forth_dsp 
9b81				endm 
# End of macro FORTH_DSP
9b81			 
9b81 7e				ld a, (hl) 
9b82 fe 01			cp DS_TYPE_STR 
9b84 20 07			jr nz, .skippopfree 
9b86			 
9b86				FORTH_DSP_VALUEHL 
9b86 cd b2 9a			call macro_dsp_valuehl 
9b89				endm 
# End of macro FORTH_DSP_VALUEHL
9b89 00				nop 
9b8a			if DEBUG_FORTH_DOT 
9b8a				DMARK "DPf" 
9b8a				CALLMONITOR 
9b8a			endif	 
9b8a cd 4c 90			call free 
9b8d			.skippopfree: 
9b8d				 
9b8d			 
9b8d			endif 
9b8d			 
9b8d			if DEBUG_FORTH_DOT_KEY 
9b8d				DMARK "DP2" 
9b8d				CALLMONITOR 
9b8d			endif	 
9b8d			 
9b8d				; move pointer down 
9b8d			 
9b8d 2a 93 ec			ld hl,(cli_data_sp) 
9b90 2b				dec hl 
9b91 2b				dec hl 
9b92			; PARSEV5 
9b92 2b				dec hl 
9b93 22 93 ec			ld (cli_data_sp), hl 
9b96			 
9b96				if DEBUG_FORTH_STACK_GUARD 
9b96 cd d3 d4				call check_stacks 
9b99					FORTH_CHK_DSP_UNDER 
9b99 e5				push hl 
9b9a d5				push de 
9b9b 2a 93 ec			ld hl,(cli_data_sp) 
9b9e 11 4d ea			ld de, cli_data_stack 
9ba1 cd d9 8a			call cmp16 
9ba4 da e1 d5			jp c, fault_dsp_under 
9ba7 d1				pop de 
9ba8 e1				pop hl 
9ba9				endm 
# End of macro FORTH_CHK_DSP_UNDER
9ba9				endif 
9ba9			 
9ba9 e1				pop hl 
9baa			 
9baa c9				ret 
9bab			 
9bab			getwordathl: 
9bab				; hl points to an address 
9bab				; load hl with the word at that address 
9bab			 
9bab d5				push de 
9bac			 
9bac 5e				ld e, (hl) 
9bad 23				inc hl 
9bae 56				ld d, (hl) 
9baf eb				ex de, hl 
9bb0			 
9bb0 d1				pop de 
9bb1 c9				ret 
9bb2			 
9bb2			 
9bb2			 
9bb2			 
9bb2			 
9bb2			; eof 
9bb2			 
# End of file forth_stackopsv5.asm
9bb2			endif 
9bb2			 
9bb2			user_word_eol:  
9bb2				; hl contains the pointer to where to create a linked list item from the end 
9bb2				; of the user dict to continue on at the system word dict 
9bb2				 
9bb2				; poke the stub of the word list linked list to repoint to rom words 
9bb2			 
9bb2				; stub format 
9bb2				; db   word id 
9bb2				; dw    link to next word 
9bb2			        ; db char length of token 
9bb2				; db string + 0 term 
9bb2				; db exec code....  
9bb2			 
9bb2 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9bb4 77				ld (hl), a		; word id 
9bb5 23				inc hl 
9bb6			 
9bb6 11 7c 9d			ld de, sysdict 
9bb9 73				ld (hl), e		; next word link ie system dict 
9bba 23				inc hl 
9bbb 72				ld (hl), d		; next word link ie system dict 
9bbc 23				inc hl	 
9bbd			 
9bbd			;	ld (hl), sysdict		; next word link ie system dict 
9bbd			;	inc hl 
9bbd			;	inc hl 
9bbd			 
9bbd			;	inc hl 
9bbd			;	inc hl 
9bbd			 
9bbd 3e 02			ld a, 2			; word length is 0 
9bbf 77				ld (hl), a	 
9bc0 23				inc hl 
9bc1			 
9bc1 3e 7e			ld a, '~'			; word length is 0 
9bc3 77				ld (hl), a	 
9bc4 23				inc hl 
9bc5 3e 00			ld a, 0			; save empty word 
9bc7 77				ld (hl), a 
9bc8			 
9bc8 c9				ret 
9bc9			 
9bc9				 
9bc9			 
9bc9			forthexec_cleanup: 
9bc9				FORTH_RSP_POP 
9bc9 cd 83 98			call macro_forth_rsp_pop 
9bcc				endm 
# End of macro FORTH_RSP_POP
9bcc c9				ret 
9bcd			 
9bcd			forth_call_hl: 
9bcd				; taking hl 
9bcd e5				push hl 
9bce c9				ret 
9bcf			 
9bcf			; this is called to reset Forth system but keep existing uwords etc 
9bcf			 
9bcf			forth_warmstart: 
9bcf				; setup stack over/under flow checks 
9bcf				if DEBUG_FORTH_STACK_GUARD 
9bcf cd b9 d4				call chk_stk_init 
9bd2				endif 
9bd2			 
9bd2				; init stack pointers  - * these stacks go upwards *  
9bd2 21 51 ec			ld hl, cli_ret_stack 
9bd5 22 97 ec			ld (cli_ret_sp), hl	 
9bd8				; set bottom of stack 
9bd8 3e 00			ld a,0 
9bda 77				ld (hl),a 
9bdb 23				inc hl 
9bdc 77				ld (hl),a 
9bdd			 
9bdd 21 4d ea			ld hl, cli_data_stack 
9be0 22 93 ec			ld (cli_data_sp), hl	 
9be3				; set bottom of stack 
9be3 3e 00			ld a,0 
9be5 77				ld (hl),a 
9be6 23				inc hl 
9be7 77				ld (hl),a 
9be8			 
9be8 21 4f eb			ld hl, cli_loop_stack 
9beb 22 95 ec			ld (cli_loop_sp), hl	 
9bee				; set bottom of stack 
9bee 3e 00			ld a,0 
9bf0 77				ld (hl),a 
9bf1 23				inc hl 
9bf2 77				ld (hl),a 
9bf3			 
9bf3				; init extent of current open file 
9bf3			 
9bf3 3e 00			ld a, 0 
9bf5 32 e2 ec			ld (store_openext), a 
9bf8			 
9bf8 c9				ret 
9bf9			 
9bf9			 
9bf9			; Cold Start - this is called to setup the whole Forth system 
9bf9			 
9bf9			forth_init: 
9bf9			 
9bf9				; setup stack over/under flow checks 
9bf9			 
9bf9			;	if DEBUG_FORTH_STACK_GUARD 
9bf9			;		call chk_stk_init 
9bf9			;	endif 
9bf9			 
9bf9				; enable auto display updates (slow.....) 
9bf9			 
9bf9 3e 01			ld a, 1 
9bfb 32 ad ec			ld (cli_autodisplay), a 
9bfe			 
9bfe			 
9bfe			 
9bfe				; show start up screen 
9bfe			 
9bfe cd 8e 88			call clear_display 
9c01			 
9c01 3e 00			ld a,0 
9c03 32 cf ec			ld (f_cursor_ptr), a 
9c06			 
9c06				; set start of word list in start of ram - for use when creating user words 
9c06			 
9c06 21 84 d7			ld hl, baseram 
9c09 22 e3 e7			ld (os_last_new_uword), hl 
9c0c cd b2 9b			call user_word_eol 
9c0f				 
9c0f			;		call display_data_sp 
9c0f			;		call next_page_prompt 
9c0f			 
9c0f			 
9c0f			 
9c0f			 
9c0f c9				ret 
9c10			 
9c10 .. 00		.bootforth: db " Forth Kernel Init ",0 
9c24			 
9c24			; TODO push to stack 
9c24			 
9c24			;  
9c24			 
9c24			if FORTH_PARSEV2 
9c24			 
9c24			 
9c24				include "forth_parserv2.asm" 
9c24			 
9c24			endif 
9c24			 
9c24			 
9c24			; parse cli version 1 
9c24			 
9c24			if FORTH_PARSEV1 
9c24			 
9c24			 
9c24			 
9c24			      include "forth_parserv1.asm" 
9c24			endif 
9c24				 
9c24			if FORTH_PARSEV3 
9c24			 
9c24			 
9c24			 
9c24			      include "forth_parserv3.asm" 
9c24				include "forth_wordsv3.asm" 
9c24			endif 
9c24			 
9c24			if FORTH_PARSEV4 
9c24			 
9c24			 
9c24			 
9c24			      include "forth_parserv4.asm" 
9c24				include "forth_wordsv4.asm" 
9c24			endif 
9c24			 
9c24			if FORTH_PARSEV5 
9c24			 
9c24			 
9c24			 
9c24			      include "forth_parserv5.asm" 
9c24			 
9c24			 
9c24			; A better parser without using malloc and string copies all over the place.  
9c24			; Exec in situ should be faster 
9c24			 
9c24			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9c24			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9c24			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9c24			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9c24			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9c24			WORD_SYS_END: equ 0   ; Opcode for all user words 
9c24			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9c24			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9c24			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9c24			 
9c24			; Core word preamble macro 
9c24			 
9c24			CWHEAD:   macro nxtword opcode lit len opflags 
9c24				db WORD_SYS_CORE+opcode             
9c24				; internal op code number 
9c24				dw nxtword            
9c24				; link to next dict word block 
9c24				db len + 1 
9c24				; literal length of dict word inc zero term 
9c24				db lit,0              
9c24				; literal dict word 
9c24			        ; TODO db opflags        
9c24				endm 
9c24			 
9c24			 
9c24			NEXTW: macro  
9c24				jp macro_next 
9c24				endm 
9c24			 
9c24			macro_next: 
9c24			if DEBUG_FORTH_PARSE_KEY 
9c24				DMARK "NXT" 
9c24				CALLMONITOR 
9c24			endif	 
9c24			;	inc hl  ; skip token null term  
9c24 ed 4b b1 ec		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9c28 ed 5b af ec		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9c2c 2a e7 e7			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9c2f			if DEBUG_FORTH_PARSE_KEY 
9c2f				DMARK "}AA" 
9c2f				CALLMONITOR 
9c2f			endif	 
9c2f c3 32 9d			jp execnext 
9c32				;jp exec1 
9c32			       
9c32			 
9c32			 
9c32			; Another go at the parser to compile  
9c32			 
9c32			 
9c32			; TODO rework parser to change all of the string words to byte tokens 
9c32			; TODO do a search for  
9c32			 
9c32			; TODO first run normal parser to zero term sections 
9c32			; TODO for each word do a token look up to get the op code 
9c32			; TODO need some means to flag to the exec that this is a byte code form    
9c32			 
9c32			 
9c32			forthcompile: 
9c32			 
9c32			; 
9c32			; line parse: 
9c32			;       parse raw input buffer 
9c32			;       tokenise the words 
9c32			;       malloc new copy (for looping etc) 
9c32			;       copy to malloc + current pc in line to start of string and add line term 
9c32			;       save on new rsp 
9c32			; 
9c32			 
9c32			; hl to point to the line to tokenise 
9c32			 
9c32			;	push hl 
9c32 22 e7 e7			ld (os_tok_ptr), hl  ; save ptr to string 
9c35			 
9c35			;	ld a,0		; string term on input 
9c35			;	call strlent 
9c35			 
9c35			;	ld (os_tok_len), hl	 ; save string length 
9c35			 
9c35			;if DEBUG_FORTH_TOK 
9c35			;	ex de,hl		 
9c35			;endif 
9c35			 
9c35			;	pop hl 		; get back string pointer 
9c35			 
9c35			if DEBUG_FORTH_TOK 
9c35						DMARK "TOc" 
9c35				CALLMONITOR 
9c35			endif 
9c35 7e			.cptoken2:    ld a,(hl) 
9c36 23				inc hl 
9c37 fe 7f			cp FORTH_END_BUFFER 
9c39 28 29			jr z, .cptokendone2 
9c3b fe 00			cp 0 
9c3d 28 25			jr z, .cptokendone2 
9c3f fe 22			cp '"' 
9c41 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9c43 fe 20			cp ' ' 
9c45 20 ee			jr nz,  .cptoken2 
9c47			 
9c47			; TODO consume comments held between ( and ) 
9c47			 
9c47				; we have a space so change to zero term for dict match later 
9c47 2b				dec hl 
9c48 3e 00			ld a,0 
9c4a 77				ld (hl), a 
9c4b 23				inc hl 
9c4c 18 e7			jr .cptoken2 
9c4e				 
9c4e			 
9c4e			.cptokenstr2: 
9c4e				; skip all white space until either eol (because forgot to term) or end double quote 
9c4e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9c4e				;inc hl ; skip current double quote 
9c4e 7e				ld a,(hl) 
9c4f 23				inc hl 
9c50 fe 22			cp '"' 
9c52 28 e1			jr z, .cptoken2 
9c54 fe 7f			cp FORTH_END_BUFFER 
9c56 28 0c			jr z, .cptokendone2 
9c58 fe 00			cp 0 
9c5a 28 08			jr z, .cptokendone2 
9c5c fe 20			cp ' ' 
9c5e 28 02			jr z, .cptmp2 
9c60 18 ec			jr .cptokenstr2 
9c62			 
9c62			.cptmp2:	; we have a space so change to zero term for dict match later 
9c62				;dec hl 
9c62				;ld a,"-"	; TODO remove this when working 
9c62				;ld (hl), a 
9c62				;inc hl 
9c62 18 ea			jr .cptokenstr2 
9c64			 
9c64			.cptokendone2: 
9c64				;inc hl 
9c64 3e 7f			ld a, FORTH_END_BUFFER 
9c66 77				ld (hl),a 
9c67 23				inc hl 
9c68 3e 21			ld a, '!' 
9c6a 77				ld (hl),a 
9c6b			 
9c6b 2a e7 e7			ld hl,(os_tok_ptr) 
9c6e			         
9c6e			if DEBUG_FORTH_TOK 
9c6e						DMARK "Tc1" 
9c6e				CALLMONITOR 
9c6e			endif 
9c6e			 
9c6e				; push exec string to top of return stack 
9c6e				FORTH_RSP_NEXT 
9c6e cd 62 98			call macro_forth_rsp_next 
9c71				endm 
# End of macro FORTH_RSP_NEXT
9c71 c9				ret 
9c72			 
9c72			; Another go at the parser need to simplify the process 
9c72			 
9c72			forthparse: 
9c72			 
9c72			; 
9c72			; line parse: 
9c72			;       parse raw input buffer 
9c72			;       tokenise the words 
9c72			;       malloc new copy (for looping etc) 
9c72			;       copy to malloc + current pc in line to start of string and add line term 
9c72			;       save on new rsp 
9c72			; 
9c72			 
9c72			; hl to point to the line to tokenise 
9c72			 
9c72			;	push hl 
9c72 22 e7 e7			ld (os_tok_ptr), hl  ; save ptr to string 
9c75			 
9c75			;	ld a,0		; string term on input 
9c75			;	call strlent 
9c75			 
9c75			;	ld (os_tok_len), hl	 ; save string length 
9c75			 
9c75			;if DEBUG_FORTH_TOK 
9c75			;	ex de,hl		 
9c75			;endif 
9c75			 
9c75			;	pop hl 		; get back string pointer 
9c75			 
9c75			if DEBUG_FORTH_TOK 
9c75						DMARK "TOK" 
9c75				CALLMONITOR 
9c75			endif 
9c75 7e			.ptoken2:    ld a,(hl) 
9c76 23				inc hl 
9c77 fe 7f			cp FORTH_END_BUFFER 
9c79 28 29			jr z, .ptokendone2 
9c7b fe 00			cp 0 
9c7d 28 25			jr z, .ptokendone2 
9c7f fe 22			cp '"' 
9c81 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9c83 fe 20			cp ' ' 
9c85 20 ee			jr nz,  .ptoken2 
9c87			 
9c87			; TODO consume comments held between ( and ) 
9c87			 
9c87				; we have a space so change to zero term for dict match later 
9c87 2b				dec hl 
9c88 3e 00			ld a,0 
9c8a 77				ld (hl), a 
9c8b 23				inc hl 
9c8c 18 e7			jr .ptoken2 
9c8e				 
9c8e			 
9c8e			.ptokenstr2: 
9c8e				; skip all white space until either eol (because forgot to term) or end double quote 
9c8e			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9c8e				;inc hl ; skip current double quote 
9c8e 7e				ld a,(hl) 
9c8f 23				inc hl 
9c90 fe 22			cp '"' 
9c92 28 e1			jr z, .ptoken2 
9c94 fe 7f			cp FORTH_END_BUFFER 
9c96 28 0c			jr z, .ptokendone2 
9c98 fe 00			cp 0 
9c9a 28 08			jr z, .ptokendone2 
9c9c fe 20			cp ' ' 
9c9e 28 02			jr z, .ptmp2 
9ca0 18 ec			jr .ptokenstr2 
9ca2			 
9ca2			.ptmp2:	; we have a space so change to zero term for dict match later 
9ca2				;dec hl 
9ca2				;ld a,"-"	; TODO remove this when working 
9ca2				;ld (hl), a 
9ca2				;inc hl 
9ca2 18 ea			jr .ptokenstr2 
9ca4			 
9ca4			.ptokendone2: 
9ca4				;inc hl 
9ca4 3e 7f			ld a, FORTH_END_BUFFER 
9ca6 77				ld (hl),a 
9ca7 23				inc hl 
9ca8 3e 21			ld a, '!' 
9caa 77				ld (hl),a 
9cab			 
9cab 2a e7 e7			ld hl,(os_tok_ptr) 
9cae			         
9cae			if DEBUG_FORTH_TOK 
9cae						DMARK "TK1" 
9cae				CALLMONITOR 
9cae			endif 
9cae			 
9cae				; push exec string to top of return stack 
9cae				FORTH_RSP_NEXT 
9cae cd 62 98			call macro_forth_rsp_next 
9cb1				endm 
# End of macro FORTH_RSP_NEXT
9cb1 c9				ret 
9cb2			 
9cb2			; 
9cb2			;	; malloc size + buffer pointer + if is loop flag 
9cb2			;	ld hl,(os_tok_len) 		 ; get string length 
9cb2			; 
9cb2			;	ld a,l 
9cb2			; 
9cb2			;	cp 0			; we dont want to use a null string 
9cb2			;	ret z 
9cb2			; 
9cb2			;;	add 3    ; prefix malloc with buffer for current word ptr 
9cb2			; 
9cb2			;	add 5     ; TODO when certain not over writing memory remove 
9cb2			; 
9cb2			;		 
9cb2			; 
9cb2			;if DEBUG_FORTH_TOK 
9cb2			;			DMARK "TKE" 
9cb2			;	CALLMONITOR 
9cb2			;endif 
9cb2			; 
9cb2			;	ld l,a 
9cb2			;	ld h,0 
9cb2			;;	push hl   ; save required space for the copy later 
9cb2			;	call malloc 
9cb2			;if DEBUG_FORTH_TOK 
9cb2			;			DMARK "TKM" 
9cb2			;	CALLMONITOR 
9cb2			;endif 
9cb2			;	if DEBUG_FORTH_MALLOC_GUARD 
9cb2			;		push af 
9cb2			;		call ishlzero 
9cb2			;;		ld a, l 
9cb2			;;		add h 
9cb2			;;		cp 0 
9cb2			;		pop af 
9cb2			;		 
9cb2			;		call z,malloc_error 
9cb2			;	endif 
9cb2			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9cb2			; 
9cb2			; 
9cb2			;if DEBUG_FORTH_TOK 
9cb2			;			DMARK "TKR" 
9cb2			;	CALLMONITOR 
9cb2			;endif 
9cb2			; 
9cb2			;	FORTH_RSP_NEXT 
9cb2			; 
9cb2			;	;inc hl	 ; go past current buffer pointer 
9cb2			;	;inc hl 
9cb2			;	;inc hl   ; and past if loop flag 
9cb2			;		; TODO Need to set flag  
9cb2			; 
9cb2			;	 
9cb2			;	 
9cb2			;	ex de,hl	; malloc is dest 
9cb2			;	ld hl, (os_tok_len) 
9cb2			;;	pop bc 
9cb2			;	ld c, l                
9cb2			;	ld b,0 
9cb2			;	ld hl, (os_tok_ptr) 
9cb2			; 
9cb2			;if DEBUG_FORTH_TOK 
9cb2			;			DMARK "TKT" 
9cb2			;	CALLMONITOR 
9cb2			;endif 
9cb2			; 
9cb2			;	; do str cpy 
9cb2			; 
9cb2			;	ldir      ; copy byte in hl to de 
9cb2			; 
9cb2			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9cb2			; 
9cb2			;if DEBUG_FORTH_TOK 
9cb2			; 
9cb2			;			DMARK "TKY" 
9cb2			;	CALLMONITOR 
9cb2			;endif 
9cb2			;	;ld a,0 
9cb2			;	;ld a,FORTH_END_BUFFER 
9cb2			;	ex de, hl 
9cb2			;	;dec hl			 ; go back over the space delim at the end of word 
9cb2			;	;ld (hl),a 
9cb2			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9cb2			;	ld a,FORTH_END_BUFFER 
9cb2			;	ld (hl),a 
9cb2			;	inc hl 
9cb2			;	ld a,FORTH_END_BUFFER 
9cb2			;	ld (hl),a 
9cb2			; 
9cb2			;	; init the malloc area data 
9cb2			;	; set pc for in current area 
9cb2			;	;ld hl, (os_tok_malloc) 
9cb2			;	;inc hl 
9cb2			;	;inc hl 
9cb2			;	;inc hl 
9cb2			;	;ex de,hl 
9cb2			;	;ld hl, (os_tok_malloc) 
9cb2			;	;ld (hl),e 
9cb2			;	;inc hl 
9cb2			;	;ld (hl),d 
9cb2			; 
9cb2			; 
9cb2			;	ld hl,(os_tok_malloc) 
9cb2			;if DEBUG_FORTH_PARSE_KEY 
9cb2			;			DMARK "TKU" 
9cb2			;	CALLMONITOR 
9cb2			;endif 
9cb2			; 
9cb2			;	ret 
9cb2			 
9cb2			forthexec: 
9cb2			 
9cb2			; line exec: 
9cb2			; forth parser 
9cb2			 
9cb2			; 
9cb2			;       get current exec line on rsp 
9cb2			 
9cb2				FORTH_RSP_TOS 
9cb2 cd 79 98			call macro_forth_rsp_tos 
9cb5				endm 
# End of macro FORTH_RSP_TOS
9cb5			 
9cb5			;       restore current pc - hl points to malloc of data 
9cb5			 
9cb5				;ld e, (hl) 
9cb5				;inc hl 
9cb5				;ld d, (hl) 
9cb5				;ex de,hl 
9cb5			 
9cb5			 
9cb5			exec1: 
9cb5 22 e7 e7			ld (os_tok_ptr), hl 
9cb8			 
9cb8				; copy our PC to working vars  
9cb8 22 b1 ec			ld (cli_ptr), hl 
9cbb 22 af ec			ld (cli_origptr), hl 
9cbe			 
9cbe 7e				ld a,(hl) 
9cbf fe 7f			cp FORTH_END_BUFFER 
9cc1 c8				ret z 
9cc2			 
9cc2				; skip any nulls 
9cc2			 
9cc2 fe 00			cp 0 
9cc4 20 03			jr nz, .execword 
9cc6 23				inc hl 
9cc7 18 ec			jr exec1 
9cc9			 
9cc9			 
9cc9			.execword: 
9cc9			 
9cc9			 
9cc9			 
9cc9			if DEBUG_FORTH_PARSE_KEY 
9cc9						DMARK "KYQ" 
9cc9				CALLMONITOR 
9cc9			endif 
9cc9			;       while at start of word: 
9cc9			; get start of dict (in user area first) 
9cc9			 
9cc9 21 84 d7		ld hl, baseram 
9ccc			;ld hl, sysdict 
9ccc 22 b3 ec		ld (cli_nextword),hl 
9ccf			;           match word at pc 
9ccf			;           exec word 
9ccf			;           or push to dsp 
9ccf			;           forward to next token 
9ccf			;           if line term pop rsp and exit 
9ccf			;        
9ccf			 
9ccf			if DEBUG_FORTH_PARSE_KEY 
9ccf						DMARK "KYq" 
9ccf				CALLMONITOR 
9ccf			endif 
9ccf			 
9ccf			; 
9ccf			; word comp 
9ccf			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9ccf			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9ccf			;    move to start of word  
9ccf			;    compare word to cli_token 
9ccf			 
9ccf			.execpnword:	; HL at start of a word in the dictionary to check 
9ccf			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9ccf			;	ld (cli_ptr), hl 
9ccf			 
9ccf 2a b3 ec			ld hl,(cli_nextword) 
9cd2			 
9cd2 cd 75 9d			call forth_tok_next 
9cd5			; tok next start here 
9cd5			;	; TODO skip compiled symbol for now 
9cd5			;	inc hl 
9cd5			; 
9cd5			;	; save pointer to next word 
9cd5			; 
9cd5			;	; hl now points to the address of the next word pointer  
9cd5			;	ld e, (hl) 
9cd5			;	inc hl 
9cd5			;	ld d, (hl) 
9cd5			;	inc l 
9cd5			; 
9cd5			;	ex de,hl 
9cd5			;if DEBUG_FORTH_PARSE_NEXTWORD 
9cd5			;	push bc 
9cd5			;	ld bc, (cli_nextword) 
9cd5			;			DMARK "NXW" 
9cd5			;	CALLMONITOR 
9cd5			;	pop bc 
9cd5			;endif 
9cd5			; tok next end here 
9cd5 22 b3 ec			ld (cli_nextword), hl     ; save for next check if no match on this word 
9cd8 eb				ex de, hl 
9cd9			 
9cd9			 
9cd9				; save the pointer of the current token - 1 to check against 
9cd9				 
9cd9 22 b7 ec			ld (cli_token), hl   
9cdc				; TODO maybe remove below save if no debug 
9cdc				; save token string ptr for any debug later 
9cdc 23				inc hl  
9cdd 22 b9 ec			ld (cli_origtoken), hl 
9ce0 2b				dec hl 
9ce1				; save pointer to the start of the next dictionay word 
9ce1 7e				ld a,(hl)   ; get string length 
9ce2 47				ld b,a 
9ce3			.execpnwordinc:  
9ce3 23				inc hl 
9ce4 10 fd			djnz .execpnwordinc 
9ce6 22 b5 ec			ld (cli_execword), hl      ; save start of this words code 
9ce9			 
9ce9				; now check the word token against the string being parsed 
9ce9			 
9ce9 2a b7 ec			ld hl,(cli_token) 
9cec 23				inc hl     ; skip string length (use zero term instead to end) 
9ced 22 b7 ec			ld (cli_token), hl 
9cf0			 
9cf0			if DEBUG_FORTH_PARSE_KEY 
9cf0						DMARK "KY2" 
9cf0			endif 
9cf0			if DEBUG_FORTH_PARSE_EXEC 
9cf0				; see if disabled 
9cf0			 
9cf0				ld a, (os_view_disable) 
9cf0				cp '*' 
9cf0				jr z, .skip 
9cf0			 
9cf0				push hl 
9cf0				push hl 
9cf0				call clear_display 
9cf0				ld de, .compword 
9cf0				ld a, display_row_1 
9cf0				call str_at_display 
9cf0				pop de 
9cf0				ld a, display_row_2 
9cf0				call str_at_display 
9cf0				ld hl,(cli_ptr) 
9cf0				ld a,(hl) 
9cf0			        ld hl, os_word_scratch 
9cf0				ld (hl),a 
9cf0				ld a,0 
9cf0				inc hl 
9cf0				ld (hl),a 	 
9cf0				ld de, os_word_scratch 
9cf0				ld a, display_row_2+10 
9cf0				call str_at_display 
9cf0				call update_display 
9cf0				ld a, 100 
9cf0				call aDelayInMS 
9cf0				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9cf0				call delay250ms 
9cf0				endif 
9cf0				pop hl 
9cf0			.skip:  
9cf0			endif	 
9cf0			.execpnchar:    ; compare char between token and string to parse 
9cf0			 
9cf0			if DEBUG_FORTH_PARSE_KEY 
9cf0						DMARK "Ky3" 
9cf0			endif 
9cf0			if DEBUG_FORTH_PARSE_EXEC 
9cf0				; see if disabled 
9cf0			 
9cf0				ld a, (os_view_disable) 
9cf0				cp '*' 
9cf0				jr z, .skip2 
9cf0			 
9cf0			;	call clear_display 
9cf0			ld hl,(cli_token) 
9cf0			ld a,(hl) 
9cf0			ld (os_word_scratch),a 
9cf0				ld hl,(cli_ptr) 
9cf0			ld a,(hl) 
9cf0				ld (os_word_scratch+1),a 
9cf0				ld a,0 
9cf0				ld (os_word_scratch+2),a 
9cf0				ld de,os_word_scratch 
9cf0				ld a,display_row_4 
9cf0				call str_at_display 
9cf0				call update_display 
9cf0			.skip2:  
9cf0			endif 
9cf0 2a b7 ec			ld hl,(cli_token) 
9cf3 7e				ld a, (hl)	 ; char in word token 
9cf4 23				inc hl 		; move to next char 
9cf5 22 b7 ec			ld (cli_token), hl ; and save it 
9cf8 47				ld b,a 
9cf9			 
9cf9 2a b1 ec			ld hl,(cli_ptr) ;	get the char from the string to parse 
9cfc 7e				ld a,(hl) 
9cfd 23				inc hl 
9cfe 22 b1 ec			ld (cli_ptr), hl		; move to next char 
9d01 cd 10 8f			call toUpper 		; make sure the input string matches case 
9d04			 
9d04			if DEBUG_FORTH_PARSE 
9d04			endif 
9d04			 
9d04				; input stream end of token is a space so get rid of it 
9d04			 
9d04			;	cp ' ' 
9d04			;	jr nz, .pnskipspace 
9d04			; 
9d04			;	ld a, 0		; make same term as word token term 
9d04			; 
9d04			;.pnskipspace: 
9d04			 
9d04			if DEBUG_FORTH_PARSE_KEY 
9d04						DMARK "KY7" 
9d04			endif 
9d04 b8				cp b 
9d05 c2 1b 9d			jp nz, .execpnskipword	 ; no match so move to next word 
9d08				 
9d08			;    if same 
9d08			;       scan for string terms 0 for token and 32 for input 
9d08			 
9d08				 
9d08			if DEBUG_FORTH_PARSE_KEY 
9d08						DMARK "KY8" 
9d08			endif 
9d08			 
9d08 80				add b			 
9d09 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9d0b							; TODO need to make sure last word in zero term string is accounted for 
9d0b 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9d0d			 
9d0d			 
9d0d				; at end of both strings so both are exact match 
9d0d			 
9d0d			;       skip ptr for next word 
9d0d			 
9d0d 2a b1 ec			ld hl,(cli_ptr) 	; at input string term 
9d10 23				inc hl			 ; at next char 
9d11 22 b1 ec			ld (cli_ptr), hl     ; save for next round of the parser 
9d14 22 af ec			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9d17				 
9d17				 
9d17			if DEBUG_FORTH_PARSE_KEY 
9d17						DMARK "KY3" 
9d17			endif 
9d17			 
9d17			 
9d17			 
9d17			;       exec code block 
9d17			if DEBUG_FORTH_JP 
9d17				call clear_display 
9d17				call update_display 
9d17				call delay1s 
9d17				ld hl, (cli_execword)     ; save for next check if no match on this word 
9d17				ld a,h 
9d17				ld hl, os_word_scratch 
9d17				call hexout 
9d17				ld hl, (cli_execword)     ; save for next check if no match on this word 
9d17				ld a,l 
9d17				ld hl, os_word_scratch+2 
9d17				call hexout 
9d17				ld hl, os_word_scratch+4 
9d17				ld a,0 
9d17				ld (hl),a 
9d17				ld de,os_word_scratch 
9d17				call str_at_display 
9d17					ld a, display_row_2 
9d17					call str_at_display 
9d17				ld de, (cli_origtoken) 
9d17				ld a, display_row_1+10 
9d17					call str_at_display 
9d17			 
9d17				ld a,display_row_1 
9d17				ld de, .foundword 
9d17				ld a, display_row_3 
9d17				call str_at_display 
9d17				call update_display 
9d17				call delay1s 
9d17				call delay1s 
9d17				call delay1s 
9d17			endif 
9d17			 
9d17			if DEBUG_FORTH_PARSE_KEY 
9d17						DMARK "KYj" 
9d17			endif 
9d17				; TODO save the word pointer in this exec 
9d17			 
9d17 2a b5 ec			ld hl,(cli_execword) 
9d1a e9				jp (hl) 
9d1b			 
9d1b			 
9d1b			;    if not same 
9d1b			;	scan for zero term 
9d1b			;	get ptr for next word 
9d1b			;	goto word comp 
9d1b			 
9d1b			.execpnskipword:	; get pointer to next word 
9d1b 2a b3 ec			ld hl,(cli_nextword) 
9d1e			 
9d1e 7e				ld a,(hl) 
9d1f fe 00			cp WORD_SYS_END 
9d21			;	cp 0 
9d21 28 09			jr z, .execendofdict			 ; at end of words 
9d23			 
9d23			if DEBUG_FORTH_PARSE_KEY 
9d23						DMARK "KY4" 
9d23			endif 
9d23			if DEBUG_FORTH_PARSE_EXEC 
9d23			 
9d23				; see if disabled 
9d23			 
9d23				ld a, (os_view_disable) 
9d23				cp '*' 
9d23				jr z, .noskip 
9d23			 
9d23			 
9d23				ld de, .nowordfound 
9d23				ld a, display_row_3 
9d23				call str_at_display 
9d23				call update_display 
9d23				ld a, 100 
9d23				call aDelayInMS 
9d23				 
9d23				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9d23					call delay250ms 
9d23				endif 
9d23			.noskip:  
9d23			 
9d23			endif	 
9d23			 
9d23 2a af ec			ld hl,(cli_origptr) 
9d26 22 b1 ec			ld (cli_ptr),hl 
9d29			 
9d29			if DEBUG_FORTH_PARSE_KEY 
9d29						DMARK "KY5" 
9d29			endif 
9d29 c3 cf 9c			jp .execpnword			; else go to next word 
9d2c			 
9d2c			.execendofdict:  
9d2c			 
9d2c			if DEBUG_FORTH_PARSE_KEY 
9d2c						DMARK "KYe" 
9d2c			endif 
9d2c			if DEBUG_FORTH_PARSE_EXEC 
9d2c				; see if disabled 
9d2c			 
9d2c				ld a, (os_view_disable) 
9d2c				cp '*' 
9d2c				jr z, .ispskip 
9d2c			 
9d2c				call clear_display 
9d2c				call update_display 
9d2c				call delay1s 
9d2c				ld de, (cli_origptr) 
9d2c				ld a, display_row_1 
9d2c				call str_at_display 
9d2c				 
9d2c				ld de, .enddict 
9d2c				ld a, display_row_3 
9d2c				call str_at_display 
9d2c				call update_display 
9d2c				ld a, 100 
9d2c				call aDelayInMS 
9d2c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9d2c				call delay1s 
9d2c				call delay1s 
9d2c				call delay1s 
9d2c				endif 
9d2c			.ispskip:  
9d2c				 
9d2c			endif	 
9d2c			 
9d2c			 
9d2c			 
9d2c				; if the word is not a keyword then must be a literal so push it to stack 
9d2c			 
9d2c			; push token to stack to end of word 
9d2c			 
9d2c				STACKFRAME ON $1efe $2f9f 
9d2c				if DEBUG_STACK_IMB 
9d2c					if ON 
9d2c						exx 
9d2c						ld de, $1efe 
9d2c						ld a, d 
9d2c						ld hl, curframe 
9d2c						call hexout 
9d2c						ld a, e 
9d2c						ld hl, curframe+2 
9d2c						call hexout 
9d2c						ld hl, $1efe 
9d2c						push hl 
9d2c						ld hl, $2f9f 
9d2c						push hl 
9d2c						exx 
9d2c					endif 
9d2c				endif 
9d2c			endm 
# End of macro STACKFRAME
9d2c			 
9d2c 2a e7 e7		ld hl,(os_tok_ptr) 
9d2f cd 24 9a		call forth_apush 
9d32			 
9d32				STACKFRAMECHK ON $1efe $2f9f 
9d32				if DEBUG_STACK_IMB 
9d32					if ON 
9d32						exx 
9d32						ld hl, $2f9f 
9d32						pop de   ; $2f9f 
9d32						call cmp16 
9d32						jr nz, .spnosame 
9d32						ld hl, $1efe 
9d32						pop de   ; $1efe 
9d32						call cmp16 
9d32						jr z, .spfrsame 
9d32						.spnosame: call showsperror 
9d32						.spfrsame: nop 
9d32						exx 
9d32					endif 
9d32				endif 
9d32			endm 
# End of macro STACKFRAMECHK
9d32			 
9d32			execnext: 
9d32			 
9d32			if DEBUG_FORTH_PARSE_KEY 
9d32						DMARK "KY>" 
9d32			endif 
9d32			; move past token to next word 
9d32			 
9d32 2a e7 e7		ld hl, (os_tok_ptr) 
9d35 3e 00		ld a, 0 
9d37 01 ff 00		ld bc, 255     ; input buffer size 
9d3a ed b1		cpir 
9d3c			 
9d3c			if DEBUG_FORTH_PARSE_KEY 
9d3c						DMARK "KY!" 
9d3c				CALLMONITOR 
9d3c			endif	 
9d3c			; TODO this might place hl on the null, so will need to forward on??? 
9d3c			;inc hl   ; see if this gets onto the next item 
9d3c			 
9d3c			 
9d3c			; TODO pass a pointer to the buffer to push 
9d3c			; TODO call function to push 
9d3c			 
9d3c			; look for end of input 
9d3c			 
9d3c			;inc hl 
9d3c			;ld a,(hl) 
9d3c			;cp FORTH_END_BUFFER 
9d3c			;ret z 
9d3c			 
9d3c			 
9d3c c3 b5 9c		jp exec1 
9d3f			 
9d3f			 
9d3f			 
9d3f			 
9d3f			 
9d3f			 
9d3f			 
9d3f			 
9d3f			 
9d3f			findnexttok: 
9d3f			 
9d3f				; hl is pointer to move 
9d3f				; de is the token to locate 
9d3f			 
9d3f					if DEBUG_FORTH 
9d3f						DMARK "NTK" 
9d3f						CALLMONITOR 
9d3f					endif 
9d3f d5				push de 
9d40			 
9d40			.fnt1:	 
9d40				; find first char of token to locate 
9d40			 
9d40 1a				ld a, (de) 
9d41 4f				ld c,a 
9d42 7e				ld a,(hl) 
9d43 cd 10 8f			call toUpper 
9d46					if DEBUG_FORTH 
9d46						DMARK "NT1" 
9d46						CALLMONITOR 
9d46					endif 
9d46 b9				cp c 
9d47			 
9d47 28 03			jr z, .fnt2cmpmorefirst	 
9d49			 
9d49				; first char not found move to next char 
9d49			 
9d49 23				inc hl 
9d4a 18 f4			jr .fnt1 
9d4c			 
9d4c			.fnt2cmpmorefirst:	 
9d4c				; first char of token found.  
9d4c			 
9d4c e5				push hl     ; save start of token just in case it is the right one 
9d4d d9				exx 
9d4e e1				pop hl        ; save it to hl' 
9d4f d9				exx 
9d50			 
9d50			 
9d50			.fnt2cmpmore:	 
9d50				; compare the rest 
9d50				 
9d50 23				inc hl 
9d51 13				inc de 
9d52				 
9d52 1a				ld a, (de) 
9d53 4f				ld c,a 
9d54 7e				ld a,(hl) 
9d55 cd 10 8f			call toUpper 
9d58			 
9d58					if DEBUG_FORTH 
9d58						DMARK "NT2" 
9d58						CALLMONITOR 
9d58					endif 
9d58				; c has the token to find char 
9d58				; a has the mem to scan char 
9d58			 
9d58 b9				cp c 
9d59 28 04			jr z,.fntmatch1 
9d5b			 
9d5b				; they are not the same 
9d5b			 
9d5b					if DEBUG_FORTH 
9d5b						DMARK "NT3" 
9d5b						CALLMONITOR 
9d5b					endif 
9d5b d1				pop de	; reset de token to look for 
9d5c d5				push de 
9d5d 18 e1			jr .fnt1 
9d5f				 
9d5f			.fntmatch1: 
9d5f			 
9d5f				; is the same char a null which means we might have a full hit? 
9d5f					if DEBUG_FORTH 
9d5f						DMARK "NT4" 
9d5f						CALLMONITOR 
9d5f					endif 
9d5f			 
9d5f fe 00			cp 0 
9d61 28 0b			jr z, .fntmatchyes 
9d63			 
9d63				; are we at the end of the token to find? 
9d63			 
9d63					if DEBUG_FORTH 
9d63						DMARK "NT5" 
9d63						CALLMONITOR 
9d63					endif 
9d63 3e 00			ld a, 0 
9d65 b9				cp c 
9d66			 
9d66 c2 50 9d			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9d69			 
9d69					if DEBUG_FORTH 
9d69						DMARK "NT6" 
9d69						CALLMONITOR 
9d69					endif 
9d69				; token to find is exhusted but no match to stream 
9d69			 
9d69				; restore tok pointer and continue on 
9d69 d1				pop de 
9d6a d5				push de 
9d6b c3 40 9d			jp .fnt1 
9d6e			 
9d6e			 
9d6e			.fntmatchyes: 
9d6e			 
9d6e				; hl now contains the end of the found token 
9d6e			 
9d6e				; get rid of saved token pointer to find 
9d6e			 
9d6e d1				pop de 
9d6f			 
9d6f					if DEBUG_FORTH 
9d6f						DMARK "NT9" 
9d6f						CALLMONITOR 
9d6f					endif 
9d6f			 
9d6f				; hl will be on the null term so forward on 
9d6f			 
9d6f				; get back the saved start of the token 
9d6f			 
9d6f d9				exx 
9d70 e5				push hl     ; save start of token just in case it is the right one 
9d71 d9				exx 
9d72 e1				pop hl        ; save it to hl 
9d73			 
9d73 c9				ret 
9d74			 
9d74			 
9d74			; LIST needs to find a specific token   
9d74			; FORGET needs to find a spefici token 
9d74			 
9d74			; SAVE needs to find all tokens by flag 
9d74			; WORDS just needs to scan through all  by flag 
9d74			; UWORDS needs to scan through all by flag 
9d74			 
9d74			 
9d74			; given hl as pointer to start of dict look up string 
9d74			; return hl as pointer to start of word block 
9d74			; or 0 if not found 
9d74			 
9d74			forth_find_tok: 
9d74 c9				ret 
9d75			 
9d75			; given hl as pointer to dict structure 
9d75			; move to the next dict block structure 
9d75			 
9d75			forth_tok_next: 
9d75				; hl now points to the address of the next word pointer  
9d75				; TODO skip compiled symbol for now 
9d75			;	push de 
9d75 23				inc hl 
9d76 5e				ld e, (hl) 
9d77 23				inc hl 
9d78 56				ld d, (hl) 
9d79 23				inc hl 
9d7a			 
9d7a eb				ex de,hl 
9d7b			if DEBUG_FORTH_PARSE_NEXTWORD 
9d7b				push bc 
9d7b				ld bc, (cli_nextword) 
9d7b						DMARK "NXW" 
9d7b				CALLMONITOR 
9d7b				pop bc 
9d7b			endif 
9d7b			;	pop de	 
9d7b c9				ret 
9d7c			 
9d7c			 
9d7c			 
9d7c			; eof 
# End of file forth_parserv5.asm
9d7c				include "forth_wordsv4.asm" 
9d7c			 
9d7c			; the core word dictionary v4 
9d7c			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9d7c			 
9d7c			; this is a linked list for each of the system words used 
9d7c			; user defined words will follow the same format but will be in ram 
9d7c			 
9d7c			 
9d7c			; 
9d7c			; 
9d7c			; define linked list: 
9d7c			; 
9d7c			; 1. compiled byte op code 
9d7c			; 2. len of text word 
9d7c			; 3. text word 
9d7c			; 4. ptr to next dictionary word 
9d7c			; 5. asm, calls etc for the word 
9d7c			; 
9d7c			;  if 1 == 0 then last word in dict  
9d7c			;   
9d7c			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9d7c			;  
9d7c			;  
9d7c			; create basic standard set of words 
9d7c			; 
9d7c			;  
9d7c			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9d7c			; 2DUP 2DROP 2SWAP  
9d7c			; @ C@ - get byte  
9d7c			; ! C! - store byte 
9d7c			; 0< true if less than zero 
9d7c			; 0= true if zero 
9d7c			; < >  
9d7c			; = true if same 
9d7c			; variables 
9d7c			 
9d7c			 
9d7c			; Hardware specific words I may need 
9d7c			; 
9d7c			; IN OUT  
9d7c			; calls to key util functions 
9d7c			; calls to hardward abstraction stuff 
9d7c			; easy control of frame buffers and lcd i/o 
9d7c			; keyboard  
9d7c			 
9d7c			 
9d7c			;DICT: macro 
9d7c			; op_code, len, word, next 
9d7c			;    word: 
9d7c			;    db op_code 
9d7c			;    ds word zero term 
9d7c			;    dw next 
9d7c			;    endm 
9d7c			 
9d7c			 
9d7c			 
9d7c			 
9d7c			; op code 1 is a flag for user define words which are to be handled differently 
9d7c			 
9d7c			 
9d7c			; 
9d7c			; 
9d7c			;    TODO on entry to a word this should be the expected environment 
9d7c			;    hl - tos value if number then held, if string this is the ptr 
9d7c			;    de -  
9d7c			 
9d7c			 
9d7c			; opcode ranges 
9d7c			; 0 - end of word dict 
9d7c			; 255 - user define words 
9d7c			 
9d7c			sysdict: 
9d7c			include "forth_opcodes.asm" 
9d7c			; op codes for forth keywords 
9d7c			; free to use code 0  
9d7c				OPCODE_HEAP: equ  1 
9d7c				OPCODE_EXEC: equ 2 
9d7c				OPCODE_DUP: equ 3 
9d7c				OPCODE_SWAP: equ 4 
9d7c				OPCODE_COLN: equ 5 
9d7c				OPCODE_SCOLN: equ 6 
9d7c				OPCODE_DROP: equ 7 
9d7c				OPCODE_DUP2: equ 8 
9d7c				OPCODE_DROP2: equ 9 
9d7c				OPCODE_SWAP2: equ 10 
9d7c				OPCODE_AT: equ 11 
9d7c				OPCODE_CAT: equ 12 
9d7c				OPCODE_BANG: equ 13 
9d7c				OPCODE_CBANG: equ 14 
9d7c				OPCODE_SCALL: equ 15 
9d7c				OPCODE_DEPTH: equ 16 
9d7c				OPCODE_OVER: equ 17 
9d7c				OPCODE_PAUSE: equ 18 
9d7c				OPCODE_PAUSES: equ 19 
9d7c				OPCODE_ROT: equ 20 
9d7c			;free to reuse	OPCODE_WORDS: equ 21 
9d7c			        OPCODE_NOT: equ 21 
9d7c				OPCODE_UWORDS: equ 22 
9d7c				OPCODE_BP: equ 23 
9d7c				OPCODE_MONITOR: equ 24  
9d7c				OPCODE_MALLOC: equ 25 
9d7c				OPCODE_FREE: equ 26 
9d7c				OPCODE_LIST: equ 27 
9d7c				OPCODE_FORGET: equ 28 
9d7c				OPCODE_NOP: equ 29 
9d7c				OPCODE_COMO: equ 30 
9d7c				OPCODE_COMC: equ 31 
9d7c			;free to reuse	OPCODE_ENDCORE: equ 32 
9d7c				OPCODE_AFTERSOUND: equ 33 
9d7c				OPCODE_GP2: equ 34 
9d7c				OPCODE_GP3: equ 35 
9d7c				OPCODE_GP4: equ 36 
9d7c				OPCODE_SIN: equ 37 
9d7c				OPCODE_SOUT: equ 38 
9d7c				OPCODE_SPIO: equ 39 
9d7c				OPCODE_SPICEH: equ 40 
9d7c				OPCODE_SPIOb: equ 41 
9d7c				OPCODE_SPII: equ 42 
9d7c				OPCODE_SESEL: equ 43 
9d7c				OPCODE_CARTDEV: equ 44 
9d7c			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9d7c				OPCODE_FB: equ 46 
9d7c				OPCODE_EMIT: equ 47 
9d7c				OPCODE_DOTH: equ 48 
9d7c				OPCODE_DOTF: equ 49 
9d7c				OPCODE_DOT: equ 50 
9d7c				OPCODE_CLS: equ 51 
9d7c				OPCODE_DRAW: equ 52 
9d7c				OPCODE_DUMP: equ 53 
9d7c				OPCODE_CDUMP: equ 54 
9d7c				OPCODE_DAT: equ 55 
9d7c				OPCODE_HOME: equ 56 
9d7c				OPCODE_SPACE: equ 57 
9d7c				OPCODE_SPACES: equ 58 
9d7c				OPCODE_SCROLL: equ 59 
9d7c				OPCODE_ATQ: equ 60 
9d7c				OPCODE_AUTODSP: equ 61 
9d7c				OPCODE_MENU: equ 62 
9d7c			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9d7c				OPCODE_THEN: equ 64 
9d7c				OPCODE_ELSE: equ 65 
9d7c				OPCODE_DO: equ 66 
9d7c				OPCODE_LOOP: equ 67 
9d7c				OPCODE_I: equ 68 
9d7c				OPCODE_DLOOP: equ 69  
9d7c				OPCODE_REPEAT: equ 70  
9d7c				OPCODE_UNTIL: equ 71 
9d7c				OPCODE_ENDFLOW: equ 72 
9d7c				OPCODE_WAITK: equ 73 
9d7c				OPCODE_ACCEPT: equ 74 
9d7c				OPCODE_EDIT: equ 75 
9d7c			;free to reuse	OPCODE_ENDKEY: equ 76 
9d7c				OPCODE_LZERO: equ 77 
9d7c				OPCODE_TZERO: equ 78 
9d7c				OPCODE_LESS: equ 79 
9d7c				OPCODE_GT: equ 80 
9d7c				OPCODE_EQUAL: equ 81  
9d7c			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9d7c				OPCODE_NEG: equ 83 
9d7c				OPCODE_DIV: equ 84 
9d7c				OPCODE_MUL: equ 85 
9d7c				OPCODE_MIN: equ 86 
9d7c				OPCODE_MAX: equ 87 
9d7c				OPCODE_RND16: equ 88 
9d7c				OPCODE_RND8: equ 89 
9d7c				OPCODE_RND: equ 90 
9d7c			;free to reuse	OPCODE_ENDMATHS: equ 91  
9d7c				OPCODE_BYNAME: equ 92 
9d7c				OPCODE_DIR: equ 93 
9d7c				OPCODE_SAVE: equ 94 
9d7c				OPCODE_LOAD: equ 95 
9d7c				OPCODE_BSAVE: equ 96 
9d7c				OPCODE_BLOAD: equ 97 
9d7c				OPCODE_SEO: equ 98  
9d7c				OPCODE_SEI: equ 99 
9d7c				OPCODE_SFREE: equ 100 
9d7c				OPCODE_SIZE: equ 101 
9d7c				OPCODE_CREATE: equ 102 
9d7c				OPCODE_APPEND: equ 103 
9d7c				OPCODE_SDEL: equ 104 
9d7c				OPCODE_OPEN: equ 105 
9d7c				OPCODE_READ: equ 106 
9d7c				OPCODE_EOF: equ 106 
9d7c				OPCODE_FORMAT: equ 107 
9d7c				OPCODE_LABEL: equ 108 
9d7c				OPCODE_LABELS: equ 109 
9d7c			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9d7c				OPCODE_UPPER: equ 111 
9d7c				OPCODE_LOWER: equ 112 
9d7c				OPCODE_SUBSTR: equ 113 
9d7c				OPCODE_LEFT: equ 114 
9d7c				OPCODE_RIGHT: equ 115 
9d7c				OPCODE_STR2NUM: equ 116 
9d7c				OPCODE_NUM2STR: equ 117 
9d7c				OPCODE_CONCAT: equ 118 
9d7c				OPCODE_FIND: equ 119 
9d7c				OPCODE_LEN: equ 120 
9d7c				OPCODE_CHAR: equ 121 
9d7c			; free to reuse	OPCODE_STRLEN: equ 122 
9d7c			; free to reuse	OPCODE_ENDSTR: equ 123 
9d7c				OPCODE_V0S: equ 124 
9d7c				OPCODE_V0Q: equ 125 
9d7c				OPCODE_V1S: equ 126 
9d7c				OPCODE_V1Q: equ 127 
9d7c				OPCODE_V2S: equ 128 
9d7c				OPCODE_V2Q: equ 129 
9d7c				OPCODE_V3S: equ 130 
9d7c				OPCODE_V3Q: equ 131 
9d7c			;free to reuse	OPCODE_END: equ 132 
9d7c				OPCODE_ZDUP: equ 133 
9d7c			 
9d7c			; eof 
# End of file forth_opcodes.asm
9d7c			 
9d7c			include "forth_words_core.asm" 
9d7c			 
9d7c			; | ## Core Words 
9d7c			 
9d7c			;if MALLOC_4 
9d7c			 
9d7c			.HEAP: 
9d7c				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9d7c 15				db WORD_SYS_CORE+OPCODE_HEAP             
9d7d bb 9d			dw .EXEC            
9d7f 05				db 4 + 1 
9d80 .. 00			db "HEAP",0              
9d85				endm 
# End of macro CWHEAD
9d85			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9d85			; | | u1 - Current number of bytes in the heap 
9d85			; | | u2 - Remaining bytes left on the heap 
9d85			; | |  
9d85			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9d85			 
9d85			 
9d85					if DEBUG_FORTH_WORDS_KEY 
9d85						DMARK "HEP" 
9d85 f5				push af  
9d86 3a 9a 9d			ld a, (.dmark)  
9d89 32 c0 ee			ld (debug_mark),a  
9d8c 3a 9b 9d			ld a, (.dmark+1)  
9d8f 32 c1 ee			ld (debug_mark+1),a  
9d92 3a 9c 9d			ld a, (.dmark+2)  
9d95 32 c2 ee			ld (debug_mark+2),a  
9d98 18 03			jr .pastdmark  
9d9a ..			.dmark: db "HEP"  
9d9d f1			.pastdmark: pop af  
9d9e			endm  
# End of macro DMARK
9d9e						CALLMONITOR 
9d9e cd 2e 93			call break_point_state  
9da1				endm  
# End of macro CALLMONITOR
9da1					endif 
9da1 2a 8e d7				ld hl, (free_list )      
9da4 11 93 d7				ld de, heap_start 
9da7			 
9da7 ed 52				sbc hl, de  
9da9			 
9da9 cd bb 98				call forth_push_numhl 
9dac			 
9dac			 
9dac ed 5b 8e d7			ld de, (free_list )      
9db0 21 cc e4				ld hl, heap_end 
9db3			 
9db3 ed 52				sbc hl, de 
9db5			 
9db5 cd bb 98				call forth_push_numhl 
9db8					 
9db8			 
9db8					 
9db8			 
9db8			 
9db8			 
9db8					NEXTW 
9db8 c3 24 9c			jp macro_next 
9dbb				endm 
# End of macro NEXTW
9dbb			;endif 
9dbb			 
9dbb			.EXEC: 
9dbb			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9dbb			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9dbb			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9dbb			;; > > 
9dbb			;; > >   
9dbb			;	STACKFRAME OFF $5efe $5f9f 
9dbb			; 
9dbb			;		if DEBUG_FORTH_WORDS_KEY 
9dbb			;			DMARK "EXE" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			; 
9dbb			;	FORTH_DSP_VALUEHL 
9dbb			; 
9dbb			;	FORTH_DSP_POP 
9dbb			; 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EX1" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			;;	ld e,(hl) 
9dbb			;;	inc hl 
9dbb			;;	ld d,(hl) 
9dbb			;;	ex de,hl 
9dbb			; 
9dbb			;;		if DEBUG_FORTH_WORDS 
9dbb			;;			DMARK "EX2" 
9dbb			;;			CALLMONITOR 
9dbb			;;		endif 
9dbb			;	push hl 
9dbb			; 
9dbb			;	;ld a, 0 
9dbb			;	;ld a, FORTH_END_BUFFER 
9dbb			;	call strlenz 
9dbb			;	inc hl   ; include zero term to copy 
9dbb			;	inc hl   ; include term 
9dbb			;	inc hl   ; include term 
9dbb			;	ld b,0 
9dbb			;	ld c,l 
9dbb			;	pop hl 
9dbb			;	ld de, execscratch 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EX3" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			;	ldir 
9dbb			; 
9dbb			; 
9dbb			;	ld hl, execscratch 
9dbb			; 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EXe" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			; 
9dbb			;	call forthparse 
9dbb			;	call forthexec 
9dbb			;;	call forthexec_cleanup 
9dbb			;;	call forthparse 
9dbb			;;	call forthexec 
9dbb			; 
9dbb			;	STACKFRAMECHK OFF $5efe $5f9f 
9dbb			; 
9dbb			;	; an immediate word so no need to process any more words 
9dbb			;	ret 
9dbb			;	NEXTW 
9dbb			 
9dbb			; dead code - old version  
9dbb			;	FORTH_RSP_NEXT 
9dbb			 
9dbb			;  
9dbb			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9dbb			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9dbb			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9dbb			;	push hl 
9dbb			;	push de 
9dbb			;	push bc 
9dbb			; 
9dbb			; 
9dbb			;		if DEBUG_FORTH_WORDS_KEY 
9dbb			;			DMARK "EXR" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			; 
9dbb			; 
9dbb			; 
9dbb			;	;v5 FORTH_DSP_VALUE 
9dbb			;	FORTH_DSP_VALUEHL 
9dbb			; 
9dbb			;	; TODO do string type checks 
9dbb			; 
9dbb			;;v5	inc hl   ; skip type 
9dbb			; 
9dbb			;	push hl  ; source code  
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EX1" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			;	ld a, 0 
9dbb			;	call strlent 
9dbb			; 
9dbb			;	inc hl 
9dbb			;	inc hl 
9dbb			;	inc hl 
9dbb			;	inc hl 
9dbb			; 
9dbb			;	push hl    ; size 
9dbb			; 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EX2" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			;	call malloc 
9dbb			; 
9dbb			;	ex de, hl    ; de now contains malloc area 
9dbb			;	pop bc   	; get byte count 
9dbb			;	pop hl      ; get string to copy 
9dbb			; 
9dbb			;	push de     ; save malloc for free later 
9dbb			; 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EX3" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			;	ldir       ; duplicate string 
9dbb			; 
9dbb			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9dbb			;	 
9dbb			;	; TODO fix the parse would be better than this...  
9dbb			;	ex de, hl 
9dbb			;	dec hl 
9dbb			;	ld a, 0 
9dbb			;	ld (hl), a 
9dbb			;	dec hl 
9dbb			;	ld a, ' ' 
9dbb			;	ld (hl), a 
9dbb			;	dec hl 
9dbb			;	ld (hl), a 
9dbb			; 
9dbb			;	dec hl 
9dbb			;	ld (hl), a 
9dbb			; 
9dbb			; 
9dbb			;	FORTH_DSP_POP  
9dbb			; 
9dbb			;	pop hl     
9dbb			;	push hl    ; save malloc area 
9dbb			; 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EX4" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			; 
9dbb			;	call forthparse 
9dbb			;	call forthexec 
9dbb			;	 
9dbb			;	pop hl 
9dbb			;	if DEBUG_FORTH_WORDS 
9dbb			;		DMARK "EX5" 
9dbb			;		CALLMONITOR 
9dbb			;	endif 
9dbb			; 
9dbb			;	if FORTH_ENABLE_FREE 
9dbb			;	call free 
9dbb			;	endif 
9dbb			; 
9dbb			;	if DEBUG_FORTH_WORDS 
9dbb			;		DMARK "EX6" 
9dbb			;		CALLMONITOR 
9dbb			;	endif 
9dbb			; 
9dbb			;	pop bc 
9dbb			;	pop de 
9dbb			;	pop hl 
9dbb			;;	FORTH_RSP_POP	  
9dbb			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9dbb			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9dbb			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9dbb			; 
9dbb			;	if DEBUG_FORTH_WORDS 
9dbb			;		DMARK "EX7" 
9dbb			;		CALLMONITOR 
9dbb			;	endif 
9dbb			;	NEXTW 
9dbb			 
9dbb			;.STKEXEC: 
9dbb			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9dbb			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9dbb			; 
9dbb			; 
9dbb			;		if DEBUG_FORTH_WORDS_KEY 
9dbb			;			DMARK "STX" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			; 
9dbb			;	FORTH_DSP_VALUEHL 
9dbb			; 
9dbb			;	ld (store_tmp1), hl    ; count 
9dbb			; 
9dbb			;	FORTH_DSP_POP 
9dbb			;.stkexec1: 
9dbb			;	ld hl, (store_tmp1)   ; count 
9dbb			;	ld a, 0 
9dbb			;	cp l 
9dbb			;	ret z 
9dbb			; 
9dbb			;	dec hl 
9dbb			;	ld (store_tmp1), hl    ; count 
9dbb			;	 
9dbb			;	FORTH_DSP_VALUEHL 
9dbb			;	push hl 
9dbb			;	 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EXp" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			;	FORTH_DSP_POP 
9dbb			; 
9dbb			;	call strlenz 
9dbb			;	inc hl   ; include zero term to copy 
9dbb			;	inc hl   ; include zero term to copy 
9dbb			;	inc hl   ; include zero term to copy 
9dbb			;	ld b,0 
9dbb			;	ld c,l 
9dbb			;	pop hl 
9dbb			;	ld de, execscratch 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EX3" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			;	ldir 
9dbb			; 
9dbb			; 
9dbb			;	ld hl, execscratch 
9dbb			; 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EXP" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			; 
9dbb			;	call forthparse 
9dbb			;	ld hl, execscratch 
9dbb			;		if DEBUG_FORTH_WORDS 
9dbb			;			DMARK "EXx" 
9dbb			;			CALLMONITOR 
9dbb			;		endif 
9dbb			;	call forthexec 
9dbb			; 
9dbb			;	jp .stkexec1 
9dbb			; 
9dbb			;	ret 
9dbb			 
9dbb			 
9dbb			.DUP: 
9dbb				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9dbb 17				db WORD_SYS_CORE+OPCODE_DUP             
9dbc 31 9e			dw .ZDUP            
9dbe 04				db 3 + 1 
9dbf .. 00			db "DUP",0              
9dc3				endm 
# End of macro CWHEAD
9dc3			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9dc3			 
9dc3					if DEBUG_FORTH_WORDS_KEY 
9dc3						DMARK "DUP" 
9dc3 f5				push af  
9dc4 3a d8 9d			ld a, (.dmark)  
9dc7 32 c0 ee			ld (debug_mark),a  
9dca 3a d9 9d			ld a, (.dmark+1)  
9dcd 32 c1 ee			ld (debug_mark+1),a  
9dd0 3a da 9d			ld a, (.dmark+2)  
9dd3 32 c2 ee			ld (debug_mark+2),a  
9dd6 18 03			jr .pastdmark  
9dd8 ..			.dmark: db "DUP"  
9ddb f1			.pastdmark: pop af  
9ddc			endm  
# End of macro DMARK
9ddc						CALLMONITOR 
9ddc cd 2e 93			call break_point_state  
9ddf				endm  
# End of macro CALLMONITOR
9ddf					endif 
9ddf			 
9ddf					FORTH_DSP 
9ddf cd 78 9a			call macro_forth_dsp 
9de2				endm 
# End of macro FORTH_DSP
9de2			 
9de2 7e					ld a, (HL) 
9de3 fe 01				cp DS_TYPE_STR 
9de5 20 25				jr nz, .dupinum 
9de7			 
9de7					; push another string 
9de7			 
9de7					FORTH_DSP_VALUEHL     		 
9de7 cd b2 9a			call macro_dsp_valuehl 
9dea				endm 
# End of macro FORTH_DSP_VALUEHL
9dea			 
9dea				if DEBUG_FORTH_WORDS 
9dea					DMARK "DUs" 
9dea f5				push af  
9deb 3a ff 9d			ld a, (.dmark)  
9dee 32 c0 ee			ld (debug_mark),a  
9df1 3a 00 9e			ld a, (.dmark+1)  
9df4 32 c1 ee			ld (debug_mark+1),a  
9df7 3a 01 9e			ld a, (.dmark+2)  
9dfa 32 c2 ee			ld (debug_mark+2),a  
9dfd 18 03			jr .pastdmark  
9dff ..			.dmark: db "DUs"  
9e02 f1			.pastdmark: pop af  
9e03			endm  
# End of macro DMARK
9e03					CALLMONITOR 
9e03 cd 2e 93			call break_point_state  
9e06				endm  
# End of macro CALLMONITOR
9e06				endif 
9e06 cd 29 99				call forth_push_str 
9e09			 
9e09					NEXTW 
9e09 c3 24 9c			jp macro_next 
9e0c				endm 
# End of macro NEXTW
9e0c			 
9e0c			 
9e0c			.dupinum: 
9e0c					 
9e0c			 
9e0c			 
9e0c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9e0c cd b2 9a			call macro_dsp_valuehl 
9e0f				endm 
# End of macro FORTH_DSP_VALUEHL
9e0f			 
9e0f				; TODO add floating point number detection 
9e0f			 
9e0f				if DEBUG_FORTH_WORDS 
9e0f					DMARK "DUi" 
9e0f f5				push af  
9e10 3a 24 9e			ld a, (.dmark)  
9e13 32 c0 ee			ld (debug_mark),a  
9e16 3a 25 9e			ld a, (.dmark+1)  
9e19 32 c1 ee			ld (debug_mark+1),a  
9e1c 3a 26 9e			ld a, (.dmark+2)  
9e1f 32 c2 ee			ld (debug_mark+2),a  
9e22 18 03			jr .pastdmark  
9e24 ..			.dmark: db "DUi"  
9e27 f1			.pastdmark: pop af  
9e28			endm  
# End of macro DMARK
9e28					CALLMONITOR 
9e28 cd 2e 93			call break_point_state  
9e2b				endm  
# End of macro CALLMONITOR
9e2b				endif 
9e2b			 
9e2b cd bb 98				call forth_push_numhl 
9e2e					NEXTW 
9e2e c3 24 9c			jp macro_next 
9e31				endm 
# End of macro NEXTW
9e31			.ZDUP: 
9e31				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9e31 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9e32 69 9e			dw .SWAP            
9e34 05				db 4 + 1 
9e35 .. 00			db "?DUP",0              
9e3a				endm 
# End of macro CWHEAD
9e3a			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
9e3a			 
9e3a					if DEBUG_FORTH_WORDS_KEY 
9e3a						DMARK "qDU" 
9e3a f5				push af  
9e3b 3a 4f 9e			ld a, (.dmark)  
9e3e 32 c0 ee			ld (debug_mark),a  
9e41 3a 50 9e			ld a, (.dmark+1)  
9e44 32 c1 ee			ld (debug_mark+1),a  
9e47 3a 51 9e			ld a, (.dmark+2)  
9e4a 32 c2 ee			ld (debug_mark+2),a  
9e4d 18 03			jr .pastdmark  
9e4f ..			.dmark: db "qDU"  
9e52 f1			.pastdmark: pop af  
9e53			endm  
# End of macro DMARK
9e53						CALLMONITOR 
9e53 cd 2e 93			call break_point_state  
9e56				endm  
# End of macro CALLMONITOR
9e56					endif 
9e56					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9e56 cd b2 9a			call macro_dsp_valuehl 
9e59				endm 
# End of macro FORTH_DSP_VALUEHL
9e59			 
9e59 e5					push hl 
9e5a			 
9e5a					; is it a zero? 
9e5a			 
9e5a 3e 00				ld a, 0 
9e5c 84					add h 
9e5d 85					add l 
9e5e			 
9e5e e1					pop hl 
9e5f			 
9e5f fe 00				cp 0 
9e61 28 03				jr z, .dup2orig 
9e63			 
9e63			 
9e63 cd bb 98				call forth_push_numhl 
9e66			 
9e66			 
9e66				; TODO add floating point number detection 
9e66			 
9e66			.dup2orig: 
9e66			 
9e66					NEXTW 
9e66 c3 24 9c			jp macro_next 
9e69				endm 
# End of macro NEXTW
9e69			.SWAP: 
9e69				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
9e69 18				db WORD_SYS_CORE+OPCODE_SWAP             
9e6a a8 9e			dw .COLN            
9e6c 05				db 4 + 1 
9e6d .. 00			db "SWAP",0              
9e72				endm 
# End of macro CWHEAD
9e72			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
9e72					if DEBUG_FORTH_WORDS_KEY 
9e72						DMARK "SWP" 
9e72 f5				push af  
9e73 3a 87 9e			ld a, (.dmark)  
9e76 32 c0 ee			ld (debug_mark),a  
9e79 3a 88 9e			ld a, (.dmark+1)  
9e7c 32 c1 ee			ld (debug_mark+1),a  
9e7f 3a 89 9e			ld a, (.dmark+2)  
9e82 32 c2 ee			ld (debug_mark+2),a  
9e85 18 03			jr .pastdmark  
9e87 ..			.dmark: db "SWP"  
9e8a f1			.pastdmark: pop af  
9e8b			endm  
# End of macro DMARK
9e8b						CALLMONITOR 
9e8b cd 2e 93			call break_point_state  
9e8e				endm  
# End of macro CALLMONITOR
9e8e					endif 
9e8e			 
9e8e					FORTH_DSP_VALUEHL 
9e8e cd b2 9a			call macro_dsp_valuehl 
9e91				endm 
# End of macro FORTH_DSP_VALUEHL
9e91 e5					push hl     ; w2 
9e92			 
9e92					FORTH_DSP_POP 
9e92 cd 6a 9b			call macro_forth_dsp_pop 
9e95				endm 
# End of macro FORTH_DSP_POP
9e95			 
9e95					FORTH_DSP_VALUEHL 
9e95 cd b2 9a			call macro_dsp_valuehl 
9e98				endm 
# End of macro FORTH_DSP_VALUEHL
9e98			 
9e98					FORTH_DSP_POP 
9e98 cd 6a 9b			call macro_forth_dsp_pop 
9e9b				endm 
# End of macro FORTH_DSP_POP
9e9b			 
9e9b d1					pop de     ; w2	, hl = w1 
9e9c			 
9e9c eb					ex de, hl 
9e9d d5					push de 
9e9e			 
9e9e cd bb 98				call forth_push_numhl 
9ea1			 
9ea1 e1					pop hl 
9ea2			 
9ea2 cd bb 98				call forth_push_numhl 
9ea5					 
9ea5			 
9ea5					NEXTW 
9ea5 c3 24 9c			jp macro_next 
9ea8				endm 
# End of macro NEXTW
9ea8			.COLN: 
9ea8				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
9ea8 19				db WORD_SYS_CORE+OPCODE_COLN             
9ea9 34 a0			dw .SCOLN            
9eab 02				db 1 + 1 
9eac .. 00			db ":",0              
9eae				endm 
# End of macro CWHEAD
9eae			; | : ( -- )         Create new word | DONE 
9eae			 
9eae					if DEBUG_FORTH_WORDS_KEY 
9eae						DMARK "CLN" 
9eae f5				push af  
9eaf 3a c3 9e			ld a, (.dmark)  
9eb2 32 c0 ee			ld (debug_mark),a  
9eb5 3a c4 9e			ld a, (.dmark+1)  
9eb8 32 c1 ee			ld (debug_mark+1),a  
9ebb 3a c5 9e			ld a, (.dmark+2)  
9ebe 32 c2 ee			ld (debug_mark+2),a  
9ec1 18 03			jr .pastdmark  
9ec3 ..			.dmark: db "CLN"  
9ec6 f1			.pastdmark: pop af  
9ec7			endm  
# End of macro DMARK
9ec7						CALLMONITOR 
9ec7 cd 2e 93			call break_point_state  
9eca				endm  
# End of macro CALLMONITOR
9eca					endif 
9eca				STACKFRAME OFF $8efe $989f 
9eca				if DEBUG_STACK_IMB 
9eca					if OFF 
9eca						exx 
9eca						ld de, $8efe 
9eca						ld a, d 
9eca						ld hl, curframe 
9eca						call hexout 
9eca						ld a, e 
9eca						ld hl, curframe+2 
9eca						call hexout 
9eca						ld hl, $8efe 
9eca						push hl 
9eca						ld hl, $989f 
9eca						push hl 
9eca						exx 
9eca					endif 
9eca				endif 
9eca			endm 
# End of macro STACKFRAME
9eca				; get parser buffer length  of new word 
9eca			 
9eca				 
9eca			 
9eca					; move tok past this to start of name defintition 
9eca					; TODO get word to define 
9eca					; TODO Move past word token 
9eca					; TODO get length of string up to the ';' 
9eca			 
9eca 2a e7 e7			ld hl, (os_tok_ptr) 
9ecd 23				inc hl 
9ece 23				inc hl 
9ecf			 
9ecf 3e 3b			ld a, ';' 
9ed1 cd 24 8f			call strlent 
9ed4			 
9ed4 7d				ld a,l 
9ed5 32 e2 e4			ld (os_new_parse_len), a 
9ed8			 
9ed8			 
9ed8			if DEBUG_FORTH_UWORD 
9ed8 ed 5b e7 e7		ld de, (os_tok_ptr) 
9edc						DMARK ":01" 
9edc f5				push af  
9edd 3a f1 9e			ld a, (.dmark)  
9ee0 32 c0 ee			ld (debug_mark),a  
9ee3 3a f2 9e			ld a, (.dmark+1)  
9ee6 32 c1 ee			ld (debug_mark+1),a  
9ee9 3a f3 9e			ld a, (.dmark+2)  
9eec 32 c2 ee			ld (debug_mark+2),a  
9eef 18 03			jr .pastdmark  
9ef1 ..			.dmark: db ":01"  
9ef4 f1			.pastdmark: pop af  
9ef5			endm  
# End of macro DMARK
9ef5				CALLMONITOR 
9ef5 cd 2e 93			call break_point_state  
9ef8				endm  
# End of macro CALLMONITOR
9ef8			endif 
9ef8			 
9ef8			; 
9ef8			;  new word memory layout: 
9ef8			;  
9ef8			;    : adg 6666 ;  
9ef8			; 
9ef8			;    db   1     ; user defined word  
9ef8 23				inc hl    
9ef9			;    dw   sysdict 
9ef9 23				inc hl 
9efa 23				inc hl 
9efb			;    db <word len>+1 (for null) 
9efb 23				inc hl 
9efc			;    db .... <word> 
9efc			; 
9efc			 
9efc 23				inc hl    ; some extras for the word preamble before the above 
9efd 23				inc hl 
9efe 23				inc hl 
9eff 23				inc hl 
9f00 23				inc hl 
9f01 23				inc hl 
9f02 23				inc hl  
9f03 23				inc hl 
9f04 23				inc hl 
9f05 23				inc hl 
9f06 23				inc hl 
9f07 23				inc hl 
9f08 23				inc hl 
9f09 23				inc hl     ; TODO how many do we really need?     maybe only 6 
9f0a			;       exec word buffer 
9f0a			;	<ptr word>   
9f0a 23				inc hl 
9f0b 23				inc hl 
9f0c			;       <word list><null term> 7F final term 
9f0c			 
9f0c			 
9f0c			if DEBUG_FORTH_UWORD 
9f0c						DMARK ":02" 
9f0c f5				push af  
9f0d 3a 21 9f			ld a, (.dmark)  
9f10 32 c0 ee			ld (debug_mark),a  
9f13 3a 22 9f			ld a, (.dmark+1)  
9f16 32 c1 ee			ld (debug_mark+1),a  
9f19 3a 23 9f			ld a, (.dmark+2)  
9f1c 32 c2 ee			ld (debug_mark+2),a  
9f1f 18 03			jr .pastdmark  
9f21 ..			.dmark: db ":02"  
9f24 f1			.pastdmark: pop af  
9f25			endm  
# End of macro DMARK
9f25				CALLMONITOR 
9f25 cd 2e 93			call break_point_state  
9f28				endm  
# End of macro CALLMONITOR
9f28			endif 
9f28			 
9f28				 
9f28					; malloc the size 
9f28			 
9f28 cd 82 8f				call malloc 
9f2b 22 e4 e4				ld (os_new_malloc), hl     ; save malloc start 
9f2e			 
9f2e			;    db   1     ; user defined word  
9f2e 3e 01				ld a, WORD_SYS_UWORD  
9f30 77					ld (hl), a 
9f31				 
9f31 23				inc hl    
9f32			;    dw   sysdict 
9f32 11 7c 9d			ld de, sysdict       ; continue on with the scan to the system dict 
9f35 73				ld (hl), e 
9f36 23				inc hl 
9f37 72				ld (hl), d 
9f38 23				inc hl 
9f39			 
9f39			 
9f39			;    Setup dict word 
9f39			 
9f39 23				inc hl 
9f3a 22 de e4			ld (os_new_work_ptr), hl     ; save start of dict word  
9f3d			 
9f3d				; 1. get length of dict word 
9f3d			 
9f3d			 
9f3d 2a e7 e7			ld hl, (os_tok_ptr) 
9f40 23				inc hl 
9f41 23				inc hl    ; position to start of dict word 
9f42 3e 00			ld a, 0 
9f44 cd 24 8f			call strlent 
9f47			 
9f47			 
9f47 23				inc hl    ; to include null??? 
9f48			 
9f48				; write length of dict word 
9f48			 
9f48 ed 5b de e4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9f4c 1b				dec de 
9f4d eb				ex de, hl 
9f4e 73				ld (hl), e 
9f4f eb				ex de, hl 
9f50			 
9f50				 
9f50			 
9f50				; copy  
9f50 4d				ld c, l 
9f51 06 00			ld b, 0 
9f53 ed 5b de e4		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9f57 2a e7 e7			ld hl, (os_tok_ptr) 
9f5a 23				inc hl 
9f5b 23				inc hl    ; position to start of dict word 
9f5c				 
9f5c			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
9f5c				 
9f5c				; TODO need to convert word to upper case 
9f5c			 
9f5c			ucasetok:	 
9f5c 7e				ld a,(hl) 
9f5d cd 10 8f			call toUpper 
9f60 77				ld (hl),a 
9f61 ed a0			ldi 
9f63 f2 5c 9f		 	jp p, ucasetok 
9f66			 
9f66			 
9f66			 
9f66				; de now points to start of where the word body code should be placed 
9f66 ed 53 de e4		ld (os_new_work_ptr), de 
9f6a				; hl now points to the words to throw at forthexec which needs to be copied 
9f6a 22 dc e4			ld (os_new_src_ptr), hl 
9f6d			 
9f6d				; TODO add 'call to forthexec' 
9f6d			 
9f6d			if DEBUG_FORTH_UWORD 
9f6d c5				push bc 
9f6e ed 4b e4 e4		ld bc, (os_new_malloc) 
9f72						DMARK ":0x" 
9f72 f5				push af  
9f73 3a 87 9f			ld a, (.dmark)  
9f76 32 c0 ee			ld (debug_mark),a  
9f79 3a 88 9f			ld a, (.dmark+1)  
9f7c 32 c1 ee			ld (debug_mark+1),a  
9f7f 3a 89 9f			ld a, (.dmark+2)  
9f82 32 c2 ee			ld (debug_mark+2),a  
9f85 18 03			jr .pastdmark  
9f87 ..			.dmark: db ":0x"  
9f8a f1			.pastdmark: pop af  
9f8b			endm  
# End of macro DMARK
9f8b				CALLMONITOR 
9f8b cd 2e 93			call break_point_state  
9f8e				endm  
# End of macro CALLMONITOR
9f8e c1				pop bc 
9f8f			endif 
9f8f			 
9f8f			 
9f8f				; create word preamble which should be: 
9f8f			 
9f8f			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
9f8f			 
9f8f				;    ld hl, <word code> 
9f8f				;    jp user_exec 
9f8f			        ;    <word code bytes> 
9f8f			 
9f8f			 
9f8f			;	inc de     ; TODO ??? or are we already past the word's null 
9f8f eb				ex de, hl 
9f90			 
9f90 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
9f92			 
9f92 23				inc hl 
9f93 22 d8 e4			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
9f96 23				inc hl 
9f97			 
9f97 23				inc hl 
9f98 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
9f9a			 
9f9a 01 67 c3			ld bc, user_exec 
9f9d 23				inc hl 
9f9e 71				ld (hl), c     ; poke address of user_exec 
9f9f 23				inc hl 
9fa0 70				ld (hl), b     
9fa1			 ; 
9fa1			;	inc hl 
9fa1			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9fa1			; 
9fa1			; 
9fa1			;	ld bc, macro_forth_rsp_next 
9fa1			;	inc hl 
9fa1			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
9fa1			;	inc hl 
9fa1			;	ld (hl), b     
9fa1			 ; 
9fa1			;	inc hl 
9fa1			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9fa1			; 
9fa1			; 
9fa1			;	inc hl 
9fa1			;	ld bc, forthexec 
9fa1			;	ld (hl), c     ; poke address of forthexec 
9fa1			;	inc hl 
9fa1			;	ld (hl), b      
9fa1			; 
9fa1			;	inc hl 
9fa1			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
9fa1			; 
9fa1			;	ld bc, user_dict_next 
9fa1			;	inc hl 
9fa1			;	ld (hl), c     ; poke address of forthexec 
9fa1			;	inc hl 
9fa1			;	ld (hl), b      
9fa1			 
9fa1				; hl is now where we need to copy the word byte data to save this 
9fa1			 
9fa1 23				inc hl 
9fa2 22 da e4			ld (os_new_exec), hl 
9fa5				 
9fa5				; copy definition 
9fa5			 
9fa5 eb				ex de, hl 
9fa6			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
9fa6			;	inc de    ; skip the PC for this parse 
9fa6 3a e2 e4			ld a, (os_new_parse_len) 
9fa9 4f				ld c, a 
9faa 06 00			ld b, 0 
9fac ed b0			ldir		 ; copy defintion 
9fae			 
9fae			 
9fae				; poke the address of where the new word bytes live for forthexec 
9fae			 
9fae 2a d8 e4			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
9fb1			 
9fb1 ed 5b da e4		ld de, (os_new_exec)      
9fb5				 
9fb5 73				ld (hl), e 
9fb6 23				inc hl 
9fb7 72				ld (hl), d 
9fb8			 
9fb8					; TODO copy last user dict word next link to this word 
9fb8					; TODO update last user dict word to point to this word 
9fb8			; 
9fb8			; hl f923 de 812a ; bc 811a 
9fb8			 
9fb8			if DEBUG_FORTH_UWORD 
9fb8 c5				push bc 
9fb9 ed 4b e4 e4		ld bc, (os_new_malloc) 
9fbd						DMARK ":0A" 
9fbd f5				push af  
9fbe 3a d2 9f			ld a, (.dmark)  
9fc1 32 c0 ee			ld (debug_mark),a  
9fc4 3a d3 9f			ld a, (.dmark+1)  
9fc7 32 c1 ee			ld (debug_mark+1),a  
9fca 3a d4 9f			ld a, (.dmark+2)  
9fcd 32 c2 ee			ld (debug_mark+2),a  
9fd0 18 03			jr .pastdmark  
9fd2 ..			.dmark: db ":0A"  
9fd5 f1			.pastdmark: pop af  
9fd6			endm  
# End of macro DMARK
9fd6				CALLMONITOR 
9fd6 cd 2e 93			call break_point_state  
9fd9				endm  
# End of macro CALLMONITOR
9fd9 c1				pop bc 
9fda			endif 
9fda			if DEBUG_FORTH_UWORD 
9fda c5				push bc 
9fdb ed 4b e4 e4		ld bc, (os_new_malloc) 
9fdf 03				inc bc 
9fe0 03				inc bc 
9fe1 03				inc bc 
9fe2 03				inc bc 
9fe3 03				inc bc 
9fe4 03				inc bc 
9fe5 03				inc bc 
9fe6 03				inc bc 
9fe7			 
9fe7						DMARK ":0B" 
9fe7 f5				push af  
9fe8 3a fc 9f			ld a, (.dmark)  
9feb 32 c0 ee			ld (debug_mark),a  
9fee 3a fd 9f			ld a, (.dmark+1)  
9ff1 32 c1 ee			ld (debug_mark+1),a  
9ff4 3a fe 9f			ld a, (.dmark+2)  
9ff7 32 c2 ee			ld (debug_mark+2),a  
9ffa 18 03			jr .pastdmark  
9ffc ..			.dmark: db ":0B"  
9fff f1			.pastdmark: pop af  
a000			endm  
# End of macro DMARK
a000				CALLMONITOR 
a000 cd 2e 93			call break_point_state  
a003				endm  
# End of macro CALLMONITOR
a003 c1				pop bc 
a004			endif 
a004			 
a004			; update word dict linked list for new word 
a004			 
a004			 
a004 2a e3 e7		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a007 23			inc hl     ; move to next work linked list ptr 
a008			 
a008 ed 5b e4 e4	ld de, (os_new_malloc)		 ; new next word 
a00c 73			ld (hl), e 
a00d 23			inc hl 
a00e 72			ld (hl), d 
a00f			 
a00f			if DEBUG_FORTH_UWORD 
a00f ed 4b e3 e7		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a013			endif 
a013			 
a013 ed 53 e3 e7	ld (os_last_new_uword), de      ; update last new uword ptr 
a017			 
a017			 
a017			if DEBUG_FORTH_UWORD 
a017						DMARK ":0+" 
a017 f5				push af  
a018 3a 2c a0			ld a, (.dmark)  
a01b 32 c0 ee			ld (debug_mark),a  
a01e 3a 2d a0			ld a, (.dmark+1)  
a021 32 c1 ee			ld (debug_mark+1),a  
a024 3a 2e a0			ld a, (.dmark+2)  
a027 32 c2 ee			ld (debug_mark+2),a  
a02a 18 03			jr .pastdmark  
a02c ..			.dmark: db ":0+"  
a02f f1			.pastdmark: pop af  
a030			endm  
# End of macro DMARK
a030				CALLMONITOR 
a030 cd 2e 93			call break_point_state  
a033				endm  
# End of macro CALLMONITOR
a033			endif 
a033			 
a033				STACKFRAMECHK OFF $8efe $989f 
a033				if DEBUG_STACK_IMB 
a033					if OFF 
a033						exx 
a033						ld hl, $989f 
a033						pop de   ; $989f 
a033						call cmp16 
a033						jr nz, .spnosame 
a033						ld hl, $8efe 
a033						pop de   ; $8efe 
a033						call cmp16 
a033						jr z, .spfrsame 
a033						.spnosame: call showsperror 
a033						.spfrsame: nop 
a033						exx 
a033					endif 
a033				endif 
a033			endm 
# End of macro STACKFRAMECHK
a033			 
a033 c9			ret    ; dont process any remaining parser tokens as they form new word 
a034			 
a034			 
a034			 
a034			 
a034			;		NEXT 
a034			.SCOLN: 
a034			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a034 06				db OPCODE_SCOLN 
a035 80 a0			dw .DROP 
a037 02				db 2 
a038 .. 00			db ";",0           
a03a			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a03a					if DEBUG_FORTH_WORDS_KEY 
a03a						DMARK "SCN" 
a03a f5				push af  
a03b 3a 4f a0			ld a, (.dmark)  
a03e 32 c0 ee			ld (debug_mark),a  
a041 3a 50 a0			ld a, (.dmark+1)  
a044 32 c1 ee			ld (debug_mark+1),a  
a047 3a 51 a0			ld a, (.dmark+2)  
a04a 32 c2 ee			ld (debug_mark+2),a  
a04d 18 03			jr .pastdmark  
a04f ..			.dmark: db "SCN"  
a052 f1			.pastdmark: pop af  
a053			endm  
# End of macro DMARK
a053						CALLMONITOR 
a053 cd 2e 93			call break_point_state  
a056				endm  
# End of macro CALLMONITOR
a056					endif 
a056					FORTH_RSP_TOS 
a056 cd 79 98			call macro_forth_rsp_tos 
a059				endm 
# End of macro FORTH_RSP_TOS
a059 e5					push hl 
a05a					FORTH_RSP_POP 
a05a cd 83 98			call macro_forth_rsp_pop 
a05d				endm 
# End of macro FORTH_RSP_POP
a05d e1					pop hl 
a05e			;		ex de,hl 
a05e 22 e7 e7				ld (os_tok_ptr),hl 
a061			 
a061			if DEBUG_FORTH_UWORD 
a061						DMARK "SCL" 
a061 f5				push af  
a062 3a 76 a0			ld a, (.dmark)  
a065 32 c0 ee			ld (debug_mark),a  
a068 3a 77 a0			ld a, (.dmark+1)  
a06b 32 c1 ee			ld (debug_mark+1),a  
a06e 3a 78 a0			ld a, (.dmark+2)  
a071 32 c2 ee			ld (debug_mark+2),a  
a074 18 03			jr .pastdmark  
a076 ..			.dmark: db "SCL"  
a079 f1			.pastdmark: pop af  
a07a			endm  
# End of macro DMARK
a07a				CALLMONITOR 
a07a cd 2e 93			call break_point_state  
a07d				endm  
# End of macro CALLMONITOR
a07d			endif 
a07d					NEXTW 
a07d c3 24 9c			jp macro_next 
a080				endm 
# End of macro NEXTW
a080			 
a080			.DROP: 
a080				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a080 1b				db WORD_SYS_CORE+OPCODE_DROP             
a081 ab a0			dw .DUP2            
a083 05				db 4 + 1 
a084 .. 00			db "DROP",0              
a089				endm 
# End of macro CWHEAD
a089			; | DROP ( w -- )   drop the TOS item   | DONE 
a089					if DEBUG_FORTH_WORDS_KEY 
a089						DMARK "DRP" 
a089 f5				push af  
a08a 3a 9e a0			ld a, (.dmark)  
a08d 32 c0 ee			ld (debug_mark),a  
a090 3a 9f a0			ld a, (.dmark+1)  
a093 32 c1 ee			ld (debug_mark+1),a  
a096 3a a0 a0			ld a, (.dmark+2)  
a099 32 c2 ee			ld (debug_mark+2),a  
a09c 18 03			jr .pastdmark  
a09e ..			.dmark: db "DRP"  
a0a1 f1			.pastdmark: pop af  
a0a2			endm  
# End of macro DMARK
a0a2						CALLMONITOR 
a0a2 cd 2e 93			call break_point_state  
a0a5				endm  
# End of macro CALLMONITOR
a0a5					endif 
a0a5					FORTH_DSP_POP 
a0a5 cd 6a 9b			call macro_forth_dsp_pop 
a0a8				endm 
# End of macro FORTH_DSP_POP
a0a8					NEXTW 
a0a8 c3 24 9c			jp macro_next 
a0ab				endm 
# End of macro NEXTW
a0ab			.DUP2: 
a0ab				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a0ab 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a0ac f0 a0			dw .DROP2            
a0ae 05				db 4 + 1 
a0af .. 00			db "2DUP",0              
a0b4				endm 
# End of macro CWHEAD
a0b4			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a0b4					if DEBUG_FORTH_WORDS_KEY 
a0b4						DMARK "2DU" 
a0b4 f5				push af  
a0b5 3a c9 a0			ld a, (.dmark)  
a0b8 32 c0 ee			ld (debug_mark),a  
a0bb 3a ca a0			ld a, (.dmark+1)  
a0be 32 c1 ee			ld (debug_mark+1),a  
a0c1 3a cb a0			ld a, (.dmark+2)  
a0c4 32 c2 ee			ld (debug_mark+2),a  
a0c7 18 03			jr .pastdmark  
a0c9 ..			.dmark: db "2DU"  
a0cc f1			.pastdmark: pop af  
a0cd			endm  
# End of macro DMARK
a0cd						CALLMONITOR 
a0cd cd 2e 93			call break_point_state  
a0d0				endm  
# End of macro CALLMONITOR
a0d0					endif 
a0d0					FORTH_DSP_VALUEHL 
a0d0 cd b2 9a			call macro_dsp_valuehl 
a0d3				endm 
# End of macro FORTH_DSP_VALUEHL
a0d3 e5					push hl      ; 2 
a0d4			 
a0d4					FORTH_DSP_POP 
a0d4 cd 6a 9b			call macro_forth_dsp_pop 
a0d7				endm 
# End of macro FORTH_DSP_POP
a0d7					 
a0d7					FORTH_DSP_VALUEHL 
a0d7 cd b2 9a			call macro_dsp_valuehl 
a0da				endm 
# End of macro FORTH_DSP_VALUEHL
a0da			;		push hl      ; 1 
a0da			 
a0da					FORTH_DSP_POP 
a0da cd 6a 9b			call macro_forth_dsp_pop 
a0dd				endm 
# End of macro FORTH_DSP_POP
a0dd			 
a0dd			;		pop hl       ; 1 
a0dd d1					pop de       ; 2 
a0de			 
a0de cd bb 98				call forth_push_numhl 
a0e1 eb					ex de, hl 
a0e2 cd bb 98				call forth_push_numhl 
a0e5			 
a0e5					 
a0e5 eb					ex de, hl 
a0e6			 
a0e6 cd bb 98				call forth_push_numhl 
a0e9 eb					ex de, hl 
a0ea cd bb 98				call forth_push_numhl 
a0ed			 
a0ed			 
a0ed					NEXTW 
a0ed c3 24 9c			jp macro_next 
a0f0				endm 
# End of macro NEXTW
a0f0			.DROP2: 
a0f0				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a0f0 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a0f1 1f a1			dw .SWAP2            
a0f3 06				db 5 + 1 
a0f4 .. 00			db "2DROP",0              
a0fa				endm 
# End of macro CWHEAD
a0fa			; | 2DROP ( w w -- )    Double drop | DONE 
a0fa					if DEBUG_FORTH_WORDS_KEY 
a0fa						DMARK "2DR" 
a0fa f5				push af  
a0fb 3a 0f a1			ld a, (.dmark)  
a0fe 32 c0 ee			ld (debug_mark),a  
a101 3a 10 a1			ld a, (.dmark+1)  
a104 32 c1 ee			ld (debug_mark+1),a  
a107 3a 11 a1			ld a, (.dmark+2)  
a10a 32 c2 ee			ld (debug_mark+2),a  
a10d 18 03			jr .pastdmark  
a10f ..			.dmark: db "2DR"  
a112 f1			.pastdmark: pop af  
a113			endm  
# End of macro DMARK
a113						CALLMONITOR 
a113 cd 2e 93			call break_point_state  
a116				endm  
# End of macro CALLMONITOR
a116					endif 
a116					FORTH_DSP_POP 
a116 cd 6a 9b			call macro_forth_dsp_pop 
a119				endm 
# End of macro FORTH_DSP_POP
a119					FORTH_DSP_POP 
a119 cd 6a 9b			call macro_forth_dsp_pop 
a11c				endm 
# End of macro FORTH_DSP_POP
a11c					NEXTW 
a11c c3 24 9c			jp macro_next 
a11f				endm 
# End of macro NEXTW
a11f			.SWAP2: 
a11f				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a11f 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a120 48 a1			dw .AT            
a122 06				db 5 + 1 
a123 .. 00			db "2SWAP",0              
a129				endm 
# End of macro CWHEAD
a129			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a129					if DEBUG_FORTH_WORDS_KEY 
a129						DMARK "2SW" 
a129 f5				push af  
a12a 3a 3e a1			ld a, (.dmark)  
a12d 32 c0 ee			ld (debug_mark),a  
a130 3a 3f a1			ld a, (.dmark+1)  
a133 32 c1 ee			ld (debug_mark+1),a  
a136 3a 40 a1			ld a, (.dmark+2)  
a139 32 c2 ee			ld (debug_mark+2),a  
a13c 18 03			jr .pastdmark  
a13e ..			.dmark: db "2SW"  
a141 f1			.pastdmark: pop af  
a142			endm  
# End of macro DMARK
a142						CALLMONITOR 
a142 cd 2e 93			call break_point_state  
a145				endm  
# End of macro CALLMONITOR
a145					endif 
a145					NEXTW 
a145 c3 24 9c			jp macro_next 
a148				endm 
# End of macro NEXTW
a148			.AT: 
a148				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a148 1f				db WORD_SYS_CORE+OPCODE_AT             
a149 7a a1			dw .CAT            
a14b 02				db 1 + 1 
a14c .. 00			db "@",0              
a14e				endm 
# End of macro CWHEAD
a14e			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a14e			 
a14e					if DEBUG_FORTH_WORDS_KEY 
a14e						DMARK "AT." 
a14e f5				push af  
a14f 3a 63 a1			ld a, (.dmark)  
a152 32 c0 ee			ld (debug_mark),a  
a155 3a 64 a1			ld a, (.dmark+1)  
a158 32 c1 ee			ld (debug_mark+1),a  
a15b 3a 65 a1			ld a, (.dmark+2)  
a15e 32 c2 ee			ld (debug_mark+2),a  
a161 18 03			jr .pastdmark  
a163 ..			.dmark: db "AT."  
a166 f1			.pastdmark: pop af  
a167			endm  
# End of macro DMARK
a167						CALLMONITOR 
a167 cd 2e 93			call break_point_state  
a16a				endm  
# End of macro CALLMONITOR
a16a					endif 
a16a			.getbyteat:	 
a16a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a16a cd b2 9a			call macro_dsp_valuehl 
a16d				endm 
# End of macro FORTH_DSP_VALUEHL
a16d					 
a16d			;		push hl 
a16d				 
a16d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a16d cd 6a 9b			call macro_forth_dsp_pop 
a170				endm 
# End of macro FORTH_DSP_POP
a170			 
a170			;		pop hl 
a170			 
a170 7e					ld a, (hl) 
a171			 
a171 6f					ld l, a 
a172 26 00				ld h, 0 
a174 cd bb 98				call forth_push_numhl 
a177			 
a177					NEXTW 
a177 c3 24 9c			jp macro_next 
a17a				endm 
# End of macro NEXTW
a17a			.CAT: 
a17a				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a17a 20				db WORD_SYS_CORE+OPCODE_CAT             
a17b a3 a1			dw .BANG            
a17d 03				db 2 + 1 
a17e .. 00			db "C@",0              
a181				endm 
# End of macro CWHEAD
a181			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a181					if DEBUG_FORTH_WORDS_KEY 
a181						DMARK "CAA" 
a181 f5				push af  
a182 3a 96 a1			ld a, (.dmark)  
a185 32 c0 ee			ld (debug_mark),a  
a188 3a 97 a1			ld a, (.dmark+1)  
a18b 32 c1 ee			ld (debug_mark+1),a  
a18e 3a 98 a1			ld a, (.dmark+2)  
a191 32 c2 ee			ld (debug_mark+2),a  
a194 18 03			jr .pastdmark  
a196 ..			.dmark: db "CAA"  
a199 f1			.pastdmark: pop af  
a19a			endm  
# End of macro DMARK
a19a						CALLMONITOR 
a19a cd 2e 93			call break_point_state  
a19d				endm  
# End of macro CALLMONITOR
a19d					endif 
a19d c3 6a a1				jp .getbyteat 
a1a0					NEXTW 
a1a0 c3 24 9c			jp macro_next 
a1a3				endm 
# End of macro NEXTW
a1a3			.BANG: 
a1a3				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a1a3 21				db WORD_SYS_CORE+OPCODE_BANG             
a1a4 d9 a1			dw .CBANG            
a1a6 02				db 1 + 1 
a1a7 .. 00			db "!",0              
a1a9				endm 
# End of macro CWHEAD
a1a9			; | ! ( x w -- ) Store x at address w      | DONE 
a1a9					if DEBUG_FORTH_WORDS_KEY 
a1a9						DMARK "BNG" 
a1a9 f5				push af  
a1aa 3a be a1			ld a, (.dmark)  
a1ad 32 c0 ee			ld (debug_mark),a  
a1b0 3a bf a1			ld a, (.dmark+1)  
a1b3 32 c1 ee			ld (debug_mark+1),a  
a1b6 3a c0 a1			ld a, (.dmark+2)  
a1b9 32 c2 ee			ld (debug_mark+2),a  
a1bc 18 03			jr .pastdmark  
a1be ..			.dmark: db "BNG"  
a1c1 f1			.pastdmark: pop af  
a1c2			endm  
# End of macro DMARK
a1c2						CALLMONITOR 
a1c2 cd 2e 93			call break_point_state  
a1c5				endm  
# End of macro CALLMONITOR
a1c5					endif 
a1c5			 
a1c5			.storebyteat:		 
a1c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a1c5 cd b2 9a			call macro_dsp_valuehl 
a1c8				endm 
# End of macro FORTH_DSP_VALUEHL
a1c8					 
a1c8 e5					push hl 
a1c9				 
a1c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a1c9 cd 6a 9b			call macro_forth_dsp_pop 
a1cc				endm 
# End of macro FORTH_DSP_POP
a1cc			 
a1cc					; get byte to poke 
a1cc			 
a1cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a1cc cd b2 9a			call macro_dsp_valuehl 
a1cf				endm 
# End of macro FORTH_DSP_VALUEHL
a1cf e5					push hl 
a1d0			 
a1d0			 
a1d0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a1d0 cd 6a 9b			call macro_forth_dsp_pop 
a1d3				endm 
# End of macro FORTH_DSP_POP
a1d3			 
a1d3			 
a1d3 d1					pop de 
a1d4 e1					pop hl 
a1d5			 
a1d5 73					ld (hl),e 
a1d6			 
a1d6			 
a1d6					NEXTW 
a1d6 c3 24 9c			jp macro_next 
a1d9				endm 
# End of macro NEXTW
a1d9			.CBANG: 
a1d9				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a1d9 22				db WORD_SYS_CORE+OPCODE_CBANG             
a1da 02 a2			dw .SCALL            
a1dc 03				db 2 + 1 
a1dd .. 00			db "C!",0              
a1e0				endm 
# End of macro CWHEAD
a1e0			; | C!  ( x w -- ) Store x at address w  | DONE 
a1e0					if DEBUG_FORTH_WORDS_KEY 
a1e0						DMARK "CBA" 
a1e0 f5				push af  
a1e1 3a f5 a1			ld a, (.dmark)  
a1e4 32 c0 ee			ld (debug_mark),a  
a1e7 3a f6 a1			ld a, (.dmark+1)  
a1ea 32 c1 ee			ld (debug_mark+1),a  
a1ed 3a f7 a1			ld a, (.dmark+2)  
a1f0 32 c2 ee			ld (debug_mark+2),a  
a1f3 18 03			jr .pastdmark  
a1f5 ..			.dmark: db "CBA"  
a1f8 f1			.pastdmark: pop af  
a1f9			endm  
# End of macro DMARK
a1f9						CALLMONITOR 
a1f9 cd 2e 93			call break_point_state  
a1fc				endm  
# End of macro CALLMONITOR
a1fc					endif 
a1fc c3 c5 a1				jp .storebyteat 
a1ff					NEXTW 
a1ff c3 24 9c			jp macro_next 
a202				endm 
# End of macro NEXTW
a202			.SCALL: 
a202				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a202 23				db WORD_SYS_CORE+OPCODE_SCALL             
a203 36 a2			dw .DEPTH            
a205 05				db 4 + 1 
a206 .. 00			db "CALL",0              
a20b				endm 
# End of macro CWHEAD
a20b			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a20b					if DEBUG_FORTH_WORDS_KEY 
a20b						DMARK "CLL" 
a20b f5				push af  
a20c 3a 20 a2			ld a, (.dmark)  
a20f 32 c0 ee			ld (debug_mark),a  
a212 3a 21 a2			ld a, (.dmark+1)  
a215 32 c1 ee			ld (debug_mark+1),a  
a218 3a 22 a2			ld a, (.dmark+2)  
a21b 32 c2 ee			ld (debug_mark+2),a  
a21e 18 03			jr .pastdmark  
a220 ..			.dmark: db "CLL"  
a223 f1			.pastdmark: pop af  
a224			endm  
# End of macro DMARK
a224						CALLMONITOR 
a224 cd 2e 93			call break_point_state  
a227				endm  
# End of macro CALLMONITOR
a227					endif 
a227			 
a227					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a227 cd b2 9a			call macro_dsp_valuehl 
a22a				endm 
# End of macro FORTH_DSP_VALUEHL
a22a			 
a22a			;		push hl 
a22a			 
a22a					; destroy value TOS 
a22a			 
a22a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a22a cd 6a 9b			call macro_forth_dsp_pop 
a22d				endm 
# End of macro FORTH_DSP_POP
a22d			 
a22d						 
a22d			;		pop hl 
a22d			 
a22d					; how to do a call with hl???? save SP? 
a22d cd cd 9b				call forth_call_hl 
a230			 
a230			 
a230					; TODO push value back onto stack for another op etc 
a230			 
a230 cd bb 98				call forth_push_numhl 
a233					NEXTW 
a233 c3 24 9c			jp macro_next 
a236				endm 
# End of macro NEXTW
a236			.DEPTH: 
a236				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a236 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a237 73 a2			dw .OVER            
a239 06				db 5 + 1 
a23a .. 00			db "DEPTH",0              
a240				endm 
# End of macro CWHEAD
a240			; | DEPTH ( -- u ) Push count of stack | DONE 
a240					; take current TOS and remove from base value div by two to get count 
a240					if DEBUG_FORTH_WORDS_KEY 
a240						DMARK "DEP" 
a240 f5				push af  
a241 3a 55 a2			ld a, (.dmark)  
a244 32 c0 ee			ld (debug_mark),a  
a247 3a 56 a2			ld a, (.dmark+1)  
a24a 32 c1 ee			ld (debug_mark+1),a  
a24d 3a 57 a2			ld a, (.dmark+2)  
a250 32 c2 ee			ld (debug_mark+2),a  
a253 18 03			jr .pastdmark  
a255 ..			.dmark: db "DEP"  
a258 f1			.pastdmark: pop af  
a259			endm  
# End of macro DMARK
a259						CALLMONITOR 
a259 cd 2e 93			call break_point_state  
a25c				endm  
# End of macro CALLMONITOR
a25c					endif 
a25c			 
a25c			 
a25c 2a 93 ec			ld hl, (cli_data_sp) 
a25f 11 4d ea			ld de, cli_data_stack 
a262 ed 52			sbc hl,de 
a264				 
a264				; div by size of stack item 
a264			 
a264 5d				ld e,l 
a265 0e 03			ld c, 3 
a267 cd 4b 8a			call Div8 
a26a			 
a26a 6f				ld l,a 
a26b 26 00			ld h,0 
a26d			 
a26d				;srl h 
a26d				;rr l 
a26d			 
a26d cd bb 98				call forth_push_numhl 
a270					NEXTW 
a270 c3 24 9c			jp macro_next 
a273				endm 
# End of macro NEXTW
a273			.OVER: 
a273				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a273 42				db WORD_SYS_CORE+46             
a274 ba a2			dw .PAUSE            
a276 05				db 4 + 1 
a277 .. 00			db "OVER",0              
a27c				endm 
# End of macro CWHEAD
a27c			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a27c					if DEBUG_FORTH_WORDS_KEY 
a27c						DMARK "OVR" 
a27c f5				push af  
a27d 3a 91 a2			ld a, (.dmark)  
a280 32 c0 ee			ld (debug_mark),a  
a283 3a 92 a2			ld a, (.dmark+1)  
a286 32 c1 ee			ld (debug_mark+1),a  
a289 3a 93 a2			ld a, (.dmark+2)  
a28c 32 c2 ee			ld (debug_mark+2),a  
a28f 18 03			jr .pastdmark  
a291 ..			.dmark: db "OVR"  
a294 f1			.pastdmark: pop af  
a295			endm  
# End of macro DMARK
a295						CALLMONITOR 
a295 cd 2e 93			call break_point_state  
a298				endm  
# End of macro CALLMONITOR
a298					endif 
a298			 
a298					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a298 cd b2 9a			call macro_dsp_valuehl 
a29b				endm 
# End of macro FORTH_DSP_VALUEHL
a29b e5					push hl    ; n2 
a29c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a29c cd 6a 9b			call macro_forth_dsp_pop 
a29f				endm 
# End of macro FORTH_DSP_POP
a29f			 
a29f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a29f cd b2 9a			call macro_dsp_valuehl 
a2a2				endm 
# End of macro FORTH_DSP_VALUEHL
a2a2 e5					push hl    ; n1 
a2a3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2a3 cd 6a 9b			call macro_forth_dsp_pop 
a2a6				endm 
# End of macro FORTH_DSP_POP
a2a6			 
a2a6 d1					pop de     ; n1 
a2a7 e1					pop hl     ; n2 
a2a8			 
a2a8 d5					push de 
a2a9 e5					push hl 
a2aa d5					push de 
a2ab			 
a2ab					; push back  
a2ab			 
a2ab e1					pop hl 
a2ac cd bb 98				call forth_push_numhl 
a2af e1					pop hl 
a2b0 cd bb 98				call forth_push_numhl 
a2b3 e1					pop hl 
a2b4 cd bb 98				call forth_push_numhl 
a2b7					NEXTW 
a2b7 c3 24 9c			jp macro_next 
a2ba				endm 
# End of macro NEXTW
a2ba			 
a2ba			.PAUSE: 
a2ba				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a2ba 43				db WORD_SYS_CORE+47             
a2bb ef a2			dw .PAUSES            
a2bd 08				db 7 + 1 
a2be .. 00			db "PAUSEMS",0              
a2c6				endm 
# End of macro CWHEAD
a2c6			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a2c6					if DEBUG_FORTH_WORDS_KEY 
a2c6						DMARK "PMS" 
a2c6 f5				push af  
a2c7 3a db a2			ld a, (.dmark)  
a2ca 32 c0 ee			ld (debug_mark),a  
a2cd 3a dc a2			ld a, (.dmark+1)  
a2d0 32 c1 ee			ld (debug_mark+1),a  
a2d3 3a dd a2			ld a, (.dmark+2)  
a2d6 32 c2 ee			ld (debug_mark+2),a  
a2d9 18 03			jr .pastdmark  
a2db ..			.dmark: db "PMS"  
a2de f1			.pastdmark: pop af  
a2df			endm  
# End of macro DMARK
a2df						CALLMONITOR 
a2df cd 2e 93			call break_point_state  
a2e2				endm  
# End of macro CALLMONITOR
a2e2					endif 
a2e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2e2 cd b2 9a			call macro_dsp_valuehl 
a2e5				endm 
# End of macro FORTH_DSP_VALUEHL
a2e5			;		push hl    ; n2 
a2e5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2e5 cd 6a 9b			call macro_forth_dsp_pop 
a2e8				endm 
# End of macro FORTH_DSP_POP
a2e8			;		pop hl 
a2e8			 
a2e8 7d					ld a, l 
a2e9 cd f3 87				call aDelayInMS 
a2ec				       NEXTW 
a2ec c3 24 9c			jp macro_next 
a2ef				endm 
# End of macro NEXTW
a2ef			.PAUSES:  
a2ef				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a2ef 44				db WORD_SYS_CORE+48             
a2f0 5e a3			dw .ROT            
a2f2 06				db 5 + 1 
a2f3 .. 00			db "PAUSE",0              
a2f9				endm 
# End of macro CWHEAD
a2f9			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a2f9					if DEBUG_FORTH_WORDS_KEY 
a2f9						DMARK "PAU" 
a2f9 f5				push af  
a2fa 3a 0e a3			ld a, (.dmark)  
a2fd 32 c0 ee			ld (debug_mark),a  
a300 3a 0f a3			ld a, (.dmark+1)  
a303 32 c1 ee			ld (debug_mark+1),a  
a306 3a 10 a3			ld a, (.dmark+2)  
a309 32 c2 ee			ld (debug_mark+2),a  
a30c 18 03			jr .pastdmark  
a30e ..			.dmark: db "PAU"  
a311 f1			.pastdmark: pop af  
a312			endm  
# End of macro DMARK
a312						CALLMONITOR 
a312 cd 2e 93			call break_point_state  
a315				endm  
# End of macro CALLMONITOR
a315					endif 
a315					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a315 cd b2 9a			call macro_dsp_valuehl 
a318				endm 
# End of macro FORTH_DSP_VALUEHL
a318			;		push hl    ; n2 
a318					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a318 cd 6a 9b			call macro_forth_dsp_pop 
a31b				endm 
# End of macro FORTH_DSP_POP
a31b			;		pop hl 
a31b 45					ld b, l 
a31c					if DEBUG_FORTH_WORDS 
a31c						DMARK "PAU" 
a31c f5				push af  
a31d 3a 31 a3			ld a, (.dmark)  
a320 32 c0 ee			ld (debug_mark),a  
a323 3a 32 a3			ld a, (.dmark+1)  
a326 32 c1 ee			ld (debug_mark+1),a  
a329 3a 33 a3			ld a, (.dmark+2)  
a32c 32 c2 ee			ld (debug_mark+2),a  
a32f 18 03			jr .pastdmark  
a331 ..			.dmark: db "PAU"  
a334 f1			.pastdmark: pop af  
a335			endm  
# End of macro DMARK
a335						CALLMONITOR 
a335 cd 2e 93			call break_point_state  
a338				endm  
# End of macro CALLMONITOR
a338					endif 
a338 c5			.pauses1:	push bc 
a339 cd 0e 88				call delay1s 
a33c c1					pop bc 
a33d					if DEBUG_FORTH_WORDS 
a33d						DMARK "PA1" 
a33d f5				push af  
a33e 3a 52 a3			ld a, (.dmark)  
a341 32 c0 ee			ld (debug_mark),a  
a344 3a 53 a3			ld a, (.dmark+1)  
a347 32 c1 ee			ld (debug_mark+1),a  
a34a 3a 54 a3			ld a, (.dmark+2)  
a34d 32 c2 ee			ld (debug_mark+2),a  
a350 18 03			jr .pastdmark  
a352 ..			.dmark: db "PA1"  
a355 f1			.pastdmark: pop af  
a356			endm  
# End of macro DMARK
a356						CALLMONITOR 
a356 cd 2e 93			call break_point_state  
a359				endm  
# End of macro CALLMONITOR
a359					endif 
a359 10 dd				djnz .pauses1 
a35b			 
a35b				       NEXTW 
a35b c3 24 9c			jp macro_next 
a35e				endm 
# End of macro NEXTW
a35e			.ROT: 
a35e				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a35e 45				db WORD_SYS_CORE+49             
a35f ac a3			dw .UWORDS            
a361 04				db 3 + 1 
a362 .. 00			db "ROT",0              
a366				endm 
# End of macro CWHEAD
a366			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a366					if DEBUG_FORTH_WORDS_KEY 
a366						DMARK "ROT" 
a366 f5				push af  
a367 3a 7b a3			ld a, (.dmark)  
a36a 32 c0 ee			ld (debug_mark),a  
a36d 3a 7c a3			ld a, (.dmark+1)  
a370 32 c1 ee			ld (debug_mark+1),a  
a373 3a 7d a3			ld a, (.dmark+2)  
a376 32 c2 ee			ld (debug_mark+2),a  
a379 18 03			jr .pastdmark  
a37b ..			.dmark: db "ROT"  
a37e f1			.pastdmark: pop af  
a37f			endm  
# End of macro DMARK
a37f						CALLMONITOR 
a37f cd 2e 93			call break_point_state  
a382				endm  
# End of macro CALLMONITOR
a382					endif 
a382			 
a382					FORTH_DSP_VALUEHL 
a382 cd b2 9a			call macro_dsp_valuehl 
a385				endm 
# End of macro FORTH_DSP_VALUEHL
a385 e5					push hl    ; u3  
a386			 
a386					FORTH_DSP_POP 
a386 cd 6a 9b			call macro_forth_dsp_pop 
a389				endm 
# End of macro FORTH_DSP_POP
a389			   
a389					FORTH_DSP_VALUEHL 
a389 cd b2 9a			call macro_dsp_valuehl 
a38c				endm 
# End of macro FORTH_DSP_VALUEHL
a38c e5					push hl     ; u2 
a38d			 
a38d					FORTH_DSP_POP 
a38d cd 6a 9b			call macro_forth_dsp_pop 
a390				endm 
# End of macro FORTH_DSP_POP
a390			 
a390					FORTH_DSP_VALUEHL 
a390 cd b2 9a			call macro_dsp_valuehl 
a393				endm 
# End of macro FORTH_DSP_VALUEHL
a393 e5					push hl     ; u1 
a394			 
a394					FORTH_DSP_POP 
a394 cd 6a 9b			call macro_forth_dsp_pop 
a397				endm 
# End of macro FORTH_DSP_POP
a397			 
a397 c1					pop bc      ; u1 
a398 e1					pop hl      ; u2 
a399 d1					pop de      ; u3 
a39a			 
a39a			 
a39a c5					push bc 
a39b d5					push de 
a39c e5					push hl 
a39d			 
a39d			 
a39d e1					pop hl 
a39e cd bb 98				call forth_push_numhl 
a3a1			 
a3a1 e1					pop hl 
a3a2 cd bb 98				call forth_push_numhl 
a3a5			 
a3a5 e1					pop hl 
a3a6 cd bb 98				call forth_push_numhl 
a3a9					 
a3a9			 
a3a9			 
a3a9			 
a3a9			 
a3a9			 
a3a9				       NEXTW 
a3a9 c3 24 9c			jp macro_next 
a3ac				endm 
# End of macro NEXTW
a3ac			 
a3ac			.UWORDS: 
a3ac				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a3ac 50				db WORD_SYS_CORE+60             
a3ad 6e a4			dw .BP            
a3af 07				db 6 + 1 
a3b0 .. 00			db "UWORDS",0              
a3b7				endm 
# End of macro CWHEAD
a3b7			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a3b7			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a3b7			; | | Following the count are the individual words. 
a3b7			; | | 
a3b7			; | | e.g. UWORDS 
a3b7			; | | BOX DIRLIST 2 
a3b7			; | |  
a3b7			; | | Can be used to save the words to storage via: 
a3b7			; | | UWORDS $01 DO $01 APPEND LOOP 
a3b7				if DEBUG_FORTH_WORDS_KEY 
a3b7					DMARK "UWR" 
a3b7 f5				push af  
a3b8 3a cc a3			ld a, (.dmark)  
a3bb 32 c0 ee			ld (debug_mark),a  
a3be 3a cd a3			ld a, (.dmark+1)  
a3c1 32 c1 ee			ld (debug_mark+1),a  
a3c4 3a ce a3			ld a, (.dmark+2)  
a3c7 32 c2 ee			ld (debug_mark+2),a  
a3ca 18 03			jr .pastdmark  
a3cc ..			.dmark: db "UWR"  
a3cf f1			.pastdmark: pop af  
a3d0			endm  
# End of macro DMARK
a3d0					CALLMONITOR 
a3d0 cd 2e 93			call break_point_state  
a3d3				endm  
# End of macro CALLMONITOR
a3d3				endif 
a3d3 21 84 d7				ld hl, baseram 
a3d6					;ld hl, baseusermem 
a3d6 01 00 00				ld bc, 0    ; start a counter 
a3d9			 
a3d9				; skip dict stub 
a3d9			 
a3d9 cd 75 9d				call forth_tok_next 
a3dc			 
a3dc			 
a3dc			; while we have words to look for 
a3dc			 
a3dc 7e			.douscan:	ld a, (hl)      
a3dd				if DEBUG_FORTH_WORDS 
a3dd					DMARK "UWs" 
a3dd f5				push af  
a3de 3a f2 a3			ld a, (.dmark)  
a3e1 32 c0 ee			ld (debug_mark),a  
a3e4 3a f3 a3			ld a, (.dmark+1)  
a3e7 32 c1 ee			ld (debug_mark+1),a  
a3ea 3a f4 a3			ld a, (.dmark+2)  
a3ed 32 c2 ee			ld (debug_mark+2),a  
a3f0 18 03			jr .pastdmark  
a3f2 ..			.dmark: db "UWs"  
a3f5 f1			.pastdmark: pop af  
a3f6			endm  
# End of macro DMARK
a3f6					CALLMONITOR 
a3f6 cd 2e 93			call break_point_state  
a3f9				endm  
# End of macro CALLMONITOR
a3f9				endif 
a3f9 fe 00				cp WORD_SYS_END 
a3fb 28 4d				jr z, .udone 
a3fd fe 01				cp WORD_SYS_UWORD 
a3ff 20 44				jr nz, .nuword 
a401			 
a401				if DEBUG_FORTH_WORDS 
a401					DMARK "UWu" 
a401 f5				push af  
a402 3a 16 a4			ld a, (.dmark)  
a405 32 c0 ee			ld (debug_mark),a  
a408 3a 17 a4			ld a, (.dmark+1)  
a40b 32 c1 ee			ld (debug_mark+1),a  
a40e 3a 18 a4			ld a, (.dmark+2)  
a411 32 c2 ee			ld (debug_mark+2),a  
a414 18 03			jr .pastdmark  
a416 ..			.dmark: db "UWu"  
a419 f1			.pastdmark: pop af  
a41a			endm  
# End of macro DMARK
a41a					CALLMONITOR 
a41a cd 2e 93			call break_point_state  
a41d				endm  
# End of macro CALLMONITOR
a41d				endif 
a41d					; we have a uword so push its name to the stack 
a41d			 
a41d e5				   	push hl  ; save so we can move to next dict block 
a41e			 
a41e					; skip opcode 
a41e 23					inc hl  
a41f					; skip next ptr 
a41f 23					inc hl  
a420 23					inc hl 
a421					; skip len 
a421 23					inc hl 
a422				if DEBUG_FORTH_WORDS 
a422					DMARK "UWt" 
a422 f5				push af  
a423 3a 37 a4			ld a, (.dmark)  
a426 32 c0 ee			ld (debug_mark),a  
a429 3a 38 a4			ld a, (.dmark+1)  
a42c 32 c1 ee			ld (debug_mark+1),a  
a42f 3a 39 a4			ld a, (.dmark+2)  
a432 32 c2 ee			ld (debug_mark+2),a  
a435 18 03			jr .pastdmark  
a437 ..			.dmark: db "UWt"  
a43a f1			.pastdmark: pop af  
a43b			endm  
# End of macro DMARK
a43b					CALLMONITOR 
a43b cd 2e 93			call break_point_state  
a43e				endm  
# End of macro CALLMONITOR
a43e				endif 
a43e 03					inc bc 
a43f			 
a43f c5					push bc 
a440 cd 29 99				call forth_push_str 
a443 c1					pop bc 
a444			 
a444 e1					pop hl 	 
a445			 
a445 cd 75 9d		.nuword:	call forth_tok_next 
a448 18 92				jr .douscan  
a44a			 
a44a			.udone:		 ; push count of uwords found 
a44a c5					push bc 
a44b e1					pop hl 
a44c			 
a44c				if DEBUG_FORTH_WORDS 
a44c					DMARK "UWc" 
a44c f5				push af  
a44d 3a 61 a4			ld a, (.dmark)  
a450 32 c0 ee			ld (debug_mark),a  
a453 3a 62 a4			ld a, (.dmark+1)  
a456 32 c1 ee			ld (debug_mark+1),a  
a459 3a 63 a4			ld a, (.dmark+2)  
a45c 32 c2 ee			ld (debug_mark+2),a  
a45f 18 03			jr .pastdmark  
a461 ..			.dmark: db "UWc"  
a464 f1			.pastdmark: pop af  
a465			endm  
# End of macro DMARK
a465					CALLMONITOR 
a465 cd 2e 93			call break_point_state  
a468				endm  
# End of macro CALLMONITOR
a468				endif 
a468 cd bb 98				call forth_push_numhl 
a46b			 
a46b			 
a46b				       NEXTW 
a46b c3 24 9c			jp macro_next 
a46e				endm 
# End of macro NEXTW
a46e			 
a46e			.BP: 
a46e				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a46e 54				db WORD_SYS_CORE+64             
a46f a4 a4			dw .MONITOR            
a471 03				db 2 + 1 
a472 .. 00			db "BP",0              
a475				endm 
# End of macro CWHEAD
a475			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a475			; | | $00 Will enable the break points within specific code paths 
a475			; | | $01 Will disable break points 
a475			; | |  
a475			; | | By default break points are off. Either the above can be used to enable them 
a475			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a475			; | | and on release of the pressed key a message will be disaplayed to notify 
a475			; | | that break points are enabled. Pressing any key will then continue boot process. 
a475					; get byte count 
a475					if DEBUG_FORTH_WORDS_KEY 
a475						DMARK "BP." 
a475 f5				push af  
a476 3a 8a a4			ld a, (.dmark)  
a479 32 c0 ee			ld (debug_mark),a  
a47c 3a 8b a4			ld a, (.dmark+1)  
a47f 32 c1 ee			ld (debug_mark+1),a  
a482 3a 8c a4			ld a, (.dmark+2)  
a485 32 c2 ee			ld (debug_mark+2),a  
a488 18 03			jr .pastdmark  
a48a ..			.dmark: db "BP."  
a48d f1			.pastdmark: pop af  
a48e			endm  
# End of macro DMARK
a48e						CALLMONITOR 
a48e cd 2e 93			call break_point_state  
a491				endm  
# End of macro CALLMONITOR
a491					endif 
a491			 
a491					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a491 cd b2 9a			call macro_dsp_valuehl 
a494				endm 
# End of macro FORTH_DSP_VALUEHL
a494			 
a494			;		push hl 
a494			 
a494					; destroy value TOS 
a494			 
a494					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a494 cd 6a 9b			call macro_forth_dsp_pop 
a497				endm 
# End of macro FORTH_DSP_POP
a497			 
a497			;		pop hl 
a497			 
a497 3e 00				ld a,0 
a499 bd					cp l 
a49a 28 02				jr z, .bpset 
a49c 3e 2a				ld a, '*' 
a49e			 
a49e 32 d7 e4		.bpset:		ld (os_view_disable), a 
a4a1			 
a4a1			 
a4a1					NEXTW 
a4a1 c3 24 9c			jp macro_next 
a4a4				endm 
# End of macro NEXTW
a4a4			 
a4a4			 
a4a4			.MONITOR: 
a4a4				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a4a4 55				db WORD_SYS_CORE+65             
a4a5 d7 a4			dw .MALLOC            
a4a7 08				db 7 + 1 
a4a8 .. 00			db "MONITOR",0              
a4b0				endm 
# End of macro CWHEAD
a4b0			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a4b0			; | | At start the current various registers will be displayed with contents. 
a4b0			; | | Top right corner will show the most recent debug marker seen. 
a4b0			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a4b0			; | | and the return stack pointer (RSP). 
a4b0			; | | Pressing: 
a4b0			; | |    1 - Initial screen 
a4b0			; | |    2 - Display a data dump of HL 
a4b0			; | |    3 - Display a data dump of DE 
a4b0			; | |    4 - Display a data dump of BC 
a4b0			; | |    5 - Display a data dump of HL 
a4b0			; | |    6 - Display a data dump of DSP 
a4b0			; | |    7 - Display a data dump of RSP 
a4b0			; | |    8 - Display a data dump of what is at DSP 
a4b0			; | |    9 - Display a data dump of what is at RSP 
a4b0			; | |    0 - Exit monitor and continue running. This will also enable break points 
a4b0			; | |    * - Disable break points 
a4b0			; | |    # - Enter traditional monitor mode 
a4b0			; | | 
a4b0			; | | Monitor Mode 
a4b0			; | | ------------ 
a4b0			; | | A prompt of '>' will be shown for various commands: 
a4b0			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a4b0			; | |    C - Continue display a data dump from the last set address 
a4b0			; | |    M xxxx - Set start of memory edit at address xx 
a4b0			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a4b0			; | |    Q - Return to previous 
a4b0					if DEBUG_FORTH_WORDS_KEY 
a4b0						DMARK "MON" 
a4b0 f5				push af  
a4b1 3a c5 a4			ld a, (.dmark)  
a4b4 32 c0 ee			ld (debug_mark),a  
a4b7 3a c6 a4			ld a, (.dmark+1)  
a4ba 32 c1 ee			ld (debug_mark+1),a  
a4bd 3a c7 a4			ld a, (.dmark+2)  
a4c0 32 c2 ee			ld (debug_mark+2),a  
a4c3 18 03			jr .pastdmark  
a4c5 ..			.dmark: db "MON"  
a4c8 f1			.pastdmark: pop af  
a4c9			endm  
# End of macro DMARK
a4c9						CALLMONITOR 
a4c9 cd 2e 93			call break_point_state  
a4cc				endm  
# End of macro CALLMONITOR
a4cc					endif 
a4cc 3e 00				ld a, 0 
a4ce 32 d7 e4				ld (os_view_disable), a 
a4d1			 
a4d1					CALLMONITOR 
a4d1 cd 2e 93			call break_point_state  
a4d4				endm  
# End of macro CALLMONITOR
a4d4			 
a4d4			;	call monitor 
a4d4			 
a4d4					NEXTW 
a4d4 c3 24 9c			jp macro_next 
a4d7				endm 
# End of macro NEXTW
a4d7			 
a4d7			 
a4d7			.MALLOC: 
a4d7				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a4d7 56				db WORD_SYS_CORE+66             
a4d8 00 a5			dw .MALLOC2            
a4da 06				db 5 + 1 
a4db .. 00			db "ALLOT",0              
a4e1				endm 
# End of macro CWHEAD
a4e1			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a4e1					if DEBUG_FORTH_WORDS_KEY 
a4e1						DMARK "ALL" 
a4e1 f5				push af  
a4e2 3a f6 a4			ld a, (.dmark)  
a4e5 32 c0 ee			ld (debug_mark),a  
a4e8 3a f7 a4			ld a, (.dmark+1)  
a4eb 32 c1 ee			ld (debug_mark+1),a  
a4ee 3a f8 a4			ld a, (.dmark+2)  
a4f1 32 c2 ee			ld (debug_mark+2),a  
a4f4 18 03			jr .pastdmark  
a4f6 ..			.dmark: db "ALL"  
a4f9 f1			.pastdmark: pop af  
a4fa			endm  
# End of macro DMARK
a4fa						CALLMONITOR 
a4fa cd 2e 93			call break_point_state  
a4fd				endm  
# End of macro CALLMONITOR
a4fd					endif 
a4fd c3 27 a5				jp .mallocc 
a500			.MALLOC2: 
a500				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a500 56				db WORD_SYS_CORE+66             
a501 3e a5			dw .FREE            
a503 07				db 6 + 1 
a504 .. 00			db "MALLOC",0              
a50b				endm 
# End of macro CWHEAD
a50b			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a50b					; get byte count 
a50b					if DEBUG_FORTH_WORDS_KEY 
a50b						DMARK "MAL" 
a50b f5				push af  
a50c 3a 20 a5			ld a, (.dmark)  
a50f 32 c0 ee			ld (debug_mark),a  
a512 3a 21 a5			ld a, (.dmark+1)  
a515 32 c1 ee			ld (debug_mark+1),a  
a518 3a 22 a5			ld a, (.dmark+2)  
a51b 32 c2 ee			ld (debug_mark+2),a  
a51e 18 03			jr .pastdmark  
a520 ..			.dmark: db "MAL"  
a523 f1			.pastdmark: pop af  
a524			endm  
# End of macro DMARK
a524						CALLMONITOR 
a524 cd 2e 93			call break_point_state  
a527				endm  
# End of macro CALLMONITOR
a527					endif 
a527			.mallocc: 
a527					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a527 cd b2 9a			call macro_dsp_valuehl 
a52a				endm 
# End of macro FORTH_DSP_VALUEHL
a52a			 
a52a			;		push hl 
a52a			 
a52a					; destroy value TOS 
a52a			 
a52a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a52a cd 6a 9b			call macro_forth_dsp_pop 
a52d				endm 
# End of macro FORTH_DSP_POP
a52d			 
a52d			;		pop hl 
a52d cd 82 8f				call malloc 
a530				if DEBUG_FORTH_MALLOC_GUARD 
a530 f5					push af 
a531 cd e4 8a				call ishlzero 
a534			;		ld a, l 
a534			;		add h 
a534			;		cp 0 
a534 f1					pop af 
a535					 
a535 cc 39 c4				call z,malloc_error 
a538				endif 
a538			 
a538 cd bb 98				call forth_push_numhl 
a53b					NEXTW 
a53b c3 24 9c			jp macro_next 
a53e				endm 
# End of macro NEXTW
a53e			 
a53e			.FREE: 
a53e				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a53e 57				db WORD_SYS_CORE+67             
a53f 6f a5			dw .LIST            
a541 05				db 4 + 1 
a542 .. 00			db "FREE",0              
a547				endm 
# End of macro CWHEAD
a547			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a547					if DEBUG_FORTH_WORDS_KEY 
a547						DMARK "FRE" 
a547 f5				push af  
a548 3a 5c a5			ld a, (.dmark)  
a54b 32 c0 ee			ld (debug_mark),a  
a54e 3a 5d a5			ld a, (.dmark+1)  
a551 32 c1 ee			ld (debug_mark+1),a  
a554 3a 5e a5			ld a, (.dmark+2)  
a557 32 c2 ee			ld (debug_mark+2),a  
a55a 18 03			jr .pastdmark  
a55c ..			.dmark: db "FRE"  
a55f f1			.pastdmark: pop af  
a560			endm  
# End of macro DMARK
a560						CALLMONITOR 
a560 cd 2e 93			call break_point_state  
a563				endm  
# End of macro CALLMONITOR
a563					endif 
a563					; get address 
a563			 
a563					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a563 cd b2 9a			call macro_dsp_valuehl 
a566				endm 
# End of macro FORTH_DSP_VALUEHL
a566			 
a566			;		push hl 
a566			 
a566					; destroy value TOS 
a566			 
a566					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a566 cd 6a 9b			call macro_forth_dsp_pop 
a569				endm 
# End of macro FORTH_DSP_POP
a569			 
a569			;		pop hl 
a569			if FORTH_ENABLE_MALLOCFREE 
a569 cd 4c 90				call free 
a56c			endif 
a56c					NEXTW 
a56c c3 24 9c			jp macro_next 
a56f				endm 
# End of macro NEXTW
a56f			.LIST: 
a56f				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a56f 5c				db WORD_SYS_CORE+72             
a570 5d a7			dw .FORGET            
a572 05				db 4 + 1 
a573 .. 00			db "LIST",0              
a578				endm 
# End of macro CWHEAD
a578			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a578			; | | The quoted word must be in upper case. 
a578				if DEBUG_FORTH_WORDS_KEY 
a578					DMARK "LST" 
a578 f5				push af  
a579 3a 8d a5			ld a, (.dmark)  
a57c 32 c0 ee			ld (debug_mark),a  
a57f 3a 8e a5			ld a, (.dmark+1)  
a582 32 c1 ee			ld (debug_mark+1),a  
a585 3a 8f a5			ld a, (.dmark+2)  
a588 32 c2 ee			ld (debug_mark+2),a  
a58b 18 03			jr .pastdmark  
a58d ..			.dmark: db "LST"  
a590 f1			.pastdmark: pop af  
a591			endm  
# End of macro DMARK
a591					CALLMONITOR 
a591 cd 2e 93			call break_point_state  
a594				endm  
# End of macro CALLMONITOR
a594				endif 
a594			 
a594					FORTH_DSP_VALUEHL 
a594 cd b2 9a			call macro_dsp_valuehl 
a597				endm 
# End of macro FORTH_DSP_VALUEHL
a597			 
a597 e5					push hl 
a598					FORTH_DSP_POP 
a598 cd 6a 9b			call macro_forth_dsp_pop 
a59b				endm 
# End of macro FORTH_DSP_POP
a59b c1					pop bc 
a59c			 
a59c			; Start format of scratch string 
a59c			 
a59c 21 e6 e4				ld hl, scratch 
a59f			 
a59f 3e 3a				ld a, ':' 
a5a1 77					ld (hl),a 
a5a2 23					inc hl 
a5a3 3e 20				ld a, ' ' 
a5a5 77					ld (hl), a 
a5a6			 
a5a6					; Get ptr to the word we need to look up 
a5a6			 
a5a6			;		FORTH_DSP_VALUEHL 
a5a6					;v5 FORTH_DSP_VALUE 
a5a6				; TODO type check 
a5a6			;		inc hl    ; Skip type check  
a5a6			;		push hl 
a5a6			;		ex de, hl    ; put into DE 
a5a6			 
a5a6			 
a5a6 21 84 d7				ld hl, baseram 
a5a9					;ld hl, baseusermem 
a5a9			 
a5a9 e5			push hl   ; sacreifical push 
a5aa			 
a5aa			.ldouscanm: 
a5aa e1				pop hl 
a5ab			.ldouscan: 
a5ab				if DEBUG_FORTH_WORDS 
a5ab					DMARK "LSs" 
a5ab f5				push af  
a5ac 3a c0 a5			ld a, (.dmark)  
a5af 32 c0 ee			ld (debug_mark),a  
a5b2 3a c1 a5			ld a, (.dmark+1)  
a5b5 32 c1 ee			ld (debug_mark+1),a  
a5b8 3a c2 a5			ld a, (.dmark+2)  
a5bb 32 c2 ee			ld (debug_mark+2),a  
a5be 18 03			jr .pastdmark  
a5c0 ..			.dmark: db "LSs"  
a5c3 f1			.pastdmark: pop af  
a5c4			endm  
# End of macro DMARK
a5c4					CALLMONITOR 
a5c4 cd 2e 93			call break_point_state  
a5c7				endm  
# End of macro CALLMONITOR
a5c7				endif 
a5c7				; skip dict stub 
a5c7 cd 75 9d				call forth_tok_next 
a5ca			 
a5ca			 
a5ca			; while we have words to look for 
a5ca			 
a5ca 7e				ld a, (hl)      
a5cb				if DEBUG_FORTH_WORDS 
a5cb					DMARK "LSk" 
a5cb f5				push af  
a5cc 3a e0 a5			ld a, (.dmark)  
a5cf 32 c0 ee			ld (debug_mark),a  
a5d2 3a e1 a5			ld a, (.dmark+1)  
a5d5 32 c1 ee			ld (debug_mark+1),a  
a5d8 3a e2 a5			ld a, (.dmark+2)  
a5db 32 c2 ee			ld (debug_mark+2),a  
a5de 18 03			jr .pastdmark  
a5e0 ..			.dmark: db "LSk"  
a5e3 f1			.pastdmark: pop af  
a5e4			endm  
# End of macro DMARK
a5e4					CALLMONITOR 
a5e4 cd 2e 93			call break_point_state  
a5e7				endm  
# End of macro CALLMONITOR
a5e7				endif 
a5e7					;cp WORD_SYS_END 
a5e7					;jp z, .lunotfound 
a5e7			 
a5e7					; if we hit non uwords then gone too far 
a5e7 fe 01				cp WORD_SYS_UWORD 
a5e9 c2 19 a7				jp nz, .lunotfound 
a5ec			 
a5ec				if DEBUG_FORTH_WORDS 
a5ec					DMARK "LSu" 
a5ec f5				push af  
a5ed 3a 01 a6			ld a, (.dmark)  
a5f0 32 c0 ee			ld (debug_mark),a  
a5f3 3a 02 a6			ld a, (.dmark+1)  
a5f6 32 c1 ee			ld (debug_mark+1),a  
a5f9 3a 03 a6			ld a, (.dmark+2)  
a5fc 32 c2 ee			ld (debug_mark+2),a  
a5ff 18 03			jr .pastdmark  
a601 ..			.dmark: db "LSu"  
a604 f1			.pastdmark: pop af  
a605			endm  
# End of macro DMARK
a605					CALLMONITOR 
a605 cd 2e 93			call break_point_state  
a608				endm  
# End of macro CALLMONITOR
a608				endif 
a608			 
a608					; found a uword but is it the one we want... 
a608			 
a608 c5					push bc     ; uword to find is on bc 
a609 d1					pop de 
a60a			 
a60a e5					push hl  ; to save the ptr 
a60b			 
a60b					; skip opcode 
a60b 23					inc hl  
a60c					; skip next ptr 
a60c 23					inc hl  
a60d 23					inc hl 
a60e					; skip len 
a60e 23					inc hl 
a60f			 
a60f				if DEBUG_FORTH_WORDS 
a60f					DMARK "LSc" 
a60f f5				push af  
a610 3a 24 a6			ld a, (.dmark)  
a613 32 c0 ee			ld (debug_mark),a  
a616 3a 25 a6			ld a, (.dmark+1)  
a619 32 c1 ee			ld (debug_mark+1),a  
a61c 3a 26 a6			ld a, (.dmark+2)  
a61f 32 c2 ee			ld (debug_mark+2),a  
a622 18 03			jr .pastdmark  
a624 ..			.dmark: db "LSc"  
a627 f1			.pastdmark: pop af  
a628			endm  
# End of macro DMARK
a628					CALLMONITOR 
a628 cd 2e 93			call break_point_state  
a62b				endm  
# End of macro CALLMONITOR
a62b				endif 
a62b cd 51 8f				call strcmp 
a62e c2 aa a5				jp nz, .ldouscanm 
a631				 
a631			 
a631			 
a631					; we have a uword so push its name to the stack 
a631			 
a631			;	   	push hl  ; save so we can move to next dict block 
a631 e1			pop hl 
a632			 
a632				if DEBUG_FORTH_WORDS 
a632					DMARK "LSm" 
a632 f5				push af  
a633 3a 47 a6			ld a, (.dmark)  
a636 32 c0 ee			ld (debug_mark),a  
a639 3a 48 a6			ld a, (.dmark+1)  
a63c 32 c1 ee			ld (debug_mark+1),a  
a63f 3a 49 a6			ld a, (.dmark+2)  
a642 32 c2 ee			ld (debug_mark+2),a  
a645 18 03			jr .pastdmark  
a647 ..			.dmark: db "LSm"  
a64a f1			.pastdmark: pop af  
a64b			endm  
# End of macro DMARK
a64b					CALLMONITOR 
a64b cd 2e 93			call break_point_state  
a64e				endm  
# End of macro CALLMONITOR
a64e				endif 
a64e			 
a64e					; skip opcode 
a64e 23					inc hl  
a64f					; skip next ptr 
a64f 23					inc hl  
a650 23					inc hl 
a651					; skip len 
a651 7e					ld a, (hl)   ; save length to add 
a652				if DEBUG_FORTH_WORDS 
a652					DMARK "LS2" 
a652 f5				push af  
a653 3a 67 a6			ld a, (.dmark)  
a656 32 c0 ee			ld (debug_mark),a  
a659 3a 68 a6			ld a, (.dmark+1)  
a65c 32 c1 ee			ld (debug_mark+1),a  
a65f 3a 69 a6			ld a, (.dmark+2)  
a662 32 c2 ee			ld (debug_mark+2),a  
a665 18 03			jr .pastdmark  
a667 ..			.dmark: db "LS2"  
a66a f1			.pastdmark: pop af  
a66b			endm  
# End of macro DMARK
a66b					CALLMONITOR 
a66b cd 2e 93			call break_point_state  
a66e				endm  
# End of macro CALLMONITOR
a66e				endif 
a66e			 
a66e					; save this location 
a66e				 
a66e e5					push hl 
a66f			 
a66f 23					inc hl 
a670 11 e8 e4				ld de, scratch+2 
a673 4f					ld c, a 
a674 06 00				ld b, 0 
a676			 
a676				if DEBUG_FORTH_WORDS 
a676					DMARK "LSn" 
a676 f5				push af  
a677 3a 8b a6			ld a, (.dmark)  
a67a 32 c0 ee			ld (debug_mark),a  
a67d 3a 8c a6			ld a, (.dmark+1)  
a680 32 c1 ee			ld (debug_mark+1),a  
a683 3a 8d a6			ld a, (.dmark+2)  
a686 32 c2 ee			ld (debug_mark+2),a  
a689 18 03			jr .pastdmark  
a68b ..			.dmark: db "LSn"  
a68e f1			.pastdmark: pop af  
a68f			endm  
# End of macro DMARK
a68f					CALLMONITOR 
a68f cd 2e 93			call break_point_state  
a692				endm  
# End of macro CALLMONITOR
a692				endif 
a692			 
a692					; copy uword name to scratch 
a692			 
a692 ed b0				ldir 
a694			 
a694 1b					dec de 
a695 3e 20				ld a, ' '    ; change null to space 
a697 12					ld (de), a 
a698			 
a698 13					inc de 
a699			 
a699 d5					push de 
a69a c1					pop bc     ; move scratch pointer to end of word name and save it 
a69b			 
a69b e1					pop hl 
a69c 7e					ld a, (hl) 
a69d					;inc hl 
a69d					; skip word string 
a69d cd bb 8a				call addatohl 
a6a0			 
a6a0 23					inc hl 
a6a1			 
a6a1				if DEBUG_FORTH_WORDS 
a6a1					DMARK "LS3" 
a6a1 f5				push af  
a6a2 3a b6 a6			ld a, (.dmark)  
a6a5 32 c0 ee			ld (debug_mark),a  
a6a8 3a b7 a6			ld a, (.dmark+1)  
a6ab 32 c1 ee			ld (debug_mark+1),a  
a6ae 3a b8 a6			ld a, (.dmark+2)  
a6b1 32 c2 ee			ld (debug_mark+2),a  
a6b4 18 03			jr .pastdmark  
a6b6 ..			.dmark: db "LS3"  
a6b9 f1			.pastdmark: pop af  
a6ba			endm  
# End of macro DMARK
a6ba					CALLMONITOR 
a6ba cd 2e 93			call break_point_state  
a6bd				endm  
# End of macro CALLMONITOR
a6bd				endif 
a6bd					; should now be at the start of the machine code to setup the eval of the uword 
a6bd					; now locate the ptr to the string defintion 
a6bd			 
a6bd					; skip ld hl, 
a6bd					; then load the ptr 
a6bd			; TODO use get from hl ptr 
a6bd 23					inc hl 
a6be 5e					ld e, (hl) 
a6bf 23					inc hl 
a6c0 56					ld d, (hl) 
a6c1 eb					ex de, hl 
a6c2			 
a6c2			 
a6c2				if DEBUG_FORTH_WORDS 
a6c2					DMARK "LSt" 
a6c2 f5				push af  
a6c3 3a d7 a6			ld a, (.dmark)  
a6c6 32 c0 ee			ld (debug_mark),a  
a6c9 3a d8 a6			ld a, (.dmark+1)  
a6cc 32 c1 ee			ld (debug_mark+1),a  
a6cf 3a d9 a6			ld a, (.dmark+2)  
a6d2 32 c2 ee			ld (debug_mark+2),a  
a6d5 18 03			jr .pastdmark  
a6d7 ..			.dmark: db "LSt"  
a6da f1			.pastdmark: pop af  
a6db			endm  
# End of macro DMARK
a6db					CALLMONITOR 
a6db cd 2e 93			call break_point_state  
a6de				endm  
# End of macro CALLMONITOR
a6de				endif 
a6de			 
a6de			; cant push right now due to tokenised strings  
a6de			 
a6de			; get the destination of where to copy this definition to. 
a6de			 
a6de c5					push bc 
a6df d1					pop de 
a6e0			 
a6e0 7e			.listl:         ld a,(hl) 
a6e1 fe 00				cp 0 
a6e3 28 09				jr z, .lreplsp     ; replace zero with space 
a6e5					;cp FORTH_END_BUFFER 
a6e5 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a6e7 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a6e9				 
a6e9					; just copy this char as is then 
a6e9			 
a6e9 12					ld (de), a 
a6ea			 
a6ea 23			.listnxt:	inc hl 
a6eb 13					inc de 
a6ec 18 f2				jr .listl 
a6ee			 
a6ee 3e 20		.lreplsp:	ld a,' ' 
a6f0 12					ld (de), a 
a6f1 18 f7				jr .listnxt 
a6f3			 
a6f3			; close up uword def 
a6f3			 
a6f3			.listdone: 
a6f3 12					ld (de), a 
a6f4 13					inc de 
a6f5 3e 00				ld a, 0 
a6f7 12					ld (de), a 
a6f8			 
a6f8			; now have def so clean up and push to stack 
a6f8			 
a6f8 21 e6 e4				ld hl, scratch 
a6fb				if DEBUG_FORTH_WORDS 
a6fb					DMARK "Ltp" 
a6fb f5				push af  
a6fc 3a 10 a7			ld a, (.dmark)  
a6ff 32 c0 ee			ld (debug_mark),a  
a702 3a 11 a7			ld a, (.dmark+1)  
a705 32 c1 ee			ld (debug_mark+1),a  
a708 3a 12 a7			ld a, (.dmark+2)  
a70b 32 c2 ee			ld (debug_mark+2),a  
a70e 18 03			jr .pastdmark  
a710 ..			.dmark: db "Ltp"  
a713 f1			.pastdmark: pop af  
a714			endm  
# End of macro DMARK
a714					CALLMONITOR 
a714 cd 2e 93			call break_point_state  
a717				endm  
# End of macro CALLMONITOR
a717				endif 
a717			 
a717 18 1f			jr .listpush 
a719			 
a719			;.lnuword:	pop hl 
a719			;		call forth_tok_next 
a719			;		jp .ldouscan  
a719			 
a719			.lunotfound:		  
a719			 
a719				if DEBUG_FORTH_WORDS 
a719					DMARK "LSn" 
a719 f5				push af  
a71a 3a 2e a7			ld a, (.dmark)  
a71d 32 c0 ee			ld (debug_mark),a  
a720 3a 2f a7			ld a, (.dmark+1)  
a723 32 c1 ee			ld (debug_mark+1),a  
a726 3a 30 a7			ld a, (.dmark+2)  
a729 32 c2 ee			ld (debug_mark+2),a  
a72c 18 03			jr .pastdmark  
a72e ..			.dmark: db "LSn"  
a731 f1			.pastdmark: pop af  
a732			endm  
# End of macro DMARK
a732					CALLMONITOR 
a732 cd 2e 93			call break_point_state  
a735				endm  
# End of macro CALLMONITOR
a735				endif 
a735			 
a735					 
a735			;		FORTH_DSP_POP 
a735			;		ld hl, .luno 
a735			 
a735					NEXTW			 
a735 c3 24 9c			jp macro_next 
a738				endm 
# End of macro NEXTW
a738			 
a738			.listpush: 
a738				if DEBUG_FORTH_WORDS 
a738					DMARK "LS>" 
a738 f5				push af  
a739 3a 4d a7			ld a, (.dmark)  
a73c 32 c0 ee			ld (debug_mark),a  
a73f 3a 4e a7			ld a, (.dmark+1)  
a742 32 c1 ee			ld (debug_mark+1),a  
a745 3a 4f a7			ld a, (.dmark+2)  
a748 32 c2 ee			ld (debug_mark+2),a  
a74b 18 03			jr .pastdmark  
a74d ..			.dmark: db "LS>"  
a750 f1			.pastdmark: pop af  
a751			endm  
# End of macro DMARK
a751					CALLMONITOR 
a751 cd 2e 93			call break_point_state  
a754				endm  
# End of macro CALLMONITOR
a754				endif 
a754 cd 29 99				call forth_push_str 
a757			 
a757			 
a757			 
a757					NEXTW 
a757 c3 24 9c			jp macro_next 
a75a				endm 
# End of macro NEXTW
a75a			 
a75a			;.luno:    db "Word not found",0 
a75a			 
a75a			 
a75a			 
a75a			 
a75a			 
a75a			;		push hl   ; save pointer to start of uword def string 
a75a			; 
a75a			;; look for FORTH_EOL_LINE 
a75a			;		ld a, FORTH_END_BUFFER 
a75a			;		call strlent 
a75a			; 
a75a			;		inc hl		 ; space for coln def 
a75a			;		inc hl 
a75a			;		inc hl          ; space for terms 
a75a			;		inc hl 
a75a			; 
a75a			;		ld a, 20   ; TODO get actual length 
a75a			;		call addatohl    ; include a random amount of room for the uword name 
a75a			; 
a75a			;		 
a75a			;	if DEBUG_FORTH_WORDS 
a75a			;		DMARK "Lt1" 
a75a			;		CALLMONITOR 
a75a			;	endif 
a75a			;		 
a75a			; 
a75a			;; malloc space for the string because we cant change it 
a75a			; 
a75a			;		call malloc 
a75a			;	if DEBUG_FORTH_MALLOC_GUARD 
a75a			;		push af 
a75a			;		call ishlzero 
a75a			;		pop af 
a75a			;		 
a75a			;		call z,malloc_error 
a75a			;	endif 
a75a			; 
a75a			;	if DEBUG_FORTH_WORDS 
a75a			;		DMARK "Lt2" 
a75a			;		CALLMONITOR 
a75a			;	endif 
a75a			;		pop de 
a75a			;		push hl    ; push the malloc to release later 
a75a			;		push hl   ;  push back a copy for the later stack push 
a75a			;		 
a75a			;; copy the string swapping out the zero terms for spaces 
a75a			; 
a75a			;		; de has our source 
a75a			;		; hl has our dest 
a75a			; 
a75a			;; add the coln def 
a75a			; 
a75a			;		ld a, ':' 
a75a			;		ld (hl), a 
a75a			;		inc hl 
a75a			;		ld a, ' ' 
a75a			;		ld (hl), a 
a75a			;		inc hl 
a75a			; 
a75a			;; add the uname word 
a75a			;		push de   ; save our string for now 
a75a			;		ex de, hl 
a75a			; 
a75a			;		FORTH_DSP_VALUE 
a75a			;		;v5 FORTH_DSP_VALUE 
a75a			; 
a75a			;		inc hl   ; skip type but we know by now this is OK 
a75a			; 
a75a			;.luword:	ld a,(hl) 
a75a			;		cp 0 
a75a			;		jr z, .luword2 
a75a			;		ld (de), a 
a75a			;		inc de 
a75a			;		inc hl 
a75a			;		jr .luword 
a75a			; 
a75a			;.luword2:	ld a, ' ' 
a75a			;		ld (de), a 
a75a			;;		inc hl 
a75a			;;		inc de 
a75a			;;		ld (de), a 
a75a			;;		inc hl 
a75a			;		inc de 
a75a			; 
a75a			;		ex de, hl 
a75a			;		pop de 
a75a			;		 
a75a			;		 
a75a			; 
a75a			;; detoken that string and copy it 
a75a			; 
a75a			;	if DEBUG_FORTH_WORDS 
a75a			;		DMARK "Lt2" 
a75a			;		CALLMONITOR 
a75a			;	endif 
a75a			;.ldetok:	ld a, (de) 
a75a			;		cp FORTH_END_BUFFER 
a75a			;		jr z, .ldetokend 
a75a			;		; swap out any zero term for space 
a75a			;		cp 0 
a75a			;		jr nz, .ldetoknext 
a75a			;		ld a, ' ' 
a75a			; 
a75a			;	if DEBUG_FORTH_WORDS 
a75a			;		DMARK "LtS" 
a75a			;		CALLMONITOR 
a75a			;	endif 
a75a			;.ldetoknext:	ld (hl), a 
a75a			;		inc de 
a75a			;		inc hl 
a75a			;		jr .ldetok 
a75a			; 
a75a			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a75a			;		ld (hl), a  
a75a			; 
a75a			;; free that temp malloc 
a75a			; 
a75a			;		pop hl    
a75a			; 
a75a			;	if DEBUG_FORTH_WORDS 
a75a			;		DMARK "Lt4" 
a75a			;		CALLMONITOR 
a75a			;	endif 
a75a			;		call forth_apushstrhl 
a75a			; 
a75a			;		; get rid of temp malloc area 
a75a			; 
a75a			;		pop hl 
a75a			;		call free 
a75a			; 
a75a			;		jr .ludone 
a75a			; 
a75a			;.lnuword:	pop hl 
a75a			;		call forth_tok_next 
a75a			;		jp .ldouscan  
a75a			; 
a75a			;.ludone:		 pop hl 
a75a			; 
a75a					NEXTW 
a75a c3 24 9c			jp macro_next 
a75d				endm 
# End of macro NEXTW
a75d			 
a75d			.FORGET: 
a75d				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a75d 5d				db WORD_SYS_CORE+73             
a75e d6 a7			dw .NOP            
a760 07				db 6 + 1 
a761 .. 00			db "FORGET",0              
a768				endm 
# End of macro CWHEAD
a768			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a768			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a768			; | |  
a768			; | | e.g. "MORE" forget 
a768					if DEBUG_FORTH_WORDS_KEY 
a768						DMARK "FRG" 
a768 f5				push af  
a769 3a 7d a7			ld a, (.dmark)  
a76c 32 c0 ee			ld (debug_mark),a  
a76f 3a 7e a7			ld a, (.dmark+1)  
a772 32 c1 ee			ld (debug_mark+1),a  
a775 3a 7f a7			ld a, (.dmark+2)  
a778 32 c2 ee			ld (debug_mark+2),a  
a77b 18 03			jr .pastdmark  
a77d ..			.dmark: db "FRG"  
a780 f1			.pastdmark: pop af  
a781			endm  
# End of macro DMARK
a781						CALLMONITOR 
a781 cd 2e 93			call break_point_state  
a784				endm  
# End of macro CALLMONITOR
a784					endif 
a784			 
a784				; find uword 
a784			        ; update start of word with "_" 
a784				; replace uword with deleted flag 
a784			 
a784			 
a784			;	if DEBUG_FORTH_WORDS 
a784			;		DMARK "FOG" 
a784			;		CALLMONITOR 
a784			;	endif 
a784			 
a784			 
a784					; Get ptr to the word we need to look up 
a784			 
a784					FORTH_DSP_VALUEHL 
a784 cd b2 9a			call macro_dsp_valuehl 
a787				endm 
# End of macro FORTH_DSP_VALUEHL
a787					;v5 FORTH_DSP_VALUE 
a787				; TODO type check 
a787			;		inc hl    ; Skip type check  
a787 e5					push hl 
a788 c1					pop bc 
a789			;		ex de, hl    ; put into DE 
a789			 
a789			 
a789 21 84 d7				ld hl, baseram 
a78c					;ld hl, baseusermem 
a78c			 
a78c				; skip dict stub 
a78c			;	call forth_tok_next 
a78c e5			push hl   ; sacreifical push 
a78d			 
a78d			.fldouscanm: 
a78d e1				pop hl 
a78e			.fldouscan: 
a78e			;	if DEBUG_FORTH_WORDS 
a78e			;		DMARK "LSs" 
a78e			;		CALLMONITOR 
a78e			;	endif 
a78e				; skip dict stub 
a78e cd 75 9d				call forth_tok_next 
a791			 
a791			 
a791			; while we have words to look for 
a791			 
a791 7e				ld a, (hl)      
a792			;	if DEBUG_FORTH_WORDS 
a792			;		DMARK "LSk" 
a792			;		CALLMONITOR 
a792			;	endif 
a792 fe 00				cp WORD_SYS_END 
a794 ca d0 a7				jp z, .flunotfound 
a797 fe 01				cp WORD_SYS_UWORD 
a799 c2 8e a7				jp nz, .fldouscan 
a79c			 
a79c			;	if DEBUG_FORTH_WORDS 
a79c			;		DMARK "LSu" 
a79c			;		CALLMONITOR 
a79c			;	endif 
a79c			 
a79c					; found a uword but is it the one we want... 
a79c			 
a79c c5					push bc     ; uword to find is on bc 
a79d d1					pop de 
a79e			 
a79e e5					push hl  ; to save the ptr 
a79f			 
a79f					; skip opcode 
a79f 23					inc hl  
a7a0					; skip next ptr 
a7a0 23					inc hl  
a7a1 23					inc hl 
a7a2					; skip len 
a7a2 23					inc hl 
a7a3			 
a7a3			;	if DEBUG_FORTH_WORDS 
a7a3			;		DMARK "LSc" 
a7a3			;		CALLMONITOR 
a7a3			;	endif 
a7a3 cd 51 8f				call strcmp 
a7a6 c2 8d a7				jp nz, .fldouscanm 
a7a9			; 
a7a9			; 
a7a9			;; while we have words to look for 
a7a9			; 
a7a9			;.fdouscan:	ld a, (hl)      
a7a9			;	if DEBUG_FORTH_WORDS 
a7a9			;		DMARK "LSs" 
a7a9			;		CALLMONITOR 
a7a9			;	endif 
a7a9			;		cp WORD_SYS_END 
a7a9			;		jp z, .fudone 
a7a9			;		cp WORD_SYS_UWORD 
a7a9			;		jp nz, .fnuword 
a7a9			; 
a7a9			;	if DEBUG_FORTH_WORDS 
a7a9			;		DMARK "FGu" 
a7a9			;		CALLMONITOR 
a7a9			;	endif 
a7a9			; 
a7a9			;		; found a uword but is it the one we want... 
a7a9			; 
a7a9			; 
a7a9			;	        pop de   ; get back the dsp name 
a7a9			;		push de 
a7a9			; 
a7a9			;		push hl  ; to save the ptr 
a7a9			; 
a7a9			;		; skip opcode 
a7a9			;		inc hl  
a7a9			;		; skip next ptr 
a7a9			;		inc hl  
a7a9			;		inc hl 
a7a9			;		; skip len 
a7a9			;		inc hl 
a7a9			; 
a7a9			;	if DEBUG_FORTH_WORDS 
a7a9			;		DMARK "FGc" 
a7a9			;		CALLMONITOR 
a7a9			;	endif 
a7a9			;		call strcmp 
a7a9			;		jp nz, .fnuword 
a7a9			 
a7a9			 
a7a9 e1			pop hl 
a7aa			 
a7aa				 
a7aa				if DEBUG_FORTH_WORDS 
a7aa					DMARK "FGm" 
a7aa f5				push af  
a7ab 3a bf a7			ld a, (.dmark)  
a7ae 32 c0 ee			ld (debug_mark),a  
a7b1 3a c0 a7			ld a, (.dmark+1)  
a7b4 32 c1 ee			ld (debug_mark+1),a  
a7b7 3a c1 a7			ld a, (.dmark+2)  
a7ba 32 c2 ee			ld (debug_mark+2),a  
a7bd 18 03			jr .pastdmark  
a7bf ..			.dmark: db "FGm"  
a7c2 f1			.pastdmark: pop af  
a7c3			endm  
# End of macro DMARK
a7c3					CALLMONITOR 
a7c3 cd 2e 93			call break_point_state  
a7c6				endm  
# End of macro CALLMONITOR
a7c6				endif 
a7c6			 
a7c6			 
a7c6			 
a7c6					; we have a uword so push its name to the stack 
a7c6			 
a7c6			;	   	push hl  ; save so we can move to next dict block 
a7c6			;pop hl 
a7c6			 
a7c6					; update opcode to deleted 
a7c6 3e 03				ld a, WORD_SYS_DELETED 
a7c8 77					ld (hl), a 
a7c9			 
a7c9 23					inc hl  
a7ca					; skip next ptr 
a7ca 23					inc hl  
a7cb 23					inc hl 
a7cc					; skip len 
a7cc 23					inc hl 
a7cd			 
a7cd					; TODO change parser to skip deleted words but for now mark it out 
a7cd 3e 5f				ld a, "_" 
a7cf 77					ld  (hl),a 
a7d0			 
a7d0			;		jr .fudone 
a7d0			; 
a7d0			;.fnuword:	pop hl 
a7d0			;		call forth_tok_next 
a7d0			;		jp .fdouscan  
a7d0			 
a7d0			.flunotfound:		  
a7d0			 
a7d0			 
a7d0					 
a7d0					FORTH_DSP_POP 
a7d0 cd 6a 9b			call macro_forth_dsp_pop 
a7d3				endm 
# End of macro FORTH_DSP_POP
a7d3			;		ld hl, .luno 
a7d3			;.fudone:		 pop hl 
a7d3					NEXTW 
a7d3 c3 24 9c			jp macro_next 
a7d6				endm 
# End of macro NEXTW
a7d6			.NOP: 
a7d6				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a7d6 61				db WORD_SYS_CORE+77             
a7d7 fd a7			dw .COMO            
a7d9 04				db 3 + 1 
a7da .. 00			db "NOP",0              
a7de				endm 
# End of macro CWHEAD
a7de			; | NOP (  --  ) Do nothing | DONE 
a7de					if DEBUG_FORTH_WORDS_KEY 
a7de						DMARK "NOP" 
a7de f5				push af  
a7df 3a f3 a7			ld a, (.dmark)  
a7e2 32 c0 ee			ld (debug_mark),a  
a7e5 3a f4 a7			ld a, (.dmark+1)  
a7e8 32 c1 ee			ld (debug_mark+1),a  
a7eb 3a f5 a7			ld a, (.dmark+2)  
a7ee 32 c2 ee			ld (debug_mark+2),a  
a7f1 18 03			jr .pastdmark  
a7f3 ..			.dmark: db "NOP"  
a7f6 f1			.pastdmark: pop af  
a7f7			endm  
# End of macro DMARK
a7f7						CALLMONITOR 
a7f7 cd 2e 93			call break_point_state  
a7fa				endm  
# End of macro CALLMONITOR
a7fa					endif 
a7fa				       NEXTW 
a7fa c3 24 9c			jp macro_next 
a7fd				endm 
# End of macro NEXTW
a7fd			.COMO: 
a7fd				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
a7fd 6e				db WORD_SYS_CORE+90             
a7fe 4f a8			dw .COMC            
a800 02				db 1 + 1 
a801 .. 00			db "(",0              
a803				endm 
# End of macro CWHEAD
a803			; | ( ( -- )  Start of comment | DONE 
a803			 
a803			 
a803 2a e7 e7				ld hl, ( os_tok_ptr) 
a806 11 4a a8			ld de, .closepar 
a809					 
a809					if DEBUG_FORTH_WORDS 
a809						DMARK ").." 
a809 f5				push af  
a80a 3a 1e a8			ld a, (.dmark)  
a80d 32 c0 ee			ld (debug_mark),a  
a810 3a 1f a8			ld a, (.dmark+1)  
a813 32 c1 ee			ld (debug_mark+1),a  
a816 3a 20 a8			ld a, (.dmark+2)  
a819 32 c2 ee			ld (debug_mark+2),a  
a81c 18 03			jr .pastdmark  
a81e ..			.dmark: db ").."  
a821 f1			.pastdmark: pop af  
a822			endm  
# End of macro DMARK
a822						CALLMONITOR 
a822 cd 2e 93			call break_point_state  
a825				endm  
# End of macro CALLMONITOR
a825					endif 
a825 cd 3f 9d			call findnexttok  
a828			 
a828					if DEBUG_FORTH_WORDS 
a828						DMARK "IF5" 
a828 f5				push af  
a829 3a 3d a8			ld a, (.dmark)  
a82c 32 c0 ee			ld (debug_mark),a  
a82f 3a 3e a8			ld a, (.dmark+1)  
a832 32 c1 ee			ld (debug_mark+1),a  
a835 3a 3f a8			ld a, (.dmark+2)  
a838 32 c2 ee			ld (debug_mark+2),a  
a83b 18 03			jr .pastdmark  
a83d ..			.dmark: db "IF5"  
a840 f1			.pastdmark: pop af  
a841			endm  
# End of macro DMARK
a841						CALLMONITOR 
a841 cd 2e 93			call break_point_state  
a844				endm  
# End of macro CALLMONITOR
a844					endif 
a844				; replace below with ) exec using tok_ptr 
a844 22 e7 e7			ld (os_tok_ptr), hl 
a847 c3 b5 9c			jp exec1 
a84a			 
a84a .. 00			.closepar:   db ")",0 
a84c			 
a84c				       NEXTW 
a84c c3 24 9c			jp macro_next 
a84f				endm 
# End of macro NEXTW
a84f			.COMC: 
a84f				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
a84f 6f				db WORD_SYS_CORE+91             
a850 58 a8			dw .SCRATCH            
a852 02				db 1 + 1 
a853 .. 00			db ")",0              
a855				endm 
# End of macro CWHEAD
a855			; | ) ( -- )  End of comment |  DONE  
a855				       NEXTW 
a855 c3 24 9c			jp macro_next 
a858				endm 
# End of macro NEXTW
a858			 
a858			.SCRATCH: 
a858				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
a858 6f				db WORD_SYS_CORE+91             
a859 93 a8			dw .INC            
a85b 08				db 7 + 1 
a85c .. 00			db "SCRATCH",0              
a864				endm 
# End of macro CWHEAD
a864			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
a864			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
a864			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
a864			; | |  
a864			; | | e.g.    : score $00 scratch ; 
a864			; | |  
a864			; | | $00 score ! 
a864			; | | $01 score +! 
a864			; | |  
a864			; | | e.g.   : varword $0a scratch ;  
a864			; | | 
a864			; | | $8000 varword ! 
a864					if DEBUG_FORTH_WORDS_KEY 
a864						DMARK "SCR" 
a864 f5				push af  
a865 3a 79 a8			ld a, (.dmark)  
a868 32 c0 ee			ld (debug_mark),a  
a86b 3a 7a a8			ld a, (.dmark+1)  
a86e 32 c1 ee			ld (debug_mark+1),a  
a871 3a 7b a8			ld a, (.dmark+2)  
a874 32 c2 ee			ld (debug_mark+2),a  
a877 18 03			jr .pastdmark  
a879 ..			.dmark: db "SCR"  
a87c f1			.pastdmark: pop af  
a87d			endm  
# End of macro DMARK
a87d						CALLMONITOR 
a87d cd 2e 93			call break_point_state  
a880				endm  
# End of macro CALLMONITOR
a880					endif 
a880			 
a880					FORTH_DSP_VALUEHL 
a880 cd b2 9a			call macro_dsp_valuehl 
a883				endm 
# End of macro FORTH_DSP_VALUEHL
a883				 
a883					FORTH_DSP_POP 
a883 cd 6a 9b			call macro_forth_dsp_pop 
a886				endm 
# End of macro FORTH_DSP_POP
a886			 
a886 7d					ld a, l 
a887 21 0b ea				ld hl, os_var_array 
a88a cd bb 8a				call addatohl 
a88d			 
a88d cd bb 98				call forth_push_numhl 
a890			 
a890				       NEXTW 
a890 c3 24 9c			jp macro_next 
a893				endm 
# End of macro NEXTW
a893			 
a893			.INC: 
a893				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
a893 6f				db WORD_SYS_CORE+91             
a894 e7 a8			dw .DEC            
a896 03				db 2 + 1 
a897 .. 00			db "+!",0              
a89a				endm 
# End of macro CWHEAD
a89a			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
a89a					if DEBUG_FORTH_WORDS_KEY 
a89a						DMARK "+s_" 
a89a f5				push af  
a89b 3a af a8			ld a, (.dmark)  
a89e 32 c0 ee			ld (debug_mark),a  
a8a1 3a b0 a8			ld a, (.dmark+1)  
a8a4 32 c1 ee			ld (debug_mark+1),a  
a8a7 3a b1 a8			ld a, (.dmark+2)  
a8aa 32 c2 ee			ld (debug_mark+2),a  
a8ad 18 03			jr .pastdmark  
a8af ..			.dmark: db "+s_"  
a8b2 f1			.pastdmark: pop af  
a8b3			endm  
# End of macro DMARK
a8b3						CALLMONITOR 
a8b3 cd 2e 93			call break_point_state  
a8b6				endm  
# End of macro CALLMONITOR
a8b6					endif 
a8b6			 
a8b6					FORTH_DSP_VALUEHL 
a8b6 cd b2 9a			call macro_dsp_valuehl 
a8b9				endm 
# End of macro FORTH_DSP_VALUEHL
a8b9			 
a8b9 e5					push hl   ; save address 
a8ba			 
a8ba					FORTH_DSP_POP 
a8ba cd 6a 9b			call macro_forth_dsp_pop 
a8bd				endm 
# End of macro FORTH_DSP_POP
a8bd			 
a8bd					FORTH_DSP_VALUEHL 
a8bd cd b2 9a			call macro_dsp_valuehl 
a8c0				endm 
# End of macro FORTH_DSP_VALUEHL
a8c0			 
a8c0					FORTH_DSP_POP 
a8c0 cd 6a 9b			call macro_forth_dsp_pop 
a8c3				endm 
# End of macro FORTH_DSP_POP
a8c3			 
a8c3					; hl contains value to add to byte at a 
a8c3				 
a8c3 eb					ex de, hl 
a8c4			 
a8c4 e1					pop hl 
a8c5			 
a8c5					if DEBUG_FORTH_WORDS 
a8c5						DMARK "INC" 
a8c5 f5				push af  
a8c6 3a da a8			ld a, (.dmark)  
a8c9 32 c0 ee			ld (debug_mark),a  
a8cc 3a db a8			ld a, (.dmark+1)  
a8cf 32 c1 ee			ld (debug_mark+1),a  
a8d2 3a dc a8			ld a, (.dmark+2)  
a8d5 32 c2 ee			ld (debug_mark+2),a  
a8d8 18 03			jr .pastdmark  
a8da ..			.dmark: db "INC"  
a8dd f1			.pastdmark: pop af  
a8de			endm  
# End of macro DMARK
a8de						CALLMONITOR 
a8de cd 2e 93			call break_point_state  
a8e1				endm  
# End of macro CALLMONITOR
a8e1					endif 
a8e1			 
a8e1 7e					ld a,(hl) 
a8e2 83					add e 
a8e3 77					ld (hl),a 
a8e4			 
a8e4			 
a8e4			 
a8e4				       NEXTW 
a8e4 c3 24 9c			jp macro_next 
a8e7				endm 
# End of macro NEXTW
a8e7			 
a8e7			.DEC: 
a8e7				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
a8e7 6f				db WORD_SYS_CORE+91             
a8e8 38 a9			dw .INC2            
a8ea 03				db 2 + 1 
a8eb .. 00			db "-!",0              
a8ee				endm 
# End of macro CWHEAD
a8ee			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
a8ee					if DEBUG_FORTH_WORDS_KEY 
a8ee						DMARK "-s_" 
a8ee f5				push af  
a8ef 3a 03 a9			ld a, (.dmark)  
a8f2 32 c0 ee			ld (debug_mark),a  
a8f5 3a 04 a9			ld a, (.dmark+1)  
a8f8 32 c1 ee			ld (debug_mark+1),a  
a8fb 3a 05 a9			ld a, (.dmark+2)  
a8fe 32 c2 ee			ld (debug_mark+2),a  
a901 18 03			jr .pastdmark  
a903 ..			.dmark: db "-s_"  
a906 f1			.pastdmark: pop af  
a907			endm  
# End of macro DMARK
a907						CALLMONITOR 
a907 cd 2e 93			call break_point_state  
a90a				endm  
# End of macro CALLMONITOR
a90a					endif 
a90a			 
a90a					FORTH_DSP_VALUEHL 
a90a cd b2 9a			call macro_dsp_valuehl 
a90d				endm 
# End of macro FORTH_DSP_VALUEHL
a90d			 
a90d e5					push hl   ; save address 
a90e			 
a90e					FORTH_DSP_POP 
a90e cd 6a 9b			call macro_forth_dsp_pop 
a911				endm 
# End of macro FORTH_DSP_POP
a911			 
a911					FORTH_DSP_VALUEHL 
a911 cd b2 9a			call macro_dsp_valuehl 
a914				endm 
# End of macro FORTH_DSP_VALUEHL
a914			 
a914					; hl contains value to add to byte at a 
a914				 
a914 eb					ex de, hl 
a915			 
a915 e1					pop hl 
a916			 
a916					if DEBUG_FORTH_WORDS 
a916						DMARK "DEC" 
a916 f5				push af  
a917 3a 2b a9			ld a, (.dmark)  
a91a 32 c0 ee			ld (debug_mark),a  
a91d 3a 2c a9			ld a, (.dmark+1)  
a920 32 c1 ee			ld (debug_mark+1),a  
a923 3a 2d a9			ld a, (.dmark+2)  
a926 32 c2 ee			ld (debug_mark+2),a  
a929 18 03			jr .pastdmark  
a92b ..			.dmark: db "DEC"  
a92e f1			.pastdmark: pop af  
a92f			endm  
# End of macro DMARK
a92f						CALLMONITOR 
a92f cd 2e 93			call break_point_state  
a932				endm  
# End of macro CALLMONITOR
a932					endif 
a932			 
a932 7e					ld a,(hl) 
a933 93					sub e 
a934 77					ld (hl),a 
a935			 
a935			 
a935			 
a935				       NEXTW 
a935 c3 24 9c			jp macro_next 
a938				endm 
# End of macro NEXTW
a938			 
a938			.INC2: 
a938				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
a938 6f				db WORD_SYS_CORE+91             
a939 e2 a9			dw .DEC2            
a93b 04				db 3 + 1 
a93c .. 00			db "+2!",0              
a940				endm 
# End of macro CWHEAD
a940			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
a940			 
a940					if DEBUG_FORTH_WORDS_KEY 
a940						DMARK "+2s" 
a940 f5				push af  
a941 3a 55 a9			ld a, (.dmark)  
a944 32 c0 ee			ld (debug_mark),a  
a947 3a 56 a9			ld a, (.dmark+1)  
a94a 32 c1 ee			ld (debug_mark+1),a  
a94d 3a 57 a9			ld a, (.dmark+2)  
a950 32 c2 ee			ld (debug_mark+2),a  
a953 18 03			jr .pastdmark  
a955 ..			.dmark: db "+2s"  
a958 f1			.pastdmark: pop af  
a959			endm  
# End of macro DMARK
a959						CALLMONITOR 
a959 cd 2e 93			call break_point_state  
a95c				endm  
# End of macro CALLMONITOR
a95c					endif 
a95c			 
a95c					; Address 
a95c			 
a95c					FORTH_DSP_VALUEHL 
a95c cd b2 9a			call macro_dsp_valuehl 
a95f				endm 
# End of macro FORTH_DSP_VALUEHL
a95f			 
a95f e5					push hl    ; save address 
a960			 
a960					; load content into de 
a960			 
a960 5e					ld e,(hl) 
a961 23					inc hl 
a962 56					ld d, (hl) 
a963			 
a963					if DEBUG_FORTH_WORDS 
a963						DMARK "+2a" 
a963 f5				push af  
a964 3a 78 a9			ld a, (.dmark)  
a967 32 c0 ee			ld (debug_mark),a  
a96a 3a 79 a9			ld a, (.dmark+1)  
a96d 32 c1 ee			ld (debug_mark+1),a  
a970 3a 7a a9			ld a, (.dmark+2)  
a973 32 c2 ee			ld (debug_mark+2),a  
a976 18 03			jr .pastdmark  
a978 ..			.dmark: db "+2a"  
a97b f1			.pastdmark: pop af  
a97c			endm  
# End of macro DMARK
a97c						CALLMONITOR 
a97c cd 2e 93			call break_point_state  
a97f				endm  
# End of macro CALLMONITOR
a97f					endif 
a97f			 
a97f					FORTH_DSP_POP 
a97f cd 6a 9b			call macro_forth_dsp_pop 
a982				endm 
# End of macro FORTH_DSP_POP
a982			 
a982					; Get value to add 
a982			 
a982					FORTH_DSP_VALUE 
a982 cd 9b 9a			call macro_forth_dsp_value 
a985				endm 
# End of macro FORTH_DSP_VALUE
a985			 
a985					if DEBUG_FORTH_WORDS 
a985						DMARK "+2v" 
a985 f5				push af  
a986 3a 9a a9			ld a, (.dmark)  
a989 32 c0 ee			ld (debug_mark),a  
a98c 3a 9b a9			ld a, (.dmark+1)  
a98f 32 c1 ee			ld (debug_mark+1),a  
a992 3a 9c a9			ld a, (.dmark+2)  
a995 32 c2 ee			ld (debug_mark+2),a  
a998 18 03			jr .pastdmark  
a99a ..			.dmark: db "+2v"  
a99d f1			.pastdmark: pop af  
a99e			endm  
# End of macro DMARK
a99e						CALLMONITOR 
a99e cd 2e 93			call break_point_state  
a9a1				endm  
# End of macro CALLMONITOR
a9a1					endif 
a9a1			 
a9a1 19					add hl, de 
a9a2			 
a9a2					if DEBUG_FORTH_WORDS 
a9a2						DMARK "+2+" 
a9a2 f5				push af  
a9a3 3a b7 a9			ld a, (.dmark)  
a9a6 32 c0 ee			ld (debug_mark),a  
a9a9 3a b8 a9			ld a, (.dmark+1)  
a9ac 32 c1 ee			ld (debug_mark+1),a  
a9af 3a b9 a9			ld a, (.dmark+2)  
a9b2 32 c2 ee			ld (debug_mark+2),a  
a9b5 18 03			jr .pastdmark  
a9b7 ..			.dmark: db "+2+"  
a9ba f1			.pastdmark: pop af  
a9bb			endm  
# End of macro DMARK
a9bb						CALLMONITOR 
a9bb cd 2e 93			call break_point_state  
a9be				endm  
# End of macro CALLMONITOR
a9be					endif 
a9be			 
a9be					; move result to de 
a9be			 
a9be eb					ex de, hl 
a9bf			 
a9bf					; Address 
a9bf			 
a9bf e1					pop hl 
a9c0			 
a9c0					; save it back 
a9c0			 
a9c0 73					ld (hl), e 
a9c1 23					inc hl 
a9c2 72					ld (hl), d 
a9c3			 
a9c3					if DEBUG_FORTH_WORDS 
a9c3						DMARK "+2e" 
a9c3 f5				push af  
a9c4 3a d8 a9			ld a, (.dmark)  
a9c7 32 c0 ee			ld (debug_mark),a  
a9ca 3a d9 a9			ld a, (.dmark+1)  
a9cd 32 c1 ee			ld (debug_mark+1),a  
a9d0 3a da a9			ld a, (.dmark+2)  
a9d3 32 c2 ee			ld (debug_mark+2),a  
a9d6 18 03			jr .pastdmark  
a9d8 ..			.dmark: db "+2e"  
a9db f1			.pastdmark: pop af  
a9dc			endm  
# End of macro DMARK
a9dc						CALLMONITOR 
a9dc cd 2e 93			call break_point_state  
a9df				endm  
# End of macro CALLMONITOR
a9df					endif 
a9df			 
a9df			 
a9df			 
a9df			 
a9df			 
a9df				       NEXTW 
a9df c3 24 9c			jp macro_next 
a9e2				endm 
# End of macro NEXTW
a9e2			 
a9e2			.DEC2: 
a9e2				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
a9e2 6f				db WORD_SYS_CORE+91             
a9e3 8e aa			dw .GET2            
a9e5 04				db 3 + 1 
a9e6 .. 00			db "-2!",0              
a9ea				endm 
# End of macro CWHEAD
a9ea			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
a9ea			 
a9ea			 
a9ea					if DEBUG_FORTH_WORDS_KEY 
a9ea						DMARK "-2s" 
a9ea f5				push af  
a9eb 3a ff a9			ld a, (.dmark)  
a9ee 32 c0 ee			ld (debug_mark),a  
a9f1 3a 00 aa			ld a, (.dmark+1)  
a9f4 32 c1 ee			ld (debug_mark+1),a  
a9f7 3a 01 aa			ld a, (.dmark+2)  
a9fa 32 c2 ee			ld (debug_mark+2),a  
a9fd 18 03			jr .pastdmark  
a9ff ..			.dmark: db "-2s"  
aa02 f1			.pastdmark: pop af  
aa03			endm  
# End of macro DMARK
aa03						CALLMONITOR 
aa03 cd 2e 93			call break_point_state  
aa06				endm  
# End of macro CALLMONITOR
aa06					endif 
aa06			 
aa06					; Address 
aa06			 
aa06					FORTH_DSP_VALUEHL 
aa06 cd b2 9a			call macro_dsp_valuehl 
aa09				endm 
# End of macro FORTH_DSP_VALUEHL
aa09			 
aa09 e5					push hl    ; save address 
aa0a			 
aa0a					; load content into de 
aa0a			 
aa0a 5e					ld e,(hl) 
aa0b 23					inc hl 
aa0c 56					ld d, (hl) 
aa0d			 
aa0d					if DEBUG_FORTH_WORDS 
aa0d						DMARK "-2a" 
aa0d f5				push af  
aa0e 3a 22 aa			ld a, (.dmark)  
aa11 32 c0 ee			ld (debug_mark),a  
aa14 3a 23 aa			ld a, (.dmark+1)  
aa17 32 c1 ee			ld (debug_mark+1),a  
aa1a 3a 24 aa			ld a, (.dmark+2)  
aa1d 32 c2 ee			ld (debug_mark+2),a  
aa20 18 03			jr .pastdmark  
aa22 ..			.dmark: db "-2a"  
aa25 f1			.pastdmark: pop af  
aa26			endm  
# End of macro DMARK
aa26						CALLMONITOR 
aa26 cd 2e 93			call break_point_state  
aa29				endm  
# End of macro CALLMONITOR
aa29					endif 
aa29			 
aa29					FORTH_DSP_POP 
aa29 cd 6a 9b			call macro_forth_dsp_pop 
aa2c				endm 
# End of macro FORTH_DSP_POP
aa2c			 
aa2c					; Get value to remove 
aa2c			 
aa2c					FORTH_DSP_VALUE 
aa2c cd 9b 9a			call macro_forth_dsp_value 
aa2f				endm 
# End of macro FORTH_DSP_VALUE
aa2f			 
aa2f					if DEBUG_FORTH_WORDS 
aa2f						DMARK "-2v" 
aa2f f5				push af  
aa30 3a 44 aa			ld a, (.dmark)  
aa33 32 c0 ee			ld (debug_mark),a  
aa36 3a 45 aa			ld a, (.dmark+1)  
aa39 32 c1 ee			ld (debug_mark+1),a  
aa3c 3a 46 aa			ld a, (.dmark+2)  
aa3f 32 c2 ee			ld (debug_mark+2),a  
aa42 18 03			jr .pastdmark  
aa44 ..			.dmark: db "-2v"  
aa47 f1			.pastdmark: pop af  
aa48			endm  
# End of macro DMARK
aa48						CALLMONITOR 
aa48 cd 2e 93			call break_point_state  
aa4b				endm  
# End of macro CALLMONITOR
aa4b					endif 
aa4b			 
aa4b eb					ex de, hl 
aa4c ed 52				sbc hl, de 
aa4e			 
aa4e					if DEBUG_FORTH_WORDS 
aa4e						DMARK "-2d" 
aa4e f5				push af  
aa4f 3a 63 aa			ld a, (.dmark)  
aa52 32 c0 ee			ld (debug_mark),a  
aa55 3a 64 aa			ld a, (.dmark+1)  
aa58 32 c1 ee			ld (debug_mark+1),a  
aa5b 3a 65 aa			ld a, (.dmark+2)  
aa5e 32 c2 ee			ld (debug_mark+2),a  
aa61 18 03			jr .pastdmark  
aa63 ..			.dmark: db "-2d"  
aa66 f1			.pastdmark: pop af  
aa67			endm  
# End of macro DMARK
aa67						CALLMONITOR 
aa67 cd 2e 93			call break_point_state  
aa6a				endm  
# End of macro CALLMONITOR
aa6a					endif 
aa6a			 
aa6a					; move result to de 
aa6a			 
aa6a eb					ex de, hl 
aa6b			 
aa6b					; Address 
aa6b			 
aa6b e1					pop hl 
aa6c			 
aa6c					; save it back 
aa6c			 
aa6c 73					ld (hl), e 
aa6d 23					inc hl 
aa6e 72					ld (hl), d 
aa6f			 
aa6f					if DEBUG_FORTH_WORDS 
aa6f						DMARK "-2e" 
aa6f f5				push af  
aa70 3a 84 aa			ld a, (.dmark)  
aa73 32 c0 ee			ld (debug_mark),a  
aa76 3a 85 aa			ld a, (.dmark+1)  
aa79 32 c1 ee			ld (debug_mark+1),a  
aa7c 3a 86 aa			ld a, (.dmark+2)  
aa7f 32 c2 ee			ld (debug_mark+2),a  
aa82 18 03			jr .pastdmark  
aa84 ..			.dmark: db "-2e"  
aa87 f1			.pastdmark: pop af  
aa88			endm  
# End of macro DMARK
aa88						CALLMONITOR 
aa88 cd 2e 93			call break_point_state  
aa8b				endm  
# End of macro CALLMONITOR
aa8b					endif 
aa8b			 
aa8b			 
aa8b			 
aa8b			 
aa8b			 
aa8b				       NEXTW 
aa8b c3 24 9c			jp macro_next 
aa8e				endm 
# End of macro NEXTW
aa8e			.GET2: 
aa8e				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
aa8e 6f				db WORD_SYS_CORE+91             
aa8f be aa			dw .BANG2            
aa91 03				db 2 + 1 
aa92 .. 00			db "2@",0              
aa95				endm 
# End of macro CWHEAD
aa95			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
aa95					if DEBUG_FORTH_WORDS_KEY 
aa95						DMARK "2A_" 
aa95 f5				push af  
aa96 3a aa aa			ld a, (.dmark)  
aa99 32 c0 ee			ld (debug_mark),a  
aa9c 3a ab aa			ld a, (.dmark+1)  
aa9f 32 c1 ee			ld (debug_mark+1),a  
aaa2 3a ac aa			ld a, (.dmark+2)  
aaa5 32 c2 ee			ld (debug_mark+2),a  
aaa8 18 03			jr .pastdmark  
aaaa ..			.dmark: db "2A_"  
aaad f1			.pastdmark: pop af  
aaae			endm  
# End of macro DMARK
aaae						CALLMONITOR 
aaae cd 2e 93			call break_point_state  
aab1				endm  
# End of macro CALLMONITOR
aab1					endif 
aab1			 
aab1					FORTH_DSP_VALUEHL 
aab1 cd b2 9a			call macro_dsp_valuehl 
aab4				endm 
# End of macro FORTH_DSP_VALUEHL
aab4			 
aab4 5e					ld e, (hl) 
aab5 23					inc hl 
aab6 56					ld d, (hl) 
aab7			 
aab7 eb					ex de, hl 
aab8			 
aab8 cd bb 98				call forth_push_numhl 
aabb			 
aabb				       NEXTW 
aabb c3 24 9c			jp macro_next 
aabe				endm 
# End of macro NEXTW
aabe			.BANG2: 
aabe				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
aabe 6f				db WORD_SYS_CORE+91             
aabf f6 aa			dw .CONFIG            
aac1 03				db 2 + 1 
aac2 .. 00			db "2!",0              
aac5				endm 
# End of macro CWHEAD
aac5			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
aac5					if DEBUG_FORTH_WORDS_KEY 
aac5						DMARK "2S_" 
aac5 f5				push af  
aac6 3a da aa			ld a, (.dmark)  
aac9 32 c0 ee			ld (debug_mark),a  
aacc 3a db aa			ld a, (.dmark+1)  
aacf 32 c1 ee			ld (debug_mark+1),a  
aad2 3a dc aa			ld a, (.dmark+2)  
aad5 32 c2 ee			ld (debug_mark+2),a  
aad8 18 03			jr .pastdmark  
aada ..			.dmark: db "2S_"  
aadd f1			.pastdmark: pop af  
aade			endm  
# End of macro DMARK
aade						CALLMONITOR 
aade cd 2e 93			call break_point_state  
aae1				endm  
# End of macro CALLMONITOR
aae1					endif 
aae1			 
aae1					FORTH_DSP_VALUEHL 
aae1 cd b2 9a			call macro_dsp_valuehl 
aae4				endm 
# End of macro FORTH_DSP_VALUEHL
aae4			 
aae4 e5					push hl   ; save address 
aae5			 
aae5			 
aae5					FORTH_DSP_POP 
aae5 cd 6a 9b			call macro_forth_dsp_pop 
aae8				endm 
# End of macro FORTH_DSP_POP
aae8			 
aae8					 
aae8					FORTH_DSP_VALUEHL 
aae8 cd b2 9a			call macro_dsp_valuehl 
aaeb				endm 
# End of macro FORTH_DSP_VALUEHL
aaeb			 
aaeb					FORTH_DSP_POP 
aaeb cd 6a 9b			call macro_forth_dsp_pop 
aaee				endm 
# End of macro FORTH_DSP_POP
aaee			 
aaee eb					ex de, hl    ; value now in de 
aaef			 
aaef e1					pop hl 
aaf0			 
aaf0 73					ld (hl), e 
aaf1			 
aaf1 23					inc hl 
aaf2			 
aaf2 72					ld (hl), d 
aaf3			 
aaf3			 
aaf3				       NEXTW 
aaf3 c3 24 9c			jp macro_next 
aaf6				endm 
# End of macro NEXTW
aaf6			.CONFIG: 
aaf6				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
aaf6 6f				db WORD_SYS_CORE+91             
aaf7 07 ab			dw .ENDCORE            
aaf9 07				db 6 + 1 
aafa .. 00			db "CONFIG",0              
ab01				endm 
# End of macro CWHEAD
ab01			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
ab01			 
ab01 cd 1b 91				call config 
ab04					NEXTW 
ab04 c3 24 9c			jp macro_next 
ab07				endm 
# End of macro NEXTW
ab07			.ENDCORE: 
ab07			 
ab07			; eof 
ab07			 
ab07			 
# End of file forth_words_core.asm
ab07			include "forth_words_flow.asm" 
ab07			 
ab07			; | ## Program Flow Words 
ab07			 
ab07			.IF: 
ab07				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ab07 1e				db WORD_SYS_CORE+10             
ab08 fc ab			dw .THEN            
ab0a 03				db 2 + 1 
ab0b .. 00			db "IF",0              
ab0e				endm 
# End of macro CWHEAD
ab0e			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ab0e			; 
ab0e					if DEBUG_FORTH_WORDS_KEY 
ab0e						DMARK "IF." 
ab0e f5				push af  
ab0f 3a 23 ab			ld a, (.dmark)  
ab12 32 c0 ee			ld (debug_mark),a  
ab15 3a 24 ab			ld a, (.dmark+1)  
ab18 32 c1 ee			ld (debug_mark+1),a  
ab1b 3a 25 ab			ld a, (.dmark+2)  
ab1e 32 c2 ee			ld (debug_mark+2),a  
ab21 18 03			jr .pastdmark  
ab23 ..			.dmark: db "IF."  
ab26 f1			.pastdmark: pop af  
ab27			endm  
# End of macro DMARK
ab27						CALLMONITOR 
ab27 cd 2e 93			call break_point_state  
ab2a				endm  
# End of macro CALLMONITOR
ab2a					endif 
ab2a			; eval TOS 
ab2a			 
ab2a				FORTH_DSP_VALUEHL 
ab2a cd b2 9a			call macro_dsp_valuehl 
ab2d				endm 
# End of macro FORTH_DSP_VALUEHL
ab2d			 
ab2d			;	push hl 
ab2d				FORTH_DSP_POP 
ab2d cd 6a 9b			call macro_forth_dsp_pop 
ab30				endm 
# End of macro FORTH_DSP_POP
ab30			;	pop hl 
ab30			 
ab30					if DEBUG_FORTH_WORDS 
ab30						DMARK "IF1" 
ab30 f5				push af  
ab31 3a 45 ab			ld a, (.dmark)  
ab34 32 c0 ee			ld (debug_mark),a  
ab37 3a 46 ab			ld a, (.dmark+1)  
ab3a 32 c1 ee			ld (debug_mark+1),a  
ab3d 3a 47 ab			ld a, (.dmark+2)  
ab40 32 c2 ee			ld (debug_mark+2),a  
ab43 18 03			jr .pastdmark  
ab45 ..			.dmark: db "IF1"  
ab48 f1			.pastdmark: pop af  
ab49			endm  
# End of macro DMARK
ab49						CALLMONITOR 
ab49 cd 2e 93			call break_point_state  
ab4c				endm  
# End of macro CALLMONITOR
ab4c					endif 
ab4c b7				or a        ; clear carry flag 
ab4d 11 00 00			ld de, 0 
ab50 eb				ex de,hl 
ab51 ed 52			sbc hl, de 
ab53 c2 dd ab			jp nz, .iftrue 
ab56			 
ab56					if DEBUG_FORTH_WORDS 
ab56						DMARK "IF2" 
ab56 f5				push af  
ab57 3a 6b ab			ld a, (.dmark)  
ab5a 32 c0 ee			ld (debug_mark),a  
ab5d 3a 6c ab			ld a, (.dmark+1)  
ab60 32 c1 ee			ld (debug_mark+1),a  
ab63 3a 6d ab			ld a, (.dmark+2)  
ab66 32 c2 ee			ld (debug_mark+2),a  
ab69 18 03			jr .pastdmark  
ab6b ..			.dmark: db "IF2"  
ab6e f1			.pastdmark: pop af  
ab6f			endm  
# End of macro DMARK
ab6f						CALLMONITOR 
ab6f cd 2e 93			call break_point_state  
ab72				endm  
# End of macro CALLMONITOR
ab72					endif 
ab72			 
ab72			; if not true then skip to THEN 
ab72			 
ab72				; TODO get tok_ptr 
ab72				; TODO consume toks until we get to THEN 
ab72			 
ab72 2a e7 e7			ld hl, (os_tok_ptr) 
ab75					if DEBUG_FORTH_WORDS 
ab75						DMARK "IF3" 
ab75 f5				push af  
ab76 3a 8a ab			ld a, (.dmark)  
ab79 32 c0 ee			ld (debug_mark),a  
ab7c 3a 8b ab			ld a, (.dmark+1)  
ab7f 32 c1 ee			ld (debug_mark+1),a  
ab82 3a 8c ab			ld a, (.dmark+2)  
ab85 32 c2 ee			ld (debug_mark+2),a  
ab88 18 03			jr .pastdmark  
ab8a ..			.dmark: db "IF3"  
ab8d f1			.pastdmark: pop af  
ab8e			endm  
# End of macro DMARK
ab8e						CALLMONITOR 
ab8e cd 2e 93			call break_point_state  
ab91				endm  
# End of macro CALLMONITOR
ab91						 
ab91					endif 
ab91 11 d8 ab			ld de, .ifthen 
ab94					if DEBUG_FORTH_WORDS 
ab94						DMARK "IF4" 
ab94 f5				push af  
ab95 3a a9 ab			ld a, (.dmark)  
ab98 32 c0 ee			ld (debug_mark),a  
ab9b 3a aa ab			ld a, (.dmark+1)  
ab9e 32 c1 ee			ld (debug_mark+1),a  
aba1 3a ab ab			ld a, (.dmark+2)  
aba4 32 c2 ee			ld (debug_mark+2),a  
aba7 18 03			jr .pastdmark  
aba9 ..			.dmark: db "IF4"  
abac f1			.pastdmark: pop af  
abad			endm  
# End of macro DMARK
abad						CALLMONITOR 
abad cd 2e 93			call break_point_state  
abb0				endm  
# End of macro CALLMONITOR
abb0					endif 
abb0 cd 3f 9d			call findnexttok  
abb3			 
abb3					if DEBUG_FORTH_WORDS 
abb3						DMARK "IF5" 
abb3 f5				push af  
abb4 3a c8 ab			ld a, (.dmark)  
abb7 32 c0 ee			ld (debug_mark),a  
abba 3a c9 ab			ld a, (.dmark+1)  
abbd 32 c1 ee			ld (debug_mark+1),a  
abc0 3a ca ab			ld a, (.dmark+2)  
abc3 32 c2 ee			ld (debug_mark+2),a  
abc6 18 03			jr .pastdmark  
abc8 ..			.dmark: db "IF5"  
abcb f1			.pastdmark: pop af  
abcc			endm  
# End of macro DMARK
abcc						CALLMONITOR 
abcc cd 2e 93			call break_point_state  
abcf				endm  
# End of macro CALLMONITOR
abcf					endif 
abcf				; TODO replace below with ; exec using tok_ptr 
abcf 22 e7 e7			ld (os_tok_ptr), hl 
abd2 c3 b5 9c			jp exec1 
abd5				NEXTW 
abd5 c3 24 9c			jp macro_next 
abd8				endm 
# End of macro NEXTW
abd8			 
abd8 .. 00		.ifthen:  db "THEN",0 
abdd			 
abdd			.iftrue:		 
abdd				; Exec next words normally 
abdd			 
abdd				; if true then exec following IF as normal 
abdd					if DEBUG_FORTH_WORDS 
abdd						DMARK "IFT" 
abdd f5				push af  
abde 3a f2 ab			ld a, (.dmark)  
abe1 32 c0 ee			ld (debug_mark),a  
abe4 3a f3 ab			ld a, (.dmark+1)  
abe7 32 c1 ee			ld (debug_mark+1),a  
abea 3a f4 ab			ld a, (.dmark+2)  
abed 32 c2 ee			ld (debug_mark+2),a  
abf0 18 03			jr .pastdmark  
abf2 ..			.dmark: db "IFT"  
abf5 f1			.pastdmark: pop af  
abf6			endm  
# End of macro DMARK
abf6						CALLMONITOR 
abf6 cd 2e 93			call break_point_state  
abf9				endm  
# End of macro CALLMONITOR
abf9					endif 
abf9			 
abf9					NEXTW 
abf9 c3 24 9c			jp macro_next 
abfc				endm 
# End of macro NEXTW
abfc			.THEN: 
abfc				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
abfc 1f				db WORD_SYS_CORE+11             
abfd 24 ac			dw .ELSE            
abff 05				db 4 + 1 
ac00 .. 00			db "THEN",0              
ac05				endm 
# End of macro CWHEAD
ac05			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
ac05					if DEBUG_FORTH_WORDS_KEY 
ac05						DMARK "THN" 
ac05 f5				push af  
ac06 3a 1a ac			ld a, (.dmark)  
ac09 32 c0 ee			ld (debug_mark),a  
ac0c 3a 1b ac			ld a, (.dmark+1)  
ac0f 32 c1 ee			ld (debug_mark+1),a  
ac12 3a 1c ac			ld a, (.dmark+2)  
ac15 32 c2 ee			ld (debug_mark+2),a  
ac18 18 03			jr .pastdmark  
ac1a ..			.dmark: db "THN"  
ac1d f1			.pastdmark: pop af  
ac1e			endm  
# End of macro DMARK
ac1e						CALLMONITOR 
ac1e cd 2e 93			call break_point_state  
ac21				endm  
# End of macro CALLMONITOR
ac21					endif 
ac21					NEXTW 
ac21 c3 24 9c			jp macro_next 
ac24				endm 
# End of macro NEXTW
ac24			.ELSE: 
ac24				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
ac24 20				db WORD_SYS_CORE+12             
ac25 4c ac			dw .DO            
ac27 03				db 2 + 1 
ac28 .. 00			db "ELSE",0              
ac2d				endm 
# End of macro CWHEAD
ac2d			; | ELSE ( -- ) Not supported - does nothing | TODO 
ac2d			 
ac2d					if DEBUG_FORTH_WORDS_KEY 
ac2d						DMARK "ELS" 
ac2d f5				push af  
ac2e 3a 42 ac			ld a, (.dmark)  
ac31 32 c0 ee			ld (debug_mark),a  
ac34 3a 43 ac			ld a, (.dmark+1)  
ac37 32 c1 ee			ld (debug_mark+1),a  
ac3a 3a 44 ac			ld a, (.dmark+2)  
ac3d 32 c2 ee			ld (debug_mark+2),a  
ac40 18 03			jr .pastdmark  
ac42 ..			.dmark: db "ELS"  
ac45 f1			.pastdmark: pop af  
ac46			endm  
# End of macro DMARK
ac46						CALLMONITOR 
ac46 cd 2e 93			call break_point_state  
ac49				endm  
# End of macro CALLMONITOR
ac49					endif 
ac49			 
ac49			 
ac49					NEXTW 
ac49 c3 24 9c			jp macro_next 
ac4c				endm 
# End of macro NEXTW
ac4c			.DO: 
ac4c				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
ac4c 21				db WORD_SYS_CORE+13             
ac4d 73 ad			dw .LOOP            
ac4f 03				db 2 + 1 
ac50 .. 00			db "DO",0              
ac53				endm 
# End of macro CWHEAD
ac53			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
ac53			 
ac53					if DEBUG_FORTH_WORDS_KEY 
ac53						DMARK "DO." 
ac53 f5				push af  
ac54 3a 68 ac			ld a, (.dmark)  
ac57 32 c0 ee			ld (debug_mark),a  
ac5a 3a 69 ac			ld a, (.dmark+1)  
ac5d 32 c1 ee			ld (debug_mark+1),a  
ac60 3a 6a ac			ld a, (.dmark+2)  
ac63 32 c2 ee			ld (debug_mark+2),a  
ac66 18 03			jr .pastdmark  
ac68 ..			.dmark: db "DO."  
ac6b f1			.pastdmark: pop af  
ac6c			endm  
# End of macro DMARK
ac6c						CALLMONITOR 
ac6c cd 2e 93			call break_point_state  
ac6f				endm  
# End of macro CALLMONITOR
ac6f					endif 
ac6f			;  push pc to rsp stack past the DO 
ac6f			 
ac6f 2a e7 e7				ld hl, (os_tok_ptr) 
ac72 23					inc hl   ; D 
ac73 23					inc hl  ; O 
ac74 23					inc hl   ; null 
ac75					if DEBUG_FORTH_WORDS 
ac75						DMARK "DO2" 
ac75 f5				push af  
ac76 3a 8a ac			ld a, (.dmark)  
ac79 32 c0 ee			ld (debug_mark),a  
ac7c 3a 8b ac			ld a, (.dmark+1)  
ac7f 32 c1 ee			ld (debug_mark+1),a  
ac82 3a 8c ac			ld a, (.dmark+2)  
ac85 32 c2 ee			ld (debug_mark+2),a  
ac88 18 03			jr .pastdmark  
ac8a ..			.dmark: db "DO2"  
ac8d f1			.pastdmark: pop af  
ac8e			endm  
# End of macro DMARK
ac8e						CALLMONITOR 
ac8e cd 2e 93			call break_point_state  
ac91				endm  
# End of macro CALLMONITOR
ac91					endif 
ac91					FORTH_RSP_NEXT 
ac91 cd 62 98			call macro_forth_rsp_next 
ac94				endm 
# End of macro FORTH_RSP_NEXT
ac94					if DEBUG_FORTH_WORDS 
ac94						DMARK "DO3" 
ac94 f5				push af  
ac95 3a a9 ac			ld a, (.dmark)  
ac98 32 c0 ee			ld (debug_mark),a  
ac9b 3a aa ac			ld a, (.dmark+1)  
ac9e 32 c1 ee			ld (debug_mark+1),a  
aca1 3a ab ac			ld a, (.dmark+2)  
aca4 32 c2 ee			ld (debug_mark+2),a  
aca7 18 03			jr .pastdmark  
aca9 ..			.dmark: db "DO3"  
acac f1			.pastdmark: pop af  
acad			endm  
# End of macro DMARK
acad						CALLMONITOR 
acad cd 2e 93			call break_point_state  
acb0				endm  
# End of macro CALLMONITOR
acb0					endif 
acb0			 
acb0					;if DEBUG_FORTH_WORDS 
acb0				;		push hl 
acb0			;		endif  
acb0			 
acb0			; get counters from data stack 
acb0			 
acb0			 
acb0					FORTH_DSP_VALUEHL 
acb0 cd b2 9a			call macro_dsp_valuehl 
acb3				endm 
# End of macro FORTH_DSP_VALUEHL
acb3 e5					push hl		 ; hl now has starting counter which needs to be tos 
acb4			 
acb4					if DEBUG_FORTH_WORDS 
acb4						DMARK "DO4" 
acb4 f5				push af  
acb5 3a c9 ac			ld a, (.dmark)  
acb8 32 c0 ee			ld (debug_mark),a  
acbb 3a ca ac			ld a, (.dmark+1)  
acbe 32 c1 ee			ld (debug_mark+1),a  
acc1 3a cb ac			ld a, (.dmark+2)  
acc4 32 c2 ee			ld (debug_mark+2),a  
acc7 18 03			jr .pastdmark  
acc9 ..			.dmark: db "DO4"  
accc f1			.pastdmark: pop af  
accd			endm  
# End of macro DMARK
accd						CALLMONITOR 
accd cd 2e 93			call break_point_state  
acd0				endm  
# End of macro CALLMONITOR
acd0					endif 
acd0					FORTH_DSP_POP 
acd0 cd 6a 9b			call macro_forth_dsp_pop 
acd3				endm 
# End of macro FORTH_DSP_POP
acd3			 
acd3					if DEBUG_FORTH_WORDS 
acd3						DMARK "DO5" 
acd3 f5				push af  
acd4 3a e8 ac			ld a, (.dmark)  
acd7 32 c0 ee			ld (debug_mark),a  
acda 3a e9 ac			ld a, (.dmark+1)  
acdd 32 c1 ee			ld (debug_mark+1),a  
ace0 3a ea ac			ld a, (.dmark+2)  
ace3 32 c2 ee			ld (debug_mark+2),a  
ace6 18 03			jr .pastdmark  
ace8 ..			.dmark: db "DO5"  
aceb f1			.pastdmark: pop af  
acec			endm  
# End of macro DMARK
acec						CALLMONITOR 
acec cd 2e 93			call break_point_state  
acef				endm  
# End of macro CALLMONITOR
acef					endif 
acef			 
acef					FORTH_DSP_VALUEHL 
acef cd b2 9a			call macro_dsp_valuehl 
acf2				endm 
# End of macro FORTH_DSP_VALUEHL
acf2			;		push hl		 ; hl now has starting limit counter 
acf2			 
acf2					if DEBUG_FORTH_WORDS 
acf2						DMARK "DO6" 
acf2 f5				push af  
acf3 3a 07 ad			ld a, (.dmark)  
acf6 32 c0 ee			ld (debug_mark),a  
acf9 3a 08 ad			ld a, (.dmark+1)  
acfc 32 c1 ee			ld (debug_mark+1),a  
acff 3a 09 ad			ld a, (.dmark+2)  
ad02 32 c2 ee			ld (debug_mark+2),a  
ad05 18 03			jr .pastdmark  
ad07 ..			.dmark: db "DO6"  
ad0a f1			.pastdmark: pop af  
ad0b			endm  
# End of macro DMARK
ad0b						CALLMONITOR 
ad0b cd 2e 93			call break_point_state  
ad0e				endm  
# End of macro CALLMONITOR
ad0e					endif 
ad0e					FORTH_DSP_POP 
ad0e cd 6a 9b			call macro_forth_dsp_pop 
ad11				endm 
# End of macro FORTH_DSP_POP
ad11			 
ad11			; put counters on the loop stack 
ad11			 
ad11			;		pop hl			 ; limit counter 
ad11 d1					pop de			; start counter 
ad12			 
ad12					; push limit counter 
ad12			 
ad12					if DEBUG_FORTH_WORDS 
ad12						DMARK "DO7" 
ad12 f5				push af  
ad13 3a 27 ad			ld a, (.dmark)  
ad16 32 c0 ee			ld (debug_mark),a  
ad19 3a 28 ad			ld a, (.dmark+1)  
ad1c 32 c1 ee			ld (debug_mark+1),a  
ad1f 3a 29 ad			ld a, (.dmark+2)  
ad22 32 c2 ee			ld (debug_mark+2),a  
ad25 18 03			jr .pastdmark  
ad27 ..			.dmark: db "DO7"  
ad2a f1			.pastdmark: pop af  
ad2b			endm  
# End of macro DMARK
ad2b						CALLMONITOR 
ad2b cd 2e 93			call break_point_state  
ad2e				endm  
# End of macro CALLMONITOR
ad2e					endif 
ad2e					FORTH_LOOP_NEXT 
ad2e cd e3 9a			call macro_forth_loop_next 
ad31				endm 
# End of macro FORTH_LOOP_NEXT
ad31			 
ad31					; push start counter 
ad31			 
ad31 eb					ex de, hl 
ad32					if DEBUG_FORTH_WORDS 
ad32						DMARK "DO7" 
ad32 f5				push af  
ad33 3a 47 ad			ld a, (.dmark)  
ad36 32 c0 ee			ld (debug_mark),a  
ad39 3a 48 ad			ld a, (.dmark+1)  
ad3c 32 c1 ee			ld (debug_mark+1),a  
ad3f 3a 49 ad			ld a, (.dmark+2)  
ad42 32 c2 ee			ld (debug_mark+2),a  
ad45 18 03			jr .pastdmark  
ad47 ..			.dmark: db "DO7"  
ad4a f1			.pastdmark: pop af  
ad4b			endm  
# End of macro DMARK
ad4b						CALLMONITOR 
ad4b cd 2e 93			call break_point_state  
ad4e				endm  
# End of macro CALLMONITOR
ad4e					endif 
ad4e					FORTH_LOOP_NEXT 
ad4e cd e3 9a			call macro_forth_loop_next 
ad51				endm 
# End of macro FORTH_LOOP_NEXT
ad51			 
ad51			 
ad51					; init first round of I counter 
ad51			 
ad51 22 0b e8				ld (os_current_i), hl 
ad54			 
ad54					if DEBUG_FORTH_WORDS 
ad54						DMARK "DO8" 
ad54 f5				push af  
ad55 3a 69 ad			ld a, (.dmark)  
ad58 32 c0 ee			ld (debug_mark),a  
ad5b 3a 6a ad			ld a, (.dmark+1)  
ad5e 32 c1 ee			ld (debug_mark+1),a  
ad61 3a 6b ad			ld a, (.dmark+2)  
ad64 32 c2 ee			ld (debug_mark+2),a  
ad67 18 03			jr .pastdmark  
ad69 ..			.dmark: db "DO8"  
ad6c f1			.pastdmark: pop af  
ad6d			endm  
# End of macro DMARK
ad6d						CALLMONITOR 
ad6d cd 2e 93			call break_point_state  
ad70				endm  
# End of macro CALLMONITOR
ad70					endif 
ad70			 
ad70					NEXTW 
ad70 c3 24 9c			jp macro_next 
ad73				endm 
# End of macro NEXTW
ad73			.LOOP: 
ad73				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
ad73 22				db WORD_SYS_CORE+14             
ad74 8b ae			dw .I            
ad76 05				db 4 + 1 
ad77 .. 00			db "LOOP",0              
ad7c				endm 
# End of macro CWHEAD
ad7c			; | LOOP ( -- ) Increment and test loop counter  | DONE 
ad7c			 
ad7c				; pop tos as current loop count to hl 
ad7c			 
ad7c				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
ad7c			 
ad7c				FORTH_LOOP_TOS 
ad7c cd 16 9b			call macro_forth_loop_tos 
ad7f				endm 
# End of macro FORTH_LOOP_TOS
ad7f e5				push hl 
ad80			 
ad80					if DEBUG_FORTH_WORDS_KEY 
ad80						DMARK "LOP" 
ad80 f5				push af  
ad81 3a 95 ad			ld a, (.dmark)  
ad84 32 c0 ee			ld (debug_mark),a  
ad87 3a 96 ad			ld a, (.dmark+1)  
ad8a 32 c1 ee			ld (debug_mark+1),a  
ad8d 3a 97 ad			ld a, (.dmark+2)  
ad90 32 c2 ee			ld (debug_mark+2),a  
ad93 18 03			jr .pastdmark  
ad95 ..			.dmark: db "LOP"  
ad98 f1			.pastdmark: pop af  
ad99			endm  
# End of macro DMARK
ad99						CALLMONITOR 
ad99 cd 2e 93			call break_point_state  
ad9c				endm  
# End of macro CALLMONITOR
ad9c					endif 
ad9c				; next item on the stack is the limit. get it 
ad9c			 
ad9c			 
ad9c				FORTH_LOOP_POP 
ad9c cd 20 9b			call macro_forth_loop_pop 
ad9f				endm 
# End of macro FORTH_LOOP_POP
ad9f			 
ad9f				FORTH_LOOP_TOS 
ad9f cd 16 9b			call macro_forth_loop_tos 
ada2				endm 
# End of macro FORTH_LOOP_TOS
ada2			 
ada2 d1				pop de		 ; de = i, hl = limit 
ada3			 
ada3					if DEBUG_FORTH_WORDS 
ada3						DMARK "LP1" 
ada3 f5				push af  
ada4 3a b8 ad			ld a, (.dmark)  
ada7 32 c0 ee			ld (debug_mark),a  
adaa 3a b9 ad			ld a, (.dmark+1)  
adad 32 c1 ee			ld (debug_mark+1),a  
adb0 3a ba ad			ld a, (.dmark+2)  
adb3 32 c2 ee			ld (debug_mark+2),a  
adb6 18 03			jr .pastdmark  
adb8 ..			.dmark: db "LP1"  
adbb f1			.pastdmark: pop af  
adbc			endm  
# End of macro DMARK
adbc						CALLMONITOR 
adbc cd 2e 93			call break_point_state  
adbf				endm  
# End of macro CALLMONITOR
adbf					endif 
adbf			 
adbf				; go back to previous word 
adbf			 
adbf d5				push de    ; save I for inc later 
adc0			 
adc0			 
adc0				; get limit 
adc0				;  is I at limit? 
adc0			 
adc0			 
adc0					if DEBUG_FORTH_WORDS 
adc0						DMARK "LP1" 
adc0 f5				push af  
adc1 3a d5 ad			ld a, (.dmark)  
adc4 32 c0 ee			ld (debug_mark),a  
adc7 3a d6 ad			ld a, (.dmark+1)  
adca 32 c1 ee			ld (debug_mark+1),a  
adcd 3a d7 ad			ld a, (.dmark+2)  
add0 32 c2 ee			ld (debug_mark+2),a  
add3 18 03			jr .pastdmark  
add5 ..			.dmark: db "LP1"  
add8 f1			.pastdmark: pop af  
add9			endm  
# End of macro DMARK
add9						CALLMONITOR 
add9 cd 2e 93			call break_point_state  
addc				endm  
# End of macro CALLMONITOR
addc					endif 
addc			 
addc ed 52			sbc hl, de 
adde			 
adde			 
adde				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
adde			 
adde 20 26				jr nz, .loopnotdone 
ade0			 
ade0 e1				pop hl   ; get rid of saved I 
ade1				FORTH_LOOP_POP     ; get rid of limit 
ade1 cd 20 9b			call macro_forth_loop_pop 
ade4				endm 
# End of macro FORTH_LOOP_POP
ade4			 
ade4				FORTH_RSP_POP     ; get rid of DO ptr 
ade4 cd 83 98			call macro_forth_rsp_pop 
ade7				endm 
# End of macro FORTH_RSP_POP
ade7			 
ade7			if DEBUG_FORTH_WORDS 
ade7						DMARK "LP>" 
ade7 f5				push af  
ade8 3a fc ad			ld a, (.dmark)  
adeb 32 c0 ee			ld (debug_mark),a  
adee 3a fd ad			ld a, (.dmark+1)  
adf1 32 c1 ee			ld (debug_mark+1),a  
adf4 3a fe ad			ld a, (.dmark+2)  
adf7 32 c2 ee			ld (debug_mark+2),a  
adfa 18 03			jr .pastdmark  
adfc ..			.dmark: db "LP>"  
adff f1			.pastdmark: pop af  
ae00			endm  
# End of macro DMARK
ae00				CALLMONITOR 
ae00 cd 2e 93			call break_point_state  
ae03				endm  
# End of macro CALLMONITOR
ae03			endif 
ae03			 
ae03					NEXTW 
ae03 c3 24 9c			jp macro_next 
ae06				endm 
# End of macro NEXTW
ae06				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
ae06			 
ae06			.loopnotdone: 
ae06			 
ae06 e1				pop hl    ; get I 
ae07 23				inc hl 
ae08			 
ae08			   	; save new I 
ae08			 
ae08			 
ae08					; set I counter 
ae08			 
ae08 22 0b e8				ld (os_current_i), hl 
ae0b			 
ae0b					if DEBUG_FORTH_WORDS 
ae0b						DMARK "LPN" 
ae0b f5				push af  
ae0c 3a 20 ae			ld a, (.dmark)  
ae0f 32 c0 ee			ld (debug_mark),a  
ae12 3a 21 ae			ld a, (.dmark+1)  
ae15 32 c1 ee			ld (debug_mark+1),a  
ae18 3a 22 ae			ld a, (.dmark+2)  
ae1b 32 c2 ee			ld (debug_mark+2),a  
ae1e 18 03			jr .pastdmark  
ae20 ..			.dmark: db "LPN"  
ae23 f1			.pastdmark: pop af  
ae24			endm  
# End of macro DMARK
ae24					CALLMONITOR 
ae24 cd 2e 93			call break_point_state  
ae27				endm  
# End of macro CALLMONITOR
ae27					endif 
ae27					 
ae27				FORTH_LOOP_NEXT 
ae27 cd e3 9a			call macro_forth_loop_next 
ae2a				endm 
# End of macro FORTH_LOOP_NEXT
ae2a			 
ae2a			 
ae2a					if DEBUG_FORTH_WORDS 
ae2a eb						ex de,hl 
ae2b					endif 
ae2b			 
ae2b			;	; get DO ptr 
ae2b			; 
ae2b					if DEBUG_FORTH_WORDS 
ae2b						DMARK "LP7" 
ae2b f5				push af  
ae2c 3a 40 ae			ld a, (.dmark)  
ae2f 32 c0 ee			ld (debug_mark),a  
ae32 3a 41 ae			ld a, (.dmark+1)  
ae35 32 c1 ee			ld (debug_mark+1),a  
ae38 3a 42 ae			ld a, (.dmark+2)  
ae3b 32 c2 ee			ld (debug_mark+2),a  
ae3e 18 03			jr .pastdmark  
ae40 ..			.dmark: db "LP7"  
ae43 f1			.pastdmark: pop af  
ae44			endm  
# End of macro DMARK
ae44					CALLMONITOR 
ae44 cd 2e 93			call break_point_state  
ae47				endm  
# End of macro CALLMONITOR
ae47					endif 
ae47				FORTH_RSP_TOS 
ae47 cd 79 98			call macro_forth_rsp_tos 
ae4a				endm 
# End of macro FORTH_RSP_TOS
ae4a			 
ae4a					if DEBUG_FORTH_WORDS 
ae4a						DMARK "LP8" 
ae4a f5				push af  
ae4b 3a 5f ae			ld a, (.dmark)  
ae4e 32 c0 ee			ld (debug_mark),a  
ae51 3a 60 ae			ld a, (.dmark+1)  
ae54 32 c1 ee			ld (debug_mark+1),a  
ae57 3a 61 ae			ld a, (.dmark+2)  
ae5a 32 c2 ee			ld (debug_mark+2),a  
ae5d 18 03			jr .pastdmark  
ae5f ..			.dmark: db "LP8"  
ae62 f1			.pastdmark: pop af  
ae63			endm  
# End of macro DMARK
ae63					CALLMONITOR 
ae63 cd 2e 93			call break_point_state  
ae66				endm  
# End of macro CALLMONITOR
ae66					endif 
ae66				;push hl 
ae66			 
ae66				; not going to DO any more 
ae66				; get rid of the RSP pointer as DO will add it back in 
ae66				;FORTH_RSP_POP 
ae66				;pop hl 
ae66			 
ae66				;ld hl,(cli_ret_sp) 
ae66				;ld e, (hl) 
ae66				;inc hl 
ae66				;ld d, (hl) 
ae66				;ex de,hl 
ae66 22 e7 e7			ld (os_tok_ptr), hl 
ae69					if DEBUG_FORTH_WORDS 
ae69						DMARK "LP<" 
ae69 f5				push af  
ae6a 3a 7e ae			ld a, (.dmark)  
ae6d 32 c0 ee			ld (debug_mark),a  
ae70 3a 7f ae			ld a, (.dmark+1)  
ae73 32 c1 ee			ld (debug_mark+1),a  
ae76 3a 80 ae			ld a, (.dmark+2)  
ae79 32 c2 ee			ld (debug_mark+2),a  
ae7c 18 03			jr .pastdmark  
ae7e ..			.dmark: db "LP<"  
ae81 f1			.pastdmark: pop af  
ae82			endm  
# End of macro DMARK
ae82					CALLMONITOR 
ae82 cd 2e 93			call break_point_state  
ae85				endm  
# End of macro CALLMONITOR
ae85				endif 
ae85 c3 b5 9c			jp exec1 
ae88			 
ae88					 
ae88			 
ae88			 
ae88					NEXTW 
ae88 c3 24 9c			jp macro_next 
ae8b				endm 
# End of macro NEXTW
ae8b			.I:  
ae8b			 
ae8b				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
ae8b 5e				db WORD_SYS_CORE+74             
ae8c b6 ae			dw .DLOOP            
ae8e 02				db 1 + 1 
ae8f .. 00			db "I",0              
ae91				endm 
# End of macro CWHEAD
ae91			; | I ( -- ) Current loop counter | DONE 
ae91					if DEBUG_FORTH_WORDS_KEY 
ae91						DMARK "I.." 
ae91 f5				push af  
ae92 3a a6 ae			ld a, (.dmark)  
ae95 32 c0 ee			ld (debug_mark),a  
ae98 3a a7 ae			ld a, (.dmark+1)  
ae9b 32 c1 ee			ld (debug_mark+1),a  
ae9e 3a a8 ae			ld a, (.dmark+2)  
aea1 32 c2 ee			ld (debug_mark+2),a  
aea4 18 03			jr .pastdmark  
aea6 ..			.dmark: db "I.."  
aea9 f1			.pastdmark: pop af  
aeaa			endm  
# End of macro DMARK
aeaa						CALLMONITOR 
aeaa cd 2e 93			call break_point_state  
aead				endm  
# End of macro CALLMONITOR
aead					endif 
aead			 
aead 2a 0b e8				ld hl,(os_current_i) 
aeb0 cd bb 98				call forth_push_numhl 
aeb3			 
aeb3					NEXTW 
aeb3 c3 24 9c			jp macro_next 
aeb6				endm 
# End of macro NEXTW
aeb6			.DLOOP: 
aeb6				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
aeb6 5f				db WORD_SYS_CORE+75             
aeb7 97 af			dw .REPEAT            
aeb9 06				db 5 + 1 
aeba .. 00			db "-LOOP",0              
aec0				endm 
# End of macro CWHEAD
aec0			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
aec0				; pop tos as current loop count to hl 
aec0					if DEBUG_FORTH_WORDS_KEY 
aec0						DMARK "-LP" 
aec0 f5				push af  
aec1 3a d5 ae			ld a, (.dmark)  
aec4 32 c0 ee			ld (debug_mark),a  
aec7 3a d6 ae			ld a, (.dmark+1)  
aeca 32 c1 ee			ld (debug_mark+1),a  
aecd 3a d7 ae			ld a, (.dmark+2)  
aed0 32 c2 ee			ld (debug_mark+2),a  
aed3 18 03			jr .pastdmark  
aed5 ..			.dmark: db "-LP"  
aed8 f1			.pastdmark: pop af  
aed9			endm  
# End of macro DMARK
aed9						CALLMONITOR 
aed9 cd 2e 93			call break_point_state  
aedc				endm  
# End of macro CALLMONITOR
aedc					endif 
aedc			 
aedc				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
aedc			 
aedc				FORTH_LOOP_TOS 
aedc cd 16 9b			call macro_forth_loop_tos 
aedf				endm 
# End of macro FORTH_LOOP_TOS
aedf e5				push hl 
aee0			 
aee0					if DEBUG_FORTH_WORDS 
aee0						DMARK "-LP" 
aee0 f5				push af  
aee1 3a f5 ae			ld a, (.dmark)  
aee4 32 c0 ee			ld (debug_mark),a  
aee7 3a f6 ae			ld a, (.dmark+1)  
aeea 32 c1 ee			ld (debug_mark+1),a  
aeed 3a f7 ae			ld a, (.dmark+2)  
aef0 32 c2 ee			ld (debug_mark+2),a  
aef3 18 03			jr .pastdmark  
aef5 ..			.dmark: db "-LP"  
aef8 f1			.pastdmark: pop af  
aef9			endm  
# End of macro DMARK
aef9						CALLMONITOR 
aef9 cd 2e 93			call break_point_state  
aefc				endm  
# End of macro CALLMONITOR
aefc					endif 
aefc				; next item on the stack is the limit. get it 
aefc			 
aefc			 
aefc				FORTH_LOOP_POP 
aefc cd 20 9b			call macro_forth_loop_pop 
aeff				endm 
# End of macro FORTH_LOOP_POP
aeff			 
aeff				FORTH_LOOP_TOS 
aeff cd 16 9b			call macro_forth_loop_tos 
af02				endm 
# End of macro FORTH_LOOP_TOS
af02			 
af02 d1				pop de		 ; de = i, hl = limit 
af03			 
af03					if DEBUG_FORTH_WORDS 
af03						DMARK "-L1" 
af03 f5				push af  
af04 3a 18 af			ld a, (.dmark)  
af07 32 c0 ee			ld (debug_mark),a  
af0a 3a 19 af			ld a, (.dmark+1)  
af0d 32 c1 ee			ld (debug_mark+1),a  
af10 3a 1a af			ld a, (.dmark+2)  
af13 32 c2 ee			ld (debug_mark+2),a  
af16 18 03			jr .pastdmark  
af18 ..			.dmark: db "-L1"  
af1b f1			.pastdmark: pop af  
af1c			endm  
# End of macro DMARK
af1c						CALLMONITOR 
af1c cd 2e 93			call break_point_state  
af1f				endm  
# End of macro CALLMONITOR
af1f					endif 
af1f			 
af1f				; go back to previous word 
af1f			 
af1f d5				push de    ; save I for inc later 
af20			 
af20			 
af20				; get limit 
af20				;  is I at limit? 
af20			 
af20			 
af20					if DEBUG_FORTH_WORDS 
af20						DMARK "-L1" 
af20 f5				push af  
af21 3a 35 af			ld a, (.dmark)  
af24 32 c0 ee			ld (debug_mark),a  
af27 3a 36 af			ld a, (.dmark+1)  
af2a 32 c1 ee			ld (debug_mark+1),a  
af2d 3a 37 af			ld a, (.dmark+2)  
af30 32 c2 ee			ld (debug_mark+2),a  
af33 18 03			jr .pastdmark  
af35 ..			.dmark: db "-L1"  
af38 f1			.pastdmark: pop af  
af39			endm  
# End of macro DMARK
af39						CALLMONITOR 
af39 cd 2e 93			call break_point_state  
af3c				endm  
# End of macro CALLMONITOR
af3c					endif 
af3c			 
af3c ed 52			sbc hl, de 
af3e			 
af3e			 
af3e				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
af3e			 
af3e 20 26				jr nz, .mloopnotdone 
af40			 
af40 e1				pop hl   ; get rid of saved I 
af41				FORTH_LOOP_POP     ; get rid of limit 
af41 cd 20 9b			call macro_forth_loop_pop 
af44				endm 
# End of macro FORTH_LOOP_POP
af44			 
af44				FORTH_RSP_POP     ; get rid of DO ptr 
af44 cd 83 98			call macro_forth_rsp_pop 
af47				endm 
# End of macro FORTH_RSP_POP
af47			 
af47			if DEBUG_FORTH_WORDS 
af47						DMARK "-L>" 
af47 f5				push af  
af48 3a 5c af			ld a, (.dmark)  
af4b 32 c0 ee			ld (debug_mark),a  
af4e 3a 5d af			ld a, (.dmark+1)  
af51 32 c1 ee			ld (debug_mark+1),a  
af54 3a 5e af			ld a, (.dmark+2)  
af57 32 c2 ee			ld (debug_mark+2),a  
af5a 18 03			jr .pastdmark  
af5c ..			.dmark: db "-L>"  
af5f f1			.pastdmark: pop af  
af60			endm  
# End of macro DMARK
af60				CALLMONITOR 
af60 cd 2e 93			call break_point_state  
af63				endm  
# End of macro CALLMONITOR
af63			endif 
af63			 
af63					NEXTW 
af63 c3 24 9c			jp macro_next 
af66				endm 
# End of macro NEXTW
af66				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
af66			 
af66			.mloopnotdone: 
af66			 
af66 e1				pop hl    ; get I 
af67 2b				dec hl 
af68			 
af68			   	; save new I 
af68			 
af68			 
af68					; set I counter 
af68			 
af68 22 0b e8				ld (os_current_i), hl 
af6b			 
af6b					 
af6b				FORTH_LOOP_NEXT 
af6b cd e3 9a			call macro_forth_loop_next 
af6e				endm 
# End of macro FORTH_LOOP_NEXT
af6e			 
af6e			 
af6e					if DEBUG_FORTH_WORDS 
af6e eb						ex de,hl 
af6f					endif 
af6f			 
af6f			;	; get DO ptr 
af6f			; 
af6f				FORTH_RSP_TOS 
af6f cd 79 98			call macro_forth_rsp_tos 
af72				endm 
# End of macro FORTH_RSP_TOS
af72			 
af72				;push hl 
af72			 
af72				; not going to DO any more 
af72				; get rid of the RSP pointer as DO will add it back in 
af72				;FORTH_RSP_POP 
af72				;pop hl 
af72			 
af72			 
af72 22 e7 e7			ld (os_tok_ptr), hl 
af75					if DEBUG_FORTH_WORDS 
af75						DMARK "-L<" 
af75 f5				push af  
af76 3a 8a af			ld a, (.dmark)  
af79 32 c0 ee			ld (debug_mark),a  
af7c 3a 8b af			ld a, (.dmark+1)  
af7f 32 c1 ee			ld (debug_mark+1),a  
af82 3a 8c af			ld a, (.dmark+2)  
af85 32 c2 ee			ld (debug_mark+2),a  
af88 18 03			jr .pastdmark  
af8a ..			.dmark: db "-L<"  
af8d f1			.pastdmark: pop af  
af8e			endm  
# End of macro DMARK
af8e					CALLMONITOR 
af8e cd 2e 93			call break_point_state  
af91				endm  
# End of macro CALLMONITOR
af91				endif 
af91 c3 b5 9c			jp exec1 
af94			 
af94					 
af94			 
af94			 
af94			 
af94				NEXTW 
af94 c3 24 9c			jp macro_next 
af97				endm 
# End of macro NEXTW
af97			 
af97			 
af97			 
af97			 
af97			.REPEAT: 
af97				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
af97 71				db WORD_SYS_CORE+93             
af98 ea af			dw .UNTIL            
af9a 06				db 5 + 1 
af9b .. 00			db "REPEAT",0              
afa2				endm 
# End of macro CWHEAD
afa2			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
afa2			;  push pc to rsp stack past the REPEAT 
afa2					if DEBUG_FORTH_WORDS_KEY 
afa2						DMARK "REP" 
afa2 f5				push af  
afa3 3a b7 af			ld a, (.dmark)  
afa6 32 c0 ee			ld (debug_mark),a  
afa9 3a b8 af			ld a, (.dmark+1)  
afac 32 c1 ee			ld (debug_mark+1),a  
afaf 3a b9 af			ld a, (.dmark+2)  
afb2 32 c2 ee			ld (debug_mark+2),a  
afb5 18 03			jr .pastdmark  
afb7 ..			.dmark: db "REP"  
afba f1			.pastdmark: pop af  
afbb			endm  
# End of macro DMARK
afbb						CALLMONITOR 
afbb cd 2e 93			call break_point_state  
afbe				endm  
# End of macro CALLMONITOR
afbe					endif 
afbe			 
afbe 2a e7 e7				ld hl, (os_tok_ptr) 
afc1 23					inc hl   ; R 
afc2 23					inc hl  ; E 
afc3 23					inc hl   ; P 
afc4 23					inc hl   ; E 
afc5 23					inc hl   ; A 
afc6 23					inc hl   ; T 
afc7 23					inc hl   ; zero 
afc8					FORTH_RSP_NEXT 
afc8 cd 62 98			call macro_forth_rsp_next 
afcb				endm 
# End of macro FORTH_RSP_NEXT
afcb			 
afcb			 
afcb					if DEBUG_FORTH_WORDS 
afcb						DMARK "REP" 
afcb f5				push af  
afcc 3a e0 af			ld a, (.dmark)  
afcf 32 c0 ee			ld (debug_mark),a  
afd2 3a e1 af			ld a, (.dmark+1)  
afd5 32 c1 ee			ld (debug_mark+1),a  
afd8 3a e2 af			ld a, (.dmark+2)  
afdb 32 c2 ee			ld (debug_mark+2),a  
afde 18 03			jr .pastdmark  
afe0 ..			.dmark: db "REP"  
afe3 f1			.pastdmark: pop af  
afe4			endm  
# End of macro DMARK
afe4						;pop bc    ; TODO BUG ?????? what is this for???? 
afe4						CALLMONITOR 
afe4 cd 2e 93			call break_point_state  
afe7				endm  
# End of macro CALLMONITOR
afe7					endif 
afe7			 
afe7					NEXTW 
afe7 c3 24 9c			jp macro_next 
afea				endm 
# End of macro NEXTW
afea			;	       NEXTW 
afea			 
afea			.UNTIL: 
afea				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
afea 72				db WORD_SYS_CORE+94             
afeb 81 b0			dw .ENDFLOW            
afed 06				db 5 + 1 
afee .. 00			db "UNTIL",0              
aff4				endm 
# End of macro CWHEAD
aff4			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
aff4			 
aff4				; pop tos as check 
aff4			 
aff4				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
aff4			 
aff4				FORTH_DSP_VALUEHL 
aff4 cd b2 9a			call macro_dsp_valuehl 
aff7				endm 
# End of macro FORTH_DSP_VALUEHL
aff7			 
aff7					if DEBUG_FORTH_WORDS_KEY 
aff7						DMARK "UNT" 
aff7 f5				push af  
aff8 3a 0c b0			ld a, (.dmark)  
affb 32 c0 ee			ld (debug_mark),a  
affe 3a 0d b0			ld a, (.dmark+1)  
b001 32 c1 ee			ld (debug_mark+1),a  
b004 3a 0e b0			ld a, (.dmark+2)  
b007 32 c2 ee			ld (debug_mark+2),a  
b00a 18 03			jr .pastdmark  
b00c ..			.dmark: db "UNT"  
b00f f1			.pastdmark: pop af  
b010			endm  
# End of macro DMARK
b010						CALLMONITOR 
b010 cd 2e 93			call break_point_state  
b013				endm  
# End of macro CALLMONITOR
b013					endif 
b013			 
b013			;	push hl 
b013				FORTH_DSP_POP 
b013 cd 6a 9b			call macro_forth_dsp_pop 
b016				endm 
# End of macro FORTH_DSP_POP
b016			 
b016			;	pop hl 
b016			 
b016				; test if true 
b016			 
b016 cd e4 8a			call ishlzero 
b019			;	ld a,l 
b019			;	add h 
b019			; 
b019			;	cp 0 
b019			 
b019 20 3e			jr nz, .untilnotdone 
b01b			 
b01b					if DEBUG_FORTH_WORDS 
b01b						DMARK "UNf" 
b01b f5				push af  
b01c 3a 30 b0			ld a, (.dmark)  
b01f 32 c0 ee			ld (debug_mark),a  
b022 3a 31 b0			ld a, (.dmark+1)  
b025 32 c1 ee			ld (debug_mark+1),a  
b028 3a 32 b0			ld a, (.dmark+2)  
b02b 32 c2 ee			ld (debug_mark+2),a  
b02e 18 03			jr .pastdmark  
b030 ..			.dmark: db "UNf"  
b033 f1			.pastdmark: pop af  
b034			endm  
# End of macro DMARK
b034						CALLMONITOR 
b034 cd 2e 93			call break_point_state  
b037				endm  
# End of macro CALLMONITOR
b037					endif 
b037			 
b037			 
b037			 
b037				FORTH_RSP_POP     ; get rid of DO ptr 
b037 cd 83 98			call macro_forth_rsp_pop 
b03a				endm 
# End of macro FORTH_RSP_POP
b03a			 
b03a			if DEBUG_FORTH_WORDS 
b03a						DMARK "UN>" 
b03a f5				push af  
b03b 3a 4f b0			ld a, (.dmark)  
b03e 32 c0 ee			ld (debug_mark),a  
b041 3a 50 b0			ld a, (.dmark+1)  
b044 32 c1 ee			ld (debug_mark+1),a  
b047 3a 51 b0			ld a, (.dmark+2)  
b04a 32 c2 ee			ld (debug_mark+2),a  
b04d 18 03			jr .pastdmark  
b04f ..			.dmark: db "UN>"  
b052 f1			.pastdmark: pop af  
b053			endm  
# End of macro DMARK
b053				CALLMONITOR 
b053 cd 2e 93			call break_point_state  
b056				endm  
# End of macro CALLMONITOR
b056			endif 
b056			 
b056					NEXTW 
b056 c3 24 9c			jp macro_next 
b059				endm 
# End of macro NEXTW
b059				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b059			 
b059			.untilnotdone: 
b059			 
b059			 
b059			;	; get DO ptr 
b059			; 
b059				FORTH_RSP_TOS 
b059 cd 79 98			call macro_forth_rsp_tos 
b05c				endm 
# End of macro FORTH_RSP_TOS
b05c			 
b05c				;push hl 
b05c			 
b05c				; not going to DO any more 
b05c				; get rid of the RSP pointer as DO will add it back in 
b05c				;FORTH_RSP_POP 
b05c				;pop hl 
b05c			 
b05c			 
b05c 22 e7 e7			ld (os_tok_ptr), hl 
b05f					if DEBUG_FORTH_WORDS 
b05f						DMARK "UN<" 
b05f f5				push af  
b060 3a 74 b0			ld a, (.dmark)  
b063 32 c0 ee			ld (debug_mark),a  
b066 3a 75 b0			ld a, (.dmark+1)  
b069 32 c1 ee			ld (debug_mark+1),a  
b06c 3a 76 b0			ld a, (.dmark+2)  
b06f 32 c2 ee			ld (debug_mark+2),a  
b072 18 03			jr .pastdmark  
b074 ..			.dmark: db "UN<"  
b077 f1			.pastdmark: pop af  
b078			endm  
# End of macro DMARK
b078					CALLMONITOR 
b078 cd 2e 93			call break_point_state  
b07b				endm  
# End of macro CALLMONITOR
b07b				endif 
b07b c3 b5 9c			jp exec1 
b07e			 
b07e					 
b07e			 
b07e			 
b07e					NEXTW 
b07e c3 24 9c			jp macro_next 
b081				endm 
# End of macro NEXTW
b081			 
b081			 
b081			.ENDFLOW: 
b081			 
b081			; eof 
b081			 
# End of file forth_words_flow.asm
b081			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b081			include "forth_words_logic.asm" 
b081			 
b081			; | ## Logic Words 
b081			 
b081			.NOT: 
b081				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b081 2d				db WORD_SYS_CORE+25             
b082 c9 b0			dw .IS            
b084 04				db 3 + 1 
b085 .. 00			db "NOT",0              
b089				endm 
# End of macro CWHEAD
b089			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b089					if DEBUG_FORTH_WORDS_KEY 
b089						DMARK "NOT" 
b089 f5				push af  
b08a 3a 9e b0			ld a, (.dmark)  
b08d 32 c0 ee			ld (debug_mark),a  
b090 3a 9f b0			ld a, (.dmark+1)  
b093 32 c1 ee			ld (debug_mark+1),a  
b096 3a a0 b0			ld a, (.dmark+2)  
b099 32 c2 ee			ld (debug_mark+2),a  
b09c 18 03			jr .pastdmark  
b09e ..			.dmark: db "NOT"  
b0a1 f1			.pastdmark: pop af  
b0a2			endm  
# End of macro DMARK
b0a2						CALLMONITOR 
b0a2 cd 2e 93			call break_point_state  
b0a5				endm  
# End of macro CALLMONITOR
b0a5					endif 
b0a5					FORTH_DSP 
b0a5 cd 78 9a			call macro_forth_dsp 
b0a8				endm 
# End of macro FORTH_DSP
b0a8 7e					ld a,(hl)	; get type of value on TOS 
b0a9 fe 02				cp DS_TYPE_INUM  
b0ab 28 03				jr z, .noti 
b0ad					NEXTW 
b0ad c3 24 9c			jp macro_next 
b0b0				endm 
# End of macro NEXTW
b0b0			.noti:          FORTH_DSP_VALUEHL 
b0b0 cd b2 9a			call macro_dsp_valuehl 
b0b3				endm 
# End of macro FORTH_DSP_VALUEHL
b0b3			;		push hl 
b0b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b0b3 cd 6a 9b			call macro_forth_dsp_pop 
b0b6				endm 
# End of macro FORTH_DSP_POP
b0b6			;		pop hl 
b0b6 3e 00				ld a,0 
b0b8 bd					cp l 
b0b9 28 04				jr z, .not2t 
b0bb 2e 00				ld l, 0 
b0bd 18 02				jr .notip 
b0bf			 
b0bf 2e ff		.not2t:		ld l, 255 
b0c1			 
b0c1 26 00		.notip:		ld h, 0	 
b0c3			 
b0c3 cd bb 98				call forth_push_numhl 
b0c6					NEXTW 
b0c6 c3 24 9c			jp macro_next 
b0c9				endm 
# End of macro NEXTW
b0c9			 
b0c9			.IS: 
b0c9				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b0c9 2d				db WORD_SYS_CORE+25             
b0ca ef b0			dw .LZERO            
b0cc 03				db 2 + 1 
b0cd .. 00			db "IS",0              
b0d0				endm 
# End of macro CWHEAD
b0d0			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b0d0					if DEBUG_FORTH_WORDS_KEY 
b0d0						DMARK "IS." 
b0d0 f5				push af  
b0d1 3a e5 b0			ld a, (.dmark)  
b0d4 32 c0 ee			ld (debug_mark),a  
b0d7 3a e6 b0			ld a, (.dmark+1)  
b0da 32 c1 ee			ld (debug_mark+1),a  
b0dd 3a e7 b0			ld a, (.dmark+2)  
b0e0 32 c2 ee			ld (debug_mark+2),a  
b0e3 18 03			jr .pastdmark  
b0e5 ..			.dmark: db "IS."  
b0e8 f1			.pastdmark: pop af  
b0e9			endm  
# End of macro DMARK
b0e9						CALLMONITOR 
b0e9 cd 2e 93			call break_point_state  
b0ec				endm  
# End of macro CALLMONITOR
b0ec					endif 
b0ec					NEXTW 
b0ec c3 24 9c			jp macro_next 
b0ef				endm 
# End of macro NEXTW
b0ef			.LZERO: 
b0ef				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b0ef 2d				db WORD_SYS_CORE+25             
b0f0 f9 b0			dw .TZERO            
b0f2 03				db 2 + 1 
b0f3 .. 00			db "0<",0              
b0f6				endm 
# End of macro CWHEAD
b0f6			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b0f6					NEXTW 
b0f6 c3 24 9c			jp macro_next 
b0f9				endm 
# End of macro NEXTW
b0f9			.TZERO: 
b0f9				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b0f9 2e				db WORD_SYS_CORE+26             
b0fa 40 b1			dw .LESS            
b0fc 03				db 2 + 1 
b0fd .. 00			db "0=",0              
b100				endm 
# End of macro CWHEAD
b100			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b100				; TODO add floating point number detection 
b100					;v5 FORTH_DSP_VALUE 
b100					if DEBUG_FORTH_WORDS_KEY 
b100						DMARK "0=." 
b100 f5				push af  
b101 3a 15 b1			ld a, (.dmark)  
b104 32 c0 ee			ld (debug_mark),a  
b107 3a 16 b1			ld a, (.dmark+1)  
b10a 32 c1 ee			ld (debug_mark+1),a  
b10d 3a 17 b1			ld a, (.dmark+2)  
b110 32 c2 ee			ld (debug_mark+2),a  
b113 18 03			jr .pastdmark  
b115 ..			.dmark: db "0=."  
b118 f1			.pastdmark: pop af  
b119			endm  
# End of macro DMARK
b119						CALLMONITOR 
b119 cd 2e 93			call break_point_state  
b11c				endm  
# End of macro CALLMONITOR
b11c					endif 
b11c					FORTH_DSP 
b11c cd 78 9a			call macro_forth_dsp 
b11f				endm 
# End of macro FORTH_DSP
b11f 7e					ld a,(hl)	; get type of value on TOS 
b120 fe 02				cp DS_TYPE_INUM  
b122 28 00				jr z, .tz_inum 
b124			 
b124				if FORTH_ENABLE_FLOATMATH 
b124					jr .tz_done 
b124			 
b124				endif 
b124					 
b124			 
b124			.tz_inum: 
b124					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b124 cd b2 9a			call macro_dsp_valuehl 
b127				endm 
# End of macro FORTH_DSP_VALUEHL
b127			 
b127			;		push hl 
b127			 
b127					; destroy value TOS 
b127			 
b127					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b127 cd 6a 9b			call macro_forth_dsp_pop 
b12a				endm 
# End of macro FORTH_DSP_POP
b12a			 
b12a			;		pop hl 
b12a			 
b12a 3e 00				ld a,0 
b12c			 
b12c bd					cp l 
b12d 20 08				jr nz, .tz_notzero 
b12f			 
b12f bc					cp h 
b130			 
b130 20 05				jr nz, .tz_notzero 
b132			 
b132			 
b132 21 01 00				ld hl, FORTH_TRUE 
b135 18 03				jr .tz_done 
b137			 
b137 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b13a			 
b13a					; push value back onto stack for another op etc 
b13a			 
b13a			.tz_done: 
b13a cd bb 98				call forth_push_numhl 
b13d			 
b13d					NEXTW 
b13d c3 24 9c			jp macro_next 
b140				endm 
# End of macro NEXTW
b140			.LESS: 
b140				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b140 2f				db WORD_SYS_CORE+27             
b141 a9 b1			dw .GT            
b143 02				db 1 + 1 
b144 .. 00			db "<",0              
b146				endm 
# End of macro CWHEAD
b146			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b146				; TODO add floating point number detection 
b146					if DEBUG_FORTH_WORDS_KEY 
b146						DMARK "LES" 
b146 f5				push af  
b147 3a 5b b1			ld a, (.dmark)  
b14a 32 c0 ee			ld (debug_mark),a  
b14d 3a 5c b1			ld a, (.dmark+1)  
b150 32 c1 ee			ld (debug_mark+1),a  
b153 3a 5d b1			ld a, (.dmark+2)  
b156 32 c2 ee			ld (debug_mark+2),a  
b159 18 03			jr .pastdmark  
b15b ..			.dmark: db "LES"  
b15e f1			.pastdmark: pop af  
b15f			endm  
# End of macro DMARK
b15f						CALLMONITOR 
b15f cd 2e 93			call break_point_state  
b162				endm  
# End of macro CALLMONITOR
b162					endif 
b162					FORTH_DSP 
b162 cd 78 9a			call macro_forth_dsp 
b165				endm 
# End of macro FORTH_DSP
b165					;v5 FORTH_DSP_VALUE 
b165 7e					ld a,(hl)	; get type of value on TOS 
b166 fe 02				cp DS_TYPE_INUM  
b168 28 00				jr z, .less_inum 
b16a			 
b16a				if FORTH_ENABLE_FLOATMATH 
b16a					jr .less_done 
b16a			 
b16a				endif 
b16a					 
b16a			 
b16a			.less_inum: 
b16a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b16a cd b2 9a			call macro_dsp_valuehl 
b16d				endm 
# End of macro FORTH_DSP_VALUEHL
b16d			 
b16d e5					push hl  ; u2 
b16e			 
b16e					; destroy value TOS 
b16e			 
b16e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b16e cd 6a 9b			call macro_forth_dsp_pop 
b171				endm 
# End of macro FORTH_DSP_POP
b171			 
b171			 
b171					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b171 cd b2 9a			call macro_dsp_valuehl 
b174				endm 
# End of macro FORTH_DSP_VALUEHL
b174			 
b174 e5					push hl    ; u1 
b175			 
b175					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b175 cd 6a 9b			call macro_forth_dsp_pop 
b178				endm 
# End of macro FORTH_DSP_POP
b178			 
b178			 
b178 b7			 or a      ;clear carry flag 
b179 01 00 00		 ld bc, FORTH_FALSE 
b17c e1			  pop hl    ; u1 
b17d d1			  pop de    ; u2 
b17e ed 52		  sbc hl,de 
b180 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b182			 
b182 01 01 00		 ld bc, FORTH_TRUE 
b185			.lscont:  
b185 c5					push bc 
b186 e1					pop hl 
b187			 
b187					if DEBUG_FORTH_WORDS 
b187						DMARK "LT1" 
b187 f5				push af  
b188 3a 9c b1			ld a, (.dmark)  
b18b 32 c0 ee			ld (debug_mark),a  
b18e 3a 9d b1			ld a, (.dmark+1)  
b191 32 c1 ee			ld (debug_mark+1),a  
b194 3a 9e b1			ld a, (.dmark+2)  
b197 32 c2 ee			ld (debug_mark+2),a  
b19a 18 03			jr .pastdmark  
b19c ..			.dmark: db "LT1"  
b19f f1			.pastdmark: pop af  
b1a0			endm  
# End of macro DMARK
b1a0						CALLMONITOR 
b1a0 cd 2e 93			call break_point_state  
b1a3				endm  
# End of macro CALLMONITOR
b1a3					endif 
b1a3 cd bb 98				call forth_push_numhl 
b1a6			 
b1a6					NEXTW 
b1a6 c3 24 9c			jp macro_next 
b1a9				endm 
# End of macro NEXTW
b1a9			.GT: 
b1a9				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b1a9 30				db WORD_SYS_CORE+28             
b1aa 12 b2			dw .EQUAL            
b1ac 02				db 1 + 1 
b1ad .. 00			db ">",0              
b1af				endm 
# End of macro CWHEAD
b1af			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b1af				; TODO add floating point number detection 
b1af					if DEBUG_FORTH_WORDS_KEY 
b1af						DMARK "GRT" 
b1af f5				push af  
b1b0 3a c4 b1			ld a, (.dmark)  
b1b3 32 c0 ee			ld (debug_mark),a  
b1b6 3a c5 b1			ld a, (.dmark+1)  
b1b9 32 c1 ee			ld (debug_mark+1),a  
b1bc 3a c6 b1			ld a, (.dmark+2)  
b1bf 32 c2 ee			ld (debug_mark+2),a  
b1c2 18 03			jr .pastdmark  
b1c4 ..			.dmark: db "GRT"  
b1c7 f1			.pastdmark: pop af  
b1c8			endm  
# End of macro DMARK
b1c8						CALLMONITOR 
b1c8 cd 2e 93			call break_point_state  
b1cb				endm  
# End of macro CALLMONITOR
b1cb					endif 
b1cb					FORTH_DSP 
b1cb cd 78 9a			call macro_forth_dsp 
b1ce				endm 
# End of macro FORTH_DSP
b1ce					;FORTH_DSP_VALUE 
b1ce 7e					ld a,(hl)	; get type of value on TOS 
b1cf fe 02				cp DS_TYPE_INUM  
b1d1 28 00				jr z, .gt_inum 
b1d3			 
b1d3				if FORTH_ENABLE_FLOATMATH 
b1d3					jr .gt_done 
b1d3			 
b1d3				endif 
b1d3					 
b1d3			 
b1d3			.gt_inum: 
b1d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b1d3 cd b2 9a			call macro_dsp_valuehl 
b1d6				endm 
# End of macro FORTH_DSP_VALUEHL
b1d6			 
b1d6 e5					push hl  ; u2 
b1d7			 
b1d7					; destroy value TOS 
b1d7			 
b1d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1d7 cd 6a 9b			call macro_forth_dsp_pop 
b1da				endm 
# End of macro FORTH_DSP_POP
b1da			 
b1da			 
b1da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b1da cd b2 9a			call macro_dsp_valuehl 
b1dd				endm 
# End of macro FORTH_DSP_VALUEHL
b1dd			 
b1dd e5					push hl    ; u1 
b1de			 
b1de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1de cd 6a 9b			call macro_forth_dsp_pop 
b1e1				endm 
# End of macro FORTH_DSP_POP
b1e1			 
b1e1			 
b1e1 b7			 or a      ;clear carry flag 
b1e2 01 00 00		 ld bc, FORTH_FALSE 
b1e5 e1			  pop hl    ; u1 
b1e6 d1			  pop de    ; u2 
b1e7 ed 52		  sbc hl,de 
b1e9 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b1eb			 
b1eb 01 01 00		 ld bc, FORTH_TRUE 
b1ee			.gtcont:  
b1ee c5					push bc 
b1ef e1					pop hl 
b1f0			 
b1f0					if DEBUG_FORTH_WORDS 
b1f0						DMARK "GT1" 
b1f0 f5				push af  
b1f1 3a 05 b2			ld a, (.dmark)  
b1f4 32 c0 ee			ld (debug_mark),a  
b1f7 3a 06 b2			ld a, (.dmark+1)  
b1fa 32 c1 ee			ld (debug_mark+1),a  
b1fd 3a 07 b2			ld a, (.dmark+2)  
b200 32 c2 ee			ld (debug_mark+2),a  
b203 18 03			jr .pastdmark  
b205 ..			.dmark: db "GT1"  
b208 f1			.pastdmark: pop af  
b209			endm  
# End of macro DMARK
b209						CALLMONITOR 
b209 cd 2e 93			call break_point_state  
b20c				endm  
# End of macro CALLMONITOR
b20c					endif 
b20c cd bb 98				call forth_push_numhl 
b20f			 
b20f					NEXTW 
b20f c3 24 9c			jp macro_next 
b212				endm 
# End of macro NEXTW
b212			.EQUAL: 
b212				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b212 31				db WORD_SYS_CORE+29             
b213 7d b2			dw .ENDLOGIC            
b215 02				db 1 + 1 
b216 .. 00			db "=",0              
b218				endm 
# End of macro CWHEAD
b218			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b218				; TODO add floating point number detection 
b218					if DEBUG_FORTH_WORDS_KEY 
b218						DMARK "EQ." 
b218 f5				push af  
b219 3a 2d b2			ld a, (.dmark)  
b21c 32 c0 ee			ld (debug_mark),a  
b21f 3a 2e b2			ld a, (.dmark+1)  
b222 32 c1 ee			ld (debug_mark+1),a  
b225 3a 2f b2			ld a, (.dmark+2)  
b228 32 c2 ee			ld (debug_mark+2),a  
b22b 18 03			jr .pastdmark  
b22d ..			.dmark: db "EQ."  
b230 f1			.pastdmark: pop af  
b231			endm  
# End of macro DMARK
b231						CALLMONITOR 
b231 cd 2e 93			call break_point_state  
b234				endm  
# End of macro CALLMONITOR
b234					endif 
b234					FORTH_DSP 
b234 cd 78 9a			call macro_forth_dsp 
b237				endm 
# End of macro FORTH_DSP
b237					;v5 FORTH_DSP_VALUE 
b237 7e					ld a,(hl)	; get type of value on TOS 
b238 fe 02				cp DS_TYPE_INUM  
b23a 28 00				jr z, .eq_inum 
b23c			 
b23c				if FORTH_ENABLE_FLOATMATH 
b23c					jr .eq_done 
b23c			 
b23c				endif 
b23c					 
b23c			 
b23c			.eq_inum: 
b23c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b23c cd b2 9a			call macro_dsp_valuehl 
b23f				endm 
# End of macro FORTH_DSP_VALUEHL
b23f			 
b23f e5					push hl 
b240			 
b240					; destroy value TOS 
b240			 
b240					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b240 cd 6a 9b			call macro_forth_dsp_pop 
b243				endm 
# End of macro FORTH_DSP_POP
b243			 
b243			 
b243					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b243 cd b2 9a			call macro_dsp_valuehl 
b246				endm 
# End of macro FORTH_DSP_VALUEHL
b246			 
b246					; one value on hl get other one back 
b246			 
b246 e5					push hl 
b247			 
b247					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b247 cd 6a 9b			call macro_forth_dsp_pop 
b24a				endm 
# End of macro FORTH_DSP_POP
b24a			 
b24a 0e 00				ld c, FORTH_FALSE 
b24c			 
b24c e1					pop hl 
b24d d1					pop de 
b24e			 
b24e 7b					ld a, e 
b24f bd					cp l 
b250			 
b250 20 06				jr nz, .eq_done 
b252			 
b252 7a					ld a, d 
b253 bc					cp h 
b254			 
b254 20 02				jr nz, .eq_done 
b256			 
b256 0e 01				ld c, FORTH_TRUE 
b258					 
b258			 
b258			 
b258			.eq_done: 
b258			 
b258					; TODO push value back onto stack for another op etc 
b258			 
b258 26 00				ld h, 0 
b25a 69					ld l, c 
b25b					if DEBUG_FORTH_WORDS 
b25b						DMARK "EQ1" 
b25b f5				push af  
b25c 3a 70 b2			ld a, (.dmark)  
b25f 32 c0 ee			ld (debug_mark),a  
b262 3a 71 b2			ld a, (.dmark+1)  
b265 32 c1 ee			ld (debug_mark+1),a  
b268 3a 72 b2			ld a, (.dmark+2)  
b26b 32 c2 ee			ld (debug_mark+2),a  
b26e 18 03			jr .pastdmark  
b270 ..			.dmark: db "EQ1"  
b273 f1			.pastdmark: pop af  
b274			endm  
# End of macro DMARK
b274						CALLMONITOR 
b274 cd 2e 93			call break_point_state  
b277				endm  
# End of macro CALLMONITOR
b277					endif 
b277 cd bb 98				call forth_push_numhl 
b27a			 
b27a					NEXTW 
b27a c3 24 9c			jp macro_next 
b27d				endm 
# End of macro NEXTW
b27d			 
b27d			 
b27d			.ENDLOGIC: 
b27d			; eof 
b27d			 
b27d			 
# End of file forth_words_logic.asm
b27d			include "forth_words_maths.asm" 
b27d			 
b27d			; | ## Maths Words 
b27d			 
b27d			.PLUS:	 
b27d				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b27d 15				db WORD_SYS_CORE+1             
b27e bf b2			dw .NEG            
b280 02				db 1 + 1 
b281 .. 00			db "+",0              
b283				endm 
# End of macro CWHEAD
b283			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b283					if DEBUG_FORTH_WORDS_KEY 
b283						DMARK "PLU" 
b283 f5				push af  
b284 3a 98 b2			ld a, (.dmark)  
b287 32 c0 ee			ld (debug_mark),a  
b28a 3a 99 b2			ld a, (.dmark+1)  
b28d 32 c1 ee			ld (debug_mark+1),a  
b290 3a 9a b2			ld a, (.dmark+2)  
b293 32 c2 ee			ld (debug_mark+2),a  
b296 18 03			jr .pastdmark  
b298 ..			.dmark: db "PLU"  
b29b f1			.pastdmark: pop af  
b29c			endm  
# End of macro DMARK
b29c						CALLMONITOR 
b29c cd 2e 93			call break_point_state  
b29f				endm  
# End of macro CALLMONITOR
b29f					endif 
b29f					; add top two values and push back result 
b29f			 
b29f					;for v5 FORTH_DSP_VALUE 
b29f					FORTH_DSP 
b29f cd 78 9a			call macro_forth_dsp 
b2a2				endm 
# End of macro FORTH_DSP
b2a2 7e					ld a,(hl)	; get type of value on TOS 
b2a3 fe 02				cp DS_TYPE_INUM  
b2a5 28 03				jr z, .dot_inum 
b2a7			 
b2a7					NEXTW 
b2a7 c3 24 9c			jp macro_next 
b2aa				endm 
# End of macro NEXTW
b2aa			 
b2aa			; float maths 
b2aa			 
b2aa				if FORTH_ENABLE_FLOATMATH 
b2aa						inc hl      ; now at start of numeric as string 
b2aa			 
b2aa					if DEBUG_FORTH_MATHS 
b2aa						DMARK "ADD" 
b2aa				CALLMONITOR 
b2aa					endif 
b2aa			 
b2aa					;ld ix, hl 
b2aa					call CON 
b2aa			 
b2aa			 
b2aa					push hl 
b2aa					 
b2aa					 
b2aa			 
b2aa						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b2aa			 
b2aa					; get next number 
b2aa			 
b2aa						FORTH_DSP_VALUE 
b2aa			 
b2aa						inc hl      ; now at start of numeric as string 
b2aa			 
b2aa					;ld ix, hl 
b2aa					call CON 
b2aa			 
b2aa					push hl 
b2aa			 
b2aa			 
b2aa						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2aa			 
b2aa						; TODO do add 
b2aa			 
b2aa						call IADD 
b2aa			 
b2aa						; TODO get result back as ascii 
b2aa			 
b2aa						; TODO push result  
b2aa			 
b2aa			 
b2aa			 
b2aa						jr .dot_done 
b2aa				endif 
b2aa			 
b2aa			.dot_inum: 
b2aa			 
b2aa			 
b2aa					if DEBUG_FORTH_DOT 
b2aa						DMARK "+IT" 
b2aa				CALLMONITOR 
b2aa					endif 
b2aa			 
b2aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2aa cd b2 9a			call macro_dsp_valuehl 
b2ad				endm 
# End of macro FORTH_DSP_VALUEHL
b2ad			 
b2ad				; TODO add floating point number detection 
b2ad			 
b2ad e5					push hl 
b2ae			 
b2ae					; destroy value TOS 
b2ae			 
b2ae					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2ae cd 6a 9b			call macro_forth_dsp_pop 
b2b1				endm 
# End of macro FORTH_DSP_POP
b2b1			 
b2b1			 
b2b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2b1 cd b2 9a			call macro_dsp_valuehl 
b2b4				endm 
# End of macro FORTH_DSP_VALUEHL
b2b4			 
b2b4					; one value on hl get other one back 
b2b4			 
b2b4 d1					pop de 
b2b5			 
b2b5					; do the add 
b2b5			 
b2b5 19					add hl,de 
b2b6			 
b2b6					; save it 
b2b6			 
b2b6			;		push hl	 
b2b6			 
b2b6					; 
b2b6			 
b2b6					; destroy value TOS 
b2b6			 
b2b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2b6 cd 6a 9b			call macro_forth_dsp_pop 
b2b9				endm 
# End of macro FORTH_DSP_POP
b2b9			 
b2b9					; TODO push value back onto stack for another op etc 
b2b9			 
b2b9			;		pop hl 
b2b9			 
b2b9			.dot_done: 
b2b9 cd bb 98				call forth_push_numhl 
b2bc			 
b2bc					NEXTW 
b2bc c3 24 9c			jp macro_next 
b2bf				endm 
# End of macro NEXTW
b2bf			.NEG: 
b2bf			 
b2bf				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b2bf 17				db WORD_SYS_CORE+3             
b2c0 02 b3			dw .DIV            
b2c2 02				db 1 + 1 
b2c3 .. 00			db "-",0              
b2c5				endm 
# End of macro CWHEAD
b2c5			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b2c5					if DEBUG_FORTH_WORDS_KEY 
b2c5						DMARK "SUB" 
b2c5 f5				push af  
b2c6 3a da b2			ld a, (.dmark)  
b2c9 32 c0 ee			ld (debug_mark),a  
b2cc 3a db b2			ld a, (.dmark+1)  
b2cf 32 c1 ee			ld (debug_mark+1),a  
b2d2 3a dc b2			ld a, (.dmark+2)  
b2d5 32 c2 ee			ld (debug_mark+2),a  
b2d8 18 03			jr .pastdmark  
b2da ..			.dmark: db "SUB"  
b2dd f1			.pastdmark: pop af  
b2de			endm  
# End of macro DMARK
b2de						CALLMONITOR 
b2de cd 2e 93			call break_point_state  
b2e1				endm  
# End of macro CALLMONITOR
b2e1					endif 
b2e1			 
b2e1			 
b2e1				; TODO add floating point number detection 
b2e1					; v5 FORTH_DSP_VALUE 
b2e1					FORTH_DSP 
b2e1 cd 78 9a			call macro_forth_dsp 
b2e4				endm 
# End of macro FORTH_DSP
b2e4 7e					ld a,(hl)	; get type of value on TOS 
b2e5 fe 02				cp DS_TYPE_INUM  
b2e7 28 03				jr z, .neg_inum 
b2e9			 
b2e9					NEXTW 
b2e9 c3 24 9c			jp macro_next 
b2ec				endm 
# End of macro NEXTW
b2ec			 
b2ec			; float maths 
b2ec			 
b2ec				if FORTH_ENABLE_FLOATMATH 
b2ec					jr .neg_done 
b2ec			 
b2ec				endif 
b2ec					 
b2ec			 
b2ec			.neg_inum: 
b2ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2ec cd b2 9a			call macro_dsp_valuehl 
b2ef				endm 
# End of macro FORTH_DSP_VALUEHL
b2ef			 
b2ef e5					push hl 
b2f0			 
b2f0					; destroy value TOS 
b2f0			 
b2f0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2f0 cd 6a 9b			call macro_forth_dsp_pop 
b2f3				endm 
# End of macro FORTH_DSP_POP
b2f3			 
b2f3			 
b2f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2f3 cd b2 9a			call macro_dsp_valuehl 
b2f6				endm 
# End of macro FORTH_DSP_VALUEHL
b2f6			 
b2f6					; one value on hl get other one back 
b2f6			 
b2f6 d1					pop de 
b2f7			 
b2f7					; do the sub 
b2f7			;		ex de, hl 
b2f7			 
b2f7 ed 52				sbc hl,de 
b2f9			 
b2f9					; save it 
b2f9			 
b2f9			;		push hl	 
b2f9			 
b2f9					; 
b2f9			 
b2f9					; destroy value TOS 
b2f9			 
b2f9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2f9 cd 6a 9b			call macro_forth_dsp_pop 
b2fc				endm 
# End of macro FORTH_DSP_POP
b2fc			 
b2fc					; TODO push value back onto stack for another op etc 
b2fc			 
b2fc			;		pop hl 
b2fc			 
b2fc cd bb 98				call forth_push_numhl 
b2ff			.neg_done: 
b2ff			 
b2ff					NEXTW 
b2ff c3 24 9c			jp macro_next 
b302				endm 
# End of macro NEXTW
b302			.DIV: 
b302				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b302 18				db WORD_SYS_CORE+4             
b303 4f b3			dw .MUL            
b305 02				db 1 + 1 
b306 .. 00			db "/",0              
b308				endm 
# End of macro CWHEAD
b308			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b308					if DEBUG_FORTH_WORDS_KEY 
b308						DMARK "DIV" 
b308 f5				push af  
b309 3a 1d b3			ld a, (.dmark)  
b30c 32 c0 ee			ld (debug_mark),a  
b30f 3a 1e b3			ld a, (.dmark+1)  
b312 32 c1 ee			ld (debug_mark+1),a  
b315 3a 1f b3			ld a, (.dmark+2)  
b318 32 c2 ee			ld (debug_mark+2),a  
b31b 18 03			jr .pastdmark  
b31d ..			.dmark: db "DIV"  
b320 f1			.pastdmark: pop af  
b321			endm  
# End of macro DMARK
b321						CALLMONITOR 
b321 cd 2e 93			call break_point_state  
b324				endm  
# End of macro CALLMONITOR
b324					endif 
b324				; TODO add floating point number detection 
b324					; v5 FORTH_DSP_VALUE 
b324					FORTH_DSP 
b324 cd 78 9a			call macro_forth_dsp 
b327				endm 
# End of macro FORTH_DSP
b327 7e					ld a,(hl)	; get type of value on TOS 
b328 fe 02				cp DS_TYPE_INUM  
b32a 28 03				jr z, .div_inum 
b32c			 
b32c				if FORTH_ENABLE_FLOATMATH 
b32c					jr .div_done 
b32c			 
b32c				endif 
b32c					NEXTW 
b32c c3 24 9c			jp macro_next 
b32f				endm 
# End of macro NEXTW
b32f			.div_inum: 
b32f			 
b32f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b32f cd b2 9a			call macro_dsp_valuehl 
b332				endm 
# End of macro FORTH_DSP_VALUEHL
b332			 
b332 e5					push hl    ; to go to bc 
b333			 
b333					; destroy value TOS 
b333			 
b333					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b333 cd 6a 9b			call macro_forth_dsp_pop 
b336				endm 
# End of macro FORTH_DSP_POP
b336			 
b336			 
b336					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b336 cd b2 9a			call macro_dsp_valuehl 
b339				endm 
# End of macro FORTH_DSP_VALUEHL
b339			 
b339					; hl to go to de 
b339			 
b339 e5					push hl 
b33a			 
b33a c1					pop bc 
b33b d1					pop de		 
b33c			 
b33c			 
b33c					if DEBUG_FORTH_MATHS 
b33c						DMARK "DIV" 
b33c				CALLMONITOR 
b33c					endif 
b33c					; one value on hl but move to a get other one back 
b33c			 
b33c			        
b33c cd 18 8a			call Div16 
b33f			 
b33f			;	push af	 
b33f e5				push hl 
b340 c5				push bc 
b341			 
b341					if DEBUG_FORTH_MATHS 
b341						DMARK "DI1" 
b341				CALLMONITOR 
b341					endif 
b341			 
b341					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b341 cd 6a 9b			call macro_forth_dsp_pop 
b344				endm 
# End of macro FORTH_DSP_POP
b344			 
b344			 
b344			 
b344 e1					pop hl    ; result 
b345			 
b345 cd bb 98				call forth_push_numhl 
b348			 
b348 e1					pop hl    ; reminder 
b349			;		ld h,0 
b349			;		ld l,d 
b349			 
b349 cd bb 98				call forth_push_numhl 
b34c			.div_done: 
b34c					NEXTW 
b34c c3 24 9c			jp macro_next 
b34f				endm 
# End of macro NEXTW
b34f			.MUL: 
b34f				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b34f 19				db WORD_SYS_CORE+5             
b350 94 b3			dw .MIN            
b352 02				db 1 + 1 
b353 .. 00			db "*",0              
b355				endm 
# End of macro CWHEAD
b355			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b355				; TODO add floating point number detection 
b355					if DEBUG_FORTH_WORDS_KEY 
b355						DMARK "MUL" 
b355 f5				push af  
b356 3a 6a b3			ld a, (.dmark)  
b359 32 c0 ee			ld (debug_mark),a  
b35c 3a 6b b3			ld a, (.dmark+1)  
b35f 32 c1 ee			ld (debug_mark+1),a  
b362 3a 6c b3			ld a, (.dmark+2)  
b365 32 c2 ee			ld (debug_mark+2),a  
b368 18 03			jr .pastdmark  
b36a ..			.dmark: db "MUL"  
b36d f1			.pastdmark: pop af  
b36e			endm  
# End of macro DMARK
b36e						CALLMONITOR 
b36e cd 2e 93			call break_point_state  
b371				endm  
# End of macro CALLMONITOR
b371					endif 
b371					FORTH_DSP 
b371 cd 78 9a			call macro_forth_dsp 
b374				endm 
# End of macro FORTH_DSP
b374					; v5 FORTH_DSP_VALUE 
b374 7e					ld a,(hl)	; get type of value on TOS 
b375 fe 02				cp DS_TYPE_INUM  
b377 28 03				jr z, .mul_inum 
b379			 
b379				if FORTH_ENABLE_FLOATMATH 
b379					jr .mul_done 
b379			 
b379				endif 
b379			 
b379					NEXTW 
b379 c3 24 9c			jp macro_next 
b37c				endm 
# End of macro NEXTW
b37c			.mul_inum:	 
b37c			 
b37c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b37c cd b2 9a			call macro_dsp_valuehl 
b37f				endm 
# End of macro FORTH_DSP_VALUEHL
b37f			 
b37f e5					push hl 
b380			 
b380					; destroy value TOS 
b380			 
b380					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b380 cd 6a 9b			call macro_forth_dsp_pop 
b383				endm 
# End of macro FORTH_DSP_POP
b383			 
b383			 
b383					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b383 cd b2 9a			call macro_dsp_valuehl 
b386				endm 
# End of macro FORTH_DSP_VALUEHL
b386			 
b386					; one value on hl but move to a get other one back 
b386			 
b386 7d					ld a, l 
b387			 
b387 d1					pop de 
b388			 
b388					; do the mull 
b388			;		ex de, hl 
b388			 
b388 cd 3e 8a				call Mult16 
b38b					; save it 
b38b			 
b38b			;		push hl	 
b38b			 
b38b					; 
b38b			 
b38b					; destroy value TOS 
b38b			 
b38b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b38b cd 6a 9b			call macro_forth_dsp_pop 
b38e				endm 
# End of macro FORTH_DSP_POP
b38e			 
b38e					; TODO push value back onto stack for another op etc 
b38e			 
b38e			;		pop hl 
b38e			 
b38e cd bb 98				call forth_push_numhl 
b391			 
b391			.mul_done: 
b391					NEXTW 
b391 c3 24 9c			jp macro_next 
b394				endm 
# End of macro NEXTW
b394			 
b394			 
b394			 
b394			 
b394			.MIN: 
b394				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b394 49				db WORD_SYS_CORE+53             
b395 15 b4			dw .MAX            
b397 04				db 3 + 1 
b398 .. 00			db "MIN",0              
b39c				endm 
# End of macro CWHEAD
b39c			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b39c					if DEBUG_FORTH_WORDS_KEY 
b39c						DMARK "MIN" 
b39c f5				push af  
b39d 3a b1 b3			ld a, (.dmark)  
b3a0 32 c0 ee			ld (debug_mark),a  
b3a3 3a b2 b3			ld a, (.dmark+1)  
b3a6 32 c1 ee			ld (debug_mark+1),a  
b3a9 3a b3 b3			ld a, (.dmark+2)  
b3ac 32 c2 ee			ld (debug_mark+2),a  
b3af 18 03			jr .pastdmark  
b3b1 ..			.dmark: db "MIN"  
b3b4 f1			.pastdmark: pop af  
b3b5			endm  
# End of macro DMARK
b3b5						CALLMONITOR 
b3b5 cd 2e 93			call break_point_state  
b3b8				endm  
# End of macro CALLMONITOR
b3b8					endif 
b3b8					; get u2 
b3b8			 
b3b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3b8 cd b2 9a			call macro_dsp_valuehl 
b3bb				endm 
# End of macro FORTH_DSP_VALUEHL
b3bb			 
b3bb e5					push hl   ; u2 
b3bc			 
b3bc					; destroy value TOS 
b3bc			 
b3bc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3bc cd 6a 9b			call macro_forth_dsp_pop 
b3bf				endm 
# End of macro FORTH_DSP_POP
b3bf			 
b3bf					; get u1 
b3bf			 
b3bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3bf cd b2 9a			call macro_dsp_valuehl 
b3c2				endm 
# End of macro FORTH_DSP_VALUEHL
b3c2			 
b3c2 e5					push hl  ; u1 
b3c3			 
b3c3					; destroy value TOS 
b3c3			 
b3c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3c3 cd 6a 9b			call macro_forth_dsp_pop 
b3c6				endm 
# End of macro FORTH_DSP_POP
b3c6			 
b3c6 b7			 or a      ;clear carry flag 
b3c7 e1			  pop hl    ; u1 
b3c8 d1			  pop de    ; u2 
b3c9 e5				push hl   ; saved in case hl is lowest 
b3ca ed 52		  sbc hl,de 
b3cc 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b3ce			 
b3ce e1				pop hl 
b3cf					if DEBUG_FORTH_WORDS 
b3cf						DMARK "MIN" 
b3cf f5				push af  
b3d0 3a e4 b3			ld a, (.dmark)  
b3d3 32 c0 ee			ld (debug_mark),a  
b3d6 3a e5 b3			ld a, (.dmark+1)  
b3d9 32 c1 ee			ld (debug_mark+1),a  
b3dc 3a e6 b3			ld a, (.dmark+2)  
b3df 32 c2 ee			ld (debug_mark+2),a  
b3e2 18 03			jr .pastdmark  
b3e4 ..			.dmark: db "MIN"  
b3e7 f1			.pastdmark: pop af  
b3e8			endm  
# End of macro DMARK
b3e8						CALLMONITOR 
b3e8 cd 2e 93			call break_point_state  
b3eb				endm  
# End of macro CALLMONITOR
b3eb					endif 
b3eb cd bb 98				call forth_push_numhl 
b3ee			 
b3ee				       NEXTW 
b3ee c3 24 9c			jp macro_next 
b3f1				endm 
# End of macro NEXTW
b3f1			 
b3f1			.mincont:  
b3f1 c1				pop bc   ; tidy up 
b3f2 eb				ex de , hl  
b3f3					if DEBUG_FORTH_WORDS 
b3f3						DMARK "MI1" 
b3f3 f5				push af  
b3f4 3a 08 b4			ld a, (.dmark)  
b3f7 32 c0 ee			ld (debug_mark),a  
b3fa 3a 09 b4			ld a, (.dmark+1)  
b3fd 32 c1 ee			ld (debug_mark+1),a  
b400 3a 0a b4			ld a, (.dmark+2)  
b403 32 c2 ee			ld (debug_mark+2),a  
b406 18 03			jr .pastdmark  
b408 ..			.dmark: db "MI1"  
b40b f1			.pastdmark: pop af  
b40c			endm  
# End of macro DMARK
b40c						CALLMONITOR 
b40c cd 2e 93			call break_point_state  
b40f				endm  
# End of macro CALLMONITOR
b40f					endif 
b40f cd bb 98				call forth_push_numhl 
b412			 
b412				       NEXTW 
b412 c3 24 9c			jp macro_next 
b415				endm 
# End of macro NEXTW
b415			.MAX: 
b415				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b415 4a				db WORD_SYS_CORE+54             
b416 96 b4			dw .RND16            
b418 04				db 3 + 1 
b419 .. 00			db "MAX",0              
b41d				endm 
# End of macro CWHEAD
b41d			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b41d					if DEBUG_FORTH_WORDS_KEY 
b41d						DMARK "MAX" 
b41d f5				push af  
b41e 3a 32 b4			ld a, (.dmark)  
b421 32 c0 ee			ld (debug_mark),a  
b424 3a 33 b4			ld a, (.dmark+1)  
b427 32 c1 ee			ld (debug_mark+1),a  
b42a 3a 34 b4			ld a, (.dmark+2)  
b42d 32 c2 ee			ld (debug_mark+2),a  
b430 18 03			jr .pastdmark  
b432 ..			.dmark: db "MAX"  
b435 f1			.pastdmark: pop af  
b436			endm  
# End of macro DMARK
b436						CALLMONITOR 
b436 cd 2e 93			call break_point_state  
b439				endm  
# End of macro CALLMONITOR
b439					endif 
b439					; get u2 
b439			 
b439					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b439 cd b2 9a			call macro_dsp_valuehl 
b43c				endm 
# End of macro FORTH_DSP_VALUEHL
b43c			 
b43c e5					push hl   ; u2 
b43d			 
b43d					; destroy value TOS 
b43d			 
b43d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b43d cd 6a 9b			call macro_forth_dsp_pop 
b440				endm 
# End of macro FORTH_DSP_POP
b440			 
b440					; get u1 
b440			 
b440					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b440 cd b2 9a			call macro_dsp_valuehl 
b443				endm 
# End of macro FORTH_DSP_VALUEHL
b443			 
b443 e5					push hl  ; u1 
b444			 
b444					; destroy value TOS 
b444			 
b444					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b444 cd 6a 9b			call macro_forth_dsp_pop 
b447				endm 
# End of macro FORTH_DSP_POP
b447			 
b447 b7			 or a      ;clear carry flag 
b448 e1			  pop hl    ; u1 
b449 d1			  pop de    ; u2 
b44a e5				push hl   ; saved in case hl is lowest 
b44b ed 52		  sbc hl,de 
b44d 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b44f			 
b44f e1				pop hl 
b450					if DEBUG_FORTH_WORDS 
b450						DMARK "MAX" 
b450 f5				push af  
b451 3a 65 b4			ld a, (.dmark)  
b454 32 c0 ee			ld (debug_mark),a  
b457 3a 66 b4			ld a, (.dmark+1)  
b45a 32 c1 ee			ld (debug_mark+1),a  
b45d 3a 67 b4			ld a, (.dmark+2)  
b460 32 c2 ee			ld (debug_mark+2),a  
b463 18 03			jr .pastdmark  
b465 ..			.dmark: db "MAX"  
b468 f1			.pastdmark: pop af  
b469			endm  
# End of macro DMARK
b469						CALLMONITOR 
b469 cd 2e 93			call break_point_state  
b46c				endm  
# End of macro CALLMONITOR
b46c					endif 
b46c cd bb 98				call forth_push_numhl 
b46f			 
b46f				       NEXTW 
b46f c3 24 9c			jp macro_next 
b472				endm 
# End of macro NEXTW
b472			 
b472			.maxcont:  
b472 c1				pop bc   ; tidy up 
b473 eb				ex de , hl  
b474					if DEBUG_FORTH_WORDS 
b474						DMARK "MA1" 
b474 f5				push af  
b475 3a 89 b4			ld a, (.dmark)  
b478 32 c0 ee			ld (debug_mark),a  
b47b 3a 8a b4			ld a, (.dmark+1)  
b47e 32 c1 ee			ld (debug_mark+1),a  
b481 3a 8b b4			ld a, (.dmark+2)  
b484 32 c2 ee			ld (debug_mark+2),a  
b487 18 03			jr .pastdmark  
b489 ..			.dmark: db "MA1"  
b48c f1			.pastdmark: pop af  
b48d			endm  
# End of macro DMARK
b48d						CALLMONITOR 
b48d cd 2e 93			call break_point_state  
b490				endm  
# End of macro CALLMONITOR
b490					endif 
b490 cd bb 98				call forth_push_numhl 
b493				       NEXTW 
b493 c3 24 9c			jp macro_next 
b496				endm 
# End of macro NEXTW
b496			 
b496			.RND16: 
b496				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b496 4e				db WORD_SYS_CORE+58             
b497 c5 b4			dw .RND8            
b499 06				db 5 + 1 
b49a .. 00			db "RND16",0              
b4a0				endm 
# End of macro CWHEAD
b4a0			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b4a0					if DEBUG_FORTH_WORDS_KEY 
b4a0						DMARK "R16" 
b4a0 f5				push af  
b4a1 3a b5 b4			ld a, (.dmark)  
b4a4 32 c0 ee			ld (debug_mark),a  
b4a7 3a b6 b4			ld a, (.dmark+1)  
b4aa 32 c1 ee			ld (debug_mark+1),a  
b4ad 3a b7 b4			ld a, (.dmark+2)  
b4b0 32 c2 ee			ld (debug_mark+2),a  
b4b3 18 03			jr .pastdmark  
b4b5 ..			.dmark: db "R16"  
b4b8 f1			.pastdmark: pop af  
b4b9			endm  
# End of macro DMARK
b4b9						CALLMONITOR 
b4b9 cd 2e 93			call break_point_state  
b4bc				endm  
# End of macro CALLMONITOR
b4bc					endif 
b4bc cd e2 89				call prng16  
b4bf cd bb 98				call forth_push_numhl 
b4c2				       NEXTW 
b4c2 c3 24 9c			jp macro_next 
b4c5				endm 
# End of macro NEXTW
b4c5			.RND8: 
b4c5				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b4c5 60				db WORD_SYS_CORE+76             
b4c6 fa b4			dw .RND            
b4c8 05				db 4 + 1 
b4c9 .. 00			db "RND8",0              
b4ce				endm 
# End of macro CWHEAD
b4ce			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b4ce					if DEBUG_FORTH_WORDS_KEY 
b4ce						DMARK "RN8" 
b4ce f5				push af  
b4cf 3a e3 b4			ld a, (.dmark)  
b4d2 32 c0 ee			ld (debug_mark),a  
b4d5 3a e4 b4			ld a, (.dmark+1)  
b4d8 32 c1 ee			ld (debug_mark+1),a  
b4db 3a e5 b4			ld a, (.dmark+2)  
b4de 32 c2 ee			ld (debug_mark+2),a  
b4e1 18 03			jr .pastdmark  
b4e3 ..			.dmark: db "RN8"  
b4e6 f1			.pastdmark: pop af  
b4e7			endm  
# End of macro DMARK
b4e7						CALLMONITOR 
b4e7 cd 2e 93			call break_point_state  
b4ea				endm  
# End of macro CALLMONITOR
b4ea					endif 
b4ea 2a 41 ed				ld hl,(xrandc) 
b4ed 23					inc hl 
b4ee cd fc 89				call xrnd 
b4f1 6f					ld l,a	 
b4f2 26 00				ld h,0 
b4f4 cd bb 98				call forth_push_numhl 
b4f7				       NEXTW 
b4f7 c3 24 9c			jp macro_next 
b4fa				endm 
# End of macro NEXTW
b4fa			.RND: 
b4fa				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b4fa 60				db WORD_SYS_CORE+76             
b4fb 00 b6			dw .ENDMATHS            
b4fd 04				db 3 + 1 
b4fe .. 00			db "RND",0              
b502				endm 
# End of macro CWHEAD
b502			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b502			 
b502					if DEBUG_FORTH_WORDS_KEY 
b502						DMARK "RND" 
b502 f5				push af  
b503 3a 17 b5			ld a, (.dmark)  
b506 32 c0 ee			ld (debug_mark),a  
b509 3a 18 b5			ld a, (.dmark+1)  
b50c 32 c1 ee			ld (debug_mark+1),a  
b50f 3a 19 b5			ld a, (.dmark+2)  
b512 32 c2 ee			ld (debug_mark+2),a  
b515 18 03			jr .pastdmark  
b517 ..			.dmark: db "RND"  
b51a f1			.pastdmark: pop af  
b51b			endm  
# End of macro DMARK
b51b						CALLMONITOR 
b51b cd 2e 93			call break_point_state  
b51e				endm  
# End of macro CALLMONITOR
b51e					endif 
b51e					 
b51e					FORTH_DSP_VALUEHL    ; upper range 
b51e cd b2 9a			call macro_dsp_valuehl 
b521				endm 
# End of macro FORTH_DSP_VALUEHL
b521			 
b521 22 45 ed				ld (LFSRSeed), hl	 
b524			 
b524					if DEBUG_FORTH_WORDS 
b524						DMARK "RN1" 
b524 f5				push af  
b525 3a 39 b5			ld a, (.dmark)  
b528 32 c0 ee			ld (debug_mark),a  
b52b 3a 3a b5			ld a, (.dmark+1)  
b52e 32 c1 ee			ld (debug_mark+1),a  
b531 3a 3b b5			ld a, (.dmark+2)  
b534 32 c2 ee			ld (debug_mark+2),a  
b537 18 03			jr .pastdmark  
b539 ..			.dmark: db "RN1"  
b53c f1			.pastdmark: pop af  
b53d			endm  
# End of macro DMARK
b53d						CALLMONITOR 
b53d cd 2e 93			call break_point_state  
b540				endm  
# End of macro CALLMONITOR
b540					endif 
b540					FORTH_DSP_POP 
b540 cd 6a 9b			call macro_forth_dsp_pop 
b543				endm 
# End of macro FORTH_DSP_POP
b543			 
b543					FORTH_DSP_VALUEHL    ; low range 
b543 cd b2 9a			call macro_dsp_valuehl 
b546				endm 
# End of macro FORTH_DSP_VALUEHL
b546			 
b546					if DEBUG_FORTH_WORDS 
b546						DMARK "RN2" 
b546 f5				push af  
b547 3a 5b b5			ld a, (.dmark)  
b54a 32 c0 ee			ld (debug_mark),a  
b54d 3a 5c b5			ld a, (.dmark+1)  
b550 32 c1 ee			ld (debug_mark+1),a  
b553 3a 5d b5			ld a, (.dmark+2)  
b556 32 c2 ee			ld (debug_mark+2),a  
b559 18 03			jr .pastdmark  
b55b ..			.dmark: db "RN2"  
b55e f1			.pastdmark: pop af  
b55f			endm  
# End of macro DMARK
b55f						CALLMONITOR 
b55f cd 2e 93			call break_point_state  
b562				endm  
# End of macro CALLMONITOR
b562					endif 
b562 22 47 ed				ld (LFSRSeed+2), hl 
b565			 
b565					FORTH_DSP_POP 
b565 cd 6a 9b			call macro_forth_dsp_pop 
b568				endm 
# End of macro FORTH_DSP_POP
b568			 
b568 e5					push hl 
b569			 
b569 e1			.inrange:	pop hl 
b56a cd e2 89				call prng16  
b56d					if DEBUG_FORTH_WORDS 
b56d						DMARK "RN3" 
b56d f5				push af  
b56e 3a 82 b5			ld a, (.dmark)  
b571 32 c0 ee			ld (debug_mark),a  
b574 3a 83 b5			ld a, (.dmark+1)  
b577 32 c1 ee			ld (debug_mark+1),a  
b57a 3a 84 b5			ld a, (.dmark+2)  
b57d 32 c2 ee			ld (debug_mark+2),a  
b580 18 03			jr .pastdmark  
b582 ..			.dmark: db "RN3"  
b585 f1			.pastdmark: pop af  
b586			endm  
# End of macro DMARK
b586						CALLMONITOR 
b586 cd 2e 93			call break_point_state  
b589				endm  
# End of macro CALLMONITOR
b589					endif 
b589					 
b589					; if the range is 8bit knock out the high byte 
b589			 
b589 ed 5b 45 ed			ld de, (LFSRSeed)     ; check high level 
b58d			 
b58d 3e 00				ld a, 0 
b58f ba					cp d  
b590 20 1e				jr nz, .hirange 
b592 26 00				ld h, 0   ; knock it down to 8bit 
b594			 
b594					if DEBUG_FORTH_WORDS 
b594						DMARK "RNk" 
b594 f5				push af  
b595 3a a9 b5			ld a, (.dmark)  
b598 32 c0 ee			ld (debug_mark),a  
b59b 3a aa b5			ld a, (.dmark+1)  
b59e 32 c1 ee			ld (debug_mark+1),a  
b5a1 3a ab b5			ld a, (.dmark+2)  
b5a4 32 c2 ee			ld (debug_mark+2),a  
b5a7 18 03			jr .pastdmark  
b5a9 ..			.dmark: db "RNk"  
b5ac f1			.pastdmark: pop af  
b5ad			endm  
# End of macro DMARK
b5ad						CALLMONITOR 
b5ad cd 2e 93			call break_point_state  
b5b0				endm  
# End of macro CALLMONITOR
b5b0					endif 
b5b0			.hirange:   
b5b0 e5					push hl  
b5b1 b7					or a  
b5b2 ed 52		                sbc hl, de 
b5b4			 
b5b4					;call cmp16 
b5b4			 
b5b4 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b5b6 e1					pop hl 
b5b7 e5					push hl 
b5b8			 
b5b8					if DEBUG_FORTH_WORDS 
b5b8						DMARK "RN4" 
b5b8 f5				push af  
b5b9 3a cd b5			ld a, (.dmark)  
b5bc 32 c0 ee			ld (debug_mark),a  
b5bf 3a ce b5			ld a, (.dmark+1)  
b5c2 32 c1 ee			ld (debug_mark+1),a  
b5c5 3a cf b5			ld a, (.dmark+2)  
b5c8 32 c2 ee			ld (debug_mark+2),a  
b5cb 18 03			jr .pastdmark  
b5cd ..			.dmark: db "RN4"  
b5d0 f1			.pastdmark: pop af  
b5d1			endm  
# End of macro DMARK
b5d1						CALLMONITOR 
b5d1 cd 2e 93			call break_point_state  
b5d4				endm  
# End of macro CALLMONITOR
b5d4					endif 
b5d4 ed 5b 47 ed			ld de, (LFSRSeed+2)   ; check low range 
b5d8					;call cmp16 
b5d8				 
b5d8 b7					or a  
b5d9 ed 52		                sbc hl, de 
b5db 38 8c				jr c, .inrange 
b5dd			 
b5dd e1					pop hl 
b5de					 
b5de					if DEBUG_FORTH_WORDS 
b5de						DMARK "RNd" 
b5de f5				push af  
b5df 3a f3 b5			ld a, (.dmark)  
b5e2 32 c0 ee			ld (debug_mark),a  
b5e5 3a f4 b5			ld a, (.dmark+1)  
b5e8 32 c1 ee			ld (debug_mark+1),a  
b5eb 3a f5 b5			ld a, (.dmark+2)  
b5ee 32 c2 ee			ld (debug_mark+2),a  
b5f1 18 03			jr .pastdmark  
b5f3 ..			.dmark: db "RNd"  
b5f6 f1			.pastdmark: pop af  
b5f7			endm  
# End of macro DMARK
b5f7						CALLMONITOR 
b5f7 cd 2e 93			call break_point_state  
b5fa				endm  
# End of macro CALLMONITOR
b5fa					endif 
b5fa			 
b5fa			 
b5fa cd bb 98				call forth_push_numhl 
b5fd				       NEXTW 
b5fd c3 24 9c			jp macro_next 
b600				endm 
# End of macro NEXTW
b600			 
b600			.ENDMATHS: 
b600			 
b600			; eof 
b600			 
# End of file forth_words_maths.asm
b600			include "forth_words_display.asm" 
b600			 
b600			; | ## Display Words 
b600			 
b600			.ATP: 
b600				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b600 62				db WORD_SYS_CORE+78             
b601 77 b6			dw .FB            
b603 04				db 3 + 1 
b604 .. 00			db "AT?",0              
b608				endm 
# End of macro CWHEAD
b608			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b608					if DEBUG_FORTH_WORDS_KEY 
b608						DMARK "AT?" 
b608 f5				push af  
b609 3a 1d b6			ld a, (.dmark)  
b60c 32 c0 ee			ld (debug_mark),a  
b60f 3a 1e b6			ld a, (.dmark+1)  
b612 32 c1 ee			ld (debug_mark+1),a  
b615 3a 1f b6			ld a, (.dmark+2)  
b618 32 c2 ee			ld (debug_mark+2),a  
b61b 18 03			jr .pastdmark  
b61d ..			.dmark: db "AT?"  
b620 f1			.pastdmark: pop af  
b621			endm  
# End of macro DMARK
b621						CALLMONITOR 
b621 cd 2e 93			call break_point_state  
b624				endm  
# End of macro CALLMONITOR
b624					endif 
b624 3a cf ec				ld a, (f_cursor_ptr) 
b627			 
b627			if DEBUG_FORTH_WORDS 
b627				DMARK "AT?" 
b627 f5				push af  
b628 3a 3c b6			ld a, (.dmark)  
b62b 32 c0 ee			ld (debug_mark),a  
b62e 3a 3d b6			ld a, (.dmark+1)  
b631 32 c1 ee			ld (debug_mark+1),a  
b634 3a 3e b6			ld a, (.dmark+2)  
b637 32 c2 ee			ld (debug_mark+2),a  
b63a 18 03			jr .pastdmark  
b63c ..			.dmark: db "AT?"  
b63f f1			.pastdmark: pop af  
b640			endm  
# End of macro DMARK
b640				CALLMONITOR 
b640 cd 2e 93			call break_point_state  
b643				endm  
# End of macro CALLMONITOR
b643			endif	 
b643					; count the number of rows 
b643			 
b643 06 00				ld b, 0 
b645 4f			.atpr:		ld c, a    ; save in case we go below zero 
b646 d6 14				sub display_cols 
b648 f2 4e b6				jp p, .atprunder 
b64b 04					inc b 
b64c 18 f7				jr .atpr 
b64e			.atprunder:	 
b64e			if DEBUG_FORTH_WORDS 
b64e				DMARK "A?2" 
b64e f5				push af  
b64f 3a 63 b6			ld a, (.dmark)  
b652 32 c0 ee			ld (debug_mark),a  
b655 3a 64 b6			ld a, (.dmark+1)  
b658 32 c1 ee			ld (debug_mark+1),a  
b65b 3a 65 b6			ld a, (.dmark+2)  
b65e 32 c2 ee			ld (debug_mark+2),a  
b661 18 03			jr .pastdmark  
b663 ..			.dmark: db "A?2"  
b666 f1			.pastdmark: pop af  
b667			endm  
# End of macro DMARK
b667				CALLMONITOR 
b667 cd 2e 93			call break_point_state  
b66a				endm  
# End of macro CALLMONITOR
b66a			endif	 
b66a 26 00				ld h, 0 
b66c 69					ld l, c 
b66d cd bb 98				call forth_push_numhl 
b670 68					ld l, b  
b671 cd bb 98				call forth_push_numhl 
b674			 
b674			 
b674				NEXTW 
b674 c3 24 9c			jp macro_next 
b677				endm 
# End of macro NEXTW
b677			 
b677			.FB: 
b677				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b677 1b				db WORD_SYS_CORE+7             
b678 c5 b6			dw .EMIT            
b67a 03				db 2 + 1 
b67b .. 00			db "FB",0              
b67e				endm 
# End of macro CWHEAD
b67e			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b67e			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b67e			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b67e			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b67e					if DEBUG_FORTH_WORDS_KEY 
b67e						DMARK "FB." 
b67e f5				push af  
b67f 3a 93 b6			ld a, (.dmark)  
b682 32 c0 ee			ld (debug_mark),a  
b685 3a 94 b6			ld a, (.dmark+1)  
b688 32 c1 ee			ld (debug_mark+1),a  
b68b 3a 95 b6			ld a, (.dmark+2)  
b68e 32 c2 ee			ld (debug_mark+2),a  
b691 18 03			jr .pastdmark  
b693 ..			.dmark: db "FB."  
b696 f1			.pastdmark: pop af  
b697			endm  
# End of macro DMARK
b697						CALLMONITOR 
b697 cd 2e 93			call break_point_state  
b69a				endm  
# End of macro CALLMONITOR
b69a					endif 
b69a			 
b69a					FORTH_DSP_VALUEHL 
b69a cd b2 9a			call macro_dsp_valuehl 
b69d				endm 
# End of macro FORTH_DSP_VALUEHL
b69d			 
b69d 7d					ld a, l 
b69e fe 01				cp 1 
b6a0 20 05				jr nz, .fbn1 
b6a2 21 05 ee				ld hl, display_fb1 
b6a5 18 15				jr .fbset 
b6a7 fe 02		.fbn1:		cp 2 
b6a9 20 05				jr nz, .fbn2 
b6ab 21 63 ed				ld hl, display_fb2 
b6ae 18 0c				jr .fbset 
b6b0 fe 03		.fbn2:		cp 3 
b6b2 20 05				jr nz, .fbn3 
b6b4 21 b4 ed				ld hl, display_fb3 
b6b7 18 03				jr .fbset 
b6b9			.fbn3:		 ; if invalid number select first 
b6b9 21 05 ee				ld hl, display_fb1 
b6bc 22 61 ed		.fbset:		ld (display_fb_active), hl 
b6bf			 
b6bf					FORTH_DSP_POP 
b6bf cd 6a 9b			call macro_forth_dsp_pop 
b6c2				endm 
# End of macro FORTH_DSP_POP
b6c2			 
b6c2					NEXTW 
b6c2 c3 24 9c			jp macro_next 
b6c5				endm 
# End of macro NEXTW
b6c5			 
b6c5			 
b6c5			.EMIT: 
b6c5				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b6c5 1b				db WORD_SYS_CORE+7             
b6c6 16 b7			dw .DOTH            
b6c8 05				db 4 + 1 
b6c9 .. 00			db "EMIT",0              
b6ce				endm 
# End of macro CWHEAD
b6ce			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b6ce					; get value off TOS and display it 
b6ce			 
b6ce					if DEBUG_FORTH_WORDS_KEY 
b6ce						DMARK "EMT" 
b6ce f5				push af  
b6cf 3a e3 b6			ld a, (.dmark)  
b6d2 32 c0 ee			ld (debug_mark),a  
b6d5 3a e4 b6			ld a, (.dmark+1)  
b6d8 32 c1 ee			ld (debug_mark+1),a  
b6db 3a e5 b6			ld a, (.dmark+2)  
b6de 32 c2 ee			ld (debug_mark+2),a  
b6e1 18 03			jr .pastdmark  
b6e3 ..			.dmark: db "EMT"  
b6e6 f1			.pastdmark: pop af  
b6e7			endm  
# End of macro DMARK
b6e7						CALLMONITOR 
b6e7 cd 2e 93			call break_point_state  
b6ea				endm  
# End of macro CALLMONITOR
b6ea					endif 
b6ea			 
b6ea					FORTH_DSP_VALUEHL 
b6ea cd b2 9a			call macro_dsp_valuehl 
b6ed				endm 
# End of macro FORTH_DSP_VALUEHL
b6ed			 
b6ed 7d					ld a,l 
b6ee			 
b6ee					; TODO write to display 
b6ee			 
b6ee 32 e4 e6				ld (os_input), a 
b6f1 3e 00				ld a, 0 
b6f3 32 e5 e6				ld (os_input+1), a 
b6f6					 
b6f6 3a cf ec				ld a, (f_cursor_ptr) 
b6f9 11 e4 e6				ld de, os_input 
b6fc cd a1 88				call str_at_display 
b6ff			 
b6ff			 
b6ff 3a ad ec				ld a,(cli_autodisplay) 
b702 fe 00				cp 0 
b704 28 03				jr z, .enoupdate 
b706 cd b1 88						call update_display 
b709					.enoupdate: 
b709			 
b709 3a cf ec				ld a, (f_cursor_ptr) 
b70c 3c					inc a 
b70d 32 cf ec				ld (f_cursor_ptr), a   ; save new pos 
b710			 
b710			 
b710					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b710 cd 6a 9b			call macro_forth_dsp_pop 
b713				endm 
# End of macro FORTH_DSP_POP
b713			  
b713			 
b713					NEXTW 
b713 c3 24 9c			jp macro_next 
b716				endm 
# End of macro NEXTW
b716			.DOTH: 
b716				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b716 1c				db WORD_SYS_CORE+8             
b717 46 b7			dw .DOTF            
b719 03				db 2 + 1 
b71a .. 00			db ".-",0              
b71d				endm 
# End of macro CWHEAD
b71d			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b71d					; get value off TOS and display it 
b71d					if DEBUG_FORTH_WORDS_KEY 
b71d						DMARK "DTD" 
b71d f5				push af  
b71e 3a 32 b7			ld a, (.dmark)  
b721 32 c0 ee			ld (debug_mark),a  
b724 3a 33 b7			ld a, (.dmark+1)  
b727 32 c1 ee			ld (debug_mark+1),a  
b72a 3a 34 b7			ld a, (.dmark+2)  
b72d 32 c2 ee			ld (debug_mark+2),a  
b730 18 03			jr .pastdmark  
b732 ..			.dmark: db "DTD"  
b735 f1			.pastdmark: pop af  
b736			endm  
# End of macro DMARK
b736						CALLMONITOR 
b736 cd 2e 93			call break_point_state  
b739				endm  
# End of macro CALLMONITOR
b739					endif 
b739 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
b73b 3e 00			ld a, 0 
b73d 32 ae ec			ld (cli_mvdot), a 
b740 c3 9d b7			jp .dotgo 
b743				NEXTW 
b743 c3 24 9c			jp macro_next 
b746				endm 
# End of macro NEXTW
b746			.DOTF: 
b746				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
b746 1c				db WORD_SYS_CORE+8             
b747 74 b7			dw .DOT            
b749 03				db 2 + 1 
b74a .. 00			db ".>",0              
b74d				endm 
# End of macro CWHEAD
b74d			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
b74d					; get value off TOS and display it 
b74d			        ; TODO BUG adds extra spaces 
b74d			        ; TODO BUG handle numerics? 
b74d					if DEBUG_FORTH_WORDS_KEY 
b74d						DMARK "DTC" 
b74d f5				push af  
b74e 3a 62 b7			ld a, (.dmark)  
b751 32 c0 ee			ld (debug_mark),a  
b754 3a 63 b7			ld a, (.dmark+1)  
b757 32 c1 ee			ld (debug_mark+1),a  
b75a 3a 64 b7			ld a, (.dmark+2)  
b75d 32 c2 ee			ld (debug_mark+2),a  
b760 18 03			jr .pastdmark  
b762 ..			.dmark: db "DTC"  
b765 f1			.pastdmark: pop af  
b766			endm  
# End of macro DMARK
b766						CALLMONITOR 
b766 cd 2e 93			call break_point_state  
b769				endm  
# End of macro CALLMONITOR
b769					endif 
b769 3e 01			ld a, 1 
b76b 32 ae ec			ld (cli_mvdot), a 
b76e c3 9d b7			jp .dotgo 
b771				NEXTW 
b771 c3 24 9c			jp macro_next 
b774				endm 
# End of macro NEXTW
b774			 
b774			.DOT: 
b774				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
b774 1c				db WORD_SYS_CORE+8             
b775 00 b8			dw .CLS            
b777 02				db 1 + 1 
b778 .. 00			db ".",0              
b77a				endm 
# End of macro CWHEAD
b77a			        ; | . ( u -- ) Display TOS | DONE 
b77a					; get value off TOS and display it 
b77a			 
b77a					if DEBUG_FORTH_WORDS_KEY 
b77a						DMARK "DOT" 
b77a f5				push af  
b77b 3a 8f b7			ld a, (.dmark)  
b77e 32 c0 ee			ld (debug_mark),a  
b781 3a 90 b7			ld a, (.dmark+1)  
b784 32 c1 ee			ld (debug_mark+1),a  
b787 3a 91 b7			ld a, (.dmark+2)  
b78a 32 c2 ee			ld (debug_mark+2),a  
b78d 18 03			jr .pastdmark  
b78f ..			.dmark: db "DOT"  
b792 f1			.pastdmark: pop af  
b793			endm  
# End of macro DMARK
b793						CALLMONITOR 
b793 cd 2e 93			call break_point_state  
b796				endm  
# End of macro CALLMONITOR
b796					endif 
b796 3e 00			ld a, 0 
b798 32 ae ec			ld (cli_mvdot), a 
b79b 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
b79d				 
b79d			 
b79d			.dotgo: 
b79d			 
b79d			; move up type to on stack for parserv5 
b79d					FORTH_DSP 
b79d cd 78 9a			call macro_forth_dsp 
b7a0				endm 
# End of macro FORTH_DSP
b7a0				;FORTH_DSP_VALUE  
b7a0			 
b7a0			if DEBUG_FORTH_DOT 
b7a0				DMARK "DOT" 
b7a0				CALLMONITOR 
b7a0			endif	 
b7a0			;		.print: 
b7a0			 
b7a0 7e				ld a,(hl)  ; work out what type of value is on the TOS 
b7a1 23				inc hl   ; position to the actual value 
b7a2 fe 01			cp DS_TYPE_STR 
b7a4 20 06			jr nz, .dotnum1  
b7a6			 
b7a6			; display string 
b7a6				FORTH_DSP_VALUE  
b7a6 cd 9b 9a			call macro_forth_dsp_value 
b7a9				endm 
# End of macro FORTH_DSP_VALUE
b7a9 eb				ex de,hl 
b7aa 18 11			jr .dotwrite 
b7ac			 
b7ac			.dotnum1: 
b7ac fe 02			cp DS_TYPE_INUM 
b7ae 20 0c			jr nz, .dotflot 
b7b0			 
b7b0			 
b7b0			; display number 
b7b0			 
b7b0			;	push hl 
b7b0			;	call clear_display 
b7b0			;	pop hl 
b7b0			 
b7b0 5e				ld e, (hl) 
b7b1 23				inc hl 
b7b2 56				ld d, (hl) 
b7b3 21 e6 e4			ld hl, scratch 
b7b6			if DEBUG_FORTH_DOT 
b7b6				DMARK "DT1" 
b7b6				CALLMONITOR 
b7b6			endif	 
b7b6			 
b7b6 cd c8 8e			call uitoa_16 
b7b9 eb				ex de,hl 
b7ba			 
b7ba			if DEBUG_FORTH_DOT 
b7ba				DMARK "DT2" 
b7ba				CALLMONITOR 
b7ba			endif	 
b7ba			 
b7ba			;	ld de, os_word_scratch 
b7ba 18 01			jr .dotwrite 
b7bc			 
b7bc 00			.dotflot:   nop 
b7bd			; TODO print floating point number 
b7bd			 
b7bd			.dotwrite:		 
b7bd			 
b7bd					; if c is set then set all '-' to spaces 
b7bd					; need to also take into account .>  
b7bd			 
b7bd 3e 01				ld a, 1 
b7bf b9					cp c 
b7c0 20 13				jr nz, .nodashswap 
b7c2			 
b7c2					; DE has the string to write, working with HL 
b7c2			 
b7c2 06 ff				ld b, 255 
b7c4 d5					push de 
b7c5 e1					pop hl 
b7c6			 
b7c6			if DEBUG_FORTH_DOT 
b7c6				DMARK "DT-" 
b7c6				CALLMONITOR 
b7c6			endif	 
b7c6 7e			.dashscan:	ld a, (hl) 
b7c7 fe 00				cp 0 
b7c9 28 0a				jr z, .nodashswap 
b7cb fe 2d				cp '-' 
b7cd 20 03				jr nz, .dashskip 
b7cf 3e 20				ld a, ' ' 
b7d1 77					ld (hl), a 
b7d2 23			.dashskip:	inc hl 
b7d3			if DEBUG_FORTH_DOT 
b7d3				DMARK "D-2" 
b7d3				CALLMONITOR 
b7d3			endif	 
b7d3 10 f1				djnz .dashscan 
b7d5			 
b7d5			if DEBUG_FORTH_DOT 
b7d5				DMARK "D-1" 
b7d5				CALLMONITOR 
b7d5			endif	 
b7d5			 
b7d5			.nodashswap: 
b7d5			 
b7d5 e5					push hl   ; save string start in case we need to advance print 
b7d6			 
b7d6 3a cf ec				ld a, (f_cursor_ptr) 
b7d9 cd a1 88				call str_at_display 
b7dc 3a ad ec				ld a,(cli_autodisplay) 
b7df fe 00				cp 0 
b7e1 28 03				jr z, .noupdate 
b7e3 cd b1 88						call update_display 
b7e6					.noupdate: 
b7e6			 
b7e6			 
b7e6					; see if we need to advance the print position 
b7e6			 
b7e6 e1					pop hl   ; get back string 
b7e7			 
b7e7 3a ae ec				ld a, (cli_mvdot) 
b7ea			if DEBUG_FORTH_DOT 
b7ea					ld e,a 
b7ea				DMARK "D>1" 
b7ea				CALLMONITOR 
b7ea			endif	 
b7ea fe 00				cp 0 
b7ec 28 0c				jr z, .noadv 
b7ee					; yes, lets advance the print position 
b7ee 3e 00				ld a, 0 
b7f0 cd 24 8f				call strlent 
b7f3 3a cf ec				ld a, (f_cursor_ptr) 
b7f6 85					add a,l 
b7f7					;call addatohl 
b7f7					;ld a, l 
b7f7 32 cf ec				ld (f_cursor_ptr), a   ; save new pos 
b7fa			 
b7fa			if DEBUG_FORTH_DOT 
b7fa				DMARK "D->" 
b7fa				CALLMONITOR 
b7fa			endif	 
b7fa			 
b7fa			.noadv:	 
b7fa			 
b7fa					if DEBUG_FORTH_DOT_WAIT 
b7fa							call next_page_prompt 
b7fa					endif	 
b7fa			; TODO this pop off the stack causes a crash. i dont know why 
b7fa			 
b7fa			 
b7fa			if DEBUG_FORTH_DOT 
b7fa				DMARK "DTh" 
b7fa				CALLMONITOR 
b7fa			endif	 
b7fa			 
b7fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b7fa cd 6a 9b			call macro_forth_dsp_pop 
b7fd				endm 
# End of macro FORTH_DSP_POP
b7fd			 
b7fd			if DEBUG_FORTH_DOT 
b7fd				DMARK "DTi" 
b7fd				CALLMONITOR 
b7fd			endif	 
b7fd			 
b7fd			 
b7fd					NEXTW 
b7fd c3 24 9c			jp macro_next 
b800				endm 
# End of macro NEXTW
b800			 
b800			.CLS: 
b800				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
b800 35				db WORD_SYS_CORE+33             
b801 2d b8			dw .DRAW            
b803 04				db 3 + 1 
b804 .. 00			db "CLS",0              
b808				endm 
# End of macro CWHEAD
b808			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
b808					if DEBUG_FORTH_WORDS_KEY 
b808						DMARK "CLS" 
b808 f5				push af  
b809 3a 1d b8			ld a, (.dmark)  
b80c 32 c0 ee			ld (debug_mark),a  
b80f 3a 1e b8			ld a, (.dmark+1)  
b812 32 c1 ee			ld (debug_mark+1),a  
b815 3a 1f b8			ld a, (.dmark+2)  
b818 32 c2 ee			ld (debug_mark+2),a  
b81b 18 03			jr .pastdmark  
b81d ..			.dmark: db "CLS"  
b820 f1			.pastdmark: pop af  
b821			endm  
# End of macro DMARK
b821						CALLMONITOR 
b821 cd 2e 93			call break_point_state  
b824				endm  
# End of macro CALLMONITOR
b824					endif 
b824 cd 8e 88				call clear_display 
b827 c3 3b b9				jp .home		; and home cursor 
b82a					NEXTW 
b82a c3 24 9c			jp macro_next 
b82d				endm 
# End of macro NEXTW
b82d			 
b82d			.DRAW: 
b82d				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
b82d 36				db WORD_SYS_CORE+34             
b82e 58 b8			dw .DUMP            
b830 05				db 4 + 1 
b831 .. 00			db "DRAW",0              
b836				endm 
# End of macro CWHEAD
b836			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
b836					if DEBUG_FORTH_WORDS_KEY 
b836						DMARK "DRW" 
b836 f5				push af  
b837 3a 4b b8			ld a, (.dmark)  
b83a 32 c0 ee			ld (debug_mark),a  
b83d 3a 4c b8			ld a, (.dmark+1)  
b840 32 c1 ee			ld (debug_mark+1),a  
b843 3a 4d b8			ld a, (.dmark+2)  
b846 32 c2 ee			ld (debug_mark+2),a  
b849 18 03			jr .pastdmark  
b84b ..			.dmark: db "DRW"  
b84e f1			.pastdmark: pop af  
b84f			endm  
# End of macro DMARK
b84f						CALLMONITOR 
b84f cd 2e 93			call break_point_state  
b852				endm  
# End of macro CALLMONITOR
b852					endif 
b852 cd b1 88				call update_display 
b855					NEXTW 
b855 c3 24 9c			jp macro_next 
b858				endm 
# End of macro NEXTW
b858			 
b858			.DUMP: 
b858				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
b858 37				db WORD_SYS_CORE+35             
b859 90 b8			dw .CDUMP            
b85b 05				db 4 + 1 
b85c .. 00			db "DUMP",0              
b861				endm 
# End of macro CWHEAD
b861			; | DUMP ( x -- ) With address x display dump   | DONE 
b861			; TODO pop address to use off of the stack 
b861					if DEBUG_FORTH_WORDS_KEY 
b861						DMARK "DUM" 
b861 f5				push af  
b862 3a 76 b8			ld a, (.dmark)  
b865 32 c0 ee			ld (debug_mark),a  
b868 3a 77 b8			ld a, (.dmark+1)  
b86b 32 c1 ee			ld (debug_mark+1),a  
b86e 3a 78 b8			ld a, (.dmark+2)  
b871 32 c2 ee			ld (debug_mark+2),a  
b874 18 03			jr .pastdmark  
b876 ..			.dmark: db "DUM"  
b879 f1			.pastdmark: pop af  
b87a			endm  
# End of macro DMARK
b87a						CALLMONITOR 
b87a cd 2e 93			call break_point_state  
b87d				endm  
# End of macro CALLMONITOR
b87d					endif 
b87d cd 8e 88				call clear_display 
b880			 
b880					; get address 
b880			 
b880					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b880 cd b2 9a			call macro_dsp_valuehl 
b883				endm 
# End of macro FORTH_DSP_VALUEHL
b883				 
b883					; save it for cdump 
b883			 
b883 22 09 e8				ld (os_cur_ptr),hl 
b886			 
b886					; destroy value TOS 
b886			 
b886					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b886 cd 6a 9b			call macro_forth_dsp_pop 
b889				endm 
# End of macro FORTH_DSP_POP
b889			 
b889 cd 3b 97				call dumpcont	; skip old style of param parsing	 
b88c c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
b88d					NEXTW 
b88d c3 24 9c			jp macro_next 
b890				endm 
# End of macro NEXTW
b890			.CDUMP: 
b890				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
b890 38				db WORD_SYS_CORE+36             
b891 c0 b8			dw .DAT            
b893 06				db 5 + 1 
b894 .. 00			db "CDUMP",0              
b89a				endm 
# End of macro CWHEAD
b89a			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
b89a					if DEBUG_FORTH_WORDS_KEY 
b89a						DMARK "CDP" 
b89a f5				push af  
b89b 3a af b8			ld a, (.dmark)  
b89e 32 c0 ee			ld (debug_mark),a  
b8a1 3a b0 b8			ld a, (.dmark+1)  
b8a4 32 c1 ee			ld (debug_mark+1),a  
b8a7 3a b1 b8			ld a, (.dmark+2)  
b8aa 32 c2 ee			ld (debug_mark+2),a  
b8ad 18 03			jr .pastdmark  
b8af ..			.dmark: db "CDP"  
b8b2 f1			.pastdmark: pop af  
b8b3			endm  
# End of macro DMARK
b8b3						CALLMONITOR 
b8b3 cd 2e 93			call break_point_state  
b8b6				endm  
# End of macro CALLMONITOR
b8b6					endif 
b8b6 cd 8e 88				call clear_display 
b8b9 cd 3b 97				call dumpcont	 
b8bc c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
b8bd					NEXTW 
b8bd c3 24 9c			jp macro_next 
b8c0				endm 
# End of macro NEXTW
b8c0			 
b8c0			 
b8c0			 
b8c0			 
b8c0			.DAT: 
b8c0				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
b8c0 3d				db WORD_SYS_CORE+41             
b8c1 16 b9			dw .HOME            
b8c3 03				db 2 + 1 
b8c4 .. 00			db "AT",0              
b8c7				endm 
# End of macro CWHEAD
b8c7			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
b8c7					if DEBUG_FORTH_WORDS_KEY 
b8c7						DMARK "AT." 
b8c7 f5				push af  
b8c8 3a dc b8			ld a, (.dmark)  
b8cb 32 c0 ee			ld (debug_mark),a  
b8ce 3a dd b8			ld a, (.dmark+1)  
b8d1 32 c1 ee			ld (debug_mark+1),a  
b8d4 3a de b8			ld a, (.dmark+2)  
b8d7 32 c2 ee			ld (debug_mark+2),a  
b8da 18 03			jr .pastdmark  
b8dc ..			.dmark: db "AT."  
b8df f1			.pastdmark: pop af  
b8e0			endm  
# End of macro DMARK
b8e0						CALLMONITOR 
b8e0 cd 2e 93			call break_point_state  
b8e3				endm  
# End of macro CALLMONITOR
b8e3					endif 
b8e3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8e3 cd b2 9a			call macro_dsp_valuehl 
b8e6				endm 
# End of macro FORTH_DSP_VALUEHL
b8e6			 
b8e6			 
b8e6					; TODO save cursor row 
b8e6 7d					ld a,l 
b8e7 fe 02				cp 2 
b8e9 20 04				jr nz, .crow3 
b8eb 3e 14				ld a, display_row_2 
b8ed 18 12				jr .ccol1 
b8ef fe 03		.crow3:		cp 3 
b8f1 20 04				jr nz, .crow4 
b8f3 3e 28				ld a, display_row_3 
b8f5 18 0a				jr .ccol1 
b8f7 fe 04		.crow4:		cp 4 
b8f9 20 04				jr nz, .crow1 
b8fb 3e 3c				ld a, display_row_4 
b8fd 18 02				jr .ccol1 
b8ff 3e 00		.crow1:		ld a,display_row_1 
b901 f5			.ccol1:		push af			; got row offset 
b902 6f					ld l,a 
b903 26 00				ld h,0 
b905					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b905 cd 6a 9b			call macro_forth_dsp_pop 
b908				endm 
# End of macro FORTH_DSP_POP
b908					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b908 cd b2 9a			call macro_dsp_valuehl 
b90b				endm 
# End of macro FORTH_DSP_VALUEHL
b90b					; TODO save cursor col 
b90b f1					pop af 
b90c 85					add l		; add col offset 
b90d 32 cf ec				ld (f_cursor_ptr), a 
b910					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b910 cd 6a 9b			call macro_forth_dsp_pop 
b913				endm 
# End of macro FORTH_DSP_POP
b913			 
b913					; calculate  
b913			 
b913					NEXTW 
b913 c3 24 9c			jp macro_next 
b916				endm 
# End of macro NEXTW
b916			 
b916			 
b916			.HOME: 
b916				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
b916 41				db WORD_SYS_CORE+45             
b917 43 b9			dw .SPACE            
b919 05				db 4 + 1 
b91a .. 00			db "HOME",0              
b91f				endm 
# End of macro CWHEAD
b91f			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
b91f					if DEBUG_FORTH_WORDS_KEY 
b91f						DMARK "HOM" 
b91f f5				push af  
b920 3a 34 b9			ld a, (.dmark)  
b923 32 c0 ee			ld (debug_mark),a  
b926 3a 35 b9			ld a, (.dmark+1)  
b929 32 c1 ee			ld (debug_mark+1),a  
b92c 3a 36 b9			ld a, (.dmark+2)  
b92f 32 c2 ee			ld (debug_mark+2),a  
b932 18 03			jr .pastdmark  
b934 ..			.dmark: db "HOM"  
b937 f1			.pastdmark: pop af  
b938			endm  
# End of macro DMARK
b938						CALLMONITOR 
b938 cd 2e 93			call break_point_state  
b93b				endm  
# End of macro CALLMONITOR
b93b					endif 
b93b 3e 00		.home:		ld a, 0		; and home cursor 
b93d 32 cf ec				ld (f_cursor_ptr), a 
b940					NEXTW 
b940 c3 24 9c			jp macro_next 
b943				endm 
# End of macro NEXTW
b943			 
b943			 
b943			.SPACE: 
b943				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
b943 46				db WORD_SYS_CORE+50             
b944 71 b9			dw .SPACES            
b946 03				db 2 + 1 
b947 .. 00			db "BL",0              
b94a				endm 
# End of macro CWHEAD
b94a			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
b94a					if DEBUG_FORTH_WORDS_KEY 
b94a						DMARK "BL." 
b94a f5				push af  
b94b 3a 5f b9			ld a, (.dmark)  
b94e 32 c0 ee			ld (debug_mark),a  
b951 3a 60 b9			ld a, (.dmark+1)  
b954 32 c1 ee			ld (debug_mark+1),a  
b957 3a 61 b9			ld a, (.dmark+2)  
b95a 32 c2 ee			ld (debug_mark+2),a  
b95d 18 03			jr .pastdmark  
b95f ..			.dmark: db "BL."  
b962 f1			.pastdmark: pop af  
b963			endm  
# End of macro DMARK
b963						CALLMONITOR 
b963 cd 2e 93			call break_point_state  
b966				endm  
# End of macro CALLMONITOR
b966					endif 
b966 21 6f b9				ld hl, .blstr 
b969 cd 29 99				call forth_push_str 
b96c					 
b96c				       NEXTW 
b96c c3 24 9c			jp macro_next 
b96f				endm 
# End of macro NEXTW
b96f			 
b96f .. 00		.blstr: db " ", 0 
b971			 
b971			.SPACES: 
b971				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
b971 47				db WORD_SYS_CORE+51             
b972 0c ba			dw .SCROLL            
b974 07				db 6 + 1 
b975 .. 00			db "SPACES",0              
b97c				endm 
# End of macro CWHEAD
b97c			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
b97c					if DEBUG_FORTH_WORDS_KEY 
b97c						DMARK "SPS" 
b97c f5				push af  
b97d 3a 91 b9			ld a, (.dmark)  
b980 32 c0 ee			ld (debug_mark),a  
b983 3a 92 b9			ld a, (.dmark+1)  
b986 32 c1 ee			ld (debug_mark+1),a  
b989 3a 93 b9			ld a, (.dmark+2)  
b98c 32 c2 ee			ld (debug_mark+2),a  
b98f 18 03			jr .pastdmark  
b991 ..			.dmark: db "SPS"  
b994 f1			.pastdmark: pop af  
b995			endm  
# End of macro DMARK
b995						CALLMONITOR 
b995 cd 2e 93			call break_point_state  
b998				endm  
# End of macro CALLMONITOR
b998					endif 
b998			 
b998			 
b998					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b998 cd b2 9a			call macro_dsp_valuehl 
b99b				endm 
# End of macro FORTH_DSP_VALUEHL
b99b			 
b99b			;		push hl    ; u 
b99b					if DEBUG_FORTH_WORDS 
b99b						DMARK "SPA" 
b99b f5				push af  
b99c 3a b0 b9			ld a, (.dmark)  
b99f 32 c0 ee			ld (debug_mark),a  
b9a2 3a b1 b9			ld a, (.dmark+1)  
b9a5 32 c1 ee			ld (debug_mark+1),a  
b9a8 3a b2 b9			ld a, (.dmark+2)  
b9ab 32 c2 ee			ld (debug_mark+2),a  
b9ae 18 03			jr .pastdmark  
b9b0 ..			.dmark: db "SPA"  
b9b3 f1			.pastdmark: pop af  
b9b4			endm  
# End of macro DMARK
b9b4						CALLMONITOR 
b9b4 cd 2e 93			call break_point_state  
b9b7				endm  
# End of macro CALLMONITOR
b9b7					endif 
b9b7			 
b9b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b9b7 cd 6a 9b			call macro_forth_dsp_pop 
b9ba				endm 
# End of macro FORTH_DSP_POP
b9ba			;		pop hl 
b9ba 4d					ld c, l 
b9bb 06 00				ld b, 0 
b9bd 21 e6 e4				ld hl, scratch  
b9c0			 
b9c0					if DEBUG_FORTH_WORDS 
b9c0						DMARK "SP2" 
b9c0 f5				push af  
b9c1 3a d5 b9			ld a, (.dmark)  
b9c4 32 c0 ee			ld (debug_mark),a  
b9c7 3a d6 b9			ld a, (.dmark+1)  
b9ca 32 c1 ee			ld (debug_mark+1),a  
b9cd 3a d7 b9			ld a, (.dmark+2)  
b9d0 32 c2 ee			ld (debug_mark+2),a  
b9d3 18 03			jr .pastdmark  
b9d5 ..			.dmark: db "SP2"  
b9d8 f1			.pastdmark: pop af  
b9d9			endm  
# End of macro DMARK
b9d9						CALLMONITOR 
b9d9 cd 2e 93			call break_point_state  
b9dc				endm  
# End of macro CALLMONITOR
b9dc					endif 
b9dc 3e 20				ld a, ' ' 
b9de c5			.spaces1:	push bc 
b9df 77					ld (hl),a 
b9e0 23					inc hl 
b9e1 c1					pop bc 
b9e2 10 fa				djnz .spaces1 
b9e4 3e 00				ld a,0 
b9e6 77					ld (hl),a 
b9e7 21 e6 e4				ld hl, scratch 
b9ea					if DEBUG_FORTH_WORDS 
b9ea						DMARK "SP3" 
b9ea f5				push af  
b9eb 3a ff b9			ld a, (.dmark)  
b9ee 32 c0 ee			ld (debug_mark),a  
b9f1 3a 00 ba			ld a, (.dmark+1)  
b9f4 32 c1 ee			ld (debug_mark+1),a  
b9f7 3a 01 ba			ld a, (.dmark+2)  
b9fa 32 c2 ee			ld (debug_mark+2),a  
b9fd 18 03			jr .pastdmark  
b9ff ..			.dmark: db "SP3"  
ba02 f1			.pastdmark: pop af  
ba03			endm  
# End of macro DMARK
ba03						CALLMONITOR 
ba03 cd 2e 93			call break_point_state  
ba06				endm  
# End of macro CALLMONITOR
ba06					endif 
ba06 cd 24 9a				call forth_apush 
ba09			 
ba09				       NEXTW 
ba09 c3 24 9c			jp macro_next 
ba0c				endm 
# End of macro NEXTW
ba0c			 
ba0c			 
ba0c			 
ba0c			.SCROLL: 
ba0c				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
ba0c 53				db WORD_SYS_CORE+63             
ba0d 39 ba			dw .SCROLLD            
ba0f 07				db 6 + 1 
ba10 .. 00			db "SCROLL",0              
ba17				endm 
# End of macro CWHEAD
ba17			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
ba17					if DEBUG_FORTH_WORDS_KEY 
ba17						DMARK "SCR" 
ba17 f5				push af  
ba18 3a 2c ba			ld a, (.dmark)  
ba1b 32 c0 ee			ld (debug_mark),a  
ba1e 3a 2d ba			ld a, (.dmark+1)  
ba21 32 c1 ee			ld (debug_mark+1),a  
ba24 3a 2e ba			ld a, (.dmark+2)  
ba27 32 c2 ee			ld (debug_mark+2),a  
ba2a 18 03			jr .pastdmark  
ba2c ..			.dmark: db "SCR"  
ba2f f1			.pastdmark: pop af  
ba30			endm  
# End of macro DMARK
ba30						CALLMONITOR 
ba30 cd 2e 93			call break_point_state  
ba33				endm  
# End of macro CALLMONITOR
ba33					endif 
ba33			 
ba33 cd 50 88			call scroll_up 
ba36			;	call update_display 
ba36			 
ba36					NEXTW 
ba36 c3 24 9c			jp macro_next 
ba39				endm 
# End of macro NEXTW
ba39			 
ba39			 
ba39			 
ba39			;		; get dir 
ba39			; 
ba39			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba39			; 
ba39			;		push hl 
ba39			; 
ba39			;		; destroy value TOS 
ba39			; 
ba39			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba39			; 
ba39			;		; get count 
ba39			; 
ba39			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba39			; 
ba39			;		push hl 
ba39			; 
ba39			;		; destroy value TOS 
ba39			; 
ba39			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba39			; 
ba39			;		; one value on hl get other one back 
ba39			; 
ba39			;		pop bc    ; count 
ba39			; 
ba39			;		pop de   ; dir 
ba39			; 
ba39			; 
ba39			;		ld b, c 
ba39			; 
ba39			;.scrolldir:     push bc 
ba39			;		push de 
ba39			; 
ba39			;		ld a, 0 
ba39			;		cp e 
ba39			;		jr z, .scrollup  
ba39			;		call scroll_down 
ba39			;		jr .scrollnext 
ba39			;.scrollup:	call scroll_up 
ba39			; 
ba39			;		 
ba39			;.scrollnext: 
ba39			;		pop de 
ba39			;		pop bc 
ba39			;		djnz .scrolldir 
ba39			; 
ba39			; 
ba39			; 
ba39			; 
ba39			; 
ba39			;		NEXTW 
ba39			 
ba39			.SCROLLD: 
ba39				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
ba39 53				db WORD_SYS_CORE+63             
ba3a 67 ba			dw .ATQ            
ba3c 08				db 7 + 1 
ba3d .. 00			db "SCROLLD",0              
ba45				endm 
# End of macro CWHEAD
ba45			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
ba45					if DEBUG_FORTH_WORDS_KEY 
ba45						DMARK "SCD" 
ba45 f5				push af  
ba46 3a 5a ba			ld a, (.dmark)  
ba49 32 c0 ee			ld (debug_mark),a  
ba4c 3a 5b ba			ld a, (.dmark+1)  
ba4f 32 c1 ee			ld (debug_mark+1),a  
ba52 3a 5c ba			ld a, (.dmark+2)  
ba55 32 c2 ee			ld (debug_mark+2),a  
ba58 18 03			jr .pastdmark  
ba5a ..			.dmark: db "SCD"  
ba5d f1			.pastdmark: pop af  
ba5e			endm  
# End of macro DMARK
ba5e						CALLMONITOR 
ba5e cd 2e 93			call break_point_state  
ba61				endm  
# End of macro CALLMONITOR
ba61					endif 
ba61			 
ba61 cd 74 88			call scroll_down 
ba64			;	call update_display 
ba64			 
ba64					NEXTW 
ba64 c3 24 9c			jp macro_next 
ba67				endm 
# End of macro NEXTW
ba67			 
ba67			 
ba67			.ATQ: 
ba67				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
ba67 62				db WORD_SYS_CORE+78             
ba68 c5 ba			dw .AUTODSP            
ba6a 04				db 3 + 1 
ba6b .. 00			db "AT@",0              
ba6f				endm 
# End of macro CWHEAD
ba6f			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
ba6f					if DEBUG_FORTH_WORDS_KEY 
ba6f						DMARK "ATA" 
ba6f f5				push af  
ba70 3a 84 ba			ld a, (.dmark)  
ba73 32 c0 ee			ld (debug_mark),a  
ba76 3a 85 ba			ld a, (.dmark+1)  
ba79 32 c1 ee			ld (debug_mark+1),a  
ba7c 3a 86 ba			ld a, (.dmark+2)  
ba7f 32 c2 ee			ld (debug_mark+2),a  
ba82 18 03			jr .pastdmark  
ba84 ..			.dmark: db "ATA"  
ba87 f1			.pastdmark: pop af  
ba88			endm  
# End of macro DMARK
ba88						CALLMONITOR 
ba88 cd 2e 93			call break_point_state  
ba8b				endm  
# End of macro CALLMONITOR
ba8b					endif 
ba8b			 
ba8b			 
ba8b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba8b cd b2 9a			call macro_dsp_valuehl 
ba8e				endm 
# End of macro FORTH_DSP_VALUEHL
ba8e			 
ba8e					; TODO save cursor row 
ba8e 7d					ld a,l 
ba8f fe 02				cp 2 
ba91 20 04				jr nz, .crow3aq 
ba93 3e 14				ld a, display_row_2 
ba95 18 12				jr .ccol1aq 
ba97 fe 03		.crow3aq:		cp 3 
ba99 20 04				jr nz, .crow4aq 
ba9b 3e 28				ld a, display_row_3 
ba9d 18 0a				jr .ccol1aq 
ba9f fe 04		.crow4aq:		cp 4 
baa1 20 04				jr nz, .crow1aq 
baa3 3e 3c				ld a, display_row_4 
baa5 18 02				jr .ccol1aq 
baa7 3e 00		.crow1aq:		ld a,display_row_1 
baa9 f5			.ccol1aq:		push af			; got row offset 
baaa 6f					ld l,a 
baab 26 00				ld h,0 
baad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
baad cd 6a 9b			call macro_forth_dsp_pop 
bab0				endm 
# End of macro FORTH_DSP_POP
bab0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bab0 cd b2 9a			call macro_dsp_valuehl 
bab3				endm 
# End of macro FORTH_DSP_VALUEHL
bab3					; TODO save cursor col 
bab3 f1					pop af 
bab4 85					add l		; add col offset 
bab5			 
bab5					; add current frame buffer address 
bab5 2a 61 ed				ld hl, (display_fb_active) 
bab8 cd bb 8a				call addatohl 
babb			 
babb			 
babb			 
babb			 
babb					; get char frame buffer location offset in hl 
babb			 
babb 7e					ld a,(hl) 
babc 26 00				ld h, 0 
babe 6f					ld l, a 
babf			 
babf cd bb 98				call forth_push_numhl 
bac2			 
bac2			 
bac2					NEXTW 
bac2 c3 24 9c			jp macro_next 
bac5				endm 
# End of macro NEXTW
bac5			 
bac5			.AUTODSP: 
bac5				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bac5 63				db WORD_SYS_CORE+79             
bac6 db ba			dw .MENU            
bac8 05				db 4 + 1 
bac9 .. 00			db "ADSP",0              
bace				endm 
# End of macro CWHEAD
bace			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bace			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bace			 
bace					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bace cd b2 9a			call macro_dsp_valuehl 
bad1				endm 
# End of macro FORTH_DSP_VALUEHL
bad1			 
bad1			;		push hl 
bad1			 
bad1					; destroy value TOS 
bad1			 
bad1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bad1 cd 6a 9b			call macro_forth_dsp_pop 
bad4				endm 
# End of macro FORTH_DSP_POP
bad4			 
bad4			;		pop hl 
bad4			 
bad4 7d					ld a,l 
bad5 32 ad ec				ld (cli_autodisplay), a 
bad8				       NEXTW 
bad8 c3 24 9c			jp macro_next 
badb				endm 
# End of macro NEXTW
badb			 
badb			.MENU: 
badb				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
badb 70				db WORD_SYS_CORE+92             
badc 84 bb			dw .ENDDISPLAY            
bade 05				db 4 + 1 
badf .. 00			db "MENU",0              
bae4				endm 
# End of macro CWHEAD
bae4			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bae4			 
bae4			;		; get number of items on the stack 
bae4			; 
bae4				 
bae4					FORTH_DSP_VALUEHL 
bae4 cd b2 9a			call macro_dsp_valuehl 
bae7				endm 
# End of macro FORTH_DSP_VALUEHL
bae7				 
bae7					if DEBUG_FORTH_WORDS_KEY 
bae7						DMARK "MNU" 
bae7 f5				push af  
bae8 3a fc ba			ld a, (.dmark)  
baeb 32 c0 ee			ld (debug_mark),a  
baee 3a fd ba			ld a, (.dmark+1)  
baf1 32 c1 ee			ld (debug_mark+1),a  
baf4 3a fe ba			ld a, (.dmark+2)  
baf7 32 c2 ee			ld (debug_mark+2),a  
bafa 18 03			jr .pastdmark  
bafc ..			.dmark: db "MNU"  
baff f1			.pastdmark: pop af  
bb00			endm  
# End of macro DMARK
bb00						CALLMONITOR 
bb00 cd 2e 93			call break_point_state  
bb03				endm  
# End of macro CALLMONITOR
bb03					endif 
bb03			 
bb03 45					ld b, l	 
bb04 05					dec b 
bb05			 
bb05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb05 cd 6a 9b			call macro_forth_dsp_pop 
bb08				endm 
# End of macro FORTH_DSP_POP
bb08			 
bb08			 
bb08					; go directly through the stack to pluck out the string pointers and build an array 
bb08			 
bb08			;		FORTH_DSP 
bb08			 
bb08					; hl contains top most stack item 
bb08				 
bb08 11 e6 e4				ld de, scratch 
bb0b			 
bb0b			.mbuild: 
bb0b			 
bb0b					FORTH_DSP_VALUEHL 
bb0b cd b2 9a			call macro_dsp_valuehl 
bb0e				endm 
# End of macro FORTH_DSP_VALUEHL
bb0e			 
bb0e					if DEBUG_FORTH_WORDS 
bb0e						DMARK "MN3" 
bb0e f5				push af  
bb0f 3a 23 bb			ld a, (.dmark)  
bb12 32 c0 ee			ld (debug_mark),a  
bb15 3a 24 bb			ld a, (.dmark+1)  
bb18 32 c1 ee			ld (debug_mark+1),a  
bb1b 3a 25 bb			ld a, (.dmark+2)  
bb1e 32 c2 ee			ld (debug_mark+2),a  
bb21 18 03			jr .pastdmark  
bb23 ..			.dmark: db "MN3"  
bb26 f1			.pastdmark: pop af  
bb27			endm  
# End of macro DMARK
bb27						CALLMONITOR 
bb27 cd 2e 93			call break_point_state  
bb2a				endm  
# End of macro CALLMONITOR
bb2a					endif 
bb2a eb					ex de, hl 
bb2b 73					ld (hl), e 
bb2c 23					inc hl 
bb2d 72					ld (hl), d 
bb2e 23					inc hl 
bb2f eb					ex de, hl 
bb30			 
bb30					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb30 cd 6a 9b			call macro_forth_dsp_pop 
bb33				endm 
# End of macro FORTH_DSP_POP
bb33			 
bb33 10 d6				djnz .mbuild 
bb35			 
bb35					; done add term 
bb35			 
bb35 eb					ex de, hl 
bb36 36 00				ld (hl), 0 
bb38 23					inc hl 
bb39 36 00				ld (hl), 0 
bb3b			 
bb3b				 
bb3b					 
bb3b 21 e6 e4				ld hl, scratch 
bb3e			 
bb3e					if DEBUG_FORTH_WORDS 
bb3e						DMARK "MNx" 
bb3e f5				push af  
bb3f 3a 53 bb			ld a, (.dmark)  
bb42 32 c0 ee			ld (debug_mark),a  
bb45 3a 54 bb			ld a, (.dmark+1)  
bb48 32 c1 ee			ld (debug_mark+1),a  
bb4b 3a 55 bb			ld a, (.dmark+2)  
bb4e 32 c2 ee			ld (debug_mark+2),a  
bb51 18 03			jr .pastdmark  
bb53 ..			.dmark: db "MNx"  
bb56 f1			.pastdmark: pop af  
bb57			endm  
# End of macro DMARK
bb57						CALLMONITOR 
bb57 cd 2e 93			call break_point_state  
bb5a				endm  
# End of macro CALLMONITOR
bb5a					endif 
bb5a			 
bb5a			 
bb5a			 
bb5a 3e 00				ld a, 0 
bb5c cd bf 88				call menu 
bb5f			 
bb5f			 
bb5f 6f					ld l, a 
bb60 26 00				ld h, 0 
bb62			 
bb62					if DEBUG_FORTH_WORDS 
bb62						DMARK "MNr" 
bb62 f5				push af  
bb63 3a 77 bb			ld a, (.dmark)  
bb66 32 c0 ee			ld (debug_mark),a  
bb69 3a 78 bb			ld a, (.dmark+1)  
bb6c 32 c1 ee			ld (debug_mark+1),a  
bb6f 3a 79 bb			ld a, (.dmark+2)  
bb72 32 c2 ee			ld (debug_mark+2),a  
bb75 18 03			jr .pastdmark  
bb77 ..			.dmark: db "MNr"  
bb7a f1			.pastdmark: pop af  
bb7b			endm  
# End of macro DMARK
bb7b						CALLMONITOR 
bb7b cd 2e 93			call break_point_state  
bb7e				endm  
# End of macro CALLMONITOR
bb7e					endif 
bb7e			 
bb7e cd bb 98				call forth_push_numhl 
bb81			 
bb81			 
bb81			 
bb81			 
bb81				       NEXTW 
bb81 c3 24 9c			jp macro_next 
bb84				endm 
# End of macro NEXTW
bb84			 
bb84			 
bb84			.ENDDISPLAY: 
bb84			 
bb84			; eof 
# End of file forth_words_display.asm
bb84			include "forth_words_str.asm" 
bb84			 
bb84			; | ## String Words 
bb84			 
bb84			.PTR:   
bb84			 
bb84				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
bb84 48				db WORD_SYS_CORE+52             
bb85 b1 bb			dw .STYPE            
bb87 04				db 3 + 1 
bb88 .. 00			db "PTR",0              
bb8c				endm 
# End of macro CWHEAD
bb8c			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
bb8c			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
bb8c			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
bb8c			 
bb8c					if DEBUG_FORTH_WORDS_KEY 
bb8c						DMARK "PTR" 
bb8c f5				push af  
bb8d 3a a1 bb			ld a, (.dmark)  
bb90 32 c0 ee			ld (debug_mark),a  
bb93 3a a2 bb			ld a, (.dmark+1)  
bb96 32 c1 ee			ld (debug_mark+1),a  
bb99 3a a3 bb			ld a, (.dmark+2)  
bb9c 32 c2 ee			ld (debug_mark+2),a  
bb9f 18 03			jr .pastdmark  
bba1 ..			.dmark: db "PTR"  
bba4 f1			.pastdmark: pop af  
bba5			endm  
# End of macro DMARK
bba5						CALLMONITOR 
bba5 cd 2e 93			call break_point_state  
bba8				endm  
# End of macro CALLMONITOR
bba8					endif 
bba8					FORTH_DSP_VALUEHL 
bba8 cd b2 9a			call macro_dsp_valuehl 
bbab				endm 
# End of macro FORTH_DSP_VALUEHL
bbab cd bb 98				call forth_push_numhl 
bbae			 
bbae			 
bbae					NEXTW 
bbae c3 24 9c			jp macro_next 
bbb1				endm 
# End of macro NEXTW
bbb1			.STYPE: 
bbb1				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
bbb1 48				db WORD_SYS_CORE+52             
bbb2 00 bc			dw .UPPER            
bbb4 06				db 5 + 1 
bbb5 .. 00			db "STYPE",0              
bbbb				endm 
# End of macro CWHEAD
bbbb			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
bbbb					if DEBUG_FORTH_WORDS_KEY 
bbbb						DMARK "STY" 
bbbb f5				push af  
bbbc 3a d0 bb			ld a, (.dmark)  
bbbf 32 c0 ee			ld (debug_mark),a  
bbc2 3a d1 bb			ld a, (.dmark+1)  
bbc5 32 c1 ee			ld (debug_mark+1),a  
bbc8 3a d2 bb			ld a, (.dmark+2)  
bbcb 32 c2 ee			ld (debug_mark+2),a  
bbce 18 03			jr .pastdmark  
bbd0 ..			.dmark: db "STY"  
bbd3 f1			.pastdmark: pop af  
bbd4			endm  
# End of macro DMARK
bbd4						CALLMONITOR 
bbd4 cd 2e 93			call break_point_state  
bbd7				endm  
# End of macro CALLMONITOR
bbd7					endif 
bbd7					FORTH_DSP 
bbd7 cd 78 9a			call macro_forth_dsp 
bbda				endm 
# End of macro FORTH_DSP
bbda					;v5 FORTH_DSP_VALUE 
bbda			 
bbda 7e					ld a, (hl) 
bbdb			 
bbdb f5					push af 
bbdc			 
bbdc			; Dont destroy TOS		FORTH_DSP_POP 
bbdc			 
bbdc f1					pop af 
bbdd			 
bbdd fe 01				cp DS_TYPE_STR 
bbdf 28 09				jr z, .typestr 
bbe1			 
bbe1 fe 02				cp DS_TYPE_INUM 
bbe3 28 0a				jr z, .typeinum 
bbe5			 
bbe5 21 fe bb				ld hl, .tna 
bbe8 18 0a				jr .tpush 
bbea			 
bbea 21 fa bb		.typestr:	ld hl, .tstr 
bbed 18 05				jr .tpush 
bbef 21 fc bb		.typeinum:	ld hl, .tinum 
bbf2 18 00				jr .tpush 
bbf4			 
bbf4			.tpush: 
bbf4			 
bbf4 cd 29 99				call forth_push_str 
bbf7			 
bbf7					NEXTW 
bbf7 c3 24 9c			jp macro_next 
bbfa				endm 
# End of macro NEXTW
bbfa .. 00		.tstr:	db "s",0 
bbfc .. 00		.tinum:  db "i",0 
bbfe .. 00		.tna:   db "?", 0 
bc00			 
bc00			 
bc00			.UPPER: 
bc00				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
bc00 48				db WORD_SYS_CORE+52             
bc01 3b bc			dw .LOWER            
bc03 06				db 5 + 1 
bc04 .. 00			db "UPPER",0              
bc0a				endm 
# End of macro CWHEAD
bc0a			; | UPPER ( s -- s ) Upper case string s  | DONE 
bc0a					if DEBUG_FORTH_WORDS_KEY 
bc0a						DMARK "UPR" 
bc0a f5				push af  
bc0b 3a 1f bc			ld a, (.dmark)  
bc0e 32 c0 ee			ld (debug_mark),a  
bc11 3a 20 bc			ld a, (.dmark+1)  
bc14 32 c1 ee			ld (debug_mark+1),a  
bc17 3a 21 bc			ld a, (.dmark+2)  
bc1a 32 c2 ee			ld (debug_mark+2),a  
bc1d 18 03			jr .pastdmark  
bc1f ..			.dmark: db "UPR"  
bc22 f1			.pastdmark: pop af  
bc23			endm  
# End of macro DMARK
bc23						CALLMONITOR 
bc23 cd 2e 93			call break_point_state  
bc26				endm  
# End of macro CALLMONITOR
bc26					endif 
bc26			 
bc26					FORTH_DSP 
bc26 cd 78 9a			call macro_forth_dsp 
bc29				endm 
# End of macro FORTH_DSP
bc29					 
bc29			; TODO check is string type 
bc29			 
bc29					FORTH_DSP_VALUEHL 
bc29 cd b2 9a			call macro_dsp_valuehl 
bc2c				endm 
# End of macro FORTH_DSP_VALUEHL
bc2c			; get pointer to string in hl 
bc2c			 
bc2c 7e			.toup:		ld a, (hl) 
bc2d fe 00				cp 0 
bc2f 28 07				jr z, .toupdone 
bc31			 
bc31 cd 28 8e				call to_upper 
bc34			 
bc34 77					ld (hl), a 
bc35 23					inc hl 
bc36 18 f4				jr .toup 
bc38			 
bc38					 
bc38			 
bc38			 
bc38			; for each char convert to upper 
bc38					 
bc38			.toupdone: 
bc38			 
bc38			 
bc38					NEXTW 
bc38 c3 24 9c			jp macro_next 
bc3b				endm 
# End of macro NEXTW
bc3b			.LOWER: 
bc3b				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
bc3b 48				db WORD_SYS_CORE+52             
bc3c 76 bc			dw .TCASE            
bc3e 06				db 5 + 1 
bc3f .. 00			db "LOWER",0              
bc45				endm 
# End of macro CWHEAD
bc45			; | LOWER ( s -- s ) Lower case string s  | DONE 
bc45					if DEBUG_FORTH_WORDS_KEY 
bc45						DMARK "LWR" 
bc45 f5				push af  
bc46 3a 5a bc			ld a, (.dmark)  
bc49 32 c0 ee			ld (debug_mark),a  
bc4c 3a 5b bc			ld a, (.dmark+1)  
bc4f 32 c1 ee			ld (debug_mark+1),a  
bc52 3a 5c bc			ld a, (.dmark+2)  
bc55 32 c2 ee			ld (debug_mark+2),a  
bc58 18 03			jr .pastdmark  
bc5a ..			.dmark: db "LWR"  
bc5d f1			.pastdmark: pop af  
bc5e			endm  
# End of macro DMARK
bc5e						CALLMONITOR 
bc5e cd 2e 93			call break_point_state  
bc61				endm  
# End of macro CALLMONITOR
bc61					endif 
bc61			 
bc61					FORTH_DSP 
bc61 cd 78 9a			call macro_forth_dsp 
bc64				endm 
# End of macro FORTH_DSP
bc64					 
bc64			; TODO check is string type 
bc64			 
bc64					FORTH_DSP_VALUEHL 
bc64 cd b2 9a			call macro_dsp_valuehl 
bc67				endm 
# End of macro FORTH_DSP_VALUEHL
bc67			; get pointer to string in hl 
bc67			 
bc67 7e			.tolow:		ld a, (hl) 
bc68 fe 00				cp 0 
bc6a 28 07				jr z, .tolowdone 
bc6c			 
bc6c cd 31 8e				call to_lower 
bc6f			 
bc6f 77					ld (hl), a 
bc70 23					inc hl 
bc71 18 f4				jr .tolow 
bc73			 
bc73					 
bc73			 
bc73			 
bc73			; for each char convert to low 
bc73					 
bc73			.tolowdone: 
bc73					NEXTW 
bc73 c3 24 9c			jp macro_next 
bc76				endm 
# End of macro NEXTW
bc76			.TCASE: 
bc76				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
bc76 48				db WORD_SYS_CORE+52             
bc77 ac bd			dw .SUBSTR            
bc79 06				db 5 + 1 
bc7a .. 00			db "TCASE",0              
bc80				endm 
# End of macro CWHEAD
bc80			; | TCASE ( s -- s ) Title case string s  | DONE 
bc80					if DEBUG_FORTH_WORDS_KEY 
bc80						DMARK "TCS" 
bc80 f5				push af  
bc81 3a 95 bc			ld a, (.dmark)  
bc84 32 c0 ee			ld (debug_mark),a  
bc87 3a 96 bc			ld a, (.dmark+1)  
bc8a 32 c1 ee			ld (debug_mark+1),a  
bc8d 3a 97 bc			ld a, (.dmark+2)  
bc90 32 c2 ee			ld (debug_mark+2),a  
bc93 18 03			jr .pastdmark  
bc95 ..			.dmark: db "TCS"  
bc98 f1			.pastdmark: pop af  
bc99			endm  
# End of macro DMARK
bc99						CALLMONITOR 
bc99 cd 2e 93			call break_point_state  
bc9c				endm  
# End of macro CALLMONITOR
bc9c					endif 
bc9c			 
bc9c					FORTH_DSP 
bc9c cd 78 9a			call macro_forth_dsp 
bc9f				endm 
# End of macro FORTH_DSP
bc9f					 
bc9f			; TODO check is string type 
bc9f			 
bc9f					FORTH_DSP_VALUEHL 
bc9f cd b2 9a			call macro_dsp_valuehl 
bca2				endm 
# End of macro FORTH_DSP_VALUEHL
bca2			; get pointer to string in hl 
bca2			 
bca2					if DEBUG_FORTH_WORDS 
bca2						DMARK "TC1" 
bca2 f5				push af  
bca3 3a b7 bc			ld a, (.dmark)  
bca6 32 c0 ee			ld (debug_mark),a  
bca9 3a b8 bc			ld a, (.dmark+1)  
bcac 32 c1 ee			ld (debug_mark+1),a  
bcaf 3a b9 bc			ld a, (.dmark+2)  
bcb2 32 c2 ee			ld (debug_mark+2),a  
bcb5 18 03			jr .pastdmark  
bcb7 ..			.dmark: db "TC1"  
bcba f1			.pastdmark: pop af  
bcbb			endm  
# End of macro DMARK
bcbb						CALLMONITOR 
bcbb cd 2e 93			call break_point_state  
bcbe				endm  
# End of macro CALLMONITOR
bcbe					endif 
bcbe			 
bcbe					; first time in turn to upper case first char 
bcbe			 
bcbe 7e					ld a, (hl) 
bcbf c3 49 bd				jp .totsiptou 
bcc2			 
bcc2			 
bcc2 7e			.tot:		ld a, (hl) 
bcc3 fe 00				cp 0 
bcc5 ca 8d bd				jp z, .totdone 
bcc8			 
bcc8					if DEBUG_FORTH_WORDS 
bcc8						DMARK "TC2" 
bcc8 f5				push af  
bcc9 3a dd bc			ld a, (.dmark)  
bccc 32 c0 ee			ld (debug_mark),a  
bccf 3a de bc			ld a, (.dmark+1)  
bcd2 32 c1 ee			ld (debug_mark+1),a  
bcd5 3a df bc			ld a, (.dmark+2)  
bcd8 32 c2 ee			ld (debug_mark+2),a  
bcdb 18 03			jr .pastdmark  
bcdd ..			.dmark: db "TC2"  
bce0 f1			.pastdmark: pop af  
bce1			endm  
# End of macro DMARK
bce1						CALLMONITOR 
bce1 cd 2e 93			call break_point_state  
bce4				endm  
# End of macro CALLMONITOR
bce4					endif 
bce4					; check to see if current char is a space 
bce4			 
bce4 fe 20				cp ' ' 
bce6 28 21				jr z, .totsp 
bce8 cd 31 8e				call to_lower 
bceb					if DEBUG_FORTH_WORDS 
bceb						DMARK "TC3" 
bceb f5				push af  
bcec 3a 00 bd			ld a, (.dmark)  
bcef 32 c0 ee			ld (debug_mark),a  
bcf2 3a 01 bd			ld a, (.dmark+1)  
bcf5 32 c1 ee			ld (debug_mark+1),a  
bcf8 3a 02 bd			ld a, (.dmark+2)  
bcfb 32 c2 ee			ld (debug_mark+2),a  
bcfe 18 03			jr .pastdmark  
bd00 ..			.dmark: db "TC3"  
bd03 f1			.pastdmark: pop af  
bd04			endm  
# End of macro DMARK
bd04						CALLMONITOR 
bd04 cd 2e 93			call break_point_state  
bd07				endm  
# End of macro CALLMONITOR
bd07					endif 
bd07 18 63				jr .totnxt 
bd09			 
bd09			.totsp:         ; on a space, find next char which should be upper 
bd09			 
bd09					if DEBUG_FORTH_WORDS 
bd09						DMARK "TC4" 
bd09 f5				push af  
bd0a 3a 1e bd			ld a, (.dmark)  
bd0d 32 c0 ee			ld (debug_mark),a  
bd10 3a 1f bd			ld a, (.dmark+1)  
bd13 32 c1 ee			ld (debug_mark+1),a  
bd16 3a 20 bd			ld a, (.dmark+2)  
bd19 32 c2 ee			ld (debug_mark+2),a  
bd1c 18 03			jr .pastdmark  
bd1e ..			.dmark: db "TC4"  
bd21 f1			.pastdmark: pop af  
bd22			endm  
# End of macro DMARK
bd22						CALLMONITOR 
bd22 cd 2e 93			call break_point_state  
bd25				endm  
# End of macro CALLMONITOR
bd25					endif 
bd25					;; 
bd25			 
bd25 fe 20				cp ' ' 
bd27 20 20				jr nz, .totsiptou 
bd29 23					inc hl 
bd2a 7e					ld a, (hl) 
bd2b					if DEBUG_FORTH_WORDS 
bd2b						DMARK "TC5" 
bd2b f5				push af  
bd2c 3a 40 bd			ld a, (.dmark)  
bd2f 32 c0 ee			ld (debug_mark),a  
bd32 3a 41 bd			ld a, (.dmark+1)  
bd35 32 c1 ee			ld (debug_mark+1),a  
bd38 3a 42 bd			ld a, (.dmark+2)  
bd3b 32 c2 ee			ld (debug_mark+2),a  
bd3e 18 03			jr .pastdmark  
bd40 ..			.dmark: db "TC5"  
bd43 f1			.pastdmark: pop af  
bd44			endm  
# End of macro DMARK
bd44						CALLMONITOR 
bd44 cd 2e 93			call break_point_state  
bd47				endm  
# End of macro CALLMONITOR
bd47					endif 
bd47 18 c0				jr .totsp 
bd49 fe 00		.totsiptou:    cp 0 
bd4b 28 40				jr z, .totdone 
bd4d					; not space and not zero term so upper case it 
bd4d cd 28 8e				call to_upper 
bd50			 
bd50					if DEBUG_FORTH_WORDS 
bd50						DMARK "TC6" 
bd50 f5				push af  
bd51 3a 65 bd			ld a, (.dmark)  
bd54 32 c0 ee			ld (debug_mark),a  
bd57 3a 66 bd			ld a, (.dmark+1)  
bd5a 32 c1 ee			ld (debug_mark+1),a  
bd5d 3a 67 bd			ld a, (.dmark+2)  
bd60 32 c2 ee			ld (debug_mark+2),a  
bd63 18 03			jr .pastdmark  
bd65 ..			.dmark: db "TC6"  
bd68 f1			.pastdmark: pop af  
bd69			endm  
# End of macro DMARK
bd69						CALLMONITOR 
bd69 cd 2e 93			call break_point_state  
bd6c				endm  
# End of macro CALLMONITOR
bd6c					endif 
bd6c			 
bd6c			 
bd6c			.totnxt: 
bd6c			 
bd6c 77					ld (hl), a 
bd6d 23					inc hl 
bd6e					if DEBUG_FORTH_WORDS 
bd6e						DMARK "TC7" 
bd6e f5				push af  
bd6f 3a 83 bd			ld a, (.dmark)  
bd72 32 c0 ee			ld (debug_mark),a  
bd75 3a 84 bd			ld a, (.dmark+1)  
bd78 32 c1 ee			ld (debug_mark+1),a  
bd7b 3a 85 bd			ld a, (.dmark+2)  
bd7e 32 c2 ee			ld (debug_mark+2),a  
bd81 18 03			jr .pastdmark  
bd83 ..			.dmark: db "TC7"  
bd86 f1			.pastdmark: pop af  
bd87			endm  
# End of macro DMARK
bd87						CALLMONITOR 
bd87 cd 2e 93			call break_point_state  
bd8a				endm  
# End of macro CALLMONITOR
bd8a					endif 
bd8a c3 c2 bc				jp .tot 
bd8d			 
bd8d					 
bd8d			 
bd8d			 
bd8d			; for each char convert to low 
bd8d					 
bd8d			.totdone: 
bd8d					if DEBUG_FORTH_WORDS 
bd8d						DMARK "TCd" 
bd8d f5				push af  
bd8e 3a a2 bd			ld a, (.dmark)  
bd91 32 c0 ee			ld (debug_mark),a  
bd94 3a a3 bd			ld a, (.dmark+1)  
bd97 32 c1 ee			ld (debug_mark+1),a  
bd9a 3a a4 bd			ld a, (.dmark+2)  
bd9d 32 c2 ee			ld (debug_mark+2),a  
bda0 18 03			jr .pastdmark  
bda2 ..			.dmark: db "TCd"  
bda5 f1			.pastdmark: pop af  
bda6			endm  
# End of macro DMARK
bda6						CALLMONITOR 
bda6 cd 2e 93			call break_point_state  
bda9				endm  
# End of macro CALLMONITOR
bda9					endif 
bda9					NEXTW 
bda9 c3 24 9c			jp macro_next 
bdac				endm 
# End of macro NEXTW
bdac			 
bdac			.SUBSTR: 
bdac				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
bdac 48				db WORD_SYS_CORE+52             
bdad 0a be			dw .LEFT            
bdaf 07				db 6 + 1 
bdb0 .. 00			db "SUBSTR",0              
bdb7				endm 
# End of macro CWHEAD
bdb7			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
bdb7			 
bdb7					if DEBUG_FORTH_WORDS_KEY 
bdb7						DMARK "SST" 
bdb7 f5				push af  
bdb8 3a cc bd			ld a, (.dmark)  
bdbb 32 c0 ee			ld (debug_mark),a  
bdbe 3a cd bd			ld a, (.dmark+1)  
bdc1 32 c1 ee			ld (debug_mark+1),a  
bdc4 3a ce bd			ld a, (.dmark+2)  
bdc7 32 c2 ee			ld (debug_mark+2),a  
bdca 18 03			jr .pastdmark  
bdcc ..			.dmark: db "SST"  
bdcf f1			.pastdmark: pop af  
bdd0			endm  
# End of macro DMARK
bdd0						CALLMONITOR 
bdd0 cd 2e 93			call break_point_state  
bdd3				endm  
# End of macro CALLMONITOR
bdd3					endif 
bdd3			; TODO check string type 
bdd3					FORTH_DSP_VALUEHL 
bdd3 cd b2 9a			call macro_dsp_valuehl 
bdd6				endm 
# End of macro FORTH_DSP_VALUEHL
bdd6			 
bdd6 e5					push hl      ; string length 
bdd7			 
bdd7					FORTH_DSP_POP 
bdd7 cd 6a 9b			call macro_forth_dsp_pop 
bdda				endm 
# End of macro FORTH_DSP_POP
bdda			 
bdda					FORTH_DSP_VALUEHL 
bdda cd b2 9a			call macro_dsp_valuehl 
bddd				endm 
# End of macro FORTH_DSP_VALUEHL
bddd			 
bddd e5					push hl     ; start char 
bdde			 
bdde					FORTH_DSP_POP 
bdde cd 6a 9b			call macro_forth_dsp_pop 
bde1				endm 
# End of macro FORTH_DSP_POP
bde1			 
bde1			 
bde1					FORTH_DSP_VALUE 
bde1 cd 9b 9a			call macro_forth_dsp_value 
bde4				endm 
# End of macro FORTH_DSP_VALUE
bde4			 
bde4 d1					pop de    ; get start post offset 
bde5			 
bde5 19					add hl, de    ; starting offset 
bde6			 
bde6 c1					pop bc 
bde7 c5					push bc      ; grab size of string 
bde8			 
bde8 e5					push hl    ; save string start  
bde9			 
bde9 26 00				ld h, 0 
bdeb 69					ld l, c 
bdec 23					inc hl 
bded 23					inc hl 
bdee			 
bdee cd 82 8f				call malloc 
bdf1				if DEBUG_FORTH_MALLOC_GUARD 
bdf1 cc 39 c4				call z,malloc_error 
bdf4				endif 
bdf4			 
bdf4 eb					ex de, hl      ; save malloc area for string copy 
bdf5 e1					pop hl    ; get back source 
bdf6 c1					pop bc    ; get length of string back 
bdf7			 
bdf7 d5					push de    ; save malloc area for after we push 
bdf8 ed b0				ldir     ; copy substr 
bdfa			 
bdfa			 
bdfa eb					ex de, hl 
bdfb 3e 00				ld a, 0 
bdfd 77					ld (hl), a   ; term substr 
bdfe			 
bdfe					 
bdfe e1					pop hl    ; get malloc so we can push it 
bdff e5					push hl   ; save so we can free it afterwards 
be00			 
be00 cd 29 99				call forth_push_str 
be03			 
be03 e1					pop hl 
be04 cd 4c 90				call free 
be07			 
be07					 
be07					 
be07			 
be07			 
be07					NEXTW 
be07 c3 24 9c			jp macro_next 
be0a				endm 
# End of macro NEXTW
be0a			 
be0a			.LEFT: 
be0a				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
be0a 48				db WORD_SYS_CORE+52             
be0b 32 be			dw .RIGHT            
be0d 05				db 4 + 1 
be0e .. 00			db "LEFT",0              
be13				endm 
# End of macro CWHEAD
be13			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
be13					if DEBUG_FORTH_WORDS_KEY 
be13						DMARK "LEF" 
be13 f5				push af  
be14 3a 28 be			ld a, (.dmark)  
be17 32 c0 ee			ld (debug_mark),a  
be1a 3a 29 be			ld a, (.dmark+1)  
be1d 32 c1 ee			ld (debug_mark+1),a  
be20 3a 2a be			ld a, (.dmark+2)  
be23 32 c2 ee			ld (debug_mark+2),a  
be26 18 03			jr .pastdmark  
be28 ..			.dmark: db "LEF"  
be2b f1			.pastdmark: pop af  
be2c			endm  
# End of macro DMARK
be2c						CALLMONITOR 
be2c cd 2e 93			call break_point_state  
be2f				endm  
# End of macro CALLMONITOR
be2f					endif 
be2f			 
be2f					NEXTW 
be2f c3 24 9c			jp macro_next 
be32				endm 
# End of macro NEXTW
be32			.RIGHT: 
be32				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
be32 48				db WORD_SYS_CORE+52             
be33 5b be			dw .STR2NUM            
be35 06				db 5 + 1 
be36 .. 00			db "RIGHT",0              
be3c				endm 
# End of macro CWHEAD
be3c			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
be3c					if DEBUG_FORTH_WORDS_KEY 
be3c						DMARK "RIG" 
be3c f5				push af  
be3d 3a 51 be			ld a, (.dmark)  
be40 32 c0 ee			ld (debug_mark),a  
be43 3a 52 be			ld a, (.dmark+1)  
be46 32 c1 ee			ld (debug_mark+1),a  
be49 3a 53 be			ld a, (.dmark+2)  
be4c 32 c2 ee			ld (debug_mark+2),a  
be4f 18 03			jr .pastdmark  
be51 ..			.dmark: db "RIG"  
be54 f1			.pastdmark: pop af  
be55			endm  
# End of macro DMARK
be55						CALLMONITOR 
be55 cd 2e 93			call break_point_state  
be58				endm  
# End of macro CALLMONITOR
be58					endif 
be58			 
be58					NEXTW 
be58 c3 24 9c			jp macro_next 
be5b				endm 
# End of macro NEXTW
be5b			 
be5b			 
be5b			.STR2NUM: 
be5b				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
be5b 48				db WORD_SYS_CORE+52             
be5c e7 be			dw .NUM2STR            
be5e 08				db 7 + 1 
be5f .. 00			db "STR2NUM",0              
be67				endm 
# End of macro CWHEAD
be67			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
be67			 
be67			 
be67			; TODO STR type check to do 
be67					if DEBUG_FORTH_WORDS_KEY 
be67						DMARK "S2N" 
be67 f5				push af  
be68 3a 7c be			ld a, (.dmark)  
be6b 32 c0 ee			ld (debug_mark),a  
be6e 3a 7d be			ld a, (.dmark+1)  
be71 32 c1 ee			ld (debug_mark+1),a  
be74 3a 7e be			ld a, (.dmark+2)  
be77 32 c2 ee			ld (debug_mark+2),a  
be7a 18 03			jr .pastdmark  
be7c ..			.dmark: db "S2N"  
be7f f1			.pastdmark: pop af  
be80			endm  
# End of macro DMARK
be80						CALLMONITOR 
be80 cd 2e 93			call break_point_state  
be83				endm  
# End of macro CALLMONITOR
be83					endif 
be83			 
be83					;FORTH_DSP 
be83					FORTH_DSP_VALUE 
be83 cd 9b 9a			call macro_forth_dsp_value 
be86				endm 
# End of macro FORTH_DSP_VALUE
be86					;inc hl 
be86			 
be86 eb					ex de, hl 
be87					if DEBUG_FORTH_WORDS 
be87						DMARK "S2a" 
be87 f5				push af  
be88 3a 9c be			ld a, (.dmark)  
be8b 32 c0 ee			ld (debug_mark),a  
be8e 3a 9d be			ld a, (.dmark+1)  
be91 32 c1 ee			ld (debug_mark+1),a  
be94 3a 9e be			ld a, (.dmark+2)  
be97 32 c2 ee			ld (debug_mark+2),a  
be9a 18 03			jr .pastdmark  
be9c ..			.dmark: db "S2a"  
be9f f1			.pastdmark: pop af  
bea0			endm  
# End of macro DMARK
bea0						CALLMONITOR 
bea0 cd 2e 93			call break_point_state  
bea3				endm  
# End of macro CALLMONITOR
bea3					endif 
bea3 cd b0 8e				call string_to_uint16 
bea6			 
bea6					if DEBUG_FORTH_WORDS 
bea6						DMARK "S2b" 
bea6 f5				push af  
bea7 3a bb be			ld a, (.dmark)  
beaa 32 c0 ee			ld (debug_mark),a  
bead 3a bc be			ld a, (.dmark+1)  
beb0 32 c1 ee			ld (debug_mark+1),a  
beb3 3a bd be			ld a, (.dmark+2)  
beb6 32 c2 ee			ld (debug_mark+2),a  
beb9 18 03			jr .pastdmark  
bebb ..			.dmark: db "S2b"  
bebe f1			.pastdmark: pop af  
bebf			endm  
# End of macro DMARK
bebf						CALLMONITOR 
bebf cd 2e 93			call break_point_state  
bec2				endm  
# End of macro CALLMONITOR
bec2					endif 
bec2			;		push hl 
bec2					FORTH_DSP_POP 
bec2 cd 6a 9b			call macro_forth_dsp_pop 
bec5				endm 
# End of macro FORTH_DSP_POP
bec5			;		pop hl 
bec5					 
bec5					if DEBUG_FORTH_WORDS 
bec5						DMARK "S2b" 
bec5 f5				push af  
bec6 3a da be			ld a, (.dmark)  
bec9 32 c0 ee			ld (debug_mark),a  
becc 3a db be			ld a, (.dmark+1)  
becf 32 c1 ee			ld (debug_mark+1),a  
bed2 3a dc be			ld a, (.dmark+2)  
bed5 32 c2 ee			ld (debug_mark+2),a  
bed8 18 03			jr .pastdmark  
beda ..			.dmark: db "S2b"  
bedd f1			.pastdmark: pop af  
bede			endm  
# End of macro DMARK
bede						CALLMONITOR 
bede cd 2e 93			call break_point_state  
bee1				endm  
# End of macro CALLMONITOR
bee1					endif 
bee1 cd bb 98				call forth_push_numhl	 
bee4			 
bee4				 
bee4				       NEXTW 
bee4 c3 24 9c			jp macro_next 
bee7				endm 
# End of macro NEXTW
bee7			.NUM2STR: 
bee7				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
bee7 48				db WORD_SYS_CORE+52             
bee8 f6 be			dw .CONCAT            
beea 08				db 7 + 1 
beeb .. 00			db "NUM2STR",0              
bef3				endm 
# End of macro CWHEAD
bef3			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
bef3			 
bef3			;		; malloc a string to target 
bef3			;		ld hl, 10     ; TODO max string size should be fine 
bef3			;		call malloc 
bef3			;		push hl    ; save malloc location 
bef3			; 
bef3			; 
bef3			;; TODO check int type 
bef3			;		FORTH_DSP_VALUEHL 
bef3			;		ld a, l 
bef3			;		call DispAToASCII   
bef3			;;TODO need to chage above call to dump into string 
bef3			; 
bef3			; 
bef3			 
bef3				       NEXTW 
bef3 c3 24 9c			jp macro_next 
bef6				endm 
# End of macro NEXTW
bef6			 
bef6			.CONCAT: 
bef6				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
bef6 48				db WORD_SYS_CORE+52             
bef7 a9 bf			dw .FIND            
bef9 07				db 6 + 1 
befa .. 00			db "CONCAT",0              
bf01				endm 
# End of macro CWHEAD
bf01			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
bf01			 
bf01			; TODO check string type 
bf01			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
bf01			 
bf01					if DEBUG_FORTH_WORDS_KEY 
bf01						DMARK "CON" 
bf01 f5				push af  
bf02 3a 16 bf			ld a, (.dmark)  
bf05 32 c0 ee			ld (debug_mark),a  
bf08 3a 17 bf			ld a, (.dmark+1)  
bf0b 32 c1 ee			ld (debug_mark+1),a  
bf0e 3a 18 bf			ld a, (.dmark+2)  
bf11 32 c2 ee			ld (debug_mark+2),a  
bf14 18 03			jr .pastdmark  
bf16 ..			.dmark: db "CON"  
bf19 f1			.pastdmark: pop af  
bf1a			endm  
# End of macro DMARK
bf1a						CALLMONITOR 
bf1a cd 2e 93			call break_point_state  
bf1d				endm  
# End of macro CALLMONITOR
bf1d					endif 
bf1d			 
bf1d			 
bf1d					FORTH_DSP_VALUE 
bf1d cd 9b 9a			call macro_forth_dsp_value 
bf20				endm 
# End of macro FORTH_DSP_VALUE
bf20 e5					push hl   ; s2 
bf21			 
bf21					FORTH_DSP_POP 
bf21 cd 6a 9b			call macro_forth_dsp_pop 
bf24				endm 
# End of macro FORTH_DSP_POP
bf24			 
bf24					FORTH_DSP_VALUE 
bf24 cd 9b 9a			call macro_forth_dsp_value 
bf27				endm 
# End of macro FORTH_DSP_VALUE
bf27			 
bf27 e5					push hl   ; s1 
bf28			 
bf28					FORTH_DSP_POP 
bf28 cd 6a 9b			call macro_forth_dsp_pop 
bf2b				endm 
# End of macro FORTH_DSP_POP
bf2b					 
bf2b			 
bf2b					; copy s1 
bf2b			 
bf2b				 
bf2b					; save ptr 
bf2b e1					pop hl  
bf2c e5					push hl 
bf2d 3e 00				ld a, 0 
bf2f cd 24 8f				call strlent 
bf32					;inc hl    ; zer0 
bf32 06 00				ld b, 0 
bf34 4d					ld c, l 
bf35 e1					pop hl		 
bf36 11 e6 e4				ld de, scratch	 
bf39					if DEBUG_FORTH_WORDS 
bf39						DMARK "CO1" 
bf39 f5				push af  
bf3a 3a 4e bf			ld a, (.dmark)  
bf3d 32 c0 ee			ld (debug_mark),a  
bf40 3a 4f bf			ld a, (.dmark+1)  
bf43 32 c1 ee			ld (debug_mark+1),a  
bf46 3a 50 bf			ld a, (.dmark+2)  
bf49 32 c2 ee			ld (debug_mark+2),a  
bf4c 18 03			jr .pastdmark  
bf4e ..			.dmark: db "CO1"  
bf51 f1			.pastdmark: pop af  
bf52			endm  
# End of macro DMARK
bf52						CALLMONITOR 
bf52 cd 2e 93			call break_point_state  
bf55				endm  
# End of macro CALLMONITOR
bf55					endif 
bf55 ed b0				ldir 
bf57			 
bf57 e1					pop hl 
bf58 e5					push hl 
bf59 d5					push de 
bf5a			 
bf5a			 
bf5a 3e 00				ld a, 0 
bf5c cd 24 8f				call strlent 
bf5f 23					inc hl    ; zer0 
bf60 23					inc hl 
bf61 06 00				ld b, 0 
bf63 4d					ld c, l 
bf64 d1					pop de 
bf65 e1					pop hl		 
bf66					if DEBUG_FORTH_WORDS 
bf66						DMARK "CO2" 
bf66 f5				push af  
bf67 3a 7b bf			ld a, (.dmark)  
bf6a 32 c0 ee			ld (debug_mark),a  
bf6d 3a 7c bf			ld a, (.dmark+1)  
bf70 32 c1 ee			ld (debug_mark+1),a  
bf73 3a 7d bf			ld a, (.dmark+2)  
bf76 32 c2 ee			ld (debug_mark+2),a  
bf79 18 03			jr .pastdmark  
bf7b ..			.dmark: db "CO2"  
bf7e f1			.pastdmark: pop af  
bf7f			endm  
# End of macro DMARK
bf7f						CALLMONITOR 
bf7f cd 2e 93			call break_point_state  
bf82				endm  
# End of macro CALLMONITOR
bf82					endif 
bf82 ed b0				ldir 
bf84			 
bf84			 
bf84			 
bf84 21 e6 e4				ld hl, scratch 
bf87					if DEBUG_FORTH_WORDS 
bf87						DMARK "CO5" 
bf87 f5				push af  
bf88 3a 9c bf			ld a, (.dmark)  
bf8b 32 c0 ee			ld (debug_mark),a  
bf8e 3a 9d bf			ld a, (.dmark+1)  
bf91 32 c1 ee			ld (debug_mark+1),a  
bf94 3a 9e bf			ld a, (.dmark+2)  
bf97 32 c2 ee			ld (debug_mark+2),a  
bf9a 18 03			jr .pastdmark  
bf9c ..			.dmark: db "CO5"  
bf9f f1			.pastdmark: pop af  
bfa0			endm  
# End of macro DMARK
bfa0						CALLMONITOR 
bfa0 cd 2e 93			call break_point_state  
bfa3				endm  
# End of macro CALLMONITOR
bfa3					endif 
bfa3			 
bfa3 cd 29 99				call forth_push_str 
bfa6			 
bfa6			 
bfa6			 
bfa6			 
bfa6				       NEXTW 
bfa6 c3 24 9c			jp macro_next 
bfa9				endm 
# End of macro NEXTW
bfa9			 
bfa9			 
bfa9			.FIND: 
bfa9				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
bfa9 4b				db WORD_SYS_CORE+55             
bfaa 67 c0			dw .LEN            
bfac 05				db 4 + 1 
bfad .. 00			db "FIND",0              
bfb2				endm 
# End of macro CWHEAD
bfb2			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
bfb2			 
bfb2					if DEBUG_FORTH_WORDS_KEY 
bfb2						DMARK "FND" 
bfb2 f5				push af  
bfb3 3a c7 bf			ld a, (.dmark)  
bfb6 32 c0 ee			ld (debug_mark),a  
bfb9 3a c8 bf			ld a, (.dmark+1)  
bfbc 32 c1 ee			ld (debug_mark+1),a  
bfbf 3a c9 bf			ld a, (.dmark+2)  
bfc2 32 c2 ee			ld (debug_mark+2),a  
bfc5 18 03			jr .pastdmark  
bfc7 ..			.dmark: db "FND"  
bfca f1			.pastdmark: pop af  
bfcb			endm  
# End of macro DMARK
bfcb						CALLMONITOR 
bfcb cd 2e 93			call break_point_state  
bfce				endm  
# End of macro CALLMONITOR
bfce					endif 
bfce			 
bfce			; TODO check string type 
bfce					FORTH_DSP_VALUE 
bfce cd 9b 9a			call macro_forth_dsp_value 
bfd1				endm 
# End of macro FORTH_DSP_VALUE
bfd1			 
bfd1 e5					push hl    
bfd2 7e					ld a,(hl)    ; char to find   
bfd3			; TODO change char to substr 
bfd3			 
bfd3 f5					push af 
bfd4					 
bfd4			 
bfd4			 
bfd4					if DEBUG_FORTH_WORDS 
bfd4						DMARK "FN1" 
bfd4 f5				push af  
bfd5 3a e9 bf			ld a, (.dmark)  
bfd8 32 c0 ee			ld (debug_mark),a  
bfdb 3a ea bf			ld a, (.dmark+1)  
bfde 32 c1 ee			ld (debug_mark+1),a  
bfe1 3a eb bf			ld a, (.dmark+2)  
bfe4 32 c2 ee			ld (debug_mark+2),a  
bfe7 18 03			jr .pastdmark  
bfe9 ..			.dmark: db "FN1"  
bfec f1			.pastdmark: pop af  
bfed			endm  
# End of macro DMARK
bfed						CALLMONITOR 
bfed cd 2e 93			call break_point_state  
bff0				endm  
# End of macro CALLMONITOR
bff0					endif 
bff0			 
bff0					FORTH_DSP_POP 
bff0 cd 6a 9b			call macro_forth_dsp_pop 
bff3				endm 
# End of macro FORTH_DSP_POP
bff3			 
bff3					; string to search 
bff3			 
bff3					FORTH_DSP_VALUE 
bff3 cd 9b 9a			call macro_forth_dsp_value 
bff6				endm 
# End of macro FORTH_DSP_VALUE
bff6			 
bff6 d1					pop de  ; d is char to find  
bff7			 
bff7					if DEBUG_FORTH_WORDS 
bff7						DMARK "FN2" 
bff7 f5				push af  
bff8 3a 0c c0			ld a, (.dmark)  
bffb 32 c0 ee			ld (debug_mark),a  
bffe 3a 0d c0			ld a, (.dmark+1)  
c001 32 c1 ee			ld (debug_mark+1),a  
c004 3a 0e c0			ld a, (.dmark+2)  
c007 32 c2 ee			ld (debug_mark+2),a  
c00a 18 03			jr .pastdmark  
c00c ..			.dmark: db "FN2"  
c00f f1			.pastdmark: pop af  
c010			endm  
# End of macro DMARK
c010						CALLMONITOR 
c010 cd 2e 93			call break_point_state  
c013				endm  
# End of macro CALLMONITOR
c013					endif 
c013					 
c013 01 00 00				ld bc, 0 
c016 7e			.findchar:      ld a,(hl) 
c017 fe 00				cp 0   		 
c019 28 27				jr z, .finddone     
c01b ba					cp d 
c01c 28 20				jr z, .foundchar 
c01e 03					inc bc 
c01f 23					inc hl 
c020					if DEBUG_FORTH_WORDS 
c020						DMARK "FN3" 
c020 f5				push af  
c021 3a 35 c0			ld a, (.dmark)  
c024 32 c0 ee			ld (debug_mark),a  
c027 3a 36 c0			ld a, (.dmark+1)  
c02a 32 c1 ee			ld (debug_mark+1),a  
c02d 3a 37 c0			ld a, (.dmark+2)  
c030 32 c2 ee			ld (debug_mark+2),a  
c033 18 03			jr .pastdmark  
c035 ..			.dmark: db "FN3"  
c038 f1			.pastdmark: pop af  
c039			endm  
# End of macro DMARK
c039						CALLMONITOR 
c039 cd 2e 93			call break_point_state  
c03c				endm  
# End of macro CALLMONITOR
c03c					endif 
c03c 18 d8				jr .findchar 
c03e			 
c03e			 
c03e c5			.foundchar:	push bc 
c03f e1					pop hl 
c040 18 03				jr .findexit 
c042			 
c042			 
c042							 
c042			 
c042			.finddone:     ; got to end of string with no find 
c042 21 00 00				ld hl, 0 
c045			.findexit: 
c045			 
c045					if DEBUG_FORTH_WORDS 
c045						DMARK "FNd" 
c045 f5				push af  
c046 3a 5a c0			ld a, (.dmark)  
c049 32 c0 ee			ld (debug_mark),a  
c04c 3a 5b c0			ld a, (.dmark+1)  
c04f 32 c1 ee			ld (debug_mark+1),a  
c052 3a 5c c0			ld a, (.dmark+2)  
c055 32 c2 ee			ld (debug_mark+2),a  
c058 18 03			jr .pastdmark  
c05a ..			.dmark: db "FNd"  
c05d f1			.pastdmark: pop af  
c05e			endm  
# End of macro DMARK
c05e						CALLMONITOR 
c05e cd 2e 93			call break_point_state  
c061				endm  
# End of macro CALLMONITOR
c061					endif 
c061 cd bb 98			call forth_push_numhl 
c064			 
c064				       NEXTW 
c064 c3 24 9c			jp macro_next 
c067				endm 
# End of macro NEXTW
c067			 
c067			.LEN: 
c067				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
c067 4c				db WORD_SYS_CORE+56             
c068 9c c0			dw .CHAR            
c06a 06				db 5 + 1 
c06b .. 00			db "COUNT",0              
c071				endm 
# End of macro CWHEAD
c071			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
c071			 
c071					if DEBUG_FORTH_WORDS_KEY 
c071						DMARK "CNT" 
c071 f5				push af  
c072 3a 86 c0			ld a, (.dmark)  
c075 32 c0 ee			ld (debug_mark),a  
c078 3a 87 c0			ld a, (.dmark+1)  
c07b 32 c1 ee			ld (debug_mark+1),a  
c07e 3a 88 c0			ld a, (.dmark+2)  
c081 32 c2 ee			ld (debug_mark+2),a  
c084 18 03			jr .pastdmark  
c086 ..			.dmark: db "CNT"  
c089 f1			.pastdmark: pop af  
c08a			endm  
# End of macro DMARK
c08a						CALLMONITOR 
c08a cd 2e 93			call break_point_state  
c08d				endm  
# End of macro CALLMONITOR
c08d					endif 
c08d			; TODO check string type 
c08d					FORTH_DSP 
c08d cd 78 9a			call macro_forth_dsp 
c090				endm 
# End of macro FORTH_DSP
c090					;v5FORTH_DSP_VALUE 
c090			 
c090 23					inc hl 
c091			 
c091 3e 00				ld a, 0 
c093 cd 24 8f				call strlent 
c096			 
c096 cd bb 98				call forth_push_numhl 
c099			 
c099			 
c099			 
c099				       NEXTW 
c099 c3 24 9c			jp macro_next 
c09c				endm 
# End of macro NEXTW
c09c			.CHAR: 
c09c				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
c09c 4d				db WORD_SYS_CORE+57             
c09d d2 c0			dw .ENDSTR            
c09f 05				db 4 + 1 
c0a0 .. 00			db "CHAR",0              
c0a5				endm 
# End of macro CWHEAD
c0a5			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c0a5					if DEBUG_FORTH_WORDS_KEY 
c0a5						DMARK "CHR" 
c0a5 f5				push af  
c0a6 3a ba c0			ld a, (.dmark)  
c0a9 32 c0 ee			ld (debug_mark),a  
c0ac 3a bb c0			ld a, (.dmark+1)  
c0af 32 c1 ee			ld (debug_mark+1),a  
c0b2 3a bc c0			ld a, (.dmark+2)  
c0b5 32 c2 ee			ld (debug_mark+2),a  
c0b8 18 03			jr .pastdmark  
c0ba ..			.dmark: db "CHR"  
c0bd f1			.pastdmark: pop af  
c0be			endm  
# End of macro DMARK
c0be						CALLMONITOR 
c0be cd 2e 93			call break_point_state  
c0c1				endm  
# End of macro CALLMONITOR
c0c1					endif 
c0c1					FORTH_DSP 
c0c1 cd 78 9a			call macro_forth_dsp 
c0c4				endm 
# End of macro FORTH_DSP
c0c4					;v5 FORTH_DSP_VALUE 
c0c4 23					inc hl      ; now at start of numeric as string 
c0c5			 
c0c5			;		push hl 
c0c5			 
c0c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c0c5 cd 6a 9b			call macro_forth_dsp_pop 
c0c8				endm 
# End of macro FORTH_DSP_POP
c0c8			 
c0c8			;		pop hl 
c0c8			 
c0c8					; push the content of a onto the stack as a value 
c0c8			 
c0c8 7e					ld a,(hl)   ; get char 
c0c9 26 00				ld h,0 
c0cb 6f					ld l,a 
c0cc cd bb 98				call forth_push_numhl 
c0cf			 
c0cf				       NEXTW 
c0cf c3 24 9c			jp macro_next 
c0d2				endm 
# End of macro NEXTW
c0d2			 
c0d2			 
c0d2			 
c0d2			 
c0d2			.ENDSTR: 
c0d2			; eof 
c0d2			 
# End of file forth_words_str.asm
c0d2			include "forth_words_key.asm" 
c0d2			 
c0d2			; | ## Keyboard Words 
c0d2			 
c0d2			.KEY: 
c0d2				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c0d2 3e				db WORD_SYS_CORE+42             
c0d3 02 c1			dw .WAITK            
c0d5 04				db 3 + 1 
c0d6 .. 00			db "KEY",0              
c0da				endm 
# End of macro CWHEAD
c0da			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c0da			 
c0da					if DEBUG_FORTH_WORDS_KEY 
c0da						DMARK "KEY" 
c0da f5				push af  
c0db 3a ef c0			ld a, (.dmark)  
c0de 32 c0 ee			ld (debug_mark),a  
c0e1 3a f0 c0			ld a, (.dmark+1)  
c0e4 32 c1 ee			ld (debug_mark+1),a  
c0e7 3a f1 c0			ld a, (.dmark+2)  
c0ea 32 c2 ee			ld (debug_mark+2),a  
c0ed 18 03			jr .pastdmark  
c0ef ..			.dmark: db "KEY"  
c0f2 f1			.pastdmark: pop af  
c0f3			endm  
# End of macro DMARK
c0f3						CALLMONITOR 
c0f3 cd 2e 93			call break_point_state  
c0f6				endm  
# End of macro CALLMONITOR
c0f6					endif 
c0f6			; TODO currently waits 
c0f6 cd 75 d7				call cin 
c0f9					;call cin_wait 
c0f9 6f					ld l, a 
c0fa 26 00				ld h, 0 
c0fc cd bb 98				call forth_push_numhl 
c0ff					NEXTW 
c0ff c3 24 9c			jp macro_next 
c102				endm 
# End of macro NEXTW
c102			.WAITK: 
c102				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c102 3f				db WORD_SYS_CORE+43             
c103 34 c1			dw .ACCEPT            
c105 06				db 5 + 1 
c106 .. 00			db "WAITK",0              
c10c				endm 
# End of macro CWHEAD
c10c			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c10c					if DEBUG_FORTH_WORDS_KEY 
c10c						DMARK "WAI" 
c10c f5				push af  
c10d 3a 21 c1			ld a, (.dmark)  
c110 32 c0 ee			ld (debug_mark),a  
c113 3a 22 c1			ld a, (.dmark+1)  
c116 32 c1 ee			ld (debug_mark+1),a  
c119 3a 23 c1			ld a, (.dmark+2)  
c11c 32 c2 ee			ld (debug_mark+2),a  
c11f 18 03			jr .pastdmark  
c121 ..			.dmark: db "WAI"  
c124 f1			.pastdmark: pop af  
c125			endm  
# End of macro DMARK
c125						CALLMONITOR 
c125 cd 2e 93			call break_point_state  
c128				endm  
# End of macro CALLMONITOR
c128					endif 
c128 cd 6f d7				call cin_wait 
c12b 6f					ld l, a 
c12c 26 00				ld h, 0 
c12e cd bb 98				call forth_push_numhl 
c131					NEXTW 
c131 c3 24 9c			jp macro_next 
c134				endm 
# End of macro NEXTW
c134			.ACCEPT: 
c134				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c134 40				db WORD_SYS_CORE+44             
c135 92 c1			dw .EDIT            
c137 07				db 6 + 1 
c138 .. 00			db "ACCEPT",0              
c13f				endm 
# End of macro CWHEAD
c13f			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c13f					; TODO crashes on push 
c13f					if DEBUG_FORTH_WORDS_KEY 
c13f						DMARK "ACC" 
c13f f5				push af  
c140 3a 54 c1			ld a, (.dmark)  
c143 32 c0 ee			ld (debug_mark),a  
c146 3a 55 c1			ld a, (.dmark+1)  
c149 32 c1 ee			ld (debug_mark+1),a  
c14c 3a 56 c1			ld a, (.dmark+2)  
c14f 32 c2 ee			ld (debug_mark+2),a  
c152 18 03			jr .pastdmark  
c154 ..			.dmark: db "ACC"  
c157 f1			.pastdmark: pop af  
c158			endm  
# End of macro DMARK
c158						CALLMONITOR 
c158 cd 2e 93			call break_point_state  
c15b				endm  
# End of macro CALLMONITOR
c15b					endif 
c15b 21 e4 e6				ld hl, os_input 
c15e 3e 00				ld a, 0 
c160 77					ld (hl),a 
c161 3a cf ec				ld a,(f_cursor_ptr) 
c164 16 64				ld d, 100 
c166 0e 00				ld c, 0 
c168 1e 28				ld e, 40 
c16a cd e8 8a				call input_str 
c16d					; TODO perhaps do a type check and wrap in quotes if not a number 
c16d 21 e4 e6				ld hl, os_input 
c170					if DEBUG_FORTH_WORDS 
c170						DMARK "AC1" 
c170 f5				push af  
c171 3a 85 c1			ld a, (.dmark)  
c174 32 c0 ee			ld (debug_mark),a  
c177 3a 86 c1			ld a, (.dmark+1)  
c17a 32 c1 ee			ld (debug_mark+1),a  
c17d 3a 87 c1			ld a, (.dmark+2)  
c180 32 c2 ee			ld (debug_mark+2),a  
c183 18 03			jr .pastdmark  
c185 ..			.dmark: db "AC1"  
c188 f1			.pastdmark: pop af  
c189			endm  
# End of macro DMARK
c189						CALLMONITOR 
c189 cd 2e 93			call break_point_state  
c18c				endm  
# End of macro CALLMONITOR
c18c					endif 
c18c cd 29 99				call forth_push_str 
c18f					NEXTW 
c18f c3 24 9c			jp macro_next 
c192				endm 
# End of macro NEXTW
c192			 
c192			.EDIT: 
c192				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
c192 40				db WORD_SYS_CORE+44             
c193 34 c2			dw .ENDKEY            
c195 05				db 4 + 1 
c196 .. 00			db "EDIT",0              
c19b				endm 
# End of macro CWHEAD
c19b			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c19b			 
c19b					; TODO does not copy from stack 
c19b					if DEBUG_FORTH_WORDS_KEY 
c19b						DMARK "EDT" 
c19b f5				push af  
c19c 3a b0 c1			ld a, (.dmark)  
c19f 32 c0 ee			ld (debug_mark),a  
c1a2 3a b1 c1			ld a, (.dmark+1)  
c1a5 32 c1 ee			ld (debug_mark+1),a  
c1a8 3a b2 c1			ld a, (.dmark+2)  
c1ab 32 c2 ee			ld (debug_mark+2),a  
c1ae 18 03			jr .pastdmark  
c1b0 ..			.dmark: db "EDT"  
c1b3 f1			.pastdmark: pop af  
c1b4			endm  
# End of macro DMARK
c1b4						CALLMONITOR 
c1b4 cd 2e 93			call break_point_state  
c1b7				endm  
# End of macro CALLMONITOR
c1b7					endif 
c1b7			 
c1b7					;FORTH_DSP 
c1b7					FORTH_DSP_VALUEHL 
c1b7 cd b2 9a			call macro_dsp_valuehl 
c1ba				endm 
# End of macro FORTH_DSP_VALUEHL
c1ba			;		inc hl    ; TODO do type check 
c1ba			 
c1ba			;		call get_word_hl 
c1ba e5					push hl 
c1bb					if DEBUG_FORTH_WORDS 
c1bb						DMARK "EDp" 
c1bb f5				push af  
c1bc 3a d0 c1			ld a, (.dmark)  
c1bf 32 c0 ee			ld (debug_mark),a  
c1c2 3a d1 c1			ld a, (.dmark+1)  
c1c5 32 c1 ee			ld (debug_mark+1),a  
c1c8 3a d2 c1			ld a, (.dmark+2)  
c1cb 32 c2 ee			ld (debug_mark+2),a  
c1ce 18 03			jr .pastdmark  
c1d0 ..			.dmark: db "EDp"  
c1d3 f1			.pastdmark: pop af  
c1d4			endm  
# End of macro DMARK
c1d4						CALLMONITOR 
c1d4 cd 2e 93			call break_point_state  
c1d7				endm  
# End of macro CALLMONITOR
c1d7					endif 
c1d7				;	ld a, 0 
c1d7 cd 19 8f				call strlenz 
c1da 23					inc hl 
c1db			 
c1db 06 00				ld b, 0 
c1dd 4d					ld c, l 
c1de			 
c1de e1					pop hl 
c1df 11 e4 e6				ld de, os_input 
c1e2					if DEBUG_FORTH_WORDS_KEY 
c1e2						DMARK "EDc" 
c1e2 f5				push af  
c1e3 3a f7 c1			ld a, (.dmark)  
c1e6 32 c0 ee			ld (debug_mark),a  
c1e9 3a f8 c1			ld a, (.dmark+1)  
c1ec 32 c1 ee			ld (debug_mark+1),a  
c1ef 3a f9 c1			ld a, (.dmark+2)  
c1f2 32 c2 ee			ld (debug_mark+2),a  
c1f5 18 03			jr .pastdmark  
c1f7 ..			.dmark: db "EDc"  
c1fa f1			.pastdmark: pop af  
c1fb			endm  
# End of macro DMARK
c1fb						CALLMONITOR 
c1fb cd 2e 93			call break_point_state  
c1fe				endm  
# End of macro CALLMONITOR
c1fe					endif 
c1fe ed b0				ldir 
c200			 
c200			 
c200 21 e4 e6				ld hl, os_input 
c203					;ld a, 0 
c203					;ld (hl),a 
c203 3a cf ec				ld a,(f_cursor_ptr) 
c206 16 64				ld d, 100 
c208 0e 00				ld c, 0 
c20a 1e 28				ld e, 40 
c20c cd e8 8a				call input_str 
c20f					; TODO perhaps do a type check and wrap in quotes if not a number 
c20f 21 e4 e6				ld hl, os_input 
c212					if DEBUG_FORTH_WORDS 
c212						DMARK "ED1" 
c212 f5				push af  
c213 3a 27 c2			ld a, (.dmark)  
c216 32 c0 ee			ld (debug_mark),a  
c219 3a 28 c2			ld a, (.dmark+1)  
c21c 32 c1 ee			ld (debug_mark+1),a  
c21f 3a 29 c2			ld a, (.dmark+2)  
c222 32 c2 ee			ld (debug_mark+2),a  
c225 18 03			jr .pastdmark  
c227 ..			.dmark: db "ED1"  
c22a f1			.pastdmark: pop af  
c22b			endm  
# End of macro DMARK
c22b						CALLMONITOR 
c22b cd 2e 93			call break_point_state  
c22e				endm  
# End of macro CALLMONITOR
c22e					endif 
c22e cd 29 99				call forth_push_str 
c231					NEXTW 
c231 c3 24 9c			jp macro_next 
c234				endm 
# End of macro NEXTW
c234			 
c234			 
c234			 
c234			.ENDKEY: 
c234			; eof 
c234			 
# End of file forth_words_key.asm
c234			 
c234			if STORAGE_SE 
c234			   	include "forth_words_storage.asm" 
c234			endif 
c234				include "forth_words_device.asm" 
c234			; Device related words 
c234			 
c234			; | ## Device Words 
c234			 
c234			if SOUND_ENABLE 
c234			.NOTE: 
c234				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c234			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c234					if DEBUG_FORTH_WORDS_KEY 
c234						DMARK "NTE" 
c234						CALLMONITOR 
c234					endif 
c234			 
c234				 
c234			 
c234					NEXTW 
c234			.AFTERSOUND: 
c234			endif 
c234			 
c234			 
c234			USE_GPIO: equ 0 
c234			 
c234			if USE_GPIO 
c234			.GP1: 
c234				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c234			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c234					NEXTW 
c234			.GP2: 
c234				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c234			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c234			 
c234					NEXTW 
c234			 
c234			.GP3: 
c234				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c234			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c234			 
c234					NEXTW 
c234			 
c234			.GP4: 
c234				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c234			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c234			 
c234					NEXTW 
c234			.SIN: 
c234			 
c234			 
c234			endif 
c234			 
c234			 
c234				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c234 33				db WORD_SYS_CORE+31             
c235 69 c2			dw .SOUT            
c237 03				db 2 + 1 
c238 .. 00			db "IN",0              
c23b				endm 
# End of macro CWHEAD
c23b			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c23b					if DEBUG_FORTH_WORDS_KEY 
c23b						DMARK "IN." 
c23b f5				push af  
c23c 3a 50 c2			ld a, (.dmark)  
c23f 32 c0 ee			ld (debug_mark),a  
c242 3a 51 c2			ld a, (.dmark+1)  
c245 32 c1 ee			ld (debug_mark+1),a  
c248 3a 52 c2			ld a, (.dmark+2)  
c24b 32 c2 ee			ld (debug_mark+2),a  
c24e 18 03			jr .pastdmark  
c250 ..			.dmark: db "IN."  
c253 f1			.pastdmark: pop af  
c254			endm  
# End of macro DMARK
c254						CALLMONITOR 
c254 cd 2e 93			call break_point_state  
c257				endm  
# End of macro CALLMONITOR
c257					endif 
c257					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c257 cd b2 9a			call macro_dsp_valuehl 
c25a				endm 
# End of macro FORTH_DSP_VALUEHL
c25a			 
c25a e5					push hl 
c25b			 
c25b					; destroy value TOS 
c25b			 
c25b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c25b cd 6a 9b			call macro_forth_dsp_pop 
c25e				endm 
# End of macro FORTH_DSP_POP
c25e			 
c25e					; one value on hl get other one back 
c25e			 
c25e c1					pop bc 
c25f			 
c25f					; do the sub 
c25f			;		ex de, hl 
c25f			 
c25f ed 68				in l,(c) 
c261			 
c261					; save it 
c261			 
c261 26 00				ld h,0 
c263			 
c263					; TODO push value back onto stack for another op etc 
c263			 
c263 cd bb 98				call forth_push_numhl 
c266					NEXTW 
c266 c3 24 9c			jp macro_next 
c269				endm 
# End of macro NEXTW
c269			.SOUT: 
c269				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c269 34				db WORD_SYS_CORE+32             
c26a bc c2			dw .SPIO            
c26c 04				db 3 + 1 
c26d .. 00			db "OUT",0              
c271				endm 
# End of macro CWHEAD
c271			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c271					if DEBUG_FORTH_WORDS_KEY 
c271						DMARK "OUT" 
c271 f5				push af  
c272 3a 86 c2			ld a, (.dmark)  
c275 32 c0 ee			ld (debug_mark),a  
c278 3a 87 c2			ld a, (.dmark+1)  
c27b 32 c1 ee			ld (debug_mark+1),a  
c27e 3a 88 c2			ld a, (.dmark+2)  
c281 32 c2 ee			ld (debug_mark+2),a  
c284 18 03			jr .pastdmark  
c286 ..			.dmark: db "OUT"  
c289 f1			.pastdmark: pop af  
c28a			endm  
# End of macro DMARK
c28a						CALLMONITOR 
c28a cd 2e 93			call break_point_state  
c28d				endm  
# End of macro CALLMONITOR
c28d					endif 
c28d			 
c28d					; get port 
c28d			 
c28d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c28d cd b2 9a			call macro_dsp_valuehl 
c290				endm 
# End of macro FORTH_DSP_VALUEHL
c290			 
c290 e5					push hl 
c291			 
c291					; destroy value TOS 
c291			 
c291					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c291 cd 6a 9b			call macro_forth_dsp_pop 
c294				endm 
# End of macro FORTH_DSP_POP
c294			 
c294					; get byte to send 
c294			 
c294					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c294 cd b2 9a			call macro_dsp_valuehl 
c297				endm 
# End of macro FORTH_DSP_VALUEHL
c297			 
c297			;		push hl 
c297			 
c297					; destroy value TOS 
c297			 
c297					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c297 cd 6a 9b			call macro_forth_dsp_pop 
c29a				endm 
# End of macro FORTH_DSP_POP
c29a			 
c29a					; one value on hl get other one back 
c29a			 
c29a			;		pop hl 
c29a			 
c29a c1					pop bc 
c29b			 
c29b					if DEBUG_FORTH_WORDS 
c29b						DMARK "OUT" 
c29b f5				push af  
c29c 3a b0 c2			ld a, (.dmark)  
c29f 32 c0 ee			ld (debug_mark),a  
c2a2 3a b1 c2			ld a, (.dmark+1)  
c2a5 32 c1 ee			ld (debug_mark+1),a  
c2a8 3a b2 c2			ld a, (.dmark+2)  
c2ab 32 c2 ee			ld (debug_mark+2),a  
c2ae 18 03			jr .pastdmark  
c2b0 ..			.dmark: db "OUT"  
c2b3 f1			.pastdmark: pop af  
c2b4			endm  
# End of macro DMARK
c2b4						CALLMONITOR 
c2b4 cd 2e 93			call break_point_state  
c2b7				endm  
# End of macro CALLMONITOR
c2b7					endif 
c2b7			 
c2b7 ed 69				out (c), l 
c2b9			 
c2b9					NEXTW 
c2b9 c3 24 9c			jp macro_next 
c2bc				endm 
# End of macro NEXTW
c2bc			 
c2bc			 
c2bc			.SPIO: 
c2bc			 
c2bc			if STORAGE_SE 
c2bc				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c2bc			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c2bc			 
c2bc					call spi_ce_low 
c2bc			    NEXTW 
c2bc			 
c2bc			.SPICEH: 
c2bc				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c2bc			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c2bc			 
c2bc					call spi_ce_high 
c2bc			    NEXTW 
c2bc			 
c2bc			 
c2bc			.SPIOb: 
c2bc			 
c2bc				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c2bc			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c2bc			 
c2bc					; get port 
c2bc			 
c2bc			 
c2bc					; get byte to send 
c2bc			 
c2bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2bc			 
c2bc			;		push hl    ; u1  
c2bc			 
c2bc					; destroy value TOS 
c2bc			 
c2bc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2bc			 
c2bc					; one value on hl get other one back 
c2bc			 
c2bc			;		pop hl   ; u2 - addr 
c2bc			 
c2bc					; TODO Send SPI byte 
c2bc			 
c2bc					ld a, l 
c2bc					call spi_send_byte 
c2bc			 
c2bc					NEXTW 
c2bc			 
c2bc			.SPII: 
c2bc				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c2bc			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c2bc			 
c2bc					; TODO Get SPI byte 
c2bc			 
c2bc					call spi_read_byte 
c2bc			 
c2bc					ld h, 0 
c2bc					ld l, a 
c2bc					call forth_push_numhl 
c2bc			 
c2bc					NEXTW 
c2bc			 
c2bc			 
c2bc			 
c2bc			.SESEL: 
c2bc				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c2bc			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c2bc					if DEBUG_FORTH_WORDS_KEY 
c2bc						DMARK "BNK" 
c2bc						CALLMONITOR 
c2bc					endif 
c2bc			 
c2bc					ld a, 255 
c2bc					ld (spi_cartdev), a 
c2bc			 
c2bc					; get bank 
c2bc			 
c2bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2bc			 
c2bc			;		push hl 
c2bc			 
c2bc					; destroy value TOS 
c2bc			 
c2bc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2bc			 
c2bc					; one value on hl get other one back 
c2bc			 
c2bc			;		pop hl 
c2bc			 
c2bc			 
c2bc					ld c, SPI_CE_HIGH 
c2bc					ld b, '0'    ; human readable bank number 
c2bc			 
c2bc					ld a, l 
c2bc			 
c2bc					if DEBUG_FORTH_WORDS 
c2bc						DMARK "BNK" 
c2bc						CALLMONITOR 
c2bc					endif 
c2bc			 
c2bc					; active low 
c2bc			 
c2bc					cp 0 
c2bc					jr z, .bset 
c2bc					cp 1 
c2bc					jr nz, .b2 
c2bc					res 0, c 
c2bc					ld b, '1'    ; human readable bank number 
c2bc			.b2:		cp 2 
c2bc					jr nz, .b3 
c2bc					res 1, c 
c2bc					ld b, '2'    ; human readable bank number 
c2bc			.b3:		cp 3 
c2bc					jr nz, .b4 
c2bc					res 2, c 
c2bc					ld b, '3'    ; human readable bank number 
c2bc			.b4:		cp 4 
c2bc					jr nz, .b5 
c2bc					res 3, c 
c2bc					ld b, '4'    ; human readable bank number 
c2bc			.b5:		cp 5 
c2bc					jr nz, .bset 
c2bc					res 4, c 
c2bc					ld b, '5'    ; human readable bank number 
c2bc			 
c2bc			.bset: 
c2bc					ld a, c 
c2bc					ld (spi_device),a 
c2bc					ld a, b 
c2bc					ld (spi_device_id),a 
c2bc					if DEBUG_FORTH_WORDS 
c2bc						DMARK "BN2" 
c2bc						CALLMONITOR 
c2bc					endif 
c2bc			 
c2bc					NEXTW 
c2bc			 
c2bc			.CARTDEV: 
c2bc				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c2bc			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c2bc					if DEBUG_FORTH_WORDS_KEY 
c2bc						DMARK "CDV" 
c2bc						CALLMONITOR 
c2bc					endif 
c2bc			 
c2bc					; disable se storage bank selection 
c2bc			 
c2bc					ld a, SPI_CE_HIGH		; ce high 
c2bc					ld (spi_device), a 
c2bc			 
c2bc					; get bank 
c2bc			 
c2bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2bc			 
c2bc			;		push hl 
c2bc			 
c2bc					; destroy value TOS 
c2bc			 
c2bc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2bc			 
c2bc					; one value on hl get other one back 
c2bc			 
c2bc			;		pop hl 
c2bc			 
c2bc					; active low 
c2bc			 
c2bc					ld c, 255 
c2bc			 
c2bc					ld a, l 
c2bc					if DEBUG_FORTH_WORDS 
c2bc						DMARK "CDV" 
c2bc						CALLMONITOR 
c2bc					endif 
c2bc					cp 0 
c2bc					jr z, .cset 
c2bc					cp 1 
c2bc					jr nz, .c2 
c2bc					res 0, c 
c2bc			.c2:		cp 2 
c2bc					jr nz, .c3 
c2bc					res 1, c 
c2bc			.c3:		cp 3 
c2bc					jr nz, .c4 
c2bc					res 2, c 
c2bc			.c4:		cp 4 
c2bc					jr nz, .c5 
c2bc					res 3, c 
c2bc			.c5:		cp 5 
c2bc					jr nz, .c6 
c2bc					res 4, c 
c2bc			.c6:		cp 6 
c2bc					jr nz, .c7 
c2bc					res 5, c 
c2bc			.c7:		cp 7 
c2bc					jr nz, .c8 
c2bc					res 6, c 
c2bc			.c8:		cp 8 
c2bc					jr nz, .cset 
c2bc					res 7, c 
c2bc			.cset:		ld a, c 
c2bc					ld (spi_cartdev),a 
c2bc			 
c2bc					if DEBUG_FORTH_WORDS 
c2bc						DMARK "CD2" 
c2bc						CALLMONITOR 
c2bc					endif 
c2bc					NEXTW 
c2bc			endif 
c2bc			 
c2bc			.ENDDEVICE: 
c2bc			; eof 
c2bc			 
# End of file forth_words_device.asm
c2bc			 
c2bc			; var handler 
c2bc			 
c2bc			 
c2bc			.VARS: 
c2bc				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
c2bc 78				db WORD_SYS_CORE+100             
c2bd d4 c2			dw .V0Q            
c2bf 04				db 3 + 1 
c2c0 .. 00			db "V0!",0              
c2c4				endm 
# End of macro CWHEAD
c2c4			;| V0! ( u1 -- )  Store value to v0  | DONE 
c2c4			 
c2c4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2c4 cd b2 9a			call macro_dsp_valuehl 
c2c7				endm 
# End of macro FORTH_DSP_VALUEHL
c2c7			 
c2c7 11 99 ec				ld de, cli_var_array 
c2ca			 
c2ca eb					ex de, hl 
c2cb 73					ld (hl), e 
c2cc 23					inc hl 
c2cd 72					ld (hl), d 
c2ce			 
c2ce					; destroy value TOS 
c2ce			 
c2ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2ce cd 6a 9b			call macro_forth_dsp_pop 
c2d1				endm 
# End of macro FORTH_DSP_POP
c2d1			 
c2d1				       NEXTW 
c2d1 c3 24 9c			jp macro_next 
c2d4				endm 
# End of macro NEXTW
c2d4			.V0Q: 
c2d4				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c2d4 79				db WORD_SYS_CORE+101             
c2d5 e5 c2			dw .V1S            
c2d7 04				db 3 + 1 
c2d8 .. 00			db "V0@",0              
c2dc				endm 
# End of macro CWHEAD
c2dc			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c2dc 2a 99 ec				ld hl, (cli_var_array) 
c2df cd bb 98				call forth_push_numhl 
c2e2			 
c2e2				       NEXTW 
c2e2 c3 24 9c			jp macro_next 
c2e5				endm 
# End of macro NEXTW
c2e5			.V1S: 
c2e5				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c2e5 7a				db WORD_SYS_CORE+102             
c2e6 fd c2			dw .V1Q            
c2e8 04				db 3 + 1 
c2e9 .. 00			db "V1!",0              
c2ed				endm 
# End of macro CWHEAD
c2ed			;| V1! ( u1 -- )  Store value to v1 | DONE 
c2ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2ed cd b2 9a			call macro_dsp_valuehl 
c2f0				endm 
# End of macro FORTH_DSP_VALUEHL
c2f0			 
c2f0 11 9b ec				ld de, cli_var_array+2 
c2f3				 
c2f3 eb					ex de, hl 
c2f4 73					ld (hl), e 
c2f5 23					inc hl 
c2f6 72					ld (hl), d 
c2f7			 
c2f7					; destroy value TOS 
c2f7			 
c2f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2f7 cd 6a 9b			call macro_forth_dsp_pop 
c2fa				endm 
# End of macro FORTH_DSP_POP
c2fa				       NEXTW 
c2fa c3 24 9c			jp macro_next 
c2fd				endm 
# End of macro NEXTW
c2fd			.V1Q: 
c2fd				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c2fd 7b				db WORD_SYS_CORE+103             
c2fe 0e c3			dw .V2S            
c300 04				db 3 + 1 
c301 .. 00			db "V1@",0              
c305				endm 
# End of macro CWHEAD
c305			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c305 2a 9b ec				ld hl, (cli_var_array+2) 
c308 cd bb 98				call forth_push_numhl 
c30b				       NEXTW 
c30b c3 24 9c			jp macro_next 
c30e				endm 
# End of macro NEXTW
c30e			.V2S: 
c30e				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c30e 7c				db WORD_SYS_CORE+104             
c30f 26 c3			dw .V2Q            
c311 04				db 3 + 1 
c312 .. 00			db "V2!",0              
c316				endm 
# End of macro CWHEAD
c316			;| V2! ( u1 -- )  Store value to v2 | DONE 
c316					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c316 cd b2 9a			call macro_dsp_valuehl 
c319				endm 
# End of macro FORTH_DSP_VALUEHL
c319			 
c319 11 9d ec				ld de, cli_var_array+4 
c31c				 
c31c eb					ex de, hl 
c31d 73					ld (hl), e 
c31e 23					inc hl 
c31f 72					ld (hl), d 
c320			 
c320					; destroy value TOS 
c320			 
c320					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c320 cd 6a 9b			call macro_forth_dsp_pop 
c323				endm 
# End of macro FORTH_DSP_POP
c323				       NEXTW 
c323 c3 24 9c			jp macro_next 
c326				endm 
# End of macro NEXTW
c326			.V2Q: 
c326				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c326 7d				db WORD_SYS_CORE+105             
c327 37 c3			dw .V3S            
c329 04				db 3 + 1 
c32a .. 00			db "V2@",0              
c32e				endm 
# End of macro CWHEAD
c32e			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c32e 2a 9d ec				ld hl, (cli_var_array+4) 
c331 cd bb 98				call forth_push_numhl 
c334				       NEXTW 
c334 c3 24 9c			jp macro_next 
c337				endm 
# End of macro NEXTW
c337			.V3S: 
c337				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c337 7c				db WORD_SYS_CORE+104             
c338 4f c3			dw .V3Q            
c33a 04				db 3 + 1 
c33b .. 00			db "V3!",0              
c33f				endm 
# End of macro CWHEAD
c33f			;| V3! ( u1 -- )  Store value to v3 | DONE 
c33f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c33f cd b2 9a			call macro_dsp_valuehl 
c342				endm 
# End of macro FORTH_DSP_VALUEHL
c342			 
c342 11 9f ec				ld de, cli_var_array+6 
c345				 
c345 eb					ex de, hl 
c346 73					ld (hl), e 
c347 23					inc hl 
c348 72					ld (hl), d 
c349			 
c349					; destroy value TOS 
c349			 
c349					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c349 cd 6a 9b			call macro_forth_dsp_pop 
c34c				endm 
# End of macro FORTH_DSP_POP
c34c				       NEXTW 
c34c c3 24 9c			jp macro_next 
c34f				endm 
# End of macro NEXTW
c34f			.V3Q: 
c34f				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c34f 7d				db WORD_SYS_CORE+105             
c350 60 c3			dw .END            
c352 04				db 3 + 1 
c353 .. 00			db "V3@",0              
c357				endm 
# End of macro CWHEAD
c357			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c357 2a 9f ec				ld hl, (cli_var_array+6) 
c35a cd bb 98				call forth_push_numhl 
c35d				       NEXTW 
c35d c3 24 9c			jp macro_next 
c360				endm 
# End of macro NEXTW
c360			 
c360			 
c360			 
c360			 
c360			 
c360			; end of dict marker 
c360			 
c360 00			.END:    db WORD_SYS_END 
c361 00 00			dw 0 
c363 00				db 0 
c364			 
c364			; use to jp here for user dict words to save on macro expansion  
c364			 
c364			user_dict_next: 
c364				NEXTW 
c364 c3 24 9c			jp macro_next 
c367				endm 
# End of macro NEXTW
c367			 
c367			 
c367			user_exec: 
c367				;    ld hl, <word code> 
c367				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c367				;    call forthexec 
c367				;    jp user_dict_next   (NEXT) 
c367			        ;    <word code bytes> 
c367 eb				ex de, hl 
c368 2a e7 e7			ld hl,(os_tok_ptr) 
c36b				 
c36b				FORTH_RSP_NEXT 
c36b cd 62 98			call macro_forth_rsp_next 
c36e				endm 
# End of macro FORTH_RSP_NEXT
c36e			 
c36e			if DEBUG_FORTH_UWORD 
c36e						DMARK "UEX" 
c36e f5				push af  
c36f 3a 83 c3			ld a, (.dmark)  
c372 32 c0 ee			ld (debug_mark),a  
c375 3a 84 c3			ld a, (.dmark+1)  
c378 32 c1 ee			ld (debug_mark+1),a  
c37b 3a 85 c3			ld a, (.dmark+2)  
c37e 32 c2 ee			ld (debug_mark+2),a  
c381 18 03			jr .pastdmark  
c383 ..			.dmark: db "UEX"  
c386 f1			.pastdmark: pop af  
c387			endm  
# End of macro DMARK
c387				CALLMONITOR 
c387 cd 2e 93			call break_point_state  
c38a				endm  
# End of macro CALLMONITOR
c38a			endif 
c38a			 
c38a			 
c38a			 
c38a eb				ex de, hl 
c38b 22 e7 e7			ld (os_tok_ptr), hl 
c38e				 
c38e				; Don't use next - Skips the first word in uword. 
c38e			 
c38e c3 b5 9c			jp exec1 
c391			;	NEXT 
c391			 
c391			 
c391			; eof 
# End of file forth_wordsv4.asm
c391			endif 
c391			;;;;;;;;;;;;;; Debug code 
c391			 
c391			 
c391			;if DEBUG_FORTH_PARSE 
c391 .. 00		.nowordfound: db "No match",0 
c39a .. 00		.compword:	db "Comparing word ",0 
c3aa .. 00		.nextwordat:	db "Next word at",0 
c3b7 .. 00		.charmatch:	db "Char match",0 
c3c2			;endif 
c3c2			if DEBUG_FORTH_JP 
c3c2			.foundword:	db "Word match. Exec..",0 
c3c2			endif 
c3c2			;if DEBUG_FORTH_PUSH 
c3c2 .. 00		.enddict:	db "Dict end. Push.",0 
c3d2 .. 00		.push_str:	db "Pushing string",0 
c3e1 .. 00		.push_num:	db "Pushing number",0 
c3f0 .. 00		.data_sp:	db "SP:",0 
c3f4 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c406 .. 00		.wordinde:	db "Word in DE (3/0):",0 
c418 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c42a			;endif 
c42a			;if DEBUG_FORTH_MALLOC 
c42a .. 00		.push_malloc:	db "Malloc address",0 
c439			;endif 
c439			 
c439			 
c439			 
c439			; display malloc address and current data stack pointer  
c439			 
c439			malloc_error: 
c439 d5				push de 
c43a f5				push af 
c43b e5				push hl 
c43c cd 8e 88			call clear_display 
c43f 11 61 c4			ld de, .mallocerr 
c442 3e 00			ld a,0 
c444			;	ld de,os_word_scratch 
c444 cd a1 88			call str_at_display 
c447 3e 11			ld a, display_row_1+17 
c449 11 c0 ee			ld de, debug_mark 
c44c cd a1 88			call str_at_display 
c44f cd b1 88			call update_display 
c452				;call break_point_state 
c452 cd 6f d7			call cin_wait 
c455			 
c455 3e 20			ld a, ' ' 
c457 32 d7 e4			ld (os_view_disable), a 
c45a e1				pop hl 
c45b f1				pop af 
c45c d1				pop de	 
c45d				CALLMONITOR 
c45d cd 2e 93			call break_point_state  
c460				endm  
# End of macro CALLMONITOR
c460 c9				ret 
c461			 
c461 .. 00		.mallocerr: 	db "Malloc Error",0 
c46e			;if DEBUG_FORTH_PUSH 
c46e			display_data_sp: 
c46e f5				push af 
c46f			 
c46f				; see if disabled 
c46f			 
c46f 3a d7 e4			ld a, (os_view_disable) 
c472 fe 2a			cp '*' 
c474 28 67			jr z, .skipdsp 
c476			 
c476 e5				push hl 
c477 e5				push hl 
c478 e5			push hl 
c479 cd 8e 88			call clear_display 
c47c e1			pop hl 
c47d 7c				ld a,h 
c47e 21 eb e7			ld hl, os_word_scratch 
c481 cd bc 8d			call hexout 
c484 e1				pop hl 
c485 7d				ld a,l 
c486 21 ed e7			ld hl, os_word_scratch+2 
c489 cd bc 8d			call hexout 
c48c 21 ef e7			ld hl, os_word_scratch+4 
c48f 3e 00			ld a,0 
c491 77				ld (hl),a 
c492 11 eb e7			ld de,os_word_scratch 
c495 3e 14				ld a, display_row_2 
c497 cd a1 88				call str_at_display 
c49a 11 f4 c3			ld de, .wordinhl 
c49d 3e 00			ld a, display_row_1 
c49f			 
c49f cd a1 88				call str_at_display 
c4a2 11 c0 ee			ld de, debug_mark 
c4a5 3e 11			ld a, display_row_1+17 
c4a7			 
c4a7 cd a1 88				call str_at_display 
c4aa			 
c4aa				; display current data stack pointer 
c4aa 11 f0 c3			ld de,.data_sp 
c4ad 3e 1c				ld a, display_row_2 + 8 
c4af cd a1 88				call str_at_display 
c4b2			 
c4b2 2a 93 ec			ld hl,(cli_data_sp) 
c4b5 e5				push hl 
c4b6 7c				ld a,h 
c4b7 21 eb e7			ld hl, os_word_scratch 
c4ba cd bc 8d			call hexout 
c4bd e1				pop hl 
c4be 7d				ld a,l 
c4bf 21 ed e7			ld hl, os_word_scratch+2 
c4c2 cd bc 8d			call hexout 
c4c5 21 ef e7			ld hl, os_word_scratch+4 
c4c8 3e 00			ld a,0 
c4ca 77				ld (hl),a 
c4cb 11 eb e7			ld de,os_word_scratch 
c4ce 3e 1f				ld a, display_row_2 + 11 
c4d0 cd a1 88				call str_at_display 
c4d3			 
c4d3			 
c4d3 cd b1 88			call update_display 
c4d6 cd 0e 88			call delay1s 
c4d9 cd 0e 88			call delay1s 
c4dc e1				pop hl 
c4dd			.skipdsp: 
c4dd f1				pop af 
c4de c9				ret 
c4df			 
c4df			display_data_malloc: 
c4df			 
c4df f5				push af 
c4e0 e5				push hl 
c4e1 e5				push hl 
c4e2 e5			push hl 
c4e3 cd 8e 88			call clear_display 
c4e6 e1			pop hl 
c4e7 7c				ld a,h 
c4e8 21 eb e7			ld hl, os_word_scratch 
c4eb cd bc 8d			call hexout 
c4ee e1				pop hl 
c4ef 7d				ld a,l 
c4f0 21 ed e7			ld hl, os_word_scratch+2 
c4f3 cd bc 8d			call hexout 
c4f6 21 ef e7			ld hl, os_word_scratch+4 
c4f9 3e 00			ld a,0 
c4fb 77				ld (hl),a 
c4fc 11 eb e7			ld de,os_word_scratch 
c4ff 3e 14				ld a, display_row_2 
c501 cd a1 88				call str_at_display 
c504 11 2a c4			ld de, .push_malloc 
c507 3e 00			ld a, display_row_1 
c509			 
c509 cd a1 88				call str_at_display 
c50c			 
c50c				; display current data stack pointer 
c50c 11 f0 c3			ld de,.data_sp 
c50f 3e 1c				ld a, display_row_2 + 8 
c511 cd a1 88				call str_at_display 
c514			 
c514 2a 93 ec			ld hl,(cli_data_sp) 
c517 e5				push hl 
c518 7c				ld a,h 
c519 21 eb e7			ld hl, os_word_scratch 
c51c cd bc 8d			call hexout 
c51f e1				pop hl 
c520 7d				ld a,l 
c521 21 ed e7			ld hl, os_word_scratch+2 
c524 cd bc 8d			call hexout 
c527 21 ef e7			ld hl, os_word_scratch+4 
c52a 3e 00			ld a,0 
c52c 77				ld (hl),a 
c52d 11 eb e7			ld de,os_word_scratch 
c530 3e 1f				ld a, display_row_2 + 11 
c532 cd a1 88				call str_at_display 
c535			 
c535 cd b1 88			call update_display 
c538 cd 0e 88			call delay1s 
c53b cd 0e 88			call delay1s 
c53e e1				pop hl 
c53f f1				pop af 
c540 c9				ret 
c541			;endif 
c541			 
c541			include "forth_autostart.asm" 
c541			; list of commands to perform at system start up 
c541			 
c541			startcmds: 
c541			;	dw test11 
c541			;	dw test12 
c541			;	dw test13 
c541			;	dw test14 
c541			;	dw test15 
c541			;	dw test16 
c541			;	dw test17 
c541			;	dw ifthtest1 
c541			;	dw ifthtest2 
c541			;	dw ifthtest3 
c541			;	dw mmtest1 
c541			;	dw mmtest2 
c541			;	dw mmtest3 
c541			;	dw mmtest4 
c541			;	dw mmtest5 
c541			;	dw mmtest6 
c541			;	dw iftest1 
c541			;	dw iftest2 
c541			;	dw iftest3 
c541			;	dw looptest1 
c541			;	dw looptest2 
c541			;	dw test1 
c541			;	dw test2 
c541			;	dw test3 
c541			;	dw test4 
c541			;	dw game2r 
c541			;	dw game2b1 
c541			;	dw game2b2 
c541			 
c541				; start up words that are actually useful 
c541			 
c541 9f c5			dw clrstack 
c543 d2 c5			dw type 
c545 93 c7			dw stest 
c547 f6 c5			dw strncpy 
c549 34 c7			dw list 
c54b 57 c6			dw start1 
c54d 69 c6			dw start2 
c54f			;	dw start3 
c54f 7c c6			dw start3b 
c551 d4 c6			dw start3c 
c553			 
c553				; (unit) testing words 
c553			 
c553 0a c8			dw mtesta 
c555 bf c8			dw mtestb 
c557 62 c9			dw mtestc 
c559 17 ca			dw mtestd 
c55b bb ca			dw mteste 
c55d			 
c55d				; demo/game words 
c55d			 
c55d c7 d1		        dw game3w 
c55f f5 d1		        dw game3p 
c561 13 d2		        dw game3sc 
c563 44 d2		        dw game3vsi 
c565 70 d2		        dw game3vs 
c567				 
c567 ba cf			dw game2b 
c569 28 d0			dw game2bf 
c56b 72 d0			dw game2mba 
c56d 08 d1			dw game2mbas 
c56f 4a d1			dw game2mb 
c571			 
c571 7b cc			dw game1 
c573 8c cc			dw game1a 
c575 ee cc			dw game1b 
c577 23 cd			dw game1c 
c579 59 cd			dw game1d 
c57b 8a cd			dw game1s 
c57d 9e cd			dw game1t 
c57f b3 cd			dw game1f 
c581 e7 cd			dw game1z 
c583 2b ce			dw game1zz 
c585			 
c585 71 cb			dw test5 
c587 a9 cb			dw test6 
c589 e1 cb			dw test7 
c58b f5 cb			dw test8 
c58d 21 cc			dw test9 
c58f 37 cc			dw test10 
c591				 
c591 02 cf		        dw ssv5 
c593 e6 ce		        dw ssv4 
c595 ca ce		        dw ssv3 
c597 94 ce		        dw ssv2 
c599 1b cf		        dw ssv1 
c59b 63 cf		        dw ssv1cpm 
c59d			;	dw keyup 
c59d			;	dw keydown 
c59d			;	dw keyleft 
c59d			;	dw keyright 
c59d			;	dw 	keyf1 
c59d			;	dw keyf2 
c59d			;	dw keyf3 
c59d			;	dw keyf4 
c59d			;	dw keyf5 
c59d			;	dw keyf6 
c59d			;	dw keyf7 
c59d			;	dw keyf8 
c59d			;	dw keyf9 
c59d			;	dw keyf10 
c59d			;	dw keyf11 
c59d			;	dw keyf12 
c59d			;	dw keytab 
c59d			;	dw keycr 
c59d			;	dw keyhome 
c59d			;	dw keyend 
c59d			;	dw keybs 
c59d 00 00			db 0, 0	 
c59f			 
c59f			 
c59f			; clear stack  
c59f			 
c59f .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
c5d2			 
c5d2			; type ( addr count - ) 
c5d2 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
c5f6			 
c5f6			; some direct memory words 
c5f6			; strncpy ( len t f -- t ) 
c5f6			 
c5f6 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
c657			 
c657 .. 00		start1:     	db ": bpon $0000 bp ;",0 
c669 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
c67c			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
c67c .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
c6d4 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
c734			 
c734			 
c734			; a handy word to list items on the stack 
c734			 
c734 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
c793			 
c793			 
c793			; test stack  
c793			; rnd8 stest 
c793			 
c793 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
c80a			 
c80a			; random malloc and free cycles 
c80a			 
c80a .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c8bf			 
c8bf			; fixed malloc and free cycles 
c8bf			 
c8bf .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c962			 
c962			; fixed double string push and drop cycle  
c962			 
c962 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
ca17			 
ca17			; consistent fixed string push and drop cycle  
ca17			 
ca17 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cabb			 
cabb .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cb71			 
cb71			;test1:		db ": aa 1 2 3 ;", 0 
cb71			;test2:     	db "111 aa 888 999",0 
cb71			;test3:     	db ": bb 77 ;",0 
cb71			;test4:     	db "$02 $01 do i . loop bb",0 
cb71			 
cb71 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
cba9 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
cbe1 .. 00		test7:     	db ": box hline vline ;",0 
cbf5 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
cc21 .. 00		test9:     	db ": sw $01 adsp world ;",0 
cc37 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
cc5c .. 00		test11:     	db "hello create .",0 
cc6b .. 00		test12:     	db "hello2 create .",0 
cc7b			 
cc7b			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
cc7b			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
cc7b			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
cc7b			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
cc7b			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
cc7b			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
cc7b			 
cc7b			;iftest1:     	db "$0001 IF cls .",0 
cc7b			;iftest2:     	db "$0000 IF cls .",0 
cc7b			;iftest3:     	db "$0002 $0003 - IF cls .",0 
cc7b			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
cc7b			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
cc7b			 
cc7b			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cc7b			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cc7b			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cc7b			 
cc7b			 
cc7b			 
cc7b			; a small guess the number game 
cc7b			 
cc7b .. 00		game1:          db ": gsn rnd8 v1! ;",0 
cc8c .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
ccee			 
ccee .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
cd23 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
cd59 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
cd8a .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
cd9e .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
cdb3 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
cde7 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
ce2b			 
ce2b			; Using 'ga' save a high score across multiple runs using external storage 
ce2b			 
ce2b .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
ce94			 
ce94			 
ce94			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
ce94			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
ce94			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
ce94			 
ce94			; simple screen saver to test code memory reuse to destruction 
ce94			 
ce94 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
ceca .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
cee6 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
cf02 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
cf1b .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
cf63 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
cfba			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
cfba			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
cfba			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
cfba			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
cfba			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
cfba			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
cfba			 
cfba			 
cfba			 
cfba			; minesweeper/battleship finding game 
cfba			; draws a game board of random ship/mine positions 
cfba			; user enters coords to see if it hits on 
cfba			; game ends when all are hit 
cfba			; when hit or miss says how many may be in the area 
cfba			 
cfba			; setup the game board and then hide it 
cfba .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
d028 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d072			; prompt for where to target 
d072 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d108 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d12d			; TODO see if the entered coords hits or misses pushes char hit of miss 
d12d .. 00		game2mbht:      db ": mbckht nop ;",0 
d13c .. 00		game2mbms:      db ": mbcms nop ;",0 
d14a			; TODO how many might be near by 
d14a .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d1c7			 
d1c7			; Game 3 
d1c7			 
d1c7			; Vert scroller ski game - avoid the trees! 
d1c7			 
d1c7			; v0 score (ie turns) 
d1c7			; v1 player pos 
d1c7			; v2 left wall 
d1c7			; v3 right wall 
d1c7			 
d1c7			; Draw side walls randomly 
d1c7			 
d1c7 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d1f5			 
d1f5			; Draw player 
d1f5 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d213			 
d213			; TODO Get Key 
d213			 
d213			; TODO Move left right 
d213			 
d213			; scroll and move walls a bit 
d213			 
d213 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d244			 
d244			; main game loop 
d244			 
d244 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d270 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d2af			 
d2af			; key board defs 
d2af			 
d2af .. 00		keyup:       db ": keyup $05 ;",0 
d2bd .. 00		keydown:       db ": keydown $0a ;",0 
d2cd .. 00		keyleft:       db ": keyleft $0b ;",0 
d2dd .. 00		keyright:       db ": keyright $0c ;",0 
d2ee .. 00		keyf1:       db ": keyf1 $10 ;",0 
d2fc .. 00		keyf2:       db ": keyf2 $11 ;",0 
d30a .. 00		keyf3:       db ": keyf3 $12 ;",0 
d318 .. 00		keyf4:       db ": keyf4 $13 ;",0 
d326 .. 00		keyf5:       db ": keyf5 $14 ;",0 
d334 .. 00		keyf6:       db ": keyf6 $15 ;",0 
d342 .. 00		keyf7:       db ": keyf7 $16 ;",0 
d350 .. 00		keyf8:       db ": keyf8 $17 ;",0 
d35e .. 00		keyf9:       db ": keyf9 $18 ;",0 
d36c .. 00		keyf10:       db ": keyf10 $19 ;",0 
d37b .. 00		keyf11:       db ": keyf11 $1a ;",0 
d38a .. 00		keyf12:       db ": keyf12 $1b ;",0 
d399			 
d399 .. 00		keytab:       db ": keytab $09 ;",0 
d3a8 .. 00		keycr:       db ": keycr $0d ;",0 
d3b6 .. 00		keyhome:       db ": keyhome $0e ;",0 
d3c6 .. 00		keyend:       db ": keyend $0f ;",0 
d3d5 .. 00		keybs:       db ": keybs $08 ;",0 
d3e3			 
d3e3			   
d3e3			 
d3e3			 
d3e3			 
d3e3			; eof 
# End of file forth_autostart.asm
d3e3			 
d3e3 .. 00		sprompt1: db "Startup load...",0 
d3f3 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
d409			 
d409			 
d409			 
d409			 
d409			forth_startup: 
d409 21 41 c5			ld hl, startcmds 
d40c 3e 00			ld a, 0 
d40e 32 0c e9			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
d411			 
d411 e5			.start1:	push hl 
d412 cd 8e 88			call clear_display 
d415 11 e3 d3			ld de, sprompt1 
d418 3e 00		        ld a, display_row_1 
d41a cd a1 88			call str_at_display 
d41d 11 f3 d3			ld de, sprompt2 
d420 3e 14		        ld a, display_row_2 
d422 cd a1 88			call str_at_display 
d425 e1				pop hl 
d426 e5				push hl 
d427 5e				ld e,(hl) 
d428 23				inc hl 
d429 56				ld d,(hl) 
d42a 3e 28		        ld a, display_row_3 
d42c cd a1 88			call str_at_display 
d42f cd b1 88			call update_display 
d432			 
d432			 
d432 3a 0c e9			ld a, (os_last_cmd) 
d435 fe 00			cp 0 
d437 28 05			jr z, .startprompt 
d439 cd 02 88			call delay250ms 
d43c 18 24			jr .startdo 
d43e				 
d43e				 
d43e			 
d43e			.startprompt: 
d43e			 
d43e 3e 4f			ld a,display_row_4 + display_cols - 1 
d440 11 31 98		        ld de, endprg 
d443 cd a1 88			call str_at_display 
d446 cd b1 88			call update_display 
d449 cd 0e 88			call delay1s 
d44c cd 6f d7			call cin_wait 
d44f						 
d44f fe 2a			cp '*' 
d451 28 5e			jr z, .startupend1 
d453 fe 23			cp '#' 
d455 20 07			jr nz, .startno 
d457 3e 01			ld a, 1 
d459 32 0c e9			ld (os_last_cmd),a 
d45c 18 04			jr .startdo 
d45e fe 31		.startno:	cp '1' 
d460 28 3a			jr z,.startnxt  
d462			 
d462				; exec startup line 
d462			.startdo:	 
d462 e1				pop hl 
d463 e5				push hl 
d464				 
d464 5e				ld e,(hl) 
d465 23				inc hl 
d466 56				ld d,(hl) 
d467 eb				ex de,hl 
d468			 
d468 e5				push hl 
d469			 
d469 3e 00			ld a, 0 
d46b				;ld a, FORTH_END_BUFFER 
d46b cd 24 8f			call strlent 
d46e 23				inc hl   ; include zero term to copy 
d46f 06 00			ld b,0 
d471 4d				ld c,l 
d472 e1				pop hl 
d473 11 e6 e4			ld de, scratch 
d476 ed b0			ldir 
d478			 
d478			 
d478 21 e6 e4			ld hl, scratch 
d47b cd 72 9c			call forthparse 
d47e cd b2 9c			call forthexec 
d481 cd c9 9b			call forthexec_cleanup 
d484			 
d484 3e 3c			ld a, display_row_4 
d486 11 d5 95			ld de, endprog 
d489			 
d489 cd b1 88			call update_display		 
d48c			 
d48c 3a 0c e9			ld a, (os_last_cmd) 
d48f fe 00			cp 0 
d491 20 09			jr nz, .startnxt 
d493 cd 33 98			call next_page_prompt 
d496 cd 8e 88		        call clear_display 
d499 cd b1 88			call update_display		 
d49c			 
d49c				; move onto next startup line? 
d49c			.startnxt: 
d49c			 
d49c cd 02 88			call delay250ms 
d49f e1				pop hl 
d4a0			 
d4a0 23				inc hl 
d4a1 23				inc hl 
d4a2			 
d4a2 e5				push hl 
d4a3 5e				ld e, (hl) 
d4a4 23				inc hl 
d4a5 56				ld d, (hl) 
d4a6 e1				pop hl 
d4a7				; TODO replace 0 test 
d4a7			 
d4a7 eb				ex de, hl 
d4a8 cd e4 8a			call ishlzero 
d4ab			;	ld a,e 
d4ab			;	add d 
d4ab			;	cp 0    ; any left to do? 
d4ab eb				ex de, hl 
d4ac c2 11 d4			jp nz, .start1 
d4af 18 01			jr .startupend 
d4b1			 
d4b1 e1			.startupend1: pop hl 
d4b2			.startupend: 
d4b2			 
d4b2 cd 8e 88			call clear_display 
d4b5 cd b1 88			call update_display 
d4b8 c9				ret 
d4b9			 
d4b9			 
d4b9			; stack over and underflow checks 
d4b9			 
d4b9			; init the words to detect the under/overflow 
d4b9			 
d4b9			chk_stk_init: 
d4b9				; a vague random number to check so we dont get any "lucky" hits 
d4b9 3e 2d			ld a, 45 
d4bb 6f				ld l, a 
d4bc 00				nop 
d4bd 3e 17			ld a, 23 
d4bf 67				ld h, a 
d4c0			 
d4c0 22 cd e4			ld (chk_word), hl     ; the word we need to check against 
d4c3			 
d4c3			;	ld (chk_stund), hl	; stack points.... 
d4c3 22 00 ef			ld (chk_stovr), hl 
d4c6 22 91 ec			ld (chk_ret_und), hl 
d4c9 22 4f ec			ld (chk_ret_ovr), hl 
d4cc 22 4d eb			ld (chk_loop_ovr), hl 
d4cf 22 4b ea			ld (chk_data_ovr), hl 
d4d2 c9				ret 
d4d3				 
d4d3			check_stacks: 
d4d3				; check all stack words 
d4d3			 
d4d3 e5				push hl 
d4d4 d5				push de 
d4d5			 
d4d5			;	ld de,(chk_word) 
d4d5			;	ld hl, (chk_stund)	; stack points.... 
d4d5			;	if DEBUG_STK_FAULT 
d4d5			;		DMARK "FAa" 
d4d5			;		CALLMONITOR 
d4d5			;	endif 
d4d5			;	call cmp16 
d4d5			;	jp z, .chk_faulta 
d4d5			; 
d4d5			;	ld de, sfaultsu 
d4d5			;	jp .chk_fault 
d4d5			 
d4d5 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d4d8 ed 5b cd e4		ld de,(chk_word) 
d4dc				if DEBUG_STK_FAULT 
d4dc					DMARK "FAb" 
d4dc					CALLMONITOR 
d4dc				endif 
d4dc cd d9 8a			call cmp16 
d4df 28 06			jr z, .chk_fault1 
d4e1 11 82 d5			ld de, sfaultso 
d4e4 c3 36 d5			jp .chk_fault 
d4e7			.chk_fault1:  
d4e7 2a 91 ec			ld hl, (chk_ret_und) 
d4ea ed 5b cd e4		ld de,(chk_word) 
d4ee				if DEBUG_STK_FAULT 
d4ee					DMARK "FAU" 
d4ee					CALLMONITOR 
d4ee				endif 
d4ee cd d9 8a			call cmp16 
d4f1 ca fa d4			jp z, .chk_fault2 
d4f4 11 92 d5			ld de, sfaultru 
d4f7 c3 36 d5			jp .chk_fault 
d4fa			.chk_fault2:  
d4fa 2a 4f ec			ld hl, (chk_ret_ovr) 
d4fd ed 5b cd e4		ld de,(chk_word) 
d501				if DEBUG_STK_FAULT 
d501					DMARK "FA1" 
d501					CALLMONITOR 
d501				endif 
d501 cd d9 8a			call cmp16 
d504 ca 0d d5			jp z, .chk_fault3 
d507 11 a0 d5			ld de, sfaultro 
d50a c3 36 d5			jp .chk_fault 
d50d			.chk_fault3:  
d50d 2a 4d eb			ld hl, (chk_loop_ovr) 
d510 ed 5b cd e4		ld de,(chk_word) 
d514				if DEBUG_STK_FAULT 
d514					DMARK "FA2" 
d514					CALLMONITOR 
d514				endif 
d514 cd d9 8a			call cmp16 
d517 ca 20 d5			jp z, .chk_fault4 
d51a 11 ba d5			ld de, sfaultlo 
d51d c3 36 d5			jp .chk_fault 
d520			.chk_fault4:  
d520 2a 4b ea			ld hl, (chk_data_ovr) 
d523 ed 5b cd e4		ld de,(chk_word) 
d527				if DEBUG_STK_FAULT 
d527					DMARK "FA3" 
d527					CALLMONITOR 
d527				endif 
d527 cd d9 8a			call cmp16 
d52a ca 33 d5			jp z, .chk_fault5 
d52d 11 d4 d5			ld de, sfaultdo 
d530 c3 36 d5			jp .chk_fault 
d533			 
d533			 
d533			.chk_fault5:  
d533 d1				pop de 
d534 e1				pop hl 
d535			 
d535 c9				ret 
d536			 
d536 cd 8e 88		.chk_fault: 	call clear_display 
d539 3e 14				ld a, display_row_2 
d53b cd a1 88				call str_at_display 
d53e 11 64 d5				   ld de, .stackfault 
d541 3e 00				ld a, display_row_1 
d543 cd a1 88				call str_at_display 
d546 11 c0 ee				    ld de, debug_mark 
d549 3e 11				ld a, display_row_1+17 
d54b cd a1 88				call str_at_display 
d54e cd b1 88				call update_display 
d551			 
d551				; prompt before entering montior for investigating issue 
d551			 
d551 3e 3c			ld a, display_row_4 
d553 11 d5 95			ld de, endprog 
d556			 
d556 cd b1 88			call update_display		 
d559			 
d559 cd 33 98			call next_page_prompt 
d55c			 
d55c d1				pop de 
d55d e1				pop hl 
d55e cd 29 96				call monitor 
d561 c3 23 95				jp warmstart 
d564					;jp 0 
d564					;halt 
d564			 
d564			 
d564			 
d564 .. 00		.stackfault: 	db "Stack fault:",0 
d571			 
d571 .. 00		sfaultsu: 	db	"Stack under flow",0 
d582 .. 00		sfaultso: 	db	"Stack over flow",0 
d592 .. 00		sfaultru:	db "RTS underflow",0 
d5a0 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
d5ba .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
d5d4 .. 00		sfaultdo:	db "DTS overflow", 0 
d5e1			 
d5e1			 
d5e1			fault_dsp_under: 
d5e1 11 f3 d5			ld de, .dsp_under 
d5e4 c3 a3 d6			jp .show_fault 
d5e7			 
d5e7			fault_rsp_under: 
d5e7 11 01 d6			ld de, .rsp_under 
d5ea c3 a3 d6			jp .show_fault 
d5ed			fault_loop_under: 
d5ed 11 0f d6			ld de, .loop_under 
d5f0 c3 a3 d6			jp .show_fault 
d5f3			 
d5f3 .. 00		.dsp_under: db "DSP Underflow",0 
d601 .. 00		.rsp_under: db "RSP Underflow",0 
d60f .. 00		.loop_under: db "LOOP Underflow",0 
d61e			 
d61e			 
d61e d5			type_faultn: 	push de 
d61f e5					push hl 
d620 cd 8e 88				call clear_display 
d623 11 4a d6				   ld de, .typefaultn 
d626 3e 00				ld a, display_row_1 
d628 cd a1 88				call str_at_display 
d62b 11 c0 ee				    ld de, debug_mark 
d62e 3e 11				ld a, display_row_1+17 
d630 cd a1 88				call str_at_display 
d633 cd b1 88				call update_display 
d636			 
d636				; prompt before entering montior for investigating issue 
d636			 
d636 3e 3c			ld a, display_row_4 
d638 11 d5 95			ld de, endprog 
d63b			 
d63b cd b1 88			call update_display		 
d63e			 
d63e cd 33 98			call next_page_prompt 
d641			 
d641 e5					push hl 
d642 d5					push de 
d643 cd 29 96				call monitor 
d646 c3 23 95				jp warmstart 
d649 76					halt 
d64a			 
d64a			 
d64a .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
d661			 
d661 d5			type_faults: 	push de 
d662 e5					push hl 
d663 cd 8e 88				call clear_display 
d666 11 8c d6				   ld de, .typefaults 
d669 3e 00				ld a, display_row_1 
d66b cd a1 88				call str_at_display 
d66e 11 c0 ee				    ld de, debug_mark 
d671 3e 11				ld a, display_row_1+17 
d673 cd a1 88				call str_at_display 
d676 cd b1 88				call update_display 
d679			 
d679				; prompt before entering montior for investigating issue 
d679			 
d679 3e 3c			ld a, display_row_4 
d67b 11 d5 95			ld de, endprog 
d67e			 
d67e cd b1 88			call update_display		 
d681			 
d681 cd 33 98			call next_page_prompt 
d684			 
d684 e1					pop hl 
d685 d1					pop de 
d686 cd 29 96				call monitor 
d689 c3 23 95				jp warmstart 
d68c			 
d68c			 
d68c .. 00		.typefaults: db "STR Type Expected TOS!",0 
d6a3			 
d6a3			.show_fault: 	 
d6a3 d5					push de 
d6a4 cd 8e 88				call clear_display 
d6a7 d1					pop de 
d6a8 3e 00				ld a, display_row_1 
d6aa cd a1 88				call str_at_display 
d6ad 11 c0 ee				    ld de, debug_mark 
d6b0 3e 11				ld a, display_row_1+17 
d6b2 cd a1 88				call str_at_display 
d6b5 cd b1 88				call update_display 
d6b8			 
d6b8				; prompt before entering montior for investigating issue 
d6b8			 
d6b8 3e 3c			ld a, display_row_4 
d6ba 11 d5 95			ld de, endprog 
d6bd			 
d6bd cd b1 88			call update_display		 
d6c0			 
d6c0 cd 33 98			call next_page_prompt 
d6c3			 
d6c3 e1					pop hl 
d6c4 d1					pop de 
d6c5 cd 29 96				call monitor 
d6c8			; do a dump to cli and not warmstart so we preserve all of the uwords.  
d6c8			; TODO Make optional fault restart to cli or warm boot? 
d6c8					;jp warmstart 
d6c8 c3 7b 95				jp cli 
d6cb 76					halt 
d6cc			 
d6cc			; handle the auto run of code from files in storage 
d6cc			 
d6cc			 
d6cc			if STORAGE_SE 
d6cc			 
d6cc			sprompt3: db "Loading from start-up file?:",0 
d6cc			sprompt4: db "(Y=Any key/N=No)",0 
d6cc			 
d6cc			 
d6cc			forth_autoload: 
d6cc			 
d6cc				; load block 0 of store 1 
d6cc				 
d6cc				ld a, $fe      ; bit 0 clear 
d6cc				ld (spi_device), a 
d6cc			 
d6cc				call storage_get_block_0 
d6cc			 
d6cc				ld a, (store_page+STORE_0_AUTOFILE) 
d6cc			 
d6cc				cp 0 
d6cc				ret z     ; auto start not enabled 
d6cc			 
d6cc				call clear_display 
d6cc			 
d6cc				; set bank 
d6cc			 
d6cc					ld a, (store_page+STORE_0_BANKRUN) 
d6cc					ld (spi_device), a 
d6cc			 
d6cc				; get file id to load from and get the file name to display 
d6cc			 
d6cc					ld a, (store_page+STORE_0_FILERUN) 
d6cc			 
d6cc					ld l, 0 
d6cc					ld h, a 
d6cc					ld de, store_page 
d6cc			 
d6cc					if DEBUG_FORTH_WORDS 
d6cc						DMARK "ASp" 
d6cc						CALLMONITOR 
d6cc					endif 
d6cc					call storage_read 
d6cc			 
d6cc					if DEBUG_FORTH_WORDS 
d6cc						DMARK "ASr" 
d6cc						CALLMONITOR 
d6cc					endif 
d6cc			 
d6cc					call ishlzero 
d6cc					ret z             ; file not found 
d6cc			 
d6cc					ld a, display_row_2 + 10 
d6cc					ld de, store_page+3 
d6cc					call str_at_display 
d6cc				 
d6cc			; 
d6cc			 
d6cc				ld a, display_row_1+5 
d6cc				ld de, sprompt3 
d6cc				call str_at_display 
d6cc				ld a, display_row_3+15 
d6cc				ld de, sprompt4 
d6cc				call str_at_display 
d6cc			 
d6cc				call update_display 
d6cc			 
d6cc				call cin_wait 
d6cc				cp 'n' 
d6cc				ret z 
d6cc				cp 'N' 
d6cc				ret z 
d6cc			 
d6cc				call delay1s 
d6cc			 
d6cc				ld a, (store_page+2) 
d6cc				ld (store_openmaxext), a    ; save count of ext 
d6cc				ld a, 1  
d6cc				ld (store_openext), a    ; save count of ext 
d6cc			 
d6cc			.autof:  
d6cc				ld l , a 
d6cc				 
d6cc				ld a, (store_page) 
d6cc				ld h, a	 
d6cc				ld de, store_page 
d6cc					if DEBUG_FORTH_WORDS 
d6cc						DMARK "ASl" 
d6cc						CALLMONITOR 
d6cc					endif 
d6cc					call storage_read 
d6cc				call ishlzero 
d6cc				ret z 
d6cc			;	jr z, .autoend 
d6cc			 
d6cc					if DEBUG_FORTH_WORDS 
d6cc						DMARK "ASc" 
d6cc						CALLMONITOR 
d6cc					endif 
d6cc				ld de, store_page+2 
d6cc				ld a, display_row_4 
d6cc				call str_at_display 
d6cc			 
d6cc				call update_display 
d6cc				call delay250ms 
d6cc			 
d6cc			 
d6cc			 
d6cc				ld hl, store_page+2 
d6cc				call forthparse 
d6cc				call forthexec 
d6cc				call forthexec_cleanup 
d6cc			 
d6cc				 
d6cc				ld a, (store_openext) 
d6cc				inc a 
d6cc				ld (store_openext), a    ; save count of ext 
d6cc			 
d6cc				jr .autof 
d6cc			;.autofdone: 
d6cc			; 
d6cc			;		if DEBUG_FORTH_WORDS 
d6cc			;			DMARK "ASx" 
d6cc			;			CALLMONITOR 
d6cc			;		endif 
d6cc			;;	call clear_display 
d6cc			;	ret 
d6cc			 
d6cc			 
d6cc			 
d6cc			endif 
d6cc			 
d6cc			 
d6cc			; eof 
# End of file forth_kernel.asm
d6cc			;include "nascombasic.asm" 
d6cc			 
d6cc			 
d6cc			; find out where the code ends if loaded into RAM (for SC114) 
d6cc			;endofcode:  
d6cc			;	nop 
d6cc			 
d6cc			 
d6cc			; eof 
d6cc			 
# End of file main.asm
d6cc			;include "firmware_lcd_4x20.asm" 
d6cc			;include "firmware_key_4x4.asm" 
d6cc			include "firmware_serial_display.asm" 
d6cc			 
d6cc			; Serial display interface for SC114 
d6cc			 
d6cc			 
d6cc			display_row_1: equ 0 
d6cc			display_row_2: equ display_row_1+display_cols 
d6cc			display_row_3: equ display_row_2 + display_cols 
d6cc			display_row_4: equ display_row_3 + display_cols 
d6cc			 
d6cc			kLCDWidth:  EQU display_cols             ;Width in characters 
d6cc			kLCD_Line1: EQU 0x00  
d6cc			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
d6cc			; E1 
d6cc			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
d6cc			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
d6cc			 
d6cc			lcd_init: 
d6cc				; no init as handled by the SCM bios 
d6cc c9				ret 
d6cd			 
d6cd			 
d6cd			; low level functions for direct screen writes 
d6cd			 
d6cd			; output char at pos? 
d6cd			fLCD_Str: 
d6cd			        ;out (SC114_SIO_1_OUT),a 
d6cd c5				push bc 
d6ce 0e 02			ld c, $02 
d6d0 f7				rst $30 
d6d1 c1				pop bc 
d6d2 c9				ret 
d6d3			 
d6d3			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
d6d3			fLCD_Pos: 
d6d3				; use ASCII escape to position 
d6d3			        ;out (SC114_SIO_1_OUT),a 
d6d3 c5				push bc 
d6d4 0e 02			ld c, $02 
d6d6 f7				rst $30 
d6d7 c1				pop bc 
d6d8			 
d6d8 c9				ret 
d6d9			 
d6d9			; output char at pos 
d6d9			fLCD_Data: 
d6d9			      ;  out (SC114_SIO_1_OUT),a 
d6d9 c5				push bc 
d6da 0e 02			ld c, $02 
d6dc f7				rst $30 
d6dd c1				pop bc 
d6de			 
d6de c9				ret 
d6df			 
d6df			; ascii cls  
d6df			 
d6df 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
d6e3			 
d6e3			; write the frame buffer given in hl to hardware  
d6e3			write_display: 
d6e3			 
d6e3			API: equ 0 
d6e3			 
d6e3			if API 
d6e3				push bc 
d6e3				ld b, 4 
d6e3			 
d6e3			        ld (display_write_tmp), hl 	  
d6e3			 
d6e3				; clear and home cursor 
d6e3			 
d6e3				ld c, 6 
d6e3				ld de, .cls 
d6e3				rst $30 
d6e3			 
d6e3			 
d6e3			.writeln: 
d6e3			 
d6e3				ld de, (display_write_tmp) 
d6e3				ld c, 6 
d6e3				rst $30 
d6e3				ld c, 7 
d6e3				rst $30 
d6e3			 
d6e3				ld hl, (display_write_tmp) 
d6e3				ld de, display_cols 
d6e3				add hl,de 
d6e3				ld (display_write_tmp),hl 
d6e3			 
d6e3				djnz  .writeln 
d6e3			 
d6e3				pop bc 
d6e3			 
d6e3			 
d6e3				ret 
d6e3			endif 
d6e3 e5				push hl 
d6e4 c5				push bc 
d6e5 d5				push de 
d6e6			 
d6e6			;	ld c, 2 
d6e6			;	;ld de, .cls 
d6e6			;	ld a, 27 
d6e6			;	rst $30 
d6e6			;	ld c, 2 
d6e6			;	;ld de, .cls 
d6e6			;	ld a, '[' 
d6e6			;	rst $30 
d6e6			; 
d6e6			;	ld c, 2 
d6e6			;	;ld de, .cls 
d6e6			;	ld a, 'H' 
d6e6			;	rst $30 
d6e6			; 
d6e6			 
d6e6 0e 02			ld c, 2 
d6e8				;ld de, .cls 
d6e8 3e 1b			ld a, 27 
d6ea f7				rst $30 
d6eb			 
d6eb			 
d6eb 0e 02			ld c, 2 
d6ed				;ld de, .cls 
d6ed 3e 5b			ld a, '[' 
d6ef f7				rst $30 
d6f0 0e 02			ld c, 2 
d6f2				;ld de, .cls 
d6f2 3e 32			ld a, '2' 
d6f4 f7				rst $30 
d6f5 0e 02			ld c, 2 
d6f7				;ld de, .cls 
d6f7 3e 4a			ld a, 'J' 
d6f9 f7				rst $30 
d6fa d1				pop de 
d6fb c1				pop bc 
d6fc e1				pop hl 
d6fd			 
d6fd			 
d6fd 22 5e ed		        ld (display_write_tmp), hl 	  
d700 3e 00			ld a, kLCD_Line1 
d702			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d702 06 14			ld b, display_cols 
d704 ed 5b 5e ed		ld de, (display_write_tmp) 
d708 cd 66 d7			call write_len_string 
d70b				 
d70b			 
d70b e5			push hl 
d70c d5			push de 
d70d c5			push bc 
d70e 0e 07			ld c, 7 
d710 f7				rst $30 
d711 c1			pop bc 
d712 d1			pop de 
d713 e1			pop hl 
d714			 
d714				 
d714 2a 5e ed			ld hl, (display_write_tmp) 
d717 11 14 00			ld de, display_cols 
d71a 19				add hl,de 
d71b 22 5e ed			ld (display_write_tmp),hl 
d71e			 
d71e				 
d71e 3e 14			ld a, kLCD_Line2 
d720			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d720 06 14			ld b, display_cols 
d722 ed 5b 5e ed		ld de, (display_write_tmp) 
d726 cd 66 d7			call write_len_string 
d729				 
d729 2a 5e ed			ld hl, (display_write_tmp) 
d72c 11 14 00			ld de, display_cols 
d72f 19				add hl,de 
d730 22 5e ed			ld (display_write_tmp),hl 
d733			 
d733 e5			push hl 
d734 d5			push de 
d735 c5			push bc 
d736 0e 07			ld c, 7 
d738 f7				rst $30 
d739 c1			pop bc 
d73a d1			pop de 
d73b e1			pop hl 
d73c			 
d73c				 
d73c 3e 28			ld a, kLCD_Line3 
d73e			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
d73e 06 14			ld b, display_cols 
d740 ed 5b 5e ed		ld de, (display_write_tmp) 
d744 cd 66 d7			call write_len_string 
d747				 
d747 2a 5e ed			ld hl, (display_write_tmp) 
d74a 11 14 00			ld de, display_cols 
d74d 19				add hl,de 
d74e 22 5e ed			ld (display_write_tmp),hl 
d751			 
d751 e5			push hl 
d752 d5			push de 
d753 c5			push bc 
d754 0e 07			ld c, 7 
d756 f7				rst $30 
d757 c1			pop bc 
d758 d1			pop de 
d759 e1			pop hl 
d75a			 
d75a				 
d75a 3e 3c			ld a, kLCD_Line4 
d75c			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
d75c 06 14			ld b, display_cols 
d75e ed 5b 5e ed		ld de, (display_write_tmp) 
d762 cd 66 d7			call write_len_string 
d765 c9					ret 
d766			 
d766			 
d766				; write out a fixed length string given in b from de 
d766			 
d766 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
d767 cd d9 d6		            CALL fLCD_Data      ;Write character to display 
d76a 13				inc de 
d76b 10 f9			djnz write_len_string 
d76d c9				ret 
d76e			 
d76e			 
d76e			; eof 
# End of file firmware_serial_display.asm
d76e			include "firmware_key_serial.asm" 
d76e			; Serial keyboard interface for SC114 
d76e			 
d76e			key_init: 
d76e				; no init as handled by the SCM bios 
d76e c9				ret 
d76f			 
d76f			 
d76f			cin_wait: 
d76f			;	ld a, 0 
d76f			;	ret 
d76f			 
d76f				;in a,(SC114_SIO_1_IN) 
d76f			        ; Use SCM API to get from whatever console device we are using 
d76f c5				push bc 
d770 0e 01			ld c, $01 
d772 f7				rst $30 
d773 c1				pop bc 
d774 c9				ret 
d775			 
d775			cin: 
d775			 
d775			 
d775 c5				push bc 
d776			 
d776				; any key waiting to process? 
d776 0e 03			ld c, $03 
d778 f7				rst $30 
d779 28 05			jr z, .cin_skip 
d77b			 
d77b				; yep, get it 
d77b			 
d77b 0e 01			ld c, $01 
d77d f7				rst $30 
d77e c1				pop bc 
d77f c9				ret 
d780			.cin_skip: 
d780 3e 00			ld a, 0 
d782 c1				pop bc 
d783 c9				ret 
d784			 
d784			 
d784			 
d784			 
# End of file firmware_key_serial.asm
d784			 
d784			baseram:  
d784			endofcode: 
d784 00				nop 
d785			 
d785			heap_start: equ baseram+15  ; Starting address of heap 
d785			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
d785			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
d785			; 
d785			 
# End of file os_mini_sc114.asm
d785
