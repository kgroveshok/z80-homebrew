# File os_mini.asm
0000			; 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ 0 
0000			CPU_CLOCK_10MHZ: equ 0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
0000			 
0000			 
0000			; Full OS but with the small 4x4 keypad 
0000			 
0000			display_rows: equ 4     ; move out to mini and mega files 
0000			display_cols: equ 20 
0000			 
0000			key_rows: equ 4     ; TODO move out to mini and mega 
0000			key_cols: equ 4    ; TODO move out to mini and mega 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 40 18			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 1   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Block 0 at offset $3c holds the file number to run at system startup after the display  
0003			  
0003			STORE_0_AUTOFILE: equ $21  
0003			STORE_0_BANKRUN: equ $23  
0003			STORE_0_FILERUN: equ $24  
0003			  
0003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0003			  
0003			STORE_0_AUTORUN: equ $20  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			spi_device_id: equ spi_device - 1    ; human readable bank number  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ scratch-2  
0003			os_new_parse_len: equ os_new_malloc - 2  
0003			os_new_word_len: equ os_new_parse_len - 2  
0003			os_new_work_ptr: equ os_new_word_len - 2  
0003			os_new_src_ptr: equ os_new_work_ptr - 2  
0003			os_new_exec: equ os_new_src_ptr - 2  
0003			os_new_exec_ptr: equ os_new_exec - 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ os_new_exec_ptr - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 c3 fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 02 fb				ld hl, display_fb1  
000b 22 5e fa				ld (display_fb_active), hl  
000e			  
000e cd d2 0a				call clear_display  
0011			  
0011 21 60 fa				ld hl, display_fb2  
0014 22 5e fa				ld (display_fb_active), hl  
0017			  
0017 cd d2 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 53 fb				ld hl, display_fb0  
001d 22 5e fa				ld (display_fb_active), hl  
0020			  
0020 cd d2 0a				call clear_display  
0023			  
0023			  
0023 cd 86 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd cf 65			call key_init  
0029 cd c9 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd a9 11				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f					call sound_init  
002f				endif  
002f			  
002f				; lcd test sequence  
002f					  
002f cd f5 0a			call update_display  
0032 cd 52 0a			call delay1s  
0035 3e 2b			ld a,'+'  
0037 cd d7 0a			call fill_display  
003a cd f5 0a			call update_display  
003d cd 52 0a			call delay1s  
0040 3e 2a			ld a,'*'  
0042 cd d7 0a			call fill_display  
0045 cd f5 0a			call update_display  
0048 cd 52 0a			call delay1s  
004b 3e 2d			ld a,'-'  
004d cd d7 0a			call fill_display  
0050 cd f5 0a			call update_display  
0053 cd 52 0a			call delay1s  
0056			  
0056			; boot splash screen  
0056			if display_cols == 20	  
0056 3e 00		        ld a, display_row_1    
0058			else  
0058			        ld a, display_row_1 +10   
0058			endif  
0058 11 89 00			ld de, bootmsg  
005b cd e5 0a			call str_at_display  
005e cd f5 0a			call update_display  
0061			  
0061			  
0061 cd 52 0a			call delay1s  
0064 cd 52 0a			call delay1s  
0067			if display_cols == 20	  
0067 3e 2a		            LD   A, display_row_3+2  
0069			else  
0069			            LD   A, display_row_3+12  
0069			endif  
0069 11 9e 00			ld de, bootmsg1  
006c cd e5 0a			call str_at_display  
006f cd f5 0a			call update_display  
0072 cd 52 0a			call delay1s  
0075 cd 52 0a			call delay1s  
0078			  
0078			;	ld a, display_row_4+3  
0078			;	ld de, bootmsg2  
0078			;	call str_at_display  
0078			;	call update_display  
0078			;	call delay1s  
0078			;	call delay1s  
0078			  
0078			; debug mark setup  
0078			  
0078 3e 5f		ld a, '_'  
007a 32 bd fb		ld (debug_mark),a  
007d 32 be fb		ld (debug_mark+1),a  
0080 32 bf fb		ld (debug_mark+2),a  
0083 3e 00		ld a,0  
0085 32 c0 fb		ld (debug_mark+3),a  
0088			  
0088 c9					ret  
0089			  
0089			  
0089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
009e .. 00		bootmsg1:	db "by Kevin Groves",0  
00ae			;bootmsg2:	db "Firmware v0.1",0  
00ae			  
00ae			; a 4x20 lcd  
00ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00ae			  
00ae			;if display_cols == 20  
00ae			;	include "firmware_lcd_4x20.asm"  
00ae			;endif  
00ae			  
00ae			;if display_cols == 40  
00ae			;	include "firmware_lcd_4x40.asm"  
00ae			;endif  
00ae			  
00ae			;  
00ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00ae			; TODO abstract the bit bang video out interface for dual display  
00ae			; TODO wire video out to tx pin on rc2014 bus  
00ae			  
00ae			; must supply cin, and cin_wait for low level hardware abstraction   
00ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00ae			; test scancode  
00ae			  
00ae			;;;;;  
00ae			;;;  
00ae			; Moved out to mini and maxi versions  
00ae			;  
00ae			; include "firmware_key_4x4.asm"  
00ae			; using existing 4 wire x 4 resistor array for input  
00ae			;include "firmware_key_4x10.asm"  
00ae			; need to mod the board for 5 rows due to resistor array  
00ae			;include "firmware_key_5x10.asm"  
00ae			  
00ae			; storage hardware interface  
00ae			  
00ae			; use microchip serial eeprom for storage  
00ae			  
00ae			  
00ae			if STORAGE_SE  
00ae				include "firmware_spi.asm"  
00ae			; my spi protocol (used by storage) 
00ae			 
00ae			; SPI pins 
00ae			 
00ae			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00ae			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00ae			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00ae			 
00ae			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00ae			; chip pin 4 gnd 
00ae			 
00ae			 
00ae			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00ae			SPI_CE1: equ 1      ;    port a1 pin 14  
00ae			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00ae			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00ae			SPI_CE4: equ 4      ; port a4     pin 10 
00ae			 
00ae			; active low AND masks 
00ae			 
00ae			;SPI_CE0_MASK: equ    255-1 
00ae			;SPI_CE1_MASK: equ   255-2 
00ae			;SPI_CE2_MASK: equ   255-4 
00ae			;SPI_CE3_MASK: equ   255-8 
00ae			;SPI_CE4_MASK: equ   255-16 
00ae			SPI_CE_HIGH:  equ 255 
00ae			 
00ae			 
00ae			 
00ae			 
00ae			; TODO store port id for spi device ie dev c 
00ae			; TODO store pin for SO 
00ae			; TODO store pin for SI 
00ae			; TODO store pin for SCLK 
00ae			 
00ae			; 
00ae			 
00ae			; ensure that spi bus is in a stable state with default pins  
00ae			 
00ae			se_stable_spi:   
00ae			 
00ae				 ; set DI high, CE high , SCLK low 
00ae				;ld a, SPI_DI | SPI_CE0 
00ae 3e 07			ld a, SPI_DI  
00b0 cd 84 01			call spi_ce_high 
00b3 d3 80			 out (storage_adata),a 
00b5 32 cf f9			ld (spi_portbyte),a 
00b8			 
00b8				if DEBUG_SPI 
00b8					push hl 
00b8					ld l, a 
00b8					DMARK "SPI" 
00b8					CALLMONITOR 
00b8					pop hl 
00b8				endif 
00b8 c9				ret 
00b9			 
00b9			; byte to send in a 
00b9			 
00b9			spi_send_byte: 
00b9				; save byte to send for bit mask shift out 
00b9 4f			        ld c,a 
00ba 3a cf f9			ld a,(spi_portbyte) 
00bd				  
00bd				; clock out	each bit of the byte msb first 
00bd			 
00bd 06 08			ld b, 8 
00bf			.ssb1: 
00bf				; clear so bit  
00bf cb bf			res SPI_DI, a 
00c1 cb 11			rl c 
00c3				; if bit 7 is set then carry is set 
00c3 30 02			jr nc, .ssb2 
00c5 cb ff			set SPI_DI,a 
00c7			.ssb2:  ; output bit to ensure it is stable 
00c7 d3 80			out (storage_adata),a 
00c9 00				nop 
00ca				; clock bit high 
00ca cb ef			set SPI_SCLK,a 
00cc d3 80			out (storage_adata),a 
00ce 00				nop 
00cf				; then low 
00cf cb af			res SPI_SCLK,a 
00d1 d3 80			out (storage_adata),a 
00d3 00				nop 
00d4 10 e9			djnz .ssb1 
00d6			 
00d6 32 cf f9			ld (spi_portbyte),a 
00d9 c9				ret 
00da			 
00da			; TODO low level get byte into A on spi 
00da			 
00da			spi_read_byte:  
00da			 
00da				; save byte to send for bit mask shift out 
00da 0e 00		    ld c,0 
00dc 3a cf f9			ld a,(spi_portbyte) 
00df				  
00df				; clock out	each bit of the byte msb first 
00df			 
00df			 
00df				; clock bit high 
00df cb ef			set SPI_SCLK,a 
00e1 d3 80			out (storage_adata),a 
00e3 00				nop 
00e4			 
00e4			    ; read DO  
00e4			 
00e4 cb f9		    set 7,c 
00e6 db 80			in a,(storage_adata) 
00e8 cb 77		    bit SPI_DO,a 
00ea 20 02		    jr nz, .b7 
00ec cb b9		    res 7,c 
00ee			.b7: 
00ee				; then low 
00ee cb af			res SPI_SCLK,a 
00f0 d3 80			out (storage_adata),a 
00f2 00				nop 
00f3			     
00f3			 
00f3				; clock bit high 
00f3 cb ef			set SPI_SCLK,a 
00f5 d3 80			out (storage_adata),a 
00f7 00				nop 
00f8			 
00f8			    ; read DO  
00f8			 
00f8 cb f1		    set 6,c 
00fa db 80			in a,(storage_adata) 
00fc cb 77		    bit SPI_DO,a 
00fe 20 02		    jr nz, .b6 
0100 cb b1		    res 6,c 
0102			.b6: 
0102				; then low 
0102 cb af			res SPI_SCLK,a 
0104 d3 80			out (storage_adata),a 
0106 00				nop 
0107			 
0107				; clock bit high 
0107 cb ef			set SPI_SCLK,a 
0109 d3 80			out (storage_adata),a 
010b 00				nop 
010c			 
010c			 
010c			    ; read DO  
010c			 
010c cb e9		    set 5,c 
010e db 80			in a,(storage_adata) 
0110 cb 77		    bit SPI_DO,a 
0112 20 02		    jr nz, .b5 
0114 cb a9		    res 5,c 
0116			.b5: 
0116				; then low 
0116 cb af			res SPI_SCLK,a 
0118 d3 80			out (storage_adata),a 
011a 00				nop 
011b				; clock bit high 
011b cb ef			set SPI_SCLK,a 
011d d3 80			out (storage_adata),a 
011f 00				nop 
0120			 
0120			    ; read DO  
0120			 
0120 cb e1		    set 4,c 
0122 db 80			in a,(storage_adata) 
0124 cb 77		    bit SPI_DO,a 
0126 20 02		    jr nz, .b4 
0128 cb a1		    res 4,c 
012a			.b4: 
012a				; then low 
012a cb af			res SPI_SCLK,a 
012c d3 80			out (storage_adata),a 
012e 00				nop 
012f				; clock bit high 
012f cb ef			set SPI_SCLK,a 
0131 d3 80			out (storage_adata),a 
0133 00				nop 
0134			 
0134			    ; read DO  
0134			 
0134 cb d9		    set 3,c 
0136 db 80			in a,(storage_adata) 
0138 cb 77		    bit SPI_DO,a 
013a 20 02		    jr nz, .b3 
013c cb 99		    res 3,c 
013e			.b3: 
013e				; then low 
013e cb af			res SPI_SCLK,a 
0140 d3 80			out (storage_adata),a 
0142 00				nop 
0143				; clock bit high 
0143 cb ef			set SPI_SCLK,a 
0145 d3 80			out (storage_adata),a 
0147 00				nop 
0148			 
0148			    ; read DO  
0148			 
0148 cb d1		    set 2,c 
014a db 80			in a,(storage_adata) 
014c cb 77		    bit SPI_DO,a 
014e 20 02		    jr nz, .b2 
0150 cb 91		    res 2,c 
0152			.b2: 
0152				; then low 
0152 cb af			res SPI_SCLK,a 
0154 d3 80			out (storage_adata),a 
0156 00				nop 
0157				; clock bit high 
0157 cb ef			set SPI_SCLK,a 
0159 d3 80			out (storage_adata),a 
015b 00				nop 
015c			 
015c			    ; read DO  
015c			 
015c cb c9		    set 1,c 
015e db 80			in a,(storage_adata) 
0160 cb 77		    bit SPI_DO,a 
0162 20 02		    jr nz, .b1 
0164 cb 89		    res 1,c 
0166			.b1: 
0166				; then low 
0166 cb af			res SPI_SCLK,a 
0168 d3 80			out (storage_adata),a 
016a 00				nop 
016b				; clock bit high 
016b cb ef			set SPI_SCLK,a 
016d d3 80			out (storage_adata),a 
016f 00				nop 
0170			 
0170			    ; read DO  
0170			 
0170 cb c1		    set 0,c 
0172 db 80			in a,(storage_adata) 
0174 cb 77		    bit SPI_DO,a 
0176 20 02		    jr nz, .b0 
0178 cb 81		    res 0,c 
017a			.b0: 
017a				; then low 
017a cb af			res SPI_SCLK,a 
017c d3 80			out (storage_adata),a 
017e 00				nop 
017f			 
017f			 
017f 32 cf f9			ld (spi_portbyte),a 
0182			 
0182			    ; return byte 
0182 79			    ld a,c 
0183			 
0183			 
0183 c9				ret 
0184			 
0184			 
0184			 
0184			spi_ce_high: 
0184			 
0184				if DEBUG_SPI_HARD_CE0 
0184			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0184					ret 
0184			 
0184				endif 
0184			 
0184			 
0184 f5				push af 
0185			 
0185				; send direct ce to port b 
0185 3e ff			ld a, 255 
0187 d3 81			out (storage_bdata), a 
0189			 
0189 f1				pop af 
018a			 
018a				; for port a that shares with spi lines AND the mask 
018a			  
018a				if DEBUG_SPI 
018a					push hl 
018a					ld h, a 
018a				endif 
018a			;	ld c, SPI_CE_HIGH 
018a			;	and c 
018a cb c7			set SPI_CE0, a 
018c cb cf			set SPI_CE1, a 
018e cb d7			set SPI_CE2, a 
0190 cb df			set SPI_CE3, a 
0192 cb e7			set SPI_CE4, a 
0194			 
0194				if DEBUG_SPI 
0194					ld l, a 
0194					DMARK "CEh" 
0194					CALLMONITOR 
0194					pop hl 
0194				endif 
0194 c9				ret 
0195			 
0195			 
0195			spi_ce_low: 
0195			 
0195				if DEBUG_SPI_HARD_CE0 
0195			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0195					ret 
0195			 
0195				endif 
0195			 
0195 c5				push bc 
0196 f5				push af 
0197			 
0197				; send direct ce to port b 
0197 3a d1 f9			ld a, (spi_cartdev) 
019a d3 81			out (storage_bdata), a 
019c			 
019c			 
019c			 
019c				; for port a that shares with spi lines AND the mask 
019c			 
019c 3a ce f9			ld a, (spi_device)  
019f 4f				ld c, a 
01a0			 
01a0 f1				pop af 
01a1			 
01a1				; detect CEx 
01a1			 
01a1				if DEBUG_SPI 
01a1					push hl 
01a1					ld h, a 
01a1				endif 
01a1			 
01a1 cb 41			bit SPI_CE0, c 
01a3 20 04			jr nz, .cel1 
01a5 cb 87			res SPI_CE0, a 
01a7 18 1e			jr .celn 
01a9			.cel1: 
01a9 cb 49			bit SPI_CE1, c 
01ab 20 04			jr nz, .cel2 
01ad cb 8f			res SPI_CE1, a 
01af 18 16			jr .celn 
01b1			.cel2: 
01b1 cb 51			bit SPI_CE2, c 
01b3 20 04			jr nz, .cel3 
01b5 cb 97			res SPI_CE2, a 
01b7 18 0e			jr .celn 
01b9			.cel3: 
01b9 cb 59			bit SPI_CE3, c 
01bb 20 04			jr nz, .cel4 
01bd cb 9f			res SPI_CE3, a 
01bf 18 06			jr .celn 
01c1			.cel4: 
01c1 cb 61			bit SPI_CE4, c 
01c3 20 02			jr nz, .celn 
01c5 cb a7			res SPI_CE4, a 
01c7			.celn: 
01c7			 
01c7			 
01c7			 
01c7			;	add c 
01c7			 
01c7				if DEBUG_SPI 
01c7					ld l, a 
01c7					DMARK "CEl" 
01c7					CALLMONITOR 
01c7					pop hl 
01c7				endif 
01c7 c1				pop bc 
01c8 c9				ret 
01c9			 
01c9			 
01c9			 
01c9			; eof 
01c9			 
01c9			 
01c9			 
01c9			 
01c9			 
# End of file firmware_spi.asm
01c9				include "firmware_seeprom.asm"  
01c9			; 
01c9			; persisent storage interface via microchip serial eeprom 
01c9			 
01c9			; port a pio 2 
01c9			; pa 7 - si 
01c9			; pa 6 - sclk  
01c9			; pa 5 - so 
01c9			; pa 4 - cs 
01c9			; pa 3 - cs 
01c9			; pa 2 - cs 
01c9			; pa 1 - cs 
01c9			; pa 0 - cs 
01c9			; 
01c9			; TODO get block 
01c9			; TODO save block 
01c9			; TODO load file 
01c9			; TODO save file 
01c9			; TODO get dir  
01c9			 
01c9			;  
01c9			storage_adata: equ Device_C    ; device c port a - onboard storage 
01c9			storage_actl: equ Device_C+2     ; device c port a 
01c9			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01c9			storage_bctl: equ Device_C+3     ; device c port b 
01c9			 
01c9			 
01c9			; TODO move these to hardware driver file 
01c9			 
01c9			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01c9			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01c9			; storage bank file system format 
01c9			; 
01c9			; first page of bank: 
01c9			; 	addr 0 - status check 
01c9			;       addr 1 - write protect flag 
01c9			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01c9			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01c9			;         TODO see if scanning whole of for available next file id is fast enough 
01c9			;	addr 4 > zero term string of bank label 
01c9			; 
01c9			;        
01c9			;  
01c9			; first page of any file: 
01c9			;      byte 0 - file id  
01c9			;      byte 1-17 - fixed file name  
01c9			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01c9			; 
01c9			; other pages of any file: 
01c9			;      byte 0 - file id 
01c9			;      byte 1> - file data 
01c9			; 
01c9			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01c9			;  
01c9			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01c9			 
01c9			 
01c9			;storage_so_bit: 5 
01c9			;storage_si_bit: 7 
01c9			;storage_sclk_bit: 6 
01c9			  
01c9			 
01c9			; init storage pio 
01c9			 
01c9			storage_init: 
01c9			 
01c9 3e cf		            LD   A, 11001111b 
01cb d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01cd 3e 00		            LD   A, 00000000b 
01cf cb f7			set SPI_DO,a 
01d1			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d1 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d3			 
01d3 3e cf		            LD   A, 11001111b 
01d5 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01d7 3e 00		            LD   A, 00000000b 
01d9 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01db			 
01db				; set all external spi devices off 
01db 3e 00			ld a, 0 
01dd 32 ce f9			ld (spi_device), a 
01e0 32 d1 f9			ld (spi_cartdev), a 
01e3			 
01e3					; ensure the spi bus is in a default stable state 
01e3 cd ae 00				call se_stable_spi 
01e6			 
01e6			; TODO scan spi bus and gather which storage banks are present 
01e6			 
01e6			; populate store_bank_active  
01e6			; for each ce line activate and attempt to write first byte of bank and read back 
01e6			; if zero is returned then bank is empty 
01e6			;   
01e6			; 
01e6			 
01e6					; init file extent cache to save on slow reads 
01e6			 
01e6			;	ld hl, store_filecache 
01e6			;	ld de, 0 
01e6			;	ld hl,(de)	 
01e6			 
01e6			 
01e6 c9			    ret 
01e7			 
01e7			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01e7			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01e7			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01e7			 
01e7			; INSTRUCTION SET 
01e7			; READ 0000 0011 Read data from memory array beginning at selected address 
01e7			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01e7			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01e7			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01e7			; RDSR 0000 0101 Read STATUS register 
01e7			; WRSR 0000 0001 Write STATUS register 
01e7			; PE 0100 0010 Page Erase – erase one page in memory array 
01e7			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01e7			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01e7			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01e7			 
01e7			; TODO send byte steam for page without setting the address for every single byte 
01e7			; TODO read byte  
01e7			 
01e7			; byte in a 
01e7			; address in hl  
01e7			se_writebyte: 
01e7			        
01e7			    ;   ld c, a 
01e7 f5			        push af 
01e8 e5			        push hl 
01e9			 
01e9			    ; initi write mode 
01e9			    ; 
01e9			    ;CS low 
01e9			 
01e9 3a cf f9		       ld a,(spi_portbyte) 
01ec cd 95 01			call spi_ce_low 
01ef			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ef d3 80		       out (storage_adata),a 
01f1 32 cf f9		       ld (spi_portbyte), a 
01f4			 
01f4			    ;clock out wren instruction 
01f4			 
01f4 3e 06		    ld a, store_wren_ins 
01f6 cd b9 00		    call spi_send_byte  
01f9			 
01f9			    ;cs high to enable write latch 
01f9			 
01f9 3a cf f9		       ld a,(spi_portbyte) 
01fc cd 84 01			call spi_ce_high 
01ff			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01ff d3 80		       out (storage_adata),a 
0201 32 cf f9		       ld (spi_portbyte), a 
0204			 
0204 00				nop 
0205			    ; 
0205			    ; intial write data 
0205			    ; 
0205			    ; cs low 
0205			     
0205 3a cf f9		       ld a,(spi_portbyte) 
0208 cd 95 01			call spi_ce_low 
020b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020b d3 80		       out (storage_adata),a 
020d 32 cf f9		       ld (spi_portbyte), a 
0210			 
0210			    ; clock out write instruction 
0210			     
0210 3e 02		    ld a, store_write_ins  
0212 cd b9 00		    call spi_send_byte  
0215			 
0215			    ; clock out address (depending on address size) 
0215			     
0215 e1			    pop hl 
0216 7c			    ld a,h    ; address out msb first 
0217 cd b9 00		    call spi_send_byte  
021a 7d			    ld a,l 
021b cd b9 00		    call spi_send_byte  
021e			 
021e			    ; clock out byte(s) for page 
021e			 
021e f1			    pop af 
021f cd b9 00		    call spi_send_byte  
0222			 
0222			    ; end write with ce high 
0222 3a cf f9		       ld a,(spi_portbyte) 
0225			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0225 cd 84 01			call spi_ce_high 
0228 d3 80		       out (storage_adata),a 
022a 32 cf f9		       ld (spi_portbyte), a 
022d			 
022d				; pause for internal write cycle 
022d 3e 0a			ld a, 10 
022f cd 37 0a			call aDelayInMS 
0232 c9			    ret 
0233			 
0233			; buffer to write in de 
0233			; address in hl  
0233			se_writepage: 
0233			        
0233			    ;   ld c, a 
0233 d5				push de 
0234 e5			        push hl 
0235			 
0235			    ; initi write mode 
0235			    ; 
0235			    ;CS low 
0235			 
0235 3a cf f9		       ld a,(spi_portbyte) 
0238 cd 95 01			call spi_ce_low 
023b			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023b d3 80		       out (storage_adata),a 
023d 32 cf f9		       ld (spi_portbyte), a 
0240			 
0240			    ;clock out wren instruction 
0240			 
0240 3e 06		    ld a, store_wren_ins 
0242 cd b9 00		    call spi_send_byte  
0245			 
0245			    ;cs high to enable write latch 
0245			 
0245 3a cf f9		       ld a,(spi_portbyte) 
0248 cd 84 01			call spi_ce_high 
024b			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024b d3 80		       out (storage_adata),a 
024d 32 cf f9		       ld (spi_portbyte), a 
0250			 
0250 00				nop 
0251			    ; 
0251			    ; intial write data 
0251			    ; 
0251			    ; cs low 
0251			     
0251 3a cf f9		       ld a,(spi_portbyte) 
0254			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0254 cd 95 01			call spi_ce_low 
0257 d3 80		       out (storage_adata),a 
0259 32 cf f9		       ld (spi_portbyte), a 
025c			 
025c			    ; clock out write instruction 
025c			     
025c 3e 02		    ld a, store_write_ins  
025e cd b9 00		    call spi_send_byte  
0261			 
0261			    ; clock out address (depending on address size) 
0261			     
0261 e1			    pop hl 
0262 7c			    ld a,h    ; address out msb first 
0263 cd b9 00		    call spi_send_byte  
0266 7d			    ld a,l 
0267 cd b9 00		    call spi_send_byte  
026a			 
026a			    ; clock out byte(s) for page 
026a			 
026a e1				pop hl 
026b 06 40			ld b, STORE_BLOCK_PHY 
026d			.bytewrite: 
026d			 
026d 7e				ld a,(hl) 
026e e5			    push hl 
026f c5				push bc 
0270 cd b9 00		    call spi_send_byte  
0273 c1				pop bc 
0274 e1				pop hl 
0275			 
0275			    ; end write with ce high 
0275 3a cf f9		       ld a,(spi_portbyte) 
0278 cd 84 01			call spi_ce_high 
027b			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027b d3 80		       out (storage_adata),a 
027d 32 cf f9		       ld (spi_portbyte), a 
0280			 
0280 23				inc hl 
0281 10 ea			djnz .bytewrite 
0283			 
0283				; pause for internal write cycle 
0283 3e 64			ld a, 100 
0285 cd 37 0a			call aDelayInMS 
0288 c9			    ret 
0289			; returns byte in a 
0289			; address in hl  
0289			se_readbyte: 
0289 d5				push de 
028a c5				push bc 
028b			 
028b			    ;   ld c, a 
028b e5			        push hl 
028c			 
028c			    ; initi write mode 
028c			    ; 
028c			    ;CS low 
028c			 
028c 3a cf f9		       ld a,(spi_portbyte) 
028f cd 95 01			call spi_ce_low 
0292			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0292 d3 80		       out (storage_adata),a 
0294 32 cf f9		       ld (spi_portbyte), a 
0297			 
0297			    ;clock out wren instruction 
0297			 
0297 3e 03		    ld a, store_read_ins 
0299 cd b9 00		    call spi_send_byte  
029c			 
029c			 
029c			    ; clock out address (depending on address size) 
029c			     
029c e1			    pop hl 
029d 7c			    ld a,h    ; address out msb first 
029e cd b9 00		    call spi_send_byte  
02a1 7d			    ld a,l 
02a2 cd b9 00		    call spi_send_byte  
02a5			 
02a5			    ; clock in byte(s) for page 
02a5			 
02a5 cd da 00		    call spi_read_byte  
02a8 f5				push af 
02a9			 
02a9			    ; end write with ce high 
02a9 3a cf f9		       ld a,(spi_portbyte) 
02ac			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02ac cd 84 01			call spi_ce_high 
02af d3 80		       out (storage_adata),a 
02b1 32 cf f9		       ld (spi_portbyte), a 
02b4			 
02b4 f1				pop af 
02b5			 
02b5 c1				pop bc 
02b6 d1				pop de 
02b7			 
02b7 c9			    ret 
02b8			 
02b8			if DEBUG_STORESE 
02b8			 
02b8			storageput:  
02b8			 
02b8			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02b8			 
02b8 21 a5 ef			ld hl,scratch+2 
02bb cd bd 10			call get_word_hl 
02be			 
02be				; stuff it here for the moment as it will be overwritten later anyway 
02be			 
02be 22 c6 f2			ld (os_cur_ptr),hl	 
02c1			 
02c1			 
02c1			; get pointer to start of string 
02c1			 
02c1 21 aa ef			ld hl, scratch+7 
02c4			 
02c4			; loop writing char of string to eeprom 
02c4			 
02c4 7e			.writestr:	ld a,(hl) 
02c5 fe 00				cp 0 
02c7 28 12				jr z, .wsdone		; done writing 
02c9 e5					push hl 
02ca 2a c6 f2				ld hl,(os_cur_ptr) 
02cd cd e7 01				call se_writebyte 
02d0			 
02d0 2a c6 f2				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d3 23					inc hl 
02d4 22 c6 f2				ld (os_cur_ptr),hl 
02d7			 
02d7					; restore string pointer and get next char 
02d7			 
02d7 e1					pop hl 
02d8 23					inc hl 
02d9 18 e9				jr .writestr 
02db			 
02db			 
02db			 
02db			.wsdone: 
02db			 
02db			 
02db			; when done load first page into a buffer  
02db			 
02db 21 00 80				ld hl,08000h		; start in ram 
02de 22 c6 f2				ld (os_cur_ptr),hl 
02e1 21 00 00				ld hl, 0		 ; start of page 
02e4 22 cb ef				ld (scratch+40),hl	; hang on to it 
02e7			 
02e7 06 80				ld b, 128		; actually get more then one page 
02e9 c5			.wsload:	push bc 
02ea 2a cb ef				ld hl,(scratch+40) 
02ed e5					push hl 
02ee cd 89 02				call se_readbyte 
02f1			 
02f1					; a now as the byte 
02f1			 
02f1 2a c6 f2				ld hl,(os_cur_ptr) 
02f4 77					ld (hl),a 
02f5					; inc next buffer area 
02f5 23					inc hl 
02f6 22 c6 f2				ld (os_cur_ptr),hl 
02f9			 
02f9					; get eeprom position, inc and save for next round 
02f9 e1					pop hl		 
02fa 23					inc hl 
02fb 22 cb ef				ld (scratch+40),hl 
02fe c1					pop bc 
02ff 10 e8				djnz .wsload 
0301			 
0301			; set 'd' pointer to start of buffer 
0301			 
0301 21 00 80				ld hl,08000h 
0304 22 c6 f2				ld (os_cur_ptr),hl 
0307			 
0307			 
0307 c9			ret 
0308			 
0308			 
0308 c9			storageread: ret 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			 
0309			endif 
0309			 
0309			 
0309			 
# End of file firmware_seeprom.asm
0309			else  
0309			   ; create some stubs for the labels  
0309			se_readbyte: ret  
0309			se_writebyte: ret  
0309			storage_init: ret  
0309			  
0309			endif  
0309			  
0309			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0309			;include "firmware_cf.asm"  
0309			  
0309			; load up high level storage hardward abstractions  
0309			include "firmware_storage.asm"  
0309			 
0309			; persisent storage hardware abstraction layer  
0309			 
0309			 
0309			 
0309			; Block 0 on storage is a config state 
0309			 
0309			 
0309			 
0309			; TODO add read phy block and write phy block functions 
0309			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0309			 
0309			; Abstraction layer  
0309			 
0309			; Logocial block size is same size as physical size - using tape concept 
0309			 
0309			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0309			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0309			 
0309			 
0309			 
0309			; Filesystem layout (Logical layout) 
0309			; 
0309			; Block 0 - Bank config  
0309			; 
0309			;      Byte - 0 file id counter 
0309			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0309			;      Byte - 3-20 zero terminated bank label 
0309			; 
0309			; Block 1 > File storage 
0309			; 
0309			;      Byte 0 file id    - block 0 file details 
0309			;      Byte 1 block id - block 0 is file  
0309			;            Byte 2-15 - File name 
0309			; 
0309			;       - to end of block data 
0309			; 
0309			 
0309			 
0309			; Read Block 
0309			; ---------- 
0309			; 
0309			; With current bank 
0309			;  
0309			; Get block number to read 
0309			; Load physical blocks starting at start block into buffer 
0309			 
0309			; de points to buffer to use 
0309			; hl holds logical block number  
0309			 
0309			storage_read_block: 
0309			 
0309				; TODO bank selection 
0309			 
0309				; for each of the physical blocks read it into the buffer 
0309 06 40			ld b, STORE_BLOCK_PHY 
030b			 
030b				if DEBUG_STORESE 
030b d5					push de 
030c				endif 
030c				 
030c			.rl1:    
030c			 
030c				; read physical block at hl into de 
030c			        ; increment hl and de to next read position on exit 
030c			 
030c e5				push hl 
030d d5				push de	 
030e c5				push bc 
030f			;	if DEBUG_STORESE 
030f			;		push af 
030f			;		ld a, 'R' 
030f			;		ld (debug_mark),a 
030f			;		pop af 
030f			;		CALLMONITOR 
030f			;	endif 
030f cd 89 02			call se_readbyte 
0312			;	if DEBUG_STORESE 
0312			;		ld a,(spi_portbyte) 
0312			;		ld l, a 
0312			;		push af 
0312			;		ld a, '1' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 c1				pop bc 
0313 d1				pop de 
0314 e1				pop hl 
0315 12				ld (de),a 
0316 23				inc hl 
0317 13				inc de 
0318			 
0318			;	if DEBUG_STORESE 
0318			;		push af 
0318			;		ld a, 'r' 
0318			;		ld (debug_mark),a 
0318			;		pop af 
0318			;		CALLMONITOR 
0318			;	endif 
0318			 
0318 10 f2			djnz .rl1 
031a			 
031a				if DEBUG_STORESE 
031a					DMARK "SRB" 
031a f5				push af  
031b 3a 2f 03			ld a, (.dmark)  
031e 32 bd fb			ld (debug_mark),a  
0321 3a 30 03			ld a, (.dmark+1)  
0324 32 be fb			ld (debug_mark+1),a  
0327 3a 31 03			ld a, (.dmark+2)  
032a 32 bf fb			ld (debug_mark+2),a  
032d 18 03			jr .pastdmark  
032f ..			.dmark: db "SRB"  
0332 f1			.pastdmark: pop af  
0333			endm  
# End of macro DMARK
0333 d1					pop de 
0334			; 
0334			;		push af 
0334			;		ld a, 'R' 
0334			;		ld (debug_mark),a 
0334			;		pop af 
0334					CALLMONITOR 
0334 cd 6a 16			call break_point_state  
0337				endm  
# End of macro CALLMONITOR
0337				endif 
0337 c9				ret	 
0338				 
0338			 
0338			; File Size 
0338			; --------- 
0338			; 
0338			;   hl file id 
0338			; 
0338			;  returns in hl the number of blocks 
0338			 
0338			storage_file_size: 
0338 5d				ld e, l 
0339 16 00			ld d, 0 
033b 21 40 00			ld hl, STORE_BLOCK_PHY 
033e					if DEBUG_FORTH_WORDS 
033e						DMARK "SIZ" 
033e f5				push af  
033f 3a 53 03			ld a, (.dmark)  
0342 32 bd fb			ld (debug_mark),a  
0345 3a 54 03			ld a, (.dmark+1)  
0348 32 be fb			ld (debug_mark+1),a  
034b 3a 55 03			ld a, (.dmark+2)  
034e 32 bf fb			ld (debug_mark+2),a  
0351 18 03			jr .pastdmark  
0353 ..			.dmark: db "SIZ"  
0356 f1			.pastdmark: pop af  
0357			endm  
# End of macro DMARK
0357						CALLMONITOR 
0357 cd 6a 16			call break_point_state  
035a				endm  
# End of macro CALLMONITOR
035a					endif 
035a cd 2a 06			call storage_findnextid 
035d			 
035d cd 2f 0d			call ishlzero 
0360			;	ld a, l 
0360			;	add h 
0360			;	cp 0 
0360 c8				ret z			; block not found so EOF 
0361			 
0361 11 e8 f9			ld de, store_page 
0364 cd 09 03			call storage_read_block 
0367			 
0367 3a ea f9			ld a, (store_page+2)	 ; get extent count 
036a 6f				ld l, a 
036b 26 00			ld h, 0 
036d c9			 	ret 
036e			 
036e			 
036e			; Write Block 
036e			; ----------- 
036e			; 
036e			; With current bank 
036e			;  
036e			; Get block number to write 
036e			; Write physical blocks starting at start block from buffer 
036e			  
036e			storage_write_block: 
036e				; TODO bank selection 
036e			 
036e				; for each of the physical blocks read it into the buffer 
036e 06 40			ld b, STORE_BLOCK_PHY 
0370			 
0370				if DEBUG_STORESE 
0370					DMARK "SWB" 
0370 f5				push af  
0371 3a 85 03			ld a, (.dmark)  
0374 32 bd fb			ld (debug_mark),a  
0377 3a 86 03			ld a, (.dmark+1)  
037a 32 be fb			ld (debug_mark+1),a  
037d 3a 87 03			ld a, (.dmark+2)  
0380 32 bf fb			ld (debug_mark+2),a  
0383 18 03			jr .pastdmark  
0385 ..			.dmark: db "SWB"  
0388 f1			.pastdmark: pop af  
0389			endm  
# End of macro DMARK
0389			 
0389					;push af 
0389					;ld a, 'W' 
0389					;ld (debug_mark),a 
0389					;pop af 
0389					CALLMONITOR 
0389 cd 6a 16			call break_point_state  
038c				endm  
# End of macro CALLMONITOR
038c				endif 
038c			 
038c			; might not be working 
038c			;	call se_writepage 
038c			 
038c			;	ret 
038c			; 
038c			 
038c			 
038c			 
038c			.wl1:    
038c			 
038c				; read physical block at hl into de 
038c			        ; increment hl and de to next read position on exit 
038c			 
038c e5				push hl 
038d d5				push de	 
038e c5				push bc 
038f 1a				ld a,(de) 
0390				;if DEBUG_STORESE 
0390			;		push af 
0390			;		ld a, 'W' 
0390			;		ld (debug_mark),a 
0390			;		pop af 
0390			;		CALLMONITOR 
0390			;	endif 
0390 cd e7 01			call se_writebyte 
0393			;	call delay250ms 
0393 00				nop 
0394 00				nop 
0395 00				nop 
0396			;	if DEBUG_STORESE 
0396			;		push af 
0396			;		ld a, 'w' 
0396			;		ld (debug_mark),a 
0396			;		pop af 
0396			;		CALLMONITOR 
0396			;	endif 
0396 c1				pop bc 
0397 d1				pop de 
0398 e1				pop hl 
0399 23				inc hl 
039a 13				inc de 
039b			 
039b			 
039b 10 ef			djnz .wl1 
039d			 
039d				if DEBUG_STORESE 
039d					DMARK "SW2" 
039d f5				push af  
039e 3a b2 03			ld a, (.dmark)  
03a1 32 bd fb			ld (debug_mark),a  
03a4 3a b3 03			ld a, (.dmark+1)  
03a7 32 be fb			ld (debug_mark+1),a  
03aa 3a b4 03			ld a, (.dmark+2)  
03ad 32 bf fb			ld (debug_mark+2),a  
03b0 18 03			jr .pastdmark  
03b2 ..			.dmark: db "SW2"  
03b5 f1			.pastdmark: pop af  
03b6			endm  
# End of macro DMARK
03b6			 
03b6					;push af 
03b6					;ld a, 'W' 
03b6					;ld (debug_mark),a 
03b6					;pop af 
03b6					CALLMONITOR 
03b6 cd 6a 16			call break_point_state  
03b9				endm  
# End of macro CALLMONITOR
03b9				endif 
03b9 c9				ret	 
03ba			 
03ba			; Init bank 
03ba			; --------- 
03ba			; 
03ba			; With current bank 
03ba			; 
03ba			; Setup block 0 config 
03ba			;     Set 0 file id counter 
03ba			;     Set formatted byte pattern 
03ba			;     Zero out bank label 
03ba			;      
03ba			; For every logical block write 0-1 byte as null 
03ba			 
03ba			storage_get_block_0: 
03ba			 
03ba				; TODO check presence 
03ba			 
03ba				; get block 0 config 
03ba			 
03ba 21 00 00			ld hl, 0 
03bd 11 e8 f9			ld de, store_page 
03c0 cd 09 03			call storage_read_block 
03c3			 
03c3				if DEBUG_STORESE 
03c3					DMARK "SB0" 
03c3 f5				push af  
03c4 3a d8 03			ld a, (.dmark)  
03c7 32 bd fb			ld (debug_mark),a  
03ca 3a d9 03			ld a, (.dmark+1)  
03cd 32 be fb			ld (debug_mark+1),a  
03d0 3a da 03			ld a, (.dmark+2)  
03d3 32 bf fb			ld (debug_mark+2),a  
03d6 18 03			jr .pastdmark  
03d8 ..			.dmark: db "SB0"  
03db f1			.pastdmark: pop af  
03dc			endm  
# End of macro DMARK
03dc 11 e8 f9				ld de, store_page 
03df			;		push af 
03df			;		ld a, 'i' 
03df			;		ld (debug_mark),a 
03df			;		pop af 
03df					CALLMONITOR 
03df cd 6a 16			call break_point_state  
03e2				endm  
# End of macro CALLMONITOR
03e2				endif 
03e2			 
03e2				; is this area formatted? 
03e2			 
03e2			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e2 2a e9 f9			ld hl, (store_page+1) 
03e5 3e 80			ld a,0x80 
03e7 bd				cp l 
03e8 20 22			jr nz, .ininotformatted 
03ea				; do a double check 
03ea 3e 27			ld a, 0x27 
03ec bc				cp h 
03ed 20 1d			jr nz, .ininotformatted 
03ef			 
03ef				; formatted then 
03ef			 
03ef				if DEBUG_STORESE 
03ef					DMARK "SB1" 
03ef f5				push af  
03f0 3a 04 04			ld a, (.dmark)  
03f3 32 bd fb			ld (debug_mark),a  
03f6 3a 05 04			ld a, (.dmark+1)  
03f9 32 be fb			ld (debug_mark+1),a  
03fc 3a 06 04			ld a, (.dmark+2)  
03ff 32 bf fb			ld (debug_mark+2),a  
0402 18 03			jr .pastdmark  
0404 ..			.dmark: db "SB1"  
0407 f1			.pastdmark: pop af  
0408			endm  
# End of macro DMARK
0408					;push af 
0408					;ld a, 'I' 
0408					;ld (debug_mark),a 
0408					;pop af 
0408					CALLMONITOR 
0408 cd 6a 16			call break_point_state  
040b				endm  
# End of macro CALLMONITOR
040b				endif 
040b c9				ret 
040c			 
040c			.ininotformatted: 
040c				; bank not formatted so poke various bits to make sure 
040c			 
040c				if DEBUG_STORESE 
040c					DMARK "SB2" 
040c f5				push af  
040d 3a 21 04			ld a, (.dmark)  
0410 32 bd fb			ld (debug_mark),a  
0413 3a 22 04			ld a, (.dmark+1)  
0416 32 be fb			ld (debug_mark+1),a  
0419 3a 23 04			ld a, (.dmark+2)  
041c 32 bf fb			ld (debug_mark+2),a  
041f 18 03			jr .pastdmark  
0421 ..			.dmark: db "SB2"  
0424 f1			.pastdmark: pop af  
0425			endm  
# End of macro DMARK
0425					;push af 
0425					;ld a, 'f' 
0425					;ld (debug_mark),a 
0425					;pop af 
0425					CALLMONITOR 
0425 cd 6a 16			call break_point_state  
0428				endm  
# End of macro CALLMONITOR
0428				endif 
0428			 
0428 cd 15 0a			call storage_clear_page 
042b			 
042b 21 e8 f9			ld hl, store_page 
042e 3e 00			ld a, 0 
0430				 
0430 77				ld (hl),a   ; reset file counter 
0431			 
0431 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0434 22 e9 f9		 	ld (store_page+1), hl	 
0437			 
0437				; set default label 
0437			 
0437 21 d3 04			ld hl, .defaultbanklabl 
043a 11 eb f9		 	ld de, store_page+3 
043d 01 0f 00			ld bc, 15 
0440 ed b0			ldir 
0442			 
0442				; Append the current bank id 
0442 21 f4 f9			ld hl, store_page+3+9 
0445 3a cd f9			ld a, (spi_device_id) 
0448 77				ld (hl), a 
0449			 
0449				; save default page 0 
0449			 
0449 21 00 00			ld hl, 0 
044c 11 e8 f9			ld de, store_page 
044f				if DEBUG_STORESE 
044f					DMARK "SB3" 
044f f5				push af  
0450 3a 64 04			ld a, (.dmark)  
0453 32 bd fb			ld (debug_mark),a  
0456 3a 65 04			ld a, (.dmark+1)  
0459 32 be fb			ld (debug_mark+1),a  
045c 3a 66 04			ld a, (.dmark+2)  
045f 32 bf fb			ld (debug_mark+2),a  
0462 18 03			jr .pastdmark  
0464 ..			.dmark: db "SB3"  
0467 f1			.pastdmark: pop af  
0468			endm  
# End of macro DMARK
0468			;		push af 
0468			;		ld a, 'F' 
0468			;		ld (debug_mark),a 
0468			;		pop af 
0468					CALLMONITOR 
0468 cd 6a 16			call break_point_state  
046b				endm  
# End of macro CALLMONITOR
046b				endif 
046b cd 6e 03			call storage_write_block 
046e				if DEBUG_STORESE 
046e					DMARK "SB4" 
046e f5				push af  
046f 3a 83 04			ld a, (.dmark)  
0472 32 bd fb			ld (debug_mark),a  
0475 3a 84 04			ld a, (.dmark+1)  
0478 32 be fb			ld (debug_mark+1),a  
047b 3a 85 04			ld a, (.dmark+2)  
047e 32 bf fb			ld (debug_mark+2),a  
0481 18 03			jr .pastdmark  
0483 ..			.dmark: db "SB4"  
0486 f1			.pastdmark: pop af  
0487			endm  
# End of macro DMARK
0487			;		push af 
0487			;		ld a, '>' 
0487			;		ld (debug_mark),a 
0487			;		pop af 
0487					CALLMONITOR 
0487 cd 6a 16			call break_point_state  
048a				endm  
# End of macro CALLMONITOR
048a				endif 
048a			 
048a 00				nop 
048b 00				nop 
048c 00				nop 
048d			 
048d				; now set 0 in every page to mark as a free block 
048d			 
048d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
048f 21 40 00			ld hl, STORE_BLOCK_PHY 
0492			 
0492 3e 00		.setmark1:   	ld a,0 
0494 e5					push hl 
0495 c5					push bc 
0496 cd e7 01				call se_writebyte 
0499 3e 0a			ld a, 10 
049b cd 37 0a			call aDelayInMS 
049e 23				inc hl 
049f cd e7 01				call se_writebyte 
04a2 3e 0a			ld a, 10 
04a4 cd 37 0a			call aDelayInMS 
04a7 2b				dec hl 
04a8 c1					pop bc 
04a9 e1					pop hl 
04aa 3e 40				ld a, STORE_BLOCK_PHY 
04ac cd 06 0d				call addatohl 
04af 10 e1				djnz .setmark1 
04b1			 
04b1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04b3 3e 00		.setmark2:   	ld a,0 
04b5 e5					push hl 
04b6 c5					push bc 
04b7 cd e7 01				call se_writebyte 
04ba 3e 0a			ld a, 10 
04bc cd 37 0a			call aDelayInMS 
04bf 23				inc hl 
04c0 cd e7 01				call se_writebyte 
04c3 3e 0a			ld a, 10 
04c5 cd 37 0a			call aDelayInMS 
04c8 2b				dec hl 
04c9 c1					pop bc 
04ca e1					pop hl 
04cb 3e 40				ld a, STORE_BLOCK_PHY 
04cd cd 06 0d				call addatohl 
04d0 10 e1				djnz .setmark2 
04d2			 
04d2					 
04d2			 
04d2			 
04d2 c9				ret 
04d3			 
04d3			 
04d3			 
04d3			 
04d3 .. 00		.defaultbanklabl:   db "BankLabel_",0 
04de			 
04de			 
04de			 
04de			; Label Bank 
04de			; ---------- 
04de			; 
04de			; With current bank 
04de			; Read block 0 
04de			; Set label 
04de			; Write block 0 
04de			 
04de			; label str pointer in hl 
04de			 
04de			storage_label:     
04de			 
04de				if DEBUG_STORESE 
04de					DMARK "LBL" 
04de f5				push af  
04df 3a f3 04			ld a, (.dmark)  
04e2 32 bd fb			ld (debug_mark),a  
04e5 3a f4 04			ld a, (.dmark+1)  
04e8 32 be fb			ld (debug_mark+1),a  
04eb 3a f5 04			ld a, (.dmark+2)  
04ee 32 bf fb			ld (debug_mark+2),a  
04f1 18 03			jr .pastdmark  
04f3 ..			.dmark: db "LBL"  
04f6 f1			.pastdmark: pop af  
04f7			endm  
# End of macro DMARK
04f7					CALLMONITOR 
04f7 cd 6a 16			call break_point_state  
04fa				endm  
# End of macro CALLMONITOR
04fa				endif 
04fa			 
04fa e5				push hl 
04fb			 
04fb cd ba 03			call storage_get_block_0 
04fe			 
04fe				; set default label 
04fe			 
04fe e1				pop hl 
04ff			 
04ff 11 eb f9		 	ld de, store_page+3 
0502 01 0f 00			ld bc, 15 
0505				if DEBUG_STORESE 
0505					DMARK "LB3" 
0505 f5				push af  
0506 3a 1a 05			ld a, (.dmark)  
0509 32 bd fb			ld (debug_mark),a  
050c 3a 1b 05			ld a, (.dmark+1)  
050f 32 be fb			ld (debug_mark+1),a  
0512 3a 1c 05			ld a, (.dmark+2)  
0515 32 bf fb			ld (debug_mark+2),a  
0518 18 03			jr .pastdmark  
051a ..			.dmark: db "LB3"  
051d f1			.pastdmark: pop af  
051e			endm  
# End of macro DMARK
051e					CALLMONITOR 
051e cd 6a 16			call break_point_state  
0521				endm  
# End of macro CALLMONITOR
0521				endif 
0521 ed b0			ldir 
0523				; save default page 0 
0523			 
0523 21 00 00			ld hl, 0 
0526 11 e8 f9			ld de, store_page 
0529				if DEBUG_STORESE 
0529					DMARK "LBW" 
0529 f5				push af  
052a 3a 3e 05			ld a, (.dmark)  
052d 32 bd fb			ld (debug_mark),a  
0530 3a 3f 05			ld a, (.dmark+1)  
0533 32 be fb			ld (debug_mark+1),a  
0536 3a 40 05			ld a, (.dmark+2)  
0539 32 bf fb			ld (debug_mark+2),a  
053c 18 03			jr .pastdmark  
053e ..			.dmark: db "LBW"  
0541 f1			.pastdmark: pop af  
0542			endm  
# End of macro DMARK
0542					CALLMONITOR 
0542 cd 6a 16			call break_point_state  
0545				endm  
# End of macro CALLMONITOR
0545				endif 
0545 cd 6e 03			call storage_write_block 
0548			 
0548 c9				ret 
0549			 
0549			 
0549			 
0549			; Read Block 0 - Config 
0549			; --------------------- 
0549			; 
0549			; With current bank 
0549			; Call presence test 
0549			;    If not present format/init bank  
0549			; Read block 0  
0549			;  
0549			 
0549			 
0549			; Dir 
0549			; --- 
0549			; 
0549			; With current bank 
0549			; Load Block 0 Config 
0549			; Get max file id number 
0549			; For each logical block 
0549			;    Read block read byte 2 
0549			;      if first block of file 
0549			;         Display file name 
0549			;         Display type flags for file 
0549			;        
0549			 
0549			; moving to words as this requires stack control 
0549			 
0549			 
0549			; Delete File 
0549			; ----------- 
0549			; 
0549			; With current bank 
0549			; 
0549			; Load Block 0 Config 
0549			; Get max file id number 
0549			; For each logical block 
0549			;    Read block file id 
0549			;      If first block of file and dont have file id 
0549			;         if file to delete 
0549			;         Save file id 
0549			;         Null file id 
0549			;         Write this block back 
0549			;      If file id is one saved 
0549			;         Null file id 
0549			;         Write this block back 
0549			 
0549			storage_erase: 
0549			 
0549				; hl contains the file id 
0549			 
0549 5d				ld e, l 
054a 16 00			ld d, 0 
054c 21 40 00			ld hl, STORE_BLOCK_PHY 
054f					if DEBUG_FORTH_WORDS 
054f						DMARK "ERA" 
054f f5				push af  
0550 3a 64 05			ld a, (.dmark)  
0553 32 bd fb			ld (debug_mark),a  
0556 3a 65 05			ld a, (.dmark+1)  
0559 32 be fb			ld (debug_mark+1),a  
055c 3a 66 05			ld a, (.dmark+2)  
055f 32 bf fb			ld (debug_mark+2),a  
0562 18 03			jr .pastdmark  
0564 ..			.dmark: db "ERA"  
0567 f1			.pastdmark: pop af  
0568			endm  
# End of macro DMARK
0568						CALLMONITOR 
0568 cd 6a 16			call break_point_state  
056b				endm  
# End of macro CALLMONITOR
056b					endif 
056b cd 2a 06			call storage_findnextid 
056e			 
056e e5				push hl 
056f			 
056f				; TODO check file not found 
056f			 
056f 11 e8 f9			ld de, store_page 
0572 cd 09 03			call storage_read_block 
0575			 
0575					if DEBUG_FORTH_WORDS 
0575						DMARK "ER1" 
0575 f5				push af  
0576 3a 8a 05			ld a, (.dmark)  
0579 32 bd fb			ld (debug_mark),a  
057c 3a 8b 05			ld a, (.dmark+1)  
057f 32 be fb			ld (debug_mark+1),a  
0582 3a 8c 05			ld a, (.dmark+2)  
0585 32 bf fb			ld (debug_mark+2),a  
0588 18 03			jr .pastdmark  
058a ..			.dmark: db "ER1"  
058d f1			.pastdmark: pop af  
058e			endm  
# End of macro DMARK
058e						CALLMONITOR 
058e cd 6a 16			call break_point_state  
0591				endm  
# End of macro CALLMONITOR
0591					endif 
0591 3a e8 f9			ld a, (store_page)	; get file id 
0594 32 e1 f9			ld (store_tmpid), a 
0597			 
0597 3a ea f9			ld a, (store_page+2)    ; get count of extends 
059a 32 e0 f9			ld (store_tmpext), a 
059d			 
059d				; wipe file header 
059d			 
059d e1				pop hl 
059e 3e 00			ld a, 0 
05a0 32 e8 f9			ld (store_page), a 
05a3 32 e9 f9			ld (store_page+1),a 
05a6 11 e8 f9			ld de, store_page 
05a9					if DEBUG_FORTH_WORDS 
05a9						DMARK "ER2" 
05a9 f5				push af  
05aa 3a be 05			ld a, (.dmark)  
05ad 32 bd fb			ld (debug_mark),a  
05b0 3a bf 05			ld a, (.dmark+1)  
05b3 32 be fb			ld (debug_mark+1),a  
05b6 3a c0 05			ld a, (.dmark+2)  
05b9 32 bf fb			ld (debug_mark+2),a  
05bc 18 03			jr .pastdmark  
05be ..			.dmark: db "ER2"  
05c1 f1			.pastdmark: pop af  
05c2			endm  
# End of macro DMARK
05c2						CALLMONITOR 
05c2 cd 6a 16			call break_point_state  
05c5				endm  
# End of macro CALLMONITOR
05c5					endif 
05c5 cd 6e 03			call storage_write_block 
05c8			 
05c8			 
05c8				; wipe file extents 
05c8			 
05c8 3a e0 f9			ld a, (store_tmpext) 
05cb 47				ld b, a 
05cc			 
05cc			.eraext:	  
05cc c5				push bc 
05cd			 
05cd 21 40 00			ld hl, STORE_BLOCK_PHY 
05d0 3a e1 f9			ld a,(store_tmpid) 
05d3 5f				ld e, a 
05d4 50				ld d, b	 
05d5					if DEBUG_FORTH_WORDS 
05d5						DMARK "ER3" 
05d5 f5				push af  
05d6 3a ea 05			ld a, (.dmark)  
05d9 32 bd fb			ld (debug_mark),a  
05dc 3a eb 05			ld a, (.dmark+1)  
05df 32 be fb			ld (debug_mark+1),a  
05e2 3a ec 05			ld a, (.dmark+2)  
05e5 32 bf fb			ld (debug_mark+2),a  
05e8 18 03			jr .pastdmark  
05ea ..			.dmark: db "ER3"  
05ed f1			.pastdmark: pop af  
05ee			endm  
# End of macro DMARK
05ee						CALLMONITOR 
05ee cd 6a 16			call break_point_state  
05f1				endm  
# End of macro CALLMONITOR
05f1					endif 
05f1 cd 2a 06			call storage_findnextid 
05f4			 
05f4 e5				push hl 
05f5 11 e8 f9			ld de, store_page 
05f8 cd 09 03			call storage_read_block 
05fb			 
05fb				; free block	 
05fb			 
05fb 3e 00			ld a, 0 
05fd 32 e8 f9			ld (store_page), a 
0600 32 e9 f9			ld (store_page+1),a 
0603 11 e8 f9			ld de, store_page 
0606 e1				pop hl 
0607					if DEBUG_FORTH_WORDS 
0607						DMARK "ER4" 
0607 f5				push af  
0608 3a 1c 06			ld a, (.dmark)  
060b 32 bd fb			ld (debug_mark),a  
060e 3a 1d 06			ld a, (.dmark+1)  
0611 32 be fb			ld (debug_mark+1),a  
0614 3a 1e 06			ld a, (.dmark+2)  
0617 32 bf fb			ld (debug_mark+2),a  
061a 18 03			jr .pastdmark  
061c ..			.dmark: db "ER4"  
061f f1			.pastdmark: pop af  
0620			endm  
# End of macro DMARK
0620						CALLMONITOR 
0620 cd 6a 16			call break_point_state  
0623				endm  
# End of macro CALLMONITOR
0623					endif 
0623 cd 6e 03			call storage_write_block 
0626			 
0626 c1				pop bc 
0627 10 a3			djnz .eraext 
0629			 
0629 c9				ret 
062a			 
062a			 
062a			; Find Free Block 
062a			; --------------- 
062a			; 
062a			; With current bank 
062a			;  
062a			; From given starting logical block 
062a			;    Read block  
062a			;    If no file id 
062a			;         Return block id 
062a			 
062a			 
062a			; hl starting page number 
062a			; hl contains free page number or zero if no pages free 
062a			; e contains the file id to locate 
062a			; d contains the block number 
062a			 
062a			; TODO change to find file id and use zero for free block 
062a			 
062a			storage_findnextid: 
062a			 
062a				; now locate first 0 page to mark as a free block 
062a			 
062a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
062c			;	ld hl, STORE_BLOCK_PHY 
062c			 
062c					if DEBUG_FORTH_WORDS 
062c					DMARK "FNI" 
062c f5				push af  
062d 3a 41 06			ld a, (.dmark)  
0630 32 bd fb			ld (debug_mark),a  
0633 3a 42 06			ld a, (.dmark+1)  
0636 32 be fb			ld (debug_mark+1),a  
0639 3a 43 06			ld a, (.dmark+2)  
063c 32 bf fb			ld (debug_mark+2),a  
063f 18 03			jr .pastdmark  
0641 ..			.dmark: db "FNI"  
0644 f1			.pastdmark: pop af  
0645			endm  
# End of macro DMARK
0645						CALLMONITOR 
0645 cd 6a 16			call break_point_state  
0648				endm  
# End of macro CALLMONITOR
0648					endif 
0648			.ff1:   	 
0648 e5					push hl 
0649 c5					push bc 
064a d5					push de 
064b cd 89 02				call se_readbyte 
064e 5f					ld e,a 
064f 23					inc hl 
0650 cd 89 02				call se_readbyte 
0653 57					ld d, a 
0654 e1					pop hl 
0655 e5					push hl 
0656 cd 24 0d				call cmp16 
0659 28 49				jr z, .fffound 
065b			 
065b d1					pop de 
065c c1					pop bc 
065d e1					pop hl 
065e			 
065e					; is found? 
065e					;cp e 
065e					;ret z 
065e			 
065e 3e 40				ld a, STORE_BLOCK_PHY 
0660 cd 06 0d				call addatohl 
0663 10 e3				djnz .ff1 
0665			 
0665 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0667			.ff2:   	 
0667			 
0667 e5					push hl 
0668 c5					push bc 
0669 d5					push de 
066a cd 89 02				call se_readbyte 
066d 5f					ld e,a 
066e 23					inc hl 
066f cd 89 02				call se_readbyte 
0672 57					ld d, a 
0673			 
0673 e1					pop hl 
0674 e5					push hl 
0675 cd 24 0d				call cmp16 
0678 28 2a				jr z, .fffound 
067a			 
067a d1					pop de 
067b c1					pop bc 
067c e1					pop hl 
067d					; is found? 
067d					;cp e 
067d					;ret z 
067d			 
067d 3e 40				ld a, STORE_BLOCK_PHY 
067f cd 06 0d				call addatohl 
0682 10 e3				djnz .ff2 
0684			 
0684			 
0684					if DEBUG_FORTH_WORDS 
0684					DMARK "FN-" 
0684 f5				push af  
0685 3a 99 06			ld a, (.dmark)  
0688 32 bd fb			ld (debug_mark),a  
068b 3a 9a 06			ld a, (.dmark+1)  
068e 32 be fb			ld (debug_mark+1),a  
0691 3a 9b 06			ld a, (.dmark+2)  
0694 32 bf fb			ld (debug_mark+2),a  
0697 18 03			jr .pastdmark  
0699 ..			.dmark: db "FN-"  
069c f1			.pastdmark: pop af  
069d			endm  
# End of macro DMARK
069d					;	push af 
069d					;	ld a, 'n' 
069d					;	ld (debug_mark),a 
069d					;	pop af 
069d						CALLMONITOR 
069d cd 6a 16			call break_point_state  
06a0				endm  
# End of macro CALLMONITOR
06a0					endif 
06a0				; no free marks! 
06a0 21 00 00				ld hl, 0 
06a3 c9				ret 
06a4			.fffound: 
06a4				 
06a4			 
06a4 d1					pop de 
06a5 c1					pop bc 
06a6 e1					pop hl 
06a7					if DEBUG_FORTH_WORDS 
06a7					DMARK "FNF" 
06a7 f5				push af  
06a8 3a bc 06			ld a, (.dmark)  
06ab 32 bd fb			ld (debug_mark),a  
06ae 3a bd 06			ld a, (.dmark+1)  
06b1 32 be fb			ld (debug_mark+1),a  
06b4 3a be 06			ld a, (.dmark+2)  
06b7 32 bf fb			ld (debug_mark+2),a  
06ba 18 03			jr .pastdmark  
06bc ..			.dmark: db "FNF"  
06bf f1			.pastdmark: pop af  
06c0			endm  
# End of macro DMARK
06c0					;	push af 
06c0					;	ld a, 'n' 
06c0					;	ld (debug_mark),a 
06c0					;	pop af 
06c0						CALLMONITOR 
06c0 cd 6a 16			call break_point_state  
06c3				endm  
# End of macro CALLMONITOR
06c3					endif 
06c3 c9				ret 
06c4			 
06c4			 
06c4			 
06c4			; Free Space 
06c4			; ---------- 
06c4			; 
06c4			; With current bank 
06c4			; 
06c4			; Set block count to zero 
06c4			; Starting with first logical block 
06c4			;      Find free block  
06c4			;      If block id given, increment block count 
06c4			; 
06c4			;  
06c4			 
06c4			 
06c4			; hl contains count of free blocks 
06c4			 
06c4			storage_freeblocks: 
06c4			 
06c4				; now locate first 0 page to mark as a free block 
06c4			 
06c4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06c6 21 40 00			ld hl, STORE_BLOCK_PHY 
06c9 11 00 00			ld de, 0 
06cc			 
06cc			.fb1:   	 
06cc e5					push hl 
06cd c5					push bc 
06ce d5					push de 
06cf cd 89 02				call se_readbyte 
06d2 d1					pop de 
06d3 c1					pop bc 
06d4 e1					pop hl 
06d5			 
06d5					; is free? 
06d5 fe 00				cp 0 
06d7 20 01				jr nz, .ff1cont 
06d9 13					inc de 
06da			 
06da			.ff1cont: 
06da			 
06da			 
06da 3e 40				ld a, STORE_BLOCK_PHY 
06dc cd 06 0d				call addatohl 
06df 10 eb				djnz .fb1 
06e1			 
06e1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06e3			.fb2:   	 
06e3 e5					push hl 
06e4 c5					push bc 
06e5 d5					push de 
06e6 cd 89 02				call se_readbyte 
06e9 d1					pop de 
06ea c1					pop bc 
06eb e1					pop hl 
06ec			 
06ec					; is free? 
06ec fe 00				cp 0 
06ee 20 01				jr nz, .ff2cont 
06f0 13					inc de 
06f1			 
06f1			.ff2cont: 
06f1			 
06f1 3e 40				ld a, STORE_BLOCK_PHY 
06f3 cd 06 0d				call addatohl 
06f6 10 eb				djnz .fb2 
06f8			 
06f8 eb				ex de, hl 
06f9 c9				ret 
06fa			 
06fa			; Get File ID 
06fa			; ----------- 
06fa			; 
06fa			; With current bank 
06fa			;  
06fa			; Load Block 0 Config 
06fa			; Get max file id number 
06fa			; For each logical block 
06fa			;    Read block file id 
06fa			;      If first block of file and dont have file id 
06fa			;         if file get id and exit 
06fa			 
06fa			 
06fa			 
06fa			 
06fa			; Create File 
06fa			; ----------- 
06fa			; 
06fa			; With current bank  
06fa			; Load Block 0 Config 
06fa			; Get max file id number 
06fa			; Increment file id number 
06fa			; Save Config 
06fa			; Find free block 
06fa			; Set buffer with file name and file id 
06fa			; Write buffer to free block  
06fa			 
06fa			 
06fa			; hl point to file name 
06fa			; hl returns file id 
06fa			 
06fa			; file format: 
06fa			; byte 0 - file id 
06fa			; byte 1 - extent number 
06fa			; byte 2-> data 
06fa			 
06fa			; format for extent number 0: 
06fa			; 
06fa			; byte 0 - file id 
06fa			; byte 1 - extent 0 
06fa			; byte 2 - extent count 
06fa			; byte 3 -> file name and meta data 
06fa			 
06fa			 
06fa			storage_create: 
06fa				if DEBUG_STORESE 
06fa					DMARK "SCR" 
06fa f5				push af  
06fb 3a 0f 07			ld a, (.dmark)  
06fe 32 bd fb			ld (debug_mark),a  
0701 3a 10 07			ld a, (.dmark+1)  
0704 32 be fb			ld (debug_mark+1),a  
0707 3a 11 07			ld a, (.dmark+2)  
070a 32 bf fb			ld (debug_mark+2),a  
070d 18 03			jr .pastdmark  
070f ..			.dmark: db "SCR"  
0712 f1			.pastdmark: pop af  
0713			endm  
# End of macro DMARK
0713					CALLMONITOR 
0713 cd 6a 16			call break_point_state  
0716				endm  
# End of macro CALLMONITOR
0716				endif 
0716			 
0716 e5				push hl		; save file name pointer 
0717			 
0717 cd ba 03			call storage_get_block_0 
071a			 
071a 3a e8 f9			ld a,(store_page)	; get current file id 
071d 3c				inc a 
071e 32 e8 f9			ld (store_page),a 
0721				 
0721 32 e1 f9			ld (store_tmpid),a			; save id 
0724			 
0724 21 00 00			ld hl, 0 
0727 11 e8 f9			ld de, store_page 
072a				if DEBUG_STORESE 
072a					DMARK "SCw" 
072a f5				push af  
072b 3a 3f 07			ld a, (.dmark)  
072e 32 bd fb			ld (debug_mark),a  
0731 3a 40 07			ld a, (.dmark+1)  
0734 32 be fb			ld (debug_mark+1),a  
0737 3a 41 07			ld a, (.dmark+2)  
073a 32 bf fb			ld (debug_mark+2),a  
073d 18 03			jr .pastdmark  
073f ..			.dmark: db "SCw"  
0742 f1			.pastdmark: pop af  
0743			endm  
# End of macro DMARK
0743					CALLMONITOR 
0743 cd 6a 16			call break_point_state  
0746				endm  
# End of macro CALLMONITOR
0746				endif 
0746 cd 6e 03			call storage_write_block	 ; save update 
0749			 
0749				if DEBUG_STORESE 
0749 11 e8 f9				ld de, store_page 
074c					DMARK "SCC" 
074c f5				push af  
074d 3a 61 07			ld a, (.dmark)  
0750 32 bd fb			ld (debug_mark),a  
0753 3a 62 07			ld a, (.dmark+1)  
0756 32 be fb			ld (debug_mark+1),a  
0759 3a 63 07			ld a, (.dmark+2)  
075c 32 bf fb			ld (debug_mark+2),a  
075f 18 03			jr .pastdmark  
0761 ..			.dmark: db "SCC"  
0764 f1			.pastdmark: pop af  
0765			endm  
# End of macro DMARK
0765					CALLMONITOR 
0765 cd 6a 16			call break_point_state  
0768				endm  
# End of macro CALLMONITOR
0768				endif 
0768				;  
0768				 
0768 21 40 00			ld hl, STORE_BLOCK_PHY 
076b 11 00 00			ld de, 0 
076e cd 2a 06			call storage_findnextid 
0771			 
0771 22 d2 f9			ld (store_tmppageid), hl    ; save page to use  
0774			 
0774				; TODO detect 0 = no spare blocks 
0774			 
0774				; hl now contains the free page to use for the file header page 
0774			 
0774				if DEBUG_STORESE 
0774				DMARK "SCF" 
0774 f5				push af  
0775 3a 89 07			ld a, (.dmark)  
0778 32 bd fb			ld (debug_mark),a  
077b 3a 8a 07			ld a, (.dmark+1)  
077e 32 be fb			ld (debug_mark+1),a  
0781 3a 8b 07			ld a, (.dmark+2)  
0784 32 bf fb			ld (debug_mark+2),a  
0787 18 03			jr .pastdmark  
0789 ..			.dmark: db "SCF"  
078c f1			.pastdmark: pop af  
078d			endm  
# End of macro DMARK
078d					CALLMONITOR 
078d cd 6a 16			call break_point_state  
0790				endm  
# End of macro CALLMONITOR
0790				endif 
0790			 
0790 22 d2 f9			ld (store_tmppageid), hl 
0793				 
0793 3a e1 f9			ld a,(store_tmpid)    ; get file id 
0796			;	ld a, (store_filecache)			; save to cache 
0796			 
0796 32 e8 f9			ld (store_page),a    ; set page id 
0799 3e 00			ld a, 0			 ; extent 0 is file header 
079b 32 e9 f9			ld (store_page+1), a   ; set file extent 
079e			 
079e 32 ea f9			ld (store_page+2), a   ; extent count for the file 
07a1			 
07a1			;	inc hl 		; init block 0 of file 
07a1			;	inc hl   		; skip file and extent id 
07a1			 ;       ld a, 0 
07a1			;	ld (hl),a 
07a1			;	ld a, (store_filecache+1)  	; save to cache 
07a1			 
07a1			;	inc hl    ; file name 
07a1				 
07a1				 
07a1 11 eb f9			ld de, store_page+3    ; get buffer for term string to use as file name 
07a4				if DEBUG_STORESE 
07a4					DMARK "SCc" 
07a4 f5				push af  
07a5 3a b9 07			ld a, (.dmark)  
07a8 32 bd fb			ld (debug_mark),a  
07ab 3a ba 07			ld a, (.dmark+1)  
07ae 32 be fb			ld (debug_mark+1),a  
07b1 3a bb 07			ld a, (.dmark+2)  
07b4 32 bf fb			ld (debug_mark+2),a  
07b7 18 03			jr .pastdmark  
07b9 ..			.dmark: db "SCc"  
07bc f1			.pastdmark: pop af  
07bd			endm  
# End of macro DMARK
07bd					CALLMONITOR 
07bd cd 6a 16			call break_point_state  
07c0				endm  
# End of macro CALLMONITOR
07c0				endif 
07c0 e1				pop hl    ; get zero term string 
07c1 e5				push hl 
07c2 3e 00			ld a, 0 
07c4 cd 6f 11			call strlent 
07c7 23				inc hl   ; cover zero term 
07c8 06 00			ld b,0 
07ca 4d				ld c,l 
07cb e1				pop hl 
07cc				;ex de, hl 
07cc				if DEBUG_STORESE 
07cc					DMARK "SCa" 
07cc f5				push af  
07cd 3a e1 07			ld a, (.dmark)  
07d0 32 bd fb			ld (debug_mark),a  
07d3 3a e2 07			ld a, (.dmark+1)  
07d6 32 be fb			ld (debug_mark+1),a  
07d9 3a e3 07			ld a, (.dmark+2)  
07dc 32 bf fb			ld (debug_mark+2),a  
07df 18 03			jr .pastdmark  
07e1 ..			.dmark: db "SCa"  
07e4 f1			.pastdmark: pop af  
07e5			endm  
# End of macro DMARK
07e5					;push af 
07e5					;ld a, 'a' 
07e5					;ld (debug_mark),a 
07e5					;pop af 
07e5					CALLMONITOR 
07e5 cd 6a 16			call break_point_state  
07e8				endm  
# End of macro CALLMONITOR
07e8				endif 
07e8 ed b0			ldir    ; copy zero term string 
07ea				if DEBUG_STORESE 
07ea					DMARK "SCA" 
07ea f5				push af  
07eb 3a ff 07			ld a, (.dmark)  
07ee 32 bd fb			ld (debug_mark),a  
07f1 3a 00 08			ld a, (.dmark+1)  
07f4 32 be fb			ld (debug_mark+1),a  
07f7 3a 01 08			ld a, (.dmark+2)  
07fa 32 bf fb			ld (debug_mark+2),a  
07fd 18 03			jr .pastdmark  
07ff ..			.dmark: db "SCA"  
0802 f1			.pastdmark: pop af  
0803			endm  
# End of macro DMARK
0803					CALLMONITOR 
0803 cd 6a 16			call break_point_state  
0806				endm  
# End of macro CALLMONITOR
0806				endif 
0806			 
0806				; write file header page 
0806			 
0806 2a d2 f9			ld hl,(store_tmppageid) 
0809 11 e8 f9			ld de, store_page 
080c				if DEBUG_STORESE 
080c					DMARK "SCb" 
080c f5				push af  
080d 3a 21 08			ld a, (.dmark)  
0810 32 bd fb			ld (debug_mark),a  
0813 3a 22 08			ld a, (.dmark+1)  
0816 32 be fb			ld (debug_mark+1),a  
0819 3a 23 08			ld a, (.dmark+2)  
081c 32 bf fb			ld (debug_mark+2),a  
081f 18 03			jr .pastdmark  
0821 ..			.dmark: db "SCb"  
0824 f1			.pastdmark: pop af  
0825			endm  
# End of macro DMARK
0825					;push af 
0825					;ld a, 'b' 
0825					;ld (debug_mark),a 
0825					;pop af 
0825					CALLMONITOR 
0825 cd 6a 16			call break_point_state  
0828				endm  
# End of macro CALLMONITOR
0828				endif 
0828 cd 6e 03			call storage_write_block 
082b			 
082b 3a e1 f9			ld a, (store_tmpid) 
082e 6f				ld l, a 
082f 26 00			ld h,0 
0831				if DEBUG_STORESE 
0831					DMARK "SCz" 
0831 f5				push af  
0832 3a 46 08			ld a, (.dmark)  
0835 32 bd fb			ld (debug_mark),a  
0838 3a 47 08			ld a, (.dmark+1)  
083b 32 be fb			ld (debug_mark+1),a  
083e 3a 48 08			ld a, (.dmark+2)  
0841 32 bf fb			ld (debug_mark+2),a  
0844 18 03			jr .pastdmark  
0846 ..			.dmark: db "SCz"  
0849 f1			.pastdmark: pop af  
084a			endm  
# End of macro DMARK
084a					CALLMONITOR 
084a cd 6a 16			call break_point_state  
084d				endm  
# End of macro CALLMONITOR
084d				endif 
084d c9				ret 
084e				 
084e			 
084e			 
084e			; 
084e			; Read File 
084e			; 
084e			; h - file id to locate 
084e			; l - extent to locate 
084e			; de - pointer to string to read into 
084e			; 
084e			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
084e			storage_read: 
084e d5				push de 
084f			 
084f			; TODO BUG the above push is it popped before the RET Z? 
084f			 
084f			; TODO how to handle multiple part blocks 
084f			 
084f				; locate file extent to read 
084f			 
084f 5c				ld e, h 
0850 55				ld d, l 
0851 21 40 00			ld hl, STORE_BLOCK_PHY 
0854				if DEBUG_STORESE 
0854					DMARK "SRE" 
0854 f5				push af  
0855 3a 69 08			ld a, (.dmark)  
0858 32 bd fb			ld (debug_mark),a  
085b 3a 6a 08			ld a, (.dmark+1)  
085e 32 be fb			ld (debug_mark+1),a  
0861 3a 6b 08			ld a, (.dmark+2)  
0864 32 bf fb			ld (debug_mark+2),a  
0867 18 03			jr .pastdmark  
0869 ..			.dmark: db "SRE"  
086c f1			.pastdmark: pop af  
086d			endm  
# End of macro DMARK
086d					CALLMONITOR 
086d cd 6a 16			call break_point_state  
0870				endm  
# End of macro CALLMONITOR
0870				endif 
0870 cd 2a 06			call storage_findnextid 
0873			 
0873				if DEBUG_STORESE 
0873					DMARK "SRf" 
0873 f5				push af  
0874 3a 88 08			ld a, (.dmark)  
0877 32 bd fb			ld (debug_mark),a  
087a 3a 89 08			ld a, (.dmark+1)  
087d 32 be fb			ld (debug_mark+1),a  
0880 3a 8a 08			ld a, (.dmark+2)  
0883 32 bf fb			ld (debug_mark+2),a  
0886 18 03			jr .pastdmark  
0888 ..			.dmark: db "SRf"  
088b f1			.pastdmark: pop af  
088c			endm  
# End of macro DMARK
088c					CALLMONITOR 
088c cd 6a 16			call break_point_state  
088f				endm  
# End of macro CALLMONITOR
088f				endif 
088f cd 2f 0d			call ishlzero 
0892			;	ld a, l 
0892			;	add h 
0892			;	cp 0 
0892 c8				ret z			; block not found so EOF 
0893			 
0893				; hl contains page number to load 
0893 d1				pop de   ; get storage 
0894 d5				push de 
0895				if DEBUG_STORESE 
0895					DMARK "SRg" 
0895 f5				push af  
0896 3a aa 08			ld a, (.dmark)  
0899 32 bd fb			ld (debug_mark),a  
089c 3a ab 08			ld a, (.dmark+1)  
089f 32 be fb			ld (debug_mark+1),a  
08a2 3a ac 08			ld a, (.dmark+2)  
08a5 32 bf fb			ld (debug_mark+2),a  
08a8 18 03			jr .pastdmark  
08aa ..			.dmark: db "SRg"  
08ad f1			.pastdmark: pop af  
08ae			endm  
# End of macro DMARK
08ae					CALLMONITOR 
08ae cd 6a 16			call break_point_state  
08b1				endm  
# End of macro CALLMONITOR
08b1				endif 
08b1 cd 09 03			call storage_read_block 
08b4			 
08b4			 
08b4			; TODO if block has no zeros then need to read next block  
08b4			 
08b4			 
08b4					 
08b4 e1				pop hl 		 ; return start of data to show as not EOF 
08b5 23				inc hl   ; past file id 
08b6 23				inc hl   ; past ext 
08b7				if DEBUG_STORESE 
08b7					DMARK "SRe" 
08b7 f5				push af  
08b8 3a cc 08			ld a, (.dmark)  
08bb 32 bd fb			ld (debug_mark),a  
08be 3a cd 08			ld a, (.dmark+1)  
08c1 32 be fb			ld (debug_mark+1),a  
08c4 3a ce 08			ld a, (.dmark+2)  
08c7 32 bf fb			ld (debug_mark+2),a  
08ca 18 03			jr .pastdmark  
08cc ..			.dmark: db "SRe"  
08cf f1			.pastdmark: pop af  
08d0			endm  
# End of macro DMARK
08d0					CALLMONITOR 
08d0 cd 6a 16			call break_point_state  
08d3				endm  
# End of macro CALLMONITOR
08d3				endif 
08d3 c9					ret 
08d4			 
08d4			 
08d4			 
08d4			; 
08d4			; Append File 
08d4			; 
08d4			; hl - file id to locate 
08d4			; de - pointer to (multi block) string to write 
08d4			 
08d4			 
08d4			storage_append: 
08d4				; hl -  file id to append to 
08d4				; de - string to append 
08d4			 
08d4 d5				push de 
08d5				 
08d5				if DEBUG_STORESE 
08d5					DMARK "AP1" 
08d5 f5				push af  
08d6 3a ea 08			ld a, (.dmark)  
08d9 32 bd fb			ld (debug_mark),a  
08dc 3a eb 08			ld a, (.dmark+1)  
08df 32 be fb			ld (debug_mark+1),a  
08e2 3a ec 08			ld a, (.dmark+2)  
08e5 32 bf fb			ld (debug_mark+2),a  
08e8 18 03			jr .pastdmark  
08ea ..			.dmark: db "AP1"  
08ed f1			.pastdmark: pop af  
08ee			endm  
# End of macro DMARK
08ee					CALLMONITOR 
08ee cd 6a 16			call break_point_state  
08f1				endm  
# End of macro CALLMONITOR
08f1				endif 
08f1			 
08f1 7d				ld a, l 
08f2 32 e1 f9			ld (store_tmpid), a 
08f5			 
08f5				; get file header  
08f5			 
08f5 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08f7 3a e1 f9			ld a, (store_tmpid) 
08fa 5f				ld e, a 
08fb			 
08fb 21 40 00				ld hl, STORE_BLOCK_PHY 
08fe cd 2a 06				call storage_findnextid 
0901			 
0901 22 d2 f9			ld (store_tmppageid), hl 
0904			 
0904				; TODO handle file id not found 
0904			 
0904				if DEBUG_STORESE 
0904					DMARK "AP2" 
0904 f5				push af  
0905 3a 19 09			ld a, (.dmark)  
0908 32 bd fb			ld (debug_mark),a  
090b 3a 1a 09			ld a, (.dmark+1)  
090e 32 be fb			ld (debug_mark+1),a  
0911 3a 1b 09			ld a, (.dmark+2)  
0914 32 bf fb			ld (debug_mark+2),a  
0917 18 03			jr .pastdmark  
0919 ..			.dmark: db "AP2"  
091c f1			.pastdmark: pop af  
091d			endm  
# End of macro DMARK
091d					CALLMONITOR 
091d cd 6a 16			call break_point_state  
0920				endm  
# End of macro CALLMONITOR
0920				endif 
0920			 
0920				; update file extent count 
0920			 
0920 11 e8 f9			ld de, store_page 
0923			 
0923 cd 09 03			call storage_read_block 
0926			 
0926				if DEBUG_STORESE 
0926					DMARK "AP3" 
0926 f5				push af  
0927 3a 3b 09			ld a, (.dmark)  
092a 32 bd fb			ld (debug_mark),a  
092d 3a 3c 09			ld a, (.dmark+1)  
0930 32 be fb			ld (debug_mark+1),a  
0933 3a 3d 09			ld a, (.dmark+2)  
0936 32 bf fb			ld (debug_mark+2),a  
0939 18 03			jr .pastdmark  
093b ..			.dmark: db "AP3"  
093e f1			.pastdmark: pop af  
093f			endm  
# End of macro DMARK
093f					CALLMONITOR 
093f cd 6a 16			call break_point_state  
0942				endm  
# End of macro CALLMONITOR
0942				endif 
0942			;	ld (store_tmppageid), hl 
0942			 
0942 3a ea f9			ld a, (store_page+2) 
0945 3c				inc a 
0946 32 ea f9			ld (store_page+2), a 
0949 32 e0 f9			ld (store_tmpext), a 
094c				 
094c				if DEBUG_STORESE 
094c					DMARK "AP3" 
094c f5				push af  
094d 3a 61 09			ld a, (.dmark)  
0950 32 bd fb			ld (debug_mark),a  
0953 3a 62 09			ld a, (.dmark+1)  
0956 32 be fb			ld (debug_mark+1),a  
0959 3a 63 09			ld a, (.dmark+2)  
095c 32 bf fb			ld (debug_mark+2),a  
095f 18 03			jr .pastdmark  
0961 ..			.dmark: db "AP3"  
0964 f1			.pastdmark: pop af  
0965			endm  
# End of macro DMARK
0965					CALLMONITOR 
0965 cd 6a 16			call break_point_state  
0968				endm  
# End of macro CALLMONITOR
0968				endif 
0968 2a d2 f9			ld hl, (store_tmppageid) 
096b 11 e8 f9			ld de, store_page 
096e cd 6e 03			call storage_write_block 
0971			 
0971				; find free block 
0971			 
0971 11 00 00			ld de, 0			 ; file extent to locate 
0974			 
0974 21 40 00				ld hl, STORE_BLOCK_PHY 
0977 cd 2a 06				call storage_findnextid 
097a			 
097a					; TODO handle no space left 
097a					 
097a 22 d2 f9				ld (store_tmppageid), hl 
097d			 
097d				if DEBUG_STORESE 
097d					DMARK "AP4" 
097d f5				push af  
097e 3a 92 09			ld a, (.dmark)  
0981 32 bd fb			ld (debug_mark),a  
0984 3a 93 09			ld a, (.dmark+1)  
0987 32 be fb			ld (debug_mark+1),a  
098a 3a 94 09			ld a, (.dmark+2)  
098d 32 bf fb			ld (debug_mark+2),a  
0990 18 03			jr .pastdmark  
0992 ..			.dmark: db "AP4"  
0995 f1			.pastdmark: pop af  
0996			endm  
# End of macro DMARK
0996					CALLMONITOR 
0996 cd 6a 16			call break_point_state  
0999				endm  
# End of macro CALLMONITOR
0999				endif 
0999					; init the buffer with zeros so we can id if the buffer is full or not 
0999			 
0999 e5					push hl 
099a c5					push bc 
099b			 
099b 21 e8 f9				ld hl, store_page 
099e 06 40				ld b, STORE_BLOCK_PHY 
09a0 3e 00				ld a, 0 
09a2 77			.zeroblock:	ld (hl), a 
09a3 23					inc hl 
09a4 10 fc				djnz .zeroblock 
09a6			 
09a6 c1					pop bc 
09a7 e1					pop hl 
09a8			 
09a8					; construct block 
09a8			 
09a8 3a e1 f9				ld a, (store_tmpid) 
09ab 32 e8 f9				ld (store_page), a   ; file id 
09ae 3a e0 f9				ld a, (store_tmpext)   ; extent for this block 
09b1 32 e9 f9				ld (store_page+1), a 
09b4			 
09b4 e1					pop hl    ; get string to write 
09b5 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09b7 11 ea f9				ld de, store_page+2 
09ba			 
09ba				if DEBUG_STORESE 
09ba					DMARK "AP5" 
09ba f5				push af  
09bb 3a cf 09			ld a, (.dmark)  
09be 32 bd fb			ld (debug_mark),a  
09c1 3a d0 09			ld a, (.dmark+1)  
09c4 32 be fb			ld (debug_mark+1),a  
09c7 3a d1 09			ld a, (.dmark+2)  
09ca 32 bf fb			ld (debug_mark+2),a  
09cd 18 03			jr .pastdmark  
09cf ..			.dmark: db "AP5"  
09d2 f1			.pastdmark: pop af  
09d3			endm  
# End of macro DMARK
09d3					CALLMONITOR 
09d3 cd 6a 16			call break_point_state  
09d6				endm  
# End of macro CALLMONITOR
09d6				endif 
09d6			 
09d6			 
09d6			 
09d6					; fill buffer with data until end of string or full block 
09d6			 
09d6 7e			.appd:		ld a, (hl) 
09d7 12					ld (de), a 
09d8 fe 00				cp 0 
09da 28 04				jr z, .appdone 
09dc 23					inc hl 
09dd 13					inc de 
09de 10 f6				djnz .appd 
09e0			 
09e0 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09e1 f5					push af   		; save last byte dumped 
09e2			 
09e2			 
09e2 2a d2 f9			ld hl, (store_tmppageid) 
09e5 11 e8 f9			ld de, store_page 
09e8				if DEBUG_STORESE 
09e8					DMARK "AP6" 
09e8 f5				push af  
09e9 3a fd 09			ld a, (.dmark)  
09ec 32 bd fb			ld (debug_mark),a  
09ef 3a fe 09			ld a, (.dmark+1)  
09f2 32 be fb			ld (debug_mark+1),a  
09f5 3a ff 09			ld a, (.dmark+2)  
09f8 32 bf fb			ld (debug_mark+2),a  
09fb 18 03			jr .pastdmark  
09fd ..			.dmark: db "AP6"  
0a00 f1			.pastdmark: pop af  
0a01			endm  
# End of macro DMARK
0a01					CALLMONITOR 
0a01 cd 6a 16			call break_point_state  
0a04				endm  
# End of macro CALLMONITOR
0a04				endif 
0a04 cd 6e 03				call storage_write_block 
0a07			 
0a07			 
0a07				; was that a full block of data written? 
0a07				; any more to write out? 
0a07			 
0a07				; if yes then set vars and jump to start of function again 
0a07			 
0a07 f1					pop af 
0a08 d1					pop de 
0a09			 
0a09 fe 00				cp 0		 ; no, string was fully written 
0a0b c8					ret z 
0a0c			 
0a0c					; setup vars for next cycle 
0a0c			 
0a0c 3a e1 f9				ld a, (store_tmpid) 
0a0f 6f					ld l, a 
0a10 26 00				ld h, 0 
0a12			 
0a12 c3 d4 08			 	jp storage_append	 ; yes, need to write out some more 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			 
0a15			if DEBUG_STORECF 
0a15			storageput:	 
0a15					ret 
0a15			storageread: 
0a15					ld hl, store_page 
0a15					ld b, 200 
0a15					ld a,0 
0a15			.src:		ld (hl),a 
0a15					inc hl 
0a15					djnz .src 
0a15					 
0a15			 
0a15					ld de, 0 
0a15					ld bc, 1 
0a15					ld hl, store_page 
0a15					call cfRead 
0a15			 
0a15				call cfGetError 
0a15				ld hl,scratch 
0a15				call hexout 
0a15				ld hl, scratch+2 
0a15				ld a, 0 
0a15				ld (hl),a 
0a15				ld de, scratch 
0a15				ld a,display_row_1 
0a15				call str_at_display 
0a15				call update_display 
0a15			 
0a15					ld hl, store_page 
0a15					ld (os_cur_ptr),hl 
0a15			 
0a15					ret 
0a15			endif 
0a15			 
0a15			 
0a15			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a15			 
0a15			storage_clear_page: 
0a15 e5				push hl 
0a16 d5				push de 
0a17 c5				push bc 
0a18 21 e8 f9			ld hl, store_page 
0a1b 3e 00			ld a, 0 
0a1d 77				ld (hl), a 
0a1e			 
0a1e 11 e9 f9			ld de, store_page+1 
0a21 01 40 00			ld bc, STORE_BLOCK_PHY 
0a24			 
0a24 ed b0			ldir 
0a26				 
0a26 c1				pop bc 
0a27 d1				pop de 
0a28 e1				pop hl 
0a29 c9				ret 
0a2a			 
0a2a			; eof 
# End of file firmware_storage.asm
0a2a			  
0a2a			; support routines for above hardware abstraction layer  
0a2a			  
0a2a			include "firmware_general.asm"        ; general support functions  
0a2a			 
0a2a			; word look up 
0a2a			 
0a2a			; in 
0a2a			; a is the index 
0a2a			; hl is pointer start of array 
0a2a			; 
0a2a			; returns 
0a2a			; hl to the word 
0a2a			; 
0a2a			 
0a2a			table_lookup:  
0a2a d5					push de 
0a2b eb					ex de, hl 
0a2c			 
0a2c 6f					ld l, a 
0a2d 26 00				ld h, 0 
0a2f 29					add hl, hl 
0a30 19					add hl, de 
0a31 7e					ld a, (hl) 
0a32 23					inc hl 
0a33 66					ld h,(hl) 
0a34 6f					ld l, a 
0a35			 
0a35 d1					pop de 
0a36 c9					ret 
0a37			 
0a37			; Delay loops 
0a37			 
0a37			 
0a37			 
0a37			aDelayInMS: 
0a37 c5				push bc 
0a38 47				ld b,a 
0a39			msdelay: 
0a39 c5				push bc 
0a3a				 
0a3a			 
0a3a 01 41 00			ld bc,041h 
0a3d cd 55 0a			call delayloop 
0a40 c1				pop bc 
0a41 05				dec b 
0a42 20 f5			jr nz,msdelay 
0a44			 
0a44			;if CPU_CLOCK_8MHZ 
0a44			;msdelay8: 
0a44			;	push bc 
0a44			;	 
0a44			; 
0a44			;	ld bc,041h 
0a44			;	call delayloop 
0a44			;	pop bc 
0a44			;	dec b 
0a44			;	jr nz,msdelay8 
0a44			;endif 
0a44			 
0a44			 
0a44 c1				pop bc 
0a45 c9				ret 
0a46			 
0a46			 
0a46			delay250ms: 
0a46				;push de 
0a46 01 00 40			ld bc, 04000h 
0a49 c3 55 0a			jp delayloop 
0a4c			delay500ms: 
0a4c				;push de 
0a4c 01 00 80			ld bc, 08000h 
0a4f c3 55 0a			jp delayloop 
0a52			delay1s: 
0a52				;push bc 
0a52			   ; Clobbers A, d and e 
0a52 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a55			delayloop: 
0a55 c5			    push bc 
0a56			 
0a56			if BASE_CPM 
0a56				ld bc, CPM_DELAY_TUNE 
0a56			.cpmloop: 
0a56				push bc 
0a56			 
0a56			endif 
0a56			 
0a56			 
0a56			 
0a56			delayloopi: 
0a56			;	push bc 
0a56			;.dl: 
0a56 cb 47		    bit     0,a    	; 8 
0a58 cb 47		    bit     0,a    	; 8 
0a5a cb 47		    bit     0,a    	; 8 
0a5c e6 ff		    and     255  	; 7 
0a5e 0b			    dec     bc      	; 6 
0a5f 79			    ld      a,c     	; 4 
0a60 b0			    or      b     	; 4 
0a61 c2 56 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a64			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a64				;pop de 
0a64			;pop bc 
0a64			 
0a64			if BASE_CPM 
0a64				pop bc 
0a64				 
0a64			    dec     bc      	; 6 
0a64			    ld      a,c     	; 4 
0a64			    or      b     	; 4 
0a64			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a64				 
0a64			 
0a64			endif 
0a64			;if CPU_CLOCK_8MHZ 
0a64			;    pop bc 
0a64			;    push bc 
0a64			;.dl8: 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    and     255  	; 7 
0a64			;    dec     bc      	; 6 
0a64			;    ld      a,c     	; 4 
0a64			;    or      b     	; 4 
0a64			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a64			;endif 
0a64			 
0a64			;if CPU_CLOCK_10MHZ 
0a64			;    pop bc 
0a64			;    push bc 
0a64			;.dl8: 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    bit     0,a    	; 8 
0a64			;    and     255  	; 7 
0a64			;    dec     bc      	; 6 
0a64			;    ld      a,c     	; 4 
0a64			;    or      b     	; 4 
0a64			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a64			;endif 
0a64 c1			    pop bc 
0a65			 
0a65 c9				ret 
0a66			 
0a66			 
0a66			 
0a66			; eof 
# End of file firmware_general.asm
0a66			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a66			; display routines that use the physical hardware abstraction layer 
0a66			 
0a66			 
0a66			; information window 
0a66			 
0a66			; pass hl with 1st string to display 
0a66			; pass de with 2nd string to display 
0a66			 
0a66			info_panel: 
0a66 e5				push hl 
0a67			 
0a67 2a 5e fa			ld hl, (display_fb_active) 
0a6a e5				push hl    ; future de destination 
0a6b 21 53 fb				ld hl, display_fb0 
0a6e 22 5e fa				ld (display_fb_active), hl 
0a71			 
0a71 cd d2 0a			call clear_display 
0a74			 
0a74			 
0a74 3e 2d			ld a, display_row_3 + 5 
0a76 cd e5 0a			call str_at_display 
0a79			 
0a79 e1				pop hl 
0a7a d1				pop de 
0a7b			 
0a7b e5				push hl 
0a7c			 
0a7c			 
0a7c 3e 19			ld a, display_row_2 + 5 
0a7e cd e5 0a			call str_at_display 
0a81			 
0a81			 
0a81 cd f5 0a			call update_display 
0a84 cd 6f 1b			call next_page_prompt 
0a87 cd d2 0a			call clear_display 
0a8a			 
0a8a				 
0a8a 21 02 fb				ld hl, display_fb1 
0a8d 22 5e fa				ld (display_fb_active), hl 
0a90 cd f5 0a			call update_display 
0a93			 
0a93			 
0a93 c9				ret 
0a94			 
0a94			 
0a94			 
0a94			 
0a94			; TODO windowing? 
0a94			 
0a94			; TODO scroll line up 
0a94			 
0a94			scroll_up: 
0a94			 
0a94 e5				push hl 
0a95 d5				push de 
0a96 c5				push bc 
0a97			 
0a97				; get frame buffer  
0a97			 
0a97 2a 5e fa			ld hl, (display_fb_active) 
0a9a e5				push hl    ; future de destination 
0a9b			 
0a9b 11 14 00			ld  de, display_cols 
0a9e 19				add hl, de 
0a9f			 
0a9f d1				pop de 
0aa0			 
0aa0				;ex de, hl 
0aa0 01 4f 00			ld bc, display_fb_len -1  
0aa3			;if DEBUG_FORTH_WORDS 
0aa3			;	DMARK "SCL" 
0aa3			;	CALLMONITOR 
0aa3			;endif	 
0aa3 ed b0			ldir 
0aa5			 
0aa5				; wipe bottom row 
0aa5			 
0aa5			 
0aa5 2a 5e fa			ld hl, (display_fb_active) 
0aa8 11 50 00			ld de, display_cols*display_rows 
0aab 19				add hl, de 
0aac 06 14			ld b, display_cols 
0aae 3e 20			ld a, ' ' 
0ab0			.scwipe: 
0ab0 77				ld (hl), a 
0ab1 2b				dec hl 
0ab2 10 fc			djnz .scwipe 
0ab4			 
0ab4				;pop hl 
0ab4			 
0ab4 c1				pop bc 
0ab5 d1				pop de 
0ab6 e1				pop hl 
0ab7			 
0ab7 c9				ret 
0ab8			 
0ab8			 
0ab8			;scroll_upo: 
0ab8			;	ld de, display_row_1 
0ab8			 ;	ld hl, display_row_2 
0ab8			;	ld bc, display_cols 
0ab8			;	ldir 
0ab8			;	ld de, display_row_2 
0ab8			 ;	ld hl, display_row_3 
0ab8			;	ld bc, display_cols 
0ab8			;	ldir 
0ab8			;	ld de, display_row_3 
0ab8			 ;	ld hl, display_row_4 
0ab8			;	ld bc, display_cols 
0ab8			;	ldir 
0ab8			 
0ab8			; TODO clear row 4 
0ab8			 
0ab8			;	ret 
0ab8			 
0ab8				 
0ab8			scroll_down: 
0ab8			 
0ab8 e5				push hl 
0ab9 d5				push de 
0aba c5				push bc 
0abb			 
0abb				; get frame buffer  
0abb			 
0abb 2a 5e fa			ld hl, (display_fb_active) 
0abe			 
0abe 11 4f 00			ld de, display_fb_len - 1 
0ac1 19				add hl, de 
0ac2			 
0ac2 e5			push hl    ; future de destination 
0ac3			 
0ac3 11 14 00			ld  de, display_cols 
0ac6 ed 52			sbc hl, de 
0ac8			 
0ac8			 
0ac8 d1				pop de 
0ac9			 
0ac9			;	ex de, hl 
0ac9 01 4f 00			ld bc, display_fb_len -1  
0acc			 
0acc			 
0acc				 
0acc			 
0acc ed b0			ldir 
0ace			 
0ace				; wipe bottom row 
0ace			 
0ace			 
0ace			;	ld hl, (display_fb_active) 
0ace			;;	ld de, display_cols*display_rows 
0ace			;;	add hl, de 
0ace			;	ld b, display_cols 
0ace			;	ld a, ' ' 
0ace			;.scwiped: 
0ace			;	ld (hl), a 
0ace			;	dec hl 
0ace			;	djnz .scwiped 
0ace			 
0ace				;pop hl 
0ace			 
0ace c1				pop bc 
0acf d1				pop de 
0ad0 e1				pop hl 
0ad1			 
0ad1 c9				ret 
0ad2			;scroll_down: 
0ad2			;	ld de, display_row_4 
0ad2			;	ld hl, display_row_3 
0ad2			;	ld bc, display_cols 
0ad2			;	ldir 
0ad2			;	ld de, display_row_3 
0ad2			; 	ld hl, display_row_2 
0ad2			;	ld bc, display_cols 
0ad2			;	ldir 
0ad2			;	ld de, display_row_2 
0ad2			;	ld hl, display_row_1 
0ad2			;	ld bc, display_cols 
0ad2			;	ldir 
0ad2			;;; TODO clear row 1 
0ad2			;	ret 
0ad2			 
0ad2			 
0ad2			 
0ad2			 
0ad2			 
0ad2			; clear active frame buffer 
0ad2			 
0ad2			clear_display: 
0ad2 3e 20			ld a, ' ' 
0ad4 c3 d7 0a			jp fill_display 
0ad7			 
0ad7			; fill active frame buffer with a char in A 
0ad7			 
0ad7			fill_display: 
0ad7 06 50			ld b,display_fb_len 
0ad9 2a 5e fa			ld hl, (display_fb_active) 
0adc 77			.fd1:	ld (hl),a 
0add 23				inc hl 
0ade 10 fc			djnz .fd1 
0ae0 23				inc hl 
0ae1 3e 00			ld a,0 
0ae3 77				ld (hl),a 
0ae4			 
0ae4			 
0ae4 c9				ret 
0ae5			; Write string (DE) at pos (A) to active frame buffer 
0ae5			 
0ae5 2a 5e fa		str_at_display:    ld hl,(display_fb_active) 
0ae8 06 00					ld b,0 
0aea 4f					ld c,a 
0aeb 09					add hl,bc 
0aec 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0aed b7			            OR   A              ;Null terminator? 
0aee c8			            RET  Z              ;Yes, so finished 
0aef 77					ld (hl),a 
0af0 23				inc hl 
0af1 13			            INC  DE             ;Point to next character 
0af2 18 f8		            JR   .sad1     ;Repeat 
0af4 c9					ret 
0af5			 
0af5			; using current frame buffer write to physical display 
0af5			 
0af5			update_display: 
0af5 e5				push hl 
0af6 2a 5e fa			ld hl, (display_fb_active) 
0af9 cd a5 64			call write_display 
0afc e1				pop hl 
0afd c9				ret 
0afe			 
0afe			; TODO scrolling 
0afe			 
0afe			 
0afe			; move cursor right one char 
0afe			cursor_right: 
0afe			 
0afe				; TODO shift right 
0afe				; TODO if beyond max col 
0afe				; TODO       cursor_next_line 
0afe			 
0afe c9				ret 
0aff			 
0aff			 
0aff			cursor_next_line: 
0aff				; TODO first char 
0aff				; TODO line down 
0aff				; TODO if past last row 
0aff				; TODO    scroll up 
0aff			 
0aff c9				ret 
0b00			 
0b00			cursor_left: 
0b00				; TODO shift left 
0b00				; TODO if beyond left  
0b00				; TODO     cursor prev line 
0b00				 
0b00 c9				ret 
0b01			 
0b01			cursor_prev_line: 
0b01				; TODO last char 
0b01				; TODO line up 
0b01				; TODO if past first row 
0b01				; TODO   scroll down 
0b01			 
0b01 c9				ret 
0b02			 
0b02			 
0b02			cout: 
0b02				; A - char 
0b02 c9				ret 
0b03			 
0b03			 
0b03			; Display a menu and allow item selection (optional toggle items) 
0b03			; 
0b03			; format: 
0b03			; hl pointer to word array with zero term for items 
0b03			; e.g.    db item1 
0b03			;         db .... 
0b03			;         db 0 
0b03			; 
0b03			; a = starting menu item  
0b03			; 
0b03			; de = pointer item toggle array   (todo) 
0b03			; 
0b03			; returns item selected in a 1-... 
0b03			; returns 0 if back button pressed 
0b03			; 
0b03			; NOTE: Uses system frame buffer to display 
0b03			; 
0b03			; LEFT, Q = go back 
0b03			; RIGHT, SPACE, CR = select 
0b03			; UP, A - Up 
0b03			; DOWN, Z - Down 
0b03			 
0b03			 
0b03			 
0b03			 
0b03			 
0b03			menu: 
0b03			 
0b03					; keep array pointer 
0b03			 
0b03 22 e6 f9				ld (store_tmp1), hl 
0b06 32 e4 f9				ld (store_tmp2), a 
0b09			 
0b09					; check for key bounce 
0b09			 
0b09			if BASE_KEV 
0b09			 
0b09 cd 5a 66		.mbounce:	call cin 
0b0c fe 00				cp 0 
0b0e 20 f9				jr nz, .mbounce 
0b10			endif 
0b10					; for ease use ex 
0b10			 
0b10					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0b10 21 53 fb				ld hl, display_fb0 
0b13 22 5e fa				ld (display_fb_active), hl 
0b16			 
0b16 cd d2 0a		.mloop:		call clear_display 
0b19 cd f5 0a				call update_display 
0b1c			 
0b1c					; draw selection id '>' at 1 
0b1c			 
0b1c					; init start of list display 
0b1c			 
0b1c 3e 05				ld a, 5 
0b1e 32 e2 f9				ld (store_tmp3), a   ; display row count 
0b21 3a e4 f9				ld a,( store_tmp2) 
0b24 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0b27			 
0b27					 
0b27			.mitem:	 
0b27			 
0b27			 
0b27 3a e5 f9				ld a,(store_tmp2+1) 
0b2a 6f					ld l, a 
0b2b 26 00				ld h, 0 
0b2d 29					add hl, hl 
0b2e ed 5b e6 f9			ld de, (store_tmp1) 
0b32 19					add hl, de 
0b33 7e					ld a, (hl) 
0b34 23					inc hl 
0b35 66					ld h,(hl) 
0b36 6f					ld l, a 
0b37			 
0b37 cd 2f 0d				call ishlzero 
0b3a 28 1a				jr z, .mdone 
0b3c			 
0b3c eb					ex de, hl 
0b3d 3a e2 f9				ld a, (store_tmp3) 
0b40 cd e5 0a				call str_at_display 
0b43					 
0b43			 
0b43					; next item 
0b43 3a e5 f9				ld a, (store_tmp2+1) 
0b46 3c					inc a 
0b47 32 e5 f9				ld (store_tmp2+1), a   ; display item count 
0b4a			 
0b4a			 		; next row 
0b4a			 
0b4a 3a e2 f9				ld a, (store_tmp3) 
0b4d c6 14				add display_cols 
0b4f 32 e2 f9				ld (store_tmp3), a 
0b52			 
0b52					; at end of screen? 
0b52			 
0b52 fe 10				cp display_rows*4 
0b54 20 d1				jr nz, .mitem 
0b56			 
0b56			 
0b56			.mdone: 
0b56 cd 2f 0d				call ishlzero 
0b59 28 08				jr z, .nodn 
0b5b			 
0b5b 3e 3c				ld a, display_row_4 
0b5d 11 dc 0b				ld de, .mdown 
0b60 cd e5 0a				call str_at_display 
0b63			 
0b63					; draw options to fill the screens with active item on line 1 
0b63					; if current option is 2 or more then display ^ in top 
0b63			 
0b63 3a e4 f9		.nodn:		ld a, (store_tmp2) 
0b66 fe 00				cp 0 
0b68 28 08				jr z, .noup 
0b6a			 
0b6a 3e 00				ld a, 0 
0b6c 11 da 0b				ld de, .mup 
0b6f cd e5 0a				call str_at_display 
0b72			 
0b72 3e 02		.noup:		ld a, 2 
0b74 11 d8 0b				ld de, .msel 
0b77 cd e5 0a				call str_at_display 
0b7a			 
0b7a					; if current option + 1 is not null then display V in bottom 
0b7a					; get key 
0b7a cd f5 0a				call update_display 
0b7d			 
0b7d			 
0b7d					; handle key 
0b7d			 
0b7d cd 49 66				call cin_wait 
0b80			 
0b80 fe 05				cp KEY_UP 
0b82 28 2b				jr z, .mgoup 
0b84 fe 61				cp 'a' 
0b86 28 27				jr z, .mgoup 
0b88 fe 0a				cp KEY_DOWN 
0b8a 28 32				jr z, .mgod 
0b8c fe 7a				cp 'z' 
0b8e 28 2e				jr z, .mgod 
0b90 fe 20				cp ' ' 
0b92 28 34				jr z, .goend 
0b94 fe 0c				cp KEY_RIGHT 
0b96 28 30				jr z, .goend 
0b98 fe 0d				cp KEY_CR 
0b9a 28 2c				jr z, .goend 
0b9c fe 71				cp 'q' 
0b9e 28 0b				jr z, .goback 
0ba0			 
0ba0 fe 0b				cp KEY_LEFT 
0ba2 28 07				jr z, .goback 
0ba4 fe 08				cp KEY_BS 
0ba6 28 03				jr z, .goback 
0ba8 c3 16 0b				jp .mloop 
0bab			 
0bab			.goback: 
0bab 3e 00			ld a, 0 
0bad 18 1d			jr .goend2 
0baf			 
0baf				; move up one 
0baf			.mgoup: 
0baf 3a e4 f9				ld a, (store_tmp2) 
0bb2 fe 00				cp 0 
0bb4 ca 16 0b				jp z, .mloop 
0bb7 3d					dec a 
0bb8 32 e4 f9				ld (store_tmp2), a 
0bbb c3 16 0b				jp .mloop 
0bbe			 
0bbe				; move down one 
0bbe			.mgod: 
0bbe 3a e4 f9				ld a, (store_tmp2) 
0bc1 3c					inc a 
0bc2 32 e4 f9				ld (store_tmp2), a 
0bc5 c3 16 0b				jp .mloop 
0bc8			 
0bc8			 
0bc8			.goend: 
0bc8					; get selected item number 
0bc8			 
0bc8 3a e4 f9				ld a, (store_tmp2) 
0bcb 3c					inc a 
0bcc			 
0bcc			.goend2: 
0bcc f5					push af 
0bcd			 
0bcd					; restore active fb 
0bcd					; TODO BUG assumes fb1 
0bcd			 
0bcd 21 02 fb				ld hl, display_fb1 
0bd0 22 5e fa				ld (display_fb_active), hl 
0bd3			 
0bd3					; restore main regs 
0bd3			 
0bd3			 
0bd3 cd f5 0a				call update_display 
0bd6			 
0bd6 f1					pop af 
0bd7			 
0bd7 c9				ret 
0bd8			 
0bd8 .. 00		.msel:   db ">",0 
0bda .. 00		.mup:   db "^",0 
0bdc .. 00		.mdown:   db "v",0 
0bde			 
0bde			 
0bde			; eof 
0bde			 
# End of file firmware_display.asm
0bde			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0bde			; random number generators 
0bde			 
0bde			 
0bde			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0bde			 
0bde			 
0bde			;-----> Generate a random number 
0bde			; output a=answer 0<=a<=255 
0bde			; all registers are preserved except: af 
0bde			random: 
0bde e5			        push    hl 
0bdf d5			        push    de 
0be0 2a 40 fa		        ld      hl,(randData) 
0be3 ed 5f		        ld      a,r 
0be5 57			        ld      d,a 
0be6 5e			        ld      e,(hl) 
0be7 19			        add     hl,de 
0be8 85			        add     a,l 
0be9 ac			        xor     h 
0bea 22 40 fa		        ld      (randData),hl 
0bed d1			        pop     de 
0bee e1			        pop     hl 
0bef c9			        ret 
0bf0			 
0bf0			 
0bf0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0bf0			 
0bf0			 
0bf0			 
0bf0			;------LFSR------ 
0bf0			;James Montelongo 
0bf0			;optimized by Spencer Putt 
0bf0			;out: 
0bf0			; a = 8 bit random number 
0bf0			RandLFSR: 
0bf0 21 46 fa		        ld hl,LFSRSeed+4 
0bf3 5e			        ld e,(hl) 
0bf4 23			        inc hl 
0bf5 56			        ld d,(hl) 
0bf6 23			        inc hl 
0bf7 4e			        ld c,(hl) 
0bf8 23			        inc hl 
0bf9 7e			        ld a,(hl) 
0bfa 47			        ld b,a 
0bfb cb 13		        rl e  
0bfd cb 12			rl d 
0bff cb 11		        rl c  
0c01 17				rla 
0c02 cb 13		        rl e  
0c04 cb 12			rl d 
0c06 cb 11		        rl c  
0c08 17				rla 
0c09 cb 13		        rl e  
0c0b cb 12			rl d 
0c0d cb 11		        rl c  
0c0f 17				rla 
0c10 67			        ld h,a 
0c11 cb 13		        rl e  
0c13 cb 12			rl d 
0c15 cb 11		        rl c  
0c17 17				rla 
0c18 a8			        xor b 
0c19 cb 13		        rl e  
0c1b cb 12			rl d 
0c1d ac			        xor h 
0c1e a9			        xor c 
0c1f aa			        xor d 
0c20 21 48 fa		        ld hl,LFSRSeed+6 
0c23 11 49 fa		        ld de,LFSRSeed+7 
0c26 01 07 00		        ld bc,7 
0c29 ed b8		        lddr 
0c2b 12			        ld (de),a 
0c2c c9			        ret 
0c2d			 
0c2d			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0c2d			 
0c2d			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0c2d			 
0c2d			 
0c2d			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0c2d			 
0c2d			prng16: 
0c2d			;Inputs: 
0c2d			;   (seed1) contains a 16-bit seed value 
0c2d			;   (seed2) contains a NON-ZERO 16-bit seed value 
0c2d			;Outputs: 
0c2d			;   HL is the result 
0c2d			;   BC is the result of the LCG, so not that great of quality 
0c2d			;   DE is preserved 
0c2d			;Destroys: 
0c2d			;   AF 
0c2d			;cycle: 4,294,901,760 (almost 4.3 billion) 
0c2d			;160cc 
0c2d			;26 bytes 
0c2d 2a 3a fa		    ld hl,(seed1) 
0c30 44			    ld b,h 
0c31 4d			    ld c,l 
0c32 29			    add hl,hl 
0c33 29			    add hl,hl 
0c34 2c			    inc l 
0c35 09			    add hl,bc 
0c36 22 3a fa		    ld (seed1),hl 
0c39 2a 38 fa		    ld hl,(seed2) 
0c3c 29			    add hl,hl 
0c3d 9f			    sbc a,a 
0c3e e6 2d		    and %00101101 
0c40 ad			    xor l 
0c41 6f			    ld l,a 
0c42 22 38 fa		    ld (seed2),hl 
0c45 09			    add hl,bc 
0c46 c9			    ret 
0c47			 
0c47			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0c47			 
0c47			rand32: 
0c47			;Inputs: 
0c47			;   (seed1_0) holds the lower 16 bits of the first seed 
0c47			;   (seed1_1) holds the upper 16 bits of the first seed 
0c47			;   (seed2_0) holds the lower 16 bits of the second seed 
0c47			;   (seed2_1) holds the upper 16 bits of the second seed 
0c47			;   **NOTE: seed2 must be non-zero 
0c47			;Outputs: 
0c47			;   HL is the result 
0c47			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0c47			;Destroys: 
0c47			;   AF 
0c47			;Tested and passes all CAcert tests 
0c47			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0c47			;it has a period of 18,446,744,069,414,584,320 
0c47			;roughly 18.4 quintillion. 
0c47			;LFSR taps: 0,2,6,7  = 11000101 
0c47			;291cc 
0c47			;seed1_0=$+1 
0c47			;    ld hl,12345 
0c47			;seed1_1=$+1 
0c47			;    ld de,6789 
0c47			;    ld b,h 
0c47			;    ld c,l 
0c47			;    add hl,hl \ rl e \ rl d 
0c47			;    add hl,hl \ rl e \ rl d 
0c47			;    inc l 
0c47			;    add hl,bc 
0c47			;    ld (seed1_0),hl 
0c47			;    ld hl,(seed1_1) 
0c47			;    adc hl,de 
0c47			;    ld (seed1_1),hl 
0c47			;    ex de,hl 
0c47			;seed2_0=$+1 
0c47			;    ld hl,9876 
0c47			;seed2_1=$+1 
0c47			;    ld bc,54321 
0c47			;    add hl,hl \ rl c \ rl b 
0c47			;    ld (seed2_1),bc 
0c47			;    sbc a,a 
0c47			;    and %11000101 
0c47			;    xor l 
0c47			;    ld l,a 
0c47			;    ld (seed2_0),hl 
0c47			;    ex de,hl 
0c47			;    add hl,bc 
0c47			;    ret 
0c47			; 
0c47			 
0c47			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0c47			; 20 bytes, 86 cycles (excluding ret) 
0c47			 
0c47			; returns   hl = pseudorandom number 
0c47			; corrupts   a 
0c47			 
0c47			; generates 16-bit pseudorandom numbers with a period of 65535 
0c47			; using the xorshift method: 
0c47			 
0c47			; hl ^= hl << 7 
0c47			; hl ^= hl >> 9 
0c47			; hl ^= hl << 8 
0c47			 
0c47			; some alternative shift triplets which also perform well are: 
0c47			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0c47			 
0c47			;  org 32768 
0c47			 
0c47			xrnd: 
0c47 2a 3e fa		  ld hl,(xrandc)       ; seed must not be 0 
0c4a 3e 00		  ld a,0 
0c4c bd			  cp l 
0c4d 20 02		  jr nz, .xrnd1 
0c4f 2e 01		  ld l, 1 
0c51			.xrnd1: 
0c51			 
0c51 7c			  ld a,h 
0c52 1f			  rra 
0c53 7d			  ld a,l 
0c54 1f			  rra 
0c55 ac			  xor h 
0c56 67			  ld h,a 
0c57 7d			  ld a,l 
0c58 1f			  rra 
0c59 7c			  ld a,h 
0c5a 1f			  rra 
0c5b ad			  xor l 
0c5c 6f			  ld l,a 
0c5d ac			  xor h 
0c5e 67			  ld h,a 
0c5f			 
0c5f 22 3e fa		  ld (xrandc),hl 
0c62			 
0c62 c9			  ret 
0c63			;  
0c63			 
0c63			 
0c63			;;;; int maths 
0c63			 
0c63			; https://map.grauw.nl/articles/mult_div_shifts.php 
0c63			; Divide 16-bit values (with 16-bit result) 
0c63			; In: Divide BC by divider DE 
0c63			; Out: BC = result, HL = rest 
0c63			; 
0c63			Div16: 
0c63 21 00 00		    ld hl,0 
0c66 78			    ld a,b 
0c67 06 08		    ld b,8 
0c69			Div16_Loop1: 
0c69 17			    rla 
0c6a ed 6a		    adc hl,hl 
0c6c ed 52		    sbc hl,de 
0c6e 30 01		    jr nc,Div16_NoAdd1 
0c70 19			    add hl,de 
0c71			Div16_NoAdd1: 
0c71 10 f6		    djnz Div16_Loop1 
0c73 17			    rla 
0c74 2f			    cpl 
0c75 47			    ld b,a 
0c76 79			    ld a,c 
0c77 48			    ld c,b 
0c78 06 08		    ld b,8 
0c7a			Div16_Loop2: 
0c7a 17			    rla 
0c7b ed 6a		    adc hl,hl 
0c7d ed 52		    sbc hl,de 
0c7f 30 01		    jr nc,Div16_NoAdd2 
0c81 19			    add hl,de 
0c82			Div16_NoAdd2: 
0c82 10 f6		    djnz Div16_Loop2 
0c84 17			    rla 
0c85 2f			    cpl 
0c86 41			    ld b,c 
0c87 4f			    ld c,a 
0c88 c9			ret 
0c89			 
0c89			 
0c89			;http://z80-heaven.wikidot.com/math 
0c89			; 
0c89			;Inputs: 
0c89			;     DE and A are factors 
0c89			;Outputs: 
0c89			;     A is not changed 
0c89			;     B is 0 
0c89			;     C is not changed 
0c89			;     DE is not changed 
0c89			;     HL is the product 
0c89			;Time: 
0c89			;     342+6x 
0c89			; 
0c89			Mult16: 
0c89			 
0c89 06 08		     ld b,8          ;7           7 
0c8b 21 00 00		     ld hl,0         ;10         10 
0c8e 29			       add hl,hl     ;11*8       88 
0c8f 07			       rlca          ;4*8        32 
0c90 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c92 19			         add hl,de   ;--         -- 
0c93 10 f9		       djnz $-5      ;13*7+8     99 
0c95 c9			ret 
0c96			 
0c96			; 
0c96			; Square root of 16-bit value 
0c96			; In:  HL = value 
0c96			; Out:  D = result (rounded down) 
0c96			; 
0c96			;Sqr16: 
0c96			;    ld de,#0040 
0c96			;    ld a,l 
0c96			;    ld l,h 
0c96			;    ld h,d 
0c96			;    or a 
0c96			;    ld b,8 
0c96			;Sqr16_Loop: 
0c96			;    sbc hl,de 
0c96			;    jr nc,Sqr16_Skip 
0c96			;    add hl,de 
0c96			;Sqr16_Skip: 
0c96			;    ccf 
0c96			;    rl d 
0c96			;    add a,a 
0c96			;    adc hl,hl 
0c96			;    add a,a 
0c96			;    adc hl,hl 
0c96			;    djnz Sqr16_Loop 
0c96			;    ret 
0c96			; 
0c96			; 
0c96			; Divide 8-bit values 
0c96			; In: Divide E by divider C 
0c96			; Out: A = result, B = rest 
0c96			; 
0c96			Div8: 
0c96 af			    xor a 
0c97 06 08		    ld b,8 
0c99			Div8_Loop: 
0c99 cb 13		    rl e 
0c9b 17			    rla 
0c9c 91			    sub c 
0c9d 30 01		    jr nc,Div8_NoAdd 
0c9f 81			    add a,c 
0ca0			Div8_NoAdd: 
0ca0 10 f7		    djnz Div8_Loop 
0ca2 47			    ld b,a 
0ca3 7b			    ld a,e 
0ca4 17			    rla 
0ca5 2f			    cpl 
0ca6 c9			    ret 
0ca7			 
0ca7			; 
0ca7			; Multiply 8-bit value with a 16-bit value (unrolled) 
0ca7			; In: Multiply A with DE 
0ca7			; Out: HL = result 
0ca7			; 
0ca7			Mult12U: 
0ca7 2e 00		    ld l,0 
0ca9 87			    add a,a 
0caa 30 01		    jr nc,Mult12U_NoAdd0 
0cac 19			    add hl,de 
0cad			Mult12U_NoAdd0: 
0cad 29			    add hl,hl 
0cae 87			    add a,a 
0caf 30 01		    jr nc,Mult12U_NoAdd1 
0cb1 19			    add hl,de 
0cb2			Mult12U_NoAdd1: 
0cb2 29			    add hl,hl 
0cb3 87			    add a,a 
0cb4 30 01		    jr nc,Mult12U_NoAdd2 
0cb6 19			    add hl,de 
0cb7			Mult12U_NoAdd2: 
0cb7 29			    add hl,hl 
0cb8 87			    add a,a 
0cb9 30 01		    jr nc,Mult12U_NoAdd3 
0cbb 19			    add hl,de 
0cbc			Mult12U_NoAdd3: 
0cbc 29			    add hl,hl 
0cbd 87			    add a,a 
0cbe 30 01		    jr nc,Mult12U_NoAdd4 
0cc0 19			    add hl,de 
0cc1			Mult12U_NoAdd4: 
0cc1 29			    add hl,hl 
0cc2 87			    add a,a 
0cc3 30 01		    jr nc,Mult12U_NoAdd5 
0cc5 19			    add hl,de 
0cc6			Mult12U_NoAdd5: 
0cc6 29			    add hl,hl 
0cc7 87			    add a,a 
0cc8 30 01		    jr nc,Mult12U_NoAdd6 
0cca 19			    add hl,de 
0ccb			Mult12U_NoAdd6: 
0ccb 29			    add hl,hl 
0ccc 87			    add a,a 
0ccd d0			    ret nc 
0cce 19			    add hl,de 
0ccf c9			    ret 
0cd0			 
0cd0			; 
0cd0			; Multiply 8-bit value with a 16-bit value (right rotating) 
0cd0			; In: Multiply A with DE 
0cd0			;      Put lowest value in A for most efficient calculation 
0cd0			; Out: HL = result 
0cd0			; 
0cd0			Mult12R: 
0cd0 21 00 00		    ld hl,0 
0cd3			Mult12R_Loop: 
0cd3 cb 3f		    srl a 
0cd5 30 01		    jr nc,Mult12R_NoAdd 
0cd7 19			    add hl,de 
0cd8			Mult12R_NoAdd: 
0cd8 cb 23		    sla e 
0cda cb 12		    rl d 
0cdc b7			    or a 
0cdd c2 d3 0c		    jp nz,Mult12R_Loop 
0ce0 c9			    ret 
0ce1			 
0ce1			; 
0ce1			; Multiply 16-bit values (with 32-bit result) 
0ce1			; In: Multiply BC with DE 
0ce1			; Out: BCHL = result 
0ce1			; 
0ce1			Mult32: 
0ce1 79			    ld a,c 
0ce2 48			    ld c,b 
0ce3 21 00 00		    ld hl,0 
0ce6 06 10		    ld b,16 
0ce8			Mult32_Loop: 
0ce8 29			    add hl,hl 
0ce9 17			    rla 
0cea cb 11		    rl c 
0cec 30 07		    jr nc,Mult32_NoAdd 
0cee 19			    add hl,de 
0cef ce 00		    adc a,0 
0cf1 d2 f5 0c		    jp nc,Mult32_NoAdd 
0cf4 0c			    inc c 
0cf5			Mult32_NoAdd: 
0cf5 10 f1		    djnz Mult32_Loop 
0cf7 41			    ld b,c 
0cf8 4f			    ld c,a 
0cf9 c9			    ret 
0cfa			 
0cfa			 
0cfa			 
0cfa			; 
0cfa			; Multiply 8-bit values 
0cfa			; In:  Multiply H with E 
0cfa			; Out: HL = result 
0cfa			; 
0cfa			Mult8: 
0cfa 16 00		    ld d,0 
0cfc 6a			    ld l,d 
0cfd 06 08		    ld b,8 
0cff			Mult8_Loop: 
0cff 29			    add hl,hl 
0d00 30 01		    jr nc,Mult8_NoAdd 
0d02 19			    add hl,de 
0d03			Mult8_NoAdd: 
0d03 10 fa		    djnz Mult8_Loop 
0d05 c9			    ret 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			 
0d06			;;http://z80-heaven.wikidot.com/math 
0d06			;;This divides DE by BC, storing the result in DE, remainder in HL 
0d06			; 
0d06			;DE_Div_BC:          ;1281-2x, x is at most 16 
0d06			;     ld a,16        ;7 
0d06			;     ld hl,0        ;10 
0d06			;     jp $+5         ;10 
0d06			;.DivLoop: 
0d06			;       add hl,bc    ;-- 
0d06			;       dec a        ;64 
0d06			;       jr z,.DivLoopEnd        ;86 
0d06			; 
0d06			;       sla e        ;128 
0d06			;       rl d         ;128 
0d06			;       adc hl,hl    ;240 
0d06			;       sbc hl,bc    ;240 
0d06			;       jr nc,.DivLoop ;23|21 
0d06			;       inc e        ;-- 
0d06			;       jp .DivLoop+1 
0d06			; 
0d06			;.DivLoopEnd: 
0d06			 
0d06			;HL_Div_C: 
0d06			;Inputs: 
0d06			;     HL is the numerator 
0d06			;     C is the denominator 
0d06			;Outputs: 
0d06			;     A is the remainder 
0d06			;     B is 0 
0d06			;     C is not changed 
0d06			;     DE is not changed 
0d06			;     HL is the quotient 
0d06			; 
0d06			;       ld b,16 
0d06			;       xor a 
0d06			;         add hl,hl 
0d06			;         rla 
0d06			;         cp c 
0d06			;         jr c,$+4 
0d06			;           inc l 
0d06			;           sub c 
0d06			;         djnz $-7 
0d06			 
0d06			; https://plutiedev.com/z80-add-8bit-to-16bit 
0d06			 
0d06			addatohl: 
0d06 85			    add   a, l    ; A = A+L 
0d07 6f			    ld    l, a    ; L = A+L 
0d08 8c			    adc   a, h    ; A = A+L+H+carry 
0d09 95			    sub   l       ; A = H+carry 
0d0a 67			    ld    h, a    ; H = H+carry 
0d0b c9			ret 
0d0c			 
0d0c			addatode: 
0d0c 83			    add   a, e    ; A = A+L 
0d0d 5f			    ld    e, a    ; L = A+L 
0d0e 8a			    adc   a, d    ; A = A+L+H+carry 
0d0f 93			    sub   e       ; A = H+carry 
0d10 57			    ld    d, a    ; H = H+carry 
0d11 c9			ret 
0d12			 
0d12			 
0d12			addatobc: 
0d12 81			    add   a, c    ; A = A+L 
0d13 4f			    ld    c, a    ; L = A+L 
0d14 88			    adc   a, b    ; A = A+L+H+carry 
0d15 91			    sub   c       ; A = H+carry 
0d16 47			    ld    b, a    ; H = H+carry 
0d17 c9			ret 
0d18			 
0d18			subafromhl: 
0d18			   ; If A=0 do nothing 
0d18			    ; Otherwise flip A's sign. Since 
0d18			    ; the upper byte becomes -1, also 
0d18			    ; substract 1 from H. 
0d18 ed 44		    neg 
0d1a ca 23 0d		    jp    z, Skip 
0d1d 25			    dec   h 
0d1e			     
0d1e			    ; Now add the low byte as usual 
0d1e			    ; Two's complement takes care of 
0d1e			    ; ensuring the result is correct 
0d1e 85			    add   a, l 
0d1f 6f			    ld    l, a 
0d20 8c			    adc   a, h 
0d21 95			    sub   l 
0d22 67			    ld    h, a 
0d23			Skip: 
0d23 c9				ret 
0d24			 
0d24			 
0d24			; compare hl and de 
0d24			; returns:  
0d24			; if hl = de, z=1, s=0, c0=0 
0d24			; if hl > de, z=0, s=0, c=0 
0d24			; if hl < de, z=0, s=1, c=1 
0d24			cmp16:	 
0d24 b7				or a 
0d25 ed 52			sbc hl,de 
0d27 e0				ret po 
0d28 7c				ld a,h 
0d29 1f				rra 
0d2a ee 40			xor 01000000B 
0d2c 37				scf 
0d2d 8f				adc a,a 
0d2e c9				ret 
0d2f			 
0d2f			 
0d2f			; test if hl contains zero   - A is destroyed 
0d2f			 
0d2f			ishlzero:    
0d2f b7				or a     ; reset flags 
0d30 7c				ld a, h 
0d31 b5				or l        	 
0d32			 
0d32 c9				ret 
0d33			 
0d33			 
0d33			 
0d33			 
0d33			if FORTH_ENABLE_FLOATMATH 
0d33			;include "float/bbcmath.z80" 
0d33			include "float/lpfpcalc.asm" 
0d33			endif 
0d33			 
0d33			 
0d33			; eof 
0d33			 
# End of file firmware_maths.asm
0d33			include "firmware_strings.asm"   ; string handling  
0d33			 
0d33			 
0d33			; TODO string len 
0d33			; input text string, end on cr with zero term 
0d33			; a offset into frame buffer to start prompt 
0d33			; d is max length 
0d33			; e is display size TODO 
0d33			; c is current cursor position 
0d33			; hl is ptr to where string will be stored 
0d33			 
0d33			 
0d33			; TODO check limit of buffer for new inserts 
0d33			; TODO check insert does not push beyond buffer 
0d33			; TODO scroll in a limited display area 
0d33			; TODO scroll whole screen on page wrap 
0d33			 
0d33			 
0d33			; TODO handle KEY_PREVWORD 
0d33			; TODO handle KEY_NEXTWORD 
0d33			; TODO handle KEY_HOME 
0d33			; TODO handle KEY_END 
0d33			; TODO use LCD cursor? 
0d33			 
0d33 32 b6 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0d36 81					add c 
0d37 32 b4 fb				ld (input_at_cursor),a	; save draw pos of cursor 
0d3a 22 b9 fb				ld (input_start), hl     ; save ptr to buffer 
0d3d 79					ld a, c 
0d3e cd 06 0d				call addatohl 
0d41 22 bb fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0d44 7a					ld a,d 
0d45 32 b8 fb			        ld (input_size), a       ; save length of input area 
0d48 79					ld a, c 
0d49 32 a7 fb				ld (input_cursor),a      ; init cursor start position  
0d4c 7b					ld a,e 
0d4d 32 b7 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0d50					 
0d50					 
0d50			 
0d50			;		ld a,(input_ptr) 
0d50			;		ld (input_under_cursor),a 	; save what is under the cursor 
0d50			 
0d50			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0d50					; init cursor shape if not set by the cin routines 
0d50 21 56 fa				ld hl, cursor_shape 
0d53 3e ff				ld a, 255 
0d55 77					ld (hl), a 
0d56 23					inc hl 
0d57 3e 00				ld a, 0 
0d59 77					ld (hl), a 
0d5a			 
0d5a 3e 0f				ld a, CUR_BLINK_RATE 
0d5c 32 b2 fb				ld (input_cur_flash), a 
0d5f 3e 01				ld a, 1 
0d61 32 b1 fb				ld (input_cur_onoff),a 
0d64			 
0d64			;	if DEBUG_INPUT 
0d64			;		push af 
0d64			;		ld a, 'I' 
0d64			;		ld (debug_mark),a 
0d64			;		pop af 
0d64			;		CALLMONITOR 
0d64			;	endif 
0d64			.is1:		; main entry loop 
0d64			 
0d64			 
0d64			 
0d64					; pause 1ms 
0d64			 
0d64 3e 01				ld a, 1 
0d66 cd 37 0a				call aDelayInMS 
0d69			 
0d69					; dec flash counter 
0d69 3a b2 fb				ld a, (input_cur_flash) 
0d6c 3d					dec a 
0d6d 32 b2 fb				ld (input_cur_flash), a 
0d70 fe 00				cp 0 
0d72 20 0d				jr nz, .nochgstate 
0d74			 
0d74			 
0d74					; change state 
0d74 3a b1 fb				ld a,(input_cur_onoff) 
0d77 ed 44				neg 
0d79 32 b1 fb				ld (input_cur_onoff),a 
0d7c			 
0d7c			 
0d7c					; reset on change of state 
0d7c 3e 0f				ld a, CUR_BLINK_RATE 
0d7e 32 b2 fb				ld (input_cur_flash), a 
0d81			 
0d81			.nochgstate: 
0d81					 
0d81					 
0d81			 
0d81					; display cursor  
0d81			 
0d81			;		ld hl, (input_start) 
0d81			;		ld a, (input_cursor) 
0d81			;		call addatohl 
0d81			 
0d81					; get char under cursor and replace with cursor 
0d81 2a bb fb		ld hl, (input_ptr) 
0d84			;		ld a, (hl) 
0d84			;		ld (input_under_cursor),a 
0d84			;		ld a, '_' 
0d84			;		ld (hl), a 
0d84			 
0d84					; display string 
0d84			 
0d84 ed 5b b9 fb			ld de, (input_start) 
0d88 3a b6 fb				ld a, (input_at_pos) 
0d8b cd e5 0a				call str_at_display 
0d8e			;	        call update_display 
0d8e			 
0d8e					; find place to put the cursor 
0d8e			;		add h 
0d8e			;		ld l, display_row_1 
0d8e			;		sub l 
0d8e			; (input_at_pos) 
0d8e					;ld c, a 
0d8e			;		ld a, (input_cursor) 
0d8e			;		ld l, (input_at_pos) 
0d8e			;		;ld b, h 
0d8e			;		add l 
0d8e			;		ld (input_at_cursor),a 
0d8e					;ld l,h 
0d8e			 
0d8e			;		ld h, 0 
0d8e			;		ld l,(input_at_pos) 
0d8e			;		ld a, (input_cursor) 
0d8e			;		call addatohl 
0d8e			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d8e			;		call subafromhl 
0d8e			;		ld a,l 
0d8e			;		ld (input_at_cursor), a 
0d8e			 
0d8e				if DEBUG_INPUT 
0d8e					ld a, (hardware_diag) 
0d8e					cp 0 
0d8e					jr z, .skip_input_diag 
0d8e			 
0d8e					ld a,(input_at_pos) 
0d8e					ld hl, LFSRSeed 
0d8e					call hexout 
0d8e					ld a, (input_cursor) 
0d8e					ld hl, LFSRSeed+2 
0d8e					call hexout 
0d8e					ld a,(input_at_cursor) 
0d8e					ld hl, LFSRSeed+4 
0d8e					call hexout 
0d8e			 
0d8e					ld a,(input_cur_onoff) 
0d8e					ld hl, LFSRSeed+6 
0d8e					call hexout 
0d8e			 
0d8e					ld a,(input_cur_flash) 
0d8e					ld hl, LFSRSeed+8 
0d8e					call hexout 
0d8e			 
0d8e					ld a,(input_len) 
0d8e					ld hl, LFSRSeed+10 
0d8e					call hexout 
0d8e					ld hl, LFSRSeed+12 
0d8e					ld a, 0 
0d8e					ld (hl),a 
0d8e					ld a, display_row_4 
0d8e					ld de, LFSRSeed 
0d8e					call str_at_display 
0d8e					.skip_input_diag: 
0d8e				endif 
0d8e			 
0d8e					; decide on if we are showing the cursor this time round 
0d8e			 
0d8e 3a b1 fb				ld a, (input_cur_onoff) 
0d91 fe ff				cp 255 
0d93 28 13				jr z, .skipcur 
0d95			 
0d95			 
0d95 3a b4 fb				ld a,(input_at_cursor) 
0d98 11 56 fa				ld de, cursor_shape 
0d9b cd e5 0a				call str_at_display 
0d9e			 
0d9e					; save length of current input string 
0d9e 2a b9 fb				ld hl, (input_start) 
0da1 cd 64 11				call strlenz 
0da4 7d					ld a,l 
0da5 32 ac fb				ld (input_len),a 
0da8			 
0da8			.skipcur: 
0da8			 
0da8 cd f5 0a			        call update_display 
0dab					 
0dab			 
0dab			 
0dab					; wait 
0dab				 
0dab					; TODO loop without wait to flash the cursor and char under cursor	 
0dab cd 5a 66				call cin    ; _wait 
0dae			 
0dae fe 00				cp 0 
0db0 ca 64 0d				jp z, .is1 
0db3			 
0db3					; get ptr to char to input into 
0db3			 
0db3 4f					ld c,a 
0db4 2a b9 fb				ld hl, (input_start) 
0db7 3a a7 fb				ld a, (input_cursor) 
0dba cd 06 0d				call addatohl 
0dbd 22 bb fb				ld (input_ptr), hl 
0dc0 79					ld a,c 
0dc1			 
0dc1					; replace char under cursor 
0dc1			 
0dc1			;		ld hl, (input_ptr) 
0dc1			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0dc1			;		ld (hl), a 
0dc1			 
0dc1			;	if DEBUG_INPUT 
0dc1			;		push af 
0dc1			;		ld a, 'i' 
0dc1			;		ld (debug_mark),a 
0dc1			;		pop af 
0dc1			;		CALLMONITOR 
0dc1			;	endif 
0dc1 fe 0e				cp KEY_HOME 
0dc3 20 0e				jr nz, .iske 
0dc5			 
0dc5 3a b6 fb				ld a, (input_at_pos) 
0dc8 32 b4 fb				ld (input_at_cursor),a 
0dcb 3e 00				ld a, 0 
0dcd 32 a7 fb				ld (input_cursor), a 
0dd0 c3 64 0d				jp .is1 
0dd3					 
0dd3 fe 0f		.iske:		cp KEY_END 
0dd5 20 03				jr nz, .isknw 
0dd7 c3 64 0d				jp .is1 
0dda			 
0dda fe 06		.isknw:		cp KEY_NEXTWORD 
0ddc 20 1b				jr nz, .iskpw 
0dde			 
0dde 2a bb fb		.isknwm:	ld hl, (input_ptr) 
0de1 7e					ld a,(hl)	 
0de2 fe 00				cp 0 
0de4 ca 64 0d				jp z, .is1    ; end of string 
0de7 fe 20				cp ' ' 
0de9 ca 64 0d				jp z, .is1    ; end of word 
0dec 23					inc hl 
0ded 22 bb fb				ld (input_ptr), hl 
0df0 3a b4 fb				ld a, (input_at_cursor) 
0df3 3c					inc a 
0df4 32 b4 fb				ld (input_at_cursor), a 
0df7 18 e5				jr .isknwm 
0df9			 
0df9 fe 07		.iskpw:		cp KEY_PREVWORD 
0dfb 20 1b				jr nz, .iskl 
0dfd			.iskpwm:	 
0dfd 2a bb fb				ld hl, (input_ptr) 
0e00 7e					ld a,(hl)	 
0e01 fe 00				cp 0  
0e03 ca 64 0d				jp z, .is1    ; end of string 
0e06 fe 20				cp ' ' 
0e08 ca 64 0d				jp z, .is1    ; end of word 
0e0b 2b					dec hl 
0e0c 22 bb fb				ld (input_ptr), hl 
0e0f 3a b4 fb				ld a, (input_at_cursor) 
0e12 3d					dec a 
0e13 32 b4 fb				ld (input_at_cursor), a 
0e16 18 e5				jr .iskpwm 
0e18			 
0e18			 
0e18 fe 0b		.iskl:		cp KEY_LEFT 
0e1a 20 27				jr nz, .isk1 
0e1c			 
0e1c 3a a7 fb				ld a, (input_cursor) 
0e1f			 
0e1f fe 00				cp 0 
0e21 ca 64 0d				jp z, .is1 		; at start of line to ignore  
0e24			 
0e24 3d					dec  a 		; TODO check underflow 
0e25 32 a7 fb				ld (input_cursor), a 
0e28			 
0e28 2a bb fb				ld hl, (input_ptr) 
0e2b 2b					dec hl 
0e2c 22 bb fb				ld (input_ptr), hl 
0e2f					 
0e2f 3a b4 fb				ld a, (input_at_cursor) 
0e32 3d					dec a 
0e33 32 b4 fb				ld (input_at_cursor), a 
0e36			 
0e36 3e 01				ld a, 1		; show cursor moving 
0e38 32 b1 fb				ld (input_cur_onoff),a 
0e3b 3e 0f				ld a, CUR_BLINK_RATE 
0e3d 32 b2 fb				ld (input_cur_flash), a 
0e40			 
0e40 c3 64 0d				jp .is1 
0e43			 
0e43 fe 0c		.isk1:		cp KEY_RIGHT 
0e45 20 2a				jr nz, .isk2 
0e47			 
0e47 3a ac fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0e4a 5f					ld e,a 
0e4b 3a a7 fb				ld a, (input_cursor) 
0e4e bb					cp e 
0e4f ca 64 0d				jp z, .is1		; at the end of string so dont go right 
0e52			 
0e52 3c					inc  a 		; TODO check overflow 
0e53 32 a7 fb				ld (input_cursor), a 
0e56			 
0e56 3a b4 fb				ld a, (input_at_cursor) 
0e59 3c					inc a 
0e5a 32 b4 fb				ld (input_at_cursor), a 
0e5d			 
0e5d 2a bb fb				ld hl, (input_ptr) 
0e60 23					inc hl 
0e61 22 bb fb				ld (input_ptr), hl 
0e64			 
0e64 3e 01				ld a, 1		; show cursor moving 
0e66 32 b1 fb				ld (input_cur_onoff),a 
0e69 3e 0f				ld a, CUR_BLINK_RATE 
0e6b 32 b2 fb				ld (input_cur_flash), a 
0e6e			 
0e6e c3 64 0d				jp .is1 
0e71			 
0e71 fe 05		.isk2:		cp KEY_UP 
0e73			 
0e73 20 26				jr nz, .isk3 
0e75			 
0e75					; swap last command with the current on 
0e75			 
0e75					; move cursor to start of string 
0e75 2a b9 fb				ld hl, (input_start) 
0e78 22 bb fb				ld (input_ptr), hl 
0e7b			 
0e7b 3a b6 fb				ld a, (input_at_pos) 
0e7e 32 b4 fb				ld (input_at_cursor), a 
0e81			 
0e81 3e 00				ld a, 0 
0e83 32 a7 fb				ld (input_cursor), a 
0e86					 
0e86					; swap input and last command buffers 
0e86			 
0e86 21 ca f2				ld hl, os_cli_cmd 
0e89 11 c9 f3				ld de, os_last_cmd 
0e8c 06 ff				ld b, 255 
0e8e 7e			.swap1:		ld a, (hl) 
0e8f 4f					ld c,a 
0e90 1a					ld a, (de) 
0e91 77					ld (hl), a 
0e92 79					ld a,c 
0e93 12					ld (de),a 
0e94 23					inc hl 
0e95 13					inc de 
0e96 10 f6				djnz .swap1 
0e98			 
0e98			 
0e98			 
0e98			 
0e98			 
0e98 c3 64 0d				jp .is1 
0e9b			 
0e9b fe 08		.isk3:		cp KEY_BS 
0e9d 20 3c				jr nz, .isk4 
0e9f			 
0e9f 3a a7 fb				ld a, (input_cursor) 
0ea2			 
0ea2 fe 00				cp 0 
0ea4 ca 64 0d				jp z, .is1 		; at start of line to ignore  
0ea7			 
0ea7 3d					dec  a 		; TODO check underflow 
0ea8 32 a7 fb				ld (input_cursor), a 
0eab			 
0eab					; hl is source 
0eab					; de needs to be source - 1 
0eab			 
0eab			;		ld a, 0 
0eab			;		dec hl 
0eab			;		ld (hl), a 
0eab			 
0eab 2a bb fb				ld hl, (input_ptr) 
0eae 2b					dec hl 
0eaf 22 bb fb				ld (input_ptr), hl 
0eb2			 
0eb2					; shift all data 
0eb2			 
0eb2 e5					push hl 
0eb3 23					inc hl 
0eb4 d1					pop de 
0eb5 3a ac fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0eb8 4f					ld c,a 
0eb9 06 00				ld b,0 
0ebb ed b0				ldir  
0ebd			 
0ebd			 
0ebd			 
0ebd			 
0ebd 3a b4 fb				ld a, (input_at_cursor) 
0ec0 3d					dec a 
0ec1 32 b4 fb				ld (input_at_cursor), a 
0ec4			 
0ec4			 
0ec4 3e 01				ld a, 1		; show cursor moving 
0ec6 32 b1 fb				ld (input_cur_onoff),a 
0ec9 3e 0f				ld a, CUR_BLINK_RATE 
0ecb 32 b2 fb				ld (input_cur_flash), a 
0ece			 
0ece					; remove char 
0ece 3a b4 fb				ld a, (input_at_cursor) 
0ed1 3c					inc a 
0ed2 11 5c 0f				ld de,.iblank 
0ed5 cd e5 0a				call str_at_display 
0ed8			 
0ed8 c3 64 0d				jp .is1 
0edb			 
0edb fe 0d		.isk4:		cp KEY_CR 
0edd 28 6c				jr z, .endinput 
0edf			 
0edf					; else add the key press to the end 
0edf			 
0edf 4f					ld c, a			; save key pressed 
0ee0			 
0ee0 7e					ld a,(hl)		; get what is currently under char 
0ee1			 
0ee1 fe 00				cp 0			; we are at the end of the string 
0ee3 20 2f				jr nz, .onchar 
0ee5					 
0ee5					; add a char to the end of the string 
0ee5				 
0ee5 71					ld (hl),c 
0ee6 23					inc hl 
0ee7			;		ld a,' ' 
0ee7			;		ld (hl),a 
0ee7			;		inc hl 
0ee7 3e 00				ld a,0 
0ee9 77					ld (hl),a 
0eea 2b					dec hl 
0eeb			 
0eeb 3a a7 fb				ld a, (input_cursor) 
0eee 3c					inc a				; TODO check max string length and scroll  
0eef 32 a7 fb				ld (input_cursor), a		; inc cursor pos 
0ef2							 
0ef2 3a b4 fb				ld a, (input_at_cursor) 
0ef5 3c					inc a 
0ef6 32 b4 fb				ld (input_at_cursor), a 
0ef9			 
0ef9 2a bb fb				ld hl, (input_ptr) 
0efc 23					inc hl 
0efd 22 bb fb				ld (input_ptr), hl 
0f00			 
0f00 2a bb fb				ld hl, (input_ptr) 
0f03 23					inc hl 
0f04 22 bb fb				ld (input_ptr), hl 
0f07			;	if DEBUG_INPUT 
0f07			;		push af 
0f07			;		ld a, '+' 
0f07			;		ld (debug_mark),a 
0f07			;		pop af 
0f07			;		CALLMONITOR 
0f07			;	endif 
0f07 3e 01				ld a, 1		; show cursor moving 
0f09 32 b1 fb				ld (input_cur_onoff),a 
0f0c 3e 0f				ld a, CUR_BLINK_RATE 
0f0e 32 b2 fb				ld (input_cur_flash), a 
0f11 c3 64 0d				jp .is1 
0f14					 
0f14			 
0f14			 
0f14					; if on a char then insert 
0f14			.onchar: 
0f14			 
0f14					; TODO over flow check: make sure insert does not blow out buffer 
0f14			 
0f14					; need to do some maths to use lddr 
0f14			 
0f14 e5					push hl   ; save char pos 
0f15 c5					push bc 
0f16			 
0f16 2a b9 fb				ld hl, (input_start) 
0f19 3a ac fb				ld a, (input_len) 
0f1c cd 06 0d				call addatohl  		; end of string 
0f1f 23					inc hl 
0f20 23					inc hl		; past zero term 
0f21 e5					push hl 
0f22 23					inc hl 
0f23 e5					push hl  
0f24			 
0f24								; start and end of lddr set, now how much to move? 
0f24			 
0f24							 
0f24 3a a7 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0f27 47					ld b,a 
0f28 3a ac fb				ld a,(input_len) 
0f2b 5f					ld e,a 
0f2c 90					sub b 
0f2d 3c					inc a		;?? 
0f2e 3c					inc a		;?? 
0f2f 3c					inc a		;?? 
0f30			 
0f30 06 00				ld b,0 
0f32 4f					ld c,a 
0f33			 
0f33				if DEBUG_INPUT 
0f33					push af 
0f33					ld a, 'i' 
0f33					ld (debug_mark),a 
0f33					pop af 
0f33			;		CALLMONITOR 
0f33				endif 
0f33 d1					pop de 
0f34 e1					pop hl 
0f35				if DEBUG_INPUT 
0f35					push af 
0f35					ld a, 'I' 
0f35					ld (debug_mark),a 
0f35					pop af 
0f35			;		CALLMONITOR 
0f35				endif 
0f35 ed b8				lddr 
0f37				 
0f37			 
0f37			 
0f37					; TODO have a key for insert/overwrite mode???? 
0f37 c1					pop bc 
0f38 e1					pop hl 
0f39 71					ld (hl), c		; otherwise overwrite current char 
0f3a					 
0f3a			 
0f3a			 
0f3a			 
0f3a 3a a7 fb				ld a, (input_cursor) 
0f3d 3c					inc  a 		; TODO check overflow 
0f3e 32 a7 fb				ld (input_cursor), a 
0f41			 
0f41 3a b4 fb				ld a, (input_at_cursor) 
0f44 3c					inc a 
0f45 32 b4 fb				ld (input_at_cursor), a 
0f48			 
0f48 c3 64 0d				jp .is1 
0f4b			 
0f4b			.endinput:	; TODO look for end of string 
0f4b			 
0f4b					; add trailing space for end of token 
0f4b			 
0f4b 2a b9 fb				ld hl, (input_start) 
0f4e 3a ac fb				ld a,(input_len) 
0f51 cd 06 0d				call addatohl 
0f54 3e 20				ld a, ' ' 
0f56 77					ld (hl),a 
0f57					; TODO eof of parse marker 
0f57			 
0f57 23					inc hl 
0f58 3e 00				ld a, 0 
0f5a 77					ld (hl),a 
0f5b			 
0f5b			 
0f5b c9					ret 
0f5c			 
0f5c .. 00		.iblank: db " ",0 
0f5e			 
0f5e			 
0f5e 32 b6 fb		input_str_prev:	ld (input_at_pos), a 
0f61 22 b9 fb				ld (input_start), hl 
0f64 3e 01				ld a,1			; add cursor 
0f66 77					ld (hl),a 
0f67 23					inc hl 
0f68 3e 00				ld a,0 
0f6a 77					ld (hl),a 
0f6b 22 bb fb				ld (input_ptr), hl 
0f6e 7a					ld a,d 
0f6f 32 b8 fb				ld (input_size), a 
0f72 3e 00				ld a,0 
0f74 32 a7 fb				ld (input_cursor),a 
0f77			.instr1:	 
0f77			 
0f77					; TODO do block cursor 
0f77					; TODO switch cursor depending on the modifer key 
0f77			 
0f77					; update cursor shape change on key hold 
0f77			 
0f77 2a bb fb				ld hl, (input_ptr) 
0f7a 2b					dec hl 
0f7b 3a 56 fa				ld a,(cursor_shape) 
0f7e 77					ld (hl), a 
0f7f			 
0f7f					; display entered text 
0f7f 3a b6 fb				ld a,(input_at_pos) 
0f82 cd 78 65		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f85 ed 5b b9 fb	            	LD   de, (input_start) 
0f89 cd 80 65		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f8c			 
0f8c cd 5a 66				call cin 
0f8f fe 00				cp 0 
0f91 28 e4				jr z, .instr1 
0f93			 
0f93					; proecess keyboard controls first 
0f93			 
0f93 2a bb fb				ld hl,(input_ptr) 
0f96			 
0f96 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f98 28 5a				jr z, .instrcr 
0f9a			 
0f9a fe 08				cp KEY_BS 	; back space 
0f9c 20 0f				jr nz, .instr2 
0f9e					; process back space 
0f9e			 
0f9e					; TODO stop back space if at start of string 
0f9e 2b					dec hl 
0f9f 2b					dec hl ; to over write cursor 
0fa0 3a 56 fa				ld a,(cursor_shape) 
0fa3					;ld a,0 
0fa3 77					ld (hl),a 
0fa4 23					inc hl 
0fa5 3e 20				ld a," " 
0fa7 77					ld (hl),a 
0fa8 22 bb fb				ld (input_ptr),hl 
0fab					 
0fab			 
0fab 18 ca				jr .instr1 
0fad			 
0fad fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0faf 20 06				jr nz, .instr3 
0fb1 2b					dec hl 
0fb2 22 bb fb				ld (input_ptr),hl 
0fb5 18 c0				jr .instr1 
0fb7				 
0fb7 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0fb9 20 06				jr nz, .instr4 
0fbb 23					inc hl 
0fbc 22 bb fb				ld (input_ptr),hl 
0fbf 18 b6				jr .instr1 
0fc1			 
0fc1 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0fc3 20 06				jr nz, .instr5 
0fc5 2b					dec hl 
0fc6 22 bb fb				ld (input_ptr),hl 
0fc9 18 ac				jr .instr1 
0fcb			 
0fcb fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0fcd 20 06				jr nz, .instr6 
0fcf 2b					dec hl 
0fd0 22 bb fb				ld (input_ptr),hl 
0fd3 18 a2				jr .instr1 
0fd5 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0fd7 20 0b				jr nz, .instrnew 
0fd9			 
0fd9 21 a3 ef			ld hl, scratch 
0fdc 11 c9 f3			ld de, os_last_cmd 
0fdf cd fd 0f			call strcpy 
0fe2 18 93				jr .instr1 
0fe4			 
0fe4			 
0fe4			.instrnew:	; no special key pressed to see if we have room to store it 
0fe4			 
0fe4					; TODO do string size test 
0fe4			 
0fe4 2b					dec hl ; to over write cursor 
0fe5 77					ld (hl),a 
0fe6 23					inc hl 
0fe7 3a 56 fa				ld a,(cursor_shape) 
0fea 77					ld (hl),a 
0feb 23					inc hl 
0fec 3e 00				ld a,0 
0fee 77					ld (hl),a 
0fef			 
0fef 22 bb fb				ld (input_ptr),hl 
0ff2					 
0ff2 18 83				jr .instr1 
0ff4 2b			.instrcr:	dec hl		; remove cursor 
0ff5 3e 20				ld a,' '	; TODO add a trailing space for safety 
0ff7 77					ld (hl),a 
0ff8 23					inc hl 
0ff9 3e 00				ld a,0 
0ffb 77					ld (hl),a 
0ffc			 
0ffc			 
0ffc					; if at end of line scroll up    
0ffc					; TODO detecting only end of line 4 for scroll up  
0ffc			 
0ffc					;ld   
0ffc			 
0ffc c9					ret 
0ffd			 
0ffd			 
0ffd			; strcpy hl = dest, de source 
0ffd			 
0ffd 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ffe b7			            OR   A              ;Null terminator? 
0fff c8			            RET  Z              ;Yes, so finished 
1000 1a					ld a,(de) 
1001 77					ld (hl),a 
1002 13			            INC  DE             ;Point to next character 
1003 23					inc hl 
1004 18 f7		            JR   strcpy       ;Repeat 
1006 c9					ret 
1007			 
1007			 
1007			; TODO string_at  
1007			; pass string which starts with lcd offset address and then null term string 
1007			 
1007			; TODO string to dec 
1007			; TODO string to hex 
1007			; TODO byte to string hex 
1007			; TODO byte to string dec 
1007			 
1007			 
1007			 
1007			; from z80uartmonitor 
1007			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1007			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
1007			; pass hl for where to put the text 
1007			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1007 c5			hexout:	PUSH BC 
1008 f5					PUSH AF 
1009 47					LD B, A 
100a					; Upper nybble 
100a cb 3f				SRL A 
100c cb 3f				SRL A 
100e cb 3f				SRL A 
1010 cb 3f				SRL A 
1012 cd 22 10				CALL tohex 
1015 77					ld (hl),a 
1016 23					inc hl	 
1017					 
1017					; Lower nybble 
1017 78					LD A, B 
1018 e6 0f				AND 0FH 
101a cd 22 10				CALL tohex 
101d 77					ld (hl),a 
101e 23					inc hl	 
101f					 
101f f1					POP AF 
1020 c1					POP BC 
1021 c9					RET 
1022					 
1022			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1022			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1022			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1022			tohex: 
1022 e5					PUSH HL 
1023 d5					PUSH DE 
1024 16 00				LD D, 0 
1026 5f					LD E, A 
1027 21 2f 10				LD HL, .DATA 
102a 19					ADD HL, DE 
102b 7e					LD A, (HL) 
102c d1					POP DE 
102d e1					POP HL 
102e c9					RET 
102f			 
102f			.DATA: 
102f 30					DEFB	30h	; 0 
1030 31					DEFB	31h	; 1 
1031 32					DEFB	32h	; 2 
1032 33					DEFB	33h	; 3 
1033 34					DEFB	34h	; 4 
1034 35					DEFB	35h	; 5 
1035 36					DEFB	36h	; 6 
1036 37					DEFB	37h	; 7 
1037 38					DEFB	38h	; 8 
1038 39					DEFB	39h	; 9 
1039 41					DEFB	41h	; A 
103a 42					DEFB	42h	; B 
103b 43					DEFB	43h	; C 
103c 44					DEFB	44h	; D 
103d 45					DEFB	45h	; E 
103e 46					DEFB	46h	; F 
103f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
103f			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
103f			;;    subtract $30, if result > 9 then subtract $7 more 
103f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
103f			atohex: 
103f d6 30				SUB $30 
1041 fe 0a				CP 10 
1043 f8					RET M		; If result negative it was 0-9 so we're done 
1044 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1046 c9					RET		 
1047			 
1047			 
1047			 
1047			 
1047			; Get 2 ASCII characters as hex byte from pointer in hl 
1047			 
1047			BYTERD: 
1047 16 00			LD	D,00h		;Set up 
1049 cd 51 10			CALL	HEXCON		;Get byte and convert to hex 
104c 87				ADD	A,A		;First nibble so 
104d 87				ADD	A,A		;multiply by 16 
104e 87				ADD	A,A		; 
104f 87				ADD	A,A		; 
1050 57				LD	D,A		;Save hi nibble in D 
1051			HEXCON: 
1051 7e				ld a, (hl)		;Get next chr 
1052 23				inc hl 
1053 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1055 fe 0a			CP	00Ah		;Is it 0-9 ? 
1057 38 02			JR	C,NALPHA	;If so miss next bit 
1059 d6 07			SUB	007h		;Else convert alpha 
105b			NALPHA: 
105b b2				OR	D		;Add hi nibble back 
105c c9				RET			; 
105d			 
105d			 
105d			; 
105d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
105d			; Since the routines get_byte and therefore get_nibble are called, only valid 
105d			; characters (0-9a-f) are accepted. 
105d			; 
105d			;get_word        push    af 
105d			;                call    get_byte        ; Get the upper byte 
105d			;                ld      h, a 
105d			;                call    get_byte        ; Get the lower byte 
105d			;                ld      l, a 
105d			;                pop     af 
105d			;                ret 
105d			; 
105d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
105d			; the routine get_nibble is used only valid characters are accepted - the  
105d			; input routine only accepts characters 0-9a-f. 
105d			; 
105d c5			get_byte:        push    bc              ; Save contents of B (and C) 
105e 7e					ld a,(hl) 
105f 23					inc hl 
1060 cd 85 10		                call    nibble2val      ; Get upper nibble 
1063 cb 07		                rlc     a 
1065 cb 07		                rlc     a 
1067 cb 07		                rlc     a 
1069 cb 07		                rlc     a 
106b 47			                ld      b, a            ; Save upper four bits 
106c 7e					ld a,(hl) 
106d cd 85 10		                call    nibble2val      ; Get lower nibble 
1070 b0			                or      b               ; Combine both nibbles 
1071 c1			                pop     bc              ; Restore B (and C) 
1072 c9			                ret 
1073			; 
1073			; Get a hexadecimal digit from the serial line. This routine blocks until 
1073			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1073			; to the serial line interface. The lower 4 bits of A contain the value of  
1073			; that particular digit. 
1073			; 
1073			;get_nibble      ld a,(hl)           ; Read a character 
1073			;                call    to_upper        ; Convert to upper case 
1073			;                call    is_hex          ; Was it a hex digit? 
1073			;                jr      nc, get_nibble  ; No, get another character 
1073			 ;               call    nibble2val      ; Convert nibble to value 
1073			 ;               call    print_nibble 
1073			 ;               ret 
1073			; 
1073			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1073			; A valid hexadecimal digit is denoted by a set C flag. 
1073			; 
1073			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1073			;                ret     nc              ; Yes 
1073			;                cp      '0'             ; Less than '0'? 
1073			;                jr      nc, is_hex_1    ; No, continue 
1073			;                ccf                     ; Complement carry (i.e. clear it) 
1073			;                ret 
1073			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1073			;                ret     c               ; Yes 
1073			;                cp      'A'             ; Less than 'A'? 
1073			;                jr      nc, is_hex_2    ; No, continue 
1073			;                ccf                     ; Yes - clear carry and return 
1073			;                ret 
1073			;is_hex_2        scf                     ; Set carry 
1073			;                ret 
1073			; 
1073			; Convert a single character contained in A to upper case: 
1073			; 
1073 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1075 d8			                ret     c 
1076 fe 7b		                cp      'z' + 1         ; > 'z'? 
1078 d0			                ret     nc              ; Nothing to do, either 
1079 e6 5f		                and     $5f             ; Convert to upper case 
107b c9			                ret 
107c			 
107c			 
107c			to_lower: 
107c			 
107c			   ; if char is in [A-Z] make it lower case 
107c			 
107c			   ; enter : a = char 
107c			   ; exit  : a = lower case char 
107c			   ; uses  : af 
107c			 
107c fe 41		   cp 'A' 
107e d8			   ret c 
107f			    
107f fe 5b		   cp 'Z'+1 
1081 d0			   ret nc 
1082			    
1082 f6 20		   or $20 
1084 c9			   ret 
1085			 
1085			; 
1085			; Expects a hexadecimal digit (upper case!) in A and returns the 
1085			; corresponding value in A. 
1085			; 
1085 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1087 38 02		                jr      c, nibble2val_1 ; Yes 
1089 d6 07		                sub     7               ; Adjust for A-F 
108b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
108d e6 0f		                and     $f              ; Only return lower 4 bits 
108f c9			                ret 
1090			; 
1090			; Print_nibble prints a single hex nibble which is contained in the lower  
1090			; four bits of A: 
1090			; 
1090			;print_nibble    push    af              ; We won't destroy the contents of A 
1090			;                and     $f              ; Just in case... 
1090			;                add     a, '0'             ; If we have a digit we are done here. 
1090			;                cp      '9' + 1         ; Is the result > 9? 
1090			;                jr      c, print_nibble_1 
1090			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1090			;print_nibble_1  call    putc            ; Print the nibble and 
1090			;                pop     af              ; restore the original value of A 
1090			;                ret 
1090			;; 
1090			;; Send a CR/LF pair: 
1090			; 
1090			;crlf            push    af 
1090			;                ld      a, cr 
1090			;                call    putc 
1090			;                ld      a, lf 
1090			;                call    putc 
1090			;                pop     af 
1090			;                ret 
1090			; 
1090			; Print_word prints the four hex digits of a word to the serial line. The  
1090			; word is expected to be in HL. 
1090			; 
1090			;print_word      push    hl 
1090			;                push    af 
1090			;                ld      a, h 
1090			;                call    print_byte 
1090			;                ld      a, l 
1090			;                call    print_byte 
1090			;                pop     af 
1090			;                pop     hl 
1090			;                ret 
1090			; 
1090			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1090			; The byte to be printed is expected to be in A. 
1090			; 
1090			;print_byte      push    af              ; Save the contents of the registers 
1090			;                push    bc 
1090			;                ld      b, a 
1090			;                rrca 
1090			;                rrca 
1090			;                rrca 
1090			;                rrca 
1090			;                call    print_nibble    ; Print high nibble 
1090			;                ld      a, b 
1090			;                call    print_nibble    ; Print low nibble 
1090			;                pop     bc              ; Restore original register contents 
1090			;                pop     af 
1090			;                ret 
1090			 
1090			 
1090			 
1090			 
1090			 
1090			fourehexhl:  
1090 7e				ld a,(hl) 
1091 cd 3f 10			call atohex 
1094 cb 3f				SRL A 
1096 cb 3f				SRL A 
1098 cb 3f				SRL A 
109a cb 3f				SRL A 
109c 47				ld b, a 
109d 23				inc hl 
109e 7e				ld a,(hl) 
109f 23				inc hl 
10a0 cd 3f 10			call atohex 
10a3 80				add b 
10a4 57				ld d,a 
10a5 7e				ld a,(hl) 
10a6 cd 3f 10			call atohex 
10a9 cb 3f				SRL A 
10ab cb 3f				SRL A 
10ad cb 3f				SRL A 
10af cb 3f				SRL A 
10b1 47				ld b, a 
10b2 23				inc hl 
10b3 7e				ld a,(hl) 
10b4 23				inc hl 
10b5 cd 3f 10			call atohex 
10b8 80				add b 
10b9 5f				ld e, a 
10ba d5				push de 
10bb e1				pop hl 
10bc c9				ret 
10bd			 
10bd			; pass hl. returns z set if the byte at hl is a digit 
10bd			;isdigithl:  
10bd			;	push bc 
10bd			;	ld a,(hl) 
10bd			;	cp ':' 
10bd			;	jr nc, .isdf 		; > 
10bd			;	cp '0' 
10bd			;	jr c, .isdf		; < 
10bd			; 
10bd			;	; TODO find a better way to set z 
10bd			; 
10bd			;	ld b,a 
10bd			;	cp b 
10bd			;	pop bc 
10bd			;	ret 
10bd			; 
10bd			;.isdf:	; not digit so clear z 
10bd			; 
10bd			;	; TODO find a better way to unset z 
10bd			; 
10bd			;	ld b,a 
10bd			;	inc b 
10bd			;	cp b 
10bd			; 
10bd			;	pop bc 
10bd			;	ret 
10bd				 
10bd				 
10bd			 
10bd			 
10bd			; pass hl as the four byte address to load 
10bd			 
10bd			get_word_hl:  
10bd e5				push hl 
10be cd 5d 10			call get_byte 
10c1				 
10c1 47				ld b, a 
10c2			 
10c2 e1				pop hl 
10c3 23				inc hl 
10c4 23				inc hl 
10c5			 
10c5			; TODO not able to handle a-f  
10c5 7e				ld a,(hl) 
10c6			;	;cp ':' 
10c6			;	cp 'g' 
10c6			;	jr nc, .single_byte_hl 		; > 
10c6			;	cp 'G' 
10c6			;	jr nc, .single_byte_hl 		; > 
10c6			;	cp '0' 
10c6			;	jr c, .single_byte_hl		; < 
10c6			 
10c6				;call isdigithl 
10c6 fe 00			cp 0 
10c8 28 06			jr z, .single_byte_hl 
10ca			 
10ca			.getwhln:   ; hex word so get next byte 
10ca			 
10ca cd 5d 10			call get_byte 
10cd 6f				ld l, a 
10ce 60				ld h,b 
10cf c9				ret 
10d0 68			.single_byte_hl:   ld l,b 
10d1 26 00				ld h,0 
10d3 c9					ret 
10d4			 
10d4			 
10d4			 
10d4			 
10d4 21 0e 19			ld hl,asc+1 
10d7			;	ld a, (hl) 
10d7			;	call nibble2val 
10d7 cd 5d 10			call get_byte 
10da			 
10da			;	call fourehexhl 
10da 32 d7 ef			ld (scratch+52),a 
10dd				 
10dd 21 d5 ef			ld hl,scratch+50 
10e0 22 c6 f2			ld (os_cur_ptr),hl 
10e3			 
10e3 c9				ret 
10e4			 
10e4			 
10e4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10e4			 
10e4			; Decimal Unsigned Version 
10e4			 
10e4			;Number in a to decimal ASCII 
10e4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10e4			;Example: display a=56 as "056" 
10e4			;input: a = number 
10e4			;Output: a=0,value of a in the screen 
10e4			;destroys af,bc (don't know about hl and de) 
10e4			DispAToASCII: 
10e4 0e 9c			ld	c,-100 
10e6 cd f0 10			call	.Na1 
10e9 0e f6			ld	c,-10 
10eb cd f0 10			call	.Na1 
10ee 0e ff			ld	c,-1 
10f0 06 2f		.Na1:	ld	b,'0'-1 
10f2 04			.Na2:	inc	b 
10f3 81				add	a,c 
10f4 38 fc			jr	c,.Na2 
10f6 91				sub	c		;works as add 100/10/1 
10f7 f5				push af		;safer than ld c,a 
10f8 78				ld	a,b		;char is in b 
10f9			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10f9 f1				pop af		;safer than ld a,c 
10fa c9				ret 
10fb			 
10fb			; Decimal Signed Version 
10fb			 
10fb			; DispA 
10fb			; -------------------------------------------------------------- 
10fb			; Converts a signed integer value to a zero-terminated ASCII 
10fb			; string representative of that value (using radix 10). 
10fb			; -------------------------------------------------------------- 
10fb			; INPUTS: 
10fb			;     HL     Value to convert (two's complement integer). 
10fb			;     DE     Base address of string destination. (pointer). 
10fb			; -------------------------------------------------------------- 
10fb			; OUTPUTS: 
10fb			;     None 
10fb			; -------------------------------------------------------------- 
10fb			; REGISTERS/MEMORY DESTROYED 
10fb			; AF HL 
10fb			; -------------------------------------------------------------- 
10fb			 
10fb			;DispHLToASCII: 
10fb			;   push    de 
10fb			;   push    bc 
10fb			; 
10fb			;; Detect sign of HL. 
10fb			;    bit    7, h 
10fb			;    jr     z, ._DoConvert 
10fb			; 
10fb			;; HL is negative. Output '-' to string and negate HL. 
10fb			;    ld     a, '-' 
10fb			;    ld     (de), a 
10fb			;    inc    de 
10fb			; 
10fb			;; Negate HL (using two's complement) 
10fb			;    xor    a 
10fb			;    sub    l 
10fb			;    ld     l, a 
10fb			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10fb			;    sbc    a, h 
10fb			;    ld     h, a 
10fb			; 
10fb			;; Convert HL to digit characters 
10fb			;._DoConvert: 
10fb			;    ld     b, 0     ; B will count character length of number 
10fb			;-   ld     a, 10 
10fb			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10fb			;    push   af 
10fb			;    inc    b 
10fb			;    ld     a, h 
10fb			;    or     l 
10fb			;    jr     nz, - 
10fb			; 
10fb			;; Retrieve digits from stack 
10fb			;-   pop    af 
10fb			;    or     $30 
10fb			;    ld     (de), a 
10fb			;    inc    de 
10fb			;    djnz   - 
10fb			; 
10fb			;; Terminate string with NULL 
10fb			;    xor    a 
10fb			;    ld     (de), a 
10fb			; 
10fb			;    pop    bc 
10fb			;    pop    de 
10fb			;    ret 
10fb			 
10fb			;Comments 
10fb			; 
10fb			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10fb			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10fb			;    Note that the output string will not be fixed-width. 
10fb			; 
10fb			;Example Usage 
10fb			; 
10fb			;    ld    hl, -1004 
10fb			;    ld    de, OP1 
10fb			;    call  DispA 
10fb			;    ld    hl, OP1 
10fb			;    syscall  PutS 
10fb			 
10fb			 
10fb			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10fb			 
10fb			 
10fb			;Converts an ASCII string to an unsigned 16-bit integer 
10fb			;Quits when it reaches a non-decimal digit 
10fb			 
10fb			string_to_uint16: 
10fb			atoui_16: 
10fb			;Input: 
10fb			;     DE points to the string 
10fb			;Outputs: 
10fb			;     HL is the result 
10fb			;     A is the 8-bit value of the number 
10fb			;     DE points to the byte after the number 
10fb			;Destroys: 
10fb			;     BC 
10fb			;       if the string is non-empty, BC is HL/10 
10fb			;Size:  24 bytes 
10fb			;Speed: 42+d(104+{0,9}) 
10fb			;       d is the number of digits in the number 
10fb			;       max is 640 cycles for a 5 digit number 
10fb			;Assuming no leading zeros: 
10fb			;1 digit:  146cc 
10fb			;2 digit:  250cc 
10fb			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10fb			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10fb			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10fb			;avg: 544.81158447265625cc (544+13297/16384) 
10fb			;=============================================================== 
10fb 21 00 00		  ld hl,0 
10fe			.u16a: 
10fe 1a			  ld a,(de) 
10ff d6 30		  sub 30h 
1101 fe 0a		  cp 10 
1103 d0			  ret nc 
1104 13			  inc de 
1105 44			  ld b,h 
1106 4d			  ld c,l 
1107 29			  add hl,hl 
1108 29			  add hl,hl 
1109 09			  add hl,bc 
110a 29			  add hl,hl 
110b 85			  add a,l 
110c 6f			  ld l,a 
110d 30 ef		  jr nc,.u16a 
110f 24			  inc h 
1110 c3 fe 10		  jp .u16a 
1113			 
1113			 
1113			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1113			 
1113			;written by Zeda 
1113			;Converts a 16-bit unsigned integer to an ASCII string. 
1113			 
1113			uitoa_16: 
1113			;Input: 
1113			;   DE is the number to convert 
1113			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1113			;Output: 
1113			;   HL points to the null-terminated ASCII string 
1113			;      NOTE: This isn't necessarily the same as the input HL. 
1113 d5			  push de 
1114 c5			  push bc 
1115 f5			  push af 
1116 eb			  ex de,hl 
1117			 
1117 01 f0 d8		  ld bc,-10000 
111a 3e 2f		  ld a,'0'-1 
111c 3c			  inc a 
111d 09			  add hl,bc  
111e 38 fc		   jr c,$-2 
1120 12			  ld (de),a 
1121 13			  inc de 
1122			 
1122 01 e8 03		  ld bc,1000 
1125 3e 3a		  ld a,'9'+1 
1127 3d			  dec a  
1128 09			  add hl,bc  
1129 30 fc		   jr nc,$-2 
112b 12			  ld (de),a 
112c 13			  inc de 
112d			 
112d 01 9c ff		  ld bc,-100 
1130 3e 2f		  ld a,'0'-1 
1132 3c			  inc a  
1133 09			  add hl,bc  
1134 38 fc		   jr c,$-2 
1136 12			  ld (de),a 
1137 13			  inc de 
1138			 
1138 7d			  ld a,l 
1139 26 3a		  ld h,'9'+1 
113b 25			  dec h  
113c c6 0a		  add a,10  
113e 30 fb		   jr nc,$-3 
1140 c6 30		  add a,'0' 
1142 eb			  ex de,hl 
1143 72			  ld (hl),d 
1144 23			  inc hl 
1145 77			  ld (hl),a 
1146 23			  inc hl 
1147 36 00		  ld (hl),0 
1149			 
1149			;Now strip the leading zeros 
1149 0e fa		  ld c,-6 
114b 09			  add hl,bc 
114c 3e 30		  ld a,'0' 
114e 23			  inc hl  
114f be			  cp (hl)  
1150 28 fc		  jr z,$-2 
1152			 
1152			;Make sure that the string is non-empty! 
1152 7e			  ld a,(hl) 
1153 b7			  or a 
1154 20 01		  jr nz,.atoub 
1156 2b			  dec hl 
1157			.atoub: 
1157			 
1157 f1			  pop af 
1158 c1			  pop bc 
1159 d1			  pop de 
115a c9			  ret 
115b			 
115b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
115b			 
115b			toUpper: 
115b			;A is the char. 
115b			;If A is a lowercase letter, this sets it to the matching uppercase 
115b			;18cc or 30cc or 41cc 
115b			;avg: 26.75cc 
115b fe 61		  cp 'a' 
115d d8			  ret c 
115e fe 7b		  cp 'z'+1 
1160 d0			  ret nc 
1161 d6 20		  sub 'a'-'A' 
1163 c9			  ret 
1164			 
1164			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1164			 
1164			; String Length 
1164			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1164			 
1164			; Get the length of the null-terminated string starting at $8000 hl 
1164			;    LD     HL, $8000 
1164			 
1164			strlenz: 
1164			 
1164 af			    XOR    A               ; Zero is the value we are looking for. 
1165 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1166 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1167			                           ; 65, 536 bytes (the entire addressable memory space). 
1167 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1169			 
1169			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1169 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
116a 6f			    LD     L, A             ; number of bytes 
116b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
116d 2b			    DEC    HL              ; Compensate for null. 
116e c9				ret 
116f			 
116f			; Get the length of the A terminated string starting at $8000 hl 
116f			;    LD     HL, $8000 
116f			 
116f			strlent: 
116f			 
116f			                  ; A is the value we are looking for. 
116f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1171 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1173			                           ; 65, 536 bytes (the entire addressable memory space). 
1173 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1175			 
1175			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1175 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1177 2e 00		    LD     L, 0             ; number of bytes 
1179 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
117b 2b			    DEC    HL              ; Compensate for null. 
117c c9				ret 
117d			 
117d			 
117d			;Comparing Strings 
117d			 
117d			;IN    HL     Address of string1. 
117d			;      DE     Address of string2. 
117d			 
117d			; doc given but wrong??? 
117d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
117d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
117d			; tested 
117d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
117d			 
117d			strcmp_old: 
117d e5			    PUSH   HL 
117e d5			    PUSH   DE 
117f			 
117f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1180 be			    CP     (HL)            ; (want to minimize work). 
1181 38 01		    JR     C, Str1IsBigger 
1183 7e			    LD     A, (HL) 
1184			 
1184			Str1IsBigger: 
1184 4f			    LD     C, A             ; Put length in BC 
1185 06 00		    LD     B, 0 
1187 13			    INC    DE              ; Increment pointers to meat of string. 
1188 23			    INC    HL 
1189			 
1189			CmpLoop: 
1189 1a			    LD     A, (DE)          ; Compare bytes. 
118a ed a1		    CPI 
118c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
118e 13			    INC    DE              ; Update pointer. 
118f ea 89 11		    JP     PE, CmpLoop 
1192			 
1192 d1			    POP    DE 
1193 e1			    POP    HL 
1194 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1195 be			    CP     (HL) 
1196 c9			    RET 
1197			 
1197			NoMatch: 
1197 2b			    DEC    HL 
1198 be			    CP     (HL)            ; Compare again to affect carry. 
1199 d1			    POP    DE 
119a e1			    POP    HL 
119b c9			    RET 
119c			 
119c			;; test strmp 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str2 
119c			;call strcmp 
119c			;jr z, .z1 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "NZ1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.z1: 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "ZZ1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str1 
119c			;call strcmp 
119c			;jr z, .z2 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "NZ2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.z2: 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "ZZ2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str2 
119c			;call strcmp 
119c			;jr c, .c1 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "Nc1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.c1: 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "cc1" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			; 
119c			;ld de, .str1 
119c			;ld hl, .str1 
119c			;call strcmp 
119c			;jr c, .c2 
119c			;;this 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "Nc2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;.c2: 
119c			; 
119c			;	if DEBUG_FORTH_WORDS 
119c			;		DMARK "cc2" 
119c			;		CALLMONITOR 
119c			;	endif 
119c			;	NEXTW 
119c			;.str1:   db "string1",0 
119c			;.str2:   db "string2",0 
119c			 
119c			; only care about direct match or not 
119c			; hl and de strings 
119c			; zero set if the same 
119c			 
119c			strcmp: 
119c 1a				ld a, (de) 
119d be				cp (hl) 
119e 28 02			jr z, .ssame 
11a0 b7				or a 
11a1 c9				ret 
11a2			 
11a2			.ssame:  
11a2 fe 00			cp 0 
11a4 c8				ret z 
11a5			 
11a5 23				inc hl 
11a6 13				inc de 
11a7 18 f3			jr strcmp 
11a9				 
11a9				 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			; eof 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			 
11a9			 
# End of file firmware_strings.asm
11a9			include "firmware_memory.asm"   ; malloc and free  
11a9			 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			.mallocsize: db "Wants malloc >256",0 
11a9			.mallocasize: db "MALLOC gives >256",0 
11a9			.malloczero: db "MALLOC gives zero",0 
11a9			 
11a9			malloc_guard_zerolen: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9				ld de, 0 
11a9			        call cmp16 
11a9				jr nz, .lowalloz 
11a9			 
11a9				push hl 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .malloczero 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9				ld a, 0 
11a9				ld (os_view_disable), a 
11a9			 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				 
11a9			 
11a9				CALLMONITOR 
11a9			.lowalloz: 
11a9			 
11a9			 
11a9				pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			 
11a9			malloc_guard_entry: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9			 	or a      ;clear carry flag 
11a9				push hl 
11a9				ld de, 255 
11a9				sbc hl, de 
11a9				jr c, .lowalloc 
11a9			 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .mallocsize 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9				ld a, 0 
11a9				ld (os_view_disable), a 
11a9			 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				 
11a9			 
11a9				CALLMONITOR 
11a9				jr .lowdone 
11a9			.lowalloc: 
11a9			 
11a9			 
11a9				pop hl 
11a9			.lowdone:	pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			 
11a9			malloc_guard_exit: 
11a9				push hl 
11a9				push de 
11a9				push af 
11a9			 
11a9			 	or a      ;clear carry flag 
11a9				push hl 
11a9				ld de, 255 
11a9				sbc hl, de 
11a9				jr c, .lowallocx 
11a9			 
11a9				push de 
11a9					ld hl, display_fb0 
11a9					ld (display_fb_active), hl 
11a9				call clear_display 
11a9				ld a, 0 
11a9				ld de, .mallocasize 
11a9				call str_at_display 
11a9				call update_display 
11a9				call delay1s 
11a9				call delay1s 
11a9				ld a, 0 
11a9				ld (os_view_disable), a 
11a9				pop de 
11a9				pop hl 
11a9			 
11a9				CALLMONITOR 
11a9				jr .lowdonex 
11a9			.lowallocx: 
11a9			 
11a9				pop hl 
11a9			.lowdonex:	pop af 
11a9				pop de 
11a9				pop hl 
11a9			ret 
11a9			endif 
11a9			 
11a9			if MALLOC_2 
11a9			; Z80 Malloc and Free Functions 
11a9			 
11a9			; Malloc Function: 
11a9			; Input: 
11a9			;   HL: Size of block to allocate 
11a9			; Output: 
11a9			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11a9			 
11a9			malloc: 
11a9				 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			call malloc_guard_entry 
11a9			endif 
11a9			 
11a9			 
11a9			 
11a9			 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "mal" 
11a9						CALLMONITOR 
11a9					endif 
11a9			    push af            ; Save AF register 
11a9			    ld a, l            ; Load low byte of size into A 
11a9			    or h               ; Check if size is zero 
11a9			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11a9			 
11a9			    ; Allocate memory 
11a9			    ld hl, (heap_start) ; Load start of heap into HL 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma1" 
11a9						CALLMONITOR 
11a9					endif 
11a9			    call malloc_internal ; Call internal malloc function 
11a9			    pop af             ; Restore AF register 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret                ; Return 
11a9			 
11a9			; Free Function: 
11a9			; Input: 
11a9			;   HL: Pointer to memory block to free 
11a9			; Output: 
11a9			;   None 
11a9			 
11a9			free: 
11a9			    push af            ; Save AF register 
11a9			    ld a, l            ; Load low byte of pointer into A 
11a9			    or h               ; Check if pointer is NULL 
11a9			    jp z, free_exit    ; If pointer is NULL, exit 
11a9			 
11a9			    ; Free memory 
11a9			    ld hl, (heap_start) ; Load start of heap into HL 
11a9			    call free_internal  ; Call internal free function 
11a9			    pop af             ; Restore AF register 
11a9			    ret                ; Return 
11a9			 
11a9			; Internal Malloc Function: 
11a9			; Input: 
11a9			;   HL: Size of block to allocate 
11a9			; Output: 
11a9			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11a9			 
11a9			malloc_internal: 
11a9			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11a9			    add hl, bc         ; Add management overhead to requested size 
11a9			    ex de, hl          ; Save total size in DE, and keep it in HL 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma2" 
11a9						CALLMONITOR 
11a9					endif 
11a9			 
11a9			    ; Search for free memory block 
11a9			    ld de, (heap_end)  ; Load end of heap into DE 
11a9			    ld bc, 0           ; Initialize counter 
11a9			 
11a9					if DEBUG_FORTH_MALLOC 
11a9						DMARK "ma2" 
11a9						CALLMONITOR 
11a9					endif 
11a9			malloc_search_loop: 
11a9			    ; Check if current block is free 
11a9			    ld a, (hl)         ; Load current block's status (free or used) 
11a9			    cp 0               ; Compare with zero (free) 
11a9			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11a9			 
11a9			    ; Check if current block is large enough 
11a9			    ld a, (hl+1)       ; Load high byte of block size 
11a9			    cp l               ; Compare with low byte of requested size 
11a9			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11a9			 
11a9			    ld a, (hl+2)       ; Load low byte of block size 
11a9			    cp h               ; Compare with high byte of requested size 
11a9			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11a9			 
11a9			    ; Mark block as used 
11a9			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11a9			 
11a9			    ; Calculate remaining space in block 
11a9			    ld bc, 0           ; Clear BC 
11a9			    add hl, bc         ; Increment HL to point to start of data block 
11a9			    add hl, de         ; HL = HL + DE (total size) 
11a9			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11a9			    add hl, bc         ; Add management overhead to start of data block 
11a9			 
11a9			    ; Save pointer to allocated block in HL 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma5" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			 
11a9			malloc_skip_block_check: 
11a9			    ; Move to the next block 
11a9			    ld bc, 3           ; Size of management overhead 
11a9			    add hl, bc         ; Move to the next block 
11a9			    inc de             ; Increment counter 
11a9			 
11a9			    ; Check if we have reached the end of heap 
11a9			    ld a, e            ; Load low byte of heap end address 
11a9			    cp (hl)            ; Compare with low byte of current address 
11a9			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11a9			    ld a, d            ; Load high byte of heap end address 
11a9			    cp 0               ; Check if it's zero (end of memory) 
11a9			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11a9			 
11a9			    ; If we reached here, allocation failed 
11a9			    xor a              ; Set result to NULL 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma6" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			malloc_exit: 
11a9			if DEBUG_FORTH_MALLOC_HIGH 
11a9						DMARK "ma7" 
11a9			call malloc_guard_exit 
11a9			call malloc_guard_zerolen 
11a9			endif 
11a9			    ret 
11a9			 
11a9			; Internal Free Function: 
11a9			; Input: 
11a9			;   HL: Pointer to memory block to free 
11a9			; Output: 
11a9			;   None 
11a9			 
11a9			free_internal: 
11a9			    ld de, (heap_start) ; Load start of heap into DE 
11a9			    ld bc, 0            ; Initialize counter 
11a9			 
11a9			free_search_loop: 
11a9			    ; Check if current block contains the pointer 
11a9			    ld a, l             ; Load low byte of pointer 
11a9			    cp (hl+1)           ; Compare with high byte of current block's address 
11a9			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11a9			    ld a, h             ; Load high byte of pointer 
11a9			    cp (hl+2)           ; Compare with low byte of current block's address 
11a9			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11a9			 
11a9			    ; Mark block as free 
11a9			    ld (hl), 0          ; Set status byte to indicate free block 
11a9			    ret                 ; Return 
11a9			 
11a9			free_skip_block_check: 
11a9			    ; Move to the next block 
11a9			    ld bc, 3            ; Size of management overhead 
11a9			    add hl, bc          ; Move to the next block 
11a9			    inc de              ; Increment counter 
11a9			 
11a9			    ; Check if we have reached the end of heap 
11a9			    ld a, e             ; Load low byte of heap end address 
11a9			    cp (hl)             ; Compare with low byte of current address 
11a9			    jr nz, free_search_loop  ; If not equal, continue searching 
11a9			    ld a, d             ; Load high byte of heap end address 
11a9			    cp 0                ; Check if it's zero (end of memory) 
11a9			    jr nz, free_search_loop  ; If not zero, continue searching 
11a9			 
11a9			    ; If we reached here, pointer is not found in heap 
11a9			    ret 
11a9			 
11a9			free_exit: 
11a9			    ret                 ; Return 
11a9			 
11a9			; Define heap start and end addresses 
11a9			;heap_start:    .dw 0xC000   ; Start of heap 
11a9			;heap_end:      .dw 0xE000   ; End of heap 
11a9			 
11a9			endif 
11a9			 
11a9			 
11a9			if MALLOC_1 
11a9			 
11a9			 
11a9			 
11a9			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11a9			 
11a9			;moved to firmware.asm 
11a9			;heap_start        .equ  0x9000      ; Starting address of heap 
11a9			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11a9			 
11a9			;      .org 0 
11a9			;      jp    main 
11a9			 
11a9			 
11a9			;      .org  0x100 
11a9			;main: 
11a9			;      ld    HL, 0x8100 
11a9			;      ld    SP, HL 
11a9			; 
11a9			;      call  heap_init 
11a9			; 
11a9			;      ; Make some allocations 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9004 
11a9			; 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9014 
11a9			; 
11a9			;      ld    HL, 12 
11a9			;      call  malloc            ; Allocates 0x9024 
11a9			; 
11a9			;      ; Free some allocations 
11a9			;      ld    HL, 0x9014 
11a9			;      call  free 
11a9			; 
11a9			;      ld    HL, 0x9004 
11a9			;      call  free 
11a9			; 
11a9			;      ld    HL, 0x9024 
11a9			;      call  free 
11a9			; 
11a9			; 
11a9			;      halt 
11a9			 
11a9			 
11a9			;------------------------------------------------------------------------------ 
11a9			;     heap_init                                                               : 
11a9			;                                                                             : 
11a9			; Description                                                                 : 
11a9			;     Initialise the heap and make it ready for malloc and free operations.   : 
11a9			;                                                                             : 
11a9			;     The heap is maintained as a linked list, starting with an initial       : 
11a9			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11a9			;     the first free block in the heap. Each block then points to the next    : 
11a9			;     free block within the heap, and the free list ends at the first block   : 
11a9			;     with a null pointer to the next free block.                             : 
11a9			;                                                                             : 
11a9			; Parameters                                                                  : 
11a9			;     Inputs are compile-time only. Two defines which specify the starting    : 
11a9			;     address of the heap and its size are required, along with a memory      : 
11a9			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11a9			;     principally stores a pointer to the first free block in the heap.       : 
11a9			;                                                                             : 
11a9			; Returns                                                                     : 
11a9			;     Nothing                                                                 : 
11a9			;------------------------------------------------------------------------------ 
11a9			heap_init: 
11a9 e5			      push  HL 
11aa			 
11aa			      ; Initialise free list struct 
11aa 21 0e 80		      ld    HL, heap_start 
11ad 22 0a 80		      ld    (free_list), HL 
11b0 21 00 00		      ld    HL, 0 
11b3 22 0c 80		      ld    (free_list+2), HL 
11b6			 
11b6			      ; Insert first free block at bottom of heap, consumes entire heap 
11b6 21 0a 80		      ld    HL, heap_start+heap_size-4 
11b9 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
11bc 21 fc ff		      ld    HL, heap_size-4 
11bf 22 10 80		      ld    (heap_start+2), HL      ; Block size 
11c2			 
11c2			      ; Insert end of free list block at top of heap - two null words will 
11c2			      ; terminate the free list 
11c2 21 00 00		      ld    HL, 0 
11c5 22 0c 80		      ld    (heap_start+heap_size-2), HL 
11c8 22 0a 80		      ld    (heap_start+heap_size-4), HL 
11cb			 
11cb e1			      pop   HL 
11cc			 
11cc c9			      ret 
11cd			 
11cd			 
11cd			;------------------------------------------------------------------------------ 
11cd			;     malloc                                                                  : 
11cd			;                                                                             : 
11cd			; Description                                                                 : 
11cd			;     Allocates the wanted space from the heap and returns the address of the : 
11cd			;     first useable byte of the allocation.                                   : 
11cd			;                                                                             : 
11cd			;     Allocations can happen in one of two ways:                              : 
11cd			;                                                                             : 
11cd			;     1. A free block may be found which is the exact size wanted. In this    : 
11cd			;        case the block is removed from the free list and retuedn to the      : 
11cd			;        caller.                                                              : 
11cd			;     2. A free block may be found which is larger than the size wanted. In   : 
11cd			;        this case, the larger block is split into two. The first portion of  : 
11cd			;        this block will become the requested space by the malloc call and    : 
11cd			;        is returned to the caller. The second portion becomes a new free     : 
11cd			;        block, and the free list is adjusted to maintain continuity via this : 
11cd			;        newly created block.                                                 : 
11cd			;                                                                             : 
11cd			;     malloc does not set any initial value in the allocated space, the       : 
11cd			;     caller is required to do this as required.                              : 
11cd			;                                                                             : 
11cd			;     This implementation of malloc uses the stack exclusively, and is        : 
11cd			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11cd			;     advisable to disable interrupts before calling malloc, and recommended  : 
11cd			;     to avoid the use of malloc inside ISRs in general.                      : 
11cd			;                                                                             : 
11cd			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11cd			;                                                                             : 
11cd			; Parameters                                                                  : 
11cd			;     HL  Number of bytes wanted                                              : 
11cd			;                                                                             : 
11cd			; Returns                                                                     : 
11cd			;     HL  Address of the first useable byte of the allocation                 : 
11cd			;                                                                             : 
11cd			; Flags                                                                       : 
11cd			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11cd			;                                                                             : 
11cd			; Stack frame                                                                 : 
11cd			;       |             |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     BC      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     DE      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |     IX      |                                                       : 
11cd			;       +-------------+                                                       : 
11cd			;       |  prev_free  |                                                       : 
11cd			;   +4  +-------------+                                                       : 
11cd			;       |  this_free  |                                                       : 
11cd			;   +2  +-------------+                                                       : 
11cd			;       |  next_free  |                                                       : 
11cd			;   +0  +-------------+                                                       : 
11cd			;       |             |                                                       : 
11cd			;                                                                             : 
11cd			;------------------------------------------------------------------------------ 
11cd			 
11cd			 
11cd			;malloc: 
11cd			; 
11cd			;	SAVESP ON 1 
11cd			; 
11cd			;	call malloc_code 
11cd			; 
11cd			;	CHECKSP ON 1 
11cd			;	ret 
11cd			 
11cd			 
11cd			malloc: 
11cd c5			      push  BC 
11ce d5			      push  DE 
11cf dd e5		      push  IX 
11d1			if DEBUG_FORTH_MALLOC_HIGH 
11d1			call malloc_guard_entry 
11d1			endif 
11d1			 
11d1					if DEBUG_FORTH_MALLOC 
11d1						DMARK "mal" 
11d1						CALLMONITOR 
11d1					endif 
11d1 7c			      ld    A, H                    ; Exit if no space requested 
11d2 b5			      or    L 
11d3 ca 92 12		      jp    Z, malloc_early_exit 
11d6			 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			; 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			;inc hl 
11d6			 
11d6			 
11d6			 
11d6			 
11d6					if DEBUG_FORTH_MALLOC 
11d6						DMARK "maA" 
11d6						CALLMONITOR 
11d6					endif 
11d6			      ; Set up stack frame 
11d6 eb			      ex    DE, HL 
11d7 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11da 39			      add   HL, SP 
11db f9			      ld    SP, HL 
11dc dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11e0 dd 39		      add   IX, SP 
11e2			 
11e2			      ; Setup initial state 
11e2 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e5 19			      add   HL, DE 
11e6			 
11e6 44			      ld    B, H                    ; Move want to BC 
11e7 4d			      ld    C, L 
11e8			 
11e8 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
11eb dd 75 04		      ld    (IX+4), L 
11ee dd 74 05		      ld    (IX+5), H 
11f1			 
11f1 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f2 23			      inc   HL 
11f3 56			      ld    D, (HL) 
11f4 dd 73 02		      ld    (IX+2), E 
11f7 dd 72 03		      ld    (IX+3), D 
11fa eb			      ex    DE, HL                  ; this_free ptr into HL 
11fb			 
11fb					if DEBUG_FORTH_MALLOC 
11fb						DMARK "maB" 
11fb						CALLMONITOR 
11fb					endif 
11fb			      ; Loop through free block list to find some space 
11fb			malloc_find_space: 
11fb 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11fc 23			      inc   HL 
11fd 56			      ld    D, (HL) 
11fe			 
11fe 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11ff b3			      or    E 
1200 ca 8c 12		      jp    Z, malloc_no_space 
1203			 
1203 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1206 dd 72 01		      ld    (IX+1), D 
1209			 
1209			      ; Does this block have enough space to make the allocation? 
1209 23			      inc   HL                      ; Load free block size into DE 
120a 5e			      ld    E, (HL) 
120b 23			      inc   HL 
120c 56			      ld    D, (HL) 
120d			 
120d eb			      ex    DE, HL                  ; Check size of block against want 
120e b7			      or    A                       ; Ensure carry flag clear 
120f ed 42		      sbc   HL, BC 
1211 e5			      push  HL                      ; Store the result for later (new block size) 
1212			 
1212 ca 61 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1215 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1217			 
1217			      ; this_free block is not big enough, setup ptrs to test next free block 
1217 e1			      pop   HL                      ; Discard previous result 
1218			 
1218 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
121b dd 66 03		      ld    H, (IX+3) 
121e dd 75 04		      ld    (IX+4), L 
1221 dd 74 05		      ld    (IX+5), H 
1224			 
1224 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1227 dd 66 01		      ld    H, (IX+1) 
122a dd 75 02		      ld    (IX+2), L 
122d dd 74 03		      ld    (IX+3), H 
1230			 
1230					if DEBUG_FORTH_MALLOC 
1230						DMARK "MA>" 
1230						CALLMONITOR 
1230					endif 
1230 18 c9		      jr    malloc_find_space 
1232			 
1232			      ; split a bigger block into two - requested size and remaining size 
1232			malloc_alloc_split: 
1232					if DEBUG_FORTH_MALLOC 
1232						DMARK "MAs" 
1232						CALLMONITOR 
1232					endif 
1232 eb			      ex    DE, HL                  ; Calculate address of new free block 
1233 2b			      dec   HL 
1234 2b			      dec   HL 
1235 2b			      dec   HL 
1236 09			      add   HL, BC 
1237			 
1237			      ; Create a new block and point it at next_free 
1237 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
123a dd 56 01		      ld    D, (IX+1) 
123d			 
123d 73			      ld    (HL), E                 ; Store next_free ptr into new block 
123e 23			      inc   HL 
123f 72			      ld    (HL), D 
1240			 
1240 d1			      pop   DE                      ; Store size of new block into new block 
1241 23			      inc   HL 
1242 73			      ld    (HL), E 
1243 23			      inc   HL 
1244 72			      ld    (HL), D 
1245			 
1245			      ; Update this_free ptr to point to new block 
1245 2b			      dec   HL 
1246 2b			      dec   HL 
1247 2b			      dec   HL 
1248			 
1248 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
124b dd 56 03		      ld    D, (IX+3) 
124e			 
124e dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1251 dd 74 03		      ld    (IX+3), H 
1254			 
1254			      ; Modify this_free block to be allocation 
1254 eb			      ex    DE, HL 
1255 af			      xor   A                       ; Null the next block ptr of allocated block 
1256 77			      ld    (HL), A 
1257 23			      inc   HL 
1258 77			      ld    (HL), A 
1259			 
1259 23			      inc   HL                      ; Store want size into allocated block 
125a 71			      ld    (HL), C 
125b 23			      inc   HL 
125c 70			      ld    (HL), B 
125d 23			      inc   HL 
125e e5			      push  HL                      ; Address of allocation to return 
125f			 
125f 18 19		      jr    malloc_update_links 
1261			 
1261			malloc_alloc_fit: 
1261 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1262			 
1262					if DEBUG_FORTH_MALLOC 
1262						DMARK "MAf" 
1262						CALLMONITOR 
1262					endif 
1262			      ; Modify this_free block to be allocation 
1262 eb			      ex    DE, HL 
1263 2b			      dec   HL 
1264 2b			      dec   HL 
1265 2b			      dec   HL 
1266			 
1266 af			      xor   A                       ; Null the next block ptr of allocated block 
1267 77			      ld    (HL), A 
1268 23			      inc   HL 
1269 77			      ld    (HL), A 
126a			 
126a 23			      inc   HL                      ; Store address of allocation to return 
126b 23			      inc   HL 
126c 23			      inc   HL 
126d e5			      push  HL 
126e			 
126e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
126e dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1271 dd 66 01		      ld    H, (IX+1) 
1274			 
1274 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1277 dd 74 03		      ld    (IX+3), H 
127a			 
127a			 
127a			malloc_update_links: 
127a			      ; Update prev_free ptr to point to this_free 
127a dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
127d dd 66 05		      ld    H, (IX+5) 
1280			 
1280 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1283 dd 56 03		      ld    D, (IX+3) 
1286			 
1286 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1287 23			      inc   HL 
1288 72			      ld    (HL), D 
1289			 
1289					if DEBUG_FORTH_MALLOC 
1289						DMARK "Mul" 
1289						CALLMONITOR 
1289					endif 
1289			      ; Clear the Z flag to indicate successful allocation 
1289 7a			      ld    A, D 
128a b3			      or    E 
128b			 
128b d1			      pop   DE                      ; Address of allocation 
128c					if DEBUG_FORTH_MALLOC 
128c						DMARK "MAu" 
128c						CALLMONITOR 
128c					endif 
128c			 
128c			malloc_no_space: 
128c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
128f 39			      add   HL, SP 
1290 f9			      ld    SP, HL 
1291			 
1291 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1292					if DEBUG_FORTH_MALLOC 
1292						DMARK "MAN" 
1292						CALLMONITOR 
1292					endif 
1292			 
1292			malloc_early_exit: 
1292					if DEBUG_FORTH_MALLOC 
1292						DMARK "MAx" 
1292						CALLMONITOR 
1292					endif 
1292 dd e1		      pop   IX 
1294 d1			      pop   DE 
1295 c1			      pop   BC 
1296			 
1296			if DEBUG_FORTH_MALLOC_HIGH 
1296			call malloc_guard_exit 
1296			call malloc_guard_zerolen 
1296			endif 
1296 c9			      ret 
1297			 
1297			 
1297			;------------------------------------------------------------------------------ 
1297			;     free                                                                    : 
1297			;                                                                             : 
1297			; Description                                                                 : 
1297			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1297			;     returned by malloc, otherwise the behaviour is undefined.               : 
1297			;                                                                             : 
1297			;     Where possible, directly adjacent free blocks will be merged together   : 
1297			;     into larger blocks to help ensure that the heap does not become         : 
1297			;     excessively fragmented.                                                 : 
1297			;                                                                             : 
1297			;     free does not clear or set any other value into the freed space, and    : 
1297			;     therefore its contents may be visible through subsequent malloc's. The  : 
1297			;     caller should clear the freed space as required.                        : 
1297			;                                                                             : 
1297			;     This implementation of free uses the stack exclusively, and is          : 
1297			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1297			;     advisable to disable interrupts before calling free, and recommended    : 
1297			;     to avoid the use of free inside ISRs in general.                        : 
1297			;                                                                             : 
1297			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1297			;                                                                             : 
1297			; Parameters                                                                  : 
1297			;     HL  Pointer to address of first byte of allocation to be freed          : 
1297			;                                                                             : 
1297			; Returns                                                                     : 
1297			;     Nothing                                                                 : 
1297			;                                                                             : 
1297			; Stack frame                                                                 : 
1297			;       |             |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     BC      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     DE      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |     IX      |                                                       : 
1297			;       +-------------+                                                       : 
1297			;       |  prev_free  |                                                       : 
1297			;   +2  +-------------+                                                       : 
1297			;       |  next_free  |                                                       : 
1297			;   +0  +-------------+                                                       : 
1297			;       |             |                                                       : 
1297			;                                                                             : 
1297			;------------------------------------------------------------------------------ 
1297			free: 
1297 c5			      push  BC 
1298 d5			      push  DE 
1299 dd e5		      push  IX 
129b			 
129b 7c			      ld    A, H                    ; Exit if ptr is null 
129c b5			      or    L 
129d ca 61 13		      jp    Z, free_early_exit 
12a0			 
12a0			      ; Set up stack frame 
12a0 eb			      ex    DE, HL 
12a1 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12a4 39			      add   HL, SP 
12a5 f9			      ld    SP, HL 
12a6 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12aa dd 39		      add   IX, SP 
12ac			 
12ac			      ; The address in HL points to the start of the useable allocated space, 
12ac			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12ac			      ; address of the block itself. 
12ac eb			      ex    DE, HL 
12ad 11 fc ff		      ld    DE, -4 
12b0 19			      add   HL, DE 
12b1			 
12b1			      ; An allocated block must have a null next block pointer in it 
12b1 7e			      ld    A, (HL) 
12b2 23			      inc   HL 
12b3 b6			      or    (HL) 
12b4 c2 5c 13		      jp    NZ, free_done 
12b7			 
12b7 2b			      dec   HL 
12b8			 
12b8 44			      ld    B, H                    ; Copy HL to BC 
12b9 4d			      ld    C, L 
12ba			 
12ba			      ; Loop through the free list to find the first block with an address 
12ba			      ; higher than the block being freed 
12ba 21 0a 80		      ld    HL, free_list 
12bd			 
12bd			free_find_higher_block: 
12bd 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12be 23			      inc   HL 
12bf 56			      ld    D, (HL) 
12c0 2b			      dec   HL 
12c1			 
12c1 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12c4 dd 72 01		      ld    (IX+1), D 
12c7 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12ca dd 74 03		      ld    (IX+3), H 
12cd			 
12cd 78			      ld    A, B                    ; Check if DE is greater than BC 
12ce ba			      cp    D                       ; Compare MSB first 
12cf 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12d1 30 04		      jr    NC, free_find_higher_block_skip 
12d3 79			      ld    A, C 
12d4 bb			      cp    E                       ; Then compare LSB 
12d5 38 08		      jr    C, free_found_higher_block 
12d7			 
12d7			free_find_higher_block_skip: 
12d7 7a			      ld    A, D                    ; Reached the end of the free list? 
12d8 b3			      or    E 
12d9 ca 5c 13		      jp    Z, free_done 
12dc			 
12dc eb			      ex    DE, HL 
12dd			 
12dd 18 de		      jr    free_find_higher_block 
12df			 
12df			free_found_higher_block: 
12df			      ; Insert freed block between prev and next free blocks 
12df 71			      ld    (HL), C                 ; Point prev free block to freed block 
12e0 23			      inc   HL 
12e1 70			      ld    (HL), B 
12e2			 
12e2 60			      ld    H, B                    ; Point freed block at next free block 
12e3 69			      ld    L, C 
12e4 73			      ld    (HL), E 
12e5 23			      inc   HL 
12e6 72			      ld    (HL), D 
12e7			 
12e7			      ; Check if the freed block is adjacent to the next free block 
12e7 23			      inc   HL                      ; Load size of freed block into HL 
12e8 5e			      ld    E, (HL) 
12e9 23			      inc   HL 
12ea 56			      ld    D, (HL) 
12eb eb			      ex    DE, HL 
12ec			 
12ec 09			      add   HL, BC                  ; Add addr of freed block and its size 
12ed			 
12ed dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12f0 dd 56 01		      ld    D, (IX+1) 
12f3			 
12f3 b7			      or    A                       ; Clear the carry flag 
12f4 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f6 20 22		      jr    NZ, free_check_adjacent_to_prev 
12f8			 
12f8			      ; Freed block is adjacent to next, merge into one bigger block 
12f8 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12f9 5e			      ld    E, (HL) 
12fa 23			      inc   HL 
12fb 56			      ld    D, (HL) 
12fc e5			      push  HL                      ; Save ptr to next block for later 
12fd			 
12fd 60			      ld    H, B                    ; Store ptr from next block into freed block 
12fe 69			      ld    L, C 
12ff 73			      ld    (HL), E 
1300 23			      inc   HL 
1301 72			      ld    (HL), D 
1302			 
1302 e1			      pop   HL                      ; Restore ptr to next block 
1303 23			      inc   HL                      ; Load size of next block into DE 
1304 5e			      ld    E, (HL) 
1305 23			      inc   HL 
1306 56			      ld    D, (HL) 
1307 d5			      push  DE                      ; Save next block size for later 
1308			 
1308 60			      ld    H, B                    ; Load size of freed block into HL 
1309 69			      ld    L, C 
130a 23			      inc   HL 
130b 23			      inc   HL 
130c 5e			      ld    E, (HL) 
130d 23			      inc   HL 
130e 56			      ld    D, (HL) 
130f eb			      ex    DE, HL 
1310			 
1310 d1			      pop   DE                      ; Restore size of next block 
1311 19			      add   HL, DE                  ; Add sizes of both blocks 
1312 eb			      ex    DE, HL 
1313			 
1313 60			      ld    H, B                    ; Store new bigger size into freed block 
1314 69			      ld    L, C 
1315 23			      inc   HL 
1316 23			      inc   HL 
1317 73			      ld    (HL), E 
1318 23			      inc   HL 
1319 72			      ld    (HL), D 
131a			 
131a			free_check_adjacent_to_prev: 
131a			      ; Check if the freed block is adjacent to the prev free block 
131a dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
131d dd 66 03		      ld    H, (IX+3) 
1320			 
1320 23			      inc   HL                      ; Size of prev free block into DE 
1321 23			      inc   HL 
1322 5e			      ld    E, (HL) 
1323 23			      inc   HL 
1324 56			      ld    D, (HL) 
1325 2b			      dec   HL 
1326 2b			      dec   HL 
1327 2b			      dec   HL 
1328			 
1328 19			      add   HL, DE                  ; Add prev block addr and size 
1329			 
1329 b7			      or    A                       ; Clear the carry flag 
132a ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132c 20 2e		      jr    NZ, free_done 
132e			 
132e			      ; Freed block is adjacent to prev, merge into one bigger block 
132e 60			      ld    H, B                    ; Load next ptr from freed block into DE 
132f 69			      ld    L, C 
1330 5e			      ld    E, (HL) 
1331 23			      inc   HL 
1332 56			      ld    D, (HL) 
1333 e5			      push  HL                      ; Save freed block ptr for later 
1334			 
1334 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1337 dd 66 03		      ld    H, (IX+3) 
133a 73			      ld    (HL), E 
133b 23			      inc   HL 
133c 72			      ld    (HL), D 
133d			 
133d e1			      pop   HL                      ; Restore freed block ptr 
133e 23			      inc   HL                      ; Load size of freed block into DE 
133f 5e			      ld    E, (HL) 
1340 23			      inc   HL 
1341 56			      ld    D, (HL) 
1342 d5			      push  DE                      ; Save freed block size for later 
1343			 
1343 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1346 dd 66 03		      ld    H, (IX+3) 
1349 23			      inc   HL 
134a 23			      inc   HL 
134b 5e			      ld    E, (HL) 
134c 23			      inc   HL 
134d 56			      ld    D, (HL) 
134e			 
134e e1			      pop   HL                      ; Add sizes of both blocks 
134f 19			      add   HL, DE 
1350 eb			      ex    DE, HL 
1351			 
1351 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1354 dd 66 03		      ld    H, (IX+3) 
1357 23			      inc   HL 
1358 23			      inc   HL 
1359 73			      ld    (HL), E 
135a 23			      inc   HL 
135b 72			      ld    (HL), D 
135c			 
135c			free_done: 
135c 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
135f 39			      add   HL, SP 
1360 f9			      ld    SP, HL 
1361			 
1361			free_early_exit: 
1361 dd e1		      pop   IX 
1363 d1			      pop   DE 
1364 c1			      pop   BC 
1365			 
1365 c9			      ret 
1366			 
1366			; moved to firmware.asm 
1366			; 
1366			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1366			;                  .dw   0 
1366			 
1366			 
1366			endif 
1366			 
1366			 
1366			if MALLOC_3 
1366			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1366			;heap_start        .equ  0x9000      ; Starting address of heap 
1366			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1366			; 
1366			 ;     .org 0 
1366			  ;    jp    main 
1366			; 
1366			; 
1366			 ;     .org  0x100 
1366			;main: 
1366			 ;     ld    HL, 0x8100 
1366			  ;    ld    SP, HL 
1366			; 
1366			;      call  heap_init 
1366			 
1366			      ; Make some allocations 
1366			;      ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9004 
1366			; 
1366			 ;     ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9014 
1366			 
1366			;      ld    HL, 12 
1366			;      call  malloc            ; Allocates 0x9024 
1366			 
1366			      ; Free some allocations 
1366			;      ld    HL, 0x9014 
1366			;      call  free 
1366			 
1366			;      ld    HL, 0x9004 
1366			;      call  free 
1366			; 
1366			;      ld    HL, 0x9024 
1366			;      call  free 
1366			 
1366			 
1366			 ;     halt 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     heap_init                                                               : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Initialise the heap and make it ready for malloc and free operations.   : 
1366			;                                                                             : 
1366			;     The heap is maintained as a linked list, starting with an initial       : 
1366			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1366			;     the first free block in the heap. Each block then points to the next    : 
1366			;     free block within the heap, and the free list ends at the first block   : 
1366			;     with a null pointer to the next free block.                             : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     Inputs are compile-time only. Two defines which specify the starting    : 
1366			;     address of the heap and its size are required, along with a memory      : 
1366			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1366			;     principally stores a pointer to the first free block in the heap.       : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     Nothing                                                                 : 
1366			;------------------------------------------------------------------------------ 
1366			heap_init: 
1366			      push  HL 
1366			 
1366			      ; Initialise free list struct 
1366			      ld    HL, heap_start 
1366			      ld    (free_list), HL 
1366			      ld    HL, 0 
1366			      ld    (free_list+2), HL 
1366			 
1366			      ; Insert first free block at bottom of heap, consumes entire heap 
1366			      ld    HL, heap_start+heap_size-4 
1366			      ld    (heap_start), HL        ; Next block (end of free list) 
1366			      ld    HL, heap_size-4 
1366			      ld    (heap_start+2), HL      ; Block size 
1366			 
1366			      ; Insert end of free list block at top of heap - two null words will 
1366			      ; terminate the free list 
1366			      ld    HL, 0 
1366			      ld    (heap_start+heap_size-2), HL 
1366			      ld    (heap_start+heap_size-4), HL 
1366			 
1366			      pop   HL 
1366			 
1366			      ret 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     malloc                                                                  : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Allocates the wanted space from the heap and returns the address of the : 
1366			;     first useable byte of the allocation.                                   : 
1366			;                                                                             : 
1366			;     Allocations can happen in one of two ways:                              : 
1366			;                                                                             : 
1366			;     1. A free block may be found which is the exact size wanted. In this    : 
1366			;        case the block is removed from the free list and retuedn to the      : 
1366			;        caller.                                                              : 
1366			;     2. A free block may be found which is larger than the size wanted. In   : 
1366			;        this case, the larger block is split into two. The first portion of  : 
1366			;        this block will become the requested space by the malloc call and    : 
1366			;        is returned to the caller. The second portion becomes a new free     : 
1366			;        block, and the free list is adjusted to maintain continuity via this : 
1366			;        newly created block.                                                 : 
1366			;                                                                             : 
1366			;     malloc does not set any initial value in the allocated space, the       : 
1366			;     caller is required to do this as required.                              : 
1366			;                                                                             : 
1366			;     This implementation of malloc uses the stack exclusively, and is        : 
1366			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1366			;     advisable to disable interrupts before calling malloc, and recommended  : 
1366			;     to avoid the use of malloc inside ISRs in general.                      : 
1366			;                                                                             : 
1366			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     HL  Number of bytes wanted                                              : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     HL  Address of the first useable byte of the allocation                 : 
1366			;                                                                             : 
1366			; Flags                                                                       : 
1366			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1366			;                                                                             : 
1366			; Stack frame                                                                 : 
1366			;       |             |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     BC      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     DE      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     IX      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |  prev_free  |                                                       : 
1366			;   +4  +-------------+                                                       : 
1366			;       |  this_free  |                                                       : 
1366			;   +2  +-------------+                                                       : 
1366			;       |  next_free  |                                                       : 
1366			;   +0  +-------------+                                                       : 
1366			;       |             |                                                       : 
1366			;                                                                             : 
1366			;------------------------------------------------------------------------------ 
1366			malloc: 
1366			      push  BC 
1366			      push  DE 
1366			      push  IX 
1366			 
1366			      ld    A, H                    ; Exit if no space requested 
1366			      or    L 
1366			      jp    Z, malloc_early_exit 
1366			 
1366			      ; Set up stack frame 
1366			      ex    DE, HL 
1366			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			      ld    IX, 0                   ; Use IX as a frame pointer 
1366			      add   IX, SP 
1366			 
1366			      ; Setup initial state 
1366			      ld    HL, 4                   ; want must also include space used by block struct 
1366			      add   HL, DE 
1366			 
1366			      ld    B, H                    ; Move want to BC 
1366			      ld    C, L 
1366			 
1366			      ld    HL, free_list           ; Store prev_free ptr to stack 
1366			      ld    (IX+4), L 
1366			      ld    (IX+5), H 
1366			 
1366			      ld    E, (HL)                 ; Store this_free ptr to stack 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ld    (IX+2), E 
1366			      ld    (IX+3), D 
1366			      ex    DE, HL                  ; this_free ptr into HL 
1366			 
1366			      ; Loop through free block list to find some space 
1366			malloc_find_space: 
1366			      ld    E, (HL)                 ; Load next_free ptr into DE 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1366			      or    E 
1366			      jp    Z, malloc_no_space 
1366			 
1366			      ld    (IX+0), E               ; Store next_free ptr to stack 
1366			      ld    (IX+1), D 
1366			 
1366			      ; Does this block have enough space to make the allocation? 
1366			      inc   HL                      ; Load free block size into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      ex    DE, HL                  ; Check size of block against want 
1366			      or    A                       ; Ensure carry flag clear 
1366			      sbc   HL, BC 
1366			      push  HL                      ; Store the result for later (new block size) 
1366			 
1366			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1366			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1366			 
1366			      ; this_free block is not big enough, setup ptrs to test next free block 
1366			      pop   HL                      ; Discard previous result 
1366			 
1366			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1366			      ld    H, (IX+3) 
1366			      ld    (IX+4), L 
1366			      ld    (IX+5), H 
1366			 
1366			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1366			      ld    H, (IX+1) 
1366			      ld    (IX+2), L 
1366			      ld    (IX+3), H 
1366			 
1366			      jr    malloc_find_space 
1366			 
1366			      ; split a bigger block into two - requested size and remaining size 
1366			malloc_alloc_split: 
1366			      ex    DE, HL                  ; Calculate address of new free block 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			      add   HL, BC 
1366			 
1366			      ; Create a new block and point it at next_free 
1366			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1366			      ld    D, (IX+1) 
1366			 
1366			      ld    (HL), E                 ; Store next_free ptr into new block 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   DE                      ; Store size of new block into new block 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Update this_free ptr to point to new block 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1366			      ld    D, (IX+3) 
1366			 
1366			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1366			      ld    (IX+3), H 
1366			 
1366			      ; Modify this_free block to be allocation 
1366			      ex    DE, HL 
1366			      xor   A                       ; Null the next block ptr of allocated block 
1366			      ld    (HL), A 
1366			      inc   HL 
1366			      ld    (HL), A 
1366			 
1366			      inc   HL                      ; Store want size into allocated block 
1366			      ld    (HL), C 
1366			      inc   HL 
1366			      ld    (HL), B 
1366			      inc   HL 
1366			      push  HL                      ; Address of allocation to return 
1366			 
1366			      jr    malloc_update_links 
1366			 
1366			malloc_alloc_fit: 
1366			      pop   HL                      ; Dont need new block size, want is exact fit 
1366			 
1366			      ; Modify this_free block to be allocation 
1366			      ex    DE, HL 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      xor   A                       ; Null the next block ptr of allocated block 
1366			      ld    (HL), A 
1366			      inc   HL 
1366			      ld    (HL), A 
1366			 
1366			      inc   HL                      ; Store address of allocation to return 
1366			      inc   HL 
1366			      inc   HL 
1366			      push  HL 
1366			 
1366			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1366			      ld    L, (IX+0)               ; next_free to HL 
1366			      ld    H, (IX+1) 
1366			 
1366			      ld    (IX+2), L               ; HL to this_free 
1366			      ld    (IX+3), H 
1366			 
1366			 
1366			malloc_update_links: 
1366			      ; Update prev_free ptr to point to this_free 
1366			      ld    L, (IX+4)               ; prev_free ptr to HL 
1366			      ld    H, (IX+5) 
1366			 
1366			      ld    E, (IX+2)               ; this_free ptr to DE 
1366			      ld    D, (IX+3) 
1366			 
1366			      ld    (HL), E                 ; this_free ptr into prev_free 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Clear the Z flag to indicate successful allocation 
1366			      ld    A, D 
1366			      or    E 
1366			 
1366			      pop   DE                      ; Address of allocation 
1366			 
1366			malloc_no_space: 
1366			      ld    HL, 6                   ; Clean up stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			 
1366			      ex    DE, HL                  ; Alloc addr into HL for return 
1366			 
1366			malloc_early_exit: 
1366			      pop   IX 
1366			      pop   DE 
1366			      pop   BC 
1366			 
1366			      ret 
1366			 
1366			 
1366			;------------------------------------------------------------------------------ 
1366			;     free                                                                    : 
1366			;                                                                             : 
1366			; Description                                                                 : 
1366			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1366			;     returned by malloc, otherwise the behaviour is undefined.               : 
1366			;                                                                             : 
1366			;     Where possible, directly adjacent free blocks will be merged together   : 
1366			;     into larger blocks to help ensure that the heap does not become         : 
1366			;     excessively fragmented.                                                 : 
1366			;                                                                             : 
1366			;     free does not clear or set any other value into the freed space, and    : 
1366			;     therefore its contents may be visible through subsequent malloc's. The  : 
1366			;     caller should clear the freed space as required.                        : 
1366			;                                                                             : 
1366			;     This implementation of free uses the stack exclusively, and is          : 
1366			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1366			;     advisable to disable interrupts before calling free, and recommended    : 
1366			;     to avoid the use of free inside ISRs in general.                        : 
1366			;                                                                             : 
1366			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1366			;                                                                             : 
1366			; Parameters                                                                  : 
1366			;     HL  Pointer to address of first byte of allocation to be freed          : 
1366			;                                                                             : 
1366			; Returns                                                                     : 
1366			;     Nothing                                                                 : 
1366			;                                                                             : 
1366			; Stack frame                                                                 : 
1366			;       |             |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     BC      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     DE      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |     IX      |                                                       : 
1366			;       +-------------+                                                       : 
1366			;       |  prev_free  |                                                       : 
1366			;   +2  +-------------+                                                       : 
1366			;       |  next_free  |                                                       : 
1366			;   +0  +-------------+                                                       : 
1366			;       |             |                                                       : 
1366			;                                                                             : 
1366			;------------------------------------------------------------------------------ 
1366			free: 
1366			      push  BC 
1366			      push  DE 
1366			      push  IX 
1366			 
1366			      ld    A, H                    ; Exit if ptr is null 
1366			      or    L 
1366			      jp    Z, free_early_exit 
1366			 
1366			      ; Set up stack frame 
1366			      ex    DE, HL 
1366			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			      ld    IX, 0                   ; Use IX as a frame pointer 
1366			      add   IX, SP 
1366			 
1366			      ; The address in HL points to the start of the useable allocated space, 
1366			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1366			      ; address of the block itself. 
1366			      ex    DE, HL 
1366			      ld    DE, -4 
1366			      add   HL, DE 
1366			 
1366			      ; An allocated block must have a null next block pointer in it 
1366			      ld    A, (HL) 
1366			      inc   HL 
1366			      or    (HL) 
1366			      jp    NZ, free_done 
1366			 
1366			      dec   HL 
1366			 
1366			      ld    B, H                    ; Copy HL to BC 
1366			      ld    C, L 
1366			 
1366			      ; Loop through the free list to find the first block with an address 
1366			      ; higher than the block being freed 
1366			      ld    HL, free_list 
1366			 
1366			free_find_higher_block: 
1366			      ld    E, (HL)                 ; Load next ptr from free block 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      dec   HL 
1366			 
1366			      ld    (IX+0), E               ; Save ptr to next free block 
1366			      ld    (IX+1), D 
1366			      ld    (IX+2), L               ; Save ptr to prev free block 
1366			      ld    (IX+3), H 
1366			 
1366			      ld    A, B                    ; Check if DE is greater than BC 
1366			      cp    D                       ; Compare MSB first 
1366			      jr    Z, $+4                  ; MSB the same, compare LSB 
1366			      jr    NC, free_find_higher_block_skip 
1366			      ld    A, C 
1366			      cp    E                       ; Then compare LSB 
1366			      jr    C, free_found_higher_block 
1366			 
1366			free_find_higher_block_skip: 
1366			      ld    A, D                    ; Reached the end of the free list? 
1366			      or    E 
1366			      jp    Z, free_done 
1366			 
1366			      ex    DE, HL 
1366			 
1366			      jr    free_find_higher_block 
1366			 
1366			free_found_higher_block: 
1366			      ; Insert freed block between prev and next free blocks 
1366			      ld    (HL), C                 ; Point prev free block to freed block 
1366			      inc   HL 
1366			      ld    (HL), B 
1366			 
1366			      ld    H, B                    ; Point freed block at next free block 
1366			      ld    L, C 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      ; Check if the freed block is adjacent to the next free block 
1366			      inc   HL                      ; Load size of freed block into HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ex    DE, HL 
1366			 
1366			      add   HL, BC                  ; Add addr of freed block and its size 
1366			 
1366			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1366			      ld    D, (IX+1) 
1366			 
1366			      or    A                       ; Clear the carry flag 
1366			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1366			      jr    NZ, free_check_adjacent_to_prev 
1366			 
1366			      ; Freed block is adjacent to next, merge into one bigger block 
1366			      ex    DE, HL                  ; Load next ptr from next block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  HL                      ; Save ptr to next block for later 
1366			 
1366			      ld    H, B                    ; Store ptr from next block into freed block 
1366			      ld    L, C 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   HL                      ; Restore ptr to next block 
1366			      inc   HL                      ; Load size of next block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  DE                      ; Save next block size for later 
1366			 
1366			      ld    H, B                    ; Load size of freed block into HL 
1366			      ld    L, C 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      ex    DE, HL 
1366			 
1366			      pop   DE                      ; Restore size of next block 
1366			      add   HL, DE                  ; Add sizes of both blocks 
1366			      ex    DE, HL 
1366			 
1366			      ld    H, B                    ; Store new bigger size into freed block 
1366			      ld    L, C 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			free_check_adjacent_to_prev: 
1366			      ; Check if the freed block is adjacent to the prev free block 
1366			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1366			      ld    H, (IX+3) 
1366			 
1366			      inc   HL                      ; Size of prev free block into DE 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      dec   HL 
1366			      dec   HL 
1366			      dec   HL 
1366			 
1366			      add   HL, DE                  ; Add prev block addr and size 
1366			 
1366			      or    A                       ; Clear the carry flag 
1366			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1366			      jr    NZ, free_done 
1366			 
1366			      ; Freed block is adjacent to prev, merge into one bigger block 
1366			      ld    H, B                    ; Load next ptr from freed block into DE 
1366			      ld    L, C 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  HL                      ; Save freed block ptr for later 
1366			 
1366			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1366			      ld    H, (IX+3) 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			      pop   HL                      ; Restore freed block ptr 
1366			      inc   HL                      ; Load size of freed block into DE 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			      push  DE                      ; Save freed block size for later 
1366			 
1366			      ld    L, (IX+2)               ; Load size of prev block into DE 
1366			      ld    H, (IX+3) 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    E, (HL) 
1366			      inc   HL 
1366			      ld    D, (HL) 
1366			 
1366			      pop   HL                      ; Add sizes of both blocks 
1366			      add   HL, DE 
1366			      ex    DE, HL 
1366			 
1366			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1366			      ld    H, (IX+3) 
1366			      inc   HL 
1366			      inc   HL 
1366			      ld    (HL), E 
1366			      inc   HL 
1366			      ld    (HL), D 
1366			 
1366			free_done: 
1366			      ld    HL, 4                   ; Clean up stack frame 
1366			      add   HL, SP 
1366			      ld    SP, HL 
1366			 
1366			free_early_exit: 
1366			      pop   IX 
1366			      pop   DE 
1366			      pop   BC 
1366			 
1366			      ret 
1366			 
1366			 
1366			;      .org 0x8000 
1366			; 
1366			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1366			 ;                 .dw   0 
1366			 
1366			endif 
1366			 
1366			 
1366			if MALLOC_4 
1366			 
1366			; My memory allocation code. Very very simple.... 
1366			; allocate space under 250 chars 
1366			 
1366			heap_init: 
1366				; init start of heap as zero 
1366				;  
1366			 
1366				ld hl, heap_start 
1366				ld a, 0 
1366				ld (hl), a      ; empty block 
1366				inc hl 
1366				ld a, 0 
1366				ld (hl), a      ; length of block 
1366				; write end of list 
1366				inc hl 
1366				ld a,(hl) 
1366				inc hl 
1366				ld a,(hl) 
1366				 
1366			 
1366				; init some malloc vars 
1366			 
1366				ld hl, 0 
1366				ld (free_list), hl       ; store last malloc location 
1366			 
1366				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1366				ld a, 0 
1366				ld (hl), a 
1366			 
1366			 
1366				ld hl, heap_start 
1366				;  
1366				  
1366				ret 
1366			 
1366			 
1366			;    free block marker 
1366			;    requested size  
1366			;    pointer to next block 
1366			;    .... 
1366			;    next block marker 
1366			 
1366			 
1366			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1366			; 
1366			 
1366			 
1366			malloc:  
1366				push de 
1366				push bc 
1366				push af 
1366			 
1366				; hl space required 
1366				 
1366				ld c, l    ; hold space   (TODO only a max of 255) 
1366			 
1366			;	inc c     ; TODO BUG need to fix memory leak on push str 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			;	inc c 
1366			 
1366			 
1366			 
1366				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1366			 
1366				ld a, (free_list+3) 
1366				cp 0 
1366				jr z, .contheap 
1366			 
1366				ld hl, (free_list)     ; get last alloc 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mrs" 
1366						CALLMONITOR 
1366					endif 
1366				jr .startalloc 
1366			 
1366			.contheap: 
1366				ld hl, heap_start 
1366			 
1366			.startalloc: 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mym" 
1366						CALLMONITOR 
1366					endif 
1366			.findblock: 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mmf" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366				ld a,(hl)  
1366				; if byte is zero then clear to use 
1366			 
1366				cp 0 
1366				jr z, .foundemptyblock 
1366			 
1366				; if byte is not clear 
1366				;     then byte is offset to next block 
1366			 
1366				inc hl 
1366				ld a, (hl) ; get size 
1366			.nextblock:	inc hl 
1366					ld e, (hl) 
1366					inc hl 
1366					ld d, (hl) 
1366					ex de, hl 
1366			;	inc hl  ; move past the store space 
1366			;	inc hl  ; move past zero index  
1366			 
1366				; TODO detect no more space 
1366			 
1366				push hl 
1366				ld de, heap_end 
1366				call cmp16 
1366				pop hl 
1366				jr nc, .nospace 
1366			 
1366				jr .findblock 
1366			 
1366			.nospace: ld hl, 0 
1366				jp .exit 
1366			 
1366			 
1366			.foundemptyblock:	 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mme" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			; TODO has block enough space if reusing??? 
1366			 
1366				;  
1366			 
1366			; see if this block has been previously used 
1366				inc hl 
1366				ld a, (hl) 
1366				dec hl 
1366				cp 0 
1366				jr z, .newblock 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "meR" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			; no reusing previously allocated block 
1366			 
1366			; is it smaller than previously used? 
1366				 
1366				inc hl    ; move to size 
1366				ld a, c 
1366				sub (hl)        ; we want c < (hl) 
1366				dec hl    ; move back to marker 
1366			        jr z, .findblock 
1366			 
1366				; update with the new size which should be lower 
1366			 
1366			        ;inc  hl   ; negate next move. move back to size  
1366			 
1366			.newblock: 
1366				; need to be at marker here 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "meN" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			 
1366				ld a, c 
1366			 
1366				ld (free_list+3), a	 ; flag resume from last malloc  
1366				ld (free_list), hl    ; save out last location 
1366			 
1366			 
1366				;inc a     ; space for length byte 
1366				ld (hl), a     ; save block in use marker 
1366			 
1366				inc hl   ; move to space marker 
1366				ld (hl), a    ; save new space 
1366			 
1366				inc hl   ; move to start of allocated area 
1366				 
1366			;	push hl     ; save where we are - 1  
1366			 
1366			;	inc hl  ; move past zero index  
1366				; skip space to set down new marker 
1366			 
1366				; provide some extra space for now 
1366			 
1366				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1366				inc a 
1366				inc a 
1366			 
1366				push hl   ; save where we are in the node block 
1366			 
1366				call addatohl 
1366			 
1366				; write linked list point 
1366			 
1366				pop de     ; get our node position 
1366				ex de, hl 
1366			 
1366				ld (hl), e 
1366				inc hl 
1366				ld (hl), d 
1366			 
1366				inc hl 
1366			 
1366				; now at start of allocated data so save pointer 
1366			 
1366				push hl 
1366			 
1366				; jump to position of next node and setup empty header in DE 
1366			 
1366				ex de, hl 
1366			 
1366			;	inc hl ; move past end of block 
1366			 
1366				ld a, 0 
1366				ld (hl), a   ; empty marker 
1366				inc hl 
1366				ld (hl), a   ; size 
1366				inc hl  
1366				ld (hl), a   ; ptr 
1366				inc hl 
1366				ld (hl), a   ; ptr 
1366			 
1366			 
1366				pop hl 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "mmr" 
1366						CALLMONITOR 
1366					endif 
1366			 
1366			.exit: 
1366				pop af 
1366				pop bc 
1366				pop de  
1366				ret 
1366			 
1366			 
1366			 
1366			 
1366			free:  
1366				push hl 
1366				push af 
1366				; get address in hl 
1366			 
1366					if DEBUG_FORTH_MALLOC_INT 
1366						DMARK "fre" 
1366						CALLMONITOR 
1366					endif 
1366				; data is at hl - move to block count 
1366				dec hl 
1366				dec hl    ; get past pointer 
1366				dec hl 
1366			 
1366				ld a, (hl)    ; need this for a validation check 
1366			 
1366				dec hl    ; move to block marker 
1366			 
1366				; now check that the block count and block marker are the same  
1366			        ; this checks that we are on a malloc node and not random memory 
1366			        ; OK a faint chance this could be a problem but rare - famous last words! 
1366			 
1366				ld c, a 
1366				ld a, (hl)    
1366			 
1366				cp c 
1366				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1366			 
1366				; yes good chance we are on a malloc node 
1366			 
1366				ld a, 0      
1366				ld (hl), a   ; mark as free 
1366			 
1366				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1366			 
1366			.freeignore:  
1366			 
1366				pop af 
1366				pop hl 
1366			 
1366				ret 
1366			 
1366			 
1366			 
1366			endif 
1366			 
1366			; eof 
# End of file firmware_memory.asm
1366			  
1366			; device C  
1366			if SOUND_ENABLE  
1366				include "firmware_sound.asm"  
1366			endif  
1366			  
1366			include "firmware_diags.asm"  
1366			; Hardware diags menu 
1366			 
1366			 
1366			config: 
1366			 
1366 3e 00			ld a, 0 
1368 21 8c 13			ld hl, .configmn 
136b cd 03 0b			call menu 
136e			 
136e fe 00			cp 0 
1370 c8				ret z 
1371			 
1371 fe 01			cp 1 
1373 cc 51 14			call z, .savetostore 
1376			 
1376 fe 02			cp 2 
1378 cc 12 14			call z, .selautoload 
137b fe 03			cp 3 
137d cc 4f 14			call z, .selbank 
1380 fe 05			cp 5 
1382 cc 2c 15			call z, .debug_tog 
1385 fe 06			cp 6 
1387 cc 52 15			call z, hardware_diags 
138a			 
138a 18 da			jr config 
138c			 
138c			.configmn: 
138c 9a 13			dw .c3 
138e b6 13			dw .c2 
1390 cb 13			dw .c2b 
1392 df 13			dw .c4 
1394 e8 13			dw .m4 
1396 03 14			dw .c1 
1398 00 00			dw 0 
139a				 
139a			 
139a .. 00		.c3: db "Add User Dictionary To File",0 
13b6 .. 00		.c2: db "Select Autoload File",0 
13cb .. 00		.c2b: db "Select Storage Bank",0 
13df .. 00		.c4: db "Settings",0 
13e8 .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
1403 .. 00		.c1: db "Hardware Diags",0 
1412			 
1412			; Select auto start 
1412			 
1412			.selautoload: 
1412			 
1412				 
1412				if STORAGE_SE 
1412			 
1412 cd 76 14				call config_dir 
1415 21 a3 ef			        ld hl, scratch 
1418 3e 00				ld a, 0 
141a cd 03 0b				call menu 
141d			 
141d					; locate menu option 
141d			 
141d 21 a3 ef				ld hl, scratch 
1420 cd 2a 0a				call table_lookup 
1423			 
1423					; with the pointer to the menu it, the byte following the zero term is the file id 
1423			 
1423 3e 00				ld a, 0 
1425 01 32 00				ld bc, 50   ; max of bytes to look at 
1428 ed b1				cpir  
142a			 
142a 23					inc hl 
142b			 
142b 7e					ld a, (hl)   ; file id 
142c					 
142c				        ; save bank and file ids 
142c			 
142c f5					push af 
142d			 
142d cd ba 03				call storage_get_block_0 
1430			 
1430 f1					pop af 
1431			 
1431 32 0c fa				ld (store_page+STORE_0_FILERUN),a 
1434					 
1434					; save bank id 
1434			 
1434 3a ce f9				ld a,(spi_device) 
1437 32 0b fa				ld (store_page+STORE_0_BANKRUN),a 
143a			 
143a					; enable auto run of store file 
143a 3e 01				ld a, 1 
143c 32 09 fa				ld (store_page+STORE_0_AUTOFILE),a 
143f			 
143f					; save buffer 
143f			 
143f 21 00 00				ld hl, 0 
1442 11 e8 f9				ld de, store_page 
1445 cd 6e 03			call storage_write_block	 ; save update 
1448			  
1448			 
1448			 
1448			 
1448 21 a3 ef				ld hl, scratch 
144b cd 63 14				call config_fdir 
144e			 
144e			 
144e				endif 
144e c9				ret 
144f			 
144f			 
144f			 
144f			; Select storage bank 
144f			 
144f			.selbank: 
144f			 
144f				if STORAGE_SE 
144f				endif 
144f				 
144f c9				ret 
1450			 
1450			if STORAGE_SE 
1450			 
1450			.config_ldir:   
1450				; Load storage bank labels into menu array 
1450			 
1450				 
1450			 
1450			 
1450 c9				ret 
1451			 
1451			 
1451			endif 
1451			 
1451			 
1451			; Save user words to storage 
1451			 
1451			.savetostore: 
1451			 
1451				if STORAGE_SE 
1451			 
1451 cd 76 14				call config_dir 
1454 21 a3 ef			        ld hl, scratch 
1457 3e 00				ld a, 0 
1459 cd 03 0b				call menu 
145c					 
145c 21 a3 ef				ld hl, scratch 
145f cd 63 14				call config_fdir 
1462			 
1462			 
1462				endif 
1462			 
1462 c9				ret 
1463			 
1463			 
1463			 
1463			if STORAGE_SE 
1463			 
1463			config_fdir: 
1463				; using the scratch dir go through and release the memory allocated for each string 
1463				 
1463 21 a3 ef			ld hl, scratch 
1466 5e			.cfdir:	ld e,(hl) 
1467 23				inc hl 
1468 56				ld d,(hl) 
1469 23				inc hl 
146a			 
146a eb				ex de, hl 
146b cd 2f 0d			call ishlzero 
146e c8				ret z     ; return on null pointer 
146f cd 97 12			call free 
1472 eb				ex de, hl 
1473 18 f1			jr .cfdir 
1475			 
1475			 
1475 c9				ret 
1476			 
1476			 
1476			config_dir: 
1476			 
1476				; for the config menus that need to build a directory of storage call this routine 
1476				; it will construct a menu in scratch to pass to menu 
1476			 
1476				; open storage device 
1476			 
1476				; execute DIR to build a list of files and their ids into scratch in menu format 
1476				; once the menu has finished then will need to call config_fdir to release the strings 
1476				 
1476				; c = number items 
1476			 
1476				 
1476 cd ba 03			call storage_get_block_0 
1479			 
1479 21 e8 f9			ld hl, store_page     ; get current id count 
147c 46				ld b, (hl) 
147d 0e 00			ld c, 0    ; count of files   
147f			 
147f			 
147f 21 a3 ef			ld hl, scratch 
1482 22 e4 f9			ld (store_tmp2), hl    ; location to poke strings 
1485			 
1485				; check for empty drive 
1485			 
1485 3e 00			ld a, 0 
1487 b8				cp b 
1488 ca 22 15			jp z, .dirdone 
148b			 
148b				 
148b					if DEBUG_FORTH_WORDS 
148b						DMARK "Cdc" 
148b f5				push af  
148c 3a a0 14			ld a, (.dmark)  
148f 32 bd fb			ld (debug_mark),a  
1492 3a a1 14			ld a, (.dmark+1)  
1495 32 be fb			ld (debug_mark+1),a  
1498 3a a2 14			ld a, (.dmark+2)  
149b 32 bf fb			ld (debug_mark+2),a  
149e 18 03			jr .pastdmark  
14a0 ..			.dmark: db "Cdc"  
14a3 f1			.pastdmark: pop af  
14a4			endm  
# End of macro DMARK
14a4						CALLMONITOR 
14a4 cd 6a 16			call break_point_state  
14a7				endm  
# End of macro CALLMONITOR
14a7					endif 
14a7			 
14a7			 
14a7			.diritem:	 
14a7 c5				push bc 
14a8				; for each of the current ids do a search for them and if found push to stack 
14a8			 
14a8 21 40 00				ld hl, STORE_BLOCK_PHY 
14ab 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
14ad 58					ld e,b 
14ae			 
14ae cd 2a 06				call storage_findnextid 
14b1			 
14b1			 
14b1					; if found hl will be non zero 
14b1			 
14b1 cd 2f 0d				call ishlzero 
14b4 28 69				jr z, .dirnotfound 
14b6			 
14b6					; increase count 
14b6			 
14b6 c1					pop bc	 
14b7 0c					inc c 
14b8 c5					push bc 
14b9					 
14b9			 
14b9					; get file header and push the file name 
14b9			 
14b9 11 e8 f9				ld de, store_page 
14bc cd 09 03				call storage_read_block 
14bf			 
14bf					; push file id to stack 
14bf				 
14bf 3a e8 f9				ld a, (store_page) 
14c2 26 00				ld h, 0 
14c4 6f					ld l, a 
14c5			 
14c5					;call forth_push_numhl 
14c5					; TODO store id 
14c5			 
14c5 e5					push hl 
14c6			 
14c6					; push extent count to stack  
14c6				 
14c6 21 eb f9				ld hl, store_page+3 
14c9			 
14c9					; get file name length 
14c9			 
14c9 cd 64 11				call strlenz   
14cc			 
14cc 23					inc hl   ; cover zero term 
14cd 23					inc hl  ; stick the id at the end of the area 
14ce			 
14ce e5					push hl 
14cf c1					pop bc    ; move length to bc 
14d0			 
14d0 cd cd 11				call malloc 
14d3			 
14d3					; TODO save malloc area to scratch 
14d3			 
14d3 eb					ex de, hl 
14d4 2a e4 f9				ld hl, (store_tmp2) 
14d7 73					ld (hl), e 
14d8 23					inc hl 
14d9 72					ld (hl), d 
14da 23					inc hl 
14db 22 e4 f9				ld (store_tmp2), hl 
14de			 
14de					 
14de			 
14de					;pop hl   ; get source 
14de			;		ex de, hl    ; swap aronund	 
14de			 
14de 21 eb f9				ld hl, store_page+3 
14e1					if DEBUG_FORTH_WORDS 
14e1						DMARK "CFd" 
14e1 f5				push af  
14e2 3a f6 14			ld a, (.dmark)  
14e5 32 bd fb			ld (debug_mark),a  
14e8 3a f7 14			ld a, (.dmark+1)  
14eb 32 be fb			ld (debug_mark+1),a  
14ee 3a f8 14			ld a, (.dmark+2)  
14f1 32 bf fb			ld (debug_mark+2),a  
14f4 18 03			jr .pastdmark  
14f6 ..			.dmark: db "CFd"  
14f9 f1			.pastdmark: pop af  
14fa			endm  
# End of macro DMARK
14fa						CALLMONITOR 
14fa cd 6a 16			call break_point_state  
14fd				endm  
# End of macro CALLMONITOR
14fd					endif 
14fd ed b0				ldir 
14ff			 
14ff					; de is past string, move back one and store id 
14ff					 
14ff 1b					dec de 
1500			 
1500					; store file id 
1500			 
1500 e1					pop hl 
1501 eb					ex de,hl 
1502 73					ld (hl), e 
1503			 
1503					if DEBUG_FORTH_WORDS 
1503						DMARK "Cdi" 
1503 f5				push af  
1504 3a 18 15			ld a, (.dmark)  
1507 32 bd fb			ld (debug_mark),a  
150a 3a 19 15			ld a, (.dmark+1)  
150d 32 be fb			ld (debug_mark+1),a  
1510 3a 1a 15			ld a, (.dmark+2)  
1513 32 bf fb			ld (debug_mark+2),a  
1516 18 03			jr .pastdmark  
1518 ..			.dmark: db "Cdi"  
151b f1			.pastdmark: pop af  
151c			endm  
# End of macro DMARK
151c						CALLMONITOR 
151c cd 6a 16			call break_point_state  
151f				endm  
# End of macro CALLMONITOR
151f					endif 
151f					 
151f			.dirnotfound: 
151f c1					pop bc     
1520 10 85				djnz .diritem 
1522				 
1522			.dirdone:	 
1522			 
1522 3e 00				ld a, 0 
1524 2a e4 f9				ld hl, (store_tmp2) 
1527 77					ld (hl), a 
1528 23					inc hl 
1529 77					ld (hl), a 
152a 23					inc hl 
152b					; push a count of the dir items found 
152b			 
152b			;		ld h, 0 
152b			;		ld l, c 
152b			 
152b c9				ret 
152c			 
152c			endif 
152c			 
152c			 
152c			; Settings 
152c			; Run  
152c			 
152c			 
152c			 
152c			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
152c			;;hd_menu2:   db "        2: Editor",0   
152c			;hd_menu2:   db "        2: Editor       6: Menu",0   
152c			;hd_menu3:   db "        3: Storage",0 
152c			;hd_menu4:   db "0=quit  4: Debug",0 
152c			;hd_don:     db "ON",0 
152c			;hd_doff:     db "OFF",0 
152c			; 
152c			; 
152c			; 
152c			;hardware_diags_old:       
152c			; 
152c			;.diagmenu: 
152c			;	call clear_display 
152c			;	ld a, display_row_1 
152c			;	ld de, hd_menu1 
152c			;	call str_at_display 
152c			; 
152c			;	ld a, display_row_2 
152c			;	ld de, hd_menu2 
152c			;	call str_at_display 
152c			; 
152c			;	ld a, display_row_3 
152c			;	ld de, hd_menu3 
152c			;	call str_at_display 
152c			; 
152c			;	ld a,  display_row_4 
152c			;	ld de, hd_menu4 
152c			;	call str_at_display 
152c			; 
152c			;	; display debug state 
152c			; 
152c			;	ld de, hd_don 
152c			;	ld a, (os_view_disable) 
152c			;	cp 0 
152c			;	jr z, .distog 
152c			;	ld de, hd_doff 
152c			;.distog: ld a, display_row_4+17 
152c			;	call str_at_display 
152c			; 
152c			;	call update_display 
152c			; 
152c			;	call cin_wait 
152c			; 
152c			; 
152c			; 
152c			;	cp '4' 
152c			;	jr nz, .diagn1 
152c			; 
152c			;	; debug toggle 
152c			; 
152c			;	ld a, (os_view_disable) 
152c			;	ld b, '*' 
152c			;	cp 0 
152c			;	jr z, .debtog 
152c			;	ld b, 0 
152c			;.debtog:	 
152c			;	ld a,b 
152c			;	ld (os_view_disable),a 
152c			; 
152c			;.diagn1: cp '0' 
152c			;	 ret z 
152c			; 
152c			;;	cp '1' 
152c			;;       jp z, matrix	 
152c			;;   TODO keyboard matrix test 
152c			; 
152c			;	cp '2' 
152c			;	jp z, .diagedit 
152c			; 
152c			;;	cp '6' 
152c			;;	jp z, .menutest 
152c			;;if ENABLE_BASIC 
152c			;;	cp '6' 
152c			;;	jp z, basic 
152c			;;endif 
152c			 ; 
152c			;	jp .diagmenu 
152c			; 
152c			; 
152c			;	ret 
152c			 
152c			 
152c			.debug_tog: 
152c 21 73 15			ld hl, .menudebug 
152f				 
152f 3a 94 ef			ld a, (os_view_disable) 
1532 fe 2a			cp '*' 
1534 20 04			jr nz,.tdon  
1536 3e 01			ld a, 1 
1538 18 02			jr .tog1 
153a 3e 00		.tdon: ld a, 0 
153c			 
153c			.tog1: 
153c cd 03 0b			call menu 
153f fe 00			cp 0 
1541 c8				ret z 
1542 fe 01			cp 1    ; disable debug 
1544 28 04			jr z, .dtog0 
1546 3e 2a			ld a, '*' 
1548 18 02			jr .dtogset 
154a 3e 00		.dtog0: ld a, 0 
154c 32 94 ef		.dtogset:  ld (os_view_disable), a 
154f c3 2c 15			jp .debug_tog 
1552			 
1552			 
1552			hardware_diags:       
1552			 
1552			.diagm: 
1552 21 65 15			ld hl, .menuitems 
1555 3e 00			ld a, 0 
1557 cd 03 0b			call menu 
155a			 
155a fe 00		         cp 0 
155c c8				 ret z 
155d			 
155d fe 02			cp 2 
155f ca be 15			jp z, .diagedit 
1562			 
1562			;	cp '6' 
1562			;	jp z, .menutest 
1562			;if ENABLE_BASIC 
1562			;	cp '6' 
1562			;	jp z, basic 
1562			;endif 
1562			  
1562 c3 52 15			jp .diagm 
1565			 
1565				 
1565 79 15		.menuitems:   	dw .m1 
1567 84 15				dw .m2 
1569 8b 15				dw .m3 
156b 93 15				dw .m5 
156d 99 15				dw .m5a 
156f a2 15				dw .m5b 
1571 00 00				dw 0 
1573			 
1573			.menudebug: 
1573 ab 15				dw .m6 
1575 b4 15				dw .m7 
1577 00 00				dw 0 
1579			 
1579 .. 00		.m1:   db "Key Matrix",0 
1584 .. 00		.m2:   db "Editor",0 
158b .. 00		.m3:   db "Storage",0 
1593 .. 00		.m5:   db "Sound",0 
1599 .. 00		.m5a:  db "RAM Test",0 
15a2 .. 00		.m5b:  db "LCD Test",0 
15ab			 
15ab .. 00		.m6:   db "Debug ON",0 
15b4 .. 00		.m7:   db "Debug OFF",0 
15be			 
15be			; debug editor 
15be			 
15be			.diagedit: 
15be			 
15be 21 a3 ef			ld hl, scratch 
15c1			;	ld bc, 250 
15c1			;	ldir 
15c1				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
15c1 3e 00			ld a, 0 
15c3 77				ld (hl), a 
15c4 23				inc hl 
15c5 77				ld (hl), a 
15c6 23				inc hl 
15c7 77				ld (hl), a 
15c8			 
15c8 cd d2 0a		        call clear_display 
15cb cd f5 0a			call update_display 
15ce 3e 01			ld a, 1 
15d0 32 c3 fb			ld (hardware_diag), a 
15d3			.diloop: 
15d3 3e 00			ld a, display_row_1 
15d5 0e 00			ld c, 0 
15d7 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
15d9 1e 28			ld e, 40 
15db			 
15db 21 a3 ef			ld hl, scratch	 
15de cd 33 0d			call input_str 
15e1			 
15e1 3e 14			ld a, display_row_2 
15e3 11 a3 ef			ld de, scratch 
15e6 cd e5 0a			call str_at_display 
15e9 cd f5 0a			call update_display 
15ec			 
15ec c3 d3 15			jp .diloop 
15ef			 
15ef			 
15ef			; pass word in hl 
15ef			; a has display location 
15ef			display_word_at: 
15ef f5				push af 
15f0 e5				push hl 
15f1 7c				ld a,h 
15f2 21 a8 f2			ld hl, os_word_scratch 
15f5 cd 07 10			call hexout 
15f8 e1				pop hl 
15f9 7d				ld a,l 
15fa 21 aa f2			ld hl, os_word_scratch+2 
15fd cd 07 10			call hexout 
1600 21 ac f2			ld hl, os_word_scratch+4 
1603 3e 00			ld a,0 
1605 77				ld (hl),a 
1606 11 a8 f2			ld de,os_word_scratch 
1609 f1				pop af 
160a cd e5 0a				call str_at_display 
160d c9				ret 
160e			 
160e			display_ptr_state: 
160e			 
160e				; to restore afterwards 
160e			 
160e d5				push de 
160f c5				push bc 
1610 e5				push hl 
1611 f5				push af 
1612			 
1612				; for use in here 
1612			 
1612			;	push bc 
1612			;	push de 
1612			;	push hl 
1612			;	push af 
1612			 
1612 cd d2 0a			call clear_display 
1615			 
1615 11 e8 17			ld de, .ptrstate 
1618 3e 00			ld a, display_row_1 
161a cd e5 0a			call str_at_display 
161d			 
161d				; display debug step 
161d			 
161d			 
161d 11 bd fb			ld de, debug_mark 
1620 3e 12			ld a, display_row_1+display_cols-2 
1622 cd e5 0a			call str_at_display 
1625			 
1625				; display a 
1625 11 f2 17			ld de, .ptrcliptr 
1628 3e 14			ld a, display_row_2 
162a cd e5 0a			call str_at_display 
162d			 
162d f1				pop af 
162e 2a ae f9			ld hl,(cli_ptr) 
1631 3e 1c			ld a, display_row_2+8 
1633 cd ef 15			call display_word_at 
1636			 
1636			 
1636				; display hl 
1636			 
1636			 
1636 11 fa 17			ld de, .ptrclioptr 
1639 3e 1e			ld a, display_row_2+10 
163b cd e5 0a			call str_at_display 
163e			; 
163e			;	pop hl 
163e 3e 21			ld a, display_row_2+13 
1640 2a ac f9			ld hl,(cli_origptr) 
1643 cd ef 15			call display_word_at 
1646			; 
1646			;	 
1646			;	; display de 
1646			 
1646			;	ld de, .regstatede 
1646			;	ld a, display_row_3 
1646			;	call str_at_display 
1646			 
1646			;	pop de 
1646			;	ld h,d 
1646			;	ld l, e 
1646			;	ld a, display_row_3+3 
1646			;	call display_word_at 
1646			 
1646			 
1646				; display bc 
1646			 
1646			;	ld de, .regstatebc 
1646			;	ld a, display_row_3+10 
1646			;	call str_at_display 
1646			 
1646			;	pop bc 
1646			;	ld h,b 
1646			;	ld l, c 
1646			;	ld a, display_row_3+13 
1646			;	call display_word_at 
1646			 
1646			 
1646				; display dsp 
1646			 
1646			;	ld de, .regstatedsp 
1646			;	ld a, display_row_4 
1646			;	call str_at_display 
1646			 
1646				 
1646			;	ld hl,(cli_data_sp) 
1646			;	ld a, display_row_4+4 
1646			;	call display_word_at 
1646			 
1646				; display rsp 
1646			 
1646 11 29 18			ld de, .regstatersp 
1649 3e 46			ld a, display_row_4+10 
164b cd e5 0a			call str_at_display 
164e			 
164e				 
164e 2a 94 f9			ld hl,(cli_ret_sp) 
1651 3e 4a			ld a, display_row_4+14 
1653 cd ef 15			call display_word_at 
1656			 
1656 cd f5 0a			call update_display 
1659			 
1659 cd 52 0a			call delay1s 
165c cd 52 0a			call delay1s 
165f cd 52 0a			call delay1s 
1662			 
1662			 
1662 cd 6f 1b			call next_page_prompt 
1665			 
1665				; restore  
1665			 
1665 f1				pop af 
1666 e1				pop hl 
1667 c1				pop bc 
1668 d1				pop de 
1669 c9				ret 
166a			 
166a			break_point_state: 
166a f5				push af 
166b			 
166b				; see if disabled 
166b			 
166b 3a 94 ef			ld a, (os_view_disable) 
166e fe 2a			cp '*' 
1670 20 02			jr nz, .bpsgo 
1672 f1				pop af 
1673 c9				ret 
1674			 
1674			.bpsgo: 
1674 f1				pop af 
1675 f5				push af 
1676 22 90 ef			ld (os_view_hl), hl 
1679 ed 53 8e ef		ld (os_view_de), de 
167d ed 43 8c ef		ld (os_view_bc), bc 
1681 e5				push hl 
1682 6f				ld l, a 
1683 26 00			ld h, 0 
1685 22 92 ef			ld (os_view_af),hl 
1688			 
1688 21 53 fb				ld hl, display_fb0 
168b 22 5e fa				ld (display_fb_active), hl 
168e e1				pop hl	 
168f			 
168f 3e 31			ld a, '1' 
1691 fe 2a		.bps1:  cp '*' 
1693 20 03			jr nz, .bps1b 
1695 32 94 ef			ld (os_view_disable),a 
1698 fe 31		.bps1b:  cp '1' 
169a 20 14			jr nz, .bps2 
169c			 
169c				; display reg 
169c			 
169c				 
169c			 
169c 3a 92 ef			ld a, (os_view_af) 
169f 2a 90 ef			ld hl, (os_view_hl) 
16a2 ed 5b 8e ef		ld de, (os_view_de) 
16a6 ed 4b 8c ef		ld bc, (os_view_bc) 
16aa cd 44 17			call display_reg_state 
16ad c3 30 17			jp .bpschk 
16b0			 
16b0 fe 32		.bps2:  cp '2' 
16b2 20 08			jr nz, .bps3 
16b4				 
16b4				; display hl 
16b4 2a 90 ef			ld hl, (os_view_hl) 
16b7 cd 2e 18			call display_dump_at_hl 
16ba			 
16ba 18 74			jr .bpschk 
16bc			 
16bc fe 33		.bps3:  cp '3' 
16be 20 08			jr nz, .bps4 
16c0			 
16c0			        ; display de 
16c0 2a 8e ef			ld hl, (os_view_de) 
16c3 cd 2e 18			call display_dump_at_hl 
16c6			 
16c6 18 68			jr .bpschk 
16c8 fe 34		.bps4:  cp '4' 
16ca 20 08			jr nz, .bps5 
16cc			 
16cc			        ; display bc 
16cc 2a 8c ef			ld hl, (os_view_bc) 
16cf cd 2e 18			call display_dump_at_hl 
16d2			 
16d2 18 5c			jr .bpschk 
16d4 fe 35		.bps5:  cp '5' 
16d6 20 08		        jr nz, .bps7 
16d8			 
16d8				; display cur ptr 
16d8 2a ae f9			ld hl, (cli_ptr) 
16db cd 2e 18			call display_dump_at_hl 
16de			 
16de 18 50			jr .bpschk 
16e0 fe 36		.bps7:  cp '6' 
16e2 20 08			jr nz, .bps8b 
16e4				 
16e4				; display cur orig ptr 
16e4 2a ac f9			ld hl, (cli_origptr) 
16e7 cd 2e 18			call display_dump_at_hl 
16ea 18 44			jr .bpschk 
16ec fe 37		.bps8b:  cp '7' 
16ee 20 08			jr nz, .bps9 
16f0				 
16f0				; display dsp 
16f0 2a 90 f9			ld hl, (cli_data_sp) 
16f3 cd 2e 18			call display_dump_at_hl 
16f6			 
16f6 18 38			jr .bpschk 
16f8 fe 39		.bps9:  cp '9' 
16fa 20 05			jr nz, .bps8c 
16fc				 
16fc				; display SP 
16fc			;	ld hl, sp 
16fc cd 2e 18			call display_dump_at_hl 
16ff			 
16ff 18 2f			jr .bpschk 
1701 fe 38		.bps8c:  cp '8' 
1703 20 08			jr nz, .bps8d 
1705				 
1705				; display rsp 
1705 2a 94 f9			ld hl, (cli_ret_sp) 
1708 cd 2e 18			call display_dump_at_hl 
170b			 
170b 18 23			jr .bpschk 
170d fe 23		.bps8d:  cp '#'     ; access monitor sub system 
170f 20 05			jr nz, .bps8 
1711 cd 65 19			call monitor 
1714			 
1714 18 1a			jr .bpschk 
1716 fe 30		.bps8:  cp '0' 
1718 20 16			jr nz, .bpschk 
171a			 
171a 21 02 fb				ld hl, display_fb1 
171d 22 5e fa				ld (display_fb_active), hl 
1720 cd f5 0a				call update_display 
1723			 
1723				;ld a, (os_view_af) 
1723 2a 90 ef			ld hl, (os_view_hl) 
1726 ed 5b 8e ef		ld de, (os_view_de) 
172a ed 4b 8c ef		ld bc, (os_view_bc) 
172e f1				pop af 
172f c9				ret 
1730			 
1730			.bpschk:   
1730 cd 52 0a			call delay1s 
1733 3e 4f		ld a,display_row_4 + display_cols - 1 
1735 11 6d 1b		        ld de, endprg 
1738 cd e5 0a			call str_at_display 
173b cd f5 0a			call update_display 
173e cd 49 66			call cin_wait 
1741			 
1741 c3 91 16			jp .bps1 
1744			 
1744			 
1744			display_reg_state: 
1744			 
1744				; to restore afterwards 
1744			 
1744 d5				push de 
1745 c5				push bc 
1746 e5				push hl 
1747 f5				push af 
1748			 
1748				; for use in here 
1748			 
1748 c5				push bc 
1749 d5				push de 
174a e5				push hl 
174b f5				push af 
174c			 
174c cd d2 0a			call clear_display 
174f			 
174f 11 04 18			ld de, .regstate 
1752 3e 00			ld a, display_row_1 
1754 cd e5 0a			call str_at_display 
1757			 
1757				; display debug step 
1757			 
1757			 
1757 11 bd fb			ld de, debug_mark 
175a 3e 11			ld a, display_row_1+display_cols-3 
175c cd e5 0a			call str_at_display 
175f			 
175f				; display a 
175f 11 20 18			ld de, .regstatea 
1762 3e 14			ld a, display_row_2 
1764 cd e5 0a			call str_at_display 
1767			 
1767 e1				pop hl 
1768			;	ld h,0 
1768			;	ld l, a 
1768 3e 17			ld a, display_row_2+3 
176a cd ef 15			call display_word_at 
176d			 
176d			 
176d				; display hl 
176d			 
176d			 
176d 11 14 18			ld de, .regstatehl 
1770 3e 1e			ld a, display_row_2+10 
1772 cd e5 0a			call str_at_display 
1775			 
1775 e1				pop hl 
1776 3e 21			ld a, display_row_2+13 
1778 cd ef 15			call display_word_at 
177b			 
177b				 
177b				; display de 
177b			 
177b 11 18 18			ld de, .regstatede 
177e 3e 28			ld a, display_row_3 
1780 cd e5 0a			call str_at_display 
1783			 
1783 e1				pop hl 
1784			;	ld h,d 
1784			;	ld l, e 
1784 3e 2b			ld a, display_row_3+3 
1786 cd ef 15			call display_word_at 
1789			 
1789			 
1789				; display bc 
1789			 
1789 11 1c 18			ld de, .regstatebc 
178c 3e 32			ld a, display_row_3+10 
178e cd e5 0a			call str_at_display 
1791			 
1791 e1				pop hl 
1792			;	ld h,b 
1792			;	ld l, c 
1792 3e 35			ld a, display_row_3+13 
1794 cd ef 15			call display_word_at 
1797			 
1797			 
1797				; display dsp 
1797			 
1797 11 24 18			ld de, .regstatedsp 
179a 3e 3c			ld a, display_row_4 
179c cd e5 0a			call str_at_display 
179f			 
179f				 
179f 2a 90 f9			ld hl,(cli_data_sp) 
17a2 3e 40			ld a, display_row_4+4 
17a4 cd ef 15			call display_word_at 
17a7			 
17a7				; display rsp 
17a7			 
17a7 11 29 18			ld de, .regstatersp 
17aa 3e 46			ld a, display_row_4+10 
17ac cd e5 0a			call str_at_display 
17af			 
17af				 
17af 2a 94 f9			ld hl,(cli_ret_sp) 
17b2 3e 4a			ld a, display_row_4+14 
17b4 cd ef 15			call display_word_at 
17b7			 
17b7 cd f5 0a			call update_display 
17ba			 
17ba			;	call delay1s 
17ba			;	call delay1s 
17ba			;	call delay1s 
17ba			 
17ba			 
17ba			;	call next_page_prompt 
17ba			 
17ba				; restore  
17ba			 
17ba f1				pop af 
17bb e1				pop hl 
17bc c1				pop bc 
17bd d1				pop de 
17be c9				ret 
17bf			 
17bf .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
17d3 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
17e8 .. 00		.ptrstate:	db "Ptr State",0 
17f2 .. 00		.ptrcliptr:     db "cli_ptr",0 
17fa .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1804 .. 00		.regstate:	db "Reg State (1/0)",0 
1814 .. 00		.regstatehl:	db "HL:",0 
1818 .. 00		.regstatede:	db "DE:",0 
181c .. 00		.regstatebc:	db "BC:",0 
1820 .. 00		.regstatea:	db "A :",0 
1824 .. 00		.regstatedsp:	db "DSP:",0 
1829 .. 00		.regstatersp:	db "RSP:",0 
182e			 
182e			display_dump_at_hl: 
182e e5				push hl 
182f d5				push de 
1830 c5				push bc 
1831 f5				push af 
1832			 
1832 22 c6 f2			ld (os_cur_ptr),hl	 
1835 cd d2 0a			call clear_display 
1838 cd 77 1a			call dumpcont 
183b			;	call delay1s 
183b			;	call next_page_prompt 
183b			 
183b			 
183b f1				pop af 
183c c1				pop bc 
183d d1				pop de 
183e e1				pop hl 
183f c9				ret 
1840			 
1840			;if ENABLE_BASIC 
1840			;	include "nascombasic.asm" 
1840			;	basic: 
1840			;	include "forth/FORTH.ASM" 
1840			;endif 
1840			 
1840			; eof 
1840			 
1840			 
# End of file firmware_diags.asm
1840			  
1840			  
1840			  
1840			  
1840			; eof  
1840			  
# End of file firmware.asm
1840			 
1840			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1840			;if BASE_KEV  
1840			;baseram: equ 08000h 
1840			;endif 
1840			 
1840			;if BASE_SC114 
1840			;baseram:     equ    endofcode 
1840			;endif 
1840			 
1840			 
1840			; start system 
1840			 
1840			coldstart: 
1840				; set sp 
1840				; di/ei 
1840			 
1840 f3				di 
1841 31 fd ff			ld sp, tos 
1844			;	ei 
1844			 
1844			 
1844				; disable breakpoint by default 
1844			 
1844 3e 2a			ld a,'*' 
1846 32 94 ef			ld (os_view_disable),a 
1849			 
1849				; init hardware 
1849			 
1849				; init keyboard and screen hardware 
1849			 
1849 cd 03 00			call hardware_init 
184c			 
184c			 
184c				; detect if any keys are held down to enable breakpoints at start up 
184c			 
184c cd 5a 66			call cin  
184f fe 00			cp 0 
1851 28 03			jr z, .nokeys 
1853			 
1853				;call hardware_diags 
1853 cd 66 13			call config 
1856			 
1856			;	ld de, .bpen 
1856			;	ld a, display_row_4 
1856			;	call str_at_display 
1856			;	call update_display 
1856			; 
1856			;	ld a,0 
1856			;	ld (os_view_disable),a 
1856			; 
1856			;.bpwait: 
1856			;	call cin 
1856			;	cp 0 
1856			;	jr z, .bpwait 
1856			;	jr .nokeys 
1856			; 
1856			; 
1856			;.bpen:  db "Break points enabled!",0 
1856			 
1856			 
1856			 
1856			 
1856			 
1856			 
1856			.nokeys: 
1856			 
1856			 
1856				 
1856			 
1856			;jp  testkey 
1856			 
1856			;call storage_get_block_0 
1856			; 
1856			;ld hl, 0 
1856			;ld de, store_page 
1856			;call storage_read_block 
1856			 
1856				 
1856			;ld hl, 10 
1856			;ld de, store_page 
1856			;call storage_read_block 
1856			 
1856			 
1856			 
1856			 
1856			 
1856			;stop:	nop 
1856			;	jp stop 
1856			 
1856			 
1856			 
1856			main: 
1856 cd d2 0a			call clear_display 
1859 cd f5 0a			call update_display 
185c			 
185c			 
185c			 
185c			;	call testlcd 
185c			 
185c			 
185c			 
185c cd 35 1f			call forth_init 
185f			 
185f			 
185f			warmstart: 
185f cd 0b 1f			call forth_warmstart 
1862			 
1862				; run startup word load 
1862			        ; TODO prevent this running at warmstart after crash  
1862			 
1862				if STARTUP_ENABLE 
1862 cd c3 61				call forth_startup 
1865				endif 
1865			 
1865				; show free memory after boot 
1865 11 ff 18			ld de, freeram 
1868 3e 00			ld a, display_row_1 
186a cd e5 0a			call str_at_display 
186d			 
186d			; Or use heap_size word???? 
186d 21 89 ef			ld hl, heap_end 
1870 11 0e 80			ld de, heap_start 
1873 ed 52			sbc hl, de 
1875 e5				push hl 
1876 7c				ld a,h	         	 
1877 21 a8 f2			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
187a cd 07 10			call hexout 
187d e1			   	pop hl 
187e			 
187e 7d				ld a,l 
187f 21 aa f2			ld hl, os_word_scratch+2 
1882 cd 07 10			call hexout 
1885 21 ac f2			ld hl, os_word_scratch+4 
1888 3e 00			ld a, 0 
188a 77				ld (hl),a 
188b 11 a8 f2			ld de, os_word_scratch 
188e 3e 0d			ld a, display_row_1 + 13 
1890 cd e5 0a			call str_at_display 
1893 cd f5 0a			call update_display 
1896			 
1896			 
1896				;call demo 
1896			 
1896			 
1896				; init scratch input area for cli commands 
1896			 
1896 21 ca f2			ld hl, os_cli_cmd 
1899 3e 00			ld a,0 
189b 77				ld (hl),a 
189c 23				inc hl 
189d 77				ld (hl),a 
189e			 
189e 3e 00			ld a,0 
18a0 32 c9 f3			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
18a3			 
18a3 32 c6 f2			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
18a6 32 c7 f2			ld (os_cur_ptr+1),a	 
18a9			 
18a9 32 a8 f2			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
18ac 32 a9 f2			ld (os_word_scratch+1),a	 
18af				 
18af			 
18af				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18af 21 ca f2			ld hl, os_cli_cmd 
18b2			 
18b2 3e 00			ld a, 0		 ; init cli input 
18b4 77				ld (hl), a 
18b5 3e 14			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18b7			cli: 
18b7				; show cli prompt 
18b7				;push af 
18b7				;ld a, 0 
18b7				;ld de, prompt 
18b7				;call str_at_display 
18b7			 
18b7				;call update_display 
18b7				;pop af 
18b7				;inc a 
18b7				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18b7 0e 00			ld c, 0 
18b9 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18bb 1e 28			ld e, 40 
18bd			 
18bd 21 ca f2			ld hl, os_cli_cmd 
18c0			 
18c0				STACKFRAME OFF $fefe $9f9f 
18c0				if DEBUG_STACK_IMB 
18c0					if OFF 
18c0						exx 
18c0						ld de, $fefe 
18c0						ld a, d 
18c0						ld hl, curframe 
18c0						call hexout 
18c0						ld a, e 
18c0						ld hl, curframe+2 
18c0						call hexout 
18c0						ld hl, $fefe 
18c0						push hl 
18c0						ld hl, $9f9f 
18c0						push hl 
18c0						exx 
18c0					endif 
18c0				endif 
18c0			endm 
# End of macro STACKFRAME
18c0			 
18c0 cd 33 0d			call input_str 
18c3			 
18c3				STACKFRAMECHK OFF $fefe $9f9f 
18c3				if DEBUG_STACK_IMB 
18c3					if OFF 
18c3						exx 
18c3						ld hl, $9f9f 
18c3						pop de   ; $9f9f 
18c3						call cmp16 
18c3						jr nz, .spnosame 
18c3						ld hl, $fefe 
18c3						pop de   ; $fefe 
18c3						call cmp16 
18c3						jr z, .spfrsame 
18c3						.spnosame: call showsperror 
18c3						.spfrsame: nop 
18c3						exx 
18c3					endif 
18c3				endif 
18c3			endm 
# End of macro STACKFRAMECHK
18c3			 
18c3				; copy input to last command 
18c3			 
18c3 21 ca f2			ld hl, os_cli_cmd 
18c6 11 c9 f3			ld de, os_last_cmd 
18c9 01 ff 00			ld bc, 255 
18cc ed b0			ldir 
18ce			 
18ce				; wipe current buffer 
18ce			 
18ce			;	ld a, 0 
18ce			;	ld hl, os_cli_cmd 
18ce			;	ld de, os_cli_cmd+1 
18ce			;	ld bc, 254 
18ce			;	ldir 
18ce				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18ce			;	call strcpy 
18ce			;	ld a, 0 
18ce			;	ld (hl), a 
18ce			;	inc hl 
18ce			;	ld (hl), a 
18ce			;	inc hl 
18ce			;	ld (hl), a 
18ce			 
18ce				; switch frame buffer to program  
18ce			 
18ce 21 02 fb				ld hl, display_fb1 
18d1 22 5e fa				ld (display_fb_active), hl 
18d4			 
18d4			;	nop 
18d4				STACKFRAME ON $fbfe $8f9f 
18d4				if DEBUG_STACK_IMB 
18d4					if ON 
18d4						exx 
18d4						ld de, $fbfe 
18d4						ld a, d 
18d4						ld hl, curframe 
18d4						call hexout 
18d4						ld a, e 
18d4						ld hl, curframe+2 
18d4						call hexout 
18d4						ld hl, $fbfe 
18d4						push hl 
18d4						ld hl, $8f9f 
18d4						push hl 
18d4						exx 
18d4					endif 
18d4				endif 
18d4			endm 
# End of macro STACKFRAME
18d4				; first time into the parser so pass over the current scratch pad 
18d4 21 ca f2			ld hl,os_cli_cmd 
18d7				; tokenise the entered statement(s) in HL 
18d7 cd ae 1f			call forthparse 
18da			        ; exec forth statements in top of return stack 
18da cd ee 1f			call forthexec 
18dd				;call forthexec_cleanup 
18dd			;	call parsenext 
18dd			 
18dd				STACKFRAMECHK ON $fbfe $8f9f 
18dd				if DEBUG_STACK_IMB 
18dd					if ON 
18dd						exx 
18dd						ld hl, $8f9f 
18dd						pop de   ; $8f9f 
18dd						call cmp16 
18dd						jr nz, .spnosame 
18dd						ld hl, $fbfe 
18dd						pop de   ; $fbfe 
18dd						call cmp16 
18dd						jr z, .spfrsame 
18dd						.spnosame: call showsperror 
18dd						.spfrsame: nop 
18dd						exx 
18dd					endif 
18dd				endif 
18dd			endm 
# End of macro STACKFRAMECHK
18dd				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
18dd			 
18dd 3e 3c			ld a, display_row_4 
18df 11 11 19			ld de, endprog 
18e2			 
18e2 cd f5 0a			call update_display		 
18e5			 
18e5 cd 6f 1b			call next_page_prompt 
18e8			 
18e8				; switch frame buffer to cli 
18e8			 
18e8 21 53 fb				ld hl, display_fb0 
18eb 22 5e fa				ld (display_fb_active), hl 
18ee			 
18ee			 
18ee cd d2 0a		        call clear_display 
18f1 cd f5 0a			call update_display		 
18f4			 
18f4 21 ca f2			ld hl, os_cli_cmd 
18f7			 
18f7 3e 00			ld a, 0		 ; init cli input 
18f9 77				ld (hl), a 
18fa			 
18fa				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
18fa			 
18fa				; now on last line 
18fa			 
18fa				; TODO scroll screen up 
18fa			 
18fa				; TODO instead just clear screen and place at top of screen 
18fa			 
18fa			;	ld a, 0 
18fa			;	ld (f_cursor_ptr),a 
18fa			 
18fa				;call clear_display 
18fa				;call update_display 
18fa			 
18fa				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18fa 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18fc c3 b7 18			jp cli 
18ff			 
18ff .. 00		freeram: db "Free bytes: $",0 
190d ..			asc: db "1A2F" 
1911 .. 00		endprog: db "End prog...",0 
191d			 
191d			testenter2:   
191d 21 d5 ef			ld hl,scratch+50 
1920 22 c6 f2			ld (os_cur_ptr),hl 
1923 c3 b7 18			jp cli 
1926			 
1926			testenter:  
1926			 
1926 21 0d 19			ld hl,asc 
1929			;	ld a,(hl) 
1929			;	call nibble2val 
1929 cd 5d 10			call get_byte 
192c			 
192c			 
192c			;	ld a,(hl) 
192c			;	call atohex 
192c			 
192c			;	call fourehexhl 
192c 32 d5 ef			ld (scratch+50),a 
192f			 
192f			 
192f			 
192f 21 0f 19			ld hl,asc+2 
1932			;	ld a, (hl) 
1932			;	call nibble2val 
1932 cd 5d 10			call get_byte 
1935			 
1935			;	call fourehexhl 
1935 32 d7 ef			ld (scratch+52),a 
1938				 
1938 21 d5 ef			ld hl,scratch+50 
193b 22 c6 f2			ld (os_cur_ptr),hl 
193e c3 b7 18			jp cli 
1941			 
1941			enter:	 
1941 3a a7 ef			ld a,(scratch+4) 
1944 fe 00			cp 0 
1946 28 0c			jr z, .entercont 
1948				; no, not a null term line so has an address to work out.... 
1948			 
1948 21 a5 ef			ld hl,scratch+2 
194b cd bd 10			call get_word_hl 
194e			 
194e 22 c6 f2			ld (os_cur_ptr),hl	 
1951 c3 b7 18			jp cli 
1954			 
1954			 
1954			.entercont:  
1954			 
1954 21 a5 ef			ld hl, scratch+2 
1957 cd 5d 10			call get_byte 
195a			 
195a 2a c6 f2		   	ld hl,(os_cur_ptr) 
195d 77					ld (hl),a 
195e 23					inc hl 
195f 22 c6 f2				ld (os_cur_ptr),hl 
1962				 
1962			; get byte  
1962			 
1962			 
1962 c3 b7 18			jp cli 
1965			 
1965			 
1965			; basic monitor support 
1965			 
1965			monitor: 
1965				;  
1965 cd d2 0a			call clear_display 
1968 3e 00			ld a, 0 
196a 11 b2 19			ld de, .monprompt 
196d cd e5 0a			call str_at_display 
1970 cd f5 0a			call update_display 
1973			 
1973				; get a monitor command 
1973			 
1973 0e 00			ld c, 0     ; entry at top left 
1975 16 64			ld d, 100   ; max buffer size 
1977 1e 0f			ld e, 15    ; input scroll area 
1979 3e 00			ld a, 0     ; init string 
197b 21 a1 f1			ld hl, os_input 
197e 77				ld (hl), a 
197f 23				inc hl 
1980 77				ld (hl), a 
1981 21 a1 f1			ld hl, os_input 
1984 3e 01			ld a, 1     ; init string 
1986 cd 33 0d			call input_str 
1989			 
1989 cd d2 0a		        call clear_display 
198c cd f5 0a			call update_display		 
198f			 
198f 3a a1 f1			ld a, (os_input) 
1992 cd 5b 11			call toUpper 
1995 fe 48		        cp 'H' 
1997 28 6f		        jr z, .monhelp 
1999 fe 44			cp 'D'		; dump 
199b ca 29 1a			jp z, .mondump	 
199e fe 43			cp 'C'		; dump 
19a0 ca 43 1a			jp z, .moncdump	 
19a3 fe 4d			cp 'M'		; dump 
19a5 ca b4 19			jp z, .moneditstart 
19a8 fe 55			cp 'U'		; dump 
19aa 28 14			jr z, .monedit	 
19ac fe 51			cp 'Q'		; dump 
19ae c8				ret z	 
19af			 
19af			 
19af				; TODO "S" to access symbol by name and not need the address 
19af				; TODO "F" to find a string in memory 
19af			 
19af c3 65 19			jp monitor 
19b2			 
19b2 .. 00		.monprompt: db ">", 0 
19b4			 
19b4			.moneditstart: 
19b4				; get starting address 
19b4			 
19b4 21 a3 f1			ld hl,os_input+2 
19b7 cd bd 10			call get_word_hl 
19ba			 
19ba 22 c6 f2			ld (os_cur_ptr),hl	 
19bd			 
19bd c3 65 19			jp monitor 
19c0			 
19c0			.monedit: 
19c0				; get byte to load 
19c0			 
19c0 21 a3 f1			ld hl,os_input+2 
19c3 cd 5d 10			call get_byte 
19c6			 
19c6				; get address to update 
19c6 2a c6 f2			ld hl, (os_cur_ptr) 
19c9			 
19c9				; update byte 
19c9			 
19c9 77				ld (hl), a 
19ca			 
19ca				; move to next address and save it 
19ca			 
19ca 23				inc hl 
19cb 22 c6 f2			ld (os_cur_ptr),hl	 
19ce			 
19ce c3 65 19			jp monitor 
19d1			 
19d1			 
19d1 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
19e5 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a01 .. 00		.monhelptext3:  db "Q-Quit",0 
1a08			        
1a08			.monhelp: 
1a08 3e 00			ld a, display_row_1 
1a0a 11 d1 19		        ld de, .monhelptext1 
1a0d			 
1a0d cd e5 0a			call str_at_display 
1a10 3e 14			ld a, display_row_2 
1a12 11 e5 19		        ld de, .monhelptext2 
1a15					 
1a15 cd e5 0a			call str_at_display 
1a18 3e 28			ld a, display_row_3 
1a1a 11 01 1a		        ld de, .monhelptext3 
1a1d					 
1a1d cd e5 0a			call str_at_display 
1a20 cd f5 0a			call update_display		 
1a23			 
1a23 cd 6f 1b			call next_page_prompt 
1a26 c3 65 19			jp monitor 
1a29			 
1a29			.mondump:    
1a29 21 a3 f1			ld hl,os_input+2 
1a2c cd bd 10			call get_word_hl 
1a2f			 
1a2f 22 c6 f2			ld (os_cur_ptr),hl	 
1a32 cd 77 1a			call dumpcont 
1a35 3e 3c			ld a, display_row_4 
1a37 11 11 19			ld de, endprog 
1a3a			 
1a3a cd f5 0a			call update_display		 
1a3d			 
1a3d cd 6f 1b			call next_page_prompt 
1a40 c3 65 19			jp monitor 
1a43			.moncdump: 
1a43 cd 77 1a			call dumpcont 
1a46 3e 3c			ld a, display_row_4 
1a48 11 11 19			ld de, endprog 
1a4b			 
1a4b cd f5 0a			call update_display		 
1a4e			 
1a4e cd 6f 1b			call next_page_prompt 
1a51 c3 65 19			jp monitor 
1a54			 
1a54			 
1a54			; TODO symbol access  
1a54			 
1a54			.symbols:     ;; A list of symbols that can be called up  
1a54 53 fb			dw display_fb0 
1a56 .. 00			db "fb0",0  
1a5a e8 f9		     	dw store_page 
1a5c .. 00			db "store_page",0 
1a67			 
1a67			 
1a67			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1a67			 
1a67 3a a4 ef			ld a,(scratch+1) 
1a6a fe 00			cp 0 
1a6c 28 09			jr z, dumpcont 
1a6e			 
1a6e				; no, not a null term line so has an address to work out.... 
1a6e			 
1a6e 21 a5 ef			ld hl,scratch+2 
1a71 cd bd 10			call get_word_hl 
1a74			 
1a74 22 c6 f2			ld (os_cur_ptr),hl	 
1a77			 
1a77			 
1a77			 
1a77			dumpcont: 
1a77			 
1a77				; dump bytes at ptr 
1a77			 
1a77			 
1a77 3e 00			ld a, display_row_1 
1a79 2a 5e fa			ld hl, (display_fb_active) 
1a7c cd 06 0d			call addatohl 
1a7f cd a7 1a			call .dumpbyterow 
1a82			 
1a82 3e 14			ld a, display_row_2 
1a84 2a 5e fa			ld hl, (display_fb_active) 
1a87 cd 06 0d			call addatohl 
1a8a cd a7 1a			call .dumpbyterow 
1a8d			 
1a8d			 
1a8d 3e 28			ld a, display_row_3 
1a8f 2a 5e fa			ld hl, (display_fb_active) 
1a92 cd 06 0d			call addatohl 
1a95 cd a7 1a			call .dumpbyterow 
1a98			 
1a98 3e 3c			ld a, display_row_4 
1a9a 2a 5e fa			ld hl, (display_fb_active) 
1a9d cd 06 0d			call addatohl 
1aa0 cd a7 1a			call .dumpbyterow 
1aa3			 
1aa3 cd f5 0a			call update_display 
1aa6			;		jp cli 
1aa6 c9				ret 
1aa7			 
1aa7			.dumpbyterow: 
1aa7			 
1aa7				;push af 
1aa7			 
1aa7 e5				push hl 
1aa8			 
1aa8				; calc where to poke the ascii 
1aa8			if display_cols == 20 
1aa8 3e 10			ld a, 16 
1aaa			else 
1aaa				ld a, 31 
1aaa			endif 
1aaa			 
1aaa cd 06 0d			call addatohl 
1aad 22 a8 f2			ld (os_word_scratch),hl  		; save pos for later 
1ab0			 
1ab0			 
1ab0			; display decoding address 
1ab0 2a c6 f2		   	ld hl,(os_cur_ptr) 
1ab3			 
1ab3 7c				ld a,h 
1ab4 e1				pop hl 
1ab5 e5				push hl 
1ab6			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ab6 cd 07 10			call hexout 
1ab9 2a c6 f2		   	ld hl,(os_cur_ptr) 
1abc			 
1abc 7d				ld a,l 
1abd e1				pop hl 
1abe 23				inc hl 
1abf 23				inc hl 
1ac0 e5				push hl 
1ac1			;	ld hl, os_word_scratch+2 
1ac1 cd 07 10			call hexout 
1ac4 e1				pop hl 
1ac5 23				inc hl 
1ac6 23				inc hl 
1ac7				;ld hl, os_word_scratch+4 
1ac7 3e 3a			ld a, ':' 
1ac9 77				ld (hl),a 
1aca 23				inc hl 
1acb				;ld a, 0 
1acb				;ld (hl),a 
1acb				;ld de, os_word_scratch 
1acb				;pop af 
1acb				;push af 
1acb			;		ld a, display_row_2 
1acb			;		call str_at_display 
1acb			;		call update_display 
1acb			 
1acb			 
1acb			;pop af 
1acb			;	add 5 
1acb			 
1acb			if display_cols == 20 
1acb 06 04			ld b, 4 
1acd			else 
1acd				ld b, 8 
1acd			endif	 
1acd			 
1acd			.dumpbyte: 
1acd c5				push bc 
1ace e5				push hl 
1acf			 
1acf			 
1acf 2a c6 f2		   	ld hl,(os_cur_ptr) 
1ad2 7e					ld a,(hl) 
1ad3			 
1ad3					; poke the ascii to display 
1ad3 2a a8 f2				ld hl,(os_word_scratch) 
1ad6 77					ld (hl),a 
1ad7 23					inc hl 
1ad8 22 a8 f2				ld (os_word_scratch),hl 
1adb			 
1adb					 
1adb			 
1adb			 
1adb e1					pop hl 
1adc e5					push hl 
1add			 
1add cd 07 10				call hexout 
1ae0			 
1ae0					 
1ae0 2a c6 f2		   	ld hl,(os_cur_ptr) 
1ae3 23				inc hl 
1ae4 22 c6 f2		   	ld (os_cur_ptr),hl 
1ae7			 
1ae7 e1					pop hl 
1ae8 23					inc hl 
1ae9 23					inc hl 
1aea 23					inc hl 
1aeb			 
1aeb			 
1aeb			 
1aeb					;ld a,0 
1aeb					;ld (os_word_scratch+2),a 
1aeb					;pop af 
1aeb					;push af 
1aeb			 
1aeb					;ld de, os_word_scratch 
1aeb					;call str_at_display 
1aeb			;		call update_display 
1aeb			;		pop af 
1aeb c1					pop bc 
1aec c6 03				add 3 
1aee 10 dd			djnz .dumpbyte 
1af0			 
1af0				 
1af0			 
1af0 c9				ret 
1af1			 
1af1			jump:	 
1af1			 
1af1 21 a5 ef			ld hl,scratch+2 
1af4 cd bd 10			call get_word_hl 
1af7				;ld hl,(scratch+2) 
1af7				;call fourehexhl 
1af7			 
1af7 22 c6 f2			ld (os_cur_ptr),hl	 
1afa			 
1afa e9				jp (hl) 
1afb			 
1afb			 
1afb			 
1afb			; TODO implement a basic monitor mode to start with 
1afb			 
1afb			 
1afb			 
1afb			 
1afb			 
1afb			 
1afb			 
1afb			 
1afb			 
1afb			; testing and demo code during development 
1afb			 
1afb			 
1afb .. 00		str1: db "Enter some text...",0 
1b0e .. 00		clear: db "                    ",0 
1b23			 
1b23			demo: 
1b23			 
1b23			 
1b23			 
1b23			;	call update_display 
1b23			 
1b23				; init scratch input area for testing 
1b23 21 a3 ef			ld hl, scratch	 
1b26 3e 00			ld a,0 
1b28 77				ld (hl),a 
1b29			 
1b29			 
1b29 3e 14		            LD   A, display_row_2 
1b2b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b2b 11 fb 1a		            LD   DE, str1 
1b2e cd e5 0a			call str_at_display 
1b31			 
1b31			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b31			cloop:	 
1b31 3e 28		            LD   A, display_row_3 
1b33			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b33 11 0e 1b		            LD   DE, clear 
1b36			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b36 cd e5 0a				call str_at_display 
1b39 3e 3c			ld a, display_row_4 
1b3b 11 6b 1b			ld de, prompt 
1b3e			 
1b3e cd e5 0a				call str_at_display 
1b41 cd f5 0a			call update_display 
1b44			 
1b44 3e 55			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1b46 16 0a			ld d, 10 
1b48 21 a3 ef			ld hl, scratch	 
1b4b cd 33 0d			call input_str 
1b4e			 
1b4e			;	call clear_display 
1b4e			;'	call update_display 
1b4e			 
1b4e 3e 00		            LD   A, display_row_1 
1b50			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b50 11 0e 1b		            LD   DE, clear 
1b53 cd e5 0a				call str_at_display 
1b56			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b56 3e 00		            LD   A, display_row_1 
1b58			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b58 11 a3 ef		            LD   DE, scratch 
1b5b			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b5b cd e5 0a				call str_at_display 
1b5e cd f5 0a			call update_display 
1b61			 
1b61 3e 00				ld a,0 
1b63 21 a3 ef			ld hl, scratch 
1b66 77				ld (hl),a 
1b67			 
1b67 00				nop 
1b68 c3 31 1b			jp cloop 
1b6b			 
1b6b			 
1b6b			 
1b6b			; OS Prompt 
1b6b			 
1b6b .. 00		prompt: db ">",0 
1b6d .. 00		endprg: db "?",0 
1b6f			 
1b6f			 
1b6f			; handy next page prompt 
1b6f			next_page_prompt: 
1b6f e5				push hl 
1b70 d5				push de 
1b71 f5				push af 
1b72 c5				push bc 
1b73			 
1b73 3e 4f			ld a,display_row_4 + display_cols - 1 
1b75 11 6d 1b		        ld de, endprg 
1b78 cd e5 0a			call str_at_display 
1b7b cd f5 0a			call update_display 
1b7e cd 49 66			call cin_wait 
1b81 c1				pop bc 
1b82 f1				pop af 
1b83 d1				pop de 
1b84 e1				pop hl 
1b85			 
1b85			 
1b85 c9				ret 
1b86			 
1b86			 
1b86			; forth parser 
1b86			 
1b86			; My forth kernel 
1b86			include "forth_kernel.asm" 
1b86			; 
1b86			; kernel to the forth OS 
1b86			 
1b86			DS_TYPE_STR: equ 1     ; string type 
1b86			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1b86			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1b86			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1b86			 
1b86			FORTH_PARSEV1: equ 0 
1b86			FORTH_PARSEV2: equ 0 
1b86			FORTH_PARSEV3: equ 0 
1b86			FORTH_PARSEV4: equ 0 
1b86			FORTH_PARSEV5: equ 1 
1b86			 
1b86			;if FORTH_PARSEV5 
1b86			;	FORTH_END_BUFFER: equ 0 
1b86			;else 
1b86			FORTH_END_BUFFER: equ 127 
1b86			;endif 
1b86			 
1b86			FORTH_TRUE: equ 1 
1b86			FORTH_FALSE: equ 0 
1b86			 
1b86			if FORTH_PARSEV4 
1b86			include "forth_stackops.asm" 
1b86			endif 
1b86			 
1b86			if FORTH_PARSEV5 
1b86			include "forth_stackopsv5.asm" 
1b86			 
1b86			; Stack operations for v5 parser on wards 
1b86			; * DATA stack 
1b86			; * LOOP stack 
1b86			; * RETURN stack 
1b86			 
1b86			 
1b86			 
1b86			FORTH_CHK_DSP_UNDER: macro 
1b86				push hl 
1b86				push de 
1b86				ld hl,(cli_data_sp) 
1b86				ld de, cli_data_stack 
1b86				call cmp16 
1b86				jp c, fault_dsp_under 
1b86				pop de 
1b86				pop hl 
1b86				endm 
1b86			 
1b86			 
1b86			FORTH_CHK_RSP_UNDER: macro 
1b86				push hl 
1b86				push de 
1b86				ld hl,(cli_ret_sp) 
1b86				ld de, cli_ret_stack 
1b86				call cmp16 
1b86				jp c, fault_rsp_under 
1b86				pop de 
1b86				pop hl 
1b86				endm 
1b86			 
1b86			FORTH_CHK_LOOP_UNDER: macro 
1b86				push hl 
1b86				push de 
1b86				ld hl,(cli_loop_sp) 
1b86				ld de, cli_loop_stack 
1b86				call cmp16 
1b86				jp c, fault_loop_under 
1b86				pop de 
1b86				pop hl 
1b86				endm 
1b86			 
1b86			FORTH_ERR_TOS_NOTSTR: macro 
1b86				; TOSO might need more for checks when used 
1b86				push af 
1b86				ld a,(hl) 
1b86				cp DS_TYPE_STR 
1b86				jp nz, type_faultn   
1b86				pop af 
1b86				endm 
1b86			 
1b86			FORTH_ERR_TOS_NOTNUM: macro 
1b86				push af 
1b86				ld a,(hl) 
1b86				cp DS_TYPE_INUM 
1b86				jp nz, type_faultn   
1b86				pop af 
1b86				endm 
1b86			 
1b86			 
1b86			; increase data stack pointer and save hl to it 
1b86				 
1b86			FORTH_DSP_NEXT: macro 
1b86				call macro_forth_dsp_next 
1b86				endm 
1b86			 
1b86			 
1b86			macro_forth_dsp_next: 
1b86				if DEBUG_FORTH_STACK_GUARD 
1b86 cd 8d 62				call check_stacks 
1b89				endif 
1b89 e5				push hl 
1b8a d5				push de 
1b8b eb				ex de,hl 
1b8c 2a 90 f9			ld hl,(cli_data_sp) 
1b8f 23				inc hl 
1b90 23				inc hl 
1b91			 
1b91			; PARSEV5 
1b91 23				inc hl 
1b92 22 90 f9			ld (cli_data_sp),hl 
1b95 73				ld (hl), e 
1b96 23				inc hl 
1b97 72				ld (hl), d 
1b98 d1				pop de 
1b99 e1				pop hl 
1b9a				if DEBUG_FORTH_STACK_GUARD 
1b9a cd 8d 62				call check_stacks 
1b9d				endif 
1b9d c9				ret 
1b9e			 
1b9e			 
1b9e			; increase ret stack pointer and save hl to it 
1b9e				 
1b9e			FORTH_RSP_NEXT: macro 
1b9e				call macro_forth_rsp_next 
1b9e				endm 
1b9e			 
1b9e			macro_forth_rsp_next: 
1b9e				if DEBUG_FORTH_STACK_GUARD 
1b9e cd 8d 62				call check_stacks 
1ba1				endif 
1ba1 e5				push hl 
1ba2 d5				push de 
1ba3 eb				ex de,hl 
1ba4 2a 94 f9			ld hl,(cli_ret_sp) 
1ba7 23				inc hl 
1ba8 23				inc hl 
1ba9 22 94 f9			ld (cli_ret_sp),hl 
1bac 73				ld (hl), e 
1bad 23				inc hl 
1bae 72				ld (hl), d 
1baf d1				pop de 
1bb0 e1				pop hl 
1bb1				if DEBUG_FORTH_STACK_GUARD 
1bb1 cd 8d 62				call check_stacks 
1bb4				endif 
1bb4 c9				ret 
1bb5			 
1bb5			; get current ret stack pointer and save to hl  
1bb5				 
1bb5			FORTH_RSP_TOS: macro 
1bb5				call macro_forth_rsp_tos 
1bb5				endm 
1bb5			 
1bb5			macro_forth_rsp_tos: 
1bb5				;push de 
1bb5 2a 94 f9			ld hl,(cli_ret_sp) 
1bb8 cd f0 1b			call loadhlptrtohl 
1bbb				;ld e, (hl) 
1bbb				;inc hl 
1bbb				;ld d, (hl) 
1bbb				;ex de, hl 
1bbb					if DEBUG_FORTH_WORDS 
1bbb			;			DMARK "RST" 
1bbb						CALLMONITOR 
1bbb cd 6a 16			call break_point_state  
1bbe				endm  
# End of macro CALLMONITOR
1bbe					endif 
1bbe				;pop de 
1bbe c9				ret 
1bbf			 
1bbf			; pop ret stack pointer 
1bbf				 
1bbf			FORTH_RSP_POP: macro 
1bbf				call macro_forth_rsp_pop 
1bbf				endm 
1bbf			 
1bbf			 
1bbf			macro_forth_rsp_pop: 
1bbf				if DEBUG_FORTH_STACK_GUARD 
1bbf			;		DMARK "RPP" 
1bbf cd 8d 62				call check_stacks 
1bc2					FORTH_CHK_RSP_UNDER 
1bc2 e5				push hl 
1bc3 d5				push de 
1bc4 2a 94 f9			ld hl,(cli_ret_sp) 
1bc7 11 0e f9			ld de, cli_ret_stack 
1bca cd 24 0d			call cmp16 
1bcd da a1 63			jp c, fault_rsp_under 
1bd0 d1				pop de 
1bd1 e1				pop hl 
1bd2				endm 
# End of macro FORTH_CHK_RSP_UNDER
1bd2				endif 
1bd2 e5				push hl 
1bd3 2a 94 f9			ld hl,(cli_ret_sp) 
1bd6			 
1bd6			 
1bd6				if FORTH_ENABLE_FREE 
1bd6			 
1bd6					; get pointer 
1bd6			 
1bd6					push de 
1bd6					push hl 
1bd6			 
1bd6					ld e, (hl) 
1bd6					inc hl 
1bd6					ld d, (hl) 
1bd6			 
1bd6					ex de, hl 
1bd6					call free 
1bd6			 
1bd6					pop hl 
1bd6					pop de 
1bd6			 
1bd6			 
1bd6				endif 
1bd6			 
1bd6			 
1bd6 2b				dec hl 
1bd7 2b				dec hl 
1bd8 22 94 f9			ld (cli_ret_sp), hl 
1bdb				; do stack underflow checks 
1bdb e1				pop hl 
1bdc				if DEBUG_FORTH_STACK_GUARD 
1bdc cd 8d 62				call check_stacks 
1bdf					FORTH_CHK_RSP_UNDER 
1bdf e5				push hl 
1be0 d5				push de 
1be1 2a 94 f9			ld hl,(cli_ret_sp) 
1be4 11 0e f9			ld de, cli_ret_stack 
1be7 cd 24 0d			call cmp16 
1bea da a1 63			jp c, fault_rsp_under 
1bed d1				pop de 
1bee e1				pop hl 
1bef				endm 
# End of macro FORTH_CHK_RSP_UNDER
1bef				endif 
1bef c9				ret 
1bf0			 
1bf0			 
1bf0			 
1bf0			; routine to load word pointed to by hl into hl 
1bf0			 
1bf0			loadhlptrtohl: 
1bf0			 
1bf0 d5				push de 
1bf1 5e				ld e, (hl) 
1bf2 23				inc hl 
1bf3 56				ld d, (hl) 
1bf4 eb				ex de, hl 
1bf5 d1				pop de 
1bf6			 
1bf6 c9				ret 
1bf7			 
1bf7			 
1bf7			 
1bf7			 
1bf7			 
1bf7			; push a number held in HL onto the data stack 
1bf7			; entry point for pushing a value when already in hl used in function above 
1bf7			 
1bf7			forth_push_numhl: 
1bf7			 
1bf7 e5				push hl    ; save value to push 
1bf8			 
1bf8			if DEBUG_FORTH_PUSH 
1bf8				; see if disabled 
1bf8			 
1bf8			 
1bf8 f5				push af 
1bf9 3a 94 ef			ld a, (os_view_disable) 
1bfc fe 2a			cp '*' 
1bfe 28 34			jr z, .pskip2 
1c00 e5				push hl 
1c01 e5			push hl 
1c02 cd d2 0a			call clear_display 
1c05 e1			pop hl 
1c06 7c				ld a,h 
1c07 21 a8 f2			ld hl, os_word_scratch 
1c0a cd 07 10			call hexout 
1c0d e1				pop hl 
1c0e 7d				ld a,l 
1c0f 21 aa f2			ld hl, os_word_scratch+2 
1c12 cd 07 10			call hexout 
1c15			 
1c15 21 ac f2			ld hl, os_word_scratch+4 
1c18 3e 00			ld a,0 
1c1a 77				ld (hl),a 
1c1b 11 a8 f2			ld de,os_word_scratch 
1c1e 3e 14				ld a, display_row_2 
1c20 cd e5 0a				call str_at_display 
1c23 11 9b 51			ld de, .push_num 
1c26 3e 00			ld a, display_row_1 
1c28			 
1c28 cd e5 0a				call str_at_display 
1c2b			 
1c2b			 
1c2b cd f5 0a			call update_display 
1c2e cd 52 0a			call delay1s 
1c31 cd 52 0a			call delay1s 
1c34			.pskip2:  
1c34			 
1c34 f1				pop af 
1c35			endif	 
1c35			 
1c35			 
1c35				FORTH_DSP_NEXT 
1c35 cd 86 1b			call macro_forth_dsp_next 
1c38				endm 
# End of macro FORTH_DSP_NEXT
1c38			 
1c38 2a 90 f9			ld hl, (cli_data_sp) 
1c3b			 
1c3b				; save item type 
1c3b 3e 02			ld a,  DS_TYPE_INUM 
1c3d 77				ld (hl), a 
1c3e 23				inc hl 
1c3f			 
1c3f				; get word off stack 
1c3f d1				pop de 
1c40 7b				ld a,e 
1c41 77				ld (hl), a 
1c42 23				inc hl 
1c43 7a				ld a,d 
1c44 77				ld (hl), a 
1c45			 
1c45			if DEBUG_FORTH_PUSH 
1c45 2b				dec hl 
1c46 2b				dec hl 
1c47 2b				dec hl 
1c48						DMARK "PH5" 
1c48 f5				push af  
1c49 3a 5d 1c			ld a, (.dmark)  
1c4c 32 bd fb			ld (debug_mark),a  
1c4f 3a 5e 1c			ld a, (.dmark+1)  
1c52 32 be fb			ld (debug_mark+1),a  
1c55 3a 5f 1c			ld a, (.dmark+2)  
1c58 32 bf fb			ld (debug_mark+2),a  
1c5b 18 03			jr .pastdmark  
1c5d ..			.dmark: db "PH5"  
1c60 f1			.pastdmark: pop af  
1c61			endm  
# End of macro DMARK
1c61				CALLMONITOR 
1c61 cd 6a 16			call break_point_state  
1c64				endm  
# End of macro CALLMONITOR
1c64			endif	 
1c64			 
1c64 c9				ret 
1c65			 
1c65			 
1c65			; Push a string to stack pointed to by hl 
1c65			 
1c65			forth_push_str: 
1c65			 
1c65			if DEBUG_FORTH_PUSH 
1c65						DMARK "PSQ" 
1c65 f5				push af  
1c66 3a 7a 1c			ld a, (.dmark)  
1c69 32 bd fb			ld (debug_mark),a  
1c6c 3a 7b 1c			ld a, (.dmark+1)  
1c6f 32 be fb			ld (debug_mark+1),a  
1c72 3a 7c 1c			ld a, (.dmark+2)  
1c75 32 bf fb			ld (debug_mark+2),a  
1c78 18 03			jr .pastdmark  
1c7a ..			.dmark: db "PSQ"  
1c7d f1			.pastdmark: pop af  
1c7e			endm  
# End of macro DMARK
1c7e				CALLMONITOR 
1c7e cd 6a 16			call break_point_state  
1c81				endm  
# End of macro CALLMONITOR
1c81			endif	 
1c81			    
1c81 e5				push hl 
1c82 e5				push hl 
1c83			 
1c83			;	ld a, 0   ; find end of string 
1c83 cd 64 11			call strlenz 
1c86			if DEBUG_FORTH_PUSH 
1c86						DMARK "PQ2" 
1c86 f5				push af  
1c87 3a 9b 1c			ld a, (.dmark)  
1c8a 32 bd fb			ld (debug_mark),a  
1c8d 3a 9c 1c			ld a, (.dmark+1)  
1c90 32 be fb			ld (debug_mark+1),a  
1c93 3a 9d 1c			ld a, (.dmark+2)  
1c96 32 bf fb			ld (debug_mark+2),a  
1c99 18 03			jr .pastdmark  
1c9b ..			.dmark: db "PQ2"  
1c9e f1			.pastdmark: pop af  
1c9f			endm  
# End of macro DMARK
1c9f				CALLMONITOR 
1c9f cd 6a 16			call break_point_state  
1ca2				endm  
# End of macro CALLMONITOR
1ca2			endif	 
1ca2 eb				ex de, hl 
1ca3 e1				pop hl   ; get ptr to start of string 
1ca4			if DEBUG_FORTH_PUSH 
1ca4						DMARK "PQ3" 
1ca4 f5				push af  
1ca5 3a b9 1c			ld a, (.dmark)  
1ca8 32 bd fb			ld (debug_mark),a  
1cab 3a ba 1c			ld a, (.dmark+1)  
1cae 32 be fb			ld (debug_mark+1),a  
1cb1 3a bb 1c			ld a, (.dmark+2)  
1cb4 32 bf fb			ld (debug_mark+2),a  
1cb7 18 03			jr .pastdmark  
1cb9 ..			.dmark: db "PQ3"  
1cbc f1			.pastdmark: pop af  
1cbd			endm  
# End of macro DMARK
1cbd				CALLMONITOR 
1cbd cd 6a 16			call break_point_state  
1cc0				endm  
# End of macro CALLMONITOR
1cc0			endif	 
1cc0 19				add hl,de 
1cc1			if DEBUG_FORTH_PUSH 
1cc1						DMARK "PQE" 
1cc1 f5				push af  
1cc2 3a d6 1c			ld a, (.dmark)  
1cc5 32 bd fb			ld (debug_mark),a  
1cc8 3a d7 1c			ld a, (.dmark+1)  
1ccb 32 be fb			ld (debug_mark+1),a  
1cce 3a d8 1c			ld a, (.dmark+2)  
1cd1 32 bf fb			ld (debug_mark+2),a  
1cd4 18 03			jr .pastdmark  
1cd6 ..			.dmark: db "PQE"  
1cd9 f1			.pastdmark: pop af  
1cda			endm  
# End of macro DMARK
1cda				CALLMONITOR 
1cda cd 6a 16			call break_point_state  
1cdd				endm  
# End of macro CALLMONITOR
1cdd			endif	 
1cdd			 
1cdd 2b				dec hl    ; see if there is an optional trailing double quote 
1cde 7e				ld a,(hl) 
1cdf fe 22			cp '"' 
1ce1 20 03			jr nz, .strnoq 
1ce3 3e 00			ld a, 0      ; get rid of double quote 
1ce5 77				ld (hl), a 
1ce6 23			.strnoq: inc hl 
1ce7			 
1ce7 3e 00			ld a, 0 
1ce9 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1cea			 
1cea 13				inc de ; add one for the type string 
1ceb 13				inc de ; add one for null term??? 
1cec			 
1cec				; tos is get string pointer again 
1cec				; de contains space to allocate 
1cec				 
1cec d5				push de 
1ced			 
1ced eb				ex de, hl 
1cee			 
1cee				;push af 
1cee			 
1cee			if DEBUG_FORTH_PUSH 
1cee						DMARK "PHm" 
1cee f5				push af  
1cef 3a 03 1d			ld a, (.dmark)  
1cf2 32 bd fb			ld (debug_mark),a  
1cf5 3a 04 1d			ld a, (.dmark+1)  
1cf8 32 be fb			ld (debug_mark+1),a  
1cfb 3a 05 1d			ld a, (.dmark+2)  
1cfe 32 bf fb			ld (debug_mark+2),a  
1d01 18 03			jr .pastdmark  
1d03 ..			.dmark: db "PHm"  
1d06 f1			.pastdmark: pop af  
1d07			endm  
# End of macro DMARK
1d07				CALLMONITOR 
1d07 cd 6a 16			call break_point_state  
1d0a				endm  
# End of macro CALLMONITOR
1d0a			endif	 
1d0a cd cd 11			call malloc	; on ret hl now contains allocated memory 
1d0d				if DEBUG_FORTH_MALLOC_GUARD 
1d0d cc f3 51				call z,malloc_error 
1d10				endif 
1d10			 
1d10				 
1d10 c1				pop bc    ; get length 
1d11 d1				pop de   ;  get string start    
1d12			 
1d12				; hl has destination from malloc 
1d12			 
1d12 eb				ex de, hl    ; prep for ldir 
1d13			 
1d13 d5				push de   ; save malloc area for DSP later 
1d14				;push hl   ; save malloc area for DSP later 
1d14			 
1d14			if DEBUG_FORTH_PUSH 
1d14						DMARK "PHc" 
1d14 f5				push af  
1d15 3a 29 1d			ld a, (.dmark)  
1d18 32 bd fb			ld (debug_mark),a  
1d1b 3a 2a 1d			ld a, (.dmark+1)  
1d1e 32 be fb			ld (debug_mark+1),a  
1d21 3a 2b 1d			ld a, (.dmark+2)  
1d24 32 bf fb			ld (debug_mark+2),a  
1d27 18 03			jr .pastdmark  
1d29 ..			.dmark: db "PHc"  
1d2c f1			.pastdmark: pop af  
1d2d			endm  
# End of macro DMARK
1d2d				CALLMONITOR 
1d2d cd 6a 16			call break_point_state  
1d30				endm  
# End of macro CALLMONITOR
1d30			endif	 
1d30			 
1d30			 
1d30 ed b0			ldir 
1d32			 
1d32			 
1d32				; push malloc to data stack     macro?????  
1d32			 
1d32				FORTH_DSP_NEXT 
1d32 cd 86 1b			call macro_forth_dsp_next 
1d35				endm 
# End of macro FORTH_DSP_NEXT
1d35			 
1d35				; save value and type 
1d35			 
1d35 2a 90 f9			ld hl, (cli_data_sp) 
1d38			 
1d38				; save item type 
1d38 3e 01			ld a,  DS_TYPE_STR 
1d3a 77				ld (hl), a 
1d3b 23				inc hl 
1d3c			 
1d3c				; get malloc word off stack 
1d3c d1				pop de 
1d3d 73				ld (hl), e 
1d3e 23				inc hl 
1d3f 72				ld (hl), d 
1d40			 
1d40			 
1d40			 
1d40			if DEBUG_FORTH_PUSH 
1d40 2a 90 f9			ld hl, (cli_data_sp) 
1d43						DMARK "PHS" 
1d43 f5				push af  
1d44 3a 58 1d			ld a, (.dmark)  
1d47 32 bd fb			ld (debug_mark),a  
1d4a 3a 59 1d			ld a, (.dmark+1)  
1d4d 32 be fb			ld (debug_mark+1),a  
1d50 3a 5a 1d			ld a, (.dmark+2)  
1d53 32 bf fb			ld (debug_mark+2),a  
1d56 18 03			jr .pastdmark  
1d58 ..			.dmark: db "PHS"  
1d5b f1			.pastdmark: pop af  
1d5c			endm  
# End of macro DMARK
1d5c				CALLMONITOR 
1d5c cd 6a 16			call break_point_state  
1d5f				endm  
# End of macro CALLMONITOR
1d5f			;	ex de,hl 
1d5f			endif	 
1d5f				; in case of spaces, skip the ptr past the copied string 
1d5f				;pop af 
1d5f				;ld (cli_origptr),hl 
1d5f			 
1d5f c9				ret 
1d60			 
1d60			 
1d60			 
1d60			; TODO ascii push input onto stack given hl to start of input 
1d60			 
1d60			; identify type 
1d60			; if starts with a " then a string 
1d60			; otherwise it is a number 
1d60			;  
1d60			; if a string 
1d60			;     scan for ending " to get length of string to malloc for + 1 
1d60			;     malloc 
1d60			;     put pointer to string on stack first byte flags as string 
1d60			; 
1d60			; else a number 
1d60			;    look for number format identifier 
1d60			;    $xx hex 
1d60			;    %xxxxx bin 
1d60			;    xxxxx decimal 
1d60			;    convert number to 16bit word.  
1d60			;    malloc word + 1 with flag to identiy as num 
1d60			;    put pointer to number on stack 
1d60			;   
1d60			;  
1d60			  
1d60			forth_apush: 
1d60				; kernel push 
1d60			 
1d60			if DEBUG_FORTH_PUSH 
1d60						DMARK "PSH" 
1d60 f5				push af  
1d61 3a 75 1d			ld a, (.dmark)  
1d64 32 bd fb			ld (debug_mark),a  
1d67 3a 76 1d			ld a, (.dmark+1)  
1d6a 32 be fb			ld (debug_mark+1),a  
1d6d 3a 77 1d			ld a, (.dmark+2)  
1d70 32 bf fb			ld (debug_mark+2),a  
1d73 18 03			jr .pastdmark  
1d75 ..			.dmark: db "PSH"  
1d78 f1			.pastdmark: pop af  
1d79			endm  
# End of macro DMARK
1d79				CALLMONITOR 
1d79 cd 6a 16			call break_point_state  
1d7c				endm  
# End of macro CALLMONITOR
1d7c			endif	 
1d7c				; identify input type 
1d7c			 
1d7c 7e				ld a,(hl) 
1d7d fe 22			cp '"' 
1d7f 28 0a			jr z, .fapstr 
1d81 fe 24			cp '$' 
1d83 ca ab 1d			jp z, .faphex 
1d86 fe 25			cp '%' 
1d88 ca 93 1d			jp z, .fapbin 
1d8b			;	cp 'b' 
1d8b			;	jp z, .fabin 
1d8b				; else decimal 
1d8b			 
1d8b				; TODO do decimal conversion 
1d8b				; decimal is stored as a 16bit word 
1d8b			 
1d8b				; by default everything is a string if type is not detected 
1d8b			.fapstr: ; 
1d8b fe 22			cp '"' 
1d8d 20 01			jr nz, .strnoqu 
1d8f 23				inc hl 
1d90			.strnoqu: 
1d90 c3 65 1c			jp forth_push_str 
1d93			 
1d93			 
1d93			 
1d93			.fapbin:    ; push a binary string.  
1d93 11 00 00			ld de, 0   ; hold a 16bit value 
1d96			 
1d96 23			.fapbinshift:	inc hl  
1d97 7e				ld a,(hl) 
1d98 fe 00			cp 0     ; done scanning  
1d9a 28 0b			jr z, .fapbdone  	; got it in HL so push  
1d9c			 
1d9c				; left shift de 
1d9c eb				ex de, hl	 
1d9d 29				add hl, hl 
1d9e			 
1d9e				; is 1 
1d9e fe 31			cp '1' 
1da0 20 02			jr nz, .binzero 
1da2 cb 4d			bit 1, l 
1da4			.binzero: 
1da4 eb				ex de, hl	 ; save current de 
1da5 18 ef			jr .fapbinshift 
1da7			 
1da7			.fapbdone: 
1da7 eb				ex de, hl 
1da8 c3 f7 1b			jp forth_push_numhl 
1dab			 
1dab			 
1dab			.faphex:   ; hex is always stored as a 16bit word 
1dab				; skip number prefix 
1dab 23				inc hl 
1dac				; turn ascii into number 
1dac cd bd 10			call get_word_hl	; ret 16bit word in hl 
1daf			 
1daf c3 f7 1b			jp forth_push_numhl 
1db2			 
1db2 00				 nop 
1db3			 
1db3			.fabin:   ; TODO bin conversion 
1db3			 
1db3			 
1db3 c9				ret 
1db4			 
1db4			 
1db4			; get either a string ptr or a 16bit word from the data stack 
1db4			 
1db4			FORTH_DSP: macro 
1db4				call macro_forth_dsp 
1db4				endm 
1db4			 
1db4			macro_forth_dsp: 
1db4				; data stack pointer points to current word on tos 
1db4			 
1db4 2a 90 f9			ld hl,(cli_data_sp) 
1db7			 
1db7				if DEBUG_FORTH_PUSH 
1db7						DMARK "DSP" 
1db7 f5				push af  
1db8 3a cc 1d			ld a, (.dmark)  
1dbb 32 bd fb			ld (debug_mark),a  
1dbe 3a cd 1d			ld a, (.dmark+1)  
1dc1 32 be fb			ld (debug_mark+1),a  
1dc4 3a ce 1d			ld a, (.dmark+2)  
1dc7 32 bf fb			ld (debug_mark+2),a  
1dca 18 03			jr .pastdmark  
1dcc ..			.dmark: db "DSP"  
1dcf f1			.pastdmark: pop af  
1dd0			endm  
# End of macro DMARK
1dd0			 
1dd0 cd 28 52				call display_data_sp 
1dd3				;call break_point_state 
1dd3				;rst 030h 
1dd3				CALLMONITOR 
1dd3 cd 6a 16			call break_point_state  
1dd6				endm  
# End of macro CALLMONITOR
1dd6				endif 
1dd6			 
1dd6 c9				ret 
1dd7			 
1dd7			; return hl to start of value on stack 
1dd7			 
1dd7			FORTH_DSP_VALUE: macro 
1dd7				call macro_forth_dsp_value 
1dd7				endm 
1dd7			 
1dd7			macro_forth_dsp_value: 
1dd7			 
1dd7				FORTH_DSP 
1dd7 cd b4 1d			call macro_forth_dsp 
1dda				endm 
# End of macro FORTH_DSP
1dda			 
1dda d5				push de 
1ddb			 
1ddb 23				inc hl ; skip type 
1ddc			 
1ddc 5e				ld e, (hl) 
1ddd 23				inc hl 
1dde 56				ld d, (hl) 
1ddf eb				ex de,hl  
1de0			 
1de0 d1				pop de 
1de1			 
1de1 c9				ret 
1de2			 
1de2			; return hl to start of value to second item on stack 
1de2			 
1de2			FORTH_DSP_VALUEM1: macro 
1de2				call macro_forth_dsp_value_m1 
1de2				endm 
1de2			 
1de2			macro_forth_dsp_value_m1: 
1de2			 
1de2				FORTH_DSP 
1de2 cd b4 1d			call macro_forth_dsp 
1de5				endm 
# End of macro FORTH_DSP
1de5			 
1de5 2b				dec hl 
1de6 2b				dec hl 
1de7			;	dec hl 
1de7			 
1de7 d5				push de 
1de8			 
1de8 5e				ld e, (hl) 
1de9 23				inc hl 
1dea 56				ld d, (hl) 
1deb eb				ex de,hl  
1dec			 
1dec d1				pop de 
1ded			 
1ded c9				ret 
1dee			 
1dee				 
1dee			 
1dee			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1dee			 
1dee			FORTH_DSP_POP: macro 
1dee				call macro_forth_dsp_pop 
1dee				endm 
1dee			 
1dee			 
1dee			; get the tos data type 
1dee			 
1dee			FORTH_DSP_TYPE:   macro 
1dee			 
1dee				;FORTH_DSP_VALUE 
1dee				FORTH_DSP 
1dee				 
1dee				; hl points to value 
1dee				; check type 
1dee			 
1dee				ld a,(hl) 
1dee			 
1dee				endm 
1dee			 
1dee			; load the tos value into hl 
1dee			 
1dee			 
1dee			FORTH_DSP_VALUEHL:  macro 
1dee				call macro_dsp_valuehl 
1dee				endm 
1dee			 
1dee			 
1dee			 
1dee			macro_dsp_valuehl: 
1dee				FORTH_DSP_VALUE 
1dee cd d7 1d			call macro_forth_dsp_value 
1df1				endm 
# End of macro FORTH_DSP_VALUE
1df1			 
1df1				;FORTH_ERR_TOS_NOTNUM 
1df1			 
1df1				;inc hl   ; skip type id 
1df1			 
1df1			;	push de 
1df1			; 
1df1			;	ld e, (hl) 
1df1			;	inc hl 
1df1			;	ld d, (hl) 
1df1			;	ex de,hl  
1df1			 
1df1			;	pop de 
1df1			 
1df1				if DEBUG_FORTH_PUSH 
1df1						DMARK "DVL" 
1df1 f5				push af  
1df2 3a 06 1e			ld a, (.dmark)  
1df5 32 bd fb			ld (debug_mark),a  
1df8 3a 07 1e			ld a, (.dmark+1)  
1dfb 32 be fb			ld (debug_mark+1),a  
1dfe 3a 08 1e			ld a, (.dmark+2)  
1e01 32 bf fb			ld (debug_mark+2),a  
1e04 18 03			jr .pastdmark  
1e06 ..			.dmark: db "DVL"  
1e09 f1			.pastdmark: pop af  
1e0a			endm  
# End of macro DMARK
1e0a				CALLMONITOR 
1e0a cd 6a 16			call break_point_state  
1e0d				endm  
# End of macro CALLMONITOR
1e0d				endif 
1e0d c9				ret 
1e0e			 
1e0e			forth_apushstrhl:      
1e0e				; push of string requires use of cli_origptr 
1e0e				; bodge use 
1e0e			 
1e0e				; get current cli_origptr, save, update with temp pointer  
1e0e ed 5b ac f9		ld de, (cli_origptr) 
1e12 22 ac f9			ld (cli_origptr), hl 
1e15 d5				push de 
1e16 cd 60 1d			call forth_apush 
1e19 d1				pop de 
1e1a ed 53 ac f9		ld (cli_origptr), de 
1e1e c9			        ret	 
1e1f			 
1e1f			 
1e1f			; increase loop stack pointer and save hl to it 
1e1f				 
1e1f			FORTH_LOOP_NEXT: macro 
1e1f				call macro_forth_loop_next 
1e1f				;nop 
1e1f				endm 
1e1f			 
1e1f			macro_forth_loop_next: 
1e1f				if DEBUG_FORTH_STACK_GUARD 
1e1f cd 8d 62				call check_stacks 
1e22				endif 
1e22 e5				push hl 
1e23 d5				push de 
1e24 eb				ex de,hl 
1e25 2a 92 f9			ld hl,(cli_loop_sp) 
1e28 23				inc hl 
1e29 23				inc hl 
1e2a					if DEBUG_FORTH_WORDS 
1e2a						DMARK "LNX" 
1e2a f5				push af  
1e2b 3a 3f 1e			ld a, (.dmark)  
1e2e 32 bd fb			ld (debug_mark),a  
1e31 3a 40 1e			ld a, (.dmark+1)  
1e34 32 be fb			ld (debug_mark+1),a  
1e37 3a 41 1e			ld a, (.dmark+2)  
1e3a 32 bf fb			ld (debug_mark+2),a  
1e3d 18 03			jr .pastdmark  
1e3f ..			.dmark: db "LNX"  
1e42 f1			.pastdmark: pop af  
1e43			endm  
# End of macro DMARK
1e43						CALLMONITOR 
1e43 cd 6a 16			call break_point_state  
1e46				endm  
# End of macro CALLMONITOR
1e46					endif 
1e46 22 92 f9			ld (cli_loop_sp),hl 
1e49 73				ld (hl), e 
1e4a 23				inc hl 
1e4b 72				ld (hl), d 
1e4c d1				pop de    ; been reversed so save a swap on restore 
1e4d e1				pop hl 
1e4e				if DEBUG_FORTH_STACK_GUARD 
1e4e cd 8d 62				call check_stacks 
1e51				endif 
1e51 c9				ret 
1e52			 
1e52			; get current ret stack pointer and save to hl  
1e52				 
1e52			FORTH_LOOP_TOS: macro 
1e52				call macro_forth_loop_tos 
1e52				endm 
1e52			 
1e52			macro_forth_loop_tos: 
1e52 d5				push de 
1e53 2a 92 f9			ld hl,(cli_loop_sp) 
1e56 5e				ld e, (hl) 
1e57 23				inc hl 
1e58 56				ld d, (hl) 
1e59 eb				ex de, hl 
1e5a d1				pop de 
1e5b c9				ret 
1e5c			 
1e5c			; pop loop stack pointer 
1e5c				 
1e5c			FORTH_LOOP_POP: macro 
1e5c				call macro_forth_loop_pop 
1e5c				endm 
1e5c			 
1e5c			 
1e5c			macro_forth_loop_pop: 
1e5c				if DEBUG_FORTH_STACK_GUARD 
1e5c					DMARK "LPP" 
1e5c f5				push af  
1e5d 3a 71 1e			ld a, (.dmark)  
1e60 32 bd fb			ld (debug_mark),a  
1e63 3a 72 1e			ld a, (.dmark+1)  
1e66 32 be fb			ld (debug_mark+1),a  
1e69 3a 73 1e			ld a, (.dmark+2)  
1e6c 32 bf fb			ld (debug_mark+2),a  
1e6f 18 03			jr .pastdmark  
1e71 ..			.dmark: db "LPP"  
1e74 f1			.pastdmark: pop af  
1e75			endm  
# End of macro DMARK
1e75 cd 8d 62				call check_stacks 
1e78					FORTH_CHK_LOOP_UNDER 
1e78 e5				push hl 
1e79 d5				push de 
1e7a 2a 92 f9			ld hl,(cli_loop_sp) 
1e7d 11 0c f7			ld de, cli_loop_stack 
1e80 cd 24 0d			call cmp16 
1e83 da a7 63			jp c, fault_loop_under 
1e86 d1				pop de 
1e87 e1				pop hl 
1e88				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e88				endif 
1e88 e5				push hl 
1e89 2a 92 f9			ld hl,(cli_loop_sp) 
1e8c 2b				dec hl 
1e8d 2b				dec hl 
1e8e 22 92 f9			ld (cli_loop_sp), hl 
1e91				; TODO do stack underflow checks 
1e91 e1				pop hl 
1e92				if DEBUG_FORTH_STACK_GUARD 
1e92 cd 8d 62				call check_stacks 
1e95					FORTH_CHK_LOOP_UNDER 
1e95 e5				push hl 
1e96 d5				push de 
1e97 2a 92 f9			ld hl,(cli_loop_sp) 
1e9a 11 0c f7			ld de, cli_loop_stack 
1e9d cd 24 0d			call cmp16 
1ea0 da a7 63			jp c, fault_loop_under 
1ea3 d1				pop de 
1ea4 e1				pop hl 
1ea5				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ea5				endif 
1ea5 c9				ret 
1ea6			 
1ea6			macro_forth_dsp_pop: 
1ea6			 
1ea6 e5				push hl 
1ea7			 
1ea7				; release malloc data 
1ea7			 
1ea7				if DEBUG_FORTH_STACK_GUARD 
1ea7 cd 8d 62				call check_stacks 
1eaa					FORTH_CHK_DSP_UNDER 
1eaa e5				push hl 
1eab d5				push de 
1eac 2a 90 f9			ld hl,(cli_data_sp) 
1eaf 11 0a f5			ld de, cli_data_stack 
1eb2 cd 24 0d			call cmp16 
1eb5 da 9b 63			jp c, fault_dsp_under 
1eb8 d1				pop de 
1eb9 e1				pop hl 
1eba				endm 
# End of macro FORTH_CHK_DSP_UNDER
1eba				endif 
1eba				;ld hl,(cli_data_sp) 
1eba			if DEBUG_FORTH_DOT 
1eba				DMARK "DPP" 
1eba				CALLMONITOR 
1eba			endif	 
1eba			 
1eba			 
1eba			if FORTH_ENABLE_DSPPOPFREE 
1eba			 
1eba				FORTH_DSP 
1eba cd b4 1d			call macro_forth_dsp 
1ebd				endm 
# End of macro FORTH_DSP
1ebd			 
1ebd 7e				ld a, (hl) 
1ebe fe 01			cp DS_TYPE_STR 
1ec0 20 07			jr nz, .skippopfree 
1ec2			 
1ec2				FORTH_DSP_VALUEHL 
1ec2 cd ee 1d			call macro_dsp_valuehl 
1ec5				endm 
# End of macro FORTH_DSP_VALUEHL
1ec5 00				nop 
1ec6			if DEBUG_FORTH_DOT 
1ec6				DMARK "DPf" 
1ec6				CALLMONITOR 
1ec6			endif	 
1ec6 cd 97 12			call free 
1ec9			.skippopfree: 
1ec9				 
1ec9			 
1ec9			endif 
1ec9			 
1ec9			if DEBUG_FORTH_DOT_KEY 
1ec9				DMARK "DP2" 
1ec9				CALLMONITOR 
1ec9			endif	 
1ec9			 
1ec9				; move pointer down 
1ec9			 
1ec9 2a 90 f9			ld hl,(cli_data_sp) 
1ecc 2b				dec hl 
1ecd 2b				dec hl 
1ece			; PARSEV5 
1ece 2b				dec hl 
1ecf 22 90 f9			ld (cli_data_sp), hl 
1ed2			 
1ed2				if DEBUG_FORTH_STACK_GUARD 
1ed2 cd 8d 62				call check_stacks 
1ed5					FORTH_CHK_DSP_UNDER 
1ed5 e5				push hl 
1ed6 d5				push de 
1ed7 2a 90 f9			ld hl,(cli_data_sp) 
1eda 11 0a f5			ld de, cli_data_stack 
1edd cd 24 0d			call cmp16 
1ee0 da 9b 63			jp c, fault_dsp_under 
1ee3 d1				pop de 
1ee4 e1				pop hl 
1ee5				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ee5				endif 
1ee5			 
1ee5 e1				pop hl 
1ee6			 
1ee6 c9				ret 
1ee7			 
1ee7			getwordathl: 
1ee7				; hl points to an address 
1ee7				; load hl with the word at that address 
1ee7			 
1ee7 d5				push de 
1ee8			 
1ee8 5e				ld e, (hl) 
1ee9 23				inc hl 
1eea 56				ld d, (hl) 
1eeb eb				ex de, hl 
1eec			 
1eec d1				pop de 
1eed c9				ret 
1eee			 
1eee			 
1eee			 
1eee			 
1eee			 
1eee			; eof 
1eee			 
# End of file forth_stackopsv5.asm
1eee			endif 
1eee			 
1eee			user_word_eol:  
1eee				; hl contains the pointer to where to create a linked list item from the end 
1eee				; of the user dict to continue on at the system word dict 
1eee				 
1eee				; poke the stub of the word list linked list to repoint to rom words 
1eee			 
1eee				; stub format 
1eee				; db   word id 
1eee				; dw    link to next word 
1eee			        ; db char length of token 
1eee				; db string + 0 term 
1eee				; db exec code....  
1eee			 
1eee 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1ef0 77				ld (hl), a		; word id 
1ef1 23				inc hl 
1ef2			 
1ef2 11 b8 20			ld de, sysdict 
1ef5 73				ld (hl), e		; next word link ie system dict 
1ef6 23				inc hl 
1ef7 72				ld (hl), d		; next word link ie system dict 
1ef8 23				inc hl	 
1ef9			 
1ef9			;	ld (hl), sysdict		; next word link ie system dict 
1ef9			;	inc hl 
1ef9			;	inc hl 
1ef9			 
1ef9			;	inc hl 
1ef9			;	inc hl 
1ef9			 
1ef9 3e 02			ld a, 2			; word length is 0 
1efb 77				ld (hl), a	 
1efc 23				inc hl 
1efd			 
1efd 3e 7e			ld a, '~'			; word length is 0 
1eff 77				ld (hl), a	 
1f00 23				inc hl 
1f01 3e 00			ld a, 0			; save empty word 
1f03 77				ld (hl), a 
1f04			 
1f04 c9				ret 
1f05			 
1f05				 
1f05			 
1f05			forthexec_cleanup: 
1f05				FORTH_RSP_POP 
1f05 cd bf 1b			call macro_forth_rsp_pop 
1f08				endm 
# End of macro FORTH_RSP_POP
1f08 c9				ret 
1f09			 
1f09			forth_call_hl: 
1f09				; taking hl 
1f09 e5				push hl 
1f0a c9				ret 
1f0b			 
1f0b			; this is called to reset Forth system but keep existing uwords etc 
1f0b			 
1f0b			forth_warmstart: 
1f0b				; setup stack over/under flow checks 
1f0b				if DEBUG_FORTH_STACK_GUARD 
1f0b cd 73 62				call chk_stk_init 
1f0e				endif 
1f0e			 
1f0e				; init stack pointers  - * these stacks go upwards *  
1f0e 21 0e f9			ld hl, cli_ret_stack 
1f11 22 94 f9			ld (cli_ret_sp), hl	 
1f14				; set bottom of stack 
1f14 3e 00			ld a,0 
1f16 77				ld (hl),a 
1f17 23				inc hl 
1f18 77				ld (hl),a 
1f19			 
1f19 21 0a f5			ld hl, cli_data_stack 
1f1c 22 90 f9			ld (cli_data_sp), hl	 
1f1f				; set bottom of stack 
1f1f 3e 00			ld a,0 
1f21 77				ld (hl),a 
1f22 23				inc hl 
1f23 77				ld (hl),a 
1f24			 
1f24 21 0c f7			ld hl, cli_loop_stack 
1f27 22 92 f9			ld (cli_loop_sp), hl	 
1f2a				; set bottom of stack 
1f2a 3e 00			ld a,0 
1f2c 77				ld (hl),a 
1f2d 23				inc hl 
1f2e 77				ld (hl),a 
1f2f			 
1f2f				; init extent of current open file 
1f2f			 
1f2f 3e 00			ld a, 0 
1f31 32 df f9			ld (store_openext), a 
1f34			 
1f34 c9				ret 
1f35			 
1f35			 
1f35			; Cold Start - this is called to setup the whole Forth system 
1f35			 
1f35			forth_init: 
1f35			 
1f35				; setup stack over/under flow checks 
1f35			 
1f35			;	if DEBUG_FORTH_STACK_GUARD 
1f35			;		call chk_stk_init 
1f35			;	endif 
1f35			 
1f35				; enable auto display updates (slow.....) 
1f35			 
1f35 3e 01			ld a, 1 
1f37 32 aa f9			ld (cli_autodisplay), a 
1f3a			 
1f3a			 
1f3a			 
1f3a				; show start up screen 
1f3a			 
1f3a cd d2 0a			call clear_display 
1f3d			 
1f3d 3e 00			ld a,0 
1f3f 32 cc f9			ld (f_cursor_ptr), a 
1f42			 
1f42				; set start of word list in start of ram - for use when creating user words 
1f42			 
1f42 21 00 80			ld hl, baseram 
1f45 22 a0 f2			ld (os_last_new_uword), hl 
1f48 cd ee 1e			call user_word_eol 
1f4b				 
1f4b			;		call display_data_sp 
1f4b			;		call next_page_prompt 
1f4b			 
1f4b			 
1f4b			 
1f4b			 
1f4b c9				ret 
1f4c			 
1f4c .. 00		.bootforth: db " Forth Kernel Init ",0 
1f60			 
1f60			; TODO push to stack 
1f60			 
1f60			;  
1f60			 
1f60			if FORTH_PARSEV2 
1f60			 
1f60			 
1f60				include "forth_parserv2.asm" 
1f60			 
1f60			endif 
1f60			 
1f60			 
1f60			; parse cli version 1 
1f60			 
1f60			if FORTH_PARSEV1 
1f60			 
1f60			 
1f60			 
1f60			      include "forth_parserv1.asm" 
1f60			endif 
1f60				 
1f60			if FORTH_PARSEV3 
1f60			 
1f60			 
1f60			 
1f60			      include "forth_parserv3.asm" 
1f60				include "forth_wordsv3.asm" 
1f60			endif 
1f60			 
1f60			if FORTH_PARSEV4 
1f60			 
1f60			 
1f60			 
1f60			      include "forth_parserv4.asm" 
1f60				include "forth_wordsv4.asm" 
1f60			endif 
1f60			 
1f60			if FORTH_PARSEV5 
1f60			 
1f60			 
1f60			 
1f60			      include "forth_parserv5.asm" 
1f60			 
1f60			 
1f60			; A better parser without using malloc and string copies all over the place.  
1f60			; Exec in situ should be faster 
1f60			 
1f60			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1f60			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1f60			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1f60			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1f60			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1f60			WORD_SYS_END: equ 0   ; Opcode for all user words 
1f60			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1f60			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1f60			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1f60			 
1f60			; Core word preamble macro 
1f60			 
1f60			CWHEAD:   macro nxtword opcode lit len opflags 
1f60				db WORD_SYS_CORE+opcode             
1f60				; internal op code number 
1f60				dw nxtword            
1f60				; link to next dict word block 
1f60				db len + 1 
1f60				; literal length of dict word inc zero term 
1f60				db lit,0              
1f60				; literal dict word 
1f60			        ; TODO db opflags        
1f60				endm 
1f60			 
1f60			 
1f60			NEXTW: macro  
1f60				jp macro_next 
1f60				endm 
1f60			 
1f60			macro_next: 
1f60			if DEBUG_FORTH_PARSE_KEY 
1f60				DMARK "NXT" 
1f60				CALLMONITOR 
1f60			endif	 
1f60			;	inc hl  ; skip token null term  
1f60 ed 4b ae f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f64 ed 5b ac f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f68 2a a4 f2			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f6b			if DEBUG_FORTH_PARSE_KEY 
1f6b				DMARK "}AA" 
1f6b				CALLMONITOR 
1f6b			endif	 
1f6b c3 6e 20			jp execnext 
1f6e				;jp exec1 
1f6e			       
1f6e			 
1f6e			 
1f6e			; Another go at the parser to compile  
1f6e			 
1f6e			 
1f6e			; TODO rework parser to change all of the string words to byte tokens 
1f6e			; TODO do a search for  
1f6e			 
1f6e			; TODO first run normal parser to zero term sections 
1f6e			; TODO for each word do a token look up to get the op code 
1f6e			; TODO need some means to flag to the exec that this is a byte code form    
1f6e			 
1f6e			 
1f6e			forthcompile: 
1f6e			 
1f6e			; 
1f6e			; line parse: 
1f6e			;       parse raw input buffer 
1f6e			;       tokenise the words 
1f6e			;       malloc new copy (for looping etc) 
1f6e			;       copy to malloc + current pc in line to start of string and add line term 
1f6e			;       save on new rsp 
1f6e			; 
1f6e			 
1f6e			; hl to point to the line to tokenise 
1f6e			 
1f6e			;	push hl 
1f6e 22 a4 f2			ld (os_tok_ptr), hl  ; save ptr to string 
1f71			 
1f71			;	ld a,0		; string term on input 
1f71			;	call strlent 
1f71			 
1f71			;	ld (os_tok_len), hl	 ; save string length 
1f71			 
1f71			;if DEBUG_FORTH_TOK 
1f71			;	ex de,hl		 
1f71			;endif 
1f71			 
1f71			;	pop hl 		; get back string pointer 
1f71			 
1f71			if DEBUG_FORTH_TOK 
1f71						DMARK "TOc" 
1f71				CALLMONITOR 
1f71			endif 
1f71 7e			.cptoken2:    ld a,(hl) 
1f72 23				inc hl 
1f73 fe 7f			cp FORTH_END_BUFFER 
1f75 28 29			jr z, .cptokendone2 
1f77 fe 00			cp 0 
1f79 28 25			jr z, .cptokendone2 
1f7b fe 22			cp '"' 
1f7d 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1f7f fe 20			cp ' ' 
1f81 20 ee			jr nz,  .cptoken2 
1f83			 
1f83			; TODO consume comments held between ( and ) 
1f83			 
1f83				; we have a space so change to zero term for dict match later 
1f83 2b				dec hl 
1f84 3e 00			ld a,0 
1f86 77				ld (hl), a 
1f87 23				inc hl 
1f88 18 e7			jr .cptoken2 
1f8a				 
1f8a			 
1f8a			.cptokenstr2: 
1f8a				; skip all white space until either eol (because forgot to term) or end double quote 
1f8a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f8a				;inc hl ; skip current double quote 
1f8a 7e				ld a,(hl) 
1f8b 23				inc hl 
1f8c fe 22			cp '"' 
1f8e 28 e1			jr z, .cptoken2 
1f90 fe 7f			cp FORTH_END_BUFFER 
1f92 28 0c			jr z, .cptokendone2 
1f94 fe 00			cp 0 
1f96 28 08			jr z, .cptokendone2 
1f98 fe 20			cp ' ' 
1f9a 28 02			jr z, .cptmp2 
1f9c 18 ec			jr .cptokenstr2 
1f9e			 
1f9e			.cptmp2:	; we have a space so change to zero term for dict match later 
1f9e				;dec hl 
1f9e				;ld a,"-"	; TODO remove this when working 
1f9e				;ld (hl), a 
1f9e				;inc hl 
1f9e 18 ea			jr .cptokenstr2 
1fa0			 
1fa0			.cptokendone2: 
1fa0				;inc hl 
1fa0 3e 7f			ld a, FORTH_END_BUFFER 
1fa2 77				ld (hl),a 
1fa3 23				inc hl 
1fa4 3e 21			ld a, '!' 
1fa6 77				ld (hl),a 
1fa7			 
1fa7 2a a4 f2			ld hl,(os_tok_ptr) 
1faa			         
1faa			if DEBUG_FORTH_TOK 
1faa						DMARK "Tc1" 
1faa				CALLMONITOR 
1faa			endif 
1faa			 
1faa				; push exec string to top of return stack 
1faa				FORTH_RSP_NEXT 
1faa cd 9e 1b			call macro_forth_rsp_next 
1fad				endm 
# End of macro FORTH_RSP_NEXT
1fad c9				ret 
1fae			 
1fae			; Another go at the parser need to simplify the process 
1fae			 
1fae			forthparse: 
1fae			 
1fae			; 
1fae			; line parse: 
1fae			;       parse raw input buffer 
1fae			;       tokenise the words 
1fae			;       malloc new copy (for looping etc) 
1fae			;       copy to malloc + current pc in line to start of string and add line term 
1fae			;       save on new rsp 
1fae			; 
1fae			 
1fae			; hl to point to the line to tokenise 
1fae			 
1fae			;	push hl 
1fae 22 a4 f2			ld (os_tok_ptr), hl  ; save ptr to string 
1fb1			 
1fb1			;	ld a,0		; string term on input 
1fb1			;	call strlent 
1fb1			 
1fb1			;	ld (os_tok_len), hl	 ; save string length 
1fb1			 
1fb1			;if DEBUG_FORTH_TOK 
1fb1			;	ex de,hl		 
1fb1			;endif 
1fb1			 
1fb1			;	pop hl 		; get back string pointer 
1fb1			 
1fb1			if DEBUG_FORTH_TOK 
1fb1						DMARK "TOK" 
1fb1				CALLMONITOR 
1fb1			endif 
1fb1 7e			.ptoken2:    ld a,(hl) 
1fb2 23				inc hl 
1fb3 fe 7f			cp FORTH_END_BUFFER 
1fb5 28 29			jr z, .ptokendone2 
1fb7 fe 00			cp 0 
1fb9 28 25			jr z, .ptokendone2 
1fbb fe 22			cp '"' 
1fbd 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1fbf fe 20			cp ' ' 
1fc1 20 ee			jr nz,  .ptoken2 
1fc3			 
1fc3			; TODO consume comments held between ( and ) 
1fc3			 
1fc3				; we have a space so change to zero term for dict match later 
1fc3 2b				dec hl 
1fc4 3e 00			ld a,0 
1fc6 77				ld (hl), a 
1fc7 23				inc hl 
1fc8 18 e7			jr .ptoken2 
1fca				 
1fca			 
1fca			.ptokenstr2: 
1fca				; skip all white space until either eol (because forgot to term) or end double quote 
1fca			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1fca				;inc hl ; skip current double quote 
1fca 7e				ld a,(hl) 
1fcb 23				inc hl 
1fcc fe 22			cp '"' 
1fce 28 e1			jr z, .ptoken2 
1fd0 fe 7f			cp FORTH_END_BUFFER 
1fd2 28 0c			jr z, .ptokendone2 
1fd4 fe 00			cp 0 
1fd6 28 08			jr z, .ptokendone2 
1fd8 fe 20			cp ' ' 
1fda 28 02			jr z, .ptmp2 
1fdc 18 ec			jr .ptokenstr2 
1fde			 
1fde			.ptmp2:	; we have a space so change to zero term for dict match later 
1fde				;dec hl 
1fde				;ld a,"-"	; TODO remove this when working 
1fde				;ld (hl), a 
1fde				;inc hl 
1fde 18 ea			jr .ptokenstr2 
1fe0			 
1fe0			.ptokendone2: 
1fe0				;inc hl 
1fe0 3e 7f			ld a, FORTH_END_BUFFER 
1fe2 77				ld (hl),a 
1fe3 23				inc hl 
1fe4 3e 21			ld a, '!' 
1fe6 77				ld (hl),a 
1fe7			 
1fe7 2a a4 f2			ld hl,(os_tok_ptr) 
1fea			         
1fea			if DEBUG_FORTH_TOK 
1fea						DMARK "TK1" 
1fea				CALLMONITOR 
1fea			endif 
1fea			 
1fea				; push exec string to top of return stack 
1fea				FORTH_RSP_NEXT 
1fea cd 9e 1b			call macro_forth_rsp_next 
1fed				endm 
# End of macro FORTH_RSP_NEXT
1fed c9				ret 
1fee			 
1fee			; 
1fee			;	; malloc size + buffer pointer + if is loop flag 
1fee			;	ld hl,(os_tok_len) 		 ; get string length 
1fee			; 
1fee			;	ld a,l 
1fee			; 
1fee			;	cp 0			; we dont want to use a null string 
1fee			;	ret z 
1fee			; 
1fee			;;	add 3    ; prefix malloc with buffer for current word ptr 
1fee			; 
1fee			;	add 5     ; TODO when certain not over writing memory remove 
1fee			; 
1fee			;		 
1fee			; 
1fee			;if DEBUG_FORTH_TOK 
1fee			;			DMARK "TKE" 
1fee			;	CALLMONITOR 
1fee			;endif 
1fee			; 
1fee			;	ld l,a 
1fee			;	ld h,0 
1fee			;;	push hl   ; save required space for the copy later 
1fee			;	call malloc 
1fee			;if DEBUG_FORTH_TOK 
1fee			;			DMARK "TKM" 
1fee			;	CALLMONITOR 
1fee			;endif 
1fee			;	if DEBUG_FORTH_MALLOC_GUARD 
1fee			;		push af 
1fee			;		call ishlzero 
1fee			;;		ld a, l 
1fee			;;		add h 
1fee			;;		cp 0 
1fee			;		pop af 
1fee			;		 
1fee			;		call z,malloc_error 
1fee			;	endif 
1fee			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1fee			; 
1fee			; 
1fee			;if DEBUG_FORTH_TOK 
1fee			;			DMARK "TKR" 
1fee			;	CALLMONITOR 
1fee			;endif 
1fee			; 
1fee			;	FORTH_RSP_NEXT 
1fee			; 
1fee			;	;inc hl	 ; go past current buffer pointer 
1fee			;	;inc hl 
1fee			;	;inc hl   ; and past if loop flag 
1fee			;		; TODO Need to set flag  
1fee			; 
1fee			;	 
1fee			;	 
1fee			;	ex de,hl	; malloc is dest 
1fee			;	ld hl, (os_tok_len) 
1fee			;;	pop bc 
1fee			;	ld c, l                
1fee			;	ld b,0 
1fee			;	ld hl, (os_tok_ptr) 
1fee			; 
1fee			;if DEBUG_FORTH_TOK 
1fee			;			DMARK "TKT" 
1fee			;	CALLMONITOR 
1fee			;endif 
1fee			; 
1fee			;	; do str cpy 
1fee			; 
1fee			;	ldir      ; copy byte in hl to de 
1fee			; 
1fee			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1fee			; 
1fee			;if DEBUG_FORTH_TOK 
1fee			; 
1fee			;			DMARK "TKY" 
1fee			;	CALLMONITOR 
1fee			;endif 
1fee			;	;ld a,0 
1fee			;	;ld a,FORTH_END_BUFFER 
1fee			;	ex de, hl 
1fee			;	;dec hl			 ; go back over the space delim at the end of word 
1fee			;	;ld (hl),a 
1fee			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1fee			;	ld a,FORTH_END_BUFFER 
1fee			;	ld (hl),a 
1fee			;	inc hl 
1fee			;	ld a,FORTH_END_BUFFER 
1fee			;	ld (hl),a 
1fee			; 
1fee			;	; init the malloc area data 
1fee			;	; set pc for in current area 
1fee			;	;ld hl, (os_tok_malloc) 
1fee			;	;inc hl 
1fee			;	;inc hl 
1fee			;	;inc hl 
1fee			;	;ex de,hl 
1fee			;	;ld hl, (os_tok_malloc) 
1fee			;	;ld (hl),e 
1fee			;	;inc hl 
1fee			;	;ld (hl),d 
1fee			; 
1fee			; 
1fee			;	ld hl,(os_tok_malloc) 
1fee			;if DEBUG_FORTH_PARSE_KEY 
1fee			;			DMARK "TKU" 
1fee			;	CALLMONITOR 
1fee			;endif 
1fee			; 
1fee			;	ret 
1fee			 
1fee			forthexec: 
1fee			 
1fee			; line exec: 
1fee			; forth parser 
1fee			 
1fee			; 
1fee			;       get current exec line on rsp 
1fee			 
1fee				FORTH_RSP_TOS 
1fee cd b5 1b			call macro_forth_rsp_tos 
1ff1				endm 
# End of macro FORTH_RSP_TOS
1ff1			 
1ff1			;       restore current pc - hl points to malloc of data 
1ff1			 
1ff1				;ld e, (hl) 
1ff1				;inc hl 
1ff1				;ld d, (hl) 
1ff1				;ex de,hl 
1ff1			 
1ff1			 
1ff1			exec1: 
1ff1 22 a4 f2			ld (os_tok_ptr), hl 
1ff4			 
1ff4				; copy our PC to working vars  
1ff4 22 ae f9			ld (cli_ptr), hl 
1ff7 22 ac f9			ld (cli_origptr), hl 
1ffa			 
1ffa 7e				ld a,(hl) 
1ffb fe 7f			cp FORTH_END_BUFFER 
1ffd c8				ret z 
1ffe			 
1ffe				; skip any nulls 
1ffe			 
1ffe fe 00			cp 0 
2000 20 03			jr nz, .execword 
2002 23				inc hl 
2003 18 ec			jr exec1 
2005			 
2005			 
2005			.execword: 
2005			 
2005			 
2005			 
2005			if DEBUG_FORTH_PARSE_KEY 
2005						DMARK "KYQ" 
2005				CALLMONITOR 
2005			endif 
2005			;       while at start of word: 
2005			; get start of dict (in user area first) 
2005			 
2005 21 00 80		ld hl, baseram 
2008			;ld hl, sysdict 
2008 22 b0 f9		ld (cli_nextword),hl 
200b			;           match word at pc 
200b			;           exec word 
200b			;           or push to dsp 
200b			;           forward to next token 
200b			;           if line term pop rsp and exit 
200b			;        
200b			 
200b			if DEBUG_FORTH_PARSE_KEY 
200b						DMARK "KYq" 
200b				CALLMONITOR 
200b			endif 
200b			 
200b			; 
200b			; word comp 
200b			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
200b			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
200b			;    move to start of word  
200b			;    compare word to cli_token 
200b			 
200b			.execpnword:	; HL at start of a word in the dictionary to check 
200b			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
200b			;	ld (cli_ptr), hl 
200b			 
200b 2a b0 f9			ld hl,(cli_nextword) 
200e			 
200e cd b1 20			call forth_tok_next 
2011			; tok next start here 
2011			;	; TODO skip compiled symbol for now 
2011			;	inc hl 
2011			; 
2011			;	; save pointer to next word 
2011			; 
2011			;	; hl now points to the address of the next word pointer  
2011			;	ld e, (hl) 
2011			;	inc hl 
2011			;	ld d, (hl) 
2011			;	inc l 
2011			; 
2011			;	ex de,hl 
2011			;if DEBUG_FORTH_PARSE_NEXTWORD 
2011			;	push bc 
2011			;	ld bc, (cli_nextword) 
2011			;			DMARK "NXW" 
2011			;	CALLMONITOR 
2011			;	pop bc 
2011			;endif 
2011			; tok next end here 
2011 22 b0 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
2014 eb				ex de, hl 
2015			 
2015			 
2015				; save the pointer of the current token - 1 to check against 
2015				 
2015 22 b4 f9			ld (cli_token), hl   
2018				; TODO maybe remove below save if no debug 
2018				; save token string ptr for any debug later 
2018 23				inc hl  
2019 22 b6 f9			ld (cli_origtoken), hl 
201c 2b				dec hl 
201d				; save pointer to the start of the next dictionay word 
201d 7e				ld a,(hl)   ; get string length 
201e 47				ld b,a 
201f			.execpnwordinc:  
201f 23				inc hl 
2020 10 fd			djnz .execpnwordinc 
2022 22 b2 f9			ld (cli_execword), hl      ; save start of this words code 
2025			 
2025				; now check the word token against the string being parsed 
2025			 
2025 2a b4 f9			ld hl,(cli_token) 
2028 23				inc hl     ; skip string length (use zero term instead to end) 
2029 22 b4 f9			ld (cli_token), hl 
202c			 
202c			if DEBUG_FORTH_PARSE_KEY 
202c						DMARK "KY2" 
202c			endif 
202c			if DEBUG_FORTH_PARSE_EXEC 
202c				; see if disabled 
202c			 
202c				ld a, (os_view_disable) 
202c				cp '*' 
202c				jr z, .skip 
202c			 
202c				push hl 
202c				push hl 
202c				call clear_display 
202c				ld de, .compword 
202c				ld a, display_row_1 
202c				call str_at_display 
202c				pop de 
202c				ld a, display_row_2 
202c				call str_at_display 
202c				ld hl,(cli_ptr) 
202c				ld a,(hl) 
202c			        ld hl, os_word_scratch 
202c				ld (hl),a 
202c				ld a,0 
202c				inc hl 
202c				ld (hl),a 	 
202c				ld de, os_word_scratch 
202c				ld a, display_row_2+10 
202c				call str_at_display 
202c				call update_display 
202c				ld a, 100 
202c				call aDelayInMS 
202c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
202c				call delay250ms 
202c				endif 
202c				pop hl 
202c			.skip:  
202c			endif	 
202c			.execpnchar:    ; compare char between token and string to parse 
202c			 
202c			if DEBUG_FORTH_PARSE_KEY 
202c						DMARK "Ky3" 
202c			endif 
202c			if DEBUG_FORTH_PARSE_EXEC 
202c				; see if disabled 
202c			 
202c				ld a, (os_view_disable) 
202c				cp '*' 
202c				jr z, .skip2 
202c			 
202c			;	call clear_display 
202c			ld hl,(cli_token) 
202c			ld a,(hl) 
202c			ld (os_word_scratch),a 
202c				ld hl,(cli_ptr) 
202c			ld a,(hl) 
202c				ld (os_word_scratch+1),a 
202c				ld a,0 
202c				ld (os_word_scratch+2),a 
202c				ld de,os_word_scratch 
202c				ld a,display_row_4 
202c				call str_at_display 
202c				call update_display 
202c			.skip2:  
202c			endif 
202c 2a b4 f9			ld hl,(cli_token) 
202f 7e				ld a, (hl)	 ; char in word token 
2030 23				inc hl 		; move to next char 
2031 22 b4 f9			ld (cli_token), hl ; and save it 
2034 47				ld b,a 
2035			 
2035 2a ae f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
2038 7e				ld a,(hl) 
2039 23				inc hl 
203a 22 ae f9			ld (cli_ptr), hl		; move to next char 
203d cd 5b 11			call toUpper 		; make sure the input string matches case 
2040			 
2040			if DEBUG_FORTH_PARSE 
2040			endif 
2040			 
2040				; input stream end of token is a space so get rid of it 
2040			 
2040			;	cp ' ' 
2040			;	jr nz, .pnskipspace 
2040			; 
2040			;	ld a, 0		; make same term as word token term 
2040			; 
2040			;.pnskipspace: 
2040			 
2040			if DEBUG_FORTH_PARSE_KEY 
2040						DMARK "KY7" 
2040			endif 
2040 b8				cp b 
2041 c2 57 20			jp nz, .execpnskipword	 ; no match so move to next word 
2044				 
2044			;    if same 
2044			;       scan for string terms 0 for token and 32 for input 
2044			 
2044				 
2044			if DEBUG_FORTH_PARSE_KEY 
2044						DMARK "KY8" 
2044			endif 
2044			 
2044 80				add b			 
2045 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2047							; TODO need to make sure last word in zero term string is accounted for 
2047 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2049			 
2049			 
2049				; at end of both strings so both are exact match 
2049			 
2049			;       skip ptr for next word 
2049			 
2049 2a ae f9			ld hl,(cli_ptr) 	; at input string term 
204c 23				inc hl			 ; at next char 
204d 22 ae f9			ld (cli_ptr), hl     ; save for next round of the parser 
2050 22 ac f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2053				 
2053				 
2053			if DEBUG_FORTH_PARSE_KEY 
2053						DMARK "KY3" 
2053			endif 
2053			 
2053			 
2053			 
2053			;       exec code block 
2053			if DEBUG_FORTH_JP 
2053				call clear_display 
2053				call update_display 
2053				call delay1s 
2053				ld hl, (cli_execword)     ; save for next check if no match on this word 
2053				ld a,h 
2053				ld hl, os_word_scratch 
2053				call hexout 
2053				ld hl, (cli_execword)     ; save for next check if no match on this word 
2053				ld a,l 
2053				ld hl, os_word_scratch+2 
2053				call hexout 
2053				ld hl, os_word_scratch+4 
2053				ld a,0 
2053				ld (hl),a 
2053				ld de,os_word_scratch 
2053				call str_at_display 
2053					ld a, display_row_2 
2053					call str_at_display 
2053				ld de, (cli_origtoken) 
2053				ld a, display_row_1+10 
2053					call str_at_display 
2053			 
2053				ld a,display_row_1 
2053				ld de, .foundword 
2053				ld a, display_row_3 
2053				call str_at_display 
2053				call update_display 
2053				call delay1s 
2053				call delay1s 
2053				call delay1s 
2053			endif 
2053			 
2053			if DEBUG_FORTH_PARSE_KEY 
2053						DMARK "KYj" 
2053			endif 
2053				; TODO save the word pointer in this exec 
2053			 
2053 2a b2 f9			ld hl,(cli_execword) 
2056 e9				jp (hl) 
2057			 
2057			 
2057			;    if not same 
2057			;	scan for zero term 
2057			;	get ptr for next word 
2057			;	goto word comp 
2057			 
2057			.execpnskipword:	; get pointer to next word 
2057 2a b0 f9			ld hl,(cli_nextword) 
205a			 
205a 7e				ld a,(hl) 
205b fe 00			cp WORD_SYS_END 
205d			;	cp 0 
205d 28 09			jr z, .execendofdict			 ; at end of words 
205f			 
205f			if DEBUG_FORTH_PARSE_KEY 
205f						DMARK "KY4" 
205f			endif 
205f			if DEBUG_FORTH_PARSE_EXEC 
205f			 
205f				; see if disabled 
205f			 
205f				ld a, (os_view_disable) 
205f				cp '*' 
205f				jr z, .noskip 
205f			 
205f			 
205f				ld de, .nowordfound 
205f				ld a, display_row_3 
205f				call str_at_display 
205f				call update_display 
205f				ld a, 100 
205f				call aDelayInMS 
205f				 
205f				if DEBUG_FORTH_PARSE_EXEC_SLOW 
205f					call delay250ms 
205f				endif 
205f			.noskip:  
205f			 
205f			endif	 
205f			 
205f 2a ac f9			ld hl,(cli_origptr) 
2062 22 ae f9			ld (cli_ptr),hl 
2065			 
2065			if DEBUG_FORTH_PARSE_KEY 
2065						DMARK "KY5" 
2065			endif 
2065 c3 0b 20			jp .execpnword			; else go to next word 
2068			 
2068			.execendofdict:  
2068			 
2068			if DEBUG_FORTH_PARSE_KEY 
2068						DMARK "KYe" 
2068			endif 
2068			if DEBUG_FORTH_PARSE_EXEC 
2068				; see if disabled 
2068			 
2068				ld a, (os_view_disable) 
2068				cp '*' 
2068				jr z, .ispskip 
2068			 
2068				call clear_display 
2068				call update_display 
2068				call delay1s 
2068				ld de, (cli_origptr) 
2068				ld a, display_row_1 
2068				call str_at_display 
2068				 
2068				ld de, .enddict 
2068				ld a, display_row_3 
2068				call str_at_display 
2068				call update_display 
2068				ld a, 100 
2068				call aDelayInMS 
2068				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2068				call delay1s 
2068				call delay1s 
2068				call delay1s 
2068				endif 
2068			.ispskip:  
2068				 
2068			endif	 
2068			 
2068			 
2068			 
2068				; if the word is not a keyword then must be a literal so push it to stack 
2068			 
2068			; push token to stack to end of word 
2068			 
2068				STACKFRAME ON $1efe $2f9f 
2068				if DEBUG_STACK_IMB 
2068					if ON 
2068						exx 
2068						ld de, $1efe 
2068						ld a, d 
2068						ld hl, curframe 
2068						call hexout 
2068						ld a, e 
2068						ld hl, curframe+2 
2068						call hexout 
2068						ld hl, $1efe 
2068						push hl 
2068						ld hl, $2f9f 
2068						push hl 
2068						exx 
2068					endif 
2068				endif 
2068			endm 
# End of macro STACKFRAME
2068			 
2068 2a a4 f2		ld hl,(os_tok_ptr) 
206b cd 60 1d		call forth_apush 
206e			 
206e				STACKFRAMECHK ON $1efe $2f9f 
206e				if DEBUG_STACK_IMB 
206e					if ON 
206e						exx 
206e						ld hl, $2f9f 
206e						pop de   ; $2f9f 
206e						call cmp16 
206e						jr nz, .spnosame 
206e						ld hl, $1efe 
206e						pop de   ; $1efe 
206e						call cmp16 
206e						jr z, .spfrsame 
206e						.spnosame: call showsperror 
206e						.spfrsame: nop 
206e						exx 
206e					endif 
206e				endif 
206e			endm 
# End of macro STACKFRAMECHK
206e			 
206e			execnext: 
206e			 
206e			if DEBUG_FORTH_PARSE_KEY 
206e						DMARK "KY>" 
206e			endif 
206e			; move past token to next word 
206e			 
206e 2a a4 f2		ld hl, (os_tok_ptr) 
2071 3e 00		ld a, 0 
2073 01 ff 00		ld bc, 255     ; input buffer size 
2076 ed b1		cpir 
2078			 
2078			if DEBUG_FORTH_PARSE_KEY 
2078						DMARK "KY!" 
2078				CALLMONITOR 
2078			endif	 
2078			; TODO this might place hl on the null, so will need to forward on??? 
2078			;inc hl   ; see if this gets onto the next item 
2078			 
2078			 
2078			; TODO pass a pointer to the buffer to push 
2078			; TODO call function to push 
2078			 
2078			; look for end of input 
2078			 
2078			;inc hl 
2078			;ld a,(hl) 
2078			;cp FORTH_END_BUFFER 
2078			;ret z 
2078			 
2078			 
2078 c3 f1 1f		jp exec1 
207b			 
207b			 
207b			 
207b			 
207b			 
207b			 
207b			 
207b			 
207b			 
207b			findnexttok: 
207b			 
207b				; hl is pointer to move 
207b				; de is the token to locate 
207b			 
207b					if DEBUG_FORTH 
207b						DMARK "NTK" 
207b						CALLMONITOR 
207b					endif 
207b d5				push de 
207c			 
207c			.fnt1:	 
207c				; find first char of token to locate 
207c			 
207c 1a				ld a, (de) 
207d 4f				ld c,a 
207e 7e				ld a,(hl) 
207f cd 5b 11			call toUpper 
2082					if DEBUG_FORTH 
2082						DMARK "NT1" 
2082						CALLMONITOR 
2082					endif 
2082 b9				cp c 
2083			 
2083 28 03			jr z, .fnt2cmpmorefirst	 
2085			 
2085				; first char not found move to next char 
2085			 
2085 23				inc hl 
2086 18 f4			jr .fnt1 
2088			 
2088			.fnt2cmpmorefirst:	 
2088				; first char of token found.  
2088			 
2088 e5				push hl     ; save start of token just in case it is the right one 
2089 d9				exx 
208a e1				pop hl        ; save it to hl' 
208b d9				exx 
208c			 
208c			 
208c			.fnt2cmpmore:	 
208c				; compare the rest 
208c				 
208c 23				inc hl 
208d 13				inc de 
208e				 
208e 1a				ld a, (de) 
208f 4f				ld c,a 
2090 7e				ld a,(hl) 
2091 cd 5b 11			call toUpper 
2094			 
2094					if DEBUG_FORTH 
2094						DMARK "NT2" 
2094						CALLMONITOR 
2094					endif 
2094				; c has the token to find char 
2094				; a has the mem to scan char 
2094			 
2094 b9				cp c 
2095 28 04			jr z,.fntmatch1 
2097			 
2097				; they are not the same 
2097			 
2097					if DEBUG_FORTH 
2097						DMARK "NT3" 
2097						CALLMONITOR 
2097					endif 
2097 d1				pop de	; reset de token to look for 
2098 d5				push de 
2099 18 e1			jr .fnt1 
209b				 
209b			.fntmatch1: 
209b			 
209b				; is the same char a null which means we might have a full hit? 
209b					if DEBUG_FORTH 
209b						DMARK "NT4" 
209b						CALLMONITOR 
209b					endif 
209b			 
209b fe 00			cp 0 
209d 28 0b			jr z, .fntmatchyes 
209f			 
209f				; are we at the end of the token to find? 
209f			 
209f					if DEBUG_FORTH 
209f						DMARK "NT5" 
209f						CALLMONITOR 
209f					endif 
209f 3e 00			ld a, 0 
20a1 b9				cp c 
20a2			 
20a2 c2 8c 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
20a5			 
20a5					if DEBUG_FORTH 
20a5						DMARK "NT6" 
20a5						CALLMONITOR 
20a5					endif 
20a5				; token to find is exhusted but no match to stream 
20a5			 
20a5				; restore tok pointer and continue on 
20a5 d1				pop de 
20a6 d5				push de 
20a7 c3 7c 20			jp .fnt1 
20aa			 
20aa			 
20aa			.fntmatchyes: 
20aa			 
20aa				; hl now contains the end of the found token 
20aa			 
20aa				; get rid of saved token pointer to find 
20aa			 
20aa d1				pop de 
20ab			 
20ab					if DEBUG_FORTH 
20ab						DMARK "NT9" 
20ab						CALLMONITOR 
20ab					endif 
20ab			 
20ab				; hl will be on the null term so forward on 
20ab			 
20ab				; get back the saved start of the token 
20ab			 
20ab d9				exx 
20ac e5				push hl     ; save start of token just in case it is the right one 
20ad d9				exx 
20ae e1				pop hl        ; save it to hl 
20af			 
20af c9				ret 
20b0			 
20b0			 
20b0			; LIST needs to find a specific token   
20b0			; FORGET needs to find a spefici token 
20b0			 
20b0			; SAVE needs to find all tokens by flag 
20b0			; WORDS just needs to scan through all  by flag 
20b0			; UWORDS needs to scan through all by flag 
20b0			 
20b0			 
20b0			; given hl as pointer to start of dict look up string 
20b0			; return hl as pointer to start of word block 
20b0			; or 0 if not found 
20b0			 
20b0			forth_find_tok: 
20b0 c9				ret 
20b1			 
20b1			; given hl as pointer to dict structure 
20b1			; move to the next dict block structure 
20b1			 
20b1			forth_tok_next: 
20b1				; hl now points to the address of the next word pointer  
20b1				; TODO skip compiled symbol for now 
20b1			;	push de 
20b1 23				inc hl 
20b2 5e				ld e, (hl) 
20b3 23				inc hl 
20b4 56				ld d, (hl) 
20b5 23				inc hl 
20b6			 
20b6 eb				ex de,hl 
20b7			if DEBUG_FORTH_PARSE_NEXTWORD 
20b7				push bc 
20b7				ld bc, (cli_nextword) 
20b7						DMARK "NXW" 
20b7				CALLMONITOR 
20b7				pop bc 
20b7			endif 
20b7			;	pop de	 
20b7 c9				ret 
20b8			 
20b8			 
20b8			 
20b8			; eof 
# End of file forth_parserv5.asm
20b8				include "forth_wordsv4.asm" 
20b8			 
20b8			; the core word dictionary v4 
20b8			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
20b8			 
20b8			; this is a linked list for each of the system words used 
20b8			; user defined words will follow the same format but will be in ram 
20b8			 
20b8			 
20b8			; 
20b8			; 
20b8			; define linked list: 
20b8			; 
20b8			; 1. compiled byte op code 
20b8			; 2. len of text word 
20b8			; 3. text word 
20b8			; 4. ptr to next dictionary word 
20b8			; 5. asm, calls etc for the word 
20b8			; 
20b8			;  if 1 == 0 then last word in dict  
20b8			;   
20b8			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
20b8			;  
20b8			;  
20b8			; create basic standard set of words 
20b8			; 
20b8			;  
20b8			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
20b8			; 2DUP 2DROP 2SWAP  
20b8			; @ C@ - get byte  
20b8			; ! C! - store byte 
20b8			; 0< true if less than zero 
20b8			; 0= true if zero 
20b8			; < >  
20b8			; = true if same 
20b8			; variables 
20b8			 
20b8			 
20b8			; Hardware specific words I may need 
20b8			; 
20b8			; IN OUT  
20b8			; calls to key util functions 
20b8			; calls to hardward abstraction stuff 
20b8			; easy control of frame buffers and lcd i/o 
20b8			; keyboard  
20b8			 
20b8			 
20b8			;DICT: macro 
20b8			; op_code, len, word, next 
20b8			;    word: 
20b8			;    db op_code 
20b8			;    ds word zero term 
20b8			;    dw next 
20b8			;    endm 
20b8			 
20b8			 
20b8			 
20b8			 
20b8			; op code 1 is a flag for user define words which are to be handled differently 
20b8			 
20b8			 
20b8			; 
20b8			; 
20b8			;    TODO on entry to a word this should be the expected environment 
20b8			;    hl - tos value if number then held, if string this is the ptr 
20b8			;    de -  
20b8			 
20b8			 
20b8			; opcode ranges 
20b8			; 0 - end of word dict 
20b8			; 255 - user define words 
20b8			 
20b8			sysdict: 
20b8			include "forth_opcodes.asm" 
20b8			; op codes for forth keywords 
20b8			; free to use code 0  
20b8				OPCODE_HEAP: equ  1 
20b8				OPCODE_EXEC: equ 2 
20b8				OPCODE_DUP: equ 3 
20b8				OPCODE_SWAP: equ 4 
20b8				OPCODE_COLN: equ 5 
20b8				OPCODE_SCOLN: equ 6 
20b8				OPCODE_DROP: equ 7 
20b8				OPCODE_DUP2: equ 8 
20b8				OPCODE_DROP2: equ 9 
20b8				OPCODE_SWAP2: equ 10 
20b8				OPCODE_AT: equ 11 
20b8				OPCODE_CAT: equ 12 
20b8				OPCODE_BANG: equ 13 
20b8				OPCODE_CBANG: equ 14 
20b8				OPCODE_SCALL: equ 15 
20b8				OPCODE_DEPTH: equ 16 
20b8				OPCODE_OVER: equ 17 
20b8				OPCODE_PAUSE: equ 18 
20b8				OPCODE_PAUSES: equ 19 
20b8				OPCODE_ROT: equ 20 
20b8			;free to reuse	OPCODE_WORDS: equ 21 
20b8			        OPCODE_NOT: equ 21 
20b8				OPCODE_UWORDS: equ 22 
20b8				OPCODE_BP: equ 23 
20b8				OPCODE_MONITOR: equ 24  
20b8				OPCODE_MALLOC: equ 25 
20b8				OPCODE_FREE: equ 26 
20b8				OPCODE_LIST: equ 27 
20b8				OPCODE_FORGET: equ 28 
20b8				OPCODE_NOP: equ 29 
20b8				OPCODE_COMO: equ 30 
20b8				OPCODE_COMC: equ 31 
20b8			;free to reuse	OPCODE_ENDCORE: equ 32 
20b8				OPCODE_AFTERSOUND: equ 33 
20b8				OPCODE_GP2: equ 34 
20b8				OPCODE_GP3: equ 35 
20b8				OPCODE_GP4: equ 36 
20b8				OPCODE_SIN: equ 37 
20b8				OPCODE_SOUT: equ 38 
20b8				OPCODE_SPIO: equ 39 
20b8				OPCODE_SPICEH: equ 40 
20b8				OPCODE_SPIOb: equ 41 
20b8				OPCODE_SPII: equ 42 
20b8				OPCODE_SESEL: equ 43 
20b8				OPCODE_CARTDEV: equ 44 
20b8			; free to reuse	OPCODE_ENDDEVICE: equ 45 
20b8				OPCODE_FB: equ 46 
20b8				OPCODE_EMIT: equ 47 
20b8				OPCODE_DOTH: equ 48 
20b8				OPCODE_DOTF: equ 49 
20b8				OPCODE_DOT: equ 50 
20b8				OPCODE_CLS: equ 51 
20b8				OPCODE_DRAW: equ 52 
20b8				OPCODE_DUMP: equ 53 
20b8				OPCODE_CDUMP: equ 54 
20b8				OPCODE_DAT: equ 55 
20b8				OPCODE_HOME: equ 56 
20b8				OPCODE_SPACE: equ 57 
20b8				OPCODE_SPACES: equ 58 
20b8				OPCODE_SCROLL: equ 59 
20b8				OPCODE_ATQ: equ 60 
20b8				OPCODE_AUTODSP: equ 61 
20b8				OPCODE_MENU: equ 62 
20b8			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
20b8				OPCODE_THEN: equ 64 
20b8				OPCODE_ELSE: equ 65 
20b8				OPCODE_DO: equ 66 
20b8				OPCODE_LOOP: equ 67 
20b8				OPCODE_I: equ 68 
20b8				OPCODE_DLOOP: equ 69  
20b8				OPCODE_REPEAT: equ 70  
20b8				OPCODE_UNTIL: equ 71 
20b8				OPCODE_ENDFLOW: equ 72 
20b8				OPCODE_WAITK: equ 73 
20b8				OPCODE_ACCEPT: equ 74 
20b8				OPCODE_EDIT: equ 75 
20b8			;free to reuse	OPCODE_ENDKEY: equ 76 
20b8				OPCODE_LZERO: equ 77 
20b8				OPCODE_TZERO: equ 78 
20b8				OPCODE_LESS: equ 79 
20b8				OPCODE_GT: equ 80 
20b8				OPCODE_EQUAL: equ 81  
20b8			;free to reuse	OPCODE_ENDLOGIC: equ 82 
20b8				OPCODE_NEG: equ 83 
20b8				OPCODE_DIV: equ 84 
20b8				OPCODE_MUL: equ 85 
20b8				OPCODE_MIN: equ 86 
20b8				OPCODE_MAX: equ 87 
20b8				OPCODE_RND16: equ 88 
20b8				OPCODE_RND8: equ 89 
20b8				OPCODE_RND: equ 90 
20b8			;free to reuse	OPCODE_ENDMATHS: equ 91  
20b8				OPCODE_BYNAME: equ 92 
20b8				OPCODE_DIR: equ 93 
20b8				OPCODE_SAVE: equ 94 
20b8				OPCODE_LOAD: equ 95 
20b8				OPCODE_BSAVE: equ 96 
20b8				OPCODE_BLOAD: equ 97 
20b8				OPCODE_SEO: equ 98  
20b8				OPCODE_SEI: equ 99 
20b8				OPCODE_SFREE: equ 100 
20b8				OPCODE_SIZE: equ 101 
20b8				OPCODE_CREATE: equ 102 
20b8				OPCODE_APPEND: equ 103 
20b8				OPCODE_SDEL: equ 104 
20b8				OPCODE_OPEN: equ 105 
20b8				OPCODE_READ: equ 106 
20b8				OPCODE_EOF: equ 106 
20b8				OPCODE_FORMAT: equ 107 
20b8				OPCODE_LABEL: equ 108 
20b8				OPCODE_LABELS: equ 109 
20b8			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
20b8				OPCODE_UPPER: equ 111 
20b8				OPCODE_LOWER: equ 112 
20b8				OPCODE_SUBSTR: equ 113 
20b8				OPCODE_LEFT: equ 114 
20b8				OPCODE_RIGHT: equ 115 
20b8				OPCODE_STR2NUM: equ 116 
20b8				OPCODE_NUM2STR: equ 117 
20b8				OPCODE_CONCAT: equ 118 
20b8				OPCODE_FIND: equ 119 
20b8				OPCODE_LEN: equ 120 
20b8				OPCODE_CHAR: equ 121 
20b8			; free to reuse	OPCODE_STRLEN: equ 122 
20b8			; free to reuse	OPCODE_ENDSTR: equ 123 
20b8				OPCODE_V0S: equ 124 
20b8				OPCODE_V0Q: equ 125 
20b8				OPCODE_V1S: equ 126 
20b8				OPCODE_V1Q: equ 127 
20b8				OPCODE_V2S: equ 128 
20b8				OPCODE_V2Q: equ 129 
20b8				OPCODE_V3S: equ 130 
20b8				OPCODE_V3Q: equ 131 
20b8			;free to reuse	OPCODE_END: equ 132 
20b8				OPCODE_ZDUP: equ 133 
20b8			 
20b8			; eof 
# End of file forth_opcodes.asm
20b8			 
20b8			include "forth_words_core.asm" 
20b8			 
20b8			; | ## Core Words 
20b8			 
20b8			;if MALLOC_4 
20b8			 
20b8			.HEAP: 
20b8				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
20b8 15				db WORD_SYS_CORE+OPCODE_HEAP             
20b9 f7 20			dw .EXEC            
20bb 05				db 4 + 1 
20bc .. 00			db "HEAP",0              
20c1				endm 
# End of macro CWHEAD
20c1			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
20c1			; | | u1 - Current number of bytes in the heap 
20c1			; | | u2 - Remaining bytes left on the heap 
20c1			; | |  
20c1			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
20c1			 
20c1			 
20c1					if DEBUG_FORTH_WORDS_KEY 
20c1						DMARK "HEP" 
20c1 f5				push af  
20c2 3a d6 20			ld a, (.dmark)  
20c5 32 bd fb			ld (debug_mark),a  
20c8 3a d7 20			ld a, (.dmark+1)  
20cb 32 be fb			ld (debug_mark+1),a  
20ce 3a d8 20			ld a, (.dmark+2)  
20d1 32 bf fb			ld (debug_mark+2),a  
20d4 18 03			jr .pastdmark  
20d6 ..			.dmark: db "HEP"  
20d9 f1			.pastdmark: pop af  
20da			endm  
# End of macro DMARK
20da						CALLMONITOR 
20da cd 6a 16			call break_point_state  
20dd				endm  
# End of macro CALLMONITOR
20dd					endif 
20dd 2a 0a 80				ld hl, (free_list )      
20e0 11 0e 80				ld de, heap_start 
20e3			 
20e3 ed 52				sbc hl, de  
20e5			 
20e5 cd f7 1b				call forth_push_numhl 
20e8			 
20e8			 
20e8 ed 5b 0a 80			ld de, (free_list )      
20ec 21 89 ef				ld hl, heap_end 
20ef			 
20ef ed 52				sbc hl, de 
20f1			 
20f1 cd f7 1b				call forth_push_numhl 
20f4					 
20f4			 
20f4					 
20f4			 
20f4			 
20f4			 
20f4					NEXTW 
20f4 c3 60 1f			jp macro_next 
20f7				endm 
# End of macro NEXTW
20f7			;endif 
20f7			 
20f7			.EXEC: 
20f7				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
20f7 16				db WORD_SYS_CORE+OPCODE_EXEC             
20f8 93 21			dw .STKEXEC            
20fa 05				db 4 + 1 
20fb .. 00			db "EXEC",0              
2100				endm 
# End of macro CWHEAD
2100			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
2100			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2100			; | | 
2100			; | |   
2100				STACKFRAME OFF $5efe $5f9f 
2100				if DEBUG_STACK_IMB 
2100					if OFF 
2100						exx 
2100						ld de, $5efe 
2100						ld a, d 
2100						ld hl, curframe 
2100						call hexout 
2100						ld a, e 
2100						ld hl, curframe+2 
2100						call hexout 
2100						ld hl, $5efe 
2100						push hl 
2100						ld hl, $5f9f 
2100						push hl 
2100						exx 
2100					endif 
2100				endif 
2100			endm 
# End of macro STACKFRAME
2100			 
2100					if DEBUG_FORTH_WORDS_KEY 
2100						DMARK "EXE" 
2100 f5				push af  
2101 3a 15 21			ld a, (.dmark)  
2104 32 bd fb			ld (debug_mark),a  
2107 3a 16 21			ld a, (.dmark+1)  
210a 32 be fb			ld (debug_mark+1),a  
210d 3a 17 21			ld a, (.dmark+2)  
2110 32 bf fb			ld (debug_mark+2),a  
2113 18 03			jr .pastdmark  
2115 ..			.dmark: db "EXE"  
2118 f1			.pastdmark: pop af  
2119			endm  
# End of macro DMARK
2119						CALLMONITOR 
2119 cd 6a 16			call break_point_state  
211c				endm  
# End of macro CALLMONITOR
211c					endif 
211c			 
211c				FORTH_DSP_VALUEHL 
211c cd ee 1d			call macro_dsp_valuehl 
211f				endm 
# End of macro FORTH_DSP_VALUEHL
211f			 
211f				FORTH_DSP_POP 
211f cd a6 1e			call macro_forth_dsp_pop 
2122				endm 
# End of macro FORTH_DSP_POP
2122			 
2122					if DEBUG_FORTH_WORDS 
2122						DMARK "EX1" 
2122 f5				push af  
2123 3a 37 21			ld a, (.dmark)  
2126 32 bd fb			ld (debug_mark),a  
2129 3a 38 21			ld a, (.dmark+1)  
212c 32 be fb			ld (debug_mark+1),a  
212f 3a 39 21			ld a, (.dmark+2)  
2132 32 bf fb			ld (debug_mark+2),a  
2135 18 03			jr .pastdmark  
2137 ..			.dmark: db "EX1"  
213a f1			.pastdmark: pop af  
213b			endm  
# End of macro DMARK
213b						CALLMONITOR 
213b cd 6a 16			call break_point_state  
213e				endm  
# End of macro CALLMONITOR
213e					endif 
213e			;	ld e,(hl) 
213e			;	inc hl 
213e			;	ld d,(hl) 
213e			;	ex de,hl 
213e			 
213e			;		if DEBUG_FORTH_WORDS 
213e			;			DMARK "EX2" 
213e			;			CALLMONITOR 
213e			;		endif 
213e e5				push hl 
213f			 
213f				;ld a, 0 
213f				;ld a, FORTH_END_BUFFER 
213f cd 64 11			call strlenz 
2142 23				inc hl   ; include zero term to copy 
2143 23				inc hl   ; include term 
2144 23				inc hl   ; include term 
2145 06 00			ld b,0 
2147 4d				ld c,l 
2148 e1				pop hl 
2149 11 a2 f0			ld de, execscratch 
214c					if DEBUG_FORTH_WORDS 
214c						DMARK "EX3" 
214c f5				push af  
214d 3a 61 21			ld a, (.dmark)  
2150 32 bd fb			ld (debug_mark),a  
2153 3a 62 21			ld a, (.dmark+1)  
2156 32 be fb			ld (debug_mark+1),a  
2159 3a 63 21			ld a, (.dmark+2)  
215c 32 bf fb			ld (debug_mark+2),a  
215f 18 03			jr .pastdmark  
2161 ..			.dmark: db "EX3"  
2164 f1			.pastdmark: pop af  
2165			endm  
# End of macro DMARK
2165						CALLMONITOR 
2165 cd 6a 16			call break_point_state  
2168				endm  
# End of macro CALLMONITOR
2168					endif 
2168 ed b0			ldir 
216a			 
216a			 
216a 21 a2 f0			ld hl, execscratch 
216d			 
216d					if DEBUG_FORTH_WORDS 
216d						DMARK "EXe" 
216d f5				push af  
216e 3a 82 21			ld a, (.dmark)  
2171 32 bd fb			ld (debug_mark),a  
2174 3a 83 21			ld a, (.dmark+1)  
2177 32 be fb			ld (debug_mark+1),a  
217a 3a 84 21			ld a, (.dmark+2)  
217d 32 bf fb			ld (debug_mark+2),a  
2180 18 03			jr .pastdmark  
2182 ..			.dmark: db "EXe"  
2185 f1			.pastdmark: pop af  
2186			endm  
# End of macro DMARK
2186						CALLMONITOR 
2186 cd 6a 16			call break_point_state  
2189				endm  
# End of macro CALLMONITOR
2189					endif 
2189			 
2189 cd ae 1f			call forthparse 
218c cd ee 1f			call forthexec 
218f			;	call forthexec_cleanup 
218f			;	call forthparse 
218f			;	call forthexec 
218f			 
218f				STACKFRAMECHK OFF $5efe $5f9f 
218f				if DEBUG_STACK_IMB 
218f					if OFF 
218f						exx 
218f						ld hl, $5f9f 
218f						pop de   ; $5f9f 
218f						call cmp16 
218f						jr nz, .spnosame 
218f						ld hl, $5efe 
218f						pop de   ; $5efe 
218f						call cmp16 
218f						jr z, .spfrsame 
218f						.spnosame: call showsperror 
218f						.spfrsame: nop 
218f						exx 
218f					endif 
218f				endif 
218f			endm 
# End of macro STACKFRAMECHK
218f			 
218f				; an immediate word so no need to process any more words 
218f c9				ret 
2190				NEXTW 
2190 c3 60 1f			jp macro_next 
2193				endm 
# End of macro NEXTW
2193			 
2193			; dead code - old version  
2193			;	FORTH_RSP_NEXT 
2193			 
2193			;  
2193			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2193			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2193			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2193			;	push hl 
2193			;	push de 
2193			;	push bc 
2193			; 
2193			; 
2193			;		if DEBUG_FORTH_WORDS_KEY 
2193			;			DMARK "EXR" 
2193			;			CALLMONITOR 
2193			;		endif 
2193			; 
2193			; 
2193			; 
2193			;	;v5 FORTH_DSP_VALUE 
2193			;	FORTH_DSP_VALUEHL 
2193			; 
2193			;	; TODO do string type checks 
2193			; 
2193			;;v5	inc hl   ; skip type 
2193			; 
2193			;	push hl  ; source code  
2193			;		if DEBUG_FORTH_WORDS 
2193			;			DMARK "EX1" 
2193			;			CALLMONITOR 
2193			;		endif 
2193			;	ld a, 0 
2193			;	call strlent 
2193			; 
2193			;	inc hl 
2193			;	inc hl 
2193			;	inc hl 
2193			;	inc hl 
2193			; 
2193			;	push hl    ; size 
2193			; 
2193			;		if DEBUG_FORTH_WORDS 
2193			;			DMARK "EX2" 
2193			;			CALLMONITOR 
2193			;		endif 
2193			;	call malloc 
2193			; 
2193			;	ex de, hl    ; de now contains malloc area 
2193			;	pop bc   	; get byte count 
2193			;	pop hl      ; get string to copy 
2193			; 
2193			;	push de     ; save malloc for free later 
2193			; 
2193			;		if DEBUG_FORTH_WORDS 
2193			;			DMARK "EX3" 
2193			;			CALLMONITOR 
2193			;		endif 
2193			;	ldir       ; duplicate string 
2193			; 
2193			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2193			;	 
2193			;	; TODO fix the parse would be better than this...  
2193			;	ex de, hl 
2193			;	dec hl 
2193			;	ld a, 0 
2193			;	ld (hl), a 
2193			;	dec hl 
2193			;	ld a, ' ' 
2193			;	ld (hl), a 
2193			;	dec hl 
2193			;	ld (hl), a 
2193			; 
2193			;	dec hl 
2193			;	ld (hl), a 
2193			; 
2193			; 
2193			;	FORTH_DSP_POP  
2193			; 
2193			;	pop hl     
2193			;	push hl    ; save malloc area 
2193			; 
2193			;		if DEBUG_FORTH_WORDS 
2193			;			DMARK "EX4" 
2193			;			CALLMONITOR 
2193			;		endif 
2193			; 
2193			;	call forthparse 
2193			;	call forthexec 
2193			;	 
2193			;	pop hl 
2193			;	if DEBUG_FORTH_WORDS 
2193			;		DMARK "EX5" 
2193			;		CALLMONITOR 
2193			;	endif 
2193			; 
2193			;	if FORTH_ENABLE_FREE 
2193			;	call free 
2193			;	endif 
2193			; 
2193			;	if DEBUG_FORTH_WORDS 
2193			;		DMARK "EX6" 
2193			;		CALLMONITOR 
2193			;	endif 
2193			; 
2193			;	pop bc 
2193			;	pop de 
2193			;	pop hl 
2193			;;	FORTH_RSP_POP	  
2193			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2193			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2193			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2193			; 
2193			;	if DEBUG_FORTH_WORDS 
2193			;		DMARK "EX7" 
2193			;		CALLMONITOR 
2193			;	endif 
2193			;	NEXTW 
2193			 
2193			.STKEXEC: 
2193				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2193 3f				db WORD_SYS_CORE+43             
2194 db 22			dw .ZDUP            
2196 08				db 7 + 1 
2197 .. 00			db "STKEXEC",0              
219f				endm 
# End of macro CWHEAD
219f			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
219f			 
219f			 
219f					if DEBUG_FORTH_WORDS_KEY 
219f						DMARK "STX" 
219f f5				push af  
21a0 3a b4 21			ld a, (.dmark)  
21a3 32 bd fb			ld (debug_mark),a  
21a6 3a b5 21			ld a, (.dmark+1)  
21a9 32 be fb			ld (debug_mark+1),a  
21ac 3a b6 21			ld a, (.dmark+2)  
21af 32 bf fb			ld (debug_mark+2),a  
21b2 18 03			jr .pastdmark  
21b4 ..			.dmark: db "STX"  
21b7 f1			.pastdmark: pop af  
21b8			endm  
# End of macro DMARK
21b8						CALLMONITOR 
21b8 cd 6a 16			call break_point_state  
21bb				endm  
# End of macro CALLMONITOR
21bb					endif 
21bb			 
21bb				FORTH_DSP_VALUEHL 
21bb cd ee 1d			call macro_dsp_valuehl 
21be				endm 
# End of macro FORTH_DSP_VALUEHL
21be			 
21be 22 e6 f9			ld (store_tmp1), hl    ; count 
21c1			 
21c1				FORTH_DSP_POP 
21c1 cd a6 1e			call macro_forth_dsp_pop 
21c4				endm 
# End of macro FORTH_DSP_POP
21c4			.stkexec1: 
21c4 2a e6 f9			ld hl, (store_tmp1)   ; count 
21c7 3e 00			ld a, 0 
21c9 bd				cp l 
21ca c8				ret z 
21cb			 
21cb 2b				dec hl 
21cc 22 e6 f9			ld (store_tmp1), hl    ; count 
21cf				 
21cf				FORTH_DSP_VALUEHL 
21cf cd ee 1d			call macro_dsp_valuehl 
21d2				endm 
# End of macro FORTH_DSP_VALUEHL
21d2 e5				push hl 
21d3				 
21d3					if DEBUG_FORTH_WORDS 
21d3						DMARK "EXp" 
21d3 f5				push af  
21d4 3a e8 21			ld a, (.dmark)  
21d7 32 bd fb			ld (debug_mark),a  
21da 3a e9 21			ld a, (.dmark+1)  
21dd 32 be fb			ld (debug_mark+1),a  
21e0 3a ea 21			ld a, (.dmark+2)  
21e3 32 bf fb			ld (debug_mark+2),a  
21e6 18 03			jr .pastdmark  
21e8 ..			.dmark: db "EXp"  
21eb f1			.pastdmark: pop af  
21ec			endm  
# End of macro DMARK
21ec						CALLMONITOR 
21ec cd 6a 16			call break_point_state  
21ef				endm  
# End of macro CALLMONITOR
21ef					endif 
21ef				FORTH_DSP_POP 
21ef cd a6 1e			call macro_forth_dsp_pop 
21f2				endm 
# End of macro FORTH_DSP_POP
21f2			 
21f2 cd 64 11			call strlenz 
21f5 23				inc hl   ; include zero term to copy 
21f6 23				inc hl   ; include zero term to copy 
21f7 23				inc hl   ; include zero term to copy 
21f8 06 00			ld b,0 
21fa 4d				ld c,l 
21fb e1				pop hl 
21fc 11 a2 f0			ld de, execscratch 
21ff					if DEBUG_FORTH_WORDS 
21ff						DMARK "EX3" 
21ff f5				push af  
2200 3a 14 22			ld a, (.dmark)  
2203 32 bd fb			ld (debug_mark),a  
2206 3a 15 22			ld a, (.dmark+1)  
2209 32 be fb			ld (debug_mark+1),a  
220c 3a 16 22			ld a, (.dmark+2)  
220f 32 bf fb			ld (debug_mark+2),a  
2212 18 03			jr .pastdmark  
2214 ..			.dmark: db "EX3"  
2217 f1			.pastdmark: pop af  
2218			endm  
# End of macro DMARK
2218						CALLMONITOR 
2218 cd 6a 16			call break_point_state  
221b				endm  
# End of macro CALLMONITOR
221b					endif 
221b ed b0			ldir 
221d			 
221d			 
221d 21 a2 f0			ld hl, execscratch 
2220			 
2220					if DEBUG_FORTH_WORDS 
2220						DMARK "EXP" 
2220 f5				push af  
2221 3a 35 22			ld a, (.dmark)  
2224 32 bd fb			ld (debug_mark),a  
2227 3a 36 22			ld a, (.dmark+1)  
222a 32 be fb			ld (debug_mark+1),a  
222d 3a 37 22			ld a, (.dmark+2)  
2230 32 bf fb			ld (debug_mark+2),a  
2233 18 03			jr .pastdmark  
2235 ..			.dmark: db "EXP"  
2238 f1			.pastdmark: pop af  
2239			endm  
# End of macro DMARK
2239						CALLMONITOR 
2239 cd 6a 16			call break_point_state  
223c				endm  
# End of macro CALLMONITOR
223c					endif 
223c			 
223c cd ae 1f			call forthparse 
223f 21 a2 f0			ld hl, execscratch 
2242					if DEBUG_FORTH_WORDS 
2242						DMARK "EXx" 
2242 f5				push af  
2243 3a 57 22			ld a, (.dmark)  
2246 32 bd fb			ld (debug_mark),a  
2249 3a 58 22			ld a, (.dmark+1)  
224c 32 be fb			ld (debug_mark+1),a  
224f 3a 59 22			ld a, (.dmark+2)  
2252 32 bf fb			ld (debug_mark+2),a  
2255 18 03			jr .pastdmark  
2257 ..			.dmark: db "EXx"  
225a f1			.pastdmark: pop af  
225b			endm  
# End of macro DMARK
225b						CALLMONITOR 
225b cd 6a 16			call break_point_state  
225e				endm  
# End of macro CALLMONITOR
225e					endif 
225e cd ee 1f			call forthexec 
2261			 
2261 c3 c4 21			jp .stkexec1 
2264			 
2264 c9				ret 
2265			 
2265			 
2265			.DUP: 
2265				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2265 17				db WORD_SYS_CORE+OPCODE_DUP             
2266 db 22			dw .ZDUP            
2268 04				db 3 + 1 
2269 .. 00			db "DUP",0              
226d				endm 
# End of macro CWHEAD
226d			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
226d			 
226d					if DEBUG_FORTH_WORDS_KEY 
226d						DMARK "DUP" 
226d f5				push af  
226e 3a 82 22			ld a, (.dmark)  
2271 32 bd fb			ld (debug_mark),a  
2274 3a 83 22			ld a, (.dmark+1)  
2277 32 be fb			ld (debug_mark+1),a  
227a 3a 84 22			ld a, (.dmark+2)  
227d 32 bf fb			ld (debug_mark+2),a  
2280 18 03			jr .pastdmark  
2282 ..			.dmark: db "DUP"  
2285 f1			.pastdmark: pop af  
2286			endm  
# End of macro DMARK
2286						CALLMONITOR 
2286 cd 6a 16			call break_point_state  
2289				endm  
# End of macro CALLMONITOR
2289					endif 
2289			 
2289					FORTH_DSP 
2289 cd b4 1d			call macro_forth_dsp 
228c				endm 
# End of macro FORTH_DSP
228c			 
228c 7e					ld a, (HL) 
228d fe 01				cp DS_TYPE_STR 
228f 20 25				jr nz, .dupinum 
2291			 
2291					; push another string 
2291			 
2291					FORTH_DSP_VALUEHL     		 
2291 cd ee 1d			call macro_dsp_valuehl 
2294				endm 
# End of macro FORTH_DSP_VALUEHL
2294			 
2294				if DEBUG_FORTH_WORDS 
2294					DMARK "DUs" 
2294 f5				push af  
2295 3a a9 22			ld a, (.dmark)  
2298 32 bd fb			ld (debug_mark),a  
229b 3a aa 22			ld a, (.dmark+1)  
229e 32 be fb			ld (debug_mark+1),a  
22a1 3a ab 22			ld a, (.dmark+2)  
22a4 32 bf fb			ld (debug_mark+2),a  
22a7 18 03			jr .pastdmark  
22a9 ..			.dmark: db "DUs"  
22ac f1			.pastdmark: pop af  
22ad			endm  
# End of macro DMARK
22ad					CALLMONITOR 
22ad cd 6a 16			call break_point_state  
22b0				endm  
# End of macro CALLMONITOR
22b0				endif 
22b0 cd 65 1c				call forth_push_str 
22b3			 
22b3					NEXTW 
22b3 c3 60 1f			jp macro_next 
22b6				endm 
# End of macro NEXTW
22b6			 
22b6			 
22b6			.dupinum: 
22b6					 
22b6			 
22b6			 
22b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22b6 cd ee 1d			call macro_dsp_valuehl 
22b9				endm 
# End of macro FORTH_DSP_VALUEHL
22b9			 
22b9				; TODO add floating point number detection 
22b9			 
22b9				if DEBUG_FORTH_WORDS 
22b9					DMARK "DUi" 
22b9 f5				push af  
22ba 3a ce 22			ld a, (.dmark)  
22bd 32 bd fb			ld (debug_mark),a  
22c0 3a cf 22			ld a, (.dmark+1)  
22c3 32 be fb			ld (debug_mark+1),a  
22c6 3a d0 22			ld a, (.dmark+2)  
22c9 32 bf fb			ld (debug_mark+2),a  
22cc 18 03			jr .pastdmark  
22ce ..			.dmark: db "DUi"  
22d1 f1			.pastdmark: pop af  
22d2			endm  
# End of macro DMARK
22d2					CALLMONITOR 
22d2 cd 6a 16			call break_point_state  
22d5				endm  
# End of macro CALLMONITOR
22d5				endif 
22d5			 
22d5 cd f7 1b				call forth_push_numhl 
22d8					NEXTW 
22d8 c3 60 1f			jp macro_next 
22db				endm 
# End of macro NEXTW
22db			.ZDUP: 
22db				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
22db 99				db WORD_SYS_CORE+OPCODE_ZDUP             
22dc 13 23			dw .SWAP            
22de 05				db 4 + 1 
22df .. 00			db "?DUP",0              
22e4				endm 
# End of macro CWHEAD
22e4			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
22e4			 
22e4					if DEBUG_FORTH_WORDS_KEY 
22e4						DMARK "qDU" 
22e4 f5				push af  
22e5 3a f9 22			ld a, (.dmark)  
22e8 32 bd fb			ld (debug_mark),a  
22eb 3a fa 22			ld a, (.dmark+1)  
22ee 32 be fb			ld (debug_mark+1),a  
22f1 3a fb 22			ld a, (.dmark+2)  
22f4 32 bf fb			ld (debug_mark+2),a  
22f7 18 03			jr .pastdmark  
22f9 ..			.dmark: db "qDU"  
22fc f1			.pastdmark: pop af  
22fd			endm  
# End of macro DMARK
22fd						CALLMONITOR 
22fd cd 6a 16			call break_point_state  
2300				endm  
# End of macro CALLMONITOR
2300					endif 
2300					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2300 cd ee 1d			call macro_dsp_valuehl 
2303				endm 
# End of macro FORTH_DSP_VALUEHL
2303			 
2303 e5					push hl 
2304			 
2304					; is it a zero? 
2304			 
2304 3e 00				ld a, 0 
2306 84					add h 
2307 85					add l 
2308			 
2308 e1					pop hl 
2309			 
2309 fe 00				cp 0 
230b 28 03				jr z, .dup2orig 
230d			 
230d			 
230d cd f7 1b				call forth_push_numhl 
2310			 
2310			 
2310				; TODO add floating point number detection 
2310			 
2310			.dup2orig: 
2310			 
2310					NEXTW 
2310 c3 60 1f			jp macro_next 
2313				endm 
# End of macro NEXTW
2313			.SWAP: 
2313				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2313 18				db WORD_SYS_CORE+OPCODE_SWAP             
2314 52 23			dw .COLN            
2316 05				db 4 + 1 
2317 .. 00			db "SWAP",0              
231c				endm 
# End of macro CWHEAD
231c			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
231c					if DEBUG_FORTH_WORDS_KEY 
231c						DMARK "SWP" 
231c f5				push af  
231d 3a 31 23			ld a, (.dmark)  
2320 32 bd fb			ld (debug_mark),a  
2323 3a 32 23			ld a, (.dmark+1)  
2326 32 be fb			ld (debug_mark+1),a  
2329 3a 33 23			ld a, (.dmark+2)  
232c 32 bf fb			ld (debug_mark+2),a  
232f 18 03			jr .pastdmark  
2331 ..			.dmark: db "SWP"  
2334 f1			.pastdmark: pop af  
2335			endm  
# End of macro DMARK
2335						CALLMONITOR 
2335 cd 6a 16			call break_point_state  
2338				endm  
# End of macro CALLMONITOR
2338					endif 
2338			 
2338					FORTH_DSP_VALUEHL 
2338 cd ee 1d			call macro_dsp_valuehl 
233b				endm 
# End of macro FORTH_DSP_VALUEHL
233b e5					push hl     ; w2 
233c			 
233c					FORTH_DSP_POP 
233c cd a6 1e			call macro_forth_dsp_pop 
233f				endm 
# End of macro FORTH_DSP_POP
233f			 
233f					FORTH_DSP_VALUEHL 
233f cd ee 1d			call macro_dsp_valuehl 
2342				endm 
# End of macro FORTH_DSP_VALUEHL
2342			 
2342					FORTH_DSP_POP 
2342 cd a6 1e			call macro_forth_dsp_pop 
2345				endm 
# End of macro FORTH_DSP_POP
2345			 
2345 d1					pop de     ; w2	, hl = w1 
2346			 
2346 eb					ex de, hl 
2347 d5					push de 
2348			 
2348 cd f7 1b				call forth_push_numhl 
234b			 
234b e1					pop hl 
234c			 
234c cd f7 1b				call forth_push_numhl 
234f					 
234f			 
234f					NEXTW 
234f c3 60 1f			jp macro_next 
2352				endm 
# End of macro NEXTW
2352			.COLN: 
2352				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2352 19				db WORD_SYS_CORE+OPCODE_COLN             
2353 de 24			dw .SCOLN            
2355 02				db 1 + 1 
2356 .. 00			db ":",0              
2358				endm 
# End of macro CWHEAD
2358			; | : ( -- )         Create new word | DONE 
2358			 
2358					if DEBUG_FORTH_WORDS_KEY 
2358						DMARK "CLN" 
2358 f5				push af  
2359 3a 6d 23			ld a, (.dmark)  
235c 32 bd fb			ld (debug_mark),a  
235f 3a 6e 23			ld a, (.dmark+1)  
2362 32 be fb			ld (debug_mark+1),a  
2365 3a 6f 23			ld a, (.dmark+2)  
2368 32 bf fb			ld (debug_mark+2),a  
236b 18 03			jr .pastdmark  
236d ..			.dmark: db "CLN"  
2370 f1			.pastdmark: pop af  
2371			endm  
# End of macro DMARK
2371						CALLMONITOR 
2371 cd 6a 16			call break_point_state  
2374				endm  
# End of macro CALLMONITOR
2374					endif 
2374				STACKFRAME OFF $8efe $989f 
2374				if DEBUG_STACK_IMB 
2374					if OFF 
2374						exx 
2374						ld de, $8efe 
2374						ld a, d 
2374						ld hl, curframe 
2374						call hexout 
2374						ld a, e 
2374						ld hl, curframe+2 
2374						call hexout 
2374						ld hl, $8efe 
2374						push hl 
2374						ld hl, $989f 
2374						push hl 
2374						exx 
2374					endif 
2374				endif 
2374			endm 
# End of macro STACKFRAME
2374				; get parser buffer length  of new word 
2374			 
2374				 
2374			 
2374					; move tok past this to start of name defintition 
2374					; TODO get word to define 
2374					; TODO Move past word token 
2374					; TODO get length of string up to the ';' 
2374			 
2374 2a a4 f2			ld hl, (os_tok_ptr) 
2377 23				inc hl 
2378 23				inc hl 
2379			 
2379 3e 3b			ld a, ';' 
237b cd 6f 11			call strlent 
237e			 
237e 7d				ld a,l 
237f 32 9f ef			ld (os_new_parse_len), a 
2382			 
2382			 
2382			if DEBUG_FORTH_UWORD 
2382 ed 5b a4 f2		ld de, (os_tok_ptr) 
2386						DMARK ":01" 
2386 f5				push af  
2387 3a 9b 23			ld a, (.dmark)  
238a 32 bd fb			ld (debug_mark),a  
238d 3a 9c 23			ld a, (.dmark+1)  
2390 32 be fb			ld (debug_mark+1),a  
2393 3a 9d 23			ld a, (.dmark+2)  
2396 32 bf fb			ld (debug_mark+2),a  
2399 18 03			jr .pastdmark  
239b ..			.dmark: db ":01"  
239e f1			.pastdmark: pop af  
239f			endm  
# End of macro DMARK
239f				CALLMONITOR 
239f cd 6a 16			call break_point_state  
23a2				endm  
# End of macro CALLMONITOR
23a2			endif 
23a2			 
23a2			; 
23a2			;  new word memory layout: 
23a2			;  
23a2			;    : adg 6666 ;  
23a2			; 
23a2			;    db   1     ; user defined word  
23a2 23				inc hl    
23a3			;    dw   sysdict 
23a3 23				inc hl 
23a4 23				inc hl 
23a5			;    db <word len>+1 (for null) 
23a5 23				inc hl 
23a6			;    db .... <word> 
23a6			; 
23a6			 
23a6 23				inc hl    ; some extras for the word preamble before the above 
23a7 23				inc hl 
23a8 23				inc hl 
23a9 23				inc hl 
23aa 23				inc hl 
23ab 23				inc hl 
23ac 23				inc hl  
23ad 23				inc hl 
23ae 23				inc hl 
23af 23				inc hl 
23b0 23				inc hl 
23b1 23				inc hl 
23b2 23				inc hl 
23b3 23				inc hl     ; TODO how many do we really need?     maybe only 6 
23b4			;       exec word buffer 
23b4			;	<ptr word>   
23b4 23				inc hl 
23b5 23				inc hl 
23b6			;       <word list><null term> 7F final term 
23b6			 
23b6			 
23b6			if DEBUG_FORTH_UWORD 
23b6						DMARK ":02" 
23b6 f5				push af  
23b7 3a cb 23			ld a, (.dmark)  
23ba 32 bd fb			ld (debug_mark),a  
23bd 3a cc 23			ld a, (.dmark+1)  
23c0 32 be fb			ld (debug_mark+1),a  
23c3 3a cd 23			ld a, (.dmark+2)  
23c6 32 bf fb			ld (debug_mark+2),a  
23c9 18 03			jr .pastdmark  
23cb ..			.dmark: db ":02"  
23ce f1			.pastdmark: pop af  
23cf			endm  
# End of macro DMARK
23cf				CALLMONITOR 
23cf cd 6a 16			call break_point_state  
23d2				endm  
# End of macro CALLMONITOR
23d2			endif 
23d2			 
23d2				 
23d2					; malloc the size 
23d2			 
23d2 cd cd 11				call malloc 
23d5 22 a1 ef				ld (os_new_malloc), hl     ; save malloc start 
23d8			 
23d8			;    db   1     ; user defined word  
23d8 3e 01				ld a, WORD_SYS_UWORD  
23da 77					ld (hl), a 
23db				 
23db 23				inc hl    
23dc			;    dw   sysdict 
23dc 11 b8 20			ld de, sysdict       ; continue on with the scan to the system dict 
23df 73				ld (hl), e 
23e0 23				inc hl 
23e1 72				ld (hl), d 
23e2 23				inc hl 
23e3			 
23e3			 
23e3			;    Setup dict word 
23e3			 
23e3 23				inc hl 
23e4 22 9b ef			ld (os_new_work_ptr), hl     ; save start of dict word  
23e7			 
23e7				; 1. get length of dict word 
23e7			 
23e7			 
23e7 2a a4 f2			ld hl, (os_tok_ptr) 
23ea 23				inc hl 
23eb 23				inc hl    ; position to start of dict word 
23ec 3e 00			ld a, 0 
23ee cd 6f 11			call strlent 
23f1			 
23f1			 
23f1 23				inc hl    ; to include null??? 
23f2			 
23f2				; write length of dict word 
23f2			 
23f2 ed 5b 9b ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
23f6 1b				dec de 
23f7 eb				ex de, hl 
23f8 73				ld (hl), e 
23f9 eb				ex de, hl 
23fa			 
23fa				 
23fa			 
23fa				; copy  
23fa 4d				ld c, l 
23fb 06 00			ld b, 0 
23fd ed 5b 9b ef		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2401 2a a4 f2			ld hl, (os_tok_ptr) 
2404 23				inc hl 
2405 23				inc hl    ; position to start of dict word 
2406				 
2406			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2406				 
2406				; TODO need to convert word to upper case 
2406			 
2406			ucasetok:	 
2406 7e				ld a,(hl) 
2407 cd 5b 11			call toUpper 
240a 77				ld (hl),a 
240b ed a0			ldi 
240d f2 06 24		 	jp p, ucasetok 
2410			 
2410			 
2410			 
2410				; de now points to start of where the word body code should be placed 
2410 ed 53 9b ef		ld (os_new_work_ptr), de 
2414				; hl now points to the words to throw at forthexec which needs to be copied 
2414 22 99 ef			ld (os_new_src_ptr), hl 
2417			 
2417				; TODO add 'call to forthexec' 
2417			 
2417			if DEBUG_FORTH_UWORD 
2417 c5				push bc 
2418 ed 4b a1 ef		ld bc, (os_new_malloc) 
241c						DMARK ":0x" 
241c f5				push af  
241d 3a 31 24			ld a, (.dmark)  
2420 32 bd fb			ld (debug_mark),a  
2423 3a 32 24			ld a, (.dmark+1)  
2426 32 be fb			ld (debug_mark+1),a  
2429 3a 33 24			ld a, (.dmark+2)  
242c 32 bf fb			ld (debug_mark+2),a  
242f 18 03			jr .pastdmark  
2431 ..			.dmark: db ":0x"  
2434 f1			.pastdmark: pop af  
2435			endm  
# End of macro DMARK
2435				CALLMONITOR 
2435 cd 6a 16			call break_point_state  
2438				endm  
# End of macro CALLMONITOR
2438 c1				pop bc 
2439			endif 
2439			 
2439			 
2439				; create word preamble which should be: 
2439			 
2439			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2439			 
2439				;    ld hl, <word code> 
2439				;    jp user_exec 
2439			        ;    <word code bytes> 
2439			 
2439			 
2439			;	inc de     ; TODO ??? or are we already past the word's null 
2439 eb				ex de, hl 
243a			 
243a 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
243c			 
243c 23				inc hl 
243d 22 95 ef			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2440 23				inc hl 
2441			 
2441 23				inc hl 
2442 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2444			 
2444 01 21 51			ld bc, user_exec 
2447 23				inc hl 
2448 71				ld (hl), c     ; poke address of user_exec 
2449 23				inc hl 
244a 70				ld (hl), b     
244b			 ; 
244b			;	inc hl 
244b			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
244b			; 
244b			; 
244b			;	ld bc, macro_forth_rsp_next 
244b			;	inc hl 
244b			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
244b			;	inc hl 
244b			;	ld (hl), b     
244b			 ; 
244b			;	inc hl 
244b			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
244b			; 
244b			; 
244b			;	inc hl 
244b			;	ld bc, forthexec 
244b			;	ld (hl), c     ; poke address of forthexec 
244b			;	inc hl 
244b			;	ld (hl), b      
244b			; 
244b			;	inc hl 
244b			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
244b			; 
244b			;	ld bc, user_dict_next 
244b			;	inc hl 
244b			;	ld (hl), c     ; poke address of forthexec 
244b			;	inc hl 
244b			;	ld (hl), b      
244b			 
244b				; hl is now where we need to copy the word byte data to save this 
244b			 
244b 23				inc hl 
244c 22 97 ef			ld (os_new_exec), hl 
244f				 
244f				; copy definition 
244f			 
244f eb				ex de, hl 
2450			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2450			;	inc de    ; skip the PC for this parse 
2450 3a 9f ef			ld a, (os_new_parse_len) 
2453 4f				ld c, a 
2454 06 00			ld b, 0 
2456 ed b0			ldir		 ; copy defintion 
2458			 
2458			 
2458				; poke the address of where the new word bytes live for forthexec 
2458			 
2458 2a 95 ef			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
245b			 
245b ed 5b 97 ef		ld de, (os_new_exec)      
245f				 
245f 73				ld (hl), e 
2460 23				inc hl 
2461 72				ld (hl), d 
2462			 
2462					; TODO copy last user dict word next link to this word 
2462					; TODO update last user dict word to point to this word 
2462			; 
2462			; hl f923 de 812a ; bc 811a 
2462			 
2462			if DEBUG_FORTH_UWORD 
2462 c5				push bc 
2463 ed 4b a1 ef		ld bc, (os_new_malloc) 
2467						DMARK ":0A" 
2467 f5				push af  
2468 3a 7c 24			ld a, (.dmark)  
246b 32 bd fb			ld (debug_mark),a  
246e 3a 7d 24			ld a, (.dmark+1)  
2471 32 be fb			ld (debug_mark+1),a  
2474 3a 7e 24			ld a, (.dmark+2)  
2477 32 bf fb			ld (debug_mark+2),a  
247a 18 03			jr .pastdmark  
247c ..			.dmark: db ":0A"  
247f f1			.pastdmark: pop af  
2480			endm  
# End of macro DMARK
2480				CALLMONITOR 
2480 cd 6a 16			call break_point_state  
2483				endm  
# End of macro CALLMONITOR
2483 c1				pop bc 
2484			endif 
2484			if DEBUG_FORTH_UWORD 
2484 c5				push bc 
2485 ed 4b a1 ef		ld bc, (os_new_malloc) 
2489 03				inc bc 
248a 03				inc bc 
248b 03				inc bc 
248c 03				inc bc 
248d 03				inc bc 
248e 03				inc bc 
248f 03				inc bc 
2490 03				inc bc 
2491			 
2491						DMARK ":0B" 
2491 f5				push af  
2492 3a a6 24			ld a, (.dmark)  
2495 32 bd fb			ld (debug_mark),a  
2498 3a a7 24			ld a, (.dmark+1)  
249b 32 be fb			ld (debug_mark+1),a  
249e 3a a8 24			ld a, (.dmark+2)  
24a1 32 bf fb			ld (debug_mark+2),a  
24a4 18 03			jr .pastdmark  
24a6 ..			.dmark: db ":0B"  
24a9 f1			.pastdmark: pop af  
24aa			endm  
# End of macro DMARK
24aa				CALLMONITOR 
24aa cd 6a 16			call break_point_state  
24ad				endm  
# End of macro CALLMONITOR
24ad c1				pop bc 
24ae			endif 
24ae			 
24ae			; update word dict linked list for new word 
24ae			 
24ae			 
24ae 2a a0 f2		ld hl, (os_last_new_uword)		; get the start of the last added uword 
24b1 23			inc hl     ; move to next work linked list ptr 
24b2			 
24b2 ed 5b a1 ef	ld de, (os_new_malloc)		 ; new next word 
24b6 73			ld (hl), e 
24b7 23			inc hl 
24b8 72			ld (hl), d 
24b9			 
24b9			if DEBUG_FORTH_UWORD 
24b9 ed 4b a0 f2		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
24bd			endif 
24bd			 
24bd ed 53 a0 f2	ld (os_last_new_uword), de      ; update last new uword ptr 
24c1			 
24c1			 
24c1			if DEBUG_FORTH_UWORD 
24c1						DMARK ":0+" 
24c1 f5				push af  
24c2 3a d6 24			ld a, (.dmark)  
24c5 32 bd fb			ld (debug_mark),a  
24c8 3a d7 24			ld a, (.dmark+1)  
24cb 32 be fb			ld (debug_mark+1),a  
24ce 3a d8 24			ld a, (.dmark+2)  
24d1 32 bf fb			ld (debug_mark+2),a  
24d4 18 03			jr .pastdmark  
24d6 ..			.dmark: db ":0+"  
24d9 f1			.pastdmark: pop af  
24da			endm  
# End of macro DMARK
24da				CALLMONITOR 
24da cd 6a 16			call break_point_state  
24dd				endm  
# End of macro CALLMONITOR
24dd			endif 
24dd			 
24dd				STACKFRAMECHK OFF $8efe $989f 
24dd				if DEBUG_STACK_IMB 
24dd					if OFF 
24dd						exx 
24dd						ld hl, $989f 
24dd						pop de   ; $989f 
24dd						call cmp16 
24dd						jr nz, .spnosame 
24dd						ld hl, $8efe 
24dd						pop de   ; $8efe 
24dd						call cmp16 
24dd						jr z, .spfrsame 
24dd						.spnosame: call showsperror 
24dd						.spfrsame: nop 
24dd						exx 
24dd					endif 
24dd				endif 
24dd			endm 
# End of macro STACKFRAMECHK
24dd			 
24dd c9			ret    ; dont process any remaining parser tokens as they form new word 
24de			 
24de			 
24de			 
24de			 
24de			;		NEXT 
24de			.SCOLN: 
24de			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
24de 06				db OPCODE_SCOLN 
24df 2a 25			dw .DROP 
24e1 02				db 2 
24e2 .. 00			db ";",0           
24e4			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
24e4					if DEBUG_FORTH_WORDS_KEY 
24e4						DMARK "SCN" 
24e4 f5				push af  
24e5 3a f9 24			ld a, (.dmark)  
24e8 32 bd fb			ld (debug_mark),a  
24eb 3a fa 24			ld a, (.dmark+1)  
24ee 32 be fb			ld (debug_mark+1),a  
24f1 3a fb 24			ld a, (.dmark+2)  
24f4 32 bf fb			ld (debug_mark+2),a  
24f7 18 03			jr .pastdmark  
24f9 ..			.dmark: db "SCN"  
24fc f1			.pastdmark: pop af  
24fd			endm  
# End of macro DMARK
24fd						CALLMONITOR 
24fd cd 6a 16			call break_point_state  
2500				endm  
# End of macro CALLMONITOR
2500					endif 
2500					FORTH_RSP_TOS 
2500 cd b5 1b			call macro_forth_rsp_tos 
2503				endm 
# End of macro FORTH_RSP_TOS
2503 e5					push hl 
2504					FORTH_RSP_POP 
2504 cd bf 1b			call macro_forth_rsp_pop 
2507				endm 
# End of macro FORTH_RSP_POP
2507 e1					pop hl 
2508			;		ex de,hl 
2508 22 a4 f2				ld (os_tok_ptr),hl 
250b			 
250b			if DEBUG_FORTH_UWORD 
250b						DMARK "SCL" 
250b f5				push af  
250c 3a 20 25			ld a, (.dmark)  
250f 32 bd fb			ld (debug_mark),a  
2512 3a 21 25			ld a, (.dmark+1)  
2515 32 be fb			ld (debug_mark+1),a  
2518 3a 22 25			ld a, (.dmark+2)  
251b 32 bf fb			ld (debug_mark+2),a  
251e 18 03			jr .pastdmark  
2520 ..			.dmark: db "SCL"  
2523 f1			.pastdmark: pop af  
2524			endm  
# End of macro DMARK
2524				CALLMONITOR 
2524 cd 6a 16			call break_point_state  
2527				endm  
# End of macro CALLMONITOR
2527			endif 
2527					NEXTW 
2527 c3 60 1f			jp macro_next 
252a				endm 
# End of macro NEXTW
252a			 
252a			.DROP: 
252a				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
252a 1b				db WORD_SYS_CORE+OPCODE_DROP             
252b 55 25			dw .DUP2            
252d 05				db 4 + 1 
252e .. 00			db "DROP",0              
2533				endm 
# End of macro CWHEAD
2533			; | DROP ( w -- )   drop the TOS item   | DONE 
2533					if DEBUG_FORTH_WORDS_KEY 
2533						DMARK "DRP" 
2533 f5				push af  
2534 3a 48 25			ld a, (.dmark)  
2537 32 bd fb			ld (debug_mark),a  
253a 3a 49 25			ld a, (.dmark+1)  
253d 32 be fb			ld (debug_mark+1),a  
2540 3a 4a 25			ld a, (.dmark+2)  
2543 32 bf fb			ld (debug_mark+2),a  
2546 18 03			jr .pastdmark  
2548 ..			.dmark: db "DRP"  
254b f1			.pastdmark: pop af  
254c			endm  
# End of macro DMARK
254c						CALLMONITOR 
254c cd 6a 16			call break_point_state  
254f				endm  
# End of macro CALLMONITOR
254f					endif 
254f					FORTH_DSP_POP 
254f cd a6 1e			call macro_forth_dsp_pop 
2552				endm 
# End of macro FORTH_DSP_POP
2552					NEXTW 
2552 c3 60 1f			jp macro_next 
2555				endm 
# End of macro NEXTW
2555			.DUP2: 
2555				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2555 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2556 9a 25			dw .DROP2            
2558 05				db 4 + 1 
2559 .. 00			db "2DUP",0              
255e				endm 
# End of macro CWHEAD
255e			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
255e					if DEBUG_FORTH_WORDS_KEY 
255e						DMARK "2DU" 
255e f5				push af  
255f 3a 73 25			ld a, (.dmark)  
2562 32 bd fb			ld (debug_mark),a  
2565 3a 74 25			ld a, (.dmark+1)  
2568 32 be fb			ld (debug_mark+1),a  
256b 3a 75 25			ld a, (.dmark+2)  
256e 32 bf fb			ld (debug_mark+2),a  
2571 18 03			jr .pastdmark  
2573 ..			.dmark: db "2DU"  
2576 f1			.pastdmark: pop af  
2577			endm  
# End of macro DMARK
2577						CALLMONITOR 
2577 cd 6a 16			call break_point_state  
257a				endm  
# End of macro CALLMONITOR
257a					endif 
257a					FORTH_DSP_VALUEHL 
257a cd ee 1d			call macro_dsp_valuehl 
257d				endm 
# End of macro FORTH_DSP_VALUEHL
257d e5					push hl      ; 2 
257e			 
257e					FORTH_DSP_POP 
257e cd a6 1e			call macro_forth_dsp_pop 
2581				endm 
# End of macro FORTH_DSP_POP
2581					 
2581					FORTH_DSP_VALUEHL 
2581 cd ee 1d			call macro_dsp_valuehl 
2584				endm 
# End of macro FORTH_DSP_VALUEHL
2584			;		push hl      ; 1 
2584			 
2584					FORTH_DSP_POP 
2584 cd a6 1e			call macro_forth_dsp_pop 
2587				endm 
# End of macro FORTH_DSP_POP
2587			 
2587			;		pop hl       ; 1 
2587 d1					pop de       ; 2 
2588			 
2588 cd f7 1b				call forth_push_numhl 
258b eb					ex de, hl 
258c cd f7 1b				call forth_push_numhl 
258f			 
258f					 
258f eb					ex de, hl 
2590			 
2590 cd f7 1b				call forth_push_numhl 
2593 eb					ex de, hl 
2594 cd f7 1b				call forth_push_numhl 
2597			 
2597			 
2597					NEXTW 
2597 c3 60 1f			jp macro_next 
259a				endm 
# End of macro NEXTW
259a			.DROP2: 
259a				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
259a 1d				db WORD_SYS_CORE+OPCODE_DROP2             
259b c9 25			dw .SWAP2            
259d 06				db 5 + 1 
259e .. 00			db "2DROP",0              
25a4				endm 
# End of macro CWHEAD
25a4			; | 2DROP ( w w -- )    Double drop | DONE 
25a4					if DEBUG_FORTH_WORDS_KEY 
25a4						DMARK "2DR" 
25a4 f5				push af  
25a5 3a b9 25			ld a, (.dmark)  
25a8 32 bd fb			ld (debug_mark),a  
25ab 3a ba 25			ld a, (.dmark+1)  
25ae 32 be fb			ld (debug_mark+1),a  
25b1 3a bb 25			ld a, (.dmark+2)  
25b4 32 bf fb			ld (debug_mark+2),a  
25b7 18 03			jr .pastdmark  
25b9 ..			.dmark: db "2DR"  
25bc f1			.pastdmark: pop af  
25bd			endm  
# End of macro DMARK
25bd						CALLMONITOR 
25bd cd 6a 16			call break_point_state  
25c0				endm  
# End of macro CALLMONITOR
25c0					endif 
25c0					FORTH_DSP_POP 
25c0 cd a6 1e			call macro_forth_dsp_pop 
25c3				endm 
# End of macro FORTH_DSP_POP
25c3					FORTH_DSP_POP 
25c3 cd a6 1e			call macro_forth_dsp_pop 
25c6				endm 
# End of macro FORTH_DSP_POP
25c6					NEXTW 
25c6 c3 60 1f			jp macro_next 
25c9				endm 
# End of macro NEXTW
25c9			.SWAP2: 
25c9				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
25c9 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
25ca f2 25			dw .AT            
25cc 06				db 5 + 1 
25cd .. 00			db "2SWAP",0              
25d3				endm 
# End of macro CWHEAD
25d3			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
25d3					if DEBUG_FORTH_WORDS_KEY 
25d3						DMARK "2SW" 
25d3 f5				push af  
25d4 3a e8 25			ld a, (.dmark)  
25d7 32 bd fb			ld (debug_mark),a  
25da 3a e9 25			ld a, (.dmark+1)  
25dd 32 be fb			ld (debug_mark+1),a  
25e0 3a ea 25			ld a, (.dmark+2)  
25e3 32 bf fb			ld (debug_mark+2),a  
25e6 18 03			jr .pastdmark  
25e8 ..			.dmark: db "2SW"  
25eb f1			.pastdmark: pop af  
25ec			endm  
# End of macro DMARK
25ec						CALLMONITOR 
25ec cd 6a 16			call break_point_state  
25ef				endm  
# End of macro CALLMONITOR
25ef					endif 
25ef					NEXTW 
25ef c3 60 1f			jp macro_next 
25f2				endm 
# End of macro NEXTW
25f2			.AT: 
25f2				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
25f2 1f				db WORD_SYS_CORE+OPCODE_AT             
25f3 24 26			dw .CAT            
25f5 02				db 1 + 1 
25f6 .. 00			db "@",0              
25f8				endm 
# End of macro CWHEAD
25f8			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
25f8			 
25f8					if DEBUG_FORTH_WORDS_KEY 
25f8						DMARK "AT." 
25f8 f5				push af  
25f9 3a 0d 26			ld a, (.dmark)  
25fc 32 bd fb			ld (debug_mark),a  
25ff 3a 0e 26			ld a, (.dmark+1)  
2602 32 be fb			ld (debug_mark+1),a  
2605 3a 0f 26			ld a, (.dmark+2)  
2608 32 bf fb			ld (debug_mark+2),a  
260b 18 03			jr .pastdmark  
260d ..			.dmark: db "AT."  
2610 f1			.pastdmark: pop af  
2611			endm  
# End of macro DMARK
2611						CALLMONITOR 
2611 cd 6a 16			call break_point_state  
2614				endm  
# End of macro CALLMONITOR
2614					endif 
2614			.getbyteat:	 
2614					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2614 cd ee 1d			call macro_dsp_valuehl 
2617				endm 
# End of macro FORTH_DSP_VALUEHL
2617					 
2617			;		push hl 
2617				 
2617					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2617 cd a6 1e			call macro_forth_dsp_pop 
261a				endm 
# End of macro FORTH_DSP_POP
261a			 
261a			;		pop hl 
261a			 
261a 7e					ld a, (hl) 
261b			 
261b 6f					ld l, a 
261c 26 00				ld h, 0 
261e cd f7 1b				call forth_push_numhl 
2621			 
2621					NEXTW 
2621 c3 60 1f			jp macro_next 
2624				endm 
# End of macro NEXTW
2624			.CAT: 
2624				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2624 20				db WORD_SYS_CORE+OPCODE_CAT             
2625 4d 26			dw .BANG            
2627 03				db 2 + 1 
2628 .. 00			db "C@",0              
262b				endm 
# End of macro CWHEAD
262b			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
262b					if DEBUG_FORTH_WORDS_KEY 
262b						DMARK "CAA" 
262b f5				push af  
262c 3a 40 26			ld a, (.dmark)  
262f 32 bd fb			ld (debug_mark),a  
2632 3a 41 26			ld a, (.dmark+1)  
2635 32 be fb			ld (debug_mark+1),a  
2638 3a 42 26			ld a, (.dmark+2)  
263b 32 bf fb			ld (debug_mark+2),a  
263e 18 03			jr .pastdmark  
2640 ..			.dmark: db "CAA"  
2643 f1			.pastdmark: pop af  
2644			endm  
# End of macro DMARK
2644						CALLMONITOR 
2644 cd 6a 16			call break_point_state  
2647				endm  
# End of macro CALLMONITOR
2647					endif 
2647 c3 14 26				jp .getbyteat 
264a					NEXTW 
264a c3 60 1f			jp macro_next 
264d				endm 
# End of macro NEXTW
264d			.BANG: 
264d				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
264d 21				db WORD_SYS_CORE+OPCODE_BANG             
264e 83 26			dw .CBANG            
2650 02				db 1 + 1 
2651 .. 00			db "!",0              
2653				endm 
# End of macro CWHEAD
2653			; | ! ( x w -- ) Store x at address w      | DONE 
2653					if DEBUG_FORTH_WORDS_KEY 
2653						DMARK "BNG" 
2653 f5				push af  
2654 3a 68 26			ld a, (.dmark)  
2657 32 bd fb			ld (debug_mark),a  
265a 3a 69 26			ld a, (.dmark+1)  
265d 32 be fb			ld (debug_mark+1),a  
2660 3a 6a 26			ld a, (.dmark+2)  
2663 32 bf fb			ld (debug_mark+2),a  
2666 18 03			jr .pastdmark  
2668 ..			.dmark: db "BNG"  
266b f1			.pastdmark: pop af  
266c			endm  
# End of macro DMARK
266c						CALLMONITOR 
266c cd 6a 16			call break_point_state  
266f				endm  
# End of macro CALLMONITOR
266f					endif 
266f			 
266f			.storebyteat:		 
266f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
266f cd ee 1d			call macro_dsp_valuehl 
2672				endm 
# End of macro FORTH_DSP_VALUEHL
2672					 
2672 e5					push hl 
2673				 
2673					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2673 cd a6 1e			call macro_forth_dsp_pop 
2676				endm 
# End of macro FORTH_DSP_POP
2676			 
2676					; get byte to poke 
2676			 
2676					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2676 cd ee 1d			call macro_dsp_valuehl 
2679				endm 
# End of macro FORTH_DSP_VALUEHL
2679 e5					push hl 
267a			 
267a			 
267a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
267a cd a6 1e			call macro_forth_dsp_pop 
267d				endm 
# End of macro FORTH_DSP_POP
267d			 
267d			 
267d d1					pop de 
267e e1					pop hl 
267f			 
267f 73					ld (hl),e 
2680			 
2680			 
2680					NEXTW 
2680 c3 60 1f			jp macro_next 
2683				endm 
# End of macro NEXTW
2683			.CBANG: 
2683				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2683 22				db WORD_SYS_CORE+OPCODE_CBANG             
2684 ac 26			dw .SCALL            
2686 03				db 2 + 1 
2687 .. 00			db "C!",0              
268a				endm 
# End of macro CWHEAD
268a			; | C!  ( x w -- ) Store x at address w  | DONE 
268a					if DEBUG_FORTH_WORDS_KEY 
268a						DMARK "CBA" 
268a f5				push af  
268b 3a 9f 26			ld a, (.dmark)  
268e 32 bd fb			ld (debug_mark),a  
2691 3a a0 26			ld a, (.dmark+1)  
2694 32 be fb			ld (debug_mark+1),a  
2697 3a a1 26			ld a, (.dmark+2)  
269a 32 bf fb			ld (debug_mark+2),a  
269d 18 03			jr .pastdmark  
269f ..			.dmark: db "CBA"  
26a2 f1			.pastdmark: pop af  
26a3			endm  
# End of macro DMARK
26a3						CALLMONITOR 
26a3 cd 6a 16			call break_point_state  
26a6				endm  
# End of macro CALLMONITOR
26a6					endif 
26a6 c3 6f 26				jp .storebyteat 
26a9					NEXTW 
26a9 c3 60 1f			jp macro_next 
26ac				endm 
# End of macro NEXTW
26ac			.SCALL: 
26ac				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
26ac 23				db WORD_SYS_CORE+OPCODE_SCALL             
26ad e0 26			dw .DEPTH            
26af 05				db 4 + 1 
26b0 .. 00			db "CALL",0              
26b5				endm 
# End of macro CWHEAD
26b5			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
26b5					if DEBUG_FORTH_WORDS_KEY 
26b5						DMARK "CLL" 
26b5 f5				push af  
26b6 3a ca 26			ld a, (.dmark)  
26b9 32 bd fb			ld (debug_mark),a  
26bc 3a cb 26			ld a, (.dmark+1)  
26bf 32 be fb			ld (debug_mark+1),a  
26c2 3a cc 26			ld a, (.dmark+2)  
26c5 32 bf fb			ld (debug_mark+2),a  
26c8 18 03			jr .pastdmark  
26ca ..			.dmark: db "CLL"  
26cd f1			.pastdmark: pop af  
26ce			endm  
# End of macro DMARK
26ce						CALLMONITOR 
26ce cd 6a 16			call break_point_state  
26d1				endm  
# End of macro CALLMONITOR
26d1					endif 
26d1			 
26d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26d1 cd ee 1d			call macro_dsp_valuehl 
26d4				endm 
# End of macro FORTH_DSP_VALUEHL
26d4			 
26d4			;		push hl 
26d4			 
26d4					; destroy value TOS 
26d4			 
26d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26d4 cd a6 1e			call macro_forth_dsp_pop 
26d7				endm 
# End of macro FORTH_DSP_POP
26d7			 
26d7						 
26d7			;		pop hl 
26d7			 
26d7					; how to do a call with hl???? save SP? 
26d7 cd 09 1f				call forth_call_hl 
26da			 
26da			 
26da					; TODO push value back onto stack for another op etc 
26da			 
26da cd f7 1b				call forth_push_numhl 
26dd					NEXTW 
26dd c3 60 1f			jp macro_next 
26e0				endm 
# End of macro NEXTW
26e0			.DEPTH: 
26e0				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
26e0 24				db WORD_SYS_CORE+OPCODE_DEPTH             
26e1 1d 27			dw .OVER            
26e3 06				db 5 + 1 
26e4 .. 00			db "DEPTH",0              
26ea				endm 
# End of macro CWHEAD
26ea			; | DEPTH ( -- u ) Push count of stack | DONE 
26ea					; take current TOS and remove from base value div by two to get count 
26ea					if DEBUG_FORTH_WORDS_KEY 
26ea						DMARK "DEP" 
26ea f5				push af  
26eb 3a ff 26			ld a, (.dmark)  
26ee 32 bd fb			ld (debug_mark),a  
26f1 3a 00 27			ld a, (.dmark+1)  
26f4 32 be fb			ld (debug_mark+1),a  
26f7 3a 01 27			ld a, (.dmark+2)  
26fa 32 bf fb			ld (debug_mark+2),a  
26fd 18 03			jr .pastdmark  
26ff ..			.dmark: db "DEP"  
2702 f1			.pastdmark: pop af  
2703			endm  
# End of macro DMARK
2703						CALLMONITOR 
2703 cd 6a 16			call break_point_state  
2706				endm  
# End of macro CALLMONITOR
2706					endif 
2706			 
2706			 
2706 2a 90 f9			ld hl, (cli_data_sp) 
2709 11 0a f5			ld de, cli_data_stack 
270c ed 52			sbc hl,de 
270e				 
270e				; div by size of stack item 
270e			 
270e 5d				ld e,l 
270f 0e 03			ld c, 3 
2711 cd 96 0c			call Div8 
2714			 
2714 6f				ld l,a 
2715 26 00			ld h,0 
2717			 
2717				;srl h 
2717				;rr l 
2717			 
2717 cd f7 1b				call forth_push_numhl 
271a					NEXTW 
271a c3 60 1f			jp macro_next 
271d				endm 
# End of macro NEXTW
271d			.OVER: 
271d				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
271d 42				db WORD_SYS_CORE+46             
271e 64 27			dw .PAUSE            
2720 05				db 4 + 1 
2721 .. 00			db "OVER",0              
2726				endm 
# End of macro CWHEAD
2726			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2726					if DEBUG_FORTH_WORDS_KEY 
2726						DMARK "OVR" 
2726 f5				push af  
2727 3a 3b 27			ld a, (.dmark)  
272a 32 bd fb			ld (debug_mark),a  
272d 3a 3c 27			ld a, (.dmark+1)  
2730 32 be fb			ld (debug_mark+1),a  
2733 3a 3d 27			ld a, (.dmark+2)  
2736 32 bf fb			ld (debug_mark+2),a  
2739 18 03			jr .pastdmark  
273b ..			.dmark: db "OVR"  
273e f1			.pastdmark: pop af  
273f			endm  
# End of macro DMARK
273f						CALLMONITOR 
273f cd 6a 16			call break_point_state  
2742				endm  
# End of macro CALLMONITOR
2742					endif 
2742			 
2742					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2742 cd ee 1d			call macro_dsp_valuehl 
2745				endm 
# End of macro FORTH_DSP_VALUEHL
2745 e5					push hl    ; n2 
2746					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2746 cd a6 1e			call macro_forth_dsp_pop 
2749				endm 
# End of macro FORTH_DSP_POP
2749			 
2749					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2749 cd ee 1d			call macro_dsp_valuehl 
274c				endm 
# End of macro FORTH_DSP_VALUEHL
274c e5					push hl    ; n1 
274d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
274d cd a6 1e			call macro_forth_dsp_pop 
2750				endm 
# End of macro FORTH_DSP_POP
2750			 
2750 d1					pop de     ; n1 
2751 e1					pop hl     ; n2 
2752			 
2752 d5					push de 
2753 e5					push hl 
2754 d5					push de 
2755			 
2755					; push back  
2755			 
2755 e1					pop hl 
2756 cd f7 1b				call forth_push_numhl 
2759 e1					pop hl 
275a cd f7 1b				call forth_push_numhl 
275d e1					pop hl 
275e cd f7 1b				call forth_push_numhl 
2761					NEXTW 
2761 c3 60 1f			jp macro_next 
2764				endm 
# End of macro NEXTW
2764			 
2764			.PAUSE: 
2764				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2764 43				db WORD_SYS_CORE+47             
2765 99 27			dw .PAUSES            
2767 08				db 7 + 1 
2768 .. 00			db "PAUSEMS",0              
2770				endm 
# End of macro CWHEAD
2770			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2770					if DEBUG_FORTH_WORDS_KEY 
2770						DMARK "PMS" 
2770 f5				push af  
2771 3a 85 27			ld a, (.dmark)  
2774 32 bd fb			ld (debug_mark),a  
2777 3a 86 27			ld a, (.dmark+1)  
277a 32 be fb			ld (debug_mark+1),a  
277d 3a 87 27			ld a, (.dmark+2)  
2780 32 bf fb			ld (debug_mark+2),a  
2783 18 03			jr .pastdmark  
2785 ..			.dmark: db "PMS"  
2788 f1			.pastdmark: pop af  
2789			endm  
# End of macro DMARK
2789						CALLMONITOR 
2789 cd 6a 16			call break_point_state  
278c				endm  
# End of macro CALLMONITOR
278c					endif 
278c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
278c cd ee 1d			call macro_dsp_valuehl 
278f				endm 
# End of macro FORTH_DSP_VALUEHL
278f			;		push hl    ; n2 
278f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
278f cd a6 1e			call macro_forth_dsp_pop 
2792				endm 
# End of macro FORTH_DSP_POP
2792			;		pop hl 
2792			 
2792 7d					ld a, l 
2793 cd 37 0a				call aDelayInMS 
2796				       NEXTW 
2796 c3 60 1f			jp macro_next 
2799				endm 
# End of macro NEXTW
2799			.PAUSES:  
2799				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2799 44				db WORD_SYS_CORE+48             
279a 08 28			dw .ROT            
279c 06				db 5 + 1 
279d .. 00			db "PAUSE",0              
27a3				endm 
# End of macro CWHEAD
27a3			; | PAUSE ( n -- )  Pause for n seconds | DONE 
27a3					if DEBUG_FORTH_WORDS_KEY 
27a3						DMARK "PAU" 
27a3 f5				push af  
27a4 3a b8 27			ld a, (.dmark)  
27a7 32 bd fb			ld (debug_mark),a  
27aa 3a b9 27			ld a, (.dmark+1)  
27ad 32 be fb			ld (debug_mark+1),a  
27b0 3a ba 27			ld a, (.dmark+2)  
27b3 32 bf fb			ld (debug_mark+2),a  
27b6 18 03			jr .pastdmark  
27b8 ..			.dmark: db "PAU"  
27bb f1			.pastdmark: pop af  
27bc			endm  
# End of macro DMARK
27bc						CALLMONITOR 
27bc cd 6a 16			call break_point_state  
27bf				endm  
# End of macro CALLMONITOR
27bf					endif 
27bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27bf cd ee 1d			call macro_dsp_valuehl 
27c2				endm 
# End of macro FORTH_DSP_VALUEHL
27c2			;		push hl    ; n2 
27c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27c2 cd a6 1e			call macro_forth_dsp_pop 
27c5				endm 
# End of macro FORTH_DSP_POP
27c5			;		pop hl 
27c5 45					ld b, l 
27c6					if DEBUG_FORTH_WORDS 
27c6						DMARK "PAU" 
27c6 f5				push af  
27c7 3a db 27			ld a, (.dmark)  
27ca 32 bd fb			ld (debug_mark),a  
27cd 3a dc 27			ld a, (.dmark+1)  
27d0 32 be fb			ld (debug_mark+1),a  
27d3 3a dd 27			ld a, (.dmark+2)  
27d6 32 bf fb			ld (debug_mark+2),a  
27d9 18 03			jr .pastdmark  
27db ..			.dmark: db "PAU"  
27de f1			.pastdmark: pop af  
27df			endm  
# End of macro DMARK
27df						CALLMONITOR 
27df cd 6a 16			call break_point_state  
27e2				endm  
# End of macro CALLMONITOR
27e2					endif 
27e2 c5			.pauses1:	push bc 
27e3 cd 52 0a				call delay1s 
27e6 c1					pop bc 
27e7					if DEBUG_FORTH_WORDS 
27e7						DMARK "PA1" 
27e7 f5				push af  
27e8 3a fc 27			ld a, (.dmark)  
27eb 32 bd fb			ld (debug_mark),a  
27ee 3a fd 27			ld a, (.dmark+1)  
27f1 32 be fb			ld (debug_mark+1),a  
27f4 3a fe 27			ld a, (.dmark+2)  
27f7 32 bf fb			ld (debug_mark+2),a  
27fa 18 03			jr .pastdmark  
27fc ..			.dmark: db "PA1"  
27ff f1			.pastdmark: pop af  
2800			endm  
# End of macro DMARK
2800						CALLMONITOR 
2800 cd 6a 16			call break_point_state  
2803				endm  
# End of macro CALLMONITOR
2803					endif 
2803 10 dd				djnz .pauses1 
2805			 
2805				       NEXTW 
2805 c3 60 1f			jp macro_next 
2808				endm 
# End of macro NEXTW
2808			.ROT: 
2808				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2808 45				db WORD_SYS_CORE+49             
2809 56 28			dw .UWORDS            
280b 04				db 3 + 1 
280c .. 00			db "ROT",0              
2810				endm 
# End of macro CWHEAD
2810			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2810					if DEBUG_FORTH_WORDS_KEY 
2810						DMARK "ROT" 
2810 f5				push af  
2811 3a 25 28			ld a, (.dmark)  
2814 32 bd fb			ld (debug_mark),a  
2817 3a 26 28			ld a, (.dmark+1)  
281a 32 be fb			ld (debug_mark+1),a  
281d 3a 27 28			ld a, (.dmark+2)  
2820 32 bf fb			ld (debug_mark+2),a  
2823 18 03			jr .pastdmark  
2825 ..			.dmark: db "ROT"  
2828 f1			.pastdmark: pop af  
2829			endm  
# End of macro DMARK
2829						CALLMONITOR 
2829 cd 6a 16			call break_point_state  
282c				endm  
# End of macro CALLMONITOR
282c					endif 
282c			 
282c					FORTH_DSP_VALUEHL 
282c cd ee 1d			call macro_dsp_valuehl 
282f				endm 
# End of macro FORTH_DSP_VALUEHL
282f e5					push hl    ; u3  
2830			 
2830					FORTH_DSP_POP 
2830 cd a6 1e			call macro_forth_dsp_pop 
2833				endm 
# End of macro FORTH_DSP_POP
2833			   
2833					FORTH_DSP_VALUEHL 
2833 cd ee 1d			call macro_dsp_valuehl 
2836				endm 
# End of macro FORTH_DSP_VALUEHL
2836 e5					push hl     ; u2 
2837			 
2837					FORTH_DSP_POP 
2837 cd a6 1e			call macro_forth_dsp_pop 
283a				endm 
# End of macro FORTH_DSP_POP
283a			 
283a					FORTH_DSP_VALUEHL 
283a cd ee 1d			call macro_dsp_valuehl 
283d				endm 
# End of macro FORTH_DSP_VALUEHL
283d e5					push hl     ; u1 
283e			 
283e					FORTH_DSP_POP 
283e cd a6 1e			call macro_forth_dsp_pop 
2841				endm 
# End of macro FORTH_DSP_POP
2841			 
2841 c1					pop bc      ; u1 
2842 e1					pop hl      ; u2 
2843 d1					pop de      ; u3 
2844			 
2844			 
2844 c5					push bc 
2845 d5					push de 
2846 e5					push hl 
2847			 
2847			 
2847 e1					pop hl 
2848 cd f7 1b				call forth_push_numhl 
284b			 
284b e1					pop hl 
284c cd f7 1b				call forth_push_numhl 
284f			 
284f e1					pop hl 
2850 cd f7 1b				call forth_push_numhl 
2853					 
2853			 
2853			 
2853			 
2853			 
2853			 
2853				       NEXTW 
2853 c3 60 1f			jp macro_next 
2856				endm 
# End of macro NEXTW
2856			 
2856			.UWORDS: 
2856				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2856 50				db WORD_SYS_CORE+60             
2857 18 29			dw .BP            
2859 07				db 6 + 1 
285a .. 00			db "UWORDS",0              
2861				endm 
# End of macro CWHEAD
2861			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2861			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2861			; | | Following the count are the individual words. 
2861			; | | 
2861			; | | e.g. UWORDS 
2861			; | | BOX DIRLIST 2 
2861			; | |  
2861			; | | Can be used to save the words to storage via: 
2861			; | | UWORDS $01 DO $01 APPEND LOOP 
2861				if DEBUG_FORTH_WORDS_KEY 
2861					DMARK "UWR" 
2861 f5				push af  
2862 3a 76 28			ld a, (.dmark)  
2865 32 bd fb			ld (debug_mark),a  
2868 3a 77 28			ld a, (.dmark+1)  
286b 32 be fb			ld (debug_mark+1),a  
286e 3a 78 28			ld a, (.dmark+2)  
2871 32 bf fb			ld (debug_mark+2),a  
2874 18 03			jr .pastdmark  
2876 ..			.dmark: db "UWR"  
2879 f1			.pastdmark: pop af  
287a			endm  
# End of macro DMARK
287a					CALLMONITOR 
287a cd 6a 16			call break_point_state  
287d				endm  
# End of macro CALLMONITOR
287d				endif 
287d 21 00 80				ld hl, baseram 
2880					;ld hl, baseusermem 
2880 01 00 00				ld bc, 0    ; start a counter 
2883			 
2883				; skip dict stub 
2883			 
2883 cd b1 20				call forth_tok_next 
2886			 
2886			 
2886			; while we have words to look for 
2886			 
2886 7e			.douscan:	ld a, (hl)      
2887				if DEBUG_FORTH_WORDS 
2887					DMARK "UWs" 
2887 f5				push af  
2888 3a 9c 28			ld a, (.dmark)  
288b 32 bd fb			ld (debug_mark),a  
288e 3a 9d 28			ld a, (.dmark+1)  
2891 32 be fb			ld (debug_mark+1),a  
2894 3a 9e 28			ld a, (.dmark+2)  
2897 32 bf fb			ld (debug_mark+2),a  
289a 18 03			jr .pastdmark  
289c ..			.dmark: db "UWs"  
289f f1			.pastdmark: pop af  
28a0			endm  
# End of macro DMARK
28a0					CALLMONITOR 
28a0 cd 6a 16			call break_point_state  
28a3				endm  
# End of macro CALLMONITOR
28a3				endif 
28a3 fe 00				cp WORD_SYS_END 
28a5 28 4d				jr z, .udone 
28a7 fe 01				cp WORD_SYS_UWORD 
28a9 20 44				jr nz, .nuword 
28ab			 
28ab				if DEBUG_FORTH_WORDS 
28ab					DMARK "UWu" 
28ab f5				push af  
28ac 3a c0 28			ld a, (.dmark)  
28af 32 bd fb			ld (debug_mark),a  
28b2 3a c1 28			ld a, (.dmark+1)  
28b5 32 be fb			ld (debug_mark+1),a  
28b8 3a c2 28			ld a, (.dmark+2)  
28bb 32 bf fb			ld (debug_mark+2),a  
28be 18 03			jr .pastdmark  
28c0 ..			.dmark: db "UWu"  
28c3 f1			.pastdmark: pop af  
28c4			endm  
# End of macro DMARK
28c4					CALLMONITOR 
28c4 cd 6a 16			call break_point_state  
28c7				endm  
# End of macro CALLMONITOR
28c7				endif 
28c7					; we have a uword so push its name to the stack 
28c7			 
28c7 e5				   	push hl  ; save so we can move to next dict block 
28c8			 
28c8					; skip opcode 
28c8 23					inc hl  
28c9					; skip next ptr 
28c9 23					inc hl  
28ca 23					inc hl 
28cb					; skip len 
28cb 23					inc hl 
28cc				if DEBUG_FORTH_WORDS 
28cc					DMARK "UWt" 
28cc f5				push af  
28cd 3a e1 28			ld a, (.dmark)  
28d0 32 bd fb			ld (debug_mark),a  
28d3 3a e2 28			ld a, (.dmark+1)  
28d6 32 be fb			ld (debug_mark+1),a  
28d9 3a e3 28			ld a, (.dmark+2)  
28dc 32 bf fb			ld (debug_mark+2),a  
28df 18 03			jr .pastdmark  
28e1 ..			.dmark: db "UWt"  
28e4 f1			.pastdmark: pop af  
28e5			endm  
# End of macro DMARK
28e5					CALLMONITOR 
28e5 cd 6a 16			call break_point_state  
28e8				endm  
# End of macro CALLMONITOR
28e8				endif 
28e8 03					inc bc 
28e9			 
28e9 c5					push bc 
28ea cd 65 1c				call forth_push_str 
28ed c1					pop bc 
28ee			 
28ee e1					pop hl 	 
28ef			 
28ef cd b1 20		.nuword:	call forth_tok_next 
28f2 18 92				jr .douscan  
28f4			 
28f4			.udone:		 ; push count of uwords found 
28f4 c5					push bc 
28f5 e1					pop hl 
28f6			 
28f6				if DEBUG_FORTH_WORDS 
28f6					DMARK "UWc" 
28f6 f5				push af  
28f7 3a 0b 29			ld a, (.dmark)  
28fa 32 bd fb			ld (debug_mark),a  
28fd 3a 0c 29			ld a, (.dmark+1)  
2900 32 be fb			ld (debug_mark+1),a  
2903 3a 0d 29			ld a, (.dmark+2)  
2906 32 bf fb			ld (debug_mark+2),a  
2909 18 03			jr .pastdmark  
290b ..			.dmark: db "UWc"  
290e f1			.pastdmark: pop af  
290f			endm  
# End of macro DMARK
290f					CALLMONITOR 
290f cd 6a 16			call break_point_state  
2912				endm  
# End of macro CALLMONITOR
2912				endif 
2912 cd f7 1b				call forth_push_numhl 
2915			 
2915			 
2915				       NEXTW 
2915 c3 60 1f			jp macro_next 
2918				endm 
# End of macro NEXTW
2918			 
2918			.BP: 
2918				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2918 54				db WORD_SYS_CORE+64             
2919 4e 29			dw .MONITOR            
291b 03				db 2 + 1 
291c .. 00			db "BP",0              
291f				endm 
# End of macro CWHEAD
291f			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
291f			; | | $00 Will enable the break points within specific code paths 
291f			; | | $01 Will disable break points 
291f			; | |  
291f			; | | By default break points are off. Either the above can be used to enable them 
291f			; | | or if a key is held down during start up the spashscreen will appear to freeze 
291f			; | | and on release of the pressed key a message will be disaplayed to notify 
291f			; | | that break points are enabled. Pressing any key will then continue boot process. 
291f					; get byte count 
291f					if DEBUG_FORTH_WORDS_KEY 
291f						DMARK "BP." 
291f f5				push af  
2920 3a 34 29			ld a, (.dmark)  
2923 32 bd fb			ld (debug_mark),a  
2926 3a 35 29			ld a, (.dmark+1)  
2929 32 be fb			ld (debug_mark+1),a  
292c 3a 36 29			ld a, (.dmark+2)  
292f 32 bf fb			ld (debug_mark+2),a  
2932 18 03			jr .pastdmark  
2934 ..			.dmark: db "BP."  
2937 f1			.pastdmark: pop af  
2938			endm  
# End of macro DMARK
2938						CALLMONITOR 
2938 cd 6a 16			call break_point_state  
293b				endm  
# End of macro CALLMONITOR
293b					endif 
293b			 
293b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
293b cd ee 1d			call macro_dsp_valuehl 
293e				endm 
# End of macro FORTH_DSP_VALUEHL
293e			 
293e			;		push hl 
293e			 
293e					; destroy value TOS 
293e			 
293e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
293e cd a6 1e			call macro_forth_dsp_pop 
2941				endm 
# End of macro FORTH_DSP_POP
2941			 
2941			;		pop hl 
2941			 
2941 3e 00				ld a,0 
2943 bd					cp l 
2944 28 02				jr z, .bpset 
2946 3e 2a				ld a, '*' 
2948			 
2948 32 94 ef		.bpset:		ld (os_view_disable), a 
294b			 
294b			 
294b					NEXTW 
294b c3 60 1f			jp macro_next 
294e				endm 
# End of macro NEXTW
294e			 
294e			 
294e			.MONITOR: 
294e				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
294e 55				db WORD_SYS_CORE+65             
294f 81 29			dw .MALLOC            
2951 08				db 7 + 1 
2952 .. 00			db "MONITOR",0              
295a				endm 
# End of macro CWHEAD
295a			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
295a			; | | At start the current various registers will be displayed with contents. 
295a			; | | Top right corner will show the most recent debug marker seen. 
295a			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
295a			; | | and the return stack pointer (RSP). 
295a			; | | Pressing: 
295a			; | |    1 - Initial screen 
295a			; | |    2 - Display a data dump of HL 
295a			; | |    3 - Display a data dump of DE 
295a			; | |    4 - Display a data dump of BC 
295a			; | |    5 - Display a data dump of HL 
295a			; | |    6 - Display a data dump of DSP 
295a			; | |    7 - Display a data dump of RSP 
295a			; | |    8 - Display a data dump of what is at DSP 
295a			; | |    9 - Display a data dump of what is at RSP 
295a			; | |    0 - Exit monitor and continue running. This will also enable break points 
295a			; | |    * - Disable break points 
295a			; | |    # - Enter traditional monitor mode 
295a			; | | 
295a			; | | Monitor Mode 
295a			; | | ------------ 
295a			; | | A prompt of '>' will be shown for various commands: 
295a			; | |    D xxxx - Display a data dump starting from hex address xxxx 
295a			; | |    C - Continue display a data dump from the last set address 
295a			; | |    M xxxx - Set start of memory edit at address xx 
295a			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
295a			; | |    Q - Return to previous 
295a					if DEBUG_FORTH_WORDS_KEY 
295a						DMARK "MON" 
295a f5				push af  
295b 3a 6f 29			ld a, (.dmark)  
295e 32 bd fb			ld (debug_mark),a  
2961 3a 70 29			ld a, (.dmark+1)  
2964 32 be fb			ld (debug_mark+1),a  
2967 3a 71 29			ld a, (.dmark+2)  
296a 32 bf fb			ld (debug_mark+2),a  
296d 18 03			jr .pastdmark  
296f ..			.dmark: db "MON"  
2972 f1			.pastdmark: pop af  
2973			endm  
# End of macro DMARK
2973						CALLMONITOR 
2973 cd 6a 16			call break_point_state  
2976				endm  
# End of macro CALLMONITOR
2976					endif 
2976 3e 00				ld a, 0 
2978 32 94 ef				ld (os_view_disable), a 
297b			 
297b					CALLMONITOR 
297b cd 6a 16			call break_point_state  
297e				endm  
# End of macro CALLMONITOR
297e			 
297e			;	call monitor 
297e			 
297e					NEXTW 
297e c3 60 1f			jp macro_next 
2981				endm 
# End of macro NEXTW
2981			 
2981			 
2981			.MALLOC: 
2981				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2981 56				db WORD_SYS_CORE+66             
2982 aa 29			dw .MALLOC2            
2984 06				db 5 + 1 
2985 .. 00			db "ALLOT",0              
298b				endm 
# End of macro CWHEAD
298b			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
298b					if DEBUG_FORTH_WORDS_KEY 
298b						DMARK "ALL" 
298b f5				push af  
298c 3a a0 29			ld a, (.dmark)  
298f 32 bd fb			ld (debug_mark),a  
2992 3a a1 29			ld a, (.dmark+1)  
2995 32 be fb			ld (debug_mark+1),a  
2998 3a a2 29			ld a, (.dmark+2)  
299b 32 bf fb			ld (debug_mark+2),a  
299e 18 03			jr .pastdmark  
29a0 ..			.dmark: db "ALL"  
29a3 f1			.pastdmark: pop af  
29a4			endm  
# End of macro DMARK
29a4						CALLMONITOR 
29a4 cd 6a 16			call break_point_state  
29a7				endm  
# End of macro CALLMONITOR
29a7					endif 
29a7 c3 d1 29				jp .mallocc 
29aa			.MALLOC2: 
29aa				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
29aa 56				db WORD_SYS_CORE+66             
29ab e8 29			dw .FREE            
29ad 07				db 6 + 1 
29ae .. 00			db "MALLOC",0              
29b5				endm 
# End of macro CWHEAD
29b5			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
29b5					; get byte count 
29b5					if DEBUG_FORTH_WORDS_KEY 
29b5						DMARK "MAL" 
29b5 f5				push af  
29b6 3a ca 29			ld a, (.dmark)  
29b9 32 bd fb			ld (debug_mark),a  
29bc 3a cb 29			ld a, (.dmark+1)  
29bf 32 be fb			ld (debug_mark+1),a  
29c2 3a cc 29			ld a, (.dmark+2)  
29c5 32 bf fb			ld (debug_mark+2),a  
29c8 18 03			jr .pastdmark  
29ca ..			.dmark: db "MAL"  
29cd f1			.pastdmark: pop af  
29ce			endm  
# End of macro DMARK
29ce						CALLMONITOR 
29ce cd 6a 16			call break_point_state  
29d1				endm  
# End of macro CALLMONITOR
29d1					endif 
29d1			.mallocc: 
29d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29d1 cd ee 1d			call macro_dsp_valuehl 
29d4				endm 
# End of macro FORTH_DSP_VALUEHL
29d4			 
29d4			;		push hl 
29d4			 
29d4					; destroy value TOS 
29d4			 
29d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29d4 cd a6 1e			call macro_forth_dsp_pop 
29d7				endm 
# End of macro FORTH_DSP_POP
29d7			 
29d7			;		pop hl 
29d7 cd cd 11				call malloc 
29da				if DEBUG_FORTH_MALLOC_GUARD 
29da f5					push af 
29db cd 2f 0d				call ishlzero 
29de			;		ld a, l 
29de			;		add h 
29de			;		cp 0 
29de f1					pop af 
29df					 
29df cc f3 51				call z,malloc_error 
29e2				endif 
29e2			 
29e2 cd f7 1b				call forth_push_numhl 
29e5					NEXTW 
29e5 c3 60 1f			jp macro_next 
29e8				endm 
# End of macro NEXTW
29e8			 
29e8			.FREE: 
29e8				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
29e8 57				db WORD_SYS_CORE+67             
29e9 19 2a			dw .LIST            
29eb 05				db 4 + 1 
29ec .. 00			db "FREE",0              
29f1				endm 
# End of macro CWHEAD
29f1			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
29f1					if DEBUG_FORTH_WORDS_KEY 
29f1						DMARK "FRE" 
29f1 f5				push af  
29f2 3a 06 2a			ld a, (.dmark)  
29f5 32 bd fb			ld (debug_mark),a  
29f8 3a 07 2a			ld a, (.dmark+1)  
29fb 32 be fb			ld (debug_mark+1),a  
29fe 3a 08 2a			ld a, (.dmark+2)  
2a01 32 bf fb			ld (debug_mark+2),a  
2a04 18 03			jr .pastdmark  
2a06 ..			.dmark: db "FRE"  
2a09 f1			.pastdmark: pop af  
2a0a			endm  
# End of macro DMARK
2a0a						CALLMONITOR 
2a0a cd 6a 16			call break_point_state  
2a0d				endm  
# End of macro CALLMONITOR
2a0d					endif 
2a0d					; get address 
2a0d			 
2a0d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a0d cd ee 1d			call macro_dsp_valuehl 
2a10				endm 
# End of macro FORTH_DSP_VALUEHL
2a10			 
2a10			;		push hl 
2a10			 
2a10					; destroy value TOS 
2a10			 
2a10					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a10 cd a6 1e			call macro_forth_dsp_pop 
2a13				endm 
# End of macro FORTH_DSP_POP
2a13			 
2a13			;		pop hl 
2a13			if FORTH_ENABLE_MALLOCFREE 
2a13 cd 97 12				call free 
2a16			endif 
2a16					NEXTW 
2a16 c3 60 1f			jp macro_next 
2a19				endm 
# End of macro NEXTW
2a19			.LIST: 
2a19				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2a19 5c				db WORD_SYS_CORE+72             
2a1a dc 2b			dw .FORGET            
2a1c 05				db 4 + 1 
2a1d .. 00			db "LIST",0              
2a22				endm 
# End of macro CWHEAD
2a22			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2a22			; | | The quoted word must be in upper case. 
2a22				if DEBUG_FORTH_WORDS_KEY 
2a22					DMARK "LST" 
2a22 f5				push af  
2a23 3a 37 2a			ld a, (.dmark)  
2a26 32 bd fb			ld (debug_mark),a  
2a29 3a 38 2a			ld a, (.dmark+1)  
2a2c 32 be fb			ld (debug_mark+1),a  
2a2f 3a 39 2a			ld a, (.dmark+2)  
2a32 32 bf fb			ld (debug_mark+2),a  
2a35 18 03			jr .pastdmark  
2a37 ..			.dmark: db "LST"  
2a3a f1			.pastdmark: pop af  
2a3b			endm  
# End of macro DMARK
2a3b					CALLMONITOR 
2a3b cd 6a 16			call break_point_state  
2a3e				endm  
# End of macro CALLMONITOR
2a3e				endif 
2a3e			 
2a3e					FORTH_DSP_VALUEHL 
2a3e cd ee 1d			call macro_dsp_valuehl 
2a41				endm 
# End of macro FORTH_DSP_VALUEHL
2a41			 
2a41 e5					push hl 
2a42 c1					pop bc 
2a43			 
2a43			; Start format of scratch string 
2a43			 
2a43 21 a3 ef				ld hl, scratch 
2a46			 
2a46 3e 3a				ld a, ':' 
2a48 77					ld (hl),a 
2a49 23					inc hl 
2a4a 3e 20				ld a, ' ' 
2a4c 77					ld (hl), a 
2a4d			 
2a4d					; Get ptr to the word we need to look up 
2a4d			 
2a4d			;		FORTH_DSP_VALUEHL 
2a4d					;v5 FORTH_DSP_VALUE 
2a4d				; TODO type check 
2a4d			;		inc hl    ; Skip type check  
2a4d			;		push hl 
2a4d			;		ex de, hl    ; put into DE 
2a4d			 
2a4d			 
2a4d 21 00 80				ld hl, baseram 
2a50					;ld hl, baseusermem 
2a50			 
2a50 e5			push hl   ; sacreifical push 
2a51			 
2a51			.ldouscanm: 
2a51 e1				pop hl 
2a52			.ldouscan: 
2a52				if DEBUG_FORTH_WORDS 
2a52					DMARK "LSs" 
2a52 f5				push af  
2a53 3a 67 2a			ld a, (.dmark)  
2a56 32 bd fb			ld (debug_mark),a  
2a59 3a 68 2a			ld a, (.dmark+1)  
2a5c 32 be fb			ld (debug_mark+1),a  
2a5f 3a 69 2a			ld a, (.dmark+2)  
2a62 32 bf fb			ld (debug_mark+2),a  
2a65 18 03			jr .pastdmark  
2a67 ..			.dmark: db "LSs"  
2a6a f1			.pastdmark: pop af  
2a6b			endm  
# End of macro DMARK
2a6b					CALLMONITOR 
2a6b cd 6a 16			call break_point_state  
2a6e				endm  
# End of macro CALLMONITOR
2a6e				endif 
2a6e				; skip dict stub 
2a6e cd b1 20				call forth_tok_next 
2a71			 
2a71			 
2a71			; while we have words to look for 
2a71			 
2a71 7e				ld a, (hl)      
2a72				if DEBUG_FORTH_WORDS 
2a72					DMARK "LSk" 
2a72 f5				push af  
2a73 3a 87 2a			ld a, (.dmark)  
2a76 32 bd fb			ld (debug_mark),a  
2a79 3a 88 2a			ld a, (.dmark+1)  
2a7c 32 be fb			ld (debug_mark+1),a  
2a7f 3a 89 2a			ld a, (.dmark+2)  
2a82 32 bf fb			ld (debug_mark+2),a  
2a85 18 03			jr .pastdmark  
2a87 ..			.dmark: db "LSk"  
2a8a f1			.pastdmark: pop af  
2a8b			endm  
# End of macro DMARK
2a8b					CALLMONITOR 
2a8b cd 6a 16			call break_point_state  
2a8e				endm  
# End of macro CALLMONITOR
2a8e				endif 
2a8e fe 00				cp WORD_SYS_END 
2a90 ca c3 2b				jp z, .lunotfound 
2a93 fe 01				cp WORD_SYS_UWORD 
2a95 c2 52 2a				jp nz, .ldouscan 
2a98			 
2a98				if DEBUG_FORTH_WORDS 
2a98					DMARK "LSu" 
2a98 f5				push af  
2a99 3a ad 2a			ld a, (.dmark)  
2a9c 32 bd fb			ld (debug_mark),a  
2a9f 3a ae 2a			ld a, (.dmark+1)  
2aa2 32 be fb			ld (debug_mark+1),a  
2aa5 3a af 2a			ld a, (.dmark+2)  
2aa8 32 bf fb			ld (debug_mark+2),a  
2aab 18 03			jr .pastdmark  
2aad ..			.dmark: db "LSu"  
2ab0 f1			.pastdmark: pop af  
2ab1			endm  
# End of macro DMARK
2ab1					CALLMONITOR 
2ab1 cd 6a 16			call break_point_state  
2ab4				endm  
# End of macro CALLMONITOR
2ab4				endif 
2ab4			 
2ab4					; found a uword but is it the one we want... 
2ab4			 
2ab4 c5					push bc     ; uword to find is on bc 
2ab5 d1					pop de 
2ab6			 
2ab6 e5					push hl  ; to save the ptr 
2ab7			 
2ab7					; skip opcode 
2ab7 23					inc hl  
2ab8					; skip next ptr 
2ab8 23					inc hl  
2ab9 23					inc hl 
2aba					; skip len 
2aba 23					inc hl 
2abb			 
2abb				if DEBUG_FORTH_WORDS 
2abb					DMARK "LSc" 
2abb f5				push af  
2abc 3a d0 2a			ld a, (.dmark)  
2abf 32 bd fb			ld (debug_mark),a  
2ac2 3a d1 2a			ld a, (.dmark+1)  
2ac5 32 be fb			ld (debug_mark+1),a  
2ac8 3a d2 2a			ld a, (.dmark+2)  
2acb 32 bf fb			ld (debug_mark+2),a  
2ace 18 03			jr .pastdmark  
2ad0 ..			.dmark: db "LSc"  
2ad3 f1			.pastdmark: pop af  
2ad4			endm  
# End of macro DMARK
2ad4					CALLMONITOR 
2ad4 cd 6a 16			call break_point_state  
2ad7				endm  
# End of macro CALLMONITOR
2ad7				endif 
2ad7 cd 9c 11				call strcmp 
2ada c2 51 2a				jp nz, .ldouscanm 
2add				 
2add			 
2add			 
2add					; we have a uword so push its name to the stack 
2add			 
2add			;	   	push hl  ; save so we can move to next dict block 
2add e1			pop hl 
2ade			 
2ade				if DEBUG_FORTH_WORDS 
2ade					DMARK "LSm" 
2ade f5				push af  
2adf 3a f3 2a			ld a, (.dmark)  
2ae2 32 bd fb			ld (debug_mark),a  
2ae5 3a f4 2a			ld a, (.dmark+1)  
2ae8 32 be fb			ld (debug_mark+1),a  
2aeb 3a f5 2a			ld a, (.dmark+2)  
2aee 32 bf fb			ld (debug_mark+2),a  
2af1 18 03			jr .pastdmark  
2af3 ..			.dmark: db "LSm"  
2af6 f1			.pastdmark: pop af  
2af7			endm  
# End of macro DMARK
2af7					CALLMONITOR 
2af7 cd 6a 16			call break_point_state  
2afa				endm  
# End of macro CALLMONITOR
2afa				endif 
2afa			 
2afa					; skip opcode 
2afa 23					inc hl  
2afb					; skip next ptr 
2afb 23					inc hl  
2afc 23					inc hl 
2afd					; skip len 
2afd 7e					ld a, (hl)   ; save length to add 
2afe				if DEBUG_FORTH_WORDS 
2afe					DMARK "LS2" 
2afe f5				push af  
2aff 3a 13 2b			ld a, (.dmark)  
2b02 32 bd fb			ld (debug_mark),a  
2b05 3a 14 2b			ld a, (.dmark+1)  
2b08 32 be fb			ld (debug_mark+1),a  
2b0b 3a 15 2b			ld a, (.dmark+2)  
2b0e 32 bf fb			ld (debug_mark+2),a  
2b11 18 03			jr .pastdmark  
2b13 ..			.dmark: db "LS2"  
2b16 f1			.pastdmark: pop af  
2b17			endm  
# End of macro DMARK
2b17					CALLMONITOR 
2b17 cd 6a 16			call break_point_state  
2b1a				endm  
# End of macro CALLMONITOR
2b1a				endif 
2b1a			 
2b1a					; save this location 
2b1a				 
2b1a e5					push hl 
2b1b			 
2b1b 23					inc hl 
2b1c 11 a5 ef				ld de, scratch+2 
2b1f 4f					ld c, a 
2b20 06 00				ld b, 0 
2b22			 
2b22				if DEBUG_FORTH_WORDS 
2b22					DMARK "LSn" 
2b22 f5				push af  
2b23 3a 37 2b			ld a, (.dmark)  
2b26 32 bd fb			ld (debug_mark),a  
2b29 3a 38 2b			ld a, (.dmark+1)  
2b2c 32 be fb			ld (debug_mark+1),a  
2b2f 3a 39 2b			ld a, (.dmark+2)  
2b32 32 bf fb			ld (debug_mark+2),a  
2b35 18 03			jr .pastdmark  
2b37 ..			.dmark: db "LSn"  
2b3a f1			.pastdmark: pop af  
2b3b			endm  
# End of macro DMARK
2b3b					CALLMONITOR 
2b3b cd 6a 16			call break_point_state  
2b3e				endm  
# End of macro CALLMONITOR
2b3e				endif 
2b3e			 
2b3e					; copy uword name to scratch 
2b3e			 
2b3e ed b0				ldir 
2b40			 
2b40 1b					dec de 
2b41 3e 20				ld a, ' '    ; change null to space 
2b43 12					ld (de), a 
2b44			 
2b44 13					inc de 
2b45			 
2b45 d5					push de 
2b46 c1					pop bc     ; move scratch pointer to end of word name and save it 
2b47			 
2b47 e1					pop hl 
2b48 7e					ld a, (hl) 
2b49					;inc hl 
2b49					; skip word string 
2b49 cd 06 0d				call addatohl 
2b4c			 
2b4c 23					inc hl 
2b4d			 
2b4d				if DEBUG_FORTH_WORDS 
2b4d					DMARK "LS3" 
2b4d f5				push af  
2b4e 3a 62 2b			ld a, (.dmark)  
2b51 32 bd fb			ld (debug_mark),a  
2b54 3a 63 2b			ld a, (.dmark+1)  
2b57 32 be fb			ld (debug_mark+1),a  
2b5a 3a 64 2b			ld a, (.dmark+2)  
2b5d 32 bf fb			ld (debug_mark+2),a  
2b60 18 03			jr .pastdmark  
2b62 ..			.dmark: db "LS3"  
2b65 f1			.pastdmark: pop af  
2b66			endm  
# End of macro DMARK
2b66					CALLMONITOR 
2b66 cd 6a 16			call break_point_state  
2b69				endm  
# End of macro CALLMONITOR
2b69				endif 
2b69					; should now be at the start of the machine code to setup the eval of the uword 
2b69					; now locate the ptr to the string defintion 
2b69			 
2b69					; skip ld hl, 
2b69					; then load the ptr 
2b69			 
2b69 23					inc hl 
2b6a 5e					ld e, (hl) 
2b6b 23					inc hl 
2b6c 56					ld d, (hl) 
2b6d eb					ex de, hl 
2b6e			 
2b6e			 
2b6e				if DEBUG_FORTH_WORDS 
2b6e					DMARK "LSt" 
2b6e f5				push af  
2b6f 3a 83 2b			ld a, (.dmark)  
2b72 32 bd fb			ld (debug_mark),a  
2b75 3a 84 2b			ld a, (.dmark+1)  
2b78 32 be fb			ld (debug_mark+1),a  
2b7b 3a 85 2b			ld a, (.dmark+2)  
2b7e 32 bf fb			ld (debug_mark+2),a  
2b81 18 03			jr .pastdmark  
2b83 ..			.dmark: db "LSt"  
2b86 f1			.pastdmark: pop af  
2b87			endm  
# End of macro DMARK
2b87					CALLMONITOR 
2b87 cd 6a 16			call break_point_state  
2b8a				endm  
# End of macro CALLMONITOR
2b8a				endif 
2b8a			 
2b8a			; cant push right now due to tokenised strings  
2b8a			 
2b8a			; get the destination of where to copy this definition to. 
2b8a			 
2b8a c5					push bc 
2b8b d1					pop de 
2b8c			 
2b8c 7e			.listl:         ld a,(hl) 
2b8d fe 00				cp 0 
2b8f 28 09				jr z, .lreplsp     ; replace zero with space 
2b91 fe 7f				cp FORTH_END_BUFFER 
2b93 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2b95				 
2b95					; just copy this char as is then 
2b95			 
2b95 12					ld (de), a 
2b96			 
2b96 23			.listnxt:	inc hl 
2b97 13					inc de 
2b98 18 f2				jr .listl 
2b9a			 
2b9a 3e 20		.lreplsp:	ld a,' ' 
2b9c 12					ld (de), a 
2b9d 18 f7				jr .listnxt 
2b9f			 
2b9f			; close up uword def 
2b9f			 
2b9f			.listdone: 
2b9f 3e 00				ld a, 0 
2ba1 12					ld (de), a 
2ba2			 
2ba2			; now have def so clean up and push to stack 
2ba2			 
2ba2 21 a3 ef				ld hl, scratch 
2ba5				if DEBUG_FORTH_WORDS 
2ba5					DMARK "Ltp" 
2ba5 f5				push af  
2ba6 3a ba 2b			ld a, (.dmark)  
2ba9 32 bd fb			ld (debug_mark),a  
2bac 3a bb 2b			ld a, (.dmark+1)  
2baf 32 be fb			ld (debug_mark+1),a  
2bb2 3a bc 2b			ld a, (.dmark+2)  
2bb5 32 bf fb			ld (debug_mark+2),a  
2bb8 18 03			jr .pastdmark  
2bba ..			.dmark: db "Ltp"  
2bbd f1			.pastdmark: pop af  
2bbe			endm  
# End of macro DMARK
2bbe					CALLMONITOR 
2bbe cd 6a 16			call break_point_state  
2bc1				endm  
# End of macro CALLMONITOR
2bc1				endif 
2bc1			 
2bc1 18 06			jr .listpush 
2bc3			 
2bc3			;.lnuword:	pop hl 
2bc3			;		call forth_tok_next 
2bc3			;		jp .ldouscan  
2bc3			 
2bc3			.lunotfound:		  
2bc3			 
2bc3			 
2bc3					 
2bc3					FORTH_DSP_POP 
2bc3 cd a6 1e			call macro_forth_dsp_pop 
2bc6				endm 
# End of macro FORTH_DSP_POP
2bc6 21 cf 2b				ld hl, .luno 
2bc9						 
2bc9			 
2bc9			.listpush: 
2bc9 cd 65 1c				call forth_push_str 
2bcc			 
2bcc			 
2bcc			 
2bcc					NEXTW 
2bcc c3 60 1f			jp macro_next 
2bcf				endm 
# End of macro NEXTW
2bcf			 
2bcf .. 00		.luno:    db "Not found",0 
2bd9			 
2bd9			 
2bd9			 
2bd9			 
2bd9			 
2bd9			;		push hl   ; save pointer to start of uword def string 
2bd9			; 
2bd9			;; look for FORTH_EOL_LINE 
2bd9			;		ld a, FORTH_END_BUFFER 
2bd9			;		call strlent 
2bd9			; 
2bd9			;		inc hl		 ; space for coln def 
2bd9			;		inc hl 
2bd9			;		inc hl          ; space for terms 
2bd9			;		inc hl 
2bd9			; 
2bd9			;		ld a, 20   ; TODO get actual length 
2bd9			;		call addatohl    ; include a random amount of room for the uword name 
2bd9			; 
2bd9			;		 
2bd9			;	if DEBUG_FORTH_WORDS 
2bd9			;		DMARK "Lt1" 
2bd9			;		CALLMONITOR 
2bd9			;	endif 
2bd9			;		 
2bd9			; 
2bd9			;; malloc space for the string because we cant change it 
2bd9			; 
2bd9			;		call malloc 
2bd9			;	if DEBUG_FORTH_MALLOC_GUARD 
2bd9			;		push af 
2bd9			;		call ishlzero 
2bd9			;		pop af 
2bd9			;		 
2bd9			;		call z,malloc_error 
2bd9			;	endif 
2bd9			; 
2bd9			;	if DEBUG_FORTH_WORDS 
2bd9			;		DMARK "Lt2" 
2bd9			;		CALLMONITOR 
2bd9			;	endif 
2bd9			;		pop de 
2bd9			;		push hl    ; push the malloc to release later 
2bd9			;		push hl   ;  push back a copy for the later stack push 
2bd9			;		 
2bd9			;; copy the string swapping out the zero terms for spaces 
2bd9			; 
2bd9			;		; de has our source 
2bd9			;		; hl has our dest 
2bd9			; 
2bd9			;; add the coln def 
2bd9			; 
2bd9			;		ld a, ':' 
2bd9			;		ld (hl), a 
2bd9			;		inc hl 
2bd9			;		ld a, ' ' 
2bd9			;		ld (hl), a 
2bd9			;		inc hl 
2bd9			; 
2bd9			;; add the uname word 
2bd9			;		push de   ; save our string for now 
2bd9			;		ex de, hl 
2bd9			; 
2bd9			;		FORTH_DSP_VALUE 
2bd9			;		;v5 FORTH_DSP_VALUE 
2bd9			; 
2bd9			;		inc hl   ; skip type but we know by now this is OK 
2bd9			; 
2bd9			;.luword:	ld a,(hl) 
2bd9			;		cp 0 
2bd9			;		jr z, .luword2 
2bd9			;		ld (de), a 
2bd9			;		inc de 
2bd9			;		inc hl 
2bd9			;		jr .luword 
2bd9			; 
2bd9			;.luword2:	ld a, ' ' 
2bd9			;		ld (de), a 
2bd9			;;		inc hl 
2bd9			;;		inc de 
2bd9			;;		ld (de), a 
2bd9			;;		inc hl 
2bd9			;		inc de 
2bd9			; 
2bd9			;		ex de, hl 
2bd9			;		pop de 
2bd9			;		 
2bd9			;		 
2bd9			; 
2bd9			;; detoken that string and copy it 
2bd9			; 
2bd9			;	if DEBUG_FORTH_WORDS 
2bd9			;		DMARK "Lt2" 
2bd9			;		CALLMONITOR 
2bd9			;	endif 
2bd9			;.ldetok:	ld a, (de) 
2bd9			;		cp FORTH_END_BUFFER 
2bd9			;		jr z, .ldetokend 
2bd9			;		; swap out any zero term for space 
2bd9			;		cp 0 
2bd9			;		jr nz, .ldetoknext 
2bd9			;		ld a, ' ' 
2bd9			; 
2bd9			;	if DEBUG_FORTH_WORDS 
2bd9			;		DMARK "LtS" 
2bd9			;		CALLMONITOR 
2bd9			;	endif 
2bd9			;.ldetoknext:	ld (hl), a 
2bd9			;		inc de 
2bd9			;		inc hl 
2bd9			;		jr .ldetok 
2bd9			; 
2bd9			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2bd9			;		ld (hl), a  
2bd9			; 
2bd9			;; free that temp malloc 
2bd9			; 
2bd9			;		pop hl    
2bd9			; 
2bd9			;	if DEBUG_FORTH_WORDS 
2bd9			;		DMARK "Lt4" 
2bd9			;		CALLMONITOR 
2bd9			;	endif 
2bd9			;		call forth_apushstrhl 
2bd9			; 
2bd9			;		; get rid of temp malloc area 
2bd9			; 
2bd9			;		pop hl 
2bd9			;		call free 
2bd9			; 
2bd9			;		jr .ludone 
2bd9			; 
2bd9			;.lnuword:	pop hl 
2bd9			;		call forth_tok_next 
2bd9			;		jp .ldouscan  
2bd9			; 
2bd9			;.ludone:		 pop hl 
2bd9			; 
2bd9					NEXTW 
2bd9 c3 60 1f			jp macro_next 
2bdc				endm 
# End of macro NEXTW
2bdc			 
2bdc			.FORGET: 
2bdc				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2bdc 5d				db WORD_SYS_CORE+73             
2bdd 55 2c			dw .NOP            
2bdf 07				db 6 + 1 
2be0 .. 00			db "FORGET",0              
2be7				endm 
# End of macro CWHEAD
2be7			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2be7			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2be7			; | |  
2be7			; | | e.g. "MORE" forget 
2be7					if DEBUG_FORTH_WORDS_KEY 
2be7						DMARK "FRG" 
2be7 f5				push af  
2be8 3a fc 2b			ld a, (.dmark)  
2beb 32 bd fb			ld (debug_mark),a  
2bee 3a fd 2b			ld a, (.dmark+1)  
2bf1 32 be fb			ld (debug_mark+1),a  
2bf4 3a fe 2b			ld a, (.dmark+2)  
2bf7 32 bf fb			ld (debug_mark+2),a  
2bfa 18 03			jr .pastdmark  
2bfc ..			.dmark: db "FRG"  
2bff f1			.pastdmark: pop af  
2c00			endm  
# End of macro DMARK
2c00						CALLMONITOR 
2c00 cd 6a 16			call break_point_state  
2c03				endm  
# End of macro CALLMONITOR
2c03					endif 
2c03			 
2c03				; find uword 
2c03			        ; update start of word with "_" 
2c03				; replace uword with deleted flag 
2c03			 
2c03			 
2c03			;	if DEBUG_FORTH_WORDS 
2c03			;		DMARK "FOG" 
2c03			;		CALLMONITOR 
2c03			;	endif 
2c03			 
2c03			 
2c03					; Get ptr to the word we need to look up 
2c03			 
2c03					FORTH_DSP_VALUEHL 
2c03 cd ee 1d			call macro_dsp_valuehl 
2c06				endm 
# End of macro FORTH_DSP_VALUEHL
2c06					;v5 FORTH_DSP_VALUE 
2c06				; TODO type check 
2c06			;		inc hl    ; Skip type check  
2c06 e5					push hl 
2c07 c1					pop bc 
2c08			;		ex de, hl    ; put into DE 
2c08			 
2c08			 
2c08 21 00 80				ld hl, baseram 
2c0b					;ld hl, baseusermem 
2c0b			 
2c0b				; skip dict stub 
2c0b			;	call forth_tok_next 
2c0b e5			push hl   ; sacreifical push 
2c0c			 
2c0c			.fldouscanm: 
2c0c e1				pop hl 
2c0d			.fldouscan: 
2c0d			;	if DEBUG_FORTH_WORDS 
2c0d			;		DMARK "LSs" 
2c0d			;		CALLMONITOR 
2c0d			;	endif 
2c0d				; skip dict stub 
2c0d cd b1 20				call forth_tok_next 
2c10			 
2c10			 
2c10			; while we have words to look for 
2c10			 
2c10 7e				ld a, (hl)      
2c11			;	if DEBUG_FORTH_WORDS 
2c11			;		DMARK "LSk" 
2c11			;		CALLMONITOR 
2c11			;	endif 
2c11 fe 00				cp WORD_SYS_END 
2c13 ca 4f 2c				jp z, .flunotfound 
2c16 fe 01				cp WORD_SYS_UWORD 
2c18 c2 0d 2c				jp nz, .fldouscan 
2c1b			 
2c1b			;	if DEBUG_FORTH_WORDS 
2c1b			;		DMARK "LSu" 
2c1b			;		CALLMONITOR 
2c1b			;	endif 
2c1b			 
2c1b					; found a uword but is it the one we want... 
2c1b			 
2c1b c5					push bc     ; uword to find is on bc 
2c1c d1					pop de 
2c1d			 
2c1d e5					push hl  ; to save the ptr 
2c1e			 
2c1e					; skip opcode 
2c1e 23					inc hl  
2c1f					; skip next ptr 
2c1f 23					inc hl  
2c20 23					inc hl 
2c21					; skip len 
2c21 23					inc hl 
2c22			 
2c22			;	if DEBUG_FORTH_WORDS 
2c22			;		DMARK "LSc" 
2c22			;		CALLMONITOR 
2c22			;	endif 
2c22 cd 9c 11				call strcmp 
2c25 c2 0c 2c				jp nz, .fldouscanm 
2c28			; 
2c28			; 
2c28			;; while we have words to look for 
2c28			; 
2c28			;.fdouscan:	ld a, (hl)      
2c28			;	if DEBUG_FORTH_WORDS 
2c28			;		DMARK "LSs" 
2c28			;		CALLMONITOR 
2c28			;	endif 
2c28			;		cp WORD_SYS_END 
2c28			;		jp z, .fudone 
2c28			;		cp WORD_SYS_UWORD 
2c28			;		jp nz, .fnuword 
2c28			; 
2c28			;	if DEBUG_FORTH_WORDS 
2c28			;		DMARK "FGu" 
2c28			;		CALLMONITOR 
2c28			;	endif 
2c28			; 
2c28			;		; found a uword but is it the one we want... 
2c28			; 
2c28			; 
2c28			;	        pop de   ; get back the dsp name 
2c28			;		push de 
2c28			; 
2c28			;		push hl  ; to save the ptr 
2c28			; 
2c28			;		; skip opcode 
2c28			;		inc hl  
2c28			;		; skip next ptr 
2c28			;		inc hl  
2c28			;		inc hl 
2c28			;		; skip len 
2c28			;		inc hl 
2c28			; 
2c28			;	if DEBUG_FORTH_WORDS 
2c28			;		DMARK "FGc" 
2c28			;		CALLMONITOR 
2c28			;	endif 
2c28			;		call strcmp 
2c28			;		jp nz, .fnuword 
2c28			 
2c28			 
2c28 e1			pop hl 
2c29			 
2c29				 
2c29				if DEBUG_FORTH_WORDS 
2c29					DMARK "FGm" 
2c29 f5				push af  
2c2a 3a 3e 2c			ld a, (.dmark)  
2c2d 32 bd fb			ld (debug_mark),a  
2c30 3a 3f 2c			ld a, (.dmark+1)  
2c33 32 be fb			ld (debug_mark+1),a  
2c36 3a 40 2c			ld a, (.dmark+2)  
2c39 32 bf fb			ld (debug_mark+2),a  
2c3c 18 03			jr .pastdmark  
2c3e ..			.dmark: db "FGm"  
2c41 f1			.pastdmark: pop af  
2c42			endm  
# End of macro DMARK
2c42					CALLMONITOR 
2c42 cd 6a 16			call break_point_state  
2c45				endm  
# End of macro CALLMONITOR
2c45				endif 
2c45			 
2c45			 
2c45			 
2c45					; we have a uword so push its name to the stack 
2c45			 
2c45			;	   	push hl  ; save so we can move to next dict block 
2c45			;pop hl 
2c45			 
2c45					; update opcode to deleted 
2c45 3e 03				ld a, WORD_SYS_DELETED 
2c47 77					ld (hl), a 
2c48			 
2c48 23					inc hl  
2c49					; skip next ptr 
2c49 23					inc hl  
2c4a 23					inc hl 
2c4b					; skip len 
2c4b 23					inc hl 
2c4c			 
2c4c					; TODO change parser to skip deleted words but for now mark it out 
2c4c 3e 5f				ld a, "_" 
2c4e 77					ld  (hl),a 
2c4f			 
2c4f			;		jr .fudone 
2c4f			; 
2c4f			;.fnuword:	pop hl 
2c4f			;		call forth_tok_next 
2c4f			;		jp .fdouscan  
2c4f			 
2c4f			.flunotfound:		  
2c4f			 
2c4f			 
2c4f					 
2c4f					FORTH_DSP_POP 
2c4f cd a6 1e			call macro_forth_dsp_pop 
2c52				endm 
# End of macro FORTH_DSP_POP
2c52			;		ld hl, .luno 
2c52			;.fudone:		 pop hl 
2c52					NEXTW 
2c52 c3 60 1f			jp macro_next 
2c55				endm 
# End of macro NEXTW
2c55			.NOP: 
2c55				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2c55 61				db WORD_SYS_CORE+77             
2c56 7c 2c			dw .COMO            
2c58 04				db 3 + 1 
2c59 .. 00			db "NOP",0              
2c5d				endm 
# End of macro CWHEAD
2c5d			; | NOP (  --  ) Do nothing | DONE 
2c5d					if DEBUG_FORTH_WORDS_KEY 
2c5d						DMARK "NOP" 
2c5d f5				push af  
2c5e 3a 72 2c			ld a, (.dmark)  
2c61 32 bd fb			ld (debug_mark),a  
2c64 3a 73 2c			ld a, (.dmark+1)  
2c67 32 be fb			ld (debug_mark+1),a  
2c6a 3a 74 2c			ld a, (.dmark+2)  
2c6d 32 bf fb			ld (debug_mark+2),a  
2c70 18 03			jr .pastdmark  
2c72 ..			.dmark: db "NOP"  
2c75 f1			.pastdmark: pop af  
2c76			endm  
# End of macro DMARK
2c76						CALLMONITOR 
2c76 cd 6a 16			call break_point_state  
2c79				endm  
# End of macro CALLMONITOR
2c79					endif 
2c79				       NEXTW 
2c79 c3 60 1f			jp macro_next 
2c7c				endm 
# End of macro NEXTW
2c7c			.COMO: 
2c7c				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2c7c 6e				db WORD_SYS_CORE+90             
2c7d ce 2c			dw .COMC            
2c7f 02				db 1 + 1 
2c80 .. 00			db "(",0              
2c82				endm 
# End of macro CWHEAD
2c82			; | ( ( -- )  Start of comment | DONE 
2c82			 
2c82			 
2c82 2a a4 f2				ld hl, ( os_tok_ptr) 
2c85 11 c9 2c			ld de, .closepar 
2c88					 
2c88					if DEBUG_FORTH_WORDS 
2c88						DMARK ").." 
2c88 f5				push af  
2c89 3a 9d 2c			ld a, (.dmark)  
2c8c 32 bd fb			ld (debug_mark),a  
2c8f 3a 9e 2c			ld a, (.dmark+1)  
2c92 32 be fb			ld (debug_mark+1),a  
2c95 3a 9f 2c			ld a, (.dmark+2)  
2c98 32 bf fb			ld (debug_mark+2),a  
2c9b 18 03			jr .pastdmark  
2c9d ..			.dmark: db ").."  
2ca0 f1			.pastdmark: pop af  
2ca1			endm  
# End of macro DMARK
2ca1						CALLMONITOR 
2ca1 cd 6a 16			call break_point_state  
2ca4				endm  
# End of macro CALLMONITOR
2ca4					endif 
2ca4 cd 7b 20			call findnexttok  
2ca7			 
2ca7					if DEBUG_FORTH_WORDS 
2ca7						DMARK "IF5" 
2ca7 f5				push af  
2ca8 3a bc 2c			ld a, (.dmark)  
2cab 32 bd fb			ld (debug_mark),a  
2cae 3a bd 2c			ld a, (.dmark+1)  
2cb1 32 be fb			ld (debug_mark+1),a  
2cb4 3a be 2c			ld a, (.dmark+2)  
2cb7 32 bf fb			ld (debug_mark+2),a  
2cba 18 03			jr .pastdmark  
2cbc ..			.dmark: db "IF5"  
2cbf f1			.pastdmark: pop af  
2cc0			endm  
# End of macro DMARK
2cc0						CALLMONITOR 
2cc0 cd 6a 16			call break_point_state  
2cc3				endm  
# End of macro CALLMONITOR
2cc3					endif 
2cc3				; replace below with ) exec using tok_ptr 
2cc3 22 a4 f2			ld (os_tok_ptr), hl 
2cc6 c3 f1 1f			jp exec1 
2cc9			 
2cc9 .. 00			.closepar:   db ")",0 
2ccb			 
2ccb				       NEXTW 
2ccb c3 60 1f			jp macro_next 
2cce				endm 
# End of macro NEXTW
2cce			.COMC: 
2cce				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2cce 6f				db WORD_SYS_CORE+91             
2ccf d7 2c			dw .SCRATCH            
2cd1 02				db 1 + 1 
2cd2 .. 00			db ")",0              
2cd4				endm 
# End of macro CWHEAD
2cd4			; | ) ( -- )  End of comment |  DONE  
2cd4				       NEXTW 
2cd4 c3 60 1f			jp macro_next 
2cd7				endm 
# End of macro NEXTW
2cd7			 
2cd7			.SCRATCH: 
2cd7				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2cd7 6f				db WORD_SYS_CORE+91             
2cd8 12 2d			dw .INC            
2cda 08				db 7 + 1 
2cdb .. 00			db "SCRATCH",0              
2ce3				endm 
# End of macro CWHEAD
2ce3			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2ce3			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2ce3			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2ce3			; | |  
2ce3			; | | e.g.    : score $00 scratch ; 
2ce3			; | |  
2ce3			; | | $00 score ! 
2ce3			; | | $01 score +! 
2ce3			; | |  
2ce3			; | | e.g.   : varword $0a scratch ;  
2ce3			; | | 
2ce3			; | | $8000 varword ! 
2ce3					if DEBUG_FORTH_WORDS_KEY 
2ce3						DMARK "SCR" 
2ce3 f5				push af  
2ce4 3a f8 2c			ld a, (.dmark)  
2ce7 32 bd fb			ld (debug_mark),a  
2cea 3a f9 2c			ld a, (.dmark+1)  
2ced 32 be fb			ld (debug_mark+1),a  
2cf0 3a fa 2c			ld a, (.dmark+2)  
2cf3 32 bf fb			ld (debug_mark+2),a  
2cf6 18 03			jr .pastdmark  
2cf8 ..			.dmark: db "SCR"  
2cfb f1			.pastdmark: pop af  
2cfc			endm  
# End of macro DMARK
2cfc						CALLMONITOR 
2cfc cd 6a 16			call break_point_state  
2cff				endm  
# End of macro CALLMONITOR
2cff					endif 
2cff			 
2cff					FORTH_DSP_VALUEHL 
2cff cd ee 1d			call macro_dsp_valuehl 
2d02				endm 
# End of macro FORTH_DSP_VALUEHL
2d02				 
2d02					FORTH_DSP_POP 
2d02 cd a6 1e			call macro_forth_dsp_pop 
2d05				endm 
# End of macro FORTH_DSP_POP
2d05			 
2d05 7d					ld a, l 
2d06 21 c8 f4				ld hl, os_var_array 
2d09 cd 06 0d				call addatohl 
2d0c			 
2d0c cd f7 1b				call forth_push_numhl 
2d0f			 
2d0f				       NEXTW 
2d0f c3 60 1f			jp macro_next 
2d12				endm 
# End of macro NEXTW
2d12			 
2d12			.INC: 
2d12				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2d12 6f				db WORD_SYS_CORE+91             
2d13 66 2d			dw .DEC            
2d15 03				db 2 + 1 
2d16 .. 00			db "+!",0              
2d19				endm 
# End of macro CWHEAD
2d19			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2d19					if DEBUG_FORTH_WORDS_KEY 
2d19						DMARK "+s_" 
2d19 f5				push af  
2d1a 3a 2e 2d			ld a, (.dmark)  
2d1d 32 bd fb			ld (debug_mark),a  
2d20 3a 2f 2d			ld a, (.dmark+1)  
2d23 32 be fb			ld (debug_mark+1),a  
2d26 3a 30 2d			ld a, (.dmark+2)  
2d29 32 bf fb			ld (debug_mark+2),a  
2d2c 18 03			jr .pastdmark  
2d2e ..			.dmark: db "+s_"  
2d31 f1			.pastdmark: pop af  
2d32			endm  
# End of macro DMARK
2d32						CALLMONITOR 
2d32 cd 6a 16			call break_point_state  
2d35				endm  
# End of macro CALLMONITOR
2d35					endif 
2d35			 
2d35					FORTH_DSP_VALUEHL 
2d35 cd ee 1d			call macro_dsp_valuehl 
2d38				endm 
# End of macro FORTH_DSP_VALUEHL
2d38			 
2d38 e5					push hl   ; save address 
2d39			 
2d39					FORTH_DSP_POP 
2d39 cd a6 1e			call macro_forth_dsp_pop 
2d3c				endm 
# End of macro FORTH_DSP_POP
2d3c			 
2d3c					FORTH_DSP_VALUEHL 
2d3c cd ee 1d			call macro_dsp_valuehl 
2d3f				endm 
# End of macro FORTH_DSP_VALUEHL
2d3f			 
2d3f					FORTH_DSP_POP 
2d3f cd a6 1e			call macro_forth_dsp_pop 
2d42				endm 
# End of macro FORTH_DSP_POP
2d42			 
2d42					; hl contains value to add to byte at a 
2d42				 
2d42 eb					ex de, hl 
2d43			 
2d43 e1					pop hl 
2d44			 
2d44					if DEBUG_FORTH_WORDS 
2d44						DMARK "INC" 
2d44 f5				push af  
2d45 3a 59 2d			ld a, (.dmark)  
2d48 32 bd fb			ld (debug_mark),a  
2d4b 3a 5a 2d			ld a, (.dmark+1)  
2d4e 32 be fb			ld (debug_mark+1),a  
2d51 3a 5b 2d			ld a, (.dmark+2)  
2d54 32 bf fb			ld (debug_mark+2),a  
2d57 18 03			jr .pastdmark  
2d59 ..			.dmark: db "INC"  
2d5c f1			.pastdmark: pop af  
2d5d			endm  
# End of macro DMARK
2d5d						CALLMONITOR 
2d5d cd 6a 16			call break_point_state  
2d60				endm  
# End of macro CALLMONITOR
2d60					endif 
2d60			 
2d60 7e					ld a,(hl) 
2d61 83					add e 
2d62 77					ld (hl),a 
2d63			 
2d63			 
2d63			 
2d63				       NEXTW 
2d63 c3 60 1f			jp macro_next 
2d66				endm 
# End of macro NEXTW
2d66			 
2d66			.DEC: 
2d66				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2d66 6f				db WORD_SYS_CORE+91             
2d67 b7 2d			dw .INC2            
2d69 03				db 2 + 1 
2d6a .. 00			db "-!",0              
2d6d				endm 
# End of macro CWHEAD
2d6d			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2d6d					if DEBUG_FORTH_WORDS_KEY 
2d6d						DMARK "-s_" 
2d6d f5				push af  
2d6e 3a 82 2d			ld a, (.dmark)  
2d71 32 bd fb			ld (debug_mark),a  
2d74 3a 83 2d			ld a, (.dmark+1)  
2d77 32 be fb			ld (debug_mark+1),a  
2d7a 3a 84 2d			ld a, (.dmark+2)  
2d7d 32 bf fb			ld (debug_mark+2),a  
2d80 18 03			jr .pastdmark  
2d82 ..			.dmark: db "-s_"  
2d85 f1			.pastdmark: pop af  
2d86			endm  
# End of macro DMARK
2d86						CALLMONITOR 
2d86 cd 6a 16			call break_point_state  
2d89				endm  
# End of macro CALLMONITOR
2d89					endif 
2d89			 
2d89					FORTH_DSP_VALUEHL 
2d89 cd ee 1d			call macro_dsp_valuehl 
2d8c				endm 
# End of macro FORTH_DSP_VALUEHL
2d8c			 
2d8c e5					push hl   ; save address 
2d8d			 
2d8d					FORTH_DSP_POP 
2d8d cd a6 1e			call macro_forth_dsp_pop 
2d90				endm 
# End of macro FORTH_DSP_POP
2d90			 
2d90					FORTH_DSP_VALUEHL 
2d90 cd ee 1d			call macro_dsp_valuehl 
2d93				endm 
# End of macro FORTH_DSP_VALUEHL
2d93			 
2d93					; hl contains value to add to byte at a 
2d93				 
2d93 eb					ex de, hl 
2d94			 
2d94 e1					pop hl 
2d95			 
2d95					if DEBUG_FORTH_WORDS 
2d95						DMARK "DEC" 
2d95 f5				push af  
2d96 3a aa 2d			ld a, (.dmark)  
2d99 32 bd fb			ld (debug_mark),a  
2d9c 3a ab 2d			ld a, (.dmark+1)  
2d9f 32 be fb			ld (debug_mark+1),a  
2da2 3a ac 2d			ld a, (.dmark+2)  
2da5 32 bf fb			ld (debug_mark+2),a  
2da8 18 03			jr .pastdmark  
2daa ..			.dmark: db "DEC"  
2dad f1			.pastdmark: pop af  
2dae			endm  
# End of macro DMARK
2dae						CALLMONITOR 
2dae cd 6a 16			call break_point_state  
2db1				endm  
# End of macro CALLMONITOR
2db1					endif 
2db1			 
2db1 7e					ld a,(hl) 
2db2 93					sub e 
2db3 77					ld (hl),a 
2db4			 
2db4			 
2db4			 
2db4				       NEXTW 
2db4 c3 60 1f			jp macro_next 
2db7				endm 
# End of macro NEXTW
2db7			 
2db7			.INC2: 
2db7				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2db7 6f				db WORD_SYS_CORE+91             
2db8 61 2e			dw .DEC2            
2dba 04				db 3 + 1 
2dbb .. 00			db "+2!",0              
2dbf				endm 
# End of macro CWHEAD
2dbf			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2dbf			 
2dbf					if DEBUG_FORTH_WORDS_KEY 
2dbf						DMARK "+2s" 
2dbf f5				push af  
2dc0 3a d4 2d			ld a, (.dmark)  
2dc3 32 bd fb			ld (debug_mark),a  
2dc6 3a d5 2d			ld a, (.dmark+1)  
2dc9 32 be fb			ld (debug_mark+1),a  
2dcc 3a d6 2d			ld a, (.dmark+2)  
2dcf 32 bf fb			ld (debug_mark+2),a  
2dd2 18 03			jr .pastdmark  
2dd4 ..			.dmark: db "+2s"  
2dd7 f1			.pastdmark: pop af  
2dd8			endm  
# End of macro DMARK
2dd8						CALLMONITOR 
2dd8 cd 6a 16			call break_point_state  
2ddb				endm  
# End of macro CALLMONITOR
2ddb					endif 
2ddb			 
2ddb					; Address 
2ddb			 
2ddb					FORTH_DSP_VALUEHL 
2ddb cd ee 1d			call macro_dsp_valuehl 
2dde				endm 
# End of macro FORTH_DSP_VALUEHL
2dde			 
2dde e5					push hl    ; save address 
2ddf			 
2ddf					; load content into de 
2ddf			 
2ddf 5e					ld e,(hl) 
2de0 23					inc hl 
2de1 56					ld d, (hl) 
2de2			 
2de2					if DEBUG_FORTH_WORDS 
2de2						DMARK "+2a" 
2de2 f5				push af  
2de3 3a f7 2d			ld a, (.dmark)  
2de6 32 bd fb			ld (debug_mark),a  
2de9 3a f8 2d			ld a, (.dmark+1)  
2dec 32 be fb			ld (debug_mark+1),a  
2def 3a f9 2d			ld a, (.dmark+2)  
2df2 32 bf fb			ld (debug_mark+2),a  
2df5 18 03			jr .pastdmark  
2df7 ..			.dmark: db "+2a"  
2dfa f1			.pastdmark: pop af  
2dfb			endm  
# End of macro DMARK
2dfb						CALLMONITOR 
2dfb cd 6a 16			call break_point_state  
2dfe				endm  
# End of macro CALLMONITOR
2dfe					endif 
2dfe			 
2dfe					FORTH_DSP_POP 
2dfe cd a6 1e			call macro_forth_dsp_pop 
2e01				endm 
# End of macro FORTH_DSP_POP
2e01			 
2e01					; Get value to add 
2e01			 
2e01					FORTH_DSP_VALUE 
2e01 cd d7 1d			call macro_forth_dsp_value 
2e04				endm 
# End of macro FORTH_DSP_VALUE
2e04			 
2e04					if DEBUG_FORTH_WORDS 
2e04						DMARK "+2v" 
2e04 f5				push af  
2e05 3a 19 2e			ld a, (.dmark)  
2e08 32 bd fb			ld (debug_mark),a  
2e0b 3a 1a 2e			ld a, (.dmark+1)  
2e0e 32 be fb			ld (debug_mark+1),a  
2e11 3a 1b 2e			ld a, (.dmark+2)  
2e14 32 bf fb			ld (debug_mark+2),a  
2e17 18 03			jr .pastdmark  
2e19 ..			.dmark: db "+2v"  
2e1c f1			.pastdmark: pop af  
2e1d			endm  
# End of macro DMARK
2e1d						CALLMONITOR 
2e1d cd 6a 16			call break_point_state  
2e20				endm  
# End of macro CALLMONITOR
2e20					endif 
2e20			 
2e20 19					add hl, de 
2e21			 
2e21					if DEBUG_FORTH_WORDS 
2e21						DMARK "+2+" 
2e21 f5				push af  
2e22 3a 36 2e			ld a, (.dmark)  
2e25 32 bd fb			ld (debug_mark),a  
2e28 3a 37 2e			ld a, (.dmark+1)  
2e2b 32 be fb			ld (debug_mark+1),a  
2e2e 3a 38 2e			ld a, (.dmark+2)  
2e31 32 bf fb			ld (debug_mark+2),a  
2e34 18 03			jr .pastdmark  
2e36 ..			.dmark: db "+2+"  
2e39 f1			.pastdmark: pop af  
2e3a			endm  
# End of macro DMARK
2e3a						CALLMONITOR 
2e3a cd 6a 16			call break_point_state  
2e3d				endm  
# End of macro CALLMONITOR
2e3d					endif 
2e3d			 
2e3d					; move result to de 
2e3d			 
2e3d eb					ex de, hl 
2e3e			 
2e3e					; Address 
2e3e			 
2e3e e1					pop hl 
2e3f			 
2e3f					; save it back 
2e3f			 
2e3f 73					ld (hl), e 
2e40 23					inc hl 
2e41 72					ld (hl), d 
2e42			 
2e42					if DEBUG_FORTH_WORDS 
2e42						DMARK "+2e" 
2e42 f5				push af  
2e43 3a 57 2e			ld a, (.dmark)  
2e46 32 bd fb			ld (debug_mark),a  
2e49 3a 58 2e			ld a, (.dmark+1)  
2e4c 32 be fb			ld (debug_mark+1),a  
2e4f 3a 59 2e			ld a, (.dmark+2)  
2e52 32 bf fb			ld (debug_mark+2),a  
2e55 18 03			jr .pastdmark  
2e57 ..			.dmark: db "+2e"  
2e5a f1			.pastdmark: pop af  
2e5b			endm  
# End of macro DMARK
2e5b						CALLMONITOR 
2e5b cd 6a 16			call break_point_state  
2e5e				endm  
# End of macro CALLMONITOR
2e5e					endif 
2e5e			 
2e5e			 
2e5e			 
2e5e			 
2e5e			 
2e5e				       NEXTW 
2e5e c3 60 1f			jp macro_next 
2e61				endm 
# End of macro NEXTW
2e61			 
2e61			.DEC2: 
2e61				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2e61 6f				db WORD_SYS_CORE+91             
2e62 0d 2f			dw .GET2            
2e64 04				db 3 + 1 
2e65 .. 00			db "-2!",0              
2e69				endm 
# End of macro CWHEAD
2e69			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2e69			 
2e69			 
2e69					if DEBUG_FORTH_WORDS_KEY 
2e69						DMARK "-2s" 
2e69 f5				push af  
2e6a 3a 7e 2e			ld a, (.dmark)  
2e6d 32 bd fb			ld (debug_mark),a  
2e70 3a 7f 2e			ld a, (.dmark+1)  
2e73 32 be fb			ld (debug_mark+1),a  
2e76 3a 80 2e			ld a, (.dmark+2)  
2e79 32 bf fb			ld (debug_mark+2),a  
2e7c 18 03			jr .pastdmark  
2e7e ..			.dmark: db "-2s"  
2e81 f1			.pastdmark: pop af  
2e82			endm  
# End of macro DMARK
2e82						CALLMONITOR 
2e82 cd 6a 16			call break_point_state  
2e85				endm  
# End of macro CALLMONITOR
2e85					endif 
2e85			 
2e85					; Address 
2e85			 
2e85					FORTH_DSP_VALUEHL 
2e85 cd ee 1d			call macro_dsp_valuehl 
2e88				endm 
# End of macro FORTH_DSP_VALUEHL
2e88			 
2e88 e5					push hl    ; save address 
2e89			 
2e89					; load content into de 
2e89			 
2e89 5e					ld e,(hl) 
2e8a 23					inc hl 
2e8b 56					ld d, (hl) 
2e8c			 
2e8c					if DEBUG_FORTH_WORDS 
2e8c						DMARK "-2a" 
2e8c f5				push af  
2e8d 3a a1 2e			ld a, (.dmark)  
2e90 32 bd fb			ld (debug_mark),a  
2e93 3a a2 2e			ld a, (.dmark+1)  
2e96 32 be fb			ld (debug_mark+1),a  
2e99 3a a3 2e			ld a, (.dmark+2)  
2e9c 32 bf fb			ld (debug_mark+2),a  
2e9f 18 03			jr .pastdmark  
2ea1 ..			.dmark: db "-2a"  
2ea4 f1			.pastdmark: pop af  
2ea5			endm  
# End of macro DMARK
2ea5						CALLMONITOR 
2ea5 cd 6a 16			call break_point_state  
2ea8				endm  
# End of macro CALLMONITOR
2ea8					endif 
2ea8			 
2ea8					FORTH_DSP_POP 
2ea8 cd a6 1e			call macro_forth_dsp_pop 
2eab				endm 
# End of macro FORTH_DSP_POP
2eab			 
2eab					; Get value to remove 
2eab			 
2eab					FORTH_DSP_VALUE 
2eab cd d7 1d			call macro_forth_dsp_value 
2eae				endm 
# End of macro FORTH_DSP_VALUE
2eae			 
2eae					if DEBUG_FORTH_WORDS 
2eae						DMARK "-2v" 
2eae f5				push af  
2eaf 3a c3 2e			ld a, (.dmark)  
2eb2 32 bd fb			ld (debug_mark),a  
2eb5 3a c4 2e			ld a, (.dmark+1)  
2eb8 32 be fb			ld (debug_mark+1),a  
2ebb 3a c5 2e			ld a, (.dmark+2)  
2ebe 32 bf fb			ld (debug_mark+2),a  
2ec1 18 03			jr .pastdmark  
2ec3 ..			.dmark: db "-2v"  
2ec6 f1			.pastdmark: pop af  
2ec7			endm  
# End of macro DMARK
2ec7						CALLMONITOR 
2ec7 cd 6a 16			call break_point_state  
2eca				endm  
# End of macro CALLMONITOR
2eca					endif 
2eca			 
2eca eb					ex de, hl 
2ecb ed 52				sbc hl, de 
2ecd			 
2ecd					if DEBUG_FORTH_WORDS 
2ecd						DMARK "-2d" 
2ecd f5				push af  
2ece 3a e2 2e			ld a, (.dmark)  
2ed1 32 bd fb			ld (debug_mark),a  
2ed4 3a e3 2e			ld a, (.dmark+1)  
2ed7 32 be fb			ld (debug_mark+1),a  
2eda 3a e4 2e			ld a, (.dmark+2)  
2edd 32 bf fb			ld (debug_mark+2),a  
2ee0 18 03			jr .pastdmark  
2ee2 ..			.dmark: db "-2d"  
2ee5 f1			.pastdmark: pop af  
2ee6			endm  
# End of macro DMARK
2ee6						CALLMONITOR 
2ee6 cd 6a 16			call break_point_state  
2ee9				endm  
# End of macro CALLMONITOR
2ee9					endif 
2ee9			 
2ee9					; move result to de 
2ee9			 
2ee9 eb					ex de, hl 
2eea			 
2eea					; Address 
2eea			 
2eea e1					pop hl 
2eeb			 
2eeb					; save it back 
2eeb			 
2eeb 73					ld (hl), e 
2eec 23					inc hl 
2eed 72					ld (hl), d 
2eee			 
2eee					if DEBUG_FORTH_WORDS 
2eee						DMARK "-2e" 
2eee f5				push af  
2eef 3a 03 2f			ld a, (.dmark)  
2ef2 32 bd fb			ld (debug_mark),a  
2ef5 3a 04 2f			ld a, (.dmark+1)  
2ef8 32 be fb			ld (debug_mark+1),a  
2efb 3a 05 2f			ld a, (.dmark+2)  
2efe 32 bf fb			ld (debug_mark+2),a  
2f01 18 03			jr .pastdmark  
2f03 ..			.dmark: db "-2e"  
2f06 f1			.pastdmark: pop af  
2f07			endm  
# End of macro DMARK
2f07						CALLMONITOR 
2f07 cd 6a 16			call break_point_state  
2f0a				endm  
# End of macro CALLMONITOR
2f0a					endif 
2f0a			 
2f0a			 
2f0a			 
2f0a			 
2f0a			 
2f0a				       NEXTW 
2f0a c3 60 1f			jp macro_next 
2f0d				endm 
# End of macro NEXTW
2f0d			.GET2: 
2f0d				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2f0d 6f				db WORD_SYS_CORE+91             
2f0e 3d 2f			dw .BANG2            
2f10 03				db 2 + 1 
2f11 .. 00			db "2@",0              
2f14				endm 
# End of macro CWHEAD
2f14			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2f14					if DEBUG_FORTH_WORDS_KEY 
2f14						DMARK "2A_" 
2f14 f5				push af  
2f15 3a 29 2f			ld a, (.dmark)  
2f18 32 bd fb			ld (debug_mark),a  
2f1b 3a 2a 2f			ld a, (.dmark+1)  
2f1e 32 be fb			ld (debug_mark+1),a  
2f21 3a 2b 2f			ld a, (.dmark+2)  
2f24 32 bf fb			ld (debug_mark+2),a  
2f27 18 03			jr .pastdmark  
2f29 ..			.dmark: db "2A_"  
2f2c f1			.pastdmark: pop af  
2f2d			endm  
# End of macro DMARK
2f2d						CALLMONITOR 
2f2d cd 6a 16			call break_point_state  
2f30				endm  
# End of macro CALLMONITOR
2f30					endif 
2f30			 
2f30					FORTH_DSP_VALUEHL 
2f30 cd ee 1d			call macro_dsp_valuehl 
2f33				endm 
# End of macro FORTH_DSP_VALUEHL
2f33			 
2f33 5e					ld e, (hl) 
2f34 23					inc hl 
2f35 56					ld d, (hl) 
2f36			 
2f36 eb					ex de, hl 
2f37			 
2f37 cd f7 1b				call forth_push_numhl 
2f3a			 
2f3a				       NEXTW 
2f3a c3 60 1f			jp macro_next 
2f3d				endm 
# End of macro NEXTW
2f3d			.BANG2: 
2f3d				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2f3d 6f				db WORD_SYS_CORE+91             
2f3e 75 2f			dw .CONFIG            
2f40 03				db 2 + 1 
2f41 .. 00			db "2!",0              
2f44				endm 
# End of macro CWHEAD
2f44			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2f44					if DEBUG_FORTH_WORDS_KEY 
2f44						DMARK "2S_" 
2f44 f5				push af  
2f45 3a 59 2f			ld a, (.dmark)  
2f48 32 bd fb			ld (debug_mark),a  
2f4b 3a 5a 2f			ld a, (.dmark+1)  
2f4e 32 be fb			ld (debug_mark+1),a  
2f51 3a 5b 2f			ld a, (.dmark+2)  
2f54 32 bf fb			ld (debug_mark+2),a  
2f57 18 03			jr .pastdmark  
2f59 ..			.dmark: db "2S_"  
2f5c f1			.pastdmark: pop af  
2f5d			endm  
# End of macro DMARK
2f5d						CALLMONITOR 
2f5d cd 6a 16			call break_point_state  
2f60				endm  
# End of macro CALLMONITOR
2f60					endif 
2f60			 
2f60					FORTH_DSP_VALUEHL 
2f60 cd ee 1d			call macro_dsp_valuehl 
2f63				endm 
# End of macro FORTH_DSP_VALUEHL
2f63			 
2f63 e5					push hl   ; save address 
2f64			 
2f64			 
2f64					FORTH_DSP_POP 
2f64 cd a6 1e			call macro_forth_dsp_pop 
2f67				endm 
# End of macro FORTH_DSP_POP
2f67			 
2f67					 
2f67					FORTH_DSP_VALUEHL 
2f67 cd ee 1d			call macro_dsp_valuehl 
2f6a				endm 
# End of macro FORTH_DSP_VALUEHL
2f6a			 
2f6a					FORTH_DSP_POP 
2f6a cd a6 1e			call macro_forth_dsp_pop 
2f6d				endm 
# End of macro FORTH_DSP_POP
2f6d			 
2f6d eb					ex de, hl    ; value now in de 
2f6e			 
2f6e e1					pop hl 
2f6f			 
2f6f 73					ld (hl), e 
2f70			 
2f70 23					inc hl 
2f71			 
2f71 72					ld (hl), d 
2f72			 
2f72			 
2f72				       NEXTW 
2f72 c3 60 1f			jp macro_next 
2f75				endm 
# End of macro NEXTW
2f75			.CONFIG: 
2f75				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2f75 6f				db WORD_SYS_CORE+91             
2f76 86 2f			dw .ENDCORE            
2f78 07				db 6 + 1 
2f79 .. 00			db "CONFIG",0              
2f80				endm 
# End of macro CWHEAD
2f80			; | CONFIG ( -- )  Access the system configuration menu | TO DO 
2f80			 
2f80 cd 66 13				call config 
2f83					NEXTW 
2f83 c3 60 1f			jp macro_next 
2f86				endm 
# End of macro NEXTW
2f86			.ENDCORE: 
2f86			 
2f86			; eof 
2f86			 
2f86			 
# End of file forth_words_core.asm
2f86			include "forth_words_flow.asm" 
2f86			 
2f86			; | ## Program Flow Words 
2f86			 
2f86			.IF: 
2f86				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f86 1e				db WORD_SYS_CORE+10             
2f87 7b 30			dw .THEN            
2f89 03				db 2 + 1 
2f8a .. 00			db "IF",0              
2f8d				endm 
# End of macro CWHEAD
2f8d			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f8d			; 
2f8d					if DEBUG_FORTH_WORDS_KEY 
2f8d						DMARK "IF." 
2f8d f5				push af  
2f8e 3a a2 2f			ld a, (.dmark)  
2f91 32 bd fb			ld (debug_mark),a  
2f94 3a a3 2f			ld a, (.dmark+1)  
2f97 32 be fb			ld (debug_mark+1),a  
2f9a 3a a4 2f			ld a, (.dmark+2)  
2f9d 32 bf fb			ld (debug_mark+2),a  
2fa0 18 03			jr .pastdmark  
2fa2 ..			.dmark: db "IF."  
2fa5 f1			.pastdmark: pop af  
2fa6			endm  
# End of macro DMARK
2fa6						CALLMONITOR 
2fa6 cd 6a 16			call break_point_state  
2fa9				endm  
# End of macro CALLMONITOR
2fa9					endif 
2fa9			; eval TOS 
2fa9			 
2fa9				FORTH_DSP_VALUEHL 
2fa9 cd ee 1d			call macro_dsp_valuehl 
2fac				endm 
# End of macro FORTH_DSP_VALUEHL
2fac			 
2fac			;	push hl 
2fac				FORTH_DSP_POP 
2fac cd a6 1e			call macro_forth_dsp_pop 
2faf				endm 
# End of macro FORTH_DSP_POP
2faf			;	pop hl 
2faf			 
2faf					if DEBUG_FORTH_WORDS 
2faf						DMARK "IF1" 
2faf f5				push af  
2fb0 3a c4 2f			ld a, (.dmark)  
2fb3 32 bd fb			ld (debug_mark),a  
2fb6 3a c5 2f			ld a, (.dmark+1)  
2fb9 32 be fb			ld (debug_mark+1),a  
2fbc 3a c6 2f			ld a, (.dmark+2)  
2fbf 32 bf fb			ld (debug_mark+2),a  
2fc2 18 03			jr .pastdmark  
2fc4 ..			.dmark: db "IF1"  
2fc7 f1			.pastdmark: pop af  
2fc8			endm  
# End of macro DMARK
2fc8						CALLMONITOR 
2fc8 cd 6a 16			call break_point_state  
2fcb				endm  
# End of macro CALLMONITOR
2fcb					endif 
2fcb b7				or a        ; clear carry flag 
2fcc 11 00 00			ld de, 0 
2fcf eb				ex de,hl 
2fd0 ed 52			sbc hl, de 
2fd2 c2 5c 30			jp nz, .iftrue 
2fd5			 
2fd5					if DEBUG_FORTH_WORDS 
2fd5						DMARK "IF2" 
2fd5 f5				push af  
2fd6 3a ea 2f			ld a, (.dmark)  
2fd9 32 bd fb			ld (debug_mark),a  
2fdc 3a eb 2f			ld a, (.dmark+1)  
2fdf 32 be fb			ld (debug_mark+1),a  
2fe2 3a ec 2f			ld a, (.dmark+2)  
2fe5 32 bf fb			ld (debug_mark+2),a  
2fe8 18 03			jr .pastdmark  
2fea ..			.dmark: db "IF2"  
2fed f1			.pastdmark: pop af  
2fee			endm  
# End of macro DMARK
2fee						CALLMONITOR 
2fee cd 6a 16			call break_point_state  
2ff1				endm  
# End of macro CALLMONITOR
2ff1					endif 
2ff1			 
2ff1			; if not true then skip to THEN 
2ff1			 
2ff1				; TODO get tok_ptr 
2ff1				; TODO consume toks until we get to THEN 
2ff1			 
2ff1 2a a4 f2			ld hl, (os_tok_ptr) 
2ff4					if DEBUG_FORTH_WORDS 
2ff4						DMARK "IF3" 
2ff4 f5				push af  
2ff5 3a 09 30			ld a, (.dmark)  
2ff8 32 bd fb			ld (debug_mark),a  
2ffb 3a 0a 30			ld a, (.dmark+1)  
2ffe 32 be fb			ld (debug_mark+1),a  
3001 3a 0b 30			ld a, (.dmark+2)  
3004 32 bf fb			ld (debug_mark+2),a  
3007 18 03			jr .pastdmark  
3009 ..			.dmark: db "IF3"  
300c f1			.pastdmark: pop af  
300d			endm  
# End of macro DMARK
300d						CALLMONITOR 
300d cd 6a 16			call break_point_state  
3010				endm  
# End of macro CALLMONITOR
3010						 
3010					endif 
3010 11 57 30			ld de, .ifthen 
3013					if DEBUG_FORTH_WORDS 
3013						DMARK "IF4" 
3013 f5				push af  
3014 3a 28 30			ld a, (.dmark)  
3017 32 bd fb			ld (debug_mark),a  
301a 3a 29 30			ld a, (.dmark+1)  
301d 32 be fb			ld (debug_mark+1),a  
3020 3a 2a 30			ld a, (.dmark+2)  
3023 32 bf fb			ld (debug_mark+2),a  
3026 18 03			jr .pastdmark  
3028 ..			.dmark: db "IF4"  
302b f1			.pastdmark: pop af  
302c			endm  
# End of macro DMARK
302c						CALLMONITOR 
302c cd 6a 16			call break_point_state  
302f				endm  
# End of macro CALLMONITOR
302f					endif 
302f cd 7b 20			call findnexttok  
3032			 
3032					if DEBUG_FORTH_WORDS 
3032						DMARK "IF5" 
3032 f5				push af  
3033 3a 47 30			ld a, (.dmark)  
3036 32 bd fb			ld (debug_mark),a  
3039 3a 48 30			ld a, (.dmark+1)  
303c 32 be fb			ld (debug_mark+1),a  
303f 3a 49 30			ld a, (.dmark+2)  
3042 32 bf fb			ld (debug_mark+2),a  
3045 18 03			jr .pastdmark  
3047 ..			.dmark: db "IF5"  
304a f1			.pastdmark: pop af  
304b			endm  
# End of macro DMARK
304b						CALLMONITOR 
304b cd 6a 16			call break_point_state  
304e				endm  
# End of macro CALLMONITOR
304e					endif 
304e				; TODO replace below with ; exec using tok_ptr 
304e 22 a4 f2			ld (os_tok_ptr), hl 
3051 c3 f1 1f			jp exec1 
3054				NEXTW 
3054 c3 60 1f			jp macro_next 
3057				endm 
# End of macro NEXTW
3057			 
3057 .. 00		.ifthen:  db "THEN",0 
305c			 
305c			.iftrue:		 
305c				; Exec next words normally 
305c			 
305c				; if true then exec following IF as normal 
305c					if DEBUG_FORTH_WORDS 
305c						DMARK "IFT" 
305c f5				push af  
305d 3a 71 30			ld a, (.dmark)  
3060 32 bd fb			ld (debug_mark),a  
3063 3a 72 30			ld a, (.dmark+1)  
3066 32 be fb			ld (debug_mark+1),a  
3069 3a 73 30			ld a, (.dmark+2)  
306c 32 bf fb			ld (debug_mark+2),a  
306f 18 03			jr .pastdmark  
3071 ..			.dmark: db "IFT"  
3074 f1			.pastdmark: pop af  
3075			endm  
# End of macro DMARK
3075						CALLMONITOR 
3075 cd 6a 16			call break_point_state  
3078				endm  
# End of macro CALLMONITOR
3078					endif 
3078			 
3078					NEXTW 
3078 c3 60 1f			jp macro_next 
307b				endm 
# End of macro NEXTW
307b			.THEN: 
307b				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
307b 1f				db WORD_SYS_CORE+11             
307c a3 30			dw .ELSE            
307e 05				db 4 + 1 
307f .. 00			db "THEN",0              
3084				endm 
# End of macro CWHEAD
3084			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3084					if DEBUG_FORTH_WORDS_KEY 
3084						DMARK "THN" 
3084 f5				push af  
3085 3a 99 30			ld a, (.dmark)  
3088 32 bd fb			ld (debug_mark),a  
308b 3a 9a 30			ld a, (.dmark+1)  
308e 32 be fb			ld (debug_mark+1),a  
3091 3a 9b 30			ld a, (.dmark+2)  
3094 32 bf fb			ld (debug_mark+2),a  
3097 18 03			jr .pastdmark  
3099 ..			.dmark: db "THN"  
309c f1			.pastdmark: pop af  
309d			endm  
# End of macro DMARK
309d						CALLMONITOR 
309d cd 6a 16			call break_point_state  
30a0				endm  
# End of macro CALLMONITOR
30a0					endif 
30a0					NEXTW 
30a0 c3 60 1f			jp macro_next 
30a3				endm 
# End of macro NEXTW
30a3			.ELSE: 
30a3				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
30a3 20				db WORD_SYS_CORE+12             
30a4 cb 30			dw .DO            
30a6 03				db 2 + 1 
30a7 .. 00			db "ELSE",0              
30ac				endm 
# End of macro CWHEAD
30ac			; | ELSE ( -- ) Not supported - does nothing | TODO 
30ac			 
30ac					if DEBUG_FORTH_WORDS_KEY 
30ac						DMARK "ELS" 
30ac f5				push af  
30ad 3a c1 30			ld a, (.dmark)  
30b0 32 bd fb			ld (debug_mark),a  
30b3 3a c2 30			ld a, (.dmark+1)  
30b6 32 be fb			ld (debug_mark+1),a  
30b9 3a c3 30			ld a, (.dmark+2)  
30bc 32 bf fb			ld (debug_mark+2),a  
30bf 18 03			jr .pastdmark  
30c1 ..			.dmark: db "ELS"  
30c4 f1			.pastdmark: pop af  
30c5			endm  
# End of macro DMARK
30c5						CALLMONITOR 
30c5 cd 6a 16			call break_point_state  
30c8				endm  
# End of macro CALLMONITOR
30c8					endif 
30c8			 
30c8			 
30c8					NEXTW 
30c8 c3 60 1f			jp macro_next 
30cb				endm 
# End of macro NEXTW
30cb			.DO: 
30cb				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
30cb 21				db WORD_SYS_CORE+13             
30cc f2 31			dw .LOOP            
30ce 03				db 2 + 1 
30cf .. 00			db "DO",0              
30d2				endm 
# End of macro CWHEAD
30d2			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
30d2			 
30d2					if DEBUG_FORTH_WORDS_KEY 
30d2						DMARK "DO." 
30d2 f5				push af  
30d3 3a e7 30			ld a, (.dmark)  
30d6 32 bd fb			ld (debug_mark),a  
30d9 3a e8 30			ld a, (.dmark+1)  
30dc 32 be fb			ld (debug_mark+1),a  
30df 3a e9 30			ld a, (.dmark+2)  
30e2 32 bf fb			ld (debug_mark+2),a  
30e5 18 03			jr .pastdmark  
30e7 ..			.dmark: db "DO."  
30ea f1			.pastdmark: pop af  
30eb			endm  
# End of macro DMARK
30eb						CALLMONITOR 
30eb cd 6a 16			call break_point_state  
30ee				endm  
# End of macro CALLMONITOR
30ee					endif 
30ee			;  push pc to rsp stack past the DO 
30ee			 
30ee 2a a4 f2				ld hl, (os_tok_ptr) 
30f1 23					inc hl   ; D 
30f2 23					inc hl  ; O 
30f3 23					inc hl   ; null 
30f4					if DEBUG_FORTH_WORDS 
30f4						DMARK "DO2" 
30f4 f5				push af  
30f5 3a 09 31			ld a, (.dmark)  
30f8 32 bd fb			ld (debug_mark),a  
30fb 3a 0a 31			ld a, (.dmark+1)  
30fe 32 be fb			ld (debug_mark+1),a  
3101 3a 0b 31			ld a, (.dmark+2)  
3104 32 bf fb			ld (debug_mark+2),a  
3107 18 03			jr .pastdmark  
3109 ..			.dmark: db "DO2"  
310c f1			.pastdmark: pop af  
310d			endm  
# End of macro DMARK
310d						CALLMONITOR 
310d cd 6a 16			call break_point_state  
3110				endm  
# End of macro CALLMONITOR
3110					endif 
3110					FORTH_RSP_NEXT 
3110 cd 9e 1b			call macro_forth_rsp_next 
3113				endm 
# End of macro FORTH_RSP_NEXT
3113					if DEBUG_FORTH_WORDS 
3113						DMARK "DO3" 
3113 f5				push af  
3114 3a 28 31			ld a, (.dmark)  
3117 32 bd fb			ld (debug_mark),a  
311a 3a 29 31			ld a, (.dmark+1)  
311d 32 be fb			ld (debug_mark+1),a  
3120 3a 2a 31			ld a, (.dmark+2)  
3123 32 bf fb			ld (debug_mark+2),a  
3126 18 03			jr .pastdmark  
3128 ..			.dmark: db "DO3"  
312b f1			.pastdmark: pop af  
312c			endm  
# End of macro DMARK
312c						CALLMONITOR 
312c cd 6a 16			call break_point_state  
312f				endm  
# End of macro CALLMONITOR
312f					endif 
312f			 
312f					;if DEBUG_FORTH_WORDS 
312f				;		push hl 
312f			;		endif  
312f			 
312f			; get counters from data stack 
312f			 
312f			 
312f					FORTH_DSP_VALUEHL 
312f cd ee 1d			call macro_dsp_valuehl 
3132				endm 
# End of macro FORTH_DSP_VALUEHL
3132 e5					push hl		 ; hl now has starting counter which needs to be tos 
3133			 
3133					if DEBUG_FORTH_WORDS 
3133						DMARK "DO4" 
3133 f5				push af  
3134 3a 48 31			ld a, (.dmark)  
3137 32 bd fb			ld (debug_mark),a  
313a 3a 49 31			ld a, (.dmark+1)  
313d 32 be fb			ld (debug_mark+1),a  
3140 3a 4a 31			ld a, (.dmark+2)  
3143 32 bf fb			ld (debug_mark+2),a  
3146 18 03			jr .pastdmark  
3148 ..			.dmark: db "DO4"  
314b f1			.pastdmark: pop af  
314c			endm  
# End of macro DMARK
314c						CALLMONITOR 
314c cd 6a 16			call break_point_state  
314f				endm  
# End of macro CALLMONITOR
314f					endif 
314f					FORTH_DSP_POP 
314f cd a6 1e			call macro_forth_dsp_pop 
3152				endm 
# End of macro FORTH_DSP_POP
3152			 
3152					if DEBUG_FORTH_WORDS 
3152						DMARK "DO5" 
3152 f5				push af  
3153 3a 67 31			ld a, (.dmark)  
3156 32 bd fb			ld (debug_mark),a  
3159 3a 68 31			ld a, (.dmark+1)  
315c 32 be fb			ld (debug_mark+1),a  
315f 3a 69 31			ld a, (.dmark+2)  
3162 32 bf fb			ld (debug_mark+2),a  
3165 18 03			jr .pastdmark  
3167 ..			.dmark: db "DO5"  
316a f1			.pastdmark: pop af  
316b			endm  
# End of macro DMARK
316b						CALLMONITOR 
316b cd 6a 16			call break_point_state  
316e				endm  
# End of macro CALLMONITOR
316e					endif 
316e			 
316e					FORTH_DSP_VALUEHL 
316e cd ee 1d			call macro_dsp_valuehl 
3171				endm 
# End of macro FORTH_DSP_VALUEHL
3171			;		push hl		 ; hl now has starting limit counter 
3171			 
3171					if DEBUG_FORTH_WORDS 
3171						DMARK "DO6" 
3171 f5				push af  
3172 3a 86 31			ld a, (.dmark)  
3175 32 bd fb			ld (debug_mark),a  
3178 3a 87 31			ld a, (.dmark+1)  
317b 32 be fb			ld (debug_mark+1),a  
317e 3a 88 31			ld a, (.dmark+2)  
3181 32 bf fb			ld (debug_mark+2),a  
3184 18 03			jr .pastdmark  
3186 ..			.dmark: db "DO6"  
3189 f1			.pastdmark: pop af  
318a			endm  
# End of macro DMARK
318a						CALLMONITOR 
318a cd 6a 16			call break_point_state  
318d				endm  
# End of macro CALLMONITOR
318d					endif 
318d					FORTH_DSP_POP 
318d cd a6 1e			call macro_forth_dsp_pop 
3190				endm 
# End of macro FORTH_DSP_POP
3190			 
3190			; put counters on the loop stack 
3190			 
3190			;		pop hl			 ; limit counter 
3190 d1					pop de			; start counter 
3191			 
3191					; push limit counter 
3191			 
3191					if DEBUG_FORTH_WORDS 
3191						DMARK "DO7" 
3191 f5				push af  
3192 3a a6 31			ld a, (.dmark)  
3195 32 bd fb			ld (debug_mark),a  
3198 3a a7 31			ld a, (.dmark+1)  
319b 32 be fb			ld (debug_mark+1),a  
319e 3a a8 31			ld a, (.dmark+2)  
31a1 32 bf fb			ld (debug_mark+2),a  
31a4 18 03			jr .pastdmark  
31a6 ..			.dmark: db "DO7"  
31a9 f1			.pastdmark: pop af  
31aa			endm  
# End of macro DMARK
31aa						CALLMONITOR 
31aa cd 6a 16			call break_point_state  
31ad				endm  
# End of macro CALLMONITOR
31ad					endif 
31ad					FORTH_LOOP_NEXT 
31ad cd 1f 1e			call macro_forth_loop_next 
31b0				endm 
# End of macro FORTH_LOOP_NEXT
31b0			 
31b0					; push start counter 
31b0			 
31b0 eb					ex de, hl 
31b1					if DEBUG_FORTH_WORDS 
31b1						DMARK "DO7" 
31b1 f5				push af  
31b2 3a c6 31			ld a, (.dmark)  
31b5 32 bd fb			ld (debug_mark),a  
31b8 3a c7 31			ld a, (.dmark+1)  
31bb 32 be fb			ld (debug_mark+1),a  
31be 3a c8 31			ld a, (.dmark+2)  
31c1 32 bf fb			ld (debug_mark+2),a  
31c4 18 03			jr .pastdmark  
31c6 ..			.dmark: db "DO7"  
31c9 f1			.pastdmark: pop af  
31ca			endm  
# End of macro DMARK
31ca						CALLMONITOR 
31ca cd 6a 16			call break_point_state  
31cd				endm  
# End of macro CALLMONITOR
31cd					endif 
31cd					FORTH_LOOP_NEXT 
31cd cd 1f 1e			call macro_forth_loop_next 
31d0				endm 
# End of macro FORTH_LOOP_NEXT
31d0			 
31d0			 
31d0					; init first round of I counter 
31d0			 
31d0 22 c8 f2				ld (os_current_i), hl 
31d3			 
31d3					if DEBUG_FORTH_WORDS 
31d3						DMARK "DO8" 
31d3 f5				push af  
31d4 3a e8 31			ld a, (.dmark)  
31d7 32 bd fb			ld (debug_mark),a  
31da 3a e9 31			ld a, (.dmark+1)  
31dd 32 be fb			ld (debug_mark+1),a  
31e0 3a ea 31			ld a, (.dmark+2)  
31e3 32 bf fb			ld (debug_mark+2),a  
31e6 18 03			jr .pastdmark  
31e8 ..			.dmark: db "DO8"  
31eb f1			.pastdmark: pop af  
31ec			endm  
# End of macro DMARK
31ec						CALLMONITOR 
31ec cd 6a 16			call break_point_state  
31ef				endm  
# End of macro CALLMONITOR
31ef					endif 
31ef			 
31ef					NEXTW 
31ef c3 60 1f			jp macro_next 
31f2				endm 
# End of macro NEXTW
31f2			.LOOP: 
31f2				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
31f2 22				db WORD_SYS_CORE+14             
31f3 0a 33			dw .I            
31f5 05				db 4 + 1 
31f6 .. 00			db "LOOP",0              
31fb				endm 
# End of macro CWHEAD
31fb			; | LOOP ( -- ) Increment and test loop counter  | DONE 
31fb			 
31fb				; pop tos as current loop count to hl 
31fb			 
31fb				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
31fb			 
31fb				FORTH_LOOP_TOS 
31fb cd 52 1e			call macro_forth_loop_tos 
31fe				endm 
# End of macro FORTH_LOOP_TOS
31fe e5				push hl 
31ff			 
31ff					if DEBUG_FORTH_WORDS_KEY 
31ff						DMARK "LOP" 
31ff f5				push af  
3200 3a 14 32			ld a, (.dmark)  
3203 32 bd fb			ld (debug_mark),a  
3206 3a 15 32			ld a, (.dmark+1)  
3209 32 be fb			ld (debug_mark+1),a  
320c 3a 16 32			ld a, (.dmark+2)  
320f 32 bf fb			ld (debug_mark+2),a  
3212 18 03			jr .pastdmark  
3214 ..			.dmark: db "LOP"  
3217 f1			.pastdmark: pop af  
3218			endm  
# End of macro DMARK
3218						CALLMONITOR 
3218 cd 6a 16			call break_point_state  
321b				endm  
# End of macro CALLMONITOR
321b					endif 
321b				; next item on the stack is the limit. get it 
321b			 
321b			 
321b				FORTH_LOOP_POP 
321b cd 5c 1e			call macro_forth_loop_pop 
321e				endm 
# End of macro FORTH_LOOP_POP
321e			 
321e				FORTH_LOOP_TOS 
321e cd 52 1e			call macro_forth_loop_tos 
3221				endm 
# End of macro FORTH_LOOP_TOS
3221			 
3221 d1				pop de		 ; de = i, hl = limit 
3222			 
3222					if DEBUG_FORTH_WORDS 
3222						DMARK "LP1" 
3222 f5				push af  
3223 3a 37 32			ld a, (.dmark)  
3226 32 bd fb			ld (debug_mark),a  
3229 3a 38 32			ld a, (.dmark+1)  
322c 32 be fb			ld (debug_mark+1),a  
322f 3a 39 32			ld a, (.dmark+2)  
3232 32 bf fb			ld (debug_mark+2),a  
3235 18 03			jr .pastdmark  
3237 ..			.dmark: db "LP1"  
323a f1			.pastdmark: pop af  
323b			endm  
# End of macro DMARK
323b						CALLMONITOR 
323b cd 6a 16			call break_point_state  
323e				endm  
# End of macro CALLMONITOR
323e					endif 
323e			 
323e				; go back to previous word 
323e			 
323e d5				push de    ; save I for inc later 
323f			 
323f			 
323f				; get limit 
323f				;  is I at limit? 
323f			 
323f			 
323f					if DEBUG_FORTH_WORDS 
323f						DMARK "LP1" 
323f f5				push af  
3240 3a 54 32			ld a, (.dmark)  
3243 32 bd fb			ld (debug_mark),a  
3246 3a 55 32			ld a, (.dmark+1)  
3249 32 be fb			ld (debug_mark+1),a  
324c 3a 56 32			ld a, (.dmark+2)  
324f 32 bf fb			ld (debug_mark+2),a  
3252 18 03			jr .pastdmark  
3254 ..			.dmark: db "LP1"  
3257 f1			.pastdmark: pop af  
3258			endm  
# End of macro DMARK
3258						CALLMONITOR 
3258 cd 6a 16			call break_point_state  
325b				endm  
# End of macro CALLMONITOR
325b					endif 
325b			 
325b ed 52			sbc hl, de 
325d			 
325d			 
325d				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
325d			 
325d 20 26				jr nz, .loopnotdone 
325f			 
325f e1				pop hl   ; get rid of saved I 
3260				FORTH_LOOP_POP     ; get rid of limit 
3260 cd 5c 1e			call macro_forth_loop_pop 
3263				endm 
# End of macro FORTH_LOOP_POP
3263			 
3263				FORTH_RSP_POP     ; get rid of DO ptr 
3263 cd bf 1b			call macro_forth_rsp_pop 
3266				endm 
# End of macro FORTH_RSP_POP
3266			 
3266			if DEBUG_FORTH_WORDS 
3266						DMARK "LP>" 
3266 f5				push af  
3267 3a 7b 32			ld a, (.dmark)  
326a 32 bd fb			ld (debug_mark),a  
326d 3a 7c 32			ld a, (.dmark+1)  
3270 32 be fb			ld (debug_mark+1),a  
3273 3a 7d 32			ld a, (.dmark+2)  
3276 32 bf fb			ld (debug_mark+2),a  
3279 18 03			jr .pastdmark  
327b ..			.dmark: db "LP>"  
327e f1			.pastdmark: pop af  
327f			endm  
# End of macro DMARK
327f				CALLMONITOR 
327f cd 6a 16			call break_point_state  
3282				endm  
# End of macro CALLMONITOR
3282			endif 
3282			 
3282					NEXTW 
3282 c3 60 1f			jp macro_next 
3285				endm 
# End of macro NEXTW
3285				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3285			 
3285			.loopnotdone: 
3285			 
3285 e1				pop hl    ; get I 
3286 23				inc hl 
3287			 
3287			   	; save new I 
3287			 
3287			 
3287					; set I counter 
3287			 
3287 22 c8 f2				ld (os_current_i), hl 
328a			 
328a					if DEBUG_FORTH_WORDS 
328a						DMARK "LPN" 
328a f5				push af  
328b 3a 9f 32			ld a, (.dmark)  
328e 32 bd fb			ld (debug_mark),a  
3291 3a a0 32			ld a, (.dmark+1)  
3294 32 be fb			ld (debug_mark+1),a  
3297 3a a1 32			ld a, (.dmark+2)  
329a 32 bf fb			ld (debug_mark+2),a  
329d 18 03			jr .pastdmark  
329f ..			.dmark: db "LPN"  
32a2 f1			.pastdmark: pop af  
32a3			endm  
# End of macro DMARK
32a3					CALLMONITOR 
32a3 cd 6a 16			call break_point_state  
32a6				endm  
# End of macro CALLMONITOR
32a6					endif 
32a6					 
32a6				FORTH_LOOP_NEXT 
32a6 cd 1f 1e			call macro_forth_loop_next 
32a9				endm 
# End of macro FORTH_LOOP_NEXT
32a9			 
32a9			 
32a9					if DEBUG_FORTH_WORDS 
32a9 eb						ex de,hl 
32aa					endif 
32aa			 
32aa			;	; get DO ptr 
32aa			; 
32aa					if DEBUG_FORTH_WORDS 
32aa						DMARK "LP7" 
32aa f5				push af  
32ab 3a bf 32			ld a, (.dmark)  
32ae 32 bd fb			ld (debug_mark),a  
32b1 3a c0 32			ld a, (.dmark+1)  
32b4 32 be fb			ld (debug_mark+1),a  
32b7 3a c1 32			ld a, (.dmark+2)  
32ba 32 bf fb			ld (debug_mark+2),a  
32bd 18 03			jr .pastdmark  
32bf ..			.dmark: db "LP7"  
32c2 f1			.pastdmark: pop af  
32c3			endm  
# End of macro DMARK
32c3					CALLMONITOR 
32c3 cd 6a 16			call break_point_state  
32c6				endm  
# End of macro CALLMONITOR
32c6					endif 
32c6				FORTH_RSP_TOS 
32c6 cd b5 1b			call macro_forth_rsp_tos 
32c9				endm 
# End of macro FORTH_RSP_TOS
32c9			 
32c9					if DEBUG_FORTH_WORDS 
32c9						DMARK "LP8" 
32c9 f5				push af  
32ca 3a de 32			ld a, (.dmark)  
32cd 32 bd fb			ld (debug_mark),a  
32d0 3a df 32			ld a, (.dmark+1)  
32d3 32 be fb			ld (debug_mark+1),a  
32d6 3a e0 32			ld a, (.dmark+2)  
32d9 32 bf fb			ld (debug_mark+2),a  
32dc 18 03			jr .pastdmark  
32de ..			.dmark: db "LP8"  
32e1 f1			.pastdmark: pop af  
32e2			endm  
# End of macro DMARK
32e2					CALLMONITOR 
32e2 cd 6a 16			call break_point_state  
32e5				endm  
# End of macro CALLMONITOR
32e5					endif 
32e5				;push hl 
32e5			 
32e5				; not going to DO any more 
32e5				; get rid of the RSP pointer as DO will add it back in 
32e5				;FORTH_RSP_POP 
32e5				;pop hl 
32e5			 
32e5				;ld hl,(cli_ret_sp) 
32e5				;ld e, (hl) 
32e5				;inc hl 
32e5				;ld d, (hl) 
32e5				;ex de,hl 
32e5 22 a4 f2			ld (os_tok_ptr), hl 
32e8					if DEBUG_FORTH_WORDS 
32e8						DMARK "LP<" 
32e8 f5				push af  
32e9 3a fd 32			ld a, (.dmark)  
32ec 32 bd fb			ld (debug_mark),a  
32ef 3a fe 32			ld a, (.dmark+1)  
32f2 32 be fb			ld (debug_mark+1),a  
32f5 3a ff 32			ld a, (.dmark+2)  
32f8 32 bf fb			ld (debug_mark+2),a  
32fb 18 03			jr .pastdmark  
32fd ..			.dmark: db "LP<"  
3300 f1			.pastdmark: pop af  
3301			endm  
# End of macro DMARK
3301					CALLMONITOR 
3301 cd 6a 16			call break_point_state  
3304				endm  
# End of macro CALLMONITOR
3304				endif 
3304 c3 f1 1f			jp exec1 
3307			 
3307					 
3307			 
3307			 
3307					NEXTW 
3307 c3 60 1f			jp macro_next 
330a				endm 
# End of macro NEXTW
330a			.I:  
330a			 
330a				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
330a 5e				db WORD_SYS_CORE+74             
330b 35 33			dw .DLOOP            
330d 02				db 1 + 1 
330e .. 00			db "I",0              
3310				endm 
# End of macro CWHEAD
3310			; | I ( -- ) Current loop counter | DONE 
3310					if DEBUG_FORTH_WORDS_KEY 
3310						DMARK "I.." 
3310 f5				push af  
3311 3a 25 33			ld a, (.dmark)  
3314 32 bd fb			ld (debug_mark),a  
3317 3a 26 33			ld a, (.dmark+1)  
331a 32 be fb			ld (debug_mark+1),a  
331d 3a 27 33			ld a, (.dmark+2)  
3320 32 bf fb			ld (debug_mark+2),a  
3323 18 03			jr .pastdmark  
3325 ..			.dmark: db "I.."  
3328 f1			.pastdmark: pop af  
3329			endm  
# End of macro DMARK
3329						CALLMONITOR 
3329 cd 6a 16			call break_point_state  
332c				endm  
# End of macro CALLMONITOR
332c					endif 
332c			 
332c 2a c8 f2				ld hl,(os_current_i) 
332f cd f7 1b				call forth_push_numhl 
3332			 
3332					NEXTW 
3332 c3 60 1f			jp macro_next 
3335				endm 
# End of macro NEXTW
3335			.DLOOP: 
3335				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3335 5f				db WORD_SYS_CORE+75             
3336 16 34			dw .REPEAT            
3338 06				db 5 + 1 
3339 .. 00			db "-LOOP",0              
333f				endm 
# End of macro CWHEAD
333f			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
333f				; pop tos as current loop count to hl 
333f					if DEBUG_FORTH_WORDS_KEY 
333f						DMARK "-LP" 
333f f5				push af  
3340 3a 54 33			ld a, (.dmark)  
3343 32 bd fb			ld (debug_mark),a  
3346 3a 55 33			ld a, (.dmark+1)  
3349 32 be fb			ld (debug_mark+1),a  
334c 3a 56 33			ld a, (.dmark+2)  
334f 32 bf fb			ld (debug_mark+2),a  
3352 18 03			jr .pastdmark  
3354 ..			.dmark: db "-LP"  
3357 f1			.pastdmark: pop af  
3358			endm  
# End of macro DMARK
3358						CALLMONITOR 
3358 cd 6a 16			call break_point_state  
335b				endm  
# End of macro CALLMONITOR
335b					endif 
335b			 
335b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
335b			 
335b				FORTH_LOOP_TOS 
335b cd 52 1e			call macro_forth_loop_tos 
335e				endm 
# End of macro FORTH_LOOP_TOS
335e e5				push hl 
335f			 
335f					if DEBUG_FORTH_WORDS 
335f						DMARK "-LP" 
335f f5				push af  
3360 3a 74 33			ld a, (.dmark)  
3363 32 bd fb			ld (debug_mark),a  
3366 3a 75 33			ld a, (.dmark+1)  
3369 32 be fb			ld (debug_mark+1),a  
336c 3a 76 33			ld a, (.dmark+2)  
336f 32 bf fb			ld (debug_mark+2),a  
3372 18 03			jr .pastdmark  
3374 ..			.dmark: db "-LP"  
3377 f1			.pastdmark: pop af  
3378			endm  
# End of macro DMARK
3378						CALLMONITOR 
3378 cd 6a 16			call break_point_state  
337b				endm  
# End of macro CALLMONITOR
337b					endif 
337b				; next item on the stack is the limit. get it 
337b			 
337b			 
337b				FORTH_LOOP_POP 
337b cd 5c 1e			call macro_forth_loop_pop 
337e				endm 
# End of macro FORTH_LOOP_POP
337e			 
337e				FORTH_LOOP_TOS 
337e cd 52 1e			call macro_forth_loop_tos 
3381				endm 
# End of macro FORTH_LOOP_TOS
3381			 
3381 d1				pop de		 ; de = i, hl = limit 
3382			 
3382					if DEBUG_FORTH_WORDS 
3382						DMARK "-L1" 
3382 f5				push af  
3383 3a 97 33			ld a, (.dmark)  
3386 32 bd fb			ld (debug_mark),a  
3389 3a 98 33			ld a, (.dmark+1)  
338c 32 be fb			ld (debug_mark+1),a  
338f 3a 99 33			ld a, (.dmark+2)  
3392 32 bf fb			ld (debug_mark+2),a  
3395 18 03			jr .pastdmark  
3397 ..			.dmark: db "-L1"  
339a f1			.pastdmark: pop af  
339b			endm  
# End of macro DMARK
339b						CALLMONITOR 
339b cd 6a 16			call break_point_state  
339e				endm  
# End of macro CALLMONITOR
339e					endif 
339e			 
339e				; go back to previous word 
339e			 
339e d5				push de    ; save I for inc later 
339f			 
339f			 
339f				; get limit 
339f				;  is I at limit? 
339f			 
339f			 
339f					if DEBUG_FORTH_WORDS 
339f						DMARK "-L1" 
339f f5				push af  
33a0 3a b4 33			ld a, (.dmark)  
33a3 32 bd fb			ld (debug_mark),a  
33a6 3a b5 33			ld a, (.dmark+1)  
33a9 32 be fb			ld (debug_mark+1),a  
33ac 3a b6 33			ld a, (.dmark+2)  
33af 32 bf fb			ld (debug_mark+2),a  
33b2 18 03			jr .pastdmark  
33b4 ..			.dmark: db "-L1"  
33b7 f1			.pastdmark: pop af  
33b8			endm  
# End of macro DMARK
33b8						CALLMONITOR 
33b8 cd 6a 16			call break_point_state  
33bb				endm  
# End of macro CALLMONITOR
33bb					endif 
33bb			 
33bb ed 52			sbc hl, de 
33bd			 
33bd			 
33bd				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
33bd			 
33bd 20 26				jr nz, .mloopnotdone 
33bf			 
33bf e1				pop hl   ; get rid of saved I 
33c0				FORTH_LOOP_POP     ; get rid of limit 
33c0 cd 5c 1e			call macro_forth_loop_pop 
33c3				endm 
# End of macro FORTH_LOOP_POP
33c3			 
33c3				FORTH_RSP_POP     ; get rid of DO ptr 
33c3 cd bf 1b			call macro_forth_rsp_pop 
33c6				endm 
# End of macro FORTH_RSP_POP
33c6			 
33c6			if DEBUG_FORTH_WORDS 
33c6						DMARK "-L>" 
33c6 f5				push af  
33c7 3a db 33			ld a, (.dmark)  
33ca 32 bd fb			ld (debug_mark),a  
33cd 3a dc 33			ld a, (.dmark+1)  
33d0 32 be fb			ld (debug_mark+1),a  
33d3 3a dd 33			ld a, (.dmark+2)  
33d6 32 bf fb			ld (debug_mark+2),a  
33d9 18 03			jr .pastdmark  
33db ..			.dmark: db "-L>"  
33de f1			.pastdmark: pop af  
33df			endm  
# End of macro DMARK
33df				CALLMONITOR 
33df cd 6a 16			call break_point_state  
33e2				endm  
# End of macro CALLMONITOR
33e2			endif 
33e2			 
33e2					NEXTW 
33e2 c3 60 1f			jp macro_next 
33e5				endm 
# End of macro NEXTW
33e5				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
33e5			 
33e5			.mloopnotdone: 
33e5			 
33e5 e1				pop hl    ; get I 
33e6 2b				dec hl 
33e7			 
33e7			   	; save new I 
33e7			 
33e7			 
33e7					; set I counter 
33e7			 
33e7 22 c8 f2				ld (os_current_i), hl 
33ea			 
33ea					 
33ea				FORTH_LOOP_NEXT 
33ea cd 1f 1e			call macro_forth_loop_next 
33ed				endm 
# End of macro FORTH_LOOP_NEXT
33ed			 
33ed			 
33ed					if DEBUG_FORTH_WORDS 
33ed eb						ex de,hl 
33ee					endif 
33ee			 
33ee			;	; get DO ptr 
33ee			; 
33ee				FORTH_RSP_TOS 
33ee cd b5 1b			call macro_forth_rsp_tos 
33f1				endm 
# End of macro FORTH_RSP_TOS
33f1			 
33f1				;push hl 
33f1			 
33f1				; not going to DO any more 
33f1				; get rid of the RSP pointer as DO will add it back in 
33f1				;FORTH_RSP_POP 
33f1				;pop hl 
33f1			 
33f1			 
33f1 22 a4 f2			ld (os_tok_ptr), hl 
33f4					if DEBUG_FORTH_WORDS 
33f4						DMARK "-L<" 
33f4 f5				push af  
33f5 3a 09 34			ld a, (.dmark)  
33f8 32 bd fb			ld (debug_mark),a  
33fb 3a 0a 34			ld a, (.dmark+1)  
33fe 32 be fb			ld (debug_mark+1),a  
3401 3a 0b 34			ld a, (.dmark+2)  
3404 32 bf fb			ld (debug_mark+2),a  
3407 18 03			jr .pastdmark  
3409 ..			.dmark: db "-L<"  
340c f1			.pastdmark: pop af  
340d			endm  
# End of macro DMARK
340d					CALLMONITOR 
340d cd 6a 16			call break_point_state  
3410				endm  
# End of macro CALLMONITOR
3410				endif 
3410 c3 f1 1f			jp exec1 
3413			 
3413					 
3413			 
3413			 
3413			 
3413				NEXTW 
3413 c3 60 1f			jp macro_next 
3416				endm 
# End of macro NEXTW
3416			 
3416			 
3416			 
3416			 
3416			.REPEAT: 
3416				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3416 71				db WORD_SYS_CORE+93             
3417 69 34			dw .UNTIL            
3419 06				db 5 + 1 
341a .. 00			db "REPEAT",0              
3421				endm 
# End of macro CWHEAD
3421			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3421			;  push pc to rsp stack past the REPEAT 
3421					if DEBUG_FORTH_WORDS_KEY 
3421						DMARK "REP" 
3421 f5				push af  
3422 3a 36 34			ld a, (.dmark)  
3425 32 bd fb			ld (debug_mark),a  
3428 3a 37 34			ld a, (.dmark+1)  
342b 32 be fb			ld (debug_mark+1),a  
342e 3a 38 34			ld a, (.dmark+2)  
3431 32 bf fb			ld (debug_mark+2),a  
3434 18 03			jr .pastdmark  
3436 ..			.dmark: db "REP"  
3439 f1			.pastdmark: pop af  
343a			endm  
# End of macro DMARK
343a						CALLMONITOR 
343a cd 6a 16			call break_point_state  
343d				endm  
# End of macro CALLMONITOR
343d					endif 
343d			 
343d 2a a4 f2				ld hl, (os_tok_ptr) 
3440 23					inc hl   ; R 
3441 23					inc hl  ; E 
3442 23					inc hl   ; P 
3443 23					inc hl   ; E 
3444 23					inc hl   ; A 
3445 23					inc hl   ; T 
3446 23					inc hl   ; zero 
3447					FORTH_RSP_NEXT 
3447 cd 9e 1b			call macro_forth_rsp_next 
344a				endm 
# End of macro FORTH_RSP_NEXT
344a			 
344a			 
344a					if DEBUG_FORTH_WORDS 
344a						DMARK "REP" 
344a f5				push af  
344b 3a 5f 34			ld a, (.dmark)  
344e 32 bd fb			ld (debug_mark),a  
3451 3a 60 34			ld a, (.dmark+1)  
3454 32 be fb			ld (debug_mark+1),a  
3457 3a 61 34			ld a, (.dmark+2)  
345a 32 bf fb			ld (debug_mark+2),a  
345d 18 03			jr .pastdmark  
345f ..			.dmark: db "REP"  
3462 f1			.pastdmark: pop af  
3463			endm  
# End of macro DMARK
3463						;pop bc    ; TODO BUG ?????? what is this for???? 
3463						CALLMONITOR 
3463 cd 6a 16			call break_point_state  
3466				endm  
# End of macro CALLMONITOR
3466					endif 
3466			 
3466					NEXTW 
3466 c3 60 1f			jp macro_next 
3469				endm 
# End of macro NEXTW
3469			;	       NEXTW 
3469			 
3469			.UNTIL: 
3469				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3469 72				db WORD_SYS_CORE+94             
346a 00 35			dw .ENDFLOW            
346c 06				db 5 + 1 
346d .. 00			db "UNTIL",0              
3473				endm 
# End of macro CWHEAD
3473			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3473			 
3473				; pop tos as check 
3473			 
3473				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3473			 
3473				FORTH_DSP_VALUEHL 
3473 cd ee 1d			call macro_dsp_valuehl 
3476				endm 
# End of macro FORTH_DSP_VALUEHL
3476			 
3476					if DEBUG_FORTH_WORDS_KEY 
3476						DMARK "UNT" 
3476 f5				push af  
3477 3a 8b 34			ld a, (.dmark)  
347a 32 bd fb			ld (debug_mark),a  
347d 3a 8c 34			ld a, (.dmark+1)  
3480 32 be fb			ld (debug_mark+1),a  
3483 3a 8d 34			ld a, (.dmark+2)  
3486 32 bf fb			ld (debug_mark+2),a  
3489 18 03			jr .pastdmark  
348b ..			.dmark: db "UNT"  
348e f1			.pastdmark: pop af  
348f			endm  
# End of macro DMARK
348f						CALLMONITOR 
348f cd 6a 16			call break_point_state  
3492				endm  
# End of macro CALLMONITOR
3492					endif 
3492			 
3492			;	push hl 
3492				FORTH_DSP_POP 
3492 cd a6 1e			call macro_forth_dsp_pop 
3495				endm 
# End of macro FORTH_DSP_POP
3495			 
3495			;	pop hl 
3495			 
3495				; test if true 
3495			 
3495 cd 2f 0d			call ishlzero 
3498			;	ld a,l 
3498			;	add h 
3498			; 
3498			;	cp 0 
3498			 
3498 20 3e			jr nz, .untilnotdone 
349a			 
349a					if DEBUG_FORTH_WORDS 
349a						DMARK "UNf" 
349a f5				push af  
349b 3a af 34			ld a, (.dmark)  
349e 32 bd fb			ld (debug_mark),a  
34a1 3a b0 34			ld a, (.dmark+1)  
34a4 32 be fb			ld (debug_mark+1),a  
34a7 3a b1 34			ld a, (.dmark+2)  
34aa 32 bf fb			ld (debug_mark+2),a  
34ad 18 03			jr .pastdmark  
34af ..			.dmark: db "UNf"  
34b2 f1			.pastdmark: pop af  
34b3			endm  
# End of macro DMARK
34b3						CALLMONITOR 
34b3 cd 6a 16			call break_point_state  
34b6				endm  
# End of macro CALLMONITOR
34b6					endif 
34b6			 
34b6			 
34b6			 
34b6				FORTH_RSP_POP     ; get rid of DO ptr 
34b6 cd bf 1b			call macro_forth_rsp_pop 
34b9				endm 
# End of macro FORTH_RSP_POP
34b9			 
34b9			if DEBUG_FORTH_WORDS 
34b9						DMARK "UN>" 
34b9 f5				push af  
34ba 3a ce 34			ld a, (.dmark)  
34bd 32 bd fb			ld (debug_mark),a  
34c0 3a cf 34			ld a, (.dmark+1)  
34c3 32 be fb			ld (debug_mark+1),a  
34c6 3a d0 34			ld a, (.dmark+2)  
34c9 32 bf fb			ld (debug_mark+2),a  
34cc 18 03			jr .pastdmark  
34ce ..			.dmark: db "UN>"  
34d1 f1			.pastdmark: pop af  
34d2			endm  
# End of macro DMARK
34d2				CALLMONITOR 
34d2 cd 6a 16			call break_point_state  
34d5				endm  
# End of macro CALLMONITOR
34d5			endif 
34d5			 
34d5					NEXTW 
34d5 c3 60 1f			jp macro_next 
34d8				endm 
# End of macro NEXTW
34d8				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34d8			 
34d8			.untilnotdone: 
34d8			 
34d8			 
34d8			;	; get DO ptr 
34d8			; 
34d8				FORTH_RSP_TOS 
34d8 cd b5 1b			call macro_forth_rsp_tos 
34db				endm 
# End of macro FORTH_RSP_TOS
34db			 
34db				;push hl 
34db			 
34db				; not going to DO any more 
34db				; get rid of the RSP pointer as DO will add it back in 
34db				;FORTH_RSP_POP 
34db				;pop hl 
34db			 
34db			 
34db 22 a4 f2			ld (os_tok_ptr), hl 
34de					if DEBUG_FORTH_WORDS 
34de						DMARK "UN<" 
34de f5				push af  
34df 3a f3 34			ld a, (.dmark)  
34e2 32 bd fb			ld (debug_mark),a  
34e5 3a f4 34			ld a, (.dmark+1)  
34e8 32 be fb			ld (debug_mark+1),a  
34eb 3a f5 34			ld a, (.dmark+2)  
34ee 32 bf fb			ld (debug_mark+2),a  
34f1 18 03			jr .pastdmark  
34f3 ..			.dmark: db "UN<"  
34f6 f1			.pastdmark: pop af  
34f7			endm  
# End of macro DMARK
34f7					CALLMONITOR 
34f7 cd 6a 16			call break_point_state  
34fa				endm  
# End of macro CALLMONITOR
34fa				endif 
34fa c3 f1 1f			jp exec1 
34fd			 
34fd					 
34fd			 
34fd			 
34fd					NEXTW 
34fd c3 60 1f			jp macro_next 
3500				endm 
# End of macro NEXTW
3500			 
3500			 
3500			.ENDFLOW: 
3500			 
3500			; eof 
3500			 
# End of file forth_words_flow.asm
3500			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3500			include "forth_words_logic.asm" 
3500			 
3500			; | ## Logic Words 
3500			 
3500			.NOT: 
3500				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3500 2d				db WORD_SYS_CORE+25             
3501 48 35			dw .IS            
3503 04				db 3 + 1 
3504 .. 00			db "NOT",0              
3508				endm 
# End of macro CWHEAD
3508			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3508					if DEBUG_FORTH_WORDS_KEY 
3508						DMARK "NOT" 
3508 f5				push af  
3509 3a 1d 35			ld a, (.dmark)  
350c 32 bd fb			ld (debug_mark),a  
350f 3a 1e 35			ld a, (.dmark+1)  
3512 32 be fb			ld (debug_mark+1),a  
3515 3a 1f 35			ld a, (.dmark+2)  
3518 32 bf fb			ld (debug_mark+2),a  
351b 18 03			jr .pastdmark  
351d ..			.dmark: db "NOT"  
3520 f1			.pastdmark: pop af  
3521			endm  
# End of macro DMARK
3521						CALLMONITOR 
3521 cd 6a 16			call break_point_state  
3524				endm  
# End of macro CALLMONITOR
3524					endif 
3524					FORTH_DSP 
3524 cd b4 1d			call macro_forth_dsp 
3527				endm 
# End of macro FORTH_DSP
3527 7e					ld a,(hl)	; get type of value on TOS 
3528 fe 02				cp DS_TYPE_INUM  
352a 28 03				jr z, .noti 
352c					NEXTW 
352c c3 60 1f			jp macro_next 
352f				endm 
# End of macro NEXTW
352f			.noti:          FORTH_DSP_VALUEHL 
352f cd ee 1d			call macro_dsp_valuehl 
3532				endm 
# End of macro FORTH_DSP_VALUEHL
3532			;		push hl 
3532					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3532 cd a6 1e			call macro_forth_dsp_pop 
3535				endm 
# End of macro FORTH_DSP_POP
3535			;		pop hl 
3535 3e 00				ld a,0 
3537 bd					cp l 
3538 28 04				jr z, .not2t 
353a 2e 00				ld l, 0 
353c 18 02				jr .notip 
353e			 
353e 2e ff		.not2t:		ld l, 255 
3540			 
3540 26 00		.notip:		ld h, 0	 
3542			 
3542 cd f7 1b				call forth_push_numhl 
3545					NEXTW 
3545 c3 60 1f			jp macro_next 
3548				endm 
# End of macro NEXTW
3548			 
3548			.IS: 
3548				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3548 2d				db WORD_SYS_CORE+25             
3549 6e 35			dw .LZERO            
354b 03				db 2 + 1 
354c .. 00			db "IS",0              
354f				endm 
# End of macro CWHEAD
354f			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
354f					if DEBUG_FORTH_WORDS_KEY 
354f						DMARK "IS." 
354f f5				push af  
3550 3a 64 35			ld a, (.dmark)  
3553 32 bd fb			ld (debug_mark),a  
3556 3a 65 35			ld a, (.dmark+1)  
3559 32 be fb			ld (debug_mark+1),a  
355c 3a 66 35			ld a, (.dmark+2)  
355f 32 bf fb			ld (debug_mark+2),a  
3562 18 03			jr .pastdmark  
3564 ..			.dmark: db "IS."  
3567 f1			.pastdmark: pop af  
3568			endm  
# End of macro DMARK
3568						CALLMONITOR 
3568 cd 6a 16			call break_point_state  
356b				endm  
# End of macro CALLMONITOR
356b					endif 
356b					NEXTW 
356b c3 60 1f			jp macro_next 
356e				endm 
# End of macro NEXTW
356e			.LZERO: 
356e				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
356e 2d				db WORD_SYS_CORE+25             
356f 78 35			dw .TZERO            
3571 03				db 2 + 1 
3572 .. 00			db "0<",0              
3575				endm 
# End of macro CWHEAD
3575			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3575					NEXTW 
3575 c3 60 1f			jp macro_next 
3578				endm 
# End of macro NEXTW
3578			.TZERO: 
3578				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3578 2e				db WORD_SYS_CORE+26             
3579 bf 35			dw .LESS            
357b 03				db 2 + 1 
357c .. 00			db "0=",0              
357f				endm 
# End of macro CWHEAD
357f			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
357f				; TODO add floating point number detection 
357f					;v5 FORTH_DSP_VALUE 
357f					if DEBUG_FORTH_WORDS_KEY 
357f						DMARK "0=." 
357f f5				push af  
3580 3a 94 35			ld a, (.dmark)  
3583 32 bd fb			ld (debug_mark),a  
3586 3a 95 35			ld a, (.dmark+1)  
3589 32 be fb			ld (debug_mark+1),a  
358c 3a 96 35			ld a, (.dmark+2)  
358f 32 bf fb			ld (debug_mark+2),a  
3592 18 03			jr .pastdmark  
3594 ..			.dmark: db "0=."  
3597 f1			.pastdmark: pop af  
3598			endm  
# End of macro DMARK
3598						CALLMONITOR 
3598 cd 6a 16			call break_point_state  
359b				endm  
# End of macro CALLMONITOR
359b					endif 
359b					FORTH_DSP 
359b cd b4 1d			call macro_forth_dsp 
359e				endm 
# End of macro FORTH_DSP
359e 7e					ld a,(hl)	; get type of value on TOS 
359f fe 02				cp DS_TYPE_INUM  
35a1 28 00				jr z, .tz_inum 
35a3			 
35a3				if FORTH_ENABLE_FLOATMATH 
35a3					jr .tz_done 
35a3			 
35a3				endif 
35a3					 
35a3			 
35a3			.tz_inum: 
35a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35a3 cd ee 1d			call macro_dsp_valuehl 
35a6				endm 
# End of macro FORTH_DSP_VALUEHL
35a6			 
35a6			;		push hl 
35a6			 
35a6					; destroy value TOS 
35a6			 
35a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35a6 cd a6 1e			call macro_forth_dsp_pop 
35a9				endm 
# End of macro FORTH_DSP_POP
35a9			 
35a9			;		pop hl 
35a9			 
35a9 3e 00				ld a,0 
35ab			 
35ab bd					cp l 
35ac 20 08				jr nz, .tz_notzero 
35ae			 
35ae bc					cp h 
35af			 
35af 20 05				jr nz, .tz_notzero 
35b1			 
35b1			 
35b1 21 01 00				ld hl, FORTH_TRUE 
35b4 18 03				jr .tz_done 
35b6			 
35b6 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
35b9			 
35b9					; push value back onto stack for another op etc 
35b9			 
35b9			.tz_done: 
35b9 cd f7 1b				call forth_push_numhl 
35bc			 
35bc					NEXTW 
35bc c3 60 1f			jp macro_next 
35bf				endm 
# End of macro NEXTW
35bf			.LESS: 
35bf				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
35bf 2f				db WORD_SYS_CORE+27             
35c0 28 36			dw .GT            
35c2 02				db 1 + 1 
35c3 .. 00			db "<",0              
35c5				endm 
# End of macro CWHEAD
35c5			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
35c5				; TODO add floating point number detection 
35c5					if DEBUG_FORTH_WORDS_KEY 
35c5						DMARK "LES" 
35c5 f5				push af  
35c6 3a da 35			ld a, (.dmark)  
35c9 32 bd fb			ld (debug_mark),a  
35cc 3a db 35			ld a, (.dmark+1)  
35cf 32 be fb			ld (debug_mark+1),a  
35d2 3a dc 35			ld a, (.dmark+2)  
35d5 32 bf fb			ld (debug_mark+2),a  
35d8 18 03			jr .pastdmark  
35da ..			.dmark: db "LES"  
35dd f1			.pastdmark: pop af  
35de			endm  
# End of macro DMARK
35de						CALLMONITOR 
35de cd 6a 16			call break_point_state  
35e1				endm  
# End of macro CALLMONITOR
35e1					endif 
35e1					FORTH_DSP 
35e1 cd b4 1d			call macro_forth_dsp 
35e4				endm 
# End of macro FORTH_DSP
35e4					;v5 FORTH_DSP_VALUE 
35e4 7e					ld a,(hl)	; get type of value on TOS 
35e5 fe 02				cp DS_TYPE_INUM  
35e7 28 00				jr z, .less_inum 
35e9			 
35e9				if FORTH_ENABLE_FLOATMATH 
35e9					jr .less_done 
35e9			 
35e9				endif 
35e9					 
35e9			 
35e9			.less_inum: 
35e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35e9 cd ee 1d			call macro_dsp_valuehl 
35ec				endm 
# End of macro FORTH_DSP_VALUEHL
35ec			 
35ec e5					push hl  ; u2 
35ed			 
35ed					; destroy value TOS 
35ed			 
35ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35ed cd a6 1e			call macro_forth_dsp_pop 
35f0				endm 
# End of macro FORTH_DSP_POP
35f0			 
35f0			 
35f0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35f0 cd ee 1d			call macro_dsp_valuehl 
35f3				endm 
# End of macro FORTH_DSP_VALUEHL
35f3			 
35f3 e5					push hl    ; u1 
35f4			 
35f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35f4 cd a6 1e			call macro_forth_dsp_pop 
35f7				endm 
# End of macro FORTH_DSP_POP
35f7			 
35f7			 
35f7 b7			 or a      ;clear carry flag 
35f8 01 00 00		 ld bc, FORTH_FALSE 
35fb e1			  pop hl    ; u1 
35fc d1			  pop de    ; u2 
35fd ed 52		  sbc hl,de 
35ff 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3601			 
3601 01 01 00		 ld bc, FORTH_TRUE 
3604			.lscont:  
3604 c5					push bc 
3605 e1					pop hl 
3606			 
3606					if DEBUG_FORTH_WORDS 
3606						DMARK "LT1" 
3606 f5				push af  
3607 3a 1b 36			ld a, (.dmark)  
360a 32 bd fb			ld (debug_mark),a  
360d 3a 1c 36			ld a, (.dmark+1)  
3610 32 be fb			ld (debug_mark+1),a  
3613 3a 1d 36			ld a, (.dmark+2)  
3616 32 bf fb			ld (debug_mark+2),a  
3619 18 03			jr .pastdmark  
361b ..			.dmark: db "LT1"  
361e f1			.pastdmark: pop af  
361f			endm  
# End of macro DMARK
361f						CALLMONITOR 
361f cd 6a 16			call break_point_state  
3622				endm  
# End of macro CALLMONITOR
3622					endif 
3622 cd f7 1b				call forth_push_numhl 
3625			 
3625					NEXTW 
3625 c3 60 1f			jp macro_next 
3628				endm 
# End of macro NEXTW
3628			.GT: 
3628				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3628 30				db WORD_SYS_CORE+28             
3629 91 36			dw .EQUAL            
362b 02				db 1 + 1 
362c .. 00			db ">",0              
362e				endm 
# End of macro CWHEAD
362e			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
362e				; TODO add floating point number detection 
362e					if DEBUG_FORTH_WORDS_KEY 
362e						DMARK "GRT" 
362e f5				push af  
362f 3a 43 36			ld a, (.dmark)  
3632 32 bd fb			ld (debug_mark),a  
3635 3a 44 36			ld a, (.dmark+1)  
3638 32 be fb			ld (debug_mark+1),a  
363b 3a 45 36			ld a, (.dmark+2)  
363e 32 bf fb			ld (debug_mark+2),a  
3641 18 03			jr .pastdmark  
3643 ..			.dmark: db "GRT"  
3646 f1			.pastdmark: pop af  
3647			endm  
# End of macro DMARK
3647						CALLMONITOR 
3647 cd 6a 16			call break_point_state  
364a				endm  
# End of macro CALLMONITOR
364a					endif 
364a					FORTH_DSP 
364a cd b4 1d			call macro_forth_dsp 
364d				endm 
# End of macro FORTH_DSP
364d					;FORTH_DSP_VALUE 
364d 7e					ld a,(hl)	; get type of value on TOS 
364e fe 02				cp DS_TYPE_INUM  
3650 28 00				jr z, .gt_inum 
3652			 
3652				if FORTH_ENABLE_FLOATMATH 
3652					jr .gt_done 
3652			 
3652				endif 
3652					 
3652			 
3652			.gt_inum: 
3652					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3652 cd ee 1d			call macro_dsp_valuehl 
3655				endm 
# End of macro FORTH_DSP_VALUEHL
3655			 
3655 e5					push hl  ; u2 
3656			 
3656					; destroy value TOS 
3656			 
3656					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3656 cd a6 1e			call macro_forth_dsp_pop 
3659				endm 
# End of macro FORTH_DSP_POP
3659			 
3659			 
3659					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3659 cd ee 1d			call macro_dsp_valuehl 
365c				endm 
# End of macro FORTH_DSP_VALUEHL
365c			 
365c e5					push hl    ; u1 
365d			 
365d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
365d cd a6 1e			call macro_forth_dsp_pop 
3660				endm 
# End of macro FORTH_DSP_POP
3660			 
3660			 
3660 b7			 or a      ;clear carry flag 
3661 01 00 00		 ld bc, FORTH_FALSE 
3664 e1			  pop hl    ; u1 
3665 d1			  pop de    ; u2 
3666 ed 52		  sbc hl,de 
3668 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
366a			 
366a 01 01 00		 ld bc, FORTH_TRUE 
366d			.gtcont:  
366d c5					push bc 
366e e1					pop hl 
366f			 
366f					if DEBUG_FORTH_WORDS 
366f						DMARK "GT1" 
366f f5				push af  
3670 3a 84 36			ld a, (.dmark)  
3673 32 bd fb			ld (debug_mark),a  
3676 3a 85 36			ld a, (.dmark+1)  
3679 32 be fb			ld (debug_mark+1),a  
367c 3a 86 36			ld a, (.dmark+2)  
367f 32 bf fb			ld (debug_mark+2),a  
3682 18 03			jr .pastdmark  
3684 ..			.dmark: db "GT1"  
3687 f1			.pastdmark: pop af  
3688			endm  
# End of macro DMARK
3688						CALLMONITOR 
3688 cd 6a 16			call break_point_state  
368b				endm  
# End of macro CALLMONITOR
368b					endif 
368b cd f7 1b				call forth_push_numhl 
368e			 
368e					NEXTW 
368e c3 60 1f			jp macro_next 
3691				endm 
# End of macro NEXTW
3691			.EQUAL: 
3691				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3691 31				db WORD_SYS_CORE+29             
3692 fc 36			dw .ENDLOGIC            
3694 02				db 1 + 1 
3695 .. 00			db "=",0              
3697				endm 
# End of macro CWHEAD
3697			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3697				; TODO add floating point number detection 
3697					if DEBUG_FORTH_WORDS_KEY 
3697						DMARK "EQ." 
3697 f5				push af  
3698 3a ac 36			ld a, (.dmark)  
369b 32 bd fb			ld (debug_mark),a  
369e 3a ad 36			ld a, (.dmark+1)  
36a1 32 be fb			ld (debug_mark+1),a  
36a4 3a ae 36			ld a, (.dmark+2)  
36a7 32 bf fb			ld (debug_mark+2),a  
36aa 18 03			jr .pastdmark  
36ac ..			.dmark: db "EQ."  
36af f1			.pastdmark: pop af  
36b0			endm  
# End of macro DMARK
36b0						CALLMONITOR 
36b0 cd 6a 16			call break_point_state  
36b3				endm  
# End of macro CALLMONITOR
36b3					endif 
36b3					FORTH_DSP 
36b3 cd b4 1d			call macro_forth_dsp 
36b6				endm 
# End of macro FORTH_DSP
36b6					;v5 FORTH_DSP_VALUE 
36b6 7e					ld a,(hl)	; get type of value on TOS 
36b7 fe 02				cp DS_TYPE_INUM  
36b9 28 00				jr z, .eq_inum 
36bb			 
36bb				if FORTH_ENABLE_FLOATMATH 
36bb					jr .eq_done 
36bb			 
36bb				endif 
36bb					 
36bb			 
36bb			.eq_inum: 
36bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36bb cd ee 1d			call macro_dsp_valuehl 
36be				endm 
# End of macro FORTH_DSP_VALUEHL
36be			 
36be e5					push hl 
36bf			 
36bf					; destroy value TOS 
36bf			 
36bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36bf cd a6 1e			call macro_forth_dsp_pop 
36c2				endm 
# End of macro FORTH_DSP_POP
36c2			 
36c2			 
36c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36c2 cd ee 1d			call macro_dsp_valuehl 
36c5				endm 
# End of macro FORTH_DSP_VALUEHL
36c5			 
36c5					; one value on hl get other one back 
36c5			 
36c5 e5					push hl 
36c6			 
36c6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36c6 cd a6 1e			call macro_forth_dsp_pop 
36c9				endm 
# End of macro FORTH_DSP_POP
36c9			 
36c9 0e 00				ld c, FORTH_FALSE 
36cb			 
36cb e1					pop hl 
36cc d1					pop de 
36cd			 
36cd 7b					ld a, e 
36ce bd					cp l 
36cf			 
36cf 20 06				jr nz, .eq_done 
36d1			 
36d1 7a					ld a, d 
36d2 bc					cp h 
36d3			 
36d3 20 02				jr nz, .eq_done 
36d5			 
36d5 0e 01				ld c, FORTH_TRUE 
36d7					 
36d7			 
36d7			 
36d7			.eq_done: 
36d7			 
36d7					; TODO push value back onto stack for another op etc 
36d7			 
36d7 26 00				ld h, 0 
36d9 69					ld l, c 
36da					if DEBUG_FORTH_WORDS 
36da						DMARK "EQ1" 
36da f5				push af  
36db 3a ef 36			ld a, (.dmark)  
36de 32 bd fb			ld (debug_mark),a  
36e1 3a f0 36			ld a, (.dmark+1)  
36e4 32 be fb			ld (debug_mark+1),a  
36e7 3a f1 36			ld a, (.dmark+2)  
36ea 32 bf fb			ld (debug_mark+2),a  
36ed 18 03			jr .pastdmark  
36ef ..			.dmark: db "EQ1"  
36f2 f1			.pastdmark: pop af  
36f3			endm  
# End of macro DMARK
36f3						CALLMONITOR 
36f3 cd 6a 16			call break_point_state  
36f6				endm  
# End of macro CALLMONITOR
36f6					endif 
36f6 cd f7 1b				call forth_push_numhl 
36f9			 
36f9					NEXTW 
36f9 c3 60 1f			jp macro_next 
36fc				endm 
# End of macro NEXTW
36fc			 
36fc			 
36fc			.ENDLOGIC: 
36fc			; eof 
36fc			 
36fc			 
# End of file forth_words_logic.asm
36fc			include "forth_words_maths.asm" 
36fc			 
36fc			; | ## Maths Words 
36fc			 
36fc			.PLUS:	 
36fc				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
36fc 15				db WORD_SYS_CORE+1             
36fd 3e 37			dw .NEG            
36ff 02				db 1 + 1 
3700 .. 00			db "+",0              
3702				endm 
# End of macro CWHEAD
3702			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3702					if DEBUG_FORTH_WORDS_KEY 
3702						DMARK "PLU" 
3702 f5				push af  
3703 3a 17 37			ld a, (.dmark)  
3706 32 bd fb			ld (debug_mark),a  
3709 3a 18 37			ld a, (.dmark+1)  
370c 32 be fb			ld (debug_mark+1),a  
370f 3a 19 37			ld a, (.dmark+2)  
3712 32 bf fb			ld (debug_mark+2),a  
3715 18 03			jr .pastdmark  
3717 ..			.dmark: db "PLU"  
371a f1			.pastdmark: pop af  
371b			endm  
# End of macro DMARK
371b						CALLMONITOR 
371b cd 6a 16			call break_point_state  
371e				endm  
# End of macro CALLMONITOR
371e					endif 
371e					; add top two values and push back result 
371e			 
371e					;for v5 FORTH_DSP_VALUE 
371e					FORTH_DSP 
371e cd b4 1d			call macro_forth_dsp 
3721				endm 
# End of macro FORTH_DSP
3721 7e					ld a,(hl)	; get type of value on TOS 
3722 fe 02				cp DS_TYPE_INUM  
3724 28 03				jr z, .dot_inum 
3726			 
3726					NEXTW 
3726 c3 60 1f			jp macro_next 
3729				endm 
# End of macro NEXTW
3729			 
3729			; float maths 
3729			 
3729				if FORTH_ENABLE_FLOATMATH 
3729						inc hl      ; now at start of numeric as string 
3729			 
3729					if DEBUG_FORTH_MATHS 
3729						DMARK "ADD" 
3729				CALLMONITOR 
3729					endif 
3729			 
3729					;ld ix, hl 
3729					call CON 
3729			 
3729			 
3729					push hl 
3729					 
3729					 
3729			 
3729						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3729			 
3729					; get next number 
3729			 
3729						FORTH_DSP_VALUE 
3729			 
3729						inc hl      ; now at start of numeric as string 
3729			 
3729					;ld ix, hl 
3729					call CON 
3729			 
3729					push hl 
3729			 
3729			 
3729						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3729			 
3729						; TODO do add 
3729			 
3729						call IADD 
3729			 
3729						; TODO get result back as ascii 
3729			 
3729						; TODO push result  
3729			 
3729			 
3729			 
3729						jr .dot_done 
3729				endif 
3729			 
3729			.dot_inum: 
3729			 
3729			 
3729					if DEBUG_FORTH_DOT 
3729						DMARK "+IT" 
3729				CALLMONITOR 
3729					endif 
3729			 
3729					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3729 cd ee 1d			call macro_dsp_valuehl 
372c				endm 
# End of macro FORTH_DSP_VALUEHL
372c			 
372c				; TODO add floating point number detection 
372c			 
372c e5					push hl 
372d			 
372d					; destroy value TOS 
372d			 
372d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
372d cd a6 1e			call macro_forth_dsp_pop 
3730				endm 
# End of macro FORTH_DSP_POP
3730			 
3730			 
3730					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3730 cd ee 1d			call macro_dsp_valuehl 
3733				endm 
# End of macro FORTH_DSP_VALUEHL
3733			 
3733					; one value on hl get other one back 
3733			 
3733 d1					pop de 
3734			 
3734					; do the add 
3734			 
3734 19					add hl,de 
3735			 
3735					; save it 
3735			 
3735			;		push hl	 
3735			 
3735					; 
3735			 
3735					; destroy value TOS 
3735			 
3735					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3735 cd a6 1e			call macro_forth_dsp_pop 
3738				endm 
# End of macro FORTH_DSP_POP
3738			 
3738					; TODO push value back onto stack for another op etc 
3738			 
3738			;		pop hl 
3738			 
3738			.dot_done: 
3738 cd f7 1b				call forth_push_numhl 
373b			 
373b					NEXTW 
373b c3 60 1f			jp macro_next 
373e				endm 
# End of macro NEXTW
373e			.NEG: 
373e			 
373e				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
373e 17				db WORD_SYS_CORE+3             
373f 81 37			dw .DIV            
3741 02				db 1 + 1 
3742 .. 00			db "-",0              
3744				endm 
# End of macro CWHEAD
3744			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3744					if DEBUG_FORTH_WORDS_KEY 
3744						DMARK "SUB" 
3744 f5				push af  
3745 3a 59 37			ld a, (.dmark)  
3748 32 bd fb			ld (debug_mark),a  
374b 3a 5a 37			ld a, (.dmark+1)  
374e 32 be fb			ld (debug_mark+1),a  
3751 3a 5b 37			ld a, (.dmark+2)  
3754 32 bf fb			ld (debug_mark+2),a  
3757 18 03			jr .pastdmark  
3759 ..			.dmark: db "SUB"  
375c f1			.pastdmark: pop af  
375d			endm  
# End of macro DMARK
375d						CALLMONITOR 
375d cd 6a 16			call break_point_state  
3760				endm  
# End of macro CALLMONITOR
3760					endif 
3760			 
3760			 
3760				; TODO add floating point number detection 
3760					; v5 FORTH_DSP_VALUE 
3760					FORTH_DSP 
3760 cd b4 1d			call macro_forth_dsp 
3763				endm 
# End of macro FORTH_DSP
3763 7e					ld a,(hl)	; get type of value on TOS 
3764 fe 02				cp DS_TYPE_INUM  
3766 28 03				jr z, .neg_inum 
3768			 
3768					NEXTW 
3768 c3 60 1f			jp macro_next 
376b				endm 
# End of macro NEXTW
376b			 
376b			; float maths 
376b			 
376b				if FORTH_ENABLE_FLOATMATH 
376b					jr .neg_done 
376b			 
376b				endif 
376b					 
376b			 
376b			.neg_inum: 
376b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
376b cd ee 1d			call macro_dsp_valuehl 
376e				endm 
# End of macro FORTH_DSP_VALUEHL
376e			 
376e e5					push hl 
376f			 
376f					; destroy value TOS 
376f			 
376f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
376f cd a6 1e			call macro_forth_dsp_pop 
3772				endm 
# End of macro FORTH_DSP_POP
3772			 
3772			 
3772					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3772 cd ee 1d			call macro_dsp_valuehl 
3775				endm 
# End of macro FORTH_DSP_VALUEHL
3775			 
3775					; one value on hl get other one back 
3775			 
3775 d1					pop de 
3776			 
3776					; do the sub 
3776			;		ex de, hl 
3776			 
3776 ed 52				sbc hl,de 
3778			 
3778					; save it 
3778			 
3778			;		push hl	 
3778			 
3778					; 
3778			 
3778					; destroy value TOS 
3778			 
3778					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3778 cd a6 1e			call macro_forth_dsp_pop 
377b				endm 
# End of macro FORTH_DSP_POP
377b			 
377b					; TODO push value back onto stack for another op etc 
377b			 
377b			;		pop hl 
377b			 
377b cd f7 1b				call forth_push_numhl 
377e			.neg_done: 
377e			 
377e					NEXTW 
377e c3 60 1f			jp macro_next 
3781				endm 
# End of macro NEXTW
3781			.DIV: 
3781				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3781 18				db WORD_SYS_CORE+4             
3782 ce 37			dw .MUL            
3784 02				db 1 + 1 
3785 .. 00			db "/",0              
3787				endm 
# End of macro CWHEAD
3787			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3787					if DEBUG_FORTH_WORDS_KEY 
3787						DMARK "DIV" 
3787 f5				push af  
3788 3a 9c 37			ld a, (.dmark)  
378b 32 bd fb			ld (debug_mark),a  
378e 3a 9d 37			ld a, (.dmark+1)  
3791 32 be fb			ld (debug_mark+1),a  
3794 3a 9e 37			ld a, (.dmark+2)  
3797 32 bf fb			ld (debug_mark+2),a  
379a 18 03			jr .pastdmark  
379c ..			.dmark: db "DIV"  
379f f1			.pastdmark: pop af  
37a0			endm  
# End of macro DMARK
37a0						CALLMONITOR 
37a0 cd 6a 16			call break_point_state  
37a3				endm  
# End of macro CALLMONITOR
37a3					endif 
37a3				; TODO add floating point number detection 
37a3					; v5 FORTH_DSP_VALUE 
37a3					FORTH_DSP 
37a3 cd b4 1d			call macro_forth_dsp 
37a6				endm 
# End of macro FORTH_DSP
37a6 7e					ld a,(hl)	; get type of value on TOS 
37a7 fe 02				cp DS_TYPE_INUM  
37a9 28 03				jr z, .div_inum 
37ab			 
37ab				if FORTH_ENABLE_FLOATMATH 
37ab					jr .div_done 
37ab			 
37ab				endif 
37ab					NEXTW 
37ab c3 60 1f			jp macro_next 
37ae				endm 
# End of macro NEXTW
37ae			.div_inum: 
37ae			 
37ae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37ae cd ee 1d			call macro_dsp_valuehl 
37b1				endm 
# End of macro FORTH_DSP_VALUEHL
37b1			 
37b1 e5					push hl    ; to go to bc 
37b2			 
37b2					; destroy value TOS 
37b2			 
37b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37b2 cd a6 1e			call macro_forth_dsp_pop 
37b5				endm 
# End of macro FORTH_DSP_POP
37b5			 
37b5			 
37b5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37b5 cd ee 1d			call macro_dsp_valuehl 
37b8				endm 
# End of macro FORTH_DSP_VALUEHL
37b8			 
37b8					; hl to go to de 
37b8			 
37b8 e5					push hl 
37b9			 
37b9 c1					pop bc 
37ba d1					pop de		 
37bb			 
37bb			 
37bb					if DEBUG_FORTH_MATHS 
37bb						DMARK "DIV" 
37bb				CALLMONITOR 
37bb					endif 
37bb					; one value on hl but move to a get other one back 
37bb			 
37bb			        
37bb cd 63 0c			call Div16 
37be			 
37be			;	push af	 
37be e5				push hl 
37bf c5				push bc 
37c0			 
37c0					if DEBUG_FORTH_MATHS 
37c0						DMARK "DI1" 
37c0				CALLMONITOR 
37c0					endif 
37c0			 
37c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37c0 cd a6 1e			call macro_forth_dsp_pop 
37c3				endm 
# End of macro FORTH_DSP_POP
37c3			 
37c3			 
37c3			 
37c3 e1					pop hl    ; result 
37c4			 
37c4 cd f7 1b				call forth_push_numhl 
37c7			 
37c7 e1					pop hl    ; reminder 
37c8			;		ld h,0 
37c8			;		ld l,d 
37c8			 
37c8 cd f7 1b				call forth_push_numhl 
37cb			.div_done: 
37cb					NEXTW 
37cb c3 60 1f			jp macro_next 
37ce				endm 
# End of macro NEXTW
37ce			.MUL: 
37ce				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
37ce 19				db WORD_SYS_CORE+5             
37cf 13 38			dw .MIN            
37d1 02				db 1 + 1 
37d2 .. 00			db "*",0              
37d4				endm 
# End of macro CWHEAD
37d4			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
37d4				; TODO add floating point number detection 
37d4					if DEBUG_FORTH_WORDS_KEY 
37d4						DMARK "MUL" 
37d4 f5				push af  
37d5 3a e9 37			ld a, (.dmark)  
37d8 32 bd fb			ld (debug_mark),a  
37db 3a ea 37			ld a, (.dmark+1)  
37de 32 be fb			ld (debug_mark+1),a  
37e1 3a eb 37			ld a, (.dmark+2)  
37e4 32 bf fb			ld (debug_mark+2),a  
37e7 18 03			jr .pastdmark  
37e9 ..			.dmark: db "MUL"  
37ec f1			.pastdmark: pop af  
37ed			endm  
# End of macro DMARK
37ed						CALLMONITOR 
37ed cd 6a 16			call break_point_state  
37f0				endm  
# End of macro CALLMONITOR
37f0					endif 
37f0					FORTH_DSP 
37f0 cd b4 1d			call macro_forth_dsp 
37f3				endm 
# End of macro FORTH_DSP
37f3					; v5 FORTH_DSP_VALUE 
37f3 7e					ld a,(hl)	; get type of value on TOS 
37f4 fe 02				cp DS_TYPE_INUM  
37f6 28 03				jr z, .mul_inum 
37f8			 
37f8				if FORTH_ENABLE_FLOATMATH 
37f8					jr .mul_done 
37f8			 
37f8				endif 
37f8			 
37f8					NEXTW 
37f8 c3 60 1f			jp macro_next 
37fb				endm 
# End of macro NEXTW
37fb			.mul_inum:	 
37fb			 
37fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37fb cd ee 1d			call macro_dsp_valuehl 
37fe				endm 
# End of macro FORTH_DSP_VALUEHL
37fe			 
37fe e5					push hl 
37ff			 
37ff					; destroy value TOS 
37ff			 
37ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ff cd a6 1e			call macro_forth_dsp_pop 
3802				endm 
# End of macro FORTH_DSP_POP
3802			 
3802			 
3802					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3802 cd ee 1d			call macro_dsp_valuehl 
3805				endm 
# End of macro FORTH_DSP_VALUEHL
3805			 
3805					; one value on hl but move to a get other one back 
3805			 
3805 7d					ld a, l 
3806			 
3806 d1					pop de 
3807			 
3807					; do the mull 
3807			;		ex de, hl 
3807			 
3807 cd 89 0c				call Mult16 
380a					; save it 
380a			 
380a			;		push hl	 
380a			 
380a					; 
380a			 
380a					; destroy value TOS 
380a			 
380a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
380a cd a6 1e			call macro_forth_dsp_pop 
380d				endm 
# End of macro FORTH_DSP_POP
380d			 
380d					; TODO push value back onto stack for another op etc 
380d			 
380d			;		pop hl 
380d			 
380d cd f7 1b				call forth_push_numhl 
3810			 
3810			.mul_done: 
3810					NEXTW 
3810 c3 60 1f			jp macro_next 
3813				endm 
# End of macro NEXTW
3813			 
3813			 
3813			 
3813			 
3813			.MIN: 
3813				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3813 49				db WORD_SYS_CORE+53             
3814 94 38			dw .MAX            
3816 04				db 3 + 1 
3817 .. 00			db "MIN",0              
381b				endm 
# End of macro CWHEAD
381b			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
381b					if DEBUG_FORTH_WORDS_KEY 
381b						DMARK "MIN" 
381b f5				push af  
381c 3a 30 38			ld a, (.dmark)  
381f 32 bd fb			ld (debug_mark),a  
3822 3a 31 38			ld a, (.dmark+1)  
3825 32 be fb			ld (debug_mark+1),a  
3828 3a 32 38			ld a, (.dmark+2)  
382b 32 bf fb			ld (debug_mark+2),a  
382e 18 03			jr .pastdmark  
3830 ..			.dmark: db "MIN"  
3833 f1			.pastdmark: pop af  
3834			endm  
# End of macro DMARK
3834						CALLMONITOR 
3834 cd 6a 16			call break_point_state  
3837				endm  
# End of macro CALLMONITOR
3837					endif 
3837					; get u2 
3837			 
3837					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3837 cd ee 1d			call macro_dsp_valuehl 
383a				endm 
# End of macro FORTH_DSP_VALUEHL
383a			 
383a e5					push hl   ; u2 
383b			 
383b					; destroy value TOS 
383b			 
383b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
383b cd a6 1e			call macro_forth_dsp_pop 
383e				endm 
# End of macro FORTH_DSP_POP
383e			 
383e					; get u1 
383e			 
383e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
383e cd ee 1d			call macro_dsp_valuehl 
3841				endm 
# End of macro FORTH_DSP_VALUEHL
3841			 
3841 e5					push hl  ; u1 
3842			 
3842					; destroy value TOS 
3842			 
3842					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3842 cd a6 1e			call macro_forth_dsp_pop 
3845				endm 
# End of macro FORTH_DSP_POP
3845			 
3845 b7			 or a      ;clear carry flag 
3846 e1			  pop hl    ; u1 
3847 d1			  pop de    ; u2 
3848 e5				push hl   ; saved in case hl is lowest 
3849 ed 52		  sbc hl,de 
384b 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
384d			 
384d e1				pop hl 
384e					if DEBUG_FORTH_WORDS 
384e						DMARK "MIN" 
384e f5				push af  
384f 3a 63 38			ld a, (.dmark)  
3852 32 bd fb			ld (debug_mark),a  
3855 3a 64 38			ld a, (.dmark+1)  
3858 32 be fb			ld (debug_mark+1),a  
385b 3a 65 38			ld a, (.dmark+2)  
385e 32 bf fb			ld (debug_mark+2),a  
3861 18 03			jr .pastdmark  
3863 ..			.dmark: db "MIN"  
3866 f1			.pastdmark: pop af  
3867			endm  
# End of macro DMARK
3867						CALLMONITOR 
3867 cd 6a 16			call break_point_state  
386a				endm  
# End of macro CALLMONITOR
386a					endif 
386a cd f7 1b				call forth_push_numhl 
386d			 
386d				       NEXTW 
386d c3 60 1f			jp macro_next 
3870				endm 
# End of macro NEXTW
3870			 
3870			.mincont:  
3870 c1				pop bc   ; tidy up 
3871 eb				ex de , hl  
3872					if DEBUG_FORTH_WORDS 
3872						DMARK "MI1" 
3872 f5				push af  
3873 3a 87 38			ld a, (.dmark)  
3876 32 bd fb			ld (debug_mark),a  
3879 3a 88 38			ld a, (.dmark+1)  
387c 32 be fb			ld (debug_mark+1),a  
387f 3a 89 38			ld a, (.dmark+2)  
3882 32 bf fb			ld (debug_mark+2),a  
3885 18 03			jr .pastdmark  
3887 ..			.dmark: db "MI1"  
388a f1			.pastdmark: pop af  
388b			endm  
# End of macro DMARK
388b						CALLMONITOR 
388b cd 6a 16			call break_point_state  
388e				endm  
# End of macro CALLMONITOR
388e					endif 
388e cd f7 1b				call forth_push_numhl 
3891			 
3891				       NEXTW 
3891 c3 60 1f			jp macro_next 
3894				endm 
# End of macro NEXTW
3894			.MAX: 
3894				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3894 4a				db WORD_SYS_CORE+54             
3895 15 39			dw .RND16            
3897 04				db 3 + 1 
3898 .. 00			db "MAX",0              
389c				endm 
# End of macro CWHEAD
389c			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
389c					if DEBUG_FORTH_WORDS_KEY 
389c						DMARK "MAX" 
389c f5				push af  
389d 3a b1 38			ld a, (.dmark)  
38a0 32 bd fb			ld (debug_mark),a  
38a3 3a b2 38			ld a, (.dmark+1)  
38a6 32 be fb			ld (debug_mark+1),a  
38a9 3a b3 38			ld a, (.dmark+2)  
38ac 32 bf fb			ld (debug_mark+2),a  
38af 18 03			jr .pastdmark  
38b1 ..			.dmark: db "MAX"  
38b4 f1			.pastdmark: pop af  
38b5			endm  
# End of macro DMARK
38b5						CALLMONITOR 
38b5 cd 6a 16			call break_point_state  
38b8				endm  
# End of macro CALLMONITOR
38b8					endif 
38b8					; get u2 
38b8			 
38b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38b8 cd ee 1d			call macro_dsp_valuehl 
38bb				endm 
# End of macro FORTH_DSP_VALUEHL
38bb			 
38bb e5					push hl   ; u2 
38bc			 
38bc					; destroy value TOS 
38bc			 
38bc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38bc cd a6 1e			call macro_forth_dsp_pop 
38bf				endm 
# End of macro FORTH_DSP_POP
38bf			 
38bf					; get u1 
38bf			 
38bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38bf cd ee 1d			call macro_dsp_valuehl 
38c2				endm 
# End of macro FORTH_DSP_VALUEHL
38c2			 
38c2 e5					push hl  ; u1 
38c3			 
38c3					; destroy value TOS 
38c3			 
38c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38c3 cd a6 1e			call macro_forth_dsp_pop 
38c6				endm 
# End of macro FORTH_DSP_POP
38c6			 
38c6 b7			 or a      ;clear carry flag 
38c7 e1			  pop hl    ; u1 
38c8 d1			  pop de    ; u2 
38c9 e5				push hl   ; saved in case hl is lowest 
38ca ed 52		  sbc hl,de 
38cc 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
38ce			 
38ce e1				pop hl 
38cf					if DEBUG_FORTH_WORDS 
38cf						DMARK "MAX" 
38cf f5				push af  
38d0 3a e4 38			ld a, (.dmark)  
38d3 32 bd fb			ld (debug_mark),a  
38d6 3a e5 38			ld a, (.dmark+1)  
38d9 32 be fb			ld (debug_mark+1),a  
38dc 3a e6 38			ld a, (.dmark+2)  
38df 32 bf fb			ld (debug_mark+2),a  
38e2 18 03			jr .pastdmark  
38e4 ..			.dmark: db "MAX"  
38e7 f1			.pastdmark: pop af  
38e8			endm  
# End of macro DMARK
38e8						CALLMONITOR 
38e8 cd 6a 16			call break_point_state  
38eb				endm  
# End of macro CALLMONITOR
38eb					endif 
38eb cd f7 1b				call forth_push_numhl 
38ee			 
38ee				       NEXTW 
38ee c3 60 1f			jp macro_next 
38f1				endm 
# End of macro NEXTW
38f1			 
38f1			.maxcont:  
38f1 c1				pop bc   ; tidy up 
38f2 eb				ex de , hl  
38f3					if DEBUG_FORTH_WORDS 
38f3						DMARK "MA1" 
38f3 f5				push af  
38f4 3a 08 39			ld a, (.dmark)  
38f7 32 bd fb			ld (debug_mark),a  
38fa 3a 09 39			ld a, (.dmark+1)  
38fd 32 be fb			ld (debug_mark+1),a  
3900 3a 0a 39			ld a, (.dmark+2)  
3903 32 bf fb			ld (debug_mark+2),a  
3906 18 03			jr .pastdmark  
3908 ..			.dmark: db "MA1"  
390b f1			.pastdmark: pop af  
390c			endm  
# End of macro DMARK
390c						CALLMONITOR 
390c cd 6a 16			call break_point_state  
390f				endm  
# End of macro CALLMONITOR
390f					endif 
390f cd f7 1b				call forth_push_numhl 
3912				       NEXTW 
3912 c3 60 1f			jp macro_next 
3915				endm 
# End of macro NEXTW
3915			 
3915			.RND16: 
3915				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3915 4e				db WORD_SYS_CORE+58             
3916 44 39			dw .RND8            
3918 06				db 5 + 1 
3919 .. 00			db "RND16",0              
391f				endm 
# End of macro CWHEAD
391f			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
391f					if DEBUG_FORTH_WORDS_KEY 
391f						DMARK "R16" 
391f f5				push af  
3920 3a 34 39			ld a, (.dmark)  
3923 32 bd fb			ld (debug_mark),a  
3926 3a 35 39			ld a, (.dmark+1)  
3929 32 be fb			ld (debug_mark+1),a  
392c 3a 36 39			ld a, (.dmark+2)  
392f 32 bf fb			ld (debug_mark+2),a  
3932 18 03			jr .pastdmark  
3934 ..			.dmark: db "R16"  
3937 f1			.pastdmark: pop af  
3938			endm  
# End of macro DMARK
3938						CALLMONITOR 
3938 cd 6a 16			call break_point_state  
393b				endm  
# End of macro CALLMONITOR
393b					endif 
393b cd 2d 0c				call prng16  
393e cd f7 1b				call forth_push_numhl 
3941				       NEXTW 
3941 c3 60 1f			jp macro_next 
3944				endm 
# End of macro NEXTW
3944			.RND8: 
3944				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3944 60				db WORD_SYS_CORE+76             
3945 79 39			dw .RND            
3947 05				db 4 + 1 
3948 .. 00			db "RND8",0              
394d				endm 
# End of macro CWHEAD
394d			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
394d					if DEBUG_FORTH_WORDS_KEY 
394d						DMARK "RN8" 
394d f5				push af  
394e 3a 62 39			ld a, (.dmark)  
3951 32 bd fb			ld (debug_mark),a  
3954 3a 63 39			ld a, (.dmark+1)  
3957 32 be fb			ld (debug_mark+1),a  
395a 3a 64 39			ld a, (.dmark+2)  
395d 32 bf fb			ld (debug_mark+2),a  
3960 18 03			jr .pastdmark  
3962 ..			.dmark: db "RN8"  
3965 f1			.pastdmark: pop af  
3966			endm  
# End of macro DMARK
3966						CALLMONITOR 
3966 cd 6a 16			call break_point_state  
3969				endm  
# End of macro CALLMONITOR
3969					endif 
3969 2a 3e fa				ld hl,(xrandc) 
396c 23					inc hl 
396d cd 47 0c				call xrnd 
3970 6f					ld l,a	 
3971 26 00				ld h,0 
3973 cd f7 1b				call forth_push_numhl 
3976				       NEXTW 
3976 c3 60 1f			jp macro_next 
3979				endm 
# End of macro NEXTW
3979			.RND: 
3979				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3979 60				db WORD_SYS_CORE+76             
397a 7f 3a			dw .ENDMATHS            
397c 04				db 3 + 1 
397d .. 00			db "RND",0              
3981				endm 
# End of macro CWHEAD
3981			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3981			 
3981					if DEBUG_FORTH_WORDS_KEY 
3981						DMARK "RND" 
3981 f5				push af  
3982 3a 96 39			ld a, (.dmark)  
3985 32 bd fb			ld (debug_mark),a  
3988 3a 97 39			ld a, (.dmark+1)  
398b 32 be fb			ld (debug_mark+1),a  
398e 3a 98 39			ld a, (.dmark+2)  
3991 32 bf fb			ld (debug_mark+2),a  
3994 18 03			jr .pastdmark  
3996 ..			.dmark: db "RND"  
3999 f1			.pastdmark: pop af  
399a			endm  
# End of macro DMARK
399a						CALLMONITOR 
399a cd 6a 16			call break_point_state  
399d				endm  
# End of macro CALLMONITOR
399d					endif 
399d					 
399d					FORTH_DSP_VALUEHL    ; upper range 
399d cd ee 1d			call macro_dsp_valuehl 
39a0				endm 
# End of macro FORTH_DSP_VALUEHL
39a0			 
39a0 22 42 fa				ld (LFSRSeed), hl	 
39a3			 
39a3					if DEBUG_FORTH_WORDS 
39a3						DMARK "RN1" 
39a3 f5				push af  
39a4 3a b8 39			ld a, (.dmark)  
39a7 32 bd fb			ld (debug_mark),a  
39aa 3a b9 39			ld a, (.dmark+1)  
39ad 32 be fb			ld (debug_mark+1),a  
39b0 3a ba 39			ld a, (.dmark+2)  
39b3 32 bf fb			ld (debug_mark+2),a  
39b6 18 03			jr .pastdmark  
39b8 ..			.dmark: db "RN1"  
39bb f1			.pastdmark: pop af  
39bc			endm  
# End of macro DMARK
39bc						CALLMONITOR 
39bc cd 6a 16			call break_point_state  
39bf				endm  
# End of macro CALLMONITOR
39bf					endif 
39bf					FORTH_DSP_POP 
39bf cd a6 1e			call macro_forth_dsp_pop 
39c2				endm 
# End of macro FORTH_DSP_POP
39c2			 
39c2					FORTH_DSP_VALUEHL    ; low range 
39c2 cd ee 1d			call macro_dsp_valuehl 
39c5				endm 
# End of macro FORTH_DSP_VALUEHL
39c5			 
39c5					if DEBUG_FORTH_WORDS 
39c5						DMARK "RN2" 
39c5 f5				push af  
39c6 3a da 39			ld a, (.dmark)  
39c9 32 bd fb			ld (debug_mark),a  
39cc 3a db 39			ld a, (.dmark+1)  
39cf 32 be fb			ld (debug_mark+1),a  
39d2 3a dc 39			ld a, (.dmark+2)  
39d5 32 bf fb			ld (debug_mark+2),a  
39d8 18 03			jr .pastdmark  
39da ..			.dmark: db "RN2"  
39dd f1			.pastdmark: pop af  
39de			endm  
# End of macro DMARK
39de						CALLMONITOR 
39de cd 6a 16			call break_point_state  
39e1				endm  
# End of macro CALLMONITOR
39e1					endif 
39e1 22 44 fa				ld (LFSRSeed+2), hl 
39e4			 
39e4					FORTH_DSP_POP 
39e4 cd a6 1e			call macro_forth_dsp_pop 
39e7				endm 
# End of macro FORTH_DSP_POP
39e7			 
39e7 e5					push hl 
39e8			 
39e8 e1			.inrange:	pop hl 
39e9 cd 2d 0c				call prng16  
39ec					if DEBUG_FORTH_WORDS 
39ec						DMARK "RN3" 
39ec f5				push af  
39ed 3a 01 3a			ld a, (.dmark)  
39f0 32 bd fb			ld (debug_mark),a  
39f3 3a 02 3a			ld a, (.dmark+1)  
39f6 32 be fb			ld (debug_mark+1),a  
39f9 3a 03 3a			ld a, (.dmark+2)  
39fc 32 bf fb			ld (debug_mark+2),a  
39ff 18 03			jr .pastdmark  
3a01 ..			.dmark: db "RN3"  
3a04 f1			.pastdmark: pop af  
3a05			endm  
# End of macro DMARK
3a05						CALLMONITOR 
3a05 cd 6a 16			call break_point_state  
3a08				endm  
# End of macro CALLMONITOR
3a08					endif 
3a08					 
3a08					; if the range is 8bit knock out the high byte 
3a08			 
3a08 ed 5b 42 fa			ld de, (LFSRSeed)     ; check high level 
3a0c			 
3a0c 3e 00				ld a, 0 
3a0e ba					cp d  
3a0f 20 1e				jr nz, .hirange 
3a11 26 00				ld h, 0   ; knock it down to 8bit 
3a13			 
3a13					if DEBUG_FORTH_WORDS 
3a13						DMARK "RNk" 
3a13 f5				push af  
3a14 3a 28 3a			ld a, (.dmark)  
3a17 32 bd fb			ld (debug_mark),a  
3a1a 3a 29 3a			ld a, (.dmark+1)  
3a1d 32 be fb			ld (debug_mark+1),a  
3a20 3a 2a 3a			ld a, (.dmark+2)  
3a23 32 bf fb			ld (debug_mark+2),a  
3a26 18 03			jr .pastdmark  
3a28 ..			.dmark: db "RNk"  
3a2b f1			.pastdmark: pop af  
3a2c			endm  
# End of macro DMARK
3a2c						CALLMONITOR 
3a2c cd 6a 16			call break_point_state  
3a2f				endm  
# End of macro CALLMONITOR
3a2f					endif 
3a2f			.hirange:   
3a2f e5					push hl  
3a30 b7					or a  
3a31 ed 52		                sbc hl, de 
3a33			 
3a33					;call cmp16 
3a33			 
3a33 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3a35 e1					pop hl 
3a36 e5					push hl 
3a37			 
3a37					if DEBUG_FORTH_WORDS 
3a37						DMARK "RN4" 
3a37 f5				push af  
3a38 3a 4c 3a			ld a, (.dmark)  
3a3b 32 bd fb			ld (debug_mark),a  
3a3e 3a 4d 3a			ld a, (.dmark+1)  
3a41 32 be fb			ld (debug_mark+1),a  
3a44 3a 4e 3a			ld a, (.dmark+2)  
3a47 32 bf fb			ld (debug_mark+2),a  
3a4a 18 03			jr .pastdmark  
3a4c ..			.dmark: db "RN4"  
3a4f f1			.pastdmark: pop af  
3a50			endm  
# End of macro DMARK
3a50						CALLMONITOR 
3a50 cd 6a 16			call break_point_state  
3a53				endm  
# End of macro CALLMONITOR
3a53					endif 
3a53 ed 5b 44 fa			ld de, (LFSRSeed+2)   ; check low range 
3a57					;call cmp16 
3a57				 
3a57 b7					or a  
3a58 ed 52		                sbc hl, de 
3a5a 38 8c				jr c, .inrange 
3a5c			 
3a5c e1					pop hl 
3a5d					 
3a5d					if DEBUG_FORTH_WORDS 
3a5d						DMARK "RNd" 
3a5d f5				push af  
3a5e 3a 72 3a			ld a, (.dmark)  
3a61 32 bd fb			ld (debug_mark),a  
3a64 3a 73 3a			ld a, (.dmark+1)  
3a67 32 be fb			ld (debug_mark+1),a  
3a6a 3a 74 3a			ld a, (.dmark+2)  
3a6d 32 bf fb			ld (debug_mark+2),a  
3a70 18 03			jr .pastdmark  
3a72 ..			.dmark: db "RNd"  
3a75 f1			.pastdmark: pop af  
3a76			endm  
# End of macro DMARK
3a76						CALLMONITOR 
3a76 cd 6a 16			call break_point_state  
3a79				endm  
# End of macro CALLMONITOR
3a79					endif 
3a79			 
3a79			 
3a79 cd f7 1b				call forth_push_numhl 
3a7c				       NEXTW 
3a7c c3 60 1f			jp macro_next 
3a7f				endm 
# End of macro NEXTW
3a7f			 
3a7f			.ENDMATHS: 
3a7f			 
3a7f			; eof 
3a7f			 
# End of file forth_words_maths.asm
3a7f			include "forth_words_display.asm" 
3a7f			 
3a7f			; | ## Display Words 
3a7f			 
3a7f			.ATP: 
3a7f				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a7f 62				db WORD_SYS_CORE+78             
3a80 f6 3a			dw .FB            
3a82 04				db 3 + 1 
3a83 .. 00			db "AT?",0              
3a87				endm 
# End of macro CWHEAD
3a87			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a87					if DEBUG_FORTH_WORDS_KEY 
3a87						DMARK "AT?" 
3a87 f5				push af  
3a88 3a 9c 3a			ld a, (.dmark)  
3a8b 32 bd fb			ld (debug_mark),a  
3a8e 3a 9d 3a			ld a, (.dmark+1)  
3a91 32 be fb			ld (debug_mark+1),a  
3a94 3a 9e 3a			ld a, (.dmark+2)  
3a97 32 bf fb			ld (debug_mark+2),a  
3a9a 18 03			jr .pastdmark  
3a9c ..			.dmark: db "AT?"  
3a9f f1			.pastdmark: pop af  
3aa0			endm  
# End of macro DMARK
3aa0						CALLMONITOR 
3aa0 cd 6a 16			call break_point_state  
3aa3				endm  
# End of macro CALLMONITOR
3aa3					endif 
3aa3 3a cc f9				ld a, (f_cursor_ptr) 
3aa6			 
3aa6			if DEBUG_FORTH_WORDS 
3aa6				DMARK "AT?" 
3aa6 f5				push af  
3aa7 3a bb 3a			ld a, (.dmark)  
3aaa 32 bd fb			ld (debug_mark),a  
3aad 3a bc 3a			ld a, (.dmark+1)  
3ab0 32 be fb			ld (debug_mark+1),a  
3ab3 3a bd 3a			ld a, (.dmark+2)  
3ab6 32 bf fb			ld (debug_mark+2),a  
3ab9 18 03			jr .pastdmark  
3abb ..			.dmark: db "AT?"  
3abe f1			.pastdmark: pop af  
3abf			endm  
# End of macro DMARK
3abf				CALLMONITOR 
3abf cd 6a 16			call break_point_state  
3ac2				endm  
# End of macro CALLMONITOR
3ac2			endif	 
3ac2					; count the number of rows 
3ac2			 
3ac2 06 00				ld b, 0 
3ac4 4f			.atpr:		ld c, a    ; save in case we go below zero 
3ac5 d6 14				sub display_cols 
3ac7 f2 cd 3a				jp p, .atprunder 
3aca 04					inc b 
3acb 18 f7				jr .atpr 
3acd			.atprunder:	 
3acd			if DEBUG_FORTH_WORDS 
3acd				DMARK "A?2" 
3acd f5				push af  
3ace 3a e2 3a			ld a, (.dmark)  
3ad1 32 bd fb			ld (debug_mark),a  
3ad4 3a e3 3a			ld a, (.dmark+1)  
3ad7 32 be fb			ld (debug_mark+1),a  
3ada 3a e4 3a			ld a, (.dmark+2)  
3add 32 bf fb			ld (debug_mark+2),a  
3ae0 18 03			jr .pastdmark  
3ae2 ..			.dmark: db "A?2"  
3ae5 f1			.pastdmark: pop af  
3ae6			endm  
# End of macro DMARK
3ae6				CALLMONITOR 
3ae6 cd 6a 16			call break_point_state  
3ae9				endm  
# End of macro CALLMONITOR
3ae9			endif	 
3ae9 26 00				ld h, 0 
3aeb 69					ld l, c 
3aec cd f7 1b				call forth_push_numhl 
3aef 68					ld l, b  
3af0 cd f7 1b				call forth_push_numhl 
3af3			 
3af3			 
3af3				NEXTW 
3af3 c3 60 1f			jp macro_next 
3af6				endm 
# End of macro NEXTW
3af6			 
3af6			.FB: 
3af6				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3af6 1b				db WORD_SYS_CORE+7             
3af7 44 3b			dw .EMIT            
3af9 03				db 2 + 1 
3afa .. 00			db "FB",0              
3afd				endm 
# End of macro CWHEAD
3afd			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3afd			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3afd			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3afd			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3afd					if DEBUG_FORTH_WORDS_KEY 
3afd						DMARK "FB." 
3afd f5				push af  
3afe 3a 12 3b			ld a, (.dmark)  
3b01 32 bd fb			ld (debug_mark),a  
3b04 3a 13 3b			ld a, (.dmark+1)  
3b07 32 be fb			ld (debug_mark+1),a  
3b0a 3a 14 3b			ld a, (.dmark+2)  
3b0d 32 bf fb			ld (debug_mark+2),a  
3b10 18 03			jr .pastdmark  
3b12 ..			.dmark: db "FB."  
3b15 f1			.pastdmark: pop af  
3b16			endm  
# End of macro DMARK
3b16						CALLMONITOR 
3b16 cd 6a 16			call break_point_state  
3b19				endm  
# End of macro CALLMONITOR
3b19					endif 
3b19			 
3b19					FORTH_DSP_VALUEHL 
3b19 cd ee 1d			call macro_dsp_valuehl 
3b1c				endm 
# End of macro FORTH_DSP_VALUEHL
3b1c			 
3b1c 7d					ld a, l 
3b1d fe 01				cp 1 
3b1f 20 05				jr nz, .fbn1 
3b21 21 02 fb				ld hl, display_fb1 
3b24 18 15				jr .fbset 
3b26 fe 02		.fbn1:		cp 2 
3b28 20 05				jr nz, .fbn2 
3b2a 21 60 fa				ld hl, display_fb2 
3b2d 18 0c				jr .fbset 
3b2f fe 03		.fbn2:		cp 3 
3b31 20 05				jr nz, .fbn3 
3b33 21 b1 fa				ld hl, display_fb3 
3b36 18 03				jr .fbset 
3b38			.fbn3:		 ; if invalid number select first 
3b38 21 02 fb				ld hl, display_fb1 
3b3b 22 5e fa		.fbset:		ld (display_fb_active), hl 
3b3e			 
3b3e					FORTH_DSP_POP 
3b3e cd a6 1e			call macro_forth_dsp_pop 
3b41				endm 
# End of macro FORTH_DSP_POP
3b41			 
3b41					NEXTW 
3b41 c3 60 1f			jp macro_next 
3b44				endm 
# End of macro NEXTW
3b44			 
3b44			 
3b44			.EMIT: 
3b44				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b44 1b				db WORD_SYS_CORE+7             
3b45 95 3b			dw .DOTH            
3b47 05				db 4 + 1 
3b48 .. 00			db "EMIT",0              
3b4d				endm 
# End of macro CWHEAD
3b4d			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b4d					; get value off TOS and display it 
3b4d			 
3b4d					if DEBUG_FORTH_WORDS_KEY 
3b4d						DMARK "EMT" 
3b4d f5				push af  
3b4e 3a 62 3b			ld a, (.dmark)  
3b51 32 bd fb			ld (debug_mark),a  
3b54 3a 63 3b			ld a, (.dmark+1)  
3b57 32 be fb			ld (debug_mark+1),a  
3b5a 3a 64 3b			ld a, (.dmark+2)  
3b5d 32 bf fb			ld (debug_mark+2),a  
3b60 18 03			jr .pastdmark  
3b62 ..			.dmark: db "EMT"  
3b65 f1			.pastdmark: pop af  
3b66			endm  
# End of macro DMARK
3b66						CALLMONITOR 
3b66 cd 6a 16			call break_point_state  
3b69				endm  
# End of macro CALLMONITOR
3b69					endif 
3b69			 
3b69					FORTH_DSP_VALUEHL 
3b69 cd ee 1d			call macro_dsp_valuehl 
3b6c				endm 
# End of macro FORTH_DSP_VALUEHL
3b6c			 
3b6c 7d					ld a,l 
3b6d			 
3b6d					; TODO write to display 
3b6d			 
3b6d 32 a1 f1				ld (os_input), a 
3b70 3e 00				ld a, 0 
3b72 32 a2 f1				ld (os_input+1), a 
3b75					 
3b75 3a cc f9				ld a, (f_cursor_ptr) 
3b78 11 a1 f1				ld de, os_input 
3b7b cd e5 0a				call str_at_display 
3b7e			 
3b7e			 
3b7e 3a aa f9				ld a,(cli_autodisplay) 
3b81 fe 00				cp 0 
3b83 28 03				jr z, .enoupdate 
3b85 cd f5 0a						call update_display 
3b88					.enoupdate: 
3b88			 
3b88 3a cc f9				ld a, (f_cursor_ptr) 
3b8b 3c					inc a 
3b8c 32 cc f9				ld (f_cursor_ptr), a   ; save new pos 
3b8f			 
3b8f			 
3b8f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b8f cd a6 1e			call macro_forth_dsp_pop 
3b92				endm 
# End of macro FORTH_DSP_POP
3b92			  
3b92			 
3b92					NEXTW 
3b92 c3 60 1f			jp macro_next 
3b95				endm 
# End of macro NEXTW
3b95			.DOTH: 
3b95				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b95 1c				db WORD_SYS_CORE+8             
3b96 c5 3b			dw .DOTF            
3b98 03				db 2 + 1 
3b99 .. 00			db ".-",0              
3b9c				endm 
# End of macro CWHEAD
3b9c			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b9c					; get value off TOS and display it 
3b9c					if DEBUG_FORTH_WORDS_KEY 
3b9c						DMARK "DTD" 
3b9c f5				push af  
3b9d 3a b1 3b			ld a, (.dmark)  
3ba0 32 bd fb			ld (debug_mark),a  
3ba3 3a b2 3b			ld a, (.dmark+1)  
3ba6 32 be fb			ld (debug_mark+1),a  
3ba9 3a b3 3b			ld a, (.dmark+2)  
3bac 32 bf fb			ld (debug_mark+2),a  
3baf 18 03			jr .pastdmark  
3bb1 ..			.dmark: db "DTD"  
3bb4 f1			.pastdmark: pop af  
3bb5			endm  
# End of macro DMARK
3bb5						CALLMONITOR 
3bb5 cd 6a 16			call break_point_state  
3bb8				endm  
# End of macro CALLMONITOR
3bb8					endif 
3bb8 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3bba 3e 00			ld a, 0 
3bbc 32 ab f9			ld (cli_mvdot), a 
3bbf c3 1c 3c			jp .dotgo 
3bc2				NEXTW 
3bc2 c3 60 1f			jp macro_next 
3bc5				endm 
# End of macro NEXTW
3bc5			.DOTF: 
3bc5				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3bc5 1c				db WORD_SYS_CORE+8             
3bc6 f3 3b			dw .DOT            
3bc8 03				db 2 + 1 
3bc9 .. 00			db ".>",0              
3bcc				endm 
# End of macro CWHEAD
3bcc			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3bcc					; get value off TOS and display it 
3bcc			        ; TODO BUG adds extra spaces 
3bcc			        ; TODO BUG handle numerics? 
3bcc					if DEBUG_FORTH_WORDS_KEY 
3bcc						DMARK "DTC" 
3bcc f5				push af  
3bcd 3a e1 3b			ld a, (.dmark)  
3bd0 32 bd fb			ld (debug_mark),a  
3bd3 3a e2 3b			ld a, (.dmark+1)  
3bd6 32 be fb			ld (debug_mark+1),a  
3bd9 3a e3 3b			ld a, (.dmark+2)  
3bdc 32 bf fb			ld (debug_mark+2),a  
3bdf 18 03			jr .pastdmark  
3be1 ..			.dmark: db "DTC"  
3be4 f1			.pastdmark: pop af  
3be5			endm  
# End of macro DMARK
3be5						CALLMONITOR 
3be5 cd 6a 16			call break_point_state  
3be8				endm  
# End of macro CALLMONITOR
3be8					endif 
3be8 3e 01			ld a, 1 
3bea 32 ab f9			ld (cli_mvdot), a 
3bed c3 1c 3c			jp .dotgo 
3bf0				NEXTW 
3bf0 c3 60 1f			jp macro_next 
3bf3				endm 
# End of macro NEXTW
3bf3			 
3bf3			.DOT: 
3bf3				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3bf3 1c				db WORD_SYS_CORE+8             
3bf4 7f 3c			dw .CLS            
3bf6 02				db 1 + 1 
3bf7 .. 00			db ".",0              
3bf9				endm 
# End of macro CWHEAD
3bf9			        ; | . ( u -- ) Display TOS | DONE 
3bf9					; get value off TOS and display it 
3bf9			 
3bf9					if DEBUG_FORTH_WORDS_KEY 
3bf9						DMARK "DOT" 
3bf9 f5				push af  
3bfa 3a 0e 3c			ld a, (.dmark)  
3bfd 32 bd fb			ld (debug_mark),a  
3c00 3a 0f 3c			ld a, (.dmark+1)  
3c03 32 be fb			ld (debug_mark+1),a  
3c06 3a 10 3c			ld a, (.dmark+2)  
3c09 32 bf fb			ld (debug_mark+2),a  
3c0c 18 03			jr .pastdmark  
3c0e ..			.dmark: db "DOT"  
3c11 f1			.pastdmark: pop af  
3c12			endm  
# End of macro DMARK
3c12						CALLMONITOR 
3c12 cd 6a 16			call break_point_state  
3c15				endm  
# End of macro CALLMONITOR
3c15					endif 
3c15 3e 00			ld a, 0 
3c17 32 ab f9			ld (cli_mvdot), a 
3c1a 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3c1c				 
3c1c			 
3c1c			.dotgo: 
3c1c			 
3c1c			; move up type to on stack for parserv5 
3c1c					FORTH_DSP 
3c1c cd b4 1d			call macro_forth_dsp 
3c1f				endm 
# End of macro FORTH_DSP
3c1f				;FORTH_DSP_VALUE  
3c1f			 
3c1f			if DEBUG_FORTH_DOT 
3c1f				DMARK "DOT" 
3c1f				CALLMONITOR 
3c1f			endif	 
3c1f			;		.print: 
3c1f			 
3c1f 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3c20 23				inc hl   ; position to the actual value 
3c21 fe 01			cp DS_TYPE_STR 
3c23 20 06			jr nz, .dotnum1  
3c25			 
3c25			; display string 
3c25				FORTH_DSP_VALUE  
3c25 cd d7 1d			call macro_forth_dsp_value 
3c28				endm 
# End of macro FORTH_DSP_VALUE
3c28 eb				ex de,hl 
3c29 18 11			jr .dotwrite 
3c2b			 
3c2b			.dotnum1: 
3c2b fe 02			cp DS_TYPE_INUM 
3c2d 20 0c			jr nz, .dotflot 
3c2f			 
3c2f			 
3c2f			; display number 
3c2f			 
3c2f			;	push hl 
3c2f			;	call clear_display 
3c2f			;	pop hl 
3c2f			 
3c2f 5e				ld e, (hl) 
3c30 23				inc hl 
3c31 56				ld d, (hl) 
3c32 21 a3 ef			ld hl, scratch 
3c35			if DEBUG_FORTH_DOT 
3c35				DMARK "DT1" 
3c35				CALLMONITOR 
3c35			endif	 
3c35			 
3c35 cd 13 11			call uitoa_16 
3c38 eb				ex de,hl 
3c39			 
3c39			if DEBUG_FORTH_DOT 
3c39				DMARK "DT2" 
3c39				CALLMONITOR 
3c39			endif	 
3c39			 
3c39			;	ld de, os_word_scratch 
3c39 18 01			jr .dotwrite 
3c3b			 
3c3b 00			.dotflot:   nop 
3c3c			; TODO print floating point number 
3c3c			 
3c3c			.dotwrite:		 
3c3c			 
3c3c					; if c is set then set all '-' to spaces 
3c3c					; need to also take into account .>  
3c3c			 
3c3c 3e 01				ld a, 1 
3c3e b9					cp c 
3c3f 20 13				jr nz, .nodashswap 
3c41			 
3c41					; DE has the string to write, working with HL 
3c41			 
3c41 06 ff				ld b, 255 
3c43 d5					push de 
3c44 e1					pop hl 
3c45			 
3c45			if DEBUG_FORTH_DOT 
3c45				DMARK "DT-" 
3c45				CALLMONITOR 
3c45			endif	 
3c45 7e			.dashscan:	ld a, (hl) 
3c46 fe 00				cp 0 
3c48 28 0a				jr z, .nodashswap 
3c4a fe 2d				cp '-' 
3c4c 20 03				jr nz, .dashskip 
3c4e 3e 20				ld a, ' ' 
3c50 77					ld (hl), a 
3c51 23			.dashskip:	inc hl 
3c52			if DEBUG_FORTH_DOT 
3c52				DMARK "D-2" 
3c52				CALLMONITOR 
3c52			endif	 
3c52 10 f1				djnz .dashscan 
3c54			 
3c54			if DEBUG_FORTH_DOT 
3c54				DMARK "D-1" 
3c54				CALLMONITOR 
3c54			endif	 
3c54			 
3c54			.nodashswap: 
3c54			 
3c54 e5					push hl   ; save string start in case we need to advance print 
3c55			 
3c55 3a cc f9				ld a, (f_cursor_ptr) 
3c58 cd e5 0a				call str_at_display 
3c5b 3a aa f9				ld a,(cli_autodisplay) 
3c5e fe 00				cp 0 
3c60 28 03				jr z, .noupdate 
3c62 cd f5 0a						call update_display 
3c65					.noupdate: 
3c65			 
3c65			 
3c65					; see if we need to advance the print position 
3c65			 
3c65 e1					pop hl   ; get back string 
3c66			 
3c66 3a ab f9				ld a, (cli_mvdot) 
3c69			if DEBUG_FORTH_DOT 
3c69					ld e,a 
3c69				DMARK "D>1" 
3c69				CALLMONITOR 
3c69			endif	 
3c69 fe 00				cp 0 
3c6b 28 0c				jr z, .noadv 
3c6d					; yes, lets advance the print position 
3c6d 3e 00				ld a, 0 
3c6f cd 6f 11				call strlent 
3c72 3a cc f9				ld a, (f_cursor_ptr) 
3c75 85					add a,l 
3c76					;call addatohl 
3c76					;ld a, l 
3c76 32 cc f9				ld (f_cursor_ptr), a   ; save new pos 
3c79			 
3c79			if DEBUG_FORTH_DOT 
3c79				DMARK "D->" 
3c79				CALLMONITOR 
3c79			endif	 
3c79			 
3c79			.noadv:	 
3c79			 
3c79					if DEBUG_FORTH_DOT_WAIT 
3c79							call next_page_prompt 
3c79					endif	 
3c79			; TODO this pop off the stack causes a crash. i dont know why 
3c79			 
3c79			 
3c79			if DEBUG_FORTH_DOT 
3c79				DMARK "DTh" 
3c79				CALLMONITOR 
3c79			endif	 
3c79			 
3c79					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c79 cd a6 1e			call macro_forth_dsp_pop 
3c7c				endm 
# End of macro FORTH_DSP_POP
3c7c			 
3c7c			if DEBUG_FORTH_DOT 
3c7c				DMARK "DTi" 
3c7c				CALLMONITOR 
3c7c			endif	 
3c7c			 
3c7c			 
3c7c					NEXTW 
3c7c c3 60 1f			jp macro_next 
3c7f				endm 
# End of macro NEXTW
3c7f			 
3c7f			.CLS: 
3c7f				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3c7f 35				db WORD_SYS_CORE+33             
3c80 ac 3c			dw .DRAW            
3c82 04				db 3 + 1 
3c83 .. 00			db "CLS",0              
3c87				endm 
# End of macro CWHEAD
3c87			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3c87					if DEBUG_FORTH_WORDS_KEY 
3c87						DMARK "CLS" 
3c87 f5				push af  
3c88 3a 9c 3c			ld a, (.dmark)  
3c8b 32 bd fb			ld (debug_mark),a  
3c8e 3a 9d 3c			ld a, (.dmark+1)  
3c91 32 be fb			ld (debug_mark+1),a  
3c94 3a 9e 3c			ld a, (.dmark+2)  
3c97 32 bf fb			ld (debug_mark+2),a  
3c9a 18 03			jr .pastdmark  
3c9c ..			.dmark: db "CLS"  
3c9f f1			.pastdmark: pop af  
3ca0			endm  
# End of macro DMARK
3ca0						CALLMONITOR 
3ca0 cd 6a 16			call break_point_state  
3ca3				endm  
# End of macro CALLMONITOR
3ca3					endif 
3ca3 cd d2 0a				call clear_display 
3ca6 c3 ba 3d				jp .home		; and home cursor 
3ca9					NEXTW 
3ca9 c3 60 1f			jp macro_next 
3cac				endm 
# End of macro NEXTW
3cac			 
3cac			.DRAW: 
3cac				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3cac 36				db WORD_SYS_CORE+34             
3cad d7 3c			dw .DUMP            
3caf 05				db 4 + 1 
3cb0 .. 00			db "DRAW",0              
3cb5				endm 
# End of macro CWHEAD
3cb5			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3cb5					if DEBUG_FORTH_WORDS_KEY 
3cb5						DMARK "DRW" 
3cb5 f5				push af  
3cb6 3a ca 3c			ld a, (.dmark)  
3cb9 32 bd fb			ld (debug_mark),a  
3cbc 3a cb 3c			ld a, (.dmark+1)  
3cbf 32 be fb			ld (debug_mark+1),a  
3cc2 3a cc 3c			ld a, (.dmark+2)  
3cc5 32 bf fb			ld (debug_mark+2),a  
3cc8 18 03			jr .pastdmark  
3cca ..			.dmark: db "DRW"  
3ccd f1			.pastdmark: pop af  
3cce			endm  
# End of macro DMARK
3cce						CALLMONITOR 
3cce cd 6a 16			call break_point_state  
3cd1				endm  
# End of macro CALLMONITOR
3cd1					endif 
3cd1 cd f5 0a				call update_display 
3cd4					NEXTW 
3cd4 c3 60 1f			jp macro_next 
3cd7				endm 
# End of macro NEXTW
3cd7			 
3cd7			.DUMP: 
3cd7				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3cd7 37				db WORD_SYS_CORE+35             
3cd8 0f 3d			dw .CDUMP            
3cda 05				db 4 + 1 
3cdb .. 00			db "DUMP",0              
3ce0				endm 
# End of macro CWHEAD
3ce0			; | DUMP ( x -- ) With address x display dump   | DONE 
3ce0			; TODO pop address to use off of the stack 
3ce0					if DEBUG_FORTH_WORDS_KEY 
3ce0						DMARK "DUM" 
3ce0 f5				push af  
3ce1 3a f5 3c			ld a, (.dmark)  
3ce4 32 bd fb			ld (debug_mark),a  
3ce7 3a f6 3c			ld a, (.dmark+1)  
3cea 32 be fb			ld (debug_mark+1),a  
3ced 3a f7 3c			ld a, (.dmark+2)  
3cf0 32 bf fb			ld (debug_mark+2),a  
3cf3 18 03			jr .pastdmark  
3cf5 ..			.dmark: db "DUM"  
3cf8 f1			.pastdmark: pop af  
3cf9			endm  
# End of macro DMARK
3cf9						CALLMONITOR 
3cf9 cd 6a 16			call break_point_state  
3cfc				endm  
# End of macro CALLMONITOR
3cfc					endif 
3cfc cd d2 0a				call clear_display 
3cff			 
3cff					; get address 
3cff			 
3cff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cff cd ee 1d			call macro_dsp_valuehl 
3d02				endm 
# End of macro FORTH_DSP_VALUEHL
3d02				 
3d02					; save it for cdump 
3d02			 
3d02 22 c6 f2				ld (os_cur_ptr),hl 
3d05			 
3d05					; destroy value TOS 
3d05			 
3d05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d05 cd a6 1e			call macro_forth_dsp_pop 
3d08				endm 
# End of macro FORTH_DSP_POP
3d08			 
3d08 cd 77 1a				call dumpcont	; skip old style of param parsing	 
3d0b c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3d0c					NEXTW 
3d0c c3 60 1f			jp macro_next 
3d0f				endm 
# End of macro NEXTW
3d0f			.CDUMP: 
3d0f				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3d0f 38				db WORD_SYS_CORE+36             
3d10 3f 3d			dw .DAT            
3d12 06				db 5 + 1 
3d13 .. 00			db "CDUMP",0              
3d19				endm 
# End of macro CWHEAD
3d19			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3d19					if DEBUG_FORTH_WORDS_KEY 
3d19						DMARK "CDP" 
3d19 f5				push af  
3d1a 3a 2e 3d			ld a, (.dmark)  
3d1d 32 bd fb			ld (debug_mark),a  
3d20 3a 2f 3d			ld a, (.dmark+1)  
3d23 32 be fb			ld (debug_mark+1),a  
3d26 3a 30 3d			ld a, (.dmark+2)  
3d29 32 bf fb			ld (debug_mark+2),a  
3d2c 18 03			jr .pastdmark  
3d2e ..			.dmark: db "CDP"  
3d31 f1			.pastdmark: pop af  
3d32			endm  
# End of macro DMARK
3d32						CALLMONITOR 
3d32 cd 6a 16			call break_point_state  
3d35				endm  
# End of macro CALLMONITOR
3d35					endif 
3d35 cd d2 0a				call clear_display 
3d38 cd 77 1a				call dumpcont	 
3d3b c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3d3c					NEXTW 
3d3c c3 60 1f			jp macro_next 
3d3f				endm 
# End of macro NEXTW
3d3f			 
3d3f			 
3d3f			 
3d3f			 
3d3f			.DAT: 
3d3f				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3d3f 3d				db WORD_SYS_CORE+41             
3d40 95 3d			dw .HOME            
3d42 03				db 2 + 1 
3d43 .. 00			db "AT",0              
3d46				endm 
# End of macro CWHEAD
3d46			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3d46					if DEBUG_FORTH_WORDS_KEY 
3d46						DMARK "AT." 
3d46 f5				push af  
3d47 3a 5b 3d			ld a, (.dmark)  
3d4a 32 bd fb			ld (debug_mark),a  
3d4d 3a 5c 3d			ld a, (.dmark+1)  
3d50 32 be fb			ld (debug_mark+1),a  
3d53 3a 5d 3d			ld a, (.dmark+2)  
3d56 32 bf fb			ld (debug_mark+2),a  
3d59 18 03			jr .pastdmark  
3d5b ..			.dmark: db "AT."  
3d5e f1			.pastdmark: pop af  
3d5f			endm  
# End of macro DMARK
3d5f						CALLMONITOR 
3d5f cd 6a 16			call break_point_state  
3d62				endm  
# End of macro CALLMONITOR
3d62					endif 
3d62					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d62 cd ee 1d			call macro_dsp_valuehl 
3d65				endm 
# End of macro FORTH_DSP_VALUEHL
3d65			 
3d65			 
3d65					; TODO save cursor row 
3d65 7d					ld a,l 
3d66 fe 02				cp 2 
3d68 20 04				jr nz, .crow3 
3d6a 3e 14				ld a, display_row_2 
3d6c 18 12				jr .ccol1 
3d6e fe 03		.crow3:		cp 3 
3d70 20 04				jr nz, .crow4 
3d72 3e 28				ld a, display_row_3 
3d74 18 0a				jr .ccol1 
3d76 fe 04		.crow4:		cp 4 
3d78 20 04				jr nz, .crow1 
3d7a 3e 3c				ld a, display_row_4 
3d7c 18 02				jr .ccol1 
3d7e 3e 00		.crow1:		ld a,display_row_1 
3d80 f5			.ccol1:		push af			; got row offset 
3d81 6f					ld l,a 
3d82 26 00				ld h,0 
3d84					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d84 cd a6 1e			call macro_forth_dsp_pop 
3d87				endm 
# End of macro FORTH_DSP_POP
3d87					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d87 cd ee 1d			call macro_dsp_valuehl 
3d8a				endm 
# End of macro FORTH_DSP_VALUEHL
3d8a					; TODO save cursor col 
3d8a f1					pop af 
3d8b 85					add l		; add col offset 
3d8c 32 cc f9				ld (f_cursor_ptr), a 
3d8f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d8f cd a6 1e			call macro_forth_dsp_pop 
3d92				endm 
# End of macro FORTH_DSP_POP
3d92			 
3d92					; calculate  
3d92			 
3d92					NEXTW 
3d92 c3 60 1f			jp macro_next 
3d95				endm 
# End of macro NEXTW
3d95			 
3d95			 
3d95			.HOME: 
3d95				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3d95 41				db WORD_SYS_CORE+45             
3d96 c2 3d			dw .SPACE            
3d98 05				db 4 + 1 
3d99 .. 00			db "HOME",0              
3d9e				endm 
# End of macro CWHEAD
3d9e			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3d9e					if DEBUG_FORTH_WORDS_KEY 
3d9e						DMARK "HOM" 
3d9e f5				push af  
3d9f 3a b3 3d			ld a, (.dmark)  
3da2 32 bd fb			ld (debug_mark),a  
3da5 3a b4 3d			ld a, (.dmark+1)  
3da8 32 be fb			ld (debug_mark+1),a  
3dab 3a b5 3d			ld a, (.dmark+2)  
3dae 32 bf fb			ld (debug_mark+2),a  
3db1 18 03			jr .pastdmark  
3db3 ..			.dmark: db "HOM"  
3db6 f1			.pastdmark: pop af  
3db7			endm  
# End of macro DMARK
3db7						CALLMONITOR 
3db7 cd 6a 16			call break_point_state  
3dba				endm  
# End of macro CALLMONITOR
3dba					endif 
3dba 3e 00		.home:		ld a, 0		; and home cursor 
3dbc 32 cc f9				ld (f_cursor_ptr), a 
3dbf					NEXTW 
3dbf c3 60 1f			jp macro_next 
3dc2				endm 
# End of macro NEXTW
3dc2			 
3dc2			 
3dc2			.SPACE: 
3dc2				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3dc2 46				db WORD_SYS_CORE+50             
3dc3 f0 3d			dw .SPACES            
3dc5 03				db 2 + 1 
3dc6 .. 00			db "BL",0              
3dc9				endm 
# End of macro CWHEAD
3dc9			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3dc9					if DEBUG_FORTH_WORDS_KEY 
3dc9						DMARK "BL." 
3dc9 f5				push af  
3dca 3a de 3d			ld a, (.dmark)  
3dcd 32 bd fb			ld (debug_mark),a  
3dd0 3a df 3d			ld a, (.dmark+1)  
3dd3 32 be fb			ld (debug_mark+1),a  
3dd6 3a e0 3d			ld a, (.dmark+2)  
3dd9 32 bf fb			ld (debug_mark+2),a  
3ddc 18 03			jr .pastdmark  
3dde ..			.dmark: db "BL."  
3de1 f1			.pastdmark: pop af  
3de2			endm  
# End of macro DMARK
3de2						CALLMONITOR 
3de2 cd 6a 16			call break_point_state  
3de5				endm  
# End of macro CALLMONITOR
3de5					endif 
3de5 21 ee 3d				ld hl, .blstr 
3de8 cd 65 1c				call forth_push_str 
3deb					 
3deb				       NEXTW 
3deb c3 60 1f			jp macro_next 
3dee				endm 
# End of macro NEXTW
3dee			 
3dee .. 00		.blstr: db " ", 0 
3df0			 
3df0			.SPACES: 
3df0				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3df0 47				db WORD_SYS_CORE+51             
3df1 8b 3e			dw .SCROLL            
3df3 07				db 6 + 1 
3df4 .. 00			db "SPACES",0              
3dfb				endm 
# End of macro CWHEAD
3dfb			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3dfb					if DEBUG_FORTH_WORDS_KEY 
3dfb						DMARK "SPS" 
3dfb f5				push af  
3dfc 3a 10 3e			ld a, (.dmark)  
3dff 32 bd fb			ld (debug_mark),a  
3e02 3a 11 3e			ld a, (.dmark+1)  
3e05 32 be fb			ld (debug_mark+1),a  
3e08 3a 12 3e			ld a, (.dmark+2)  
3e0b 32 bf fb			ld (debug_mark+2),a  
3e0e 18 03			jr .pastdmark  
3e10 ..			.dmark: db "SPS"  
3e13 f1			.pastdmark: pop af  
3e14			endm  
# End of macro DMARK
3e14						CALLMONITOR 
3e14 cd 6a 16			call break_point_state  
3e17				endm  
# End of macro CALLMONITOR
3e17					endif 
3e17			 
3e17			 
3e17					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e17 cd ee 1d			call macro_dsp_valuehl 
3e1a				endm 
# End of macro FORTH_DSP_VALUEHL
3e1a			 
3e1a			;		push hl    ; u 
3e1a					if DEBUG_FORTH_WORDS 
3e1a						DMARK "SPA" 
3e1a f5				push af  
3e1b 3a 2f 3e			ld a, (.dmark)  
3e1e 32 bd fb			ld (debug_mark),a  
3e21 3a 30 3e			ld a, (.dmark+1)  
3e24 32 be fb			ld (debug_mark+1),a  
3e27 3a 31 3e			ld a, (.dmark+2)  
3e2a 32 bf fb			ld (debug_mark+2),a  
3e2d 18 03			jr .pastdmark  
3e2f ..			.dmark: db "SPA"  
3e32 f1			.pastdmark: pop af  
3e33			endm  
# End of macro DMARK
3e33						CALLMONITOR 
3e33 cd 6a 16			call break_point_state  
3e36				endm  
# End of macro CALLMONITOR
3e36					endif 
3e36			 
3e36					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e36 cd a6 1e			call macro_forth_dsp_pop 
3e39				endm 
# End of macro FORTH_DSP_POP
3e39			;		pop hl 
3e39 4d					ld c, l 
3e3a 06 00				ld b, 0 
3e3c 21 a3 ef				ld hl, scratch  
3e3f			 
3e3f					if DEBUG_FORTH_WORDS 
3e3f						DMARK "SP2" 
3e3f f5				push af  
3e40 3a 54 3e			ld a, (.dmark)  
3e43 32 bd fb			ld (debug_mark),a  
3e46 3a 55 3e			ld a, (.dmark+1)  
3e49 32 be fb			ld (debug_mark+1),a  
3e4c 3a 56 3e			ld a, (.dmark+2)  
3e4f 32 bf fb			ld (debug_mark+2),a  
3e52 18 03			jr .pastdmark  
3e54 ..			.dmark: db "SP2"  
3e57 f1			.pastdmark: pop af  
3e58			endm  
# End of macro DMARK
3e58						CALLMONITOR 
3e58 cd 6a 16			call break_point_state  
3e5b				endm  
# End of macro CALLMONITOR
3e5b					endif 
3e5b 3e 20				ld a, ' ' 
3e5d c5			.spaces1:	push bc 
3e5e 77					ld (hl),a 
3e5f 23					inc hl 
3e60 c1					pop bc 
3e61 10 fa				djnz .spaces1 
3e63 3e 00				ld a,0 
3e65 77					ld (hl),a 
3e66 21 a3 ef				ld hl, scratch 
3e69					if DEBUG_FORTH_WORDS 
3e69						DMARK "SP3" 
3e69 f5				push af  
3e6a 3a 7e 3e			ld a, (.dmark)  
3e6d 32 bd fb			ld (debug_mark),a  
3e70 3a 7f 3e			ld a, (.dmark+1)  
3e73 32 be fb			ld (debug_mark+1),a  
3e76 3a 80 3e			ld a, (.dmark+2)  
3e79 32 bf fb			ld (debug_mark+2),a  
3e7c 18 03			jr .pastdmark  
3e7e ..			.dmark: db "SP3"  
3e81 f1			.pastdmark: pop af  
3e82			endm  
# End of macro DMARK
3e82						CALLMONITOR 
3e82 cd 6a 16			call break_point_state  
3e85				endm  
# End of macro CALLMONITOR
3e85					endif 
3e85 cd 60 1d				call forth_apush 
3e88			 
3e88				       NEXTW 
3e88 c3 60 1f			jp macro_next 
3e8b				endm 
# End of macro NEXTW
3e8b			 
3e8b			 
3e8b			 
3e8b			.SCROLL: 
3e8b				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3e8b 53				db WORD_SYS_CORE+63             
3e8c b8 3e			dw .SCROLLD            
3e8e 07				db 6 + 1 
3e8f .. 00			db "SCROLL",0              
3e96				endm 
# End of macro CWHEAD
3e96			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3e96					if DEBUG_FORTH_WORDS_KEY 
3e96						DMARK "SCR" 
3e96 f5				push af  
3e97 3a ab 3e			ld a, (.dmark)  
3e9a 32 bd fb			ld (debug_mark),a  
3e9d 3a ac 3e			ld a, (.dmark+1)  
3ea0 32 be fb			ld (debug_mark+1),a  
3ea3 3a ad 3e			ld a, (.dmark+2)  
3ea6 32 bf fb			ld (debug_mark+2),a  
3ea9 18 03			jr .pastdmark  
3eab ..			.dmark: db "SCR"  
3eae f1			.pastdmark: pop af  
3eaf			endm  
# End of macro DMARK
3eaf						CALLMONITOR 
3eaf cd 6a 16			call break_point_state  
3eb2				endm  
# End of macro CALLMONITOR
3eb2					endif 
3eb2			 
3eb2 cd 94 0a			call scroll_up 
3eb5			;	call update_display 
3eb5			 
3eb5					NEXTW 
3eb5 c3 60 1f			jp macro_next 
3eb8				endm 
# End of macro NEXTW
3eb8			 
3eb8			 
3eb8			 
3eb8			;		; get dir 
3eb8			; 
3eb8			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eb8			; 
3eb8			;		push hl 
3eb8			; 
3eb8			;		; destroy value TOS 
3eb8			; 
3eb8			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eb8			; 
3eb8			;		; get count 
3eb8			; 
3eb8			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eb8			; 
3eb8			;		push hl 
3eb8			; 
3eb8			;		; destroy value TOS 
3eb8			; 
3eb8			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eb8			; 
3eb8			;		; one value on hl get other one back 
3eb8			; 
3eb8			;		pop bc    ; count 
3eb8			; 
3eb8			;		pop de   ; dir 
3eb8			; 
3eb8			; 
3eb8			;		ld b, c 
3eb8			; 
3eb8			;.scrolldir:     push bc 
3eb8			;		push de 
3eb8			; 
3eb8			;		ld a, 0 
3eb8			;		cp e 
3eb8			;		jr z, .scrollup  
3eb8			;		call scroll_down 
3eb8			;		jr .scrollnext 
3eb8			;.scrollup:	call scroll_up 
3eb8			; 
3eb8			;		 
3eb8			;.scrollnext: 
3eb8			;		pop de 
3eb8			;		pop bc 
3eb8			;		djnz .scrolldir 
3eb8			; 
3eb8			; 
3eb8			; 
3eb8			; 
3eb8			; 
3eb8			;		NEXTW 
3eb8			 
3eb8			.SCROLLD: 
3eb8				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3eb8 53				db WORD_SYS_CORE+63             
3eb9 e6 3e			dw .ATQ            
3ebb 08				db 7 + 1 
3ebc .. 00			db "SCROLLD",0              
3ec4				endm 
# End of macro CWHEAD
3ec4			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3ec4					if DEBUG_FORTH_WORDS_KEY 
3ec4						DMARK "SCD" 
3ec4 f5				push af  
3ec5 3a d9 3e			ld a, (.dmark)  
3ec8 32 bd fb			ld (debug_mark),a  
3ecb 3a da 3e			ld a, (.dmark+1)  
3ece 32 be fb			ld (debug_mark+1),a  
3ed1 3a db 3e			ld a, (.dmark+2)  
3ed4 32 bf fb			ld (debug_mark+2),a  
3ed7 18 03			jr .pastdmark  
3ed9 ..			.dmark: db "SCD"  
3edc f1			.pastdmark: pop af  
3edd			endm  
# End of macro DMARK
3edd						CALLMONITOR 
3edd cd 6a 16			call break_point_state  
3ee0				endm  
# End of macro CALLMONITOR
3ee0					endif 
3ee0			 
3ee0 cd b8 0a			call scroll_down 
3ee3			;	call update_display 
3ee3			 
3ee3					NEXTW 
3ee3 c3 60 1f			jp macro_next 
3ee6				endm 
# End of macro NEXTW
3ee6			 
3ee6			 
3ee6			.ATQ: 
3ee6				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3ee6 62				db WORD_SYS_CORE+78             
3ee7 44 3f			dw .AUTODSP            
3ee9 04				db 3 + 1 
3eea .. 00			db "AT@",0              
3eee				endm 
# End of macro CWHEAD
3eee			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3eee					if DEBUG_FORTH_WORDS_KEY 
3eee						DMARK "ATA" 
3eee f5				push af  
3eef 3a 03 3f			ld a, (.dmark)  
3ef2 32 bd fb			ld (debug_mark),a  
3ef5 3a 04 3f			ld a, (.dmark+1)  
3ef8 32 be fb			ld (debug_mark+1),a  
3efb 3a 05 3f			ld a, (.dmark+2)  
3efe 32 bf fb			ld (debug_mark+2),a  
3f01 18 03			jr .pastdmark  
3f03 ..			.dmark: db "ATA"  
3f06 f1			.pastdmark: pop af  
3f07			endm  
# End of macro DMARK
3f07						CALLMONITOR 
3f07 cd 6a 16			call break_point_state  
3f0a				endm  
# End of macro CALLMONITOR
3f0a					endif 
3f0a			 
3f0a			 
3f0a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f0a cd ee 1d			call macro_dsp_valuehl 
3f0d				endm 
# End of macro FORTH_DSP_VALUEHL
3f0d			 
3f0d					; TODO save cursor row 
3f0d 7d					ld a,l 
3f0e fe 02				cp 2 
3f10 20 04				jr nz, .crow3aq 
3f12 3e 14				ld a, display_row_2 
3f14 18 12				jr .ccol1aq 
3f16 fe 03		.crow3aq:		cp 3 
3f18 20 04				jr nz, .crow4aq 
3f1a 3e 28				ld a, display_row_3 
3f1c 18 0a				jr .ccol1aq 
3f1e fe 04		.crow4aq:		cp 4 
3f20 20 04				jr nz, .crow1aq 
3f22 3e 3c				ld a, display_row_4 
3f24 18 02				jr .ccol1aq 
3f26 3e 00		.crow1aq:		ld a,display_row_1 
3f28 f5			.ccol1aq:		push af			; got row offset 
3f29 6f					ld l,a 
3f2a 26 00				ld h,0 
3f2c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f2c cd a6 1e			call macro_forth_dsp_pop 
3f2f				endm 
# End of macro FORTH_DSP_POP
3f2f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f2f cd ee 1d			call macro_dsp_valuehl 
3f32				endm 
# End of macro FORTH_DSP_VALUEHL
3f32					; TODO save cursor col 
3f32 f1					pop af 
3f33 85					add l		; add col offset 
3f34			 
3f34					; add current frame buffer address 
3f34 2a 5e fa				ld hl, (display_fb_active) 
3f37 cd 06 0d				call addatohl 
3f3a			 
3f3a			 
3f3a			 
3f3a			 
3f3a					; get char frame buffer location offset in hl 
3f3a			 
3f3a 7e					ld a,(hl) 
3f3b 26 00				ld h, 0 
3f3d 6f					ld l, a 
3f3e			 
3f3e cd f7 1b				call forth_push_numhl 
3f41			 
3f41			 
3f41					NEXTW 
3f41 c3 60 1f			jp macro_next 
3f44				endm 
# End of macro NEXTW
3f44			 
3f44			.AUTODSP: 
3f44				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3f44 63				db WORD_SYS_CORE+79             
3f45 5a 3f			dw .MENU            
3f47 05				db 4 + 1 
3f48 .. 00			db "ADSP",0              
3f4d				endm 
# End of macro CWHEAD
3f4d			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3f4d			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3f4d			 
3f4d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f4d cd ee 1d			call macro_dsp_valuehl 
3f50				endm 
# End of macro FORTH_DSP_VALUEHL
3f50			 
3f50			;		push hl 
3f50			 
3f50					; destroy value TOS 
3f50			 
3f50					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f50 cd a6 1e			call macro_forth_dsp_pop 
3f53				endm 
# End of macro FORTH_DSP_POP
3f53			 
3f53			;		pop hl 
3f53			 
3f53 7d					ld a,l 
3f54 32 aa f9				ld (cli_autodisplay), a 
3f57				       NEXTW 
3f57 c3 60 1f			jp macro_next 
3f5a				endm 
# End of macro NEXTW
3f5a			 
3f5a			.MENU: 
3f5a				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3f5a 70				db WORD_SYS_CORE+92             
3f5b 03 40			dw .ENDDISPLAY            
3f5d 05				db 4 + 1 
3f5e .. 00			db "MENU",0              
3f63				endm 
# End of macro CWHEAD
3f63			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3f63			 
3f63			;		; get number of items on the stack 
3f63			; 
3f63				 
3f63					FORTH_DSP_VALUEHL 
3f63 cd ee 1d			call macro_dsp_valuehl 
3f66				endm 
# End of macro FORTH_DSP_VALUEHL
3f66				 
3f66					if DEBUG_FORTH_WORDS_KEY 
3f66						DMARK "MNU" 
3f66 f5				push af  
3f67 3a 7b 3f			ld a, (.dmark)  
3f6a 32 bd fb			ld (debug_mark),a  
3f6d 3a 7c 3f			ld a, (.dmark+1)  
3f70 32 be fb			ld (debug_mark+1),a  
3f73 3a 7d 3f			ld a, (.dmark+2)  
3f76 32 bf fb			ld (debug_mark+2),a  
3f79 18 03			jr .pastdmark  
3f7b ..			.dmark: db "MNU"  
3f7e f1			.pastdmark: pop af  
3f7f			endm  
# End of macro DMARK
3f7f						CALLMONITOR 
3f7f cd 6a 16			call break_point_state  
3f82				endm  
# End of macro CALLMONITOR
3f82					endif 
3f82			 
3f82 45					ld b, l	 
3f83 05					dec b 
3f84			 
3f84					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f84 cd a6 1e			call macro_forth_dsp_pop 
3f87				endm 
# End of macro FORTH_DSP_POP
3f87			 
3f87			 
3f87					; go directly through the stack to pluck out the string pointers and build an array 
3f87			 
3f87			;		FORTH_DSP 
3f87			 
3f87					; hl contains top most stack item 
3f87				 
3f87 11 a3 ef				ld de, scratch 
3f8a			 
3f8a			.mbuild: 
3f8a			 
3f8a					FORTH_DSP_VALUEHL 
3f8a cd ee 1d			call macro_dsp_valuehl 
3f8d				endm 
# End of macro FORTH_DSP_VALUEHL
3f8d			 
3f8d					if DEBUG_FORTH_WORDS 
3f8d						DMARK "MN3" 
3f8d f5				push af  
3f8e 3a a2 3f			ld a, (.dmark)  
3f91 32 bd fb			ld (debug_mark),a  
3f94 3a a3 3f			ld a, (.dmark+1)  
3f97 32 be fb			ld (debug_mark+1),a  
3f9a 3a a4 3f			ld a, (.dmark+2)  
3f9d 32 bf fb			ld (debug_mark+2),a  
3fa0 18 03			jr .pastdmark  
3fa2 ..			.dmark: db "MN3"  
3fa5 f1			.pastdmark: pop af  
3fa6			endm  
# End of macro DMARK
3fa6						CALLMONITOR 
3fa6 cd 6a 16			call break_point_state  
3fa9				endm  
# End of macro CALLMONITOR
3fa9					endif 
3fa9 eb					ex de, hl 
3faa 73					ld (hl), e 
3fab 23					inc hl 
3fac 72					ld (hl), d 
3fad 23					inc hl 
3fae eb					ex de, hl 
3faf			 
3faf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3faf cd a6 1e			call macro_forth_dsp_pop 
3fb2				endm 
# End of macro FORTH_DSP_POP
3fb2			 
3fb2 10 d6				djnz .mbuild 
3fb4			 
3fb4					; done add term 
3fb4			 
3fb4 eb					ex de, hl 
3fb5 36 00				ld (hl), 0 
3fb7 23					inc hl 
3fb8 36 00				ld (hl), 0 
3fba			 
3fba				 
3fba					 
3fba 21 a3 ef				ld hl, scratch 
3fbd			 
3fbd					if DEBUG_FORTH_WORDS 
3fbd						DMARK "MNx" 
3fbd f5				push af  
3fbe 3a d2 3f			ld a, (.dmark)  
3fc1 32 bd fb			ld (debug_mark),a  
3fc4 3a d3 3f			ld a, (.dmark+1)  
3fc7 32 be fb			ld (debug_mark+1),a  
3fca 3a d4 3f			ld a, (.dmark+2)  
3fcd 32 bf fb			ld (debug_mark+2),a  
3fd0 18 03			jr .pastdmark  
3fd2 ..			.dmark: db "MNx"  
3fd5 f1			.pastdmark: pop af  
3fd6			endm  
# End of macro DMARK
3fd6						CALLMONITOR 
3fd6 cd 6a 16			call break_point_state  
3fd9				endm  
# End of macro CALLMONITOR
3fd9					endif 
3fd9			 
3fd9			 
3fd9			 
3fd9 3e 00				ld a, 0 
3fdb cd 03 0b				call menu 
3fde			 
3fde			 
3fde 6f					ld l, a 
3fdf 26 00				ld h, 0 
3fe1			 
3fe1					if DEBUG_FORTH_WORDS 
3fe1						DMARK "MNr" 
3fe1 f5				push af  
3fe2 3a f6 3f			ld a, (.dmark)  
3fe5 32 bd fb			ld (debug_mark),a  
3fe8 3a f7 3f			ld a, (.dmark+1)  
3feb 32 be fb			ld (debug_mark+1),a  
3fee 3a f8 3f			ld a, (.dmark+2)  
3ff1 32 bf fb			ld (debug_mark+2),a  
3ff4 18 03			jr .pastdmark  
3ff6 ..			.dmark: db "MNr"  
3ff9 f1			.pastdmark: pop af  
3ffa			endm  
# End of macro DMARK
3ffa						CALLMONITOR 
3ffa cd 6a 16			call break_point_state  
3ffd				endm  
# End of macro CALLMONITOR
3ffd					endif 
3ffd			 
3ffd cd f7 1b				call forth_push_numhl 
4000			 
4000			 
4000			 
4000			 
4000				       NEXTW 
4000 c3 60 1f			jp macro_next 
4003				endm 
# End of macro NEXTW
4003			 
4003			 
4003			.ENDDISPLAY: 
4003			 
4003			; eof 
# End of file forth_words_display.asm
4003			include "forth_words_str.asm" 
4003			 
4003			; | ## String Words 
4003			 
4003			.PTR:   
4003			 
4003				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4003 48				db WORD_SYS_CORE+52             
4004 30 40			dw .STYPE            
4006 04				db 3 + 1 
4007 .. 00			db "PTR",0              
400b				endm 
# End of macro CWHEAD
400b			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
400b			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
400b			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
400b			 
400b					if DEBUG_FORTH_WORDS_KEY 
400b						DMARK "PTR" 
400b f5				push af  
400c 3a 20 40			ld a, (.dmark)  
400f 32 bd fb			ld (debug_mark),a  
4012 3a 21 40			ld a, (.dmark+1)  
4015 32 be fb			ld (debug_mark+1),a  
4018 3a 22 40			ld a, (.dmark+2)  
401b 32 bf fb			ld (debug_mark+2),a  
401e 18 03			jr .pastdmark  
4020 ..			.dmark: db "PTR"  
4023 f1			.pastdmark: pop af  
4024			endm  
# End of macro DMARK
4024						CALLMONITOR 
4024 cd 6a 16			call break_point_state  
4027				endm  
# End of macro CALLMONITOR
4027					endif 
4027					FORTH_DSP_VALUEHL 
4027 cd ee 1d			call macro_dsp_valuehl 
402a				endm 
# End of macro FORTH_DSP_VALUEHL
402a cd f7 1b				call forth_push_numhl 
402d			 
402d			 
402d					NEXTW 
402d c3 60 1f			jp macro_next 
4030				endm 
# End of macro NEXTW
4030			.STYPE: 
4030				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4030 48				db WORD_SYS_CORE+52             
4031 7f 40			dw .UPPER            
4033 06				db 5 + 1 
4034 .. 00			db "STYPE",0              
403a				endm 
# End of macro CWHEAD
403a			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
403a					if DEBUG_FORTH_WORDS_KEY 
403a						DMARK "STY" 
403a f5				push af  
403b 3a 4f 40			ld a, (.dmark)  
403e 32 bd fb			ld (debug_mark),a  
4041 3a 50 40			ld a, (.dmark+1)  
4044 32 be fb			ld (debug_mark+1),a  
4047 3a 51 40			ld a, (.dmark+2)  
404a 32 bf fb			ld (debug_mark+2),a  
404d 18 03			jr .pastdmark  
404f ..			.dmark: db "STY"  
4052 f1			.pastdmark: pop af  
4053			endm  
# End of macro DMARK
4053						CALLMONITOR 
4053 cd 6a 16			call break_point_state  
4056				endm  
# End of macro CALLMONITOR
4056					endif 
4056					FORTH_DSP 
4056 cd b4 1d			call macro_forth_dsp 
4059				endm 
# End of macro FORTH_DSP
4059					;v5 FORTH_DSP_VALUE 
4059			 
4059 7e					ld a, (hl) 
405a			 
405a f5					push af 
405b			 
405b			; Dont destroy TOS		FORTH_DSP_POP 
405b			 
405b f1					pop af 
405c			 
405c fe 01				cp DS_TYPE_STR 
405e 28 09				jr z, .typestr 
4060			 
4060 fe 02				cp DS_TYPE_INUM 
4062 28 0a				jr z, .typeinum 
4064			 
4064 21 7d 40				ld hl, .tna 
4067 18 0a				jr .tpush 
4069			 
4069 21 79 40		.typestr:	ld hl, .tstr 
406c 18 05				jr .tpush 
406e 21 7b 40		.typeinum:	ld hl, .tinum 
4071 18 00				jr .tpush 
4073			 
4073			.tpush: 
4073			 
4073 cd 65 1c				call forth_push_str 
4076			 
4076					NEXTW 
4076 c3 60 1f			jp macro_next 
4079				endm 
# End of macro NEXTW
4079 .. 00		.tstr:	db "s",0 
407b .. 00		.tinum:  db "i",0 
407d .. 00		.tna:   db "?", 0 
407f			 
407f			 
407f			.UPPER: 
407f				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
407f 48				db WORD_SYS_CORE+52             
4080 ba 40			dw .LOWER            
4082 06				db 5 + 1 
4083 .. 00			db "UPPER",0              
4089				endm 
# End of macro CWHEAD
4089			; | UPPER ( s -- s ) Upper case string s  | DONE 
4089					if DEBUG_FORTH_WORDS_KEY 
4089						DMARK "UPR" 
4089 f5				push af  
408a 3a 9e 40			ld a, (.dmark)  
408d 32 bd fb			ld (debug_mark),a  
4090 3a 9f 40			ld a, (.dmark+1)  
4093 32 be fb			ld (debug_mark+1),a  
4096 3a a0 40			ld a, (.dmark+2)  
4099 32 bf fb			ld (debug_mark+2),a  
409c 18 03			jr .pastdmark  
409e ..			.dmark: db "UPR"  
40a1 f1			.pastdmark: pop af  
40a2			endm  
# End of macro DMARK
40a2						CALLMONITOR 
40a2 cd 6a 16			call break_point_state  
40a5				endm  
# End of macro CALLMONITOR
40a5					endif 
40a5			 
40a5					FORTH_DSP 
40a5 cd b4 1d			call macro_forth_dsp 
40a8				endm 
# End of macro FORTH_DSP
40a8					 
40a8			; TODO check is string type 
40a8			 
40a8					FORTH_DSP_VALUEHL 
40a8 cd ee 1d			call macro_dsp_valuehl 
40ab				endm 
# End of macro FORTH_DSP_VALUEHL
40ab			; get pointer to string in hl 
40ab			 
40ab 7e			.toup:		ld a, (hl) 
40ac fe 00				cp 0 
40ae 28 07				jr z, .toupdone 
40b0			 
40b0 cd 73 10				call to_upper 
40b3			 
40b3 77					ld (hl), a 
40b4 23					inc hl 
40b5 18 f4				jr .toup 
40b7			 
40b7					 
40b7			 
40b7			 
40b7			; for each char convert to upper 
40b7					 
40b7			.toupdone: 
40b7			 
40b7			 
40b7					NEXTW 
40b7 c3 60 1f			jp macro_next 
40ba				endm 
# End of macro NEXTW
40ba			.LOWER: 
40ba				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
40ba 48				db WORD_SYS_CORE+52             
40bb f5 40			dw .TCASE            
40bd 06				db 5 + 1 
40be .. 00			db "LOWER",0              
40c4				endm 
# End of macro CWHEAD
40c4			; | LOWER ( s -- s ) Lower case string s  | DONE 
40c4					if DEBUG_FORTH_WORDS_KEY 
40c4						DMARK "LWR" 
40c4 f5				push af  
40c5 3a d9 40			ld a, (.dmark)  
40c8 32 bd fb			ld (debug_mark),a  
40cb 3a da 40			ld a, (.dmark+1)  
40ce 32 be fb			ld (debug_mark+1),a  
40d1 3a db 40			ld a, (.dmark+2)  
40d4 32 bf fb			ld (debug_mark+2),a  
40d7 18 03			jr .pastdmark  
40d9 ..			.dmark: db "LWR"  
40dc f1			.pastdmark: pop af  
40dd			endm  
# End of macro DMARK
40dd						CALLMONITOR 
40dd cd 6a 16			call break_point_state  
40e0				endm  
# End of macro CALLMONITOR
40e0					endif 
40e0			 
40e0					FORTH_DSP 
40e0 cd b4 1d			call macro_forth_dsp 
40e3				endm 
# End of macro FORTH_DSP
40e3					 
40e3			; TODO check is string type 
40e3			 
40e3					FORTH_DSP_VALUEHL 
40e3 cd ee 1d			call macro_dsp_valuehl 
40e6				endm 
# End of macro FORTH_DSP_VALUEHL
40e6			; get pointer to string in hl 
40e6			 
40e6 7e			.tolow:		ld a, (hl) 
40e7 fe 00				cp 0 
40e9 28 07				jr z, .tolowdone 
40eb			 
40eb cd 7c 10				call to_lower 
40ee			 
40ee 77					ld (hl), a 
40ef 23					inc hl 
40f0 18 f4				jr .tolow 
40f2			 
40f2					 
40f2			 
40f2			 
40f2			; for each char convert to low 
40f2					 
40f2			.tolowdone: 
40f2					NEXTW 
40f2 c3 60 1f			jp macro_next 
40f5				endm 
# End of macro NEXTW
40f5			.TCASE: 
40f5				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
40f5 48				db WORD_SYS_CORE+52             
40f6 2b 42			dw .SUBSTR            
40f8 06				db 5 + 1 
40f9 .. 00			db "TCASE",0              
40ff				endm 
# End of macro CWHEAD
40ff			; | TCASE ( s -- s ) Title case string s  | DONE 
40ff					if DEBUG_FORTH_WORDS_KEY 
40ff						DMARK "TCS" 
40ff f5				push af  
4100 3a 14 41			ld a, (.dmark)  
4103 32 bd fb			ld (debug_mark),a  
4106 3a 15 41			ld a, (.dmark+1)  
4109 32 be fb			ld (debug_mark+1),a  
410c 3a 16 41			ld a, (.dmark+2)  
410f 32 bf fb			ld (debug_mark+2),a  
4112 18 03			jr .pastdmark  
4114 ..			.dmark: db "TCS"  
4117 f1			.pastdmark: pop af  
4118			endm  
# End of macro DMARK
4118						CALLMONITOR 
4118 cd 6a 16			call break_point_state  
411b				endm  
# End of macro CALLMONITOR
411b					endif 
411b			 
411b					FORTH_DSP 
411b cd b4 1d			call macro_forth_dsp 
411e				endm 
# End of macro FORTH_DSP
411e					 
411e			; TODO check is string type 
411e			 
411e					FORTH_DSP_VALUEHL 
411e cd ee 1d			call macro_dsp_valuehl 
4121				endm 
# End of macro FORTH_DSP_VALUEHL
4121			; get pointer to string in hl 
4121			 
4121					if DEBUG_FORTH_WORDS 
4121						DMARK "TC1" 
4121 f5				push af  
4122 3a 36 41			ld a, (.dmark)  
4125 32 bd fb			ld (debug_mark),a  
4128 3a 37 41			ld a, (.dmark+1)  
412b 32 be fb			ld (debug_mark+1),a  
412e 3a 38 41			ld a, (.dmark+2)  
4131 32 bf fb			ld (debug_mark+2),a  
4134 18 03			jr .pastdmark  
4136 ..			.dmark: db "TC1"  
4139 f1			.pastdmark: pop af  
413a			endm  
# End of macro DMARK
413a						CALLMONITOR 
413a cd 6a 16			call break_point_state  
413d				endm  
# End of macro CALLMONITOR
413d					endif 
413d			 
413d					; first time in turn to upper case first char 
413d			 
413d 7e					ld a, (hl) 
413e c3 c8 41				jp .totsiptou 
4141			 
4141			 
4141 7e			.tot:		ld a, (hl) 
4142 fe 00				cp 0 
4144 ca 0c 42				jp z, .totdone 
4147			 
4147					if DEBUG_FORTH_WORDS 
4147						DMARK "TC2" 
4147 f5				push af  
4148 3a 5c 41			ld a, (.dmark)  
414b 32 bd fb			ld (debug_mark),a  
414e 3a 5d 41			ld a, (.dmark+1)  
4151 32 be fb			ld (debug_mark+1),a  
4154 3a 5e 41			ld a, (.dmark+2)  
4157 32 bf fb			ld (debug_mark+2),a  
415a 18 03			jr .pastdmark  
415c ..			.dmark: db "TC2"  
415f f1			.pastdmark: pop af  
4160			endm  
# End of macro DMARK
4160						CALLMONITOR 
4160 cd 6a 16			call break_point_state  
4163				endm  
# End of macro CALLMONITOR
4163					endif 
4163					; check to see if current char is a space 
4163			 
4163 fe 20				cp ' ' 
4165 28 21				jr z, .totsp 
4167 cd 7c 10				call to_lower 
416a					if DEBUG_FORTH_WORDS 
416a						DMARK "TC3" 
416a f5				push af  
416b 3a 7f 41			ld a, (.dmark)  
416e 32 bd fb			ld (debug_mark),a  
4171 3a 80 41			ld a, (.dmark+1)  
4174 32 be fb			ld (debug_mark+1),a  
4177 3a 81 41			ld a, (.dmark+2)  
417a 32 bf fb			ld (debug_mark+2),a  
417d 18 03			jr .pastdmark  
417f ..			.dmark: db "TC3"  
4182 f1			.pastdmark: pop af  
4183			endm  
# End of macro DMARK
4183						CALLMONITOR 
4183 cd 6a 16			call break_point_state  
4186				endm  
# End of macro CALLMONITOR
4186					endif 
4186 18 63				jr .totnxt 
4188			 
4188			.totsp:         ; on a space, find next char which should be upper 
4188			 
4188					if DEBUG_FORTH_WORDS 
4188						DMARK "TC4" 
4188 f5				push af  
4189 3a 9d 41			ld a, (.dmark)  
418c 32 bd fb			ld (debug_mark),a  
418f 3a 9e 41			ld a, (.dmark+1)  
4192 32 be fb			ld (debug_mark+1),a  
4195 3a 9f 41			ld a, (.dmark+2)  
4198 32 bf fb			ld (debug_mark+2),a  
419b 18 03			jr .pastdmark  
419d ..			.dmark: db "TC4"  
41a0 f1			.pastdmark: pop af  
41a1			endm  
# End of macro DMARK
41a1						CALLMONITOR 
41a1 cd 6a 16			call break_point_state  
41a4				endm  
# End of macro CALLMONITOR
41a4					endif 
41a4					;; 
41a4			 
41a4 fe 20				cp ' ' 
41a6 20 20				jr nz, .totsiptou 
41a8 23					inc hl 
41a9 7e					ld a, (hl) 
41aa					if DEBUG_FORTH_WORDS 
41aa						DMARK "TC5" 
41aa f5				push af  
41ab 3a bf 41			ld a, (.dmark)  
41ae 32 bd fb			ld (debug_mark),a  
41b1 3a c0 41			ld a, (.dmark+1)  
41b4 32 be fb			ld (debug_mark+1),a  
41b7 3a c1 41			ld a, (.dmark+2)  
41ba 32 bf fb			ld (debug_mark+2),a  
41bd 18 03			jr .pastdmark  
41bf ..			.dmark: db "TC5"  
41c2 f1			.pastdmark: pop af  
41c3			endm  
# End of macro DMARK
41c3						CALLMONITOR 
41c3 cd 6a 16			call break_point_state  
41c6				endm  
# End of macro CALLMONITOR
41c6					endif 
41c6 18 c0				jr .totsp 
41c8 fe 00		.totsiptou:    cp 0 
41ca 28 40				jr z, .totdone 
41cc					; not space and not zero term so upper case it 
41cc cd 73 10				call to_upper 
41cf			 
41cf					if DEBUG_FORTH_WORDS 
41cf						DMARK "TC6" 
41cf f5				push af  
41d0 3a e4 41			ld a, (.dmark)  
41d3 32 bd fb			ld (debug_mark),a  
41d6 3a e5 41			ld a, (.dmark+1)  
41d9 32 be fb			ld (debug_mark+1),a  
41dc 3a e6 41			ld a, (.dmark+2)  
41df 32 bf fb			ld (debug_mark+2),a  
41e2 18 03			jr .pastdmark  
41e4 ..			.dmark: db "TC6"  
41e7 f1			.pastdmark: pop af  
41e8			endm  
# End of macro DMARK
41e8						CALLMONITOR 
41e8 cd 6a 16			call break_point_state  
41eb				endm  
# End of macro CALLMONITOR
41eb					endif 
41eb			 
41eb			 
41eb			.totnxt: 
41eb			 
41eb 77					ld (hl), a 
41ec 23					inc hl 
41ed					if DEBUG_FORTH_WORDS 
41ed						DMARK "TC7" 
41ed f5				push af  
41ee 3a 02 42			ld a, (.dmark)  
41f1 32 bd fb			ld (debug_mark),a  
41f4 3a 03 42			ld a, (.dmark+1)  
41f7 32 be fb			ld (debug_mark+1),a  
41fa 3a 04 42			ld a, (.dmark+2)  
41fd 32 bf fb			ld (debug_mark+2),a  
4200 18 03			jr .pastdmark  
4202 ..			.dmark: db "TC7"  
4205 f1			.pastdmark: pop af  
4206			endm  
# End of macro DMARK
4206						CALLMONITOR 
4206 cd 6a 16			call break_point_state  
4209				endm  
# End of macro CALLMONITOR
4209					endif 
4209 c3 41 41				jp .tot 
420c			 
420c					 
420c			 
420c			 
420c			; for each char convert to low 
420c					 
420c			.totdone: 
420c					if DEBUG_FORTH_WORDS 
420c						DMARK "TCd" 
420c f5				push af  
420d 3a 21 42			ld a, (.dmark)  
4210 32 bd fb			ld (debug_mark),a  
4213 3a 22 42			ld a, (.dmark+1)  
4216 32 be fb			ld (debug_mark+1),a  
4219 3a 23 42			ld a, (.dmark+2)  
421c 32 bf fb			ld (debug_mark+2),a  
421f 18 03			jr .pastdmark  
4221 ..			.dmark: db "TCd"  
4224 f1			.pastdmark: pop af  
4225			endm  
# End of macro DMARK
4225						CALLMONITOR 
4225 cd 6a 16			call break_point_state  
4228				endm  
# End of macro CALLMONITOR
4228					endif 
4228					NEXTW 
4228 c3 60 1f			jp macro_next 
422b				endm 
# End of macro NEXTW
422b			 
422b			.SUBSTR: 
422b				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
422b 48				db WORD_SYS_CORE+52             
422c 89 42			dw .LEFT            
422e 07				db 6 + 1 
422f .. 00			db "SUBSTR",0              
4236				endm 
# End of macro CWHEAD
4236			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4236			 
4236					if DEBUG_FORTH_WORDS_KEY 
4236						DMARK "SST" 
4236 f5				push af  
4237 3a 4b 42			ld a, (.dmark)  
423a 32 bd fb			ld (debug_mark),a  
423d 3a 4c 42			ld a, (.dmark+1)  
4240 32 be fb			ld (debug_mark+1),a  
4243 3a 4d 42			ld a, (.dmark+2)  
4246 32 bf fb			ld (debug_mark+2),a  
4249 18 03			jr .pastdmark  
424b ..			.dmark: db "SST"  
424e f1			.pastdmark: pop af  
424f			endm  
# End of macro DMARK
424f						CALLMONITOR 
424f cd 6a 16			call break_point_state  
4252				endm  
# End of macro CALLMONITOR
4252					endif 
4252			; TODO check string type 
4252					FORTH_DSP_VALUEHL 
4252 cd ee 1d			call macro_dsp_valuehl 
4255				endm 
# End of macro FORTH_DSP_VALUEHL
4255			 
4255 e5					push hl      ; string length 
4256			 
4256					FORTH_DSP_POP 
4256 cd a6 1e			call macro_forth_dsp_pop 
4259				endm 
# End of macro FORTH_DSP_POP
4259			 
4259					FORTH_DSP_VALUEHL 
4259 cd ee 1d			call macro_dsp_valuehl 
425c				endm 
# End of macro FORTH_DSP_VALUEHL
425c			 
425c e5					push hl     ; start char 
425d			 
425d					FORTH_DSP_POP 
425d cd a6 1e			call macro_forth_dsp_pop 
4260				endm 
# End of macro FORTH_DSP_POP
4260			 
4260			 
4260					FORTH_DSP_VALUE 
4260 cd d7 1d			call macro_forth_dsp_value 
4263				endm 
# End of macro FORTH_DSP_VALUE
4263			 
4263 d1					pop de    ; get start post offset 
4264			 
4264 19					add hl, de    ; starting offset 
4265			 
4265 c1					pop bc 
4266 c5					push bc      ; grab size of string 
4267			 
4267 e5					push hl    ; save string start  
4268			 
4268 26 00				ld h, 0 
426a 69					ld l, c 
426b 23					inc hl 
426c 23					inc hl 
426d			 
426d cd cd 11				call malloc 
4270				if DEBUG_FORTH_MALLOC_GUARD 
4270 cc f3 51				call z,malloc_error 
4273				endif 
4273			 
4273 eb					ex de, hl      ; save malloc area for string copy 
4274 e1					pop hl    ; get back source 
4275 c1					pop bc    ; get length of string back 
4276			 
4276 d5					push de    ; save malloc area for after we push 
4277 ed b0				ldir     ; copy substr 
4279			 
4279			 
4279 eb					ex de, hl 
427a 3e 00				ld a, 0 
427c 77					ld (hl), a   ; term substr 
427d			 
427d					 
427d e1					pop hl    ; get malloc so we can push it 
427e e5					push hl   ; save so we can free it afterwards 
427f			 
427f cd 65 1c				call forth_push_str 
4282			 
4282 e1					pop hl 
4283 cd 97 12				call free 
4286			 
4286					 
4286					 
4286			 
4286			 
4286					NEXTW 
4286 c3 60 1f			jp macro_next 
4289				endm 
# End of macro NEXTW
4289			 
4289			.LEFT: 
4289				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4289 48				db WORD_SYS_CORE+52             
428a b1 42			dw .RIGHT            
428c 05				db 4 + 1 
428d .. 00			db "LEFT",0              
4292				endm 
# End of macro CWHEAD
4292			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4292					if DEBUG_FORTH_WORDS_KEY 
4292						DMARK "LEF" 
4292 f5				push af  
4293 3a a7 42			ld a, (.dmark)  
4296 32 bd fb			ld (debug_mark),a  
4299 3a a8 42			ld a, (.dmark+1)  
429c 32 be fb			ld (debug_mark+1),a  
429f 3a a9 42			ld a, (.dmark+2)  
42a2 32 bf fb			ld (debug_mark+2),a  
42a5 18 03			jr .pastdmark  
42a7 ..			.dmark: db "LEF"  
42aa f1			.pastdmark: pop af  
42ab			endm  
# End of macro DMARK
42ab						CALLMONITOR 
42ab cd 6a 16			call break_point_state  
42ae				endm  
# End of macro CALLMONITOR
42ae					endif 
42ae			 
42ae					NEXTW 
42ae c3 60 1f			jp macro_next 
42b1				endm 
# End of macro NEXTW
42b1			.RIGHT: 
42b1				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
42b1 48				db WORD_SYS_CORE+52             
42b2 da 42			dw .STR2NUM            
42b4 06				db 5 + 1 
42b5 .. 00			db "RIGHT",0              
42bb				endm 
# End of macro CWHEAD
42bb			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
42bb					if DEBUG_FORTH_WORDS_KEY 
42bb						DMARK "RIG" 
42bb f5				push af  
42bc 3a d0 42			ld a, (.dmark)  
42bf 32 bd fb			ld (debug_mark),a  
42c2 3a d1 42			ld a, (.dmark+1)  
42c5 32 be fb			ld (debug_mark+1),a  
42c8 3a d2 42			ld a, (.dmark+2)  
42cb 32 bf fb			ld (debug_mark+2),a  
42ce 18 03			jr .pastdmark  
42d0 ..			.dmark: db "RIG"  
42d3 f1			.pastdmark: pop af  
42d4			endm  
# End of macro DMARK
42d4						CALLMONITOR 
42d4 cd 6a 16			call break_point_state  
42d7				endm  
# End of macro CALLMONITOR
42d7					endif 
42d7			 
42d7					NEXTW 
42d7 c3 60 1f			jp macro_next 
42da				endm 
# End of macro NEXTW
42da			 
42da			 
42da			.STR2NUM: 
42da				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
42da 48				db WORD_SYS_CORE+52             
42db 66 43			dw .NUM2STR            
42dd 08				db 7 + 1 
42de .. 00			db "STR2NUM",0              
42e6				endm 
# End of macro CWHEAD
42e6			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
42e6			 
42e6			 
42e6			; TODO STR type check to do 
42e6					if DEBUG_FORTH_WORDS_KEY 
42e6						DMARK "S2N" 
42e6 f5				push af  
42e7 3a fb 42			ld a, (.dmark)  
42ea 32 bd fb			ld (debug_mark),a  
42ed 3a fc 42			ld a, (.dmark+1)  
42f0 32 be fb			ld (debug_mark+1),a  
42f3 3a fd 42			ld a, (.dmark+2)  
42f6 32 bf fb			ld (debug_mark+2),a  
42f9 18 03			jr .pastdmark  
42fb ..			.dmark: db "S2N"  
42fe f1			.pastdmark: pop af  
42ff			endm  
# End of macro DMARK
42ff						CALLMONITOR 
42ff cd 6a 16			call break_point_state  
4302				endm  
# End of macro CALLMONITOR
4302					endif 
4302			 
4302					;FORTH_DSP 
4302					FORTH_DSP_VALUE 
4302 cd d7 1d			call macro_forth_dsp_value 
4305				endm 
# End of macro FORTH_DSP_VALUE
4305					;inc hl 
4305			 
4305 eb					ex de, hl 
4306					if DEBUG_FORTH_WORDS 
4306						DMARK "S2a" 
4306 f5				push af  
4307 3a 1b 43			ld a, (.dmark)  
430a 32 bd fb			ld (debug_mark),a  
430d 3a 1c 43			ld a, (.dmark+1)  
4310 32 be fb			ld (debug_mark+1),a  
4313 3a 1d 43			ld a, (.dmark+2)  
4316 32 bf fb			ld (debug_mark+2),a  
4319 18 03			jr .pastdmark  
431b ..			.dmark: db "S2a"  
431e f1			.pastdmark: pop af  
431f			endm  
# End of macro DMARK
431f						CALLMONITOR 
431f cd 6a 16			call break_point_state  
4322				endm  
# End of macro CALLMONITOR
4322					endif 
4322 cd fb 10				call string_to_uint16 
4325			 
4325					if DEBUG_FORTH_WORDS 
4325						DMARK "S2b" 
4325 f5				push af  
4326 3a 3a 43			ld a, (.dmark)  
4329 32 bd fb			ld (debug_mark),a  
432c 3a 3b 43			ld a, (.dmark+1)  
432f 32 be fb			ld (debug_mark+1),a  
4332 3a 3c 43			ld a, (.dmark+2)  
4335 32 bf fb			ld (debug_mark+2),a  
4338 18 03			jr .pastdmark  
433a ..			.dmark: db "S2b"  
433d f1			.pastdmark: pop af  
433e			endm  
# End of macro DMARK
433e						CALLMONITOR 
433e cd 6a 16			call break_point_state  
4341				endm  
# End of macro CALLMONITOR
4341					endif 
4341			;		push hl 
4341					FORTH_DSP_POP 
4341 cd a6 1e			call macro_forth_dsp_pop 
4344				endm 
# End of macro FORTH_DSP_POP
4344			;		pop hl 
4344					 
4344					if DEBUG_FORTH_WORDS 
4344						DMARK "S2b" 
4344 f5				push af  
4345 3a 59 43			ld a, (.dmark)  
4348 32 bd fb			ld (debug_mark),a  
434b 3a 5a 43			ld a, (.dmark+1)  
434e 32 be fb			ld (debug_mark+1),a  
4351 3a 5b 43			ld a, (.dmark+2)  
4354 32 bf fb			ld (debug_mark+2),a  
4357 18 03			jr .pastdmark  
4359 ..			.dmark: db "S2b"  
435c f1			.pastdmark: pop af  
435d			endm  
# End of macro DMARK
435d						CALLMONITOR 
435d cd 6a 16			call break_point_state  
4360				endm  
# End of macro CALLMONITOR
4360					endif 
4360 cd f7 1b				call forth_push_numhl	 
4363			 
4363				 
4363				       NEXTW 
4363 c3 60 1f			jp macro_next 
4366				endm 
# End of macro NEXTW
4366			.NUM2STR: 
4366				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4366 48				db WORD_SYS_CORE+52             
4367 75 43			dw .CONCAT            
4369 08				db 7 + 1 
436a .. 00			db "NUM2STR",0              
4372				endm 
# End of macro CWHEAD
4372			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4372			 
4372			;		; malloc a string to target 
4372			;		ld hl, 10     ; TODO max string size should be fine 
4372			;		call malloc 
4372			;		push hl    ; save malloc location 
4372			; 
4372			; 
4372			;; TODO check int type 
4372			;		FORTH_DSP_VALUEHL 
4372			;		ld a, l 
4372			;		call DispAToASCII   
4372			;;TODO need to chage above call to dump into string 
4372			; 
4372			; 
4372			 
4372				       NEXTW 
4372 c3 60 1f			jp macro_next 
4375				endm 
# End of macro NEXTW
4375			 
4375			.CONCAT: 
4375				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4375 48				db WORD_SYS_CORE+52             
4376 28 44			dw .FIND            
4378 07				db 6 + 1 
4379 .. 00			db "CONCAT",0              
4380				endm 
# End of macro CWHEAD
4380			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4380			 
4380			; TODO check string type 
4380			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4380			 
4380					if DEBUG_FORTH_WORDS_KEY 
4380						DMARK "CON" 
4380 f5				push af  
4381 3a 95 43			ld a, (.dmark)  
4384 32 bd fb			ld (debug_mark),a  
4387 3a 96 43			ld a, (.dmark+1)  
438a 32 be fb			ld (debug_mark+1),a  
438d 3a 97 43			ld a, (.dmark+2)  
4390 32 bf fb			ld (debug_mark+2),a  
4393 18 03			jr .pastdmark  
4395 ..			.dmark: db "CON"  
4398 f1			.pastdmark: pop af  
4399			endm  
# End of macro DMARK
4399						CALLMONITOR 
4399 cd 6a 16			call break_point_state  
439c				endm  
# End of macro CALLMONITOR
439c					endif 
439c			 
439c			 
439c					FORTH_DSP_VALUE 
439c cd d7 1d			call macro_forth_dsp_value 
439f				endm 
# End of macro FORTH_DSP_VALUE
439f e5					push hl   ; s2 
43a0			 
43a0					FORTH_DSP_POP 
43a0 cd a6 1e			call macro_forth_dsp_pop 
43a3				endm 
# End of macro FORTH_DSP_POP
43a3			 
43a3					FORTH_DSP_VALUE 
43a3 cd d7 1d			call macro_forth_dsp_value 
43a6				endm 
# End of macro FORTH_DSP_VALUE
43a6			 
43a6 e5					push hl   ; s1 
43a7			 
43a7					FORTH_DSP_POP 
43a7 cd a6 1e			call macro_forth_dsp_pop 
43aa				endm 
# End of macro FORTH_DSP_POP
43aa					 
43aa			 
43aa					; copy s1 
43aa			 
43aa				 
43aa					; save ptr 
43aa e1					pop hl  
43ab e5					push hl 
43ac 3e 00				ld a, 0 
43ae cd 6f 11				call strlent 
43b1					;inc hl    ; zer0 
43b1 06 00				ld b, 0 
43b3 4d					ld c, l 
43b4 e1					pop hl		 
43b5 11 a3 ef				ld de, scratch	 
43b8					if DEBUG_FORTH_WORDS 
43b8						DMARK "CO1" 
43b8 f5				push af  
43b9 3a cd 43			ld a, (.dmark)  
43bc 32 bd fb			ld (debug_mark),a  
43bf 3a ce 43			ld a, (.dmark+1)  
43c2 32 be fb			ld (debug_mark+1),a  
43c5 3a cf 43			ld a, (.dmark+2)  
43c8 32 bf fb			ld (debug_mark+2),a  
43cb 18 03			jr .pastdmark  
43cd ..			.dmark: db "CO1"  
43d0 f1			.pastdmark: pop af  
43d1			endm  
# End of macro DMARK
43d1						CALLMONITOR 
43d1 cd 6a 16			call break_point_state  
43d4				endm  
# End of macro CALLMONITOR
43d4					endif 
43d4 ed b0				ldir 
43d6			 
43d6 e1					pop hl 
43d7 e5					push hl 
43d8 d5					push de 
43d9			 
43d9			 
43d9 3e 00				ld a, 0 
43db cd 6f 11				call strlent 
43de 23					inc hl    ; zer0 
43df 23					inc hl 
43e0 06 00				ld b, 0 
43e2 4d					ld c, l 
43e3 d1					pop de 
43e4 e1					pop hl		 
43e5					if DEBUG_FORTH_WORDS 
43e5						DMARK "CO2" 
43e5 f5				push af  
43e6 3a fa 43			ld a, (.dmark)  
43e9 32 bd fb			ld (debug_mark),a  
43ec 3a fb 43			ld a, (.dmark+1)  
43ef 32 be fb			ld (debug_mark+1),a  
43f2 3a fc 43			ld a, (.dmark+2)  
43f5 32 bf fb			ld (debug_mark+2),a  
43f8 18 03			jr .pastdmark  
43fa ..			.dmark: db "CO2"  
43fd f1			.pastdmark: pop af  
43fe			endm  
# End of macro DMARK
43fe						CALLMONITOR 
43fe cd 6a 16			call break_point_state  
4401				endm  
# End of macro CALLMONITOR
4401					endif 
4401 ed b0				ldir 
4403			 
4403			 
4403			 
4403 21 a3 ef				ld hl, scratch 
4406					if DEBUG_FORTH_WORDS 
4406						DMARK "CO5" 
4406 f5				push af  
4407 3a 1b 44			ld a, (.dmark)  
440a 32 bd fb			ld (debug_mark),a  
440d 3a 1c 44			ld a, (.dmark+1)  
4410 32 be fb			ld (debug_mark+1),a  
4413 3a 1d 44			ld a, (.dmark+2)  
4416 32 bf fb			ld (debug_mark+2),a  
4419 18 03			jr .pastdmark  
441b ..			.dmark: db "CO5"  
441e f1			.pastdmark: pop af  
441f			endm  
# End of macro DMARK
441f						CALLMONITOR 
441f cd 6a 16			call break_point_state  
4422				endm  
# End of macro CALLMONITOR
4422					endif 
4422			 
4422 cd 65 1c				call forth_push_str 
4425			 
4425			 
4425			 
4425			 
4425				       NEXTW 
4425 c3 60 1f			jp macro_next 
4428				endm 
# End of macro NEXTW
4428			 
4428			 
4428			.FIND: 
4428				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4428 4b				db WORD_SYS_CORE+55             
4429 e6 44			dw .LEN            
442b 05				db 4 + 1 
442c .. 00			db "FIND",0              
4431				endm 
# End of macro CWHEAD
4431			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4431			 
4431					if DEBUG_FORTH_WORDS_KEY 
4431						DMARK "FND" 
4431 f5				push af  
4432 3a 46 44			ld a, (.dmark)  
4435 32 bd fb			ld (debug_mark),a  
4438 3a 47 44			ld a, (.dmark+1)  
443b 32 be fb			ld (debug_mark+1),a  
443e 3a 48 44			ld a, (.dmark+2)  
4441 32 bf fb			ld (debug_mark+2),a  
4444 18 03			jr .pastdmark  
4446 ..			.dmark: db "FND"  
4449 f1			.pastdmark: pop af  
444a			endm  
# End of macro DMARK
444a						CALLMONITOR 
444a cd 6a 16			call break_point_state  
444d				endm  
# End of macro CALLMONITOR
444d					endif 
444d			 
444d			; TODO check string type 
444d					FORTH_DSP_VALUE 
444d cd d7 1d			call macro_forth_dsp_value 
4450				endm 
# End of macro FORTH_DSP_VALUE
4450			 
4450 e5					push hl    
4451 7e					ld a,(hl)    ; char to find   
4452			; TODO change char to substr 
4452			 
4452 f5					push af 
4453					 
4453			 
4453			 
4453					if DEBUG_FORTH_WORDS 
4453						DMARK "FN1" 
4453 f5				push af  
4454 3a 68 44			ld a, (.dmark)  
4457 32 bd fb			ld (debug_mark),a  
445a 3a 69 44			ld a, (.dmark+1)  
445d 32 be fb			ld (debug_mark+1),a  
4460 3a 6a 44			ld a, (.dmark+2)  
4463 32 bf fb			ld (debug_mark+2),a  
4466 18 03			jr .pastdmark  
4468 ..			.dmark: db "FN1"  
446b f1			.pastdmark: pop af  
446c			endm  
# End of macro DMARK
446c						CALLMONITOR 
446c cd 6a 16			call break_point_state  
446f				endm  
# End of macro CALLMONITOR
446f					endif 
446f			 
446f					FORTH_DSP_POP 
446f cd a6 1e			call macro_forth_dsp_pop 
4472				endm 
# End of macro FORTH_DSP_POP
4472			 
4472					; string to search 
4472			 
4472					FORTH_DSP_VALUE 
4472 cd d7 1d			call macro_forth_dsp_value 
4475				endm 
# End of macro FORTH_DSP_VALUE
4475			 
4475 d1					pop de  ; d is char to find  
4476			 
4476					if DEBUG_FORTH_WORDS 
4476						DMARK "FN2" 
4476 f5				push af  
4477 3a 8b 44			ld a, (.dmark)  
447a 32 bd fb			ld (debug_mark),a  
447d 3a 8c 44			ld a, (.dmark+1)  
4480 32 be fb			ld (debug_mark+1),a  
4483 3a 8d 44			ld a, (.dmark+2)  
4486 32 bf fb			ld (debug_mark+2),a  
4489 18 03			jr .pastdmark  
448b ..			.dmark: db "FN2"  
448e f1			.pastdmark: pop af  
448f			endm  
# End of macro DMARK
448f						CALLMONITOR 
448f cd 6a 16			call break_point_state  
4492				endm  
# End of macro CALLMONITOR
4492					endif 
4492					 
4492 01 00 00				ld bc, 0 
4495 7e			.findchar:      ld a,(hl) 
4496 fe 00				cp 0   		 
4498 28 27				jr z, .finddone     
449a ba					cp d 
449b 28 20				jr z, .foundchar 
449d 03					inc bc 
449e 23					inc hl 
449f					if DEBUG_FORTH_WORDS 
449f						DMARK "FN3" 
449f f5				push af  
44a0 3a b4 44			ld a, (.dmark)  
44a3 32 bd fb			ld (debug_mark),a  
44a6 3a b5 44			ld a, (.dmark+1)  
44a9 32 be fb			ld (debug_mark+1),a  
44ac 3a b6 44			ld a, (.dmark+2)  
44af 32 bf fb			ld (debug_mark+2),a  
44b2 18 03			jr .pastdmark  
44b4 ..			.dmark: db "FN3"  
44b7 f1			.pastdmark: pop af  
44b8			endm  
# End of macro DMARK
44b8						CALLMONITOR 
44b8 cd 6a 16			call break_point_state  
44bb				endm  
# End of macro CALLMONITOR
44bb					endif 
44bb 18 d8				jr .findchar 
44bd			 
44bd			 
44bd c5			.foundchar:	push bc 
44be e1					pop hl 
44bf 18 03				jr .findexit 
44c1			 
44c1			 
44c1							 
44c1			 
44c1			.finddone:     ; got to end of string with no find 
44c1 21 00 00				ld hl, 0 
44c4			.findexit: 
44c4			 
44c4					if DEBUG_FORTH_WORDS 
44c4						DMARK "FNd" 
44c4 f5				push af  
44c5 3a d9 44			ld a, (.dmark)  
44c8 32 bd fb			ld (debug_mark),a  
44cb 3a da 44			ld a, (.dmark+1)  
44ce 32 be fb			ld (debug_mark+1),a  
44d1 3a db 44			ld a, (.dmark+2)  
44d4 32 bf fb			ld (debug_mark+2),a  
44d7 18 03			jr .pastdmark  
44d9 ..			.dmark: db "FNd"  
44dc f1			.pastdmark: pop af  
44dd			endm  
# End of macro DMARK
44dd						CALLMONITOR 
44dd cd 6a 16			call break_point_state  
44e0				endm  
# End of macro CALLMONITOR
44e0					endif 
44e0 cd f7 1b			call forth_push_numhl 
44e3			 
44e3				       NEXTW 
44e3 c3 60 1f			jp macro_next 
44e6				endm 
# End of macro NEXTW
44e6			 
44e6			.LEN: 
44e6				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
44e6 4c				db WORD_SYS_CORE+56             
44e7 1b 45			dw .CHAR            
44e9 06				db 5 + 1 
44ea .. 00			db "COUNT",0              
44f0				endm 
# End of macro CWHEAD
44f0			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
44f0			 
44f0					if DEBUG_FORTH_WORDS_KEY 
44f0						DMARK "CNT" 
44f0 f5				push af  
44f1 3a 05 45			ld a, (.dmark)  
44f4 32 bd fb			ld (debug_mark),a  
44f7 3a 06 45			ld a, (.dmark+1)  
44fa 32 be fb			ld (debug_mark+1),a  
44fd 3a 07 45			ld a, (.dmark+2)  
4500 32 bf fb			ld (debug_mark+2),a  
4503 18 03			jr .pastdmark  
4505 ..			.dmark: db "CNT"  
4508 f1			.pastdmark: pop af  
4509			endm  
# End of macro DMARK
4509						CALLMONITOR 
4509 cd 6a 16			call break_point_state  
450c				endm  
# End of macro CALLMONITOR
450c					endif 
450c			; TODO check string type 
450c					FORTH_DSP 
450c cd b4 1d			call macro_forth_dsp 
450f				endm 
# End of macro FORTH_DSP
450f					;v5FORTH_DSP_VALUE 
450f			 
450f 23					inc hl 
4510			 
4510 3e 00				ld a, 0 
4512 cd 6f 11				call strlent 
4515			 
4515 cd f7 1b				call forth_push_numhl 
4518			 
4518			 
4518			 
4518				       NEXTW 
4518 c3 60 1f			jp macro_next 
451b				endm 
# End of macro NEXTW
451b			.CHAR: 
451b				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
451b 4d				db WORD_SYS_CORE+57             
451c 51 45			dw .ENDSTR            
451e 05				db 4 + 1 
451f .. 00			db "CHAR",0              
4524				endm 
# End of macro CWHEAD
4524			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4524					if DEBUG_FORTH_WORDS_KEY 
4524						DMARK "CHR" 
4524 f5				push af  
4525 3a 39 45			ld a, (.dmark)  
4528 32 bd fb			ld (debug_mark),a  
452b 3a 3a 45			ld a, (.dmark+1)  
452e 32 be fb			ld (debug_mark+1),a  
4531 3a 3b 45			ld a, (.dmark+2)  
4534 32 bf fb			ld (debug_mark+2),a  
4537 18 03			jr .pastdmark  
4539 ..			.dmark: db "CHR"  
453c f1			.pastdmark: pop af  
453d			endm  
# End of macro DMARK
453d						CALLMONITOR 
453d cd 6a 16			call break_point_state  
4540				endm  
# End of macro CALLMONITOR
4540					endif 
4540					FORTH_DSP 
4540 cd b4 1d			call macro_forth_dsp 
4543				endm 
# End of macro FORTH_DSP
4543					;v5 FORTH_DSP_VALUE 
4543 23					inc hl      ; now at start of numeric as string 
4544			 
4544			;		push hl 
4544			 
4544					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4544 cd a6 1e			call macro_forth_dsp_pop 
4547				endm 
# End of macro FORTH_DSP_POP
4547			 
4547			;		pop hl 
4547			 
4547					; push the content of a onto the stack as a value 
4547			 
4547 7e					ld a,(hl)   ; get char 
4548 26 00				ld h,0 
454a 6f					ld l,a 
454b cd f7 1b				call forth_push_numhl 
454e			 
454e				       NEXTW 
454e c3 60 1f			jp macro_next 
4551				endm 
# End of macro NEXTW
4551			 
4551			 
4551			 
4551			 
4551			.ENDSTR: 
4551			; eof 
4551			 
# End of file forth_words_str.asm
4551			include "forth_words_key.asm" 
4551			 
4551			; | ## Keyboard Words 
4551			 
4551			.KEY: 
4551				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4551 3e				db WORD_SYS_CORE+42             
4552 81 45			dw .WAITK            
4554 04				db 3 + 1 
4555 .. 00			db "KEY",0              
4559				endm 
# End of macro CWHEAD
4559			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4559			 
4559					if DEBUG_FORTH_WORDS_KEY 
4559						DMARK "KEY" 
4559 f5				push af  
455a 3a 6e 45			ld a, (.dmark)  
455d 32 bd fb			ld (debug_mark),a  
4560 3a 6f 45			ld a, (.dmark+1)  
4563 32 be fb			ld (debug_mark+1),a  
4566 3a 70 45			ld a, (.dmark+2)  
4569 32 bf fb			ld (debug_mark+2),a  
456c 18 03			jr .pastdmark  
456e ..			.dmark: db "KEY"  
4571 f1			.pastdmark: pop af  
4572			endm  
# End of macro DMARK
4572						CALLMONITOR 
4572 cd 6a 16			call break_point_state  
4575				endm  
# End of macro CALLMONITOR
4575					endif 
4575			; TODO currently waits 
4575 cd 5a 66				call cin 
4578					;call cin_wait 
4578 6f					ld l, a 
4579 26 00				ld h, 0 
457b cd f7 1b				call forth_push_numhl 
457e					NEXTW 
457e c3 60 1f			jp macro_next 
4581				endm 
# End of macro NEXTW
4581			.WAITK: 
4581				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4581 3f				db WORD_SYS_CORE+43             
4582 b3 45			dw .ACCEPT            
4584 06				db 5 + 1 
4585 .. 00			db "WAITK",0              
458b				endm 
# End of macro CWHEAD
458b			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
458b					if DEBUG_FORTH_WORDS_KEY 
458b						DMARK "WAI" 
458b f5				push af  
458c 3a a0 45			ld a, (.dmark)  
458f 32 bd fb			ld (debug_mark),a  
4592 3a a1 45			ld a, (.dmark+1)  
4595 32 be fb			ld (debug_mark+1),a  
4598 3a a2 45			ld a, (.dmark+2)  
459b 32 bf fb			ld (debug_mark+2),a  
459e 18 03			jr .pastdmark  
45a0 ..			.dmark: db "WAI"  
45a3 f1			.pastdmark: pop af  
45a4			endm  
# End of macro DMARK
45a4						CALLMONITOR 
45a4 cd 6a 16			call break_point_state  
45a7				endm  
# End of macro CALLMONITOR
45a7					endif 
45a7 cd 49 66				call cin_wait 
45aa 6f					ld l, a 
45ab 26 00				ld h, 0 
45ad cd f7 1b				call forth_push_numhl 
45b0					NEXTW 
45b0 c3 60 1f			jp macro_next 
45b3				endm 
# End of macro NEXTW
45b3			.ACCEPT: 
45b3				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
45b3 40				db WORD_SYS_CORE+44             
45b4 11 46			dw .EDIT            
45b6 07				db 6 + 1 
45b7 .. 00			db "ACCEPT",0              
45be				endm 
# End of macro CWHEAD
45be			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
45be					; TODO crashes on push 
45be					if DEBUG_FORTH_WORDS_KEY 
45be						DMARK "ACC" 
45be f5				push af  
45bf 3a d3 45			ld a, (.dmark)  
45c2 32 bd fb			ld (debug_mark),a  
45c5 3a d4 45			ld a, (.dmark+1)  
45c8 32 be fb			ld (debug_mark+1),a  
45cb 3a d5 45			ld a, (.dmark+2)  
45ce 32 bf fb			ld (debug_mark+2),a  
45d1 18 03			jr .pastdmark  
45d3 ..			.dmark: db "ACC"  
45d6 f1			.pastdmark: pop af  
45d7			endm  
# End of macro DMARK
45d7						CALLMONITOR 
45d7 cd 6a 16			call break_point_state  
45da				endm  
# End of macro CALLMONITOR
45da					endif 
45da 21 a1 f1				ld hl, os_input 
45dd 3e 00				ld a, 0 
45df 77					ld (hl),a 
45e0 3a cc f9				ld a,(f_cursor_ptr) 
45e3 16 64				ld d, 100 
45e5 0e 00				ld c, 0 
45e7 1e 28				ld e, 40 
45e9 cd 33 0d				call input_str 
45ec					; TODO perhaps do a type check and wrap in quotes if not a number 
45ec 21 a1 f1				ld hl, os_input 
45ef					if DEBUG_FORTH_WORDS 
45ef						DMARK "AC1" 
45ef f5				push af  
45f0 3a 04 46			ld a, (.dmark)  
45f3 32 bd fb			ld (debug_mark),a  
45f6 3a 05 46			ld a, (.dmark+1)  
45f9 32 be fb			ld (debug_mark+1),a  
45fc 3a 06 46			ld a, (.dmark+2)  
45ff 32 bf fb			ld (debug_mark+2),a  
4602 18 03			jr .pastdmark  
4604 ..			.dmark: db "AC1"  
4607 f1			.pastdmark: pop af  
4608			endm  
# End of macro DMARK
4608						CALLMONITOR 
4608 cd 6a 16			call break_point_state  
460b				endm  
# End of macro CALLMONITOR
460b					endif 
460b cd 65 1c				call forth_push_str 
460e					NEXTW 
460e c3 60 1f			jp macro_next 
4611				endm 
# End of macro NEXTW
4611			 
4611			.EDIT: 
4611				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4611 40				db WORD_SYS_CORE+44             
4612 9a 46			dw .ENDKEY            
4614 05				db 4 + 1 
4615 .. 00			db "EDIT",0              
461a				endm 
# End of macro CWHEAD
461a			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
461a			 
461a					; TODO does not copy from stack 
461a					if DEBUG_FORTH_WORDS_KEY 
461a						DMARK "EDT" 
461a f5				push af  
461b 3a 2f 46			ld a, (.dmark)  
461e 32 bd fb			ld (debug_mark),a  
4621 3a 30 46			ld a, (.dmark+1)  
4624 32 be fb			ld (debug_mark+1),a  
4627 3a 31 46			ld a, (.dmark+2)  
462a 32 bf fb			ld (debug_mark+2),a  
462d 18 03			jr .pastdmark  
462f ..			.dmark: db "EDT"  
4632 f1			.pastdmark: pop af  
4633			endm  
# End of macro DMARK
4633						CALLMONITOR 
4633 cd 6a 16			call break_point_state  
4636				endm  
# End of macro CALLMONITOR
4636					endif 
4636			 
4636					FORTH_DSP 
4636 cd b4 1d			call macro_forth_dsp 
4639				endm 
# End of macro FORTH_DSP
4639					;v5 FORTH_DSP_VALUE 
4639 23					inc hl    ; TODO do type check 
463a			 
463a e5					push hl 
463b 3e 00				ld a, 0 
463d cd 6f 11				call strlent 
4640 23					inc hl 
4641			 
4641 06 00				ld b, 0 
4643 4d					ld c, l 
4644			 
4644 e1					pop hl 
4645 11 a1 f1				ld de, os_input 
4648					if DEBUG_FORTH_WORDS_KEY 
4648						DMARK "EDc" 
4648 f5				push af  
4649 3a 5d 46			ld a, (.dmark)  
464c 32 bd fb			ld (debug_mark),a  
464f 3a 5e 46			ld a, (.dmark+1)  
4652 32 be fb			ld (debug_mark+1),a  
4655 3a 5f 46			ld a, (.dmark+2)  
4658 32 bf fb			ld (debug_mark+2),a  
465b 18 03			jr .pastdmark  
465d ..			.dmark: db "EDc"  
4660 f1			.pastdmark: pop af  
4661			endm  
# End of macro DMARK
4661						CALLMONITOR 
4661 cd 6a 16			call break_point_state  
4664				endm  
# End of macro CALLMONITOR
4664					endif 
4664 ed b0				ldir 
4666			 
4666			 
4666 21 a1 f1				ld hl, os_input 
4669					;ld a, 0 
4669					;ld (hl),a 
4669 3a cc f9				ld a,(f_cursor_ptr) 
466c 16 64				ld d, 100 
466e 0e 00				ld c, 0 
4670 1e 28				ld e, 40 
4672 cd 33 0d				call input_str 
4675					; TODO perhaps do a type check and wrap in quotes if not a number 
4675 21 a1 f1				ld hl, os_input 
4678					if DEBUG_FORTH_WORDS 
4678						DMARK "ED1" 
4678 f5				push af  
4679 3a 8d 46			ld a, (.dmark)  
467c 32 bd fb			ld (debug_mark),a  
467f 3a 8e 46			ld a, (.dmark+1)  
4682 32 be fb			ld (debug_mark+1),a  
4685 3a 8f 46			ld a, (.dmark+2)  
4688 32 bf fb			ld (debug_mark+2),a  
468b 18 03			jr .pastdmark  
468d ..			.dmark: db "ED1"  
4690 f1			.pastdmark: pop af  
4691			endm  
# End of macro DMARK
4691						CALLMONITOR 
4691 cd 6a 16			call break_point_state  
4694				endm  
# End of macro CALLMONITOR
4694					endif 
4694 cd 65 1c				call forth_push_str 
4697					NEXTW 
4697 c3 60 1f			jp macro_next 
469a				endm 
# End of macro NEXTW
469a			 
469a			 
469a			 
469a			.ENDKEY: 
469a			; eof 
469a			 
# End of file forth_words_key.asm
469a			 
469a			if STORAGE_SE 
469a			   	include "forth_words_storage.asm" 
469a			 
469a			; | ## Fixed Storage Words 
469a			 
469a			 
469a			.BREAD: 
469a			  
469a				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
469a 3a				db WORD_SYS_CORE+38             
469b 13 47			dw .BWRITE            
469d 06				db 5 + 1 
469e .. 00			db "BREAD",0              
46a4				endm 
# End of macro CWHEAD
46a4			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
46a4				 
46a4					if DEBUG_FORTH_WORDS_KEY 
46a4						DMARK "BRD" 
46a4 f5				push af  
46a5 3a b9 46			ld a, (.dmark)  
46a8 32 bd fb			ld (debug_mark),a  
46ab 3a ba 46			ld a, (.dmark+1)  
46ae 32 be fb			ld (debug_mark+1),a  
46b1 3a bb 46			ld a, (.dmark+2)  
46b4 32 bf fb			ld (debug_mark+2),a  
46b7 18 03			jr .pastdmark  
46b9 ..			.dmark: db "BRD"  
46bc f1			.pastdmark: pop af  
46bd			endm  
# End of macro DMARK
46bd						CALLMONITOR 
46bd cd 6a 16			call break_point_state  
46c0				endm  
# End of macro CALLMONITOR
46c0					endif 
46c0			 
46c0				FORTH_DSP_VALUEHL 
46c0 cd ee 1d			call macro_dsp_valuehl 
46c3				endm 
# End of macro FORTH_DSP_VALUEHL
46c3			 
46c3				FORTH_DSP_POP 
46c3 cd a6 1e			call macro_forth_dsp_pop 
46c6				endm 
# End of macro FORTH_DSP_POP
46c6			 
46c6				; calc block address 
46c6			 
46c6 eb				ex de, hl 
46c7 3e 40			ld a, STORE_BLOCK_PHY 
46c9 cd 89 0c			call Mult16 
46cc			 
46cc			 
46cc 11 e8 f9			ld de, store_page 
46cf			 
46cf					if DEBUG_FORTH_WORDS 
46cf						DMARK "BR1" 
46cf f5				push af  
46d0 3a e4 46			ld a, (.dmark)  
46d3 32 bd fb			ld (debug_mark),a  
46d6 3a e5 46			ld a, (.dmark+1)  
46d9 32 be fb			ld (debug_mark+1),a  
46dc 3a e6 46			ld a, (.dmark+2)  
46df 32 bf fb			ld (debug_mark+2),a  
46e2 18 03			jr .pastdmark  
46e4 ..			.dmark: db "BR1"  
46e7 f1			.pastdmark: pop af  
46e8			endm  
# End of macro DMARK
46e8						CALLMONITOR 
46e8 cd 6a 16			call break_point_state  
46eb				endm  
# End of macro CALLMONITOR
46eb					endif 
46eb			 
46eb cd 09 03			call storage_read_block 
46ee			 
46ee 21 ea f9		        ld hl, store_page+2 
46f1					if DEBUG_FORTH_WORDS 
46f1						DMARK "BR2" 
46f1 f5				push af  
46f2 3a 06 47			ld a, (.dmark)  
46f5 32 bd fb			ld (debug_mark),a  
46f8 3a 07 47			ld a, (.dmark+1)  
46fb 32 be fb			ld (debug_mark+1),a  
46fe 3a 08 47			ld a, (.dmark+2)  
4701 32 bf fb			ld (debug_mark+2),a  
4704 18 03			jr .pastdmark  
4706 ..			.dmark: db "BR2"  
4709 f1			.pastdmark: pop af  
470a			endm  
# End of macro DMARK
470a						CALLMONITOR 
470a cd 6a 16			call break_point_state  
470d				endm  
# End of macro CALLMONITOR
470d					endif 
470d cd 65 1c			call forth_push_str 
4710			 
4710			 
4710					NEXTW 
4710 c3 60 1f			jp macro_next 
4713				endm 
# End of macro NEXTW
4713			.BWRITE: 
4713				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4713 3a				db WORD_SYS_CORE+38             
4714 a8 47			dw .BUPD            
4716 07				db 6 + 1 
4717 .. 00			db "BWRITE",0              
471e				endm 
# End of macro CWHEAD
471e			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | DONE 
471e			 
471e					if DEBUG_FORTH_WORDS_KEY 
471e						DMARK "BWR" 
471e f5				push af  
471f 3a 33 47			ld a, (.dmark)  
4722 32 bd fb			ld (debug_mark),a  
4725 3a 34 47			ld a, (.dmark+1)  
4728 32 be fb			ld (debug_mark+1),a  
472b 3a 35 47			ld a, (.dmark+2)  
472e 32 bf fb			ld (debug_mark+2),a  
4731 18 03			jr .pastdmark  
4733 ..			.dmark: db "BWR"  
4736 f1			.pastdmark: pop af  
4737			endm  
# End of macro DMARK
4737						CALLMONITOR 
4737 cd 6a 16			call break_point_state  
473a				endm  
# End of macro CALLMONITOR
473a					endif 
473a			 
473a				FORTH_DSP_VALUEHL 
473a cd ee 1d			call macro_dsp_valuehl 
473d				endm 
# End of macro FORTH_DSP_VALUEHL
473d			 
473d				; calc block address 
473d			 
473d eb				ex de, hl 
473e 3e 40			ld a, STORE_BLOCK_PHY 
4740 cd 89 0c			call Mult16 
4743			 
4743 e5				push hl         ; address 
4744			 
4744				FORTH_DSP_POP 
4744 cd a6 1e			call macro_forth_dsp_pop 
4747				endm 
# End of macro FORTH_DSP_POP
4747			 
4747				FORTH_DSP_VALUEHL 
4747 cd ee 1d			call macro_dsp_valuehl 
474a				endm 
# End of macro FORTH_DSP_VALUEHL
474a			 
474a				FORTH_DSP_POP 
474a cd a6 1e			call macro_forth_dsp_pop 
474d				endm 
# End of macro FORTH_DSP_POP
474d			 
474d cd 15 0a			call storage_clear_page 
4750			 
4750				; copy string to store page 
4750			 
4750 e5				push hl     ; save string address 
4751			 
4751 3e 00			ld a, 0 
4753 cd 6f 11			call strlent 
4756			 
4756 23				inc hl 
4757			 
4757 4d				ld c, l 
4758 06 00			ld b, 0 
475a			 
475a e1				pop hl 
475b 11 ea f9			ld de, store_page + 2 
475e					if DEBUG_FORTH_WORDS 
475e						DMARK "BW1" 
475e f5				push af  
475f 3a 73 47			ld a, (.dmark)  
4762 32 bd fb			ld (debug_mark),a  
4765 3a 74 47			ld a, (.dmark+1)  
4768 32 be fb			ld (debug_mark+1),a  
476b 3a 75 47			ld a, (.dmark+2)  
476e 32 bf fb			ld (debug_mark+2),a  
4771 18 03			jr .pastdmark  
4773 ..			.dmark: db "BW1"  
4776 f1			.pastdmark: pop af  
4777			endm  
# End of macro DMARK
4777						CALLMONITOR 
4777 cd 6a 16			call break_point_state  
477a				endm  
# End of macro CALLMONITOR
477a					endif 
477a ed b0			ldir 
477c			 
477c			 
477c				; poke the start of the block with flags to prevent high level file ops hitting the block 
477c			 
477c 21 ff ff			ld hl, $ffff 
477f			 
477f 22 e8 f9			ld (store_page), hl	 
4782				 
4782 e1				pop hl    ; get address 
4783 11 e8 f9			ld de, store_page 
4786			 
4786					if DEBUG_FORTH_WORDS 
4786						DMARK "BW2" 
4786 f5				push af  
4787 3a 9b 47			ld a, (.dmark)  
478a 32 bd fb			ld (debug_mark),a  
478d 3a 9c 47			ld a, (.dmark+1)  
4790 32 be fb			ld (debug_mark+1),a  
4793 3a 9d 47			ld a, (.dmark+2)  
4796 32 bf fb			ld (debug_mark+2),a  
4799 18 03			jr .pastdmark  
479b ..			.dmark: db "BW2"  
479e f1			.pastdmark: pop af  
479f			endm  
# End of macro DMARK
479f						CALLMONITOR 
479f cd 6a 16			call break_point_state  
47a2				endm  
# End of macro CALLMONITOR
47a2					endif 
47a2			 
47a2 cd 6e 03			call storage_write_block 
47a5			 
47a5					NEXTW 
47a5 c3 60 1f			jp macro_next 
47a8				endm 
# End of macro NEXTW
47a8			 
47a8			.BUPD: 
47a8				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
47a8 3a				db WORD_SYS_CORE+38             
47a9 fe 47			dw .BYID            
47ab 05				db 4 + 1 
47ac .. 00			db "BUPD",0              
47b1				endm 
# End of macro CWHEAD
47b1			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | DONE 
47b1			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
47b1			; | | or completely different file system structure. 
47b1			 
47b1					if DEBUG_FORTH_WORDS_KEY 
47b1						DMARK "BUD" 
47b1 f5				push af  
47b2 3a c6 47			ld a, (.dmark)  
47b5 32 bd fb			ld (debug_mark),a  
47b8 3a c7 47			ld a, (.dmark+1)  
47bb 32 be fb			ld (debug_mark+1),a  
47be 3a c8 47			ld a, (.dmark+2)  
47c1 32 bf fb			ld (debug_mark+2),a  
47c4 18 03			jr .pastdmark  
47c6 ..			.dmark: db "BUD"  
47c9 f1			.pastdmark: pop af  
47ca			endm  
# End of macro DMARK
47ca						CALLMONITOR 
47ca cd 6a 16			call break_point_state  
47cd				endm  
# End of macro CALLMONITOR
47cd					endif 
47cd			 
47cd				FORTH_DSP_VALUEHL 
47cd cd ee 1d			call macro_dsp_valuehl 
47d0				endm 
# End of macro FORTH_DSP_VALUEHL
47d0			 
47d0				; calc block address 
47d0			 
47d0 eb				ex de, hl 
47d1 3e 40			ld a, STORE_BLOCK_PHY 
47d3 cd 89 0c			call Mult16 
47d6			 
47d6				FORTH_DSP_POP 
47d6 cd a6 1e			call macro_forth_dsp_pop 
47d9				endm 
# End of macro FORTH_DSP_POP
47d9			 
47d9			 
47d9 11 e8 f9			ld de, store_page 
47dc			 
47dc					if DEBUG_FORTH_WORDS 
47dc						DMARK "BUe" 
47dc f5				push af  
47dd 3a f1 47			ld a, (.dmark)  
47e0 32 bd fb			ld (debug_mark),a  
47e3 3a f2 47			ld a, (.dmark+1)  
47e6 32 be fb			ld (debug_mark+1),a  
47e9 3a f3 47			ld a, (.dmark+2)  
47ec 32 bf fb			ld (debug_mark+2),a  
47ef 18 03			jr .pastdmark  
47f1 ..			.dmark: db "BUe"  
47f4 f1			.pastdmark: pop af  
47f5			endm  
# End of macro DMARK
47f5						CALLMONITOR 
47f5 cd 6a 16			call break_point_state  
47f8				endm  
# End of macro CALLMONITOR
47f8					endif 
47f8			 
47f8 cd 6e 03			call storage_write_block 
47fb			 
47fb					NEXTW 
47fb c3 60 1f			jp macro_next 
47fe				endm 
# End of macro NEXTW
47fe			 
47fe			.BYID: 
47fe			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
47fe			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
47fe			; 
47fe			;		 
47fe			;		if DEBUG_FORTH_WORDS_KEY 
47fe			;			DMARK "BYID" 
47fe			;			CALLMONITOR 
47fe			;		endif 
47fe			; 
47fe			;		; get direct address 
47fe			; 
47fe			;		FORTH_DSP_VALUEHL 
47fe			; 
47fe			;		FORTH_DSP_POP 
47fe			; 
47fe			;	; calc block address 
47fe			; 
47fe			;	ex de, hl 
47fe			;	ld a, STORE_BLOCK_PHY 
47fe			;	call Mult16 
47fe			;	;	do BREAD with number as param 
47fe			;	; push the file name	 
47fe			;	ld de, store_page 
47fe			;	call storage_read_block 
47fe			 ;       ld hl, store_page+2 
47fe			; 
47fe			; 
47fe			;		NEXTW 
47fe			;.BYNAME: 
47fe			;	CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
47fe			;; > BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s > TODO 
47fe			;		NEXTW 
47fe			; 
47fe			.DIR: 
47fe				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
47fe 3a				db WORD_SYS_CORE+38             
47ff 02 49			dw .SAVE            
4801 04				db 3 + 1 
4802 .. 00			db "DIR",0              
4806				endm 
# End of macro CWHEAD
4806			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4806			 
4806					if DEBUG_FORTH_WORDS_KEY 
4806						DMARK "DIR" 
4806 f5				push af  
4807 3a 1b 48			ld a, (.dmark)  
480a 32 bd fb			ld (debug_mark),a  
480d 3a 1c 48			ld a, (.dmark+1)  
4810 32 be fb			ld (debug_mark+1),a  
4813 3a 1d 48			ld a, (.dmark+2)  
4816 32 bf fb			ld (debug_mark+2),a  
4819 18 03			jr .pastdmark  
481b ..			.dmark: db "DIR"  
481e f1			.pastdmark: pop af  
481f			endm  
# End of macro DMARK
481f						CALLMONITOR 
481f cd 6a 16			call break_point_state  
4822				endm  
# End of macro CALLMONITOR
4822					endif 
4822 cd ba 03			call storage_get_block_0 
4825			 
4825 21 e8 f9			ld hl, store_page     ; get current id count 
4828 46				ld b, (hl) 
4829 0e 00			ld c, 0    ; count of files   
482b					if DEBUG_FORTH_WORDS 
482b						DMARK "DI1" 
482b f5				push af  
482c 3a 40 48			ld a, (.dmark)  
482f 32 bd fb			ld (debug_mark),a  
4832 3a 41 48			ld a, (.dmark+1)  
4835 32 be fb			ld (debug_mark+1),a  
4838 3a 42 48			ld a, (.dmark+2)  
483b 32 bf fb			ld (debug_mark+2),a  
483e 18 03			jr .pastdmark  
4840 ..			.dmark: db "DI1"  
4843 f1			.pastdmark: pop af  
4844			endm  
# End of macro DMARK
4844						CALLMONITOR 
4844 cd 6a 16			call break_point_state  
4847				endm  
# End of macro CALLMONITOR
4847					endif 
4847			 
4847				; check for empty drive 
4847			 
4847 3e 00			ld a, 0 
4849 b8				cp b 
484a ca b8 48			jp z, .dirdone 
484d			 
484d				; for each of the current ids do a search for them and if found push to stack 
484d			 
484d c5			.diritem:	push bc 
484e 21 40 00				ld hl, STORE_BLOCK_PHY 
4851 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4853 58					ld e,b 
4854			 
4854			;		if DEBUG_FORTH_WORDS 
4854			;			DMARK "DI2" 
4854			;			CALLMONITOR 
4854			;		endif 
4854			 
4854 cd 2a 06				call storage_findnextid 
4857			 
4857			;		if DEBUG_FORTH_WORDS 
4857			;			DMARK "DI3" 
4857			;			CALLMONITOR 
4857			;		endif 
4857			 
4857					; if found hl will be non zero 
4857			 
4857 cd 2f 0d				call ishlzero 
485a			;		ld a, l 
485a			;		add h 
485a			; 
485a			;		cp 0 
485a 28 59				jr z, .dirnotfound 
485c			 
485c					; increase count 
485c			 
485c c1					pop bc	 
485d 0c					inc c 
485e c5					push bc 
485f					 
485f			 
485f					; get file header and push the file name 
485f			 
485f 11 e8 f9				ld de, store_page 
4862 cd 09 03				call storage_read_block 
4865			 
4865					; push file id to stack 
4865				 
4865 3a e8 f9				ld a, (store_page) 
4868 26 00				ld h, 0 
486a 6f					ld l, a 
486b cd f7 1b				call forth_push_numhl 
486e			 
486e					; push extent count to stack  
486e				 
486e 3a ea f9				ld a, (store_page+2) 
4871 26 00				ld h, 0 
4873 6f					ld l, a 
4874 cd f7 1b				call forth_push_numhl 
4877			 
4877					; push file name 
4877			 
4877 21 eb f9				ld hl, store_page+3 
487a					if DEBUG_FORTH_WORDS 
487a						DMARK "DI5" 
487a f5				push af  
487b 3a 8f 48			ld a, (.dmark)  
487e 32 bd fb			ld (debug_mark),a  
4881 3a 90 48			ld a, (.dmark+1)  
4884 32 be fb			ld (debug_mark+1),a  
4887 3a 91 48			ld a, (.dmark+2)  
488a 32 bf fb			ld (debug_mark+2),a  
488d 18 03			jr .pastdmark  
488f ..			.dmark: db "DI5"  
4892 f1			.pastdmark: pop af  
4893			endm  
# End of macro DMARK
4893						CALLMONITOR 
4893 cd 6a 16			call break_point_state  
4896				endm  
# End of macro CALLMONITOR
4896					endif 
4896 cd 65 1c				call forth_push_str 
4899					if DEBUG_FORTH_WORDS 
4899						DMARK "DI6" 
4899 f5				push af  
489a 3a ae 48			ld a, (.dmark)  
489d 32 bd fb			ld (debug_mark),a  
48a0 3a af 48			ld a, (.dmark+1)  
48a3 32 be fb			ld (debug_mark+1),a  
48a6 3a b0 48			ld a, (.dmark+2)  
48a9 32 bf fb			ld (debug_mark+2),a  
48ac 18 03			jr .pastdmark  
48ae ..			.dmark: db "DI6"  
48b1 f1			.pastdmark: pop af  
48b2			endm  
# End of macro DMARK
48b2						CALLMONITOR 
48b2 cd 6a 16			call break_point_state  
48b5				endm  
# End of macro CALLMONITOR
48b5					endif 
48b5			.dirnotfound: 
48b5 c1					pop bc     
48b6 10 95				djnz .diritem 
48b8				 
48b8			.dirdone:	 
48b8					if DEBUG_FORTH_WORDS 
48b8						DMARK "DI7" 
48b8 f5				push af  
48b9 3a cd 48			ld a, (.dmark)  
48bc 32 bd fb			ld (debug_mark),a  
48bf 3a ce 48			ld a, (.dmark+1)  
48c2 32 be fb			ld (debug_mark+1),a  
48c5 3a cf 48			ld a, (.dmark+2)  
48c8 32 bf fb			ld (debug_mark+2),a  
48cb 18 03			jr .pastdmark  
48cd ..			.dmark: db "DI7"  
48d0 f1			.pastdmark: pop af  
48d1			endm  
# End of macro DMARK
48d1						CALLMONITOR 
48d1 cd 6a 16			call break_point_state  
48d4				endm  
# End of macro CALLMONITOR
48d4					endif 
48d4			 
48d4					; push a count of the dir items found 
48d4			 
48d4 26 00				ld h, 0 
48d6 69					ld l, c 
48d7 cd f7 1b				call forth_push_numhl 
48da			 
48da					; push the bank label 
48da			 
48da cd ba 03				call storage_get_block_0 
48dd			 
48dd				 
48dd 21 eb f9		 		ld hl, store_page+3 
48e0			 
48e0					if DEBUG_FORTH_WORDS 
48e0						DMARK "DI8" 
48e0 f5				push af  
48e1 3a f5 48			ld a, (.dmark)  
48e4 32 bd fb			ld (debug_mark),a  
48e7 3a f6 48			ld a, (.dmark+1)  
48ea 32 be fb			ld (debug_mark+1),a  
48ed 3a f7 48			ld a, (.dmark+2)  
48f0 32 bf fb			ld (debug_mark+2),a  
48f3 18 03			jr .pastdmark  
48f5 ..			.dmark: db "DI8"  
48f8 f1			.pastdmark: pop af  
48f9			endm  
# End of macro DMARK
48f9						CALLMONITOR 
48f9 cd 6a 16			call break_point_state  
48fc				endm  
# End of macro CALLMONITOR
48fc					endif 
48fc cd 65 1c				call forth_push_str 
48ff			 
48ff			 
48ff				 
48ff					NEXTW 
48ff c3 60 1f			jp macro_next 
4902				endm 
# End of macro NEXTW
4902			.SAVE: 
4902			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4902			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4902			;		NEXTW 
4902			;.LOAD: 
4902			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4902			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4902			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4902			;; > > The LOAD command can not be used in any user words or compound lines. 
4902			; 
4902			;		; store_openext use it. If zero it is EOF 
4902			; 
4902			;		; read block from current stream id 
4902			;		; if the block does not contain zero term keep reading blocks until zero found 
4902			;		; push the block to stack 
4902			;		; save the block id to stream 
4902			; 
4902			; 
4902			;		FORTH_DSP_VALUEHL 
4902			; 
4902			;;		push hl 
4902			; 
4902			;	if DEBUG_STORESE 
4902			;		DMARK "LOA" 
4902			;		CALLMONITOR 
4902			;	endif 
4902			;		FORTH_DSP_POP 
4902			; 
4902			;;		pop hl 
4902			; 
4902			;		ld h, l 
4902			;		ld l, 0 
4902			; 
4902			;		push hl     ; stack holds current file id and extent to work with 
4902			; 
4902			; 
4902			;		ld de, store_page      ; get block zero of file 
4902			;	if DEBUG_STORESE 
4902			;		DMARK "LO0" 
4902			;		CALLMONITOR 
4902			;	endif 
4902			;		call storage_read 
4902			; 
4902			;		ld a, (store_page+2)    ; max extents for this file 
4902			;		ld  (store_openmaxext),a   ; get our limit 
4902			; 
4902			;	if DEBUG_STORESE 
4902			;		DMARK "LOE" 
4902			;		CALLMONITOR 
4902			;	endif 
4902			; 
4902			;; TODO dont know why max extents are not present 
4902			;;		cp 0 
4902			;;		jp z, .loadeof     ; dont read past eof 
4902			; 
4902			;;		ld a, 1   ; start from the head of the file 
4902			; 
4902			;.loadline:	pop hl 
4902			;		inc hl 
4902			;		ld  a, (store_openmaxext)   ; get our limit 
4902			;	if DEBUG_STORESE 
4902			;		DMARK "LOx" 
4902			;		CALLMONITOR 
4902			;	endif 
4902			;		inc a 
4902			;		cp l 
4902			;		jp z, .loadeof 
4902			;		push hl    ; save current extent 
4902			; 
4902			;		ld de, store_page 
4902			; 
4902			;	if DEBUG_STORESE 
4902			;		DMARK "LO1" 
4902			;		CALLMONITOR 
4902			;	endif 
4902			;		call storage_read 
4902			; 
4902			;	if DEBUG_STORESE 
4902			;		DMARK "LO2" 
4902			;		CALLMONITOR 
4902			;	endif 
4902			;	call ishlzero 
4902			;	ld a, l 
4902			;	add h 
4902			;	cp 0 
4902			;	jr z, .loadeof 
4902			; 
4902			;	; not eof so hl should point to data to exec 
4902			; 
4902			;	; will need to add the FORTH_END_BUFFER flag 
4902			 ; 
4902			;	ld hl, store_page+2 
4902			;	ld bc, 255 
4902			;	ld a, 0 
4902			;	cpir 
4902			;	if DEBUG_STORESE 
4902			;		DMARK "LOt" 
4902			;		CALLMONITOR 
4902			;	endif 
4902			;	dec hl 
4902			;	ld a, ' ' 
4902			;	ld (hl), a 
4902			;	inc hl 
4902			;	ld (hl), a 
4902			;	inc hl 
4902			;	ld (hl), a 
4902			;	inc hl 
4902			;	ld a, FORTH_END_BUFFER 
4902			;	ld (hl), a 
4902			; 
4902			;	; TODO handle more than a single block read 
4902			; 
4902			; 
4902			;	ld hl, store_page+2 
4902			; 
4902			;	ld (os_tok_ptr), hl 
4902			; 
4902			;	if DEBUG_STORESE 
4902			;		DMARK "LO3" 
4902			;		CALLMONITOR 
4902			;	endif 
4902			; 
4902			;	call forthparse 
4902			;	call forthexec 
4902			;	call forthexec_cleanup 
4902			; 
4902			;	; go to next extent 
4902			; 
4902			;	; get next block  or mark as eof 
4902			;	jp .loadline 
4902			; 
4902			; 
4902			; 
4902			;	       NEXTW 
4902			;.loadeof:	ld a, 0 
4902			;		ld (store_openext), a 
4902			; 
4902			;	if DEBUG_STORESE 
4902			;		DMARK "LOF" 
4902			;		CALLMONITOR 
4902			;	endif 
4902			;		ret 
4902			;		;NEXTW 
4902			;.BSAVE:   
4902			; 
4902			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4902			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4902			;		NEXTW 
4902			;.BLOAD: 
4902			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4902			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4902			;		NEXTW 
4902			;;;; counter gap 
4902			 
4902			 
4902			.SEO: 
4902				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4902 64				db WORD_SYS_CORE+80             
4903 21 49			dw .SEI            
4905 04				db 3 + 1 
4906 .. 00			db "SEO",0              
490a				endm 
# End of macro CWHEAD
490a			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
490a			 
490a					; get port 
490a			 
490a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
490a cd ee 1d			call macro_dsp_valuehl 
490d				endm 
# End of macro FORTH_DSP_VALUEHL
490d			 
490d e5					push hl    ; u2 - byte 
490e			 
490e					; destroy value TOS 
490e			 
490e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
490e cd a6 1e			call macro_forth_dsp_pop 
4911				endm 
# End of macro FORTH_DSP_POP
4911			 
4911					; get byte to send 
4911			 
4911					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4911 cd ee 1d			call macro_dsp_valuehl 
4914				endm 
# End of macro FORTH_DSP_VALUEHL
4914			 
4914 e5					push hl    ; u1 - addr 
4915			 
4915					; destroy value TOS 
4915			 
4915					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4915 cd a6 1e			call macro_forth_dsp_pop 
4918				endm 
# End of macro FORTH_DSP_POP
4918			 
4918					; one value on hl get other one back 
4918			 
4918 d1					pop de   ; u1 - byte 
4919			 
4919 e1					pop hl   ; u2 - addr 
491a			 
491a					; TODO Send SPI byte 
491a			 
491a			 
491a 7b					ld a, e 
491b cd e7 01				call se_writebyte 
491e			 
491e					 
491e			 
491e					NEXTW 
491e c3 60 1f			jp macro_next 
4921				endm 
# End of macro NEXTW
4921			 
4921			.SEI: 
4921				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4921 65				db WORD_SYS_CORE+81             
4922 3b 49			dw .SFREE            
4924 04				db 3 + 1 
4925 .. 00			db "SEI",0              
4929				endm 
# End of macro CWHEAD
4929			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4929			 
4929					; get port 
4929			 
4929					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4929 cd ee 1d			call macro_dsp_valuehl 
492c				endm 
# End of macro FORTH_DSP_VALUEHL
492c			 
492c			;		push hl 
492c			 
492c					; destroy value TOS 
492c			 
492c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
492c cd a6 1e			call macro_forth_dsp_pop 
492f				endm 
# End of macro FORTH_DSP_POP
492f			 
492f					; one value on hl get other one back 
492f			 
492f			;		pop hl 
492f			 
492f			 
492f					; TODO Get SPI byte 
492f			 
492f cd 89 02				call se_readbyte 
4932			 
4932 26 00				ld h, 0 
4934 6f					ld l, a 
4935 cd f7 1b				call forth_push_numhl 
4938			 
4938					NEXTW 
4938 c3 60 1f			jp macro_next 
493b				endm 
# End of macro NEXTW
493b			 
493b			.SFREE: 
493b				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
493b 67				db WORD_SYS_CORE+83             
493c 6a 49			dw .SIZE            
493e 06				db 5 + 1 
493f .. 00			db "FFREE",0              
4945				endm 
# End of macro CWHEAD
4945			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4945					if DEBUG_FORTH_WORDS_KEY 
4945						DMARK "FFR" 
4945 f5				push af  
4946 3a 5a 49			ld a, (.dmark)  
4949 32 bd fb			ld (debug_mark),a  
494c 3a 5b 49			ld a, (.dmark+1)  
494f 32 be fb			ld (debug_mark+1),a  
4952 3a 5c 49			ld a, (.dmark+2)  
4955 32 bf fb			ld (debug_mark+2),a  
4958 18 03			jr .pastdmark  
495a ..			.dmark: db "FFR"  
495d f1			.pastdmark: pop af  
495e			endm  
# End of macro DMARK
495e						CALLMONITOR 
495e cd 6a 16			call break_point_state  
4961				endm  
# End of macro CALLMONITOR
4961					endif 
4961			 
4961 cd c4 06				call storage_freeblocks 
4964			 
4964 cd f7 1b				call forth_push_numhl 
4967			 
4967				       NEXTW 
4967 c3 60 1f			jp macro_next 
496a				endm 
# End of macro NEXTW
496a			.SIZE: 
496a				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
496a 67				db WORD_SYS_CORE+83             
496b 9e 49			dw .CREATE            
496d 05				db 4 + 1 
496e .. 00			db "SIZE",0              
4973				endm 
# End of macro CWHEAD
4973			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4973					if DEBUG_FORTH_WORDS_KEY 
4973						DMARK "SIZ" 
4973 f5				push af  
4974 3a 88 49			ld a, (.dmark)  
4977 32 bd fb			ld (debug_mark),a  
497a 3a 89 49			ld a, (.dmark+1)  
497d 32 be fb			ld (debug_mark+1),a  
4980 3a 8a 49			ld a, (.dmark+2)  
4983 32 bf fb			ld (debug_mark+2),a  
4986 18 03			jr .pastdmark  
4988 ..			.dmark: db "SIZ"  
498b f1			.pastdmark: pop af  
498c			endm  
# End of macro DMARK
498c						CALLMONITOR 
498c cd 6a 16			call break_point_state  
498f				endm  
# End of macro CALLMONITOR
498f					endif 
498f			 
498f					FORTH_DSP_VALUEHL 
498f cd ee 1d			call macro_dsp_valuehl 
4992				endm 
# End of macro FORTH_DSP_VALUEHL
4992			;		push hl 
4992					FORTH_DSP_POP 
4992 cd a6 1e			call macro_forth_dsp_pop 
4995				endm 
# End of macro FORTH_DSP_POP
4995			;		pop hl 
4995 cd 38 03				call storage_file_size 
4998			 
4998 cd f7 1b				call forth_push_numhl 
499b			  
499b			 
499b				       NEXTW 
499b c3 60 1f			jp macro_next 
499e				endm 
# End of macro NEXTW
499e			 
499e			.CREATE: 
499e				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
499e 68				db WORD_SYS_CORE+84             
499f 0c 4a			dw .APPEND            
49a1 07				db 6 + 1 
49a2 .. 00			db "CREATE",0              
49a9				endm 
# End of macro CWHEAD
49a9			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
49a9			; | | e.g.  
49a9			; | | TestProgram CREATE 
49a9			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
49a9			; | |  
49a9			; | | Max file IDs are 255. 
49a9			; | |  
49a9					 
49a9					if DEBUG_FORTH_WORDS_KEY 
49a9						DMARK "CRT" 
49a9 f5				push af  
49aa 3a be 49			ld a, (.dmark)  
49ad 32 bd fb			ld (debug_mark),a  
49b0 3a bf 49			ld a, (.dmark+1)  
49b3 32 be fb			ld (debug_mark+1),a  
49b6 3a c0 49			ld a, (.dmark+2)  
49b9 32 bf fb			ld (debug_mark+2),a  
49bc 18 03			jr .pastdmark  
49be ..			.dmark: db "CRT"  
49c1 f1			.pastdmark: pop af  
49c2			endm  
# End of macro DMARK
49c2						CALLMONITOR 
49c2 cd 6a 16			call break_point_state  
49c5				endm  
# End of macro CALLMONITOR
49c5					endif 
49c5			;		call storage_get_block_0 
49c5			 
49c5					; TODO pop hl 
49c5			 
49c5					;v5 FORTH_DSP_VALUE 
49c5					FORTH_DSP_VALUE 
49c5 cd d7 1d			call macro_forth_dsp_value 
49c8				endm 
# End of macro FORTH_DSP_VALUE
49c8			 
49c8				if DEBUG_STORESE 
49c8					DMARK "CR1" 
49c8 f5				push af  
49c9 3a dd 49			ld a, (.dmark)  
49cc 32 bd fb			ld (debug_mark),a  
49cf 3a de 49			ld a, (.dmark+1)  
49d2 32 be fb			ld (debug_mark+1),a  
49d5 3a df 49			ld a, (.dmark+2)  
49d8 32 bf fb			ld (debug_mark+2),a  
49db 18 03			jr .pastdmark  
49dd ..			.dmark: db "CR1"  
49e0 f1			.pastdmark: pop af  
49e1			endm  
# End of macro DMARK
49e1					CALLMONITOR 
49e1 cd 6a 16			call break_point_state  
49e4				endm  
# End of macro CALLMONITOR
49e4				endif 
49e4			;		push hl 
49e4			;		FORTH_DSP_POP 
49e4			;		pop hl 
49e4			 
49e4			;		inc hl   ; move past the type marker 
49e4			 
49e4 cd fa 06				call storage_create 
49e7			 
49e7				if DEBUG_STORESE 
49e7					DMARK "CT1" 
49e7 f5				push af  
49e8 3a fc 49			ld a, (.dmark)  
49eb 32 bd fb			ld (debug_mark),a  
49ee 3a fd 49			ld a, (.dmark+1)  
49f1 32 be fb			ld (debug_mark+1),a  
49f4 3a fe 49			ld a, (.dmark+2)  
49f7 32 bf fb			ld (debug_mark+2),a  
49fa 18 03			jr .pastdmark  
49fc ..			.dmark: db "CT1"  
49ff f1			.pastdmark: pop af  
4a00			endm  
# End of macro DMARK
4a00					CALLMONITOR 
4a00 cd 6a 16			call break_point_state  
4a03				endm  
# End of macro CALLMONITOR
4a03				endif 
4a03			;		push hl 
4a03					FORTH_DSP_POP 
4a03 cd a6 1e			call macro_forth_dsp_pop 
4a06				endm 
# End of macro FORTH_DSP_POP
4a06			;		pop hl 
4a06					; push file id to stack 
4a06 cd f7 1b				call forth_push_numhl 
4a09			 
4a09			 
4a09			 
4a09				       NEXTW 
4a09 c3 60 1f			jp macro_next 
4a0c				endm 
# End of macro NEXTW
4a0c			 
4a0c			.APPEND: 
4a0c				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4a0c 69				db WORD_SYS_CORE+85             
4a0d 9d 4a			dw .SDEL            
4a0f 07				db 6 + 1 
4a10 .. 00			db "APPEND",0              
4a17				endm 
# End of macro CWHEAD
4a17			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4a17			; | | e.g. 
4a17			; | | Test CREATE      -> $01 
4a17			; | | "A string to add to file" $01 APPEND 
4a17			; | |  
4a17			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4a17					if DEBUG_FORTH_WORDS_KEY 
4a17						DMARK "APP" 
4a17 f5				push af  
4a18 3a 2c 4a			ld a, (.dmark)  
4a1b 32 bd fb			ld (debug_mark),a  
4a1e 3a 2d 4a			ld a, (.dmark+1)  
4a21 32 be fb			ld (debug_mark+1),a  
4a24 3a 2e 4a			ld a, (.dmark+2)  
4a27 32 bf fb			ld (debug_mark+2),a  
4a2a 18 03			jr .pastdmark  
4a2c ..			.dmark: db "APP"  
4a2f f1			.pastdmark: pop af  
4a30			endm  
# End of macro DMARK
4a30						CALLMONITOR 
4a30 cd 6a 16			call break_point_state  
4a33				endm  
# End of macro CALLMONITOR
4a33					endif 
4a33			 
4a33					FORTH_DSP_VALUEHL 
4a33 cd ee 1d			call macro_dsp_valuehl 
4a36				endm 
# End of macro FORTH_DSP_VALUEHL
4a36 e5					push hl 	; save file id 
4a37			 
4a37				if DEBUG_STORESE 
4a37					DMARK "AP1" 
4a37 f5				push af  
4a38 3a 4c 4a			ld a, (.dmark)  
4a3b 32 bd fb			ld (debug_mark),a  
4a3e 3a 4d 4a			ld a, (.dmark+1)  
4a41 32 be fb			ld (debug_mark+1),a  
4a44 3a 4e 4a			ld a, (.dmark+2)  
4a47 32 bf fb			ld (debug_mark+2),a  
4a4a 18 03			jr .pastdmark  
4a4c ..			.dmark: db "AP1"  
4a4f f1			.pastdmark: pop af  
4a50			endm  
# End of macro DMARK
4a50					CALLMONITOR 
4a50 cd 6a 16			call break_point_state  
4a53				endm  
# End of macro CALLMONITOR
4a53				endif 
4a53					FORTH_DSP_POP 
4a53 cd a6 1e			call macro_forth_dsp_pop 
4a56				endm 
# End of macro FORTH_DSP_POP
4a56			 
4a56					FORTH_DSP_VALUEHL 
4a56 cd ee 1d			call macro_dsp_valuehl 
4a59				endm 
# End of macro FORTH_DSP_VALUEHL
4a59					;v5 FORTH_DSP_VALUE 
4a59 e5					push hl 	; save ptr to string to save 
4a5a			 
4a5a				if DEBUG_STORESE 
4a5a					DMARK "AP1" 
4a5a f5				push af  
4a5b 3a 6f 4a			ld a, (.dmark)  
4a5e 32 bd fb			ld (debug_mark),a  
4a61 3a 70 4a			ld a, (.dmark+1)  
4a64 32 be fb			ld (debug_mark+1),a  
4a67 3a 71 4a			ld a, (.dmark+2)  
4a6a 32 bf fb			ld (debug_mark+2),a  
4a6d 18 03			jr .pastdmark  
4a6f ..			.dmark: db "AP1"  
4a72 f1			.pastdmark: pop af  
4a73			endm  
# End of macro DMARK
4a73					CALLMONITOR 
4a73 cd 6a 16			call break_point_state  
4a76				endm  
# End of macro CALLMONITOR
4a76				endif 
4a76					FORTH_DSP_POP 
4a76 cd a6 1e			call macro_forth_dsp_pop 
4a79				endm 
# End of macro FORTH_DSP_POP
4a79			 
4a79 d1					pop de 
4a7a e1					pop hl 
4a7b				if DEBUG_STORESE 
4a7b					DMARK "AP2" 
4a7b f5				push af  
4a7c 3a 90 4a			ld a, (.dmark)  
4a7f 32 bd fb			ld (debug_mark),a  
4a82 3a 91 4a			ld a, (.dmark+1)  
4a85 32 be fb			ld (debug_mark+1),a  
4a88 3a 92 4a			ld a, (.dmark+2)  
4a8b 32 bf fb			ld (debug_mark+2),a  
4a8e 18 03			jr .pastdmark  
4a90 ..			.dmark: db "AP2"  
4a93 f1			.pastdmark: pop af  
4a94			endm  
# End of macro DMARK
4a94					CALLMONITOR 
4a94 cd 6a 16			call break_point_state  
4a97				endm  
# End of macro CALLMONITOR
4a97				endif 
4a97					;inc de ; skip var type indicator 
4a97			 
4a97					; TODO how to append numerics???? 
4a97			 
4a97 cd d4 08				call storage_append		 
4a9a			 
4a9a				       NEXTW 
4a9a c3 60 1f			jp macro_next 
4a9d				endm 
# End of macro NEXTW
4a9d			.SDEL: 
4a9d				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4a9d 6a				db WORD_SYS_CORE+86             
4a9e e9 4a			dw .OPEN            
4aa0 05				db 4 + 1 
4aa1 .. 00			db "ERA",0              
4aa5				endm 
# End of macro CWHEAD
4aa5			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4aa5					FORTH_DSP_VALUEHL 
4aa5 cd ee 1d			call macro_dsp_valuehl 
4aa8				endm 
# End of macro FORTH_DSP_VALUEHL
4aa8			;		push hl 	; save file id 
4aa8			 
4aa8					if DEBUG_FORTH_WORDS_KEY 
4aa8						DMARK "ERA" 
4aa8 f5				push af  
4aa9 3a bd 4a			ld a, (.dmark)  
4aac 32 bd fb			ld (debug_mark),a  
4aaf 3a be 4a			ld a, (.dmark+1)  
4ab2 32 be fb			ld (debug_mark+1),a  
4ab5 3a bf 4a			ld a, (.dmark+2)  
4ab8 32 bf fb			ld (debug_mark+2),a  
4abb 18 03			jr .pastdmark  
4abd ..			.dmark: db "ERA"  
4ac0 f1			.pastdmark: pop af  
4ac1			endm  
# End of macro DMARK
4ac1						CALLMONITOR 
4ac1 cd 6a 16			call break_point_state  
4ac4				endm  
# End of macro CALLMONITOR
4ac4					endif 
4ac4				if DEBUG_STORESE 
4ac4					DMARK "ER1" 
4ac4 f5				push af  
4ac5 3a d9 4a			ld a, (.dmark)  
4ac8 32 bd fb			ld (debug_mark),a  
4acb 3a da 4a			ld a, (.dmark+1)  
4ace 32 be fb			ld (debug_mark+1),a  
4ad1 3a db 4a			ld a, (.dmark+2)  
4ad4 32 bf fb			ld (debug_mark+2),a  
4ad7 18 03			jr .pastdmark  
4ad9 ..			.dmark: db "ER1"  
4adc f1			.pastdmark: pop af  
4add			endm  
# End of macro DMARK
4add					CALLMONITOR 
4add cd 6a 16			call break_point_state  
4ae0				endm  
# End of macro CALLMONITOR
4ae0				endif 
4ae0					FORTH_DSP_POP 
4ae0 cd a6 1e			call macro_forth_dsp_pop 
4ae3				endm 
# End of macro FORTH_DSP_POP
4ae3			 
4ae3			;		pop hl 
4ae3			 
4ae3 cd 49 05				call storage_erase 
4ae6				       NEXTW 
4ae6 c3 60 1f			jp macro_next 
4ae9				endm 
# End of macro NEXTW
4ae9			 
4ae9			.OPEN: 
4ae9				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4ae9 6b				db WORD_SYS_CORE+87             
4aea 70 4b			dw .READ            
4aec 05				db 4 + 1 
4aed .. 00			db "OPEN",0              
4af2				endm 
# End of macro CWHEAD
4af2			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4af2			; | | e.g. 
4af2			; | | $01 OPEN $01 DO $01 READ . LOOP 
4af2			 
4af2					if DEBUG_FORTH_WORDS_KEY 
4af2						DMARK "OPN" 
4af2 f5				push af  
4af3 3a 07 4b			ld a, (.dmark)  
4af6 32 bd fb			ld (debug_mark),a  
4af9 3a 08 4b			ld a, (.dmark+1)  
4afc 32 be fb			ld (debug_mark+1),a  
4aff 3a 09 4b			ld a, (.dmark+2)  
4b02 32 bf fb			ld (debug_mark+2),a  
4b05 18 03			jr .pastdmark  
4b07 ..			.dmark: db "OPN"  
4b0a f1			.pastdmark: pop af  
4b0b			endm  
# End of macro DMARK
4b0b						CALLMONITOR 
4b0b cd 6a 16			call break_point_state  
4b0e				endm  
# End of macro CALLMONITOR
4b0e					endif 
4b0e					; TODO handle multiple file opens 
4b0e			 
4b0e 3e 01			       	ld a, 1 
4b10 32 df f9				ld (store_openext), a 
4b13			 
4b13					; get max extents for this file 
4b13				 
4b13								 
4b13					FORTH_DSP_VALUEHL 
4b13 cd ee 1d			call macro_dsp_valuehl 
4b16				endm 
# End of macro FORTH_DSP_VALUEHL
4b16			 
4b16 65					ld h, l 
4b17 2e 00				ld l, 0 
4b19			 
4b19				if DEBUG_STORESE 
4b19					DMARK "OPN" 
4b19 f5				push af  
4b1a 3a 2e 4b			ld a, (.dmark)  
4b1d 32 bd fb			ld (debug_mark),a  
4b20 3a 2f 4b			ld a, (.dmark+1)  
4b23 32 be fb			ld (debug_mark+1),a  
4b26 3a 30 4b			ld a, (.dmark+2)  
4b29 32 bf fb			ld (debug_mark+2),a  
4b2c 18 03			jr .pastdmark  
4b2e ..			.dmark: db "OPN"  
4b31 f1			.pastdmark: pop af  
4b32			endm  
# End of macro DMARK
4b32					CALLMONITOR 
4b32 cd 6a 16			call break_point_state  
4b35				endm  
# End of macro CALLMONITOR
4b35				endif 
4b35			;		push hl 
4b35					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4b35 cd a6 1e			call macro_forth_dsp_pop 
4b38				endm 
# End of macro FORTH_DSP_POP
4b38			;		pop hl 
4b38						 
4b38 11 e8 f9				ld de, store_page      ; get block zero of file 
4b3b cd 4e 08				call storage_read 
4b3e			 
4b3e			 
4b3e 3a ea f9				ld a, (store_page+2)    ; max extents for this file 
4b41 32 de f9				ld  (store_openmaxext), a   ; get our limit and push 
4b44					 
4b44				if DEBUG_STORESE 
4b44					DMARK "OPx" 
4b44 f5				push af  
4b45 3a 59 4b			ld a, (.dmark)  
4b48 32 bd fb			ld (debug_mark),a  
4b4b 3a 5a 4b			ld a, (.dmark+1)  
4b4e 32 be fb			ld (debug_mark+1),a  
4b51 3a 5b 4b			ld a, (.dmark+2)  
4b54 32 bf fb			ld (debug_mark+2),a  
4b57 18 03			jr .pastdmark  
4b59 ..			.dmark: db "OPx"  
4b5c f1			.pastdmark: pop af  
4b5d			endm  
# End of macro DMARK
4b5d					CALLMONITOR 
4b5d cd 6a 16			call break_point_state  
4b60				endm  
# End of macro CALLMONITOR
4b60				endif 
4b60 fe 00				cp 0 
4b62 20 03				jr nz, .skipopeneof 
4b64					; have opened an empty file 
4b64					 
4b64 32 df f9				ld (store_openext), a 
4b67			 
4b67			.skipopeneof: 
4b67			 
4b67 6f					ld l, a 
4b68 26 00				ld h, 0 
4b6a cd f7 1b				call forth_push_numhl 
4b6d			 
4b6d			 
4b6d				       NEXTW 
4b6d c3 60 1f			jp macro_next 
4b70				endm 
# End of macro NEXTW
4b70			.READ: 
4b70				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4b70 6c				db WORD_SYS_CORE+88             
4b71 b7 4c			dw .EOF            
4b73 05				db 4 + 1 
4b74 .. 00			db "READ",0              
4b79				endm 
# End of macro CWHEAD
4b79			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4b79			; | | e.g. 
4b79			; | | $01 OPEN $01 DO $01 READ . LOOP 
4b79			 
4b79					if DEBUG_FORTH_WORDS_KEY 
4b79						DMARK "REA" 
4b79 f5				push af  
4b7a 3a 8e 4b			ld a, (.dmark)  
4b7d 32 bd fb			ld (debug_mark),a  
4b80 3a 8f 4b			ld a, (.dmark+1)  
4b83 32 be fb			ld (debug_mark+1),a  
4b86 3a 90 4b			ld a, (.dmark+2)  
4b89 32 bf fb			ld (debug_mark+2),a  
4b8c 18 03			jr .pastdmark  
4b8e ..			.dmark: db "REA"  
4b91 f1			.pastdmark: pop af  
4b92			endm  
# End of macro DMARK
4b92						CALLMONITOR 
4b92 cd 6a 16			call break_point_state  
4b95				endm  
# End of macro CALLMONITOR
4b95					endif 
4b95					; store_openext use it. If zero it is EOF 
4b95			 
4b95					; read block from current stream id 
4b95					; if the block does not contain zero term keep reading blocks until zero found 
4b95					; push the block to stack 
4b95					; save the block id to stream 
4b95			 
4b95			 
4b95					FORTH_DSP_VALUEHL 
4b95 cd ee 1d			call macro_dsp_valuehl 
4b98				endm 
# End of macro FORTH_DSP_VALUEHL
4b98			 
4b98			;		push hl 
4b98			 
4b98				if DEBUG_STORESE 
4b98					DMARK "REA" 
4b98 f5				push af  
4b99 3a ad 4b			ld a, (.dmark)  
4b9c 32 bd fb			ld (debug_mark),a  
4b9f 3a ae 4b			ld a, (.dmark+1)  
4ba2 32 be fb			ld (debug_mark+1),a  
4ba5 3a af 4b			ld a, (.dmark+2)  
4ba8 32 bf fb			ld (debug_mark+2),a  
4bab 18 03			jr .pastdmark  
4bad ..			.dmark: db "REA"  
4bb0 f1			.pastdmark: pop af  
4bb1			endm  
# End of macro DMARK
4bb1					CALLMONITOR 
4bb1 cd 6a 16			call break_point_state  
4bb4				endm  
# End of macro CALLMONITOR
4bb4				endif 
4bb4					FORTH_DSP_POP 
4bb4 cd a6 1e			call macro_forth_dsp_pop 
4bb7				endm 
# End of macro FORTH_DSP_POP
4bb7			 
4bb7			;		pop hl 
4bb7				 
4bb7 65					ld h,l 
4bb8			 
4bb8 3a df f9				ld a, (store_openext) 
4bbb 6f					ld l, a 
4bbc					 
4bbc fe 00				cp 0 
4bbe ca 89 4c				jp z, .ateof     ; dont read past eof 
4bc1			 
4bc1			 
4bc1 11 e8 f9				ld de, store_page 
4bc4				if DEBUG_STORESE 
4bc4					DMARK "RE1" 
4bc4 f5				push af  
4bc5 3a d9 4b			ld a, (.dmark)  
4bc8 32 bd fb			ld (debug_mark),a  
4bcb 3a da 4b			ld a, (.dmark+1)  
4bce 32 be fb			ld (debug_mark+1),a  
4bd1 3a db 4b			ld a, (.dmark+2)  
4bd4 32 bf fb			ld (debug_mark+2),a  
4bd7 18 03			jr .pastdmark  
4bd9 ..			.dmark: db "RE1"  
4bdc f1			.pastdmark: pop af  
4bdd			endm  
# End of macro DMARK
4bdd					CALLMONITOR 
4bdd cd 6a 16			call break_point_state  
4be0				endm  
# End of macro CALLMONITOR
4be0				endif 
4be0 cd 4e 08				call storage_read 
4be3			 
4be3				if DEBUG_STORESE 
4be3					DMARK "RE2" 
4be3 f5				push af  
4be4 3a f8 4b			ld a, (.dmark)  
4be7 32 bd fb			ld (debug_mark),a  
4bea 3a f9 4b			ld a, (.dmark+1)  
4bed 32 be fb			ld (debug_mark+1),a  
4bf0 3a fa 4b			ld a, (.dmark+2)  
4bf3 32 bf fb			ld (debug_mark+2),a  
4bf6 18 03			jr .pastdmark  
4bf8 ..			.dmark: db "RE2"  
4bfb f1			.pastdmark: pop af  
4bfc			endm  
# End of macro DMARK
4bfc					CALLMONITOR 
4bfc cd 6a 16			call break_point_state  
4bff				endm  
# End of macro CALLMONITOR
4bff				endif 
4bff cd 2f 0d			call ishlzero 
4c02			;	ld a, l 
4c02			;	add h 
4c02			;	cp 0 
4c02 ca 8f 4c			jp z, .readeof 
4c05			 
4c05				; not eof so hl should point to data to push to stack 
4c05			 
4c05				if DEBUG_STORESE 
4c05					DMARK "RE3" 
4c05 f5				push af  
4c06 3a 1a 4c			ld a, (.dmark)  
4c09 32 bd fb			ld (debug_mark),a  
4c0c 3a 1b 4c			ld a, (.dmark+1)  
4c0f 32 be fb			ld (debug_mark+1),a  
4c12 3a 1c 4c			ld a, (.dmark+2)  
4c15 32 bf fb			ld (debug_mark+2),a  
4c18 18 03			jr .pastdmark  
4c1a ..			.dmark: db "RE3"  
4c1d f1			.pastdmark: pop af  
4c1e			endm  
# End of macro DMARK
4c1e					CALLMONITOR 
4c1e cd 6a 16			call break_point_state  
4c21				endm  
# End of macro CALLMONITOR
4c21				endif 
4c21 cd 65 1c			call forth_push_str 
4c24			 
4c24				if DEBUG_STORESE 
4c24					DMARK "RE4" 
4c24 f5				push af  
4c25 3a 39 4c			ld a, (.dmark)  
4c28 32 bd fb			ld (debug_mark),a  
4c2b 3a 3a 4c			ld a, (.dmark+1)  
4c2e 32 be fb			ld (debug_mark+1),a  
4c31 3a 3b 4c			ld a, (.dmark+2)  
4c34 32 bf fb			ld (debug_mark+2),a  
4c37 18 03			jr .pastdmark  
4c39 ..			.dmark: db "RE4"  
4c3c f1			.pastdmark: pop af  
4c3d			endm  
# End of macro DMARK
4c3d					CALLMONITOR 
4c3d cd 6a 16			call break_point_state  
4c40				endm  
# End of macro CALLMONITOR
4c40				endif 
4c40				; get next block  or mark as eof 
4c40			 
4c40 3a de f9			ld a, (store_openmaxext)   ; get our limit 
4c43 4f				ld c, a	 
4c44 3a df f9			ld a, (store_openext) 
4c47			 
4c47				if DEBUG_STORESE 
4c47					DMARK "RE5" 
4c47 f5				push af  
4c48 3a 5c 4c			ld a, (.dmark)  
4c4b 32 bd fb			ld (debug_mark),a  
4c4e 3a 5d 4c			ld a, (.dmark+1)  
4c51 32 be fb			ld (debug_mark+1),a  
4c54 3a 5e 4c			ld a, (.dmark+2)  
4c57 32 bf fb			ld (debug_mark+2),a  
4c5a 18 03			jr .pastdmark  
4c5c ..			.dmark: db "RE5"  
4c5f f1			.pastdmark: pop af  
4c60			endm  
# End of macro DMARK
4c60					CALLMONITOR 
4c60 cd 6a 16			call break_point_state  
4c63				endm  
# End of macro CALLMONITOR
4c63				endif 
4c63 b9				cp c 
4c64 28 29			jr z, .readeof     ; at last extent 
4c66			 
4c66 3c					inc a 
4c67 32 df f9				ld (store_openext), a 
4c6a			 
4c6a				if DEBUG_STORESE 
4c6a					DMARK "RE6" 
4c6a f5				push af  
4c6b 3a 7f 4c			ld a, (.dmark)  
4c6e 32 bd fb			ld (debug_mark),a  
4c71 3a 80 4c			ld a, (.dmark+1)  
4c74 32 be fb			ld (debug_mark+1),a  
4c77 3a 81 4c			ld a, (.dmark+2)  
4c7a 32 bf fb			ld (debug_mark+2),a  
4c7d 18 03			jr .pastdmark  
4c7f ..			.dmark: db "RE6"  
4c82 f1			.pastdmark: pop af  
4c83			endm  
# End of macro DMARK
4c83					CALLMONITOR 
4c83 cd 6a 16			call break_point_state  
4c86				endm  
# End of macro CALLMONITOR
4c86				endif 
4c86			 
4c86			 
4c86				       NEXTW 
4c86 c3 60 1f			jp macro_next 
4c89				endm 
# End of macro NEXTW
4c89			.ateof: 
4c89 21 b3 4c				ld hl, .showeof 
4c8c cd 65 1c				call forth_push_str 
4c8f 3e 00		.readeof:	ld a, 0 
4c91 32 df f9				ld (store_openext), a 
4c94			 
4c94					 
4c94				if DEBUG_STORESE 
4c94					DMARK "REF" 
4c94 f5				push af  
4c95 3a a9 4c			ld a, (.dmark)  
4c98 32 bd fb			ld (debug_mark),a  
4c9b 3a aa 4c			ld a, (.dmark+1)  
4c9e 32 be fb			ld (debug_mark+1),a  
4ca1 3a ab 4c			ld a, (.dmark+2)  
4ca4 32 bf fb			ld (debug_mark+2),a  
4ca7 18 03			jr .pastdmark  
4ca9 ..			.dmark: db "REF"  
4cac f1			.pastdmark: pop af  
4cad			endm  
# End of macro DMARK
4cad					CALLMONITOR 
4cad cd 6a 16			call break_point_state  
4cb0				endm  
# End of macro CALLMONITOR
4cb0				endif 
4cb0				       NEXTW 
4cb0 c3 60 1f			jp macro_next 
4cb3				endm 
# End of macro NEXTW
4cb3			 
4cb3 .. 00		.showeof:   db "eof", 0 
4cb7			 
4cb7			 
4cb7			.EOF: 
4cb7				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4cb7 6d				db WORD_SYS_CORE+89             
4cb8 f8 4c			dw .FORMAT            
4cba 04				db 3 + 1 
4cbb .. 00			db "EOF",0              
4cbf				endm 
# End of macro CWHEAD
4cbf			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4cbf			; | | e.g. 
4cbf			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4cbf					; TODO if current block id for stream is zero then push true else false 
4cbf			 
4cbf					if DEBUG_FORTH_WORDS_KEY 
4cbf						DMARK "EOF" 
4cbf f5				push af  
4cc0 3a d4 4c			ld a, (.dmark)  
4cc3 32 bd fb			ld (debug_mark),a  
4cc6 3a d5 4c			ld a, (.dmark+1)  
4cc9 32 be fb			ld (debug_mark+1),a  
4ccc 3a d6 4c			ld a, (.dmark+2)  
4ccf 32 bf fb			ld (debug_mark+2),a  
4cd2 18 03			jr .pastdmark  
4cd4 ..			.dmark: db "EOF"  
4cd7 f1			.pastdmark: pop af  
4cd8			endm  
# End of macro DMARK
4cd8						CALLMONITOR 
4cd8 cd 6a 16			call break_point_state  
4cdb				endm  
# End of macro CALLMONITOR
4cdb					endif 
4cdb			 
4cdb					; TODO handlue multiple file streams 
4cdb			 
4cdb					FORTH_DSP_POP     ; for now just get rid of stream id 
4cdb cd a6 1e			call macro_forth_dsp_pop 
4cde				endm 
# End of macro FORTH_DSP_POP
4cde			 
4cde 2e 01				ld l, 1 
4ce0 3a de f9				ld a, (store_openmaxext) 
4ce3 fe 00				cp 0 
4ce5 28 09				jr  z, .eofdone   ; empty file 
4ce7 3a df f9				ld a, (store_openext) 
4cea fe 00				cp 0 
4cec 28 02				jr  z, .eofdone 
4cee 2e 00				ld l, 0 
4cf0 26 00		.eofdone:	ld h, 0 
4cf2 cd f7 1b				call forth_push_numhl 
4cf5			 
4cf5			 
4cf5				       NEXTW 
4cf5 c3 60 1f			jp macro_next 
4cf8				endm 
# End of macro NEXTW
4cf8			 
4cf8			.FORMAT: 
4cf8				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4cf8 6d				db WORD_SYS_CORE+89             
4cf9 49 4d			dw .LABEL            
4cfb 07				db 6 + 1 
4cfc .. 00			db "FORMAT",0              
4d03				endm 
# End of macro CWHEAD
4d03			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4d03					; TODO if current block id for stream is zero then push true else false 
4d03				 
4d03				if DEBUG_STORESE 
4d03					DMARK "FOR" 
4d03 f5				push af  
4d04 3a 18 4d			ld a, (.dmark)  
4d07 32 bd fb			ld (debug_mark),a  
4d0a 3a 19 4d			ld a, (.dmark+1)  
4d0d 32 be fb			ld (debug_mark+1),a  
4d10 3a 1a 4d			ld a, (.dmark+2)  
4d13 32 bf fb			ld (debug_mark+2),a  
4d16 18 03			jr .pastdmark  
4d18 ..			.dmark: db "FOR"  
4d1b f1			.pastdmark: pop af  
4d1c			endm  
# End of macro DMARK
4d1c					CALLMONITOR 
4d1c cd 6a 16			call break_point_state  
4d1f				endm  
# End of macro CALLMONITOR
4d1f				endif 
4d1f					; Wipes the bank check flags to cause a reformat on next block 0 read 
4d1f			 
4d1f 21 01 00				ld hl, 1 
4d22 3e 00				ld a, 0 
4d24 cd e7 01				call se_writebyte 
4d27			 
4d27				if DEBUG_STORESE 
4d27					DMARK "FO0" 
4d27 f5				push af  
4d28 3a 3c 4d			ld a, (.dmark)  
4d2b 32 bd fb			ld (debug_mark),a  
4d2e 3a 3d 4d			ld a, (.dmark+1)  
4d31 32 be fb			ld (debug_mark+1),a  
4d34 3a 3e 4d			ld a, (.dmark+2)  
4d37 32 bf fb			ld (debug_mark+2),a  
4d3a 18 03			jr .pastdmark  
4d3c ..			.dmark: db "FO0"  
4d3f f1			.pastdmark: pop af  
4d40			endm  
# End of macro DMARK
4d40					CALLMONITOR 
4d40 cd 6a 16			call break_point_state  
4d43				endm  
# End of macro CALLMONITOR
4d43				endif 
4d43					; force bank init 
4d43			 
4d43 cd ba 03				call storage_get_block_0 
4d46					 
4d46				       NEXTW 
4d46 c3 60 1f			jp macro_next 
4d49				endm 
# End of macro NEXTW
4d49			.LABEL: 
4d49				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4d49 6d				db WORD_SYS_CORE+89             
4d4a 97 4d			dw .STOREPAGE            
4d4c 06				db 5 + 1 
4d4d .. 00			db "LABEL",0              
4d53				endm 
# End of macro CWHEAD
4d53			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4d53					; TODO test to see if bank is selected 
4d53				 
4d53					if DEBUG_FORTH_WORDS_KEY 
4d53						DMARK "LBL" 
4d53 f5				push af  
4d54 3a 68 4d			ld a, (.dmark)  
4d57 32 bd fb			ld (debug_mark),a  
4d5a 3a 69 4d			ld a, (.dmark+1)  
4d5d 32 be fb			ld (debug_mark+1),a  
4d60 3a 6a 4d			ld a, (.dmark+2)  
4d63 32 bf fb			ld (debug_mark+2),a  
4d66 18 03			jr .pastdmark  
4d68 ..			.dmark: db "LBL"  
4d6b f1			.pastdmark: pop af  
4d6c			endm  
# End of macro DMARK
4d6c						CALLMONITOR 
4d6c cd 6a 16			call break_point_state  
4d6f				endm  
# End of macro CALLMONITOR
4d6f					endif 
4d6f			;	if DEBUG_STORESE 
4d6f			;		DMARK "LBL" 
4d6f			;		CALLMONITOR 
4d6f			;	endif 
4d6f					FORTH_DSP_VALUEHL 
4d6f cd ee 1d			call macro_dsp_valuehl 
4d72				endm 
# End of macro FORTH_DSP_VALUEHL
4d72					;v5FORTH_DSP_VALUE 
4d72					 
4d72			;		push hl 
4d72					FORTH_DSP_POP 
4d72 cd a6 1e			call macro_forth_dsp_pop 
4d75				endm 
# End of macro FORTH_DSP_POP
4d75			;		pop hl 
4d75			 
4d75			;v5		inc hl   ; move past the type marker 
4d75			 
4d75				if DEBUG_STORESE 
4d75					DMARK "LBl" 
4d75 f5				push af  
4d76 3a 8a 4d			ld a, (.dmark)  
4d79 32 bd fb			ld (debug_mark),a  
4d7c 3a 8b 4d			ld a, (.dmark+1)  
4d7f 32 be fb			ld (debug_mark+1),a  
4d82 3a 8c 4d			ld a, (.dmark+2)  
4d85 32 bf fb			ld (debug_mark+2),a  
4d88 18 03			jr .pastdmark  
4d8a ..			.dmark: db "LBl"  
4d8d f1			.pastdmark: pop af  
4d8e			endm  
# End of macro DMARK
4d8e					CALLMONITOR 
4d8e cd 6a 16			call break_point_state  
4d91				endm  
# End of macro CALLMONITOR
4d91				endif 
4d91 cd de 04				call storage_label 
4d94			 
4d94				       NEXTW 
4d94 c3 60 1f			jp macro_next 
4d97				endm 
# End of macro NEXTW
4d97			.STOREPAGE: 
4d97				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4d97 6d				db WORD_SYS_CORE+89             
4d98 ca 4d			dw .LABELS            
4d9a 0a				db 9 + 1 
4d9b .. 00			db "STOREPAGE",0              
4da5				endm 
# End of macro CWHEAD
4da5			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4da5					; TODO test to see if bank is selected 
4da5				 
4da5					if DEBUG_FORTH_WORDS_KEY 
4da5						DMARK "STP" 
4da5 f5				push af  
4da6 3a ba 4d			ld a, (.dmark)  
4da9 32 bd fb			ld (debug_mark),a  
4dac 3a bb 4d			ld a, (.dmark+1)  
4daf 32 be fb			ld (debug_mark+1),a  
4db2 3a bc 4d			ld a, (.dmark+2)  
4db5 32 bf fb			ld (debug_mark+2),a  
4db8 18 03			jr .pastdmark  
4dba ..			.dmark: db "STP"  
4dbd f1			.pastdmark: pop af  
4dbe			endm  
# End of macro DMARK
4dbe						CALLMONITOR 
4dbe cd 6a 16			call break_point_state  
4dc1				endm  
# End of macro CALLMONITOR
4dc1					endif 
4dc1			;	if DEBUG_STORESE 
4dc1			;		DMARK "STP" 
4dc1			;		CALLMONITOR 
4dc1			;	endif 
4dc1			 
4dc1 21 e8 f9			ld hl, store_page 
4dc4 cd f7 1b			call forth_push_numhl 
4dc7			 
4dc7			 
4dc7				       NEXTW 
4dc7 c3 60 1f			jp macro_next 
4dca				endm 
# End of macro NEXTW
4dca			.LABELS: 
4dca				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4dca 6d				db WORD_SYS_CORE+89             
4dcb 54 4e			dw .ENDSTORAGE            
4dcd 07				db 6 + 1 
4dce .. 00			db "LABELS",0              
4dd5				endm 
# End of macro CWHEAD
4dd5			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4dd5					;  
4dd5			 
4dd5					; save the current device selected to restore afterwards 
4dd5				 
4dd5 3a ce f9				ld a, (spi_device) 
4dd8 f5					push af 
4dd9			 
4dd9			 
4dd9					; run through each of the banks 
4dd9			 
4dd9 21 01 00				ld hl, 1 
4ddc cd f7 1b				call forth_push_numhl 
4ddf 3e ff				ld a, SPI_CE_HIGH 
4de1 cb 87				res SPI_CE0, a 
4de3 32 ce f9				ld (spi_device), a 
4de6 cd ba 03				call storage_get_block_0 
4de9 21 eb f9				ld hl, store_page+3 
4dec cd 65 1c				call forth_push_str 
4def			 
4def					 
4def 21 02 00				ld hl, 2 
4df2 cd f7 1b				call forth_push_numhl 
4df5 3e ff				ld a, SPI_CE_HIGH 
4df7 cb 8f				res SPI_CE1, a 
4df9 32 ce f9				ld (spi_device), a 
4dfc cd ba 03				call storage_get_block_0 
4dff 21 eb f9				ld hl, store_page+3 
4e02 cd 65 1c				call forth_push_str 
4e05			 
4e05					 
4e05 21 03 00				ld hl, 3 
4e08 cd f7 1b				call forth_push_numhl 
4e0b 3e ff				ld a, SPI_CE_HIGH 
4e0d cb 97				res SPI_CE2, a 
4e0f 32 ce f9				ld (spi_device), a 
4e12 cd ba 03				call storage_get_block_0 
4e15 21 eb f9				ld hl, store_page+3 
4e18 cd 65 1c				call forth_push_str 
4e1b			 
4e1b			 
4e1b 21 04 00				ld hl, 4 
4e1e cd f7 1b				call forth_push_numhl 
4e21 3e ff				ld a, SPI_CE_HIGH 
4e23 cb 9f				res SPI_CE3, a 
4e25 32 ce f9				ld (spi_device), a 
4e28 cd ba 03				call storage_get_block_0 
4e2b 21 eb f9				ld hl, store_page+3 
4e2e cd 65 1c				call forth_push_str 
4e31			 
4e31					 
4e31			 
4e31 21 05 00				ld hl, 5 
4e34 cd f7 1b				call forth_push_numhl 
4e37 3e ff				ld a, SPI_CE_HIGH 
4e39 cb a7				res SPI_CE4, a 
4e3b 32 ce f9				ld (spi_device), a 
4e3e cd ba 03				call storage_get_block_0 
4e41 21 eb f9				ld hl, store_page+3 
4e44 cd 65 1c				call forth_push_str 
4e47			 
4e47					 
4e47					; push fixed count of storage devices (on board) for now 
4e47			 
4e47 21 05 00				ld hl, 5 
4e4a cd f7 1b				call forth_push_numhl 
4e4d			 
4e4d					; restore selected device  
4e4d				 
4e4d f1					pop af 
4e4e 32 ce f9				ld (spi_device), a 
4e51			 
4e51				       NEXTW 
4e51 c3 60 1f			jp macro_next 
4e54				endm 
# End of macro NEXTW
4e54			 
4e54			.ENDSTORAGE: 
4e54			; eof 
# End of file forth_words_storage.asm
4e54			endif 
4e54				include "forth_words_device.asm" 
4e54			; Device related words 
4e54			 
4e54			; | ## Device Words 
4e54			 
4e54			if SOUND_ENABLE 
4e54			.NOTE: 
4e54				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4e54			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4e54					if DEBUG_FORTH_WORDS_KEY 
4e54						DMARK "NTE" 
4e54						CALLMONITOR 
4e54					endif 
4e54			 
4e54				 
4e54			 
4e54					NEXTW 
4e54			.AFTERSOUND: 
4e54			endif 
4e54			 
4e54			 
4e54			USE_GPIO: equ 0 
4e54			 
4e54			if USE_GPIO 
4e54			.GP1: 
4e54				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4e54			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4e54					NEXTW 
4e54			.GP2: 
4e54				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4e54			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4e54			 
4e54					NEXTW 
4e54			 
4e54			.GP3: 
4e54				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4e54			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4e54			 
4e54					NEXTW 
4e54			 
4e54			.GP4: 
4e54				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4e54			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4e54			 
4e54					NEXTW 
4e54			.SIN: 
4e54			 
4e54			 
4e54			endif 
4e54			 
4e54			 
4e54				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4e54 33				db WORD_SYS_CORE+31             
4e55 89 4e			dw .SOUT            
4e57 03				db 2 + 1 
4e58 .. 00			db "IN",0              
4e5b				endm 
# End of macro CWHEAD
4e5b			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4e5b					if DEBUG_FORTH_WORDS_KEY 
4e5b						DMARK "IN." 
4e5b f5				push af  
4e5c 3a 70 4e			ld a, (.dmark)  
4e5f 32 bd fb			ld (debug_mark),a  
4e62 3a 71 4e			ld a, (.dmark+1)  
4e65 32 be fb			ld (debug_mark+1),a  
4e68 3a 72 4e			ld a, (.dmark+2)  
4e6b 32 bf fb			ld (debug_mark+2),a  
4e6e 18 03			jr .pastdmark  
4e70 ..			.dmark: db "IN."  
4e73 f1			.pastdmark: pop af  
4e74			endm  
# End of macro DMARK
4e74						CALLMONITOR 
4e74 cd 6a 16			call break_point_state  
4e77				endm  
# End of macro CALLMONITOR
4e77					endif 
4e77					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e77 cd ee 1d			call macro_dsp_valuehl 
4e7a				endm 
# End of macro FORTH_DSP_VALUEHL
4e7a			 
4e7a e5					push hl 
4e7b			 
4e7b					; destroy value TOS 
4e7b			 
4e7b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e7b cd a6 1e			call macro_forth_dsp_pop 
4e7e				endm 
# End of macro FORTH_DSP_POP
4e7e			 
4e7e					; one value on hl get other one back 
4e7e			 
4e7e c1					pop bc 
4e7f			 
4e7f					; do the sub 
4e7f			;		ex de, hl 
4e7f			 
4e7f ed 68				in l,(c) 
4e81			 
4e81					; save it 
4e81			 
4e81 26 00				ld h,0 
4e83			 
4e83					; TODO push value back onto stack for another op etc 
4e83			 
4e83 cd f7 1b				call forth_push_numhl 
4e86					NEXTW 
4e86 c3 60 1f			jp macro_next 
4e89				endm 
# End of macro NEXTW
4e89			.SOUT: 
4e89				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4e89 34				db WORD_SYS_CORE+32             
4e8a dc 4e			dw .SPIO            
4e8c 04				db 3 + 1 
4e8d .. 00			db "OUT",0              
4e91				endm 
# End of macro CWHEAD
4e91			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4e91					if DEBUG_FORTH_WORDS_KEY 
4e91						DMARK "OUT" 
4e91 f5				push af  
4e92 3a a6 4e			ld a, (.dmark)  
4e95 32 bd fb			ld (debug_mark),a  
4e98 3a a7 4e			ld a, (.dmark+1)  
4e9b 32 be fb			ld (debug_mark+1),a  
4e9e 3a a8 4e			ld a, (.dmark+2)  
4ea1 32 bf fb			ld (debug_mark+2),a  
4ea4 18 03			jr .pastdmark  
4ea6 ..			.dmark: db "OUT"  
4ea9 f1			.pastdmark: pop af  
4eaa			endm  
# End of macro DMARK
4eaa						CALLMONITOR 
4eaa cd 6a 16			call break_point_state  
4ead				endm  
# End of macro CALLMONITOR
4ead					endif 
4ead			 
4ead					; get port 
4ead			 
4ead					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ead cd ee 1d			call macro_dsp_valuehl 
4eb0				endm 
# End of macro FORTH_DSP_VALUEHL
4eb0			 
4eb0 e5					push hl 
4eb1			 
4eb1					; destroy value TOS 
4eb1			 
4eb1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4eb1 cd a6 1e			call macro_forth_dsp_pop 
4eb4				endm 
# End of macro FORTH_DSP_POP
4eb4			 
4eb4					; get byte to send 
4eb4			 
4eb4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4eb4 cd ee 1d			call macro_dsp_valuehl 
4eb7				endm 
# End of macro FORTH_DSP_VALUEHL
4eb7			 
4eb7			;		push hl 
4eb7			 
4eb7					; destroy value TOS 
4eb7			 
4eb7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4eb7 cd a6 1e			call macro_forth_dsp_pop 
4eba				endm 
# End of macro FORTH_DSP_POP
4eba			 
4eba					; one value on hl get other one back 
4eba			 
4eba			;		pop hl 
4eba			 
4eba c1					pop bc 
4ebb			 
4ebb					if DEBUG_FORTH_WORDS 
4ebb						DMARK "OUT" 
4ebb f5				push af  
4ebc 3a d0 4e			ld a, (.dmark)  
4ebf 32 bd fb			ld (debug_mark),a  
4ec2 3a d1 4e			ld a, (.dmark+1)  
4ec5 32 be fb			ld (debug_mark+1),a  
4ec8 3a d2 4e			ld a, (.dmark+2)  
4ecb 32 bf fb			ld (debug_mark+2),a  
4ece 18 03			jr .pastdmark  
4ed0 ..			.dmark: db "OUT"  
4ed3 f1			.pastdmark: pop af  
4ed4			endm  
# End of macro DMARK
4ed4						CALLMONITOR 
4ed4 cd 6a 16			call break_point_state  
4ed7				endm  
# End of macro CALLMONITOR
4ed7					endif 
4ed7			 
4ed7 ed 69				out (c), l 
4ed9			 
4ed9					NEXTW 
4ed9 c3 60 1f			jp macro_next 
4edc				endm 
# End of macro NEXTW
4edc			 
4edc			 
4edc			.SPIO: 
4edc			 
4edc			if STORAGE_SE 
4edc				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4edc 51				db WORD_SYS_CORE+61             
4edd ed 4e			dw .SPICEH            
4edf 07				db 6 + 1 
4ee0 .. 00			db "SPICEL",0              
4ee7				endm 
# End of macro CWHEAD
4ee7			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4ee7			 
4ee7 cd 95 01				call spi_ce_low 
4eea			    NEXTW 
4eea c3 60 1f			jp macro_next 
4eed				endm 
# End of macro NEXTW
4eed			 
4eed			.SPICEH: 
4eed				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4eed 51				db WORD_SYS_CORE+61             
4eee fe 4e			dw .SPIOb            
4ef0 07				db 6 + 1 
4ef1 .. 00			db "SPICEH",0              
4ef8				endm 
# End of macro CWHEAD
4ef8			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4ef8			 
4ef8 cd 84 01				call spi_ce_high 
4efb			    NEXTW 
4efb c3 60 1f			jp macro_next 
4efe				endm 
# End of macro NEXTW
4efe			 
4efe			 
4efe			.SPIOb: 
4efe			 
4efe				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4efe 51				db WORD_SYS_CORE+61             
4eff 14 4f			dw .SPII            
4f01 05				db 4 + 1 
4f02 .. 00			db "SPIO",0              
4f07				endm 
# End of macro CWHEAD
4f07			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4f07			 
4f07					; get port 
4f07			 
4f07			 
4f07					; get byte to send 
4f07			 
4f07					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f07 cd ee 1d			call macro_dsp_valuehl 
4f0a				endm 
# End of macro FORTH_DSP_VALUEHL
4f0a			 
4f0a			;		push hl    ; u1  
4f0a			 
4f0a					; destroy value TOS 
4f0a			 
4f0a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f0a cd a6 1e			call macro_forth_dsp_pop 
4f0d				endm 
# End of macro FORTH_DSP_POP
4f0d			 
4f0d					; one value on hl get other one back 
4f0d			 
4f0d			;		pop hl   ; u2 - addr 
4f0d			 
4f0d					; TODO Send SPI byte 
4f0d			 
4f0d 7d					ld a, l 
4f0e cd b9 00				call spi_send_byte 
4f11			 
4f11					NEXTW 
4f11 c3 60 1f			jp macro_next 
4f14				endm 
# End of macro NEXTW
4f14			 
4f14			.SPII: 
4f14				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4f14 52				db WORD_SYS_CORE+62             
4f15 29 4f			dw .SESEL            
4f17 06				db 5 + 1 
4f18 .. 00			db "SPII",0              
4f1d				endm 
# End of macro CWHEAD
4f1d			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4f1d			 
4f1d					; TODO Get SPI byte 
4f1d			 
4f1d cd da 00				call spi_read_byte 
4f20			 
4f20 26 00				ld h, 0 
4f22 6f					ld l, a 
4f23 cd f7 1b				call forth_push_numhl 
4f26			 
4f26					NEXTW 
4f26 c3 60 1f			jp macro_next 
4f29				endm 
# End of macro NEXTW
4f29			 
4f29			 
4f29			 
4f29			.SESEL: 
4f29				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4f29 66				db WORD_SYS_CORE+82             
4f2a cd 4f			dw .CARTDEV            
4f2c 05				db 4 + 1 
4f2d .. 00			db "BANK",0              
4f32				endm 
# End of macro CWHEAD
4f32			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4f32					if DEBUG_FORTH_WORDS_KEY 
4f32						DMARK "BNK" 
4f32 f5				push af  
4f33 3a 47 4f			ld a, (.dmark)  
4f36 32 bd fb			ld (debug_mark),a  
4f39 3a 48 4f			ld a, (.dmark+1)  
4f3c 32 be fb			ld (debug_mark+1),a  
4f3f 3a 49 4f			ld a, (.dmark+2)  
4f42 32 bf fb			ld (debug_mark+2),a  
4f45 18 03			jr .pastdmark  
4f47 ..			.dmark: db "BNK"  
4f4a f1			.pastdmark: pop af  
4f4b			endm  
# End of macro DMARK
4f4b						CALLMONITOR 
4f4b cd 6a 16			call break_point_state  
4f4e				endm  
# End of macro CALLMONITOR
4f4e					endif 
4f4e			 
4f4e 3e ff				ld a, 255 
4f50 32 d1 f9				ld (spi_cartdev), a 
4f53			 
4f53					; get bank 
4f53			 
4f53					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4f53 cd ee 1d			call macro_dsp_valuehl 
4f56				endm 
# End of macro FORTH_DSP_VALUEHL
4f56			 
4f56			;		push hl 
4f56			 
4f56					; destroy value TOS 
4f56			 
4f56					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4f56 cd a6 1e			call macro_forth_dsp_pop 
4f59				endm 
# End of macro FORTH_DSP_POP
4f59			 
4f59					; one value on hl get other one back 
4f59			 
4f59			;		pop hl 
4f59			 
4f59			 
4f59 0e ff				ld c, SPI_CE_HIGH 
4f5b 06 30				ld b, '0'    ; human readable bank number 
4f5d			 
4f5d 7d					ld a, l 
4f5e			 
4f5e					if DEBUG_FORTH_WORDS 
4f5e						DMARK "BNK" 
4f5e f5				push af  
4f5f 3a 73 4f			ld a, (.dmark)  
4f62 32 bd fb			ld (debug_mark),a  
4f65 3a 74 4f			ld a, (.dmark+1)  
4f68 32 be fb			ld (debug_mark+1),a  
4f6b 3a 75 4f			ld a, (.dmark+2)  
4f6e 32 bf fb			ld (debug_mark+2),a  
4f71 18 03			jr .pastdmark  
4f73 ..			.dmark: db "BNK"  
4f76 f1			.pastdmark: pop af  
4f77			endm  
# End of macro DMARK
4f77						CALLMONITOR 
4f77 cd 6a 16			call break_point_state  
4f7a				endm  
# End of macro CALLMONITOR
4f7a					endif 
4f7a			 
4f7a					; active low 
4f7a			 
4f7a fe 00				cp 0 
4f7c 28 28				jr z, .bset 
4f7e fe 01				cp 1 
4f80 20 04				jr nz, .b2 
4f82 cb 81				res 0, c 
4f84 06 31				ld b, '1'    ; human readable bank number 
4f86 fe 02		.b2:		cp 2 
4f88 20 04				jr nz, .b3 
4f8a cb 89				res 1, c 
4f8c 06 32				ld b, '2'    ; human readable bank number 
4f8e fe 03		.b3:		cp 3 
4f90 20 04				jr nz, .b4 
4f92 cb 91				res 2, c 
4f94 06 33				ld b, '3'    ; human readable bank number 
4f96 fe 04		.b4:		cp 4 
4f98 20 04				jr nz, .b5 
4f9a cb 99				res 3, c 
4f9c 06 34				ld b, '4'    ; human readable bank number 
4f9e fe 05		.b5:		cp 5 
4fa0 20 04				jr nz, .bset 
4fa2 cb a1				res 4, c 
4fa4 06 35				ld b, '5'    ; human readable bank number 
4fa6			 
4fa6			.bset: 
4fa6 79					ld a, c 
4fa7 32 ce f9				ld (spi_device),a 
4faa 78					ld a, b 
4fab 32 cd f9				ld (spi_device_id),a 
4fae					if DEBUG_FORTH_WORDS 
4fae						DMARK "BN2" 
4fae f5				push af  
4faf 3a c3 4f			ld a, (.dmark)  
4fb2 32 bd fb			ld (debug_mark),a  
4fb5 3a c4 4f			ld a, (.dmark+1)  
4fb8 32 be fb			ld (debug_mark+1),a  
4fbb 3a c5 4f			ld a, (.dmark+2)  
4fbe 32 bf fb			ld (debug_mark+2),a  
4fc1 18 03			jr .pastdmark  
4fc3 ..			.dmark: db "BN2"  
4fc6 f1			.pastdmark: pop af  
4fc7			endm  
# End of macro DMARK
4fc7						CALLMONITOR 
4fc7 cd 6a 16			call break_point_state  
4fca				endm  
# End of macro CALLMONITOR
4fca					endif 
4fca			 
4fca					NEXTW 
4fca c3 60 1f			jp macro_next 
4fcd				endm 
# End of macro NEXTW
4fcd			 
4fcd			.CARTDEV: 
4fcd				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4fcd 66				db WORD_SYS_CORE+82             
4fce 76 50			dw .ENDDEVICE            
4fd0 08				db 7 + 1 
4fd1 .. 00			db "CARTDEV",0              
4fd9				endm 
# End of macro CWHEAD
4fd9			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4fd9					if DEBUG_FORTH_WORDS_KEY 
4fd9						DMARK "CDV" 
4fd9 f5				push af  
4fda 3a ee 4f			ld a, (.dmark)  
4fdd 32 bd fb			ld (debug_mark),a  
4fe0 3a ef 4f			ld a, (.dmark+1)  
4fe3 32 be fb			ld (debug_mark+1),a  
4fe6 3a f0 4f			ld a, (.dmark+2)  
4fe9 32 bf fb			ld (debug_mark+2),a  
4fec 18 03			jr .pastdmark  
4fee ..			.dmark: db "CDV"  
4ff1 f1			.pastdmark: pop af  
4ff2			endm  
# End of macro DMARK
4ff2						CALLMONITOR 
4ff2 cd 6a 16			call break_point_state  
4ff5				endm  
# End of macro CALLMONITOR
4ff5					endif 
4ff5			 
4ff5					; disable se storage bank selection 
4ff5			 
4ff5 3e ff				ld a, SPI_CE_HIGH		; ce high 
4ff7 32 ce f9				ld (spi_device), a 
4ffa			 
4ffa					; get bank 
4ffa			 
4ffa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ffa cd ee 1d			call macro_dsp_valuehl 
4ffd				endm 
# End of macro FORTH_DSP_VALUEHL
4ffd			 
4ffd			;		push hl 
4ffd			 
4ffd					; destroy value TOS 
4ffd			 
4ffd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ffd cd a6 1e			call macro_forth_dsp_pop 
5000				endm 
# End of macro FORTH_DSP_POP
5000			 
5000					; one value on hl get other one back 
5000			 
5000			;		pop hl 
5000			 
5000					; active low 
5000			 
5000 0e ff				ld c, 255 
5002			 
5002 7d					ld a, l 
5003					if DEBUG_FORTH_WORDS 
5003						DMARK "CDV" 
5003 f5				push af  
5004 3a 18 50			ld a, (.dmark)  
5007 32 bd fb			ld (debug_mark),a  
500a 3a 19 50			ld a, (.dmark+1)  
500d 32 be fb			ld (debug_mark+1),a  
5010 3a 1a 50			ld a, (.dmark+2)  
5013 32 bf fb			ld (debug_mark+2),a  
5016 18 03			jr .pastdmark  
5018 ..			.dmark: db "CDV"  
501b f1			.pastdmark: pop af  
501c			endm  
# End of macro DMARK
501c						CALLMONITOR 
501c cd 6a 16			call break_point_state  
501f				endm  
# End of macro CALLMONITOR
501f					endif 
501f fe 00				cp 0 
5021 28 30				jr z, .cset 
5023 fe 01				cp 1 
5025 20 02				jr nz, .c2 
5027 cb 81				res 0, c 
5029 fe 02		.c2:		cp 2 
502b 20 02				jr nz, .c3 
502d cb 89				res 1, c 
502f fe 03		.c3:		cp 3 
5031 20 02				jr nz, .c4 
5033 cb 91				res 2, c 
5035 fe 04		.c4:		cp 4 
5037 20 02				jr nz, .c5 
5039 cb 99				res 3, c 
503b fe 05		.c5:		cp 5 
503d 20 02				jr nz, .c6 
503f cb a1				res 4, c 
5041 fe 06		.c6:		cp 6 
5043 20 02				jr nz, .c7 
5045 cb a9				res 5, c 
5047 fe 07		.c7:		cp 7 
5049 20 02				jr nz, .c8 
504b cb b1				res 6, c 
504d fe 08		.c8:		cp 8 
504f 20 02				jr nz, .cset 
5051 cb b9				res 7, c 
5053 79			.cset:		ld a, c 
5054 32 d1 f9				ld (spi_cartdev),a 
5057			 
5057					if DEBUG_FORTH_WORDS 
5057						DMARK "CD2" 
5057 f5				push af  
5058 3a 6c 50			ld a, (.dmark)  
505b 32 bd fb			ld (debug_mark),a  
505e 3a 6d 50			ld a, (.dmark+1)  
5061 32 be fb			ld (debug_mark+1),a  
5064 3a 6e 50			ld a, (.dmark+2)  
5067 32 bf fb			ld (debug_mark+2),a  
506a 18 03			jr .pastdmark  
506c ..			.dmark: db "CD2"  
506f f1			.pastdmark: pop af  
5070			endm  
# End of macro DMARK
5070						CALLMONITOR 
5070 cd 6a 16			call break_point_state  
5073				endm  
# End of macro CALLMONITOR
5073					endif 
5073					NEXTW 
5073 c3 60 1f			jp macro_next 
5076				endm 
# End of macro NEXTW
5076			endif 
5076			 
5076			.ENDDEVICE: 
5076			; eof 
5076			 
# End of file forth_words_device.asm
5076			 
5076			; var handler 
5076			 
5076			 
5076			.VARS: 
5076				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5076 78				db WORD_SYS_CORE+100             
5077 8e 50			dw .V0Q            
5079 04				db 3 + 1 
507a .. 00			db "V0!",0              
507e				endm 
# End of macro CWHEAD
507e			;| V0! ( u1 -- )  Store value to v0  | DONE 
507e			 
507e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
507e cd ee 1d			call macro_dsp_valuehl 
5081				endm 
# End of macro FORTH_DSP_VALUEHL
5081			 
5081 11 96 f9				ld de, cli_var_array 
5084			 
5084 eb					ex de, hl 
5085 73					ld (hl), e 
5086 23					inc hl 
5087 72					ld (hl), d 
5088			 
5088					; destroy value TOS 
5088			 
5088					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5088 cd a6 1e			call macro_forth_dsp_pop 
508b				endm 
# End of macro FORTH_DSP_POP
508b			 
508b				       NEXTW 
508b c3 60 1f			jp macro_next 
508e				endm 
# End of macro NEXTW
508e			.V0Q: 
508e				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
508e 79				db WORD_SYS_CORE+101             
508f 9f 50			dw .V1S            
5091 04				db 3 + 1 
5092 .. 00			db "V0@",0              
5096				endm 
# End of macro CWHEAD
5096			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5096 2a 96 f9				ld hl, (cli_var_array) 
5099 cd f7 1b				call forth_push_numhl 
509c			 
509c				       NEXTW 
509c c3 60 1f			jp macro_next 
509f				endm 
# End of macro NEXTW
509f			.V1S: 
509f				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
509f 7a				db WORD_SYS_CORE+102             
50a0 b7 50			dw .V1Q            
50a2 04				db 3 + 1 
50a3 .. 00			db "V1!",0              
50a7				endm 
# End of macro CWHEAD
50a7			;| V1! ( u1 -- )  Store value to v1 | DONE 
50a7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50a7 cd ee 1d			call macro_dsp_valuehl 
50aa				endm 
# End of macro FORTH_DSP_VALUEHL
50aa			 
50aa 11 98 f9				ld de, cli_var_array+2 
50ad				 
50ad eb					ex de, hl 
50ae 73					ld (hl), e 
50af 23					inc hl 
50b0 72					ld (hl), d 
50b1			 
50b1					; destroy value TOS 
50b1			 
50b1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50b1 cd a6 1e			call macro_forth_dsp_pop 
50b4				endm 
# End of macro FORTH_DSP_POP
50b4				       NEXTW 
50b4 c3 60 1f			jp macro_next 
50b7				endm 
# End of macro NEXTW
50b7			.V1Q: 
50b7				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
50b7 7b				db WORD_SYS_CORE+103             
50b8 c8 50			dw .V2S            
50ba 04				db 3 + 1 
50bb .. 00			db "V1@",0              
50bf				endm 
# End of macro CWHEAD
50bf			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
50bf 2a 98 f9				ld hl, (cli_var_array+2) 
50c2 cd f7 1b				call forth_push_numhl 
50c5				       NEXTW 
50c5 c3 60 1f			jp macro_next 
50c8				endm 
# End of macro NEXTW
50c8			.V2S: 
50c8				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
50c8 7c				db WORD_SYS_CORE+104             
50c9 e0 50			dw .V2Q            
50cb 04				db 3 + 1 
50cc .. 00			db "V2!",0              
50d0				endm 
# End of macro CWHEAD
50d0			;| V2! ( u1 -- )  Store value to v2 | DONE 
50d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50d0 cd ee 1d			call macro_dsp_valuehl 
50d3				endm 
# End of macro FORTH_DSP_VALUEHL
50d3			 
50d3 11 9a f9				ld de, cli_var_array+4 
50d6				 
50d6 eb					ex de, hl 
50d7 73					ld (hl), e 
50d8 23					inc hl 
50d9 72					ld (hl), d 
50da			 
50da					; destroy value TOS 
50da			 
50da					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
50da cd a6 1e			call macro_forth_dsp_pop 
50dd				endm 
# End of macro FORTH_DSP_POP
50dd				       NEXTW 
50dd c3 60 1f			jp macro_next 
50e0				endm 
# End of macro NEXTW
50e0			.V2Q: 
50e0				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
50e0 7d				db WORD_SYS_CORE+105             
50e1 f1 50			dw .V3S            
50e3 04				db 3 + 1 
50e4 .. 00			db "V2@",0              
50e8				endm 
# End of macro CWHEAD
50e8			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
50e8 2a 9a f9				ld hl, (cli_var_array+4) 
50eb cd f7 1b				call forth_push_numhl 
50ee				       NEXTW 
50ee c3 60 1f			jp macro_next 
50f1				endm 
# End of macro NEXTW
50f1			.V3S: 
50f1				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
50f1 7c				db WORD_SYS_CORE+104             
50f2 09 51			dw .V3Q            
50f4 04				db 3 + 1 
50f5 .. 00			db "V3!",0              
50f9				endm 
# End of macro CWHEAD
50f9			;| V3! ( u1 -- )  Store value to v3 | DONE 
50f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
50f9 cd ee 1d			call macro_dsp_valuehl 
50fc				endm 
# End of macro FORTH_DSP_VALUEHL
50fc			 
50fc 11 9c f9				ld de, cli_var_array+6 
50ff				 
50ff eb					ex de, hl 
5100 73					ld (hl), e 
5101 23					inc hl 
5102 72					ld (hl), d 
5103			 
5103					; destroy value TOS 
5103			 
5103					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5103 cd a6 1e			call macro_forth_dsp_pop 
5106				endm 
# End of macro FORTH_DSP_POP
5106				       NEXTW 
5106 c3 60 1f			jp macro_next 
5109				endm 
# End of macro NEXTW
5109			.V3Q: 
5109				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5109 7d				db WORD_SYS_CORE+105             
510a 1a 51			dw .END            
510c 04				db 3 + 1 
510d .. 00			db "V3@",0              
5111				endm 
# End of macro CWHEAD
5111			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5111 2a 9c f9				ld hl, (cli_var_array+6) 
5114 cd f7 1b				call forth_push_numhl 
5117				       NEXTW 
5117 c3 60 1f			jp macro_next 
511a				endm 
# End of macro NEXTW
511a			 
511a			 
511a			 
511a			 
511a			 
511a			; end of dict marker 
511a			 
511a 00			.END:    db WORD_SYS_END 
511b 00 00			dw 0 
511d 00				db 0 
511e			 
511e			; use to jp here for user dict words to save on macro expansion  
511e			 
511e			user_dict_next: 
511e				NEXTW 
511e c3 60 1f			jp macro_next 
5121				endm 
# End of macro NEXTW
5121			 
5121			 
5121			user_exec: 
5121				;    ld hl, <word code> 
5121				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5121				;    call forthexec 
5121				;    jp user_dict_next   (NEXT) 
5121			        ;    <word code bytes> 
5121 eb				ex de, hl 
5122 2a a4 f2			ld hl,(os_tok_ptr) 
5125				 
5125				FORTH_RSP_NEXT 
5125 cd 9e 1b			call macro_forth_rsp_next 
5128				endm 
# End of macro FORTH_RSP_NEXT
5128			 
5128			if DEBUG_FORTH_UWORD 
5128						DMARK "UEX" 
5128 f5				push af  
5129 3a 3d 51			ld a, (.dmark)  
512c 32 bd fb			ld (debug_mark),a  
512f 3a 3e 51			ld a, (.dmark+1)  
5132 32 be fb			ld (debug_mark+1),a  
5135 3a 3f 51			ld a, (.dmark+2)  
5138 32 bf fb			ld (debug_mark+2),a  
513b 18 03			jr .pastdmark  
513d ..			.dmark: db "UEX"  
5140 f1			.pastdmark: pop af  
5141			endm  
# End of macro DMARK
5141				CALLMONITOR 
5141 cd 6a 16			call break_point_state  
5144				endm  
# End of macro CALLMONITOR
5144			endif 
5144			 
5144			 
5144			 
5144 eb				ex de, hl 
5145 22 a4 f2			ld (os_tok_ptr), hl 
5148				 
5148				; Don't use next - Skips the first word in uword. 
5148			 
5148 c3 f1 1f			jp exec1 
514b			;	NEXT 
514b			 
514b			 
514b			; eof 
# End of file forth_wordsv4.asm
514b			endif 
514b			;;;;;;;;;;;;;; Debug code 
514b			 
514b			 
514b			;if DEBUG_FORTH_PARSE 
514b .. 00		.nowordfound: db "No match",0 
5154 .. 00		.compword:	db "Comparing word ",0 
5164 .. 00		.nextwordat:	db "Next word at",0 
5171 .. 00		.charmatch:	db "Char match",0 
517c			;endif 
517c			if DEBUG_FORTH_JP 
517c			.foundword:	db "Word match. Exec..",0 
517c			endif 
517c			;if DEBUG_FORTH_PUSH 
517c .. 00		.enddict:	db "Dict end. Push.",0 
518c .. 00		.push_str:	db "Pushing string",0 
519b .. 00		.push_num:	db "Pushing number",0 
51aa .. 00		.data_sp:	db "SP:",0 
51ae .. 00		.wordinhl:	db "Word in HL (2/0):",0 
51c0 .. 00		.wordinde:	db "Word in DE (3/0):",0 
51d2 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
51e4			;endif 
51e4			;if DEBUG_FORTH_MALLOC 
51e4 .. 00		.push_malloc:	db "Malloc address",0 
51f3			;endif 
51f3			 
51f3			 
51f3			 
51f3			; display malloc address and current data stack pointer  
51f3			 
51f3			malloc_error: 
51f3 d5				push de 
51f4 f5				push af 
51f5 e5				push hl 
51f6 cd d2 0a			call clear_display 
51f9 11 1b 52			ld de, .mallocerr 
51fc 3e 00			ld a,0 
51fe			;	ld de,os_word_scratch 
51fe cd e5 0a			call str_at_display 
5201 3e 11			ld a, display_row_1+17 
5203 11 bd fb			ld de, debug_mark 
5206 cd e5 0a			call str_at_display 
5209 cd f5 0a			call update_display 
520c				;call break_point_state 
520c cd 49 66			call cin_wait 
520f			 
520f 3e 20			ld a, ' ' 
5211 32 94 ef			ld (os_view_disable), a 
5214 e1				pop hl 
5215 f1				pop af 
5216 d1				pop de	 
5217				CALLMONITOR 
5217 cd 6a 16			call break_point_state  
521a				endm  
# End of macro CALLMONITOR
521a c9				ret 
521b			 
521b .. 00		.mallocerr: 	db "Malloc Error",0 
5228			;if DEBUG_FORTH_PUSH 
5228			display_data_sp: 
5228 f5				push af 
5229			 
5229				; see if disabled 
5229			 
5229 3a 94 ef			ld a, (os_view_disable) 
522c fe 2a			cp '*' 
522e 28 67			jr z, .skipdsp 
5230			 
5230 e5				push hl 
5231 e5				push hl 
5232 e5			push hl 
5233 cd d2 0a			call clear_display 
5236 e1			pop hl 
5237 7c				ld a,h 
5238 21 a8 f2			ld hl, os_word_scratch 
523b cd 07 10			call hexout 
523e e1				pop hl 
523f 7d				ld a,l 
5240 21 aa f2			ld hl, os_word_scratch+2 
5243 cd 07 10			call hexout 
5246 21 ac f2			ld hl, os_word_scratch+4 
5249 3e 00			ld a,0 
524b 77				ld (hl),a 
524c 11 a8 f2			ld de,os_word_scratch 
524f 3e 14				ld a, display_row_2 
5251 cd e5 0a				call str_at_display 
5254 11 ae 51			ld de, .wordinhl 
5257 3e 00			ld a, display_row_1 
5259			 
5259 cd e5 0a				call str_at_display 
525c 11 bd fb			ld de, debug_mark 
525f 3e 11			ld a, display_row_1+17 
5261			 
5261 cd e5 0a				call str_at_display 
5264			 
5264				; display current data stack pointer 
5264 11 aa 51			ld de,.data_sp 
5267 3e 1c				ld a, display_row_2 + 8 
5269 cd e5 0a				call str_at_display 
526c			 
526c 2a 90 f9			ld hl,(cli_data_sp) 
526f e5				push hl 
5270 7c				ld a,h 
5271 21 a8 f2			ld hl, os_word_scratch 
5274 cd 07 10			call hexout 
5277 e1				pop hl 
5278 7d				ld a,l 
5279 21 aa f2			ld hl, os_word_scratch+2 
527c cd 07 10			call hexout 
527f 21 ac f2			ld hl, os_word_scratch+4 
5282 3e 00			ld a,0 
5284 77				ld (hl),a 
5285 11 a8 f2			ld de,os_word_scratch 
5288 3e 1f				ld a, display_row_2 + 11 
528a cd e5 0a				call str_at_display 
528d			 
528d			 
528d cd f5 0a			call update_display 
5290 cd 52 0a			call delay1s 
5293 cd 52 0a			call delay1s 
5296 e1				pop hl 
5297			.skipdsp: 
5297 f1				pop af 
5298 c9				ret 
5299			 
5299			display_data_malloc: 
5299			 
5299 f5				push af 
529a e5				push hl 
529b e5				push hl 
529c e5			push hl 
529d cd d2 0a			call clear_display 
52a0 e1			pop hl 
52a1 7c				ld a,h 
52a2 21 a8 f2			ld hl, os_word_scratch 
52a5 cd 07 10			call hexout 
52a8 e1				pop hl 
52a9 7d				ld a,l 
52aa 21 aa f2			ld hl, os_word_scratch+2 
52ad cd 07 10			call hexout 
52b0 21 ac f2			ld hl, os_word_scratch+4 
52b3 3e 00			ld a,0 
52b5 77				ld (hl),a 
52b6 11 a8 f2			ld de,os_word_scratch 
52b9 3e 14				ld a, display_row_2 
52bb cd e5 0a				call str_at_display 
52be 11 e4 51			ld de, .push_malloc 
52c1 3e 00			ld a, display_row_1 
52c3			 
52c3 cd e5 0a				call str_at_display 
52c6			 
52c6				; display current data stack pointer 
52c6 11 aa 51			ld de,.data_sp 
52c9 3e 1c				ld a, display_row_2 + 8 
52cb cd e5 0a				call str_at_display 
52ce			 
52ce 2a 90 f9			ld hl,(cli_data_sp) 
52d1 e5				push hl 
52d2 7c				ld a,h 
52d3 21 a8 f2			ld hl, os_word_scratch 
52d6 cd 07 10			call hexout 
52d9 e1				pop hl 
52da 7d				ld a,l 
52db 21 aa f2			ld hl, os_word_scratch+2 
52de cd 07 10			call hexout 
52e1 21 ac f2			ld hl, os_word_scratch+4 
52e4 3e 00			ld a,0 
52e6 77				ld (hl),a 
52e7 11 a8 f2			ld de,os_word_scratch 
52ea 3e 1f				ld a, display_row_2 + 11 
52ec cd e5 0a				call str_at_display 
52ef			 
52ef cd f5 0a			call update_display 
52f2 cd 52 0a			call delay1s 
52f5 cd 52 0a			call delay1s 
52f8 e1				pop hl 
52f9 f1				pop af 
52fa c9				ret 
52fb			;endif 
52fb			 
52fb			include "forth_autostart.asm" 
52fb			; list of commands to perform at system start up 
52fb			 
52fb			startcmds: 
52fb			;	dw test11 
52fb			;	dw test12 
52fb			;	dw test13 
52fb			;	dw test14 
52fb			;	dw test15 
52fb			;	dw test16 
52fb			;	dw test17 
52fb			;	dw ifthtest1 
52fb			;	dw ifthtest2 
52fb			;	dw ifthtest3 
52fb			;	dw mmtest1 
52fb			;	dw mmtest2 
52fb			;	dw mmtest3 
52fb			;	dw mmtest4 
52fb			;	dw mmtest5 
52fb			;	dw mmtest6 
52fb			;	dw iftest1 
52fb			;	dw iftest2 
52fb			;	dw iftest3 
52fb			;	dw looptest1 
52fb			;	dw looptest2 
52fb			;	dw test1 
52fb			;	dw test2 
52fb			;	dw test3 
52fb			;	dw test4 
52fb			;	dw game2r 
52fb			;	dw game2b1 
52fb			;	dw game2b2 
52fb			 
52fb				; start up words that are actually useful 
52fb			 
52fb 59 53			dw clrstack 
52fd 8c 53			dw type 
52ff 4d 55			dw stest 
5301 b0 53			dw strncpy 
5303 ee 54			dw list 
5305 11 54			dw start1 
5307 23 54			dw start2 
5309			;	dw start3 
5309 36 54			dw start3b 
530b 8e 54			dw start3c 
530d			 
530d				; (unit) testing words 
530d			 
530d c4 55			dw mtesta 
530f 79 56			dw mtestb 
5311 1c 57			dw mtestc 
5313 d1 57			dw mtestd 
5315 75 58			dw mteste 
5317			 
5317				; demo/game words 
5317			 
5317 81 5f		        dw game3w 
5319 af 5f		        dw game3p 
531b cd 5f		        dw game3sc 
531d fe 5f		        dw game3vsi 
531f 2a 60		        dw game3vs 
5321				 
5321 74 5d			dw game2b 
5323 e2 5d			dw game2bf 
5325 2c 5e			dw game2mba 
5327 c2 5e			dw game2mbas 
5329 04 5f			dw game2mb 
532b			 
532b 35 5a			dw game1 
532d 46 5a			dw game1a 
532f a8 5a			dw game1b 
5331 dd 5a			dw game1c 
5333 13 5b			dw game1d 
5335 44 5b			dw game1s 
5337 58 5b			dw game1t 
5339 6d 5b			dw game1f 
533b a1 5b			dw game1z 
533d e5 5b			dw game1zz 
533f			 
533f 2b 59			dw test5 
5341 63 59			dw test6 
5343 9b 59			dw test7 
5345 af 59			dw test8 
5347 db 59			dw test9 
5349 f1 59			dw test10 
534b				 
534b bc 5c		        dw ssv5 
534d a0 5c		        dw ssv4 
534f 84 5c		        dw ssv3 
5351 4e 5c		        dw ssv2 
5353 d5 5c		        dw ssv1 
5355 1d 5d		        dw ssv1cpm 
5357			;	dw keyup 
5357			;	dw keydown 
5357			;	dw keyleft 
5357			;	dw keyright 
5357			;	dw 	keyf1 
5357			;	dw keyf2 
5357			;	dw keyf3 
5357			;	dw keyf4 
5357			;	dw keyf5 
5357			;	dw keyf6 
5357			;	dw keyf7 
5357			;	dw keyf8 
5357			;	dw keyf9 
5357			;	dw keyf10 
5357			;	dw keyf11 
5357			;	dw keyf12 
5357			;	dw keytab 
5357			;	dw keycr 
5357			;	dw keyhome 
5357			;	dw keyend 
5357			;	dw keybs 
5357 00 00			db 0, 0	 
5359			 
5359			 
5359			; clear stack  
5359			 
5359 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
538c			 
538c			; type ( addr count - ) 
538c .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
53b0			 
53b0			; some direct memory words 
53b0			; strncpy ( len t f -- t ) 
53b0			 
53b0 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5411			 
5411 .. 00		start1:     	db ": bpon $0000 bp ;",0 
5423 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
5436			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
5436 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
548e .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
54ee			 
54ee			 
54ee			; a handy word to list items on the stack 
54ee			 
54ee .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
554d			 
554d			 
554d			; test stack  
554d			; rnd8 stest 
554d			 
554d .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
55c4			 
55c4			; random malloc and free cycles 
55c4			 
55c4 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5679			 
5679			; fixed malloc and free cycles 
5679			 
5679 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
571c			 
571c			; fixed double string push and drop cycle  
571c			 
571c .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
57d1			 
57d1			; consistent fixed string push and drop cycle  
57d1			 
57d1 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5875			 
5875 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
592b			 
592b			;test1:		db ": aa 1 2 3 ;", 0 
592b			;test2:     	db "111 aa 888 999",0 
592b			;test3:     	db ": bb 77 ;",0 
592b			;test4:     	db "$02 $01 do i . loop bb",0 
592b			 
592b .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5963 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
599b .. 00		test7:     	db ": box hline vline ;",0 
59af .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
59db .. 00		test9:     	db ": sw $01 adsp world ;",0 
59f1 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5a16 .. 00		test11:     	db "hello create .",0 
5a25 .. 00		test12:     	db "hello2 create .",0 
5a35			 
5a35			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5a35			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5a35			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5a35			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5a35			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5a35			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5a35			 
5a35			;iftest1:     	db "$0001 IF cls .",0 
5a35			;iftest2:     	db "$0000 IF cls .",0 
5a35			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5a35			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5a35			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5a35			 
5a35			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a35			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a35			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5a35			 
5a35			 
5a35			 
5a35			; a small guess the number game 
5a35			 
5a35 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a46 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5aa8			 
5aa8 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5add .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5b13 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b44 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b58 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b6d .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5ba1 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5be5			 
5be5			; Using 'ga' save a high score across multiple runs using external storage 
5be5			 
5be5 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c4e			 
5c4e			 
5c4e			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c4e			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c4e			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c4e			 
5c4e			; simple screen saver to test code memory reuse to destruction 
5c4e			 
5c4e .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c84 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5ca0 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5cbc .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5cd5 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d1d .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d74			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d74			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d74			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d74			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d74			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d74			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d74			 
5d74			 
5d74			 
5d74			; minesweeper/battleship finding game 
5d74			; draws a game board of random ship/mine positions 
5d74			; user enters coords to see if it hits on 
5d74			; game ends when all are hit 
5d74			; when hit or miss says how many may be in the area 
5d74			 
5d74			; setup the game board and then hide it 
5d74 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5de2 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e2c			; prompt for where to target 
5e2c .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5ec2 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5ee7			; TODO see if the entered coords hits or misses pushes char hit of miss 
5ee7 .. 00		game2mbht:      db ": mbckht nop ;",0 
5ef6 .. 00		game2mbms:      db ": mbcms nop ;",0 
5f04			; TODO how many might be near by 
5f04 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f81			 
5f81			; Game 3 
5f81			 
5f81			; Vert scroller ski game - avoid the trees! 
5f81			 
5f81			; v0 score (ie turns) 
5f81			; v1 player pos 
5f81			; v2 left wall 
5f81			; v3 right wall 
5f81			 
5f81			; Draw side walls randomly 
5f81			 
5f81 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5faf			 
5faf			; Draw player 
5faf .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5fcd			 
5fcd			; TODO Get Key 
5fcd			 
5fcd			; TODO Move left right 
5fcd			 
5fcd			; scroll and move walls a bit 
5fcd			 
5fcd .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5ffe			 
5ffe			; main game loop 
5ffe			 
5ffe .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
602a .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6069			 
6069			; key board defs 
6069			 
6069 .. 00		keyup:       db ": keyup $05 ;",0 
6077 .. 00		keydown:       db ": keydown $0a ;",0 
6087 .. 00		keyleft:       db ": keyleft $0b ;",0 
6097 .. 00		keyright:       db ": keyright $0c ;",0 
60a8 .. 00		keyf1:       db ": keyf1 $10 ;",0 
60b6 .. 00		keyf2:       db ": keyf2 $11 ;",0 
60c4 .. 00		keyf3:       db ": keyf3 $12 ;",0 
60d2 .. 00		keyf4:       db ": keyf4 $13 ;",0 
60e0 .. 00		keyf5:       db ": keyf5 $14 ;",0 
60ee .. 00		keyf6:       db ": keyf6 $15 ;",0 
60fc .. 00		keyf7:       db ": keyf7 $16 ;",0 
610a .. 00		keyf8:       db ": keyf8 $17 ;",0 
6118 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6126 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6135 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6144 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6153			 
6153 .. 00		keytab:       db ": keytab $09 ;",0 
6162 .. 00		keycr:       db ": keycr $0d ;",0 
6170 .. 00		keyhome:       db ": keyhome $0e ;",0 
6180 .. 00		keyend:       db ": keyend $0f ;",0 
618f .. 00		keybs:       db ": keybs $08 ;",0 
619d			 
619d			   
619d			 
619d			 
619d			 
619d			; eof 
# End of file forth_autostart.asm
619d			 
619d .. 00		sprompt1: db "Startup load...",0 
61ad .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
61c3			 
61c3			forth_startup: 
61c3 21 fb 52			ld hl, startcmds 
61c6 3e 00			ld a, 0 
61c8 32 c9 f3			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
61cb			 
61cb e5			.start1:	push hl 
61cc cd d2 0a			call clear_display 
61cf 11 9d 61			ld de, sprompt1 
61d2 3e 00		        ld a, display_row_1 
61d4 cd e5 0a			call str_at_display 
61d7 11 ad 61			ld de, sprompt2 
61da 3e 14		        ld a, display_row_2 
61dc cd e5 0a			call str_at_display 
61df e1				pop hl 
61e0 e5				push hl 
61e1 5e				ld e,(hl) 
61e2 23				inc hl 
61e3 56				ld d,(hl) 
61e4 3e 28		        ld a, display_row_3 
61e6 cd e5 0a			call str_at_display 
61e9 cd f5 0a			call update_display 
61ec			 
61ec			 
61ec 3a c9 f3			ld a, (os_last_cmd) 
61ef fe 00			cp 0 
61f1 28 05			jr z, .startprompt 
61f3 cd 46 0a			call delay250ms 
61f6 18 24			jr .startdo 
61f8				 
61f8				 
61f8			 
61f8			.startprompt: 
61f8			 
61f8 3e 4f			ld a,display_row_4 + display_cols - 1 
61fa 11 6d 1b		        ld de, endprg 
61fd cd e5 0a			call str_at_display 
6200 cd f5 0a			call update_display 
6203 cd 52 0a			call delay1s 
6206 cd 49 66			call cin_wait 
6209						 
6209 fe 2a			cp '*' 
620b 28 5e			jr z, .startupend1 
620d fe 23			cp '#' 
620f 20 07			jr nz, .startno 
6211 3e 01			ld a, 1 
6213 32 c9 f3			ld (os_last_cmd),a 
6216 18 04			jr .startdo 
6218 fe 31		.startno:	cp '1' 
621a 28 3a			jr z,.startnxt  
621c			 
621c				; exec startup line 
621c			.startdo:	 
621c e1				pop hl 
621d e5				push hl 
621e				 
621e 5e				ld e,(hl) 
621f 23				inc hl 
6220 56				ld d,(hl) 
6221 eb				ex de,hl 
6222			 
6222 e5				push hl 
6223			 
6223 3e 00			ld a, 0 
6225				;ld a, FORTH_END_BUFFER 
6225 cd 6f 11			call strlent 
6228 23				inc hl   ; include zero term to copy 
6229 06 00			ld b,0 
622b 4d				ld c,l 
622c e1				pop hl 
622d 11 a3 ef			ld de, scratch 
6230 ed b0			ldir 
6232			 
6232			 
6232 21 a3 ef			ld hl, scratch 
6235 cd ae 1f			call forthparse 
6238 cd ee 1f			call forthexec 
623b cd 05 1f			call forthexec_cleanup 
623e			 
623e 3e 3c			ld a, display_row_4 
6240 11 11 19			ld de, endprog 
6243			 
6243 cd f5 0a			call update_display		 
6246			 
6246 3a c9 f3			ld a, (os_last_cmd) 
6249 fe 00			cp 0 
624b 20 09			jr nz, .startnxt 
624d cd 6f 1b			call next_page_prompt 
6250 cd d2 0a		        call clear_display 
6253 cd f5 0a			call update_display		 
6256			 
6256				; move onto next startup line? 
6256			.startnxt: 
6256			 
6256 cd 46 0a			call delay250ms 
6259 e1				pop hl 
625a			 
625a 23				inc hl 
625b 23				inc hl 
625c			 
625c e5				push hl 
625d 5e				ld e, (hl) 
625e 23				inc hl 
625f 56				ld d, (hl) 
6260 e1				pop hl 
6261				; TODO replace 0 test 
6261			 
6261 eb				ex de, hl 
6262 cd 2f 0d			call ishlzero 
6265			;	ld a,e 
6265			;	add d 
6265			;	cp 0    ; any left to do? 
6265 eb				ex de, hl 
6266 c2 cb 61			jp nz, .start1 
6269 18 01			jr .startupend 
626b			 
626b e1			.startupend1: pop hl 
626c			.startupend: 
626c			 
626c cd d2 0a			call clear_display 
626f cd f5 0a			call update_display 
6272 c9				ret 
6273			 
6273			 
6273			; stack over and underflow checks 
6273			 
6273			; init the words to detect the under/overflow 
6273			 
6273			chk_stk_init: 
6273				; a vague random number to check so we dont get any "lucky" hits 
6273 3e 2d			ld a, 45 
6275 6f				ld l, a 
6276 00				nop 
6277 3e 17			ld a, 23 
6279 67				ld h, a 
627a			 
627a 22 8a ef			ld (chk_word), hl     ; the word we need to check against 
627d			 
627d			;	ld (chk_stund), hl	; stack points.... 
627d 22 fd fb			ld (chk_stovr), hl 
6280 22 8e f9			ld (chk_ret_und), hl 
6283 22 0c f9			ld (chk_ret_ovr), hl 
6286 22 0a f7			ld (chk_loop_ovr), hl 
6289 22 08 f5			ld (chk_data_ovr), hl 
628c c9				ret 
628d				 
628d			check_stacks: 
628d				; check all stack words 
628d			 
628d e5				push hl 
628e d5				push de 
628f			 
628f			;	ld de,(chk_word) 
628f			;	ld hl, (chk_stund)	; stack points.... 
628f			;	if DEBUG_STK_FAULT 
628f			;		DMARK "FAa" 
628f			;		CALLMONITOR 
628f			;	endif 
628f			;	call cmp16 
628f			;	jp z, .chk_faulta 
628f			; 
628f			;	ld de, sfaultsu 
628f			;	jp .chk_fault 
628f			 
628f 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
6292 ed 5b 8a ef		ld de,(chk_word) 
6296				if DEBUG_STK_FAULT 
6296					DMARK "FAb" 
6296					CALLMONITOR 
6296				endif 
6296 cd 24 0d			call cmp16 
6299 28 06			jr z, .chk_fault1 
629b 11 3c 63			ld de, sfaultso 
629e c3 f0 62			jp .chk_fault 
62a1			.chk_fault1:  
62a1 2a 8e f9			ld hl, (chk_ret_und) 
62a4 ed 5b 8a ef		ld de,(chk_word) 
62a8				if DEBUG_STK_FAULT 
62a8					DMARK "FAU" 
62a8					CALLMONITOR 
62a8				endif 
62a8 cd 24 0d			call cmp16 
62ab ca b4 62			jp z, .chk_fault2 
62ae 11 4c 63			ld de, sfaultru 
62b1 c3 f0 62			jp .chk_fault 
62b4			.chk_fault2:  
62b4 2a 0c f9			ld hl, (chk_ret_ovr) 
62b7 ed 5b 8a ef		ld de,(chk_word) 
62bb				if DEBUG_STK_FAULT 
62bb					DMARK "FA1" 
62bb					CALLMONITOR 
62bb				endif 
62bb cd 24 0d			call cmp16 
62be ca c7 62			jp z, .chk_fault3 
62c1 11 5a 63			ld de, sfaultro 
62c4 c3 f0 62			jp .chk_fault 
62c7			.chk_fault3:  
62c7 2a 0a f7			ld hl, (chk_loop_ovr) 
62ca ed 5b 8a ef		ld de,(chk_word) 
62ce				if DEBUG_STK_FAULT 
62ce					DMARK "FA2" 
62ce					CALLMONITOR 
62ce				endif 
62ce cd 24 0d			call cmp16 
62d1 ca da 62			jp z, .chk_fault4 
62d4 11 74 63			ld de, sfaultlo 
62d7 c3 f0 62			jp .chk_fault 
62da			.chk_fault4:  
62da 2a 08 f5			ld hl, (chk_data_ovr) 
62dd ed 5b 8a ef		ld de,(chk_word) 
62e1				if DEBUG_STK_FAULT 
62e1					DMARK "FA3" 
62e1					CALLMONITOR 
62e1				endif 
62e1 cd 24 0d			call cmp16 
62e4 ca ed 62			jp z, .chk_fault5 
62e7 11 8e 63			ld de, sfaultdo 
62ea c3 f0 62			jp .chk_fault 
62ed			 
62ed			 
62ed			.chk_fault5:  
62ed d1				pop de 
62ee e1				pop hl 
62ef			 
62ef c9				ret 
62f0			 
62f0 cd d2 0a		.chk_fault: 	call clear_display 
62f3 3e 14				ld a, display_row_2 
62f5 cd e5 0a				call str_at_display 
62f8 11 1e 63				   ld de, .stackfault 
62fb 3e 00				ld a, display_row_1 
62fd cd e5 0a				call str_at_display 
6300 11 bd fb				    ld de, debug_mark 
6303 3e 11				ld a, display_row_1+17 
6305 cd e5 0a				call str_at_display 
6308 cd f5 0a				call update_display 
630b			 
630b				; prompt before entering montior for investigating issue 
630b			 
630b 3e 3c			ld a, display_row_4 
630d 11 11 19			ld de, endprog 
6310			 
6310 cd f5 0a			call update_display		 
6313			 
6313 cd 6f 1b			call next_page_prompt 
6316			 
6316 d1				pop de 
6317 e1				pop hl 
6318 cd 65 19				call monitor 
631b c3 5f 18				jp warmstart 
631e					;jp 0 
631e					;halt 
631e			 
631e			 
631e			 
631e .. 00		.stackfault: 	db "Stack fault:",0 
632b			 
632b .. 00		sfaultsu: 	db	"Stack under flow",0 
633c .. 00		sfaultso: 	db	"Stack over flow",0 
634c .. 00		sfaultru:	db "RTS underflow",0 
635a .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6374 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
638e .. 00		sfaultdo:	db "DTS overflow", 0 
639b			 
639b			 
639b			fault_dsp_under: 
639b 11 ad 63			ld de, .dsp_under 
639e c3 5d 64			jp .show_fault 
63a1			 
63a1			fault_rsp_under: 
63a1 11 bb 63			ld de, .rsp_under 
63a4 c3 5d 64			jp .show_fault 
63a7			fault_loop_under: 
63a7 11 c9 63			ld de, .loop_under 
63aa c3 5d 64			jp .show_fault 
63ad			 
63ad .. 00		.dsp_under: db "DSP Underflow",0 
63bb .. 00		.rsp_under: db "RSP Underflow",0 
63c9 .. 00		.loop_under: db "LOOP Underflow",0 
63d8			 
63d8			 
63d8 d5			type_faultn: 	push de 
63d9 e5					push hl 
63da cd d2 0a				call clear_display 
63dd 11 04 64				   ld de, .typefaultn 
63e0 3e 00				ld a, display_row_1 
63e2 cd e5 0a				call str_at_display 
63e5 11 bd fb				    ld de, debug_mark 
63e8 3e 11				ld a, display_row_1+17 
63ea cd e5 0a				call str_at_display 
63ed cd f5 0a				call update_display 
63f0			 
63f0				; prompt before entering montior for investigating issue 
63f0			 
63f0 3e 3c			ld a, display_row_4 
63f2 11 11 19			ld de, endprog 
63f5			 
63f5 cd f5 0a			call update_display		 
63f8			 
63f8 cd 6f 1b			call next_page_prompt 
63fb			 
63fb e5					push hl 
63fc d5					push de 
63fd cd 65 19				call monitor 
6400 c3 5f 18				jp warmstart 
6403 76					halt 
6404			 
6404			 
6404 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
641b			 
641b d5			type_faults: 	push de 
641c e5					push hl 
641d cd d2 0a				call clear_display 
6420 11 46 64				   ld de, .typefaults 
6423 3e 00				ld a, display_row_1 
6425 cd e5 0a				call str_at_display 
6428 11 bd fb				    ld de, debug_mark 
642b 3e 11				ld a, display_row_1+17 
642d cd e5 0a				call str_at_display 
6430 cd f5 0a				call update_display 
6433			 
6433				; prompt before entering montior for investigating issue 
6433			 
6433 3e 3c			ld a, display_row_4 
6435 11 11 19			ld de, endprog 
6438			 
6438 cd f5 0a			call update_display		 
643b			 
643b cd 6f 1b			call next_page_prompt 
643e			 
643e e1					pop hl 
643f d1					pop de 
6440 cd 65 19				call monitor 
6443 c3 5f 18				jp warmstart 
6446			 
6446			 
6446 .. 00		.typefaults: db "STR Type Expected TOS!",0 
645d			 
645d			.show_fault: 	 
645d d5					push de 
645e cd d2 0a				call clear_display 
6461 d1					pop de 
6462 3e 00				ld a, display_row_1 
6464 cd e5 0a				call str_at_display 
6467 11 bd fb				    ld de, debug_mark 
646a 3e 11				ld a, display_row_1+17 
646c cd e5 0a				call str_at_display 
646f cd f5 0a				call update_display 
6472			 
6472				; prompt before entering montior for investigating issue 
6472			 
6472 3e 3c			ld a, display_row_4 
6474 11 11 19			ld de, endprog 
6477			 
6477 cd f5 0a			call update_display		 
647a			 
647a cd 6f 1b			call next_page_prompt 
647d			 
647d e1					pop hl 
647e d1					pop de 
647f cd 65 19				call monitor 
6482			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6482			; TODO Make optional fault restart to cli or warm boot? 
6482					;jp warmstart 
6482 c3 b7 18				jp cli 
6485 76					halt 
6486			; eof 
# End of file forth_kernel.asm
6486			;include "nascombasic.asm" 
6486			 
6486			 
6486			; find out where the code ends if loaded into RAM (for SC114) 
6486			;endofcode:  
6486			;	nop 
6486			 
6486			 
6486			; eof 
6486			 
# End of file main.asm
6486			include "firmware_lcd_4x20.asm" 
6486			; **********************************************************************  
6486			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6486			; **********************************************************************  
6486			;  
6486			; **  Written as a Small Computer Monitor App  
6486			; **  www.scc.me.uk  
6486			;  
6486			; History  
6486			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6486			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6486			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6486			;  
6486			; **********************************************************************  
6486			;  
6486			; This program is an example of one of the methods of interfacing an   
6486			; alphanumeric LCD module.   
6486			;  
6486			; In this example the display is connected to either a Z80 PIO or a   
6486			; simple 8-bit output port.   
6486			;  
6486			; This interfacing method uses 4-bit data mode and uses time delays  
6486			; rather than polling the display's ready status. As a result the   
6486			; interface only requires 6 simple output lines:  
6486			;   Output bit 0 = not used  
6486			;   Output bit 1 = not used  
6486			;   Output bit 2 = RS         High = data, Low = instruction  
6486			;   Output bit 3 = E          Active high  
6486			;   Output bit 4 = DB4  
6486			;   Output bit 5 = DB5  
6486			;   Output bit 6 = DB6  
6486			;   Output bit 7 = DB7  
6486			; Display's R/W is connected to 0v so it is always in write mode  
6486			;  
6486			; This set up should work with any system supporting the RC2014 bus  
6486			  
6486			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6486			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6486			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6486			;  
6486			; **********************************************************************  
6486			  
6486			; **********************************************************************  
6486			; **  Constants  
6486			; **********************************************************************  
6486			; LCD constants required by LCD support module  
6486			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6486			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6486			kLCDBitE:   EQU 3              ;Port bit for LCD E signal  
6486			kLCDWidth:  EQU display_cols             ;Width in characters  
6486			  
6486			; **********************************************************************  
6486			; **  Code library usage  
6486			; **********************************************************************  
6486			  
6486			; send character to current cursor position  
6486			; wraps and/or scrolls screen automatically  
6486			  
6486			  
6486			lcd_init:  
6486			  
6486			; SCMonAPI functions used  
6486			  
6486			; Alphanumeric LCD functions used  
6486			; no need to specify specific functions for this module  
6486			  
6486 3e cf		            LD   A, 11001111b  
6488 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
648a 3e 00		            LD   A, 00000000b  
648c d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
648e			  
648e			; Initialise alphanumeric LCD module  
648e cd 07 65		            CALL fLCD_Init      ;Initialise LCD module  
6491			  
6491 c9				ret  
6492			  
6492			;  
6492			;;  
6492			; lcd functions  
6492			;  
6492			;  
6492			  
6492			; what is at cursor position   
6492			  
6492			;get_cursor:	ld de, (cursor_row)   ;  row + col  
6492			;		call curptr  
6492			;		ret  
6492			  
6492			  
6492			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
6492			  
6492			curptr:  
6492 c5				push bc  
6493 21 53 fb			ld hl, display_fb0  
6496			cpr:	  
6496				; loop for cursor whole row  
6496 0e 14			ld c, display_cols  
6498 23			cpr1:	inc hl  
6499 0d				dec c  
649a 20 fc			jr nz, cpr1  
649c 05				dec b  
649d 20 f7			jr nz, cpr  
649f			  
649f				; add col	  
649f			  
649f 23			cpr2:	inc hl  
64a0 1d				dec e  
64a1 20 fc			jr nz, cpr2  
64a3			  
64a3 c1				pop bc  
64a4 c9				ret  
64a5				  
64a5			  
64a5			  
64a5			  
64a5			  
64a5			; write the frame buffer given in hl to hardware   
64a5 22 5b fa		write_display: ld (display_write_tmp), hl 	   
64a8 3e 00			ld a, kLCD_Line1  
64aa cd 78 65		            CALL fLCD_Pos       ;Position cursor to location in A  
64ad 06 14			ld b, display_cols  
64af ed 5b 5b fa		ld de, (display_write_tmp)  
64b3 cd ff 64			call write_len_string  
64b6				  
64b6				  
64b6 2a 5b fa			ld hl, (display_write_tmp)  
64b9 11 14 00			ld de, display_cols  
64bc 19				add hl,de  
64bd 22 5b fa			ld (display_write_tmp),hl  
64c0			  
64c0				  
64c0 3e 40			ld a, kLCD_Line2  
64c2 cd 78 65		            CALL fLCD_Pos       ;Position cursor to location in A  
64c5 06 14			ld b, display_cols  
64c7 ed 5b 5b fa		ld de, (display_write_tmp)  
64cb cd ff 64			call write_len_string  
64ce				  
64ce 2a 5b fa			ld hl, (display_write_tmp)  
64d1 11 14 00			ld de, display_cols  
64d4 19				add hl,de  
64d5 22 5b fa			ld (display_write_tmp),hl  
64d8			  
64d8				  
64d8 3e 14			ld a, kLCD_Line3  
64da cd 78 65		            CALL fLCD_Pos       ;Position cursor to location in A  
64dd 06 14			ld b, display_cols  
64df ed 5b 5b fa		ld de, (display_write_tmp)  
64e3 cd ff 64			call write_len_string  
64e6				  
64e6 2a 5b fa			ld hl, (display_write_tmp)  
64e9 11 14 00			ld de, display_cols  
64ec 19				add hl,de  
64ed 22 5b fa			ld (display_write_tmp),hl  
64f0			  
64f0				  
64f0 3e 54			ld a, kLCD_Line4  
64f2 cd 78 65		            CALL fLCD_Pos       ;Position cursor to location in A  
64f5 06 14			ld b, display_cols  
64f7 ed 5b 5b fa		ld de, (display_write_tmp)  
64fb cd ff 64			call write_len_string  
64fe c9					ret  
64ff				  
64ff				; write out a fixed length string given in b from de  
64ff			  
64ff 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6500 cd 51 65		            CALL fLCD_Data      ;Write character to display  
6503 13				inc de  
6504 10 f9			djnz write_len_string  
6506 c9				ret  
6507			  
6507			; Some other things to do  
6507			;            LD   A, kLCD_Clear ;Display clear  
6507			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
6507			;            LD   A, kLCD_Under ;Display on with underscore cursor  
6507			;            LD   A, kLCD_On     ;Display on with no cursor  
6507			;            ;LD   A, kLCD_Off   ;Display off  
6507			;            CALL fLCD_Inst      ;Send instruction to display  
6507			;  
6507			;  
6507			;            halt  
6507			;  
6507			;  
6507			;MsgHello:   DB  "Hello World!",0  
6507			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
6507			  
6507			; Custom characters 5 pixels wide by 8 pixels high  
6507			; Up to 8 custom characters can be defined  
6507			;BitMaps:      
6507			;; Character 0x00 = Battery icon  
6507			;            DB  01110b  
6507			;            DB  11011b  
6507			;            DB  10001b  
6507			;            DB  10001b  
6507			;            DB  11111b  
6507			;            DB  11111b  
6507			;            DB  11111b  
6507			;            DB  11111b  
6507			;; Character 0x01 = Bluetooth icon  
6507			;            DB  01100b  
6507			;            DB  01010b  
6507			;            DB  11100b  
6507			;            DB  01000b  
6507			;            DB  11100b  
6507			;            DB  01010b  
6507			;            DB  01100b  
6507			;            DB  00000b  
6507			;  
6507			  
6507			  
6507			; **********************************************************************  
6507			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
6507			; **********************************************************************  
6507			;  
6507			; **  Written as a Small Computer Monitor App   
6507			; **  Version 0.1 SCC 2018-05-16  
6507			; **  www.scc.me.uk  
6507			;  
6507			; **********************************************************************  
6507			;  
6507			; This module provides support for alphanumeric LCD modules using with  
6507			; *  HD44780 (or compatible) controller  
6507			; *  5 x 7 pixel fonts  
6507			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
6507			; *  Interface via six digital outputs to the display (see below)  
6507			;  
6507			; LCD module pinout:  
6507			;   1  Vss   0v supply  
6507			;   2  Vdd   5v supply  
6507			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
6507			;   4  RS    High = data, Low = instruction  
6507			;   5  R/W   High = Read, Low = Write  
6507			;   6  E     Enable signal (active high)  
6507			;   7  DB0   Data bit 0  
6507			;   8  DB1   Data bit 1  
6507			;   9  DB2   Data bit 2  
6507			;  10  DB3   Data bit 3  
6507			;  11  DB4   Data bit 4  
6507			;  12  DB5   Data bit 5  
6507			;  13  DB6   Data bit 6  
6507			;  14  DB7   Data bit 7  
6507			;  15  A     Backlight anode (+)  
6507			;  16  K     Backlight cathode (-)  
6507			;  
6507			; This interfacing method uses 4-bit data mode and uses time delays  
6507			; rather than polling the display's ready status. As a result the   
6507			; interface only requires 6 simple output lines:  
6507			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
6507			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
6507			;   LCD DB4 = Microcomputer output port bit 4  
6507			;   LCD DB5 = Microcomputer output port bit 5  
6507			;   LCD DB6 = Microcomputer output port bit 6  
6507			;   LCD DB7 = Microcomputer output port bit 7  
6507			; Display's R/W is connected to 0v so it is always in write mode  
6507			; All 6 connections must be on the same port address <kLCDPrt>  
6507			; This method also allows a decent length of cable from micro to LCD  
6507			;  
6507			; **********************************************************************  
6507			;  
6507			; To include the code for any given function provided by this module,   
6507			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
6507			; the parent source file.  
6507			; For example:  #REQUIRES   uHexPrefix  
6507			;  
6507			; Also #INCLUDE this file at some point after the #REQUIRES statements  
6507			; in the parent source file.  
6507			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
6507			;  
6507			; These are the function names provided by this module:  
6507			; fLCD_Init                     ;Initialise LCD  
6507			; fLCD_Inst                     ;Send instruction to LCD  
6507			; fLCD_Data                     ;Send data byte to LCD  
6507			; fLCD_Pos                      ;Position cursor  
6507			; fLCD_Str                      ;Display string  
6507			; fLCD_Def                      ;Define custom character  
6507			;  
6507			; **********************************************************************  
6507			;  
6507			; Requires SCMonAPI.asm to also be included in the project  
6507			;  
6507			  
6507			  
6507			; **********************************************************************  
6507			; **  Constants  
6507			; **********************************************************************  
6507			  
6507			; Constants that must be defined externally  
6507			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
6507			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
6507			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
6507			;kLCDWidth: EQU 20             ;Width in characters  
6507			  
6507			; general line offsets in any frame buffer  
6507			  
6507			  
6507			display_row_1: equ 0  
6507			display_row_2: equ display_row_1+display_cols  
6507			display_row_3: equ display_row_2 + display_cols  
6507			display_row_4: equ display_row_3 + display_cols  
6507			;display_row_4_eol:   
6507			  
6507			  
6507			; Cursor position values for the start of each line  
6507			kLCD_Line1: EQU 0x00   
6507			kLCD_Line2: EQU 0x40    
6507			kLCD_Line3: EQU kLCD_Line1+kLCDWidth  
6507			kLCD_Line4: EQU kLCD_Line2+kLCDWidth   
6507			  
6507			; Instructions to send as A register to fLCD_Inst  
6507			kLCD_Clear: EQU 00000001b     ;LCD clear  
6507			kLCD_Off:   EQU 00001000b     ;LCD off  
6507			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
6507			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
6507			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
6507			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
6507			  
6507			; Constants used by this code module  
6507			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
6507			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
6507			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
6507			  
6507			  
6507			  
6507			; **********************************************************************  
6507			; **  LCD support functions  
6507			; **********************************************************************  
6507			  
6507			; Initialise alphanumeric LCD module  
6507			; LCD control register codes:  
6507			;   DL   0 = 4-bit mode        1 = 8-bit mode  
6507			;   N    0 = 1-line mode       1 = 2-line mode  
6507			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
6507			;   D    0 = Display off       1 = Display on  
6507			;   C    0 = Cursor off        1 = Cursor on  
6507			;   B    0 = Blinking off      1 = Blinking on  
6507			;   ID   0 = Decrement mode    1 = Increment mode  
6507			;   SH   0 = Entire shift off  1 = Entire shift on  
6507 3e 28		fLCD_Init:  LD   A, 40  
6509 cd be 65		            CALL LCDDelay       ;Delay 40ms after power up  
650c			; For reliable reset set 8-bit mode - 3 times  
650c cd a8 65		            CALL WrFn8bit       ;Function = 8-bit mode  
650f cd a8 65		            CALL WrFn8bit       ;Function = 8-bit mode  
6512 cd a8 65		            CALL WrFn8bit       ;Function = 8-bit mode  
6515			; Set 4-bit mode  
6515 cd a4 65		            CALL WrFn4bit       ;Function = 4-bit mode  
6518 cd bc 65		            CALL LCDDelay1      ;Delay 37 us or more  
651b			; Function set  
651b 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
651d cd 30 65		            CALL fLCD_Inst      ;2 line, display on  
6520			; Display On/Off control  
6520 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6522 cd 30 65		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6525			; Display Clear  
6525 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6527 cd 30 65		            CALL fLCD_Inst      ;Clear display  
652a			; Entry mode  
652a 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
652c cd 30 65		            CALL fLCD_Inst      ;Increment mode, shift off  
652f			; Display module now initialised  
652f c9			            RET  
6530			; ok to here  
6530			  
6530			; Write instruction to LCD  
6530			;   On entry: A = Instruction byte to be written  
6530			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6530 f5			fLCD_Inst:  PUSH AF  
6531 f5			            PUSH AF  
6532 cd 44 65		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6535 f1			            POP  AF  
6536 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6537 17			            RLA  
6538 17			            RLA  
6539 17			            RLA  
653a cd 44 65		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
653d 3e 02		            LD   A, 2  
653f cd be 65		            CALL LCDDelay       ;Delay 2 ms to complete   
6542 f1			            POP  AF  
6543 c9			            RET  
6544 e6 f0		Wr4bits:   AND  0xF0           ;Mask so we only have D4 to D7  
6546 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6548 cb df		            SET  kLCDBitE, A  
654a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
654c cb 9f		            RES  kLCDBitE, A  
654e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6550 c9			            RET  
6551			  
6551			  
6551			; Write data to LCD  
6551			;   On entry: A = Data byte to be written  
6551			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6551 f5			fLCD_Data:  PUSH AF  
6552 f5			            PUSH AF  
6553 cd 65 65		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6556 f1			            POP  AF  
6557 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6558 17			            RLA  
6559 17			            RLA  
655a 17			            RLA  
655b cd 65 65		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
655e 3e 96		            LD   A, 150  
6560 3d			Wait:      DEC  A              ;Wait a while to allow data   
6561 20 fd		            JR   NZ, Wait      ;  write to complete  
6563 f1			            POP  AF  
6564 c9			            RET  
6565 e6 f0		Wr4bitsa:   AND  0xF0           ;Mask so we only have D4 to D7  
6567 cb d7		            SET  kLCDBitRS, A  
6569 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
656b cb df		            SET  kLCDBitE, A  
656d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
656f cb 9f		            RES  kLCDBitE, A  
6571 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6573 cb 97		            RES  kLCDBitRS, A  
6575 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6577 c9			            RET  
6578			  
6578			  
6578			; Position cursor to specified location  
6578			;   On entry: A = Cursor position  
6578			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6578 f5			fLCD_Pos:   PUSH AF  
6579 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
657b cd 30 65		            CALL fLCD_Inst      ;Write instruction to LCD  
657e f1			            POP  AF  
657f c9			            RET  
6580			  
6580			  
6580			; Output text string to LCD  
6580			;   On entry: DE = Pointer to null terminated text string  
6580			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6580 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6581 b7			            OR   A              ;Null terminator?  
6582 c8			            RET  Z              ;Yes, so finished  
6583 cd 51 65		            CALL fLCD_Data      ;Write character to display  
6586 13			            INC  DE             ;Point to next character  
6587 18 f7		            JR   fLCD_Str       ;Repeat  
6589 c9					ret  
658a			  
658a			; Define custom character  
658a			;   On entry: A = Character number (0 to 7)  
658a			;             DE = Pointer to character bitmap data  
658a			;   On exit:  A = Next character number  
658a			;             DE = Next location following bitmap  
658a			;             BC HL IX IY I AF' BC' DE' HL' preserved  
658a			; Character is   
658a c5			fLCD_Def:   PUSH BC  
658b f5			            PUSH AF  
658c 07			            RLCA                ;Calculate location  
658d 07			            RLCA                ;  for bitmap data  
658e 07			            RLCA                ;  = 8 x CharacterNumber  
658f f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6591 cd 30 65		            CALL fLCD_Inst      ;Write instruction to LCD  
6594 06 00		            LD   B, 0  
6596 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6597 cd 51 65		            CALL fLCD_Data      ;Write byte to display  
659a 13			            INC  DE             ;Point to next byte  
659b 04			            INC  B              ;Count bytes  
659c cb 58		            BIT  3, B           ;Finish all 8 bytes?  
659e 28 f6		            JR   Z, Loop       ;No, so repeat  
65a0 f1			            POP  AF  
65a1 3c			            INC  A              ;Increment character number  
65a2 c1			            POP  BC  
65a3 c9			            RET  
65a4			  
65a4			  
65a4			; **********************************************************************  
65a4			; **  Private functions  
65a4			; **********************************************************************  
65a4			  
65a4			; Write function to LCD  
65a4			;   On entry: A = Function byte to be written  
65a4			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
65a4 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
65a6 18 02		            JR   WrFunc  
65a8 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
65aa f5			WrFunc:     PUSH AF  
65ab d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65ad cb df		            SET  kLCDBitE, A  
65af d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
65b1 cb 9f		            RES  kLCDBitE, A  
65b3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
65b5 3e 05		            LD   A, 5  
65b7 cd be 65		            CALL LCDDelay       ;Delay 5 ms to complete  
65ba f1			            POP  AF  
65bb c9			            RET  
65bc			  
65bc			  
65bc			; Delay in milliseconds  
65bc			;   On entry: A = Number of milliseconds delay  
65bc			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
65bc 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
65be d5			LCDDelay:   PUSH DE  
65bf 5f			            LD   E, A           ;Delay by 'A' ms  
65c0 16 00		            LD   D, 0  
65c2 cd 37 0a		            CALL aDelayInMS  
65c5 d1			            POP  DE  
65c6 c9			            RET  
65c7			  
65c7			  
65c7			  
65c7			  
65c7			; eof  
65c7			  
# End of file firmware_lcd_4x20.asm
65c7			include "firmware_key_4x4.asm" 
65c7			  
65c7			  
65c7			; bit mask for each scan column and row for teing the matrix  
65c7			  
65c7			; out   
65c7 80 40 20 10	key_row_bitmask:    db 128, 64, 32, 16  
65cb			; in  
65cb 01 02 04 08	key_col_bitmask:    db 1, 2, 4, 8  
65cf			  
65cf			; row/col to character map  
65cf			  
65cf			; char, state use   123xxsss   - bit 8,7,6 this key selects specified state, s is this key is member of that state  
65cf			;    
65cf			  
65cf			; physical key matrix map to face of key  
65cf			  
65cf			  
65cf			;      	1	2	3	A  
65cf			;   	abc”	def&	ghi$	s1  
65cf			;			  
65cf			;	4	5	6	B  
65cf			; 	jkl,	mno.	pqr:	s2  
65cf			;			  
65cf			; 	7	8	9	C  
65cf			;	stu;	vwx@	yz?!	s3  
65cf			;			  
65cf			; 	*	0	#	D  
65cf			; 	shift lck '	Space < >	Enter ( )	s4  
65cf			;       tab bs 		  
65cf			  
65cf			  
65cf			  
65cf			  
65cf			key_init:  
65cf			  
65cf			; SCMonAPI functions used  
65cf			  
65cf			; Alphanumeric LCD functions used  
65cf			; no need to specify specific functions for this module  
65cf			  
65cf			  
65cf 3e cf		            LD   A, 11001111b  
65d1 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
65d3			;            LD   A, 00000000b  
65d3 3e 0f		            LD   A, 00001111b  
65d5 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
65d7			  
65d7			  
65d7				; TODO Configure cursor shapes  
65d7			  
65d7				; Load cursor shapes   
65d7 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
65d9 11 e9 65		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
65dc 06 02		            LD   B, 2           ;Number of characters to define  
65de cd 8a 65		.DefLoop:   CALL fLCD_Def       ;Define custom character  
65e1 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
65e3			  
65e3 3e 01				ld a, 1  
65e5 32 56 fa			ld (cursor_shape),a  
65e8 c9				ret  
65e9			  
65e9			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
65e9			; Up to 8 custom characters can be defined  
65e9			.cursor_shapes:      
65e9			;; Character 0x00 = Normal  
65e9 1f			            DB  11111b  
65ea 1f			            DB  11111b  
65eb 1f			            DB  11111b  
65ec 1f			            DB  11111b  
65ed 1f			            DB  11111b  
65ee 1f			            DB  11111b  
65ef 1f			            DB  11111b  
65f0 1f			            DB  11111b  
65f1			;; Character 0x01 = Modifier  
65f1 1f			            DB  11111b  
65f2 1b			            DB  11011b  
65f3 1b			            DB  11011b  
65f4 1b			            DB  11011b  
65f5 1b			            DB  11011b  
65f6 1f			            DB  11111b  
65f7 1b			            DB  11011b  
65f8 1f			            DB  11111b  
65f9			  
65f9			  
65f9			  
65f9			  
65f9			; Display custom character 0  
65f9			;            LD   A, kLCD_Line1+14  
65f9			;            CALL fLCD_Pos       ;Position cursor to location in A  
65f9			;            LD   A, 0  
65f9			;            CALL fLCD_Data      ;Write character in A at cursor  
65f9			  
65f9			; Display custom character 1  
65f9			;            LD   A, kLCD_Line2+14  
65f9			;            CALL fLCD_Pos      ;Position cursor to location in A  
65f9			;            LD   A, 1  
65f9			;            CALL fLCD_Data     ;Write character in A at cursor  
65f9			  
65f9			; keyboard scanning   
65f9			  
65f9			  
65f9			; key_rows: equ 4  
65f9			; key_cols: equ 4  
65f9			; keyscan_table: edu ( tos-stacksize-(key_rows*key_cols))  
65f9			  
65f9			; key_scanr: equ key_row_bitmask  
65f9			; key_scanc: equ key_col_bitmask  
65f9			  
65f9			; key_char_map: equ key_map  
65f9			  
65f9			  
65f9			  
65f9			; character in from keyboard  
65f9			  
65f9 ..			.matrix_to_char: db "D#0*C987B654A321"  
6609			  
6609			  
6609			; map the physical key to a char dependant on state  
6609			  
6609			.key_map_fa:   
6609			  
6609 ..					db 'D'  
660a 0d					db KEY_CR    ; cr  
660b ..					db ' '  
660c 04					db  KEY_SHIFTLOCK   ; TODO Shift lock  
660d ..					db 'C'  
660e ..					db 'y'  
660f ..					db 'v'  
6610 ..					db 's'  
6611 ..					db 'B'  
6612 ..					db 'p'  
6613 ..					db 'm'  
6614 ..					db 'j'  
6615 ..					db 'A'  
6616 ..					db 'g'  
6617 ..					db 'd'  
6618 ..					db 'a'  
6619			  
6619			.key_map_fb:  
6619			  
6619 ..					db 'A'  
661a ..					db '+'   
661b ..					db '<'  
661c ..					db  "'"    
661d			  
661d ..					db 'A'  
661e ..					db 'z'  
661f ..					db 'w'  
6620 ..					db 't'  
6621 ..					db 'A'  
6622 ..					db 'q'  
6623 ..					db 'n'  
6624 ..					db 'k'  
6625 ..					db 'A'  
6626 ..					db 'h'  
6627 ..					db 'e'  
6628 ..			 		db 'b'  
6629			  
6629			.key_map_fc:   
6629			  
6629			  
6629 ..					db 'A'  
662a ..					db '-'   
662b ..					db '>'  
662c ..					db  '='   	  
662d ..					db 'A'  
662e ..					db '?'  
662f ..					db 'x'  
6630 ..					db 'u'  
6631 ..					db 'A'  
6632 ..					db 'r'  
6633 ..					db 'o'  
6634 ..					db 'l'  
6635 ..					db 'A'  
6636 ..					db 'i'  
6637 ..					db 'f'  
6638 ..					db 'c'  
6639			  
6639				  
6639			.key_map_fd:  
6639			  
6639 ..					db 'A'  
663a ..					db '/'   
663b ..					db '%'   
663c 08					db KEY_BS  ; back space  
663d ..					db 'A'  
663e ..					db '!'  
663f ..					db '@'  
6640 ..					db ';'  
6641 ..					db 'A'  
6642 ..					db ':'  
6643 ..					db '.'  
6644 ..					db ','  
6645 ..					db 'A'  
6646 ..					db '$'  
6647 ..					db '&'  
6648 ..				 	db '"'  
6649			  
6649					  
6649				  
6649			  
6649			; add cin and cin_wait  
6649			  
6649 cd 5a 66		cin_wait: 	call cin  
664c fe 00			cp 0  
664e 28 f9			jr z, cin_wait   ; block until key press  
6650			  
6650 f5				push af   ; save key pressed  
6651			  
6651 cd 5a 66		.cin_wait1:	call cin  
6654 fe 00			cp 0  
6656 20 f9			jr nz, .cin_wait1  	; wait for key release  
6658			  
6658 f1				pop af   ; get key  
6659 c9				ret  
665a			  
665a			  
665a cd 6b 66		cin: 	call .mtoc  
665d			  
665d				; no key held  
665d fe 00			cp 0  
665f c8				ret z  
6660			  
6660				; stop key bounce  
6660			  
6660			;	ld (key_held),a		 ; save it  
6660 47				ld b, a  
6661			  
6661 c5			.cina1:	push bc  
6662 cd 6b 66			call .mtoc  
6665 c1				pop bc  
6666 b8				cp b  
6667 28 f8			jr z, .cina1  
6669 78				ld a,b		  
666a c9				ret  
666b			  
666b			; detect keyboard modifier key press and apply new overlay to the face key held  
666b			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
666b			  
666b			;.cin_map_modifier:   
666b			;	ld a, (hl)  
666b			;	and 255  
666b			;	ret NZ		; modifier key not flagged  
666b			;  
666b			;	; get key face  
666b			;  
666b			;	ld b,(key_face_held)  
666b			;  
666b			;	ld b, key_cols * key_rows  
666b			;  
666b			;	push de  
666b			;	pop hl  
666b			;  
666b			;.mmod1: ld a,(hl)   ; get map test  
666b			;	cp b  
666b			;	jr z, .mmod2  
666b			;  
666b			;  
666b			;  
666b			;.mmod2: inc hl    ;   
666b			;  
666b			;	  
666b			;  
666b			;	  
666b			;  
666b			;	ld hl,key_actual_pressed  
666b			;	ld (hl),a,  
666b			;	ret  
666b			  
666b				  
666b			  
666b			; map matrix key held to char on face of key  
666b			  
666b			.mtoc:  
666b			  
666b			  
666b				; TODO optimise the code....  
666b			  
666b			; scan keyboard row 1  
666b 3e 80			ld a, 128  
666d 21 d3 fb			ld hl, keyscan_table  
6670 cd 52 67			call .rowscan  
6673			  
6673				   
6673			  
6673 3e 40			ld a, 64  
6675 21 d7 fb			ld hl, keyscan_table+key_cols  
6678 cd 52 67			call .rowscan  
667b			  
667b			  
667b			  
667b			  
667b 3e 20			ld a, 32  
667d 21 db fb			ld hl, keyscan_table+(key_cols*2)  
6680 cd 52 67			call .rowscan  
6683			  
6683			  
6683			  
6683 3e 10			ld a, 16  
6685 21 df fb			ld hl, keyscan_table+(key_cols*3)  
6688 cd 52 67			call .rowscan  
668b			  
668b			  
668b				; flag if key D is held down and remove from reporting  
668b 01 39 66			ld bc, .key_map_fd    
668e 21 d3 fb			ld hl, keyscan_table  
6691 11 c5 fb			ld de, key_fd  
6694 cd e4 66			call .key_shift_hold  
6697 fe ff			cp 255  
6699 28 33			jr z, .cinmap  
669b				; flag if key C is held down and remove from reporting  
669b 01 29 66			ld bc, .key_map_fc    
669e 21 d7 fb			ld hl, keyscan_table+key_cols  
66a1 11 c6 fb			ld de, key_fc  
66a4 cd e4 66			call .key_shift_hold  
66a7 fe ff			cp 255  
66a9 28 23			jr z, .cinmap  
66ab				; flag if key B is held down and remove from reporting  
66ab 01 19 66			ld bc, .key_map_fb    
66ae 21 db fb			ld hl, keyscan_table+(key_cols*2)  
66b1 11 c7 fb			ld de, key_fb  
66b4 cd e4 66			call .key_shift_hold  
66b7 fe ff			cp 255  
66b9 28 13			jr z, .cinmap  
66bb				; flag if key A is held down and remove from reporting  
66bb 01 09 66			ld bc, .key_map_fa    
66be 21 df fb			ld hl, keyscan_table+(key_cols*3)  
66c1 11 c8 fb			ld de, key_fa  
66c4 cd e4 66			call .key_shift_hold  
66c7 fe ff			cp 255  
66c9 28 03			jr z, .cinmap  
66cb			  
66cb 11 f9 65			ld de, .matrix_to_char  
66ce			  
66ce			  
66ce			.cinmap:   
66ce				if DEBUG_KEY  
66ce			            LD   A, kLCD_Line4  
66ce			            CALL fLCD_Pos       ;Position cursor to location in A  
66ce					push de  
66ce			            LD   DE, keyscan_table  
66ce			            CALL fLCD_Str       ;Display string pointed to by DE  
66ce					pop de  
66ce				endif  
66ce			  
66ce				; scan key matrix table for any held key  
66ce			  
66ce				; de holds either the default matrix or one selected above  
66ce			  
66ce 21 d3 fb			ld hl, keyscan_table  
66d1 06 10			ld b,key_cols*key_rows  
66d3			  
66d3 7e			.cin1:	ld a,(hl)  
66d4 fe 23			cp '#'  
66d6 28 08			jr z, .cinhit  
66d8 23				inc hl  
66d9 13				inc de  
66da 05				dec b  
66db 20 f6			jr nz, .cin1  
66dd				; no key found held  
66dd 3e 00			ld a,0  
66df c9				ret  
66e0 d5			.cinhit: push de  
66e1 e1				pop hl  
66e2 7e				ld a,(hl)  
66e3 c9				ret  
66e4			  
66e4			; flag a control key is held   
66e4			; hl is key pin, de is flag indicator  
66e4			  
66e4			.key_shift_hold:  
66e4 c5				push bc  
66e5 3e 01			ld a, 1  
66e7 32 56 fa			ld (cursor_shape),a  
66ea 06 00			ld b, 0  
66ec 7e				ld a, (hl)  
66ed fe 2e			cp '.'  
66ef 28 0a			jr z, .key_shift1  
66f1 06 ff			ld b, 255  
66f3 3e 2b			ld a, '+'    ; hide key from later scans  
66f5 77				ld (hl),a  
66f6 3e 02			ld a, 2  
66f8 32 56 fa			ld (cursor_shape),a  
66fb			.key_shift1:  
66fb				; write flag indicator  
66fb 78				ld a,b  
66fc 12				ld (de),a  
66fd			  
66fd d1				pop de    ; de now holds the key map ptr  
66fe c9				ret  
66ff			  
66ff				  
66ff				  
66ff			  
66ff			  
66ff			  
66ff			  
66ff			  
66ff			  
66ff			  
66ff			  
66ff			  
66ff			  
66ff c9				ret  
6700			  
6700			;	push hl  
6700			;	push de  
6700			;	push bc  
6700			;	call keyscan  
6700			;	; map key matrix to ascii value of key face  
6700			;  
6700			;	ld hl, key_face_map  
6700			;	ld de, keyscan_table  
6700			;  
6700			;	; get how many keys to look at  
6700			;	ld b, keyscan_table_len  
6700			;	  
6700			;  
6700			;	; at this stage fall out on first key hit  
6700			;	; TODO handle multiple key press  
6700			;  
6700			;map1:	ld a,(hl)  
6700			;	cp '#'  
6700			;	jr z, keyhit  
6700			;	inc hl  
6700			;	inc de  
6700			;	dec b  
6700			;	jr nz, map1  
6700			;nohit:	ld a, 0  
6700			;	jr keydone  
6700			;keyhit: push de  
6700			;	pop hl  
6700			;	ld a,(hl)  
6700			;keydone:  
6700			;	push bc  
6700			;	push de  
6700			; 	push hl  
6700			;	ret   
6700			;  
6700			  
6700			  
6700			  
6700			  
6700			; scan physical key matrix  
6700			  
6700			  
6700			;keyscan:  
6700			;  
6700			;; for each key_row use keyscanr bit mask for out  
6700			;; then read in for keyscanc bitmask  
6700			;; save result of row scan to keyscantable  
6700			;  
6700			;; scan keyboard row 1  
6700			;  
6700			;	ld b, key_rows  
6700			;	ld hl, key_scanr  
6700			;	ld de, keyscan_table  
6700			;  
6700			;rowloop:  
6700			;  
6700			;	ld a,(hl)		; out bit mask to energise keyboard row  
6700			;	call rowscan  
6700			;	inc hl  
6700			;	dec b  
6700			;	jr nz, rowloop  
6700			;  
6700			;	ret  
6700			;  
6700			;  
6700			;; pass a out bitmask, b row number  
6700			;arowscan:   
6700			;	push bc  
6700			;  
6700			;	ld d, b  
6700			;  
6700			;	; calculate buffer location for this row  
6700			;  
6700			;	ld hl, keyscan_table	  
6700			;kbufr:  ld e, key_cols  
6700			;kbufc:	inc hl  
6700			;	dec e  
6700			;	jr nz, kbufc  
6700			;	dec d  
6700			;	jr nz, kbufr  
6700			;  
6700			;	; energise row and read columns  
6700			;  
6700			;	out (portbdata),a  
6700			;	in a,(portbdata)  
6700			;	ld c,a  
6700			;  
6700			;  
6700			;	; save buffer loc  
6700			;  
6700			;	ld (keybufptr), hl  
6700			;  
6700			;	ld hl, key_scanc  
6700			;	ld d, key_cols  
6700			;  
6700			;	; for each column check each bit mask  
6700			;  
6700			;colloop:  
6700			;	  
6700			;  
6700			;	; reset flags for the row   
6700			;  
6700			;	ld b,'.'  
6700			;	and (hl)  
6700			;	jr z, maskskip  
6700			;	ld b,'#'  
6700			;maskskip:  
6700			;	; save  key state  
6700			;	push hl  
6700			;	ld hl, (keybufptr)  
6700			;	ld (hl), b  
6700			;	inc hl  
6700			;	ld (keybufptr), hl  
6700			;  
6700			;	; move to next bit mask  
6700			;	pop hl  
6700			;	inc hl  
6700			;  
6700			;	dec d  
6700			;	jr nz, colloop  
6700			;  
6700			;	ret  
6700			;  
6700			;  
6700			;;  
6700			; lcd functions  
6700			;  
6700			;  
6700			  
6700			;if DEBUG_KEY_MATRIX  
6700			  
6700			; test function to display hardware view of matrix state  
6700			  
6700			matrix:  
6700			  
6700			  
6700			  
6700			; scan keyboard row 1  
6700 3e 80			ld a, 128  
6702 21 f8 fb			ld hl, keyscan_table_row1  
6705 cd 52 67			call .rowscan  
6708			  
6708 3e 40			ld a, 64  
670a 21 f3 fb			ld hl, keyscan_table_row2  
670d cd 52 67			call .rowscan  
6710			  
6710 3e 20			ld a, 32  
6712 21 ee fb			ld hl, keyscan_table_row3  
6715 cd 52 67			call .rowscan  
6718			  
6718 3e 10			ld a, 16  
671a 21 e9 fb			ld hl, keyscan_table_row4  
671d cd 52 67			call .rowscan  
6720			  
6720			; Display text on first line  
6720 3e 00		            LD   A, kLCD_Line1  
6722 cd 78 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6725 11 f8 fb		            LD   DE, keyscan_table_row1  
6728			            ;LD   DE, MsgHello  
6728 cd 80 65		            CALL fLCD_Str       ;Display string pointed to by DE  
672b			  
672b			; Display text on second line  
672b 3e 40		            LD   A, kLCD_Line2  
672d cd 78 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6730 11 f3 fb		            LD   DE, keyscan_table_row2  
6733 cd 80 65		            CALL fLCD_Str       ;Display string pointed to by DE  
6736 3e 14		            LD   A, kLCD_Line3  
6738 cd 78 65		            CALL fLCD_Pos       ;Position cursor to location in A  
673b 11 ee fb		            LD   DE, keyscan_table_row3  
673e cd 80 65		            CALL fLCD_Str       ;Display string pointed to by DE  
6741 3e 54		            LD   A, kLCD_Line4  
6743 cd 78 65		            CALL fLCD_Pos       ;Position cursor to location in A  
6746 11 e9 fb		            LD   DE, keyscan_table_row4  
6749 cd 80 65		            CALL fLCD_Str       ;Display string pointed to by DE  
674c			  
674c cd 46 0a			call delay250ms  
674f c3 00 67			jp matrix  
6752			  
6752			; pass de as row display flags  
6752			.rowscan:   
6752 d3 c1			out (portbdata),a  
6754 db c1			in a,(portbdata)  
6756 4f				ld c,a  
6757				; reset flags for the row   
6757 06 2e			ld b,'.'  
6759 e6 01			and 1  
675b 28 02			jr z, .p1on  
675d 06 23			ld b,'#'  
675f			.p1on:  
675f 70				ld (hl), b  
6760 23				inc hl  
6761			  
6761 06 2e			ld b,'.'  
6763 79				ld a,c  
6764 e6 02			and 2  
6766			;	bit 0,a  
6766 28 02			jr z, .p2on  
6768 06 23			ld b,'#'  
676a			.p2on:  
676a 70				ld (hl), b  
676b 23				inc hl  
676c			;  
676c 06 2e			ld b,'.'  
676e 79				ld a,c  
676f e6 04			and 4  
6771			;;	bit 0,a  
6771 28 02			jr z, .p3on  
6773 06 23			ld b,'#'  
6775			.p3on:  
6775 70				ld (hl), b  
6776 23				inc hl  
6777			;;  
6777 06 2e			ld b,'.'  
6779			;;	bit 0,a  
6779 79				ld a,c  
677a e6 08			and 8  
677c 28 02			jr z, .p4on  
677e 06 23			ld b,'#'  
6780			.p4on:  
6780 70				ld (hl), b  
6781 23				inc hl  
6782			  
6782			; zero term  
6782 06 00			ld b,0  
6784 70				ld (hl), b  
6785			  
6785 c9			.rscandone: ret  
6786			  
6786			  
6786			  
6786			;endif  
6786			  
6786			  
6786			; eof  
# End of file firmware_key_4x4.asm
# End of file os_mini.asm
6786
