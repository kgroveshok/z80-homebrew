# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 65 18			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 ..			buildtime: db   "Build: " 
010a					include "romtimestamp.asm" 
010a ..			db '2025-08-07 17:04' 
# End of file romtimestamp.asm
011a 00				   db 0 
011b			 
011b			 
011b			 
011b			;        nop  
011b			;        nop 
011b			;;	org 05h		; null out bdos call 
011b			; 
011b			;        nop  
011b			;        nop  
011b			;        nop 
011b			;;	org 08h 
011b			;;; 
011b			;;	jp cin		; rst 8 - char in 
011b			;;; 
011b			; 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;	org 010h 
011b			;; 
011b			;	jp cout		; rest 010h  - char out 
011b			;; 
011b			;	org 01bh   
011b			; 
011b			;	;jp  		; rst 01bh   - write string to display 
011b			;	jp str_at_display 
011b			; 
011b			; 
011b			;	org 020h 
011b			; 
011b			;	; jp		 ; rst 020h - read char at screen location 
011b			; 
011b			;	org 028h 
011b			 
011b				; jp		 ; rst 028h  - storage i/o 
011b			 
011b			; 	org 030h 
011b			;	jp break_point_state 
011b			  
011b			; $30  
011b			; org 038h 
011b			; $38 
011b			 
011b			; TODO any more important entry points to add to jump table for easier coding use? 
011b			 
011b			if BASE_KEV = 1  
011b			 
011b				; need to be at $66 for nmi support 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255 
011b				jp nmi 
011b			endif 
011b			 
011b			include "firmware.asm" 
011b			  
011b			; main constants (used here and in firmware)  
011b			  
011b			; TODO have page 0 of storage as bios  
011b			  
011b			Device_A: equ 0h  
011b			Device_B: equ 040h          ; Sound  
011b			  
011b			if BASE_KEV  
011b			Device_C: equ 080h          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			if BASE_SC114  
011b			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			if BASE_CPM  
011b			; TODO fixup for CPM  
011b			Device_C: equ 080h          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			Device_D: equ 0c0h             ; Keyboard and LCD  
011b			  
011b			; Odd specific debug points for testing hardware dev  
011b			  
011b			DEBUG_SOUND: equ 0       
011b			DEBUG_STK_FAULT: equ 0  
011b			DEBUG_INPUT: equ 0     ; Debug input entry code  
011b			DEBUG_KEYCINWAIT: equ 0  
011b			DEBUG_KEYCIN: equ 0  
011b			DEBUG_KEY: equ 0  
011b			DEBUG_KEY_MATRIX: equ 0  
011b			DEBUG_STORECF: equ 0  
011b			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011b			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011b			DEBUG_SPI: equ 0    ; low level spi tests  
011b			  
011b			; Enable many break points  
011b			  
011b			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011b			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011b			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011b			DEBUG_FORTH_JP: equ 0    ; 4  
011b			DEBUG_FORTH_MALLOC: equ 0  
011b			DEBUG_FORTH_MALLOC_INT: equ 0  
011b			DEBUG_FORTH_DOT: equ 1  
011b			DEBUG_FORTH_DOT_WAIT: equ 0  
011b			DEBUG_FORTH_MATHS: equ 0  
011b			DEBUG_FORTH_TOK: equ 0    ; 4  
011b			DEBUG_FORTH_PARSE: equ 0    ; 3  
011b			DEBUG_FORTH: equ 0  ;2  
011b			DEBUG_FORTH_WORDS: equ 1   ; 1  
011b			DEBUG_FORTH_PUSH: equ 1   ; 1  
011b			DEBUG_FORTH_UWORD: equ 1   ; 1  
011b			  
011b			; Enable key point breakpoints  
011b			  
011b			DEBUG_FORTH_DOT_KEY: equ 0  
011b			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011b			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011b			  
011b			; Debug stack imbalances  
011b			  
011b			ON: equ 1  
011b			OFF: equ 0  
011b			  
011b			DEBUG_STACK_IMB: equ 0  
011b			STACK_IMB_STORE: equ 20  
011b			  
011b			; House keeping and protections  
011b			  
011b			DEBUG_FORTH_STACK_GUARD: equ 1  
011b			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011b			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011b			FORTH_ENABLE_FREE: equ 0  
011b			FORTH_ENABLE_MALLOCFREE: equ 1  
011b			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011b			FORTH_ENABLE_FLOATMATH: equ 0  
011b			  
011b			  
011b			CALLMONITOR: macro  
011b			;	call break_point_state  
011b			; now use the break point debug vector  
011b				call debug_vector  
011b				endm  
011b			  
011b			MALLOC_1: equ 1        ; from dk88   
011b			MALLOC_2: equ 0           ; broke  
011b			MALLOC_3: equ 0           ; really broke  
011b			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011b			  
011b			if BASE_KEV   
011b			;stacksize: equ 256  
011b			; each stack entry is three bytes (type + word)  
011b			stacksize: equ 3*150  
011b			  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 512  
011b			endif  
011b			if BASE_SC114  
011b			;tos:	equ 0f000h  
011b			stacksize: equ 256  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 256  
011b			endif  
011b			  
011b			if BASE_CPM  
011b			;tos:	equ 0f000h  
011b			stacksize: equ 256  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 256  
011b			endif  
011b			  
011b			;if STORAGE_SE == 0  
011b			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011b			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011b			;endif  
011b			  
011b			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011b			  
011b			STORE_0_AUTORUN: equ $20  
011b			  
011b			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011b			  
011b			STORE_0_AUTOFILE: equ $21  
011b			STORE_0_BANKRUN: equ $23  
011b			STORE_0_FILERUN: equ $24  
011b			  
011b			; Block 0 offsets for settings  
011b			  
011b			; if set then skip prompt for start up and accept all  
011b			  
011b			STORE_0_QUICKSTART: equ $25  
011b			  
011b			; Blocks where directory table is held  
011b			  
011b			; Reducing the number of entries increases the max file size  
011b			  
011b			;STORE_DIR_START: equ 1  
011b			;STORE_DIR_END: equ 33  
011b			  
011b			; Blocks from where file data is stored  
011b			  
011b			;STORE_DATA_START: equ STORE_DIR_END + 1  
011b			  
011b			; Block indicators (<32 are data files)  
011b			  
011b			;STORE_BLOCK_CFG: equ $8f       ; config block  
011b			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011b			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011b			;STORE_BLOCK_FREE: equ $85       ; data block free  
011b			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011b			  
011b			  
011b			  
011b			; Directory entry flags  
011b			  
011b			;STORE_DIR_FREE: equ 0  
011b			;STORE_DIR_FILE:  equ 1  
011b			  
011b			; Structure offsets to directory entries  
011b			;STORE_DE_FLAG: equ 0  
011b			;STORE_DE_MAXEXT: equ 1  
011b			;STORE_DE_FILENAME: equ 2  
011b			  
011b			; Structure offsets to block 0  
011b			  
011b			;STORE_BK0_ISFOR: equ 1  
011b			;STORE_BK0_LABEL: equ 3  
011b			  
011b			; memory allocation   
011b			  
011b			chk_stund: equ tos+2           ; underflow check word  
011b			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011b			  
011b			; keyscan table needs rows x cols buffer  
011b			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011b			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011b			  
011b			keyscan_table_row1: equ chk_stovr -key_cols-1  
011b			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011b			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011b			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011b			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011b			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011b			keyscan_scancol: equ keyscan_table-key_cols  
011b			;keyscan_table_len: equ key_rows*key_cols  
011b			;keybufptr: equ keyscan_table - 2  
011b			;keysymbol: equ keybufptr - 1  
011b			key_held: equ keyscan_scancol-1	; currently held  
011b			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011b			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011b			key_fa: equ key_repeat_ct -1 ;  
011b			key_fb: equ key_fa -1 ;  
011b			key_fc: equ key_fb -1 ;  
011b			key_fd: equ key_fc -1 ;  
011b			key_face_held: equ key_fd - 1   
011b			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011b			  
011b			hardware_config: equ key_face_held - 10  
011b			  
011b			; hardware config switches  
011b			; TODO add bitmasks on includes for hardware  
011b			; high byte for expansion ids  
011b			;     0000 0000  no card inserted  
011b			;     0000 0001  storage card inserted  
011b			;     0000 0010  spi sd card active  
011b			  
011b			;       
011b			; low byte:  
011b			;     0000 0001   4x4 keypad  
011b			;     0000 0010   full keyboard  
011b			;     0000 0011   spi/ext keyboard  
011b			;     0000 0100   20x4 lcd  
011b			;     0000 1000   40x4 lcd  
011b			;     0000 1100   spi/ext display  
011b			;     0001 0000   ide interface available  
011b			  
011b			hardware_word: equ hardware_config - 2  
011b			  
011b			; debug marker - optional display of debug point on the debug screens  
011b			  
011b			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011b			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011b			  
011b			debug_mark: equ debug_vector - 4  
011b			  
011b			; input_str vars  
011b			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011b			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011b			input_size: equ input_start -1  ; number of chars  
011b			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011b			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011b			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011b			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011b			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011b			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011b			input_len: equ input_cur_onoff - 5 ; length of current input  
011b			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011b			  
011b			CUR_BLINK_RATE: equ 15  
011b			  
011b			key_actual_pressed: equ input_cursor - 1   
011b			key_symbol: equ key_actual_pressed - 1   
011b			key_shift: equ key_symbol - 1   
011b			  
011b			; Display allocation  
011b			  
011b			;display_rows: equ 4     ; move out to mini and mega files  
011b			;display_cols: equ 20  
011b			  
011b			display_fb_len: equ display_rows*display_cols  
011b			  
011b			; primary frame buffer     
011b			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011b			; working frame buffers  
011b			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011b			display_fb3: equ  display_fb1-display_fb_len - 1  
011b			display_fb2: equ  display_fb3-display_fb_len - 1  
011b			;  
011b			; pointer to active frame buffer  
011b			display_fb_active: equ display_fb2 - 2  
011b			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011b			display_write_tmp: equ display_lcde1e2 - 2  
011b			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011b			  
011b			;  
011b			  
011b			;; can load into de directory  
011b			cursor_col: equ display_active-1  
011b			cursor_row: equ cursor_col-1  
011b			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011b			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011b			  
011b			; maths vars  
011b			  
011b			LFSRSeed: equ cursor_shape -20   
011b			randData: equ LFSRSeed - 2  
011b			xrandc: equ randData - 2  
011b			stackstore: equ xrandc - 2  
011b			seed1: equ  stackstore -2   
011b			seed2: equ seed1 - 2  
011b			  
011b			; cf storage vars  
011b			  
011b			iErrorNum:  equ seed2-1         ;Error number  
011b			iErrorReg:  equ iErrorNum -1              ;Error register  
011b			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011b			  
011b			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011b			  
011b			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011b			  
011b			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011b			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011b			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011b			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011b			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011b			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011b			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011b			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011b			store_tmpid: equ store_tmp3 - 1		; page temp id  
011b			store_tmpext: equ store_tmpid - 1		; file extent temp  
011b			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011b			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011b			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011b			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011b			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011b			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011b			;  
011b			; spi vars  
011b			  
011b			  
011b			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011b			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011b			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011b			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011b			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011b			spi_device_id: equ spi_device - 1    ; human readable bank number  
011b			  
011b			;;;;; forth cli params  
011b			  
011b			; TODO use a different frame buffer for forth???  
011b			  
011b			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011b			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011b			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011b			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011b			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011b			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011b			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011b			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011b			  
011b			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011b			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011b			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011b			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011b			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011b			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011b			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011b			  
011b			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011b			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011b			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011b			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011b			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011b			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011b			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011b			  
011b			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011b			  
011b			; os/forth token vars  
011b			  
011b			os_last_cmd: equ os_var_array-255  
011b			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011b			os_current_i: equ os_cli_cmd-2  
011b			os_cur_ptr: equ os_current_i-2  
011b			os_word_scratch: equ os_cur_ptr-30  
011b			os_tok_len: equ os_word_scratch - 2  
011b			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011b			os_tok_malloc: equ os_tok_ptr - 2  
011b			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011b			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011b			execscratch: equ os_input-255        ; exec cmd eval buffer  
011b			scratch: equ execscratch-255  
011b			  
011b			os_stack_1: equ scratch - 3       ; stack holding area 1  
011b			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
011b			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
011b			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
011b			  
011b			  
011b			; temp locations for new word processing to save on adding more   
011b			  
011b			os_new_malloc: equ os_stack_4-2  
011b			os_new_parse_len: equ os_new_malloc - 2  
011b			os_new_word_len: equ os_new_parse_len - 2  
011b			os_new_work_ptr: equ os_new_word_len - 2  
011b			os_new_src_ptr: equ os_new_work_ptr - 2  
011b			os_new_exec: equ os_new_src_ptr - 2  
011b			os_new_exec_ptr: equ os_new_exec - 2  
011b			  
011b			; resume memory alloocations....  
011b			  
011b			;os_view_disable: equ os_new_exec_ptr - 1  
011b			os_view_af: equ os_new_exec_ptr - 2  
011b			os_view_hl: equ os_view_af -2  
011b			os_view_de: equ os_view_hl - 2  
011b			os_view_bc: equ os_view_de - 2  
011b			  
011b			; stack checksum word  
011b			if DEBUG_STACK_IMB  
011b				curframe: equ  os_view_de - 5  
011b				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011b				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011b			else  
011b				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011b			endif  
011b			  
011b			; with data stack could see memory filled with junk. need some memory management   
011b			; malloc and free entry points added  
011b			  
011b			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011b			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011b			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			;heap_end: equ free_list-1  ; Starting address of heap  
011b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			  
011b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			heap_end: equ chk_word-1  ; Starting address of heap  
011b			  
011b			  
011b			;if BASE_KEV   
011b			;heap_start: equ 0800eh  ; Starting address of heap  
011b			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011b			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011b			;endif  
011b			  
011b			;if BASE_SC114  
011b			;heap_start: equ baseram+15  ; Starting address of heap  
011b			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011b			;endif  
011b			  
011b			  
011b			;;;;  
011b			  
011b			  
011b			; change below to point to last memory alloc above  
011b			topusermem:  equ   heap_start  
011b			  
011b			;if BASE_KEV   
011b			;baseusermem: equ 08000h  
011b			;endif  
011b			  
011b			;if BASE_SC114  
011b			;;aseusermem:     equ    12  
011b			;baseusermem:     equ    prompt  
011b			;;baseusermem:     equ    endofcode  
011b			;endif  
011b			  
011b			  
011b			; **********************************************************************  
011b			; **  Constants  
011b			; **********************************************************************  
011b			  
011b			; Constants used by this code module  
011b			kDataReg:   EQU Device_D           ;PIO port A data register  
011b			kContReg:   EQU Device_D+2           ;PIO port A control register  
011b			  
011b			  
011b			portbdata:  equ Device_D+1    ; port b data  
011b			portbctl:   equ Device_D+3    ; port b control  
011b			  
011b			  
011b			;KEY_SHIFT:   equ 5  
011b			;KEY_SYMBOLSHIFT:  equ 6  
011b			  
011b			KEY_SHIFTLOCK: equ 4  
011b			  
011b			  
011b			KEY_UP: equ 5  
011b			KEY_NEXTWORD: equ 6  
011b			KEY_PREVWORD: equ 7  
011b			KEY_BS: equ 8  
011b			KEY_TAB:  equ 9  
011b			KEY_DOWN: equ 10  
011b			KEY_LEFT: equ 11  
011b			KEY_RIGHT: equ 12  
011b			KEY_CR:   equ 13  
011b			KEY_HOME: equ 14  
011b			KEY_END: equ 15  
011b			  
011b			KEY_F1: equ 16  
011b			KEY_F2: equ 17  
011b			KEY_F3: equ 18  
011b			KEY_F4: equ 19  
011b			  
011b			KEY_F5: equ 20  
011b			KEY_F6: equ 21  
011b			KEY_F7: equ 22  
011b			KEY_F8: equ 23  
011b			  
011b			KEY_F9: equ 24  
011b			KEY_F10: equ 25  
011b			KEY_F11: equ 26  
011b			KEY_F12: equ 27  
011b			  
011b			;if DEBUG_KEY  
011b			;	KEY_MATRIX_NO_PRESS: equ '.'  
011b			;	KEY_SHIFT:   equ '.'  
011b			;	KEY_SYMBOLSHIFT:  equ '.'  
011b			;else  
011b				KEY_SHIFT:   equ '~'  
011b				KEY_SYMBOLSHIFT:  equ '~'  
011b				KEY_MATRIX_NO_PRESS: equ '~'  
011b			;endi  
011b			  
011b			  
011b			  
011b			  
011b			; Macro to make adding debug marks easier  
011b			  
011b			DMARK: macro str  
011b				push af  
011b				ld a, (.dmark)  
011b				ld (debug_mark),a  
011b				ld a, (.dmark+1)  
011b				ld (debug_mark+1),a  
011b				ld a, (.dmark+2)  
011b				ld (debug_mark+2),a  
011b				jr .pastdmark  
011b			.dmark: db str  
011b			.pastdmark: pop af  
011b			  
011b			endm  
011b			  
011b			  
011b			; macro to detect for stack imbalances  
011b			  
011b			include "stackimbal.asm"  
011b			; Macro and code to detect stock imbalances 
011b			 
011b			SPPUSH: equ 0 
011b			 
011b			; Add a stack frame which can be checked before return 
011b			 
011b			STACKFRAME: macro onoff frame1 frame2 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						; save current SP 
011b						exx 
011b			 
011b						ld de, frame1 
011b						ld a, d 
011b						ld hl, curframe 
011b						call hexout 
011b						ld a, e 
011b						ld hl, curframe+2 
011b						call hexout 
011b			  
011b						ld hl, frame1 
011b						push hl 
011b						ld hl, frame2 
011b						push hl 
011b						exx 
011b					endif 
011b					 
011b				endif 
011b			endm 
011b			 
011b			STACKFRAMECHK: macro onoff frame1 frame2 
011b			 
011b					 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						exx 
011b						; check stack frame SP 
011b			 
011b						ld hl, frame2 
011b						pop de   ; frame2 
011b			 
011b						call cmp16 
011b						jr nz, .spnosame 
011b						 
011b			 
011b						ld hl, frame1 
011b						pop de   ; frame1 
011b			 
011b						call cmp16 
011b						jr z, .spfrsame 
011b			 
011b						.spnosame: call showsperror 
011b			 
011b						.spfrsame: nop 
011b			 
011b						exx 
011b					endif 
011b					 
011b				endif 
011b			 
011b			 
011b			endm 
011b			 
011b			 
011b			; for a sub routine, wrap SP collection and comparisons 
011b			 
011b			; Usage: 
011b			; 
011b			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011b			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011b			 
011b			SAVESP: macro onoff storeword 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						; save current SP 
011b			 
011b						ld (store_sp+(storeword*4)), sp 
011b			 
011b					endif 
011b					 
011b				endif 
011b			 
011b			endm 
011b			 
011b			CHECKSP: macro onoff storeword 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b			 
011b						; save SP after last save 
011b				 
011b						ld (store_sp+(storeword*4)+2), sp 
011b			 
011b						push hl 
011b						ld hl, store_sp+(storeword*4) 
011b						call check_stack_sp  
011b						pop hl 
011b			 
011b			 
011b					endif 
011b					 
011b				endif 
011b			 
011b			endm 
011b			 
011b			if DEBUG_STACK_IMB 
011b			 
011b			check_stack_sp: 
011b					push de 
011b			 
011b					ld e, (hl) 
011b					inc hl 
011b					ld d, (hl) 
011b					inc hl 
011b			 
011b					push de 
011b			 
011b			 
011b					ld e, (hl) 
011b					inc hl 
011b					ld d, (hl) 
011b					inc hl 
011b			 
011b					pop hl 
011b			 
011b			 
011b					; check to see if the same 
011b			 
011b					call cmp16 
011b					jr z, .spsame 
011b			 
011b					; not same 
011b			 
011b					call showsperror 
011b			.spsame: 
011b			 
011b					pop de 
011b			 
011b					ret 
011b			 
011b			.sperr:  db "Stack imbalance",0 
011b			 
011b			 
011b			showsperror: 
011b			 
011b			 
011b				push hl 
011b				push af 
011b				push de 
011b				call clear_display 
011b				ld de, .sperr 
011b				ld a,0 
011b			;	ld de,os_word_scratch 
011b				call str_at_display 
011b				ld a, display_row_1+17 
011b				ld de, debug_mark 
011b				call str_at_display 
011b				ld a, 0 
011b				ld (curframe+4),a 
011b				ld hl, curframe 
011b				ld de, os_word_scratch 
011b				ld a, display_row_4 
011b				call str_at_display 
011b				call update_display 
011b				;call break_point_state 
011b				call cin_wait 
011b			 
011b			;	ld a, ' ' 
011b			;	ld (os_view_disable), a 
011b				call bp_on 
011b				pop de	 
011b				pop af 
011b				pop hl 
011b				CALLMONITOR 
011b				ret 
011b			 
011b			endif 
011b			 
011b			 
011b			 
011b			; eof 
# End of file stackimbal.asm
011b			  
011b			;TODO macro to calc col and row offset into screen  
011b			  
011b			  
011b			  
011b			hardware_init:  
011b			  
011b				  
011b			  
011b					;ld a, 0  
011b					;ld (hardware_diag), a  
011b			  
011b					; clear all the buffers  
011b			  
011b 21 10 ed				ld hl, display_fb1  
011e 22 cc eb				ld (display_fb_active), hl  
0121			  
0121 cd b9 0b				call clear_display  
0124			  
0124 21 ce eb				ld hl, display_fb2  
0127 22 cc eb				ld (display_fb_active), hl  
012a			  
012a cd b9 0b				call clear_display  
012d			  
012d					; init primary frame buffer area  
012d 21 b1 ed				ld hl, display_fb0  
0130 22 cc eb				ld (display_fb_active), hl  
0133			  
0133 cd b9 0b				call clear_display  
0136			  
0136			  
0136 cd 37 65				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0139			  
0139 cd 25 66			call key_init  
013c cd 9e 01			call storage_init  
013f			  
013f				; setup malloc functions  
013f			  
013f				if MALLOC_1  
013f cd 95 12				call  heap_init  
0142				endif  
0142				if MALLOC_4  
0142					call  heap_init  
0142				endif  
0142			  
0142				; init sound hardware if present  
0142			  
0142				if SOUND_ENABLE  
0142					call sound_init  
0142				endif  
0142			  
0142				; lcd test sequence  
0142					  
0142 cd dc 0b			call update_display  
0145 cd f1 0a			call delay1s  
0148 3e 2b			ld a,'+'  
014a cd be 0b			call fill_display  
014d cd dc 0b			call update_display  
0150 cd f1 0a			call delay1s  
0153 3e 2a			ld a,'*'  
0155 cd be 0b			call fill_display  
0158 cd dc 0b			call update_display  
015b cd f1 0a			call delay1s  
015e 3e 2d			ld a,'-'  
0160 cd be 0b			call fill_display  
0163 cd dc 0b			call update_display  
0166 cd f1 0a			call delay1s  
0169			  
0169			; boot splash screen  
0169			if display_cols == 20	  
0169			        ld a, display_row_1    
0169			else  
0169 3e 0a		        ld a, display_row_1 +10   
016b			endif  
016b 11 c3 17			ld de, prom_bootmsg  
016e cd cc 0b			call str_at_display  
0171 cd dc 0b			call update_display  
0174			  
0174			  
0174 cd f1 0a			call delay1s  
0177 cd f1 0a			call delay1s  
017a			if display_cols == 20	  
017a			            LD   A, display_row_3+2  
017a			else  
017a 3e 5c		            LD   A, display_row_3+12  
017c			endif  
017c 11 d8 17			ld de, prom_bootmsg1  
017f cd cc 0b			call str_at_display  
0182 cd dc 0b			call update_display  
0185 cd f1 0a			call delay1s  
0188 cd f1 0a			call delay1s  
018b			  
018b			;	ld a, display_row_4+3  
018b			;	ld de, bootmsg2  
018b			;	call str_at_display  
018b			;	call update_display  
018b			;	call delay1s  
018b			;	call delay1s  
018b			  
018b			; debug mark setup  
018b			  
018b 3e 5f		ld a, '_'  
018d 32 6b ee		ld (debug_mark),a  
0190 32 6c ee		ld (debug_mark+1),a  
0193 32 6d ee		ld (debug_mark+2),a  
0196 3e 00		ld a,0  
0198 32 6e ee		ld (debug_mark+3),a  
019b			  
019b c9					ret  
019c			  
019c			  
019c			;bootmsg2:	db "Firmware v0.1",0  
019c			  
019c			; a 4x20 lcd  
019c			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019c			  
019c			;if display_cols == 20  
019c			;	include "firmware_lcd_4x20.asm"  
019c			;endif  
019c			  
019c			;if display_cols == 40  
019c			;	include "firmware_lcd_4x40.asm"  
019c			;endif  
019c			  
019c			;  
019c			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019c			; TODO abstract the bit bang video out interface for dual display  
019c			; TODO wire video out to tx pin on rc2014 bus  
019c			  
019c			; must supply cin, and cin_wait for low level hardware abstraction   
019c			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019c			; test scancode  
019c			  
019c			;;;;;  
019c			;;;  
019c			; Moved out to mini and maxi versions  
019c			;  
019c			; include "firmware_key_4x4.asm"  
019c			; using existing 4 wire x 4 resistor array for input  
019c			;include "firmware_key_4x10.asm"  
019c			; need to mod the board for 5 rows due to resistor array  
019c			;include "firmware_key_5x10.asm"  
019c			  
019c			; storage hardware interface  
019c			  
019c			; use microchip serial eeprom for storage  
019c			  
019c			  
019c			if STORAGE_SE  
019c				include "firmware_spi.asm"  
019c				include "firmware_seeprom.asm"  
019c			else  
019c			   ; create some stubs for the labels  
019c c9			se_readbyte: ret  
019d c9			se_writebyte: ret  
019e c9			storage_init: ret  
019f			  
019f			endif  
019f			  
019f			; use cf card for storage - throwing timeout errors. Hardware or software?????  
019f			;include "firmware_cf.asm"  
019f			  
019f			; load up high level storage hardward abstractions  
019f			include "firmware_storage.asm"  
019f			 
019f			; persisent storage hardware abstraction layer  
019f			 
019f			 
019f			 
019f			; Block 0 on storage is a config state 
019f			 
019f			 
019f			 
019f			; TODO add read phy block and write phy block functions 
019f			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
019f			 
019f			; Abstraction layer  
019f			 
019f			; Logocial block size is same size as physical size - using tape concept 
019f			 
019f			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
019f			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
019f			 
019f			 
019f			 
019f			; Filesystem layout (Logical layout) 
019f			; 
019f			; Block 0 - Bank config  
019f			; 
019f			;      Byte - 0 file id counter 
019f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
019f			;      Byte - 3-20 zero terminated bank label 
019f			; 
019f			; Block 1 > File storage 
019f			; 
019f			;      Byte 0 file id    - block 0 file details 
019f			;      Byte 1 block id - block 0 is file  
019f			;            Byte 2-15 - File name 
019f			; 
019f			;       - to end of block data 
019f			; 
019f			 
019f			; Get ID for the file named in pointer held HL 
019f			; Returns ID in HL = 255 if no file found 
019f			 
019f			storage_getid: 
019f			 
019f 22 73 ea			ld (store_tmp1), hl 
01a2			 
01a2				if DEBUG_STORESE 
01a2					DMARK "SGI" 
01a2 f5				push af  
01a3 3a b7 01			ld a, (.dmark)  
01a6 32 6b ee			ld (debug_mark),a  
01a9 3a b8 01			ld a, (.dmark+1)  
01ac 32 6c ee			ld (debug_mark+1),a  
01af 3a b9 01			ld a, (.dmark+2)  
01b2 32 6d ee			ld (debug_mark+2),a  
01b5 18 03			jr .pastdmark  
01b7 ..			.dmark: db "SGI"  
01ba f1			.pastdmark: pop af  
01bb			endm  
# End of macro DMARK
01bb					CALLMONITOR 
01bb cd 6f ee			call debug_vector  
01be				endm  
# End of macro CALLMONITOR
01be				endif 
01be				; get block 0 and set counter for number of files to scan 
01be			 
01be cd 29 03			call storage_get_block_0 
01c1			 
01c1 3a 7a ea			ld a, (store_page) 
01c4 47				ld b, a 
01c5			 
01c5				; get extent 0 of each file id 
01c5			 
01c5				if DEBUG_STORESE 
01c5					DMARK "SGc" 
01c5 f5				push af  
01c6 3a da 01			ld a, (.dmark)  
01c9 32 6b ee			ld (debug_mark),a  
01cc 3a db 01			ld a, (.dmark+1)  
01cf 32 6c ee			ld (debug_mark+1),a  
01d2 3a dc 01			ld a, (.dmark+2)  
01d5 32 6d ee			ld (debug_mark+2),a  
01d8 18 03			jr .pastdmark  
01da ..			.dmark: db "SGc"  
01dd f1			.pastdmark: pop af  
01de			endm  
# End of macro DMARK
01de					CALLMONITOR 
01de cd 6f ee			call debug_vector  
01e1				endm  
# End of macro CALLMONITOR
01e1				endif 
01e1 60			.getloop:	ld h, b 
01e2 2e 00				ld l, 0 
01e4 c5					push bc 
01e5			 
01e5 11 7a ea				ld de, store_page 
01e8				if DEBUG_STORESE 
01e8					DMARK "SGr" 
01e8 f5				push af  
01e9 3a fd 01			ld a, (.dmark)  
01ec 32 6b ee			ld (debug_mark),a  
01ef 3a fe 01			ld a, (.dmark+1)  
01f2 32 6c ee			ld (debug_mark+1),a  
01f5 3a ff 01			ld a, (.dmark+2)  
01f8 32 6d ee			ld (debug_mark+2),a  
01fb 18 03			jr .pastdmark  
01fd ..			.dmark: db "SGr"  
0200 f1			.pastdmark: pop af  
0201			endm  
# End of macro DMARK
0201					CALLMONITOR 
0201 cd 6f ee			call debug_vector  
0204				endm  
# End of macro CALLMONITOR
0204				endif 
0204 cd d1 07				call storage_read 
0207 cd 0f 0e				call ishlzero 
020a 28 2d				jr z, .gap 
020c					 
020c					; have a file name read. Is it one we want. 
020c			 
020c 2a 73 ea				ld hl, (store_tmp1) 
020f 11 7d ea				ld de, store_page+3   ; file name 
0212			 
0212				if DEBUG_STORESE 
0212					DMARK "SGc" 
0212 f5				push af  
0213 3a 27 02			ld a, (.dmark)  
0216 32 6b ee			ld (debug_mark),a  
0219 3a 28 02			ld a, (.dmark+1)  
021c 32 6c ee			ld (debug_mark+1),a  
021f 3a 29 02			ld a, (.dmark+2)  
0222 32 6d ee			ld (debug_mark+2),a  
0225 18 03			jr .pastdmark  
0227 ..			.dmark: db "SGc"  
022a f1			.pastdmark: pop af  
022b			endm  
# End of macro DMARK
022b					CALLMONITOR 
022b cd 6f ee			call debug_vector  
022e				endm  
# End of macro CALLMONITOR
022e				endif 
022e cd 7c 12				call strcmp 
0231 20 06				jr nz, .gap   ; not this one 
0233			 
0233 c1				        pop bc 
0234			 
0234 26 00				ld h, 0 
0236 68					ld l, b 
0237 18 22				jr .getdone 
0239						 
0239			 
0239			 
0239			 
0239			.gap: 
0239				if DEBUG_STORESE 
0239					DMARK "SGg" 
0239 f5				push af  
023a 3a 4e 02			ld a, (.dmark)  
023d 32 6b ee			ld (debug_mark),a  
0240 3a 4f 02			ld a, (.dmark+1)  
0243 32 6c ee			ld (debug_mark+1),a  
0246 3a 50 02			ld a, (.dmark+2)  
0249 32 6d ee			ld (debug_mark+2),a  
024c 18 03			jr .pastdmark  
024e ..			.dmark: db "SGg"  
0251 f1			.pastdmark: pop af  
0252			endm  
# End of macro DMARK
0252					CALLMONITOR 
0252 cd 6f ee			call debug_vector  
0255				endm  
# End of macro CALLMONITOR
0255				endif 
0255			 
0255 c1					pop bc 
0256 10 89				djnz .getloop 
0258 21 ff 00				ld hl, 255 
025b			.getdone: 
025b			 
025b				if DEBUG_STORESE 
025b					DMARK "SGe" 
025b f5				push af  
025c 3a 70 02			ld a, (.dmark)  
025f 32 6b ee			ld (debug_mark),a  
0262 3a 71 02			ld a, (.dmark+1)  
0265 32 6c ee			ld (debug_mark+1),a  
0268 3a 72 02			ld a, (.dmark+2)  
026b 32 6d ee			ld (debug_mark+2),a  
026e 18 03			jr .pastdmark  
0270 ..			.dmark: db "SGe"  
0273 f1			.pastdmark: pop af  
0274			endm  
# End of macro DMARK
0274					CALLMONITOR 
0274 cd 6f ee			call debug_vector  
0277				endm  
# End of macro CALLMONITOR
0277				endif 
0277			 
0277 c9				ret 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			; Read Block 
0278			; ---------- 
0278			; 
0278			; With current bank 
0278			;  
0278			; Get block number to read 
0278			; Load physical blocks starting at start block into buffer 
0278			 
0278			; de points to buffer to use 
0278			; hl holds logical block number  
0278			 
0278			storage_read_block: 
0278			 
0278				; TODO bank selection 
0278			 
0278				; for each of the physical blocks read it into the buffer 
0278 06 40			ld b, STORE_BLOCK_PHY 
027a			 
027a				if DEBUG_STORESE 
027a d5					push de 
027b				endif 
027b				 
027b			.rl1:    
027b			 
027b				; read physical block at hl into de 
027b			        ; increment hl and de to next read position on exit 
027b			 
027b e5				push hl 
027c d5				push de	 
027d c5				push bc 
027e			;	if DEBUG_STORESE 
027e			;		push af 
027e			;		ld a, 'R' 
027e			;		ld (debug_mark),a 
027e			;		pop af 
027e			;		CALLMONITOR 
027e			;	endif 
027e cd 9c 01			call se_readbyte 
0281			;	if DEBUG_STORESE 
0281			;		ld a,(spi_portbyte) 
0281			;		ld l, a 
0281			;		push af 
0281			;		ld a, '1' 
0281			;		ld (debug_mark),a 
0281			;		pop af 
0281			;		CALLMONITOR 
0281			;	endif 
0281 c1				pop bc 
0282 d1				pop de 
0283 e1				pop hl 
0284 12				ld (de),a 
0285 23				inc hl 
0286 13				inc de 
0287			 
0287			;	if DEBUG_STORESE 
0287			;		push af 
0287			;		ld a, 'r' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287			;		CALLMONITOR 
0287			;	endif 
0287			 
0287 10 f2			djnz .rl1 
0289			 
0289				if DEBUG_STORESE 
0289					DMARK "SRB" 
0289 f5				push af  
028a 3a 9e 02			ld a, (.dmark)  
028d 32 6b ee			ld (debug_mark),a  
0290 3a 9f 02			ld a, (.dmark+1)  
0293 32 6c ee			ld (debug_mark+1),a  
0296 3a a0 02			ld a, (.dmark+2)  
0299 32 6d ee			ld (debug_mark+2),a  
029c 18 03			jr .pastdmark  
029e ..			.dmark: db "SRB"  
02a1 f1			.pastdmark: pop af  
02a2			endm  
# End of macro DMARK
02a2 d1					pop de 
02a3			; 
02a3			;		push af 
02a3			;		ld a, 'R' 
02a3			;		ld (debug_mark),a 
02a3			;		pop af 
02a3					CALLMONITOR 
02a3 cd 6f ee			call debug_vector  
02a6				endm  
# End of macro CALLMONITOR
02a6				endif 
02a6 c9				ret	 
02a7				 
02a7			 
02a7			; File Size 
02a7			; --------- 
02a7			; 
02a7			;   hl file id 
02a7			; 
02a7			;  returns in hl the number of blocks 
02a7			 
02a7			storage_file_size: 
02a7 5d				ld e, l 
02a8 16 00			ld d, 0 
02aa 21 40 00			ld hl, STORE_BLOCK_PHY 
02ad					if DEBUG_FORTH_WORDS 
02ad						DMARK "SIZ" 
02ad f5				push af  
02ae 3a c2 02			ld a, (.dmark)  
02b1 32 6b ee			ld (debug_mark),a  
02b4 3a c3 02			ld a, (.dmark+1)  
02b7 32 6c ee			ld (debug_mark+1),a  
02ba 3a c4 02			ld a, (.dmark+2)  
02bd 32 6d ee			ld (debug_mark+2),a  
02c0 18 03			jr .pastdmark  
02c2 ..			.dmark: db "SIZ"  
02c5 f1			.pastdmark: pop af  
02c6			endm  
# End of macro DMARK
02c6						CALLMONITOR 
02c6 cd 6f ee			call debug_vector  
02c9				endm  
# End of macro CALLMONITOR
02c9					endif 
02c9 cd ab 05			call storage_findnextid 
02cc			 
02cc cd 0f 0e			call ishlzero 
02cf			;	ld a, l 
02cf			;	add h 
02cf			;	cp 0 
02cf c8				ret z			; block not found so EOF 
02d0			 
02d0 11 7a ea			ld de, store_page 
02d3 cd 78 02			call storage_read_block 
02d6			 
02d6 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
02d9 6f				ld l, a 
02da 26 00			ld h, 0 
02dc c9			 	ret 
02dd			 
02dd			 
02dd			; Write Block 
02dd			; ----------- 
02dd			; 
02dd			; With current bank 
02dd			;  
02dd			; Get block number to write 
02dd			; Write physical blocks starting at start block from buffer 
02dd			  
02dd			storage_write_block: 
02dd				; TODO bank selection 
02dd			 
02dd				; for each of the physical blocks read it into the buffer 
02dd 06 40			ld b, STORE_BLOCK_PHY 
02df			 
02df				if DEBUG_STORESE 
02df					DMARK "SWB" 
02df f5				push af  
02e0 3a f4 02			ld a, (.dmark)  
02e3 32 6b ee			ld (debug_mark),a  
02e6 3a f5 02			ld a, (.dmark+1)  
02e9 32 6c ee			ld (debug_mark+1),a  
02ec 3a f6 02			ld a, (.dmark+2)  
02ef 32 6d ee			ld (debug_mark+2),a  
02f2 18 03			jr .pastdmark  
02f4 ..			.dmark: db "SWB"  
02f7 f1			.pastdmark: pop af  
02f8			endm  
# End of macro DMARK
02f8			 
02f8					;push af 
02f8					;ld a, 'W' 
02f8					;ld (debug_mark),a 
02f8					;pop af 
02f8					CALLMONITOR 
02f8 cd 6f ee			call debug_vector  
02fb				endm  
# End of macro CALLMONITOR
02fb				endif 
02fb			 
02fb			; might not be working 
02fb			;	call se_writepage 
02fb			 
02fb			;	ret 
02fb			; 
02fb			 
02fb			 
02fb			 
02fb			.wl1:    
02fb			 
02fb				; read physical block at hl into de 
02fb			        ; increment hl and de to next read position on exit 
02fb			 
02fb e5				push hl 
02fc d5				push de	 
02fd c5				push bc 
02fe 1a				ld a,(de) 
02ff				;if DEBUG_STORESE 
02ff			;		push af 
02ff			;		ld a, 'W' 
02ff			;		ld (debug_mark),a 
02ff			;		pop af 
02ff			;		CALLMONITOR 
02ff			;	endif 
02ff cd 9d 01			call se_writebyte 
0302			;	call delay250ms 
0302 00				nop 
0303 00				nop 
0304 00				nop 
0305			;	if DEBUG_STORESE 
0305			;		push af 
0305			;		ld a, 'w' 
0305			;		ld (debug_mark),a 
0305			;		pop af 
0305			;		CALLMONITOR 
0305			;	endif 
0305 c1				pop bc 
0306 d1				pop de 
0307 e1				pop hl 
0308 23				inc hl 
0309 13				inc de 
030a			 
030a			 
030a 10 ef			djnz .wl1 
030c			 
030c				if DEBUG_STORESE 
030c					DMARK "SW2" 
030c f5				push af  
030d 3a 21 03			ld a, (.dmark)  
0310 32 6b ee			ld (debug_mark),a  
0313 3a 22 03			ld a, (.dmark+1)  
0316 32 6c ee			ld (debug_mark+1),a  
0319 3a 23 03			ld a, (.dmark+2)  
031c 32 6d ee			ld (debug_mark+2),a  
031f 18 03			jr .pastdmark  
0321 ..			.dmark: db "SW2"  
0324 f1			.pastdmark: pop af  
0325			endm  
# End of macro DMARK
0325			 
0325					;push af 
0325					;ld a, 'W' 
0325					;ld (debug_mark),a 
0325					;pop af 
0325					CALLMONITOR 
0325 cd 6f ee			call debug_vector  
0328				endm  
# End of macro CALLMONITOR
0328				endif 
0328 c9				ret	 
0329			 
0329			; Init bank 
0329			; --------- 
0329			; 
0329			; With current bank 
0329			; 
0329			; Setup block 0 config 
0329			;     Set 0 file id counter 
0329			;     Set formatted byte pattern 
0329			;     Zero out bank label 
0329			;      
0329			; For every logical block write 0-1 byte as null 
0329			 
0329			storage_get_block_0: 
0329			 
0329				; TODO check presence 
0329			 
0329				; get block 0 config 
0329			 
0329 21 00 00			ld hl, 0 
032c 11 7a ea			ld de, store_page 
032f cd 78 02			call storage_read_block 
0332			 
0332				if DEBUG_STORESE 
0332					DMARK "SB0" 
0332 f5				push af  
0333 3a 47 03			ld a, (.dmark)  
0336 32 6b ee			ld (debug_mark),a  
0339 3a 48 03			ld a, (.dmark+1)  
033c 32 6c ee			ld (debug_mark+1),a  
033f 3a 49 03			ld a, (.dmark+2)  
0342 32 6d ee			ld (debug_mark+2),a  
0345 18 03			jr .pastdmark  
0347 ..			.dmark: db "SB0"  
034a f1			.pastdmark: pop af  
034b			endm  
# End of macro DMARK
034b 11 7a ea				ld de, store_page 
034e			;		push af 
034e			;		ld a, 'i' 
034e			;		ld (debug_mark),a 
034e			;		pop af 
034e					CALLMONITOR 
034e cd 6f ee			call debug_vector  
0351				endm  
# End of macro CALLMONITOR
0351				endif 
0351			 
0351				; is this area formatted? 
0351			 
0351			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0351 2a 7b ea			ld hl, (store_page+1) 
0354 3e 80			ld a,0x80 
0356 bd				cp l 
0357 20 22			jr nz, .ininotformatted 
0359				; do a double check 
0359 3e 27			ld a, 0x27 
035b bc				cp h 
035c 20 1d			jr nz, .ininotformatted 
035e			 
035e				; formatted then 
035e			 
035e				if DEBUG_STORESE 
035e					DMARK "SB1" 
035e f5				push af  
035f 3a 73 03			ld a, (.dmark)  
0362 32 6b ee			ld (debug_mark),a  
0365 3a 74 03			ld a, (.dmark+1)  
0368 32 6c ee			ld (debug_mark+1),a  
036b 3a 75 03			ld a, (.dmark+2)  
036e 32 6d ee			ld (debug_mark+2),a  
0371 18 03			jr .pastdmark  
0373 ..			.dmark: db "SB1"  
0376 f1			.pastdmark: pop af  
0377			endm  
# End of macro DMARK
0377					;push af 
0377					;ld a, 'I' 
0377					;ld (debug_mark),a 
0377					;pop af 
0377					CALLMONITOR 
0377 cd 6f ee			call debug_vector  
037a				endm  
# End of macro CALLMONITOR
037a				endif 
037a c9				ret 
037b			 
037b			.ininotformatted: 
037b				; bank not formatted so poke various bits to make sure 
037b			 
037b				if DEBUG_STORESE 
037b					DMARK "SB2" 
037b f5				push af  
037c 3a 90 03			ld a, (.dmark)  
037f 32 6b ee			ld (debug_mark),a  
0382 3a 91 03			ld a, (.dmark+1)  
0385 32 6c ee			ld (debug_mark+1),a  
0388 3a 92 03			ld a, (.dmark+2)  
038b 32 6d ee			ld (debug_mark+2),a  
038e 18 03			jr .pastdmark  
0390 ..			.dmark: db "SB2"  
0393 f1			.pastdmark: pop af  
0394			endm  
# End of macro DMARK
0394					;push af 
0394					;ld a, 'f' 
0394					;ld (debug_mark),a 
0394					;pop af 
0394					CALLMONITOR 
0394 cd 6f ee			call debug_vector  
0397				endm  
# End of macro CALLMONITOR
0397				endif 
0397			 
0397 cd b4 0a			call storage_clear_page 
039a			 
039a 21 7a ea			ld hl, store_page 
039d 3e 00			ld a, 0 
039f				 
039f 77				ld (hl),a   ; reset file counter 
03a0			 
03a0 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a3 22 7b ea		 	ld (store_page+1), hl	 
03a6			 
03a6				; set default label 
03a6			 
03a6 21 42 04			ld hl, .defaultbanklabl 
03a9 11 7d ea		 	ld de, store_page+3 
03ac 01 0f 00			ld bc, 15 
03af ed b0			ldir 
03b1			 
03b1				; Append the current bank id 
03b1 21 86 ea			ld hl, store_page+3+9 
03b4 3a 5f ea			ld a, (spi_device_id) 
03b7 77				ld (hl), a 
03b8			 
03b8				; save default page 0 
03b8			 
03b8 21 00 00			ld hl, 0 
03bb 11 7a ea			ld de, store_page 
03be				if DEBUG_STORESE 
03be					DMARK "SB3" 
03be f5				push af  
03bf 3a d3 03			ld a, (.dmark)  
03c2 32 6b ee			ld (debug_mark),a  
03c5 3a d4 03			ld a, (.dmark+1)  
03c8 32 6c ee			ld (debug_mark+1),a  
03cb 3a d5 03			ld a, (.dmark+2)  
03ce 32 6d ee			ld (debug_mark+2),a  
03d1 18 03			jr .pastdmark  
03d3 ..			.dmark: db "SB3"  
03d6 f1			.pastdmark: pop af  
03d7			endm  
# End of macro DMARK
03d7			;		push af 
03d7			;		ld a, 'F' 
03d7			;		ld (debug_mark),a 
03d7			;		pop af 
03d7					CALLMONITOR 
03d7 cd 6f ee			call debug_vector  
03da				endm  
# End of macro CALLMONITOR
03da				endif 
03da cd dd 02			call storage_write_block 
03dd				if DEBUG_STORESE 
03dd					DMARK "SB4" 
03dd f5				push af  
03de 3a f2 03			ld a, (.dmark)  
03e1 32 6b ee			ld (debug_mark),a  
03e4 3a f3 03			ld a, (.dmark+1)  
03e7 32 6c ee			ld (debug_mark+1),a  
03ea 3a f4 03			ld a, (.dmark+2)  
03ed 32 6d ee			ld (debug_mark+2),a  
03f0 18 03			jr .pastdmark  
03f2 ..			.dmark: db "SB4"  
03f5 f1			.pastdmark: pop af  
03f6			endm  
# End of macro DMARK
03f6			;		push af 
03f6			;		ld a, '>' 
03f6			;		ld (debug_mark),a 
03f6			;		pop af 
03f6					CALLMONITOR 
03f6 cd 6f ee			call debug_vector  
03f9				endm  
# End of macro CALLMONITOR
03f9				endif 
03f9			 
03f9 00				nop 
03fa 00				nop 
03fb 00				nop 
03fc			 
03fc				; now set 0 in every page to mark as a free block 
03fc			 
03fc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03fe 21 40 00			ld hl, STORE_BLOCK_PHY 
0401			 
0401 3e 00		.setmark1:   	ld a,0 
0403 e5					push hl 
0404 c5					push bc 
0405 cd 9d 01				call se_writebyte 
0408 3e 0a			ld a, 10 
040a cd d6 0a			call aDelayInMS 
040d 23				inc hl 
040e cd 9d 01				call se_writebyte 
0411 3e 0a			ld a, 10 
0413 cd d6 0a			call aDelayInMS 
0416 2b				dec hl 
0417 c1					pop bc 
0418 e1					pop hl 
0419 3e 40				ld a, STORE_BLOCK_PHY 
041b cd e6 0d				call addatohl 
041e 10 e1				djnz .setmark1 
0420			 
0420 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0422 3e 00		.setmark2:   	ld a,0 
0424 e5					push hl 
0425 c5					push bc 
0426 cd 9d 01				call se_writebyte 
0429 3e 0a			ld a, 10 
042b cd d6 0a			call aDelayInMS 
042e 23				inc hl 
042f cd 9d 01				call se_writebyte 
0432 3e 0a			ld a, 10 
0434 cd d6 0a			call aDelayInMS 
0437 2b				dec hl 
0438 c1					pop bc 
0439 e1					pop hl 
043a 3e 40				ld a, STORE_BLOCK_PHY 
043c cd e6 0d				call addatohl 
043f 10 e1				djnz .setmark2 
0441			 
0441					 
0441			 
0441			 
0441 c9				ret 
0442			 
0442			 
0442			 
0442			 
0442 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044d			 
044d			 
044d			 
044d			; Label Bank 
044d			; ---------- 
044d			; 
044d			; With current bank 
044d			; Read block 0 
044d			; Set label 
044d			; Write block 0 
044d			 
044d			; label str pointer in hl 
044d			 
044d			storage_label:     
044d			 
044d				if DEBUG_STORESE 
044d					DMARK "LBL" 
044d f5				push af  
044e 3a 62 04			ld a, (.dmark)  
0451 32 6b ee			ld (debug_mark),a  
0454 3a 63 04			ld a, (.dmark+1)  
0457 32 6c ee			ld (debug_mark+1),a  
045a 3a 64 04			ld a, (.dmark+2)  
045d 32 6d ee			ld (debug_mark+2),a  
0460 18 03			jr .pastdmark  
0462 ..			.dmark: db "LBL"  
0465 f1			.pastdmark: pop af  
0466			endm  
# End of macro DMARK
0466					CALLMONITOR 
0466 cd 6f ee			call debug_vector  
0469				endm  
# End of macro CALLMONITOR
0469				endif 
0469			 
0469 e5				push hl 
046a			 
046a cd 29 03			call storage_get_block_0 
046d			 
046d				; set default label 
046d			 
046d e1				pop hl 
046e			 
046e 11 7d ea		 	ld de, store_page+3 
0471 01 0f 00			ld bc, 15 
0474				if DEBUG_STORESE 
0474					DMARK "LB3" 
0474 f5				push af  
0475 3a 89 04			ld a, (.dmark)  
0478 32 6b ee			ld (debug_mark),a  
047b 3a 8a 04			ld a, (.dmark+1)  
047e 32 6c ee			ld (debug_mark+1),a  
0481 3a 8b 04			ld a, (.dmark+2)  
0484 32 6d ee			ld (debug_mark+2),a  
0487 18 03			jr .pastdmark  
0489 ..			.dmark: db "LB3"  
048c f1			.pastdmark: pop af  
048d			endm  
# End of macro DMARK
048d					CALLMONITOR 
048d cd 6f ee			call debug_vector  
0490				endm  
# End of macro CALLMONITOR
0490				endif 
0490 ed b0			ldir 
0492				; save default page 0 
0492			 
0492 21 00 00			ld hl, 0 
0495 11 7a ea			ld de, store_page 
0498				if DEBUG_STORESE 
0498					DMARK "LBW" 
0498 f5				push af  
0499 3a ad 04			ld a, (.dmark)  
049c 32 6b ee			ld (debug_mark),a  
049f 3a ae 04			ld a, (.dmark+1)  
04a2 32 6c ee			ld (debug_mark+1),a  
04a5 3a af 04			ld a, (.dmark+2)  
04a8 32 6d ee			ld (debug_mark+2),a  
04ab 18 03			jr .pastdmark  
04ad ..			.dmark: db "LBW"  
04b0 f1			.pastdmark: pop af  
04b1			endm  
# End of macro DMARK
04b1					CALLMONITOR 
04b1 cd 6f ee			call debug_vector  
04b4				endm  
# End of macro CALLMONITOR
04b4				endif 
04b4 cd dd 02			call storage_write_block 
04b7			 
04b7 c9				ret 
04b8			 
04b8			 
04b8			 
04b8			; Read Block 0 - Config 
04b8			; --------------------- 
04b8			; 
04b8			; With current bank 
04b8			; Call presence test 
04b8			;    If not present format/init bank  
04b8			; Read block 0  
04b8			;  
04b8			 
04b8			 
04b8			; Dir 
04b8			; --- 
04b8			; 
04b8			; With current bank 
04b8			; Load Block 0 Config 
04b8			; Get max file id number 
04b8			; For each logical block 
04b8			;    Read block read byte 2 
04b8			;      if first block of file 
04b8			;         Display file name 
04b8			;         Display type flags for file 
04b8			;        
04b8			 
04b8			; moving to words as this requires stack control 
04b8			 
04b8			 
04b8			; Delete File 
04b8			; ----------- 
04b8			; 
04b8			; With current bank 
04b8			; 
04b8			; Load Block 0 Config 
04b8			; Get max file id number 
04b8			; For each logical block 
04b8			;    Read block file id 
04b8			;      If first block of file and dont have file id 
04b8			;         if file to delete 
04b8			;         Save file id 
04b8			;         Null file id 
04b8			;         Write this block back 
04b8			;      If file id is one saved 
04b8			;         Null file id 
04b8			;         Write this block back 
04b8			 
04b8			 
04b8			.se_done: 
04b8 e1				pop hl 
04b9 c9				ret 
04ba			 
04ba			storage_erase: 
04ba			 
04ba				; hl contains the file id 
04ba			 
04ba 5d				ld e, l 
04bb 16 00			ld d, 0 
04bd 21 40 00			ld hl, STORE_BLOCK_PHY 
04c0					if DEBUG_FORTH_WORDS 
04c0						DMARK "ERA" 
04c0 f5				push af  
04c1 3a d5 04			ld a, (.dmark)  
04c4 32 6b ee			ld (debug_mark),a  
04c7 3a d6 04			ld a, (.dmark+1)  
04ca 32 6c ee			ld (debug_mark+1),a  
04cd 3a d7 04			ld a, (.dmark+2)  
04d0 32 6d ee			ld (debug_mark+2),a  
04d3 18 03			jr .pastdmark  
04d5 ..			.dmark: db "ERA"  
04d8 f1			.pastdmark: pop af  
04d9			endm  
# End of macro DMARK
04d9						CALLMONITOR 
04d9 cd 6f ee			call debug_vector  
04dc				endm  
# End of macro CALLMONITOR
04dc					endif 
04dc cd ab 05			call storage_findnextid 
04df cd 0f 0e			call ishlzero 
04e2 c8				ret z 
04e3			 
04e3 e5				push hl 
04e4			 
04e4				; TODO check file not found 
04e4			 
04e4 11 7a ea			ld de, store_page 
04e7 cd 78 02			call storage_read_block 
04ea			 
04ea cd 0f 0e			call ishlzero 
04ed ca b8 04			jp z,.se_done 
04f0			 
04f0					if DEBUG_FORTH_WORDS 
04f0						DMARK "ER1" 
04f0 f5				push af  
04f1 3a 05 05			ld a, (.dmark)  
04f4 32 6b ee			ld (debug_mark),a  
04f7 3a 06 05			ld a, (.dmark+1)  
04fa 32 6c ee			ld (debug_mark+1),a  
04fd 3a 07 05			ld a, (.dmark+2)  
0500 32 6d ee			ld (debug_mark+2),a  
0503 18 03			jr .pastdmark  
0505 ..			.dmark: db "ER1"  
0508 f1			.pastdmark: pop af  
0509			endm  
# End of macro DMARK
0509						CALLMONITOR 
0509 cd 6f ee			call debug_vector  
050c				endm  
# End of macro CALLMONITOR
050c					endif 
050c 3a 7a ea			ld a, (store_page)	; get file id 
050f 32 6e ea			ld (store_tmpid), a 
0512			 
0512 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
0515 32 6d ea			ld (store_tmpext), a 
0518			 
0518				; wipe file header 
0518			 
0518 e1				pop hl 
0519 3e 00			ld a, 0 
051b 32 7a ea			ld (store_page), a 
051e 32 7b ea			ld (store_page+1),a 
0521 11 7a ea			ld de, store_page 
0524					if DEBUG_FORTH_WORDS 
0524						DMARK "ER2" 
0524 f5				push af  
0525 3a 39 05			ld a, (.dmark)  
0528 32 6b ee			ld (debug_mark),a  
052b 3a 3a 05			ld a, (.dmark+1)  
052e 32 6c ee			ld (debug_mark+1),a  
0531 3a 3b 05			ld a, (.dmark+2)  
0534 32 6d ee			ld (debug_mark+2),a  
0537 18 03			jr .pastdmark  
0539 ..			.dmark: db "ER2"  
053c f1			.pastdmark: pop af  
053d			endm  
# End of macro DMARK
053d						CALLMONITOR 
053d cd 6f ee			call debug_vector  
0540				endm  
# End of macro CALLMONITOR
0540					endif 
0540 cd dd 02			call storage_write_block 
0543			 
0543			 
0543				; wipe file extents 
0543			 
0543 3a 6d ea			ld a, (store_tmpext) 
0546 47				ld b, a 
0547			 
0547			.eraext:	  
0547 c5				push bc 
0548			 
0548 21 40 00			ld hl, STORE_BLOCK_PHY 
054b 3a 6e ea			ld a,(store_tmpid) 
054e 5f				ld e, a 
054f 50				ld d, b	 
0550					if DEBUG_FORTH_WORDS 
0550						DMARK "ER3" 
0550 f5				push af  
0551 3a 65 05			ld a, (.dmark)  
0554 32 6b ee			ld (debug_mark),a  
0557 3a 66 05			ld a, (.dmark+1)  
055a 32 6c ee			ld (debug_mark+1),a  
055d 3a 67 05			ld a, (.dmark+2)  
0560 32 6d ee			ld (debug_mark+2),a  
0563 18 03			jr .pastdmark  
0565 ..			.dmark: db "ER3"  
0568 f1			.pastdmark: pop af  
0569			endm  
# End of macro DMARK
0569						CALLMONITOR 
0569 cd 6f ee			call debug_vector  
056c				endm  
# End of macro CALLMONITOR
056c					endif 
056c cd ab 05			call storage_findnextid 
056f cd 0f 0e			call ishlzero 
0572 ca b8 04			jp z,.se_done 
0575			 
0575 e5				push hl 
0576 11 7a ea			ld de, store_page 
0579 cd 78 02			call storage_read_block 
057c			 
057c				; free block	 
057c			 
057c 3e 00			ld a, 0 
057e 32 7a ea			ld (store_page), a 
0581 32 7b ea			ld (store_page+1),a 
0584 11 7a ea			ld de, store_page 
0587 e1				pop hl 
0588					if DEBUG_FORTH_WORDS 
0588						DMARK "ER4" 
0588 f5				push af  
0589 3a 9d 05			ld a, (.dmark)  
058c 32 6b ee			ld (debug_mark),a  
058f 3a 9e 05			ld a, (.dmark+1)  
0592 32 6c ee			ld (debug_mark+1),a  
0595 3a 9f 05			ld a, (.dmark+2)  
0598 32 6d ee			ld (debug_mark+2),a  
059b 18 03			jr .pastdmark  
059d ..			.dmark: db "ER4"  
05a0 f1			.pastdmark: pop af  
05a1			endm  
# End of macro DMARK
05a1						CALLMONITOR 
05a1 cd 6f ee			call debug_vector  
05a4				endm  
# End of macro CALLMONITOR
05a4					endif 
05a4 cd dd 02			call storage_write_block 
05a7			 
05a7 c1				pop bc 
05a8 10 9d			djnz .eraext 
05aa			 
05aa c9				ret 
05ab			 
05ab			 
05ab			; Find Free Block 
05ab			; --------------- 
05ab			; 
05ab			; With current bank 
05ab			;  
05ab			; From given starting logical block 
05ab			;    Read block  
05ab			;    If no file id 
05ab			;         Return block id 
05ab			 
05ab			 
05ab			; hl starting page number 
05ab			; hl contains free page number or zero if no pages free 
05ab			; e contains the file id to locate 
05ab			; d contains the block number 
05ab			 
05ab			; TODO change to find file id and use zero for free block 
05ab			 
05ab			storage_findnextid: 
05ab			 
05ab				; now locate first 0 page to mark as a free block 
05ab			 
05ab 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ad			;	ld hl, STORE_BLOCK_PHY 
05ad			 
05ad					if DEBUG_FORTH_WORDS 
05ad					DMARK "FNI" 
05ad f5				push af  
05ae 3a c2 05			ld a, (.dmark)  
05b1 32 6b ee			ld (debug_mark),a  
05b4 3a c3 05			ld a, (.dmark+1)  
05b7 32 6c ee			ld (debug_mark+1),a  
05ba 3a c4 05			ld a, (.dmark+2)  
05bd 32 6d ee			ld (debug_mark+2),a  
05c0 18 03			jr .pastdmark  
05c2 ..			.dmark: db "FNI"  
05c5 f1			.pastdmark: pop af  
05c6			endm  
# End of macro DMARK
05c6						CALLMONITOR 
05c6 cd 6f ee			call debug_vector  
05c9				endm  
# End of macro CALLMONITOR
05c9					endif 
05c9			.ff1:   	 
05c9 e5					push hl 
05ca c5					push bc 
05cb d5					push de 
05cc cd 9c 01				call se_readbyte 
05cf 5f					ld e,a 
05d0 23					inc hl 
05d1 cd 9c 01				call se_readbyte 
05d4 57					ld d, a 
05d5 e1					pop hl 
05d6 e5					push hl 
05d7 cd 04 0e				call cmp16 
05da 28 49				jr z, .fffound 
05dc			 
05dc d1					pop de 
05dd c1					pop bc 
05de e1					pop hl 
05df			 
05df					; is found? 
05df					;cp e 
05df					;ret z 
05df			 
05df 3e 40				ld a, STORE_BLOCK_PHY 
05e1 cd e6 0d				call addatohl 
05e4 10 e3				djnz .ff1 
05e6			 
05e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e8			.ff2:   	 
05e8			 
05e8 e5					push hl 
05e9 c5					push bc 
05ea d5					push de 
05eb cd 9c 01				call se_readbyte 
05ee 5f					ld e,a 
05ef 23					inc hl 
05f0 cd 9c 01				call se_readbyte 
05f3 57					ld d, a 
05f4			 
05f4 e1					pop hl 
05f5 e5					push hl 
05f6 cd 04 0e				call cmp16 
05f9 28 2a				jr z, .fffound 
05fb			 
05fb d1					pop de 
05fc c1					pop bc 
05fd e1					pop hl 
05fe					; is found? 
05fe					;cp e 
05fe					;ret z 
05fe			 
05fe 3e 40				ld a, STORE_BLOCK_PHY 
0600 cd e6 0d				call addatohl 
0603 10 e3				djnz .ff2 
0605			 
0605			 
0605					if DEBUG_FORTH_WORDS 
0605					DMARK "FN-" 
0605 f5				push af  
0606 3a 1a 06			ld a, (.dmark)  
0609 32 6b ee			ld (debug_mark),a  
060c 3a 1b 06			ld a, (.dmark+1)  
060f 32 6c ee			ld (debug_mark+1),a  
0612 3a 1c 06			ld a, (.dmark+2)  
0615 32 6d ee			ld (debug_mark+2),a  
0618 18 03			jr .pastdmark  
061a ..			.dmark: db "FN-"  
061d f1			.pastdmark: pop af  
061e			endm  
# End of macro DMARK
061e					;	push af 
061e					;	ld a, 'n' 
061e					;	ld (debug_mark),a 
061e					;	pop af 
061e						CALLMONITOR 
061e cd 6f ee			call debug_vector  
0621				endm  
# End of macro CALLMONITOR
0621					endif 
0621				; no free marks! 
0621 21 00 00				ld hl, 0 
0624 c9				ret 
0625			.fffound: 
0625				 
0625			 
0625 d1					pop de 
0626 c1					pop bc 
0627 e1					pop hl 
0628					if DEBUG_FORTH_WORDS 
0628					DMARK "FNF" 
0628 f5				push af  
0629 3a 3d 06			ld a, (.dmark)  
062c 32 6b ee			ld (debug_mark),a  
062f 3a 3e 06			ld a, (.dmark+1)  
0632 32 6c ee			ld (debug_mark+1),a  
0635 3a 3f 06			ld a, (.dmark+2)  
0638 32 6d ee			ld (debug_mark+2),a  
063b 18 03			jr .pastdmark  
063d ..			.dmark: db "FNF"  
0640 f1			.pastdmark: pop af  
0641			endm  
# End of macro DMARK
0641					;	push af 
0641					;	ld a, 'n' 
0641					;	ld (debug_mark),a 
0641					;	pop af 
0641						CALLMONITOR 
0641 cd 6f ee			call debug_vector  
0644				endm  
# End of macro CALLMONITOR
0644					endif 
0644 c9				ret 
0645			 
0645			 
0645			 
0645			; Free Space 
0645			; ---------- 
0645			; 
0645			; With current bank 
0645			; 
0645			; Set block count to zero 
0645			; Starting with first logical block 
0645			;      Find free block  
0645			;      If block id given, increment block count 
0645			; 
0645			;  
0645			 
0645			 
0645			; hl contains count of free blocks 
0645			 
0645			storage_freeblocks: 
0645			 
0645				; now locate first 0 page to mark as a free block 
0645			 
0645 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0647 21 40 00			ld hl, STORE_BLOCK_PHY 
064a 11 00 00			ld de, 0 
064d			 
064d			.fb1:   	 
064d e5					push hl 
064e c5					push bc 
064f d5					push de 
0650 cd 9c 01				call se_readbyte 
0653 d1					pop de 
0654 c1					pop bc 
0655 e1					pop hl 
0656			 
0656					; is free? 
0656 fe 00				cp 0 
0658 20 01				jr nz, .ff1cont 
065a 13					inc de 
065b			 
065b			.ff1cont: 
065b			 
065b			 
065b 3e 40				ld a, STORE_BLOCK_PHY 
065d cd e6 0d				call addatohl 
0660 10 eb				djnz .fb1 
0662			 
0662 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0664			.fb2:   	 
0664 e5					push hl 
0665 c5					push bc 
0666 d5					push de 
0667 cd 9c 01				call se_readbyte 
066a d1					pop de 
066b c1					pop bc 
066c e1					pop hl 
066d			 
066d					; is free? 
066d fe 00				cp 0 
066f 20 01				jr nz, .ff2cont 
0671 13					inc de 
0672			 
0672			.ff2cont: 
0672			 
0672 3e 40				ld a, STORE_BLOCK_PHY 
0674 cd e6 0d				call addatohl 
0677 10 eb				djnz .fb2 
0679			 
0679 eb				ex de, hl 
067a c9				ret 
067b			 
067b			; Get File ID 
067b			; ----------- 
067b			; 
067b			; With current bank 
067b			;  
067b			; Load Block 0 Config 
067b			; Get max file id number 
067b			; For each logical block 
067b			;    Read block file id 
067b			;      If first block of file and dont have file id 
067b			;         if file get id and exit 
067b			 
067b			 
067b			 
067b			 
067b			; Create File 
067b			; ----------- 
067b			; 
067b			; With current bank  
067b			; Load Block 0 Config 
067b			; Get max file id number 
067b			; Increment file id number 
067b			; Save Config 
067b			; Find free block 
067b			; Set buffer with file name and file id 
067b			; Write buffer to free block  
067b			 
067b			 
067b			; hl point to file name 
067b			; hl returns file id 
067b			 
067b			; file format: 
067b			; byte 0 - file id 
067b			; byte 1 - extent number 
067b			; byte 2-> data 
067b			 
067b			; format for extent number 0: 
067b			; 
067b			; byte 0 - file id 
067b			; byte 1 - extent 0 
067b			; byte 2 - extent count 
067b			; byte 3 -> file name and meta data 
067b			 
067b			 
067b			storage_create: 
067b				if DEBUG_STORESE 
067b					DMARK "SCR" 
067b f5				push af  
067c 3a 90 06			ld a, (.dmark)  
067f 32 6b ee			ld (debug_mark),a  
0682 3a 91 06			ld a, (.dmark+1)  
0685 32 6c ee			ld (debug_mark+1),a  
0688 3a 92 06			ld a, (.dmark+2)  
068b 32 6d ee			ld (debug_mark+2),a  
068e 18 03			jr .pastdmark  
0690 ..			.dmark: db "SCR"  
0693 f1			.pastdmark: pop af  
0694			endm  
# End of macro DMARK
0694					CALLMONITOR 
0694 cd 6f ee			call debug_vector  
0697				endm  
# End of macro CALLMONITOR
0697				endif 
0697			 
0697 e5				push hl		; save file name pointer 
0698			 
0698 cd 29 03			call storage_get_block_0 
069b			 
069b 3a 7a ea			ld a,(store_page)	; get current file id 
069e 3c				inc a 
069f 32 7a ea			ld (store_page),a 
06a2				 
06a2 32 6e ea			ld (store_tmpid),a			; save id 
06a5			 
06a5 21 00 00			ld hl, 0 
06a8 11 7a ea			ld de, store_page 
06ab				if DEBUG_STORESE 
06ab					DMARK "SCw" 
06ab f5				push af  
06ac 3a c0 06			ld a, (.dmark)  
06af 32 6b ee			ld (debug_mark),a  
06b2 3a c1 06			ld a, (.dmark+1)  
06b5 32 6c ee			ld (debug_mark+1),a  
06b8 3a c2 06			ld a, (.dmark+2)  
06bb 32 6d ee			ld (debug_mark+2),a  
06be 18 03			jr .pastdmark  
06c0 ..			.dmark: db "SCw"  
06c3 f1			.pastdmark: pop af  
06c4			endm  
# End of macro DMARK
06c4					CALLMONITOR 
06c4 cd 6f ee			call debug_vector  
06c7				endm  
# End of macro CALLMONITOR
06c7				endif 
06c7 cd dd 02			call storage_write_block	 ; save update 
06ca			 
06ca				if DEBUG_STORESE 
06ca 11 7a ea				ld de, store_page 
06cd					DMARK "SCC" 
06cd f5				push af  
06ce 3a e2 06			ld a, (.dmark)  
06d1 32 6b ee			ld (debug_mark),a  
06d4 3a e3 06			ld a, (.dmark+1)  
06d7 32 6c ee			ld (debug_mark+1),a  
06da 3a e4 06			ld a, (.dmark+2)  
06dd 32 6d ee			ld (debug_mark+2),a  
06e0 18 03			jr .pastdmark  
06e2 ..			.dmark: db "SCC"  
06e5 f1			.pastdmark: pop af  
06e6			endm  
# End of macro DMARK
06e6					CALLMONITOR 
06e6 cd 6f ee			call debug_vector  
06e9				endm  
# End of macro CALLMONITOR
06e9				endif 
06e9				;  
06e9				 
06e9 21 40 00			ld hl, STORE_BLOCK_PHY 
06ec 11 00 00			ld de, 0 
06ef cd ab 05			call storage_findnextid 
06f2			 
06f2 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
06f5			 
06f5				; TODO detect 0 = no spare blocks 
06f5			 
06f5				; hl now contains the free page to use for the file header page 
06f5			 
06f5				if DEBUG_STORESE 
06f5				DMARK "SCF" 
06f5 f5				push af  
06f6 3a 0a 07			ld a, (.dmark)  
06f9 32 6b ee			ld (debug_mark),a  
06fc 3a 0b 07			ld a, (.dmark+1)  
06ff 32 6c ee			ld (debug_mark+1),a  
0702 3a 0c 07			ld a, (.dmark+2)  
0705 32 6d ee			ld (debug_mark+2),a  
0708 18 03			jr .pastdmark  
070a ..			.dmark: db "SCF"  
070d f1			.pastdmark: pop af  
070e			endm  
# End of macro DMARK
070e					CALLMONITOR 
070e cd 6f ee			call debug_vector  
0711				endm  
# End of macro CALLMONITOR
0711				endif 
0711			 
0711 22 65 ea			ld (store_tmppageid), hl 
0714				 
0714 3a 6e ea			ld a,(store_tmpid)    ; get file id 
0717			;	ld a, (store_filecache)			; save to cache 
0717			 
0717 32 7a ea			ld (store_page),a    ; set page id 
071a 3e 00			ld a, 0			 ; extent 0 is file header 
071c 32 7b ea			ld (store_page+1), a   ; set file extent 
071f			 
071f 32 7c ea			ld (store_page+2), a   ; extent count for the file 
0722			 
0722			;	inc hl 		; init block 0 of file 
0722			;	inc hl   		; skip file and extent id 
0722			 ;       ld a, 0 
0722			;	ld (hl),a 
0722			;	ld a, (store_filecache+1)  	; save to cache 
0722			 
0722			;	inc hl    ; file name 
0722				 
0722				 
0722 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0725				if DEBUG_STORESE 
0725					DMARK "SCc" 
0725 f5				push af  
0726 3a 3a 07			ld a, (.dmark)  
0729 32 6b ee			ld (debug_mark),a  
072c 3a 3b 07			ld a, (.dmark+1)  
072f 32 6c ee			ld (debug_mark+1),a  
0732 3a 3c 07			ld a, (.dmark+2)  
0735 32 6d ee			ld (debug_mark+2),a  
0738 18 03			jr .pastdmark  
073a ..			.dmark: db "SCc"  
073d f1			.pastdmark: pop af  
073e			endm  
# End of macro DMARK
073e					CALLMONITOR 
073e cd 6f ee			call debug_vector  
0741				endm  
# End of macro CALLMONITOR
0741				endif 
0741 e1				pop hl    ; get zero term string 
0742 e5				push hl 
0743 3e 00			ld a, 0 
0745 cd 4f 12			call strlent 
0748 23				inc hl   ; cover zero term 
0749 06 00			ld b,0 
074b 4d				ld c,l 
074c e1				pop hl 
074d				;ex de, hl 
074d				if DEBUG_STORESE 
074d					DMARK "SCa" 
074d f5				push af  
074e 3a 62 07			ld a, (.dmark)  
0751 32 6b ee			ld (debug_mark),a  
0754 3a 63 07			ld a, (.dmark+1)  
0757 32 6c ee			ld (debug_mark+1),a  
075a 3a 64 07			ld a, (.dmark+2)  
075d 32 6d ee			ld (debug_mark+2),a  
0760 18 03			jr .pastdmark  
0762 ..			.dmark: db "SCa"  
0765 f1			.pastdmark: pop af  
0766			endm  
# End of macro DMARK
0766					;push af 
0766					;ld a, 'a' 
0766					;ld (debug_mark),a 
0766					;pop af 
0766					CALLMONITOR 
0766 cd 6f ee			call debug_vector  
0769				endm  
# End of macro CALLMONITOR
0769				endif 
0769 ed b0			ldir    ; copy zero term string 
076b				if DEBUG_STORESE 
076b					DMARK "SCA" 
076b f5				push af  
076c 3a 80 07			ld a, (.dmark)  
076f 32 6b ee			ld (debug_mark),a  
0772 3a 81 07			ld a, (.dmark+1)  
0775 32 6c ee			ld (debug_mark+1),a  
0778 3a 82 07			ld a, (.dmark+2)  
077b 32 6d ee			ld (debug_mark+2),a  
077e 18 03			jr .pastdmark  
0780 ..			.dmark: db "SCA"  
0783 f1			.pastdmark: pop af  
0784			endm  
# End of macro DMARK
0784					CALLMONITOR 
0784 cd 6f ee			call debug_vector  
0787				endm  
# End of macro CALLMONITOR
0787				endif 
0787			 
0787				; write file header page 
0787			 
0787 2a 65 ea			ld hl,(store_tmppageid) 
078a 11 7a ea			ld de, store_page 
078d				if DEBUG_STORESE 
078d					DMARK "SCb" 
078d f5				push af  
078e 3a a2 07			ld a, (.dmark)  
0791 32 6b ee			ld (debug_mark),a  
0794 3a a3 07			ld a, (.dmark+1)  
0797 32 6c ee			ld (debug_mark+1),a  
079a 3a a4 07			ld a, (.dmark+2)  
079d 32 6d ee			ld (debug_mark+2),a  
07a0 18 03			jr .pastdmark  
07a2 ..			.dmark: db "SCb"  
07a5 f1			.pastdmark: pop af  
07a6			endm  
# End of macro DMARK
07a6					;push af 
07a6					;ld a, 'b' 
07a6					;ld (debug_mark),a 
07a6					;pop af 
07a6					CALLMONITOR 
07a6 cd 6f ee			call debug_vector  
07a9				endm  
# End of macro CALLMONITOR
07a9				endif 
07a9 cd dd 02			call storage_write_block 
07ac			 
07ac 3a 6e ea			ld a, (store_tmpid) 
07af 6f				ld l, a 
07b0 26 00			ld h,0 
07b2				if DEBUG_STORESE 
07b2					DMARK "SCz" 
07b2 f5				push af  
07b3 3a c7 07			ld a, (.dmark)  
07b6 32 6b ee			ld (debug_mark),a  
07b9 3a c8 07			ld a, (.dmark+1)  
07bc 32 6c ee			ld (debug_mark+1),a  
07bf 3a c9 07			ld a, (.dmark+2)  
07c2 32 6d ee			ld (debug_mark+2),a  
07c5 18 03			jr .pastdmark  
07c7 ..			.dmark: db "SCz"  
07ca f1			.pastdmark: pop af  
07cb			endm  
# End of macro DMARK
07cb					CALLMONITOR 
07cb cd 6f ee			call debug_vector  
07ce				endm  
# End of macro CALLMONITOR
07ce				endif 
07ce c9				ret 
07cf				 
07cf			 
07cf			 
07cf			; 
07cf			; Read File 
07cf			; 
07cf			; h - file id to locate 
07cf			; l - extent to locate 
07cf			; de - pointer to string to read into 
07cf			; 
07cf			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07cf			 
07cf			.sr_fail: 
07cf d1				pop de 
07d0 c9				ret 
07d1			 
07d1			storage_read: 
07d1			 
07d1			 
07d1 d5				push de 
07d2			 
07d2			; TODO BUG the above push is it popped before the RET Z? 
07d2			 
07d2			; TODO how to handle multiple part blocks 
07d2			 
07d2				; locate file extent to read 
07d2			 
07d2 5c				ld e, h 
07d3 55				ld d, l 
07d4			 
07d4			.srext: 
07d4 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
07d7 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07db			 
07db 21 40 00			ld hl, STORE_BLOCK_PHY 
07de				if DEBUG_STORESE 
07de					DMARK "sre" 
07de f5				push af  
07df 3a f3 07			ld a, (.dmark)  
07e2 32 6b ee			ld (debug_mark),a  
07e5 3a f4 07			ld a, (.dmark+1)  
07e8 32 6c ee			ld (debug_mark+1),a  
07eb 3a f5 07			ld a, (.dmark+2)  
07ee 32 6d ee			ld (debug_mark+2),a  
07f1 18 03			jr .pastdmark  
07f3 ..			.dmark: db "sre"  
07f6 f1			.pastdmark: pop af  
07f7			endm  
# End of macro DMARK
07f7					CALLMONITOR 
07f7 cd 6f ee			call debug_vector  
07fa				endm  
# End of macro CALLMONITOR
07fa				endif 
07fa cd ab 05			call storage_findnextid 
07fd			 
07fd				if DEBUG_STORESE 
07fd					DMARK "srf" 
07fd f5				push af  
07fe 3a 12 08			ld a, (.dmark)  
0801 32 6b ee			ld (debug_mark),a  
0804 3a 13 08			ld a, (.dmark+1)  
0807 32 6c ee			ld (debug_mark+1),a  
080a 3a 14 08			ld a, (.dmark+2)  
080d 32 6d ee			ld (debug_mark+2),a  
0810 18 03			jr .pastdmark  
0812 ..			.dmark: db "srf"  
0815 f1			.pastdmark: pop af  
0816			endm  
# End of macro DMARK
0816					CALLMONITOR 
0816 cd 6f ee			call debug_vector  
0819				endm  
# End of macro CALLMONITOR
0819				endif 
0819 cd 0f 0e			call ishlzero 
081c			;	ld a, l 
081c			;	add h 
081c			;	cp 0 
081c 28 b1			jr z,.sr_fail			; block not found so EOF 
081e			 
081e				; save current address for use by higher level words etc 
081e			 
081e 22 6b ea			ld (store_openaddr),hl 
0821			 
0821			 
0821				; hl contains page number to load 
0821 d1				pop de   ; get storage 
0822 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
0826 d5				push de 
0827				if DEBUG_STORESE 
0827					DMARK "srg" 
0827 f5				push af  
0828 3a 3c 08			ld a, (.dmark)  
082b 32 6b ee			ld (debug_mark),a  
082e 3a 3d 08			ld a, (.dmark+1)  
0831 32 6c ee			ld (debug_mark+1),a  
0834 3a 3e 08			ld a, (.dmark+2)  
0837 32 6d ee			ld (debug_mark+2),a  
083a 18 03			jr .pastdmark  
083c ..			.dmark: db "srg"  
083f f1			.pastdmark: pop af  
0840			endm  
# End of macro DMARK
0840					CALLMONITOR 
0840 cd 6f ee			call debug_vector  
0843				endm  
# End of macro CALLMONITOR
0843				endif 
0843 cd 78 02			call storage_read_block 
0846			 
0846				; if this a continuation read??? 
0846			 
0846 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0849			 
0849 3e 3f			ld a, STORE_BLOCK_PHY-1 
084b cd e6 0d			call addatohl 
084e 7e				ld a,(hl) 
084f fe 00			cp 0 
0851 28 02			jr z, .markiscont 
0853 3e ff			ld a, 255 
0855			 
0855			.markiscont: 
0855 32 6d ea			ld (store_readcont), a 
0858			 
0858				if DEBUG_STORESE 
0858					DMARK "srC" 
0858 f5				push af  
0859 3a 6d 08			ld a, (.dmark)  
085c 32 6b ee			ld (debug_mark),a  
085f 3a 6e 08			ld a, (.dmark+1)  
0862 32 6c ee			ld (debug_mark+1),a  
0865 3a 6f 08			ld a, (.dmark+2)  
0868 32 6d ee			ld (debug_mark+2),a  
086b 18 03			jr .pastdmark  
086d ..			.dmark: db "srC"  
0870 f1			.pastdmark: pop af  
0871			endm  
# End of macro DMARK
0871					CALLMONITOR 
0871 cd 6f ee			call debug_vector  
0874				endm  
# End of macro CALLMONITOR
0874				endif 
0874				; only short reads enabled 
0874			 
0874 3a 75 ea			ld a, (store_longread) 
0877 fe 00			cp 0 
0879 ca 46 09			jp z, .readdone 
087c			 
087c			; TODO if block has no zeros then need to read next block  
087c			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087c			; check last byte of physical block. 
087c			; if not zero then the next block needs to be loaded 
087c			 
087c			 
087c 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
087f			 
087f 3e 3f			ld a, STORE_BLOCK_PHY-1 
0881 cd e6 0d			call addatohl 
0884				;dec hl 
0884 7e				ld a,(hl) 
0885				if DEBUG_STORESE 
0885					DMARK "sr?" 
0885 f5				push af  
0886 3a 9a 08			ld a, (.dmark)  
0889 32 6b ee			ld (debug_mark),a  
088c 3a 9b 08			ld a, (.dmark+1)  
088f 32 6c ee			ld (debug_mark+1),a  
0892 3a 9c 08			ld a, (.dmark+2)  
0895 32 6d ee			ld (debug_mark+2),a  
0898 18 03			jr .pastdmark  
089a ..			.dmark: db "sr?"  
089d f1			.pastdmark: pop af  
089e			endm  
# End of macro DMARK
089e					CALLMONITOR 
089e cd 6f ee			call debug_vector  
08a1				endm  
# End of macro CALLMONITOR
08a1				endif 
08a1 fe 00			cp 0 
08a3 ca 46 09			jp z, .readdone 
08a6			 
08a6				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a6			 
08a6 23				inc hl 
08a7			 
08a7 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08aa			 
08aa ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
08ae			 
08ae eb				ex de, hl 
08af			 
08af				; next ext 
08af			 
08af 23				inc hl 
08b0 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
08b3			 
08b3				if DEBUG_STORESE 
08b3					DMARK "sF2" 
08b3 f5				push af  
08b4 3a c8 08			ld a, (.dmark)  
08b7 32 6b ee			ld (debug_mark),a  
08ba 3a c9 08			ld a, (.dmark+1)  
08bd 32 6c ee			ld (debug_mark+1),a  
08c0 3a ca 08			ld a, (.dmark+2)  
08c3 32 6d ee			ld (debug_mark+2),a  
08c6 18 03			jr .pastdmark  
08c8 ..			.dmark: db "sF2"  
08cb f1			.pastdmark: pop af  
08cc			endm  
# End of macro DMARK
08cc					CALLMONITOR 
08cc cd 6f ee			call debug_vector  
08cf				endm  
# End of macro CALLMONITOR
08cf				endif 
08cf			 
08cf				; get and load block 
08cf			 
08cf cd ab 05			call storage_findnextid 
08d2			 
08d2				if DEBUG_STORESE 
08d2					DMARK "sf2" 
08d2 f5				push af  
08d3 3a e7 08			ld a, (.dmark)  
08d6 32 6b ee			ld (debug_mark),a  
08d9 3a e8 08			ld a, (.dmark+1)  
08dc 32 6c ee			ld (debug_mark+1),a  
08df 3a e9 08			ld a, (.dmark+2)  
08e2 32 6d ee			ld (debug_mark+2),a  
08e5 18 03			jr .pastdmark  
08e7 ..			.dmark: db "sf2"  
08ea f1			.pastdmark: pop af  
08eb			endm  
# End of macro DMARK
08eb					CALLMONITOR 
08eb cd 6f ee			call debug_vector  
08ee				endm  
# End of macro CALLMONITOR
08ee				endif 
08ee cd 0f 0e			call ishlzero 
08f1			;	ld a, l 
08f1			;	add h 
08f1			;	cp 0 
08f1 ca cf 07			jp z,.sr_fail			; block not found so EOF 
08f4				 
08f4				; save current address for use by higher level words etc 
08f4			 
08f4 22 6b ea			ld (store_openaddr),hl 
08f7			 
08f7 cd 78 02			call storage_read_block 
08fa			 
08fa				; on a continuation block, we now have the file id and ext in the middle of the block 
08fa				; we need to pull everything back  
08fa			 
08fa ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08fe 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0901 23				inc hl 
0902 23				inc hl     ; skip id and ext 
0903 01 40 00			ld bc, STORE_BLOCK_PHY 
0906				if DEBUG_STORESE 
0906					DMARK "SR<" 
0906 f5				push af  
0907 3a 1b 09			ld a, (.dmark)  
090a 32 6b ee			ld (debug_mark),a  
090d 3a 1c 09			ld a, (.dmark+1)  
0910 32 6c ee			ld (debug_mark+1),a  
0913 3a 1d 09			ld a, (.dmark+2)  
0916 32 6d ee			ld (debug_mark+2),a  
0919 18 03			jr .pastdmark  
091b ..			.dmark: db "SR<"  
091e f1			.pastdmark: pop af  
091f			endm  
# End of macro DMARK
091f					CALLMONITOR 
091f cd 6f ee			call debug_vector  
0922				endm  
# End of macro CALLMONITOR
0922				endif 
0922 ed b0			ldir     ; copy data 
0924			 
0924				; move the pointer back and pretend we have a full buffer for next recheck 
0924			 
0924 1b				dec de 
0925 1b				dec de 
0926			 
0926			; TODO do pop below now short circuit loop????? 
0926 c1				pop bc     ; get rid of spare de on stack 
0927				if DEBUG_STORESE 
0927					DMARK "SR>" 
0927 f5				push af  
0928 3a 3c 09			ld a, (.dmark)  
092b 32 6b ee			ld (debug_mark),a  
092e 3a 3d 09			ld a, (.dmark+1)  
0931 32 6c ee			ld (debug_mark+1),a  
0934 3a 3e 09			ld a, (.dmark+2)  
0937 32 6d ee			ld (debug_mark+2),a  
093a 18 03			jr .pastdmark  
093c ..			.dmark: db "SR>"  
093f f1			.pastdmark: pop af  
0940			endm  
# End of macro DMARK
0940					CALLMONITOR 
0940 cd 6f ee			call debug_vector  
0943				endm  
# End of macro CALLMONITOR
0943				endif 
0943 c3 d4 07			jp .srext 
0946			 
0946			 
0946			 
0946			 
0946			 
0946			.readdone:		 
0946 e1				pop hl 		 ; return start of data to show as not EOF 
0947 23				inc hl   ; past file id 
0948 23				inc hl   ; past ext 
0949				if DEBUG_STORESE 
0949					DMARK "SRe" 
0949 f5				push af  
094a 3a 5e 09			ld a, (.dmark)  
094d 32 6b ee			ld (debug_mark),a  
0950 3a 5f 09			ld a, (.dmark+1)  
0953 32 6c ee			ld (debug_mark+1),a  
0956 3a 60 09			ld a, (.dmark+2)  
0959 32 6d ee			ld (debug_mark+2),a  
095c 18 03			jr .pastdmark  
095e ..			.dmark: db "SRe"  
0961 f1			.pastdmark: pop af  
0962			endm  
# End of macro DMARK
0962					CALLMONITOR 
0962 cd 6f ee			call debug_vector  
0965				endm  
# End of macro CALLMONITOR
0965				endif 
0965 c9					ret 
0966			 
0966			 
0966			 
0966			; 
0966			; Append File 
0966			; 
0966			; hl - file id to locate 
0966			; de - pointer to (multi block) string to write 
0966			 
0966			.sa_notfound: 
0966 d1				pop de 
0967 c9				ret 
0968			 
0968			 
0968			storage_append: 
0968				; hl -  file id to append to 
0968				; de - string to append 
0968			 
0968 d5				push de 
0969				 
0969				if DEBUG_STORESE 
0969					DMARK "AP1" 
0969 f5				push af  
096a 3a 7e 09			ld a, (.dmark)  
096d 32 6b ee			ld (debug_mark),a  
0970 3a 7f 09			ld a, (.dmark+1)  
0973 32 6c ee			ld (debug_mark+1),a  
0976 3a 80 09			ld a, (.dmark+2)  
0979 32 6d ee			ld (debug_mark+2),a  
097c 18 03			jr .pastdmark  
097e ..			.dmark: db "AP1"  
0981 f1			.pastdmark: pop af  
0982			endm  
# End of macro DMARK
0982					CALLMONITOR 
0982 cd 6f ee			call debug_vector  
0985				endm  
# End of macro CALLMONITOR
0985				endif 
0985			 
0985 7d				ld a, l 
0986 32 6e ea			ld (store_tmpid), a 
0989			 
0989				; get file header  
0989			 
0989 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098b 3a 6e ea			ld a, (store_tmpid) 
098e 5f				ld e, a 
098f			 
098f 21 40 00				ld hl, STORE_BLOCK_PHY 
0992 cd ab 05				call storage_findnextid 
0995			 
0995 cd 0f 0e			call ishlzero 
0998 28 cc			jr z, .sa_notfound 
099a			 
099a 22 65 ea			ld (store_tmppageid), hl 
099d			 
099d				; TODO handle file id not found 
099d			 
099d				if DEBUG_STORESE 
099d					DMARK "AP2" 
099d f5				push af  
099e 3a b2 09			ld a, (.dmark)  
09a1 32 6b ee			ld (debug_mark),a  
09a4 3a b3 09			ld a, (.dmark+1)  
09a7 32 6c ee			ld (debug_mark+1),a  
09aa 3a b4 09			ld a, (.dmark+2)  
09ad 32 6d ee			ld (debug_mark+2),a  
09b0 18 03			jr .pastdmark  
09b2 ..			.dmark: db "AP2"  
09b5 f1			.pastdmark: pop af  
09b6			endm  
# End of macro DMARK
09b6					CALLMONITOR 
09b6 cd 6f ee			call debug_vector  
09b9				endm  
# End of macro CALLMONITOR
09b9				endif 
09b9			 
09b9				; update file extent count 
09b9			 
09b9 11 7a ea			ld de, store_page 
09bc			 
09bc cd 78 02			call storage_read_block 
09bf			 
09bf				if DEBUG_STORESE 
09bf					DMARK "AP3" 
09bf f5				push af  
09c0 3a d4 09			ld a, (.dmark)  
09c3 32 6b ee			ld (debug_mark),a  
09c6 3a d5 09			ld a, (.dmark+1)  
09c9 32 6c ee			ld (debug_mark+1),a  
09cc 3a d6 09			ld a, (.dmark+2)  
09cf 32 6d ee			ld (debug_mark+2),a  
09d2 18 03			jr .pastdmark  
09d4 ..			.dmark: db "AP3"  
09d7 f1			.pastdmark: pop af  
09d8			endm  
# End of macro DMARK
09d8					CALLMONITOR 
09d8 cd 6f ee			call debug_vector  
09db				endm  
# End of macro CALLMONITOR
09db				endif 
09db			;	ld (store_tmppageid), hl 
09db			 
09db 3a 7c ea			ld a, (store_page+2) 
09de 3c				inc a 
09df 32 7c ea			ld (store_page+2), a 
09e2 32 6d ea			ld (store_tmpext), a 
09e5				 
09e5				if DEBUG_STORESE 
09e5					DMARK "AP3" 
09e5 f5				push af  
09e6 3a fa 09			ld a, (.dmark)  
09e9 32 6b ee			ld (debug_mark),a  
09ec 3a fb 09			ld a, (.dmark+1)  
09ef 32 6c ee			ld (debug_mark+1),a  
09f2 3a fc 09			ld a, (.dmark+2)  
09f5 32 6d ee			ld (debug_mark+2),a  
09f8 18 03			jr .pastdmark  
09fa ..			.dmark: db "AP3"  
09fd f1			.pastdmark: pop af  
09fe			endm  
# End of macro DMARK
09fe					CALLMONITOR 
09fe cd 6f ee			call debug_vector  
0a01				endm  
# End of macro CALLMONITOR
0a01				endif 
0a01 2a 65 ea			ld hl, (store_tmppageid) 
0a04 11 7a ea			ld de, store_page 
0a07 cd dd 02			call storage_write_block 
0a0a			 
0a0a				; find free block 
0a0a			 
0a0a 11 00 00			ld de, 0			 ; file extent to locate 
0a0d			 
0a0d 21 40 00				ld hl, STORE_BLOCK_PHY 
0a10 cd ab 05				call storage_findnextid 
0a13 cd 0f 0e			call ishlzero 
0a16 ca 66 09			jp z, .sa_notfound 
0a19			 
0a19					; TODO handle no space left 
0a19					 
0a19 22 65 ea				ld (store_tmppageid), hl 
0a1c			 
0a1c				if DEBUG_STORESE 
0a1c					DMARK "AP4" 
0a1c f5				push af  
0a1d 3a 31 0a			ld a, (.dmark)  
0a20 32 6b ee			ld (debug_mark),a  
0a23 3a 32 0a			ld a, (.dmark+1)  
0a26 32 6c ee			ld (debug_mark+1),a  
0a29 3a 33 0a			ld a, (.dmark+2)  
0a2c 32 6d ee			ld (debug_mark+2),a  
0a2f 18 03			jr .pastdmark  
0a31 ..			.dmark: db "AP4"  
0a34 f1			.pastdmark: pop af  
0a35			endm  
# End of macro DMARK
0a35					CALLMONITOR 
0a35 cd 6f ee			call debug_vector  
0a38				endm  
# End of macro CALLMONITOR
0a38				endif 
0a38					; init the buffer with zeros so we can id if the buffer is full or not 
0a38			 
0a38 e5					push hl 
0a39 c5					push bc 
0a3a			 
0a3a 21 7a ea				ld hl, store_page 
0a3d 06 40				ld b, STORE_BLOCK_PHY 
0a3f 3e 00				ld a, 0 
0a41 77			.zeroblock:	ld (hl), a 
0a42 23					inc hl 
0a43 10 fc				djnz .zeroblock 
0a45			 
0a45 c1					pop bc 
0a46 e1					pop hl 
0a47			 
0a47					; construct block 
0a47			 
0a47 3a 6e ea				ld a, (store_tmpid) 
0a4a 32 7a ea				ld (store_page), a   ; file id 
0a4d 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
0a50 32 7b ea				ld (store_page+1), a 
0a53			 
0a53 e1					pop hl    ; get string to write 
0a54 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a56 11 7c ea				ld de, store_page+2 
0a59			 
0a59				if DEBUG_STORESE 
0a59					DMARK "AP5" 
0a59 f5				push af  
0a5a 3a 6e 0a			ld a, (.dmark)  
0a5d 32 6b ee			ld (debug_mark),a  
0a60 3a 6f 0a			ld a, (.dmark+1)  
0a63 32 6c ee			ld (debug_mark+1),a  
0a66 3a 70 0a			ld a, (.dmark+2)  
0a69 32 6d ee			ld (debug_mark+2),a  
0a6c 18 03			jr .pastdmark  
0a6e ..			.dmark: db "AP5"  
0a71 f1			.pastdmark: pop af  
0a72			endm  
# End of macro DMARK
0a72					CALLMONITOR 
0a72 cd 6f ee			call debug_vector  
0a75				endm  
# End of macro CALLMONITOR
0a75				endif 
0a75			 
0a75			 
0a75			 
0a75					; fill buffer with data until end of string or full block 
0a75			 
0a75 7e			.appd:		ld a, (hl) 
0a76 12					ld (de), a 
0a77 fe 00				cp 0 
0a79 28 04				jr z, .appdone 
0a7b 23					inc hl 
0a7c 13					inc de 
0a7d 10 f6				djnz .appd 
0a7f			 
0a7f e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a80 f5					push af   		; save last byte dumped 
0a81			 
0a81			 
0a81 2a 65 ea			ld hl, (store_tmppageid) 
0a84 11 7a ea			ld de, store_page 
0a87				if DEBUG_STORESE 
0a87					DMARK "AP6" 
0a87 f5				push af  
0a88 3a 9c 0a			ld a, (.dmark)  
0a8b 32 6b ee			ld (debug_mark),a  
0a8e 3a 9d 0a			ld a, (.dmark+1)  
0a91 32 6c ee			ld (debug_mark+1),a  
0a94 3a 9e 0a			ld a, (.dmark+2)  
0a97 32 6d ee			ld (debug_mark+2),a  
0a9a 18 03			jr .pastdmark  
0a9c ..			.dmark: db "AP6"  
0a9f f1			.pastdmark: pop af  
0aa0			endm  
# End of macro DMARK
0aa0					CALLMONITOR 
0aa0 cd 6f ee			call debug_vector  
0aa3				endm  
# End of macro CALLMONITOR
0aa3				endif 
0aa3 cd dd 02				call storage_write_block 
0aa6			 
0aa6			 
0aa6				; was that a full block of data written? 
0aa6				; any more to write out? 
0aa6			 
0aa6				; if yes then set vars and jump to start of function again 
0aa6			 
0aa6 f1					pop af 
0aa7 d1					pop de 
0aa8			 
0aa8 fe 00				cp 0		 ; no, string was fully written 
0aaa c8					ret z 
0aab			 
0aab					; setup vars for next cycle 
0aab			 
0aab 3a 6e ea				ld a, (store_tmpid) 
0aae 6f					ld l, a 
0aaf 26 00				ld h, 0 
0ab1			 
0ab1 c3 68 09			 	jp storage_append	 ; yes, need to write out some more 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			if DEBUG_STORECF 
0ab4			storageput:	 
0ab4					ret 
0ab4			storageread: 
0ab4					ld hl, store_page 
0ab4					ld b, 200 
0ab4					ld a,0 
0ab4			.src:		ld (hl),a 
0ab4					inc hl 
0ab4					djnz .src 
0ab4					 
0ab4			 
0ab4					ld de, 0 
0ab4					ld bc, 1 
0ab4					ld hl, store_page 
0ab4					call cfRead 
0ab4			 
0ab4				call cfGetError 
0ab4				ld hl,scratch 
0ab4				call hexout 
0ab4				ld hl, scratch+2 
0ab4				ld a, 0 
0ab4				ld (hl),a 
0ab4				ld de, scratch 
0ab4				ld a,display_row_1 
0ab4				call str_at_display 
0ab4				call update_display 
0ab4			 
0ab4					ld hl, store_page 
0ab4					ld (os_cur_ptr),hl 
0ab4			 
0ab4					ret 
0ab4			endif 
0ab4			 
0ab4			 
0ab4			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab4			 
0ab4			storage_clear_page: 
0ab4 e5				push hl 
0ab5 d5				push de 
0ab6 c5				push bc 
0ab7 21 7a ea			ld hl, store_page 
0aba 3e 00			ld a, 0 
0abc 77				ld (hl), a 
0abd			 
0abd 11 7b ea			ld de, store_page+1 
0ac0 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac3			 
0ac3 ed b0			ldir 
0ac5				 
0ac5 c1				pop bc 
0ac6 d1				pop de 
0ac7 e1				pop hl 
0ac8 c9				ret 
0ac9			 
0ac9			; eof 
# End of file firmware_storage.asm
0ac9			  
0ac9			; support routines for above hardware abstraction layer  
0ac9			  
0ac9			include "firmware_general.asm"        ; general support functions  
0ac9			 
0ac9			; word look up 
0ac9			 
0ac9			; in 
0ac9			; a is the index 
0ac9			; hl is pointer start of array 
0ac9			; 
0ac9			; returns 
0ac9			; hl to the word 
0ac9			; 
0ac9			 
0ac9			table_lookup:  
0ac9 d5					push de 
0aca eb					ex de, hl 
0acb			 
0acb 6f					ld l, a 
0acc 26 00				ld h, 0 
0ace 29					add hl, hl 
0acf 19					add hl, de 
0ad0 7e					ld a, (hl) 
0ad1 23					inc hl 
0ad2 66					ld h,(hl) 
0ad3 6f					ld l, a 
0ad4			 
0ad4 d1					pop de 
0ad5 c9					ret 
0ad6			 
0ad6			; Delay loops 
0ad6			 
0ad6			 
0ad6			 
0ad6			aDelayInMS: 
0ad6 c5				push bc 
0ad7 47				ld b,a 
0ad8			msdelay: 
0ad8 c5				push bc 
0ad9				 
0ad9			 
0ad9 01 41 00			ld bc,041h 
0adc cd f4 0a			call delayloop 
0adf c1				pop bc 
0ae0 05				dec b 
0ae1 20 f5			jr nz,msdelay 
0ae3			 
0ae3			;if CPU_CLOCK_8MHZ 
0ae3			;msdelay8: 
0ae3			;	push bc 
0ae3			;	 
0ae3			; 
0ae3			;	ld bc,041h 
0ae3			;	call delayloop 
0ae3			;	pop bc 
0ae3			;	dec b 
0ae3			;	jr nz,msdelay8 
0ae3			;endif 
0ae3			 
0ae3			 
0ae3 c1				pop bc 
0ae4 c9				ret 
0ae5			 
0ae5			 
0ae5			delay250ms: 
0ae5				;push de 
0ae5 01 00 40			ld bc, 04000h 
0ae8 c3 f4 0a			jp delayloop 
0aeb			delay500ms: 
0aeb				;push de 
0aeb 01 00 80			ld bc, 08000h 
0aee c3 f4 0a			jp delayloop 
0af1			delay1s: 
0af1				;push bc 
0af1			   ; Clobbers A, d and e 
0af1 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af4			delayloop: 
0af4 c5			    push bc 
0af5			 
0af5			if BASE_CPM 
0af5 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af8			.cpmloop: 
0af8 c5				push bc 
0af9			 
0af9			endif 
0af9			 
0af9			 
0af9			 
0af9			delayloopi: 
0af9			;	push bc 
0af9			;.dl: 
0af9 cb 47		    bit     0,a    	; 8 
0afb cb 47		    bit     0,a    	; 8 
0afd cb 47		    bit     0,a    	; 8 
0aff e6 ff		    and     255  	; 7 
0b01 0b			    dec     bc      	; 6 
0b02 79			    ld      a,c     	; 4 
0b03 b0			    or      b     	; 4 
0b04 c2 f9 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b07			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b07				;pop de 
0b07			;pop bc 
0b07			 
0b07			if BASE_CPM 
0b07 c1				pop bc 
0b08				 
0b08 0b			    dec     bc      	; 6 
0b09 79			    ld      a,c     	; 4 
0b0a b0			    or      b     	; 4 
0b0b c2 f8 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0e				 
0b0e			 
0b0e			endif 
0b0e			;if CPU_CLOCK_8MHZ 
0b0e			;    pop bc 
0b0e			;    push bc 
0b0e			;.dl8: 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    and     255  	; 7 
0b0e			;    dec     bc      	; 6 
0b0e			;    ld      a,c     	; 4 
0b0e			;    or      b     	; 4 
0b0e			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0e			;endif 
0b0e			 
0b0e			;if CPU_CLOCK_10MHZ 
0b0e			;    pop bc 
0b0e			;    push bc 
0b0e			;.dl8: 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    and     255  	; 7 
0b0e			;    dec     bc      	; 6 
0b0e			;    ld      a,c     	; 4 
0b0e			;    or      b     	; 4 
0b0e			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0e			;endif 
0b0e c1			    pop bc 
0b0f			 
0b0f c9				ret 
0b10			 
0b10			 
0b10			 
0b10			; eof 
# End of file firmware_general.asm
0b10			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b10			; display routines that use the physical hardware abstraction layer 
0b10			 
0b10			 
0b10			; Display an activity indicator 
0b10			; Each call returns the new char pointed to in hl 
0b10			 
0b10			active: 
0b10 3a c6 eb			ld a, (display_active) 
0b13 fe 06			cp 6 
0b15			 
0b15 20 02			jr nz, .sne 
0b17				; gone past the last one reset sequence 
0b17 3e ff			ld a, 255 
0b19			 
0b19			.sne:   
0b19				; get the next char in seq 
0b19 3c				inc a 
0b1a 32 c6 eb			ld (display_active), a 
0b1d			 
0b1d				; look up the string in the table 
0b1d 21 34 0b			ld hl, actseq 
0b20 cb 27			sla a 
0b22 cd e6 0d			call addatohl 
0b25 cd 81 1f			call loadwordinhl 
0b28			 
0b28				; forth will write the to string when pushing so move from rom to ram 
0b28			 
0b28 11 c7 eb			ld de, display_active+1 
0b2b 01 02 00			ld bc, 2 
0b2e ed b0			ldir 
0b30			 
0b30 21 c7 eb			ld hl, display_active+1 
0b33 c9				ret 
0b34				 
0b34				 
0b34			 
0b34			 
0b34			;db "|/-\|-\" 
0b34			 
0b34			actseq: 
0b34			 
0b34 42 0b		dw spin0 
0b36 44 0b		dw spin1 
0b38 46 0b		dw spin2 
0b3a 48 0b		dw spin3 
0b3c 46 0b		dw spin2 
0b3e 44 0b		dw spin1 
0b40 42 0b		dw spin0 
0b42			 
0b42 .. 00		spin0: db " ", 0 
0b44 .. 00		spin1: db "-", 0 
0b46 .. 00		spin2: db "+", 0 
0b48 .. 00		spin3: db "#", 0 
0b4a			 
0b4a			 
0b4a			; information window 
0b4a			 
0b4a			; pass hl with 1st string to display 
0b4a			; pass de with 2nd string to display 
0b4a			 
0b4a			info_panel: 
0b4a e5				push hl 
0b4b			 
0b4b 2a cc eb			ld hl, (display_fb_active) 
0b4e e5				push hl    ; future de destination 
0b4f 21 b1 ed				ld hl, display_fb0 
0b52 22 cc eb				ld (display_fb_active), hl 
0b55			 
0b55			;	call clear_display 
0b55			 
0b55				if BASE_CPM 
0b55 3e 2e			ld a, '.' 
0b57				else 
0b57				ld a, 165 
0b57				endif 
0b57 cd be 0b			call fill_display 
0b5a			 
0b5a			 
0b5a 3e 55			ld a, display_row_3 + 5 
0b5c cd cc 0b			call str_at_display 
0b5f			 
0b5f e1				pop hl 
0b60 d1				pop de 
0b61			 
0b61 e5				push hl 
0b62			 
0b62			 
0b62 3e 2d			ld a, display_row_2 + 5 
0b64 cd cc 0b			call str_at_display 
0b67			 
0b67			 
0b67 cd dc 0b			call update_display 
0b6a cd ca 1b			call next_page_prompt 
0b6d cd b9 0b			call clear_display 
0b70			 
0b70				 
0b70 21 10 ed				ld hl, display_fb1 
0b73 22 cc eb				ld (display_fb_active), hl 
0b76 cd dc 0b			call update_display 
0b79			 
0b79 e1				pop hl 
0b7a			 
0b7a c9				ret 
0b7b			 
0b7b			 
0b7b			 
0b7b			 
0b7b			; TODO windowing? 
0b7b			 
0b7b			; TODO scroll line up 
0b7b			 
0b7b			scroll_up: 
0b7b			 
0b7b e5				push hl 
0b7c d5				push de 
0b7d c5				push bc 
0b7e			 
0b7e				; get frame buffer  
0b7e			 
0b7e 2a cc eb			ld hl, (display_fb_active) 
0b81 e5				push hl    ; future de destination 
0b82			 
0b82 11 28 00			ld  de, display_cols 
0b85 19				add hl, de 
0b86			 
0b86 d1				pop de 
0b87			 
0b87				;ex de, hl 
0b87 01 9f 00			ld bc, display_fb_len -1  
0b8a			;if DEBUG_FORTH_WORDS 
0b8a			;	DMARK "SCL" 
0b8a			;	CALLMONITOR 
0b8a			;endif	 
0b8a ed b0			ldir 
0b8c			 
0b8c				; wipe bottom row 
0b8c			 
0b8c			 
0b8c 2a cc eb			ld hl, (display_fb_active) 
0b8f 11 a0 00			ld de, display_cols*display_rows 
0b92 19				add hl, de 
0b93 06 28			ld b, display_cols 
0b95 3e 20			ld a, ' ' 
0b97			.scwipe: 
0b97 77				ld (hl), a 
0b98 2b				dec hl 
0b99 10 fc			djnz .scwipe 
0b9b			 
0b9b				;pop hl 
0b9b			 
0b9b c1				pop bc 
0b9c d1				pop de 
0b9d e1				pop hl 
0b9e			 
0b9e c9				ret 
0b9f			 
0b9f			 
0b9f			;scroll_upo: 
0b9f			;	ld de, display_row_1 
0b9f			 ;	ld hl, display_row_2 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			;	ld de, display_row_2 
0b9f			 ;	ld hl, display_row_3 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			;	ld de, display_row_3 
0b9f			 ;	ld hl, display_row_4 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			 
0b9f			; TODO clear row 4 
0b9f			 
0b9f			;	ret 
0b9f			 
0b9f				 
0b9f			scroll_down: 
0b9f			 
0b9f e5				push hl 
0ba0 d5				push de 
0ba1 c5				push bc 
0ba2			 
0ba2				; get frame buffer  
0ba2			 
0ba2 2a cc eb			ld hl, (display_fb_active) 
0ba5			 
0ba5 11 9f 00			ld de, display_fb_len - 1 
0ba8 19				add hl, de 
0ba9			 
0ba9 e5			push hl    ; future de destination 
0baa			 
0baa 11 28 00			ld  de, display_cols 
0bad ed 52			sbc hl, de 
0baf			 
0baf			 
0baf d1				pop de 
0bb0			 
0bb0			;	ex de, hl 
0bb0 01 9f 00			ld bc, display_fb_len -1  
0bb3			 
0bb3			 
0bb3				 
0bb3			 
0bb3 ed b0			ldir 
0bb5			 
0bb5				; wipe bottom row 
0bb5			 
0bb5			 
0bb5			;	ld hl, (display_fb_active) 
0bb5			;;	ld de, display_cols*display_rows 
0bb5			;;	add hl, de 
0bb5			;	ld b, display_cols 
0bb5			;	ld a, ' ' 
0bb5			;.scwiped: 
0bb5			;	ld (hl), a 
0bb5			;	dec hl 
0bb5			;	djnz .scwiped 
0bb5			 
0bb5				;pop hl 
0bb5			 
0bb5 c1				pop bc 
0bb6 d1				pop de 
0bb7 e1				pop hl 
0bb8			 
0bb8 c9				ret 
0bb9			;scroll_down: 
0bb9			;	ld de, display_row_4 
0bb9			;	ld hl, display_row_3 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;	ld de, display_row_3 
0bb9			; 	ld hl, display_row_2 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;	ld de, display_row_2 
0bb9			;	ld hl, display_row_1 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;;; TODO clear row 1 
0bb9			;	ret 
0bb9			 
0bb9			 
0bb9			 
0bb9			 
0bb9			 
0bb9			; clear active frame buffer 
0bb9			 
0bb9			clear_display: 
0bb9 3e 20			ld a, ' ' 
0bbb c3 be 0b			jp fill_display 
0bbe			 
0bbe			; fill active frame buffer with a char in A 
0bbe			 
0bbe			fill_display: 
0bbe 06 a0			ld b,display_fb_len 
0bc0 2a cc eb			ld hl, (display_fb_active) 
0bc3 77			.fd1:	ld (hl),a 
0bc4 23				inc hl 
0bc5 10 fc			djnz .fd1 
0bc7 23				inc hl 
0bc8 3e 00			ld a,0 
0bca 77				ld (hl),a 
0bcb			 
0bcb			 
0bcb c9				ret 
0bcc			; Write string (DE) at pos (A) to active frame buffer 
0bcc			 
0bcc 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
0bcf 06 00					ld b,0 
0bd1 4f					ld c,a 
0bd2 09					add hl,bc 
0bd3 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd4 b7			            OR   A              ;Null terminator? 
0bd5 c8			            RET  Z              ;Yes, so finished 
0bd6 77					ld (hl),a 
0bd7 23				inc hl 
0bd8 13			            INC  DE             ;Point to next character 
0bd9 18 f8		            JR   .sad1     ;Repeat 
0bdb c9					ret 
0bdc			 
0bdc			; using current frame buffer write to physical display 
0bdc			 
0bdc			update_display: 
0bdc e5				push hl 
0bdd 2a cc eb			ld hl, (display_fb_active) 
0be0 cd 74 65			call write_display 
0be3 e1				pop hl 
0be4 c9				ret 
0be5			 
0be5			; TODO scrolling 
0be5			 
0be5			 
0be5			; move cursor right one char 
0be5			cursor_right: 
0be5			 
0be5				; TODO shift right 
0be5				; TODO if beyond max col 
0be5				; TODO       cursor_next_line 
0be5			 
0be5 c9				ret 
0be6			 
0be6			 
0be6			cursor_next_line: 
0be6				; TODO first char 
0be6				; TODO line down 
0be6				; TODO if past last row 
0be6				; TODO    scroll up 
0be6			 
0be6 c9				ret 
0be7			 
0be7			cursor_left: 
0be7				; TODO shift left 
0be7				; TODO if beyond left  
0be7				; TODO     cursor prev line 
0be7				 
0be7 c9				ret 
0be8			 
0be8			cursor_prev_line: 
0be8				; TODO last char 
0be8				; TODO line up 
0be8				; TODO if past first row 
0be8				; TODO   scroll down 
0be8			 
0be8 c9				ret 
0be9			 
0be9			 
0be9			cout: 
0be9				; A - char 
0be9 c9				ret 
0bea			 
0bea			 
0bea			; Display a menu and allow item selection (optional toggle items) 
0bea			; 
0bea			; format: 
0bea			; hl pointer to word array with zero term for items 
0bea			; e.g.    db item1 
0bea			;         db .... 
0bea			;         db 0 
0bea			; 
0bea			; a = starting menu item  
0bea			; 
0bea			; de = pointer item toggle array   (todo) 
0bea			; 
0bea			; returns item selected in a 1-... 
0bea			; returns 0 if back button pressed 
0bea			; 
0bea			; NOTE: Uses system frame buffer to display 
0bea			; 
0bea			; LEFT, Q = go back 
0bea			; RIGHT, SPACE, CR = select 
0bea			; UP, A - Up 
0bea			; DOWN, Z - Down 
0bea			 
0bea			 
0bea			 
0bea			 
0bea			 
0bea			menu: 
0bea			 
0bea					; keep array pointer 
0bea			 
0bea 22 73 ea				ld (store_tmp1), hl 
0bed 32 71 ea				ld (store_tmp2), a 
0bf0			 
0bf0					; check for key bounce 
0bf0			 
0bf0			if BASE_KEV 
0bf0			 
0bf0			.mbounce:	call cin 
0bf0					cp 0 
0bf0					jr nz, .mbounce 
0bf0			endif 
0bf0					; for ease use ex 
0bf0			 
0bf0					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bf0 21 b1 ed				ld hl, display_fb0 
0bf3 22 cc eb				ld (display_fb_active), hl 
0bf6			 
0bf6 cd b9 0b		.mloop:		call clear_display 
0bf9 cd dc 0b				call update_display 
0bfc			 
0bfc					; draw selection id '>' at 1 
0bfc			 
0bfc					; init start of list display 
0bfc			 
0bfc 3e 05				ld a, 5 
0bfe 32 6f ea				ld (store_tmp3), a   ; display row count 
0c01 3a 71 ea				ld a,( store_tmp2) 
0c04 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c07			 
0c07					 
0c07			.mitem:	 
0c07			 
0c07			 
0c07 3a 72 ea				ld a,(store_tmp2+1) 
0c0a 6f					ld l, a 
0c0b 26 00				ld h, 0 
0c0d 29					add hl, hl 
0c0e ed 5b 73 ea			ld de, (store_tmp1) 
0c12 19					add hl, de 
0c13 7e					ld a, (hl) 
0c14 23					inc hl 
0c15 66					ld h,(hl) 
0c16 6f					ld l, a 
0c17			 
0c17 cd 0f 0e				call ishlzero 
0c1a 28 1a				jr z, .mdone 
0c1c			 
0c1c eb					ex de, hl 
0c1d 3a 6f ea				ld a, (store_tmp3) 
0c20 cd cc 0b				call str_at_display 
0c23					 
0c23			 
0c23					; next item 
0c23 3a 72 ea				ld a, (store_tmp2+1) 
0c26 3c					inc a 
0c27 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c2a			 
0c2a			 		; next row 
0c2a			 
0c2a 3a 6f ea				ld a, (store_tmp3) 
0c2d c6 28				add display_cols 
0c2f 32 6f ea				ld (store_tmp3), a 
0c32			 
0c32					; at end of screen? 
0c32			 
0c32 fe 10				cp display_rows*4 
0c34 20 d1				jr nz, .mitem 
0c36			 
0c36			 
0c36			.mdone: 
0c36 cd 0f 0e				call ishlzero 
0c39 28 08				jr z, .nodn 
0c3b			 
0c3b 3e 78				ld a, display_row_4 
0c3d 11 bc 0c				ld de, .mdown 
0c40 cd cc 0b				call str_at_display 
0c43			 
0c43					; draw options to fill the screens with active item on line 1 
0c43					; if current option is 2 or more then display ^ in top 
0c43			 
0c43 3a 71 ea		.nodn:		ld a, (store_tmp2) 
0c46 fe 00				cp 0 
0c48 28 08				jr z, .noup 
0c4a			 
0c4a 3e 00				ld a, 0 
0c4c 11 ba 0c				ld de, .mup 
0c4f cd cc 0b				call str_at_display 
0c52			 
0c52 3e 02		.noup:		ld a, 2 
0c54 11 b8 0c				ld de, .msel 
0c57 cd cc 0b				call str_at_display 
0c5a			 
0c5a					; if current option + 1 is not null then display V in bottom 
0c5a					; get key 
0c5a cd dc 0b				call update_display 
0c5d			 
0c5d			 
0c5d					; handle key 
0c5d			 
0c5d cd 26 66				call cin_wait 
0c60			 
0c60 fe 05				cp KEY_UP 
0c62 28 2b				jr z, .mgoup 
0c64 fe 61				cp 'a' 
0c66 28 27				jr z, .mgoup 
0c68 fe 0a				cp KEY_DOWN 
0c6a 28 32				jr z, .mgod 
0c6c fe 7a				cp 'z' 
0c6e 28 2e				jr z, .mgod 
0c70 fe 20				cp ' ' 
0c72 28 34				jr z, .goend 
0c74 fe 0c				cp KEY_RIGHT 
0c76 28 30				jr z, .goend 
0c78 fe 0d				cp KEY_CR 
0c7a 28 2c				jr z, .goend 
0c7c fe 71				cp 'q' 
0c7e 28 0b				jr z, .goback 
0c80			 
0c80 fe 0b				cp KEY_LEFT 
0c82 28 07				jr z, .goback 
0c84 fe 08				cp KEY_BS 
0c86 28 03				jr z, .goback 
0c88 c3 f6 0b				jp .mloop 
0c8b			 
0c8b			.goback: 
0c8b 3e 00			ld a, 0 
0c8d 18 1d			jr .goend2 
0c8f			 
0c8f				; move up one 
0c8f			.mgoup: 
0c8f 3a 71 ea				ld a, (store_tmp2) 
0c92 fe 00				cp 0 
0c94 ca f6 0b				jp z, .mloop 
0c97 3d					dec a 
0c98 32 71 ea				ld (store_tmp2), a 
0c9b c3 f6 0b				jp .mloop 
0c9e			 
0c9e				; move down one 
0c9e			.mgod: 
0c9e 3a 71 ea				ld a, (store_tmp2) 
0ca1 3c					inc a 
0ca2 32 71 ea				ld (store_tmp2), a 
0ca5 c3 f6 0b				jp .mloop 
0ca8			 
0ca8			 
0ca8			.goend: 
0ca8					; get selected item number 
0ca8			 
0ca8 3a 71 ea				ld a, (store_tmp2) 
0cab 3c					inc a 
0cac			 
0cac			.goend2: 
0cac f5					push af 
0cad			 
0cad					; restore active fb 
0cad					; TODO BUG assumes fb1 
0cad			 
0cad 21 10 ed				ld hl, display_fb1 
0cb0 22 cc eb				ld (display_fb_active), hl 
0cb3			 
0cb3					; restore main regs 
0cb3			 
0cb3			 
0cb3 cd dc 0b				call update_display 
0cb6			 
0cb6 f1					pop af 
0cb7			 
0cb7 c9				ret 
0cb8			 
0cb8 .. 00		.msel:   db ">",0 
0cba .. 00		.mup:   db "^",0 
0cbc .. 00		.mdown:   db "v",0 
0cbe			 
0cbe			 
0cbe			; eof 
0cbe			 
# End of file firmware_display.asm
0cbe			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cbe			; random number generators 
0cbe			 
0cbe			 
0cbe			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cbe			 
0cbe			 
0cbe			;-----> Generate a random number 
0cbe			; output a=answer 0<=a<=255 
0cbe			; all registers are preserved except: af 
0cbe			random: 
0cbe e5			        push    hl 
0cbf d5			        push    de 
0cc0 2a ab eb		        ld      hl,(randData) 
0cc3 ed 5f		        ld      a,r 
0cc5 57			        ld      d,a 
0cc6 5e			        ld      e,(hl) 
0cc7 19			        add     hl,de 
0cc8 85			        add     a,l 
0cc9 ac			        xor     h 
0cca 22 ab eb		        ld      (randData),hl 
0ccd d1			        pop     de 
0cce e1			        pop     hl 
0ccf c9			        ret 
0cd0			 
0cd0			 
0cd0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cd0			 
0cd0			 
0cd0			 
0cd0			;------LFSR------ 
0cd0			;James Montelongo 
0cd0			;optimized by Spencer Putt 
0cd0			;out: 
0cd0			; a = 8 bit random number 
0cd0			RandLFSR: 
0cd0 21 b1 eb		        ld hl,LFSRSeed+4 
0cd3 5e			        ld e,(hl) 
0cd4 23			        inc hl 
0cd5 56			        ld d,(hl) 
0cd6 23			        inc hl 
0cd7 4e			        ld c,(hl) 
0cd8 23			        inc hl 
0cd9 7e			        ld a,(hl) 
0cda 47			        ld b,a 
0cdb cb 13		        rl e  
0cdd cb 12			rl d 
0cdf cb 11		        rl c  
0ce1 17				rla 
0ce2 cb 13		        rl e  
0ce4 cb 12			rl d 
0ce6 cb 11		        rl c  
0ce8 17				rla 
0ce9 cb 13		        rl e  
0ceb cb 12			rl d 
0ced cb 11		        rl c  
0cef 17				rla 
0cf0 67			        ld h,a 
0cf1 cb 13		        rl e  
0cf3 cb 12			rl d 
0cf5 cb 11		        rl c  
0cf7 17				rla 
0cf8 a8			        xor b 
0cf9 cb 13		        rl e  
0cfb cb 12			rl d 
0cfd ac			        xor h 
0cfe a9			        xor c 
0cff aa			        xor d 
0d00 21 b3 eb		        ld hl,LFSRSeed+6 
0d03 11 b4 eb		        ld de,LFSRSeed+7 
0d06 01 07 00		        ld bc,7 
0d09 ed b8		        lddr 
0d0b 12			        ld (de),a 
0d0c c9			        ret 
0d0d			 
0d0d			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d0d			 
0d0d			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d0d			 
0d0d			 
0d0d			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d0d			 
0d0d			prng16: 
0d0d			;Inputs: 
0d0d			;   (seed1) contains a 16-bit seed value 
0d0d			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d0d			;Outputs: 
0d0d			;   HL is the result 
0d0d			;   BC is the result of the LCG, so not that great of quality 
0d0d			;   DE is preserved 
0d0d			;Destroys: 
0d0d			;   AF 
0d0d			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d0d			;160cc 
0d0d			;26 bytes 
0d0d 2a a5 eb		    ld hl,(seed1) 
0d10 44			    ld b,h 
0d11 4d			    ld c,l 
0d12 29			    add hl,hl 
0d13 29			    add hl,hl 
0d14 2c			    inc l 
0d15 09			    add hl,bc 
0d16 22 a5 eb		    ld (seed1),hl 
0d19 2a a3 eb		    ld hl,(seed2) 
0d1c 29			    add hl,hl 
0d1d 9f			    sbc a,a 
0d1e e6 2d		    and %00101101 
0d20 ad			    xor l 
0d21 6f			    ld l,a 
0d22 22 a3 eb		    ld (seed2),hl 
0d25 09			    add hl,bc 
0d26 c9			    ret 
0d27			 
0d27			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d27			 
0d27			rand32: 
0d27			;Inputs: 
0d27			;   (seed1_0) holds the lower 16 bits of the first seed 
0d27			;   (seed1_1) holds the upper 16 bits of the first seed 
0d27			;   (seed2_0) holds the lower 16 bits of the second seed 
0d27			;   (seed2_1) holds the upper 16 bits of the second seed 
0d27			;   **NOTE: seed2 must be non-zero 
0d27			;Outputs: 
0d27			;   HL is the result 
0d27			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d27			;Destroys: 
0d27			;   AF 
0d27			;Tested and passes all CAcert tests 
0d27			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d27			;it has a period of 18,446,744,069,414,584,320 
0d27			;roughly 18.4 quintillion. 
0d27			;LFSR taps: 0,2,6,7  = 11000101 
0d27			;291cc 
0d27			;seed1_0=$+1 
0d27			;    ld hl,12345 
0d27			;seed1_1=$+1 
0d27			;    ld de,6789 
0d27			;    ld b,h 
0d27			;    ld c,l 
0d27			;    add hl,hl \ rl e \ rl d 
0d27			;    add hl,hl \ rl e \ rl d 
0d27			;    inc l 
0d27			;    add hl,bc 
0d27			;    ld (seed1_0),hl 
0d27			;    ld hl,(seed1_1) 
0d27			;    adc hl,de 
0d27			;    ld (seed1_1),hl 
0d27			;    ex de,hl 
0d27			;seed2_0=$+1 
0d27			;    ld hl,9876 
0d27			;seed2_1=$+1 
0d27			;    ld bc,54321 
0d27			;    add hl,hl \ rl c \ rl b 
0d27			;    ld (seed2_1),bc 
0d27			;    sbc a,a 
0d27			;    and %11000101 
0d27			;    xor l 
0d27			;    ld l,a 
0d27			;    ld (seed2_0),hl 
0d27			;    ex de,hl 
0d27			;    add hl,bc 
0d27			;    ret 
0d27			; 
0d27			 
0d27			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d27			; 20 bytes, 86 cycles (excluding ret) 
0d27			 
0d27			; returns   hl = pseudorandom number 
0d27			; corrupts   a 
0d27			 
0d27			; generates 16-bit pseudorandom numbers with a period of 65535 
0d27			; using the xorshift method: 
0d27			 
0d27			; hl ^= hl << 7 
0d27			; hl ^= hl >> 9 
0d27			; hl ^= hl << 8 
0d27			 
0d27			; some alternative shift triplets which also perform well are: 
0d27			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d27			 
0d27			;  org 32768 
0d27			 
0d27			xrnd: 
0d27 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d2a 3e 00		  ld a,0 
0d2c bd			  cp l 
0d2d 20 02		  jr nz, .xrnd1 
0d2f 2e 01		  ld l, 1 
0d31			.xrnd1: 
0d31			 
0d31 7c			  ld a,h 
0d32 1f			  rra 
0d33 7d			  ld a,l 
0d34 1f			  rra 
0d35 ac			  xor h 
0d36 67			  ld h,a 
0d37 7d			  ld a,l 
0d38 1f			  rra 
0d39 7c			  ld a,h 
0d3a 1f			  rra 
0d3b ad			  xor l 
0d3c 6f			  ld l,a 
0d3d ac			  xor h 
0d3e 67			  ld h,a 
0d3f			 
0d3f 22 a9 eb		  ld (xrandc),hl 
0d42			 
0d42 c9			  ret 
0d43			;  
0d43			 
0d43			 
0d43			;;;; int maths 
0d43			 
0d43			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d43			; Divide 16-bit values (with 16-bit result) 
0d43			; In: Divide BC by divider DE 
0d43			; Out: BC = result, HL = rest 
0d43			; 
0d43			Div16: 
0d43 21 00 00		    ld hl,0 
0d46 78			    ld a,b 
0d47 06 08		    ld b,8 
0d49			Div16_Loop1: 
0d49 17			    rla 
0d4a ed 6a		    adc hl,hl 
0d4c ed 52		    sbc hl,de 
0d4e 30 01		    jr nc,Div16_NoAdd1 
0d50 19			    add hl,de 
0d51			Div16_NoAdd1: 
0d51 10 f6		    djnz Div16_Loop1 
0d53 17			    rla 
0d54 2f			    cpl 
0d55 47			    ld b,a 
0d56 79			    ld a,c 
0d57 48			    ld c,b 
0d58 06 08		    ld b,8 
0d5a			Div16_Loop2: 
0d5a 17			    rla 
0d5b ed 6a		    adc hl,hl 
0d5d ed 52		    sbc hl,de 
0d5f 30 01		    jr nc,Div16_NoAdd2 
0d61 19			    add hl,de 
0d62			Div16_NoAdd2: 
0d62 10 f6		    djnz Div16_Loop2 
0d64 17			    rla 
0d65 2f			    cpl 
0d66 41			    ld b,c 
0d67 4f			    ld c,a 
0d68 c9			ret 
0d69			 
0d69			 
0d69			;http://z80-heaven.wikidot.com/math 
0d69			; 
0d69			;Inputs: 
0d69			;     DE and A are factors 
0d69			;Outputs: 
0d69			;     A is not changed 
0d69			;     B is 0 
0d69			;     C is not changed 
0d69			;     DE is not changed 
0d69			;     HL is the product 
0d69			;Time: 
0d69			;     342+6x 
0d69			; 
0d69			Mult16: 
0d69			 
0d69 06 08		     ld b,8          ;7           7 
0d6b 21 00 00		     ld hl,0         ;10         10 
0d6e 29			       add hl,hl     ;11*8       88 
0d6f 07			       rlca          ;4*8        32 
0d70 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d72 19			         add hl,de   ;--         -- 
0d73 10 f9		       djnz $-5      ;13*7+8     99 
0d75 c9			ret 
0d76			 
0d76			; 
0d76			; Square root of 16-bit value 
0d76			; In:  HL = value 
0d76			; Out:  D = result (rounded down) 
0d76			; 
0d76			;Sqr16: 
0d76			;    ld de,#0040 
0d76			;    ld a,l 
0d76			;    ld l,h 
0d76			;    ld h,d 
0d76			;    or a 
0d76			;    ld b,8 
0d76			;Sqr16_Loop: 
0d76			;    sbc hl,de 
0d76			;    jr nc,Sqr16_Skip 
0d76			;    add hl,de 
0d76			;Sqr16_Skip: 
0d76			;    ccf 
0d76			;    rl d 
0d76			;    add a,a 
0d76			;    adc hl,hl 
0d76			;    add a,a 
0d76			;    adc hl,hl 
0d76			;    djnz Sqr16_Loop 
0d76			;    ret 
0d76			; 
0d76			; 
0d76			; Divide 8-bit values 
0d76			; In: Divide E by divider C 
0d76			; Out: A = result, B = rest 
0d76			; 
0d76			Div8: 
0d76 af			    xor a 
0d77 06 08		    ld b,8 
0d79			Div8_Loop: 
0d79 cb 13		    rl e 
0d7b 17			    rla 
0d7c 91			    sub c 
0d7d 30 01		    jr nc,Div8_NoAdd 
0d7f 81			    add a,c 
0d80			Div8_NoAdd: 
0d80 10 f7		    djnz Div8_Loop 
0d82 47			    ld b,a 
0d83 7b			    ld a,e 
0d84 17			    rla 
0d85 2f			    cpl 
0d86 c9			    ret 
0d87			 
0d87			; 
0d87			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d87			; In: Multiply A with DE 
0d87			; Out: HL = result 
0d87			; 
0d87			Mult12U: 
0d87 2e 00		    ld l,0 
0d89 87			    add a,a 
0d8a 30 01		    jr nc,Mult12U_NoAdd0 
0d8c 19			    add hl,de 
0d8d			Mult12U_NoAdd0: 
0d8d 29			    add hl,hl 
0d8e 87			    add a,a 
0d8f 30 01		    jr nc,Mult12U_NoAdd1 
0d91 19			    add hl,de 
0d92			Mult12U_NoAdd1: 
0d92 29			    add hl,hl 
0d93 87			    add a,a 
0d94 30 01		    jr nc,Mult12U_NoAdd2 
0d96 19			    add hl,de 
0d97			Mult12U_NoAdd2: 
0d97 29			    add hl,hl 
0d98 87			    add a,a 
0d99 30 01		    jr nc,Mult12U_NoAdd3 
0d9b 19			    add hl,de 
0d9c			Mult12U_NoAdd3: 
0d9c 29			    add hl,hl 
0d9d 87			    add a,a 
0d9e 30 01		    jr nc,Mult12U_NoAdd4 
0da0 19			    add hl,de 
0da1			Mult12U_NoAdd4: 
0da1 29			    add hl,hl 
0da2 87			    add a,a 
0da3 30 01		    jr nc,Mult12U_NoAdd5 
0da5 19			    add hl,de 
0da6			Mult12U_NoAdd5: 
0da6 29			    add hl,hl 
0da7 87			    add a,a 
0da8 30 01		    jr nc,Mult12U_NoAdd6 
0daa 19			    add hl,de 
0dab			Mult12U_NoAdd6: 
0dab 29			    add hl,hl 
0dac 87			    add a,a 
0dad d0			    ret nc 
0dae 19			    add hl,de 
0daf c9			    ret 
0db0			 
0db0			; 
0db0			; Multiply 8-bit value with a 16-bit value (right rotating) 
0db0			; In: Multiply A with DE 
0db0			;      Put lowest value in A for most efficient calculation 
0db0			; Out: HL = result 
0db0			; 
0db0			Mult12R: 
0db0 21 00 00		    ld hl,0 
0db3			Mult12R_Loop: 
0db3 cb 3f		    srl a 
0db5 30 01		    jr nc,Mult12R_NoAdd 
0db7 19			    add hl,de 
0db8			Mult12R_NoAdd: 
0db8 cb 23		    sla e 
0dba cb 12		    rl d 
0dbc b7			    or a 
0dbd c2 b3 0d		    jp nz,Mult12R_Loop 
0dc0 c9			    ret 
0dc1			 
0dc1			; 
0dc1			; Multiply 16-bit values (with 32-bit result) 
0dc1			; In: Multiply BC with DE 
0dc1			; Out: BCHL = result 
0dc1			; 
0dc1			Mult32: 
0dc1 79			    ld a,c 
0dc2 48			    ld c,b 
0dc3 21 00 00		    ld hl,0 
0dc6 06 10		    ld b,16 
0dc8			Mult32_Loop: 
0dc8 29			    add hl,hl 
0dc9 17			    rla 
0dca cb 11		    rl c 
0dcc 30 07		    jr nc,Mult32_NoAdd 
0dce 19			    add hl,de 
0dcf ce 00		    adc a,0 
0dd1 d2 d5 0d		    jp nc,Mult32_NoAdd 
0dd4 0c			    inc c 
0dd5			Mult32_NoAdd: 
0dd5 10 f1		    djnz Mult32_Loop 
0dd7 41			    ld b,c 
0dd8 4f			    ld c,a 
0dd9 c9			    ret 
0dda			 
0dda			 
0dda			 
0dda			; 
0dda			; Multiply 8-bit values 
0dda			; In:  Multiply H with E 
0dda			; Out: HL = result 
0dda			; 
0dda			Mult8: 
0dda 16 00		    ld d,0 
0ddc 6a			    ld l,d 
0ddd 06 08		    ld b,8 
0ddf			Mult8_Loop: 
0ddf 29			    add hl,hl 
0de0 30 01		    jr nc,Mult8_NoAdd 
0de2 19			    add hl,de 
0de3			Mult8_NoAdd: 
0de3 10 fa		    djnz Mult8_Loop 
0de5 c9			    ret 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			;;http://z80-heaven.wikidot.com/math 
0de6			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de6			; 
0de6			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de6			;     ld a,16        ;7 
0de6			;     ld hl,0        ;10 
0de6			;     jp $+5         ;10 
0de6			;.DivLoop: 
0de6			;       add hl,bc    ;-- 
0de6			;       dec a        ;64 
0de6			;       jr z,.DivLoopEnd        ;86 
0de6			; 
0de6			;       sla e        ;128 
0de6			;       rl d         ;128 
0de6			;       adc hl,hl    ;240 
0de6			;       sbc hl,bc    ;240 
0de6			;       jr nc,.DivLoop ;23|21 
0de6			;       inc e        ;-- 
0de6			;       jp .DivLoop+1 
0de6			; 
0de6			;.DivLoopEnd: 
0de6			 
0de6			;HL_Div_C: 
0de6			;Inputs: 
0de6			;     HL is the numerator 
0de6			;     C is the denominator 
0de6			;Outputs: 
0de6			;     A is the remainder 
0de6			;     B is 0 
0de6			;     C is not changed 
0de6			;     DE is not changed 
0de6			;     HL is the quotient 
0de6			; 
0de6			;       ld b,16 
0de6			;       xor a 
0de6			;         add hl,hl 
0de6			;         rla 
0de6			;         cp c 
0de6			;         jr c,$+4 
0de6			;           inc l 
0de6			;           sub c 
0de6			;         djnz $-7 
0de6			 
0de6			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de6			 
0de6			addatohl: 
0de6 85			    add   a, l    ; A = A+L 
0de7 6f			    ld    l, a    ; L = A+L 
0de8 8c			    adc   a, h    ; A = A+L+H+carry 
0de9 95			    sub   l       ; A = H+carry 
0dea 67			    ld    h, a    ; H = H+carry 
0deb c9			ret 
0dec			 
0dec			addatode: 
0dec 83			    add   a, e    ; A = A+L 
0ded 5f			    ld    e, a    ; L = A+L 
0dee 8a			    adc   a, d    ; A = A+L+H+carry 
0def 93			    sub   e       ; A = H+carry 
0df0 57			    ld    d, a    ; H = H+carry 
0df1 c9			ret 
0df2			 
0df2			 
0df2			addatobc: 
0df2 81			    add   a, c    ; A = A+L 
0df3 4f			    ld    c, a    ; L = A+L 
0df4 88			    adc   a, b    ; A = A+L+H+carry 
0df5 91			    sub   c       ; A = H+carry 
0df6 47			    ld    b, a    ; H = H+carry 
0df7 c9			ret 
0df8			 
0df8			subafromhl: 
0df8			   ; If A=0 do nothing 
0df8			    ; Otherwise flip A's sign. Since 
0df8			    ; the upper byte becomes -1, also 
0df8			    ; substract 1 from H. 
0df8 ed 44		    neg 
0dfa ca 03 0e		    jp    z, Skip 
0dfd 25			    dec   h 
0dfe			     
0dfe			    ; Now add the low byte as usual 
0dfe			    ; Two's complement takes care of 
0dfe			    ; ensuring the result is correct 
0dfe 85			    add   a, l 
0dff 6f			    ld    l, a 
0e00 8c			    adc   a, h 
0e01 95			    sub   l 
0e02 67			    ld    h, a 
0e03			Skip: 
0e03 c9				ret 
0e04			 
0e04			 
0e04			; compare hl and de 
0e04			; returns:  
0e04			; if hl = de, z=1, s=0, c0=0 
0e04			; if hl > de, z=0, s=0, c=0 
0e04			; if hl < de, z=0, s=1, c=1 
0e04			cmp16:	 
0e04 b7				or a 
0e05 ed 52			sbc hl,de 
0e07 e0				ret po 
0e08 7c				ld a,h 
0e09 1f				rra 
0e0a ee 40			xor 01000000B 
0e0c 37				scf 
0e0d 8f				adc a,a 
0e0e c9				ret 
0e0f			 
0e0f			 
0e0f			; test if hl contains zero   - A is destroyed 
0e0f			 
0e0f			ishlzero:    
0e0f b7				or a     ; reset flags 
0e10 7c				ld a, h 
0e11 b5				or l        	 
0e12			 
0e12 c9				ret 
0e13			 
0e13			 
0e13			 
0e13			 
0e13			if FORTH_ENABLE_FLOATMATH 
0e13			;include "float/bbcmath.z80" 
0e13			include "float/lpfpcalc.asm" 
0e13			endif 
0e13			 
0e13			 
0e13			; eof 
0e13			 
# End of file firmware_maths.asm
0e13			include "firmware_strings.asm"   ; string handling  
0e13			 
0e13			 
0e13			; TODO string len 
0e13			; input text string, end on cr with zero term 
0e13			; a offset into frame buffer to start prompt 
0e13			; d is max length 
0e13			; e is display size TODO 
0e13			; c is current cursor position 
0e13			; hl is ptr to where string will be stored 
0e13			 
0e13			 
0e13			; TODO check limit of buffer for new inserts 
0e13			; TODO check insert does not push beyond buffer 
0e13			; TODO scroll in a limited display area 
0e13			; TODO scroll whole screen on page wrap 
0e13			 
0e13			 
0e13			; TODO handle KEY_PREVWORD 
0e13			; TODO handle KEY_NEXTWORD 
0e13			; TODO handle KEY_HOME 
0e13			; TODO handle KEY_END 
0e13			; TODO use LCD cursor? 
0e13			 
0e13 32 64 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0e16 81					add c 
0e17 32 62 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0e1a 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
0e1d 79					ld a, c 
0e1e cd e6 0d				call addatohl 
0e21 22 69 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0e24 7a					ld a,d 
0e25 32 66 ee			        ld (input_size), a       ; save length of input area 
0e28 79					ld a, c 
0e29 32 55 ee				ld (input_cursor),a      ; init cursor start position  
0e2c 7b					ld a,e 
0e2d 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e30					 
0e30					 
0e30			 
0e30			;		ld a,(input_ptr) 
0e30			;		ld (input_under_cursor),a 	; save what is under the cursor 
0e30			 
0e30			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e30					; init cursor shape if not set by the cin routines 
0e30 21 c1 eb				ld hl, cursor_shape 
0e33 3e ff				ld a, 255 
0e35 77					ld (hl), a 
0e36 23					inc hl 
0e37 3e 00				ld a, 0 
0e39 77					ld (hl), a 
0e3a			 
0e3a 3e 0f				ld a, CUR_BLINK_RATE 
0e3c 32 60 ee				ld (input_cur_flash), a 
0e3f 3e 01				ld a, 1 
0e41 32 5f ee				ld (input_cur_onoff),a 
0e44			 
0e44			;	if DEBUG_INPUT 
0e44			;		push af 
0e44			;		ld a, 'I' 
0e44			;		ld (debug_mark),a 
0e44			;		pop af 
0e44			;		CALLMONITOR 
0e44			;	endif 
0e44			.is1:		; main entry loop 
0e44			 
0e44			 
0e44			 
0e44					; pause 1ms 
0e44			 
0e44 3e 01				ld a, 1 
0e46 cd d6 0a				call aDelayInMS 
0e49			 
0e49					; dec flash counter 
0e49 3a 60 ee				ld a, (input_cur_flash) 
0e4c 3d					dec a 
0e4d 32 60 ee				ld (input_cur_flash), a 
0e50 fe 00				cp 0 
0e52 20 0d				jr nz, .nochgstate 
0e54			 
0e54			 
0e54					; change state 
0e54 3a 5f ee				ld a,(input_cur_onoff) 
0e57 ed 44				neg 
0e59 32 5f ee				ld (input_cur_onoff),a 
0e5c			 
0e5c			 
0e5c					; reset on change of state 
0e5c 3e 0f				ld a, CUR_BLINK_RATE 
0e5e 32 60 ee				ld (input_cur_flash), a 
0e61			 
0e61			.nochgstate: 
0e61					 
0e61					 
0e61			 
0e61					; display cursor  
0e61			 
0e61			;		ld hl, (input_start) 
0e61			;		ld a, (input_cursor) 
0e61			;		call addatohl 
0e61			 
0e61					; get char under cursor and replace with cursor 
0e61 2a 69 ee		ld hl, (input_ptr) 
0e64			;		ld a, (hl) 
0e64			;		ld (input_under_cursor),a 
0e64			;		ld a, '_' 
0e64			;		ld (hl), a 
0e64			 
0e64					; display string 
0e64			 
0e64 ed 5b 67 ee			ld de, (input_start) 
0e68 3a 64 ee				ld a, (input_at_pos) 
0e6b cd cc 0b				call str_at_display 
0e6e			;	        call update_display 
0e6e			 
0e6e					; find place to put the cursor 
0e6e			;		add h 
0e6e			;		ld l, display_row_1 
0e6e			;		sub l 
0e6e			; (input_at_pos) 
0e6e					;ld c, a 
0e6e			;		ld a, (input_cursor) 
0e6e			;		ld l, (input_at_pos) 
0e6e			;		;ld b, h 
0e6e			;		add l 
0e6e			;		ld (input_at_cursor),a 
0e6e					;ld l,h 
0e6e			 
0e6e			;		ld h, 0 
0e6e			;		ld l,(input_at_pos) 
0e6e			;		ld a, (input_cursor) 
0e6e			;		call addatohl 
0e6e			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0e6e			;		call subafromhl 
0e6e			;		ld a,l 
0e6e			;		ld (input_at_cursor), a 
0e6e			 
0e6e				if DEBUG_INPUT 
0e6e					ld a, (hardware_diag) 
0e6e					cp 0 
0e6e					jr z, .skip_input_diag 
0e6e			 
0e6e					ld a,(input_at_pos) 
0e6e					ld hl, LFSRSeed 
0e6e					call hexout 
0e6e					ld a, (input_cursor) 
0e6e					ld hl, LFSRSeed+2 
0e6e					call hexout 
0e6e					ld a,(input_at_cursor) 
0e6e					ld hl, LFSRSeed+4 
0e6e					call hexout 
0e6e			 
0e6e					ld a,(input_cur_onoff) 
0e6e					ld hl, LFSRSeed+6 
0e6e					call hexout 
0e6e			 
0e6e					ld a,(input_cur_flash) 
0e6e					ld hl, LFSRSeed+8 
0e6e					call hexout 
0e6e			 
0e6e					ld a,(input_len) 
0e6e					ld hl, LFSRSeed+10 
0e6e					call hexout 
0e6e					ld hl, LFSRSeed+12 
0e6e					ld a, 0 
0e6e					ld (hl),a 
0e6e					ld a, display_row_4 
0e6e					ld de, LFSRSeed 
0e6e					call str_at_display 
0e6e					.skip_input_diag: 
0e6e				endif 
0e6e			 
0e6e					; decide on if we are showing the cursor this time round 
0e6e			 
0e6e 3a 5f ee				ld a, (input_cur_onoff) 
0e71 fe ff				cp 255 
0e73 28 13				jr z, .skipcur 
0e75			 
0e75			 
0e75 3a 62 ee				ld a,(input_at_cursor) 
0e78 11 c1 eb				ld de, cursor_shape 
0e7b cd cc 0b				call str_at_display 
0e7e			 
0e7e					; save length of current input string 
0e7e 2a 67 ee				ld hl, (input_start) 
0e81 cd 44 12				call strlenz 
0e84 7d					ld a,l 
0e85 32 5a ee				ld (input_len),a 
0e88			 
0e88			.skipcur: 
0e88			 
0e88 cd dc 0b			        call update_display 
0e8b					 
0e8b			 
0e8b			 
0e8b					; wait 
0e8b				 
0e8b					; TODO loop without wait to flash the cursor and char under cursor	 
0e8b cd 2e 66				call cin    ; _wait 
0e8e			 
0e8e fe 00				cp 0 
0e90 ca 44 0e				jp z, .is1 
0e93			 
0e93					; get ptr to char to input into 
0e93			 
0e93 4f					ld c,a 
0e94 2a 67 ee				ld hl, (input_start) 
0e97 3a 55 ee				ld a, (input_cursor) 
0e9a cd e6 0d				call addatohl 
0e9d 22 69 ee				ld (input_ptr), hl 
0ea0 79					ld a,c 
0ea1			 
0ea1					; replace char under cursor 
0ea1			 
0ea1			;		ld hl, (input_ptr) 
0ea1			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ea1			;		ld (hl), a 
0ea1			 
0ea1			;	if DEBUG_INPUT 
0ea1			;		push af 
0ea1			;		ld a, 'i' 
0ea1			;		ld (debug_mark),a 
0ea1			;		pop af 
0ea1			;		CALLMONITOR 
0ea1			;	endif 
0ea1 fe 0e				cp KEY_HOME 
0ea3 20 0e				jr nz, .iske 
0ea5			 
0ea5 3a 64 ee				ld a, (input_at_pos) 
0ea8 32 62 ee				ld (input_at_cursor),a 
0eab 3e 00				ld a, 0 
0ead 32 55 ee				ld (input_cursor), a 
0eb0 c3 44 0e				jp .is1 
0eb3					 
0eb3 fe 0f		.iske:		cp KEY_END 
0eb5 20 03				jr nz, .isknw 
0eb7 c3 44 0e				jp .is1 
0eba			 
0eba fe 06		.isknw:		cp KEY_NEXTWORD 
0ebc 20 1b				jr nz, .iskpw 
0ebe			 
0ebe 2a 69 ee		.isknwm:	ld hl, (input_ptr) 
0ec1 7e					ld a,(hl)	 
0ec2 fe 00				cp 0 
0ec4 ca 44 0e				jp z, .is1    ; end of string 
0ec7 fe 20				cp ' ' 
0ec9 ca 44 0e				jp z, .is1    ; end of word 
0ecc 23					inc hl 
0ecd 22 69 ee				ld (input_ptr), hl 
0ed0 3a 62 ee				ld a, (input_at_cursor) 
0ed3 3c					inc a 
0ed4 32 62 ee				ld (input_at_cursor), a 
0ed7 18 e5				jr .isknwm 
0ed9			 
0ed9 fe 07		.iskpw:		cp KEY_PREVWORD 
0edb 20 1b				jr nz, .iskl 
0edd			.iskpwm:	 
0edd 2a 69 ee				ld hl, (input_ptr) 
0ee0 7e					ld a,(hl)	 
0ee1 fe 00				cp 0  
0ee3 ca 44 0e				jp z, .is1    ; end of string 
0ee6 fe 20				cp ' ' 
0ee8 ca 44 0e				jp z, .is1    ; end of word 
0eeb 2b					dec hl 
0eec 22 69 ee				ld (input_ptr), hl 
0eef 3a 62 ee				ld a, (input_at_cursor) 
0ef2 3d					dec a 
0ef3 32 62 ee				ld (input_at_cursor), a 
0ef6 18 e5				jr .iskpwm 
0ef8			 
0ef8			 
0ef8 fe 0b		.iskl:		cp KEY_LEFT 
0efa 20 27				jr nz, .isk1 
0efc			 
0efc 3a 55 ee				ld a, (input_cursor) 
0eff			 
0eff fe 00				cp 0 
0f01 ca 44 0e				jp z, .is1 		; at start of line to ignore  
0f04			 
0f04 3d					dec  a 		; TODO check underflow 
0f05 32 55 ee				ld (input_cursor), a 
0f08			 
0f08 2a 69 ee				ld hl, (input_ptr) 
0f0b 2b					dec hl 
0f0c 22 69 ee				ld (input_ptr), hl 
0f0f					 
0f0f 3a 62 ee				ld a, (input_at_cursor) 
0f12 3d					dec a 
0f13 32 62 ee				ld (input_at_cursor), a 
0f16			 
0f16 3e 01				ld a, 1		; show cursor moving 
0f18 32 5f ee				ld (input_cur_onoff),a 
0f1b 3e 0f				ld a, CUR_BLINK_RATE 
0f1d 32 60 ee				ld (input_cur_flash), a 
0f20			 
0f20 c3 44 0e				jp .is1 
0f23			 
0f23 fe 0c		.isk1:		cp KEY_RIGHT 
0f25 20 2a				jr nz, .isk2 
0f27			 
0f27 3a 5a ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0f2a 5f					ld e,a 
0f2b 3a 55 ee				ld a, (input_cursor) 
0f2e bb					cp e 
0f2f ca 44 0e				jp z, .is1		; at the end of string so dont go right 
0f32			 
0f32 3c					inc  a 		; TODO check overflow 
0f33 32 55 ee				ld (input_cursor), a 
0f36			 
0f36 3a 62 ee				ld a, (input_at_cursor) 
0f39 3c					inc a 
0f3a 32 62 ee				ld (input_at_cursor), a 
0f3d			 
0f3d 2a 69 ee				ld hl, (input_ptr) 
0f40 23					inc hl 
0f41 22 69 ee				ld (input_ptr), hl 
0f44			 
0f44 3e 01				ld a, 1		; show cursor moving 
0f46 32 5f ee				ld (input_cur_onoff),a 
0f49 3e 0f				ld a, CUR_BLINK_RATE 
0f4b 32 60 ee				ld (input_cur_flash), a 
0f4e			 
0f4e c3 44 0e				jp .is1 
0f51			 
0f51 fe 05		.isk2:		cp KEY_UP 
0f53			 
0f53 20 26				jr nz, .isk3 
0f55			 
0f55					; swap last command with the current on 
0f55			 
0f55					; move cursor to start of string 
0f55 2a 67 ee				ld hl, (input_start) 
0f58 22 69 ee				ld (input_ptr), hl 
0f5b			 
0f5b 3a 64 ee				ld a, (input_at_pos) 
0f5e 32 62 ee				ld (input_at_cursor), a 
0f61			 
0f61 3e 00				ld a, 0 
0f63 32 55 ee				ld (input_cursor), a 
0f66					 
0f66					; swap input and last command buffers 
0f66			 
0f66 21 e8 e5				ld hl, os_cli_cmd 
0f69 11 e7 e6				ld de, os_last_cmd 
0f6c 06 ff				ld b, 255 
0f6e 7e			.swap1:		ld a, (hl) 
0f6f 4f					ld c,a 
0f70 1a					ld a, (de) 
0f71 77					ld (hl), a 
0f72 79					ld a,c 
0f73 12					ld (de),a 
0f74 23					inc hl 
0f75 13					inc de 
0f76 10 f6				djnz .swap1 
0f78			 
0f78			 
0f78			 
0f78			 
0f78			 
0f78 c3 44 0e				jp .is1 
0f7b			 
0f7b fe 08		.isk3:		cp KEY_BS 
0f7d 20 3c				jr nz, .isk4 
0f7f			 
0f7f 3a 55 ee				ld a, (input_cursor) 
0f82			 
0f82 fe 00				cp 0 
0f84 ca 44 0e				jp z, .is1 		; at start of line to ignore  
0f87			 
0f87 3d					dec  a 		; TODO check underflow 
0f88 32 55 ee				ld (input_cursor), a 
0f8b			 
0f8b					; hl is source 
0f8b					; de needs to be source - 1 
0f8b			 
0f8b			;		ld a, 0 
0f8b			;		dec hl 
0f8b			;		ld (hl), a 
0f8b			 
0f8b 2a 69 ee				ld hl, (input_ptr) 
0f8e 2b					dec hl 
0f8f 22 69 ee				ld (input_ptr), hl 
0f92			 
0f92					; shift all data 
0f92			 
0f92 e5					push hl 
0f93 23					inc hl 
0f94 d1					pop de 
0f95 3a 5a ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0f98 4f					ld c,a 
0f99 06 00				ld b,0 
0f9b ed b0				ldir  
0f9d			 
0f9d			 
0f9d			 
0f9d			 
0f9d 3a 62 ee				ld a, (input_at_cursor) 
0fa0 3d					dec a 
0fa1 32 62 ee				ld (input_at_cursor), a 
0fa4			 
0fa4			 
0fa4 3e 01				ld a, 1		; show cursor moving 
0fa6 32 5f ee				ld (input_cur_onoff),a 
0fa9 3e 0f				ld a, CUR_BLINK_RATE 
0fab 32 60 ee				ld (input_cur_flash), a 
0fae			 
0fae					; remove char 
0fae 3a 62 ee				ld a, (input_at_cursor) 
0fb1 3c					inc a 
0fb2 11 3c 10				ld de,.iblank 
0fb5 cd cc 0b				call str_at_display 
0fb8			 
0fb8 c3 44 0e				jp .is1 
0fbb			 
0fbb fe 0d		.isk4:		cp KEY_CR 
0fbd 28 6c				jr z, .endinput 
0fbf			 
0fbf					; else add the key press to the end 
0fbf			 
0fbf 4f					ld c, a			; save key pressed 
0fc0			 
0fc0 7e					ld a,(hl)		; get what is currently under char 
0fc1			 
0fc1 fe 00				cp 0			; we are at the end of the string 
0fc3 20 2f				jr nz, .onchar 
0fc5					 
0fc5					; add a char to the end of the string 
0fc5				 
0fc5 71					ld (hl),c 
0fc6 23					inc hl 
0fc7			;		ld a,' ' 
0fc7			;		ld (hl),a 
0fc7			;		inc hl 
0fc7 3e 00				ld a,0 
0fc9 77					ld (hl),a 
0fca 2b					dec hl 
0fcb			 
0fcb 3a 55 ee				ld a, (input_cursor) 
0fce 3c					inc a				; TODO check max string length and scroll  
0fcf 32 55 ee				ld (input_cursor), a		; inc cursor pos 
0fd2							 
0fd2 3a 62 ee				ld a, (input_at_cursor) 
0fd5 3c					inc a 
0fd6 32 62 ee				ld (input_at_cursor), a 
0fd9			 
0fd9 2a 69 ee				ld hl, (input_ptr) 
0fdc 23					inc hl 
0fdd 22 69 ee				ld (input_ptr), hl 
0fe0			 
0fe0 2a 69 ee				ld hl, (input_ptr) 
0fe3 23					inc hl 
0fe4 22 69 ee				ld (input_ptr), hl 
0fe7			;	if DEBUG_INPUT 
0fe7			;		push af 
0fe7			;		ld a, '+' 
0fe7			;		ld (debug_mark),a 
0fe7			;		pop af 
0fe7			;		CALLMONITOR 
0fe7			;	endif 
0fe7 3e 01				ld a, 1		; show cursor moving 
0fe9 32 5f ee				ld (input_cur_onoff),a 
0fec 3e 0f				ld a, CUR_BLINK_RATE 
0fee 32 60 ee				ld (input_cur_flash), a 
0ff1 c3 44 0e				jp .is1 
0ff4					 
0ff4			 
0ff4			 
0ff4					; if on a char then insert 
0ff4			.onchar: 
0ff4			 
0ff4					; TODO over flow check: make sure insert does not blow out buffer 
0ff4			 
0ff4					; need to do some maths to use lddr 
0ff4			 
0ff4 e5					push hl   ; save char pos 
0ff5 c5					push bc 
0ff6			 
0ff6 2a 67 ee				ld hl, (input_start) 
0ff9 3a 5a ee				ld a, (input_len) 
0ffc cd e6 0d				call addatohl  		; end of string 
0fff 23					inc hl 
1000 23					inc hl		; past zero term 
1001 e5					push hl 
1002 23					inc hl 
1003 e5					push hl  
1004			 
1004								; start and end of lddr set, now how much to move? 
1004			 
1004							 
1004 3a 55 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
1007 47					ld b,a 
1008 3a 5a ee				ld a,(input_len) 
100b 5f					ld e,a 
100c 90					sub b 
100d 3c					inc a		;?? 
100e 3c					inc a		;?? 
100f 3c					inc a		;?? 
1010			 
1010 06 00				ld b,0 
1012 4f					ld c,a 
1013			 
1013				if DEBUG_INPUT 
1013					push af 
1013					ld a, 'i' 
1013					ld (debug_mark),a 
1013					pop af 
1013			;		CALLMONITOR 
1013				endif 
1013 d1					pop de 
1014 e1					pop hl 
1015				if DEBUG_INPUT 
1015					push af 
1015					ld a, 'I' 
1015					ld (debug_mark),a 
1015					pop af 
1015			;		CALLMONITOR 
1015				endif 
1015 ed b8				lddr 
1017				 
1017			 
1017			 
1017					; TODO have a key for insert/overwrite mode???? 
1017 c1					pop bc 
1018 e1					pop hl 
1019 71					ld (hl), c		; otherwise overwrite current char 
101a					 
101a			 
101a			 
101a			 
101a 3a 55 ee				ld a, (input_cursor) 
101d 3c					inc  a 		; TODO check overflow 
101e 32 55 ee				ld (input_cursor), a 
1021			 
1021 3a 62 ee				ld a, (input_at_cursor) 
1024 3c					inc a 
1025 32 62 ee				ld (input_at_cursor), a 
1028			 
1028 c3 44 0e				jp .is1 
102b			 
102b			.endinput:	; TODO look for end of string 
102b			 
102b					; add trailing space for end of token 
102b			 
102b 2a 67 ee				ld hl, (input_start) 
102e 3a 5a ee				ld a,(input_len) 
1031 cd e6 0d				call addatohl 
1034 3e 20				ld a, ' ' 
1036 77					ld (hl),a 
1037					; TODO eof of parse marker 
1037			 
1037 23					inc hl 
1038 3e 00				ld a, 0 
103a 77					ld (hl),a 
103b			 
103b			 
103b c9					ret 
103c			 
103c .. 00		.iblank: db " ",0 
103e			 
103e			 
103e 32 64 ee		input_str_prev:	ld (input_at_pos), a 
1041 22 67 ee				ld (input_start), hl 
1044 3e 01				ld a,1			; add cursor 
1046 77					ld (hl),a 
1047 23					inc hl 
1048 3e 00				ld a,0 
104a 77					ld (hl),a 
104b 22 69 ee				ld (input_ptr), hl 
104e 7a					ld a,d 
104f 32 66 ee				ld (input_size), a 
1052 3e 00				ld a,0 
1054 32 55 ee				ld (input_cursor),a 
1057			.instr1:	 
1057			 
1057					; TODO do block cursor 
1057					; TODO switch cursor depending on the modifer key 
1057			 
1057					; update cursor shape change on key hold 
1057			 
1057 2a 69 ee				ld hl, (input_ptr) 
105a 2b					dec hl 
105b 3a c1 eb				ld a,(cursor_shape) 
105e 77					ld (hl), a 
105f			 
105f					; display entered text 
105f 3a 64 ee				ld a,(input_at_pos) 
1062 cd 43 65		            	CALL fLCD_Pos       ;Position cursor to location in A 
1065 ed 5b 67 ee	            	LD   de, (input_start) 
1069 cd 38 65		            	CALL fLCD_Str       ;Display string pointed to by DE 
106c			 
106c cd 2e 66				call cin 
106f fe 00				cp 0 
1071 28 e4				jr z, .instr1 
1073			 
1073					; proecess keyboard controls first 
1073			 
1073 2a 69 ee				ld hl,(input_ptr) 
1076			 
1076 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1078 28 5a				jr z, .instrcr 
107a			 
107a fe 08				cp KEY_BS 	; back space 
107c 20 0f				jr nz, .instr2 
107e					; process back space 
107e			 
107e					; TODO stop back space if at start of string 
107e 2b					dec hl 
107f 2b					dec hl ; to over write cursor 
1080 3a c1 eb				ld a,(cursor_shape) 
1083					;ld a,0 
1083 77					ld (hl),a 
1084 23					inc hl 
1085 3e 20				ld a," " 
1087 77					ld (hl),a 
1088 22 69 ee				ld (input_ptr),hl 
108b					 
108b			 
108b 18 ca				jr .instr1 
108d			 
108d fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
108f 20 06				jr nz, .instr3 
1091 2b					dec hl 
1092 22 69 ee				ld (input_ptr),hl 
1095 18 c0				jr .instr1 
1097				 
1097 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
1099 20 06				jr nz, .instr4 
109b 23					inc hl 
109c 22 69 ee				ld (input_ptr),hl 
109f 18 b6				jr .instr1 
10a1			 
10a1 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
10a3 20 06				jr nz, .instr5 
10a5 2b					dec hl 
10a6 22 69 ee				ld (input_ptr),hl 
10a9 18 ac				jr .instr1 
10ab			 
10ab fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
10ad 20 06				jr nz, .instr6 
10af 2b					dec hl 
10b0 22 69 ee				ld (input_ptr),hl 
10b3 18 a2				jr .instr1 
10b5 fe 05		.instr6:        cp KEY_UP      ; recall last command 
10b7 20 0b				jr nz, .instrnew 
10b9			 
10b9 21 c1 e2			ld hl, scratch 
10bc 11 e7 e6			ld de, os_last_cmd 
10bf cd dd 10			call strcpy 
10c2 18 93				jr .instr1 
10c4			 
10c4			 
10c4			.instrnew:	; no special key pressed to see if we have room to store it 
10c4			 
10c4					; TODO do string size test 
10c4			 
10c4 2b					dec hl ; to over write cursor 
10c5 77					ld (hl),a 
10c6 23					inc hl 
10c7 3a c1 eb				ld a,(cursor_shape) 
10ca 77					ld (hl),a 
10cb 23					inc hl 
10cc 3e 00				ld a,0 
10ce 77					ld (hl),a 
10cf			 
10cf 22 69 ee				ld (input_ptr),hl 
10d2					 
10d2 18 83				jr .instr1 
10d4 2b			.instrcr:	dec hl		; remove cursor 
10d5 3e 20				ld a,' '	; TODO add a trailing space for safety 
10d7 77					ld (hl),a 
10d8 23					inc hl 
10d9 3e 00				ld a,0 
10db 77					ld (hl),a 
10dc			 
10dc			 
10dc					; if at end of line scroll up    
10dc					; TODO detecting only end of line 4 for scroll up  
10dc			 
10dc					;ld   
10dc			 
10dc c9					ret 
10dd			 
10dd			 
10dd			; strcpy hl = dest, de source 
10dd			 
10dd 1a			strcpy:   LD   A, (DE)        ;Get character from string 
10de b7			            OR   A              ;Null terminator? 
10df c8			            RET  Z              ;Yes, so finished 
10e0 1a					ld a,(de) 
10e1 77					ld (hl),a 
10e2 13			            INC  DE             ;Point to next character 
10e3 23					inc hl 
10e4 18 f7		            JR   strcpy       ;Repeat 
10e6 c9					ret 
10e7			 
10e7			 
10e7			; TODO string_at  
10e7			; pass string which starts with lcd offset address and then null term string 
10e7			 
10e7			; TODO string to dec 
10e7			; TODO string to hex 
10e7			; TODO byte to string hex 
10e7			; TODO byte to string dec 
10e7			 
10e7			 
10e7			 
10e7			; from z80uartmonitor 
10e7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e7			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
10e7			; pass hl for where to put the text 
10e7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e7 c5			hexout:	PUSH BC 
10e8 f5					PUSH AF 
10e9 47					LD B, A 
10ea					; Upper nybble 
10ea cb 3f				SRL A 
10ec cb 3f				SRL A 
10ee cb 3f				SRL A 
10f0 cb 3f				SRL A 
10f2 cd 02 11				CALL tohex 
10f5 77					ld (hl),a 
10f6 23					inc hl	 
10f7					 
10f7					; Lower nybble 
10f7 78					LD A, B 
10f8 e6 0f				AND 0FH 
10fa cd 02 11				CALL tohex 
10fd 77					ld (hl),a 
10fe 23					inc hl	 
10ff					 
10ff f1					POP AF 
1100 c1					POP BC 
1101 c9					RET 
1102					 
1102			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1102			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1102			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1102			tohex: 
1102 e5					PUSH HL 
1103 d5					PUSH DE 
1104 16 00				LD D, 0 
1106 5f					LD E, A 
1107 21 0f 11				LD HL, .DATA 
110a 19					ADD HL, DE 
110b 7e					LD A, (HL) 
110c d1					POP DE 
110d e1					POP HL 
110e c9					RET 
110f			 
110f			.DATA: 
110f 30					DEFB	30h	; 0 
1110 31					DEFB	31h	; 1 
1111 32					DEFB	32h	; 2 
1112 33					DEFB	33h	; 3 
1113 34					DEFB	34h	; 4 
1114 35					DEFB	35h	; 5 
1115 36					DEFB	36h	; 6 
1116 37					DEFB	37h	; 7 
1117 38					DEFB	38h	; 8 
1118 39					DEFB	39h	; 9 
1119 41					DEFB	41h	; A 
111a 42					DEFB	42h	; B 
111b 43					DEFB	43h	; C 
111c 44					DEFB	44h	; D 
111d 45					DEFB	45h	; E 
111e 46					DEFB	46h	; F 
111f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
111f			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
111f			;;    subtract $30, if result > 9 then subtract $7 more 
111f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
111f			atohex: 
111f d6 30				SUB $30 
1121 fe 0a				CP 10 
1123 f8					RET M		; If result negative it was 0-9 so we're done 
1124 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1126 c9					RET		 
1127			 
1127			 
1127			 
1127			 
1127			; Get 2 ASCII characters as hex byte from pointer in hl 
1127			 
1127			BYTERD: 
1127 16 00			LD	D,00h		;Set up 
1129 cd 31 11			CALL	HEXCON		;Get byte and convert to hex 
112c 87				ADD	A,A		;First nibble so 
112d 87				ADD	A,A		;multiply by 16 
112e 87				ADD	A,A		; 
112f 87				ADD	A,A		; 
1130 57				LD	D,A		;Save hi nibble in D 
1131			HEXCON: 
1131 7e				ld a, (hl)		;Get next chr 
1132 23				inc hl 
1133 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1135 fe 0a			CP	00Ah		;Is it 0-9 ? 
1137 38 02			JR	C,NALPHA	;If so miss next bit 
1139 d6 07			SUB	007h		;Else convert alpha 
113b			NALPHA: 
113b b2				OR	D		;Add hi nibble back 
113c c9				RET			; 
113d			 
113d			 
113d			; 
113d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
113d			; Since the routines get_byte and therefore get_nibble are called, only valid 
113d			; characters (0-9a-f) are accepted. 
113d			; 
113d			;get_word        push    af 
113d			;                call    get_byte        ; Get the upper byte 
113d			;                ld      h, a 
113d			;                call    get_byte        ; Get the lower byte 
113d			;                ld      l, a 
113d			;                pop     af 
113d			;                ret 
113d			; 
113d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
113d			; the routine get_nibble is used only valid characters are accepted - the  
113d			; input routine only accepts characters 0-9a-f. 
113d			; 
113d c5			get_byte:        push    bc              ; Save contents of B (and C) 
113e 7e					ld a,(hl) 
113f 23					inc hl 
1140 cd 65 11		                call    nibble2val      ; Get upper nibble 
1143 cb 07		                rlc     a 
1145 cb 07		                rlc     a 
1147 cb 07		                rlc     a 
1149 cb 07		                rlc     a 
114b 47			                ld      b, a            ; Save upper four bits 
114c 7e					ld a,(hl) 
114d cd 65 11		                call    nibble2val      ; Get lower nibble 
1150 b0			                or      b               ; Combine both nibbles 
1151 c1			                pop     bc              ; Restore B (and C) 
1152 c9			                ret 
1153			; 
1153			; Get a hexadecimal digit from the serial line. This routine blocks until 
1153			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1153			; to the serial line interface. The lower 4 bits of A contain the value of  
1153			; that particular digit. 
1153			; 
1153			;get_nibble      ld a,(hl)           ; Read a character 
1153			;                call    to_upper        ; Convert to upper case 
1153			;                call    is_hex          ; Was it a hex digit? 
1153			;                jr      nc, get_nibble  ; No, get another character 
1153			 ;               call    nibble2val      ; Convert nibble to value 
1153			 ;               call    print_nibble 
1153			 ;               ret 
1153			; 
1153			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1153			; A valid hexadecimal digit is denoted by a set C flag. 
1153			; 
1153			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1153			;                ret     nc              ; Yes 
1153			;                cp      '0'             ; Less than '0'? 
1153			;                jr      nc, is_hex_1    ; No, continue 
1153			;                ccf                     ; Complement carry (i.e. clear it) 
1153			;                ret 
1153			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1153			;                ret     c               ; Yes 
1153			;                cp      'A'             ; Less than 'A'? 
1153			;                jr      nc, is_hex_2    ; No, continue 
1153			;                ccf                     ; Yes - clear carry and return 
1153			;                ret 
1153			;is_hex_2        scf                     ; Set carry 
1153			;                ret 
1153			; 
1153			; Convert a single character contained in A to upper case: 
1153			; 
1153 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1155 d8			                ret     c 
1156 fe 7b		                cp      'z' + 1         ; > 'z'? 
1158 d0			                ret     nc              ; Nothing to do, either 
1159 e6 5f		                and     $5f             ; Convert to upper case 
115b c9			                ret 
115c			 
115c			 
115c			to_lower: 
115c			 
115c			   ; if char is in [A-Z] make it lower case 
115c			 
115c			   ; enter : a = char 
115c			   ; exit  : a = lower case char 
115c			   ; uses  : af 
115c			 
115c fe 41		   cp 'A' 
115e d8			   ret c 
115f			    
115f fe 5b		   cp 'Z'+1 
1161 d0			   ret nc 
1162			    
1162 f6 20		   or $20 
1164 c9			   ret 
1165			 
1165			; 
1165			; Expects a hexadecimal digit (upper case!) in A and returns the 
1165			; corresponding value in A. 
1165			; 
1165 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1167 38 02		                jr      c, nibble2val_1 ; Yes 
1169 d6 07		                sub     7               ; Adjust for A-F 
116b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
116d e6 0f		                and     $f              ; Only return lower 4 bits 
116f c9			                ret 
1170			; 
1170			; Print_nibble prints a single hex nibble which is contained in the lower  
1170			; four bits of A: 
1170			; 
1170			;print_nibble    push    af              ; We won't destroy the contents of A 
1170			;                and     $f              ; Just in case... 
1170			;                add     a, '0'             ; If we have a digit we are done here. 
1170			;                cp      '9' + 1         ; Is the result > 9? 
1170			;                jr      c, print_nibble_1 
1170			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1170			;print_nibble_1  call    putc            ; Print the nibble and 
1170			;                pop     af              ; restore the original value of A 
1170			;                ret 
1170			;; 
1170			;; Send a CR/LF pair: 
1170			; 
1170			;crlf            push    af 
1170			;                ld      a, cr 
1170			;                call    putc 
1170			;                ld      a, lf 
1170			;                call    putc 
1170			;                pop     af 
1170			;                ret 
1170			; 
1170			; Print_word prints the four hex digits of a word to the serial line. The  
1170			; word is expected to be in HL. 
1170			; 
1170			;print_word      push    hl 
1170			;                push    af 
1170			;                ld      a, h 
1170			;                call    print_byte 
1170			;                ld      a, l 
1170			;                call    print_byte 
1170			;                pop     af 
1170			;                pop     hl 
1170			;                ret 
1170			; 
1170			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1170			; The byte to be printed is expected to be in A. 
1170			; 
1170			;print_byte      push    af              ; Save the contents of the registers 
1170			;                push    bc 
1170			;                ld      b, a 
1170			;                rrca 
1170			;                rrca 
1170			;                rrca 
1170			;                rrca 
1170			;                call    print_nibble    ; Print high nibble 
1170			;                ld      a, b 
1170			;                call    print_nibble    ; Print low nibble 
1170			;                pop     bc              ; Restore original register contents 
1170			;                pop     af 
1170			;                ret 
1170			 
1170			 
1170			 
1170			 
1170			 
1170			fourehexhl:  
1170 7e				ld a,(hl) 
1171 cd 1f 11			call atohex 
1174 cb 3f				SRL A 
1176 cb 3f				SRL A 
1178 cb 3f				SRL A 
117a cb 3f				SRL A 
117c 47				ld b, a 
117d 23				inc hl 
117e 7e				ld a,(hl) 
117f 23				inc hl 
1180 cd 1f 11			call atohex 
1183 80				add b 
1184 57				ld d,a 
1185 7e				ld a,(hl) 
1186 cd 1f 11			call atohex 
1189 cb 3f				SRL A 
118b cb 3f				SRL A 
118d cb 3f				SRL A 
118f cb 3f				SRL A 
1191 47				ld b, a 
1192 23				inc hl 
1193 7e				ld a,(hl) 
1194 23				inc hl 
1195 cd 1f 11			call atohex 
1198 80				add b 
1199 5f				ld e, a 
119a d5				push de 
119b e1				pop hl 
119c c9				ret 
119d			 
119d			; pass hl. returns z set if the byte at hl is a digit 
119d			;isdigithl:  
119d			;	push bc 
119d			;	ld a,(hl) 
119d			;	cp ':' 
119d			;	jr nc, .isdf 		; > 
119d			;	cp '0' 
119d			;	jr c, .isdf		; < 
119d			; 
119d			;	; TODO find a better way to set z 
119d			; 
119d			;	ld b,a 
119d			;	cp b 
119d			;	pop bc 
119d			;	ret 
119d			; 
119d			;.isdf:	; not digit so clear z 
119d			; 
119d			;	; TODO find a better way to unset z 
119d			; 
119d			;	ld b,a 
119d			;	inc b 
119d			;	cp b 
119d			; 
119d			;	pop bc 
119d			;	ret 
119d				 
119d				 
119d			 
119d			 
119d			; pass hl as the four byte address to load 
119d			 
119d			get_word_hl:  
119d e5				push hl 
119e cd 3d 11			call get_byte 
11a1				 
11a1 47				ld b, a 
11a2			 
11a2 e1				pop hl 
11a3 23				inc hl 
11a4 23				inc hl 
11a5			 
11a5			; TODO not able to handle a-f  
11a5 7e				ld a,(hl) 
11a6			;	;cp ':' 
11a6			;	cp 'g' 
11a6			;	jr nc, .single_byte_hl 		; > 
11a6			;	cp 'G' 
11a6			;	jr nc, .single_byte_hl 		; > 
11a6			;	cp '0' 
11a6			;	jr c, .single_byte_hl		; < 
11a6			 
11a6				;call isdigithl 
11a6 fe 00			cp 0 
11a8 28 06			jr z, .single_byte_hl 
11aa			 
11aa			.getwhln:   ; hex word so get next byte 
11aa			 
11aa cd 3d 11			call get_byte 
11ad 6f				ld l, a 
11ae 60				ld h,b 
11af c9				ret 
11b0 68			.single_byte_hl:   ld l,b 
11b1 26 00				ld h,0 
11b3 c9					ret 
11b4			 
11b4			 
11b4			 
11b4			 
11b4 21 41 19			ld hl,asc+1 
11b7			;	ld a, (hl) 
11b7			;	call nibble2val 
11b7 cd 3d 11			call get_byte 
11ba			 
11ba			;	call fourehexhl 
11ba 32 f5 e2			ld (scratch+52),a 
11bd				 
11bd 21 f3 e2			ld hl,scratch+50 
11c0 22 e4 e5			ld (os_cur_ptr),hl 
11c3			 
11c3 c9				ret 
11c4			 
11c4			 
11c4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
11c4			 
11c4			; Decimal Unsigned Version 
11c4			 
11c4			;Number in a to decimal ASCII 
11c4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
11c4			;Example: display a=56 as "056" 
11c4			;input: a = number 
11c4			;Output: a=0,value of a in the screen 
11c4			;destroys af,bc (don't know about hl and de) 
11c4			DispAToASCII: 
11c4 0e 9c			ld	c,-100 
11c6 cd d0 11			call	.Na1 
11c9 0e f6			ld	c,-10 
11cb cd d0 11			call	.Na1 
11ce 0e ff			ld	c,-1 
11d0 06 2f		.Na1:	ld	b,'0'-1 
11d2 04			.Na2:	inc	b 
11d3 81				add	a,c 
11d4 38 fc			jr	c,.Na2 
11d6 91				sub	c		;works as add 100/10/1 
11d7 f5				push af		;safer than ld c,a 
11d8 78				ld	a,b		;char is in b 
11d9			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
11d9 f1				pop af		;safer than ld a,c 
11da c9				ret 
11db			 
11db			; Decimal Signed Version 
11db			 
11db			; DispA 
11db			; -------------------------------------------------------------- 
11db			; Converts a signed integer value to a zero-terminated ASCII 
11db			; string representative of that value (using radix 10). 
11db			; -------------------------------------------------------------- 
11db			; INPUTS: 
11db			;     HL     Value to convert (two's complement integer). 
11db			;     DE     Base address of string destination. (pointer). 
11db			; -------------------------------------------------------------- 
11db			; OUTPUTS: 
11db			;     None 
11db			; -------------------------------------------------------------- 
11db			; REGISTERS/MEMORY DESTROYED 
11db			; AF HL 
11db			; -------------------------------------------------------------- 
11db			 
11db			;DispHLToASCII: 
11db			;   push    de 
11db			;   push    bc 
11db			; 
11db			;; Detect sign of HL. 
11db			;    bit    7, h 
11db			;    jr     z, ._DoConvert 
11db			; 
11db			;; HL is negative. Output '-' to string and negate HL. 
11db			;    ld     a, '-' 
11db			;    ld     (de), a 
11db			;    inc    de 
11db			; 
11db			;; Negate HL (using two's complement) 
11db			;    xor    a 
11db			;    sub    l 
11db			;    ld     l, a 
11db			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
11db			;    sbc    a, h 
11db			;    ld     h, a 
11db			; 
11db			;; Convert HL to digit characters 
11db			;._DoConvert: 
11db			;    ld     b, 0     ; B will count character length of number 
11db			;-   ld     a, 10 
11db			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
11db			;    push   af 
11db			;    inc    b 
11db			;    ld     a, h 
11db			;    or     l 
11db			;    jr     nz, - 
11db			; 
11db			;; Retrieve digits from stack 
11db			;-   pop    af 
11db			;    or     $30 
11db			;    ld     (de), a 
11db			;    inc    de 
11db			;    djnz   - 
11db			; 
11db			;; Terminate string with NULL 
11db			;    xor    a 
11db			;    ld     (de), a 
11db			; 
11db			;    pop    bc 
11db			;    pop    de 
11db			;    ret 
11db			 
11db			;Comments 
11db			; 
11db			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
11db			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
11db			;    Note that the output string will not be fixed-width. 
11db			; 
11db			;Example Usage 
11db			; 
11db			;    ld    hl, -1004 
11db			;    ld    de, OP1 
11db			;    call  DispA 
11db			;    ld    hl, OP1 
11db			;    syscall  PutS 
11db			 
11db			 
11db			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11db			 
11db			 
11db			;Converts an ASCII string to an unsigned 16-bit integer 
11db			;Quits when it reaches a non-decimal digit 
11db			 
11db			string_to_uint16: 
11db			atoui_16: 
11db			;Input: 
11db			;     DE points to the string 
11db			;Outputs: 
11db			;     HL is the result 
11db			;     A is the 8-bit value of the number 
11db			;     DE points to the byte after the number 
11db			;Destroys: 
11db			;     BC 
11db			;       if the string is non-empty, BC is HL/10 
11db			;Size:  24 bytes 
11db			;Speed: 42+d(104+{0,9}) 
11db			;       d is the number of digits in the number 
11db			;       max is 640 cycles for a 5 digit number 
11db			;Assuming no leading zeros: 
11db			;1 digit:  146cc 
11db			;2 digit:  250cc 
11db			;3 digit:  354cc or 363cc (avg: 354.126cc) 
11db			;4 digit:  458cc or 467cc (avg: 458.27cc) 
11db			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
11db			;avg: 544.81158447265625cc (544+13297/16384) 
11db			;=============================================================== 
11db 21 00 00		  ld hl,0 
11de			.u16a: 
11de 1a			  ld a,(de) 
11df d6 30		  sub 30h 
11e1 fe 0a		  cp 10 
11e3 d0			  ret nc 
11e4 13			  inc de 
11e5 44			  ld b,h 
11e6 4d			  ld c,l 
11e7 29			  add hl,hl 
11e8 29			  add hl,hl 
11e9 09			  add hl,bc 
11ea 29			  add hl,hl 
11eb 85			  add a,l 
11ec 6f			  ld l,a 
11ed 30 ef		  jr nc,.u16a 
11ef 24			  inc h 
11f0 c3 de 11		  jp .u16a 
11f3			 
11f3			 
11f3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11f3			 
11f3			;written by Zeda 
11f3			;Converts a 16-bit unsigned integer to an ASCII string. 
11f3			 
11f3			uitoa_16: 
11f3			;Input: 
11f3			;   DE is the number to convert 
11f3			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
11f3			;Output: 
11f3			;   HL points to the null-terminated ASCII string 
11f3			;      NOTE: This isn't necessarily the same as the input HL. 
11f3 d5			  push de 
11f4 c5			  push bc 
11f5 f5			  push af 
11f6 eb			  ex de,hl 
11f7			 
11f7 01 f0 d8		  ld bc,-10000 
11fa 3e 2f		  ld a,'0'-1 
11fc 3c			  inc a 
11fd 09			  add hl,bc  
11fe 38 fc		   jr c,$-2 
1200 12			  ld (de),a 
1201 13			  inc de 
1202			 
1202 01 e8 03		  ld bc,1000 
1205 3e 3a		  ld a,'9'+1 
1207 3d			  dec a  
1208 09			  add hl,bc  
1209 30 fc		   jr nc,$-2 
120b 12			  ld (de),a 
120c 13			  inc de 
120d			 
120d 01 9c ff		  ld bc,-100 
1210 3e 2f		  ld a,'0'-1 
1212 3c			  inc a  
1213 09			  add hl,bc  
1214 38 fc		   jr c,$-2 
1216 12			  ld (de),a 
1217 13			  inc de 
1218			 
1218 7d			  ld a,l 
1219 26 3a		  ld h,'9'+1 
121b 25			  dec h  
121c c6 0a		  add a,10  
121e 30 fb		   jr nc,$-3 
1220 c6 30		  add a,'0' 
1222 eb			  ex de,hl 
1223 72			  ld (hl),d 
1224 23			  inc hl 
1225 77			  ld (hl),a 
1226 23			  inc hl 
1227 36 00		  ld (hl),0 
1229			 
1229			;Now strip the leading zeros 
1229 0e fa		  ld c,-6 
122b 09			  add hl,bc 
122c 3e 30		  ld a,'0' 
122e 23			  inc hl  
122f be			  cp (hl)  
1230 28 fc		  jr z,$-2 
1232			 
1232			;Make sure that the string is non-empty! 
1232 7e			  ld a,(hl) 
1233 b7			  or a 
1234 20 01		  jr nz,.atoub 
1236 2b			  dec hl 
1237			.atoub: 
1237			 
1237 f1			  pop af 
1238 c1			  pop bc 
1239 d1			  pop de 
123a c9			  ret 
123b			 
123b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
123b			 
123b			toUpper: 
123b			;A is the char. 
123b			;If A is a lowercase letter, this sets it to the matching uppercase 
123b			;18cc or 30cc or 41cc 
123b			;avg: 26.75cc 
123b fe 61		  cp 'a' 
123d d8			  ret c 
123e fe 7b		  cp 'z'+1 
1240 d0			  ret nc 
1241 d6 20		  sub 'a'-'A' 
1243 c9			  ret 
1244			 
1244			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1244			 
1244			; String Length 
1244			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1244			 
1244			; Get the length of the null-terminated string starting at $8000 hl 
1244			;    LD     HL, $8000 
1244			 
1244			strlenz: 
1244			 
1244 af			    XOR    A               ; Zero is the value we are looking for. 
1245 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1246 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1247			                           ; 65, 536 bytes (the entire addressable memory space). 
1247 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1249			 
1249			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1249 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
124a 6f			    LD     L, A             ; number of bytes 
124b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
124d 2b			    DEC    HL              ; Compensate for null. 
124e c9				ret 
124f			 
124f			; Get the length of the A terminated string starting at $8000 hl 
124f			;    LD     HL, $8000 
124f			 
124f			strlent: 
124f			 
124f			                  ; A is the value we are looking for. 
124f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1251 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1253			                           ; 65, 536 bytes (the entire addressable memory space). 
1253 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1255			 
1255			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1255 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1257 2e 00		    LD     L, 0             ; number of bytes 
1259 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
125b 2b			    DEC    HL              ; Compensate for null. 
125c c9				ret 
125d			 
125d			 
125d			;Comparing Strings 
125d			 
125d			;IN    HL     Address of string1. 
125d			;      DE     Address of string2. 
125d			 
125d			; doc given but wrong??? 
125d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
125d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
125d			; tested 
125d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
125d			 
125d			strcmp_old: 
125d e5			    PUSH   HL 
125e d5			    PUSH   DE 
125f			 
125f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1260 be			    CP     (HL)            ; (want to minimize work). 
1261 38 01		    JR     C, Str1IsBigger 
1263 7e			    LD     A, (HL) 
1264			 
1264			Str1IsBigger: 
1264 4f			    LD     C, A             ; Put length in BC 
1265 06 00		    LD     B, 0 
1267 13			    INC    DE              ; Increment pointers to meat of string. 
1268 23			    INC    HL 
1269			 
1269			CmpLoop: 
1269 1a			    LD     A, (DE)          ; Compare bytes. 
126a ed a1		    CPI 
126c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
126e 13			    INC    DE              ; Update pointer. 
126f ea 69 12		    JP     PE, CmpLoop 
1272			 
1272 d1			    POP    DE 
1273 e1			    POP    HL 
1274 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1275 be			    CP     (HL) 
1276 c9			    RET 
1277			 
1277			NoMatch: 
1277 2b			    DEC    HL 
1278 be			    CP     (HL)            ; Compare again to affect carry. 
1279 d1			    POP    DE 
127a e1			    POP    HL 
127b c9			    RET 
127c			 
127c			;; test strmp 
127c			; 
127c			;ld de, .str1 
127c			;ld hl, .str2 
127c			;call strcmp 
127c			;jr z, .z1 
127c			;;this 
127c			;	if DEBUG_FORTH_WORDS 
127c			;		DMARK "NZ1" 
127c			;		CALLMONITOR 
127c			;	endif 
127c			;.z1: 
127c			; 
127c			;	if DEBUG_FORTH_WORDS 
127c			;		DMARK "ZZ1" 
127c			;		CALLMONITOR 
127c			;	endif 
127c			; 
127c			;ld de, .str1 
127c			;ld hl, .str1 
127c			;call strcmp 
127c			;jr z, .z2 
127c			;;this 
127c			;	if DEBUG_FORTH_WORDS 
127c			;		DMARK "NZ2" 
127c			;		CALLMONITOR 
127c			;	endif 
127c			;.z2: 
127c			; 
127c			;	if DEBUG_FORTH_WORDS 
127c			;		DMARK "ZZ2" 
127c			;		CALLMONITOR 
127c			;	endif 
127c			; 
127c			;ld de, .str1 
127c			;ld hl, .str2 
127c			;call strcmp 
127c			;jr c, .c1 
127c			; 
127c			;	if DEBUG_FORTH_WORDS 
127c			;		DMARK "Nc1" 
127c			;		CALLMONITOR 
127c			;	endif 
127c			;.c1: 
127c			;;this 
127c			;	if DEBUG_FORTH_WORDS 
127c			;		DMARK "cc1" 
127c			;		CALLMONITOR 
127c			;	endif 
127c			; 
127c			;ld de, .str1 
127c			;ld hl, .str1 
127c			;call strcmp 
127c			;jr c, .c2 
127c			;;this 
127c			;	if DEBUG_FORTH_WORDS 
127c			;		DMARK "Nc2" 
127c			;		CALLMONITOR 
127c			;	endif 
127c			;.c2: 
127c			; 
127c			;	if DEBUG_FORTH_WORDS 
127c			;		DMARK "cc2" 
127c			;		CALLMONITOR 
127c			;	endif 
127c			;	NEXTW 
127c			;.str1:   db "string1",0 
127c			;.str2:   db "string2",0 
127c			 
127c			; only care about direct match or not 
127c			; hl and de strings 
127c			; zero set if the same 
127c			 
127c			strcmp: 
127c 1a				ld a, (de) 
127d be				cp (hl) 
127e 28 02			jr z, .ssame 
1280 b7				or a 
1281 c9				ret 
1282			 
1282			.ssame:  
1282 fe 00			cp 0 
1284 c8				ret z 
1285			 
1285 23				inc hl 
1286 13				inc de 
1287 18 f3			jr strcmp 
1289				 
1289				 
1289			 
1289			;Copyright (c) 2014, Luke Maurits 
1289			;All rights reserved. 
1289			; 
1289			;Redistribution and use in source and binary forms, with or without 
1289			;modification, are permitted provided that the following conditions are met: 
1289			; 
1289			;* Redistributions of source code must retain the above copyright notice, this 
1289			;  list of conditions and the following disclaimer. 
1289			; 
1289			;* Redistributions in binary form must reproduce the above copyright notice, 
1289			;  this list of conditions and the following disclaimer in the documentation 
1289			;  and/or other materials provided with the distribution. 
1289			; 
1289			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
1289			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
1289			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
1289			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
1289			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
1289			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
1289			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
1289			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
1289			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
1289			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
1289			 
1289			; https://github.com/lmaurits/lm512/blob/master/string.z80 
1289			 
1289			StrictStrCmp: 
1289				; Load next chars of each string 
1289 1a				ld a, (de) 
128a 47				ld b, a 
128b 7e				ld a, (hl) 
128c				; Compare 
128c b8				cp b 
128d				; Return non-zero if chars don't match 
128d c0				ret nz 
128e				; Check for end of both strings 
128e fe 00			cp "\0" 
1290				; Return if strings have ended 
1290 c8				ret z 
1291				; Otherwise, advance to next chars 
1291 23				inc hl 
1292 13				inc de 
1293 18 f4			jr StrictStrCmp 
1295			 
1295			;end 
1295			; eof 
1295			 
1295			 
1295			 
1295			 
1295			 
1295			 
# End of file firmware_strings.asm
1295			include "firmware_memory.asm"   ; malloc and free  
1295			 
1295			if DEBUG_FORTH_MALLOC_HIGH 
1295			.mallocsize: db "Wants malloc >256",0 
1295			.mallocasize: db "MALLOC gives >256",0 
1295			.malloczero: db "MALLOC gives zero",0 
1295			 
1295			malloc_guard_zerolen: 
1295				push hl 
1295				push de 
1295				push af 
1295			 
1295				ld de, 0 
1295			        call cmp16 
1295				jr nz, .lowalloz 
1295			 
1295				push hl 
1295				push de 
1295					ld hl, display_fb0 
1295					ld (display_fb_active), hl 
1295				call clear_display 
1295				ld a, 0 
1295				ld de, .malloczero 
1295				call str_at_display 
1295				call update_display 
1295				call delay1s 
1295				call delay1s 
1295				call bp_on 
1295			;	ld a, 0 
1295			;	ld (os_view_disable), a 
1295			 
1295				pop de 
1295				pop hl 
1295			 
1295				 
1295			 
1295				CALLMONITOR 
1295			.lowalloz: 
1295			 
1295			 
1295				pop af 
1295				pop de 
1295				pop hl 
1295			ret 
1295			 
1295			malloc_guard_entry: 
1295				push hl 
1295				push de 
1295				push af 
1295			 
1295			 	or a      ;clear carry flag 
1295				push hl 
1295				ld de, 255 
1295				sbc hl, de 
1295				jr c, .lowalloc 
1295			 
1295				push de 
1295					ld hl, display_fb0 
1295					ld (display_fb_active), hl 
1295				call clear_display 
1295				ld a, 0 
1295				ld de, .mallocsize 
1295				call str_at_display 
1295				call update_display 
1295				call delay1s 
1295				call delay1s 
1295			;	ld a, 0 
1295			;	ld (os_view_disable), a 
1295				call bp_on 
1295			 
1295				pop de 
1295				pop hl 
1295			 
1295				 
1295			 
1295				CALLMONITOR 
1295				jr .lowdone 
1295			.lowalloc: 
1295			 
1295			 
1295				pop hl 
1295			.lowdone:	pop af 
1295				pop de 
1295				pop hl 
1295			ret 
1295			 
1295			malloc_guard_exit: 
1295				push hl 
1295				push de 
1295				push af 
1295			 
1295			 	or a      ;clear carry flag 
1295				push hl 
1295				ld de, 255 
1295				sbc hl, de 
1295				jr c, .lowallocx 
1295			 
1295				push de 
1295					ld hl, display_fb0 
1295					ld (display_fb_active), hl 
1295				call clear_display 
1295				ld a, 0 
1295				ld de, .mallocasize 
1295				call str_at_display 
1295				call update_display 
1295				call delay1s 
1295				call delay1s 
1295			;	ld a, 0 
1295			;	ld (os_view_disable), a 
1295				call bp_on 
1295				pop de 
1295				pop hl 
1295			 
1295				CALLMONITOR 
1295				jr .lowdonex 
1295			.lowallocx: 
1295			 
1295				pop hl 
1295			.lowdonex:	pop af 
1295				pop de 
1295				pop hl 
1295			ret 
1295			endif 
1295			 
1295			if MALLOC_2 
1295			; Z80 Malloc and Free Functions 
1295			 
1295			; Malloc Function: 
1295			; Input: 
1295			;   HL: Size of block to allocate 
1295			; Output: 
1295			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1295			 
1295			malloc: 
1295				 
1295			if DEBUG_FORTH_MALLOC_HIGH 
1295			call malloc_guard_entry 
1295			endif 
1295			 
1295			 
1295			 
1295			 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "mal" 
1295						CALLMONITOR 
1295					endif 
1295			    push af            ; Save AF register 
1295			    ld a, l            ; Load low byte of size into A 
1295			    or h               ; Check if size is zero 
1295			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1295			 
1295			    ; Allocate memory 
1295			    ld hl, (heap_start) ; Load start of heap into HL 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "ma1" 
1295						CALLMONITOR 
1295					endif 
1295			    call malloc_internal ; Call internal malloc function 
1295			    pop af             ; Restore AF register 
1295			if DEBUG_FORTH_MALLOC_HIGH 
1295			call malloc_guard_exit 
1295			call malloc_guard_zerolen 
1295			endif 
1295			    ret                ; Return 
1295			 
1295			; Free Function: 
1295			; Input: 
1295			;   HL: Pointer to memory block to free 
1295			; Output: 
1295			;   None 
1295			 
1295			free: 
1295			    push af            ; Save AF register 
1295			    ld a, l            ; Load low byte of pointer into A 
1295			    or h               ; Check if pointer is NULL 
1295			    jp z, free_exit    ; If pointer is NULL, exit 
1295			 
1295			    ; Free memory 
1295			    ld hl, (heap_start) ; Load start of heap into HL 
1295			    call free_internal  ; Call internal free function 
1295			    pop af             ; Restore AF register 
1295			    ret                ; Return 
1295			 
1295			; Internal Malloc Function: 
1295			; Input: 
1295			;   HL: Size of block to allocate 
1295			; Output: 
1295			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1295			 
1295			malloc_internal: 
1295			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1295			    add hl, bc         ; Add management overhead to requested size 
1295			    ex de, hl          ; Save total size in DE, and keep it in HL 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "ma2" 
1295						CALLMONITOR 
1295					endif 
1295			 
1295			    ; Search for free memory block 
1295			    ld de, (heap_end)  ; Load end of heap into DE 
1295			    ld bc, 0           ; Initialize counter 
1295			 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "ma2" 
1295						CALLMONITOR 
1295					endif 
1295			malloc_search_loop: 
1295			    ; Check if current block is free 
1295			    ld a, (hl)         ; Load current block's status (free or used) 
1295			    cp 0               ; Compare with zero (free) 
1295			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1295			 
1295			    ; Check if current block is large enough 
1295			    ld a, (hl+1)       ; Load high byte of block size 
1295			    cp l               ; Compare with low byte of requested size 
1295			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1295			 
1295			    ld a, (hl+2)       ; Load low byte of block size 
1295			    cp h               ; Compare with high byte of requested size 
1295			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1295			 
1295			    ; Mark block as used 
1295			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1295			 
1295			    ; Calculate remaining space in block 
1295			    ld bc, 0           ; Clear BC 
1295			    add hl, bc         ; Increment HL to point to start of data block 
1295			    add hl, de         ; HL = HL + DE (total size) 
1295			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1295			    add hl, bc         ; Add management overhead to start of data block 
1295			 
1295			    ; Save pointer to allocated block in HL 
1295			if DEBUG_FORTH_MALLOC_HIGH 
1295						DMARK "ma5" 
1295			call malloc_guard_exit 
1295			call malloc_guard_zerolen 
1295			endif 
1295			    ret 
1295			 
1295			malloc_skip_block_check: 
1295			    ; Move to the next block 
1295			    ld bc, 3           ; Size of management overhead 
1295			    add hl, bc         ; Move to the next block 
1295			    inc de             ; Increment counter 
1295			 
1295			    ; Check if we have reached the end of heap 
1295			    ld a, e            ; Load low byte of heap end address 
1295			    cp (hl)            ; Compare with low byte of current address 
1295			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1295			    ld a, d            ; Load high byte of heap end address 
1295			    cp 0               ; Check if it's zero (end of memory) 
1295			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1295			 
1295			    ; If we reached here, allocation failed 
1295			    xor a              ; Set result to NULL 
1295			if DEBUG_FORTH_MALLOC_HIGH 
1295						DMARK "ma6" 
1295			call malloc_guard_exit 
1295			call malloc_guard_zerolen 
1295			endif 
1295			    ret 
1295			malloc_exit: 
1295			if DEBUG_FORTH_MALLOC_HIGH 
1295						DMARK "ma7" 
1295			call malloc_guard_exit 
1295			call malloc_guard_zerolen 
1295			endif 
1295			    ret 
1295			 
1295			; Internal Free Function: 
1295			; Input: 
1295			;   HL: Pointer to memory block to free 
1295			; Output: 
1295			;   None 
1295			 
1295			free_internal: 
1295			    ld de, (heap_start) ; Load start of heap into DE 
1295			    ld bc, 0            ; Initialize counter 
1295			 
1295			free_search_loop: 
1295			    ; Check if current block contains the pointer 
1295			    ld a, l             ; Load low byte of pointer 
1295			    cp (hl+1)           ; Compare with high byte of current block's address 
1295			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1295			    ld a, h             ; Load high byte of pointer 
1295			    cp (hl+2)           ; Compare with low byte of current block's address 
1295			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1295			 
1295			    ; Mark block as free 
1295			    ld (hl), 0          ; Set status byte to indicate free block 
1295			    ret                 ; Return 
1295			 
1295			free_skip_block_check: 
1295			    ; Move to the next block 
1295			    ld bc, 3            ; Size of management overhead 
1295			    add hl, bc          ; Move to the next block 
1295			    inc de              ; Increment counter 
1295			 
1295			    ; Check if we have reached the end of heap 
1295			    ld a, e             ; Load low byte of heap end address 
1295			    cp (hl)             ; Compare with low byte of current address 
1295			    jr nz, free_search_loop  ; If not equal, continue searching 
1295			    ld a, d             ; Load high byte of heap end address 
1295			    cp 0                ; Check if it's zero (end of memory) 
1295			    jr nz, free_search_loop  ; If not zero, continue searching 
1295			 
1295			    ; If we reached here, pointer is not found in heap 
1295			    ret 
1295			 
1295			free_exit: 
1295			    ret                 ; Return 
1295			 
1295			; Define heap start and end addresses 
1295			;heap_start:    .dw 0xC000   ; Start of heap 
1295			;heap_end:      .dw 0xE000   ; End of heap 
1295			 
1295			endif 
1295			 
1295			 
1295			if MALLOC_1 
1295			 
1295			 
1295			 
1295			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1295			 
1295			;moved to firmware.asm 
1295			;heap_start        .equ  0x9000      ; Starting address of heap 
1295			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1295			 
1295			;      .org 0 
1295			;      jp    main 
1295			 
1295			 
1295			;      .org  0x100 
1295			;main: 
1295			;      ld    HL, 0x8100 
1295			;      ld    SP, HL 
1295			; 
1295			;      call  heap_init 
1295			; 
1295			;      ; Make some allocations 
1295			;      ld    HL, 12 
1295			;      call  malloc            ; Allocates 0x9004 
1295			; 
1295			;      ld    HL, 12 
1295			;      call  malloc            ; Allocates 0x9014 
1295			; 
1295			;      ld    HL, 12 
1295			;      call  malloc            ; Allocates 0x9024 
1295			; 
1295			;      ; Free some allocations 
1295			;      ld    HL, 0x9014 
1295			;      call  free 
1295			; 
1295			;      ld    HL, 0x9004 
1295			;      call  free 
1295			; 
1295			;      ld    HL, 0x9024 
1295			;      call  free 
1295			; 
1295			; 
1295			;      halt 
1295			 
1295			 
1295			;------------------------------------------------------------------------------ 
1295			;     heap_init                                                               : 
1295			;                                                                             : 
1295			; Description                                                                 : 
1295			;     Initialise the heap and make it ready for malloc and free operations.   : 
1295			;                                                                             : 
1295			;     The heap is maintained as a linked list, starting with an initial       : 
1295			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1295			;     the first free block in the heap. Each block then points to the next    : 
1295			;     free block within the heap, and the free list ends at the first block   : 
1295			;     with a null pointer to the next free block.                             : 
1295			;                                                                             : 
1295			; Parameters                                                                  : 
1295			;     Inputs are compile-time only. Two defines which specify the starting    : 
1295			;     address of the heap and its size are required, along with a memory      : 
1295			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1295			;     principally stores a pointer to the first free block in the heap.       : 
1295			;                                                                             : 
1295			; Returns                                                                     : 
1295			;     Nothing                                                                 : 
1295			;------------------------------------------------------------------------------ 
1295			heap_init: 
1295 e5			      push  HL 
1296			 
1296			      ; Initialise free list struct 
1296 21 56 66		      ld    HL, heap_start 
1299 22 51 66		      ld    (free_list), HL 
129c 21 00 00		      ld    HL, 0 
129f 22 53 66		      ld    (free_list+2), HL 
12a2			 
12a2			      ; Insert first free block at bottom of heap, consumes entire heap 
12a2 21 98 e2		      ld    HL, heap_start+heap_size-4 
12a5 22 56 66		      ld    (heap_start), HL        ; Next block (end of free list) 
12a8 21 42 7c		      ld    HL, heap_size-4 
12ab 22 58 66		      ld    (heap_start+2), HL      ; Block size 
12ae			 
12ae			      ; Insert end of free list block at top of heap - two null words will 
12ae			      ; terminate the free list 
12ae 21 00 00		      ld    HL, 0 
12b1 22 9a e2		      ld    (heap_start+heap_size-2), HL 
12b4 22 98 e2		      ld    (heap_start+heap_size-4), HL 
12b7			 
12b7 e1			      pop   HL 
12b8			 
12b8 c9			      ret 
12b9			 
12b9			 
12b9			;------------------------------------------------------------------------------ 
12b9			;     malloc                                                                  : 
12b9			;                                                                             : 
12b9			; Description                                                                 : 
12b9			;     Allocates the wanted space from the heap and returns the address of the : 
12b9			;     first useable byte of the allocation.                                   : 
12b9			;                                                                             : 
12b9			;     Allocations can happen in one of two ways:                              : 
12b9			;                                                                             : 
12b9			;     1. A free block may be found which is the exact size wanted. In this    : 
12b9			;        case the block is removed from the free list and retuedn to the      : 
12b9			;        caller.                                                              : 
12b9			;     2. A free block may be found which is larger than the size wanted. In   : 
12b9			;        this case, the larger block is split into two. The first portion of  : 
12b9			;        this block will become the requested space by the malloc call and    : 
12b9			;        is returned to the caller. The second portion becomes a new free     : 
12b9			;        block, and the free list is adjusted to maintain continuity via this : 
12b9			;        newly created block.                                                 : 
12b9			;                                                                             : 
12b9			;     malloc does not set any initial value in the allocated space, the       : 
12b9			;     caller is required to do this as required.                              : 
12b9			;                                                                             : 
12b9			;     This implementation of malloc uses the stack exclusively, and is        : 
12b9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12b9			;     advisable to disable interrupts before calling malloc, and recommended  : 
12b9			;     to avoid the use of malloc inside ISRs in general.                      : 
12b9			;                                                                             : 
12b9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12b9			;                                                                             : 
12b9			; Parameters                                                                  : 
12b9			;     HL  Number of bytes wanted                                              : 
12b9			;                                                                             : 
12b9			; Returns                                                                     : 
12b9			;     HL  Address of the first useable byte of the allocation                 : 
12b9			;                                                                             : 
12b9			; Flags                                                                       : 
12b9			;     Z   Set if the allocation did not succeed, clear otherwise              : 
12b9			;                                                                             : 
12b9			; Stack frame                                                                 : 
12b9			;       |             |                                                       : 
12b9			;       +-------------+                                                       : 
12b9			;       |     BC      |                                                       : 
12b9			;       +-------------+                                                       : 
12b9			;       |     DE      |                                                       : 
12b9			;       +-------------+                                                       : 
12b9			;       |     IX      |                                                       : 
12b9			;       +-------------+                                                       : 
12b9			;       |  prev_free  |                                                       : 
12b9			;   +4  +-------------+                                                       : 
12b9			;       |  this_free  |                                                       : 
12b9			;   +2  +-------------+                                                       : 
12b9			;       |  next_free  |                                                       : 
12b9			;   +0  +-------------+                                                       : 
12b9			;       |             |                                                       : 
12b9			;                                                                             : 
12b9			;------------------------------------------------------------------------------ 
12b9			 
12b9			 
12b9			;malloc: 
12b9			; 
12b9			;	SAVESP ON 1 
12b9			; 
12b9			;	call malloc_code 
12b9			; 
12b9			;	CHECKSP ON 1 
12b9			;	ret 
12b9			 
12b9			 
12b9			malloc: 
12b9 c5			      push  BC 
12ba d5			      push  DE 
12bb dd e5		      push  IX 
12bd			if DEBUG_FORTH_MALLOC_HIGH 
12bd			call malloc_guard_entry 
12bd			endif 
12bd			 
12bd					if DEBUG_FORTH_MALLOC 
12bd						DMARK "mal" 
12bd						CALLMONITOR 
12bd					endif 
12bd 7c			      ld    A, H                    ; Exit if no space requested 
12be b5			      or    L 
12bf ca 7e 13		      jp    Z, malloc_early_exit 
12c2			 
12c2			;inc hl 
12c2			;inc hl 
12c2			;inc hl 
12c2			; 
12c2			;inc hl 
12c2			;inc hl 
12c2			;inc hl 
12c2			;inc hl 
12c2			;inc hl 
12c2			;inc hl 
12c2			;inc hl 
12c2			;inc hl 
12c2			;inc hl 
12c2			 
12c2			 
12c2			 
12c2			 
12c2					if DEBUG_FORTH_MALLOC 
12c2						DMARK "maA" 
12c2						CALLMONITOR 
12c2					endif 
12c2			      ; Set up stack frame 
12c2 eb			      ex    DE, HL 
12c3 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
12c6 39			      add   HL, SP 
12c7 f9			      ld    SP, HL 
12c8 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12cc dd 39		      add   IX, SP 
12ce			 
12ce			      ; Setup initial state 
12ce 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
12d1 19			      add   HL, DE 
12d2			 
12d2 44			      ld    B, H                    ; Move want to BC 
12d3 4d			      ld    C, L 
12d4			 
12d4 21 51 66		      ld    HL, free_list           ; Store prev_free ptr to stack 
12d7 dd 75 04		      ld    (IX+4), L 
12da dd 74 05		      ld    (IX+5), H 
12dd			 
12dd 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
12de 23			      inc   HL 
12df 56			      ld    D, (HL) 
12e0 dd 73 02		      ld    (IX+2), E 
12e3 dd 72 03		      ld    (IX+3), D 
12e6 eb			      ex    DE, HL                  ; this_free ptr into HL 
12e7			 
12e7					if DEBUG_FORTH_MALLOC 
12e7						DMARK "maB" 
12e7						CALLMONITOR 
12e7					endif 
12e7			      ; Loop through free block list to find some space 
12e7			malloc_find_space: 
12e7 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
12e8 23			      inc   HL 
12e9 56			      ld    D, (HL) 
12ea			 
12ea 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12eb b3			      or    E 
12ec ca 78 13		      jp    Z, malloc_no_space 
12ef			 
12ef dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
12f2 dd 72 01		      ld    (IX+1), D 
12f5			 
12f5			      ; Does this block have enough space to make the allocation? 
12f5 23			      inc   HL                      ; Load free block size into DE 
12f6 5e			      ld    E, (HL) 
12f7 23			      inc   HL 
12f8 56			      ld    D, (HL) 
12f9			 
12f9 eb			      ex    DE, HL                  ; Check size of block against want 
12fa b7			      or    A                       ; Ensure carry flag clear 
12fb ed 42		      sbc   HL, BC 
12fd e5			      push  HL                      ; Store the result for later (new block size) 
12fe			 
12fe ca 4d 13		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1301 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1303			 
1303			      ; this_free block is not big enough, setup ptrs to test next free block 
1303 e1			      pop   HL                      ; Discard previous result 
1304			 
1304 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1307 dd 66 03		      ld    H, (IX+3) 
130a dd 75 04		      ld    (IX+4), L 
130d dd 74 05		      ld    (IX+5), H 
1310			 
1310 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1313 dd 66 01		      ld    H, (IX+1) 
1316 dd 75 02		      ld    (IX+2), L 
1319 dd 74 03		      ld    (IX+3), H 
131c			 
131c					if DEBUG_FORTH_MALLOC 
131c						DMARK "MA>" 
131c						CALLMONITOR 
131c					endif 
131c 18 c9		      jr    malloc_find_space 
131e			 
131e			      ; split a bigger block into two - requested size and remaining size 
131e			malloc_alloc_split: 
131e					if DEBUG_FORTH_MALLOC 
131e						DMARK "MAs" 
131e						CALLMONITOR 
131e					endif 
131e eb			      ex    DE, HL                  ; Calculate address of new free block 
131f 2b			      dec   HL 
1320 2b			      dec   HL 
1321 2b			      dec   HL 
1322 09			      add   HL, BC 
1323			 
1323			      ; Create a new block and point it at next_free 
1323 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1326 dd 56 01		      ld    D, (IX+1) 
1329			 
1329 73			      ld    (HL), E                 ; Store next_free ptr into new block 
132a 23			      inc   HL 
132b 72			      ld    (HL), D 
132c			 
132c d1			      pop   DE                      ; Store size of new block into new block 
132d 23			      inc   HL 
132e 73			      ld    (HL), E 
132f 23			      inc   HL 
1330 72			      ld    (HL), D 
1331			 
1331			      ; Update this_free ptr to point to new block 
1331 2b			      dec   HL 
1332 2b			      dec   HL 
1333 2b			      dec   HL 
1334			 
1334 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1337 dd 56 03		      ld    D, (IX+3) 
133a			 
133a dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
133d dd 74 03		      ld    (IX+3), H 
1340			 
1340			      ; Modify this_free block to be allocation 
1340 eb			      ex    DE, HL 
1341 af			      xor   A                       ; Null the next block ptr of allocated block 
1342 77			      ld    (HL), A 
1343 23			      inc   HL 
1344 77			      ld    (HL), A 
1345			 
1345 23			      inc   HL                      ; Store want size into allocated block 
1346 71			      ld    (HL), C 
1347 23			      inc   HL 
1348 70			      ld    (HL), B 
1349 23			      inc   HL 
134a e5			      push  HL                      ; Address of allocation to return 
134b			 
134b 18 19		      jr    malloc_update_links 
134d			 
134d			malloc_alloc_fit: 
134d e1			      pop   HL                      ; Dont need new block size, want is exact fit 
134e			 
134e					if DEBUG_FORTH_MALLOC 
134e						DMARK "MAf" 
134e						CALLMONITOR 
134e					endif 
134e			      ; Modify this_free block to be allocation 
134e eb			      ex    DE, HL 
134f 2b			      dec   HL 
1350 2b			      dec   HL 
1351 2b			      dec   HL 
1352			 
1352 af			      xor   A                       ; Null the next block ptr of allocated block 
1353 77			      ld    (HL), A 
1354 23			      inc   HL 
1355 77			      ld    (HL), A 
1356			 
1356 23			      inc   HL                      ; Store address of allocation to return 
1357 23			      inc   HL 
1358 23			      inc   HL 
1359 e5			      push  HL 
135a			 
135a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
135a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
135d dd 66 01		      ld    H, (IX+1) 
1360			 
1360 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1363 dd 74 03		      ld    (IX+3), H 
1366			 
1366			 
1366			malloc_update_links: 
1366			      ; Update prev_free ptr to point to this_free 
1366 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1369 dd 66 05		      ld    H, (IX+5) 
136c			 
136c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
136f dd 56 03		      ld    D, (IX+3) 
1372			 
1372 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1373 23			      inc   HL 
1374 72			      ld    (HL), D 
1375			 
1375					if DEBUG_FORTH_MALLOC 
1375						DMARK "Mul" 
1375						CALLMONITOR 
1375					endif 
1375			      ; Clear the Z flag to indicate successful allocation 
1375 7a			      ld    A, D 
1376 b3			      or    E 
1377			 
1377 d1			      pop   DE                      ; Address of allocation 
1378					if DEBUG_FORTH_MALLOC 
1378						DMARK "MAu" 
1378						CALLMONITOR 
1378					endif 
1378			 
1378			malloc_no_space: 
1378 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
137b 39			      add   HL, SP 
137c f9			      ld    SP, HL 
137d			 
137d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
137e					if DEBUG_FORTH_MALLOC 
137e						DMARK "MAN" 
137e						CALLMONITOR 
137e					endif 
137e			 
137e			malloc_early_exit: 
137e					if DEBUG_FORTH_MALLOC 
137e						DMARK "MAx" 
137e						CALLMONITOR 
137e					endif 
137e dd e1		      pop   IX 
1380 d1			      pop   DE 
1381 c1			      pop   BC 
1382			 
1382			if DEBUG_FORTH_MALLOC_HIGH 
1382			call malloc_guard_exit 
1382			call malloc_guard_zerolen 
1382			endif 
1382 c9			      ret 
1383			 
1383			 
1383			;------------------------------------------------------------------------------ 
1383			;     free                                                                    : 
1383			;                                                                             : 
1383			; Description                                                                 : 
1383			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1383			;     returned by malloc, otherwise the behaviour is undefined.               : 
1383			;                                                                             : 
1383			;     Where possible, directly adjacent free blocks will be merged together   : 
1383			;     into larger blocks to help ensure that the heap does not become         : 
1383			;     excessively fragmented.                                                 : 
1383			;                                                                             : 
1383			;     free does not clear or set any other value into the freed space, and    : 
1383			;     therefore its contents may be visible through subsequent malloc's. The  : 
1383			;     caller should clear the freed space as required.                        : 
1383			;                                                                             : 
1383			;     This implementation of free uses the stack exclusively, and is          : 
1383			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1383			;     advisable to disable interrupts before calling free, and recommended    : 
1383			;     to avoid the use of free inside ISRs in general.                        : 
1383			;                                                                             : 
1383			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1383			;                                                                             : 
1383			; Parameters                                                                  : 
1383			;     HL  Pointer to address of first byte of allocation to be freed          : 
1383			;                                                                             : 
1383			; Returns                                                                     : 
1383			;     Nothing                                                                 : 
1383			;                                                                             : 
1383			; Stack frame                                                                 : 
1383			;       |             |                                                       : 
1383			;       +-------------+                                                       : 
1383			;       |     BC      |                                                       : 
1383			;       +-------------+                                                       : 
1383			;       |     DE      |                                                       : 
1383			;       +-------------+                                                       : 
1383			;       |     IX      |                                                       : 
1383			;       +-------------+                                                       : 
1383			;       |  prev_free  |                                                       : 
1383			;   +2  +-------------+                                                       : 
1383			;       |  next_free  |                                                       : 
1383			;   +0  +-------------+                                                       : 
1383			;       |             |                                                       : 
1383			;                                                                             : 
1383			;------------------------------------------------------------------------------ 
1383			free: 
1383 c5			      push  BC 
1384 d5			      push  DE 
1385 dd e5		      push  IX 
1387			 
1387 7c			      ld    A, H                    ; Exit if ptr is null 
1388 b5			      or    L 
1389 ca 4d 14		      jp    Z, free_early_exit 
138c			 
138c			      ; Set up stack frame 
138c eb			      ex    DE, HL 
138d 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1390 39			      add   HL, SP 
1391 f9			      ld    SP, HL 
1392 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1396 dd 39		      add   IX, SP 
1398			 
1398			      ; The address in HL points to the start of the useable allocated space, 
1398			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1398			      ; address of the block itself. 
1398 eb			      ex    DE, HL 
1399 11 fc ff		      ld    DE, -4 
139c 19			      add   HL, DE 
139d			 
139d			      ; An allocated block must have a null next block pointer in it 
139d 7e			      ld    A, (HL) 
139e 23			      inc   HL 
139f b6			      or    (HL) 
13a0 c2 48 14		      jp    NZ, free_done 
13a3			 
13a3 2b			      dec   HL 
13a4			 
13a4 44			      ld    B, H                    ; Copy HL to BC 
13a5 4d			      ld    C, L 
13a6			 
13a6			      ; Loop through the free list to find the first block with an address 
13a6			      ; higher than the block being freed 
13a6 21 51 66		      ld    HL, free_list 
13a9			 
13a9			free_find_higher_block: 
13a9 5e			      ld    E, (HL)                 ; Load next ptr from free block 
13aa 23			      inc   HL 
13ab 56			      ld    D, (HL) 
13ac 2b			      dec   HL 
13ad			 
13ad dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
13b0 dd 72 01		      ld    (IX+1), D 
13b3 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
13b6 dd 74 03		      ld    (IX+3), H 
13b9			 
13b9 78			      ld    A, B                    ; Check if DE is greater than BC 
13ba ba			      cp    D                       ; Compare MSB first 
13bb 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
13bd 30 04		      jr    NC, free_find_higher_block_skip 
13bf 79			      ld    A, C 
13c0 bb			      cp    E                       ; Then compare LSB 
13c1 38 08		      jr    C, free_found_higher_block 
13c3			 
13c3			free_find_higher_block_skip: 
13c3 7a			      ld    A, D                    ; Reached the end of the free list? 
13c4 b3			      or    E 
13c5 ca 48 14		      jp    Z, free_done 
13c8			 
13c8 eb			      ex    DE, HL 
13c9			 
13c9 18 de		      jr    free_find_higher_block 
13cb			 
13cb			free_found_higher_block: 
13cb			      ; Insert freed block between prev and next free blocks 
13cb 71			      ld    (HL), C                 ; Point prev free block to freed block 
13cc 23			      inc   HL 
13cd 70			      ld    (HL), B 
13ce			 
13ce 60			      ld    H, B                    ; Point freed block at next free block 
13cf 69			      ld    L, C 
13d0 73			      ld    (HL), E 
13d1 23			      inc   HL 
13d2 72			      ld    (HL), D 
13d3			 
13d3			      ; Check if the freed block is adjacent to the next free block 
13d3 23			      inc   HL                      ; Load size of freed block into HL 
13d4 5e			      ld    E, (HL) 
13d5 23			      inc   HL 
13d6 56			      ld    D, (HL) 
13d7 eb			      ex    DE, HL 
13d8			 
13d8 09			      add   HL, BC                  ; Add addr of freed block and its size 
13d9			 
13d9 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
13dc dd 56 01		      ld    D, (IX+1) 
13df			 
13df b7			      or    A                       ; Clear the carry flag 
13e0 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
13e2 20 22		      jr    NZ, free_check_adjacent_to_prev 
13e4			 
13e4			      ; Freed block is adjacent to next, merge into one bigger block 
13e4 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
13e5 5e			      ld    E, (HL) 
13e6 23			      inc   HL 
13e7 56			      ld    D, (HL) 
13e8 e5			      push  HL                      ; Save ptr to next block for later 
13e9			 
13e9 60			      ld    H, B                    ; Store ptr from next block into freed block 
13ea 69			      ld    L, C 
13eb 73			      ld    (HL), E 
13ec 23			      inc   HL 
13ed 72			      ld    (HL), D 
13ee			 
13ee e1			      pop   HL                      ; Restore ptr to next block 
13ef 23			      inc   HL                      ; Load size of next block into DE 
13f0 5e			      ld    E, (HL) 
13f1 23			      inc   HL 
13f2 56			      ld    D, (HL) 
13f3 d5			      push  DE                      ; Save next block size for later 
13f4			 
13f4 60			      ld    H, B                    ; Load size of freed block into HL 
13f5 69			      ld    L, C 
13f6 23			      inc   HL 
13f7 23			      inc   HL 
13f8 5e			      ld    E, (HL) 
13f9 23			      inc   HL 
13fa 56			      ld    D, (HL) 
13fb eb			      ex    DE, HL 
13fc			 
13fc d1			      pop   DE                      ; Restore size of next block 
13fd 19			      add   HL, DE                  ; Add sizes of both blocks 
13fe eb			      ex    DE, HL 
13ff			 
13ff 60			      ld    H, B                    ; Store new bigger size into freed block 
1400 69			      ld    L, C 
1401 23			      inc   HL 
1402 23			      inc   HL 
1403 73			      ld    (HL), E 
1404 23			      inc   HL 
1405 72			      ld    (HL), D 
1406			 
1406			free_check_adjacent_to_prev: 
1406			      ; Check if the freed block is adjacent to the prev free block 
1406 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1409 dd 66 03		      ld    H, (IX+3) 
140c			 
140c 23			      inc   HL                      ; Size of prev free block into DE 
140d 23			      inc   HL 
140e 5e			      ld    E, (HL) 
140f 23			      inc   HL 
1410 56			      ld    D, (HL) 
1411 2b			      dec   HL 
1412 2b			      dec   HL 
1413 2b			      dec   HL 
1414			 
1414 19			      add   HL, DE                  ; Add prev block addr and size 
1415			 
1415 b7			      or    A                       ; Clear the carry flag 
1416 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1418 20 2e		      jr    NZ, free_done 
141a			 
141a			      ; Freed block is adjacent to prev, merge into one bigger block 
141a 60			      ld    H, B                    ; Load next ptr from freed block into DE 
141b 69			      ld    L, C 
141c 5e			      ld    E, (HL) 
141d 23			      inc   HL 
141e 56			      ld    D, (HL) 
141f e5			      push  HL                      ; Save freed block ptr for later 
1420			 
1420 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1423 dd 66 03		      ld    H, (IX+3) 
1426 73			      ld    (HL), E 
1427 23			      inc   HL 
1428 72			      ld    (HL), D 
1429			 
1429 e1			      pop   HL                      ; Restore freed block ptr 
142a 23			      inc   HL                      ; Load size of freed block into DE 
142b 5e			      ld    E, (HL) 
142c 23			      inc   HL 
142d 56			      ld    D, (HL) 
142e d5			      push  DE                      ; Save freed block size for later 
142f			 
142f dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1432 dd 66 03		      ld    H, (IX+3) 
1435 23			      inc   HL 
1436 23			      inc   HL 
1437 5e			      ld    E, (HL) 
1438 23			      inc   HL 
1439 56			      ld    D, (HL) 
143a			 
143a e1			      pop   HL                      ; Add sizes of both blocks 
143b 19			      add   HL, DE 
143c eb			      ex    DE, HL 
143d			 
143d dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1440 dd 66 03		      ld    H, (IX+3) 
1443 23			      inc   HL 
1444 23			      inc   HL 
1445 73			      ld    (HL), E 
1446 23			      inc   HL 
1447 72			      ld    (HL), D 
1448			 
1448			free_done: 
1448 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
144b 39			      add   HL, SP 
144c f9			      ld    SP, HL 
144d			 
144d			free_early_exit: 
144d dd e1		      pop   IX 
144f d1			      pop   DE 
1450 c1			      pop   BC 
1451			 
1451 c9			      ret 
1452			 
1452			; moved to firmware.asm 
1452			; 
1452			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1452			;                  .dw   0 
1452			 
1452			 
1452			endif 
1452			 
1452			 
1452			if MALLOC_3 
1452			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1452			;heap_start        .equ  0x9000      ; Starting address of heap 
1452			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1452			; 
1452			 ;     .org 0 
1452			  ;    jp    main 
1452			; 
1452			; 
1452			 ;     .org  0x100 
1452			;main: 
1452			 ;     ld    HL, 0x8100 
1452			  ;    ld    SP, HL 
1452			; 
1452			;      call  heap_init 
1452			 
1452			      ; Make some allocations 
1452			;      ld    HL, 12 
1452			;      call  malloc            ; Allocates 0x9004 
1452			; 
1452			 ;     ld    HL, 12 
1452			;      call  malloc            ; Allocates 0x9014 
1452			 
1452			;      ld    HL, 12 
1452			;      call  malloc            ; Allocates 0x9024 
1452			 
1452			      ; Free some allocations 
1452			;      ld    HL, 0x9014 
1452			;      call  free 
1452			 
1452			;      ld    HL, 0x9004 
1452			;      call  free 
1452			; 
1452			;      ld    HL, 0x9024 
1452			;      call  free 
1452			 
1452			 
1452			 ;     halt 
1452			 
1452			 
1452			;------------------------------------------------------------------------------ 
1452			;     heap_init                                                               : 
1452			;                                                                             : 
1452			; Description                                                                 : 
1452			;     Initialise the heap and make it ready for malloc and free operations.   : 
1452			;                                                                             : 
1452			;     The heap is maintained as a linked list, starting with an initial       : 
1452			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1452			;     the first free block in the heap. Each block then points to the next    : 
1452			;     free block within the heap, and the free list ends at the first block   : 
1452			;     with a null pointer to the next free block.                             : 
1452			;                                                                             : 
1452			; Parameters                                                                  : 
1452			;     Inputs are compile-time only. Two defines which specify the starting    : 
1452			;     address of the heap and its size are required, along with a memory      : 
1452			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1452			;     principally stores a pointer to the first free block in the heap.       : 
1452			;                                                                             : 
1452			; Returns                                                                     : 
1452			;     Nothing                                                                 : 
1452			;------------------------------------------------------------------------------ 
1452			heap_init: 
1452			      push  HL 
1452			 
1452			      ; Initialise free list struct 
1452			      ld    HL, heap_start 
1452			      ld    (free_list), HL 
1452			      ld    HL, 0 
1452			      ld    (free_list+2), HL 
1452			 
1452			      ; Insert first free block at bottom of heap, consumes entire heap 
1452			      ld    HL, heap_start+heap_size-4 
1452			      ld    (heap_start), HL        ; Next block (end of free list) 
1452			      ld    HL, heap_size-4 
1452			      ld    (heap_start+2), HL      ; Block size 
1452			 
1452			      ; Insert end of free list block at top of heap - two null words will 
1452			      ; terminate the free list 
1452			      ld    HL, 0 
1452			      ld    (heap_start+heap_size-2), HL 
1452			      ld    (heap_start+heap_size-4), HL 
1452			 
1452			      pop   HL 
1452			 
1452			      ret 
1452			 
1452			 
1452			;------------------------------------------------------------------------------ 
1452			;     malloc                                                                  : 
1452			;                                                                             : 
1452			; Description                                                                 : 
1452			;     Allocates the wanted space from the heap and returns the address of the : 
1452			;     first useable byte of the allocation.                                   : 
1452			;                                                                             : 
1452			;     Allocations can happen in one of two ways:                              : 
1452			;                                                                             : 
1452			;     1. A free block may be found which is the exact size wanted. In this    : 
1452			;        case the block is removed from the free list and retuedn to the      : 
1452			;        caller.                                                              : 
1452			;     2. A free block may be found which is larger than the size wanted. In   : 
1452			;        this case, the larger block is split into two. The first portion of  : 
1452			;        this block will become the requested space by the malloc call and    : 
1452			;        is returned to the caller. The second portion becomes a new free     : 
1452			;        block, and the free list is adjusted to maintain continuity via this : 
1452			;        newly created block.                                                 : 
1452			;                                                                             : 
1452			;     malloc does not set any initial value in the allocated space, the       : 
1452			;     caller is required to do this as required.                              : 
1452			;                                                                             : 
1452			;     This implementation of malloc uses the stack exclusively, and is        : 
1452			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1452			;     advisable to disable interrupts before calling malloc, and recommended  : 
1452			;     to avoid the use of malloc inside ISRs in general.                      : 
1452			;                                                                             : 
1452			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1452			;                                                                             : 
1452			; Parameters                                                                  : 
1452			;     HL  Number of bytes wanted                                              : 
1452			;                                                                             : 
1452			; Returns                                                                     : 
1452			;     HL  Address of the first useable byte of the allocation                 : 
1452			;                                                                             : 
1452			; Flags                                                                       : 
1452			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1452			;                                                                             : 
1452			; Stack frame                                                                 : 
1452			;       |             |                                                       : 
1452			;       +-------------+                                                       : 
1452			;       |     BC      |                                                       : 
1452			;       +-------------+                                                       : 
1452			;       |     DE      |                                                       : 
1452			;       +-------------+                                                       : 
1452			;       |     IX      |                                                       : 
1452			;       +-------------+                                                       : 
1452			;       |  prev_free  |                                                       : 
1452			;   +4  +-------------+                                                       : 
1452			;       |  this_free  |                                                       : 
1452			;   +2  +-------------+                                                       : 
1452			;       |  next_free  |                                                       : 
1452			;   +0  +-------------+                                                       : 
1452			;       |             |                                                       : 
1452			;                                                                             : 
1452			;------------------------------------------------------------------------------ 
1452			malloc: 
1452			      push  BC 
1452			      push  DE 
1452			      push  IX 
1452			 
1452			      ld    A, H                    ; Exit if no space requested 
1452			      or    L 
1452			      jp    Z, malloc_early_exit 
1452			 
1452			      ; Set up stack frame 
1452			      ex    DE, HL 
1452			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1452			      add   HL, SP 
1452			      ld    SP, HL 
1452			      ld    IX, 0                   ; Use IX as a frame pointer 
1452			      add   IX, SP 
1452			 
1452			      ; Setup initial state 
1452			      ld    HL, 4                   ; want must also include space used by block struct 
1452			      add   HL, DE 
1452			 
1452			      ld    B, H                    ; Move want to BC 
1452			      ld    C, L 
1452			 
1452			      ld    HL, free_list           ; Store prev_free ptr to stack 
1452			      ld    (IX+4), L 
1452			      ld    (IX+5), H 
1452			 
1452			      ld    E, (HL)                 ; Store this_free ptr to stack 
1452			      inc   HL 
1452			      ld    D, (HL) 
1452			      ld    (IX+2), E 
1452			      ld    (IX+3), D 
1452			      ex    DE, HL                  ; this_free ptr into HL 
1452			 
1452			      ; Loop through free block list to find some space 
1452			malloc_find_space: 
1452			      ld    E, (HL)                 ; Load next_free ptr into DE 
1452			      inc   HL 
1452			      ld    D, (HL) 
1452			 
1452			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1452			      or    E 
1452			      jp    Z, malloc_no_space 
1452			 
1452			      ld    (IX+0), E               ; Store next_free ptr to stack 
1452			      ld    (IX+1), D 
1452			 
1452			      ; Does this block have enough space to make the allocation? 
1452			      inc   HL                      ; Load free block size into DE 
1452			      ld    E, (HL) 
1452			      inc   HL 
1452			      ld    D, (HL) 
1452			 
1452			      ex    DE, HL                  ; Check size of block against want 
1452			      or    A                       ; Ensure carry flag clear 
1452			      sbc   HL, BC 
1452			      push  HL                      ; Store the result for later (new block size) 
1452			 
1452			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1452			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1452			 
1452			      ; this_free block is not big enough, setup ptrs to test next free block 
1452			      pop   HL                      ; Discard previous result 
1452			 
1452			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1452			      ld    H, (IX+3) 
1452			      ld    (IX+4), L 
1452			      ld    (IX+5), H 
1452			 
1452			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1452			      ld    H, (IX+1) 
1452			      ld    (IX+2), L 
1452			      ld    (IX+3), H 
1452			 
1452			      jr    malloc_find_space 
1452			 
1452			      ; split a bigger block into two - requested size and remaining size 
1452			malloc_alloc_split: 
1452			      ex    DE, HL                  ; Calculate address of new free block 
1452			      dec   HL 
1452			      dec   HL 
1452			      dec   HL 
1452			      add   HL, BC 
1452			 
1452			      ; Create a new block and point it at next_free 
1452			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1452			      ld    D, (IX+1) 
1452			 
1452			      ld    (HL), E                 ; Store next_free ptr into new block 
1452			      inc   HL 
1452			      ld    (HL), D 
1452			 
1452			      pop   DE                      ; Store size of new block into new block 
1452			      inc   HL 
1452			      ld    (HL), E 
1452			      inc   HL 
1452			      ld    (HL), D 
1452			 
1452			      ; Update this_free ptr to point to new block 
1452			      dec   HL 
1452			      dec   HL 
1452			      dec   HL 
1452			 
1452			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1452			      ld    D, (IX+3) 
1452			 
1452			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1452			      ld    (IX+3), H 
1452			 
1452			      ; Modify this_free block to be allocation 
1452			      ex    DE, HL 
1452			      xor   A                       ; Null the next block ptr of allocated block 
1452			      ld    (HL), A 
1452			      inc   HL 
1452			      ld    (HL), A 
1452			 
1452			      inc   HL                      ; Store want size into allocated block 
1452			      ld    (HL), C 
1452			      inc   HL 
1452			      ld    (HL), B 
1452			      inc   HL 
1452			      push  HL                      ; Address of allocation to return 
1452			 
1452			      jr    malloc_update_links 
1452			 
1452			malloc_alloc_fit: 
1452			      pop   HL                      ; Dont need new block size, want is exact fit 
1452			 
1452			      ; Modify this_free block to be allocation 
1452			      ex    DE, HL 
1452			      dec   HL 
1452			      dec   HL 
1452			      dec   HL 
1452			 
1452			      xor   A                       ; Null the next block ptr of allocated block 
1452			      ld    (HL), A 
1452			      inc   HL 
1452			      ld    (HL), A 
1452			 
1452			      inc   HL                      ; Store address of allocation to return 
1452			      inc   HL 
1452			      inc   HL 
1452			      push  HL 
1452			 
1452			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1452			      ld    L, (IX+0)               ; next_free to HL 
1452			      ld    H, (IX+1) 
1452			 
1452			      ld    (IX+2), L               ; HL to this_free 
1452			      ld    (IX+3), H 
1452			 
1452			 
1452			malloc_update_links: 
1452			      ; Update prev_free ptr to point to this_free 
1452			      ld    L, (IX+4)               ; prev_free ptr to HL 
1452			      ld    H, (IX+5) 
1452			 
1452			      ld    E, (IX+2)               ; this_free ptr to DE 
1452			      ld    D, (IX+3) 
1452			 
1452			      ld    (HL), E                 ; this_free ptr into prev_free 
1452			      inc   HL 
1452			      ld    (HL), D 
1452			 
1452			      ; Clear the Z flag to indicate successful allocation 
1452			      ld    A, D 
1452			      or    E 
1452			 
1452			      pop   DE                      ; Address of allocation 
1452			 
1452			malloc_no_space: 
1452			      ld    HL, 6                   ; Clean up stack frame 
1452			      add   HL, SP 
1452			      ld    SP, HL 
1452			 
1452			      ex    DE, HL                  ; Alloc addr into HL for return 
1452			 
1452			malloc_early_exit: 
1452			      pop   IX 
1452			      pop   DE 
1452			      pop   BC 
1452			 
1452			      ret 
1452			 
1452			 
1452			;------------------------------------------------------------------------------ 
1452			;     free                                                                    : 
1452			;                                                                             : 
1452			; Description                                                                 : 
1452			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1452			;     returned by malloc, otherwise the behaviour is undefined.               : 
1452			;                                                                             : 
1452			;     Where possible, directly adjacent free blocks will be merged together   : 
1452			;     into larger blocks to help ensure that the heap does not become         : 
1452			;     excessively fragmented.                                                 : 
1452			;                                                                             : 
1452			;     free does not clear or set any other value into the freed space, and    : 
1452			;     therefore its contents may be visible through subsequent malloc's. The  : 
1452			;     caller should clear the freed space as required.                        : 
1452			;                                                                             : 
1452			;     This implementation of free uses the stack exclusively, and is          : 
1452			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1452			;     advisable to disable interrupts before calling free, and recommended    : 
1452			;     to avoid the use of free inside ISRs in general.                        : 
1452			;                                                                             : 
1452			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1452			;                                                                             : 
1452			; Parameters                                                                  : 
1452			;     HL  Pointer to address of first byte of allocation to be freed          : 
1452			;                                                                             : 
1452			; Returns                                                                     : 
1452			;     Nothing                                                                 : 
1452			;                                                                             : 
1452			; Stack frame                                                                 : 
1452			;       |             |                                                       : 
1452			;       +-------------+                                                       : 
1452			;       |     BC      |                                                       : 
1452			;       +-------------+                                                       : 
1452			;       |     DE      |                                                       : 
1452			;       +-------------+                                                       : 
1452			;       |     IX      |                                                       : 
1452			;       +-------------+                                                       : 
1452			;       |  prev_free  |                                                       : 
1452			;   +2  +-------------+                                                       : 
1452			;       |  next_free  |                                                       : 
1452			;   +0  +-------------+                                                       : 
1452			;       |             |                                                       : 
1452			;                                                                             : 
1452			;------------------------------------------------------------------------------ 
1452			free: 
1452			      push  BC 
1452			      push  DE 
1452			      push  IX 
1452			 
1452			      ld    A, H                    ; Exit if ptr is null 
1452			      or    L 
1452			      jp    Z, free_early_exit 
1452			 
1452			      ; Set up stack frame 
1452			      ex    DE, HL 
1452			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1452			      add   HL, SP 
1452			      ld    SP, HL 
1452			      ld    IX, 0                   ; Use IX as a frame pointer 
1452			      add   IX, SP 
1452			 
1452			      ; The address in HL points to the start of the useable allocated space, 
1452			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1452			      ; address of the block itself. 
1452			      ex    DE, HL 
1452			      ld    DE, -4 
1452			      add   HL, DE 
1452			 
1452			      ; An allocated block must have a null next block pointer in it 
1452			      ld    A, (HL) 
1452			      inc   HL 
1452			      or    (HL) 
1452			      jp    NZ, free_done 
1452			 
1452			      dec   HL 
1452			 
1452			      ld    B, H                    ; Copy HL to BC 
1452			      ld    C, L 
1452			 
1452			      ; Loop through the free list to find the first block with an address 
1452			      ; higher than the block being freed 
1452			      ld    HL, free_list 
1452			 
1452			free_find_higher_block: 
1452			      ld    E, (HL)                 ; Load next ptr from free block 
1452			      inc   HL 
1452			      ld    D, (HL) 
1452			      dec   HL 
1452			 
1452			      ld    (IX+0), E               ; Save ptr to next free block 
1452			      ld    (IX+1), D 
1452			      ld    (IX+2), L               ; Save ptr to prev free block 
1452			      ld    (IX+3), H 
1452			 
1452			      ld    A, B                    ; Check if DE is greater than BC 
1452			      cp    D                       ; Compare MSB first 
1452			      jr    Z, $+4                  ; MSB the same, compare LSB 
1452			      jr    NC, free_find_higher_block_skip 
1452			      ld    A, C 
1452			      cp    E                       ; Then compare LSB 
1452			      jr    C, free_found_higher_block 
1452			 
1452			free_find_higher_block_skip: 
1452			      ld    A, D                    ; Reached the end of the free list? 
1452			      or    E 
1452			      jp    Z, free_done 
1452			 
1452			      ex    DE, HL 
1452			 
1452			      jr    free_find_higher_block 
1452			 
1452			free_found_higher_block: 
1452			      ; Insert freed block between prev and next free blocks 
1452			      ld    (HL), C                 ; Point prev free block to freed block 
1452			      inc   HL 
1452			      ld    (HL), B 
1452			 
1452			      ld    H, B                    ; Point freed block at next free block 
1452			      ld    L, C 
1452			      ld    (HL), E 
1452			      inc   HL 
1452			      ld    (HL), D 
1452			 
1452			      ; Check if the freed block is adjacent to the next free block 
1452			      inc   HL                      ; Load size of freed block into HL 
1452			      ld    E, (HL) 
1452			      inc   HL 
1452			      ld    D, (HL) 
1452			      ex    DE, HL 
1452			 
1452			      add   HL, BC                  ; Add addr of freed block and its size 
1452			 
1452			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1452			      ld    D, (IX+1) 
1452			 
1452			      or    A                       ; Clear the carry flag 
1452			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1452			      jr    NZ, free_check_adjacent_to_prev 
1452			 
1452			      ; Freed block is adjacent to next, merge into one bigger block 
1452			      ex    DE, HL                  ; Load next ptr from next block into DE 
1452			      ld    E, (HL) 
1452			      inc   HL 
1452			      ld    D, (HL) 
1452			      push  HL                      ; Save ptr to next block for later 
1452			 
1452			      ld    H, B                    ; Store ptr from next block into freed block 
1452			      ld    L, C 
1452			      ld    (HL), E 
1452			      inc   HL 
1452			      ld    (HL), D 
1452			 
1452			      pop   HL                      ; Restore ptr to next block 
1452			      inc   HL                      ; Load size of next block into DE 
1452			      ld    E, (HL) 
1452			      inc   HL 
1452			      ld    D, (HL) 
1452			      push  DE                      ; Save next block size for later 
1452			 
1452			      ld    H, B                    ; Load size of freed block into HL 
1452			      ld    L, C 
1452			      inc   HL 
1452			      inc   HL 
1452			      ld    E, (HL) 
1452			      inc   HL 
1452			      ld    D, (HL) 
1452			      ex    DE, HL 
1452			 
1452			      pop   DE                      ; Restore size of next block 
1452			      add   HL, DE                  ; Add sizes of both blocks 
1452			      ex    DE, HL 
1452			 
1452			      ld    H, B                    ; Store new bigger size into freed block 
1452			      ld    L, C 
1452			      inc   HL 
1452			      inc   HL 
1452			      ld    (HL), E 
1452			      inc   HL 
1452			      ld    (HL), D 
1452			 
1452			free_check_adjacent_to_prev: 
1452			      ; Check if the freed block is adjacent to the prev free block 
1452			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1452			      ld    H, (IX+3) 
1452			 
1452			      inc   HL                      ; Size of prev free block into DE 
1452			      inc   HL 
1452			      ld    E, (HL) 
1452			      inc   HL 
1452			      ld    D, (HL) 
1452			      dec   HL 
1452			      dec   HL 
1452			      dec   HL 
1452			 
1452			      add   HL, DE                  ; Add prev block addr and size 
1452			 
1452			      or    A                       ; Clear the carry flag 
1452			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1452			      jr    NZ, free_done 
1452			 
1452			      ; Freed block is adjacent to prev, merge into one bigger block 
1452			      ld    H, B                    ; Load next ptr from freed block into DE 
1452			      ld    L, C 
1452			      ld    E, (HL) 
1452			      inc   HL 
1452			      ld    D, (HL) 
1452			      push  HL                      ; Save freed block ptr for later 
1452			 
1452			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1452			      ld    H, (IX+3) 
1452			      ld    (HL), E 
1452			      inc   HL 
1452			      ld    (HL), D 
1452			 
1452			      pop   HL                      ; Restore freed block ptr 
1452			      inc   HL                      ; Load size of freed block into DE 
1452			      ld    E, (HL) 
1452			      inc   HL 
1452			      ld    D, (HL) 
1452			      push  DE                      ; Save freed block size for later 
1452			 
1452			      ld    L, (IX+2)               ; Load size of prev block into DE 
1452			      ld    H, (IX+3) 
1452			      inc   HL 
1452			      inc   HL 
1452			      ld    E, (HL) 
1452			      inc   HL 
1452			      ld    D, (HL) 
1452			 
1452			      pop   HL                      ; Add sizes of both blocks 
1452			      add   HL, DE 
1452			      ex    DE, HL 
1452			 
1452			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1452			      ld    H, (IX+3) 
1452			      inc   HL 
1452			      inc   HL 
1452			      ld    (HL), E 
1452			      inc   HL 
1452			      ld    (HL), D 
1452			 
1452			free_done: 
1452			      ld    HL, 4                   ; Clean up stack frame 
1452			      add   HL, SP 
1452			      ld    SP, HL 
1452			 
1452			free_early_exit: 
1452			      pop   IX 
1452			      pop   DE 
1452			      pop   BC 
1452			 
1452			      ret 
1452			 
1452			 
1452			;      .org 0x8000 
1452			; 
1452			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1452			 ;                 .dw   0 
1452			 
1452			endif 
1452			 
1452			 
1452			if MALLOC_4 
1452			 
1452			; My memory allocation code. Very very simple.... 
1452			; allocate space under 250 chars 
1452			 
1452			heap_init: 
1452				; init start of heap as zero 
1452				;  
1452			 
1452				ld hl, heap_start 
1452				ld a, 0 
1452				ld (hl), a      ; empty block 
1452				inc hl 
1452				ld a, 0 
1452				ld (hl), a      ; length of block 
1452				; write end of list 
1452				inc hl 
1452				ld a,(hl) 
1452				inc hl 
1452				ld a,(hl) 
1452				 
1452			 
1452				; init some malloc vars 
1452			 
1452				ld hl, 0 
1452				ld (free_list), hl       ; store last malloc location 
1452			 
1452				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1452				ld a, 0 
1452				ld (hl), a 
1452			 
1452			 
1452				ld hl, heap_start 
1452				;  
1452				  
1452				ret 
1452			 
1452			 
1452			;    free block marker 
1452			;    requested size  
1452			;    pointer to next block 
1452			;    .... 
1452			;    next block marker 
1452			 
1452			 
1452			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1452			; 
1452			 
1452			 
1452			malloc:  
1452				push de 
1452				push bc 
1452				push af 
1452			 
1452				; hl space required 
1452				 
1452				ld c, l    ; hold space   (TODO only a max of 255) 
1452			 
1452			;	inc c     ; TODO BUG need to fix memory leak on push str 
1452			;	inc c 
1452			;	inc c 
1452			;	inc c 
1452			;	inc c 
1452			;	inc c 
1452			;	inc c 
1452			 
1452			 
1452			 
1452				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1452			 
1452				ld a, (free_list+3) 
1452				cp 0 
1452				jr z, .contheap 
1452			 
1452				ld hl, (free_list)     ; get last alloc 
1452					if DEBUG_FORTH_MALLOC_INT 
1452						DMARK "mrs" 
1452						CALLMONITOR 
1452					endif 
1452				jr .startalloc 
1452			 
1452			.contheap: 
1452				ld hl, heap_start 
1452			 
1452			.startalloc: 
1452			 
1452					if DEBUG_FORTH_MALLOC_INT 
1452						DMARK "mym" 
1452						CALLMONITOR 
1452					endif 
1452			.findblock: 
1452					if DEBUG_FORTH_MALLOC_INT 
1452						DMARK "mmf" 
1452						CALLMONITOR 
1452					endif 
1452			 
1452				ld a,(hl)  
1452				; if byte is zero then clear to use 
1452			 
1452				cp 0 
1452				jr z, .foundemptyblock 
1452			 
1452				; if byte is not clear 
1452				;     then byte is offset to next block 
1452			 
1452				inc hl 
1452				ld a, (hl) ; get size 
1452			.nextblock:	inc hl 
1452					ld e, (hl) 
1452					inc hl 
1452					ld d, (hl) 
1452					ex de, hl 
1452			;	inc hl  ; move past the store space 
1452			;	inc hl  ; move past zero index  
1452			 
1452				; TODO detect no more space 
1452			 
1452				push hl 
1452				ld de, heap_end 
1452				call cmp16 
1452				pop hl 
1452				jr nc, .nospace 
1452			 
1452				jr .findblock 
1452			 
1452			.nospace: ld hl, 0 
1452				jp .exit 
1452			 
1452			 
1452			.foundemptyblock:	 
1452					if DEBUG_FORTH_MALLOC_INT 
1452						DMARK "mme" 
1452						CALLMONITOR 
1452					endif 
1452			 
1452			; TODO has block enough space if reusing??? 
1452			 
1452				;  
1452			 
1452			; see if this block has been previously used 
1452				inc hl 
1452				ld a, (hl) 
1452				dec hl 
1452				cp 0 
1452				jr z, .newblock 
1452			 
1452					if DEBUG_FORTH_MALLOC_INT 
1452						DMARK "meR" 
1452						CALLMONITOR 
1452					endif 
1452			 
1452			; no reusing previously allocated block 
1452			 
1452			; is it smaller than previously used? 
1452				 
1452				inc hl    ; move to size 
1452				ld a, c 
1452				sub (hl)        ; we want c < (hl) 
1452				dec hl    ; move back to marker 
1452			        jr z, .findblock 
1452			 
1452				; update with the new size which should be lower 
1452			 
1452			        ;inc  hl   ; negate next move. move back to size  
1452			 
1452			.newblock: 
1452				; need to be at marker here 
1452			 
1452					if DEBUG_FORTH_MALLOC_INT 
1452						DMARK "meN" 
1452						CALLMONITOR 
1452					endif 
1452			 
1452			 
1452				ld a, c 
1452			 
1452				ld (free_list+3), a	 ; flag resume from last malloc  
1452				ld (free_list), hl    ; save out last location 
1452			 
1452			 
1452				;inc a     ; space for length byte 
1452				ld (hl), a     ; save block in use marker 
1452			 
1452				inc hl   ; move to space marker 
1452				ld (hl), a    ; save new space 
1452			 
1452				inc hl   ; move to start of allocated area 
1452				 
1452			;	push hl     ; save where we are - 1  
1452			 
1452			;	inc hl  ; move past zero index  
1452				; skip space to set down new marker 
1452			 
1452				; provide some extra space for now 
1452			 
1452				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1452				inc a 
1452				inc a 
1452			 
1452				push hl   ; save where we are in the node block 
1452			 
1452				call addatohl 
1452			 
1452				; write linked list point 
1452			 
1452				pop de     ; get our node position 
1452				ex de, hl 
1452			 
1452				ld (hl), e 
1452				inc hl 
1452				ld (hl), d 
1452			 
1452				inc hl 
1452			 
1452				; now at start of allocated data so save pointer 
1452			 
1452				push hl 
1452			 
1452				; jump to position of next node and setup empty header in DE 
1452			 
1452				ex de, hl 
1452			 
1452			;	inc hl ; move past end of block 
1452			 
1452				ld a, 0 
1452				ld (hl), a   ; empty marker 
1452				inc hl 
1452				ld (hl), a   ; size 
1452				inc hl  
1452				ld (hl), a   ; ptr 
1452				inc hl 
1452				ld (hl), a   ; ptr 
1452			 
1452			 
1452				pop hl 
1452			 
1452					if DEBUG_FORTH_MALLOC_INT 
1452						DMARK "mmr" 
1452						CALLMONITOR 
1452					endif 
1452			 
1452			.exit: 
1452				pop af 
1452				pop bc 
1452				pop de  
1452				ret 
1452			 
1452			 
1452			 
1452			 
1452			free:  
1452				push hl 
1452				push af 
1452				; get address in hl 
1452			 
1452					if DEBUG_FORTH_MALLOC_INT 
1452						DMARK "fre" 
1452						CALLMONITOR 
1452					endif 
1452				; data is at hl - move to block count 
1452				dec hl 
1452				dec hl    ; get past pointer 
1452				dec hl 
1452			 
1452				ld a, (hl)    ; need this for a validation check 
1452			 
1452				dec hl    ; move to block marker 
1452			 
1452				; now check that the block count and block marker are the same  
1452			        ; this checks that we are on a malloc node and not random memory 
1452			        ; OK a faint chance this could be a problem but rare - famous last words! 
1452			 
1452				ld c, a 
1452				ld a, (hl)    
1452			 
1452				cp c 
1452				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1452			 
1452				; yes good chance we are on a malloc node 
1452			 
1452				ld a, 0      
1452				ld (hl), a   ; mark as free 
1452			 
1452				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1452			 
1452			.freeignore:  
1452			 
1452				pop af 
1452				pop hl 
1452			 
1452				ret 
1452			 
1452			 
1452			 
1452			endif 
1452			 
1452			; eof 
# End of file firmware_memory.asm
1452			  
1452			; device C  
1452			; Now handled by SPI  
1452			;if SOUND_ENABLE  
1452			;	include "firmware_sound.asm"  
1452			;endif  
1452			  
1452			include "firmware_diags.asm"  
1452			; Hardware diags menu 
1452			 
1452			 
1452			config: 
1452			 
1452 3e 00			ld a, 0 
1454 21 78 14			ld hl, .configmn 
1457 cd ea 0b			call menu 
145a			 
145a fe 00			cp 0 
145c c8				ret z 
145d			 
145d			;	cp 1 
145d			;	call z, .savetostore 
145d			 
145d fe 01			cp 1 
145f			if STARTUP_V1 
145f cc 8e 14			call z, .selautoload 
1462			endif 
1462			 
1462			if STARTUP_V2 
1462				call z, .enautoload 
1462			endif 
1462 fe 02			cp 2 
1464 cc 84 14			call z, .disautoload 
1467			;	cp 3 
1467			;	call z, .selbank 
1467 fe 03			cp 3 
1469 cc ac 14			call z, .debug_tog 
146c fe 04			cp 4 
146e cc fa 15			call z, .bpsgo 
1471 fe 05			cp 5 
1473 cc d5 14			call z, hardware_diags 
1476			if STARTUP_V2 
1476				cp 6 
1476				call z, create_startup 
1476			endif 
1476 18 da			jr config 
1478			 
1478			.configmn: 
1478			;	dw prom_c3 
1478 e8 17			dw prom_c2 
147a fd 17			dw prom_c2a 
147c			;	dw prom_c2b 
147c			;	dw prom_c4 
147c 1c 18			dw prom_m4 
147e 37 18			dw prom_m4b 
1480 3f 18			dw prom_c1 
1482			if STARTUP_V2 
1482				dw prom_c9 
1482			endif 
1482 00 00			dw 0 
1484				 
1484			 
1484			if STARTUP_V2 
1484			.enautoload: 
1484				if STORAGE_SE 
1484				ld a, $fe      ; bit 0 clear 
1484				ld (spi_device), a 
1484			 
1484				call storage_get_block_0 
1484			 
1484				ld a, 1 
1484				ld (store_page+STORE_0_AUTOFILE), a 
1484			 
1484					ld hl, 0 
1484					ld de, store_page 
1484				call storage_write_block	 ; save update 
1484				else 
1484			 
1484				ld hl, prom_notav 
1484				ld de, prom_empty 
1484				call info_panel 
1484				endif 
1484			 
1484			 
1484				ret 
1484			endif 
1484			 
1484			.disautoload: 
1484				if STORAGE_SE 
1484				ld a, $fe      ; bit 0 clear 
1484				ld (spi_device), a 
1484			 
1484				call storage_get_block_0 
1484			 
1484				ld a, 0 
1484				ld (store_page+STORE_0_AUTOFILE), a 
1484			 
1484					ld hl, 0 
1484					ld de, store_page 
1484				call storage_write_block	 ; save update 
1484				else 
1484			 
1484 21 4e 18			ld hl, prom_notav 
1487 11 64 18			ld de, prom_empty 
148a cd 4a 0b			call info_panel 
148d				endif 
148d			 
148d			 
148d c9				ret 
148e			 
148e			if STARTUP_V1 
148e			 
148e			; Select auto start 
148e			 
148e			.selautoload: 
148e			 
148e				 
148e				if STORAGE_SE 
148e			 
148e					call config_dir 
148e				        ld hl, scratch 
148e					ld a, 0 
148e					call menu 
148e			 
148e					cp 0 
148e					ret z 
148e			 
148e					dec a 
148e			 
148e			 
148e					; locate menu option 
148e			 
148e					ld hl, scratch 
148e					call table_lookup 
148e			 
148e					if DEBUG_FORTH_WORDS 
148e						DMARK "ALl" 
148e						CALLMONITOR 
148e					endif 
148e					; with the pointer to the menu it, the byte following the zero term is the file id 
148e			 
148e					ld a, 0 
148e					ld bc, 50   ; max of bytes to look at 
148e					cpir  
148e			 
148e					if DEBUG_FORTH_WORDS 
148e						DMARK "ALb" 
148e						CALLMONITOR 
148e					endif 
148e					;inc hl 
148e			 
148e					ld a, (hl)   ; file id 
148e					 
148e				        ; save bank and file ids 
148e			 
148e					push af 
148e			 
148e			; TODO need to save to block 0 on bank 1	 
148e			 
148e					call storage_get_block_0 
148e			 
148e					if DEBUG_FORTH_WORDS 
148e						DMARK "AL0" 
148e						CALLMONITOR 
148e					endif 
148e					pop af 
148e			 
148e					ld (store_page+STORE_0_FILERUN),a 
148e					 
148e					; save bank id 
148e			 
148e					ld a,(spi_device) 
148e					ld (store_page+STORE_0_BANKRUN),a 
148e			 
148e					; enable auto run of store file 
148e			 
148e					ld a, 1 
148e					ld (store_page+STORE_0_AUTOFILE),a 
148e			 
148e					; save buffer 
148e			 
148e					ld hl, 0 
148e					ld de, store_page 
148e					if DEBUG_FORTH_WORDS 
148e						DMARK "ALw" 
148e						CALLMONITOR 
148e					endif 
148e				call storage_write_block	 ; save update 
148e			  
148e			 
148e			 
148e			 
148e					ld hl, scratch 
148e					call config_fdir 
148e			 
148e				else 
148e			 
148e 21 4e 18			ld hl, prom_notav 
1491 11 64 18			ld de, prom_empty 
1494 cd 4a 0b			call info_panel 
1497			 
1497				endif 
1497 c9				ret 
1498			endif 
1498			 
1498			 
1498			; Select storage bank 
1498			 
1498			.selbank: 
1498			 
1498			;	if STORAGE_SE 
1498			;	else 
1498			 
1498 21 4e 18			ld hl, prom_notav 
149b 11 64 18			ld de, prom_empty 
149e cd 4a 0b			call info_panel 
14a1			;	endif 
14a1				 
14a1 c9				ret 
14a2			 
14a2			if STORAGE_SE 
14a2			 
14a2			.config_ldir:   
14a2				; Load storage bank labels into menu array 
14a2			 
14a2				 
14a2			 
14a2			 
14a2				ret 
14a2			 
14a2			 
14a2			endif 
14a2			 
14a2			 
14a2			; Save user words to storage 
14a2			 
14a2			.savetostore: 
14a2			 
14a2			;	if STORAGE_SE 
14a2			; 
14a2			;		call config_dir 
14a2			;	        ld hl, scratch 
14a2			;		ld a, 0 
14a2			;		call menu 
14a2			;		 
14a2			;		ld hl, scratch 
14a2			;		call config_fdir 
14a2			; 
14a2			;	else 
14a2			 
14a2 21 4e 18			ld hl, prom_notav 
14a5 11 64 18			ld de, prom_empty 
14a8 cd 4a 0b			call info_panel 
14ab			 
14ab			;	endif 
14ab			 
14ab c9				ret 
14ac			 
14ac			if STARTUP_V2 
14ac			 
14ac			create_startup: 
14ac			 
14ac				ld a, 0 
14ac				ld hl, .crstart 
14ac				call menu 
14ac			 
14ac				cp 0 
14ac				ret z 
14ac			 
14ac				cp 1 
14ac				call z, .genlsword 
14ac				cp 2 
14ac				call z, .genedword 
14ac			 
14ac				cp 3 
14ac				call z, .gendemword 
14ac			 
14ac				cp 4 
14ac				call z, .genutlword 
14ac				cp 5 
14ac				call z, .genspiword 
14ac				cp 6 
14ac				call z, .genkeyword 
14ac				cp 7 
14ac				call z, .gensoundword 
14ac				jr create_startup 
14ac			 
14ac			.gensoundword: 
14ac				ld hl, crs_sound 
14ac				ld de, .soundworddef 
14ac				call .genfile 
14ac				ret 
14ac			.genlsword: 
14ac				ld hl, crs_s1 
14ac				ld de, .lsworddef 
14ac				call .genfile 
14ac				ret 
14ac			 
14ac			.genedword: 
14ac				ld de, .edworddef 
14ac				ld hl, crs_s2 
14ac				call .genfile 
14ac				ret 
14ac			 
14ac			.gendemword: 
14ac				ld de, .demoworddef 
14ac				ld hl, crs_s3 
14ac				call .genfile 
14ac				ret 
14ac			 
14ac			.genutlword: 
14ac				ld hl, crs_s4 
14ac				ld de, .utilwordef 
14ac				call .genfile 
14ac				ret 
14ac			.genspiword: 
14ac				ld hl, crs_s5 
14ac				ld de, .spiworddef 
14ac				call .genfile 
14ac				ret 
14ac			.genkeyword: 
14ac				ld hl, crs_s6 
14ac				ld de, .keyworddef 
14ac				call .genfile 
14ac				ret 
14ac			 
14ac			; hl - points to file name 
14ac			; de - points to strings to add to file 
14ac			 
14ac			.genfile: 
14ac				push hl 
14ac				push de 
14ac			 
14ac				call clear_display 
14ac				ld a, display_row_1 
14ac				ld de, .genfiletxt 
14ac				call str_at_display 
14ac				call update_display 
14ac			 
14ac				pop de 
14ac				pop hl 
14ac			 
14ac			 
14ac				push de 
14ac				call storage_create 
14ac				; id in hl 
14ac				pop de   ; table of strings to add 
14ac			 
14ac			.genloop: 
14ac			 
14ac				push hl ; save id for next time around 
14ac				push de ; save de for next time around 
14ac			 
14ac				ex de, hl 
14ac				call loadwordinhl 
14ac				ex de, hl 
14ac			 
14ac				; need hl to be the id 
14ac				; need de to be the string ptr 
14ac				 
14ac				call storage_append 
14ac			 
14ac				pop de 
14ac				pop hl 
14ac			 
14ac				inc de 
14ac				inc de 
14ac			 
14ac				ld a,(de) 
14ac				cp 0 
14ac				jr nz, .genloop 
14ac				inc de 
14ac				ld a, (de) 
14ac				dec de 
14ac				cp 0 
14ac				jr nz, .genloop	 
14ac			 
14ac				ret 
14ac			 
14ac			.genfiletxt:  db "Creating file...",0 
14ac			 
14ac			.soundworddef: 
14ac				dw sound1 
14ac				dw sound2 
14ac				dw sound3 
14ac				dw sound4 
14ac				dw sound5 
14ac				dw sound6 
14ac				dw sound7 
14ac				dw sound8 
14ac				dw sound9 
14ac				dw 0 
14ac			 
14ac			.utilwordef: 
14ac				dw strncpy 
14ac				dw type 
14ac				dw clrstack 
14ac				dw longread 
14ac				dw start1 
14ac				dw start2 
14ac			; duplicated 
14ac			;	dw start3b 
14ac			;	dw start3c 
14ac				dw list 
14ac				dw 0 
14ac			 
14ac			.lsworddef: 
14ac				dw start3b 
14ac				dw 0 
14ac			 
14ac			.edworddef: 
14ac				dw edit1 
14ac				dw edit2 
14ac				dw edit3 
14ac				dw 0 
14ac			 
14ac			.demoworddef: 
14ac				dw test5 
14ac				dw test6 
14ac				dw test7 
14ac				dw test8 
14ac				dw test9 
14ac				dw test10 
14ac				dw game1 
14ac				dw game1a 
14ac				dw game1b 
14ac				dw game1c 
14ac				dw game1d 
14ac				dw game1s 
14ac				dw game1t 
14ac				dw game1f 
14ac				dw game1z 
14ac				dw game1zz 
14ac				dw ssv2 
14ac				dw ssv3 
14ac				dw ssv4 
14ac				dw ssv5 
14ac				dw ssv1 
14ac				dw ssv1cpm	 
14ac				dw game2b 
14ac				dw game2bf 
14ac				dw game2mba 
14ac				dw game2mbas	 
14ac				dw game2mbht 
14ac				dw game2mbms 
14ac				dw game2mb 
14ac				dw game3w 
14ac				dw game3p 
14ac				dw game3sc 
14ac				dw game3vsi 
14ac				dw game3vs 
14ac				dw 0 
14ac			 
14ac			 
14ac			.spiworddef: 
14ac			 
14ac			    dw spi1 
14ac			    dw spi2 
14ac			    dw spi2b 
14ac			    dw spi3 
14ac			    dw spi4 
14ac			    dw spi5 
14ac			;    dw spi6 
14ac			;    dw spi7 
14ac			 
14ac			;    dw spi8 
14ac			;    dw spi9 
14ac			;    dw spi10 
14ac			    dw 0 
14ac			 
14ac			.keyworddef: 
14ac			 
14ac				dw keyup 
14ac				dw keydown 
14ac				dw keyleft 
14ac				dw keyright 
14ac				dw 	keyf1 
14ac				dw keyf2 
14ac				dw keyf3 
14ac				dw keyf4 
14ac				dw keyf5 
14ac				dw keyf6 
14ac				dw keyf7 
14ac				dw keyf8 
14ac				dw keyf9 
14ac				dw keyf10 
14ac				dw keyf11 
14ac				dw keyf12 
14ac				dw keytab 
14ac				dw keycr 
14ac				dw keyhome 
14ac				dw keyend 
14ac				dw keybs 
14ac				dw 0 
14ac			 
14ac			.crstart: 
14ac				dw crs_s1 
14ac				dw crs_s2 
14ac				dw crs_s3 
14ac				dw crs_s4 
14ac				dw crs_s5 
14ac				dw crs_s6 
14ac				dw crs_sound 
14ac				dw 0 
14ac			 
14ac			endif 
14ac			 
14ac			 
14ac			if STORAGE_SE 
14ac			 
14ac			config_fdir: 
14ac				; using the scratch dir go through and release the memory allocated for each string 
14ac				 
14ac				ld hl, scratch 
14ac			.cfdir:	ld e,(hl) 
14ac				inc hl 
14ac				ld d,(hl) 
14ac				inc hl 
14ac			 
14ac				ex de, hl 
14ac				call ishlzero 
14ac				ret z     ; return on null pointer 
14ac				call free 
14ac				ex de, hl 
14ac				jr .cfdir 
14ac			 
14ac			 
14ac				ret 
14ac			 
14ac			 
14ac			config_dir: 
14ac			 
14ac				; for the config menus that need to build a directory of storage call this routine 
14ac				; it will construct a menu in scratch to pass to menu 
14ac			 
14ac				; open storage device 
14ac			 
14ac				; execute DIR to build a list of files and their ids into scratch in menu format 
14ac				; once the menu has finished then will need to call config_fdir to release the strings 
14ac				 
14ac				; c = number items 
14ac			 
14ac				 
14ac				call storage_get_block_0 
14ac			 
14ac				ld hl, store_page     ; get current id count 
14ac				ld b, (hl) 
14ac				ld c, 0    ; count of files   
14ac			 
14ac			 
14ac				ld hl, scratch 
14ac				ld (store_tmp2), hl    ; location to poke strings 
14ac			 
14ac				; check for empty drive 
14ac			 
14ac				ld a, 0 
14ac				cp b 
14ac				jp z, .dirdone 
14ac			 
14ac				 
14ac					if DEBUG_FORTH_WORDS 
14ac						DMARK "Cdc" 
14ac						CALLMONITOR 
14ac					endif 
14ac			 
14ac			 
14ac			.diritem:	 
14ac				push bc 
14ac				; for each of the current ids do a search for them and if found push to stack 
14ac			 
14ac					ld hl, STORE_BLOCK_PHY 
14ac					ld d, 0		 ; look for extent 0 of block id as this contains file name 
14ac					ld e,b 
14ac			 
14ac					call storage_findnextid 
14ac			 
14ac			 
14ac					; if found hl will be non zero 
14ac			 
14ac					call ishlzero 
14ac					jr z, .dirnotfound 
14ac			 
14ac					; increase count 
14ac			 
14ac					pop bc	 
14ac					inc c 
14ac					push bc 
14ac					 
14ac			 
14ac					; get file header and push the file name 
14ac			 
14ac					ld de, store_page 
14ac					call storage_read_block 
14ac			 
14ac					; push file id to stack 
14ac				 
14ac					ld a, (store_page) 
14ac					ld h, 0 
14ac					ld l, a 
14ac			 
14ac					;call forth_push_numhl 
14ac					; TODO store id 
14ac			 
14ac					push hl 
14ac			 
14ac					; push extent count to stack  
14ac				 
14ac					ld hl, store_page+3 
14ac			 
14ac					; get file name length 
14ac			 
14ac					call strlenz   
14ac			 
14ac					inc hl   ; cover zero term 
14ac					inc hl  ; stick the id at the end of the area 
14ac			 
14ac					push hl 
14ac					pop bc    ; move length to bc 
14ac			 
14ac					call malloc 
14ac			 
14ac					; TODO save malloc area to scratch 
14ac			 
14ac					ex de, hl 
14ac					ld hl, (store_tmp2) 
14ac					ld (hl), e 
14ac					inc hl 
14ac					ld (hl), d 
14ac					inc hl 
14ac					ld (store_tmp2), hl 
14ac			 
14ac					 
14ac			 
14ac					;pop hl   ; get source 
14ac			;		ex de, hl    ; swap aronund	 
14ac			 
14ac					ld hl, store_page+3 
14ac					if DEBUG_FORTH_WORDS 
14ac						DMARK "CFd" 
14ac						CALLMONITOR 
14ac					endif 
14ac					ldir 
14ac			 
14ac					; de is past string, move back one and store id 
14ac					 
14ac					dec de 
14ac			 
14ac					; store file id 
14ac			 
14ac					pop hl 
14ac					ex de,hl 
14ac					ld (hl), e 
14ac			 
14ac					if DEBUG_FORTH_WORDS 
14ac						DMARK "Cdi" 
14ac						CALLMONITOR 
14ac					endif 
14ac					 
14ac			.dirnotfound: 
14ac					pop bc     
14ac					djnz .diritem 
14ac				 
14ac			.dirdone:	 
14ac			 
14ac					ld a, 0 
14ac					ld hl, (store_tmp2) 
14ac					ld (hl), a 
14ac					inc hl 
14ac					ld (hl), a 
14ac					inc hl 
14ac					; push a count of the dir items found 
14ac			 
14ac			;		ld h, 0 
14ac			;		ld l, c 
14ac			 
14ac				ret 
14ac			 
14ac			endif 
14ac			 
14ac			 
14ac			; Settings 
14ac			; Run  
14ac			 
14ac			 
14ac			 
14ac			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
14ac			;;hd_menu2:   db "        2: Editor",0   
14ac			;hd_menu2:   db "        2: Editor       6: Menu",0   
14ac			;hd_menu3:   db "        3: Storage",0 
14ac			;hd_menu4:   db "0=quit  4: Debug",0 
14ac			;hd_don:     db "ON",0 
14ac			;hd_doff:     db "OFF",0 
14ac			; 
14ac			; 
14ac			; 
14ac			;hardware_diags_old:       
14ac			; 
14ac			;.diagmenu: 
14ac			;	call clear_display 
14ac			;	ld a, display_row_1 
14ac			;	ld de, hd_menu1 
14ac			;	call str_at_display 
14ac			; 
14ac			;	ld a, display_row_2 
14ac			;	ld de, hd_menu2 
14ac			;	call str_at_display 
14ac			; 
14ac			;	ld a, display_row_3 
14ac			;	ld de, hd_menu3 
14ac			;	call str_at_display 
14ac			; 
14ac			;	ld a,  display_row_4 
14ac			;	ld de, hd_menu4 
14ac			;	call str_at_display 
14ac			; 
14ac			;	; display debug state 
14ac			; 
14ac			;	ld de, hd_don 
14ac			;	ld a, (os_view_disable) 
14ac			;	cp 0 
14ac			;	jr z, .distog 
14ac			;	ld de, hd_doff 
14ac			;.distog: ld a, display_row_4+17 
14ac			;	call str_at_display 
14ac			; 
14ac			;	call update_display 
14ac			; 
14ac			;	call cin_wait 
14ac			; 
14ac			; 
14ac			; 
14ac			;	cp '4' 
14ac			;	jr nz, .diagn1 
14ac			; 
14ac			;	; debug toggle 
14ac			; 
14ac			;	ld a, (os_view_disable) 
14ac			;	ld b, '*' 
14ac			;	cp 0 
14ac			;	jr z, .debtog 
14ac			;	ld b, 0 
14ac			;.debtog:	 
14ac			;	ld a,b 
14ac			;	ld (os_view_disable),a 
14ac			; 
14ac			;.diagn1: cp '0' 
14ac			;	 ret z 
14ac			; 
14ac			;;	cp '1' 
14ac			;;       jp z, matrix	 
14ac			;;   TODO keyboard matrix test 
14ac			; 
14ac			;	cp '2' 
14ac			;	jp z, .diagedit 
14ac			; 
14ac			;;	cp '6' 
14ac			;;	jp z, .menutest 
14ac			;;if ENABLE_BASIC 
14ac			;;	cp '6' 
14ac			;;	jp z, basic 
14ac			;;endif 
14ac			 ; 
14ac			;	jp .diagmenu 
14ac			; 
14ac			; 
14ac			;	ret 
14ac			 
14ac			 
14ac			.debug_tog: 
14ac 21 f6 14			ld hl, .menudebug 
14af				 
14af			;	ld a, (os_view_disable) 
14af			;	cp '*' 
14af 3a 6f ee			ld a,(debug_vector) 
14b2 fe c9			cp $C9   ; RET 
14b4 20 04			jr nz,.tdon  
14b6 3e 01			ld a, 1 
14b8 18 02			jr .tog1 
14ba 3e 00		.tdon: ld a, 0 
14bc			 
14bc			.tog1: 
14bc cd ea 0b			call menu 
14bf fe 00			cp 0 
14c1 c8				ret z 
14c2 fe 01			cp 1    ; disable debug 
14c4 28 04			jr z, .dtog0 
14c6 3e 2a			ld a, '*' 
14c8 18 05			jr .dtogset 
14ca			.dtog0:  
14ca				;ld a, 0 
14ca cd e8 15			call bp_on 
14cd 18 dd			jr .debug_tog 
14cf			.dtogset:  
14cf				; ld (os_view_disable), a 
14cf cd f4 15			call bp_off 
14d2 c3 ac 14			jp .debug_tog 
14d5			 
14d5			 
14d5			hardware_diags:       
14d5			 
14d5			.diagm: 
14d5 21 e8 14			ld hl, .menuitems 
14d8 3e 00			ld a, 0 
14da cd ea 0b			call menu 
14dd			 
14dd fe 00		         cp 0 
14df c8				 ret z 
14e0			 
14e0 fe 02			cp 2 
14e2 ca 41 15			jp z, .diagedit 
14e5			 
14e5			;	cp '6' 
14e5			;	jp z, .menutest 
14e5			;if ENABLE_BASIC 
14e5			;	cp '6' 
14e5			;	jp z, basic 
14e5			;endif 
14e5			  
14e5 c3 d5 14			jp .diagm 
14e8			 
14e8				 
14e8 fc 14		.menuitems:   	dw .m1 
14ea 07 15				dw .m2 
14ec 0e 15				dw .m3 
14ee 16 15				dw .m5 
14f0 1c 15				dw .m5a 
14f2 25 15				dw .m5b 
14f4 00 00				dw 0 
14f6			 
14f6			.menudebug: 
14f6 2e 15				dw .m6 
14f8 37 15				dw .m7 
14fa 00 00				dw 0 
14fc			 
14fc .. 00		.m1:   db "Key Matrix",0 
1507 .. 00		.m2:   db "Editor",0 
150e .. 00		.m3:   db "Storage",0 
1516 .. 00		.m5:   db "Sound",0 
151c .. 00		.m5a:  db "RAM Test",0 
1525 .. 00		.m5b:  db "LCD Test",0 
152e			 
152e .. 00		.m6:   db "Debug ON",0 
1537 .. 00		.m7:   db "Debug OFF",0 
1541			 
1541			; debug editor 
1541			 
1541			.diagedit: 
1541			 
1541 21 c1 e2			ld hl, scratch 
1544			;	ld bc, 250 
1544			;	ldir 
1544				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1544 3e 00			ld a, 0 
1546 77				ld (hl), a 
1547 23				inc hl 
1548 77				ld (hl), a 
1549 23				inc hl 
154a 77				ld (hl), a 
154b			 
154b cd b9 0b		        call clear_display 
154e cd dc 0b			call update_display 
1551				;ld a, 1 
1551				;ld (hardware_diag), a 
1551			.diloop: 
1551 3e 00			ld a, display_row_1 
1553 0e 00			ld c, 0 
1555 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1557 1e 28			ld e, 40 
1559			 
1559 21 c1 e2			ld hl, scratch	 
155c cd 13 0e			call input_str 
155f			 
155f 3e 28			ld a, display_row_2 
1561 11 c1 e2			ld de, scratch 
1564 cd cc 0b			call str_at_display 
1567 cd dc 0b			call update_display 
156a			 
156a c3 51 15			jp .diloop 
156d			 
156d			 
156d			; pass word in hl 
156d			; a has display location 
156d			display_word_at: 
156d f5				push af 
156e e5				push hl 
156f 7c				ld a,h 
1570 21 c6 e5			ld hl, os_word_scratch 
1573 cd e7 10			call hexout 
1576 e1				pop hl 
1577 7d				ld a,l 
1578 21 c8 e5			ld hl, os_word_scratch+2 
157b cd e7 10			call hexout 
157e 21 ca e5			ld hl, os_word_scratch+4 
1581 3e 00			ld a,0 
1583 77				ld (hl),a 
1584 11 c6 e5			ld de,os_word_scratch 
1587 f1				pop af 
1588 cd cc 0b				call str_at_display 
158b c9				ret 
158c			 
158c			display_ptr_state: 
158c			 
158c				; to restore afterwards 
158c			 
158c d5				push de 
158d c5				push bc 
158e e5				push hl 
158f f5				push af 
1590			 
1590				; for use in here 
1590			 
1590			;	push bc 
1590			;	push de 
1590			;	push hl 
1590			;	push af 
1590			 
1590 cd b9 0b			call clear_display 
1593			 
1593 11 6b 17			ld de, .ptrstate 
1596 3e 00			ld a, display_row_1 
1598 cd cc 0b			call str_at_display 
159b			 
159b				; display debug step 
159b			 
159b			 
159b 11 6b ee			ld de, debug_mark 
159e 3e 26			ld a, display_row_1+display_cols-2 
15a0 cd cc 0b			call str_at_display 
15a3			 
15a3				; display a 
15a3 11 75 17			ld de, .ptrcliptr 
15a6 3e 28			ld a, display_row_2 
15a8 cd cc 0b			call str_at_display 
15ab			 
15ab f1				pop af 
15ac 2a 40 ea			ld hl,(cli_ptr) 
15af 3e 30			ld a, display_row_2+8 
15b1 cd 6d 15			call display_word_at 
15b4			 
15b4			 
15b4				; display hl 
15b4			 
15b4			 
15b4 11 7d 17			ld de, .ptrclioptr 
15b7 3e 32			ld a, display_row_2+10 
15b9 cd cc 0b			call str_at_display 
15bc			; 
15bc			;	pop hl 
15bc 3e 35			ld a, display_row_2+13 
15be 2a 3e ea			ld hl,(cli_origptr) 
15c1 cd 6d 15			call display_word_at 
15c4			; 
15c4			;	 
15c4			;	; display de 
15c4			 
15c4			;	ld de, .regstatede 
15c4			;	ld a, display_row_3 
15c4			;	call str_at_display 
15c4			 
15c4			;	pop de 
15c4			;	ld h,d 
15c4			;	ld l, e 
15c4			;	ld a, display_row_3+3 
15c4			;	call display_word_at 
15c4			 
15c4			 
15c4				; display bc 
15c4			 
15c4			;	ld de, .regstatebc 
15c4			;	ld a, display_row_3+10 
15c4			;	call str_at_display 
15c4			 
15c4			;	pop bc 
15c4			;	ld h,b 
15c4			;	ld l, c 
15c4			;	ld a, display_row_3+13 
15c4			;	call display_word_at 
15c4			 
15c4			 
15c4				; display dsp 
15c4			 
15c4			;	ld de, .regstatedsp 
15c4			;	ld a, display_row_4 
15c4			;	call str_at_display 
15c4			 
15c4				 
15c4			;	ld hl,(cli_data_sp) 
15c4			;	ld a, display_row_4+4 
15c4			;	call display_word_at 
15c4			 
15c4				; display rsp 
15c4			 
15c4 11 ac 17			ld de, .regstatersp 
15c7 3e 82			ld a, display_row_4+10 
15c9 cd cc 0b			call str_at_display 
15cc			 
15cc				 
15cc 2a f2 e9			ld hl,(cli_ret_sp) 
15cf 3e 86			ld a, display_row_4+14 
15d1 cd 6d 15			call display_word_at 
15d4			 
15d4 cd dc 0b			call update_display 
15d7			 
15d7 cd f1 0a			call delay1s 
15da cd f1 0a			call delay1s 
15dd cd f1 0a			call delay1s 
15e0			 
15e0			 
15e0 cd ca 1b			call next_page_prompt 
15e3			 
15e3				; restore  
15e3			 
15e3 f1				pop af 
15e4 e1				pop hl 
15e5 c1				pop bc 
15e6 d1				pop de 
15e7 c9				ret 
15e8			 
15e8			; Update the break point vector so that the user can hook a new routine 
15e8			 
15e8			bp_on: 
15e8 3e c3			ld a, $c3    ; JP 
15ea 32 6f ee			ld (debug_vector), a 
15ed 21 fa 15			ld hl, break_point_state 
15f0 22 70 ee			ld (debug_vector+1), hl 
15f3 c9				ret 
15f4			 
15f4			bp_off: 
15f4 3e c9			ld a, $c9    ; RET 
15f6 32 6f ee			ld (debug_vector), a 
15f9 c9				ret 
15fa			 
15fa			 
15fa			break_point_state: 
15fa			;	push af 
15fa			; 
15fa			;	; see if disabled 
15fa			; 
15fa			;	ld a, (os_view_disable) 
15fa			;	cp '*' 
15fa			;	jr nz, .bpsgo 
15fa			;	pop af 
15fa			;	ret 
15fa			 
15fa			.bpsgo: 
15fa			;	pop af 
15fa f5				push af 
15fb 22 a3 e2			ld (os_view_hl), hl 
15fe ed 53 a1 e2		ld (os_view_de), de 
1602 ed 43 9f e2		ld (os_view_bc), bc 
1606 e5				push hl 
1607 6f				ld l, a 
1608 26 00			ld h, 0 
160a 22 a5 e2			ld (os_view_af),hl 
160d			 
160d 21 b1 ed				ld hl, display_fb0 
1610 22 cc eb				ld (display_fb_active), hl 
1613 e1				pop hl	 
1614			 
1614 3e 31			ld a, '1' 
1616 fe 2a		.bps1:  cp '*' 
1618 cc f4 15			call z, bp_off 
161b			;	jr nz, .bps1b 
161b			;	ld (os_view_disable),a 
161b fe 31		.bps1b:  cp '1' 
161d 20 14			jr nz, .bps2 
161f			 
161f				; display reg 
161f			 
161f				 
161f			 
161f 3a a5 e2			ld a, (os_view_af) 
1622 2a a3 e2			ld hl, (os_view_hl) 
1625 ed 5b a1 e2		ld de, (os_view_de) 
1629 ed 4b 9f e2		ld bc, (os_view_bc) 
162d cd c7 16			call display_reg_state 
1630 c3 b3 16			jp .bpschk 
1633			 
1633 fe 32		.bps2:  cp '2' 
1635 20 08			jr nz, .bps3 
1637				 
1637				; display hl 
1637 2a a3 e2			ld hl, (os_view_hl) 
163a cd b1 17			call display_dump_at_hl 
163d			 
163d 18 74			jr .bpschk 
163f			 
163f fe 33		.bps3:  cp '3' 
1641 20 08			jr nz, .bps4 
1643			 
1643			        ; display de 
1643 2a a1 e2			ld hl, (os_view_de) 
1646 cd b1 17			call display_dump_at_hl 
1649			 
1649 18 68			jr .bpschk 
164b fe 34		.bps4:  cp '4' 
164d 20 08			jr nz, .bps5 
164f			 
164f			        ; display bc 
164f 2a 9f e2			ld hl, (os_view_bc) 
1652 cd b1 17			call display_dump_at_hl 
1655			 
1655 18 5c			jr .bpschk 
1657 fe 35		.bps5:  cp '5' 
1659 20 08		        jr nz, .bps7 
165b			 
165b				; display cur ptr 
165b 2a 40 ea			ld hl, (cli_ptr) 
165e cd b1 17			call display_dump_at_hl 
1661			 
1661 18 50			jr .bpschk 
1663 fe 36		.bps7:  cp '6' 
1665 20 08			jr nz, .bps8b 
1667				 
1667				; display cur orig ptr 
1667 2a 3e ea			ld hl, (cli_origptr) 
166a cd b1 17			call display_dump_at_hl 
166d 18 44			jr .bpschk 
166f fe 37		.bps8b:  cp '7' 
1671 20 08			jr nz, .bps9 
1673				 
1673				; display dsp 
1673 2a ee e9			ld hl, (cli_data_sp) 
1676 cd b1 17			call display_dump_at_hl 
1679			 
1679 18 38			jr .bpschk 
167b fe 39		.bps9:  cp '9' 
167d 20 05			jr nz, .bps8c 
167f				 
167f				; display SP 
167f			;	ld hl, sp 
167f cd b1 17			call display_dump_at_hl 
1682			 
1682 18 2f			jr .bpschk 
1684 fe 38		.bps8c:  cp '8' 
1686 20 08			jr nz, .bps8d 
1688				 
1688				; display rsp 
1688 2a f2 e9			ld hl, (cli_ret_sp) 
168b cd b1 17			call display_dump_at_hl 
168e			 
168e 18 23			jr .bpschk 
1690 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1692 20 05			jr nz, .bps8 
1694 cd 98 19			call monitor 
1697			 
1697 18 1a			jr .bpschk 
1699 fe 30		.bps8:  cp '0' 
169b 20 16			jr nz, .bpschk 
169d			 
169d 21 10 ed				ld hl, display_fb1 
16a0 22 cc eb				ld (display_fb_active), hl 
16a3 cd dc 0b				call update_display 
16a6			 
16a6				;ld a, (os_view_af) 
16a6 2a a3 e2			ld hl, (os_view_hl) 
16a9 ed 5b a1 e2		ld de, (os_view_de) 
16ad ed 4b 9f e2		ld bc, (os_view_bc) 
16b1 f1				pop af 
16b2 c9				ret 
16b3			 
16b3			.bpschk:   
16b3 cd f1 0a			call delay1s 
16b6 3e 9f		ld a,display_row_4 + display_cols - 1 
16b8 11 c8 1b		        ld de, endprg 
16bb cd cc 0b			call str_at_display 
16be cd dc 0b			call update_display 
16c1 cd 26 66			call cin_wait 
16c4			 
16c4 c3 16 16			jp .bps1 
16c7			 
16c7			 
16c7			display_reg_state: 
16c7			 
16c7				; to restore afterwards 
16c7			 
16c7 d5				push de 
16c8 c5				push bc 
16c9 e5				push hl 
16ca f5				push af 
16cb			 
16cb				; for use in here 
16cb			 
16cb c5				push bc 
16cc d5				push de 
16cd e5				push hl 
16ce f5				push af 
16cf			 
16cf cd b9 0b			call clear_display 
16d2			 
16d2 11 87 17			ld de, .regstate 
16d5 3e 00			ld a, display_row_1 
16d7 cd cc 0b			call str_at_display 
16da			 
16da				; display debug step 
16da			 
16da			 
16da 11 6b ee			ld de, debug_mark 
16dd 3e 25			ld a, display_row_1+display_cols-3 
16df cd cc 0b			call str_at_display 
16e2			 
16e2				; display a 
16e2 11 a3 17			ld de, .regstatea 
16e5 3e 28			ld a, display_row_2 
16e7 cd cc 0b			call str_at_display 
16ea			 
16ea e1				pop hl 
16eb			;	ld h,0 
16eb			;	ld l, a 
16eb 3e 2b			ld a, display_row_2+3 
16ed cd 6d 15			call display_word_at 
16f0			 
16f0			 
16f0				; display hl 
16f0			 
16f0			 
16f0 11 97 17			ld de, .regstatehl 
16f3 3e 32			ld a, display_row_2+10 
16f5 cd cc 0b			call str_at_display 
16f8			 
16f8 e1				pop hl 
16f9 3e 35			ld a, display_row_2+13 
16fb cd 6d 15			call display_word_at 
16fe			 
16fe				 
16fe				; display de 
16fe			 
16fe 11 9b 17			ld de, .regstatede 
1701 3e 50			ld a, display_row_3 
1703 cd cc 0b			call str_at_display 
1706			 
1706 e1				pop hl 
1707			;	ld h,d 
1707			;	ld l, e 
1707 3e 53			ld a, display_row_3+3 
1709 cd 6d 15			call display_word_at 
170c			 
170c			 
170c				; display bc 
170c			 
170c 11 9f 17			ld de, .regstatebc 
170f 3e 5a			ld a, display_row_3+10 
1711 cd cc 0b			call str_at_display 
1714			 
1714 e1				pop hl 
1715			;	ld h,b 
1715			;	ld l, c 
1715 3e 5d			ld a, display_row_3+13 
1717 cd 6d 15			call display_word_at 
171a			 
171a			 
171a				; display dsp 
171a			 
171a 11 a7 17			ld de, .regstatedsp 
171d 3e 78			ld a, display_row_4 
171f cd cc 0b			call str_at_display 
1722			 
1722				 
1722 2a ee e9			ld hl,(cli_data_sp) 
1725 3e 7c			ld a, display_row_4+4 
1727 cd 6d 15			call display_word_at 
172a			 
172a				; display rsp 
172a			 
172a 11 ac 17			ld de, .regstatersp 
172d 3e 82			ld a, display_row_4+10 
172f cd cc 0b			call str_at_display 
1732			 
1732				 
1732 2a f2 e9			ld hl,(cli_ret_sp) 
1735 3e 86			ld a, display_row_4+14 
1737 cd 6d 15			call display_word_at 
173a			 
173a cd dc 0b			call update_display 
173d			 
173d			;	call delay1s 
173d			;	call delay1s 
173d			;	call delay1s 
173d			 
173d			 
173d			;	call next_page_prompt 
173d			 
173d				; restore  
173d			 
173d f1				pop af 
173e e1				pop hl 
173f c1				pop bc 
1740 d1				pop de 
1741 c9				ret 
1742			 
1742 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1756 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
176b .. 00		.ptrstate:	db "Ptr State",0 
1775 .. 00		.ptrcliptr:     db "cli_ptr",0 
177d .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1787 .. 00		.regstate:	db "Reg State (1/0)",0 
1797 .. 00		.regstatehl:	db "HL:",0 
179b .. 00		.regstatede:	db "DE:",0 
179f .. 00		.regstatebc:	db "BC:",0 
17a3 .. 00		.regstatea:	db "A :",0 
17a7 .. 00		.regstatedsp:	db "DSP:",0 
17ac .. 00		.regstatersp:	db "RSP:",0 
17b1			 
17b1			display_dump_at_hl: 
17b1 e5				push hl 
17b2 d5				push de 
17b3 c5				push bc 
17b4 f5				push af 
17b5			 
17b5 22 e4 e5			ld (os_cur_ptr),hl	 
17b8 cd b9 0b			call clear_display 
17bb cd d2 1a			call dumpcont 
17be			;	call delay1s 
17be			;	call next_page_prompt 
17be			 
17be			 
17be f1				pop af 
17bf c1				pop bc 
17c0 d1				pop de 
17c1 e1				pop hl 
17c2 c9				ret 
17c3			 
17c3			;if ENABLE_BASIC 
17c3			;	include "nascombasic.asm" 
17c3			;	basic: 
17c3			;	include "forth/FORTH.ASM" 
17c3			;endif 
17c3			 
17c3			; eof 
17c3			 
17c3			 
# End of file firmware_diags.asm
17c3			  
17c3			include "firmware_prompts.asm"  
17c3			; Prompts  
17c3			 
17c3			; boot messages 
17c3			 
17c3 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
17d8 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
17e8			 
17e8			 
17e8			; config menus 
17e8			 
17e8			;prom_c3: db "Add Dictionary To File",0 
17e8			 
17e8			if STARTUP_V1 
17e8 .. 00		prom_c2: db "Select Autoload File",0 
17fd .. 00		prom_c2a: db "Disable Autoload File", 0 
1813			endif 
1813			 
1813			if STARTUP_V2 
1813			prom_c2: db "Enable Autoload Files",0 
1813			prom_c2a: db "Disable Autoload Files", 0 
1813			 
1813			crs_s1: db "*ls-word", 0 
1813			crs_s2: db "*ed-word", 0 
1813			crs_s3: db "*Demo-Programs", 0 
1813			crs_s4: db "*Utils", 0 
1813			crs_s5: db "*SPI-Util", 0 
1813			crs_s6: db "*Key-constants", 0 
1813			crs_sound: db "*Sound-Util", 0 
1813			 
1813			 
1813			 
1813			endif 
1813			;prom_c2b: db "Select Storage Bank",0 
1813 .. 00		prom_c4: db "Settings",0 
181c .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1837 .. 00		prom_m4b:   db "Monitor",0 
183f .. 00		prom_c1: db "Hardware Diags",0 
184e			 
184e			 
184e			if STARTUP_V2 
184e			prom_c9: db "Create Startup Files",0 
184e			endif 
184e			 
184e .. 00		prom_notav:    db "Feature not available",0 
1864 .. 00		prom_empty:    db "",0 
1865			 
1865			; eof 
1865			 
# End of file firmware_prompts.asm
1865			  
1865			  
1865			; eof  
1865			  
# End of file firmware.asm
1865			 
1865			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1865			;if BASE_KEV  
1865			;baseram: equ 08000h 
1865			;endif 
1865			 
1865			;if BASE_SC114 
1865			;baseram:     equ    endofcode 
1865			;endif 
1865			 
1865			 
1865			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1865			 
1865			; start system 
1865			 
1865			coldstart: 
1865				; set sp 
1865				; di/ei 
1865			 
1865 f3				di 
1866 31 00 f0			ld sp, tos 
1869 cd 24 65			call init_nmi 
186c			;	ei 
186c			 
186c				; init spinner 
186c 3e 00			ld a,0 
186e 32 c6 eb			ld (display_active), a 
1871			 
1871				; disable breakpoint by default 
1871			 
1871				;ld a,'*' 
1871			;	ld a,' ' 
1871			;	ld (os_view_disable),a 
1871			 
1871				; set break point vector as new break point on or off 
1871 cd f4 15			call bp_off 
1874			 
1874				; init hardware 
1874			 
1874				; init keyboard and screen hardware 
1874			 
1874 cd 1b 01			call hardware_init 
1877			 
1877			 
1877 cd f1 0a			call delay1s 
187a 3e 58			ld a, display_row_3+8 
187c 11 03 01			ld de, buildtime 
187f cd cc 0b			call str_at_display 
1882 cd dc 0b			call update_display 
1885			 
1885 cd f1 0a			call delay1s 
1888 cd f1 0a			call delay1s 
188b cd f1 0a			call delay1s 
188e			 
188e				; detect if any keys are held down to enable breakpoints at start up 
188e			 
188e cd 2e 66			call cin  
1891 fe 00			cp 0 
1893 28 03			jr z, .nokeys 
1895			 
1895				;call hardware_diags 
1895 cd 52 14			call config 
1898			 
1898			;	ld de, .bpen 
1898			;	ld a, display_row_4 
1898			;	call str_at_display 
1898			;	call update_display 
1898			; 
1898			;	ld a,0 
1898			;	ld (os_view_disable),a 
1898			; 
1898			;.bpwait: 
1898			;	call cin 
1898			;	cp 0 
1898			;	jr z, .bpwait 
1898			;	jr .nokeys 
1898			; 
1898			; 
1898			;.bpen:  db "Break points enabled!",0 
1898			 
1898			 
1898			 
1898			 
1898			 
1898			 
1898			.nokeys: 
1898			 
1898			 
1898				 
1898			 
1898			;jp  testkey 
1898			 
1898			;call storage_get_block_0 
1898			; 
1898			;ld hl, 0 
1898			;ld de, store_page 
1898			;call storage_read_block 
1898			 
1898				 
1898			;ld hl, 10 
1898			;ld de, store_page 
1898			;call storage_read_block 
1898			 
1898			 
1898			 
1898			 
1898			 
1898			;stop:	nop 
1898			;	jp stop 
1898			 
1898			 
1898			 
1898			main: 
1898 cd b9 0b			call clear_display 
189b cd dc 0b			call update_display 
189e			 
189e			 
189e			 
189e			;	call testlcd 
189e			 
189e			 
189e			 
189e cd cf 1f			call forth_init 
18a1			 
18a1			 
18a1			warmstart: 
18a1 cd a5 1f			call forth_warmstart 
18a4			 
18a4				; run startup word load 
18a4			        ; TODO prevent this running at warmstart after crash  
18a4			 
18a4				if STARTUP_ENABLE 
18a4			 
18a4					if STARTUP_V1 
18a4			 
18a4						if STORAGE_SE 
18a4							call forth_autoload 
18a4						endif 
18a4 cd 74 64					call forth_startup 
18a7					endif 
18a7			 
18a7					if STARTUP_V2 
18a7			 
18a7						if STORAGE_SE 
18a7							call forth_autoload 
18a7						else 
18a7							call forth_startup 
18a7						endif 
18a7			 
18a7			 
18a7					endif 
18a7			 
18a7				endif 
18a7			 
18a7				; show free memory after boot 
18a7 11 33 19			ld de, freeram 
18aa 3e 00			ld a, display_row_1 
18ac cd cc 0b			call str_at_display 
18af			 
18af				; get current heap start after loading any uwords 
18af			 
18af				;ld de, (os_last_new_uword) 
18af				;ex de, hl 
18af			 
18af			; Or use heap_size word???? 
18af				;ld hl, heap_end 
18af				;ld hl, heap_size 
18af				;ld de, topusermem 
18af				;ld de, heap_start 
18af ed 5b 51 66			ld de, (free_list )      
18b3 21 9c e2				ld hl, heap_end 
18b6 ed 52			sbc hl, de 
18b8				;push hl 
18b8				;ld a,h	         	 
18b8				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18b8				;call hexout 
18b8			   	;pop hl 
18b8			; 
18b8			;	ld a,l 
18b8			;	ld hl, os_word_scratch+2 
18b8			;	call hexout 
18b8			;	ld hl, os_word_scratch+4 
18b8			;	ld a, 0 
18b8			;	ld (hl),a 
18b8 eb				ex de, hl 
18b9 21 c6 e5			ld hl, os_word_scratch 
18bc cd f3 11			call uitoa_16 
18bf			 
18bf			 
18bf 11 c6 e5			ld de, os_word_scratch 
18c2 3e 0d			ld a, display_row_1 + 13 
18c4 cd cc 0b			call str_at_display 
18c7 cd dc 0b			call update_display 
18ca			 
18ca			 
18ca				;call demo 
18ca			 
18ca			 
18ca				; init scratch input area for cli commands 
18ca			 
18ca 21 e8 e5			ld hl, os_cli_cmd 
18cd 3e 00			ld a,0 
18cf 77				ld (hl),a 
18d0 23				inc hl 
18d1 77				ld (hl),a 
18d2			 
18d2 3e 00			ld a,0 
18d4 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
18d7			 
18d7 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
18da 32 e5 e5			ld (os_cur_ptr+1),a	 
18dd			 
18dd 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
18e0 32 c7 e5			ld (os_word_scratch+1),a	 
18e3				 
18e3			 
18e3				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18e3 21 e8 e5			ld hl, os_cli_cmd 
18e6			 
18e6 3e 00			ld a, 0		 ; init cli input 
18e8 77				ld (hl), a 
18e9 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18eb			cli: 
18eb				; show cli prompt 
18eb				;push af 
18eb				;ld a, 0 
18eb				;ld de, prompt 
18eb				;call str_at_display 
18eb			 
18eb				;call update_display 
18eb				;pop af 
18eb				;inc a 
18eb				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18eb 0e 00			ld c, 0 
18ed 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18ef 1e 28			ld e, 40 
18f1			 
18f1 21 e8 e5			ld hl, os_cli_cmd 
18f4			 
18f4				STACKFRAME OFF $fefe $9f9f 
18f4				if DEBUG_STACK_IMB 
18f4					if OFF 
18f4						exx 
18f4						ld de, $fefe 
18f4						ld a, d 
18f4						ld hl, curframe 
18f4						call hexout 
18f4						ld a, e 
18f4						ld hl, curframe+2 
18f4						call hexout 
18f4						ld hl, $fefe 
18f4						push hl 
18f4						ld hl, $9f9f 
18f4						push hl 
18f4						exx 
18f4					endif 
18f4				endif 
18f4			endm 
# End of macro STACKFRAME
18f4			 
18f4 cd 13 0e			call input_str 
18f7			 
18f7				STACKFRAMECHK OFF $fefe $9f9f 
18f7				if DEBUG_STACK_IMB 
18f7					if OFF 
18f7						exx 
18f7						ld hl, $9f9f 
18f7						pop de   ; $9f9f 
18f7						call cmp16 
18f7						jr nz, .spnosame 
18f7						ld hl, $fefe 
18f7						pop de   ; $fefe 
18f7						call cmp16 
18f7						jr z, .spfrsame 
18f7						.spnosame: call showsperror 
18f7						.spfrsame: nop 
18f7						exx 
18f7					endif 
18f7				endif 
18f7			endm 
# End of macro STACKFRAMECHK
18f7			 
18f7				; copy input to last command 
18f7			 
18f7 21 e8 e5			ld hl, os_cli_cmd 
18fa 11 e7 e6			ld de, os_last_cmd 
18fd 01 ff 00			ld bc, 255 
1900 ed b0			ldir 
1902			 
1902				; wipe current buffer 
1902			 
1902			;	ld a, 0 
1902			;	ld hl, os_cli_cmd 
1902			;	ld de, os_cli_cmd+1 
1902			;	ld bc, 254 
1902			;	ldir 
1902				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1902			;	call strcpy 
1902			;	ld a, 0 
1902			;	ld (hl), a 
1902			;	inc hl 
1902			;	ld (hl), a 
1902			;	inc hl 
1902			;	ld (hl), a 
1902			 
1902				; switch frame buffer to program  
1902			 
1902 21 10 ed				ld hl, display_fb1 
1905 22 cc eb				ld (display_fb_active), hl 
1908			 
1908			;	nop 
1908				STACKFRAME ON $fbfe $8f9f 
1908				if DEBUG_STACK_IMB 
1908					if ON 
1908						exx 
1908						ld de, $fbfe 
1908						ld a, d 
1908						ld hl, curframe 
1908						call hexout 
1908						ld a, e 
1908						ld hl, curframe+2 
1908						call hexout 
1908						ld hl, $fbfe 
1908						push hl 
1908						ld hl, $8f9f 
1908						push hl 
1908						exx 
1908					endif 
1908				endif 
1908			endm 
# End of macro STACKFRAME
1908				; first time into the parser so pass over the current scratch pad 
1908 21 e8 e5			ld hl,os_cli_cmd 
190b				; tokenise the entered statement(s) in HL 
190b cd 4d 20			call forthparse 
190e			        ; exec forth statements in top of return stack 
190e cd 8d 20			call forthexec 
1911				;call forthexec_cleanup 
1911			;	call parsenext 
1911			 
1911				STACKFRAMECHK ON $fbfe $8f9f 
1911				if DEBUG_STACK_IMB 
1911					if ON 
1911						exx 
1911						ld hl, $8f9f 
1911						pop de   ; $8f9f 
1911						call cmp16 
1911						jr nz, .spnosame 
1911						ld hl, $fbfe 
1911						pop de   ; $fbfe 
1911						call cmp16 
1911						jr z, .spfrsame 
1911						.spnosame: call showsperror 
1911						.spfrsame: nop 
1911						exx 
1911					endif 
1911				endif 
1911			endm 
# End of macro STACKFRAMECHK
1911				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1911			 
1911 3e 78			ld a, display_row_4 
1913 11 44 19			ld de, endprog 
1916			 
1916 cd dc 0b			call update_display		 
1919			 
1919 cd ca 1b			call next_page_prompt 
191c			 
191c				; switch frame buffer to cli 
191c			 
191c 21 b1 ed				ld hl, display_fb0 
191f 22 cc eb				ld (display_fb_active), hl 
1922			 
1922			 
1922 cd b9 0b		        call clear_display 
1925 cd dc 0b			call update_display		 
1928			 
1928 21 e8 e5			ld hl, os_cli_cmd 
192b			 
192b 3e 00			ld a, 0		 ; init cli input 
192d 77				ld (hl), a 
192e			 
192e				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
192e			 
192e				; now on last line 
192e			 
192e				; TODO scroll screen up 
192e			 
192e				; TODO instead just clear screen and place at top of screen 
192e			 
192e			;	ld a, 0 
192e			;	ld (f_cursor_ptr),a 
192e			 
192e				;call clear_display 
192e				;call update_display 
192e			 
192e				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
192e 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1930 c3 eb 18			jp cli 
1933			 
1933 .. 00		freeram: db "Free bytes: ",0 
1940 ..			asc: db "1A2F" 
1944 .. 00		endprog: db "End prog...",0 
1950			 
1950			testenter2:   
1950 21 f3 e2			ld hl,scratch+50 
1953 22 e4 e5			ld (os_cur_ptr),hl 
1956 c3 eb 18			jp cli 
1959			 
1959			testenter:  
1959			 
1959 21 40 19			ld hl,asc 
195c			;	ld a,(hl) 
195c			;	call nibble2val 
195c cd 3d 11			call get_byte 
195f			 
195f			 
195f			;	ld a,(hl) 
195f			;	call atohex 
195f			 
195f			;	call fourehexhl 
195f 32 f3 e2			ld (scratch+50),a 
1962			 
1962			 
1962			 
1962 21 42 19			ld hl,asc+2 
1965			;	ld a, (hl) 
1965			;	call nibble2val 
1965 cd 3d 11			call get_byte 
1968			 
1968			;	call fourehexhl 
1968 32 f5 e2			ld (scratch+52),a 
196b				 
196b 21 f3 e2			ld hl,scratch+50 
196e 22 e4 e5			ld (os_cur_ptr),hl 
1971 c3 eb 18			jp cli 
1974			 
1974			enter:	 
1974 3a c5 e2			ld a,(scratch+4) 
1977 fe 00			cp 0 
1979 28 0c			jr z, .entercont 
197b				; no, not a null term line so has an address to work out.... 
197b			 
197b 21 c3 e2			ld hl,scratch+2 
197e cd 9d 11			call get_word_hl 
1981			 
1981 22 e4 e5			ld (os_cur_ptr),hl	 
1984 c3 eb 18			jp cli 
1987			 
1987			 
1987			.entercont:  
1987			 
1987 21 c3 e2			ld hl, scratch+2 
198a cd 3d 11			call get_byte 
198d			 
198d 2a e4 e5		   	ld hl,(os_cur_ptr) 
1990 77					ld (hl),a 
1991 23					inc hl 
1992 22 e4 e5				ld (os_cur_ptr),hl 
1995				 
1995			; get byte  
1995			 
1995			 
1995 c3 eb 18			jp cli 
1998			 
1998			 
1998			; basic monitor support 
1998			 
1998			monitor: 
1998				;  
1998 cd b9 0b			call clear_display 
199b 3e 00			ld a, 0 
199d 11 ec 19			ld de, .monprompt 
19a0 cd cc 0b			call str_at_display 
19a3 cd dc 0b			call update_display 
19a6			 
19a6				; get a monitor command 
19a6			 
19a6 0e 00			ld c, 0     ; entry at top left 
19a8 16 64			ld d, 100   ; max buffer size 
19aa 1e 0f			ld e, 15    ; input scroll area 
19ac 3e 00			ld a, 0     ; init string 
19ae 21 bf e4			ld hl, os_input 
19b1 77				ld (hl), a 
19b2 23				inc hl 
19b3 77				ld (hl), a 
19b4 21 bf e4			ld hl, os_input 
19b7 3e 01			ld a, 1     ; init string 
19b9 cd 13 0e			call input_str 
19bc			 
19bc cd b9 0b		        call clear_display 
19bf cd dc 0b			call update_display		 
19c2			 
19c2 3a bf e4			ld a, (os_input) 
19c5 cd 3b 12			call toUpper 
19c8 fe 48		        cp 'H' 
19ca ca 51 1a		        jp z, .monhelp 
19cd fe 44			cp 'D'		; dump 
19cf ca 84 1a			jp z, .mondump	 
19d2 fe 43			cp 'C'		; dump 
19d4 ca 9e 1a			jp z, .moncdump	 
19d7 fe 4d			cp 'M'		; dump 
19d9 ca ee 19			jp z, .moneditstart 
19dc fe 55			cp 'U'		; dump 
19de ca fa 19			jp z, .monedit	 
19e1 fe 47			cp 'G'		; dump 
19e3 ca 7a 1a			jp z, .monjump 
19e6 fe 51			cp 'Q'		; dump 
19e8 c8				ret z	 
19e9			 
19e9			 
19e9				; TODO "S" to access symbol by name and not need the address 
19e9				; TODO "F" to find a string in memory 
19e9			 
19e9 c3 98 19			jp monitor 
19ec			 
19ec .. 00		.monprompt: db ">", 0 
19ee			 
19ee			.moneditstart: 
19ee				; get starting address 
19ee			 
19ee 21 c1 e4			ld hl,os_input+2 
19f1 cd 9d 11			call get_word_hl 
19f4			 
19f4 22 e4 e5			ld (os_cur_ptr),hl	 
19f7			 
19f7 c3 98 19			jp monitor 
19fa			 
19fa			.monedit: 
19fa				; get byte to load 
19fa			 
19fa 21 c1 e4			ld hl,os_input+2 
19fd cd 3d 11			call get_byte 
1a00			 
1a00				; get address to update 
1a00 2a e4 e5			ld hl, (os_cur_ptr) 
1a03			 
1a03				; update byte 
1a03			 
1a03 77				ld (hl), a 
1a04			 
1a04				; move to next address and save it 
1a04			 
1a04 23				inc hl 
1a05 22 e4 e5			ld (os_cur_ptr),hl	 
1a08			 
1a08 c3 98 19			jp monitor 
1a0b			 
1a0b			 
1a0b .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a1f .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a3b .. 00		.monhelptext3:  db "G-Call address",0 
1a4a .. 00		.monhelptext4:  db "Q-Quit",0 
1a51			        
1a51			.monhelp: 
1a51 3e 00			ld a, display_row_1 
1a53 11 0b 1a		        ld de, .monhelptext1 
1a56			 
1a56 cd cc 0b			call str_at_display 
1a59 3e 28			ld a, display_row_2 
1a5b 11 1f 1a		        ld de, .monhelptext2 
1a5e					 
1a5e cd cc 0b			call str_at_display 
1a61 3e 50			ld a, display_row_3 
1a63 11 3b 1a		        ld de, .monhelptext3 
1a66					 
1a66 cd cc 0b			call str_at_display 
1a69 3e 78			ld a, display_row_4 
1a6b 11 4a 1a		        ld de, .monhelptext4 
1a6e cd cc 0b			call str_at_display 
1a71			 
1a71 cd dc 0b			call update_display		 
1a74			 
1a74 cd ca 1b			call next_page_prompt 
1a77 c3 98 19			jp monitor 
1a7a			 
1a7a			.monjump:    
1a7a 21 c1 e4			ld hl,os_input+2 
1a7d cd 9d 11			call get_word_hl 
1a80			 
1a80 e9				jp (hl) 
1a81 c3 98 19			jp monitor 
1a84			 
1a84			.mondump:    
1a84 21 c1 e4			ld hl,os_input+2 
1a87 cd 9d 11			call get_word_hl 
1a8a			 
1a8a 22 e4 e5			ld (os_cur_ptr),hl	 
1a8d cd d2 1a			call dumpcont 
1a90 3e 78			ld a, display_row_4 
1a92 11 44 19			ld de, endprog 
1a95			 
1a95 cd dc 0b			call update_display		 
1a98			 
1a98 cd ca 1b			call next_page_prompt 
1a9b c3 98 19			jp monitor 
1a9e			.moncdump: 
1a9e cd d2 1a			call dumpcont 
1aa1 3e 78			ld a, display_row_4 
1aa3 11 44 19			ld de, endprog 
1aa6			 
1aa6 cd dc 0b			call update_display		 
1aa9			 
1aa9 cd ca 1b			call next_page_prompt 
1aac c3 98 19			jp monitor 
1aaf			 
1aaf			 
1aaf			; TODO symbol access  
1aaf			 
1aaf			.symbols:     ;; A list of symbols that can be called up  
1aaf b1 ed			dw display_fb0 
1ab1 .. 00			db "fb0",0  
1ab5 7a ea		     	dw store_page 
1ab7 .. 00			db "store_page",0 
1ac2			 
1ac2			 
1ac2			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1ac2			 
1ac2 3a c2 e2			ld a,(scratch+1) 
1ac5 fe 00			cp 0 
1ac7 28 09			jr z, dumpcont 
1ac9			 
1ac9				; no, not a null term line so has an address to work out.... 
1ac9			 
1ac9 21 c3 e2			ld hl,scratch+2 
1acc cd 9d 11			call get_word_hl 
1acf			 
1acf 22 e4 e5			ld (os_cur_ptr),hl	 
1ad2			 
1ad2			 
1ad2			 
1ad2			dumpcont: 
1ad2			 
1ad2				; dump bytes at ptr 
1ad2			 
1ad2			 
1ad2 3e 00			ld a, display_row_1 
1ad4 2a cc eb			ld hl, (display_fb_active) 
1ad7 cd e6 0d			call addatohl 
1ada cd 02 1b			call .dumpbyterow 
1add			 
1add 3e 28			ld a, display_row_2 
1adf 2a cc eb			ld hl, (display_fb_active) 
1ae2 cd e6 0d			call addatohl 
1ae5 cd 02 1b			call .dumpbyterow 
1ae8			 
1ae8			 
1ae8 3e 50			ld a, display_row_3 
1aea 2a cc eb			ld hl, (display_fb_active) 
1aed cd e6 0d			call addatohl 
1af0 cd 02 1b			call .dumpbyterow 
1af3			 
1af3 3e 78			ld a, display_row_4 
1af5 2a cc eb			ld hl, (display_fb_active) 
1af8 cd e6 0d			call addatohl 
1afb cd 02 1b			call .dumpbyterow 
1afe			 
1afe cd dc 0b			call update_display 
1b01			;		jp cli 
1b01 c9				ret 
1b02			 
1b02			.dumpbyterow: 
1b02			 
1b02				;push af 
1b02			 
1b02 e5				push hl 
1b03			 
1b03				; calc where to poke the ascii 
1b03			if display_cols == 20 
1b03				ld a, 16 
1b03			else 
1b03 3e 1f			ld a, 31 
1b05			endif 
1b05			 
1b05 cd e6 0d			call addatohl 
1b08 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
1b0b			 
1b0b			 
1b0b			; display decoding address 
1b0b 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b0e			 
1b0e 7c				ld a,h 
1b0f e1				pop hl 
1b10 e5				push hl 
1b11			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b11 cd e7 10			call hexout 
1b14 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b17			 
1b17 7d				ld a,l 
1b18 e1				pop hl 
1b19 23				inc hl 
1b1a 23				inc hl 
1b1b e5				push hl 
1b1c			;	ld hl, os_word_scratch+2 
1b1c cd e7 10			call hexout 
1b1f e1				pop hl 
1b20 23				inc hl 
1b21 23				inc hl 
1b22				;ld hl, os_word_scratch+4 
1b22 3e 3a			ld a, ':' 
1b24 77				ld (hl),a 
1b25 23				inc hl 
1b26				;ld a, 0 
1b26				;ld (hl),a 
1b26				;ld de, os_word_scratch 
1b26				;pop af 
1b26				;push af 
1b26			;		ld a, display_row_2 
1b26			;		call str_at_display 
1b26			;		call update_display 
1b26			 
1b26			 
1b26			;pop af 
1b26			;	add 5 
1b26			 
1b26			if display_cols == 20 
1b26				ld b, 4 
1b26			else 
1b26 06 08			ld b, 8 
1b28			endif	 
1b28			 
1b28			.dumpbyte: 
1b28 c5				push bc 
1b29 e5				push hl 
1b2a			 
1b2a			 
1b2a 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b2d 7e					ld a,(hl) 
1b2e			 
1b2e					; poke the ascii to display 
1b2e 2a c6 e5				ld hl,(os_word_scratch) 
1b31 77					ld (hl),a 
1b32 23					inc hl 
1b33 22 c6 e5				ld (os_word_scratch),hl 
1b36			 
1b36					 
1b36			 
1b36			 
1b36 e1					pop hl 
1b37 e5					push hl 
1b38			 
1b38 cd e7 10				call hexout 
1b3b			 
1b3b					 
1b3b 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b3e 23				inc hl 
1b3f 22 e4 e5		   	ld (os_cur_ptr),hl 
1b42			 
1b42 e1					pop hl 
1b43 23					inc hl 
1b44 23					inc hl 
1b45 23					inc hl 
1b46			 
1b46			 
1b46			 
1b46					;ld a,0 
1b46					;ld (os_word_scratch+2),a 
1b46					;pop af 
1b46					;push af 
1b46			 
1b46					;ld de, os_word_scratch 
1b46					;call str_at_display 
1b46			;		call update_display 
1b46			;		pop af 
1b46 c1					pop bc 
1b47 c6 03				add 3 
1b49 10 dd			djnz .dumpbyte 
1b4b			 
1b4b				 
1b4b			 
1b4b c9				ret 
1b4c			 
1b4c			jump:	 
1b4c			 
1b4c 21 c3 e2			ld hl,scratch+2 
1b4f cd 9d 11			call get_word_hl 
1b52				;ld hl,(scratch+2) 
1b52				;call fourehexhl 
1b52			 
1b52 22 e4 e5			ld (os_cur_ptr),hl	 
1b55			 
1b55 e9				jp (hl) 
1b56			 
1b56			 
1b56			 
1b56			; TODO implement a basic monitor mode to start with 
1b56			 
1b56			 
1b56			 
1b56			 
1b56			 
1b56			 
1b56			 
1b56			 
1b56			 
1b56			; testing and demo code during development 
1b56			 
1b56			 
1b56 .. 00		str1: db "Enter some text...",0 
1b69 .. 00		clear: db "                    ",0 
1b7e			 
1b7e			demo: 
1b7e			 
1b7e			 
1b7e			 
1b7e			;	call update_display 
1b7e			 
1b7e				; init scratch input area for testing 
1b7e 21 c1 e2			ld hl, scratch	 
1b81 3e 00			ld a,0 
1b83 77				ld (hl),a 
1b84			 
1b84			 
1b84 3e 28		            LD   A, display_row_2 
1b86			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b86 11 56 1b		            LD   DE, str1 
1b89 cd cc 0b			call str_at_display 
1b8c			 
1b8c			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b8c			cloop:	 
1b8c 3e 50		            LD   A, display_row_3 
1b8e			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b8e 11 69 1b		            LD   DE, clear 
1b91			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b91 cd cc 0b				call str_at_display 
1b94 3e 78			ld a, display_row_4 
1b96 11 c6 1b			ld de, prompt 
1b99			 
1b99 cd cc 0b				call str_at_display 
1b9c cd dc 0b			call update_display 
1b9f			 
1b9f 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1ba1 16 0a			ld d, 10 
1ba3 21 c1 e2			ld hl, scratch	 
1ba6 cd 13 0e			call input_str 
1ba9			 
1ba9			;	call clear_display 
1ba9			;'	call update_display 
1ba9			 
1ba9 3e 00		            LD   A, display_row_1 
1bab			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bab 11 69 1b		            LD   DE, clear 
1bae cd cc 0b				call str_at_display 
1bb1			;            CALL fLCD_Str       ;Display string pointed to by DE 
1bb1 3e 00		            LD   A, display_row_1 
1bb3			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bb3 11 c1 e2		            LD   DE, scratch 
1bb6			;            CALL fLCD_Str       ;Display string pointed to by DE 
1bb6 cd cc 0b				call str_at_display 
1bb9 cd dc 0b			call update_display 
1bbc			 
1bbc 3e 00				ld a,0 
1bbe 21 c1 e2			ld hl, scratch 
1bc1 77				ld (hl),a 
1bc2			 
1bc2 00				nop 
1bc3 c3 8c 1b			jp cloop 
1bc6			 
1bc6			 
1bc6			 
1bc6			; OS Prompt 
1bc6			 
1bc6 .. 00		prompt: db ">",0 
1bc8 .. 00		endprg: db "?",0 
1bca			 
1bca			 
1bca			; handy next page prompt 
1bca			next_page_prompt: 
1bca e5				push hl 
1bcb d5				push de 
1bcc f5				push af 
1bcd c5				push bc 
1bce			 
1bce 3e 9f			ld a,display_row_4 + display_cols - 1 
1bd0 11 c8 1b		        ld de, endprg 
1bd3 cd cc 0b			call str_at_display 
1bd6 cd dc 0b			call update_display 
1bd9 cd 26 66			call cin_wait 
1bdc c1				pop bc 
1bdd f1				pop af 
1bde d1				pop de 
1bdf e1				pop hl 
1be0			 
1be0			 
1be0 c9				ret 
1be1			 
1be1			 
1be1			; forth parser 
1be1			 
1be1			; My forth kernel 
1be1			include "forth_kernel.asm" 
1be1			; 
1be1			; kernel to the forth OS 
1be1			 
1be1			DS_TYPE_STR: equ 1     ; string type 
1be1			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1be1			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1be1			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1be1			 
1be1			FORTH_PARSEV1: equ 0 
1be1			FORTH_PARSEV2: equ 0 
1be1			FORTH_PARSEV3: equ 0 
1be1			FORTH_PARSEV4: equ 0 
1be1			FORTH_PARSEV5: equ 1 
1be1			 
1be1			;if FORTH_PARSEV5 
1be1			;	FORTH_END_BUFFER: equ 0 
1be1			;else 
1be1			FORTH_END_BUFFER: equ 127 
1be1			;endif 
1be1			 
1be1			FORTH_TRUE: equ 1 
1be1			FORTH_FALSE: equ 0 
1be1			 
1be1			if FORTH_PARSEV4 
1be1			include "forth_stackops.asm" 
1be1			endif 
1be1			 
1be1			if FORTH_PARSEV5 
1be1			include "forth_stackopsv5.asm" 
1be1			 
1be1			; Stack operations for v5 parser on wards 
1be1			; * DATA stack 
1be1			; * LOOP stack 
1be1			; * RETURN stack 
1be1			 
1be1			 
1be1			 
1be1			FORTH_CHK_DSP_UNDER: macro 
1be1				push hl 
1be1				push de 
1be1				ld hl,(cli_data_sp) 
1be1				ld de, cli_data_stack 
1be1				call cmp16 
1be1				jp c, fault_dsp_under 
1be1				pop de 
1be1				pop hl 
1be1				endm 
1be1			 
1be1			 
1be1			FORTH_CHK_RSP_UNDER: macro 
1be1				push hl 
1be1				push de 
1be1				ld hl,(cli_ret_sp) 
1be1				ld de, cli_ret_stack 
1be1				call cmp16 
1be1				jp c, fault_rsp_under 
1be1				pop de 
1be1				pop hl 
1be1				endm 
1be1			 
1be1			FORTH_CHK_LOOP_UNDER: macro 
1be1				push hl 
1be1				push de 
1be1				ld hl,(cli_loop_sp) 
1be1				ld de, cli_loop_stack 
1be1				call cmp16 
1be1				jp c, fault_loop_under 
1be1				pop de 
1be1				pop hl 
1be1				endm 
1be1			 
1be1			FORTH_ERR_TOS_NOTSTR: macro 
1be1				; TOSO might need more for checks when used 
1be1				push af 
1be1				ld a,(hl) 
1be1				cp DS_TYPE_STR 
1be1				jp nz, type_faultn   
1be1				pop af 
1be1				endm 
1be1			 
1be1			FORTH_ERR_TOS_NOTNUM: macro 
1be1				push af 
1be1				ld a,(hl) 
1be1				cp DS_TYPE_INUM 
1be1				jp nz, type_faultn   
1be1				pop af 
1be1				endm 
1be1			 
1be1			 
1be1			; increase data stack pointer and save hl to it 
1be1				 
1be1			FORTH_DSP_NEXT: macro 
1be1				call macro_forth_dsp_next 
1be1				endm 
1be1			 
1be1			 
1be1			macro_forth_dsp_next: 
1be1				if DEBUG_FORTH_STACK_GUARD 
1be1 cd 55 62				call check_stacks 
1be4				endif 
1be4 e5				push hl 
1be5 d5				push de 
1be6 eb				ex de,hl 
1be7 2a ee e9			ld hl,(cli_data_sp) 
1bea 23				inc hl 
1beb 23				inc hl 
1bec			 
1bec			; PARSEV5 
1bec 23				inc hl 
1bed 22 ee e9			ld (cli_data_sp),hl 
1bf0 73				ld (hl), e 
1bf1 23				inc hl 
1bf2 72				ld (hl), d 
1bf3 d1				pop de 
1bf4 e1				pop hl 
1bf5				if DEBUG_FORTH_STACK_GUARD 
1bf5 cd 55 62				call check_stacks 
1bf8				endif 
1bf8 c9				ret 
1bf9			 
1bf9			 
1bf9			; increase ret stack pointer and save hl to it 
1bf9				 
1bf9			FORTH_RSP_NEXT: macro 
1bf9				call macro_forth_rsp_next 
1bf9				endm 
1bf9			 
1bf9			macro_forth_rsp_next: 
1bf9				if DEBUG_FORTH_STACK_GUARD 
1bf9 cd 55 62				call check_stacks 
1bfc				endif 
1bfc e5				push hl 
1bfd d5				push de 
1bfe eb				ex de,hl 
1bff 2a f2 e9			ld hl,(cli_ret_sp) 
1c02 23				inc hl 
1c03 23				inc hl 
1c04 22 f2 e9			ld (cli_ret_sp),hl 
1c07 73				ld (hl), e 
1c08 23				inc hl 
1c09 72				ld (hl), d 
1c0a d1				pop de 
1c0b e1				pop hl 
1c0c				if DEBUG_FORTH_STACK_GUARD 
1c0c cd 55 62				call check_stacks 
1c0f				endif 
1c0f c9				ret 
1c10			 
1c10			; get current ret stack pointer and save to hl  
1c10				 
1c10			FORTH_RSP_TOS: macro 
1c10				call macro_forth_rsp_tos 
1c10				endm 
1c10			 
1c10			macro_forth_rsp_tos: 
1c10				;push de 
1c10 2a f2 e9			ld hl,(cli_ret_sp) 
1c13 cd 4b 1c			call loadhlptrtohl 
1c16				;ld e, (hl) 
1c16				;inc hl 
1c16				;ld d, (hl) 
1c16				;ex de, hl 
1c16					if DEBUG_FORTH_WORDS 
1c16			;			DMARK "RST" 
1c16						CALLMONITOR 
1c16 cd 6f ee			call debug_vector  
1c19				endm  
# End of macro CALLMONITOR
1c19					endif 
1c19				;pop de 
1c19 c9				ret 
1c1a			 
1c1a			; pop ret stack pointer 
1c1a				 
1c1a			FORTH_RSP_POP: macro 
1c1a				call macro_forth_rsp_pop 
1c1a				endm 
1c1a			 
1c1a			 
1c1a			macro_forth_rsp_pop: 
1c1a				if DEBUG_FORTH_STACK_GUARD 
1c1a			;		DMARK "RPP" 
1c1a cd 55 62				call check_stacks 
1c1d					FORTH_CHK_RSP_UNDER 
1c1d e5				push hl 
1c1e d5				push de 
1c1f 2a f2 e9			ld hl,(cli_ret_sp) 
1c22 11 ac e9			ld de, cli_ret_stack 
1c25 cd 04 0e			call cmp16 
1c28 da 69 63			jp c, fault_rsp_under 
1c2b d1				pop de 
1c2c e1				pop hl 
1c2d				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c2d				endif 
1c2d e5				push hl 
1c2e 2a f2 e9			ld hl,(cli_ret_sp) 
1c31			 
1c31			 
1c31				if FORTH_ENABLE_FREE 
1c31			 
1c31					; get pointer 
1c31			 
1c31					push de 
1c31					push hl 
1c31			 
1c31					ld e, (hl) 
1c31					inc hl 
1c31					ld d, (hl) 
1c31			 
1c31					ex de, hl 
1c31					call free 
1c31			 
1c31					pop hl 
1c31					pop de 
1c31			 
1c31			 
1c31				endif 
1c31			 
1c31			 
1c31 2b				dec hl 
1c32 2b				dec hl 
1c33 22 f2 e9			ld (cli_ret_sp), hl 
1c36				; do stack underflow checks 
1c36 e1				pop hl 
1c37				if DEBUG_FORTH_STACK_GUARD 
1c37 cd 55 62				call check_stacks 
1c3a					FORTH_CHK_RSP_UNDER 
1c3a e5				push hl 
1c3b d5				push de 
1c3c 2a f2 e9			ld hl,(cli_ret_sp) 
1c3f 11 ac e9			ld de, cli_ret_stack 
1c42 cd 04 0e			call cmp16 
1c45 da 69 63			jp c, fault_rsp_under 
1c48 d1				pop de 
1c49 e1				pop hl 
1c4a				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c4a				endif 
1c4a c9				ret 
1c4b			 
1c4b			 
1c4b			 
1c4b			; routine to load word pointed to by hl into hl 
1c4b			 
1c4b			loadhlptrtohl: 
1c4b			 
1c4b d5				push de 
1c4c 5e				ld e, (hl) 
1c4d 23				inc hl 
1c4e 56				ld d, (hl) 
1c4f eb				ex de, hl 
1c50 d1				pop de 
1c51			 
1c51 c9				ret 
1c52			 
1c52			 
1c52			 
1c52			 
1c52			 
1c52			; push a number held in HL onto the data stack 
1c52			; entry point for pushing a value when already in hl used in function above 
1c52			 
1c52			forth_push_numhl: 
1c52			 
1c52 e5				push hl    ; save value to push 
1c53			 
1c53			if DEBUG_FORTH_PUSH 
1c53				; see if disabled 
1c53			 
1c53			 
1c53 f5				push af 
1c54 3a 6f ee			ld a,(debug_vector) 
1c57 fe c9			cp $c9   ; ret 
1c59			;	ld a, (os_view_disable) 
1c59			;	cp '*' 
1c59 28 34			jr z, .pskip2 
1c5b e5				push hl 
1c5c e5			push hl 
1c5d cd b9 0b			call clear_display 
1c60 e1			pop hl 
1c61 7c				ld a,h 
1c62 21 c6 e5			ld hl, os_word_scratch 
1c65 cd e7 10			call hexout 
1c68 e1				pop hl 
1c69 7d				ld a,l 
1c6a 21 c8 e5			ld hl, os_word_scratch+2 
1c6d cd e7 10			call hexout 
1c70			 
1c70 21 ca e5			ld hl, os_word_scratch+4 
1c73 3e 00			ld a,0 
1c75 77				ld (hl),a 
1c76 11 c6 e5			ld de,os_word_scratch 
1c79 3e 28				ld a, display_row_2 
1c7b cd cc 0b				call str_at_display 
1c7e 11 67 4d			ld de, .push_num 
1c81 3e 00			ld a, display_row_1 
1c83			 
1c83 cd cc 0b				call str_at_display 
1c86			 
1c86			 
1c86 cd dc 0b			call update_display 
1c89 cd f1 0a			call delay1s 
1c8c cd f1 0a			call delay1s 
1c8f			.pskip2:  
1c8f			 
1c8f f1				pop af 
1c90			endif	 
1c90			 
1c90			 
1c90				FORTH_DSP_NEXT 
1c90 cd e1 1b			call macro_forth_dsp_next 
1c93				endm 
# End of macro FORTH_DSP_NEXT
1c93			 
1c93 2a ee e9			ld hl, (cli_data_sp) 
1c96			 
1c96				; save item type 
1c96 3e 02			ld a,  DS_TYPE_INUM 
1c98 77				ld (hl), a 
1c99 23				inc hl 
1c9a			 
1c9a				; get word off stack 
1c9a d1				pop de 
1c9b 7b				ld a,e 
1c9c 77				ld (hl), a 
1c9d 23				inc hl 
1c9e 7a				ld a,d 
1c9f 77				ld (hl), a 
1ca0			 
1ca0			if DEBUG_FORTH_PUSH 
1ca0 2b				dec hl 
1ca1 2b				dec hl 
1ca2 2b				dec hl 
1ca3						DMARK "PH5" 
1ca3 f5				push af  
1ca4 3a b8 1c			ld a, (.dmark)  
1ca7 32 6b ee			ld (debug_mark),a  
1caa 3a b9 1c			ld a, (.dmark+1)  
1cad 32 6c ee			ld (debug_mark+1),a  
1cb0 3a ba 1c			ld a, (.dmark+2)  
1cb3 32 6d ee			ld (debug_mark+2),a  
1cb6 18 03			jr .pastdmark  
1cb8 ..			.dmark: db "PH5"  
1cbb f1			.pastdmark: pop af  
1cbc			endm  
# End of macro DMARK
1cbc				CALLMONITOR 
1cbc cd 6f ee			call debug_vector  
1cbf				endm  
# End of macro CALLMONITOR
1cbf			endif	 
1cbf			 
1cbf c9				ret 
1cc0			 
1cc0			 
1cc0			; Push a string to stack pointed to by hl 
1cc0			 
1cc0			forth_push_str: 
1cc0			 
1cc0			if DEBUG_FORTH_PUSH 
1cc0						DMARK "PSQ" 
1cc0 f5				push af  
1cc1 3a d5 1c			ld a, (.dmark)  
1cc4 32 6b ee			ld (debug_mark),a  
1cc7 3a d6 1c			ld a, (.dmark+1)  
1cca 32 6c ee			ld (debug_mark+1),a  
1ccd 3a d7 1c			ld a, (.dmark+2)  
1cd0 32 6d ee			ld (debug_mark+2),a  
1cd3 18 03			jr .pastdmark  
1cd5 ..			.dmark: db "PSQ"  
1cd8 f1			.pastdmark: pop af  
1cd9			endm  
# End of macro DMARK
1cd9				CALLMONITOR 
1cd9 cd 6f ee			call debug_vector  
1cdc				endm  
# End of macro CALLMONITOR
1cdc			endif	 
1cdc			    
1cdc e5				push hl 
1cdd e5				push hl 
1cde			 
1cde			;	ld a, 0   ; find end of string 
1cde cd 44 12			call strlenz 
1ce1			if DEBUG_FORTH_PUSH 
1ce1						DMARK "PQ2" 
1ce1 f5				push af  
1ce2 3a f6 1c			ld a, (.dmark)  
1ce5 32 6b ee			ld (debug_mark),a  
1ce8 3a f7 1c			ld a, (.dmark+1)  
1ceb 32 6c ee			ld (debug_mark+1),a  
1cee 3a f8 1c			ld a, (.dmark+2)  
1cf1 32 6d ee			ld (debug_mark+2),a  
1cf4 18 03			jr .pastdmark  
1cf6 ..			.dmark: db "PQ2"  
1cf9 f1			.pastdmark: pop af  
1cfa			endm  
# End of macro DMARK
1cfa				CALLMONITOR 
1cfa cd 6f ee			call debug_vector  
1cfd				endm  
# End of macro CALLMONITOR
1cfd			endif	 
1cfd eb				ex de, hl 
1cfe e1				pop hl   ; get ptr to start of string 
1cff			if DEBUG_FORTH_PUSH 
1cff						DMARK "PQ3" 
1cff f5				push af  
1d00 3a 14 1d			ld a, (.dmark)  
1d03 32 6b ee			ld (debug_mark),a  
1d06 3a 15 1d			ld a, (.dmark+1)  
1d09 32 6c ee			ld (debug_mark+1),a  
1d0c 3a 16 1d			ld a, (.dmark+2)  
1d0f 32 6d ee			ld (debug_mark+2),a  
1d12 18 03			jr .pastdmark  
1d14 ..			.dmark: db "PQ3"  
1d17 f1			.pastdmark: pop af  
1d18			endm  
# End of macro DMARK
1d18				CALLMONITOR 
1d18 cd 6f ee			call debug_vector  
1d1b				endm  
# End of macro CALLMONITOR
1d1b			endif	 
1d1b 19				add hl,de 
1d1c			if DEBUG_FORTH_PUSH 
1d1c						DMARK "PQE" 
1d1c f5				push af  
1d1d 3a 31 1d			ld a, (.dmark)  
1d20 32 6b ee			ld (debug_mark),a  
1d23 3a 32 1d			ld a, (.dmark+1)  
1d26 32 6c ee			ld (debug_mark+1),a  
1d29 3a 33 1d			ld a, (.dmark+2)  
1d2c 32 6d ee			ld (debug_mark+2),a  
1d2f 18 03			jr .pastdmark  
1d31 ..			.dmark: db "PQE"  
1d34 f1			.pastdmark: pop af  
1d35			endm  
# End of macro DMARK
1d35				CALLMONITOR 
1d35 cd 6f ee			call debug_vector  
1d38				endm  
# End of macro CALLMONITOR
1d38			endif	 
1d38			 
1d38 2b				dec hl    ; see if there is an optional trailing double quote 
1d39 7e				ld a,(hl) 
1d3a fe 22			cp '"' 
1d3c 20 03			jr nz, .strnoq 
1d3e 3e 00			ld a, 0      ; get rid of double quote 
1d40 77				ld (hl), a 
1d41 23			.strnoq: inc hl 
1d42			 
1d42 3e 00			ld a, 0 
1d44 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d45			 
1d45 13				inc de ; add one for the type string 
1d46 13				inc de ; add one for null term??? 
1d47			 
1d47				; tos is get string pointer again 
1d47				; de contains space to allocate 
1d47				 
1d47 d5				push de 
1d48			 
1d48 eb				ex de, hl 
1d49			 
1d49				;push af 
1d49			 
1d49			if DEBUG_FORTH_PUSH 
1d49						DMARK "PHm" 
1d49 f5				push af  
1d4a 3a 5e 1d			ld a, (.dmark)  
1d4d 32 6b ee			ld (debug_mark),a  
1d50 3a 5f 1d			ld a, (.dmark+1)  
1d53 32 6c ee			ld (debug_mark+1),a  
1d56 3a 60 1d			ld a, (.dmark+2)  
1d59 32 6d ee			ld (debug_mark+2),a  
1d5c 18 03			jr .pastdmark  
1d5e ..			.dmark: db "PHm"  
1d61 f1			.pastdmark: pop af  
1d62			endm  
# End of macro DMARK
1d62				CALLMONITOR 
1d62 cd 6f ee			call debug_vector  
1d65				endm  
# End of macro CALLMONITOR
1d65			endif	 
1d65 cd b9 12			call malloc	; on ret hl now contains allocated memory 
1d68				if DEBUG_FORTH_MALLOC_GUARD 
1d68 cc bf 4d				call z,malloc_error 
1d6b				endif 
1d6b			 
1d6b				 
1d6b c1				pop bc    ; get length 
1d6c d1				pop de   ;  get string start    
1d6d			 
1d6d				; hl has destination from malloc 
1d6d			 
1d6d eb				ex de, hl    ; prep for ldir 
1d6e			 
1d6e d5				push de   ; save malloc area for DSP later 
1d6f				;push hl   ; save malloc area for DSP later 
1d6f			 
1d6f			if DEBUG_FORTH_PUSH 
1d6f						DMARK "PHc" 
1d6f f5				push af  
1d70 3a 84 1d			ld a, (.dmark)  
1d73 32 6b ee			ld (debug_mark),a  
1d76 3a 85 1d			ld a, (.dmark+1)  
1d79 32 6c ee			ld (debug_mark+1),a  
1d7c 3a 86 1d			ld a, (.dmark+2)  
1d7f 32 6d ee			ld (debug_mark+2),a  
1d82 18 03			jr .pastdmark  
1d84 ..			.dmark: db "PHc"  
1d87 f1			.pastdmark: pop af  
1d88			endm  
# End of macro DMARK
1d88				CALLMONITOR 
1d88 cd 6f ee			call debug_vector  
1d8b				endm  
# End of macro CALLMONITOR
1d8b			endif	 
1d8b			 
1d8b			 
1d8b ed b0			ldir 
1d8d			 
1d8d			 
1d8d				; push malloc to data stack     macro?????  
1d8d			 
1d8d				FORTH_DSP_NEXT 
1d8d cd e1 1b			call macro_forth_dsp_next 
1d90				endm 
# End of macro FORTH_DSP_NEXT
1d90			 
1d90				; save value and type 
1d90			 
1d90 2a ee e9			ld hl, (cli_data_sp) 
1d93			 
1d93				; save item type 
1d93 3e 01			ld a,  DS_TYPE_STR 
1d95 77				ld (hl), a 
1d96 23				inc hl 
1d97			 
1d97				; get malloc word off stack 
1d97 d1				pop de 
1d98 73				ld (hl), e 
1d99 23				inc hl 
1d9a 72				ld (hl), d 
1d9b			 
1d9b			 
1d9b			 
1d9b			if DEBUG_FORTH_PUSH 
1d9b 2a ee e9			ld hl, (cli_data_sp) 
1d9e						DMARK "PHS" 
1d9e f5				push af  
1d9f 3a b3 1d			ld a, (.dmark)  
1da2 32 6b ee			ld (debug_mark),a  
1da5 3a b4 1d			ld a, (.dmark+1)  
1da8 32 6c ee			ld (debug_mark+1),a  
1dab 3a b5 1d			ld a, (.dmark+2)  
1dae 32 6d ee			ld (debug_mark+2),a  
1db1 18 03			jr .pastdmark  
1db3 ..			.dmark: db "PHS"  
1db6 f1			.pastdmark: pop af  
1db7			endm  
# End of macro DMARK
1db7				CALLMONITOR 
1db7 cd 6f ee			call debug_vector  
1dba				endm  
# End of macro CALLMONITOR
1dba			;	ex de,hl 
1dba			endif	 
1dba				; in case of spaces, skip the ptr past the copied string 
1dba				;pop af 
1dba				;ld (cli_origptr),hl 
1dba			 
1dba c9				ret 
1dbb			 
1dbb			 
1dbb			 
1dbb			; TODO ascii push input onto stack given hl to start of input 
1dbb			 
1dbb			; identify type 
1dbb			; if starts with a " then a string 
1dbb			; otherwise it is a number 
1dbb			;  
1dbb			; if a string 
1dbb			;     scan for ending " to get length of string to malloc for + 1 
1dbb			;     malloc 
1dbb			;     put pointer to string on stack first byte flags as string 
1dbb			; 
1dbb			; else a number 
1dbb			;    look for number format identifier 
1dbb			;    $xx hex 
1dbb			;    %xxxxx bin 
1dbb			;    xxxxx decimal 
1dbb			;    convert number to 16bit word.  
1dbb			;    malloc word + 1 with flag to identiy as num 
1dbb			;    put pointer to number on stack 
1dbb			;   
1dbb			;  
1dbb			  
1dbb			forth_apush: 
1dbb				; kernel push 
1dbb			 
1dbb			if DEBUG_FORTH_PUSH 
1dbb						DMARK "PSH" 
1dbb f5				push af  
1dbc 3a d0 1d			ld a, (.dmark)  
1dbf 32 6b ee			ld (debug_mark),a  
1dc2 3a d1 1d			ld a, (.dmark+1)  
1dc5 32 6c ee			ld (debug_mark+1),a  
1dc8 3a d2 1d			ld a, (.dmark+2)  
1dcb 32 6d ee			ld (debug_mark+2),a  
1dce 18 03			jr .pastdmark  
1dd0 ..			.dmark: db "PSH"  
1dd3 f1			.pastdmark: pop af  
1dd4			endm  
# End of macro DMARK
1dd4				CALLMONITOR 
1dd4 cd 6f ee			call debug_vector  
1dd7				endm  
# End of macro CALLMONITOR
1dd7			endif	 
1dd7				; identify input type 
1dd7			 
1dd7 7e				ld a,(hl) 
1dd8 fe 22			cp '"' 
1dda 28 0a			jr z, .fapstr 
1ddc fe 24			cp '$' 
1dde ca 06 1e			jp z, .faphex 
1de1 fe 25			cp '%' 
1de3 ca ee 1d			jp z, .fapbin 
1de6			;	cp 'b' 
1de6			;	jp z, .fabin 
1de6				; else decimal 
1de6			 
1de6				; TODO do decimal conversion 
1de6				; decimal is stored as a 16bit word 
1de6			 
1de6				; by default everything is a string if type is not detected 
1de6			.fapstr: ; 
1de6 fe 22			cp '"' 
1de8 20 01			jr nz, .strnoqu 
1dea 23				inc hl 
1deb			.strnoqu: 
1deb c3 c0 1c			jp forth_push_str 
1dee			 
1dee			 
1dee			 
1dee			.fapbin:    ; push a binary string.  
1dee 11 00 00			ld de, 0   ; hold a 16bit value 
1df1			 
1df1 23			.fapbinshift:	inc hl  
1df2 7e				ld a,(hl) 
1df3 fe 00			cp 0     ; done scanning  
1df5 28 0b			jr z, .fapbdone  	; got it in HL so push  
1df7			 
1df7				; left shift de 
1df7 eb				ex de, hl	 
1df8 29				add hl, hl 
1df9			 
1df9				; is 1 
1df9 fe 31			cp '1' 
1dfb 20 02			jr nz, .binzero 
1dfd cb 4d			bit 1, l 
1dff			.binzero: 
1dff eb				ex de, hl	 ; save current de 
1e00 18 ef			jr .fapbinshift 
1e02			 
1e02			.fapbdone: 
1e02 eb				ex de, hl 
1e03 c3 52 1c			jp forth_push_numhl 
1e06			 
1e06			 
1e06			.faphex:   ; hex is always stored as a 16bit word 
1e06				; skip number prefix 
1e06 23				inc hl 
1e07				; turn ascii into number 
1e07 cd 9d 11			call get_word_hl	; ret 16bit word in hl 
1e0a			 
1e0a c3 52 1c			jp forth_push_numhl 
1e0d			 
1e0d 00				 nop 
1e0e			 
1e0e			.fabin:   ; TODO bin conversion 
1e0e			 
1e0e			 
1e0e c9				ret 
1e0f			 
1e0f			 
1e0f			; get either a string ptr or a 16bit word from the data stack 
1e0f			 
1e0f			FORTH_DSP: macro 
1e0f				call macro_forth_dsp 
1e0f				endm 
1e0f			 
1e0f			macro_forth_dsp: 
1e0f				; data stack pointer points to current word on tos 
1e0f			 
1e0f 2a ee e9			ld hl,(cli_data_sp) 
1e12			 
1e12				if DEBUG_FORTH_PUSH 
1e12						DMARK "DSP" 
1e12 f5				push af  
1e13 3a 27 1e			ld a, (.dmark)  
1e16 32 6b ee			ld (debug_mark),a  
1e19 3a 28 1e			ld a, (.dmark+1)  
1e1c 32 6c ee			ld (debug_mark+1),a  
1e1f 3a 29 1e			ld a, (.dmark+2)  
1e22 32 6d ee			ld (debug_mark+2),a  
1e25 18 03			jr .pastdmark  
1e27 ..			.dmark: db "DSP"  
1e2a f1			.pastdmark: pop af  
1e2b			endm  
# End of macro DMARK
1e2b			 
1e2b cd f2 4d				call display_data_sp 
1e2e				;call break_point_state 
1e2e				;rst 030h 
1e2e				CALLMONITOR 
1e2e cd 6f ee			call debug_vector  
1e31				endm  
# End of macro CALLMONITOR
1e31				endif 
1e31			 
1e31 c9				ret 
1e32			 
1e32			; return hl to start of value on stack 
1e32			 
1e32			FORTH_DSP_VALUE: macro 
1e32				call macro_forth_dsp_value 
1e32				endm 
1e32			 
1e32			macro_forth_dsp_value: 
1e32			 
1e32				FORTH_DSP 
1e32 cd 0f 1e			call macro_forth_dsp 
1e35				endm 
# End of macro FORTH_DSP
1e35			 
1e35 d5				push de 
1e36			 
1e36 23				inc hl ; skip type 
1e37			 
1e37 5e				ld e, (hl) 
1e38 23				inc hl 
1e39 56				ld d, (hl) 
1e3a eb				ex de,hl  
1e3b			 
1e3b d1				pop de 
1e3c			 
1e3c c9				ret 
1e3d			 
1e3d			; return hl to start of value to second item on stack 
1e3d			 
1e3d			FORTH_DSP_VALUEM1: macro 
1e3d				call macro_forth_dsp_value_m1 
1e3d				endm 
1e3d			 
1e3d			macro_forth_dsp_value_m1: 
1e3d			 
1e3d				FORTH_DSP 
1e3d cd 0f 1e			call macro_forth_dsp 
1e40				endm 
# End of macro FORTH_DSP
1e40			 
1e40 2b				dec hl 
1e41 2b				dec hl 
1e42			;	dec hl 
1e42			 
1e42 d5				push de 
1e43			 
1e43 5e				ld e, (hl) 
1e44 23				inc hl 
1e45 56				ld d, (hl) 
1e46 eb				ex de,hl  
1e47			 
1e47 d1				pop de 
1e48			 
1e48 c9				ret 
1e49			 
1e49				 
1e49			 
1e49			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1e49			 
1e49			FORTH_DSP_POP: macro 
1e49				call macro_forth_dsp_pop 
1e49				endm 
1e49			 
1e49			 
1e49			; get the tos data type 
1e49			 
1e49			FORTH_DSP_TYPE:   macro 
1e49			 
1e49				;FORTH_DSP_VALUE 
1e49				FORTH_DSP 
1e49				 
1e49				; hl points to value 
1e49				; check type 
1e49			 
1e49				ld a,(hl) 
1e49			 
1e49				endm 
1e49			 
1e49			; load the tos value into hl 
1e49			 
1e49			 
1e49			FORTH_DSP_VALUEHL:  macro 
1e49				call macro_dsp_valuehl 
1e49				endm 
1e49			 
1e49			 
1e49			 
1e49			macro_dsp_valuehl: 
1e49				FORTH_DSP_VALUE 
1e49 cd 32 1e			call macro_forth_dsp_value 
1e4c				endm 
# End of macro FORTH_DSP_VALUE
1e4c			 
1e4c				;FORTH_ERR_TOS_NOTNUM 
1e4c			 
1e4c				;inc hl   ; skip type id 
1e4c			 
1e4c			;	push de 
1e4c			; 
1e4c			;	ld e, (hl) 
1e4c			;	inc hl 
1e4c			;	ld d, (hl) 
1e4c			;	ex de,hl  
1e4c			 
1e4c			;	pop de 
1e4c			 
1e4c				if DEBUG_FORTH_PUSH 
1e4c						DMARK "DVL" 
1e4c f5				push af  
1e4d 3a 61 1e			ld a, (.dmark)  
1e50 32 6b ee			ld (debug_mark),a  
1e53 3a 62 1e			ld a, (.dmark+1)  
1e56 32 6c ee			ld (debug_mark+1),a  
1e59 3a 63 1e			ld a, (.dmark+2)  
1e5c 32 6d ee			ld (debug_mark+2),a  
1e5f 18 03			jr .pastdmark  
1e61 ..			.dmark: db "DVL"  
1e64 f1			.pastdmark: pop af  
1e65			endm  
# End of macro DMARK
1e65				CALLMONITOR 
1e65 cd 6f ee			call debug_vector  
1e68				endm  
# End of macro CALLMONITOR
1e68				endif 
1e68 c9				ret 
1e69			 
1e69			forth_apushstrhl:      
1e69				; push of string requires use of cli_origptr 
1e69				; bodge use 
1e69			 
1e69				; get current cli_origptr, save, update with temp pointer  
1e69 ed 5b 3e ea		ld de, (cli_origptr) 
1e6d 22 3e ea			ld (cli_origptr), hl 
1e70 d5				push de 
1e71 cd bb 1d			call forth_apush 
1e74 d1				pop de 
1e75 ed 53 3e ea		ld (cli_origptr), de 
1e79 c9			        ret	 
1e7a			 
1e7a			 
1e7a			; increase loop stack pointer and save hl to it 
1e7a				 
1e7a			FORTH_LOOP_NEXT: macro 
1e7a				call macro_forth_loop_next 
1e7a				;nop 
1e7a				endm 
1e7a			 
1e7a			macro_forth_loop_next: 
1e7a				if DEBUG_FORTH_STACK_GUARD 
1e7a cd 55 62				call check_stacks 
1e7d				endif 
1e7d e5				push hl 
1e7e d5				push de 
1e7f eb				ex de,hl 
1e80 2a f0 e9			ld hl,(cli_loop_sp) 
1e83 23				inc hl 
1e84 23				inc hl 
1e85					if DEBUG_FORTH_WORDS 
1e85						DMARK "LNX" 
1e85 f5				push af  
1e86 3a 9a 1e			ld a, (.dmark)  
1e89 32 6b ee			ld (debug_mark),a  
1e8c 3a 9b 1e			ld a, (.dmark+1)  
1e8f 32 6c ee			ld (debug_mark+1),a  
1e92 3a 9c 1e			ld a, (.dmark+2)  
1e95 32 6d ee			ld (debug_mark+2),a  
1e98 18 03			jr .pastdmark  
1e9a ..			.dmark: db "LNX"  
1e9d f1			.pastdmark: pop af  
1e9e			endm  
# End of macro DMARK
1e9e						CALLMONITOR 
1e9e cd 6f ee			call debug_vector  
1ea1				endm  
# End of macro CALLMONITOR
1ea1					endif 
1ea1 22 f0 e9			ld (cli_loop_sp),hl 
1ea4 73				ld (hl), e 
1ea5 23				inc hl 
1ea6 72				ld (hl), d 
1ea7 d1				pop de    ; been reversed so save a swap on restore 
1ea8 e1				pop hl 
1ea9				if DEBUG_FORTH_STACK_GUARD 
1ea9 cd 55 62				call check_stacks 
1eac				endif 
1eac c9				ret 
1ead			 
1ead			; get current ret stack pointer and save to hl  
1ead				 
1ead			FORTH_LOOP_TOS: macro 
1ead				call macro_forth_loop_tos 
1ead				endm 
1ead			 
1ead			macro_forth_loop_tos: 
1ead d5				push de 
1eae 2a f0 e9			ld hl,(cli_loop_sp) 
1eb1 5e				ld e, (hl) 
1eb2 23				inc hl 
1eb3 56				ld d, (hl) 
1eb4 eb				ex de, hl 
1eb5 d1				pop de 
1eb6 c9				ret 
1eb7			 
1eb7			; pop loop stack pointer 
1eb7				 
1eb7			FORTH_LOOP_POP: macro 
1eb7				call macro_forth_loop_pop 
1eb7				endm 
1eb7			 
1eb7			 
1eb7			macro_forth_loop_pop: 
1eb7				if DEBUG_FORTH_STACK_GUARD 
1eb7					DMARK "LPP" 
1eb7 f5				push af  
1eb8 3a cc 1e			ld a, (.dmark)  
1ebb 32 6b ee			ld (debug_mark),a  
1ebe 3a cd 1e			ld a, (.dmark+1)  
1ec1 32 6c ee			ld (debug_mark+1),a  
1ec4 3a ce 1e			ld a, (.dmark+2)  
1ec7 32 6d ee			ld (debug_mark+2),a  
1eca 18 03			jr .pastdmark  
1ecc ..			.dmark: db "LPP"  
1ecf f1			.pastdmark: pop af  
1ed0			endm  
# End of macro DMARK
1ed0 cd 55 62				call check_stacks 
1ed3					FORTH_CHK_LOOP_UNDER 
1ed3 e5				push hl 
1ed4 d5				push de 
1ed5 2a f0 e9			ld hl,(cli_loop_sp) 
1ed8 11 2a e9			ld de, cli_loop_stack 
1edb cd 04 0e			call cmp16 
1ede da 6f 63			jp c, fault_loop_under 
1ee1 d1				pop de 
1ee2 e1				pop hl 
1ee3				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ee3				endif 
1ee3 e5				push hl 
1ee4 2a f0 e9			ld hl,(cli_loop_sp) 
1ee7 2b				dec hl 
1ee8 2b				dec hl 
1ee9 22 f0 e9			ld (cli_loop_sp), hl 
1eec				; TODO do stack underflow checks 
1eec e1				pop hl 
1eed				if DEBUG_FORTH_STACK_GUARD 
1eed cd 55 62				call check_stacks 
1ef0					FORTH_CHK_LOOP_UNDER 
1ef0 e5				push hl 
1ef1 d5				push de 
1ef2 2a f0 e9			ld hl,(cli_loop_sp) 
1ef5 11 2a e9			ld de, cli_loop_stack 
1ef8 cd 04 0e			call cmp16 
1efb da 6f 63			jp c, fault_loop_under 
1efe d1				pop de 
1eff e1				pop hl 
1f00				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f00				endif 
1f00 c9				ret 
1f01			 
1f01			macro_forth_dsp_pop: 
1f01			 
1f01 e5				push hl 
1f02			 
1f02				; release malloc data 
1f02			 
1f02				if DEBUG_FORTH_STACK_GUARD 
1f02 cd 55 62				call check_stacks 
1f05					FORTH_CHK_DSP_UNDER 
1f05 e5				push hl 
1f06 d5				push de 
1f07 2a ee e9			ld hl,(cli_data_sp) 
1f0a 11 28 e8			ld de, cli_data_stack 
1f0d cd 04 0e			call cmp16 
1f10 da 63 63			jp c, fault_dsp_under 
1f13 d1				pop de 
1f14 e1				pop hl 
1f15				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f15				endif 
1f15				;ld hl,(cli_data_sp) 
1f15			if DEBUG_FORTH_DOT 
1f15				DMARK "DPP" 
1f15 f5				push af  
1f16 3a 2a 1f			ld a, (.dmark)  
1f19 32 6b ee			ld (debug_mark),a  
1f1c 3a 2b 1f			ld a, (.dmark+1)  
1f1f 32 6c ee			ld (debug_mark+1),a  
1f22 3a 2c 1f			ld a, (.dmark+2)  
1f25 32 6d ee			ld (debug_mark+2),a  
1f28 18 03			jr .pastdmark  
1f2a ..			.dmark: db "DPP"  
1f2d f1			.pastdmark: pop af  
1f2e			endm  
# End of macro DMARK
1f2e				CALLMONITOR 
1f2e cd 6f ee			call debug_vector  
1f31				endm  
# End of macro CALLMONITOR
1f31			endif	 
1f31			 
1f31			 
1f31			if FORTH_ENABLE_DSPPOPFREE 
1f31			 
1f31				FORTH_DSP 
1f31 cd 0f 1e			call macro_forth_dsp 
1f34				endm 
# End of macro FORTH_DSP
1f34			 
1f34 7e				ld a, (hl) 
1f35 fe 01			cp DS_TYPE_STR 
1f37 20 23			jr nz, .skippopfree 
1f39			 
1f39				FORTH_DSP_VALUEHL 
1f39 cd 49 1e			call macro_dsp_valuehl 
1f3c				endm 
# End of macro FORTH_DSP_VALUEHL
1f3c 00				nop 
1f3d			if DEBUG_FORTH_DOT 
1f3d				DMARK "DPf" 
1f3d f5				push af  
1f3e 3a 52 1f			ld a, (.dmark)  
1f41 32 6b ee			ld (debug_mark),a  
1f44 3a 53 1f			ld a, (.dmark+1)  
1f47 32 6c ee			ld (debug_mark+1),a  
1f4a 3a 54 1f			ld a, (.dmark+2)  
1f4d 32 6d ee			ld (debug_mark+2),a  
1f50 18 03			jr .pastdmark  
1f52 ..			.dmark: db "DPf"  
1f55 f1			.pastdmark: pop af  
1f56			endm  
# End of macro DMARK
1f56				CALLMONITOR 
1f56 cd 6f ee			call debug_vector  
1f59				endm  
# End of macro CALLMONITOR
1f59			endif	 
1f59 cd 83 13			call free 
1f5c			.skippopfree: 
1f5c				 
1f5c			 
1f5c			endif 
1f5c			 
1f5c			if DEBUG_FORTH_DOT_KEY 
1f5c				DMARK "DP2" 
1f5c				CALLMONITOR 
1f5c			endif	 
1f5c			 
1f5c				; move pointer down 
1f5c			 
1f5c 2a ee e9			ld hl,(cli_data_sp) 
1f5f 2b				dec hl 
1f60 2b				dec hl 
1f61			; PARSEV5 
1f61 2b				dec hl 
1f62 22 ee e9			ld (cli_data_sp), hl 
1f65			 
1f65				if DEBUG_FORTH_STACK_GUARD 
1f65 cd 55 62				call check_stacks 
1f68					FORTH_CHK_DSP_UNDER 
1f68 e5				push hl 
1f69 d5				push de 
1f6a 2a ee e9			ld hl,(cli_data_sp) 
1f6d 11 28 e8			ld de, cli_data_stack 
1f70 cd 04 0e			call cmp16 
1f73 da 63 63			jp c, fault_dsp_under 
1f76 d1				pop de 
1f77 e1				pop hl 
1f78				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f78				endif 
1f78			 
1f78 e1				pop hl 
1f79			 
1f79 c9				ret 
1f7a			 
1f7a			getwordathl: 
1f7a				; hl points to an address 
1f7a				; load hl with the word at that address 
1f7a			 
1f7a d5				push de 
1f7b			 
1f7b 5e				ld e, (hl) 
1f7c 23				inc hl 
1f7d 56				ld d, (hl) 
1f7e eb				ex de, hl 
1f7f			 
1f7f d1				pop de 
1f80 c9				ret 
1f81			 
1f81			 
1f81			 
1f81			 
1f81			 
1f81			; eof 
1f81			 
# End of file forth_stackopsv5.asm
1f81			endif 
1f81			 
1f81			loadwordinhl:	 
1f81			 
1f81 d5				push de 
1f82			 
1f82 5e				ld e, (hl) 
1f83 23				inc hl 
1f84 56				ld d, (hl) 
1f85 eb				ex de,hl  
1f86			 
1f86 d1				pop de 
1f87			 
1f87 c9				ret 
1f88			 
1f88			user_word_eol:  
1f88				; hl contains the pointer to where to create a linked list item from the end 
1f88				; of the user dict to continue on at the system word dict 
1f88				 
1f88				; poke the stub of the word list linked list to repoint to rom words 
1f88			 
1f88				; stub format 
1f88				; db   word id 
1f88				; dw    link to next word 
1f88			        ; db char length of token 
1f88				; db string + 0 term 
1f88				; db exec code....  
1f88			 
1f88 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f8a 77				ld (hl), a		; word id 
1f8b 23				inc hl 
1f8c			 
1f8c 11 57 21			ld de, sysdict 
1f8f 73				ld (hl), e		; next word link ie system dict 
1f90 23				inc hl 
1f91 72				ld (hl), d		; next word link ie system dict 
1f92 23				inc hl	 
1f93			 
1f93			;	ld (hl), sysdict		; next word link ie system dict 
1f93			;	inc hl 
1f93			;	inc hl 
1f93			 
1f93			;	inc hl 
1f93			;	inc hl 
1f93			 
1f93 3e 02			ld a, 2			; word length is 0 
1f95 77				ld (hl), a	 
1f96 23				inc hl 
1f97			 
1f97 3e 7e			ld a, '~'			; word length is 0 
1f99 77				ld (hl), a	 
1f9a 23				inc hl 
1f9b 3e 00			ld a, 0			; save empty word 
1f9d 77				ld (hl), a 
1f9e			 
1f9e c9				ret 
1f9f			 
1f9f				 
1f9f			 
1f9f			forthexec_cleanup: 
1f9f				FORTH_RSP_POP 
1f9f cd 1a 1c			call macro_forth_rsp_pop 
1fa2				endm 
# End of macro FORTH_RSP_POP
1fa2 c9				ret 
1fa3			 
1fa3			forth_call_hl: 
1fa3				; taking hl 
1fa3 e5				push hl 
1fa4 c9				ret 
1fa5			 
1fa5			; this is called to reset Forth system but keep existing uwords etc 
1fa5			 
1fa5			forth_warmstart: 
1fa5				; setup stack over/under flow checks 
1fa5				if DEBUG_FORTH_STACK_GUARD 
1fa5 cd 3b 62				call chk_stk_init 
1fa8				endif 
1fa8			 
1fa8				; init stack pointers  - * these stacks go upwards *  
1fa8 21 ac e9			ld hl, cli_ret_stack 
1fab 22 f2 e9			ld (cli_ret_sp), hl	 
1fae				; set bottom of stack 
1fae 3e 00			ld a,0 
1fb0 77				ld (hl),a 
1fb1 23				inc hl 
1fb2 77				ld (hl),a 
1fb3			 
1fb3 21 28 e8			ld hl, cli_data_stack 
1fb6 22 ee e9			ld (cli_data_sp), hl	 
1fb9				; set bottom of stack 
1fb9 3e 00			ld a,0 
1fbb 77				ld (hl),a 
1fbc 23				inc hl 
1fbd 77				ld (hl),a 
1fbe			 
1fbe 21 2a e9			ld hl, cli_loop_stack 
1fc1 22 f0 e9			ld (cli_loop_sp), hl	 
1fc4				; set bottom of stack 
1fc4 3e 00			ld a,0 
1fc6 77				ld (hl),a 
1fc7 23				inc hl 
1fc8 77				ld (hl),a 
1fc9			 
1fc9				; init extent of current open file 
1fc9			 
1fc9 3e 00			ld a, 0 
1fcb 32 6a ea			ld (store_openext), a 
1fce			 
1fce c9				ret 
1fcf			 
1fcf			 
1fcf			 
1fcf			; Cold Start - this is called to setup the whole Forth system 
1fcf			 
1fcf			forth_init: 
1fcf			 
1fcf				; setup stack over/under flow checks 
1fcf			 
1fcf			;	if DEBUG_FORTH_STACK_GUARD 
1fcf			;		call chk_stk_init 
1fcf			;	endif 
1fcf			 
1fcf				; enable auto display updates (slow.....) 
1fcf			 
1fcf 3e 01			ld a, 1 
1fd1 32 3c ea			ld (cli_autodisplay), a 
1fd4			 
1fd4				; if storage is in use disable long reads for now 
1fd4 3e 00			ld a, 0 
1fd6 32 75 ea			ld (store_longread), a 
1fd9			 
1fd9			 
1fd9				; show start up screen 
1fd9			 
1fd9 cd b9 0b			call clear_display 
1fdc			 
1fdc 3e 00			ld a,0 
1fde 32 5e ea			ld (f_cursor_ptr), a 
1fe1			 
1fe1				; set start of word list in start of ram - for use when creating user words 
1fe1			 
1fe1 21 47 66			ld hl, baseram 
1fe4 22 be e5			ld (os_last_new_uword), hl 
1fe7 cd 88 1f			call user_word_eol 
1fea				 
1fea			;		call display_data_sp 
1fea			;		call next_page_prompt 
1fea			 
1fea			 
1fea			 
1fea			 
1fea c9				ret 
1feb			 
1feb .. 00		.bootforth: db " Forth Kernel Init ",0 
1fff			 
1fff			; TODO push to stack 
1fff			 
1fff			;  
1fff			 
1fff			if FORTH_PARSEV2 
1fff			 
1fff			 
1fff				include "forth_parserv2.asm" 
1fff			 
1fff			endif 
1fff			 
1fff			 
1fff			; parse cli version 1 
1fff			 
1fff			if FORTH_PARSEV1 
1fff			 
1fff			 
1fff			 
1fff			      include "forth_parserv1.asm" 
1fff			endif 
1fff				 
1fff			if FORTH_PARSEV3 
1fff			 
1fff			 
1fff			 
1fff			      include "forth_parserv3.asm" 
1fff				include "forth_wordsv3.asm" 
1fff			endif 
1fff			 
1fff			if FORTH_PARSEV4 
1fff			 
1fff			 
1fff			 
1fff			      include "forth_parserv4.asm" 
1fff				include "forth_wordsv4.asm" 
1fff			endif 
1fff			 
1fff			if FORTH_PARSEV5 
1fff			 
1fff			 
1fff			 
1fff			      include "forth_parserv5.asm" 
1fff			 
1fff			 
1fff			; A better parser without using malloc and string copies all over the place.  
1fff			; Exec in situ should be faster 
1fff			 
1fff			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1fff			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1fff			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1fff			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1fff			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1fff			WORD_SYS_END: equ 0   ; Opcode for all user words 
1fff			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1fff			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1fff			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1fff			 
1fff			; Core word preamble macro 
1fff			 
1fff			CWHEAD:   macro nxtword opcode lit len opflags 
1fff				db WORD_SYS_CORE+opcode             
1fff				; internal op code number 
1fff				dw nxtword            
1fff				; link to next dict word block 
1fff				db len + 1 
1fff				; literal length of dict word inc zero term 
1fff				db lit,0              
1fff				; literal dict word 
1fff			        ; TODO db opflags        
1fff				endm 
1fff			 
1fff			 
1fff			NEXTW: macro  
1fff				jp macro_next 
1fff				endm 
1fff			 
1fff			macro_next: 
1fff			if DEBUG_FORTH_PARSE_KEY 
1fff				DMARK "NXT" 
1fff				CALLMONITOR 
1fff			endif	 
1fff			;	inc hl  ; skip token null term  
1fff ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2003 ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2007 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
200a			if DEBUG_FORTH_PARSE_KEY 
200a				DMARK "}AA" 
200a				CALLMONITOR 
200a			endif	 
200a c3 0d 21			jp execnext 
200d				;jp exec1 
200d			       
200d			 
200d			 
200d			; Another go at the parser to compile  
200d			 
200d			 
200d			; TODO rework parser to change all of the string words to byte tokens 
200d			; TODO do a search for  
200d			 
200d			; TODO first run normal parser to zero term sections 
200d			; TODO for each word do a token look up to get the op code 
200d			; TODO need some means to flag to the exec that this is a byte code form    
200d			 
200d			 
200d			forthcompile: 
200d			 
200d			; 
200d			; line parse: 
200d			;       parse raw input buffer 
200d			;       tokenise the words 
200d			;       malloc new copy (for looping etc) 
200d			;       copy to malloc + current pc in line to start of string and add line term 
200d			;       save on new rsp 
200d			; 
200d			 
200d			; hl to point to the line to tokenise 
200d			 
200d			;	push hl 
200d 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2010			 
2010			;	ld a,0		; string term on input 
2010			;	call strlent 
2010			 
2010			;	ld (os_tok_len), hl	 ; save string length 
2010			 
2010			;if DEBUG_FORTH_TOK 
2010			;	ex de,hl		 
2010			;endif 
2010			 
2010			;	pop hl 		; get back string pointer 
2010			 
2010			if DEBUG_FORTH_TOK 
2010						DMARK "TOc" 
2010				CALLMONITOR 
2010			endif 
2010 7e			.cptoken2:    ld a,(hl) 
2011 23				inc hl 
2012 fe 7f			cp FORTH_END_BUFFER 
2014 28 29			jr z, .cptokendone2 
2016 fe 00			cp 0 
2018 28 25			jr z, .cptokendone2 
201a fe 22			cp '"' 
201c 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
201e fe 20			cp ' ' 
2020 20 ee			jr nz,  .cptoken2 
2022			 
2022			; TODO consume comments held between ( and ) 
2022			 
2022				; we have a space so change to zero term for dict match later 
2022 2b				dec hl 
2023 3e 00			ld a,0 
2025 77				ld (hl), a 
2026 23				inc hl 
2027 18 e7			jr .cptoken2 
2029				 
2029			 
2029			.cptokenstr2: 
2029				; skip all white space until either eol (because forgot to term) or end double quote 
2029			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2029				;inc hl ; skip current double quote 
2029 7e				ld a,(hl) 
202a 23				inc hl 
202b fe 22			cp '"' 
202d 28 e1			jr z, .cptoken2 
202f fe 7f			cp FORTH_END_BUFFER 
2031 28 0c			jr z, .cptokendone2 
2033 fe 00			cp 0 
2035 28 08			jr z, .cptokendone2 
2037 fe 20			cp ' ' 
2039 28 02			jr z, .cptmp2 
203b 18 ec			jr .cptokenstr2 
203d			 
203d			.cptmp2:	; we have a space so change to zero term for dict match later 
203d				;dec hl 
203d				;ld a,"-"	; TODO remove this when working 
203d				;ld (hl), a 
203d				;inc hl 
203d 18 ea			jr .cptokenstr2 
203f			 
203f			.cptokendone2: 
203f				;inc hl 
203f 3e 7f			ld a, FORTH_END_BUFFER 
2041 77				ld (hl),a 
2042 23				inc hl 
2043 3e 21			ld a, '!' 
2045 77				ld (hl),a 
2046			 
2046 2a c2 e5			ld hl,(os_tok_ptr) 
2049			         
2049			if DEBUG_FORTH_TOK 
2049						DMARK "Tc1" 
2049				CALLMONITOR 
2049			endif 
2049			 
2049				; push exec string to top of return stack 
2049				FORTH_RSP_NEXT 
2049 cd f9 1b			call macro_forth_rsp_next 
204c				endm 
# End of macro FORTH_RSP_NEXT
204c c9				ret 
204d			 
204d			; Another go at the parser need to simplify the process 
204d			 
204d			forthparse: 
204d			 
204d			; 
204d			; line parse: 
204d			;       parse raw input buffer 
204d			;       tokenise the words 
204d			;       malloc new copy (for looping etc) 
204d			;       copy to malloc + current pc in line to start of string and add line term 
204d			;       save on new rsp 
204d			; 
204d			 
204d			; hl to point to the line to tokenise 
204d			 
204d			;	push hl 
204d 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2050			 
2050			;	ld a,0		; string term on input 
2050			;	call strlent 
2050			 
2050			;	ld (os_tok_len), hl	 ; save string length 
2050			 
2050			;if DEBUG_FORTH_TOK 
2050			;	ex de,hl		 
2050			;endif 
2050			 
2050			;	pop hl 		; get back string pointer 
2050			 
2050			if DEBUG_FORTH_TOK 
2050						DMARK "TOK" 
2050				CALLMONITOR 
2050			endif 
2050 7e			.ptoken2:    ld a,(hl) 
2051 23				inc hl 
2052 fe 7f			cp FORTH_END_BUFFER 
2054 28 29			jr z, .ptokendone2 
2056 fe 00			cp 0 
2058 28 25			jr z, .ptokendone2 
205a fe 22			cp '"' 
205c 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
205e fe 20			cp ' ' 
2060 20 ee			jr nz,  .ptoken2 
2062			 
2062			; TODO consume comments held between ( and ) 
2062			 
2062				; we have a space so change to zero term for dict match later 
2062 2b				dec hl 
2063 3e 00			ld a,0 
2065 77				ld (hl), a 
2066 23				inc hl 
2067 18 e7			jr .ptoken2 
2069				 
2069			 
2069			.ptokenstr2: 
2069				; skip all white space until either eol (because forgot to term) or end double quote 
2069			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2069				;inc hl ; skip current double quote 
2069 7e				ld a,(hl) 
206a 23				inc hl 
206b fe 22			cp '"' 
206d 28 e1			jr z, .ptoken2 
206f fe 7f			cp FORTH_END_BUFFER 
2071 28 0c			jr z, .ptokendone2 
2073 fe 00			cp 0 
2075 28 08			jr z, .ptokendone2 
2077 fe 20			cp ' ' 
2079 28 02			jr z, .ptmp2 
207b 18 ec			jr .ptokenstr2 
207d			 
207d			.ptmp2:	; we have a space so change to zero term for dict match later 
207d				;dec hl 
207d				;ld a,"-"	; TODO remove this when working 
207d				;ld (hl), a 
207d				;inc hl 
207d 18 ea			jr .ptokenstr2 
207f			 
207f			.ptokendone2: 
207f				;inc hl 
207f 3e 7f			ld a, FORTH_END_BUFFER 
2081 77				ld (hl),a 
2082 23				inc hl 
2083 3e 21			ld a, '!' 
2085 77				ld (hl),a 
2086			 
2086 2a c2 e5			ld hl,(os_tok_ptr) 
2089			         
2089			if DEBUG_FORTH_TOK 
2089						DMARK "TK1" 
2089				CALLMONITOR 
2089			endif 
2089			 
2089				; push exec string to top of return stack 
2089				FORTH_RSP_NEXT 
2089 cd f9 1b			call macro_forth_rsp_next 
208c				endm 
# End of macro FORTH_RSP_NEXT
208c c9				ret 
208d			 
208d			; 
208d			;	; malloc size + buffer pointer + if is loop flag 
208d			;	ld hl,(os_tok_len) 		 ; get string length 
208d			; 
208d			;	ld a,l 
208d			; 
208d			;	cp 0			; we dont want to use a null string 
208d			;	ret z 
208d			; 
208d			;;	add 3    ; prefix malloc with buffer for current word ptr 
208d			; 
208d			;	add 5     ; TODO when certain not over writing memory remove 
208d			; 
208d			;		 
208d			; 
208d			;if DEBUG_FORTH_TOK 
208d			;			DMARK "TKE" 
208d			;	CALLMONITOR 
208d			;endif 
208d			; 
208d			;	ld l,a 
208d			;	ld h,0 
208d			;;	push hl   ; save required space for the copy later 
208d			;	call malloc 
208d			;if DEBUG_FORTH_TOK 
208d			;			DMARK "TKM" 
208d			;	CALLMONITOR 
208d			;endif 
208d			;	if DEBUG_FORTH_MALLOC_GUARD 
208d			;		push af 
208d			;		call ishlzero 
208d			;;		ld a, l 
208d			;;		add h 
208d			;;		cp 0 
208d			;		pop af 
208d			;		 
208d			;		call z,malloc_error 
208d			;	endif 
208d			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
208d			; 
208d			; 
208d			;if DEBUG_FORTH_TOK 
208d			;			DMARK "TKR" 
208d			;	CALLMONITOR 
208d			;endif 
208d			; 
208d			;	FORTH_RSP_NEXT 
208d			; 
208d			;	;inc hl	 ; go past current buffer pointer 
208d			;	;inc hl 
208d			;	;inc hl   ; and past if loop flag 
208d			;		; TODO Need to set flag  
208d			; 
208d			;	 
208d			;	 
208d			;	ex de,hl	; malloc is dest 
208d			;	ld hl, (os_tok_len) 
208d			;;	pop bc 
208d			;	ld c, l                
208d			;	ld b,0 
208d			;	ld hl, (os_tok_ptr) 
208d			; 
208d			;if DEBUG_FORTH_TOK 
208d			;			DMARK "TKT" 
208d			;	CALLMONITOR 
208d			;endif 
208d			; 
208d			;	; do str cpy 
208d			; 
208d			;	ldir      ; copy byte in hl to de 
208d			; 
208d			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
208d			; 
208d			;if DEBUG_FORTH_TOK 
208d			; 
208d			;			DMARK "TKY" 
208d			;	CALLMONITOR 
208d			;endif 
208d			;	;ld a,0 
208d			;	;ld a,FORTH_END_BUFFER 
208d			;	ex de, hl 
208d			;	;dec hl			 ; go back over the space delim at the end of word 
208d			;	;ld (hl),a 
208d			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
208d			;	ld a,FORTH_END_BUFFER 
208d			;	ld (hl),a 
208d			;	inc hl 
208d			;	ld a,FORTH_END_BUFFER 
208d			;	ld (hl),a 
208d			; 
208d			;	; init the malloc area data 
208d			;	; set pc for in current area 
208d			;	;ld hl, (os_tok_malloc) 
208d			;	;inc hl 
208d			;	;inc hl 
208d			;	;inc hl 
208d			;	;ex de,hl 
208d			;	;ld hl, (os_tok_malloc) 
208d			;	;ld (hl),e 
208d			;	;inc hl 
208d			;	;ld (hl),d 
208d			; 
208d			; 
208d			;	ld hl,(os_tok_malloc) 
208d			;if DEBUG_FORTH_PARSE_KEY 
208d			;			DMARK "TKU" 
208d			;	CALLMONITOR 
208d			;endif 
208d			; 
208d			;	ret 
208d			 
208d			forthexec: 
208d			 
208d			; line exec: 
208d			; forth parser 
208d			 
208d			; 
208d			;       get current exec line on rsp 
208d			 
208d				FORTH_RSP_TOS 
208d cd 10 1c			call macro_forth_rsp_tos 
2090				endm 
# End of macro FORTH_RSP_TOS
2090			 
2090			;       restore current pc - hl points to malloc of data 
2090			 
2090				;ld e, (hl) 
2090				;inc hl 
2090				;ld d, (hl) 
2090				;ex de,hl 
2090			 
2090			 
2090			exec1: 
2090 22 c2 e5			ld (os_tok_ptr), hl 
2093			 
2093				; copy our PC to working vars  
2093 22 40 ea			ld (cli_ptr), hl 
2096 22 3e ea			ld (cli_origptr), hl 
2099			 
2099 7e				ld a,(hl) 
209a fe 7f			cp FORTH_END_BUFFER 
209c c8				ret z 
209d			 
209d				; skip any nulls 
209d			 
209d fe 00			cp 0 
209f 20 03			jr nz, .execword 
20a1 23				inc hl 
20a2 18 ec			jr exec1 
20a4			 
20a4			 
20a4			.execword: 
20a4			 
20a4			 
20a4			 
20a4			if DEBUG_FORTH_PARSE_KEY 
20a4						DMARK "KYQ" 
20a4				CALLMONITOR 
20a4			endif 
20a4			;       while at start of word: 
20a4			; get start of dict (in user area first) 
20a4			 
20a4 21 47 66		ld hl, baseram 
20a7			;ld hl, sysdict 
20a7 22 42 ea		ld (cli_nextword),hl 
20aa			;           match word at pc 
20aa			;           exec word 
20aa			;           or push to dsp 
20aa			;           forward to next token 
20aa			;           if line term pop rsp and exit 
20aa			;        
20aa			 
20aa			if DEBUG_FORTH_PARSE_KEY 
20aa						DMARK "KYq" 
20aa				CALLMONITOR 
20aa			endif 
20aa			 
20aa			; 
20aa			; word comp 
20aa			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
20aa			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
20aa			;    move to start of word  
20aa			;    compare word to cli_token 
20aa			 
20aa			.execpnword:	; HL at start of a word in the dictionary to check 
20aa			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
20aa			;	ld (cli_ptr), hl 
20aa			 
20aa 2a 42 ea			ld hl,(cli_nextword) 
20ad			 
20ad cd 50 21			call forth_tok_next 
20b0			; tok next start here 
20b0			;	; TODO skip compiled symbol for now 
20b0			;	inc hl 
20b0			; 
20b0			;	; save pointer to next word 
20b0			; 
20b0			;	; hl now points to the address of the next word pointer  
20b0			;	ld e, (hl) 
20b0			;	inc hl 
20b0			;	ld d, (hl) 
20b0			;	inc l 
20b0			; 
20b0			;	ex de,hl 
20b0			;if DEBUG_FORTH_PARSE_NEXTWORD 
20b0			;	push bc 
20b0			;	ld bc, (cli_nextword) 
20b0			;			DMARK "NXW" 
20b0			;	CALLMONITOR 
20b0			;	pop bc 
20b0			;endif 
20b0			; tok next end here 
20b0 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
20b3 eb				ex de, hl 
20b4			 
20b4			 
20b4				; save the pointer of the current token - 1 to check against 
20b4				 
20b4 22 46 ea			ld (cli_token), hl   
20b7				; TODO maybe remove below save if no debug 
20b7				; save token string ptr for any debug later 
20b7 23				inc hl  
20b8 22 48 ea			ld (cli_origtoken), hl 
20bb 2b				dec hl 
20bc				; save pointer to the start of the next dictionay word 
20bc 7e				ld a,(hl)   ; get string length 
20bd 47				ld b,a 
20be			.execpnwordinc:  
20be 23				inc hl 
20bf 10 fd			djnz .execpnwordinc 
20c1 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
20c4			 
20c4				; now check the word token against the string being parsed 
20c4			 
20c4 2a 46 ea			ld hl,(cli_token) 
20c7 23				inc hl     ; skip string length (use zero term instead to end) 
20c8 22 46 ea			ld (cli_token), hl 
20cb			 
20cb			if DEBUG_FORTH_PARSE_KEY 
20cb						DMARK "KY2" 
20cb			endif 
20cb			if DEBUG_FORTH_PARSE_EXEC 
20cb				; see if disabled 
20cb			 
20cb			;	ld a, (os_view_disable) 
20cb			;	cp '*' 
20cb				ld a, (debug_vector) 
20cb				cp $c9   ; RET  
20cb				jr z, .skip 
20cb			 
20cb				push hl 
20cb				push hl 
20cb				call clear_display 
20cb				ld de, .compword 
20cb				ld a, display_row_1 
20cb				call str_at_display 
20cb				pop de 
20cb				ld a, display_row_2 
20cb				call str_at_display 
20cb				ld hl,(cli_ptr) 
20cb				ld a,(hl) 
20cb			        ld hl, os_word_scratch 
20cb				ld (hl),a 
20cb				ld a,0 
20cb				inc hl 
20cb				ld (hl),a 	 
20cb				ld de, os_word_scratch 
20cb				ld a, display_row_2+10 
20cb				call str_at_display 
20cb				call update_display 
20cb				ld a, 100 
20cb				call aDelayInMS 
20cb				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20cb				call delay250ms 
20cb				endif 
20cb				pop hl 
20cb			.skip:  
20cb			endif	 
20cb			.execpnchar:    ; compare char between token and string to parse 
20cb			 
20cb			if DEBUG_FORTH_PARSE_KEY 
20cb						DMARK "Ky3" 
20cb			endif 
20cb			if DEBUG_FORTH_PARSE_EXEC 
20cb				; see if disabled 
20cb			 
20cb			;	ld a, (os_view_disable) 
20cb			;	cp '*' 
20cb				ld a, (debug_vector) 
20cb				cp $C9  ; RET 
20cb				jr z, .skip2 
20cb			 
20cb			;	call clear_display 
20cb			ld hl,(cli_token) 
20cb			ld a,(hl) 
20cb			ld (os_word_scratch),a 
20cb				ld hl,(cli_ptr) 
20cb			ld a,(hl) 
20cb				ld (os_word_scratch+1),a 
20cb				ld a,0 
20cb				ld (os_word_scratch+2),a 
20cb				ld de,os_word_scratch 
20cb				ld a,display_row_4 
20cb				call str_at_display 
20cb				call update_display 
20cb			.skip2:  
20cb			endif 
20cb 2a 46 ea			ld hl,(cli_token) 
20ce 7e				ld a, (hl)	 ; char in word token 
20cf 23				inc hl 		; move to next char 
20d0 22 46 ea			ld (cli_token), hl ; and save it 
20d3 47				ld b,a 
20d4			 
20d4 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
20d7 7e				ld a,(hl) 
20d8 23				inc hl 
20d9 22 40 ea			ld (cli_ptr), hl		; move to next char 
20dc cd 3b 12			call toUpper 		; make sure the input string matches case 
20df			 
20df			if DEBUG_FORTH_PARSE 
20df			endif 
20df			 
20df				; input stream end of token is a space so get rid of it 
20df			 
20df			;	cp ' ' 
20df			;	jr nz, .pnskipspace 
20df			; 
20df			;	ld a, 0		; make same term as word token term 
20df			; 
20df			;.pnskipspace: 
20df			 
20df			if DEBUG_FORTH_PARSE_KEY 
20df						DMARK "KY7" 
20df			endif 
20df b8				cp b 
20e0 c2 f6 20			jp nz, .execpnskipword	 ; no match so move to next word 
20e3				 
20e3			;    if same 
20e3			;       scan for string terms 0 for token and 32 for input 
20e3			 
20e3				 
20e3			if DEBUG_FORTH_PARSE_KEY 
20e3						DMARK "KY8" 
20e3			endif 
20e3			 
20e3 80				add b			 
20e4 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
20e6							; TODO need to make sure last word in zero term string is accounted for 
20e6 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
20e8			 
20e8			 
20e8				; at end of both strings so both are exact match 
20e8			 
20e8			;       skip ptr for next word 
20e8			 
20e8 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
20eb 23				inc hl			 ; at next char 
20ec 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
20ef 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
20f2				 
20f2				 
20f2			if DEBUG_FORTH_PARSE_KEY 
20f2						DMARK "KY3" 
20f2			endif 
20f2			 
20f2			 
20f2			 
20f2			;       exec code block 
20f2			if DEBUG_FORTH_JP 
20f2				call clear_display 
20f2				call update_display 
20f2				call delay1s 
20f2				ld hl, (cli_execword)     ; save for next check if no match on this word 
20f2				ld a,h 
20f2				ld hl, os_word_scratch 
20f2				call hexout 
20f2				ld hl, (cli_execword)     ; save for next check if no match on this word 
20f2				ld a,l 
20f2				ld hl, os_word_scratch+2 
20f2				call hexout 
20f2				ld hl, os_word_scratch+4 
20f2				ld a,0 
20f2				ld (hl),a 
20f2				ld de,os_word_scratch 
20f2				call str_at_display 
20f2					ld a, display_row_2 
20f2					call str_at_display 
20f2				ld de, (cli_origtoken) 
20f2				ld a, display_row_1+10 
20f2					call str_at_display 
20f2			 
20f2				ld a,display_row_1 
20f2				ld de, .foundword 
20f2				ld a, display_row_3 
20f2				call str_at_display 
20f2				call update_display 
20f2				call delay1s 
20f2				call delay1s 
20f2				call delay1s 
20f2			endif 
20f2			 
20f2			if DEBUG_FORTH_PARSE_KEY 
20f2						DMARK "KYj" 
20f2			endif 
20f2				; TODO save the word pointer in this exec 
20f2			 
20f2 2a 44 ea			ld hl,(cli_execword) 
20f5 e9				jp (hl) 
20f6			 
20f6			 
20f6			;    if not same 
20f6			;	scan for zero term 
20f6			;	get ptr for next word 
20f6			;	goto word comp 
20f6			 
20f6			.execpnskipword:	; get pointer to next word 
20f6 2a 42 ea			ld hl,(cli_nextword) 
20f9			 
20f9 7e				ld a,(hl) 
20fa fe 00			cp WORD_SYS_END 
20fc			;	cp 0 
20fc 28 09			jr z, .execendofdict			 ; at end of words 
20fe			 
20fe			if DEBUG_FORTH_PARSE_KEY 
20fe						DMARK "KY4" 
20fe			endif 
20fe			if DEBUG_FORTH_PARSE_EXEC 
20fe			 
20fe				; see if disabled 
20fe			 
20fe			;	ld a, (os_view_disable) 
20fe			;	cp '*' 
20fe				ld a,(debug_vector) 
20fe				cp $c9   ; RET 
20fe				jr z, .noskip 
20fe			 
20fe			 
20fe				ld de, .nowordfound 
20fe				ld a, display_row_3 
20fe				call str_at_display 
20fe				call update_display 
20fe				ld a, 100 
20fe				call aDelayInMS 
20fe				 
20fe				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20fe					call delay250ms 
20fe				endif 
20fe			.noskip:  
20fe			 
20fe			endif	 
20fe			 
20fe 2a 3e ea			ld hl,(cli_origptr) 
2101 22 40 ea			ld (cli_ptr),hl 
2104			 
2104			if DEBUG_FORTH_PARSE_KEY 
2104						DMARK "KY5" 
2104			endif 
2104 c3 aa 20			jp .execpnword			; else go to next word 
2107			 
2107			.execendofdict:  
2107			 
2107			if DEBUG_FORTH_PARSE_KEY 
2107						DMARK "KYe" 
2107			endif 
2107			if DEBUG_FORTH_PARSE_EXEC 
2107				; see if disabled 
2107			 
2107			;	ld a, (os_view_disable) 
2107			;	cp '*' 
2107				ld a,(debug_vector) 
2107				cp $c9   ; ret 
2107				jr z, .ispskip 
2107			 
2107				call clear_display 
2107				call update_display 
2107				call delay1s 
2107				ld de, (cli_origptr) 
2107				ld a, display_row_1 
2107				call str_at_display 
2107				 
2107				ld de, .enddict 
2107				ld a, display_row_3 
2107				call str_at_display 
2107				call update_display 
2107				ld a, 100 
2107				call aDelayInMS 
2107				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2107				call delay1s 
2107				call delay1s 
2107				call delay1s 
2107				endif 
2107			.ispskip:  
2107				 
2107			endif	 
2107			 
2107			 
2107			 
2107				; if the word is not a keyword then must be a literal so push it to stack 
2107			 
2107			; push token to stack to end of word 
2107			 
2107				STACKFRAME ON $1efe $2f9f 
2107				if DEBUG_STACK_IMB 
2107					if ON 
2107						exx 
2107						ld de, $1efe 
2107						ld a, d 
2107						ld hl, curframe 
2107						call hexout 
2107						ld a, e 
2107						ld hl, curframe+2 
2107						call hexout 
2107						ld hl, $1efe 
2107						push hl 
2107						ld hl, $2f9f 
2107						push hl 
2107						exx 
2107					endif 
2107				endif 
2107			endm 
# End of macro STACKFRAME
2107			 
2107 2a c2 e5		ld hl,(os_tok_ptr) 
210a cd bb 1d		call forth_apush 
210d			 
210d				STACKFRAMECHK ON $1efe $2f9f 
210d				if DEBUG_STACK_IMB 
210d					if ON 
210d						exx 
210d						ld hl, $2f9f 
210d						pop de   ; $2f9f 
210d						call cmp16 
210d						jr nz, .spnosame 
210d						ld hl, $1efe 
210d						pop de   ; $1efe 
210d						call cmp16 
210d						jr z, .spfrsame 
210d						.spnosame: call showsperror 
210d						.spfrsame: nop 
210d						exx 
210d					endif 
210d				endif 
210d			endm 
# End of macro STACKFRAMECHK
210d			 
210d			execnext: 
210d			 
210d			if DEBUG_FORTH_PARSE_KEY 
210d						DMARK "KY>" 
210d			endif 
210d			; move past token to next word 
210d			 
210d 2a c2 e5		ld hl, (os_tok_ptr) 
2110 3e 00		ld a, 0 
2112 01 ff 00		ld bc, 255     ; input buffer size 
2115 ed b1		cpir 
2117			 
2117			if DEBUG_FORTH_PARSE_KEY 
2117						DMARK "KY!" 
2117				CALLMONITOR 
2117			endif	 
2117			; TODO this might place hl on the null, so will need to forward on??? 
2117			;inc hl   ; see if this gets onto the next item 
2117			 
2117			 
2117			; TODO pass a pointer to the buffer to push 
2117			; TODO call function to push 
2117			 
2117			; look for end of input 
2117			 
2117			;inc hl 
2117			;ld a,(hl) 
2117			;cp FORTH_END_BUFFER 
2117			;ret z 
2117			 
2117			 
2117 c3 90 20		jp exec1 
211a			 
211a			 
211a			 
211a			 
211a			 
211a			 
211a			 
211a			 
211a			 
211a			findnexttok: 
211a			 
211a				; hl is pointer to move 
211a				; de is the token to locate 
211a			 
211a					if DEBUG_FORTH 
211a						DMARK "NTK" 
211a						CALLMONITOR 
211a					endif 
211a d5				push de 
211b			 
211b			.fnt1:	 
211b				; find first char of token to locate 
211b			 
211b 1a				ld a, (de) 
211c 4f				ld c,a 
211d 7e				ld a,(hl) 
211e cd 3b 12			call toUpper 
2121					if DEBUG_FORTH 
2121						DMARK "NT1" 
2121						CALLMONITOR 
2121					endif 
2121 b9				cp c 
2122			 
2122 28 03			jr z, .fnt2cmpmorefirst	 
2124			 
2124				; first char not found move to next char 
2124			 
2124 23				inc hl 
2125 18 f4			jr .fnt1 
2127			 
2127			.fnt2cmpmorefirst:	 
2127				; first char of token found.  
2127			 
2127 e5				push hl     ; save start of token just in case it is the right one 
2128 d9				exx 
2129 e1				pop hl        ; save it to hl' 
212a d9				exx 
212b			 
212b			 
212b			.fnt2cmpmore:	 
212b				; compare the rest 
212b				 
212b 23				inc hl 
212c 13				inc de 
212d				 
212d 1a				ld a, (de) 
212e 4f				ld c,a 
212f 7e				ld a,(hl) 
2130 cd 3b 12			call toUpper 
2133			 
2133					if DEBUG_FORTH 
2133						DMARK "NT2" 
2133						CALLMONITOR 
2133					endif 
2133				; c has the token to find char 
2133				; a has the mem to scan char 
2133			 
2133 b9				cp c 
2134 28 04			jr z,.fntmatch1 
2136			 
2136				; they are not the same 
2136			 
2136					if DEBUG_FORTH 
2136						DMARK "NT3" 
2136						CALLMONITOR 
2136					endif 
2136 d1				pop de	; reset de token to look for 
2137 d5				push de 
2138 18 e1			jr .fnt1 
213a				 
213a			.fntmatch1: 
213a			 
213a				; is the same char a null which means we might have a full hit? 
213a					if DEBUG_FORTH 
213a						DMARK "NT4" 
213a						CALLMONITOR 
213a					endif 
213a			 
213a fe 00			cp 0 
213c 28 0b			jr z, .fntmatchyes 
213e			 
213e				; are we at the end of the token to find? 
213e			 
213e					if DEBUG_FORTH 
213e						DMARK "NT5" 
213e						CALLMONITOR 
213e					endif 
213e 3e 00			ld a, 0 
2140 b9				cp c 
2141			 
2141 c2 2b 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2144			 
2144					if DEBUG_FORTH 
2144						DMARK "NT6" 
2144						CALLMONITOR 
2144					endif 
2144				; token to find is exhusted but no match to stream 
2144			 
2144				; restore tok pointer and continue on 
2144 d1				pop de 
2145 d5				push de 
2146 c3 1b 21			jp .fnt1 
2149			 
2149			 
2149			.fntmatchyes: 
2149			 
2149				; hl now contains the end of the found token 
2149			 
2149				; get rid of saved token pointer to find 
2149			 
2149 d1				pop de 
214a			 
214a					if DEBUG_FORTH 
214a						DMARK "NT9" 
214a						CALLMONITOR 
214a					endif 
214a			 
214a				; hl will be on the null term so forward on 
214a			 
214a				; get back the saved start of the token 
214a			 
214a d9				exx 
214b e5				push hl     ; save start of token just in case it is the right one 
214c d9				exx 
214d e1				pop hl        ; save it to hl 
214e			 
214e c9				ret 
214f			 
214f			 
214f			; LIST needs to find a specific token   
214f			; FORGET needs to find a spefici token 
214f			 
214f			; SAVE needs to find all tokens by flag 
214f			; WORDS just needs to scan through all  by flag 
214f			; UWORDS needs to scan through all by flag 
214f			 
214f			 
214f			; given hl as pointer to start of dict look up string 
214f			; return hl as pointer to start of word block 
214f			; or 0 if not found 
214f			 
214f			forth_find_tok: 
214f c9				ret 
2150			 
2150			; given hl as pointer to dict structure 
2150			; move to the next dict block structure 
2150			 
2150			forth_tok_next: 
2150				; hl now points to the address of the next word pointer  
2150				; TODO skip compiled symbol for now 
2150			;	push de 
2150 23				inc hl 
2151 5e				ld e, (hl) 
2152 23				inc hl 
2153 56				ld d, (hl) 
2154 23				inc hl 
2155			 
2155 eb				ex de,hl 
2156			if DEBUG_FORTH_PARSE_NEXTWORD 
2156				push bc 
2156				ld bc, (cli_nextword) 
2156						DMARK "NXW" 
2156				CALLMONITOR 
2156				pop bc 
2156			endif 
2156			;	pop de	 
2156 c9				ret 
2157			 
2157			 
2157			 
2157			; eof 
# End of file forth_parserv5.asm
2157				include "forth_wordsv4.asm" 
2157			 
2157			; the core word dictionary v4 
2157			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2157			 
2157			; this is a linked list for each of the system words used 
2157			; user defined words will follow the same format but will be in ram 
2157			 
2157			 
2157			; 
2157			; 
2157			; define linked list: 
2157			; 
2157			; 1. compiled byte op code 
2157			; 2. len of text word 
2157			; 3. text word 
2157			; 4. ptr to next dictionary word 
2157			; 5. asm, calls etc for the word 
2157			; 
2157			;  if 1 == 0 then last word in dict  
2157			;   
2157			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2157			;  
2157			;  
2157			; create basic standard set of words 
2157			; 
2157			;  
2157			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2157			; 2DUP 2DROP 2SWAP  
2157			; @ C@ - get byte  
2157			; ! C! - store byte 
2157			; 0< true if less than zero 
2157			; 0= true if zero 
2157			; < >  
2157			; = true if same 
2157			; variables 
2157			 
2157			 
2157			; Hardware specific words I may need 
2157			; 
2157			; IN OUT  
2157			; calls to key util functions 
2157			; calls to hardward abstraction stuff 
2157			; easy control of frame buffers and lcd i/o 
2157			; keyboard  
2157			 
2157			 
2157			;DICT: macro 
2157			; op_code, len, word, next 
2157			;    word: 
2157			;    db op_code 
2157			;    ds word zero term 
2157			;    dw next 
2157			;    endm 
2157			 
2157			 
2157			 
2157			 
2157			; op code 1 is a flag for user define words which are to be handled differently 
2157			 
2157			 
2157			; 
2157			; 
2157			;    TODO on entry to a word this should be the expected environment 
2157			;    hl - tos value if number then held, if string this is the ptr 
2157			;    de -  
2157			 
2157			 
2157			; opcode ranges 
2157			; 0 - end of word dict 
2157			; 255 - user define words 
2157			 
2157			sysdict: 
2157			include "forth_opcodes.asm" 
2157			; op codes for forth keywords 
2157			; free to use code 0  
2157				OPCODE_HEAP: equ  1 
2157				OPCODE_EXEC: equ 2 
2157				OPCODE_DUP: equ 3 
2157				OPCODE_SWAP: equ 4 
2157				OPCODE_COLN: equ 5 
2157				OPCODE_SCOLN: equ 6 
2157				OPCODE_DROP: equ 7 
2157				OPCODE_DUP2: equ 8 
2157				OPCODE_DROP2: equ 9 
2157				OPCODE_SWAP2: equ 10 
2157				OPCODE_AT: equ 11 
2157				OPCODE_CAT: equ 12 
2157				OPCODE_BANG: equ 13 
2157				OPCODE_CBANG: equ 14 
2157				OPCODE_SCALL: equ 15 
2157				OPCODE_DEPTH: equ 16 
2157				OPCODE_OVER: equ 17 
2157				OPCODE_PAUSE: equ 18 
2157				OPCODE_PAUSES: equ 19 
2157				OPCODE_ROT: equ 20 
2157			;free to reuse	OPCODE_WORDS: equ 21 
2157			        OPCODE_NOT: equ 21 
2157				OPCODE_UWORDS: equ 22 
2157				OPCODE_BP: equ 23 
2157				OPCODE_MONITOR: equ 24  
2157				OPCODE_MALLOC: equ 25 
2157				OPCODE_FREE: equ 26 
2157				OPCODE_LIST: equ 27 
2157				OPCODE_FORGET: equ 28 
2157				OPCODE_NOP: equ 29 
2157				OPCODE_COMO: equ 30 
2157				OPCODE_COMC: equ 31 
2157			;free to reuse	OPCODE_ENDCORE: equ 32 
2157				OPCODE_AFTERSOUND: equ 33 
2157				OPCODE_GP2: equ 34 
2157				OPCODE_GP3: equ 35 
2157				OPCODE_GP4: equ 36 
2157				OPCODE_SIN: equ 37 
2157				OPCODE_SOUT: equ 38 
2157				OPCODE_SPIO: equ 39 
2157				OPCODE_SPICEH: equ 40 
2157				OPCODE_SPIOb: equ 41 
2157				OPCODE_SPII: equ 42 
2157				OPCODE_SESEL: equ 43 
2157				OPCODE_CARTDEV: equ 44 
2157			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2157				OPCODE_FB: equ 46 
2157				OPCODE_EMIT: equ 47 
2157				OPCODE_DOTH: equ 48 
2157				OPCODE_DOTF: equ 49 
2157				OPCODE_DOT: equ 50 
2157				OPCODE_CLS: equ 51 
2157				OPCODE_DRAW: equ 52 
2157				OPCODE_DUMP: equ 53 
2157				OPCODE_CDUMP: equ 54 
2157				OPCODE_DAT: equ 55 
2157				OPCODE_HOME: equ 56 
2157				OPCODE_SPACE: equ 57 
2157				OPCODE_SPACES: equ 58 
2157				OPCODE_SCROLL: equ 59 
2157				OPCODE_ATQ: equ 60 
2157				OPCODE_AUTODSP: equ 61 
2157				OPCODE_MENU: equ 62 
2157			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2157				OPCODE_THEN: equ 64 
2157				OPCODE_ELSE: equ 65 
2157				OPCODE_DO: equ 66 
2157				OPCODE_LOOP: equ 67 
2157				OPCODE_I: equ 68 
2157				OPCODE_DLOOP: equ 69  
2157				OPCODE_REPEAT: equ 70  
2157				OPCODE_UNTIL: equ 71 
2157				OPCODE_ENDFLOW: equ 72 
2157				OPCODE_WAITK: equ 73 
2157				OPCODE_ACCEPT: equ 74 
2157				OPCODE_EDIT: equ 75 
2157			;free to reuse	OPCODE_ENDKEY: equ 76 
2157				OPCODE_LZERO: equ 77 
2157				OPCODE_TZERO: equ 78 
2157				OPCODE_LESS: equ 79 
2157				OPCODE_GT: equ 80 
2157				OPCODE_EQUAL: equ 81  
2157			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2157				OPCODE_NEG: equ 83 
2157				OPCODE_DIV: equ 84 
2157				OPCODE_MUL: equ 85 
2157				OPCODE_MIN: equ 86 
2157				OPCODE_MAX: equ 87 
2157				OPCODE_RND16: equ 88 
2157				OPCODE_RND8: equ 89 
2157				OPCODE_RND: equ 90 
2157			;free to reuse	OPCODE_ENDMATHS: equ 91  
2157				OPCODE_BYNAME: equ 92 
2157				OPCODE_DIR: equ 93 
2157				OPCODE_SAVE: equ 94 
2157				OPCODE_LOAD: equ 95 
2157				OPCODE_BSAVE: equ 96 
2157				OPCODE_BLOAD: equ 97 
2157				OPCODE_SEO: equ 98  
2157				OPCODE_SEI: equ 99 
2157				OPCODE_SFREE: equ 100 
2157				OPCODE_SIZE: equ 101 
2157				OPCODE_CREATE: equ 102 
2157				OPCODE_APPEND: equ 103 
2157				OPCODE_SDEL: equ 104 
2157				OPCODE_OPEN: equ 105 
2157				OPCODE_READ: equ 106 
2157				OPCODE_EOF: equ 106 
2157				OPCODE_FORMAT: equ 107 
2157				OPCODE_LABEL: equ 108 
2157				OPCODE_LABELS: equ 109 
2157			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2157				OPCODE_UPPER: equ 111 
2157				OPCODE_LOWER: equ 112 
2157				OPCODE_SUBSTR: equ 113 
2157				OPCODE_LEFT: equ 114 
2157				OPCODE_RIGHT: equ 115 
2157				OPCODE_STR2NUM: equ 116 
2157				OPCODE_NUM2STR: equ 117 
2157				OPCODE_CONCAT: equ 118 
2157				OPCODE_FIND: equ 119 
2157				OPCODE_LEN: equ 120 
2157				OPCODE_CHAR: equ 121 
2157			; free to reuse	OPCODE_STRLEN: equ 122 
2157			; free to reuse	OPCODE_ENDSTR: equ 123 
2157				OPCODE_V0S: equ 124 
2157				OPCODE_V0Q: equ 125 
2157				OPCODE_V1S: equ 126 
2157				OPCODE_V1Q: equ 127 
2157				OPCODE_V2S: equ 128 
2157				OPCODE_V2Q: equ 129 
2157				OPCODE_V3S: equ 130 
2157				OPCODE_V3Q: equ 131 
2157			;free to reuse	OPCODE_END: equ 132 
2157				OPCODE_ZDUP: equ 133 
2157			 
2157			; eof 
# End of file forth_opcodes.asm
2157			 
2157			include "forth_words_core.asm" 
2157			 
2157			; | ## Core Words 
2157			 
2157			;if MALLOC_4 
2157			 
2157			.HEAP: 
2157			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2157 15				db WORD_SYS_CORE+OPCODE_HEAP             
2158 96 21			dw .EXEC            
215a 05				db 4 + 1 
215b .. 00			db "HEAP",0              
2160				endm 
# End of macro CWHEAD
2160			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2160			; | | u1 - Current number of bytes in the heap 
2160			; | | u2 - Remaining bytes left on the heap 
2160			; | |  
2160			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2160			 
2160			 
2160				if DEBUG_FORTH_WORDS_KEY 
2160					DMARK "HEP" 
2160 f5				push af  
2161 3a 75 21			ld a, (.dmark)  
2164 32 6b ee			ld (debug_mark),a  
2167 3a 76 21			ld a, (.dmark+1)  
216a 32 6c ee			ld (debug_mark+1),a  
216d 3a 77 21			ld a, (.dmark+2)  
2170 32 6d ee			ld (debug_mark+2),a  
2173 18 03			jr .pastdmark  
2175 ..			.dmark: db "HEP"  
2178 f1			.pastdmark: pop af  
2179			endm  
# End of macro DMARK
2179					CALLMONITOR 
2179 cd 6f ee			call debug_vector  
217c				endm  
# End of macro CALLMONITOR
217c				endif 
217c 2a 51 66			ld hl, (free_list )      
217f 11 56 66			ld de, heap_start 
2182			 
2182 ed 52			sbc hl, de  
2184			 
2184 cd 52 1c			call forth_push_numhl 
2187			 
2187			 
2187 ed 5b 51 66		ld de, (free_list )      
218b 21 9c e2			ld hl, heap_end 
218e			 
218e ed 52			sbc hl, de 
2190			 
2190 cd 52 1c			call forth_push_numhl 
2193				 
2193			 
2193				 
2193			 
2193			 
2193			 
2193				NEXTW 
2193 c3 ff 1f			jp macro_next 
2196				endm 
# End of macro NEXTW
2196			;endif 
2196			 
2196			.EXEC: 
2196			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2196			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2196			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2196			;; > > 
2196			;; > >   
2196			;	STACKFRAME OFF $5efe $5f9f 
2196			; 
2196			;		if DEBUG_FORTH_WORDS_KEY 
2196			;			DMARK "EXE" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			; 
2196			;	FORTH_DSP_VALUEHL 
2196			; 
2196			;	FORTH_DSP_POP 
2196			; 
2196			;		if DEBUG_FORTH_WORDS 
2196			;			DMARK "EX1" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			;;	ld e,(hl) 
2196			;;	inc hl 
2196			;;	ld d,(hl) 
2196			;;	ex de,hl 
2196			; 
2196			;;		if DEBUG_FORTH_WORDS 
2196			;;			DMARK "EX2" 
2196			;;			CALLMONITOR 
2196			;;		endif 
2196			;	push hl 
2196			; 
2196			;	;ld a, 0 
2196			;	;ld a, FORTH_END_BUFFER 
2196			;	call strlenz 
2196			;	inc hl   ; include zero term to copy 
2196			;	inc hl   ; include term 
2196			;	inc hl   ; include term 
2196			;	ld b,0 
2196			;	ld c,l 
2196			;	pop hl 
2196			;	ld de, execscratch 
2196			;		if DEBUG_FORTH_WORDS 
2196			;			DMARK "EX3" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			;	ldir 
2196			; 
2196			; 
2196			;	ld hl, execscratch 
2196			; 
2196			;		if DEBUG_FORTH_WORDS 
2196			;			DMARK "EXe" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			; 
2196			;	call forthparse 
2196			;	call forthexec 
2196			;;	call forthexec_cleanup 
2196			;;	call forthparse 
2196			;;	call forthexec 
2196			; 
2196			;	STACKFRAMECHK OFF $5efe $5f9f 
2196			; 
2196			;	; an immediate word so no need to process any more words 
2196			;	ret 
2196			;	NEXTW 
2196			 
2196			; dead code - old version  
2196			;	FORTH_RSP_NEXT 
2196			 
2196			;  
2196			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2196			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2196			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2196			;	push hl 
2196			;	push de 
2196			;	push bc 
2196			; 
2196			; 
2196			;		if DEBUG_FORTH_WORDS_KEY 
2196			;			DMARK "EXR" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			; 
2196			; 
2196			; 
2196			;	;v5 FORTH_DSP_VALUE 
2196			;	FORTH_DSP_VALUEHL 
2196			; 
2196			;	; TODO do string type checks 
2196			; 
2196			;;v5	inc hl   ; skip type 
2196			; 
2196			;	push hl  ; source code  
2196			;		if DEBUG_FORTH_WORDS 
2196			;			DMARK "EX1" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			;	ld a, 0 
2196			;	call strlent 
2196			; 
2196			;	inc hl 
2196			;	inc hl 
2196			;	inc hl 
2196			;	inc hl 
2196			; 
2196			;	push hl    ; size 
2196			; 
2196			;		if DEBUG_FORTH_WORDS 
2196			;			DMARK "EX2" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			;	call malloc 
2196			; 
2196			;	ex de, hl    ; de now contains malloc area 
2196			;	pop bc   	; get byte count 
2196			;	pop hl      ; get string to copy 
2196			; 
2196			;	push de     ; save malloc for free later 
2196			; 
2196			;		if DEBUG_FORTH_WORDS 
2196			;			DMARK "EX3" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			;	ldir       ; duplicate string 
2196			; 
2196			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2196			;	 
2196			;	; TODO fix the parse would be better than this...  
2196			;	ex de, hl 
2196			;	dec hl 
2196			;	ld a, 0 
2196			;	ld (hl), a 
2196			;	dec hl 
2196			;	ld a, ' ' 
2196			;	ld (hl), a 
2196			;	dec hl 
2196			;	ld (hl), a 
2196			; 
2196			;	dec hl 
2196			;	ld (hl), a 
2196			; 
2196			; 
2196			;	FORTH_DSP_POP  
2196			; 
2196			;	pop hl     
2196			;	push hl    ; save malloc area 
2196			; 
2196			;		if DEBUG_FORTH_WORDS 
2196			;			DMARK "EX4" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			; 
2196			;	call forthparse 
2196			;	call forthexec 
2196			;	 
2196			;	pop hl 
2196			;	if DEBUG_FORTH_WORDS 
2196			;		DMARK "EX5" 
2196			;		CALLMONITOR 
2196			;	endif 
2196			; 
2196			;	if FORTH_ENABLE_FREE 
2196			;	call free 
2196			;	endif 
2196			; 
2196			;	if DEBUG_FORTH_WORDS 
2196			;		DMARK "EX6" 
2196			;		CALLMONITOR 
2196			;	endif 
2196			; 
2196			;	pop bc 
2196			;	pop de 
2196			;	pop hl 
2196			;;	FORTH_RSP_POP	  
2196			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2196			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2196			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2196			; 
2196			;	if DEBUG_FORTH_WORDS 
2196			;		DMARK "EX7" 
2196			;		CALLMONITOR 
2196			;	endif 
2196			;	NEXTW 
2196			 
2196			;.STKEXEC: 
2196			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2196			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2196			; 
2196			; 
2196			;		if DEBUG_FORTH_WORDS_KEY 
2196			;			DMARK "STX" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			; 
2196			;	FORTH_DSP_VALUEHL 
2196			; 
2196			;	ld (store_tmp1), hl    ; count 
2196			; 
2196			;	FORTH_DSP_POP 
2196			;.stkexec1: 
2196			;	ld hl, (store_tmp1)   ; count 
2196			;	ld a, 0 
2196			;	cp l 
2196			;	ret z 
2196			; 
2196			;	dec hl 
2196			;	ld (store_tmp1), hl    ; count 
2196			;	 
2196			;	FORTH_DSP_VALUEHL 
2196			;	push hl 
2196			;	 
2196			;		if DEBUG_FORTH_WORDS 
2196			;			DMARK "EXp" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			;	FORTH_DSP_POP 
2196			; 
2196			;	call strlenz 
2196			;	inc hl   ; include zero term to copy 
2196			;	inc hl   ; include zero term to copy 
2196			;	inc hl   ; include zero term to copy 
2196			;	ld b,0 
2196			;	ld c,l 
2196			;	pop hl 
2196			;	ld de, execscratch 
2196			;		if DEBUG_FORTH_WORDS 
2196			;			DMARK "EX3" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			;	ldir 
2196			; 
2196			; 
2196			;	ld hl, execscratch 
2196			; 
2196			;		if DEBUG_FORTH_WORDS 
2196			;			DMARK "EXP" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			; 
2196			;	call forthparse 
2196			;	ld hl, execscratch 
2196			;		if DEBUG_FORTH_WORDS 
2196			;			DMARK "EXx" 
2196			;			CALLMONITOR 
2196			;		endif 
2196			;	call forthexec 
2196			; 
2196			;	jp .stkexec1 
2196			; 
2196			;	ret 
2196			 
2196			 
2196			.DUP: 
2196			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2196 17				db WORD_SYS_CORE+OPCODE_DUP             
2197 0c 22			dw .ZDUP            
2199 04				db 3 + 1 
219a .. 00			db "DUP",0              
219e				endm 
# End of macro CWHEAD
219e			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
219e			 
219e				if DEBUG_FORTH_WORDS_KEY 
219e					DMARK "DUP" 
219e f5				push af  
219f 3a b3 21			ld a, (.dmark)  
21a2 32 6b ee			ld (debug_mark),a  
21a5 3a b4 21			ld a, (.dmark+1)  
21a8 32 6c ee			ld (debug_mark+1),a  
21ab 3a b5 21			ld a, (.dmark+2)  
21ae 32 6d ee			ld (debug_mark+2),a  
21b1 18 03			jr .pastdmark  
21b3 ..			.dmark: db "DUP"  
21b6 f1			.pastdmark: pop af  
21b7			endm  
# End of macro DMARK
21b7					CALLMONITOR 
21b7 cd 6f ee			call debug_vector  
21ba				endm  
# End of macro CALLMONITOR
21ba				endif 
21ba			 
21ba				FORTH_DSP 
21ba cd 0f 1e			call macro_forth_dsp 
21bd				endm 
# End of macro FORTH_DSP
21bd			 
21bd 7e				ld a, (HL) 
21be fe 01			cp DS_TYPE_STR 
21c0 20 25			jr nz, .dupinum 
21c2			 
21c2				; push another string 
21c2			 
21c2				FORTH_DSP_VALUEHL     		 
21c2 cd 49 1e			call macro_dsp_valuehl 
21c5				endm 
# End of macro FORTH_DSP_VALUEHL
21c5			 
21c5			if DEBUG_FORTH_WORDS 
21c5				DMARK "DUs" 
21c5 f5				push af  
21c6 3a da 21			ld a, (.dmark)  
21c9 32 6b ee			ld (debug_mark),a  
21cc 3a db 21			ld a, (.dmark+1)  
21cf 32 6c ee			ld (debug_mark+1),a  
21d2 3a dc 21			ld a, (.dmark+2)  
21d5 32 6d ee			ld (debug_mark+2),a  
21d8 18 03			jr .pastdmark  
21da ..			.dmark: db "DUs"  
21dd f1			.pastdmark: pop af  
21de			endm  
# End of macro DMARK
21de				CALLMONITOR 
21de cd 6f ee			call debug_vector  
21e1				endm  
# End of macro CALLMONITOR
21e1			endif 
21e1 cd c0 1c			call forth_push_str 
21e4			 
21e4				NEXTW 
21e4 c3 ff 1f			jp macro_next 
21e7				endm 
# End of macro NEXTW
21e7			 
21e7			 
21e7			.dupinum: 
21e7				 
21e7			 
21e7			 
21e7				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21e7 cd 49 1e			call macro_dsp_valuehl 
21ea				endm 
# End of macro FORTH_DSP_VALUEHL
21ea			 
21ea			; TODO add floating point number detection 
21ea			 
21ea			if DEBUG_FORTH_WORDS 
21ea				DMARK "DUi" 
21ea f5				push af  
21eb 3a ff 21			ld a, (.dmark)  
21ee 32 6b ee			ld (debug_mark),a  
21f1 3a 00 22			ld a, (.dmark+1)  
21f4 32 6c ee			ld (debug_mark+1),a  
21f7 3a 01 22			ld a, (.dmark+2)  
21fa 32 6d ee			ld (debug_mark+2),a  
21fd 18 03			jr .pastdmark  
21ff ..			.dmark: db "DUi"  
2202 f1			.pastdmark: pop af  
2203			endm  
# End of macro DMARK
2203				CALLMONITOR 
2203 cd 6f ee			call debug_vector  
2206				endm  
# End of macro CALLMONITOR
2206			endif 
2206			 
2206 cd 52 1c			call forth_push_numhl 
2209				NEXTW 
2209 c3 ff 1f			jp macro_next 
220c				endm 
# End of macro NEXTW
220c			.ZDUP: 
220c			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
220c 99				db WORD_SYS_CORE+OPCODE_ZDUP             
220d 44 22			dw .SWAP            
220f 05				db 4 + 1 
2210 .. 00			db "?DUP",0              
2215				endm 
# End of macro CWHEAD
2215			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2215			 
2215				if DEBUG_FORTH_WORDS_KEY 
2215					DMARK "qDU" 
2215 f5				push af  
2216 3a 2a 22			ld a, (.dmark)  
2219 32 6b ee			ld (debug_mark),a  
221c 3a 2b 22			ld a, (.dmark+1)  
221f 32 6c ee			ld (debug_mark+1),a  
2222 3a 2c 22			ld a, (.dmark+2)  
2225 32 6d ee			ld (debug_mark+2),a  
2228 18 03			jr .pastdmark  
222a ..			.dmark: db "qDU"  
222d f1			.pastdmark: pop af  
222e			endm  
# End of macro DMARK
222e					CALLMONITOR 
222e cd 6f ee			call debug_vector  
2231				endm  
# End of macro CALLMONITOR
2231				endif 
2231				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2231 cd 49 1e			call macro_dsp_valuehl 
2234				endm 
# End of macro FORTH_DSP_VALUEHL
2234			 
2234 e5				push hl 
2235			 
2235				; is it a zero? 
2235			 
2235 3e 00			ld a, 0 
2237 84				add h 
2238 85				add l 
2239			 
2239 e1				pop hl 
223a			 
223a fe 00			cp 0 
223c 28 03			jr z, .dup2orig 
223e			 
223e			 
223e cd 52 1c			call forth_push_numhl 
2241			 
2241			 
2241			; TODO add floating point number detection 
2241			 
2241			.dup2orig: 
2241			 
2241				NEXTW 
2241 c3 ff 1f			jp macro_next 
2244				endm 
# End of macro NEXTW
2244			.SWAP: 
2244			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2244 18				db WORD_SYS_CORE+OPCODE_SWAP             
2245 83 22			dw .COLN            
2247 05				db 4 + 1 
2248 .. 00			db "SWAP",0              
224d				endm 
# End of macro CWHEAD
224d			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
224d				if DEBUG_FORTH_WORDS_KEY 
224d					DMARK "SWP" 
224d f5				push af  
224e 3a 62 22			ld a, (.dmark)  
2251 32 6b ee			ld (debug_mark),a  
2254 3a 63 22			ld a, (.dmark+1)  
2257 32 6c ee			ld (debug_mark+1),a  
225a 3a 64 22			ld a, (.dmark+2)  
225d 32 6d ee			ld (debug_mark+2),a  
2260 18 03			jr .pastdmark  
2262 ..			.dmark: db "SWP"  
2265 f1			.pastdmark: pop af  
2266			endm  
# End of macro DMARK
2266					CALLMONITOR 
2266 cd 6f ee			call debug_vector  
2269				endm  
# End of macro CALLMONITOR
2269				endif 
2269			 
2269			; TODO Use os stack swap memory 
2269				FORTH_DSP_VALUEHL 
2269 cd 49 1e			call macro_dsp_valuehl 
226c				endm 
# End of macro FORTH_DSP_VALUEHL
226c e5				push hl     ; w2 
226d			 
226d				FORTH_DSP_POP 
226d cd 01 1f			call macro_forth_dsp_pop 
2270				endm 
# End of macro FORTH_DSP_POP
2270			 
2270				FORTH_DSP_VALUEHL 
2270 cd 49 1e			call macro_dsp_valuehl 
2273				endm 
# End of macro FORTH_DSP_VALUEHL
2273			 
2273				FORTH_DSP_POP 
2273 cd 01 1f			call macro_forth_dsp_pop 
2276				endm 
# End of macro FORTH_DSP_POP
2276			 
2276 d1				pop de     ; w2	, hl = w1 
2277			 
2277 eb				ex de, hl 
2278 d5				push de 
2279			 
2279 cd 52 1c			call forth_push_numhl 
227c			 
227c e1				pop hl 
227d			 
227d cd 52 1c			call forth_push_numhl 
2280				 
2280			 
2280				NEXTW 
2280 c3 ff 1f			jp macro_next 
2283				endm 
# End of macro NEXTW
2283			.COLN: 
2283			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2283 19				db WORD_SYS_CORE+OPCODE_COLN             
2284 0f 24			dw .SCOLN            
2286 02				db 1 + 1 
2287 .. 00			db ":",0              
2289				endm 
# End of macro CWHEAD
2289			; | : ( -- )         Create new word | DONE 
2289			 
2289				if DEBUG_FORTH_WORDS_KEY 
2289					DMARK "CLN" 
2289 f5				push af  
228a 3a 9e 22			ld a, (.dmark)  
228d 32 6b ee			ld (debug_mark),a  
2290 3a 9f 22			ld a, (.dmark+1)  
2293 32 6c ee			ld (debug_mark+1),a  
2296 3a a0 22			ld a, (.dmark+2)  
2299 32 6d ee			ld (debug_mark+2),a  
229c 18 03			jr .pastdmark  
229e ..			.dmark: db "CLN"  
22a1 f1			.pastdmark: pop af  
22a2			endm  
# End of macro DMARK
22a2					CALLMONITOR 
22a2 cd 6f ee			call debug_vector  
22a5				endm  
# End of macro CALLMONITOR
22a5				endif 
22a5			STACKFRAME OFF $8efe $989f 
22a5				if DEBUG_STACK_IMB 
22a5					if OFF 
22a5						exx 
22a5						ld de, $8efe 
22a5						ld a, d 
22a5						ld hl, curframe 
22a5						call hexout 
22a5						ld a, e 
22a5						ld hl, curframe+2 
22a5						call hexout 
22a5						ld hl, $8efe 
22a5						push hl 
22a5						ld hl, $989f 
22a5						push hl 
22a5						exx 
22a5					endif 
22a5				endif 
22a5			endm 
# End of macro STACKFRAME
22a5			; get parser buffer length  of new word 
22a5			 
22a5			 
22a5			 
22a5				; move tok past this to start of name defintition 
22a5				; TODO get word to define 
22a5				; TODO Move past word token 
22a5				; TODO get length of string up to the ';' 
22a5			 
22a5 2a c2 e5		ld hl, (os_tok_ptr) 
22a8 23			inc hl 
22a9 23			inc hl 
22aa			 
22aa 3e 3b		ld a, ';' 
22ac cd 4f 12		call strlent 
22af			 
22af 7d			ld a,l 
22b0 32 b1 e2		ld (os_new_parse_len), a 
22b3			 
22b3			 
22b3			if DEBUG_FORTH_UWORD 
22b3 ed 5b c2 e5	ld de, (os_tok_ptr) 
22b7					DMARK ":01" 
22b7 f5				push af  
22b8 3a cc 22			ld a, (.dmark)  
22bb 32 6b ee			ld (debug_mark),a  
22be 3a cd 22			ld a, (.dmark+1)  
22c1 32 6c ee			ld (debug_mark+1),a  
22c4 3a ce 22			ld a, (.dmark+2)  
22c7 32 6d ee			ld (debug_mark+2),a  
22ca 18 03			jr .pastdmark  
22cc ..			.dmark: db ":01"  
22cf f1			.pastdmark: pop af  
22d0			endm  
# End of macro DMARK
22d0			CALLMONITOR 
22d0 cd 6f ee			call debug_vector  
22d3				endm  
# End of macro CALLMONITOR
22d3			endif 
22d3			 
22d3			; 
22d3			;  new word memory layout: 
22d3			;  
22d3			;    : adg 6666 ;  
22d3			; 
22d3			;    db   1     ; user defined word  
22d3 23			inc hl    
22d4			;    dw   sysdict 
22d4 23			inc hl 
22d5 23			inc hl 
22d6			;    db <word len>+1 (for null) 
22d6 23			inc hl 
22d7			;    db .... <word> 
22d7			; 
22d7			 
22d7 23			inc hl    ; some extras for the word preamble before the above 
22d8 23			inc hl 
22d9 23			inc hl 
22da 23			inc hl 
22db 23			inc hl 
22dc 23			inc hl 
22dd 23			inc hl  
22de 23			inc hl 
22df 23			inc hl 
22e0 23			inc hl 
22e1 23			inc hl 
22e2 23			inc hl 
22e3 23			inc hl 
22e4 23			inc hl     ; TODO how many do we really need?     maybe only 6 
22e5			;       exec word buffer 
22e5			;	<ptr word>   
22e5 23			inc hl 
22e6 23			inc hl 
22e7			;       <word list><null term> 7F final term 
22e7			 
22e7			 
22e7			if DEBUG_FORTH_UWORD 
22e7					DMARK ":02" 
22e7 f5				push af  
22e8 3a fc 22			ld a, (.dmark)  
22eb 32 6b ee			ld (debug_mark),a  
22ee 3a fd 22			ld a, (.dmark+1)  
22f1 32 6c ee			ld (debug_mark+1),a  
22f4 3a fe 22			ld a, (.dmark+2)  
22f7 32 6d ee			ld (debug_mark+2),a  
22fa 18 03			jr .pastdmark  
22fc ..			.dmark: db ":02"  
22ff f1			.pastdmark: pop af  
2300			endm  
# End of macro DMARK
2300			CALLMONITOR 
2300 cd 6f ee			call debug_vector  
2303				endm  
# End of macro CALLMONITOR
2303			endif 
2303			 
2303			 
2303				; malloc the size 
2303			 
2303 cd b9 12			call malloc 
2306 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
2309			 
2309			;    db   1     ; user defined word  
2309 3e 01			ld a, WORD_SYS_UWORD  
230b 77				ld (hl), a 
230c			 
230c 23			inc hl    
230d			;    dw   sysdict 
230d 11 57 21		ld de, sysdict       ; continue on with the scan to the system dict 
2310 73			ld (hl), e 
2311 23			inc hl 
2312 72			ld (hl), d 
2313 23			inc hl 
2314			 
2314			 
2314			;    Setup dict word 
2314			 
2314 23			inc hl 
2315 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
2318			 
2318			; 1. get length of dict word 
2318			 
2318			 
2318 2a c2 e5		ld hl, (os_tok_ptr) 
231b 23			inc hl 
231c 23			inc hl    ; position to start of dict word 
231d 3e 00		ld a, 0 
231f cd 4f 12		call strlent 
2322			 
2322			 
2322 23			inc hl    ; to include null??? 
2323			 
2323			; write length of dict word 
2323			 
2323 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2327 1b			dec de 
2328 eb			ex de, hl 
2329 73			ld (hl), e 
232a eb			ex de, hl 
232b			 
232b			 
232b			 
232b			; copy  
232b 4d			ld c, l 
232c 06 00		ld b, 0 
232e ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2332 2a c2 e5		ld hl, (os_tok_ptr) 
2335 23			inc hl 
2336 23			inc hl    ; position to start of dict word 
2337			 
2337			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2337			 
2337			; TODO need to convert word to upper case 
2337			 
2337			ucasetok:	 
2337 7e			ld a,(hl) 
2338 cd 3b 12		call toUpper 
233b 77			ld (hl),a 
233c ed a0		ldi 
233e f2 37 23		jp p, ucasetok 
2341			 
2341			 
2341			 
2341			; de now points to start of where the word body code should be placed 
2341 ed 53 ad e2	ld (os_new_work_ptr), de 
2345			; hl now points to the words to throw at forthexec which needs to be copied 
2345 22 ab e2		ld (os_new_src_ptr), hl 
2348			 
2348			; TODO add 'call to forthexec' 
2348			 
2348			if DEBUG_FORTH_UWORD 
2348 c5			push bc 
2349 ed 4b b3 e2	ld bc, (os_new_malloc) 
234d					DMARK ":0x" 
234d f5				push af  
234e 3a 62 23			ld a, (.dmark)  
2351 32 6b ee			ld (debug_mark),a  
2354 3a 63 23			ld a, (.dmark+1)  
2357 32 6c ee			ld (debug_mark+1),a  
235a 3a 64 23			ld a, (.dmark+2)  
235d 32 6d ee			ld (debug_mark+2),a  
2360 18 03			jr .pastdmark  
2362 ..			.dmark: db ":0x"  
2365 f1			.pastdmark: pop af  
2366			endm  
# End of macro DMARK
2366			CALLMONITOR 
2366 cd 6f ee			call debug_vector  
2369				endm  
# End of macro CALLMONITOR
2369 c1			pop bc 
236a			endif 
236a			 
236a			 
236a			; create word preamble which should be: 
236a			 
236a			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
236a			 
236a			;    ld hl, <word code> 
236a			;    jp user_exec 
236a			;    <word code bytes> 
236a			 
236a			 
236a			;	inc de     ; TODO ??? or are we already past the word's null 
236a eb			ex de, hl 
236b			 
236b 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
236d			 
236d 23			inc hl 
236e 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2371 23			inc hl 
2372			 
2372 23			inc hl 
2373 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2375			 
2375 01 ed 4c		ld bc, user_exec 
2378 23			inc hl 
2379 71			ld (hl), c     ; poke address of user_exec 
237a 23			inc hl 
237b 70			ld (hl), b     
237c			; 
237c			;	inc hl 
237c			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
237c			; 
237c			; 
237c			;	ld bc, macro_forth_rsp_next 
237c			;	inc hl 
237c			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
237c			;	inc hl 
237c			;	ld (hl), b     
237c			; 
237c			;	inc hl 
237c			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
237c			; 
237c			; 
237c			;	inc hl 
237c			;	ld bc, forthexec 
237c			;	ld (hl), c     ; poke address of forthexec 
237c			;	inc hl 
237c			;	ld (hl), b      
237c			; 
237c			;	inc hl 
237c			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
237c			; 
237c			;	ld bc, user_dict_next 
237c			;	inc hl 
237c			;	ld (hl), c     ; poke address of forthexec 
237c			;	inc hl 
237c			;	ld (hl), b      
237c			 
237c			; hl is now where we need to copy the word byte data to save this 
237c			 
237c 23			inc hl 
237d 22 a9 e2		ld (os_new_exec), hl 
2380			 
2380			; copy definition 
2380			 
2380 eb			ex de, hl 
2381			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2381			;	inc de    ; skip the PC for this parse 
2381 3a b1 e2		ld a, (os_new_parse_len) 
2384 4f			ld c, a 
2385 06 00		ld b, 0 
2387 ed b0		ldir		 ; copy defintion 
2389			 
2389			 
2389			; poke the address of where the new word bytes live for forthexec 
2389			 
2389 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
238c			 
238c ed 5b a9 e2	ld de, (os_new_exec)      
2390			 
2390 73			ld (hl), e 
2391 23			inc hl 
2392 72			ld (hl), d 
2393			 
2393				; TODO copy last user dict word next link to this word 
2393				; TODO update last user dict word to point to this word 
2393			; 
2393			; hl f923 de 812a ; bc 811a 
2393			 
2393			if DEBUG_FORTH_UWORD 
2393 c5			push bc 
2394 ed 4b b3 e2	ld bc, (os_new_malloc) 
2398					DMARK ":0A" 
2398 f5				push af  
2399 3a ad 23			ld a, (.dmark)  
239c 32 6b ee			ld (debug_mark),a  
239f 3a ae 23			ld a, (.dmark+1)  
23a2 32 6c ee			ld (debug_mark+1),a  
23a5 3a af 23			ld a, (.dmark+2)  
23a8 32 6d ee			ld (debug_mark+2),a  
23ab 18 03			jr .pastdmark  
23ad ..			.dmark: db ":0A"  
23b0 f1			.pastdmark: pop af  
23b1			endm  
# End of macro DMARK
23b1			CALLMONITOR 
23b1 cd 6f ee			call debug_vector  
23b4				endm  
# End of macro CALLMONITOR
23b4 c1			pop bc 
23b5			endif 
23b5			if DEBUG_FORTH_UWORD 
23b5 c5			push bc 
23b6 ed 4b b3 e2	ld bc, (os_new_malloc) 
23ba 03			inc bc 
23bb 03			inc bc 
23bc 03			inc bc 
23bd 03			inc bc 
23be 03			inc bc 
23bf 03			inc bc 
23c0 03			inc bc 
23c1 03			inc bc 
23c2			 
23c2					DMARK ":0B" 
23c2 f5				push af  
23c3 3a d7 23			ld a, (.dmark)  
23c6 32 6b ee			ld (debug_mark),a  
23c9 3a d8 23			ld a, (.dmark+1)  
23cc 32 6c ee			ld (debug_mark+1),a  
23cf 3a d9 23			ld a, (.dmark+2)  
23d2 32 6d ee			ld (debug_mark+2),a  
23d5 18 03			jr .pastdmark  
23d7 ..			.dmark: db ":0B"  
23da f1			.pastdmark: pop af  
23db			endm  
# End of macro DMARK
23db			CALLMONITOR 
23db cd 6f ee			call debug_vector  
23de				endm  
# End of macro CALLMONITOR
23de c1			pop bc 
23df			endif 
23df			 
23df			; update word dict linked list for new word 
23df			 
23df			 
23df 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
23e2 23			inc hl     ; move to next work linked list ptr 
23e3			 
23e3 ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
23e7 73			ld (hl), e 
23e8 23			inc hl 
23e9 72			ld (hl), d 
23ea			 
23ea			if DEBUG_FORTH_UWORD 
23ea ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
23ee			endif 
23ee			 
23ee ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
23f2			 
23f2			 
23f2			if DEBUG_FORTH_UWORD 
23f2					DMARK ":0+" 
23f2 f5				push af  
23f3 3a 07 24			ld a, (.dmark)  
23f6 32 6b ee			ld (debug_mark),a  
23f9 3a 08 24			ld a, (.dmark+1)  
23fc 32 6c ee			ld (debug_mark+1),a  
23ff 3a 09 24			ld a, (.dmark+2)  
2402 32 6d ee			ld (debug_mark+2),a  
2405 18 03			jr .pastdmark  
2407 ..			.dmark: db ":0+"  
240a f1			.pastdmark: pop af  
240b			endm  
# End of macro DMARK
240b			CALLMONITOR 
240b cd 6f ee			call debug_vector  
240e				endm  
# End of macro CALLMONITOR
240e			endif 
240e			 
240e			STACKFRAMECHK OFF $8efe $989f 
240e				if DEBUG_STACK_IMB 
240e					if OFF 
240e						exx 
240e						ld hl, $989f 
240e						pop de   ; $989f 
240e						call cmp16 
240e						jr nz, .spnosame 
240e						ld hl, $8efe 
240e						pop de   ; $8efe 
240e						call cmp16 
240e						jr z, .spfrsame 
240e						.spnosame: call showsperror 
240e						.spfrsame: nop 
240e						exx 
240e					endif 
240e				endif 
240e			endm 
# End of macro STACKFRAMECHK
240e			 
240e c9			ret    ; dont process any remaining parser tokens as they form new word 
240f			 
240f			 
240f			 
240f			 
240f			;		NEXT 
240f			.SCOLN: 
240f			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
240f 06			db OPCODE_SCOLN 
2410 5b 24		dw .DROP 
2412 02			db 2 
2413 .. 00		db ";",0           
2415			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2415				if DEBUG_FORTH_WORDS_KEY 
2415					DMARK "SCN" 
2415 f5				push af  
2416 3a 2a 24			ld a, (.dmark)  
2419 32 6b ee			ld (debug_mark),a  
241c 3a 2b 24			ld a, (.dmark+1)  
241f 32 6c ee			ld (debug_mark+1),a  
2422 3a 2c 24			ld a, (.dmark+2)  
2425 32 6d ee			ld (debug_mark+2),a  
2428 18 03			jr .pastdmark  
242a ..			.dmark: db "SCN"  
242d f1			.pastdmark: pop af  
242e			endm  
# End of macro DMARK
242e					CALLMONITOR 
242e cd 6f ee			call debug_vector  
2431				endm  
# End of macro CALLMONITOR
2431				endif 
2431				FORTH_RSP_TOS 
2431 cd 10 1c			call macro_forth_rsp_tos 
2434				endm 
# End of macro FORTH_RSP_TOS
2434 e5				push hl 
2435				FORTH_RSP_POP 
2435 cd 1a 1c			call macro_forth_rsp_pop 
2438				endm 
# End of macro FORTH_RSP_POP
2438 e1				pop hl 
2439			;		ex de,hl 
2439 22 c2 e5			ld (os_tok_ptr),hl 
243c			 
243c			if DEBUG_FORTH_UWORD 
243c					DMARK "SCL" 
243c f5				push af  
243d 3a 51 24			ld a, (.dmark)  
2440 32 6b ee			ld (debug_mark),a  
2443 3a 52 24			ld a, (.dmark+1)  
2446 32 6c ee			ld (debug_mark+1),a  
2449 3a 53 24			ld a, (.dmark+2)  
244c 32 6d ee			ld (debug_mark+2),a  
244f 18 03			jr .pastdmark  
2451 ..			.dmark: db "SCL"  
2454 f1			.pastdmark: pop af  
2455			endm  
# End of macro DMARK
2455			CALLMONITOR 
2455 cd 6f ee			call debug_vector  
2458				endm  
# End of macro CALLMONITOR
2458			endif 
2458				NEXTW 
2458 c3 ff 1f			jp macro_next 
245b				endm 
# End of macro NEXTW
245b			 
245b			.DROP: 
245b			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
245b 1b				db WORD_SYS_CORE+OPCODE_DROP             
245c 86 24			dw .DUP2            
245e 05				db 4 + 1 
245f .. 00			db "DROP",0              
2464				endm 
# End of macro CWHEAD
2464			; | DROP ( w -- )   drop the TOS item   | DONE 
2464				if DEBUG_FORTH_WORDS_KEY 
2464					DMARK "DRP" 
2464 f5				push af  
2465 3a 79 24			ld a, (.dmark)  
2468 32 6b ee			ld (debug_mark),a  
246b 3a 7a 24			ld a, (.dmark+1)  
246e 32 6c ee			ld (debug_mark+1),a  
2471 3a 7b 24			ld a, (.dmark+2)  
2474 32 6d ee			ld (debug_mark+2),a  
2477 18 03			jr .pastdmark  
2479 ..			.dmark: db "DRP"  
247c f1			.pastdmark: pop af  
247d			endm  
# End of macro DMARK
247d					CALLMONITOR 
247d cd 6f ee			call debug_vector  
2480				endm  
# End of macro CALLMONITOR
2480				endif 
2480				FORTH_DSP_POP 
2480 cd 01 1f			call macro_forth_dsp_pop 
2483				endm 
# End of macro FORTH_DSP_POP
2483				NEXTW 
2483 c3 ff 1f			jp macro_next 
2486				endm 
# End of macro NEXTW
2486			.DUP2: 
2486			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2486 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2487 cb 24			dw .DROP2            
2489 05				db 4 + 1 
248a .. 00			db "2DUP",0              
248f				endm 
# End of macro CWHEAD
248f			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
248f				if DEBUG_FORTH_WORDS_KEY 
248f					DMARK "2DU" 
248f f5				push af  
2490 3a a4 24			ld a, (.dmark)  
2493 32 6b ee			ld (debug_mark),a  
2496 3a a5 24			ld a, (.dmark+1)  
2499 32 6c ee			ld (debug_mark+1),a  
249c 3a a6 24			ld a, (.dmark+2)  
249f 32 6d ee			ld (debug_mark+2),a  
24a2 18 03			jr .pastdmark  
24a4 ..			.dmark: db "2DU"  
24a7 f1			.pastdmark: pop af  
24a8			endm  
# End of macro DMARK
24a8					CALLMONITOR 
24a8 cd 6f ee			call debug_vector  
24ab				endm  
# End of macro CALLMONITOR
24ab				endif 
24ab				FORTH_DSP_VALUEHL 
24ab cd 49 1e			call macro_dsp_valuehl 
24ae				endm 
# End of macro FORTH_DSP_VALUEHL
24ae e5				push hl      ; 2 
24af			 
24af				FORTH_DSP_POP 
24af cd 01 1f			call macro_forth_dsp_pop 
24b2				endm 
# End of macro FORTH_DSP_POP
24b2				 
24b2				FORTH_DSP_VALUEHL 
24b2 cd 49 1e			call macro_dsp_valuehl 
24b5				endm 
# End of macro FORTH_DSP_VALUEHL
24b5			;		push hl      ; 1 
24b5			 
24b5				FORTH_DSP_POP 
24b5 cd 01 1f			call macro_forth_dsp_pop 
24b8				endm 
# End of macro FORTH_DSP_POP
24b8			 
24b8			;		pop hl       ; 1 
24b8 d1				pop de       ; 2 
24b9			 
24b9 cd 52 1c			call forth_push_numhl 
24bc eb				ex de, hl 
24bd cd 52 1c			call forth_push_numhl 
24c0			 
24c0				 
24c0 eb				ex de, hl 
24c1			 
24c1 cd 52 1c			call forth_push_numhl 
24c4 eb				ex de, hl 
24c5 cd 52 1c			call forth_push_numhl 
24c8			 
24c8			 
24c8				NEXTW 
24c8 c3 ff 1f			jp macro_next 
24cb				endm 
# End of macro NEXTW
24cb			.DROP2: 
24cb			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
24cb 1d				db WORD_SYS_CORE+OPCODE_DROP2             
24cc fa 24			dw .SWAP2            
24ce 06				db 5 + 1 
24cf .. 00			db "2DROP",0              
24d5				endm 
# End of macro CWHEAD
24d5			; | 2DROP ( w w -- )    Double drop | DONE 
24d5				if DEBUG_FORTH_WORDS_KEY 
24d5					DMARK "2DR" 
24d5 f5				push af  
24d6 3a ea 24			ld a, (.dmark)  
24d9 32 6b ee			ld (debug_mark),a  
24dc 3a eb 24			ld a, (.dmark+1)  
24df 32 6c ee			ld (debug_mark+1),a  
24e2 3a ec 24			ld a, (.dmark+2)  
24e5 32 6d ee			ld (debug_mark+2),a  
24e8 18 03			jr .pastdmark  
24ea ..			.dmark: db "2DR"  
24ed f1			.pastdmark: pop af  
24ee			endm  
# End of macro DMARK
24ee					CALLMONITOR 
24ee cd 6f ee			call debug_vector  
24f1				endm  
# End of macro CALLMONITOR
24f1				endif 
24f1				FORTH_DSP_POP 
24f1 cd 01 1f			call macro_forth_dsp_pop 
24f4				endm 
# End of macro FORTH_DSP_POP
24f4				FORTH_DSP_POP 
24f4 cd 01 1f			call macro_forth_dsp_pop 
24f7				endm 
# End of macro FORTH_DSP_POP
24f7				NEXTW 
24f7 c3 ff 1f			jp macro_next 
24fa				endm 
# End of macro NEXTW
24fa			.SWAP2: 
24fa			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
24fa 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
24fb 23 25			dw .AT            
24fd 06				db 5 + 1 
24fe .. 00			db "2SWAP",0              
2504				endm 
# End of macro CWHEAD
2504			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2504				if DEBUG_FORTH_WORDS_KEY 
2504					DMARK "2SW" 
2504 f5				push af  
2505 3a 19 25			ld a, (.dmark)  
2508 32 6b ee			ld (debug_mark),a  
250b 3a 1a 25			ld a, (.dmark+1)  
250e 32 6c ee			ld (debug_mark+1),a  
2511 3a 1b 25			ld a, (.dmark+2)  
2514 32 6d ee			ld (debug_mark+2),a  
2517 18 03			jr .pastdmark  
2519 ..			.dmark: db "2SW"  
251c f1			.pastdmark: pop af  
251d			endm  
# End of macro DMARK
251d					CALLMONITOR 
251d cd 6f ee			call debug_vector  
2520				endm  
# End of macro CALLMONITOR
2520				endif 
2520			; TODO Use os stack swap memory 
2520				NEXTW 
2520 c3 ff 1f			jp macro_next 
2523				endm 
# End of macro NEXTW
2523			.AT: 
2523			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2523 1f				db WORD_SYS_CORE+OPCODE_AT             
2524 55 25			dw .CAT            
2526 02				db 1 + 1 
2527 .. 00			db "@",0              
2529				endm 
# End of macro CWHEAD
2529			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2529			 
2529				if DEBUG_FORTH_WORDS_KEY 
2529					DMARK "AT." 
2529 f5				push af  
252a 3a 3e 25			ld a, (.dmark)  
252d 32 6b ee			ld (debug_mark),a  
2530 3a 3f 25			ld a, (.dmark+1)  
2533 32 6c ee			ld (debug_mark+1),a  
2536 3a 40 25			ld a, (.dmark+2)  
2539 32 6d ee			ld (debug_mark+2),a  
253c 18 03			jr .pastdmark  
253e ..			.dmark: db "AT."  
2541 f1			.pastdmark: pop af  
2542			endm  
# End of macro DMARK
2542					CALLMONITOR 
2542 cd 6f ee			call debug_vector  
2545				endm  
# End of macro CALLMONITOR
2545				endif 
2545			.getbyteat:	 
2545				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2545 cd 49 1e			call macro_dsp_valuehl 
2548				endm 
# End of macro FORTH_DSP_VALUEHL
2548				 
2548			;		push hl 
2548			 
2548				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2548 cd 01 1f			call macro_forth_dsp_pop 
254b				endm 
# End of macro FORTH_DSP_POP
254b			 
254b			;		pop hl 
254b			 
254b 7e				ld a, (hl) 
254c			 
254c 6f				ld l, a 
254d 26 00			ld h, 0 
254f cd 52 1c			call forth_push_numhl 
2552			 
2552				NEXTW 
2552 c3 ff 1f			jp macro_next 
2555				endm 
# End of macro NEXTW
2555			.CAT: 
2555			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2555 20				db WORD_SYS_CORE+OPCODE_CAT             
2556 7e 25			dw .BANG            
2558 03				db 2 + 1 
2559 .. 00			db "C@",0              
255c				endm 
# End of macro CWHEAD
255c			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
255c				if DEBUG_FORTH_WORDS_KEY 
255c					DMARK "CAA" 
255c f5				push af  
255d 3a 71 25			ld a, (.dmark)  
2560 32 6b ee			ld (debug_mark),a  
2563 3a 72 25			ld a, (.dmark+1)  
2566 32 6c ee			ld (debug_mark+1),a  
2569 3a 73 25			ld a, (.dmark+2)  
256c 32 6d ee			ld (debug_mark+2),a  
256f 18 03			jr .pastdmark  
2571 ..			.dmark: db "CAA"  
2574 f1			.pastdmark: pop af  
2575			endm  
# End of macro DMARK
2575					CALLMONITOR 
2575 cd 6f ee			call debug_vector  
2578				endm  
# End of macro CALLMONITOR
2578				endif 
2578 c3 45 25			jp .getbyteat 
257b				NEXTW 
257b c3 ff 1f			jp macro_next 
257e				endm 
# End of macro NEXTW
257e			.BANG: 
257e			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
257e 21				db WORD_SYS_CORE+OPCODE_BANG             
257f b4 25			dw .CBANG            
2581 02				db 1 + 1 
2582 .. 00			db "!",0              
2584				endm 
# End of macro CWHEAD
2584			; | ! ( x w -- ) Store x at address w      | DONE 
2584				if DEBUG_FORTH_WORDS_KEY 
2584					DMARK "BNG" 
2584 f5				push af  
2585 3a 99 25			ld a, (.dmark)  
2588 32 6b ee			ld (debug_mark),a  
258b 3a 9a 25			ld a, (.dmark+1)  
258e 32 6c ee			ld (debug_mark+1),a  
2591 3a 9b 25			ld a, (.dmark+2)  
2594 32 6d ee			ld (debug_mark+2),a  
2597 18 03			jr .pastdmark  
2599 ..			.dmark: db "BNG"  
259c f1			.pastdmark: pop af  
259d			endm  
# End of macro DMARK
259d					CALLMONITOR 
259d cd 6f ee			call debug_vector  
25a0				endm  
# End of macro CALLMONITOR
25a0				endif 
25a0			 
25a0			.storebyteat:		 
25a0				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25a0 cd 49 1e			call macro_dsp_valuehl 
25a3				endm 
# End of macro FORTH_DSP_VALUEHL
25a3				 
25a3 e5				push hl 
25a4			 
25a4				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25a4 cd 01 1f			call macro_forth_dsp_pop 
25a7				endm 
# End of macro FORTH_DSP_POP
25a7			 
25a7				; get byte to poke 
25a7			 
25a7				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25a7 cd 49 1e			call macro_dsp_valuehl 
25aa				endm 
# End of macro FORTH_DSP_VALUEHL
25aa e5				push hl 
25ab			 
25ab			 
25ab				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25ab cd 01 1f			call macro_forth_dsp_pop 
25ae				endm 
# End of macro FORTH_DSP_POP
25ae			 
25ae			 
25ae d1				pop de 
25af e1				pop hl 
25b0			 
25b0 73				ld (hl),e 
25b1			 
25b1			 
25b1				NEXTW 
25b1 c3 ff 1f			jp macro_next 
25b4				endm 
# End of macro NEXTW
25b4			.CBANG: 
25b4			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
25b4 22				db WORD_SYS_CORE+OPCODE_CBANG             
25b5 dd 25			dw .SCALL            
25b7 03				db 2 + 1 
25b8 .. 00			db "C!",0              
25bb				endm 
# End of macro CWHEAD
25bb			; | C!  ( x w -- ) Store x at address w  | DONE 
25bb				if DEBUG_FORTH_WORDS_KEY 
25bb					DMARK "CBA" 
25bb f5				push af  
25bc 3a d0 25			ld a, (.dmark)  
25bf 32 6b ee			ld (debug_mark),a  
25c2 3a d1 25			ld a, (.dmark+1)  
25c5 32 6c ee			ld (debug_mark+1),a  
25c8 3a d2 25			ld a, (.dmark+2)  
25cb 32 6d ee			ld (debug_mark+2),a  
25ce 18 03			jr .pastdmark  
25d0 ..			.dmark: db "CBA"  
25d3 f1			.pastdmark: pop af  
25d4			endm  
# End of macro DMARK
25d4					CALLMONITOR 
25d4 cd 6f ee			call debug_vector  
25d7				endm  
# End of macro CALLMONITOR
25d7				endif 
25d7 c3 a0 25			jp .storebyteat 
25da				NEXTW 
25da c3 ff 1f			jp macro_next 
25dd				endm 
# End of macro NEXTW
25dd			.SCALL: 
25dd			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
25dd 23				db WORD_SYS_CORE+OPCODE_SCALL             
25de 11 26			dw .DEPTH            
25e0 05				db 4 + 1 
25e1 .. 00			db "CALL",0              
25e6				endm 
# End of macro CWHEAD
25e6			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
25e6				if DEBUG_FORTH_WORDS_KEY 
25e6					DMARK "CLL" 
25e6 f5				push af  
25e7 3a fb 25			ld a, (.dmark)  
25ea 32 6b ee			ld (debug_mark),a  
25ed 3a fc 25			ld a, (.dmark+1)  
25f0 32 6c ee			ld (debug_mark+1),a  
25f3 3a fd 25			ld a, (.dmark+2)  
25f6 32 6d ee			ld (debug_mark+2),a  
25f9 18 03			jr .pastdmark  
25fb ..			.dmark: db "CLL"  
25fe f1			.pastdmark: pop af  
25ff			endm  
# End of macro DMARK
25ff					CALLMONITOR 
25ff cd 6f ee			call debug_vector  
2602				endm  
# End of macro CALLMONITOR
2602				endif 
2602			 
2602				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2602 cd 49 1e			call macro_dsp_valuehl 
2605				endm 
# End of macro FORTH_DSP_VALUEHL
2605			 
2605			;		push hl 
2605			 
2605				; destroy value TOS 
2605			 
2605				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2605 cd 01 1f			call macro_forth_dsp_pop 
2608				endm 
# End of macro FORTH_DSP_POP
2608			 
2608					 
2608			;		pop hl 
2608			 
2608				; how to do a call with hl???? save SP? 
2608 cd a3 1f			call forth_call_hl 
260b			 
260b			 
260b				; TODO push value back onto stack for another op etc 
260b			 
260b cd 52 1c			call forth_push_numhl 
260e				NEXTW 
260e c3 ff 1f			jp macro_next 
2611				endm 
# End of macro NEXTW
2611			.DEPTH: 
2611			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2611 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2612 4e 26			dw .OVER            
2614 06				db 5 + 1 
2615 .. 00			db "DEPTH",0              
261b				endm 
# End of macro CWHEAD
261b			; | DEPTH ( -- u ) Push count of stack | DONE 
261b				; take current TOS and remove from base value div by two to get count 
261b				if DEBUG_FORTH_WORDS_KEY 
261b					DMARK "DEP" 
261b f5				push af  
261c 3a 30 26			ld a, (.dmark)  
261f 32 6b ee			ld (debug_mark),a  
2622 3a 31 26			ld a, (.dmark+1)  
2625 32 6c ee			ld (debug_mark+1),a  
2628 3a 32 26			ld a, (.dmark+2)  
262b 32 6d ee			ld (debug_mark+2),a  
262e 18 03			jr .pastdmark  
2630 ..			.dmark: db "DEP"  
2633 f1			.pastdmark: pop af  
2634			endm  
# End of macro DMARK
2634					CALLMONITOR 
2634 cd 6f ee			call debug_vector  
2637				endm  
# End of macro CALLMONITOR
2637				endif 
2637			 
2637			 
2637 2a ee e9		ld hl, (cli_data_sp) 
263a 11 28 e8		ld de, cli_data_stack 
263d ed 52		sbc hl,de 
263f			 
263f			; div by size of stack item 
263f			 
263f 5d			ld e,l 
2640 0e 03		ld c, 3 
2642 cd 76 0d		call Div8 
2645			 
2645 6f			ld l,a 
2646 26 00		ld h,0 
2648			 
2648			;srl h 
2648			;rr l 
2648			 
2648 cd 52 1c			call forth_push_numhl 
264b				NEXTW 
264b c3 ff 1f			jp macro_next 
264e				endm 
# End of macro NEXTW
264e			.OVER: 
264e			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
264e 42				db WORD_SYS_CORE+46             
264f 95 26			dw .PAUSE            
2651 05				db 4 + 1 
2652 .. 00			db "OVER",0              
2657				endm 
# End of macro CWHEAD
2657			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2657				if DEBUG_FORTH_WORDS_KEY 
2657					DMARK "OVR" 
2657 f5				push af  
2658 3a 6c 26			ld a, (.dmark)  
265b 32 6b ee			ld (debug_mark),a  
265e 3a 6d 26			ld a, (.dmark+1)  
2661 32 6c ee			ld (debug_mark+1),a  
2664 3a 6e 26			ld a, (.dmark+2)  
2667 32 6d ee			ld (debug_mark+2),a  
266a 18 03			jr .pastdmark  
266c ..			.dmark: db "OVR"  
266f f1			.pastdmark: pop af  
2670			endm  
# End of macro DMARK
2670					CALLMONITOR 
2670 cd 6f ee			call debug_vector  
2673				endm  
# End of macro CALLMONITOR
2673				endif 
2673			 
2673			; TODO Use os stack swap memory 
2673				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2673 cd 49 1e			call macro_dsp_valuehl 
2676				endm 
# End of macro FORTH_DSP_VALUEHL
2676 e5				push hl    ; n2 
2677				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2677 cd 01 1f			call macro_forth_dsp_pop 
267a				endm 
# End of macro FORTH_DSP_POP
267a			 
267a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
267a cd 49 1e			call macro_dsp_valuehl 
267d				endm 
# End of macro FORTH_DSP_VALUEHL
267d e5				push hl    ; n1 
267e				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
267e cd 01 1f			call macro_forth_dsp_pop 
2681				endm 
# End of macro FORTH_DSP_POP
2681			 
2681 d1				pop de     ; n1 
2682 e1				pop hl     ; n2 
2683			 
2683 d5				push de 
2684 e5				push hl 
2685 d5				push de 
2686			 
2686				; push back  
2686			 
2686 e1				pop hl 
2687 cd 52 1c			call forth_push_numhl 
268a e1				pop hl 
268b cd 52 1c			call forth_push_numhl 
268e e1				pop hl 
268f cd 52 1c			call forth_push_numhl 
2692				NEXTW 
2692 c3 ff 1f			jp macro_next 
2695				endm 
# End of macro NEXTW
2695			 
2695			.PAUSE: 
2695			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2695 43				db WORD_SYS_CORE+47             
2696 ca 26			dw .PAUSES            
2698 08				db 7 + 1 
2699 .. 00			db "PAUSEMS",0              
26a1				endm 
# End of macro CWHEAD
26a1			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
26a1				if DEBUG_FORTH_WORDS_KEY 
26a1					DMARK "PMS" 
26a1 f5				push af  
26a2 3a b6 26			ld a, (.dmark)  
26a5 32 6b ee			ld (debug_mark),a  
26a8 3a b7 26			ld a, (.dmark+1)  
26ab 32 6c ee			ld (debug_mark+1),a  
26ae 3a b8 26			ld a, (.dmark+2)  
26b1 32 6d ee			ld (debug_mark+2),a  
26b4 18 03			jr .pastdmark  
26b6 ..			.dmark: db "PMS"  
26b9 f1			.pastdmark: pop af  
26ba			endm  
# End of macro DMARK
26ba					CALLMONITOR 
26ba cd 6f ee			call debug_vector  
26bd				endm  
# End of macro CALLMONITOR
26bd				endif 
26bd				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26bd cd 49 1e			call macro_dsp_valuehl 
26c0				endm 
# End of macro FORTH_DSP_VALUEHL
26c0			;		push hl    ; n2 
26c0				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26c0 cd 01 1f			call macro_forth_dsp_pop 
26c3				endm 
# End of macro FORTH_DSP_POP
26c3			;		pop hl 
26c3			 
26c3 7d				ld a, l 
26c4 cd d6 0a			call aDelayInMS 
26c7			       NEXTW 
26c7 c3 ff 1f			jp macro_next 
26ca				endm 
# End of macro NEXTW
26ca			.PAUSES:  
26ca			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
26ca 44				db WORD_SYS_CORE+48             
26cb 39 27			dw .ROT            
26cd 06				db 5 + 1 
26ce .. 00			db "PAUSE",0              
26d4				endm 
# End of macro CWHEAD
26d4			; | PAUSE ( n -- )  Pause for n seconds | DONE 
26d4				if DEBUG_FORTH_WORDS_KEY 
26d4					DMARK "PAU" 
26d4 f5				push af  
26d5 3a e9 26			ld a, (.dmark)  
26d8 32 6b ee			ld (debug_mark),a  
26db 3a ea 26			ld a, (.dmark+1)  
26de 32 6c ee			ld (debug_mark+1),a  
26e1 3a eb 26			ld a, (.dmark+2)  
26e4 32 6d ee			ld (debug_mark+2),a  
26e7 18 03			jr .pastdmark  
26e9 ..			.dmark: db "PAU"  
26ec f1			.pastdmark: pop af  
26ed			endm  
# End of macro DMARK
26ed					CALLMONITOR 
26ed cd 6f ee			call debug_vector  
26f0				endm  
# End of macro CALLMONITOR
26f0				endif 
26f0				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26f0 cd 49 1e			call macro_dsp_valuehl 
26f3				endm 
# End of macro FORTH_DSP_VALUEHL
26f3			;		push hl    ; n2 
26f3				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26f3 cd 01 1f			call macro_forth_dsp_pop 
26f6				endm 
# End of macro FORTH_DSP_POP
26f6			;		pop hl 
26f6 45				ld b, l 
26f7				if DEBUG_FORTH_WORDS 
26f7					DMARK "PAU" 
26f7 f5				push af  
26f8 3a 0c 27			ld a, (.dmark)  
26fb 32 6b ee			ld (debug_mark),a  
26fe 3a 0d 27			ld a, (.dmark+1)  
2701 32 6c ee			ld (debug_mark+1),a  
2704 3a 0e 27			ld a, (.dmark+2)  
2707 32 6d ee			ld (debug_mark+2),a  
270a 18 03			jr .pastdmark  
270c ..			.dmark: db "PAU"  
270f f1			.pastdmark: pop af  
2710			endm  
# End of macro DMARK
2710					CALLMONITOR 
2710 cd 6f ee			call debug_vector  
2713				endm  
# End of macro CALLMONITOR
2713				endif 
2713 c5			.pauses1:	push bc 
2714 cd f1 0a			call delay1s 
2717 c1				pop bc 
2718				if DEBUG_FORTH_WORDS 
2718					DMARK "PA1" 
2718 f5				push af  
2719 3a 2d 27			ld a, (.dmark)  
271c 32 6b ee			ld (debug_mark),a  
271f 3a 2e 27			ld a, (.dmark+1)  
2722 32 6c ee			ld (debug_mark+1),a  
2725 3a 2f 27			ld a, (.dmark+2)  
2728 32 6d ee			ld (debug_mark+2),a  
272b 18 03			jr .pastdmark  
272d ..			.dmark: db "PA1"  
2730 f1			.pastdmark: pop af  
2731			endm  
# End of macro DMARK
2731					CALLMONITOR 
2731 cd 6f ee			call debug_vector  
2734				endm  
# End of macro CALLMONITOR
2734				endif 
2734 10 dd			djnz .pauses1 
2736			 
2736			       NEXTW 
2736 c3 ff 1f			jp macro_next 
2739				endm 
# End of macro NEXTW
2739			.ROT: 
2739			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2739 45				db WORD_SYS_CORE+49             
273a 87 27			dw .UWORDS            
273c 04				db 3 + 1 
273d .. 00			db "ROT",0              
2741				endm 
# End of macro CWHEAD
2741			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2741				if DEBUG_FORTH_WORDS_KEY 
2741					DMARK "ROT" 
2741 f5				push af  
2742 3a 56 27			ld a, (.dmark)  
2745 32 6b ee			ld (debug_mark),a  
2748 3a 57 27			ld a, (.dmark+1)  
274b 32 6c ee			ld (debug_mark+1),a  
274e 3a 58 27			ld a, (.dmark+2)  
2751 32 6d ee			ld (debug_mark+2),a  
2754 18 03			jr .pastdmark  
2756 ..			.dmark: db "ROT"  
2759 f1			.pastdmark: pop af  
275a			endm  
# End of macro DMARK
275a					CALLMONITOR 
275a cd 6f ee			call debug_vector  
275d				endm  
# End of macro CALLMONITOR
275d				endif 
275d			 
275d			; TODO Use os stack swap memory 
275d				FORTH_DSP_VALUEHL 
275d cd 49 1e			call macro_dsp_valuehl 
2760				endm 
# End of macro FORTH_DSP_VALUEHL
2760 e5				push hl    ; u3  
2761			 
2761				FORTH_DSP_POP 
2761 cd 01 1f			call macro_forth_dsp_pop 
2764				endm 
# End of macro FORTH_DSP_POP
2764			 
2764				FORTH_DSP_VALUEHL 
2764 cd 49 1e			call macro_dsp_valuehl 
2767				endm 
# End of macro FORTH_DSP_VALUEHL
2767 e5				push hl     ; u2 
2768			 
2768				FORTH_DSP_POP 
2768 cd 01 1f			call macro_forth_dsp_pop 
276b				endm 
# End of macro FORTH_DSP_POP
276b			 
276b				FORTH_DSP_VALUEHL 
276b cd 49 1e			call macro_dsp_valuehl 
276e				endm 
# End of macro FORTH_DSP_VALUEHL
276e e5				push hl     ; u1 
276f			 
276f				FORTH_DSP_POP 
276f cd 01 1f			call macro_forth_dsp_pop 
2772				endm 
# End of macro FORTH_DSP_POP
2772			 
2772 c1				pop bc      ; u1 
2773 e1				pop hl      ; u2 
2774 d1				pop de      ; u3 
2775			 
2775			 
2775 c5				push bc 
2776 d5				push de 
2777 e5				push hl 
2778			 
2778			 
2778 e1				pop hl 
2779 cd 52 1c			call forth_push_numhl 
277c			 
277c e1				pop hl 
277d cd 52 1c			call forth_push_numhl 
2780			 
2780 e1				pop hl 
2781 cd 52 1c			call forth_push_numhl 
2784				 
2784			 
2784			 
2784			 
2784			 
2784			 
2784			       NEXTW 
2784 c3 ff 1f			jp macro_next 
2787				endm 
# End of macro NEXTW
2787			 
2787			.UWORDS: 
2787			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2787 50				db WORD_SYS_CORE+60             
2788 49 28			dw .BP            
278a 07				db 6 + 1 
278b .. 00			db "UWORDS",0              
2792				endm 
# End of macro CWHEAD
2792			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2792			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2792			; | | Following the count are the individual words. 
2792			; | | 
2792			; | | e.g. UWORDS 
2792			; | | BOX DIRLIST 2 
2792			; | |  
2792			; | | Can be used to save the words to storage via: 
2792			; | | UWORDS $01 DO $01 APPEND LOOP 
2792			if DEBUG_FORTH_WORDS_KEY 
2792				DMARK "UWR" 
2792 f5				push af  
2793 3a a7 27			ld a, (.dmark)  
2796 32 6b ee			ld (debug_mark),a  
2799 3a a8 27			ld a, (.dmark+1)  
279c 32 6c ee			ld (debug_mark+1),a  
279f 3a a9 27			ld a, (.dmark+2)  
27a2 32 6d ee			ld (debug_mark+2),a  
27a5 18 03			jr .pastdmark  
27a7 ..			.dmark: db "UWR"  
27aa f1			.pastdmark: pop af  
27ab			endm  
# End of macro DMARK
27ab				CALLMONITOR 
27ab cd 6f ee			call debug_vector  
27ae				endm  
# End of macro CALLMONITOR
27ae			endif 
27ae 21 47 66			ld hl, baseram 
27b1				;ld hl, baseusermem 
27b1 01 00 00			ld bc, 0    ; start a counter 
27b4			 
27b4			; skip dict stub 
27b4			 
27b4 cd 50 21			call forth_tok_next 
27b7			 
27b7			 
27b7			; while we have words to look for 
27b7			 
27b7 7e			.douscan:	ld a, (hl)      
27b8			if DEBUG_FORTH_WORDS 
27b8				DMARK "UWs" 
27b8 f5				push af  
27b9 3a cd 27			ld a, (.dmark)  
27bc 32 6b ee			ld (debug_mark),a  
27bf 3a ce 27			ld a, (.dmark+1)  
27c2 32 6c ee			ld (debug_mark+1),a  
27c5 3a cf 27			ld a, (.dmark+2)  
27c8 32 6d ee			ld (debug_mark+2),a  
27cb 18 03			jr .pastdmark  
27cd ..			.dmark: db "UWs"  
27d0 f1			.pastdmark: pop af  
27d1			endm  
# End of macro DMARK
27d1				CALLMONITOR 
27d1 cd 6f ee			call debug_vector  
27d4				endm  
# End of macro CALLMONITOR
27d4			endif 
27d4 fe 00			cp WORD_SYS_END 
27d6 28 4d			jr z, .udone 
27d8 fe 01			cp WORD_SYS_UWORD 
27da 20 44			jr nz, .nuword 
27dc			 
27dc			if DEBUG_FORTH_WORDS 
27dc				DMARK "UWu" 
27dc f5				push af  
27dd 3a f1 27			ld a, (.dmark)  
27e0 32 6b ee			ld (debug_mark),a  
27e3 3a f2 27			ld a, (.dmark+1)  
27e6 32 6c ee			ld (debug_mark+1),a  
27e9 3a f3 27			ld a, (.dmark+2)  
27ec 32 6d ee			ld (debug_mark+2),a  
27ef 18 03			jr .pastdmark  
27f1 ..			.dmark: db "UWu"  
27f4 f1			.pastdmark: pop af  
27f5			endm  
# End of macro DMARK
27f5				CALLMONITOR 
27f5 cd 6f ee			call debug_vector  
27f8				endm  
# End of macro CALLMONITOR
27f8			endif 
27f8				; we have a uword so push its name to the stack 
27f8			 
27f8 e5				push hl  ; save so we can move to next dict block 
27f9			 
27f9				; skip opcode 
27f9 23				inc hl  
27fa				; skip next ptr 
27fa 23				inc hl  
27fb 23				inc hl 
27fc				; skip len 
27fc 23				inc hl 
27fd			if DEBUG_FORTH_WORDS 
27fd				DMARK "UWt" 
27fd f5				push af  
27fe 3a 12 28			ld a, (.dmark)  
2801 32 6b ee			ld (debug_mark),a  
2804 3a 13 28			ld a, (.dmark+1)  
2807 32 6c ee			ld (debug_mark+1),a  
280a 3a 14 28			ld a, (.dmark+2)  
280d 32 6d ee			ld (debug_mark+2),a  
2810 18 03			jr .pastdmark  
2812 ..			.dmark: db "UWt"  
2815 f1			.pastdmark: pop af  
2816			endm  
# End of macro DMARK
2816				CALLMONITOR 
2816 cd 6f ee			call debug_vector  
2819				endm  
# End of macro CALLMONITOR
2819			endif 
2819 03				inc bc 
281a			 
281a c5				push bc 
281b cd c0 1c			call forth_push_str 
281e c1				pop bc 
281f			 
281f e1				pop hl 	 
2820			 
2820 cd 50 21		.nuword:	call forth_tok_next 
2823 18 92			jr .douscan  
2825			 
2825			.udone:		 ; push count of uwords found 
2825 c5				push bc 
2826 e1				pop hl 
2827			 
2827			if DEBUG_FORTH_WORDS 
2827				DMARK "UWc" 
2827 f5				push af  
2828 3a 3c 28			ld a, (.dmark)  
282b 32 6b ee			ld (debug_mark),a  
282e 3a 3d 28			ld a, (.dmark+1)  
2831 32 6c ee			ld (debug_mark+1),a  
2834 3a 3e 28			ld a, (.dmark+2)  
2837 32 6d ee			ld (debug_mark+2),a  
283a 18 03			jr .pastdmark  
283c ..			.dmark: db "UWc"  
283f f1			.pastdmark: pop af  
2840			endm  
# End of macro DMARK
2840				CALLMONITOR 
2840 cd 6f ee			call debug_vector  
2843				endm  
# End of macro CALLMONITOR
2843			endif 
2843 cd 52 1c			call forth_push_numhl 
2846			 
2846			 
2846			       NEXTW 
2846 c3 ff 1f			jp macro_next 
2849				endm 
# End of macro NEXTW
2849			 
2849			.BP: 
2849			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2849 54				db WORD_SYS_CORE+64             
284a 83 28			dw .MONITOR            
284c 03				db 2 + 1 
284d .. 00			db "BP",0              
2850				endm 
# End of macro CWHEAD
2850			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2850			; | | $00 Will enable the break points within specific code paths 
2850			; | | $01 Will disable break points 
2850			; | |  
2850			; | | By default break points are off. Either the above can be used to enable them 
2850			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2850			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2850			; | | can disable break points. Exiting will then continue boot process. 
2850				; get byte count 
2850				if DEBUG_FORTH_WORDS_KEY 
2850					DMARK "BP." 
2850 f5				push af  
2851 3a 65 28			ld a, (.dmark)  
2854 32 6b ee			ld (debug_mark),a  
2857 3a 66 28			ld a, (.dmark+1)  
285a 32 6c ee			ld (debug_mark+1),a  
285d 3a 67 28			ld a, (.dmark+2)  
2860 32 6d ee			ld (debug_mark+2),a  
2863 18 03			jr .pastdmark  
2865 ..			.dmark: db "BP."  
2868 f1			.pastdmark: pop af  
2869			endm  
# End of macro DMARK
2869					CALLMONITOR 
2869 cd 6f ee			call debug_vector  
286c				endm  
# End of macro CALLMONITOR
286c				endif 
286c			 
286c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
286c cd 49 1e			call macro_dsp_valuehl 
286f				endm 
# End of macro FORTH_DSP_VALUEHL
286f			 
286f			;		push hl 
286f			 
286f				; destroy value TOS 
286f			 
286f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
286f cd 01 1f			call macro_forth_dsp_pop 
2872				endm 
# End of macro FORTH_DSP_POP
2872			 
2872			;		pop hl 
2872			 
2872 3e 00			ld a,0 
2874 bd				cp l 
2875 28 06			jr z, .bpset 
2877			;		ld a, '*' 
2877 cd f4 15			call bp_off 
287a				NEXTW 
287a c3 ff 1f			jp macro_next 
287d				endm 
# End of macro NEXTW
287d			 
287d			.bpset:	 
287d				;	ld (os_view_disable), a 
287d cd e8 15			call bp_on 
2880			 
2880			 
2880				NEXTW 
2880 c3 ff 1f			jp macro_next 
2883				endm 
# End of macro NEXTW
2883			 
2883			 
2883			.MONITOR: 
2883			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2883 55				db WORD_SYS_CORE+65             
2884 b4 28			dw .MALLOC            
2886 08				db 7 + 1 
2887 .. 00			db "MONITOR",0              
288f				endm 
# End of macro CWHEAD
288f			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
288f			; | | At start the current various registers will be displayed with contents. 
288f			; | | Top right corner will show the most recent debug marker seen. 
288f			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
288f			; | | and the return stack pointer (RSP). 
288f			; | | Pressing: 
288f			; | |    1 - Initial screen 
288f			; | |    2 - Display a data dump of HL 
288f			; | |    3 - Display a data dump of DE 
288f			; | |    4 - Display a data dump of BC 
288f			; | |    5 - Display a data dump of HL 
288f			; | |    6 - Display a data dump of DSP 
288f			; | |    7 - Display a data dump of RSP 
288f			; | |    8 - Display a data dump of what is at DSP 
288f			; | |    9 - Display a data dump of what is at RSP 
288f			; | |    0 - Exit monitor and continue running. This will also enable break points 
288f			; | |    * - Disable break points 
288f			; | |    # - Enter traditional monitor mode 
288f			; | | 
288f			; | | Monitor Mode 
288f			; | | ------------ 
288f			; | | A prompt of '>' will be shown for various commands: 
288f			; | |    D xxxx - Display a data dump starting from hex address xxxx 
288f			; | |    C - Continue display a data dump from the last set address 
288f			; | |    M xxxx - Set start of memory edit at address xx 
288f			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
288f			; | |    G xxxx - Exec code at specific address 
288f			; | |    Q - Return to previous 
288f				if DEBUG_FORTH_WORDS_KEY 
288f					DMARK "MON" 
288f f5				push af  
2890 3a a4 28			ld a, (.dmark)  
2893 32 6b ee			ld (debug_mark),a  
2896 3a a5 28			ld a, (.dmark+1)  
2899 32 6c ee			ld (debug_mark+1),a  
289c 3a a6 28			ld a, (.dmark+2)  
289f 32 6d ee			ld (debug_mark+2),a  
28a2 18 03			jr .pastdmark  
28a4 ..			.dmark: db "MON"  
28a7 f1			.pastdmark: pop af  
28a8			endm  
# End of macro DMARK
28a8					CALLMONITOR 
28a8 cd 6f ee			call debug_vector  
28ab				endm  
# End of macro CALLMONITOR
28ab				endif 
28ab			;		ld a, 0 
28ab			;		ld (os_view_disable), a 
28ab cd e8 15			call bp_on 
28ae			 
28ae				CALLMONITOR 
28ae cd 6f ee			call debug_vector  
28b1				endm  
# End of macro CALLMONITOR
28b1			 
28b1			;	call monitor 
28b1			 
28b1				NEXTW 
28b1 c3 ff 1f			jp macro_next 
28b4				endm 
# End of macro NEXTW
28b4			 
28b4			 
28b4			.MALLOC: 
28b4			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28b4 56				db WORD_SYS_CORE+66             
28b5 dd 28			dw .MALLOC2            
28b7 06				db 5 + 1 
28b8 .. 00			db "ALLOT",0              
28be				endm 
# End of macro CWHEAD
28be			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28be				if DEBUG_FORTH_WORDS_KEY 
28be					DMARK "ALL" 
28be f5				push af  
28bf 3a d3 28			ld a, (.dmark)  
28c2 32 6b ee			ld (debug_mark),a  
28c5 3a d4 28			ld a, (.dmark+1)  
28c8 32 6c ee			ld (debug_mark+1),a  
28cb 3a d5 28			ld a, (.dmark+2)  
28ce 32 6d ee			ld (debug_mark+2),a  
28d1 18 03			jr .pastdmark  
28d3 ..			.dmark: db "ALL"  
28d6 f1			.pastdmark: pop af  
28d7			endm  
# End of macro DMARK
28d7					CALLMONITOR 
28d7 cd 6f ee			call debug_vector  
28da				endm  
# End of macro CALLMONITOR
28da				endif 
28da c3 04 29			jp .mallocc 
28dd			.MALLOC2: 
28dd			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
28dd 56				db WORD_SYS_CORE+66             
28de 1b 29			dw .FREE            
28e0 07				db 6 + 1 
28e1 .. 00			db "MALLOC",0              
28e8				endm 
# End of macro CWHEAD
28e8			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28e8				; get byte count 
28e8				if DEBUG_FORTH_WORDS_KEY 
28e8					DMARK "MAL" 
28e8 f5				push af  
28e9 3a fd 28			ld a, (.dmark)  
28ec 32 6b ee			ld (debug_mark),a  
28ef 3a fe 28			ld a, (.dmark+1)  
28f2 32 6c ee			ld (debug_mark+1),a  
28f5 3a ff 28			ld a, (.dmark+2)  
28f8 32 6d ee			ld (debug_mark+2),a  
28fb 18 03			jr .pastdmark  
28fd ..			.dmark: db "MAL"  
2900 f1			.pastdmark: pop af  
2901			endm  
# End of macro DMARK
2901					CALLMONITOR 
2901 cd 6f ee			call debug_vector  
2904				endm  
# End of macro CALLMONITOR
2904				endif 
2904			.mallocc: 
2904				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2904 cd 49 1e			call macro_dsp_valuehl 
2907				endm 
# End of macro FORTH_DSP_VALUEHL
2907			 
2907			;		push hl 
2907			 
2907				; destroy value TOS 
2907			 
2907				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2907 cd 01 1f			call macro_forth_dsp_pop 
290a				endm 
# End of macro FORTH_DSP_POP
290a			 
290a			;		pop hl 
290a cd b9 12			call malloc 
290d			if DEBUG_FORTH_MALLOC_GUARD 
290d f5				push af 
290e cd 0f 0e			call ishlzero 
2911			;		ld a, l 
2911			;		add h 
2911			;		cp 0 
2911 f1				pop af 
2912				 
2912 cc bf 4d			call z,malloc_error 
2915			endif 
2915			 
2915 cd 52 1c			call forth_push_numhl 
2918				NEXTW 
2918 c3 ff 1f			jp macro_next 
291b				endm 
# End of macro NEXTW
291b			 
291b			.FREE: 
291b			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
291b 57				db WORD_SYS_CORE+67             
291c 4c 29			dw .LIST            
291e 05				db 4 + 1 
291f .. 00			db "FREE",0              
2924				endm 
# End of macro CWHEAD
2924			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2924				if DEBUG_FORTH_WORDS_KEY 
2924					DMARK "FRE" 
2924 f5				push af  
2925 3a 39 29			ld a, (.dmark)  
2928 32 6b ee			ld (debug_mark),a  
292b 3a 3a 29			ld a, (.dmark+1)  
292e 32 6c ee			ld (debug_mark+1),a  
2931 3a 3b 29			ld a, (.dmark+2)  
2934 32 6d ee			ld (debug_mark+2),a  
2937 18 03			jr .pastdmark  
2939 ..			.dmark: db "FRE"  
293c f1			.pastdmark: pop af  
293d			endm  
# End of macro DMARK
293d					CALLMONITOR 
293d cd 6f ee			call debug_vector  
2940				endm  
# End of macro CALLMONITOR
2940				endif 
2940				; get address 
2940			 
2940				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2940 cd 49 1e			call macro_dsp_valuehl 
2943				endm 
# End of macro FORTH_DSP_VALUEHL
2943			 
2943			;		push hl 
2943			 
2943				; destroy value TOS 
2943			 
2943				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2943 cd 01 1f			call macro_forth_dsp_pop 
2946				endm 
# End of macro FORTH_DSP_POP
2946			 
2946			;		pop hl 
2946			if FORTH_ENABLE_MALLOCFREE 
2946 cd 83 13			call free 
2949			endif 
2949				NEXTW 
2949 c3 ff 1f			jp macro_next 
294c				endm 
# End of macro NEXTW
294c			.LIST: 
294c			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
294c 5c				db WORD_SYS_CORE+72             
294d 3c 2b			dw .FORGET            
294f 05				db 4 + 1 
2950 .. 00			db "LIST",0              
2955				endm 
# End of macro CWHEAD
2955			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2955			; | | The quoted word must be in upper case. 
2955			if DEBUG_FORTH_WORDS_KEY 
2955				DMARK "LST" 
2955 f5				push af  
2956 3a 6a 29			ld a, (.dmark)  
2959 32 6b ee			ld (debug_mark),a  
295c 3a 6b 29			ld a, (.dmark+1)  
295f 32 6c ee			ld (debug_mark+1),a  
2962 3a 6c 29			ld a, (.dmark+2)  
2965 32 6d ee			ld (debug_mark+2),a  
2968 18 03			jr .pastdmark  
296a ..			.dmark: db "LST"  
296d f1			.pastdmark: pop af  
296e			endm  
# End of macro DMARK
296e				CALLMONITOR 
296e cd 6f ee			call debug_vector  
2971				endm  
# End of macro CALLMONITOR
2971			endif 
2971			 
2971				FORTH_DSP_VALUEHL 
2971 cd 49 1e			call macro_dsp_valuehl 
2974				endm 
# End of macro FORTH_DSP_VALUEHL
2974			 
2974 e5				push hl 
2975				FORTH_DSP_POP 
2975 cd 01 1f			call macro_forth_dsp_pop 
2978				endm 
# End of macro FORTH_DSP_POP
2978 c1				pop bc 
2979			 
2979			; Start format of scratch string 
2979			 
2979 21 c1 e2			ld hl, scratch 
297c			 
297c 3e 3a			ld a, ':' 
297e 77				ld (hl),a 
297f 23				inc hl 
2980 3e 20			ld a, ' ' 
2982 77				ld (hl), a 
2983			 
2983				; Get ptr to the word we need to look up 
2983			 
2983			;		FORTH_DSP_VALUEHL 
2983				;v5 FORTH_DSP_VALUE 
2983			; TODO type check 
2983			;		inc hl    ; Skip type check  
2983			;		push hl 
2983			;		ex de, hl    ; put into DE 
2983			 
2983			 
2983 21 47 66			ld hl, baseram 
2986				;ld hl, baseusermem 
2986			 
2986 e5			push hl   ; sacreifical push 
2987			 
2987			.ldouscanm: 
2987 e1			pop hl 
2988			.ldouscan: 
2988			if DEBUG_FORTH_WORDS 
2988				DMARK "LSs" 
2988 f5				push af  
2989 3a 9d 29			ld a, (.dmark)  
298c 32 6b ee			ld (debug_mark),a  
298f 3a 9e 29			ld a, (.dmark+1)  
2992 32 6c ee			ld (debug_mark+1),a  
2995 3a 9f 29			ld a, (.dmark+2)  
2998 32 6d ee			ld (debug_mark+2),a  
299b 18 03			jr .pastdmark  
299d ..			.dmark: db "LSs"  
29a0 f1			.pastdmark: pop af  
29a1			endm  
# End of macro DMARK
29a1				CALLMONITOR 
29a1 cd 6f ee			call debug_vector  
29a4				endm  
# End of macro CALLMONITOR
29a4			endif 
29a4			; skip dict stub 
29a4 cd 50 21			call forth_tok_next 
29a7			 
29a7			 
29a7			; while we have words to look for 
29a7			 
29a7 7e			ld a, (hl)      
29a8			if DEBUG_FORTH_WORDS 
29a8				DMARK "LSk" 
29a8 f5				push af  
29a9 3a bd 29			ld a, (.dmark)  
29ac 32 6b ee			ld (debug_mark),a  
29af 3a be 29			ld a, (.dmark+1)  
29b2 32 6c ee			ld (debug_mark+1),a  
29b5 3a bf 29			ld a, (.dmark+2)  
29b8 32 6d ee			ld (debug_mark+2),a  
29bb 18 03			jr .pastdmark  
29bd ..			.dmark: db "LSk"  
29c0 f1			.pastdmark: pop af  
29c1			endm  
# End of macro DMARK
29c1				CALLMONITOR 
29c1 cd 6f ee			call debug_vector  
29c4				endm  
# End of macro CALLMONITOR
29c4			endif 
29c4				;cp WORD_SYS_END 
29c4				;jp z, .lunotfound 
29c4			 
29c4					; if we hit non uwords then gone too far 
29c4 fe 01				cp WORD_SYS_UWORD 
29c6 c2 f8 2a				jp nz, .lunotfound 
29c9			 
29c9				if DEBUG_FORTH_WORDS 
29c9					DMARK "LSu" 
29c9 f5				push af  
29ca 3a de 29			ld a, (.dmark)  
29cd 32 6b ee			ld (debug_mark),a  
29d0 3a df 29			ld a, (.dmark+1)  
29d3 32 6c ee			ld (debug_mark+1),a  
29d6 3a e0 29			ld a, (.dmark+2)  
29d9 32 6d ee			ld (debug_mark+2),a  
29dc 18 03			jr .pastdmark  
29de ..			.dmark: db "LSu"  
29e1 f1			.pastdmark: pop af  
29e2			endm  
# End of macro DMARK
29e2					CALLMONITOR 
29e2 cd 6f ee			call debug_vector  
29e5				endm  
# End of macro CALLMONITOR
29e5				endif 
29e5			 
29e5					; found a uword but is it the one we want... 
29e5			 
29e5 c5					push bc     ; uword to find is on bc 
29e6 d1					pop de 
29e7			 
29e7 e5					push hl  ; to save the ptr 
29e8			 
29e8					; skip opcode 
29e8 23					inc hl  
29e9					; skip next ptr 
29e9 23					inc hl  
29ea 23					inc hl 
29eb					; skip len 
29eb 23					inc hl 
29ec			 
29ec				if DEBUG_FORTH_WORDS 
29ec					DMARK "LSc" 
29ec f5				push af  
29ed 3a 01 2a			ld a, (.dmark)  
29f0 32 6b ee			ld (debug_mark),a  
29f3 3a 02 2a			ld a, (.dmark+1)  
29f6 32 6c ee			ld (debug_mark+1),a  
29f9 3a 03 2a			ld a, (.dmark+2)  
29fc 32 6d ee			ld (debug_mark+2),a  
29ff 18 03			jr .pastdmark  
2a01 ..			.dmark: db "LSc"  
2a04 f1			.pastdmark: pop af  
2a05			endm  
# End of macro DMARK
2a05					CALLMONITOR 
2a05 cd 6f ee			call debug_vector  
2a08				endm  
# End of macro CALLMONITOR
2a08				endif 
2a08			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2a08			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2a08			; Nope that has gone the other way. It needs to be exact not on first zero 
2a08			;		call strcmp 
2a08 c5					push bc 
2a09 cd 89 12				call StrictStrCmp 
2a0c c1					pop bc 
2a0d c2 87 29				jp nz, .ldouscanm 
2a10				 
2a10			 
2a10			 
2a10					; we have a uword so push its name to the stack 
2a10			 
2a10			;	   	push hl  ; save so we can move to next dict block 
2a10 e1			pop hl 
2a11			 
2a11				if DEBUG_FORTH_WORDS 
2a11					DMARK "LSm" 
2a11 f5				push af  
2a12 3a 26 2a			ld a, (.dmark)  
2a15 32 6b ee			ld (debug_mark),a  
2a18 3a 27 2a			ld a, (.dmark+1)  
2a1b 32 6c ee			ld (debug_mark+1),a  
2a1e 3a 28 2a			ld a, (.dmark+2)  
2a21 32 6d ee			ld (debug_mark+2),a  
2a24 18 03			jr .pastdmark  
2a26 ..			.dmark: db "LSm"  
2a29 f1			.pastdmark: pop af  
2a2a			endm  
# End of macro DMARK
2a2a					CALLMONITOR 
2a2a cd 6f ee			call debug_vector  
2a2d				endm  
# End of macro CALLMONITOR
2a2d				endif 
2a2d			 
2a2d					; skip opcode 
2a2d 23					inc hl  
2a2e					; skip next ptr 
2a2e 23					inc hl  
2a2f 23					inc hl 
2a30					; skip len 
2a30 7e					ld a, (hl)   ; save length to add 
2a31				if DEBUG_FORTH_WORDS 
2a31					DMARK "LS2" 
2a31 f5				push af  
2a32 3a 46 2a			ld a, (.dmark)  
2a35 32 6b ee			ld (debug_mark),a  
2a38 3a 47 2a			ld a, (.dmark+1)  
2a3b 32 6c ee			ld (debug_mark+1),a  
2a3e 3a 48 2a			ld a, (.dmark+2)  
2a41 32 6d ee			ld (debug_mark+2),a  
2a44 18 03			jr .pastdmark  
2a46 ..			.dmark: db "LS2"  
2a49 f1			.pastdmark: pop af  
2a4a			endm  
# End of macro DMARK
2a4a					CALLMONITOR 
2a4a cd 6f ee			call debug_vector  
2a4d				endm  
# End of macro CALLMONITOR
2a4d				endif 
2a4d			 
2a4d					; save this location 
2a4d				 
2a4d e5					push hl 
2a4e			 
2a4e 23					inc hl 
2a4f 11 c3 e2				ld de, scratch+2 
2a52 4f					ld c, a 
2a53 06 00				ld b, 0 
2a55			 
2a55				if DEBUG_FORTH_WORDS 
2a55					DMARK "LSn" 
2a55 f5				push af  
2a56 3a 6a 2a			ld a, (.dmark)  
2a59 32 6b ee			ld (debug_mark),a  
2a5c 3a 6b 2a			ld a, (.dmark+1)  
2a5f 32 6c ee			ld (debug_mark+1),a  
2a62 3a 6c 2a			ld a, (.dmark+2)  
2a65 32 6d ee			ld (debug_mark+2),a  
2a68 18 03			jr .pastdmark  
2a6a ..			.dmark: db "LSn"  
2a6d f1			.pastdmark: pop af  
2a6e			endm  
# End of macro DMARK
2a6e					CALLMONITOR 
2a6e cd 6f ee			call debug_vector  
2a71				endm  
# End of macro CALLMONITOR
2a71				endif 
2a71			 
2a71					; copy uword name to scratch 
2a71			 
2a71 ed b0				ldir 
2a73			 
2a73 1b					dec de 
2a74 3e 20				ld a, ' '    ; change null to space 
2a76 12					ld (de), a 
2a77			 
2a77 13					inc de 
2a78			 
2a78 d5					push de 
2a79 c1					pop bc     ; move scratch pointer to end of word name and save it 
2a7a			 
2a7a e1					pop hl 
2a7b 7e					ld a, (hl) 
2a7c					;inc hl 
2a7c					; skip word string 
2a7c cd e6 0d				call addatohl 
2a7f			 
2a7f 23					inc hl 
2a80			 
2a80				if DEBUG_FORTH_WORDS 
2a80					DMARK "LS3" 
2a80 f5				push af  
2a81 3a 95 2a			ld a, (.dmark)  
2a84 32 6b ee			ld (debug_mark),a  
2a87 3a 96 2a			ld a, (.dmark+1)  
2a8a 32 6c ee			ld (debug_mark+1),a  
2a8d 3a 97 2a			ld a, (.dmark+2)  
2a90 32 6d ee			ld (debug_mark+2),a  
2a93 18 03			jr .pastdmark  
2a95 ..			.dmark: db "LS3"  
2a98 f1			.pastdmark: pop af  
2a99			endm  
# End of macro DMARK
2a99					CALLMONITOR 
2a99 cd 6f ee			call debug_vector  
2a9c				endm  
# End of macro CALLMONITOR
2a9c				endif 
2a9c					; should now be at the start of the machine code to setup the eval of the uword 
2a9c					; now locate the ptr to the string defintion 
2a9c			 
2a9c					; skip ld hl, 
2a9c					; then load the ptr 
2a9c			; TODO use get from hl ptr 
2a9c 23					inc hl 
2a9d 5e					ld e, (hl) 
2a9e 23					inc hl 
2a9f 56					ld d, (hl) 
2aa0 eb					ex de, hl 
2aa1			 
2aa1			 
2aa1				if DEBUG_FORTH_WORDS 
2aa1					DMARK "LSt" 
2aa1 f5				push af  
2aa2 3a b6 2a			ld a, (.dmark)  
2aa5 32 6b ee			ld (debug_mark),a  
2aa8 3a b7 2a			ld a, (.dmark+1)  
2aab 32 6c ee			ld (debug_mark+1),a  
2aae 3a b8 2a			ld a, (.dmark+2)  
2ab1 32 6d ee			ld (debug_mark+2),a  
2ab4 18 03			jr .pastdmark  
2ab6 ..			.dmark: db "LSt"  
2ab9 f1			.pastdmark: pop af  
2aba			endm  
# End of macro DMARK
2aba					CALLMONITOR 
2aba cd 6f ee			call debug_vector  
2abd				endm  
# End of macro CALLMONITOR
2abd				endif 
2abd			 
2abd			; cant push right now due to tokenised strings  
2abd			 
2abd			; get the destination of where to copy this definition to. 
2abd			 
2abd c5					push bc 
2abe d1					pop de 
2abf			 
2abf 7e			.listl:         ld a,(hl) 
2ac0 fe 00				cp 0 
2ac2 28 09				jr z, .lreplsp     ; replace zero with space 
2ac4					;cp FORTH_END_BUFFER 
2ac4 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2ac6 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2ac8				 
2ac8					; just copy this char as is then 
2ac8			 
2ac8 12					ld (de), a 
2ac9			 
2ac9 23			.listnxt:	inc hl 
2aca 13					inc de 
2acb 18 f2				jr .listl 
2acd			 
2acd 3e 20		.lreplsp:	ld a,' ' 
2acf 12					ld (de), a 
2ad0 18 f7				jr .listnxt 
2ad2			 
2ad2			; close up uword def 
2ad2			 
2ad2			.listdone: 
2ad2 12					ld (de), a 
2ad3 13					inc de 
2ad4 3e 00				ld a, 0 
2ad6 12					ld (de), a 
2ad7			 
2ad7			; now have def so clean up and push to stack 
2ad7			 
2ad7 21 c1 e2				ld hl, scratch 
2ada				if DEBUG_FORTH_WORDS 
2ada					DMARK "Ltp" 
2ada f5				push af  
2adb 3a ef 2a			ld a, (.dmark)  
2ade 32 6b ee			ld (debug_mark),a  
2ae1 3a f0 2a			ld a, (.dmark+1)  
2ae4 32 6c ee			ld (debug_mark+1),a  
2ae7 3a f1 2a			ld a, (.dmark+2)  
2aea 32 6d ee			ld (debug_mark+2),a  
2aed 18 03			jr .pastdmark  
2aef ..			.dmark: db "Ltp"  
2af2 f1			.pastdmark: pop af  
2af3			endm  
# End of macro DMARK
2af3					CALLMONITOR 
2af3 cd 6f ee			call debug_vector  
2af6				endm  
# End of macro CALLMONITOR
2af6				endif 
2af6			 
2af6 18 1f			jr .listpush 
2af8			 
2af8			;.lnuword:	pop hl 
2af8			;		call forth_tok_next 
2af8			;		jp .ldouscan  
2af8			 
2af8			.lunotfound:		  
2af8			 
2af8				if DEBUG_FORTH_WORDS 
2af8					DMARK "LSn" 
2af8 f5				push af  
2af9 3a 0d 2b			ld a, (.dmark)  
2afc 32 6b ee			ld (debug_mark),a  
2aff 3a 0e 2b			ld a, (.dmark+1)  
2b02 32 6c ee			ld (debug_mark+1),a  
2b05 3a 0f 2b			ld a, (.dmark+2)  
2b08 32 6d ee			ld (debug_mark+2),a  
2b0b 18 03			jr .pastdmark  
2b0d ..			.dmark: db "LSn"  
2b10 f1			.pastdmark: pop af  
2b11			endm  
# End of macro DMARK
2b11					CALLMONITOR 
2b11 cd 6f ee			call debug_vector  
2b14				endm  
# End of macro CALLMONITOR
2b14				endif 
2b14			 
2b14					 
2b14			;		FORTH_DSP_POP 
2b14			;		ld hl, .luno 
2b14			 
2b14					NEXTW			 
2b14 c3 ff 1f			jp macro_next 
2b17				endm 
# End of macro NEXTW
2b17			 
2b17			.listpush: 
2b17				if DEBUG_FORTH_WORDS 
2b17					DMARK "LS>" 
2b17 f5				push af  
2b18 3a 2c 2b			ld a, (.dmark)  
2b1b 32 6b ee			ld (debug_mark),a  
2b1e 3a 2d 2b			ld a, (.dmark+1)  
2b21 32 6c ee			ld (debug_mark+1),a  
2b24 3a 2e 2b			ld a, (.dmark+2)  
2b27 32 6d ee			ld (debug_mark+2),a  
2b2a 18 03			jr .pastdmark  
2b2c ..			.dmark: db "LS>"  
2b2f f1			.pastdmark: pop af  
2b30			endm  
# End of macro DMARK
2b30					CALLMONITOR 
2b30 cd 6f ee			call debug_vector  
2b33				endm  
# End of macro CALLMONITOR
2b33				endif 
2b33 cd c0 1c				call forth_push_str 
2b36			 
2b36			 
2b36			 
2b36					NEXTW 
2b36 c3 ff 1f			jp macro_next 
2b39				endm 
# End of macro NEXTW
2b39			 
2b39			;.luno:    db "Word not found",0 
2b39			 
2b39			 
2b39			 
2b39			 
2b39			 
2b39			;		push hl   ; save pointer to start of uword def string 
2b39			; 
2b39			;; look for FORTH_EOL_LINE 
2b39			;		ld a, FORTH_END_BUFFER 
2b39			;		call strlent 
2b39			; 
2b39			;		inc hl		 ; space for coln def 
2b39			;		inc hl 
2b39			;		inc hl          ; space for terms 
2b39			;		inc hl 
2b39			; 
2b39			;		ld a, 20   ; TODO get actual length 
2b39			;		call addatohl    ; include a random amount of room for the uword name 
2b39			; 
2b39			;		 
2b39			;	if DEBUG_FORTH_WORDS 
2b39			;		DMARK "Lt1" 
2b39			;		CALLMONITOR 
2b39			;	endif 
2b39			;		 
2b39			; 
2b39			;; malloc space for the string because we cant change it 
2b39			; 
2b39			;		call malloc 
2b39			;	if DEBUG_FORTH_MALLOC_GUARD 
2b39			;		push af 
2b39			;		call ishlzero 
2b39			;		pop af 
2b39			;		 
2b39			;		call z,malloc_error 
2b39			;	endif 
2b39			; 
2b39			;	if DEBUG_FORTH_WORDS 
2b39			;		DMARK "Lt2" 
2b39			;		CALLMONITOR 
2b39			;	endif 
2b39			;		pop de 
2b39			;		push hl    ; push the malloc to release later 
2b39			;		push hl   ;  push back a copy for the later stack push 
2b39			;		 
2b39			;; copy the string swapping out the zero terms for spaces 
2b39			; 
2b39			;		; de has our source 
2b39			;		; hl has our dest 
2b39			; 
2b39			;; add the coln def 
2b39			; 
2b39			;		ld a, ':' 
2b39			;		ld (hl), a 
2b39			;		inc hl 
2b39			;		ld a, ' ' 
2b39			;		ld (hl), a 
2b39			;		inc hl 
2b39			; 
2b39			;; add the uname word 
2b39			;		push de   ; save our string for now 
2b39			;		ex de, hl 
2b39			; 
2b39			;		FORTH_DSP_VALUE 
2b39			;		;v5 FORTH_DSP_VALUE 
2b39			; 
2b39			;		inc hl   ; skip type but we know by now this is OK 
2b39			; 
2b39			;.luword:	ld a,(hl) 
2b39			;		cp 0 
2b39			;		jr z, .luword2 
2b39			;		ld (de), a 
2b39			;		inc de 
2b39			;		inc hl 
2b39			;		jr .luword 
2b39			; 
2b39			;.luword2:	ld a, ' ' 
2b39			;		ld (de), a 
2b39			;;		inc hl 
2b39			;;		inc de 
2b39			;;		ld (de), a 
2b39			;;		inc hl 
2b39			;		inc de 
2b39			; 
2b39			;		ex de, hl 
2b39			;		pop de 
2b39			;		 
2b39			;		 
2b39			; 
2b39			;; detoken that string and copy it 
2b39			; 
2b39			;	if DEBUG_FORTH_WORDS 
2b39			;		DMARK "Lt2" 
2b39			;		CALLMONITOR 
2b39			;	endif 
2b39			;.ldetok:	ld a, (de) 
2b39			;		cp FORTH_END_BUFFER 
2b39			;		jr z, .ldetokend 
2b39			;		; swap out any zero term for space 
2b39			;		cp 0 
2b39			;		jr nz, .ldetoknext 
2b39			;		ld a, ' ' 
2b39			; 
2b39			;	if DEBUG_FORTH_WORDS 
2b39			;		DMARK "LtS" 
2b39			;		CALLMONITOR 
2b39			;	endif 
2b39			;.ldetoknext:	ld (hl), a 
2b39			;		inc de 
2b39			;		inc hl 
2b39			;		jr .ldetok 
2b39			; 
2b39			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b39			;		ld (hl), a  
2b39			; 
2b39			;; free that temp malloc 
2b39			; 
2b39			;		pop hl    
2b39			; 
2b39			;	if DEBUG_FORTH_WORDS 
2b39			;		DMARK "Lt4" 
2b39			;		CALLMONITOR 
2b39			;	endif 
2b39			;		call forth_apushstrhl 
2b39			; 
2b39			;		; get rid of temp malloc area 
2b39			; 
2b39			;		pop hl 
2b39			;		call free 
2b39			; 
2b39			;		jr .ludone 
2b39			; 
2b39			;.lnuword:	pop hl 
2b39			;		call forth_tok_next 
2b39			;		jp .ldouscan  
2b39			; 
2b39			;.ludone:		 pop hl 
2b39			; 
2b39					NEXTW 
2b39 c3 ff 1f			jp macro_next 
2b3c				endm 
# End of macro NEXTW
2b3c			 
2b3c			.FORGET: 
2b3c				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b3c 5d				db WORD_SYS_CORE+73             
2b3d b5 2b			dw .NOP            
2b3f 07				db 6 + 1 
2b40 .. 00			db "FORGET",0              
2b47				endm 
# End of macro CWHEAD
2b47			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b47			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2b47			; | |  
2b47			; | | e.g. "MORE" forget 
2b47					if DEBUG_FORTH_WORDS_KEY 
2b47						DMARK "FRG" 
2b47 f5				push af  
2b48 3a 5c 2b			ld a, (.dmark)  
2b4b 32 6b ee			ld (debug_mark),a  
2b4e 3a 5d 2b			ld a, (.dmark+1)  
2b51 32 6c ee			ld (debug_mark+1),a  
2b54 3a 5e 2b			ld a, (.dmark+2)  
2b57 32 6d ee			ld (debug_mark+2),a  
2b5a 18 03			jr .pastdmark  
2b5c ..			.dmark: db "FRG"  
2b5f f1			.pastdmark: pop af  
2b60			endm  
# End of macro DMARK
2b60						CALLMONITOR 
2b60 cd 6f ee			call debug_vector  
2b63				endm  
# End of macro CALLMONITOR
2b63					endif 
2b63			 
2b63				; find uword 
2b63			        ; update start of word with "_" 
2b63				; replace uword with deleted flag 
2b63			 
2b63			 
2b63			;	if DEBUG_FORTH_WORDS 
2b63			;		DMARK "FOG" 
2b63			;		CALLMONITOR 
2b63			;	endif 
2b63			 
2b63			 
2b63					; Get ptr to the word we need to look up 
2b63			 
2b63					FORTH_DSP_VALUEHL 
2b63 cd 49 1e			call macro_dsp_valuehl 
2b66				endm 
# End of macro FORTH_DSP_VALUEHL
2b66					;v5 FORTH_DSP_VALUE 
2b66				; TODO type check 
2b66			;		inc hl    ; Skip type check  
2b66 e5					push hl 
2b67 c1					pop bc 
2b68			;		ex de, hl    ; put into DE 
2b68			 
2b68			 
2b68 21 47 66				ld hl, baseram 
2b6b					;ld hl, baseusermem 
2b6b			 
2b6b				; skip dict stub 
2b6b			;	call forth_tok_next 
2b6b e5			push hl   ; sacreifical push 
2b6c			 
2b6c			.fldouscanm: 
2b6c e1				pop hl 
2b6d			.fldouscan: 
2b6d			;	if DEBUG_FORTH_WORDS 
2b6d			;		DMARK "LSs" 
2b6d			;		CALLMONITOR 
2b6d			;	endif 
2b6d				; skip dict stub 
2b6d cd 50 21				call forth_tok_next 
2b70			 
2b70			 
2b70			; while we have words to look for 
2b70			 
2b70 7e				ld a, (hl)      
2b71			;	if DEBUG_FORTH_WORDS 
2b71			;		DMARK "LSk" 
2b71			;		CALLMONITOR 
2b71			;	endif 
2b71 fe 00				cp WORD_SYS_END 
2b73 ca af 2b				jp z, .flunotfound 
2b76 fe 01				cp WORD_SYS_UWORD 
2b78 c2 6d 2b				jp nz, .fldouscan 
2b7b			 
2b7b			;	if DEBUG_FORTH_WORDS 
2b7b			;		DMARK "LSu" 
2b7b			;		CALLMONITOR 
2b7b			;	endif 
2b7b			 
2b7b					; found a uword but is it the one we want... 
2b7b			 
2b7b c5					push bc     ; uword to find is on bc 
2b7c d1					pop de 
2b7d			 
2b7d e5					push hl  ; to save the ptr 
2b7e			 
2b7e					; skip opcode 
2b7e 23					inc hl  
2b7f					; skip next ptr 
2b7f 23					inc hl  
2b80 23					inc hl 
2b81					; skip len 
2b81 23					inc hl 
2b82			 
2b82			;	if DEBUG_FORTH_WORDS 
2b82			;		DMARK "LSc" 
2b82			;		CALLMONITOR 
2b82			;	endif 
2b82 cd 7c 12				call strcmp 
2b85 c2 6c 2b				jp nz, .fldouscanm 
2b88			; 
2b88			; 
2b88			;; while we have words to look for 
2b88			; 
2b88			;.fdouscan:	ld a, (hl)      
2b88			;	if DEBUG_FORTH_WORDS 
2b88			;		DMARK "LSs" 
2b88			;		CALLMONITOR 
2b88			;	endif 
2b88			;		cp WORD_SYS_END 
2b88			;		jp z, .fudone 
2b88			;		cp WORD_SYS_UWORD 
2b88			;		jp nz, .fnuword 
2b88			; 
2b88			;	if DEBUG_FORTH_WORDS 
2b88			;		DMARK "FGu" 
2b88			;		CALLMONITOR 
2b88			;	endif 
2b88			; 
2b88			;		; found a uword but is it the one we want... 
2b88			; 
2b88			; 
2b88			;	        pop de   ; get back the dsp name 
2b88			;		push de 
2b88			; 
2b88			;		push hl  ; to save the ptr 
2b88			; 
2b88			;		; skip opcode 
2b88			;		inc hl  
2b88			;		; skip next ptr 
2b88			;		inc hl  
2b88			;		inc hl 
2b88			;		; skip len 
2b88			;		inc hl 
2b88			; 
2b88			;	if DEBUG_FORTH_WORDS 
2b88			;		DMARK "FGc" 
2b88			;		CALLMONITOR 
2b88			;	endif 
2b88			;		call strcmp 
2b88			;		jp nz, .fnuword 
2b88			 
2b88			 
2b88 e1			pop hl 
2b89			 
2b89				 
2b89				if DEBUG_FORTH_WORDS 
2b89					DMARK "FGm" 
2b89 f5				push af  
2b8a 3a 9e 2b			ld a, (.dmark)  
2b8d 32 6b ee			ld (debug_mark),a  
2b90 3a 9f 2b			ld a, (.dmark+1)  
2b93 32 6c ee			ld (debug_mark+1),a  
2b96 3a a0 2b			ld a, (.dmark+2)  
2b99 32 6d ee			ld (debug_mark+2),a  
2b9c 18 03			jr .pastdmark  
2b9e ..			.dmark: db "FGm"  
2ba1 f1			.pastdmark: pop af  
2ba2			endm  
# End of macro DMARK
2ba2					CALLMONITOR 
2ba2 cd 6f ee			call debug_vector  
2ba5				endm  
# End of macro CALLMONITOR
2ba5				endif 
2ba5			 
2ba5			 
2ba5			 
2ba5					; we have a uword so push its name to the stack 
2ba5			 
2ba5			;	   	push hl  ; save so we can move to next dict block 
2ba5			;pop hl 
2ba5			 
2ba5					; update opcode to deleted 
2ba5 3e 03				ld a, WORD_SYS_DELETED 
2ba7 77					ld (hl), a 
2ba8			 
2ba8 23					inc hl  
2ba9					; skip next ptr 
2ba9 23					inc hl  
2baa 23					inc hl 
2bab					; skip len 
2bab 23					inc hl 
2bac			 
2bac					; TODO change parser to skip deleted words but for now mark it out 
2bac 3e 5f				ld a, "_" 
2bae 77					ld  (hl),a 
2baf			 
2baf			;		jr .fudone 
2baf			; 
2baf			;.fnuword:	pop hl 
2baf			;		call forth_tok_next 
2baf			;		jp .fdouscan  
2baf			 
2baf			.flunotfound:		  
2baf			 
2baf			 
2baf					 
2baf					FORTH_DSP_POP 
2baf cd 01 1f			call macro_forth_dsp_pop 
2bb2				endm 
# End of macro FORTH_DSP_POP
2bb2			;		ld hl, .luno 
2bb2			;.fudone:		 pop hl 
2bb2					NEXTW 
2bb2 c3 ff 1f			jp macro_next 
2bb5				endm 
# End of macro NEXTW
2bb5			.NOP: 
2bb5				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2bb5 61				db WORD_SYS_CORE+77             
2bb6 dc 2b			dw .COMO            
2bb8 04				db 3 + 1 
2bb9 .. 00			db "NOP",0              
2bbd				endm 
# End of macro CWHEAD
2bbd			; | NOP (  --  ) Do nothing | DONE 
2bbd					if DEBUG_FORTH_WORDS_KEY 
2bbd						DMARK "NOP" 
2bbd f5				push af  
2bbe 3a d2 2b			ld a, (.dmark)  
2bc1 32 6b ee			ld (debug_mark),a  
2bc4 3a d3 2b			ld a, (.dmark+1)  
2bc7 32 6c ee			ld (debug_mark+1),a  
2bca 3a d4 2b			ld a, (.dmark+2)  
2bcd 32 6d ee			ld (debug_mark+2),a  
2bd0 18 03			jr .pastdmark  
2bd2 ..			.dmark: db "NOP"  
2bd5 f1			.pastdmark: pop af  
2bd6			endm  
# End of macro DMARK
2bd6						CALLMONITOR 
2bd6 cd 6f ee			call debug_vector  
2bd9				endm  
# End of macro CALLMONITOR
2bd9					endif 
2bd9				       NEXTW 
2bd9 c3 ff 1f			jp macro_next 
2bdc				endm 
# End of macro NEXTW
2bdc			.COMO: 
2bdc				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2bdc 6e				db WORD_SYS_CORE+90             
2bdd 2e 2c			dw .COMC            
2bdf 02				db 1 + 1 
2be0 .. 00			db "(",0              
2be2				endm 
# End of macro CWHEAD
2be2			; | ( ( -- )  Start of comment | DONE 
2be2			 
2be2			 
2be2 2a c2 e5				ld hl, ( os_tok_ptr) 
2be5 11 29 2c			ld de, .closepar 
2be8					 
2be8					if DEBUG_FORTH_WORDS 
2be8						DMARK ").." 
2be8 f5				push af  
2be9 3a fd 2b			ld a, (.dmark)  
2bec 32 6b ee			ld (debug_mark),a  
2bef 3a fe 2b			ld a, (.dmark+1)  
2bf2 32 6c ee			ld (debug_mark+1),a  
2bf5 3a ff 2b			ld a, (.dmark+2)  
2bf8 32 6d ee			ld (debug_mark+2),a  
2bfb 18 03			jr .pastdmark  
2bfd ..			.dmark: db ").."  
2c00 f1			.pastdmark: pop af  
2c01			endm  
# End of macro DMARK
2c01						CALLMONITOR 
2c01 cd 6f ee			call debug_vector  
2c04				endm  
# End of macro CALLMONITOR
2c04					endif 
2c04 cd 1a 21			call findnexttok  
2c07			 
2c07					if DEBUG_FORTH_WORDS 
2c07						DMARK "IF5" 
2c07 f5				push af  
2c08 3a 1c 2c			ld a, (.dmark)  
2c0b 32 6b ee			ld (debug_mark),a  
2c0e 3a 1d 2c			ld a, (.dmark+1)  
2c11 32 6c ee			ld (debug_mark+1),a  
2c14 3a 1e 2c			ld a, (.dmark+2)  
2c17 32 6d ee			ld (debug_mark+2),a  
2c1a 18 03			jr .pastdmark  
2c1c ..			.dmark: db "IF5"  
2c1f f1			.pastdmark: pop af  
2c20			endm  
# End of macro DMARK
2c20						CALLMONITOR 
2c20 cd 6f ee			call debug_vector  
2c23				endm  
# End of macro CALLMONITOR
2c23					endif 
2c23				; replace below with ) exec using tok_ptr 
2c23 22 c2 e5			ld (os_tok_ptr), hl 
2c26 c3 90 20			jp exec1 
2c29			 
2c29 .. 00			.closepar:   db ")",0 
2c2b			 
2c2b				       NEXTW 
2c2b c3 ff 1f			jp macro_next 
2c2e				endm 
# End of macro NEXTW
2c2e			.COMC: 
2c2e				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c2e 6f				db WORD_SYS_CORE+91             
2c2f 37 2c			dw .SCRATCH            
2c31 02				db 1 + 1 
2c32 .. 00			db ")",0              
2c34				endm 
# End of macro CWHEAD
2c34			; | ) ( -- )  End of comment |  DONE  
2c34				       NEXTW 
2c34 c3 ff 1f			jp macro_next 
2c37				endm 
# End of macro NEXTW
2c37			 
2c37			.SCRATCH: 
2c37				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c37 6f				db WORD_SYS_CORE+91             
2c38 72 2c			dw .INC            
2c3a 08				db 7 + 1 
2c3b .. 00			db "SCRATCH",0              
2c43				endm 
# End of macro CWHEAD
2c43			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c43			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c43			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c43			; | |  
2c43			; | | e.g.    : score $00 scratch ; 
2c43			; | |  
2c43			; | | $00 score ! 
2c43			; | | $01 score +! 
2c43			; | |  
2c43			; | | e.g.   : varword $0a scratch ;  
2c43			; | | 
2c43			; | | $8000 varword ! 
2c43					if DEBUG_FORTH_WORDS_KEY 
2c43						DMARK "SCR" 
2c43 f5				push af  
2c44 3a 58 2c			ld a, (.dmark)  
2c47 32 6b ee			ld (debug_mark),a  
2c4a 3a 59 2c			ld a, (.dmark+1)  
2c4d 32 6c ee			ld (debug_mark+1),a  
2c50 3a 5a 2c			ld a, (.dmark+2)  
2c53 32 6d ee			ld (debug_mark+2),a  
2c56 18 03			jr .pastdmark  
2c58 ..			.dmark: db "SCR"  
2c5b f1			.pastdmark: pop af  
2c5c			endm  
# End of macro DMARK
2c5c						CALLMONITOR 
2c5c cd 6f ee			call debug_vector  
2c5f				endm  
# End of macro CALLMONITOR
2c5f					endif 
2c5f			 
2c5f					FORTH_DSP_VALUEHL 
2c5f cd 49 1e			call macro_dsp_valuehl 
2c62				endm 
# End of macro FORTH_DSP_VALUEHL
2c62				 
2c62					FORTH_DSP_POP 
2c62 cd 01 1f			call macro_forth_dsp_pop 
2c65				endm 
# End of macro FORTH_DSP_POP
2c65			 
2c65 7d					ld a, l 
2c66 21 e6 e7				ld hl, os_var_array 
2c69 cd e6 0d				call addatohl 
2c6c			 
2c6c cd 52 1c				call forth_push_numhl 
2c6f			 
2c6f				       NEXTW 
2c6f c3 ff 1f			jp macro_next 
2c72				endm 
# End of macro NEXTW
2c72			 
2c72			.INC: 
2c72				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c72 6f				db WORD_SYS_CORE+91             
2c73 c8 2c			dw .DEC            
2c75 03				db 2 + 1 
2c76 .. 00			db "+!",0              
2c79				endm 
# End of macro CWHEAD
2c79			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c79					if DEBUG_FORTH_WORDS_KEY 
2c79						DMARK "+s_" 
2c79 f5				push af  
2c7a 3a 8e 2c			ld a, (.dmark)  
2c7d 32 6b ee			ld (debug_mark),a  
2c80 3a 8f 2c			ld a, (.dmark+1)  
2c83 32 6c ee			ld (debug_mark+1),a  
2c86 3a 90 2c			ld a, (.dmark+2)  
2c89 32 6d ee			ld (debug_mark+2),a  
2c8c 18 03			jr .pastdmark  
2c8e ..			.dmark: db "+s_"  
2c91 f1			.pastdmark: pop af  
2c92			endm  
# End of macro DMARK
2c92						CALLMONITOR 
2c92 cd 6f ee			call debug_vector  
2c95				endm  
# End of macro CALLMONITOR
2c95					endif 
2c95			 
2c95					FORTH_DSP_VALUEHL 
2c95 cd 49 1e			call macro_dsp_valuehl 
2c98				endm 
# End of macro FORTH_DSP_VALUEHL
2c98			 
2c98 e5					push hl   ; save address 
2c99			 
2c99					FORTH_DSP_POP 
2c99 cd 01 1f			call macro_forth_dsp_pop 
2c9c				endm 
# End of macro FORTH_DSP_POP
2c9c			 
2c9c					FORTH_DSP_VALUEHL 
2c9c cd 49 1e			call macro_dsp_valuehl 
2c9f				endm 
# End of macro FORTH_DSP_VALUEHL
2c9f			 
2c9f e5					push hl 
2ca0					FORTH_DSP_POP 
2ca0 cd 01 1f			call macro_forth_dsp_pop 
2ca3				endm 
# End of macro FORTH_DSP_POP
2ca3 e1					pop hl 
2ca4			 
2ca4					; hl contains value to add to byte at a 
2ca4				 
2ca4 eb					ex de, hl 
2ca5			 
2ca5 e1					pop hl 
2ca6			 
2ca6					if DEBUG_FORTH_WORDS 
2ca6						DMARK "INC" 
2ca6 f5				push af  
2ca7 3a bb 2c			ld a, (.dmark)  
2caa 32 6b ee			ld (debug_mark),a  
2cad 3a bc 2c			ld a, (.dmark+1)  
2cb0 32 6c ee			ld (debug_mark+1),a  
2cb3 3a bd 2c			ld a, (.dmark+2)  
2cb6 32 6d ee			ld (debug_mark+2),a  
2cb9 18 03			jr .pastdmark  
2cbb ..			.dmark: db "INC"  
2cbe f1			.pastdmark: pop af  
2cbf			endm  
# End of macro DMARK
2cbf						CALLMONITOR 
2cbf cd 6f ee			call debug_vector  
2cc2				endm  
# End of macro CALLMONITOR
2cc2					endif 
2cc2			 
2cc2 7e					ld a,(hl) 
2cc3 83					add e 
2cc4 77					ld (hl),a 
2cc5			 
2cc5			 
2cc5			 
2cc5				       NEXTW 
2cc5 c3 ff 1f			jp macro_next 
2cc8				endm 
# End of macro NEXTW
2cc8			 
2cc8			.DEC: 
2cc8				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2cc8 6f				db WORD_SYS_CORE+91             
2cc9 1c 2d			dw .INC2            
2ccb 03				db 2 + 1 
2ccc .. 00			db "-!",0              
2ccf				endm 
# End of macro CWHEAD
2ccf			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2ccf					if DEBUG_FORTH_WORDS_KEY 
2ccf						DMARK "-s_" 
2ccf f5				push af  
2cd0 3a e4 2c			ld a, (.dmark)  
2cd3 32 6b ee			ld (debug_mark),a  
2cd6 3a e5 2c			ld a, (.dmark+1)  
2cd9 32 6c ee			ld (debug_mark+1),a  
2cdc 3a e6 2c			ld a, (.dmark+2)  
2cdf 32 6d ee			ld (debug_mark+2),a  
2ce2 18 03			jr .pastdmark  
2ce4 ..			.dmark: db "-s_"  
2ce7 f1			.pastdmark: pop af  
2ce8			endm  
# End of macro DMARK
2ce8						CALLMONITOR 
2ce8 cd 6f ee			call debug_vector  
2ceb				endm  
# End of macro CALLMONITOR
2ceb					endif 
2ceb			 
2ceb					FORTH_DSP_VALUEHL 
2ceb cd 49 1e			call macro_dsp_valuehl 
2cee				endm 
# End of macro FORTH_DSP_VALUEHL
2cee			 
2cee e5					push hl   ; save address 
2cef			 
2cef					FORTH_DSP_POP 
2cef cd 01 1f			call macro_forth_dsp_pop 
2cf2				endm 
# End of macro FORTH_DSP_POP
2cf2			 
2cf2					FORTH_DSP_VALUEHL 
2cf2 cd 49 1e			call macro_dsp_valuehl 
2cf5				endm 
# End of macro FORTH_DSP_VALUEHL
2cf5			 
2cf5					; hl contains value to add to byte at a 
2cf5				 
2cf5 eb					ex de, hl 
2cf6			 
2cf6 e1					pop hl 
2cf7			 
2cf7					if DEBUG_FORTH_WORDS 
2cf7						DMARK "DEC" 
2cf7 f5				push af  
2cf8 3a 0c 2d			ld a, (.dmark)  
2cfb 32 6b ee			ld (debug_mark),a  
2cfe 3a 0d 2d			ld a, (.dmark+1)  
2d01 32 6c ee			ld (debug_mark+1),a  
2d04 3a 0e 2d			ld a, (.dmark+2)  
2d07 32 6d ee			ld (debug_mark+2),a  
2d0a 18 03			jr .pastdmark  
2d0c ..			.dmark: db "DEC"  
2d0f f1			.pastdmark: pop af  
2d10			endm  
# End of macro DMARK
2d10						CALLMONITOR 
2d10 cd 6f ee			call debug_vector  
2d13				endm  
# End of macro CALLMONITOR
2d13					endif 
2d13			 
2d13 7e					ld a,(hl) 
2d14 93					sub e 
2d15 77					ld (hl),a 
2d16			 
2d16			 
2d16					FORTH_DSP_POP 
2d16 cd 01 1f			call macro_forth_dsp_pop 
2d19				endm 
# End of macro FORTH_DSP_POP
2d19			 
2d19				       NEXTW 
2d19 c3 ff 1f			jp macro_next 
2d1c				endm 
# End of macro NEXTW
2d1c			 
2d1c			.INC2: 
2d1c				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d1c 6f				db WORD_SYS_CORE+91             
2d1d c9 2d			dw .DEC2            
2d1f 04				db 3 + 1 
2d20 .. 00			db "+2!",0              
2d24				endm 
# End of macro CWHEAD
2d24			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d24			 
2d24					if DEBUG_FORTH_WORDS_KEY 
2d24						DMARK "+2s" 
2d24 f5				push af  
2d25 3a 39 2d			ld a, (.dmark)  
2d28 32 6b ee			ld (debug_mark),a  
2d2b 3a 3a 2d			ld a, (.dmark+1)  
2d2e 32 6c ee			ld (debug_mark+1),a  
2d31 3a 3b 2d			ld a, (.dmark+2)  
2d34 32 6d ee			ld (debug_mark+2),a  
2d37 18 03			jr .pastdmark  
2d39 ..			.dmark: db "+2s"  
2d3c f1			.pastdmark: pop af  
2d3d			endm  
# End of macro DMARK
2d3d						CALLMONITOR 
2d3d cd 6f ee			call debug_vector  
2d40				endm  
# End of macro CALLMONITOR
2d40					endif 
2d40			 
2d40					; Address 
2d40			 
2d40					FORTH_DSP_VALUEHL 
2d40 cd 49 1e			call macro_dsp_valuehl 
2d43				endm 
# End of macro FORTH_DSP_VALUEHL
2d43			 
2d43 e5					push hl    ; save address 
2d44			 
2d44					; load content into de 
2d44			 
2d44 5e					ld e,(hl) 
2d45 23					inc hl 
2d46 56					ld d, (hl) 
2d47			 
2d47					if DEBUG_FORTH_WORDS 
2d47						DMARK "+2a" 
2d47 f5				push af  
2d48 3a 5c 2d			ld a, (.dmark)  
2d4b 32 6b ee			ld (debug_mark),a  
2d4e 3a 5d 2d			ld a, (.dmark+1)  
2d51 32 6c ee			ld (debug_mark+1),a  
2d54 3a 5e 2d			ld a, (.dmark+2)  
2d57 32 6d ee			ld (debug_mark+2),a  
2d5a 18 03			jr .pastdmark  
2d5c ..			.dmark: db "+2a"  
2d5f f1			.pastdmark: pop af  
2d60			endm  
# End of macro DMARK
2d60						CALLMONITOR 
2d60 cd 6f ee			call debug_vector  
2d63				endm  
# End of macro CALLMONITOR
2d63					endif 
2d63			 
2d63					FORTH_DSP_POP 
2d63 cd 01 1f			call macro_forth_dsp_pop 
2d66				endm 
# End of macro FORTH_DSP_POP
2d66			 
2d66					; Get value to add 
2d66			 
2d66					FORTH_DSP_VALUE 
2d66 cd 32 1e			call macro_forth_dsp_value 
2d69				endm 
# End of macro FORTH_DSP_VALUE
2d69			 
2d69					if DEBUG_FORTH_WORDS 
2d69						DMARK "+2v" 
2d69 f5				push af  
2d6a 3a 7e 2d			ld a, (.dmark)  
2d6d 32 6b ee			ld (debug_mark),a  
2d70 3a 7f 2d			ld a, (.dmark+1)  
2d73 32 6c ee			ld (debug_mark+1),a  
2d76 3a 80 2d			ld a, (.dmark+2)  
2d79 32 6d ee			ld (debug_mark+2),a  
2d7c 18 03			jr .pastdmark  
2d7e ..			.dmark: db "+2v"  
2d81 f1			.pastdmark: pop af  
2d82			endm  
# End of macro DMARK
2d82						CALLMONITOR 
2d82 cd 6f ee			call debug_vector  
2d85				endm  
# End of macro CALLMONITOR
2d85					endif 
2d85			 
2d85 19					add hl, de 
2d86			 
2d86					if DEBUG_FORTH_WORDS 
2d86						DMARK "+2+" 
2d86 f5				push af  
2d87 3a 9b 2d			ld a, (.dmark)  
2d8a 32 6b ee			ld (debug_mark),a  
2d8d 3a 9c 2d			ld a, (.dmark+1)  
2d90 32 6c ee			ld (debug_mark+1),a  
2d93 3a 9d 2d			ld a, (.dmark+2)  
2d96 32 6d ee			ld (debug_mark+2),a  
2d99 18 03			jr .pastdmark  
2d9b ..			.dmark: db "+2+"  
2d9e f1			.pastdmark: pop af  
2d9f			endm  
# End of macro DMARK
2d9f						CALLMONITOR 
2d9f cd 6f ee			call debug_vector  
2da2				endm  
# End of macro CALLMONITOR
2da2					endif 
2da2			 
2da2					; move result to de 
2da2			 
2da2 eb					ex de, hl 
2da3			 
2da3					; Address 
2da3			 
2da3 e1					pop hl 
2da4			 
2da4					; save it back 
2da4			 
2da4 73					ld (hl), e 
2da5 23					inc hl 
2da6 72					ld (hl), d 
2da7			 
2da7					if DEBUG_FORTH_WORDS 
2da7						DMARK "+2e" 
2da7 f5				push af  
2da8 3a bc 2d			ld a, (.dmark)  
2dab 32 6b ee			ld (debug_mark),a  
2dae 3a bd 2d			ld a, (.dmark+1)  
2db1 32 6c ee			ld (debug_mark+1),a  
2db4 3a be 2d			ld a, (.dmark+2)  
2db7 32 6d ee			ld (debug_mark+2),a  
2dba 18 03			jr .pastdmark  
2dbc ..			.dmark: db "+2e"  
2dbf f1			.pastdmark: pop af  
2dc0			endm  
# End of macro DMARK
2dc0						CALLMONITOR 
2dc0 cd 6f ee			call debug_vector  
2dc3				endm  
# End of macro CALLMONITOR
2dc3					endif 
2dc3			 
2dc3			 
2dc3			 
2dc3					FORTH_DSP_POP 
2dc3 cd 01 1f			call macro_forth_dsp_pop 
2dc6				endm 
# End of macro FORTH_DSP_POP
2dc6			 
2dc6			 
2dc6				       NEXTW 
2dc6 c3 ff 1f			jp macro_next 
2dc9				endm 
# End of macro NEXTW
2dc9			 
2dc9			.DEC2: 
2dc9				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2dc9 6f				db WORD_SYS_CORE+91             
2dca 78 2e			dw .GET2            
2dcc 04				db 3 + 1 
2dcd .. 00			db "-2!",0              
2dd1				endm 
# End of macro CWHEAD
2dd1			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2dd1			 
2dd1			 
2dd1					if DEBUG_FORTH_WORDS_KEY 
2dd1						DMARK "-2s" 
2dd1 f5				push af  
2dd2 3a e6 2d			ld a, (.dmark)  
2dd5 32 6b ee			ld (debug_mark),a  
2dd8 3a e7 2d			ld a, (.dmark+1)  
2ddb 32 6c ee			ld (debug_mark+1),a  
2dde 3a e8 2d			ld a, (.dmark+2)  
2de1 32 6d ee			ld (debug_mark+2),a  
2de4 18 03			jr .pastdmark  
2de6 ..			.dmark: db "-2s"  
2de9 f1			.pastdmark: pop af  
2dea			endm  
# End of macro DMARK
2dea						CALLMONITOR 
2dea cd 6f ee			call debug_vector  
2ded				endm  
# End of macro CALLMONITOR
2ded					endif 
2ded			 
2ded					; Address 
2ded			 
2ded					FORTH_DSP_VALUEHL 
2ded cd 49 1e			call macro_dsp_valuehl 
2df0				endm 
# End of macro FORTH_DSP_VALUEHL
2df0			 
2df0 e5					push hl    ; save address 
2df1			 
2df1					; load content into de 
2df1			 
2df1 5e					ld e,(hl) 
2df2 23					inc hl 
2df3 56					ld d, (hl) 
2df4			 
2df4					if DEBUG_FORTH_WORDS 
2df4						DMARK "-2a" 
2df4 f5				push af  
2df5 3a 09 2e			ld a, (.dmark)  
2df8 32 6b ee			ld (debug_mark),a  
2dfb 3a 0a 2e			ld a, (.dmark+1)  
2dfe 32 6c ee			ld (debug_mark+1),a  
2e01 3a 0b 2e			ld a, (.dmark+2)  
2e04 32 6d ee			ld (debug_mark+2),a  
2e07 18 03			jr .pastdmark  
2e09 ..			.dmark: db "-2a"  
2e0c f1			.pastdmark: pop af  
2e0d			endm  
# End of macro DMARK
2e0d						CALLMONITOR 
2e0d cd 6f ee			call debug_vector  
2e10				endm  
# End of macro CALLMONITOR
2e10					endif 
2e10			 
2e10					FORTH_DSP_POP 
2e10 cd 01 1f			call macro_forth_dsp_pop 
2e13				endm 
# End of macro FORTH_DSP_POP
2e13			 
2e13					; Get value to remove 
2e13			 
2e13					FORTH_DSP_VALUE 
2e13 cd 32 1e			call macro_forth_dsp_value 
2e16				endm 
# End of macro FORTH_DSP_VALUE
2e16			 
2e16					if DEBUG_FORTH_WORDS 
2e16						DMARK "-2v" 
2e16 f5				push af  
2e17 3a 2b 2e			ld a, (.dmark)  
2e1a 32 6b ee			ld (debug_mark),a  
2e1d 3a 2c 2e			ld a, (.dmark+1)  
2e20 32 6c ee			ld (debug_mark+1),a  
2e23 3a 2d 2e			ld a, (.dmark+2)  
2e26 32 6d ee			ld (debug_mark+2),a  
2e29 18 03			jr .pastdmark  
2e2b ..			.dmark: db "-2v"  
2e2e f1			.pastdmark: pop af  
2e2f			endm  
# End of macro DMARK
2e2f						CALLMONITOR 
2e2f cd 6f ee			call debug_vector  
2e32				endm  
# End of macro CALLMONITOR
2e32					endif 
2e32			 
2e32 eb					ex de, hl 
2e33 ed 52				sbc hl, de 
2e35			 
2e35					if DEBUG_FORTH_WORDS 
2e35						DMARK "-2d" 
2e35 f5				push af  
2e36 3a 4a 2e			ld a, (.dmark)  
2e39 32 6b ee			ld (debug_mark),a  
2e3c 3a 4b 2e			ld a, (.dmark+1)  
2e3f 32 6c ee			ld (debug_mark+1),a  
2e42 3a 4c 2e			ld a, (.dmark+2)  
2e45 32 6d ee			ld (debug_mark+2),a  
2e48 18 03			jr .pastdmark  
2e4a ..			.dmark: db "-2d"  
2e4d f1			.pastdmark: pop af  
2e4e			endm  
# End of macro DMARK
2e4e						CALLMONITOR 
2e4e cd 6f ee			call debug_vector  
2e51				endm  
# End of macro CALLMONITOR
2e51					endif 
2e51			 
2e51					; move result to de 
2e51			 
2e51 eb					ex de, hl 
2e52			 
2e52					; Address 
2e52			 
2e52 e1					pop hl 
2e53			 
2e53					; save it back 
2e53			 
2e53 73					ld (hl), e 
2e54 23					inc hl 
2e55 72					ld (hl), d 
2e56			 
2e56					if DEBUG_FORTH_WORDS 
2e56						DMARK "-2e" 
2e56 f5				push af  
2e57 3a 6b 2e			ld a, (.dmark)  
2e5a 32 6b ee			ld (debug_mark),a  
2e5d 3a 6c 2e			ld a, (.dmark+1)  
2e60 32 6c ee			ld (debug_mark+1),a  
2e63 3a 6d 2e			ld a, (.dmark+2)  
2e66 32 6d ee			ld (debug_mark+2),a  
2e69 18 03			jr .pastdmark  
2e6b ..			.dmark: db "-2e"  
2e6e f1			.pastdmark: pop af  
2e6f			endm  
# End of macro DMARK
2e6f						CALLMONITOR 
2e6f cd 6f ee			call debug_vector  
2e72				endm  
# End of macro CALLMONITOR
2e72					endif 
2e72			 
2e72			 
2e72					FORTH_DSP_POP 
2e72 cd 01 1f			call macro_forth_dsp_pop 
2e75				endm 
# End of macro FORTH_DSP_POP
2e75			 
2e75			 
2e75			 
2e75				       NEXTW 
2e75 c3 ff 1f			jp macro_next 
2e78				endm 
# End of macro NEXTW
2e78			.GET2: 
2e78				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e78 6f				db WORD_SYS_CORE+91             
2e79 ad 2e			dw .BANG2            
2e7b 03				db 2 + 1 
2e7c .. 00			db "2@",0              
2e7f				endm 
# End of macro CWHEAD
2e7f			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e7f					if DEBUG_FORTH_WORDS_KEY 
2e7f						DMARK "2A_" 
2e7f f5				push af  
2e80 3a 94 2e			ld a, (.dmark)  
2e83 32 6b ee			ld (debug_mark),a  
2e86 3a 95 2e			ld a, (.dmark+1)  
2e89 32 6c ee			ld (debug_mark+1),a  
2e8c 3a 96 2e			ld a, (.dmark+2)  
2e8f 32 6d ee			ld (debug_mark+2),a  
2e92 18 03			jr .pastdmark  
2e94 ..			.dmark: db "2A_"  
2e97 f1			.pastdmark: pop af  
2e98			endm  
# End of macro DMARK
2e98						CALLMONITOR 
2e98 cd 6f ee			call debug_vector  
2e9b				endm  
# End of macro CALLMONITOR
2e9b					endif 
2e9b			 
2e9b					FORTH_DSP_VALUEHL 
2e9b cd 49 1e			call macro_dsp_valuehl 
2e9e				endm 
# End of macro FORTH_DSP_VALUEHL
2e9e			 
2e9e e5					push hl   ; save address 
2e9f			 
2e9f					FORTH_DSP_POP 
2e9f cd 01 1f			call macro_forth_dsp_pop 
2ea2				endm 
# End of macro FORTH_DSP_POP
2ea2			 
2ea2 e1					pop hl 
2ea3			 
2ea3 5e					ld e, (hl) 
2ea4 23					inc hl 
2ea5 56					ld d, (hl) 
2ea6			 
2ea6 eb					ex de, hl 
2ea7			 
2ea7 cd 52 1c				call forth_push_numhl 
2eaa			 
2eaa				       NEXTW 
2eaa c3 ff 1f			jp macro_next 
2ead				endm 
# End of macro NEXTW
2ead			.BANG2: 
2ead				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2ead 6f				db WORD_SYS_CORE+91             
2eae e5 2e			dw .CONFIG            
2eb0 03				db 2 + 1 
2eb1 .. 00			db "2!",0              
2eb4				endm 
# End of macro CWHEAD
2eb4			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2eb4					if DEBUG_FORTH_WORDS_KEY 
2eb4						DMARK "2S_" 
2eb4 f5				push af  
2eb5 3a c9 2e			ld a, (.dmark)  
2eb8 32 6b ee			ld (debug_mark),a  
2ebb 3a ca 2e			ld a, (.dmark+1)  
2ebe 32 6c ee			ld (debug_mark+1),a  
2ec1 3a cb 2e			ld a, (.dmark+2)  
2ec4 32 6d ee			ld (debug_mark+2),a  
2ec7 18 03			jr .pastdmark  
2ec9 ..			.dmark: db "2S_"  
2ecc f1			.pastdmark: pop af  
2ecd			endm  
# End of macro DMARK
2ecd						CALLMONITOR 
2ecd cd 6f ee			call debug_vector  
2ed0				endm  
# End of macro CALLMONITOR
2ed0					endif 
2ed0			 
2ed0					FORTH_DSP_VALUEHL 
2ed0 cd 49 1e			call macro_dsp_valuehl 
2ed3				endm 
# End of macro FORTH_DSP_VALUEHL
2ed3			 
2ed3 e5					push hl   ; save address 
2ed4			 
2ed4			 
2ed4					FORTH_DSP_POP 
2ed4 cd 01 1f			call macro_forth_dsp_pop 
2ed7				endm 
# End of macro FORTH_DSP_POP
2ed7			 
2ed7					 
2ed7					FORTH_DSP_VALUEHL 
2ed7 cd 49 1e			call macro_dsp_valuehl 
2eda				endm 
# End of macro FORTH_DSP_VALUEHL
2eda			 
2eda					FORTH_DSP_POP 
2eda cd 01 1f			call macro_forth_dsp_pop 
2edd				endm 
# End of macro FORTH_DSP_POP
2edd			 
2edd eb					ex de, hl    ; value now in de 
2ede			 
2ede e1					pop hl 
2edf			 
2edf 73					ld (hl), e 
2ee0			 
2ee0 23					inc hl 
2ee1			 
2ee1 72					ld (hl), d 
2ee2			 
2ee2			 
2ee2				       NEXTW 
2ee2 c3 ff 1f			jp macro_next 
2ee5				endm 
# End of macro NEXTW
2ee5			.CONFIG: 
2ee5				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
2ee5 6f				db WORD_SYS_CORE+91             
2ee6 f6 2e			dw .ADTOS            
2ee8 07				db 6 + 1 
2ee9 .. 00			db "CONFIG",0              
2ef0				endm 
# End of macro CWHEAD
2ef0			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2ef0			 
2ef0 cd 52 14				call config 
2ef3					NEXTW 
2ef3 c3 ff 1f			jp macro_next 
2ef6				endm 
# End of macro NEXTW
2ef6			 
2ef6			.ADTOS: 
2ef6				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
2ef6 6f				db WORD_SYS_CORE+91             
2ef7 0c 2f			dw .SBTOS            
2ef9 03				db 2 + 1 
2efa .. 00			db "1+",0              
2efd				endm 
# End of macro CWHEAD
2efd			; | 1+ ( u -- u )  Increment value on TOS | DONE 
2efd			 
2efd					FORTH_DSP_VALUEHL 
2efd cd 49 1e			call macro_dsp_valuehl 
2f00				endm 
# End of macro FORTH_DSP_VALUEHL
2f00 e5					push hl 
2f01			 
2f01					FORTH_DSP_POP 
2f01 cd 01 1f			call macro_forth_dsp_pop 
2f04				endm 
# End of macro FORTH_DSP_POP
2f04 e1					pop hl 
2f05			 
2f05 23					inc hl 
2f06 cd 52 1c				call forth_push_numhl 
2f09					 
2f09					NEXTW 
2f09 c3 ff 1f			jp macro_next 
2f0c				endm 
# End of macro NEXTW
2f0c			.SBTOS: 
2f0c				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
2f0c 6f				db WORD_SYS_CORE+91             
2f0d 22 2f			dw .ADSTORE            
2f0f 03				db 2 + 1 
2f10 .. 00			db "1-",0              
2f13				endm 
# End of macro CWHEAD
2f13			; | 1- ( u -- u )  Decrement value on TOS | DONE 
2f13			 
2f13					FORTH_DSP_VALUEHL 
2f13 cd 49 1e			call macro_dsp_valuehl 
2f16				endm 
# End of macro FORTH_DSP_VALUEHL
2f16 e5					push hl 
2f17			 
2f17					FORTH_DSP_POP 
2f17 cd 01 1f			call macro_forth_dsp_pop 
2f1a				endm 
# End of macro FORTH_DSP_POP
2f1a e1					pop hl 
2f1b			 
2f1b 2b					dec hl 
2f1c cd 52 1c				call forth_push_numhl 
2f1f					 
2f1f					NEXTW 
2f1f c3 ff 1f			jp macro_next 
2f22				endm 
# End of macro NEXTW
2f22			.ADSTORE: 
2f22				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
2f22 6f				db WORD_SYS_CORE+91             
2f23 38 2f			dw .ADWSTORE            
2f25 04				db 3 + 1 
2f26 .. 00			db "1+!",0              
2f2a				endm 
# End of macro CWHEAD
2f2a			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
2f2a			 
2f2a					FORTH_DSP_VALUEHL 
2f2a cd 49 1e			call macro_dsp_valuehl 
2f2d				endm 
# End of macro FORTH_DSP_VALUEHL
2f2d e5					push hl 
2f2e			 
2f2e					FORTH_DSP_POP 
2f2e cd 01 1f			call macro_forth_dsp_pop 
2f31				endm 
# End of macro FORTH_DSP_POP
2f31 e1					pop hl 
2f32			 
2f32 7e					ld a, (hl) 
2f33 3c					inc a 
2f34 77					ld (hl), a 
2f35					 
2f35					NEXTW 
2f35 c3 ff 1f			jp macro_next 
2f38				endm 
# End of macro NEXTW
2f38			.ADWSTORE: 
2f38				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
2f38 6f				db WORD_SYS_CORE+91             
2f39 56 2f			dw .SBSTORE            
2f3b 05				db 4 + 1 
2f3c .. 00			db "1+2!",0              
2f41				endm 
# End of macro CWHEAD
2f41			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
2f41			 
2f41					FORTH_DSP_VALUEHL 
2f41 cd 49 1e			call macro_dsp_valuehl 
2f44				endm 
# End of macro FORTH_DSP_VALUEHL
2f44 e5					push hl 
2f45			 
2f45					FORTH_DSP_POP 
2f45 cd 01 1f			call macro_forth_dsp_pop 
2f48				endm 
# End of macro FORTH_DSP_POP
2f48 e1					pop hl 
2f49			 
2f49 e5					push hl 
2f4a			 
2f4a cd 81 1f				call loadwordinhl 
2f4d 23					inc hl 
2f4e			 
2f4e d1					pop de 
2f4f eb					ex de, hl 
2f50 73					ld (hl), e 
2f51 23					inc hl 
2f52 72					ld (hl), d 
2f53					 
2f53					NEXTW 
2f53 c3 ff 1f			jp macro_next 
2f56				endm 
# End of macro NEXTW
2f56			.SBSTORE: 
2f56				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
2f56 6f				db WORD_SYS_CORE+91             
2f57 6c 2f			dw .SBWSTORE            
2f59 04				db 3 + 1 
2f5a .. 00			db "1-!",0              
2f5e				endm 
# End of macro CWHEAD
2f5e			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
2f5e			 
2f5e					FORTH_DSP_VALUEHL 
2f5e cd 49 1e			call macro_dsp_valuehl 
2f61				endm 
# End of macro FORTH_DSP_VALUEHL
2f61 e5					push hl 
2f62			 
2f62					FORTH_DSP_POP 
2f62 cd 01 1f			call macro_forth_dsp_pop 
2f65				endm 
# End of macro FORTH_DSP_POP
2f65 e1					pop hl 
2f66			 
2f66 7e					ld a, (hl) 
2f67 3d					dec a 
2f68 77					ld (hl), a 
2f69					 
2f69					NEXTW 
2f69 c3 ff 1f			jp macro_next 
2f6c				endm 
# End of macro NEXTW
2f6c			.SBWSTORE: 
2f6c				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
2f6c 6f				db WORD_SYS_CORE+91             
2f6d 8a 2f			dw .ENDCORE            
2f6f 05				db 4 + 1 
2f70 .. 00			db "1-2!",0              
2f75				endm 
# End of macro CWHEAD
2f75			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
2f75			 
2f75					FORTH_DSP_VALUEHL 
2f75 cd 49 1e			call macro_dsp_valuehl 
2f78				endm 
# End of macro FORTH_DSP_VALUEHL
2f78 e5					push hl 
2f79			 
2f79					FORTH_DSP_POP 
2f79 cd 01 1f			call macro_forth_dsp_pop 
2f7c				endm 
# End of macro FORTH_DSP_POP
2f7c e1					pop hl 
2f7d			 
2f7d e5					push hl 
2f7e			 
2f7e cd 81 1f				call loadwordinhl 
2f81 2b					dec hl 
2f82			 
2f82 d1					pop de 
2f83 eb					ex de, hl 
2f84 73					ld (hl), e 
2f85 23					inc hl 
2f86 72					ld (hl), d 
2f87					 
2f87					NEXTW 
2f87 c3 ff 1f			jp macro_next 
2f8a				endm 
# End of macro NEXTW
2f8a			.ENDCORE: 
2f8a			 
2f8a			; eof 
2f8a			 
2f8a			 
# End of file forth_words_core.asm
2f8a			include "forth_words_flow.asm" 
2f8a			 
2f8a			; | ## Program Flow Words 
2f8a			 
2f8a			.IF: 
2f8a				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f8a 1e				db WORD_SYS_CORE+10             
2f8b 7f 30			dw .THEN            
2f8d 03				db 2 + 1 
2f8e .. 00			db "IF",0              
2f91				endm 
# End of macro CWHEAD
2f91			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f91			; 
2f91					if DEBUG_FORTH_WORDS_KEY 
2f91						DMARK "IF." 
2f91 f5				push af  
2f92 3a a6 2f			ld a, (.dmark)  
2f95 32 6b ee			ld (debug_mark),a  
2f98 3a a7 2f			ld a, (.dmark+1)  
2f9b 32 6c ee			ld (debug_mark+1),a  
2f9e 3a a8 2f			ld a, (.dmark+2)  
2fa1 32 6d ee			ld (debug_mark+2),a  
2fa4 18 03			jr .pastdmark  
2fa6 ..			.dmark: db "IF."  
2fa9 f1			.pastdmark: pop af  
2faa			endm  
# End of macro DMARK
2faa						CALLMONITOR 
2faa cd 6f ee			call debug_vector  
2fad				endm  
# End of macro CALLMONITOR
2fad					endif 
2fad			; eval TOS 
2fad			 
2fad				FORTH_DSP_VALUEHL 
2fad cd 49 1e			call macro_dsp_valuehl 
2fb0				endm 
# End of macro FORTH_DSP_VALUEHL
2fb0			 
2fb0			;	push hl 
2fb0				FORTH_DSP_POP 
2fb0 cd 01 1f			call macro_forth_dsp_pop 
2fb3				endm 
# End of macro FORTH_DSP_POP
2fb3			;	pop hl 
2fb3			 
2fb3					if DEBUG_FORTH_WORDS 
2fb3						DMARK "IF1" 
2fb3 f5				push af  
2fb4 3a c8 2f			ld a, (.dmark)  
2fb7 32 6b ee			ld (debug_mark),a  
2fba 3a c9 2f			ld a, (.dmark+1)  
2fbd 32 6c ee			ld (debug_mark+1),a  
2fc0 3a ca 2f			ld a, (.dmark+2)  
2fc3 32 6d ee			ld (debug_mark+2),a  
2fc6 18 03			jr .pastdmark  
2fc8 ..			.dmark: db "IF1"  
2fcb f1			.pastdmark: pop af  
2fcc			endm  
# End of macro DMARK
2fcc						CALLMONITOR 
2fcc cd 6f ee			call debug_vector  
2fcf				endm  
# End of macro CALLMONITOR
2fcf					endif 
2fcf b7				or a        ; clear carry flag 
2fd0 11 00 00			ld de, 0 
2fd3 eb				ex de,hl 
2fd4 ed 52			sbc hl, de 
2fd6 c2 60 30			jp nz, .iftrue 
2fd9			 
2fd9					if DEBUG_FORTH_WORDS 
2fd9						DMARK "IF2" 
2fd9 f5				push af  
2fda 3a ee 2f			ld a, (.dmark)  
2fdd 32 6b ee			ld (debug_mark),a  
2fe0 3a ef 2f			ld a, (.dmark+1)  
2fe3 32 6c ee			ld (debug_mark+1),a  
2fe6 3a f0 2f			ld a, (.dmark+2)  
2fe9 32 6d ee			ld (debug_mark+2),a  
2fec 18 03			jr .pastdmark  
2fee ..			.dmark: db "IF2"  
2ff1 f1			.pastdmark: pop af  
2ff2			endm  
# End of macro DMARK
2ff2						CALLMONITOR 
2ff2 cd 6f ee			call debug_vector  
2ff5				endm  
# End of macro CALLMONITOR
2ff5					endif 
2ff5			 
2ff5			; if not true then skip to THEN 
2ff5			 
2ff5				; TODO get tok_ptr 
2ff5				; TODO consume toks until we get to THEN 
2ff5			 
2ff5 2a c2 e5			ld hl, (os_tok_ptr) 
2ff8					if DEBUG_FORTH_WORDS 
2ff8						DMARK "IF3" 
2ff8 f5				push af  
2ff9 3a 0d 30			ld a, (.dmark)  
2ffc 32 6b ee			ld (debug_mark),a  
2fff 3a 0e 30			ld a, (.dmark+1)  
3002 32 6c ee			ld (debug_mark+1),a  
3005 3a 0f 30			ld a, (.dmark+2)  
3008 32 6d ee			ld (debug_mark+2),a  
300b 18 03			jr .pastdmark  
300d ..			.dmark: db "IF3"  
3010 f1			.pastdmark: pop af  
3011			endm  
# End of macro DMARK
3011						CALLMONITOR 
3011 cd 6f ee			call debug_vector  
3014				endm  
# End of macro CALLMONITOR
3014						 
3014					endif 
3014 11 5b 30			ld de, .ifthen 
3017					if DEBUG_FORTH_WORDS 
3017						DMARK "IF4" 
3017 f5				push af  
3018 3a 2c 30			ld a, (.dmark)  
301b 32 6b ee			ld (debug_mark),a  
301e 3a 2d 30			ld a, (.dmark+1)  
3021 32 6c ee			ld (debug_mark+1),a  
3024 3a 2e 30			ld a, (.dmark+2)  
3027 32 6d ee			ld (debug_mark+2),a  
302a 18 03			jr .pastdmark  
302c ..			.dmark: db "IF4"  
302f f1			.pastdmark: pop af  
3030			endm  
# End of macro DMARK
3030						CALLMONITOR 
3030 cd 6f ee			call debug_vector  
3033				endm  
# End of macro CALLMONITOR
3033					endif 
3033 cd 1a 21			call findnexttok  
3036			 
3036					if DEBUG_FORTH_WORDS 
3036						DMARK "IF5" 
3036 f5				push af  
3037 3a 4b 30			ld a, (.dmark)  
303a 32 6b ee			ld (debug_mark),a  
303d 3a 4c 30			ld a, (.dmark+1)  
3040 32 6c ee			ld (debug_mark+1),a  
3043 3a 4d 30			ld a, (.dmark+2)  
3046 32 6d ee			ld (debug_mark+2),a  
3049 18 03			jr .pastdmark  
304b ..			.dmark: db "IF5"  
304e f1			.pastdmark: pop af  
304f			endm  
# End of macro DMARK
304f						CALLMONITOR 
304f cd 6f ee			call debug_vector  
3052				endm  
# End of macro CALLMONITOR
3052					endif 
3052				; TODO replace below with ; exec using tok_ptr 
3052 22 c2 e5			ld (os_tok_ptr), hl 
3055 c3 90 20			jp exec1 
3058				NEXTW 
3058 c3 ff 1f			jp macro_next 
305b				endm 
# End of macro NEXTW
305b			 
305b .. 00		.ifthen:  db "THEN",0 
3060			 
3060			.iftrue:		 
3060				; Exec next words normally 
3060			 
3060				; if true then exec following IF as normal 
3060					if DEBUG_FORTH_WORDS 
3060						DMARK "IFT" 
3060 f5				push af  
3061 3a 75 30			ld a, (.dmark)  
3064 32 6b ee			ld (debug_mark),a  
3067 3a 76 30			ld a, (.dmark+1)  
306a 32 6c ee			ld (debug_mark+1),a  
306d 3a 77 30			ld a, (.dmark+2)  
3070 32 6d ee			ld (debug_mark+2),a  
3073 18 03			jr .pastdmark  
3075 ..			.dmark: db "IFT"  
3078 f1			.pastdmark: pop af  
3079			endm  
# End of macro DMARK
3079						CALLMONITOR 
3079 cd 6f ee			call debug_vector  
307c				endm  
# End of macro CALLMONITOR
307c					endif 
307c			 
307c					NEXTW 
307c c3 ff 1f			jp macro_next 
307f				endm 
# End of macro NEXTW
307f			.THEN: 
307f				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
307f 1f				db WORD_SYS_CORE+11             
3080 a7 30			dw .ELSE            
3082 05				db 4 + 1 
3083 .. 00			db "THEN",0              
3088				endm 
# End of macro CWHEAD
3088			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3088					if DEBUG_FORTH_WORDS_KEY 
3088						DMARK "THN" 
3088 f5				push af  
3089 3a 9d 30			ld a, (.dmark)  
308c 32 6b ee			ld (debug_mark),a  
308f 3a 9e 30			ld a, (.dmark+1)  
3092 32 6c ee			ld (debug_mark+1),a  
3095 3a 9f 30			ld a, (.dmark+2)  
3098 32 6d ee			ld (debug_mark+2),a  
309b 18 03			jr .pastdmark  
309d ..			.dmark: db "THN"  
30a0 f1			.pastdmark: pop af  
30a1			endm  
# End of macro DMARK
30a1						CALLMONITOR 
30a1 cd 6f ee			call debug_vector  
30a4				endm  
# End of macro CALLMONITOR
30a4					endif 
30a4					NEXTW 
30a4 c3 ff 1f			jp macro_next 
30a7				endm 
# End of macro NEXTW
30a7			.ELSE: 
30a7				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
30a7 20				db WORD_SYS_CORE+12             
30a8 cf 30			dw .DO            
30aa 03				db 2 + 1 
30ab .. 00			db "ELSE",0              
30b0				endm 
# End of macro CWHEAD
30b0			; | ELSE ( -- ) Not supported - does nothing | TODO 
30b0			 
30b0					if DEBUG_FORTH_WORDS_KEY 
30b0						DMARK "ELS" 
30b0 f5				push af  
30b1 3a c5 30			ld a, (.dmark)  
30b4 32 6b ee			ld (debug_mark),a  
30b7 3a c6 30			ld a, (.dmark+1)  
30ba 32 6c ee			ld (debug_mark+1),a  
30bd 3a c7 30			ld a, (.dmark+2)  
30c0 32 6d ee			ld (debug_mark+2),a  
30c3 18 03			jr .pastdmark  
30c5 ..			.dmark: db "ELS"  
30c8 f1			.pastdmark: pop af  
30c9			endm  
# End of macro DMARK
30c9						CALLMONITOR 
30c9 cd 6f ee			call debug_vector  
30cc				endm  
# End of macro CALLMONITOR
30cc					endif 
30cc			 
30cc			 
30cc					NEXTW 
30cc c3 ff 1f			jp macro_next 
30cf				endm 
# End of macro NEXTW
30cf			.DO: 
30cf				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
30cf 21				db WORD_SYS_CORE+13             
30d0 f6 31			dw .LOOP            
30d2 03				db 2 + 1 
30d3 .. 00			db "DO",0              
30d6				endm 
# End of macro CWHEAD
30d6			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
30d6			 
30d6					if DEBUG_FORTH_WORDS_KEY 
30d6						DMARK "DO." 
30d6 f5				push af  
30d7 3a eb 30			ld a, (.dmark)  
30da 32 6b ee			ld (debug_mark),a  
30dd 3a ec 30			ld a, (.dmark+1)  
30e0 32 6c ee			ld (debug_mark+1),a  
30e3 3a ed 30			ld a, (.dmark+2)  
30e6 32 6d ee			ld (debug_mark+2),a  
30e9 18 03			jr .pastdmark  
30eb ..			.dmark: db "DO."  
30ee f1			.pastdmark: pop af  
30ef			endm  
# End of macro DMARK
30ef						CALLMONITOR 
30ef cd 6f ee			call debug_vector  
30f2				endm  
# End of macro CALLMONITOR
30f2					endif 
30f2			;  push pc to rsp stack past the DO 
30f2			 
30f2 2a c2 e5				ld hl, (os_tok_ptr) 
30f5 23					inc hl   ; D 
30f6 23					inc hl  ; O 
30f7 23					inc hl   ; null 
30f8					if DEBUG_FORTH_WORDS 
30f8						DMARK "DO2" 
30f8 f5				push af  
30f9 3a 0d 31			ld a, (.dmark)  
30fc 32 6b ee			ld (debug_mark),a  
30ff 3a 0e 31			ld a, (.dmark+1)  
3102 32 6c ee			ld (debug_mark+1),a  
3105 3a 0f 31			ld a, (.dmark+2)  
3108 32 6d ee			ld (debug_mark+2),a  
310b 18 03			jr .pastdmark  
310d ..			.dmark: db "DO2"  
3110 f1			.pastdmark: pop af  
3111			endm  
# End of macro DMARK
3111						CALLMONITOR 
3111 cd 6f ee			call debug_vector  
3114				endm  
# End of macro CALLMONITOR
3114					endif 
3114					FORTH_RSP_NEXT 
3114 cd f9 1b			call macro_forth_rsp_next 
3117				endm 
# End of macro FORTH_RSP_NEXT
3117					if DEBUG_FORTH_WORDS 
3117						DMARK "DO3" 
3117 f5				push af  
3118 3a 2c 31			ld a, (.dmark)  
311b 32 6b ee			ld (debug_mark),a  
311e 3a 2d 31			ld a, (.dmark+1)  
3121 32 6c ee			ld (debug_mark+1),a  
3124 3a 2e 31			ld a, (.dmark+2)  
3127 32 6d ee			ld (debug_mark+2),a  
312a 18 03			jr .pastdmark  
312c ..			.dmark: db "DO3"  
312f f1			.pastdmark: pop af  
3130			endm  
# End of macro DMARK
3130						CALLMONITOR 
3130 cd 6f ee			call debug_vector  
3133				endm  
# End of macro CALLMONITOR
3133					endif 
3133			 
3133					;if DEBUG_FORTH_WORDS 
3133				;		push hl 
3133			;		endif  
3133			 
3133			; get counters from data stack 
3133			 
3133			 
3133					FORTH_DSP_VALUEHL 
3133 cd 49 1e			call macro_dsp_valuehl 
3136				endm 
# End of macro FORTH_DSP_VALUEHL
3136 e5					push hl		 ; hl now has starting counter which needs to be tos 
3137			 
3137					if DEBUG_FORTH_WORDS 
3137						DMARK "DO4" 
3137 f5				push af  
3138 3a 4c 31			ld a, (.dmark)  
313b 32 6b ee			ld (debug_mark),a  
313e 3a 4d 31			ld a, (.dmark+1)  
3141 32 6c ee			ld (debug_mark+1),a  
3144 3a 4e 31			ld a, (.dmark+2)  
3147 32 6d ee			ld (debug_mark+2),a  
314a 18 03			jr .pastdmark  
314c ..			.dmark: db "DO4"  
314f f1			.pastdmark: pop af  
3150			endm  
# End of macro DMARK
3150						CALLMONITOR 
3150 cd 6f ee			call debug_vector  
3153				endm  
# End of macro CALLMONITOR
3153					endif 
3153					FORTH_DSP_POP 
3153 cd 01 1f			call macro_forth_dsp_pop 
3156				endm 
# End of macro FORTH_DSP_POP
3156			 
3156					if DEBUG_FORTH_WORDS 
3156						DMARK "DO5" 
3156 f5				push af  
3157 3a 6b 31			ld a, (.dmark)  
315a 32 6b ee			ld (debug_mark),a  
315d 3a 6c 31			ld a, (.dmark+1)  
3160 32 6c ee			ld (debug_mark+1),a  
3163 3a 6d 31			ld a, (.dmark+2)  
3166 32 6d ee			ld (debug_mark+2),a  
3169 18 03			jr .pastdmark  
316b ..			.dmark: db "DO5"  
316e f1			.pastdmark: pop af  
316f			endm  
# End of macro DMARK
316f						CALLMONITOR 
316f cd 6f ee			call debug_vector  
3172				endm  
# End of macro CALLMONITOR
3172					endif 
3172			 
3172					FORTH_DSP_VALUEHL 
3172 cd 49 1e			call macro_dsp_valuehl 
3175				endm 
# End of macro FORTH_DSP_VALUEHL
3175			;		push hl		 ; hl now has starting limit counter 
3175			 
3175					if DEBUG_FORTH_WORDS 
3175						DMARK "DO6" 
3175 f5				push af  
3176 3a 8a 31			ld a, (.dmark)  
3179 32 6b ee			ld (debug_mark),a  
317c 3a 8b 31			ld a, (.dmark+1)  
317f 32 6c ee			ld (debug_mark+1),a  
3182 3a 8c 31			ld a, (.dmark+2)  
3185 32 6d ee			ld (debug_mark+2),a  
3188 18 03			jr .pastdmark  
318a ..			.dmark: db "DO6"  
318d f1			.pastdmark: pop af  
318e			endm  
# End of macro DMARK
318e						CALLMONITOR 
318e cd 6f ee			call debug_vector  
3191				endm  
# End of macro CALLMONITOR
3191					endif 
3191					FORTH_DSP_POP 
3191 cd 01 1f			call macro_forth_dsp_pop 
3194				endm 
# End of macro FORTH_DSP_POP
3194			 
3194			; put counters on the loop stack 
3194			 
3194			;		pop hl			 ; limit counter 
3194 d1					pop de			; start counter 
3195			 
3195					; push limit counter 
3195			 
3195					if DEBUG_FORTH_WORDS 
3195						DMARK "DO7" 
3195 f5				push af  
3196 3a aa 31			ld a, (.dmark)  
3199 32 6b ee			ld (debug_mark),a  
319c 3a ab 31			ld a, (.dmark+1)  
319f 32 6c ee			ld (debug_mark+1),a  
31a2 3a ac 31			ld a, (.dmark+2)  
31a5 32 6d ee			ld (debug_mark+2),a  
31a8 18 03			jr .pastdmark  
31aa ..			.dmark: db "DO7"  
31ad f1			.pastdmark: pop af  
31ae			endm  
# End of macro DMARK
31ae						CALLMONITOR 
31ae cd 6f ee			call debug_vector  
31b1				endm  
# End of macro CALLMONITOR
31b1					endif 
31b1					FORTH_LOOP_NEXT 
31b1 cd 7a 1e			call macro_forth_loop_next 
31b4				endm 
# End of macro FORTH_LOOP_NEXT
31b4			 
31b4					; push start counter 
31b4			 
31b4 eb					ex de, hl 
31b5					if DEBUG_FORTH_WORDS 
31b5						DMARK "DO7" 
31b5 f5				push af  
31b6 3a ca 31			ld a, (.dmark)  
31b9 32 6b ee			ld (debug_mark),a  
31bc 3a cb 31			ld a, (.dmark+1)  
31bf 32 6c ee			ld (debug_mark+1),a  
31c2 3a cc 31			ld a, (.dmark+2)  
31c5 32 6d ee			ld (debug_mark+2),a  
31c8 18 03			jr .pastdmark  
31ca ..			.dmark: db "DO7"  
31cd f1			.pastdmark: pop af  
31ce			endm  
# End of macro DMARK
31ce						CALLMONITOR 
31ce cd 6f ee			call debug_vector  
31d1				endm  
# End of macro CALLMONITOR
31d1					endif 
31d1					FORTH_LOOP_NEXT 
31d1 cd 7a 1e			call macro_forth_loop_next 
31d4				endm 
# End of macro FORTH_LOOP_NEXT
31d4			 
31d4			 
31d4					; init first round of I counter 
31d4			 
31d4 22 e6 e5				ld (os_current_i), hl 
31d7			 
31d7					if DEBUG_FORTH_WORDS 
31d7						DMARK "DO8" 
31d7 f5				push af  
31d8 3a ec 31			ld a, (.dmark)  
31db 32 6b ee			ld (debug_mark),a  
31de 3a ed 31			ld a, (.dmark+1)  
31e1 32 6c ee			ld (debug_mark+1),a  
31e4 3a ee 31			ld a, (.dmark+2)  
31e7 32 6d ee			ld (debug_mark+2),a  
31ea 18 03			jr .pastdmark  
31ec ..			.dmark: db "DO8"  
31ef f1			.pastdmark: pop af  
31f0			endm  
# End of macro DMARK
31f0						CALLMONITOR 
31f0 cd 6f ee			call debug_vector  
31f3				endm  
# End of macro CALLMONITOR
31f3					endif 
31f3			 
31f3					NEXTW 
31f3 c3 ff 1f			jp macro_next 
31f6				endm 
# End of macro NEXTW
31f6			.LOOP: 
31f6				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
31f6 22				db WORD_SYS_CORE+14             
31f7 0e 33			dw .I            
31f9 05				db 4 + 1 
31fa .. 00			db "LOOP",0              
31ff				endm 
# End of macro CWHEAD
31ff			; | LOOP ( -- ) Increment and test loop counter  | DONE 
31ff			 
31ff				; pop tos as current loop count to hl 
31ff			 
31ff				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
31ff			 
31ff				FORTH_LOOP_TOS 
31ff cd ad 1e			call macro_forth_loop_tos 
3202				endm 
# End of macro FORTH_LOOP_TOS
3202 e5				push hl 
3203			 
3203					if DEBUG_FORTH_WORDS_KEY 
3203						DMARK "LOP" 
3203 f5				push af  
3204 3a 18 32			ld a, (.dmark)  
3207 32 6b ee			ld (debug_mark),a  
320a 3a 19 32			ld a, (.dmark+1)  
320d 32 6c ee			ld (debug_mark+1),a  
3210 3a 1a 32			ld a, (.dmark+2)  
3213 32 6d ee			ld (debug_mark+2),a  
3216 18 03			jr .pastdmark  
3218 ..			.dmark: db "LOP"  
321b f1			.pastdmark: pop af  
321c			endm  
# End of macro DMARK
321c						CALLMONITOR 
321c cd 6f ee			call debug_vector  
321f				endm  
# End of macro CALLMONITOR
321f					endif 
321f				; next item on the stack is the limit. get it 
321f			 
321f			 
321f				FORTH_LOOP_POP 
321f cd b7 1e			call macro_forth_loop_pop 
3222				endm 
# End of macro FORTH_LOOP_POP
3222			 
3222				FORTH_LOOP_TOS 
3222 cd ad 1e			call macro_forth_loop_tos 
3225				endm 
# End of macro FORTH_LOOP_TOS
3225			 
3225 d1				pop de		 ; de = i, hl = limit 
3226			 
3226					if DEBUG_FORTH_WORDS 
3226						DMARK "LP1" 
3226 f5				push af  
3227 3a 3b 32			ld a, (.dmark)  
322a 32 6b ee			ld (debug_mark),a  
322d 3a 3c 32			ld a, (.dmark+1)  
3230 32 6c ee			ld (debug_mark+1),a  
3233 3a 3d 32			ld a, (.dmark+2)  
3236 32 6d ee			ld (debug_mark+2),a  
3239 18 03			jr .pastdmark  
323b ..			.dmark: db "LP1"  
323e f1			.pastdmark: pop af  
323f			endm  
# End of macro DMARK
323f						CALLMONITOR 
323f cd 6f ee			call debug_vector  
3242				endm  
# End of macro CALLMONITOR
3242					endif 
3242			 
3242				; go back to previous word 
3242			 
3242 d5				push de    ; save I for inc later 
3243			 
3243			 
3243				; get limit 
3243				;  is I at limit? 
3243			 
3243			 
3243					if DEBUG_FORTH_WORDS 
3243						DMARK "LP1" 
3243 f5				push af  
3244 3a 58 32			ld a, (.dmark)  
3247 32 6b ee			ld (debug_mark),a  
324a 3a 59 32			ld a, (.dmark+1)  
324d 32 6c ee			ld (debug_mark+1),a  
3250 3a 5a 32			ld a, (.dmark+2)  
3253 32 6d ee			ld (debug_mark+2),a  
3256 18 03			jr .pastdmark  
3258 ..			.dmark: db "LP1"  
325b f1			.pastdmark: pop af  
325c			endm  
# End of macro DMARK
325c						CALLMONITOR 
325c cd 6f ee			call debug_vector  
325f				endm  
# End of macro CALLMONITOR
325f					endif 
325f			 
325f ed 52			sbc hl, de 
3261			 
3261			 
3261				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3261			 
3261 20 26				jr nz, .loopnotdone 
3263			 
3263 e1				pop hl   ; get rid of saved I 
3264				FORTH_LOOP_POP     ; get rid of limit 
3264 cd b7 1e			call macro_forth_loop_pop 
3267				endm 
# End of macro FORTH_LOOP_POP
3267			 
3267				FORTH_RSP_POP     ; get rid of DO ptr 
3267 cd 1a 1c			call macro_forth_rsp_pop 
326a				endm 
# End of macro FORTH_RSP_POP
326a			 
326a			if DEBUG_FORTH_WORDS 
326a						DMARK "LP>" 
326a f5				push af  
326b 3a 7f 32			ld a, (.dmark)  
326e 32 6b ee			ld (debug_mark),a  
3271 3a 80 32			ld a, (.dmark+1)  
3274 32 6c ee			ld (debug_mark+1),a  
3277 3a 81 32			ld a, (.dmark+2)  
327a 32 6d ee			ld (debug_mark+2),a  
327d 18 03			jr .pastdmark  
327f ..			.dmark: db "LP>"  
3282 f1			.pastdmark: pop af  
3283			endm  
# End of macro DMARK
3283				CALLMONITOR 
3283 cd 6f ee			call debug_vector  
3286				endm  
# End of macro CALLMONITOR
3286			endif 
3286			 
3286					NEXTW 
3286 c3 ff 1f			jp macro_next 
3289				endm 
# End of macro NEXTW
3289				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3289			 
3289			.loopnotdone: 
3289			 
3289 e1				pop hl    ; get I 
328a 23				inc hl 
328b			 
328b			   	; save new I 
328b			 
328b			 
328b					; set I counter 
328b			 
328b 22 e6 e5				ld (os_current_i), hl 
328e			 
328e					if DEBUG_FORTH_WORDS 
328e						DMARK "LPN" 
328e f5				push af  
328f 3a a3 32			ld a, (.dmark)  
3292 32 6b ee			ld (debug_mark),a  
3295 3a a4 32			ld a, (.dmark+1)  
3298 32 6c ee			ld (debug_mark+1),a  
329b 3a a5 32			ld a, (.dmark+2)  
329e 32 6d ee			ld (debug_mark+2),a  
32a1 18 03			jr .pastdmark  
32a3 ..			.dmark: db "LPN"  
32a6 f1			.pastdmark: pop af  
32a7			endm  
# End of macro DMARK
32a7					CALLMONITOR 
32a7 cd 6f ee			call debug_vector  
32aa				endm  
# End of macro CALLMONITOR
32aa					endif 
32aa					 
32aa				FORTH_LOOP_NEXT 
32aa cd 7a 1e			call macro_forth_loop_next 
32ad				endm 
# End of macro FORTH_LOOP_NEXT
32ad			 
32ad			 
32ad					if DEBUG_FORTH_WORDS 
32ad eb						ex de,hl 
32ae					endif 
32ae			 
32ae			;	; get DO ptr 
32ae			; 
32ae					if DEBUG_FORTH_WORDS 
32ae						DMARK "LP7" 
32ae f5				push af  
32af 3a c3 32			ld a, (.dmark)  
32b2 32 6b ee			ld (debug_mark),a  
32b5 3a c4 32			ld a, (.dmark+1)  
32b8 32 6c ee			ld (debug_mark+1),a  
32bb 3a c5 32			ld a, (.dmark+2)  
32be 32 6d ee			ld (debug_mark+2),a  
32c1 18 03			jr .pastdmark  
32c3 ..			.dmark: db "LP7"  
32c6 f1			.pastdmark: pop af  
32c7			endm  
# End of macro DMARK
32c7					CALLMONITOR 
32c7 cd 6f ee			call debug_vector  
32ca				endm  
# End of macro CALLMONITOR
32ca					endif 
32ca				FORTH_RSP_TOS 
32ca cd 10 1c			call macro_forth_rsp_tos 
32cd				endm 
# End of macro FORTH_RSP_TOS
32cd			 
32cd					if DEBUG_FORTH_WORDS 
32cd						DMARK "LP8" 
32cd f5				push af  
32ce 3a e2 32			ld a, (.dmark)  
32d1 32 6b ee			ld (debug_mark),a  
32d4 3a e3 32			ld a, (.dmark+1)  
32d7 32 6c ee			ld (debug_mark+1),a  
32da 3a e4 32			ld a, (.dmark+2)  
32dd 32 6d ee			ld (debug_mark+2),a  
32e0 18 03			jr .pastdmark  
32e2 ..			.dmark: db "LP8"  
32e5 f1			.pastdmark: pop af  
32e6			endm  
# End of macro DMARK
32e6					CALLMONITOR 
32e6 cd 6f ee			call debug_vector  
32e9				endm  
# End of macro CALLMONITOR
32e9					endif 
32e9				;push hl 
32e9			 
32e9				; not going to DO any more 
32e9				; get rid of the RSP pointer as DO will add it back in 
32e9				;FORTH_RSP_POP 
32e9				;pop hl 
32e9			 
32e9				;ld hl,(cli_ret_sp) 
32e9				;ld e, (hl) 
32e9				;inc hl 
32e9				;ld d, (hl) 
32e9				;ex de,hl 
32e9 22 c2 e5			ld (os_tok_ptr), hl 
32ec					if DEBUG_FORTH_WORDS 
32ec						DMARK "LP<" 
32ec f5				push af  
32ed 3a 01 33			ld a, (.dmark)  
32f0 32 6b ee			ld (debug_mark),a  
32f3 3a 02 33			ld a, (.dmark+1)  
32f6 32 6c ee			ld (debug_mark+1),a  
32f9 3a 03 33			ld a, (.dmark+2)  
32fc 32 6d ee			ld (debug_mark+2),a  
32ff 18 03			jr .pastdmark  
3301 ..			.dmark: db "LP<"  
3304 f1			.pastdmark: pop af  
3305			endm  
# End of macro DMARK
3305					CALLMONITOR 
3305 cd 6f ee			call debug_vector  
3308				endm  
# End of macro CALLMONITOR
3308				endif 
3308 c3 90 20			jp exec1 
330b			 
330b					 
330b			 
330b			 
330b					NEXTW 
330b c3 ff 1f			jp macro_next 
330e				endm 
# End of macro NEXTW
330e			.I:  
330e			 
330e				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
330e 5e				db WORD_SYS_CORE+74             
330f 39 33			dw .DLOOP            
3311 02				db 1 + 1 
3312 .. 00			db "I",0              
3314				endm 
# End of macro CWHEAD
3314			; | I ( -- ) Current loop counter | DONE 
3314					if DEBUG_FORTH_WORDS_KEY 
3314						DMARK "I.." 
3314 f5				push af  
3315 3a 29 33			ld a, (.dmark)  
3318 32 6b ee			ld (debug_mark),a  
331b 3a 2a 33			ld a, (.dmark+1)  
331e 32 6c ee			ld (debug_mark+1),a  
3321 3a 2b 33			ld a, (.dmark+2)  
3324 32 6d ee			ld (debug_mark+2),a  
3327 18 03			jr .pastdmark  
3329 ..			.dmark: db "I.."  
332c f1			.pastdmark: pop af  
332d			endm  
# End of macro DMARK
332d						CALLMONITOR 
332d cd 6f ee			call debug_vector  
3330				endm  
# End of macro CALLMONITOR
3330					endif 
3330			 
3330 2a e6 e5				ld hl,(os_current_i) 
3333 cd 52 1c				call forth_push_numhl 
3336			 
3336					NEXTW 
3336 c3 ff 1f			jp macro_next 
3339				endm 
# End of macro NEXTW
3339			.DLOOP: 
3339				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3339 5f				db WORD_SYS_CORE+75             
333a 1a 34			dw .REPEAT            
333c 06				db 5 + 1 
333d .. 00			db "-LOOP",0              
3343				endm 
# End of macro CWHEAD
3343			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3343				; pop tos as current loop count to hl 
3343					if DEBUG_FORTH_WORDS_KEY 
3343						DMARK "-LP" 
3343 f5				push af  
3344 3a 58 33			ld a, (.dmark)  
3347 32 6b ee			ld (debug_mark),a  
334a 3a 59 33			ld a, (.dmark+1)  
334d 32 6c ee			ld (debug_mark+1),a  
3350 3a 5a 33			ld a, (.dmark+2)  
3353 32 6d ee			ld (debug_mark+2),a  
3356 18 03			jr .pastdmark  
3358 ..			.dmark: db "-LP"  
335b f1			.pastdmark: pop af  
335c			endm  
# End of macro DMARK
335c						CALLMONITOR 
335c cd 6f ee			call debug_vector  
335f				endm  
# End of macro CALLMONITOR
335f					endif 
335f			 
335f				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
335f			 
335f				FORTH_LOOP_TOS 
335f cd ad 1e			call macro_forth_loop_tos 
3362				endm 
# End of macro FORTH_LOOP_TOS
3362 e5				push hl 
3363			 
3363					if DEBUG_FORTH_WORDS 
3363						DMARK "-LP" 
3363 f5				push af  
3364 3a 78 33			ld a, (.dmark)  
3367 32 6b ee			ld (debug_mark),a  
336a 3a 79 33			ld a, (.dmark+1)  
336d 32 6c ee			ld (debug_mark+1),a  
3370 3a 7a 33			ld a, (.dmark+2)  
3373 32 6d ee			ld (debug_mark+2),a  
3376 18 03			jr .pastdmark  
3378 ..			.dmark: db "-LP"  
337b f1			.pastdmark: pop af  
337c			endm  
# End of macro DMARK
337c						CALLMONITOR 
337c cd 6f ee			call debug_vector  
337f				endm  
# End of macro CALLMONITOR
337f					endif 
337f				; next item on the stack is the limit. get it 
337f			 
337f			 
337f				FORTH_LOOP_POP 
337f cd b7 1e			call macro_forth_loop_pop 
3382				endm 
# End of macro FORTH_LOOP_POP
3382			 
3382				FORTH_LOOP_TOS 
3382 cd ad 1e			call macro_forth_loop_tos 
3385				endm 
# End of macro FORTH_LOOP_TOS
3385			 
3385 d1				pop de		 ; de = i, hl = limit 
3386			 
3386					if DEBUG_FORTH_WORDS 
3386						DMARK "-L1" 
3386 f5				push af  
3387 3a 9b 33			ld a, (.dmark)  
338a 32 6b ee			ld (debug_mark),a  
338d 3a 9c 33			ld a, (.dmark+1)  
3390 32 6c ee			ld (debug_mark+1),a  
3393 3a 9d 33			ld a, (.dmark+2)  
3396 32 6d ee			ld (debug_mark+2),a  
3399 18 03			jr .pastdmark  
339b ..			.dmark: db "-L1"  
339e f1			.pastdmark: pop af  
339f			endm  
# End of macro DMARK
339f						CALLMONITOR 
339f cd 6f ee			call debug_vector  
33a2				endm  
# End of macro CALLMONITOR
33a2					endif 
33a2			 
33a2				; go back to previous word 
33a2			 
33a2 d5				push de    ; save I for inc later 
33a3			 
33a3			 
33a3				; get limit 
33a3				;  is I at limit? 
33a3			 
33a3			 
33a3					if DEBUG_FORTH_WORDS 
33a3						DMARK "-L1" 
33a3 f5				push af  
33a4 3a b8 33			ld a, (.dmark)  
33a7 32 6b ee			ld (debug_mark),a  
33aa 3a b9 33			ld a, (.dmark+1)  
33ad 32 6c ee			ld (debug_mark+1),a  
33b0 3a ba 33			ld a, (.dmark+2)  
33b3 32 6d ee			ld (debug_mark+2),a  
33b6 18 03			jr .pastdmark  
33b8 ..			.dmark: db "-L1"  
33bb f1			.pastdmark: pop af  
33bc			endm  
# End of macro DMARK
33bc						CALLMONITOR 
33bc cd 6f ee			call debug_vector  
33bf				endm  
# End of macro CALLMONITOR
33bf					endif 
33bf			 
33bf ed 52			sbc hl, de 
33c1			 
33c1			 
33c1				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
33c1			 
33c1 20 26				jr nz, .mloopnotdone 
33c3			 
33c3 e1				pop hl   ; get rid of saved I 
33c4				FORTH_LOOP_POP     ; get rid of limit 
33c4 cd b7 1e			call macro_forth_loop_pop 
33c7				endm 
# End of macro FORTH_LOOP_POP
33c7			 
33c7				FORTH_RSP_POP     ; get rid of DO ptr 
33c7 cd 1a 1c			call macro_forth_rsp_pop 
33ca				endm 
# End of macro FORTH_RSP_POP
33ca			 
33ca			if DEBUG_FORTH_WORDS 
33ca						DMARK "-L>" 
33ca f5				push af  
33cb 3a df 33			ld a, (.dmark)  
33ce 32 6b ee			ld (debug_mark),a  
33d1 3a e0 33			ld a, (.dmark+1)  
33d4 32 6c ee			ld (debug_mark+1),a  
33d7 3a e1 33			ld a, (.dmark+2)  
33da 32 6d ee			ld (debug_mark+2),a  
33dd 18 03			jr .pastdmark  
33df ..			.dmark: db "-L>"  
33e2 f1			.pastdmark: pop af  
33e3			endm  
# End of macro DMARK
33e3				CALLMONITOR 
33e3 cd 6f ee			call debug_vector  
33e6				endm  
# End of macro CALLMONITOR
33e6			endif 
33e6			 
33e6					NEXTW 
33e6 c3 ff 1f			jp macro_next 
33e9				endm 
# End of macro NEXTW
33e9				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
33e9			 
33e9			.mloopnotdone: 
33e9			 
33e9 e1				pop hl    ; get I 
33ea 2b				dec hl 
33eb			 
33eb			   	; save new I 
33eb			 
33eb			 
33eb					; set I counter 
33eb			 
33eb 22 e6 e5				ld (os_current_i), hl 
33ee			 
33ee					 
33ee				FORTH_LOOP_NEXT 
33ee cd 7a 1e			call macro_forth_loop_next 
33f1				endm 
# End of macro FORTH_LOOP_NEXT
33f1			 
33f1			 
33f1					if DEBUG_FORTH_WORDS 
33f1 eb						ex de,hl 
33f2					endif 
33f2			 
33f2			;	; get DO ptr 
33f2			; 
33f2				FORTH_RSP_TOS 
33f2 cd 10 1c			call macro_forth_rsp_tos 
33f5				endm 
# End of macro FORTH_RSP_TOS
33f5			 
33f5				;push hl 
33f5			 
33f5				; not going to DO any more 
33f5				; get rid of the RSP pointer as DO will add it back in 
33f5				;FORTH_RSP_POP 
33f5				;pop hl 
33f5			 
33f5			 
33f5 22 c2 e5			ld (os_tok_ptr), hl 
33f8					if DEBUG_FORTH_WORDS 
33f8						DMARK "-L<" 
33f8 f5				push af  
33f9 3a 0d 34			ld a, (.dmark)  
33fc 32 6b ee			ld (debug_mark),a  
33ff 3a 0e 34			ld a, (.dmark+1)  
3402 32 6c ee			ld (debug_mark+1),a  
3405 3a 0f 34			ld a, (.dmark+2)  
3408 32 6d ee			ld (debug_mark+2),a  
340b 18 03			jr .pastdmark  
340d ..			.dmark: db "-L<"  
3410 f1			.pastdmark: pop af  
3411			endm  
# End of macro DMARK
3411					CALLMONITOR 
3411 cd 6f ee			call debug_vector  
3414				endm  
# End of macro CALLMONITOR
3414				endif 
3414 c3 90 20			jp exec1 
3417			 
3417					 
3417			 
3417			 
3417			 
3417				NEXTW 
3417 c3 ff 1f			jp macro_next 
341a				endm 
# End of macro NEXTW
341a			 
341a			 
341a			 
341a			 
341a			.REPEAT: 
341a				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
341a 71				db WORD_SYS_CORE+93             
341b 6d 34			dw .UNTIL            
341d 06				db 5 + 1 
341e .. 00			db "REPEAT",0              
3425				endm 
# End of macro CWHEAD
3425			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3425			;  push pc to rsp stack past the REPEAT 
3425					if DEBUG_FORTH_WORDS_KEY 
3425						DMARK "REP" 
3425 f5				push af  
3426 3a 3a 34			ld a, (.dmark)  
3429 32 6b ee			ld (debug_mark),a  
342c 3a 3b 34			ld a, (.dmark+1)  
342f 32 6c ee			ld (debug_mark+1),a  
3432 3a 3c 34			ld a, (.dmark+2)  
3435 32 6d ee			ld (debug_mark+2),a  
3438 18 03			jr .pastdmark  
343a ..			.dmark: db "REP"  
343d f1			.pastdmark: pop af  
343e			endm  
# End of macro DMARK
343e						CALLMONITOR 
343e cd 6f ee			call debug_vector  
3441				endm  
# End of macro CALLMONITOR
3441					endif 
3441			 
3441 2a c2 e5				ld hl, (os_tok_ptr) 
3444 23					inc hl   ; R 
3445 23					inc hl  ; E 
3446 23					inc hl   ; P 
3447 23					inc hl   ; E 
3448 23					inc hl   ; A 
3449 23					inc hl   ; T 
344a 23					inc hl   ; zero 
344b					FORTH_RSP_NEXT 
344b cd f9 1b			call macro_forth_rsp_next 
344e				endm 
# End of macro FORTH_RSP_NEXT
344e			 
344e			 
344e					if DEBUG_FORTH_WORDS 
344e						DMARK "REP" 
344e f5				push af  
344f 3a 63 34			ld a, (.dmark)  
3452 32 6b ee			ld (debug_mark),a  
3455 3a 64 34			ld a, (.dmark+1)  
3458 32 6c ee			ld (debug_mark+1),a  
345b 3a 65 34			ld a, (.dmark+2)  
345e 32 6d ee			ld (debug_mark+2),a  
3461 18 03			jr .pastdmark  
3463 ..			.dmark: db "REP"  
3466 f1			.pastdmark: pop af  
3467			endm  
# End of macro DMARK
3467						;pop bc    ; TODO BUG ?????? what is this for???? 
3467						CALLMONITOR 
3467 cd 6f ee			call debug_vector  
346a				endm  
# End of macro CALLMONITOR
346a					endif 
346a			 
346a					NEXTW 
346a c3 ff 1f			jp macro_next 
346d				endm 
# End of macro NEXTW
346d			;	       NEXTW 
346d			 
346d			.UNTIL: 
346d				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
346d 72				db WORD_SYS_CORE+94             
346e 04 35			dw .ENDFLOW            
3470 06				db 5 + 1 
3471 .. 00			db "UNTIL",0              
3477				endm 
# End of macro CWHEAD
3477			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3477			 
3477				; pop tos as check 
3477			 
3477				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3477			 
3477				FORTH_DSP_VALUEHL 
3477 cd 49 1e			call macro_dsp_valuehl 
347a				endm 
# End of macro FORTH_DSP_VALUEHL
347a			 
347a					if DEBUG_FORTH_WORDS_KEY 
347a						DMARK "UNT" 
347a f5				push af  
347b 3a 8f 34			ld a, (.dmark)  
347e 32 6b ee			ld (debug_mark),a  
3481 3a 90 34			ld a, (.dmark+1)  
3484 32 6c ee			ld (debug_mark+1),a  
3487 3a 91 34			ld a, (.dmark+2)  
348a 32 6d ee			ld (debug_mark+2),a  
348d 18 03			jr .pastdmark  
348f ..			.dmark: db "UNT"  
3492 f1			.pastdmark: pop af  
3493			endm  
# End of macro DMARK
3493						CALLMONITOR 
3493 cd 6f ee			call debug_vector  
3496				endm  
# End of macro CALLMONITOR
3496					endif 
3496			 
3496			;	push hl 
3496				FORTH_DSP_POP 
3496 cd 01 1f			call macro_forth_dsp_pop 
3499				endm 
# End of macro FORTH_DSP_POP
3499			 
3499			;	pop hl 
3499			 
3499				; test if true 
3499			 
3499 cd 0f 0e			call ishlzero 
349c			;	ld a,l 
349c			;	add h 
349c			; 
349c			;	cp 0 
349c			 
349c 20 3e			jr nz, .untilnotdone 
349e			 
349e					if DEBUG_FORTH_WORDS 
349e						DMARK "UNf" 
349e f5				push af  
349f 3a b3 34			ld a, (.dmark)  
34a2 32 6b ee			ld (debug_mark),a  
34a5 3a b4 34			ld a, (.dmark+1)  
34a8 32 6c ee			ld (debug_mark+1),a  
34ab 3a b5 34			ld a, (.dmark+2)  
34ae 32 6d ee			ld (debug_mark+2),a  
34b1 18 03			jr .pastdmark  
34b3 ..			.dmark: db "UNf"  
34b6 f1			.pastdmark: pop af  
34b7			endm  
# End of macro DMARK
34b7						CALLMONITOR 
34b7 cd 6f ee			call debug_vector  
34ba				endm  
# End of macro CALLMONITOR
34ba					endif 
34ba			 
34ba			 
34ba			 
34ba				FORTH_RSP_POP     ; get rid of DO ptr 
34ba cd 1a 1c			call macro_forth_rsp_pop 
34bd				endm 
# End of macro FORTH_RSP_POP
34bd			 
34bd			if DEBUG_FORTH_WORDS 
34bd						DMARK "UN>" 
34bd f5				push af  
34be 3a d2 34			ld a, (.dmark)  
34c1 32 6b ee			ld (debug_mark),a  
34c4 3a d3 34			ld a, (.dmark+1)  
34c7 32 6c ee			ld (debug_mark+1),a  
34ca 3a d4 34			ld a, (.dmark+2)  
34cd 32 6d ee			ld (debug_mark+2),a  
34d0 18 03			jr .pastdmark  
34d2 ..			.dmark: db "UN>"  
34d5 f1			.pastdmark: pop af  
34d6			endm  
# End of macro DMARK
34d6				CALLMONITOR 
34d6 cd 6f ee			call debug_vector  
34d9				endm  
# End of macro CALLMONITOR
34d9			endif 
34d9			 
34d9					NEXTW 
34d9 c3 ff 1f			jp macro_next 
34dc				endm 
# End of macro NEXTW
34dc				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34dc			 
34dc			.untilnotdone: 
34dc			 
34dc			 
34dc			;	; get DO ptr 
34dc			; 
34dc				FORTH_RSP_TOS 
34dc cd 10 1c			call macro_forth_rsp_tos 
34df				endm 
# End of macro FORTH_RSP_TOS
34df			 
34df				;push hl 
34df			 
34df				; not going to DO any more 
34df				; get rid of the RSP pointer as DO will add it back in 
34df				;FORTH_RSP_POP 
34df				;pop hl 
34df			 
34df			 
34df 22 c2 e5			ld (os_tok_ptr), hl 
34e2					if DEBUG_FORTH_WORDS 
34e2						DMARK "UN<" 
34e2 f5				push af  
34e3 3a f7 34			ld a, (.dmark)  
34e6 32 6b ee			ld (debug_mark),a  
34e9 3a f8 34			ld a, (.dmark+1)  
34ec 32 6c ee			ld (debug_mark+1),a  
34ef 3a f9 34			ld a, (.dmark+2)  
34f2 32 6d ee			ld (debug_mark+2),a  
34f5 18 03			jr .pastdmark  
34f7 ..			.dmark: db "UN<"  
34fa f1			.pastdmark: pop af  
34fb			endm  
# End of macro DMARK
34fb					CALLMONITOR 
34fb cd 6f ee			call debug_vector  
34fe				endm  
# End of macro CALLMONITOR
34fe				endif 
34fe c3 90 20			jp exec1 
3501			 
3501					 
3501			 
3501			 
3501					NEXTW 
3501 c3 ff 1f			jp macro_next 
3504				endm 
# End of macro NEXTW
3504			 
3504			 
3504			.ENDFLOW: 
3504			 
3504			; eof 
3504			 
# End of file forth_words_flow.asm
3504			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3504			include "forth_words_logic.asm" 
3504			 
3504			; | ## Logic Words 
3504			 
3504			.NOT: 
3504				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3504 2d				db WORD_SYS_CORE+25             
3505 4c 35			dw .IS            
3507 04				db 3 + 1 
3508 .. 00			db "NOT",0              
350c				endm 
# End of macro CWHEAD
350c			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
350c					if DEBUG_FORTH_WORDS_KEY 
350c						DMARK "NOT" 
350c f5				push af  
350d 3a 21 35			ld a, (.dmark)  
3510 32 6b ee			ld (debug_mark),a  
3513 3a 22 35			ld a, (.dmark+1)  
3516 32 6c ee			ld (debug_mark+1),a  
3519 3a 23 35			ld a, (.dmark+2)  
351c 32 6d ee			ld (debug_mark+2),a  
351f 18 03			jr .pastdmark  
3521 ..			.dmark: db "NOT"  
3524 f1			.pastdmark: pop af  
3525			endm  
# End of macro DMARK
3525						CALLMONITOR 
3525 cd 6f ee			call debug_vector  
3528				endm  
# End of macro CALLMONITOR
3528					endif 
3528					FORTH_DSP 
3528 cd 0f 1e			call macro_forth_dsp 
352b				endm 
# End of macro FORTH_DSP
352b 7e					ld a,(hl)	; get type of value on TOS 
352c fe 02				cp DS_TYPE_INUM  
352e 28 03				jr z, .noti 
3530					NEXTW 
3530 c3 ff 1f			jp macro_next 
3533				endm 
# End of macro NEXTW
3533			.noti:          FORTH_DSP_VALUEHL 
3533 cd 49 1e			call macro_dsp_valuehl 
3536				endm 
# End of macro FORTH_DSP_VALUEHL
3536			;		push hl 
3536					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3536 cd 01 1f			call macro_forth_dsp_pop 
3539				endm 
# End of macro FORTH_DSP_POP
3539			;		pop hl 
3539 3e 00				ld a,0 
353b bd					cp l 
353c 28 04				jr z, .not2t 
353e 2e 00				ld l, 0 
3540 18 02				jr .notip 
3542			 
3542 2e ff		.not2t:		ld l, 255 
3544			 
3544 26 00		.notip:		ld h, 0	 
3546			 
3546 cd 52 1c				call forth_push_numhl 
3549					NEXTW 
3549 c3 ff 1f			jp macro_next 
354c				endm 
# End of macro NEXTW
354c			 
354c			.IS: 
354c				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
354c 2d				db WORD_SYS_CORE+25             
354d 72 35			dw .LZERO            
354f 03				db 2 + 1 
3550 .. 00			db "IS",0              
3553				endm 
# End of macro CWHEAD
3553			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3553					if DEBUG_FORTH_WORDS_KEY 
3553						DMARK "IS." 
3553 f5				push af  
3554 3a 68 35			ld a, (.dmark)  
3557 32 6b ee			ld (debug_mark),a  
355a 3a 69 35			ld a, (.dmark+1)  
355d 32 6c ee			ld (debug_mark+1),a  
3560 3a 6a 35			ld a, (.dmark+2)  
3563 32 6d ee			ld (debug_mark+2),a  
3566 18 03			jr .pastdmark  
3568 ..			.dmark: db "IS."  
356b f1			.pastdmark: pop af  
356c			endm  
# End of macro DMARK
356c						CALLMONITOR 
356c cd 6f ee			call debug_vector  
356f				endm  
# End of macro CALLMONITOR
356f					endif 
356f					NEXTW 
356f c3 ff 1f			jp macro_next 
3572				endm 
# End of macro NEXTW
3572			.LZERO: 
3572				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3572 2d				db WORD_SYS_CORE+25             
3573 7c 35			dw .TZERO            
3575 03				db 2 + 1 
3576 .. 00			db "0<",0              
3579				endm 
# End of macro CWHEAD
3579			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3579					NEXTW 
3579 c3 ff 1f			jp macro_next 
357c				endm 
# End of macro NEXTW
357c			.TZERO: 
357c				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
357c 2e				db WORD_SYS_CORE+26             
357d c3 35			dw .LESS            
357f 03				db 2 + 1 
3580 .. 00			db "0=",0              
3583				endm 
# End of macro CWHEAD
3583			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3583				; TODO add floating point number detection 
3583					;v5 FORTH_DSP_VALUE 
3583					if DEBUG_FORTH_WORDS_KEY 
3583						DMARK "0=." 
3583 f5				push af  
3584 3a 98 35			ld a, (.dmark)  
3587 32 6b ee			ld (debug_mark),a  
358a 3a 99 35			ld a, (.dmark+1)  
358d 32 6c ee			ld (debug_mark+1),a  
3590 3a 9a 35			ld a, (.dmark+2)  
3593 32 6d ee			ld (debug_mark+2),a  
3596 18 03			jr .pastdmark  
3598 ..			.dmark: db "0=."  
359b f1			.pastdmark: pop af  
359c			endm  
# End of macro DMARK
359c						CALLMONITOR 
359c cd 6f ee			call debug_vector  
359f				endm  
# End of macro CALLMONITOR
359f					endif 
359f					FORTH_DSP 
359f cd 0f 1e			call macro_forth_dsp 
35a2				endm 
# End of macro FORTH_DSP
35a2 7e					ld a,(hl)	; get type of value on TOS 
35a3 fe 02				cp DS_TYPE_INUM  
35a5 28 00				jr z, .tz_inum 
35a7			 
35a7				if FORTH_ENABLE_FLOATMATH 
35a7					jr .tz_done 
35a7			 
35a7				endif 
35a7					 
35a7			 
35a7			.tz_inum: 
35a7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35a7 cd 49 1e			call macro_dsp_valuehl 
35aa				endm 
# End of macro FORTH_DSP_VALUEHL
35aa			 
35aa			;		push hl 
35aa			 
35aa					; destroy value TOS 
35aa			 
35aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35aa cd 01 1f			call macro_forth_dsp_pop 
35ad				endm 
# End of macro FORTH_DSP_POP
35ad			 
35ad			;		pop hl 
35ad			 
35ad 3e 00				ld a,0 
35af			 
35af bd					cp l 
35b0 20 08				jr nz, .tz_notzero 
35b2			 
35b2 bc					cp h 
35b3			 
35b3 20 05				jr nz, .tz_notzero 
35b5			 
35b5			 
35b5 21 01 00				ld hl, FORTH_TRUE 
35b8 18 03				jr .tz_done 
35ba			 
35ba 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
35bd			 
35bd					; push value back onto stack for another op etc 
35bd			 
35bd			.tz_done: 
35bd cd 52 1c				call forth_push_numhl 
35c0			 
35c0					NEXTW 
35c0 c3 ff 1f			jp macro_next 
35c3				endm 
# End of macro NEXTW
35c3			.LESS: 
35c3				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
35c3 2f				db WORD_SYS_CORE+27             
35c4 2c 36			dw .GT            
35c6 02				db 1 + 1 
35c7 .. 00			db "<",0              
35c9				endm 
# End of macro CWHEAD
35c9			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
35c9				; TODO add floating point number detection 
35c9					if DEBUG_FORTH_WORDS_KEY 
35c9						DMARK "LES" 
35c9 f5				push af  
35ca 3a de 35			ld a, (.dmark)  
35cd 32 6b ee			ld (debug_mark),a  
35d0 3a df 35			ld a, (.dmark+1)  
35d3 32 6c ee			ld (debug_mark+1),a  
35d6 3a e0 35			ld a, (.dmark+2)  
35d9 32 6d ee			ld (debug_mark+2),a  
35dc 18 03			jr .pastdmark  
35de ..			.dmark: db "LES"  
35e1 f1			.pastdmark: pop af  
35e2			endm  
# End of macro DMARK
35e2						CALLMONITOR 
35e2 cd 6f ee			call debug_vector  
35e5				endm  
# End of macro CALLMONITOR
35e5					endif 
35e5					FORTH_DSP 
35e5 cd 0f 1e			call macro_forth_dsp 
35e8				endm 
# End of macro FORTH_DSP
35e8					;v5 FORTH_DSP_VALUE 
35e8 7e					ld a,(hl)	; get type of value on TOS 
35e9 fe 02				cp DS_TYPE_INUM  
35eb 28 00				jr z, .less_inum 
35ed			 
35ed				if FORTH_ENABLE_FLOATMATH 
35ed					jr .less_done 
35ed			 
35ed				endif 
35ed					 
35ed			 
35ed			.less_inum: 
35ed					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35ed cd 49 1e			call macro_dsp_valuehl 
35f0				endm 
# End of macro FORTH_DSP_VALUEHL
35f0			 
35f0 e5					push hl  ; u2 
35f1			 
35f1					; destroy value TOS 
35f1			 
35f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35f1 cd 01 1f			call macro_forth_dsp_pop 
35f4				endm 
# End of macro FORTH_DSP_POP
35f4			 
35f4			 
35f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35f4 cd 49 1e			call macro_dsp_valuehl 
35f7				endm 
# End of macro FORTH_DSP_VALUEHL
35f7			 
35f7 e5					push hl    ; u1 
35f8			 
35f8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35f8 cd 01 1f			call macro_forth_dsp_pop 
35fb				endm 
# End of macro FORTH_DSP_POP
35fb			 
35fb			 
35fb b7			 or a      ;clear carry flag 
35fc 01 00 00		 ld bc, FORTH_FALSE 
35ff e1			  pop hl    ; u1 
3600 d1			  pop de    ; u2 
3601 ed 52		  sbc hl,de 
3603 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3605			 
3605 01 01 00		 ld bc, FORTH_TRUE 
3608			.lscont:  
3608 c5					push bc 
3609 e1					pop hl 
360a			 
360a					if DEBUG_FORTH_WORDS 
360a						DMARK "LT1" 
360a f5				push af  
360b 3a 1f 36			ld a, (.dmark)  
360e 32 6b ee			ld (debug_mark),a  
3611 3a 20 36			ld a, (.dmark+1)  
3614 32 6c ee			ld (debug_mark+1),a  
3617 3a 21 36			ld a, (.dmark+2)  
361a 32 6d ee			ld (debug_mark+2),a  
361d 18 03			jr .pastdmark  
361f ..			.dmark: db "LT1"  
3622 f1			.pastdmark: pop af  
3623			endm  
# End of macro DMARK
3623						CALLMONITOR 
3623 cd 6f ee			call debug_vector  
3626				endm  
# End of macro CALLMONITOR
3626					endif 
3626 cd 52 1c				call forth_push_numhl 
3629			 
3629					NEXTW 
3629 c3 ff 1f			jp macro_next 
362c				endm 
# End of macro NEXTW
362c			.GT: 
362c				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
362c 30				db WORD_SYS_CORE+28             
362d 95 36			dw .EQUAL            
362f 02				db 1 + 1 
3630 .. 00			db ">",0              
3632				endm 
# End of macro CWHEAD
3632			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3632				; TODO add floating point number detection 
3632					if DEBUG_FORTH_WORDS_KEY 
3632						DMARK "GRT" 
3632 f5				push af  
3633 3a 47 36			ld a, (.dmark)  
3636 32 6b ee			ld (debug_mark),a  
3639 3a 48 36			ld a, (.dmark+1)  
363c 32 6c ee			ld (debug_mark+1),a  
363f 3a 49 36			ld a, (.dmark+2)  
3642 32 6d ee			ld (debug_mark+2),a  
3645 18 03			jr .pastdmark  
3647 ..			.dmark: db "GRT"  
364a f1			.pastdmark: pop af  
364b			endm  
# End of macro DMARK
364b						CALLMONITOR 
364b cd 6f ee			call debug_vector  
364e				endm  
# End of macro CALLMONITOR
364e					endif 
364e					FORTH_DSP 
364e cd 0f 1e			call macro_forth_dsp 
3651				endm 
# End of macro FORTH_DSP
3651					;FORTH_DSP_VALUE 
3651 7e					ld a,(hl)	; get type of value on TOS 
3652 fe 02				cp DS_TYPE_INUM  
3654 28 00				jr z, .gt_inum 
3656			 
3656				if FORTH_ENABLE_FLOATMATH 
3656					jr .gt_done 
3656			 
3656				endif 
3656					 
3656			 
3656			.gt_inum: 
3656					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3656 cd 49 1e			call macro_dsp_valuehl 
3659				endm 
# End of macro FORTH_DSP_VALUEHL
3659			 
3659 e5					push hl  ; u2 
365a			 
365a					; destroy value TOS 
365a			 
365a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
365a cd 01 1f			call macro_forth_dsp_pop 
365d				endm 
# End of macro FORTH_DSP_POP
365d			 
365d			 
365d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
365d cd 49 1e			call macro_dsp_valuehl 
3660				endm 
# End of macro FORTH_DSP_VALUEHL
3660			 
3660 e5					push hl    ; u1 
3661			 
3661					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3661 cd 01 1f			call macro_forth_dsp_pop 
3664				endm 
# End of macro FORTH_DSP_POP
3664			 
3664			 
3664 b7			 or a      ;clear carry flag 
3665 01 00 00		 ld bc, FORTH_FALSE 
3668 e1			  pop hl    ; u1 
3669 d1			  pop de    ; u2 
366a ed 52		  sbc hl,de 
366c 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
366e			 
366e 01 01 00		 ld bc, FORTH_TRUE 
3671			.gtcont:  
3671 c5					push bc 
3672 e1					pop hl 
3673			 
3673					if DEBUG_FORTH_WORDS 
3673						DMARK "GT1" 
3673 f5				push af  
3674 3a 88 36			ld a, (.dmark)  
3677 32 6b ee			ld (debug_mark),a  
367a 3a 89 36			ld a, (.dmark+1)  
367d 32 6c ee			ld (debug_mark+1),a  
3680 3a 8a 36			ld a, (.dmark+2)  
3683 32 6d ee			ld (debug_mark+2),a  
3686 18 03			jr .pastdmark  
3688 ..			.dmark: db "GT1"  
368b f1			.pastdmark: pop af  
368c			endm  
# End of macro DMARK
368c						CALLMONITOR 
368c cd 6f ee			call debug_vector  
368f				endm  
# End of macro CALLMONITOR
368f					endif 
368f cd 52 1c				call forth_push_numhl 
3692			 
3692					NEXTW 
3692 c3 ff 1f			jp macro_next 
3695				endm 
# End of macro NEXTW
3695			.EQUAL: 
3695				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3695 31				db WORD_SYS_CORE+29             
3696 00 37			dw .ENDLOGIC            
3698 02				db 1 + 1 
3699 .. 00			db "=",0              
369b				endm 
# End of macro CWHEAD
369b			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
369b				; TODO add floating point number detection 
369b					if DEBUG_FORTH_WORDS_KEY 
369b						DMARK "EQ." 
369b f5				push af  
369c 3a b0 36			ld a, (.dmark)  
369f 32 6b ee			ld (debug_mark),a  
36a2 3a b1 36			ld a, (.dmark+1)  
36a5 32 6c ee			ld (debug_mark+1),a  
36a8 3a b2 36			ld a, (.dmark+2)  
36ab 32 6d ee			ld (debug_mark+2),a  
36ae 18 03			jr .pastdmark  
36b0 ..			.dmark: db "EQ."  
36b3 f1			.pastdmark: pop af  
36b4			endm  
# End of macro DMARK
36b4						CALLMONITOR 
36b4 cd 6f ee			call debug_vector  
36b7				endm  
# End of macro CALLMONITOR
36b7					endif 
36b7					FORTH_DSP 
36b7 cd 0f 1e			call macro_forth_dsp 
36ba				endm 
# End of macro FORTH_DSP
36ba					;v5 FORTH_DSP_VALUE 
36ba 7e					ld a,(hl)	; get type of value on TOS 
36bb fe 02				cp DS_TYPE_INUM  
36bd 28 00				jr z, .eq_inum 
36bf			 
36bf				if FORTH_ENABLE_FLOATMATH 
36bf					jr .eq_done 
36bf			 
36bf				endif 
36bf					 
36bf			 
36bf			.eq_inum: 
36bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36bf cd 49 1e			call macro_dsp_valuehl 
36c2				endm 
# End of macro FORTH_DSP_VALUEHL
36c2			 
36c2 e5					push hl 
36c3			 
36c3					; destroy value TOS 
36c3			 
36c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36c3 cd 01 1f			call macro_forth_dsp_pop 
36c6				endm 
# End of macro FORTH_DSP_POP
36c6			 
36c6			 
36c6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36c6 cd 49 1e			call macro_dsp_valuehl 
36c9				endm 
# End of macro FORTH_DSP_VALUEHL
36c9			 
36c9					; one value on hl get other one back 
36c9			 
36c9 e5					push hl 
36ca			 
36ca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36ca cd 01 1f			call macro_forth_dsp_pop 
36cd				endm 
# End of macro FORTH_DSP_POP
36cd			 
36cd 0e 00				ld c, FORTH_FALSE 
36cf			 
36cf e1					pop hl 
36d0 d1					pop de 
36d1			 
36d1 7b					ld a, e 
36d2 bd					cp l 
36d3			 
36d3 20 06				jr nz, .eq_done 
36d5			 
36d5 7a					ld a, d 
36d6 bc					cp h 
36d7			 
36d7 20 02				jr nz, .eq_done 
36d9			 
36d9 0e 01				ld c, FORTH_TRUE 
36db					 
36db			 
36db			 
36db			.eq_done: 
36db			 
36db					; TODO push value back onto stack for another op etc 
36db			 
36db 26 00				ld h, 0 
36dd 69					ld l, c 
36de					if DEBUG_FORTH_WORDS 
36de						DMARK "EQ1" 
36de f5				push af  
36df 3a f3 36			ld a, (.dmark)  
36e2 32 6b ee			ld (debug_mark),a  
36e5 3a f4 36			ld a, (.dmark+1)  
36e8 32 6c ee			ld (debug_mark+1),a  
36eb 3a f5 36			ld a, (.dmark+2)  
36ee 32 6d ee			ld (debug_mark+2),a  
36f1 18 03			jr .pastdmark  
36f3 ..			.dmark: db "EQ1"  
36f6 f1			.pastdmark: pop af  
36f7			endm  
# End of macro DMARK
36f7						CALLMONITOR 
36f7 cd 6f ee			call debug_vector  
36fa				endm  
# End of macro CALLMONITOR
36fa					endif 
36fa cd 52 1c				call forth_push_numhl 
36fd			 
36fd					NEXTW 
36fd c3 ff 1f			jp macro_next 
3700				endm 
# End of macro NEXTW
3700			 
3700			 
3700			.ENDLOGIC: 
3700			; eof 
3700			 
3700			 
# End of file forth_words_logic.asm
3700			include "forth_words_maths.asm" 
3700			 
3700			; | ## Maths Words 
3700			 
3700			.PLUS:	 
3700				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3700 15				db WORD_SYS_CORE+1             
3701 5e 37			dw .NEG            
3703 02				db 1 + 1 
3704 .. 00			db "+",0              
3706				endm 
# End of macro CWHEAD
3706			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3706					if DEBUG_FORTH_WORDS_KEY 
3706						DMARK "PLU" 
3706 f5				push af  
3707 3a 1b 37			ld a, (.dmark)  
370a 32 6b ee			ld (debug_mark),a  
370d 3a 1c 37			ld a, (.dmark+1)  
3710 32 6c ee			ld (debug_mark+1),a  
3713 3a 1d 37			ld a, (.dmark+2)  
3716 32 6d ee			ld (debug_mark+2),a  
3719 18 03			jr .pastdmark  
371b ..			.dmark: db "PLU"  
371e f1			.pastdmark: pop af  
371f			endm  
# End of macro DMARK
371f						CALLMONITOR 
371f cd 6f ee			call debug_vector  
3722				endm  
# End of macro CALLMONITOR
3722					endif 
3722					; add top two values and push back result 
3722			 
3722					;for v5 FORTH_DSP_VALUE 
3722					FORTH_DSP 
3722 cd 0f 1e			call macro_forth_dsp 
3725				endm 
# End of macro FORTH_DSP
3725 7e					ld a,(hl)	; get type of value on TOS 
3726 fe 02				cp DS_TYPE_INUM  
3728 28 03				jr z, .dot_inum 
372a			 
372a					NEXTW 
372a c3 ff 1f			jp macro_next 
372d				endm 
# End of macro NEXTW
372d			 
372d			; float maths 
372d			 
372d				if FORTH_ENABLE_FLOATMATH 
372d						inc hl      ; now at start of numeric as string 
372d			 
372d					if DEBUG_FORTH_MATHS 
372d						DMARK "ADD" 
372d				CALLMONITOR 
372d					endif 
372d			 
372d					;ld ix, hl 
372d					call CON 
372d			 
372d			 
372d					push hl 
372d					 
372d					 
372d			 
372d						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
372d			 
372d					; get next number 
372d			 
372d						FORTH_DSP_VALUE 
372d			 
372d						inc hl      ; now at start of numeric as string 
372d			 
372d					;ld ix, hl 
372d					call CON 
372d			 
372d					push hl 
372d			 
372d			 
372d						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
372d			 
372d						; TODO do add 
372d			 
372d						call IADD 
372d			 
372d						; TODO get result back as ascii 
372d			 
372d						; TODO push result  
372d			 
372d			 
372d			 
372d						jr .dot_done 
372d				endif 
372d			 
372d			.dot_inum: 
372d			 
372d			 
372d					if DEBUG_FORTH_DOT 
372d						DMARK "+IT" 
372d f5				push af  
372e 3a 42 37			ld a, (.dmark)  
3731 32 6b ee			ld (debug_mark),a  
3734 3a 43 37			ld a, (.dmark+1)  
3737 32 6c ee			ld (debug_mark+1),a  
373a 3a 44 37			ld a, (.dmark+2)  
373d 32 6d ee			ld (debug_mark+2),a  
3740 18 03			jr .pastdmark  
3742 ..			.dmark: db "+IT"  
3745 f1			.pastdmark: pop af  
3746			endm  
# End of macro DMARK
3746				CALLMONITOR 
3746 cd 6f ee			call debug_vector  
3749				endm  
# End of macro CALLMONITOR
3749					endif 
3749			 
3749					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3749 cd 49 1e			call macro_dsp_valuehl 
374c				endm 
# End of macro FORTH_DSP_VALUEHL
374c			 
374c				; TODO add floating point number detection 
374c			 
374c e5					push hl 
374d			 
374d					; destroy value TOS 
374d			 
374d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
374d cd 01 1f			call macro_forth_dsp_pop 
3750				endm 
# End of macro FORTH_DSP_POP
3750			 
3750			 
3750					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3750 cd 49 1e			call macro_dsp_valuehl 
3753				endm 
# End of macro FORTH_DSP_VALUEHL
3753			 
3753					; one value on hl get other one back 
3753			 
3753 d1					pop de 
3754			 
3754					; do the add 
3754			 
3754 19					add hl,de 
3755			 
3755					; save it 
3755			 
3755			;		push hl	 
3755			 
3755					; 
3755			 
3755					; destroy value TOS 
3755			 
3755					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3755 cd 01 1f			call macro_forth_dsp_pop 
3758				endm 
# End of macro FORTH_DSP_POP
3758			 
3758					; TODO push value back onto stack for another op etc 
3758			 
3758			;		pop hl 
3758			 
3758			.dot_done: 
3758 cd 52 1c				call forth_push_numhl 
375b			 
375b					NEXTW 
375b c3 ff 1f			jp macro_next 
375e				endm 
# End of macro NEXTW
375e			.NEG: 
375e			 
375e				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
375e 17				db WORD_SYS_CORE+3             
375f a1 37			dw .DIV            
3761 02				db 1 + 1 
3762 .. 00			db "-",0              
3764				endm 
# End of macro CWHEAD
3764			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3764					if DEBUG_FORTH_WORDS_KEY 
3764						DMARK "SUB" 
3764 f5				push af  
3765 3a 79 37			ld a, (.dmark)  
3768 32 6b ee			ld (debug_mark),a  
376b 3a 7a 37			ld a, (.dmark+1)  
376e 32 6c ee			ld (debug_mark+1),a  
3771 3a 7b 37			ld a, (.dmark+2)  
3774 32 6d ee			ld (debug_mark+2),a  
3777 18 03			jr .pastdmark  
3779 ..			.dmark: db "SUB"  
377c f1			.pastdmark: pop af  
377d			endm  
# End of macro DMARK
377d						CALLMONITOR 
377d cd 6f ee			call debug_vector  
3780				endm  
# End of macro CALLMONITOR
3780					endif 
3780			 
3780			 
3780				; TODO add floating point number detection 
3780					; v5 FORTH_DSP_VALUE 
3780					FORTH_DSP 
3780 cd 0f 1e			call macro_forth_dsp 
3783				endm 
# End of macro FORTH_DSP
3783 7e					ld a,(hl)	; get type of value on TOS 
3784 fe 02				cp DS_TYPE_INUM  
3786 28 03				jr z, .neg_inum 
3788			 
3788					NEXTW 
3788 c3 ff 1f			jp macro_next 
378b				endm 
# End of macro NEXTW
378b			 
378b			; float maths 
378b			 
378b				if FORTH_ENABLE_FLOATMATH 
378b					jr .neg_done 
378b			 
378b				endif 
378b					 
378b			 
378b			.neg_inum: 
378b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
378b cd 49 1e			call macro_dsp_valuehl 
378e				endm 
# End of macro FORTH_DSP_VALUEHL
378e			 
378e e5					push hl 
378f			 
378f					; destroy value TOS 
378f			 
378f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
378f cd 01 1f			call macro_forth_dsp_pop 
3792				endm 
# End of macro FORTH_DSP_POP
3792			 
3792			 
3792					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3792 cd 49 1e			call macro_dsp_valuehl 
3795				endm 
# End of macro FORTH_DSP_VALUEHL
3795			 
3795					; one value on hl get other one back 
3795			 
3795 d1					pop de 
3796			 
3796					; do the sub 
3796			;		ex de, hl 
3796			 
3796 ed 52				sbc hl,de 
3798			 
3798					; save it 
3798			 
3798			;		push hl	 
3798			 
3798					; 
3798			 
3798					; destroy value TOS 
3798			 
3798					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3798 cd 01 1f			call macro_forth_dsp_pop 
379b				endm 
# End of macro FORTH_DSP_POP
379b			 
379b					; TODO push value back onto stack for another op etc 
379b			 
379b			;		pop hl 
379b			 
379b cd 52 1c				call forth_push_numhl 
379e			.neg_done: 
379e			 
379e					NEXTW 
379e c3 ff 1f			jp macro_next 
37a1				endm 
# End of macro NEXTW
37a1			.DIV: 
37a1				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
37a1 18				db WORD_SYS_CORE+4             
37a2 ee 37			dw .MUL            
37a4 02				db 1 + 1 
37a5 .. 00			db "/",0              
37a7				endm 
# End of macro CWHEAD
37a7			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
37a7					if DEBUG_FORTH_WORDS_KEY 
37a7						DMARK "DIV" 
37a7 f5				push af  
37a8 3a bc 37			ld a, (.dmark)  
37ab 32 6b ee			ld (debug_mark),a  
37ae 3a bd 37			ld a, (.dmark+1)  
37b1 32 6c ee			ld (debug_mark+1),a  
37b4 3a be 37			ld a, (.dmark+2)  
37b7 32 6d ee			ld (debug_mark+2),a  
37ba 18 03			jr .pastdmark  
37bc ..			.dmark: db "DIV"  
37bf f1			.pastdmark: pop af  
37c0			endm  
# End of macro DMARK
37c0						CALLMONITOR 
37c0 cd 6f ee			call debug_vector  
37c3				endm  
# End of macro CALLMONITOR
37c3					endif 
37c3				; TODO add floating point number detection 
37c3					; v5 FORTH_DSP_VALUE 
37c3					FORTH_DSP 
37c3 cd 0f 1e			call macro_forth_dsp 
37c6				endm 
# End of macro FORTH_DSP
37c6 7e					ld a,(hl)	; get type of value on TOS 
37c7 fe 02				cp DS_TYPE_INUM  
37c9 28 03				jr z, .div_inum 
37cb			 
37cb				if FORTH_ENABLE_FLOATMATH 
37cb					jr .div_done 
37cb			 
37cb				endif 
37cb					NEXTW 
37cb c3 ff 1f			jp macro_next 
37ce				endm 
# End of macro NEXTW
37ce			.div_inum: 
37ce			 
37ce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37ce cd 49 1e			call macro_dsp_valuehl 
37d1				endm 
# End of macro FORTH_DSP_VALUEHL
37d1			 
37d1 e5					push hl    ; to go to bc 
37d2			 
37d2					; destroy value TOS 
37d2			 
37d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37d2 cd 01 1f			call macro_forth_dsp_pop 
37d5				endm 
# End of macro FORTH_DSP_POP
37d5			 
37d5			 
37d5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37d5 cd 49 1e			call macro_dsp_valuehl 
37d8				endm 
# End of macro FORTH_DSP_VALUEHL
37d8			 
37d8					; hl to go to de 
37d8			 
37d8 e5					push hl 
37d9			 
37d9 c1					pop bc 
37da d1					pop de		 
37db			 
37db			 
37db					if DEBUG_FORTH_MATHS 
37db						DMARK "DIV" 
37db				CALLMONITOR 
37db					endif 
37db					; one value on hl but move to a get other one back 
37db			 
37db			        
37db cd 43 0d			call Div16 
37de			 
37de			;	push af	 
37de e5				push hl 
37df c5				push bc 
37e0			 
37e0					if DEBUG_FORTH_MATHS 
37e0						DMARK "DI1" 
37e0				CALLMONITOR 
37e0					endif 
37e0			 
37e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37e0 cd 01 1f			call macro_forth_dsp_pop 
37e3				endm 
# End of macro FORTH_DSP_POP
37e3			 
37e3			 
37e3			 
37e3 e1					pop hl    ; result 
37e4			 
37e4 cd 52 1c				call forth_push_numhl 
37e7			 
37e7 e1					pop hl    ; reminder 
37e8			;		ld h,0 
37e8			;		ld l,d 
37e8			 
37e8 cd 52 1c				call forth_push_numhl 
37eb			.div_done: 
37eb					NEXTW 
37eb c3 ff 1f			jp macro_next 
37ee				endm 
# End of macro NEXTW
37ee			.MUL: 
37ee				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
37ee 19				db WORD_SYS_CORE+5             
37ef 33 38			dw .MIN            
37f1 02				db 1 + 1 
37f2 .. 00			db "*",0              
37f4				endm 
# End of macro CWHEAD
37f4			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
37f4				; TODO add floating point number detection 
37f4					if DEBUG_FORTH_WORDS_KEY 
37f4						DMARK "MUL" 
37f4 f5				push af  
37f5 3a 09 38			ld a, (.dmark)  
37f8 32 6b ee			ld (debug_mark),a  
37fb 3a 0a 38			ld a, (.dmark+1)  
37fe 32 6c ee			ld (debug_mark+1),a  
3801 3a 0b 38			ld a, (.dmark+2)  
3804 32 6d ee			ld (debug_mark+2),a  
3807 18 03			jr .pastdmark  
3809 ..			.dmark: db "MUL"  
380c f1			.pastdmark: pop af  
380d			endm  
# End of macro DMARK
380d						CALLMONITOR 
380d cd 6f ee			call debug_vector  
3810				endm  
# End of macro CALLMONITOR
3810					endif 
3810					FORTH_DSP 
3810 cd 0f 1e			call macro_forth_dsp 
3813				endm 
# End of macro FORTH_DSP
3813					; v5 FORTH_DSP_VALUE 
3813 7e					ld a,(hl)	; get type of value on TOS 
3814 fe 02				cp DS_TYPE_INUM  
3816 28 03				jr z, .mul_inum 
3818			 
3818				if FORTH_ENABLE_FLOATMATH 
3818					jr .mul_done 
3818			 
3818				endif 
3818			 
3818					NEXTW 
3818 c3 ff 1f			jp macro_next 
381b				endm 
# End of macro NEXTW
381b			.mul_inum:	 
381b			 
381b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
381b cd 49 1e			call macro_dsp_valuehl 
381e				endm 
# End of macro FORTH_DSP_VALUEHL
381e			 
381e e5					push hl 
381f			 
381f					; destroy value TOS 
381f			 
381f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
381f cd 01 1f			call macro_forth_dsp_pop 
3822				endm 
# End of macro FORTH_DSP_POP
3822			 
3822			 
3822					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3822 cd 49 1e			call macro_dsp_valuehl 
3825				endm 
# End of macro FORTH_DSP_VALUEHL
3825			 
3825					; one value on hl but move to a get other one back 
3825			 
3825 7d					ld a, l 
3826			 
3826 d1					pop de 
3827			 
3827					; do the mull 
3827			;		ex de, hl 
3827			 
3827 cd 69 0d				call Mult16 
382a					; save it 
382a			 
382a			;		push hl	 
382a			 
382a					; 
382a			 
382a					; destroy value TOS 
382a			 
382a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
382a cd 01 1f			call macro_forth_dsp_pop 
382d				endm 
# End of macro FORTH_DSP_POP
382d			 
382d					; TODO push value back onto stack for another op etc 
382d			 
382d			;		pop hl 
382d			 
382d cd 52 1c				call forth_push_numhl 
3830			 
3830			.mul_done: 
3830					NEXTW 
3830 c3 ff 1f			jp macro_next 
3833				endm 
# End of macro NEXTW
3833			 
3833			 
3833			 
3833			 
3833			.MIN: 
3833				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3833 49				db WORD_SYS_CORE+53             
3834 b4 38			dw .MAX            
3836 04				db 3 + 1 
3837 .. 00			db "MIN",0              
383b				endm 
# End of macro CWHEAD
383b			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
383b					if DEBUG_FORTH_WORDS_KEY 
383b						DMARK "MIN" 
383b f5				push af  
383c 3a 50 38			ld a, (.dmark)  
383f 32 6b ee			ld (debug_mark),a  
3842 3a 51 38			ld a, (.dmark+1)  
3845 32 6c ee			ld (debug_mark+1),a  
3848 3a 52 38			ld a, (.dmark+2)  
384b 32 6d ee			ld (debug_mark+2),a  
384e 18 03			jr .pastdmark  
3850 ..			.dmark: db "MIN"  
3853 f1			.pastdmark: pop af  
3854			endm  
# End of macro DMARK
3854						CALLMONITOR 
3854 cd 6f ee			call debug_vector  
3857				endm  
# End of macro CALLMONITOR
3857					endif 
3857					; get u2 
3857			 
3857					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3857 cd 49 1e			call macro_dsp_valuehl 
385a				endm 
# End of macro FORTH_DSP_VALUEHL
385a			 
385a e5					push hl   ; u2 
385b			 
385b					; destroy value TOS 
385b			 
385b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
385b cd 01 1f			call macro_forth_dsp_pop 
385e				endm 
# End of macro FORTH_DSP_POP
385e			 
385e					; get u1 
385e			 
385e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
385e cd 49 1e			call macro_dsp_valuehl 
3861				endm 
# End of macro FORTH_DSP_VALUEHL
3861			 
3861 e5					push hl  ; u1 
3862			 
3862					; destroy value TOS 
3862			 
3862					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3862 cd 01 1f			call macro_forth_dsp_pop 
3865				endm 
# End of macro FORTH_DSP_POP
3865			 
3865 b7			 or a      ;clear carry flag 
3866 e1			  pop hl    ; u1 
3867 d1			  pop de    ; u2 
3868 e5				push hl   ; saved in case hl is lowest 
3869 ed 52		  sbc hl,de 
386b 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
386d			 
386d e1				pop hl 
386e					if DEBUG_FORTH_WORDS 
386e						DMARK "MIN" 
386e f5				push af  
386f 3a 83 38			ld a, (.dmark)  
3872 32 6b ee			ld (debug_mark),a  
3875 3a 84 38			ld a, (.dmark+1)  
3878 32 6c ee			ld (debug_mark+1),a  
387b 3a 85 38			ld a, (.dmark+2)  
387e 32 6d ee			ld (debug_mark+2),a  
3881 18 03			jr .pastdmark  
3883 ..			.dmark: db "MIN"  
3886 f1			.pastdmark: pop af  
3887			endm  
# End of macro DMARK
3887						CALLMONITOR 
3887 cd 6f ee			call debug_vector  
388a				endm  
# End of macro CALLMONITOR
388a					endif 
388a cd 52 1c				call forth_push_numhl 
388d			 
388d				       NEXTW 
388d c3 ff 1f			jp macro_next 
3890				endm 
# End of macro NEXTW
3890			 
3890			.mincont:  
3890 c1				pop bc   ; tidy up 
3891 eb				ex de , hl  
3892					if DEBUG_FORTH_WORDS 
3892						DMARK "MI1" 
3892 f5				push af  
3893 3a a7 38			ld a, (.dmark)  
3896 32 6b ee			ld (debug_mark),a  
3899 3a a8 38			ld a, (.dmark+1)  
389c 32 6c ee			ld (debug_mark+1),a  
389f 3a a9 38			ld a, (.dmark+2)  
38a2 32 6d ee			ld (debug_mark+2),a  
38a5 18 03			jr .pastdmark  
38a7 ..			.dmark: db "MI1"  
38aa f1			.pastdmark: pop af  
38ab			endm  
# End of macro DMARK
38ab						CALLMONITOR 
38ab cd 6f ee			call debug_vector  
38ae				endm  
# End of macro CALLMONITOR
38ae					endif 
38ae cd 52 1c				call forth_push_numhl 
38b1			 
38b1				       NEXTW 
38b1 c3 ff 1f			jp macro_next 
38b4				endm 
# End of macro NEXTW
38b4			.MAX: 
38b4				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
38b4 4a				db WORD_SYS_CORE+54             
38b5 35 39			dw .RND16            
38b7 04				db 3 + 1 
38b8 .. 00			db "MAX",0              
38bc				endm 
# End of macro CWHEAD
38bc			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
38bc					if DEBUG_FORTH_WORDS_KEY 
38bc						DMARK "MAX" 
38bc f5				push af  
38bd 3a d1 38			ld a, (.dmark)  
38c0 32 6b ee			ld (debug_mark),a  
38c3 3a d2 38			ld a, (.dmark+1)  
38c6 32 6c ee			ld (debug_mark+1),a  
38c9 3a d3 38			ld a, (.dmark+2)  
38cc 32 6d ee			ld (debug_mark+2),a  
38cf 18 03			jr .pastdmark  
38d1 ..			.dmark: db "MAX"  
38d4 f1			.pastdmark: pop af  
38d5			endm  
# End of macro DMARK
38d5						CALLMONITOR 
38d5 cd 6f ee			call debug_vector  
38d8				endm  
# End of macro CALLMONITOR
38d8					endif 
38d8					; get u2 
38d8			 
38d8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38d8 cd 49 1e			call macro_dsp_valuehl 
38db				endm 
# End of macro FORTH_DSP_VALUEHL
38db			 
38db e5					push hl   ; u2 
38dc			 
38dc					; destroy value TOS 
38dc			 
38dc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38dc cd 01 1f			call macro_forth_dsp_pop 
38df				endm 
# End of macro FORTH_DSP_POP
38df			 
38df					; get u1 
38df			 
38df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38df cd 49 1e			call macro_dsp_valuehl 
38e2				endm 
# End of macro FORTH_DSP_VALUEHL
38e2			 
38e2 e5					push hl  ; u1 
38e3			 
38e3					; destroy value TOS 
38e3			 
38e3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38e3 cd 01 1f			call macro_forth_dsp_pop 
38e6				endm 
# End of macro FORTH_DSP_POP
38e6			 
38e6 b7			 or a      ;clear carry flag 
38e7 e1			  pop hl    ; u1 
38e8 d1			  pop de    ; u2 
38e9 e5				push hl   ; saved in case hl is lowest 
38ea ed 52		  sbc hl,de 
38ec 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
38ee			 
38ee e1				pop hl 
38ef					if DEBUG_FORTH_WORDS 
38ef						DMARK "MAX" 
38ef f5				push af  
38f0 3a 04 39			ld a, (.dmark)  
38f3 32 6b ee			ld (debug_mark),a  
38f6 3a 05 39			ld a, (.dmark+1)  
38f9 32 6c ee			ld (debug_mark+1),a  
38fc 3a 06 39			ld a, (.dmark+2)  
38ff 32 6d ee			ld (debug_mark+2),a  
3902 18 03			jr .pastdmark  
3904 ..			.dmark: db "MAX"  
3907 f1			.pastdmark: pop af  
3908			endm  
# End of macro DMARK
3908						CALLMONITOR 
3908 cd 6f ee			call debug_vector  
390b				endm  
# End of macro CALLMONITOR
390b					endif 
390b cd 52 1c				call forth_push_numhl 
390e			 
390e				       NEXTW 
390e c3 ff 1f			jp macro_next 
3911				endm 
# End of macro NEXTW
3911			 
3911			.maxcont:  
3911 c1				pop bc   ; tidy up 
3912 eb				ex de , hl  
3913					if DEBUG_FORTH_WORDS 
3913						DMARK "MA1" 
3913 f5				push af  
3914 3a 28 39			ld a, (.dmark)  
3917 32 6b ee			ld (debug_mark),a  
391a 3a 29 39			ld a, (.dmark+1)  
391d 32 6c ee			ld (debug_mark+1),a  
3920 3a 2a 39			ld a, (.dmark+2)  
3923 32 6d ee			ld (debug_mark+2),a  
3926 18 03			jr .pastdmark  
3928 ..			.dmark: db "MA1"  
392b f1			.pastdmark: pop af  
392c			endm  
# End of macro DMARK
392c						CALLMONITOR 
392c cd 6f ee			call debug_vector  
392f				endm  
# End of macro CALLMONITOR
392f					endif 
392f cd 52 1c				call forth_push_numhl 
3932				       NEXTW 
3932 c3 ff 1f			jp macro_next 
3935				endm 
# End of macro NEXTW
3935			 
3935			.RND16: 
3935				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3935 4e				db WORD_SYS_CORE+58             
3936 64 39			dw .RND8            
3938 06				db 5 + 1 
3939 .. 00			db "RND16",0              
393f				endm 
# End of macro CWHEAD
393f			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
393f					if DEBUG_FORTH_WORDS_KEY 
393f						DMARK "R16" 
393f f5				push af  
3940 3a 54 39			ld a, (.dmark)  
3943 32 6b ee			ld (debug_mark),a  
3946 3a 55 39			ld a, (.dmark+1)  
3949 32 6c ee			ld (debug_mark+1),a  
394c 3a 56 39			ld a, (.dmark+2)  
394f 32 6d ee			ld (debug_mark+2),a  
3952 18 03			jr .pastdmark  
3954 ..			.dmark: db "R16"  
3957 f1			.pastdmark: pop af  
3958			endm  
# End of macro DMARK
3958						CALLMONITOR 
3958 cd 6f ee			call debug_vector  
395b				endm  
# End of macro CALLMONITOR
395b					endif 
395b cd 0d 0d				call prng16  
395e cd 52 1c				call forth_push_numhl 
3961				       NEXTW 
3961 c3 ff 1f			jp macro_next 
3964				endm 
# End of macro NEXTW
3964			.RND8: 
3964				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3964 60				db WORD_SYS_CORE+76             
3965 99 39			dw .RND            
3967 05				db 4 + 1 
3968 .. 00			db "RND8",0              
396d				endm 
# End of macro CWHEAD
396d			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
396d					if DEBUG_FORTH_WORDS_KEY 
396d						DMARK "RN8" 
396d f5				push af  
396e 3a 82 39			ld a, (.dmark)  
3971 32 6b ee			ld (debug_mark),a  
3974 3a 83 39			ld a, (.dmark+1)  
3977 32 6c ee			ld (debug_mark+1),a  
397a 3a 84 39			ld a, (.dmark+2)  
397d 32 6d ee			ld (debug_mark+2),a  
3980 18 03			jr .pastdmark  
3982 ..			.dmark: db "RN8"  
3985 f1			.pastdmark: pop af  
3986			endm  
# End of macro DMARK
3986						CALLMONITOR 
3986 cd 6f ee			call debug_vector  
3989				endm  
# End of macro CALLMONITOR
3989					endif 
3989 2a a9 eb				ld hl,(xrandc) 
398c 23					inc hl 
398d cd 27 0d				call xrnd 
3990 6f					ld l,a	 
3991 26 00				ld h,0 
3993 cd 52 1c				call forth_push_numhl 
3996				       NEXTW 
3996 c3 ff 1f			jp macro_next 
3999				endm 
# End of macro NEXTW
3999			.RND: 
3999				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3999 60				db WORD_SYS_CORE+76             
399a 9f 3a			dw .ENDMATHS            
399c 04				db 3 + 1 
399d .. 00			db "RND",0              
39a1				endm 
# End of macro CWHEAD
39a1			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
39a1			 
39a1					if DEBUG_FORTH_WORDS_KEY 
39a1						DMARK "RND" 
39a1 f5				push af  
39a2 3a b6 39			ld a, (.dmark)  
39a5 32 6b ee			ld (debug_mark),a  
39a8 3a b7 39			ld a, (.dmark+1)  
39ab 32 6c ee			ld (debug_mark+1),a  
39ae 3a b8 39			ld a, (.dmark+2)  
39b1 32 6d ee			ld (debug_mark+2),a  
39b4 18 03			jr .pastdmark  
39b6 ..			.dmark: db "RND"  
39b9 f1			.pastdmark: pop af  
39ba			endm  
# End of macro DMARK
39ba						CALLMONITOR 
39ba cd 6f ee			call debug_vector  
39bd				endm  
# End of macro CALLMONITOR
39bd					endif 
39bd					 
39bd					FORTH_DSP_VALUEHL    ; upper range 
39bd cd 49 1e			call macro_dsp_valuehl 
39c0				endm 
# End of macro FORTH_DSP_VALUEHL
39c0			 
39c0 22 ad eb				ld (LFSRSeed), hl	 
39c3			 
39c3					if DEBUG_FORTH_WORDS 
39c3						DMARK "RN1" 
39c3 f5				push af  
39c4 3a d8 39			ld a, (.dmark)  
39c7 32 6b ee			ld (debug_mark),a  
39ca 3a d9 39			ld a, (.dmark+1)  
39cd 32 6c ee			ld (debug_mark+1),a  
39d0 3a da 39			ld a, (.dmark+2)  
39d3 32 6d ee			ld (debug_mark+2),a  
39d6 18 03			jr .pastdmark  
39d8 ..			.dmark: db "RN1"  
39db f1			.pastdmark: pop af  
39dc			endm  
# End of macro DMARK
39dc						CALLMONITOR 
39dc cd 6f ee			call debug_vector  
39df				endm  
# End of macro CALLMONITOR
39df					endif 
39df					FORTH_DSP_POP 
39df cd 01 1f			call macro_forth_dsp_pop 
39e2				endm 
# End of macro FORTH_DSP_POP
39e2			 
39e2					FORTH_DSP_VALUEHL    ; low range 
39e2 cd 49 1e			call macro_dsp_valuehl 
39e5				endm 
# End of macro FORTH_DSP_VALUEHL
39e5			 
39e5					if DEBUG_FORTH_WORDS 
39e5						DMARK "RN2" 
39e5 f5				push af  
39e6 3a fa 39			ld a, (.dmark)  
39e9 32 6b ee			ld (debug_mark),a  
39ec 3a fb 39			ld a, (.dmark+1)  
39ef 32 6c ee			ld (debug_mark+1),a  
39f2 3a fc 39			ld a, (.dmark+2)  
39f5 32 6d ee			ld (debug_mark+2),a  
39f8 18 03			jr .pastdmark  
39fa ..			.dmark: db "RN2"  
39fd f1			.pastdmark: pop af  
39fe			endm  
# End of macro DMARK
39fe						CALLMONITOR 
39fe cd 6f ee			call debug_vector  
3a01				endm  
# End of macro CALLMONITOR
3a01					endif 
3a01 22 af eb				ld (LFSRSeed+2), hl 
3a04			 
3a04					FORTH_DSP_POP 
3a04 cd 01 1f			call macro_forth_dsp_pop 
3a07				endm 
# End of macro FORTH_DSP_POP
3a07			 
3a07 e5					push hl 
3a08			 
3a08 e1			.inrange:	pop hl 
3a09 cd 0d 0d				call prng16  
3a0c					if DEBUG_FORTH_WORDS 
3a0c						DMARK "RN3" 
3a0c f5				push af  
3a0d 3a 21 3a			ld a, (.dmark)  
3a10 32 6b ee			ld (debug_mark),a  
3a13 3a 22 3a			ld a, (.dmark+1)  
3a16 32 6c ee			ld (debug_mark+1),a  
3a19 3a 23 3a			ld a, (.dmark+2)  
3a1c 32 6d ee			ld (debug_mark+2),a  
3a1f 18 03			jr .pastdmark  
3a21 ..			.dmark: db "RN3"  
3a24 f1			.pastdmark: pop af  
3a25			endm  
# End of macro DMARK
3a25						CALLMONITOR 
3a25 cd 6f ee			call debug_vector  
3a28				endm  
# End of macro CALLMONITOR
3a28					endif 
3a28					 
3a28					; if the range is 8bit knock out the high byte 
3a28			 
3a28 ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
3a2c			 
3a2c 3e 00				ld a, 0 
3a2e ba					cp d  
3a2f 20 1e				jr nz, .hirange 
3a31 26 00				ld h, 0   ; knock it down to 8bit 
3a33			 
3a33					if DEBUG_FORTH_WORDS 
3a33						DMARK "RNk" 
3a33 f5				push af  
3a34 3a 48 3a			ld a, (.dmark)  
3a37 32 6b ee			ld (debug_mark),a  
3a3a 3a 49 3a			ld a, (.dmark+1)  
3a3d 32 6c ee			ld (debug_mark+1),a  
3a40 3a 4a 3a			ld a, (.dmark+2)  
3a43 32 6d ee			ld (debug_mark+2),a  
3a46 18 03			jr .pastdmark  
3a48 ..			.dmark: db "RNk"  
3a4b f1			.pastdmark: pop af  
3a4c			endm  
# End of macro DMARK
3a4c						CALLMONITOR 
3a4c cd 6f ee			call debug_vector  
3a4f				endm  
# End of macro CALLMONITOR
3a4f					endif 
3a4f			.hirange:   
3a4f e5					push hl  
3a50 b7					or a  
3a51 ed 52		                sbc hl, de 
3a53			 
3a53					;call cmp16 
3a53			 
3a53 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3a55 e1					pop hl 
3a56 e5					push hl 
3a57			 
3a57					if DEBUG_FORTH_WORDS 
3a57						DMARK "RN4" 
3a57 f5				push af  
3a58 3a 6c 3a			ld a, (.dmark)  
3a5b 32 6b ee			ld (debug_mark),a  
3a5e 3a 6d 3a			ld a, (.dmark+1)  
3a61 32 6c ee			ld (debug_mark+1),a  
3a64 3a 6e 3a			ld a, (.dmark+2)  
3a67 32 6d ee			ld (debug_mark+2),a  
3a6a 18 03			jr .pastdmark  
3a6c ..			.dmark: db "RN4"  
3a6f f1			.pastdmark: pop af  
3a70			endm  
# End of macro DMARK
3a70						CALLMONITOR 
3a70 cd 6f ee			call debug_vector  
3a73				endm  
# End of macro CALLMONITOR
3a73					endif 
3a73 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
3a77					;call cmp16 
3a77				 
3a77 b7					or a  
3a78 ed 52		                sbc hl, de 
3a7a 38 8c				jr c, .inrange 
3a7c			 
3a7c e1					pop hl 
3a7d					 
3a7d					if DEBUG_FORTH_WORDS 
3a7d						DMARK "RNd" 
3a7d f5				push af  
3a7e 3a 92 3a			ld a, (.dmark)  
3a81 32 6b ee			ld (debug_mark),a  
3a84 3a 93 3a			ld a, (.dmark+1)  
3a87 32 6c ee			ld (debug_mark+1),a  
3a8a 3a 94 3a			ld a, (.dmark+2)  
3a8d 32 6d ee			ld (debug_mark+2),a  
3a90 18 03			jr .pastdmark  
3a92 ..			.dmark: db "RNd"  
3a95 f1			.pastdmark: pop af  
3a96			endm  
# End of macro DMARK
3a96						CALLMONITOR 
3a96 cd 6f ee			call debug_vector  
3a99				endm  
# End of macro CALLMONITOR
3a99					endif 
3a99			 
3a99			 
3a99 cd 52 1c				call forth_push_numhl 
3a9c				       NEXTW 
3a9c c3 ff 1f			jp macro_next 
3a9f				endm 
# End of macro NEXTW
3a9f			 
3a9f			.ENDMATHS: 
3a9f			 
3a9f			; eof 
3a9f			 
# End of file forth_words_maths.asm
3a9f			include "forth_words_display.asm" 
3a9f			 
3a9f			; | ## Display Words 
3a9f			 
3a9f			.ACT: 
3a9f			 
3a9f				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3a9f 62				db WORD_SYS_CORE+78             
3aa0 eb 3a			dw .INFO            
3aa2 07				db 6 + 1 
3aa3 .. 00			db "ACTIVE",0              
3aaa				endm 
# End of macro CWHEAD
3aaa			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3aaa			;  
3aaa			; | | To display a pulsing activity indicator in a processing loop do this... 
3aaa			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3aaa			 
3aaa					if DEBUG_FORTH_WORDS_KEY 
3aaa						DMARK "ACT" 
3aaa f5				push af  
3aab 3a bf 3a			ld a, (.dmark)  
3aae 32 6b ee			ld (debug_mark),a  
3ab1 3a c0 3a			ld a, (.dmark+1)  
3ab4 32 6c ee			ld (debug_mark+1),a  
3ab7 3a c1 3a			ld a, (.dmark+2)  
3aba 32 6d ee			ld (debug_mark+2),a  
3abd 18 03			jr .pastdmark  
3abf ..			.dmark: db "ACT"  
3ac2 f1			.pastdmark: pop af  
3ac3			endm  
# End of macro DMARK
3ac3						CALLMONITOR 
3ac3 cd 6f ee			call debug_vector  
3ac6				endm  
# End of macro CALLMONITOR
3ac6					endif 
3ac6 cd 10 0b				call active 
3ac9					if DEBUG_FORTH_WORDS 
3ac9						DMARK "ACp" 
3ac9 f5				push af  
3aca 3a de 3a			ld a, (.dmark)  
3acd 32 6b ee			ld (debug_mark),a  
3ad0 3a df 3a			ld a, (.dmark+1)  
3ad3 32 6c ee			ld (debug_mark+1),a  
3ad6 3a e0 3a			ld a, (.dmark+2)  
3ad9 32 6d ee			ld (debug_mark+2),a  
3adc 18 03			jr .pastdmark  
3ade ..			.dmark: db "ACp"  
3ae1 f1			.pastdmark: pop af  
3ae2			endm  
# End of macro DMARK
3ae2						CALLMONITOR 
3ae2 cd 6f ee			call debug_vector  
3ae5				endm  
# End of macro CALLMONITOR
3ae5					endif 
3ae5 cd c0 1c				call forth_push_str 
3ae8			 
3ae8					NEXTW 
3ae8 c3 ff 1f			jp macro_next 
3aeb				endm 
# End of macro NEXTW
3aeb			.INFO: 
3aeb			 
3aeb				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3aeb 62				db WORD_SYS_CORE+78             
3aec 08 3b			dw .ATP            
3aee 05				db 4 + 1 
3aef .. 00			db "INFO",0              
3af4				endm 
# End of macro CWHEAD
3af4			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3af4					FORTH_DSP_VALUEHL 
3af4 cd 49 1e			call macro_dsp_valuehl 
3af7				endm 
# End of macro FORTH_DSP_VALUEHL
3af7			 
3af7					FORTH_DSP_POP 
3af7 cd 01 1f			call macro_forth_dsp_pop 
3afa				endm 
# End of macro FORTH_DSP_POP
3afa			 
3afa e5					push hl 
3afb			 
3afb					FORTH_DSP_VALUEHL 
3afb cd 49 1e			call macro_dsp_valuehl 
3afe				endm 
# End of macro FORTH_DSP_VALUEHL
3afe			 
3afe					FORTH_DSP_POP 
3afe cd 01 1f			call macro_forth_dsp_pop 
3b01				endm 
# End of macro FORTH_DSP_POP
3b01			 
3b01 d1					pop de 
3b02			 
3b02 cd 4a 0b				call info_panel 
3b05			 
3b05			 
3b05					NEXTW 
3b05 c3 ff 1f			jp macro_next 
3b08				endm 
# End of macro NEXTW
3b08			.ATP: 
3b08				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3b08 62				db WORD_SYS_CORE+78             
3b09 7f 3b			dw .FB            
3b0b 04				db 3 + 1 
3b0c .. 00			db "AT?",0              
3b10				endm 
# End of macro CWHEAD
3b10			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3b10					if DEBUG_FORTH_WORDS_KEY 
3b10						DMARK "AT?" 
3b10 f5				push af  
3b11 3a 25 3b			ld a, (.dmark)  
3b14 32 6b ee			ld (debug_mark),a  
3b17 3a 26 3b			ld a, (.dmark+1)  
3b1a 32 6c ee			ld (debug_mark+1),a  
3b1d 3a 27 3b			ld a, (.dmark+2)  
3b20 32 6d ee			ld (debug_mark+2),a  
3b23 18 03			jr .pastdmark  
3b25 ..			.dmark: db "AT?"  
3b28 f1			.pastdmark: pop af  
3b29			endm  
# End of macro DMARK
3b29						CALLMONITOR 
3b29 cd 6f ee			call debug_vector  
3b2c				endm  
# End of macro CALLMONITOR
3b2c					endif 
3b2c 3a 5e ea				ld a, (f_cursor_ptr) 
3b2f			 
3b2f			if DEBUG_FORTH_WORDS 
3b2f				DMARK "AT?" 
3b2f f5				push af  
3b30 3a 44 3b			ld a, (.dmark)  
3b33 32 6b ee			ld (debug_mark),a  
3b36 3a 45 3b			ld a, (.dmark+1)  
3b39 32 6c ee			ld (debug_mark+1),a  
3b3c 3a 46 3b			ld a, (.dmark+2)  
3b3f 32 6d ee			ld (debug_mark+2),a  
3b42 18 03			jr .pastdmark  
3b44 ..			.dmark: db "AT?"  
3b47 f1			.pastdmark: pop af  
3b48			endm  
# End of macro DMARK
3b48				CALLMONITOR 
3b48 cd 6f ee			call debug_vector  
3b4b				endm  
# End of macro CALLMONITOR
3b4b			endif	 
3b4b					; count the number of rows 
3b4b			 
3b4b 06 00				ld b, 0 
3b4d 4f			.atpr:		ld c, a    ; save in case we go below zero 
3b4e d6 28				sub display_cols 
3b50 f2 56 3b				jp p, .atprunder 
3b53 04					inc b 
3b54 18 f7				jr .atpr 
3b56			.atprunder:	 
3b56			if DEBUG_FORTH_WORDS 
3b56				DMARK "A?2" 
3b56 f5				push af  
3b57 3a 6b 3b			ld a, (.dmark)  
3b5a 32 6b ee			ld (debug_mark),a  
3b5d 3a 6c 3b			ld a, (.dmark+1)  
3b60 32 6c ee			ld (debug_mark+1),a  
3b63 3a 6d 3b			ld a, (.dmark+2)  
3b66 32 6d ee			ld (debug_mark+2),a  
3b69 18 03			jr .pastdmark  
3b6b ..			.dmark: db "A?2"  
3b6e f1			.pastdmark: pop af  
3b6f			endm  
# End of macro DMARK
3b6f				CALLMONITOR 
3b6f cd 6f ee			call debug_vector  
3b72				endm  
# End of macro CALLMONITOR
3b72			endif	 
3b72 26 00				ld h, 0 
3b74 69					ld l, c 
3b75 cd 52 1c				call forth_push_numhl 
3b78 68					ld l, b  
3b79 cd 52 1c				call forth_push_numhl 
3b7c			 
3b7c			 
3b7c				NEXTW 
3b7c c3 ff 1f			jp macro_next 
3b7f				endm 
# End of macro NEXTW
3b7f			 
3b7f			.FB: 
3b7f				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3b7f 1b				db WORD_SYS_CORE+7             
3b80 cd 3b			dw .EMIT            
3b82 03				db 2 + 1 
3b83 .. 00			db "FB",0              
3b86				endm 
# End of macro CWHEAD
3b86			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3b86			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3b86			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3b86			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3b86					if DEBUG_FORTH_WORDS_KEY 
3b86						DMARK "FB." 
3b86 f5				push af  
3b87 3a 9b 3b			ld a, (.dmark)  
3b8a 32 6b ee			ld (debug_mark),a  
3b8d 3a 9c 3b			ld a, (.dmark+1)  
3b90 32 6c ee			ld (debug_mark+1),a  
3b93 3a 9d 3b			ld a, (.dmark+2)  
3b96 32 6d ee			ld (debug_mark+2),a  
3b99 18 03			jr .pastdmark  
3b9b ..			.dmark: db "FB."  
3b9e f1			.pastdmark: pop af  
3b9f			endm  
# End of macro DMARK
3b9f						CALLMONITOR 
3b9f cd 6f ee			call debug_vector  
3ba2				endm  
# End of macro CALLMONITOR
3ba2					endif 
3ba2			 
3ba2					FORTH_DSP_VALUEHL 
3ba2 cd 49 1e			call macro_dsp_valuehl 
3ba5				endm 
# End of macro FORTH_DSP_VALUEHL
3ba5			 
3ba5 7d					ld a, l 
3ba6 fe 01				cp 1 
3ba8 20 05				jr nz, .fbn1 
3baa 21 10 ed				ld hl, display_fb1 
3bad 18 15				jr .fbset 
3baf fe 02		.fbn1:		cp 2 
3bb1 20 05				jr nz, .fbn2 
3bb3 21 ce eb				ld hl, display_fb2 
3bb6 18 0c				jr .fbset 
3bb8 fe 03		.fbn2:		cp 3 
3bba 20 05				jr nz, .fbn3 
3bbc 21 6f ec				ld hl, display_fb3 
3bbf 18 03				jr .fbset 
3bc1			.fbn3:		 ; if invalid number select first 
3bc1 21 10 ed				ld hl, display_fb1 
3bc4 22 cc eb		.fbset:		ld (display_fb_active), hl 
3bc7			 
3bc7					FORTH_DSP_POP 
3bc7 cd 01 1f			call macro_forth_dsp_pop 
3bca				endm 
# End of macro FORTH_DSP_POP
3bca			 
3bca					NEXTW 
3bca c3 ff 1f			jp macro_next 
3bcd				endm 
# End of macro NEXTW
3bcd			 
3bcd			 
3bcd			.EMIT: 
3bcd				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3bcd 1b				db WORD_SYS_CORE+7             
3bce 1e 3c			dw .DOTH            
3bd0 05				db 4 + 1 
3bd1 .. 00			db "EMIT",0              
3bd6				endm 
# End of macro CWHEAD
3bd6			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3bd6					; get value off TOS and display it 
3bd6			 
3bd6					if DEBUG_FORTH_WORDS_KEY 
3bd6						DMARK "EMT" 
3bd6 f5				push af  
3bd7 3a eb 3b			ld a, (.dmark)  
3bda 32 6b ee			ld (debug_mark),a  
3bdd 3a ec 3b			ld a, (.dmark+1)  
3be0 32 6c ee			ld (debug_mark+1),a  
3be3 3a ed 3b			ld a, (.dmark+2)  
3be6 32 6d ee			ld (debug_mark+2),a  
3be9 18 03			jr .pastdmark  
3beb ..			.dmark: db "EMT"  
3bee f1			.pastdmark: pop af  
3bef			endm  
# End of macro DMARK
3bef						CALLMONITOR 
3bef cd 6f ee			call debug_vector  
3bf2				endm  
# End of macro CALLMONITOR
3bf2					endif 
3bf2			 
3bf2					FORTH_DSP_VALUEHL 
3bf2 cd 49 1e			call macro_dsp_valuehl 
3bf5				endm 
# End of macro FORTH_DSP_VALUEHL
3bf5			 
3bf5 7d					ld a,l 
3bf6			 
3bf6					; TODO write to display 
3bf6			 
3bf6 32 bf e4				ld (os_input), a 
3bf9 3e 00				ld a, 0 
3bfb 32 c0 e4				ld (os_input+1), a 
3bfe					 
3bfe 3a 5e ea				ld a, (f_cursor_ptr) 
3c01 11 bf e4				ld de, os_input 
3c04 cd cc 0b				call str_at_display 
3c07			 
3c07			 
3c07 3a 3c ea				ld a,(cli_autodisplay) 
3c0a fe 00				cp 0 
3c0c 28 03				jr z, .enoupdate 
3c0e cd dc 0b						call update_display 
3c11					.enoupdate: 
3c11			 
3c11 3a 5e ea				ld a, (f_cursor_ptr) 
3c14 3c					inc a 
3c15 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3c18			 
3c18			 
3c18					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c18 cd 01 1f			call macro_forth_dsp_pop 
3c1b				endm 
# End of macro FORTH_DSP_POP
3c1b			  
3c1b			 
3c1b					NEXTW 
3c1b c3 ff 1f			jp macro_next 
3c1e				endm 
# End of macro NEXTW
3c1e			.DOTH: 
3c1e				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3c1e 1c				db WORD_SYS_CORE+8             
3c1f 4e 3c			dw .DOTF            
3c21 03				db 2 + 1 
3c22 .. 00			db ".-",0              
3c25				endm 
# End of macro CWHEAD
3c25			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3c25					; get value off TOS and display it 
3c25					if DEBUG_FORTH_WORDS_KEY 
3c25						DMARK "DTD" 
3c25 f5				push af  
3c26 3a 3a 3c			ld a, (.dmark)  
3c29 32 6b ee			ld (debug_mark),a  
3c2c 3a 3b 3c			ld a, (.dmark+1)  
3c2f 32 6c ee			ld (debug_mark+1),a  
3c32 3a 3c 3c			ld a, (.dmark+2)  
3c35 32 6d ee			ld (debug_mark+2),a  
3c38 18 03			jr .pastdmark  
3c3a ..			.dmark: db "DTD"  
3c3d f1			.pastdmark: pop af  
3c3e			endm  
# End of macro DMARK
3c3e						CALLMONITOR 
3c3e cd 6f ee			call debug_vector  
3c41				endm  
# End of macro CALLMONITOR
3c41					endif 
3c41 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3c43 3e 00			ld a, 0 
3c45 32 3d ea			ld (cli_mvdot), a 
3c48 c3 a5 3c			jp .dotgo 
3c4b				NEXTW 
3c4b c3 ff 1f			jp macro_next 
3c4e				endm 
# End of macro NEXTW
3c4e			.DOTF: 
3c4e				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3c4e 1c				db WORD_SYS_CORE+8             
3c4f 7c 3c			dw .DOT            
3c51 03				db 2 + 1 
3c52 .. 00			db ".>",0              
3c55				endm 
# End of macro CWHEAD
3c55			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
3c55					; get value off TOS and display it 
3c55			        ; TODO BUG adds extra spaces 
3c55			        ; TODO BUG handle numerics? 
3c55					if DEBUG_FORTH_WORDS_KEY 
3c55						DMARK "DTC" 
3c55 f5				push af  
3c56 3a 6a 3c			ld a, (.dmark)  
3c59 32 6b ee			ld (debug_mark),a  
3c5c 3a 6b 3c			ld a, (.dmark+1)  
3c5f 32 6c ee			ld (debug_mark+1),a  
3c62 3a 6c 3c			ld a, (.dmark+2)  
3c65 32 6d ee			ld (debug_mark+2),a  
3c68 18 03			jr .pastdmark  
3c6a ..			.dmark: db "DTC"  
3c6d f1			.pastdmark: pop af  
3c6e			endm  
# End of macro DMARK
3c6e						CALLMONITOR 
3c6e cd 6f ee			call debug_vector  
3c71				endm  
# End of macro CALLMONITOR
3c71					endif 
3c71 3e 01			ld a, 1 
3c73 32 3d ea			ld (cli_mvdot), a 
3c76 c3 a5 3c			jp .dotgo 
3c79				NEXTW 
3c79 c3 ff 1f			jp macro_next 
3c7c				endm 
# End of macro NEXTW
3c7c			 
3c7c			.DOT: 
3c7c				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3c7c 1c				db WORD_SYS_CORE+8             
3c7d 58 3e			dw .CLS            
3c7f 02				db 1 + 1 
3c80 .. 00			db ".",0              
3c82				endm 
# End of macro CWHEAD
3c82			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
3c82					; get value off TOS and display it 
3c82			 
3c82					if DEBUG_FORTH_WORDS_KEY 
3c82						DMARK "DOT" 
3c82 f5				push af  
3c83 3a 97 3c			ld a, (.dmark)  
3c86 32 6b ee			ld (debug_mark),a  
3c89 3a 98 3c			ld a, (.dmark+1)  
3c8c 32 6c ee			ld (debug_mark+1),a  
3c8f 3a 99 3c			ld a, (.dmark+2)  
3c92 32 6d ee			ld (debug_mark+2),a  
3c95 18 03			jr .pastdmark  
3c97 ..			.dmark: db "DOT"  
3c9a f1			.pastdmark: pop af  
3c9b			endm  
# End of macro DMARK
3c9b						CALLMONITOR 
3c9b cd 6f ee			call debug_vector  
3c9e				endm  
# End of macro CALLMONITOR
3c9e					endif 
3c9e 3e 00			ld a, 0 
3ca0 32 3d ea			ld (cli_mvdot), a 
3ca3 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3ca5				 
3ca5			 
3ca5			.dotgo: 
3ca5			 
3ca5			; move up type to on stack for parserv5 
3ca5					FORTH_DSP 
3ca5 cd 0f 1e			call macro_forth_dsp 
3ca8				endm 
# End of macro FORTH_DSP
3ca8				;FORTH_DSP_VALUE  
3ca8			 
3ca8			if DEBUG_FORTH_DOT 
3ca8				DMARK "DOT" 
3ca8 f5				push af  
3ca9 3a bd 3c			ld a, (.dmark)  
3cac 32 6b ee			ld (debug_mark),a  
3caf 3a be 3c			ld a, (.dmark+1)  
3cb2 32 6c ee			ld (debug_mark+1),a  
3cb5 3a bf 3c			ld a, (.dmark+2)  
3cb8 32 6d ee			ld (debug_mark+2),a  
3cbb 18 03			jr .pastdmark  
3cbd ..			.dmark: db "DOT"  
3cc0 f1			.pastdmark: pop af  
3cc1			endm  
# End of macro DMARK
3cc1				CALLMONITOR 
3cc1 cd 6f ee			call debug_vector  
3cc4				endm  
# End of macro CALLMONITOR
3cc4			endif	 
3cc4			;		.print: 
3cc4			 
3cc4 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3cc5 23				inc hl   ; position to the actual value 
3cc6 fe 01			cp DS_TYPE_STR 
3cc8 20 06			jr nz, .dotnum1  
3cca			 
3cca			; display string 
3cca				FORTH_DSP_VALUE  
3cca cd 32 1e			call macro_forth_dsp_value 
3ccd				endm 
# End of macro FORTH_DSP_VALUE
3ccd eb				ex de,hl 
3cce 18 49			jr .dotwrite 
3cd0			 
3cd0			.dotnum1: 
3cd0 fe 02			cp DS_TYPE_INUM 
3cd2 20 44			jr nz, .dotflot 
3cd4			 
3cd4			 
3cd4			; display number 
3cd4			 
3cd4			;	push hl 
3cd4			;	call clear_display 
3cd4			;	pop hl 
3cd4			 
3cd4 5e				ld e, (hl) 
3cd5 23				inc hl 
3cd6 56				ld d, (hl) 
3cd7 21 c1 e2			ld hl, scratch 
3cda			if DEBUG_FORTH_DOT 
3cda				DMARK "DT1" 
3cda f5				push af  
3cdb 3a ef 3c			ld a, (.dmark)  
3cde 32 6b ee			ld (debug_mark),a  
3ce1 3a f0 3c			ld a, (.dmark+1)  
3ce4 32 6c ee			ld (debug_mark+1),a  
3ce7 3a f1 3c			ld a, (.dmark+2)  
3cea 32 6d ee			ld (debug_mark+2),a  
3ced 18 03			jr .pastdmark  
3cef ..			.dmark: db "DT1"  
3cf2 f1			.pastdmark: pop af  
3cf3			endm  
# End of macro DMARK
3cf3				CALLMONITOR 
3cf3 cd 6f ee			call debug_vector  
3cf6				endm  
# End of macro CALLMONITOR
3cf6			endif	 
3cf6			 
3cf6 cd f3 11			call uitoa_16 
3cf9 eb				ex de,hl 
3cfa			 
3cfa			if DEBUG_FORTH_DOT 
3cfa				DMARK "DT2" 
3cfa f5				push af  
3cfb 3a 0f 3d			ld a, (.dmark)  
3cfe 32 6b ee			ld (debug_mark),a  
3d01 3a 10 3d			ld a, (.dmark+1)  
3d04 32 6c ee			ld (debug_mark+1),a  
3d07 3a 11 3d			ld a, (.dmark+2)  
3d0a 32 6d ee			ld (debug_mark+2),a  
3d0d 18 03			jr .pastdmark  
3d0f ..			.dmark: db "DT2"  
3d12 f1			.pastdmark: pop af  
3d13			endm  
# End of macro DMARK
3d13				CALLMONITOR 
3d13 cd 6f ee			call debug_vector  
3d16				endm  
# End of macro CALLMONITOR
3d16			endif	 
3d16			 
3d16			;	ld de, os_word_scratch 
3d16 18 01			jr .dotwrite 
3d18			 
3d18 00			.dotflot:   nop 
3d19			; TODO print floating point number 
3d19			 
3d19			.dotwrite:		 
3d19			 
3d19					; if c is set then set all '-' to spaces 
3d19					; need to also take into account .>  
3d19			 
3d19 3e 01				ld a, 1 
3d1b b9					cp c 
3d1c 20 67				jr nz, .nodashswap 
3d1e			 
3d1e					; DE has the string to write, working with HL 
3d1e			 
3d1e 06 ff				ld b, 255 
3d20 d5					push de 
3d21 e1					pop hl 
3d22			 
3d22			if DEBUG_FORTH_DOT 
3d22				DMARK "DT-" 
3d22 f5				push af  
3d23 3a 37 3d			ld a, (.dmark)  
3d26 32 6b ee			ld (debug_mark),a  
3d29 3a 38 3d			ld a, (.dmark+1)  
3d2c 32 6c ee			ld (debug_mark+1),a  
3d2f 3a 39 3d			ld a, (.dmark+2)  
3d32 32 6d ee			ld (debug_mark+2),a  
3d35 18 03			jr .pastdmark  
3d37 ..			.dmark: db "DT-"  
3d3a f1			.pastdmark: pop af  
3d3b			endm  
# End of macro DMARK
3d3b				CALLMONITOR 
3d3b cd 6f ee			call debug_vector  
3d3e				endm  
# End of macro CALLMONITOR
3d3e			endif	 
3d3e 7e			.dashscan:	ld a, (hl) 
3d3f fe 00				cp 0 
3d41 28 42				jr z, .nodashswap 
3d43 fe 2d				cp '-' 
3d45 20 03				jr nz, .dashskip 
3d47 3e 20				ld a, ' ' 
3d49 77					ld (hl), a 
3d4a 23			.dashskip:	inc hl 
3d4b			if DEBUG_FORTH_DOT 
3d4b				DMARK "D-2" 
3d4b f5				push af  
3d4c 3a 60 3d			ld a, (.dmark)  
3d4f 32 6b ee			ld (debug_mark),a  
3d52 3a 61 3d			ld a, (.dmark+1)  
3d55 32 6c ee			ld (debug_mark+1),a  
3d58 3a 62 3d			ld a, (.dmark+2)  
3d5b 32 6d ee			ld (debug_mark+2),a  
3d5e 18 03			jr .pastdmark  
3d60 ..			.dmark: db "D-2"  
3d63 f1			.pastdmark: pop af  
3d64			endm  
# End of macro DMARK
3d64				CALLMONITOR 
3d64 cd 6f ee			call debug_vector  
3d67				endm  
# End of macro CALLMONITOR
3d67			endif	 
3d67 10 d5				djnz .dashscan 
3d69			 
3d69			if DEBUG_FORTH_DOT 
3d69				DMARK "D-1" 
3d69 f5				push af  
3d6a 3a 7e 3d			ld a, (.dmark)  
3d6d 32 6b ee			ld (debug_mark),a  
3d70 3a 7f 3d			ld a, (.dmark+1)  
3d73 32 6c ee			ld (debug_mark+1),a  
3d76 3a 80 3d			ld a, (.dmark+2)  
3d79 32 6d ee			ld (debug_mark+2),a  
3d7c 18 03			jr .pastdmark  
3d7e ..			.dmark: db "D-1"  
3d81 f1			.pastdmark: pop af  
3d82			endm  
# End of macro DMARK
3d82				CALLMONITOR 
3d82 cd 6f ee			call debug_vector  
3d85				endm  
# End of macro CALLMONITOR
3d85			endif	 
3d85			 
3d85			.nodashswap: 
3d85			 
3d85			if DEBUG_FORTH_DOT 
3d85				DMARK "D-o" 
3d85 f5				push af  
3d86 3a 9a 3d			ld a, (.dmark)  
3d89 32 6b ee			ld (debug_mark),a  
3d8c 3a 9b 3d			ld a, (.dmark+1)  
3d8f 32 6c ee			ld (debug_mark+1),a  
3d92 3a 9c 3d			ld a, (.dmark+2)  
3d95 32 6d ee			ld (debug_mark+2),a  
3d98 18 03			jr .pastdmark  
3d9a ..			.dmark: db "D-o"  
3d9d f1			.pastdmark: pop af  
3d9e			endm  
# End of macro DMARK
3d9e				CALLMONITOR 
3d9e cd 6f ee			call debug_vector  
3da1				endm  
# End of macro CALLMONITOR
3da1			endif	 
3da1			 
3da1 d5					push de   ; save string start in case we need to advance print 
3da2			 
3da2 3a 5e ea				ld a, (f_cursor_ptr) 
3da5 cd cc 0b				call str_at_display 
3da8 3a 3c ea				ld a,(cli_autodisplay) 
3dab fe 00				cp 0 
3dad 28 03				jr z, .noupdate 
3daf cd dc 0b						call update_display 
3db2					.noupdate: 
3db2			 
3db2			 
3db2					; see if we need to advance the print position 
3db2			 
3db2 e1					pop hl   ; get back string 
3db3			;		ex de,hl 
3db3			 
3db3 3a 3d ea				ld a, (cli_mvdot) 
3db6			if DEBUG_FORTH_DOT 
3db6			;		ld e,a 
3db6				DMARK "D>1" 
3db6 f5				push af  
3db7 3a cb 3d			ld a, (.dmark)  
3dba 32 6b ee			ld (debug_mark),a  
3dbd 3a cc 3d			ld a, (.dmark+1)  
3dc0 32 6c ee			ld (debug_mark+1),a  
3dc3 3a cd 3d			ld a, (.dmark+2)  
3dc6 32 6d ee			ld (debug_mark+2),a  
3dc9 18 03			jr .pastdmark  
3dcb ..			.dmark: db "D>1"  
3dce f1			.pastdmark: pop af  
3dcf			endm  
# End of macro DMARK
3dcf				CALLMONITOR 
3dcf cd 6f ee			call debug_vector  
3dd2				endm  
# End of macro CALLMONITOR
3dd2			endif	 
3dd2 fe 00				cp 0 
3dd4 28 44				jr z, .noadv 
3dd6					; yes, lets advance the print position 
3dd6 3e 00				ld a, 0 
3dd8 cd 4f 12				call strlent 
3ddb			if DEBUG_FORTH_DOT 
3ddb				DMARK "D-?" 
3ddb f5				push af  
3ddc 3a f0 3d			ld a, (.dmark)  
3ddf 32 6b ee			ld (debug_mark),a  
3de2 3a f1 3d			ld a, (.dmark+1)  
3de5 32 6c ee			ld (debug_mark+1),a  
3de8 3a f2 3d			ld a, (.dmark+2)  
3deb 32 6d ee			ld (debug_mark+2),a  
3dee 18 03			jr .pastdmark  
3df0 ..			.dmark: db "D-?"  
3df3 f1			.pastdmark: pop af  
3df4			endm  
# End of macro DMARK
3df4				CALLMONITOR 
3df4 cd 6f ee			call debug_vector  
3df7				endm  
# End of macro CALLMONITOR
3df7			endif	 
3df7 3a 5e ea				ld a, (f_cursor_ptr) 
3dfa 85					add a,l 
3dfb					;call addatohl 
3dfb					;ld a, l 
3dfb 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3dfe			 
3dfe			if DEBUG_FORTH_DOT 
3dfe				DMARK "D->" 
3dfe f5				push af  
3dff 3a 13 3e			ld a, (.dmark)  
3e02 32 6b ee			ld (debug_mark),a  
3e05 3a 14 3e			ld a, (.dmark+1)  
3e08 32 6c ee			ld (debug_mark+1),a  
3e0b 3a 15 3e			ld a, (.dmark+2)  
3e0e 32 6d ee			ld (debug_mark+2),a  
3e11 18 03			jr .pastdmark  
3e13 ..			.dmark: db "D->"  
3e16 f1			.pastdmark: pop af  
3e17			endm  
# End of macro DMARK
3e17				CALLMONITOR 
3e17 cd 6f ee			call debug_vector  
3e1a				endm  
# End of macro CALLMONITOR
3e1a			endif	 
3e1a			 
3e1a			.noadv:	 
3e1a			 
3e1a					if DEBUG_FORTH_DOT_WAIT 
3e1a							call next_page_prompt 
3e1a					endif	 
3e1a			; TODO this pop off the stack causes a crash. i dont know why 
3e1a			 
3e1a			 
3e1a			if DEBUG_FORTH_DOT 
3e1a				DMARK "DTh" 
3e1a f5				push af  
3e1b 3a 2f 3e			ld a, (.dmark)  
3e1e 32 6b ee			ld (debug_mark),a  
3e21 3a 30 3e			ld a, (.dmark+1)  
3e24 32 6c ee			ld (debug_mark+1),a  
3e27 3a 31 3e			ld a, (.dmark+2)  
3e2a 32 6d ee			ld (debug_mark+2),a  
3e2d 18 03			jr .pastdmark  
3e2f ..			.dmark: db "DTh"  
3e32 f1			.pastdmark: pop af  
3e33			endm  
# End of macro DMARK
3e33				CALLMONITOR 
3e33 cd 6f ee			call debug_vector  
3e36				endm  
# End of macro CALLMONITOR
3e36			endif	 
3e36			 
3e36					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e36 cd 01 1f			call macro_forth_dsp_pop 
3e39				endm 
# End of macro FORTH_DSP_POP
3e39			 
3e39			if DEBUG_FORTH_DOT 
3e39				DMARK "DTi" 
3e39 f5				push af  
3e3a 3a 4e 3e			ld a, (.dmark)  
3e3d 32 6b ee			ld (debug_mark),a  
3e40 3a 4f 3e			ld a, (.dmark+1)  
3e43 32 6c ee			ld (debug_mark+1),a  
3e46 3a 50 3e			ld a, (.dmark+2)  
3e49 32 6d ee			ld (debug_mark+2),a  
3e4c 18 03			jr .pastdmark  
3e4e ..			.dmark: db "DTi"  
3e51 f1			.pastdmark: pop af  
3e52			endm  
# End of macro DMARK
3e52				CALLMONITOR 
3e52 cd 6f ee			call debug_vector  
3e55				endm  
# End of macro CALLMONITOR
3e55			endif	 
3e55			 
3e55			 
3e55					NEXTW 
3e55 c3 ff 1f			jp macro_next 
3e58				endm 
# End of macro NEXTW
3e58			 
3e58			.CLS: 
3e58				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3e58 35				db WORD_SYS_CORE+33             
3e59 85 3e			dw .DRAW            
3e5b 04				db 3 + 1 
3e5c .. 00			db "CLS",0              
3e60				endm 
# End of macro CWHEAD
3e60			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3e60					if DEBUG_FORTH_WORDS_KEY 
3e60						DMARK "CLS" 
3e60 f5				push af  
3e61 3a 75 3e			ld a, (.dmark)  
3e64 32 6b ee			ld (debug_mark),a  
3e67 3a 76 3e			ld a, (.dmark+1)  
3e6a 32 6c ee			ld (debug_mark+1),a  
3e6d 3a 77 3e			ld a, (.dmark+2)  
3e70 32 6d ee			ld (debug_mark+2),a  
3e73 18 03			jr .pastdmark  
3e75 ..			.dmark: db "CLS"  
3e78 f1			.pastdmark: pop af  
3e79			endm  
# End of macro DMARK
3e79						CALLMONITOR 
3e79 cd 6f ee			call debug_vector  
3e7c				endm  
# End of macro CALLMONITOR
3e7c					endif 
3e7c cd b9 0b				call clear_display 
3e7f c3 93 3f				jp .home		; and home cursor 
3e82					NEXTW 
3e82 c3 ff 1f			jp macro_next 
3e85				endm 
# End of macro NEXTW
3e85			 
3e85			.DRAW: 
3e85				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3e85 36				db WORD_SYS_CORE+34             
3e86 b0 3e			dw .DUMP            
3e88 05				db 4 + 1 
3e89 .. 00			db "DRAW",0              
3e8e				endm 
# End of macro CWHEAD
3e8e			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3e8e					if DEBUG_FORTH_WORDS_KEY 
3e8e						DMARK "DRW" 
3e8e f5				push af  
3e8f 3a a3 3e			ld a, (.dmark)  
3e92 32 6b ee			ld (debug_mark),a  
3e95 3a a4 3e			ld a, (.dmark+1)  
3e98 32 6c ee			ld (debug_mark+1),a  
3e9b 3a a5 3e			ld a, (.dmark+2)  
3e9e 32 6d ee			ld (debug_mark+2),a  
3ea1 18 03			jr .pastdmark  
3ea3 ..			.dmark: db "DRW"  
3ea6 f1			.pastdmark: pop af  
3ea7			endm  
# End of macro DMARK
3ea7						CALLMONITOR 
3ea7 cd 6f ee			call debug_vector  
3eaa				endm  
# End of macro CALLMONITOR
3eaa					endif 
3eaa cd dc 0b				call update_display 
3ead					NEXTW 
3ead c3 ff 1f			jp macro_next 
3eb0				endm 
# End of macro NEXTW
3eb0			 
3eb0			.DUMP: 
3eb0				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3eb0 37				db WORD_SYS_CORE+35             
3eb1 e8 3e			dw .CDUMP            
3eb3 05				db 4 + 1 
3eb4 .. 00			db "DUMP",0              
3eb9				endm 
# End of macro CWHEAD
3eb9			; | DUMP ( x -- ) With address x display dump   | DONE 
3eb9			; TODO pop address to use off of the stack 
3eb9					if DEBUG_FORTH_WORDS_KEY 
3eb9						DMARK "DUM" 
3eb9 f5				push af  
3eba 3a ce 3e			ld a, (.dmark)  
3ebd 32 6b ee			ld (debug_mark),a  
3ec0 3a cf 3e			ld a, (.dmark+1)  
3ec3 32 6c ee			ld (debug_mark+1),a  
3ec6 3a d0 3e			ld a, (.dmark+2)  
3ec9 32 6d ee			ld (debug_mark+2),a  
3ecc 18 03			jr .pastdmark  
3ece ..			.dmark: db "DUM"  
3ed1 f1			.pastdmark: pop af  
3ed2			endm  
# End of macro DMARK
3ed2						CALLMONITOR 
3ed2 cd 6f ee			call debug_vector  
3ed5				endm  
# End of macro CALLMONITOR
3ed5					endif 
3ed5 cd b9 0b				call clear_display 
3ed8			 
3ed8					; get address 
3ed8			 
3ed8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ed8 cd 49 1e			call macro_dsp_valuehl 
3edb				endm 
# End of macro FORTH_DSP_VALUEHL
3edb				 
3edb					; save it for cdump 
3edb			 
3edb 22 e4 e5				ld (os_cur_ptr),hl 
3ede			 
3ede					; destroy value TOS 
3ede			 
3ede					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ede cd 01 1f			call macro_forth_dsp_pop 
3ee1				endm 
# End of macro FORTH_DSP_POP
3ee1			 
3ee1 cd d2 1a				call dumpcont	; skip old style of param parsing	 
3ee4 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3ee5					NEXTW 
3ee5 c3 ff 1f			jp macro_next 
3ee8				endm 
# End of macro NEXTW
3ee8			.CDUMP: 
3ee8				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3ee8 38				db WORD_SYS_CORE+36             
3ee9 18 3f			dw .DAT            
3eeb 06				db 5 + 1 
3eec .. 00			db "CDUMP",0              
3ef2				endm 
# End of macro CWHEAD
3ef2			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3ef2					if DEBUG_FORTH_WORDS_KEY 
3ef2						DMARK "CDP" 
3ef2 f5				push af  
3ef3 3a 07 3f			ld a, (.dmark)  
3ef6 32 6b ee			ld (debug_mark),a  
3ef9 3a 08 3f			ld a, (.dmark+1)  
3efc 32 6c ee			ld (debug_mark+1),a  
3eff 3a 09 3f			ld a, (.dmark+2)  
3f02 32 6d ee			ld (debug_mark+2),a  
3f05 18 03			jr .pastdmark  
3f07 ..			.dmark: db "CDP"  
3f0a f1			.pastdmark: pop af  
3f0b			endm  
# End of macro DMARK
3f0b						CALLMONITOR 
3f0b cd 6f ee			call debug_vector  
3f0e				endm  
# End of macro CALLMONITOR
3f0e					endif 
3f0e cd b9 0b				call clear_display 
3f11 cd d2 1a				call dumpcont	 
3f14 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3f15					NEXTW 
3f15 c3 ff 1f			jp macro_next 
3f18				endm 
# End of macro NEXTW
3f18			 
3f18			 
3f18			 
3f18			 
3f18			.DAT: 
3f18				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3f18 3d				db WORD_SYS_CORE+41             
3f19 6e 3f			dw .HOME            
3f1b 03				db 2 + 1 
3f1c .. 00			db "AT",0              
3f1f				endm 
# End of macro CWHEAD
3f1f			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3f1f					if DEBUG_FORTH_WORDS_KEY 
3f1f						DMARK "AT." 
3f1f f5				push af  
3f20 3a 34 3f			ld a, (.dmark)  
3f23 32 6b ee			ld (debug_mark),a  
3f26 3a 35 3f			ld a, (.dmark+1)  
3f29 32 6c ee			ld (debug_mark+1),a  
3f2c 3a 36 3f			ld a, (.dmark+2)  
3f2f 32 6d ee			ld (debug_mark+2),a  
3f32 18 03			jr .pastdmark  
3f34 ..			.dmark: db "AT."  
3f37 f1			.pastdmark: pop af  
3f38			endm  
# End of macro DMARK
3f38						CALLMONITOR 
3f38 cd 6f ee			call debug_vector  
3f3b				endm  
# End of macro CALLMONITOR
3f3b					endif 
3f3b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f3b cd 49 1e			call macro_dsp_valuehl 
3f3e				endm 
# End of macro FORTH_DSP_VALUEHL
3f3e			 
3f3e			 
3f3e					; TODO save cursor row 
3f3e 7d					ld a,l 
3f3f fe 02				cp 2 
3f41 20 04				jr nz, .crow3 
3f43 3e 28				ld a, display_row_2 
3f45 18 12				jr .ccol1 
3f47 fe 03		.crow3:		cp 3 
3f49 20 04				jr nz, .crow4 
3f4b 3e 50				ld a, display_row_3 
3f4d 18 0a				jr .ccol1 
3f4f fe 04		.crow4:		cp 4 
3f51 20 04				jr nz, .crow1 
3f53 3e 78				ld a, display_row_4 
3f55 18 02				jr .ccol1 
3f57 3e 00		.crow1:		ld a,display_row_1 
3f59 f5			.ccol1:		push af			; got row offset 
3f5a 6f					ld l,a 
3f5b 26 00				ld h,0 
3f5d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f5d cd 01 1f			call macro_forth_dsp_pop 
3f60				endm 
# End of macro FORTH_DSP_POP
3f60					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f60 cd 49 1e			call macro_dsp_valuehl 
3f63				endm 
# End of macro FORTH_DSP_VALUEHL
3f63					; TODO save cursor col 
3f63 f1					pop af 
3f64 85					add l		; add col offset 
3f65 32 5e ea				ld (f_cursor_ptr), a 
3f68					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f68 cd 01 1f			call macro_forth_dsp_pop 
3f6b				endm 
# End of macro FORTH_DSP_POP
3f6b			 
3f6b					; calculate  
3f6b			 
3f6b					NEXTW 
3f6b c3 ff 1f			jp macro_next 
3f6e				endm 
# End of macro NEXTW
3f6e			 
3f6e			 
3f6e			.HOME: 
3f6e				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
3f6e 41				db WORD_SYS_CORE+45             
3f6f 9b 3f			dw .CR            
3f71 05				db 4 + 1 
3f72 .. 00			db "HOME",0              
3f77				endm 
# End of macro CWHEAD
3f77			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3f77					if DEBUG_FORTH_WORDS_KEY 
3f77						DMARK "HOM" 
3f77 f5				push af  
3f78 3a 8c 3f			ld a, (.dmark)  
3f7b 32 6b ee			ld (debug_mark),a  
3f7e 3a 8d 3f			ld a, (.dmark+1)  
3f81 32 6c ee			ld (debug_mark+1),a  
3f84 3a 8e 3f			ld a, (.dmark+2)  
3f87 32 6d ee			ld (debug_mark+2),a  
3f8a 18 03			jr .pastdmark  
3f8c ..			.dmark: db "HOM"  
3f8f f1			.pastdmark: pop af  
3f90			endm  
# End of macro DMARK
3f90						CALLMONITOR 
3f90 cd 6f ee			call debug_vector  
3f93				endm  
# End of macro CALLMONITOR
3f93					endif 
3f93 3e 00		.home:		ld a, 0		; and home cursor 
3f95 32 5e ea				ld (f_cursor_ptr), a 
3f98					NEXTW 
3f98 c3 ff 1f			jp macro_next 
3f9b				endm 
# End of macro NEXTW
3f9b			 
3f9b			 
3f9b			.CR: 
3f9b				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
3f9b 46				db WORD_SYS_CORE+50             
3f9c d6 3f			dw .SPACE            
3f9e 03				db 2 + 1 
3f9f .. 00			db "CR",0              
3fa2				endm 
# End of macro CWHEAD
3fa2			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
3fa2					if DEBUG_FORTH_WORDS_KEY 
3fa2						DMARK "CR." 
3fa2 f5				push af  
3fa3 3a b7 3f			ld a, (.dmark)  
3fa6 32 6b ee			ld (debug_mark),a  
3fa9 3a b8 3f			ld a, (.dmark+1)  
3fac 32 6c ee			ld (debug_mark+1),a  
3faf 3a b9 3f			ld a, (.dmark+2)  
3fb2 32 6d ee			ld (debug_mark+2),a  
3fb5 18 03			jr .pastdmark  
3fb7 ..			.dmark: db "CR."  
3fba f1			.pastdmark: pop af  
3fbb			endm  
# End of macro DMARK
3fbb						CALLMONITOR 
3fbb cd 6f ee			call debug_vector  
3fbe				endm  
# End of macro CALLMONITOR
3fbe					endif 
3fbe 3e 0d				ld a, 13 
3fc0 32 c1 e2				ld (scratch),a 
3fc3 3e 0a				ld a, 10 
3fc5 32 c2 e2				ld (scratch+1),a 
3fc8 3e 00				ld a, 0 
3fca 32 c3 e2				ld (scratch+2),a 
3fcd 21 c1 e2				ld hl, scratch 
3fd0 cd c0 1c				call forth_push_str 
3fd3					 
3fd3				       NEXTW 
3fd3 c3 ff 1f			jp macro_next 
3fd6				endm 
# End of macro NEXTW
3fd6			.SPACE: 
3fd6				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3fd6 46				db WORD_SYS_CORE+50             
3fd7 0c 40			dw .SPACES            
3fd9 03				db 2 + 1 
3fda .. 00			db "BL",0              
3fdd				endm 
# End of macro CWHEAD
3fdd			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3fdd					if DEBUG_FORTH_WORDS_KEY 
3fdd						DMARK "BL." 
3fdd f5				push af  
3fde 3a f2 3f			ld a, (.dmark)  
3fe1 32 6b ee			ld (debug_mark),a  
3fe4 3a f3 3f			ld a, (.dmark+1)  
3fe7 32 6c ee			ld (debug_mark+1),a  
3fea 3a f4 3f			ld a, (.dmark+2)  
3fed 32 6d ee			ld (debug_mark+2),a  
3ff0 18 03			jr .pastdmark  
3ff2 ..			.dmark: db "BL."  
3ff5 f1			.pastdmark: pop af  
3ff6			endm  
# End of macro DMARK
3ff6						CALLMONITOR 
3ff6 cd 6f ee			call debug_vector  
3ff9				endm  
# End of macro CALLMONITOR
3ff9					endif 
3ff9 3e 20				ld a, " " 
3ffb 32 c1 e2				ld (scratch),a 
3ffe 3e 00				ld a, 0 
4000 32 c2 e2				ld (scratch+1),a 
4003 21 c1 e2				ld hl, scratch 
4006 cd c0 1c				call forth_push_str 
4009					 
4009				       NEXTW 
4009 c3 ff 1f			jp macro_next 
400c				endm 
# End of macro NEXTW
400c			 
400c			;.blstr: db " ", 0 
400c			 
400c			.SPACES: 
400c				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
400c 47				db WORD_SYS_CORE+51             
400d a7 40			dw .SCROLL            
400f 07				db 6 + 1 
4010 .. 00			db "SPACES",0              
4017				endm 
# End of macro CWHEAD
4017			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
4017					if DEBUG_FORTH_WORDS_KEY 
4017						DMARK "SPS" 
4017 f5				push af  
4018 3a 2c 40			ld a, (.dmark)  
401b 32 6b ee			ld (debug_mark),a  
401e 3a 2d 40			ld a, (.dmark+1)  
4021 32 6c ee			ld (debug_mark+1),a  
4024 3a 2e 40			ld a, (.dmark+2)  
4027 32 6d ee			ld (debug_mark+2),a  
402a 18 03			jr .pastdmark  
402c ..			.dmark: db "SPS"  
402f f1			.pastdmark: pop af  
4030			endm  
# End of macro DMARK
4030						CALLMONITOR 
4030 cd 6f ee			call debug_vector  
4033				endm  
# End of macro CALLMONITOR
4033					endif 
4033			 
4033			 
4033					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4033 cd 49 1e			call macro_dsp_valuehl 
4036				endm 
# End of macro FORTH_DSP_VALUEHL
4036			 
4036 e5					push hl    ; u 
4037					if DEBUG_FORTH_WORDS 
4037						DMARK "SPA" 
4037 f5				push af  
4038 3a 4c 40			ld a, (.dmark)  
403b 32 6b ee			ld (debug_mark),a  
403e 3a 4d 40			ld a, (.dmark+1)  
4041 32 6c ee			ld (debug_mark+1),a  
4044 3a 4e 40			ld a, (.dmark+2)  
4047 32 6d ee			ld (debug_mark+2),a  
404a 18 03			jr .pastdmark  
404c ..			.dmark: db "SPA"  
404f f1			.pastdmark: pop af  
4050			endm  
# End of macro DMARK
4050						CALLMONITOR 
4050 cd 6f ee			call debug_vector  
4053				endm  
# End of macro CALLMONITOR
4053					endif 
4053			 
4053					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4053 cd 01 1f			call macro_forth_dsp_pop 
4056				endm 
# End of macro FORTH_DSP_POP
4056 e1					pop hl 
4057 0e 00				ld c, 0 
4059 45					ld b, l 
405a 21 c1 e2				ld hl, scratch  
405d			 
405d					if DEBUG_FORTH_WORDS 
405d						DMARK "SP2" 
405d f5				push af  
405e 3a 72 40			ld a, (.dmark)  
4061 32 6b ee			ld (debug_mark),a  
4064 3a 73 40			ld a, (.dmark+1)  
4067 32 6c ee			ld (debug_mark+1),a  
406a 3a 74 40			ld a, (.dmark+2)  
406d 32 6d ee			ld (debug_mark+2),a  
4070 18 03			jr .pastdmark  
4072 ..			.dmark: db "SP2"  
4075 f1			.pastdmark: pop af  
4076			endm  
# End of macro DMARK
4076						CALLMONITOR 
4076 cd 6f ee			call debug_vector  
4079				endm  
# End of macro CALLMONITOR
4079					endif 
4079 3e 20				ld a, ' ' 
407b			.spaces1:	 
407b 77					ld (hl),a 
407c 23					inc hl 
407d					 
407d 10 fc				djnz .spaces1 
407f 3e 00				ld a,0 
4081 77					ld (hl),a 
4082 21 c1 e2				ld hl, scratch 
4085					if DEBUG_FORTH_WORDS 
4085						DMARK "SP3" 
4085 f5				push af  
4086 3a 9a 40			ld a, (.dmark)  
4089 32 6b ee			ld (debug_mark),a  
408c 3a 9b 40			ld a, (.dmark+1)  
408f 32 6c ee			ld (debug_mark+1),a  
4092 3a 9c 40			ld a, (.dmark+2)  
4095 32 6d ee			ld (debug_mark+2),a  
4098 18 03			jr .pastdmark  
409a ..			.dmark: db "SP3"  
409d f1			.pastdmark: pop af  
409e			endm  
# End of macro DMARK
409e						CALLMONITOR 
409e cd 6f ee			call debug_vector  
40a1				endm  
# End of macro CALLMONITOR
40a1					endif 
40a1 cd c0 1c				call forth_push_str 
40a4			 
40a4				       NEXTW 
40a4 c3 ff 1f			jp macro_next 
40a7				endm 
# End of macro NEXTW
40a7			 
40a7			 
40a7			 
40a7			.SCROLL: 
40a7				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
40a7 53				db WORD_SYS_CORE+63             
40a8 d4 40			dw .SCROLLD            
40aa 07				db 6 + 1 
40ab .. 00			db "SCROLL",0              
40b2				endm 
# End of macro CWHEAD
40b2			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
40b2					if DEBUG_FORTH_WORDS_KEY 
40b2						DMARK "SCR" 
40b2 f5				push af  
40b3 3a c7 40			ld a, (.dmark)  
40b6 32 6b ee			ld (debug_mark),a  
40b9 3a c8 40			ld a, (.dmark+1)  
40bc 32 6c ee			ld (debug_mark+1),a  
40bf 3a c9 40			ld a, (.dmark+2)  
40c2 32 6d ee			ld (debug_mark+2),a  
40c5 18 03			jr .pastdmark  
40c7 ..			.dmark: db "SCR"  
40ca f1			.pastdmark: pop af  
40cb			endm  
# End of macro DMARK
40cb						CALLMONITOR 
40cb cd 6f ee			call debug_vector  
40ce				endm  
# End of macro CALLMONITOR
40ce					endif 
40ce			 
40ce cd 7b 0b			call scroll_up 
40d1			;	call update_display 
40d1			 
40d1					NEXTW 
40d1 c3 ff 1f			jp macro_next 
40d4				endm 
# End of macro NEXTW
40d4			 
40d4			 
40d4			 
40d4			;		; get dir 
40d4			; 
40d4			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40d4			; 
40d4			;		push hl 
40d4			; 
40d4			;		; destroy value TOS 
40d4			; 
40d4			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40d4			; 
40d4			;		; get count 
40d4			; 
40d4			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40d4			; 
40d4			;		push hl 
40d4			; 
40d4			;		; destroy value TOS 
40d4			; 
40d4			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40d4			; 
40d4			;		; one value on hl get other one back 
40d4			; 
40d4			;		pop bc    ; count 
40d4			; 
40d4			;		pop de   ; dir 
40d4			; 
40d4			; 
40d4			;		ld b, c 
40d4			; 
40d4			;.scrolldir:     push bc 
40d4			;		push de 
40d4			; 
40d4			;		ld a, 0 
40d4			;		cp e 
40d4			;		jr z, .scrollup  
40d4			;		call scroll_down 
40d4			;		jr .scrollnext 
40d4			;.scrollup:	call scroll_up 
40d4			; 
40d4			;		 
40d4			;.scrollnext: 
40d4			;		pop de 
40d4			;		pop bc 
40d4			;		djnz .scrolldir 
40d4			; 
40d4			; 
40d4			; 
40d4			; 
40d4			; 
40d4			;		NEXTW 
40d4			 
40d4			.SCROLLD: 
40d4				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
40d4 53				db WORD_SYS_CORE+63             
40d5 02 41			dw .ATQ            
40d7 08				db 7 + 1 
40d8 .. 00			db "SCROLLD",0              
40e0				endm 
# End of macro CWHEAD
40e0			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
40e0					if DEBUG_FORTH_WORDS_KEY 
40e0						DMARK "SCD" 
40e0 f5				push af  
40e1 3a f5 40			ld a, (.dmark)  
40e4 32 6b ee			ld (debug_mark),a  
40e7 3a f6 40			ld a, (.dmark+1)  
40ea 32 6c ee			ld (debug_mark+1),a  
40ed 3a f7 40			ld a, (.dmark+2)  
40f0 32 6d ee			ld (debug_mark+2),a  
40f3 18 03			jr .pastdmark  
40f5 ..			.dmark: db "SCD"  
40f8 f1			.pastdmark: pop af  
40f9			endm  
# End of macro DMARK
40f9						CALLMONITOR 
40f9 cd 6f ee			call debug_vector  
40fc				endm  
# End of macro CALLMONITOR
40fc					endif 
40fc			 
40fc cd 9f 0b			call scroll_down 
40ff			;	call update_display 
40ff			 
40ff					NEXTW 
40ff c3 ff 1f			jp macro_next 
4102				endm 
# End of macro NEXTW
4102			 
4102			 
4102			.ATQ: 
4102				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4102 62				db WORD_SYS_CORE+78             
4103 60 41			dw .AUTODSP            
4105 04				db 3 + 1 
4106 .. 00			db "AT@",0              
410a				endm 
# End of macro CWHEAD
410a			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
410a					if DEBUG_FORTH_WORDS_KEY 
410a						DMARK "ATA" 
410a f5				push af  
410b 3a 1f 41			ld a, (.dmark)  
410e 32 6b ee			ld (debug_mark),a  
4111 3a 20 41			ld a, (.dmark+1)  
4114 32 6c ee			ld (debug_mark+1),a  
4117 3a 21 41			ld a, (.dmark+2)  
411a 32 6d ee			ld (debug_mark+2),a  
411d 18 03			jr .pastdmark  
411f ..			.dmark: db "ATA"  
4122 f1			.pastdmark: pop af  
4123			endm  
# End of macro DMARK
4123						CALLMONITOR 
4123 cd 6f ee			call debug_vector  
4126				endm  
# End of macro CALLMONITOR
4126					endif 
4126			 
4126			 
4126					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4126 cd 49 1e			call macro_dsp_valuehl 
4129				endm 
# End of macro FORTH_DSP_VALUEHL
4129			 
4129					; TODO save cursor row 
4129 7d					ld a,l 
412a fe 02				cp 2 
412c 20 04				jr nz, .crow3aq 
412e 3e 28				ld a, display_row_2 
4130 18 12				jr .ccol1aq 
4132 fe 03		.crow3aq:		cp 3 
4134 20 04				jr nz, .crow4aq 
4136 3e 50				ld a, display_row_3 
4138 18 0a				jr .ccol1aq 
413a fe 04		.crow4aq:		cp 4 
413c 20 04				jr nz, .crow1aq 
413e 3e 78				ld a, display_row_4 
4140 18 02				jr .ccol1aq 
4142 3e 00		.crow1aq:		ld a,display_row_1 
4144 f5			.ccol1aq:		push af			; got row offset 
4145 6f					ld l,a 
4146 26 00				ld h,0 
4148					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4148 cd 01 1f			call macro_forth_dsp_pop 
414b				endm 
# End of macro FORTH_DSP_POP
414b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
414b cd 49 1e			call macro_dsp_valuehl 
414e				endm 
# End of macro FORTH_DSP_VALUEHL
414e					; TODO save cursor col 
414e f1					pop af 
414f 85					add l		; add col offset 
4150			 
4150					; add current frame buffer address 
4150 2a cc eb				ld hl, (display_fb_active) 
4153 cd e6 0d				call addatohl 
4156			 
4156			 
4156			 
4156			 
4156					; get char frame buffer location offset in hl 
4156			 
4156 7e					ld a,(hl) 
4157 26 00				ld h, 0 
4159 6f					ld l, a 
415a			 
415a cd 52 1c				call forth_push_numhl 
415d			 
415d			 
415d					NEXTW 
415d c3 ff 1f			jp macro_next 
4160				endm 
# End of macro NEXTW
4160			 
4160			.AUTODSP: 
4160				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4160 63				db WORD_SYS_CORE+79             
4161 76 41			dw .MENU            
4163 05				db 4 + 1 
4164 .. 00			db "ADSP",0              
4169				endm 
# End of macro CWHEAD
4169			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4169			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4169			 
4169					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4169 cd 49 1e			call macro_dsp_valuehl 
416c				endm 
# End of macro FORTH_DSP_VALUEHL
416c			 
416c			;		push hl 
416c			 
416c					; destroy value TOS 
416c			 
416c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
416c cd 01 1f			call macro_forth_dsp_pop 
416f				endm 
# End of macro FORTH_DSP_POP
416f			 
416f			;		pop hl 
416f			 
416f 7d					ld a,l 
4170 32 3c ea				ld (cli_autodisplay), a 
4173				       NEXTW 
4173 c3 ff 1f			jp macro_next 
4176				endm 
# End of macro NEXTW
4176			 
4176			.MENU: 
4176				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4176 70				db WORD_SYS_CORE+92             
4177 1f 42			dw .ENDDISPLAY            
4179 05				db 4 + 1 
417a .. 00			db "MENU",0              
417f				endm 
# End of macro CWHEAD
417f			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
417f			 
417f			;		; get number of items on the stack 
417f			; 
417f				 
417f					FORTH_DSP_VALUEHL 
417f cd 49 1e			call macro_dsp_valuehl 
4182				endm 
# End of macro FORTH_DSP_VALUEHL
4182				 
4182					if DEBUG_FORTH_WORDS_KEY 
4182						DMARK "MNU" 
4182 f5				push af  
4183 3a 97 41			ld a, (.dmark)  
4186 32 6b ee			ld (debug_mark),a  
4189 3a 98 41			ld a, (.dmark+1)  
418c 32 6c ee			ld (debug_mark+1),a  
418f 3a 99 41			ld a, (.dmark+2)  
4192 32 6d ee			ld (debug_mark+2),a  
4195 18 03			jr .pastdmark  
4197 ..			.dmark: db "MNU"  
419a f1			.pastdmark: pop af  
419b			endm  
# End of macro DMARK
419b						CALLMONITOR 
419b cd 6f ee			call debug_vector  
419e				endm  
# End of macro CALLMONITOR
419e					endif 
419e			 
419e 45					ld b, l	 
419f 05					dec b 
41a0			 
41a0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
41a0 cd 01 1f			call macro_forth_dsp_pop 
41a3				endm 
# End of macro FORTH_DSP_POP
41a3			 
41a3			 
41a3					; go directly through the stack to pluck out the string pointers and build an array 
41a3			 
41a3			;		FORTH_DSP 
41a3			 
41a3					; hl contains top most stack item 
41a3				 
41a3 11 c1 e2				ld de, scratch 
41a6			 
41a6			.mbuild: 
41a6			 
41a6					FORTH_DSP_VALUEHL 
41a6 cd 49 1e			call macro_dsp_valuehl 
41a9				endm 
# End of macro FORTH_DSP_VALUEHL
41a9			 
41a9					if DEBUG_FORTH_WORDS 
41a9						DMARK "MN3" 
41a9 f5				push af  
41aa 3a be 41			ld a, (.dmark)  
41ad 32 6b ee			ld (debug_mark),a  
41b0 3a bf 41			ld a, (.dmark+1)  
41b3 32 6c ee			ld (debug_mark+1),a  
41b6 3a c0 41			ld a, (.dmark+2)  
41b9 32 6d ee			ld (debug_mark+2),a  
41bc 18 03			jr .pastdmark  
41be ..			.dmark: db "MN3"  
41c1 f1			.pastdmark: pop af  
41c2			endm  
# End of macro DMARK
41c2						CALLMONITOR 
41c2 cd 6f ee			call debug_vector  
41c5				endm  
# End of macro CALLMONITOR
41c5					endif 
41c5 eb					ex de, hl 
41c6 73					ld (hl), e 
41c7 23					inc hl 
41c8 72					ld (hl), d 
41c9 23					inc hl 
41ca eb					ex de, hl 
41cb			 
41cb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
41cb cd 01 1f			call macro_forth_dsp_pop 
41ce				endm 
# End of macro FORTH_DSP_POP
41ce			 
41ce 10 d6				djnz .mbuild 
41d0			 
41d0					; done add term 
41d0			 
41d0 eb					ex de, hl 
41d1 36 00				ld (hl), 0 
41d3 23					inc hl 
41d4 36 00				ld (hl), 0 
41d6			 
41d6				 
41d6					 
41d6 21 c1 e2				ld hl, scratch 
41d9			 
41d9					if DEBUG_FORTH_WORDS 
41d9						DMARK "MNx" 
41d9 f5				push af  
41da 3a ee 41			ld a, (.dmark)  
41dd 32 6b ee			ld (debug_mark),a  
41e0 3a ef 41			ld a, (.dmark+1)  
41e3 32 6c ee			ld (debug_mark+1),a  
41e6 3a f0 41			ld a, (.dmark+2)  
41e9 32 6d ee			ld (debug_mark+2),a  
41ec 18 03			jr .pastdmark  
41ee ..			.dmark: db "MNx"  
41f1 f1			.pastdmark: pop af  
41f2			endm  
# End of macro DMARK
41f2						CALLMONITOR 
41f2 cd 6f ee			call debug_vector  
41f5				endm  
# End of macro CALLMONITOR
41f5					endif 
41f5			 
41f5			 
41f5			 
41f5 3e 00				ld a, 0 
41f7 cd ea 0b				call menu 
41fa			 
41fa			 
41fa 6f					ld l, a 
41fb 26 00				ld h, 0 
41fd			 
41fd					if DEBUG_FORTH_WORDS 
41fd						DMARK "MNr" 
41fd f5				push af  
41fe 3a 12 42			ld a, (.dmark)  
4201 32 6b ee			ld (debug_mark),a  
4204 3a 13 42			ld a, (.dmark+1)  
4207 32 6c ee			ld (debug_mark+1),a  
420a 3a 14 42			ld a, (.dmark+2)  
420d 32 6d ee			ld (debug_mark+2),a  
4210 18 03			jr .pastdmark  
4212 ..			.dmark: db "MNr"  
4215 f1			.pastdmark: pop af  
4216			endm  
# End of macro DMARK
4216						CALLMONITOR 
4216 cd 6f ee			call debug_vector  
4219				endm  
# End of macro CALLMONITOR
4219					endif 
4219			 
4219 cd 52 1c				call forth_push_numhl 
421c			 
421c			 
421c			 
421c			 
421c				       NEXTW 
421c c3 ff 1f			jp macro_next 
421f				endm 
# End of macro NEXTW
421f			 
421f			 
421f			.ENDDISPLAY: 
421f			 
421f			; eof 
# End of file forth_words_display.asm
421f			include "forth_words_str.asm" 
421f			 
421f			; | ## String Words 
421f			 
421f			.PTR:   
421f			 
421f				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
421f 48				db WORD_SYS_CORE+52             
4220 4c 42			dw .STYPE            
4222 04				db 3 + 1 
4223 .. 00			db "PTR",0              
4227				endm 
# End of macro CWHEAD
4227			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4227			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4227			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4227			 
4227					if DEBUG_FORTH_WORDS_KEY 
4227						DMARK "PTR" 
4227 f5				push af  
4228 3a 3c 42			ld a, (.dmark)  
422b 32 6b ee			ld (debug_mark),a  
422e 3a 3d 42			ld a, (.dmark+1)  
4231 32 6c ee			ld (debug_mark+1),a  
4234 3a 3e 42			ld a, (.dmark+2)  
4237 32 6d ee			ld (debug_mark+2),a  
423a 18 03			jr .pastdmark  
423c ..			.dmark: db "PTR"  
423f f1			.pastdmark: pop af  
4240			endm  
# End of macro DMARK
4240						CALLMONITOR 
4240 cd 6f ee			call debug_vector  
4243				endm  
# End of macro CALLMONITOR
4243					endif 
4243					FORTH_DSP_VALUEHL 
4243 cd 49 1e			call macro_dsp_valuehl 
4246				endm 
# End of macro FORTH_DSP_VALUEHL
4246 cd 52 1c				call forth_push_numhl 
4249			 
4249			 
4249					NEXTW 
4249 c3 ff 1f			jp macro_next 
424c				endm 
# End of macro NEXTW
424c			.STYPE: 
424c				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
424c 48				db WORD_SYS_CORE+52             
424d 9b 42			dw .UPPER            
424f 06				db 5 + 1 
4250 .. 00			db "STYPE",0              
4256				endm 
# End of macro CWHEAD
4256			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4256					if DEBUG_FORTH_WORDS_KEY 
4256						DMARK "STY" 
4256 f5				push af  
4257 3a 6b 42			ld a, (.dmark)  
425a 32 6b ee			ld (debug_mark),a  
425d 3a 6c 42			ld a, (.dmark+1)  
4260 32 6c ee			ld (debug_mark+1),a  
4263 3a 6d 42			ld a, (.dmark+2)  
4266 32 6d ee			ld (debug_mark+2),a  
4269 18 03			jr .pastdmark  
426b ..			.dmark: db "STY"  
426e f1			.pastdmark: pop af  
426f			endm  
# End of macro DMARK
426f						CALLMONITOR 
426f cd 6f ee			call debug_vector  
4272				endm  
# End of macro CALLMONITOR
4272					endif 
4272					FORTH_DSP 
4272 cd 0f 1e			call macro_forth_dsp 
4275				endm 
# End of macro FORTH_DSP
4275					;v5 FORTH_DSP_VALUE 
4275			 
4275 7e					ld a, (hl) 
4276			 
4276 f5					push af 
4277			 
4277			; Dont destroy TOS		FORTH_DSP_POP 
4277			 
4277 f1					pop af 
4278			 
4278 fe 01				cp DS_TYPE_STR 
427a 28 09				jr z, .typestr 
427c			 
427c fe 02				cp DS_TYPE_INUM 
427e 28 0a				jr z, .typeinum 
4280			 
4280 21 99 42				ld hl, .tna 
4283 18 0a				jr .tpush 
4285			 
4285 21 95 42		.typestr:	ld hl, .tstr 
4288 18 05				jr .tpush 
428a 21 97 42		.typeinum:	ld hl, .tinum 
428d 18 00				jr .tpush 
428f			 
428f			.tpush: 
428f			 
428f cd c0 1c				call forth_push_str 
4292			 
4292					NEXTW 
4292 c3 ff 1f			jp macro_next 
4295				endm 
# End of macro NEXTW
4295 .. 00		.tstr:	db "s",0 
4297 .. 00		.tinum:  db "i",0 
4299 .. 00		.tna:   db "?", 0 
429b			 
429b			 
429b			.UPPER: 
429b				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
429b 48				db WORD_SYS_CORE+52             
429c d6 42			dw .LOWER            
429e 06				db 5 + 1 
429f .. 00			db "UPPER",0              
42a5				endm 
# End of macro CWHEAD
42a5			; | UPPER ( s -- s ) Upper case string s  | DONE 
42a5					if DEBUG_FORTH_WORDS_KEY 
42a5						DMARK "UPR" 
42a5 f5				push af  
42a6 3a ba 42			ld a, (.dmark)  
42a9 32 6b ee			ld (debug_mark),a  
42ac 3a bb 42			ld a, (.dmark+1)  
42af 32 6c ee			ld (debug_mark+1),a  
42b2 3a bc 42			ld a, (.dmark+2)  
42b5 32 6d ee			ld (debug_mark+2),a  
42b8 18 03			jr .pastdmark  
42ba ..			.dmark: db "UPR"  
42bd f1			.pastdmark: pop af  
42be			endm  
# End of macro DMARK
42be						CALLMONITOR 
42be cd 6f ee			call debug_vector  
42c1				endm  
# End of macro CALLMONITOR
42c1					endif 
42c1			 
42c1					FORTH_DSP 
42c1 cd 0f 1e			call macro_forth_dsp 
42c4				endm 
# End of macro FORTH_DSP
42c4					 
42c4			; TODO check is string type 
42c4			 
42c4					FORTH_DSP_VALUEHL 
42c4 cd 49 1e			call macro_dsp_valuehl 
42c7				endm 
# End of macro FORTH_DSP_VALUEHL
42c7			; get pointer to string in hl 
42c7			 
42c7 7e			.toup:		ld a, (hl) 
42c8 fe 00				cp 0 
42ca 28 07				jr z, .toupdone 
42cc			 
42cc cd 53 11				call to_upper 
42cf			 
42cf 77					ld (hl), a 
42d0 23					inc hl 
42d1 18 f4				jr .toup 
42d3			 
42d3					 
42d3			 
42d3			 
42d3			; for each char convert to upper 
42d3					 
42d3			.toupdone: 
42d3			 
42d3			 
42d3					NEXTW 
42d3 c3 ff 1f			jp macro_next 
42d6				endm 
# End of macro NEXTW
42d6			.LOWER: 
42d6				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
42d6 48				db WORD_SYS_CORE+52             
42d7 11 43			dw .TCASE            
42d9 06				db 5 + 1 
42da .. 00			db "LOWER",0              
42e0				endm 
# End of macro CWHEAD
42e0			; | LOWER ( s -- s ) Lower case string s  | DONE 
42e0					if DEBUG_FORTH_WORDS_KEY 
42e0						DMARK "LWR" 
42e0 f5				push af  
42e1 3a f5 42			ld a, (.dmark)  
42e4 32 6b ee			ld (debug_mark),a  
42e7 3a f6 42			ld a, (.dmark+1)  
42ea 32 6c ee			ld (debug_mark+1),a  
42ed 3a f7 42			ld a, (.dmark+2)  
42f0 32 6d ee			ld (debug_mark+2),a  
42f3 18 03			jr .pastdmark  
42f5 ..			.dmark: db "LWR"  
42f8 f1			.pastdmark: pop af  
42f9			endm  
# End of macro DMARK
42f9						CALLMONITOR 
42f9 cd 6f ee			call debug_vector  
42fc				endm  
# End of macro CALLMONITOR
42fc					endif 
42fc			 
42fc					FORTH_DSP 
42fc cd 0f 1e			call macro_forth_dsp 
42ff				endm 
# End of macro FORTH_DSP
42ff					 
42ff			; TODO check is string type 
42ff			 
42ff					FORTH_DSP_VALUEHL 
42ff cd 49 1e			call macro_dsp_valuehl 
4302				endm 
# End of macro FORTH_DSP_VALUEHL
4302			; get pointer to string in hl 
4302			 
4302 7e			.tolow:		ld a, (hl) 
4303 fe 00				cp 0 
4305 28 07				jr z, .tolowdone 
4307			 
4307 cd 5c 11				call to_lower 
430a			 
430a 77					ld (hl), a 
430b 23					inc hl 
430c 18 f4				jr .tolow 
430e			 
430e					 
430e			 
430e			 
430e			; for each char convert to low 
430e					 
430e			.tolowdone: 
430e					NEXTW 
430e c3 ff 1f			jp macro_next 
4311				endm 
# End of macro NEXTW
4311			.TCASE: 
4311				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4311 48				db WORD_SYS_CORE+52             
4312 47 44			dw .SUBSTR            
4314 06				db 5 + 1 
4315 .. 00			db "TCASE",0              
431b				endm 
# End of macro CWHEAD
431b			; | TCASE ( s -- s ) Title case string s  | DONE 
431b					if DEBUG_FORTH_WORDS_KEY 
431b						DMARK "TCS" 
431b f5				push af  
431c 3a 30 43			ld a, (.dmark)  
431f 32 6b ee			ld (debug_mark),a  
4322 3a 31 43			ld a, (.dmark+1)  
4325 32 6c ee			ld (debug_mark+1),a  
4328 3a 32 43			ld a, (.dmark+2)  
432b 32 6d ee			ld (debug_mark+2),a  
432e 18 03			jr .pastdmark  
4330 ..			.dmark: db "TCS"  
4333 f1			.pastdmark: pop af  
4334			endm  
# End of macro DMARK
4334						CALLMONITOR 
4334 cd 6f ee			call debug_vector  
4337				endm  
# End of macro CALLMONITOR
4337					endif 
4337			 
4337					FORTH_DSP 
4337 cd 0f 1e			call macro_forth_dsp 
433a				endm 
# End of macro FORTH_DSP
433a					 
433a			; TODO check is string type 
433a			 
433a					FORTH_DSP_VALUEHL 
433a cd 49 1e			call macro_dsp_valuehl 
433d				endm 
# End of macro FORTH_DSP_VALUEHL
433d			; get pointer to string in hl 
433d			 
433d					if DEBUG_FORTH_WORDS 
433d						DMARK "TC1" 
433d f5				push af  
433e 3a 52 43			ld a, (.dmark)  
4341 32 6b ee			ld (debug_mark),a  
4344 3a 53 43			ld a, (.dmark+1)  
4347 32 6c ee			ld (debug_mark+1),a  
434a 3a 54 43			ld a, (.dmark+2)  
434d 32 6d ee			ld (debug_mark+2),a  
4350 18 03			jr .pastdmark  
4352 ..			.dmark: db "TC1"  
4355 f1			.pastdmark: pop af  
4356			endm  
# End of macro DMARK
4356						CALLMONITOR 
4356 cd 6f ee			call debug_vector  
4359				endm  
# End of macro CALLMONITOR
4359					endif 
4359			 
4359					; first time in turn to upper case first char 
4359			 
4359 7e					ld a, (hl) 
435a c3 e4 43				jp .totsiptou 
435d			 
435d			 
435d 7e			.tot:		ld a, (hl) 
435e fe 00				cp 0 
4360 ca 28 44				jp z, .totdone 
4363			 
4363					if DEBUG_FORTH_WORDS 
4363						DMARK "TC2" 
4363 f5				push af  
4364 3a 78 43			ld a, (.dmark)  
4367 32 6b ee			ld (debug_mark),a  
436a 3a 79 43			ld a, (.dmark+1)  
436d 32 6c ee			ld (debug_mark+1),a  
4370 3a 7a 43			ld a, (.dmark+2)  
4373 32 6d ee			ld (debug_mark+2),a  
4376 18 03			jr .pastdmark  
4378 ..			.dmark: db "TC2"  
437b f1			.pastdmark: pop af  
437c			endm  
# End of macro DMARK
437c						CALLMONITOR 
437c cd 6f ee			call debug_vector  
437f				endm  
# End of macro CALLMONITOR
437f					endif 
437f					; check to see if current char is a space 
437f			 
437f fe 20				cp ' ' 
4381 28 21				jr z, .totsp 
4383 cd 5c 11				call to_lower 
4386					if DEBUG_FORTH_WORDS 
4386						DMARK "TC3" 
4386 f5				push af  
4387 3a 9b 43			ld a, (.dmark)  
438a 32 6b ee			ld (debug_mark),a  
438d 3a 9c 43			ld a, (.dmark+1)  
4390 32 6c ee			ld (debug_mark+1),a  
4393 3a 9d 43			ld a, (.dmark+2)  
4396 32 6d ee			ld (debug_mark+2),a  
4399 18 03			jr .pastdmark  
439b ..			.dmark: db "TC3"  
439e f1			.pastdmark: pop af  
439f			endm  
# End of macro DMARK
439f						CALLMONITOR 
439f cd 6f ee			call debug_vector  
43a2				endm  
# End of macro CALLMONITOR
43a2					endif 
43a2 18 63				jr .totnxt 
43a4			 
43a4			.totsp:         ; on a space, find next char which should be upper 
43a4			 
43a4					if DEBUG_FORTH_WORDS 
43a4						DMARK "TC4" 
43a4 f5				push af  
43a5 3a b9 43			ld a, (.dmark)  
43a8 32 6b ee			ld (debug_mark),a  
43ab 3a ba 43			ld a, (.dmark+1)  
43ae 32 6c ee			ld (debug_mark+1),a  
43b1 3a bb 43			ld a, (.dmark+2)  
43b4 32 6d ee			ld (debug_mark+2),a  
43b7 18 03			jr .pastdmark  
43b9 ..			.dmark: db "TC4"  
43bc f1			.pastdmark: pop af  
43bd			endm  
# End of macro DMARK
43bd						CALLMONITOR 
43bd cd 6f ee			call debug_vector  
43c0				endm  
# End of macro CALLMONITOR
43c0					endif 
43c0					;; 
43c0			 
43c0 fe 20				cp ' ' 
43c2 20 20				jr nz, .totsiptou 
43c4 23					inc hl 
43c5 7e					ld a, (hl) 
43c6					if DEBUG_FORTH_WORDS 
43c6						DMARK "TC5" 
43c6 f5				push af  
43c7 3a db 43			ld a, (.dmark)  
43ca 32 6b ee			ld (debug_mark),a  
43cd 3a dc 43			ld a, (.dmark+1)  
43d0 32 6c ee			ld (debug_mark+1),a  
43d3 3a dd 43			ld a, (.dmark+2)  
43d6 32 6d ee			ld (debug_mark+2),a  
43d9 18 03			jr .pastdmark  
43db ..			.dmark: db "TC5"  
43de f1			.pastdmark: pop af  
43df			endm  
# End of macro DMARK
43df						CALLMONITOR 
43df cd 6f ee			call debug_vector  
43e2				endm  
# End of macro CALLMONITOR
43e2					endif 
43e2 18 c0				jr .totsp 
43e4 fe 00		.totsiptou:    cp 0 
43e6 28 40				jr z, .totdone 
43e8					; not space and not zero term so upper case it 
43e8 cd 53 11				call to_upper 
43eb			 
43eb					if DEBUG_FORTH_WORDS 
43eb						DMARK "TC6" 
43eb f5				push af  
43ec 3a 00 44			ld a, (.dmark)  
43ef 32 6b ee			ld (debug_mark),a  
43f2 3a 01 44			ld a, (.dmark+1)  
43f5 32 6c ee			ld (debug_mark+1),a  
43f8 3a 02 44			ld a, (.dmark+2)  
43fb 32 6d ee			ld (debug_mark+2),a  
43fe 18 03			jr .pastdmark  
4400 ..			.dmark: db "TC6"  
4403 f1			.pastdmark: pop af  
4404			endm  
# End of macro DMARK
4404						CALLMONITOR 
4404 cd 6f ee			call debug_vector  
4407				endm  
# End of macro CALLMONITOR
4407					endif 
4407			 
4407			 
4407			.totnxt: 
4407			 
4407 77					ld (hl), a 
4408 23					inc hl 
4409					if DEBUG_FORTH_WORDS 
4409						DMARK "TC7" 
4409 f5				push af  
440a 3a 1e 44			ld a, (.dmark)  
440d 32 6b ee			ld (debug_mark),a  
4410 3a 1f 44			ld a, (.dmark+1)  
4413 32 6c ee			ld (debug_mark+1),a  
4416 3a 20 44			ld a, (.dmark+2)  
4419 32 6d ee			ld (debug_mark+2),a  
441c 18 03			jr .pastdmark  
441e ..			.dmark: db "TC7"  
4421 f1			.pastdmark: pop af  
4422			endm  
# End of macro DMARK
4422						CALLMONITOR 
4422 cd 6f ee			call debug_vector  
4425				endm  
# End of macro CALLMONITOR
4425					endif 
4425 c3 5d 43				jp .tot 
4428			 
4428					 
4428			 
4428			 
4428			; for each char convert to low 
4428					 
4428			.totdone: 
4428					if DEBUG_FORTH_WORDS 
4428						DMARK "TCd" 
4428 f5				push af  
4429 3a 3d 44			ld a, (.dmark)  
442c 32 6b ee			ld (debug_mark),a  
442f 3a 3e 44			ld a, (.dmark+1)  
4432 32 6c ee			ld (debug_mark+1),a  
4435 3a 3f 44			ld a, (.dmark+2)  
4438 32 6d ee			ld (debug_mark+2),a  
443b 18 03			jr .pastdmark  
443d ..			.dmark: db "TCd"  
4440 f1			.pastdmark: pop af  
4441			endm  
# End of macro DMARK
4441						CALLMONITOR 
4441 cd 6f ee			call debug_vector  
4444				endm  
# End of macro CALLMONITOR
4444					endif 
4444					NEXTW 
4444 c3 ff 1f			jp macro_next 
4447				endm 
# End of macro NEXTW
4447			 
4447			.SUBSTR: 
4447				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4447 48				db WORD_SYS_CORE+52             
4448 a5 44			dw .LEFT            
444a 07				db 6 + 1 
444b .. 00			db "SUBSTR",0              
4452				endm 
# End of macro CWHEAD
4452			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4452			 
4452					if DEBUG_FORTH_WORDS_KEY 
4452						DMARK "SST" 
4452 f5				push af  
4453 3a 67 44			ld a, (.dmark)  
4456 32 6b ee			ld (debug_mark),a  
4459 3a 68 44			ld a, (.dmark+1)  
445c 32 6c ee			ld (debug_mark+1),a  
445f 3a 69 44			ld a, (.dmark+2)  
4462 32 6d ee			ld (debug_mark+2),a  
4465 18 03			jr .pastdmark  
4467 ..			.dmark: db "SST"  
446a f1			.pastdmark: pop af  
446b			endm  
# End of macro DMARK
446b						CALLMONITOR 
446b cd 6f ee			call debug_vector  
446e				endm  
# End of macro CALLMONITOR
446e					endif 
446e			; TODO check string type 
446e					FORTH_DSP_VALUEHL 
446e cd 49 1e			call macro_dsp_valuehl 
4471				endm 
# End of macro FORTH_DSP_VALUEHL
4471			 
4471 e5					push hl      ; string length 
4472			 
4472					FORTH_DSP_POP 
4472 cd 01 1f			call macro_forth_dsp_pop 
4475				endm 
# End of macro FORTH_DSP_POP
4475			 
4475					FORTH_DSP_VALUEHL 
4475 cd 49 1e			call macro_dsp_valuehl 
4478				endm 
# End of macro FORTH_DSP_VALUEHL
4478			 
4478 e5					push hl     ; start char 
4479			 
4479					FORTH_DSP_POP 
4479 cd 01 1f			call macro_forth_dsp_pop 
447c				endm 
# End of macro FORTH_DSP_POP
447c			 
447c			 
447c					FORTH_DSP_VALUE 
447c cd 32 1e			call macro_forth_dsp_value 
447f				endm 
# End of macro FORTH_DSP_VALUE
447f			 
447f d1					pop de    ; get start post offset 
4480			 
4480 19					add hl, de    ; starting offset 
4481			 
4481 c1					pop bc 
4482 c5					push bc      ; grab size of string 
4483			 
4483 e5					push hl    ; save string start  
4484			 
4484 26 00				ld h, 0 
4486 69					ld l, c 
4487 23					inc hl 
4488 23					inc hl 
4489			 
4489 cd b9 12				call malloc 
448c				if DEBUG_FORTH_MALLOC_GUARD 
448c cc bf 4d				call z,malloc_error 
448f				endif 
448f			 
448f eb					ex de, hl      ; save malloc area for string copy 
4490 e1					pop hl    ; get back source 
4491 c1					pop bc    ; get length of string back 
4492			 
4492 d5					push de    ; save malloc area for after we push 
4493 ed b0				ldir     ; copy substr 
4495			 
4495			 
4495 eb					ex de, hl 
4496 3e 00				ld a, 0 
4498 77					ld (hl), a   ; term substr 
4499			 
4499					 
4499 e1					pop hl    ; get malloc so we can push it 
449a e5					push hl   ; save so we can free it afterwards 
449b			 
449b cd c0 1c				call forth_push_str 
449e			 
449e e1					pop hl 
449f cd 83 13				call free 
44a2			 
44a2					 
44a2					 
44a2			 
44a2			 
44a2					NEXTW 
44a2 c3 ff 1f			jp macro_next 
44a5				endm 
# End of macro NEXTW
44a5			 
44a5			.LEFT: 
44a5				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
44a5 48				db WORD_SYS_CORE+52             
44a6 cd 44			dw .RIGHT            
44a8 05				db 4 + 1 
44a9 .. 00			db "LEFT",0              
44ae				endm 
# End of macro CWHEAD
44ae			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
44ae					if DEBUG_FORTH_WORDS_KEY 
44ae						DMARK "LEF" 
44ae f5				push af  
44af 3a c3 44			ld a, (.dmark)  
44b2 32 6b ee			ld (debug_mark),a  
44b5 3a c4 44			ld a, (.dmark+1)  
44b8 32 6c ee			ld (debug_mark+1),a  
44bb 3a c5 44			ld a, (.dmark+2)  
44be 32 6d ee			ld (debug_mark+2),a  
44c1 18 03			jr .pastdmark  
44c3 ..			.dmark: db "LEF"  
44c6 f1			.pastdmark: pop af  
44c7			endm  
# End of macro DMARK
44c7						CALLMONITOR 
44c7 cd 6f ee			call debug_vector  
44ca				endm  
# End of macro CALLMONITOR
44ca					endif 
44ca			 
44ca					NEXTW 
44ca c3 ff 1f			jp macro_next 
44cd				endm 
# End of macro NEXTW
44cd			.RIGHT: 
44cd				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
44cd 48				db WORD_SYS_CORE+52             
44ce f6 44			dw .STR2NUM            
44d0 06				db 5 + 1 
44d1 .. 00			db "RIGHT",0              
44d7				endm 
# End of macro CWHEAD
44d7			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
44d7					if DEBUG_FORTH_WORDS_KEY 
44d7						DMARK "RIG" 
44d7 f5				push af  
44d8 3a ec 44			ld a, (.dmark)  
44db 32 6b ee			ld (debug_mark),a  
44de 3a ed 44			ld a, (.dmark+1)  
44e1 32 6c ee			ld (debug_mark+1),a  
44e4 3a ee 44			ld a, (.dmark+2)  
44e7 32 6d ee			ld (debug_mark+2),a  
44ea 18 03			jr .pastdmark  
44ec ..			.dmark: db "RIG"  
44ef f1			.pastdmark: pop af  
44f0			endm  
# End of macro DMARK
44f0						CALLMONITOR 
44f0 cd 6f ee			call debug_vector  
44f3				endm  
# End of macro CALLMONITOR
44f3					endif 
44f3			 
44f3					NEXTW 
44f3 c3 ff 1f			jp macro_next 
44f6				endm 
# End of macro NEXTW
44f6			 
44f6			 
44f6			.STR2NUM: 
44f6				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
44f6 48				db WORD_SYS_CORE+52             
44f7 82 45			dw .NUM2STR            
44f9 08				db 7 + 1 
44fa .. 00			db "STR2NUM",0              
4502				endm 
# End of macro CWHEAD
4502			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4502			 
4502			 
4502			; TODO STR type check to do 
4502					if DEBUG_FORTH_WORDS_KEY 
4502						DMARK "S2N" 
4502 f5				push af  
4503 3a 17 45			ld a, (.dmark)  
4506 32 6b ee			ld (debug_mark),a  
4509 3a 18 45			ld a, (.dmark+1)  
450c 32 6c ee			ld (debug_mark+1),a  
450f 3a 19 45			ld a, (.dmark+2)  
4512 32 6d ee			ld (debug_mark+2),a  
4515 18 03			jr .pastdmark  
4517 ..			.dmark: db "S2N"  
451a f1			.pastdmark: pop af  
451b			endm  
# End of macro DMARK
451b						CALLMONITOR 
451b cd 6f ee			call debug_vector  
451e				endm  
# End of macro CALLMONITOR
451e					endif 
451e			 
451e					;FORTH_DSP 
451e					FORTH_DSP_VALUE 
451e cd 32 1e			call macro_forth_dsp_value 
4521				endm 
# End of macro FORTH_DSP_VALUE
4521					;inc hl 
4521			 
4521 eb					ex de, hl 
4522					if DEBUG_FORTH_WORDS 
4522						DMARK "S2a" 
4522 f5				push af  
4523 3a 37 45			ld a, (.dmark)  
4526 32 6b ee			ld (debug_mark),a  
4529 3a 38 45			ld a, (.dmark+1)  
452c 32 6c ee			ld (debug_mark+1),a  
452f 3a 39 45			ld a, (.dmark+2)  
4532 32 6d ee			ld (debug_mark+2),a  
4535 18 03			jr .pastdmark  
4537 ..			.dmark: db "S2a"  
453a f1			.pastdmark: pop af  
453b			endm  
# End of macro DMARK
453b						CALLMONITOR 
453b cd 6f ee			call debug_vector  
453e				endm  
# End of macro CALLMONITOR
453e					endif 
453e cd db 11				call string_to_uint16 
4541			 
4541					if DEBUG_FORTH_WORDS 
4541						DMARK "S2b" 
4541 f5				push af  
4542 3a 56 45			ld a, (.dmark)  
4545 32 6b ee			ld (debug_mark),a  
4548 3a 57 45			ld a, (.dmark+1)  
454b 32 6c ee			ld (debug_mark+1),a  
454e 3a 58 45			ld a, (.dmark+2)  
4551 32 6d ee			ld (debug_mark+2),a  
4554 18 03			jr .pastdmark  
4556 ..			.dmark: db "S2b"  
4559 f1			.pastdmark: pop af  
455a			endm  
# End of macro DMARK
455a						CALLMONITOR 
455a cd 6f ee			call debug_vector  
455d				endm  
# End of macro CALLMONITOR
455d					endif 
455d			;		push hl 
455d					FORTH_DSP_POP 
455d cd 01 1f			call macro_forth_dsp_pop 
4560				endm 
# End of macro FORTH_DSP_POP
4560			;		pop hl 
4560					 
4560					if DEBUG_FORTH_WORDS 
4560						DMARK "S2b" 
4560 f5				push af  
4561 3a 75 45			ld a, (.dmark)  
4564 32 6b ee			ld (debug_mark),a  
4567 3a 76 45			ld a, (.dmark+1)  
456a 32 6c ee			ld (debug_mark+1),a  
456d 3a 77 45			ld a, (.dmark+2)  
4570 32 6d ee			ld (debug_mark+2),a  
4573 18 03			jr .pastdmark  
4575 ..			.dmark: db "S2b"  
4578 f1			.pastdmark: pop af  
4579			endm  
# End of macro DMARK
4579						CALLMONITOR 
4579 cd 6f ee			call debug_vector  
457c				endm  
# End of macro CALLMONITOR
457c					endif 
457c cd 52 1c				call forth_push_numhl	 
457f			 
457f				 
457f				       NEXTW 
457f c3 ff 1f			jp macro_next 
4582				endm 
# End of macro NEXTW
4582			.NUM2STR: 
4582				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4582 48				db WORD_SYS_CORE+52             
4583 91 45			dw .CONCAT            
4585 08				db 7 + 1 
4586 .. 00			db "NUM2STR",0              
458e				endm 
# End of macro CWHEAD
458e			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
458e			 
458e			;		; malloc a string to target 
458e			;		ld hl, 10     ; TODO max string size should be fine 
458e			;		call malloc 
458e			;		push hl    ; save malloc location 
458e			; 
458e			; 
458e			;; TODO check int type 
458e			;		FORTH_DSP_VALUEHL 
458e			;		ld a, l 
458e			;		call DispAToASCII   
458e			;;TODO need to chage above call to dump into string 
458e			; 
458e			; 
458e			 
458e				       NEXTW 
458e c3 ff 1f			jp macro_next 
4591				endm 
# End of macro NEXTW
4591			 
4591			.CONCAT: 
4591				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4591 48				db WORD_SYS_CORE+52             
4592 44 46			dw .FIND            
4594 07				db 6 + 1 
4595 .. 00			db "CONCAT",0              
459c				endm 
# End of macro CWHEAD
459c			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
459c			 
459c			; TODO check string type 
459c			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
459c			 
459c					if DEBUG_FORTH_WORDS_KEY 
459c						DMARK "CON" 
459c f5				push af  
459d 3a b1 45			ld a, (.dmark)  
45a0 32 6b ee			ld (debug_mark),a  
45a3 3a b2 45			ld a, (.dmark+1)  
45a6 32 6c ee			ld (debug_mark+1),a  
45a9 3a b3 45			ld a, (.dmark+2)  
45ac 32 6d ee			ld (debug_mark+2),a  
45af 18 03			jr .pastdmark  
45b1 ..			.dmark: db "CON"  
45b4 f1			.pastdmark: pop af  
45b5			endm  
# End of macro DMARK
45b5						CALLMONITOR 
45b5 cd 6f ee			call debug_vector  
45b8				endm  
# End of macro CALLMONITOR
45b8					endif 
45b8			 
45b8			 
45b8					FORTH_DSP_VALUE 
45b8 cd 32 1e			call macro_forth_dsp_value 
45bb				endm 
# End of macro FORTH_DSP_VALUE
45bb e5					push hl   ; s2 
45bc			 
45bc					FORTH_DSP_POP 
45bc cd 01 1f			call macro_forth_dsp_pop 
45bf				endm 
# End of macro FORTH_DSP_POP
45bf			 
45bf					FORTH_DSP_VALUE 
45bf cd 32 1e			call macro_forth_dsp_value 
45c2				endm 
# End of macro FORTH_DSP_VALUE
45c2			 
45c2 e5					push hl   ; s1 
45c3			 
45c3					FORTH_DSP_POP 
45c3 cd 01 1f			call macro_forth_dsp_pop 
45c6				endm 
# End of macro FORTH_DSP_POP
45c6					 
45c6			 
45c6					; copy s1 
45c6			 
45c6				 
45c6					; save ptr 
45c6 e1					pop hl  
45c7 e5					push hl 
45c8 3e 00				ld a, 0 
45ca cd 4f 12				call strlent 
45cd					;inc hl    ; zer0 
45cd 06 00				ld b, 0 
45cf 4d					ld c, l 
45d0 e1					pop hl		 
45d1 11 c1 e2				ld de, scratch	 
45d4					if DEBUG_FORTH_WORDS 
45d4						DMARK "CO1" 
45d4 f5				push af  
45d5 3a e9 45			ld a, (.dmark)  
45d8 32 6b ee			ld (debug_mark),a  
45db 3a ea 45			ld a, (.dmark+1)  
45de 32 6c ee			ld (debug_mark+1),a  
45e1 3a eb 45			ld a, (.dmark+2)  
45e4 32 6d ee			ld (debug_mark+2),a  
45e7 18 03			jr .pastdmark  
45e9 ..			.dmark: db "CO1"  
45ec f1			.pastdmark: pop af  
45ed			endm  
# End of macro DMARK
45ed						CALLMONITOR 
45ed cd 6f ee			call debug_vector  
45f0				endm  
# End of macro CALLMONITOR
45f0					endif 
45f0 ed b0				ldir 
45f2			 
45f2 e1					pop hl 
45f3 e5					push hl 
45f4 d5					push de 
45f5			 
45f5			 
45f5 3e 00				ld a, 0 
45f7 cd 4f 12				call strlent 
45fa 23					inc hl    ; zer0 
45fb 23					inc hl 
45fc 06 00				ld b, 0 
45fe 4d					ld c, l 
45ff d1					pop de 
4600 e1					pop hl		 
4601					if DEBUG_FORTH_WORDS 
4601						DMARK "CO2" 
4601 f5				push af  
4602 3a 16 46			ld a, (.dmark)  
4605 32 6b ee			ld (debug_mark),a  
4608 3a 17 46			ld a, (.dmark+1)  
460b 32 6c ee			ld (debug_mark+1),a  
460e 3a 18 46			ld a, (.dmark+2)  
4611 32 6d ee			ld (debug_mark+2),a  
4614 18 03			jr .pastdmark  
4616 ..			.dmark: db "CO2"  
4619 f1			.pastdmark: pop af  
461a			endm  
# End of macro DMARK
461a						CALLMONITOR 
461a cd 6f ee			call debug_vector  
461d				endm  
# End of macro CALLMONITOR
461d					endif 
461d ed b0				ldir 
461f			 
461f			 
461f			 
461f 21 c1 e2				ld hl, scratch 
4622					if DEBUG_FORTH_WORDS 
4622						DMARK "CO5" 
4622 f5				push af  
4623 3a 37 46			ld a, (.dmark)  
4626 32 6b ee			ld (debug_mark),a  
4629 3a 38 46			ld a, (.dmark+1)  
462c 32 6c ee			ld (debug_mark+1),a  
462f 3a 39 46			ld a, (.dmark+2)  
4632 32 6d ee			ld (debug_mark+2),a  
4635 18 03			jr .pastdmark  
4637 ..			.dmark: db "CO5"  
463a f1			.pastdmark: pop af  
463b			endm  
# End of macro DMARK
463b						CALLMONITOR 
463b cd 6f ee			call debug_vector  
463e				endm  
# End of macro CALLMONITOR
463e					endif 
463e			 
463e cd c0 1c				call forth_push_str 
4641			 
4641			 
4641			 
4641			 
4641				       NEXTW 
4641 c3 ff 1f			jp macro_next 
4644				endm 
# End of macro NEXTW
4644			 
4644			 
4644			.FIND: 
4644				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4644 4b				db WORD_SYS_CORE+55             
4645 02 47			dw .LEN            
4647 05				db 4 + 1 
4648 .. 00			db "FIND",0              
464d				endm 
# End of macro CWHEAD
464d			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
464d			 
464d					if DEBUG_FORTH_WORDS_KEY 
464d						DMARK "FND" 
464d f5				push af  
464e 3a 62 46			ld a, (.dmark)  
4651 32 6b ee			ld (debug_mark),a  
4654 3a 63 46			ld a, (.dmark+1)  
4657 32 6c ee			ld (debug_mark+1),a  
465a 3a 64 46			ld a, (.dmark+2)  
465d 32 6d ee			ld (debug_mark+2),a  
4660 18 03			jr .pastdmark  
4662 ..			.dmark: db "FND"  
4665 f1			.pastdmark: pop af  
4666			endm  
# End of macro DMARK
4666						CALLMONITOR 
4666 cd 6f ee			call debug_vector  
4669				endm  
# End of macro CALLMONITOR
4669					endif 
4669			 
4669			; TODO check string type 
4669					FORTH_DSP_VALUE 
4669 cd 32 1e			call macro_forth_dsp_value 
466c				endm 
# End of macro FORTH_DSP_VALUE
466c			 
466c e5					push hl    
466d 7e					ld a,(hl)    ; char to find   
466e			; TODO change char to substr 
466e			 
466e f5					push af 
466f					 
466f			 
466f			 
466f					if DEBUG_FORTH_WORDS 
466f						DMARK "FN1" 
466f f5				push af  
4670 3a 84 46			ld a, (.dmark)  
4673 32 6b ee			ld (debug_mark),a  
4676 3a 85 46			ld a, (.dmark+1)  
4679 32 6c ee			ld (debug_mark+1),a  
467c 3a 86 46			ld a, (.dmark+2)  
467f 32 6d ee			ld (debug_mark+2),a  
4682 18 03			jr .pastdmark  
4684 ..			.dmark: db "FN1"  
4687 f1			.pastdmark: pop af  
4688			endm  
# End of macro DMARK
4688						CALLMONITOR 
4688 cd 6f ee			call debug_vector  
468b				endm  
# End of macro CALLMONITOR
468b					endif 
468b			 
468b					FORTH_DSP_POP 
468b cd 01 1f			call macro_forth_dsp_pop 
468e				endm 
# End of macro FORTH_DSP_POP
468e			 
468e					; string to search 
468e			 
468e					FORTH_DSP_VALUE 
468e cd 32 1e			call macro_forth_dsp_value 
4691				endm 
# End of macro FORTH_DSP_VALUE
4691			 
4691 d1					pop de  ; d is char to find  
4692			 
4692					if DEBUG_FORTH_WORDS 
4692						DMARK "FN2" 
4692 f5				push af  
4693 3a a7 46			ld a, (.dmark)  
4696 32 6b ee			ld (debug_mark),a  
4699 3a a8 46			ld a, (.dmark+1)  
469c 32 6c ee			ld (debug_mark+1),a  
469f 3a a9 46			ld a, (.dmark+2)  
46a2 32 6d ee			ld (debug_mark+2),a  
46a5 18 03			jr .pastdmark  
46a7 ..			.dmark: db "FN2"  
46aa f1			.pastdmark: pop af  
46ab			endm  
# End of macro DMARK
46ab						CALLMONITOR 
46ab cd 6f ee			call debug_vector  
46ae				endm  
# End of macro CALLMONITOR
46ae					endif 
46ae					 
46ae 01 00 00				ld bc, 0 
46b1 7e			.findchar:      ld a,(hl) 
46b2 fe 00				cp 0   		 
46b4 28 27				jr z, .finddone     
46b6 ba					cp d 
46b7 28 20				jr z, .foundchar 
46b9 03					inc bc 
46ba 23					inc hl 
46bb					if DEBUG_FORTH_WORDS 
46bb						DMARK "FN3" 
46bb f5				push af  
46bc 3a d0 46			ld a, (.dmark)  
46bf 32 6b ee			ld (debug_mark),a  
46c2 3a d1 46			ld a, (.dmark+1)  
46c5 32 6c ee			ld (debug_mark+1),a  
46c8 3a d2 46			ld a, (.dmark+2)  
46cb 32 6d ee			ld (debug_mark+2),a  
46ce 18 03			jr .pastdmark  
46d0 ..			.dmark: db "FN3"  
46d3 f1			.pastdmark: pop af  
46d4			endm  
# End of macro DMARK
46d4						CALLMONITOR 
46d4 cd 6f ee			call debug_vector  
46d7				endm  
# End of macro CALLMONITOR
46d7					endif 
46d7 18 d8				jr .findchar 
46d9			 
46d9			 
46d9 c5			.foundchar:	push bc 
46da e1					pop hl 
46db 18 03				jr .findexit 
46dd			 
46dd			 
46dd							 
46dd			 
46dd			.finddone:     ; got to end of string with no find 
46dd 21 00 00				ld hl, 0 
46e0			.findexit: 
46e0			 
46e0					if DEBUG_FORTH_WORDS 
46e0						DMARK "FNd" 
46e0 f5				push af  
46e1 3a f5 46			ld a, (.dmark)  
46e4 32 6b ee			ld (debug_mark),a  
46e7 3a f6 46			ld a, (.dmark+1)  
46ea 32 6c ee			ld (debug_mark+1),a  
46ed 3a f7 46			ld a, (.dmark+2)  
46f0 32 6d ee			ld (debug_mark+2),a  
46f3 18 03			jr .pastdmark  
46f5 ..			.dmark: db "FNd"  
46f8 f1			.pastdmark: pop af  
46f9			endm  
# End of macro DMARK
46f9						CALLMONITOR 
46f9 cd 6f ee			call debug_vector  
46fc				endm  
# End of macro CALLMONITOR
46fc					endif 
46fc cd 52 1c			call forth_push_numhl 
46ff			 
46ff				       NEXTW 
46ff c3 ff 1f			jp macro_next 
4702				endm 
# End of macro NEXTW
4702			 
4702			.LEN: 
4702				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4702 4c				db WORD_SYS_CORE+56             
4703 6c 47			dw .ASC            
4705 06				db 5 + 1 
4706 .. 00			db "COUNT",0              
470c				endm 
# End of macro CWHEAD
470c			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
470c			 
470c					if DEBUG_FORTH_WORDS_KEY 
470c						DMARK "CNT" 
470c f5				push af  
470d 3a 21 47			ld a, (.dmark)  
4710 32 6b ee			ld (debug_mark),a  
4713 3a 22 47			ld a, (.dmark+1)  
4716 32 6c ee			ld (debug_mark+1),a  
4719 3a 23 47			ld a, (.dmark+2)  
471c 32 6d ee			ld (debug_mark+2),a  
471f 18 03			jr .pastdmark  
4721 ..			.dmark: db "CNT"  
4724 f1			.pastdmark: pop af  
4725			endm  
# End of macro DMARK
4725						CALLMONITOR 
4725 cd 6f ee			call debug_vector  
4728				endm  
# End of macro CALLMONITOR
4728					endif 
4728			; TODO check string type 
4728					FORTH_DSP_VALUE 
4728 cd 32 1e			call macro_forth_dsp_value 
472b				endm 
# End of macro FORTH_DSP_VALUE
472b			 
472b			 
472b					if DEBUG_FORTH_WORDS 
472b						DMARK "CN?" 
472b f5				push af  
472c 3a 40 47			ld a, (.dmark)  
472f 32 6b ee			ld (debug_mark),a  
4732 3a 41 47			ld a, (.dmark+1)  
4735 32 6c ee			ld (debug_mark+1),a  
4738 3a 42 47			ld a, (.dmark+2)  
473b 32 6d ee			ld (debug_mark+2),a  
473e 18 03			jr .pastdmark  
4740 ..			.dmark: db "CN?"  
4743 f1			.pastdmark: pop af  
4744			endm  
# End of macro DMARK
4744						CALLMONITOR 
4744 cd 6f ee			call debug_vector  
4747				endm  
# End of macro CALLMONITOR
4747					endif 
4747 cd 44 12				call strlenz 
474a					if DEBUG_FORTH_WORDS 
474a						DMARK "CNl" 
474a f5				push af  
474b 3a 5f 47			ld a, (.dmark)  
474e 32 6b ee			ld (debug_mark),a  
4751 3a 60 47			ld a, (.dmark+1)  
4754 32 6c ee			ld (debug_mark+1),a  
4757 3a 61 47			ld a, (.dmark+2)  
475a 32 6d ee			ld (debug_mark+2),a  
475d 18 03			jr .pastdmark  
475f ..			.dmark: db "CNl"  
4762 f1			.pastdmark: pop af  
4763			endm  
# End of macro DMARK
4763						CALLMONITOR 
4763 cd 6f ee			call debug_vector  
4766				endm  
# End of macro CALLMONITOR
4766					endif 
4766			 
4766 cd 52 1c				call forth_push_numhl 
4769			 
4769			 
4769			 
4769				       NEXTW 
4769 c3 ff 1f			jp macro_next 
476c				endm 
# End of macro NEXTW
476c			.ASC: 
476c				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
476c 4d				db WORD_SYS_CORE+57             
476d da 47			dw .CHR            
476f 04				db 3 + 1 
4770 .. 00			db "ASC",0              
4774				endm 
# End of macro CWHEAD
4774			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4774					if DEBUG_FORTH_WORDS_KEY 
4774						DMARK "ASC" 
4774 f5				push af  
4775 3a 89 47			ld a, (.dmark)  
4778 32 6b ee			ld (debug_mark),a  
477b 3a 8a 47			ld a, (.dmark+1)  
477e 32 6c ee			ld (debug_mark+1),a  
4781 3a 8b 47			ld a, (.dmark+2)  
4784 32 6d ee			ld (debug_mark+2),a  
4787 18 03			jr .pastdmark  
4789 ..			.dmark: db "ASC"  
478c f1			.pastdmark: pop af  
478d			endm  
# End of macro DMARK
478d						CALLMONITOR 
478d cd 6f ee			call debug_vector  
4790				endm  
# End of macro CALLMONITOR
4790					endif 
4790					FORTH_DSP_VALUE 
4790 cd 32 1e			call macro_forth_dsp_value 
4793				endm 
# End of macro FORTH_DSP_VALUE
4793					;v5 FORTH_DSP_VALUE 
4793			;		inc hl      ; now at start of numeric as string 
4793			 
4793 e5					push hl 
4794			 
4794					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4794 cd 01 1f			call macro_forth_dsp_pop 
4797				endm 
# End of macro FORTH_DSP_POP
4797			 
4797 e1					pop hl 
4798			 
4798					if DEBUG_FORTH_WORDS 
4798						DMARK "AS1" 
4798 f5				push af  
4799 3a ad 47			ld a, (.dmark)  
479c 32 6b ee			ld (debug_mark),a  
479f 3a ae 47			ld a, (.dmark+1)  
47a2 32 6c ee			ld (debug_mark+1),a  
47a5 3a af 47			ld a, (.dmark+2)  
47a8 32 6d ee			ld (debug_mark+2),a  
47ab 18 03			jr .pastdmark  
47ad ..			.dmark: db "AS1"  
47b0 f1			.pastdmark: pop af  
47b1			endm  
# End of macro DMARK
47b1						CALLMONITOR 
47b1 cd 6f ee			call debug_vector  
47b4				endm  
# End of macro CALLMONITOR
47b4					endif 
47b4					; push the content of a onto the stack as a value 
47b4			 
47b4 7e					ld a,(hl)   ; get char 
47b5 26 00				ld h,0 
47b7 6f					ld l,a 
47b8					if DEBUG_FORTH_WORDS 
47b8						DMARK "AS2" 
47b8 f5				push af  
47b9 3a cd 47			ld a, (.dmark)  
47bc 32 6b ee			ld (debug_mark),a  
47bf 3a ce 47			ld a, (.dmark+1)  
47c2 32 6c ee			ld (debug_mark+1),a  
47c5 3a cf 47			ld a, (.dmark+2)  
47c8 32 6d ee			ld (debug_mark+2),a  
47cb 18 03			jr .pastdmark  
47cd ..			.dmark: db "AS2"  
47d0 f1			.pastdmark: pop af  
47d1			endm  
# End of macro DMARK
47d1						CALLMONITOR 
47d1 cd 6f ee			call debug_vector  
47d4				endm  
# End of macro CALLMONITOR
47d4					endif 
47d4 cd 52 1c				call forth_push_numhl 
47d7			 
47d7				       NEXTW 
47d7 c3 ff 1f			jp macro_next 
47da				endm 
# End of macro NEXTW
47da			 
47da			.CHR: 
47da				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
47da 4d				db WORD_SYS_CORE+57             
47db 16 48			dw .ENDSTR            
47dd 04				db 3 + 1 
47de .. 00			db "CHR",0              
47e2				endm 
# End of macro CWHEAD
47e2			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
47e2					if DEBUG_FORTH_WORDS_KEY 
47e2						DMARK "CHR" 
47e2 f5				push af  
47e3 3a f7 47			ld a, (.dmark)  
47e6 32 6b ee			ld (debug_mark),a  
47e9 3a f8 47			ld a, (.dmark+1)  
47ec 32 6c ee			ld (debug_mark+1),a  
47ef 3a f9 47			ld a, (.dmark+2)  
47f2 32 6d ee			ld (debug_mark+2),a  
47f5 18 03			jr .pastdmark  
47f7 ..			.dmark: db "CHR"  
47fa f1			.pastdmark: pop af  
47fb			endm  
# End of macro DMARK
47fb						CALLMONITOR 
47fb cd 6f ee			call debug_vector  
47fe				endm  
# End of macro CALLMONITOR
47fe					endif 
47fe					FORTH_DSP_VALUEHL 
47fe cd 49 1e			call macro_dsp_valuehl 
4801				endm 
# End of macro FORTH_DSP_VALUEHL
4801			 
4801					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4801 cd 01 1f			call macro_forth_dsp_pop 
4804				endm 
# End of macro FORTH_DSP_POP
4804			 
4804					; save asci byte as a zero term string and push string 
4804			 
4804 7d					ld a,l 
4805 32 c1 e2				ld (scratch), a 
4808			 
4808 3e 00				ld a, 0 
480a 32 c2 e2				ld (scratch+1), a 
480d			 
480d 21 c1 e2				ld hl, scratch 
4810 cd c0 1c				call forth_push_str 
4813			 
4813			 
4813				       NEXTW 
4813 c3 ff 1f			jp macro_next 
4816				endm 
# End of macro NEXTW
4816			 
4816			 
4816			 
4816			 
4816			.ENDSTR: 
4816			; eof 
4816			 
# End of file forth_words_str.asm
4816			include "forth_words_key.asm" 
4816			 
4816			; | ## Keyboard Words 
4816			 
4816			.KEY: 
4816				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4816 3e				db WORD_SYS_CORE+42             
4817 46 48			dw .WAITK            
4819 04				db 3 + 1 
481a .. 00			db "KEY",0              
481e				endm 
# End of macro CWHEAD
481e			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
481e			 
481e					if DEBUG_FORTH_WORDS_KEY 
481e						DMARK "KEY" 
481e f5				push af  
481f 3a 33 48			ld a, (.dmark)  
4822 32 6b ee			ld (debug_mark),a  
4825 3a 34 48			ld a, (.dmark+1)  
4828 32 6c ee			ld (debug_mark+1),a  
482b 3a 35 48			ld a, (.dmark+2)  
482e 32 6d ee			ld (debug_mark+2),a  
4831 18 03			jr .pastdmark  
4833 ..			.dmark: db "KEY"  
4836 f1			.pastdmark: pop af  
4837			endm  
# End of macro DMARK
4837						CALLMONITOR 
4837 cd 6f ee			call debug_vector  
483a				endm  
# End of macro CALLMONITOR
483a					endif 
483a			; TODO currently waits 
483a cd 2e 66				call cin 
483d					;call cin_wait 
483d 6f					ld l, a 
483e 26 00				ld h, 0 
4840 cd 52 1c				call forth_push_numhl 
4843					NEXTW 
4843 c3 ff 1f			jp macro_next 
4846				endm 
# End of macro NEXTW
4846			.WAITK: 
4846				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4846 3f				db WORD_SYS_CORE+43             
4847 78 48			dw .ACCEPT            
4849 06				db 5 + 1 
484a .. 00			db "WAITK",0              
4850				endm 
# End of macro CWHEAD
4850			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4850					if DEBUG_FORTH_WORDS_KEY 
4850						DMARK "WAI" 
4850 f5				push af  
4851 3a 65 48			ld a, (.dmark)  
4854 32 6b ee			ld (debug_mark),a  
4857 3a 66 48			ld a, (.dmark+1)  
485a 32 6c ee			ld (debug_mark+1),a  
485d 3a 67 48			ld a, (.dmark+2)  
4860 32 6d ee			ld (debug_mark+2),a  
4863 18 03			jr .pastdmark  
4865 ..			.dmark: db "WAI"  
4868 f1			.pastdmark: pop af  
4869			endm  
# End of macro DMARK
4869						CALLMONITOR 
4869 cd 6f ee			call debug_vector  
486c				endm  
# End of macro CALLMONITOR
486c					endif 
486c cd 26 66				call cin_wait 
486f 6f					ld l, a 
4870 26 00				ld h, 0 
4872 cd 52 1c				call forth_push_numhl 
4875					NEXTW 
4875 c3 ff 1f			jp macro_next 
4878				endm 
# End of macro NEXTW
4878			.ACCEPT: 
4878				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4878 40				db WORD_SYS_CORE+44             
4879 d6 48			dw .EDIT            
487b 07				db 6 + 1 
487c .. 00			db "ACCEPT",0              
4883				endm 
# End of macro CWHEAD
4883			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4883					; TODO crashes on push 
4883					if DEBUG_FORTH_WORDS_KEY 
4883						DMARK "ACC" 
4883 f5				push af  
4884 3a 98 48			ld a, (.dmark)  
4887 32 6b ee			ld (debug_mark),a  
488a 3a 99 48			ld a, (.dmark+1)  
488d 32 6c ee			ld (debug_mark+1),a  
4890 3a 9a 48			ld a, (.dmark+2)  
4893 32 6d ee			ld (debug_mark+2),a  
4896 18 03			jr .pastdmark  
4898 ..			.dmark: db "ACC"  
489b f1			.pastdmark: pop af  
489c			endm  
# End of macro DMARK
489c						CALLMONITOR 
489c cd 6f ee			call debug_vector  
489f				endm  
# End of macro CALLMONITOR
489f					endif 
489f 21 bf e4				ld hl, os_input 
48a2 3e 00				ld a, 0 
48a4 77					ld (hl),a 
48a5 3a 5e ea				ld a,(f_cursor_ptr) 
48a8 16 64				ld d, 100 
48aa 0e 00				ld c, 0 
48ac 1e 28				ld e, 40 
48ae cd 13 0e				call input_str 
48b1					; TODO perhaps do a type check and wrap in quotes if not a number 
48b1 21 bf e4				ld hl, os_input 
48b4					if DEBUG_FORTH_WORDS 
48b4						DMARK "AC1" 
48b4 f5				push af  
48b5 3a c9 48			ld a, (.dmark)  
48b8 32 6b ee			ld (debug_mark),a  
48bb 3a ca 48			ld a, (.dmark+1)  
48be 32 6c ee			ld (debug_mark+1),a  
48c1 3a cb 48			ld a, (.dmark+2)  
48c4 32 6d ee			ld (debug_mark+2),a  
48c7 18 03			jr .pastdmark  
48c9 ..			.dmark: db "AC1"  
48cc f1			.pastdmark: pop af  
48cd			endm  
# End of macro DMARK
48cd						CALLMONITOR 
48cd cd 6f ee			call debug_vector  
48d0				endm  
# End of macro CALLMONITOR
48d0					endif 
48d0 cd c0 1c				call forth_push_str 
48d3					NEXTW 
48d3 c3 ff 1f			jp macro_next 
48d6				endm 
# End of macro NEXTW
48d6			 
48d6			.EDIT: 
48d6				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
48d6 40				db WORD_SYS_CORE+44             
48d7 78 49			dw .DEDIT            
48d9 05				db 4 + 1 
48da .. 00			db "EDIT",0              
48df				endm 
# End of macro CWHEAD
48df			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
48df			 
48df					; TODO does not copy from stack 
48df					if DEBUG_FORTH_WORDS_KEY 
48df						DMARK "EDT" 
48df f5				push af  
48e0 3a f4 48			ld a, (.dmark)  
48e3 32 6b ee			ld (debug_mark),a  
48e6 3a f5 48			ld a, (.dmark+1)  
48e9 32 6c ee			ld (debug_mark+1),a  
48ec 3a f6 48			ld a, (.dmark+2)  
48ef 32 6d ee			ld (debug_mark+2),a  
48f2 18 03			jr .pastdmark  
48f4 ..			.dmark: db "EDT"  
48f7 f1			.pastdmark: pop af  
48f8			endm  
# End of macro DMARK
48f8						CALLMONITOR 
48f8 cd 6f ee			call debug_vector  
48fb				endm  
# End of macro CALLMONITOR
48fb					endif 
48fb			 
48fb					;FORTH_DSP 
48fb					FORTH_DSP_VALUEHL 
48fb cd 49 1e			call macro_dsp_valuehl 
48fe				endm 
# End of macro FORTH_DSP_VALUEHL
48fe			;		inc hl    ; TODO do type check 
48fe			 
48fe			;		call get_word_hl 
48fe e5					push hl 
48ff					if DEBUG_FORTH_WORDS 
48ff						DMARK "EDp" 
48ff f5				push af  
4900 3a 14 49			ld a, (.dmark)  
4903 32 6b ee			ld (debug_mark),a  
4906 3a 15 49			ld a, (.dmark+1)  
4909 32 6c ee			ld (debug_mark+1),a  
490c 3a 16 49			ld a, (.dmark+2)  
490f 32 6d ee			ld (debug_mark+2),a  
4912 18 03			jr .pastdmark  
4914 ..			.dmark: db "EDp"  
4917 f1			.pastdmark: pop af  
4918			endm  
# End of macro DMARK
4918						CALLMONITOR 
4918 cd 6f ee			call debug_vector  
491b				endm  
# End of macro CALLMONITOR
491b					endif 
491b				;	ld a, 0 
491b cd 44 12				call strlenz 
491e 23					inc hl 
491f			 
491f 06 00				ld b, 0 
4921 4d					ld c, l 
4922			 
4922 e1					pop hl 
4923 11 bf e4				ld de, os_input 
4926					if DEBUG_FORTH_WORDS_KEY 
4926						DMARK "EDc" 
4926 f5				push af  
4927 3a 3b 49			ld a, (.dmark)  
492a 32 6b ee			ld (debug_mark),a  
492d 3a 3c 49			ld a, (.dmark+1)  
4930 32 6c ee			ld (debug_mark+1),a  
4933 3a 3d 49			ld a, (.dmark+2)  
4936 32 6d ee			ld (debug_mark+2),a  
4939 18 03			jr .pastdmark  
493b ..			.dmark: db "EDc"  
493e f1			.pastdmark: pop af  
493f			endm  
# End of macro DMARK
493f						CALLMONITOR 
493f cd 6f ee			call debug_vector  
4942				endm  
# End of macro CALLMONITOR
4942					endif 
4942 ed b0				ldir 
4944			 
4944			 
4944 21 bf e4				ld hl, os_input 
4947					;ld a, 0 
4947					;ld (hl),a 
4947 3a 5e ea				ld a,(f_cursor_ptr) 
494a 16 64				ld d, 100 
494c 0e 00				ld c, 0 
494e 1e 28				ld e, 40 
4950 cd 13 0e				call input_str 
4953					; TODO perhaps do a type check and wrap in quotes if not a number 
4953 21 bf e4				ld hl, os_input 
4956					if DEBUG_FORTH_WORDS 
4956						DMARK "ED1" 
4956 f5				push af  
4957 3a 6b 49			ld a, (.dmark)  
495a 32 6b ee			ld (debug_mark),a  
495d 3a 6c 49			ld a, (.dmark+1)  
4960 32 6c ee			ld (debug_mark+1),a  
4963 3a 6d 49			ld a, (.dmark+2)  
4966 32 6d ee			ld (debug_mark+2),a  
4969 18 03			jr .pastdmark  
496b ..			.dmark: db "ED1"  
496e f1			.pastdmark: pop af  
496f			endm  
# End of macro DMARK
496f						CALLMONITOR 
496f cd 6f ee			call debug_vector  
4972				endm  
# End of macro CALLMONITOR
4972					endif 
4972 cd c0 1c				call forth_push_str 
4975					NEXTW 
4975 c3 ff 1f			jp macro_next 
4978				endm 
# End of macro NEXTW
4978			 
4978			.DEDIT: 
4978				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4978 40				db WORD_SYS_CORE+44             
4979 da 49			dw .ENDKEY            
497b 06				db 5 + 1 
497c .. 00			db "DEDIT",0              
4982				endm 
# End of macro CWHEAD
4982			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4982			 
4982					; TODO does not copy from stack 
4982					if DEBUG_FORTH_WORDS_KEY 
4982						DMARK "DED" 
4982 f5				push af  
4983 3a 97 49			ld a, (.dmark)  
4986 32 6b ee			ld (debug_mark),a  
4989 3a 98 49			ld a, (.dmark+1)  
498c 32 6c ee			ld (debug_mark+1),a  
498f 3a 99 49			ld a, (.dmark+2)  
4992 32 6d ee			ld (debug_mark+2),a  
4995 18 03			jr .pastdmark  
4997 ..			.dmark: db "DED"  
499a f1			.pastdmark: pop af  
499b			endm  
# End of macro DMARK
499b						CALLMONITOR 
499b cd 6f ee			call debug_vector  
499e				endm  
# End of macro CALLMONITOR
499e					endif 
499e			 
499e					;FORTH_DSP 
499e					FORTH_DSP_VALUEHL 
499e cd 49 1e			call macro_dsp_valuehl 
49a1				endm 
# End of macro FORTH_DSP_VALUEHL
49a1			;		inc hl    ; TODO do type check 
49a1			 
49a1			;		call get_word_hl 
49a1 e5					push hl 
49a2 e5					push hl 
49a3					FORTH_DSP_POP 
49a3 cd 01 1f			call macro_forth_dsp_pop 
49a6				endm 
# End of macro FORTH_DSP_POP
49a6 e1					pop hl 
49a7					if DEBUG_FORTH_WORDS 
49a7						DMARK "EDp" 
49a7 f5				push af  
49a8 3a bc 49			ld a, (.dmark)  
49ab 32 6b ee			ld (debug_mark),a  
49ae 3a bd 49			ld a, (.dmark+1)  
49b1 32 6c ee			ld (debug_mark+1),a  
49b4 3a be 49			ld a, (.dmark+2)  
49b7 32 6d ee			ld (debug_mark+2),a  
49ba 18 03			jr .pastdmark  
49bc ..			.dmark: db "EDp"  
49bf f1			.pastdmark: pop af  
49c0			endm  
# End of macro DMARK
49c0						CALLMONITOR 
49c0 cd 6f ee			call debug_vector  
49c3				endm  
# End of macro CALLMONITOR
49c3					endif 
49c3				;	ld a, 0 
49c3 cd 44 12				call strlenz 
49c6 23					inc hl 
49c7			 
49c7 06 00				ld b, 0 
49c9 4d					ld c, l 
49ca			 
49ca e1					pop hl 
49cb			 
49cb					;ld a, 0 
49cb					;ld (hl),a 
49cb 3a 5e ea				ld a,(f_cursor_ptr) 
49ce 16 64				ld d, 100 
49d0 0e 00				ld c, 0 
49d2 1e 28				ld e, 40 
49d4 cd 13 0e				call input_str 
49d7					; TODO perhaps do a type check and wrap in quotes if not a number 
49d7					NEXTW 
49d7 c3 ff 1f			jp macro_next 
49da				endm 
# End of macro NEXTW
49da			 
49da			 
49da			.ENDKEY: 
49da			; eof 
49da			 
# End of file forth_words_key.asm
49da			include "forth_words_const.asm" 
49da			 
49da			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
49da			 
49da			 
49da			.SPITIME: 
49da				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
49da 77				db WORD_SYS_CORE+99             
49db ef 49			dw .VA            
49dd 08				db 7 + 1 
49de .. 00			db "SPITIME",0              
49e6				endm 
# End of macro CWHEAD
49e6			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
49e6			; 
49e6			; | | If using BANK devices then leave as is. 
49e6			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
49e6			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
49e6			 
49e6 21 64 ea				ld hl, spi_clktime  
49e9 cd 52 1c				call forth_push_numhl 
49ec			 
49ec					NEXTW 
49ec c3 ff 1f			jp macro_next 
49ef				endm 
# End of macro NEXTW
49ef			 
49ef			 
49ef			.VA: 
49ef				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
49ef 77				db WORD_SYS_CORE+99             
49f0 ff 49			dw .SYMBOL            
49f2 03				db 2 + 1 
49f3 .. 00			db "VA",0              
49f6				endm 
# End of macro CWHEAD
49f6			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
49f6 21 28 ea				ld hl, cli_var_array 
49f9 cd 52 1c				call forth_push_numhl 
49fc			 
49fc					NEXTW 
49fc c3 ff 1f			jp macro_next 
49ff				endm 
# End of macro NEXTW
49ff			 
49ff			.SYMBOL: 
49ff				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
49ff 77				db WORD_SYS_CORE+99             
4a00 09 4b			dw .ENDCONST            
4a02 07				db 6 + 1 
4a03 .. 00			db "SYMBOL",0              
4a0a				endm 
# End of macro CWHEAD
4a0a			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4a0a			; | 
4a0a			; | | The value is the number reference and the final address is pushed to stack 
4a0a			 
4a0a			; | | ``` 
4a0a			; | | dw sym_table 
4a0a			; | | dw nmi_vector 
4a0a			; | | dw cli_autodisplay 
4a0a			; | | dw cli_data_sp 
4a0a			; | | dw cli_data_stack 
4a0a			; | | dw cli_loop_sp 
4a0a			; | | dw cli_loop_stack 
4a0a			; | | dw cli_var_array 
4a0a			; | | dw cursor_col 
4a0a			; | | dw cursor_ptr 
4a0a			; | | ; 10 
4a0a			; | | dw cursor_row 
4a0a			; | | dw debug_mark 
4a0a			; | | dw display_fb0 
4a0a			; | | dw display_fb1 
4a0a			; | | dw display_fb2 
4a0a			; | | dw display_fb3 
4a0a			; | | dw display_fb_active 
4a0a			; | | dw execscratch 
4a0a			; | | dw f_cursor_ptr 
4a0a			; | | dw hardware_word 
4a0a			; | | ;20 
4a0a			; | | dw input_at_cursor 
4a0a			; | | dw input_at_pos 
4a0a			; | | dw input_cur_flash 
4a0a			; | | dw input_cur_onoff 
4a0a			; | | dw input_cursor 
4a0a			; | | dw input_display_size 
4a0a			; | | dw input_len 
4a0a			; | | dw input_ptr 
4a0a			; | | dw input_size 
4a0a			; | | dw input_start 
4a0a			; | | ; 30 
4a0a			; | | dw input_str 
4a0a			; | | dw input_under_cursor 
4a0a			; | | dw os_cli_cmd 
4a0a			; | | dw os_cur_ptr 
4a0a			; | | dw os_current_i 
4a0a			; | | dw os_input 
4a0a			; | | dw os_last_cmd 
4a0a			; | | dw os_last_new_uword 
4a0a			; | | dw debug_vector 
4a0a			; | | dw os_view_hl 
4a0a			; | | ;40 
4a0a			; | | dw os_word_scratch 
4a0a			; | | dw portbctl 
4a0a			; | | dw portbdata 
4a0a			; | | dw spi_cartdev 
4a0a			; | | dw spi_cartdev2 
4a0a			; | | dw spi_clktime 
4a0a			; | | dw spi_device 
4a0a			; | | dw spi_device_id 
4a0a			; | | dw spi_portbyte 
4a0a			; | | dw stackstore 
4a0a			; | | ; 50 
4a0a			; | | if STORAGE_SE 
4a0a			; | | dw storage_actl 
4a0a			; | | dw storage_adata 
4a0a			; | | else 
4a0a			; | | dw 0 
4a0a			; | | dw 0 
4a0a			; | | endif 
4a0a			; | | dw storage_append 
4a0a			; | | if STORAGE_SE 
4a0a			; | | dw storage_bctl 
4a0a			; | | else 
4a0a			; | | dw 0 
4a0a			; | | endif 
4a0a			; | | dw store_bank_active 
4a0a			; | | dw store_filecache 
4a0a			; | | dw store_longread 
4a0a			; | | dw store_openaddr 
4a0a			; | | dw store_openext 
4a0a			; | | dw store_openmaxext 
4a0a			; | | ; 60 
4a0a			; | | dw store_page 
4a0a			; | | dw store_readbuf 
4a0a			; | | dw store_readcont 
4a0a			; | | dw store_readptr 
4a0a			; | | dw store_tmpext 
4a0a			; | | dw store_tmpid 
4a0a			; | | dw store_tmppageid 
4a0a			; | | dw malloc 
4a0a			; | | dw free 
4a0a			; | | dw cin 
4a0a			; | | ; 70 
4a0a			; | | dw cin_wait 
4a0a			; | | dw forth_push_numhl 
4a0a			; | | dw forth_push_str 
4a0a			; | | ``` 
4a0a			 
4a0a					if DEBUG_FORTH_WORDS_KEY 
4a0a						DMARK "SYM" 
4a0a f5				push af  
4a0b 3a 1f 4a			ld a, (.dmark)  
4a0e 32 6b ee			ld (debug_mark),a  
4a11 3a 20 4a			ld a, (.dmark+1)  
4a14 32 6c ee			ld (debug_mark+1),a  
4a17 3a 21 4a			ld a, (.dmark+2)  
4a1a 32 6d ee			ld (debug_mark+2),a  
4a1d 18 03			jr .pastdmark  
4a1f ..			.dmark: db "SYM"  
4a22 f1			.pastdmark: pop af  
4a23			endm  
# End of macro DMARK
4a23						CALLMONITOR 
4a23 cd 6f ee			call debug_vector  
4a26				endm  
# End of macro CALLMONITOR
4a26					endif 
4a26			 
4a26					FORTH_DSP_VALUEHL 
4a26 cd 49 1e			call macro_dsp_valuehl 
4a29				endm 
# End of macro FORTH_DSP_VALUEHL
4a29			 
4a29 7d					ld a, l     
4a2a			 
4a2a			 
4a2a					if DEBUG_FORTH_WORDS 
4a2a						DMARK "SY1" 
4a2a f5				push af  
4a2b 3a 3f 4a			ld a, (.dmark)  
4a2e 32 6b ee			ld (debug_mark),a  
4a31 3a 40 4a			ld a, (.dmark+1)  
4a34 32 6c ee			ld (debug_mark+1),a  
4a37 3a 41 4a			ld a, (.dmark+2)  
4a3a 32 6d ee			ld (debug_mark+2),a  
4a3d 18 03			jr .pastdmark  
4a3f ..			.dmark: db "SY1"  
4a42 f1			.pastdmark: pop af  
4a43			endm  
# End of macro DMARK
4a43						CALLMONITOR 
4a43 cd 6f ee			call debug_vector  
4a46				endm  
# End of macro CALLMONITOR
4a46					endif 
4a46					 
4a46 f5					push af	 
4a47					FORTH_DSP_POP 
4a47 cd 01 1f			call macro_forth_dsp_pop 
4a4a				endm 
# End of macro FORTH_DSP_POP
4a4a f1					pop af 
4a4b			 
4a4b cb 27				sla a  
4a4d				 
4a4d					 
4a4d					if DEBUG_FORTH_WORDS 
4a4d						DMARK "SY" 
4a4d f5				push af  
4a4e 3a 62 4a			ld a, (.dmark)  
4a51 32 6b ee			ld (debug_mark),a  
4a54 3a 63 4a			ld a, (.dmark+1)  
4a57 32 6c ee			ld (debug_mark+1),a  
4a5a 3a 64 4a			ld a, (.dmark+2)  
4a5d 32 6d ee			ld (debug_mark+2),a  
4a60 18 02			jr .pastdmark  
4a62 ..			.dmark: db "SY"  
4a64 f1			.pastdmark: pop af  
4a65			endm  
# End of macro DMARK
4a65						CALLMONITOR 
4a65 cd 6f ee			call debug_vector  
4a68				endm  
# End of macro CALLMONITOR
4a68					endif 
4a68			 
4a68 21 77 4a				ld hl, sym_table 
4a6b cd e6 0d				call addatohl 
4a6e cd 81 1f				call loadwordinhl 
4a71 cd 52 1c				call forth_push_numhl 
4a74			 
4a74			 
4a74				       NEXTW 
4a74 c3 ff 1f			jp macro_next 
4a77				endm 
# End of macro NEXTW
4a77			 
4a77			sym_table: 
4a77			 
4a77			; 0 
4a77 77 4a		dw sym_table 
4a79 72 ee		dw nmi_vector 
4a7b 3c ea		dw cli_autodisplay 
4a7d ee e9		dw cli_data_sp 
4a7f 28 e8		dw cli_data_stack 
4a81 f0 e9		dw cli_loop_sp 
4a83 2a e9		dw cli_loop_stack 
4a85 28 ea		dw cli_var_array 
4a87 c5 eb		dw cursor_col 
4a89 c3 eb		dw cursor_ptr 
4a8b			; 10 
4a8b c4 eb		dw cursor_row 
4a8d 6b ee		dw debug_mark 
4a8f b1 ed		dw display_fb0 
4a91 10 ed		dw display_fb1 
4a93 ce eb		dw display_fb2 
4a95 6f ec		dw display_fb3 
4a97 cc eb		dw display_fb_active 
4a99 c0 e3		dw execscratch 
4a9b 5e ea		dw f_cursor_ptr 
4a9d 75 ee		dw hardware_word 
4a9f			;20 
4a9f 62 ee		dw input_at_cursor 
4aa1 64 ee		dw input_at_pos 
4aa3 60 ee		dw input_cur_flash 
4aa5 5f ee		dw input_cur_onoff 
4aa7 55 ee		dw input_cursor 
4aa9 65 ee		dw input_display_size 
4aab 5a ee		dw input_len 
4aad 69 ee		dw input_ptr 
4aaf 66 ee		dw input_size 
4ab1 67 ee		dw input_start 
4ab3			; 30 
4ab3 13 0e		dw input_str 
4ab5 63 ee		dw input_under_cursor 
4ab7 e8 e5		dw os_cli_cmd 
4ab9 e4 e5		dw os_cur_ptr 
4abb e6 e5		dw os_current_i 
4abd bf e4		dw os_input 
4abf e7 e6		dw os_last_cmd 
4ac1 be e5		dw os_last_new_uword 
4ac3 6f ee		dw debug_vector 
4ac5 a3 e2		dw os_view_hl 
4ac7			;40 
4ac7 c6 e5		dw os_word_scratch 
4ac9 c3 00		dw portbctl 
4acb c1 00		dw portbdata 
4acd 63 ea		dw spi_cartdev 
4acf 62 ea		dw spi_cartdev2 
4ad1 64 ea		dw spi_clktime 
4ad3 60 ea		dw spi_device 
4ad5 5f ea		dw spi_device_id 
4ad7 61 ea		dw spi_portbyte 
4ad9 a7 eb		dw stackstore 
4adb			; 50 
4adb			if STORAGE_SE 
4adb			dw storage_actl 
4adb			dw storage_adata 
4adb			else 
4adb 00 00		dw 0 
4add 00 00		dw 0 
4adf			endif 
4adf 68 09		dw storage_append 
4ae1			if STORAGE_SE 
4ae1			dw storage_bctl 
4ae1			else 
4ae1 00 00		dw 0 
4ae3			endif 
4ae3 93 eb		dw store_bank_active 
4ae5 67 ea		dw store_filecache 
4ae7 75 ea		dw store_longread 
4ae9 6b ea		dw store_openaddr 
4aeb 6a ea		dw store_openext 
4aed 69 ea		dw store_openmaxext 
4aef			; 60 
4aef 7a ea		dw store_page 
4af1 76 ea		dw store_readbuf 
4af3 6d ea		dw store_readcont 
4af5 78 ea		dw store_readptr 
4af7 6d ea		dw store_tmpext 
4af9 6e ea		dw store_tmpid 
4afb 65 ea		dw store_tmppageid 
4afd b9 12		dw malloc 
4aff 83 13		dw free 
4b01 2e 66		dw cin 
4b03			; 70 
4b03 26 66		dw cin_wait 
4b05 52 1c		dw forth_push_numhl 
4b07 c0 1c		dw forth_push_str 
4b09			 
4b09			 
4b09			.ENDCONST: 
4b09			 
4b09			; eof 
4b09			 
4b09			 
# End of file forth_words_const.asm
4b09			 
4b09			if STORAGE_SE 
4b09			   	include "forth_words_storage.asm" 
4b09			endif 
4b09				include "forth_words_device.asm" 
4b09			; Device related words 
4b09			 
4b09			; | ## Device Words 
4b09			 
4b09			;if SOUND_ENABLE 
4b09			;.NOTE: 
4b09			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4b09			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
4b09			;		if DEBUG_FORTH_WORDS_KEY 
4b09			;			DMARK "NTE" 
4b09			;			CALLMONITOR 
4b09			;		endif 
4b09			; 
4b09			;	 
4b09			; 
4b09			;		NEXTW 
4b09			;.AFTERSOUND: 
4b09			;endif 
4b09			 
4b09			 
4b09			USE_GPIO: equ 0 
4b09			 
4b09			if USE_GPIO 
4b09			.GP1: 
4b09				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4b09			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
4b09					NEXTW 
4b09			.GP2: 
4b09				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4b09			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
4b09			 
4b09					NEXTW 
4b09			 
4b09			.GP3: 
4b09				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4b09			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
4b09			 
4b09					NEXTW 
4b09			 
4b09			.GP4: 
4b09				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4b09			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
4b09			 
4b09					NEXTW 
4b09			.SIN: 
4b09			 
4b09			 
4b09			endif 
4b09			 
4b09			 
4b09				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4b09 33				db WORD_SYS_CORE+31             
4b0a 3e 4b			dw .SOUT            
4b0c 03				db 2 + 1 
4b0d .. 00			db "IN",0              
4b10				endm 
# End of macro CWHEAD
4b10			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4b10					if DEBUG_FORTH_WORDS_KEY 
4b10						DMARK "IN." 
4b10 f5				push af  
4b11 3a 25 4b			ld a, (.dmark)  
4b14 32 6b ee			ld (debug_mark),a  
4b17 3a 26 4b			ld a, (.dmark+1)  
4b1a 32 6c ee			ld (debug_mark+1),a  
4b1d 3a 27 4b			ld a, (.dmark+2)  
4b20 32 6d ee			ld (debug_mark+2),a  
4b23 18 03			jr .pastdmark  
4b25 ..			.dmark: db "IN."  
4b28 f1			.pastdmark: pop af  
4b29			endm  
# End of macro DMARK
4b29						CALLMONITOR 
4b29 cd 6f ee			call debug_vector  
4b2c				endm  
# End of macro CALLMONITOR
4b2c					endif 
4b2c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b2c cd 49 1e			call macro_dsp_valuehl 
4b2f				endm 
# End of macro FORTH_DSP_VALUEHL
4b2f			 
4b2f e5					push hl 
4b30			 
4b30					; destroy value TOS 
4b30			 
4b30					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b30 cd 01 1f			call macro_forth_dsp_pop 
4b33				endm 
# End of macro FORTH_DSP_POP
4b33			 
4b33					; one value on hl get other one back 
4b33			 
4b33 c1					pop bc 
4b34			 
4b34					; do the sub 
4b34			;		ex de, hl 
4b34			 
4b34 ed 68				in l,(c) 
4b36			 
4b36					; save it 
4b36			 
4b36 26 00				ld h,0 
4b38			 
4b38					; TODO push value back onto stack for another op etc 
4b38			 
4b38 cd 52 1c				call forth_push_numhl 
4b3b					NEXTW 
4b3b c3 ff 1f			jp macro_next 
4b3e				endm 
# End of macro NEXTW
4b3e			.SOUT: 
4b3e				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4b3e 34				db WORD_SYS_CORE+32             
4b3f 91 4b			dw .SPIO            
4b41 04				db 3 + 1 
4b42 .. 00			db "OUT",0              
4b46				endm 
# End of macro CWHEAD
4b46			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4b46					if DEBUG_FORTH_WORDS_KEY 
4b46						DMARK "OUT" 
4b46 f5				push af  
4b47 3a 5b 4b			ld a, (.dmark)  
4b4a 32 6b ee			ld (debug_mark),a  
4b4d 3a 5c 4b			ld a, (.dmark+1)  
4b50 32 6c ee			ld (debug_mark+1),a  
4b53 3a 5d 4b			ld a, (.dmark+2)  
4b56 32 6d ee			ld (debug_mark+2),a  
4b59 18 03			jr .pastdmark  
4b5b ..			.dmark: db "OUT"  
4b5e f1			.pastdmark: pop af  
4b5f			endm  
# End of macro DMARK
4b5f						CALLMONITOR 
4b5f cd 6f ee			call debug_vector  
4b62				endm  
# End of macro CALLMONITOR
4b62					endif 
4b62			 
4b62					; get port 
4b62			 
4b62					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b62 cd 49 1e			call macro_dsp_valuehl 
4b65				endm 
# End of macro FORTH_DSP_VALUEHL
4b65			 
4b65 e5					push hl 
4b66			 
4b66					; destroy value TOS 
4b66			 
4b66					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b66 cd 01 1f			call macro_forth_dsp_pop 
4b69				endm 
# End of macro FORTH_DSP_POP
4b69			 
4b69					; get byte to send 
4b69			 
4b69					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b69 cd 49 1e			call macro_dsp_valuehl 
4b6c				endm 
# End of macro FORTH_DSP_VALUEHL
4b6c			 
4b6c			;		push hl 
4b6c			 
4b6c					; destroy value TOS 
4b6c			 
4b6c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b6c cd 01 1f			call macro_forth_dsp_pop 
4b6f				endm 
# End of macro FORTH_DSP_POP
4b6f			 
4b6f					; one value on hl get other one back 
4b6f			 
4b6f			;		pop hl 
4b6f			 
4b6f c1					pop bc 
4b70			 
4b70					if DEBUG_FORTH_WORDS 
4b70						DMARK "OUT" 
4b70 f5				push af  
4b71 3a 85 4b			ld a, (.dmark)  
4b74 32 6b ee			ld (debug_mark),a  
4b77 3a 86 4b			ld a, (.dmark+1)  
4b7a 32 6c ee			ld (debug_mark+1),a  
4b7d 3a 87 4b			ld a, (.dmark+2)  
4b80 32 6d ee			ld (debug_mark+2),a  
4b83 18 03			jr .pastdmark  
4b85 ..			.dmark: db "OUT"  
4b88 f1			.pastdmark: pop af  
4b89			endm  
# End of macro DMARK
4b89						CALLMONITOR 
4b89 cd 6f ee			call debug_vector  
4b8c				endm  
# End of macro CALLMONITOR
4b8c					endif 
4b8c			 
4b8c ed 69				out (c), l 
4b8e			 
4b8e					NEXTW 
4b8e c3 ff 1f			jp macro_next 
4b91				endm 
# End of macro NEXTW
4b91			 
4b91			 
4b91			.SPIO: 
4b91			 
4b91			if STORAGE_SE 
4b91				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4b91			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4b91			 
4b91					call spi_ce_low 
4b91			    NEXTW 
4b91			 
4b91			.SPICEH: 
4b91				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4b91			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4b91			 
4b91					call spi_ce_high 
4b91			    NEXTW 
4b91			 
4b91			 
4b91			.SPIOb: 
4b91			 
4b91				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4b91			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4b91			 
4b91					if DEBUG_FORTH_WORDS_KEY 
4b91						DMARK "SPo" 
4b91						CALLMONITOR 
4b91					endif 
4b91					; get port 
4b91			 
4b91			 
4b91					; get byte to send 
4b91			 
4b91					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b91			 
4b91			;		push hl    ; u1  
4b91			 
4b91					; destroy value TOS 
4b91			 
4b91					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b91			 
4b91					; one value on hl get other one back 
4b91			 
4b91			;		pop hl   ; u2 - addr 
4b91			 
4b91					; TODO Send SPI byte 
4b91			 
4b91			;		push hl 
4b91			;		call spi_ce_low 
4b91			;		pop hl 
4b91					ld a, l 
4b91					call spi_send_byte 
4b91			;		call spi_ce_high 
4b91			 
4b91					NEXTW 
4b91			 
4b91			.SPII: 
4b91				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4b91			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4b91					if DEBUG_FORTH_WORDS_KEY 
4b91						DMARK "SPi" 
4b91						CALLMONITOR 
4b91					endif 
4b91			 
4b91					; TODO Get SPI byte 
4b91			 
4b91					call spi_read_byte 
4b91			 
4b91					if DEBUG_FORTH_WORDS 
4b91						DMARK "Si2" 
4b91						CALLMONITOR 
4b91					endif 
4b91					ld h, 0 
4b91					ld l, a 
4b91					if DEBUG_FORTH_WORDS 
4b91						DMARK "Si3" 
4b91						CALLMONITOR 
4b91					endif 
4b91					call forth_push_numhl 
4b91			 
4b91					NEXTW 
4b91			 
4b91			 
4b91			 
4b91			.SESEL: 
4b91				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4b91			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4b91					if DEBUG_FORTH_WORDS_KEY 
4b91						DMARK "BNK" 
4b91						CALLMONITOR 
4b91					endif 
4b91			 
4b91					ld a, 255 
4b91					ld (spi_cartdev), a 
4b91			 
4b91					; get bank 
4b91			 
4b91					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b91			 
4b91			;		push hl 
4b91			 
4b91					; destroy value TOS 
4b91			 
4b91					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b91			 
4b91					; one value on hl get other one back 
4b91			 
4b91			;		pop hl 
4b91			 
4b91			 
4b91					ld c, SPI_CE_HIGH 
4b91					ld b, '0'    ; human readable bank number 
4b91			 
4b91					ld a, l 
4b91			 
4b91					if DEBUG_FORTH_WORDS 
4b91						DMARK "BNK" 
4b91						CALLMONITOR 
4b91					endif 
4b91			 
4b91					; active low 
4b91			 
4b91					cp 0 
4b91					jr z, .bset 
4b91					cp 1 
4b91					jr nz, .b2 
4b91					res 0, c 
4b91					ld b, '1'    ; human readable bank number 
4b91			.b2:		cp 2 
4b91					jr nz, .b3 
4b91					res 1, c 
4b91					ld b, '2'    ; human readable bank number 
4b91			.b3:		cp 3 
4b91					jr nz, .b4 
4b91					res 2, c 
4b91					ld b, '3'    ; human readable bank number 
4b91			.b4:		cp 4 
4b91					jr nz, .b5 
4b91					res 3, c 
4b91					ld b, '4'    ; human readable bank number 
4b91			.b5:		cp 5 
4b91					jr nz, .bset 
4b91					res 4, c 
4b91					ld b, '5'    ; human readable bank number 
4b91			 
4b91			.bset: 
4b91					ld a, c 
4b91					ld (spi_device),a 
4b91					ld a, b 
4b91					ld (spi_device_id),a 
4b91					if DEBUG_FORTH_WORDS 
4b91						DMARK "BN2" 
4b91						CALLMONITOR 
4b91					endif 
4b91			 
4b91					; set default SPI clk pulse time as disabled for BANK use 
4b91			 
4b91					ld a, 0 
4b91					ld (spi_clktime), a 
4b91			 
4b91					NEXTW 
4b91			 
4b91			.CARTDEV: 
4b91				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4b91			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4b91					if DEBUG_FORTH_WORDS_KEY 
4b91						DMARK "CDV" 
4b91						CALLMONITOR 
4b91					endif 
4b91			 
4b91					; disable se storage bank selection 
4b91			 
4b91					ld a, SPI_CE_HIGH		; ce high 
4b91					ld (spi_device), a 
4b91			 
4b91					; get bank 
4b91			 
4b91					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b91			 
4b91			;		push hl 
4b91			 
4b91					; destroy value TOS 
4b91			 
4b91					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b91			 
4b91					; one value on hl get other one back 
4b91			 
4b91			;		pop hl 
4b91			 
4b91					; active low 
4b91			 
4b91					ld c, 255 
4b91			 
4b91					ld a, l 
4b91					if DEBUG_FORTH_WORDS 
4b91						DMARK "CDV" 
4b91						CALLMONITOR 
4b91					endif 
4b91					cp 0 
4b91					jr z, .cset 
4b91					cp 1 
4b91					jr nz, .c2 
4b91					res 0, c 
4b91			.c2:		cp 2 
4b91					jr nz, .c3 
4b91					res 1, c 
4b91			.c3:		cp 3 
4b91					jr nz, .c4 
4b91					res 2, c 
4b91			.c4:		cp 4 
4b91					jr nz, .c5 
4b91					res 3, c 
4b91			.c5:		cp 5 
4b91					jr nz, .c6 
4b91					res 4, c 
4b91			.c6:		cp 6 
4b91					jr nz, .c7 
4b91					res 5, c 
4b91			.c7:		cp 7 
4b91					jr nz, .c8 
4b91					res 6, c 
4b91			.c8:		cp 8 
4b91					jr nz, .cset 
4b91					res 7, c 
4b91			.cset:		ld a, c 
4b91					ld (spi_cartdev),a 
4b91			 
4b91					if DEBUG_FORTH_WORDS 
4b91						DMARK "CD2" 
4b91						CALLMONITOR 
4b91					endif 
4b91			 
4b91					; set default SPI clk pulse time as 10ms for CARTDEV use 
4b91			 
4b91					ld a, $0a 
4b91					ld (spi_clktime), a 
4b91					NEXTW 
4b91			endif 
4b91			 
4b91			.ENDDEVICE: 
4b91			; eof 
4b91			 
# End of file forth_words_device.asm
4b91			 
4b91			; var handler 
4b91			 
4b91			 
4b91			.VARS: 
4b91				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4b91 77				db WORD_SYS_CORE+99             
4b92 42 4c			dw .V0            
4b94 04				db 3 + 1 
4b95 .. 00			db "VAR",0              
4b99				endm 
# End of macro CWHEAD
4b99			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4b99			;| 
4b99			;| The variable name should consist of a single letter. e.g. "a" 
4b99			;! If a full string is passed then only the first char is looked at 
4b99			;| Any other char could exceed bounds checks!  
4b99			 
4b99					if DEBUG_FORTH_WORDS_KEY 
4b99						DMARK "VAR" 
4b99 f5				push af  
4b9a 3a ae 4b			ld a, (.dmark)  
4b9d 32 6b ee			ld (debug_mark),a  
4ba0 3a af 4b			ld a, (.dmark+1)  
4ba3 32 6c ee			ld (debug_mark+1),a  
4ba6 3a b0 4b			ld a, (.dmark+2)  
4ba9 32 6d ee			ld (debug_mark+2),a  
4bac 18 03			jr .pastdmark  
4bae ..			.dmark: db "VAR"  
4bb1 f1			.pastdmark: pop af  
4bb2			endm  
# End of macro DMARK
4bb2						CALLMONITOR 
4bb2 cd 6f ee			call debug_vector  
4bb5				endm  
# End of macro CALLMONITOR
4bb5					endif 
4bb5			 
4bb5					FORTH_DSP_VALUEHL 
4bb5 cd 49 1e			call macro_dsp_valuehl 
4bb8				endm 
# End of macro FORTH_DSP_VALUEHL
4bb8			 
4bb8 7e					ld a, (hl)    ; get first char on of the string 
4bb9			 
4bb9			 
4bb9					if DEBUG_FORTH_WORDS 
4bb9						DMARK "VR1" 
4bb9 f5				push af  
4bba 3a ce 4b			ld a, (.dmark)  
4bbd 32 6b ee			ld (debug_mark),a  
4bc0 3a cf 4b			ld a, (.dmark+1)  
4bc3 32 6c ee			ld (debug_mark+1),a  
4bc6 3a d0 4b			ld a, (.dmark+2)  
4bc9 32 6d ee			ld (debug_mark+2),a  
4bcc 18 03			jr .pastdmark  
4bce ..			.dmark: db "VR1"  
4bd1 f1			.pastdmark: pop af  
4bd2			endm  
# End of macro DMARK
4bd2						CALLMONITOR 
4bd2 cd 6f ee			call debug_vector  
4bd5				endm  
# End of macro CALLMONITOR
4bd5					endif 
4bd5					 
4bd5 f5					push af	 
4bd6					FORTH_DSP_POP 
4bd6 cd 01 1f			call macro_forth_dsp_pop 
4bd9				endm 
# End of macro FORTH_DSP_POP
4bd9 f1					pop af 
4bda			 
4bda					; convert to upper 
4bda			 
4bda cd 53 11				call to_upper 
4bdd					if DEBUG_FORTH_WORDS 
4bdd						DMARK "Vaa" 
4bdd f5				push af  
4bde 3a f2 4b			ld a, (.dmark)  
4be1 32 6b ee			ld (debug_mark),a  
4be4 3a f3 4b			ld a, (.dmark+1)  
4be7 32 6c ee			ld (debug_mark+1),a  
4bea 3a f4 4b			ld a, (.dmark+2)  
4bed 32 6d ee			ld (debug_mark+2),a  
4bf0 18 03			jr .pastdmark  
4bf2 ..			.dmark: db "Vaa"  
4bf5 f1			.pastdmark: pop af  
4bf6			endm  
# End of macro DMARK
4bf6						CALLMONITOR 
4bf6 cd 6f ee			call debug_vector  
4bf9				endm  
# End of macro CALLMONITOR
4bf9					endif 
4bf9 06 41				ld b, 'A' 
4bfb 90					sub b			; set offset 
4bfc					if DEBUG_FORTH_WORDS 
4bfc						DMARK "Vbb" 
4bfc f5				push af  
4bfd 3a 11 4c			ld a, (.dmark)  
4c00 32 6b ee			ld (debug_mark),a  
4c03 3a 12 4c			ld a, (.dmark+1)  
4c06 32 6c ee			ld (debug_mark+1),a  
4c09 3a 13 4c			ld a, (.dmark+2)  
4c0c 32 6d ee			ld (debug_mark+2),a  
4c0f 18 03			jr .pastdmark  
4c11 ..			.dmark: db "Vbb"  
4c14 f1			.pastdmark: pop af  
4c15			endm  
# End of macro DMARK
4c15						CALLMONITOR 
4c15 cd 6f ee			call debug_vector  
4c18				endm  
# End of macro CALLMONITOR
4c18					endif 
4c18 cb 27				sla a  
4c1a				 
4c1a					 
4c1a					if DEBUG_FORTH_WORDS 
4c1a						DMARK "VR2" 
4c1a f5				push af  
4c1b 3a 2f 4c			ld a, (.dmark)  
4c1e 32 6b ee			ld (debug_mark),a  
4c21 3a 30 4c			ld a, (.dmark+1)  
4c24 32 6c ee			ld (debug_mark+1),a  
4c27 3a 31 4c			ld a, (.dmark+2)  
4c2a 32 6d ee			ld (debug_mark+2),a  
4c2d 18 03			jr .pastdmark  
4c2f ..			.dmark: db "VR2"  
4c32 f1			.pastdmark: pop af  
4c33			endm  
# End of macro DMARK
4c33						CALLMONITOR 
4c33 cd 6f ee			call debug_vector  
4c36				endm  
# End of macro CALLMONITOR
4c36					endif 
4c36			 
4c36 21 f4 e9				ld hl, cli_var_array2 
4c39 cd e6 0d				call addatohl 
4c3c cd 52 1c				call forth_push_numhl 
4c3f			 
4c3f			 
4c3f				       NEXTW 
4c3f c3 ff 1f			jp macro_next 
4c42				endm 
# End of macro NEXTW
4c42			.V0: 
4c42				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4c42 78				db WORD_SYS_CORE+100             
4c43 5a 4c			dw .V0Q            
4c45 04				db 3 + 1 
4c46 .. 00			db "V0!",0              
4c4a				endm 
# End of macro CWHEAD
4c4a			;| V0! ( u1 -- )  Store value to v0  | DONE 
4c4a			 
4c4a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c4a cd 49 1e			call macro_dsp_valuehl 
4c4d				endm 
# End of macro FORTH_DSP_VALUEHL
4c4d			 
4c4d 11 28 ea				ld de, cli_var_array 
4c50			 
4c50 eb					ex de, hl 
4c51 73					ld (hl), e 
4c52 23					inc hl 
4c53 72					ld (hl), d 
4c54			 
4c54					; destroy value TOS 
4c54			 
4c54					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c54 cd 01 1f			call macro_forth_dsp_pop 
4c57				endm 
# End of macro FORTH_DSP_POP
4c57			 
4c57				       NEXTW 
4c57 c3 ff 1f			jp macro_next 
4c5a				endm 
# End of macro NEXTW
4c5a			.V0Q: 
4c5a				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4c5a 79				db WORD_SYS_CORE+101             
4c5b 6b 4c			dw .V1S            
4c5d 04				db 3 + 1 
4c5e .. 00			db "V0@",0              
4c62				endm 
# End of macro CWHEAD
4c62			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4c62 2a 28 ea				ld hl, (cli_var_array) 
4c65 cd 52 1c				call forth_push_numhl 
4c68			 
4c68				       NEXTW 
4c68 c3 ff 1f			jp macro_next 
4c6b				endm 
# End of macro NEXTW
4c6b			.V1S: 
4c6b				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4c6b 7a				db WORD_SYS_CORE+102             
4c6c 83 4c			dw .V1Q            
4c6e 04				db 3 + 1 
4c6f .. 00			db "V1!",0              
4c73				endm 
# End of macro CWHEAD
4c73			;| V1! ( u1 -- )  Store value to v1 | DONE 
4c73					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c73 cd 49 1e			call macro_dsp_valuehl 
4c76				endm 
# End of macro FORTH_DSP_VALUEHL
4c76			 
4c76 11 2a ea				ld de, cli_var_array+2 
4c79				 
4c79 eb					ex de, hl 
4c7a 73					ld (hl), e 
4c7b 23					inc hl 
4c7c 72					ld (hl), d 
4c7d			 
4c7d					; destroy value TOS 
4c7d			 
4c7d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c7d cd 01 1f			call macro_forth_dsp_pop 
4c80				endm 
# End of macro FORTH_DSP_POP
4c80				       NEXTW 
4c80 c3 ff 1f			jp macro_next 
4c83				endm 
# End of macro NEXTW
4c83			.V1Q: 
4c83				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4c83 7b				db WORD_SYS_CORE+103             
4c84 94 4c			dw .V2S            
4c86 04				db 3 + 1 
4c87 .. 00			db "V1@",0              
4c8b				endm 
# End of macro CWHEAD
4c8b			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4c8b 2a 2a ea				ld hl, (cli_var_array+2) 
4c8e cd 52 1c				call forth_push_numhl 
4c91				       NEXTW 
4c91 c3 ff 1f			jp macro_next 
4c94				endm 
# End of macro NEXTW
4c94			.V2S: 
4c94				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4c94 7c				db WORD_SYS_CORE+104             
4c95 ac 4c			dw .V2Q            
4c97 04				db 3 + 1 
4c98 .. 00			db "V2!",0              
4c9c				endm 
# End of macro CWHEAD
4c9c			;| V2! ( u1 -- )  Store value to v2 | DONE 
4c9c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c9c cd 49 1e			call macro_dsp_valuehl 
4c9f				endm 
# End of macro FORTH_DSP_VALUEHL
4c9f			 
4c9f 11 2c ea				ld de, cli_var_array+4 
4ca2				 
4ca2 eb					ex de, hl 
4ca3 73					ld (hl), e 
4ca4 23					inc hl 
4ca5 72					ld (hl), d 
4ca6			 
4ca6					; destroy value TOS 
4ca6			 
4ca6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ca6 cd 01 1f			call macro_forth_dsp_pop 
4ca9				endm 
# End of macro FORTH_DSP_POP
4ca9				       NEXTW 
4ca9 c3 ff 1f			jp macro_next 
4cac				endm 
# End of macro NEXTW
4cac			.V2Q: 
4cac				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4cac 7d				db WORD_SYS_CORE+105             
4cad bd 4c			dw .V3S            
4caf 04				db 3 + 1 
4cb0 .. 00			db "V2@",0              
4cb4				endm 
# End of macro CWHEAD
4cb4			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4cb4 2a 2c ea				ld hl, (cli_var_array+4) 
4cb7 cd 52 1c				call forth_push_numhl 
4cba				       NEXTW 
4cba c3 ff 1f			jp macro_next 
4cbd				endm 
# End of macro NEXTW
4cbd			.V3S: 
4cbd				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4cbd 7c				db WORD_SYS_CORE+104             
4cbe d5 4c			dw .V3Q            
4cc0 04				db 3 + 1 
4cc1 .. 00			db "V3!",0              
4cc5				endm 
# End of macro CWHEAD
4cc5			;| V3! ( u1 -- )  Store value to v3 | DONE 
4cc5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4cc5 cd 49 1e			call macro_dsp_valuehl 
4cc8				endm 
# End of macro FORTH_DSP_VALUEHL
4cc8			 
4cc8 11 2e ea				ld de, cli_var_array+6 
4ccb				 
4ccb eb					ex de, hl 
4ccc 73					ld (hl), e 
4ccd 23					inc hl 
4cce 72					ld (hl), d 
4ccf			 
4ccf					; destroy value TOS 
4ccf			 
4ccf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ccf cd 01 1f			call macro_forth_dsp_pop 
4cd2				endm 
# End of macro FORTH_DSP_POP
4cd2				       NEXTW 
4cd2 c3 ff 1f			jp macro_next 
4cd5				endm 
# End of macro NEXTW
4cd5			.V3Q: 
4cd5				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4cd5 7d				db WORD_SYS_CORE+105             
4cd6 e6 4c			dw .END            
4cd8 04				db 3 + 1 
4cd9 .. 00			db "V3@",0              
4cdd				endm 
# End of macro CWHEAD
4cdd			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4cdd 2a 2e ea				ld hl, (cli_var_array+6) 
4ce0 cd 52 1c				call forth_push_numhl 
4ce3				       NEXTW 
4ce3 c3 ff 1f			jp macro_next 
4ce6				endm 
# End of macro NEXTW
4ce6			 
4ce6			 
4ce6			 
4ce6			 
4ce6			 
4ce6			; end of dict marker 
4ce6			 
4ce6 00			.END:    db WORD_SYS_END 
4ce7 00 00			dw 0 
4ce9 00				db 0 
4cea			 
4cea			; use to jp here for user dict words to save on macro expansion  
4cea			 
4cea			user_dict_next: 
4cea				NEXTW 
4cea c3 ff 1f			jp macro_next 
4ced				endm 
# End of macro NEXTW
4ced			 
4ced			 
4ced			user_exec: 
4ced				;    ld hl, <word code> 
4ced				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4ced				;    call forthexec 
4ced				;    jp user_dict_next   (NEXT) 
4ced			        ;    <word code bytes> 
4ced eb				ex de, hl 
4cee 2a c2 e5			ld hl,(os_tok_ptr) 
4cf1				 
4cf1				FORTH_RSP_NEXT 
4cf1 cd f9 1b			call macro_forth_rsp_next 
4cf4				endm 
# End of macro FORTH_RSP_NEXT
4cf4			 
4cf4			if DEBUG_FORTH_UWORD 
4cf4						DMARK "UEX" 
4cf4 f5				push af  
4cf5 3a 09 4d			ld a, (.dmark)  
4cf8 32 6b ee			ld (debug_mark),a  
4cfb 3a 0a 4d			ld a, (.dmark+1)  
4cfe 32 6c ee			ld (debug_mark+1),a  
4d01 3a 0b 4d			ld a, (.dmark+2)  
4d04 32 6d ee			ld (debug_mark+2),a  
4d07 18 03			jr .pastdmark  
4d09 ..			.dmark: db "UEX"  
4d0c f1			.pastdmark: pop af  
4d0d			endm  
# End of macro DMARK
4d0d				CALLMONITOR 
4d0d cd 6f ee			call debug_vector  
4d10				endm  
# End of macro CALLMONITOR
4d10			endif 
4d10			 
4d10			 
4d10			 
4d10 eb				ex de, hl 
4d11 22 c2 e5			ld (os_tok_ptr), hl 
4d14				 
4d14				; Don't use next - Skips the first word in uword. 
4d14			 
4d14 c3 90 20			jp exec1 
4d17			;	NEXT 
4d17			 
4d17			 
4d17			; eof 
# End of file forth_wordsv4.asm
4d17			endif 
4d17			;;;;;;;;;;;;;; Debug code 
4d17			 
4d17			 
4d17			;if DEBUG_FORTH_PARSE 
4d17 .. 00		.nowordfound: db "No match",0 
4d20 .. 00		.compword:	db "Comparing word ",0 
4d30 .. 00		.nextwordat:	db "Next word at",0 
4d3d .. 00		.charmatch:	db "Char match",0 
4d48			;endif 
4d48			if DEBUG_FORTH_JP 
4d48			.foundword:	db "Word match. Exec..",0 
4d48			endif 
4d48			;if DEBUG_FORTH_PUSH 
4d48 .. 00		.enddict:	db "Dict end. Push.",0 
4d58 .. 00		.push_str:	db "Pushing string",0 
4d67 .. 00		.push_num:	db "Pushing number",0 
4d76 .. 00		.data_sp:	db "SP:",0 
4d7a .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4d8c .. 00		.wordinde:	db "Word in DE (3/0):",0 
4d9e .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4db0			;endif 
4db0			;if DEBUG_FORTH_MALLOC 
4db0 .. 00		.push_malloc:	db "Malloc address",0 
4dbf			;endif 
4dbf			 
4dbf			 
4dbf			 
4dbf			; display malloc address and current data stack pointer  
4dbf			 
4dbf			malloc_error: 
4dbf d5				push de 
4dc0 f5				push af 
4dc1 e5				push hl 
4dc2 cd b9 0b			call clear_display 
4dc5 11 e5 4d			ld de, .mallocerr 
4dc8 3e 00			ld a,0 
4dca			;	ld de,os_word_scratch 
4dca cd cc 0b			call str_at_display 
4dcd 3e 11			ld a, display_row_1+17 
4dcf 11 6b ee			ld de, debug_mark 
4dd2 cd cc 0b			call str_at_display 
4dd5 cd dc 0b			call update_display 
4dd8				;call break_point_state 
4dd8 cd 26 66			call cin_wait 
4ddb			 
4ddb			;	ld a, ' ' 
4ddb			;	ld (os_view_disable), a 
4ddb cd e8 15			call bp_on 
4dde e1				pop hl 
4ddf f1				pop af 
4de0 d1				pop de	 
4de1				CALLMONITOR 
4de1 cd 6f ee			call debug_vector  
4de4				endm  
# End of macro CALLMONITOR
4de4 c9				ret 
4de5			 
4de5 .. 00		.mallocerr: 	db "Malloc Error",0 
4df2			;if DEBUG_FORTH_PUSH 
4df2			display_data_sp: 
4df2 f5				push af 
4df3			 
4df3				; see if disabled 
4df3			 
4df3			 
4df3 3a 6f ee			ld a, (debug_vector) 
4df6 fe c9			cp $C9  ; RET 
4df8				;ld a, (os_view_disable) 
4df8				;cp '*' 
4df8 28 67			jr z, .skipdsp 
4dfa			 
4dfa e5				push hl 
4dfb e5				push hl 
4dfc e5			push hl 
4dfd cd b9 0b			call clear_display 
4e00 e1			pop hl 
4e01 7c				ld a,h 
4e02 21 c6 e5			ld hl, os_word_scratch 
4e05 cd e7 10			call hexout 
4e08 e1				pop hl 
4e09 7d				ld a,l 
4e0a 21 c8 e5			ld hl, os_word_scratch+2 
4e0d cd e7 10			call hexout 
4e10 21 ca e5			ld hl, os_word_scratch+4 
4e13 3e 00			ld a,0 
4e15 77				ld (hl),a 
4e16 11 c6 e5			ld de,os_word_scratch 
4e19 3e 28				ld a, display_row_2 
4e1b cd cc 0b				call str_at_display 
4e1e 11 7a 4d			ld de, .wordinhl 
4e21 3e 00			ld a, display_row_1 
4e23			 
4e23 cd cc 0b				call str_at_display 
4e26 11 6b ee			ld de, debug_mark 
4e29 3e 11			ld a, display_row_1+17 
4e2b			 
4e2b cd cc 0b				call str_at_display 
4e2e			 
4e2e				; display current data stack pointer 
4e2e 11 76 4d			ld de,.data_sp 
4e31 3e 30				ld a, display_row_2 + 8 
4e33 cd cc 0b				call str_at_display 
4e36			 
4e36 2a ee e9			ld hl,(cli_data_sp) 
4e39 e5				push hl 
4e3a 7c				ld a,h 
4e3b 21 c6 e5			ld hl, os_word_scratch 
4e3e cd e7 10			call hexout 
4e41 e1				pop hl 
4e42 7d				ld a,l 
4e43 21 c8 e5			ld hl, os_word_scratch+2 
4e46 cd e7 10			call hexout 
4e49 21 ca e5			ld hl, os_word_scratch+4 
4e4c 3e 00			ld a,0 
4e4e 77				ld (hl),a 
4e4f 11 c6 e5			ld de,os_word_scratch 
4e52 3e 33				ld a, display_row_2 + 11 
4e54 cd cc 0b				call str_at_display 
4e57			 
4e57			 
4e57 cd dc 0b			call update_display 
4e5a cd f1 0a			call delay1s 
4e5d cd f1 0a			call delay1s 
4e60 e1				pop hl 
4e61			.skipdsp: 
4e61 f1				pop af 
4e62 c9				ret 
4e63			 
4e63			display_data_malloc: 
4e63			 
4e63 f5				push af 
4e64 e5				push hl 
4e65 e5				push hl 
4e66 e5			push hl 
4e67 cd b9 0b			call clear_display 
4e6a e1			pop hl 
4e6b 7c				ld a,h 
4e6c 21 c6 e5			ld hl, os_word_scratch 
4e6f cd e7 10			call hexout 
4e72 e1				pop hl 
4e73 7d				ld a,l 
4e74 21 c8 e5			ld hl, os_word_scratch+2 
4e77 cd e7 10			call hexout 
4e7a 21 ca e5			ld hl, os_word_scratch+4 
4e7d 3e 00			ld a,0 
4e7f 77				ld (hl),a 
4e80 11 c6 e5			ld de,os_word_scratch 
4e83 3e 28				ld a, display_row_2 
4e85 cd cc 0b				call str_at_display 
4e88 11 b0 4d			ld de, .push_malloc 
4e8b 3e 00			ld a, display_row_1 
4e8d			 
4e8d cd cc 0b				call str_at_display 
4e90			 
4e90				; display current data stack pointer 
4e90 11 76 4d			ld de,.data_sp 
4e93 3e 30				ld a, display_row_2 + 8 
4e95 cd cc 0b				call str_at_display 
4e98			 
4e98 2a ee e9			ld hl,(cli_data_sp) 
4e9b e5				push hl 
4e9c 7c				ld a,h 
4e9d 21 c6 e5			ld hl, os_word_scratch 
4ea0 cd e7 10			call hexout 
4ea3 e1				pop hl 
4ea4 7d				ld a,l 
4ea5 21 c8 e5			ld hl, os_word_scratch+2 
4ea8 cd e7 10			call hexout 
4eab 21 ca e5			ld hl, os_word_scratch+4 
4eae 3e 00			ld a,0 
4eb0 77				ld (hl),a 
4eb1 11 c6 e5			ld de,os_word_scratch 
4eb4 3e 33				ld a, display_row_2 + 11 
4eb6 cd cc 0b				call str_at_display 
4eb9			 
4eb9 cd dc 0b			call update_display 
4ebc cd f1 0a			call delay1s 
4ebf cd f1 0a			call delay1s 
4ec2 e1				pop hl 
4ec3 f1				pop af 
4ec4 c9				ret 
4ec5			;endif 
4ec5			 
4ec5			include "forth_autostart.asm" 
4ec5			; list of commands to perform at system start up 
4ec5			 
4ec5			startcmds: 
4ec5			;	dw test11 
4ec5			;	dw test12 
4ec5			;	dw test13 
4ec5			;	dw test14 
4ec5			;	dw test15 
4ec5			;	dw test16 
4ec5			;	dw test17 
4ec5			;	dw ifthtest1 
4ec5			;	dw ifthtest2 
4ec5			;	dw ifthtest3 
4ec5			;	dw mmtest1 
4ec5			;	dw mmtest2 
4ec5			;	dw mmtest3 
4ec5			;	dw mmtest4 
4ec5			;	dw mmtest5 
4ec5			;	dw mmtest6 
4ec5			;	dw iftest1 
4ec5			;	dw iftest2 
4ec5			;	dw iftest3 
4ec5			;	dw looptest1 
4ec5			;	dw looptest2 
4ec5			;	dw test1 
4ec5			;	dw test2 
4ec5			;	dw test3 
4ec5			;	dw test4 
4ec5			;	dw game2r 
4ec5			;	dw game2b1 
4ec5			;	dw game2b2 
4ec5			 
4ec5				; start up words that are actually useful 
4ec5			 
4ec5			;    dw spi1 
4ec5			;    dw spi2 
4ec5			;    dw spi3 
4ec5			;    dw spi4 
4ec5			;    dw spi5 
4ec5			;    dw spi6 
4ec5			;    dw spi7 
4ec5			; 
4ec5			;    dw spi8 
4ec5			;    dw spi9 
4ec5			;    dw spi10 
4ec5			 
4ec5			; file editor 
4ec5			;	dw edit1 
4ec5			;	dw edit2 
4ec5			;	dw edit3 
4ec5			 
4ec5			;	dw longread 
4ec5 ef 52			dw clrstack 
4ec7 23 53			dw type 
4ec9			;	dw stest 
4ec9 48 53			dw strncpy 
4ecb			;	dw list 
4ecb a9 53			dw start1 
4ecd b9 53			dw start2 
4ecf			;	dw start3 
4ecf			;	dw start3b 
4ecf			;	dw start3c 
4ecf			 
4ecf				; (unit) testing words 
4ecf			 
4ecf			;	dw mtesta 
4ecf			;	dw mtestb 
4ecf			;	dw mtestc 
4ecf			;	dw mtestd 
4ecf			;	dw mteste 
4ecf			 
4ecf				; demo/game words 
4ecf			 
4ecf			;        dw game3w 
4ecf			;        dw game3p 
4ecf			;        dw game3sc 
4ecf			;        dw game3vsi 
4ecf			;        dw game3vs 
4ecf				 
4ecf 12 5e			dw game2b 
4ed1 80 5e			dw game2bf 
4ed3 ca 5e			dw game2mba 
4ed5 60 5f			dw game2mbas 
4ed7 a2 5f			dw game2mb 
4ed9			 
4ed9 d3 5a			dw game1 
4edb e4 5a			dw game1a 
4edd 46 5b			dw game1b 
4edf 7b 5b			dw game1c 
4ee1 b1 5b			dw game1d 
4ee3 e2 5b			dw game1s 
4ee5 f6 5b			dw game1t 
4ee7 0b 5c			dw game1f 
4ee9 3f 5c			dw game1z 
4eeb 83 5c			dw game1zz 
4eed			 
4eed ed 58			dw test5 
4eef 25 59			dw test6 
4ef1 5d 59			dw test7 
4ef3 71 59			dw test8 
4ef5 9d 59			dw test9 
4ef7 b3 59			dw test10 
4ef9				 
4ef9 5a 5d		        dw ssv5 
4efb 3e 5d		        dw ssv4 
4efd 22 5d		        dw ssv3 
4eff ec 5c		        dw ssv2 
4f01 73 5d		        dw ssv1 
4f03 bb 5d		        dw ssv1cpm 
4f05			;	dw keyup 
4f05			;	dw keydown 
4f05			;	dw keyleft 
4f05			;	dw keyright 
4f05			;	dw 	keyf1 
4f05			;	dw keyf2 
4f05			;	dw keyf3 
4f05			;	dw keyf4 
4f05			;	dw keyf5 
4f05			;	dw keyf6 
4f05			;	dw keyf7 
4f05			;	dw keyf8 
4f05			;	dw keyf9 
4f05			;	dw keyf10 
4f05			;	dw keyf11 
4f05			;	dw keyf12 
4f05			;	dw keytab 
4f05			;	dw keycr 
4f05			;	dw keyhome 
4f05			;	dw keyend 
4f05			;	dw keybs 
4f05 00 00			db 0, 0	 
4f07			 
4f07			 
4f07			; File Editor 
4f07			 
4f07			; ( id - ) use 'e' to edit the displayed line 
4f07 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4f28 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4f5d			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4f5d .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4f95			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4f95			 
4f95			; SPI Net support words 
4f95			 
4f95			; v0! = node to send to 
4f95			; ( str count - ) 
4f95 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4fee			 
4fee			; spiputc ( char node - ) 
4fee .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
5022			; spiputc ( u node - ) 
5022 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
5050			 
5050			; spigetc ( - n ) 
5050 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
5079			 
5079			; getnode ( - n ) 
5079 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
50a6			 
50a6			; ( str node - )  
50a6 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
510c			; store string ( str i - ) 
510c			 
510c			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
510c .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
5161			 
5161			; get string ( addr i -  )    TO FIX 
5161			 
5161 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
51b9			 
51b9			 
51b9			; NETCHAT (TODO) 
51b9			; Program to allow two nodes to chat with eachother 
51b9			; 
51b9			; v0 - target node 
51b9			;  
51b9			; accept input at 0,0 
51b9			; if input is string send spitype to target node 
51b9			; starting at row 2,0 , while spigetchr is not zero ->  
51b9			; 
51b9			; 
51b9			; TODO add paging of get request 
51b9			 
51b9			; ( node - ) 
51b9 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
51d8 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5230 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
52a8			 
52a8			 
52a8			; Long read of currently open file 
52a8 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
52ef			 
52ef			; clear stack  
52ef			 
52ef .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
5323			 
5323			; type ( addr count - ) 
5323 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
5348			 
5348			; some direct memory words 
5348			; strncpy ( len t f -- t ) 
5348			 
5348 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
53a9			 
53a9 .. 00		start1:     	db ": bpon $00 bp ;",0 
53b9 .. 00		start2:     	db ": bpoff $01 bp ;",0 
53ca .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
5445 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
54a5			 
54a5			 
54a5			; a handy word to list items on the stack 
54a5			 
54a5 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
550f			 
550f			 
550f			; test stack  
550f			; rnd8 stest 
550f			 
550f .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5586			 
5586			; random malloc and free cycles 
5586			 
5586 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
563b			 
563b			; fixed malloc and free cycles 
563b			 
563b .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
56de			 
56de			; fixed double string push and drop cycle  
56de			 
56de .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5793			 
5793			; consistent fixed string push and drop cycle  
5793			 
5793 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5837			 
5837 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
58ed			 
58ed			;test1:		db ": aa 1 2 3 ;", 0 
58ed			;test2:     	db "111 aa 888 999",0 
58ed			;test3:     	db ": bb 77 ;",0 
58ed			;test4:     	db "$02 $01 do i . loop bb",0 
58ed			 
58ed .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5925 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
595d .. 00		test7:     	db ": box hline vline ;",0 
5971 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
599d .. 00		test9:     	db ": sw $01 adsp world ;",0 
59b3 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
59d8 .. 00		test11:     	db "hello create .",0 
59e7 .. 00		test12:     	db "hello2 create .",0 
59f7			 
59f7			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
59f7			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
59f7			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
59f7			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
59f7			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
59f7			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
59f7			 
59f7			;iftest1:     	db "$0001 IF cls .",0 
59f7			;iftest2:     	db "$0000 IF cls .",0 
59f7			;iftest3:     	db "$0002 $0003 - IF cls .",0 
59f7			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
59f7			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
59f7			 
59f7			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
59f7			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
59f7			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
59f7			 
59f7			 
59f7 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
5a1b .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
5a4b .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
5a70 .. 00		sound4: db ": cha $00 ; ",0 
5a7d .. 00		sound5: db ": chb $20 ; ",0 
5a8a .. 00		sound6: db ": chc $40 ; ",0 
5a97 .. 00		sound7: db ": chd $60 ; ",0 
5aa4 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
5abc .. 00		sound9: db ": cvol $90 + + note ; ", 0 
5ad3			 
5ad3			 
5ad3			 
5ad3			 
5ad3			; a small guess the number game 
5ad3			 
5ad3 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5ae4 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5b46			 
5b46 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5b7b .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5bb1 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5be2 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5bf6 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5c0b .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5c3f .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5c83			 
5c83			; Using 'ga' save a high score across multiple runs using external storage 
5c83			 
5c83 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5cec			 
5cec			 
5cec			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5cec			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5cec			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5cec			 
5cec			; simple screen saver to test code memory reuse to destruction 
5cec			 
5cec .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5d22 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5d3e .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5d5a .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5d73 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5dbb .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5e12			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5e12			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5e12			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5e12			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5e12			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5e12			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5e12			 
5e12			 
5e12			 
5e12			; minesweeper/battleship finding game 
5e12			; draws a game board of random ship/mine positions 
5e12			; user enters coords to see if it hits on 
5e12			; game ends when all are hit 
5e12			; when hit or miss says how many may be in the area 
5e12			 
5e12			; setup the game board and then hide it 
5e12 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5e80 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5eca			; prompt for where to target 
5eca .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5f60 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5f85			; TODO see if the entered coords hits or misses pushes char hit of miss 
5f85 .. 00		game2mbht:      db ": mbckht nop ;",0 
5f94 .. 00		game2mbms:      db ": mbcms nop ;",0 
5fa2			; TODO how many might be near by 
5fa2 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
601f			 
601f			; Game 3 
601f			 
601f			; Vert scroller ski game - avoid the trees! 
601f			 
601f			; v0 score (ie turns) 
601f			; v1 player pos 
601f			; v2 left wall 
601f			; v3 right wall 
601f			 
601f			; Draw side walls randomly 
601f			 
601f .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
604d			 
604d			; Draw player 
604d .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
606b			 
606b			; TODO Get Key 
606b			 
606b			; TODO Move left right 
606b			 
606b			; scroll and move walls a bit 
606b			 
606b .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
609c			 
609c			; main game loop 
609c			 
609c .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
60c8 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6107			 
6107			; key board defs 
6107			 
6107 .. 00		keyup:       db ": keyup $05 ;",0 
6115 .. 00		keydown:       db ": keydown $0a ;",0 
6125 .. 00		keyleft:       db ": keyleft $0b ;",0 
6135 .. 00		keyright:       db ": keyright $0c ;",0 
6146 .. 00		keyf1:       db ": keyf1 $10 ;",0 
6154 .. 00		keyf2:       db ": keyf2 $11 ;",0 
6162 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6170 .. 00		keyf4:       db ": keyf4 $13 ;",0 
617e .. 00		keyf5:       db ": keyf5 $14 ;",0 
618c .. 00		keyf6:       db ": keyf6 $15 ;",0 
619a .. 00		keyf7:       db ": keyf7 $16 ;",0 
61a8 .. 00		keyf8:       db ": keyf8 $17 ;",0 
61b6 .. 00		keyf9:       db ": keyf9 $18 ;",0 
61c4 .. 00		keyf10:       db ": keyf10 $19 ;",0 
61d3 .. 00		keyf11:       db ": keyf11 $1a ;",0 
61e2 .. 00		keyf12:       db ": keyf12 $1b ;",0 
61f1			 
61f1 .. 00		keytab:       db ": keytab $09 ;",0 
6200 .. 00		keycr:       db ": keycr $0d ;",0 
620e .. 00		keyhome:       db ": keyhome $0e ;",0 
621e .. 00		keyend:       db ": keyend $0f ;",0 
622d .. 00		keybs:       db ": keybs $08 ;",0 
623b			 
623b			   
623b			 
623b			 
623b			 
623b			; eof 
# End of file forth_autostart.asm
623b			 
623b			 
623b			 
623b			; stack over and underflow checks 
623b			 
623b			; init the words to detect the under/overflow 
623b			 
623b			chk_stk_init: 
623b				; a vague random number to check so we dont get any "lucky" hits 
623b 3e 2d			ld a, 45 
623d 6f				ld l, a 
623e 00				nop 
623f 3e 17			ld a, 23 
6241 67				ld h, a 
6242			 
6242 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
6245			 
6245			;	ld (chk_stund), hl	; stack points.... 
6245 22 00 ef			ld (chk_stovr), hl 
6248 22 ec e9			ld (chk_ret_und), hl 
624b 22 aa e9			ld (chk_ret_ovr), hl 
624e 22 28 e9			ld (chk_loop_ovr), hl 
6251 22 26 e8			ld (chk_data_ovr), hl 
6254 c9				ret 
6255				 
6255			check_stacks: 
6255				; check all stack words 
6255			 
6255 e5				push hl 
6256 d5				push de 
6257			 
6257			;	ld de,(chk_word) 
6257			;	ld hl, (chk_stund)	; stack points.... 
6257			;	if DEBUG_STK_FAULT 
6257			;		DMARK "FAa" 
6257			;		CALLMONITOR 
6257			;	endif 
6257			;	call cmp16 
6257			;	jp z, .chk_faulta 
6257			; 
6257			;	ld de, sfaultsu 
6257			;	jp .chk_fault 
6257			 
6257 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
625a ed 5b 9d e2		ld de,(chk_word) 
625e				if DEBUG_STK_FAULT 
625e					DMARK "FAb" 
625e					CALLMONITOR 
625e				endif 
625e cd 04 0e			call cmp16 
6261 28 06			jr z, .chk_fault1 
6263 11 04 63			ld de, sfaultso 
6266 c3 b8 62			jp .chk_fault 
6269			.chk_fault1:  
6269 2a ec e9			ld hl, (chk_ret_und) 
626c ed 5b 9d e2		ld de,(chk_word) 
6270				if DEBUG_STK_FAULT 
6270					DMARK "FAU" 
6270					CALLMONITOR 
6270				endif 
6270 cd 04 0e			call cmp16 
6273 ca 7c 62			jp z, .chk_fault2 
6276 11 14 63			ld de, sfaultru 
6279 c3 b8 62			jp .chk_fault 
627c			.chk_fault2:  
627c 2a aa e9			ld hl, (chk_ret_ovr) 
627f ed 5b 9d e2		ld de,(chk_word) 
6283				if DEBUG_STK_FAULT 
6283					DMARK "FA1" 
6283					CALLMONITOR 
6283				endif 
6283 cd 04 0e			call cmp16 
6286 ca 8f 62			jp z, .chk_fault3 
6289 11 22 63			ld de, sfaultro 
628c c3 b8 62			jp .chk_fault 
628f			.chk_fault3:  
628f 2a 28 e9			ld hl, (chk_loop_ovr) 
6292 ed 5b 9d e2		ld de,(chk_word) 
6296				if DEBUG_STK_FAULT 
6296					DMARK "FA2" 
6296					CALLMONITOR 
6296				endif 
6296 cd 04 0e			call cmp16 
6299 ca a2 62			jp z, .chk_fault4 
629c 11 3c 63			ld de, sfaultlo 
629f c3 b8 62			jp .chk_fault 
62a2			.chk_fault4:  
62a2 2a 26 e8			ld hl, (chk_data_ovr) 
62a5 ed 5b 9d e2		ld de,(chk_word) 
62a9				if DEBUG_STK_FAULT 
62a9					DMARK "FA3" 
62a9					CALLMONITOR 
62a9				endif 
62a9 cd 04 0e			call cmp16 
62ac ca b5 62			jp z, .chk_fault5 
62af 11 56 63			ld de, sfaultdo 
62b2 c3 b8 62			jp .chk_fault 
62b5			 
62b5			 
62b5			.chk_fault5:  
62b5 d1				pop de 
62b6 e1				pop hl 
62b7			 
62b7 c9				ret 
62b8			 
62b8 cd b9 0b		.chk_fault: 	call clear_display 
62bb 3e 28				ld a, display_row_2 
62bd cd cc 0b				call str_at_display 
62c0 11 e6 62				   ld de, .stackfault 
62c3 3e 00				ld a, display_row_1 
62c5 cd cc 0b				call str_at_display 
62c8 11 6b ee				    ld de, debug_mark 
62cb 3e 11				ld a, display_row_1+17 
62cd cd cc 0b				call str_at_display 
62d0 cd dc 0b				call update_display 
62d3			 
62d3				; prompt before entering montior for investigating issue 
62d3			 
62d3 3e 78			ld a, display_row_4 
62d5 11 44 19			ld de, endprog 
62d8			 
62d8 cd dc 0b			call update_display		 
62db			 
62db cd ca 1b			call next_page_prompt 
62de			 
62de d1				pop de 
62df e1				pop hl 
62e0 cd 98 19				call monitor 
62e3 c3 a1 18				jp warmstart 
62e6					;jp 0 
62e6					;halt 
62e6			 
62e6			 
62e6			 
62e6 .. 00		.stackfault: 	db "Stack fault:",0 
62f3			 
62f3 .. 00		sfaultsu: 	db	"Stack under flow",0 
6304 .. 00		sfaultso: 	db	"Stack over flow",0 
6314 .. 00		sfaultru:	db "RTS underflow",0 
6322 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
633c .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6356 .. 00		sfaultdo:	db "DTS overflow", 0 
6363			 
6363			 
6363			fault_dsp_under: 
6363 11 75 63			ld de, .dsp_under 
6366 c3 25 64			jp .show_fault 
6369			 
6369			fault_rsp_under: 
6369 11 83 63			ld de, .rsp_under 
636c c3 25 64			jp .show_fault 
636f			fault_loop_under: 
636f 11 91 63			ld de, .loop_under 
6372 c3 25 64			jp .show_fault 
6375			 
6375 .. 00		.dsp_under: db "DSP Underflow",0 
6383 .. 00		.rsp_under: db "RSP Underflow",0 
6391 .. 00		.loop_under: db "LOOP Underflow",0 
63a0			 
63a0			 
63a0 d5			type_faultn: 	push de 
63a1 e5					push hl 
63a2 cd b9 0b				call clear_display 
63a5 11 cc 63				   ld de, .typefaultn 
63a8 3e 00				ld a, display_row_1 
63aa cd cc 0b				call str_at_display 
63ad 11 6b ee				    ld de, debug_mark 
63b0 3e 11				ld a, display_row_1+17 
63b2 cd cc 0b				call str_at_display 
63b5 cd dc 0b				call update_display 
63b8			 
63b8				; prompt before entering montior for investigating issue 
63b8			 
63b8 3e 78			ld a, display_row_4 
63ba 11 44 19			ld de, endprog 
63bd			 
63bd cd dc 0b			call update_display		 
63c0			 
63c0 cd ca 1b			call next_page_prompt 
63c3			 
63c3 e5					push hl 
63c4 d5					push de 
63c5 cd 98 19				call monitor 
63c8 c3 a1 18				jp warmstart 
63cb 76					halt 
63cc			 
63cc			 
63cc .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
63e3			 
63e3 d5			type_faults: 	push de 
63e4 e5					push hl 
63e5 cd b9 0b				call clear_display 
63e8 11 0e 64				   ld de, .typefaults 
63eb 3e 00				ld a, display_row_1 
63ed cd cc 0b				call str_at_display 
63f0 11 6b ee				    ld de, debug_mark 
63f3 3e 11				ld a, display_row_1+17 
63f5 cd cc 0b				call str_at_display 
63f8 cd dc 0b				call update_display 
63fb			 
63fb				; prompt before entering montior for investigating issue 
63fb			 
63fb 3e 78			ld a, display_row_4 
63fd 11 44 19			ld de, endprog 
6400			 
6400 cd dc 0b			call update_display		 
6403			 
6403 cd ca 1b			call next_page_prompt 
6406			 
6406 e1					pop hl 
6407 d1					pop de 
6408 cd 98 19				call monitor 
640b c3 a1 18				jp warmstart 
640e			 
640e			 
640e .. 00		.typefaults: db "STR Type Expected TOS!",0 
6425			 
6425			.show_fault: 	 
6425 d5					push de 
6426 cd b9 0b				call clear_display 
6429 d1					pop de 
642a 3e 00				ld a, display_row_1 
642c cd cc 0b				call str_at_display 
642f 11 6b ee				    ld de, debug_mark 
6432 3e 11				ld a, display_row_1+17 
6434 cd cc 0b				call str_at_display 
6437 cd dc 0b				call update_display 
643a			 
643a				; prompt before entering montior for investigating issue 
643a			 
643a 3e 78			ld a, display_row_4 
643c 11 44 19			ld de, endprog 
643f			 
643f cd dc 0b			call update_display		 
6442			 
6442 cd ca 1b			call next_page_prompt 
6445			 
6445 e1					pop hl 
6446 d1					pop de 
6447 cd 98 19				call monitor 
644a			; do a dump to cli and not warmstart so we preserve all of the uwords.  
644a			; TODO Make optional fault restart to cli or warm boot? 
644a					;jp warmstart 
644a c3 eb 18				jp cli 
644d 76					halt 
644e			 
644e			; handle the auto run of code from files in storage 
644e			 
644e			 
644e			include "forth_startup.asm" 
644e			; Which startup method to use? 
644e			; 
644e			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
644e			; followed by loading of a list of scripts in eeprom 
644e			 
644e			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
644e			; from eeprom 
644e			 
644e			; Select with define in main stubs 
644e			 
644e			if STARTUP_V1 
644e				include "forth_startupv1.asm" 
644e			; Startup script loading version 1 
644e			 
644e			; If SE storage is available first stage is to use the selected file 
644e			; then go through the eeprom list 
644e			 
644e .. 00		sprompt1: db "Startup load...",0 
645e .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6474			 
6474			 
6474			 
6474			 
6474			forth_startup: 
6474 21 c5 4e			ld hl, startcmds 
6477 3e 00			ld a, 0 
6479 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
647c			 
647c e5			.start1:	push hl 
647d cd b9 0b			call clear_display 
6480 11 4e 64			ld de, sprompt1 
6483 3e 00		        ld a, display_row_1 
6485 cd cc 0b			call str_at_display 
6488 11 5e 64			ld de, sprompt2 
648b 3e 28		        ld a, display_row_2 
648d cd cc 0b			call str_at_display 
6490 e1				pop hl 
6491 e5				push hl 
6492 5e				ld e,(hl) 
6493 23				inc hl 
6494 56				ld d,(hl) 
6495 3e 50		        ld a, display_row_3 
6497 cd cc 0b			call str_at_display 
649a cd dc 0b			call update_display 
649d			 
649d			 
649d 3a e7 e6			ld a, (os_last_cmd) 
64a0 fe 00			cp 0 
64a2 28 05			jr z, .startprompt 
64a4 cd e5 0a			call delay250ms 
64a7 18 24			jr .startdo 
64a9				 
64a9				 
64a9			 
64a9			.startprompt: 
64a9			 
64a9 3e 9f			ld a,display_row_4 + display_cols - 1 
64ab 11 c8 1b		        ld de, endprg 
64ae cd cc 0b			call str_at_display 
64b1 cd dc 0b			call update_display 
64b4 cd f1 0a			call delay1s 
64b7 cd 26 66			call cin_wait 
64ba						 
64ba fe 2a			cp '*' 
64bc 28 5e			jr z, .startupend1 
64be fe 23			cp '#' 
64c0 20 07			jr nz, .startno 
64c2 3e 01			ld a, 1 
64c4 32 e7 e6			ld (os_last_cmd),a 
64c7 18 04			jr .startdo 
64c9 fe 31		.startno:	cp '1' 
64cb 28 3a			jr z,.startnxt  
64cd			 
64cd				; exec startup line 
64cd			.startdo:	 
64cd e1				pop hl 
64ce e5				push hl 
64cf				 
64cf 5e				ld e,(hl) 
64d0 23				inc hl 
64d1 56				ld d,(hl) 
64d2 eb				ex de,hl 
64d3			 
64d3 e5				push hl 
64d4			 
64d4 3e 00			ld a, 0 
64d6				;ld a, FORTH_END_BUFFER 
64d6 cd 4f 12			call strlent 
64d9 23				inc hl   ; include zero term to copy 
64da 06 00			ld b,0 
64dc 4d				ld c,l 
64dd e1				pop hl 
64de 11 c1 e2			ld de, scratch 
64e1 ed b0			ldir 
64e3			 
64e3			 
64e3 21 c1 e2			ld hl, scratch 
64e6 cd 4d 20			call forthparse 
64e9 cd 8d 20			call forthexec 
64ec cd 9f 1f			call forthexec_cleanup 
64ef			 
64ef 3e 78			ld a, display_row_4 
64f1 11 44 19			ld de, endprog 
64f4			 
64f4 cd dc 0b			call update_display		 
64f7			 
64f7 3a e7 e6			ld a, (os_last_cmd) 
64fa fe 00			cp 0 
64fc 20 09			jr nz, .startnxt 
64fe cd ca 1b			call next_page_prompt 
6501 cd b9 0b		        call clear_display 
6504 cd dc 0b			call update_display		 
6507			 
6507				; move onto next startup line? 
6507			.startnxt: 
6507			 
6507 cd e5 0a			call delay250ms 
650a e1				pop hl 
650b			 
650b 23				inc hl 
650c 23				inc hl 
650d			 
650d e5				push hl 
650e 5e				ld e, (hl) 
650f 23				inc hl 
6510 56				ld d, (hl) 
6511 e1				pop hl 
6512				; TODO replace 0 test 
6512			 
6512 eb				ex de, hl 
6513 cd 0f 0e			call ishlzero 
6516			;	ld a,e 
6516			;	add d 
6516			;	cp 0    ; any left to do? 
6516 eb				ex de, hl 
6517 c2 7c 64			jp nz, .start1 
651a 18 01			jr .startupend 
651c			 
651c e1			.startupend1: pop hl 
651d			.startupend: 
651d			 
651d cd b9 0b			call clear_display 
6520 cd dc 0b			call update_display 
6523 c9				ret 
6524			if STORAGE_SE 
6524			 
6524			sprompt3: db "Loading from start-up file?:",0 
6524			sprompt4: db "(Y=Any key/N=No)",0 
6524			 
6524			 
6524			forth_autoload: 
6524			 
6524				; load block 0 of store 1 
6524				 
6524				ld a, $fe      ; bit 0 clear 
6524				ld (spi_device), a 
6524			 
6524				call storage_get_block_0 
6524			 
6524				ld a, (store_page+STORE_0_AUTOFILE) 
6524			 
6524				cp 0 
6524				ret z     ; auto start not enabled 
6524			 
6524				call clear_display 
6524			 
6524				; set bank 
6524			 
6524					ld a, (store_page+STORE_0_BANKRUN) 
6524					ld (spi_device), a 
6524			 
6524				; get file id to load from and get the file name to display 
6524			 
6524					ld a, (store_page+STORE_0_FILERUN) 
6524			 
6524					ld l, 0 
6524					ld h, a 
6524					ld de, store_page 
6524			 
6524					if DEBUG_FORTH_WORDS 
6524						DMARK "ASp" 
6524						CALLMONITOR 
6524					endif 
6524					call storage_read 
6524			 
6524					if DEBUG_FORTH_WORDS 
6524						DMARK "ASr" 
6524						CALLMONITOR 
6524					endif 
6524			 
6524					call ishlzero 
6524					ret z             ; file not found 
6524			 
6524					ld a, display_row_2 + 10 
6524					ld de, store_page+3 
6524					call str_at_display 
6524				 
6524			; 
6524			 
6524				ld a, display_row_1+5 
6524				ld de, sprompt3 
6524				call str_at_display 
6524				ld a, display_row_3+15 
6524				ld de, sprompt4 
6524				call str_at_display 
6524			 
6524				call update_display 
6524			 
6524				call cin_wait 
6524				cp 'n' 
6524				ret z 
6524				cp 'N' 
6524				ret z 
6524			 
6524				call delay1s 
6524			 
6524				ld a, (store_page+2) 
6524				ld (store_openmaxext), a    ; save count of ext 
6524				ld a, 1  
6524				ld (store_openext), a    ; save count of ext 
6524			 
6524			.autof:  
6524				ld l , a 
6524				 
6524				ld a, (store_page) 
6524				ld h, a	 
6524				ld de, store_page 
6524					if DEBUG_FORTH_WORDS 
6524						DMARK "ASl" 
6524						CALLMONITOR 
6524					endif 
6524					call storage_read 
6524				call ishlzero 
6524				ret z 
6524			;	jr z, .autoend 
6524			 
6524					if DEBUG_FORTH_WORDS 
6524						DMARK "ASc" 
6524						CALLMONITOR 
6524					endif 
6524				ld de, store_page+2 
6524				ld a, display_row_4 
6524				call str_at_display 
6524			 
6524				call update_display 
6524				call delay250ms 
6524			 
6524			 
6524			 
6524				ld hl, store_page+2 
6524				call forthparse 
6524				call forthexec 
6524				call forthexec_cleanup 
6524			 
6524				 
6524				ld a, (store_openext) 
6524				inc a 
6524				ld (store_openext), a    ; save count of ext 
6524			 
6524				jr .autof 
6524			;.autofdone: 
6524			; 
6524			;		if DEBUG_FORTH_WORDS 
6524			;			DMARK "ASx" 
6524			;			CALLMONITOR 
6524			;		endif 
6524			;;	call clear_display 
6524			;	ret 
6524			 
6524			 
6524			 
6524			endif 
# End of file forth_startupv1.asm
6524			endif 
6524			if STARTUP_V2 
6524				include "forth_startupv2.asm" 
6524			endif 
6524			 
# End of file forth_startup.asm
6524			 
6524			; eof 
# End of file forth_kernel.asm
6524			;include "nascombasic.asm" 
6524			 
6524			 
6524			; find out where the code ends if loaded into RAM (for SC114) 
6524			;endofcode:  
6524			;	nop 
6524			 
6524			 
6524			; jump to nmi vector 
6524			 
6524			init_nmi: 
6524 3e c9			ld a, $c9   ; RET 
6526 32 72 ee			ld (nmi_vector), a 
6529 c9				ret 
652a			nmi: 
652a e5				push hl 
652b d5				push de 
652c c5				push bc 
652d f5				push af 
652e cd 72 ee			call nmi_vector 
6531 f5				push af 
6532 c5				push bc 
6533 d5				push de 
6534 e5				push hl 
6535 ed 4d			reti 
6537			 
6537			 
6537			; eof 
6537			 
# End of file main.asm
6537			;include "firmware_lcd_4x40.asm" 
6537			;;include "firmware_lcd_4x20.asm" 
6537			include "firmware_cpm_display.asm" 
6537			 
6537			; Serial display interface for SC114 
6537			 
6537			 
6537			display_row_1: equ 0 
6537			display_row_2: equ display_row_1+display_cols 
6537			display_row_3: equ display_row_2 + display_cols 
6537			display_row_4: equ display_row_3 + display_cols 
6537			 
6537			kLCDWidth:  EQU display_cols             ;Width in characters 
6537			kLCD_Line1: EQU 0x00  
6537			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
6537			; E1 
6537			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
6537			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
6537			 
6537			lcd_init: 
6537				; no init as handled by the SCM bios 
6537 c9				ret 
6538			 
6538			 
6538			; low level functions for direct screen writes 
6538			 
6538			; output char at pos? 
6538			fLCD_Str: 
6538			        ;out (SC114_SIO_1_OUT),a 
6538 c5				push bc 
6539 d5				push de 
653a 5f				ld e, a 
653b			; TODO Replace with CP/M BIOS call 
653b 0e 02			ld c, $02 
653d cd 05 00			call 5 
6540 d1				pop de 
6541 c1				pop bc 
6542 c9				ret 
6543			 
6543			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
6543			fLCD_Pos: 
6543				; use ASCII escape to position 
6543			        ;out (SC114_SIO_1_OUT),a 
6543 c5				push bc 
6544 d5				push de 
6545 5f				ld e, a 
6546 0e 02			ld c, $02 
6548			; TODO Replace with CP/M BIOS call 
6548 cd 05 00			call 5 
654b d1				pop de 
654c c1				pop bc 
654d			 
654d c9				ret 
654e			 
654e			; output char at pos 
654e			fLCD_Data: 
654e			      ;  out (SC114_SIO_1_OUT),a 
654e c5				push bc 
654f d5				push de 
6550 0e 02			ld c, $02 
6552 5f				ld e, a 
6553			; TODO Replace with CP/M BIOS call 
6553 cd 05 00			call 5 
6556 d1				pop de 
6557 c1				pop bc 
6558			 
6558 c9				ret 
6559			 
6559			; ascii cls  
6559			 
6559 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
655d			 
655d 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
6574			;.clscpm: db 3, $3c,"$" 
6574			 
6574			; write the frame buffer given in hl to hardware  
6574			write_display: 
6574			 
6574			API: equ 0 
6574			 
6574			if API 
6574				push bc 
6574				ld b, 4 
6574			 
6574			        ld (display_write_tmp), hl 	  
6574			 
6574				; clear and home cursor 
6574			 
6574				ld c, 9 
6574				ld de, .cls 
6574			; TODO Replace with CP/M BIOS call 
6574				call 5 
6574			 
6574			 
6574			.writeln: 
6574			 
6574				ld de, (display_write_tmp) 
6574				ld c, 6 
6574			; TODO Replace with CP/M BIOS call 
6574				rst $30 
6574				ld c, 7 
6574				rst $30 
6574			 
6574				ld hl, (display_write_tmp) 
6574				ld de, display_cols 
6574				add hl,de 
6574				ld (display_write_tmp),hl 
6574			 
6574				djnz  .writeln 
6574			 
6574				pop bc 
6574			 
6574			 
6574				ret 
6574			endif 
6574 e5				push hl 
6575 c5				push bc 
6576 d5				push de 
6577			 
6577			;	ld c, 2 
6577			;	;ld de, .cls 
6577			;	ld a, 27 
6577			;	rst $30 
6577			;	ld c, 2 
6577			;	;ld de, .cls 
6577			;	ld a, '[' 
6577			;	rst $30 
6577			; 
6577			;	ld c, 2 
6577			;	;ld de, .cls 
6577			;	ld a, 'H' 
6577			;	rst $30 
6577			; 
6577			 
6577			 
6577			; lots of CR/LF 
6577			;	ld c, 9 
6577			;	ld de, .clscpm 
6577			;	call 5 
6577			 
6577			; xterm cls 
6577 0e 02			ld c, 2 
6579 1e 1b			ld e, 27 
657b cd 05 00			call 5 
657e			; cls causes too much flicker 
657e			;	ld c, 2 
657e			;	ld e, 'c' 
657e			;	call 5 
657e			 
657e			; use xterm home instead 
657e 0e 02			ld c, 2 
6580 1e 5b			ld e, '[' 
6582 cd 05 00			call 5 
6585 0e 02			ld c, 2 
6587 1e 48			ld e, 'H' 
6589 cd 05 00			call 5 
658c			LLL: equ 0 
658c			 
658c			if LLL 
658c			 
658c				ld c, 2 
658c				;ld de, .cls 
658c				ld e, 27 
658c			; TODO Replace with CP/M BIOS call 
658c				call 5 
658c			 
658c			 
658c				ld c, 2 
658c				;ld de, .cls 
658c				ld e, '[' 
658c			; TODO Replace with CP/M BIOS call 
658c				call 5 
658c				ld c, 2 
658c				;ld de, .cls 
658c				ld e, '2' 
658c			; TODO Replace with CP/M BIOS call 
658c				call 5 
658c				ld c, 2 
658c				;ld de, .cls 
658c				ld e, 'J' 
658c			; TODO Replace with CP/M BIOS call 
658c				call 5 
658c			 
658c			endif 
658c			 
658c d1				pop de 
658d c1				pop bc 
658e e1				pop hl 
658f			 
658f			 
658f 22 c9 eb		        ld (display_write_tmp), hl 	  
6592 3e 00			ld a, kLCD_Line1 
6594			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
6594 06 28			ld b, display_cols 
6596 ed 5b c9 eb		ld de, (display_write_tmp) 
659a cd 1d 66			call write_len_string 
659d				 
659d			 
659d e5			push hl 
659e d5			push de 
659f c5			push bc 
65a0 0e 02			ld c, 2 
65a2 1e 0a			ld e, 10 
65a4 cd 05 00			call 5 
65a7 0e 02			ld c, 2 
65a9 1e 0d			ld e, 13 
65ab cd 05 00			call 5 
65ae			; TODO Replace with CP/M BIOS call 
65ae				;rst $30 
65ae c1			pop bc 
65af d1			pop de 
65b0 e1			pop hl 
65b1			 
65b1				 
65b1 2a c9 eb			ld hl, (display_write_tmp) 
65b4 11 28 00			ld de, display_cols 
65b7 19				add hl,de 
65b8 22 c9 eb			ld (display_write_tmp),hl 
65bb			 
65bb				 
65bb 3e 28			ld a, kLCD_Line2 
65bd			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
65bd 06 28			ld b, display_cols 
65bf ed 5b c9 eb		ld de, (display_write_tmp) 
65c3 cd 1d 66			call write_len_string 
65c6				 
65c6 2a c9 eb			ld hl, (display_write_tmp) 
65c9 11 28 00			ld de, display_cols 
65cc 19				add hl,de 
65cd 22 c9 eb			ld (display_write_tmp),hl 
65d0			 
65d0 e5			push hl 
65d1 d5			push de 
65d2 c5			push bc 
65d3 0e 07			ld c, 7 
65d5			; TODO Replace with CP/M BIOS call 
65d5				;rst $30 
65d5 0e 02			ld c, 2 
65d7 1e 0a			ld e, 10 
65d9 cd 05 00			call 5 
65dc 0e 02			ld c, 2 
65de 1e 0d			ld e, 13 
65e0 cd 05 00			call 5 
65e3 c1			pop bc 
65e4 d1			pop de 
65e5 e1			pop hl 
65e6			 
65e6				 
65e6 3e 50			ld a, kLCD_Line3 
65e8			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
65e8 06 28			ld b, display_cols 
65ea ed 5b c9 eb		ld de, (display_write_tmp) 
65ee cd 1d 66			call write_len_string 
65f1				 
65f1 2a c9 eb			ld hl, (display_write_tmp) 
65f4 11 28 00			ld de, display_cols 
65f7 19				add hl,de 
65f8 22 c9 eb			ld (display_write_tmp),hl 
65fb			 
65fb e5			push hl 
65fc d5			push de 
65fd c5			push bc 
65fe 0e 07			ld c, 7 
6600			; TODO Replace with CP/M BIOS call 
6600				;rst $30 
6600 0e 02			ld c, 2 
6602 1e 0a			ld e, 10 
6604 cd 05 00			call 5 
6607 0e 02			ld c, 2 
6609 1e 0d			ld e, 13 
660b cd 05 00			call 5 
660e c1			pop bc 
660f d1			pop de 
6610 e1			pop hl 
6611			 
6611				 
6611 3e 78			ld a, kLCD_Line4 
6613			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
6613 06 28			ld b, display_cols 
6615 ed 5b c9 eb		ld de, (display_write_tmp) 
6619 cd 1d 66			call write_len_string 
661c c9					ret 
661d			 
661d			 
661d				; write out a fixed length string given in b from de 
661d			 
661d 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
661e cd 4e 65		            CALL fLCD_Data      ;Write character to display 
6621 13				inc de 
6622 10 f9			djnz write_len_string 
6624 c9				ret 
6625			 
6625			 
6625			; eof 
# End of file firmware_cpm_display.asm
6625			;include "firmware_key_5x10.asm" 
6625			;;include "firmware_key_4x10.asm" 
6625			include "firmware_key_cpm.asm" 
6625			; Serial keyboard interface for SC114 
6625			 
6625			 
6625			key_init: 
6625				; no init as handled by the SCM bios 
6625 c9				ret 
6626			 
6626			 
6626			cin_wait: 
6626			;	ld a, 0 
6626			;	ret 
6626			 
6626				;in a,(SC114_SIO_1_IN) 
6626			        ; Use SCM API to get from whatever console device we are using 
6626			 
6626			; TODO Replace with CP/M BIOS call 
6626 c5				push bc 
6627 0e 01			ld c, $01 
6629 cd 05 00			call 5 
662c c1				pop bc 
662d c9				ret 
662e			 
662e			cin: 
662e			 
662e			 
662e c5				push bc 
662f			 
662f				; any key waiting to process? 
662f			; TODO Replace with CP/M BIOS call 
662f 0e 06			ld c, $06 
6631 cd 05 00			call 5 
6634 28 0d			jr z, .cin_skip 
6636			 
6636				; yep, get it 
6636			 
6636 0e 01			ld c, $01 
6638			; TODO Replace with CP/M BIOS call 
6638 cd 05 00			call 5 
663b			 
663b fe 7f			cp $7f     ; back space 
663d 20 02			jr nz, .skipbs 
663f 3e 08			ld a, KEY_BS 
6641			.skipbs: 
6641			 
6641 c1				pop bc 
6642 c9				ret 
6643			.cin_skip: 
6643 3e 00			ld a, 0 
6645 c1				pop bc 
6646 c9				ret 
6647			 
6647			 
6647			 
6647			 
# End of file firmware_key_cpm.asm
6647			endofcode:  
6647			baseram:  
6647 00				nop 
6648			 
6648			heap_start: equ baseram+15  ; Starting address of heap 
6648			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
6648			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
6648			;VDU:  EQU     endofcode           ; BASIC Work space 
6648			; eof 
6648			 
# End of file os_mega_cpm.asm
6648
